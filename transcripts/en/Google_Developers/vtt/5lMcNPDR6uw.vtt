WEBVTT
Kind: captions
Language: en

00:00:11.250 --> 00:00:13.784
FRED SAUER: OK, welcome
everyone.

00:00:13.784 --> 00:00:17.470
It's a great third day of
an excellent conference.

00:00:17.470 --> 00:00:20.610
Hopefully you've had a really
good time so far.

00:00:20.610 --> 00:00:22.710
And we're in the home stretch.

00:00:22.710 --> 00:00:25.010
I think there's one more block
of sessions after this.

00:00:25.010 --> 00:00:29.330
I'm excited to show you a couple
of demos today and walk

00:00:29.330 --> 00:00:32.470
through some code.

00:00:32.470 --> 00:00:33.860
Let's get started.

00:00:33.860 --> 00:00:35.560
I want to give you a little
bit of background--

00:00:35.560 --> 00:00:40.540
how I came into web games
and the stuff I work on.

00:00:40.540 --> 00:00:42.510
So back in 2007--

00:00:42.510 --> 00:00:44.180
this is before I
joined Google--

00:00:44.180 --> 00:00:45.830
my son and I wanted
to build a game.

00:00:45.830 --> 00:00:46.980
And so we sat down.

00:00:46.980 --> 00:00:48.040
He did some artwork.

00:00:48.040 --> 00:00:49.990
He was five at the time.

00:00:49.990 --> 00:00:52.330
And browsers--

00:00:52.330 --> 00:00:53.100
well, they weren't that good.

00:00:53.100 --> 00:00:55.590
Chrome wasn't even out.

00:00:55.590 --> 00:00:59.610
I probably got, I think,
initially 10, 12 frames per

00:00:59.610 --> 00:01:01.070
second on this game.

00:01:01.070 --> 00:01:04.280
I just used CSS to move
sprites around.

00:01:04.280 --> 00:01:05.820
So let me show you what
the game looks like.

00:01:05.820 --> 00:01:10.333
It's been preserved
in history.

00:01:10.333 --> 00:01:10.786
[VIDEO GAME SHOOTING
SOUND EFFECTS]

00:01:10.786 --> 00:01:12.603
It has some sound effects.

00:01:12.603 --> 00:01:16.330
Actually, let's turn
it up a bit.

00:01:16.330 --> 00:01:20.520
Now, this is a quality of, I'll
say, state-of-the-art web

00:01:20.520 --> 00:01:24.430
game circa 2007.

00:01:24.430 --> 00:01:27.300
Lots of fun, but I think
we can do a little

00:01:27.300 --> 00:01:28.920
bit better than that.

00:01:32.160 --> 00:01:38.460
Now, last year at the keynote,
you saw Chrome Angry Birds, an

00:01:38.460 --> 00:01:41.520
HTML5 game using WebGL.

00:01:41.520 --> 00:01:46.460
Very fast, amazing, much better
than, I would say, that

00:01:46.460 --> 00:01:52.544
2007 game that I worked on.

00:01:52.544 --> 00:01:59.190
And I'm not going to bore you
with playing a lot of this

00:01:59.190 --> 00:02:02.367
game, but I just want to show
you a little bit of what's

00:02:02.367 --> 00:02:03.141
going on here.

00:02:03.141 --> 00:02:10.869
[VIDEO GAME SOUND EFFECTS]

00:02:10.869 --> 00:02:12.390
Now, pretty good, huh?

00:02:12.390 --> 00:02:13.050
Pretty good?

00:02:13.050 --> 00:02:14.300
Yeah, OK.

00:02:16.680 --> 00:02:23.860
Now, if you played that game
last year at I/O, you probably

00:02:23.860 --> 00:02:26.830
realize that the game
has changed a lot.

00:02:26.830 --> 00:02:28.060
It has a lot of new levels.

00:02:28.060 --> 00:02:29.690
It has episodes.

00:02:29.690 --> 00:02:31.240
There's more functionality.

00:02:31.240 --> 00:02:34.980
Your progress is now
saved in the cloud.

00:02:34.980 --> 00:02:36.070
That's possible in a web game.

00:02:36.070 --> 00:02:38.040
That wasn't possible back
in the day when we did

00:02:38.040 --> 00:02:39.620
shrink-wrap games.

00:02:39.620 --> 00:02:41.900
If you bought a box of
software, you took

00:02:41.900 --> 00:02:42.690
it home with you.

00:02:42.690 --> 00:02:44.750
That's pretty much the version
of the software you had for

00:02:44.750 --> 00:02:46.270
the rest of your life.

00:02:46.270 --> 00:02:48.330
Our phones don't operate
that way anymore.

00:02:48.330 --> 00:02:50.500
The phones you got the other
day probably have already

00:02:50.500 --> 00:02:53.780
received an OTA and are in a
newer version than when you

00:02:53.780 --> 00:02:58.440
unpackaged them just the
day before yesterday.

00:02:58.440 --> 00:03:01.380
So with Chrome Angry Birds,
we released a

00:03:01.380 --> 00:03:02.690
framework called PlayN.

00:03:02.690 --> 00:03:04.320
And that's not really
what I'm going to be

00:03:04.320 --> 00:03:05.050
talking about today.

00:03:05.050 --> 00:03:07.190
But I wanted to stick this slide
up there and show you

00:03:07.190 --> 00:03:09.600
that the community
has stepped up.

00:03:09.600 --> 00:03:12.840
There's other games out
there that are fun.

00:03:12.840 --> 00:03:14.840
| like this one that
came out earlier.

00:03:14.840 --> 00:03:17.212
Just a nice little classic.

00:03:17.212 --> 00:03:19.256
And I'm going to die pretty
quickly because I'm no

00:03:19.256 --> 00:03:20.910
good at this game.

00:03:20.910 --> 00:03:23.390
Yeah, no.

00:03:23.390 --> 00:03:25.460
So watching me play games for
the rest of the hour is

00:03:25.460 --> 00:03:26.725
probably not what we
want to be doing.

00:03:29.760 --> 00:03:33.900
So as a game developer, you
really need to know a lot of

00:03:33.900 --> 00:03:38.220
things about backends
and frontends.

00:03:38.220 --> 00:03:39.670
You need to worry about
scalability and

00:03:39.670 --> 00:03:43.760
authentication, making your
game social, monetization,

00:03:43.760 --> 00:03:45.710
persisting player data.

00:03:45.710 --> 00:03:48.460
Oh, and you have to make the
game playable and fun, and

00:03:48.460 --> 00:03:51.620
have good graphics, and
do all that stuff.

00:03:55.320 --> 00:04:00.740
So let me show you the sample
game that we built this year.

00:04:00.740 --> 00:04:03.720
It's not quite the quality
of some of the

00:04:03.720 --> 00:04:04.370
other games out there.

00:04:04.370 --> 00:04:08.530
But we wanted to give you a
showcase game, something that

00:04:08.530 --> 00:04:10.800
you could open up
the source code.

00:04:10.800 --> 00:04:13.580
And you could look at it, and
you can copy bits and pieces.

00:04:13.580 --> 00:04:16.959
And you could get started, kind
of like your first kit

00:04:16.959 --> 00:04:18.310
for building the game.

00:04:21.640 --> 00:04:24.590
So I'm just going to launch
that game here.

00:04:24.590 --> 00:04:27.180
We integrate with--

00:04:27.180 --> 00:04:29.450
we have authentication.

00:04:29.450 --> 00:04:31.968
Let's see.

00:04:31.968 --> 00:04:36.110
I'm not actually logged in, but
I think I can take care of

00:04:36.110 --> 00:04:38.190
being logged in.

00:04:38.190 --> 00:04:39.440
Very secure password.

00:04:42.996 --> 00:04:44.246
All right.

00:04:47.262 --> 00:04:49.270
I've got a list of friends.

00:04:49.270 --> 00:04:51.110
Now, this is a multiplayer
game.

00:04:51.110 --> 00:04:54.770
I'm not sure if anyone's
on at the moment.

00:04:54.770 --> 00:04:56.470
Let's see what happens.

00:04:56.470 --> 00:04:58.750
At least I'll get in.

00:04:58.750 --> 00:05:00.530
It looks like it's just
me right now.

00:05:00.530 --> 00:05:01.870
There's a light team
and a dark team.

00:05:01.870 --> 00:05:03.630
And I can walk around.

00:05:03.630 --> 00:05:06.160
I can shoot things.

00:05:10.534 --> 00:05:11.790
We have sound effects.

00:05:16.190 --> 00:05:18.710
And the opposite team, they
would appear right here.

00:05:18.710 --> 00:05:20.460
And then we would go after
each other and

00:05:20.460 --> 00:05:21.710
shoot each other up.

00:05:26.410 --> 00:05:31.680
The pictures that you see
here are the party--

00:05:31.680 --> 00:05:35.750
the six of the willing, those
people that, 120 days ago,

00:05:35.750 --> 00:05:39.010
decided that we'd build
a web game together.

00:05:39.010 --> 00:05:41.670
Most of these folks were working
on the frontend.

00:05:41.670 --> 00:05:44.030
A couple of us were working
on some backend stuff.

00:05:44.030 --> 00:05:46.080
I take no credit for
all the beauty.

00:05:46.080 --> 00:05:47.360
That's the graphics.

00:05:47.360 --> 00:05:49.220
I'm a backend guy.

00:05:49.220 --> 00:05:53.070
Now, on day one, there
was a talk by Colt

00:05:53.070 --> 00:05:53.990
all about the frontend.

00:05:53.990 --> 00:05:56.360
If you missed that,
catch it online.

00:05:56.360 --> 00:05:58.420
This talk is the complementary
talk, which is

00:05:58.420 --> 00:05:59.670
about backend pieces.

00:06:03.350 --> 00:06:07.275
Now, when we set out to build
this game, called Grits, we

00:06:07.275 --> 00:06:08.940
had to choose a development
stack.

00:06:08.940 --> 00:06:10.545
And there's a lot of
things that go into

00:06:10.545 --> 00:06:11.800
a development stack.

00:06:11.800 --> 00:06:15.220
But ultimately, one of the big
choices you're making is the

00:06:15.220 --> 00:06:17.040
language that you're
going to choose.

00:06:17.040 --> 00:06:21.060
If you're using PlayN, you're
using Java, and you're

00:06:21.060 --> 00:06:23.070
compiling to multiple
platforms.

00:06:23.070 --> 00:06:25.760
And we thought we'd do
something different.

00:06:25.760 --> 00:06:27.940
We wanted something that
was very approachable.

00:06:27.940 --> 00:06:30.160
We wanted to build
an HTML5 game.

00:06:30.160 --> 00:06:31.720
We wanted to use pure
JavaScript.

00:06:31.720 --> 00:06:33.450
We wanted to reuse
the JavaScript

00:06:33.450 --> 00:06:35.920
source code on the server.

00:06:35.920 --> 00:06:39.080
And so when you think about your
next project, think about

00:06:39.080 --> 00:06:41.560
all these things that
are influencing

00:06:41.560 --> 00:06:43.690
your choice of a platform.

00:06:43.690 --> 00:06:47.160
And you may pick something
that's really relevant.

00:06:47.160 --> 00:06:51.160
Or you may pick some random
thing like the hot new thing

00:06:51.160 --> 00:06:53.680
that you want to learn
and work on.

00:06:53.680 --> 00:06:58.150
We decided to go for developer
approachability.

00:06:58.150 --> 00:07:02.460
Now, my background is
server-side infrastructure.

00:07:02.460 --> 00:07:04.560
I work on App Engine.

00:07:04.560 --> 00:07:07.420
And for this project, we used
a combination of App Engine

00:07:07.420 --> 00:07:09.750
and Compute Engine.

00:07:09.750 --> 00:07:12.540
The parts that we could put on
App Engine so we didn't have

00:07:12.540 --> 00:07:14.380
to write a lot of code,
we put there.

00:07:14.380 --> 00:07:19.400
The node.js server that we
wanted to kind of run the

00:07:19.400 --> 00:07:23.900
physics on and share code with
the clients, we put on Compute

00:07:23.900 --> 00:07:26.130
Engine inside of VM.

00:07:26.130 --> 00:07:29.050
So let's take a closer look
at that architecture.

00:07:29.050 --> 00:07:32.300
You saw the web game, which
is running in a browser.

00:07:32.300 --> 00:07:36.890
I'm later going to show you an
Android controller app that

00:07:36.890 --> 00:07:39.710
connects to the same
game as well.

00:07:39.710 --> 00:07:41.300
That's pretty cool.

00:07:41.300 --> 00:07:44.070
Now, on App Engine, we do the
static content serving, so we

00:07:44.070 --> 00:07:45.990
just host up the basic site.

00:07:45.990 --> 00:07:48.640
We have what are called
frontend instances.

00:07:48.640 --> 00:07:52.540
This is the instances where
our application code runs.

00:07:52.540 --> 00:07:55.540
And they reply to requests from
the browser, like find me

00:07:55.540 --> 00:07:56.990
a game that I can drop into.

00:07:56.990 --> 00:07:59.600
And then App Engine responds
back and says, the game is

00:07:59.600 --> 00:08:02.020
available at this IP address
on this port.

00:08:02.020 --> 00:08:03.670
Go for it.

00:08:03.670 --> 00:08:06.530
And then we have a special type
of server on App Engine

00:08:06.530 --> 00:08:07.750
called the backend.

00:08:07.750 --> 00:08:09.970
This is a stateful server
that's a little bit more

00:08:09.970 --> 00:08:10.970
long-running.

00:08:10.970 --> 00:08:14.760
And what its job to do is
to keep track of all the

00:08:14.760 --> 00:08:17.560
different games that are
currently ongoing.

00:08:17.560 --> 00:08:21.450
And actually, I think
I can pull up the

00:08:21.450 --> 00:08:22.630
current state right now.

00:08:22.630 --> 00:08:25.720
There's a debug URL.

00:08:25.720 --> 00:08:29.450
And here you see a big
JSON response.

00:08:29.450 --> 00:08:32.360
Right down at the bottom here--
let me increase the

00:08:32.360 --> 00:08:33.880
font size a bit--

00:08:33.880 --> 00:08:35.840
you see players_waiting, none.

00:08:35.840 --> 00:08:37.510
So there's no players
currently waiting

00:08:37.510 --> 00:08:39.429
to get into a game.

00:08:39.429 --> 00:08:41.049
If I go to the very
top, there's a

00:08:41.049 --> 00:08:42.250
list of game servers.

00:08:42.250 --> 00:08:46.040
And they all have randomly
generated unique strings to

00:08:46.040 --> 00:08:47.170
identify them.

00:08:47.170 --> 00:08:51.180
And then each game server has
some state associated with it.

00:08:51.180 --> 00:08:53.830
In this case, this game
server here has a

00:08:53.830 --> 00:08:56.470
number of running games.

00:08:56.470 --> 00:08:59.060
There's a game, 9ZXL,
going on right now.

00:08:59.060 --> 00:09:00.480
It's very exciting.

00:09:00.480 --> 00:09:02.070
There's four people in there.

00:09:02.070 --> 00:09:05.640
Two of them logged in, and
two of them anonymously,

00:09:05.640 --> 00:09:07.990
identified by the bots.

00:09:07.990 --> 00:09:09.940
And we have another
game here, mA32.

00:09:09.940 --> 00:09:11.160
Anyone in that game?

00:09:11.160 --> 00:09:13.640
No, must be the room
next door.

00:09:13.640 --> 00:09:15.950
They have quite a few
players going on.

00:09:15.950 --> 00:09:20.510
So this is just the state that's
currently represented

00:09:20.510 --> 00:09:22.930
in this App Engine backend.

00:09:22.930 --> 00:09:25.500
And any time a player comes
in, they kind of ask this

00:09:25.500 --> 00:09:27.420
backend for some information.

00:09:27.420 --> 00:09:28.750
Where can I play?

00:09:28.750 --> 00:09:30.040
Where's an open slot?

00:09:30.040 --> 00:09:31.930
App Engine assigns a slot,
keeps track of the

00:09:31.930 --> 00:09:32.910
information.

00:09:32.910 --> 00:09:33.860
So all that's going on there.

00:09:33.860 --> 00:09:35.780
And we'll talk about that
a little bit more.

00:09:35.780 --> 00:09:39.570
And then on Compute Engine, we
have the actual games running.

00:09:39.570 --> 00:09:43.740
This is where the logic and the
physics replay happens.

00:09:43.740 --> 00:09:46.390
And then both our web browser
and later our Android client,

00:09:46.390 --> 00:09:53.140
they use WebSockets to connect
to these node.js instances.

00:09:53.140 --> 00:09:56.390
And then the Compute Engine and
App Engine instances, they

00:09:56.390 --> 00:09:58.270
have to communicate
with each other.

00:09:58.270 --> 00:10:00.060
They have to keep
track of state.

00:10:00.060 --> 00:10:02.530
They kind of share the global
state of the system.

00:10:02.530 --> 00:10:04.700
And so they do a lot
of JSON message

00:10:04.700 --> 00:10:08.360
passing back and forth.

00:10:08.360 --> 00:10:11.680
And the parts that I'm going to
talk to you about most are

00:10:11.680 --> 00:10:14.960
this Android controller and then
most of the App Engine

00:10:14.960 --> 00:10:18.030
backend stuff.

00:10:18.030 --> 00:10:23.500
Now, when we set out to choose
a wire protocol, we had two

00:10:23.500 --> 00:10:26.010
top-level options
in front of us.

00:10:26.010 --> 00:10:29.770
We could use someone
else's plumbing.

00:10:29.770 --> 00:10:30.930
There's some good
options there.

00:10:30.930 --> 00:10:33.680
There's App Engine Endpoints,
which you heard about at this

00:10:33.680 --> 00:10:35.410
conference.

00:10:35.410 --> 00:10:38.460
There's Google Plugin for
Eclipse that provides some

00:10:38.460 --> 00:10:40.450
synchronization options
and does a lot of the

00:10:40.450 --> 00:10:42.010
hard work for you.

00:10:42.010 --> 00:10:44.910
You should use those.

00:10:44.910 --> 00:10:47.470
Like all engineers, though, we
thought we could just write

00:10:47.470 --> 00:10:48.300
our own plumbing.

00:10:48.300 --> 00:10:51.620
Because why use someone
else's?

00:10:51.620 --> 00:10:53.300
So we started out with
some basic options.

00:10:53.300 --> 00:10:55.210
We could do XML--

00:10:55.210 --> 00:11:00.290
kind of wordy, very chatty,
a lot of bytes.

00:11:00.290 --> 00:11:02.080
We could do JSON.

00:11:02.080 --> 00:11:03.510
And we could roll our
own protocol--

00:11:03.510 --> 00:11:05.990
nice and compact, a little
hard to decode,

00:11:05.990 --> 00:11:08.670
but probably efficient.

00:11:08.670 --> 00:11:12.970
And if you compare those, you
see that, for the high

00:11:12.970 --> 00:11:15.500
bandwidth stuff, we should
probably choose a protocol

00:11:15.500 --> 00:11:17.240
that's much smaller
and tighter.

00:11:17.240 --> 00:11:21.370
And so we ended up rolling our
own protocol that's fairly

00:11:21.370 --> 00:11:23.780
compact, but still
human readable.

00:11:23.780 --> 00:11:26.010
And then for the
server-to-server communication

00:11:26.010 --> 00:11:29.440
that's a little bit more low
bandwidth, we chose JSON just

00:11:29.440 --> 00:11:31.430
because of its ease of use.

00:11:31.430 --> 00:11:32.490
And XML--

00:11:32.490 --> 00:11:34.840
no, we didn't do that one.

00:11:34.840 --> 00:11:38.080
We could have gone just
a little bit tighter.

00:11:38.080 --> 00:11:42.330
You see some information here,
four Booleans and a number.

00:11:42.330 --> 00:11:45.760
We could have actually encoded
that in a single byte.

00:11:45.760 --> 00:11:49.290
Three is 0011 in binary.

00:11:49.290 --> 00:11:51.630
And then the four Boolean
flags we could

00:11:51.630 --> 00:11:53.820
have encoded as bits.

00:11:53.820 --> 00:11:55.400
This would have been really
hard to debug.

00:11:55.400 --> 00:11:57.860
It would have been slightly more
efficient, but a little

00:11:57.860 --> 00:11:59.450
bit overkill for this example.

00:11:59.450 --> 00:12:01.630
We wanted to be able to look
at messages and understand

00:12:01.630 --> 00:12:02.790
what's going on.

00:12:02.790 --> 00:12:07.220
So for Grits, we chose the
semi-dense, roll your own

00:12:07.220 --> 00:12:11.560
protocol, and then JSON
for everything else.

00:12:11.560 --> 00:12:15.320
Now, when we started out, we're
debugging things, we're

00:12:15.320 --> 00:12:18.310
looking at the console, and
we're looking at JSON that

00:12:18.310 --> 00:12:19.650
looks like this.

00:12:19.650 --> 00:12:21.200
And then you'd make a tweak.

00:12:21.200 --> 00:12:22.540
And then you look
at some JSON.

00:12:22.540 --> 00:12:23.845
And it'd look just like
that, except it

00:12:23.845 --> 00:12:25.050
was slightly different.

00:12:25.050 --> 00:12:28.520
And it was really hard to figure
out what was going on.

00:12:28.520 --> 00:12:30.750
And we said, this
is not working.

00:12:30.750 --> 00:12:33.110
If we're going to use JSON, we
actually need this stuff

00:12:33.110 --> 00:12:36.400
formatted in a way that
humans can read.

00:12:36.400 --> 00:12:38.910
We want something that looks
more like this, because then

00:12:38.910 --> 00:12:40.670
you can actually compare
differences and see

00:12:40.670 --> 00:12:41.920
what's going on.

00:12:41.920 --> 00:12:46.010
So on App Engine, we used the
JSON library, of course.

00:12:46.010 --> 00:12:48.280
And we did a little something.

00:12:48.280 --> 00:12:49.380
We have a debug flag.

00:12:49.380 --> 00:12:53.500
And when we turned that on, we
changed our JSON encoder.

00:12:53.500 --> 00:12:55.810
And we indent everything
before spaces.

00:12:55.810 --> 00:12:57.160
And we sort the keys.

00:12:57.160 --> 00:13:00.630
So that the controller host here
that you see, that first

00:13:00.630 --> 00:13:02.720
entry, is always the first
thing that shows up.

00:13:02.720 --> 00:13:04.740
It's not random depending
on the order of

00:13:04.740 --> 00:13:07.130
the internal hash.

00:13:07.130 --> 00:13:09.520
And then we have a couple of
helper functions, tojson

00:13:09.520 --> 00:13:13.920
method for taking a payload,
turning it into JSON, taking a

00:13:13.920 --> 00:13:15.120
Python object.

00:13:15.120 --> 00:13:19.950
And then fromjson to
do the reverse.

00:13:19.950 --> 00:13:22.340
And it does some exception
handling.

00:13:22.340 --> 00:13:24.760
And if for some reason it gets
a message back that's not

00:13:24.760 --> 00:13:28.420
JSON, it actually prints out
the payload that it got.

00:13:28.420 --> 00:13:30.290
So we can figure out
what's going on.

00:13:30.290 --> 00:13:34.630
In the beginning, a lot
of that was happening.

00:13:34.630 --> 00:13:37.490
Now, we wanted to make life a
little bit easier as well.

00:13:37.490 --> 00:13:42.760
We created a JSON handler that
took care of the boilerplate.

00:13:42.760 --> 00:13:45.170
Every single time we had a
request handler, we needed to

00:13:45.170 --> 00:13:47.510
inject a JSON payload, do
some work, and then

00:13:47.510 --> 00:13:49.760
spit out a JSON response.

00:13:49.760 --> 00:13:51.240
And so you see that here.

00:13:51.240 --> 00:13:52.840
We have a post handler.

00:13:52.840 --> 00:13:57.510
It logs the information that's
coming in, throws an exception

00:13:57.510 --> 00:13:59.690
if there's no content.

00:13:59.690 --> 00:14:03.580
It parses the payload
that's come in,

00:14:03.580 --> 00:14:05.180
and it handles response.

00:14:05.180 --> 00:14:08.290
This is delegated
to a subclass.

00:14:08.290 --> 00:14:14.470
And then we spit out the right
content type and encode the

00:14:14.470 --> 00:14:18.170
response and send it back
to the requester.

00:14:18.170 --> 00:14:20.420
And if there's any kind of
exception, we print a nice

00:14:20.420 --> 00:14:23.610
pretty stack trace that you can
actually see on the other

00:14:23.610 --> 00:14:27.240
end of the connection so
you can debug things.

00:14:27.240 --> 00:14:30.300
And here's that handle method
that was being called above.

00:14:30.300 --> 00:14:33.160
And this is something that you
implement in every single

00:14:33.160 --> 00:14:35.540
implementation.

00:14:35.540 --> 00:14:37.420
So the payoff--

00:14:37.420 --> 00:14:38.570
you'll just have to trust me.

00:14:38.570 --> 00:14:40.020
Before, the code looked
like that.

00:14:40.020 --> 00:14:43.260
After, it looked like that.

00:14:43.260 --> 00:14:45.780
No, let me show you what
it looks like.

00:14:45.780 --> 00:14:50.090
So here's the code without
the helper functions.

00:14:50.090 --> 00:14:52.090
The blue stuff is really
what we care about.

00:14:52.090 --> 00:14:54.990
We parse something, and we
spit out a response.

00:14:54.990 --> 00:14:57.280
Afterwards, there's a lot
less boilerplate.

00:14:57.280 --> 00:14:59.130
Everything's taken care of.

00:14:59.130 --> 00:15:00.830
And this code [? savings ?]

00:15:00.830 --> 00:15:03.330
repeats itself throughout
the code.

00:15:06.360 --> 00:15:10.070
We also turned on the new
PageSpeed service that was

00:15:10.070 --> 00:15:11.490
announced at this conference.

00:15:11.490 --> 00:15:13.830
It has a whole bunch
of rewriters.

00:15:13.830 --> 00:15:16.840
It's an experimental feature
in App Engine, but it's

00:15:16.840 --> 00:15:19.350
something you can
try out today.

00:15:19.350 --> 00:15:22.170
And by default, it has a number
of rewriters that it

00:15:22.170 --> 00:15:25.770
turns on that it believes are
safe for almost every single

00:15:25.770 --> 00:15:26.830
site out there.

00:15:26.830 --> 00:15:30.700
So like getting rid of
whitespace in CSS and HTML,

00:15:30.700 --> 00:15:33.540
getting rid of comments, those
things are generally safe and

00:15:33.540 --> 00:15:34.900
won't break anything.

00:15:34.900 --> 00:15:38.450
There's a few rewriters that
are a little more advanced,

00:15:38.450 --> 00:15:41.440
like combining JavaScript
files, inlining

00:15:41.440 --> 00:15:42.920
JavaScript in CSS.

00:15:42.920 --> 00:15:45.260
And depending on your
application, they may or may

00:15:45.260 --> 00:15:46.540
not be safe.

00:15:46.540 --> 00:15:49.720
And so we provide a way to
customize that for you.

00:15:49.720 --> 00:15:53.500
In your app.yaml, which is your
main configuration file

00:15:53.500 --> 00:15:55.620
on App Engine, you
add a special

00:15:55.620 --> 00:15:57.370
block, a pagespeed block.

00:15:57.370 --> 00:16:01.395
And there, you can explicitly
indicate domains that you want

00:16:01.395 --> 00:16:04.620
to rewrite, blacklist URLs.

00:16:04.620 --> 00:16:07.060
And then you can enable
rewriters that aren't on by

00:16:07.060 --> 00:16:10.260
default, or you can disable
rewriters that normally are on

00:16:10.260 --> 00:16:11.780
by default.

00:16:11.780 --> 00:16:13.950
But if you leave this block
out and you just go to the

00:16:13.950 --> 00:16:16.370
admin console and you
check the box, we'll

00:16:16.370 --> 00:16:17.900
do the default thing.

00:16:17.900 --> 00:16:20.210
And for most applications,
it's the right thing.

00:16:20.210 --> 00:16:25.700
And then the amount of traffic
after a few iterations will

00:16:25.700 --> 00:16:27.170
get faster.

00:16:27.170 --> 00:16:29.440
So what happens when you flip
this bit, the first time you

00:16:29.440 --> 00:16:34.350
hit your website, it will
actually be the same slow,

00:16:34.350 --> 00:16:35.780
large payload that
you saw before.

00:16:35.780 --> 00:16:38.370
But behind the scenes, the
PageSpeed service is fetching

00:16:38.370 --> 00:16:40.120
all the content, rewriting it.

00:16:40.120 --> 00:16:43.570
And then when you come back
shortly thereafter, it will

00:16:43.570 --> 00:16:46.900
ship down the rewritten bites,
which are nice and compact and

00:16:46.900 --> 00:16:48.060
a little bit more efficient.

00:16:48.060 --> 00:16:50.330
And hopefully, your users' load
times will go down, and

00:16:50.330 --> 00:16:54.725
your bandwidth costs will
be affected as well.

00:16:57.270 --> 00:17:03.610
So one big pain for games that
usually developers delay to

00:17:03.610 --> 00:17:06.510
the last minute is identity
and access controls.

00:17:06.510 --> 00:17:09.560
This is always a pain point
of integration.

00:17:09.560 --> 00:17:11.240
Security is a hard thing.

00:17:11.240 --> 00:17:14.160
Luckily, we have some existing
tools that we

00:17:14.160 --> 00:17:16.300
can use in App Engine.

00:17:16.300 --> 00:17:18.140
There's a built-in Users API.

00:17:18.140 --> 00:17:22.010
This is great for sites that
use Google accounts.

00:17:22.010 --> 00:17:25.410
You get this full-page redirect,
so you don't have

00:17:25.410 --> 00:17:27.750
any kind of branding
on the site.

00:17:27.750 --> 00:17:33.010
And users have to authenticate
themselves every 30 days.

00:17:33.010 --> 00:17:36.380
So this might be OK for
certain style apps.

00:17:36.380 --> 00:17:39.890
But for games, it's probably
not the best experience.

00:17:39.890 --> 00:17:43.250
It's fairly easy
to use, though.

00:17:43.250 --> 00:17:44.860
You just have your
regular handlers.

00:17:44.860 --> 00:17:47.760
And you add one line of code
that says, Login required.

00:17:47.760 --> 00:17:49.370
And then App Engine will
take care of the rest.

00:17:49.370 --> 00:17:51.930
It will create these
interstitial pages, make sure

00:17:51.930 --> 00:17:55.050
that users cannot get to your
site, or at least to these

00:17:55.050 --> 00:17:59.490
URLs, until they are logged
in with a Google account.

00:17:59.490 --> 00:18:04.920
Then, in your main.py, you
use the user's API.

00:18:04.920 --> 00:18:08.380
And you can just say
users.get_current_user().

00:18:08.380 --> 00:18:12.070
And that object will either be
none if the user's not logged

00:18:12.070 --> 00:18:14.060
in, or it will be something.

00:18:14.060 --> 00:18:20.340
And you can get the name of the
user or the email address.

00:18:20.340 --> 00:18:22.980
And if they're not logged
in, you can send

00:18:22.980 --> 00:18:25.530
them to a login page.

00:18:25.530 --> 00:18:28.910
And then you pass in the page
that you want the user to come

00:18:28.910 --> 00:18:31.640
back to after they've
logged in.

00:18:31.640 --> 00:18:33.360
So that's pretty easy to use.

00:18:33.360 --> 00:18:36.720
But we decided to use OAuth,
because we get a better user

00:18:36.720 --> 00:18:37.590
experience.

00:18:37.590 --> 00:18:40.190
We still have our branding.

00:18:40.190 --> 00:18:41.420
Our page is up.

00:18:41.420 --> 00:18:42.010
Our game is up.

00:18:42.010 --> 00:18:45.690
And then there's a popup page
with the OAuth flow.

00:18:45.690 --> 00:18:52.760
So this is where the user can
indicate whether or not

00:18:52.760 --> 00:18:54.080
they're willing to
share their email

00:18:54.080 --> 00:18:55.550
address, share their profile.

00:18:55.550 --> 00:18:58.040
Whatever the permissions are
that you're asking for, this

00:18:58.040 --> 00:19:01.780
is what the dialog
box will show.

00:19:01.780 --> 00:19:05.420
Now, once the client's
authenticated, it gets a

00:19:05.420 --> 00:19:07.010
special access token.

00:19:07.010 --> 00:19:09.800
And when you have that access
token, and you pass it into

00:19:09.800 --> 00:19:16.970
App Engine, App Engine can
extract the access token,

00:19:16.970 --> 00:19:20.360
validate that the access token
is correct, and then give you

00:19:20.360 --> 00:19:23.980
back the username
for that user.

00:19:23.980 --> 00:19:25.970
And so it looks very much
like the Users API.

00:19:25.970 --> 00:19:28.250
Instead of
user.get_current_user, you

00:19:28.250 --> 00:19:31.100
say, oauth.get_current_user.

00:19:31.100 --> 00:19:32.350
And then you pass in a scope.

00:19:32.350 --> 00:19:35.570
And the scope is one of the
permission scopes that you've

00:19:35.570 --> 00:19:38.970
asked for when you created
that token initially.

00:19:38.970 --> 00:19:43.110
The nice thing about using the
email scope in this case is

00:19:43.110 --> 00:19:45.980
that the user ID that you'll
get back is the exact same

00:19:45.980 --> 00:19:49.230
user ID that the Users API
would have given back.

00:19:49.230 --> 00:19:52.770
This is useful if you have two
parts to your site, one that

00:19:52.770 --> 00:19:55.760
is maybe for administrators
or uses the Users

00:19:55.760 --> 00:19:57.460
API to prevent login.

00:19:57.460 --> 00:20:00.530
And in another place, you have
maybe mobile devices or you

00:20:00.530 --> 00:20:03.320
use OAuth for some other
reason to get in.

00:20:03.320 --> 00:20:06.770
Now you can correlate these two
user objects by lining up

00:20:06.770 --> 00:20:09.570
the user ID.

00:20:09.570 --> 00:20:11.800
Then good debugging tip.

00:20:11.800 --> 00:20:14.740
When you have these access
tokens and you don't know why

00:20:14.740 --> 00:20:17.190
they're working or what they're
for or how you got

00:20:17.190 --> 00:20:22.030
them, you can just make
a call to this URL.

00:20:22.030 --> 00:20:26.430
And Google will tell you where
the access token--

00:20:26.430 --> 00:20:29.800
who it was issued by, what it's
for, when it expires.

00:20:29.800 --> 00:20:31.340
All that good stuff.

00:20:31.340 --> 00:20:35.820
So it's a really useful
debugging tool right there.

00:20:35.820 --> 00:20:39.990
Now, OAuth2 has many
different flows.

00:20:39.990 --> 00:20:43.700
So I wanted to just walk through
what the flow is like

00:20:43.700 --> 00:20:44.860
in our application.

00:20:44.860 --> 00:20:48.170
We have the client, which is the
web browser in this case.

00:20:48.170 --> 00:20:53.840
We have App Engine hosting the
content and the services.

00:20:53.840 --> 00:20:57.820
And then we have the Google
Authorization and User Info

00:20:57.820 --> 00:21:01.390
Services over there
on the right.

00:21:01.390 --> 00:21:05.330
So what happens is, the client
grabs the initial page.

00:21:05.330 --> 00:21:07.710
They download the game.

00:21:07.710 --> 00:21:10.120
And then the user clicks
the login button.

00:21:16.780 --> 00:21:18.130
We send them to a login
OAuth page.

00:21:18.130 --> 00:21:22.100
And App Engine redirects them
to this longer URL, which

00:21:22.100 --> 00:21:24.290
points at the authorization
servers.

00:21:24.290 --> 00:21:26.530
There, they get this
dialogue box.

00:21:26.530 --> 00:21:28.800
And the user clicks
Allow Access.

00:21:28.800 --> 00:21:32.080
The servers generate a
unique access token.

00:21:32.080 --> 00:21:35.220
And then they send a redirect
to the URL that we specified

00:21:35.220 --> 00:21:40.120
initially, which is this
other page, logup.

00:21:40.120 --> 00:21:43.300
And it passes in the access
token and the hash fragment.

00:21:43.300 --> 00:21:45.840
So we can extract that
on the page.

00:21:45.840 --> 00:21:48.650
And then we can use that
access token to call

00:21:48.650 --> 00:21:52.280
this user info URL.

00:21:52.280 --> 00:21:55.860
And that allows us to get
information about the profile

00:21:55.860 --> 00:21:57.240
of the user.

00:21:57.240 --> 00:22:01.170
And then sometime later,
the game calls--

00:22:01.170 --> 00:22:04.240
when they click Quick
Game, we call a

00:22:04.240 --> 00:22:05.890
service called findGame.

00:22:05.890 --> 00:22:07.770
And we pass in the
access token.

00:22:07.770 --> 00:22:12.710
And that's how App Engine knows
which user is asking to

00:22:12.710 --> 00:22:14.280
login to the game.

00:22:14.280 --> 00:22:17.870
And so App Engine does this
access token verification and

00:22:17.870 --> 00:22:19.460
extracts the user ID.

00:22:19.460 --> 00:22:23.340
And we can go on.

00:22:23.340 --> 00:22:28.730
Now, in Grits, kind of the
middle section, the App Engine

00:22:28.730 --> 00:22:31.270
section, looks something
like this.

00:22:31.270 --> 00:22:34.790
We have a Grits service
handler.

00:22:34.790 --> 00:22:37.860
This is where all those Grits
requests come in, so

00:22:37.860 --> 00:22:40.160
grits.findGame, for example.

00:22:40.160 --> 00:22:46.360
And in the post, when we get the
HTTP post coming in, the

00:22:46.360 --> 00:22:48.700
first thing we do is
determine the user.

00:22:48.700 --> 00:22:52.830
And that function is
below, right here.

00:22:52.830 --> 00:22:56.610
And this is a little tricky bit
because, in our game, we

00:22:56.610 --> 00:23:00.505
allow users to login anonymously
by clicking Quick

00:23:00.505 --> 00:23:04.140
Game, or click the login button,
go through the OAuth

00:23:04.140 --> 00:23:06.580
flow, and actually identify
themselves.

00:23:06.580 --> 00:23:08.560
So we have those two
things going on.

00:23:08.560 --> 00:23:11.780
And then at the same time, we
want all this to work in

00:23:11.780 --> 00:23:12.870
production.

00:23:12.870 --> 00:23:15.430
But we want to be able to do
some easy debugging on the

00:23:15.430 --> 00:23:19.370
local development server, so
when we're coding on a laptop.

00:23:19.370 --> 00:23:22.430
So we really have four different
scenarios going on.

00:23:22.430 --> 00:23:25.540
We have the Quick Game
and Login both in

00:23:25.540 --> 00:23:27.320
production and locally.

00:23:27.320 --> 00:23:30.430
And so the block of code
below here handles all

00:23:30.430 --> 00:23:31.900
four of those cases.

00:23:31.900 --> 00:23:34.890
So the first thing we do is
say, if we're in a local

00:23:34.890 --> 00:23:41.710
development server, then we
allow the request URL to have

00:23:41.710 --> 00:23:43.910
a user ID passed in.

00:23:43.910 --> 00:23:45.460
And we will accept it blindly.

00:23:45.460 --> 00:23:46.330
We're in development.

00:23:46.330 --> 00:23:48.010
We're on our own machine.

00:23:48.010 --> 00:23:50.280
We're not worried about
any kind of security.

00:23:50.280 --> 00:23:53.890
We just want to test out the
display of names or user IDs

00:23:53.890 --> 00:23:55.170
or do whatever we want.

00:23:55.170 --> 00:23:58.910
So in development,
anything goes.

00:23:58.910 --> 00:24:03.760
If we're not in development, and
the user ID starts with a

00:24:03.760 --> 00:24:08.920
special string, bot*, that's a
string that we've whitelisted.

00:24:08.920 --> 00:24:10.430
And that's the string
that's generated by

00:24:10.430 --> 00:24:13.130
this Quick Game button.

00:24:13.130 --> 00:24:16.480
If the user ID starts with
that, we allow it.

00:24:16.480 --> 00:24:19.870
So any user can specify
a name, as long as

00:24:19.870 --> 00:24:22.140
it starts with bot*.

00:24:22.140 --> 00:24:26.310
If that's not the case, then we
do the OAuth look up that

00:24:26.310 --> 00:24:28.150
you saw earlier.

00:24:28.150 --> 00:24:31.690
And if we get any kind of OAuth
error because the token

00:24:31.690 --> 00:24:35.090
was invalid or something like
that, then we throw an

00:24:35.090 --> 00:24:36.690
exception back to the user.

00:24:36.690 --> 00:24:40.610
So now we have all four of
those scenarios covered.

00:24:40.610 --> 00:24:44.490
And we know what the user is, we
have a user ID, and we have

00:24:44.490 --> 00:24:45.260
a display name.

00:24:45.260 --> 00:24:51.100
The user ID is the internal key
that we used to save data

00:24:51.100 --> 00:24:52.320
in the data store.

00:24:52.320 --> 00:24:55.480
And the display name is what the
users will see above their

00:24:55.480 --> 00:24:59.460
player on the game.

00:24:59.460 --> 00:25:02.340
Now, this game was fun.

00:25:02.340 --> 00:25:04.870
And WebSockets and JSON,
all of that's fun.

00:25:04.870 --> 00:25:09.170
But I thought it'd be a little
bit more interesting to get

00:25:09.170 --> 00:25:13.310
your hands off the keyboard
and use the

00:25:13.310 --> 00:25:14.640
latest Android toy.

00:25:14.640 --> 00:25:18.260
So we all have pretty fancy game
controllers, probably in

00:25:18.260 --> 00:25:21.220
our pockets, if not
in your bags.

00:25:21.220 --> 00:25:22.250
They have accelerometers.

00:25:22.250 --> 00:25:24.840
They can do really
cool things.

00:25:24.840 --> 00:25:27.480
And some of them can even
make phone calls.

00:25:30.140 --> 00:25:33.910
So what you see here is
a spinning globe.

00:25:33.910 --> 00:25:37.960
Represented on it the
average gravity by

00:25:37.960 --> 00:25:39.420
location on the planet.

00:25:39.420 --> 00:25:40.830
And you see that it
varies a bit.

00:25:40.830 --> 00:25:42.700
Places where there's mountains,
there's actually a

00:25:42.700 --> 00:25:46.170
little bit more gravity than
in lower-lying areas.

00:25:46.170 --> 00:25:50.300
Luckily, these variances
are not that great.

00:25:50.300 --> 00:25:52.530
And they won't really
affect the next

00:25:52.530 --> 00:25:53.330
steps in the gameplay.

00:25:53.330 --> 00:25:57.250
Although players on high
mountainous regions might have

00:25:57.250 --> 00:26:01.380
to tilt their phone a little
less than we will here at the

00:26:01.380 --> 00:26:02.450
conference.

00:26:02.450 --> 00:26:07.950
The average pull of gravity is
about 9.8 meters per second

00:26:07.950 --> 00:26:09.090
per second.

00:26:09.090 --> 00:26:12.790
And we're going to use our
phone's sensors to measure

00:26:12.790 --> 00:26:15.400
this gravity, measure the
direction of the gravity, and

00:26:15.400 --> 00:26:18.310
use that to control the
character in the game.

00:26:18.310 --> 00:26:24.500
So I created this app called
WASD, W-A-S-D, after the four

00:26:24.500 --> 00:26:26.580
keys that are used
in this game to

00:26:26.580 --> 00:26:29.550
control your character.

00:26:29.550 --> 00:26:33.270
And it's a simple little app
that looks like this.

00:26:33.270 --> 00:26:36.870
And let me show you what
that looks like.

00:26:48.890 --> 00:26:51.620
Now, there's four
buttons on here.

00:26:51.620 --> 00:26:54.790
But if I press in the buttons,
you see that nothing happens.

00:26:54.790 --> 00:26:56.290
I didn't wire them
up that way.

00:26:56.290 --> 00:26:58.760
I wired them up to the
accelerometer.

00:26:58.760 --> 00:27:05.250
So when I tilt the tablet, the
different buttons light up.

00:27:05.250 --> 00:27:10.890
And so the idea is that you just
rock this tablet around.

00:27:10.890 --> 00:27:13.760
And that's how you control
your character.

00:27:13.760 --> 00:27:17.340
So let's see what
that looks like.

00:27:17.340 --> 00:27:21.890
Hopefully, the network gods
will be friendly to us.

00:27:21.890 --> 00:27:23.790
So I'm going to login
to the game.

00:27:23.790 --> 00:27:28.910
I'm going to be sure to use the
OAuth flow so that I'm an

00:27:28.910 --> 00:27:34.950
authenticated user and the App
Engine will be able to marry

00:27:34.950 --> 00:27:39.570
up the player right here
on the laptop and the

00:27:39.570 --> 00:27:40.820
player in the game.

00:27:44.220 --> 00:27:45.410
I'll do a little split screen.

00:27:45.410 --> 00:27:47.080
You can look at either screen.

00:27:49.970 --> 00:27:51.225
So we have the player
dropping in.

00:27:51.225 --> 00:27:54.610
I'm logged in as me.

00:27:54.610 --> 00:27:58.550
Here on the tablet,
I have a chooser.

00:27:58.550 --> 00:28:01.244
There's two accounts associated
with this device.

00:28:01.244 --> 00:28:04.740
I'm going to pick my
Gmail account here.

00:28:04.740 --> 00:28:06.040
You can see a couple
of popup messages.

00:28:06.040 --> 00:28:07.820
It's getting an OAuth
access token.

00:28:07.820 --> 00:28:09.940
It's looking up a user ID.

00:28:09.940 --> 00:28:11.010
And it has a connection.

00:28:11.010 --> 00:28:12.260
It says, yay.

00:28:14.760 --> 00:28:16.752
Oh, someone else joined us.

00:28:25.240 --> 00:28:28.014
Network gods are not playing
good with us yet.

00:28:31.320 --> 00:28:34.170
I'll try to reconnect, see if
we can make this happen.

00:28:46.630 --> 00:28:47.112
[? See if ?]

00:28:47.112 --> 00:28:50.130
[? this character starts in ?]--
there we go.

00:28:50.130 --> 00:28:51.465
So isn't that a lot more fun?

00:28:54.630 --> 00:28:56.335
Except I haven't implemented--

00:28:56.335 --> 00:29:01.026
[APPLAUSE]

00:29:01.026 --> 00:29:03.550
So there's one problem-- there's
no fire button yet.

00:29:12.300 --> 00:29:16.274
So it's not quite fair.

00:29:16.274 --> 00:29:17.524
All right.

00:29:21.140 --> 00:29:23.840
So that's this little app.

00:29:23.840 --> 00:29:26.980
And I want to show you a little
bit of how that app

00:29:26.980 --> 00:29:29.540
came together.

00:29:29.540 --> 00:29:31.920
One of the key things that we're
doing, of course, is

00:29:31.920 --> 00:29:35.630
measuring that gravity and
measuring acceleration.

00:29:35.630 --> 00:29:39.420
This could be because I mount
the phone in a rocket and

00:29:39.420 --> 00:29:42.550
blasted off to the moon, or
because gravity is pulling.

00:29:42.550 --> 00:29:46.640
The two both measure the same.

00:29:46.640 --> 00:29:50.860
The thing that we do is we
implement this sensor event

00:29:50.860 --> 00:29:52.180
listener interface.

00:29:52.180 --> 00:29:55.030
And then there's a special
callback method called

00:29:55.030 --> 00:29:57.020
onSensorChanged.

00:29:57.020 --> 00:30:02.140
And inside that method, we
check the current display

00:30:02.140 --> 00:30:03.620
orientation.

00:30:03.620 --> 00:30:04.660
So depending on your--

00:30:04.660 --> 00:30:08.570
you know, when you rotate your
app and the display of the app

00:30:08.570 --> 00:30:10.660
rotates with the device--

00:30:10.660 --> 00:30:14.000
the acceleration is always
measured in one direction.

00:30:14.000 --> 00:30:17.630
But the app can be any
of four directions.

00:30:17.630 --> 00:30:24.090
And so there is a little bit of
simple math that we have to

00:30:24.090 --> 00:30:27.830
do to figure out either take the
positive x or the negative

00:30:27.830 --> 00:30:30.210
y or whatever the
direction is.

00:30:30.210 --> 00:30:32.570
To simplify things in this app,
I've just hard coded the

00:30:32.570 --> 00:30:37.930
directions so this app always is
landscape in one particular

00:30:37.930 --> 00:30:39.070
orientation.

00:30:39.070 --> 00:30:41.870
This Assert statement is here
just to make sure that that's

00:30:41.870 --> 00:30:44.390
the case and I'm not
messing things up.

00:30:44.390 --> 00:30:46.640
So here, you see that math
I was talking about.

00:30:46.640 --> 00:30:52.540
The sensorX is the second event
value in a negative, and

00:30:52.540 --> 00:30:55.380
sensorY, the first one
is a positive.

00:30:55.380 --> 00:31:01.840
If the rotation of the device is
one of the other four, then

00:31:01.840 --> 00:31:03.900
the minus sign there and the
plus sign, they kind of

00:31:03.900 --> 00:31:06.080
alternate and switch around.

00:31:06.080 --> 00:31:08.980
The full source code will show
you what that looks like.

00:31:08.980 --> 00:31:13.030
In any case, every time we get
a sensor changed, we figure

00:31:13.030 --> 00:31:17.210
out what the x and y direction
are on the axis of the

00:31:17.210 --> 00:31:18.820
application display.

00:31:18.820 --> 00:31:23.260
And then we call this
updateDirections method.

00:31:23.260 --> 00:31:26.050
And then, in order to make sure
that we're saving battery

00:31:26.050 --> 00:31:30.060
life, we have to make
sure that we have

00:31:30.060 --> 00:31:31.450
start and stop methods.

00:31:31.450 --> 00:31:35.390
So that we can shut down the
accelerometer and spin it back

00:31:35.390 --> 00:31:36.450
up when we need to.

00:31:36.450 --> 00:31:40.250
So we'll call those methods
in a minute.

00:31:40.250 --> 00:31:44.060
Now, when we first started
doing this--

00:31:44.060 --> 00:31:46.750
essentially, the numbers that
you get back is, as you tilt

00:31:46.750 --> 00:31:52.220
the device, you go from seeing
zero acceleration when the

00:31:52.220 --> 00:31:57.930
device is completely level to
9.8 meters per second per

00:31:57.930 --> 00:32:02.060
second when the device is
vertical, and negative 9.8

00:32:02.060 --> 00:32:03.560
when the device is
the other way.

00:32:03.560 --> 00:32:06.780
The same thing happens in the
y direction like that.

00:32:06.780 --> 00:32:09.700
So if you're holding the device
level, you see about 0.

00:32:09.700 --> 00:32:13.780
But the sensor values actually
fluctuate a little bit.

00:32:13.780 --> 00:32:15.360
They move around.

00:32:15.360 --> 00:32:16.980
There's a little bit of
noise in the sensor.

00:32:16.980 --> 00:32:20.280
And of course, you're not
holding it entirely steady.

00:32:20.280 --> 00:32:24.640
So in the first iteration, I
picked a value just by trial

00:32:24.640 --> 00:32:27.230
and error, and said, OK, well,
at about 2 meters per second

00:32:27.230 --> 00:32:30.750
per second, the device is
tilted about right.

00:32:30.750 --> 00:32:34.700
And so if I get a reading that's
more than 2 in this

00:32:34.700 --> 00:32:36.440
direction, I move right.

00:32:36.440 --> 00:32:41.420
And if it's less than negative
2, then I move this direction.

00:32:41.420 --> 00:32:47.076
Unfortunately, what you get is
that if you're very close to

00:32:47.076 --> 00:32:51.280
that 2 value and you get that
noise, the character will go

00:32:51.280 --> 00:32:53.740
right, stop, right, stop,
right, stop, and kind of

00:32:53.740 --> 00:32:54.810
jitter around.

00:32:54.810 --> 00:32:56.690
And you end up having to push
the sensor a little bit

00:32:56.690 --> 00:33:00.690
further to make sure that the
noise doesn't get you back.

00:33:00.690 --> 00:33:04.680
So to compensate for that, you
can do some low-pass filters

00:33:04.680 --> 00:33:07.460
and some fancy math.

00:33:07.460 --> 00:33:11.030
But what I did is something
a little more just

00:33:11.030 --> 00:33:13.960
straightforward here and
introduced some stickiness.

00:33:13.960 --> 00:33:17.070
So you see that represented
in this bar here.

00:33:17.070 --> 00:33:21.360
Roughly between 0 and 2.8
is this blue section.

00:33:21.360 --> 00:33:26.720
And if the reading I get back is
between 0 and 2.8, I treat

00:33:26.720 --> 00:33:27.890
that as a key up.

00:33:27.890 --> 00:33:30.810
In other words, that key is
not currently pressed.

00:33:30.810 --> 00:33:34.780
And I have to go all the
way to 3.0 before I

00:33:34.780 --> 00:33:36.190
trigger a key press.

00:33:36.190 --> 00:33:39.350
And then everything from 3.0
above is key pressed.

00:33:39.350 --> 00:33:43.110
When I come back down, though,
instead of turning things off

00:33:43.110 --> 00:33:47.220
at 3, I don't turn them
off until I reach 2.8.

00:33:47.220 --> 00:33:50.490
So the trigger is at a different
spot than the

00:33:50.490 --> 00:33:51.700
release is.

00:33:51.700 --> 00:33:53.700
And this makes the game
a lot more playable.

00:33:53.700 --> 00:33:56.660
That way, once I tilt it, as
soon as I get to that 3, then

00:33:56.660 --> 00:34:01.040
it's kind of sticky there
until I go back to 2.8.

00:34:01.040 --> 00:34:04.000
And those numbers are kind of
arbitrary, but those are a

00:34:04.000 --> 00:34:07.100
little bit of trial and error.

00:34:07.100 --> 00:34:09.219
Now, I do that in all
four directions.

00:34:09.219 --> 00:34:12.230
There's the stickiness
on both x, y, and

00:34:12.230 --> 00:34:13.460
up, down, left, right.

00:34:13.460 --> 00:34:14.389
So here's what that
looks like.

00:34:14.389 --> 00:34:16.800
We have the updateDirections
method.

00:34:16.800 --> 00:34:19.800
We pass in the sensor x and y.

00:34:19.800 --> 00:34:25.330
And here we're looking at the
threshold to see if the x is

00:34:25.330 --> 00:34:26.690
greater than 3.

00:34:26.690 --> 00:34:30.590
That means I'm over the
red line there.

00:34:30.590 --> 00:34:36.730
In that case, I want to turn
the left button on.

00:34:36.730 --> 00:34:40.290
Now, if the sensor is less than
that threshold, minus the

00:34:40.290 --> 00:34:44.239
stickiness factor, then I turn
the left direction off.

00:34:44.239 --> 00:34:47.000
I repeat this for
the opposite.

00:34:47.000 --> 00:34:50.340
I repeat it again for the y.

00:34:50.340 --> 00:34:56.380
And then, at the very end, I
light up the buttons and say,

00:34:56.380 --> 00:34:58.310
if you're going left,
do a bright color.

00:34:58.310 --> 00:35:00.750
And if you're not, do
a darker color.

00:35:04.980 --> 00:35:07.200
So then in the main activity--

00:35:07.200 --> 00:35:12.600
this is the thing displaying the
app, the screen where you

00:35:12.600 --> 00:35:13.400
see the buttons.

00:35:13.400 --> 00:35:14.800
That's the activity--

00:35:14.800 --> 00:35:16.510
there's an onCreate method.

00:35:16.510 --> 00:35:21.610
And when we first get here,
there's a few bits of

00:35:21.610 --> 00:35:23.760
information we need.

00:35:23.760 --> 00:35:26.490
We set a flag to keep the screen
on, because I'm not

00:35:26.490 --> 00:35:27.910
touching the screen or
interacting with it.

00:35:27.910 --> 00:35:29.510
I don't want it to
go to sleep.

00:35:29.510 --> 00:35:31.660
So I do that flag.

00:35:31.660 --> 00:35:35.550
And then I get some shared
preferences where I can store

00:35:35.550 --> 00:35:40.010
which user ID the user wants
to be logged in with.

00:35:40.010 --> 00:35:42.800
I get the account manager so I
can get identity information

00:35:42.800 --> 00:35:44.470
and get OAuth keys.

00:35:44.470 --> 00:35:47.390
I get the sensor manager so
I can get access to the

00:35:47.390 --> 00:35:48.122
accelerometer.

00:35:48.122 --> 00:35:51.410
I get the display so I can
figure out the rotation.

00:35:51.410 --> 00:35:54.530
And then I set the content
view, which is,

00:35:54.530 --> 00:35:55.630
light up the display.

00:35:55.630 --> 00:35:58.280
Put the layout on there.

00:35:58.280 --> 00:35:59.930
And then you can find
the different

00:35:59.930 --> 00:36:00.970
buttons on the display.

00:36:00.970 --> 00:36:07.350
So in Android, you lay out
your display either in a

00:36:07.350 --> 00:36:10.150
WYSIWYG layout or
in XML directly.

00:36:10.150 --> 00:36:12.520
And then you have unique IDs
for all the elements.

00:36:12.520 --> 00:36:16.530
And after you display those, you
can go find them and get

00:36:16.530 --> 00:36:19.740
access references to
those objects.

00:36:19.740 --> 00:36:22.350
And then we spin up our
sensor listener,

00:36:22.350 --> 00:36:25.510
which we'll start up.

00:36:25.510 --> 00:36:27.670
Now, this is the bit about
saving battery.

00:36:27.670 --> 00:36:33.510
In the activities onResume and
onPause methods, we spin up

00:36:33.510 --> 00:36:36.680
and shut down the sensor manager
to save battery power

00:36:36.680 --> 00:36:38.650
right there.

00:36:38.650 --> 00:36:43.150
So if another popup comes up,
like a text message, or the

00:36:43.150 --> 00:36:46.930
user moves over to another app
and then comes back, we want

00:36:46.930 --> 00:36:48.965
to make sure to shut
down the sensors.

00:36:51.650 --> 00:36:54.900
Now I'm going to talk a little
bit about how the game is

00:36:54.900 --> 00:36:58.300
wired initially, and then how
I wired in the controller

00:36:58.300 --> 00:36:59.540
after that.

00:36:59.540 --> 00:37:02.860
So we have up to eight
players in the game.

00:37:02.860 --> 00:37:06.590
And each one of them has a
WebSocket Socket connecting to

00:37:06.590 --> 00:37:09.750
the game engine on
Compute Engine.

00:37:09.750 --> 00:37:14.920
And we're using socket.IO, which
has endpoints, kind of

00:37:14.920 --> 00:37:17.230
like URL endpoints.

00:37:17.230 --> 00:37:20.630
And you saw those four character
random games before.

00:37:20.630 --> 00:37:23.300
So I picked a game
here called abcd.

00:37:23.300 --> 00:37:25.890
And they're all connected
to the same game.

00:37:25.890 --> 00:37:29.700
And each of the players, as
they move, they send up

00:37:29.700 --> 00:37:30.750
physics and position

00:37:30.750 --> 00:37:33.180
information to the game engine.

00:37:33.180 --> 00:37:36.710
So each of the players will say,
my x and y is here, my

00:37:36.710 --> 00:37:42.240
velocity is this, and by the
way, I just shot off a bullet.

00:37:42.240 --> 00:37:45.340
And the game engine will compute
what's going on and

00:37:45.340 --> 00:37:48.770
then tell all the players about
what actually happened.

00:37:48.770 --> 00:37:52.840
And then each of the games is
actually predicting its own

00:37:52.840 --> 00:37:55.670
physics, but listening
to the server.

00:37:55.670 --> 00:37:59.210
So the server is
authoritative.

00:37:59.210 --> 00:38:01.840
So each of these players
has their WASD

00:38:01.840 --> 00:38:03.860
controls on their keyboard.

00:38:03.860 --> 00:38:09.750
And when they hit one of the
controls, the game logic fires

00:38:09.750 --> 00:38:14.000
off the necessary events
up to the game engine.

00:38:14.000 --> 00:38:17.060
And then the game engine fires
off all the events back down

00:38:17.060 --> 00:38:17.850
to the different players.

00:38:17.850 --> 00:38:19.870
And this is happening for all
players, all the time.

00:38:19.870 --> 00:38:24.570
So there's a lot of traffic
going back and forth.

00:38:24.570 --> 00:38:27.960
Now, we want to have an Android
controller there.

00:38:27.960 --> 00:38:30.870
And when I started out doing
this, I was trying to

00:38:30.870 --> 00:38:35.770
replicate the game logic inside
the Android controller.

00:38:35.770 --> 00:38:39.520
And that meant I would have
to worry about physics and

00:38:39.520 --> 00:38:44.210
position and have all of this
rich knowledge about the game.

00:38:44.210 --> 00:38:45.980
I didn't want to
do any of that.

00:38:45.980 --> 00:38:47.380
I'm way too lazy.

00:38:47.380 --> 00:38:50.260
I wanted to just send keystrokes
for left, right,

00:38:50.260 --> 00:38:52.530
up, down, and be done with it.

00:38:52.530 --> 00:38:53.620
I didn't even want to implement

00:38:53.620 --> 00:38:56.080
fire, as you noticed.

00:38:56.080 --> 00:39:01.320
So I decided to create another
WebSocket endpoint and

00:39:01.320 --> 00:39:02.820
actually create one
for each player.

00:39:02.820 --> 00:39:03.580
So you see these here.

00:39:03.580 --> 00:39:07.770
They're abcd!1, 2, 3, 4.

00:39:07.770 --> 00:39:10.840
And these are dedicated sockets
that four different

00:39:10.840 --> 00:39:14.420
controllers can connect to
each of these sockets.

00:39:14.420 --> 00:39:19.170
Now, here's the way it works is
the Android device connects

00:39:19.170 --> 00:39:20.710
to this other socket.

00:39:20.710 --> 00:39:24.770
And over this channel, it sends
a very simple protocol.

00:39:24.770 --> 00:39:30.120
It sends, I think, the number 3,
a colon, and then it sends

00:39:30.120 --> 00:39:34.060
four characters that are either
y or n for the four

00:39:34.060 --> 00:39:35.300
different directions.

00:39:35.300 --> 00:39:37.450
So four Booleans.

00:39:37.450 --> 00:39:42.600
The game server reflects that
back up the normal abcd

00:39:42.600 --> 00:39:45.550
channel, but in a different
protocol.

00:39:45.550 --> 00:39:48.080
This is the game protocol which
has a lot of complex

00:39:48.080 --> 00:39:52.000
messages and is something that
I didn't want to implement.

00:39:52.000 --> 00:39:56.630
So this is how I get around
having to implement the

00:39:56.630 --> 00:39:58.590
protocol is I have the
game server do the

00:39:58.590 --> 00:40:00.710
translation for me.

00:40:00.710 --> 00:40:05.130
So I'm on my Android device.

00:40:05.130 --> 00:40:07.960
And I tilt it, and I send
out a keystroke.

00:40:07.960 --> 00:40:10.270
And it goes up into the cloud.

00:40:10.270 --> 00:40:12.310
And the cloud reflects
it back down.

00:40:12.310 --> 00:40:13.860
It goes down to the browser.

00:40:13.860 --> 00:40:18.060
And then inside the browser,
rather than integrate into the

00:40:18.060 --> 00:40:21.100
game, I decided to do something
a lot more hacky,

00:40:21.100 --> 00:40:24.170
which is just to synthesize
key events and then inject

00:40:24.170 --> 00:40:25.430
them into the DOM.

00:40:25.430 --> 00:40:28.080
And that worked beautifully.

00:40:28.080 --> 00:40:30.390
So I'm going up to the cloud.

00:40:30.390 --> 00:40:32.150
It reflects down
to the browser.

00:40:32.150 --> 00:40:36.140
The browser interprets those
four flags as key up and key

00:40:36.140 --> 00:40:39.520
down events, injects those
into the page.

00:40:39.520 --> 00:40:41.660
And then the game logic just
takes over and thinks that the

00:40:41.660 --> 00:40:44.200
player pushed one of the keys.

00:40:44.200 --> 00:40:48.400
And it then sends information
up to the game engine, which

00:40:48.400 --> 00:40:50.130
interprets and then sends it
back down to the client.

00:40:50.130 --> 00:40:53.360
So I've been doing an
extra round trip,

00:40:53.360 --> 00:40:55.200
but it's a lot easier.

00:40:55.200 --> 00:40:57.890
So I got away with it.

00:40:57.890 --> 00:41:00.840
So here's what the injecting
the keystrokes looks like.

00:41:00.840 --> 00:41:03.820
In the browser, I have a
little function, wasd.

00:41:03.820 --> 00:41:06.980
And it gets messages that
look like this.

00:41:06.980 --> 00:41:10.130
After they've been unpacked out
of this dense format, they

00:41:10.130 --> 00:41:13.640
turn into these little
JavaScript objects.

00:41:13.640 --> 00:41:18.220
And here I have wasd with
true and false values.

00:41:18.220 --> 00:41:21.420
And so I just go in a For loop
for all the keys inside of

00:41:21.420 --> 00:41:23.140
this message.

00:41:23.140 --> 00:41:24.570
I create an event.

00:41:24.570 --> 00:41:27.710
If the value is true, I create
a key down event.

00:41:27.710 --> 00:41:29.930
If it's false, key up.

00:41:29.930 --> 00:41:34.580
And then I set the key code,
either W, A, S, or D. And then

00:41:34.580 --> 00:41:35.810
you dispatch the event.

00:41:35.810 --> 00:41:40.190
And the game loop
will take over.

00:41:40.190 --> 00:41:44.610
So that's my little game
controller hack there.

00:41:44.610 --> 00:41:49.310
For OAuth, in order to bind this
device to the browser,

00:41:49.310 --> 00:41:52.350
I'm having the user login with
the same Google account in

00:41:52.350 --> 00:41:53.340
both places.

00:41:53.340 --> 00:41:58.560
In both cases, I'm using
OAuth on App Engine to

00:41:58.560 --> 00:42:00.790
extract the user ID.

00:42:00.790 --> 00:42:03.570
So this is what it
looks like here.

00:42:03.570 --> 00:42:08.510
Inside the Android activity,
we get the account manager.

00:42:08.510 --> 00:42:11.300
Here, I've hardcoded it to the
first account, which is the

00:42:11.300 --> 00:42:14.310
primary account on
the device, 0.

00:42:14.310 --> 00:42:17.660
And then there's a built-in
method called getAuthToken.

00:42:17.660 --> 00:42:22.940
It gives me an OAuth2 token if
I specify an OAuth2 scope.

00:42:22.940 --> 00:42:24.620
In this case, I'm using
the email scope.

00:42:24.620 --> 00:42:27.990
So those user IDs
line up nicely.

00:42:27.990 --> 00:42:33.265
And then in the callback, I can
access the result, grab

00:42:33.265 --> 00:42:35.290
out the access token.

00:42:35.290 --> 00:42:37.490
And then I can call
my App Engine API.

00:42:37.490 --> 00:42:42.360
And I pass in that special HTTP
header, Authorization,

00:42:42.360 --> 00:42:44.980
Bearer, and then the OAuth2
access token.

00:42:44.980 --> 00:42:48.040
And App Engine will interpret
that, figure out the user ID,

00:42:48.040 --> 00:42:50.410
and give that back to me.

00:42:50.410 --> 00:42:54.200
Now, if the user clicks No
Thanks on this page that pops

00:42:54.200 --> 00:42:56.580
up, then I'll actually
get an exception

00:42:56.580 --> 00:42:57.940
here, operation canceled.

00:42:57.940 --> 00:42:59.670
And I have to figure
out what to do.

00:42:59.670 --> 00:43:01.070
I guess I can't continue
as the app.

00:43:01.070 --> 00:43:02.880
And I can tell the user,
well, sorry.

00:43:02.880 --> 00:43:04.870
You can't use this game
if you don't give me

00:43:04.870 --> 00:43:07.240
access to your account.

00:43:07.240 --> 00:43:10.470
But that is a condition
we need to handle.

00:43:10.470 --> 00:43:13.910
Now, there's a couple things
that we didn't take care of in

00:43:13.910 --> 00:43:16.410
this game that, if you're doing
this in a real game, you

00:43:16.410 --> 00:43:18.700
should worry about.

00:43:18.700 --> 00:43:22.210
The confused deputy problem
is one of them.

00:43:22.210 --> 00:43:25.310
And I give you the Wikipedia
link to look this up.

00:43:25.310 --> 00:43:30.190
But essentially, right now, this
application is requesting

00:43:30.190 --> 00:43:35.250
a token that proves that
the user was there.

00:43:35.250 --> 00:43:38.820
But we're not currently
authenticating that this token

00:43:38.820 --> 00:43:42.640
actually originated from
my Android app.

00:43:42.640 --> 00:43:45.690
You could build an Android app,
get one of these tokens.

00:43:45.690 --> 00:43:47.270
And then you could call
my App Engine service

00:43:47.270 --> 00:43:48.550
and give me the token.

00:43:48.550 --> 00:43:53.380
And all I know is that that same
user was behind your app.

00:43:53.380 --> 00:43:55.360
But I don't know that they
came from my app.

00:43:55.360 --> 00:43:57.830
So that's actually a security
problem here.

00:43:57.830 --> 00:44:00.500
And it's called the confused
deputy problem.

00:44:00.500 --> 00:44:03.690
And there's some workarounds for
that, but for this demo,

00:44:03.690 --> 00:44:05.000
we didn't do it.

00:44:05.000 --> 00:44:08.560
The other thing you need
to do is that these

00:44:08.560 --> 00:44:10.520
access tokens expire.

00:44:10.520 --> 00:44:12.980
So when you look at these
examples, they work great.

00:44:12.980 --> 00:44:13.410
You go to bed.

00:44:13.410 --> 00:44:14.330
You wake up in the morning.

00:44:14.330 --> 00:44:16.280
And then the tokens
stop working.

00:44:16.280 --> 00:44:20.140
That's because you need
to expire them and

00:44:20.140 --> 00:44:22.010
then get new tokens.

00:44:22.010 --> 00:44:24.650
What a lot of people do is they
just always expire the

00:44:24.650 --> 00:44:27.920
token before they get a token,
rather than trying to make a

00:44:27.920 --> 00:44:30.640
connection, and then if it
fails, expire the old one and

00:44:30.640 --> 00:44:31.890
grab a new one.

00:44:31.890 --> 00:44:33.500
You can do either way.

00:44:33.500 --> 00:44:34.750
It's up to you.

00:44:37.610 --> 00:44:41.350
So we are using a number of
services on App Engine that we

00:44:41.350 --> 00:44:42.010
looked at so far.

00:44:42.010 --> 00:44:45.520
We have the PageSpeed service
for optimizing the content.

00:44:45.520 --> 00:44:46.720
We have the App Engine
frontends

00:44:46.720 --> 00:44:48.650
where we run our code.

00:44:48.650 --> 00:44:51.890
We have the High Replication
Datastore where actually

00:44:51.890 --> 00:44:55.900
persisting data, player data,
number of wins, number of

00:44:55.900 --> 00:45:00.300
losses, number of credits
for virtual items--

00:45:00.300 --> 00:45:02.730
which you can't buy just yet,
but that's coming soon.

00:45:02.730 --> 00:45:05.660
And then we're using the OAuth
APIs to authenticate users.

00:45:09.800 --> 00:45:11.510
Now, the High Replication
Datastore--

00:45:14.270 --> 00:45:17.750
there's many talks that you
should probably look at if you

00:45:17.750 --> 00:45:19.830
want to start using it and
fully understand it.

00:45:19.830 --> 00:45:22.660
A really good one is this one
from Google I/O last year,

00:45:22.660 --> 00:45:26.380
More 9s Please, talking about
the differences between the

00:45:26.380 --> 00:45:29.520
Master/Slave Datastore and the
High Replication Datastore,

00:45:29.520 --> 00:45:30.960
and all its advantages.

00:45:30.960 --> 00:45:33.710
What we're using it for is
really simple stuff.

00:45:33.710 --> 00:45:36.740
We're storing some global
configuration information.

00:45:36.740 --> 00:45:40.630
These are OAuth client IDs and
secrets, and then some user

00:45:40.630 --> 00:45:41.970
information--

00:45:41.970 --> 00:45:44.520
the wins, losses, and credits.

00:45:44.520 --> 00:45:47.220
And I mentioned the
virtual items.

00:45:47.220 --> 00:45:49.250
So the way we do that
is we have a little

00:45:49.250 --> 00:45:51.900
Python class, db_api.

00:45:51.900 --> 00:45:58.620
And we're using NDB, which is
Python's new database module.

00:45:58.620 --> 00:46:00.970
It does some fantastic
magic for you.

00:46:00.970 --> 00:46:03.490
It caches in memory inside
the instance.

00:46:03.490 --> 00:46:05.980
It caches inside a memcache
before it

00:46:05.980 --> 00:46:07.470
accesses the datastore.

00:46:07.470 --> 00:46:12.120
So if you use NDB, it's
definitely an upgrade from DB.

00:46:12.120 --> 00:46:14.430
It's a better API.

00:46:14.430 --> 00:46:17.300
And it reduces the number of
datastore writes that you have

00:46:17.300 --> 00:46:20.590
and datastore reads, because
we have this extra caching

00:46:20.590 --> 00:46:21.650
layer built in.

00:46:21.650 --> 00:46:25.870
And the use is basically
the same.

00:46:25.870 --> 00:46:28.960
For this user class, we
have a display name

00:46:28.960 --> 00:46:30.590
and a create date.

00:46:30.590 --> 00:46:33.850
And this is all we have to do
to declare the class, just

00:46:33.850 --> 00:46:36.640
these two lines of
code right here.

00:46:36.640 --> 00:46:38.520
We also add in number of
wins and number of

00:46:38.520 --> 00:46:40.850
losses, and then credits.

00:46:40.850 --> 00:46:43.910
So we have five properties
total storing all the

00:46:43.910 --> 00:46:45.860
information about the user--

00:46:45.860 --> 00:46:46.980
sorry, six.

00:46:46.980 --> 00:46:49.140
And we have these hidden
virtual items that

00:46:49.140 --> 00:46:50.170
you can't buy yet.

00:46:50.170 --> 00:46:52.210
But these are essentially
weapons upgrades

00:46:52.210 --> 00:46:53.210
and things like that.

00:46:53.210 --> 00:46:56.890
So as your scores increase,
you get credits.

00:46:56.890 --> 00:46:59.540
And then with credits, you
can buy virtual items.

00:47:04.470 --> 00:47:09.300
Now, managing all these
different servers--

00:47:09.300 --> 00:47:12.400
we have multiple game servers
running, we have App Engine--

00:47:12.400 --> 00:47:14.150
is quite a bit of work.

00:47:14.150 --> 00:47:17.740
And I wanted to give you a
little bit of insight of what

00:47:17.740 --> 00:47:20.750
that looks like, what the JSON
flows look like, and the

00:47:20.750 --> 00:47:23.760
communication between the
different pieces.

00:47:23.760 --> 00:47:29.880
So we have, potentially, an
administrator, one of the game

00:47:29.880 --> 00:47:32.250
creators that's trying to look
at the game, debug things.

00:47:32.250 --> 00:47:34.480
We have the actual player.

00:47:34.480 --> 00:47:38.670
Then we have the App Engine,
which has zero if there's no

00:47:38.670 --> 00:47:41.210
traffic, or many backends if
there's a lot of traffic at

00:47:41.210 --> 00:47:42.200
that moment.

00:47:42.200 --> 00:47:45.510
We currently have one App
Engine backend that is

00:47:45.510 --> 00:47:47.550
coordinating all the
matchmaking.

00:47:47.550 --> 00:47:53.270
And then on Compute Engine, on
each instance, we have a

00:47:53.270 --> 00:47:57.770
node.js controller, and then
potentially many games.

00:47:57.770 --> 00:48:00.690
And all of these components need
to talk to each other and

00:48:00.690 --> 00:48:02.900
exchange information.

00:48:02.900 --> 00:48:08.810
So what happens is each time a
node.js instance starts up, in

00:48:08.810 --> 00:48:11.550
its initial startup script,
it calls home.

00:48:11.550 --> 00:48:13.590
It calls the App Engine
matchmaker.

00:48:13.590 --> 00:48:15.350
And it registers itself.

00:48:15.350 --> 00:48:18.230
And it's basically telling App
Engine, hey, I'm available.

00:48:18.230 --> 00:48:20.000
I'm ready to spin up
games for you.

00:48:20.000 --> 00:48:23.690
Whenever you're ready,
send me players.

00:48:23.690 --> 00:48:25.320
Then there's a player
that comes in.

00:48:25.320 --> 00:48:26.260
They load up the page.

00:48:26.260 --> 00:48:27.300
So they go to index.html.

00:48:27.300 --> 00:48:29.170
They get a bunch of resources.

00:48:29.170 --> 00:48:30.940
And eventually they
click Quick Game.

00:48:30.940 --> 00:48:34.340
And they call this Grits method,
this findGame method.

00:48:34.340 --> 00:48:37.610
And they talk to one of the
frontends, which just passes

00:48:37.610 --> 00:48:40.610
the information on
to the backend.

00:48:40.610 --> 00:48:44.250
The backend then goes and
pings all the node.js

00:48:44.250 --> 00:48:47.670
instances very quickly to find
out if they're all still alive

00:48:47.670 --> 00:48:48.650
and healthy.

00:48:48.650 --> 00:48:50.920
And it picks one at random.

00:48:50.920 --> 00:48:53.910
And it calls start-game,
requesting it

00:48:53.910 --> 00:48:55.330
to start up a game.

00:48:55.330 --> 00:48:57.570
If the instance rejects, then
it just goes on to the next

00:48:57.570 --> 00:48:59.250
one and calls start-game
there.

00:48:59.250 --> 00:49:03.470
But assuming it accepts, that
instance will create a

00:49:03.470 --> 00:49:05.860
brand-new game, empty game
with no players.

00:49:05.860 --> 00:49:08.880
That information is given all
the way back to the player.

00:49:08.880 --> 00:49:12.180
And the browser opens a
WebSocket connection directly

00:49:12.180 --> 00:49:15.710
to the node.js instance using
the IP address in the port

00:49:15.710 --> 00:49:18.310
provided to it and the name
of the game, which is this

00:49:18.310 --> 00:49:21.600
four-character random
sequence.

00:49:21.600 --> 00:49:23.690
So at that point, that
player is in the

00:49:23.690 --> 00:49:25.820
game, playing the game.

00:49:25.820 --> 00:49:27.470
Other players follow
this flow.

00:49:27.470 --> 00:49:29.810
And they're all communicating
directly to

00:49:29.810 --> 00:49:31.610
this backend instance.

00:49:31.610 --> 00:49:34.670
Then as players drop out or the
game finishes, we'll get

00:49:34.670 --> 00:49:39.200
this update-game-state message
back to App Engine, giving us

00:49:39.200 --> 00:49:40.440
the summary of what happened.

00:49:40.440 --> 00:49:41.310
How many kills?

00:49:41.310 --> 00:49:42.480
How many wins?

00:49:42.480 --> 00:49:43.900
How many points did
players do?

00:49:43.900 --> 00:49:46.350
How many games did they play?

00:49:46.350 --> 00:49:50.830
And then the game-over URL when
the game actually ends.

00:49:50.830 --> 00:49:54.830
Separately, the admin might
do some debugging here.

00:49:54.830 --> 00:49:58.620
We have a couple of callback
hooks like list-games to see

00:49:58.620 --> 00:50:00.220
how many games are active.

00:50:00.220 --> 00:50:03.790
We have this debug call, which
is the big JSON block I showed

00:50:03.790 --> 00:50:05.600
you earlier.

00:50:05.600 --> 00:50:10.060
And then we can talk to the
individual node backends and

00:50:10.060 --> 00:50:12.730
get some login information.

00:50:12.730 --> 00:50:17.150
So here's that big debug section
you saw earlier.

00:50:17.150 --> 00:50:20.420
Let's see list-games,
what it shows us.

00:50:20.420 --> 00:50:23.350
OK, so this gives us--

00:50:23.350 --> 00:50:23.750
let me see.

00:50:23.750 --> 00:50:26.140
There's one server right here.

00:50:26.140 --> 00:50:28.130
There's a game.

00:50:28.130 --> 00:50:30.400
There's a second game.

00:50:30.400 --> 00:50:32.300
And that's it.

00:50:32.300 --> 00:50:35.980
And if we look at one of these
games right here, you can see

00:50:35.980 --> 00:50:36.900
the different information.

00:50:36.900 --> 00:50:40.300
So this is the control host.

00:50:40.300 --> 00:50:43.450
This is where the main
instance is running.

00:50:43.450 --> 00:50:48.290
This is the WebSocket URL where
the game is running.

00:50:48.290 --> 00:50:49.860
This game supports a
maximum of eight

00:50:49.860 --> 00:50:52.510
players, minimum of one.

00:50:52.510 --> 00:50:56.980
And currently, there are three
players inside this game.

00:50:56.980 --> 00:51:02.580
And it's been running for
173 seconds right now.

00:51:02.580 --> 00:51:05.200
So there's some happy
players right now.

00:51:10.090 --> 00:51:12.550
Let me get through
this slide again.

00:51:16.260 --> 00:51:19.260
So that findGame call invokes
this matchmaking service that

00:51:19.260 --> 00:51:20.910
I've been talking about.

00:51:20.910 --> 00:51:23.020
And so I wanted to walk
through that real

00:51:23.020 --> 00:51:24.410
briefly with you.

00:51:24.410 --> 00:51:25.710
We've done something
very simple.

00:51:25.710 --> 00:51:27.590
We're not doing anything
skills based.

00:51:27.590 --> 00:51:30.250
We're just allotting players
to different slots.

00:51:30.250 --> 00:51:32.330
So we have this queue
of players.

00:51:32.330 --> 00:51:34.020
And it's a first come,
first served.

00:51:34.020 --> 00:51:36.570
As you drop into the queue, you
have the first opportunity

00:51:36.570 --> 00:51:38.480
to play the game.

00:51:38.480 --> 00:51:39.560
So a player drops in.

00:51:39.560 --> 00:51:40.480
We get a couple more.

00:51:40.480 --> 00:51:41.730
Then we get a few
more players.

00:51:41.730 --> 00:51:44.970
And now, suddenly, we have a
whole backlog of players.

00:51:44.970 --> 00:51:46.750
So we call this startGame
method.

00:51:46.750 --> 00:51:48.330
Start up a game.

00:51:48.330 --> 00:51:51.430
Minimum of two-- so we're going
to take two players out

00:51:51.430 --> 00:51:54.400
and shift them into
the first game.

00:51:54.400 --> 00:51:55.575
We slide everyone up.

00:51:55.575 --> 00:51:57.660
And we'll repeat this process.

00:51:57.660 --> 00:52:01.630
And we're constantly trying
to fill up new games.

00:52:01.630 --> 00:52:03.430
So now we have three different
games going,

00:52:03.430 --> 00:52:04.500
two players in each.

00:52:04.500 --> 00:52:06.810
And we only have one
player left.

00:52:06.810 --> 00:52:09.360
Now, if we drop this player into
a new game, they wouldn't

00:52:09.360 --> 00:52:11.180
be able to play.

00:52:11.180 --> 00:52:13.040
Because they would have to
wait for someone else.

00:52:13.040 --> 00:52:14.510
So what we're going to do
instead is we're going to

00:52:14.510 --> 00:52:17.680
slide them into one of the
remaining slots and have them

00:52:17.680 --> 00:52:20.020
drop into an existing game.

00:52:20.020 --> 00:52:23.450
So that's the entire
matchmaking

00:52:23.450 --> 00:52:25.610
service right there.

00:52:25.610 --> 00:52:27.680
So in code, what does
that look like?

00:52:27.680 --> 00:52:31.010
Well, we do this two-pass flow
that I talked about.

00:52:31.010 --> 00:52:34.230
If there's no players waiting,
there's nothing to do.

00:52:34.230 --> 00:52:38.250
Otherwise, we do a first pass,
which is we match players

00:52:38.250 --> 00:52:41.400
based on the minimum number
of players in the game.

00:52:41.400 --> 00:52:42.820
So that's two per game.

00:52:42.820 --> 00:52:47.000
And then we go across until we
can no longer fill up slots.

00:52:47.000 --> 00:52:49.740
And then we do the second pass,
which is do matchmaking

00:52:49.740 --> 00:52:51.630
based on the maximum
number of players.

00:52:51.630 --> 00:52:54.940
So in this phase, we're filling
everything up until

00:52:54.940 --> 00:52:56.190
eight players.

00:52:59.910 --> 00:53:04.790
Now, I'll skip this
min method.

00:53:04.790 --> 00:53:08.960
You can read that later.

00:53:08.960 --> 00:53:11.700
Now, let's say we want to
scale things up a bit.

00:53:11.700 --> 00:53:13.610
I said we had one
matcher backend.

00:53:13.610 --> 00:53:16.100
And that can handle quite
a bit of capacity.

00:53:16.100 --> 00:53:18.750
But if this game became really,
really popular, we

00:53:18.750 --> 00:53:21.190
might actually want
more backends.

00:53:21.190 --> 00:53:23.530
Now, App Engine already takes
care of frontends for us.

00:53:23.530 --> 00:53:26.600
As traffic comes in, it will
spin up additional instances.

00:53:26.600 --> 00:53:28.080
And before you know it,
you might have a

00:53:28.080 --> 00:53:29.910
large number of instances.

00:53:29.910 --> 00:53:31.110
Backends are a little
bit different.

00:53:31.110 --> 00:53:34.930
They're designed for long
running jobs or jobs where you

00:53:34.930 --> 00:53:38.400
want a specific server that
you can identify.

00:53:38.400 --> 00:53:42.290
But backends do have this
feature where you can make

00:53:42.290 --> 00:53:46.410
them be dynamic and behave
like frontends.

00:53:46.410 --> 00:53:50.890
But at the same time, backends
know which backend number they

00:53:50.890 --> 00:53:52.200
are, which backend instance
they are.

00:53:52.200 --> 00:53:53.960
So you can make them
kind of sticky.

00:53:53.960 --> 00:53:57.040
So we can imagine doing that.

00:53:57.040 --> 00:53:58.270
So let's say we have
one backend.

00:53:58.270 --> 00:54:01.750
And we have all the traffic
going there.

00:54:01.750 --> 00:54:02.890
We decide we need more.

00:54:02.890 --> 00:54:06.470
So we would change our
backends.yaml.

00:54:06.470 --> 00:54:09.210
And we'll say we'll have three
instances instead of one.

00:54:09.210 --> 00:54:12.870
And we specify that they're
dynamic, which means App

00:54:12.870 --> 00:54:17.340
Engine will spin up more as
the earlier ones get busy.

00:54:17.340 --> 00:54:20.000
Now what happens here is that
now, traffic is being routed

00:54:20.000 --> 00:54:20.770
all over the place.

00:54:20.770 --> 00:54:22.360
Any time you call a
backend, you get

00:54:22.360 --> 00:54:24.210
routed to a random backend.

00:54:24.210 --> 00:54:27.350
And that's not really what you
want, because we want players

00:54:27.350 --> 00:54:33.290
that are coming in to always
reach the same backend.

00:54:33.290 --> 00:54:36.550
And we can do that by specifying
a different URL.

00:54:36.550 --> 00:54:40.620
We can specify the instance
number, 0, 1, or 2, in front

00:54:40.620 --> 00:54:44.090
of the backend name, matcher,
in front of the app ID,

00:54:44.090 --> 00:54:45.340
gritsgame.appspot.com.

00:54:47.210 --> 00:54:50.550
So what that looks like in the
backend is when one of these

00:54:50.550 --> 00:54:54.080
random calls come in,
we can actually call

00:54:54.080 --> 00:54:56.040
backends.get_instance().

00:54:56.040 --> 00:54:57.910
That way, we know what
instance we are--

00:54:57.910 --> 00:54:59.220
say, 2.

00:54:59.220 --> 00:55:03.340
And then we can create a
new URL based on that.

00:55:03.340 --> 00:55:06.680
So we get one of those
2.matcher.gritsgame.com.

00:55:06.680 --> 00:55:10.860
And in our response back to the
client, we can tell them

00:55:10.860 --> 00:55:15.750
what URL to use next time they
call home so that they contact

00:55:15.750 --> 00:55:16.920
the same person.

00:55:16.920 --> 00:55:19.070
And so now we have dynamic
backends that scale up and

00:55:19.070 --> 00:55:20.600
down with load.

00:55:20.600 --> 00:55:24.390
But as users connect to
backends, they'll be told to

00:55:24.390 --> 00:55:25.750
reconnect to the same backend.

00:55:25.750 --> 00:55:28.760
So we still get the stickiness
benefit.

00:55:28.760 --> 00:55:30.235
And then things look
much nicer.

00:55:30.235 --> 00:55:31.690
They look exactly
the way we want.

00:55:34.520 --> 00:55:39.200
Now, when you're building
games, one of things you

00:55:39.200 --> 00:55:41.360
really need to do is
do load tests.

00:55:41.360 --> 00:55:43.570
Unless you're just building
the game for you and three

00:55:43.570 --> 00:55:44.700
other friends.

00:55:44.700 --> 00:55:48.040
Hopefully, that's the weekend
project, and you're thinking

00:55:48.040 --> 00:55:49.520
about something else.

00:55:49.520 --> 00:55:51.630
A lot of people start
out doing load tests

00:55:51.630 --> 00:55:53.630
essentially like this.

00:55:53.630 --> 00:55:55.840
They have zero traffic.

00:55:55.840 --> 00:55:57.700
And then they flip
on the load test.

00:55:57.700 --> 00:56:00.190
And they want to do 1,000
requests per second,

00:56:00.190 --> 00:56:01.650
instantaneously.

00:56:01.650 --> 00:56:03.100
And then they get a bunch
of error messages.

00:56:03.100 --> 00:56:05.050
And they wonder why.

00:56:05.050 --> 00:56:07.240
Natural traffic really doesn't
behave like this.

00:56:07.240 --> 00:56:10.730
Even if your game were to get
slashdotted, your traffic

00:56:10.730 --> 00:56:13.380
would not look like this.

00:56:13.380 --> 00:56:16.360
A graph like this is a
little bit better.

00:56:16.360 --> 00:56:18.660
Ramp it up over time.

00:56:18.660 --> 00:56:21.450
Much more ideal is probably
something like this.

00:56:21.450 --> 00:56:28.050
Now, the basic recipe for
doing load tests goes

00:56:28.050 --> 00:56:29.560
something like this.

00:56:29.560 --> 00:56:32.510
Send some steady-state traffic--
about, let's say,

00:56:32.510 --> 00:56:34.850
start with five queries
per second.

00:56:34.850 --> 00:56:38.750
And then you uncover
any bottlenecks.

00:56:38.750 --> 00:56:41.820
If you have, say, a global
counter that all your requests

00:56:41.820 --> 00:56:45.260
are connecting to, you'll
already see issues here.

00:56:45.260 --> 00:56:46.820
So you fix that up.

00:56:46.820 --> 00:56:48.980
Everything's going
beautiful again.

00:56:48.980 --> 00:56:52.210
And then you wait about
15, maybe 20 minutes.

00:56:52.210 --> 00:56:55.410
And you look at your dashboard
at all your graphs.

00:56:55.410 --> 00:56:57.660
You make sure you have
zero quota denials.

00:56:57.660 --> 00:56:59.530
Your error rates
are really low.

00:56:59.530 --> 00:57:03.620
All your tasks are keeping up
and not forming a backlog, and

00:57:03.620 --> 00:57:06.340
no elevated datastore
contention.

00:57:06.340 --> 00:57:08.800
And if you have any of these
issues, you make adjustments

00:57:08.800 --> 00:57:10.640
in your app.

00:57:10.640 --> 00:57:14.430
And then you slowly ramp up to
about twice that traffic.

00:57:14.430 --> 00:57:18.540
So you go from 5 to 10,
to 20, to 40, to 80.

00:57:18.540 --> 00:57:22.540
And very quickly, you'll be in
hundreds or thousands of QPS.

00:57:22.540 --> 00:57:25.910
Yet through this stepped
process, you can uncover

00:57:25.910 --> 00:57:30.800
bottlenecks at different
levels of resource

00:57:30.800 --> 00:57:32.530
requirements in your
application.

00:57:32.530 --> 00:57:36.150
And it's a lot easier to
diagnose issues than flipping

00:57:36.150 --> 00:57:39.820
the switch, going to 1,000
requests per second, and then

00:57:39.820 --> 00:57:42.140
not being able to see what's
going on because everything is

00:57:42.140 --> 00:57:44.840
blowing up in your face.

00:57:44.840 --> 00:57:47.550
So you uncover the next
bottleneck if you have any.

00:57:47.550 --> 00:57:49.780
If you've done all your homework
and done things

00:57:49.780 --> 00:57:51.820
correctly, you should be fine.

00:57:51.820 --> 00:57:56.120
And then you repeat and iterate
until you've reached

00:57:56.120 --> 00:57:58.610
the goal traffic rate.

00:57:58.610 --> 00:58:01.730
And then you relax and plan
your next feature and plan

00:58:01.730 --> 00:58:02.980
your next load test.

00:58:07.740 --> 00:58:09.560
Some other pro tips, especially
if you're building

00:58:09.560 --> 00:58:10.920
mobile backends--

00:58:10.920 --> 00:58:13.490
don't have all your devices call
home at the same time of

00:58:13.490 --> 00:58:15.990
day every night.

00:58:15.990 --> 00:58:19.730
Even though there's different
time zones in the world, you

00:58:19.730 --> 00:58:22.540
don't want 24 of these spikes
across your application.

00:58:22.540 --> 00:58:24.480
That won't do very well.

00:58:24.480 --> 00:58:27.630
And also, make sure that your
retry times are a little bit

00:58:27.630 --> 00:58:30.420
randomized and that you use
exponential back-off.

00:58:30.420 --> 00:58:32.200
Otherwise, your app might
be serving right,

00:58:32.200 --> 00:58:33.420
goes down for a minute.

00:58:33.420 --> 00:58:36.210
And then you have every single
client out there.

00:58:36.210 --> 00:58:39.840
You have a million mobile
app users out there.

00:58:39.840 --> 00:58:43.780
They all wait exactly two
minutes and then call home.

00:58:43.780 --> 00:58:45.020
And of course, most
of them will fail.

00:58:45.020 --> 00:58:46.490
So they all sit back
for two minutes.

00:58:46.490 --> 00:58:47.770
And then they call home.

00:58:47.770 --> 00:58:49.640
And you get this repeated
Denial of

00:58:49.640 --> 00:58:51.660
Service attack on yourself.

00:58:51.660 --> 00:58:52.970
So don't do that.

00:58:57.830 --> 00:58:59.440
I'm going to skip over
some of this.

00:58:59.440 --> 00:59:02.400
You can read this later.

00:59:02.400 --> 00:59:08.730
So what you saw here is
building JSON APIs,

00:59:08.730 --> 00:59:12.580
integrating with OAuth, using
matchmaking in backends,

00:59:12.580 --> 00:59:14.080
taking an Android app.

00:59:14.080 --> 00:59:18.590
Kind of all the basic building
blocks for backend services.

00:59:18.590 --> 00:59:21.290
Colt's talk, which was the
complementary to this one,

00:59:21.290 --> 00:59:25.920
talked all about the frontend,
how you build atlases and

00:59:25.920 --> 00:59:30.260
sprite sheets, how you put
together all the JavaScript,

00:59:30.260 --> 00:59:32.440
how you create the protocol
messages.

00:59:32.440 --> 00:59:36.710
So really, you should
have pretty good

00:59:36.710 --> 00:59:39.030
information to get started.

00:59:39.030 --> 00:59:43.080
Now, I know we're actually
out of time here.

00:59:43.080 --> 00:59:47.590
But I wanted to briefly show
you this other idea that

00:59:47.590 --> 00:59:48.840
didn't quite come together.

00:59:52.760 --> 00:59:54.900
So this is almost an
identical app.

00:59:58.105 --> 00:59:59.988
And here we go.

01:00:04.260 --> 01:00:05.880
So the next phase--

01:00:05.880 --> 01:00:09.140
rather than have this controller
wired directly into

01:00:09.140 --> 01:00:12.500
a game, I thought I could
make a controller that

01:00:12.500 --> 01:00:16.610
wired into any game.

01:00:16.610 --> 01:00:20.150
For example, this game
that I heard of that

01:00:20.150 --> 01:00:24.090
was created in 2007.

01:00:24.090 --> 01:00:26.090
So we can go to--

01:00:26.090 --> 01:00:29.030
I built an extension
this morning.

01:00:29.030 --> 01:00:36.330
And this extension uses
WebSockets to

01:00:36.330 --> 01:00:37.830
connect to the phone.

01:00:37.830 --> 01:00:41.650
And let's see if it
will connect back.

01:00:41.650 --> 01:00:43.100
Oh, it's working.

01:00:43.100 --> 01:00:45.120
So you see all these
messages here.

01:00:45.120 --> 01:00:51.040
Those are actually coming
down from this device.

01:00:51.040 --> 01:00:55.130
And you see as I tilt it, we get
different Boolean values.

01:00:55.130 --> 01:00:58.490
And this one does actually
have a Shoot button.

01:00:58.490 --> 01:01:02.530
When I hit it, I get a little
asterisk there.

01:01:02.530 --> 01:01:05.560
Now, the game's not working yet,
because I didn't quite

01:01:05.560 --> 01:01:08.530
finish this.

01:01:08.530 --> 01:01:11.250
Let me turn off the extension
for a moment.

01:01:11.250 --> 01:01:14.540
The very last piece of wiring,
that I'm going to put together

01:01:14.540 --> 01:01:20.400
probably this weekend, is
actually injecting the

01:01:20.400 --> 01:01:20.920
keystrokes.

01:01:20.920 --> 01:01:23.500
And this is the code I
showed you before.

01:01:23.500 --> 01:01:24.750
So you see here--

01:01:28.070 --> 01:01:29.730
let's see if I can zoom
in here for you--

01:01:29.730 --> 01:01:33.380
we have keyCode 32,
which is a space.

01:01:33.380 --> 01:01:36.240
And this game needs
a space to start.

01:01:36.240 --> 01:01:38.820
So if I inject this piece of
JavaScript into this page

01:01:38.820 --> 01:01:40.870
right now, the game starts.

01:01:45.980 --> 01:01:48.870
So imagine this game controller
wired up into any

01:01:48.870 --> 01:01:51.220
game with this Chrome
extension.

01:01:51.220 --> 01:01:53.620
So you could play any game on
the web that has WASD as the

01:01:53.620 --> 01:01:55.440
keys, or the arrow keys.

01:01:55.440 --> 01:01:57.930
And you just pick up your
Android device.

01:01:57.930 --> 01:01:58.790
And you tilt it.

01:01:58.790 --> 01:02:01.230
And it injects keystrokes
in the page.

01:02:01.230 --> 01:02:05.460
That is the demo you did
not see here today.

01:02:05.460 --> 01:02:06.710
Sorry about that.

01:02:10.520 --> 01:02:11.420
That's it.

01:02:11.420 --> 01:02:12.320
Sorry about that.

01:02:12.320 --> 01:02:12.620
Thank you.

01:02:12.620 --> 01:02:16.737
[APPLAUSE]

