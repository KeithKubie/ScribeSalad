WEBVTT
Kind: captions
Language: en

00:00:01.290 --> 00:00:03.680
Hi out there in internet land.

00:00:03.680 --> 00:00:05.205
My name is Bob Nystrom.

00:00:05.205 --> 00:00:08.010
I'm a Googler working
on the Dart Project.

00:00:08.010 --> 00:00:11.260
Specifically, I spend most of my
time hacking on Pub, which

00:00:11.260 --> 00:00:12.600
is our package manager.

00:00:12.600 --> 00:00:15.160
But when I'm not doing that, I
spend a lot of time talking

00:00:15.160 --> 00:00:18.250
about Dart online, in like
mailing lists, and Reddit, and

00:00:18.250 --> 00:00:19.710
stuff like that.

00:00:19.710 --> 00:00:24.010
So when we let Dart into the
wild last October, I mentally

00:00:24.010 --> 00:00:27.410
prepared myself for wave
a of invective.

00:00:27.410 --> 00:00:29.620
I figured there are few things
people love more than

00:00:29.620 --> 00:00:31.210
complaining about new
programming languages.

00:00:31.210 --> 00:00:33.720
I mean, there's few things I
love more than complaining

00:00:33.720 --> 00:00:35.570
about new programming
languages.

00:00:35.570 --> 00:00:38.770
But I was just prepared for
people saying Dart is bad

00:00:38.770 --> 00:00:39.980
technically.

00:00:39.980 --> 00:00:42.540
What made me a little sad
thought, was people saying

00:00:42.540 --> 00:00:44.920
Dart was bad in the
moral sense.

00:00:44.920 --> 00:00:47.830
Not just that it was a bad
language, but that it was bad

00:00:47.830 --> 00:00:51.890
for the world, or at least the
web, for it to exist--

00:00:51.890 --> 00:00:54.480
like it was evil.

00:00:54.480 --> 00:00:57.110
In case you missed out, here's
my understanding of what

00:00:57.110 --> 00:00:58.400
people were saying.

00:00:58.400 --> 00:01:01.280
So back in the early days, of
the web, during the browser

00:01:01.280 --> 00:01:04.200
wars of the '90s, Microsoft
created this language call

00:01:04.200 --> 00:01:07.010
VBScript and put it in
Internet Explorer.

00:01:07.010 --> 00:01:09.160
If you didn't want to write
your client-side code in

00:01:09.160 --> 00:01:12.120
JavaScript, you could write
it in VBScript instead.

00:01:12.120 --> 00:01:14.050
The rub, though, was
that VBScript was

00:01:14.050 --> 00:01:15.820
only in Internet Explorer.

00:01:15.820 --> 00:01:17.700
And that basically broke
the web in half.

00:01:17.700 --> 00:01:21.120
So instead of a single
standards-based, open web that

00:01:21.120 --> 00:01:24.270
all users can participate in
equally, you had this part of

00:01:24.270 --> 00:01:27.140
the web using VBScript that
only worked in IE, and the

00:01:27.140 --> 00:01:29.380
rest of the web that worked
in any browser.

00:01:29.380 --> 00:01:32.090
And that's bad for users
because it stifles

00:01:32.090 --> 00:01:32.990
competition.

00:01:32.990 --> 00:01:35.940
If any given website only works
on a single browser,

00:01:35.940 --> 00:01:38.940
then browsers can't compete
for that user's attention.

00:01:38.940 --> 00:01:40.750
They're already locked in.

00:01:40.750 --> 00:01:42.980
So then Google comes along
with our client-side web

00:01:42.980 --> 00:01:45.340
language, Dart, and we talk
about having this nice native

00:01:45.340 --> 00:01:48.100
virtual machine for it that we
want to put into Chrome.

00:01:48.100 --> 00:01:50.720
And this starts to sound
like a familiar story.

00:01:50.720 --> 00:01:56.220
So people got kind of nervous,
and angry, and started saying

00:01:56.220 --> 00:01:58.140
not very nice things about us.

00:01:58.140 --> 00:02:02.390
And that kind of made me
wonder, was I evil?

00:02:02.390 --> 00:02:05.350
I mean, I don't feel evil, but
I'm guessing that most

00:02:05.350 --> 00:02:06.200
villains don't, right?

00:02:06.200 --> 00:02:08.389
Like maybe I'm on the
dark side and I just

00:02:08.389 --> 00:02:09.880
don't realize it.

00:02:09.880 --> 00:02:12.220
So I started doing some
soul searching.

00:02:12.220 --> 00:02:13.500
This is me and my dog.

00:02:13.500 --> 00:02:16.040
You can see I'm literally
soul searching here.

00:02:16.040 --> 00:02:18.360
The dog is too, I guess.

00:02:18.360 --> 00:02:21.900
Could this be the image of some
kind of evil villain?

00:02:21.900 --> 00:02:23.400
Well, I found a couple
of problems.

00:02:23.400 --> 00:02:27.100
First, try as I might, I'm
actually completely incapable

00:02:27.100 --> 00:02:30.630
of growing a goatee or any
suitably sinister facial hair.

00:02:30.630 --> 00:02:32.710
I can't even grow a mustache
that I could

00:02:32.710 --> 00:02:34.710
twirl the ends of.

00:02:34.710 --> 00:02:37.960
Also, every super villain seems
to have some sort of

00:02:37.960 --> 00:02:40.290
animal familiar to protect
their evil lair.

00:02:40.290 --> 00:02:43.570
And I have one, but she's not
like a vicious, mutant

00:02:43.570 --> 00:02:44.850
half-shark, half-bear.

00:02:44.850 --> 00:02:48.480
She's a half-Yorkie,
half-Pomeranian.

00:02:48.480 --> 00:02:51.480
She's not going to protect
my evil lair.

00:02:51.480 --> 00:02:54.280
But the most obvious reason I'm
not an evil overlord, is

00:02:54.280 --> 00:02:55.710
that I'm not an over anything.

00:02:55.710 --> 00:02:57.750
I have a boss.

00:02:57.750 --> 00:02:59.320
And then the realization
hit me.

00:02:59.320 --> 00:03:02.190
What if my boss or his
boss is the Overlord?

00:03:02.190 --> 00:03:04.360
And what would that
say about me?

00:03:04.360 --> 00:03:05.610
I would be a minion.

00:03:05.610 --> 00:03:08.530
And do minions know that
they're minions?

00:03:08.530 --> 00:03:11.340
Now, I don't want to be a
cog in some giant, evil

00:03:11.340 --> 00:03:14.440
enterprise, so I spent a lot of
time thinking about Dart.

00:03:14.440 --> 00:03:17.240
Of course, technology itself
has no morality.

00:03:17.240 --> 00:03:20.340
A split atom isn't good or evil,
it's just a question of

00:03:20.340 --> 00:03:23.870
whether you use it
in this or this.

00:03:23.870 --> 00:03:26.476
So the question I asked
myself was, can Dart

00:03:26.476 --> 00:03:27.270
be a force for good?

00:03:27.270 --> 00:03:29.930
Can it be something that
helps the world?

00:03:29.930 --> 00:03:31.610
I realize it looks like
I'm joking here, but

00:03:31.610 --> 00:03:33.090
I really did this.

00:03:33.090 --> 00:03:35.490
I care a lot about the integrity
of my work, and I

00:03:35.490 --> 00:03:38.400
spend a lot of my free time
hacking on open source stuff.

00:03:38.400 --> 00:03:41.010
And I do that, in large part,
because I love the feeling

00:03:41.010 --> 00:03:43.380
that I'm making the world
a better place.

00:03:43.380 --> 00:03:45.490
So that's kind of what
this talk is about.

00:03:45.490 --> 00:03:49.110
After my soul searching, this
is the stuff that I found in

00:03:49.110 --> 00:03:51.430
Dart that makes me think
that it isn't evil.

00:03:51.430 --> 00:03:55.690
This is my story about how I
think Dart could help make the

00:03:55.690 --> 00:03:59.210
open web better, and why
regular, non-evil web

00:03:59.210 --> 00:04:02.960
developers might want to
consider using it.

00:04:02.960 --> 00:04:07.060
But before I talk about Dart,
let's talk about the web.

00:04:07.060 --> 00:04:09.930
For a long time, web developers
got a free pass

00:04:09.930 --> 00:04:11.620
when it came to interactivity.

00:04:11.620 --> 00:04:15.253
The web was designed for this,
physics papers and pages that

00:04:15.253 --> 00:04:16.570
link to physics papers.

00:04:16.570 --> 00:04:18.420
And that's pretty much it.

00:04:18.420 --> 00:04:19.890
So when web developers
managed to get

00:04:19.890 --> 00:04:21.220
stuff like this working--

00:04:21.220 --> 00:04:23.950
this is Hotmail, circa 1997--

00:04:23.950 --> 00:04:25.290
users were already impressed.

00:04:25.290 --> 00:04:27.680
I mean, sure, you had to refresh
the whole page every

00:04:27.680 --> 00:04:29.690
time you wanted to delete
a single email.

00:04:29.690 --> 00:04:33.180
But you could check your email
from anywhere, right?

00:04:33.180 --> 00:04:35.240
Well, unfortunately, bad news.

00:04:35.240 --> 00:04:36.890
Mobile devices are here.

00:04:36.890 --> 00:04:39.730
So web apps used to be awesome
simply because you could get

00:04:39.730 --> 00:04:41.350
to your data wherever
you were.

00:04:41.350 --> 00:04:43.980
And users were willing to give
up all sorts of user

00:04:43.980 --> 00:04:46.090
experience niceties
to get that.

00:04:46.090 --> 00:04:49.410
But omnipresence is no longer
a web exclusive.

00:04:49.410 --> 00:04:50.940
Mobile apps are everywhere,
too.

00:04:50.940 --> 00:04:52.520
And they connect to the cloud.

00:04:52.520 --> 00:04:54.850
So anyone who has a smartphone
can check their email

00:04:54.850 --> 00:04:57.910
anywhere, and they can do it
in some native app that has

00:04:57.910 --> 00:05:00.980
smooth animation and
acceleration, multi-touch,

00:05:00.980 --> 00:05:03.900
offline support, and cute little
sounds, and stuff.

00:05:03.900 --> 00:05:06.870
And they never ever have
to refresh the page.

00:05:06.870 --> 00:05:09.260
And that means users'
expectations have risen.

00:05:09.260 --> 00:05:12.340
So great web apps these days
have to be great apps, and not

00:05:12.340 --> 00:05:13.700
just great web apps.

00:05:13.700 --> 00:05:15.830
We don't get to play the
web card anymore.

00:05:15.830 --> 00:05:17.840
And that means no
page refreshes.

00:05:17.840 --> 00:05:18.670
That means offline.

00:05:18.670 --> 00:05:21.180
That means animation
and acceleration.

00:05:21.180 --> 00:05:23.560
And all of that means more code
that's running on the

00:05:23.560 --> 00:05:26.460
browser, a lot more.

00:05:26.460 --> 00:05:29.505
Now, it wasn't that long ago
that 100 lines of JavaScript

00:05:29.505 --> 00:05:30.860
was lot of code.

00:05:30.860 --> 00:05:34.000
And a few years ago, the idea of
having the MVC side of your

00:05:34.000 --> 00:05:37.170
app all running in the browser,
would have been

00:05:37.170 --> 00:05:39.790
somewhere between crazy
and revolutionary.

00:05:39.790 --> 00:05:43.300
But now, if you look, it seems
like there's a new JavaScript

00:05:43.300 --> 00:05:48.510
MVC package coming out
every single day.

00:05:48.510 --> 00:05:49.910
Now, I like JavaScript.

00:05:49.910 --> 00:05:53.610
But what I've found is that the
bigger my apps get, the

00:05:53.610 --> 00:05:55.830
less I feel like JavaScript
is a good fit.

00:05:55.830 --> 00:05:57.800
It scales surprisingly well.

00:05:57.800 --> 00:06:00.470
But what that means is that a
language that was designed for

00:06:00.470 --> 00:06:03.550
about a dozen lines of code
works pretty well up to, say,

00:06:03.550 --> 00:06:04.950
a few thousand.

00:06:04.950 --> 00:06:08.640
But for comparison, EmberJS is
20,000 lines of code right

00:06:08.640 --> 00:06:10.690
now, and that's just
the framework.

00:06:10.690 --> 00:06:13.000
And at that scale, I struggle
with a language.

00:06:13.000 --> 00:06:14.590
It doesn't mean there's
anything wrong with

00:06:14.590 --> 00:06:15.190
JavaScript.

00:06:15.190 --> 00:06:17.530
It just means that Brendan
Eich probably didn't have

00:06:17.530 --> 00:06:20.260
anything like Google Maps in
mind when he was designing it.

00:06:20.260 --> 00:06:23.400
And we're starting to write, not
just a lot of client-side

00:06:23.400 --> 00:06:26.270
code now, but really diverse
client-side code.

00:06:26.270 --> 00:06:29.660
The web has reached a level of
maturity where no one language

00:06:29.660 --> 00:06:31.070
can meet everyone's needs.

00:06:31.070 --> 00:06:33.460
And we been that on the server
side forever, but now the

00:06:33.460 --> 00:06:35.690
browser is like that to.

00:06:35.690 --> 00:06:38.030
The question is, how do you
bring new languages to the

00:06:38.030 --> 00:06:39.980
browser in a way that doesn't
break the web?

00:06:39.980 --> 00:06:42.746
How do you make a new language
without being evil?

00:06:42.746 --> 00:06:45.900
And the answer is the same
answer that CoffeeScript, and

00:06:45.900 --> 00:06:47.520
ClosureScript, and
others have.

00:06:47.520 --> 00:06:48.770
You compile the JavaScript.

00:06:51.260 --> 00:06:53.900
So there's a couple different
ways to run Dart code.

00:06:53.900 --> 00:06:56.260
We have a native virtual machine
that executes Dart

00:06:56.260 --> 00:06:58.730
code directly, sort of like
you would Python or Ruby.

00:06:58.730 --> 00:07:01.480
And you can use that for
server-side coding.

00:07:01.480 --> 00:07:03.860
And we hope to eventually put
it in Chrome and any other

00:07:03.860 --> 00:07:06.260
browser that wants it.

00:07:06.260 --> 00:07:09.130
We've also got something we
call Dartium, which is a

00:07:09.130 --> 00:07:11.720
custom-built of Chromium, the
open-source version of Chrome,

00:07:11.720 --> 00:07:13.950
with that native Dart
VM embedded in it.

00:07:13.950 --> 00:07:16.170
And it's really handy during
development, because it means

00:07:16.170 --> 00:07:18.510
you can iterate on your Dart
code without a compile step.

00:07:18.510 --> 00:07:21.500
You just refresh the page like
you would with JavaScript.

00:07:21.500 --> 00:07:24.490
And it means you can use the
Chrome Debugger, and debug,

00:07:24.490 --> 00:07:27.610
and step through the original
Dart code and not unreadable,

00:07:27.610 --> 00:07:29.880
generated code.

00:07:29.880 --> 00:07:32.890
But completely separate from
those, but just as important,

00:07:32.890 --> 00:07:35.180
we have something called
Dart to JS.

00:07:35.180 --> 00:07:38.000
This is an offline compiler that
takes in an entire Dart

00:07:38.000 --> 00:07:40.830
program and compiles the whole
thing to JavaScript.

00:07:40.830 --> 00:07:43.735
So with Dart to JS, you write
all your code in Dart, and

00:07:43.735 --> 00:07:44.890
then compile it to JavaScript.

00:07:44.890 --> 00:07:46.240
And then you just deploy
that like you

00:07:46.240 --> 00:07:47.970
would a normal JS app.

00:07:47.970 --> 00:07:50.690
As long as your user's browser
can run relatively modern

00:07:50.690 --> 00:07:52.360
JavaScript, they can
run your app.

00:07:52.360 --> 00:07:54.670
They don't care or even know
that it was originally

00:07:54.670 --> 00:07:56.970
developed in Dart.

00:07:56.970 --> 00:08:00.290
What this means is that, yeah,
Dart works in Chrome, but

00:08:00.290 --> 00:08:03.910
right now, today, it also works
equally well in Firefox,

00:08:03.910 --> 00:08:05.760
Safari, and Internet Explorer.

00:08:05.760 --> 00:08:08.980
You could run Dart on your iPad
or your Android phone.

00:08:08.980 --> 00:08:11.390
Opera will be up here at some
point, but we've got

00:08:11.390 --> 00:08:12.900
some bugs to fix.

00:08:12.900 --> 00:08:15.700
So the goal here is that any
browser that supports modern,

00:08:15.700 --> 00:08:20.610
standards compliant JavaScript
will support Dart too.

00:08:20.610 --> 00:08:22.990
There's one last technical bit
that I should mention before I

00:08:22.990 --> 00:08:24.860
start talking about the
language itself.

00:08:24.860 --> 00:08:27.200
The Dart Project is fully
open-sourced.

00:08:27.200 --> 00:08:30.870
It's ESD licensed, if you care
about particular licenses.

00:08:30.870 --> 00:08:33.000
We work live in the
public repository.

00:08:33.000 --> 00:08:35.270
Our bug trackers are public, our
mailing lists are public,

00:08:35.270 --> 00:08:36.230
pretty much everything.

00:08:36.230 --> 00:08:39.570
If you watch how we work it,
we're kind of closer to being

00:08:39.570 --> 00:08:41.780
outside of Google than
inside of it.

00:08:41.780 --> 00:08:45.740
Dart was designed by the same
people who created V8, which

00:08:45.740 --> 00:08:47.640
is the JavaScript engine
in Chrome.

00:08:47.640 --> 00:08:51.370
And the fact that V8 is open
source is what led Ryan Dahl

00:08:51.370 --> 00:08:52.930
to build Node.js using it.

00:08:52.930 --> 00:08:54.800
So open source is pretty
deeply ingrained

00:08:54.800 --> 00:08:58.120
in the team's culture.

00:08:58.120 --> 00:08:59.130
OK, now the fun stuff.

00:08:59.130 --> 00:09:01.540
Now I can start talking
about the language.

00:09:01.540 --> 00:09:05.250
I'm going to do a pretty quick
overview, since I don't really

00:09:05.250 --> 00:09:07.210
know who's going to be watching
this or what the

00:09:07.210 --> 00:09:08.050
audience is.

00:09:08.050 --> 00:09:10.770
It's hard to go into details,
because stuff that would be

00:09:10.770 --> 00:09:12.800
interesting to some people is
going to be really boring to

00:09:12.800 --> 00:09:14.320
other people.

00:09:14.320 --> 00:09:16.330
And the other reason I'll go
pretty quickly at first is

00:09:16.330 --> 00:09:20.190
because Dart tries really hard
to be familiar to anyone

00:09:20.190 --> 00:09:24.930
coming from a Java or JavaScript
background.

00:09:24.930 --> 00:09:26.980
So here's a simple
Dart program.

00:09:26.980 --> 00:09:30.280
It looks kind of like C and
JavaScript had a baby.

00:09:30.280 --> 00:09:33.070
Dart inherits the same
expressions and statements

00:09:33.070 --> 00:09:37.110
that you know from C, C++
Java, C#, or JavaScript.

00:09:37.110 --> 00:09:40.035
You have your familiar
arithmetic operators.

00:09:40.035 --> 00:09:43.320
You've got if then else, while
loops, for loops, all that

00:09:43.320 --> 00:09:47.370
kind of basic stuff that
you take for granted.

00:09:47.370 --> 00:09:51.850
declarations like main () look
like they do in C. And main ()

00:09:51.850 --> 00:09:54.430
is the entry point
of your app.

00:09:54.430 --> 00:09:57.070
But local variables are declared
using var, kind of

00:09:57.070 --> 00:09:58.450
JavaScript.

00:09:58.450 --> 00:10:01.220
And also, we've got nice
list literals.

00:10:01.220 --> 00:10:04.170
We have map literals too, which
means that JSON is also

00:10:04.170 --> 00:10:06.660
valid Dart syntax.

00:10:06.660 --> 00:10:09.790
There's a couple of other
niceties going on here too.

00:10:09.790 --> 00:10:12.710
We have a nice for in loop that
will let you walk over

00:10:12.710 --> 00:10:15.770
any iterable collection.

00:10:15.770 --> 00:10:18.640
Here you can see we have
string interpolation.

00:10:18.640 --> 00:10:21.620
The little dollar sign curly
block encloses an expression.

00:10:21.620 --> 00:10:24.380
And Dart will evaluate that
and insert the result in a

00:10:24.380 --> 00:10:25.890
string for you.

00:10:25.890 --> 00:10:28.060
If you like a more functional
style, this

00:10:28.060 --> 00:10:29.920
example could be this.

00:10:29.920 --> 00:10:32.840
Dart, of course, has closures
and nested functions like most

00:10:32.840 --> 00:10:34.940
newer languages do.

00:10:34.940 --> 00:10:37.500
Also, our built-in collection
classes have most of the

00:10:37.500 --> 00:10:39.830
functional methods you would
expect like for each, and map,

00:10:39.830 --> 00:10:42.560
and filter.

00:10:42.560 --> 00:10:45.210
The little arrow here is our
syntax for lambdas, which is

00:10:45.210 --> 00:10:48.100
just an anonymous function whose
body just returns the

00:10:48.100 --> 00:10:50.490
result of a single expression.

00:10:50.490 --> 00:10:53.370
In fact, you can use that arrow
syntax even for named

00:10:53.370 --> 00:10:55.500
functions like main (), if
its body is just a single

00:10:55.500 --> 00:10:56.400
expression.

00:10:56.400 --> 00:10:58.520
So if you really want to go
down the functional rabbit

00:10:58.520 --> 00:11:01.830
hole, this example could
look like this.

00:11:01.830 --> 00:11:05.330
So, basically, Dart is like
your kind of vanilla curly

00:11:05.330 --> 00:11:07.600
brace and semicolon imperative
language.

00:11:07.600 --> 00:11:09.520
And then we poured a functional

00:11:09.520 --> 00:11:13.150
chocolate sauce on top.

00:11:13.150 --> 00:11:15.790
For people like me that care
about this kind of stuff, Dart

00:11:15.790 --> 00:11:17.750
has solid lexical scoping.

00:11:17.750 --> 00:11:20.340
Variables are blocked scoped,
not function scoped.

00:11:20.340 --> 00:11:22.760
There's no weird hoisting
shenanigans.

00:11:22.760 --> 00:11:25.040
Also, closures and loops
do the right thing.

00:11:25.040 --> 00:11:27.140
If you close over a loop
variable, you'll get a fresh

00:11:27.140 --> 00:11:29.770
one each iteration.

00:11:29.770 --> 00:11:31.990
But that's kind of microscale
stuff though.

00:11:31.990 --> 00:11:36.660
So let's go a bit bigger and
let's talk about classes.

00:11:36.660 --> 00:11:40.480
So when programs get big, one
way we knock them down to size

00:11:40.480 --> 00:11:42.330
is by breaking them down
into data types.

00:11:42.330 --> 00:11:45.610
You encapsulate your code
in kinds of things.

00:11:45.610 --> 00:11:49.130
And doing this was a design
pattern in languages like C.

00:11:49.130 --> 00:11:52.210
And then became part of the
language in Simula, Smalltalk,

00:11:52.210 --> 00:11:55.740
and then Java, Self, JavaScript,
you name it.

00:11:55.740 --> 00:11:58.610
So most of these languages
defined kinds of

00:11:58.610 --> 00:12:00.430
objects using classes.

00:12:00.430 --> 00:12:03.090
JavaScript is a bit unusual, in
that inherited a different

00:12:03.090 --> 00:12:06.510
model prototypes from a
language called Self.

00:12:06.510 --> 00:12:08.160
Now, prototypes are very cool.

00:12:08.160 --> 00:12:10.210
And they're very flexible, but
they're flexible in the way

00:12:10.210 --> 00:12:12.000
that assembly language
is flexible.

00:12:12.000 --> 00:12:14.530
They let you do anything, but
they kind of force you to do

00:12:14.530 --> 00:12:15.800
everything yourself.

00:12:15.800 --> 00:12:18.630
So, for example, let's say you
want to define a kind of

00:12:18.630 --> 00:12:21.400
monster object in JavaScript.

00:12:21.400 --> 00:12:23.790
Here's kind of the vanilla
way of doing it.

00:12:23.790 --> 00:12:26.160
If you aren't fairly experienced
in JavaScript,

00:12:26.160 --> 00:12:30.500
this is probably pretty opaque,
so I'll annotate it.

00:12:30.500 --> 00:12:32.910
And this code has a couple
of problems with it.

00:12:32.910 --> 00:12:35.850
First, it's really verbose
and repetitive.

00:12:35.850 --> 00:12:38.830
We're mentioning monster
six times.

00:12:38.830 --> 00:12:40.370
Game object shows
up three times.

00:12:40.370 --> 00:12:43.680
That's the thing that we're
inheriting from.

00:12:43.680 --> 00:12:45.020
Then there's all this prototype

00:12:45.020 --> 00:12:47.020
machinery directly exposed.

00:12:47.020 --> 00:12:49.930
So the intent to this code
is to define a kind of

00:12:49.930 --> 00:12:50.990
entity in our game.

00:12:50.990 --> 00:12:53.750
But what the code actually does
is just muck around with

00:12:53.750 --> 00:12:55.420
JavaScript's dispatch
mechanics.

00:12:55.420 --> 00:12:58.490
Now, there is a pattern here,
and if you know the pattern,

00:12:58.490 --> 00:13:00.990
you can kind of squint through
it and see what's going on.

00:13:00.990 --> 00:13:04.740
But if you don't, this is just
like semantic mystery meat.

00:13:04.740 --> 00:13:08.020
The last issue, and possibly the
biggest, is that this is

00:13:08.020 --> 00:13:09.350
all imperative code.

00:13:09.350 --> 00:13:11.130
We aren't declaring
a type here.

00:13:11.130 --> 00:13:13.330
We're molding it out
of unformed clay

00:13:13.330 --> 00:13:14.940
one mutation a time.

00:13:14.940 --> 00:13:18.820
And doing that's ugly, but
worse, it's opaque to tools.

00:13:18.820 --> 00:13:22.046
So here's how you define
the same class in Dart.

00:13:22.046 --> 00:13:24.200
Now, the obvious difference
is that this is a

00:13:24.200 --> 00:13:25.780
lot shorter and simpler.

00:13:25.780 --> 00:13:29.200
We now have a built-in syntax
to say I am creating a type.

00:13:29.200 --> 00:13:31.886
So Dart lets you directly
express your intent in the

00:13:31.886 --> 00:13:35.090
code, instead of requiring
you to know some pattern.

00:13:35.090 --> 00:13:38.060
But once we have a class syntax
in the grammar, we can

00:13:38.060 --> 00:13:40.830
hang some other nice
features off it.

00:13:40.830 --> 00:13:42.990
So because the compiler knows
that we're inside a class

00:13:42.990 --> 00:13:45.950
definition, it can let us use
super to call a super class

00:13:45.950 --> 00:13:48.320
constructor method, so we don't
have to keep saying game

00:13:48.320 --> 00:13:51.710
object over and over again.

00:13:51.710 --> 00:13:54.600
We've got this nice little
syntactic sugar here to

00:13:54.600 --> 00:13:59.420
directly initialize a field from
a constructor argument.

00:13:59.420 --> 00:14:02.320
Over in the JavaScript code,
every field access was

00:14:02.320 --> 00:14:03.650
preceded by this dot.

00:14:03.650 --> 00:14:06.970
It's always this dot name
and not just name.

00:14:06.970 --> 00:14:08.790
In the Dart code, that's gone.

00:14:08.790 --> 00:14:11.540
Since we have solid lexical
scope, and we can

00:14:11.540 --> 00:14:13.720
syntactically tell that we're
in a class and what fields

00:14:13.720 --> 00:14:17.080
that class has, the compiler can
figure out that a variable

00:14:17.080 --> 00:14:19.845
like name or attack refers to a
field, the same way you can

00:14:19.845 --> 00:14:22.460
in Java or C++.

00:14:22.460 --> 00:14:25.730
OK, I'll go over one more
really nasty JavaScript

00:14:25.730 --> 00:14:28.320
pitfall that having a class
syntax lets us fix.

00:14:28.320 --> 00:14:30.185
But it's a bit tricky
to explain, so I'll

00:14:30.185 --> 00:14:32.850
need another example.

00:14:32.850 --> 00:14:35.860
OK, here's some JavaScript
code.

00:14:35.860 --> 00:14:38.340
We're creating a
monster object.

00:14:38.340 --> 00:14:41.950
And it has this method,
makeYell function.

00:14:41.950 --> 00:14:44.550
And that method returns
a function.

00:14:44.550 --> 00:14:47.420
And when you call the function
that it returns, it prints the

00:14:47.420 --> 00:14:49.580
monster's name.

00:14:49.580 --> 00:14:52.630
The important bit here is that
this function is a closure.

00:14:52.630 --> 00:14:55.710
It's accessing something
declared in an outer scope.

00:14:55.710 --> 00:14:58.920
In particular, it accesses
this, which should be the

00:14:58.920 --> 00:15:01.750
monster object that
the method is on.

00:15:01.750 --> 00:15:03.380
So then down here, we call that

00:15:03.380 --> 00:15:04.810
method to get the function.

00:15:04.810 --> 00:15:07.720
And then finally, we
call the function.

00:15:07.720 --> 00:15:10.370
So the question is, what
does this print?

00:15:10.370 --> 00:15:15.110
So if you run this in node, it
prints this In a browser,

00:15:15.110 --> 00:15:18.140
it'll do something different.

00:15:18.140 --> 00:15:21.220
So if you got the right answer
here, congratulations.

00:15:21.220 --> 00:15:23.670
That means you've gone through
the right of passage of being

00:15:23.670 --> 00:15:29.130
burned by this, and you're a
real JavaScript programmer.

00:15:29.130 --> 00:15:32.420
The problem here is that in
JavaScript, the special this

00:15:32.420 --> 00:15:35.610
variable is dynamically bound,
not lexically bound.

00:15:35.610 --> 00:15:38.680
When you call a method in
JavaScript, this is always

00:15:38.680 --> 00:15:41.740
just like whatever object was
to the left of the dot when

00:15:41.740 --> 00:15:42.500
you called it.

00:15:42.500 --> 00:15:47.040
So if you do your mom dot is so
fat, then inside is so fat,

00:15:47.040 --> 00:15:50.930
this will be bound
to your mom.

00:15:50.930 --> 00:15:54.170
So when we call yell here,
there's no receiver at all.

00:15:54.170 --> 00:15:56.150
It's not something dot yell.

00:15:56.150 --> 00:15:59.180
So this defaults to the
global object instead.

00:15:59.180 --> 00:16:01.630
And that's window
in the browser.

00:16:01.630 --> 00:16:04.190
And if window were to happen to
have a name property, then

00:16:04.190 --> 00:16:07.380
this would print whatever
that was.

00:16:07.380 --> 00:16:10.780
The fix, in case you're curious,
is usually something

00:16:10.780 --> 00:16:12.050
along these lines.

00:16:12.050 --> 00:16:16.900
You get this and you capture it
in a variable that or self.

00:16:16.900 --> 00:16:19.840
And then your closure refers
to that variable instead.

00:16:19.840 --> 00:16:23.000
Since variables are lexically
scoped, this retains the right

00:16:23.000 --> 00:16:24.696
object, the monster.

00:16:24.696 --> 00:16:27.130
Now ultimately, this boils
down to the fact that

00:16:27.130 --> 00:16:31.290
JavaScript doesn't distinguish
between functions and methods.

00:16:31.290 --> 00:16:33.580
But if we translate this to
Dart though, we don't have

00:16:33.580 --> 00:16:34.470
that problem.

00:16:34.470 --> 00:16:37.150
Since we have a dedicated syntax
for classes, we also

00:16:37.150 --> 00:16:40.340
have the distinction between
methods, like this one, and

00:16:40.340 --> 00:16:42.100
functions, like this one.

00:16:42.100 --> 00:16:44.750
So this is dynamically bound in
methods, which is what you

00:16:44.750 --> 00:16:47.610
need for overwriting to work,
but it's lexically bound for

00:16:47.610 --> 00:16:49.600
functions, which is what
you want for closures.

00:16:49.600 --> 00:16:51.910
So that means that, in Dart,
this program does the right

00:16:51.910 --> 00:16:54.580
thing and prints the
monster's name.

00:16:54.580 --> 00:16:59.090
So having a class syntax lets us
do some kind of nice stuff.

00:16:59.090 --> 00:17:01.150
But this is all kind of
small potatoes, right?

00:17:01.150 --> 00:17:06.310
The big potato with this is
that now our tools can be

00:17:06.310 --> 00:17:08.119
aware of the data types
in our program.

00:17:08.119 --> 00:17:11.030
So with a declarative syntax,
you can see what types of

00:17:11.030 --> 00:17:13.200
program defines, just
by parsing.

00:17:13.200 --> 00:17:14.900
You don't have to execute
any code.

00:17:14.900 --> 00:17:17.319
And this is something that
we take for granted in

00:17:17.319 --> 00:17:19.960
statically-typed languages like
Java, but this is like

00:17:19.960 --> 00:17:23.250
rocket science in a language
like JavaScript.

00:17:23.250 --> 00:17:25.730
So I will ask you to remember
the bit about class syntax

00:17:25.730 --> 00:17:27.690
being tool-friendly, because
I'm going to

00:17:27.690 --> 00:17:30.310
get back to it later.

00:17:30.310 --> 00:17:33.700
Now, I understand that classes
are a turn-off for a lot of

00:17:33.700 --> 00:17:35.450
JavaScripters, because
Java left a bad

00:17:35.450 --> 00:17:36.310
taste in their mouth.

00:17:36.310 --> 00:17:38.560
In Java, everything has
to be in a class.

00:17:38.560 --> 00:17:41.030
And you get this kind of kingdom
of nouns phenomenon,

00:17:41.030 --> 00:17:43.530
where even a simple function
or variable has to be

00:17:43.530 --> 00:17:46.940
ensconced in some boilerplate
class definition.

00:17:46.940 --> 00:17:48.930
So Dart doesn't roll that way.

00:17:48.930 --> 00:17:51.450
Up until now, the examples
I've showed you were just

00:17:51.450 --> 00:17:52.760
simple top-level functions.

00:17:52.760 --> 00:17:55.390
And you could define entire
programs just using those.

00:17:55.390 --> 00:17:58.060
The way I look at it is, Dart
has classes, but it doesn't

00:17:58.060 --> 00:17:59.525
have mandatory enrollment.

00:18:02.600 --> 00:18:02.950
OK.

00:18:02.950 --> 00:18:05.810
I want to talk about just a
few more corners of the

00:18:05.810 --> 00:18:09.330
language that I think are united
by a common theme.

00:18:09.330 --> 00:18:12.400
So I talk about Dart being
designed for bigger programs.

00:18:12.400 --> 00:18:14.110
But apps don't start
big, right?

00:18:14.110 --> 00:18:15.910
They start small and
then they grow.

00:18:15.910 --> 00:18:19.370
And Dart has a few features that
I think are really cool,

00:18:19.370 --> 00:18:21.260
because they help there, because
they keep you from

00:18:21.260 --> 00:18:23.360
needing to do what I call
future-proofing.

00:18:23.360 --> 00:18:25.900
So let me explain here.

00:18:25.900 --> 00:18:29.160
Here's some Java code.

00:18:29.160 --> 00:18:32.610
So, we have these get name
and get attacks methods.

00:18:32.610 --> 00:18:34.840
And all they do is
return the field.

00:18:34.840 --> 00:18:37.510
So why not just get rid of those
and make those fields

00:18:37.510 --> 00:18:39.440
public instead?

00:18:39.440 --> 00:18:42.330
Well, the answer, of course,
is that sure, they just

00:18:42.330 --> 00:18:43.670
return field now.

00:18:43.670 --> 00:18:46.490
But who knows, maybe a year down
the road we'll need to do

00:18:46.490 --> 00:18:47.860
some calculation to determine a

00:18:47.860 --> 00:18:49.680
monster's name or its attacks.

00:18:49.680 --> 00:18:52.230
And when that happens, we'd have
to get every place in our

00:18:52.230 --> 00:18:54.870
program where we're accessing
those fields, and replace it

00:18:54.870 --> 00:18:56.580
with a call to our new method.

00:18:56.580 --> 00:18:59.380
And if this changes in a library
that's been released

00:18:59.380 --> 00:19:03.110
into the wild, that's a
breaking API change.

00:19:03.110 --> 00:19:05.630
The reason it's a breaking
change is that accessing a

00:19:05.630 --> 00:19:07.440
field and calling a getter
method in Java

00:19:07.440 --> 00:19:08.800
have different syntax.

00:19:08.800 --> 00:19:11.910
You can't transparently go
from a field to a method

00:19:11.910 --> 00:19:14.430
without having to touch every
single call site.

00:19:14.430 --> 00:19:17.120
And since you might need to do
that at some point, everyone

00:19:17.120 --> 00:19:20.480
in Java just preemptively wraps
every single field in a

00:19:20.480 --> 00:19:22.130
getter, just in case.

00:19:22.130 --> 00:19:23.920
And that's what I mean
by future-proofing.

00:19:23.920 --> 00:19:26.550
It's code that you write today,
just in case you end up

00:19:26.550 --> 00:19:28.475
needing the flexibility
in the future.

00:19:28.475 --> 00:19:30.210
And to me, that sucks, right?

00:19:30.210 --> 00:19:33.350
You're basically burning time
writing code that has no value

00:19:33.350 --> 00:19:34.620
for you today.

00:19:34.620 --> 00:19:37.140
One of the things I like about
Dart is that you rarely have

00:19:37.140 --> 00:19:37.950
to do that.

00:19:37.950 --> 00:19:41.570
In Dart, that example
can just be this.

00:19:41.570 --> 00:19:44.150
Name and attacks are
just fields.

00:19:44.150 --> 00:19:46.240
So let's say we decide to not
to store the name and

00:19:46.240 --> 00:19:48.330
calculate it instead.

00:19:48.330 --> 00:19:52.230
In Dart, you could just change
that to a getter method.

00:19:52.230 --> 00:19:54.970
And the important bit is that
the syntax for calling that

00:19:54.970 --> 00:19:59.680
getter is 100% identical
to accessing a field.

00:19:59.680 --> 00:20:02.240
So in this example, name
just has a getter.

00:20:02.240 --> 00:20:03.600
So it's an immutable property.

00:20:03.600 --> 00:20:05.810
You can read it, but you
can't modify it.

00:20:05.810 --> 00:20:09.480
To make it mutable, you can also
define setter methods.

00:20:09.480 --> 00:20:11.600
So here we've got a
setter method too.

00:20:11.600 --> 00:20:14.120
So now you can assign to the
name property, and it invokes

00:20:14.120 --> 00:20:16.490
that method with the
assigned value.

00:20:16.490 --> 00:20:19.800
And again, the syntax between
setting a field and calling a

00:20:19.800 --> 00:20:24.680
user-defined setter method is
identical at the call site.

00:20:24.680 --> 00:20:25.940
OK, there's one other bit
of future-proofing

00:20:25.940 --> 00:20:28.850
in this Java example.

00:20:28.850 --> 00:20:32.140
So we're taking a list for
attacks instead of a built-in

00:20:32.140 --> 00:20:33.570
Java array.

00:20:33.570 --> 00:20:35.310
Why?

00:20:35.310 --> 00:20:37.510
There's actually a couple
of subtle reasons.

00:20:37.510 --> 00:20:40.300
But one of the big ones is that,
again, it's because the

00:20:40.300 --> 00:20:42.610
syntax for using them
is different.

00:20:42.610 --> 00:20:45.675
So if you go from one to the
other, it breaks all the code

00:20:45.675 --> 00:20:46.370
that's using it.

00:20:46.370 --> 00:20:47.790
And again, Dart has
you covered here.

00:20:47.790 --> 00:20:50.690
Dart lets you define your own
subscript operators, the

00:20:50.690 --> 00:20:52.120
square bracket thing.

00:20:52.120 --> 00:20:54.840
So you can go from a built-in
list to some user-defined

00:20:54.840 --> 00:20:57.090
collection and support the
exact same API that

00:20:57.090 --> 00:21:00.540
the native list uses.

00:21:00.540 --> 00:21:00.790
OK.

00:21:00.790 --> 00:21:04.100
I won't go into the details
here, but this is a table of a

00:21:04.100 --> 00:21:05.700
bunch of language features.

00:21:05.700 --> 00:21:10.020
So you start off just using the
stuff on the left, which

00:21:10.020 --> 00:21:11.600
all have built-in behavior.

00:21:11.600 --> 00:21:14.030
And then later, if you find
you need to insert some

00:21:14.030 --> 00:21:17.230
abstraction in there, the
features on the right let you

00:21:17.230 --> 00:21:19.810
seamlessly roll that stuff in,
using your user-defined

00:21:19.810 --> 00:21:22.500
behavior without breaking
any existing code.

00:21:22.500 --> 00:21:24.740
So the idea is that when you
start writing your app, you

00:21:24.740 --> 00:21:27.230
just write simple code that
does what you need today.

00:21:27.230 --> 00:21:29.780
And then when it grows, the
language should be ready to

00:21:29.780 --> 00:21:31.030
grow with you.

00:21:32.990 --> 00:21:36.420
Now I'm here blathering about
language features.

00:21:36.420 --> 00:21:38.990
But one of the things that
people keep asking me is, why

00:21:38.990 --> 00:21:40.580
are you making a language
at all when the

00:21:40.580 --> 00:21:42.530
platform is the problem?

00:21:42.530 --> 00:21:44.400
And I think a lot of us
agree that the whole

00:21:44.400 --> 00:21:46.290
web stack needs work.

00:21:46.290 --> 00:21:48.830
And one of the things that's
cool about being at Google, is

00:21:48.830 --> 00:21:50.670
that Google has people working
on pretty much every

00:21:50.670 --> 00:21:51.220
corner of the web.

00:21:51.220 --> 00:21:56.280
We have people doing HTML,
JavaScript, CSS, the DOM, new

00:21:56.280 --> 00:21:58.800
HTML5 APIs.

00:21:58.800 --> 00:22:02.350
But, in particular, let's
talk about the DOM.

00:22:02.350 --> 00:22:06.350
So here's my understanding of
the genesis of the DOM API.

00:22:06.350 --> 00:22:08.650
You've got a bunch of people,
the browser vendors, who

00:22:08.650 --> 00:22:11.290
actively dislike each other,
and you've jammed them in a

00:22:11.290 --> 00:22:12.480
room together.

00:22:12.480 --> 00:22:15.470
And you told them they couldn't
leave until they all

00:22:15.470 --> 00:22:17.080
agree on a single API.

00:22:17.080 --> 00:22:21.020
And then you say, see how much
XML you can involve, the more

00:22:21.020 --> 00:22:22.240
the better.

00:22:22.240 --> 00:22:24.580
Oh, and also, don't
forget to make it

00:22:24.580 --> 00:22:25.950
programming-language agnostic.

00:22:25.950 --> 00:22:28.850
So any really cool language
feature that you like a lot,

00:22:28.850 --> 00:22:29.900
yeah, you can't use that.

00:22:29.900 --> 00:22:32.790
You can only use lowest common
denominator stuff that every

00:22:32.790 --> 00:22:35.560
possible language supports.

00:22:35.560 --> 00:22:39.440
So given that, the DOM API
didn't come out too bad.

00:22:39.440 --> 00:22:42.760
But that's still a pretty awful
set of preconditions to

00:22:42.760 --> 00:22:44.210
start from.

00:22:44.210 --> 00:22:47.190
So Dart is a web language, so
of course it has full access

00:22:47.190 --> 00:22:48.020
to the DOM API.

00:22:48.020 --> 00:22:50.280
Dart isn't like Java applets or
Flash or something where it

00:22:50.280 --> 00:22:52.800
just runs in a special little
rectangle in your page.

00:22:52.800 --> 00:22:54.990
It's fully integrated
with the browser.

00:22:54.990 --> 00:22:57.950
But since we are making a new
language, and we have this

00:22:57.950 --> 00:23:01.180
Dart to JavaScript compiler for
it, we have a fantastic

00:23:01.180 --> 00:23:01.750
opportunity.

00:23:01.750 --> 00:23:03.680
We can also clean up the DOM.

00:23:03.680 --> 00:23:06.560
So we've got a compiler that's
taking Dart code and spitting

00:23:06.560 --> 00:23:07.500
out JavaScript.

00:23:07.500 --> 00:23:10.530
And we can use that same
machinery to take calls to a

00:23:10.530 --> 00:23:13.460
new, better DOM API, and then
turn them into calls to the

00:23:13.460 --> 00:23:15.250
old school JavaScript DOM.

00:23:15.250 --> 00:23:19.540
And that means we can ditch two
decades of old patterns

00:23:19.540 --> 00:23:21.130
and historical cruft.

00:23:21.130 --> 00:23:25.150
And we can stop pretending that
HTML was a flavor of XML.

00:23:25.150 --> 00:23:28.170
And we can make an API that only
tries to be great for one

00:23:28.170 --> 00:23:30.650
language and that fully uses all
of the features that are

00:23:30.650 --> 00:23:33.060
particular to that language.

00:23:33.060 --> 00:23:33.980
So that's what we're doing.

00:23:33.980 --> 00:23:36.290
We've still got lots of work
to do, but I can show you a

00:23:36.290 --> 00:23:38.650
couple of examples.

00:23:38.650 --> 00:23:40.350
So let's talk about querying.

00:23:40.350 --> 00:23:42.360
You've got your happy little
tree of nodes in your

00:23:42.360 --> 00:23:45.690
document, and you want
to find some.

00:23:45.690 --> 00:23:48.280
Here's how you can
do it in the DOM.

00:23:48.280 --> 00:23:51.140
This is like an all you
can eat buffet, right?

00:23:51.140 --> 00:23:54.420
So several years ago, John Resig
went to the mountaintop

00:23:54.420 --> 00:23:56.760
and received this divine
revelation--

00:23:56.760 --> 00:24:01.200
that thou shalt query for
elements using CSS selectors.

00:24:01.200 --> 00:24:03.350
So we took that gospel
to heart.

00:24:03.350 --> 00:24:06.330
And this is what we have
in our DOM API.

00:24:06.330 --> 00:24:08.140
If you want one element,
you call query.

00:24:08.140 --> 00:24:10.800
And if you want them all,
you call query all.

00:24:10.800 --> 00:24:13.000
These are both simple
top-level functions.

00:24:13.000 --> 00:24:13.670
You just call them.

00:24:13.670 --> 00:24:15.320
There's no document
dot or anything.

00:24:18.110 --> 00:24:20.790
So query all returns a
collection of elements.

00:24:20.790 --> 00:24:22.680
What kind of collection?

00:24:22.680 --> 00:24:26.010
The original DOM API had to
be language agnostic.

00:24:26.010 --> 00:24:27.540
And that meant that it
couldn't rely on any

00:24:27.540 --> 00:24:29.250
collection types that
were built into

00:24:29.250 --> 00:24:30.630
a particular language.

00:24:30.630 --> 00:24:34.320
So instead, it had to define
its own weird DOM-specific

00:24:34.320 --> 00:24:36.010
slightly incompatible ones.

00:24:36.010 --> 00:24:37.860
So when you get a list of
elements from the DOM in

00:24:37.860 --> 00:24:40.900
JavaScript, it isn't a normal
JavaScript array, and it might

00:24:40.900 --> 00:24:43.210
not have all the methods
that you expect.

00:24:43.210 --> 00:24:46.940
But Dart's API is for Dart, so
we don't have that problem.

00:24:46.940 --> 00:24:48.960
When you get a collection
from the DOM, you get a

00:24:48.960 --> 00:24:50.980
full-featured collection that
supports everything that a

00:24:50.980 --> 00:24:53.540
built-in list supports,
because it is a list.

00:24:53.540 --> 00:24:57.080
So let's say you want to get
all of the non-empty button

00:24:57.080 --> 00:24:58.280
labels on your page.

00:24:58.280 --> 00:25:00.550
In Dart, you can just do this.

00:25:00.550 --> 00:25:03.280
Since lists support map
and filter, the DOM

00:25:03.280 --> 00:25:04.530
collections do too.

00:25:07.610 --> 00:25:11.340
For arcane reasons, the
JavaScript DOM API hates

00:25:11.340 --> 00:25:11.700
constructors.

00:25:11.700 --> 00:25:14.280
So let's say you want
to make a button.

00:25:14.280 --> 00:25:15.990
Here's how you would do it.

00:25:15.990 --> 00:25:18.302
And that's kind of nasty.

00:25:18.302 --> 00:25:21.810
Of course, in practice, you just
use jQuery or inner HTML

00:25:21.810 --> 00:25:22.420
or something.

00:25:22.420 --> 00:25:26.350
But to me, that's kind of just
routing around the problem.

00:25:26.350 --> 00:25:28.510
In Dart, you can do this.

00:25:28.510 --> 00:25:31.760
So when you're trying to learn
a new API, and you have some

00:25:31.760 --> 00:25:34.500
type that you know you want an
instance of, the natural thing

00:25:34.500 --> 00:25:36.180
to do is to try to
construct it.

00:25:36.180 --> 00:25:38.970
So, with Dart, we just
make that work.

00:25:38.970 --> 00:25:42.650
Also, notice that there's no
special append child or insert

00:25:42.650 --> 00:25:44.480
adjacent HTML method
here to add the

00:25:44.480 --> 00:25:46.050
button to the document.

00:25:46.050 --> 00:25:49.050
Instead, we're calling add,
which is just the regular

00:25:49.050 --> 00:25:49.830
method on lists.

00:25:49.830 --> 00:25:52.200
So if you know how to add items
to a list, you already

00:25:52.200 --> 00:25:55.320
know how to add elements
to the DOM.

00:25:55.320 --> 00:25:58.560
Now, I won't claim that this
is some kind of like magic

00:25:58.560 --> 00:26:00.140
pixie dust that's going
to somehow make all

00:26:00.140 --> 00:26:01.710
of your apps awesome.

00:26:01.710 --> 00:26:04.770
But I do think that small
improvements like these cut

00:26:04.770 --> 00:26:07.490
down the time you spend chasing
down stupid little

00:26:07.490 --> 00:26:08.180
bugs and typos.

00:26:08.180 --> 00:26:10.040
And for me, when I'm less

00:26:10.040 --> 00:26:11.290
frustrated, I am more creative.

00:26:14.430 --> 00:26:14.680
OK.

00:26:14.680 --> 00:26:17.110
If you've heard anything about
Dart, you're probably

00:26:17.110 --> 00:26:19.360
wondering when I'm going
to talk about types.

00:26:19.360 --> 00:26:21.700
So let's do that now.

00:26:21.700 --> 00:26:23.670
So people who like
statically-typed or

00:26:23.670 --> 00:26:27.490
dynamically-typed languages
historically have kind of a

00:26:27.490 --> 00:26:29.920
rocky relationship
with each other.

00:26:29.920 --> 00:26:32.420
People who like dynamic
languages seem to look at

00:26:32.420 --> 00:26:36.450
static languages like Java as
being kind of boring and

00:26:36.450 --> 00:26:39.860
plain, sort of just no fun,
vanilla languages.

00:26:39.860 --> 00:26:43.250
And then, meanwhile, people into
static languages think

00:26:43.250 --> 00:26:46.755
dynamically languages are too
unsafe and unreliable to use

00:26:46.755 --> 00:26:48.620
for real production code.

00:26:48.620 --> 00:26:52.070
And that the people who use
them are a little crazy or

00:26:52.070 --> 00:26:56.260
maybe a little bananas.

00:26:56.260 --> 00:26:59.710
So I don't know about you, but
when I look at those, what I

00:26:59.710 --> 00:27:02.550
find myself wanting is this.

00:27:02.550 --> 00:27:05.210
I should apologize for how
bad that metaphor is.

00:27:05.210 --> 00:27:06.830
It's pretty terrible.

00:27:06.830 --> 00:27:10.430
So anyway, our goal with Dart
is to try to get some of

00:27:10.430 --> 00:27:13.360
what's great about dynamic and
static languages, and kind of

00:27:13.360 --> 00:27:14.720
blend them together.

00:27:14.720 --> 00:27:17.550
Now in their heart of hearts,
the guys who designed Dart are

00:27:17.550 --> 00:27:19.460
much closer to the
dynamic side.

00:27:19.460 --> 00:27:21.160
So Dart is mostly a
dynamic language.

00:27:21.160 --> 00:27:24.090
They started with a purely
dynamic language, kind of in

00:27:24.090 --> 00:27:25.580
the Smalltalk vein.

00:27:25.580 --> 00:27:28.720
But then what they did is they
mixed in just a little bit of

00:27:28.720 --> 00:27:32.050
static typing to try to get some
of the benefits of that.

00:27:32.050 --> 00:27:33.630
But they wanted to do that
without giving up the

00:27:33.630 --> 00:27:35.060
flexibility and the
open-endedness

00:27:35.060 --> 00:27:37.980
of a dynamic language.

00:27:37.980 --> 00:27:41.220
So, for example, here's
a chunk of Dart code.

00:27:41.220 --> 00:27:44.120
The most important thing
about types in Dart in

00:27:44.120 --> 00:27:44.990
that they're optional.

00:27:44.990 --> 00:27:48.210
In Dart, you never have to write
a type annotation if you

00:27:48.210 --> 00:27:49.290
don't want to.

00:27:49.290 --> 00:27:51.980
That's why I've been able to
show a bunch of code samples

00:27:51.980 --> 00:27:53.590
without a hint of
static typing.

00:27:53.590 --> 00:27:56.480
So this Dart code here is
perfectly valid, because under

00:27:56.480 --> 00:27:58.880
the hood, the language is
dynamically-typed, and it

00:27:58.880 --> 00:28:01.120
doesn't need any static
types to run.

00:28:01.120 --> 00:28:04.550
But, if you don't roll that way,
you can slather types all

00:28:04.550 --> 00:28:05.540
over your code.

00:28:05.540 --> 00:28:06.810
And that's fine too.

00:28:06.810 --> 00:28:10.700
Maybe it's C++ nostalgia, or you
get paid by the volume of

00:28:10.700 --> 00:28:12.880
code or something.

00:28:12.880 --> 00:28:16.610
In practice, people seem to do
a mix, kind of like this.

00:28:16.610 --> 00:28:18.780
They write types at the API
boundary, but they don't

00:28:18.780 --> 00:28:20.850
usually worry about them
for things like local

00:28:20.850 --> 00:28:22.930
variables or lambdas.

00:28:22.930 --> 00:28:25.900
So if you do that, if you
sprinkle a few types in your

00:28:25.900 --> 00:28:31.300
code, then Dart gives you
some benefits in return.

00:28:31.300 --> 00:28:34.210
So this is jQuery's
contains method.

00:28:34.210 --> 00:28:37.140
And you notice that most of
the documentation is just

00:28:37.140 --> 00:28:40.550
describing the types that
those parameters allow.

00:28:40.550 --> 00:28:42.440
It would be hard to use
this method without

00:28:42.440 --> 00:28:43.610
those comments, right?

00:28:43.610 --> 00:28:45.290
Would you have known that
you couldn't pass a

00:28:45.290 --> 00:28:47.410
jQuery object to it?

00:28:47.410 --> 00:28:49.830
So doing this in documentation
works.

00:28:49.830 --> 00:28:52.110
But programmers don't have
the best reputation for

00:28:52.110 --> 00:28:54.340
maintaining docs.

00:28:54.340 --> 00:28:56.860
So having types gives you a
really light way of writing

00:28:56.860 --> 00:28:58.300
this kind of documentation.

00:28:58.300 --> 00:29:00.880
And we found that just by making
it easier, that people

00:29:00.880 --> 00:29:05.510
are a good bit more likely
to actually do it.

00:29:05.510 --> 00:29:05.750
OK.

00:29:05.750 --> 00:29:08.270
So I'm going to switch over to
the Dart Editor now, which is

00:29:08.270 --> 00:29:11.010
a free, open-source, kind
of lightweight IDE

00:29:11.010 --> 00:29:12.260
we're working on.

00:29:17.330 --> 00:29:17.580
OK.

00:29:17.580 --> 00:29:22.240
I will do the world's quickest
demo of what types let us do

00:29:22.240 --> 00:29:23.390
in the editor.

00:29:23.390 --> 00:29:24.560
So we'll start really simple.

00:29:24.560 --> 00:29:27.570
So here, we have a function
that's supposed to draw some

00:29:27.570 --> 00:29:29.650
stuff on to a DOM element.

00:29:29.650 --> 00:29:31.450
And aside from the fact that it
doesn't do anything, this

00:29:31.450 --> 00:29:32.780
is valid Dart code.

00:29:32.780 --> 00:29:35.540
But let's say we want to
make it clear what kind

00:29:35.540 --> 00:29:37.010
of elements we allow.

00:29:37.010 --> 00:29:39.850
We're going to be drawing using
the Canvas API, so we'll

00:29:39.850 --> 00:29:43.052
annotate it to only accept
Canvas elements.

00:29:43.052 --> 00:29:46.440
And to do that, we
just do this.

00:29:46.440 --> 00:29:48.870
So now anyone looking at this
code can see what kinds of

00:29:48.870 --> 00:29:50.170
elements are kosher here.

00:29:50.170 --> 00:29:53.640
So already, this is useful for
people reading the code.

00:29:53.640 --> 00:29:57.320
But since type annotations are
part of the language grammar,

00:29:57.320 --> 00:29:59.200
the tool can see them too.

00:29:59.200 --> 00:30:02.040
So when I was talking about
classes earlier, I said having

00:30:02.040 --> 00:30:04.930
a declared a syntax for classes
helps with tools.

00:30:04.930 --> 00:30:07.640
The missing piece was having
type annotations that mention

00:30:07.640 --> 00:30:09.480
those tools, those classes.

00:30:09.480 --> 00:30:12.275
So now that we've got
both, I can show you

00:30:12.275 --> 00:30:13.070
what I'm talking about.

00:30:13.070 --> 00:30:15.910
So let's go ahead and implement
this function here.

00:30:15.910 --> 00:30:27.180
[TYPING]

00:30:27.180 --> 00:30:27.430
OK.

00:30:27.430 --> 00:30:31.690
So maybe I'm easily impressed,
but to me, that's pretty

00:30:31.690 --> 00:30:32.340
awesome, right?

00:30:32.340 --> 00:30:35.870
We have full autocomplete going
on for the DOM API.

00:30:35.870 --> 00:30:38.210
And that's really helpful when
you're trying to learn your

00:30:38.210 --> 00:30:40.680
way around a new library,
especially a big

00:30:40.680 --> 00:30:42.290
one like the DOM.

00:30:42.290 --> 00:30:45.010
And it's especially helpful with
stuff like Canvas here,

00:30:45.010 --> 00:30:47.820
where you have methods that take
a lot of arguments, and

00:30:47.820 --> 00:30:49.830
it's easy to forget what
the order is, or

00:30:49.830 --> 00:30:52.360
which ones are optional.

00:30:52.360 --> 00:30:55.650
The reason the editor can do
this is because it knows what

00:30:55.650 --> 00:30:58.120
types are associated with
variables, and it knows what

00:30:58.120 --> 00:31:00.070
methods those types support.

00:31:00.070 --> 00:31:03.250
And, of course, if it knows what
those types are, it also

00:31:03.250 --> 00:31:04.350
knows where they are.

00:31:04.350 --> 00:31:08.000
So we can do this, too.

00:31:08.000 --> 00:31:11.970
So we've got go to definition
working.

00:31:11.970 --> 00:31:14.520
Now, of course, once you've got
types and your tool can

00:31:14.520 --> 00:31:16.940
understand them like this, the
next thing you want it to do

00:31:16.940 --> 00:31:18.750
is tell you when you're
using them wrong.

00:31:18.750 --> 00:31:20.650
So we can do that too.

00:31:20.650 --> 00:31:23.280
Let's go ahead and get
something wrong.

00:31:23.280 --> 00:31:24.977
So we'll try setting
the line width.

00:31:24.977 --> 00:31:29.750
[TYPING]

00:31:29.750 --> 00:31:33.120
Now I'm going to guess that it
takes a string so that I can

00:31:33.120 --> 00:31:35.810
specify CSS units.

00:31:35.810 --> 00:31:39.540
Now when I try that, as soon
as I do, I get a warning

00:31:39.540 --> 00:31:41.700
immediately in the editor
telling me I'm doing the wrong

00:31:41.700 --> 00:31:45.200
thing, instead of having to
spend who knows how much time

00:31:45.200 --> 00:31:48.820
debugging the stuff at runtime
in my browser.

00:31:48.820 --> 00:31:52.080
Now, I feel a little silly
making a big deal out of this,

00:31:52.080 --> 00:31:54.750
because anyone coming from
Visual Studio or Eclipse is

00:31:54.750 --> 00:31:57.000
like, yeah, this is
kind of old news.

00:31:57.000 --> 00:31:59.720
But this kind of error checking
is kind of a rarity

00:31:59.720 --> 00:32:01.950
in client-side web
programming.

00:32:01.950 --> 00:32:04.390
But what I think is particularly
cool here is that

00:32:04.390 --> 00:32:06.230
we got this error checking
without having to put a

00:32:06.230 --> 00:32:07.470
lot of effort in.

00:32:07.470 --> 00:32:10.450
You'll notice that this entire
program has exactly one single

00:32:10.450 --> 00:32:15.250
type annotation, just that one
little Canvas element up here.

00:32:15.250 --> 00:32:16.950
And that's enough for the editor
to figure out what I'm

00:32:16.950 --> 00:32:20.120
trying to do and let me know
when I've got it wrong.

00:32:20.120 --> 00:32:23.200
I hate tracking down stupid
bugs, so this is kind of like

00:32:23.200 --> 00:32:24.450
sunshine and rainbows for me.

00:32:26.990 --> 00:32:28.240
OK.

00:32:31.710 --> 00:32:34.450
So for us, those are pretty much
the big things that we

00:32:34.450 --> 00:32:35.340
want to get out of types.

00:32:35.340 --> 00:32:38.910
We want better API
documentation.

00:32:38.910 --> 00:32:41.210
We want code navigation, so you
can learn your way around

00:32:41.210 --> 00:32:42.140
a code base.

00:32:42.140 --> 00:32:46.450
We want autocomplete, so that
you can discover what methods

00:32:46.450 --> 00:32:50.180
type support as you use them,
and learn an API interactively

00:32:50.180 --> 00:32:51.886
in your editor.

00:32:51.886 --> 00:32:54.300
We want some basic error
checking, so you can catch

00:32:54.300 --> 00:32:55.410
typos and type errors.

00:32:55.410 --> 00:32:58.730
And that's really the major
stuff, like maybe some

00:32:58.730 --> 00:33:01.380
refactoring support.

00:33:01.380 --> 00:33:04.340
Oh, and there's one more thing
that types let us do.

00:33:04.340 --> 00:33:06.510
This is something that
I think is--

00:33:06.510 --> 00:33:09.590
I personally think is really,
really cool and could possibly

00:33:09.590 --> 00:33:11.540
be a big deal for the web.

00:33:11.540 --> 00:33:13.880
So, I'm pretty new to
web programming.

00:33:13.880 --> 00:33:17.030
And as I was learning my way
around, I looked at a bunch of

00:33:17.030 --> 00:33:19.050
sites for various JavaScript
libraries.

00:33:19.050 --> 00:33:21.300
And I started noticing something
that seemed a

00:33:21.300 --> 00:33:23.810
little odd to me.

00:33:23.810 --> 00:33:26.630
So this is jQuery's website,
and the little arrow is

00:33:26.630 --> 00:33:30.750
pointing to-- it's telling me
how big the library is.

00:33:30.750 --> 00:33:31.930
Why do I care about this?

00:33:31.930 --> 00:33:35.130
I don't remember any C++
libraries being like, hey,

00:33:35.130 --> 00:33:39.040
we're only 5K of code
or whatever.

00:33:39.040 --> 00:33:40.010
This is Mootools.

00:33:40.010 --> 00:33:44.250
It's pointing to compact, so
here, I guess, being small is

00:33:44.250 --> 00:33:48.100
important enough to be
part of its branding.

00:33:48.100 --> 00:33:49.590
This is Raphael.

00:33:49.590 --> 00:33:51.290
Here, it mentions small
in the text.

00:33:51.290 --> 00:33:53.190
And it highlights
the file size.

00:33:53.190 --> 00:33:55.870
And it goes out of its way to
tell you how big it is after

00:33:55.870 --> 00:33:58.700
you gzip it.

00:33:58.700 --> 00:34:00.050
This is Bootstrap.

00:34:00.050 --> 00:34:01.740
Bootstrap doesn't
seem to care.

00:34:01.740 --> 00:34:03.940
Oh, unless you look
under the fold.

00:34:03.940 --> 00:34:06.180
So here, that cares too.

00:34:06.180 --> 00:34:09.719
And finally, the ultimate
example of this is Zepto.

00:34:09.719 --> 00:34:13.360
So with Zepto even the name
is about how small it is.

00:34:13.360 --> 00:34:16.020
The whole goal of Zepto's
existence is to be small.

00:34:16.020 --> 00:34:19.469
Their pitch is hey, you know all
that cool stuff in jQuery?

00:34:19.469 --> 00:34:21.639
We took most of that out.

00:34:21.639 --> 00:34:24.850
And that's kind of
like, that's it.

00:34:24.850 --> 00:34:27.610
Now, just to be clear, the
designers of these libraries

00:34:27.610 --> 00:34:29.620
are doing exactly the
right thing for the

00:34:29.620 --> 00:34:30.630
world they live in.

00:34:30.630 --> 00:34:32.600
They're not crazy.

00:34:32.600 --> 00:34:35.650
If you look, Zepto calls out
the problem right here.

00:34:35.650 --> 00:34:38.800
Every line of JavaScript in a
library that you use has to

00:34:38.800 --> 00:34:40.850
get pushed down the wire
to the user's browser.

00:34:40.850 --> 00:34:44.230
And unless you really, really
clever, every line you send

00:34:44.230 --> 00:34:47.960
down adds a tiny bit of
delay before users can

00:34:47.960 --> 00:34:48.920
start using your app.

00:34:48.920 --> 00:34:51.449
So the bigger the libraries
you use, this slower

00:34:51.449 --> 00:34:52.690
your app starts up.

00:34:52.690 --> 00:34:54.650
So minimizing library
size is the only

00:34:54.650 --> 00:34:57.300
way to get fast startup.

00:34:57.300 --> 00:35:00.860
My background, strangely
enough, is video games.

00:35:00.860 --> 00:35:03.410
So this seems totally
crazy to me.

00:35:03.410 --> 00:35:05.780
I certainly cared about
code size, because I

00:35:05.780 --> 00:35:07.150
was coming from C++.

00:35:07.150 --> 00:35:11.340
So I had template expansion,
and limited game RAM, and I

00:35:11.340 --> 00:35:15.270
had this pathological aversion
to instruction cache misses.

00:35:15.270 --> 00:35:18.610
But I never thought well, can't
use this library, it's

00:35:18.610 --> 00:35:21.030
got functions that
I don't call.

00:35:21.030 --> 00:35:24.780
Because eliminating dead code
is the linker's job.

00:35:24.780 --> 00:35:26.960
Where's my linker
for JavaScript?

00:35:26.960 --> 00:35:31.630
Well, part of the problem is
that it's really, really hard.

00:35:31.630 --> 00:35:35.900
So here's some JavaScripts to
create a monster object with

00:35:35.900 --> 00:35:37.700
an attack method.

00:35:37.700 --> 00:35:40.320
Now, the question is, is that
method ever called in our

00:35:40.320 --> 00:35:43.102
program, or can we
strip it out?

00:35:43.102 --> 00:35:46.260
Well, obviously, if we see
something like this, then

00:35:46.260 --> 00:35:48.790
yeah, it's probably in use.

00:35:48.790 --> 00:35:52.750
But you can also do
this, or this.

00:35:52.750 --> 00:35:56.040
So this calls the attack method,
but only on Tuesdays

00:35:56.040 --> 00:35:59.880
and Thursdays and, I think,
only in certain locales.

00:35:59.880 --> 00:36:03.300
So, in general, it's not
possible to statically tell

00:36:03.300 --> 00:36:05.180
what code is reachable
in JavaScript.

00:36:05.180 --> 00:36:07.580
Everything is mutable,
everything is imperative.

00:36:07.580 --> 00:36:10.470
And everything can be reached
by name, using strings

00:36:10.470 --> 00:36:11.770
constructed at runtime.

00:36:11.770 --> 00:36:14.220
And that kind of flexibility
is super fun for

00:36:14.220 --> 00:36:16.930
metaprogramming, but it's the
kiss of death when you want to

00:36:16.930 --> 00:36:20.370
do stuff that relies
on static analysis.

00:36:20.370 --> 00:36:23.140
But dead code elimination
isn't impossible.

00:36:23.140 --> 00:36:26.460
Lispers and Smalltalkers have
been doing this forever,

00:36:26.460 --> 00:36:28.950
because they've apparently been
doing everything forever.

00:36:28.950 --> 00:36:32.450
So Lispers call dead code
elimination tree shaking.

00:36:32.450 --> 00:36:34.245
They think of their
code as a tree.

00:36:34.245 --> 00:36:36.280
And the root of the
tree is main().

00:36:36.280 --> 00:36:38.760
And then the branches are
everything that main () calls,

00:36:38.760 --> 00:36:40.630
and then everything that those
things call, and so on, all

00:36:40.630 --> 00:36:42.550
the way out to the leaves.

00:36:42.550 --> 00:36:44.650
And code in your program
that doesn't get called

00:36:44.650 --> 00:36:46.720
is just dead wood.

00:36:46.720 --> 00:36:49.320
Now, imagine grabbing the trunk
and shaking it hard.

00:36:49.320 --> 00:36:51.990
All of the loose, dead branches
that aren't actually

00:36:51.990 --> 00:36:55.310
connected fall off, and what
you're left with is just the

00:36:55.310 --> 00:36:58.210
live tree, just the stuff that
you can reach from the root.

00:36:58.210 --> 00:37:00.730
So in Dart, doing this
is pretty easy.

00:37:00.730 --> 00:37:03.010
We have a declarative
syntax for classes.

00:37:03.010 --> 00:37:05.100
So we know what methods
every type supports.

00:37:05.100 --> 00:37:06.760
We have type annotations.

00:37:06.760 --> 00:37:09.020
So it's pretty easy to tell
what types of objects are

00:37:09.020 --> 00:37:10.320
stored in variables.

00:37:10.320 --> 00:37:12.430
And then we also have a
declarative syntax for

00:37:12.430 --> 00:37:13.870
importing modules.

00:37:13.870 --> 00:37:16.480
And that's enough to get a
decent picture of which code

00:37:16.480 --> 00:37:18.030
is in use and which isn't.

00:37:18.030 --> 00:37:20.910
So we have this Dart to
JavaScript compiler, but it

00:37:20.910 --> 00:37:23.660
doesn't just turn your Dart
code into JavaScript.

00:37:23.660 --> 00:37:26.520
It reads in your entire program,
your app, and every

00:37:26.520 --> 00:37:28.160
single library it uses.

00:37:28.160 --> 00:37:30.680
And then it grabs your main
() function, and shakes

00:37:30.680 --> 00:37:31.465
the hell out of it.

00:37:31.465 --> 00:37:34.400
And it only generates code for
the stuff that's left, the

00:37:34.400 --> 00:37:36.360
code that's called.

00:37:36.360 --> 00:37:39.920
Now, our hope is that this means
that code reuse will be

00:37:39.920 --> 00:37:41.740
much easier in Dart.

00:37:41.740 --> 00:37:44.320
You can just make libraries
that do useful stuff.

00:37:44.320 --> 00:37:48.270
You shouldn't have to agonize
over, can I add this function

00:37:48.270 --> 00:37:49.920
to my library, or will
that make it to big

00:37:49.920 --> 00:37:51.770
and scare off users?

00:37:51.770 --> 00:37:54.780
And when you use a library, the
compiler will shake out

00:37:54.780 --> 00:37:55.620
the stuff you don't call.

00:37:55.620 --> 00:37:58.260
The only code that gets pushed
down the wire is the

00:37:58.260 --> 00:37:59.240
code that you need.

00:37:59.240 --> 00:38:00.605
And you only pay for
what you use.

00:38:04.210 --> 00:38:04.540
OK.

00:38:04.540 --> 00:38:07.670
So you survived the fire
hose of slides.

00:38:07.670 --> 00:38:10.740
I pushed a whole pile of stuff
onto your mental stacks, so

00:38:10.740 --> 00:38:13.740
I'll pop the important
bits off.

00:38:13.740 --> 00:38:17.620
First of all, the JavaScript
community has code reuse

00:38:17.620 --> 00:38:20.310
problems, because download
sizes limit the size of

00:38:20.310 --> 00:38:22.050
libraries you can use.

00:38:22.050 --> 00:38:25.440
And if we're lucky, tree shaking
to eliminate dead code

00:38:25.440 --> 00:38:30.200
automatically will help
solve that for Dart.

00:38:30.200 --> 00:38:34.280
Taking a dynamic language and
then layering on just some

00:38:34.280 --> 00:38:37.490
really simple, optional static
typing can give you

00:38:37.490 --> 00:38:41.430
autocomplete, code navigation,
error checking, maybe

00:38:41.430 --> 00:38:44.260
refactoring support, most of
the stuff you expect from a

00:38:44.260 --> 00:38:47.790
fully static language, without a
lot of the restrictions of a

00:38:47.790 --> 00:38:51.140
mandatory-type checker.

00:38:51.140 --> 00:38:53.760
You can make the DOM a lot more
awesome if you just pick

00:38:53.760 --> 00:38:56.903
one language, and that
language isn't XML.

00:38:59.870 --> 00:39:02.710
Language features like getters
and setters and operator

00:39:02.710 --> 00:39:05.820
overloading that let you take
built-in syntax and give it

00:39:05.820 --> 00:39:08.830
your own user-defined behavior
are like super awesome,

00:39:08.830 --> 00:39:11.650
because they save you from
having to write a bunch of

00:39:11.650 --> 00:39:14.390
pointless future-proofing
boilerplate code when your app

00:39:14.390 --> 00:39:15.620
is starting out.

00:39:15.620 --> 00:39:17.120
And then they give you
flexibility when

00:39:17.120 --> 00:39:20.410
it grows over time.

00:39:20.410 --> 00:39:23.820
Having language support for
classes makes it a lot easier

00:39:23.820 --> 00:39:27.240
for programmers to express their
intents declaratively,

00:39:27.240 --> 00:39:29.580
gives you a bunch of nice,
little features and it makes

00:39:29.580 --> 00:39:32.864
tooling way easier.

00:39:32.864 --> 00:39:36.230
And finally, compilation to
JavaScript is awesome.

00:39:36.230 --> 00:39:39.170
It lets us all have new
languages on the client

00:39:39.170 --> 00:39:40.680
without breaking the open web.

00:39:40.680 --> 00:39:44.300
And it lets Dart work on every
major modern browser, right

00:39:44.300 --> 00:39:47.050
now, without any effort on the
users' or the browsers

00:39:47.050 --> 00:39:48.300
vendors' part.

00:39:50.920 --> 00:39:54.160
So if I'm very lucky, hopefully
I've piqued your

00:39:54.160 --> 00:39:55.160
interest in Dart.

00:39:55.160 --> 00:39:59.450
If you want to learn a little
bit more and try it out, I

00:39:59.450 --> 00:40:02.030
strongly encourage you to
check out dartlang.org.

00:40:02.030 --> 00:40:05.530
We've got examples, and
tutorials, and documentation,

00:40:05.530 --> 00:40:07.790
all sorts of stuff like that.

00:40:07.790 --> 00:40:09.460
You can download the SDK.

00:40:09.460 --> 00:40:12.330
It works on Linux,
Mac, and Windows.

00:40:12.330 --> 00:40:14.680
You can also download
the editor, which

00:40:14.680 --> 00:40:16.500
includes the SDK.

00:40:16.500 --> 00:40:20.310
And it also includes Dartium,
which is our custom browser

00:40:20.310 --> 00:40:22.550
with the Dart VM installed.

00:40:22.550 --> 00:40:24.260
If nothing else, I
think it's really

00:40:24.260 --> 00:40:26.160
cool to try out Dartium.

00:40:26.160 --> 00:40:29.180
And just write a little bit
of Dart code, because the

00:40:29.180 --> 00:40:32.580
experience of having a new
language running natively in a

00:40:32.580 --> 00:40:34.790
browser, it has an
interesting feel.

00:40:34.790 --> 00:40:37.860
Even if you ultimately don't end
up liking Dart, it's kind

00:40:37.860 --> 00:40:41.700
of cool seeing what it's like
to have a language that just

00:40:41.700 --> 00:40:44.510
runs directly in the browser,
and can talk to the DOM that

00:40:44.510 --> 00:40:45.760
isn't JavaScript.

00:40:47.800 --> 00:40:49.880
Anyway, so that's it.

00:40:49.880 --> 00:40:51.130
Thanks for your time.

