WEBVTT
Kind: captions
Language: en

00:00:09.405 --> 00:00:10.980
JOHN MCCUTCHAN: Hey, everyone.

00:00:10.980 --> 00:00:12.250
I'm John McCutchan.

00:00:12.250 --> 00:00:17.100
You might remember me
from a couple hours ago.

00:00:17.100 --> 00:00:20.530
But instead of games, I'm
here to talk about Dart.

00:00:20.530 --> 00:00:22.420
I'm an engineer on
the Dart VM team.

00:00:22.420 --> 00:00:27.000
And the goal of the
team that I'm on

00:00:27.000 --> 00:00:32.080
is to really make
the web faster.

00:00:32.080 --> 00:00:36.180
Our goal is to make applications
run at least twice as

00:00:36.180 --> 00:00:39.490
fast as they can in JavaScript.

00:00:39.490 --> 00:00:42.970
But this talk is going to focus
a lot on like what Dart is,

00:00:42.970 --> 00:00:46.750
and its philosophy, and
the feel of the language.

00:00:46.750 --> 00:00:51.940
But before I start, how many
of you have heard of Dart?

00:00:55.380 --> 00:00:58.870
And how many of you
have tried out Dart?

00:00:58.870 --> 00:01:01.260
Taken a look at it?

00:01:01.260 --> 00:01:06.160
All right, well, I hope
to change some minds here.

00:01:09.120 --> 00:01:13.010
So I guess you could capture
a lot of Dart's philosophy

00:01:13.010 --> 00:01:17.030
with this phrase
"batteries included,"

00:01:17.030 --> 00:01:20.630
which in America
means, like it comes

00:01:20.630 --> 00:01:22.390
with everything
you need to use it.

00:01:22.390 --> 00:01:26.330
So Dart-- it's not
just a language,

00:01:26.330 --> 00:01:28.880
but there's actually
standard libraries.

00:01:28.880 --> 00:01:32.840
There's tools, an editor that
understands the code base,

00:01:32.840 --> 00:01:37.170
can give you
auto-completion, everything.

00:01:37.170 --> 00:01:38.480
There's a virtual machine.

00:01:38.480 --> 00:01:40.750
That's the team that
I work on, and that's

00:01:40.750 --> 00:01:47.070
headed by Lars Bach,
who used to do V8.

00:01:47.070 --> 00:01:49.050
You might know V8.

00:01:49.050 --> 00:01:51.970
And then there's a
compiler to JavaScript.

00:01:51.970 --> 00:01:55.300
So even if your browser doesn't
have the Dart virtual machine,

00:01:55.300 --> 00:01:58.450
it doesn't matter, because
you can compile Dart source

00:01:58.450 --> 00:02:02.170
code to JavaScript, and
it runs just as fast

00:02:02.170 --> 00:02:05.110
as handwritten JavaScript.

00:02:05.110 --> 00:02:06.885
And you'll see the
compelling reasons

00:02:06.885 --> 00:02:11.440
of why you might want to code
in Dart versus pure JavaScript.

00:02:11.440 --> 00:02:13.340
So here's a little story here.

00:02:13.340 --> 00:02:15.070
So I want to build
a web app, right?

00:02:15.070 --> 00:02:16.650
This is the state
of the world today

00:02:16.650 --> 00:02:19.180
if you're a
JavaScript developer.

00:02:19.180 --> 00:02:23.110
Well, you'll get to Backbone,
and backbone Marionette,

00:02:23.110 --> 00:02:26.700
and jQuery, and
Modernizr-- I mean,

00:02:26.700 --> 00:02:28.304
it just goes on and on and on.

00:02:30.990 --> 00:02:32.380
It's kind of crazy, right?

00:02:32.380 --> 00:02:35.050
I mean, there's
no standard stack.

00:02:35.050 --> 00:02:37.590
There's no default
way that everyone

00:02:37.590 --> 00:02:39.450
who's writing JavaScript
writes JavaScript.

00:02:39.450 --> 00:02:42.900
Every JavaScript project
kind of hand-picks

00:02:42.900 --> 00:02:46.735
a few of these libraries, that
they like, and goes with it.

00:02:46.735 --> 00:02:51.440
But Dart has all of
these things included.

00:02:51.440 --> 00:02:53.750
So there's a little
bit of sanity here.

00:02:53.750 --> 00:02:55.130
Things are very consistent.

00:02:55.130 --> 00:02:57.980
So the Dart SDK
is the base here.

00:02:57.980 --> 00:03:00.580
And then what we have is
we have a package system

00:03:00.580 --> 00:03:05.570
where Dart library developers
can upload their packages

00:03:05.570 --> 00:03:07.050
to a central repository.

00:03:07.050 --> 00:03:09.470
And then you, as a Dart
programmer, can just say,

00:03:09.470 --> 00:03:11.250
well, I want to use
the unit test library,

00:03:11.250 --> 00:03:13.130
and I want to use
Web UI, and I care

00:03:13.130 --> 00:03:17.930
about internationalization, and
you'll just get those packages.

00:03:17.930 --> 00:03:20.530
And every other Dart
programmer out there

00:03:20.530 --> 00:03:22.240
is going to be using
these same packages,

00:03:22.240 --> 00:03:23.865
so there's a little
bit of consistency.

00:03:27.200 --> 00:03:29.600
But then we want to
scale web apps up.

00:03:29.600 --> 00:03:33.006
Right now, it's very difficult
even inside of Google.

00:03:33.006 --> 00:03:34.630
I mean, we've got
dozens-- no, hundreds

00:03:34.630 --> 00:03:37.662
of engineers working in
millions of lines of code.

00:03:37.662 --> 00:03:39.120
There's all these
different layers.

00:03:39.120 --> 00:03:42.760
There's GWT, there's
Closure, there's Soy.

00:03:42.760 --> 00:03:45.340
But the productivity is impacted
by this, because there's

00:03:45.340 --> 00:03:49.850
no edit/refresh iteration
cycle during development.

00:03:49.850 --> 00:03:53.030
You have to go through all these
different intermediate steps

00:03:53.030 --> 00:03:55.450
just to see the
change that you made,

00:03:55.450 --> 00:03:59.970
and the source code actually
show up on the site.

00:03:59.970 --> 00:04:02.490
So this is kind of like a
running theme here with Dart,

00:04:02.490 --> 00:04:05.150
is that we can do
better than this.

00:04:05.150 --> 00:04:08.380
And there's a lot of
competition in terms

00:04:08.380 --> 00:04:11.330
of languages to
replace JavaScript.

00:04:11.330 --> 00:04:14.810
And in a way, that confirms
one of Dart's goals, which

00:04:14.810 --> 00:04:20.480
is that JavaScript
has certain flaws,

00:04:20.480 --> 00:04:22.420
and there's a lot of
languages out there

00:04:22.420 --> 00:04:24.960
that are trying to kind
of paper over these flaws,

00:04:24.960 --> 00:04:28.320
and make it easier
and more digestible.

00:04:28.320 --> 00:04:32.005
So there's Dart,
there's Closure,

00:04:32.005 --> 00:04:34.960
there's CoffeeScript there's
TypeScript there's GWT.

00:04:34.960 --> 00:04:37.130
But when you compare
all of these things,

00:04:37.130 --> 00:04:39.220
Dart has some really
compelling things--

00:04:39.220 --> 00:04:42.390
in particular the rightmost
column here, performance.

00:04:42.390 --> 00:04:45.730
These other languages
are always built

00:04:45.730 --> 00:04:48.270
around the idea of compiling
directly to JavaScript,

00:04:48.270 --> 00:04:50.390
so the performance is
kind of like however

00:04:50.390 --> 00:04:51.980
fast you can run
JavaScript, that's

00:04:51.980 --> 00:04:55.050
how fast your program written
in CoffeeScript or Typescript

00:04:55.050 --> 00:04:55.600
can run.

00:04:55.600 --> 00:04:57.010
It can't run any quicker.

00:04:57.010 --> 00:04:58.900
But with Dart,
with a Dart VM, you

00:04:58.900 --> 00:05:01.280
could theoretically
run twice as fast.

00:05:05.960 --> 00:05:07.770
So let's give a
quick tour of what

00:05:07.770 --> 00:05:10.440
Dart source code looks like.

00:05:10.440 --> 00:05:11.840
So Dart is class-based.

00:05:11.840 --> 00:05:12.770
It's object-oriented.

00:05:12.770 --> 00:05:15.860
It's not prototype based
the way JavaScript is.

00:05:15.860 --> 00:05:19.490
So the one running theme
with Dart source code

00:05:19.490 --> 00:05:20.540
is that it's familiar.

00:05:20.540 --> 00:05:24.750
If you're familiar with a
language like Java or C or C++

00:05:24.750 --> 00:05:27.720
or C#, you're going to feel
right at home with Dart.

00:05:27.720 --> 00:05:29.470
It's very similar.

00:05:29.470 --> 00:05:33.660
So let's make a class Hug.

00:05:33.660 --> 00:05:36.590
And Hug can have
a strength to it.

00:05:36.590 --> 00:05:40.880
How strong am I hugging you?

00:05:40.880 --> 00:05:42.580
But you can be really terse.

00:05:42.580 --> 00:05:45.150
A lot of the time, in your
constructor for a class,

00:05:45.150 --> 00:05:47.510
you open it up, and you just
take the parameters that

00:05:47.510 --> 00:05:49.880
were passed to the
constructor, and assign them

00:05:49.880 --> 00:05:50.980
to member variables.

00:05:50.980 --> 00:05:52.870
In Dart, there's just shorthand.

00:05:52.870 --> 00:05:55.890
You see Hug this dot strength.

00:05:55.890 --> 00:05:57.820
That just means it's
shorthand for saying,

00:05:57.820 --> 00:05:59.640
take this parameter,
and assign it

00:05:59.640 --> 00:06:02.470
to my member variable strength.

00:06:05.340 --> 00:06:06.814
You can have named constructors.

00:06:06.814 --> 00:06:08.480
So you can have a
secondary constructor.

00:06:08.480 --> 00:06:11.370
So if you just want a shorthand
for like a super strong bear

00:06:11.370 --> 00:06:17.080
hug, just do Hug.bear, and
strength is set to 100.

00:06:17.080 --> 00:06:19.360
You can do operator overloading.

00:06:19.360 --> 00:06:22.270
This is something that's not
possible in JavaScript today.

00:06:22.270 --> 00:06:26.110
This allows you to take two
hugs, and add them together.

00:06:26.110 --> 00:06:31.380
And in this class, that means
adding their strength together.

00:06:31.380 --> 00:06:33.960
You can have named
optional parameters.

00:06:33.960 --> 00:06:36.580
So you don't have to pass
parameters always by the order

00:06:36.580 --> 00:06:38.290
that the function
accepts them in.

00:06:38.290 --> 00:06:41.420
You can actually provide
names, and make them optional,

00:06:41.420 --> 00:06:44.660
and give them default values.

00:06:44.660 --> 00:06:48.940
So by default, if I want to
patBack, it's just one hand.

00:06:48.940 --> 00:06:52.430
I'm not using both of my hands.

00:06:52.430 --> 00:06:56.800
And this is another example
of how terse Dart can be.

00:06:56.800 --> 00:06:58.040
Here's toString.

00:06:58.040 --> 00:06:59.580
If it's just a
one-line function,

00:06:59.580 --> 00:07:04.010
why have a curly brace and
all that extra syntax with it?

00:07:04.010 --> 00:07:08.320
You can just do a fat arrow
syntax, that fat arrow says,

00:07:08.320 --> 00:07:10.800
return whatever's
on the right of this

00:07:10.800 --> 00:07:14.820
is the result of
calling this function.

00:07:14.820 --> 00:07:16.490
We also have string
interpolation.

00:07:16.490 --> 00:07:23.070
So instead of having to use the
add operator to combine strings

00:07:23.070 --> 00:07:26.010
together, or to take a variable
and convert it into a string,

00:07:26.010 --> 00:07:29.530
you can actually just use
this dollar sign syntax here.

00:07:29.530 --> 00:07:31.720
So if you had a
hug, and you wanted

00:07:31.720 --> 00:07:37.210
to print it to the console,
it would be the Embraceometer

00:07:37.210 --> 00:07:40.330
reads $strength-- whatever
the value of strength

00:07:40.330 --> 00:07:44.400
is at that time.

00:07:44.400 --> 00:07:46.830
So one of the most
important things to me

00:07:46.830 --> 00:07:50.090
as a developer about Dart
is that the semantics

00:07:50.090 --> 00:07:52.230
are really clean.

00:07:52.230 --> 00:07:55.980
I come from a C, C++ background,
so coming to JavaScript,

00:07:55.980 --> 00:07:58.192
I often get confused.

00:07:58.192 --> 00:07:59.650
I don't understand
what's going on.

00:07:59.650 --> 00:08:01.640
I compare to things
they shouldn't be equal

00:08:01.640 --> 00:08:03.830
and they're equal, or
the other way around.

00:08:03.830 --> 00:08:08.290
Dart, that's not going to
happen, because only true

00:08:08.290 --> 00:08:09.620
is true.

00:08:09.620 --> 00:08:11.690
And there's no undefined.

00:08:11.690 --> 00:08:12.710
That doesn't exist.

00:08:12.710 --> 00:08:14.150
It's just null.

00:08:14.150 --> 00:08:15.460
There's no type coercion.

00:08:15.460 --> 00:08:21.090
If I say is a equals
equal to b, the language

00:08:21.090 --> 00:08:23.030
is not going to try
and make them equal.

00:08:23.030 --> 00:08:25.800
It's just going to evaluate
the equal equals operator,

00:08:25.800 --> 00:08:27.040
and return true or false.

00:08:27.040 --> 00:08:29.820
That's it.

00:08:29.820 --> 00:08:35.590
So what happens if you
try and access some value

00:08:35.590 --> 00:08:39.740
on an instance
that doesn't exist?

00:08:39.740 --> 00:08:44.010
Well, you actually get a
proper NoSuchMethodError.

00:08:44.010 --> 00:08:48.720
The class string doesn't
respond to the missing getter.

00:08:48.720 --> 00:08:52.500
And we'll see more on
NoSuchMethod as we go on.

00:08:52.500 --> 00:08:54.810
But this is very logical, right?

00:08:54.810 --> 00:08:59.640
You asked for the missing
property on a string.

00:08:59.640 --> 00:09:02.330
And instead of it
just kind of magically

00:09:02.330 --> 00:09:04.340
giving you undefined
or null, you're

00:09:04.340 --> 00:09:08.480
getting a proper error
message, telling you

00:09:08.480 --> 00:09:11.910
who the receiver was, a little
bit of a message, any arguments

00:09:11.910 --> 00:09:14.260
passed to the function.

00:09:14.260 --> 00:09:15.990
What about an
index out of range?

00:09:15.990 --> 00:09:17.920
This is completely
valid in JavaScript.

00:09:17.920 --> 00:09:21.480
You can just ask for this,
you'll get something back.

00:09:21.480 --> 00:09:23.500
In Dart, you actually
get a RangeError.

00:09:23.500 --> 00:09:26.320
This array does not
have a 99th element,

00:09:26.320 --> 00:09:29.560
so it can't possibly
give it to you.

00:09:29.560 --> 00:09:35.140
So this stops you from kind of
cruising through development,

00:09:35.140 --> 00:09:38.300
not realizing that you've
made a lot of subtle bugs

00:09:38.300 --> 00:09:40.790
inside your code.

00:09:40.790 --> 00:09:43.350
So this is something
that, for me,

00:09:43.350 --> 00:09:48.760
JavaScript is incredibly
confusing, is variable scope.

00:09:48.760 --> 00:09:51.300
So we see here that we
have many foos, right?

00:09:51.300 --> 00:09:54.010
We have a foo that's
local to the VAR function,

00:09:54.010 --> 00:09:56.670
and we have a foo that's
in the global scope.

00:09:56.670 --> 00:09:58.490
But there's no hoisting, right?

00:09:58.490 --> 00:10:04.440
You can see that the foo
inside the if not true branch

00:10:04.440 --> 00:10:08.120
doesn't override the foo
that's in the global scope.

00:10:08.120 --> 00:10:10.870
So this kind of operates the
way languages like C and Java

00:10:10.870 --> 00:10:14.260
and C# where the scoping
is truly lexical.

00:10:18.020 --> 00:10:22.310
And this-- this is like-- every
time I program in JavaScript,

00:10:22.310 --> 00:10:26.300
I make this mistake where
I have the this is not

00:10:26.300 --> 00:10:28.030
the this that I expect it to be.

00:10:28.030 --> 00:10:31.110
But in Dart, it always is the
this that you expect it to be.

00:10:34.270 --> 00:10:35.920
So there's a real
scalable structure.

00:10:35.920 --> 00:10:37.810
If you want to use
a library in Dart,

00:10:37.810 --> 00:10:39.760
you actually have to
explicitly import it,

00:10:39.760 --> 00:10:41.910
and you have to
name your libraries.

00:10:41.910 --> 00:10:44.790
So everything-- again, there's
a lot of structure here.

00:10:44.790 --> 00:10:47.590
So you can see on the
right-hand side of this slide,

00:10:47.590 --> 00:10:49.166
I'm making a library.

00:10:49.166 --> 00:10:50.040
I'm calling it games.

00:10:50.040 --> 00:10:52.570
So if I wanted to
upload it as a package,

00:10:52.570 --> 00:10:54.710
you could use my games library.

00:10:54.710 --> 00:10:56.880
And my games library
needs the math librarian,

00:10:56.880 --> 00:11:00.040
and it needs the
players library,

00:11:00.040 --> 00:11:03.670
and there's all these
different classes in there.

00:11:03.670 --> 00:11:07.740
But let's dig deeper into
what's new in the Dart language.

00:11:07.740 --> 00:11:10.600
So if we look at this,
we see in var button

00:11:10.600 --> 00:11:11.920
is equal to new ButtonElements.

00:11:11.920 --> 00:11:13.545
We're making a
ButtonElement, and we're

00:11:13.545 --> 00:11:15.000
going to insert it into the DOM.

00:11:15.000 --> 00:11:17.090
And we want to set
its ID to fancy,

00:11:17.090 --> 00:11:20.790
and the text to click, and
add the important CSS class,

00:11:20.790 --> 00:11:26.160
and set up a listener for
click, and then finally add it

00:11:26.160 --> 00:11:28.585
to the DOM at the end there.

00:11:28.585 --> 00:11:31.770
In Dart, we have
this dot dot syntax.

00:11:31.770 --> 00:11:34.490
So you could say var button is
equal to a new ButtonElement

00:11:34.490 --> 00:11:40.510
dot dot id equals fancy dot
dot text, et cetera, right?

00:11:40.510 --> 00:11:42.400
So this saves you
a lot of typing,

00:11:42.400 --> 00:11:44.120
and it becomes
clearer that you're

00:11:44.120 --> 00:11:47.950
kind of doing all of this
as one unit of logic.

00:11:47.950 --> 00:11:49.900
And you can even
go so far as just

00:11:49.900 --> 00:11:53.390
put that right inside
the children.add, so you

00:11:53.390 --> 00:11:55.590
can do new
ButtonElement dot dot.

00:11:55.590 --> 00:11:58.400
So when this expression
is evaluated,

00:11:58.400 --> 00:12:00.150
your ButtonElement is
entirely initialized

00:12:00.150 --> 00:12:02.566
the way you want it to be, and
then it's added to the DOM.

00:12:06.670 --> 00:12:13.220
So what if you wanted to
serialize a hug object?

00:12:13.220 --> 00:12:15.740
You wanted to put
it into a data store

00:12:15.740 --> 00:12:19.010
somewhere, put it in a database
or something like that,

00:12:19.010 --> 00:12:20.776
make it persistable?

00:12:20.776 --> 00:12:22.370
You know, in a
class-based language,

00:12:22.370 --> 00:12:25.950
you think OK, well, I'll
make a persistable class,

00:12:25.950 --> 00:12:28.700
and then have all
the classes that I

00:12:28.700 --> 00:12:31.815
want to serialize into this
persistable data store,

00:12:31.815 --> 00:12:32.930
and inherit from that.

00:12:32.930 --> 00:12:36.430
But that's not really what
object-oriented inheritance

00:12:36.430 --> 00:12:37.730
is supposed to be.

00:12:37.730 --> 00:12:40.060
So Dart actually has
this concept of a mixin.

00:12:40.060 --> 00:12:43.500
So hug is still just inheriting
from the base object,

00:12:43.500 --> 00:12:45.934
but you can actually
mix in functionality.

00:12:45.934 --> 00:12:47.600
So it doesn't alter
the class hierarchy,

00:12:47.600 --> 00:12:52.390
but it provides new
functionality to your class.

00:12:52.390 --> 00:12:55.370
So if we have this abstract
class persistable, which

00:12:55.370 --> 00:12:58.660
I save load into
JSON, we can say

00:12:58.660 --> 00:13:03.010
that class hug extends
object with persistable.

00:13:03.010 --> 00:13:06.650
So hug gets the functionality
of the persistable class,

00:13:06.650 --> 00:13:09.410
but it doesn't pollute the
class hierarchy in a way

00:13:09.410 --> 00:13:12.180
that it is not logically sound.

00:13:12.180 --> 00:13:16.284
And then here we say, let's
instantiate a new hug,

00:13:16.284 --> 00:13:17.700
and then call save
on it, and it's

00:13:17.700 --> 00:13:19.408
going to go into some
database somewhere.

00:13:25.460 --> 00:13:28.909
So libraries and JavaScript
interoperability.

00:13:28.909 --> 00:13:30.825
So one thing you might
be wondering about Dart

00:13:30.825 --> 00:13:32.116
is, OK, it's this new language.

00:13:32.116 --> 00:13:35.354
It's running on the web, but can
I use all this JavaScript code

00:13:35.354 --> 00:13:36.520
that I already have written?

00:13:36.520 --> 00:13:38.450
And the answer is yes.

00:13:38.450 --> 00:13:41.140
It's actually relatively
straightforward.

00:13:41.140 --> 00:13:43.790
There is a Dart
library that allows you

00:13:43.790 --> 00:13:47.092
to proxy between JavaScript
objects and Dart objects,

00:13:47.092 --> 00:13:48.300
and pass them back and forth.

00:13:51.060 --> 00:13:52.610
So here's a little example.

00:13:52.610 --> 00:13:55.790
The Dart code up
here reads like this.

00:13:55.790 --> 00:14:01.610
So you get the chartsAPI out
of your JavaScript library.

00:14:01.610 --> 00:14:05.040
You create a new
JavaScript array,

00:14:05.040 --> 00:14:07.780
and then you create a
new chart by proxying it

00:14:07.780 --> 00:14:09.260
through the JS library.

00:14:09.260 --> 00:14:11.700
And then you just
call chart.draw.

00:14:11.700 --> 00:14:14.530
Now this is actual
JavaScript code

00:14:14.530 --> 00:14:16.570
if you were to be writing
JavaScript itself.

00:14:16.570 --> 00:14:19.410
You can see that it's
almost identical, aside

00:14:19.410 --> 00:14:23.410
from a few extra proxy steps
needed on the Dart side.

00:14:23.410 --> 00:14:26.160
So the point here is that
it's very straightforward

00:14:26.160 --> 00:14:28.180
to take all of the
legacy code that you've

00:14:28.180 --> 00:14:32.080
written in JavaScript, and carry
it with you into the new Dart

00:14:32.080 --> 00:14:32.580
land.

00:14:37.730 --> 00:14:39.740
So async with callbacks.

00:14:39.740 --> 00:14:42.870
We all know how many
callbacks we have,

00:14:42.870 --> 00:14:45.960
and they can be kind of scary.

00:14:45.960 --> 00:14:50.470
So if we have this catService
here, and we getCatData cute,

00:14:50.470 --> 00:14:51.980
and we get the
image ID, and then

00:14:51.980 --> 00:14:55.100
we rotate the image by
30 degrees-- I mean,

00:14:55.100 --> 00:14:57.740
we're four levels deep with
all this nesting and different

00:14:57.740 --> 00:15:00.887
callbacks and so on.

00:15:00.887 --> 00:15:02.970
But then you've got to do
all this error handling.

00:15:02.970 --> 00:15:06.030
Like what if any one of these
single steps has gone wrong?

00:15:09.204 --> 00:15:11.500
You're just repeating
a lot of code here.

00:15:11.500 --> 00:15:14.850
So Dart has the
concept of futures,

00:15:14.850 --> 00:15:18.217
and you can do a
catService getCat,

00:15:18.217 --> 00:15:19.300
and that returns a future.

00:15:19.300 --> 00:15:22.300
And then you can just do dot
then and do the next step,

00:15:22.300 --> 00:15:23.750
and dot then and
do the next step,

00:15:23.750 --> 00:15:25.840
and then dot then
and do the next step.

00:15:25.840 --> 00:15:28.710
And the catchError at the end
kind of handles all of them.

00:15:28.710 --> 00:15:30.960
So if any one of
these steps fails,

00:15:30.960 --> 00:15:33.180
the error case is
going to be executed

00:15:33.180 --> 00:15:36.320
at the bottom of the chain here.

00:15:36.320 --> 00:15:39.580
So you can actually compose
futures, which is quite nice.

00:15:39.580 --> 00:15:42.260
So if you want to get
two different cats,

00:15:42.260 --> 00:15:47.490
but you want to do all the logic
only once you have both cats,

00:15:47.490 --> 00:15:50.350
you can do this-- you
get two futures back,

00:15:50.350 --> 00:15:53.630
and then you call a
future.wait, and pass

00:15:53.630 --> 00:15:54.860
in the list of both of them.

00:15:54.860 --> 00:15:58.470
And then when that
future will complete,

00:15:58.470 --> 00:16:01.650
when they're both completed.

00:16:01.650 --> 00:16:04.400
And if any one of
them has an error,

00:16:04.400 --> 00:16:07.790
the catchError will
fire at the end.

00:16:07.790 --> 00:16:11.320
So asynchronous with
futures-- it's little bit

00:16:11.320 --> 00:16:17.260
better than a fiery
housescape that we saw before.

00:16:17.260 --> 00:16:19.140
So the streams-- this
is another concept

00:16:19.140 --> 00:16:23.170
that is baked into the
core libraries of Dart.

00:16:23.170 --> 00:16:26.770
So all of these things
like futures and streams

00:16:26.770 --> 00:16:28.850
are not extra
libraries that you go,

00:16:28.850 --> 00:16:31.120
and you download, and
you put into your site.

00:16:31.120 --> 00:16:34.000
This is part of the
language and the base SDK.

00:16:34.000 --> 00:16:36.900
So we're all starting
from a much higher place

00:16:36.900 --> 00:16:40.810
than starting from
the blank slate.

00:16:40.810 --> 00:16:43.520
So streams are a series
of asynchronous events.

00:16:43.520 --> 00:16:46.830
A future is an isolated
asynchronous event.

00:16:46.830 --> 00:16:48.572
A stream is a series of them.

00:16:48.572 --> 00:16:50.155
So you can think of
streams like bytes

00:16:50.155 --> 00:16:53.050
from a file, your messages
from a web socket,

00:16:53.050 --> 00:16:55.950
button clicks,
incoming connections.

00:16:55.950 --> 00:17:00.650
And basically, all you have
to do to consume things

00:17:00.650 --> 00:17:02.480
from a stream is
just this single line

00:17:02.480 --> 00:17:05.230
of code at the bottom here,
which is stream.listen.

00:17:05.230 --> 00:17:08.640
You're given whatever the
asynchronous event is.

00:17:08.640 --> 00:17:11.746
You do something with it.

00:17:11.746 --> 00:17:12.829
So let's take a look here.

00:17:12.829 --> 00:17:18.780
We have on Element, and there
is a stream for key presses.

00:17:18.780 --> 00:17:21.270
Right, so query the DOM.

00:17:21.270 --> 00:17:24.190
This is another
nice thing-- query

00:17:24.190 --> 00:17:26.650
is just baked in to
the platform like this.

00:17:26.650 --> 00:17:30.690
So you have query for
textarea, and then onKeyPress

00:17:30.690 --> 00:17:35.590
where the keys are
between 32 and 122.

00:17:35.590 --> 00:17:40.770
Map the character code
to a string first.

00:17:40.770 --> 00:17:44.230
Right, so this is just going
to first returns the very

00:17:44.230 --> 00:17:45.490
first key press.

00:17:45.490 --> 00:17:45.990
That's it.

00:17:48.520 --> 00:17:51.250
Then print the first character
pressed on the keyboard

00:17:51.250 --> 00:17:53.280
is equal to that character.

00:17:56.360 --> 00:18:01.160
So web programming with Dart
kind of looks like this.

00:18:01.160 --> 00:18:05.464
So you have window.navigator,
getUserMedia,

00:18:05.464 --> 00:18:06.380
get the video element.

00:18:06.380 --> 00:18:09.450
You can see the dot dot
syntax, the listen, catchError.

00:18:13.550 --> 00:18:16.270
XHR requests with
Dart look like this.

00:18:16.270 --> 00:18:18.660
It's very straightforward.

00:18:18.660 --> 00:18:21.300
Again, you can see how easy
it is to kind of compose

00:18:21.300 --> 00:18:26.400
all of the stock Dart
SDK features together

00:18:26.400 --> 00:18:31.720
into some really
tight-looking code.

00:18:31.720 --> 00:18:34.860
So we have event source
mapping, which is kind of cool.

00:18:34.860 --> 00:18:39.020
Like so if you have document
body onClick matches thread.

00:18:39.020 --> 00:18:42.350
So listen, and then
print super cool, right?

00:18:42.350 --> 00:18:47.920
So this will dynamically-- if
anything on the document that

00:18:47.920 --> 00:18:50.850
has the CSS class
thread gets clicked on,

00:18:50.850 --> 00:18:57.820
this is going to fire,
even if the element gets

00:18:57.820 --> 00:19:00.670
the class later on after
this code is executed,

00:19:00.670 --> 00:19:04.260
or is removed its dynamic,
it will just always respect

00:19:04.260 --> 00:19:09.220
whichever element has
the dot thread class.

00:19:09.220 --> 00:19:11.730
We also have automatic
sanitization.

00:19:11.730 --> 00:19:14.040
So if you want to
take some user input,

00:19:14.040 --> 00:19:16.970
and put it into the
inner HTML of an element,

00:19:16.970 --> 00:19:21.760
it's not possible for them
to insert a script tag,

00:19:21.760 --> 00:19:22.990
and run it in there.

00:19:22.990 --> 00:19:27.960
Dart actually will
make sure that anything

00:19:27.960 --> 00:19:29.880
that is potentially
a security exploit

00:19:29.880 --> 00:19:34.510
is removed when you
assigned the inner HTML.

00:19:34.510 --> 00:19:36.550
So web components--
we've been talking

00:19:36.550 --> 00:19:40.830
a lot about web components,
and Dart fully supports them.

00:19:40.830 --> 00:19:46.300
So this is the classic example
of how great components are.

00:19:46.300 --> 00:19:50.702
I mean, here is on the
left some variant of Gmail,

00:19:50.702 --> 00:19:52.910
and then on the right,
something that logically makes

00:19:52.910 --> 00:19:56.180
sense where you have messages,
and message with subject.

00:19:56.180 --> 00:19:58.100
I mean, these new
custom elements

00:19:58.100 --> 00:20:02.520
really allow you to make kind
of logical and semantic sense

00:20:02.520 --> 00:20:06.840
of the tags in your page, rather
than just div and table soup.

00:20:09.480 --> 00:20:12.190
There's encapsulation
with custom elements,

00:20:12.190 --> 00:20:14.350
so you have structure and
your behavior and styles

00:20:14.350 --> 00:20:17.990
can all be hidden inside
of these custom elements.

00:20:17.990 --> 00:20:20.010
And they're reusable.

00:20:20.010 --> 00:20:23.329
You can just import the library,
and import the HTML file

00:20:23.329 --> 00:20:24.870
for the custom
element, and there you

00:20:24.870 --> 00:20:27.800
go-- you've got your
own custom element.

00:20:27.800 --> 00:20:31.370
There's data bindings
between the DOM nodes.

00:20:31.370 --> 00:20:34.400
So polymer.dart kind of
fits in at the foundation

00:20:34.400 --> 00:20:35.280
and the core level.

00:20:40.470 --> 00:20:44.450
So size and speed-- one
of the goals of Dart--

00:20:44.450 --> 00:20:48.660
aside from speed-- is
that we support really

00:20:48.660 --> 00:20:51.350
large scale software
development.

00:20:51.350 --> 00:20:53.464
Because the language
is so structured,

00:20:53.464 --> 00:20:55.130
it's much easier to
make sense of what's

00:20:55.130 --> 00:20:57.410
going on in the
editor, actually allows

00:20:57.410 --> 00:20:59.270
you to hyperlink through
your source code,

00:20:59.270 --> 00:21:01.775
and get to different
functions, and pop around.

00:21:01.775 --> 00:21:04.530
It's quite nice.

00:21:04.530 --> 00:21:07.370
So by running
faster, you actually

00:21:07.370 --> 00:21:11.780
save battery, because when
you're executing your code,

00:21:11.780 --> 00:21:13.850
it takes fewer CPU cycles.

00:21:13.850 --> 00:21:16.350
So on mobile
devices and laptops,

00:21:16.350 --> 00:21:18.950
tablets, et cetera,
running faster actually

00:21:18.950 --> 00:21:22.670
will lead to longer battery
life, which is awesome.

00:21:22.670 --> 00:21:24.469
We all want that.

00:21:24.469 --> 00:21:26.510
So like I said at the
beginning, there's two ways

00:21:26.510 --> 00:21:27.680
to run Dart code, right?

00:21:27.680 --> 00:21:30.160
You can run Dart in the
Dart virtual machine,

00:21:30.160 --> 00:21:32.330
or you can compile
Dart to JavaScript.

00:21:32.330 --> 00:21:36.250
And the dart2js compiler
does a really fantastic job

00:21:36.250 --> 00:21:38.375
of compiling Dart
code down to JS.

00:21:40.990 --> 00:21:43.470
So if we look at
this snippet of code

00:21:43.470 --> 00:21:49.910
here where we have var Bob is
equal to new person Bob Smith,

00:21:49.910 --> 00:21:51.900
and then we query the
DOM for something,

00:21:51.900 --> 00:21:54.850
and then we set the
text of that DOM element

00:21:54.850 --> 00:22:01.052
to Bob's first name,
dart2js compiles a code,

00:22:01.052 --> 00:22:02.010
and it looks like this.

00:22:02.010 --> 00:22:04.880
I mean, it's practically
human readable.

00:22:04.880 --> 00:22:08.370
It's, a lot of the time, a
direct one-to-one mapping

00:22:08.370 --> 00:22:10.780
between Dart code
and JavaScript code.

00:22:15.160 --> 00:22:18.760
So you can also
get minified code.

00:22:18.760 --> 00:22:21.580
So at the top here,
we have by default

00:22:21.580 --> 00:22:24.340
what dart2js will generate.

00:22:24.340 --> 00:22:26.350
And then you can pass
in a flag that says,

00:22:26.350 --> 00:22:27.980
OK, compile this,
but also minify it,

00:22:27.980 --> 00:22:31.600
and it becomes illegible
like all minified code.

00:22:31.600 --> 00:22:33.740
But this, just again,
this helps you save space

00:22:33.740 --> 00:22:35.270
when compiling
Dart to JavaScript.

00:22:38.090 --> 00:22:40.610
So we also something
built in to the compiler

00:22:40.610 --> 00:22:43.140
called tree shaking.

00:22:43.140 --> 00:22:45.700
And because Dart
is so structured,

00:22:45.700 --> 00:22:49.040
we can actually reason about
what pieces of code are used,

00:22:49.040 --> 00:22:51.630
and which pieces of
code are not used.

00:22:51.630 --> 00:22:54.960
So even if you import
many, many libraries,

00:22:54.960 --> 00:22:58.690
but you only call few
functions, the dart2js compiler

00:22:58.690 --> 00:23:02.310
has this phase called tree
shaking, which you just

00:23:02.310 --> 00:23:04.832
shake the tree and, all
the stuff falls off of it

00:23:04.832 --> 00:23:06.040
that you don't actually need.

00:23:06.040 --> 00:23:09.380
And you end up with this really
minimal code right here, which

00:23:09.380 --> 00:23:13.390
is that main calls
func2, which calls funcx.

00:23:13.390 --> 00:23:15.320
funcy and func1
are never invoked,

00:23:15.320 --> 00:23:20.600
so they're not included
in the dart2js output.

00:23:20.600 --> 00:23:25.740
The Dart VM-- this is the
project that I work on.

00:23:25.740 --> 00:23:29.730
Because Dart is such
strict language,

00:23:29.730 --> 00:23:32.230
this actually allows
the virtual machine

00:23:32.230 --> 00:23:36.599
to run faster than any
JavaScript virtual machine can.

00:23:36.599 --> 00:23:38.140
We went over it a
little bit earlier.

00:23:38.140 --> 00:23:41.050
Like, there's real arrays,
there's real classes,

00:23:41.050 --> 00:23:42.660
there's directs calls.

00:23:42.660 --> 00:23:44.870
There's no, like, walk
up the prototype chain,

00:23:44.870 --> 00:23:48.030
find the first object that
can respond to a method,

00:23:48.030 --> 00:23:50.570
and invoke it.

00:23:50.570 --> 00:23:52.990
The VM will actually
globally track field type.

00:23:52.990 --> 00:23:58.590
So if you have class person,
and it has a field called name.

00:23:58.590 --> 00:24:01.830
If name is always a string, then
we know it's a string always.

00:24:01.830 --> 00:24:03.420
And the VM will
track this, and you

00:24:03.420 --> 00:24:05.590
can actually-- when
this was enabled,

00:24:05.590 --> 00:24:07.710
we saw kind of
across the board 20%

00:24:07.710 --> 00:24:11.470
speed up just from
this one optimization.

00:24:11.470 --> 00:24:14.300
So one thing that I actually
personally worked on

00:24:14.300 --> 00:24:17.850
was bringing SIMD
to the Dart VM,

00:24:17.850 --> 00:24:20.630
and to the web for
the first time.

00:24:20.630 --> 00:24:26.470
So this is the CPU die a
dual core ARM processor.

00:24:26.470 --> 00:24:31.540
So you can see that the kind of
bluish core area there, that's

00:24:31.540 --> 00:24:34.450
like where your integer
arithmetic, your just

00:24:34.450 --> 00:24:37.740
general CPU computation occurs.

00:24:37.740 --> 00:24:39.930
And then, you can
see VFP, that's

00:24:39.930 --> 00:24:43.350
where your floating point,
your double precision numbers

00:24:43.350 --> 00:24:44.870
are being executed.

00:24:44.870 --> 00:24:46.860
And then we have this
red area here, Neon.

00:24:46.860 --> 00:24:51.890
And this is where the SIMD
portion of the CPU is devoted.

00:24:51.890 --> 00:24:53.540
So if you look at
how much silicon

00:24:53.540 --> 00:24:59.150
is devoted on every CPU-- and
in your laptops and tablets,

00:24:59.150 --> 00:25:02.460
there's a ton of silicon devoted
to the SIMD processing, which

00:25:02.460 --> 00:25:06.650
up until the Dart VM
added support for SIMD,

00:25:06.650 --> 00:25:08.300
it was impossible to tap into.

00:25:08.300 --> 00:25:11.420
So you're looking at
maybe 20% of the surface

00:25:11.420 --> 00:25:13.666
area of your CPU is
just sitting there idle.

00:25:13.666 --> 00:25:15.550
You cannot access
that or program it,

00:25:15.550 --> 00:25:19.210
and there's huge performance
gains to be had from being able

00:25:19.210 --> 00:25:22.140
to tap into this.

00:25:22.140 --> 00:25:25.580
Let me just show you a
demo here to give you

00:25:25.580 --> 00:25:27.990
an idea of what's
possible, especially

00:25:27.990 --> 00:25:32.310
when it comes to three
games when SIMD is enabled.

00:25:32.310 --> 00:25:34.800
So what you're seeing here
is a bunch of monsters

00:25:34.800 --> 00:25:38.000
from Doom just kind of
standing around, animating,

00:25:38.000 --> 00:25:39.380
doing whatever.

00:25:39.380 --> 00:25:41.180
And this application
is attempting

00:25:41.180 --> 00:25:47.420
to keep as many monsters
on the screen as possible,

00:25:47.420 --> 00:25:49.379
and still run at 60
frames per second.

00:25:49.379 --> 00:25:51.420
So there's just this
adaptive algorithm in there.

00:25:51.420 --> 00:25:55.630
That's why you see them kind
of popping in and popping out.

00:25:55.630 --> 00:25:57.920
We're trying to
keep it about 60.

00:25:57.920 --> 00:25:59.340
So right now, SIMD is off.

00:25:59.340 --> 00:26:08.750
But if I turn on SIMD,
this is a massive speedup.

00:26:08.750 --> 00:26:11.110
I mean, we were
at like about 13,

00:26:11.110 --> 00:26:16.200
and now we're in the
high 60s, low 70s.

00:26:16.200 --> 00:26:18.210
This is because the
Dart VM actually

00:26:18.210 --> 00:26:20.520
lets you tap into that
huge amount of silicon

00:26:20.520 --> 00:26:24.720
on your CPU that's specially
designed to accelerate things

00:26:24.720 --> 00:26:27.870
like image processing
and 3D graphics.

00:26:36.485 --> 00:26:38.360
So I've been talking
about performance a lot,

00:26:38.360 --> 00:26:41.090
and we have some publicly
tracked benchmarks.

00:26:41.090 --> 00:26:43.664
So internally,
during my games talk,

00:26:43.664 --> 00:26:45.830
I talked about how we have
this infrastructure where

00:26:45.830 --> 00:26:49.610
we track the
performance across all

00:26:49.610 --> 00:26:52.600
of these benchmarks on
every single commit.

00:26:52.600 --> 00:26:55.720
And so, these are current
numbers right now.

00:26:55.720 --> 00:27:04.430
The green numbers are-- OK,
so first of all, the y-axis,

00:27:04.430 --> 00:27:05.900
higher is better.

00:27:05.900 --> 00:27:08.410
You're running faster
the higher the bar is.

00:27:10.970 --> 00:27:12.842
Green is dart2js.

00:27:12.842 --> 00:27:14.300
So we take the Dart
code, we run it

00:27:14.300 --> 00:27:15.920
through the dart2js
compiler, and then

00:27:15.920 --> 00:27:18.940
we execute it inside Chrome.

00:27:18.940 --> 00:27:21.670
Yellow is handwritten
JavaScript.

00:27:21.670 --> 00:27:24.310
So some human went out and
wrote the same algorithm

00:27:24.310 --> 00:27:26.320
in JavaScript that's
run in Chrome.

00:27:26.320 --> 00:27:30.410
The blue bar here
represents the performance

00:27:30.410 --> 00:27:33.120
when running under the Dart VM.

00:27:33.120 --> 00:27:36.830
So you can see
for DeltaBlue, you

00:27:36.830 --> 00:27:40.220
can see that dart2js
actually greatly outperforms

00:27:40.220 --> 00:27:43.130
handwritten JavaScript.

00:27:43.130 --> 00:27:45.910
And the Dart VM just
destroys all of them.

00:27:45.910 --> 00:27:48.420
I mean, it's ridiculously fast.

00:27:48.420 --> 00:27:51.740
Richard's dart2js-- so
for Richards and Tracers

00:27:51.740 --> 00:27:56.580
dart2js does not do as well
as handwritten JavaScript,

00:27:56.580 --> 00:27:58.580
but it does a respectable job.

00:27:58.580 --> 00:28:00.820
And then again, you can see
how much faster the Dart

00:28:00.820 --> 00:28:05.150
VM is compared to a JavaScript.

00:28:05.150 --> 00:28:09.830
And with the Tracer, which
is ray-tracing benchmark,

00:28:09.830 --> 00:28:14.115
we're 2.3 times faster than
handwritten JavaScript.

00:28:16.750 --> 00:28:21.740
So we also have an NBody, which
is a solar system simulator.

00:28:21.740 --> 00:28:24.000
This is another
benchmark that we track.

00:28:24.000 --> 00:28:28.060
And this is performance numbers
in Chrome Mobile, so on an ARM

00:28:28.060 --> 00:28:33.080
device-- your cell phone running
Chrome with a Dart VM baked

00:28:33.080 --> 00:28:34.860
into it.

00:28:34.860 --> 00:28:38.840
So we have a handwritten
JavaScript-- yellow here--

00:28:38.840 --> 00:28:42.930
and then the light blue
is just the Dart VM.

00:28:42.930 --> 00:28:46.540
And we're 1.48 times faster.

00:28:46.540 --> 00:28:49.440
You can also port
the NBody benchmark

00:28:49.440 --> 00:28:52.760
to take advantage of the
SIMD support in Dart.

00:28:52.760 --> 00:28:56.970
And when you do that,
Dart is 2.42 times faster

00:28:56.970 --> 00:29:01.210
than handwritten JavaScript.

00:29:01.210 --> 00:29:05.560
So Dart is an extremely
structured, kind

00:29:05.560 --> 00:29:11.180
of sane language that,
when run under the Dart VM,

00:29:11.180 --> 00:29:16.450
can run at least twice as
fast as JavaScript can.

00:29:19.020 --> 00:29:21.130
But we really haven't
scratched the surface.

00:29:21.130 --> 00:29:23.150
There's so much more
to Dart that we just

00:29:23.150 --> 00:29:27.030
don't have time to go
into in this presentation.

00:29:27.030 --> 00:29:30.100
Dart has great support
for reflection.

00:29:30.100 --> 00:29:31.792
So you could do
things like I want

00:29:31.792 --> 00:29:34.000
to iterate over all the
libraries that were imported,

00:29:34.000 --> 00:29:40.100
or find a class that responds
to this method, and call it.

00:29:40.100 --> 00:29:41.080
There's server-side.

00:29:41.080 --> 00:29:45.150
So you all, I'm sure, are
familiar with Node.js,

00:29:45.150 --> 00:29:47.090
which runs V8.

00:29:47.090 --> 00:29:51.070
So Dart from the get go
has supported the model

00:29:51.070 --> 00:29:54.060
of running Dart code on both
the server and the client.

00:29:54.060 --> 00:30:00.740
And this really makes code
reuse really straightforward.

00:30:00.740 --> 00:30:02.570
You have a bunch
of libraries which

00:30:02.570 --> 00:30:05.990
describe the kind of structures
that your application

00:30:05.990 --> 00:30:06.630
deals with.

00:30:06.630 --> 00:30:09.570
And you can share those
on the server side,

00:30:09.570 --> 00:30:12.380
and on the client side.

00:30:12.380 --> 00:30:15.240
The pub package manager,
which I mentioned earlier,

00:30:15.240 --> 00:30:18.560
which is just like an
integral part of the platform.

00:30:18.560 --> 00:30:20.170
We have the editor.

00:30:20.170 --> 00:30:24.210
There's built-in support
for unit testing, isolates

00:30:24.210 --> 00:30:24.960
for concurrency.

00:30:24.960 --> 00:30:27.650
So isolates are kind
of like web workers

00:30:27.650 --> 00:30:31.010
where you can farm off work
onto a separate thread,

00:30:31.010 --> 00:30:34.920
and pass messages
back and forth.

00:30:34.920 --> 00:30:37.770
So I really want to encourage
you all to go out and try Dart.

00:30:37.770 --> 00:30:41.310
It's a really exciting language.

00:30:41.310 --> 00:30:43.800
I have a hard time
going back to JavaScript

00:30:43.800 --> 00:30:46.085
after I've gotten used
to writing in Dart.

00:30:48.700 --> 00:30:51.290
And we have a Dartisans
community on G+.

00:30:51.290 --> 00:30:53.890
And you can send poll
requests on Github.

00:30:53.890 --> 00:30:56.360
Dart is entirely open source.

00:30:56.360 --> 00:31:00.080
The VM, the dart2js compiler,
all of the libraries--

00:31:00.080 --> 00:31:02.700
everything with
Dart is open source.

00:31:02.700 --> 00:31:05.980
We actually have active
external contributors

00:31:05.980 --> 00:31:07.780
who are not Google employees.

00:31:07.780 --> 00:31:10.070
And I would
encourage anyone here

00:31:10.070 --> 00:31:12.320
who is interested
in participating

00:31:12.320 --> 00:31:15.210
to join these communities,
get on the mailing list,

00:31:15.210 --> 00:31:19.120
start looking at the code,
and feel free to ask questions

00:31:19.120 --> 00:31:20.060
on Stack Overflow.

00:31:20.060 --> 00:31:23.740
We have a lot of people
that participate there.

00:31:23.740 --> 00:31:27.480
So Dart is a stable language,
has stable core libraries,

00:31:27.480 --> 00:31:29.500
compiles to JavaScript.

00:31:29.500 --> 00:31:34.490
It's relatively evolved compared
to where the web is today.

00:31:34.490 --> 00:31:36.140
And we're really
committed to Dart,

00:31:36.140 --> 00:31:38.140
and we really want it
to be a huge success.

00:31:42.750 --> 00:31:43.440
Thanks.

00:31:43.440 --> 00:31:53.180
[APPLAUSE]

00:31:53.180 --> 00:31:55.874
JOHN MCCUTCHAN: I
can take questions.

00:31:55.874 --> 00:31:56.790
AUDIENCE: [INAUDIBLE]?

00:32:29.238 --> 00:32:30.654
AUDIENCE: So here's
two questions.

00:32:30.654 --> 00:32:35.090
One is, when will the Dart VM be
merged into Chromium or Chrome?

00:32:35.090 --> 00:32:41.770
And the other one is,
what's the opinion

00:32:41.770 --> 00:32:44.740
about Dart from other
browsers' vendors?

00:32:44.740 --> 00:32:47.710
And how are you going
collaborate with that?

00:32:50.680 --> 00:32:53.240
JOHN MCCUTCHAN: Sure.

00:32:53.240 --> 00:32:56.870
We do not have a timeline
for when the Dart

00:32:56.870 --> 00:32:59.030
VM will be included in Chrome.

00:32:59.030 --> 00:33:01.670
But if you download
the Dart Editor,

00:33:01.670 --> 00:33:04.720
it comes with a custom version
of Chrome with a Dart VM baked

00:33:04.720 --> 00:33:05.650
into it.

00:33:05.650 --> 00:33:08.870
That's what I was running
the monsters demo running on.

00:33:08.870 --> 00:33:13.200
So during your development,
you can iterate very quickly

00:33:13.200 --> 00:33:16.550
inside what we're Dartium.

00:33:16.550 --> 00:33:19.890
And in terms of collaboration
with other browser vendors,

00:33:19.890 --> 00:33:22.410
we are an entirely
open source project,

00:33:22.410 --> 00:33:28.100
and we openly-- if another
browser vendor wanted

00:33:28.100 --> 00:33:31.040
to work with us and incorporate
the VM into their browser,

00:33:31.040 --> 00:33:32.230
we would love it.

00:33:32.230 --> 00:33:35.387
There would be absolutely
no issue with that.

00:33:35.387 --> 00:33:37.720
But again, I just want to
stress that Dart compiles down

00:33:37.720 --> 00:33:41.380
to very clean, very
performant JavaScript code.

00:33:41.380 --> 00:33:44.150
So in some sense,
it's irrelevant

00:33:44.150 --> 00:33:48.490
if other browser vendors do not
include the virtual machine,

00:33:48.490 --> 00:33:51.640
because Dart code
compiled to JavaScript

00:33:51.640 --> 00:33:56.300
executes very quickly,
in which case,

00:33:56.300 --> 00:33:58.070
it's going to run everywhere.

00:33:58.070 --> 00:34:00.000
When you deploy a
Dart application,

00:34:00.000 --> 00:34:02.480
you're not just deploying
the Dart source code.

00:34:02.480 --> 00:34:06.750
You're also deploying the
dart2js source code, as well.

00:34:06.750 --> 00:34:10.870
And if your browser happens
to support the Dart VM,

00:34:10.870 --> 00:34:14.090
you'll get something that
runs significantly faster.

00:34:14.090 --> 00:34:15.570
If it doesn't,
you'll get something

00:34:15.570 --> 00:34:16.903
that runs as fast as JavaScript.

00:34:20.013 --> 00:34:20.679
Other questions?

00:34:23.540 --> 00:34:25.790
AUDIENCE: I know
Dart is providing

00:34:25.790 --> 00:34:28.870
compiler source for me.

00:34:28.870 --> 00:34:31.570
In case that my
[INAUDIBLE] needed

00:34:31.570 --> 00:34:34.432
to be protected from
accessing all users.

00:34:34.432 --> 00:34:37.186
Does Google have
any official plan

00:34:37.186 --> 00:34:42.330
for supporting encryption
or [INAUDIBLE]?

00:34:42.330 --> 00:34:44.600
JOHN MCCUTCHAN: Not
that I'm aware of.

00:34:44.600 --> 00:34:46.670
I mean, it's the web.

00:34:46.670 --> 00:34:49.381
Source code's out there.

00:34:49.381 --> 00:34:51.880
AUDIENCE: But not on VM, right?

00:34:51.880 --> 00:34:54.105
JOHN MCCUTCHAN: Sorry?

00:34:54.105 --> 00:34:56.836
AUDIENCE: Our source code
is running on VM, right?

00:34:56.836 --> 00:35:04.200
So why does Google
support [INAUDIBLE].

00:35:04.200 --> 00:35:06.000
JOHN MCCUTCHAN:
Yeah, I don't know.

00:35:06.000 --> 00:35:09.400
I mean, in some sense,
that's kind of on a tangent,

00:35:09.400 --> 00:35:11.000
and not directly
related to Dart.

00:35:11.000 --> 00:35:15.280
I mean, maybe you want to
encrypt your JavaScript source

00:35:15.280 --> 00:35:19.950
code, and have all JavaScript
engines know how to decrypt it.

00:35:19.950 --> 00:35:22.530
But I don't know.

00:35:22.530 --> 00:35:25.222
It's certainly not something
we're working on right now.

00:35:25.222 --> 00:35:28.966
AUDIENCE: It is an official?

00:35:28.966 --> 00:35:31.967
It is official opinion?

00:35:31.967 --> 00:35:33.300
JOHN MCCUTCHAN: It's my opinion.

00:35:37.593 --> 00:35:39.510
AUDIENCE: All right, thank you.

00:35:39.510 --> 00:35:40.843
JOHN MCCUTCHAN: Other questions?

00:35:44.100 --> 00:35:45.890
All right, thanks everyone.

00:35:45.890 --> 00:36:00.151
[APPLAUSE]

