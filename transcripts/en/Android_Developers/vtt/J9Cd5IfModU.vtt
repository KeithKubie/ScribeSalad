WEBVTT
Kind: captions
Language: en

00:00:05.029 --> 00:00:13.400
&gt;&gt;Ankur Kotwal: Welcome everyone to the Android
Developer Lab.

00:00:13.400 --> 00:00:18.320
This is the first episode of the Android Developer
Lab plus.

00:00:18.320 --> 00:00:21.070
And we're really excited to be launching it.

00:00:21.070 --> 00:00:25.620
So this is a revamp of what we used to have
called Office Hours, and it just basically

00:00:25.620 --> 00:00:28.020
expands on that show.

00:00:28.020 --> 00:00:30.860
So let me start off by introducing the team.

00:00:30.860 --> 00:00:33.910
&gt;&gt;Anirudh Dewani: I will first here.

00:00:33.910 --> 00:00:41.559
Hi guys, I'm Anirudh Dewani and I'm based
out of the Hyderabad office in India.

00:00:41.559 --> 00:00:46.499
&gt;&gt;Tony Chan: I'm Tony Chan and I am based
out of Hong Kong.

00:00:46.499 --> 00:00:52.620
&gt;&gt;Ankur Kotwal: And I'm Ankur Kotwal and I'm
based out of Sydney, Australia.

00:00:52.620 --> 00:00:58.940
So, we're really glad to have everyone joining
us today.

00:00:58.940 --> 00:01:03.510
We are just getting the show started, so just
give us a few minutes.

00:01:03.510 --> 00:01:10.579
We are just making sure that people online
are able to join our link.

00:01:10.579 --> 00:01:18.030
And as soon as we've got that up, we should
be right to go.

00:01:18.030 --> 00:01:23.340
So in the meanwhile, Tony do you want to give
us an update on some of the questions we had

00:01:23.340 --> 00:01:25.620
last week to do with low level media?

00:01:25.620 --> 00:01:28.240
&gt;&gt;Tony Chan: Yes, sure.

00:01:28.240 --> 00:01:34.750
So let me pull the question up.

00:01:34.750 --> 00:01:40.409
So basically there are two questions we got,
we left unanswered last week.

00:01:40.409 --> 00:01:45.200
So we're trying to find the answer, here you
go.

00:01:45.200 --> 00:01:53.009
So the first one is "Can the [indistinct]
StageFright classes be used in the JNI code

00:01:53.009 --> 00:01:54.009
somehow?

00:01:54.009 --> 00:01:58.840
JNI versus Android source tree incompatibility
and stable native interface."

00:01:58.840 --> 00:02:03.020
So basically the answer is yeah, why not.

00:02:03.020 --> 00:02:11.842
And you can certainly do that but one thing
you need to pay attention is for, if you are

00:02:11.842 --> 00:02:19.209
using the native interface there is no guarantee
those interface will not change.

00:02:19.209 --> 00:02:28.870
So when you go for that approach make sure
you pay attention to our source tree changes

00:02:28.870 --> 00:02:31.540
and make sure that it's not broken.

00:02:31.540 --> 00:02:34.440
So that's the caveat.

00:02:34.440 --> 00:02:40.340
So another question we left unanswered last
week was "Is there any supported way to stream

00:02:40.340 --> 00:02:42.750
live video and audio?"

00:02:42.750 --> 00:02:46.150
So I think last week we forgot to mention
something.

00:02:46.150 --> 00:03:00.220
We do have http live stream support in Honeycomb
and plus devices, so also prior to Honeycomb

00:03:00.220 --> 00:03:07.660
there are some public commercial solution
as well for live streaming and we have seen

00:03:07.660 --> 00:03:14.069
developer done that, written their own solution
before on our end before.

00:03:14.069 --> 00:03:16.870
So it's pretty doable.

00:03:16.870 --> 00:03:23.820
So I guess that’s pretty much addressed
by some of the unanswered question last week.

00:03:23.820 --> 00:03:26.099
&gt;&gt; Ankur Kotwal: Thanks Tony.

00:03:26.099 --> 00:03:29.730
So what we're going to do today is a little
bit different.

00:03:29.730 --> 00:03:32.819
As I mentioned the format is changing.

00:03:32.819 --> 00:03:38.549
So let's get started, we're going to flick
over to our presentation right now.

00:03:38.549 --> 00:03:42.810
And here we go.

00:03:42.810 --> 00:03:47.620
So, first thing we'll just start off with
some news.

00:03:47.620 --> 00:03:52.720
These are just basically some of the events
that have happened in terms of the Android

00:03:52.720 --> 00:03:55.190
developer world over the last week.

00:03:55.190 --> 00:04:02.150
The first one is that we've launched preview
2 of the Android Developer Tools version 21.

00:04:02.150 --> 00:04:05.560
So this the upcoming version.

00:04:05.560 --> 00:04:11.060
Don't be too concerned if the, you are unable
to get the URL down or not, we’ll go and

00:04:11.060 --> 00:04:14.250
edit the YouTube video and put it in there.

00:04:14.250 --> 00:04:17.500
But certainly you can do a Google search for
this.

00:04:17.500 --> 00:04:24.639
The next one is that we, one of our team members
has put in, has released some sample code

00:04:24.639 --> 00:04:27.310
actually for some scrolling tricks.

00:04:27.310 --> 00:04:31.770
So let me just bring that up.

00:04:31.770 --> 00:04:41.840
So the ADT preview is up, Tor Norbye is one
of the engineers that works on the SDK tools

00:04:41.840 --> 00:04:47.180
and he's announced the availability of these
tools on his Plus page.

00:04:47.180 --> 00:04:52.949
Roman Nurik and Nick Butcher who are also
Android Developer Advocates, put together

00:04:52.949 --> 00:04:55.850
this great little sample app.

00:04:55.850 --> 00:05:00.980
There's some code there and you can just see
what it basically looks like.

00:05:00.980 --> 00:05:04.520
You'll notice that there are some scrolling
tricks that we've been implementing with our

00:05:04.520 --> 00:05:05.520
apps.

00:05:05.520 --> 00:05:09.430
So as they scroll down here you'll notice
that the little white bar disappears.

00:05:09.430 --> 00:05:12.780
But as soon as they pull down, the white bar
shows up again.

00:05:12.780 --> 00:05:17.000
So it's kind of like a floating or docked
bar across the top, but there's a sticky version

00:05:17.000 --> 00:05:18.410
of it as well.

00:05:18.410 --> 00:05:25.360
So, it's a really nice source code there so
you can see if it's worth implementing or

00:05:25.360 --> 00:05:27.860
something that you consider to be useful for
your apps.

00:05:27.860 --> 00:05:32.030
We use it in the Google play client actually.

00:05:32.030 --> 00:05:35.580
Another one is what we call the pinhole progress.

00:05:35.580 --> 00:05:44.460
So it's something that we sort of introduced
in the Google movies client and you'll notice

00:05:44.460 --> 00:05:46.729
as your, as well as books actually.

00:05:46.729 --> 00:05:51.190
So as you're downloading content you get this
little pin which is what you toggle to say

00:05:51.190 --> 00:05:53.030
whether it downloaded or not.

00:05:53.030 --> 00:05:55.150
And the progress bar starts to fill up.

00:05:55.150 --> 00:06:03.270
So Roman, again, put together some great sample
code and you can go and grab it from the URL

00:06:03.270 --> 00:06:05.410
that's just displayed here as well.

00:06:05.410 --> 00:06:07.480
It’s just a shortened version.

00:06:07.480 --> 00:06:11.870
Or you can just follow Roman on Google Plus.

00:06:11.870 --> 00:06:16.449
So with that being said that's pretty much
the biggest things that have happened from

00:06:16.449 --> 00:06:19.900
our side of the Android Developer ecosystem.

00:06:19.900 --> 00:06:26.100
I know there's been plenty of things in the
community side.

00:06:26.100 --> 00:06:29.600
The other thing we're going to do today that's
a bit different is that we're going to have

00:06:29.600 --> 00:06:31.190
a message from our sponsor.

00:06:31.190 --> 00:06:35.050
And our sponsor this week is the Android Manifest
File.

00:06:35.050 --> 00:06:41.169
So we thought we'd share some pro-tips with
you guys because there has been some confusion

00:06:41.169 --> 00:06:45.030
in the past and ways to really optimize your
development.

00:06:45.030 --> 00:06:47.870
So we thought we'd share those with you.

00:06:47.870 --> 00:06:51.770
We’re gonna start off by talking about uses
SDK.

00:06:51.770 --> 00:06:56.620
So uses SDK is a tag that you'd have in your
manifest file and there's a couple attributes

00:06:56.620 --> 00:06:59.020
on there that are quite important.

00:06:59.020 --> 00:07:05.150
And they can really make some dramatic impacts
to you apps compatibility and availability

00:07:05.150 --> 00:07:06.150
on Google Play.

00:07:06.150 --> 00:07:08.010
So let's get started.

00:07:08.010 --> 00:07:14.110
The first one is the minimum SDK version or
we state it as min SDK Version.

00:07:14.110 --> 00:07:23.590
So what it is, it basically tells the device
that this app needs a minimum version of this

00:07:23.590 --> 00:07:26.819
API level to be able to run.

00:07:26.819 --> 00:07:32.919
Now when you specify the minimum SDK version
in your manifest file, it is up to you as

00:07:32.919 --> 00:07:40.050
the developer to ensure that you're not calling
APIs that are not supported in that SDK version.

00:07:40.050 --> 00:07:46.440
Or if you are, you're putting version gates
around them so you're checking that that particular

00:07:46.440 --> 00:07:49.900
API is available on that version of the platform.

00:07:49.900 --> 00:07:54.280
Now the good thing is that once you start
using the SDK version, if you're using a more

00:07:54.280 --> 00:07:58.170
recent version of the Android developer tools
we added lint support.

00:07:58.170 --> 00:08:05.789
So lint is a compile time check, that goes
and sees if you're doing anything not quite

00:08:05.789 --> 00:08:07.610
right with your source code.

00:08:07.610 --> 00:08:13.720
This is an example where what it'll do, it'll
actually check what the minimum SDK version

00:08:13.720 --> 00:08:18.080
that has been specified in your manifest is
and to see whether you're calling any particular

00:08:18.080 --> 00:08:20.750
APIs that are not supported in that minimum
SDK version.

00:08:20.750 --> 00:08:27.590
So it's a really nice handy tool and those
warnings should definitely be actioned.

00:08:27.590 --> 00:08:33.010
The thing about the minimum SDK version is
that when a user goes to install an APK, so

00:08:33.010 --> 00:08:39.160
let's say you're side loading an app, the
operating system will actually check whether

00:08:39.160 --> 00:08:45.630
it is a version that’s higher than, or greater
than or equal to the minimum SDK version.

00:08:45.630 --> 00:08:48.490
So the operating system itself will confirm
that.

00:08:48.490 --> 00:08:53.400
Google Play also does this, so if there's,
if you're running on let's say a Gingerbread

00:08:53.400 --> 00:09:01.100
device and a minimum SDK has been set to Honeycomb,
if you search for that app on Google Play

00:09:01.100 --> 00:09:06.290
on your Gingerbread device, Play won't actually
show that app.

00:09:06.290 --> 00:09:10.660
Actually if you go to the web version of Google
Play, when you sign in, you search for that

00:09:10.660 --> 00:09:14.980
particular app, you'll notice that when you
try to install the app through the web version

00:09:14.980 --> 00:09:20.220
there's a way you can choose which device
you want it to install to, it won't actually

00:09:20.220 --> 00:09:24.420
present devices that are below that minimum
SDK version.

00:09:24.420 --> 00:09:30.800
So by default the value that’s' there, it's
an implicit value that defaults to 1, which

00:09:30.800 --> 00:09:36.610
mean it supports every version of Android,
but we always in terms of best practices,

00:09:36.610 --> 00:09:41.340
we recommend that you explicitly specify the
minimum SDK version.

00:09:41.340 --> 00:09:45.510
And it's also a way for you to make sure that
you're targeting the right set of users.

00:09:45.510 --> 00:09:52.790
If you have a very media heavy app for example,
or an app that, you know, requires a certain

00:09:52.790 --> 00:09:58.250
level of device, minimum SDK is one way to
do it.

00:09:58.250 --> 00:10:02.570
One way to check, to ensure that it doesn't
get installed on the wrong device.

00:10:02.570 --> 00:10:08.410
So, please, you know, go in and explicitly
specify minimum SDK.

00:10:08.410 --> 00:10:11.710
You might be looking at that and saying, well
it's not there by default so why do I need

00:10:11.710 --> 00:10:12.710
it?

00:10:12.710 --> 00:10:17.110
Well, the next bit of useful information is
the target SDK.

00:10:17.110 --> 00:10:23.750
The target SDK is basically saying to , well
you're saying by specifying a target SDK that

00:10:23.750 --> 00:10:28.970
this particular app is guaranteed to run on
a particular API level.

00:10:28.970 --> 00:10:34.600
And the reason that you should be stating
it is that it actually enables a whole bunch

00:10:34.600 --> 00:10:36.530
of features in the background.

00:10:36.530 --> 00:10:40.730
So what we recommend, and we're going to talk
about what some of those features are, what

00:10:40.730 --> 00:10:45.530
recommend in terms of our best practices is
that you should always set your target SDK

00:10:45.530 --> 00:10:48.980
version in your app to be latest version of
Android.

00:10:48.980 --> 00:10:50.040
OK?

00:10:50.040 --> 00:10:56.130
Just because you set it to, let's say 15,
API level 15, if you try to install it on,

00:10:56.130 --> 00:11:03.260
let's say a Gingerbread device which is API
level 9, it's not going to actually prevent

00:11:03.260 --> 00:11:05.320
it from running.

00:11:05.320 --> 00:11:10.270
What it will do is that it will default back
to the API level 9 behavior on those API level

00:11:10.270 --> 00:11:12.270
9 devices.

00:11:12.270 --> 00:11:16.870
And this is where minimum SDK helps, because
what you do is you use the minimum SDK to

00:11:16.870 --> 00:11:21.571
specify what's the lowest version or oldest
version of Android that you can run and you

00:11:21.571 --> 00:11:26.380
use target SDK to specify the one that you're
really targeting.

00:11:26.380 --> 00:11:30.300
Now remember earlier I said that there'd be
some features that it enables.

00:11:30.300 --> 00:11:33.440
So let's talk about some of those.

00:11:33.440 --> 00:11:38.500
If you target API level 11 or greater, you
actually get some nice benefits.

00:11:38.500 --> 00:11:41.460
It enables the Holo theme for example, in
your app.

00:11:41.460 --> 00:11:46.280
So that your, all of your UI controls look
modern, look up to date.

00:11:46.280 --> 00:11:48.330
They don't look like they're Gingerbread versions.

00:11:48.330 --> 00:11:52.890
So for those apps that you've seen occasionally
running on your Ice Cream Sandwich devices

00:11:52.890 --> 00:11:58.970
that seem to have Gingerbread looking buttons,
it's because they haven't specified a target

00:11:58.970 --> 00:12:01.750
SDK version of 11 or higher.

00:12:01.750 --> 00:12:04.290
So it's really important that you do go and
you enable it.

00:12:04.290 --> 00:12:08.000
So you get the Holo theme, then there's a
screen compatibility mode which is all about

00:12:08.000 --> 00:12:12.320
saying whether you want app to stretch to
fit or zoom to fit.

00:12:12.320 --> 00:12:16.790
And the more interesting one now is obviously
the legacy menu button.

00:12:16.790 --> 00:12:22.891
So with our current generation of devices
like the Galaxy Nexus or in fact most of the

00:12:22.891 --> 00:12:26.630
Android tablets, they don't have a physical
menu button.

00:12:26.630 --> 00:12:34.480
If you try to run a legacy app, an older app,
on these newer devices what you'll find is

00:12:34.480 --> 00:12:40.390
that in your navigation bar you get a little
menu button, it looks like the overflow button

00:12:40.390 --> 00:12:41.780
but it's the menu button.

00:12:41.780 --> 00:12:45.840
That's the legacy menu button and it's something
that really, you should be moving away from

00:12:45.840 --> 00:12:48.360
and moving towards using the action bar.

00:12:48.360 --> 00:12:53.880
So, target SDK version is what you use as
soon as you specify 11 or greater.

00:12:53.880 --> 00:12:58.090
It'll enable these things on a newer versions
of the platform.

00:12:58.090 --> 00:13:03.890
If you target 14 or higher, you automatically
get hardware acceleration, unless you explicitly

00:13:03.890 --> 00:13:06.800
mention that you don’t want hardware acceleration
in your app.

00:13:06.800 --> 00:13:13.440
But there are very few scenarios that we found
where you wouldn't want that hardware acceleration.

00:13:13.440 --> 00:13:17.860
So really, you know, try to follow these best
practices of keeping the target SDK version

00:13:17.860 --> 00:13:19.520
up to the maximum version.

00:13:19.520 --> 00:13:24.510
Now, you might be asking yourself "Well, if
this is how it works, why doesn't it implicitly

00:13:24.510 --> 00:13:28.010
target the newest version all the time?"

00:13:28.010 --> 00:13:32.470
The reason is because there can be changes
in behavior and so when you make certain changes

00:13:32.470 --> 00:13:40.630
in behavior to the Android framework, we make
sure that we keep the existing behavior if

00:13:40.630 --> 00:13:44.060
the app is targeting older API levels.

00:13:44.060 --> 00:13:49.330
So an example of changes in behavior is that
we changed the AsyncTask threading model in

00:13:49.330 --> 00:13:50.330
API 13.

00:13:50.330 --> 00:13:56.430
Where instead of having a pool of threads
that execute AsyncTasks you use a single thread

00:13:56.430 --> 00:14:00.740
that runs AsyncTasks serially, but still in
a separate thread.

00:14:00.740 --> 00:14:04.990
So there can be minor changes in behavior
and so that's why we recommend that you do,

00:14:04.990 --> 00:14:10.530
not only do you update to the latest API level
in your target SDK version, but you do go

00:14:10.530 --> 00:14:11.590
through your full test cycle.

00:14:11.590 --> 00:14:12.590
&gt;&gt;Tony Chan: Yeah.

00:14:12.590 --> 00:14:14.480
&gt;&gt; Ankur Kotwal: But as I said, the benefits
are great.

00:14:14.480 --> 00:14:18.520
&gt;&gt;Tony Chan: Yeah, one thing I want to add
is also, like also for example the action

00:14:18.520 --> 00:14:22.960
bar for when you enable set target SDK to
greater than 11.

00:14:22.960 --> 00:14:29.210
So action bar will be something, will be enabled
at that point.

00:14:29.210 --> 00:14:36.240
So if your apps hasn't been tested on the
latest version, so make sure you test your

00:14:36.240 --> 00:14:43.300
app as well because that will have an impact
on the UI of the application.

00:14:43.300 --> 00:14:46.440
&gt;&gt; Ankur Kotwal: Yeah, thanks Tony.

00:14:46.440 --> 00:14:53.890
So the last one is the max SDK version and
actually as of Android 2.0.1, the operating

00:14:53.890 --> 00:14:56.660
system doesn't even look at the max SDK version.

00:14:56.660 --> 00:14:58.890
It's only used in Google Play.

00:14:58.890 --> 00:15:05.620
So what happens is, if you specify max SDK
version, it means that Google Play won't often,

00:15:05.620 --> 00:15:13.880
devices that are running newer versions of
the API, it won't offer your app, this particular

00:15:13.880 --> 00:15:15.400
app to those devices.

00:15:15.400 --> 00:15:20.280
So you’re kind of saying hey it'll only
run up to Ice Cream Sandwich and not any further

00:15:20.280 --> 00:15:21.490
than that.

00:15:21.490 --> 00:15:27.120
And really as Android app developer, what
you want to be doing is maximizing the number

00:15:27.120 --> 00:15:32.020
of people, well maximizing the number of people
that can install your app, right?

00:15:32.020 --> 00:15:37.130
So you don't wanna be specifying these max
SDK versions because remember what I said,

00:15:37.130 --> 00:15:43.260
when you're using target SDK version and you're
fixing it to a particular value, we will ensure

00:15:43.260 --> 00:15:45.610
that you get the same behavior.

00:15:45.610 --> 00:15:51.510
So that AsyncTask change that I mentioned
before, if you're target SDK version isn't

00:15:51.510 --> 00:15:54.320
13 or greater you will get the older behavior.

00:15:54.320 --> 00:15:59.020
So in general we don't actually recommend
you use max SDK version and the only real

00:15:59.020 --> 00:16:04.191
situation that we've, that I can come up with
where you might want to use it is if you're

00:16:04.191 --> 00:16:09.920
using multi APK support, so in Play you're
kind of saying well I've got different APKs

00:16:09.920 --> 00:16:12.190
targeting different versions of the platform.

00:16:12.190 --> 00:16:16.690
So an example of where you might want to do
that is where you have an app today that’s

00:16:16.690 --> 00:16:22.700
supporting a set of older Android versions
but in your next version of that app you kinda

00:16:22.700 --> 00:16:29.040
wanna say "I'm no longer supporting those
old devices or old API versions, but I don’t

00:16:29.040 --> 00:16:34.000
wanna take that old version off the store
for people that have old devices".

00:16:34.000 --> 00:16:39.040
So then what will happen by using this, you
would specify max SDK version for your older

00:16:39.040 --> 00:16:44.040
version of the app and then people with older
versions of the API, so you'd use a combination

00:16:44.040 --> 00:16:45.750
of max and min obviously.

00:16:45.750 --> 00:16:52.880
People with the older version of the platform
will get the older app so people on 1.5 1.6

00:16:52.880 --> 00:16:57.640
and then your newer users can get the latest
updates and the latest features.

00:16:57.640 --> 00:17:01.680
So it's really about making your life easier.

00:17:01.680 --> 00:17:08.410
But it is something that developers can overlook
from time to time and we really recommend

00:17:08.410 --> 00:17:11.910
that you certainly use minimum and target
SDK versions.

00:17:11.910 --> 00:17:17.330
&gt;&gt;Tony Chan: Yeah, I think another thing I
want to add is another use case that I saw

00:17:17.330 --> 00:17:24.500
the developer using the max SDK version is
when there is a major release, a Android OS

00:17:24.500 --> 00:17:32.410
release, some developer may just temporarily
set the max SDK while they are doing extensive

00:17:32.410 --> 00:17:35.110
testing on the major release.

00:17:35.110 --> 00:17:41.630
I think that probably another real use case
that may be useful for temporarily setting

00:17:41.630 --> 00:17:45.130
the max SDK to the [unintelligible].

00:17:45.130 --> 00:17:49.350
[feedback noise]
&gt;&gt; Ankur Kotwal: Yeah.

00:17:49.350 --> 00:17:50.350
Alright.

00:17:50.350 --> 00:17:51.350
So that's user SDK.

00:17:51.350 --> 00:17:54.970
The next one we'd like to talk about is uses
feature.

00:17:54.970 --> 00:18:01.360
So you know often you may have an app that
you're using some sort of hardware feature

00:18:01.360 --> 00:18:03.870
but it's not critical to the operation of
your app.

00:18:03.870 --> 00:18:08.460
So an example of that is that you may have
a brilliant app that does great photo editing.

00:18:08.460 --> 00:18:14.370
Now, one of the features of your app might
be that you use, that you allow the use to

00:18:14.370 --> 00:18:18.700
take photos as well as edit existing photos
in the gallery.

00:18:18.700 --> 00:18:23.320
Now, if you're taking photos you might be
wanting to use features like auto focus.

00:18:23.320 --> 00:18:28.290
So you don’t want to get into a situation
where people that have devices that don’t

00:18:28.290 --> 00:18:33.610
have a specific feature aren't able to use
the core functionality of your app.

00:18:33.610 --> 00:18:38.020
So there are ways that you can actually specify
that "Hey I would like to use this hardware

00:18:38.020 --> 00:18:41.161
feature if it's there, but if it's not then
go ahead anyway".

00:18:41.161 --> 00:18:44.230
And that’s what we're gonna talk about now.

00:18:44.230 --> 00:18:49.840
So in terms of how you would do this, you
would typically say "Hey, I wanna use a camera"

00:18:49.840 --> 00:18:53.040
and then you can make decisions on which of
those features are optional.

00:18:53.040 --> 00:18:58.140
So in the example here we're saying we're
using the camera we're also using auto focus

00:18:58.140 --> 00:19:03.920
but you'll notice at the bottom of that white
text it says "Android required equals false"

00:19:03.920 --> 00:19:08.640
And that's stating that this particular auto
focus feature is optional.

00:19:08.640 --> 00:19:15.310
Now, keep in mind that when you request these
users features for anything that is said to

00:19:15.310 --> 00:19:20.680
be required equals true, Google Play will
filter on those.

00:19:20.680 --> 00:19:25.990
So at the top there we said uses-feature camera,
but we didn't actually specify required.

00:19:25.990 --> 00:19:31.850
It's implicitly implied there that required
is true, that's the default value.

00:19:31.850 --> 00:19:35.390
So the second part, the other focus is actually
saying it's optional.

00:19:35.390 --> 00:19:40.070
So you can make a decision as which part of,
which of these features are optional in your

00:19:40.070 --> 00:19:41.070
app.

00:19:41.070 --> 00:19:46.300
And then at runtime what you do is that you
can go through the package manager to go and

00:19:46.300 --> 00:19:49.980
find out if the system has that particular
feature.

00:19:49.980 --> 00:19:55.740
So here we're checking if we have the feature
at runtime and then conditionally we are executing

00:19:55.740 --> 00:19:57.530
our code.

00:19:57.530 --> 00:20:04.040
So, this is a nice way to kind of, you know,
broaden the number of users, the number of

00:20:04.040 --> 00:20:06.560
devices that your app can run on.

00:20:06.560 --> 00:20:11.230
Whilst making sure, you know, your app still
hangs together.

00:20:11.230 --> 00:20:13.840
Now I've provided a URL there at the bottom.

00:20:13.840 --> 00:20:18.640
We actually had a blog post about this and
I'll just bring that up.

00:20:18.640 --> 00:20:25.800
We had a blog post about this in, all the
way back in October actually, in October 2010

00:20:25.800 --> 00:20:27.400
rather, I should add.

00:20:27.400 --> 00:20:33.420
So it's worth your while to have a look at
this code and have a look through this blog

00:20:33.420 --> 00:20:38.010
post that kinda walks you through it in more
detail.

00:20:38.010 --> 00:20:39.010
[chime]

00:20:39.010 --> 00:20:46.950
&gt;&gt; Ankur Kotwal: So let's go to the next section
of the presentation.

00:20:46.950 --> 00:20:48.180
Uses-permission.

00:20:48.180 --> 00:20:55.100
So obviously developers know you can, at install
time you specify which Android permissions

00:20:55.100 --> 00:20:56.100
you'd like.

00:20:56.100 --> 00:20:59.700
Well, what we've found is, that there are
a number of apps that request permissions

00:20:59.700 --> 00:21:05.380
that are over and above what they really require
and users are starting to really object to

00:21:05.380 --> 00:21:06.380
this.

00:21:06.380 --> 00:21:11.290
Android users are quite tech savvy and they
tend to know, when, you know, an app is requesting

00:21:11.290 --> 00:21:13.170
more than they need to.

00:21:13.170 --> 00:21:18.350
Like a wallpaper app should never need to,
you know, read through my contacts, for example.

00:21:18.350 --> 00:21:23.110
So what we wanted to do is present to you
a list of what we consider to be the worst

00:21:23.110 --> 00:21:27.250
permissions that apps request.

00:21:27.250 --> 00:21:31.500
There are circumstances where you might need
some of these permissions but you really need

00:21:31.500 --> 00:21:32.510
to think long and hard.

00:21:32.510 --> 00:21:35.990
So the first one, well, we're gonna start
from 10 and go backwards.

00:21:35.990 --> 00:21:41.440
So changing Wi-Fi settings, there are very
few instances where you should need to change

00:21:41.440 --> 00:21:44.230
a user's Wi-Fi settings.

00:21:44.230 --> 00:21:51.080
Doing things on boot, you know, again it's
one of those things that, on boot you don’t

00:21:51.080 --> 00:21:56.120
want a whole of bunch of apps starting to
do a lot of things, so keep that in mind.

00:21:56.120 --> 00:21:58.420
You know, start your app at the right time.

00:21:58.420 --> 00:22:03.510
Don’t put an unnecessary load on the app,
on the device by having your app start up

00:22:03.510 --> 00:22:08.080
at boot and you know, and stay resident continuously.

00:22:08.080 --> 00:22:12.570
You don’t need to know what other tasks
are running on a device in most situations.

00:22:12.570 --> 00:22:16.110
There are again very few scenarios where you
would need to know this.

00:22:16.110 --> 00:22:20.950
Obtaining a fine location, there are some
apps that actually do need a very specific

00:22:20.950 --> 00:22:24.810
location but often that you'll find that the
course location will be good enough or the

00:22:24.810 --> 00:22:26.410
network location.

00:22:26.410 --> 00:22:30.330
You can also register for location updates
that other apps request.

00:22:30.330 --> 00:22:34.990
So try and be smarter about retrieving this
location.

00:22:34.990 --> 00:22:40.820
Getting fine location obviously also triggers
the GPS and you know, the GPS in these mobile

00:22:40.820 --> 00:22:47.420
devices do consume a lot of power so really,
challenge yourself to, or ask yourself do

00:22:47.420 --> 00:22:49.490
you really need it?

00:22:49.490 --> 00:22:51.930
You should never need to read the system log.

00:22:51.930 --> 00:22:54.390
And it's something in Jelly Bean that's actually
going away.

00:22:54.390 --> 00:22:58.210
You'll be able to read your own logs but you
won't have, you know, this permission will

00:22:58.210 --> 00:23:01.490
pretty much not do anything from Jelly Bean
onwards.

00:23:01.490 --> 00:23:04.880
You certainly won't be able to see the log
of the rest of the system.

00:23:04.880 --> 00:23:10.310
So number 5, you should never need to directly
call phone numbers.

00:23:10.310 --> 00:23:15.380
We actually have an intent that you can fire
to say 'hey, go fire up the dialer and prepopulate

00:23:15.380 --> 00:23:17.730
it with this phone number'.

00:23:17.730 --> 00:23:21.220
The user still has to click dial and that's
the right way to do it.

00:23:21.220 --> 00:23:25.260
Rather than directly call a number a yourself
through your app, fire up your intent.

00:23:25.260 --> 00:23:30.780
The intent doesn't even require you to have
a permission to do it.

00:23:30.780 --> 00:23:34.770
As I mentioned with things like wallpaper
apps asking for, reading contacts and calendar,

00:23:34.770 --> 00:23:38.280
people are very conscious about their privacy
these days.

00:23:38.280 --> 00:23:41.990
So, you know, again, ask yourself do you really
need that capability?

00:23:41.990 --> 00:23:49.559
The same goes with bookmarks, displaying system
level alerts, you know, spamming the notification

00:23:49.559 --> 00:23:54.730
bar, for example, and you know, in general,
system level alert permissions.

00:23:54.730 --> 00:24:01.710
And number one, and this is the worst one,
is for apps to be sending and receiving SMSs.

00:24:01.710 --> 00:24:06.220
There are some premium services that may do
this but the majority of the apps that we

00:24:06.220 --> 00:24:11.640
see that are requesting these kinds of permissions
certainly don’t need to do it.

00:24:11.640 --> 00:24:17.500
I'm not saying that they all have a malicious
intent, but you should really be careful about

00:24:17.500 --> 00:24:23.400
this one because you will notice many of the
apps that request these sorts of permission,

00:24:23.400 --> 00:24:27.220
get very negative feedback in the Play store.

00:24:27.220 --> 00:24:31.060
And once it's there, you can't get rid of
that negative feedback.

00:24:31.060 --> 00:24:34.040
So what should you do if you need some of
these permissions?

00:24:34.040 --> 00:24:38.360
Firstly, describe the reason that you would
need the permission on the Play store.

00:24:38.360 --> 00:24:43.950
You have a great big section of description
and in there, you know, you should state "Hey,

00:24:43.950 --> 00:24:47.330
we need this permission because this is how
we are using it".

00:24:47.330 --> 00:24:49.610
That's the responsible thing to do.

00:24:49.610 --> 00:24:53.760
Users love transparency, so the more transparent
you are with them, the more they're going

00:24:53.760 --> 00:24:57.760
to trust you as well to do the right thing.

00:24:57.760 --> 00:25:01.800
You know there can be ways of architecting
your apps such that you can separate that

00:25:01.800 --> 00:25:07.590
bit of functionality and make it optional
and though maybe like a plugin or add-on for

00:25:07.590 --> 00:25:11.040
your app that users can install separately.

00:25:11.040 --> 00:25:14.760
And then you can try triggering it through
that mechanism.

00:25:14.760 --> 00:25:18.860
And finally, just put yourself in the shoes
of the user.

00:25:18.860 --> 00:25:25.570
Would you be comfortable giving other apps
the permissions that your app is requesting?

00:25:25.570 --> 00:25:29.220
If you truly believe that the answer is yes,
then go ahead and do some of these things.

00:25:29.220 --> 00:25:34.100
But make sure again, transparency and you
want to gain the trust of the user and you

00:25:34.100 --> 00:25:39.100
certainly don’t want to abuse it.

00:25:39.100 --> 00:25:48.450
OK, so, that concludes the sort of short presentation
that we've had on the Android Manifest pro-tips,

00:25:48.450 --> 00:25:53.400
for now what we're gonna do is move to the
Q&amp;A section.

00:25:53.400 --> 00:25:57.510
And of course this is gonna be questions related
to Android development.

00:25:57.510 --> 00:26:04.850
You know we have the moderator questions,
we also have some people that are here live

00:26:04.850 --> 00:26:05.850
with us.

00:26:05.850 --> 00:26:08.309
So let's open it up for questions.

00:26:08.309 --> 00:26:10.720
Let's see if the live audience has anything.

00:26:10.720 --> 00:26:12.110
Hey, Andrew.

00:26:12.110 --> 00:26:17.150
&gt;&gt;Andrew Kelly: Hey, just a quick one on the
stuff you were talking about just a moment

00:26:17.150 --> 00:26:18.920
ago with permissions.

00:26:18.920 --> 00:26:25.390
Is it likely that or an alternative that you'd
be able to have required kind of true or false

00:26:25.390 --> 00:26:28.630
on permissions in the same way that you can
with features?

00:26:28.630 --> 00:26:35.980
So, you know, if I could have location, fine
location as a permission, it's not actually

00:26:35.980 --> 00:26:40.650
required and I could then test for that in
my app to say "OK, these five features of

00:26:40.650 --> 00:26:45.780
my app can be used quite happily, but if I've
been given permission to query the location

00:26:45.780 --> 00:26:51.580
and this extra feature, you know, like pinpointing
your location on map will then become usable?"

00:26:51.580 --> 00:26:58.370
I mean at the moment a user has to accept
all of the permissions in one fell swoop rather

00:26:58.370 --> 00:27:02.620
than individually choosing which ones I've
got access to which I could then query later

00:27:02.620 --> 00:27:03.620
on.

00:27:03.620 --> 00:27:07.830
&gt;&gt; Ankur Kotwal: Sure, that's a good question,
and so, let me start off by saying it's very

00:27:07.830 --> 00:27:12.710
hard for us to comment on what direction we
are going but, let's just talk through some

00:27:12.710 --> 00:27:13.710
of that.

00:27:13.710 --> 00:27:18.490
Part of it is that we want to ensure users
have, have a really good experience when they

00:27:18.490 --> 00:27:22.540
install apps, they're not presented with,
you know, a ton of questions, that say, you

00:27:22.540 --> 00:27:26.890
know, here's four permissions that are requesting,
which ones do you want to turn on and off?

00:27:26.890 --> 00:27:31.450
So we really need to think about the user
experience when it comes to installing apps,

00:27:31.450 --> 00:27:35.570
and then we also need to think about well,
what about developers that have already got

00:27:35.570 --> 00:27:40.360
an existing set of apps, that are not stating
those permissions are optional.

00:27:40.360 --> 00:27:43.020
Should users be able to turn off permissions
on an app?

00:27:43.020 --> 00:27:46.480
So what does it mean for our existing set
of apps, what does it mean for the user experience

00:27:46.480 --> 00:27:47.630
if we were to do this?

00:27:47.630 --> 00:27:54.620
So there are a couple of things at play here,
and so as I said, I can't really comment one

00:27:54.620 --> 00:27:56.120
what's going to happen in the future.

00:27:56.120 --> 00:27:57.280
But, uh yea.

00:27:57.280 --> 00:28:03.740
&gt;&gt;Tony Chan: I guess one of the current implementation
developer currently is doing is to build some

00:28:03.740 --> 00:28:08.600
plugins right, and in those plugin asking
for those optional permissions.

00:28:08.600 --> 00:28:15.570
I mean if you have something that you think
your apps can be optional, you can pull those

00:28:15.570 --> 00:28:17.560
features into a separated plugin so, and–

00:28:17.560 --> 00:28:22.740
&gt;&gt;Andrew Kelly: When you say a plugin you
mean a separate APK file that's going to be

00:28:22.740 --> 00:28:24.029
hosted on the Google Play store?

00:28:24.029 --> 00:28:27.601
&gt;&gt; Ankur Kotwal: Yeah, so it's a separate
app, totally separate app and what you would

00:28:27.601 --> 00:28:32.890
do, is you could go and check if that’s
installed and if it's not installed you could

00:28:32.890 --> 00:28:37.190
say so when user tries to use a feature you
could say hey, you actually need to grab this

00:28:37.190 --> 00:28:41.490
piece of functionality from the Play store
and you could direct them to the Play store,

00:28:41.490 --> 00:28:42.490
you know page.

00:28:42.490 --> 00:28:43.880
So they don't need to search for it or anything.

00:28:43.880 --> 00:28:49.350
&gt;&gt;Tony Chan: And policy wise that's OK because
it's really offering different functionality,

00:28:49.350 --> 00:28:54.500
it's not like you're putting like multiple
same application on the Play store, which

00:28:54.500 --> 00:28:55.610
is what we discourage.

00:28:55.610 --> 00:29:00.590
&gt;&gt;Andrew Kelly: Yeah, going back to Ankur's
bit just a moment ago, all you've done there

00:29:00.590 --> 00:29:08.360
is changed the "hey, can I use your permission"
dialogue into a "hey, please go to the Google

00:29:08.360 --> 00:29:12.380
Play store and download the map plug in for
your application".

00:29:12.380 --> 00:29:13.650
You've not kinda made it a seamless-

00:29:13.650 --> 00:29:16.820
&gt;&gt; Ankur Kotwal: hmm
&gt;&gt; Andrew Kelly:- there's still a user interaction

00:29:16.820 --> 00:29:17.820
there.

00:29:17.820 --> 00:29:21.820
&gt;&gt; Ankur Kotwal: Yeah, it is a delicate balance,
there's no doubt it.

00:29:21.820 --> 00:29:24.420
It's not a simple problem, we certainly admit
that.

00:29:24.420 --> 00:29:25.420
Yeah.

00:29:25.420 --> 00:29:27.299
&gt;&gt; Andrew Kelly: Yeah, OK.

00:29:27.299 --> 00:29:35.520
&gt;&gt; Ankur Kotwal: Alright, so we've got a couple
of other of people on the hangout.

00:29:35.520 --> 00:29:39.130
Any other questions from anyone?

00:29:39.130 --> 00:29:40.950
Before we move to moderator.

00:29:40.950 --> 00:29:42.230
[pause]

00:29:42.230 --> 00:29:52.030
&gt;&gt; Ankur Kotwal: OK, so let's move to the
moderator link, let me just bring that up.

00:29:52.030 --> 00:29:57.120
And I will screen share.

00:29:57.120 --> 00:30:02.190
[pause] [tapping noises]

00:30:02.190 --> 00:30:07.310
Actually I'll just do that window because
then it will be nice and, nice and large.

00:30:07.310 --> 00:30:08.310
There we are.

00:30:08.310 --> 00:30:11.110
So Tony do want to walk us through these?

00:30:11.110 --> 00:30:12.160
Or Anirudh?

00:30:12.160 --> 00:30:13.160
[pause]

00:30:13.160 --> 00:30:14.270
&gt;&gt;Anirudh Dewani: uhh

00:30:14.270 --> 00:30:18.980
&gt;&gt;Tony Chan: Yeah, Anirudh, you want to take
or I can.

00:30:18.980 --> 00:30:23.370
&gt;&gt;Anirudh Dewani: Uhh, I'm sorry which question
are we talking about?

00:30:23.370 --> 00:30:25.690
&gt;&gt;Tony Chan: OK, I'll take this one.

00:30:25.690 --> 00:30:31.950
So, "Why do developer, Android developer guides
for parsing XML recommend using an XmlPullParser

00:30:31.950 --> 00:30:38.580
when it appears the SAX parsers are an order
of magnitude faster?"

00:30:38.580 --> 00:30:47.290
So, I think one reason we are recommending
the Pull Parser, actually the SAX parser in

00:30:47.290 --> 00:30:56.620
general is, performance wise compared to like
pull parser is really better and in most cases

00:30:56.620 --> 00:31:06.140
like the pull parser performance is actually
better but from the article you post there,

00:31:06.140 --> 00:31:12.270
the pull parser is, the SAX parser, there
are two implementation, the SAX one is really,

00:31:12.270 --> 00:31:13.560
have a better performance.

00:31:13.560 --> 00:31:20.530
But again, that actually depends on the benchmark
and we can take this as a feedback and bring

00:31:20.530 --> 00:31:27.900
this back to the engineering team and see
whether there is really a performance optimization

00:31:27.900 --> 00:31:30.429
there we can do on the pull parser.

00:31:30.429 --> 00:31:36.679
Also, in terms of coding style, I think the
pull parser is better because you can select

00:31:36.679 --> 00:31:46.929
event, you want to listen to versus the SAX
parser you have to, it's kind of a push model

00:31:46.929 --> 00:31:49.600
instead of a pull model.

00:31:49.600 --> 00:31:51.440
So, that's what I have anyway.

00:31:51.440 --> 00:31:53.990
Anirudh you have anything to add or Ankur?

00:31:53.990 --> 00:31:58.570
&gt;&gt;Anirudh Dewani: Yeah, I mean with the, the
one difference is with the pull parser, when

00:31:58.570 --> 00:32:05.260
you need to do the event types they'll start
and you can only look at the events that you

00:32:05.260 --> 00:32:11.660
are interested in but with the SAX parser,
you have to go through all the other ones

00:32:11.660 --> 00:32:18.010
that come through the code that you write
so that's one benefit of using a pull parser.

00:32:18.010 --> 00:32:21.420
&gt;&gt; Ankur Kotwal: OK, thank you.

00:32:21.420 --> 00:32:25.740
So the next question is actually from Andrew.

00:32:25.740 --> 00:32:32.200
Andrews says "I'm using a html image map for
each area that is clicked a blue rectangle,

00:32:32.200 --> 00:32:38.460
it can be orange depending on device, it's
displayed briefly, even if the shape happens

00:32:38.460 --> 00:32:39.460
to be a circle.

00:32:39.460 --> 00:32:40.730
Can this be turned off?"

00:32:40.730 --> 00:32:47.340
And he's tried a few web kit tricks in his
CSS but didn't have much luck.

00:32:47.340 --> 00:32:56.830
Now, Andrew, I actually had a look at this
and it seems like the implementation that

00:32:56.830 --> 00:33:04.390
we have in the, in web view unfortunately
has this side effect.

00:33:04.390 --> 00:33:10.040
There is nothing we do at the moment unfortunately,
we can pass it on to the engineering team.

00:33:10.040 --> 00:33:14.080
One thing I can tell you however, which it
doesn’t really help you, I think, if this

00:33:14.080 --> 00:33:16.570
is an app it doesn't help you, but if it's
just a website-

00:33:16.570 --> 00:33:17.570
&gt;&gt;Andrew Kelly: Yeah, it's an app.

00:33:17.570 --> 00:33:18.570
&gt;&gt;Ankur Kotwal: - Ahh, it's an app, OK.

00:33:18.570 --> 00:33:22.960
If it was a website, what I did was I tried
it in Chrome on Android and it didn't result

00:33:22.960 --> 00:33:23.960
in the blue squares.

00:33:23.960 --> 00:33:24.960
&gt;&gt;Andrew Kelly: Yeah.

00:33:24.960 --> 00:33:26.010
Yeah, It's not in Chrome, yeah.

00:33:26.010 --> 00:33:27.550
&gt;&gt;Ankur Kotwal: So, yeah.

00:33:27.550 --> 00:33:35.110
So I think this is a difference in behavior
on the web view component on Android.

00:33:35.110 --> 00:33:39.960
I even confirmed it actually in the browser
itself.

00:33:39.960 --> 00:33:41.050
Not just the web view component.

00:33:41.050 --> 00:33:45.670
So yeah, we’ll take that back and report
it to the team.

00:33:45.670 --> 00:33:49.020
But is it a major show stopper for you?

00:33:49.020 --> 00:33:53.310
&gt;&gt;Andrew Kelly: No it's not it's just something
the client I'm working with has noticed every

00:33:53.310 --> 00:33:57.000
time that they use the image map and they're
kicking around on the page they see these

00:33:57.000 --> 00:34:01.500
little blue squares appearing and it's just
a little bit annoying compared to when you

00:34:01.500 --> 00:34:05.500
use these sites on the desktop or on an iPad
and you don't see the kind of highlighted

00:34:05.500 --> 00:34:07.770
areas as you're kicking around on the site.

00:34:07.770 --> 00:34:11.609
So it was just something I was trying to work
out if there was a bit of CSS that I could

00:34:11.609 --> 00:34:16.340
stick in there or whether there was an attribute
in the XML I could put around the web view

00:34:16.340 --> 00:34:18.110
that would turn that stuff of.

00:34:18.110 --> 00:34:21.450
But yeah, I've tried several things and none
of them seem to work, so.

00:34:21.450 --> 00:34:23.010
&gt;&gt;Ankur Kotwal: Yeah, sorry about that.

00:34:23.010 --> 00:34:24.050
&gt;&gt;Andrew Kelly: It's alright.

00:34:24.050 --> 00:34:25.649
&gt;&gt;Ankur Kotwal: We'll take it back to the
team-

00:34:25.649 --> 00:34:26.800
&gt;&gt;Andrew Kelly: Good.

00:34:26.800 --> 00:34:29.109
&gt;&gt;Ankur Kotwal: -and let you know.

00:34:29.109 --> 00:34:34.820
Alright, next question; "Why is there no satellite
mode for MapView?

00:34:34.820 --> 00:34:41.820
The method set Satellite actually sets hybrid
mode including both tiles of aerial imagery

00:34:41.820 --> 00:34:44.390
with roads and names superimposed.

00:34:44.390 --> 00:34:48.980
So right now there is no way to show only
aerial imagery without roads."

00:34:48.980 --> 00:34:49.980
Anirudh?

00:34:49.980 --> 00:34:56.560
&gt;&gt;Anirudh Dewani: Yeah, this is when we have
an open issue on our Android issue tracker

00:34:56.560 --> 00:34:59.359
regarding this, this is something we'll look
at.

00:34:59.359 --> 00:35:01.240
Thanks for your feedback.

00:35:01.240 --> 00:35:03.130
&gt;&gt;Ankur Kotwal: Yeah, alright.

00:35:03.130 --> 00:35:07.140
Again, thanks for reporting it, sorry that
we don’t actually have a work around for

00:35:07.140 --> 00:35:08.140
you.

00:35:08.140 --> 00:35:11.790
The only work around which I probably wouldn’t
recommend when it comes to using the map side

00:35:11.790 --> 00:35:15.910
of it is, you know, using the web version
of the map.

00:35:15.910 --> 00:35:21.720
And the only reason I say I wouldn't recommend
it is just because I find that using that

00:35:21.720 --> 00:35:26.920
Java script version of maps in a web view,
it doesn’t perform as well as the native

00:35:26.920 --> 00:35:30.240
map view, or sorry map activity.

00:35:30.240 --> 00:35:32.640
So, yeah.

00:35:32.640 --> 00:35:33.830
Next.

00:35:33.830 --> 00:35:40.470
"Why are we not able to attach image in the
mail body?"

00:35:40.470 --> 00:35:48.640
This person, this doesn't sound like a developer
question actually, so don't know the answer.

00:35:48.640 --> 00:35:50.390
[chuckle]

00:35:50.390 --> 00:35:56.080
Here's another one that doesn't sound like
a developer question: "Why does Android not

00:35:56.080 --> 00:36:01.350
have an official Google sites app, I would
love to customize my websites on the go" I

00:36:01.350 --> 00:36:06.460
suspect you could probably just go to the
Google sites page in your Android web browser

00:36:06.460 --> 00:36:08.070
and modify it there.

00:36:08.070 --> 00:36:14.030
I don’t know that there would be a massive
market for people changing their, modifying

00:36:14.030 --> 00:36:18.850
their Google sites through a mobile app anyway.

00:36:18.850 --> 00:36:21.220
That's not necessarily the official reason,
but that's just my thoughts.

00:36:21.220 --> 00:36:24.660
So, not a developer question, we'll move on.

00:36:24.660 --> 00:36:30.180
"Last time you had mentioned that there are
some new Notification support in the support

00:36:30.180 --> 00:36:35.720
library, can you tell us what Notification
features have been added there?

00:36:35.720 --> 00:36:41.170
Can Android 4.1-like notifications work in
earlier versions?"

00:36:41.170 --> 00:36:42.220
Anirudh?

00:36:42.220 --> 00:36:50.990
&gt;&gt;Anirudh Dewani: Yes, we've added rich notification
support and there are some release notes with

00:36:50.990 --> 00:36:53.880
the support library which you can look at
what the features are.

00:36:53.880 --> 00:36:59.170
But we do provide now rich notification support
like the Jelly Bean and ICS.

00:36:59.170 --> 00:37:05.300
&gt;&gt;Tony Chan: Yeah, all the big content expanded
layout and priority, those things are now

00:37:05.300 --> 00:37:10.590
supported in the compact, notification compact
library.

00:37:10.590 --> 00:37:16.580
&gt;&gt;Ankur Kotwal: Cool, alright, well, there
are no more questions on the moderator, are

00:37:16.580 --> 00:37:22.210
there any other questions from people that
are on the Hangout?

00:37:22.210 --> 00:37:23.830
[pause]

00:37:23.830 --> 00:37:26.470
Doesn't look like it.

00:37:26.470 --> 00:37:33.421
Well, in that case well thank you for joining
us for our first episode for Android Developer

00:37:33.421 --> 00:37:37.609
Lab Plus, we'll be back again next week.

00:37:37.609 --> 00:37:42.570
As you noticed today we did a presentation
on the Android Manifest File, we'll be doing

00:37:42.570 --> 00:37:48.040
more of these sort of topics of the week,
so we've got a few ideas in mind.

00:37:48.040 --> 00:37:51.930
But if there are some specific topics that
you guys would like us to talk about please

00:37:51.930 --> 00:37:53.700
let us know.

00:37:53.700 --> 00:37:58.970
We are always interested in your feedback
and we do take that seriously.

00:37:58.970 --> 00:38:02.360
So on that note, thanks for joining in and
see you next time.

00:38:02.360 --> 00:38:04.100
&gt;&gt;Andrew Kelly: See you next week.

00:38:04.100 --> 00:38:05.550
&gt;&gt;Tony Chan: Thank you, bye.

00:38:05.550 --> 00:38:06.420
&gt;&gt;Anirudh Dewani: Bye

