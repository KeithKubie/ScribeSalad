WEBVTT
Kind: captions
Language: en

00:00:04.019 --> 00:00:04.810
TOR NORBYE: Hello.

00:00:04.810 --> 00:00:07.310
Welcome, everyone,
to this session,

00:00:07.310 --> 00:00:09.470
entitled "Android
Studio for Experts."

00:00:09.470 --> 00:00:13.030
Congratulations on passing
the expert exam at the door.

00:00:13.030 --> 00:00:15.850
The format for this is
going to be all demos.

00:00:15.850 --> 00:00:19.190
You probably know some
of these tricks and tips,

00:00:19.190 --> 00:00:20.670
but hopefully not all of them.

00:00:20.670 --> 00:00:21.920
And we're going to take turns.

00:00:21.920 --> 00:00:23.544
These are members
from the Studio team.

00:00:23.544 --> 00:00:26.350
We're going to take turns
doing our own individual demos.

00:00:26.350 --> 00:00:28.410
So I guess I'll
just get started.

00:00:28.410 --> 00:00:29.577
Thank you.

00:00:29.577 --> 00:00:31.410
So I'm going to show
you some editor tricks.

00:00:31.410 --> 00:00:35.490
Can we go to, yes, you're
already showing the ID.

00:00:35.490 --> 00:00:38.560
So the first thing I want to
show you is code completion.

00:00:38.560 --> 00:00:41.580
Small, little trick when
you do completion like this.

00:00:41.580 --> 00:00:43.719
If you just press
Enter to choose,

00:00:43.719 --> 00:00:46.260
it's going to basically insert
and break your code like this.

00:00:46.260 --> 00:00:47.860
And what you
probably want to know

00:00:47.860 --> 00:00:50.060
is that you should
press Tab instead.

00:00:50.060 --> 00:00:53.678
That will replace the
symbol under the carat.

00:00:53.678 --> 00:00:55.082
[APPLAUSE]

00:00:57.430 --> 00:00:58.160
All right.

00:00:58.160 --> 00:01:00.790
Some of you already learned
something, that's great.

00:01:00.790 --> 00:01:01.805
All right.

00:01:01.805 --> 00:01:03.930
The other code completion
trick is, code completion

00:01:03.930 --> 00:01:05.250
is really, really smart.

00:01:05.250 --> 00:01:08.140
And so generally all you have to
do is just press Control-Space.

00:01:08.140 --> 00:01:11.280
But did you know that if you
press Control-Shift-Space,

00:01:11.280 --> 00:01:13.390
it gets smarter?

00:01:13.390 --> 00:01:15.910
It actually will do chain calls.

00:01:15.910 --> 00:01:17.619
And sometimes you have
to press it twice.

00:01:17.619 --> 00:01:19.035
So let me show
what happens when I

00:01:19.035 --> 00:01:20.400
have a context local variable.

00:01:20.400 --> 00:01:24.731
This is a static method that
doesn't extend any Android

00:01:24.731 --> 00:01:25.230
classes.

00:01:25.230 --> 00:01:30.145
But if I press Control-Shift
once and then twice,

00:01:30.145 --> 00:01:32.770
notice how it figured out that
I had a context variable that it

00:01:32.770 --> 00:01:34.250
could get a drawable from.

00:01:34.250 --> 00:01:37.640
So that's really useful.

00:01:37.640 --> 00:01:41.014
OK, selection.

00:01:41.014 --> 00:01:42.680
I've seen a lot of
users do this, right?

00:01:42.680 --> 00:01:45.330
You get the mouse, you
try to select this part,

00:01:45.330 --> 00:01:47.100
and you're maybe off by one.

00:01:47.100 --> 00:01:48.610
Or maybe you do it
by the keyboard,

00:01:48.610 --> 00:01:51.124
and you're pressing the Shift
key while you're selecting.

00:01:51.124 --> 00:01:52.540
There's a better
way of selecting,

00:01:52.540 --> 00:01:53.700
and that is AST selection.

00:01:53.700 --> 00:01:57.560
So the action for that is
Extend Selection, I think.

00:01:57.560 --> 00:01:58.060
Yeah.

00:01:58.060 --> 00:01:59.740
So you can see the
shortcut right there.

00:01:59.740 --> 00:02:02.220
So you can really
quickly select portions

00:02:02.220 --> 00:02:04.650
based on syntactic elements
in the source code, right?

00:02:04.650 --> 00:02:08.395
And I can press Up and Down to
select outer and inner things.

00:02:08.395 --> 00:02:09.770
So if I quickly
wanted to select,

00:02:09.770 --> 00:02:11.270
for example, this
statement up here,

00:02:11.270 --> 00:02:12.470
I just tap on it like that.

00:02:12.470 --> 00:02:15.740
And then, one or two or three
clicks, I have the expression.

00:02:15.740 --> 00:02:17.900
And I can then press a
shortcut to, for example,

00:02:17.900 --> 00:02:19.025
extract a variable from it.

00:02:21.450 --> 00:02:22.240
Intentions.

00:02:22.240 --> 00:02:24.540
Hopefully, you all know what
intention actions are now.

00:02:24.540 --> 00:02:26.581
If not, that is going to
be the most useful thing

00:02:26.581 --> 00:02:27.880
you learn today.

00:02:27.880 --> 00:02:30.130
Intention actions are these
things that are invisible.

00:02:30.130 --> 00:02:31.970
So they look at,
where's the carat

00:02:31.970 --> 00:02:34.920
and what can I do at
the carat position?

00:02:34.920 --> 00:02:37.790
So you can use that
to, for example, well,

00:02:37.790 --> 00:02:39.620
let's see what we can
do on a character.

00:02:39.620 --> 00:02:42.691
Well, I can convert to
string literal, for example.

00:02:42.691 --> 00:02:44.940
I really like that when I
have a constructor like this

00:02:44.940 --> 00:02:48.430
and I'm adding more fields,
I can invoke an intention

00:02:48.430 --> 00:02:50.417
action here, and I can
bind the constructor

00:02:50.417 --> 00:02:51.250
to parameter fields.

00:02:51.250 --> 00:02:53.850
So it very quickly will add
variables and initialize it

00:02:53.850 --> 00:02:54.980
in the constructor.

00:02:54.980 --> 00:02:59.534
And likewise, if I add
a fourth parameter,

00:02:59.534 --> 00:03:00.450
I can invoke it again.

00:03:00.450 --> 00:03:02.830
And it'll also insert a field,
and bind it, and so forth.

00:03:02.830 --> 00:03:04.510
So that's pretty handy.

00:03:04.510 --> 00:03:06.580
This is also great
with instanceof check.

00:03:06.580 --> 00:03:08.705
So I'm sure that many of
you have done this, right?

00:03:08.705 --> 00:03:11.449
You're in here, you made sure
your parameter is a context.

00:03:11.449 --> 00:03:13.990
You don't want to have to go
and actually declare a variable.

00:03:13.990 --> 00:03:16.050
You can just put the
carat one line back up.

00:03:16.050 --> 00:03:17.224
Invoke--

00:03:17.224 --> 00:03:18.140
AUDIENCE: Scroll down.

00:03:18.140 --> 00:03:18.700
TOR NORBYE: Scroll down?

00:03:18.700 --> 00:03:19.200
Oh.

00:03:19.200 --> 00:03:21.820
Sorry.

00:03:21.820 --> 00:03:22.612
That's interesting.

00:03:22.612 --> 00:03:24.319
I'm seeing different
things than you are.

00:03:24.319 --> 00:03:24.980
OK.

00:03:24.980 --> 00:03:28.920
So you can put the carat
back on the context line.

00:03:28.920 --> 00:03:31.850
And there is now an intention
to insert a variable that's

00:03:31.850 --> 00:03:33.130
already been cast.

00:03:33.130 --> 00:03:35.490
It's pretty handy.

00:03:35.490 --> 00:03:36.340
Suppress.

00:03:36.340 --> 00:03:37.715
I just want to
make sure everyone

00:03:37.715 --> 00:03:40.080
knows that when you have
a warning like this,

00:03:40.080 --> 00:03:41.040
there's a quick fix.

00:03:41.040 --> 00:03:43.440
But you can also always
press the Arrow Right

00:03:43.440 --> 00:03:44.960
to suppress the warning, right?

00:03:44.960 --> 00:03:46.750
So it'll actually
highlight the context

00:03:46.750 --> 00:03:48.855
that the suppress applies to.

00:03:48.855 --> 00:03:49.896
It's pretty good to know.

00:03:52.420 --> 00:03:53.220
Live templates.

00:03:53.220 --> 00:03:58.230
So you never want to go and
write a for-loop by hand.

00:03:58.230 --> 00:03:59.667
You can, but there's
a better way.

00:03:59.667 --> 00:04:01.000
And that's using live templates.

00:04:01.000 --> 00:04:04.240
So if I just type fori,
and I press the Tab key,

00:04:04.240 --> 00:04:06.650
it inserts a for
skeleton like that.

00:04:06.650 --> 00:04:08.250
And then you can
just tap through.

00:04:08.250 --> 00:04:10.500
And of course, you would
have the target size.

00:04:10.500 --> 00:04:12.560
And there's nothing
special about i, right?

00:04:12.560 --> 00:04:15.281
So if I do this I can
also call my variable j.

00:04:15.281 --> 00:04:15.780
Right?

00:04:15.780 --> 00:04:20.228
And the end condition could
be, for example, list.size.

00:04:20.228 --> 00:04:22.190
Now, Romain Guy
wanted to show you

00:04:22.190 --> 00:04:25.190
that you can also use post-fix
completion for this, right?

00:04:25.190 --> 00:04:27.560
So you just type the variable
you want to iterate over.

00:04:27.560 --> 00:04:30.597
And then the post-fix expression
will be fori like this.

00:04:30.597 --> 00:04:31.805
And that does the same thing.

00:04:31.805 --> 00:04:34.800
And it's already
preset, the size.

00:04:34.800 --> 00:04:35.300
Yeah.

00:04:35.300 --> 00:04:37.650
[APPLAUSE]

00:04:40.000 --> 00:04:41.770
All right.

00:04:41.770 --> 00:04:43.187
Some more stuff
on live templates.

00:04:43.187 --> 00:04:44.686
If you're doing
Android development,

00:04:44.686 --> 00:04:46.360
you're probably doing
a lot of logging.

00:04:46.360 --> 00:04:48.420
And so there's some
live templates for that.

00:04:48.420 --> 00:04:51.170
So I can, for example,
type logi to insert

00:04:51.170 --> 00:04:54.050
a logging statement for info.

00:04:54.050 --> 00:04:56.120
And you can see now
that it wants a tag,

00:04:56.120 --> 00:04:59.730
and so I could of course use the
normal intention for inserting

00:04:59.730 --> 00:05:01.050
a tag.

00:05:01.050 --> 00:05:03.900
And that's going to create a
constant that I can add, right?

00:05:03.900 --> 00:05:05.760
But there actually is
another live template

00:05:05.760 --> 00:05:06.980
for creating a tag.

00:05:06.980 --> 00:05:08.734
Logt.

00:05:08.734 --> 00:05:10.900
And notice how that actually
pre-populates the value

00:05:10.900 --> 00:05:14.350
with the current class,
which is pretty handy.

00:05:14.350 --> 00:05:18.050
And so there are some
additional logging templates.

00:05:18.050 --> 00:05:20.340
So for example, at the
beginning of the method,

00:05:20.340 --> 00:05:22.423
If I want to log that this
method is being called,

00:05:22.423 --> 00:05:23.480
I just do logm.

00:05:23.480 --> 00:05:26.570
Notice how that inserts
not just the method name,

00:05:26.570 --> 00:05:28.367
but all the parameters as well.

00:05:28.367 --> 00:05:30.200
And at the end, maybe
I want to log that I'm

00:05:30.200 --> 00:05:31.283
about to leave the method.

00:05:31.283 --> 00:05:32.830
So I just do logreturn.

00:05:32.830 --> 00:05:34.580
And that inserts, hey,
I'm about to return

00:05:34.580 --> 00:05:36.140
and here's the result value.

00:05:36.140 --> 00:05:39.044
This makes it really
easy to add logging.

00:05:39.044 --> 00:05:39.920
Yay.

00:05:39.920 --> 00:05:41.486
You're allowed to clap.

00:05:41.486 --> 00:05:44.336
[APPLAUSE]

00:05:46.090 --> 00:05:46.720
FilterSearch.

00:05:46.720 --> 00:05:49.194
This is actually not
code, but navigation.

00:05:49.194 --> 00:05:50.610
I want to make
sure everyone knows

00:05:50.610 --> 00:05:54.260
that we have invisible searching
in almost every list in the ID.

00:05:54.260 --> 00:05:54.760
Right?

00:05:54.760 --> 00:05:56.749
So if I, for example,
do Command-N,

00:05:56.749 --> 00:05:57.790
I get this Generate list.

00:05:57.790 --> 00:06:01.329
If I want to go for toString, I
could use the Arrow key, right?

00:06:01.329 --> 00:06:03.120
But even though there's
no search box here,

00:06:03.120 --> 00:06:05.710
if I start typing toString, you
can see it starts filtering.

00:06:05.710 --> 00:06:07.190
It puts a little text
field on top of it.

00:06:07.190 --> 00:06:08.773
And this is true
basically everywhere.

00:06:08.773 --> 00:06:10.830
So if I'm over here
and I want to do New,

00:06:10.830 --> 00:06:13.600
if I'm looking for Vector,
I just type vector, right?

00:06:13.600 --> 00:06:15.910
And it's navigating
right to that wizard.

00:06:15.910 --> 00:06:17.900
If I'm in the Refactoring
menu, Refactor This,

00:06:17.900 --> 00:06:20.610
I can search, for example,
for the Inline Factoring.

00:06:20.610 --> 00:06:23.370
I can filter the Project
View, build.gradle.

00:06:23.370 --> 00:06:25.270
So basically wherever
you are, and you're

00:06:25.270 --> 00:06:26.811
trying to search
for long lists, just

00:06:26.811 --> 00:06:29.720
start typing and
see what happens.

00:06:29.720 --> 00:06:31.470
StructuralReplace.

00:06:31.470 --> 00:06:35.210
So let me show you this
string file I came across

00:06:35.210 --> 00:06:37.340
in one of our projects.

00:06:37.340 --> 00:06:40.840
So the translators
had translated this,

00:06:40.840 --> 00:06:42.870
but they left all these
translation description

00:06:42.870 --> 00:06:44.530
elements in.

00:06:44.530 --> 00:06:46.420
And when you do it
like this, it actually

00:06:46.420 --> 00:06:48.150
gets packaged in VPK, right?

00:06:48.150 --> 00:06:49.430
So you don't want to do this.

00:06:49.430 --> 00:06:51.950
So how do I get rid of
all these attributes

00:06:51.950 --> 00:06:53.052
from the translations?

00:06:53.052 --> 00:06:54.760
You could probably
imagine a way to do it

00:06:54.760 --> 00:06:56.134
with regular
expressions, but I'm

00:06:56.134 --> 00:06:58.600
going to show you a different
way that's pretty handy.

00:06:58.600 --> 00:07:01.900
And that is Structural
Search and Replace.

00:07:01.900 --> 00:07:03.700
So, Replace Structurally, right?

00:07:03.700 --> 00:07:05.810
So what we're going
to do is, we're

00:07:05.810 --> 00:07:09.270
going to search in XML files.

00:07:09.270 --> 00:07:11.930
And I want to find
a StringElement.

00:07:11.930 --> 00:07:16.264
I can type string,
and I want the name,

00:07:16.264 --> 00:07:17.680
and I don't care
what the name is.

00:07:17.680 --> 00:07:18.930
So I'm just going to
make a little variable.

00:07:18.930 --> 00:07:20.540
That will be a placeholder.

00:07:20.540 --> 00:07:23.859
I'm going to look for
translation description.

00:07:23.859 --> 00:07:25.650
And the description is
going to be whatever

00:07:25.650 --> 00:07:27.480
it is, another placeholder.

00:07:27.480 --> 00:07:29.180
And then we're going
to have some text.

00:07:29.180 --> 00:07:34.270
And if the ID finds this, I
want it to basically remove

00:07:34.270 --> 00:07:36.380
that attribute.

00:07:36.380 --> 00:07:38.980
So if I've done this
correctly, if I search now

00:07:38.980 --> 00:07:40.940
it's going to search my project.

00:07:40.940 --> 00:07:43.903
And it's going to find
a bunch of attributes.

00:07:43.903 --> 00:07:44.403
Nope.

00:07:44.403 --> 00:07:45.150
Ha.

00:07:45.150 --> 00:07:47.530
Apparently I didn't do it right.

00:07:47.530 --> 00:07:48.030
OK.

00:07:48.030 --> 00:07:48.940
What's the problem here?

00:07:48.940 --> 00:07:50.648
AUDIENCE: Second dollar
sign on the text.

00:07:51.340 --> 00:07:52.890
TOR NORBYE: Oh, you're right.

00:07:52.890 --> 00:07:54.320
The audience got it.

00:07:54.320 --> 00:07:56.780
And then we have to
fix the value as well.

00:07:56.780 --> 00:07:58.910
Let's try again.

00:07:58.910 --> 00:08:01.580
We're searching and
we're seeing matches.

00:08:01.580 --> 00:08:05.260
So if I open this
here, it actually

00:08:05.260 --> 00:08:06.677
offers to preview
the replacement.

00:08:06.677 --> 00:08:08.051
So if I do that,
you can see it's

00:08:08.051 --> 00:08:09.390
going to do the right thing.

00:08:09.390 --> 00:08:11.390
So that removes the attribute.

00:08:11.390 --> 00:08:14.260
And now comes my favorite part.

00:08:14.260 --> 00:08:16.510
I'm going to open up
the Inspections UI.

00:08:16.510 --> 00:08:18.920
And I am going to navigate
to the Structural Search

00:08:18.920 --> 00:08:20.250
Inspection.

00:08:20.250 --> 00:08:23.910
I can turn this on, and I
can say that I actually want

00:08:23.910 --> 00:08:26.040
to add a Replace template here.

00:08:26.040 --> 00:08:28.800
And it's going to just show
the last one we just did.

00:08:28.800 --> 00:08:30.822
And when I add this
as an inspection,

00:08:30.822 --> 00:08:32.155
I can also add a message for it.

00:08:32.155 --> 00:08:35.120
So I'm going to say, please
don't include-- sorry

00:08:35.120 --> 00:08:37.240
about the missing
apostrophe-- please

00:08:37.240 --> 00:08:42.150
don't include
translation descriptions.

00:08:42.150 --> 00:08:46.910
And notice what happens when
we go back to our source file.

00:08:46.910 --> 00:08:49.920
It's telling us, hey,
this is not right.

00:08:49.920 --> 00:08:54.089
And if I invoke QuickFix,
oh, it's got it right there.

00:08:54.089 --> 00:08:55.380
And I can basically apply this.

00:08:55.380 --> 00:08:58.688
So we can turn a Structural
Search into a QuickFix.

00:08:58.688 --> 00:09:01.670
[APPLAUSE]

00:09:04.910 --> 00:09:08.910
So if I go back, maybe you have
Thread.sleep in your source

00:09:08.910 --> 00:09:11.210
code and you're not super
comfortable with having that.

00:09:11.210 --> 00:09:13.168
Someone filed a bug that
lint should flag this.

00:09:13.168 --> 00:09:15.350
And, you know, we
should flag that.

00:09:15.350 --> 00:09:17.510
But in the meantime,
if you have APIs

00:09:17.510 --> 00:09:20.940
that you want to blacklist in
your codebase at your company,

00:09:20.940 --> 00:09:22.830
you can do it with
Structural Search.

00:09:22.830 --> 00:09:26.160
So again, I will just do a
Search instead of a Replace

00:09:26.160 --> 00:09:27.110
now.

00:09:27.110 --> 00:09:30.152
Search Structurally.

00:09:30.152 --> 00:09:31.610
And we can search
for Thread.sleep.

00:09:31.610 --> 00:09:36.110
In fact, I'll just say that
any duration is a problem.

00:09:36.110 --> 00:09:37.980
And you can see
when I search, it's

00:09:37.980 --> 00:09:39.490
finding this element
syntactically.

00:09:39.490 --> 00:09:44.760
And I could turn that
into a warning again.

00:09:44.760 --> 00:09:48.956
Or the example that Romain Guy
came up with before this was,

00:09:48.956 --> 00:09:50.630
you can use this
action to replace

00:09:50.630 --> 00:09:52.140
deprecated APIs with new APIs.

00:09:52.140 --> 00:09:56.428
So this method is
deprecated, and you really

00:09:56.428 --> 00:09:58.840
should be calling setBackground.

00:09:58.840 --> 00:10:00.224
Said drawable again, I think.

00:10:00.224 --> 00:10:02.390
You could do another Search
and Replace on this API.

00:10:05.310 --> 00:10:08.180
All right, let's talk about
designtime attributes.

00:10:08.180 --> 00:10:11.070
So I'm going to switch
to the Topeka app.

00:10:11.070 --> 00:10:15.550
So this is the puzzle app
that we showed earlier.

00:10:15.550 --> 00:10:17.692
And the picture on
the left is what it

00:10:17.692 --> 00:10:18.900
should look like when we run.

00:10:18.900 --> 00:10:23.060
You can see that the designtime
is not looking quite as nice.

00:10:23.060 --> 00:10:25.330
And this layout is composed
of a couple of elements.

00:10:25.330 --> 00:10:28.320
So we have an included layout
for this avatar, so let's jump

00:10:28.320 --> 00:10:29.150
to that layout.

00:10:29.150 --> 00:10:30.970
Sign In Avatars.

00:10:30.970 --> 00:10:32.970
And you can see when I'm
looking at this layout,

00:10:32.970 --> 00:10:34.420
I'm only seeing the avatar list.

00:10:34.420 --> 00:10:37.800
I'm not seeing the list the way
it appears in the final layout.

00:10:37.800 --> 00:10:40.850
So for that, you can use
a designtime attribute.

00:10:40.850 --> 00:10:44.070
And one of the new things
we have in our current build

00:10:44.070 --> 00:10:47.290
is, code completion actually
for designtime attributes.

00:10:47.290 --> 00:10:48.980
So if I do Tools,
you can see we now

00:10:48.980 --> 00:10:50.727
have these things showing up.

00:10:50.727 --> 00:10:51.560
[SCATTERED APPLAUSE]

00:10:52.059 --> 00:10:53.330
Yay.

00:10:53.330 --> 00:10:55.871
And so I can now, for example,
say I want to show this in--

00:10:55.871 --> 00:10:57.870
and what is the name of
the layouts coming from,

00:10:57.870 --> 00:11:00.210
fragment_signin.

00:11:00.210 --> 00:11:02.950
If I do that, you
can see we now see

00:11:02.950 --> 00:11:06.320
this layout surrounded by the
place that will include it.

00:11:06.320 --> 00:11:08.704
And this, of course, is
sort of in translucent gray

00:11:08.704 --> 00:11:10.120
a little bit so
that you don't get

00:11:10.120 --> 00:11:11.620
confused about
what's in this layout

00:11:11.620 --> 00:11:14.080
and what's in the other layout.

00:11:14.080 --> 00:11:17.530
Comparing to the image
again, still a little ugly.

00:11:17.530 --> 00:11:20.690
We need to have more
columns over here.

00:11:20.690 --> 00:11:22.670
And so now the trick for
designtime attributes

00:11:22.670 --> 00:11:25.680
is that I could, of course,
just set the number of columns

00:11:25.680 --> 00:11:29.220
to something like four, right?

00:11:29.220 --> 00:11:31.880
But I don't want to do
that, because this column

00:11:31.880 --> 00:11:34.110
count is actually computed
by Java code at runtime.

00:11:34.110 --> 00:11:36.210
It looks at the width of
the screen, and the size

00:11:36.210 --> 00:11:37.590
of the images, and computes it.

00:11:37.590 --> 00:11:39.715
But at designtime I'm not
running that code, right?

00:11:39.715 --> 00:11:42.570
So let's just say we can put a
hard-coded value in the tool,

00:11:42.570 --> 00:11:43.480
but not at runtime.

00:11:43.480 --> 00:11:45.210
And the way we do that
is just to replace

00:11:45.210 --> 00:11:47.180
this with a tools namespace.

00:11:47.180 --> 00:11:50.260
So now you can see it still is
showing four columns over here,

00:11:50.260 --> 00:11:51.560
but at runtime, it would not.

00:11:51.560 --> 00:11:54.940
It's going to be continuing
to call the runtime code.

00:11:54.940 --> 00:11:56.899
So you can call any of
the standard attributes.

00:11:56.899 --> 00:11:58.690
You can just switch to
the tools namespace.

00:11:58.690 --> 00:12:00.930
When we build the app, we
strip out these attributes.

00:12:00.930 --> 00:12:03.760
So they're only
used at tooltime.

00:12:03.760 --> 00:12:05.460
Still looking not great. .

00:12:05.460 --> 00:12:08.945
So the other thing we can
do is, we can look at this.

00:12:08.945 --> 00:12:10.740
This is a GridView, right?

00:12:10.740 --> 00:12:12.560
Let's see how the
GridView is being used.

00:12:12.560 --> 00:12:14.960
So I do Find Usages and
we see that it's being

00:12:14.960 --> 00:12:17.780
used in the SignInFragment.

00:12:17.780 --> 00:12:20.670
And it's associated
with this AvatarAdapter.

00:12:20.670 --> 00:12:23.067
And the AvatarAdapter is
using this item_avatar layout.

00:12:23.067 --> 00:12:24.400
So let's go look at that layout.

00:12:27.120 --> 00:12:28.960
That looks not great.

00:12:28.960 --> 00:12:32.160
So this is in AvatarView,
which of course is

00:12:32.160 --> 00:12:36.960
being populated dynamically
with the right image, right?

00:12:36.960 --> 00:12:39.410
So one thing we can do, we
can just basically update

00:12:39.410 --> 00:12:41.797
the Custom View code
to call isInEditMode,

00:12:41.797 --> 00:12:43.380
which is going to
be true in the tool,

00:12:43.380 --> 00:12:47.090
but not when the app is running.

00:12:47.090 --> 00:12:49.930
We can also do this with
designtime attributes.

00:12:49.930 --> 00:12:51.690
And the way we
would do that is, we

00:12:51.690 --> 00:12:56.370
can say that we want to set
the source attribute to-- oh,

00:12:56.370 --> 00:12:58.300
let's see.

00:12:58.300 --> 00:12:59.420
Can I remember?

00:12:59.420 --> 00:13:00.420
It's @drawable/avatar_1.

00:13:04.010 --> 00:13:05.730
OK, so now we have our avatar_1.

00:13:08.270 --> 00:13:08.970
OK.

00:13:08.970 --> 00:13:14.380
And if we now switch back
to our list, it's not great.

00:13:14.380 --> 00:13:16.500
Because this whole
Find Usages thing

00:13:16.500 --> 00:13:18.999
I did, I was discovering what
layout will actually be used.

00:13:18.999 --> 00:13:20.290
That was all done through code.

00:13:20.290 --> 00:13:22.240
The adapter decides what to use.

00:13:22.240 --> 00:13:26.460
But again, we can use
tools attributes-- invoke

00:13:26.460 --> 00:13:30.480
code completion here-- to say
what listitem layout to use

00:13:30.480 --> 00:13:31.980
at design time.

00:13:31.980 --> 00:13:38.440
So here we can say that we
want to use item_avatar.

00:13:38.440 --> 00:13:40.960
And now you can
see, we actually are

00:13:40.960 --> 00:13:44.710
starting to see a layout that
looks pretty close to what's

00:13:44.710 --> 00:13:46.184
happening at runtime.

00:13:46.184 --> 00:13:48.850
I realize now that I've actually
done something really bad here.

00:13:48.850 --> 00:13:50.110
I hard-coded the icon to this.

00:13:50.110 --> 00:13:52.110
And I don't want to do
that, I want to switch it

00:13:52.110 --> 00:13:54.290
to the tools namespace.

00:13:54.290 --> 00:13:56.960
So if I do that, you can see
we have an intention now.

00:13:56.960 --> 00:14:00.522
So if you just write tools
anywhere, you came up QuickFix,

00:14:00.522 --> 00:14:01.480
and we have it for you.

00:14:01.480 --> 00:14:02.490
You don't have to
go and copy-paste it

00:14:02.490 --> 00:14:03.364
from some other file.

00:14:06.281 --> 00:14:06.780
All right.

00:14:06.780 --> 00:14:08.890
So that was
designtime attributes.

00:14:08.890 --> 00:14:12.969
Actually, let me find
back where I was.

00:14:12.969 --> 00:14:13.468
OK.

00:14:16.220 --> 00:14:17.140
All right.

00:14:17.140 --> 00:14:19.300
Let's talk about
privateResources.

00:14:19.300 --> 00:14:24.380
So in my content_main layout
out here, I am using a library.

00:14:24.380 --> 00:14:27.470
And you can see that
my code completion

00:14:27.470 --> 00:14:29.040
is getting filled
up with resources

00:14:29.040 --> 00:14:31.470
from this third-party
library, ccl.

00:14:31.470 --> 00:14:34.030
Whatever that is.

00:14:34.030 --> 00:14:35.660
And that was not intentional.

00:14:35.660 --> 00:14:37.460
Those strings are
used in the library,

00:14:37.460 --> 00:14:39.660
but they're not meant
for others to use them.

00:14:39.660 --> 00:14:42.850
So I can actually go into
the library source code.

00:14:42.850 --> 00:14:43.800
Where are you?

00:14:43.800 --> 00:14:45.110
OK, Library.

00:14:45.110 --> 00:14:46.400
Strings.

00:14:46.400 --> 00:14:48.850
Here you can see one of my
string files in the library.

00:14:48.850 --> 00:14:50.620
And I can say that
I basically want

00:14:50.620 --> 00:14:54.450
to set which resources are
exported from this library,

00:14:54.450 --> 00:14:57.534
and everything else will
be treated as private.

00:14:57.534 --> 00:14:59.450
By the way, one thing I
want to show you first

00:14:59.450 --> 00:15:01.450
is, you can see it's
highlighting here that this

00:15:01.450 --> 00:15:03.260
is an unexpected resource name.

00:15:03.260 --> 00:15:05.570
That's because we have this
feature for a library where

00:15:05.570 --> 00:15:06.980
you can, in the
build.gradle, say

00:15:06.980 --> 00:15:10.180
that you want your resources
to all have a certain prefix.

00:15:10.180 --> 00:15:12.790
And if you declare a resource
that doesn't have that prefix,

00:15:12.790 --> 00:15:13.730
we will warn you about that.

00:15:13.730 --> 00:15:15.646
So you can sort of be
consistent in how you're

00:15:15.646 --> 00:15:16.781
declaring your resources.

00:15:16.781 --> 00:15:17.280
Right.

00:15:17.280 --> 00:15:20.750
So now we're going to go and
say that the only resource we

00:15:20.750 --> 00:15:23.730
exposed from this
app is this one.

00:15:23.730 --> 00:15:26.760
So to do that, we can
create an XML file.

00:15:26.760 --> 00:15:29.270
It doesn't matter
what you call it.

00:15:29.270 --> 00:15:33.839
I think the best name for it
probably would be public.xml.

00:15:33.839 --> 00:15:35.630
Sadly, we don't let
you create one of those

00:15:35.630 --> 00:15:36.730
because it's a keyword.

00:15:36.730 --> 00:15:39.800
But that's a bug, because
it's OK for values.

00:15:39.800 --> 00:15:43.850
So I'm just going to cheat
and use New File instead.

00:15:43.850 --> 00:15:46.830
And I'm going to
put it here and I'm

00:15:46.830 --> 00:15:49.424
going to call it public.xml.

00:15:49.424 --> 00:15:51.740
Resources.

00:15:51.740 --> 00:15:54.161
And the keyword public
is what you use.

00:15:54.161 --> 00:15:55.410
This is another resource type.

00:15:55.410 --> 00:15:57.700
You can also write item
and then type="public,"

00:15:57.700 --> 00:15:59.414
but public like this.

00:15:59.414 --> 00:16:02.080
And I already forgot the name of
the resource we want to expose.

00:16:02.080 --> 00:16:04.317
Well, let's do the first one.

00:16:04.317 --> 00:16:05.900
And then you have
to declare the type.

00:16:05.900 --> 00:16:10.026
And it's a type="string."

00:16:10.026 --> 00:16:11.150
So now we've declared this.

00:16:11.150 --> 00:16:13.170
And I actually have
to compile my app,

00:16:13.170 --> 00:16:15.040
because the public
declaration is

00:16:15.040 --> 00:16:17.480
written into this
part of the AAR file

00:16:17.480 --> 00:16:21.750
that the clients will read.

00:16:21.750 --> 00:16:25.020
So we are building.

00:16:25.020 --> 00:16:29.630
And if I go back now
to my app module, which

00:16:29.630 --> 00:16:34.980
is digesting the library, what
should happen-- hopefully--

00:16:34.980 --> 00:16:37.119
is that when I invoke
code completion, yes.

00:16:37.119 --> 00:16:39.160
You can see, it's filtered
out all the CCL stuff.

00:16:39.160 --> 00:16:42.480
So we only get the one
thing we basically exposed.

00:16:42.480 --> 00:16:45.490
And in fact, if I were to try
to use some other resource,

00:16:45.490 --> 00:16:48.150
or if I had been bad
in the past and used

00:16:48.150 --> 00:16:50.880
one of these things that
weren't intended to be used,

00:16:50.880 --> 00:16:53.371
if I use it, you
can see we actually

00:16:53.371 --> 00:16:55.620
warn you that you are using
a resource that you're not

00:16:55.620 --> 00:16:56.470
supposed to use.

00:16:56.470 --> 00:16:58.157
So if you have a
library, you definitely

00:16:58.157 --> 00:16:59.990
want to look at all the
things you're using.

00:16:59.990 --> 00:17:01.370
Your drawables, your styles.

00:17:01.370 --> 00:17:02.480
And make sure that
you really are only

00:17:02.480 --> 00:17:04.688
exposing for clients the
things that they want to see

00:17:04.688 --> 00:17:07.569
in their code completion list.

00:17:07.569 --> 00:17:08.290
All right.

00:17:08.290 --> 00:17:13.180
The last thing I will show
you is resource shrinking.

00:17:13.180 --> 00:17:16.190
So resource shrinking
is basically

00:17:16.190 --> 00:17:20.082
a way to let you strip out
all the assets from libraries

00:17:20.082 --> 00:17:21.290
that you don't actually need.

00:17:21.290 --> 00:17:23.045
So if you depend
on a large library,

00:17:23.045 --> 00:17:24.420
let's say, you
know, all the Play

00:17:24.420 --> 00:17:27.134
Services, which might include
graphics for the Login button.

00:17:27.134 --> 00:17:29.050
And you're not actually
calling those methods,

00:17:29.050 --> 00:17:30.520
you can get rid of those.

00:17:30.520 --> 00:17:32.394
You can't go to the
source code and delete it

00:17:32.394 --> 00:17:34.580
but we can look at the code
you're actually calling,

00:17:34.580 --> 00:17:36.746
then we can strip out the
stuff that's not relevant.

00:17:36.746 --> 00:17:42.050
So the way that works is
that, in my build.gradle

00:17:42.050 --> 00:17:44.810
I say, shrinkResources true.

00:17:44.810 --> 00:17:47.100
By the way, this only
works for when you actually

00:17:47.100 --> 00:17:49.940
are shrinking, right?

00:17:49.940 --> 00:17:51.640
We could make it
work without it,

00:17:51.640 --> 00:17:53.740
but it's not really much
of a point in that case.

00:17:53.740 --> 00:17:55.380
So this is when
you are at the end,

00:17:55.380 --> 00:17:56.890
you're having ProGuard
go in and figure out

00:17:56.890 --> 00:17:58.200
exactly the call
graph you're using,

00:17:58.200 --> 00:17:59.408
and deleting everything else.

00:17:59.408 --> 00:18:01.450
And that's what frees up
these resources, right?

00:18:01.450 --> 00:18:02.866
If you're using
the Login library,

00:18:02.866 --> 00:18:05.429
Play Services is referencing
those icons, right?

00:18:05.429 --> 00:18:06.470
For the sign in function.

00:18:06.470 --> 00:18:07.530
If you're not
calling that function

00:18:07.530 --> 00:18:09.990
and we strip out that code,
well, then the resources

00:18:09.990 --> 00:18:11.990
become eligible for
deletion as well.

00:18:11.990 --> 00:18:13.990
So you can do
shrinkResources true.

00:18:13.990 --> 00:18:17.990
And when you've done
that, our code will

00:18:17.990 --> 00:18:23.640
be very careful to try not
to delete your code, right?

00:18:23.640 --> 00:18:27.070
So for example, if we see
that you have code like this,

00:18:27.070 --> 00:18:28.114
img_%d.

00:18:28.114 --> 00:18:30.530
So you're formatting something,
and then you're passing it

00:18:30.530 --> 00:18:33.420
to this resource manager,
that .get identifier.

00:18:33.420 --> 00:18:35.610
We don't dare to delete
any resource that

00:18:35.610 --> 00:18:37.000
starts with the prefix img.

00:18:37.000 --> 00:18:37.500
Right?

00:18:37.500 --> 00:18:40.660
Because this is basically
an escape clause to get

00:18:40.660 --> 00:18:43.080
access to any resource by name.

00:18:43.080 --> 00:18:45.890
So that's what we do
by default, to try

00:18:45.890 --> 00:18:47.070
to not make the app crash.

00:18:47.070 --> 00:18:49.670
But there actually is a way
with designtime attributes

00:18:49.670 --> 00:18:53.610
to tell us that you don't
want us to be that careful.

00:18:53.610 --> 00:18:56.280
So the way you do that is,
you go into some value file.

00:18:56.280 --> 00:18:59.810
I'm going to use
strings.xml, because why not?

00:18:59.810 --> 00:19:01.232
And here I can say tools:.

00:19:01.232 --> 00:19:02.440
I'll add the tools namespace.

00:19:06.180 --> 00:19:06.802
All right.

00:19:06.802 --> 00:19:09.260
OK, we haven't actually added
strictMode to the completion,

00:19:09.260 --> 00:19:10.150
that's too bad.

00:19:10.150 --> 00:19:13.850
So "safe" is what you
usually get out of the box.

00:19:13.850 --> 00:19:16.060
If you switch this
to "strict," then we

00:19:16.060 --> 00:19:20.140
will not consider
reflection as a possibility.

00:19:20.140 --> 00:19:21.950
If you do this, then
you are in charge,

00:19:21.950 --> 00:19:23.590
just like with
ProGuard, of providing

00:19:23.590 --> 00:19:24.720
the keep rules, right?

00:19:24.720 --> 00:19:29.620
So tools:"keep" is how you
specify a comma-separated list

00:19:29.620 --> 00:19:33.380
of resources that you know
might be called from code.

00:19:33.380 --> 00:19:35.205
And you can also
do tools:"discard"

00:19:35.205 --> 00:19:37.810
if you want to, basically,
something that you want

00:19:37.810 --> 00:19:40.450
to discard even though somehow
we didn't figure out that it

00:19:40.450 --> 00:19:43.200
was eligible for deletion.

00:19:43.200 --> 00:19:46.440
And I think, with that, I
am going to turn it over

00:19:46.440 --> 00:19:48.570
to the next speaker.

00:19:48.570 --> 00:19:50.740
Siva is going to show you
how to use the Debugger.

00:19:50.740 --> 00:19:56.404
[APPLAUSE]

00:19:58.300 --> 00:19:59.730
SIVA VELUSAMY: Thank you, Tor.

00:19:59.730 --> 00:20:00.620
Welcome, everyone.

00:20:00.620 --> 00:20:03.490
I'm going to spend the next
five minutes giving you guys

00:20:03.490 --> 00:20:06.480
a few tricks about how
to use the Debugger.

00:20:06.480 --> 00:20:10.090
So let me start with a very
common operation that I do,

00:20:10.090 --> 00:20:12.910
which is I receive a stacktrace.

00:20:12.910 --> 00:20:14.970
A long time I used to
look at the stacktrace,

00:20:14.970 --> 00:20:17.370
find the last file, and
then go back to the ID

00:20:17.370 --> 00:20:19.106
to locate the class.

00:20:19.106 --> 00:20:20.970
A trick that I
learned recently is,

00:20:20.970 --> 00:20:24.690
you just have to search
for Analyze Stacktrace.

00:20:24.690 --> 00:20:26.510
So I press
Command-Shift-A, which

00:20:26.510 --> 00:20:28.250
is find an action by name.

00:20:28.250 --> 00:20:29.630
That's a very useful shortcut.

00:20:29.630 --> 00:20:32.100
You do that, and you just start
typing for whatever action

00:20:32.100 --> 00:20:32.949
you're looking for.

00:20:32.949 --> 00:20:33.990
I type AnalyzeStacktrace.

00:20:37.030 --> 00:20:39.630
Let me just select all of
this, and then I do that.

00:20:39.630 --> 00:20:43.560
It automatically fills
this dialog with whatever

00:20:43.560 --> 00:20:45.100
you have on the clipboard.

00:20:45.100 --> 00:20:49.680
And you just press OK, and
that will automatically

00:20:49.680 --> 00:20:54.450
populate a console with a
clickable list of the files.

00:20:54.450 --> 00:20:56.560
Now, what is
actually even cooler

00:20:56.560 --> 00:20:59.510
about this
AnalyzeStacktrace dialog is,

00:20:59.510 --> 00:21:01.630
there are actually
two options here.

00:21:01.630 --> 00:21:04.570
At the top there's an option
to Unscramble your Stacktrace.

00:21:04.570 --> 00:21:06.360
So in case you are
using ProGuard,

00:21:06.360 --> 00:21:07.950
and you have a
scrambled stacktrace,

00:21:07.950 --> 00:21:10.980
then you'd use the ProGuard
Unscramble plug-in.

00:21:10.980 --> 00:21:13.870
And that would be able to
normalize the stack trace.

00:21:13.870 --> 00:21:19.070
And at the very end, you have an
option to show the VCS history.

00:21:19.070 --> 00:21:24.680
So in case you have .get, or any
other version control system,

00:21:24.680 --> 00:21:27.080
plugged into your
project and you do this,

00:21:27.080 --> 00:21:31.860
it will actually mark the files
that have changed in the last n

00:21:31.860 --> 00:21:32.930
number of days.

00:21:32.930 --> 00:21:36.880
And you can actually
also conveniently

00:21:36.880 --> 00:21:42.810
look at who committed it,
and not to pick on Ben here.

00:21:42.810 --> 00:21:44.710
So that is AnalyzeStacktrace.

00:21:44.710 --> 00:21:47.059
I hope you find it useful.

00:21:47.059 --> 00:21:48.600
And now let's switch
to the Debugger.

00:21:48.600 --> 00:21:51.480
I already have the Debugger
connected to a running app

00:21:51.480 --> 00:21:53.750
and I am waiting
on a breakpoint.

00:21:53.750 --> 00:21:55.900
I'll show you a bunch
of things that you can

00:21:55.900 --> 00:21:58.290
explore in the Variables view.

00:21:58.290 --> 00:22:02.210
So the Variables view, which
is down here at the bottom,

00:22:02.210 --> 00:22:05.136
you see all the local
variables and fields.

00:22:08.230 --> 00:22:11.470
By default, you would know
about the renderings for all

00:22:11.470 --> 00:22:14.850
the objects which just
use their toString method,

00:22:14.850 --> 00:22:18.260
and just displays that object
using its object.toString.

00:22:18.260 --> 00:22:22.217
And for primitive types you
just render it as a primitive.

00:22:22.217 --> 00:22:24.800
We have a few other additions,
which is, for instance, in case

00:22:24.800 --> 00:22:28.790
you have a bitmap, you can click
on this to view the bitmap.

00:22:28.790 --> 00:22:31.270
That works for bitmaps
and bitmap drawables.

00:22:31.270 --> 00:22:33.740
And then let's say I'm
in a different place,

00:22:33.740 --> 00:22:37.500
and now I'm looking at different
things such as primitives.

00:22:37.500 --> 00:22:42.750
Now Android, we use primitives
to express a lot of types.

00:22:42.750 --> 00:22:47.110
So we use integers as enums,
as colors, as our references

00:22:47.110 --> 00:22:49.870
to resources, as resource IDs.

00:22:49.870 --> 00:22:52.050
And are many times
when you have an ID

00:22:52.050 --> 00:22:54.650
and you don't know
exactly what it means,

00:22:54.650 --> 00:22:59.510
you could just see View As
and select the type integer.

00:22:59.510 --> 00:23:03.220
And so an Android
type integer would

00:23:03.220 --> 00:23:07.814
be able to resolve
it to its reference.

00:23:07.814 --> 00:23:09.230
In this particular
case it happens

00:23:09.230 --> 00:23:11.560
to be a reference to a drawable.

00:23:11.560 --> 00:23:12.870
Now how does this work?

00:23:12.870 --> 00:23:15.560
This works because
of annotations

00:23:15.560 --> 00:23:16.770
that you might have.

00:23:16.770 --> 00:23:19.430
You already have annotations
in the platform source code,

00:23:19.430 --> 00:23:22.080
but you could also have
annotations in your own source

00:23:22.080 --> 00:23:22.580
codes.

00:23:22.580 --> 00:23:25.030
In this particular
case, this variable

00:23:25.030 --> 00:23:27.890
was actually annotated
as a drawable resource.

00:23:27.890 --> 00:23:33.670
And so the annotation could
be on the local variable,

00:23:33.670 --> 00:23:36.410
it could be on a field, it
could even be on the getter.

00:23:36.410 --> 00:23:39.240
We would do sufficient flow
analysis to figure out,

00:23:39.240 --> 00:23:40.960
what is the
corresponding annotation?

00:23:40.960 --> 00:23:45.230
And then render an integer
in an appropriate manner.

00:23:45.230 --> 00:23:48.200
This works not just for
reference to resource,

00:23:48.200 --> 00:23:49.890
but in this particular
case, let's say

00:23:49.890 --> 00:23:55.310
I have a variable that's
called a color, but again,

00:23:55.310 --> 00:23:58.190
a Typed Integer,
and it references

00:23:58.190 --> 00:24:00.500
to a themed background.

00:24:00.500 --> 00:24:03.570
Same with just regular colors.

00:24:03.570 --> 00:24:08.880
You would see it renders
it properly as a color.

00:24:08.880 --> 00:24:13.780
So that is viewing
primitive types.

00:24:13.780 --> 00:24:16.730
So, so far we've looked
at just the bitmap,

00:24:16.730 --> 00:24:19.930
and then we've looked at how
to render certain primitives.

00:24:19.930 --> 00:24:23.670
The other option is, you might
want to do your own custom

00:24:23.670 --> 00:24:24.170
rendering.

00:24:24.170 --> 00:24:27.651
So for instance, instead
of the toString method,

00:24:27.651 --> 00:24:29.150
you might want to
render your object

00:24:29.150 --> 00:24:31.060
in a slightly different way.

00:24:31.060 --> 00:24:37.430
In this particular class,
this is the onBindViewHolder,

00:24:37.430 --> 00:24:39.060
part of the RecyclerView API.

00:24:39.060 --> 00:24:43.395
And the model object
for this list,

00:24:43.395 --> 00:24:45.660
it holds a list of categories.

00:24:45.660 --> 00:24:48.000
And if you look at the list
of categories by default,

00:24:48.000 --> 00:24:49.420
this is what is shown there.

00:24:49.420 --> 00:24:53.940
It basically shows the
toString of each category,

00:24:53.940 --> 00:24:57.990
and many times it may not be
exactly what you want to show.

00:24:57.990 --> 00:25:01.530
So an easy thing to do is just
right-click on it and then

00:25:01.530 --> 00:25:04.040
Customize Data View for it.

00:25:04.040 --> 00:25:06.050
And you would go to
Java Type Renderers

00:25:06.050 --> 00:25:07.997
and you would add a new one.

00:25:07.997 --> 00:25:08.955
Let's call it category.

00:25:11.750 --> 00:25:15.625
And the object that you want
to customize is a Category.

00:25:20.810 --> 00:25:22.410
So that's over here.

00:25:22.410 --> 00:25:24.890
And then, instead of using
the default renderer,

00:25:24.890 --> 00:25:27.920
you want to do something like,
I just want to show the name.

00:25:27.920 --> 00:25:31.440
Or I want to show the name
plus-- this is a quiz app,

00:25:31.440 --> 00:25:33.654
so it has a bunch of
questions-- so you

00:25:33.654 --> 00:25:35.320
say you say that, I
want to see the name

00:25:35.320 --> 00:25:36.486
and the number of questions.

00:25:36.486 --> 00:25:38.090
Which would be
getQuizzes().size().

00:25:42.080 --> 00:25:55.940
So I do this, and now you'll
see that each category gets--

00:25:55.940 --> 00:25:58.293
as soon as we get this running.

00:26:01.664 --> 00:26:03.080
Maybe I made a
mistake over there.

00:26:18.435 --> 00:26:18.935
Ah, well.

00:26:18.935 --> 00:26:22.250
It looks like a demo
issue right now.

00:26:22.250 --> 00:26:24.452
But in theory, if
it's a category

00:26:24.452 --> 00:26:26.410
it'll show you whatever
custom rendering you've

00:26:26.410 --> 00:26:27.680
done over there.

00:26:27.680 --> 00:26:29.440
Sorry about that.

00:26:29.440 --> 00:26:32.570
I'm not actually sure
what happened over there.

00:26:32.570 --> 00:26:33.070
All right.

00:26:33.070 --> 00:26:34.880
Let's move on to
the next one, which

00:26:34.880 --> 00:26:39.430
is, how do you
evaluate expressions

00:26:39.430 --> 00:26:40.650
when you're over here?

00:26:40.650 --> 00:26:44.740
So one common thing we
see is that any time when

00:26:44.740 --> 00:26:47.910
you want to explore what is
happening inside a program,

00:26:47.910 --> 00:26:49.620
and you're waiting
on a breakpoint,

00:26:49.620 --> 00:26:51.610
you can actually
select a bunch of text.

00:26:51.610 --> 00:26:53.800
Let's say in this
particular case I have this.

00:26:53.800 --> 00:26:59.720
And evaluate and invoke the
Evaluate Expression option.

00:26:59.720 --> 00:27:03.180
And over here you can actually
invoke whatever you want.

00:27:03.180 --> 00:27:05.990
So in this particular case,
I have a variable category.

00:27:05.990 --> 00:27:08.250
I can do all the operations.

00:27:08.250 --> 00:27:13.000
I can basically query
methods on that object.

00:27:13.000 --> 00:27:15.170
And it's not isolated
to just that object,

00:27:15.170 --> 00:27:18.060
you can query for
whatever is in this code.

00:27:18.060 --> 00:27:21.520
So this is extremely
useful when you

00:27:21.520 --> 00:27:25.620
have a bunch of Boolean
expressions combined together

00:27:25.620 --> 00:27:29.250
and you want to see which one
is actually false or true.

00:27:29.250 --> 00:27:32.270
You can actually explore
entire APIs this way.

00:27:32.270 --> 00:27:35.100
So if you have a
bunch of JSON values

00:27:35.100 --> 00:27:37.160
and you want to see
how it's structured,

00:27:37.160 --> 00:27:38.840
you would just
open it up in this.

00:27:38.840 --> 00:27:44.660
And then just gradually
query different methods

00:27:44.660 --> 00:27:46.610
to see exactly what you want.

00:27:46.610 --> 00:27:49.750
That is Evaluate Expressions.

00:27:49.750 --> 00:27:53.050
So, so far we've looked at what
you can do when you're actually

00:27:53.050 --> 00:27:54.370
waiting on a breakpoint.

00:27:54.370 --> 00:27:56.710
The other thing I want
to show is actually

00:27:56.710 --> 00:28:00.020
setting these breakpoints in
a very conditional manner.

00:28:00.020 --> 00:28:02.360
So in this particular
case, let's say, again,

00:28:02.360 --> 00:28:03.900
I'm on a RecyclerView.

00:28:03.900 --> 00:28:05.520
It has a whole
bunch of elements.

00:28:05.520 --> 00:28:08.480
I press Continue, it'll again
come back and read over here.

00:28:11.570 --> 00:28:14.660
So instead of having to do
Continue again and again,

00:28:14.660 --> 00:28:17.760
you might want to
make this conditional.

00:28:17.760 --> 00:28:20.360
So in this particular case,
you can make it conditional

00:28:20.360 --> 00:28:24.990
on category.get
Name().equals something.

00:28:24.990 --> 00:28:28.800
So that way you only stop
at a particular breakpoint

00:28:28.800 --> 00:28:32.094
if you know the exact condition
when you actually have to stop.

00:28:32.094 --> 00:28:34.010
But in case you don't
know the exact condition

00:28:34.010 --> 00:28:36.500
when you want to stop,
your normal recourse

00:28:36.500 --> 00:28:39.130
would be, maybe you add a log
statement there, you rebuild,

00:28:39.130 --> 00:28:40.040
re-upload.

00:28:40.040 --> 00:28:42.200
Instead of doing
that, you can actually

00:28:42.200 --> 00:28:46.320
modify the breakpoint itself
to log a particular expression

00:28:46.320 --> 00:28:48.080
whenever it hits the breakpoint.

00:28:48.080 --> 00:28:51.750
To do that, you would go
into the More Options here,

00:28:51.750 --> 00:28:53.950
and then you would
deselect the Suspend.

00:28:53.950 --> 00:28:55.530
So that when it
hits a breakpoint,

00:28:55.530 --> 00:28:57.010
you don't actually
want to suspend.

00:28:57.010 --> 00:29:00.180
But instead you want to
log a particular expression

00:29:00.180 --> 00:29:01.820
that you evaluate.

00:29:01.820 --> 00:29:05.870
So let's say I just want to
see what the category name is

00:29:05.870 --> 00:29:07.600
whenever it comes over here.

00:29:07.600 --> 00:29:10.993
And I press Continue.

00:29:10.993 --> 00:29:12.310
Let me move this breakpoint.

00:29:16.110 --> 00:29:18.740
Over here you started
seeing the category names

00:29:18.740 --> 00:29:24.160
being-- so you can see as I go
through it-- whenever it hits

00:29:24.160 --> 00:29:27.500
the breakpoint, it'll basically
log exactly the expression

00:29:27.500 --> 00:29:30.050
that you have
provided over there.

00:29:30.050 --> 00:29:31.360
That is actually all I had.

00:29:31.360 --> 00:29:32.810
I hope you found it useful.

00:29:32.810 --> 00:29:33.553
Thank you.

00:29:33.553 --> 00:29:38.060
[APPLAUSE]

00:29:38.896 --> 00:29:40.020
ALEX RUIZ: Thank you, Siva.

00:29:40.020 --> 00:29:41.300
My name is Alex.

00:29:41.300 --> 00:29:43.720
I'm going to talk about
Gradle integration.

00:29:43.720 --> 00:29:48.440
One of the common questions
that we get from the other

00:29:48.440 --> 00:29:53.166
developers using Eclipse is,
I have this compile .aar,

00:29:53.166 --> 00:29:55.810
aar This library that I'm
using my Eclipse projects.

00:29:55.810 --> 00:30:00.170
But I also want to use it for
my new app in Android Studio.

00:30:00.170 --> 00:30:01.620
What do we do?

00:30:01.620 --> 00:30:05.240
So we can either copy the
file, there is a lot of things

00:30:05.240 --> 00:30:06.250
that we can do.

00:30:06.250 --> 00:30:11.590
Create a local Maven repository
and install that .aar there.

00:30:11.590 --> 00:30:15.040
But Android Studio actually
provides a very nice shortcut.

00:30:15.040 --> 00:30:18.200
And you can actually import
the compile .aar as a regular

00:30:18.200 --> 00:30:18.820
module.

00:30:18.820 --> 00:30:22.330
And I'm going to show you how.

00:30:22.330 --> 00:30:24.576
So we create first a New Module.

00:30:28.830 --> 00:30:32.720
Then we select
Import .AAR Package.

00:30:32.720 --> 00:30:38.640
After you click Import, this
wizard is going to ask you

00:30:38.640 --> 00:30:41.150
for the path in the file system
of the .aar that you want

00:30:41.150 --> 00:30:42.410
to import.

00:30:42.410 --> 00:30:44.100
To save some time,
I already did this,

00:30:44.100 --> 00:30:45.933
and I'm going to show
you how it looks like.

00:30:48.460 --> 00:30:52.690
So here, there it is.

00:30:52.690 --> 00:30:56.530
That's the module that was
created by Android Studio.

00:30:56.530 --> 00:30:59.080
It creates the module,
the buld.gradle file,

00:30:59.080 --> 00:31:01.650
and also the .aar
that is wrapping.

00:31:01.650 --> 00:31:06.820
After that, I added a
dependency in my app,

00:31:06.820 --> 00:31:11.310
just like I would depend
on any other module here,

00:31:11.310 --> 00:31:13.130
and I'm ready to use this code.

00:31:13.130 --> 00:31:15.770
For this example, I
imported a tip calculator.

00:31:15.770 --> 00:31:21.116
So now in My Activity, I can
just start using the code.

00:31:25.530 --> 00:31:26.130
Very simple.

00:31:29.390 --> 00:31:33.110
The second tip for the Gradle
integration in Android Studio

00:31:33.110 --> 00:31:38.980
is, how do I run any Gradle
task without leaving my ID?

00:31:38.980 --> 00:31:40.820
So this is something
very handy that we

00:31:40.820 --> 00:31:46.610
inherit from IntelliJ IDEA,
which is the Gradle Task View.

00:31:46.610 --> 00:31:49.350
So here you are going to see
all the Gradle tasks that

00:31:49.350 --> 00:31:51.360
are available for your project.

00:31:51.360 --> 00:31:55.300
They are categorized
by the top level

00:31:55.300 --> 00:31:58.490
module, which is the project.

00:31:58.490 --> 00:32:01.700
And here for example, I'm
going to select Dependencies.

00:32:01.700 --> 00:32:03.936
So if you're familiar
with Dependencies tasks,

00:32:03.936 --> 00:32:05.560
it's going to show
you a very nice tree

00:32:05.560 --> 00:32:08.050
view of all the
dependencies of your module.

00:32:08.050 --> 00:32:10.640
So I'm going to just
double click this.

00:32:10.640 --> 00:32:11.556
It's going to execute.

00:32:16.555 --> 00:32:17.055
Executing.

00:32:22.090 --> 00:32:25.190
Well, sadly it didn't like
the way it was executed.

00:32:25.190 --> 00:32:27.390
Because to execute
dependencies you

00:32:27.390 --> 00:32:32.770
have to prepend the Gradle path
of the module you're using.

00:32:32.770 --> 00:32:34.520
But we can fix that very easily.

00:32:34.520 --> 00:32:38.000
The cool thing about this is
that the IDE Android Studio

00:32:38.000 --> 00:32:40.700
will create the ROM
configuration for that task

00:32:40.700 --> 00:32:42.860
that you just executed.

00:32:42.860 --> 00:32:47.070
So we go here, we added
the configuration.

00:32:47.070 --> 00:32:48.470
It's this one.

00:32:48.470 --> 00:32:50.280
We fix it.

00:32:50.280 --> 00:32:52.870
Oops.

00:32:52.870 --> 00:32:53.750
There.

00:32:53.750 --> 00:33:02.152
We apply the changes, click OK,
Run again, and there you go.

00:33:02.152 --> 00:33:04.110
The problem is that the
text is a little small,

00:33:04.110 --> 00:33:05.220
so you cannot see it.

00:33:05.220 --> 00:33:06.700
But it's there.

00:33:06.700 --> 00:33:09.746
And it looks very cool.

00:33:09.746 --> 00:33:11.495
So besides creating
the ROM configuration,

00:33:11.495 --> 00:33:13.540
it'll allow you to edit it.

00:33:13.540 --> 00:33:14.470
You can save it.

00:33:14.470 --> 00:33:16.540
So you can preserve
that ROM configuration

00:33:16.540 --> 00:33:20.650
between ID sessions,
which is pretty handy.

00:33:20.650 --> 00:33:24.820
And the last thing I'd like to
talk about is build variants.

00:33:24.820 --> 00:33:27.635
So by now, I am assuming
that everybody here

00:33:27.635 --> 00:33:29.260
is familiar with
build variants, right?

00:33:29.260 --> 00:33:30.780
Please raise your hand.

00:33:30.780 --> 00:33:31.370
Yeah?

00:33:31.370 --> 00:33:31.870
Yeah.

00:33:31.870 --> 00:33:34.350
For the folks who
didn't raise your hand,

00:33:34.350 --> 00:33:37.900
I recommend you to please
watch the Gradle talk

00:33:37.900 --> 00:33:39.600
when it's available online.

00:33:39.600 --> 00:33:43.140
So build variants are different
flavors of your application

00:33:43.140 --> 00:33:44.850
inside your codebase.

00:33:44.850 --> 00:33:48.360
And we usually get asked,
where do I see these things?

00:33:48.360 --> 00:33:51.320
And they're kind of
hidden in the ID.

00:33:51.320 --> 00:33:52.250
So they are here.

00:33:52.250 --> 00:33:57.230
So actually, let me
minimize this and this.

00:33:57.230 --> 00:33:58.259
So, here.

00:33:58.259 --> 00:33:59.800
So this is the Build
Variants window,

00:33:59.800 --> 00:34:02.460
it's on the bottom left.

00:34:02.460 --> 00:34:05.590
And here you have the list
of modules in your project.

00:34:05.590 --> 00:34:08.330
These are only Android
modules, because they are

00:34:08.330 --> 00:34:10.580
the ones with build variants.

00:34:10.580 --> 00:34:14.130
And here, each
row for the module

00:34:14.130 --> 00:34:17.389
has a drop-down where you
can select the variant you

00:34:17.389 --> 00:34:18.510
want to work on.

00:34:18.510 --> 00:34:21.699
You can work only with
one variant at a time.

00:34:21.699 --> 00:34:24.400
Something that's a little
sad is that each build

00:34:24.400 --> 00:34:26.982
variant has two test artifacts.

00:34:26.982 --> 00:34:28.929
And because some
limitations in the ID

00:34:28.929 --> 00:34:33.360
before, you can only work with
one test artifact at a time.

00:34:33.360 --> 00:34:37.110
So you can either work with
Android tests or unit tests,

00:34:37.110 --> 00:34:37.900
but not both.

00:34:37.900 --> 00:34:40.570
So if you want to run
tests continuously,

00:34:40.570 --> 00:34:42.389
you have to keep
switching between them,

00:34:42.389 --> 00:34:44.719
which is not very convenient.

00:34:44.719 --> 00:34:48.530
And another thing is that by
having only one test artifact

00:34:48.530 --> 00:34:52.170
enabled at the same time,
one table at a time,

00:34:52.170 --> 00:34:53.530
refactoring doesn't work.

00:34:53.530 --> 00:34:56.040
And I'll show you
what do I mean.

00:34:56.040 --> 00:35:00.026
So let's say that I have
Android tests enabled.

00:35:00.026 --> 00:35:02.500
And I have this method here.

00:35:02.500 --> 00:35:03.426
I rename it.

00:35:08.220 --> 00:35:09.220
There.

00:35:09.220 --> 00:35:15.930
So my Android test participated
in the automatic refactoring

00:35:15.930 --> 00:35:17.910
and was updated properly.

00:35:17.910 --> 00:35:22.150
But the problem is that
the unit test wasn't,

00:35:22.150 --> 00:35:23.940
because it's not enabled.

00:35:23.940 --> 00:35:28.570
So when they switch to
unit tests, it's broken.

00:35:28.570 --> 00:35:31.210
And then you have to
manually fix that.

00:35:31.210 --> 00:35:35.670
That's not really awesome.

00:35:35.670 --> 00:35:36.721
So let's undo that.

00:35:44.590 --> 00:35:45.090
Yeah.

00:35:51.585 --> 00:35:52.700
Let's remove this.

00:35:55.340 --> 00:35:56.130
OK.

00:35:56.130 --> 00:35:59.320
So, how can we
make things better?

00:35:59.320 --> 00:36:02.190
So, starting with
Android Studio 2.0,

00:36:02.190 --> 00:36:06.040
you can have both test artifacts
enabled at the same time.

00:36:06.040 --> 00:36:09.280
It is an experimental feature,
it's not on by default.

00:36:09.280 --> 00:36:12.470
But it will be super great if
you can try it out and give us

00:36:12.470 --> 00:36:13.780
some feedback.

00:36:13.780 --> 00:36:15.480
How to enable this?

00:36:15.480 --> 00:36:21.500
You go to the Preferences
and there is a tab.

00:36:21.500 --> 00:36:25.005
So you go to Build, Execution,
Deployment&gt; Build Tools&gt;

00:36:25.005 --> 00:36:26.850
Gradle&gt; Experimental.

00:36:26.850 --> 00:36:32.590
And there is this option,
Enable All Test Artifacts.

00:36:32.590 --> 00:36:35.642
You enable that, click OK.

00:36:35.642 --> 00:36:36.600
That drop-down is gone.

00:36:39.380 --> 00:36:40.648
The unit test is active.

00:36:44.720 --> 00:36:47.770
Also, I wanted to show
you something else.

00:36:47.770 --> 00:36:50.050
If you see the Android
test, the folder

00:36:50.050 --> 00:36:53.220
has a little Android head there.

00:36:53.220 --> 00:36:55.760
So at least you can
somehow distinguish

00:36:55.760 --> 00:36:58.750
which one is the unit
test and the Android test.

00:36:58.750 --> 00:37:06.650
And now if I refactor this
again like I did before,

00:37:06.650 --> 00:37:07.440
now, let's see.

00:37:07.440 --> 00:37:09.490
Android test.

00:37:09.490 --> 00:37:10.380
Beautiful.

00:37:10.380 --> 00:37:11.910
It was updated.

00:37:11.910 --> 00:37:14.990
And also the unit
test was updated.

00:37:14.990 --> 00:37:15.490
Yeah.

00:37:15.490 --> 00:37:19.135
[APPLAUSE]

00:37:20.460 --> 00:37:22.480
And that's it for me.

00:37:22.480 --> 00:37:25.310
Here is Michal, who is going
to talk more about testing

00:37:25.310 --> 00:37:26.121
in Android Studio.

00:37:26.121 --> 00:37:27.120
MICHAL BENDOWSKI: Hello.

00:37:27.120 --> 00:37:27.640
Hi.

00:37:27.640 --> 00:37:29.160
Can we switch to the
other computer, please?

00:37:29.160 --> 00:37:29.660
OK.

00:37:29.660 --> 00:37:30.500
Perfect.

00:37:30.500 --> 00:37:32.230
Let me show you a
couple of useful tricks

00:37:32.230 --> 00:37:34.640
that'll come in handy
when writing test code.

00:37:34.640 --> 00:37:37.480
The first thing I'd like to show
is the Create Test Intention,

00:37:37.480 --> 00:37:40.150
which is available when
my cursor is on the class

00:37:40.150 --> 00:37:41.050
definition.

00:37:41.050 --> 00:37:44.364
So here I'm going to press
Alt-Enter and just Create Test.

00:37:44.364 --> 00:37:47.030
In the dialog I'm getting, I can
choose the name of my new test.

00:37:47.030 --> 00:37:49.160
DemoActivityTest sounds fine.

00:37:49.160 --> 00:37:50.650
So let's move forward.

00:37:50.650 --> 00:37:52.190
And with our new
support for having

00:37:52.190 --> 00:37:54.530
both test sources
active, now I should

00:37:54.530 --> 00:37:57.600
choose which one I want to use.

00:37:57.600 --> 00:38:00.440
So let's use Android
test for now.

00:38:00.440 --> 00:38:03.610
And now I got my new
test class, which

00:38:03.610 --> 00:38:07.150
was created in the right
place in my project structure.

00:38:07.150 --> 00:38:10.650
You can see all the intermediate
directories got created,

00:38:10.650 --> 00:38:12.200
so that's quite convenient.

00:38:12.200 --> 00:38:13.710
Let's fill it in
with some content.

00:38:13.710 --> 00:38:15.126
Now, there was a
session dedicated

00:38:15.126 --> 00:38:17.310
to testing earlier today,
so if you haven't seen it,

00:38:17.310 --> 00:38:19.020
I recommend you watch the video.

00:38:19.020 --> 00:38:21.069
Because for the
purposes of this demo,

00:38:21.069 --> 00:38:23.110
I'm just going to do
something very, very simple.

00:38:23.110 --> 00:38:27.460
Let's just add an
ActivityTestRule

00:38:27.460 --> 00:38:30.610
for my demo activity.

00:38:30.610 --> 00:38:35.530
And it can even suggest me
a good name for my field.

00:38:35.530 --> 00:38:38.460
And now I want new.

00:38:38.460 --> 00:38:40.505
ActivityTestRule.

00:38:40.505 --> 00:38:41.480
DemoActivity.

00:38:41.480 --> 00:38:43.110
Perfect.

00:38:43.110 --> 00:38:45.235
Next thing I'd like to show
is the Generate command

00:38:45.235 --> 00:38:46.670
that Tor already mentioned.

00:38:46.670 --> 00:38:49.100
It's Command-N on the Mac.

00:38:49.100 --> 00:38:51.520
And in the test
context, I can use

00:38:51.520 --> 00:38:53.590
it to generate a test method.

00:38:53.590 --> 00:38:56.634
So in this case, let's
call it testBasics.

00:38:56.634 --> 00:38:58.550
And let me just do
something very simple here.

00:38:58.550 --> 00:39:01.400
I'll use
ActivityTestRule.getactivity.

00:39:01.400 --> 00:39:04.640
And I can play with
postfix completion.

00:39:04.640 --> 00:39:06.830
For example, the .var
to actually assign it

00:39:06.830 --> 00:39:08.510
to a variable.

00:39:08.510 --> 00:39:11.910
I'll leave it at
that for now, but let

00:39:11.910 --> 00:39:13.760
me show you something else.

00:39:13.760 --> 00:39:15.550
On any kind of
field declaration,

00:39:15.550 --> 00:39:18.230
including rules for
testing, I can again

00:39:18.230 --> 00:39:21.700
use intentions to Move
Initializer to setUp method,

00:39:21.700 --> 00:39:24.570
which is quite convenient if
you find yourself in a position

00:39:24.570 --> 00:39:26.840
where your test setup is
becoming more complicated.

00:39:26.840 --> 00:39:31.120
So when I press Enter, Studio
will generate a new setUp

00:39:31.120 --> 00:39:33.100
method for me,
annotated with @Before,

00:39:33.100 --> 00:39:36.530
and move the
initialization here.

00:39:36.530 --> 00:39:38.200
I can also use
intentions to get rid

00:39:38.200 --> 00:39:41.956
of the unnecessary
generic parameter.

00:39:41.956 --> 00:39:44.800
OK, next thing I'd like
to show you is Goto Test.

00:39:44.800 --> 00:39:49.150
So on a Mac that's
Shift-Command-T. So when I

00:39:49.150 --> 00:39:52.510
press it, I can jump between
my main code and my test code.

00:39:52.510 --> 00:39:55.130
So from the DemoActivity
you can go to the test.

00:39:55.130 --> 00:39:57.670
From the test I can
go back to Activity.

00:39:57.670 --> 00:40:00.930
[INAUDIBLE] is that
the popup for Goto test

00:40:00.930 --> 00:40:03.210
allows me to create
a new test as well.

00:40:03.210 --> 00:40:05.411
So let's do that now,
because for a change

00:40:05.411 --> 00:40:07.910
I would like to create a unit
test that will execute locally

00:40:07.910 --> 00:40:08.610
on my machine.

00:40:08.610 --> 00:40:11.190
And there's one method I'm
particularly interested

00:40:11.190 --> 00:40:13.770
in, the
generateSecretKey() method.

00:40:13.770 --> 00:40:15.100
Let's press OK.

00:40:15.100 --> 00:40:20.180
This time let's make sure it
ends up in the test SourceIT

00:40:20.180 --> 00:40:24.650
Again, we end up with a test
created in the right directory,

00:40:24.650 --> 00:40:27.150
with the test
pregenerated for me.

00:40:27.150 --> 00:40:29.170
Let me put something
very simple here.

00:40:29.170 --> 00:40:29.920
Assert.assertTrue.

00:40:35.270 --> 00:40:37.782
Let's just make sure our
keys are positive integers.

00:40:37.782 --> 00:40:41.270
So Studio 2.0 is based
on Intelligence 15, which

00:40:41.270 --> 00:40:43.000
means that on the
left margin here

00:40:43.000 --> 00:40:45.430
we have icons that I can
use for running tests.

00:40:45.430 --> 00:40:48.890
So when I click it, I can
choose to run my test.

00:40:48.890 --> 00:40:51.610
And let's see it run.

00:40:51.610 --> 00:40:52.250
Perfect.

00:40:52.250 --> 00:40:52.780
All agree.

00:40:52.780 --> 00:40:54.700
Exactly how I like it.

00:40:54.700 --> 00:40:57.020
OK, so last but not
least, if I decide

00:40:57.020 --> 00:41:00.010
to go back to my
activity and now decide

00:41:00.010 --> 00:41:02.090
that, with all the
other test coverage,

00:41:02.090 --> 00:41:04.050
it's actually ready
for production,

00:41:04.050 --> 00:41:08.565
I can rename my
DemoActivity MainActivity.

00:41:08.565 --> 00:41:12.105
And Studio will notice that
I have tests that corresponds

00:41:12.105 --> 00:41:13.980
to my demo activity,
and they should probably

00:41:13.980 --> 00:41:15.330
be renamed as well.

00:41:15.330 --> 00:41:18.900
So my DemoActivity test
becomes MainActivity test,

00:41:18.900 --> 00:41:21.456
and DemoActivity unit test
becomes MainActivityUnitTest.

00:41:21.456 --> 00:41:22.580
So that's a very good idea.

00:41:22.580 --> 00:41:23.800
Let's do that.

00:41:23.800 --> 00:41:27.080
I'll click Select All, and OK.

00:41:27.080 --> 00:41:29.400
OK, now that we're done
with this, close it.

00:41:29.400 --> 00:41:32.900
I can then go to Test, I can
see my tests have been renamed,

00:41:32.900 --> 00:41:36.560
and both of them use the
new activity name exactly

00:41:36.560 --> 00:41:38.460
as I would expect.

00:41:38.460 --> 00:41:39.365
OK, thank you.

00:41:44.160 --> 00:41:47.566
And now Kathryn will tell you
all about our C++ support.

00:41:47.566 --> 00:41:48.565
KATHRYN SHIH: All right.

00:41:48.565 --> 00:41:51.180
Let's see.

00:41:51.180 --> 00:41:55.130
So I'm going to just cover
a smattering of C++ topics.

00:41:55.130 --> 00:41:57.230
We already saw some of the
things like intentions.

00:41:57.230 --> 00:41:58.646
They're totally
supported for C++.

00:41:58.646 --> 00:42:01.030
If you're curious, you can
find them in the settings

00:42:01.030 --> 00:42:02.790
and check out previous videos.

00:42:02.790 --> 00:42:07.130
This is more topics that
have been previously covered.

00:42:07.130 --> 00:42:11.150
So things that are new in Studio
for C++ and that you might not

00:42:11.150 --> 00:42:11.990
know about.

00:42:11.990 --> 00:42:14.390
One of the things is
that we have recently

00:42:14.390 --> 00:42:16.160
added Doxygen support.

00:42:16.160 --> 00:42:19.456
So when you've been
using C++ historically,

00:42:19.456 --> 00:42:21.080
you may have noticed
that, for example,

00:42:21.080 --> 00:42:23.470
if you hit F1 to
bring up the docs,

00:42:23.470 --> 00:42:26.290
you can see details on
where macros to find,

00:42:26.290 --> 00:42:28.630
what the expansion is.

00:42:28.630 --> 00:42:31.220
Similar to that, we
now have this syntax.

00:42:31.220 --> 00:42:33.140
It's kind of akin to Java docs.

00:42:33.140 --> 00:42:34.920
You can add it for a function.

00:42:34.920 --> 00:42:37.694
And then when you go actually
look at the definition,

00:42:37.694 --> 00:42:39.110
this one is very
dull, but you can

00:42:39.110 --> 00:42:43.920
imagine putting in as much
detail as you may find useful.

00:42:43.920 --> 00:42:46.910
So may be helpful
documenting large projects.

00:42:46.910 --> 00:42:51.760
Other new support, let's see
if we've got this running yet.

00:42:51.760 --> 00:42:53.990
So this is a hybrid activity.

00:42:53.990 --> 00:42:57.330
And I've added a breakpoint
here in the Java code right

00:42:57.330 --> 00:42:59.480
before we go into
this native call.

00:42:59.480 --> 00:43:01.260
Get String From Native.

00:43:01.260 --> 00:43:04.590
Once I've done that--
oh, this microphone.

00:43:04.590 --> 00:43:08.920
I've gone and edited my debug
configuration to make sure that

00:43:08.920 --> 00:43:11.460
the debugger type is hybrid,
because I'm curious about both

00:43:11.460 --> 00:43:13.625
my Java and my C++ execution.

00:43:13.625 --> 00:43:17.700
And I've actually launched
a debugger, hopefully.

00:43:17.700 --> 00:43:19.184
Or I am launching a debugger.

00:43:19.184 --> 00:43:21.600
For those of you who don't
have the superpower of reading,

00:43:21.600 --> 00:43:24.080
like, size two font, it looks
like we're about to run.

00:43:30.070 --> 00:43:51.030
This is totally the
curse of the live demo

00:43:51.030 --> 00:43:51.908
Super suspicious.

00:44:05.558 --> 00:44:07.490
All right, well,
at least in theory,

00:44:07.490 --> 00:44:11.080
we now have the ability to step
from Java code into C++ code.

00:44:11.080 --> 00:44:13.330
We will give this another
30 seconds before we declare

00:44:13.330 --> 00:44:14.790
it to be primarily theoretical

00:44:14.790 --> 00:44:18.290
[LAUGHTER]

00:44:22.290 --> 00:44:23.940
Oh, come on.

00:44:23.940 --> 00:44:26.024
Well, while that
thinks about itself,

00:44:26.024 --> 00:44:28.190
so this was supposed to be
the stable functionality.

00:44:28.190 --> 00:44:30.189
And then we have some
experimental functionality

00:44:30.189 --> 00:44:33.230
that should also be helpful
for folks doing hybrid apps.

00:44:33.230 --> 00:44:34.577
So we'll come back to that.

00:44:34.577 --> 00:44:37.160
Sorry, something totally messed
with my emulator configuration

00:44:37.160 --> 00:44:39.760
right before this started.

00:44:39.760 --> 00:44:42.902
So historically, you're
running a hybrid app.

00:44:42.902 --> 00:44:43.860
And this is an example.

00:44:43.860 --> 00:44:46.360
I've got an app which
has a bunch of Java code,

00:44:46.360 --> 00:44:49.590
and I've got a library
with a bunch of C++ code.

00:44:49.590 --> 00:44:52.660
I want to express a reasonable
dependency that doesn't involve

00:44:52.660 --> 00:44:54.940
hard-coding linker flags.

00:44:54.940 --> 00:44:58.100
So we've added an experimental
first class syntax

00:44:58.100 --> 00:44:59.390
for doing this.

00:44:59.390 --> 00:45:03.080
In this case, I want to say
I have a jniLib dependency

00:45:03.080 --> 00:45:04.382
on project Lib.

00:45:04.382 --> 00:45:06.090
By default it's going
to pull in the same

00:45:06.090 --> 00:45:09.120
build type and flavor that
my actual build is using.

00:45:09.120 --> 00:45:10.760
You can override
this if you like.

00:45:10.760 --> 00:45:13.600
And this thing is not taking
well to the huge font,

00:45:13.600 --> 00:45:16.950
but by default you're going
to get dynamic linking.

00:45:16.950 --> 00:45:19.830
If you want static
linking, specify it.

00:45:19.830 --> 00:45:23.880
You can also define
dependencies on pre-build SOs.

00:45:23.880 --> 00:45:25.460
So library file.

00:45:25.460 --> 00:45:28.250
Maybe define that as
a jniLib dependency.

00:45:28.250 --> 00:45:31.170
You're basically saying
to package it only.

00:45:31.170 --> 00:45:32.920
If you define as jni
dependency, then it's

00:45:32.920 --> 00:45:34.420
a buildtime dependency.

00:45:34.420 --> 00:45:36.660
And this is experimental,
not because we

00:45:36.660 --> 00:45:38.230
think it may sometimes
fail to work,

00:45:38.230 --> 00:45:39.730
but just because
we know we're going

00:45:39.730 --> 00:45:42.160
to be changing the DSL at
some point in the future.

00:45:42.160 --> 00:45:45.020
So if you think this is useful,
go ahead and use it and try it.

00:45:45.020 --> 00:45:47.710
Just be warned that
in the next n months,

00:45:47.710 --> 00:45:51.180
you're likely going to have to
go tweak your Gradle syntax.

00:45:51.180 --> 00:45:54.600
The other feature we have that
is more genuinely experimental

00:45:54.600 --> 00:45:56.060
is, for C++-- Oop.

00:45:56.060 --> 00:45:58.230
I forgot to put it in here.

00:45:58.230 --> 00:46:02.050
We've actually added
the specification for,

00:46:02.050 --> 00:46:13.260
I can now say cppFlags, if I can
type, for split-dwarf builds.

00:46:13.260 --> 00:46:14.650
Oh, here's my Debugger.

00:46:14.650 --> 00:46:17.350
[APPLAUSE]

00:46:19.940 --> 00:46:23.040
So, I guess, finishing
one thought at a time.

00:46:23.040 --> 00:46:25.247
Split-dwarf bills, if
you're not familiar with it.

00:46:25.247 --> 00:46:27.080
When you start running
a debug build in C++,

00:46:27.080 --> 00:46:30.290
the compiler is going to shove
all of the debug information

00:46:30.290 --> 00:46:31.310
into your objects.

00:46:31.310 --> 00:46:33.410
And this may result in
substantially larger files

00:46:33.410 --> 00:46:36.470
that then take your linker a
much longer time to process.

00:46:36.470 --> 00:46:38.110
If you use the
split-dwarf flag, you're

00:46:38.110 --> 00:46:40.380
going to keep the
debug information out

00:46:40.380 --> 00:46:42.430
of the objects of
the linker processes.

00:46:42.430 --> 00:46:45.920
And it may result in like a 10%
or more increase in linktime,

00:46:45.920 --> 00:46:48.700
particularly when you are
seeing slow link times because

00:46:48.700 --> 00:46:51.280
of big files with tons
of debug information.

00:46:51.280 --> 00:46:53.230
That one is more
genuinely experimental.

00:46:53.230 --> 00:46:56.140
It's a new compiler flag, out
in the wild for the first time.

00:46:56.140 --> 00:46:57.280
So give it a shot.

00:46:57.280 --> 00:46:59.770
And if it, frankly, fails
to compile, please tell us,

00:46:59.770 --> 00:47:01.480
we'll fix it.

00:47:01.480 --> 00:47:04.730
So going back then
to our debugger.

00:47:04.730 --> 00:47:07.260
I placed the breakpoint
here in the Java code.

00:47:07.260 --> 00:47:09.740
You can see I've got
my Java debugger open.

00:47:09.740 --> 00:47:12.000
I can start examining all
of the objects in here.

00:47:12.000 --> 00:47:14.524
But then what happens when
I start stepping forward?

00:47:17.090 --> 00:47:21.114
So I am stepping
into the C++ code.

00:47:21.114 --> 00:47:24.526
[APPLAUSE]

00:47:25.440 --> 00:47:28.200
And it should momentarily hand
this off to the C++ debugger

00:47:28.200 --> 00:47:30.180
and let me see all
that memory state.

00:47:30.180 --> 00:47:32.430
Assuming the curse of the
live demo does not continue.

00:47:35.325 --> 00:47:35.825
App-native.

00:47:35.825 --> 00:47:37.770
Native.

00:47:37.770 --> 00:47:40.030
Oh, come on.

00:47:40.030 --> 00:47:41.200
Yes, here we go.

00:47:41.200 --> 00:47:43.420
So we've totally got
native code here.

00:47:43.420 --> 00:47:45.610
I can keep on stepping forward.

00:47:45.610 --> 00:47:47.954
I can go just to my
next break point.

00:47:47.954 --> 00:47:49.370
And the other thing
you may notice

00:47:49.370 --> 00:47:51.580
is that we've added
significantly better display

00:47:51.580 --> 00:47:52.944
if you're using the STL.

00:47:52.944 --> 00:47:54.860
So can actually start
inspecting my templates,

00:47:54.860 --> 00:47:56.770
seeing what's in here.

00:47:56.770 --> 00:48:01.990
And then if I'm running on X86
or a Nexus 9 emulator like I

00:48:01.990 --> 00:48:06.214
conveniently picked, I can
start adding things to watches

00:48:06.214 --> 00:48:07.838
and continue working
with the C++ code.

00:48:11.250 --> 00:48:14.400
So as I step through,
everything updates.

00:48:14.400 --> 00:48:17.676
So again, play with
the C++ debugger.

00:48:17.676 --> 00:48:19.300
Let us know how it's
working, and we're

00:48:19.300 --> 00:48:20.530
going to be continuing
to update this.

00:48:20.530 --> 00:48:22.620
So if you have things
you really want to see,

00:48:22.620 --> 00:48:26.770
the squeaky wheel typically
gets the grease here.

00:48:26.770 --> 00:48:30.130
So, Gradle support,
Debugger, editing.

00:48:30.130 --> 00:48:35.040
The next thing is going to be
a total change in projects.

00:48:35.040 --> 00:48:37.690
You may have noticed during
the keynote yesterday,

00:48:37.690 --> 00:48:41.280
we announced a snazzy
new-- and this is maybe

00:48:41.280 --> 00:48:43.060
beyond experimental,
this is maybe

00:48:43.060 --> 00:48:48.268
super-ultra preview alpha-- But
we announced a GPU profiler.

00:48:51.530 --> 00:48:53.460
So come back to Studio.

00:48:53.460 --> 00:48:58.009
So here is a project
with a bunch of GL code.

00:48:58.009 --> 00:49:00.050
And there's two steps to
getting the GPU Profiler

00:49:00.050 --> 00:49:02.930
working, which I've
sneakily done ahead of time.

00:49:02.930 --> 00:49:05.260
You have to add a trace
library to your project.

00:49:05.260 --> 00:49:06.718
It's distributed
with the profiler,

00:49:06.718 --> 00:49:08.140
so you just copy it in place.

00:49:08.140 --> 00:49:12.630
And then you have to add
a couple calls in order

00:49:12.630 --> 00:49:14.270
to actually load it.

00:49:14.270 --> 00:49:16.170
Once you've loaded
it, you'll see

00:49:16.170 --> 00:49:18.976
that there is a new button
available over here.

00:49:18.976 --> 00:49:21.820
Oh, come on.

00:49:21.820 --> 00:49:23.764
Where's my monitor?

00:49:23.764 --> 00:49:25.430
Well, if I could
expand the monitor tab,

00:49:25.430 --> 00:49:27.600
there's a little red
button for running a trace.

00:49:27.600 --> 00:49:31.979
When you launch an application
with the profiling library

00:49:31.979 --> 00:49:33.770
included in it, the
application is actually

00:49:33.770 --> 00:49:35.000
going to block on startup.

00:49:35.000 --> 00:49:37.290
Because it needs to start
sending all of the GPU data

00:49:37.290 --> 00:49:39.329
back to Studio so that
we can collect the trace.

00:49:39.329 --> 00:49:41.120
So the first time you
run your application,

00:49:41.120 --> 00:49:43.065
you're going to see this
exciting black screen

00:49:43.065 --> 00:49:45.440
while it waits for you to hit
the Trace button on the GPU

00:49:45.440 --> 00:49:46.214
tab.

00:49:46.214 --> 00:49:48.130
Don't freak out, just
go hit the Trace button.

00:49:48.130 --> 00:49:51.880
And be sure to remove it before
you send this thing to prod.

00:49:51.880 --> 00:49:55.280
Once you've run the trace, you
should get something like this.

00:49:55.280 --> 00:49:57.630
So I can see all of the
frames that were captured

00:49:57.630 --> 00:49:59.700
while I interacted with my app.

00:49:59.700 --> 00:50:03.210
For any given frame, you
can see Depth Buffer.

00:50:03.210 --> 00:50:04.920
You can start seeing
Wireframe View.

00:50:07.435 --> 00:50:09.310
And then I can actually
expand the draw calls

00:50:09.310 --> 00:50:11.290
that went into it.

00:50:11.290 --> 00:50:14.030
So let's look at
one of these guys.

00:50:14.030 --> 00:50:16.040
So here's all the open GL calls.

00:50:16.040 --> 00:50:18.130
In places where I was
dealing with memory,

00:50:18.130 --> 00:50:20.450
I can click on this.

00:50:20.450 --> 00:50:22.999
Oh, and normally the text
isn't clipped like this.

00:50:22.999 --> 00:50:25.290
We blew up the size to make
it look good on the monitor

00:50:25.290 --> 00:50:28.590
and now everything
is slightly confused.

00:50:28.590 --> 00:50:31.000
When I'm inspecting the
memory, I can actually

00:50:31.000 --> 00:50:32.579
see what matrix I was using.

00:50:32.579 --> 00:50:34.620
Again, this works better
when my text size is not

00:50:34.620 --> 00:50:37.970
gargantuan relative to
my screen dimensions.

00:50:37.970 --> 00:50:40.370
And I can explore the GPU
state that was around for this.

00:50:40.370 --> 00:50:43.255
So down here I've, got
let's say, my shaders.

00:50:45.927 --> 00:50:48.260
I can see all of the information
that was actually being

00:50:48.260 --> 00:50:49.600
used to generate the scene.

00:50:49.600 --> 00:50:51.808
And then as I click through
the different draw calls,

00:50:51.808 --> 00:50:54.510
you can also see the different
elements being drawn.

00:50:54.510 --> 00:50:57.640
So it's going to look
better if I don't have it

00:50:57.640 --> 00:50:59.180
on the wireframe mode.

00:50:59.180 --> 00:51:01.030
But, for example, if I stepped
through the draw calls on this,

00:51:01.030 --> 00:51:02.613
I'd see the foreground
coming in, then

00:51:02.613 --> 00:51:04.520
the background, et cetera.

00:51:04.520 --> 00:51:07.130
Again, this is highly
preview functionality,

00:51:07.130 --> 00:51:09.660
but if you think it looks
interesting, give it a shot.

00:51:09.660 --> 00:51:12.930
Let us know what works
and what doesn't.

00:51:12.930 --> 00:51:14.430
There's a couple
gotchas around what

00:51:14.430 --> 00:51:16.640
we know are currently
unsupported features for this.

00:51:16.640 --> 00:51:18.360
You can see them
on the help docs

00:51:18.360 --> 00:51:21.180
and we'll be hopefully
relaxing them over time.

00:51:21.180 --> 00:51:24.296
So with that, here's Esteban
for non-GPU profiling.

00:51:24.296 --> 00:51:25.249
[APPLAUSE]

00:51:25.249 --> 00:51:26.790
ESTEBAN DE LA CANAL:
Hello, everyone.

00:51:30.699 --> 00:51:32.740
So I'm going to be talking
in the next 15 minutes

00:51:32.740 --> 00:51:36.990
about our performance
tools in Android Studio.

00:51:36.990 --> 00:51:41.520
I'm still booting my emulator,
so bear with me one second.

00:51:41.520 --> 00:51:43.630
In the last few days, I
put together a quick app

00:51:43.630 --> 00:51:44.838
that I want to show you guys.

00:51:44.838 --> 00:51:46.952
It's basically an app
that has quite a few bugs

00:51:46.952 --> 00:51:48.660
hidden in there, and
I wanted us together

00:51:48.660 --> 00:51:52.490
to use the monitors
in Android Studio

00:51:52.490 --> 00:51:54.910
to see if we can detect
something there, and find

00:51:54.910 --> 00:51:56.500
those bugs and fix them.

00:51:56.500 --> 00:52:03.020
So let me run the app.

00:52:03.020 --> 00:52:07.210
The app is now installing
in the emulator.

00:52:07.210 --> 00:52:11.300
So for those of you not
familiar with the monitors,

00:52:11.300 --> 00:52:14.310
they are in the UnderMonitor
tab on the bottom of the screen.

00:52:14.310 --> 00:52:17.400
I will hide it for a
second while I run you

00:52:17.400 --> 00:52:19.640
through my amazing app.

00:52:19.640 --> 00:52:21.750
[CHUCKLES] This is
a slide show app,

00:52:21.750 --> 00:52:24.115
so I'm getting some
images from the web.

00:52:24.115 --> 00:52:24.990
I'm now loading them.

00:52:24.990 --> 00:52:28.510
And you have an Next button in
there to go to the next image.

00:52:28.510 --> 00:52:31.290
You can go back.

00:52:31.290 --> 00:52:32.260
A simple app.

00:52:32.260 --> 00:52:33.770
And I'm showing
the time at the top

00:52:33.770 --> 00:52:36.030
just because I want to
know what time it is.

00:52:36.030 --> 00:52:39.850
And I also have a menu with
a few options to have there.

00:52:39.850 --> 00:52:42.840
The first option
is a Clear cache.

00:52:42.840 --> 00:52:44.534
So I have a small
cache of five images

00:52:44.534 --> 00:52:46.700
at the same time in memory,
so I don't download them

00:52:46.700 --> 00:52:48.120
when you go back and forth.

00:52:48.120 --> 00:52:49.660
So you can go and
clear the cache.

00:52:49.660 --> 00:52:51.820
And I also have two filters.

00:52:51.820 --> 00:52:53.790
I have a sepia filter,
which is quite popular.

00:52:53.790 --> 00:52:57.310
And there you go, you
have the sepia image.

00:52:57.310 --> 00:53:00.120
And I also have another filter.

00:53:00.120 --> 00:53:02.240
That is a sharpening filter.

00:53:02.240 --> 00:53:04.970
For those of you that are
not familiar with filters,

00:53:04.970 --> 00:53:08.710
sepia filter is very
simple, because you only

00:53:08.710 --> 00:53:09.895
modify each pixel at a time.

00:53:09.895 --> 00:53:11.270
Whereas a sharpening
filter needs

00:53:11.270 --> 00:53:12.980
to look at the
[INAUDIBLE] matrix,

00:53:12.980 --> 00:53:15.060
it needs to look at
its run in pixels.

00:53:15.060 --> 00:53:16.144
So it takes more time.

00:53:16.144 --> 00:53:18.060
The reason I have that
filter is because we're

00:53:18.060 --> 00:53:19.768
going to be looking
at some CPU activity,

00:53:19.768 --> 00:53:22.200
and see whether
this filter actually

00:53:22.200 --> 00:53:25.210
shows up in the CPU Monitor
as something being expensive.

00:53:25.210 --> 00:53:28.070
And there you go, the
image is now sharpened.

00:53:28.070 --> 00:53:29.940
So that's my app.

00:53:29.940 --> 00:53:32.830
Now let's look at
the same thing,

00:53:32.830 --> 00:53:38.370
but now hooking it up to the
monitors in Android Studio.

00:53:38.370 --> 00:53:41.080
I'm going to uninstall
the app right now.

00:53:41.080 --> 00:53:45.620
If you watched the
keynote yesterday,

00:53:45.620 --> 00:53:48.462
you saw that we had a
tiny bug with Instant Run.

00:53:48.462 --> 00:53:50.420
So I don't want to run
into that bug right now,

00:53:50.420 --> 00:53:52.836
so I just uninstall the app
and I'm going to run it again.

00:53:56.388 --> 00:53:59.492
You know, we just did
five live demos in a row.

00:53:59.492 --> 00:54:01.200
Mine is the sixth one;
what can go wrong?

00:54:01.200 --> 00:54:01.699
Right?

00:54:05.490 --> 00:54:05.990
Cool.

00:54:05.990 --> 00:54:09.530
I'm going to write again
here, and then we'll

00:54:09.530 --> 00:54:13.760
see the app connected to the
monitors Just for curiosity,

00:54:13.760 --> 00:54:16.780
how many of you have tried
the CPU Memory Monitor?

00:54:16.780 --> 00:54:17.865
Can you raise your hand?

00:54:17.865 --> 00:54:18.610
Oh, cool.

00:54:18.610 --> 00:54:21.400
All right.

00:54:21.400 --> 00:54:24.410
All right, here's my app.

00:54:24.410 --> 00:54:26.290
Android Monitors.

00:54:26.290 --> 00:54:30.970
I'm going to expand this.

00:54:30.970 --> 00:54:33.284
Can you in the back seats
see the CPU Monitor?

00:54:33.284 --> 00:54:34.200
The one at the bottom?

00:54:34.200 --> 00:54:34.890
Yeah?

00:54:34.890 --> 00:54:35.390
Yep.

00:54:35.390 --> 00:54:37.450
If you don't say no, then
that means you're seeing it.

00:54:37.450 --> 00:54:37.950
Cool.

00:54:37.950 --> 00:54:39.240
Now, this is my app again.

00:54:39.240 --> 00:54:41.156
And let's see if we can
spot some bugs, right?

00:54:41.156 --> 00:54:43.854
So I'm going to go
to the next image.

00:54:43.854 --> 00:54:46.020
The first monitor at the
top is an Android Monitor .

00:54:46.020 --> 00:54:47.880
We recently added this monitor.

00:54:47.880 --> 00:54:50.430
And as you can see, when
I'm requesting a new image,

00:54:50.430 --> 00:54:53.330
you can see New Request.

00:54:53.330 --> 00:54:55.940
Above the zero line, you're
seeing the bytes are coming in,

00:54:55.940 --> 00:54:57.690
and below is the bytes
that are going out.

00:54:57.690 --> 00:54:59.870
So the request is
basically tiny,

00:54:59.870 --> 00:55:03.770
but you can see that
image being downloaded.

00:55:03.770 --> 00:55:05.974
The area of the thing
you're looking at there

00:55:05.974 --> 00:55:08.390
is telling you how many bytes
you're actually downloading.

00:55:08.390 --> 00:55:10.940
So on the x-axis you have time,
on the y-axis you have speed,

00:55:10.940 --> 00:55:12.170
and the area is the
amount of bytes.

00:55:12.170 --> 00:55:13.790
So you can see the
bigger the area,

00:55:13.790 --> 00:55:15.200
the bigger the request was.

00:55:15.200 --> 00:55:17.670
And clearly, I have a
cache, so when I go back,

00:55:17.670 --> 00:55:20.820
there shouldn't be any
requests happening there.

00:55:20.820 --> 00:55:21.650
That's a bug.

00:55:21.650 --> 00:55:22.190
Right?

00:55:22.190 --> 00:55:23.526
That's how you spot a bug.

00:55:23.526 --> 00:55:24.650
So my cache is not working.

00:55:24.650 --> 00:55:26.066
I'm going to go
to my ImageLoader.

00:55:28.149 --> 00:55:30.190
There's no space to see
the monitors and the code

00:55:30.190 --> 00:55:31.490
at the same time.

00:55:31.490 --> 00:55:34.550
Looking at my
ImageLoader, I decided

00:55:34.550 --> 00:55:39.629
to add the image to the cache,
on the catch part of my code.

00:55:39.629 --> 00:55:40.670
That was the wrong place.

00:55:40.670 --> 00:55:41.990
I just moved it up.

00:55:41.990 --> 00:55:45.812
And I'm going to
use Instant Run.

00:55:45.812 --> 00:55:48.110
And Yee-hay.

00:55:48.110 --> 00:55:49.310
Instant Run is working.

00:55:49.310 --> 00:55:52.250
So I just use
Instant Run, and I'm

00:55:52.250 --> 00:55:54.470
going to reopen the monitors
and see what happens.

00:55:54.470 --> 00:55:56.011
So I'm going to go
to the next image.

00:55:56.011 --> 00:55:58.440
This should request the image,
because we haven't seen it.

00:55:58.440 --> 00:55:59.200
Cool.

00:55:59.200 --> 00:56:00.730
One more time.

00:56:00.730 --> 00:56:04.040
This image is a new image,
and now I'm going back.

00:56:04.040 --> 00:56:04.960
No network request.

00:56:04.960 --> 00:56:05.710
The bug was fixed.

00:56:05.710 --> 00:56:09.358
[APPLAUSE]

00:56:09.358 --> 00:56:10.270
Cool.

00:56:10.270 --> 00:56:14.180
So now that we have the cache
working fantastically well,

00:56:14.180 --> 00:56:16.450
we're going to move
on to the next thing.

00:56:16.450 --> 00:56:19.870
You know, we thought,
sepia filter is fast.

00:56:19.870 --> 00:56:22.830
We saw the image of [INAUDIBLE]
Sharpen uses a lot of CPU.

00:56:22.830 --> 00:56:24.240
So I'm going run
my sepia filter,

00:56:24.240 --> 00:56:27.210
and clearly we'll see one
spike on the CPU monitor,

00:56:27.210 --> 00:56:28.170
and that's it, right?

00:56:28.170 --> 00:56:30.940
My CPU Monitor is
now back to-- No.

00:56:30.940 --> 00:56:32.840
It's doing stuff.

00:56:32.840 --> 00:56:33.860
What did I do?

00:56:33.860 --> 00:56:39.220
So we go back to where
I'm calling that.

00:56:39.220 --> 00:56:42.080
By the way, if I
open the monitor,

00:56:42.080 --> 00:56:43.797
OK, it did do something.

00:56:43.797 --> 00:56:46.005
So I'm going to look where
I'm calling this function.

00:56:46.005 --> 00:56:48.860
And you can see I
have, you guys know

00:56:48.860 --> 00:56:52.330
the onOptionsItemSelected
callback that you get.

00:56:52.330 --> 00:56:57.010
And I have my sepia filter
here, and my sharpener-- OK, I

00:56:57.010 --> 00:56:57.960
forgot a break.

00:56:57.960 --> 00:57:00.320
So whenever I was
doing a sepia filter,

00:57:00.320 --> 00:57:02.569
I was also doing a
sharpener filter.

00:57:02.569 --> 00:57:03.360
We don't want that.

00:57:03.360 --> 00:57:06.740
So I'm going to put a break
here, run this new magic thing

00:57:06.740 --> 00:57:09.576
that we have, and
open up the monitor.

00:57:12.240 --> 00:57:18.884
Let's put in our
image and run sepia.

00:57:18.884 --> 00:57:21.000
CPU spike, done.

00:57:21.000 --> 00:57:23.630
That's what you would expect
when you fix this bug.

00:57:23.630 --> 00:57:24.130
Cool.

00:57:24.130 --> 00:57:26.561
Now let's move on
to another bug.

00:57:29.150 --> 00:57:33.350
I'm going to run again
the sharpening filter.

00:57:33.350 --> 00:57:35.160
This, as expected,
will use a lot of CPU.

00:57:38.200 --> 00:57:40.060
And now it's done.

00:57:40.060 --> 00:57:42.750
But I'm going to switch to a
different monitor, the Memory

00:57:42.750 --> 00:57:45.230
Monitor.

00:57:45.230 --> 00:57:48.180
I was not expecting
at all this filter

00:57:48.180 --> 00:57:49.960
to have any memory activity.

00:57:49.960 --> 00:57:50.460
Right?

00:57:50.460 --> 00:57:53.710
So you see the seesaw pattern
there at the same time

00:57:53.710 --> 00:57:54.740
that the CPU spiked.

00:57:54.740 --> 00:57:56.850
So why this happening?

00:57:56.850 --> 00:57:59.376
When you see a
pattern of this form,

00:57:59.376 --> 00:58:01.750
generally it means that you're
doing a lot of allocations

00:58:01.750 --> 00:58:03.291
in a short period
of time, and you're

00:58:03.291 --> 00:58:06.470
getting your garbage collection
kicking in, and bringing them

00:58:06.470 --> 00:58:07.010
back, right?

00:58:07.010 --> 00:58:09.106
So I'm going to
do the same thing,

00:58:09.106 --> 00:58:10.480
but this time I'm
going to run it

00:58:10.480 --> 00:58:12.735
through the allocation tracker.

00:58:12.735 --> 00:58:14.400
The allocation
tracker, what it does

00:58:14.400 --> 00:58:15.920
is, you start in
a moment in time,

00:58:15.920 --> 00:58:18.045
it captures all the
allocations that are happening,

00:58:18.045 --> 00:58:22.020
and then you can go and dig
into these allocations, right?

00:58:22.020 --> 00:58:23.485
So let's do it.

00:58:26.424 --> 00:58:27.840
I'm running sharpen,
and I'm going

00:58:27.840 --> 00:58:29.580
to start allocation tracking.

00:58:29.580 --> 00:58:32.250
You can see in the Memory
monitor, what is the time frame

00:58:32.250 --> 00:58:34.980
that I'm doing this tracking.

00:58:34.980 --> 00:58:38.270
I'm going to stop it here.

00:58:38.270 --> 00:58:43.772
And then we minimize the monitor
so we can see, here we go.

00:58:43.772 --> 00:58:45.480
So now the file is
being transferred over

00:58:45.480 --> 00:58:46.910
to Android Studio.

00:58:46.910 --> 00:58:50.010
And then we see Thread 1,
36 allocations, Thread 3,

00:58:50.010 --> 00:58:52.480
10 allocations.

00:58:52.480 --> 00:58:56.320
Thread 13 decided to
do 65,000 allocations.

00:58:56.320 --> 00:58:57.670
Something is wrong.

00:58:57.670 --> 00:58:58.630
How do we go there?

00:58:58.630 --> 00:59:02.872
OK, I'm going to start
opening this guy.

00:59:02.872 --> 00:59:04.330
You can see the
asynchronous task t

00:59:04.330 --> 00:59:06.880
that I used to do the filter.

00:59:06.880 --> 00:59:09.950
You can keep digging, it
goes into the filter image.

00:59:09.950 --> 00:59:12.890
Sorry, we have super huge
fonts so you guys can see,

00:59:12.890 --> 00:59:16.980
but I keep digging,
digging, 65,000 allocations.

00:59:16.980 --> 00:59:19.100
I get to the sharpen code.

00:59:19.100 --> 00:59:20.901
I open it up.

00:59:20.901 --> 00:59:22.950
Gazillion long allocations.

00:59:22.950 --> 00:59:23.995
Why is this happening?

00:59:27.130 --> 00:59:28.650
I'm going to go to source.

00:59:28.650 --> 00:59:30.770
There's an action there
to Jump to Source.

00:59:30.770 --> 00:59:33.090
Looking at my code.

00:59:33.090 --> 00:59:35.610
In standard filter code, you
have two nested for-loops

00:59:35.610 --> 00:59:38.710
and go through all the pixels.

00:59:38.710 --> 00:59:39.340
OK.

00:59:39.340 --> 00:59:42.310
I have a new location
of an array inside this.

00:59:42.310 --> 00:59:45.910
So these images are
1,000 by 1,000, roughly.

00:59:45.910 --> 00:59:48.290
I'm doing quite a
lot of allocations.

00:59:48.290 --> 00:59:50.930
I'm going to move
this out of the loops.

00:59:50.930 --> 00:59:53.350
It doesn't need to be at
that location in the loop.

00:59:53.350 --> 00:59:55.630
I'm going to press the
magic button again.

00:59:55.630 --> 00:59:59.210
And let's open the monitors.

00:59:59.210 --> 00:59:59.980
Cool.

00:59:59.980 --> 01:00:03.320
Now let's try again,
another image.

01:00:03.320 --> 01:00:06.460
Oh, that image after two
sharpen filters looks beautiful.

01:00:06.460 --> 01:00:08.330
OK.

01:00:08.330 --> 01:00:10.660
Sharpen.

01:00:10.660 --> 01:00:16.660
CPU activity, as you can expect,
the memory, safe and sound.

01:00:16.660 --> 01:00:19.430
That's how you spot and how
you track down allocation bugs.

01:00:19.430 --> 01:00:22.054
There is another thing I want to
show you on the Location view.

01:00:25.560 --> 01:00:26.190
Here we go.

01:00:31.840 --> 01:00:33.660
So this ImageUtils
class, the one

01:00:33.660 --> 01:00:36.410
that was doing the
[INAUDIBLE] allocations,

01:00:36.410 --> 01:00:39.260
I have it in a package called
Third Party Images Package,

01:00:39.260 --> 01:00:39.880
right?

01:00:39.880 --> 01:00:42.250
Imagine you're using a
library that you didn't write,

01:00:42.250 --> 01:00:44.541
but you're calling it from
similar places of your code.

01:00:44.541 --> 01:00:47.375
And that library seems to be
doing a lot of allocations.

01:00:47.375 --> 01:00:49.250
If you use this view in
the Location Tracker,

01:00:49.250 --> 01:00:52.260
you're going to find that
all these allocations are

01:00:52.260 --> 01:00:53.910
being blamed on those packages.

01:00:53.910 --> 01:00:54.980
You're going to drill
down and say, oh, it's

01:00:54.980 --> 01:00:56.960
again this library, it's
again this library, right?

01:00:56.960 --> 01:00:59.543
When you do an allocation where
you see the call stack, right?

01:00:59.543 --> 01:01:02.041
So you see all the
call stack, and then

01:01:02.041 --> 01:01:03.540
the final function
in the call stack

01:01:03.540 --> 01:01:05.696
is going to be the
one that you blame,

01:01:05.696 --> 01:01:07.820
to say, OK, that's the one
that did the allocation.

01:01:07.820 --> 01:01:09.950
However, maybe one
of your classes

01:01:09.950 --> 01:01:12.430
is responsible before
that code happened, right?

01:01:12.430 --> 01:01:15.430
So you don't want to go directly
to the class that's called New,

01:01:15.430 --> 01:01:18.720
but you want to go back and
say, OK, which one of my classes

01:01:18.720 --> 01:01:20.257
is actually the
one calling this?

01:01:20.257 --> 01:01:21.840
So for that, there
is a different view

01:01:21.840 --> 01:01:24.640
that you can use, which we
call Group by Allocator.

01:01:24.640 --> 01:01:28.610
When you do this, instead
of using the call stack

01:01:28.610 --> 01:01:31.180
as the guide to group
the allocations,

01:01:31.180 --> 01:01:33.700
we use the package names.

01:01:33.700 --> 01:01:36.040
So here, like I
was saying before,

01:01:36.040 --> 01:01:38.209
you can see that
com.thirdparty.images

01:01:38.209 --> 01:01:40.250
was a package that was
doing all the allocations.

01:01:40.250 --> 01:01:41.740
Not helpful at all.

01:01:41.740 --> 01:01:45.930
We have a box here where
you can specify the package

01:01:45.930 --> 01:01:47.560
that you want to highlight.

01:01:47.560 --> 01:01:49.910
So this allocation that
go through many things,

01:01:49.910 --> 01:01:52.160
but you want the last thing
to be one of your package.

01:01:52.160 --> 01:01:58.889
I can put com.example, which
was my applications package.

01:01:58.889 --> 01:02:01.180
And now you can see that
whenever we see an allocation,

01:02:01.180 --> 01:02:04.790
we will not blame it
on the very deep call,

01:02:04.790 --> 01:02:07.712
but we will blame
it on my last call.

01:02:07.712 --> 01:02:09.670
So now you can go and
see that com.example.devs

01:02:09.670 --> 01:02:12.980
ummit.MainActivity
is the class to blame

01:02:12.980 --> 01:02:14.550
for all these allocations.

01:02:14.550 --> 01:02:19.230
But with this, you can
better track the culprits

01:02:19.230 --> 01:02:21.150
of several allocations.

01:02:21.150 --> 01:02:22.420
Cool.

01:02:22.420 --> 01:02:23.518
So, going back to the app.

01:02:26.949 --> 01:02:28.740
The last thing that I
want to show you guys

01:02:28.740 --> 01:02:32.084
is, my app is here.

01:02:32.084 --> 01:02:33.500
I'm going to restart
the activity.

01:02:33.500 --> 01:02:35.820
I could rotate the emulator
and it will go offscreen.

01:02:35.820 --> 01:02:42.334
So we have a new shortcut
to restart the activity.

01:02:42.334 --> 01:02:44.250
Everyone knows that when
an activity restarts,

01:02:44.250 --> 01:02:46.690
we need to be very careful
about a few things, right?

01:02:46.690 --> 01:02:50.120
We need to be careful about the
onCreate method being called

01:02:50.120 --> 01:02:53.640
again, so if we create some
things that we don't dispose,

01:02:53.640 --> 01:02:55.400
there would be a leak, right?

01:02:55.400 --> 01:02:57.720
And leaking activities is
one of the most common things

01:02:57.720 --> 01:03:00.110
that happen when this is
not handled correctly.

01:03:00.110 --> 01:03:02.830
So while we keep
looking at this,

01:03:02.830 --> 01:03:04.819
I'm going to restart
activity a few times.

01:03:04.819 --> 01:03:07.110
It is always expected to see
some memory activity here,

01:03:07.110 --> 01:03:07.300
right?

01:03:07.300 --> 01:03:09.850
Because the old activity is
gone, something's going to go,

01:03:09.850 --> 01:03:12.820
and the garbage collector
kicks in slightly later.

01:03:12.820 --> 01:03:16.030
So I'm restarting the
activity quite a few times.

01:03:16.030 --> 01:03:18.620
The purpose of this
demo is to show you

01:03:18.620 --> 01:03:22.250
guys, when you see a pattern on
the monitors that is incorrect,

01:03:22.250 --> 01:03:24.650
something that
should not happen.

01:03:24.650 --> 01:03:27.190
A typical pattern of something
that should not happen

01:03:27.190 --> 01:03:29.940
is that pattern, right?

01:03:29.940 --> 01:03:31.824
I am leaking something.

01:03:31.824 --> 01:03:33.740
Just as a last resort,
I'm going to go and run

01:03:33.740 --> 01:03:35.865
a garbage collection and
hope everything goes away.

01:03:35.865 --> 01:03:36.700
No, it doesn't.

01:03:36.700 --> 01:03:38.050
So there is a bug.

01:03:38.050 --> 01:03:39.150
How do we find this?

01:03:39.150 --> 01:03:43.619
Well, the thing you do is,
you do a heap dump and dig

01:03:43.619 --> 01:03:45.410
through your stuff,
and, you know, what are

01:03:45.410 --> 01:03:47.150
the things that we are leaking?

01:03:47.150 --> 01:03:50.980
To save time I already have a
heap dump here, that I took off

01:03:50.980 --> 01:03:53.286
a very similar scenario.

01:03:53.286 --> 01:03:54.910
The fonts are huge,
so in your computer

01:03:54.910 --> 01:03:55.770
you will not see it like this.

01:03:55.770 --> 01:03:57.186
But, you know, we
blew up the font

01:03:57.186 --> 01:04:00.110
so you can read from there.

01:04:00.110 --> 01:04:04.320
I could now go and dig in and
find, where are my activities,

01:04:04.320 --> 01:04:06.580
how many do I have?

01:04:06.580 --> 01:04:09.180
We added this very
handy thing that

01:04:09.180 --> 01:04:12.360
is called Analyzer Tasks,
that we can automatically

01:04:12.360 --> 01:04:14.230
run some tasks for you.

01:04:14.230 --> 01:04:16.590
And we detect common
patterns of things.

01:04:16.590 --> 01:04:21.840
We have this long list of two
things that we will take now,

01:04:21.840 --> 01:04:24.565
but obviously, with time
we'll be adding more.

01:04:24.565 --> 01:04:28.362
The most important we have
now is the Leaked Activities.

01:04:28.362 --> 01:04:29.570
I open the Leaked Activities.

01:04:29.570 --> 01:04:33.640
I leaked the activity every
time that I was rotating, right?

01:04:33.640 --> 01:04:37.020
If you look at all the
instances of many activity,

01:04:37.020 --> 01:04:41.160
I have seven instances of
MainActivity and six of them

01:04:41.160 --> 01:04:41.937
were leaked.

01:04:41.937 --> 01:04:43.770
That means that there
is something on my app

01:04:43.770 --> 01:04:45.340
that is keeping a
reference to them,

01:04:45.340 --> 01:04:48.020
and with that it keeps all the
resources of that activity.

01:04:48.020 --> 01:04:50.100
So how do we find that?

01:04:50.100 --> 01:04:50.620
Cool.

01:04:50.620 --> 01:04:52.540
Let's click on one of
the leaked activities.

01:04:52.540 --> 01:04:54.670
If you click here, it will
click on the main view

01:04:54.670 --> 01:04:56.242
and we select the instance.

01:04:56.242 --> 01:04:58.700
And then on the bottom pane,
you can see all the references

01:04:58.700 --> 01:04:59.400
to that, right?

01:04:59.400 --> 01:05:04.633
So you will see the reversed
references to your objects,

01:05:04.633 --> 01:05:07.240
This tells you which
are the objects that

01:05:07.240 --> 01:05:08.740
keep a reference to me.

01:05:08.740 --> 01:05:11.680
We sort this by the distance
to the nearest root.

01:05:11.680 --> 01:05:13.640
That means the nearest
garbage collection root.

01:05:13.640 --> 01:05:15.300
That means that if
you expand the tree,

01:05:15.300 --> 01:05:17.522
and you go in the first,
first, first, first child,

01:05:17.522 --> 01:05:19.480
you're going to get to
the root pretty quickly.

01:05:19.480 --> 01:05:22.203
And that is, in most cases, the
one that is keeping in memory.

01:05:25.030 --> 01:05:27.420
On top of that, there is a
lot of Dominator calculation

01:05:27.420 --> 01:05:30.020
retain size, so that you can
look at the documentation

01:05:30.020 --> 01:05:31.440
and find what these things mean.

01:05:31.440 --> 01:05:33.606
But I'm going to
quickly go and see

01:05:33.606 --> 01:05:35.230
if I can just spot
the culprit of this.

01:05:35.230 --> 01:05:38.710
I have my MainActivity,
and I have a ClockUpdater,

01:05:38.710 --> 01:05:40.370
but it's a thread,
and this is a root.

01:05:40.370 --> 01:05:42.130
So why is this still there?

01:05:42.130 --> 01:05:46.960
I'm going to go to my code
and see why ClockUpdater keeps

01:05:46.960 --> 01:05:48.990
a reference to my activity.

01:05:48.990 --> 01:05:49.760
This is a thread.

01:05:49.760 --> 01:05:53.380
You know, a "don't do this
at home" kind of thing.

01:05:53.380 --> 01:05:56.930
I'm going to look at
all the usages of this.

01:05:56.930 --> 01:05:58.070
And I actually know them.

01:05:58.070 --> 01:06:00.790
Here are the ones
using the MainActivity.

01:06:00.790 --> 01:06:05.250
I start this thread on
onCreate and-- whoops,

01:06:05.250 --> 01:06:06.840
I left this comment out.

01:06:06.840 --> 01:06:09.770
This is why my thread
was not stopping.

01:06:09.770 --> 01:06:13.354
I'm going to press the
magic button again.

01:06:13.354 --> 01:06:14.810
Cool.

01:06:14.810 --> 01:06:17.591
Let's open the monitors.

01:06:17.591 --> 01:06:18.090
Right.

01:06:18.090 --> 01:06:20.600
I'm going to start
restarting the activity

01:06:20.600 --> 01:06:26.370
and see if the memory
does something.

01:06:26.370 --> 01:06:28.950
There we go.

01:06:28.950 --> 01:06:32.090
Like we said, some activity
on the memory is expected.

01:06:32.090 --> 01:06:34.454
This thing is going up.

01:06:34.454 --> 01:06:37.120
Garbage collection, I'm going to
click on the garbage collection

01:06:37.120 --> 01:06:40.640
button to see if it is a drop.

01:06:40.640 --> 01:06:43.410
I think we're good.

01:06:43.410 --> 01:06:44.610
Yep.

01:06:44.610 --> 01:06:45.980
Memory is stable once again.

01:06:45.980 --> 01:06:47.604
There's a garbage
collection, and we're

01:06:47.604 --> 01:06:49.780
back to where we should be.

01:06:49.780 --> 01:06:52.560
So the last monitor
I want to show you

01:06:52.560 --> 01:06:55.340
is an experimental
monitor that we have.

01:06:55.340 --> 01:06:56.846
And it is the GPU Monitor.

01:06:59.430 --> 01:07:01.810
It's disabled by default
because when you enable this,

01:07:01.810 --> 01:07:04.270
you might see some interference
with the other monitors.

01:07:04.270 --> 01:07:08.221
So whenever we query the device
to get some GPU activity,

01:07:08.221 --> 01:07:10.720
some allocations are happening,
and you will see your memory

01:07:10.720 --> 01:07:12.200
monitor moving up and down.

01:07:12.200 --> 01:07:16.090
So we have it disabled for
now, disabled by default.

01:07:16.090 --> 01:07:17.620
I'm going to enable it.

01:07:17.620 --> 01:07:19.450
For those of you
familiar with on-device,

01:07:19.450 --> 01:07:21.875
when you go to Settings
and Developer Options,

01:07:21.875 --> 01:07:22.750
something, something.

01:07:22.750 --> 01:07:25.200
Then you go and
enable GPU Profiling.

01:07:25.200 --> 01:07:27.856
You see on-device how
long each frame is taking.

01:07:27.856 --> 01:07:29.480
We're showing the
same thing on Studio,

01:07:29.480 --> 01:07:31.854
so you can see it at the same
time as the other monitors.

01:07:34.120 --> 01:07:36.289
I'm going to start doing
something on my app,

01:07:36.289 --> 01:07:37.580
and you will see some activity.

01:07:37.580 --> 01:07:38.581
We have two lines there.

01:07:38.581 --> 01:07:40.246
We have the red line
and the green line.

01:07:40.246 --> 01:07:42.380
The green line is 60 frames
per second, everything

01:07:42.380 --> 01:07:43.835
below that is super fine.

01:07:43.835 --> 01:07:45.710
Then the yellow line is
30 frames per second.

01:07:45.710 --> 01:07:48.000
You should really
not go over that.

01:07:48.000 --> 01:07:50.180
You know, one is at
16.6 milliseconds,

01:07:50.180 --> 01:07:52.010
the other one is double that.

01:07:54.920 --> 01:07:57.400
And you can see
here that, whenever

01:07:57.400 --> 01:08:00.610
I'm rendering a new
image, depending

01:08:00.610 --> 01:08:03.364
on the size of the image,
we are going over the limit.

01:08:03.364 --> 01:08:05.780
The reason for this is, I'm
not scaling the images at all.

01:08:05.780 --> 01:08:07.294
I'm rendering them
as original size.

01:08:07.294 --> 01:08:08.960
And, you know, this
will take some time.

01:08:08.960 --> 01:08:12.160
I'm not going to fix
that using Instant Run.

01:08:12.160 --> 01:08:14.620
Forgive me for that,
it's a bit more involved.

01:08:14.620 --> 01:08:18.270
But this is how we would
use the GPU monitor.

01:08:18.270 --> 01:08:20.510
So this is the last monitor
that I want to show you.

01:08:20.510 --> 01:08:22.740
And I wanted to close
with a few words of where

01:08:22.740 --> 01:08:26.220
we are going with the
performance tools in Studio.

01:08:26.220 --> 01:08:29.640
So our idea is to
have the monitors

01:08:29.640 --> 01:08:32.446
as a very quick thing for you
guys to look at your app, see

01:08:32.446 --> 01:08:33.529
is everything fine or not.

01:08:33.529 --> 01:08:36.306
And move all the analysis
that we could do automatically

01:08:36.306 --> 01:08:38.180
to the monitor, so you
don't have to profile.

01:08:38.180 --> 01:08:39.580
We'll do that live for you.

01:08:39.580 --> 01:08:41.710
And we will highlight
the issues there.

01:08:41.710 --> 01:08:45.410
And hopefully in the next
releases, the next year,

01:08:45.410 --> 01:08:47.590
you're going to see
improvements on this area.

01:08:47.590 --> 01:08:51.229
And we hope you have
healthier applications.

01:08:51.229 --> 01:08:52.820
Thank you.

01:08:52.820 --> 01:08:58.278
[APPLAUSE]

01:08:58.278 --> 01:09:00.319
With that, I'm going to
invite my colleagues back

01:09:00.319 --> 01:09:02.210
on the stage, and we'll
be happy to answer

01:09:02.210 --> 01:09:05.261
any questions you might have.

01:09:05.261 --> 01:09:07.344
TOR NORBYE: So, there's
microphones on both sides.

01:09:15.380 --> 01:09:16.920
All right.

01:09:16.920 --> 01:09:19.500
No questions?

01:09:19.500 --> 01:09:22.820
Is there anything
else you want to see?

01:09:22.820 --> 01:09:24.270
All right, we have a question.

01:09:24.270 --> 01:09:24.770
Yes.

01:09:24.770 --> 01:09:27.750
AUDIENCE: I have a question
about these performance tools.

01:09:27.750 --> 01:09:32.370
Before, a lot of tools can
be opened as standalone app,

01:09:32.370 --> 01:09:35.000
like a monitor or a view tracer.

01:09:35.000 --> 01:09:39.609
Could these tools can be
opened without Android Studio?

01:09:42.390 --> 01:09:44.140
TOR NORBYE: I was going
to say, right now,

01:09:44.140 --> 01:09:45.439
we are moving away from that.

01:09:45.439 --> 01:09:46.772
That's how we used to do things.

01:09:46.772 --> 01:09:49.130
We used to have, sort of,
separate standalone tools,

01:09:49.130 --> 01:09:50.890
and we're trying to put
everything into the ID.

01:09:50.890 --> 01:09:52.210
And you want speak more
to the performance tools,

01:09:52.210 --> 01:09:53.359
specifically?

01:09:53.359 --> 01:09:55.910
ESTEBAN DE LA CANAL: Yes,
so, exactly what he said.

01:09:55.910 --> 01:09:58.040
We are bringing all these
tools back into Studio.

01:09:58.040 --> 01:09:59.580
And the reason
we're doing that is

01:09:59.580 --> 01:10:02.634
so you can see multiple
monitors at the same time

01:10:02.634 --> 01:10:03.800
and we can do more analysis.

01:10:03.800 --> 01:10:05.258
The idea is to
integrate everything

01:10:05.258 --> 01:10:07.380
into a more cohesive
experience, so you

01:10:07.380 --> 01:10:09.340
don't have to switch
between different tools.

01:10:09.340 --> 01:10:13.380
And having them inside
Studio gives us a chance of,

01:10:13.380 --> 01:10:15.480
because we are the IDE,
we can see all your code,

01:10:15.480 --> 01:10:16.480
we can explore the code.

01:10:16.480 --> 01:10:19.450
And we could do from static
analysis to live performance.

01:10:19.450 --> 01:10:21.890
We can do all the
spectrum of analysis.

01:10:21.890 --> 01:10:24.736
That's why we're bringing
it all into studio.

01:10:24.736 --> 01:10:27.950
AUDIENCE: But the reason I
ask is, sometimes opening

01:10:27.950 --> 01:10:30.200
Android Studio is quite slow.

01:10:30.200 --> 01:10:33.080
So I would prefer just
open a standalone app.

01:10:33.080 --> 01:10:38.215
And it's just because, tracing
memory issues performance

01:10:38.215 --> 01:10:40.280
is take a long time.

01:10:40.280 --> 01:10:45.760
So if it just can open with one
app, and hook up with device,

01:10:45.760 --> 01:10:50.340
or hook up with a simulator,
and a monitor can be easier.

01:10:50.340 --> 01:10:51.840
TOR NORBYE: So you
do only analysis,

01:10:51.840 --> 01:10:53.954
not coding or debugging?

01:10:53.954 --> 01:10:55.870
AUDIENCE: We will, like,
coding and debugging,

01:10:55.870 --> 01:10:57.579
but after we find the
issues, we can go--

01:10:57.579 --> 01:10:59.578
TOR NORBYE: Then you want
to exit Android Studio

01:10:59.578 --> 01:11:00.722
and just do your analysis.

01:11:00.722 --> 01:11:01.150
AUDIENCE: Yeah.

01:11:01.150 --> 01:11:01.775
TOR NORBYE: OK.

01:11:01.775 --> 01:11:03.780
Yeah, the problem is
that for us, there's

01:11:03.780 --> 01:11:05.900
a lot of convenience to
actually being integrated.

01:11:05.900 --> 01:11:08.110
For example, like, you
saw all the text fields.

01:11:08.110 --> 01:11:09.950
We do auto completion
on code, for example.

01:11:09.950 --> 01:11:11.260
And that needs to
know about where's

01:11:11.260 --> 01:11:12.840
your code, and what's
the project context,

01:11:12.840 --> 01:11:13.590
and the classpath.

01:11:13.590 --> 01:11:15.740
And so, you know,
integrating them

01:11:15.740 --> 01:11:17.910
allows us to do a better
feature than when we

01:11:17.910 --> 01:11:19.410
have really standalone tools.

01:11:19.410 --> 01:11:22.480
So that's why we're
doing that deliberately.

01:11:22.480 --> 01:11:24.740
All right, let's
go to that side.

01:11:24.740 --> 01:11:27.860
AUDIENCE: Do you have any
update on the NDK side

01:11:27.860 --> 01:11:30.345
to analyze memory,
like Valgrind?

01:11:30.345 --> 01:11:33.940
Running Valgrind in the device
is a pretty painful thing

01:11:33.940 --> 01:11:34.820
to do.

01:11:34.820 --> 01:11:37.140
So I don't know if you
have any update on that.

01:11:37.140 --> 01:11:39.640
KATHRYN SHIH: So, I don't think
we have an update right now.

01:11:39.640 --> 01:11:42.030
But I would say that, in
general, we recognize strongly

01:11:42.030 --> 01:11:44.640
the need for expanded
performance tools that

01:11:44.640 --> 01:11:47.820
would cover and NDK development
and you should just stay tuned.

01:11:47.820 --> 01:11:49.653
And we're sorry for the
lack of specificity.

01:11:51.991 --> 01:11:54.240
AUDIENCE: I was noticing
that for shrinkResources, you

01:11:54.240 --> 01:11:58.000
had that tools keep annotation,
in case you just needed to tell

01:11:58.000 --> 01:11:59.320
the system to keep something.

01:11:59.320 --> 01:12:00.745
TOR NORBYE: It's like the
ProGuard file, basically.

01:12:00.745 --> 01:12:01.190
AUDIENCE: Yeah.

01:12:01.190 --> 01:12:01.550
TOR NORBYE: Yeah.

01:12:01.550 --> 01:12:02.110
AUDIENCE: So I
was wondering, how

01:12:02.110 --> 01:12:04.110
do you do that for resources
that aren't defined

01:12:04.110 --> 01:12:06.540
in XML, like something in raw?

01:12:06.540 --> 01:12:09.600
TOR NORBYE: Well, those would
be at raw/ and then the name

01:12:09.600 --> 01:12:10.890
of the resource.

01:12:10.890 --> 01:12:13.312
AUDIENCE: Oh, so you
define that in an XML file.

01:12:13.312 --> 01:12:14.020
TOR NORBYE: Yeah.

01:12:14.020 --> 01:12:15.894
So I think whenever you
put something in raw,

01:12:15.894 --> 01:12:19.195
they also get an actual
field name in the R class.

01:12:19.195 --> 01:12:21.070
So the resource type is
raw, and then there's

01:12:21.070 --> 01:12:23.400
the name that that field has.

01:12:23.400 --> 01:12:24.284
AUDIENCE: OK.

01:12:24.284 --> 01:12:26.500
TOR NORBYE: Yup.

01:12:26.500 --> 01:12:28.180
AUDIENCE: So, Java
packages exist

01:12:28.180 --> 01:12:31.470
so you can organize your Java
code and split it up however

01:12:31.470 --> 01:12:32.530
you want.

01:12:32.530 --> 01:12:36.112
But there aren't really clear
ways of organizing resources.

01:12:36.112 --> 01:12:37.570
So if you have a
large app, you may

01:12:37.570 --> 01:12:41.420
have dozens, if not hundreds, of
layout files or drawable files.

01:12:41.420 --> 01:12:43.260
Are there any
plans or strategies

01:12:43.260 --> 01:12:45.944
for organizing resources,
similar to how you

01:12:45.944 --> 01:12:47.110
might organize other things?

01:12:49.255 --> 01:12:49.880
TOR NORBYE: OK.

01:12:49.880 --> 01:12:52.830
So I don't think we
have any concrete plans.

01:12:52.830 --> 01:12:54.930
I know that people had
posted this workaround

01:12:54.930 --> 01:12:57.640
on social media, where you
basically nest the folders

01:12:57.640 --> 01:12:59.840
and you tell Gradle about this.

01:12:59.840 --> 01:13:02.400
But there are some serious
downsides with that approach.

01:13:02.400 --> 01:13:04.920
So I think for
now, what I've seen

01:13:04.920 --> 01:13:06.781
apps do is, they
basically use a prefix.

01:13:06.781 --> 01:13:07.280
Right?

01:13:07.280 --> 01:13:09.870
So you sort of
organize everything

01:13:09.870 --> 01:13:11.610
by a common prefix,
underscore, and then

01:13:11.610 --> 01:13:12.440
the rest of the resource.

01:13:12.440 --> 01:13:14.330
And I don't think it's
easier to do more than that.

01:13:14.330 --> 01:13:15.788
I guess you can
use libraries, too,

01:13:15.788 --> 01:13:18.110
but it might not
be very natural.

01:13:18.110 --> 01:13:20.150
Anyone else want to say
anything about that?

01:13:20.150 --> 01:13:20.720
Michal?

01:13:20.720 --> 01:13:21.090
Gradle?

01:13:21.090 --> 01:13:21.430
No?

01:13:21.430 --> 01:13:21.921
OK.

01:13:21.921 --> 01:13:22.796
MICHAL BENDOWSKI: No.

01:13:22.796 --> 01:13:23.876
[LAUGHTER]

01:13:24.376 --> 01:13:25.360
AUDIENCE: Hi.

01:13:25.360 --> 01:13:27.170
So you showed some
really cool stuff

01:13:27.170 --> 01:13:30.750
that looks like it ends
up being configuration set

01:13:30.750 --> 01:13:33.670
in the local ID
for one programmer.

01:13:33.670 --> 01:13:37.340
How do you see us sharing
that in the team, especially,

01:13:37.340 --> 01:13:39.560
for example, the
structuralReplace,

01:13:39.560 --> 01:13:41.150
talking about the
translation thing

01:13:41.150 --> 01:13:43.940
that the translation
team shouldn't do,

01:13:43.940 --> 01:13:46.342
that kind of thing?

01:13:46.342 --> 01:13:48.050
TOR NORBYE: I think
a lot of these things

01:13:48.050 --> 01:13:50.700
actually do get saved
as project settings.

01:13:50.700 --> 01:13:53.382
And so I think by
default we actually-- so,

01:13:53.382 --> 01:13:55.340
when we make a new project,
we put a gitignore.

01:13:55.340 --> 01:13:57.060
We know that not
everyone uses gitignore,

01:13:57.060 --> 01:13:58.643
but if you use
Mercurial, you probably

01:13:58.643 --> 01:13:59.732
can translate it yourself.

01:13:59.732 --> 01:14:01.440
So the gitignore is
basically documenting

01:14:01.440 --> 01:14:03.400
what we think you want
to include and exclude.

01:14:03.400 --> 01:14:05.441
And I think we actually
do encourage you to check

01:14:05.441 --> 01:14:08.029
the .idea folder
into version control.

01:14:08.029 --> 01:14:10.320
Because that's where you
store things like code styles.

01:14:10.320 --> 01:14:12.700
I know in IntelliJ 15, you
also can import and expert

01:14:12.700 --> 01:14:14.960
code styles really conveniently.

01:14:14.960 --> 01:14:16.970
But I think at least
a structuralReplace

01:14:16.970 --> 01:14:20.000
gets saved there.

01:14:20.000 --> 01:14:21.117
So, yeah.

01:14:21.117 --> 01:14:21.950
AUDIENCE: Thank you.

01:14:21.950 --> 01:14:24.730
TOR NORBYE: Mm-hm.

01:14:24.730 --> 01:14:28.270
AUDIENCE: Do you have any plans
for adding strace support,

01:14:28.270 --> 01:14:34.800
or sort of bringing in the
web-based traces to IntelliJ?

01:14:34.800 --> 01:14:36.190
ESTEBAN DE LA CANAL: Yes.

01:14:36.190 --> 01:14:38.130
[LAUGHTER]

01:14:38.630 --> 01:14:40.490
You want more detail than that?

01:14:40.490 --> 01:14:42.090
Yeah, like I said,
we're planning

01:14:42.090 --> 01:14:44.173
on bringing all the
performance tools into Studio,

01:14:44.173 --> 01:14:45.590
and that's a very handy one.

01:14:45.590 --> 01:14:47.458
So it's going to be on the list.

01:14:50.069 --> 01:14:50.610
AUDIENCE: Hi.

01:14:50.610 --> 01:14:52.740
Android Studio 2 looks amazing.

01:14:52.740 --> 01:14:56.510
But I have a very simple
question about fine usages.

01:14:56.510 --> 01:15:00.770
Is there an easy way to
prevent it from listing usages

01:15:00.770 --> 01:15:05.647
and generated stuff like
merged intermediates?

01:15:05.647 --> 01:15:08.230
TOR NORBYE: Yeah, I think that's
actually a question for Alex.

01:15:08.230 --> 01:15:11.024
Because in general, we
try not to do that, right?

01:15:11.024 --> 01:15:12.940
ALEX RUIZ: Yeah, but I
think that's a bug now.

01:15:12.940 --> 01:15:13.580
TOR NORBYE: OK.

01:15:13.580 --> 01:15:15.770
You found a bug.

01:15:15.770 --> 01:15:17.860
Yeah.

01:15:17.860 --> 01:15:20.174
In Gradle sync, you
do a lot of work.

01:15:20.174 --> 01:15:22.340
To make sure that generated
things are recognized as

01:15:22.340 --> 01:15:24.150
generated.

01:15:24.150 --> 01:15:27.050
ALEX RUIZ: But we still
have to do more work

01:15:27.050 --> 01:15:29.840
to get those generated
codes outside some searches

01:15:29.840 --> 01:15:32.050
and refactoring targets.

01:15:32.050 --> 01:15:34.280
TOR NORBYE: Do you already
have a bug tracking that?

01:15:34.280 --> 01:15:35.196
ALEX RUIZ: I think so.

01:15:35.196 --> 01:15:36.270
TOR NORBYE: OK, yeah.

01:15:36.270 --> 01:15:37.103
AUDIENCE: Thank you.

01:15:37.103 --> 01:15:39.544
TOR NORBYE: Alex
is working on it.

01:15:39.544 --> 01:15:40.085
AUDIENCE: Hi.

01:15:40.085 --> 01:15:43.680
I really like the Debugger, but
sometimes, in some projects,

01:15:43.680 --> 01:15:46.350
it tries to resolve my
variables and it doesn't

01:15:46.350 --> 01:15:48.690
seem to be able to do that.

01:15:48.690 --> 01:15:51.140
Is that something you
recognized as well?

01:15:51.140 --> 01:15:55.120
Or what's, kind of, the remedy
to get it working again?

01:15:55.120 --> 01:15:57.950
SIVA VELUSAMY: When you
see it does not recognize,

01:15:57.950 --> 01:16:00.000
are you talking
about it gets stuck?

01:16:00.000 --> 01:16:01.090
Or are you just saying--

01:16:01.090 --> 01:16:04.820
AUDIENCE: It just cannot resolve
the variables at a break point,

01:16:04.820 --> 01:16:05.990
so to speak.

01:16:05.990 --> 01:16:07.740
SIVA VELUSAMY: Well,
resolving a variable,

01:16:07.740 --> 01:16:11.830
I'm not sure if it's a scope
issue stuck in the wrong area

01:16:11.830 --> 01:16:14.670
and that variable is just
not visible in that scope,

01:16:14.670 --> 01:16:17.697
or it's more of
an issue of, there

01:16:17.697 --> 01:16:19.530
is an issue with the
connection, and then it

01:16:19.530 --> 01:16:20.670
doesn't get through.

01:16:20.670 --> 01:16:22.880
But if it's something that
is very specific and very

01:16:22.880 --> 01:16:26.880
reproducible, you should
certainly file a bug.

01:16:26.880 --> 01:16:29.190
As long as it's there in the
scope, it should be there.

01:16:29.190 --> 01:16:30.065
It should be visible.

01:16:30.065 --> 01:16:32.090
AUDIENCE: OK, but not
like clean project

01:16:32.090 --> 01:16:33.430
or restart Android Studio?

01:16:33.430 --> 01:16:34.930
SIVA VELUSAMY: I
mean, of course you

01:16:34.930 --> 01:16:36.490
shouldn't have to do all that.

01:16:36.490 --> 01:16:38.620
Certainly file the bug.

01:16:38.620 --> 01:16:40.120
AUDIENCE: Do you
guys have any plans

01:16:40.120 --> 01:16:44.120
for improving or integrating
Hierarchy Viewer and improved

01:16:44.120 --> 01:16:45.454
view tree editing and reviewing?

01:16:45.454 --> 01:16:46.744
SIVA VELUSAMY: That is correct.

01:16:46.744 --> 01:16:48.320
That is coming
through pretty soon,

01:16:48.320 --> 01:16:49.861
like over the next
year we'll see it.

01:16:51.880 --> 01:16:54.395
Pretty much all the tools
that are present in DDMS,

01:16:54.395 --> 01:16:55.770
I think all the
performance tools

01:16:55.770 --> 01:16:57.310
will come in Android Studio.

01:16:57.310 --> 01:17:00.640
Anything that was part of the
standalone or present in DDMS

01:17:00.640 --> 01:17:02.620
monitor, you will
see all of them being

01:17:02.620 --> 01:17:04.370
integrated into Android Studio.

01:17:04.370 --> 01:17:05.670
TOR NORBYE: Yeah, I think
the only reason monitor

01:17:05.670 --> 01:17:08.280
is a separate tool today is that
we haven't replaced absolutely

01:17:08.280 --> 01:17:08.920
everything yet.

01:17:08.920 --> 01:17:10.290
SIVA VELUSAMY: Yes.

01:17:10.290 --> 01:17:13.000
AUDIENCE: Still about the
standalone performance tool.

01:17:13.000 --> 01:17:15.210
My coworker point
out, like, do you

01:17:15.210 --> 01:17:18.090
have any plan to
make some output

01:17:18.090 --> 01:17:21.950
so we can use these
performance tool in the CI

01:17:21.950 --> 01:17:25.209
so we can automatically
detect the performance issues?

01:17:25.209 --> 01:17:26.250
ESTEBAN DE LA CANAL: Yes.

01:17:26.250 --> 01:17:26.749
Yes.

01:17:26.749 --> 01:17:29.790
So part of the
thing we plan to do

01:17:29.790 --> 01:17:32.010
is, we have this in
a separate library.

01:17:32.010 --> 01:17:35.430
But you could call command line,
all this analysis that will do.

01:17:35.430 --> 01:17:37.910
So the idea is that you
can write regression tests,

01:17:37.910 --> 01:17:39.540
or whatever you
need to make sure

01:17:39.540 --> 01:17:41.890
that your application doesn't
regress in the performance

01:17:41.890 --> 01:17:43.520
space.

01:17:43.520 --> 01:17:45.360
So that will be covered, yes.

01:17:45.360 --> 01:17:47.580
TOR NORBYE: Is there
something in Espresso as well

01:17:47.580 --> 01:17:49.340
for doing performance testing?

01:17:49.340 --> 01:17:52.770
MICHAL BENDOWSKI: Yes, it was
mentioned in the testing talk.

01:17:52.770 --> 01:17:55.148
So, yeah, I recommend
you watch it later.

01:17:55.148 --> 01:17:58.090
TOR NORBYE: Yeah.

01:17:58.090 --> 01:17:58.590
OK.

01:17:58.590 --> 01:18:00.000
Any other questions?

01:18:02.812 --> 01:18:05.270
KATHRYN SHIH: Everyone knows
everything they would possibly

01:18:05.270 --> 01:18:06.353
want to know about Studio.

01:18:10.265 --> 01:18:10.890
TOR NORBYE: OK.

01:18:10.890 --> 01:18:12.973
In that case, I thank you
very much for your time.

01:18:12.973 --> 01:18:15.890
[APPLAUSE]

01:18:15.890 --> 01:18:17.440
[ELECTRONIC MUSIC]

