WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.832
[UPBEAT MUSIC PLAYING]

00:00:04.720 --> 00:00:06.380
XAVIER DUCROHET:
I'm Xavier Ducrohet.

00:00:06.380 --> 00:00:08.252
I work on the
developer tools team.

00:00:08.252 --> 00:00:09.960
AURIMAS LIUTIKAS: Hi,
my name is Aurimas,

00:00:09.960 --> 00:00:12.287
and I am from
Android Toolkit Team.

00:00:12.287 --> 00:00:14.370
Seems like everyone is
very awake, which is great.

00:00:14.370 --> 00:00:17.550
Thanks for the attention
you guys are giving us.

00:00:17.550 --> 00:00:20.160
Anyway, so we're going to be
talking about building bigger,

00:00:20.160 --> 00:00:24.360
better, from a perspective of
a big Gradle Project, AndroidX,

00:00:24.360 --> 00:00:26.400
and well as Android Studio.

00:00:26.400 --> 00:00:29.880
We're here to hopefully dispel
the myth that you cannot build

00:00:29.880 --> 00:00:32.460
big projects with Gradle.

00:00:32.460 --> 00:00:35.640
So, every project starts
simple, but quickly,

00:00:35.640 --> 00:00:37.210
as you add more
and more features,

00:00:37.210 --> 00:00:38.940
it gets really complicated.

00:00:38.940 --> 00:00:41.977
And from my work on Chrome
for Android and AndroidX,

00:00:41.977 --> 00:00:43.560
formerly known as
the Support Library,

00:00:43.560 --> 00:00:45.960
I learned that Android
projects are just the same.

00:00:45.960 --> 00:00:49.860
They start as big monolithic
projects, they grow over time,

00:00:49.860 --> 00:00:52.770
and each incremental
change makes sense.

00:00:52.770 --> 00:00:55.390
For some context, over
the past six years,

00:00:55.390 --> 00:00:59.560
AndroidX grew from 5
to 240 Gradle projects.

00:00:59.560 --> 00:01:03.240
We went from 90,000 lines
of code to over 400,000.

00:01:03.240 --> 00:01:05.367
We have an order of
magnitude, more commits,

00:01:05.367 --> 00:01:07.200
writing all the cool
libraries for you guys,

00:01:07.200 --> 00:01:10.420
like Jetpack Compose and others.

00:01:10.420 --> 00:01:13.335
But as you can imagine, the
initial Gradle config just

00:01:13.335 --> 00:01:14.460
couldn't keep up with this.

00:01:14.460 --> 00:01:16.168
It was, like, not good
enough of a setup.

00:01:16.168 --> 00:01:19.260
So, in this talk, we will
focus on how we made it better

00:01:19.260 --> 00:01:21.480
and how we improved.

00:01:21.480 --> 00:01:24.150
So, let me state the obvious,
when it comes to builds,

00:01:24.150 --> 00:01:26.650
modularization is good.

00:01:26.650 --> 00:01:28.760
You, first of all,
get more parallelism.

00:01:28.760 --> 00:01:30.790
So, you are able to
compile multiple projects

00:01:30.790 --> 00:01:32.020
at the same time.

00:01:32.020 --> 00:01:33.850
You also get more
compilation avoidance

00:01:33.850 --> 00:01:37.960
because Gradle is able to skip
certain libraries in cases.

00:01:37.960 --> 00:01:41.140
For your fetches, you're often
invalidating fewer projects,

00:01:41.140 --> 00:01:44.620
so you get fewer
cache invalidations.

00:01:44.620 --> 00:01:47.170
Additionally, you avoid
tangled dependencies

00:01:47.170 --> 00:01:49.180
that you get from
monolithic builds.

00:01:49.180 --> 00:01:51.130
We definitely struggled
with that in AndroidX,

00:01:51.130 --> 00:01:52.460
for libraries like v4.

00:01:52.460 --> 00:01:57.830
We added dozens of classes and
there was circular dependencies

00:01:57.830 --> 00:02:00.460
that made it almost impossible
to pull those libraries apart

00:02:00.460 --> 00:02:02.380
into smaller pieces.

00:02:02.380 --> 00:02:05.470
And finally, you get
to test your libraries

00:02:05.470 --> 00:02:08.560
easier because now your
libraries live with the tests

00:02:08.560 --> 00:02:09.289
next to them.

00:02:09.289 --> 00:02:13.833
So, you exactly know what to
test when you make a change.

00:02:13.833 --> 00:02:15.500
In architecture
components, for example,

00:02:15.500 --> 00:02:17.650
we found that creating
pure Java libraries

00:02:17.650 --> 00:02:20.740
as a common layer between other
libraries was really helpful.

00:02:20.740 --> 00:02:22.240
First of all, you
get the separation

00:02:22.240 --> 00:02:25.910
from Android APIs, which lets
you run those tests on a host.

00:02:25.910 --> 00:02:28.492
Which is really fast, it's
not running on the phone.

00:02:28.492 --> 00:02:29.950
Additionally, you
get faster builds

00:02:29.950 --> 00:02:36.340
because by definition, these
non-Android, Java and Kotlin

00:02:36.340 --> 00:02:38.080
projects are a lot lighter.

00:02:38.080 --> 00:02:40.060
They don't handle variants.

00:02:40.060 --> 00:02:42.560
They don't have
Android resources.

00:02:42.560 --> 00:02:44.630
They don't have
manifests and so on.

00:02:44.630 --> 00:02:46.397
So, for your project,
if you can pull out

00:02:46.397 --> 00:02:47.980
these kind of projects,
I would highly

00:02:47.980 --> 00:02:52.020
recommend starting with making
them pure Kotlin or Java.

00:02:52.020 --> 00:02:55.440
Gradle plugins can be great,
but overusing them can cause you

00:02:55.440 --> 00:02:57.133
issues and wasted work.

00:02:57.133 --> 00:02:58.800
For example, if you
have a Gradle plugin

00:02:58.800 --> 00:03:00.960
for publishing to
Maven, you really

00:03:00.960 --> 00:03:02.760
should be applying it
to the project that

00:03:02.760 --> 00:03:04.830
needs to publish to Maven.

00:03:04.830 --> 00:03:06.840
Otherwise, you're
creating all these tasks

00:03:06.840 --> 00:03:08.840
and you will be wasting time.

00:03:08.840 --> 00:03:10.410
So, modularization
here helps you

00:03:10.410 --> 00:03:13.740
to apply these kind of plugins
to a much smaller scope,

00:03:13.740 --> 00:03:16.280
so you're applying it to
a smaller project that

00:03:16.280 --> 00:03:18.720
leads to faster builds.

00:03:18.720 --> 00:03:21.780
Similarly to the plugins,
annotation processors

00:03:21.780 --> 00:03:25.230
can waste time, especially
a nonincremental type.

00:03:25.230 --> 00:03:27.750
For example, if you use
AndroidX Room Library,

00:03:27.750 --> 00:03:30.570
you should really pull the
libraries that need Room

00:03:30.570 --> 00:03:33.450
into a separate project, and run
the annotation processor just

00:03:33.450 --> 00:03:34.800
on that project.

00:03:34.800 --> 00:03:38.490
That way, you isolate on what
the annotation processor runs,

00:03:38.490 --> 00:03:41.280
thus increasing your speed.

00:03:41.280 --> 00:03:43.440
If your project
is an application,

00:03:43.440 --> 00:03:45.390
you should really
consider running Lint only

00:03:45.390 --> 00:03:47.110
in the final project.

00:03:47.110 --> 00:03:50.087
Because while Lint is
amazing at finding bugs,

00:03:50.087 --> 00:03:51.670
as you do modularization,
you're going

00:03:51.670 --> 00:03:55.230
to be running it on more and
more projects, slowing it down.

00:03:55.230 --> 00:03:57.330
However, I want to note,
if you do ship libraries,

00:03:57.330 --> 00:03:58.950
I would highly
recommend continuing

00:03:58.950 --> 00:04:02.520
to run Lint on those libraries,
because things like Minimum SDK

00:04:02.520 --> 00:04:06.600
affect how Lint runs, and you
will return different results

00:04:06.600 --> 00:04:09.170
and help you catch bugs.

00:04:09.170 --> 00:04:11.580
We introduced the concept
of API and implementation

00:04:11.580 --> 00:04:12.880
over two years ago.

00:04:12.880 --> 00:04:15.560
It allows you to specify
your dependencies

00:04:15.560 --> 00:04:17.820
as implementation details,
which, essentially,

00:04:17.820 --> 00:04:20.709
helps with compilation avoidance
that I mentioned before.

00:04:20.709 --> 00:04:22.380
If you want to learn
more about that,

00:04:22.380 --> 00:04:26.110
there's a recording from
yesterday of the topic

00:04:26.110 --> 00:04:28.100
that Xav did.

00:04:28.100 --> 00:04:30.330
So, it's not all great.

00:04:30.330 --> 00:04:32.450
There are some downsides
of doing the breakdown.

00:04:32.450 --> 00:04:36.660
And one of the obvious ones is
you have a larger dependency

00:04:36.660 --> 00:04:37.160
graph.

00:04:37.160 --> 00:04:39.538
So, Gradle has to load
up more build files,

00:04:39.538 --> 00:04:42.080
and figure out what's going on
and what the dependencies are.

00:04:42.080 --> 00:04:45.242
But often, these are
offset by the fact

00:04:45.242 --> 00:04:47.450
that you're doing a lot of
saving from all the things

00:04:47.450 --> 00:04:49.280
that I described before.

00:04:49.280 --> 00:04:51.530
One thing that is not so
easy and not so obvious

00:04:51.530 --> 00:04:54.200
is that you have a lot
more build files now.

00:04:54.200 --> 00:04:57.331
And this is one of the things
we struggled a lot in AndroidX.

00:04:59.880 --> 00:05:02.400
A standard practice in
software engineering

00:05:02.400 --> 00:05:04.290
is not to repeat
yourself, and the same

00:05:04.290 --> 00:05:07.320
applies to build dot
configuration files.

00:05:07.320 --> 00:05:09.998
Less code is simply
easier to manage.

00:05:09.998 --> 00:05:11.540
In AndroidX, for
example, if you want

00:05:11.540 --> 00:05:13.920
it to bump to a new
version of Espresso,

00:05:13.920 --> 00:05:16.290
that meant touching a
hundred build.gradle files

00:05:16.290 --> 00:05:18.990
and doing the same manual
change every place.

00:05:18.990 --> 00:05:20.305
And it was really error prone.

00:05:20.305 --> 00:05:21.430
It was really easy to make.

00:05:21.430 --> 00:05:22.650
In a mistake.

00:05:22.650 --> 00:05:24.870
So, these kind of
explicit versions

00:05:24.870 --> 00:05:27.120
made it difficult
to upgrade, and also

00:05:27.120 --> 00:05:30.180
was unclear of what versions
are used across the project.

00:05:33.220 --> 00:05:35.340
So, one option to kind
of get around that

00:05:35.340 --> 00:05:38.220
is to use Gradle's
extra [? stash, ?]

00:05:38.220 --> 00:05:41.040
so it allows you to put
strings on this object.

00:05:41.040 --> 00:05:45.270
And then you set it up in
your root build.gradle file.

00:05:45.270 --> 00:05:47.130
Then, to utilize
them, you can put it

00:05:47.130 --> 00:05:51.300
in each project as build.gradle
file and then, use it there.

00:05:51.300 --> 00:05:53.220
The solves a
centralization problem

00:05:53.220 --> 00:05:54.940
and makes it really
easy to update.

00:05:54.940 --> 00:05:56.982
So, instead of having to
touch hundreds of files,

00:05:56.982 --> 00:05:58.620
you touch it in one
place, and now you

00:05:58.620 --> 00:06:01.900
have the updated version
throughout of your project.

00:06:01.900 --> 00:06:03.390
It can be further
extended to use

00:06:03.390 --> 00:06:07.080
this kind of extra property
for other things as well.

00:06:07.080 --> 00:06:09.630
In AndroidX, we used this a
lot and it was very helpful,

00:06:09.630 --> 00:06:12.397
but sadly, you do not get
things like autocomplete

00:06:12.397 --> 00:06:14.730
and you do not get to click
through and see what version

00:06:14.730 --> 00:06:16.740
you are actually setting.

00:06:16.740 --> 00:06:19.110
So, to get around
that, there is a way.

00:06:19.110 --> 00:06:22.260
Gradle offers you an implicit
build that gets automatically

00:06:22.260 --> 00:06:24.080
added to the build class bath.

00:06:24.080 --> 00:06:26.490
All you need to do is to
create a build source directory

00:06:26.490 --> 00:06:28.950
and add build.gradle in
there, and that project will

00:06:28.950 --> 00:06:31.540
automatically get built
before your real project,

00:06:31.540 --> 00:06:34.350
and you will get added
to your build class bath.

00:06:34.350 --> 00:06:37.380
So, solving the same
dependencies problem,

00:06:37.380 --> 00:06:40.710
you can create a Kotlin
file in build source,

00:06:40.710 --> 00:06:43.940
and just like in step one,
you have the same thing,

00:06:43.940 --> 00:06:47.190
but now you're writing
it all in Kotlin.

00:06:47.190 --> 00:06:49.530
And then, similarly,
you also refer to it

00:06:49.530 --> 00:06:51.510
in your build.gradle files.

00:06:51.510 --> 00:06:54.330
We eventually move to
this style to specify

00:06:54.330 --> 00:06:56.520
all of our dependencies
in AndroidX.

00:06:56.520 --> 00:06:59.010
It gives you the same
centralization benefits,

00:06:59.010 --> 00:07:01.890
you also get autocomplete,
and you get the click through

00:07:01.890 --> 00:07:05.577
to see the versions that
you are actually using.

00:07:05.577 --> 00:07:08.160
So, in AndroidX, we found that
there's way more configurations

00:07:08.160 --> 00:07:10.830
that we found the same from
build file to build file,

00:07:10.830 --> 00:07:11.660
to build file.

00:07:11.660 --> 00:07:13.830
And a lot of these were
coming from Android

00:07:13.830 --> 00:07:16.980
to Gradle plugin,
and that Android DSL.

00:07:16.980 --> 00:07:20.040
So, using extra property,
like we did in the beginning,

00:07:20.040 --> 00:07:23.010
did not quite scale because
you cannot create things like

00:07:23.010 --> 00:07:26.710
flavors and stuff very
easily at the root.

00:07:26.710 --> 00:07:29.670
So, Gradle handles configuration
via plugin most of the time,

00:07:29.670 --> 00:07:32.930
and you can create one of
your own in Build Source.

00:07:32.930 --> 00:07:35.520
In AndroidX, we
created one of them

00:07:35.520 --> 00:07:37.350
to set the common
properties that were

00:07:37.350 --> 00:07:39.680
common across all the projects.

00:07:39.680 --> 00:07:41.550
In this light,
the important part

00:07:41.550 --> 00:07:43.460
is to override the apply method.

00:07:43.460 --> 00:07:46.910
That's the one that gets called
when you apply the plugin.

00:07:46.910 --> 00:07:49.860
And when you are
applied, you can react

00:07:49.860 --> 00:07:51.130
when other plugins are added.

00:07:51.130 --> 00:07:53.850
So, for example, if Android
Gradle plugin is added,

00:07:53.850 --> 00:07:55.537
you can react to
it, and then you

00:07:55.537 --> 00:07:57.870
can take the extension, which
is essentially the backing

00:07:57.870 --> 00:08:01.380
store that you can use
in build.gradle files

00:08:01.380 --> 00:08:04.770
behind the Android DSL,
and you can set things up.

00:08:04.770 --> 00:08:08.040
So, one thing to note here,
you can have one custom plugin

00:08:08.040 --> 00:08:11.400
that you wrote that handles
many, many external plugins,

00:08:11.400 --> 00:08:13.900
you don't need to write
one for each plugin.

00:08:13.900 --> 00:08:16.570
So, in this example, this
handles both, Android library

00:08:16.570 --> 00:08:19.470
plugin and Android
application plugin.

00:08:19.470 --> 00:08:23.170
And then, as you get up, you
just get automatically set up.

00:08:23.170 --> 00:08:24.990
So, here, you have
the same power

00:08:24.990 --> 00:08:28.770
as you had in Android
DSL in your build.gradle.

00:08:28.770 --> 00:08:30.300
You can set things
like target SDK,

00:08:30.300 --> 00:08:32.010
you can set the
default test runner,

00:08:32.010 --> 00:08:33.870
enable coverage, and so on.

00:08:33.870 --> 00:08:35.880
The two extensions that
you really care about

00:08:35.880 --> 00:08:37.669
are library extension,
from the library

00:08:37.669 --> 00:08:42.000
plugin, and app extension,
from the application plugin.

00:08:42.000 --> 00:08:43.600
Same is true for other plugins.

00:08:43.600 --> 00:08:45.720
So, for example, if you
have a Java library,

00:08:45.720 --> 00:08:47.707
you can also configure
it in the same way.

00:08:47.707 --> 00:08:49.290
The only difference,
here, is that you

00:08:49.290 --> 00:08:52.120
have to use a convention
instead of an extension.

00:08:52.120 --> 00:08:54.790
It's very similar otherwise.

00:08:54.790 --> 00:08:57.180
So, when you have the setup,
it's super easy to apply,

00:08:57.180 --> 00:08:59.580
and creating a new
module becomes trivial.

00:08:59.580 --> 00:09:02.490
All your developers have to do
is throw in a few lines of code

00:09:02.490 --> 00:09:04.470
and you're pretty much set.

00:09:04.470 --> 00:09:08.190
So, in AndroidX, specifically,
which has huge gains of this,

00:09:08.190 --> 00:09:11.070
we went from over
150 lines of code

00:09:11.070 --> 00:09:13.080
for a build.gradle
for a project,

00:09:13.080 --> 00:09:16.500
to around 35 lines of
code for build.gradle.

00:09:16.500 --> 00:09:18.930
And considering we
have 240 projects,

00:09:18.930 --> 00:09:20.670
that's a huge savings.

00:09:20.670 --> 00:09:23.790
So, in our plugin, we set up
things like Maven configuration

00:09:23.790 --> 00:09:26.430
for uploading, we
set up java.builds,

00:09:26.430 --> 00:09:30.150
and Lint, and other
uniform properties.

00:09:30.150 --> 00:09:32.700
Sadly, we hit an
issue where if you

00:09:32.700 --> 00:09:34.360
want to do a custom
configuration just

00:09:34.360 --> 00:09:36.660
to one library-- for example,
if one of your libraries

00:09:36.660 --> 00:09:39.570
has a different
Minimum SDK version,

00:09:39.570 --> 00:09:41.560
the setup didn't
really allow for that.

00:09:41.560 --> 00:09:43.350
So, we needed to find
a way to accommodate

00:09:43.350 --> 00:09:45.720
for this kind of change.

00:09:45.720 --> 00:09:48.290
So, the first option is just
to set those custom values

00:09:48.290 --> 00:09:50.467
in each library
build.gradle file.

00:09:50.467 --> 00:09:52.550
In this example, we're
setting a different Minimum

00:09:52.550 --> 00:09:56.160
SDK and different
target Java version.

00:09:56.160 --> 00:09:58.080
And in AndroidX, we
did exactly that.

00:09:58.080 --> 00:10:00.400
So, this is a real
example from lifecycle,

00:10:00.400 --> 00:10:02.240
a runtime on build.gradle.

00:10:02.240 --> 00:10:05.690
We simply applied AndroidX
plugin, Android library plugin,

00:10:05.690 --> 00:10:07.880
we set up the
dependencies, and just add

00:10:07.880 --> 00:10:11.510
some options for
Android DSL that

00:10:11.510 --> 00:10:13.880
are specific to this library,
like, this library harshly

00:10:13.880 --> 00:10:18.410
has ProGuard configs that we
want to ship inside of the AAR.

00:10:18.410 --> 00:10:20.090
One difference here
is we also created

00:10:20.090 --> 00:10:24.210
our own DSL that allows us to
tweak our own plugin works.

00:10:24.210 --> 00:10:26.360
So, when our plugin
sets everything up,

00:10:26.360 --> 00:10:28.040
it reads these
values and then we're

00:10:28.040 --> 00:10:31.820
able to specify how our
Maven publishing works.

00:10:31.820 --> 00:10:34.250
So, isn't it great to see
all of the configuration

00:10:34.250 --> 00:10:37.040
for one real production
library in two slides?

00:10:37.040 --> 00:10:38.520
I sure think so.

00:10:38.520 --> 00:10:40.520
And Xav is going to
talk about how to set up

00:10:40.520 --> 00:10:42.500
this custom Gradle DSL.

00:10:42.500 --> 00:10:43.814
XAVIER DUCROHET: Thank you.

00:10:43.814 --> 00:10:46.676
[AUDIENCE CLAPPING]

00:10:49.980 --> 00:10:52.230
So, let's say you want to
configure your own extension

00:10:52.230 --> 00:10:53.355
for your own plugin, right?

00:10:53.355 --> 00:10:56.288
Let's take a very
simple example,

00:10:56.288 --> 00:10:58.080
here, you have your
own plugin and you just

00:10:58.080 --> 00:11:01.060
want to have my config
with one property in it.

00:11:01.060 --> 00:11:03.810
So, here, I want to press
each one to be a Boolean.

00:11:03.810 --> 00:11:07.980
Notice that I'm
using a setter here

00:11:07.980 --> 00:11:09.880
and we're going to
see why in a second.

00:11:09.880 --> 00:11:11.505
So, the first thing
that you need to do

00:11:11.505 --> 00:11:13.050
is to create an extension class.

00:11:13.050 --> 00:11:15.360
And this extension
class is very basic.

00:11:15.360 --> 00:11:19.230
It doesn't need to extend
anything, and so here I have it

00:11:19.230 --> 00:11:20.460
and I have my property.

00:11:20.460 --> 00:11:22.090
So, notice two things.

00:11:22.090 --> 00:11:25.290
The first one, I'm not
declaring a Boolean type--

00:11:25.290 --> 00:11:28.110
I'm not using a Boolean type,
I'm using a property Boolean.

00:11:28.110 --> 00:11:30.930
That is a new API integrator
that introduced maybe

00:11:30.930 --> 00:11:33.030
about a year ago.

00:11:33.030 --> 00:11:35.700
And the second thing
that you can notice here

00:11:35.700 --> 00:11:38.610
is that I'm declaring
both the class

00:11:38.610 --> 00:11:41.010
and the property as abstract.

00:11:41.010 --> 00:11:43.200
So, those property objects
have to be instantiated

00:11:43.200 --> 00:11:45.005
in a very special way.

00:11:45.005 --> 00:11:46.380
And in order to
do that manually,

00:11:46.380 --> 00:11:49.500
you have to inject a
factory into your class.

00:11:49.500 --> 00:11:51.000
And it's really a
lot of boilerplate

00:11:51.000 --> 00:11:52.083
that you don't want to do.

00:11:52.083 --> 00:11:54.810
So, starting, I think,
two versions of Gradle

00:11:54.810 --> 00:11:57.762
ago, if you declare your
classes as abstract,

00:11:57.762 --> 00:11:59.220
Gradle is going to
take care of it.

00:11:59.220 --> 00:12:00.690
Because, anyway,
what Gradle does

00:12:00.690 --> 00:12:03.580
is that it never uses
your type directly,

00:12:03.580 --> 00:12:06.270
it always extends your type
and creates a decorated version

00:12:06.270 --> 00:12:06.848
of it.

00:12:06.848 --> 00:12:08.640
And so here, when it
creates that new type,

00:12:08.640 --> 00:12:10.307
it's going to take
care of instantiating

00:12:10.307 --> 00:12:15.620
all the properties of
type, properties something.

00:12:15.620 --> 00:12:18.990
So, the way you instantiate
it is just this way,

00:12:18.990 --> 00:12:21.320
called Project Extension Create.

00:12:21.320 --> 00:12:24.880
Aurimas's example had a
project extension, get by type.

00:12:24.880 --> 00:12:26.040
So, here we create it.

00:12:26.040 --> 00:12:27.547
The string is called my config.

00:12:27.547 --> 00:12:29.130
This is what will
show up on your DSL.

00:12:29.130 --> 00:12:30.510
And you provide your type.

00:12:30.510 --> 00:12:33.090
The instance that
may fail to return

00:12:33.090 --> 00:12:35.155
is not exactly
MyPluginExtension.

00:12:35.155 --> 00:12:36.780
It's going to be the
decorated version,

00:12:36.780 --> 00:12:37.905
but you don't have to care.

00:12:37.905 --> 00:12:39.825
You can just keep
manipulating your own task.

00:12:39.825 --> 00:12:41.700
All the things that's
added onto on above it,

00:12:41.700 --> 00:12:45.178
you don't really have
to worry about it.

00:12:45.178 --> 00:12:46.720
So now you want to
use that, you want

00:12:46.720 --> 00:12:50.260
to use that value that
you set in the DSL

00:12:50.260 --> 00:12:52.980
into a task as an input.

00:12:52.980 --> 00:12:56.740
And so here, I'm creating a
task, and I have a property,

00:12:56.740 --> 00:12:58.900
and I'm also setting
the type of the property

00:12:58.900 --> 00:13:01.240
to be property of Boolean.

00:13:01.240 --> 00:13:02.630
This is very important.

00:13:02.630 --> 00:13:04.600
I'm also declaring
it as abstract

00:13:04.600 --> 00:13:07.030
and the task also
type, instead of

00:13:07.030 --> 00:13:10.120
being just a regular open
type that you would do,

00:13:10.120 --> 00:13:12.820
I'm declaring it as abstract
so that Gradle can decorate it

00:13:12.820 --> 00:13:15.460
and do the right thing for me.

00:13:15.460 --> 00:13:17.350
Next, I want to
actually register

00:13:17.350 --> 00:13:18.970
my task using the lazy API.

00:13:18.970 --> 00:13:21.640
So register and a callback
that's a lambda that gets

00:13:21.640 --> 00:13:24.490
called whenever your
task gets configured.

00:13:24.490 --> 00:13:27.970
And here I am setting
on to my task property,

00:13:27.970 --> 00:13:30.637
the property coming
from my extension.

00:13:30.637 --> 00:13:31.720
I'm not setting the value.

00:13:31.720 --> 00:13:35.500
I'm not doing myconfig.supress
LintWarnings.get,

00:13:35.500 --> 00:13:37.810
if you do that, you lose
some of the benefits.

00:13:37.810 --> 00:13:40.600
And so by using the
property directly,

00:13:40.600 --> 00:13:43.760
you're basically doing a
lazy binding between the two.

00:13:43.760 --> 00:13:46.270
So what happens is that this
code here, the register,

00:13:46.270 --> 00:13:48.850
really is likely to
happen in your apply.

00:13:48.850 --> 00:13:51.530
And your apply is at the
very top of build.gradle.

00:13:51.530 --> 00:13:53.750
So if you change
the value later,

00:13:53.750 --> 00:13:56.418
it's important that you do not
set the value in the apply,

00:13:56.418 --> 00:13:58.210
because then if you
change the value later,

00:13:58.210 --> 00:14:00.170
then the task will
have the old value.

00:14:00.170 --> 00:14:02.380
So by using properties,
you guarantee

00:14:02.380 --> 00:14:05.410
that whenever you're actually
configuring your task,

00:14:05.410 --> 00:14:07.960
or whenever you're setting
the last value in the DSL,

00:14:07.960 --> 00:14:11.920
at the end your task will have
the letter's value anyway.

00:14:11.920 --> 00:14:13.442
So this is a new
feature of Gradle

00:14:13.442 --> 00:14:15.400
and it's really efficient
and you should really

00:14:15.400 --> 00:14:17.930
use property everywhere.

00:14:17.930 --> 00:14:21.160
OK, let's look at other
tips to really configure

00:14:21.160 --> 00:14:24.710
your project in the most
efficient way possible.

00:14:24.710 --> 00:14:27.550
So when we talk
about configuration,

00:14:27.550 --> 00:14:29.290
the first advice
that I have is really

00:14:29.290 --> 00:14:30.640
do as little as possible.

00:14:30.640 --> 00:14:33.380
I see a lot of people who do a
lot of things in their build.

00:14:33.380 --> 00:14:35.940
They have 150 lines
in their build.gradle

00:14:35.940 --> 00:14:37.850
and they do crazy
things in there.

00:14:37.850 --> 00:14:39.100
And this is a cost you're
going to pay, all right?

00:14:39.100 --> 00:14:41.020
Every time you go into
Gradle, whether you're

00:14:41.020 --> 00:14:43.860
syncing, doing a build,
querying for the list of tasks,

00:14:43.860 --> 00:14:45.110
you're going to pay that cost.

00:14:45.110 --> 00:14:48.950
So it's important that you
do as little as possible.

00:14:48.950 --> 00:14:51.970
Another advice is
try to see what

00:14:51.970 --> 00:14:56.710
you can do that in release,
but not do it in debug.

00:14:56.710 --> 00:14:58.497
You have those build
times by default,

00:14:58.497 --> 00:15:00.580
we see a lot of people
doing way too much in debug

00:15:00.580 --> 00:15:01.705
that they don't need to do.

00:15:01.705 --> 00:15:02.690
Don't do it.

00:15:02.690 --> 00:15:05.470
And then on CI, make
sure that you only build

00:15:05.470 --> 00:15:06.700
whatever you actually need.

00:15:06.700 --> 00:15:09.040
We see people calling
assemble, and that build is

00:15:09.040 --> 00:15:10.040
way more than they need.

00:15:12.740 --> 00:15:14.930
So around
configuration of tasks,

00:15:14.930 --> 00:15:17.690
you know I just showed you
the tasks that register.

00:15:17.690 --> 00:15:21.650
And it's particularly
important to use the lazy API,

00:15:21.650 --> 00:15:23.960
because in Android, by default
you have five variants.

00:15:23.960 --> 00:15:25.668
For each module, you
have debug, release,

00:15:25.668 --> 00:15:26.960
and then three test variant.

00:15:26.960 --> 00:15:28.430
So it creates a lot of tasks.

00:15:28.430 --> 00:15:31.820
Here in the example that I have,
100 modules, it's 19,000 tasks.

00:15:31.820 --> 00:15:34.980
You don't want to create
and configure all of them.

00:15:34.980 --> 00:15:37.160
So we are already doing that.

00:15:37.160 --> 00:15:38.910
What's important for
you is two things.

00:15:38.910 --> 00:15:41.810
First, when you create your
own task, create them lazily.

00:15:41.810 --> 00:15:44.670
And second, when you use APIs
from Gradle or from the Android

00:15:44.670 --> 00:15:47.160
plugin, use the proper API.

00:15:47.160 --> 00:15:50.300
There's a lot of legacy API
that returns a task instance,

00:15:50.300 --> 00:15:52.950
and we have them in a GPU,
like, you know on your variants,

00:15:52.950 --> 00:15:55.010
you can do get compiled, that
returns are compiled task.

00:15:55.010 --> 00:15:56.802
If you use that, it's
going to create them,

00:15:56.802 --> 00:15:59.660
it's going to force configuring.

00:15:59.660 --> 00:16:02.120
Gradle has API that we
do on a task provider

00:16:02.120 --> 00:16:05.000
and we have new APIs written,
get compiled provider, that

00:16:05.000 --> 00:16:06.962
returns a task provider
that's a lazy object,

00:16:06.962 --> 00:16:07.920
so you should use that.

00:16:10.470 --> 00:16:13.850
The second thing I want to
talk about is task wiring.

00:16:13.850 --> 00:16:15.560
If you're creating a
lot of custom tasks,

00:16:15.560 --> 00:16:18.780
you probably have
to do some dependsOn

00:16:18.780 --> 00:16:21.140
and that's very fragile and
really you shouldn't do it.

00:16:21.140 --> 00:16:22.730
Let's say you have
A dependsOn B,

00:16:22.730 --> 00:16:25.190
and then later you change
A to actually depend on C,

00:16:25.190 --> 00:16:27.560
if you don't pay attention,
you may depend on B and C

00:16:27.560 --> 00:16:29.040
and that's not what you want.

00:16:29.040 --> 00:16:31.100
So the old way of
doing this is, you

00:16:31.100 --> 00:16:34.580
have the Task1 to generate an
output directory and the type

00:16:34.580 --> 00:16:36.170
of properties File.

00:16:36.170 --> 00:16:40.510
And the Task2 that consumes that
directory and it has a property

00:16:40.510 --> 00:16:43.318
of type File as well.

00:16:43.318 --> 00:16:45.110
And so the way you
configure those two task

00:16:45.110 --> 00:16:49.520
is, on the first one you do
register, output, my location.

00:16:49.520 --> 00:16:53.180
On the second one,
you do inputDir=.

00:16:53.180 --> 00:16:56.320
OK, so normally,
before, if you didn't

00:16:56.320 --> 00:16:59.810
have a lazy configuration,
you could do Task1.outputDir,

00:16:59.810 --> 00:17:02.460
you just link those
two locations directly.

00:17:02.460 --> 00:17:05.250
You can't really do that
in lazy configuration.

00:17:05.250 --> 00:17:07.910
So you have to kind of
either duplicate it or use

00:17:07.910 --> 00:17:10.910
another class that's
centralized or your location

00:17:10.910 --> 00:17:13.940
computation, which is something
we used to do in a GPU

00:17:13.940 --> 00:17:15.300
a long time ago.

00:17:15.300 --> 00:17:17.023
And then you do a
manual dependsOn.

00:17:17.023 --> 00:17:19.190
So the first thing is not
great, then the second one

00:17:19.190 --> 00:17:21.192
is definitely terrible,
you should not do that.

00:17:21.192 --> 00:17:23.400
You might be thinking, well,
it's just the next line,

00:17:23.400 --> 00:17:25.970
so if I update the
value of inputDir,

00:17:25.970 --> 00:17:28.575
I will remember to
change the dependsOn.

00:17:28.575 --> 00:17:30.950
But the reality is that it is
more likely to be somewhere

00:17:30.950 --> 00:17:33.980
else at an integrated
plug in, it was definitely

00:17:33.980 --> 00:17:35.550
in a lot of somewhere else.

00:17:35.550 --> 00:17:37.455
And so we moved away
from all of that.

00:17:37.455 --> 00:17:39.080
So, Gradle in the
last year, after they

00:17:39.080 --> 00:17:41.930
introduced the property
type, they really

00:17:41.930 --> 00:17:43.480
improved a lot of that.

00:17:43.480 --> 00:17:45.230
So let's see what it
looks like and what's

00:17:45.230 --> 00:17:47.690
the best practice today.

00:17:47.690 --> 00:17:49.670
First your Task1, you're
going to change it

00:17:49.670 --> 00:17:53.930
and the property is now going
to be DirectoryProperty.

00:17:53.930 --> 00:17:57.320
And also, I'm using
also DirectoryProperty

00:17:57.320 --> 00:17:59.750
on the second one
and, of course,

00:17:59.750 --> 00:18:01.910
I used the abstract
way, so that Gradle

00:18:01.910 --> 00:18:05.180
takes care of instantiating
all of those objects for me.

00:18:05.180 --> 00:18:07.580
So DirectoryProperty
is very interesting.

00:18:07.580 --> 00:18:09.610
It's actually a property
of directory similar me

00:18:09.610 --> 00:18:12.990
out to the Property Boolean
that I showed earlier.

00:18:12.990 --> 00:18:16.400
So it's dynamic and lazy in the
same way that the other one is.

00:18:16.400 --> 00:18:19.187
But it also includes task
dependency information.

00:18:19.187 --> 00:18:21.020
Even though, when you
look at the type here,

00:18:21.020 --> 00:18:22.940
our key doesn't
really show anything,

00:18:22.940 --> 00:18:25.490
but the Java doc says, hey,
it includes task dependency

00:18:25.490 --> 00:18:27.195
information.

00:18:27.195 --> 00:18:28.820
So let's see how I'm
going to use that.

00:18:28.820 --> 00:18:30.930
Oh, and by the way, you see
that, it's actually directory.

00:18:30.930 --> 00:18:32.940
There is a matching
regular file property,

00:18:32.940 --> 00:18:36.875
so your API is more precise and
you cannot link to Task1 that

00:18:36.875 --> 00:18:39.500
generates a directory, the other
one that reads a file anymore,

00:18:39.500 --> 00:18:42.260
because it's type safe there.

00:18:42.260 --> 00:18:46.000
So setting Task1, it's
very similar, outputDir.set

00:18:46.000 --> 00:18:48.990
and then the value, so
no difference there.

00:18:48.990 --> 00:18:52.178
On the Task2, what I'm
doing is, the same way

00:18:52.178 --> 00:18:53.720
I did with the task
and the extension

00:18:53.720 --> 00:18:56.930
earlier where I'm setting on
one property, the other property

00:18:56.930 --> 00:19:00.570
directly to make a link between
them, I want to do that too.

00:19:00.570 --> 00:19:02.480
But here, because
I have lazy tasks

00:19:02.480 --> 00:19:06.920
while the obvious
easy way or lazy way

00:19:06.920 --> 00:19:10.040
to do it is to say,
well Task1.get and then

00:19:10.040 --> 00:19:11.570
I get the property.

00:19:11.570 --> 00:19:13.070
Well it's not lazy
at all, actually,

00:19:13.070 --> 00:19:15.320
because you got to first
configure your task, which is

00:19:15.320 --> 00:19:16.590
not something you want to do.

00:19:16.590 --> 00:19:20.480
So Task1 and Task2 are
a type of task provider,

00:19:20.480 --> 00:19:23.290
and they have this
thing called flatMap.

00:19:23.290 --> 00:19:27.350
So what flatMap does, it returns
a provider of a directory.

00:19:27.350 --> 00:19:32.040
Provider being the
parent type of property

00:19:32.040 --> 00:19:34.190
and it's a read only type.

00:19:34.190 --> 00:19:36.920
And so this is lazy,
it's going to encapsulate

00:19:36.920 --> 00:19:39.470
the property of Task1.

00:19:39.470 --> 00:19:41.820
And it's going to propagate
the value in a lazy way,

00:19:41.820 --> 00:19:46.500
but it's also going to
propagate the dependency lazy.

00:19:46.500 --> 00:19:50.480
And so now, inputDir
automatically depends on Task1.

00:19:50.480 --> 00:19:52.803
Sorry, Task2 directly
depends on Task1.

00:19:52.803 --> 00:19:53.970
I don't have to do anything.

00:19:53.970 --> 00:19:57.720
If I change input.Dir to be
set to a different value,

00:19:57.720 --> 00:20:00.350
then it will automatically
change my dependency.

00:20:00.350 --> 00:20:03.877
So when you extract flatMap
into an artifact of value,

00:20:03.877 --> 00:20:05.960
that's very interesting,
because these thing, now,

00:20:05.960 --> 00:20:08.772
represent the artifact and
whatever is needed to build it.

00:20:08.772 --> 00:20:10.730
And you don't have to
care about the how, which

00:20:10.730 --> 00:20:13.070
is keeping track of Task1 one.

00:20:13.070 --> 00:20:16.010
So imagine you have a task
that output two things,

00:20:16.010 --> 00:20:18.810
and you have some code
that use those two things.

00:20:18.810 --> 00:20:20.310
And then later, you
change that task

00:20:20.310 --> 00:20:23.390
to actually be two tasks
each that generate one thing.

00:20:23.390 --> 00:20:25.250
If you're already
using the provider

00:20:25.250 --> 00:20:27.262
of directory or provider
of regular file,

00:20:27.262 --> 00:20:28.220
you don't have to care.

00:20:28.220 --> 00:20:30.740
You don't have to keep
track of the task,

00:20:30.740 --> 00:20:32.850
you just keep track
of this artifact.

00:20:32.850 --> 00:20:34.850
And then you just read
it, it doesn't matter who

00:20:34.850 --> 00:20:36.915
created it and it's updated.

00:20:36.915 --> 00:20:38.540
This is something
that is very powerful

00:20:38.540 --> 00:20:40.700
and that makes
code much cleaner.

00:20:40.700 --> 00:20:43.030
This is something that
internally in Gradle plugin

00:20:43.030 --> 00:20:44.660
we're moving toward.

00:20:44.660 --> 00:20:47.300
And then I think
we'll expose that

00:20:47.300 --> 00:20:51.070
as a public API at some point.

00:20:51.070 --> 00:20:53.430
OK, so in my previous
talk, yesterday, we

00:20:53.430 --> 00:20:54.540
talked about worker API.

00:20:54.540 --> 00:20:56.310
Jerome talked
about it, explained

00:20:56.310 --> 00:20:58.985
how things are less
efficient if you

00:20:58.985 --> 00:21:01.110
have tasks that are not
using worker and tasks that

00:21:01.110 --> 00:21:02.200
are using worker.

00:21:02.200 --> 00:21:03.450
So please go look at the talk.

00:21:03.450 --> 00:21:06.510
And the message for you today
is, if you have custom tasks,

00:21:06.510 --> 00:21:08.340
please use the worker API.

00:21:08.340 --> 00:21:10.440
Look at the API online
on the Gradle site,

00:21:10.440 --> 00:21:14.610
it's not that difficult and
you should really do it.

00:21:14.610 --> 00:21:16.110
Another thing that
I want to mention

00:21:16.110 --> 00:21:20.160
is, when you create tasks,
always create a custom type.

00:21:20.160 --> 00:21:25.290
It may seem easier to use
some of the API shortcut

00:21:25.290 --> 00:21:27.715
that Gradle has, like you
could do something like that.

00:21:27.715 --> 00:21:30.420
It's like, hey, I have a task
and I'm just configuring it

00:21:30.420 --> 00:21:32.880
and saying here do this thing.

00:21:32.880 --> 00:21:33.990
It looks OK, right?

00:21:33.990 --> 00:21:36.160
And there's some trick
between the groovy DSL

00:21:36.160 --> 00:21:38.153
and the [INAUDIBLE] DSL.

00:21:38.153 --> 00:21:40.320
And you might be thinking
that it's the right thing,

00:21:40.320 --> 00:21:43.267
but if you were to actually
use a default type from Gradle

00:21:43.267 --> 00:21:44.850
and then tried to
extend it, you would

00:21:44.850 --> 00:21:47.520
realize that
actually, you're doing

00:21:47.520 --> 00:21:50.143
expensive call, whatever it is,
directly in the configuration.

00:21:50.143 --> 00:21:51.810
So every time you
build, you're actually

00:21:51.810 --> 00:21:53.910
going to do what your
task is supposed to do,

00:21:53.910 --> 00:21:54.620
this is not good.

00:21:54.620 --> 00:21:55.290
All right?

00:21:55.290 --> 00:21:59.180
So the real shortcut would
now be Task doLast expensive.

00:21:59.180 --> 00:22:01.080
So it doesn't look
as well, anyway.

00:22:01.080 --> 00:22:03.720
And then doLast
cannot use workers,

00:22:03.720 --> 00:22:06.460
you can't really declare
inputs or outputs.

00:22:06.460 --> 00:22:09.660
And so the best practice is
always create your own type,

00:22:09.660 --> 00:22:12.870
declare input, declare
outputs, and use workers.

00:22:12.870 --> 00:22:15.780
If you don't do it, you're
basically not building

00:22:15.780 --> 00:22:19.070
as efficiently as you should.

00:22:19.070 --> 00:22:21.420
I'm not talking about doing
things during configuration

00:22:21.420 --> 00:22:24.120
that you shouldn't
do, really we see

00:22:24.120 --> 00:22:26.268
a lot of people trying to
do a lot of computation

00:22:26.268 --> 00:22:28.560
and it's really not something
that you should be doing.

00:22:28.560 --> 00:22:29.970
Now, I realize
that we don't have

00:22:29.970 --> 00:22:31.920
awesome APIs to let you
do some of the things

00:22:31.920 --> 00:22:33.040
that you want to do.

00:22:33.040 --> 00:22:34.540
But I'm going to
run you through two

00:22:34.540 --> 00:22:37.590
examples that kind of
explain some work arounds

00:22:37.590 --> 00:22:39.520
to do a better job.

00:22:39.520 --> 00:22:41.880
So the first one that is,
by far, the one that we

00:22:41.880 --> 00:22:43.980
see the most people
do is putting

00:22:43.980 --> 00:22:47.880
get information into their
versionCode or versionName.

00:22:47.880 --> 00:22:49.590
So we see something like that.

00:22:49.590 --> 00:22:54.540
VersionCode= and then calling
to get the [INAUDIBLE]

00:22:54.540 --> 00:22:55.960
or whatever.

00:22:55.960 --> 00:22:57.480
And it's just not
efficient at all.

00:22:57.480 --> 00:23:00.063
Again, you're going to do that
every time you sync, every time

00:23:00.063 --> 00:23:03.330
you call Gradle just to
do, hey, what's this task

00:23:03.330 --> 00:23:06.310
or what's my dependency,
it is just not efficient.

00:23:06.310 --> 00:23:08.880
So as I said, we don't really
have a better way to do it,

00:23:08.880 --> 00:23:10.900
or a nice way, but there's
some ways to do it.

00:23:10.900 --> 00:23:14.400
So the answer should always
be I need to do it in a task.

00:23:14.400 --> 00:23:16.790
So here, because
it's not very easy,

00:23:16.790 --> 00:23:20.438
the way that I found is, while
the versionCode is injected

00:23:20.438 --> 00:23:22.980
into manifest merger, so if at
the end of the manifest merger

00:23:22.980 --> 00:23:26.050
I go and I inject the
version, it should work.

00:23:26.050 --> 00:23:27.860
So the solution
looks like this, I'm

00:23:27.860 --> 00:23:29.065
going to run you through it.

00:23:29.065 --> 00:23:30.440
So the first thing
is that you're

00:23:30.440 --> 00:23:36.220
going to have to
read the versionCode,

00:23:36.220 --> 00:23:41.890
and you're going to have
to read the manifest file.

00:23:41.890 --> 00:23:43.420
And so since I'm
a little bit lazy

00:23:43.420 --> 00:23:45.250
and I don't want to
use a full XML library

00:23:45.250 --> 00:23:47.500
and find the attributes, I'm
just going to do a search

00:23:47.500 --> 00:23:48.520
and replace.

00:23:48.520 --> 00:23:51.280
So I said versionCode
to a lot of nines.

00:23:51.280 --> 00:23:52.810
Hopefully, it's
not a string that

00:23:52.810 --> 00:23:55.880
is present multiple
times in my file.

00:23:55.880 --> 00:23:58.370
The next thing is, I need to
loop over all of my variants,

00:23:58.370 --> 00:23:58.870
right?

00:23:58.870 --> 00:24:01.090
You always have to do
it, if you did tasks,

00:24:01.090 --> 00:24:03.980
you have multiple variants,
you have to deal with them.

00:24:03.980 --> 00:24:07.480
And then also, the manifest
merger is part of the output,

00:24:07.480 --> 00:24:10.230
because of multi APK if you use
splits and things like that,

00:24:10.230 --> 00:24:12.830
here I don't have any, so I'm
just going to loop on them.

00:24:12.830 --> 00:24:14.440
But I knew I would
only have one.

00:24:14.440 --> 00:24:18.080
And then I use, I'm sorry, I
use manifest merger provider.

00:24:18.080 --> 00:24:21.208
Remember earlier I said don't
use the known provider version?

00:24:21.208 --> 00:24:23.500
So here, I get ManifestProvider
return a task provider,

00:24:23.500 --> 00:24:25.270
and I can call
configure, which just

00:24:25.270 --> 00:24:28.000
register a lambda
to run whenever

00:24:28.000 --> 00:24:29.270
the task is configured later.

00:24:29.270 --> 00:24:30.850
So it's lazy.

00:24:30.850 --> 00:24:34.540
So inside, I added doLast,
I said earlier workers,

00:24:34.540 --> 00:24:37.670
but that's the only
solution I have right now.

00:24:37.670 --> 00:24:39.010
And then inside, it's very easy.

00:24:39.010 --> 00:24:40.843
The first thing I do
is I read the manifest.

00:24:40.843 --> 00:24:42.850
So here the manifest
merger actually

00:24:42.850 --> 00:24:44.740
has a property
which is a directory

00:24:44.740 --> 00:24:48.430
property,
manifestOutputDirectory.get

00:24:48.430 --> 00:24:50.045
and then asFile.

00:24:50.045 --> 00:24:52.420
And then I just read the file,
I do a search and replace,

00:24:52.420 --> 00:24:53.810
and I write it back.

00:24:53.810 --> 00:24:56.270
And if you do that,
it will actually work.

00:24:56.270 --> 00:24:59.740
Now, there are some things that
you need to tweak a little bit.

00:24:59.740 --> 00:25:02.390
Like if you do a get
comment touching,

00:25:02.390 --> 00:25:05.230
let's say a read me file, your
get will want to exchange,

00:25:05.230 --> 00:25:07.270
your [INAUDIBLE] want
to change, but your code

00:25:07.270 --> 00:25:10.630
hasn't, so you need to
technically recompile.

00:25:10.630 --> 00:25:12.590
Caching also is important
to use the inputs.

00:25:12.590 --> 00:25:14.630
So you need to do a
little bit more work.

00:25:14.630 --> 00:25:18.440
And so on tasks, you
can create new inputs.

00:25:18.440 --> 00:25:20.140
So here I declare a new input.

00:25:20.140 --> 00:25:22.943
The name has to be unique,
I put something random here,

00:25:22.943 --> 00:25:24.110
and then you pass the value.

00:25:24.110 --> 00:25:26.610
And again, it has to be lazy,
so don't put the actual value.

00:25:26.610 --> 00:25:29.920
Put a callable that will do the
value so that Gradle can call

00:25:29.920 --> 00:25:32.988
that whenever you need that.

00:25:32.988 --> 00:25:34.780
The last thing here,
is that while I end up

00:25:34.780 --> 00:25:39.130
coding compute value twice,
inside and during input

00:25:39.130 --> 00:25:39.640
validation.

00:25:39.640 --> 00:25:42.400
So you technically should
extract that into callable,

00:25:42.400 --> 00:25:43.578
memorize it somehow.

00:25:43.578 --> 00:25:45.370
And in fact, I should
probably put that one

00:25:45.370 --> 00:25:50.590
above my application
loop, because I

00:25:50.590 --> 00:25:53.380
don't want to do that for
both debug and release.

00:25:53.380 --> 00:25:55.480
Some caveats here.

00:25:55.480 --> 00:25:57.520
The model is not up
to date, so if you

00:25:57.520 --> 00:25:59.320
have another plugin
that use versionCode,

00:25:59.320 --> 00:26:02.020
it's not going to get the value.

00:26:02.020 --> 00:26:04.720
Here I use a value as
an input, generally

00:26:04.720 --> 00:26:06.908
you want to use a file,
but the input here

00:26:06.908 --> 00:26:08.950
should be the get index,
which can be really big.

00:26:08.950 --> 00:26:11.080
So do I want to do a
check sum of all of it?

00:26:11.080 --> 00:26:13.340
Maybe using get, I can
get the value faster.

00:26:13.340 --> 00:26:15.420
So up to you, figure it out.

00:26:15.420 --> 00:26:18.100
And then doLast,
don't use Worker.

00:26:18.100 --> 00:26:21.730
In fact, they don't use Worker
and they don't work very well

00:26:21.730 --> 00:26:22.450
with Worker.

00:26:22.450 --> 00:26:24.640
So if you have your task
here, and you add a Worker

00:26:24.640 --> 00:26:29.890
at the end, if the task uses
a Worker, the doLast doesn't.

00:26:29.890 --> 00:26:32.380
That means that if another
task run at the same time,

00:26:32.380 --> 00:26:35.300
it can move doLast actually
and scale a little bit later.

00:26:35.300 --> 00:26:38.530
So if you look at
Gradle scans, the time

00:26:38.530 --> 00:26:42.520
of the action of the task
might be bigger than it seems,

00:26:42.520 --> 00:26:45.100
but it is because of that
white space in the middle.

00:26:45.100 --> 00:26:47.518
Something to think about.

00:26:47.518 --> 00:26:49.060
OK, so we have
another example, which

00:26:49.060 --> 00:26:51.910
is we see people passing
data via BuildConfig.

00:26:51.910 --> 00:26:54.920
For example, they compute a
value and they put it there.

00:26:54.920 --> 00:26:57.520
So here it's harder
to hook into the end

00:26:57.520 --> 00:26:59.300
and actually add to the class.

00:26:59.300 --> 00:27:00.935
So you can generate
your own class.

00:27:00.935 --> 00:27:02.560
So in order to do
that, it's very easy.

00:27:02.560 --> 00:27:05.830
You create a task, so
some inputs, package name,

00:27:05.830 --> 00:27:09.310
class name, location,
and then the value.

00:27:09.310 --> 00:27:11.540
And then the generation
is relatively easy.

00:27:11.540 --> 00:27:14.300
I'm just generating your
following Java class.

00:27:14.300 --> 00:27:17.350
So it's nothing to talk about.

00:27:17.350 --> 00:27:20.140
The part that we want to
look at is how I register it.

00:27:20.140 --> 00:27:22.000
So again, I loop
on the variants,

00:27:22.000 --> 00:27:25.300
I create my task with a unique
name using the variant name,

00:27:25.300 --> 00:27:26.830
and then I set the value here.

00:27:26.830 --> 00:27:28.540
Again, using something lazy.

00:27:28.540 --> 00:27:32.200
So project.provider
received a callable

00:27:32.200 --> 00:27:35.213
and returned a provider object,
basically, so that it's lazy

00:27:35.213 --> 00:27:36.880
and it's going to
work out of the books.

00:27:36.880 --> 00:27:40.160
The last thing you
need to do is you

00:27:40.160 --> 00:27:43.210
need to tell us that, hey, I
am generating some Java code

00:27:43.210 --> 00:27:46.630
please go and compile
it or pass it to studio

00:27:46.630 --> 00:27:49.510
so that I don't have
unresolved symbols.

00:27:49.510 --> 00:27:52.290
And settle your API to do
that, receive task and not

00:27:52.290 --> 00:27:53.120
task provider.

00:27:53.120 --> 00:27:56.785
So we need to update that to
make that lazy task compatible.

00:27:56.785 --> 00:27:59.410
So you would have to actually go
and call on your task provider

00:27:59.410 --> 00:28:02.100
to get, which we configure it
right away, which is not great,

00:28:02.100 --> 00:28:03.850
but it's better than
doing the computation

00:28:03.850 --> 00:28:09.030
during the configuration.

00:28:09.030 --> 00:28:09.918
All right.

00:28:09.918 --> 00:28:12.460
AURIMAS LIUTIKAS: And I'm gonna
walk you through a little bit

00:28:12.460 --> 00:28:14.320
through the guide
to investigations.

00:28:14.320 --> 00:28:16.660
So how do you want to go
about profiling, measuring,

00:28:16.660 --> 00:28:18.700
and optimizing your builds.

00:28:18.700 --> 00:28:20.560
So Build Scans is
a really great tool

00:28:20.560 --> 00:28:24.477
that is provided by Gradle,
the company behind Gradle.

00:28:24.477 --> 00:28:25.560
It's really simple to use.

00:28:25.560 --> 00:28:27.185
You run the same
tasks you normally do,

00:28:27.185 --> 00:28:30.220
you just simply add
--scan at the end.

00:28:30.220 --> 00:28:32.170
And it will prompt you
to accept a license,

00:28:32.170 --> 00:28:35.190
and then it will upload
your results for analysis.

00:28:35.190 --> 00:28:36.650
The important
caveat to note here,

00:28:36.650 --> 00:28:39.310
this does send the
data to Gradle servers,

00:28:39.310 --> 00:28:41.120
so you should be
comfortable doing that.

00:28:41.120 --> 00:28:43.940
They do give you an option
to delete all the results

00:28:43.940 --> 00:28:46.880
after you're done your
analysis, but you should just

00:28:46.880 --> 00:28:48.560
be aware of that when
you're doing this.

00:28:48.560 --> 00:28:50.820
Also, the reason why this
tool is really helpful,

00:28:50.820 --> 00:28:52.910
it helps you find
those non-lazy tasks

00:28:52.910 --> 00:28:54.720
that Xav was talking about.

00:28:54.720 --> 00:28:57.740
And as well, you can find where
your dependencies that get

00:28:57.740 --> 00:28:59.630
resolved during the
configuration time, which

00:28:59.630 --> 00:29:02.400
is another big no no.

00:29:02.400 --> 00:29:04.040
So in yesterday's,
talk if you saw,

00:29:04.040 --> 00:29:08.060
Xav was talking about the
100 module baseline build.

00:29:08.060 --> 00:29:10.640
And then this is how it
compares to AndroidX.

00:29:10.640 --> 00:29:14.600
So this is a real project
that has 240 modules

00:29:14.600 --> 00:29:19.080
and is able to configure it in
24 milliseconds for a project.

00:29:19.080 --> 00:29:23.630
So if you're seeing your
builds of 40, 50 modules taking

00:29:23.630 --> 00:29:26.090
10 seconds, 20 seconds,
there's definitely

00:29:26.090 --> 00:29:28.050
ways to improve
and make it better.

00:29:28.050 --> 00:29:30.530
So all I'm saying
is, get inspired.

00:29:30.530 --> 00:29:33.460
So this is only 6 milliseconds
worse than a baseline project.

00:29:33.460 --> 00:29:35.960
And one thing to note here,
that you can see in these lines,

00:29:35.960 --> 00:29:37.918
that we're not even doing
them in any lazy task

00:29:37.918 --> 00:29:38.900
configurations.

00:29:38.900 --> 00:29:41.483
That just means that we haven't
done the work to actually make

00:29:41.483 --> 00:29:43.770
it as fast as it can be.

00:29:43.770 --> 00:29:46.640
So in AndroidX, we actually
use Build Scans in another way.

00:29:46.640 --> 00:29:50.330
We used it to investigate
the effects of JVM max memory

00:29:50.330 --> 00:29:51.320
limits.

00:29:51.320 --> 00:29:55.860
We wanted to see how does
that affect our project.

00:29:55.860 --> 00:29:57.290
And for our project,
it turned out

00:29:57.290 --> 00:30:00.170
to be the biggest bang
for the buck potentially.

00:30:00.170 --> 00:30:05.570
New studio projects start 1.5
gig limit for your Gradle JVM,

00:30:05.570 --> 00:30:07.658
and that might not be
enough for your project.

00:30:07.658 --> 00:30:09.200
So what you want to
do, is you really

00:30:09.200 --> 00:30:11.990
want to run an experiment where
you try the different values

00:30:11.990 --> 00:30:13.940
and see how that comes out.

00:30:13.940 --> 00:30:16.700
In terms of to get the
optimal value of speed

00:30:16.700 --> 00:30:17.972
versus memory usage.

00:30:17.972 --> 00:30:19.430
The things you want
to do, you want

00:30:19.430 --> 00:30:22.250
to run the --rerun
tasks that forces

00:30:22.250 --> 00:30:23.900
you to run all the tasks.

00:30:23.900 --> 00:30:26.360
Otherwise, you might be skipping
some tasks due to caching

00:30:26.360 --> 00:30:27.193
and stuff like that.

00:30:27.193 --> 00:30:29.105
And that will give
you incorrect results.

00:30:29.105 --> 00:30:30.980
You want to kill daemons
in between the runs,

00:30:30.980 --> 00:30:34.220
because if you don't,
the Gradle daemon will

00:30:34.220 --> 00:30:36.410
stick around and cause
you memory pressure,

00:30:36.410 --> 00:30:39.385
also leading to
incorrect results.

00:30:39.385 --> 00:30:40.760
Another thing to
run, is you want

00:30:40.760 --> 00:30:42.810
to run tasks that are
common to your developers.

00:30:42.810 --> 00:30:45.180
So if your developer does
assemble debug all the time,

00:30:45.180 --> 00:30:47.070
that's the path you
should optimize for.

00:30:47.070 --> 00:30:49.070
And then finally, and
probably more importantly,

00:30:49.070 --> 00:30:51.480
is you want to run it on a
typical developer machine.

00:30:51.480 --> 00:30:53.190
If you're going to test
it out on a beefy machine,

00:30:53.190 --> 00:30:55.250
and then developers are going
to run it on a different one,

00:30:55.250 --> 00:30:57.125
you're not going to have
the same performance

00:30:57.125 --> 00:30:58.460
characteristics.

00:30:58.460 --> 00:31:01.113
So as you play around
with JVM memory limit,

00:31:01.113 --> 00:31:02.780
you just want to use
build scans and see

00:31:02.780 --> 00:31:06.290
how the execution time and
garbage collection times,

00:31:06.290 --> 00:31:07.580
what the ratio is.

00:31:07.580 --> 00:31:09.620
So here in AndroidX,
we did a scan

00:31:09.620 --> 00:31:12.350
and it takes five minutes
to GC, and a total

00:31:12.350 --> 00:31:13.360
build of nine minutes.

00:31:13.360 --> 00:31:16.400
That means we're only doing like
four minutes of valuable work

00:31:16.400 --> 00:31:18.620
and the rest of it is
just garbage collecting.

00:31:18.620 --> 00:31:19.460
And that's bad.

00:31:19.460 --> 00:31:21.080
That's the state we
were in before we

00:31:21.080 --> 00:31:23.300
started investigating.

00:31:23.300 --> 00:31:26.750
There's obviously hard limits
of how small the memory can be.

00:31:26.750 --> 00:31:29.900
If you try to build AndroidX
or one gig of memory allowed,

00:31:29.900 --> 00:31:32.090
after 14 minutes of
struggling, it will just

00:31:32.090 --> 00:31:34.620
throw out a memory exception.

00:31:34.620 --> 00:31:36.920
So as we did the test, you
can see in the graph, one

00:31:36.920 --> 00:31:40.040
and two gigs were simply just
not a thing that you can do.

00:31:40.040 --> 00:31:41.720
And at four gigs,
we're wasting a lot

00:31:41.720 --> 00:31:43.280
of time garbage collecting.

00:31:43.280 --> 00:31:45.590
We ended up picking
number 8 gigabytes for us,

00:31:45.590 --> 00:31:48.470
because that was the best in
terms of the developer machines

00:31:48.470 --> 00:31:51.470
that we had available and the
speed we were able to achieve.

00:31:51.470 --> 00:31:53.360
As you can see, there's
diminishing returns

00:31:53.360 --> 00:31:55.040
as you give Gradle
more memory, there

00:31:55.040 --> 00:31:58.010
will be less garbage collection,
but you should really

00:31:58.010 --> 00:31:59.300
pick a value.

00:31:59.300 --> 00:32:01.430
And note, don't just
take 8 gigabytes

00:32:01.430 --> 00:32:03.680
and set it in your project,
this is for our project.

00:32:03.680 --> 00:32:07.730
You should do your own
experiment and run it yourself.

00:32:07.730 --> 00:32:10.800
Another lever you have to
pull is Gradle workers.

00:32:10.800 --> 00:32:12.300
So Gradle, by
default, gives you the

00:32:12.300 --> 00:32:14.910
a number of workers as
you have processors.

00:32:14.910 --> 00:32:17.510
And that might be too many
for you, because what happens

00:32:17.510 --> 00:32:19.970
is the more workers you
spin up, the more memories

00:32:19.970 --> 00:32:21.600
are being used at the same time.

00:32:21.600 --> 00:32:22.700
And if you don't
have enough memory,

00:32:22.700 --> 00:32:24.908
you force your computer to
go into garbage collection

00:32:24.908 --> 00:32:25.650
all the time.

00:32:25.650 --> 00:32:28.333
So potentially, limiting
the number of workers,

00:32:28.333 --> 00:32:29.750
I know it sounds
counterintuitive,

00:32:29.750 --> 00:32:31.580
but it might make
your builds faster.

00:32:31.580 --> 00:32:33.580
And you essentially want
to run the same process

00:32:33.580 --> 00:32:38.950
of experimentation that
we did for max memory.

00:32:38.950 --> 00:32:41.780
And finally, one thing you
want to notice for your CI,

00:32:41.780 --> 00:32:43.790
you probably should be
picking different values

00:32:43.790 --> 00:32:46.910
for the maximum JVM limits,
as well for max workers.

00:32:46.910 --> 00:32:49.910
And the reasons are, your CI
probably runs way more tasks

00:32:49.910 --> 00:32:52.140
and different tasks than
what your build machines do.

00:32:52.140 --> 00:32:54.390
And then also, you probably
have more beefier machines

00:32:54.390 --> 00:32:56.247
with more CPU and more RAM.

00:32:56.247 --> 00:32:58.580
And Xav is going to walk you
through how to use a tracer

00:32:58.580 --> 00:33:02.140
agent to do more debugging.

00:33:02.140 --> 00:33:04.350
XAVIER DUCROHET:
OK, so yesterday I

00:33:04.350 --> 00:33:08.513
mentioned that you should really
profile your configuration.

00:33:08.513 --> 00:33:10.180
Especially if you
apply a lot of plugin,

00:33:10.180 --> 00:33:11.700
or if you have your own plugin.

00:33:11.700 --> 00:33:15.250
So, of course, you can
use any Java provider,

00:33:15.250 --> 00:33:18.180
but we found that
there was probably

00:33:18.180 --> 00:33:21.360
a better way, a more user
friendly way to profile that.

00:33:21.360 --> 00:33:25.470
So we created this little tool
called Tracer Agent that you

00:33:25.470 --> 00:33:27.510
can go and download
from a repository,

00:33:27.510 --> 00:33:29.937
you can build it, look at
the readme, see everything.

00:33:29.937 --> 00:33:31.770
But, basically, it works
two different ways.

00:33:31.770 --> 00:33:37.380
One way is you can create some
custom events using the API,

00:33:37.380 --> 00:33:41.670
or you can just
attach it to your JVM.

00:33:41.670 --> 00:33:44.280
It's going to run inside
it, and you provide it

00:33:44.280 --> 00:33:46.920
with a list of
things to instrument.

00:33:46.920 --> 00:33:50.820
And then at the end, it's going
to output a JSON file that you

00:33:50.820 --> 00:33:52.500
can just load into
Chrome tracing tool

00:33:52.500 --> 00:33:54.330
and see everything that happens.

00:33:54.330 --> 00:33:56.790
So I did that with
the little plugin

00:33:56.790 --> 00:34:00.050
that I made for this demo about
the manifest merger, doLast,

00:34:00.050 --> 00:34:02.460
and the little generate code
for buildConfig and things

00:34:02.460 --> 00:34:04.120
like that.

00:34:04.120 --> 00:34:06.270
So what I did here
is I set it up

00:34:06.270 --> 00:34:08.820
to instrument everything
in my custom package.

00:34:08.820 --> 00:34:10.469
And then I added
a couple of lines

00:34:10.469 --> 00:34:13.739
to instrument a few
methods from Gradle

00:34:13.739 --> 00:34:17.280
to see some lifecycle between
configuration and execution

00:34:17.280 --> 00:34:20.010
and a few of our
own methods in order

00:34:20.010 --> 00:34:21.840
to also instrument
and see what's

00:34:21.840 --> 00:34:24.239
happening in the Gradle plugin.

00:34:24.239 --> 00:34:27.510
So you load that into Chrome,
and then you see all the colors

00:34:27.510 --> 00:34:29.250
and you're wondering
what's happening.

00:34:29.250 --> 00:34:32.130
So if we dig into the
configuration phase,

00:34:32.130 --> 00:34:34.409
you see the large
green banner at the top

00:34:34.409 --> 00:34:36.989
is the whole
configuration phase.

00:34:36.989 --> 00:34:38.580
And then you can
zoom in and you can

00:34:38.580 --> 00:34:40.560
see that this tiny
little line here

00:34:40.560 --> 00:34:43.469
is the apply plugin
of my own plugin.

00:34:43.469 --> 00:34:45.957
So I do very little here, great.

00:34:45.957 --> 00:34:48.040
But then you can see that
you have these two lines

00:34:48.040 --> 00:34:50.540
and if you look at the name,
it says customplugin.something,

00:34:50.540 --> 00:34:51.750
that's my code too.

00:34:51.750 --> 00:34:55.409
In fact, it's whenever you do
Android.applicationvariant.all,

00:34:55.409 --> 00:34:57.643
you're just registering
callback to happen later,

00:34:57.643 --> 00:35:00.060
whenever the Gradle plugin
creates those variants and then

00:35:00.060 --> 00:35:01.240
call you back.

00:35:01.240 --> 00:35:03.530
So it doesn't show up
in my apply plugin,

00:35:03.530 --> 00:35:04.712
it shows up somewhere else.

00:35:04.712 --> 00:35:07.170
That's why this tool is great,
because I say, show me where

00:35:07.170 --> 00:35:09.365
that method is taking time.

00:35:09.365 --> 00:35:11.490
Wherever it is, I don't
have to go and backtrack it

00:35:11.490 --> 00:35:13.270
where it's coming from.

00:35:13.270 --> 00:35:15.570
So here, it's called
twice and it's

00:35:15.570 --> 00:35:21.250
the method called create
generate code tasks.

00:35:21.250 --> 00:35:23.910
So that's my second example
that I showed about.

00:35:23.910 --> 00:35:26.430
And it's taking a
large amount of time

00:35:26.430 --> 00:35:30.360
compared to the whole pink line,
which is create another task,

00:35:30.360 --> 00:35:31.620
and it's just for one task.

00:35:31.620 --> 00:35:35.850
So what happens here is I let a
thread slip 100 milliseconds so

00:35:35.850 --> 00:35:38.400
that it shows up there, but
basically you can go and really

00:35:38.400 --> 00:35:41.190
look to see where your code is.

00:35:41.190 --> 00:35:43.380
Another example, this is
during execution phase,

00:35:43.380 --> 00:35:44.960
and again, you don't
really see anything else.

00:35:44.960 --> 00:35:46.920
Not really should be
like a waterfall chart,

00:35:46.920 --> 00:35:49.260
but here it only shows
you basically the end.

00:35:49.260 --> 00:35:51.880
And it's my compute
version code.

00:35:51.880 --> 00:35:54.640
So I can see that it's
called three times.

00:35:54.640 --> 00:35:58.027
So it turns out that the
first two actually Gradle

00:35:58.027 --> 00:36:00.610
are doing up to date checks and
calling the method to be like,

00:36:00.610 --> 00:36:02.943
hey, what's the current version
compared to the old one.

00:36:02.943 --> 00:36:05.080
And then the third
one is the execution.

00:36:05.080 --> 00:36:08.220
And so I mentioned
earlier during my slide,

00:36:08.220 --> 00:36:09.930
that you need to memorize it.

00:36:09.930 --> 00:36:11.790
And here, obviously,
I did not do it,

00:36:11.790 --> 00:36:13.560
and therefore I see
it run three times.

00:36:13.560 --> 00:36:14.748
And so that's very useful.

00:36:14.748 --> 00:36:16.790
So the good thing here,
is that you can basically

00:36:16.790 --> 00:36:17.940
instrument any plug in.

00:36:17.940 --> 00:36:20.580
If you apply a bunch of
plugin, go look at the source,

00:36:20.580 --> 00:36:22.650
just open the JAR, see
what the package name is,

00:36:22.650 --> 00:36:24.200
just add the package
name, it's going

00:36:24.200 --> 00:36:26.070
to instrument all the plugin.

00:36:26.070 --> 00:36:28.080
And then you can just
run a regular build,

00:36:28.080 --> 00:36:30.060
look at just a JSON
file, see where

00:36:30.060 --> 00:36:32.100
you're spending a lot
of time, and figure out

00:36:32.100 --> 00:36:34.920
where your configuration
is way above the baseline

00:36:34.920 --> 00:36:38.210
that Aurimas and I showed you.

00:36:38.210 --> 00:36:43.110
I've talked to people telling
me I have a few dozen modules

00:36:43.110 --> 00:36:45.720
and I have 30 plus
second configuration,

00:36:45.720 --> 00:36:47.470
and this is not normal.

00:36:47.470 --> 00:36:49.330
You should be way
faster than that.

00:36:49.330 --> 00:36:52.470
So I highly recommend that you
use this tool or any other Java

00:36:52.470 --> 00:36:54.240
profiler to really
figure out why

00:36:54.240 --> 00:36:57.140
you're spending so much time.

00:36:57.140 --> 00:36:59.080
And with that, thank you.

00:36:59.080 --> 00:37:01.860
We will be at the Sandbox
if you have questions,

00:37:01.860 --> 00:37:04.620
and thank you for coming.

00:37:04.620 --> 00:37:07.070
[MUSIC PLAYING]

