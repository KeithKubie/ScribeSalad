WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.000
Test coverage let’s us assign a score to a collection of test cases

00:00:03.000 --> 00:00:05.000
and so let's be a little bit more rigorous about it.

00:00:05.000 --> 00:00:09.000
So test coverage is really is a measure of the proportion of a program exercised during testing.

00:00:09.000 --> 00:00:12.000
So, for example, we’ve just talked about measuring a number of functions 

00:00:12.000 --> 00:00:15.000
out of the total number of functions or exercise by some test that we had.

00:00:15.000 --> 00:00:18.000
What’s good about test coverage is it gives us a score,

00:00:18.000 --> 00:00:21.000
gives us something objective that we can use to try figure out how well we’re doing.

00:00:21.000 --> 00:00:26.000
Additionally, when coverage is less than 100%, that is to say, as in our example, 

00:00:26.000 --> 00:00:29.000
where we had failed to execute all of the functions in the software under test,

00:00:29.000 --> 00:00:31.000
we know what we need to do to get full coverage.

00:00:31.000 --> 00:00:34.000
We know what the functions are that we need to execute.

00:00:34.000 --> 00:00:37.000
Now, we simply need to construct test cases and execute those functions. 

00:00:37.000 --> 00:00:39.000
So, these are the good things about test coverage. 

00:00:39.000 --> 00:00:41.000
On the other hand, there are also some disadvantages.

00:00:41.000 --> 00:00:45.000
First of all, test coverage, because it is a white box metric that is derived

00:00:45.000 --> 00:00:49.000
from the source code for our system is not good at helping us find bugs of omission,

00:00:49.000 --> 00:00:52.000
that is to say bugs were simply left out something that we should have implemented.

00:00:52.000 --> 00:00:58.000
The second drawback is it could be really hard to know what a test coverage score less 100% means 

00:00:58.000 --> 00:01:03.000
and in safety critical software development would sometimes done is requiring 100% test coverage 

00:01:03.000 --> 00:01:06.000
of a certain coverage metrics and that sort of removes this problem, 

00:01:06.000 --> 00:01:10.000
it means that we don’t have to interpret scores less than 100% because we’re not allowed

00:01:10.000 --> 00:01:13.000
to ship our product until we get 100% test coverage. 

00:01:13.000 --> 00:01:16.000
For a larger, more complex software systems where the standards are correct

00:01:16.000 --> 00:01:19.000
and not as high as they are for safety critical systems, that’s often the case,

00:01:19.000 --> 00:01:22.000
but it’s difficult or impossible to achieve 100% test coverage.

00:01:22.000 --> 00:01:27.000
Leaving us with this problem we’re trying to figure out what that actually means about the software.

00:01:27.000 --> 00:01:31.000
The third disadvantage is even 100% coverage doesn’t mean that all bugs are found

00:01:31.000 --> 00:01:35.000
and you could see that sort of easily by thinking about the example why we’re measuring 

00:01:35.000 --> 00:01:38.000
our coverage by looking at the number of functions we executed. 

00:01:38.000 --> 00:01:40.000
Just we executed some function, of course, 

00:01:40.000 --> 00:01:42.000
it doesn’t mean that we found all the bugs in that function.

00:01:42.000 --> 00:01:45.000
We may not have executed very much of it or may not have somehow

00:01:45.000 --> 00:01:48.000
found very many of the interesting behaviors inside that function.

