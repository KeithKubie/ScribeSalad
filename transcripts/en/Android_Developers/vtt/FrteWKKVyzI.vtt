WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:05.189
[MUSIC PLAYING]

00:00:05.189 --> 00:00:05.980
MIKE CLERON: So hi.

00:00:05.980 --> 00:00:07.080
I'm Mike Cleron.

00:00:07.080 --> 00:00:08.650
I'm on the Android team.

00:00:08.650 --> 00:00:14.120
I manage the system UI framework
and UI toolkit teams there.

00:00:14.120 --> 00:00:17.650
We're going to be talking
today in a lot of detail

00:00:17.650 --> 00:00:21.790
about some big changes to
how we recommend that you

00:00:21.790 --> 00:00:23.710
build Android applications.

00:00:23.710 --> 00:00:26.110
But before we go into
a lot of the details,

00:00:26.110 --> 00:00:28.510
I thought would be helpful
to step back a bit,

00:00:28.510 --> 00:00:31.960
and frame the discussion by
talking about where we came

00:00:31.960 --> 00:00:34.730
from, and where we're going.

00:00:34.730 --> 00:00:36.100
So let's do that.

00:00:36.100 --> 00:00:39.010
So to start, Android
has always been based

00:00:39.010 --> 00:00:41.230
on some strong principles.

00:00:41.230 --> 00:00:43.330
Not surprisingly, those
were best expressed

00:00:43.330 --> 00:00:44.860
by Dianne Hackborn.

00:00:44.860 --> 00:00:46.600
She's the one who
actually architected

00:00:46.600 --> 00:00:48.880
most of the Android framework.

00:00:48.880 --> 00:00:51.160
She wrote a post about
this a few months back,

00:00:51.160 --> 00:00:54.310
and I have some
excerpts from that here.

00:00:54.310 --> 00:00:56.230
If you look at our
core primitives--

00:00:56.230 --> 00:01:00.100
activity, broadcast receiver,
service content provider,

00:01:00.100 --> 00:01:03.880
you might reasonably think that
those constitute an application

00:01:03.880 --> 00:01:05.012
framework.

00:01:05.012 --> 00:01:06.970
But that's not the right
way to think about it.

00:01:06.970 --> 00:01:10.120
These classes are
actually contracts

00:01:10.120 --> 00:01:14.910
between the application
and the operating system.

00:01:14.910 --> 00:01:16.950
They represent the minimal
amount of information

00:01:16.950 --> 00:01:20.790
necessary so that the OS knows
what's going on inside your app

00:01:20.790 --> 00:01:23.220
so we can manage it properly.

00:01:23.220 --> 00:01:27.060
So as an example, if your app
is running in the background,

00:01:27.060 --> 00:01:29.600
but is also exposing data
to another application

00:01:29.600 --> 00:01:32.492
through a content provider,
the OS needs to know that.

00:01:32.492 --> 00:01:34.950
And we need to know that so we
don't accidentally kill you.

00:01:34.950 --> 00:01:37.500
The content provider is a
mechanism that tells us that

00:01:37.500 --> 00:01:39.990
so that we can keep you alive.

00:01:39.990 --> 00:01:41.970
So we think of
these core classes

00:01:41.970 --> 00:01:44.790
as really being like the
fundamental laws of physics

00:01:44.790 --> 00:01:47.520
for Android, hence
the illustration.

00:01:47.520 --> 00:01:49.920
That is the cover
of the manuscript

00:01:49.920 --> 00:01:52.170
where Isaac Newton
first presented

00:01:52.170 --> 00:01:53.430
the basic laws of motion.

00:01:56.620 --> 00:01:59.580
Now, fundamental laws
are a good thing.

00:01:59.580 --> 00:02:01.560
I use a shorthand when
talking about this.

00:02:01.560 --> 00:02:04.530
I say, Android has good bones,
even though people look at me

00:02:04.530 --> 00:02:06.780
funny after I say that.

00:02:06.780 --> 00:02:09.960
But what I mean by
that is that Android

00:02:09.960 --> 00:02:13.650
is based on a small,
stable, cohesive set

00:02:13.650 --> 00:02:15.150
of core primitives.

00:02:15.150 --> 00:02:18.390
And that allows a
common programming model

00:02:18.390 --> 00:02:20.940
across a really
incredibly diverse range

00:02:20.940 --> 00:02:24.750
of devices from wearables
to phones to tablets

00:02:24.750 --> 00:02:27.870
to TVs to cars, and more.

00:02:27.870 --> 00:02:30.210
This model also gives
application developers

00:02:30.210 --> 00:02:32.310
the freedom to choose
whatever framework

00:02:32.310 --> 00:02:34.170
they want inside
their application

00:02:34.170 --> 00:02:36.010
for their internal framework.

00:02:36.010 --> 00:02:38.070
So that means that we
on the Android team

00:02:38.070 --> 00:02:41.250
don't have to get involved
in debates about whether MVC

00:02:41.250 --> 00:02:45.540
is better than MVP, or whether
MVP is better than [? MVVBM. ?]

00:02:45.540 --> 00:02:49.260
You guys can pick whatever
makes sense to you.

00:02:49.260 --> 00:02:52.680
Now, that's a pretty good story
if you are in the operating

00:02:52.680 --> 00:02:55.921
system business like, say, me.

00:02:55.921 --> 00:02:57.420
But if you're in
the app development

00:02:57.420 --> 00:03:01.110
business like, say,
all of you, that's

00:03:01.110 --> 00:03:03.120
really only chapter
one of the story.

00:03:03.120 --> 00:03:04.890
And the reason for
that is because

00:03:04.890 --> 00:03:08.190
while strong fundamentals
and freedom of choice

00:03:08.190 --> 00:03:12.000
are good things, we know that
in your day to day jobs--

00:03:12.000 --> 00:03:16.730
and we know this because you
told us, you want more from us.

00:03:16.730 --> 00:03:19.690
So I'm going to abuse
my analogy a bit here.

00:03:19.690 --> 00:03:22.810
We can all appreciate the
simple elegance of Newton's laws

00:03:22.810 --> 00:03:27.725
of motion, but if your job
is to land a Rover on Mars,

00:03:27.725 --> 00:03:29.350
you don't want to
come to work each day

00:03:29.350 --> 00:03:31.810
and start with only F equals
ma, and derive everything

00:03:31.810 --> 00:03:35.230
from first principles.

00:03:35.230 --> 00:03:37.780
So we've been talking to
developers, both inside

00:03:37.780 --> 00:03:41.140
and outside of Google, and
taking a hard look at the app

00:03:41.140 --> 00:03:42.830
development experience.

00:03:42.830 --> 00:03:45.230
And we've realized
a couple of things.

00:03:45.230 --> 00:03:47.770
First, there are
peaks and valleys.

00:03:47.770 --> 00:03:51.550
Some aspects of app development
are better served by our APIs

00:03:51.550 --> 00:03:52.570
than others.

00:03:52.570 --> 00:03:56.470
For example, we think
RecyclerView is that the better

00:03:56.470 --> 00:03:57.830
end of that spectrum.

00:03:57.830 --> 00:04:02.020
So with RecyclerView, we didn't
say, hey, we give you events,

00:04:02.020 --> 00:04:03.810
and you can draw stuff.

00:04:03.810 --> 00:04:07.600
And in between you have a Turing
complete language, so good luck

00:04:07.600 --> 00:04:09.550
with everything else.

00:04:09.550 --> 00:04:12.640
On the other hand,
maybe Activity

00:04:12.640 --> 00:04:16.510
and Fragment Lifecycles belong
down in that dark shadowy place

00:04:16.510 --> 00:04:18.730
because there, I
think, too much of it

00:04:18.730 --> 00:04:21.790
is indeed left as an
exercise for the reader.

00:04:21.790 --> 00:04:24.730
And we want to fix that.

00:04:24.730 --> 00:04:27.250
So as we thought about this,
we realized the good solution

00:04:27.250 --> 00:04:29.930
has key properties.

00:04:29.930 --> 00:04:32.194
First, we have to solve
the right problems.

00:04:32.194 --> 00:04:33.860
This is going to be
a sustained effort--

00:04:33.860 --> 00:04:36.320
like sustained
for us on Android.

00:04:36.320 --> 00:04:38.410
But for the first cut,
we want to make sure

00:04:38.410 --> 00:04:39.910
that we are going
after the problems

00:04:39.910 --> 00:04:42.040
that every developer
faces, the things that

00:04:42.040 --> 00:04:45.040
are hard to do right right now.

00:04:45.040 --> 00:04:47.574
Again, app Lifecycles is
a really good example.

00:04:47.574 --> 00:04:49.240
If you don't get that
right in your app,

00:04:49.240 --> 00:04:51.236
nothing is going to
work on top of that.

00:04:51.236 --> 00:04:53.110
And that's true for your
app, but that's also

00:04:53.110 --> 00:04:55.026
true for the frameworks
we're trying to build.

00:04:55.026 --> 00:04:58.420
We have to get that right
before we can do anything else.

00:04:58.420 --> 00:05:00.370
Second, we have to
play well with others.

00:05:00.370 --> 00:05:02.830
We know that you all have huge
investments in your existing

00:05:02.830 --> 00:05:05.196
code bases, and we
can't create a model

00:05:05.196 --> 00:05:06.820
where the first thing
we say to you is,

00:05:06.820 --> 00:05:08.940
throw all that out
and start over.

00:05:08.940 --> 00:05:12.070
So we're trying to create APIs
that you can adopt a little bit

00:05:12.070 --> 00:05:15.580
at a time, and also
that interoperate well

00:05:15.580 --> 00:05:19.710
with other libraries
or other frameworks.

00:05:19.710 --> 00:05:22.054
Third, we want to
be more opinionated.

00:05:22.054 --> 00:05:23.970
We're going to take a
stronger, clearer stance

00:05:23.970 --> 00:05:26.000
on how to Android and
app the right way,

00:05:26.000 --> 00:05:27.100
at least as we see it.

00:05:27.100 --> 00:05:29.100
Now, this is all still optional.

00:05:29.100 --> 00:05:31.330
And if you already have
something that works for you,

00:05:31.330 --> 00:05:33.030
then great.

00:05:33.030 --> 00:05:36.210
But developers are telling us
that they want more guidance

00:05:36.210 --> 00:05:38.590
on how apps should be
built. And by the way,

00:05:38.590 --> 00:05:40.770
we're not changing any of
the laws of physics here,

00:05:40.770 --> 00:05:43.860
we're just layering some
higher level constructs on top.

00:05:43.860 --> 00:05:46.620
Because after all, F is
going to equal ma whether you

00:05:46.620 --> 00:05:49.860
believe it should or not.

00:05:49.860 --> 00:05:52.140
Next, it needs to scale.

00:05:52.140 --> 00:05:54.420
We want solutions that
are industrial strength,

00:05:54.420 --> 00:05:56.760
and that will scale to the
real world requirements

00:05:56.760 --> 00:05:58.474
of real world applications.

00:05:58.474 --> 00:06:01.140
We don't want to build something
that's awesome for Hello World,

00:06:01.140 --> 00:06:03.181
but then it's going to
collapse the first time it

00:06:03.181 --> 00:06:07.620
bumps into the messy
complexities of reality.

00:06:07.620 --> 00:06:09.410
And finally, reach.

00:06:09.410 --> 00:06:11.310
For this problem,
for making it easier

00:06:11.310 --> 00:06:13.830
for you to write Android
applications the right way--

00:06:13.830 --> 00:06:15.690
what we think is
the right way, we

00:06:15.690 --> 00:06:18.390
want to use libraries like
Support Lib wherever possible

00:06:18.390 --> 00:06:21.150
rather than adding new
APIs to the platform,

00:06:21.150 --> 00:06:24.030
because lets our solution
reach older versions of the OS

00:06:24.030 --> 00:06:26.745
as well.

00:06:26.745 --> 00:06:29.370
OK, so that's the background on
what we're trying to accomplish

00:06:29.370 --> 00:06:30.440
and why we're here.

00:06:30.440 --> 00:06:33.309
Now we'd like to introduce
Yigit, tool kit engineer

00:06:33.309 --> 00:06:35.600
extraordinaire, and he's
going to walk you through what

00:06:35.600 --> 00:06:36.860
we actually built. Thank you.

00:06:36.860 --> 00:06:37.290
[APPLAUSE]

00:06:37.290 --> 00:06:38.248
YIGIT BOYAR: All right.

00:06:38.248 --> 00:06:39.322
Thanks, Frank.

00:06:43.610 --> 00:06:44.410
Hello everybody.

00:06:44.410 --> 00:06:46.930
So that was the background.

00:06:46.930 --> 00:06:49.050
What are we shipping today?

00:06:49.050 --> 00:06:51.210
The very first thing
we are shipping

00:06:51.210 --> 00:06:55.230
is an architecture guide
on developer Android com.

00:06:55.230 --> 00:06:58.440
Now for over years, you've
been asking us for our opinion.

00:06:58.440 --> 00:07:02.220
Like how do we think that an
application should be built?

00:07:02.220 --> 00:07:03.900
And this is that guide.

00:07:03.900 --> 00:07:06.270
So we believe that
it's very good,

00:07:06.270 --> 00:07:08.730
covers lots of
application cases.

00:07:08.730 --> 00:07:10.890
But even if you
have an architecture

00:07:10.890 --> 00:07:14.040
that you are comfortable
with, you can keep it.

00:07:14.040 --> 00:07:18.300
But you can probably learn
something from this guide.

00:07:18.300 --> 00:07:20.910
Second, we are shipping
a new set of libraries

00:07:20.910 --> 00:07:23.290
that we call
architecture components.

00:07:23.290 --> 00:07:24.900
These are more
fundamental components

00:07:24.900 --> 00:07:28.440
where you can build
your application on top.

00:07:28.440 --> 00:07:29.760
The first thing is Lifecycles.

00:07:29.760 --> 00:07:33.000
So this is the biggest developer
complaint that we have.

00:07:33.000 --> 00:07:35.610
Lifecycles are hard,
Lifecycles are hard.

00:07:35.610 --> 00:07:38.020
And we said, OK, we
should solve this problem.

00:07:38.020 --> 00:07:41.850
And the first level of this,
this new set of components.

00:07:41.850 --> 00:07:44.070
Second one is
Lifecycle-aware observables,

00:07:44.070 --> 00:07:46.860
which will go in detail
later, but this is basically

00:07:46.860 --> 00:07:51.730
things that can do something
based on the Lifecycle.

00:07:51.730 --> 00:07:54.810
Third, we are going to introduce
a lightweight ViewModel, which

00:07:54.810 --> 00:07:58.020
is all of our effort
to take out that code

00:07:58.020 --> 00:08:00.150
outside of your
Activities and Fragments,

00:08:00.150 --> 00:08:03.550
and put it somewhere else
where you can easily test it.

00:08:03.550 --> 00:08:06.630
Last but not least, we are
going to introduce a new object

00:08:06.630 --> 00:08:10.290
mapping library for SQLite.

00:08:10.290 --> 00:08:15.248
And all of this is available for
you today on Maven Google com.

00:08:15.248 --> 00:08:24.290
[APPLAUSE]

00:08:24.290 --> 00:08:25.790
Let's talk about Lifecycles.

00:08:25.790 --> 00:08:27.830
So what is what's
hard about Lifecycles?

00:08:27.830 --> 00:08:29.970
Why do we hear so many
complaints about that?

00:08:29.970 --> 00:08:31.510
Let's go through an example.

00:08:31.510 --> 00:08:33.440
Assume we have an
activity where we

00:08:33.440 --> 00:08:36.591
want to show the location
of the device on the screen.

00:08:36.591 --> 00:08:38.090
So you will try
something like this.

00:08:38.090 --> 00:08:41.280
You create a LocationListener
on Create method,

00:08:41.280 --> 00:08:43.250
you need to initialize
it with the context,

00:08:43.250 --> 00:08:46.520
and you have a callback that
it calls whenever the location

00:08:46.520 --> 00:08:48.800
changes, and you update the UI.

00:08:48.800 --> 00:08:51.230
Now, if you have ever written
an Android application,

00:08:51.230 --> 00:08:54.330
you know that this
code is never enough.

00:08:54.330 --> 00:08:57.440
You also need to go ahead and
override onStart, and then

00:08:57.440 --> 00:09:01.880
tell it to start, and override
onStop, and tell it to stop.

00:09:01.880 --> 00:09:04.040
You always need to
do this babysitting

00:09:04.040 --> 00:09:05.510
for these components.

00:09:05.510 --> 00:09:06.840
But this is acceptable.

00:09:06.840 --> 00:09:09.680
This a simple example,
this looks all right.

00:09:09.680 --> 00:09:11.750
But then your product
manager comes and says,

00:09:11.750 --> 00:09:12.560
oh, you know what?

00:09:12.560 --> 00:09:16.160
We need to first check the
user settings before enable--

00:09:16.160 --> 00:09:17.710
asking for a location.

00:09:17.710 --> 00:09:22.160
Then your developer says, OK,
sure, that's an easy change.

00:09:22.160 --> 00:09:25.570
I'm going to change this method
to first call this utility

00:09:25.570 --> 00:09:27.980
method, which probably
makes a web service call

00:09:27.980 --> 00:09:29.900
to check the user settings.

00:09:29.900 --> 00:09:32.030
And then if the
user is enrolled,

00:09:32.030 --> 00:09:34.160
then we want to start
the LocationListener.

00:09:34.160 --> 00:09:37.010
Which looks like a
very simple change,

00:09:37.010 --> 00:09:39.440
you will think this would
work, but let's look

00:09:39.440 --> 00:09:42.440
at what happens in that
activity's Lifecycle.

00:09:42.440 --> 00:09:43.990
So our activity was created.

00:09:43.990 --> 00:09:49.526
We said, OK, run start check
if the user status is enrolled.

00:09:49.526 --> 00:09:52.370
Then meanwhile, user wants
to rotate the device.

00:09:52.370 --> 00:09:54.930
Which, rotation means
a configuration change,

00:09:54.930 --> 00:09:58.430
which means Android is going
to recreate that activity.

00:09:58.430 --> 00:10:00.200
So in onStop, we
knew about this,

00:10:00.200 --> 00:10:03.292
and we said, OK,
location manager stop.

00:10:03.292 --> 00:10:05.780
And then the new
activity came, it also

00:10:05.780 --> 00:10:07.430
goes through the same thing.

00:10:07.430 --> 00:10:10.280
Looks all right, except
do you remember this call

00:10:10.280 --> 00:10:12.140
we made before?

00:10:12.140 --> 00:10:15.400
That little change, and then
it decides to come back.

00:10:15.400 --> 00:10:17.110
Hey, user is enrolled.

00:10:17.110 --> 00:10:18.080
And then what we did?

00:10:18.080 --> 00:10:20.790
We said, OK, then start.

00:10:20.790 --> 00:10:22.250
And you realize the [INAUDIBLE]?

00:10:22.250 --> 00:10:26.510
We called start after
calling on stop, which means

00:10:26.510 --> 00:10:28.700
our activity will live forever.

00:10:28.700 --> 00:10:31.130
We are going to observe
the location forever,

00:10:31.130 --> 00:10:32.257
the battery will drain.

00:10:32.257 --> 00:10:33.215
We will have sad users.

00:10:37.078 --> 00:10:38.600
This is situation, right?

00:10:38.600 --> 00:10:40.220
We want to get rid of this.

00:10:40.220 --> 00:10:41.840
We want to put an end to this.

00:10:41.840 --> 00:10:43.950
So we said, OK, we
need to acknowledge--

00:10:43.950 --> 00:10:46.670
like as Mike mentioned,
we cannot change the laws,

00:10:46.670 --> 00:10:49.670
but we can make it easier
to deal with these things.

00:10:49.670 --> 00:10:52.430
So we decided to introduce
a new interface called

00:10:52.430 --> 00:10:53.970
LifecycleOwner.

00:10:53.970 --> 00:10:55.970
This is a thing
with a Lifecycle.

00:10:55.970 --> 00:10:58.400
Is your activity, is
your fragment-- or maybe

00:10:58.400 --> 00:11:02.270
you have your own UI framework,
whatever the container you have

00:11:02.270 --> 00:11:05.570
there as a LifecycleOwner.

00:11:05.570 --> 00:11:08.780
And we have these
LifecycleObservers,

00:11:08.780 --> 00:11:11.180
which are the things that
care about the Lifecycle.

00:11:11.180 --> 00:11:13.310
Like the
LocationListener we had,

00:11:13.310 --> 00:11:16.580
it cares about the Lifecycle,
it wants to stop itself

00:11:16.580 --> 00:11:18.680
if the Lifecycle is not active.

00:11:18.680 --> 00:11:21.130
So we said, OK, we
will acknowledge this.

00:11:21.130 --> 00:11:23.600
And we have a
LifecycleObservers.

00:11:23.600 --> 00:11:26.090
And we'll go through the
code through our activity.

00:11:26.090 --> 00:11:30.080
Now we make our activity extend
the LifecycleActivity class.

00:11:30.080 --> 00:11:33.320
This is just a temporary
class until these components

00:11:33.320 --> 00:11:34.410
reach 1.0.

00:11:34.410 --> 00:11:35.900
Then everything
in Support Library

00:11:35.900 --> 00:11:39.980
will implement this
LifecycleOwner interface.

00:11:39.980 --> 00:11:42.550
Inside of our activity,
when we initialize

00:11:42.550 --> 00:11:45.710
our LocationListener,
we are going to tell it,

00:11:45.710 --> 00:11:48.240
this is the Lifecycle
you care about.

00:11:48.240 --> 00:11:50.390
And that's all we will do.

00:11:50.390 --> 00:11:54.410
But as it's the same, it
calls back the update UI.

00:11:54.410 --> 00:11:57.020
So how can we change
our LocationListener

00:11:57.020 --> 00:12:00.890
to take advantage
of this Lifecycle?

00:12:00.890 --> 00:12:03.500
Oh, we do the same thing
for the UserStatus as well.

00:12:06.240 --> 00:12:08.880
So there's some boilerplate
code here to get the fields.

00:12:08.880 --> 00:12:10.950
It doesn't really
matter, but we have

00:12:10.950 --> 00:12:14.850
this enabled method which gets
called if the user is enrolled.

00:12:14.850 --> 00:12:16.500
Inside this enabled
method, now we

00:12:16.500 --> 00:12:18.420
want to start
listening to location

00:12:18.420 --> 00:12:21.360
only if the activity is started.

00:12:21.360 --> 00:12:23.040
Now you can do this.

00:12:23.040 --> 00:12:26.590
You can say, what is my current
state, which is amazing.

00:12:26.590 --> 00:12:29.370
We didn't have
this API until now.

00:12:29.370 --> 00:12:32.010
Well now you can.

00:12:32.010 --> 00:12:34.110
So OK, that was a simple change.

00:12:34.110 --> 00:12:36.510
But we also get
notified, what if we get

00:12:36.510 --> 00:12:38.710
enrolled when the activity
was in back state,

00:12:38.710 --> 00:12:40.800
and user comes back
to the activity.

00:12:40.800 --> 00:12:43.290
Now we should actually
start the LocationManager.

00:12:43.290 --> 00:12:46.290
For this, we want to
observe that Lifecycle.

00:12:46.290 --> 00:12:48.690
To do that, we implement
this interface,

00:12:48.690 --> 00:12:50.670
which allows us to
write these methods.

00:12:50.670 --> 00:12:52.710
You can annotate
the methods saying

00:12:52.710 --> 00:12:56.152
that, if ON_START
happens, call this method.

00:12:56.152 --> 00:12:58.360
And the new components will
take care of calling you.

00:12:58.360 --> 00:13:00.660
So if you are already
enabled, now you

00:13:00.660 --> 00:13:03.540
start, and ON_STOP
you disconnect.

00:13:03.540 --> 00:13:06.700
And last but not least, if
the activity is destroyed

00:13:06.700 --> 00:13:09.220
there is nothing you want
to do with that activity

00:13:09.220 --> 00:13:11.796
so you can unregister.

00:13:11.796 --> 00:13:13.920
So now you might be asking
yourself, well, you just

00:13:13.920 --> 00:13:16.710
moved those ON_START, ON_STOP
methods from the activity

00:13:16.710 --> 00:13:18.450
into this Location Manager.

00:13:18.450 --> 00:13:20.150
How come it is simpler?

00:13:20.150 --> 00:13:22.250
It's simpler because
those methods

00:13:22.250 --> 00:13:23.610
live in the right place.

00:13:23.610 --> 00:13:27.690
It's the Location Manager which
cares about the Lifecycle.

00:13:27.690 --> 00:13:30.780
So it should be able to
do it without the activity

00:13:30.780 --> 00:13:32.460
babysitting itself.

00:13:32.460 --> 00:13:34.170
I'm sure if you look
at your code today,

00:13:34.170 --> 00:13:37.260
your activity ON_START, ON_STOP
methods are like, at least 20,

00:13:37.260 --> 00:13:38.730
30 lines of code.

00:13:38.730 --> 00:13:42.060
We want them to be
zero lines of code.

00:13:42.060 --> 00:13:43.800
If we go back to
activity, I want

00:13:43.800 --> 00:13:45.780
to point out something that--

00:13:45.780 --> 00:13:49.260
look, in onCreate, we
initialized these components.

00:13:49.260 --> 00:13:50.580
And that's all we did.

00:13:50.580 --> 00:13:53.230
We didn't override, we
didn't ON_STOP, ON_START,

00:13:53.230 --> 00:13:55.020
we don't override
any of those things

00:13:55.020 --> 00:13:59.630
because the Location Manager
is a Lifecycle aware component

00:13:59.630 --> 00:14:01.875
now.

00:14:01.875 --> 00:14:03.990
So it's a new concept
we want to introduce.

00:14:03.990 --> 00:14:08.130
A Lifecycle aware component in
a component can get a Lifecycle,

00:14:08.130 --> 00:14:09.170
and do the right things.

00:14:09.170 --> 00:14:12.210
It can take care of itself
so that your activity,

00:14:12.210 --> 00:14:15.120
you can just initialize
it and forget about it.

00:14:15.120 --> 00:14:19.060
You know that's not
going to leak you.

00:14:19.060 --> 00:14:22.480
Now, of course, it was like
more of moving the complex

00:14:22.480 --> 00:14:24.520
from activity to the
Location Manager,

00:14:24.520 --> 00:14:27.310
and then it still needs
to deal with Lifecycle.

00:14:27.310 --> 00:14:29.190
We said, OK, what do we want?

00:14:29.190 --> 00:14:32.540
It's nice to be able to
do that, but we want more.

00:14:32.540 --> 00:14:35.230
We want a very convenient
to handle this common case.

00:14:35.230 --> 00:14:38.390
It's very common that your
activity or fragment, it

00:14:38.390 --> 00:14:41.830
observes some data, and
whenever that data changes,

00:14:41.830 --> 00:14:43.300
it wants to refresh itself.

00:14:43.300 --> 00:14:46.910
It happens basically
almost every single UI.

00:14:46.910 --> 00:14:49.870
And we want to share resources
across multiple fragments

00:14:49.870 --> 00:14:51.250
or activities.

00:14:51.250 --> 00:14:54.580
The location of the device
is the same from fragment

00:14:54.580 --> 00:14:55.240
to fragment.

00:14:55.240 --> 00:14:57.040
If you have two
fragments, why do you

00:14:57.040 --> 00:15:01.610
need to create two listeners
to listen to the same location?

00:15:01.610 --> 00:15:05.080
Hence, we created this
new LiveData clause.

00:15:05.080 --> 00:15:06.600
Let's look at that.

00:15:06.600 --> 00:15:10.390
So LiveData is a data holder,
it just holds some data.

00:15:10.390 --> 00:15:13.690
It's like an observable, but
the tricky thing about LiveData

00:15:13.690 --> 00:15:15.760
is that it is Lifecycle aware.

00:15:15.760 --> 00:15:18.310
It understands about Lifecycles.

00:15:18.310 --> 00:15:20.820
Because it understands
about Lifecycles,

00:15:20.820 --> 00:15:22.850
it automatically
manages subscriptions.

00:15:22.850 --> 00:15:25.220
So very similar to
the previous example,

00:15:25.220 --> 00:15:29.290
if you are observing a LiveData,
you don't need to unsubscribe,

00:15:29.290 --> 00:15:33.040
the right things will
happen in the right times.

00:15:33.040 --> 00:15:37.660
So if that LocationListener
was a LiveData, and a singleton

00:15:37.660 --> 00:15:40.000
because location
is singleton, we

00:15:40.000 --> 00:15:41.800
could write the code like this--

00:15:41.800 --> 00:15:43.930
get distance, start observing.

00:15:43.930 --> 00:15:47.280
And when you observe, you
say, this is my Lifecycle.

00:15:47.280 --> 00:15:48.280
This all you need to do.

00:15:48.280 --> 00:15:51.880
Before on Android, if you were
observing something singleton

00:15:51.880 --> 00:15:55.180
from an activity, everyone
will give minus two

00:15:55.180 --> 00:15:56.650
to that code review.

00:15:56.650 --> 00:15:57.805
Now you can do this.

00:15:57.805 --> 00:16:01.600
This is safe,
nothing ever leaks.

00:16:01.600 --> 00:16:03.790
So if you want to change
your LocationListener

00:16:03.790 --> 00:16:07.430
to use this new API, we get
rid of the unnecessary things.

00:16:07.430 --> 00:16:09.590
All we need is a
context to connect.

00:16:09.590 --> 00:16:15.540
What we say, this is a LiveData,
this a LiveData of a location.

00:16:15.540 --> 00:16:18.110
And we get these
two new methods.

00:16:18.110 --> 00:16:20.520
One of two says
onActive, which means

00:16:20.520 --> 00:16:22.920
you have an active observer.

00:16:22.920 --> 00:16:24.475
And the other one
says onInactive,

00:16:24.475 --> 00:16:27.555
which means you don't have
any observers that are active.

00:16:27.555 --> 00:16:30.360
Now at this point, you're
probably asking yourself,

00:16:30.360 --> 00:16:32.590
what is an active observer?

00:16:32.590 --> 00:16:34.290
Well, we define
an active observer

00:16:34.290 --> 00:16:37.710
as an observer that's in the
STARTED or RESUMED state, which

00:16:37.710 --> 00:16:40.440
is like an activity user
is currently seeing.

00:16:40.440 --> 00:16:43.020
So if you have an observer
in the back stack,

00:16:43.020 --> 00:16:45.300
there's no reason to
put this inactive.

00:16:45.300 --> 00:16:47.190
There's no reason to
update that activity

00:16:47.190 --> 00:16:49.950
because user will never, ever
see what's going on there.

00:16:53.390 --> 00:16:56.130
So inside our connect
method, all we need to do

00:16:56.130 --> 00:16:58.540
is, whenever the system
Location Manager sends us

00:16:58.540 --> 00:17:02.120
a new location, we call
setValue on ourselves.

00:17:02.120 --> 00:17:05.589
Then the LiveData knows which
are the active observers,

00:17:05.589 --> 00:17:08.410
and delivers the data
to those observers.

00:17:08.410 --> 00:17:11.930
Or if one of the observers
was on the back stack

00:17:11.930 --> 00:17:14.290
and then becomes
visible again, LiveData

00:17:14.290 --> 00:17:17.080
takes care of sending the latest
data back to that observer.

00:17:19.609 --> 00:17:22.859
And then we can make our
LocationListener singleton

00:17:22.859 --> 00:17:26.020
because well, we don't
need multiple instances.

00:17:26.020 --> 00:17:30.400
So if we look at LiveData, it
is a Lifecycle aware Observable.

00:17:30.400 --> 00:17:32.520
It is very simple start
and stop semantics.

00:17:32.520 --> 00:17:34.650
Doesn't matter how many
observers you have,

00:17:34.650 --> 00:17:39.740
or what state they are, we merge
all of it into one Lifecycle.

00:17:39.740 --> 00:17:42.000
And it doesn't have any
activities or fragments

00:17:42.000 --> 00:17:44.620
inside it, but it works
with both of them.

00:17:44.620 --> 00:17:47.460
And is also really used to
test LiveData because it's

00:17:47.460 --> 00:17:49.080
kind of Android free.

00:17:49.080 --> 00:17:52.720
And if you know about this
infamous FragmentTransaction

00:17:52.720 --> 00:17:56.670
exception, we guarantee that
your observer will never,

00:17:56.670 --> 00:17:59.750
ever be called in a state
where you cannot run

00:17:59.750 --> 00:18:01.260
a FragmentTransaction.

00:18:01.260 --> 00:18:03.780
So this is very, very
specifically designed

00:18:03.780 --> 00:18:08.100
to work well with your
Activities and Fragments.

00:18:08.100 --> 00:18:11.520
OK, let's think about
configuration changes.

00:18:11.520 --> 00:18:14.460
Now, that example was easy
because location is global,

00:18:14.460 --> 00:18:17.550
but most of the time,
the data belongs to a UI.

00:18:17.550 --> 00:18:22.770
So if we had an activity
where we show a user profile,

00:18:22.770 --> 00:18:24.660
and we implemented
a web service that

00:18:24.660 --> 00:18:28.260
can return the data as a
LiveData which we can safely

00:18:28.260 --> 00:18:32.580
observe without risking
leaking overactivity,

00:18:32.580 --> 00:18:33.470
this all looks nice.

00:18:33.470 --> 00:18:35.030
You will never
leak this activity,

00:18:35.030 --> 00:18:36.390
it will work very well.

00:18:36.390 --> 00:18:40.340
Except, what happens if the
user rotates to the device?

00:18:40.340 --> 00:18:42.850
Let's look at the
LifeCycle graph again.

00:18:42.850 --> 00:18:44.790
So activity is
created, it saves, OK.

00:18:44.790 --> 00:18:46.752
Fetch the user.

00:18:46.752 --> 00:18:48.460
And then while you
are fetching the user,

00:18:48.460 --> 00:18:51.390
user decides, oh, I want
to rotate the phone.

00:18:51.390 --> 00:18:53.130
And then that
activity is destroyed.

00:18:53.130 --> 00:18:55.740
Luckily we don't leak
it, which is great.

00:18:55.740 --> 00:18:57.810
But then the new
activity starts,

00:18:57.810 --> 00:18:59.620
which makes this new call.

00:18:59.620 --> 00:19:02.160
Now, this is OK, but not great.

00:19:02.160 --> 00:19:03.640
What do we want?

00:19:03.640 --> 00:19:05.700
We want to actually
retain that data, right?

00:19:05.700 --> 00:19:09.870
We are already making that
request, why remake it?

00:19:09.870 --> 00:19:12.780
So we want our graph
to look like this.

00:19:12.780 --> 00:19:14.640
So if the new activity
comes, we should

00:19:14.640 --> 00:19:18.330
be able to give it back the
same view model, which is

00:19:18.330 --> 00:19:20.340
a new class called ViewModel.

00:19:20.340 --> 00:19:22.290
So we are introducing
this new class

00:19:22.290 --> 00:19:23.760
very specific to
this thing, where

00:19:23.760 --> 00:19:27.210
you should put the data
inside your activities

00:19:27.210 --> 00:19:30.940
into the ViewModel, and make
the activities data-free.

00:19:30.940 --> 00:19:33.000
So if you want to
change this activity,

00:19:33.000 --> 00:19:36.910
we create this new class, it
extends the VewModel class.

00:19:36.910 --> 00:19:41.830
Whatever data we had inside
the activity, we move it there.

00:19:41.830 --> 00:19:45.630
And in the ViewModel, all we do
is, inside the getUser method,

00:19:45.630 --> 00:19:48.790
if this is the first goal,
get it from the web service.

00:19:48.790 --> 00:19:51.800
Otherwise, return
to existing value.

00:19:51.800 --> 00:19:53.220
Now, super simple.

00:19:53.220 --> 00:19:55.800
And inside our activity, we
get rid of all that code.

00:19:55.800 --> 00:19:58.590
We say, get the
ViewModelProviders.of this.

00:19:58.590 --> 00:20:01.620
So each activity or a fragment
has a ViewModelProvider

00:20:01.620 --> 00:20:04.680
that you can obtain, and
that ViewModelProvider knows

00:20:04.680 --> 00:20:06.510
how to give you the ViewModel.

00:20:06.510 --> 00:20:08.880
So when you call
get MyViewModel,

00:20:08.880 --> 00:20:10.530
the very first time
you make this call,

00:20:10.530 --> 00:20:11.940
we will give you a new instance.

00:20:11.940 --> 00:20:13.780
When the rotated
activity comes back,

00:20:13.780 --> 00:20:16.760
it's going to reconnect
to the same ViewModel.

00:20:16.760 --> 00:20:19.432
And then the rest of
the code is the same.

00:20:19.432 --> 00:20:22.318
[APPLAUSE]

00:20:28.580 --> 00:20:31.060
So if you look at the
Lifecycle, this is how it looks.

00:20:31.060 --> 00:20:32.040
This is what we wanted.

00:20:32.040 --> 00:20:35.800
The new activity is
started, it reconnects.

00:20:35.800 --> 00:20:38.140
And when the new
activity is finished,

00:20:38.140 --> 00:20:41.050
like when we don't have anything
to do with that activity,

00:20:41.050 --> 00:20:42.580
and then we go
and tell ViewModel

00:20:42.580 --> 00:20:44.350
that it's not needed anymore.

00:20:44.350 --> 00:20:48.340
This is actually the only
method in the ViewModel class.

00:20:48.340 --> 00:20:49.570
So this is very simple.

00:20:49.570 --> 00:20:51.640
So if we look at
Lifecycles, they

00:20:51.640 --> 00:20:53.310
hold the data for the activity.

00:20:53.310 --> 00:20:56.500
They survive
configuration changes.

00:20:56.500 --> 00:20:58.930
They should never,
ever reference views

00:20:58.930 --> 00:21:00.870
because they [INAUDIBLE]
leave the activities.

00:21:00.870 --> 00:21:03.430
So you cannot reference
back to the activity.

00:21:03.430 --> 00:21:05.640
That's why you use
things like LiveData,

00:21:05.640 --> 00:21:08.550
Rx Java, or
datamining observables

00:21:08.550 --> 00:21:10.270
to do that communication.

00:21:10.270 --> 00:21:12.730
And this is what our
activity talks-- it always

00:21:12.730 --> 00:21:15.070
talks to the ViewModel.

00:21:15.070 --> 00:21:19.210
Now, another big
topic is persistence.

00:21:19.210 --> 00:21:22.000
Now, we know that to write a
good, responsive Android app,

00:21:22.000 --> 00:21:24.860
you need to save
the data on disk.

00:21:24.860 --> 00:21:27.700
If you come to Android, there's
this three major APIs we have.

00:21:27.700 --> 00:21:29.980
One of them is content
providers, which

00:21:29.980 --> 00:21:32.320
is to talk between processes.

00:21:32.320 --> 00:21:35.530
It really has nothing to do
with persistence, in reality.

00:21:35.530 --> 00:21:37.510
The other one is
shared preferences,

00:21:37.510 --> 00:21:40.090
which saves the data in XML.

00:21:40.090 --> 00:21:43.190
So you can only put very
little data into that.

00:21:43.190 --> 00:21:44.800
And the last one
is SQLite, which

00:21:44.800 --> 00:21:48.160
is something we have been
shipping since Android 1.

00:21:48.160 --> 00:21:49.720
So you know you
need to use SQLite

00:21:49.720 --> 00:21:51.890
if you want to save big data.

00:21:51.890 --> 00:21:55.330
And so you go into the
developer.android.com/ This is

00:21:55.330 --> 00:21:57.960
the very first saving
your data slide.

00:21:57.960 --> 00:22:00.130
This is so confusing.

00:22:00.130 --> 00:22:01.642
This is very sad.

00:22:01.642 --> 00:22:03.370
[LAUGHTER]

00:22:03.370 --> 00:22:06.190
So is it-- OK, we want
to make this less sad.

00:22:06.190 --> 00:22:07.960
We want to make it happy.

00:22:07.960 --> 00:22:10.060
So we'll look at
the example, right?

00:22:10.060 --> 00:22:11.740
So there's-- on top,
it tries to say,

00:22:11.740 --> 00:22:15.670
I want to select these three
columns with this constraint,

00:22:15.670 --> 00:22:17.950
and I want to order
them like this.

00:22:17.950 --> 00:22:20.670
This actually really,
really simple SQL query,

00:22:20.670 --> 00:22:22.210
but you need to
write all this code.

00:22:22.210 --> 00:22:24.160
Plus, this code
doesn't even show where

00:22:24.160 --> 00:22:27.720
you define all those constants.

00:22:27.720 --> 00:22:29.430
So what do we really want?

00:22:29.430 --> 00:22:32.060
We want to get rid of that
boilerplate-free code.

00:22:32.060 --> 00:22:34.890
When you are writing Java,
if you make a typo in Java,

00:22:34.890 --> 00:22:36.630
it doesn't compile right.

00:22:36.630 --> 00:22:39.010
We want the same thing for SQL.

00:22:39.010 --> 00:22:42.000
We still want to use SQLite,
because on every single Android

00:22:42.000 --> 00:22:43.740
device it's a proven technology.

00:22:43.740 --> 00:22:46.230
We know it works very well.

00:22:46.230 --> 00:22:48.280
But we want the compile
time verification.

00:22:48.280 --> 00:22:49.970
So we don't want the
boilerplate code,

00:22:49.970 --> 00:22:52.480
we want to compile
time verification.

00:22:52.480 --> 00:22:56.220
So we said, well-- we came up
with Room, which is an object

00:22:56.220 --> 00:22:59.649
mapping library for SQLite.

00:22:59.649 --> 00:23:05.800
[APPLAUSE]

00:23:05.800 --> 00:23:08.210
So if you look at
this query, we said,

00:23:08.210 --> 00:23:10.770
OK, let's move this query
inside the annotation.

00:23:10.770 --> 00:23:12.610
We like annotations.

00:23:12.610 --> 00:23:14.560
And we have this
feed object, which we

00:23:14.560 --> 00:23:16.360
want to save in the database.

00:23:16.360 --> 00:23:19.270
I want to put that query
inside an interface.

00:23:19.270 --> 00:23:21.280
You want to create the FeedDao--

00:23:21.280 --> 00:23:24.040
the Dao stands for
Data Access Object.

00:23:24.040 --> 00:23:27.430
Usually in database, the best
practice to put your database

00:23:27.430 --> 00:23:29.350
access into certain interfaces.

00:23:29.350 --> 00:23:32.252
Then we just need to tell
the Room, this is a Dow.

00:23:32.252 --> 00:23:34.360
Tell Room this is an entity.

00:23:34.360 --> 00:23:37.960
And finally, we had a
database class which says,

00:23:37.960 --> 00:23:41.050
I have these entities-- so
you have multiple entities,

00:23:41.050 --> 00:23:45.240
and I have these data access
objects, as you saw them.

00:23:45.240 --> 00:23:46.210
This is all you write.

00:23:46.210 --> 00:23:48.760
Once you write that, you can
get an implementation of it

00:23:48.760 --> 00:23:49.590
from Room.

00:23:49.590 --> 00:23:52.750
It's very similar to how
you use Retrofit or Dagger--

00:23:52.750 --> 00:23:57.080
you define the interfaces, we
provide the implementation.

00:23:57.080 --> 00:23:59.740
Now, once we know
this is a Dow, we

00:23:59.740 --> 00:24:01.210
can do these shortcut methods.

00:24:01.210 --> 00:24:05.350
Like, insert these items, or
delete these items, or update--

00:24:05.350 --> 00:24:06.930
a bunch of shortcut methods.

00:24:06.930 --> 00:24:08.710
And you can press
multiple parameters.

00:24:08.710 --> 00:24:11.115
As long as you can read
it and it makes sense,

00:24:11.115 --> 00:24:13.930
Room will understand it.

00:24:13.930 --> 00:24:16.000
But the most
important part of Room

00:24:16.000 --> 00:24:18.680
is, it understands your SQL.

00:24:18.680 --> 00:24:20.320
So the part-- all
those constants

00:24:20.320 --> 00:24:23.630
I mentioned we defined to
get compile time guarantees,

00:24:23.630 --> 00:24:26.560
Room actually gives
all of this for free.

00:24:26.560 --> 00:24:28.380
So when Room sees
this query, says,

00:24:28.380 --> 00:24:31.060
OK, you are receiving
these three columns

00:24:31.060 --> 00:24:34.900
from this table where the
title looks like this keyword.

00:24:34.900 --> 00:24:36.705
Where is this
keyword coming from?

00:24:36.705 --> 00:24:38.710
Oh, it's coming from
the function parameters.

00:24:38.710 --> 00:24:39.567
Makes sense.

00:24:39.567 --> 00:24:40.900
And what does it want to return?

00:24:40.900 --> 00:24:42.970
It wants to return
a list of feeds.

00:24:42.970 --> 00:24:45.330
And then Room goes and checks.

00:24:45.330 --> 00:24:47.980
Does the columns
returned match the object

00:24:47.980 --> 00:24:49.690
the user wants to return?

00:24:49.690 --> 00:24:53.812
And once they're equal, it says,
OK, I can generate this code.

00:24:53.812 --> 00:24:55.270
You can have even
say, select star.

00:24:55.270 --> 00:24:56.600
You don't need to list them.

00:24:56.600 --> 00:25:00.190
Room really, really
understand your query.

00:25:00.190 --> 00:25:03.130
You can even join 10
tables, it will still work.

00:25:03.130 --> 00:25:05.020
But what if you made a typo?

00:25:05.020 --> 00:25:07.750
Instead of saying feed
table you wrote feeds.

00:25:07.750 --> 00:25:10.750
Now, if this happens,
Room is going to give you

00:25:10.750 --> 00:25:12.940
an error at compile time.

00:25:12.940 --> 00:25:15.040
So it goes out and
verifies your query

00:25:15.040 --> 00:25:17.080
against the schema
you have defined,

00:25:17.080 --> 00:25:19.562
and it tells you if
something is wrong.

00:25:19.562 --> 00:25:22.508
[APPLAUSE]

00:25:27.797 --> 00:25:29.380
But that's not the
only thing it does.

00:25:29.380 --> 00:25:30.860
So if you said--

00:25:30.860 --> 00:25:34.070
if your query is correct, you
want to fetch ID and title.

00:25:34.070 --> 00:25:35.870
This said, well,
it's query, but you

00:25:35.870 --> 00:25:37.350
want to return it as a string.

00:25:37.350 --> 00:25:40.460
And then Room says, well, you
are returning two columns,

00:25:40.460 --> 00:25:42.260
but you only have one string.

00:25:42.260 --> 00:25:43.320
That doesn't make sense.

00:25:43.320 --> 00:25:46.800
And it's going to give you
a compile time error again.

00:25:46.800 --> 00:25:49.220
And there's a really nice
way to fix this in Room.

00:25:49.220 --> 00:25:51.095
You can basically
create any Java class.

00:25:51.095 --> 00:25:52.580
It doesn't need
to be annotating,

00:25:52.580 --> 00:25:55.170
there's nothing special
about that Pojo,

00:25:55.170 --> 00:25:57.080
and tell Room to return it.

00:25:57.080 --> 00:25:59.780
As long as whatever
query it returns

00:25:59.780 --> 00:26:01.880
matches what you
want it to return,

00:26:01.880 --> 00:26:05.250
Room will write
the code for you.

00:26:05.250 --> 00:26:07.470
And observability, which
is very important, right?

00:26:07.470 --> 00:26:09.390
If you have a query
like this, now you're

00:26:09.390 --> 00:26:11.460
showing lists of
feeds, you obviously

00:26:11.460 --> 00:26:14.295
want to get notified
when the data changes.

00:26:14.295 --> 00:26:17.842
And in Room, if you want to
do this, all you have to do

00:26:17.842 --> 00:26:19.290
is tell it.

00:26:19.290 --> 00:26:22.980
Tell it to return a LiveData,
and it will do it for you.

00:26:22.980 --> 00:26:26.400
Because it knows your query,
it knows what things affect it.

00:26:26.400 --> 00:26:29.520
So it can let you know
if that query changes.

00:26:29.520 --> 00:26:32.280
And this is the part where all
these architectural components

00:26:32.280 --> 00:26:33.750
work well together.

00:26:33.750 --> 00:26:36.640
Room already knows
about LiveData.

00:26:36.640 --> 00:26:40.340
So your ViewModel, all you would
write is-- from the data is,

00:26:40.340 --> 00:26:42.600
call this query, and
this all it will do.

00:26:42.600 --> 00:26:46.650
Whenever that data changes,
your UI will get a new update.

00:26:46.650 --> 00:26:49.470
And it only happens
if the UI is visible.

00:26:49.470 --> 00:26:52.958
Last but not least, Room
also supports RxJava 2.

00:26:52.958 --> 00:26:55.448
[APPLAUSE]

00:27:01.930 --> 00:27:04.390
OK, if we look at
Room in a nutshell,

00:27:04.390 --> 00:27:06.730
it writes the
boilerplate code for you.

00:27:06.730 --> 00:27:08.050
It has full SQLite support.

00:27:08.050 --> 00:27:10.990
You can just write in
SQLite, there's no builders.

00:27:10.990 --> 00:27:14.070
It verifies your
queries at compile time.

00:27:14.070 --> 00:27:17.350
It incentivizes best
practices, which helps you

00:27:17.350 --> 00:27:19.480
with testing migrations.

00:27:19.480 --> 00:27:23.020
And it's also observable
out of the box.

00:27:23.020 --> 00:27:28.000
OK, architecture,
our last topic today.

00:27:28.000 --> 00:27:30.000
So where we started, right?

00:27:30.000 --> 00:27:31.860
And now, you might
be asking yourselves,

00:27:31.860 --> 00:27:34.335
what has changed
in 2017 that you

00:27:34.335 --> 00:27:36.930
are talking about architecture?

00:27:36.930 --> 00:27:38.740
Well, actually
nothing has changed.

00:27:38.740 --> 00:27:40.560
We've been talking
about this topic a lot.

00:27:40.560 --> 00:27:44.460
Adam Powell and I gave a
lot of talks on this topic.

00:27:44.460 --> 00:27:49.050
There's even a talk from 2010
which I watch as a developer.

00:27:49.050 --> 00:27:51.630
So this is a topic we have
been more clear about.

00:27:51.630 --> 00:27:54.720
But what is missing was
a well-defined reference

00:27:54.720 --> 00:27:56.022
architecture.

00:27:56.022 --> 00:27:57.480
So it's what we
are shipping today.

00:27:57.480 --> 00:27:59.370
If you go to
developer.android.com today

00:27:59.370 --> 00:28:01.680
after the session,
there's a section

00:28:01.680 --> 00:28:05.246
about how to architect
an Android application.

00:28:05.246 --> 00:28:08.697
[APPLAUSE]

00:28:13.640 --> 00:28:15.890
So by the way, this
is a reference guide.

00:28:15.890 --> 00:28:17.780
This is not your religious book.

00:28:17.780 --> 00:28:20.600
We believe this is a very good
way to write applications,

00:28:20.600 --> 00:28:24.320
but you don't need to
follow it line by line.

00:28:24.320 --> 00:28:27.400
So I'm going to briefly go
through this architecture,

00:28:27.400 --> 00:28:28.960
but if you get
lost, don't worry.

00:28:28.960 --> 00:28:31.950
We have all of this documented
on developer Android com

00:28:31.950 --> 00:28:34.264
with sample applications.

00:28:34.264 --> 00:28:35.680
So we think that
an application is

00:28:35.680 --> 00:28:37.300
composed of four main things--

00:28:37.300 --> 00:28:41.680
there's UI controllers, the
view models, a repository,

00:28:41.680 --> 00:28:43.030
and the data sources.

00:28:43.030 --> 00:28:45.640
So let's look at
these in detail.

00:28:45.640 --> 00:28:47.980
UI controllers are
your activities,

00:28:47.980 --> 00:28:51.100
fragments, custom views.

00:28:51.100 --> 00:28:52.750
They have really simple tasks.

00:28:52.750 --> 00:28:55.270
They observe the
fields of the ViewModel

00:28:55.270 --> 00:28:56.720
and update themselves.

00:28:56.720 --> 00:28:58.540
And they want more
responsibility.

00:28:58.540 --> 00:29:01.540
Whenever user takes
an action on the UI,

00:29:01.540 --> 00:29:04.450
they understand that action,
and call the ViewModel

00:29:04.450 --> 00:29:07.540
to express whatever
the user wanted to do.

00:29:07.540 --> 00:29:10.390
If you go to our view
model, view model

00:29:10.390 --> 00:29:13.450
is the one which prepares
the data for the UI,

00:29:13.450 --> 00:29:14.480
and holds onto it.

00:29:14.480 --> 00:29:16.740
This is where the
data for the UI lives.

00:29:16.740 --> 00:29:20.050
View model knows how
to get that data.

00:29:20.050 --> 00:29:21.949
Usually it has LiveData.

00:29:21.949 --> 00:29:23.740
If you are using Rx
Java, it is observable,

00:29:23.740 --> 00:29:26.940
or datamining observables.

00:29:26.940 --> 00:29:28.830
It survives
configuration changes.

00:29:28.830 --> 00:29:32.200
That's why we put the
data into the view models.

00:29:32.200 --> 00:29:33.680
And it is also the gateway.

00:29:33.680 --> 00:29:37.040
You can also consider it
as, your UI controller only

00:29:37.040 --> 00:29:39.230
ever talks to the
view model to reach

00:29:39.230 --> 00:29:42.690
to the rest of the application.

00:29:42.690 --> 00:29:44.360
And then what's the repository?

00:29:44.360 --> 00:29:47.100
Now, the view model
serves as a data store

00:29:47.100 --> 00:29:48.920
for your UI controller, right?

00:29:48.920 --> 00:29:51.060
Repository saves
it as a data store

00:29:51.060 --> 00:29:53.520
for all of your application.

00:29:53.520 --> 00:29:56.070
So it's the complete
data model for the app,

00:29:56.070 --> 00:29:58.560
and it provides this
data with simple APIs

00:29:58.560 --> 00:30:00.210
to the rest of the application.

00:30:00.210 --> 00:30:03.420
You can have a user repository
where you pass a user ID,

00:30:03.420 --> 00:30:06.000
and it returns your
LiveData of users.

00:30:06.000 --> 00:30:07.650
How it gets the data?

00:30:07.650 --> 00:30:10.260
You don't care, it's
the repository's job.

00:30:10.260 --> 00:30:11.280
So how does it do that?

00:30:11.280 --> 00:30:12.420
It talks to the--

00:30:12.420 --> 00:30:15.920
fetching, syncing,
looking at database,

00:30:15.920 --> 00:30:17.990
or talking to your
retrofit back end.

00:30:17.990 --> 00:30:20.770
It's the repository's job.

00:30:20.770 --> 00:30:23.100
And last but not least,
we have our data sources,

00:30:23.100 --> 00:30:25.020
like your REST API client.

00:30:25.020 --> 00:30:28.470
You might be using Retrofit,
or you have SQLite storage.

00:30:28.470 --> 00:30:30.500
You might be using Room,
or you might be using

00:30:30.500 --> 00:30:32.460
GRAM, doesn't really matter.

00:30:32.460 --> 00:30:34.920
Or you might be talking
to other content providers

00:30:34.920 --> 00:30:36.390
from other processes.

00:30:36.390 --> 00:30:39.090
These are things we
call data sources.

00:30:39.090 --> 00:30:41.940
And we think that
all of these layers

00:30:41.940 --> 00:30:43.830
can discover each
other to create

00:30:43.830 --> 00:30:45.630
dependency checks
to the system which

00:30:45.630 --> 00:30:47.370
we'll command using Dagger.

00:30:47.370 --> 00:30:49.800
But we also realize that
understanding dependency

00:30:49.800 --> 00:30:51.810
situation is not very trivial.

00:30:51.810 --> 00:30:55.560
It's a more complex topic, and
sometimes might be an overkill.

00:30:55.560 --> 00:30:57.750
And you could also
use a service locator

00:30:57.750 --> 00:31:01.560
if you feel more
comfortable with it.

00:31:01.560 --> 00:31:04.050
So let's go back to--

00:31:04.050 --> 00:31:06.700
go through a concrete example.

00:31:06.700 --> 00:31:10.110
Let's say we have a UI
that shows a user profile,

00:31:10.110 --> 00:31:12.380
and we have the
data sources which--

00:31:12.380 --> 00:31:16.080
we save it to database, we also
can get it from the network.

00:31:16.080 --> 00:31:18.210
How do we connect
these two things?

00:31:18.210 --> 00:31:21.240
Well, we said we first
need a user repository.

00:31:21.240 --> 00:31:23.880
User repository knows it
should check the database.

00:31:23.880 --> 00:31:25.680
It's not there,
make a web request.

00:31:25.680 --> 00:31:28.500
Or meanwhile, also try
to run the database.

00:31:28.500 --> 00:31:30.750
It doesn't matter
how it does it,

00:31:30.750 --> 00:31:32.820
but it knows how to
create a LiveData

00:31:32.820 --> 00:31:36.780
of a user or an
observable, doesn't matter.

00:31:36.780 --> 00:31:38.430
And then we need the
ViewModel, right,

00:31:38.430 --> 00:31:41.670
because the data for the
UI lives in the ViewModel.

00:31:41.670 --> 00:31:44.220
So we create this
ProfileViewModel,

00:31:44.220 --> 00:31:48.030
which talks to the repository
to get this information.

00:31:48.030 --> 00:31:50.850
And then the actual
fragment gets the data

00:31:50.850 --> 00:31:54.450
from the view model so that
if the fragment comes back,

00:31:54.450 --> 00:31:57.270
the LiveData will be there
in the ProfileViewModel.

00:31:57.270 --> 00:32:00.070
But if the fragment
disappears completely,

00:32:00.070 --> 00:32:01.680
we will get rid
of the ViewModel,

00:32:01.680 --> 00:32:05.240
and the data can be
garbage collected.

00:32:05.240 --> 00:32:07.100
Now, all this
abstraction we made,

00:32:07.100 --> 00:32:10.640
if you notice, every single
component only talks to the one

00:32:10.640 --> 00:32:14.520
right below it, which is--
helps to scale your application.

00:32:14.520 --> 00:32:16.340
It also has a
great side benefit,

00:32:16.340 --> 00:32:18.260
which is called testing.

00:32:18.260 --> 00:32:19.230
You're testing, right?

00:32:24.500 --> 00:32:26.210
So let's say you
want to test your UI.

00:32:26.210 --> 00:32:27.880
Now, people say UI
testing is hard.

00:32:27.880 --> 00:32:30.990
UI testing is--
yes, it's harder.

00:32:30.990 --> 00:32:33.320
But it's usually hard because
you put all of your code

00:32:33.320 --> 00:32:35.290
into that activity.

00:32:35.290 --> 00:32:38.630
Now, we said, put most
of it into the ViewModel,

00:32:38.630 --> 00:32:41.510
and you know that UI only
talks to the ViewModel,

00:32:41.510 --> 00:32:43.520
so you can get rid
of the other two.

00:32:43.520 --> 00:32:47.170
You only need to create a fake
ViewModel to test your UI.

00:32:47.170 --> 00:32:50.900
Testing your UI become super,
super easy with Espresso.

00:32:50.900 --> 00:32:52.880
And we have a
sample app on GitHub

00:32:52.880 --> 00:32:56.346
that you can check
out with [INAUDIBLE].

00:32:56.346 --> 00:32:58.220
And the same thing as
well as for ViewModels.

00:32:58.220 --> 00:32:59.660
If you want to
test the ViewModel,

00:32:59.660 --> 00:33:02.330
you know it's only talks
to the repositories.

00:33:02.330 --> 00:33:05.860
You replace it with a mock
respository, and it works.

00:33:05.860 --> 00:33:08.570
And you can even
test your ViewModels

00:33:08.570 --> 00:33:11.150
on your host machine, on JVM.

00:33:11.150 --> 00:33:12.780
And last but not
least, you can test

00:33:12.780 --> 00:33:14.030
the respository the same way.

00:33:14.030 --> 00:33:16.040
You just mock the data sources.

00:33:16.040 --> 00:33:21.000
You can easily test your
repositories as JUnit test.

00:33:21.000 --> 00:33:23.060
Now, I know this has been
a lot of information.

00:33:23.060 --> 00:33:26.420
We have two sessions tomorrow,
and also documentation.

00:33:26.420 --> 00:33:29.630
But now I want to call
our product manager lUKAS

00:33:29.630 --> 00:33:32.646
to talk about what to do next.

00:33:32.646 --> 00:33:35.574
[APPLAUSE]

00:33:41.425 --> 00:33:42.800
LUKAS BERGSTROM:
Like Yigit said,

00:33:42.800 --> 00:33:44.870
we just covered a lot of ground.

00:33:44.870 --> 00:33:46.820
And actually, we glossed
over a lot of detail

00:33:46.820 --> 00:33:48.080
while we did that.

00:33:48.080 --> 00:33:50.420
But luckily, you don't
have to remember everything

00:33:50.420 --> 00:33:51.950
that you just heard.

00:33:51.950 --> 00:33:56.180
We have a lot of material
for you to check out

00:33:56.180 --> 00:33:58.910
at developer.android.com/arch.

00:33:58.910 --> 00:34:03.305
And that link should start
working in 21 minutes.

00:34:06.260 --> 00:34:07.790
We wanted to give
you guys a chance

00:34:07.790 --> 00:34:10.219
to kind of blog and tweet
about this before anybody else.

00:34:10.219 --> 00:34:13.190
So that's why we held it back.

00:34:13.190 --> 00:34:15.560
So yeah, we made having
good documentation

00:34:15.560 --> 00:34:18.469
and samples a priority from
the beginning of this project,

00:34:18.469 --> 00:34:22.310
since providing good guidance is
really one of the major goals.

00:34:22.310 --> 00:34:24.800
So you're going to find
in-depth documentation that's

00:34:24.800 --> 00:34:27.337
written from the perspective
of an app developer.

00:34:27.337 --> 00:34:29.420
You're going to find really
meaty sample apps that

00:34:29.420 --> 00:34:31.280
show how to build a real app.

00:34:31.280 --> 00:34:34.650
And just as an example of
how much work went into this,

00:34:34.650 --> 00:34:36.139
we have a GitHub
browser sample app

00:34:36.139 --> 00:34:39.440
that probably has better test
coverage than many real world

00:34:39.440 --> 00:34:42.170
apps, written by that guy.

00:34:44.820 --> 00:34:47.420
And of course, we have the
guide to app architecture,

00:34:47.420 --> 00:34:50.929
which internally, we called the
Opinionated Guide for a while.

00:34:50.929 --> 00:34:53.210
And we think that
label still applies.

00:34:53.210 --> 00:34:55.639
But even if you're not
planning to use our recommended

00:34:55.639 --> 00:34:58.580
architecture, we think people
should check out the guide.

00:34:58.580 --> 00:35:04.010
It has principles that we think
apply to all apps on Android.

00:35:04.010 --> 00:35:07.760
And you're probably asking
yourself, do I not--

00:35:07.760 --> 00:35:09.830
what's the impact of
this going to be on me?

00:35:09.830 --> 00:35:13.160
Am I going to have to change the
way that I'm doing everything?

00:35:13.160 --> 00:35:15.315
You know, if you're
starting a new project,

00:35:15.315 --> 00:35:16.940
or if you have an
existing app, but you

00:35:16.940 --> 00:35:19.190
want to improve the
core architecture,

00:35:19.190 --> 00:35:22.100
then yeah, we recommend
taking a look at this stuff.

00:35:22.100 --> 00:35:24.050
It's still preview.

00:35:24.050 --> 00:35:26.790
We won't be hitting
1.0 for a few months,

00:35:26.790 --> 00:35:30.050
but we think it's definitely
ready for you guys

00:35:30.050 --> 00:35:32.460
to check out, and
use in projects.

00:35:32.460 --> 00:35:34.250
But if you're happy
with what you have,

00:35:34.250 --> 00:35:37.360
you don't need to
rewrite your app.

00:35:37.360 --> 00:35:39.530
So in the spirit of be
together, not the same,

00:35:39.530 --> 00:35:41.890
we're not dictating what
everyone has to use.

00:35:41.890 --> 00:35:44.590
If you're happy with your app
architecture, you can keep it.

00:35:44.590 --> 00:35:46.510
If you're happy with
your existing ORM,

00:35:46.510 --> 00:35:48.820
you don't have to use Room.

00:35:48.820 --> 00:35:51.910
Architecture components are
designed to work well together,

00:35:51.910 --> 00:35:55.780
but they do work
perfectly fine standalone.

00:35:55.780 --> 00:35:58.300
And mixing and matching
applies not only

00:35:58.300 --> 00:36:04.730
to architecture components,
but also third party libraries.

00:36:04.730 --> 00:36:11.760
So-- I'm waiting for
this slide to come up.

00:36:11.760 --> 00:36:14.389
So yeah, so you can
use what you have,

00:36:14.389 --> 00:36:16.680
and to start to integrate
architecture components where

00:36:16.680 --> 00:36:18.310
they make sense.

00:36:18.310 --> 00:36:21.000
So for example, if you're
happy with Rx Java,

00:36:21.000 --> 00:36:24.510
but you really like the
Lifecycle aware component stuff

00:36:24.510 --> 00:36:27.360
that Yigit just showed, so that
you have these self-sufficient

00:36:27.360 --> 00:36:31.590
components, you can use
LiveData together with Rx Java.

00:36:31.590 --> 00:36:34.800
So you can get all the
power of Rx Java operators,

00:36:34.800 --> 00:36:36.420
and now it's Lifecycle safe.

00:36:36.420 --> 00:36:39.510
So kind of the best
of both worlds.

00:36:39.510 --> 00:36:41.760
And we've got additional
integrations to come.

00:36:41.760 --> 00:36:45.890
We're definitely looking at
a lot of stuff internally

00:36:45.890 --> 00:36:48.480
that would be nice if
it were self-sufficient

00:36:48.480 --> 00:36:50.500
and Lifecycle aware.

00:36:50.500 --> 00:36:53.460
And if you're a
library developer,

00:36:53.460 --> 00:36:55.920
we really recommend
checking out Lifecycles

00:36:55.920 --> 00:36:57.690
and LifecycleObserver
because we think

00:36:57.690 --> 00:37:00.480
there is a really bright
future, and a lot of potential

00:37:00.480 --> 00:37:03.420
in making libraries and
components that are Lifecycle

00:37:03.420 --> 00:37:07.870
aware by default.
But before you go

00:37:07.870 --> 00:37:11.110
do that, we have a lot more
for you at I/O this year.

00:37:11.110 --> 00:37:15.310
We have two more talks,
one on Lifecycles

00:37:15.310 --> 00:37:18.280
that's even more in-depth than
what we just showed tomorrow

00:37:18.280 --> 00:37:20.020
morning.

00:37:20.020 --> 00:37:24.040
We have another one on
Room and Persistence,

00:37:24.040 --> 00:37:25.480
and going a little
bit beyond Room

00:37:25.480 --> 00:37:27.790
starting at 12:30 tomorrow.

00:37:27.790 --> 00:37:31.950
And we'll have people who are
well-versed in architecture

00:37:31.950 --> 00:37:36.740
components in the
sandbox for all of I/O.

00:37:36.740 --> 00:37:41.600
And we also have codelabs,
which we're pretty happy with.

00:37:41.600 --> 00:37:43.890
And there's more to come.

00:37:43.890 --> 00:37:46.100
So we think we've just
scratched the surface of ways

00:37:46.100 --> 00:37:48.260
that we can improve the
experience of using Android

00:37:48.260 --> 00:37:51.320
Frameworks, and we're looking
at applying this approach

00:37:51.320 --> 00:37:53.310
in other areas as well.

00:37:53.310 --> 00:37:54.980
So some things
already in the works.

00:37:54.980 --> 00:37:58.310
And we're also interested in
hearing from you on what else

00:37:58.310 --> 00:37:59.720
you'd like to see.

00:37:59.720 --> 00:38:04.010
So come by, talk to us, tell us
what you like, what you don't.

00:38:04.010 --> 00:38:06.800
And stay tuned, because we're
really excited about the future

00:38:06.800 --> 00:38:08.570
of Android development.

00:38:08.570 --> 00:38:09.310
Thank you.

00:38:09.310 --> 00:38:11.460
[APPLAUSE]

