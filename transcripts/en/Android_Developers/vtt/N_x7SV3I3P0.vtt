WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:07.420
[MUSIC PLAYING]

00:00:07.420 --> 00:00:10.625
NICK BUTCHER: Hello, and welcome
to the last session of Android

00:00:10.625 --> 00:00:13.360
Dev Summit, or the
ultimate session, I think,

00:00:13.360 --> 00:00:15.130
which is called Get Animated.

00:00:15.130 --> 00:00:16.390
My name is Nick Butcher.

00:00:16.390 --> 00:00:19.880
I am a designer and
engineer here at Google.

00:00:19.880 --> 00:00:23.160
DORIS LIU: My name is Doris,
and I work on the Android UI

00:00:23.160 --> 00:00:23.860
Toolkit team.

00:00:23.860 --> 00:00:26.439
I'm responsible for
Android animation API.

00:00:26.439 --> 00:00:27.980
NICOLAS ROARD: And
I'm Nicolas Roard.

00:00:27.980 --> 00:00:30.820
I'm working on the
design tools [INAUDIBLE],,

00:00:30.820 --> 00:00:32.710
as well as on ConstraintLayout.

00:00:32.710 --> 00:00:35.730
JOHN HOFORD: John Hoford,
working on ConstraintLayout,

00:00:35.730 --> 00:00:38.757
MotionLayout, and design tools.

00:00:38.757 --> 00:00:39.590
NICK BUTCHER: Great.

00:00:39.590 --> 00:00:40.970
So let's get started.

00:00:40.970 --> 00:00:45.460
So Android has always
had animation APIs.

00:00:45.460 --> 00:00:51.190
The number of APIs has grown as
the system has grown and become

00:00:51.190 --> 00:00:53.920
more fully featured.

00:00:53.920 --> 00:00:57.400
There are a variety of different
APIs for different situations

00:00:57.400 --> 00:00:59.930
that have been added over
the different API releases,

00:00:59.930 --> 00:01:04.650
as well as to the new support
libraries like AndroidX.

00:01:04.650 --> 00:01:08.080
But sometimes we hear
that the variety--

00:01:08.080 --> 00:01:10.120
the range of animation systems--

00:01:10.120 --> 00:01:12.430
can be overwhelming,
that you don't

00:01:12.430 --> 00:01:14.470
know which one to
reach for or which

00:01:14.470 --> 00:01:16.480
is the best for a
certain use case.

00:01:16.480 --> 00:01:18.730
So our goal today is
to really give you

00:01:18.730 --> 00:01:21.520
an overview of the
different animation systems,

00:01:21.520 --> 00:01:23.680
tell you what they're good
for, what they might not

00:01:23.680 --> 00:01:25.450
be good for, and give
you the confidence

00:01:25.450 --> 00:01:28.387
to know which to reach for when
you need to achieve something.

00:01:28.387 --> 00:01:30.220
And we're going to spend
a bit of extra time

00:01:30.220 --> 00:01:33.620
on the new hotness that is
MotionLayout today as well.

00:01:33.620 --> 00:01:35.830
So let's dive right in.

00:01:35.830 --> 00:01:39.820
First up is Android's oldest
and original animation API,

00:01:39.820 --> 00:01:42.430
which was AndroidViewAnimation.

00:01:42.430 --> 00:01:46.750
I would urge you to kind
of consider it deprecated.

00:01:46.750 --> 00:01:49.600
Unfortunately, it's not
actually at deprecated,

00:01:49.600 --> 00:01:50.960
as I'll get to in a minute.

00:01:50.960 --> 00:01:53.860
But maybe just think
of it in that way.

00:01:53.860 --> 00:01:58.270
So this, like I say,
an older animation API,

00:01:58.270 --> 00:02:02.470
kind of runs in a certain
phase of the View system.

00:02:02.470 --> 00:02:05.020
So as everyone knows, most views
have like a measure, layout,

00:02:05.020 --> 00:02:06.190
and a draw.

00:02:06.190 --> 00:02:08.259
Unfortunately, because
the animations only

00:02:08.259 --> 00:02:12.231
run in the draw pass,
it means that we

00:02:12.231 --> 00:02:14.230
can't do certain things
like deferring rendering

00:02:14.230 --> 00:02:15.172
when we don't need to.

00:02:15.172 --> 00:02:16.630
And it also leads
to certain things

00:02:16.630 --> 00:02:20.170
where because the animation is
only applied in the draw pass,

00:02:20.170 --> 00:02:23.482
you don't know what it looks
like somewhere in your layout.

00:02:23.482 --> 00:02:25.690
Maybe you've animated a
button to a certain position.

00:02:25.690 --> 00:02:27.490
When you try and press
it, the view's bounds

00:02:27.490 --> 00:02:28.531
haven't actually changed.

00:02:28.531 --> 00:02:30.520
This only exists within
the view system--

00:02:30.520 --> 00:02:31.770
drawing pass system.

00:02:31.770 --> 00:02:34.600
So it can lead to a bunch
of different problems.

00:02:34.600 --> 00:02:37.330
Basically it's been
considered deprecated

00:02:37.330 --> 00:02:40.930
because it has much,
much better replacements.

00:02:40.930 --> 00:02:41.950
It belongs in a museum.

00:02:45.850 --> 00:02:49.270
I'd say deprecated except
there are actually-- well,

00:02:49.270 --> 00:02:52.270
one single use case I can
think of where you still

00:02:52.270 --> 00:02:53.350
have to use it.

00:02:53.350 --> 00:02:56.107
And that is when you are
doing window animations.

00:02:56.107 --> 00:02:57.940
So when you're doing
window animations, when

00:02:57.940 --> 00:03:01.120
a new activity
launches, then this API

00:03:01.120 --> 00:03:03.100
only accepts this type
of window animation.

00:03:03.100 --> 00:03:06.640
Because this existed
from API 1, but also

00:03:06.640 --> 00:03:09.820
because these windowed
animations have

00:03:09.820 --> 00:03:12.520
to declaratively state
all the information

00:03:12.520 --> 00:03:13.840
to perform the animation.

00:03:13.840 --> 00:03:15.340
The fact that it
runs in a draw pass

00:03:15.340 --> 00:03:17.770
is useful because it guarantees
that the view is already

00:03:17.770 --> 00:03:19.390
measured when you do this.

00:03:19.390 --> 00:03:22.660
And that allows it to
define certain things.

00:03:22.660 --> 00:03:25.210
Here, we're seeing a y
delta animation, which

00:03:25.210 --> 00:03:28.226
means 10% of the y position.

00:03:28.226 --> 00:03:30.100
So because it's already
definitely guaranteed

00:03:30.100 --> 00:03:32.590
to be measured,
this can be useful.

00:03:32.590 --> 00:03:34.600
The only other place
you might need to use it

00:03:34.600 --> 00:03:36.860
is if you're doing
fragment transactions.

00:03:36.860 --> 00:03:38.614
So here, when you
set the animations

00:03:38.614 --> 00:03:40.030
to run a fragment
transaction, you

00:03:40.030 --> 00:03:43.810
can supply this
android.view.animation

00:03:43.810 --> 00:03:44.560
as an arg.

00:03:44.560 --> 00:03:49.070
But the API also accepts
the newer Android animator.

00:03:49.070 --> 00:03:53.170
So I urge you to kind of use
the newer one if you can.

00:03:53.170 --> 00:03:54.400
So that was View animations.

00:03:54.400 --> 00:03:58.644
Basically only really use
it for window animations,

00:03:58.644 --> 00:04:00.310
or if you really,
really have to, if you

00:04:00.310 --> 00:04:02.410
need to rely on that measured
size part for a fragment

00:04:02.410 --> 00:04:02.910
animation.

00:04:02.910 --> 00:04:06.080
Otherwise, I think
it's deprecated.

00:04:06.080 --> 00:04:10.345
Next up, animator.

00:04:10.345 --> 00:04:11.220
DORIS LIU: All right.

00:04:16.950 --> 00:04:18.709
All right.

00:04:18.709 --> 00:04:21.160
So Nick has just talked
about View animation.

00:04:21.160 --> 00:04:23.050
Now let's take a
look at the Animator,

00:04:23.050 --> 00:04:27.591
the new animator API that was
introduced in API [? 11. ?]

00:04:27.591 --> 00:04:30.700
So the new Animator API is much
more versatile than the View

00:04:30.700 --> 00:04:34.630
animation because it allows you
to animate more than just view

00:04:34.630 --> 00:04:35.260
properties.

00:04:35.260 --> 00:04:37.630
You can essentially use it
to animate any arbitrary

00:04:37.630 --> 00:04:39.390
property on any object.

00:04:39.390 --> 00:04:42.220
And you can even just
animate any value--

00:04:42.220 --> 00:04:45.940
not necessarily associated
with any property at all--

00:04:45.940 --> 00:04:48.730
using the ValueAnimator API.

00:04:48.730 --> 00:04:51.550
And since the
introduction of Animator,

00:04:51.550 --> 00:04:54.580
we've built a bunch of
higher-level animation

00:04:54.580 --> 00:04:57.070
constructs on top
of the Animator,

00:04:57.070 --> 00:04:59.920
such as AnimatorVectorDrawable,
[? animated ?] [? stateless ?]

00:04:59.920 --> 00:05:05.070
Drawable, transition, and
the default ItemAnimator

00:05:05.070 --> 00:05:08.320
in RecyclerView.

00:05:08.320 --> 00:05:11.770
People always ask me between
Animation and Animator,

00:05:11.770 --> 00:05:14.560
which animation
API should I use?

00:05:14.560 --> 00:05:19.420
And the answer is definitely the
Animator API because it's just

00:05:19.420 --> 00:05:20.685
much more capable.

00:05:20.685 --> 00:05:25.360
And in this section, we're going
to look at a few animators.

00:05:25.360 --> 00:05:27.550
We're going to look at
value animators, where

00:05:27.550 --> 00:05:29.050
you can animate a
value, and we're

00:05:29.050 --> 00:05:32.860
going to look at ObjectAnimator,
which not only animates

00:05:32.860 --> 00:05:37.450
a value, but also automatically
sets that value on a property.

00:05:37.450 --> 00:05:40.555
We're also going to
let animator sets.

00:05:40.555 --> 00:05:42.580
And then we're also
going to take a look

00:05:42.580 --> 00:05:44.110
at the ViewPropertyAnimator.

00:05:44.110 --> 00:05:47.780
It is not an animator, but
it's backed by ValueAnimator.

00:05:47.780 --> 00:05:52.450
We'll talk a little bit
more about that in a minute.

00:05:52.450 --> 00:05:56.060
And then also we're going to
look at PropertyValuesHolder,

00:05:56.060 --> 00:06:00.460
which you can use in
conjunction with ValueAnimator.

00:06:00.460 --> 00:06:03.090
So here is an
interesting animation

00:06:03.090 --> 00:06:05.250
with a little juggling man.

00:06:05.250 --> 00:06:08.770
And that can be achieved
with the double which

00:06:08.770 --> 00:06:12.990
I think we'll talk about in
the next section or you can use

00:06:12.990 --> 00:06:14.390
[INAUDIBLE].

00:06:14.390 --> 00:06:16.200
But now let's look past that.

00:06:16.200 --> 00:06:18.742
And on top of this
little man, there

00:06:18.742 --> 00:06:22.130
are texts being
animated in and out.

00:06:22.130 --> 00:06:25.190
So in order to achieve
that, we can just

00:06:25.190 --> 00:06:29.450
simply create a object animator
to animate the alpha property

00:06:29.450 --> 00:06:30.890
of this view.

00:06:30.890 --> 00:06:31.920
Pretty straightforward.

00:06:31.920 --> 00:06:36.220
Notice how here, I'm
supplying as an alpha string.

00:06:36.220 --> 00:06:41.060
And that is a bad idea because
when the property string is

00:06:41.060 --> 00:06:43.400
being passed to the
ObjectAnimator, what we're

00:06:43.400 --> 00:06:46.460
going to do is we have to
prefix that string with a set

00:06:46.460 --> 00:06:49.670
and get in order to
then use reflection

00:06:49.670 --> 00:06:54.300
to find the setter and getter
in the target objects class.

00:06:54.300 --> 00:06:57.170
And that's inherently
more costly.

00:06:57.170 --> 00:07:02.240
What we recommend instead is
using this view.ALPHA property

00:07:02.240 --> 00:07:02.960
object.

00:07:02.960 --> 00:07:07.070
It is introduced in API
14 along with a bunch

00:07:07.070 --> 00:07:10.550
of other property objects
for other View properties.

00:07:10.550 --> 00:07:12.980
What happens in
this view.ALPHA is

00:07:12.980 --> 00:07:15.740
that whenever the animation
value gets updated,

00:07:15.740 --> 00:07:17.570
the set outlook will be called.

00:07:17.570 --> 00:07:20.346
And then from
there, the set alpha

00:07:20.346 --> 00:07:21.470
will be called on the view.

00:07:21.470 --> 00:07:23.780
So that's one level of
indirection, much more

00:07:23.780 --> 00:07:27.160
efficient than reflection.

00:07:27.160 --> 00:07:29.770
If we take a closer
look at this animation,

00:07:29.770 --> 00:07:33.870
we can see that oh no text
not only animates him,

00:07:33.870 --> 00:07:35.680
but also it blows up.

00:07:35.680 --> 00:07:37.430
So there are three
things going on,

00:07:37.430 --> 00:07:40.500
three properties being
animated-- the alpha, scale X,

00:07:40.500 --> 00:07:42.600
and scale Y.

00:07:42.600 --> 00:07:44.910
Here's how we can do that
with PropertyValuesHolder.

00:07:44.910 --> 00:07:48.710
We can create three
property value holders, one

00:07:48.710 --> 00:07:50.330
for each property,
and then we can

00:07:50.330 --> 00:07:52.400
specify the start
value and the end value

00:07:52.400 --> 00:07:53.870
for each of the property.

00:07:53.870 --> 00:07:56.090
And once we have all
these property values

00:07:56.090 --> 00:07:59.850
holders defined, we can then
set these PropertyValuesHolder

00:07:59.850 --> 00:08:00.890
on the ObjectAnimator.

00:08:00.890 --> 00:08:03.590
So then the
ObjectAnimator can then

00:08:03.590 --> 00:08:07.450
drive the change of
the property values.

00:08:07.450 --> 00:08:11.780
And one caveat is when you
use multiple property value

00:08:11.780 --> 00:08:16.730
holders on one ObjectAnimator,
you are essentially

00:08:16.730 --> 00:08:20.240
animating all these properties
with the same interpolator

00:08:20.240 --> 00:08:24.685
using the same duration
on the same target object.

00:08:24.685 --> 00:08:27.920
But a lot of times, when
you want an animated scale x

00:08:27.920 --> 00:08:33.110
and scale y simultaneously,
that's exactly what you need.

00:08:33.110 --> 00:08:36.900
And if you want to define that
same ObjectAnimator in XML

00:08:36.900 --> 00:08:38.610
with the
PropertyValuesHolder, it

00:08:38.610 --> 00:08:41.452
looks pretty straightforward.

00:08:41.452 --> 00:08:44.490
Now if you take a look at
the bottom of this animation,

00:08:44.490 --> 00:08:47.610
there is that button fading in
after all the text animations

00:08:47.610 --> 00:08:48.900
have finished.

00:08:48.900 --> 00:08:52.410
To coordinate these different
animations together,

00:08:52.410 --> 00:08:54.120
we can just create
animator sets.

00:08:54.120 --> 00:08:58.410
And then with a play
method, it would

00:08:58.410 --> 00:09:00.570
return a AnimatorSet builder.

00:09:00.570 --> 00:09:05.710
And we want to play the
fade in after the fade out.

00:09:05.710 --> 00:09:08.040
And then while the
text is fading in,

00:09:08.040 --> 00:09:09.540
we'll also want to blow it up.

00:09:09.540 --> 00:09:14.790
So we're going to play the fade
in with the scale animation.

00:09:14.790 --> 00:09:16.950
And then we want to play
all the text animations

00:09:16.950 --> 00:09:20.580
before the button fades in.

00:09:20.580 --> 00:09:26.330
So that's pretty straightforward
API, and powerful too.

00:09:26.330 --> 00:09:29.760
Now we've seen how we can
animate various properties

00:09:29.760 --> 00:09:32.070
using PropertyValuesHolder
in conjunction

00:09:32.070 --> 00:09:33.980
with ObjectAnimator.

00:09:33.980 --> 00:09:36.660
And if these properties
that you're animating

00:09:36.660 --> 00:09:38.580
happen to be View
properties, here's

00:09:38.580 --> 00:09:41.002
a more straightforward
way to animate them.

00:09:41.002 --> 00:09:42.960
You can just [? call ?]
[? view ?] the animate.

00:09:42.960 --> 00:09:46.140
That would create a
ViewPropertyAnimator.

00:09:46.140 --> 00:09:50.010
And then there are a bunch of
methods for various properties.

00:09:50.010 --> 00:09:53.550
And then you set a end
value for these properties.

00:09:53.550 --> 00:09:58.260
And then optionally, you can
set an interpolator end start.

00:09:58.260 --> 00:10:00.790
This is the syntax for
ViewPropertyAnimator.

00:10:00.790 --> 00:10:05.325
It doesn't get more beautiful
and concise than this.

00:10:05.325 --> 00:10:09.710
And ViewProperty is backed
by a value Animator.

00:10:09.710 --> 00:10:12.180
It's not an animator,
so you can't really

00:10:12.180 --> 00:10:14.180
coordinate it with the
other types of animators.

00:10:14.180 --> 00:10:17.510
You also can't reverse it
or [? seek ?] or repeat it.

00:10:20.340 --> 00:10:23.520
Some people ask me, is
ViewPropertyAnimator

00:10:23.520 --> 00:10:26.460
as efficient as ObjectAnimator?

00:10:26.460 --> 00:10:29.400
I can assure you it's actually
slightly more efficient

00:10:29.400 --> 00:10:31.280
than ObjectAnimator.

00:10:31.280 --> 00:10:33.780
The reason for that is
ViewPropertyAnimator

00:10:33.780 --> 00:10:36.770
has been optimized for
animating view properties.

00:10:36.770 --> 00:10:41.060
And as a result, it ensures
that for all the view properties

00:10:41.060 --> 00:10:46.470
that you're animating,
only one pass of validation

00:10:46.470 --> 00:10:48.030
gets triggered per frame.

00:10:48.030 --> 00:10:49.890
Whereas if you
use ObjectAnimator

00:10:49.890 --> 00:10:53.850
to animate various properties,
then each property change

00:10:53.850 --> 00:10:57.756
is going to trigger its own set
of your [? validation pass. ?]

00:10:57.756 --> 00:11:03.270
ViewPropertyAnimator
is more for a fire

00:11:03.270 --> 00:11:05.370
and forget kind of use
case, where you just

00:11:05.370 --> 00:11:07.970
start the animation and
just forget about it.

00:11:10.856 --> 00:11:16.120
Now you might have seen
this animation before

00:11:16.120 --> 00:11:19.430
in the previous slides.

00:11:19.430 --> 00:11:22.670
Did you notice that there is
three little dots animating

00:11:22.670 --> 00:11:24.732
at the end of the text?

00:11:24.732 --> 00:11:28.770
And since these three
little dots are not really

00:11:28.770 --> 00:11:32.330
a property for the
text view, so here

00:11:32.330 --> 00:11:35.540
we're going to create a
ValueAnimator to animate

00:11:35.540 --> 00:11:36.680
the number of dots.

00:11:36.680 --> 00:11:39.670
We're going to create a
ValueAnimator of integer type

00:11:39.670 --> 00:11:40.742
to animate from 0 to 4.

00:11:40.742 --> 00:11:42.200
And once it gets
to 4, it will then

00:11:42.200 --> 00:11:46.070
wrap around and restart at 0
because there's a repeat count.

00:11:46.070 --> 00:11:48.290
And with ValueAnimator,
you almost always

00:11:48.290 --> 00:11:51.890
want to use an UpdateListener
because ValueAnimator is just

00:11:51.890 --> 00:11:53.560
going to animate on its own.

00:11:53.560 --> 00:11:56.260
It has no impact to
anything else [? out ?]

00:11:56.260 --> 00:12:02.450
So here, with the
UpdateListener,

00:12:02.450 --> 00:12:07.110
we're going to read the value
out of the ValueAnimator

00:12:07.110 --> 00:12:11.670
and use it as the number of
dots that we want to show.

00:12:11.670 --> 00:12:13.720
And then we're going to
have a SpannableString.

00:12:13.720 --> 00:12:20.620
From the TextView, we're going
to set a transparent foreground

00:12:20.620 --> 00:12:25.880
color span on the dots
that shouldn't be showing.

00:12:25.880 --> 00:12:29.730
And with each
animation update, we

00:12:29.730 --> 00:12:31.810
would update the
number of dots that

00:12:31.810 --> 00:12:35.280
should be showing, and
then correspondingly change

00:12:35.280 --> 00:12:42.070
the range to hide the dots
that we want to not show.

00:12:42.070 --> 00:12:46.721
So to recap, when should we
use what kind of animator?

00:12:46.721 --> 00:12:49.445
ObjectAnimator is kind of
just all-purpose animator

00:12:49.445 --> 00:12:51.820
that, as long as you have a
property you want to animate,

00:12:51.820 --> 00:12:52.875
you can use that.

00:12:52.875 --> 00:12:59.470
ValueAnimator is for animating
a more customized kind

00:12:59.470 --> 00:13:03.050
of animation where you
want to animate this value.

00:13:03.050 --> 00:13:05.460
And then you want to then
use that value to apply it

00:13:05.460 --> 00:13:08.740
to something else in your UI.

00:13:08.740 --> 00:13:11.680
And the ViewPropertyAnimator
is best used

00:13:11.680 --> 00:13:14.320
when you have multiple
view properties

00:13:14.320 --> 00:13:16.480
that you need to
animate simultaneously

00:13:16.480 --> 00:13:19.180
on the same view.

00:13:19.180 --> 00:13:21.900
And because you can't
really coordinate

00:13:21.900 --> 00:13:24.660
this ViewPropertyAnimator
with anything else,

00:13:24.660 --> 00:13:30.060
it's only good for the
fire and forget use case.

00:13:30.060 --> 00:13:32.340
And then PropertyValuesHolder.

00:13:32.340 --> 00:13:38.070
With PropertyValuesHolder, you
can define multiple properties

00:13:38.070 --> 00:13:42.891
and then animate them
using an ObjectAnimator.

00:13:42.891 --> 00:13:46.470
The nice thing about
PropertyValuesHolder compared

00:13:46.470 --> 00:13:50.280
to ViewPropertyAnimator
is that it not only

00:13:50.280 --> 00:13:53.490
allows you to animate multiple
properties simultaneously

00:13:53.490 --> 00:13:56.510
because it's really being
set on the ObjectAnimator.

00:13:56.510 --> 00:14:01.020
You can then coordinate
that or seek and reverse.

00:14:01.020 --> 00:14:02.300
So it's more powerful.

00:14:02.300 --> 00:14:03.180
And then AnimatorSet.

00:14:03.180 --> 00:14:04.910
When you have
multiple animations

00:14:04.910 --> 00:14:07.290
that you want to
coordinate, AnimatorSet

00:14:07.290 --> 00:14:10.480
would be a good choice.

00:14:10.480 --> 00:14:11.920
NICK BUTCHER: Thank
you very much.

00:14:11.920 --> 00:14:14.810
Next up, we've got
Animated Vector Drawable.

00:14:14.810 --> 00:14:17.292
So these are great for doing
vector graphic animations,

00:14:17.292 --> 00:14:19.750
like these wonderful little
icons you see in the new Google

00:14:19.750 --> 00:14:21.750
Fit application.

00:14:21.750 --> 00:14:23.320
Animated Vector
Drawable is actually

00:14:23.320 --> 00:14:25.720
kind of a very thin wrapper
around two more powerful

00:14:25.720 --> 00:14:26.380
things.

00:14:26.380 --> 00:14:29.290
It basically connects
together a vector drawable

00:14:29.290 --> 00:14:31.690
to one or multiple
object animators

00:14:31.690 --> 00:14:33.520
and runs animations on them.

00:14:33.520 --> 00:14:36.750
It has a very kind of
small and focused API.

00:14:36.750 --> 00:14:39.400
And it basically implements
the animatable interface,

00:14:39.400 --> 00:14:41.847
which is basically just lets
you play, pause, and stop

00:14:41.847 --> 00:14:42.430
the animation.

00:14:42.430 --> 00:14:44.179
So you can get an
Animated Vector Drawable

00:14:44.179 --> 00:14:47.042
like this and just call start.

00:14:47.042 --> 00:14:51.330
AVD-- is great for performance
critical and vector graphic

00:14:51.330 --> 00:14:54.000
animation, especially
from Nougat onwards

00:14:54.000 --> 00:14:55.875
where Animated
Vector Drawable was

00:14:55.875 --> 00:14:57.630
re-implemented in native code.

00:14:57.630 --> 00:15:00.280
And also offloaded
to the render thread,

00:15:00.280 --> 00:15:02.790
which means that even if
you're janking the UI thread--

00:15:02.790 --> 00:15:04.240
and you're not doing that--

00:15:04.240 --> 00:15:06.190
that your animation
will keep on playing.

00:15:06.190 --> 00:15:08.634
But it also means that there's
just more [? rent ?] time

00:15:08.634 --> 00:15:10.800
on the thread for you to
do your code rather than it

00:15:10.800 --> 00:15:12.870
running the animation code.

00:15:12.870 --> 00:15:15.660
So when to use Animated
Vector Drawable?

00:15:15.660 --> 00:15:18.300
So when you need to animated
icons or animated vector

00:15:18.300 --> 00:15:19.290
graphics.

00:15:19.290 --> 00:15:21.630
When it needs to be
this fire and forget

00:15:21.630 --> 00:15:24.300
because it has that simple
API that just start and stop.

00:15:24.300 --> 00:15:25.987
And you can't seek through it.

00:15:25.987 --> 00:15:27.570
You can't control
the progress for it.

00:15:27.570 --> 00:15:29.020
If you need to do
something like that,

00:15:29.020 --> 00:15:31.311
then I urge you to take a
look at something like Lottie

00:15:31.311 --> 00:15:34.020
or Kyrie, K-Y-R-I-E Drawable.

00:15:34.020 --> 00:15:36.060
So it's really good
for anything which

00:15:36.060 --> 00:15:38.180
is like performance critical.

00:15:38.180 --> 00:15:40.340
And that was AVD.

00:15:40.340 --> 00:15:43.066
DORIS LIU: Thank you.

00:15:43.066 --> 00:15:44.710
Now physics-based animation.

00:15:44.710 --> 00:15:47.490
Who doesn't love physics, right?

00:15:47.490 --> 00:15:52.030
Physics-based Animation
is perfect for a highly

00:15:52.030 --> 00:15:55.010
interactive use case where you
have lots of gestures going on

00:15:55.010 --> 00:15:59.290
and you want to then carry on
that momentum of the gesture

00:15:59.290 --> 00:16:03.360
into your UI to create
the sense of continuity.

00:16:03.360 --> 00:16:08.400
And because when there are
a lot of gestures in flight,

00:16:08.400 --> 00:16:10.570
you could then
potentially interrupt

00:16:10.570 --> 00:16:12.430
the existing ongoing animation.

00:16:12.430 --> 00:16:18.820
I'm sure you've seen animations
where you want the view to move

00:16:18.820 --> 00:16:20.860
from one location to the other.

00:16:20.860 --> 00:16:25.120
And then there is gesture from
the users, and then as a result

00:16:25.120 --> 00:16:28.730
the ending location
would have changed.

00:16:28.730 --> 00:16:32.080
And in this case, if you
use Physics-based Animation,

00:16:32.080 --> 00:16:36.310
that would just simply
change some physics for us.

00:16:36.310 --> 00:16:39.640
And then as a result,
the course correction

00:16:39.640 --> 00:16:40.720
would be very smooth.

00:16:40.720 --> 00:16:43.780
And it also gives your
app a more realistic look.

00:16:43.780 --> 00:16:50.290
So here I have an example
of this little bubble

00:16:50.290 --> 00:16:52.420
with my cat's picture on it.

00:16:52.420 --> 00:16:56.320
And it's in a application
overlay window.

00:16:56.320 --> 00:17:00.040
So it sits on top of
other applications.

00:17:00.040 --> 00:17:04.599
And in this case, that is
the beautiful timely app.

00:17:04.599 --> 00:17:07.240
My goal is as I drag this
little bubble around,

00:17:07.240 --> 00:17:08.589
I want it to follow my finger.

00:17:08.589 --> 00:17:10.810
And then when I let
go, it should rest

00:17:10.810 --> 00:17:12.069
on either side of the screen.

00:17:15.261 --> 00:17:17.010
So to achieve this,
we obviously need

00:17:17.010 --> 00:17:20.579
to start with an OnTouchListner.

00:17:20.579 --> 00:17:22.470
And then we're going
to use velocity tracker

00:17:22.470 --> 00:17:24.240
to track the movement.

00:17:24.240 --> 00:17:25.859
And then when
there's action down,

00:17:25.859 --> 00:17:27.640
we need to record a
bunch of positions.

00:17:27.640 --> 00:17:29.820
And in the subsequent
move events,

00:17:29.820 --> 00:17:35.070
we're going to need to calculate
how much your finger has moved

00:17:35.070 --> 00:17:38.280
since that [INAUDIBLE] event
and then update the bubble's

00:17:38.280 --> 00:17:40.190
position accordingly.

00:17:40.190 --> 00:17:42.830
And then when there's
[? action ?] [? up, ?]

00:17:42.830 --> 00:17:46.000
that's where the interesting
[? base ?] come in.

00:17:46.000 --> 00:17:49.871
We're going to calculate the
velocity from the Velocity

00:17:49.871 --> 00:17:50.370
Tracker.

00:17:50.370 --> 00:17:57.420
And then here, for
simplification for the demo,

00:17:57.420 --> 00:18:00.180
we're just going to say when
the velocity is greater than 0,

00:18:00.180 --> 00:18:03.450
we're going to just move to
the right side of the screen,

00:18:03.450 --> 00:18:04.770
otherwise left side.

00:18:04.770 --> 00:18:07.380
Now, now that we have the
final position where we want

00:18:07.380 --> 00:18:10.170
the bubble to rest on, we
can create a spring animation

00:18:10.170 --> 00:18:13.650
to animate that bubble's
[? parem ?] [? x prop. ?] That

00:18:13.650 --> 00:18:17.490
is a custom property, which
I'll explain in the next slide.

00:18:17.490 --> 00:18:19.360
Now, before we
start the animation,

00:18:19.360 --> 00:18:21.750
we'll also want to set
the start velocity.

00:18:21.750 --> 00:18:25.410
And this is critical to
ensure that that transition

00:18:25.410 --> 00:18:27.990
from gesture to the
animation is seamless.

00:18:30.665 --> 00:18:32.650
So this is my custom property.

00:18:32.650 --> 00:18:35.110
And the whole point of
this custom property

00:18:35.110 --> 00:18:38.290
is really just to associate
the animation value

00:18:38.290 --> 00:18:41.590
with the position of the bubble.

00:18:41.590 --> 00:18:45.080
Whenever the animation
value changes,

00:18:45.080 --> 00:18:46.390
we get this set value call.

00:18:46.390 --> 00:18:50.100
We're then going to set
that animation value

00:18:50.100 --> 00:18:56.325
onto the [? primes ?] the x
because the view is animating

00:18:56.325 --> 00:18:59.500
in a application overlay window.

00:18:59.500 --> 00:19:03.310
And then we're going to have
the Window Manager update View

00:19:03.310 --> 00:19:05.300
layout to reflect the change.

00:19:05.300 --> 00:19:08.220
And similarly, in
[? get ?] value,

00:19:08.220 --> 00:19:14.480
we're just going to return
the [? LayoutFrames.x. ?]

00:19:14.480 --> 00:19:15.480
NICK BUTCHER: Thank you.

00:19:15.480 --> 00:19:18.360
Next up is the transitions API.

00:19:18.360 --> 00:19:20.630
Now transitions are
really about looking

00:19:20.630 --> 00:19:24.669
at two different layouts
states and saying

00:19:24.669 --> 00:19:26.210
what has changed
between them and how

00:19:26.210 --> 00:19:29.300
do I create an animation
to animate those changes.

00:19:29.300 --> 00:19:31.040
So really you can
think of transitions

00:19:31.040 --> 00:19:33.470
as like a factory for
creating animators

00:19:33.470 --> 00:19:35.977
based on those two inputs.

00:19:35.977 --> 00:19:38.060
A while ago, I might have
stood up here and talked

00:19:38.060 --> 00:19:40.601
about how it's great for doing
things like this where you can

00:19:40.601 --> 00:19:42.620
have two different
constraint sets

00:19:42.620 --> 00:19:44.020
and using Transition Manager.

00:19:44.020 --> 00:19:45.770
But I think that this
use case is actually

00:19:45.770 --> 00:19:47.480
better solved by MotionLayout.

00:19:47.480 --> 00:19:49.849
So I wouldn't consider
this a good use anymore.

00:19:49.849 --> 00:19:51.890
It does still have some
good things going for it.

00:19:51.890 --> 00:19:53.348
In particular, this
is probably one

00:19:53.348 --> 00:19:56.210
of my absolute favorite Android
APIs, Transition Manager

00:19:56.210 --> 00:19:57.200
beginDelayedTransition.

00:19:57.200 --> 00:19:59.420
It's deceptively simple,
but you call this,

00:19:59.420 --> 00:20:02.100
and then you make some changes
to the view hierarchy and magic

00:20:02.100 --> 00:20:02.600
happens.

00:20:02.600 --> 00:20:05.689
And that magic is exactly
what we just talked about.

00:20:05.689 --> 00:20:07.730
It looks at those two
different states of the UI,

00:20:07.730 --> 00:20:09.950
works out what's changed,
creates an animator,

00:20:09.950 --> 00:20:11.330
runs those animations.

00:20:11.330 --> 00:20:12.020
So simple.

00:20:12.020 --> 00:20:13.436
There is also an
overlay where you

00:20:13.436 --> 00:20:14.742
can control those transitions.

00:20:14.742 --> 00:20:16.700
The other thing I really
love about transitions

00:20:16.700 --> 00:20:19.682
is what it does to the
shape of your code base.

00:20:19.682 --> 00:20:21.140
So, for example,
here is the change

00:20:21.140 --> 00:20:23.900
where I moved a bunch of
code out of the View layer

00:20:23.900 --> 00:20:25.130
and into transitions.

00:20:25.130 --> 00:20:27.542
So when you're doing
animation, sometimes your code

00:20:27.542 --> 00:20:29.000
could look a bit
gnarly, like this.

00:20:29.000 --> 00:20:30.770
So you're doing a lot
of View look-up stuff,

00:20:30.770 --> 00:20:32.728
[? predraw ?] listeners,
and like poking around

00:20:32.728 --> 00:20:34.330
to the view hierarchy.

00:20:34.330 --> 00:20:36.140
By moving it to
transitions, we end up

00:20:36.140 --> 00:20:38.990
moving it to this much more kind
of like declarative composable

00:20:38.990 --> 00:20:39.800
architecture.

00:20:39.800 --> 00:20:42.550
So here I'm using some
custom transitions I wrote--

00:20:42.550 --> 00:20:45.050
as well as composed with some
of the framework transitions--

00:20:45.050 --> 00:20:46.633
in order to achieve
the same behavior,

00:20:46.633 --> 00:20:48.750
but in it's more
composable manner.

00:20:48.750 --> 00:20:51.950
So, yes, you might have to
write some transitions yourself.

00:20:51.950 --> 00:20:54.260
So here's one I had to
write to do a circular view.

00:20:54.260 --> 00:21:00.080
But that code ends up being
much more nicer to work with,

00:21:00.080 --> 00:21:01.220
and much more focused.

00:21:01.220 --> 00:21:04.920
And I find it a really good
change to the code base.

00:21:04.920 --> 00:21:06.890
So transitions, when
should you use them?

00:21:06.890 --> 00:21:09.171
For me, there's actually
one really strong use case,

00:21:09.171 --> 00:21:11.420
which is shared element
transitions between activities

00:21:11.420 --> 00:21:12.590
or fragments.

00:21:12.590 --> 00:21:14.630
So it's pretty
much the only thing

00:21:14.630 --> 00:21:16.550
you can use to achieve
this, unless you

00:21:16.550 --> 00:21:17.750
go like super custom.

00:21:17.750 --> 00:21:20.232
So that is the use
case for transitions.

00:21:20.232 --> 00:21:22.190
There's actually two
transitions going on here.

00:21:22.190 --> 00:21:23.773
There's the
[? SharedElement, ?] which

00:21:23.773 --> 00:21:25.720
is between the two
activities we see here.

00:21:25.720 --> 00:21:27.860
And then once the
[? DetailsActivity ?] launches,

00:21:27.860 --> 00:21:30.290
there's actually a window
content transition,

00:21:30.290 --> 00:21:31.910
which is when the
window launches

00:21:31.910 --> 00:21:34.341
or when it exits,
run this transition,

00:21:34.341 --> 00:21:35.840
run these animations
on the content.

00:21:35.840 --> 00:21:37.790
So when you see it come in
here, when the view arrives,

00:21:37.790 --> 00:21:39.800
the rest of the content
animates upwards.

00:21:39.800 --> 00:21:42.612
That's a window
content transition.

00:21:42.612 --> 00:21:44.977
So when should you
use transition API?

00:21:44.977 --> 00:21:47.310
So shared elements for me is
a really, really strong use

00:21:47.310 --> 00:21:50.820
case, window content,
and enter and exit.

00:21:50.820 --> 00:21:53.550
Also if you're really looking
to like modularize and compose

00:21:53.550 --> 00:21:55.350
your animation code,
then transitions

00:21:55.350 --> 00:21:57.750
could be really helpful,
as well as simple changes

00:21:57.750 --> 00:21:59.150
using that beginDelayed method.

00:21:59.150 --> 00:22:03.201
So transitions definitely
still have a use case.

00:22:03.201 --> 00:22:06.029
Motion Layouts.

00:22:06.029 --> 00:22:07.070
NICOLAS ROARD: All right.

00:22:07.070 --> 00:22:11.160
So, so far we've been
talking a lot about coding.

00:22:11.160 --> 00:22:14.090
And the nice thing with coding
is that it's super powerful.

00:22:14.090 --> 00:22:15.380
You can do a lot of things.

00:22:15.380 --> 00:22:18.140
The APIs are really,
really complete.

00:22:18.140 --> 00:22:20.830
On the other hand, it's
also quite time consuming.

00:22:20.830 --> 00:22:23.860
So taking my hat [? in order ?]
to do [? this ?] [? and ?]

00:22:23.860 --> 00:22:26.330
[? to ?] [? steam, ?] what
can we do to help that?

00:22:26.330 --> 00:22:28.730
Really, our goal is to
make you more productive,

00:22:28.730 --> 00:22:31.460
let you iterate
faster, experiment,

00:22:31.460 --> 00:22:33.050
and make your life
easier really.

00:22:33.050 --> 00:22:36.570
So we want to make
[INAUDIBLE] motion.

00:22:36.570 --> 00:22:39.990
We want to make the motion
design a lot more accessible.

00:22:39.990 --> 00:22:42.980
So one thing that we introduced
recently in ConstraintLayout

00:22:42.980 --> 00:22:46.490
2.0 is the Helpers object.

00:22:46.490 --> 00:22:49.070
And in fact Helpers
object is something

00:22:49.070 --> 00:22:52.100
that you've been using if you've
used ConstraintLayout before.

00:22:52.100 --> 00:22:54.290
That's what we use for
Guidelines, for Barriers,

00:22:54.290 --> 00:22:58.730
for these kind of tools that are
not really part of your view--

00:22:58.730 --> 00:23:01.130
your hierarchy-- in
the sense that they

00:23:01.130 --> 00:23:02.330
don't show up on screen.

00:23:02.330 --> 00:23:04.720
But they are here to help
you create those layouts.

00:23:04.720 --> 00:23:08.700
So to basically bring additional
concepts to make it easier.

00:23:08.700 --> 00:23:12.510
And in 2.0, we expose
them completely.

00:23:12.510 --> 00:23:16.740
So you can yourself create
helpers just by [? reaching ?]

00:23:16.740 --> 00:23:17.570
the class.

00:23:17.570 --> 00:23:19.190
And what is great
is that it's a way

00:23:19.190 --> 00:23:23.540
of encapsulating a behavior in
code and putting into a helper.

00:23:23.540 --> 00:23:25.570
We support the use of
[? first ?] [? in ?]

00:23:25.570 --> 00:23:28.300
[? order. ?] So it's very easy
to add the widget to those

00:23:28.300 --> 00:23:32.090
helpers to help us reference
those widgets And you can think

00:23:32.090 --> 00:23:37.640
about it as a way of tagging
those widgets with a specific

00:23:37.640 --> 00:23:38.270
behavior.

00:23:38.270 --> 00:23:39.830
So in this case of
animation, that's

00:23:39.830 --> 00:23:43.430
really nice because
you get the code,

00:23:43.430 --> 00:23:45.870
you had your helper built
on top of this code.

00:23:45.870 --> 00:23:49.710
And we got all the wealth of
the Android animation APIs.

00:23:49.710 --> 00:23:51.170
And you can do stuff like that.

00:23:51.170 --> 00:23:56.210
So for example Circular Reveal,
pretty well known animation.

00:23:56.210 --> 00:23:58.130
The only thing I really
needed to do here

00:23:58.130 --> 00:23:59.690
is to define this piece of code.

00:23:59.690 --> 00:24:01.520
And really what
I'm talking about--

00:24:04.930 --> 00:24:10.010
what I only need to do here
is this code that you see

00:24:10.010 --> 00:24:11.810
on the screen,
I'm simply cutting

00:24:11.810 --> 00:24:14.540
the [? view animation utils ?]
[? create ?] [INAUDIBLE]..

00:24:14.540 --> 00:24:16.340
So I'm not reinventing
the wheel here.

00:24:16.340 --> 00:24:21.140
I'm not coming up with my new
way of doing Circular Reveal.

00:24:21.140 --> 00:24:23.510
But that's the only thing
I need to do for my helper.

00:24:23.510 --> 00:24:25.970
And then in your
layout file, you only

00:24:25.970 --> 00:24:29.900
need to declare that
helper and specify

00:24:29.900 --> 00:24:33.550
the IDs of the widgets
you want to apply to.

00:24:33.550 --> 00:24:36.680
So it makes basically--

00:24:36.680 --> 00:24:41.970
it's a lot easier for you to
package blocks of reusable code

00:24:41.970 --> 00:24:45.630
and use them in
your application.

00:24:45.630 --> 00:24:47.540
So going back to the code stuff.

00:24:47.540 --> 00:24:52.730
So the other way that we thought
about making your life easier,

00:24:52.730 --> 00:24:54.950
[? young ?] letting you
build [? those ?] reusable

00:24:54.950 --> 00:25:00.530
[? bricks ?] is by moving to a
declarative way for animation.

00:25:00.530 --> 00:25:05.070
So you can think about it as
a specification for motion.

00:25:05.070 --> 00:25:07.730
And we interpret
this specification

00:25:07.730 --> 00:25:09.070
with a motion engine.

00:25:09.070 --> 00:25:11.840
And on top of that,
we are building

00:25:11.840 --> 00:25:13.490
a graphic called Motion Editor.

00:25:13.490 --> 00:25:16.400
So it's something we
introduced at Google I/O.

00:25:16.400 --> 00:25:17.880
We are still working on it.

00:25:17.880 --> 00:25:20.794
We decided to focus those last
few months on the library side

00:25:20.794 --> 00:25:23.210
[? simply ?] [? implement ?]
this motion engine because we

00:25:23.210 --> 00:25:25.970
kind of want to make sure
that it's right for you

00:25:25.970 --> 00:25:28.130
and for your [INAUDIBLE].

00:25:28.130 --> 00:25:32.060
Just a quick overview
on the current build.

00:25:32.060 --> 00:25:35.990
It's coming along, and hopefully
it will come soon in a kind

00:25:35.990 --> 00:25:37.990
of [? reversion ?] of
[? Android ?] [? Studio ?]

00:25:37.990 --> 00:25:39.650
But essentially we
want to make sure

00:25:39.650 --> 00:25:43.220
that the concept in the
library is right before kind

00:25:43.220 --> 00:25:44.510
of releasing the tool.

00:25:44.510 --> 00:25:48.950
So that's the overall approach
we have for helping you.

00:25:48.950 --> 00:25:52.730
So the help out on one hand
and this motion specification

00:25:52.730 --> 00:25:54.320
on the other.

00:25:54.320 --> 00:25:59.690
The thing that's kind of nice,
if I look at this in particular

00:25:59.690 --> 00:26:03.380
is that you can
specify this motion

00:26:03.380 --> 00:26:05.300
and we'll then take care of it.

00:26:05.300 --> 00:26:07.970
You don't really have
to write code for it.

00:26:07.970 --> 00:26:10.760
It's really completely
declarative.

00:26:10.760 --> 00:26:14.330
So the one way right now that
we implemented this motion spec

00:26:14.330 --> 00:26:15.920
is through MotionLayout.

00:26:15.920 --> 00:26:17.655
So what is MotionLayout?

00:26:17.655 --> 00:26:18.950
It's a View group.

00:26:18.950 --> 00:26:21.500
So one caveat is that
it means you can only

00:26:21.500 --> 00:26:24.435
animate the children
of that View group.

00:26:24.435 --> 00:26:26.060
And it's a surplus
of ConstraintLayout.

00:26:26.060 --> 00:26:27.935
So if you know
ConstraintLayout that's great.

00:26:27.935 --> 00:26:30.230
You can directly
use MotionLayout

00:26:30.230 --> 00:26:32.679
to animate your existing
constraint layouts.

00:26:32.679 --> 00:26:34.220
On the flip side,
you do have to know

00:26:34.220 --> 00:26:35.900
how to use ConstraintLayout.

00:26:35.900 --> 00:26:37.250
But it does a lot.

00:26:37.250 --> 00:26:39.530
So we do layout transitions.

00:26:39.530 --> 00:26:42.330
We interpolate
properties as well.

00:26:42.330 --> 00:26:44.630
We have a really
powerful support

00:26:44.630 --> 00:26:47.300
for touch-driven motion.

00:26:47.300 --> 00:26:51.020
So it's kind of like taking
a little bit of values

00:26:51.020 --> 00:26:56.150
areas of animation and packaging
it into a single place.

00:26:56.150 --> 00:26:59.690
So roughly speaking, the only
thing you have to understand

00:26:59.690 --> 00:27:03.020
is we are animating
between two states.

00:27:03.020 --> 00:27:05.663
We have a start state
and an end state.

00:27:05.663 --> 00:27:08.670
And we just interpolate
between those two things.

00:27:08.670 --> 00:27:14.580
So in addition to basically
supporting layout changes--

00:27:14.580 --> 00:27:17.310
so essentially we have two
versions of the layout to go

00:27:17.310 --> 00:27:18.680
from one to another--

00:27:18.680 --> 00:27:22.590
we also support
custom properties.

00:27:22.590 --> 00:27:24.770
So for example, if you
want to animate colors.

00:27:24.770 --> 00:27:27.036
And we also support the
concept of key frames.

00:27:27.036 --> 00:27:28.410
And you can think
about key frame

00:27:28.410 --> 00:27:33.600
as essentially a modifier
on that transform

00:27:33.600 --> 00:27:36.210
between the start and the end.

00:27:36.210 --> 00:27:40.530
So to kind of summarize,
we have MotionLayout.

00:27:40.530 --> 00:27:43.440
It allows you to think
about your animation,

00:27:43.440 --> 00:27:46.710
your transition, your
motion as a declaration.

00:27:46.710 --> 00:27:51.130
You just specify what it should
do and we take care of it.

00:27:51.130 --> 00:27:53.250
It specifically
is great when you

00:27:53.250 --> 00:27:55.590
want to do fine-tuned
animation-- what

00:27:55.590 --> 00:28:00.450
we call like bespoke motion.

00:28:00.450 --> 00:28:02.680
It's very specific
what you want to do.

00:28:02.680 --> 00:28:04.680
It's about coordinating
a bunch of widgets

00:28:04.680 --> 00:28:06.700
together in a very specific way.

00:28:06.700 --> 00:28:08.580
And finally, it's
really nice as well

00:28:08.580 --> 00:28:10.200
for the touch-driven motion.

00:28:14.039 --> 00:28:15.830
JOHN HOFORD: I don't
think I need the mike.

00:28:20.610 --> 00:28:25.340
So I want to just kind of like
show you guys a lot of things.

00:28:25.340 --> 00:28:29.560
And it'll be a little more
visual from here on in.

00:28:29.560 --> 00:28:35.290
So this is where you want to
create a carefully crafted,

00:28:35.290 --> 00:28:44.440
custom, coordinated, crazy
cool animation that you

00:28:44.440 --> 00:28:45.720
could do stuff like that.

00:28:52.250 --> 00:28:54.590
So how did we do that?

00:28:54.590 --> 00:29:00.830
It's just two chains that
change into one chain.

00:29:00.830 --> 00:29:02.830
And each letter is a view.

00:29:02.830 --> 00:29:06.680
And then we use a stagger and
a color change and a custom

00:29:06.680 --> 00:29:07.460
attribute.

00:29:07.460 --> 00:29:09.380
It's fairly simple to build.

00:29:09.380 --> 00:29:12.420
It took me a few minutes,
and it looks cool.

00:29:12.420 --> 00:29:16.484
And that's kind of what
this stuff is all about.

00:29:16.484 --> 00:29:21.000
So the first thing, you can
drag our stuff with touch.

00:29:21.000 --> 00:29:23.400
Essentially it
will handle swipes.

00:29:23.400 --> 00:29:26.290
If you flick, it will
go across quickly.

00:29:26.290 --> 00:29:32.230
It understands the
velocity and manages that.

00:29:32.230 --> 00:29:34.590
The next thing to
understand is we're

00:29:34.590 --> 00:29:38.310
starting from two constraint
sets, but we have key frames.

00:29:38.310 --> 00:29:41.220
And in this case here, I am
starting with two constraint

00:29:41.220 --> 00:29:44.430
sets and I'm not
having any key frames.

00:29:44.430 --> 00:29:47.160
And you see how it
crosses right there.

00:29:47.160 --> 00:29:49.090
Right there they overlap.

00:29:49.090 --> 00:29:54.540
So what you do is you add
some key position key frames,

00:29:54.540 --> 00:29:57.040
and you accelerate in the x.

00:29:57.040 --> 00:30:00.620
You finish the x part of
the motion halfway through,

00:30:00.620 --> 00:30:05.720
and that gives you
a kind of smooth--

00:30:05.720 --> 00:30:06.480
you've seen this.

00:30:06.480 --> 00:30:07.700
It's your Settings menu.

00:30:10.650 --> 00:30:15.330
So the more extreme end of
what we can do with key frames

00:30:15.330 --> 00:30:16.590
are key cycles.

00:30:16.590 --> 00:30:19.440
And here you can see a bunch
of different kind of effects

00:30:19.440 --> 00:30:20.940
that we can do.

00:30:20.940 --> 00:30:23.940
Essentially, anything that's
oscillating-- it's shaking

00:30:23.940 --> 00:30:25.710
or it's bouncing around.

00:30:25.710 --> 00:30:28.140
You don't want to
actually go and build out

00:30:28.140 --> 00:30:30.480
complex paths with key frames.

00:30:30.480 --> 00:30:31.960
This solves it.

00:30:31.960 --> 00:30:36.030
And then in alpha 2 we
introduced time cycles.

00:30:36.030 --> 00:30:37.830
And this is a kind
of a crazy animation

00:30:37.830 --> 00:30:40.630
that you can do with it.

00:30:40.630 --> 00:30:42.870
Of course, this is
way too over the top,

00:30:42.870 --> 00:30:45.225
and please don't
use this in product.

00:30:50.340 --> 00:30:53.865
So let's get into how to use it.

00:30:53.865 --> 00:30:54.740
NICOLAS ROARD: Right.

00:30:54.740 --> 00:30:58.530
So thank you.

00:30:58.530 --> 00:31:01.980
So first of all, there is
a bunch of documentation

00:31:01.980 --> 00:31:03.180
that we created.

00:31:03.180 --> 00:31:05.190
So I'm going to pass
quickly, but please

00:31:05.190 --> 00:31:06.200
look at those article.

00:31:06.200 --> 00:31:08.820
There's also a GitHub with
examples, so look at that.

00:31:08.820 --> 00:31:12.240
But one thing you
may ask yourself

00:31:12.240 --> 00:31:13.600
is that, OK, this is all great.

00:31:13.600 --> 00:31:15.850
But how do I use that
in my application?

00:31:15.850 --> 00:31:17.820
Do I have to restart
everything from scratch?

00:31:17.820 --> 00:31:18.470
Not quite.

00:31:18.470 --> 00:31:22.185
This is an example here where
you have a collapsible toolbar

00:31:22.185 --> 00:31:24.255
and a CoordinatorLayout.

00:31:24.255 --> 00:31:27.207
And to do these kind of things
with the normal collapsible

00:31:27.207 --> 00:31:28.290
toolbar is a bit annoying.

00:31:28.290 --> 00:31:30.290
You have to do it in code,
et cetera, et cetera.

00:31:30.290 --> 00:31:33.670
You can simply use
MotionLayout instead.

00:31:33.670 --> 00:31:35.129
So you still use
CoordinatorLayout.

00:31:35.129 --> 00:31:37.253
You don't really change
anything else in your code,

00:31:37.253 --> 00:31:39.530
but the collapsible toolbar
becomes a MotionLayout

00:31:39.530 --> 00:31:42.670
and take all the
advantages of it.

00:31:42.670 --> 00:31:44.740
Similarly, if you
have a DrawerLayout,

00:31:44.740 --> 00:31:46.698
you don't have to use
them in your [? class. ?]

00:31:46.698 --> 00:31:50.550
You can use a MotionLayout
for it and do anything crazy.

00:31:50.550 --> 00:31:52.560
Same thing for ViewPager.

00:31:52.560 --> 00:31:56.350
You can easily plug
MotionLayout into it.

00:31:56.350 --> 00:31:59.260
The last example is interesting.

00:31:59.260 --> 00:32:01.480
It really looks like
CoordinatorLayout.

00:32:01.480 --> 00:32:04.600
But actually this is
pure MotionLayout.

00:32:04.600 --> 00:32:07.810
And what's nice about
it is that it actually

00:32:07.810 --> 00:32:10.840
is two MotionLayouts nested.

00:32:10.840 --> 00:32:13.330
And we have one for the
collapsible toolbar.

00:32:13.330 --> 00:32:16.510
In fact, it's exactly the
same one I used before

00:32:16.510 --> 00:32:19.220
for the [? conduit ?]
[? layout ?] example.

00:32:19.220 --> 00:32:22.390
And it's simply nested into
an [? outer ?] MotionLayout.

00:32:22.390 --> 00:32:25.330
And what's really
nice is that in order

00:32:25.330 --> 00:32:30.340
to specify how this
overall screen behaves,

00:32:30.340 --> 00:32:33.680
I just need to create those
two states, the start and end.

00:32:33.680 --> 00:32:36.130
You see that in the end
I bring up a [? fab ?]

00:32:36.130 --> 00:32:40.210
and I simply make the
MotionLayout that's

00:32:40.210 --> 00:32:42.130
for the toolbar
a little smaller.

00:32:42.130 --> 00:32:45.010
And basically we take
care of all of it.

00:32:45.010 --> 00:32:47.760
So to summarize for
the current states,

00:32:47.760 --> 00:32:50.350
we are still working on
the graphical editor.

00:32:50.350 --> 00:32:54.910
But for the library, we released
it already at Google I/O.

00:32:54.910 --> 00:32:58.592
And since then we did an alpha
2 with a few more properties.

00:32:58.592 --> 00:33:01.480
And even [? putting in ?]
alpha, it's

00:33:01.480 --> 00:33:03.260
actually built upon
ConstraintLayout 1.1.

00:33:03.260 --> 00:33:06.440
So it's actually pretty stable.

00:33:06.440 --> 00:33:09.010
And in fact, because
it's pretty stable,

00:33:09.010 --> 00:33:12.340
quite a few people started
to build stuff with it.

00:33:12.340 --> 00:33:14.170
And we'll go through
some examples just

00:33:14.170 --> 00:33:16.540
to give you a
little taste of what

00:33:16.540 --> 00:33:20.706
you can do with MotionLayout.

00:33:20.706 --> 00:33:24.580
JOHN HOFORD: So I looked
on the Twitter a lot.

00:33:24.580 --> 00:33:27.350
I checked MotionLayout
on Twitter all the time.

00:33:27.350 --> 00:33:31.570
And I thought I would just share
a few interesting animations

00:33:31.570 --> 00:33:34.030
that people have published.

00:33:34.030 --> 00:33:38.700
So most of these you can
actually find in GitHub.

00:33:38.700 --> 00:33:41.740
These people publish
them as videos,

00:33:41.740 --> 00:33:44.920
and I've asked all of
them to sort of show them.

00:33:44.920 --> 00:33:48.740
This guy has been doing quite
a few pieces of work with it.

00:33:48.740 --> 00:33:51.580
It's kind of interesting
to see what he did here.

00:33:51.580 --> 00:33:54.172
NICOLAS ROARD: And this one
is particularly interesting.

00:33:54.172 --> 00:33:56.130
By the way, [? we did ?]
[? not ?] maybe notice

00:33:56.130 --> 00:33:58.755
in the previous one, there was
a [? knock ?] [? motion ?] which

00:33:58.755 --> 00:34:01.120
is very nice, something we
[? didn't ?] [? refer ?] to.

00:34:01.120 --> 00:34:03.310
But in this particular
example, what's

00:34:03.310 --> 00:34:06.360
nice is that it's kind
of like a [? View ?]

00:34:06.360 --> 00:34:08.139
He did it in
MotionLayout, but he also

00:34:08.139 --> 00:34:11.710
added a way to
drive it from code.

00:34:11.710 --> 00:34:16.960
And that's a very interesting
future avenue for us.

00:34:16.960 --> 00:34:18.830
We're going to explore
it a little bit.

00:34:18.830 --> 00:34:22.504
How can you, in code, reuse
some of this previously defined

00:34:22.504 --> 00:34:23.004
behavior?

00:34:25.535 --> 00:34:27.690
JOHN HOFORD: So
another one by him.

00:34:27.690 --> 00:34:29.610
The interesting
thing here, it's sort

00:34:29.610 --> 00:34:34.860
of mixing what is a normal
RecyclerView and then sort

00:34:34.860 --> 00:34:38.340
of a reveal detailed view.

00:34:38.340 --> 00:34:41.280
But it's an interesting
MotionLayout based animation

00:34:41.280 --> 00:34:42.695
between the two of them.

00:34:42.695 --> 00:34:44.320
NICOLAS ROARD: And
you notice that it's

00:34:44.320 --> 00:34:46.719
super easy to come up with
your own ways of doing

00:34:46.719 --> 00:34:47.830
these kind of transitions.

00:34:47.830 --> 00:34:51.340
You're not limited anymore.

00:34:51.340 --> 00:34:56.710
JOHN HOFORD: This guy
implemented a material design

00:34:56.710 --> 00:35:00.730
automation spec, but just
using MotionLayout and a custom

00:35:00.730 --> 00:35:06.370
view that he built. It was quite
nice piece of work actually.

00:35:06.370 --> 00:35:10.500
One of the things I liked about
this one is it's so original.

00:35:10.500 --> 00:35:13.690
You see a [? View ?] pages.

00:35:13.690 --> 00:35:15.850
This is like taking a
whole new twist on it,

00:35:15.850 --> 00:35:17.250
or spin on it actually.

00:35:22.650 --> 00:35:24.520
But you could see its original.

00:35:24.520 --> 00:35:27.010
And that's the beauty
of a MotionLayout.

00:35:27.010 --> 00:35:29.530
You can sort of explore
your own creativity

00:35:29.530 --> 00:35:32.950
or your team's creativity
with what they like

00:35:32.950 --> 00:35:33.760
and what they do.

00:35:37.640 --> 00:35:39.820
This one is interesting
because it's

00:35:39.820 --> 00:35:43.990
kind of like a typical
CoordinatorLayout stuff.

00:35:43.990 --> 00:35:46.240
But you see it's
transparent, and there's

00:35:46.240 --> 00:35:48.370
some special effects
going on with things

00:35:48.370 --> 00:35:50.410
fitting in as it's collapsing.

00:35:50.410 --> 00:35:56.570
It sort of produces a unique
Custom View of the whole thing.

00:35:56.570 --> 00:35:57.945
And this is our Chris Banes.

00:36:01.180 --> 00:36:05.110
And he did a very
interesting one.

00:36:05.110 --> 00:36:06.410
And it's a whole app.

00:36:06.410 --> 00:36:10.510
It's actually all the codes
involved that is out there.

00:36:10.510 --> 00:36:13.810
And it is very custom.

00:36:13.810 --> 00:36:16.680
So let's take a little
closer look at it.

00:36:16.680 --> 00:36:18.860
NICOLAS ROARD: So
what's great with it is

00:36:18.860 --> 00:36:21.230
this is the type of
motion that would

00:36:21.230 --> 00:36:23.750
be kind of [? fun ?]
to build purely by code

00:36:23.750 --> 00:36:27.410
because there is a lot of
subtle coordination across so

00:36:27.410 --> 00:36:28.370
many elements.

00:36:28.370 --> 00:36:29.900
The text is fading.

00:36:29.900 --> 00:36:32.750
That poster is actually
rotating but actually

00:36:32.750 --> 00:36:35.600
matching the [? young girl ?]
of the [INAUDIBLE]..

00:36:35.600 --> 00:36:38.720
So that's what we
mean when we are

00:36:38.720 --> 00:36:41.980
talking about bespoke
motion, or very fine-tuned,

00:36:41.980 --> 00:36:43.720
custom crafted motion.

00:36:43.720 --> 00:36:46.670
This is the type of
example that we hope

00:36:46.670 --> 00:36:49.200
will encourage you to build.

00:36:49.200 --> 00:36:51.980
JOHN HOFORD: And as
a small sneak peek

00:36:51.980 --> 00:36:57.800
at what we have in alpha 3, it
will support multiple states

00:36:57.800 --> 00:37:00.800
and allow you to interact with
the multiple states purely

00:37:00.800 --> 00:37:01.880
from touch.

00:37:01.880 --> 00:37:06.410
So this is one
single MotionLayout,

00:37:06.410 --> 00:37:10.550
but in fact it is
handling transitions

00:37:10.550 --> 00:37:13.220
between three transitions--

00:37:13.220 --> 00:37:17.360
from a blank page, to
swiping up the bottom,

00:37:17.360 --> 00:37:19.850
to swiping a little
bit, to swiping more.

00:37:19.850 --> 00:37:22.280
It's all one-page,
one MotionLayout.

00:37:22.280 --> 00:37:26.660
And it can produce a fairly
sophisticated custom view.

00:37:26.660 --> 00:37:29.020
And I sort of made it
look like a [? dialer. ?]

00:37:29.020 --> 00:37:31.370
NICOLAS ROARD: And [? decent ?]
behavior, or this touch

00:37:31.370 --> 00:37:33.920
behavior, 0 code from your end.

00:37:33.920 --> 00:37:35.580
It's all declarative.

00:37:35.580 --> 00:37:43.910
[APPLAUSE]

00:37:43.910 --> 00:37:45.930
NICK BUTCHER: Pretty awesome.

00:37:45.930 --> 00:37:46.430
Cool.

00:37:46.430 --> 00:37:49.580
So today, well,
hopefully we've given you

00:37:49.580 --> 00:37:52.550
a guided tour through this
variety of animation APIs

00:37:52.550 --> 00:37:54.500
that does exist on the platform.

00:37:54.500 --> 00:37:56.654
And our goal was really
to make you more familiar

00:37:56.654 --> 00:37:59.070
with what they're good at and
what they're not so good at.

00:37:59.070 --> 00:38:01.370
So I'm trying to summarize
that as a takeaway for you

00:38:01.370 --> 00:38:03.860
here so that you are confident
in picking the right one

00:38:03.860 --> 00:38:05.060
at the right time.

00:38:05.060 --> 00:38:06.674
For complex coordinated layout--

00:38:06.674 --> 00:38:08.840
and especially for that
nice handoff between gesture

00:38:08.840 --> 00:38:11.360
and animation-- then really,
really, really do check

00:38:11.360 --> 00:38:13.040
out MotionLayout.

00:38:13.040 --> 00:38:16.340
Next up, if you need to build
interruptible animations

00:38:16.340 --> 00:38:18.950
or, again, do gesture to
animation with that velocity

00:38:18.950 --> 00:38:23.117
tracking, then look at
the physics layout system.

00:38:23.117 --> 00:38:25.700
If you need to do shared element
transitions or window content

00:38:25.700 --> 00:38:27.741
transitions in your
application, then Transitions

00:38:27.741 --> 00:38:29.951
is the API for you.

00:38:29.951 --> 00:38:32.490
And if you need to do
vector graphic animations,

00:38:32.490 --> 00:38:35.460
then check out
AnimatedVectorDrawable.

00:38:35.460 --> 00:38:37.650
If you need to do
window animations--

00:38:37.650 --> 00:38:40.110
and only if you need to do
window animations-- then

00:38:40.110 --> 00:38:42.480
the original SDK 1.0
View animation system

00:38:42.480 --> 00:38:43.290
should be used.

00:38:43.290 --> 00:38:45.000
It's your only choice.

00:38:45.000 --> 00:38:46.890
If you need to animate
properties of views

00:38:46.890 --> 00:38:48.348
and it's supported
by it, then look

00:38:48.348 --> 00:38:49.860
at the ViewPropertyAnimator.

00:38:49.860 --> 00:38:54.300
If you need to do custom
view animation or some custom

00:38:54.300 --> 00:38:56.100
thing driven just by
an animation pulse,

00:38:56.100 --> 00:38:58.280
then look at the ValueAnimator.

00:38:58.280 --> 00:39:01.050
And lastly, like else,
use ObjectAnimator.

00:39:01.050 --> 00:39:03.420
ObjectAnimator is
your go-to default

00:39:03.420 --> 00:39:05.220
for general purpose animation.

00:39:05.220 --> 00:39:06.970
So hopefully that's
made it a bit clearer.

00:39:06.970 --> 00:39:08.760
So next time you have
to build something,

00:39:08.760 --> 00:39:12.150
you won't be paralyzed by choice
of the different animation

00:39:12.150 --> 00:39:13.417
APIs.

00:39:13.417 --> 00:39:15.000
So thank you very
much for joining us.

00:39:15.000 --> 00:39:16.458
And we'll be outside
for questions,

00:39:16.458 --> 00:39:17.950
or contact us online.

00:39:17.950 --> 00:39:18.750
Thanks very much.

00:39:18.750 --> 00:39:20.900
[MUSIC PLAYING]

