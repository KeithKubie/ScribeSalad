WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:05.400
&gt;&gt; Sean: What's the newest language you use?
&gt;&gt; BWK: I would say the newest language I use is

00:00:05.400 --> 00:00:13.730
Go, and that is sort of 10 years old at this point.
Languages last longer than you think.

00:00:13.730 --> 00:00:19.470
Fortran, which dates from the late 50s, is
still very much alive and still very

00:00:19.470 --> 00:00:23.390
much used by a lot of people, as is COBOL.

00:00:23.390 --> 00:00:27.689
Algol lives on in its derivatives; Basic
lives on its derivatives.  So all these

00:00:27.689 --> 00:00:31.320
languages never die, but then there are
brand new languages that come along.  I

00:00:31.320 --> 00:00:38.610
think that of languages that anybody
might have heard of that I use today,

00:00:38.610 --> 00:00:43.079
yeah, Go would probably be the newest.  I
have experimented with other languages

00:00:43.079 --> 00:00:46.620
briefly, mostly to try and understand
them just enough that I can say

00:00:46.620 --> 00:00:53.550
something in class.  Rust is newer than C [Go]
but not enormously so, so I've done that.

00:00:53.550 --> 00:00:57.600
Scala -- I don't even remember the dates
but it's, call it contemporaneous

00:00:57.600 --> 00:01:03.359
with Go.  I've done one program in that,
one in Lua.  I -- newer languages like

00:01:03.359 --> 00:01:10.229
Kotlin, no, I've never tried. Sorry, I'm a late
follower, not an early adopter.  

00:01:10.229 --> 00:01:13.560
&gt;&gt; Sean:  Any functional stuff?  I've seen your views 
on functional before but it'd be interesting to capture.

00:01:13.560 --> 00:01:20.729
&gt;&gt; BWK: Yeah.  Functional languages
are really really important, I think,

00:01:20.729 --> 00:01:26.520
because what they are - have proven to be -
is a proving ground for ideas in

00:01:26.520 --> 00:01:30.920
programming.  So a lot of the things that
we take for granted in modern languages --

00:01:30.920 --> 00:01:35.670
mainstream languages, mainstream compiled
languages like, let's say, C++ or Java or

00:01:35.670 --> 00:01:39.450
Go, whatever.  Many of the good ideas, the
new ideas in those, came from functional

00:01:39.450 --> 00:01:44.040
languages.  For example, recursion
originally is a Lisp idea and it shows

00:01:44.040 --> 00:01:49.710
up everywhere.  Functions as first-class
citizens, pattern matching kinds of things --

00:01:49.710 --> 00:01:54.509
all of these show up in functional
languages and then move into the

00:01:54.509 --> 00:01:58.350
mainstream in some way.  I have never
gotten over the hurdle of really

00:01:58.350 --> 00:02:03.140
internalizing a functional language well.
I have tried Haskell.  It was a desperate,

00:02:03.140 --> 00:02:06.780
desperately bad time.  It took me two
weeks to write a program that took me

00:02:06.780 --> 00:02:11.250
probably an hour to write in Lua, another
language I had never tried in my life.  I

00:02:11.250 --> 00:02:16.470
am not cut out; there's something wrong
between my brain and Haskell.  I can't

00:02:16.470 --> 00:02:21.960
do it.  But that's not to say that Haskell
is a bad idea; it has many neat ideas and

00:02:21.960 --> 00:02:27.780
it undoubtedly is providing something
that will help people in the future in

00:02:27.780 --> 00:02:33.150
programming.  But I think mainstream use
is probably always going to be dominated

00:02:33.150 --> 00:02:38.460
by the more conventional compiled,
imperative sorts of languages. 
&gt;&gt; Sean: The chap

00:02:38.460 --> 00:02:41.280
who asked the question about newest
language goes on to say what would you

00:02:41.280 --> 00:02:44.700
like to see created, which I think is a
tricky thing but, you know, what would you

00:02:44.700 --> 00:02:49.890
take the best of from, and is there a
way to answer that? 
&gt;&gt; BWK:  I think the way I

00:02:49.890 --> 00:02:53.940
would answer it is to say that in many
cases the way we make progress in all

00:02:53.940 --> 00:02:57.840
of these language-related things is when
we get to the stage where what we're

00:02:57.840 --> 00:03:01.920
trying to say is so mechanical you can
almost say it mechanically.  And once you

00:03:01.920 --> 00:03:04.980
get to that stage and we say, well let's
mechanize it so we'll add something

00:03:04.980 --> 00:03:09.360
whether it's a language or a library or
something like that, so that a whole

00:03:09.360 --> 00:03:13.230
class of things that used to require us
to do it over and over again have now

00:03:13.230 --> 00:03:17.040
become something where you have a
specification, or a very simple language,

00:03:17.040 --> 00:03:20.940
and the language is taking care of a lot
of it.  That has the advantage you

00:03:20.940 --> 00:03:24.690
understand it better.  It's much more
likely to be right if a computer is

00:03:24.690 --> 00:03:28.890
doing it for you.  And it's probably
easier to teach it to other people as

00:03:28.890 --> 00:03:34.770
well.  And sometimes those languages are
declarative, sometimes they're procedural,

00:03:34.770 --> 00:03:38.459
but fundamentally I think that's the way
we make progress: we understand more of

00:03:38.459 --> 00:03:42.660
it what it is we want to do and how to
express how to do that, and then we put

00:03:42.660 --> 00:03:47.400
that into a program; we mechanize it.
&gt;&gt; Sean:  John Read asks: "If you could start from

00:03:47.400 --> 00:03:51.360
scratch today and build a new processor
architecture and operating system with what

00:03:51.360 --> 00:03:56.580
we know today, where would you begin and
what would it look like?"
&gt;&gt; BWK: I would begin by

00:03:56.580 --> 00:04:03.060
getting somebody who actually knows what
that's all about.  Sorry.  I mean, it's true;

00:04:03.060 --> 00:04:07.500
it's not my thing, I'm no expert.
&gt;&gt; Sean: it's fair answer and he goes on to ask a

00:04:07.500 --> 00:04:11.330
second question: "Will block-based
drag-and-drop programming like Scratch

00:04:11.330 --> 00:04:15.720
eventually replace traditional text-based programming?" 
&gt;&gt; BWK:  That I at least

00:04:15.720 --> 00:04:22.169
have opinions on.  I think the answer
is 'no'.  I played briefly with Scratch or

00:04:22.169 --> 00:04:25.380
at least a derivative.  There was a
program or a system that Google

00:04:25.380 --> 00:04:28.479
provided called App Inventor.
The idea was that it was basically

00:04:28.479 --> 00:04:33.220
Scratch but with primitives that made it
possible to build Android apps very

00:04:33.220 --> 00:04:39.280
easily.  And my experience with it was
that for anything that fit within the

00:04:39.280 --> 00:04:44.979
model for which they had provided the
blocks [it] was perfectly fine but very, very,

00:04:44.979 --> 00:04:50.259
very clunky.  I tried to build something
that would navigate around a building,

00:04:50.259 --> 00:04:55.090
for example, and doing a distance
computation with blocks was just -- you had

00:04:55.090 --> 00:04:58.479
this much block to say give me the
square root of x squared plus y squared.

00:04:58.479 --> 00:05:04.300
It was hopeless.  So I think using
languages like Scratch as they were

00:05:04.300 --> 00:05:07.900
constituted when I did this -- this was a
while ago, so maybe it's moved on -- but I

00:05:07.900 --> 00:05:11.530
think the problem with them is it's
trying to ... sort of like trying to get to

00:05:11.530 --> 00:05:16.150
the moon by climbing a tree.  You know, the
first 10 or 20 feet is really good.  Now

00:05:16.150 --> 00:05:20.949
you're stuck!.  Can't get anywhere.
I think the same thing is true.  Now that's

00:05:20.949 --> 00:05:24.789
for me as a sort of professional
programmer trying to do things.  As a way

00:05:24.789 --> 00:05:29.319
to introduce programming to kids -- absolutely
great.  There's amazing stuff that people

00:05:29.319 --> 00:05:33.669
do with Scratch and languages like that.
Could you do something that would use

00:05:33.669 --> 00:05:38.319
the block space part as something that is
a nice way to get started with aspects

00:05:38.319 --> 00:05:41.500
of it, and then extend it in other ways?
That's what I was trying to do when I

00:05:41.500 --> 00:05:45.279
was playing with App Inventor and it
just, it foundered on the technology there.

00:05:45.279 --> 00:05:50.289
But I think something like that might be
useful.  So they have their place but it's

00:05:50.289 --> 00:05:55.569
not gonna replace other languages.
&gt;&gt; Sean:  What do you think about -- this is such a wide

00:05:55.569 --> 00:06:00.610
wide brief -- what do you think about the
future of computer science?  Will the

00:06:00.610 --> 00:06:05.080
manipulating bits era become obsolete in
a few years or basics will never change?

00:06:05.080 --> 00:06:10.449
&gt;&gt; BWK: I think basics will always be there; in
some sense we will always have to worry

00:06:10.449 --> 00:06:14.680
about how much memory we have, how much
processor time we have.  We'll have to

00:06:14.680 --> 00:06:18.219
worry about whether the programs are
correct or not, whether they're safe and

00:06:18.219 --> 00:06:22.479
secure or not, so all of that is going to
be with us I think in perpetuity, and I

00:06:22.479 --> 00:06:27.400
think and, as a nominally computer
science educator, that's something that

00:06:27.400 --> 00:06:30.610
we want to make sure those so that
students in computer science courses,

00:06:30.610 --> 00:06:34.629
let's say at university, should actually
understand the basics at that point.  They

00:06:34.629 --> 00:06:39.009
should understand how the machines work,
what the limitations and realities are

00:06:39.009 --> 00:06:41.370
of making them do things.
They should also understand

00:06:41.370 --> 00:06:45.450
some of the theoretical limitations: some
things are hard to compute intrinsically

00:06:45.450 --> 00:06:49.500
and that's important and sometimes
useful.  So all of that kind of thing is

00:06:49.500 --> 00:06:52.800
going to be there.  So let's call that
core computer science. And then there's

00:06:52.800 --> 00:06:56.220
all the things that computer science
gets applied to, and that's the place

00:06:56.220 --> 00:07:00.450
where all the growth is in some sense.  I
used to say to students in one of my

00:07:00.450 --> 00:07:06.600
classes for non-technical people, "I don't
care what your major or field is; you'll

00:07:06.600 --> 00:07:10.200
find a use for computing, unless maybe
you're a religion major".  And then I

00:07:10.200 --> 00:07:14.540
realized this is nonsense -- religion
majors do really, really interesting

00:07:14.540 --> 00:07:20.250
analysis of texts written in ancient
languages and they did the same kind of

00:07:20.250 --> 00:07:24.479
authorship questions that showed up in
more recent issues like the Federalist

00:07:24.479 --> 00:07:28.590
Papers.  All of these kinds of things.  So I
don't care what your field is; it has

00:07:28.590 --> 00:07:32.790
computing in it, the more you know about
that the better off you'll be able to do

00:07:32.790 --> 00:07:37.770
things in your field.  
&gt;&gt; Sean: that's a fantastic answer.  
I'm gonna ask you on the silly

00:07:37.770 --> 00:07:42.360
ones now.  What is the proper way to
pronounce caramel? Is it 'car-mel' or

00:07:42.360 --> 00:07:49.320
'car-a-mel?  
&gt;&gt; BWK: I think it's a three syllable
word, 'caramel', to me, but I think so.

00:07:49.320 --> 00:07:56.430
I don't know now that you asked me.  
&gt;&gt; Sean: Not necessarily silly ones but very difficult

00:07:56.430 --> 00:08:00.360
to answer in a concise way: "What are your
favorite books or what are your top few

00:08:00.360 --> 00:08:04.740
books?"  This came up a couple of times.
&gt;&gt; BWK: Yeah.  When I think about what I read and

00:08:04.740 --> 00:08:11.789
let's call it reading for pleasure as
opposed to reading for work.  I think what

00:08:11.789 --> 00:08:18.990
I find myself reading mostly is either
junky detective stories.  One of the

00:08:18.990 --> 00:08:23.039
wonderful things about spending time in
England is charity shops.  There are

00:08:23.039 --> 00:08:27.510
charity shops everywhere in every town,
no matter how big or small, and you can

00:08:27.510 --> 00:08:31.710
go in there and buy for a pound a really
really interesting junky detective story

00:08:31.710 --> 00:08:35.820
that you hadn't read already.  And then in
the next town, having read it, you drop it

00:08:35.820 --> 00:08:39.360
off at the charity shop and pick up a
new one.  So I read a lot of those kinds

00:08:39.360 --> 00:08:44.219
of things, probably half to two-thirds by
British authors and the rest by American

00:08:44.219 --> 00:08:48.390
authors.  So I read those.  The other
thing that I read, and probably this is

00:08:48.390 --> 00:08:52.570
more at home, tends to be history of one
sort or another.

00:08:52.570 --> 00:08:56.620
The Princeton library has a great
collection of history books and so I

00:08:56.620 --> 00:09:00.430
find myself reading that.  Reading things
on the Second World War just before I

00:09:00.430 --> 00:09:04.959
left.  I'm carrying a copy of 'A Distant
Mirror' which Barbara Tuchman wrote years

00:09:04.959 --> 00:09:09.610
ago about the calamitous era of the 14th
century and so on, which has a lot of

00:09:09.610 --> 00:09:14.110
English and French and Crusades.  So
lots of these things -- that's, that's what

00:09:14.110 --> 00:09:19.449
I read for fun as opposed to for work.  I
think I don't do very much reading of

00:09:19.449 --> 00:09:24.310
technical books, other than occasionally
I will buy a book on something like: "How

00:09:24.310 --> 00:09:31.360
do you use React?", or "How do you program
for Androids?", or I got one on OCaml

00:09:31.360 --> 00:09:34.180
recently because in spite of saying I
don't know anything about functional

00:09:34.180 --> 00:09:36.970
languages, I figure I ought to learn
something and unfortunately I'm not sure

00:09:36.970 --> 00:09:41.920
I've opened it yet.  So technical books, I
know I don't read as much as I probably should.

