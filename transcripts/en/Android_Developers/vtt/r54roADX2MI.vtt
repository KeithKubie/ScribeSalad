WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.395
[MUSIC PLAYING]

00:00:06.310 --> 00:00:08.920
DAVE KLEIDERMACHER: Hello,
and welcome to the Android P

00:00:08.920 --> 00:00:12.940
edition of what's new
in Android security.

00:00:12.940 --> 00:00:13.840
My name is Dave.

00:00:13.840 --> 00:00:16.286
I lead mobile security
here at Google.

00:00:16.286 --> 00:00:17.910
And in a few minutes,
I'll hand it over

00:00:17.910 --> 00:00:21.240
to Xiaowen, who is the lead
security product manager

00:00:21.240 --> 00:00:24.740
for the Android platform.

00:00:24.740 --> 00:00:26.210
We have a lot of
ground to cover,

00:00:26.210 --> 00:00:29.660
so we'll start with a brief
state of the union on Android

00:00:29.660 --> 00:00:32.630
security, and then jump into
all the really cool things

00:00:32.630 --> 00:00:35.750
we've been working on in Android
security over the past year

00:00:35.750 --> 00:00:39.890
and launching here at Android
P, including secure hardware

00:00:39.890 --> 00:00:43.110
support advancements, lock
screen authentication,

00:00:43.110 --> 00:00:46.960
integrity, and privacy.

00:00:46.960 --> 00:00:48.580
So state of the union.

00:00:48.580 --> 00:00:51.700
Let's talk a little bit about
what the Android security

00:00:51.700 --> 00:00:53.230
strategy looks like.

00:00:53.230 --> 00:00:56.360
There are really
three main pillars.

00:00:56.360 --> 00:00:58.870
First, Google Play Protect.

00:00:58.870 --> 00:01:02.740
This is the malware protection
and mobile security services

00:01:02.740 --> 00:01:06.810
that run on over 2 billion
Android devices today.

00:01:06.810 --> 00:01:09.600
The second pillar is
platform engineering.

00:01:09.600 --> 00:01:12.330
These are the core
operating system defenses

00:01:12.330 --> 00:01:15.480
that we build into Android to
improve security to systems,

00:01:15.480 --> 00:01:19.980
such as SELinux, control-flow
integrity protection, which

00:01:19.980 --> 00:01:23.640
we've been investing in a
lot in P, and encryption,

00:01:23.640 --> 00:01:26.400
verified boot, lots
of other features.

00:01:26.400 --> 00:01:30.780
The third pillar is the
security development lifecycle.

00:01:30.780 --> 00:01:33.660
These are all the programs
that we put in place

00:01:33.660 --> 00:01:38.100
to ensure a consistent,
high-quality level for security

00:01:38.100 --> 00:01:40.240
across the Android ecosystem.

00:01:40.240 --> 00:01:43.290
So this includes things like
testing infrastructures,

00:01:43.290 --> 00:01:46.860
and also includes our
security patching programs.

00:01:46.860 --> 00:01:48.690
We've been working
really hard on that.

00:01:48.690 --> 00:01:50.940
A couple of things
we are investing in,

00:01:50.940 --> 00:01:53.700
we've been trying to make
Android just easier to patch.

00:01:53.700 --> 00:01:57.690
So Google, we have a
pretty steady track record

00:01:57.690 --> 00:02:00.540
for years now every single
month delivering those patches

00:02:00.540 --> 00:02:01.140
to the market.

00:02:01.140 --> 00:02:04.020
But we want to make sure that
all Android OEMs are delivering

00:02:04.020 --> 00:02:05.940
patches regularly
to their devices

00:02:05.940 --> 00:02:08.220
as well, not just
Google's devices.

00:02:08.220 --> 00:02:11.160
And so making Android more
modular like with projects

00:02:11.160 --> 00:02:14.490
like Treble really help
contribute to that.

00:02:14.490 --> 00:02:19.290
We've also worked on building
security patching into our OEM

00:02:19.290 --> 00:02:20.970
agreements.

00:02:20.970 --> 00:02:25.260
Now, this will really
lead to a massive increase

00:02:25.260 --> 00:02:27.450
in the number of
devices and users

00:02:27.450 --> 00:02:29.550
receiving regular
security patches.

00:02:29.550 --> 00:02:31.510
So we're really
excited about that.

00:02:34.192 --> 00:02:36.150
But there are a couple
of also really important

00:02:36.150 --> 00:02:38.670
philosophical principles
that underlie everything

00:02:38.670 --> 00:02:41.110
we do when it comes to security.

00:02:41.110 --> 00:02:43.630
We believe in
transparency and openness,

00:02:43.630 --> 00:02:49.060
because that breeds confidence
and it breeds trust.

00:02:49.060 --> 00:02:55.230
Conversely, a closed platform,
secrecy, that breeds distrust.

00:02:55.230 --> 00:02:58.320
But actually, there's a really
important security advantage

00:02:58.320 --> 00:03:00.630
to be open.

00:03:00.630 --> 00:03:03.870
Today's mobile devices are
faced with really sophisticated

00:03:03.870 --> 00:03:04.920
attack threats.

00:03:04.920 --> 00:03:07.770
When you have billions of users,
it's an attractive target.

00:03:07.770 --> 00:03:11.370
And so it deserves the
strongest possible defense.

00:03:11.370 --> 00:03:13.230
With a closed
platform, the defenders

00:03:13.230 --> 00:03:16.740
are the employees of the one
company that owns the platform.

00:03:16.740 --> 00:03:20.382
But with Android, we have
the thousands of Googlers

00:03:20.382 --> 00:03:21.840
that wake up every
morning thinking

00:03:21.840 --> 00:03:24.720
about how best to protect
users and our platforms.

00:03:24.720 --> 00:03:28.110
We have the device manufacturers
who have their own security

00:03:28.110 --> 00:03:30.810
team to work closely
with Google on protecting

00:03:30.810 --> 00:03:32.520
Android and its users.

00:03:32.520 --> 00:03:34.470
We have the microprocessor
manufacturers--

00:03:34.470 --> 00:03:37.590
Arm, Intel, Qualcomm,
Broadcom, and others,

00:03:37.590 --> 00:03:40.980
also with their security teams
helping to protect Android.

00:03:40.980 --> 00:03:44.040
We have the worldwide
open-source Linux community

00:03:44.040 --> 00:03:47.100
contributing to Android
security every day.

00:03:47.100 --> 00:03:50.040
We have the academic
research community,

00:03:50.040 --> 00:03:52.740
which simply prefer
working on open platforms.

00:03:52.740 --> 00:03:57.780
So this is a mass force
multiplier in protection.

00:03:57.780 --> 00:04:01.860
And as operating systems have
matured, the power of open

00:04:01.860 --> 00:04:04.110
has really become
evident to the point

00:04:04.110 --> 00:04:07.740
where today, the protective
capabilities of Android

00:04:07.740 --> 00:04:10.650
are now on par with any
other mobile platform.

00:04:10.650 --> 00:04:13.260
And I strongly believe
that the power of open

00:04:13.260 --> 00:04:16.050
will accelerate those
protective capabilities

00:04:16.050 --> 00:04:19.089
for our users going forward.

00:04:19.089 --> 00:04:20.910
The other really
important philosophy

00:04:20.910 --> 00:04:24.960
that underlies our
strategy is measurability.

00:04:24.960 --> 00:04:27.780
We always look for objective
independent measurements

00:04:27.780 --> 00:04:29.970
to help not only
inform the work that we

00:04:29.970 --> 00:04:32.850
do to ensure we're investing
in the right directions,

00:04:32.850 --> 00:04:34.860
but also to measure progress.

00:04:34.860 --> 00:04:37.830
And so one example you
see here is the incidence

00:04:37.830 --> 00:04:41.430
of malware or Potentially
Harmful Applications

00:04:41.430 --> 00:04:44.190
we call PHA on devices.

00:04:44.190 --> 00:04:49.140
The bottom curve are devices
that load only from Play,

00:04:49.140 --> 00:04:51.150
and the top curve
are devices that load

00:04:51.150 --> 00:04:53.800
from sources other than Play.

00:04:53.800 --> 00:04:58.170
And you can see over time, it's
been reducing across all users.

00:04:58.170 --> 00:05:00.180
So we are committed
to protecting users,

00:05:00.180 --> 00:05:03.510
regardless of where they
get their applications from.

00:05:03.510 --> 00:05:07.010
But this improvement
is due to many things.

00:05:07.010 --> 00:05:10.410
It's locking down APIs
and permissions over time.

00:05:10.410 --> 00:05:11.860
We're constantly
looking at that.

00:05:11.860 --> 00:05:13.890
And it's investing in
the malware detection

00:05:13.890 --> 00:05:15.750
engine itself.

00:05:15.750 --> 00:05:18.900
Today, 60% of
malware is detected

00:05:18.900 --> 00:05:19.960
through machine learning.

00:05:19.960 --> 00:05:23.890
And that's been one area
of big investment for us.

00:05:23.890 --> 00:05:29.490
Over the past year, we've had
a 50% reduction in PHA on Play.

00:05:29.490 --> 00:05:33.650
And so we're really
happy with the progress,

00:05:33.650 --> 00:05:37.090
but certainly, we're not content
with where we stand today.

00:05:37.090 --> 00:05:41.620
Although, I will say that the
odds of loading a PHA from Play

00:05:41.620 --> 00:05:43.990
is about the same as
being struck by lightning.

00:05:43.990 --> 00:05:48.147
So it is a safe place to
live on your mobile life,

00:05:48.147 --> 00:05:50.230
but we're going to continue
to invest tremendously

00:05:50.230 --> 00:05:52.570
in this area.

00:05:52.570 --> 00:05:54.900
Another really
important measurement

00:05:54.900 --> 00:05:57.480
is the overall ability
of the operating system

00:05:57.480 --> 00:06:00.510
to protect itself
against exploitation.

00:06:00.510 --> 00:06:03.690
In any complex product,
there are going to be bugs.

00:06:03.690 --> 00:06:05.880
But there's no reason
why bugs have to lead

00:06:05.880 --> 00:06:07.910
to exploitation to harm users.

00:06:07.910 --> 00:06:10.890
And so we work really
hard on building

00:06:10.890 --> 00:06:13.200
features and
improvements that make

00:06:13.200 --> 00:06:18.240
Android much more difficult
and expensive to exploit.

00:06:18.240 --> 00:06:20.130
So how do you measure
how well you're doing?

00:06:20.130 --> 00:06:23.730
Well, lots of people want
to purchase exploits.

00:06:23.730 --> 00:06:26.500
There's a vibrant
market for that.

00:06:26.500 --> 00:06:30.840
And as exploits get more
difficult, of course,

00:06:30.840 --> 00:06:33.610
the law of supply demand, the
prices are going to go up.

00:06:33.610 --> 00:06:35.194
And so we watch the
pricing over time.

00:06:35.194 --> 00:06:36.901
And there's a number
of different markets

00:06:36.901 --> 00:06:37.670
you can look at.

00:06:37.670 --> 00:06:41.610
On the left-hand side, you
see the device manufacturers

00:06:41.610 --> 00:06:42.940
rewards programs.

00:06:42.940 --> 00:06:45.390
So the green bars are
Google's rewards programs,

00:06:45.390 --> 00:06:47.400
which now are paying
out the highest

00:06:47.400 --> 00:06:50.530
rewards in the industry.

00:06:50.530 --> 00:06:53.820
Another market you can look at
are the elite hacking contests,

00:06:53.820 --> 00:06:55.540
like Mobile Pwn2Own.

00:06:55.540 --> 00:06:57.960
And you can see on the
graph on the right,

00:06:57.960 --> 00:07:01.140
the price of Android
exploits has risen each year

00:07:01.140 --> 00:07:04.170
to the point where now this
is the most recent event

00:07:04.170 --> 00:07:05.610
a few months ago.

00:07:05.610 --> 00:07:10.440
The pricing for Android is
on par with other platforms.

00:07:10.440 --> 00:07:11.940
And if you haven't
seen the results,

00:07:11.940 --> 00:07:15.330
Android performed quite
well in that event.

00:07:15.330 --> 00:07:16.860
Another market is
the gray market.

00:07:16.860 --> 00:07:19.320
It's independent
researchers and brokers

00:07:19.320 --> 00:07:21.990
who will sell exploits
to the highest bidder.

00:07:21.990 --> 00:07:24.060
This market is a little
bit harder to track,

00:07:24.060 --> 00:07:26.560
but we have connections to a
lot of researchers out there.

00:07:26.560 --> 00:07:28.710
And again, anecdotally,
what we're seeing

00:07:28.710 --> 00:07:31.110
is the price of
exploitation on Android

00:07:31.110 --> 00:07:35.770
is now as high or higher
than any other platform.

00:07:35.770 --> 00:07:36.840
So this is really great.

00:07:36.840 --> 00:07:39.630
We're happy with the
progress, but we continue

00:07:39.630 --> 00:07:41.660
to invest in all these areas.

00:07:41.660 --> 00:07:43.620
And now let's switch
gears and talk about some

00:07:43.620 --> 00:07:46.380
of the new emerging
features in Android P,

00:07:46.380 --> 00:07:51.830
starting with the feature called
Android Protected Confirmation.

00:07:51.830 --> 00:07:55.880
So the problem here is in
today's secure mobility,

00:07:55.880 --> 00:07:58.730
we use mobile devices for much
more than we ever did before,

00:07:58.730 --> 00:07:59.990
much more critical things.

00:07:59.990 --> 00:08:01.880
But there's still
a ceiling of trust

00:08:01.880 --> 00:08:03.710
that we haven't
quite broken through.

00:08:03.710 --> 00:08:07.200
We don't vote for prime minister
or president from our phones.

00:08:07.200 --> 00:08:10.670
We don't program life-critical
medical devices like an insulin

00:08:10.670 --> 00:08:12.900
pump from our phones.

00:08:12.900 --> 00:08:16.280
We don't have our passports
built into our phones.

00:08:16.280 --> 00:08:18.800
It is our goal to break
through that ceiling,

00:08:18.800 --> 00:08:20.780
and Android Protected
Confirmation

00:08:20.780 --> 00:08:22.796
is a bold step in
that direction.

00:08:22.796 --> 00:08:24.170
I'll talk about
a few use cases--

00:08:24.170 --> 00:08:26.120
medical, financial, enterprise.

00:08:26.120 --> 00:08:29.900
But the key innovation here
is Protected Confirmation

00:08:29.900 --> 00:08:34.820
is the first time in any
major operating system API

00:08:34.820 --> 00:08:39.830
that we now have the ability to
execute a high-assurance user

00:08:39.830 --> 00:08:43.429
transaction completely within
secure hardware running

00:08:43.429 --> 00:08:45.170
in a Trusted
Execution Environment,

00:08:45.170 --> 00:08:48.680
or TEE, that runs separate
from the main operating system.

00:08:53.180 --> 00:08:54.460
So how does it work?

00:08:54.460 --> 00:08:58.210
So an application developer, say
you're a medical company that's

00:08:58.210 --> 00:09:01.300
developing a solution
for people with diabetes,

00:09:01.300 --> 00:09:03.730
and so you're managing
an insulin pump.

00:09:03.730 --> 00:09:07.210
You want to inject two insulin
units into your insulin pump.

00:09:07.210 --> 00:09:09.700
And the application
will enable the user

00:09:09.700 --> 00:09:13.210
to select two insulin units,
and then call the protection

00:09:13.210 --> 00:09:18.160
API to transmit that data
to the secure hardware area

00:09:18.160 --> 00:09:21.430
where a completely
independent trusted user

00:09:21.430 --> 00:09:22.960
interface will execute.

00:09:22.960 --> 00:09:25.180
The interface you see
here on the screen

00:09:25.180 --> 00:09:26.470
shows the two insulin units.

00:09:26.470 --> 00:09:28.870
The user then confirms
it by pressing a button.

00:09:28.870 --> 00:09:31.720
The input is guarded
in this protected area.

00:09:31.720 --> 00:09:33.910
And then this entire
transaction is

00:09:33.910 --> 00:09:36.940
signed using a
cryptographic key that

00:09:36.940 --> 00:09:40.210
never leaves that secure area.

00:09:40.210 --> 00:09:43.000
This provides higher assurance
to the relying party,

00:09:43.000 --> 00:09:45.250
whether it be an insulin
pump, or a financial service,

00:09:45.250 --> 00:09:49.630
or enterprise that the integrity
of this data was not corrupted.

00:09:49.630 --> 00:09:51.620
Even if you had
root level malware,

00:09:51.620 --> 00:09:54.782
you cannot corrupt the
integrity of that transaction.

00:09:57.440 --> 00:09:59.000
So in code, this is really easy.

00:09:59.000 --> 00:10:00.730
We use the standard
Android KeyStore

00:10:00.730 --> 00:10:02.770
API to create a public key.

00:10:02.770 --> 00:10:07.360
We have this new method to set
the flag confirmation required.

00:10:07.360 --> 00:10:10.180
We create the dialog for the
confirmation dialog using

00:10:10.180 --> 00:10:12.580
the Confirmation Dialog API.

00:10:12.580 --> 00:10:14.980
And then we simply call
the present prompt method

00:10:14.980 --> 00:10:18.250
to transfer control
from the main Android OS

00:10:18.250 --> 00:10:20.560
to this trusted execution
environment, where

00:10:20.560 --> 00:10:24.060
the user will then interact
with that special screen.

00:10:24.060 --> 00:10:25.567
Really easy.

00:10:25.567 --> 00:10:27.150
So we have a number
of launch partners

00:10:27.150 --> 00:10:28.380
who've been working
really closely with us

00:10:28.380 --> 00:10:29.370
on this technology.

00:10:29.370 --> 00:10:31.200
They've been building
prototypes that they

00:10:31.200 --> 00:10:35.820
intend to make product into
a product in the future.

00:10:35.820 --> 00:10:37.650
So Bigfoot Biomedical
is a firm that

00:10:37.650 --> 00:10:40.290
works on solutions for
people with diabetes.

00:10:40.290 --> 00:10:43.140
And you see here an app,
the Bigfoot Biomedical app.

00:10:43.140 --> 00:10:46.050
The user is looking at the
glucose level and deciding,

00:10:46.050 --> 00:10:50.010
I want to inject 1
and 1/2 insulin units.

00:10:50.010 --> 00:10:52.230
Uses the app to
select that, then

00:10:52.230 --> 00:10:55.230
calls the API to
invoke the new user

00:10:55.230 --> 00:10:56.700
interface that you see there.

00:10:56.700 --> 00:10:58.560
The user confirms.

00:10:58.560 --> 00:11:01.710
And then, and only then,
will the insulin pump

00:11:01.710 --> 00:11:03.055
administer that dose.

00:11:08.320 --> 00:11:11.260
In the medical side,
we have Royal Bank

00:11:11.260 --> 00:11:14.900
of Canada, RBC, that is
working to integrate Protected

00:11:14.900 --> 00:11:16.954
Confirmations into
their application.

00:11:16.954 --> 00:11:18.370
I don't have a
video for this one,

00:11:18.370 --> 00:11:20.410
but you can track left to right.

00:11:20.410 --> 00:11:23.650
This application is moving
a person-to-person financial

00:11:23.650 --> 00:11:24.640
transfer.

00:11:24.640 --> 00:11:27.580
We see we're going to send
$1,500 to [? Robbie. ?]

00:11:27.580 --> 00:11:29.920
The application invokes
the Protected Conformations

00:11:29.920 --> 00:11:32.230
API, which you
see in the middle.

00:11:32.230 --> 00:11:34.420
The user confirms $1,500.

00:11:34.420 --> 00:11:37.270
So $1,500 can't be
changed to $15,000.

00:11:37.270 --> 00:11:38.710
The relying party
on the other end

00:11:38.710 --> 00:11:41.200
has high confidence
that indeed, we

00:11:41.200 --> 00:11:43.276
intended to send
[? Robbie ?] $1,500,

00:11:43.276 --> 00:11:44.650
and the transaction
goes through.

00:11:47.690 --> 00:11:51.310
Duo Security is a firm that's
working on strong enterprise

00:11:51.310 --> 00:11:52.420
authentication.

00:11:52.420 --> 00:11:55.120
Imagine you're logging
into your Chromebook,

00:11:55.120 --> 00:11:59.672
into your G Suite application,
and it launches a second factor

00:11:59.672 --> 00:12:00.880
authentication to your phone.

00:12:00.880 --> 00:12:02.980
You see the request
come in on the left.

00:12:02.980 --> 00:12:05.800
The Duo Security
application comes up

00:12:05.800 --> 00:12:07.920
and asks for confirmation,
but then there's

00:12:07.920 --> 00:12:10.690
the second level confirmation
using the Protected

00:12:10.690 --> 00:12:13.780
Confirmation API that
provides, again, a higher

00:12:13.780 --> 00:12:16.840
level of assurance for
the enterprise that it

00:12:16.840 --> 00:12:20.290
is the device, and user,
and location that's expected

00:12:20.290 --> 00:12:23.929
for that authentication.

00:12:23.929 --> 00:12:25.720
So there are a lot of
other launch partners

00:12:25.720 --> 00:12:27.500
we've worked closely
with on this.

00:12:27.500 --> 00:12:30.910
Insulet Corporation is also
integrating their application

00:12:30.910 --> 00:12:33.410
for control of diabetes.

00:12:33.410 --> 00:12:36.530
ProxToMe is doing
proximal-based authentication.

00:12:36.530 --> 00:12:40.730
Nok Nok Labs in the enterprise
authentication space as well.

00:12:40.730 --> 00:12:43.052
I'd also like to throw
a shout-out to Qualcomm.

00:12:43.052 --> 00:12:45.010
We've been working really
closely with Qualcomm

00:12:45.010 --> 00:12:48.250
to integrate the Protected
Conformations API

00:12:48.250 --> 00:12:51.610
into the next generation
Qualcomm chipsets.

00:12:51.610 --> 00:12:55.450
Because Protected Conformations
requires a deep integration

00:12:55.450 --> 00:12:58.210
at the hardware level,
it is optional for P,

00:12:58.210 --> 00:13:03.280
and so it requires a
supported Android P device.

00:13:03.280 --> 00:13:06.340
We're breaking through that
last ceiling of assurance

00:13:06.340 --> 00:13:10.005
in mobility, so
it's very exciting.

00:13:10.005 --> 00:13:11.380
There's a lot more
to talk about,

00:13:11.380 --> 00:13:13.450
and so I'd like to
now call up Xiaowen

00:13:13.450 --> 00:13:15.850
to take us through the story.

00:13:15.850 --> 00:13:19.270
[APPLAUSE]

00:13:19.770 --> 00:13:21.960
XIAOWEN XIN: Thanks, Dave.

00:13:21.960 --> 00:13:23.120
Good morning, everyone.

00:13:23.120 --> 00:13:25.080
And I'm really
excited to be here

00:13:25.080 --> 00:13:27.720
to talk about a lot more of the
security and privacy features

00:13:27.720 --> 00:13:31.380
that we've built into Android
P. So as Dave mentioned,

00:13:31.380 --> 00:13:34.260
secure hardware is a
huge focus area for us,

00:13:34.260 --> 00:13:37.100
because they can provide
defenses against attacks

00:13:37.100 --> 00:13:40.560
that software alone is simply
not sufficient to handle.

00:13:40.560 --> 00:13:42.660
And so Protected
Confirmation was

00:13:42.660 --> 00:13:46.170
an API that really
leveraged secure hardware.

00:13:46.170 --> 00:13:51.440
And another feature that
we're making in Android P,

00:13:51.440 --> 00:13:53.490
it leverages secure
hardware also

00:13:53.490 --> 00:13:56.380
to provide stronger
protection for private keys.

00:13:56.380 --> 00:14:00.090
So why do we need stronger
protection for private keys?

00:14:00.090 --> 00:14:02.700
Well, Google Pay transit
is a great example here.

00:14:02.700 --> 00:14:05.280
And in fact, we're
working closely with them

00:14:05.280 --> 00:14:07.230
on this P feature,
and they're going

00:14:07.230 --> 00:14:09.230
to launch with it
later this year.

00:14:09.230 --> 00:14:11.110
Consider their security goal.

00:14:11.110 --> 00:14:13.200
In the traditional
transit use case,

00:14:13.200 --> 00:14:15.570
they need to make sure that
your transit card and only

00:14:15.570 --> 00:14:19.710
your credit card can be used
to pay for your bus ride.

00:14:19.710 --> 00:14:22.500
So your transit card has
your account information,

00:14:22.500 --> 00:14:26.616
a lot of secrets in there
that represents your account.

00:14:26.616 --> 00:14:27.990
Now, the transit
cards are simply

00:14:27.990 --> 00:14:30.030
made using a secure
element inside of it,

00:14:30.030 --> 00:14:32.940
so it's very hard to break into
it, extract secrets out of it,

00:14:32.940 --> 00:14:35.230
and duplicate that card.

00:14:35.230 --> 00:14:39.510
So Android Pay transit is now
working to replace that transit

00:14:39.510 --> 00:14:41.080
card with your phone.

00:14:41.080 --> 00:14:44.250
And so we need to make sure that
we provide the same security

00:14:44.250 --> 00:14:48.150
guarantees, which is that your
secrets cannot be extracted out

00:14:48.150 --> 00:14:51.060
of your phone and put
onto another phone.

00:14:51.060 --> 00:14:52.740
So in order to pay
for your bus ride,

00:14:52.740 --> 00:14:54.980
you must present your phone.

00:14:54.980 --> 00:14:59.600
And a great solution here
is to use secure hardware.

00:14:59.600 --> 00:15:01.480
Now, Google Pay
transit is one example

00:15:01.480 --> 00:15:03.670
of an in-person transaction.

00:15:03.670 --> 00:15:05.460
Payments is another.

00:15:05.460 --> 00:15:07.000
In all of these
use cases, you want

00:15:07.000 --> 00:15:09.070
to make sure that your
phone and only your phone

00:15:09.070 --> 00:15:12.010
can make that transaction.

00:15:12.010 --> 00:15:13.810
There are quite a
few other examples

00:15:13.810 --> 00:15:18.190
where we benefit from stronger
protection for private keys.

00:15:18.190 --> 00:15:20.860
For example, if you have
high value cloud data,

00:15:20.860 --> 00:15:23.500
if you're an
enterprise, or if you

00:15:23.500 --> 00:15:25.450
are a financial
institution, you want

00:15:25.450 --> 00:15:28.420
to make sure that all
requests, all data access

00:15:28.420 --> 00:15:32.650
is coming from a known phone,
a phone that you trust.

00:15:32.650 --> 00:15:36.380
And that phone is
identified by a private key.

00:15:36.380 --> 00:15:38.625
Also, if you have
high-value local data,

00:15:38.625 --> 00:15:41.000
let's say your password manager,
you're storing passwords

00:15:41.000 --> 00:15:43.040
locally on disk,
then you may want

00:15:43.040 --> 00:15:45.260
to encrypt it again with
a private key that's

00:15:45.260 --> 00:15:47.530
well-protected.

00:15:47.530 --> 00:15:51.010
And so how do we provide
stronger protection?

00:15:51.010 --> 00:15:55.000
Traditionally, secure elements
such as those built [INAUDIBLE]

00:15:55.000 --> 00:15:57.340
smartcard credit cards, and
second factor security keys

00:15:57.340 --> 00:16:01.450
and credit cards, are the gold
standard for hardware security.

00:16:01.450 --> 00:16:03.100
They're built to
exacting standards,

00:16:03.100 --> 00:16:05.350
and certified by
professional labs

00:16:05.350 --> 00:16:08.320
to be resistant to
hardware tampering.

00:16:08.320 --> 00:16:11.200
And phones are now starting to
incorporate that exact hardware

00:16:11.200 --> 00:16:13.390
directly into the phone
so that your phone can

00:16:13.390 --> 00:16:15.610
replace your transit card,
replace your credit card,

00:16:15.610 --> 00:16:18.470
and replace your second
factor security key.

00:16:18.470 --> 00:16:22.100
And so with Android P,
we're now exposing APIs

00:16:22.100 --> 00:16:24.890
so that all the
applications on Android

00:16:24.890 --> 00:16:28.640
can take advantage of this type
of temporariness and hardware

00:16:28.640 --> 00:16:31.720
on compatible devices
and potentially enable

00:16:31.720 --> 00:16:34.960
brand new use cases.

00:16:34.960 --> 00:16:36.730
Specifically, we're
adding a new type

00:16:36.730 --> 00:16:40.160
of KeyStore called StrongBox.

00:16:40.160 --> 00:16:43.710
StrongBox is built using a
tamper-resistant hardware,

00:16:43.710 --> 00:16:47.880
like a secure element,
that has isolated CPU, RAM,

00:16:47.880 --> 00:16:49.267
and secure storage.

00:16:49.267 --> 00:16:50.850
The fact that it has
its own dedicated

00:16:50.850 --> 00:16:53.520
CPU and RAM is pretty
important, because it makes it

00:16:53.520 --> 00:16:57.160
so that it's resistant to
shared resource attacks.

00:16:57.160 --> 00:16:59.190
For example, many of the
high profile hardware

00:16:59.190 --> 00:17:00.980
attacks that we've
heard about recently,

00:17:00.980 --> 00:17:03.300
StrongBox is resistant
to those, as well as

00:17:03.300 --> 00:17:04.800
resistant to side
channel attacks,

00:17:04.800 --> 00:17:07.710
like timing attacks, as
well as physical attacks,

00:17:07.710 --> 00:17:11.140
like glitching the power line.

00:17:11.140 --> 00:17:13.380
So when we look at the
KeyStore types that

00:17:13.380 --> 00:17:15.510
are available on
Android, there are now

00:17:15.510 --> 00:17:18.565
three types of KeyStore.

00:17:18.565 --> 00:17:20.849
On older Android
devices, KeyStore

00:17:20.849 --> 00:17:23.369
was typically implemented using
the Android operating system

00:17:23.369 --> 00:17:24.619
directly.

00:17:24.619 --> 00:17:27.690
On new Android devices that ship
with Android Nougat and above,

00:17:27.690 --> 00:17:30.870
KeyStore was implemented using
the TE, the Trusted Execution

00:17:30.870 --> 00:17:31.980
Environment.

00:17:31.980 --> 00:17:34.710
And now with Android P, we're
providing a new KeyStore

00:17:34.710 --> 00:17:39.330
called StrongBox that can
run alongside it together

00:17:39.330 --> 00:17:41.910
with the existing
KeyStore and the TE.

00:17:41.910 --> 00:17:46.200
StrongBox is resistant to the
widest variety of attacks,

00:17:46.200 --> 00:17:48.180
and is really
well-suited if you have

00:17:48.180 --> 00:17:50.220
a use case that requires
strong protection

00:17:50.220 --> 00:17:51.850
for your private keys.

00:17:51.850 --> 00:17:53.490
Now, the caveat here
is that because it

00:17:53.490 --> 00:17:55.660
does require new
hardware, StrongBox

00:17:55.660 --> 00:17:57.970
will be available on
only some new devices

00:17:57.970 --> 00:18:02.850
that ship with Android P.

00:18:02.850 --> 00:18:04.860
To use StrongBox, it's
fairly straightforward.

00:18:04.860 --> 00:18:06.690
When you create
your KeyStore key,

00:18:06.690 --> 00:18:10.350
set a new flag to request that
the key be backed by StrongBox.

00:18:10.350 --> 00:18:11.790
If the device
supports StrongBox,

00:18:11.790 --> 00:18:14.102
then everything
succeeds and goes well.

00:18:14.102 --> 00:18:15.810
If the device does
not support StrongBox,

00:18:15.810 --> 00:18:19.850
you'll get a StrongBox
unavailable exception.

00:18:19.850 --> 00:18:22.130
So to summarize,
StrongBox is implemented

00:18:22.130 --> 00:18:25.440
using tamper-resistant
hardware, like a secure element.

00:18:25.440 --> 00:18:28.160
Secure elements are the gold
standard for hardware security,

00:18:28.160 --> 00:18:29.810
and this is the
first time that we're

00:18:29.810 --> 00:18:35.000
offering a generic API to access
this type of secure hardware

00:18:35.000 --> 00:18:36.640
for key management.

00:18:36.640 --> 00:18:40.130
This feature, as well as the
Protected Conformation API,

00:18:40.130 --> 00:18:42.800
are really pushing the boundary
for secure hardware support

00:18:42.800 --> 00:18:43.487
on mobile.

00:18:43.487 --> 00:18:45.320
And we're really excited
about the use cases

00:18:45.320 --> 00:18:46.069
that this enables.

00:18:49.730 --> 00:18:52.350
So protecting your
private keys is

00:18:52.350 --> 00:18:54.014
one thing that apps need to do.

00:18:54.014 --> 00:18:55.680
Another thing that
apps often need to do

00:18:55.680 --> 00:18:58.950
is to make sure that the
right user is present.

00:18:58.950 --> 00:19:02.040
When you look at a typical
Android device, especially

00:19:02.040 --> 00:19:04.240
one that's up to date
and fully patched,

00:19:04.240 --> 00:19:06.240
the most likely
security incident

00:19:06.240 --> 00:19:08.850
to happen to that
device is not malware,

00:19:08.850 --> 00:19:11.010
but rather getting
lost or stolen.

00:19:11.010 --> 00:19:13.800
And so a lock screen is
very important for Android.

00:19:13.800 --> 00:19:15.660
Make sure you set a lock screen.

00:19:15.660 --> 00:19:18.400
And also, as an
app developer, make

00:19:18.400 --> 00:19:22.710
sure that you do gate-sensitive
access on user presence,

00:19:22.710 --> 00:19:24.575
on user authentication.

00:19:28.460 --> 00:19:31.180
So in Android P, we added
a few different features

00:19:31.180 --> 00:19:33.310
to help app developers
do that, starting

00:19:33.310 --> 00:19:36.860
with keyguard-bound keys.

00:19:36.860 --> 00:19:39.120
Keyguard-bound keys
are KeyStore keys

00:19:39.120 --> 00:19:41.670
that are well-suited
for protecting

00:19:41.670 --> 00:19:45.470
very sensitive data that you
store directly on the device.

00:19:45.470 --> 00:19:47.850
Like the name implies,
keyguard-bound keys

00:19:47.850 --> 00:19:50.100
have their functionality
tied to the keyguard, which

00:19:50.100 --> 00:19:52.080
is the lock screen on Android.

00:19:52.080 --> 00:19:56.360
And so these keys can be used
to encrypt data at any time,

00:19:56.360 --> 00:19:58.440
and can be used to
decrypt data only

00:19:58.440 --> 00:20:00.610
when the device is unlocked.

00:20:00.610 --> 00:20:02.220
And so the lifecycle
of these keys

00:20:02.220 --> 00:20:05.170
are tied to the lifecycle
of the lock screen.

00:20:05.170 --> 00:20:07.590
For example, if you have
very sensitive, very

00:20:07.590 --> 00:20:10.320
confidential enterprise
data or very private

00:20:10.320 --> 00:20:12.030
health and fitness
data, you might

00:20:12.030 --> 00:20:14.220
want to encrypt it with
a keyguard-bound key

00:20:14.220 --> 00:20:16.920
before you store it to disk,
so that if that device does

00:20:16.920 --> 00:20:19.770
get lost or stolen,
as long as there's

00:20:19.770 --> 00:20:22.800
a lock screen on that device,
it's now a little bit harder

00:20:22.800 --> 00:20:25.260
for an attacker to access
the sensitive data.

00:20:29.240 --> 00:20:31.850
To use a keyguard-bound
key, it's

00:20:31.850 --> 00:20:33.140
also fairly straightforward.

00:20:33.140 --> 00:20:34.970
When you create
your KeyStore key,

00:20:34.970 --> 00:20:39.110
set a flag to require that
the device be unlocked

00:20:39.110 --> 00:20:40.790
to use it for decryption.

00:20:40.790 --> 00:20:43.340
Then when you create
your cipher objects,

00:20:43.340 --> 00:20:46.080
you can create it for
encryption at any time.

00:20:46.080 --> 00:20:47.690
And you can create
it for decryption

00:20:47.690 --> 00:20:50.270
only when the
device is unlocked.

00:20:50.270 --> 00:20:53.580
So fairly straightforward,
fairly simple.

00:20:53.580 --> 00:20:55.910
Now, what if your
device has been properly

00:20:55.910 --> 00:20:59.300
unlocked, but you want to check
for user authentication one

00:20:59.300 --> 00:21:02.570
more time, let's say, before
a very sensitive action

00:21:02.570 --> 00:21:04.200
like a payment happens?

00:21:04.200 --> 00:21:06.930
This is where
BiometricPrompt comes in.

00:21:06.930 --> 00:21:08.910
BiometricPrompt
is our replacement

00:21:08.910 --> 00:21:10.422
for FingerprintManager.

00:21:10.422 --> 00:21:12.630
Now, a lot of apps today
are using FingerprintManager

00:21:12.630 --> 00:21:17.190
to reauthenticate the user using
fingerprints one more time.

00:21:17.190 --> 00:21:20.080
Now, FingerprintManager
had a few limitations.

00:21:20.080 --> 00:21:23.200
One is it only works
for fingerprint.

00:21:23.200 --> 00:21:26.140
A lot of devices today are
starting to support face, iris,

00:21:26.140 --> 00:21:28.100
and other biometric modalities.

00:21:28.100 --> 00:21:30.806
And so with BiometricPrompt,
we do support

00:21:30.806 --> 00:21:31.930
more than just fingerprint.

00:21:31.930 --> 00:21:33.820
We support several
different modalities.

00:21:33.820 --> 00:21:36.550
And it will automatically
pick the right modality

00:21:36.550 --> 00:21:40.180
for that user and
for that device.

00:21:40.180 --> 00:21:41.760
Another benefit
of BiometricPrompt

00:21:41.760 --> 00:21:44.160
is that it uses
a standard system

00:21:44.160 --> 00:21:47.070
UI, which is really nice from
a user experience perspective

00:21:47.070 --> 00:21:50.670
to show the user a standard
UI when they're making

00:21:50.670 --> 00:21:53.190
a security-relevant decision.

00:21:53.190 --> 00:21:56.922
Also, it sets us up well for
future advances in sensor

00:21:56.922 --> 00:21:59.130
technology when you have,
for example, an end display

00:21:59.130 --> 00:22:00.360
fingerprint sensor.

00:22:00.360 --> 00:22:02.190
It's much easier for
the OEM to customize

00:22:02.190 --> 00:22:05.520
this UI to tell the user exactly
where to put their finger,

00:22:05.520 --> 00:22:07.020
and less scalable
for an app to have

00:22:07.020 --> 00:22:10.820
to create device-specific UI.

00:22:10.820 --> 00:22:13.120
We know that
BiometricPrompt is quite

00:22:13.120 --> 00:22:14.920
different from
FingerprintManager.

00:22:14.920 --> 00:22:17.470
And so to ease the
pain of migration,

00:22:17.470 --> 00:22:19.840
we're also providing
a support library.

00:22:19.840 --> 00:22:23.980
And so apps will be able to
call the one API in that support

00:22:23.980 --> 00:22:26.950
library, and that will use
biometric prompt on Android P

00:22:26.950 --> 00:22:28.660
devices, and fall
back gracefully

00:22:28.660 --> 00:22:30.440
to FingerprintManager
on older devices.

00:22:35.030 --> 00:22:37.880
To use BiometricPrompts,
create the builder object,

00:22:37.880 --> 00:22:40.110
and pass it, the
title, and subtitle

00:22:40.110 --> 00:22:42.080
in these kinds of properties.

00:22:42.080 --> 00:22:44.300
Then call the
authenticate method

00:22:44.300 --> 00:22:49.490
on the prompt to create to
show the authentication prompt.

00:22:49.490 --> 00:22:52.610
We do recommend that you
pass in the crypto object,

00:22:52.610 --> 00:22:54.950
because that's how you tie
successful authentication

00:22:54.950 --> 00:22:59.702
attempts to a subsequent
cryptographic operational.

00:23:03.350 --> 00:23:06.390
All right, so biometric
prompt works really well

00:23:06.390 --> 00:23:09.310
when your users
try to authenticate

00:23:09.310 --> 00:23:11.050
your native Android app.

00:23:11.050 --> 00:23:14.430
Now, what if the users actually
go into your website in Chrome?

00:23:14.430 --> 00:23:16.500
How do you authenticate
them there?

00:23:16.500 --> 00:23:20.396
This is where a WebAuthn
and FIDO2 come in.

00:23:20.396 --> 00:23:24.770
Coming later this year
in Q4, Chrome on Android

00:23:24.770 --> 00:23:28.040
will support
WebAuthn, which means

00:23:28.040 --> 00:23:30.020
if the user's going
to your website,

00:23:30.020 --> 00:23:32.390
they can now use
their lock screen

00:23:32.390 --> 00:23:35.960
or their biometric signals to
authenticate to your website.

00:23:35.960 --> 00:23:38.370
And I think this is very
useful because, for example,

00:23:38.370 --> 00:23:40.340
if you like to buy
things on the web,

00:23:40.340 --> 00:23:42.860
PayPal now actually has
a demo running where

00:23:42.860 --> 00:23:46.370
you can use your fingerprints
to authenticate to PayPal

00:23:46.370 --> 00:23:50.382
and use that to
make your purchase.

00:23:50.382 --> 00:23:52.180
And so that's a
lot more convenient

00:23:52.180 --> 00:23:53.960
than typing in your
password every time

00:23:53.960 --> 00:23:56.330
you go to PayPal to make
a purchase on the web.

00:24:00.037 --> 00:24:02.120
So then to summarize the
several different methods

00:24:02.120 --> 00:24:06.240
that we talked about to gate
access based on authentication.

00:24:06.240 --> 00:24:08.040
First, with
keyguard-bound keys, you

00:24:08.040 --> 00:24:11.820
can tie data access to the
lifecycle of the lock screen.

00:24:11.820 --> 00:24:14.370
If the user has already
unlocked the screen

00:24:14.370 --> 00:24:16.870
and you want to
reauthenticate the user,

00:24:16.870 --> 00:24:19.350
then you can use BiometricPrompt
to show the system

00:24:19.350 --> 00:24:22.500
UI to prompt for biometric.

00:24:22.500 --> 00:24:26.040
And finally, if that user is
going to your website instead

00:24:26.040 --> 00:24:28.650
of your native app,
you can use WebAuthn

00:24:28.650 --> 00:24:30.720
to authenticate the
user via fingerprint

00:24:30.720 --> 00:24:31.910
in Chrome on Android.

00:24:35.290 --> 00:24:37.560
OK, now that you've determined
it's the right user,

00:24:37.560 --> 00:24:41.130
let's switch gears one more
time to talk about integrity.

00:24:41.130 --> 00:24:44.850
A lot of apps really
need to ensure

00:24:44.850 --> 00:24:46.380
the integrity of
their data as well

00:24:46.380 --> 00:24:48.910
as the integrity of the device
that they're running on.

00:24:48.910 --> 00:24:51.730
So how do we do this?

00:24:51.730 --> 00:24:54.130
In Android P, to
help you protect

00:24:54.130 --> 00:24:56.300
the integrity of
your data in transit,

00:24:56.300 --> 00:24:59.060
we're going to require
TLS by default.

00:24:59.060 --> 00:25:03.910
So for all new apps that
target the P API level,

00:25:03.910 --> 00:25:06.070
the system will
throw an exception

00:25:06.070 --> 00:25:10.220
if the app sends
data in the clear.

00:25:10.220 --> 00:25:12.340
Using TLS should be a
no-brainer for apps today,

00:25:12.340 --> 00:25:14.950
because it protects the
privacy of your users,

00:25:14.950 --> 00:25:16.450
and it also protects
your content

00:25:16.450 --> 00:25:19.330
from being modified in
transit, whether it's

00:25:19.330 --> 00:25:22.270
injection of unwanted ads,
or injection of tracking

00:25:22.270 --> 00:25:25.060
identifiers, or
especially formatted data

00:25:25.060 --> 00:25:27.700
to exploit a
weakness in your app.

00:25:27.700 --> 00:25:29.280
So you should always encrypt.

00:25:29.280 --> 00:25:32.370
Now, if you're connecting to
a legacy website that has not

00:25:32.370 --> 00:25:35.340
migrated to TLS yet,
then you can still

00:25:35.340 --> 00:25:38.490
opt out of specific domains by
updating your network security

00:25:38.490 --> 00:25:39.540
config.

00:25:39.540 --> 00:25:41.580
So do visit the
website on this slide

00:25:41.580 --> 00:25:46.327
to learn more about customizing
TLS enforcement for your app.

00:25:46.327 --> 00:25:48.160
Now, before you run off
to change your code,

00:25:48.160 --> 00:25:51.030
we have one more
piece of good news.

00:25:51.030 --> 00:25:55.230
A lot of apps care about FIPS
cryptographic compliance,

00:25:55.230 --> 00:25:57.640
because it's really
important and regulated

00:25:57.640 --> 00:25:59.770
industries and the government.

00:25:59.770 --> 00:26:02.820
So we're really
happy that BoringSSL,

00:26:02.820 --> 00:26:06.870
which is used to secure
SSL traffic on Android,

00:26:06.870 --> 00:26:11.520
recently received CAVP
certificates from NIST

00:26:11.520 --> 00:26:14.890
for many FIPS-approved
algorithms.

00:26:14.890 --> 00:26:17.440
And so this means that
developers targeting

00:26:17.440 --> 00:26:19.240
regulated industries
now basically

00:26:19.240 --> 00:26:21.140
have automatic FIPS
compliance built in.

00:26:21.140 --> 00:26:22.514
So we're very
excited about that.

00:26:27.000 --> 00:26:30.200
All right, so another topic
in the integrity section

00:26:30.200 --> 00:26:32.062
that developers
often care about is,

00:26:32.062 --> 00:26:33.770
how do I make sure
that the device itself

00:26:33.770 --> 00:26:35.170
has not been tampered with?

00:26:35.170 --> 00:26:38.350
The device itself
is still healthy?

00:26:38.350 --> 00:26:41.600
In Android O, we introduced a
feature called key attestation.

00:26:41.600 --> 00:26:44.907
And it's been updated in Android
P. Key attestation allows

00:26:44.907 --> 00:26:46.490
you to get a signed
statement directly

00:26:46.490 --> 00:26:50.390
from the hardware itself,
from StrongBox, from TE

00:26:50.390 --> 00:26:52.790
about the state of the device
and about the properties

00:26:52.790 --> 00:26:54.980
of your private keys.

00:26:54.980 --> 00:26:57.130
So for example, key
attestation can tell you

00:26:57.130 --> 00:27:00.610
whether the device passed
verified boot, whether it's

00:27:00.610 --> 00:27:04.000
running a recent security patch,
whether the private keys are

00:27:04.000 --> 00:27:06.640
protected by TE or StrongBox.

00:27:06.640 --> 00:27:09.730
Another thing that key
attestation will return to you

00:27:09.730 --> 00:27:12.130
on compatible
devices on Android P

00:27:12.130 --> 00:27:15.610
is the firmware hash that
the device is running.

00:27:15.610 --> 00:27:18.130
So this is the digest
of the operating system

00:27:18.130 --> 00:27:20.500
that you're running
at this time.

00:27:20.500 --> 00:27:22.850
Think of this as
transparency-enabled verified

00:27:22.850 --> 00:27:24.200
boot.

00:27:24.200 --> 00:27:25.790
What this means
is that if you're

00:27:25.790 --> 00:27:28.610
running a firmware digest
that's the same as that

00:27:28.610 --> 00:27:30.620
of a known good
version, then you're

00:27:30.620 --> 00:27:33.530
actually running a bit
for bit identical version

00:27:33.530 --> 00:27:36.410
of the operating system
as a known good version.

00:27:36.410 --> 00:27:37.880
So that's a really
powerful thing

00:27:37.880 --> 00:27:39.620
to know about what
you're running.

00:27:39.620 --> 00:27:41.600
And it's really important for a
tightly controlled environment,

00:27:41.600 --> 00:27:44.030
like enterprises, to know
that the operating system

00:27:44.030 --> 00:27:49.080
that you're running is an exact
copy of a known good version.

00:27:49.080 --> 00:27:51.840
For users of the
SafetyNet attestation API,

00:27:51.840 --> 00:27:54.070
the implementation of that
will call the platform

00:27:54.070 --> 00:27:56.220
key attestation
API under the hood.

00:27:56.220 --> 00:27:59.400
So you [? would ?] be able
to take advantage of this

00:27:59.400 --> 00:28:01.870
without any changes
to your code.

00:28:01.870 --> 00:28:04.440
Now, in some cases, if you
want to get more information

00:28:04.440 --> 00:28:07.380
from the API than what's
returned by SafetyNet,

00:28:07.380 --> 00:28:09.840
you can still call the key
attestation API directly.

00:28:14.400 --> 00:28:16.510
Now, last, but certainly
not least, privacy.

00:28:16.510 --> 00:28:19.630
Privacy is an important
area to security.

00:28:19.630 --> 00:28:21.570
We actually talked about
privacy quite a bit

00:28:21.570 --> 00:28:23.320
already when we talked
about, for example,

00:28:23.320 --> 00:28:28.110
the TLS by default
feature coming in Android.

00:28:28.110 --> 00:28:30.800
But there are a few
other privacy features

00:28:30.800 --> 00:28:32.800
that are in Android P
that we want to cover now.

00:28:36.120 --> 00:28:39.390
First, this is probably one of
my favorite features, sensor

00:28:39.390 --> 00:28:43.980
access only in the foreground.

00:28:43.980 --> 00:28:49.050
Running on an Android P device,
regardless of your API level,

00:28:49.050 --> 00:28:51.120
if your app is in the
background and idle,

00:28:51.120 --> 00:28:54.106
you will no longer be able to
access the camera, microphone,

00:28:54.106 --> 00:28:54.605
or sensors.

00:28:58.475 --> 00:29:00.100
This behavior now is
slightly different

00:29:00.100 --> 00:29:02.140
based on the exact
characteristics of the API

00:29:02.140 --> 00:29:03.810
that you're targeting.

00:29:03.810 --> 00:29:07.330
So for example, with
the microphone API,

00:29:07.330 --> 00:29:09.250
you will get
silence when you try

00:29:09.250 --> 00:29:13.150
to access a microphone from
the background in idle.

00:29:13.150 --> 00:29:15.010
With the camera
API, it will behave

00:29:15.010 --> 00:29:18.400
as if you were preempted by a
higher priority camera client.

00:29:18.400 --> 00:29:21.520
With sensors, it depends on
whether the sensor returns data

00:29:21.520 --> 00:29:24.040
continuously or via callback.

00:29:24.040 --> 00:29:25.690
The bottom line is
that if your app is

00:29:25.690 --> 00:29:27.910
in the background and
idle, you can no longer

00:29:27.910 --> 00:29:30.700
access user data from sensors.

00:29:30.700 --> 00:29:35.275
Now, if you need to access the
camera, microphone, or sensors

00:29:35.275 --> 00:29:38.380
and you're in the background,
create a foreground service

00:29:38.380 --> 00:29:41.950
with a persistent user
visible notification.

00:29:41.950 --> 00:29:45.610
So that gives users a lot more
control and more transparency

00:29:45.610 --> 00:29:48.380
into which apps have access
to their sensors at that time.

00:29:51.300 --> 00:29:53.350
To start a foreground
service, create

00:29:53.350 --> 00:29:55.980
that persistent
notification first, and then

00:29:55.980 --> 00:30:00.100
call the startForeground method,
and pass in that notification.

00:30:05.010 --> 00:30:10.980
All right, besides restricted
background access to sensors,

00:30:10.980 --> 00:30:15.960
we've also added a lot more
user control over your data.

00:30:15.960 --> 00:30:18.270
So Android is the
first major operating

00:30:18.270 --> 00:30:21.960
system to have DNS over
TLS support built right in.

00:30:21.960 --> 00:30:25.290
And so your DNS queries will
be redirected to a trusted

00:30:25.290 --> 00:30:27.044
resolver of your choice.

00:30:27.044 --> 00:30:28.710
That means that third
parties on the web

00:30:28.710 --> 00:30:32.580
can no longer monitor or
manipulate your DNS traffic.

00:30:32.580 --> 00:30:36.870
Now, if your default DNS
resolver already supports it,

00:30:36.870 --> 00:30:41.140
then we will automatically
encrypt your data.

00:30:41.140 --> 00:30:43.900
We did this in collaboration
with Alphabet's jigsaw team,

00:30:43.900 --> 00:30:46.462
who are working on many other
initiatives in this area.

00:30:46.462 --> 00:30:47.920
And so we're really
looking forward

00:30:47.920 --> 00:30:50.614
to many new developments here.

00:30:50.614 --> 00:30:52.030
Another cool feature
that we added

00:30:52.030 --> 00:30:56.570
an Android P in the privacy
space is lockdown mode.

00:30:56.570 --> 00:30:58.190
So lockdown mode
is useful if you're

00:30:58.190 --> 00:31:00.260
in a situation where
you may temporarily

00:31:00.260 --> 00:31:03.200
lose access to your device.

00:31:03.200 --> 00:31:05.330
Let's say you need to hand
it over for inspection

00:31:05.330 --> 00:31:07.070
at a security checkpoint.

00:31:07.070 --> 00:31:09.440
So at that time, you
can put your device

00:31:09.440 --> 00:31:13.335
into lockdown mode,
which is now in a state

00:31:13.335 --> 00:31:15.210
where only your knowledge
factor, your pinpad

00:31:15.210 --> 00:31:18.047
and password can be used
to unlock the device.

00:31:18.047 --> 00:31:19.880
And so your fingerprint
and other biometrics

00:31:19.880 --> 00:31:21.260
will be disabled.

00:31:21.260 --> 00:31:24.230
Your Smart Lock
will be disabled.

00:31:24.230 --> 00:31:27.570
In fact, notifications will no
longer show on the lock screen.

00:31:27.570 --> 00:31:30.540
So you would now have
much higher assurances

00:31:30.540 --> 00:31:32.540
on the state of the lock
screen, on the security

00:31:32.540 --> 00:31:36.200
of a lock screen when the device
is temporarily out of sight.

00:31:38.790 --> 00:31:41.580
So that was a quick overview
of the features that

00:31:41.580 --> 00:31:45.270
are coming with Android P.
There's a lot more that we

00:31:45.270 --> 00:31:47.130
didn't have time to cover.

00:31:47.130 --> 00:31:50.700
And so please do
give us your feedback

00:31:50.700 --> 00:31:53.370
at google.com/io/schedule.

00:31:53.370 --> 00:31:55.759
And send us an email,
security@android.com.

00:31:55.759 --> 00:31:57.550
Thank you for coming,
and have a great day.

00:31:57.550 --> 00:32:02.038
[MUSIC PLAYING]

