WEBVTT
Kind: captions
Language: en

00:00:00.300 --> 00:00:01.590
TOR NORBYE: Hello, everyone.

00:00:01.590 --> 00:00:05.060
Welcome to the expert's guide
to Android development tools.

00:00:05.060 --> 00:00:07.510
I'm Tor Norbye, tech
lead for Android Studio.

00:00:07.510 --> 00:00:10.270
And with me on stage here, I
have a number of key members

00:00:10.270 --> 00:00:11.550
from the Android Studio team.

00:00:11.550 --> 00:00:13.485
So do you want to
introduce yourselves?

00:00:13.485 --> 00:00:14.610
ESTEBAN DE LA CANAL: Hello.

00:00:14.610 --> 00:00:15.554
I'm Esteban.

00:00:15.554 --> 00:00:16.916
SIVA VELUSAMY: Hi, I'm Siva.

00:00:16.916 --> 00:00:18.450
I work on the debugger.

00:00:18.450 --> 00:00:20.125
KATHRYN SHIH: Hi, I'm Kathryn.

00:00:20.125 --> 00:00:21.660
JEROME DOCHEZ: And
hi, I'm Jerome,

00:00:21.660 --> 00:00:22.921
network on the build system.

00:00:22.921 --> 00:00:24.420
TOR NORBYE: So the
way this is going

00:00:24.420 --> 00:00:27.130
to work is that we're
going to show you some

00:00:27.130 --> 00:00:29.500
of our favorite features and
some features that we think

00:00:29.500 --> 00:00:33.110
you may not know but that you'll
find very useful once you do.

00:00:33.110 --> 00:00:34.750
If you're an expert
Studio user, you

00:00:34.750 --> 00:00:36.780
might know some of these things.

00:00:36.780 --> 00:00:38.410
We want to make
sure that everyone

00:00:38.410 --> 00:00:40.951
has heard some of these secrets,
even if you already know it.

00:00:40.951 --> 00:00:42.940
You can be very proud if you do.

00:00:42.940 --> 00:00:45.310
So we hope that you'll
learn something from this.

00:00:45.310 --> 00:00:48.330
And so first we'll have an
editor demo from Esteban.

00:00:48.330 --> 00:00:50.510
And then Siva is going to
be showing the debugger.

00:00:50.510 --> 00:00:53.620
Kathryn, native tools, and
Jerome at the end with the

00:00:53.620 --> 00:00:54.630
build system.

00:00:54.630 --> 00:00:56.255
So with that, I'm
going to turn it over

00:00:56.255 --> 00:00:58.725
to Esteban, who's going to
be showing the source editor.

00:00:58.725 --> 00:01:00.544
ESTEBAN DE LA CANAL:
Hello, everyone.

00:01:00.544 --> 00:01:02.460
We're going to switch
to the demo machine now.

00:01:06.780 --> 00:01:07.710
Can you see?

00:01:07.710 --> 00:01:08.920
That's good.

00:01:08.920 --> 00:01:10.570
So in the next 10
minutes or so, I'm

00:01:10.570 --> 00:01:12.480
going to show you 10
of my favorite features

00:01:12.480 --> 00:01:13.130
of the editor.

00:01:13.130 --> 00:01:15.984
You know how coding
all day is, right?

00:01:15.984 --> 00:01:17.400
One of the things
you try to avoid

00:01:17.400 --> 00:01:19.000
is touching the
mouse, which is, like,

00:01:19.000 --> 00:01:21.350
10 miles away from
where you are,

00:01:21.350 --> 00:01:23.300
and learning all the shortcuts.

00:01:23.300 --> 00:01:27.540
So IntelliJ has several
configurations of shortcuts.

00:01:27.540 --> 00:01:30.050
I will have, when I go through
the demo, all the shortcuts

00:01:30.050 --> 00:01:31.520
written down there.

00:01:31.520 --> 00:01:33.450
But there's one tip.

00:01:33.450 --> 00:01:35.740
If you're a
multi-platform, there

00:01:35.740 --> 00:01:37.500
are two different
shortcut setups

00:01:37.500 --> 00:01:40.340
for Mac, one that
is Mac-friendly

00:01:40.340 --> 00:01:41.840
and the other one
that is compatible

00:01:41.840 --> 00:01:42.714
with other platforms.

00:01:42.714 --> 00:01:45.389
So if you hear me speaking
shortcuts out loud,

00:01:45.389 --> 00:01:47.180
I'm probably going to
be using the one that

00:01:47.180 --> 00:01:49.860
is common across
all the platforms.

00:01:49.860 --> 00:01:51.300
So let's begin.

00:01:51.300 --> 00:01:53.360
Just before we do
the editor part,

00:01:53.360 --> 00:01:56.980
there are two tips
that I want to show you

00:01:56.980 --> 00:01:58.930
for configuring the general ID.

00:01:58.930 --> 00:02:01.890
The first one is the
command line launcher.

00:02:01.890 --> 00:02:04.620
So I don't know if you
guys know, but you can go

00:02:04.620 --> 00:02:07.000
and say, create
command line launcher.

00:02:07.000 --> 00:02:12.420
And that will create this file
that you can go from anywhere

00:02:12.420 --> 00:02:13.430
to start Studio.

00:02:13.430 --> 00:02:13.930
That's cool.

00:02:13.930 --> 00:02:14.430
It's handy.

00:02:14.430 --> 00:02:16.471
You're in a console and
you want to start Studio,

00:02:16.471 --> 00:02:17.470
you just type Studio.

00:02:17.470 --> 00:02:19.200
That's pretty neat.

00:02:19.200 --> 00:02:22.035
But it does more
things than that.

00:02:22.035 --> 00:02:22.910
So I just created it.

00:02:22.910 --> 00:02:26.410
I need to put in the password.

00:02:26.410 --> 00:02:27.114
And done.

00:02:27.114 --> 00:02:28.405
I'm going to go to the console.

00:02:33.320 --> 00:02:37.040
If I do studio dash dash
help, that's the shortcut

00:02:37.040 --> 00:02:37.930
that I just created.

00:02:37.930 --> 00:02:40.700
But you can see that there are
more options than just studio.

00:02:40.700 --> 00:02:43.240
There's div and there's merge.

00:02:43.240 --> 00:02:47.330
I'm have a div
that I ran before.

00:02:47.330 --> 00:02:51.072
This actually opens studios div.

00:02:51.072 --> 00:02:52.220
Where is it?

00:02:52.220 --> 00:02:52.870
It's gone.

00:02:55.810 --> 00:02:58.070
This is one of the best
divving tools that I've used,

00:02:58.070 --> 00:03:00.200
and it's really cool to be able
to have it as a command line

00:03:00.200 --> 00:03:00.700
tool.

00:03:00.700 --> 00:03:03.332
You can set it up to your
[INAUDIBLE] tool or whatever,

00:03:03.332 --> 00:03:05.040
and then you'll be
using this that you'll

00:03:05.040 --> 00:03:08.390
be hopefully familiar with, and
you can use this all the time.

00:03:08.390 --> 00:03:12.030
You can also do merge from the
command line tool and it works.

00:03:12.030 --> 00:03:14.480
So that's one handy
thing you have.

00:03:14.480 --> 00:03:19.030
The next one I wanted to show
you is you have a large project

00:03:19.030 --> 00:03:22.010
and effectively, you run
out of memory in the Studio

00:03:22.010 --> 00:03:23.200
and things go bad.

00:03:23.200 --> 00:03:26.190
So if you wanted to edit
the memory settings,

00:03:26.190 --> 00:03:28.481
you need to go to
a VM options file.

00:03:28.481 --> 00:03:30.480
How many of you have been
to the VM options file

00:03:30.480 --> 00:03:31.438
and changed the memory?

00:03:31.438 --> 00:03:34.427
OK, that's a lot of people.

00:03:34.427 --> 00:03:36.260
The main thing is that,
where was that file?

00:03:36.260 --> 00:03:38.780
You're going to set
things, slash, whatever.

00:03:38.780 --> 00:03:42.610
So there is an option here that
was recently added that you can

00:03:42.610 --> 00:03:45.390
say, edit custom VM options.

00:03:45.390 --> 00:03:47.460
You guys know that you
should not edit VM options

00:03:47.460 --> 00:03:49.449
inside Studio installation.

00:03:49.449 --> 00:03:51.990
The next time you update, it's
going to say, what did you do?

00:03:51.990 --> 00:03:53.810
So you do this one.

00:03:53.810 --> 00:03:56.370
And it asks, do you want
to create a custom one?

00:03:56.370 --> 00:03:58.730
And it opens it up for
you and you can go and set

00:03:58.730 --> 00:04:01.730
all the flags you want there.

00:04:01.730 --> 00:04:04.390
If you want to know
where it is-- someone

00:04:04.390 --> 00:04:06.130
was super-excited about this.

00:04:06.130 --> 00:04:09.070
If you want to know where
it is, you can press Alt-F1,

00:04:09.070 --> 00:04:11.700
and you can reveal this
file somewhere else.

00:04:11.700 --> 00:04:13.600
For example, you can
reveal it in Finder.

00:04:13.600 --> 00:04:16.209
Just pressing 8 or going down
there will open the finder

00:04:16.209 --> 00:04:19.870
to where this file is, and
you can do whatever you want.

00:04:22.294 --> 00:04:23.210
That's for VM options.

00:04:23.210 --> 00:04:24.584
So we have everything
set up now.

00:04:24.584 --> 00:04:27.350
And now we're going to
go into the editing tips.

00:04:27.350 --> 00:04:30.440
These are my 10 favorite tips
of editing in Android Studio,

00:04:30.440 --> 00:04:32.540
powered by IntelliJ.

00:04:32.540 --> 00:04:35.690
The first one is
Control-Shift-J You

00:04:35.690 --> 00:04:38.350
guys know there are
shortcuts to join lines?

00:04:38.350 --> 00:04:40.880
Well, this one is a smart one.

00:04:40.880 --> 00:04:43.010
And if you're
joining strings, it

00:04:43.010 --> 00:04:46.648
actually removes the operations
and gives you the full string.

00:04:46.648 --> 00:04:48.750
KATHRYN SHIH: I think
you lost the ID.

00:04:48.750 --> 00:04:51.830
ESTEBAN DE LA CANAL: The ID.

00:04:51.830 --> 00:04:53.992
That's me.

00:04:53.992 --> 00:04:55.450
Can we go back to
the demo machine?

00:04:59.242 --> 00:05:00.783
KATHRYN SHIH: Try
pushing the button.

00:05:04.730 --> 00:05:07.152
ESTEBAN DE LA CANAL:
Let's do it again.

00:05:07.152 --> 00:05:09.360
I was saying talking about,
I'm looking at my screen.

00:05:09.360 --> 00:05:12.100
I hear it looks beautiful.

00:05:12.100 --> 00:05:14.750
Control-Shift-J is a smart join.

00:05:14.750 --> 00:05:17.300
And it removes the
plus operations

00:05:17.300 --> 00:05:18.510
when joining a string.

00:05:18.510 --> 00:05:20.800
So that's pretty handy.

00:05:20.800 --> 00:05:24.150
There is also the option of--
and this is quite powerful,

00:05:24.150 --> 00:05:27.930
if you open the intent
menu on a string,

00:05:27.930 --> 00:05:29.610
a string operation
will plus, there's

00:05:29.610 --> 00:05:31.305
an option to copy
the concatenation

00:05:31.305 --> 00:05:32.180
text to the keyboard.

00:05:32.180 --> 00:05:36.900
So IntelliJ figured out that all
the components here are static,

00:05:36.900 --> 00:05:38.985
all the [INAUDIBLE] values.

00:05:38.985 --> 00:05:41.360
And the full string has been
now copied to the clipboard,

00:05:41.360 --> 00:05:42.700
and I can paste it here.

00:05:42.700 --> 00:05:44.400
And it's the full thing.

00:05:44.400 --> 00:05:45.984
Operations have been done.

00:05:45.984 --> 00:05:49.320
[APPLAUSE]

00:05:49.320 --> 00:05:49.820
Thank you.

00:05:53.130 --> 00:05:55.250
The next one I wanted to
show is the difference

00:05:55.250 --> 00:05:57.950
between Enter and Tab.

00:05:57.950 --> 00:06:00.485
When you want to change a
function-- in this case,

00:06:00.485 --> 00:06:02.287
let's say we want to
compare two strings,

00:06:02.287 --> 00:06:03.870
and I'm calling the
function contains,

00:06:03.870 --> 00:06:05.161
but it should be equals, right?

00:06:05.161 --> 00:06:08.540
So I type E, it suggests equals.

00:06:08.540 --> 00:06:11.840
When I type enter, this happens.

00:06:11.840 --> 00:06:16.480
But you guys know that if you
type Tab instead of Enter,

00:06:16.480 --> 00:06:19.370
there you go.

00:06:19.370 --> 00:06:22.199
[APPLAUSE]

00:06:22.199 --> 00:06:24.490
That's a pretty handy one to
know because it's usually,

00:06:24.490 --> 00:06:27.086
you know, backspace, backspace.

00:06:27.086 --> 00:06:28.460
The next one I
wanted to show you

00:06:28.460 --> 00:06:32.310
is the powerful of the
context understanding

00:06:32.310 --> 00:06:35.787
that the IntelliJ editor has.

00:06:35.787 --> 00:06:37.120
This is a common pattern, right?

00:06:37.120 --> 00:06:37.911
You have an object.

00:06:37.911 --> 00:06:40.320
You say, is this object
the instance of something?

00:06:40.320 --> 00:06:43.350
If you're inside this
if, things happen.

00:06:43.350 --> 00:06:46.850
So if I do oh dot,
the suggestions I

00:06:46.850 --> 00:06:48.540
get there are not for object.

00:06:48.540 --> 00:06:49.680
Are for context.

00:06:49.680 --> 00:06:51.387
So the editor figured
that out and was

00:06:51.387 --> 00:06:52.970
able to give me all
those suggestions.

00:06:52.970 --> 00:06:57.860
And as soon as I choose one,
the casting is done for me.

00:06:57.860 --> 00:07:02.040
More than that, if you are
going to use context many times

00:07:02.040 --> 00:07:05.890
or oh many times,
opening 10 menu,

00:07:05.890 --> 00:07:10.021
it's suggesting to generate
the declaration for you.

00:07:10.021 --> 00:07:10.520
Done.

00:07:10.520 --> 00:07:12.978
It actually put the name of
the writer right on everything.

00:07:12.978 --> 00:07:13.910
Pretty handy, right?

00:07:13.910 --> 00:07:17.510
These tips are for you guys to
speed up coding. [INAUDIBLE]

00:07:17.510 --> 00:07:19.510
enter, go go go.

00:07:19.510 --> 00:07:23.720
So that's indents
inside an instance of.

00:07:23.720 --> 00:07:26.820
One of my favorite features
is multi-cursor support.

00:07:26.820 --> 00:07:30.820
And I'm going to show you
what I do with multi-cursors

00:07:30.820 --> 00:07:33.650
and how you can integrate
other features of IntelliJ

00:07:33.650 --> 00:07:36.000
when you have multi-cursors.

00:07:36.000 --> 00:07:39.100
So I have a list of
names here that I'm

00:07:39.100 --> 00:07:42.230
going to copy and paste
inside this function.

00:07:42.230 --> 00:07:43.670
And I want to log all of them.

00:07:43.670 --> 00:07:46.070
I want to just add a
log D to all of them.

00:07:46.070 --> 00:07:49.380
You know there is a
completion template for log D.

00:07:49.380 --> 00:07:56.050
So you can select one and
start spawning cursors

00:07:56.050 --> 00:07:58.156
on the next occurrence
of the same word.

00:07:58.156 --> 00:07:59.530
If there is one
that is repeated,

00:07:59.530 --> 00:08:01.240
you can use a
shortcut to skip it.

00:08:01.240 --> 00:08:02.380
And you keep going.

00:08:02.380 --> 00:08:05.360
And now I have all these
cursors that I can do

00:08:05.360 --> 00:08:06.741
many things at the same time.

00:08:06.741 --> 00:08:07.240
[APPLAUSE]

00:08:07.240 --> 00:08:09.340
Thanks.

00:08:09.340 --> 00:08:11.273
One thing, I can,
for example, say

00:08:11.273 --> 00:08:14.440
Log D. It suggest Log D.
I can use the template,

00:08:14.440 --> 00:08:18.420
and it puts it in all the
cursors at the same time.

00:08:18.420 --> 00:08:21.920
You can use selection per
word, start removing things

00:08:21.920 --> 00:08:22.955
like this, for example.

00:08:25.910 --> 00:08:27.410
I'm going to copy.

00:08:27.410 --> 00:08:30.970
When I copy here, it actually
has one keyboard per cursor.

00:08:30.970 --> 00:08:33.110
So when I copy, and I go
to the end, for example,

00:08:33.110 --> 00:08:34.640
and I want to-- let's say
this is an email that I

00:08:34.640 --> 00:08:35.348
want to complete.

00:08:35.348 --> 00:08:41.361
And I do gmail.com-- you can
see all the clipboards were

00:08:41.361 --> 00:08:41.860
different.

00:08:41.860 --> 00:08:44.250
And in each line, I
pasted a different thing.

00:08:44.250 --> 00:08:47.240
So I'm like coding at
10 times what I would

00:08:47.240 --> 00:08:49.972
be coding if it was one line.

00:08:49.972 --> 00:08:51.930
Another cool thing that
you can do with cursors

00:08:51.930 --> 00:08:55.920
is, I'm going to go
back to these words.

00:08:55.920 --> 00:08:58.020
I'm going to select
all the names.

00:08:58.020 --> 00:08:59.830
And you can use--
Command-Shift-A

00:08:59.830 --> 00:09:01.210
is a super powerful shortcut.

00:09:01.210 --> 00:09:03.640
If you want to take one
shortcut away from today,

00:09:03.640 --> 00:09:05.740
take Command-Shift-A.
That shows you

00:09:05.740 --> 00:09:08.659
you can choose any action there
and apply it where you are.

00:09:08.659 --> 00:09:10.200
So I'm going to use
[INAUDIBLE] case.

00:09:14.100 --> 00:09:14.680
Done.

00:09:14.680 --> 00:09:16.320
All the selections
have been changed.

00:09:16.320 --> 00:09:18.477
And I'm logging all the
names pretty quickly.

00:09:18.477 --> 00:09:21.461
[APPLAUSE]

00:09:21.461 --> 00:09:21.960
Cool.

00:09:25.636 --> 00:09:26.760
The next one is navigation.

00:09:29.870 --> 00:09:30.480
Pretty useful.

00:09:30.480 --> 00:09:31.050
Command-F12.

00:09:31.050 --> 00:09:35.720
It shows you all the
functions in your file.

00:09:35.720 --> 00:09:37.810
One thing that IntelliJ
that is super powerful

00:09:37.810 --> 00:09:39.480
is, on every menu,
even if you don't

00:09:39.480 --> 00:09:42.130
see that there is a search
box, there probably is one.

00:09:42.130 --> 00:09:46.752
Start typing, and things
happen, like this, right?

00:09:46.752 --> 00:09:48.210
So if you want to
go to a function,

00:09:48.210 --> 00:09:52.340
Command-F12, type a
few letters of it.

00:09:52.340 --> 00:09:53.480
Boom, you're gone.

00:09:53.480 --> 00:09:56.780
It is a shortcut to
go back to where you

00:09:56.780 --> 00:09:58.370
were in navigation shortcuts.

00:09:58.370 --> 00:10:00.453
There is an another cool
thing that our bookmarks.

00:10:00.453 --> 00:10:04.600
I use some of these very often.

00:10:04.600 --> 00:10:08.860
You can bookmark a line, but
this is not the powerful thing.

00:10:08.860 --> 00:10:10.150
In my opinion, it's this one.

00:10:10.150 --> 00:10:13.330
You can bookmark with
Control-Shift a number.

00:10:13.330 --> 00:10:16.050
And you can give functions
in different files a number.

00:10:16.050 --> 00:10:18.900
And then, by just pressing
Control and the number,

00:10:18.900 --> 00:10:21.680
you navigate there super fast.

00:10:21.680 --> 00:10:23.510
So this is quite handy.

00:10:23.510 --> 00:10:27.020
If you run out of numbers,
and you want to use letters,

00:10:27.020 --> 00:10:27.810
you can.

00:10:27.810 --> 00:10:29.330
I've never got that many.

00:10:29.330 --> 00:10:36.270
But you could use
Control-F11 on Windows.

00:10:36.270 --> 00:10:38.320
And it opens this menu.

00:10:38.320 --> 00:10:39.730
You can choose A, for example.

00:10:39.730 --> 00:10:40.438
And there you go.

00:10:40.438 --> 00:10:42.860
You bookmark with an A.

00:10:42.860 --> 00:10:45.360
To find them, there is this
menu that shows you all the ones

00:10:45.360 --> 00:10:47.180
that you have added.

00:10:47.180 --> 00:10:50.110
And you can press A.
And it takes you there.

00:10:50.110 --> 00:10:54.070
So that's bookmarks.

00:10:54.070 --> 00:10:55.887
And this one is pretty cool.

00:10:55.887 --> 00:10:58.220
You guys know that you can
extract a method in IntelliJ,

00:10:58.220 --> 00:10:58.799
right?

00:10:58.799 --> 00:10:59.590
So I'm going to go.

00:10:59.590 --> 00:11:00.840
This is a for loop
that I have there

00:11:00.840 --> 00:11:02.714
that I would like to be
in a separate method.

00:11:02.714 --> 00:11:03.970
So I go to the middle of it.

00:11:03.970 --> 00:11:06.340
And I used the
expression selection tool

00:11:06.340 --> 00:11:08.860
that it selects an
expression going up and out.

00:11:08.860 --> 00:11:10.430
So here I have the line.

00:11:10.430 --> 00:11:11.544
Now I have the block.

00:11:11.544 --> 00:11:12.710
Now I have the [? eighth ?].

00:11:12.710 --> 00:11:13.946
Now I have the for loop.

00:11:13.946 --> 00:11:15.320
You can go up and
down, depending

00:11:15.320 --> 00:11:17.340
on the configuration you have.

00:11:17.340 --> 00:11:18.800
And I selected the for loop.

00:11:18.800 --> 00:11:20.780
And now I'm going to
extract it to a method.

00:11:20.780 --> 00:11:21.980
Let's call method test.

00:11:24.570 --> 00:11:25.160
What happened?

00:11:25.160 --> 00:11:26.740
So the font there is too small.

00:11:26.740 --> 00:11:29.700
But it pretty much says,
hey, stop doing Cut and Paste

00:11:29.700 --> 00:11:32.100
and write the things properly,
because IntelliJ just

00:11:32.100 --> 00:11:33.610
detected another
instance of what

00:11:33.610 --> 00:11:35.821
I had in a different place.

00:11:35.821 --> 00:11:37.320
So it said, you had
the same method.

00:11:37.320 --> 00:11:38.626
Do you also want to extract it?

00:11:38.626 --> 00:11:40.450
It's not using the
same variables,

00:11:40.450 --> 00:11:42.380
but it figures out that
if the arguments are

00:11:42.380 --> 00:11:45.220
the free variables, it's
going to extract it.

00:11:45.220 --> 00:11:48.330
And both for loops are gone.

00:11:48.330 --> 00:11:49.560
And only one test method.

00:11:52.489 --> 00:11:53.780
That's the one I like the most.

00:11:53.780 --> 00:11:55.975
And you clapped on
the Tab versus Enter.

00:11:55.975 --> 00:11:57.450
This is weird.

00:11:57.450 --> 00:11:57.950
Perfect.

00:12:01.447 --> 00:12:04.530
So you know you can do, if, you
have an array or something you

00:12:04.530 --> 00:12:07.700
can iterate over, you
can do post completion

00:12:07.700 --> 00:12:09.135
and say, for example, for.

00:12:09.135 --> 00:12:11.650
And it generates
the for for you.

00:12:11.650 --> 00:12:18.940
You can also do for I. And this
generates the very familiar

00:12:18.940 --> 00:12:20.450
for loop that you guys know.

00:12:20.450 --> 00:12:27.490
And you can also do for r,
and it does the annoying

00:12:27.490 --> 00:12:30.160
reverse one for you too.

00:12:30.160 --> 00:12:32.880
There are so many of this.

00:12:32.880 --> 00:12:34.590
Just play around with them.

00:12:34.590 --> 00:12:36.220
For example, if
you want an object,

00:12:36.220 --> 00:12:38.011
to check [INAUDIBLE]
an object [INAUDIBLE],

00:12:38.011 --> 00:12:40.967
you can just post complete
an n, and it do it for you.

00:12:40.967 --> 00:12:42.050
And many others like this.

00:12:42.050 --> 00:12:45.230
If you want to know them,
just press Command-J. No,

00:12:45.230 --> 00:12:47.640
I didn't press
Command-J. And it offers

00:12:47.640 --> 00:12:49.230
a list of all the
completions that you

00:12:49.230 --> 00:12:50.482
could use on an object.

00:12:50.482 --> 00:12:51.940
And you can write
your own as well.

00:12:54.620 --> 00:12:56.464
Number eight that
is pretty useful

00:12:56.464 --> 00:12:57.880
is, when you have
a condition that

00:12:57.880 --> 00:12:59.671
is complicated, you
have a lot of Booleans,

00:12:59.671 --> 00:13:04.280
and you want to simplify
it, just check out

00:13:04.280 --> 00:13:07.420
what the indent menu has,
because it will have things

00:13:07.420 --> 00:13:08.770
that will probably help you.

00:13:08.770 --> 00:13:11.560
So let's say I want to
replace ors with ands,

00:13:11.560 --> 00:13:16.670
and this is the result. Or
I want to split into two ifs

00:13:16.670 --> 00:13:17.845
or reverse the condition.

00:13:20.490 --> 00:13:22.430
You know, the cool
thing about this

00:13:22.430 --> 00:13:25.200
is that you're not
thinking, it just changes,

00:13:25.200 --> 00:13:27.010
and you know, for
sure, that it's

00:13:27.010 --> 00:13:29.720
going to be the same
behavior that you had before.

00:13:29.720 --> 00:13:30.795
So there you go.

00:13:30.795 --> 00:13:32.670
A different way of
writing the same function.

00:13:37.895 --> 00:13:39.970
Control-Space versus
Control-Shift-Space.

00:13:39.970 --> 00:13:42.010
This is a smart completion.

00:13:42.010 --> 00:13:43.510
So if you do
Control-Space here, you

00:13:43.510 --> 00:13:45.480
know that it offers
you all the expressions

00:13:45.480 --> 00:13:46.480
that you could do there.

00:13:46.480 --> 00:13:48.940
Not all, but a
big chunk of them.

00:13:48.940 --> 00:13:53.260
And it chooses the ones
that are correct at the top.

00:13:53.260 --> 00:13:56.870
But if you do
Control-Shift-Space,

00:13:56.870 --> 00:13:59.190
it gives you only the ones
that have the correct type.

00:13:59.190 --> 00:14:03.350
And you can see that before it
was showing the same function

00:14:03.350 --> 00:14:03.907
as itself.

00:14:03.907 --> 00:14:05.740
But now it figures out
that, if you do that,

00:14:05.740 --> 00:14:07.680
you're going to probably
recur to infinity.

00:14:07.680 --> 00:14:09.920
So it's no longer
showing you that.

00:14:09.920 --> 00:14:11.800
More than that, if I
come on this function

00:14:11.800 --> 00:14:14.980
here, that is the only other
expression that you could use,

00:14:14.980 --> 00:14:16.897
and I do Control-Shift-Space,
there you go.

00:14:16.897 --> 00:14:18.980
It just chose the only one
thing that it could do,

00:14:18.980 --> 00:14:19.813
and it put it there.

00:14:19.813 --> 00:14:21.650
So pretty handy.

00:14:21.650 --> 00:14:23.860
And the last feature that
I want to show you-- this

00:14:23.860 --> 00:14:25.165
has saved me so many times.

00:14:25.165 --> 00:14:27.290
You know when you say, I'm
not going to commit now,

00:14:27.290 --> 00:14:29.450
I'm sure it is fine.

00:14:29.450 --> 00:14:31.810
And then you [INAUDIBLE]?

00:14:31.810 --> 00:14:34.290
Local history to the rescue.

00:14:34.290 --> 00:14:39.340
Command-Shift-A, local history.

00:14:39.340 --> 00:14:43.060
And IntelliJ has
done a div every time

00:14:43.060 --> 00:14:44.410
you were editing your file.

00:14:44.410 --> 00:14:45.870
And you have the
history across your day.

00:14:45.870 --> 00:14:47.245
And you go back
to the point, you

00:14:47.245 --> 00:14:49.840
say, oh, this is
where I screwed up.

00:14:49.840 --> 00:14:52.640
And you can see here that it's
showing a div of everything

00:14:52.640 --> 00:14:54.370
I did during the demo.

00:14:54.370 --> 00:14:55.850
Two minutes ago,
I was with this.

00:14:55.850 --> 00:14:57.170
You can see the joins.

00:14:57.170 --> 00:14:58.710
This is super, super useful.

00:14:58.710 --> 00:15:04.793
So I hope you guys enjoyed
this, my favorite 10 tips.

00:15:04.793 --> 00:15:08.220
And Siva's going to show
you debugger cool features.

00:15:08.220 --> 00:15:09.520
Thank you.

00:15:09.520 --> 00:15:15.455
[APPLAUSE]

00:15:15.455 --> 00:15:16.960
SIVA VELUSAMY:
Thank you, Esteban.

00:15:16.960 --> 00:15:18.920
That was a number
of cool features.

00:15:18.920 --> 00:15:21.650
If you're like me, you now
have really clean-looking code

00:15:21.650 --> 00:15:22.720
that doesn't work.

00:15:22.720 --> 00:15:25.061
So now you enter the debugger.

00:15:25.061 --> 00:15:26.810
So let's spend the
next 10 minutes looking

00:15:26.810 --> 00:15:31.540
at some features in the debugger
that might help save the day.

00:15:31.540 --> 00:15:33.430
And I wanted to talk
about, actually,

00:15:33.430 --> 00:15:34.420
three different things.

00:15:34.420 --> 00:15:37.280
One is how do you attach
your debugger to a process?

00:15:37.280 --> 00:15:39.340
And then about how
do you actually

00:15:39.340 --> 00:15:42.620
set breakpoints in slightly
more interesting ways

00:15:42.620 --> 00:15:45.470
so that you can narrow down the
area that you want to debug?

00:15:45.470 --> 00:15:46.980
And finally, once
you're stopped,

00:15:46.980 --> 00:15:49.960
how do you examine the
state of your program?

00:15:49.960 --> 00:15:53.720
First let's start with
connecting the debugger.

00:15:53.720 --> 00:15:56.370
The most often used is you
just launch the debugger

00:15:56.370 --> 00:15:58.660
through Shift-F9, debug app.

00:15:58.660 --> 00:16:01.320
What this does is it
does a bunch of steps

00:16:01.320 --> 00:16:03.580
that you specified in
your run configuration.

00:16:03.580 --> 00:16:05.430
This has a number
of cool features.

00:16:05.430 --> 00:16:08.550
You can specify what
APK to install and, more

00:16:08.550 --> 00:16:10.180
importantly, what to launch.

00:16:10.180 --> 00:16:12.530
So you would normally
launch the default activity.

00:16:12.530 --> 00:16:14.360
But you can launch
a custom activity

00:16:14.360 --> 00:16:17.020
if you have activity aliases
or some other activity

00:16:17.020 --> 00:16:18.270
that you would want to launch.

00:16:18.270 --> 00:16:19.990
Or you could also launch a URL.

00:16:19.990 --> 00:16:22.777
But what happens if you don't
want to launch something?

00:16:22.777 --> 00:16:23.860
You don't want to install.

00:16:23.860 --> 00:16:26.110
You don't want to build, but
you just want to Connect.

00:16:26.110 --> 00:16:29.200
Or let's say someone brings you
a device where your program is

00:16:29.200 --> 00:16:30.405
stuck in a bad state.

00:16:30.405 --> 00:16:32.280
So in this particular
case, I have a program.

00:16:32.280 --> 00:16:33.850
And it's running over here.

00:16:33.850 --> 00:16:36.020
And I just want to
directly connect to it.

00:16:36.020 --> 00:16:40.040
The key is just saying attach
debugger to Android process.

00:16:40.040 --> 00:16:42.940
This is also present
in the toolbar.

00:16:42.940 --> 00:16:44.810
When you select
this, it shows you

00:16:44.810 --> 00:16:47.630
the processes that are running
on your connected device.

00:16:47.630 --> 00:16:50.240
And as soon as you say,
OK, you select the process,

00:16:50.240 --> 00:16:53.740
then it immediately attaches
the debugger to that process.

00:16:53.740 --> 00:16:56.440
Also, this allows you
to examine programs when

00:16:56.440 --> 00:16:59.090
they are in a messed-up state.

00:16:59.090 --> 00:17:00.930
So this is good
when your program

00:17:00.930 --> 00:17:02.590
has been running for a while.

00:17:02.590 --> 00:17:05.540
Well, what do you
do if, for instance,

00:17:05.540 --> 00:17:08.460
you want to debug
either a second process

00:17:08.460 --> 00:17:10.230
in your multi-process
app, or you

00:17:10.230 --> 00:17:13.017
want to debug
something that is--

00:17:13.017 --> 00:17:17.150
you want to attach the debugger
as soon as the process starts.

00:17:17.150 --> 00:17:22.740
So Android has a nice API
called Debug.waitfordebugger.

00:17:22.740 --> 00:17:26.692
So what this does is that, as
soon as your program starts,

00:17:26.692 --> 00:17:28.150
if it's not launched
through the ID

00:17:28.150 --> 00:17:30.200
itself, when it
encounters this API,

00:17:30.200 --> 00:17:33.040
it will just pause your
program at this location

00:17:33.040 --> 00:17:35.180
so that you can
then connect to it.

00:17:35.180 --> 00:17:37.960
So in this particular case, I'm
going to launch this broadcast

00:17:37.960 --> 00:17:38.070
reciever.

00:17:38.070 --> 00:17:39.670
It obviously doesn't
have to be this.

00:17:39.670 --> 00:17:41.480
It can be anything.

00:17:41.480 --> 00:17:44.760
So I go to the shell,
and I launch this.

00:17:44.760 --> 00:17:47.796
And now you see that the
active-- you launched

00:17:47.796 --> 00:17:50.170
is actually waiting because
it's waiting for the debugger

00:17:50.170 --> 00:17:50.980
to connect.

00:17:50.980 --> 00:17:53.150
At this point, you can,
again, attach the debugger.

00:17:53.150 --> 00:17:55.280
And now you see
the second process.

00:17:55.280 --> 00:17:59.600
And this will come force
right at the next statement.

00:17:59.600 --> 00:18:01.260
So this is really
cool when you have

00:18:01.260 --> 00:18:05.390
something that you want to
debug really early in your code.

00:18:05.390 --> 00:18:08.430
So that is how
attach to proceeds.

00:18:08.430 --> 00:18:08.980
[APPLAUSE]

00:18:08.980 --> 00:18:11.760
Oh, thank you.

00:18:11.760 --> 00:18:14.700
Now let's look at a
few things about how

00:18:14.700 --> 00:18:18.270
do you set break points in
slightly more interesting ways.

00:18:18.270 --> 00:18:20.165
Let's go back here.

00:18:20.165 --> 00:18:21.874
And let's run our app.

00:18:27.020 --> 00:18:29.170
So I have to have a break
point set up that's,

00:18:29.170 --> 00:18:32.030
I mean, the application you
saw is a pretty simple recycler

00:18:32.030 --> 00:18:32.560
view.

00:18:32.560 --> 00:18:35.800
And if this breakpoint is
set in the bindview holder,

00:18:35.800 --> 00:18:37.710
it's going to stop
every single time.

00:18:37.710 --> 00:18:42.760
So you can continuing, but
this gets super-annoying really

00:18:42.760 --> 00:18:43.550
soon.

00:18:43.550 --> 00:18:46.010
So the first thing that
you probably want to learn

00:18:46.010 --> 00:18:49.660
is there is an option called
New Breakpoints, which

00:18:49.660 --> 00:18:52.520
will disable breakpoints
throughout your program, all

00:18:52.520 --> 00:18:53.900
the breakpoints that you've set.

00:18:53.900 --> 00:18:56.350
So this allows your
app to continue running

00:18:56.350 --> 00:18:57.630
without the breakpoints.

00:18:57.630 --> 00:18:59.359
And then once you
have your program

00:18:59.359 --> 00:19:00.900
in a certain state
where you actually

00:19:00.900 --> 00:19:04.440
want the breakpoints enabled,
you can enable it back again.

00:19:04.440 --> 00:19:06.920
That is like a hammer.

00:19:06.920 --> 00:19:10.330
It disables all the breakpoints.

00:19:10.330 --> 00:19:12.250
If you want to have a
little more control,

00:19:12.250 --> 00:19:15.720
then you start looking at
conditional breakpoints.

00:19:15.720 --> 00:19:20.530
What I want you guys to think
of is that breakpoints are not

00:19:20.530 --> 00:19:21.460
purely static.

00:19:21.460 --> 00:19:25.060
You get some control
over when they are hit,

00:19:25.060 --> 00:19:27.380
and what do you do
when they are hit.

00:19:27.380 --> 00:19:30.040
If you get that part, then you
can just go through the list

00:19:30.040 --> 00:19:32.920
and figure out all the different
options around breakpoints.

00:19:32.920 --> 00:19:34.880
The first one, let's
say, is, I want

00:19:34.880 --> 00:19:39.980
to say that I want to
break on this location,

00:19:39.980 --> 00:19:46.754
only on, let's
say, the 10th item.

00:19:46.754 --> 00:19:48.420
I'm not sure if that
showed up properly.

00:19:48.420 --> 00:19:52.190
But I basically said position
equals 10 as a condition there.

00:19:52.190 --> 00:19:55.080
And this means that
this breakpoint will not

00:19:55.080 --> 00:20:01.880
be hit until this variable
position has a value of 10.

00:20:01.880 --> 00:20:05.250
So now I go here, and
I scroll, and now it

00:20:05.250 --> 00:20:09.830
hits the breakpoint only when
our position is actually 10.

00:20:09.830 --> 00:20:11.490
That's the conditional
breakpoint.

00:20:11.490 --> 00:20:15.950
Now there are actually a number
of conditions that you can set.

00:20:15.950 --> 00:20:17.220
Let's go here.

00:20:17.220 --> 00:20:20.970
And over here, you see
setting a condition is one.

00:20:20.970 --> 00:20:22.770
Another option
that is really cool

00:20:22.770 --> 00:20:24.260
is, instead of
setting a condition,

00:20:24.260 --> 00:20:26.790
you can actually
evaluate an expression.

00:20:26.790 --> 00:20:30.235
And if you [INAUDIBLE],
then this breakpoint

00:20:30.235 --> 00:20:33.190
acts pretty much like, every
time the breakpoint is hit,

00:20:33.190 --> 00:20:35.740
we will just log this
expression over here.

00:20:35.740 --> 00:20:40.030
Let's say I want to log
an expression that says,

00:20:40.030 --> 00:20:41.600
position, [INAUDIBLE].

00:20:50.701 --> 00:20:52.410
Can I do this?

00:20:52.410 --> 00:20:55.270
So now I go to the console.

00:20:55.270 --> 00:20:57.060
The new feature
in 2.3 already, is

00:20:57.060 --> 00:20:59.480
that locat gets
streamed directly

00:20:59.480 --> 00:21:01.320
into your devo console.

00:21:01.320 --> 00:21:03.620
So you see the locat over here.

00:21:03.620 --> 00:21:06.050
And then we just
added a breakpoint

00:21:06.050 --> 00:21:08.110
at the end, which
basically said every time

00:21:08.110 --> 00:21:10.750
it hits that breakpoint,
it will log an expression.

00:21:10.750 --> 00:21:13.870
So when I scroll
over here, you will

00:21:13.870 --> 00:21:17.450
see that, whenever it
hits the breakpoint,

00:21:17.450 --> 00:21:20.386
it will keep logging whatever
expression that you have given.

00:21:20.386 --> 00:21:22.010
So this is extremely
useful because you

00:21:22.010 --> 00:21:24.700
don't have to-- like, if you
just want to log something,

00:21:24.700 --> 00:21:29.340
then you don't have to do a
whole rebuild and deploy again.

00:21:29.340 --> 00:21:31.518
The next--

00:21:31.518 --> 00:21:32.017
[APPLAUSE]

00:21:35.960 --> 00:21:39.500
I just want to point out a few
of the conditional options that

00:21:39.500 --> 00:21:41.610
are there in
breakpoints, which is,

00:21:41.610 --> 00:21:45.750
there is one cool feature where
you can say that, I don't want

00:21:45.750 --> 00:21:47.920
the program to pause
at this breakpoint

00:21:47.920 --> 00:21:50.030
until a different
breakpoint was hit.

00:21:50.030 --> 00:21:52.080
So if you specify
this, then the program

00:21:52.080 --> 00:21:53.720
will pause at this
breakpoint only

00:21:53.720 --> 00:21:55.450
after the subsequent
breakpoint was hit.

00:21:55.450 --> 00:21:56.929
And you have even more controls.

00:21:56.929 --> 00:21:58.470
You know, there are
instance filters.

00:21:58.470 --> 00:21:59.970
So you can say you
only want to stop

00:21:59.970 --> 00:22:03.630
if it's a certain
object, certain class.

00:22:03.630 --> 00:22:05.863
So now let's go over from here.

00:22:10.330 --> 00:22:15.060
So now let's look at
another really cool feature

00:22:15.060 --> 00:22:16.185
that the debugger provides.

00:22:29.290 --> 00:22:32.720
So this is the data which is
displayed by the recycler view.

00:22:32.720 --> 00:22:35.020
And I have a whole
bunch of objects.

00:22:35.020 --> 00:22:37.390
What happens if
you want to track

00:22:37.390 --> 00:22:40.961
one particular object throughout
the lifecycle of your program?

00:22:40.961 --> 00:22:41.460
[INAUDIBLE]

00:22:47.336 --> 00:22:49.600
So what I can do
is, let's say I want

00:22:49.600 --> 00:22:53.590
to track what is going on with
the eighth object in my list.

00:22:53.590 --> 00:22:56.200
I can attach a name to it.

00:22:56.200 --> 00:22:58.830
And this is what you do
by marking that object.

00:22:58.830 --> 00:23:01.190
And so I say this is day 8.

00:23:01.190 --> 00:23:04.930
And what that immediately does
is that this is equivalent

00:23:04.930 --> 00:23:07.540
of you creating a
variable in the debugger

00:23:07.540 --> 00:23:09.570
and seeing that
this variable points

00:23:09.570 --> 00:23:11.050
to this particular object.

00:23:11.050 --> 00:23:15.170
And any time in your program, as
long as that object is visible,

00:23:15.170 --> 00:23:17.562
you will see it annotated
with this particular name.

00:23:17.562 --> 00:23:19.270
And it's really cool
because, many times,

00:23:19.270 --> 00:23:21.180
you want to track one
particular object.

00:23:21.180 --> 00:23:24.900
I usually end up writing it on
a piece of paper, the object

00:23:24.900 --> 00:23:25.570
reference.

00:23:25.570 --> 00:23:26.710
And you would track it.

00:23:26.710 --> 00:23:28.650
But instead, you just
have to mark the object.

00:23:28.650 --> 00:23:32.150
And then, once it's done,
let's say you go somewhere else

00:23:32.150 --> 00:23:33.760
in your program.

00:23:33.760 --> 00:23:39.980
And over here, you
can actually see,

00:23:39.980 --> 00:23:42.240
firstly you can see that
it is the same object.

00:23:42.240 --> 00:23:44.590
So in the case that it is
a singleton, for instance,

00:23:44.590 --> 00:23:47.720
and you have properly
marked it, you would always

00:23:47.720 --> 00:23:49.650
see it annotated with this.

00:23:49.650 --> 00:23:52.220
Not only that, you
can actually use this

00:23:52.220 --> 00:23:53.920
as a conditional over here.

00:23:53.920 --> 00:23:58.010
So here I can say, forecast,
[? dot ?] equals, day 8.

00:23:58.010 --> 00:23:59.910
So this is the
variable name I gave.

00:23:59.910 --> 00:24:06.160
And the convention is that
you add underscore_debug label

00:24:06.160 --> 00:24:07.300
as a suffix.

00:24:07.300 --> 00:24:09.780
And that variable is
just available to you.

00:24:09.780 --> 00:24:13.820
So now, if you do this, then
we will stop at this breakpoint

00:24:13.820 --> 00:24:17.380
only until whenever the
forecast matches the daily mark.

00:24:17.380 --> 00:24:19.290
So this is really
cool when you want

00:24:19.290 --> 00:24:22.656
to track specific objects over
the course of your program.

00:24:22.656 --> 00:24:28.510
[APPLAUSE]

00:24:28.510 --> 00:24:30.610
Now I want to get
into evaluating

00:24:30.610 --> 00:24:32.440
expressions a little bit.

00:24:32.440 --> 00:24:34.180
So let's go over here.

00:24:44.450 --> 00:24:46.200
So I have this expression.

00:24:46.200 --> 00:24:49.530
And what this says
is that, if it

00:24:49.530 --> 00:24:51.790
was more than a day
since the last sync,

00:24:51.790 --> 00:24:54.071
only then show a notification.

00:24:54.071 --> 00:24:56.070
But it so happens that I
actually want to debug.

00:24:56.070 --> 00:24:59.790
So if I continue from here,
if I step through from here,

00:24:59.790 --> 00:25:02.700
then I go into the if case.

00:25:02.700 --> 00:25:05.350
But what I really want to debug,
let's say, is the else case.

00:25:05.350 --> 00:25:06.930
So now what do you do?

00:25:06.930 --> 00:25:10.020
Let's go back to that
breakpoint again.

00:25:10.020 --> 00:25:13.410
The easiest thing to do first
is you evaluate this expression.

00:25:13.410 --> 00:25:15.234
So now you see the current.

00:25:15.234 --> 00:25:16.150
So the result is true.

00:25:16.150 --> 00:25:18.220
So you're going to
take the if case.

00:25:18.220 --> 00:25:20.150
But what I really want
to do is figure out

00:25:20.150 --> 00:25:21.730
why the if case was true.

00:25:21.730 --> 00:25:24.130
So now I can see
the lasting time.

00:25:24.130 --> 00:25:26.540
This is the timestamp
in milliseconds.

00:25:26.540 --> 00:25:29.720
But it's pretty hard to see
what exactly that means.

00:25:29.720 --> 00:25:32.070
So what you can do is,
you can say that I want

00:25:32.070 --> 00:25:34.864
to view this as a time stamp.

00:25:34.864 --> 00:25:36.280
Now, when you do
that, it actually

00:25:36.280 --> 00:25:37.404
renders it as a time stamp.

00:25:42.679 --> 00:25:44.470
And that's pretty cool,
because now you see

00:25:44.470 --> 00:25:46.340
that the last sync was at noon.

00:25:46.340 --> 00:25:49.830
And so, obviously, the if
condition will always be true.

00:25:49.830 --> 00:25:50.880
Now comes the next part.

00:25:50.880 --> 00:25:52.700
You actually want to force it.

00:25:52.700 --> 00:25:55.910
So what you do is you
set the value to 0.

00:25:55.910 --> 00:25:57.620
And you close.

00:25:57.620 --> 00:26:00.560
And then you can evaluate
the expression again.

00:26:00.560 --> 00:26:01.630
Now the result is false.

00:26:01.630 --> 00:26:03.713
And that's because we were
basically just able to,

00:26:03.713 --> 00:26:05.800
from the debugger, set
the value of an object.

00:26:05.800 --> 00:26:09.490
And you can do this, actually,
for any field that you want.

00:26:09.490 --> 00:26:14.530
So now, if you
close and step, you

00:26:14.530 --> 00:26:16.584
can now get the else
case without actually

00:26:16.584 --> 00:26:17.500
tweaking your program.

00:26:17.500 --> 00:26:19.249
You just change the
value in the debugger.

00:26:22.770 --> 00:26:24.100
The last couple of things.

00:26:24.100 --> 00:26:28.720
So actually, let me show
one more thing here.

00:26:28.720 --> 00:26:30.060
Smart step.

00:26:30.060 --> 00:26:36.370
So normally, when you
have code like this,

00:26:36.370 --> 00:27:02.147
which is either
methods, which are-- so

00:27:02.147 --> 00:27:03.230
I have a method like this.

00:27:03.230 --> 00:27:05.490
Then typically,
if I want to step

00:27:05.490 --> 00:27:08.549
into one of these methods,
what used to happen

00:27:08.549 --> 00:27:10.840
is that, you would actually
have to step into each one,

00:27:10.840 --> 00:27:13.130
and then you get out of it,
and then you go back into it.

00:27:13.130 --> 00:27:15.260
So instead, there is an option
called Smart Step, which

00:27:15.260 --> 00:27:17.180
will tell you exactly
which particular method

00:27:17.180 --> 00:27:18.630
you want to step into.

00:27:18.630 --> 00:27:22.140
And this is really useful
whenever you have methods,

00:27:22.140 --> 00:27:23.790
you know, functions
being passed in.

00:27:23.790 --> 00:27:28.550
So you have multiple parameters
which take function values.

00:27:28.550 --> 00:27:30.550
And then you can select
which particular method

00:27:30.550 --> 00:27:32.920
you want to step into.

00:27:32.920 --> 00:27:37.460
Now let's look at a little
bit about the view over here.

00:27:37.460 --> 00:27:39.780
In this stack frame
view, everything

00:27:39.780 --> 00:27:41.520
that is colored
yellow is actually

00:27:41.520 --> 00:27:45.450
coming from sources that
are not in your project.

00:27:45.450 --> 00:27:51.490
One tip to know is that,
earlier, so if I select this,

00:27:51.490 --> 00:27:53.450
we would take you to
the platform sources.

00:27:53.450 --> 00:27:56.640
But the platform sources always
corresponded to your target API

00:27:56.640 --> 00:27:59.100
level, not corresponding
to the device

00:27:59.100 --> 00:28:01.460
that you're actually running on.

00:28:01.460 --> 00:28:04.090
Finally, in 2.2,
we have fixed it

00:28:04.090 --> 00:28:06.200
so that we now show
you the sources

00:28:06.200 --> 00:28:09.030
corresponding to the device.

00:28:09.030 --> 00:28:10.910
The only thing you
have to do is make sure

00:28:10.910 --> 00:28:13.320
that that particular source
is actually installed.

00:28:13.320 --> 00:28:15.249
We don't have a UI
that comes up and says

00:28:15.249 --> 00:28:17.040
that, if you install
this, it will properly

00:28:17.040 --> 00:28:17.990
show you the source.

00:28:17.990 --> 00:28:20.250
So just as long as you
have the sources installed,

00:28:20.250 --> 00:28:23.470
it will pick up the
correct sources.

00:28:23.470 --> 00:28:24.550
[APPLAUSE]

00:28:24.550 --> 00:28:25.050
Thank you.

00:28:29.260 --> 00:28:32.620
Finally, I want to say a couple
of things about Instant Run.

00:28:32.620 --> 00:28:34.830
One really cool thing
about Instant Run

00:28:34.830 --> 00:28:38.450
is that, if you are debugging,
and instant run is enabled,

00:28:38.450 --> 00:28:41.250
you can actually restart
an activity from here.

00:28:41.250 --> 00:28:44.690
And that would immediately,
if I had launched it

00:28:44.690 --> 00:28:46.420
in Instant Run mode,
it would pretty much

00:28:46.420 --> 00:28:47.310
restart the activity.

00:28:47.310 --> 00:28:48.518
You don't have to go kill it.

00:28:48.518 --> 00:28:50.920
You don't have to
go to the device.

00:28:50.920 --> 00:28:53.480
And one other tip when
you're using Instant Run

00:28:53.480 --> 00:28:59.060
is that you have to
manually use the stop button

00:28:59.060 --> 00:29:01.900
to terminate the application
before running again

00:29:01.900 --> 00:29:03.940
if you want to launch
to a different device.

00:29:03.940 --> 00:29:05.273
This is just a little bit of it.

00:29:05.273 --> 00:29:08.440
Because Instant Run in new, many
people get confused about that.

00:29:08.440 --> 00:29:09.849
That's what I had.

00:29:09.849 --> 00:29:10.890
Hope you found it useful.

00:29:10.890 --> 00:29:14.176
Next up is Kathryn, who
will talk about C and C++.

00:29:14.176 --> 00:29:20.250
[APPLAUSE]

00:29:20.250 --> 00:29:23.240
KATHRYN SHIH: Awesome,
thank you, Siva.

00:29:23.240 --> 00:29:25.370
So C and C++.

00:29:25.370 --> 00:29:26.995
I'm going to cover
a little bit of edit

00:29:26.995 --> 00:29:28.950
and a little bit of debug.

00:29:28.950 --> 00:29:33.910
So, on the Edit front, if
anyone's ever edited mini JNI

00:29:33.910 --> 00:29:35.980
methods, it's
really, really easy,

00:29:35.980 --> 00:29:38.530
when you author it
in the C or C++ side,

00:29:38.530 --> 00:29:39.700
to get some name mismatch.

00:29:39.700 --> 00:29:41.630
And then you get
some runtime error.

00:29:41.630 --> 00:29:43.440
We've actually got
functionality in Studio,

00:29:43.440 --> 00:29:48.349
though, where you can completely
avoid this problem because when

00:29:48.349 --> 00:29:50.140
you start creating a
new method, let's just

00:29:50.140 --> 00:29:56.040
make a clone of our
string to JNI here,

00:29:56.040 --> 00:29:59.080
you can auto-complete
it from the Studio side.

00:29:59.080 --> 00:30:02.160
Oh no, where's my button?

00:30:02.160 --> 00:30:03.930
And it creates a
whole stub in C++.

00:30:03.930 --> 00:30:06.590
So don't have to worry at all
about whether you've actually

00:30:06.590 --> 00:30:09.450
gotten the right
Java classpath here.

00:30:09.450 --> 00:30:14.170
Once you start editing, there's
a C++ tool called Oxygen,

00:30:14.170 --> 00:30:16.950
where it gives you
Java style autodocs.

00:30:16.950 --> 00:30:21.680
So let's say we want to
create some sample function.

00:30:21.680 --> 00:30:27.680
I'm going to add
the method-- or not.

00:30:27.680 --> 00:30:28.317
Hey, whatever.

00:30:34.780 --> 00:30:38.890
So as I create this, I can
put whatever I want in there.

00:30:38.890 --> 00:30:41.000
And then you can look
up the whole list,

00:30:41.000 --> 00:30:43.960
but a couple good
ones are brief is

00:30:43.960 --> 00:30:51.490
the heading, this is what I
do, and say author, param.

00:30:55.260 --> 00:30:57.980
And then, when you
go down and hit F1,

00:30:57.980 --> 00:31:02.141
I should, if I have
spelled this correctly?

00:31:02.141 --> 00:31:04.630
AUDIENCE: [INAUDIBLE]

00:31:04.630 --> 00:31:05.840
KATHRYN SHIH: Sorry?

00:31:05.840 --> 00:31:07.880
AUDIENCE: [INAUDIBLE].

00:31:07.880 --> 00:31:09.260
ESTEBAN DE LA CANAL: Small s

00:31:09.260 --> 00:31:10.218
KATHRYN SHIH: Oh, gosh.

00:31:12.650 --> 00:31:16.525
So once I actually get
my letters correct,

00:31:16.525 --> 00:31:19.130
you can see all my docs.

00:31:19.130 --> 00:31:20.584
Return is another
super-handy one.

00:31:23.400 --> 00:31:24.359
Your stuff right.

00:31:30.540 --> 00:31:32.430
And yeah, it's a good
way to get Java style,

00:31:32.430 --> 00:31:33.304
keep track of things.

00:31:33.304 --> 00:31:35.590
You don't have to tab back
and forth all the time.

00:31:35.590 --> 00:31:38.720
Once you're done editing, we've
added a bunch of functionality

00:31:38.720 --> 00:31:40.300
to the debugger for C++.

00:31:40.300 --> 00:31:41.800
So I think, in the
earlier talk, Tor

00:31:41.800 --> 00:31:43.690
mentioned the auto debugger.

00:31:43.690 --> 00:31:47.190
And I'm just going
to start this.

00:31:47.190 --> 00:31:49.667
If you ever start the debugger
hoping to catch C++ code,

00:31:49.667 --> 00:31:52.000
and you're like, why is it
not catching any of my native

00:31:52.000 --> 00:31:54.910
breakpoints, the first thing
you should always look at is,

00:31:54.910 --> 00:31:58.265
under your app configuration,
do you have it set to Java?

00:31:58.265 --> 00:32:00.390
If it's set to Java, you're
going to be pretty sad.

00:32:03.250 --> 00:32:05.270
But when it's set to
Auto, Native or Hybrid--

00:32:05.270 --> 00:32:08.590
well if it's set
to Native, you're

00:32:08.590 --> 00:32:10.490
not going to catch
any Java breakpoints.

00:32:10.490 --> 00:32:13.930
But I can step into
my Java breakpoint.

00:32:13.930 --> 00:32:18.680
And then I can actually
see a little-known feature

00:32:18.680 --> 00:32:21.140
called a Memory Watchpoint.

00:32:21.140 --> 00:32:23.990
So I can right-click on this
and say, Add Watchpoint.

00:32:23.990 --> 00:32:25.617
And this actually
adds hardware support

00:32:25.617 --> 00:32:27.450
where, whenever I touch
this memory address,

00:32:27.450 --> 00:32:29.020
it's going to stop the debugger.

00:32:29.020 --> 00:32:30.770
So let's set this
to NE, because I'm

00:32:30.770 --> 00:32:32.096
going to be reading from it.

00:32:32.096 --> 00:32:33.970
And you can see, I don't
have any breakpoints

00:32:33.970 --> 00:32:36.930
set down here-- oh, just
one at the very end.

00:32:36.930 --> 00:32:38.166
I start running.

00:32:38.166 --> 00:32:40.290
And since we're actually
accessing the memory where

00:32:40.290 --> 00:32:42.360
I set the breakpoints,
the CPU is

00:32:42.360 --> 00:32:44.527
going to stop and let us
look at it with a debugger.

00:32:44.527 --> 00:32:46.151
So if you ever try
to figure out what's

00:32:46.151 --> 00:32:48.140
going on with some
crazy chunk of memory,

00:32:48.140 --> 00:32:50.000
this is a really
handy way to do it.

00:32:50.000 --> 00:32:53.280
It's officially supported
on x86 and the Nexus 9.

00:32:53.280 --> 00:32:55.290
The emulator,
though, is a good way

00:32:55.290 --> 00:32:58.310
to get an x86
debugger environment.

00:32:58.310 --> 00:33:00.460
So once you've done that,
let's take that away.

00:33:04.590 --> 00:33:08.350
And the other thing we've added
to the debugger for C++ is STL

00:33:08.350 --> 00:33:09.060
support.

00:33:09.060 --> 00:33:11.190
So you can see, up here,
I've created a vector,

00:33:11.190 --> 00:33:13.170
and I've added a
bunch of pairs to it.

00:33:13.170 --> 00:33:14.660
I can actually start expanding.

00:33:14.660 --> 00:33:15.930
It's fully aware of the STL.

00:33:15.930 --> 00:33:18.140
You can have some
crazy map in here,

00:33:18.140 --> 00:33:20.080
and it should still render.

00:33:20.080 --> 00:33:23.110
And you can interact with the
STL when you're evaluating

00:33:23.110 --> 00:33:30.910
your functions, like [? vec ?]
[? dot ?] or size, and voila.

00:33:30.910 --> 00:33:34.730
Similarly, you should be able
to edit memory, see the results.

00:33:34.730 --> 00:33:36.965
So I think that's the
debugger stuff we've added.

00:33:36.965 --> 00:33:39.840
Let's see if I can
get us back on time.

00:33:39.840 --> 00:33:43.340
Oh, and then the other thing I
should've mentioned under Edit,

00:33:43.340 --> 00:33:45.910
if you're used to using C++
11, you may have noticed that

00:33:45.910 --> 00:33:48.660
the NDK and experimental
Gradle do not default to it.

00:33:48.660 --> 00:33:52.020
So you're like, auto,
variable, error.

00:33:52.020 --> 00:33:55.677
A handy way to fix that is
you can actually turn it on.

00:33:55.677 --> 00:33:57.760
So if you're using the
experimental Gradle plugin,

00:33:57.760 --> 00:34:02.210
and you want to use C++ 11, just
add this to your NDK stanza,

00:34:02.210 --> 00:34:04.940
and you will have access to
all of the handy 11 language

00:34:04.940 --> 00:34:06.810
features.

00:34:06.810 --> 00:34:12.120
And then a final tip for C++
is, if you ever have a JNI error

00:34:12.120 --> 00:34:15.699
on a debug build in
studio on an emulator,

00:34:15.699 --> 00:34:18.110
you may notice that you get
this expanded stack trace.

00:34:18.110 --> 00:34:21.469
So I have an app here that
is actually probably not

00:34:21.469 --> 00:34:23.690
very social.

00:34:23.690 --> 00:34:27.190
It's got this handy
button for a Crash JNI.

00:34:27.190 --> 00:34:32.389
And if we hit this--
let's just keep going.

00:34:32.389 --> 00:34:35.949
If we hit this, it actually
makes a invalid JNI call.

00:34:35.949 --> 00:34:38.911
So we can't call Find Class for
something that's not a class.

00:34:38.911 --> 00:34:40.411
And we'll get this
huge stack trace.

00:34:43.510 --> 00:34:44.927
I know some folks
have come saying

00:34:44.927 --> 00:34:47.593
I'm getting all these [? sick ?]
aborts for my production build.

00:34:47.593 --> 00:34:48.469
What's happening?

00:34:48.469 --> 00:34:50.929
One thing to consider is that
these stack traces actually

00:34:50.929 --> 00:34:52.889
only occur on debug
builds from Studio

00:34:52.889 --> 00:34:54.629
by default and on the emulator.

00:34:54.629 --> 00:34:56.920
If you're using a real device
for the production build,

00:34:56.920 --> 00:34:58.410
all you'll see is the abort.

00:34:58.410 --> 00:35:00.550
And there's a handy
way to fix that,

00:35:00.550 --> 00:35:03.490
which is you can connect
to a device with ADB

00:35:03.490 --> 00:35:05.390
and set check JNI to be one.

00:35:05.390 --> 00:35:07.359
And this will
enable JNI checking,

00:35:07.359 --> 00:35:08.900
even if it's a
production build, even

00:35:08.900 --> 00:35:10.090
though it's physical device.

00:35:10.090 --> 00:35:13.480
So you're seeing crazy aborts
coming out, try running this,

00:35:13.480 --> 00:35:15.290
and try using it to
see if you've got a JNI

00:35:15.290 --> 00:35:16.870
problem causing your error.

00:35:16.870 --> 00:35:19.250
And with that, I'd like
to hand it over to Jerome

00:35:19.250 --> 00:35:21.480
for some Gradle tips.

00:35:21.480 --> 00:35:22.579
[APPLAUSE]

00:35:22.579 --> 00:35:23.620
JEROME DOCHEZ: Thank you.

00:35:27.290 --> 00:35:29.040
All right.

00:35:29.040 --> 00:35:30.910
So as you know,
we've worked a lot

00:35:30.910 --> 00:35:32.760
on performance of
build, whether the build

00:35:32.760 --> 00:35:34.650
should be incremental or full.

00:35:34.650 --> 00:35:39.260
And some of the effort that was
led by this performance work

00:35:39.260 --> 00:35:41.430
was the Instant Run technology.

00:35:41.430 --> 00:35:44.610
Now, when Instant Run got
delivered, a lot of people

00:35:44.610 --> 00:35:46.630
got confused about a few things.

00:35:46.630 --> 00:35:48.620
And I would like to
clarify some of them today.

00:35:48.620 --> 00:35:52.692
So first of all, the
way we do Instant Run

00:35:52.692 --> 00:35:54.400
is by doing [? bicode ?]
instrumentation.

00:35:54.400 --> 00:35:57.230
And we do had a few
fields and a few methods.

00:35:57.230 --> 00:35:59.200
So suddenly some
magic can happen,

00:35:59.200 --> 00:36:01.940
and you can reload a class in
your living virtual machine

00:36:01.940 --> 00:36:04.340
without having to
restart the application.

00:36:04.340 --> 00:36:07.590
Now, this adding of
fields and methods

00:36:07.590 --> 00:36:11.790
have sometimes thrown people
over the limit of the 65k text

00:36:11.790 --> 00:36:13.440
file limit.

00:36:13.440 --> 00:36:16.110
And a lot of people
were confused by that

00:36:16.110 --> 00:36:17.370
and not knowing how to fix it.

00:36:17.370 --> 00:36:20.140
So I thought I should
explain how it is.

00:36:20.140 --> 00:36:24.450
So basically, if you hit
the 65k limit, which is just

00:36:24.450 --> 00:36:26.140
what happened here--
I should probably

00:36:26.140 --> 00:36:29.540
make this a little
bigger-- so you

00:36:29.540 --> 00:36:33.230
should get a message that
will tell you that you

00:36:33.230 --> 00:36:35.899
are over the 65k limit.

00:36:35.899 --> 00:36:37.440
So, as you know,
the text file format

00:36:37.440 --> 00:36:39.790
only supports 65k
methods or classes.

00:36:39.790 --> 00:36:41.390
Here I am at 70k.

00:36:41.390 --> 00:36:43.150
So to fix the
problem, I just need

00:36:43.150 --> 00:36:51.620
to define one more
Gradle thing to say,

00:36:51.620 --> 00:36:52.990
I want multitext to be true.

00:36:52.990 --> 00:36:53.490
OK?

00:36:53.490 --> 00:36:56.640
So when that happens, and
now we can try to build,

00:36:56.640 --> 00:36:58.850
Gradle will start
saying that we are

00:36:58.850 --> 00:37:00.550
lowering to build
the application

00:37:00.550 --> 00:37:05.410
in separate
different text files.

00:37:05.410 --> 00:37:08.280
Now there's two types
of multitext platform.

00:37:08.280 --> 00:37:11.100
There's what we call
the legacy multitexting.

00:37:11.100 --> 00:37:16.090
And there is the modern
or native multitexting.

00:37:16.090 --> 00:37:19.570
And depending on which
platform you're targeting,

00:37:19.570 --> 00:37:20.980
you will use one or the other.

00:37:20.980 --> 00:37:24.830
Basically, before 21, you
will use the legacy one.

00:37:24.830 --> 00:37:28.260
And 21 and above, you
will use the modern one.

00:37:28.260 --> 00:37:31.310
The problem here is that,
because we are targeting mini

00:37:31.310 --> 00:37:39.760
SDK 19, by default, the
legacy multitext will be used.

00:37:39.760 --> 00:37:42.000
So we've still got
to build, and it's

00:37:42.000 --> 00:37:44.975
12 seconds, which is going to be
our baseline for today's demo.

00:37:44.975 --> 00:37:46.850
And we're going to see
this number going down

00:37:46.850 --> 00:37:49.860
as I'm starting to improve,
by different settings,

00:37:49.860 --> 00:37:51.810
this build environment.

00:37:51.810 --> 00:37:54.750
But first, I would like to
change a little bit of code,

00:37:54.750 --> 00:37:56.480
just one line.

00:37:56.480 --> 00:38:01.210
And I'm going to change
this, for instance.

00:38:01.210 --> 00:38:04.600
So we also get a baseline
for the incremental build.

00:38:08.330 --> 00:38:10.330
So the incremental build,
we just have one file.

00:38:10.330 --> 00:38:12.220
In theory, it should
be much faster.

00:38:12.220 --> 00:38:13.969
But we're going to see
that, because we're

00:38:13.969 --> 00:38:16.357
using legacy multitext it's
not going to be much faster.

00:38:16.357 --> 00:38:18.440
In fact, it might actually
be more or less exactly

00:38:18.440 --> 00:38:20.350
the same time.

00:38:20.350 --> 00:38:21.190
11.5, OK.

00:38:21.190 --> 00:38:23.300
So we are 12 for the full build.

00:38:23.300 --> 00:38:25.410
11.5, for the incremental build.

00:38:25.410 --> 00:38:28.550
I cannot say that we are doing
a great job at the incremental

00:38:28.550 --> 00:38:29.680
building here.

00:38:29.680 --> 00:38:33.020
So first, what we
should do is to try

00:38:33.020 --> 00:38:35.637
to switch to native multitext.

00:38:35.637 --> 00:38:37.720
Because with native
multitext, the virtual machine

00:38:37.720 --> 00:38:39.570
is capable of
understanding, natively,

00:38:39.570 --> 00:38:42.580
that an application can be
packaged a simple text file.

00:38:42.580 --> 00:38:45.670
And therefore, it's a
lot less work for the

00:38:45.670 --> 00:38:48.979
build system to be
able to handle this.

00:38:48.979 --> 00:38:50.770
So to do that, we're
going to add a flavor.

00:38:53.720 --> 00:38:57.070
And this one is going to
be said the legacy one.

00:38:57.070 --> 00:39:00.180
And that's where we're going
to continue targeting 19.

00:39:00.180 --> 00:39:02.370
And then we have a
new flavor that we're

00:39:02.370 --> 00:39:04.560
going to be calling Modern.

00:39:04.560 --> 00:39:08.310
And this one will be
targeting 21 and above.

00:39:08.310 --> 00:39:14.574
Now if I go to the build
variance-- let's think first.

00:39:14.574 --> 00:39:15.990
If I go to the
build variance, I'm

00:39:15.990 --> 00:39:19.180
going to switch my legacy
debug to my modern debug.

00:39:19.180 --> 00:39:23.430
So now that I'm
going to rebuild--

00:39:23.430 --> 00:39:25.830
do not ask me this
again, please.

00:39:25.830 --> 00:39:28.250
When I'm going to rebuild,
I'm going to now rebuild

00:39:28.250 --> 00:39:30.300
with the modern text file.

00:39:30.300 --> 00:39:34.410
And that's not going to make a
huge change for the full build.

00:39:34.410 --> 00:39:37.780
So let's wait until
it's doing its job.

00:39:37.780 --> 00:39:39.560
11.6, we were at 12.

00:39:39.560 --> 00:39:41.650
So it's not great.

00:39:41.650 --> 00:39:43.080
But slightly better.

00:39:43.080 --> 00:39:46.670
But where we are going to
start seeing a big difference

00:39:46.670 --> 00:39:50.520
is when we do the
incremental build.

00:39:50.520 --> 00:39:54.945
So when the incremental build,
we were also at 11.5 seconds.

00:39:54.945 --> 00:39:56.340
Now we're at six.

00:39:56.340 --> 00:39:58.860
So we already divided
by 2 the build time.

00:39:58.860 --> 00:39:59.660
That's good.

00:39:59.660 --> 00:40:01.210
But I'm sure we can do better.

00:40:01.210 --> 00:40:02.210
Keep your claps for now.

00:40:05.840 --> 00:40:09.160
First thing that you
should always try to do

00:40:09.160 --> 00:40:11.150
is to use the latest
Gradle plug-in.

00:40:11.150 --> 00:40:14.190
Because we always
try to enhance stuff.

00:40:14.190 --> 00:40:17.340
Yes, sometimes we break
stuff, but we try to fix it.

00:40:17.340 --> 00:40:20.290
But, for most of the time,
we try to make things better.

00:40:20.290 --> 00:40:23.170
And using the latest
version will allow you

00:40:23.170 --> 00:40:25.590
to use the latest enhancements.

00:40:25.590 --> 00:40:31.110
So, in this case I'm going to
switch to the latest version.

00:40:31.110 --> 00:40:35.560
And I'm going to continue
building exactly the same way.

00:40:35.560 --> 00:40:37.760
But because I want to
force a complete rebuild,

00:40:37.760 --> 00:40:47.600
let me clean it first
and run a full build.

00:40:47.600 --> 00:40:50.110
So here, I'm getting
another type of message.

00:40:50.110 --> 00:40:52.894
And it's telling me
that, starting with 2.2,

00:40:52.894 --> 00:40:53.810
we make things better.

00:40:53.810 --> 00:40:56.909
You can now run your
decks in process, which

00:40:56.909 --> 00:40:58.200
is going to make things faster.

00:40:58.200 --> 00:41:01.440
But, unfortunately, in
this particular instance,

00:41:01.440 --> 00:41:02.820
you don't have enough memory.

00:41:02.820 --> 00:41:06.260
And therefore, we reverted to
the old out of process stuff.

00:41:06.260 --> 00:41:08.930
So let's add more memory
to the Gradle daemon.

00:41:08.930 --> 00:41:11.950
And I cannot stress how
important this can be when you

00:41:11.950 --> 00:41:14.210
will start using the Gradle 2.2.

00:41:14.210 --> 00:41:17.070
You should really look
into adding more memory

00:41:17.070 --> 00:41:19.040
to the Gradle daemon.

00:41:19.040 --> 00:41:20.740
So here I am adding 4G.

00:41:20.740 --> 00:41:23.330
And I'm going to do exactly
the same thing again.

00:41:23.330 --> 00:41:25.210
I'm going to clean the project.

00:41:25.210 --> 00:41:27.370
So we get a new baseline
for the full build.

00:41:37.570 --> 00:41:39.890
So in this case, the
message should be gone.

00:41:39.890 --> 00:41:40.750
And it is gone.

00:41:40.750 --> 00:41:42.800
So now we are in process.

00:41:42.800 --> 00:41:45.340
And we were, about
12 seconds earlier,

00:41:45.340 --> 00:41:47.370
we are down to nine
seconds for the full build.

00:41:47.370 --> 00:41:49.280
It's pretty OK.

00:41:49.280 --> 00:41:54.010
Let's continue trying to see
how much it would take to make

00:41:54.010 --> 00:41:57.465
an incremental change now.

00:41:57.465 --> 00:41:59.350
All right, 2.3 seconds.

00:41:59.350 --> 00:42:00.559
It's getting better.

00:42:00.559 --> 00:42:01.350
But we can do more.

00:42:01.350 --> 00:42:02.160
[APPLAUSE]

00:42:02.160 --> 00:42:05.290
No, we can do more.

00:42:05.290 --> 00:42:08.480
Next thing, Instant Run
has been disabled so far.

00:42:08.480 --> 00:42:10.780
So let's put it back on.

00:42:10.780 --> 00:42:14.300
So when it's on, we
will try to redeliver

00:42:14.300 --> 00:42:18.710
the smallest set of changes
each time you do a build.

00:42:18.710 --> 00:42:20.290
So again, let me
clean it so we are

00:42:20.290 --> 00:42:22.450
sure to have a
clean environment.

00:42:22.450 --> 00:42:25.030
So Instant Run will
not only try to reload

00:42:25.030 --> 00:42:27.880
a class in the virtual machine
without even restarting

00:42:27.880 --> 00:42:31.350
the application, but it will
also concentrate very much

00:42:31.350 --> 00:42:34.450
into route delivering the
minimum set of changes

00:42:34.450 --> 00:42:35.090
required.

00:42:35.090 --> 00:42:37.940
So in this particular
case, excuse

00:42:37.940 --> 00:42:40.970
me, in this particular case,
when you change a single Java

00:42:40.970 --> 00:42:44.020
file, it will most
likely only redeliver

00:42:44.020 --> 00:42:47.220
the text file that corresponds
to the single Java file.

00:42:47.220 --> 00:42:49.350
So that was the full build.

00:42:49.350 --> 00:42:55.030
Now let's change again, this,
and let's measure how much.

00:42:55.030 --> 00:42:56.900
We are down to 0.6.

00:42:56.900 --> 00:42:58.690
Now we're talking!

00:42:58.690 --> 00:42:59.840
I'm pretty sure.

00:42:59.840 --> 00:43:05.900
[APPLAUSE]

00:43:05.900 --> 00:43:09.330
Even better, I can go to 0.4.

00:43:09.330 --> 00:43:13.320
OK, so, as you can see,
we start at 12 seconds.

00:43:13.320 --> 00:43:14.920
We are now at 0.4.

00:43:14.920 --> 00:43:18.710
With very little changes,
very little work,

00:43:18.710 --> 00:43:22.954
we divided by more than
20 times the build time.

00:43:22.954 --> 00:43:24.660
But let's do some other changes.

00:43:24.660 --> 00:43:30.610
For instance, let's take
the source files here.

00:43:30.610 --> 00:43:34.400
And let's look
into the main file.

00:43:34.400 --> 00:43:35.658
This is really small here.

00:43:39.444 --> 00:43:40.860
Actually, I don't
have to do this.

00:43:40.860 --> 00:43:41.871
I can go to the app.

00:43:41.871 --> 00:43:44.370
So as you can see here, I've
got a version code, which is 1.

00:43:44.370 --> 00:43:46.020
Let me change it to 5.

00:43:46.020 --> 00:43:48.415
And let's see how that's
influenced the build.

00:43:52.780 --> 00:43:54.240
3 seconds, what happened?

00:43:54.240 --> 00:43:56.486
I was at 0.4 And now
I'm at 3 seconds.

00:43:56.486 --> 00:43:58.860
Well, what happened is that
we changed the main manifest.

00:43:58.860 --> 00:44:00.710
And when that
happens, the only way

00:44:00.710 --> 00:44:02.590
we can redeliver
the manifest file

00:44:02.590 --> 00:44:04.330
is by redelivering the full APK.

00:44:04.330 --> 00:44:06.610
So you can see how some of
the changes that you make

00:44:06.610 --> 00:44:08.030
have a very strong influence.

00:44:08.030 --> 00:44:10.700
And knowing the tool,
knowing what the tool does,

00:44:10.700 --> 00:44:12.100
is very important.

00:44:12.100 --> 00:44:14.690
Here, if you, for
instance, are smart and try

00:44:14.690 --> 00:44:17.600
to change the version
every single time you build

00:44:17.600 --> 00:44:21.134
by using the current time,
right now, as your version,

00:44:21.134 --> 00:44:22.800
you're going to see
that you will never,

00:44:22.800 --> 00:44:25.800
ever leverage
Instant Run features.

00:44:25.800 --> 00:44:29.170
So it's important
to remember that.

00:44:29.170 --> 00:44:31.320
But again, on the
standard tools.

00:44:31.320 --> 00:44:33.970
There's a lot of documentation
about the Instant Run.

00:44:33.970 --> 00:44:35.970
I'm afraid we don't
have time for QA.

00:44:35.970 --> 00:44:37.150
We have only 30 seconds.

00:44:37.150 --> 00:44:40.846
But we will be available
outside for QA.

00:44:40.846 --> 00:44:42.220
And then we have
the booth, which

00:44:42.220 --> 00:44:44.790
is right outside on this side
for the Android Studio, where

00:44:44.790 --> 00:44:48.320
you're more than welcome to come
and ask for further questions.

00:44:48.320 --> 00:44:50.672
Thank you very much.

00:44:50.672 --> 00:44:52.395
[APPLAUSE]

