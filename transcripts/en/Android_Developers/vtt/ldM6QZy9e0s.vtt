WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:01.464
[MUSIC PLAYING]

00:00:04.150 --> 00:00:05.150
JEFFREY VAN GOGH: Hello.

00:00:05.150 --> 00:00:06.120
I'm Jeffrey van Gogh.

00:00:06.120 --> 00:00:07.830
I am a tech lead
on Android Studio.

00:00:07.830 --> 00:00:10.230
And I'm there responsible
for programming languages

00:00:10.230 --> 00:00:11.675
and compilers.

00:00:11.675 --> 00:00:13.550
HADI HARIRI: And I'm
Hadi, developer advocate

00:00:13.550 --> 00:00:14.092
at JetBrains.

00:00:14.092 --> 00:00:15.491
[CHEERING]

00:00:18.703 --> 00:00:20.370
JEFFREY VAN GOGH: So
it's been two years

00:00:20.370 --> 00:00:23.040
since Google announced
Kotlin support for Android.

00:00:23.040 --> 00:00:25.950
And yesterday we announced that
Google is going Kotlin-first.

00:00:25.950 --> 00:00:28.500
So we figured we give you
some background on this.

00:00:28.500 --> 00:00:33.390
And so, of course, we
didn't start two years ago.

00:00:33.390 --> 00:00:36.360
We took quite some
time to get things

00:00:36.360 --> 00:00:38.160
ready for Kotlin on Android.

00:00:38.160 --> 00:00:41.460
And we decided about
3, 3 and 1/2 years ago,

00:00:41.460 --> 00:00:43.800
there was a bunch of us
language geeks at Google--

00:00:43.800 --> 00:00:48.160
[INAUDIBLE] me-- starting to
play with Kotlin, and like,

00:00:48.160 --> 00:00:50.410
hey, this is
actually quite nice.

00:00:50.410 --> 00:00:53.760
And of course, Android
Studio is based on IntelliJ.

00:00:53.760 --> 00:00:56.890
And IntelliJ started using
Kotlin in its old code base.

00:00:56.890 --> 00:00:59.010
So we started to see
more and more Kotlin

00:00:59.010 --> 00:01:01.080
being used in Android Studio.

00:01:01.080 --> 00:01:02.790
And at the same
time, we were getting

00:01:02.790 --> 00:01:05.489
a lot of customer feedback
from our Customer Advisory

00:01:05.489 --> 00:01:08.550
Board, surveys, and
ad hoc discussions

00:01:08.550 --> 00:01:12.000
at conferences like these
that people really like Kotlin

00:01:12.000 --> 00:01:14.580
and they really would
like Google to support it,

00:01:14.580 --> 00:01:18.750
because their companies would
not adopt Kotlin otherwise.

00:01:18.750 --> 00:01:20.850
Of course, taking on a
new language like that

00:01:20.850 --> 00:01:21.850
is a big task.

00:01:21.850 --> 00:01:25.660
So we had to convince our
directors that this was

00:01:25.660 --> 00:01:28.510
something worth investing in.

00:01:28.510 --> 00:01:30.010
The best way we
found to do this was

00:01:30.010 --> 00:01:31.710
to just get our
directors to code

00:01:31.710 --> 00:01:33.570
for a couple days in Kotlin.

00:01:33.570 --> 00:01:35.800
And after that, they were sold.

00:01:35.800 --> 00:01:39.990
So a couple months before I/O
2017, we decided to go for it,

00:01:39.990 --> 00:01:43.770
and this meant so many
meetings to set this all up.

00:01:43.770 --> 00:01:45.683
If you think, as a
tech lead or manager,

00:01:45.683 --> 00:01:47.600
you don't have enough
time for coding anymore,

00:01:47.600 --> 00:01:51.420
try setting up a foundation.

00:01:51.420 --> 00:01:57.070
So we got this all ready one
day before Google I/O 2017.

00:01:57.070 --> 00:02:00.010
There was this big thread
on Android Dev subreddit

00:02:00.010 --> 00:02:03.630
how Google is never
going to embrace Kotlin.

00:02:03.630 --> 00:02:05.590
Of course, we knew what
was going to happen,

00:02:05.590 --> 00:02:07.860
but it was so hard to
not reply to that thread.

00:02:10.449 --> 00:02:13.260
So yeah, two years
ago, Steph was onstage

00:02:13.260 --> 00:02:14.543
announcing Kotlin support.

00:02:14.543 --> 00:02:16.710
I think it was the loudest
applause of the developer

00:02:16.710 --> 00:02:18.930
keynote.

00:02:18.930 --> 00:02:19.800
It was amazing.

00:02:19.800 --> 00:02:22.590
Of course, we all knew at
both JetBrains and Google

00:02:22.590 --> 00:02:24.930
that that meant that
we had a lot of work

00:02:24.930 --> 00:02:27.780
ahead of us to make sure
that Kotlin worked well

00:02:27.780 --> 00:02:30.590
for Android and in general.

00:02:30.590 --> 00:02:32.070
And so today, we
want to show some

00:02:32.070 --> 00:02:35.243
of the work we have done
over the last two years.

00:02:35.243 --> 00:02:36.660
Hadi will talk
about what happened

00:02:36.660 --> 00:02:38.993
to Kotlin in the last years,
and then I'll take it back,

00:02:38.993 --> 00:02:42.780
and I'll talk about what
we did on the Android side.

00:02:42.780 --> 00:02:44.640
HADI HARIRI: Thank you.

00:02:44.640 --> 00:02:47.652
So to start, I want
to just mention

00:02:47.652 --> 00:02:49.110
about the Kotlin
Foundation, which,

00:02:49.110 --> 00:02:52.560
if you remember when Google
announced official support two

00:02:52.560 --> 00:02:55.560
years ago for Kotlin, we
also briefly mentioned

00:02:55.560 --> 00:02:58.830
that we'll be forming a
foundation, which was created

00:02:58.830 --> 00:03:02.700
by JetBrains and Google to
protect, promote, and advance

00:03:02.700 --> 00:03:05.670
the language Kotlin.

00:03:05.670 --> 00:03:08.910
The foundation is governed by
a board of directors, which

00:03:08.910 --> 00:03:12.480
are two representatives of
JetBrains, two of Google,

00:03:12.480 --> 00:03:14.647
and one independent member.

00:03:14.647 --> 00:03:16.230
And to give you a
little bit of a idea

00:03:16.230 --> 00:03:21.360
on what the scope of the
foundation is, one of the jobs

00:03:21.360 --> 00:03:23.820
is to appoint a language lead
designer, which currently,

00:03:23.820 --> 00:03:27.420
of course, is Andrey
Breslav, and there's

00:03:27.420 --> 00:03:30.030
a Language Committee that
controls breaking changes.

00:03:30.030 --> 00:03:32.490
And it's very important
here to understand that this

00:03:32.490 --> 00:03:34.300
is limited in terms of scope.

00:03:34.300 --> 00:03:36.570
So it is only about
breaking changes.

00:03:36.570 --> 00:03:40.380
Kotlin continues to be developed
as it is now in the open,

00:03:40.380 --> 00:03:40.992
on GitHub.

00:03:40.992 --> 00:03:43.200
We still have the KEEP,
which is the Kotlin Evolution

00:03:43.200 --> 00:03:44.490
Enhancement Process.

00:03:44.490 --> 00:03:48.330
But the Language Committee
is mostly around controlling

00:03:48.330 --> 00:03:51.750
the breaking changes that
might happen into the language.

00:03:51.750 --> 00:03:54.150
And also, there's a
trademark subcommittee

00:03:54.150 --> 00:03:57.000
that is about protecting
the trademark of Kotlin,

00:03:57.000 --> 00:04:00.420
and working with the community
to help promote Kotlin and use

00:04:00.420 --> 00:04:01.785
Kotlin in a fair way.

00:04:01.785 --> 00:04:04.410
And if you want to find out
more about the foundation,

00:04:04.410 --> 00:04:06.360
you can go to the
KotlinLang website,

00:04:06.360 --> 00:04:09.330
where you'll have more
information as well as details

00:04:09.330 --> 00:04:12.390
about how you can use Kotlin
and trademarks, et cetera.

00:04:12.390 --> 00:04:14.527
And with that, let's
switch over to the demo.

00:04:14.527 --> 00:04:16.860
And I'm going to show you
some things with the language.

00:04:26.920 --> 00:04:29.240
This is where I'm using
someone else's machine.

00:04:29.240 --> 00:04:32.790
Let's see how this goes.

00:04:32.790 --> 00:04:34.160
I think the ID's correct.

00:04:34.160 --> 00:04:36.740
Yes.

00:04:36.740 --> 00:04:41.490
So I'll show you some
things around the language.

00:04:41.490 --> 00:04:43.970
So probably the most
fundamental, most important

00:04:43.970 --> 00:04:47.660
thing that we have done,
which has taken a very, very

00:04:47.660 --> 00:04:51.770
long time, if you're familiar
with writing a Kotlin

00:04:51.770 --> 00:04:56.100
application, you have
your main entry point.

00:04:56.100 --> 00:05:00.350
So we've actually now made that
so you don't have parameters.

00:05:00.350 --> 00:05:01.110
So that's it.

00:05:01.110 --> 00:05:01.610
Thank you.

00:05:01.610 --> 00:05:03.056
Jeffrey, do you want to-- oh.

00:05:03.056 --> 00:05:04.960
[LAUGHTER]

00:05:04.960 --> 00:05:05.710
We took two years.

00:05:05.710 --> 00:05:06.210
No.

00:05:09.407 --> 00:05:11.490
So we'll start with some
of the small things we've

00:05:11.490 --> 00:05:12.740
done with the language itself.

00:05:12.740 --> 00:05:15.630
So for instance,
one of the things

00:05:15.630 --> 00:05:17.593
with the when statements
is that often you

00:05:17.593 --> 00:05:19.260
have to capture the
value of a variable,

00:05:19.260 --> 00:05:21.480
and then you have to
examine that variable,

00:05:21.480 --> 00:05:24.060
and you're only using
that inside your actual

00:05:24.060 --> 00:05:25.008
when statement.

00:05:25.008 --> 00:05:26.550
So we've made this
a little bit nicer

00:05:26.550 --> 00:05:29.310
in that you can essentially
declare the variable inside the

00:05:29.310 --> 00:05:30.700
when statement itself.

00:05:30.700 --> 00:05:33.570
So you don't have to have it
reference outside of the scope.

00:05:33.570 --> 00:05:37.170
And this gives you the
semanticness in your language,

00:05:37.170 --> 00:05:40.140
so that people understand
that this is actually limited

00:05:40.140 --> 00:05:42.420
to just the conditional.

00:05:42.420 --> 00:05:44.130
But let's talk about
a little bit more

00:05:44.130 --> 00:05:45.960
some nice features
that we've introduced.

00:05:45.960 --> 00:05:47.400
Not that those weren't nice.

00:05:47.400 --> 00:05:50.310
I'm just saying nicer features
that we've introduced.

00:05:50.310 --> 00:05:53.490
So let's say that I have,
for instance, an application,

00:05:53.490 --> 00:05:55.595
and I want to create a class.

00:05:55.595 --> 00:05:56.970
And I'm going to
create my class,

00:05:56.970 --> 00:06:01.382
and it's going to be
called the MicroserviceAPI.

00:06:01.382 --> 00:06:04.830
So I can create an instance
of my MicroserviceAPI,

00:06:04.830 --> 00:06:06.715
and I'll say MicroserviceAPI.

00:06:06.715 --> 00:06:08.198
There we go.

00:06:08.198 --> 00:06:10.740
Now, the thing is, I don't know
if this microservice thing is

00:06:10.740 --> 00:06:11.460
going to last.

00:06:11.460 --> 00:06:13.810
It might just be a fad.

00:06:13.810 --> 00:06:16.140
So what I want to
do is tell people

00:06:16.140 --> 00:06:18.060
that are using this
that this is kind

00:06:18.060 --> 00:06:20.520
of like an experimental feature.

00:06:20.520 --> 00:06:22.020
So what we can do
is we can actually

00:06:22.020 --> 00:06:23.670
create an annotation class.

00:06:23.670 --> 00:06:26.160
And I can say, for
example, this is a new API

00:06:26.160 --> 00:06:29.190
and then annotate
that annotation class

00:06:29.190 --> 00:06:32.450
with this other class
called Experimental.

00:06:32.450 --> 00:06:36.840
And now I can use that new
Experimental annotation

00:06:36.840 --> 00:06:40.560
that I have created on anything
that I consider experimental

00:06:40.560 --> 00:06:41.850
in my API.

00:06:41.850 --> 00:06:44.250
So I could add
this new API here.

00:06:44.250 --> 00:06:46.980
And as soon as I do that,
notice that this is going red.

00:06:46.980 --> 00:06:49.220
So it's giving me
a compiler error.

00:06:49.220 --> 00:06:51.460
It's saying that
you cannot use this,

00:06:51.460 --> 00:06:53.310
because this is an
experimental feature.

00:06:53.310 --> 00:06:56.020
If we hover over it, it's
saying that it's experimental.

00:06:56.020 --> 00:06:57.840
And in fact, we can change that.

00:06:57.840 --> 00:07:00.390
We can say that instead
of it being an error,

00:07:00.390 --> 00:07:04.980
we can actually define
it as the warning.

00:07:04.980 --> 00:07:07.230
So here it could be a warning,
and it's just now going

00:07:07.230 --> 00:07:09.180
to show up as a warning.

00:07:09.180 --> 00:07:11.340
So in order to use
this, the developer

00:07:11.340 --> 00:07:14.440
has to essentially opt
in to this feature.

00:07:14.440 --> 00:07:17.130
So what I could do
is hit Alt-Enter,

00:07:17.130 --> 00:07:20.560
and now that adds the new
API to my function call.

00:07:20.560 --> 00:07:22.220
So anywhere where
I'm using this,

00:07:22.220 --> 00:07:24.990
it is saying that this is
an experimental feature.

00:07:24.990 --> 00:07:28.500
This gives people
idea into you can now

00:07:28.500 --> 00:07:34.290
create APIs that could be
experimental and kind of like,

00:07:34.290 --> 00:07:35.790
I'm not going to
guarantee anything.

00:07:35.790 --> 00:07:37.680
If tomorrow we want to
change something, it's OK.

00:07:37.680 --> 00:07:38.520
You had the warning.

00:07:38.520 --> 00:07:39.720
You did hit Alt-Enter.

00:07:39.720 --> 00:07:41.160
I saw you hit Alt-Enter.

00:07:41.160 --> 00:07:41.670
It's OK.

00:07:41.670 --> 00:07:43.357
It's your own fault.

00:07:43.357 --> 00:07:45.690
And one of the things that
we've actually done with this

00:07:45.690 --> 00:07:47.800
is we've introduced this
concept of contracts.

00:07:47.800 --> 00:07:50.610
So if you're familiar with
a little bit code contracts,

00:07:50.610 --> 00:07:53.190
we've introduced this as a
experimental feature in Kotlin

00:07:53.190 --> 00:07:53.980
as well.

00:07:53.980 --> 00:07:57.150
So let's say that I have
some function that is

00:07:57.150 --> 00:07:58.890
like, for example, printLength.

00:07:58.890 --> 00:08:02.580
And this is going to take
a string that is nullable,

00:08:02.580 --> 00:08:07.210
and then it's going to
do if string is not-null,

00:08:07.210 --> 00:08:12.460
I'm going to do println length.

00:08:12.460 --> 00:08:14.920
Now, this works, and
it's done a smart cast

00:08:14.920 --> 00:08:17.650
to a string, a
not-nullable string,

00:08:17.650 --> 00:08:19.780
because it detects
that I've already

00:08:19.780 --> 00:08:21.370
found out that this
is not-nullable,

00:08:21.370 --> 00:08:23.763
so I can do this smart cast.

00:08:23.763 --> 00:08:26.180
But if I were to take this,
and instead of doing not-null,

00:08:26.180 --> 00:08:31.360
I do something like notNull,
and I go ahead and create

00:08:31.360 --> 00:08:34.360
my function, so let's say
I create my function that

00:08:34.360 --> 00:08:43.340
is a String and notNull, that's
going to return a Boolean.

00:08:43.340 --> 00:08:45.410
And then I say return
this is not-null.

00:08:48.380 --> 00:08:51.020
You see that it doesn't
have that effect,

00:08:51.020 --> 00:08:53.900
because the compiler doesn't
guarantee that that is actually

00:08:53.900 --> 00:08:55.130
not-nullable.

00:08:55.130 --> 00:08:58.880
So it would really nice to
kind of tell the compiler

00:08:58.880 --> 00:09:04.760
that this function complies
with a certain contract.

00:09:04.760 --> 00:09:06.620
And you can do this
in Kotlin by defining,

00:09:06.620 --> 00:09:09.530
using the contract lambda,
the contract function, which

00:09:09.530 --> 00:09:10.700
is contract.

00:09:10.700 --> 00:09:13.200
And I can say that
that's imported.

00:09:13.200 --> 00:09:18.350
And I can say
returns, true, implies

00:09:18.350 --> 00:09:24.748
that this@notNull is not-null.

00:09:24.748 --> 00:09:25.790
Now, this gives an error.

00:09:25.790 --> 00:09:26.450
Ignore it.

00:09:26.450 --> 00:09:27.380
No, I'm joking.

00:09:27.380 --> 00:09:29.180
The reason that
this gives an error

00:09:29.180 --> 00:09:32.433
is because this, as I mentioned,
is an experimental feature.

00:09:32.433 --> 00:09:33.350
And there's two ways--

00:09:33.350 --> 00:09:35.930
I showed you the first one--
you could add the annotation.

00:09:35.930 --> 00:09:38.790
But if you add the annotation,
that doesn't propagate.

00:09:38.790 --> 00:09:41.330
So if something
is using that API,

00:09:41.330 --> 00:09:43.610
that also has to
add the annotation.

00:09:43.610 --> 00:09:45.620
You can add the
propagating annotation

00:09:45.620 --> 00:09:49.310
to this, which is
this format, and now I

00:09:49.310 --> 00:09:50.730
don't have to do that.

00:09:50.730 --> 00:09:53.240
And as soon as I add that
notice, that this now

00:09:53.240 --> 00:09:58.640
automatically again casts to
a string that is not-nullable.

00:09:58.640 --> 00:10:02.570
So this allows you to actually
create contracts and say

00:10:02.570 --> 00:10:06.530
that your arguments
to your function

00:10:06.530 --> 00:10:08.420
match certain conditions.

00:10:08.420 --> 00:10:10.160
And that basically
is guaranteeing

00:10:10.160 --> 00:10:12.920
you a certain level
of code correctness

00:10:12.920 --> 00:10:15.538
in your actual code.

00:10:15.538 --> 00:10:17.080
So what else have
we been working on?

00:10:17.080 --> 00:10:20.290
Well, we've done this thing
called serialization, which

00:10:20.290 --> 00:10:23.230
is a serialization library,
which is multiplatform

00:10:23.230 --> 00:10:28.090
and that is targeting JVM,
JavaScript, Kotlin/Native, iOS,

00:10:28.090 --> 00:10:30.490
macOS, Linux, Windows, Embedded.

00:10:30.490 --> 00:10:33.460
I think I mentioned
everything under the sun.

00:10:33.460 --> 00:10:35.560
And this is a
multiplatform library

00:10:35.560 --> 00:10:38.267
that doesn't require
any kind of reflection,

00:10:38.267 --> 00:10:39.850
and it's part of
some of the offerings

00:10:39.850 --> 00:10:43.180
that we're doing as part of
the language and the ecosystem

00:10:43.180 --> 00:10:44.420
around it.

00:10:44.420 --> 00:10:48.160
So here you can see that I have
a class, a typical data class,

00:10:48.160 --> 00:10:52.240
and I have added this
serializable annotation to it,

00:10:52.240 --> 00:10:55.330
which is part of the Kotlin
serialization library,

00:10:55.330 --> 00:10:59.590
and then I have a customer and
I have a list of customers.

00:10:59.590 --> 00:11:01.610
So I could do
something like println.

00:11:01.610 --> 00:11:07.600
And then here I'm going to
do Json.stringify, Customer,

00:11:07.600 --> 00:11:10.690
and indicate the serializer
I want to use, and then

00:11:10.690 --> 00:11:12.490
pass in the actual customer.

00:11:12.490 --> 00:11:16.000
And I could do exactly the same
thing for a list of customers.

00:11:16.000 --> 00:11:19.910
So I could do list here and then
pass in the list of customers.

00:11:19.910 --> 00:11:23.170
And if I were to run this, what
this is basically going to do

00:11:23.170 --> 00:11:27.032
is output that
data class in JSON.

00:11:27.032 --> 00:11:28.240
And we have support for JSON.

00:11:28.240 --> 00:11:29.500
We have support for Protobuf.

00:11:29.500 --> 00:11:32.670
And other things
are in the works.

00:11:32.670 --> 00:11:35.140
And we can obviously
do the reverse as well.

00:11:35.140 --> 00:11:36.640
So I could say,
for example, let's

00:11:36.640 --> 00:11:39.080
say that I have some JSON here.

00:11:39.080 --> 00:11:42.440
So let's go ahead
and create some JSON.

00:11:45.370 --> 00:11:52.220
So we'll do id equals 1,
and then name equals Me,

00:11:52.220 --> 00:11:55.990
and then email
equals you@me.com.

00:11:55.990 --> 00:11:59.200
I'm so creative.

00:11:59.200 --> 00:12:02.780
And now I can do println,
and in this case,

00:12:02.780 --> 00:12:09.070
I'm going to do Json.parse,
passing again the serializer,

00:12:09.070 --> 00:12:11.570
and then the actual JSON
that I want to pass in.

00:12:11.570 --> 00:12:13.510
And what this will do
is essentially create

00:12:13.510 --> 00:12:16.360
the actual data class
object for me in reverse.

00:12:16.360 --> 00:12:19.300
And you can see that it
also has support for--

00:12:19.300 --> 00:12:21.940
it creates the data
object for me in reverse.

00:12:21.940 --> 00:12:22.930
What did I do?

00:12:22.930 --> 00:12:24.055
Email, name, email.

00:12:26.770 --> 00:12:28.787
AUDIENCE: [INAUDIBLE]

00:12:28.787 --> 00:12:30.370
HADI HARIRI: Field
source is required?

00:12:30.370 --> 00:12:32.782
No, it's not.

00:12:32.782 --> 00:12:35.590
AUDIENCE: [INAUDIBLE]

00:12:35.590 --> 00:12:37.000
HADI HARIRI: No.

00:12:37.000 --> 00:12:39.010
That should actually-- right.

00:12:39.010 --> 00:12:40.828
Anyway, so that was working.

00:12:40.828 --> 00:12:42.700
[LAUGHTER]

00:12:42.700 --> 00:12:43.330
That's Jeffrey.

00:12:43.330 --> 00:12:43.960
He did something.

00:12:43.960 --> 00:12:45.002
JEFFREY VAN GOGH: Uh-huh.

00:12:45.002 --> 00:12:46.270
[APPLAUSE]

00:12:48.580 --> 00:12:52.150
HADI HARIRI: I really
like when people clap.

00:12:52.150 --> 00:12:54.170
So I don't know what's
happening there.

00:12:54.170 --> 00:12:56.233
But that's the good
thing about live demos.

00:12:56.233 --> 00:12:58.150
I want to make sure that
something goes wrong.

00:12:58.150 --> 00:12:59.680
I actually did that on purpose.

00:12:59.680 --> 00:13:01.310
So I've done that
as an exercise,

00:13:01.310 --> 00:13:03.340
so that later you come
to me in our office hours

00:13:03.340 --> 00:13:07.100
and you tell me what's
wrong with that.

00:13:07.100 --> 00:13:08.505
Let's move on.

00:13:08.505 --> 00:13:09.880
The next thing I
want to show you

00:13:09.880 --> 00:13:13.930
is a quick overview also on
terms of annotation classes.

00:13:13.930 --> 00:13:16.571
Here, we've added some
additional things for support

00:13:16.571 --> 00:13:17.350
for enums.

00:13:17.350 --> 00:13:20.500
For example, I can get the
have enums in my annotation.

00:13:20.500 --> 00:13:22.070
I can have nested annotations.

00:13:22.070 --> 00:13:25.550
I can have properties as
part of my companion object.

00:13:25.550 --> 00:13:27.790
So again, this gives
me more expressiveness

00:13:27.790 --> 00:13:31.520
in when I'm using the
actual annotations.

00:13:31.520 --> 00:13:33.920
Now there's one other thing
that we've been working on,

00:13:33.920 --> 00:13:35.560
which you may have
heard about, which

00:13:35.560 --> 00:13:38.200
is multiplatform programming.

00:13:38.200 --> 00:13:40.940
And the idea behind
multiplatform programming,

00:13:40.940 --> 00:13:44.710
which is a mouthful, is the
idea that right now Kotlin

00:13:44.710 --> 00:13:49.080
allows you to target
different types of platforms.

00:13:49.080 --> 00:13:50.710
So I can target the JVM.

00:13:50.710 --> 00:13:54.150
I can target JavaScript.

00:13:54.150 --> 00:13:57.527
I can target native, et cetera.

00:13:57.527 --> 00:13:59.110
Now one of the great
things about this

00:13:59.110 --> 00:14:01.580
is the ability to be
able to share code,

00:14:01.580 --> 00:14:04.080
because there's a lot of code
that I want to end up sharing.

00:14:04.080 --> 00:14:04.360
Right?

00:14:04.360 --> 00:14:06.860
There's business logic, there's
validation logic, et cetera,

00:14:06.860 --> 00:14:08.390
that I want to end up sharing.

00:14:08.390 --> 00:14:10.840
So how do we kind of do this?

00:14:10.840 --> 00:14:13.570
This is where we've introduced
the concept of multiplatform

00:14:13.570 --> 00:14:14.668
programming.

00:14:14.668 --> 00:14:16.210
And as a consequence
of that, you now

00:14:16.210 --> 00:14:19.550
have the idea of having
this multiplatform project.

00:14:19.550 --> 00:14:22.720
So you can see here that I've
got this project in my IDE

00:14:22.720 --> 00:14:26.990
and I'm targeting different
kinds of platforms.

00:14:26.990 --> 00:14:31.120
So I have macOS, I have
JVM, and I have JavaScript.

00:14:31.120 --> 00:14:33.640
And then I have a
series of common code

00:14:33.640 --> 00:14:35.740
which is called common.

00:14:35.740 --> 00:14:38.660
And inside here
I have some code.

00:14:38.660 --> 00:14:41.290
So here I have this
function called hello

00:14:41.290 --> 00:14:43.660
that is saying hello
from platform.name.

00:14:43.660 --> 00:14:47.650
And platform.name is
a property of object.

00:14:47.650 --> 00:14:49.420
But the difference
is that this object

00:14:49.420 --> 00:14:53.210
has this word in front of
it, which is called expect.

00:14:53.210 --> 00:14:56.620
So what this is saying
is that this is some code

00:14:56.620 --> 00:14:58.750
that I can reference
in my common code,

00:14:58.750 --> 00:15:01.870
but the implementation is
not actually provided here.

00:15:01.870 --> 00:15:04.150
The implementation is
going to be provided

00:15:04.150 --> 00:15:07.240
on different types of
platforms in a different way,

00:15:07.240 --> 00:15:09.977
because it can vary
based on the platform.

00:15:09.977 --> 00:15:11.560
So you can see that
it's got this cute

00:15:11.560 --> 00:15:13.360
little a in the corner here.

00:15:13.360 --> 00:15:17.020
And if we hit Alt Enter, when
we say go to declaration,

00:15:17.020 --> 00:15:20.980
it asks me which platform
declaration do I want to go to.

00:15:20.980 --> 00:15:24.310
So if I say JVM, it will
take me to the JVM one.

00:15:24.310 --> 00:15:27.910
If I go back and I say go to
actual declaration on macOS,

00:15:27.910 --> 00:15:30.100
it will take me
to the macOS one.

00:15:30.100 --> 00:15:31.150
Right?

00:15:31.150 --> 00:15:35.200
So for different platforms I can
have different implementations,

00:15:35.200 --> 00:15:39.320
and yet I can reference
that code in my common code

00:15:39.320 --> 00:15:42.430
and use it as part of
my shared code base.

00:15:42.430 --> 00:15:44.410
And a cool thing-- so
kind of like, think of it

00:15:44.410 --> 00:15:46.120
as a little bit like
interfaces and then

00:15:46.120 --> 00:15:48.100
the implementation
of those interfaces.

00:15:48.100 --> 00:15:50.620
And the cool thing is that you
get the static compile time

00:15:50.620 --> 00:15:51.620
checking, so to speak.

00:15:51.620 --> 00:15:54.700
So if I were to comment
this out and I go back here,

00:15:54.700 --> 00:15:56.770
you can see that it's
giving me an error,

00:15:56.770 --> 00:15:59.050
saying that one of
the actual platforms

00:15:59.050 --> 00:16:02.030
is missing an implementation.

00:16:02.030 --> 00:16:05.320
So this is allowing
you to now create

00:16:05.320 --> 00:16:09.790
multiplatform projects that
allow you to share common code

00:16:09.790 --> 00:16:13.450
base and then have specific
implementations based

00:16:13.450 --> 00:16:17.167
on the actual target a
little bit differently.

00:16:17.167 --> 00:16:19.000
And that's part of the
multiplatform project

00:16:19.000 --> 00:16:22.240
that we are offering
moving forward with Kotlin,

00:16:22.240 --> 00:16:23.740
allowing you to,
for example, create

00:16:23.740 --> 00:16:28.570
Android applications that share
common code base with Android,

00:16:28.570 --> 00:16:29.770
iOS, et cetera.

00:16:29.770 --> 00:16:31.720
And if we can switch
back to slides,

00:16:31.720 --> 00:16:33.667
I will talk to you a
little bit about some

00:16:33.667 --> 00:16:35.500
of the other things
that we've been bringing

00:16:35.500 --> 00:16:37.600
to Kotlin the language.

00:16:37.600 --> 00:16:39.720
We have more standard
library APIs.

00:16:39.720 --> 00:16:42.790
We're still keeping the
API numbers of methods

00:16:42.790 --> 00:16:45.850
calls kind of low, but we're
adding a lot more functionality

00:16:45.850 --> 00:16:46.870
in that area.

00:16:46.870 --> 00:16:49.210
Support for unsigned integers--

00:16:49.210 --> 00:16:50.060
anybody?

00:16:50.060 --> 00:16:50.560
No?

00:16:50.560 --> 00:16:51.060
Yes.

00:16:51.060 --> 00:16:53.702
[APPLAUSE]

00:16:53.702 --> 00:16:55.660
I just added that because
I know someone always

00:16:55.660 --> 00:16:58.210
claps about that.

00:16:58.210 --> 00:17:02.070
Obviously, we announced packet
KotlinConf in 2018 that's

00:17:02.070 --> 00:17:04.480
Kotlin native has hit beta.

00:17:04.480 --> 00:17:07.599
In terms of tooling, we've
provided improved performance

00:17:07.599 --> 00:17:10.030
speed, parallel builds
for Gradle projects,

00:17:10.030 --> 00:17:12.910
incremental annotation
processing with KAPT.

00:17:12.910 --> 00:17:16.030
And shout out to Ivan
Garvrilovic from Google

00:17:16.030 --> 00:17:17.980
for helping us with that.

00:17:17.980 --> 00:17:20.140
New type inference
engine, which helps

00:17:20.140 --> 00:17:22.089
in a lot of cases
in interoperability,

00:17:22.089 --> 00:17:24.460
especially if you're
doing things around RX,

00:17:24.460 --> 00:17:26.619
as well as making the
language a little bit more

00:17:26.619 --> 00:17:29.560
concise when you're using
builders, et cetera.

00:17:29.560 --> 00:17:32.290
And we've introduced this
progressive mode, which

00:17:32.290 --> 00:17:36.130
is essentially allowing
you to try out Kotlin,

00:17:36.130 --> 00:17:39.610
try out new features, even if
those features will actually

00:17:39.610 --> 00:17:41.150
break some code.

00:17:41.150 --> 00:17:42.700
So that's a flag
that you can now

00:17:42.700 --> 00:17:45.640
enable with Kotlin to kind
of live a little bit more

00:17:45.640 --> 00:17:46.890
on the edge.

00:17:46.890 --> 00:17:48.640
And with that, I'll
hand it off to Jeffrey

00:17:48.640 --> 00:17:51.057
that's going to show you some
other things that we've been

00:17:51.057 --> 00:17:52.655
doing in Android specifically.

00:17:52.655 --> 00:17:53.947
JEFFREY VAN GOGH: Thanks, Hadi.

00:17:53.947 --> 00:17:56.956
I think there is one feature
that you forgot to demo.

00:17:56.956 --> 00:17:59.340
HADI HARIRI: I have no idea
what you're talking about.

00:17:59.340 --> 00:17:59.500
JEFFREY VAN GOGH: It's OK.

00:17:59.500 --> 00:18:00.500
I'll show it to my demo.

00:18:00.500 --> 00:18:02.150
HADI HARIRI: You
probably broke it.

00:18:02.150 --> 00:18:02.885
[LAUGHTER]

00:18:02.885 --> 00:18:03.760
JEFFREY VAN GOGH: OK.

00:18:03.760 --> 00:18:06.790
So let's take a look at what we
have done in the Android side

00:18:06.790 --> 00:18:08.020
to support Kotlin.

00:18:08.020 --> 00:18:09.808
So let's first
start with the OS.

00:18:09.808 --> 00:18:11.350
Of course, the OS
works on byte code.

00:18:11.350 --> 00:18:14.173
So there's not a lot we need
to do to support Kotlin.

00:18:14.173 --> 00:18:16.090
But we did make sure
that we added correctness

00:18:16.090 --> 00:18:19.540
and performance tests so that
we don't break Kotlin patterns.

00:18:19.540 --> 00:18:21.550
We implemented a couple
of specific performance

00:18:21.550 --> 00:18:23.830
optimizations based
on those tests,

00:18:23.830 --> 00:18:26.107
specifically for
loop optimizations.

00:18:26.107 --> 00:18:27.940
And then the big thing
we did on the OS side

00:18:27.940 --> 00:18:29.548
is improve debugging support.

00:18:29.548 --> 00:18:31.090
Kotlin has a couple
of the constructs

00:18:31.090 --> 00:18:34.400
like inline functions that you
don't have in other languages.

00:18:34.400 --> 00:18:36.130
And so the new
version of Android

00:18:36.130 --> 00:18:38.620
now support debugging
that better.

00:18:38.620 --> 00:18:41.200
Then next up, the
Android frameworks,

00:18:41.200 --> 00:18:43.380
there's a lot of things
that happen there.

00:18:43.380 --> 00:18:46.060
The big thing is that we
added API annotations.

00:18:46.060 --> 00:18:48.560
So that's not complete yet.

00:18:48.560 --> 00:18:51.750
But any new API, we now have
nullness and default parameter,

00:18:51.750 --> 00:18:54.370
have default value
annotations, so you

00:18:54.370 --> 00:18:55.590
can use those from Kotlin.

00:18:55.590 --> 00:18:57.340
And we're working
through the existing API

00:18:57.340 --> 00:18:59.470
to annotate that as well.

00:18:59.470 --> 00:19:01.840
Then we added these
Kotlin extension APIs.

00:19:01.840 --> 00:19:03.820
So these are extra
libraries that you

00:19:03.820 --> 00:19:06.490
include in your
projects that provide

00:19:06.490 --> 00:19:08.230
extra APIs through
extension methods that

00:19:08.230 --> 00:19:12.550
make your Kotlin
code more idiomatic.

00:19:12.550 --> 00:19:15.040
Then we add coroutine
support for a whole bunch

00:19:15.040 --> 00:19:16.930
of the Jetpack libraries.

00:19:16.930 --> 00:19:18.280
[APPLAUSE]

00:19:18.280 --> 00:19:20.710
So this allows you to
write asynchronous code

00:19:20.710 --> 00:19:22.600
in a more procedural way.

00:19:22.600 --> 00:19:25.690
And of course, yesterday we
announced Jetpack Compose,

00:19:25.690 --> 00:19:28.150
which is all Kotlin.

00:19:28.150 --> 00:19:30.390
So let's take a
look at the demo.

00:19:30.390 --> 00:19:33.520
OK, so if I build
a small app here,

00:19:33.520 --> 00:19:35.890
it downloads a
list of shows that

00:19:35.890 --> 00:19:39.610
are available from a
server using retrofit.

00:19:39.610 --> 00:19:42.460
And then it checks against
the local SQL database

00:19:42.460 --> 00:19:46.330
if I've watched these
shows using the room APIs.

00:19:46.330 --> 00:19:48.010
So here, you see
that I have defined

00:19:48.010 --> 00:19:52.060
the API to get the list of
shows in both using RX Java,

00:19:52.060 --> 00:19:55.730
as well as using the Kotlin
coding async feature.

00:19:55.730 --> 00:19:57.820
And you see that the APIs
are pretty much the same

00:19:57.820 --> 00:20:01.230
with like, just a little
different return type.

00:20:01.230 --> 00:20:02.790
And the room side--

00:20:02.790 --> 00:20:03.490
oh, sorry.

00:20:10.308 --> 00:20:14.590
(QUIETLY) Where did my code go?

00:20:14.590 --> 00:20:15.910
OK, we'll skip the API.

00:20:15.910 --> 00:20:17.327
It's pretty much--
oh, here it is.

00:20:17.327 --> 00:20:17.830
Sorry.

00:20:17.830 --> 00:20:18.913
So you see the same thing.

00:20:18.913 --> 00:20:20.220
Have I watched the show?

00:20:20.220 --> 00:20:22.150
RX in Java, it's very similar.

00:20:22.150 --> 00:20:23.090
Here is a Flowable.

00:20:23.090 --> 00:20:25.600
There is a [INAUDIBLE].

00:20:25.600 --> 00:20:27.260
So the API is pretty similar.

00:20:27.260 --> 00:20:28.690
Now let's look at
the way you call

00:20:28.690 --> 00:20:30.780
that code between RX and Java--

00:20:30.780 --> 00:20:32.630
RX and coroutines.

00:20:32.630 --> 00:20:38.080
So in RX, we use a lot of
operators to do our show--

00:20:38.080 --> 00:20:41.070
do our flow with all
the asynchronous calls.

00:20:41.070 --> 00:20:42.588
And these can become
pretty complex.

00:20:42.588 --> 00:20:44.630
And you see that this code
is highlighted yellow.

00:20:44.630 --> 00:20:46.255
It means that there's
something I'm not

00:20:46.255 --> 00:20:47.468
doing with the return type.

00:20:47.468 --> 00:20:49.510
So you need to make sure
that when you subscribe,

00:20:49.510 --> 00:20:53.200
you deal with the subscription.

00:20:53.200 --> 00:20:56.890
Of course, RX brought great
expressibility to Java.

00:20:56.890 --> 00:20:59.580
And the inventors of
RX, they were smart.

00:20:59.580 --> 00:21:01.840
They knew what
they were building.

00:21:01.840 --> 00:21:04.030
But they were limited
by the language.

00:21:04.030 --> 00:21:06.280
In Kotlin, we now
have coroutines

00:21:06.280 --> 00:21:08.410
and we can actually
do this much nicer.

00:21:08.410 --> 00:21:11.950
So here is the same
code using coroutines.

00:21:11.950 --> 00:21:14.950
We first get the list of
shows from the server,

00:21:14.950 --> 00:21:17.080
and then we call
this a wait function.

00:21:17.080 --> 00:21:18.580
And the ID tells
you, hey, there's

00:21:18.580 --> 00:21:21.090
something asynchronous
going on here.

00:21:21.090 --> 00:21:22.760
Then we can use
regular for loops.

00:21:22.760 --> 00:21:25.095
And it [INAUDIBLE]
over the return shows.

00:21:25.095 --> 00:21:26.470
And then we make
our asynchronous

00:21:26.470 --> 00:21:30.400
call to see if I have watched
the show in the local database.

00:21:30.400 --> 00:21:31.910
And then we continue from there.

00:21:31.910 --> 00:21:34.240
And then here, you see
this launch call, which

00:21:34.240 --> 00:21:35.800
will tell you,
hey, make this call

00:21:35.800 --> 00:21:38.770
to make sure that we notify
that the data set has changed

00:21:38.770 --> 00:21:41.020
on the UI thread.

00:21:41.020 --> 00:21:44.290
And so the nice thing here is
that it looks more procedural.

00:21:44.290 --> 00:21:48.010
And when I do my debugging--

00:21:48.010 --> 00:21:49.140
I have to launch now--

00:21:58.760 --> 00:22:02.130
And that's not
working, of course.

00:22:02.130 --> 00:22:02.630
Oh!

00:22:02.630 --> 00:22:03.080
There we go.

00:22:03.080 --> 00:22:03.955
It's already running.

00:22:03.955 --> 00:22:05.820
So you see that I
can actually look

00:22:05.820 --> 00:22:07.680
at variables from
the whole method,

00:22:07.680 --> 00:22:10.608
not just from the
specific operator.

00:22:10.608 --> 00:22:12.150
And so it makes your
life much easier

00:22:12.150 --> 00:22:14.190
when you're debugging
your asynchronous code.

00:22:14.190 --> 00:22:15.648
So let's switch
back to the slides.

00:22:20.020 --> 00:22:21.995
So next, Android Tooling.

00:22:21.995 --> 00:22:23.870
We have done a lot of
stuff in Android Studio

00:22:23.870 --> 00:22:25.820
to make sure that Kotlin
is supported well.

00:22:25.820 --> 00:22:27.403
The first thing we
did is we made sure

00:22:27.403 --> 00:22:29.970
that the Kotlin plugin
is part of Android Studio

00:22:29.970 --> 00:22:32.570
so that we can test it
well before we release it.

00:22:32.570 --> 00:22:34.890
And we also worked
closely with JetBrains.

00:22:34.890 --> 00:22:37.290
Anytime they update
the Kotlin plugin,

00:22:37.290 --> 00:22:39.830
we test it before they
go public to make sure

00:22:39.830 --> 00:22:42.830
that Android Studio and
Kotlin work well together.

00:22:42.830 --> 00:22:46.280
Next, we added Android
specific refactoring support.

00:22:46.280 --> 00:22:48.110
There's a lot of
actions in the IDE

00:22:48.110 --> 00:22:50.240
that are Android
specific refactorings.

00:22:50.240 --> 00:22:52.580
And we're working
on adding support

00:22:52.580 --> 00:22:54.980
for all of those in Kotlin.

00:22:54.980 --> 00:22:57.230
On the Lint side,
Lint has pretty much

00:22:57.230 --> 00:22:59.230
completely rewritten.

00:22:59.230 --> 00:23:03.020
It used to write [INAUDIBLE]
checks for Java language.

00:23:03.020 --> 00:23:04.940
Now it uses this
thing called UAST,

00:23:04.940 --> 00:23:08.420
which allows you to write
the same Lint check once.

00:23:08.420 --> 00:23:11.990
And then it can analyze
both Kotlin and Java code.

00:23:11.990 --> 00:23:13.700
We added product
templates so that when

00:23:13.700 --> 00:23:17.013
you're creating a new
fragment or a new activity,

00:23:17.013 --> 00:23:18.680
you have Kotlin code
right in the start.

00:23:18.680 --> 00:23:20.670
You don't have to convert that.

00:23:20.670 --> 00:23:23.630
Now on the compiler
side, our new Shrinker R8

00:23:23.630 --> 00:23:25.585
has a lot of
Kotlin-specific optimization

00:23:25.585 --> 00:23:28.670
in it, so that you get
the benefit of making

00:23:28.670 --> 00:23:30.690
your code as small as possible.

00:23:30.690 --> 00:23:34.210
And of course, the IDE has
now support for the Jetpack

00:23:34.210 --> 00:23:38.170
composed framework.

00:23:38.170 --> 00:23:41.030
On documentation
and sample site,

00:23:41.030 --> 00:23:43.730
if you look at the
developer.android.com,

00:23:43.730 --> 00:23:47.480
all API references now have
both Kotlin and Java syntax

00:23:47.480 --> 00:23:48.710
available.

00:23:48.710 --> 00:23:51.500
There is a Kotlin-specific
documentation portal

00:23:51.500 --> 00:23:54.140
which will tell you how to get
started on Kotlin, how to use

00:23:54.140 --> 00:23:57.410
caller routines, et cetera.

00:23:57.410 --> 00:23:59.600
You also see that a lot of
the samples and snippets

00:23:59.600 --> 00:24:01.370
now have Kotlin available.

00:24:01.370 --> 00:24:03.830
That's both on the sides,
on our GitHub samples.

00:24:03.830 --> 00:24:07.280
As well as if look on
Google I/O this year,

00:24:07.280 --> 00:24:09.670
you'll see that most of the
presentations from Androids

00:24:09.670 --> 00:24:12.320
do their samples in Kotlin.

00:24:12.320 --> 00:24:15.440
There's a couple of apps
you can take a look as well.

00:24:15.440 --> 00:24:19.130
The Google I/O app, as well as
this new Android Sunflower app

00:24:19.130 --> 00:24:21.320
have been built up from
the ground up using Kotlin.

00:24:24.070 --> 00:24:25.810
We often get asked
hey, it's great

00:24:25.810 --> 00:24:28.510
that you guys are
recommending Kotlin.

00:24:28.510 --> 00:24:31.450
But are you using it yourself?

00:24:31.450 --> 00:24:33.800
And of course, that's
a very fair question.

00:24:33.800 --> 00:24:37.960
And now at Google, we have a
lot of in-house developer tools.

00:24:37.960 --> 00:24:42.100
And so it took us some time to
add Kotlin support to those.

00:24:42.100 --> 00:24:44.507
We started out with
internal apps for Googlers.

00:24:44.507 --> 00:24:46.090
For instance, there
is an internal app

00:24:46.090 --> 00:24:49.783
that shows you maps
and office locations.

00:24:49.783 --> 00:24:51.200
And so we learned
a lot from that.

00:24:51.200 --> 00:24:52.742
And then since then,
we have actually

00:24:52.742 --> 00:24:56.140
started using Kotlin in some
of the public Google Apps.

00:24:56.140 --> 00:24:57.940
And so here are some
of the apps that

00:24:57.940 --> 00:25:02.000
are shipping Kotlin code
on your phones today.

00:25:02.000 --> 00:25:03.730
And you can expect
many more to follow.

00:25:06.340 --> 00:25:08.350
Talking about adopting
Kotlin, if you

00:25:08.350 --> 00:25:11.800
look at the whole
ecosystem, we've

00:25:11.800 --> 00:25:14.050
seen that in active
development--

00:25:14.050 --> 00:25:16.120
and active development
is apps that

00:25:16.120 --> 00:25:18.950
have had an upload to the Play
store in the last six months,

00:25:18.950 --> 00:25:22.150
we see that 16% of the
apps are now using Kotlin.

00:25:22.150 --> 00:25:24.970
And keep in mind, an
app can be up developed

00:25:24.970 --> 00:25:27.730
just because there's one
bug fix or one asset change.

00:25:27.730 --> 00:25:29.270
So 16% is pretty impressive.

00:25:29.270 --> 00:25:31.640
That's five times
growth since last I/O.

00:25:31.640 --> 00:25:33.448
And if you look at
the top thousand apps,

00:25:33.448 --> 00:25:34.990
that's actually
already a lot bigger.

00:25:34.990 --> 00:25:37.230
44% of the apps there
we see using Kotlin.

00:25:40.320 --> 00:25:42.510
So that brings us
to Kotlin first.

00:25:42.510 --> 00:25:43.718
We announced that yesterday.

00:25:43.718 --> 00:25:46.260
And so I wanted to give you a
bit more overview of why we did

00:25:46.260 --> 00:25:48.960
it and what it's going to mean.

00:25:48.960 --> 00:25:51.660
So why would we
announce Kotlin first?

00:25:51.660 --> 00:25:54.790
We see strong adoption
of people using Kotlin.

00:25:54.790 --> 00:25:57.430
And we see a big
excitement in the community

00:25:57.430 --> 00:25:59.100
when people start using Kotlin.

00:25:59.100 --> 00:26:02.222
In fact, when people
are asked in our surveys

00:26:02.222 --> 00:26:03.930
on how much happier
they're using Kotlin,

00:26:03.930 --> 00:26:06.110
they actually score
25% higher than people

00:26:06.110 --> 00:26:08.520
who are not using Kotlin.

00:26:08.520 --> 00:26:11.070
Many apps across the
industry and inside Google

00:26:11.070 --> 00:26:13.050
are now using Kotlin.

00:26:13.050 --> 00:26:15.670
We've reached out to
many of our customers,

00:26:15.670 --> 00:26:17.380
including our Customer
Advisory Board.

00:26:17.380 --> 00:26:22.770
And like, keep focus on
an investment in Kotlin.

00:26:22.770 --> 00:26:24.267
So what does that mean?

00:26:24.267 --> 00:26:26.850
Of course, we're going to keep
supporting the Java programming

00:26:26.850 --> 00:26:29.070
language in many aspects.

00:26:29.070 --> 00:26:32.460
Platform, Android
Studio Support, Lint,

00:26:32.460 --> 00:26:35.808
like Docs, AndroidX,
that's not going away.

00:26:35.808 --> 00:26:37.350
But if you look at
some other efforts

00:26:37.350 --> 00:26:41.370
like our online training,
samples, we'll first do Kotlin,

00:26:41.370 --> 00:26:44.078
and then Java foreign
language will be best effort.

00:26:44.078 --> 00:26:45.870
And then of course,
there are some features

00:26:45.870 --> 00:26:48.957
like the multiplatform
projects and Jetpack Compose

00:26:48.957 --> 00:26:50.790
that are only going to
be offered in Kotlin.

00:26:53.590 --> 00:26:56.260
Now of course, the next question
that we hear from people is,

00:26:56.260 --> 00:26:58.690
well, does that mean
I should switch?

00:26:58.690 --> 00:27:01.390
Please don't take
Kotlin first as I

00:27:01.390 --> 00:27:05.860
need to go take all my Java
code and rewrite it in Kotlin.

00:27:05.860 --> 00:27:07.870
That's not what
we want you to do.

00:27:07.870 --> 00:27:09.550
Look at Android Studio.

00:27:09.550 --> 00:27:13.030
That is many, many hundred
thousand lines of code.

00:27:13.030 --> 00:27:15.970
Right now, we're about 10%
Kotlin of the Android Studio

00:27:15.970 --> 00:27:17.890
specific code.

00:27:17.890 --> 00:27:20.950
And so what we do is we
only take new functionality,

00:27:20.950 --> 00:27:22.335
write that in Kotlin.

00:27:22.335 --> 00:27:23.710
And it is possible
because Kotlin

00:27:23.710 --> 00:27:26.050
has great interoperability
with Java.

00:27:26.050 --> 00:27:27.670
You can write a
single class in Kotlin

00:27:27.670 --> 00:27:28.753
and keep the rest in Java.

00:27:28.753 --> 00:27:30.640
Or have 99% of your
code in Kotlin,

00:27:30.640 --> 00:27:34.420
and have only some
leftovers in Java.

00:27:34.420 --> 00:27:36.610
Of course, it matters
what is your current state

00:27:36.610 --> 00:27:38.350
of your project and team.

00:27:38.350 --> 00:27:40.660
If you're one week away
from shipping your release,

00:27:40.660 --> 00:27:43.840
that's probably not the best
time to switch to Kotlin.

00:27:43.840 --> 00:27:46.140
But if you're starting
a new development cycle,

00:27:46.140 --> 00:27:49.070
and you're like, hey, I could
probably take on Kotlin.

00:27:49.070 --> 00:27:51.230
And of course, it depends
on your team as well.

00:27:51.230 --> 00:27:52.480
Are they interested in Kotlin?

00:27:56.410 --> 00:27:58.720
Do they feel secure
taking this on?

00:27:58.720 --> 00:28:00.610
We have also found
that a lot of people

00:28:00.610 --> 00:28:04.240
actually use mentioning
Kotlin in their recruitment

00:28:04.240 --> 00:28:06.130
that they can get a
lot more candidates.

00:28:06.130 --> 00:28:08.335
So things to consider--

00:28:08.335 --> 00:28:09.710
of course, on the
technical side,

00:28:09.710 --> 00:28:11.440
there's also
trade-offs to consider.

00:28:11.440 --> 00:28:13.690
Kotlin brings great features,
a lot more productivity,

00:28:13.690 --> 00:28:15.010
and satisfaction.

00:28:15.010 --> 00:28:17.740
But you have to think
about the learning curve.

00:28:17.740 --> 00:28:19.720
It takes time for
people to learn

00:28:19.720 --> 00:28:21.340
to write idiomatic Kotlin.

00:28:21.340 --> 00:28:23.590
We see that most people
who start writing Kotlin

00:28:23.590 --> 00:28:26.238
the first week, they're
really writing Java in Kotlin.

00:28:26.238 --> 00:28:27.780
And it takes them
three to six months

00:28:27.780 --> 00:28:29.890
to really start writing
idiomatic Kotlin.

00:28:29.890 --> 00:28:30.805
That's fine.

00:28:30.805 --> 00:28:33.430
I mean, you still get all
the benefits of Kotlin

00:28:33.430 --> 00:28:35.830
warning you about
nullness, et cetera.

00:28:35.830 --> 00:28:37.930
Then there's the build speed.

00:28:37.930 --> 00:28:40.600
Kotlin is slower than
the Java compiler.

00:28:40.600 --> 00:28:42.970
It's doing more work for you.

00:28:42.970 --> 00:28:44.710
And it's a younger compiler.

00:28:44.710 --> 00:28:47.650
We are working hard
on making it faster.

00:28:47.650 --> 00:28:50.572
And of course, keep in
mind, yes, it's slower,

00:28:50.572 --> 00:28:52.780
but you have to do fewer
builds because your app will

00:28:52.780 --> 00:28:54.680
most likely be correcter.

00:28:54.680 --> 00:28:56.050
And there is also a APK size.

00:28:56.050 --> 00:28:59.680
The app uses standard library,
and it takes some space.

00:28:59.680 --> 00:29:04.150
But things like R8 can
help you reduce that.

00:29:04.150 --> 00:29:07.370
There's a whole bunch of ongoing
Kotlin work going on at Google.

00:29:07.370 --> 00:29:09.760
Of course, Jetpack Compose
is the biggest thing there.

00:29:09.760 --> 00:29:12.887
We always keep adding new
KDX APIs all the time.

00:29:12.887 --> 00:29:15.220
And then on the compiler side,
we're doing a lot of work

00:29:15.220 --> 00:29:17.120
to make it faster.

00:29:17.120 --> 00:29:20.940
And like with Kotlin
10330, we added

00:29:20.940 --> 00:29:22.360
incrementation processors.

00:29:22.360 --> 00:29:24.170
And there's much more to come.

00:29:24.170 --> 00:29:27.490
You'll see more improved tooling
and more docs and samples

00:29:27.490 --> 00:29:30.178
using Kotlin.

00:29:30.178 --> 00:29:31.720
If you're interested
in using Kotlin,

00:29:31.720 --> 00:29:33.310
but you're not sure
where to start,

00:29:33.310 --> 00:29:35.180
we're announcing
Kotlin Everywhere,

00:29:35.180 --> 00:29:38.650
which is a set of trainings
hosted by both Google

00:29:38.650 --> 00:29:41.110
and JetBrains.

00:29:41.110 --> 00:29:43.150
And it's happening
between now and KotlinConf

00:29:43.150 --> 00:29:45.010
at December at the
end of the year.

00:29:45.010 --> 00:29:47.500
If you're interested
in that, either

00:29:47.500 --> 00:29:51.190
participating or helping
hosting it, go to this link

00:29:51.190 --> 00:29:51.700
and sign up.

00:29:54.340 --> 00:29:57.470
So with our new
Kotlin first roadmap,

00:29:57.470 --> 00:29:59.520
the investments in
Kotlin for Android

00:29:59.520 --> 00:30:01.480
is only going to become larger.

00:30:01.480 --> 00:30:04.000
I'd like to invite all of you
who haven't tried Kotlin yet

00:30:04.000 --> 00:30:07.190
or haven't recently used it,
to try it in your app today.

00:30:07.190 --> 00:30:10.450
I hope you'll have a similar
experience like me with Kotlin.

00:30:10.450 --> 00:30:13.727
You will be more predictive
and have more fun coding.

00:30:13.727 --> 00:30:14.560
Thank you very much.

00:30:14.560 --> 00:30:17.910
[MUSIC PLAYING]

