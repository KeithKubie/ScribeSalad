WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.960
&gt;&gt; PARLANTE: All right, hey, everybody. All
right [INDISTINCT] a lot of people working

00:00:03.960 --> 00:00:07.029
away on this one. It's our requirement that
you finish like all the problems on this one,

00:00:07.029 --> 00:00:10.302
I'm just hoping that if you could get like,
some of them. What I'd like to do, is I want

00:00:10.302 --> 00:00:13.650
to do another quick lecture section then I
want to break our time for, you know, the

00:00:13.650 --> 00:00:16.950
nice long exercise at the end. And you're
welcome to keep working on the list problems

00:00:16.950 --> 00:00:20.550
if you want, but this last exercise, once
we have file reading, then could begin to

00:00:20.550 --> 00:00:23.210
look like a real program. And it's going to
involve--it's going to sum up all the material

00:00:23.210 --> 00:00:26.590
we've talked about, lists and strings also,
put it all together and that'll be the last

00:00:26.590 --> 00:00:33.309
thing for today. So, the last day I was sure
to show you is the HashTable or also called

00:00:33.309 --> 00:00:38.239
the dictionary. It's a very useful data structure,
it's built-in to Python; it's pretty easy

00:00:38.239 --> 00:00:46.350
to use. So, the delimiter character for a
dictionary is the curly brace. So here, I'll

00:00:46.350 --> 00:00:50.479
create one. I'll say D is equal to left curly
brace, right curly brace. I'll just create

00:00:50.479 --> 00:00:55.289
an empty one. And the way the dictionary works--and
I've got a little piece of art there from

00:00:55.289 --> 00:01:00.010
the hand out at the top--is you can think
of it as a--it's said to contain key value

00:01:00.010 --> 00:01:05.309
bindings. For each key, it can look up that
value very quickly. So, the way that works

00:01:05.309 --> 00:01:12.740
in Python is I'll say, under the key A, I
would like to store the string alpha, and

00:01:12.740 --> 00:01:17.020
under the string O--I'm just going to make
the same example I have in that little picture

00:01:17.020 --> 00:01:27.880
there--I'll store omega, and under the key
G, I'll store gamma, put it there on my [INDISTINCT].

00:01:27.880 --> 00:01:31.810
So, what HashTable does is you always talk
to it in terms of keys. You say, "Dictionary,

00:01:31.810 --> 00:01:36.170
please store this key," and it will store
whatever. And then later on, when you try

00:01:36.170 --> 00:01:41.640
and retrieve by key--this is the one thing
that HashTables are fast at--it can retrieve

00:01:41.640 --> 00:01:46.340
via key in constant time. It's just as fast
as you can imagine, it's very quick at key

00:01:46.340 --> 00:01:50.420
retrieval. So, for example, if I say, okay
dictionary--and I--in Python, the way it works

00:01:50.420 --> 00:01:54.399
is we just use the square brackets. When I
use the square bracket on the left, I was

00:01:54.399 --> 00:01:59.859
storing a value in. So, that series of three
assignments, that builds exactly this picture

00:01:59.859 --> 00:02:03.590
of the dictionary. So, you can think of the
dictionary as what has a set of keys and each--for

00:02:03.590 --> 00:02:09.129
each key it points to some value. If I want
to look--do a look up, I would say, well instead

00:02:09.129 --> 00:02:13.400
of--just don't put it on the left hand side
of an equal. So, if I just say D of A, it

00:02:13.400 --> 00:02:19.060
just returns the value, oh alpha. Now, not
to belay with the point too much, that's the

00:02:19.060 --> 00:02:25.040
one thing that dictionaries are fast at. You
could put 10 million keys in this dictionary,

00:02:25.040 --> 00:02:29.209
and yet for a particular one, you could call
it up and it would call it up in just a few

00:02:29.209 --> 00:02:33.159
cycles on the machine. It's very, very fast
at key look up, that's the one thing that

00:02:33.159 --> 00:02:40.300
it does. So, let me show you, you know, a
few more features you could do with dictionaries.

00:02:40.300 --> 00:02:44.209
So, obviously, you can store stuff in, you
could use the square right to get stuff out.

00:02:44.209 --> 00:02:48.780
If I refer to a key that is not in there,
I say, "All right dictionary, what do you

00:02:48.780 --> 00:02:54.379
have for key value X?" What I get is actually
an error, a key error so that's a--it's a

00:02:54.379 --> 00:02:58.910
long puzzle. I think Python is trying to be
sort of consistent with the list here, that

00:02:58.910 --> 00:03:04.030
if I said list, square bracket like a thousand
and there is no thousand--you know, it would've

00:03:04.030 --> 00:03:07.010
given an error. So, I think there's sort of
an attempt to be kind of consistent with what

00:03:07.010 --> 00:03:11.230
square bracket means. And square bracket means,
yeah, it should've been there and if you refer

00:03:11.230 --> 00:03:14.861
to something that's not there, it's an error.
Fortunately, there's an alternative if you

00:03:14.861 --> 00:03:22.720
use--there's a dot get method on the dictionary.
And so, if you do dot get, in the simplest

00:03:22.720 --> 00:03:28.420
form, what it does is it returns the value
none, if it's not in there and otherwise returns

00:03:28.420 --> 00:03:35.090
the value. So, if I say dot get of A, then
I get alpha, but of X then I just get back

00:03:35.090 --> 00:03:38.580
nothing. It happens in the interpreter, none
is sort of a special case, it just prints

00:03:38.580 --> 00:03:44.130
nothing; it just comes back. So, if you want
to distinguish, you know if you want--if you

00:03:44.130 --> 00:03:47.709
care where the nothing is in there, then you
could use get and you're more protected. How

00:03:47.709 --> 00:03:55.769
do you suppose you test if a value is in a
dictionary, someone say? Something I wrote

00:03:55.769 --> 00:04:02.000
I think over there, yeah, all right. While
waiting for his in, right? Dictionary is just

00:04:02.000 --> 00:04:05.959
another composite thing just like a list.
So, I can just say A in the dictionary it's

00:04:05.959 --> 00:04:11.209
like yup, it is. Like, all right, I could
say, was x in there? No, it's not. So, can

00:04:11.209 --> 00:04:18.910
you kind of live, live a little higher on
the food chain, use those built-ins. So, I'm

00:04:18.910 --> 00:04:24.470
going to--well here, I'll show you some more
features first. So, the dictionary as itself

00:04:24.470 --> 00:04:29.040
is--it's just good at this sort of key value
storage, that's all it does. One thing that's

00:04:29.040 --> 00:04:33.603
kind of common is you open a file and you
read a bunch of data; you store it all on

00:04:33.603 --> 00:04:38.330
a dictionary to kind of organize it. And then,
once you're done with it, you want to loop

00:04:38.330 --> 00:04:43.850
over the dictionary and kind of look at all
the contents. So, the simplest way to do that

00:04:43.850 --> 00:04:51.630
is the dictionary has a method called dot
keys and what does is it returns a list of

00:04:51.630 --> 00:04:57.570
just the keys. There's also a list of--oh,
and notice the keys are in kind of random

00:04:57.570 --> 00:05:01.910
order. Now, in this case I guess they appear
to be in alphabetical order, but as the dictionary

00:05:01.910 --> 00:05:06.500
gets bigger and bigger, these will be in kind
of a random order. This is the hashing strategy

00:05:06.500 --> 00:05:11.340
that the dictionary uses causes the keys to
be in a scrambled order. I'm sure I'm probably

00:05:11.340 --> 00:05:14.490
switching between the word dictionary and
the word HashTable, so better yet those are

00:05:14.490 --> 00:05:18.000
for the same thing. And hashing is this general
strategy that's very powerful, you'll see

00:05:18.000 --> 00:05:25.720
it just crop up in a lot of languages. So,
the--likewise, there is a dot values, oops

00:05:25.720 --> 00:05:31.690
what's the problem there? I spelled it wrong.
So, this just pulls out the linear list of

00:05:31.690 --> 00:05:34.780
values. So, it's actually, it's in a kind
of a random order, but it's in the same random

00:05:34.780 --> 00:05:39.430
order that the dot keys was. So, I'm going
to show you what I would regard as kind of

00:05:39.430 --> 00:05:43.130
the most common case of looping over a dictionary.
You've built the dictionary, it's got all

00:05:43.130 --> 00:05:46.870
this, you know, social security numbers or
URLs or whatever in it and now you want to

00:05:46.870 --> 00:05:54.250
loop over and look at them. I would write
it this way, I'd say, "Well, for K in dictionary

00:05:54.250 --> 00:05:59.910
dot keys." All right, so, what that means
is go to the dictionary, pull out the linear

00:05:59.910 --> 00:06:04.910
list of keys and now, I want to loop over
that. But, it's just sort of as a nicety;

00:06:04.910 --> 00:06:09.550
the keys are going to come out in kind of
random order. So, let's loop over the sorted

00:06:09.550 --> 00:06:14.570
of that. Pull out the keys, sort them, now
loop over them and write this all on my mind,

00:06:14.570 --> 00:06:18.400
I'm going to say like, well what I could print
is--I mean, let's say I want to print a little

00:06:18.400 --> 00:06:23.681
thing with like an arrow, like this key goes
to this value. I could say print. First of

00:06:23.681 --> 00:06:29.370
all, the dictionary, square bracket K so just--that's
the--I'm sorry, don't do it (ph). I'll do

00:06:29.370 --> 00:06:37.460
it, I'll say key colon, comma K, and I'll
say comma, and I'll draw like a little arrow

00:06:37.460 --> 00:06:46.370
and I'll say dictionary square bracket K.
So, if I run that without so many errors,

00:06:46.370 --> 00:06:48.910
so that's going to pull out the keys, it's
going to loop through all the keys. And then,

00:06:48.910 --> 00:06:54.050
for each one, it's doing this little line
up like, here's what the key is and here is

00:06:54.050 --> 00:07:01.340
what--here is the value that is stored for
that key. So, that is the most--I think dot

00:07:01.340 --> 00:07:07.380
keys and dot values are the most common case.
There is this one other case which is called

00:07:07.380 --> 00:07:15.330
dot items. And what dot items does isn't--rather
than just pulling out the key or just pulling

00:07:15.330 --> 00:07:21.720
out the value, it pulls them both out simultaneously
and it puts each one in a tuple-sized two.

00:07:21.720 --> 00:07:28.140
So, what you're seeing here is a list of tuples.
Each tuple is length two and each tuple represents

00:07:28.140 --> 00:07:33.911
one--what I would call a binding from the
dictionary. And so, what you could do is you

00:07:33.911 --> 00:07:39.090
could--if you really want to just get the
key value all in one step, then you could

00:07:39.090 --> 00:07:45.560
use dot items. So, for example, I could say
for tuple in d dot items colon, you know,

00:07:45.560 --> 00:07:53.960
print the tuple or whatever. All right, check
it out, I left off the prints. So, that's

00:07:53.960 --> 00:07:58.090
another way of kind of dealing with all of
the data of the dictionary, you know, once

00:07:58.090 --> 00:08:03.690
you've built it up. You know, okay, I think
that's--I'm not going to show you the other

00:08:03.690 --> 00:08:10.950
thing, it seems messy enough. So, now I'm
going to sort of step outside for saying--I

00:08:10.950 --> 00:08:18.670
mean, what is the dictionary good for? Suppose
you've got an Apache log file of like, 20

00:08:18.670 --> 00:08:24.360
million get requests and in a sense, the Apache
log file there, it's just random right? This

00:08:24.360 --> 00:08:26.960
IP address requests something, and then this
one and that one, whatever--it's all just

00:08:26.960 --> 00:08:32.339
kind of jumbled together. A very common form
of the use of the dictionary in solving your

00:08:32.339 --> 00:08:37.501
problem is that it takes incoherent data and
it makes it coherent, it organizes it. So,

00:08:37.501 --> 00:08:42.009
for example, suppose I wanted to count how
many times each IP address had been hitting

00:08:42.009 --> 00:08:45.269
my server by looking at this log file. What
I could do is I'd say, okay, I'm going to

00:08:45.269 --> 00:08:48.910
rip through the entire file--which I'll show
you in a second--and for each IP address,

00:08:48.910 --> 00:08:53.760
I'm going to use the IP address as, let's
say, the key in the dictionary. And as the

00:08:53.760 --> 00:08:57.990
value, I'm just going to count how many times
I've seen that key. So, the first time it

00:08:57.990 --> 00:09:02.009
shows up, I'm going to put a one in there.
Maybe I could use in to kind of check if it's

00:09:02.009 --> 00:09:05.870
there or not, to kind of boot strap this like,
the first time I put it in. And then the next

00:09:05.870 --> 00:09:08.889
time I see that IP address, I could go to
the dictionary, use square bracket, I'd say,

00:09:08.889 --> 00:09:12.300
"Oh, is this in there?" If it is, I'll do,
you know, plus equals one or something to

00:09:12.300 --> 00:09:16.420
kind of like pump the value up, and so by
the end, I've gone through this unordered

00:09:16.420 --> 00:09:20.519
data and I've used the dictionary to kind
of associate by IP address. So, anything where

00:09:20.519 --> 00:09:25.070
you've got this random piece of data in one
place and you want to associate it with other

00:09:25.070 --> 00:09:29.600
occurrences of that random piece of data,
the dictionary is like, hands down the good

00:09:29.600 --> 00:09:33.439
way to do that. And it relies on this fact
that it's very fast at this one operation,

00:09:33.439 --> 00:09:38.269
which is, given any random key, it can look
up that value very, very quickly. Now, stepping

00:09:38.269 --> 00:09:45.060
even farther outside of myself, Google really
runs as a big hash table and that's basically

00:09:45.060 --> 00:09:50.430
what it is, right? It's a big hash table by
word, right? And each word, kind of, points

00:09:50.430 --> 00:09:54.519
to a list of URLs or scores, or something.
So as a user, when you type in a word--you

00:09:54.519 --> 00:10:00.019
know, whatever that, you know, Britney Spears,
that's two words, I guess. You know, really

00:10:00.019 --> 00:10:03.399
it's going to this gigantic hash table that
is Google, it's looking up Britney and like

00:10:03.399 --> 00:10:06.800
there's this big list of URLs. And it's looking
up Spears, and it does officially and then,

00:10:06.800 --> 00:10:10.050
you know, you just kind of intersect those
lists. I mean, that's Google in that show

00:10:10.050 --> 00:10:13.860
(ph). To show that's very clarifying, all
right.

00:10:13.860 --> 00:10:19.440
&gt;&gt; Where is Yahoo now?
&gt;&gt; PARLANTE: Yeah, no, Yahoo it's a linear--anyway,

00:10:19.440 --> 00:10:23.100
yes. I'm--they all have--they also have hash
table technology so that's not, that's not

00:10:23.100 --> 00:10:28.999
the problem. All right. So, predictably the
big exercise for today which I'll demo in

00:10:28.999 --> 00:10:31.700
a second. Yes, I mean, why don't you use the
dictionary that's totally appropriate thing.

00:10:31.700 --> 00:10:36.600
And in fact, dictionaries are--I mean, you
can sort of see--the subtext I was saying

00:10:36.600 --> 00:10:40.730
you--telling you is, dictionaries are an extremely
useful, and powerful construct. And so, I'm

00:10:40.730 --> 00:10:45.470
going to want you push to use them like it's
a good thing to get practiced with. All right.

00:10:45.470 --> 00:10:53.019
So let me show you the last thing which is
files. And I think--I'm going to go back to

00:10:53.019 --> 00:11:01.519
editing hello.py for this. I'm going to show
you some files stuff here. All right, so here's,

00:11:01.519 --> 00:11:09.040
hello, all right, so there's just, you know--I'm
going to--there's--In UNIX, there's this utility

00:11:09.040 --> 00:11:16.980
"cat" and what it does is it--just, you know,
prints out the concepts of a file. So, I'm

00:11:16.980 --> 00:11:21.600
just going to go ahead and kind of recreate
cat and Python just to kind of show you how

00:11:21.600 --> 00:11:25.100
to how to open files. So, let's say this thing
takes a filename--I'm going to write a function

00:11:25.100 --> 00:11:28.330
called "cat" and it takes a filename argument
and what I want it to do is just print the

00:11:28.330 --> 00:11:36.830
content to that file. So, the way to do this
is there's a built-in called "open," and it's

00:11:36.830 --> 00:11:41.350
first argument is filename and the second
argument to this is kind of resembles other

00:11:41.350 --> 00:11:45.910
languages. I can specify an "r" here to mean,
I want to open this for reading or I could

00:11:45.910 --> 00:11:49.389
specify "w" to mean, I want to open it for
writing, whatever. This case will just--we'll

00:11:49.389 --> 00:11:53.999
open this for reading. And there's actually
a variant, if you put a "ru" there, it opens

00:11:53.999 --> 00:11:58.889
it in a way where it's going to--it'll ignore
DOS line endings versus UNIX line endings

00:11:58.889 --> 00:12:03.320
or whatever. I will kind of fix that under
the hood, so that's nice. So, probably the

00:12:03.320 --> 00:12:07.899
simplest way to deal with--let's say there's
a text file--to deal with online and the files,

00:12:07.899 --> 00:12:13.439
you can actually write a for-loop over a file;
sort of like it was a list. So I can say "for

00:12:13.439 --> 00:12:20.300
line in f." So, I loop over "f" and why is
it great, what it does is it actually reads

00:12:20.300 --> 00:12:26.410
the file in line by line and just processes
one line at a time. So, if I were to say "print

00:12:26.410 --> 00:12:31.079
line"--I mean this is why--I want to just
echo the file. So, I'll just print each line,

00:12:31.079 --> 00:12:37.700
and then, here I'll just--I'll fix-up my "main"
to call this thing. So, "main" just protects

00:12:37.700 --> 00:12:41.079
whatever command line argument I have here
and it's just going to call "cat" and just

00:12:41.079 --> 00:12:53.999
say, you print this out. So, I'll--I'm here,
right? Okay, so let's see. In day one--so,

00:12:53.999 --> 00:12:59.540
I've got this file, a small.txt, I'm going
to take that up here. Okay, so if we look

00:12:59.540 --> 00:13:04.930
at what's in small.txt, this is a beautiful
poem I wrote for the class. So now if I'd

00:13:04.930 --> 00:13:13.290
say, "hello.py"" of small.txt--well, it's
to me it said, so, I open that file, it's

00:13:13.290 --> 00:13:18.709
reading it, and it's printing it but I'm getting
this kind of line doubling; I'm not improving

00:13:18.709 --> 00:13:25.741
my poem. So, the problem is this line string,
it includes the new line at the end and then,

00:13:25.741 --> 00:13:31.140
when I print it, I'm kind of putting another
new line there. So to fix this--Python obscures

00:13:31.140 --> 00:13:37.100
some text. If you put--if there's a trailing
comma at the end that inhibits that last new

00:13:37.100 --> 00:13:44.369
line. So, I'll save that. I'll just run it
again. Ah, excellent. Okay. All right, so

00:13:44.369 --> 00:13:49.040
that is one way to read a file. You open it
into this thing "f" which is kind of a file

00:13:49.040 --> 00:13:53.540
handle kind of thing, and then you just loop
over it. This technique, where you loop over

00:13:53.540 --> 00:13:59.890
line by line, it has this one virtue--sort
of going back to my apache. I could have an

00:13:59.890 --> 00:14:04.660
apache log that's like 47 gigabytes of just
texts, and this loop hole has run through

00:14:04.660 --> 00:14:09.540
it but it will not require 47 gigabytes of
RAM. This uses a tiny bit of RAM because it

00:14:09.540 --> 00:14:13.369
deals with each line independently, that's
an efficient case. So, if you can go line

00:14:13.369 --> 00:14:19.189
by line, this is an efficient way to do it.
Also, just for completeness, at the end there's

00:14:19.189 --> 00:14:23.570
a dot close--I should not, you know, close
the file, you know--just to be plain (ph).

00:14:23.570 --> 00:14:26.939
If you omit it, it closes it on when the process
exits but, you know, probably more correct

00:14:26.939 --> 00:14:34.360
it and close it. All right, so that's one
way of doing it. I'm going to make aside here,

00:14:34.360 --> 00:14:40.440
just a stylistic aside that you're going to
need badly in about 20 minutes which is--if

00:14:40.440 --> 00:14:46.889
we were in Java or C++, we would know what
variables are strings and what variables are

00:14:46.889 --> 00:14:50.899
lists because there's all these declarative
syntax telling you; what's a string, what's

00:14:50.899 --> 00:14:55.550
a list, or whatever. I want to put out--in
Python there'd be all these cues. Sort of,

00:14:55.550 --> 00:15:00.769
when you look at your own code there'd be
all these cues about what's going on. In Python,

00:15:00.769 --> 00:15:07.111
there are no cues. You just have to keep in
your head, what's a filename, what's a file,

00:15:07.111 --> 00:15:12.160
what's a string, what's a list? Now, there's
something you can do about this. The one thing

00:15:12.160 --> 00:15:16.800
you can do, the one thing you get in Python
is your variable names. And you knew, you

00:15:16.800 --> 00:15:21.649
were taught or whatever, well, you knew, oh,
yeah, having variable names is kind of a good

00:15:21.649 --> 00:15:27.379
idea. But in Python, it's 10 times more important.
So, I want to point out in my little garbagey

00:15:27.379 --> 00:15:29.470
(ph) example here. And now, what I'm typing
the stuff in the interpreter. A lot of times

00:15:29.470 --> 00:15:33.949
I use one variable names but I'm a little
more disappointed here in the editor. This

00:15:33.949 --> 00:15:38.740
thing I spelled out--yes, that's a filename
not a file, not a list string, it's a filename.

00:15:38.740 --> 00:15:43.649
It's very useful in Python that you name the
variables to kind of keep track of what is

00:15:43.649 --> 00:15:47.829
that. And very often when I'm walking around
standing behind people, many of the bugs I

00:15:47.829 --> 00:15:52.519
see is where you kinds off by one. You sort
of lost the scent. You're like, "Oh, this--you

00:15:52.519 --> 00:15:56.449
know that's the filename." "Oh, no, it turns
out that's a line from the file or it's list

00:15:56.449 --> 00:15:59.379
of all the file in there." You kind of get
this off by one. Of like, "Wait what does

00:15:59.379 --> 00:16:03.589
that variable contain?" because you've got
this natural progression of filename, to file,

00:16:03.589 --> 00:16:07.749
to line of text, to word, or whatever. It's
very easy to get off by one of where you are

00:16:07.749 --> 00:16:12.089
in that progression. And Python, the only
thing you have is the variable names. So,

00:16:12.089 --> 00:16:16.329
I've worked with a lot people, you know, debugging,
basic Python programs and I'll tell you, it

00:16:16.329 --> 00:16:21.389
is--it pays off very well to be conscious
of giving your variables good names of like

00:16:21.389 --> 00:16:25.399
what is that? Is that a string? Is that a
list? Is it a dictionary; whatever. And certainly

00:16:25.399 --> 00:16:28.519
in my solutions, whatever, you know, I fall
that, I mean, that's just good style anyway,

00:16:28.519 --> 00:16:31.613
but in Python it happens to pay off especially
well because you've got so what else is going

00:16:31.613 --> 00:16:35.329
on. All right, so on our bigger exercise today
this will, this will certainly come up. The

00:16:35.329 --> 00:16:39.069
other way that this comes up is whenever I
have a list of things. I'll try and give it

00:16:39.069 --> 00:16:44.379
a variable name ending in s words, or lines,
or something like that to sort of like cue

00:16:44.379 --> 00:16:50.110
me like, "All right, that's the lists of things."
Okay, end of editorial; it's actually good

00:16:50.110 --> 00:16:57.399
advice. So, my second favorite Python file
primitive is there's this function I think--the

00:16:57.399 --> 00:17:02.079
capitalization I remember, I think it's "readLines"
like that. I guess we just try it. And what

00:17:02.079 --> 00:17:09.510
that does, is it reads the entire file into
memory as a Python list of lines where each

00:17:09.510 --> 00:17:14.940
element of the list is one line from the file.
So, then here--so for cat, I could just say

00:17:14.940 --> 00:17:18.430
"print lines" I guess and it just be done.
All right, I'll try this to just check if

00:17:18.430 --> 00:17:22.580
I have the name right there. Has no attribute
"readLines" okay, apparently not. Maybe, it's

00:17:22.580 --> 00:17:29.690
lowercase L, it must be. Oh, excellent. All
right, so now you can see just--so now it's

00:17:29.690 --> 00:17:34.530
a Python list. So, now you could loop over
that list, do something or whatever. So, if

00:17:34.530 --> 00:17:38.681
you had a file with like, you know, 10,000
or something rather is that you want you process

00:17:38.681 --> 00:17:42.620
as a list, you know, this is a--one easy way,
you just pull it and ran in one step. Notice,

00:17:42.620 --> 00:17:47.000
if the thing is 28 gigs of data, now this
does at least 28 gigs of RAM to store like

00:17:47.000 --> 00:17:49.300
I really am just drawing the whole thing around.
But, you know, I get, I get very--you know

00:17:49.300 --> 00:17:56.020
give you an access to it. My absolute favorite--I
know you've been very curious. What is my

00:17:56.020 --> 00:18:04.910
favorite Python file primitive? Oops, and
it's just--there's this one just called "read"

00:18:04.910 --> 00:18:11.910
and what is does, is it reads the entire file
into one string. And I know that's it, but

00:18:11.910 --> 00:18:17.880
for some problems that is just so convenient.
There's no notion of like looping this line

00:18:17.880 --> 00:18:21.760
versus that line I just, like suppose you
wanted to do big, some big suture place operation

00:18:21.760 --> 00:18:26.020
on a file or say some regular expression processing.
Yeah, just having the entire thing is like

00:18:26.020 --> 00:18:32.670
one big string is phenomenally convenient.
So, that is, I think that'll just work. Yes,

00:18:32.670 --> 00:18:39.940
check it out. So, we'll build on that one
a little bit more later on. I think for today

00:18:39.940 --> 00:18:43.350
just the very--the first one I showed you.
Just for line in "f." Now, that's probably

00:18:43.350 --> 00:18:48.820
the most common one. Also going back to my
ranting editorial. By variable, noticed? When

00:18:48.820 --> 00:18:50.810
I--yes, read into variable called text like
I'm trying to remind myself like, oh, right,

00:18:50.810 --> 00:18:58.000
you know, that's the whole text, whatever.
All right. So we've got dictionaries. We've

00:18:58.000 --> 00:19:04.120
got files; these are the last two elements
that you needed to know right--there's kind

00:19:04.120 --> 00:19:06.830
of an inflection point, where like with all
the stuff I've showed you now, you can write

00:19:06.830 --> 00:19:09.790
just like real Python programs. And so that,
that's why I like, last exercise is going

00:19:09.790 --> 00:19:13.980
to look at--look like. I already gave you
the advice about variable names. One other

00:19:13.980 --> 00:19:18.160
piece of advice I should give you. I'm about
to demo some larger programs for you that

00:19:18.160 --> 00:19:26.050
I want you to implement and it is the--sometimes--or
at Stanford, right? If I'm talking some 17

00:19:26.050 --> 00:19:32.270
year old--what they will do is they'll type
in the entire program, like, well, here's

00:19:32.270 --> 00:19:36.010
my vision of how the entire program is going
to work, and then once they type in the entire

00:19:36.010 --> 00:19:39.730
thing in, then they try running it. And then
they like, you know, of course, it crashes

00:19:39.730 --> 00:19:44.820
on my client too early. That is not the way
to do it, especially not in Python. Python

00:19:44.820 --> 00:19:48.770
is so good and you make a little change and
then you can run, and you can see immediately

00:19:48.770 --> 00:19:52.380
kind of what's going on. So you want to sort
to keep that focus right at the kind of growing

00:19:52.380 --> 00:19:55.740
edge of your code. And there's two things
that are going to help you out here; let's

00:19:55.740 --> 00:19:58.370
say--so for your next problem, you're gonna
do these things that involve like reading

00:19:58.370 --> 00:20:02.440
a file, then processing lines and for each
line you're going to want to kind of do something.

00:20:02.440 --> 00:20:06.400
What you should do is to move very incrementally,
like re-read in the lines and well the first

00:20:06.400 --> 00:20:10.830
thing I just want to print each line. So you
just print each line and then after you print

00:20:10.830 --> 00:20:13.560
it and, you know, when you're done, you could
call like sys.exit or something, just like,

00:20:13.560 --> 00:20:17.110
okay we'll just bail out. And just get that
working through like, no now, it's pretty

00:20:17.110 --> 00:20:21.121
[INDISTINCT]. So it's okay, well, what's my
next goal? My next goal is, you know, I want

00:20:21.121 --> 00:20:24.360
to find all the words, so I'll just print
each word or whatever. And so just have the

00:20:24.360 --> 00:20:28.120
program print what your kind of next goal
is and keep iterating until it's printing

00:20:28.120 --> 00:20:33.280
the right thing. And Python--because Python
is very easy to edit and it's built-in printing

00:20:33.280 --> 00:20:36.530
facility is actually quiet good, right? You
can print a dictionary, you can print a list,

00:20:36.530 --> 00:20:39.810
all that stuff; there's no code in your carbon
card. It just prints, it just--it'll adopt

00:20:39.810 --> 00:20:43.231
something kind of reasonable to the console.
And so you can use that to kind of iterate

00:20:43.231 --> 00:20:47.710
very tightly and certainly as I walk around,
ask and answer questions, the same thing I'll

00:20:47.710 --> 00:20:51.730
do. So, that's why--have a goal, print what
you have, [INDISTINCT], some of it--it's kind

00:20:51.730 --> 00:20:56.110
of nice if you print what your data structure
has kind of a step in of solving this thing,

00:20:56.110 --> 00:21:00.730
seeing the pixels of like, "Oh, I have a list
of strings or whatever," can help your imagination

00:21:00.730 --> 00:21:04.180
think of like, "Okay, well, what's my next
step? Oh, now I need to make a list of, you

00:21:04.180 --> 00:21:08.570
know, a dictionary or something." So it's
so nice to be all just to see your data structure

00:21:08.570 --> 00:21:14.590
right there. And I guess more broadly, what—you
know, why is it that Python program was given

00:21:14.590 --> 00:21:17.810
this zone of like, "Wow, they're very productive,
they can just get stuff quickly." It's partially

00:21:17.810 --> 00:21:22.200
because not just that they know the Python
language but that their program in a style

00:21:22.200 --> 00:21:26.000
that fits the things Python is good at, so
this is the right stuff for today. Okay, enough

00:21:26.000 --> 00:21:32.240
kind of heavy device, let's talk about actual
work. Okay, so I'm going back down to the

00:21:32.240 --> 00:21:41.730
day 1 directory, and there are—I'm gonna
show you two programs, all right? As before,

00:21:41.730 --> 00:21:46.270
this program--so the first one I will show
you is a word count. It's the first exercise

00:21:46.270 --> 00:21:49.170
for today, this is what I want you to do today,
and I'm going to demonstrate very quickly

00:21:49.170 --> 00:21:53.090
a second exercise which you could do if you
just don't like, you wanted more practice

00:21:53.090 --> 00:21:58.521
or whatever. But word count's the one I wanted
to work on. So I'm going down to my solution

00:21:58.521 --> 00:22:03.460
directory, so I can actually demo working.
So what word count does, is if you--oops,

00:22:03.460 --> 00:22:10.600
ignore that hey there thing, that's left over
for something else--so what it does is you're

00:22:10.600 --> 00:22:17.390
given a file and what I want you to--I'll
just run it here, and I'll run it on that

00:22:17.390 --> 00:22:28.710
small file--oops, I'm sorry--it takes a command
line argument, in this case a dash, dash count,

00:22:28.710 --> 00:22:35.010
and what this does is I want you to go through
the file, I want you to find all the words,

00:22:35.010 --> 00:22:40.360
and I want you to just count and I want you
to convert them with all to lower case, so

00:22:40.360 --> 00:22:44.250
we won't count upper case, smaller case different.
I want you to just count how many times each

00:22:44.250 --> 00:22:50.380
one appears. Now to find the words, there's
this Python built-in--which I showed you before,

00:22:50.380 --> 00:22:59.180
I'll show you again--so I have like aaa bbb
ccc, there's dot split and I'll show you this

00:22:59.180 --> 00:23:04.100
dot split before I would like a corn or something.
It turns out if you call dot split with no

00:23:04.100 --> 00:23:08.960
arguments then it splits on white space, and
that's going to turn out to be a pretty reasonable

00:23:08.960 --> 00:23:14.120
behavior for this program. So for word count,
I'm just looking for split with no arguments

00:23:14.120 --> 00:23:18.610
so you just get the word and it's just automatic--it
knows what it's have is, what a new line is,

00:23:18.610 --> 00:23:21.340
it'll do something kind of original. Tomorrow
with regular expressions, we'll do a better

00:23:21.340 --> 00:23:27.930
job but for today this is [INDISTINCT]. All
right, so what I want you to do is process

00:23:27.930 --> 00:23:35.350
the whole file and like a fair with the words
are, and then you can debug on small.text,

00:23:35.350 --> 00:23:40.280
and that's sort of more fun. Then we also
just have the entire text of "Alice in Wonderland"

00:23:40.280 --> 00:23:46.110
and so you could just process that as well.
Something a little dopey is happening here

00:23:46.110 --> 00:23:51.870
well, like the word while appears 20 times,
but the word while followed by a comma appears

00:23:51.870 --> 00:23:55.171
four times. This is just because of the split
strategies just on white space and it's not

00:23:55.171 --> 00:23:59.490
smart enough to trim off anything else. Okay,
I apologize this just, this just to get us

00:23:59.490 --> 00:24:03.050
through today. Tomorrow, I will show you how
to deal with the punctuation as well, but

00:24:03.050 --> 00:24:06.170
for today, I think just deal--we've got enough
problems just with the dictionary. Well, I

00:24:06.170 --> 00:24:12.610
want you to learn the dictionary in the file.
So one thing's that's need to out this is,

00:24:12.610 --> 00:24:18.140
Python is not known for being especially fast,
it's known for being quick with your time

00:24:18.140 --> 00:24:21.560
as a programmer, it's you know, it's a great
instrument and you can get stuff done very

00:24:21.560 --> 00:24:26.240
quickly. But you know memory in anywhere else
is not that quick. That's just you know, you

00:24:26.240 --> 00:24:29.780
should know, that's one of the things you
know the truth. And yet, I just process the

00:24:29.780 --> 00:24:34.140
entire "Alice in Wonderland" and like, whatever,
if your time that says like it's about 28th

00:24:34.140 --> 00:24:38.650
of a second and this code is just written
in the most obvious convenient way--the laziest

00:24:38.650 --> 00:24:44.210
way I can think of, which is of course the
way [INDISTINCT]. So on the one hand, you

00:24:44.210 --> 00:24:47.420
know, Python is not the quickest language;
on the other hand, most things are just kind

00:24:47.420 --> 00:24:52.460
of I/O bound like probably saving that last
inter second CPU time, maybe not the best

00:24:52.460 --> 00:24:55.220
usage of your time or you just want stuff
to work so that will sort of show up here.

00:24:55.220 --> 00:25:02.750
All, right, so that is part A, counting the
words. Then—and I should mention the parsing

00:25:02.750 --> 00:25:07.260
of the command line arguments and the other
kind of boilerplate, I provide for you. So

00:25:07.260 --> 00:25:10.390
when you look in that word count file, you'll
see there's a boilerplate that's done for

00:25:10.390 --> 00:25:14.420
you and then you'd figure out what just the
part of you need to add. So then I want to

00:25:14.420 --> 00:25:20.470
have top count--oops, what's two top count
on "Alice in Wonderland?" Do you guys have

00:25:20.470 --> 00:25:27.970
a 28th of a second to spare? Sure, all right.
All right, so what does that do? Yes, it's

00:25:27.970 --> 00:25:37.640
sort of--it's by the frequency. Yes, so--what
appear most often. Now, just in terms of writing

00:25:37.640 --> 00:25:45.370
code, well, this both use a dictionary which
has the word as the key and the count as the

00:25:45.370 --> 00:25:50.870
value. I don't want to have one copy of the
code that builds that dictionary for dash,

00:25:50.870 --> 00:25:56.230
dash count and another copy of the code that
builds it for dash, dash top count. Really,

00:25:56.230 --> 00:25:59.830
you should have one copy of the code that
builds the dictionary, either by putting into

00:25:59.830 --> 00:26:04.230
a separate function or, you know, or you could
[INDISTINCT] but I want one copy of that code

00:26:04.230 --> 00:26:08.600
that builds the dictionary and then we have
these two uses of the dictionary, either you

00:26:08.600 --> 00:26:12.170
could loop to the dictionary and you just
print all the words in alphabetical order

00:26:12.170 --> 00:26:16.230
or you could go to the dictionary and so the
trick here is, it's like, "Oh, I don't want

00:26:16.230 --> 00:26:20.830
all the words, I want to pick out the words
that have the big counts and I want to print

00:26:20.830 --> 00:26:26.020
those and in sort of order by count." So for
that problem, you kind of want to use the

00:26:26.020 --> 00:26:30.880
dot items on the dictionary, where you can
pull out all those two poles and then made

00:26:30.880 --> 00:26:34.300
this some custom sorting, right where you
want to sort the two poles now at the big

00:26:34.300 --> 00:26:40.090
second number, anyway, that's part B. So the
first problem is part A. All right, I have

00:26:40.090 --> 00:26:47.840
one more thing to show you, this is whole
other program, the mimic program. And I'll

00:26:47.840 --> 00:26:52.950
just run this on "Alice in Wonderland." Let's
see what does this say? "Alice's shoulder,

00:26:52.950 --> 00:26:57.490
and birds with some minutes, the only grinned
a stop to death quote. You might do something

00:26:57.490 --> 00:27:06.140
splashing about at the Caterpillar." What
is this? Yes, you could--well, so actually

00:27:06.140 --> 00:27:09.950
you can run this--so, all right. So I'll tell
you what this program does. It's a fun program,

00:27:09.950 --> 00:27:15.020
it uses actually in terms of coding technique,
it's very similar to word count. Same level

00:27:15.020 --> 00:27:19.580
of obstruction, it just does something different.
What this program does and also it shows how

00:27:19.580 --> 00:27:25.270
Python is actually quite fast sometimes. It
looks at every word that appears on the text

00:27:25.270 --> 00:27:30.990
and for every word it just create keeps a
Python list of all the words that ever appear

00:27:30.990 --> 00:27:35.910
after it in the entire text. You can sort
of imagine building a Python dictionary that's

00:27:35.910 --> 00:27:40.080
just sort of attracts this. So for the word
sister, I have a list of all seven words that

00:27:40.080 --> 00:27:45.400
ever appeared after the word sister in the
text. So that once you have that data structure

00:27:45.400 --> 00:27:49.560
you could just pick a random words, so I'm
just going to start with Alice's, and I look

00:27:49.560 --> 00:27:53.290
at the list of the words that ever appeared
after that and I just pick one at random.

00:27:53.290 --> 00:27:57.310
So apparently in this case I got shoulder
comma and then for shoulder comma, I look

00:27:57.310 --> 00:28:02.200
at the words that ever appeared after that
and I just--it's just totally random. And

00:28:02.200 --> 00:28:05.880
yet, you can--it's sort of weird, you can
I mean it's not completely believable but

00:28:05.880 --> 00:28:10.430
it's sort of weird for one unbelievably primitive
strategy this is, I mean, you can end up mimicking

00:28:10.430 --> 00:28:15.450
some text. So you can have fun if you run
it on Google design docs. The other thing

00:28:15.450 --> 00:28:19.780
that you can do of this--only a computer sciences
can prove it is you can write it on Python

00:28:19.780 --> 00:28:25.270
text, and it sort of like it's some random
sense like my variables and comments and stuff.

00:28:25.270 --> 00:28:31.250
I mean the line breaks are completely messed
up. So, that is--so if you have time or extra

00:28:31.250 --> 00:28:33.860
energy to kill, you could take a look at the
mimic program but really what I want you to

00:28:33.860 --> 00:28:38.750
work on is the word count program. And that
is the lesson for today. So, please go ahead.

00:28:38.750 --> 00:28:41.660
Get start on that, I mean, if you want to
keep working on the list once earlier or once--I'm

00:28:41.660 --> 00:28:45.060
happy to answer questions about that. But
this is a nice kind of a threshold like, oh

00:28:45.060 --> 00:28:47.861
now, this is really all the pieces of a real
Python program you put together, so it's a

00:28:47.861 --> 00:28:49.470
nice exercise to work on.

