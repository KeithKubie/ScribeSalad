WEBVTT
Kind: captions
Language: en

00:00:05.222 --> 00:00:06.430
NICK TKACHOV: My name's Nick.

00:00:06.430 --> 00:00:09.112
I'm one of the Android
developers at RetailMeNot,

00:00:09.112 --> 00:00:10.820
and sometimes I pretend
to be a designer.

00:00:10.820 --> 00:00:12.630
This is going to be
one of those times.

00:00:12.630 --> 00:00:14.820
If you want to
follow me on Twitter,

00:00:14.820 --> 00:00:17.120
just my first initial
and then last name.

00:00:17.120 --> 00:00:17.796
Very simple.

00:00:17.796 --> 00:00:19.170
Don't try to
pronounce it though.

00:00:19.170 --> 00:00:21.490
You won't be able to.

00:00:21.490 --> 00:00:24.760
So this talk is going
to be really simple.

00:00:24.760 --> 00:00:26.510
We're going to be
talking about animation,

00:00:26.510 --> 00:00:30.510
user experience, and brains.

00:00:30.510 --> 00:00:33.890
So first, we're going to
start with a little bit

00:00:33.890 --> 00:00:36.500
of natural motion
and what that means,

00:00:36.500 --> 00:00:38.760
going to be talking about
holding user's focus,

00:00:38.760 --> 00:00:42.280
and we're talking about
framing attention.

00:00:42.280 --> 00:00:45.490
Then we'll get over to material
motion, title of this talk.

00:00:45.490 --> 00:00:49.080
And finally, we'll finish
off with some Goop.

00:00:49.080 --> 00:00:52.840
So how many of you guys went to
the other material design talk

00:00:52.840 --> 00:00:54.160
here?

00:00:54.160 --> 00:00:54.700
Great.

00:00:54.700 --> 00:00:58.630
So now you're all experts
in material design, right?

00:00:58.630 --> 00:00:59.160
Sweet.

00:00:59.160 --> 00:01:02.360
This talk is going to be
a little bit more designy,

00:01:02.360 --> 00:01:04.604
with some Android
implementation,

00:01:04.604 --> 00:01:06.770
but there's still going to
be a lot of Android stuff

00:01:06.770 --> 00:01:07.820
in this talk.

00:01:07.820 --> 00:01:10.880
So for those of you who don't
know what material design is,

00:01:10.880 --> 00:01:14.160
though, I'm going to
explain it in three cards.

00:01:14.160 --> 00:01:16.690
First thing is material
design is material.

00:01:16.690 --> 00:01:18.250
So views look as
if they're made out

00:01:18.250 --> 00:01:24.090
of something real and natural,
so a paper or plastic or gel.

00:01:24.090 --> 00:01:25.710
The views then
respond in the way

00:01:25.710 --> 00:01:27.220
that material would respond.

00:01:27.220 --> 00:01:31.620
So you don't expect a piece of
plastic to fold over on itself,

00:01:31.620 --> 00:01:36.020
so why would the view, if
it's made out of plastic,

00:01:36.020 --> 00:01:38.560
fold over on itself?

00:01:38.560 --> 00:01:40.180
And animation.

00:01:40.180 --> 00:01:42.660
Views animate in meaningful
ways and guide the user

00:01:42.660 --> 00:01:45.000
through the app.

00:01:45.000 --> 00:01:49.310
So Google gives us some nice
little guidelines on this.

00:01:49.310 --> 00:01:52.620
So for material, they give
us this nice animation,

00:01:52.620 --> 00:01:54.830
so things kind of
morph into one another.

00:01:54.830 --> 00:01:58.490
You can kind of sense what
material the view is made out

00:01:58.490 --> 00:02:01.824
of, something, by how it looks.

00:02:01.824 --> 00:02:03.490
And then you can also
kind of get a feel

00:02:03.490 --> 00:02:06.000
for how that material
behaves, based

00:02:06.000 --> 00:02:07.383
on the interaction with it.

00:02:07.383 --> 00:02:09.174
So in this case, we've
got a slip of paper,

00:02:09.174 --> 00:02:11.815
and it's getting picked up
off the page and moved around.

00:02:11.815 --> 00:02:12.690
And it feels natural.

00:02:12.690 --> 00:02:15.010
It feels like a piece
of paper should behave.

00:02:15.010 --> 00:02:17.210
And finally we have animations.

00:02:17.210 --> 00:02:19.460
And Google tells us
that animations should

00:02:19.460 --> 00:02:22.290
be meaningful and guiding.

00:02:22.290 --> 00:02:24.430
But what does that
actually mean?

00:02:24.430 --> 00:02:30.390
What does meaningful and guiding
actually entail for your app?

00:02:30.390 --> 00:02:34.410
Well, the first thing is, it's
got to respond to the user.

00:02:34.410 --> 00:02:37.150
If the user doesn't tap on a
view, then it's not meaningful.

00:02:37.150 --> 00:02:38.080
Why did it animate?

00:02:38.080 --> 00:02:42.080
Why did your animation kick
off before the user interacted

00:02:42.080 --> 00:02:43.620
with it?

00:02:43.620 --> 00:02:46.240
The second thing is, in order
to actually be meaningful,

00:02:46.240 --> 00:02:48.010
it has to guide
the user's focus.

00:02:48.010 --> 00:02:49.555
Your animation has
to have a purpose,

00:02:49.555 --> 00:02:50.930
and it has to
serve that purpose.

00:02:50.930 --> 00:02:52.513
And that purpose is
always going to be

00:02:52.513 --> 00:02:54.540
to guide the user's focus.

00:02:54.540 --> 00:02:57.500
And finally, while you're
guiding the user's focus,

00:02:57.500 --> 00:03:01.220
you're going to be creating
new context for your animation.

00:03:01.220 --> 00:03:03.822
You guide them to what
they're supposed to look at.

00:03:03.822 --> 00:03:06.280
And your users understand what
they're supposed to look at,

00:03:06.280 --> 00:03:10.210
and they get this new context
based off that animation

00:03:10.210 --> 00:03:13.350
that you played for them.

00:03:13.350 --> 00:03:15.440
So let's talk a little
bit about natural motion.

00:03:15.440 --> 00:03:19.050
So what is natural motion,
what is unnatural motion,

00:03:19.050 --> 00:03:20.800
and why do we care?

00:03:20.800 --> 00:03:24.000
Natural motion keeps
motion believable.

00:03:24.000 --> 00:03:27.400
Things animate on the
screen in a realistic way.

00:03:27.400 --> 00:03:29.490
So in order to do
that, we kind of

00:03:29.490 --> 00:03:32.310
have to calculate
where an object should

00:03:32.310 --> 00:03:35.590
be in the animation
given the time.

00:03:35.590 --> 00:03:39.690
Because time flows linearly,
but your animation might not.

00:03:39.690 --> 00:03:41.370
So we need to interpolate it.

00:03:41.370 --> 00:03:44.220
And that's what motion
interpolation is.

00:03:44.220 --> 00:03:49.700
So given a formula, we interpret
our time into a set of values

00:03:49.700 --> 00:03:52.640
that we're then going to
use to play our animation.

00:03:52.640 --> 00:03:56.010
So there's a couple of
ways to interpolate motion.

00:03:56.010 --> 00:03:59.060
And I'm going to go over
four of them real quick,

00:03:59.060 --> 00:04:01.340
to give you guys an
idea of the basics

00:04:01.340 --> 00:04:02.830
that you guys need
to know in order

00:04:02.830 --> 00:04:05.130
to make your animations
natural and believable.

00:04:05.130 --> 00:04:06.730
The first is linear animation.

00:04:06.730 --> 00:04:08.330
And quite simply,
linear animation

00:04:08.330 --> 00:04:14.340
just means that when time flows,
your objects move linearly.

00:04:14.340 --> 00:04:20.180
So as our time increases, our
object moves with that time.

00:04:20.180 --> 00:04:22.370
We also do what's
called easing in.

00:04:22.370 --> 00:04:25.650
And as our animation
moves forward,

00:04:25.650 --> 00:04:29.270
our animation will
actually accelerate.

00:04:29.270 --> 00:04:30.730
So here's an example of that.

00:04:30.730 --> 00:04:35.790
So by the time it reaches the
end, it's sped up a little bit.

00:04:35.790 --> 00:04:39.130
We also have the opposite of
that, which is our animation

00:04:39.130 --> 00:04:41.210
decelerates while it's moving.

00:04:41.210 --> 00:04:45.150
So it starts off
really fast and kind of

00:04:45.150 --> 00:04:48.090
slows down towards the end.

00:04:48.090 --> 00:04:50.600
And finally, you can
combine those two.

00:04:50.600 --> 00:04:53.810
And you can ease in
and then ease out.

00:04:53.810 --> 00:04:55.480
So your animation
starts off slowly,

00:04:55.480 --> 00:04:58.360
speeds up, and then
slows back down.

00:04:58.360 --> 00:05:03.520
So watch that blue dot,
sped up, and slows down.

00:05:03.520 --> 00:05:07.119
So why do we care about
any of these things?

00:05:07.119 --> 00:05:08.910
So in order to keep
your motion believable,

00:05:08.910 --> 00:05:11.410
you kind of have to apply these
interpolations in a way that

00:05:11.410 --> 00:05:12.670
makes them believable.

00:05:12.670 --> 00:05:14.310
So the first one is easing in.

00:05:14.310 --> 00:05:16.850
And the reason that you would
use an ease-in animation

00:05:16.850 --> 00:05:19.970
interpolator is for objects
that are leaving the space.

00:05:19.970 --> 00:05:24.170
Your object is
still on the screen,

00:05:24.170 --> 00:05:26.580
then it starts speeding
up, leaves a space,

00:05:26.580 --> 00:05:29.355
because it sped up and
it's going up the screen.

00:05:29.355 --> 00:05:30.980
And the reason that
you want to do this

00:05:30.980 --> 00:05:33.040
is because it's
actually more natural.

00:05:33.040 --> 00:05:35.550
Objects speed up as
they're leaving the space.

00:05:35.550 --> 00:05:37.876
Your user has the time to
notice that object is moving,

00:05:37.876 --> 00:05:39.750
but by the time it's
actually left the space,

00:05:39.750 --> 00:05:41.660
it's sped up fast enough
that the user knows

00:05:41.660 --> 00:05:42.510
that they shouldn't care.

00:05:42.510 --> 00:05:44.420
The user can kind of
predict that that object

00:05:44.420 --> 00:05:45.864
is going to leave the space.

00:05:45.864 --> 00:05:48.280
Similar thing for easing out,
or rather the opposite thing

00:05:48.280 --> 00:05:49.110
easing out.

00:05:49.110 --> 00:05:51.400
Your objects are
entering the space,

00:05:51.400 --> 00:05:53.740
so as your objects are
entering the space,

00:05:53.740 --> 00:05:55.020
you want them to slow down.

00:05:55.020 --> 00:05:57.400
User will have a little bit
more time to figure out where

00:05:57.400 --> 00:05:59.520
that object is going to end up.

00:05:59.520 --> 00:06:01.570
Easing both is for
when your object

00:06:01.570 --> 00:06:04.210
is moving within the space.

00:06:04.210 --> 00:06:07.665
So if your object is going to
be moving across the screen,

00:06:07.665 --> 00:06:09.790
you want to start off slow,
you want to speed it up

00:06:09.790 --> 00:06:11.500
while it's actually
in motion, and then

00:06:11.500 --> 00:06:15.200
you want to put it
where it ends up.

00:06:15.200 --> 00:06:17.620
And finally, we have linear.

00:06:17.620 --> 00:06:20.420
Don't use this.

00:06:20.420 --> 00:06:23.550
It's super unnatural,
it's super robotic.

00:06:23.550 --> 00:06:25.270
This is what
unnatural motion is.

00:06:25.270 --> 00:06:27.060
Unnatural motion
is linear motion.

00:06:27.060 --> 00:06:29.070
If you want to keep
your motion natural,

00:06:29.070 --> 00:06:31.600
use one of those
other three, depending

00:06:31.600 --> 00:06:34.240
on what your animation needs.

00:06:34.240 --> 00:06:37.840
However, I will qualify this by
saying that an object in motion

00:06:37.840 --> 00:06:40.720
stays in motion, and
that part is natural.

00:06:40.720 --> 00:06:42.890
So if your object is
flinging across the screen,

00:06:42.890 --> 00:06:45.060
flying through your
application, or in general,

00:06:45.060 --> 00:06:47.700
just coming on the screen
and then leaving immediately,

00:06:47.700 --> 00:06:48.940
go ahead and make it linear.

00:06:48.940 --> 00:06:49.441
That's fine.

00:06:49.441 --> 00:06:50.981
Your object shouldn't
be slowing down

00:06:50.981 --> 00:06:52.480
if it's not stopping
on the screen

00:06:52.480 --> 00:06:54.438
or if it didn't start
from a standing position.

00:06:56.950 --> 00:06:58.690
So how do you do
this in Android?

00:06:58.690 --> 00:07:01.680
Turns out it's
ridiculously simple.

00:07:01.680 --> 00:07:05.080
We have these things
called time interpolators,

00:07:05.080 --> 00:07:06.955
and Google has built
them all for you.

00:07:06.955 --> 00:07:09.060
You don't need to
do any of this.

00:07:09.060 --> 00:07:11.416
Ease in is just an
accelerate interpolator,

00:07:11.416 --> 00:07:12.540
because that's all it does.

00:07:12.540 --> 00:07:15.030
It just accelerates the object.

00:07:15.030 --> 00:07:17.490
Ease out, decelerate
interpolator.

00:07:17.490 --> 00:07:19.710
And then when you
want to use both,

00:07:19.710 --> 00:07:21.660
accelerate-decelerate
interpolator.

00:07:21.660 --> 00:07:23.700
Just how you would expect.

00:07:23.700 --> 00:07:25.910
And when you're animating
the view-- so how

00:07:25.910 --> 00:07:27.580
do we actually animate a view?

00:07:27.580 --> 00:07:30.270
Well, we grab the
view from our ID.

00:07:30.270 --> 00:07:32.000
We call animate on it.

00:07:32.000 --> 00:07:34.460
We do whatever
animations you want,

00:07:34.460 --> 00:07:37.320
translation X, translation
Y, translation Z, you

00:07:37.320 --> 00:07:38.420
can use that for this.

00:07:38.420 --> 00:07:40.280
And you just call
said interpolator.

00:07:40.280 --> 00:07:43.530
And just pass in a new
animation interpolator.

00:07:43.530 --> 00:07:48.910
If you want to have these static
in your app, that might work.

00:07:48.910 --> 00:07:51.631
But you just pass that in
and hit Start, and boom!

00:07:51.631 --> 00:07:52.130
That's it.

00:07:52.130 --> 00:07:53.390
Your animation plays.

00:07:53.390 --> 00:07:56.270
It's really that simple.

00:07:56.270 --> 00:07:58.300
All right.

00:07:58.300 --> 00:08:02.161
Now I want to talk to guys
a little bit about evil.

00:08:02.161 --> 00:08:06.660
I want to talk to you guys about
the square root of all evil.

00:08:06.660 --> 00:08:12.810
I want to talk you guys a little
about premature optimization.

00:08:12.810 --> 00:08:16.120
So what is premature
optimization?

00:08:16.120 --> 00:08:20.350
Premature optimization
is when you take a thing

00:08:20.350 --> 00:08:22.500
that you think is
going to be slow,

00:08:22.500 --> 00:08:24.450
but you don't know
it's already slow.

00:08:24.450 --> 00:08:26.990
You think it, and
then you go ahead

00:08:26.990 --> 00:08:30.150
and you make it fast without
ever knowing whether or not

00:08:30.150 --> 00:08:32.150
it's actually slow.

00:08:32.150 --> 00:08:35.789
So for example, if you
were to build out your app,

00:08:35.789 --> 00:08:38.831
and you had a spot in your app
that you were sitting there

00:08:38.831 --> 00:08:40.789
and you're like, hey you
know what would really

00:08:40.789 --> 00:08:42.409
make sense in this place?

00:08:42.409 --> 00:08:44.860
An enum.

00:08:44.860 --> 00:08:47.230
But Colt told me
not to use enums,

00:08:47.230 --> 00:08:51.490
so I'm going to go ahead
and make this IntDef.

00:08:51.490 --> 00:08:55.800
And so now you've
made this IntDef enum,

00:08:55.800 --> 00:08:58.450
and and your code's all
messy, and everywhere is ints,

00:08:58.450 --> 00:09:03.370
and you're using the application
processor for type checking.

00:09:03.370 --> 00:09:06.420
Well, when your intern
comes in, trust me,

00:09:06.420 --> 00:09:08.750
he's going to screw that up.

00:09:08.750 --> 00:09:12.600
And that's all because you did
some premature optimization.

00:09:12.600 --> 00:09:16.750
Oh, and by the way, while
you're all doing your enums

00:09:16.750 --> 00:09:20.280
and IntDefs, your
networking class

00:09:20.280 --> 00:09:23.370
is leaking memory-- or rather
creating thousands of objects

00:09:23.370 --> 00:09:24.560
because you're using JSON.

00:09:24.560 --> 00:09:27.600
So how you avoid
premature optimization?

00:09:27.600 --> 00:09:30.220
Well, it's actually
really simple.

00:09:30.220 --> 00:09:32.740
Fix the slowest thing first.

00:09:32.740 --> 00:09:35.370
Don't fix something
you don't know is slow.

00:09:35.370 --> 00:09:39.550
Find out what's slow in
your app, and then fix it.

00:09:39.550 --> 00:09:44.000
So with that, what's the
slowest thing your app?

00:09:44.000 --> 00:09:44.530
Call it out.

00:09:44.530 --> 00:09:46.880
What's the slowest
thing in your app?

00:09:46.880 --> 00:09:48.530
Anybody?

00:09:48.530 --> 00:09:51.150
Your apps are all super fast?

00:09:51.150 --> 00:09:52.760
All right, great.

00:09:52.760 --> 00:09:54.340
Because you're wrong.

00:09:54.340 --> 00:09:56.250
There is a slowest
thing in your app.

00:09:56.250 --> 00:09:58.620
The slowest thing
your app is your user.

00:10:02.090 --> 00:10:05.470
Your CPU operates on the
order of milliseconds.

00:10:05.470 --> 00:10:09.050
Your user takes 200
milliseconds between the time

00:10:09.050 --> 00:10:10.960
that they decide to
click on the button

00:10:10.960 --> 00:10:13.210
and the signal from their
brain goes to their finger

00:10:13.210 --> 00:10:14.610
to actually click the button.

00:10:14.610 --> 00:10:17.425
That's how slow your users are.

00:10:17.425 --> 00:10:19.950
Your user might take two
seconds to figure out

00:10:19.950 --> 00:10:22.590
they wanted to click that
button in the first place.

00:10:22.590 --> 00:10:27.274
So how do we fix this?

00:10:27.274 --> 00:10:28.768
AUDIENCE: Get rid of the users.

00:10:28.768 --> 00:10:31.247
[LAUGHTER]

00:10:31.247 --> 00:10:33.080
NICK TKACHOV: That guy's
got the right idea,

00:10:33.080 --> 00:10:35.725
but singularity is
a little bit off.

00:10:38.620 --> 00:10:41.660
Well, it's the same way that
you would fix any optimization

00:10:41.660 --> 00:10:43.460
problem in your code.

00:10:43.460 --> 00:10:45.800
Hit the fast brain code paths.

00:10:45.800 --> 00:10:47.820
What brain code paths
are actually fast?

00:10:50.390 --> 00:10:52.730
Just in general, you have a
couple things in your brain

00:10:52.730 --> 00:10:53.896
that are faster than others.

00:10:53.896 --> 00:10:55.620
The first one is
colors and shapes.

00:10:55.620 --> 00:10:58.030
Colors and shapes you
recognize really, really fast.

00:10:58.030 --> 00:11:00.000
If you've got a bunch
of colors on the screen,

00:11:00.000 --> 00:11:01.820
you can identify those
colors really fast.

00:11:01.820 --> 00:11:03.736
If you've got a bunch
of shapes on the screen,

00:11:03.736 --> 00:11:06.010
you can identify those
shapes really, really fast.

00:11:06.010 --> 00:11:10.030
If you have a bunch of text on
the screen, that's really slow.

00:11:10.030 --> 00:11:11.842
That requires a
lot of processing.

00:11:11.842 --> 00:11:13.425
The other thing is
actually groupings.

00:11:16.635 --> 00:11:18.260
As soon as that
animated on the screen,

00:11:18.260 --> 00:11:20.350
you guys saw all,
what is that, four

00:11:20.350 --> 00:11:23.560
by four of those dots, 16 dots
on the screen is one group.

00:11:23.560 --> 00:11:26.670
Great, that's super fast.

00:11:26.670 --> 00:11:29.670
If I split them apart, your
brain kind of automatically

00:11:29.670 --> 00:11:32.490
generates that there's four
groups on the screen now.

00:11:32.490 --> 00:11:35.920
Super fast, always, always
group things together.

00:11:35.920 --> 00:11:37.980
Your brain optimizes
that for you.

00:11:37.980 --> 00:11:40.820
And finally, peripheral vision.

00:11:40.820 --> 00:11:43.730
Stuff that's coming out
from the side of the screen,

00:11:43.730 --> 00:11:45.660
or not directly in
your center of vision,

00:11:45.660 --> 00:11:48.770
is going to be processed
twice as fast by your brain

00:11:48.770 --> 00:11:52.860
than stuff that's directly in
your center field of vision.

00:11:52.860 --> 00:11:55.101
And you can actually find
out a lot more of this.

00:11:55.101 --> 00:11:56.600
This is just
scratching the surface.

00:11:56.600 --> 00:11:59.530
There's an amazing talk
from Google I/O 2013 called

00:11:59.530 --> 00:12:02.542
"Cognitive Science and Design,"
and this is exactly where

00:12:02.542 --> 00:12:03.750
I'm pulling all of this from.

00:12:03.750 --> 00:12:06.330
And there's so
much on that talk.

00:12:06.330 --> 00:12:08.580
Everything the guy
goes on in that talk,

00:12:08.580 --> 00:12:11.390
like, I'm going to miss half
the stuff that he talks about,

00:12:11.390 --> 00:12:14.040
but these are the core things
that matter this presentation.

00:12:14.040 --> 00:12:15.280
So this is what I'm
going to mention,

00:12:15.280 --> 00:12:17.610
but if you guys are interested
in how your brain works,

00:12:17.610 --> 00:12:18.430
go watch that talk.

00:12:18.430 --> 00:12:19.890
It's on YouTube, it's amazing.

00:12:19.890 --> 00:12:23.434
He also talks about tigers.

00:12:23.434 --> 00:12:24.100
All right, cool.

00:12:24.100 --> 00:12:26.970
So now that we know what are
the fast pathways in our brain,

00:12:26.970 --> 00:12:29.280
how can we abuse them
in order to create

00:12:29.280 --> 00:12:32.350
animations that are going to be
more meaningful to your user?

00:12:32.350 --> 00:12:36.060
Well, we create animations
that are guiding.

00:12:36.060 --> 00:12:40.150
So we have this super awesome
animation from the Google Play

00:12:40.150 --> 00:12:41.810
Store, right?

00:12:41.810 --> 00:12:44.370
That Instagram logo just
pops right up to that top

00:12:44.370 --> 00:12:45.370
as soon as you click it.

00:12:45.370 --> 00:12:46.380
Why would you do that?

00:12:46.380 --> 00:12:49.370
Why would Google go through the
effort to make that animation?

00:12:49.370 --> 00:12:51.670
Well, it's because
that animation

00:12:51.670 --> 00:12:56.682
guides your eye right there to
that point where the arrow is.

00:12:56.682 --> 00:12:57.390
Well, guess what?

00:12:57.390 --> 00:12:59.284
That's right in line
with the install button.

00:12:59.284 --> 00:13:00.950
And because they put
that little divider

00:13:00.950 --> 00:13:03.290
line right there, your
brain groups that together.

00:13:03.290 --> 00:13:06.490
Your eye already lands exactly
were Google wants you to be,

00:13:06.490 --> 00:13:08.955
which is next to
that install button.

00:13:08.955 --> 00:13:11.080
They could actually,
probably, improve this further

00:13:11.080 --> 00:13:13.150
by moving the install button on
the other side of the screen,

00:13:13.150 --> 00:13:15.566
and then your install button
is right underneath your logo

00:13:15.566 --> 00:13:17.300
that they animated to.

00:13:17.300 --> 00:13:24.670
So that provides
context to the user.

00:13:24.670 --> 00:13:28.620
But there's something
else that we can do,

00:13:28.620 --> 00:13:30.500
and that's that motion
attracts attention.

00:13:30.500 --> 00:13:32.500
So remember what I said
about peripheral vision?

00:13:32.500 --> 00:13:34.660
Well, whenever something
moves on the screen,

00:13:34.660 --> 00:13:37.640
your brain kind of snaps do it.

00:13:37.640 --> 00:13:43.710
And that way, your user is
very similar to a T. Rex,

00:13:43.710 --> 00:13:46.552
because both of their
visions are based on motion.

00:13:46.552 --> 00:13:48.010
But there's an
alternative to this.

00:13:50.344 --> 00:13:51.760
Don't move anything
that you don't

00:13:51.760 --> 00:13:53.997
want to attract attention to.

00:13:53.997 --> 00:13:56.330
You don't want to attract the
attention of that dinosaur

00:13:56.330 --> 00:13:57.520
in the same way that you
don't want to attract

00:13:57.520 --> 00:13:58.760
the attention of that user.

00:13:58.760 --> 00:14:00.218
You don't want to
attract attention

00:14:00.218 --> 00:14:02.890
to anything that you don't want
people paying attention to.

00:14:02.890 --> 00:14:04.494
So don't move it.

00:14:04.494 --> 00:14:05.910
Don't move stuff
across the screen

00:14:05.910 --> 00:14:08.770
if it's not the core
focus of your application

00:14:08.770 --> 00:14:11.630
or of that screen.

00:14:11.630 --> 00:14:16.120
And then, also, don't move more
than one element at a time.

00:14:16.120 --> 00:14:17.750
This is really important.

00:14:17.750 --> 00:14:20.964
There should only be one thing
moving on the screen at a time.

00:14:20.964 --> 00:14:22.630
So let's take this
animation that we had

00:14:22.630 --> 00:14:24.357
in the beginning of the talk.

00:14:24.357 --> 00:14:26.690
And this is a really complicated
animation that we have,

00:14:26.690 --> 00:14:29.040
but it still follows
that principle

00:14:29.040 --> 00:14:31.070
of not moving more than
one thing at a time,

00:14:31.070 --> 00:14:33.960
even though there's a bunch
of shit moving on the screen.

00:14:33.960 --> 00:14:36.740
So first of all, notice that
those teal bubbles, they fade.

00:14:36.740 --> 00:14:39.890
They don't move,
they just fade away.

00:14:39.890 --> 00:14:43.480
That one bubble moves,
and then expands out.

00:14:43.480 --> 00:14:46.129
But then those orange blocks,
they still move one at a time.

00:14:46.129 --> 00:14:48.420
By the time one of those
orange blocks finishes moving,

00:14:48.420 --> 00:14:50.949
that's when the next one starts,
and they're also fading in.

00:14:50.949 --> 00:14:53.240
So even though we've got a
lot of motion on the screen,

00:14:53.240 --> 00:14:54.430
we're still only
moving one thing

00:14:54.430 --> 00:14:56.790
at a time, which means your
user knows what to focus on,

00:14:56.790 --> 00:14:59.000
because they're going to focus
on the thing that's moving.

00:14:59.000 --> 00:15:01.125
That's the thing that's
going to attract attention.

00:15:07.430 --> 00:15:11.500
So motion attracts
attention, more motion

00:15:11.500 --> 00:15:18.690
attracts less attention, subtle
motion attracts less attention.

00:15:18.690 --> 00:15:22.130
So if we don't want to attract
attention to the screen,

00:15:22.130 --> 00:15:24.500
but we still want to move
something on the screen,

00:15:24.500 --> 00:15:25.280
how do we do it?

00:15:25.280 --> 00:15:28.510
Well, we do it subtly.

00:15:28.510 --> 00:15:31.100
So why do we actually
need subtlety?

00:15:31.100 --> 00:15:35.310
Here we have the
Google YouTube app,

00:15:35.310 --> 00:15:39.589
and whenever you swipe
through this app,

00:15:39.589 --> 00:15:41.130
we kind of got a
lot of our attention

00:15:41.130 --> 00:15:44.550
going on in the sliding content
in the center of the screen.

00:15:44.550 --> 00:15:46.660
So that's all great, but
then we got this thing

00:15:46.660 --> 00:15:48.640
in the top corner that
keeps shifting around,

00:15:48.640 --> 00:15:50.140
that subscription to account.

00:15:50.140 --> 00:15:52.040
And your brain kind of
notices that, right?

00:15:52.040 --> 00:15:55.080
The sudden flickering, your
brain pays attention to that,

00:15:55.080 --> 00:15:57.752
and then, well, you notice that.

00:15:57.752 --> 00:15:59.460
Now in Google's case,
they might actually

00:15:59.460 --> 00:16:00.250
want you to notice that.

00:16:00.250 --> 00:16:02.350
They might want you to
know which tab you're on.

00:16:02.350 --> 00:16:03.690
But maybe for your
application, you

00:16:03.690 --> 00:16:05.340
don't want them to notice
what tab they're on, right?

00:16:05.340 --> 00:16:07.756
You just need that title up
there because some PM told you

00:16:07.756 --> 00:16:11.000
to, but you don't want them to
actually pay attention to that.

00:16:11.000 --> 00:16:13.080
Well, you could do a
lot to reduce that.

00:16:13.080 --> 00:16:15.170
The first thing that
you could do is fading.

00:16:15.170 --> 00:16:17.130
But we'll get into
in that in minute.

00:16:20.360 --> 00:16:24.952
So let's use everything that
we learned to build up our UI.

00:16:24.952 --> 00:16:27.160
First thing is, fade
unimportant elements in and out.

00:16:29.702 --> 00:16:31.660
When you look at this
animation that's playing,

00:16:31.660 --> 00:16:34.790
notice all of the other
icons on the screen.

00:16:34.790 --> 00:16:35.657
They fade out.

00:16:35.657 --> 00:16:36.490
They just fade away.

00:16:36.490 --> 00:16:37.823
They don't move they, fade away.

00:16:42.387 --> 00:16:44.220
Now how many of you
guys have seen this GIF?

00:16:51.166 --> 00:16:53.540
How many of you guys noticed
that that's a different guy?

00:16:57.530 --> 00:17:00.690
Your brain kind of has this
bit of an optimization.

00:17:00.690 --> 00:17:05.880
When we interrupt your brain
with a full bleed image,

00:17:05.880 --> 00:17:09.810
and we completely erase
your field of vision,

00:17:09.810 --> 00:17:12.460
your brain kind of
forgets what was going on.

00:17:12.460 --> 00:17:14.609
We can use this to our
advantage in a great way.

00:17:14.609 --> 00:17:17.660
So you see all those tabs
up at the top of the screen?

00:17:17.660 --> 00:17:21.119
Well, besides fading, we also
completely clear those away

00:17:21.119 --> 00:17:23.970
with that giant
circular animation .

00:17:23.970 --> 00:17:28.030
So we can use reveals to
kind of transition our app

00:17:28.030 --> 00:17:30.850
into different states that we
need to transition them to.

00:17:30.850 --> 00:17:33.440
You can use a huge reveal to
wipe away the screen, wipe away

00:17:33.440 --> 00:17:35.320
whatever the user
thought was there before,

00:17:35.320 --> 00:17:37.336
and your user won't
even notice it.

00:17:37.336 --> 00:17:39.460
Because most people aren't
going to notice the fact

00:17:39.460 --> 00:17:40.900
that the tabs aren't
there anymore,

00:17:40.900 --> 00:17:42.380
they're just going to
notice the giant Instagram

00:17:42.380 --> 00:17:43.463
logo that's moving around.

00:17:50.600 --> 00:17:55.200
Next thing, small animations
can help a little bit

00:17:55.200 --> 00:17:57.320
with transitioning your UI.

00:17:57.320 --> 00:17:59.940
So we have that little animation
at the top of the screen,

00:17:59.940 --> 00:18:01.167
that little arrow animation.

00:18:01.167 --> 00:18:02.750
How many of you guys
noticed that that

00:18:02.750 --> 00:18:04.510
was playing this whole time?

00:18:04.510 --> 00:18:06.900
Like, every single time
you play-- yeah, one guy.

00:18:06.900 --> 00:18:08.950
Just for the record,
for everybody, one guy

00:18:08.950 --> 00:18:10.610
noticed that.

00:18:10.610 --> 00:18:13.710
That animation is playing up
at the top, but it's so subtle,

00:18:13.710 --> 00:18:16.180
and it's so small, that
everything else going on

00:18:16.180 --> 00:18:18.770
on the screen completely
obliterates it.

00:18:18.770 --> 00:18:22.080
But at the end of the day,
we have a Back button there.

00:18:22.080 --> 00:18:24.460
We used to have a
hamburger Menu button,

00:18:24.460 --> 00:18:25.710
but now we have a Back button.

00:18:25.710 --> 00:18:27.990
Hey, that's a lot more
useful now, for this screen,

00:18:27.990 --> 00:18:30.400
because we don't need
a Menu button on there,

00:18:30.400 --> 00:18:32.080
we need a Back button.

00:18:32.080 --> 00:18:33.390
We can have hamburgers later.

00:18:35.930 --> 00:18:39.260
Small animations are
obscured by big ones.

00:18:39.260 --> 00:18:40.370
Cool.

00:18:40.370 --> 00:18:43.500
So let's make this stuff easy.

00:18:43.500 --> 00:18:45.820
If you learn nothing
from this talk,

00:18:45.820 --> 00:18:48.000
if you go home,
forget everything,

00:18:48.000 --> 00:18:51.160
the one thing that I want you
to remember from this talk

00:18:51.160 --> 00:18:54.950
is this one line
of code right here.

00:18:54.950 --> 00:18:57.560
Animate layout
changes equals true.

00:18:57.560 --> 00:19:00.310
This code is magic, as
far as I'm concerned.

00:19:00.310 --> 00:19:03.650
Google has literally taken
99% of the animation work

00:19:03.650 --> 00:19:06.900
and done it for you
with this one line.

00:19:06.900 --> 00:19:08.960
What does this one
line look like?

00:19:08.960 --> 00:19:10.780
That.

00:19:10.780 --> 00:19:13.270
That entire animation
that's playing right now

00:19:13.270 --> 00:19:17.590
is done by one line-- well,
one line and then setting stuff

00:19:17.590 --> 00:19:19.240
to be visible and invisible.

00:19:19.240 --> 00:19:22.670
So whenever anything changes
inside of your app, when

00:19:22.670 --> 00:19:24.910
anything changes
inside of your layouts,

00:19:24.910 --> 00:19:27.350
if you have animations
layout, animate layout changes

00:19:27.350 --> 00:19:30.980
equals true, on, your entire
app will animate on its own.

00:19:30.980 --> 00:19:33.110
That transition will
happen, the layout

00:19:33.110 --> 00:19:35.280
will figure out what to
move around, what to do,

00:19:35.280 --> 00:19:37.290
and how to move it in
order for everything

00:19:37.290 --> 00:19:38.650
to fit on the screen.

00:19:38.650 --> 00:19:41.400
In the case of linear
layout, this actually

00:19:41.400 --> 00:19:43.010
works phenomenally well.

00:19:43.010 --> 00:19:44.400
Use this everywhere.

00:19:44.400 --> 00:19:47.470
If you just need an
animation that plays,

00:19:47.470 --> 00:19:48.560
slot that line in there.

00:19:48.560 --> 00:19:50.469
Boom, you're done.

00:19:50.469 --> 00:19:52.760
Now, what if you want to do
something a little bit more

00:19:52.760 --> 00:19:54.170
complicated?

00:19:54.170 --> 00:19:56.790
Well, you can start
doing some manual stuff.

00:19:56.790 --> 00:19:58.760
So let's talk a little
bit about fading.

00:19:58.760 --> 00:20:00.450
You can animate
the object alpha,

00:20:00.450 --> 00:20:02.580
and this is actually
really easy.

00:20:02.580 --> 00:20:04.600
You just take the view,
dot animate alpha.

00:20:04.600 --> 00:20:10.350
If it's visible, you
want to set it to one,

00:20:10.350 --> 00:20:13.730
and then if it's invisible,
you want to set it to zero.

00:20:13.730 --> 00:20:17.820
Oh, and don't forget
the interpolator.

00:20:17.820 --> 00:20:19.570
Because you want this
to still be natural.

00:20:19.570 --> 00:20:21.800
Even though we're
animating colors here,

00:20:21.800 --> 00:20:24.580
we can still animate
them naturally.

00:20:24.580 --> 00:20:28.130
Linear fades still look worse
than interpolator fades.

00:20:28.130 --> 00:20:31.630
So how does this look?

00:20:31.630 --> 00:20:36.170
Here's a button,
fade in and out.

00:20:36.170 --> 00:20:39.690
Again, one line of code.

00:20:39.690 --> 00:20:41.260
Color changing,
let's say you wanted

00:20:41.260 --> 00:20:44.080
to change colors in your app.

00:20:44.080 --> 00:20:48.010
Say, a button needs to go
from, say, gray to blue.

00:20:48.010 --> 00:20:51.300
Say, for example, if you're
enabling that button,

00:20:51.300 --> 00:20:54.990
it turns out we have this great
thing called object animator.

00:20:54.990 --> 00:20:57.050
And we can call
object animator dot

00:20:57.050 --> 00:21:04.000
of RGB, we give it a bitmap,
or in our case a drawable,

00:21:04.000 --> 00:21:07.700
and we tell it what
property to animate.

00:21:07.700 --> 00:21:10.220
In this case, we're
animating the tent.

00:21:10.220 --> 00:21:14.020
And then we give it our
current color, the fade color,

00:21:14.020 --> 00:21:18.520
set the interpolator, and then
we hit Start, and that's it.

00:21:18.520 --> 00:21:20.050
There is one caveat to this.

00:21:20.050 --> 00:21:23.170
This is API 21, but
that's not a big deal

00:21:23.170 --> 00:21:25.720
you can do the exact same
thing in API 16 and above.

00:21:25.720 --> 00:21:29.440
All you have to do is
instead of saying of ARGB,

00:21:29.440 --> 00:21:32.340
you just got to give it
a new ARGB evaluator.

00:21:32.340 --> 00:21:35.880
So that's just, API 21 just has
some syntactic sugar for that.

00:21:39.780 --> 00:21:42.950
Oh, also, perf matters.

00:21:42.950 --> 00:21:44.680
Don't use set
background color, use

00:21:44.680 --> 00:21:46.060
tint if you're actually
trying to set the background

00:21:46.060 --> 00:21:47.040
color with this.

00:21:47.040 --> 00:21:49.540
Tint animates on the GPU,
so that's a GPU animation.

00:21:49.540 --> 00:21:51.860
Set background color is
going to reset and invalidate

00:21:51.860 --> 00:21:54.147
your drawable.

00:21:54.147 --> 00:21:55.980
So that's going to be
a lot slower than just

00:21:55.980 --> 00:21:56.830
setting the tent.

00:21:56.830 --> 00:21:59.530
And if you're
animating, that matters.

00:21:59.530 --> 00:22:03.190
You want your animations
to play at 60 FPS.

00:22:03.190 --> 00:22:05.355
So here's what that looks like.

00:22:05.355 --> 00:22:06.730
We have that
button, we click it,

00:22:06.730 --> 00:22:08.790
changes color, everything
goes back to normal.

00:22:08.790 --> 00:22:10.660
Great.

00:22:10.660 --> 00:22:12.250
Animated vector drawables.

00:22:12.250 --> 00:22:16.080
All right, bear with me here.

00:22:16.080 --> 00:22:22.580
These are complicated,
but they look fantastic.

00:22:25.270 --> 00:22:28.604
Also, they're API 21, you
guys can go bug Colt and Chet

00:22:28.604 --> 00:22:30.770
and ask them when they're
finally going to drop this

00:22:30.770 --> 00:22:33.550
into the Support Library.

00:22:33.550 --> 00:22:35.350
How do you do an
animated vector drawable?

00:22:35.350 --> 00:22:36.766
First thing that
you have to do is

00:22:36.766 --> 00:22:38.410
you have to declare
a vector drawable.

00:22:38.410 --> 00:22:40.095
You give it your height,
your width, same way

00:22:40.095 --> 00:22:41.560
that you would any
vector drawable,

00:22:41.560 --> 00:22:43.270
but then you also have to
define your viewport width

00:22:43.270 --> 00:22:44.270
and your viewport height.

00:22:44.270 --> 00:22:46.061
That's actually going
to depend on the data

00:22:46.061 --> 00:22:48.310
that you're going to pass
into this vector drawable.

00:22:48.310 --> 00:22:50.680
So in our case, this vector
is going to have a path.

00:22:50.680 --> 00:22:51.760
And that path is
just going to have

00:22:51.760 --> 00:22:53.340
one-- it's going
to have its name,

00:22:53.340 --> 00:22:54.530
it's going to have
its fill color,

00:22:54.530 --> 00:22:56.071
and it's going to
have its path data.

00:22:56.071 --> 00:22:57.754
In this case, it's
string slash circle.

00:22:57.754 --> 00:22:58.920
What is string slash circle?

00:22:58.920 --> 00:23:02.104
String slash circle is
this giant SVG file.

00:23:02.104 --> 00:23:04.020
Well, in our case, it's
not actually very big,

00:23:04.020 --> 00:23:06.770
but you can get
these pretty large.

00:23:06.770 --> 00:23:10.130
So in our case, it's
just an SVG file.

00:23:10.130 --> 00:23:11.610
So yep, there it is.

00:23:11.610 --> 00:23:14.910
There's that circle.

00:23:14.910 --> 00:23:19.300
And again, the viewport
width depends on that string,

00:23:19.300 --> 00:23:21.440
so you've got to
ask your designers,

00:23:21.440 --> 00:23:23.700
if you have any, what
the viewport height is

00:23:23.700 --> 00:23:26.520
and what the basis
of all the numbers

00:23:26.520 --> 00:23:28.850
are, because it's all relative.

00:23:28.850 --> 00:23:30.740
So then we define
the animated vector.

00:23:30.740 --> 00:23:32.420
We've got our
vector drawable, we

00:23:32.420 --> 00:23:33.710
can define it as an animation.

00:23:33.710 --> 00:23:38.290
We tell Android which drawable
to use, use my vector.

00:23:38.290 --> 00:23:41.630
We tell it what the
path it's animating

00:23:41.630 --> 00:23:44.820
is called, well in this
case, it's compression.

00:23:44.820 --> 00:23:47.930
And then we tell it the actual
animation, which is path morph.

00:23:47.930 --> 00:23:48.930
What its path morph?

00:23:48.930 --> 00:23:50.560
Path morph is here.

00:23:50.560 --> 00:23:53.010
So this is just a
standard animation set.

00:23:53.010 --> 00:23:57.920
We've given object animator, we
pass in the value from and to.

00:23:57.920 --> 00:24:01.870
So in our case the to value
is string slash compressed,

00:24:01.870 --> 00:24:04.441
and then in this
specific example,

00:24:04.441 --> 00:24:05.940
we actually go
backwards after that.

00:24:05.940 --> 00:24:09.960
So you pass in the duration,
and what this will actually do

00:24:09.960 --> 00:24:13.150
is it'll play those two
animators sequentially.

00:24:13.150 --> 00:24:16.460
And that's because we set
the order to be sequential.

00:24:16.460 --> 00:24:19.462
And then we also set
the interpolator,

00:24:19.462 --> 00:24:21.295
in this case it's a
decelerate interpolator.

00:24:26.440 --> 00:24:27.830
That goes to that.

00:24:27.830 --> 00:24:30.750
What do vector
drawables look like?

00:24:30.750 --> 00:24:33.340
Well, remember that animation
that we had earlier,

00:24:33.340 --> 00:24:35.280
with the Back button?

00:24:35.280 --> 00:24:38.320
That is actually an
animated vector drawable.

00:24:38.320 --> 00:24:40.050
So they have three lines there.

00:24:40.050 --> 00:24:42.709
And in one case they have three
lines in a certain information,

00:24:42.709 --> 00:24:44.500
and then they have
another vector drawable,

00:24:44.500 --> 00:24:46.030
with the three lines in
a different formation,

00:24:46.030 --> 00:24:47.440
and that formation
is a back arrow.

00:24:47.440 --> 00:24:49.815
And then all they do is they
interpolate between the two.

00:24:49.815 --> 00:24:52.210
Google handles all that for
you, all the complicated SVG

00:24:52.210 --> 00:24:54.126
transformation logic,
that's all done for you,

00:24:54.126 --> 00:24:55.330
you don't to worry about it.

00:24:55.330 --> 00:24:57.690
You just create your
animated vector drawable.

00:24:57.690 --> 00:24:59.610
And then the example
that I actually rolled,

00:24:59.610 --> 00:25:00.985
well that's what
that looks like.

00:25:00.985 --> 00:25:01.870
It's just a circle.

00:25:01.870 --> 00:25:03.286
It kind of gets
squeezed together,

00:25:03.286 --> 00:25:04.930
or rather it's
stretched out, and then

00:25:04.930 --> 00:25:06.138
it goes back to where it was.

00:25:10.540 --> 00:25:12.440
So we've talked a
lot about motion,

00:25:12.440 --> 00:25:15.220
we've talked a lot
about animations,

00:25:15.220 --> 00:25:18.550
let's put everything that
we've learned together.

00:25:18.550 --> 00:25:21.410
So we've got our natural
movement-- accelerators,

00:25:21.410 --> 00:25:24.366
decelerators,
interpolaters-- bleeders

00:25:24.366 --> 00:25:26.240
and then we figured out
how to use that guide

00:25:26.240 --> 00:25:27.120
to guide our users.

00:25:30.360 --> 00:25:33.080
If we combine those two
together, what you actually

00:25:33.080 --> 00:25:36.640
end up with is fluid motion.

00:25:36.640 --> 00:25:40.810
So what is actually
fluid motion?

00:25:40.810 --> 00:25:43.110
Well, fluid motion
is when elements

00:25:43.110 --> 00:25:45.530
appear from other
elements, and then they

00:25:45.530 --> 00:25:47.420
disappear into other elements.

00:25:47.420 --> 00:25:51.570
So things don't just spawn onto
the screen willy-nilly, that's

00:25:51.570 --> 00:25:54.700
why we're animating
these things.

00:25:54.700 --> 00:25:58.940
The motion is natural,
and the motion is subtle.

00:25:58.940 --> 00:26:00.500
So when things
[AUDIO OUT] elements,

00:26:00.500 --> 00:26:02.350
we might want the
user notice that.

00:26:02.350 --> 00:26:04.671
When they despawn, user
probably doesn't care.

00:26:04.671 --> 00:26:06.170
We're going to be
subtle about that.

00:26:06.170 --> 00:26:07.110
We're going to go
ahead, and we're

00:26:07.110 --> 00:26:09.580
going to combine everything
we've learned into this one

00:26:09.580 --> 00:26:12.490
giant heap, in order to
create the animation that we

00:26:12.490 --> 00:26:18.360
need in order to guide our
users focus in a fluid manner.

00:26:18.360 --> 00:26:22.110
Here's an example from
my app, RetailMeNot.

00:26:22.110 --> 00:26:26.800
So we have this navigation
toolbar, This home row,

00:26:26.800 --> 00:26:29.050
and in some parts of the
app, we don't actually

00:26:29.050 --> 00:26:30.770
always need this.

00:26:30.770 --> 00:26:33.140
So how do we get
rid of this home row

00:26:33.140 --> 00:26:35.300
without throwing the user off?

00:26:35.300 --> 00:26:37.580
Because this is our
core central navigation

00:26:37.580 --> 00:26:40.300
feature, and we want to
hide it in some places.

00:26:40.300 --> 00:26:42.220
How do we do that?

00:26:42.220 --> 00:26:44.110
Well, we do that like this.

00:26:44.110 --> 00:26:47.430
We fade away the background,
and the colors end up on white,

00:26:47.430 --> 00:26:50.830
and then we just
swipe way the colors.

00:26:50.830 --> 00:26:53.474
Turns out, people don't
notice that animation.

00:26:53.474 --> 00:26:55.140
Whenever we need to
play this animation,

00:26:55.140 --> 00:26:57.056
we need to play it because
we're transitioning

00:26:57.056 --> 00:26:59.520
to a screen that doesn't need
that home row navigation.

00:26:59.520 --> 00:27:02.510
Well, because we're being subtle
about this, because it's fast,

00:27:02.510 --> 00:27:04.520
and because it's fluid,
people don't actually

00:27:04.520 --> 00:27:06.020
notice that this
animation plays,

00:27:06.020 --> 00:27:08.800
and that this
entire row is gone.

00:27:08.800 --> 00:27:10.700
So it actually ends up
being really awesome,

00:27:10.700 --> 00:27:15.840
and we can transition from
just the toolbar to the toolbar

00:27:15.840 --> 00:27:19.290
with secondary navigation.

00:27:19.290 --> 00:27:21.580
But we can make this better.

00:27:21.580 --> 00:27:24.560
Quite frankly, we'd like to
have that animation play,

00:27:24.560 --> 00:27:26.710
and then we'd like to be
able to tell the user when

00:27:26.710 --> 00:27:27.670
the animation is back.

00:27:27.670 --> 00:27:29.253
When those buttons
come back, we don't

00:27:29.253 --> 00:27:30.620
want it to be that subtle.

00:27:30.620 --> 00:27:34.290
That's not necessarily
the right way to go.

00:27:34.290 --> 00:27:36.300
The way that we can
do that-- or, sorry.

00:27:36.300 --> 00:27:39.170
Actually, I forgot
to mention something.

00:27:39.170 --> 00:27:42.270
Or rather, I talked
about it already.

00:27:42.270 --> 00:27:44.710
The reason that we
want to do this we

00:27:44.710 --> 00:27:47.110
establish the hierarchy
between elements.

00:27:47.110 --> 00:27:49.060
Clearly, that
toolbar right there

00:27:49.060 --> 00:27:53.010
is much more important than
the secondary navigation

00:27:53.010 --> 00:27:54.070
in this case.

00:27:54.070 --> 00:27:56.810
So we establish that
that toolbar is on top,

00:27:56.810 --> 00:27:59.330
it's more important, and is
always going to be there.

00:27:59.330 --> 00:28:01.300
The secondary navigation
slides in and out,

00:28:01.300 --> 00:28:03.020
depending on whether
or not we need it.

00:28:03.020 --> 00:28:04.870
So clearly, it's
not as important.

00:28:04.870 --> 00:28:07.030
Tabs are secondary.

00:28:07.030 --> 00:28:11.070
But then we also build and
change scenes seamlessly,

00:28:11.070 --> 00:28:14.602
so we hide elements that
we don't need at the moment

00:28:14.602 --> 00:28:15.185
unobtrusively.

00:28:19.230 --> 00:28:21.500
Now then, going back to
what we were talking about.

00:28:21.500 --> 00:28:23.210
Let's say that we wanted to
have the user pay a little bit

00:28:23.210 --> 00:28:24.650
more attention to
the actual animation

00:28:24.650 --> 00:28:25.700
when it comes back in.

00:28:25.700 --> 00:28:26.570
How can we do that?

00:28:26.570 --> 00:28:29.350
Well, the way that we do
that is by blending colors.

00:28:29.350 --> 00:28:31.830
Again, this is one of the
fast pathways in your brain.

00:28:31.830 --> 00:28:34.038
This is going to be really
fast for a user to notice,

00:28:34.038 --> 00:28:35.340
users are going to notice this.

00:28:35.340 --> 00:28:37.446
So let's say we come in,
and we have this toolbar,

00:28:37.446 --> 00:28:39.570
and we want to bring back
those navigation buttons.

00:28:39.570 --> 00:28:42.020
How can we do that in a
much more seamless way?

00:28:42.020 --> 00:28:42.640
There we go.

00:28:42.640 --> 00:28:44.370
We can blend the
colors together.

00:28:44.370 --> 00:28:46.670
So we're using that circular
reveal to kind of come

00:28:46.670 --> 00:28:50.270
from that top level toolbar, and
then we're going to animate in,

00:28:50.270 --> 00:28:52.150
and we're going to
animate in all those tabs.

00:28:52.150 --> 00:28:55.270
And this tells the user,
again, those tabs are back.

00:28:55.270 --> 00:28:56.949
First of all, it makes
them notice that,

00:28:56.949 --> 00:28:59.490
and the second thing is it tells
the user that those tabs are

00:28:59.490 --> 00:29:01.270
related to that navigation bar.

00:29:01.270 --> 00:29:03.450
So even if we have other
stuff on the screen that's

00:29:03.450 --> 00:29:05.420
going to be purple,
the user is still

00:29:05.420 --> 00:29:07.710
going to notice those
toolbar come back in.

00:29:12.050 --> 00:29:13.600
Brain perf.

00:29:13.600 --> 00:29:14.610
Group stuff by colors.

00:29:21.460 --> 00:29:24.190
We kind of had this
weird animation

00:29:24.190 --> 00:29:29.340
in the beginning of our
talk, so this thing,

00:29:29.340 --> 00:29:31.599
and it's kind of
interesting, right?

00:29:31.599 --> 00:29:32.890
So what is this actually doing?

00:29:32.890 --> 00:29:35.170
Well, this is blending
shapes together.

00:29:35.170 --> 00:29:36.890
So outside of
blending colors, which

00:29:36.890 --> 00:29:38.800
is one of the past
pathways in your brain,

00:29:38.800 --> 00:29:40.940
you can also blend shapes,
another fast pathway

00:29:40.940 --> 00:29:41.662
in your brain.

00:29:41.662 --> 00:29:43.870
Turns out, your brain actually
does this really fast,

00:29:43.870 --> 00:29:46.350
and it kind of understands this.

00:29:46.350 --> 00:29:48.114
But this is kind
of a weird example.

00:29:48.114 --> 00:29:49.530
I don't know if
you guys remember,

00:29:49.530 --> 00:29:51.363
but this was one of the
examples that I used

00:29:51.363 --> 00:29:53.510
to define what material is.

00:29:53.510 --> 00:29:57.530
But what material actually
behaves like that?

00:29:57.530 --> 00:29:59.720
Plastic?

00:29:59.720 --> 00:30:00.860
Not really.

00:30:00.860 --> 00:30:03.920
Well, it actually turns
out that this material

00:30:03.920 --> 00:30:07.470
behaves similar to what you
would find in a lava lam, that

00:30:07.470 --> 00:30:09.410
is to say, something gooey.

00:30:14.370 --> 00:30:18.660
So with that, if we
take that gooeyness,

00:30:18.660 --> 00:30:23.090
we can literally
create fluid motion.

00:30:23.090 --> 00:30:28.290
So don't just have fluid motion
in your app, be fluid motion.

00:30:28.290 --> 00:30:32.460
Have your views animate
as if they were a fluid.

00:30:32.460 --> 00:30:34.190
Make your views gooey.

00:30:37.750 --> 00:30:41.420
So what is gooey, what
does that even mean?

00:30:41.420 --> 00:30:44.300
Well, you simulate your views
as if they were a high viscosity

00:30:44.300 --> 00:30:48.040
fluid, so something that doesn't
necessarily flow like water,

00:30:48.040 --> 00:30:51.550
maybe something
more like molasses.

00:30:51.550 --> 00:30:54.040
Your views look solid
when they're stationary,

00:30:54.040 --> 00:30:57.060
so your views seem as if
they were actual buttons

00:30:57.060 --> 00:31:00.186
or whatever the user needs
for that specific case.

00:31:00.186 --> 00:31:01.810
But they move is if
they were a liquid,

00:31:01.810 --> 00:31:04.750
so that they can transform
into each other, they can move,

00:31:04.750 --> 00:31:06.950
they can flow through your app.

00:31:09.650 --> 00:31:14.530
And before we go on, I want to
show you guys this animation

00:31:14.530 --> 00:31:17.415
by Jakub Antalik,
and I apologize

00:31:17.415 --> 00:31:18.620
if I pronounced that wrong.

00:31:21.230 --> 00:31:23.730
He posted this on his Twitter,
and this animation kind

00:31:23.730 --> 00:31:30.740
of exemplifies everything that
I'm talking about in this talk.

00:31:30.740 --> 00:31:33.060
This is kind of the inspiration
for this entire talk,

00:31:33.060 --> 00:31:37.145
and sort of everything that I've
been doing for the past month.

00:31:37.145 --> 00:31:38.520
So I just want
you to watch this.

00:31:43.340 --> 00:31:48.750
Everything flows seamlessly
from one scene to the next.

00:31:48.750 --> 00:31:50.970
More importantly,
everything here

00:31:50.970 --> 00:31:52.730
is providing the
user with the context

00:31:52.730 --> 00:31:54.900
of what they're actually
doing within the scene.

00:31:54.900 --> 00:31:57.880
Buttons transform, you
understand what you're doing.

00:31:57.880 --> 00:32:00.710
That blue button
transformed into a selector,

00:32:00.710 --> 00:32:03.289
that selector transforms
into an OK button.

00:32:03.289 --> 00:32:05.330
You know exactly what
you're doing on the screen,

00:32:05.330 --> 00:32:07.038
you know exactly the
order of operations,

00:32:07.038 --> 00:32:08.800
you know exactly
what's happening,

00:32:08.800 --> 00:32:11.990
because all of these views are
morphing from one to another.

00:32:11.990 --> 00:32:13.800
It sequentially
follows that views

00:32:13.800 --> 00:32:17.060
that morph from one to
another relate to each other.

00:32:19.810 --> 00:32:25.330
So let's talk a little
bit more about goop.

00:32:25.330 --> 00:32:28.140
Goop easily changes
shape, which means

00:32:28.140 --> 00:32:30.370
that you can take something
like a square button,

00:32:30.370 --> 00:32:33.226
animate it into a circle,
and it changes that shape,

00:32:33.226 --> 00:32:34.100
and it goes smoothly.

00:32:36.780 --> 00:32:38.500
And it's natural.

00:32:38.500 --> 00:32:40.810
If your views behave
as if they were gooey,

00:32:40.810 --> 00:32:44.040
it's a natural animation.

00:32:44.040 --> 00:32:48.660
Views also can easily create
other elements from each other.

00:32:48.660 --> 00:32:51.620
So as you're moving along, if
you need to spawn more views,

00:32:51.620 --> 00:32:53.580
you can spawn more
views from one another,

00:32:53.580 --> 00:32:55.320
and it's naturally
understood by the user

00:32:55.320 --> 00:32:57.370
that those views
relate to each other.

00:32:57.370 --> 00:33:00.120
You wouldn't put three
separate buttons on the screen

00:33:00.120 --> 00:33:01.750
that animate in
that format and then

00:33:01.750 --> 00:33:03.380
not have them relate
to each other.

00:33:03.380 --> 00:33:04.760
They should all be meaningful.

00:33:04.760 --> 00:33:07.550
So if you have, for
example, three menu options,

00:33:07.550 --> 00:33:10.130
you animate them
from one menu button,

00:33:10.130 --> 00:33:12.120
and you get three
different buttons

00:33:12.120 --> 00:33:13.370
that all relate to each other.

00:33:13.370 --> 00:33:15.880
And the user intuitively
knows that those things

00:33:15.880 --> 00:33:18.230
relate to each other,
because, again, that

00:33:18.230 --> 00:33:20.119
happens faster in your
brain than if they

00:33:20.119 --> 00:33:22.410
were to scan each and every
single one of those buttons

00:33:22.410 --> 00:33:24.576
and decide whether or not
they relate to each other.

00:33:27.300 --> 00:33:30.130
So relate elements
to one another using

00:33:30.130 --> 00:33:32.060
this sort of gooey animation.

00:33:32.060 --> 00:33:34.160
So how do you actually
do this in Android?

00:33:34.160 --> 00:33:35.800
This is not a trivial task.

00:33:35.800 --> 00:33:38.335
We're getting into this
really interesting part

00:33:38.335 --> 00:33:40.460
of Android that hasn't been
done for you by Google.

00:33:40.460 --> 00:33:43.060
Everything that I've
talked about to this point

00:33:43.060 --> 00:33:44.900
has already been done for you.

00:33:44.900 --> 00:33:47.400
Well, we can kind of
categorize this goop

00:33:47.400 --> 00:33:51.150
into several
different situations.

00:33:51.150 --> 00:33:52.910
And the first one is
simple simulations,

00:33:52.910 --> 00:33:56.145
so something that's not
too hard to kind of fake.

00:33:56.145 --> 00:33:58.520
And the way that you can do
this is with vector drawables

00:33:58.520 --> 00:34:00.627
and canvas animations.

00:34:00.627 --> 00:34:02.960
And we'll talk a little bit
more about canvas animations

00:34:02.960 --> 00:34:03.580
in a second.

00:34:03.580 --> 00:34:06.464
If you have something a little
bit more medium complexity,

00:34:06.464 --> 00:34:08.380
then you might want to
have an animation list.

00:34:08.380 --> 00:34:10.239
So if you have views
that kind of transition

00:34:10.239 --> 00:34:14.000
between each other, or if
that animation is reversible--

00:34:14.000 --> 00:34:15.960
so you can play it
forwards and backwards--

00:34:15.960 --> 00:34:20.199
you can use an animation
list to animate that.

00:34:20.199 --> 00:34:23.009
But that's a little bit
more costly for you,

00:34:23.009 --> 00:34:24.550
because you need a
designer for that,

00:34:24.550 --> 00:34:26.400
but we'll talk about that later.

00:34:26.400 --> 00:34:28.010
And then we have
our hyper complex,

00:34:28.010 --> 00:34:33.040
stuff that we can't do
this in any other way,

00:34:33.040 --> 00:34:37.219
and for that we actually
need true fluid simulation.

00:34:37.219 --> 00:34:42.939
So let's talk about
the simple stuff first.

00:34:42.939 --> 00:34:45.480
So if we have a static animation
that's always going to play,

00:34:45.480 --> 00:34:48.090
and it's always going to
be the same animation,

00:34:48.090 --> 00:34:49.980
then we can just use
a vector drawable.

00:34:49.980 --> 00:34:52.629
We define our goop
in a vector, we

00:34:52.629 --> 00:34:54.670
can animate between those
vectors in the same way

00:34:54.670 --> 00:34:57.804
that we had before, and then
we can continue onwards.

00:34:57.804 --> 00:34:59.220
If we want something
more dynamic,

00:34:59.220 --> 00:35:01.428
though, we're going to have
to use canvas animations.

00:35:04.590 --> 00:35:05.620
Good job, magic move.

00:35:08.750 --> 00:35:12.630
Because of course I meant the
animations from the other one.

00:35:12.630 --> 00:35:15.690
So canvas animations
are when you actually

00:35:15.690 --> 00:35:17.930
override your views,
override your drawables,

00:35:17.930 --> 00:35:23.000
and you create your own paths,
and you animate your own paths.

00:35:23.000 --> 00:35:26.320
So this is actually
making and drawing views

00:35:26.320 --> 00:35:27.470
and then validating them.

00:35:27.470 --> 00:35:30.255
This isn't as performant, but it
still works on high-end phones.

00:35:30.255 --> 00:35:31.630
But then again,
we're not exactly

00:35:31.630 --> 00:35:33.950
trying to match this stuff
to really low-end phones.

00:35:33.950 --> 00:35:37.030
This is some hardcore
animations here,

00:35:37.030 --> 00:35:40.350
so it's not going to
run on a low-end phone.

00:35:40.350 --> 00:35:43.605
So we have this canvas,
and we drew this path.

00:35:43.605 --> 00:35:48.050
This is what this path looks
like, simple triangle, right?

00:35:48.050 --> 00:35:50.700
But if we wanted to
make that triangle look

00:35:50.700 --> 00:35:52.950
and behave a little
bit more gooey,

00:35:52.950 --> 00:35:54.474
we can add a CornerRadius.

00:35:54.474 --> 00:35:56.390
And that's what this
corner radius looks like.

00:35:56.390 --> 00:35:58.520
So here we just kind of iterate
through all these values,

00:35:58.520 --> 00:36:00.830
and I show you what the
corner radius kind of looks

00:36:00.830 --> 00:36:02.000
like when you apply it.

00:36:02.000 --> 00:36:03.960
So at some point in time,
the CornerRadius just

00:36:03.960 --> 00:36:06.840
goes way overboard, and it
doesn't do anything anymore.

00:36:06.840 --> 00:36:09.310
But at that point we can
actually start to use it,

00:36:09.310 --> 00:36:11.960
and it kind of starts
looking a little bit gooey.

00:36:14.570 --> 00:36:19.440
So we can kind of use these
canvas animations to animate

00:36:19.440 --> 00:36:21.880
our views, and
applying CornerRadius,

00:36:21.880 --> 00:36:24.949
we can get a pretty
reasonable simulation of what

00:36:24.949 --> 00:36:25.990
a gooey should look like.

00:36:25.990 --> 00:36:27.650
If you were to start
animating your path, that

00:36:27.650 --> 00:36:29.730
is to say, take that path,
draw it to the screen,

00:36:29.730 --> 00:36:32.620
and then start changing
values every single frame,

00:36:32.620 --> 00:36:36.350
you can animate this really
cool sort of gooey-like effect.

00:36:36.350 --> 00:36:37.850
Again, you want to
use interpolators

00:36:37.850 --> 00:36:41.400
in this, because goo does
behave in a non-linear fashion.

00:36:45.850 --> 00:36:47.350
We could also use AnimationSets.

00:36:47.350 --> 00:36:49.724
So for our view's that are a
little bit more complicated,

00:36:49.724 --> 00:36:52.966
and we can't really do that
in a simple canvas animation,

00:36:52.966 --> 00:36:54.340
we can start using
AnimationSets.

00:36:56.870 --> 00:36:59.060
So this is a little
bit more costly,

00:36:59.060 --> 00:37:01.060
because you have to render
your animation first.

00:37:01.060 --> 00:37:04.370
This is pre-rendered animations,
you render in AfterEffects.

00:37:04.370 --> 00:37:08.330
You take your frames from that
animation-- and for the record,

00:37:08.330 --> 00:37:10.620
about 15 frames is
250 milliseconds,

00:37:10.620 --> 00:37:12.602
which is what I usually
use for my animations.

00:37:12.602 --> 00:37:14.060
The longer your
animation, the more

00:37:14.060 --> 00:37:15.439
frames you're going to have.

00:37:15.439 --> 00:37:17.230
But hopefully your
animation is reversible,

00:37:17.230 --> 00:37:21.170
so you can reuse these
frames in reverse.

00:37:21.170 --> 00:37:23.920
We add all these frames
to our animation list,

00:37:23.920 --> 00:37:27.670
and we set the duration to
be 16 milliseconds per frame.

00:37:27.670 --> 00:37:29.442
And then we just
apply it to our goop--

00:37:29.442 --> 00:37:30.900
or rather we apply
it to our view--

00:37:30.900 --> 00:37:34.901
and we can draw these
animations to the screen.

00:37:34.901 --> 00:37:36.650
I don't actually have
an example for this,

00:37:36.650 --> 00:37:39.410
because, quite frankly, in a
talk like this, that would just

00:37:39.410 --> 00:37:40.082
look like a GIF.

00:37:40.082 --> 00:37:41.790
That would look like
any other animation,

00:37:41.790 --> 00:37:47.260
because it's just your
straight up movie.

00:37:47.260 --> 00:37:49.620
That's how movies work.

00:37:49.620 --> 00:37:54.110
So what if we want to get
kind of complicated with this?

00:37:54.110 --> 00:37:56.160
What if we wanted
to actually simulate

00:37:56.160 --> 00:38:02.520
this stuff on the screen as
an actual fluid simulation?

00:38:02.520 --> 00:38:06.260
So usually, fluid simulation
is extremely expensive,

00:38:06.260 --> 00:38:09.440
but even if we
could simulate it,

00:38:09.440 --> 00:38:11.580
how do we apply that
to our drawable?

00:38:11.580 --> 00:38:14.870
Well, we do that using
what I call Bitmap Mesh.

00:38:14.870 --> 00:38:17.860
So Android has
this great feature

00:38:17.860 --> 00:38:19.710
called Draw Bitmap Mesh.

00:38:19.710 --> 00:38:22.860
This is available from
API one, so this was here

00:38:22.860 --> 00:38:24.270
from the start.

00:38:24.270 --> 00:38:27.220
And the way that it works
is you take your mesh,

00:38:27.220 --> 00:38:29.650
in the same way that you
would have an OpenGL mesh--

00:38:29.650 --> 00:38:35.700
square grid-- and you can
apply that mesh to a bitmap.

00:38:35.700 --> 00:38:37.230
And what Android
will actually do

00:38:37.230 --> 00:38:39.974
is it'll transform your
bitmap depending on that mesh.

00:38:39.974 --> 00:38:41.640
So if you take your
mesh and you stretch

00:38:41.640 --> 00:38:44.640
one corner of the
mesh all the way out,

00:38:44.640 --> 00:38:47.390
your bitmap will
stretch in the same way.

00:38:47.390 --> 00:38:49.850
So we can use this
to our advantage.

00:38:49.850 --> 00:38:54.880
What if we could use a mesh
and make it behave like a goop?

00:38:54.880 --> 00:38:57.490
Well, maybe we can.

00:39:00.320 --> 00:39:02.070
So this is exactly
what I'm talking about.

00:39:02.070 --> 00:39:05.050
We had this mesh, we
made it simulate goop,

00:39:05.050 --> 00:39:06.809
and we applied to our bitmap.

00:39:06.809 --> 00:39:08.350
So up on the top
screen, this is what

00:39:08.350 --> 00:39:09.800
it looks like without the
mesh, and underneath, I

00:39:09.800 --> 00:39:11.310
show you what the mesh
actually looks like.

00:39:11.310 --> 00:39:12.809
So what Android is
actually doing is

00:39:12.809 --> 00:39:15.560
it's deforming that circle
bitmap, which in this case

00:39:15.560 --> 00:39:17.670
is actually just
a circle drawable,

00:39:17.670 --> 00:39:21.170
and it's deforming it in the
way that that mesh indicates.

00:39:24.030 --> 00:39:28.880
So turns out that's
actually pretty simple.

00:39:28.880 --> 00:39:32.680
And if we take an optimized
physics simulation that kind of

00:39:32.680 --> 00:39:35.470
is optimized for this rebounding
animation and this deforming,

00:39:35.470 --> 00:39:38.440
we can kind of
simulate this stuff.

00:39:38.440 --> 00:39:41.420
So we just render a
drawable to bitmap.

00:39:41.420 --> 00:39:43.770
So we can take any view,
any button, anything

00:39:43.770 --> 00:39:46.990
that we actually want to
do, render it to a bitmap,

00:39:46.990 --> 00:39:49.540
deform the mesh that we
draw underneath that bitmap,

00:39:49.540 --> 00:39:51.220
Android pipes all of that down.

00:39:51.220 --> 00:39:54.900
By the way, that bitmap
mesh is really, really fast.

00:39:54.900 --> 00:39:58.340
That goes straight
from your canvas code,

00:39:58.340 --> 00:39:59.589
straight into OpenGL.

00:39:59.589 --> 00:40:01.380
Because what Android
does under the hood is

00:40:01.380 --> 00:40:03.342
it just creates that
mesh as an actual mesh,

00:40:03.342 --> 00:40:05.300
and then draws the bitmap
over it as a texture,

00:40:05.300 --> 00:40:06.950
in the same way that
a 3D game would.

00:40:06.950 --> 00:40:08.890
That's really, really fast.

00:40:08.890 --> 00:40:10.860
And like I said, this
is available from API 1,

00:40:10.860 --> 00:40:13.880
so this can run on
something like a Nexus 1,

00:40:13.880 --> 00:40:19.100
or at T-Mobile G1, or
whatever came before that.

00:40:19.100 --> 00:40:21.300
And then we can render
that bitmap to a canvas.

00:40:21.300 --> 00:40:23.008
And then we can actually
draw that canvas

00:40:23.008 --> 00:40:25.530
as our view underneath it,

00:40:25.530 --> 00:40:28.770
So that's where this comes in.

00:40:28.770 --> 00:40:30.702
GooeyBits.

00:40:30.702 --> 00:40:32.660
So I've started working
on something like this.

00:40:32.660 --> 00:40:34.826
In fact, the animation that
you saw up on the screen

00:40:34.826 --> 00:40:37.900
was actually rendered
by this library.

00:40:37.900 --> 00:40:41.860
And demo app is coming
soon, probably sometime

00:40:41.860 --> 00:40:43.590
by the end of the
year, and I would

00:40:43.590 --> 00:40:46.480
like to stress that this is
an early experimental proof

00:40:46.480 --> 00:40:48.480
of concept stage library.

00:40:48.480 --> 00:40:50.600
This is not ready
for prime time.

00:40:50.600 --> 00:40:51.970
Don't try to use this yet.

00:40:51.970 --> 00:40:53.950
Trust me, I'll tell
you when it's good.

00:40:53.950 --> 00:40:56.320
It'll be V1.

00:40:56.320 --> 00:41:00.020
There's no version yet

00:41:00.020 --> 00:41:01.760
So you guys can
download this, and you

00:41:01.760 --> 00:41:04.920
can check it out and play
with it a little bit,

00:41:04.920 --> 00:41:07.540
but it does work, and
it works really well.

00:41:07.540 --> 00:41:09.100
The fluid simulation
part of this

00:41:09.100 --> 00:41:10.890
is actually already finished.

00:41:10.890 --> 00:41:14.310
At this point in time it's just
mesh deformation and bitmap

00:41:14.310 --> 00:41:15.320
deformation.

00:41:15.320 --> 00:41:17.200
So at this point all
I'm really doing is just

00:41:17.200 --> 00:41:19.033
trying to get all of
the different behaviors

00:41:19.033 --> 00:41:21.100
that you would expect
from a piece of goo

00:41:21.100 --> 00:41:23.120
to draw into this
mesh, and then apply

00:41:23.120 --> 00:41:25.510
that mesh to your bitmaps,
and then move that mesh around

00:41:25.510 --> 00:41:27.490
in the way that you
would expect goop.

00:41:27.490 --> 00:41:30.960
So I expect to be able to
rip apart two pieces of goop

00:41:30.960 --> 00:41:32.598
and have two separate
pieces of goop.

00:41:36.590 --> 00:41:39.450
Oh, I guess that's
twice in there.

00:41:42.340 --> 00:41:44.524
So this is like the
bleeding edge of design.

00:41:44.524 --> 00:41:46.940
This isn't something that you
guys have probably heard of,

00:41:46.940 --> 00:41:48.314
because it's not
something that's

00:41:48.314 --> 00:41:51.590
been seriously propagated
throughout the design space.

00:41:51.590 --> 00:41:53.650
But I see this as
kind of moving forward

00:41:53.650 --> 00:41:56.390
with the natural
material design.

00:41:56.390 --> 00:41:59.350
If you want to follow
this space in general,

00:41:59.350 --> 00:42:01.100
there's a lot of designs
already up there.

00:42:01.100 --> 00:42:03.120
Not a lot of implementations,
although some designers

00:42:03.120 --> 00:42:05.245
have gone out and made a
couple of implementations,

00:42:05.245 --> 00:42:07.770
there's some really good
ones, you can check them out.

00:42:07.770 --> 00:42:09.690
MaterialUp, for those
of you who don't know,

00:42:09.690 --> 00:42:14.260
is this fantastic material
animation repository,

00:42:14.260 --> 00:42:17.060
where a bunch of designers just
drop their material animations

00:42:17.060 --> 00:42:17.650
in there.

00:42:17.650 --> 00:42:20.233
And you can look at them and go
like, wow, that's really cool,

00:42:20.233 --> 00:42:22.850
let me go implement it.

00:42:22.850 --> 00:42:25.372
Materialup.com,
it's very simple.

00:42:25.372 --> 00:42:27.080
You can type in gooey
into the search box

00:42:27.080 --> 00:42:29.720
and you'll actually get
a lot of animations.

00:42:29.720 --> 00:42:32.020
You can also follow
me on Twitter--

00:42:32.020 --> 00:42:33.901
shameless self-promotion--
because I'll

00:42:33.901 --> 00:42:36.150
be tweeting about this quite
a bit more moving forward

00:42:36.150 --> 00:42:39.650
throughout the year, as
the animation library moves

00:42:39.650 --> 00:42:40.490
forward.

00:42:40.490 --> 00:42:42.105
I see a couple
people taking photos.

00:42:44.650 --> 00:42:47.275
So expect one, two, three
more followers, yes.

00:42:47.275 --> 00:42:47.775
Oh, four.

00:42:51.400 --> 00:42:57.060
And that's almost my
talk, but before I go,

00:42:57.060 --> 00:42:58.982
I want to show you guys this.

00:42:58.982 --> 00:43:00.440
I don't know if
you guys know Luke,

00:43:00.440 --> 00:43:03.030
but Luke's really popular
in the Android space,

00:43:03.030 --> 00:43:04.590
in the mobile space.

00:43:04.590 --> 00:43:06.840
But this is kind of my
first exposure to gooey,

00:43:06.840 --> 00:43:08.850
it's thanks to Luke.

00:43:08.850 --> 00:43:11.810
And I just really like that
line on the second tweet, gooey

00:43:11.810 --> 00:43:14.280
is the new flat.

00:43:14.280 --> 00:43:18.070
So gooey is the new flat, guys.

00:43:18.070 --> 00:43:19.920
Get cracking.

