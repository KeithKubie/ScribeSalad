WEBVTT
Kind: captions
Language: en

00:00:00.786 --> 00:00:03.710
SAM CLEGG: Hi everybody,
my name's Sam Clegg.

00:00:03.710 --> 00:00:05.510
This is Ben Smith.

00:00:05.510 --> 00:00:07.760
We're engineers on the
Native Client team at Google,

00:00:07.760 --> 00:00:11.327
and we're here today with Kester
and Brian, to talk about some

00:00:11.327 --> 00:00:13.910
of the things we've been working
on recently to make it easier

00:00:13.910 --> 00:00:16.432
to bring Native Code to the web.

00:00:16.432 --> 00:00:18.390
We're going to split the
talk into three parts.

00:00:18.390 --> 00:00:20.710
First, Ben and I will talk
about some of the work

00:00:20.710 --> 00:00:23.230
we've been doing on the SDK.

00:00:23.230 --> 00:00:25.247
And then Brian and
Kester will each talk

00:00:25.247 --> 00:00:27.580
about how they've been using
Native Client in their work

00:00:27.580 --> 00:00:28.640
in other parts of Google.

00:00:32.100 --> 00:00:34.175
So we'll start with
a quick introduction.

00:00:34.175 --> 00:00:35.800
For those who don't
know, Native Client

00:00:35.800 --> 00:00:39.320
is an open source project
developed at Google,

00:00:39.320 --> 00:00:41.560
with the goal of being
able to compile and run

00:00:41.560 --> 00:00:45.090
Native Code in the
browser securely.

00:00:45.090 --> 00:00:47.180
So this technology's been
available to Chrome apps

00:00:47.180 --> 00:00:49.840
in the web store
for a long time now.

00:00:49.840 --> 00:00:52.730
You just saw the presentation
about how the web store works.

00:00:52.730 --> 00:00:56.570
And Portable Native Client,
or PNaCl as we call it,

00:00:56.570 --> 00:01:00.420
is a newer technology that
builds on Native Client,

00:01:00.420 --> 00:01:03.520
and adds an architecture
and OS neutral binary format

00:01:03.520 --> 00:01:05.480
that allows Native
Code to be run

00:01:05.480 --> 00:01:07.185
in the open web on any web page.

00:01:11.180 --> 00:01:14.550
So, as a developer, if you
have a Native App written in C

00:01:14.550 --> 00:01:18.080
or C++, what do you normally
need to do to bring this

00:01:18.080 --> 00:01:20.040
to the web using Native Client?

00:01:20.040 --> 00:01:21.860
Traditionally, you
would have to use

00:01:21.860 --> 00:01:24.160
what we call the
Pepper APIs, which

00:01:24.160 --> 00:01:26.490
are the APIs available
to Native Client

00:01:26.490 --> 00:01:28.980
modules for communicating
with the outside world.

00:01:28.980 --> 00:01:30.485
So you'd normally
need to identify

00:01:30.485 --> 00:01:31.860
all the parts of
your application

00:01:31.860 --> 00:01:36.340
that do I/Os such as graphics,
sound, and file I/O, and either

00:01:36.340 --> 00:01:40.540
replace, or modify,
those parts of your code.

00:01:40.540 --> 00:01:44.380
Also, Pepper is traditionally
asynchronous API,

00:01:44.380 --> 00:01:47.500
so you might need to modify
the way your application runs

00:01:47.500 --> 00:01:50.220
and handles events.

00:01:50.220 --> 00:01:52.544
So this is a fairly
significant burden

00:01:52.544 --> 00:01:53.960
for application
developers to have

00:01:53.960 --> 00:01:56.530
to modify their
code in this way.

00:01:56.530 --> 00:01:59.290
And, also, one of the main
benefits of having access to C

00:01:59.290 --> 00:02:02.900
and C++ is being able to use
the myriad of existing libraries

00:02:02.900 --> 00:02:05.460
that are out there in the
world, in the Open Source world.

00:02:05.460 --> 00:02:07.230
And so we wanted to make
it as easy as possible

00:02:07.230 --> 00:02:08.938
to bring those libraries
to Native Client

00:02:08.938 --> 00:02:10.077
without any modifications.

00:02:10.077 --> 00:02:11.660
And that's what we've
been working on.

00:02:11.660 --> 00:02:14.150
And to that end, we've
built a library called

00:02:14.150 --> 00:02:18.220
NaCl I/O and this is
essentially a POSIX emulation

00:02:18.220 --> 00:02:21.420
layer for Native Client.

00:02:21.420 --> 00:02:23.740
And it allows you to take
your applications that

00:02:23.740 --> 00:02:27.370
are written for POSIX-like
platforms such as Linux,

00:02:27.370 --> 00:02:29.620
and Mac, and Android,
and bring them

00:02:29.620 --> 00:02:34.690
to the web with far fewer
changes and far less effort.

00:02:34.690 --> 00:02:38.525
So NaCl I/O implements
many of the POSIX APIs

00:02:38.525 --> 00:02:40.525
that you'll be familiar
with such a Standardized

00:02:40.525 --> 00:02:43.410
I/O, and the BSD socket API.

00:02:43.410 --> 00:02:46.600
It also has the ability
to make blocking calls

00:02:46.600 --> 00:02:48.710
and use a traditional
C-style main entry

00:02:48.710 --> 00:02:51.350
point for your application.

00:02:51.350 --> 00:02:54.027
One interesting part of
this is that, because we're

00:02:54.027 --> 00:02:56.360
running in the web platform,
we don't have direct access

00:02:56.360 --> 00:02:58.120
to the host file system.

00:02:58.120 --> 00:03:02.150
So, what NaCl I/O does is
build a virtual file system out

00:03:02.150 --> 00:03:05.250
of file-like objects that are
accessible on the web platform.

00:03:05.250 --> 00:03:07.720
So for example, files
on your web server,

00:03:07.720 --> 00:03:11.920
or files in Chrome's
local HTML5 storage,

00:03:11.920 --> 00:03:15.760
become available through
the normal Unix file model

00:03:15.760 --> 00:03:16.990
that you're familiar with.

00:03:16.990 --> 00:03:19.750
You can Open, Close, Read,
and Write, all these things

00:03:19.750 --> 00:03:21.360
as if they were files.

00:03:21.360 --> 00:03:23.894
And you can even write
your own file system types,

00:03:23.894 --> 00:03:25.560
so that your application
feels like it's

00:03:25.560 --> 00:03:30.080
running in a POSIX environment,
and requires less porting.

00:03:32.710 --> 00:03:34.870
So one of the things that
NaCl I/O has facilitated

00:03:34.870 --> 00:03:36.950
is the growth of the
NaClports Project, which

00:03:36.950 --> 00:03:42.180
is a repository online
of existing applications

00:03:42.180 --> 00:03:44.680
and libraries that have already
been ported to Native Client

00:03:44.680 --> 00:03:45.980
and running Chrome.

00:03:45.980 --> 00:03:49.670
And we have over 100 libraries
and applications there today.

00:03:49.670 --> 00:03:51.340
Things like language
interpreters,

00:03:51.340 --> 00:03:54.320
python, ruby, and lua
that will run in Chrome,

00:03:54.320 --> 00:03:57.566
and middleware,
like ffmpeg or SDL,

00:03:57.566 --> 00:04:00.709
that you can take
advantage of today,

00:04:00.709 --> 00:04:02.000
if your application needs that.

00:04:04.910 --> 00:04:08.170
And a lot of these ports have
been facilitated by NaCl I/O,

00:04:08.170 --> 00:04:11.090
and many of them have zero
modification from the upstream,

00:04:11.090 --> 00:04:12.295
thanks to this POSIX layer.

00:04:15.460 --> 00:04:17.339
So now I'm going to
hand over to Ben,

00:04:17.339 --> 00:04:20.050
and we're going to show you
some of the applications that

00:04:20.050 --> 00:04:23.136
are running live
in Chrome today.

00:04:23.136 --> 00:04:25.430
BEN SMITH: Thanks Sam.

00:04:25.430 --> 00:04:27.700
So, the first one is
going to be well known

00:04:27.700 --> 00:04:33.030
to probably 50% of you, it is
the famous text editor Vim.

00:04:33.030 --> 00:04:35.830
And Sam will be loading
it here, you can see it.

00:04:35.830 --> 00:04:39.990
This is pretty much unmodified.

00:04:39.990 --> 00:04:44.680
You can see him now adding some
Syntax errors, to some-- no,

00:04:44.680 --> 00:04:49.412
almost adding-- So
it looks very much

00:04:49.412 --> 00:04:51.620
like it's running in a
terminal, but this is actually

00:04:51.620 --> 00:04:52.430
a Chrome app.

00:04:52.430 --> 00:04:55.960
And one of the benefits of that
is that it will run on Mac,

00:04:55.960 --> 00:05:03.880
Linux, and Windows and-- oh, did
you lose it?-- and Chromebooks.

00:05:06.500 --> 00:05:07.560
There we are.

00:05:12.610 --> 00:05:15.410
I thought you said
you were a vim wiz?

00:05:15.410 --> 00:05:16.940
OK.

00:05:16.940 --> 00:05:18.815
So that's the text editor, vim.

00:05:22.690 --> 00:05:25.520
Moving on to something that's
a little bit more visual,

00:05:25.520 --> 00:05:29.670
this is the Cocos2d-x
game engine.

00:05:29.670 --> 00:05:32.760
Cocos2d, according to
the Cocos2d authors,

00:05:32.760 --> 00:05:37.500
is the most popular
mobile game 2D engine.

00:05:37.500 --> 00:05:41.830
And so, this is just some
examples of some 3D graphics

00:05:41.830 --> 00:05:45.770
that can be rendered
using this engine.

00:05:45.770 --> 00:05:48.910
So very simple to take a game
that was written originally

00:05:48.910 --> 00:05:52.370
for mobile, and bring it to
the web, and also Chromebooks.

00:05:55.730 --> 00:05:58.120
All right, the last one
is another 2D game engine.

00:05:58.120 --> 00:06:00.190
This is called Love.

00:06:00.190 --> 00:06:03.130
This game, in
particular, is a game

00:06:03.130 --> 00:06:06.906
that is a mash up between Super
Mario Brothers and Portal.

00:06:06.906 --> 00:06:09.280
It used to be that you could
only play it on the desktop,

00:06:09.280 --> 00:06:12.460
but since ported
it to PNaCl, you

00:06:12.460 --> 00:06:14.800
can play it directly
in the browser.

00:06:14.800 --> 00:06:19.250
So you can see Sam, here,
trying to create a portal.

00:06:19.250 --> 00:06:20.770
Keep going.

00:06:20.770 --> 00:06:22.100
And there he goes.

00:06:24.936 --> 00:06:25.435
Very nice.

00:06:28.742 --> 00:06:30.450
So these are just some
of the cool things

00:06:30.450 --> 00:06:34.636
that you can do now with very,
very little porting at all.

00:06:34.636 --> 00:06:36.260
And I'm going to hand
it off to Kester,

00:06:36.260 --> 00:06:38.176
who's going to talk about
some cool stuff he's

00:06:38.176 --> 00:06:40.372
going to do next.

00:06:40.372 --> 00:06:42.850
KESTER TONG: Thanks Ben.

00:06:42.850 --> 00:06:45.140
So I'm going to be talking
about the work we've

00:06:45.140 --> 00:06:47.280
been doing porting
IPython to PNaCl.

00:06:47.280 --> 00:06:48.760
And this work has
involved Google,

00:06:48.760 --> 00:06:51.150
it's also involved external
Open Source contributors,

00:06:51.150 --> 00:06:53.050
such as Matthew
Turk from the Center

00:06:53.050 --> 00:06:54.910
for Supercomputing Applications.

00:06:54.910 --> 00:06:59.630
And we've also started working
with the IPython Dev team.

00:06:59.630 --> 00:07:02.740
So for those of you who
haven't heard of IPython,

00:07:02.740 --> 00:07:04.880
IPython Notebook
is an environment

00:07:04.880 --> 00:07:09.260
that allows users to it mix text
code, and the output of code,

00:07:09.260 --> 00:07:10.660
in a single notebook.

00:07:10.660 --> 00:07:13.850
And it's very popular for
things such as data analysis,

00:07:13.850 --> 00:07:16.550
because people can
do some code, they

00:07:16.550 --> 00:07:18.660
can see the output
of that, for example,

00:07:18.660 --> 00:07:19.820
in the form of a graph.

00:07:19.820 --> 00:07:21.789
Then they can do
some more coding,

00:07:21.789 --> 00:07:22.830
and see some more output.

00:07:22.830 --> 00:07:24.581
And after they're done
with this workflow,

00:07:24.581 --> 00:07:27.080
they have a written record of
every step that they've taken,

00:07:27.080 --> 00:07:28.340
so it's very reproducible.

00:07:28.340 --> 00:07:32.640
And then they can add text
annotations, as you see here.

00:07:32.640 --> 00:07:36.890
And they can share this with
other people and publish it.

00:07:36.890 --> 00:07:39.150
So our goal is to
integrate IPython better

00:07:39.150 --> 00:07:42.090
with web technologies.

00:07:42.090 --> 00:07:43.560
We've done two things.

00:07:43.560 --> 00:07:46.280
The first is that we
ported IPython to PNaCl,

00:07:46.280 --> 00:07:49.220
and this allows for a
single one-click install

00:07:49.220 --> 00:07:51.120
from the Chrome Web Store.

00:07:51.120 --> 00:07:53.800
So currently IPython
is a desktop app,

00:07:53.800 --> 00:07:55.770
and it has a somewhat
complicated installation

00:07:55.770 --> 00:08:01.920
process, which may make it
hard for some users to use it.

00:08:01.920 --> 00:08:03.930
But when we've ported
IPython to PNaCl,

00:08:03.930 --> 00:08:08.290
we are able to now package it
as a Chrome Web Store app, which

00:08:08.290 --> 00:08:10.520
means a person can download
it from the Chrome Web

00:08:10.520 --> 00:08:11.950
Store in a single
click, and it's

00:08:11.950 --> 00:08:15.480
going to work the same
on every single platform.

00:08:15.480 --> 00:08:18.100
The other thing we've done is
integrated the user interface

00:08:18.100 --> 00:08:19.250
with Google Drive.

00:08:19.250 --> 00:08:22.320
So previously, IPython was
using the local file system

00:08:22.320 --> 00:08:24.637
to manage notebook files.

00:08:24.637 --> 00:08:26.470
And this could make
collaboration difficult,

00:08:26.470 --> 00:08:28.000
because, for
example, people might

00:08:28.000 --> 00:08:30.340
have to email files backwards
and forwards, if they

00:08:30.340 --> 00:08:31.257
wanted to collaborate.

00:08:31.257 --> 00:08:33.756
But we've made that much easier
by integrating the front end

00:08:33.756 --> 00:08:34.590
with Google Drive.

00:08:34.590 --> 00:08:37.429
So that all notebook files
live on Google Drive.

00:08:37.429 --> 00:08:39.650
And furthermore, we've
integrated with the real time

00:08:39.650 --> 00:08:44.410
API so that multiple
people can work

00:08:44.410 --> 00:08:45.870
on the document
at the same time.

00:08:45.870 --> 00:08:48.036
So as you can see here,
it's very much like a Google

00:08:48.036 --> 00:08:50.420
Doc-style interface where
you have individuals,

00:08:50.420 --> 00:08:53.291
you can see who's in the
document at any time,

00:08:53.291 --> 00:08:55.040
you can see where
they're in the document,

00:08:55.040 --> 00:08:56.680
and you can multiple
people working

00:08:56.680 --> 00:08:59.980
on the same document
at the same time.

00:08:59.980 --> 00:09:00.900
So how did we do this?

00:09:00.900 --> 00:09:03.750
This shows the architecture
of the Chrome app.

00:09:03.750 --> 00:09:07.130
So, Chrome apps
contain a front end,

00:09:07.130 --> 00:09:09.410
which is written in
JavaScript and HTML.

00:09:09.410 --> 00:09:11.620
But they could also
contain PNaCl files,

00:09:11.620 --> 00:09:12.900
PNaCl binary files.

00:09:12.900 --> 00:09:15.560
And in this case,
the PNaCl binary file

00:09:15.560 --> 00:09:17.690
is running the
Python run time, that

00:09:17.690 --> 00:09:21.030
is the IPython kernel, which
is executing the Python code.

00:09:21.030 --> 00:09:24.320
So all of the execution is
done inside the browser.

00:09:24.320 --> 00:09:26.180
A typical workflow
for a user would

00:09:26.180 --> 00:09:29.280
be to start off in the
Google Drive website,

00:09:29.280 --> 00:09:32.431
they could open a file,
by clicking on a file.

00:09:32.431 --> 00:09:33.930
Or they could create
a new one, that

00:09:33.930 --> 00:09:35.690
will launch a window
in the Chrome app,

00:09:35.690 --> 00:09:38.900
and then the front end will
talk to the Google API servers

00:09:38.900 --> 00:09:42.830
to implement the
real-time collaboration.

00:09:42.830 --> 00:09:45.810
As a developer, if
you're going to implement

00:09:45.810 --> 00:09:49.099
such an app yourself, Chrome
apps basically packages,

00:09:49.099 --> 00:09:50.890
they contain not only
the front end-- which

00:09:50.890 --> 00:09:53.710
is like a web page living
in a window, which contains

00:09:53.710 --> 00:09:55.550
JavaScript and
HTML-- but then when

00:09:55.550 --> 00:09:57.010
you want to package
it with PNaCl,

00:09:57.010 --> 00:10:01.370
you also can include the
PNaCl binary inside the app

00:10:01.370 --> 00:10:03.750
along with a manifest
which contains permissions.

00:10:03.750 --> 00:10:06.380
In our case, one reason
we prefer the Chrome app

00:10:06.380 --> 00:10:08.630
is because then we can
have full access to the web

00:10:08.630 --> 00:10:11.540
without cause restrictions.

00:10:11.540 --> 00:10:14.060
I'm now going to demo this app.

00:10:14.060 --> 00:10:17.380
So I start in the
Google Drive website.

00:10:17.380 --> 00:10:19.515
I'm going to click, New,
and Create a New Document.

00:10:22.650 --> 00:10:25.304
It doesn't look
very healthy there.

00:10:25.304 --> 00:10:26.595
I'm going to try one more time.

00:10:30.500 --> 00:10:32.360
OK, that's even worse.

00:10:32.360 --> 00:10:34.530
So, I'm going to start
from one that I already

00:10:34.530 --> 00:10:39.040
have running-- also
seems to have hung.

00:10:42.590 --> 00:10:46.065
So I'm just going to
do a reset of this.

00:10:52.136 --> 00:10:53.010
Let's try this again.

00:11:06.410 --> 00:11:08.270
OK, that's looking better.

00:11:08.270 --> 00:11:11.970
So it's creating a new
notebook within Google Drive.

00:11:11.970 --> 00:11:13.520
And once it's created
this notebook,

00:11:13.520 --> 00:11:16.060
we'll be ready to
execute some code.

00:11:16.060 --> 00:11:17.640
So if I type in
some code such as,

00:11:17.640 --> 00:11:24.350
Print, Hello, It will
execute this code.

00:11:24.350 --> 00:11:27.650
And the execution is
happening in the browser.

00:11:27.650 --> 00:11:29.870
I'm just going to show
a very quick demo, which

00:11:29.870 --> 00:11:31.280
I won't be able to
underwrite, but I'll just

00:11:31.280 --> 00:11:32.238
write it in very quick.

00:11:49.050 --> 00:11:50.226
Thanks, thanks a lot, Sam.

00:11:50.226 --> 00:11:52.600
So what I'm doing here is I've
imported a library called,

00:11:52.600 --> 00:11:54.730
NumPy, which is a
numerics library.

00:11:54.730 --> 00:11:57.490
And I'm just going to show
some auto complete here.

00:11:57.490 --> 00:12:03.060
So I can find the random,
normal, distribution.

00:12:03.060 --> 00:12:07.630
And I'm going to
generate 10,000 of these.

00:12:07.630 --> 00:12:10.580
And add them up to
get a random walk.

00:12:10.580 --> 00:12:17.310
And then if I plot this, then,
as you can see, that's a plot.

00:12:17.310 --> 00:12:19.822
So this is just a
very simple example

00:12:19.822 --> 00:12:22.030
of the sorts of things you
can do with this notebook.

00:12:22.030 --> 00:12:24.082
A very typical example
of something someone

00:12:24.082 --> 00:12:26.040
might do in real life,
is downloading some data

00:12:26.040 --> 00:12:27.776
off the internet,
doing some analysis,

00:12:27.776 --> 00:12:29.150
and then, with
our software, they

00:12:29.150 --> 00:12:30.840
can then share this
with other people,

00:12:30.840 --> 00:12:32.180
publish it, and so forth.

00:12:32.180 --> 00:12:33.650
I'm now going to
hand off to Brian,

00:12:33.650 --> 00:12:36.865
who's going to go about
his team's work with PNaCl.

00:12:36.865 --> 00:12:38.670
BRIAN ELLIS: Thank you Kester.

00:12:38.670 --> 00:12:40.790
So I work on the
Google Earth team.

00:12:40.790 --> 00:12:45.330
And I want to talk to you a
little about something related

00:12:45.330 --> 00:12:53.900
to this, which is working
with existing JavaScript APIs

00:12:53.900 --> 00:12:54.760
in Native Client.

00:12:54.760 --> 00:12:57.770
So the subtitle of my talk is,
why it doesn't have to hurt.

00:12:57.770 --> 00:13:00.900
I'll get to that in a minute.

00:13:00.900 --> 00:13:04.600
So in the bad old days, that
many of you may remember,

00:13:04.600 --> 00:13:08.750
the world was dominated by the
Netscape Plugin API, NPAPI.

00:13:08.750 --> 00:13:10.960
And here's an example
of some NPAPI code.

00:13:10.960 --> 00:13:14.540
We have this magical embed
tag in the document, which

00:13:14.540 --> 00:13:16.980
just sort of grows some
JavaScript properties

00:13:16.980 --> 00:13:18.700
and methods which you can call.

00:13:18.700 --> 00:13:22.170
There's a lot of magic
involved with this process.

00:13:22.170 --> 00:13:24.600
There are a lot of
reasons not to like NPAPI.

00:13:24.600 --> 00:13:28.240
It was a great technology at the
time, but the time in question

00:13:28.240 --> 00:13:30.690
was like 1995.

00:13:30.690 --> 00:13:32.680
So it's really
hard to work with,

00:13:32.680 --> 00:13:34.160
hard to write, hard to debug.

00:13:34.160 --> 00:13:36.730
It has security holes the
size of small countries.

00:13:36.730 --> 00:13:39.730
And most relevantly for
all of us it is deprecated.

00:13:39.730 --> 00:13:41.800
It Is going away in Chrome.

00:13:41.800 --> 00:13:45.290
It is probably going
away soon in Firefox.

00:13:45.290 --> 00:13:48.170
Internet Explorer never
supported it terribly well.

00:13:48.170 --> 00:13:50.810
We don't want to
use NPAPI anymore.

00:13:50.810 --> 00:13:54.340
Obviously, we would like to
consider Native Client to be

00:13:54.340 --> 00:13:58.840
the replacement for NPAPI,
but if you write Native Client

00:13:58.840 --> 00:14:01.360
code to do the same thing that
we did in the previous slide,

00:14:01.360 --> 00:14:03.620
you'll see that it looks
very, very different.

00:14:03.620 --> 00:14:06.440
There's now JSON messages
being passed back and forth.

00:14:06.440 --> 00:14:08.050
And it's not
immediately obvious,

00:14:08.050 --> 00:14:09.674
but if you look
closely at this, you'll

00:14:09.674 --> 00:14:11.240
see that it is
asynchronous code.

00:14:11.240 --> 00:14:14.830
There's an event handler
that is processing

00:14:14.830 --> 00:14:17.080
the replies for
all these messages.

00:14:17.080 --> 00:14:22.800
So, if you have an existing
synchronous JavaScript API,

00:14:22.800 --> 00:14:27.330
that you want to port away
from NPAPI to Native Client,

00:14:27.330 --> 00:14:30.440
you can't, at all.

00:14:30.440 --> 00:14:31.810
But that is about change.

00:14:31.810 --> 00:14:34.400
And I'm going to
demonstrate how.

00:14:34.400 --> 00:14:38.140
We have, just this week, added
to a Dev channel of Chrome

00:14:38.140 --> 00:14:42.870
near you a synchronous
version of the APIs

00:14:42.870 --> 00:14:44.840
for posting and
receiving messages.

00:14:44.840 --> 00:14:46.064
So this is the new code.

00:14:46.064 --> 00:14:48.230
And you'll see, it looks
very much like the old code

00:14:48.230 --> 00:14:50.830
except that now there
is an AndAwaitResponse

00:14:50.830 --> 00:14:54.370
on the end of that message,
and it has a return value.

00:14:54.370 --> 00:14:57.540
So this is actually going
to do this synchronously

00:14:57.540 --> 00:14:59.930
and give you back the
value immediately.

00:14:59.930 --> 00:15:01.921
It may not seem like
much of a difference.

00:15:01.921 --> 00:15:03.670
After all, you've still
got all these JSON

00:15:03.670 --> 00:15:04.720
objects floating around.

00:15:04.720 --> 00:15:08.810
It's still very message-based,
feels sort of like an RPC call.

00:15:08.810 --> 00:15:10.610
But with a small
JavaScript shim,

00:15:10.610 --> 00:15:12.680
which you can write
on top of this,

00:15:12.680 --> 00:15:15.250
you can get this code, which
out to look pretty familiar,

00:15:15.250 --> 00:15:17.530
because it is
basically line-for-line

00:15:17.530 --> 00:15:21.690
identical to the NPAPI code we
wrote in the very first slide.

00:15:21.690 --> 00:15:24.050
So here's the broad
statement I'm going to make.

00:15:24.050 --> 00:15:25.800
It is now possible,
as of this week,

00:15:25.800 --> 00:15:28.370
to implement almost
any existing JavaScript

00:15:28.370 --> 00:15:31.400
API on top of Native Client.

00:15:31.400 --> 00:15:34.280
So to prove this
to you, I'm going

00:15:34.280 --> 00:15:36.290
to, by way of
demonstration, show

00:15:36.290 --> 00:15:43.490
you-- looks like I'm going
to have to relaunch it

00:15:43.490 --> 00:15:47.710
because we restarted everything.

00:15:47.710 --> 00:15:49.820
So, let me do this.

00:15:57.030 --> 00:16:00.830
This is some of the technology,
behind Google Earth,

00:16:00.830 --> 00:16:03.195
running in a browser
in Native Client.

00:16:03.195 --> 00:16:06.580
And as you can see,
it is very smooth.

00:16:06.580 --> 00:16:09.320
I'm getting about 60
frames per second here.

00:16:09.320 --> 00:16:12.840
We have full support
for many of the features

00:16:12.840 --> 00:16:15.320
that you have grown
to know and love

00:16:15.320 --> 00:16:18.670
in Google Earth,
such as 3D buildings.

00:16:18.670 --> 00:16:22.740
So if I zoom in to
San Francisco here.

00:16:22.740 --> 00:16:25.630
And if the Wi-Fi network
in the Moscone Center

00:16:25.630 --> 00:16:27.610
is willing to cooperate
with me, you'll

00:16:27.610 --> 00:16:29.010
see here we have full 3D.

00:16:31.590 --> 00:16:35.850
We also have some
JavaScript, and HTML,

00:16:35.850 --> 00:16:37.040
running on top of this view.

00:16:37.040 --> 00:16:39.130
So all of this rendering
is happening natively,

00:16:39.130 --> 00:16:40.390
using Native Client.

00:16:40.390 --> 00:16:42.780
But, for example,
I can do a search

00:16:42.780 --> 00:16:49.480
for pizza near the
Moscone Center.

00:16:49.480 --> 00:16:52.640
And these results, again
assuming that the Wi-Fi here

00:16:52.640 --> 00:16:56.320
is going to cooperate with
us, are rendered in pure HTML.

00:16:56.320 --> 00:16:57.690
And they can interact.

00:16:57.690 --> 00:17:01.560
So I can zoom in
to these results

00:17:01.560 --> 00:17:04.910
and see them on the map.

00:17:04.910 --> 00:17:09.501
I can even click through
and see information

00:17:09.501 --> 00:17:10.334
about each of these.

00:17:10.334 --> 00:17:14.869
These are, again, rendered
in pure HTML and JavaScript.

00:17:14.869 --> 00:17:18.930
We can interact in
more fundamental ways

00:17:18.930 --> 00:17:20.560
by turning layers on and off.

00:17:20.560 --> 00:17:26.213
So here we're going to see, in
a minute, traffic information.

00:17:26.213 --> 00:17:29.600
At least, that's the idea.

00:17:29.600 --> 00:17:31.210
I guess traffic is
at a standstill.

00:17:31.210 --> 00:17:33.390
Well, that happens sometimes.

00:17:33.390 --> 00:17:35.650
Let's try Transit
Routes instead.

00:17:35.650 --> 00:17:40.357
I think that should
be-- well, you

00:17:40.357 --> 00:17:41.690
may have to take my word for it.

00:17:41.690 --> 00:17:44.100
But it does work.

00:17:44.100 --> 00:17:46.690
And we even have
some features that

00:17:46.690 --> 00:17:48.270
don't exist in
Google Earth today.

00:17:48.270 --> 00:17:50.970
For example, you can
switch back and forth

00:17:50.970 --> 00:17:57.055
from the globe to a
flat map, with all

00:17:57.055 --> 00:17:59.360
of the same information
plotted on it.

00:17:59.360 --> 00:18:04.160
And, again, the network is
loading fairly slowly, so--

00:18:04.160 --> 00:18:08.030
And all this is done
with no special code.

00:18:08.030 --> 00:18:10.682
There is a small
portability layer

00:18:10.682 --> 00:18:13.140
that Google Earth has had for
a very long time, which we've

00:18:13.140 --> 00:18:15.030
adapted to use the Pepper API.

00:18:15.030 --> 00:18:18.887
And we have JavaScript code,
which is written for this demo.

00:18:18.887 --> 00:18:19.470
And that's it.

00:18:19.470 --> 00:18:21.210
Everything else is
exactly the code

00:18:21.210 --> 00:18:23.130
that we deploy everywhere else.

00:18:23.130 --> 00:18:26.400
And Google Earth is not
a simple application.

00:18:26.400 --> 00:18:34.840
So, let's go back here.

00:18:34.840 --> 00:18:36.950
So there are few
caveats about this.

00:18:36.950 --> 00:18:40.660
One is, that with great power
comes great responsibility.

00:18:40.660 --> 00:18:42.690
When you have a
blocking API like this,

00:18:42.690 --> 00:18:45.520
you are actually going to
block Chrome's renderer thread.

00:18:45.520 --> 00:18:48.510
So don't wait long
before returning,

00:18:48.510 --> 00:18:51.200
or your users will notice
the performance drop.

00:18:51.200 --> 00:18:53.190
And also, similarly,
for the same reasons,

00:18:53.190 --> 00:18:56.520
prefer the asynchronous API,
whenever you can use it.

00:18:56.520 --> 00:18:58.280
The reason why that
is the primary API

00:18:58.280 --> 00:18:59.720
is for performance reasons.

00:18:59.720 --> 00:19:02.710
But now, if your
porting an NPAPI API,

00:19:02.710 --> 00:19:04.810
or some other API that
requires synchronous calls,

00:19:04.810 --> 00:19:08.090
you have that
option open to you.

00:19:08.090 --> 00:19:09.520
So happy hacking.

00:19:09.520 --> 00:19:12.000
And if you're wondering
what to do next,

00:19:12.000 --> 00:19:13.760
we have some
suggestions for you.

00:19:13.760 --> 00:19:16.300
First of all, contribute
your Open Source product,

00:19:16.300 --> 00:19:18.860
or for that matter, somebody
else's Open Source product

00:19:18.860 --> 00:19:21.420
to NaClports, the
URL is right here.

00:19:21.420 --> 00:19:24.070
And if you want to learn
more about NaCl and PNaCl,

00:19:24.070 --> 00:19:28.025
go to gonacl.com Thank
you very, very much.

00:19:36.740 --> 00:19:38.910
So I'm going to open
it up for questions.

00:19:38.910 --> 00:19:40.650
If anybody would like to--

00:19:45.765 --> 00:19:51.400
AUDIENCE: So, you guys said that
you ported the IPython notebook

00:19:51.400 --> 00:19:52.696
to PNaCl.

00:19:52.696 --> 00:19:53.660
Two questions.

00:19:53.660 --> 00:19:56.780
First of all, is
that somewhere to be

00:19:56.780 --> 00:19:59.125
found on the internet
for me to use?

00:19:59.125 --> 00:20:01.660
KESTER TONG: Yeah, it's
actually inside the NaCl ports

00:20:01.660 --> 00:20:02.555
repository.

00:20:02.555 --> 00:20:03.740
AUDIENCE: Oh, very good.

00:20:03.740 --> 00:20:06.830
And secondly, you said
it's ported to PNaCl,

00:20:06.830 --> 00:20:10.640
does the porting process differ
when porting to NaCl when

00:20:10.640 --> 00:20:13.842
compared to PNaCl, or is
it basically convertible?

00:20:13.842 --> 00:20:15.822
SAM CLEGG: It's
slightly different.

00:20:15.822 --> 00:20:17.030
There's a different compiler.

00:20:17.030 --> 00:20:20.200
With PNaCl, we're using a
Clang based compiler, an LLVM.

00:20:20.200 --> 00:20:22.815
With NaCl, it's a
DTC based compiler.

00:20:22.815 --> 00:20:24.440
The other main
limitation is that PNaCl

00:20:24.440 --> 00:20:26.050
doesn't support
inline assembler.

00:20:26.050 --> 00:20:29.330
So if you have inline
assembler for x86 ARM,

00:20:29.330 --> 00:20:31.860
today you can't use
that in the PNaCl world.

00:20:31.860 --> 00:20:34.130
But it does support
intrinsics for SIMD

00:20:34.130 --> 00:20:36.500
primitive, so you can get
some of the high performance

00:20:36.500 --> 00:20:39.230
that you might be looking
for in your assembly code.

00:20:39.230 --> 00:20:40.174
AUDIENCE: Thank you.

00:20:40.174 --> 00:20:41.590
KESTER TONG: I
just wanted to add,

00:20:41.590 --> 00:20:46.341
that only the kernel is
on NaCl ports right now.

00:20:46.341 --> 00:20:49.910
SAM CLEGG: But you are planning
on publishing that app publicly

00:20:49.910 --> 00:20:50.890
in the future, right?

00:20:50.890 --> 00:20:53.155
KESTER TONG: We'll be making
an announcement next week

00:20:53.155 --> 00:20:54.780
at the [? SciFi ?]
conference regarding

00:20:54.780 --> 00:20:57.690
the open sourcing
of the rest of it.

00:20:57.690 --> 00:20:58.688
SAM CLEGG: Cool.

00:21:02.680 --> 00:21:05.860
AUDIENCE: You're competing with
and Emscripten and asm.js so

00:21:05.860 --> 00:21:08.610
can just talk about the
trade offs between the two,

00:21:08.610 --> 00:21:11.016
and where you think
each one is stronger?

00:21:11.016 --> 00:21:14.700
SAM CLEGG: Yeah, there's a
lot of similarities there.

00:21:14.700 --> 00:21:17.570
Some of the things that
we allow are currently

00:21:17.570 --> 00:21:21.430
impossible in Emscripten,
like background threads

00:21:21.430 --> 00:21:23.040
and blocking APIs.

00:21:23.040 --> 00:21:25.500
So we can actually
implement fopen and fread,

00:21:25.500 --> 00:21:30.007
where it goes to the network and
blocks for any amount of time.

00:21:30.007 --> 00:21:32.340
So some of the stuff you have
to do to go to Emscripten,

00:21:32.340 --> 00:21:36.570
you don't have to do
to go to NaCl today.

00:21:36.570 --> 00:21:39.826
There are lots of
different trade offs.

00:21:39.826 --> 00:21:42.070
Our stuff has been
available for a bit longer,

00:21:42.070 --> 00:21:43.740
so it's a bit more
mature, probably.

00:21:43.740 --> 00:21:46.160
It's been in production
for several years now.

00:21:48.870 --> 00:21:50.680
There are probably
other people here

00:21:50.680 --> 00:21:53.600
who can speak more to the
subtleties between the two.

00:21:53.600 --> 00:21:56.420
But PNaCl and
Emscripten both use

00:21:56.420 --> 00:21:58.470
the same LLVM based tool chain.

00:21:58.470 --> 00:22:01.827
And they even share
some of the LLVM passes.

00:22:01.827 --> 00:22:03.410
So, there's some
amount of convergence

00:22:03.410 --> 00:22:06.869
that the two teams-- and they
do communicate, the two teams.

00:22:06.869 --> 00:22:09.160
You can expect more convergence
in the future, I think.

00:22:16.027 --> 00:22:18.060
AUDIENCE: Is there an example?

00:22:18.060 --> 00:22:20.430
Obviously, you probably
don't have the source code

00:22:20.430 --> 00:22:22.190
for Google Earth out there.

00:22:22.190 --> 00:22:24.360
But do you have
another example code

00:22:24.360 --> 00:22:26.470
that uses-- does
that use OpenGL?

00:22:26.470 --> 00:22:30.480
SAM CLEGG: Yes, that
uses OpenGL ES 2.0, which

00:22:30.480 --> 00:22:33.849
is what Native Client provides.

00:22:33.849 --> 00:22:35.890
You can either look in
the SDK, for our examples.

00:22:35.890 --> 00:22:38.710
Or you can look on NaClports,
the projects I mentioned,

00:22:38.710 --> 00:22:41.710
where you can see over 100
Open Source applications that

00:22:41.710 --> 00:22:42.932
run inside Native Client.

00:22:42.932 --> 00:22:44.390
AUDIENCE: And you
were also talking

00:22:44.390 --> 00:22:48.392
about being able to have
JavaScript on top of--

00:22:48.392 --> 00:22:50.022
SAM CLEGG: Yeah, so--

00:22:50.022 --> 00:22:51.480
AUDIENCE: what
exactly do you mean?

00:22:51.480 --> 00:22:52.438
And how does that work?

00:22:52.438 --> 00:22:54.040
SAM CLEGG: So, in
Native Client, you

00:22:54.040 --> 00:22:58.590
can either render to a 2D canvas
or a 3D canvas, like WebGL.

00:22:58.590 --> 00:23:01.760
And the canvases, if I'm right,
behave very, very similarly

00:23:01.760 --> 00:23:04.150
to HTML5 canvas and 3D canvas.

00:23:06.780 --> 00:23:07.810
It's just an element.

00:23:07.810 --> 00:23:10.380
AUDIENCE: Yeah, so it's just
a surface that you can--

00:23:10.380 --> 00:23:12.560
it's a surface in the
JavaScript based web--

00:23:12.560 --> 00:23:14.643
BRIAN ELLIS: It's actually
even simpler than that.

00:23:14.643 --> 00:23:18.000
You can simply overlay DIVs
on top of the NaCl embed,

00:23:18.000 --> 00:23:20.730
and it will composite correctly
with Alpha, and everything.

00:23:26.801 --> 00:23:30.742
AUDIENCE: This is only
available in Chrome, still?

00:23:30.742 --> 00:23:32.700
BEN SMITH: Yeah, it's
only available in Chrome.

00:23:32.700 --> 00:23:34.000
AUDIENCE: You haven't
convinced anybody else

00:23:34.000 --> 00:23:35.070
that it's an Open
Source project?

00:23:35.070 --> 00:23:36.614
Presumably, it
could be included--

00:23:36.614 --> 00:23:37.780
BEN SMITH: Sorry, say again?

00:23:37.780 --> 00:23:42.180
AUDIENCE: I said, NaCl,
PNaCl, Open Source project.

00:23:42.180 --> 00:23:44.800
Conceivably it could be included
in Firefox, or whatever?

00:23:44.800 --> 00:23:46.300
BEN SMITH: Conceivably,
it could be.

00:23:46.300 --> 00:23:49.440
But I don't believe that there's
any plans for other browsers.

00:23:49.440 --> 00:23:52.026
AUDIENCE: Does this run
on Chrome on Android?

00:23:52.026 --> 00:23:53.940
BEN SMITH: It does not, no.

00:23:53.940 --> 00:23:55.825
Not currently, although
there are plans.

00:24:02.040 --> 00:24:03.790
FEMALE SPEAKER: Another
thing to point out

00:24:03.790 --> 00:24:05.570
is the Pepper JS
library, which lets

00:24:05.570 --> 00:24:08.940
you take an application
that's targeting

00:24:08.940 --> 00:24:10.900
portable Native Client
and the Pepper APIs,

00:24:10.900 --> 00:24:13.180
and then compile that
using Emscripten,

00:24:13.180 --> 00:24:15.550
and we'll create polyfills
of the Pepper APIs

00:24:15.550 --> 00:24:17.490
that target
JavaScript back ends.

00:24:17.490 --> 00:24:20.290
So, given that you're
using the Pepper APIs

00:24:20.290 --> 00:24:24.440
it will make your life easier to
then port to an asm.js version.

00:24:24.440 --> 00:24:26.962
So we're definitely trying to
work with the community here,

00:24:26.962 --> 00:24:28.670
and the different
technologies available,

00:24:28.670 --> 00:24:30.730
to give our developers
the best option.

00:24:30.730 --> 00:24:32.565
SAM CLEGG: Yes, so
using that technology,

00:24:32.565 --> 00:24:36.060
you can produce a JavaScript
file using Emscripten,

00:24:36.060 --> 00:24:39.270
and a PNaCl file using our tool
chain, from the same source

00:24:39.270 --> 00:24:39.770
code.

00:24:39.770 --> 00:24:40.436
That's the idea.

00:24:40.436 --> 00:24:43.991
So then you could have a
cross platform solution.

00:24:43.991 --> 00:24:45.720
BEN SMITH: And
there are examples

00:24:45.720 --> 00:24:48.390
of that on, I think
it's, trypepperjs.org.

00:24:52.199 --> 00:24:53.490
FEMALE SPEAKER: More questions?

00:24:56.120 --> 00:24:58.500
AUDIENCE: So if I
want to use SIMD,

00:24:58.500 --> 00:25:02.170
then the x86 and ARM
intrinsics are different.

00:25:02.170 --> 00:25:03.710
So what do you actually support?

00:25:03.710 --> 00:25:07.330
BEN SMITH: So it
uses LLVM intrinsics,

00:25:07.330 --> 00:25:09.800
which are recently introduced.

00:25:09.800 --> 00:25:12.890
And there are examples of
that in the most recent STK,

00:25:12.890 --> 00:25:13.390
as well.

00:25:13.390 --> 00:25:19.350
So, it will look very
much like-- anything

00:25:19.350 --> 00:25:21.600
that's not actually implemented
by that processor will

00:25:21.600 --> 00:25:25.070
be sort of filled in
whatever way necessary.

00:25:25.070 --> 00:25:26.250
So it will always work.

00:25:26.250 --> 00:25:30.190
It's just a question of will
it be-- it won't necessarily

00:25:30.190 --> 00:25:33.880
be as fast if the [INAUDIBLE]
doesn't support it.

00:25:33.880 --> 00:25:36.640
AUDIENCE: I'm not familiar
with the LLVM intrinsics.

00:25:36.640 --> 00:25:39.100
Are they four at a time,
or eight, or sixteen, or--?

00:25:39.100 --> 00:25:40.600
BEN SMITH: You can
actually specify.

00:25:40.600 --> 00:25:42.690
There's many different sizes.

00:25:42.690 --> 00:25:46.840
I think, currently, we
only support 128 bit wide,

00:25:46.840 --> 00:25:49.650
but we have plans to support
larger, is my understanding.

00:25:49.650 --> 00:25:50.616
AUDIENCE: Thanks.

00:25:55.832 --> 00:25:57.540
FEMALE SPEAKER: If
you want to learn more

00:25:57.540 --> 00:26:00.400
about Portable Native
Client and SIMD intrinsics,

00:26:00.400 --> 00:26:04.370
there's also two videos that
we recorded and launched

00:26:04.370 --> 00:26:07.340
under the Google
I/O DevBytes site.

00:26:07.340 --> 00:26:10.380
And so, you can watch J.F.,
who implemented the SIMD

00:26:10.380 --> 00:26:12.620
intrinsics, tell you about
exactly how he did it

00:26:12.620 --> 00:26:15.400
and how he chose which
subset was super portable.

00:26:15.400 --> 00:26:17.270
And then also Brad
Nelson, who's talking

00:26:17.270 --> 00:26:21.420
about a new developer,
editor, that we have created,

00:26:21.420 --> 00:26:23.476
so that you could
actually debug and edit

00:26:23.476 --> 00:26:25.100
your programs running
on a Chrome book.

00:26:27.690 --> 00:26:28.685
Go check that out.

00:26:28.685 --> 00:26:30.560
SAM CLEGG: Yeah, this
development environment

00:26:30.560 --> 00:26:34.530
actually at uses PNaCl
to run GCC, and vim,

00:26:34.530 --> 00:26:37.100
and bash, and make,
all inside of a tab.

00:26:37.100 --> 00:26:40.740
So we're trying to get as
much with POSIX as possible

00:26:40.740 --> 00:26:43.640
to allow you to actually do
your development in Chrome,

00:26:43.640 --> 00:26:45.636
on a Chrome book.

00:26:45.636 --> 00:26:47.060
AUDIENCE: What about e.max?

00:26:47.060 --> 00:26:48.390
SAM CLEGG: E.max is coming.

00:26:48.390 --> 00:26:50.050
We have that in the pipeline.

00:26:50.050 --> 00:26:52.120
The build system for e.max
is a little bit crazy,

00:26:52.120 --> 00:26:54.184
so that's the main
problem there.

00:26:54.184 --> 00:26:55.128
AUDIENCE: [INAUDIBLE]

00:26:55.128 --> 00:26:56.110
SAM CLEGG: Yeah.

00:26:56.110 --> 00:26:58.650
Yeah.

00:26:58.650 --> 00:27:01.901
FEMALE SPEAKER: Any
other questions?

00:27:01.901 --> 00:27:02.400
Cool.

00:27:02.400 --> 00:27:06.090
Thank you so much for listening,
and go check out PNaCl.

