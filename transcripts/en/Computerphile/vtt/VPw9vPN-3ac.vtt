WEBVTT
Kind: captions
Language: en-GB

00:00:00.000 --> 00:00:03.680
Here's something that will be new to some of you at least

00:00:03.720 --> 00:00:08.040
Which in my opinion is the coolest logical operation in the world

00:00:08.040 --> 00:00:13.320
It really, some of its properties are so nice you just go, "Wow, that's great."

00:00:13.320 --> 00:00:15.320
It's exclusive Or.

00:00:17.400 --> 00:00:20.960
Let's write down a truth table for this thing.

00:00:20.960 --> 00:00:24.000
The exclusive or is like the inclusive or.

00:00:24.000 --> 00:00:29.940
It comes out as true if either one of the inputs is a one.

00:00:30.560 --> 00:00:33.480
but not when both of them are a one.

00:00:33.480 --> 00:00:35.480
That's why it's called exclusive.

00:00:35.480 --> 00:00:39.760
If they're both one, it doesn't come out as a 1 it comes out as a 0.

00:00:39.760 --> 00:00:42.940
Another way to look at it is to say

00:00:42.940 --> 00:00:46.600
the outcome's a 1 only if the two inputs differ.

00:00:46.600 --> 00:00:49.520
If they're the same then the outcome's 0.

00:00:49.520 --> 00:00:54.660
So here we go: 0 exclusive ored with a 0, they're the same, it's 0.

00:00:54.660 --> 00:00:59.200
A 1 exclusive ored with a 1, they're the same so that's a 0.

00:00:59.200 --> 00:01:04.800
But a 1 with a 0 or a 0 with a 1, they're different, so the answer is a 1.

00:01:04.800 --> 00:01:09.180
And for this reason, the exclusive or operation

00:01:09.180 --> 00:01:11.180
is sometimes called

00:01:11.180 --> 00:01:13.380
a not equivalence operation

00:01:13.380 --> 00:01:15.380
A NEC, as well as exclusive or.

00:01:15.380 --> 00:01:22.800
But if we're writing this down again in our electronics engineer-type notation, how do they like to write it down

00:01:22.800 --> 00:01:25.080
well this one's a special favourite of mine

00:01:25.080 --> 00:01:29.240
it doesn't just have a go faster fast back to it.

00:01:29.240 --> 00:01:36.720
it's got actually a double go faster aerodynamic fast back like that.

00:01:36.720 --> 00:01:38.720
So you get your two inputs

00:01:38.720 --> 00:01:39.820
a

00:01:39.820 --> 00:01:40.960
b

00:01:41.840 --> 00:01:48.180
you get your output here. Now how can you denote a exclusive ored with b?

00:01:48.180 --> 00:01:50.680
Well, lots of ways.

00:01:50.680 --> 00:01:54.980
Computer scientists would probably prefer to just write out xor.

00:01:54.980 --> 00:02:00.800
Largely because many assembly languages will have an xor operation and that's the way you think about it.

00:02:00.800 --> 00:02:05.140
But mathematical logicians may prefer

00:02:05.140 --> 00:02:08.020
and we very often see this so be aware of it

00:02:08.020 --> 00:02:11.260
to put a plus inside a circle.

00:02:11.260 --> 00:02:15.640
Like that. And that's to denote that it's not the inclusive or

00:02:15.640 --> 00:02:19.900
for which they'd use a plus sign on its own but it's a special form of plus.

00:02:19.900 --> 00:02:26.240
If fact, as you'll see in just a minute it's precisely the form of addition you need for a binary adder circuit.

00:02:26.240 --> 00:02:27.340
It really really is.

00:02:27.340 --> 00:02:31.780
But don't forget, don't be thrown if you see it written particularly in old textbooks

00:02:31.780 --> 00:02:34.980
some of them might call it the "not equivalence operation"

00:02:34.980 --> 00:02:36.980
a not equivalence with b.

00:02:36.980 --> 00:02:38.980
let me just show you now

00:02:38.980 --> 00:02:42.620
what happens if I exclusive or

00:02:43.140 --> 00:02:45.640
not just a single bit with a single bit

00:02:46.040 --> 00:02:50.060
but suppose we're doing a 3-bit binary adder.

00:02:50.060 --> 00:02:51.040
Dead simple.

00:02:51.620 --> 00:02:53.360
Unsigned addition.

00:02:53.360 --> 00:02:55.760
No two's complement. Nothing silly.

00:02:55.760 --> 00:02:58.540
Just straightforward vanilla binary adder.

00:02:58.540 --> 00:03:01.080
I'm going to write down 101.

00:03:01.080 --> 00:03:03.080
Which you all know is 5.

00:03:03.080 --> 00:03:07.200
I'm going to write down 010, which you all know is 2.

00:03:07.200 --> 00:03:09.200
And I'm going to put between them

00:03:09.200 --> 00:03:10.680
a circle plus

00:03:10.680 --> 00:03:13.120
to show you I'm exclusive oring

00:03:13.120 --> 00:03:15.280
Now what what happens from the right

00:03:15.280 --> 00:03:18.080
1 exclusive ored with 0

00:03:18.080 --> 00:03:19.220
They differ.

00:03:19.220 --> 00:03:21.220
Therefore the outcome is a 1.

00:03:21.220 --> 00:03:24.800
0 exclusive ored with 1, they differ

00:03:25.300 --> 00:03:26.560
the outcome's a 1.

00:03:26.560 --> 00:03:28.280
I've done this very carefully.

00:03:28.780 --> 00:03:33.460
Left hand column 1 exclusive ored with 0 they still differ, that's 1.

00:03:33.460 --> 00:03:35.460
5 and 2 is 7.

00:03:35.460 --> 00:03:38.300
That's magic all you've done, it's binary adder.

00:03:38.300 --> 00:03:45.280
To which my repost will be, "Yes it's a binary adder but I've carefully drawn a veil

00:03:45.280 --> 00:03:48.180
over what would happen if I had to carry.

00:03:48.180 --> 00:03:51.320
a bit from one position to the next."

00:03:51.320 --> 00:03:53.740
Because that needs extra attention.

00:03:53.740 --> 00:04:02.520
So think of it this way, the exclusive or is what you want for adding together all of the bits in a given column of a binary adder.

00:04:02.520 --> 00:04:09.820
The only trouble is is it doesn't take care of the carrying out the bit to the next column on the left.

00:04:09.820 --> 00:04:16.200
I can now show you the beginnings of how you could build

00:04:16.200 --> 00:04:20.540
or draw a logic diagram for your favourite electronics person to build for you.

00:04:20.540 --> 00:04:24.400
a 1-bit part binary adder

00:04:24.400 --> 00:04:27.860
It's technically known, here, as a half adder.

00:04:27.860 --> 00:04:29.860
So if you focus in on this, just look at this,

00:04:29.860 --> 00:04:32.140
First of all I'm revising here up at the top

00:04:32.140 --> 00:04:35.820
Here's what we've now done, we've done 'and', 'or', exclusive or and not

00:04:35.820 --> 00:04:39.260
There's a rather better drawn, neater gate, up there

00:04:39.260 --> 00:04:40.840
But just look at this

00:04:40.840 --> 00:04:45.580
at the top you will now recognize an exclusive or gate.

00:04:45.580 --> 00:04:47.580
with two inputs 'a' and 'b'.

00:04:47.580 --> 00:04:49.580
The output of those is called the sum.

00:04:49.580 --> 00:04:51.580
It's the sum in that column.

00:04:51.580 --> 00:04:55.100
However if it so happens that a and b are both 1

00:04:55.100 --> 00:04:58.020
we know what will happen with exclusive or

00:04:58.020 --> 00:05:01.000
it will say, "oh, they're the same. So I generate a 0"

00:05:01.000 --> 00:05:07.240
Wow! That's good. That's the right answer. You want to generate a 0, but you want to carry 1.

00:05:07.240 --> 00:05:10.880
So how do you generate the so-called carry-out bit?

00:05:10.880 --> 00:05:15.760
The answer is, in parallel with the inputs a and b going into the exclusive or

00:05:15.760 --> 00:05:19.340
you take them in parallel to an 'and' gate.

00:05:19.340 --> 00:05:27.780
Now remember, just want you're going to need, you're only going to carry if both of those bits in that column were 1.

00:05:28.000 --> 00:05:29.740
1 and 1 is 0.

00:05:29.740 --> 00:05:31.960
And that means you must carry out 1

00:05:31.960 --> 00:05:33.980
to the position to the left.

00:05:33.980 --> 00:05:39.620
The carry bit is the logical result of anding together a and b.

00:05:39.620 --> 00:05:44.320
and I've given you the truth table over here on the right for the whole shebang.

00:05:44.320 --> 00:05:46.320
Here's your a, here's your b

00:05:46.620 --> 00:05:48.620
Here's what the carry bit must be

00:05:49.160 --> 00:05:51.980
It must be a 1 only if the two inputs are 1s.

00:05:51.980 --> 00:05:54.360
In the second column here's the sum.

00:05:56.080 --> 00:05:59.300
A 1 if you're adding naught and one and zero,

00:05:59.620 --> 00:06:02.040
if you're adding two zeros it's obviously a zero.

00:06:02.040 --> 00:06:06.280
If you're adding two 1s it's a zero but you've taken care of the carry out.

00:06:06.740 --> 00:06:08.740
You can see why that's called a half adder.

00:06:09.140 --> 00:06:14.940
I mean we relax back, we have glass of champagne, a pint of beer, whatever turns you on, but you've only done half the job.

00:06:15.140 --> 00:06:22.280
Because the hard bit is- and I can here lots of you in the comments already saying, "Ah, but what about carry in?!"

00:06:22.560 --> 00:06:29.620
Here I am in the middle of a 32-bit binary addition, slack-bang in the middle and on column 15 I have to carry in

00:06:29.620 --> 00:06:34.440
coming from my right, as well as having to give a carry out further over to the left.

00:06:34.580 --> 00:06:36.820
Uh, yes! Well

00:06:37.220 --> 00:06:40.800
For those of you who are hardcore, or haven't seen it before

00:06:41.100 --> 00:06:46.240
let me just finish this little excursion by saying, "if you want to know what a full

00:06:46.240 --> 00:06:49.420
1-bit adder has to look like"

00:06:49.740 --> 00:06:51.740
just feast your eyes on this one here.

00:06:51.740 --> 00:06:58.640
At the top left, that's the main exclusive or that does the straightforward addition of the digits that are in that column

00:06:58.640 --> 00:07:00.080
that you're trying to add at the moment.

00:07:00.080 --> 00:07:03.120
Down here at the bottom is the carry out

00:07:03.120 --> 00:07:05.120
that we had before

00:07:05.120 --> 00:07:07.120
but the complication now is

00:07:07.420 --> 00:07:09.660
you've got to do the carry in.

00:07:09.660 --> 00:07:11.160
How do you do the carry in?

00:07:11.800 --> 00:07:15.900
Well you bring it in as C subscript in, it just comes in

00:07:15.900 --> 00:07:21.120
the carry in to this position is what the carry out was from the previous position that you've just done

00:07:21.120 --> 00:07:22.940
And you bring it in here.

00:07:23.160 --> 00:07:28.460
And I want you to work your way through this and convince yourself that this is the right answer.

00:07:28.840 --> 00:07:30.980
The carry in bit

00:07:30.980 --> 00:07:33.400
Will affect the carry out bit

00:07:33.600 --> 00:07:36.580
because as we saw when we were doing binary addition

00:07:36.640 --> 00:07:40.400
You sometimes get a situation when there's a carry in of 1

00:07:40.860 --> 00:07:44.800
but the two figures in the column to be added up also are 1s

00:07:45.020 --> 00:07:49.040
So you can have 1 + 1 + 1, right?

00:07:49.160 --> 00:07:53.140
Which is like 3, which is like

00:07:53.140 --> 00:07:57.820
modulo 2 arithmetic, it's like a 2 to be carried but with a remain of 1.

00:07:57.820 --> 00:08:02.640
So 1+1+1 is write down the 1 and carry the 1.

00:08:02.640 --> 00:08:05.440
And this bit of the circuit down here

00:08:05.440 --> 00:08:12.800
is the extended carry out circuit which copes with the fact that the carry in may have given you yet another 1

00:08:12.800 --> 00:08:16.740
to be added in as well as the two 1s that were in the column already.

00:08:16.880 --> 00:08:18.880
So here's the overall truth table

00:08:18.880 --> 00:08:20.320
for everything folks.

00:08:20.320 --> 00:08:22.860
Your a and b inputs in this particular column

00:08:22.860 --> 00:08:26.240
Whether you have a carry in or not, was it naught or 1.

00:08:26.240 --> 00:08:31.040
And in the light of all of those just read across and you'll find out what happens

00:08:31.700 --> 00:08:38.580
If a and b are 0 and you have a 0 carry in, it's easy. There's no carry out and the sum of the two is 0.

00:08:38.840 --> 00:08:41.140
Down here, the really hardest one of all

00:08:41.380 --> 00:08:43.380
is if you've got an a and b of 1

00:08:43.380 --> 00:08:45.060
and a carry in of 1

00:08:45.480 --> 00:08:47.760
that's going to be 1 down and carry 1

00:08:48.040 --> 00:08:49.260
so 1 and 1 at the bottom

00:08:49.380 --> 00:08:51.440
intermediate, you can check through.

00:08:51.440 --> 00:08:53.440
Everything checks out just the way it does.

00:08:54.120 --> 00:08:58.400
So apart from all this are the charms which we've yet to discover

00:08:58.400 --> 00:09:03.040
the great thing about exclusive or is that it's just what you need

00:09:03.040 --> 00:09:05.140
with a few extra,

00:09:05.140 --> 00:09:08.140
and gates and an or gate

00:09:08.260 --> 00:09:11.360
to do the carry outs and carry in. If you do all that

00:09:11.360 --> 00:09:16.480
exclusive or is at the heart of what a binary adder circuit has to have.

00:09:19.540 --> 00:09:22.620
go-faster tail fin there

00:09:23.200 --> 00:09:25.200
and it slips round like this

00:09:25.440 --> 00:09:30.600
There is your 'or' gate with an 'a' and a 'b'.

