WEBVTT
Kind: captions
Language: en

00:00:04.960 --> 00:00:07.110
NICO WEBER: Welcome to the last
time slot at Google I/O.

00:00:07.110 --> 00:00:08.900
I'm Nico.

00:00:08.900 --> 00:00:10.070
I'm glad you guys
could make it.

00:00:10.070 --> 00:00:13.100
So did you have a good
time so far?

00:00:13.100 --> 00:00:14.940
Any favorite sessions so far?

00:00:17.650 --> 00:00:18.900
[AUDIENCE SHOUTING ANSWERS]

00:00:20.470 --> 00:00:21.290
NICO WEBER: Yeah
I saw that one.

00:00:21.290 --> 00:00:22.540
I really liked that.

00:00:24.980 --> 00:00:26.880
So you might have noticed
it's kind of hard to

00:00:26.880 --> 00:00:27.830
get tickets for I/O.

00:00:27.830 --> 00:00:30.810
One of the easiest ways for me
to get in was to give a talk.

00:00:30.810 --> 00:00:33.620
So that's why I'm here.

00:00:33.620 --> 00:00:35.490
And it's very different to watch
all the talks when you

00:00:35.490 --> 00:00:36.640
know you'll be talking later.

00:00:36.640 --> 00:00:39.380
So one thing I've been paying
attention to a lot is what the

00:00:39.380 --> 00:00:41.360
presenters do with their hands,
knowing that I have to

00:00:41.360 --> 00:00:43.230
do something with my hands.

00:00:43.230 --> 00:00:47.630
So all the professional
presenters did like this.

00:00:47.630 --> 00:00:50.140
I guess they read some book on
body language and read that

00:00:50.140 --> 00:00:51.872
this means open and relaxed.

00:00:51.872 --> 00:00:54.860
And all the more engineering
types of guys were like this.

00:00:54.860 --> 00:00:58.120
And then they did a
stand in between.

00:00:58.120 --> 00:01:00.050
And I guess my conclusion is,
talks are more fun if you

00:01:00.050 --> 00:01:01.540
don't pay attention to
the hands of the

00:01:01.540 --> 00:01:02.460
presenter so much.

00:01:02.460 --> 00:01:06.580
So don't look at my hands.

00:01:06.580 --> 00:01:08.720
I'm going to be talking a little
bit about 3D graphics

00:01:08.720 --> 00:01:09.150
on Android.

00:01:09.150 --> 00:01:16.610
It Earlier this year I ported
Google Body to Android 3.0.

00:01:16.610 --> 00:01:20.660
And I'll just share my
experience there, I guess.

00:01:20.660 --> 00:01:24.390
So who here has Google Body?

00:01:24.390 --> 00:01:24.910
Quite a few.

00:01:24.910 --> 00:01:27.980
So for those who haven't, if you
just do a web search for

00:01:27.980 --> 00:01:31.340
Google Body and pick the first
hit on most search engines,

00:01:31.340 --> 00:01:34.240
you'll go to this thing here.

00:01:34.240 --> 00:01:36.840
And it's basically a
human anatomy app.

00:01:36.840 --> 00:01:38.870
Users call it Google
Earth for the body.

00:01:38.870 --> 00:01:40.930
So there's a 3D app
of the human body.

00:01:40.930 --> 00:01:43.530
You can zoom in, pan around.

00:01:43.530 --> 00:01:45.900
There's a transparency slide
on the left here, where you

00:01:45.900 --> 00:01:49.930
can look at skeleton
and whatnot.

00:01:52.450 --> 00:01:53.850
There's a search box
up here where you

00:01:53.850 --> 00:01:57.090
can search for stuff.

00:01:57.090 --> 00:02:00.760
And you might not have known
that the liver has kind of an

00:02:00.760 --> 00:02:02.560
interesting 3D structure
from the back.

00:02:05.750 --> 00:02:08.080
You can click on things to
learn how they're called.

00:02:08.080 --> 00:02:09.330
So this is the colon.

00:02:11.600 --> 00:02:13.460
And that's basically
Google Body.

00:02:13.460 --> 00:02:18.150
For April 1 we had Google Cow,
which was kind of popular.

00:02:18.150 --> 00:02:21.790
So it will be a little
while until it loads.

00:02:21.790 --> 00:02:23.310
So that's the same
thing for a cow.

00:02:27.790 --> 00:02:32.350
It was pretty popular so
we left it in the app.

00:02:32.350 --> 00:02:33.600
So that's Google Body.

00:02:36.600 --> 00:02:38.980
So Google Body is obviously
a web app.

00:02:38.980 --> 00:02:40.640
It lives in the browser.

00:02:40.640 --> 00:02:43.390
And for 3D display, it uses
a technology that's pretty

00:02:43.390 --> 00:02:45.810
that's called WebGL, which was
also demoed in the keynote

00:02:45.810 --> 00:02:49.540
this morning and there were
a few talks on that.

00:02:49.540 --> 00:02:52.560
So there's no plugins or
anything needed for that.

00:02:52.560 --> 00:02:54.290
You just need a new browser.

00:02:54.290 --> 00:02:55.860
So for example, Chrome
supports WebGL.

00:02:55.860 --> 00:02:58.870
Firefox 4 does.

00:02:58.870 --> 00:03:04.290
WebKit, which is the Safari
prerelease version, I guess,

00:03:04.290 --> 00:03:06.430
kind of, supports WebGL.

00:03:06.430 --> 00:03:08.130
There's an Opera
11 preview that

00:03:08.130 --> 00:03:10.470
supports WebGL on Windows.

00:03:10.470 --> 00:03:14.220
But sadly the Android browser
does not support WebGL yet.

00:03:16.850 --> 00:03:19.780
Google Body is a 20%
project by about

00:03:19.780 --> 00:03:21.010
five people at Google.

00:03:21.010 --> 00:03:24.590
So Google has this concept
of 20% time.

00:03:24.590 --> 00:03:26.410
One day of the week you can
work on whatever you

00:03:26.410 --> 00:03:28.660
want, if you want.

00:03:28.660 --> 00:03:31.250
And they were looking for
someone to make Google Body

00:03:31.250 --> 00:03:34.180
happen on Android.

00:03:34.180 --> 00:03:36.440
So I figured, yeah that
sounds like fun.

00:03:36.440 --> 00:03:38.660
I'll do that.

00:03:38.660 --> 00:03:40.480
And let me show you
how is looks.

00:03:40.480 --> 00:03:45.520
So Google Body for tablets is
available in the market today.

00:03:45.520 --> 00:03:48.170
So if you're looking for
something to do with your

00:03:48.170 --> 00:03:52.180
tablets, you can
download this.

00:03:52.180 --> 00:03:53.850
And it's basically
the same thing.

00:03:53.850 --> 00:03:57.470
So there's a 3D view
of a model that

00:03:57.470 --> 00:03:58.920
you can move around.

00:03:58.920 --> 00:04:01.060
You can zoom in, zoom out.

00:04:01.060 --> 00:04:02.310
Look at different
layers up here.

00:04:05.430 --> 00:04:08.460
You have a search box
where you can--

00:04:08.460 --> 00:04:10.370
I don't know-- search
for skull.

00:04:10.370 --> 00:04:12.360
Oh, it's right there.

00:04:12.360 --> 00:04:13.960
You can tap on things.

00:04:13.960 --> 00:04:15.670
So these things here
are called teeth.

00:04:18.880 --> 00:04:23.280
And there's a fun bug where
I don't do modular

00:04:23.280 --> 00:04:23.990
interpolations.

00:04:23.990 --> 00:04:26.080
So if you spin the model a bit
and then click on the reset

00:04:26.080 --> 00:04:30.590
view button it spins
a bit too often.

00:04:30.590 --> 00:04:33.340
So that basically Google
Body for Android.

00:04:33.340 --> 00:04:36.440
The cow is not in there yet.

00:04:36.440 --> 00:04:37.690
But it'll come eventually.

00:04:41.230 --> 00:04:42.350
So that's what I did.

00:04:42.350 --> 00:04:46.450
And currently this is tablets
only and currently I am

00:04:46.450 --> 00:04:49.940
working on getting this
to work on phones.

00:04:49.940 --> 00:04:52.750
And I'd like just to share my
experience writing this a

00:04:52.750 --> 00:04:54.980
little bit.

00:04:54.980 --> 00:04:57.880
So Google Body was released
December 2010.

00:04:57.880 --> 00:05:00.140
I did the port after that.

00:05:00.140 --> 00:05:02.827
So they send out a mail saying,
anyone interested in

00:05:02.827 --> 00:05:03.800
porting this to Android?

00:05:03.800 --> 00:05:05.550
And I was like, yeah, if
nobody else stands up.

00:05:05.550 --> 00:05:07.680
Sure I'll do it.

00:05:07.680 --> 00:05:09.380
And then they told
me, awesome.

00:05:09.380 --> 00:05:12.110
And we want this for tablets and
you have two weeks and go.

00:05:15.210 --> 00:05:19.670
So my point is, I don't have a
ton of Android experience.

00:05:19.670 --> 00:05:21.470
So I'm not on the
Android team.

00:05:21.470 --> 00:05:25.710
What I'm saying is my personal
opinion; not an official

00:05:25.710 --> 00:05:27.260
recommendation.

00:05:27.260 --> 00:05:28.910
It might be factually wrong.

00:05:28.910 --> 00:05:30.760
Parts are, probably.

00:05:30.760 --> 00:05:34.530
And what I'm mostly focusing
on is doing

00:05:34.530 --> 00:05:35.690
3D graphics on Android.

00:05:35.690 --> 00:05:37.410
I kind assume that
you are somewhat

00:05:37.410 --> 00:05:38.050
familiar with Android.

00:05:38.050 --> 00:05:41.710
So who here knows what
an activity is?

00:05:41.710 --> 00:05:42.130
Everyone?

00:05:42.130 --> 00:05:43.980
Awesome.

00:05:43.980 --> 00:05:47.790
Who here has used OpenGL
before in any?

00:05:47.790 --> 00:05:48.640
Also most people.

00:05:48.640 --> 00:05:49.090
Awesome.

00:05:49.090 --> 00:05:52.100
Who here has done OpenGL
on Android?

00:05:52.100 --> 00:05:53.560
OK, so not as many.

00:05:53.560 --> 00:05:55.440
That's perfect.

00:05:55.440 --> 00:05:57.750
So I think this talk is perfect
for you if you have

00:05:57.750 --> 00:06:00.150
some experience with Android,
some experience with OpenGL,

00:06:00.150 --> 00:06:03.530
but not so much with
the combination.

00:06:03.530 --> 00:06:06.720
And if you are completely new
to Android, I gave a version

00:06:06.720 --> 00:06:08.360
of this talk at the Game
Developers Conference

00:06:08.360 --> 00:06:09.130
earlier this year.

00:06:09.130 --> 00:06:13.140
And if you just do a web search
for GDC 2011 Android

00:06:13.140 --> 00:06:16.650
OpenGL, you'll find this page,
which has a slightly more

00:06:16.650 --> 00:06:19.070
basic version of this talk
with uglier slides.

00:06:22.430 --> 00:06:26.940
So Google Body for Android is a
native Java app and it uses

00:06:26.940 --> 00:06:29.480
OpenGL ES 2.0 for
the 3D display.

00:06:32.650 --> 00:06:34.200
So let's see what I'll
be talking about.

00:06:34.200 --> 00:06:38.860
So I'll very quickly tell you
what OpenGL ES 2.0 is.

00:06:38.860 --> 00:06:41.880
It's actually faster than
saying the whole

00:06:41.880 --> 00:06:44.770
word, OpenGL ES 2.0.

00:06:44.770 --> 00:06:46.630
And then I'll give you
a very, very rough

00:06:46.630 --> 00:06:48.920
mental model of GPUs.

00:06:48.920 --> 00:06:53.620
Tell you a few pitfalls
with textures.

00:06:53.620 --> 00:06:58.550
A few best practices and
pitfalls with geometry, that

00:06:58.550 --> 00:06:59.800
is Vertex Buffer Objects.

00:07:03.340 --> 00:07:06.660
Then I'll tell you quickly how
to quickly get data into

00:07:06.660 --> 00:07:07.590
Vertex Buffer--

00:07:07.590 --> 00:07:09.850
into ByteBuffers, which
you need to

00:07:09.850 --> 00:07:11.720
upload them to the GPU.

00:07:11.720 --> 00:07:15.930
And then I'll say a few words
about performance tweaks.

00:07:15.930 --> 00:07:18.050
So OpenGL ES 2.0.

00:07:18.050 --> 00:07:20.300
So I guess everyone
here knows OpenGL.

00:07:20.300 --> 00:07:23.680
It's looks like this, right?

00:07:23.680 --> 00:07:24.650
Looks familiar to anyone?

00:07:24.650 --> 00:07:26.800
Awesome.

00:07:26.800 --> 00:07:31.900
So OpenGL is basically
the 3D API.

00:07:31.900 --> 00:07:33.750
There are implementations
on Windows,

00:07:33.750 --> 00:07:37.710
MacOS, Linux, many phones.

00:07:37.710 --> 00:07:41.890
It's been around forever,
so it's very versatile.

00:07:41.890 --> 00:07:43.860
As I said, it's been
around for a long

00:07:43.860 --> 00:07:46.020
time, 20 years I think.

00:07:46.020 --> 00:07:48.720
And it has accumulated some
crap during that time.

00:07:48.720 --> 00:07:51.110
And they are currently cleaning
that up, but by the

00:07:51.110 --> 00:07:54.390
time they wanted to do 3D on
phones, OpenGL was kind of

00:07:54.390 --> 00:07:57.630
messy, so they decided to
release mostly a subset.

00:07:57.630 --> 00:08:02.410
OpenGL for Embedded Systems.
That's what the ES stands for.

00:08:02.410 --> 00:08:07.520
And OpenGL ES is basically
OpenGL with fewer functions.

00:08:07.520 --> 00:08:10.420
So they got rid of glbegin
and many other things.

00:08:14.700 --> 00:08:20.210
And there are two versions
of OpenGL ES: OpenGL ES 1

00:08:20.210 --> 00:08:22.650
corresponds to OpenGL
1, more or less.

00:08:22.650 --> 00:08:24.900
And it has a fixed function
type line.

00:08:24.900 --> 00:08:28.850
So that means every model you
draw will do vertex transform

00:08:28.850 --> 00:08:30.930
and rasterization and some
predefined lighting

00:08:30.930 --> 00:08:32.789
functions and so on.

00:08:32.789 --> 00:08:35.700
And there's OpenGL ES 2, which
roughly corresponds to OpenGL

00:08:35.700 --> 00:08:38.250
2, which has fully programmable
vertex and

00:08:38.250 --> 00:08:39.500
fragment shaders and all that.

00:08:43.230 --> 00:08:46.850
And Android supports both OpenGL
ES1 and OpenGL ES 2.

00:08:46.850 --> 00:08:49.790
If you do a web search for
Android OpenGL you'll find

00:08:49.790 --> 00:08:52.810
some official Android that
tells you-- that proudly

00:08:52.810 --> 00:08:52.950
proclaims--

00:08:52.950 --> 00:08:55.920
Android supports OpenGL ES 1.

00:08:55.920 --> 00:08:58.760
And that's factually not wrong,
I guess, but it also

00:08:58.760 --> 00:09:00.420
supports OpenGL ES 2
and that's what you

00:09:00.420 --> 00:09:02.200
want to use in practice.

00:09:02.200 --> 00:09:04.980
And I think they are updating
their documentation there but

00:09:04.980 --> 00:09:06.470
they are not there yet.

00:09:06.470 --> 00:09:09.540
And just as an aside, WebGL
is basically binding

00:09:09.540 --> 00:09:11.760
for OpenGL ES 2.0.

00:09:11.760 --> 00:09:14.870
So in theory, mobile browsers
could support WebGL in the

00:09:14.870 --> 00:09:17.650
future but they don't yet.

00:09:17.650 --> 00:09:22.770
And WebGL is very exciting but
nothing that I'll talk about

00:09:22.770 --> 00:09:23.330
in this talk.

00:09:23.330 --> 00:09:27.420
Because Body for Android
doesn't use it.

00:09:27.420 --> 00:09:29.240
So as I said, I'm currently
porting

00:09:29.240 --> 00:09:30.730
Body 2 to mobile phones.

00:09:30.730 --> 00:09:34.080
So I kind of need to decide
which Android versions I want

00:09:34.080 --> 00:09:34.590
to support.

00:09:34.590 --> 00:09:37.380
If you're just writing a tablet
app, you just support

00:09:37.380 --> 00:09:39.570
Android 3.0 That's easy.

00:09:39.570 --> 00:09:42.600
But for phones you need to take
a look at this chart,

00:09:42.600 --> 00:09:47.050
which is at
developer.android.com/blog.

00:09:47.050 --> 00:09:51.730
And Android 1.5 and 1.6
are less than--

00:09:51.730 --> 00:09:55.220
I think are about 5% of the
market share these days.

00:09:55.220 --> 00:09:59.550
So I don't think it's really
worth supporting.

00:09:59.550 --> 00:10:04.910
Android 2.1 is, I think,
about 24%.

00:10:04.910 --> 00:10:07.370
Which is pretty sizable.

00:10:07.370 --> 00:10:14.110
Android 2.2 is at 65-ish%
and Android 2.3 is 4%.

00:10:14.110 --> 00:10:17.910
And that adds up to
about 100, I hope.

00:10:17.910 --> 00:10:21.760
So Android 2.1 is the first
version of Android that

00:10:21.760 --> 00:10:23.770
supports OpenGL ES2.

00:10:23.770 --> 00:10:26.310
But only in the native code.

00:10:26.310 --> 00:10:29.660
So they are no Java bindings
or anything like that.

00:10:29.660 --> 00:10:32.910
So if you want to do OpenGL ES
2.0 and support Android 2.1

00:10:32.910 --> 00:10:35.100
you need to add your own driver
bindings, which is not

00:10:35.100 --> 00:10:37.090
hard but annoying.

00:10:37.090 --> 00:10:41.020
And I personally haven't used
Android 2.1 at all yet.

00:10:41.020 --> 00:10:45.640
So I won't say a lot about
Android 2.1 or anything.

00:10:45.640 --> 00:10:48.370
Android 2.2 is the first
version that adds Java

00:10:48.370 --> 00:10:50.055
bindings for OpenGL ES2.

00:10:50.055 --> 00:10:53.750
So I think that's a reasonable
lower bound, at least for the

00:10:53.750 --> 00:10:58.640
first iteration of your
project to target.

00:10:58.640 --> 00:11:01.730
It also added support for
compressed textures, or added

00:11:01.730 --> 00:11:04.840
API support for compressed
textures.

00:11:04.840 --> 00:11:07.580
And many other cool things.

00:11:07.580 --> 00:11:10.850
And finally, Android 2.3.

00:11:10.850 --> 00:11:12.890
From a Java OpenGL perspective,

00:11:12.890 --> 00:11:15.270
added only bug fixes.

00:11:15.270 --> 00:11:21.580
If you're writing native code
2.3 added a lot of cool stuff.

00:11:21.580 --> 00:11:24.040
But for just graphics
applications like Google Body,

00:11:24.040 --> 00:11:25.590
I think Java is fast enough.

00:11:25.590 --> 00:11:26.700
You're just pushing
data through the

00:11:26.700 --> 00:11:28.490
graphics card anyway.

00:11:28.490 --> 00:11:31.710
And Java is kind of like, the
better paved way to write

00:11:31.710 --> 00:11:33.470
Android applications.

00:11:33.470 --> 00:11:34.930
So Google Body is
written in Java.

00:11:34.930 --> 00:11:39.870
And my plan is to port it to
2.3 first and then if stuff

00:11:39.870 --> 00:11:43.640
works there reasonably well then
get it working on 2.2 and

00:11:43.640 --> 00:11:45.020
maybe eventually onto 1.

00:11:47.770 --> 00:11:51.635
I think no new project should
use OpenGL ES1.

00:11:51.635 --> 00:11:55.110
I think 90% of all phones
support OpenGL ES2.0.

00:11:55.110 --> 00:11:57.210
All new phones support it.

00:11:57.210 --> 00:11:59.665
And if you feel that you really
want to support the

00:11:59.665 --> 00:12:03.250
last 10% that don't support the
OpenGL ES2 these phones

00:12:03.250 --> 00:12:04.860
are also pretty slow.

00:12:04.860 --> 00:12:07.250
Weak CPUs, weak RAM.

00:12:07.250 --> 00:12:10.460
So you probably are writing a
second, lo-res version of the

00:12:10.460 --> 00:12:12.390
app anyway.

00:12:12.390 --> 00:12:16.180
So I think every new app
should go OpenGL ES2.

00:12:16.180 --> 00:12:21.010
So let's take a little look at
how you actually do this.

00:12:21.010 --> 00:12:24.110
So the class that does OpenGL
rendering in Android is

00:12:24.110 --> 00:12:25.360
GLSurfaceView.

00:12:26.960 --> 00:12:29.170
And actually it's pretty
easy to use.

00:12:29.170 --> 00:12:32.940
In your activity and your
onCreate method, you just

00:12:32.940 --> 00:12:35.380
create a GLSurfaceView.

00:12:35.380 --> 00:12:38.100
And then you say,
setEGLContentClientVersion to

00:12:38.100 --> 00:12:41.460
inform the view that you want
to use ES 2.0, which has the

00:12:41.460 --> 00:12:44.340
programmable shaders
and all that.

00:12:44.340 --> 00:12:47.610
And then you set a render
object, which is your own

00:12:47.610 --> 00:12:48.920
class that implements

00:12:48.920 --> 00:12:50.650
GLSurfaceView.render interface.

00:12:50.650 --> 00:12:52.890
We'll get to that in a second.

00:12:52.890 --> 00:12:55.580
And then you also forward on
parse and on resume to the

00:12:55.580 --> 00:12:57.680
view so that when your
application goes in the

00:12:57.680 --> 00:13:01.440
background it stops rendering
and that stuff.

00:13:01.440 --> 00:13:03.660
So that's all you have to
do in your activity.

00:13:03.660 --> 00:13:08.890
Then in your manifest you just
add uses-feature ES Version

00:13:08.890 --> 00:13:11.290
2.0, require true.

00:13:11.290 --> 00:13:17.050
And that way the market knows
that the application requires

00:13:17.050 --> 00:13:19.460
OpenGL ES2 and it will only
show it to phones

00:13:19.460 --> 00:13:21.710
that support that.

00:13:21.710 --> 00:13:25.030
And finally you need to write
your own little renderer.

00:13:25.030 --> 00:13:28.530
So if you're using OpenGL
ES2 you call static

00:13:28.530 --> 00:13:30.870
functions on GLES20.

00:13:30.870 --> 00:13:33.640
So I recommend doing an
import static for

00:13:33.640 --> 00:13:34.290
everything in there.

00:13:34.290 --> 00:13:37.950
And then you can just so normal
OpenGL calls like you

00:13:37.950 --> 00:13:39.530
used to do that in
other languages.

00:13:39.530 --> 00:13:44.200
So you don't have to do GLES20
dot GLClear or whatever.

00:13:44.200 --> 00:13:46.970
You can just write GLClear.

00:13:46.970 --> 00:13:50.000
And this interface has
three methods.

00:13:50.000 --> 00:13:54.820
One is on surface created,
which is called when your

00:13:54.820 --> 00:13:57.190
context is first created and
then a couple more times.

00:13:57.190 --> 00:13:58.390
We'll get to that in a second.

00:13:58.390 --> 00:14:01.640
And there's onDrawFrame, which
is called every time you

00:14:01.640 --> 00:14:03.060
should render.

00:14:03.060 --> 00:14:07.890
By default this is called 60
times per second [? GLE. ?]

00:14:07.890 --> 00:14:09.990
But you can also tell the
system to only draw

00:14:09.990 --> 00:14:11.200
your view on demand.

00:14:11.200 --> 00:14:15.340
And there's onSurfaceChange,
which is not very interesting

00:14:15.340 --> 00:14:17.360
in practice.

00:14:17.360 --> 00:14:24.400
So I'd like to do a tiny demo of
how this looks in practice.

00:14:24.400 --> 00:14:28.810
Coworkers inform me that it's
too risky to go switch back to

00:14:28.810 --> 00:14:30.270
Eclipse for demo.

00:14:30.270 --> 00:14:33.070
So I'll just do this
right on my slide.

00:14:33.070 --> 00:14:39.710
So onSurfaceCreated will do
GLClear, color, and a line--

00:14:43.410 --> 00:14:44.660
some redder shade of gray.

00:14:47.050 --> 00:14:51.235
And I'll also call the view to
not draw at 60 frames per

00:14:51.235 --> 00:14:55.700
second but only when needed.

00:15:01.030 --> 00:15:03.615
And in here we'll just
clear the background.

00:15:10.420 --> 00:15:14.430
If I click this run button,
hopefully the code will be

00:15:14.430 --> 00:15:16.900
copied into some Java file in
the background and then

00:15:16.900 --> 00:15:19.870
uploaded to the tablet.

00:15:19.870 --> 00:15:20.505
So it still says compiling.

00:15:20.505 --> 00:15:21.755
So it says uploading.

00:15:23.940 --> 00:15:25.470
Let's switch to the other box.

00:15:28.220 --> 00:15:30.900
Now I just opened the
IO OpenGL app.

00:15:30.900 --> 00:15:34.460
I switched slightly too slowly
to see it starting.

00:15:34.460 --> 00:15:37.960
And that hardware makes an
accelerated flashlight app.

00:15:37.960 --> 00:15:39.580
So, mission accomplished.

00:15:46.640 --> 00:15:49.260
No, at just one frame because
it's when dirty.

00:15:52.530 --> 00:15:56.060
So that's the OpenGL Hello
world, I guess.

00:15:56.060 --> 00:15:59.780
And that's about 20 lines.

00:15:59.780 --> 00:16:02.270
Not too bad.

00:16:02.270 --> 00:16:04.945
So one cool thing that
GLSurfaceView gives you is

00:16:04.945 --> 00:16:07.200
that it creates an educated
renderer thread for you.

00:16:07.200 --> 00:16:11.590
All the GL stuff will execute
on the renderer thread.

00:16:11.590 --> 00:16:14.330
Which means that if your UI
thread is overloaded, you

00:16:14.330 --> 00:16:15.920
still have smooth rendering.

00:16:15.920 --> 00:16:18.940
And if your rendering is kind
of slow, your app is still

00:16:18.940 --> 00:16:22.580
responsive to tap events
and all that.

00:16:22.580 --> 00:16:25.780
So one thing that you need to
do every now and then is to

00:16:25.780 --> 00:16:28.530
relay an event from the UI
thread to the OpenGL thread.

00:16:28.530 --> 00:16:32.830
Because UI land and GL land are
kind of single threaded,

00:16:32.830 --> 00:16:35.510
so every OpenGL call has to
be done on the GL thread.

00:16:35.510 --> 00:16:38.531
Every UI call has to be
done on the UI thread.

00:16:38.531 --> 00:16:41.470
So for example, on click, I
guess that should be on touch

00:16:41.470 --> 00:16:43.650
or something like that.

00:16:43.650 --> 00:16:47.140
When on touch is called on your
UI thread, you might want

00:16:47.140 --> 00:16:49.350
to tell the renderer to draw--

00:16:49.350 --> 00:16:51.345
I don't know-- a particle system
at the touch location

00:16:51.345 --> 00:16:52.430
or something.

00:16:52.430 --> 00:16:55.270
So you need to somehow relay the
event from the UI thread

00:16:55.270 --> 00:16:56.155
to the renderer.

00:16:56.155 --> 00:16:57.940
So the way you do this,
you just call

00:16:57.940 --> 00:17:01.600
.queueEvent on the GL view.

00:17:01.600 --> 00:17:03.110
And pass a Runnable.

00:17:03.110 --> 00:17:06.420
And then this will be executed
on the GL thread.

00:17:09.339 --> 00:17:13.200
So if you want to, for example,
access item in here,

00:17:13.200 --> 00:17:15.880
then Java has this mutation
that int has to be final.

00:17:15.880 --> 00:17:18.240
So you just put a
final in there.

00:17:18.240 --> 00:17:21.349
And then you can just use item
in here on the other thread.

00:17:21.349 --> 00:17:27.119
One little pitfall there is, if
you want use a class that's

00:17:27.119 --> 00:17:29.440
passed in, for example on a
touch event, and you just do

00:17:29.440 --> 00:17:30.890
final touch event event.

00:17:30.890 --> 00:17:32.690
And then use event down here.

00:17:32.690 --> 00:17:36.210
And then by the time the GL
thread executes the runnable,

00:17:36.210 --> 00:17:38.090
the UI thread has already
reused the

00:17:38.090 --> 00:17:39.530
touch event up here.

00:17:39.530 --> 00:17:41.010
Changed it internally
and passed it on

00:17:41.010 --> 00:17:42.280
to a different view.

00:17:42.280 --> 00:17:45.330
Because the UI thread reuses
objects so it doesn't allocate

00:17:45.330 --> 00:17:47.180
memory all that much.

00:17:47.180 --> 00:17:51.080
So by the time your renderer
looks at the touch event

00:17:51.080 --> 00:17:54.260
object, the data is all
wrong for you to use.

00:17:54.260 --> 00:17:57.640
So you should make a copy of all
parameters and then have a

00:17:57.640 --> 00:18:01.530
final local variable and use
that in the runnable.

00:18:01.530 --> 00:18:03.610
The other direction from the
renderer thread to the UI

00:18:03.610 --> 00:18:06.910
thread isn't needed
all that often.

00:18:06.910 --> 00:18:09.660
Just for completeness you can
do activity dot run on UI

00:18:09.660 --> 00:18:12.580
thread and pass in the runnable
and then this is

00:18:12.580 --> 00:18:15.300
executed in the UI thread.

00:18:15.300 --> 00:18:18.680
In Body I used this, for
example, when you would touch

00:18:18.680 --> 00:18:23.050
muscles, I need to see what
muscle was tapped.

00:18:23.050 --> 00:18:27.300
And so I basically render the
polygons in some made up

00:18:27.300 --> 00:18:29.920
colors and then I read the
screen and see what color was

00:18:29.920 --> 00:18:35.870
below the finger and then have
them mapping colors to objects

00:18:35.870 --> 00:18:39.060
and then tell the UI thread,
this thing was touched.

00:18:43.720 --> 00:18:45.900
Use GLSurfaceView.

00:18:45.900 --> 00:18:46.810
My advice.

00:18:46.810 --> 00:18:50.630
That makes happy Android for
that, which is, I guess, kind

00:18:50.630 --> 00:18:52.575
of like a gold star.

00:18:52.575 --> 00:18:53.690
It's very easy to use.

00:18:53.690 --> 00:18:56.102
It gives you a dedicated
renderer thread for free and

00:18:56.102 --> 00:18:58.240
it's very well tested.

00:18:58.240 --> 00:19:01.310
So some people on the internet
recommend that you run your

00:19:01.310 --> 00:19:04.960
own little surface
holder thing.

00:19:04.960 --> 00:19:07.590
For example, Chris Pruett, who
talked here earlier today, has

00:19:07.590 --> 00:19:10.250
an open source game called
Replica island and he has his

00:19:10.250 --> 00:19:13.150
own GlSurfaceView fork.

00:19:13.150 --> 00:19:17.840
And he has one screen full of
comments about something that

00:19:17.840 --> 00:19:18.430
went wrong.

00:19:18.430 --> 00:19:22.930
Like, a few graphics drivers
misbehaved under very specific

00:19:22.930 --> 00:19:26.850
circumstances and it took him
two weeks to track that down.

00:19:26.850 --> 00:19:29.890
So don't be Chris Pruett.

00:19:29.890 --> 00:19:31.140
Use GLSurfaceView.

00:19:33.680 --> 00:19:35.340
A little word of
warning though.

00:19:35.340 --> 00:19:37.850
GLSurfaceView loses its OpenGL
context very often.

00:19:37.850 --> 00:19:42.380
So every time you call onPause
it'll forget all OpenGL state,

00:19:42.380 --> 00:19:45.810
like uploaded pictures
and so on.

00:19:45.810 --> 00:19:52.220
It'll call onCreate on your
renderer object and then you

00:19:52.220 --> 00:19:54.350
need to re-upload all your
pictures and so on and that

00:19:54.350 --> 00:19:55.040
can be slow.

00:19:55.040 --> 00:19:59.730
So make that fast. If you're
talking 3.0 or later you can

00:19:59.730 --> 00:20:00.980
call types
setPreserveEGLContextOnPause.

00:20:03.260 --> 00:20:05.450
But if your device supports only
one OpenGL context and

00:20:05.450 --> 00:20:08.000
the user switches to another
app that uses OpenGL and he

00:20:08.000 --> 00:20:10.720
switches back to your app then
your stuff is gone anyway.

00:20:10.720 --> 00:20:16.410
So make loading your data is
the lesson here, I guess.

00:20:16.410 --> 00:20:21.610
Alright so that's basically
the OpenGL Hello world.

00:20:21.610 --> 00:20:27.500
Here's a very high level picture
about how GPUs work.

00:20:27.500 --> 00:20:31.920
So up there there's the CPU,
which executes your Java code.

00:20:31.920 --> 00:20:36.160
And then there's this OpenGL
API, where all the data that

00:20:36.160 --> 00:20:39.130
needs to be rendered needs
to be pushed through.

00:20:39.130 --> 00:20:43.150
And then the data ends up
in graphics memory here.

00:20:43.150 --> 00:20:46.290
And then the GPU reads
vertically to there, runs

00:20:46.290 --> 00:20:49.540
vertex shaders, rasterizes all
the varyings, sends them

00:20:49.540 --> 00:20:52.090
through the fragment processor,
which runs all your

00:20:52.090 --> 00:20:53.350
fragment shaders.

00:20:53.350 --> 00:20:54.680
And that's written to
the frame buffer.

00:20:57.730 --> 00:20:59.810
So as I said, this is
very simplistic.

00:20:59.810 --> 00:21:01.310
There's no planning
stage in here.

00:21:01.310 --> 00:21:05.970
On some GPUs, vertex processors
and fragment

00:21:05.970 --> 00:21:07.014
processors are executed
on the same

00:21:07.014 --> 00:21:08.770
silicon and thus is shared.

00:21:08.770 --> 00:21:12.910
But basically my point is, you
want to send not a lot of data

00:21:12.910 --> 00:21:18.430
over this bus because
that's very slow.

00:21:18.430 --> 00:21:22.770
And also many GPUs cache vertex
data pre-transform,

00:21:22.770 --> 00:21:24.770
post-transform, they
cache textures.

00:21:27.550 --> 00:21:29.650
So to make these cache
efficiently, you also want to

00:21:29.650 --> 00:21:30.900
keep your data very small.

00:21:34.540 --> 00:21:36.190
and if it And that's basically
how GPUs work.

00:21:36.190 --> 00:21:38.260
Now you know.

00:21:38.260 --> 00:21:41.010
My point basically is, don't
send lots of data to the GPU

00:21:41.010 --> 00:21:42.440
on every frame.

00:21:42.440 --> 00:21:45.480
And if you do, then don't do
it in many small calls.

00:21:45.480 --> 00:21:47.580
Just do big, bursty calls.

00:21:47.580 --> 00:21:49.700
So here's a piece of
OpenGL 101 that I

00:21:49.700 --> 00:21:52.890
think everyone knows.

00:21:52.890 --> 00:21:57.470
If you do GLTexImage2D with a
texture data at the end to

00:21:57.470 --> 00:21:59.140
basically set the current
texture and then you draw your

00:21:59.140 --> 00:22:00.815
model, then this will
upload the current

00:22:00.815 --> 00:22:02.460
texture every frame.

00:22:02.460 --> 00:22:06.440
And that's expensive,
so don't do that.

00:22:06.440 --> 00:22:11.170
Instead, in your own surface
creator method, you create an

00:22:11.170 --> 00:22:15.380
identifier for the texture,
which is just an int.

00:22:15.380 --> 00:22:17.420
You tell OpenGL make this,
make texture--

00:22:17.420 --> 00:22:18.820
I don't know-- number
five current.

00:22:18.820 --> 00:22:21.860
Then you upload the data once
into texture number five.

00:22:21.860 --> 00:22:24.480
And then in your onDraw
method you just find

00:22:24.480 --> 00:22:25.750
texture number five once.

00:22:25.750 --> 00:22:27.690
And then you call
it raw model.

00:22:27.690 --> 00:22:29.120
So everybody knows that.

00:22:29.120 --> 00:22:32.510
I'm saying this because nearly
the same is true for vertex

00:22:32.510 --> 00:22:37.830
buffer objects later and it's
not as well known there.

00:22:37.830 --> 00:22:40.170
You should also use texture
compression.

00:22:40.170 --> 00:22:43.960
So ETC, which is short for
Ericsson Texture Compression.

00:22:43.960 --> 00:22:47.220
So what the heading says
is use Ericcson Texture

00:22:47.220 --> 00:22:48.796
Compression for RGB texture
compression.

00:22:51.410 --> 00:22:54.410
An extension to OpenGL ES2
that's supported on virtually

00:22:54.410 --> 00:22:56.560
all devices out there.

00:22:56.560 --> 00:22:59.300
Or on all devices
that I know of.

00:22:59.300 --> 00:23:03.230
And if you use ETC even every
pixel need only four bits,

00:23:03.230 --> 00:23:04.120
effectively.

00:23:04.120 --> 00:23:06.160
So that's compared to
16 bits per pixel.

00:23:06.160 --> 00:23:09.634
That's a 75% memory win.

00:23:09.634 --> 00:23:13.560
And sadly, iPhone, this isn't
documented very well.

00:23:13.560 --> 00:23:14.610
So I didn't know about this.

00:23:14.610 --> 00:23:16.600
So I launched Google Body
without doing this.

00:23:16.600 --> 00:23:18.910
Then I read about this, enabled
texture compression

00:23:18.910 --> 00:23:22.520
and that saved, like, 10
megabytes of Ram, which is

00:23:22.520 --> 00:23:23.770
quite a bit.

00:23:26.460 --> 00:23:30.140
So there's this binary ETC 1
tool in the Android SDK tools

00:23:30.140 --> 00:23:33.210
folder that I didn't
know about.

00:23:33.210 --> 00:23:37.050
So when I used this the first
time I did a web search for

00:23:37.050 --> 00:23:40.010
ETC 1 compression and I found
some binary on some Erikson

00:23:40.010 --> 00:23:43.760
website that ran only on Windows
and concluded the

00:23:43.760 --> 00:23:46.520
source code didn't build
on MacOS so I patched

00:23:46.520 --> 00:23:48.500
that and used this.

00:23:48.500 --> 00:23:51.470
Turns out there's a binary
in the Android SDK.

00:23:51.470 --> 00:23:53.500
It's just nobody tells you.

00:23:53.500 --> 00:23:59.590
Nobody told me, at least.
And if you then add

00:23:59.590 --> 00:24:01.800
supports-gl-texture to your
manifest, then the market

00:24:01.800 --> 00:24:04.220
knows about this.

00:24:04.220 --> 00:24:05.320
And the Android is happy again.

00:24:05.320 --> 00:24:06.570
Hooray.

00:24:08.600 --> 00:24:10.840
And it's very easy
to load textures.

00:24:10.840 --> 00:24:14.330
So on your I/O thread you just
do ETC1utilcreatetexture and

00:24:14.330 --> 00:24:18.490
pass in input stream.

00:24:18.490 --> 00:24:22.260
And then on your GL thread, this
loads the texture into

00:24:22.260 --> 00:24:26.760
memory and then on your GL
thread you can upload this.

00:24:26.760 --> 00:24:29.670
Obviously you never want to do
I/O on the UI thread or the GL

00:24:29.670 --> 00:24:33.835
thread because I/O can be
unpredictable and might just

00:24:33.835 --> 00:24:37.270
take 100 milliseconds and you
don't want your UI or your

00:24:37.270 --> 00:24:39.140
rendering to stutter, so you
should always have a

00:24:39.140 --> 00:24:40.390
dedicated UI thread.

00:24:44.160 --> 00:24:46.320
One small word of warning.

00:24:46.320 --> 00:24:49.415
If the width or the height is
not a multiple of four, then

00:24:49.415 --> 00:24:53.700
the PowerVR GPUs just display
noise for your texture.

00:24:53.700 --> 00:24:55.415
So for example, PowerVR
is used on

00:24:55.415 --> 00:24:57.310
the Nexus S for example.

00:24:57.310 --> 00:25:00.130
In practice that's not a huge
problem because most textures

00:25:00.130 --> 00:25:01.740
are power of two sized anyway.

00:25:01.740 --> 00:25:05.270
And most powers of two are
also multiples of four.

00:25:05.270 --> 00:25:09.584
And for heads-up displays, you
can make your texture sizes a

00:25:09.584 --> 00:25:10.180
multiple of four.

00:25:10.180 --> 00:25:12.960
Something to keep in mind.

00:25:12.960 --> 00:25:14.480
So now we know how to
upload textures.

00:25:14.480 --> 00:25:17.750
Now the same for geometry.

00:25:17.750 --> 00:25:19.630
So same thing as for
textures, if you do

00:25:19.630 --> 00:25:22.540
glvertexAttribPointer and pass
the attrib data in the last

00:25:22.540 --> 00:25:27.350
parameter here, then this
uploads all the

00:25:27.350 --> 00:25:28.960
vertex data to the GPU.

00:25:28.960 --> 00:25:31.760
And if you do this on every
frame, then you are copying

00:25:31.760 --> 00:25:32.610
lots of data around.

00:25:32.610 --> 00:25:34.400
So don't do that.

00:25:34.400 --> 00:25:37.260
And this is, for some reason,
less well known.

00:25:37.260 --> 00:25:42.170
The OpenGL ES2.0 example and
Android SDK does this.

00:25:42.170 --> 00:25:45.380
So don't look at that example.

00:25:45.380 --> 00:25:51.720
I guess the excuse is OpenGL
ES1 only supported this way

00:25:51.720 --> 00:25:56.020
and they haven't updated this
since then, I guess.

00:25:56.020 --> 00:25:59.450
So instead, just like with
textures, you create a numeric

00:25:59.450 --> 00:26:01.240
ID then you bind this.

00:26:01.240 --> 00:26:04.560
So Array_BUFFER is used for
attributator like positions,

00:26:04.560 --> 00:26:05.110
normal [UNINTELLIGIBLE]

00:26:05.110 --> 00:26:06.350
coordinates.

00:26:06.350 --> 00:26:09.500
And then you do GL Buffer
data with your data.

00:26:09.500 --> 00:26:11.282
And the same for the indices.

00:26:15.080 --> 00:26:18.790
Then at run time you just bind
the array buffer and the

00:26:18.790 --> 00:26:21.000
element array buffer.

00:26:21.000 --> 00:26:25.890
And you pass zero for the last
parameter instead of data.

00:26:25.890 --> 00:26:27.780
And that's way faster.

00:26:27.780 --> 00:26:30.590
So it's quite faster.

00:26:30.590 --> 00:26:32.840
So two things to keep
in mind here.

00:26:32.840 --> 00:26:35.470
One is you need to have this
attrib data and this index

00:26:35.470 --> 00:26:37.490
data somehow.

00:26:37.490 --> 00:26:40.040
And these need to be direct
ByteBuffers, which I'll talk

00:26:40.040 --> 00:26:41.810
about in a second.

00:26:41.810 --> 00:26:45.230
And then, as I said, in call GL
Vertex attrib pointer with

00:26:45.230 --> 00:26:47.210
a zero back here and
GL draw elements

00:26:47.210 --> 00:26:48.740
with a zero back here.

00:26:48.740 --> 00:26:55.050
And if you run this on FroYo,
your application will crash.

00:26:55.050 --> 00:26:57.570
And the reason for that is that
they forgot to add the

00:26:57.570 --> 00:27:00.550
bindings for these
two method calls.

00:27:00.550 --> 00:27:01.750
So it compiles just fine.

00:27:01.750 --> 00:27:05.760
But at run time, when Android
tries to call the c method

00:27:05.760 --> 00:27:10.110
that backs this OpenGL draw,
it doesn't find anything.

00:27:10.110 --> 00:27:12.680
Which is a bit annoying but
it's pretty easy to fix.

00:27:12.680 --> 00:27:14.830
You basically need to add
your own bindings

00:27:14.830 --> 00:27:17.170
for these two functions.

00:27:17.170 --> 00:27:19.930
So if you're familiar with the
NDK, that's pretty easy and if

00:27:19.930 --> 00:27:21.540
not then I guess it's
kind of magic.

00:27:21.540 --> 00:27:24.410
You just copy paste
and you're done.

00:27:24.410 --> 00:27:27.630
Who here has used the NDK?

00:27:27.630 --> 00:27:28.970
Not many people.

00:27:28.970 --> 00:27:34.220
OK, basically what you do is you
create a normal Java class

00:27:34.220 --> 00:27:35.590
and then you put your
method there.

00:27:35.590 --> 00:27:37.760
But instead of putting
implementation there you put

00:27:37.760 --> 00:27:39.580
native in front.

00:27:39.580 --> 00:27:42.360
And this tells Java that
this method exists.

00:27:42.360 --> 00:27:45.460
It takes these parameters and
that it should look somewhere

00:27:45.460 --> 00:27:46.510
else for the implementation.

00:27:46.510 --> 00:27:48.150
It's not implemented in Java.

00:27:48.150 --> 00:27:50.780
And the same for the other
function that's missing.

00:27:50.780 --> 00:27:56.030
And then you do a system dot
load library down here in the

00:27:56.030 --> 00:27:57.280
static initializer.

00:27:59.320 --> 00:28:03.330
And then this is something
you write with the NDK.

00:28:03.330 --> 00:28:07.730
So you create a jni subfolder in
your project and you paste

00:28:07.730 --> 00:28:10.460
in this bit of code.

00:28:10.460 --> 00:28:13.210
So there's a function with this
weird naming convention--

00:28:13.210 --> 00:28:16.990
Java_com_example
_io_GLE20Fix_glDrawElements.

00:28:16.990 --> 00:28:18.810
And Java uses this
function name to

00:28:18.810 --> 00:28:21.090
associate it with a class.

00:28:21.090 --> 00:28:23.420
So it starts with Java then
it has the package name,

00:28:23.420 --> 00:28:24.690
com.example.io.

00:28:24.690 --> 00:28:28.280
Then it has the class name and
then it has the method name.

00:28:28.280 --> 00:28:31.470
In here you put the
implementation of your method.

00:28:31.470 --> 00:28:34.340
So the first two parameters
of jnimethod are always

00:28:34.340 --> 00:28:38.540
jnin and jclass c.

00:28:38.540 --> 00:28:41.690
And then the rest are the
parameters from the functions.

00:28:41.690 --> 00:28:45.260
So this is int, int, int,
int just like here,

00:28:45.260 --> 00:28:48.000
int, int, int, int.

00:28:48.000 --> 00:28:49.730
Only with a j in front.

00:28:49.730 --> 00:28:52.370
So JNI is Java Native Interface,
which is basically

00:28:52.370 --> 00:28:55.190
the technology you use
to call C from Java.

00:28:55.190 --> 00:28:56.600
And then we just call
the C function

00:28:56.600 --> 00:28:58.810
for our GL Draw elements.

00:28:58.810 --> 00:29:03.410
And exactly the same for
vertex attrib pointer.

00:29:03.410 --> 00:29:06.445
And then you copy this
android.mk file, put that also

00:29:06.445 --> 00:29:09.870
in your JNI folder.

00:29:09.870 --> 00:29:12.080
Go into that folder and then
you call NDK build from the

00:29:12.080 --> 00:29:15.930
NDK and this will create
some library.

00:29:15.930 --> 00:29:18.060
And then you do a clean build in
Eclipse, which will pick up

00:29:18.060 --> 00:29:21.250
that library and copy it into
your APK and then you can call

00:29:21.250 --> 00:29:28.020
GLE20Fix_glDrawElements and
then that works on FroYo.

00:29:28.020 --> 00:29:31.270
So that's that.

00:29:31.270 --> 00:29:35.060
Let me say a few words about
filling ByteBuffers.

00:29:35.060 --> 00:29:37.720
So ByteBuffers are the things
that you pass through GL

00:29:37.720 --> 00:29:39.610
Buffer data.

00:29:39.610 --> 00:29:41.920
And it's basically a block
of raw C memory.

00:29:41.920 --> 00:29:43.120
So if you're not
familiar with--

00:29:43.120 --> 00:29:44.100
Who here knows C?

00:29:44.100 --> 00:29:46.800
Are the same people who
used the NDK, roughly.

00:29:46.800 --> 00:29:47.740
No surprise.

00:29:47.740 --> 00:29:51.170
So Java obviously has
managed memory.

00:29:51.170 --> 00:29:52.950
C doesn't.

00:29:52.950 --> 00:29:55.755
And in some JVMs, these
memories live

00:29:55.755 --> 00:29:58.860
in different areas.

00:29:58.860 --> 00:30:03.730
And OpenGL needs to have the raw
C memory, for some reason.

00:30:03.730 --> 00:30:05.200
You just need to know you
need to use direct

00:30:05.200 --> 00:30:06.570
ByteBuffers for that.

00:30:06.570 --> 00:30:10.260
And it turns out, doing
element-wise access on these

00:30:10.260 --> 00:30:12.140
is pretty slow.

00:30:12.140 --> 00:30:13.870
So you get a ByteBuffer
by doing

00:30:13.870 --> 00:30:19.310
ByteBuffer.allocatedirect
and then some size.

00:30:19.310 --> 00:30:22.440
And then if you want to load
data from a resource into a

00:30:22.440 --> 00:30:25.240
direct ByteBuffer, don't just
get the input stream and

00:30:25.240 --> 00:30:27.520
element-wise put stuff.

00:30:27.520 --> 00:30:29.820
Basically don't read one byte
from the input stream and put

00:30:29.820 --> 00:30:32.150
it into the direct ByteBuffer.

00:30:32.150 --> 00:30:33.740
This is very slow
for some reason.

00:30:33.740 --> 00:30:36.210
Behind the scenes this does
several method calls.

00:30:36.210 --> 00:30:38.990
One JNI hop and so on.

00:30:38.990 --> 00:30:41.290
It's much better to
do this in blocks.

00:30:41.290 --> 00:30:45.480
So in Body I think I used four
kilobyte code blocks.

00:30:45.480 --> 00:30:49.481
And this sped up loading
by, I think, 8 seconds.

00:30:49.481 --> 00:30:55.445
So it's still a bit slow, but
it's done in in parallel so

00:30:55.445 --> 00:30:57.180
that's fine.

00:30:57.180 --> 00:31:00.700
And you can do even better than
that if you are willing

00:31:00.700 --> 00:31:03.030
to make some compromises.

00:31:03.030 --> 00:31:06.640
So as you might know, APK files
are just Zip files.

00:31:06.640 --> 00:31:12.570
And if you give your resources
some magic extensions, your

00:31:12.570 --> 00:31:14.180
resources won't be compressed
in the zip file.

00:31:14.180 --> 00:31:16.560
They will just be an
uncompressed part of the zip

00:31:16.560 --> 00:31:16.870
file somewhere.

00:31:16.870 --> 00:31:20.830
So for example, PNGs and JPGs
are compressed already, so

00:31:20.830 --> 00:31:23.070
they aren't recompressed
again.

00:31:23.070 --> 00:31:26.560
And also the extension, JET,
is one of these magic

00:31:26.560 --> 00:31:27.070
extensions.

00:31:27.070 --> 00:31:29.170
I have no idea what file format
this actually is.

00:31:29.170 --> 00:31:31.680
But if I want to have a resource
that's not compressed

00:31:31.680 --> 00:31:34.350
I call it dot JET and put it in
my response folder and then

00:31:34.350 --> 00:31:36.270
it's not compressed.

00:31:36.270 --> 00:31:38.960
And the cool thing about
uncompressed resourced is that

00:31:38.960 --> 00:31:42.220
they are basically just a
chunk of your APK file.

00:31:42.220 --> 00:31:46.180
And you can get a file
handle through that.

00:31:46.180 --> 00:31:50.215
You begin to get a sense that
openfd, which gives you a set

00:31:50.215 --> 00:31:52.460
file descriptor from which you
can get a file input stream

00:31:52.460 --> 00:31:54.500
instead of just an
input stream.

00:31:54.500 --> 00:31:57.680
And from a file input stream you
can then get a channel and

00:31:57.680 --> 00:32:00.640
channel you can mmap.

00:32:00.640 --> 00:32:02.870
And mmap returns a
MappedByteBuffer and

00:32:02.870 --> 00:32:05.250
MappedByteBuffers are
always direct.

00:32:05.250 --> 00:32:08.830
So in this case no conversions
at all have to be done.

00:32:08.830 --> 00:32:12.350
You can just use this and pass
this through GL buffer data.

00:32:12.350 --> 00:32:14.690
And this is another 10x
or so faster than

00:32:14.690 --> 00:32:17.020
the previous thing.

00:32:17.020 --> 00:32:20.060
So if you're willing to not to
compress your resources you

00:32:20.060 --> 00:32:22.300
can have really, rally fast
loading this way.

00:32:26.640 --> 00:32:28.440
So a small word of warning.

00:32:28.440 --> 00:32:31.400
ByteBuffer dot allocateDirect
allocates more memory than you

00:32:31.400 --> 00:32:32.550
tell it to.

00:32:32.550 --> 00:32:35.970
So if you just do a tiny test
program that does ByteBuffer

00:32:35.970 --> 00:32:39.930
dot allocateDirect with 15
megabytes and then look at

00:32:39.930 --> 00:32:41.750
Lock Add and Lock Add
will tell you I paid

00:32:41.750 --> 00:32:43.560
to allocate 60 megabytes.

00:32:43.560 --> 00:32:46.550
So it overallocates by
a factor of four.

00:32:46.550 --> 00:32:50.210
Which is an Android bug that's
being fixed, I think.

00:32:50.210 --> 00:32:53.840
But not yet.

00:32:53.840 --> 00:32:56.520
So keep your buffers
small, I guess.

00:32:56.520 --> 00:33:00.320
In Google Body if you look at
the market page, there are two

00:33:00.320 --> 00:33:02.450
one-star comments that tell
you this app is crap.

00:33:02.450 --> 00:33:04.880
It's crashes all the time.

00:33:04.880 --> 00:33:06.890
And that was because
of this bug.

00:33:06.890 --> 00:33:09.480
Basically when Body was loading
and people pressed on

00:33:09.480 --> 00:33:11.490
the screen, a lot of time.

00:33:11.490 --> 00:33:14.530
So as I said, to do touch
detection i basically rendered

00:33:14.530 --> 00:33:17.910
the whole scene into
a back buffer.

00:33:17.910 --> 00:33:20.750
And I created an off-screen
buffer for the whole screen,

00:33:20.750 --> 00:33:24.080
which is about a
million pixels.

00:33:24.080 --> 00:33:26.330
And then two bytes per pixel for
color, two bytes per pixel

00:33:26.330 --> 00:33:27.417
for that buffer.

00:33:27.417 --> 00:33:29.960
So that's about four
megabytes.

00:33:29.960 --> 00:33:32.275
With over allocation by 4x
that's 15 megabytes.

00:33:32.275 --> 00:33:34.160
And if loadings going
on in parallel,

00:33:34.160 --> 00:33:35.110
that's too much memory.

00:33:35.110 --> 00:33:37.860
So Body crashed with
out of memory.

00:33:37.860 --> 00:33:41.130
And I fixed that by not
rendering the whole screen

00:33:41.130 --> 00:33:43.620
into back buffer but only
the 20x20 pixels

00:33:43.620 --> 00:33:44.870
around the touch event.

00:33:47.320 --> 00:33:50.150
So just something
to keep in mind.

00:33:50.150 --> 00:33:52.800
And one thing that I also
learned is that, if you don't

00:33:52.800 --> 00:33:55.030
have many users and you get
two one-star ratings, that

00:33:55.030 --> 00:33:56.280
really hurts.

00:33:58.920 --> 00:34:03.370
I used to have a 4.5 average
and then then it went down.

00:34:03.370 --> 00:34:04.620
Tough times.

00:34:06.850 --> 00:34:10.389
Another pitfall: compressed
files can be,

00:34:10.389 --> 00:34:11.150
at most, one megabyte.

00:34:11.150 --> 00:34:14.330
And uncompressed
on Android 2.2.

00:34:14.330 --> 00:34:16.690
And the reason that is, I guess,
is because the Android

00:34:16.690 --> 00:34:19.370
guys have a static buffer that's
one megabyte that they

00:34:19.370 --> 00:34:20.550
use to uncompress in.

00:34:20.550 --> 00:34:24.000
And if the uncompressed size is
larger than that they say,

00:34:24.000 --> 00:34:26.540
sorry you can't do that.

00:34:26.540 --> 00:34:30.380
So the things you can do there
are, split your files into one

00:34:30.380 --> 00:34:31.699
megabytes chunks.

00:34:31.699 --> 00:34:34.739
Which kind of sucks, so
I wouldn't do that.

00:34:34.739 --> 00:34:37.480
Or you can basically use
uncompressed resources.

00:34:37.480 --> 00:34:39.530
And then if you really need
the compression you can

00:34:39.530 --> 00:34:42.480
compress them yourself and
uncompress them yourself and

00:34:42.480 --> 00:34:44.750
you can be smarter than the
Android guys and use.

00:34:49.210 --> 00:34:52.150
I hope everybody knows how
to write a decompressor.

00:34:52.150 --> 00:34:54.730
Or how to use zlib, which does
the decompression for you but

00:34:54.730 --> 00:34:57.230
don't have a static
max size buffer.

00:34:57.230 --> 00:34:58.480
So they fixed that in 2.3.

00:35:02.880 --> 00:35:05.460
And that's that about
ByteBuffer.

00:35:05.460 --> 00:35:07.680
So that's already our
last section.

00:35:07.680 --> 00:35:10.510
We're doing fantastic on time.

00:35:10.510 --> 00:35:13.785
So I'd like to say a few words
about performance here.

00:35:13.785 --> 00:35:16.950
The first word is measure.

00:35:16.950 --> 00:35:19.680
So if you're trying to do
performance improvements,

00:35:19.680 --> 00:35:21.500
always measure if they actually
help and if they

00:35:21.500 --> 00:35:24.790
don't then don't do them.

00:35:24.790 --> 00:35:26.590
And I have a little
demo for that.

00:35:29.640 --> 00:35:32.010
About a little pitfall, I guess,
when you're measuring

00:35:32.010 --> 00:35:34.350
performance, that I found.

00:35:34.350 --> 00:35:40.170
So this little program here,
basically just clears the

00:35:40.170 --> 00:35:43.110
color in the depth buffer
seven times per frame.

00:35:43.110 --> 00:35:46.020
Which is obviously not a very
useful thing to do.

00:35:46.020 --> 00:35:47.880
But it's interesting for
measuring performance.

00:35:47.880 --> 00:35:51.170
As you might know, tablets are
fill rate limited, and this

00:35:51.170 --> 00:35:54.405
can give you an idea of how much
fill rate you can get and

00:35:54.405 --> 00:35:55.840
the best case.

00:35:55.840 --> 00:36:01.850
So it turns out seven clear
screens is the upper bound you

00:36:01.850 --> 00:36:04.210
can do to still get 60 frames.

00:36:04.210 --> 00:36:08.190
So if you draw every pixel seven
times per frame, you

00:36:08.190 --> 00:36:12.700
probably won't get 60
frames per second.

00:36:12.700 --> 00:36:15.830
And that's with the cheapest
filling possible, right?

00:36:15.830 --> 00:36:17.050
Normally you'd also
do some geometry

00:36:17.050 --> 00:36:18.300
transforms and whatnot.

00:36:21.730 --> 00:36:24.670
So I was interested in finding
out what this number here is.

00:36:24.670 --> 00:36:27.230
So I wrote this program.

00:36:27.230 --> 00:36:28.460
And let's run this.

00:36:28.460 --> 00:36:32.180
So what this will do, it will,
again, compile the thing and

00:36:32.180 --> 00:36:33.220
upload it to the device.

00:36:33.220 --> 00:36:35.420
The device will measure how
fast it's drawing and send

00:36:35.420 --> 00:36:37.250
that back to the laptop
and it'll hopefully

00:36:37.250 --> 00:36:38.500
show up here on screen.

00:36:41.030 --> 00:36:45.160
And for demonstration purposes,
the app apparently

00:36:45.160 --> 00:36:47.752
measures the frame time every
frame and sesnd it.

00:36:47.752 --> 00:36:50.000
So normally you'd want to
measure for the last second

00:36:50.000 --> 00:36:53.630
and display an average
for the last second.

00:36:53.630 --> 00:36:55.390
But if you do this for
every frame, you'll

00:36:55.390 --> 00:36:56.640
see a curious thing.

00:36:56.640 --> 00:36:59.910
Every frame either takes exactly
1/60 of a second or

00:36:59.910 --> 00:37:02.550
1/30 of a second.

00:37:02.550 --> 00:37:06.150
So that oscillates between 60
frames per second and 30

00:37:06.150 --> 00:37:07.170
frames per second.

00:37:07.170 --> 00:37:11.260
Or if you think a millisecond
per frame is better, either 16

00:37:11.260 --> 00:37:15.260
or 32 milliseconds per frame.

00:37:15.260 --> 00:37:18.060
And I'm not sure why
that is, exactly.

00:37:18.060 --> 00:37:25.070
But my theory is
that the, oh--

00:37:25.070 --> 00:37:26.860
gold star!

00:37:26.860 --> 00:37:28.850
Someone suggests
it's the Vsync.

00:37:28.850 --> 00:37:33.560
So Vsync is what the old tube
monitors use, I guess.

00:37:33.560 --> 00:37:36.040
So I guess there's some kind of
double buffering going on

00:37:36.040 --> 00:37:39.460
and the compositor that draws
the Android interface

00:37:39.460 --> 00:37:42.010
basically only wants to
render at 60 hertz.

00:37:42.010 --> 00:37:45.230
And if your frame takes just a
millisecond longer than 60

00:37:45.230 --> 00:37:49.460
milliseconds, then you have to
wait for the next time Android

00:37:49.460 --> 00:37:51.030
allows you to paint.

00:37:51.030 --> 00:37:54.120
And this makes it kind of
hard to do performance

00:37:54.120 --> 00:37:54.760
measurement, right?

00:37:54.760 --> 00:37:56.980
Because if you're one
millisecond too slow then you

00:37:56.980 --> 00:38:01.050
pay another 60 millisecond
a seconds for your frame.

00:38:01.050 --> 00:38:03.450
And that makes it hard to
evaluate if any rendering

00:38:03.450 --> 00:38:06.250
changes actually value
performance.

00:38:06.250 --> 00:38:11.190
And as it turns out there's some
hack that happens to undo

00:38:11.190 --> 00:38:13.180
this effect somehow.

00:38:13.180 --> 00:38:15.910
So I guess it somehow enables
triple buffering, but I don't

00:38:15.910 --> 00:38:18.280
know what's going on
there exactly.

00:38:18.280 --> 00:38:21.970
I stumbled upon this.

00:38:21.970 --> 00:38:24.920
So this hack is done by this
function, which I'll show on

00:38:24.920 --> 00:38:25.440
the next slide.

00:38:25.440 --> 00:38:30.130
So if you do this call here.

00:38:30.130 --> 00:38:31.560
And it's compiling again,
uploading again.

00:38:35.640 --> 00:38:38.240
And now you see that this is
a pretty constant function.

00:38:38.240 --> 00:38:42.005
Just a little bit about over 60
milliseconds, which caused

00:38:42.005 --> 00:38:44.670
this jiggering.

00:38:44.670 --> 00:38:48.040
So since I don't really know
what this function does up

00:38:48.040 --> 00:38:50.430
there, I wouldn't recommend
using it in your shipping

00:38:50.430 --> 00:38:51.200
application.

00:38:51.200 --> 00:38:53.400
But it's pretty useful
for doing performance

00:38:53.400 --> 00:38:54.650
measurements, right?

00:39:00.570 --> 00:39:03.805
So I guess double buffering is
what's causing this, somehow.

00:39:03.805 --> 00:39:06.250
But who knows?

00:39:06.250 --> 00:39:08.790
If you call egl--

00:39:08.790 --> 00:39:10.980
you need to call some
function that's not

00:39:10.980 --> 00:39:11.930
exposed through Java.

00:39:11.930 --> 00:39:14.470
So you need JNI again.

00:39:14.470 --> 00:39:17.980
All this code is on some Google
code site and I'll post

00:39:17.980 --> 00:39:22.440
the link at the end so you can
play with this at home.

00:39:22.440 --> 00:39:26.260
So if you call eglSurfaceAttrib
Swap Behavior

00:39:26.260 --> 00:39:32.300
preserved, then this somehow
magically disables something,

00:39:32.300 --> 00:39:34.850
or enables something, that
allows you to do better

00:39:34.850 --> 00:39:37.460
performance measurements.

00:39:37.460 --> 00:39:40.890
If you do a web search for swap
behavior, then I think

00:39:40.890 --> 00:39:42.890
there's one page on this.

00:39:42.890 --> 00:39:45.600
And this page tells you never
use GL buffer preserve because

00:39:45.600 --> 00:39:48.310
it makes things slow.

00:39:48.310 --> 00:39:50.700
And I guess that's true.

00:39:50.700 --> 00:39:55.080
But on some hardware it allows
you to do useful time

00:39:55.080 --> 00:39:56.890
measurements.

00:39:56.890 --> 00:39:59.220
So this is on the Tegra
2 on tablets.

00:39:59.220 --> 00:40:01.660
I guess also on your Samsung
that you got

00:40:01.660 --> 00:40:04.380
also used Tegra 2.

00:40:04.380 --> 00:40:06.570
If you run this on a
[UNINTELLIGIBLE]

00:40:06.570 --> 00:40:09.900
it doesn't support this
attribute and just crashed.

00:40:09.900 --> 00:40:15.160
So it's very dangerous but
useful for measurement.

00:40:15.160 --> 00:40:16.930
So measure your stuff.

00:40:16.930 --> 00:40:19.080
Now that we know how to measure,
let's see how we can

00:40:19.080 --> 00:40:20.330
improve performance.

00:40:22.740 --> 00:40:23.970
So here are the basics.

00:40:23.970 --> 00:40:25.940
You always want you vertex
buffer objects.

00:40:25.940 --> 00:40:30.530
So don't upload your vertex
data every frame.

00:40:30.530 --> 00:40:34.640
Instead upload them into a VBO
and then only upload the

00:40:34.640 --> 00:40:37.070
integer into OpenGL.

00:40:37.070 --> 00:40:39.900
Always use index geometry.

00:40:39.900 --> 00:40:43.060
So as most of you will know,
when you render two triangles

00:40:43.060 --> 00:40:46.320
that are right next to each
other, you basically first

00:40:46.320 --> 00:40:49.290
send these three vertices
to the GPU and

00:40:49.290 --> 00:40:50.710
then these three vertices.

00:40:50.710 --> 00:40:52.640
And if you send the four
vertices, then you're

00:40:52.640 --> 00:40:55.490
basically sending this and
this vertex twice.

00:40:55.490 --> 00:40:56.460
And that's expensive.

00:40:56.460 --> 00:41:00.440
So in practice you usually
have only send indexes.

00:41:00.440 --> 00:41:03.640
You say, draw a triangle with
vertex one, two, three and

00:41:03.640 --> 00:41:07.240
then one, three, four.

00:41:07.240 --> 00:41:10.410
And that way you only need to
transfer the index twice,

00:41:10.410 --> 00:41:12.620
which is almost always a win.

00:41:12.620 --> 00:41:15.510
So do that.

00:41:15.510 --> 00:41:19.150
OpenGL gives you the flexibility
to either, order

00:41:19.150 --> 00:41:23.230
your vertices by basically
have one chunk of memory,

00:41:23.230 --> 00:41:25.500
where all the vertex positions
are and then another chunk of

00:41:25.500 --> 00:41:27.390
memory, where all the normals
are, another chunk where all

00:41:27.390 --> 00:41:30.620
the texture coordinates are.

00:41:30.620 --> 00:41:32.410
But don't do that.

00:41:32.410 --> 00:41:36.760
You should always keep one
vertex in a small, contained

00:41:36.760 --> 00:41:37.410
element of memory.

00:41:37.410 --> 00:41:40.045
So you want to have vertex
position right next to normal

00:41:40.045 --> 00:41:42.960
or texture coordinate.

00:41:42.960 --> 00:41:45.920
And then, as I said, there
aren't many caches

00:41:45.920 --> 00:41:46.600
on some of the GPUs.

00:41:46.600 --> 00:41:49.770
So you want to keep your
attributes small.

00:41:49.770 --> 00:41:52.870
So for normals you can usually
get away with just assigned

00:41:52.870 --> 00:41:55.820
u8, so assigned byte
is usually enough

00:41:55.820 --> 00:41:57.910
resolution for normal.

00:41:57.910 --> 00:41:59.550
For texture coordinates,
you might get

00:41:59.550 --> 00:42:01.280
away with half loads.

00:42:01.280 --> 00:42:03.050
So half loads are not officially
supported by ES

00:42:03.050 --> 00:42:07.860
2.0, but like ETC textures they
are supported virtually

00:42:07.860 --> 00:42:08.410
everywhere.

00:42:08.410 --> 00:42:12.290
So think about doing this.

00:42:12.290 --> 00:42:15.980
Also, since your code will run
on different devices, with

00:42:15.980 --> 00:42:18.670
different frame rates, you
should make animation

00:42:18.670 --> 00:42:20.690
time-based not frame
rate-based.

00:42:20.690 --> 00:42:24.200
So if you have some animation
and some device renders your

00:42:24.200 --> 00:42:27.790
app at 30 frames and the next
at 60 frames, the animation

00:42:27.790 --> 00:42:30.850
should take the same length and
not be twice as fast just

00:42:30.850 --> 00:42:34.220
because the device renders
twice as fast.

00:42:34.220 --> 00:42:37.080
So that's the basics,
basically.

00:42:37.080 --> 00:42:40.490
And now once you've written
your app and it's kind of

00:42:40.490 --> 00:42:43.890
slow, the first thing you do is
you set the glViewport to a

00:42:43.890 --> 00:42:46.210
1x1 pixel thingee.

00:42:46.210 --> 00:42:52.010
And then either frame rate
goes up or it doesn't.

00:42:52.010 --> 00:42:56.030
If it does go up, then you are
either fragment processor

00:42:56.030 --> 00:42:57.695
bound or texture fetch bound.

00:43:00.780 --> 00:43:03.580
And you differentiate that by
making all your textures

00:43:03.580 --> 00:43:04.210
really small.

00:43:04.210 --> 00:43:08.130
And if stuff gets--

00:43:08.130 --> 00:43:10.230
if that doesn't help then you
are fragment processor bound.

00:43:10.230 --> 00:43:12.100
And if that helps, you're
texture bound.

00:43:12.100 --> 00:43:15.790
So if you're fragment processor
bound, there are a

00:43:15.790 --> 00:43:16.400
few things you can do.

00:43:16.400 --> 00:43:19.700
You can work from the fragment
shader to the vertex shader.

00:43:19.700 --> 00:43:22.700
In my experience, fragment
shaders on mobile devices have

00:43:22.700 --> 00:43:24.350
to be, like, one or two lines.

00:43:24.350 --> 00:43:28.090
So you can't do lots of
fancy effect there.

00:43:28.090 --> 00:43:33.000
If you want to do very fancy
lighting you can basically

00:43:33.000 --> 00:43:35.590
pre-compute all your lighting
formulas for the resizing the

00:43:35.590 --> 00:43:37.750
texture and then do a texture
look up instead of doing your

00:43:37.750 --> 00:43:39.000
own calculations.

00:43:41.380 --> 00:43:44.330
You shouldn't draw backfacing.

00:43:44.330 --> 00:43:47.300
Strings that face
the other way.

00:43:47.300 --> 00:43:49.020
And you shouldn't use discard
in your fragment shaders.

00:43:51.860 --> 00:43:54.150
But the main point is
do less work in you

00:43:54.150 --> 00:43:57.360
fragment shaders here.

00:43:57.360 --> 00:44:01.710
If you're texture fetch bound,
if you're not using texture

00:44:01.710 --> 00:44:03.720
compression yet, you should.

00:44:03.720 --> 00:44:08.230
One thing that also helps is
to use mipmaps because of

00:44:08.230 --> 00:44:09.650
cache coherency.

00:44:09.650 --> 00:44:13.950
And of course use smaller
textures.

00:44:13.950 --> 00:44:17.900
One thing I forgot to mention
on the ETC slide, on the

00:44:17.900 --> 00:44:20.540
texture compression slide is
that ETC doesn't support an

00:44:20.540 --> 00:44:21.740
alpha channel.

00:44:21.740 --> 00:44:24.900
So if you have textures that
use an alpha channel, then

00:44:24.900 --> 00:44:28.020
there's a not a single
compressed texture format that

00:44:28.020 --> 00:44:30.020
works on all devices.

00:44:30.020 --> 00:44:34.070
So in that case, you probably
have to download the right

00:44:34.070 --> 00:44:36.370
compressed textures on
first run, depending

00:44:36.370 --> 00:44:37.880
on the device type.

00:44:37.880 --> 00:44:40.460
Or if you don't have many
alpha textures, not use

00:44:40.460 --> 00:44:41.400
compression.

00:44:41.400 --> 00:44:44.200
But if you're running into this
problem and not all your

00:44:44.200 --> 00:44:48.930
textures are compressed
then try that first.

00:44:48.930 --> 00:44:51.420
So if you're not fragment
processor bound, you're

00:44:51.420 --> 00:44:54.250
probably vertex processor
bound.

00:44:54.250 --> 00:44:56.850
So if using a very small
viewport doesn't really help

00:44:56.850 --> 00:44:59.680
you, you're probably vertex
processor bound.

00:44:59.680 --> 00:45:03.150
In that case, use fewer
small attributes.

00:45:03.150 --> 00:45:08.280
So try using assigned bytes for
your normals, and so on.

00:45:08.280 --> 00:45:11.240
You can play with the
position framework.

00:45:11.240 --> 00:45:15.030
Position keyword in OpenGL ES.

00:45:15.030 --> 00:45:18.750
You can do, instead of doing
lighting for vertex, instead

00:45:18.750 --> 00:45:21.820
of transforming the light vector
into model space at

00:45:21.820 --> 00:45:25.610
every vertex, you can, instead
transform the light vector

00:45:25.610 --> 00:45:29.340
once and then read the
transformed light vector.

00:45:29.340 --> 00:45:32.380
You can use level of detail.

00:45:32.380 --> 00:45:37.370
And you can call objects that
are outside of the viewport.

00:45:37.370 --> 00:45:38.600
So that's all the--

00:45:38.600 --> 00:45:40.430
I guess, pretty normal--

00:45:40.430 --> 00:45:43.670
performance stuff that's also
true on normal devices.

00:45:43.670 --> 00:45:49.060
Finally if you are CPU bound,
then use less CPU.

00:45:49.060 --> 00:45:52.700
So one thing that's expensive,
can be expensive, is if you

00:45:52.700 --> 00:45:54.970
allocate memory a lot
in your inner loops.

00:45:54.970 --> 00:45:56.510
In that case, reuse memory.

00:45:59.360 --> 00:46:00.210
Batch draw calls.

00:46:00.210 --> 00:46:04.210
So don't have a for loop in
your drawMethod type that

00:46:04.210 --> 00:46:06.370
basically tells the GPU, draw
this triangle, now this, now

00:46:06.370 --> 00:46:06.850
this, now this.

00:46:06.850 --> 00:46:09.240
And loop for all triangles.

00:46:09.240 --> 00:46:12.140
Instead have one call that
fetches all triangles.

00:46:16.310 --> 00:46:19.600
And if all else fails, you can
look at the NDK and try to

00:46:19.600 --> 00:46:22.745
write native code for your
time-critical functions.

00:46:22.745 --> 00:46:25.480
In my experience, that doesn't
help all that much.

00:46:29.540 --> 00:46:31.640
And that's that, I think.

00:46:31.640 --> 00:46:32.890
So thanks for listening.

00:46:32.890 --> 00:46:35.340
Whoa.

00:46:35.340 --> 00:46:36.923
Watch me type my password.

00:46:40.670 --> 00:46:45.120
So code, slides and so on are
available at this website.

00:46:45.120 --> 00:46:46.930
If you do a web search for
io 2011 OpenGL Android

00:46:46.930 --> 00:46:50.440
it might show up.

00:46:50.440 --> 00:46:52.850
So the project used to be
hidden earlier today.

00:46:52.850 --> 00:46:54.100
I don't know if it's
visible now.

00:46:57.980 --> 00:47:02.910
So we have these feedback links
that are completely

00:47:02.910 --> 00:47:03.890
impossible to pronounce.

00:47:03.890 --> 00:47:10.230
So, goo.gl/TUMU4 if you want
to tell me anything.

00:47:12.900 --> 00:47:14.280
And that's that.

00:47:14.280 --> 00:47:16.820
And I'll download Body for
Android and play with it a

00:47:16.820 --> 00:47:18.960
little bit.

00:47:18.960 --> 00:47:20.100
So do we have any questions?

00:47:20.100 --> 00:47:21.350
[APPLAUSE]

00:47:31.530 --> 00:47:33.330
AUDIENCE: Do you know how to
do OpenGL to a widget?

00:47:33.330 --> 00:47:34.580
NICO WEBER: I don't.

00:47:37.090 --> 00:47:41.530
I haven't looked at the widget
stuff at all, yet.

00:47:41.530 --> 00:47:44.744
AUDIENCE: Aside from using
compressed textures, how can I

00:47:44.744 --> 00:47:48.370
speed up the process of
reloading my textures when my

00:47:48.370 --> 00:47:49.650
surface is recreated?

00:47:54.700 --> 00:47:55.620
NICO WEBER: How do you
do the reading?

00:47:55.620 --> 00:47:58.070
Do you just use the ETC1
text [UNINTELLIGIBLE]

00:47:58.070 --> 00:47:59.850
to read the texture, or?

00:47:59.850 --> 00:48:01.313
AUDIENCE: I'm not using
[UNINTELLIGIBLE].

00:48:01.313 --> 00:48:04.500
I'm writing for older
versions of Android.

00:48:04.500 --> 00:48:08.210
NICO WEBER: So one thing that
I think might work, which I

00:48:08.210 --> 00:48:09.550
want to do for Body but
haven't done yet , is

00:48:09.550 --> 00:48:13.200
basically you read all your
texture data applications data

00:48:13.200 --> 00:48:18.020
once and then you keep them in
memory cache ready for upload.

00:48:18.020 --> 00:48:18.530
AUDIENCE: A memory cache?

00:48:18.530 --> 00:48:19.080
NICO WEBER: Yeah, basically.

00:48:19.080 --> 00:48:21.950
You keep them around so just
upload them immediately.

00:48:21.950 --> 00:48:23.940
And if your activity
is [? on low ?]

00:48:23.940 --> 00:48:25.750
memory is called you
drop these cache.

00:48:25.750 --> 00:48:28.540
And then basically you have them
in memory already and you

00:48:28.540 --> 00:48:29.280
don't need to reload them.

00:48:29.280 --> 00:48:30.690
That's something I would try.

00:48:30.690 --> 00:48:32.850
AUDIENCE: I'd like to get
some detail on that.

00:48:32.850 --> 00:48:33.260
NICO WEBER: OK.

00:48:33.260 --> 00:48:34.510
Maybe later.

00:48:38.060 --> 00:48:38.410
Yes?

00:48:38.410 --> 00:48:39.130
AUDIENCE: Hi.

00:48:39.130 --> 00:48:41.840
Do you have any issues
with transparency?

00:48:41.840 --> 00:48:46.436
Because I know that it looks
like Body makes pretty heavy

00:48:46.436 --> 00:48:49.322
use of showing some kind
of opaque model of

00:48:49.322 --> 00:48:50.690
a translucent shell.

00:48:50.690 --> 00:48:54.450
And in GL that can be tricky
to get order right.

00:48:54.450 --> 00:48:54.710
NICO WEBER: Yeah.

00:48:54.710 --> 00:48:58.110
So that's a known deficiency
with OpenGL.

00:48:58.110 --> 00:49:00.520
So Body, I think, just doesn't
care that much.

00:49:00.520 --> 00:49:01.590
So it doesn't look perfect.

00:49:01.590 --> 00:49:05.130
But it looks good
enough, I think.

00:49:05.130 --> 00:49:09.620
So basically, one thing you can
use so that-- the usual

00:49:09.620 --> 00:49:11.820
way to do this is to draw your
non-transparent stuff first,

00:49:11.820 --> 00:49:15.030
and then basically sort your
transparent [UNINTELLIGIBLE]

00:49:15.030 --> 00:49:16.750
on CPU and draw them
back to front.

00:49:16.750 --> 00:49:19.430
So that's slow, because
you need sort stuff.

00:49:19.430 --> 00:49:23.520
There's this depth peeling
technique by Cass Everitt,

00:49:23.520 --> 00:49:26.630
that means you need to render
the C [UNINTELLIGIBLE]

00:49:26.630 --> 00:49:27.060
for that.

00:49:27.060 --> 00:49:29.710
So I don't think there's
a good general

00:49:29.710 --> 00:49:31.030
answer to that question.

00:49:31.030 --> 00:49:32.300
You need to see what
works for your app.

00:49:32.300 --> 00:49:36.430
In Body, I just don't really
care at the moment.

00:49:36.430 --> 00:49:37.603
AUDIENCE: So what did
you do for Body?

00:49:37.603 --> 00:49:37.900
Did you just--

00:49:37.900 --> 00:49:40.770
NICO WEBER: I just say GL bend
mode one source of--

00:49:40.770 --> 00:49:42.760
AUDIENCE: But you drew the
opaque part and then just--

00:49:42.760 --> 00:49:43.800
NICO WEBER: No, I just
draw everything.

00:49:43.800 --> 00:49:46.520
So Body basically has
these layers.

00:49:46.520 --> 00:49:48.690
There's organs, skeleton
and so on.

00:49:48.690 --> 00:49:52.610
And I draw the inner layer first
and the outer layer in

00:49:52.610 --> 00:49:54.610
transparent doing the
[UNINTELLIGIBLE].

00:49:54.610 --> 00:49:56.660
But per layer I just
say, transparency

00:49:56.660 --> 00:49:58.675
on and do your thing.

00:49:58.675 --> 00:50:01.980
And I think I draw the
opaque things first.

00:50:01.980 --> 00:50:03.465
AUDIENCE: Cool.

00:50:03.465 --> 00:50:05.445
NICO WEBER: Yes?

00:50:05.445 --> 00:50:07.590
AUDIENCE: So have you considered
using something

00:50:07.590 --> 00:50:08.118
like the [?

00:50:08.118 --> 00:50:10.390
SP3s so you can get the
transparency right?

00:50:10.390 --> 00:50:11.490
NICO WEBER: Yeah, I have
considered it.

00:50:11.490 --> 00:50:15.190
But it doesn't seem like the
most critical thing I should

00:50:15.190 --> 00:50:16.694
be working on right now.

00:50:16.694 --> 00:50:17.136
So as I said--

00:50:17.136 --> 00:50:17.578
AUDIENCE: Right, right.

00:50:17.578 --> 00:50:18.670
As a 20% thing.

00:50:18.670 --> 00:50:20.690
Your spare time, other
than sleeping.

00:50:20.690 --> 00:50:22.075
NICO WEBER: Well it's my
Friday, basically.

00:50:24.860 --> 00:50:28.031
So I thought about that,
but I haven't done yet.

00:50:28.031 --> 00:50:30.282
AUDIENCE: But I guess the
question is, do you see

00:50:30.282 --> 00:50:33.186
problems in trying to
take that approach

00:50:33.186 --> 00:50:35.606
with Java on GL 2.0?

00:50:35.606 --> 00:50:38.510
Are you going to get hung
up on computation?

00:50:38.510 --> 00:50:38.994
Are you going to get hung up on

00:50:38.994 --> 00:50:41.390
pushing the indices through?

00:50:41.390 --> 00:50:42.170
NICO WEBER: Try it, I guess.

00:50:42.170 --> 00:50:45.660
So writing a demo for that
should take, maybe, two hours?

00:50:45.660 --> 00:50:46.550
And then you know.

00:50:46.550 --> 00:50:47.580
That's what I would do.

00:50:47.580 --> 00:50:48.340
But I don't know.

00:50:48.340 --> 00:50:50.960
So I guess if stuff turns out
to be slow you can always go

00:50:50.960 --> 00:50:52.490
to native code.

00:50:52.490 --> 00:50:56.190
But it worked on really slow
machines 12 years ago, or even

00:50:56.190 --> 00:50:58.530
longer than that, so I guess
it should work fine.

00:50:58.530 --> 00:51:01.834
AUDIENCE: Have you considered
or looked at Renderscript

00:51:01.834 --> 00:51:03.770
by'the way?

00:51:03.770 --> 00:51:07.490
NICO WEBER: So when I wrote
this, 3.0, there was even less

00:51:07.490 --> 00:51:09.460
documentation on Renderscript
than there is today.

00:51:09.460 --> 00:51:11.735
I think I had heard of a
name, but nothing else.

00:51:11.735 --> 00:51:13.200
So not really.

00:51:13.200 --> 00:51:16.340
And also I think Renderscript
is 3.0-only and

00:51:16.340 --> 00:51:18.100
Android-only and so on.

00:51:18.100 --> 00:51:21.930
So I think, not yet.

00:51:21.930 --> 00:51:24.375
AUDIENCE: OK, thanks.

00:51:24.375 --> 00:51:26.820
NICO WEBER: Yes?

00:51:26.820 --> 00:51:30.487
AUDIENCE: When you're using
GLSurfaceView and on top of

00:51:30.487 --> 00:51:35.022
which, you might want to use an
Android 2-D graphics widget

00:51:35.022 --> 00:51:39.352
or ListView, let's say,
the performance drops

00:51:39.352 --> 00:51:40.300
tremendously.

00:51:40.300 --> 00:51:43.830
I can understand there's 2D
computation, there's the 3D

00:51:43.830 --> 00:51:45.668
computation in the background
happening.

00:51:45.668 --> 00:51:48.476
But have you guys thought
about it?

00:51:48.476 --> 00:51:51.850
Like how do you deal with
this in the future?

00:51:51.850 --> 00:51:56.990
How about out combining 2D
graphic APIs and 3D graphic?

00:51:56.990 --> 00:52:00.750
NICO WEBER: So with you guys, do
you mean me the Google Body

00:52:00.750 --> 00:52:03.412
developer or us the Android
framework guys?

00:52:03.412 --> 00:52:04.910
AUDIENCE: Generally
Android framework.

00:52:04.910 --> 00:52:06.100
NICO WEBER: So I have
no idea what the

00:52:06.100 --> 00:52:07.125
Android guys are doing.

00:52:07.125 --> 00:52:07.870
I'm sorry.

00:52:07.870 --> 00:52:12.257
AUDIENCE: Any tips and tricks
you might have seen?

00:52:12.257 --> 00:52:15.460
AUDIENCE: [INAUDIBLE].

00:52:15.460 --> 00:52:19.450
NICO WEBER: OK, so I am told to
recommend the Office Hours.

00:52:19.450 --> 00:52:22.310
So what Google Body does, if you
tap things it draws these

00:52:22.310 --> 00:52:24.050
little text widgets.

00:52:24.050 --> 00:52:27.280
And I'm using OpenGL text just
for that because I didn't want

00:52:27.280 --> 00:52:29.210
to deal with mixing 3D and 2D.

00:52:29.210 --> 00:52:32.120
But I think Google Maps puts
2D, which is on top of the

00:52:32.120 --> 00:52:33.560
map, and the map is
a GLSurfaceView,

00:52:33.560 --> 00:52:36.160
so it kind of works.

00:52:36.160 --> 00:52:38.030
So I guess it depends on if
you're writing a game where

00:52:38.030 --> 00:52:40.250
you really need that 60
frames per second.

00:52:40.250 --> 00:52:42.602
And in that case, you don't want
to put anything on top of

00:52:42.602 --> 00:52:42.980
your thing.

00:52:42.980 --> 00:52:47.070
Or if you're writing an app, in
that case it might be fine.

00:52:47.070 --> 00:52:48.320
AUDIENCE: OK, thanks.

00:52:51.100 --> 00:52:52.350
NICO WEBER: More questions?

00:52:56.800 --> 00:52:58.640
AUDIENCE: I've got a question
about the cow.

00:52:58.640 --> 00:53:00.180
NICO WEBER: Yes?

00:53:00.180 --> 00:53:02.470
AUDIENCE: Specifically, why
are its teats on show,

00:53:02.470 --> 00:53:06.060
compared to the female model?

00:53:06.060 --> 00:53:06.920
NICO WEBER: So I don't know.

00:53:06.920 --> 00:53:10.050
The web version did that.

00:53:10.050 --> 00:53:13.260
I hadn't ported the cow yet
to the tablet version.

00:53:13.260 --> 00:53:15.980
So I haven't looked
into that yet.

00:53:15.980 --> 00:53:18.460
Thought I can see the cow on the
tablet being really useful

00:53:18.460 --> 00:53:20.760
if you go to a steak house
you can be like,

00:53:20.760 --> 00:53:23.190
can I have this piece?

00:53:23.190 --> 00:53:24.183
So that's my motivation,
there.

00:53:24.183 --> 00:53:25.433
But I haven't had time yet.

00:53:32.200 --> 00:53:34.340
What's that?

00:53:34.340 --> 00:53:36.070
Oh yeah, that's pretty
fancy, huh?

00:53:36.070 --> 00:53:38.740
So locally on the notebook,
there's a little ghost server

00:53:38.740 --> 00:53:40.350
running that basically--

00:53:40.350 --> 00:53:42.760
so I have a web socket
connection to the local ghost

00:53:42.760 --> 00:53:46.990
server and then it copies that
into a Java file, invokes and

00:53:46.990 --> 00:53:50.770
to compile this thing, then
invokes ADB to copy it over

00:53:50.770 --> 00:53:53.460
and then ADB lock add to [? grab
the output for the frame

00:53:53.460 --> 00:53:57.110
stuff, sends it back
up the web socket.

00:53:57.110 --> 00:53:59.000
Yeah, that's also on
the slide project.

00:53:59.000 --> 00:54:04.280
And this took way longer
to do that than useful.

00:54:04.280 --> 00:54:05.530
But oh, well.

00:54:08.150 --> 00:54:12.055
Yeah, the question was, how did
the run button work in the

00:54:12.055 --> 00:54:14.530
presentation.

00:54:14.530 --> 00:54:17.010
More questions?

00:54:17.010 --> 00:54:20.200
Come on guys, we have
five minutes left.

00:54:20.200 --> 00:54:21.082
No questions?

00:54:21.082 --> 00:54:21.880
All right, then.

00:54:21.880 --> 00:54:23.050
Thanks for listening, again.

00:54:23.050 --> 00:54:24.760
[APPLAUSE]

00:54:24.760 --> 00:54:26.200
NICO WEBER: Oh, there's
one last question.

00:54:26.200 --> 00:54:30.682
AUDIENCE: In the fill rate
example, you cleared both the

00:54:30.682 --> 00:54:32.674
color buffer and the
depth buffer.

00:54:32.674 --> 00:54:37.156
I mean if you, actually
I was confused.

00:54:37.156 --> 00:54:41.887
Does the fill rate work-- were
you trying look for both depth

00:54:41.887 --> 00:54:43.660
and color buffer?

00:54:43.660 --> 00:54:45.130
NICO WEBER: Yeah so if you just
clear the color buffer

00:54:45.130 --> 00:54:47.510
then you can go higher
than seven.

00:54:47.510 --> 00:54:51.300
So that's faster, if that's
the question.

00:54:51.300 --> 00:54:54.130
But you can just try
it yourself.

00:54:54.130 --> 00:54:59.014
AUDIENCE: I mean like the depth
buffer is like, you

00:54:59.014 --> 00:55:01.494
don't write to it so often,
is what I got.

00:55:01.494 --> 00:55:04.480
It's much smaller than the
color buffer, so--

00:55:04.480 --> 00:55:07.850
NICO WEBER: I think the Tegra 2
has, it usually uses 16-bit

00:55:07.850 --> 00:55:09.150
colors for performance
for the color buffer.

00:55:09.150 --> 00:55:12.410
And the Tegra also only has
16-bit C buffers so

00:55:12.410 --> 00:55:13.776
it's those same size.

00:55:13.776 --> 00:55:14.608
AUDIENCE: Both are 16-bit?

00:55:14.608 --> 00:55:17.330
NICO WEBER: Both are
16-bit per pixel.

00:55:17.330 --> 00:55:17.820
AUDIENCE: OK.

00:55:17.820 --> 00:55:18.800
Thank you.

00:55:18.800 --> 00:55:22.410
NICO WEBER: And phones actually
have, I guess, 32-bit

00:55:22.410 --> 00:55:27.030
def per pixel, so you can get
some z fighting artifacts on

00:55:27.030 --> 00:55:28.280
Tegra if you're not careful.

00:55:31.670 --> 00:55:33.160
All right then, I'll just
say thank you, again.

00:55:33.160 --> 00:55:34.796
And usually someone
else pops up.

00:55:34.796 --> 00:55:36.820
AUDIENCE: It's not about
the cow this time.

00:55:36.820 --> 00:55:40.008
The question was on, did you try
the fill buffer test with

00:55:40.008 --> 00:55:41.760
textures as well and see what
the throughput was on that?

00:55:41.760 --> 00:55:44.405
NICO WEBER: I think I did and
I think it was identical.

00:55:44.405 --> 00:55:46.420
AUDIENCE: It was lower
than 7 per?

00:55:46.420 --> 00:55:48.076
NICO WEBER: I think
it was the same.

00:55:48.076 --> 00:55:49.380
AUDIENCE: There was
no difference?

00:55:49.380 --> 00:55:52.670
So the fill rate is identical
for texture and

00:55:52.670 --> 00:55:53.370
also uniform color?

00:55:53.370 --> 00:55:55.120
NICO WEBER: I think so, yes.

00:55:55.120 --> 00:55:57.250
Pretty sure I tried that.

00:55:57.250 --> 00:55:59.680
But don't believe me anything.

00:55:59.680 --> 00:56:02.260
Just try everything yourself.

00:56:02.260 --> 00:56:04.120
It's easy and quick to do.

00:56:04.120 --> 00:56:06.130
All right, that's all folks.

00:56:06.130 --> 00:56:07.380
Thanks.

