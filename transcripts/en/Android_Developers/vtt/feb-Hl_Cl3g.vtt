WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:04.194
[MUSIC PLAYING]

00:00:04.194 --> 00:00:06.690
FRANCESCO CARUCCI: I'm going
to show you this Systraces.

00:00:06.690 --> 00:00:10.030
And I'm going to show
you how to spot issues.

00:00:10.030 --> 00:00:12.850
Issues that we found
are plenty, of course,

00:00:12.850 --> 00:00:17.960
but four were most widespread.

00:00:17.960 --> 00:00:24.190
Yes, I would say that these
four performance pitfalls were--

00:00:24.190 --> 00:00:28.357
basically every game at Seoul
had one, two, or three of them.

00:00:28.357 --> 00:00:30.940
I just found myself saying the
same thing over and over again.

00:00:30.940 --> 00:00:34.580
I said let's look at I/O
to a bunch of other people

00:00:34.580 --> 00:00:38.760
so I don't have to repeat
myself all the time.

00:00:38.760 --> 00:00:41.125
I'm going to go in depth
on each one of them.

00:00:41.125 --> 00:00:42.750
I'm going to show
you Systraces and how

00:00:42.750 --> 00:00:44.070
to spot it in your game.

00:00:46.435 --> 00:00:47.310
That's the first one.

00:00:51.890 --> 00:00:53.660
And this is a Systrace.

00:00:53.660 --> 00:00:56.260
This is basically
a certain number

00:00:56.260 --> 00:00:59.390
of cores, eight in this case.

00:00:59.390 --> 00:01:02.390
And you can see all the
threads running in the system.

00:01:02.390 --> 00:01:04.420
And you can see
this thread number

00:01:04.420 --> 00:01:09.950
three, which is basically
grabbing one core.

00:01:09.950 --> 00:01:11.630
Two is jumping from
one to the other.

00:01:11.630 --> 00:01:13.450
But essentially, it's
grabbing one core

00:01:13.450 --> 00:01:17.590
and hammering it while the rest
of the system does nothing.

00:01:17.590 --> 00:01:23.780
That's how a single thread
game looks in [INAUDIBLE]..

00:01:23.780 --> 00:01:24.370
And that is--

00:01:27.780 --> 00:01:29.040
OK.

00:01:29.040 --> 00:01:33.090
In the sense that if you're
making a casual game,

00:01:33.090 --> 00:01:35.320
a single thread casual game
is the right thing to do.

00:01:35.320 --> 00:01:35.820
I get it.

00:01:35.820 --> 00:01:37.440
It's just much easier.

00:01:37.440 --> 00:01:39.180
The architecture is easier.

00:01:39.180 --> 00:01:41.160
Everything is simpler.

00:01:41.160 --> 00:01:43.020
You don't have to look
at synchronization.

00:01:43.020 --> 00:01:43.540
I get it.

00:01:43.540 --> 00:01:46.810
It's a simple thing to do.

00:01:46.810 --> 00:01:50.310
But if you're pushing the
boundaries a little bit more,

00:01:50.310 --> 00:01:53.010
well, you have eight
cores, you're using one.

00:01:53.010 --> 00:01:55.530
It's a matter of
performance, but as we're

00:01:55.530 --> 00:01:58.741
going to see later, it's
not only about performance.

00:02:02.110 --> 00:02:05.920
This is an example
of a Unity game.

00:02:05.920 --> 00:02:07.840
I'm not going to ask you
many Unity developers

00:02:07.840 --> 00:02:10.419
are here to ask everyone
else the same question.

00:02:10.419 --> 00:02:13.210
That I believe there's
going to be many.

00:02:13.210 --> 00:02:17.180
There's going to be a Unity
mean thread, a single thread,

00:02:17.180 --> 00:02:19.640
hammering a system
just one core.

00:02:19.640 --> 00:02:21.960
Everything else does nothing.

00:02:21.960 --> 00:02:25.500
That's how it typically
looks like in Unity.

00:02:25.500 --> 00:02:29.710
And that's actually
very, very simple to fix.

00:02:29.710 --> 00:02:30.210
That's it.

00:02:30.210 --> 00:02:31.645
Click, click, click, click that.

00:02:31.645 --> 00:02:32.190
Nothing.

00:02:32.190 --> 00:02:34.220
Multi-thread
rendering, that one.

00:02:34.220 --> 00:02:36.170
Here, just click it.

00:02:36.170 --> 00:02:40.620
It's going to make your game
run faster and be better.

00:02:40.620 --> 00:02:42.500
It will make me happier.

00:02:42.500 --> 00:02:44.700
And since you're
there, you click CPU.

00:02:44.700 --> 00:02:49.440
Scanning as well, because you
don't want to scan on the CPU.

00:02:49.440 --> 00:02:51.900
It's bad and it makes me cry.

00:02:51.900 --> 00:02:54.515
I don't have a picture for that.

00:02:54.515 --> 00:02:55.140
But imagine it.

00:02:58.300 --> 00:03:01.940
Once you click that, that's how
your system is going to look.

00:03:01.940 --> 00:03:04.420
There's going to be a
nice main thread, which

00:03:04.420 --> 00:03:08.040
is processing you entity.

00:03:08.040 --> 00:03:11.060
Each entity will generate
a bunch of graphics command

00:03:11.060 --> 00:03:14.450
for the render thread that will
take these graphics commands

00:03:14.450 --> 00:03:17.300
and in parallel,
it will generate

00:03:17.300 --> 00:03:20.210
a bunch of rendering
commands for the GPU

00:03:20.210 --> 00:03:21.600
which runs in parallel.

00:03:21.600 --> 00:03:25.760
Now instead of having a thread
that is hammering one core,

00:03:25.760 --> 00:03:26.710
you have two threads.

00:03:26.710 --> 00:03:29.380
At least you're
parallelizing your work.

00:03:33.300 --> 00:03:35.920
And that's how Systrace
is going to look like.

00:03:35.920 --> 00:03:39.530
You're going to have Unity main,
which is a bit smaller, Unity

00:03:39.530 --> 00:03:41.730
GFX device.

00:03:41.730 --> 00:03:45.830
I don't know why W. I
always wondered why.

00:03:45.830 --> 00:03:49.550
This is not going to give you a
double frame rate straight out

00:03:49.550 --> 00:03:52.800
of the gate, because
you're not probably

00:03:52.800 --> 00:03:55.700
going to have workloads that
are exactly the same time,

00:03:55.700 --> 00:03:57.890
and can be just
perfectly parallelized.

00:03:57.890 --> 00:04:02.373
But you see it's a
pretty decent difference.

00:04:02.373 --> 00:04:04.040
You're going to get
something out of it.

00:04:04.040 --> 00:04:09.010
More interestingly, you're
going to let the CPU that

00:04:09.010 --> 00:04:12.310
is running Unity
main, have the chance

00:04:12.310 --> 00:04:14.210
to sleep for a little bit.

00:04:14.210 --> 00:04:19.225
We'll see why it's very, very
important to let cores sleep.

00:04:19.225 --> 00:04:21.899
It sounds weird.

00:04:21.899 --> 00:04:25.200
At the end of the day, you want
to parallelize your workloads

00:04:25.200 --> 00:04:29.150
because they will give
you better performance,

00:04:29.150 --> 00:04:34.780
but also because if you don't
do that, that's what happens,

00:04:34.780 --> 00:04:36.447
higher power consumption.

00:04:39.250 --> 00:04:43.930
That's a direct consequence of
having one single thread that

00:04:43.930 --> 00:04:45.620
does everything.

00:04:45.620 --> 00:04:50.190
It means that you're going
to consume more power,

00:04:50.190 --> 00:04:53.280
you're going to drain the
battery much faster, which

00:04:53.280 --> 00:04:55.980
leads us to the second issue.

00:04:55.980 --> 00:04:58.260
This is a gigantic deal.

00:04:58.260 --> 00:04:59.700
This is a big deal.

00:04:59.700 --> 00:05:01.100
If there is one
thing that I need

00:05:01.100 --> 00:05:04.330
you to remember out of
here is thermal throttling

00:05:04.330 --> 00:05:04.980
is a big deal.

00:05:08.260 --> 00:05:11.570
That's because on
mobile performance

00:05:11.570 --> 00:05:14.760
it's not constant over time.

00:05:14.760 --> 00:05:19.480
You think, I worked on console
and PC, pattern console.

00:05:19.480 --> 00:05:20.940
It's more fun.

00:05:20.940 --> 00:05:30.130
But once I made my frame take
33 milliseconds to process,

00:05:30.130 --> 00:05:32.258
I was done.

00:05:32.258 --> 00:05:33.550
I lived in England at the time.

00:05:33.550 --> 00:05:34.930
Everyone was going to the pub.

00:05:34.930 --> 00:05:35.870
I'm Italian.

00:05:35.870 --> 00:05:37.682
I was having a coffee.

00:05:37.682 --> 00:05:39.390
Please don't have
cappuccino after lunch.

00:05:39.390 --> 00:05:39.890
It's bad.

00:05:44.380 --> 00:05:46.590
All mobile things
are much different.

00:05:46.590 --> 00:05:53.060
On mobile, once you render
33 milliseconds for a frame,

00:05:53.060 --> 00:05:54.500
here's what happens.

00:05:54.500 --> 00:05:57.160
You have your carefully
optimized game.

00:05:57.160 --> 00:05:58.930
You give it to someone to play.

00:05:58.930 --> 00:05:59.680
It looks great.

00:05:59.680 --> 00:06:03.010
It runs beautifully
for 10 minutes.

00:06:03.010 --> 00:06:05.650
And then this device
is going to get hot.

00:06:05.650 --> 00:06:08.500
Device getting hot
means performance

00:06:08.500 --> 00:06:11.860
will go down because phones
that explode generally,

00:06:11.860 --> 00:06:15.550
are not perceived
well by clients.

00:06:15.550 --> 00:06:19.840
So manufacturers have
to slow things down so

00:06:19.840 --> 00:06:21.142
the device can cool down.

00:06:21.142 --> 00:06:23.350
So your game that was running
at 30 frames per second

00:06:23.350 --> 00:06:27.710
on the clock now is
running as 20, 15, 10.

00:06:27.710 --> 00:06:30.200
And your customer will
go and play and write

00:06:30.200 --> 00:06:32.050
to you and one star review.

00:06:32.050 --> 00:06:33.190
One star reviews are bad.

00:06:36.720 --> 00:06:38.610
I have an equation on my slide.

00:06:38.610 --> 00:06:40.711
I know math.

00:06:40.711 --> 00:06:41.705
Look at that.

00:06:45.690 --> 00:06:53.650
Power consumption for a CPU
is equal to capacitance thingy

00:06:53.650 --> 00:06:57.580
C. That thing is a constant
of some sort multiplied

00:06:57.580 --> 00:07:03.370
by square of the voltage
multiplied by its frequency.

00:07:03.370 --> 00:07:07.800
Now you see strings you can see
for each core the frequency.

00:07:07.800 --> 00:07:13.200
Like value is like 2
gigahertz [INAUDIBLE]..

00:07:13.200 --> 00:07:15.970
And you can see that thread
3 is basically maxing out

00:07:15.970 --> 00:07:18.790
frequency on that core.

00:07:18.790 --> 00:07:21.460
Also, in order to
run a max frequency,

00:07:21.460 --> 00:07:26.640
the voltage has to go up as well
to maintain the tight timings

00:07:26.640 --> 00:07:27.520
in the transistors.

00:07:27.520 --> 00:07:28.937
At least, that's
what they told me

00:07:28.937 --> 00:07:30.760
at the university 25 years ago.

00:07:34.140 --> 00:07:39.287
But also notice this very
interesting phenomenon.

00:07:39.287 --> 00:07:40.870
The frequency at
some point goes down,

00:07:40.870 --> 00:07:45.480
because the scheduler decided
to lower the frequency.

00:07:45.480 --> 00:07:48.460
But each core goes
down the same time.

00:07:48.460 --> 00:07:50.840
You can see like one, two,
three, four times in a row.

00:07:50.840 --> 00:07:54.150
They all go down at same time.

00:07:54.150 --> 00:07:59.560
That means that by virtue
of having third three,

00:07:59.560 --> 00:08:01.270
maxing out frequency
on one of the cores

00:08:01.270 --> 00:08:03.700
and maxing out the voltage
on one of the cores--

00:08:03.700 --> 00:08:04.940
voltage is squared.

00:08:04.940 --> 00:08:07.210
It's consuming a lot of power.

00:08:07.210 --> 00:08:11.560
It's forcing that small thread
n, to consume a lot of power

00:08:11.560 --> 00:08:13.810
for a little bit of
work that most probably

00:08:13.810 --> 00:08:16.120
doesn't need to run fast.

00:08:16.120 --> 00:08:18.790
If that thing takes
10 times to run,

00:08:18.790 --> 00:08:21.520
you would still hit 30 frame
per second most probably.

00:08:25.310 --> 00:08:28.160
This phenomenon is clearer here.

00:08:28.160 --> 00:08:29.900
This is a--

00:08:29.900 --> 00:08:32.220
Snapdragon 855.

00:08:32.220 --> 00:08:34.280
Yep, I remember correctly.

00:08:34.280 --> 00:08:38.850
This has 2 and 1/2
clusters of course.

00:08:38.850 --> 00:08:43.750
[INAUDIBLE] wants to
run at a lower clock?

00:08:43.750 --> 00:08:47.145
Clock 2, three cores,
that run a higher clock.

00:08:47.145 --> 00:08:48.520
And there's another
one, Clock 3,

00:08:48.520 --> 00:08:51.280
that runs at even higher clock.

00:08:51.280 --> 00:08:56.890
So basically, each
cluster has a clock plane.

00:08:56.890 --> 00:08:58.780
And each cluster
is voltage gated.

00:08:58.780 --> 00:09:01.300
That means that each cluster
runs the same voltage

00:09:01.300 --> 00:09:03.910
and the same clock frequency,
except for Clock 3 that

00:09:03.910 --> 00:09:07.110
can run at different
frequency from Clock 2.

00:09:07.110 --> 00:09:10.360
Interestingly, even if it
runs at different frequency

00:09:10.360 --> 00:09:16.730
from Clock 2, they still
share the same voltage,

00:09:16.730 --> 00:09:21.470
which means if the voltage
goes up for the last CPU,

00:09:21.470 --> 00:09:23.570
three more CPUs go up.

00:09:23.570 --> 00:09:25.330
Everything consumes a
lot of power to run.

00:09:28.790 --> 00:09:30.080
Big take away here.

00:09:30.080 --> 00:09:35.767
Cores in a cluster always
share the same clock.

00:09:35.767 --> 00:09:37.350
This doesn't make
me happy, because it

00:09:37.350 --> 00:09:39.430
makes my life harder.

00:09:39.430 --> 00:09:42.130
In yours as well.

00:09:42.130 --> 00:09:45.440
On the other hand, it's
much simpler design.

00:09:45.440 --> 00:09:51.170
And it's understandable why
all SOCs are designed this way.

00:09:51.170 --> 00:09:52.559
No exception whatsoever.

00:09:56.960 --> 00:09:58.430
This is another example.

00:09:58.430 --> 00:10:01.600
This is very interesting
because CPUs 0, 1, 2,

00:10:01.600 --> 00:10:04.380
and 3 are little course.

00:10:04.380 --> 00:10:06.820
4, 5, 6, and 7 are big cores.

00:10:06.820 --> 00:10:11.440
Now every SOC I've ever
seen has the first cores

00:10:11.440 --> 00:10:17.300
as little cores with smaller
caches, lower frequencies.

00:10:17.300 --> 00:10:20.450
And the last four
cores, big cores

00:10:20.450 --> 00:10:24.380
or even bigger with larger
caches, higher frequency,

00:10:24.380 --> 00:10:27.680
much faster and much
more power hungry.

00:10:27.680 --> 00:10:29.400
They all look the
same, but please

00:10:29.400 --> 00:10:31.400
still do your due
diligence and try

00:10:31.400 --> 00:10:35.510
to understand the topology
of DSOC programmatically.

00:10:35.510 --> 00:10:36.560
There are ways to do it.

00:10:36.560 --> 00:10:38.300
We can talk about
it later in the game

00:10:38.300 --> 00:10:42.050
reviews if you come over.

00:10:42.050 --> 00:10:45.480
Look at that W. This
is another Unity game.

00:10:45.480 --> 00:10:47.510
W is a worker thread.

00:10:47.510 --> 00:10:51.610
All these worker threads are
running on CPU 4, 5, 6, or 7.

00:10:51.610 --> 00:10:54.640
And little cores will
doing nothing, effectively.

00:10:54.640 --> 00:10:56.920
This could be running
on a little cores,

00:10:56.920 --> 00:11:03.380
consume much less power, and
give the big cores more chances

00:11:03.380 --> 00:11:04.370
to go to sleep.

00:11:04.370 --> 00:11:06.710
Going to sleep means
no power consumed.

00:11:06.710 --> 00:11:10.830
It means lower temperature
in general, less chances

00:11:10.830 --> 00:11:12.450
to throttle.

00:11:12.450 --> 00:11:15.390
Less chances to go into
thermal throttle, less chances

00:11:15.390 --> 00:11:20.400
to get the [INAUDIBLE] hot.

00:11:20.400 --> 00:11:23.070
Because all forms,
sooner or later,

00:11:23.070 --> 00:11:25.380
will overheat and
will be throttled.

00:11:25.380 --> 00:11:27.150
And that's not under control.

00:11:27.150 --> 00:11:28.920
You will not be told why.

00:11:28.920 --> 00:11:31.710
You will not be told when.

00:11:31.710 --> 00:11:33.210
Every device is different.

00:11:33.210 --> 00:11:36.930
Every manufacturer has its own
secret sauce on how to do it.

00:11:36.930 --> 00:11:38.363
It depends on the environment.

00:11:38.363 --> 00:11:39.780
I mean, if you're
play in Finland,

00:11:39.780 --> 00:11:41.970
you can probably for a while.

00:11:41.970 --> 00:11:43.950
If you play in Italy, nope.

00:11:43.950 --> 00:11:49.310
It's hot, in summer, especially.

00:11:49.310 --> 00:11:52.240
You have to do everything in
your power, which means ship

00:11:52.240 --> 00:11:54.880
as much as possible to
execute on little cores

00:11:54.880 --> 00:11:58.771
in order to avoid
thermal throttling.

00:12:02.000 --> 00:12:04.150
At the end of the day
distributor workloads,

00:12:04.150 --> 00:12:07.873
which is very similar from
parallelizing workloads.

00:12:07.873 --> 00:12:10.290
Going multi-threaded will help
you with thermal throttling

00:12:10.290 --> 00:12:10.790
as well.

00:12:16.410 --> 00:12:18.310
Which workload do you
want to run where?

00:12:18.310 --> 00:12:20.000
Well, here's the thing.

00:12:20.000 --> 00:12:22.490
High memory bandwidth,
you're reading a lot

00:12:22.490 --> 00:12:26.960
from the system memory or you
need a lot of cache to go fast.

00:12:26.960 --> 00:12:29.390
Well, this kind of workload
goes well on a big core.

00:12:33.560 --> 00:12:35.510
You're doing a lot of math.

00:12:35.510 --> 00:12:39.140
Well, lots of math
means big core again,

00:12:39.140 --> 00:12:42.830
because have the
math instructions.

00:12:42.830 --> 00:12:47.790
Little cores don't,
so they're much lower.

00:12:47.790 --> 00:12:50.250
Everything else just
[INAUDIBLE] the little cores

00:12:50.250 --> 00:12:51.000
and make me happy.

00:12:58.390 --> 00:12:59.990
This is an
interesting statistic.

00:12:59.990 --> 00:13:01.860
Well, it's not
statistics, it's numbers.

00:13:01.860 --> 00:13:07.910
On a pixel 3, a little core
consumes 31 milli pair,

00:13:07.910 --> 00:13:09.150
big core 215.

00:13:09.150 --> 00:13:13.890
It's a seven times
ratio, which means

00:13:13.890 --> 00:13:19.800
that if you have a piece of work
that you move to a little core,

00:13:19.800 --> 00:13:24.480
if that piece of work takes
less than seven times,

00:13:24.480 --> 00:13:27.300
the time to run when
compared to the big core,

00:13:27.300 --> 00:13:28.770
you're saving power.

00:13:28.770 --> 00:13:32.400
As long as you're running 30
frames per second, you're good.

00:13:32.400 --> 00:13:37.830
That's the kind of memory model
that you have to think about.

00:13:37.830 --> 00:13:43.650
On the latest devices,
this ratio goes up to 20.

00:13:43.650 --> 00:13:46.860
Like it's 20 times
more power hungry.

00:13:46.860 --> 00:13:48.360
And it's highly
unlikely that you're

00:13:48.360 --> 00:13:51.691
going to see workload that runs
30 times faster on little core.

00:13:55.773 --> 00:13:56.440
Keep it in mind.

00:14:00.280 --> 00:14:02.210
Look at the [INAUDIBLE] thread.

00:14:02.210 --> 00:14:04.750
Well, little cores
are doing nothing.

00:14:04.750 --> 00:14:07.581
That goes straight into
a CPU 0, 1, 2, or 3.

00:14:10.177 --> 00:14:11.260
And this is how you do it.

00:14:11.260 --> 00:14:11.980
Set affinity.

00:14:11.980 --> 00:14:14.950
It's just a system call.

00:14:14.950 --> 00:14:17.690
It's pretty straightforward.

00:14:17.690 --> 00:14:22.840
So here's some
code that I wrote.

00:14:22.840 --> 00:14:25.120
I can claim I'm
a programmer now.

00:14:25.120 --> 00:14:29.800
And it just runs a system
call and checks for errors.

00:14:29.800 --> 00:14:31.598
This is like, super
straightforward.

00:14:35.350 --> 00:14:36.780
And this is how you use it.

00:14:36.780 --> 00:14:38.370
If I want to run
on a little core,

00:14:38.370 --> 00:14:43.280
I set the mask to
the first core.

00:14:43.280 --> 00:14:45.340
If I want to run
to the big cores,

00:14:45.340 --> 00:14:48.250
I set the mask to
the last cores,

00:14:48.250 --> 00:14:49.810
and then I set the
thread affinity.

00:14:49.810 --> 00:14:52.650
Super straightforward.

00:14:52.650 --> 00:14:56.280
Just give, do not pin a
thread to a certain core.

00:14:56.280 --> 00:14:58.950
Just leave some room
for the scheduler

00:14:58.950 --> 00:15:01.140
to do its work,
because it's good.

00:15:01.140 --> 00:15:02.550
But pin to certain clusters.

00:15:06.360 --> 00:15:08.470
And now we have only doing time.

00:15:08.470 --> 00:15:09.520
We have 20 minutes left.

00:15:12.390 --> 00:15:13.860
I have a volunteer here.

00:15:16.770 --> 00:15:17.793
And I have my camera.

00:15:17.793 --> 00:15:19.710
This has never been done
before at Google I/O.

00:15:19.710 --> 00:15:22.260
Please, please, please,
please, please, come in.

00:15:22.260 --> 00:15:28.050
I just volunteer you and I'm
going to take photos of him.

00:15:28.050 --> 00:15:29.130
This has never been--

00:15:29.130 --> 00:15:29.880
please be serious.

00:15:29.880 --> 00:15:33.780
Like, do a more
developer-like face.

00:15:33.780 --> 00:15:36.840
Like, a serious one,
more, more, more serious.

00:15:36.840 --> 00:15:38.430
A little bit less serious.

00:15:38.430 --> 00:15:39.480
Look at me.

00:15:39.480 --> 00:15:41.190
Look at me.

00:15:41.190 --> 00:15:43.030
Excellent, excellent.

00:15:43.030 --> 00:15:46.020
[INAUDIBLE] Smile.

00:15:46.020 --> 00:15:47.010
Excellent.

00:15:47.010 --> 00:15:47.900
Thank you very much.

00:15:55.900 --> 00:16:03.505
Didn't lose the-- did I lose
the thing, the clicker thing?

00:16:07.780 --> 00:16:11.050
Did they give you
the clicker thing?

00:16:11.050 --> 00:16:13.120
Do you have a clicking thing?

00:16:13.120 --> 00:16:13.908
It's gone!

00:16:13.908 --> 00:16:14.450
It's amazing!

00:16:18.678 --> 00:16:19.390
I don't know.

00:16:19.390 --> 00:16:19.890
It's gone!

00:16:24.700 --> 00:16:27.590
Sorry?

00:16:27.590 --> 00:16:28.750
No, it's gone!

00:16:28.750 --> 00:16:30.700
Literally disappeared!

00:16:30.700 --> 00:16:31.750
But we have another one.

00:16:39.570 --> 00:16:46.120
Frame pacing is about a
lot about performance.

00:16:46.120 --> 00:16:52.850
And in Systrace
you have this view,

00:16:52.850 --> 00:16:55.780
which basically shows
you were Android

00:16:55.780 --> 00:16:58.810
is latching on your
frame and displaying it.

00:16:58.810 --> 00:17:00.760
That's basically
a very good proxy

00:17:00.760 --> 00:17:05.619
for when my frame is going to
be on screen, when my user is

00:17:05.619 --> 00:17:08.250
going to be seeing my image.

00:17:08.250 --> 00:17:12.290
And if you see bars that
are not evenly spaced--

00:17:12.290 --> 00:17:14.690
like, sometimes sorter,
sometimes bigger--

00:17:14.690 --> 00:17:17.750
that is a sure sign your
having frame pacing issues.

00:17:26.700 --> 00:17:28.480
This gets a little
bit more complicated.

00:17:28.480 --> 00:17:34.310
Like the first bar
up there is when

00:17:34.310 --> 00:17:38.420
your game is done with the
frame and is presenting it

00:17:38.420 --> 00:17:43.600
to the system so it can be
grabbed and be displayed.

00:17:43.600 --> 00:17:49.030
The second bar is a nice vsync
coming every 16.6 seconds,

00:17:49.030 --> 00:17:52.030
60 frames per second.

00:17:52.030 --> 00:17:54.670
Down there is the bar
that we saw before,

00:17:54.670 --> 00:17:56.470
just a little bit the larger.

00:17:56.470 --> 00:17:58.660
Shows you like, the
system is doing something.

00:17:58.660 --> 00:18:01.920
It's sending the frame
to the outer compositor.

00:18:01.920 --> 00:18:02.840
It's doing some work.

00:18:06.110 --> 00:18:10.470
But the point is that
at some point when

00:18:10.470 --> 00:18:13.630
the frame is present
in the queue,

00:18:13.630 --> 00:18:16.210
Android will decide
OK, I gotta frame.

00:18:16.210 --> 00:18:18.060
Off it goes to screen.

00:18:18.060 --> 00:18:20.790
And it took about
50 milliseconds

00:18:20.790 --> 00:18:26.150
in the first instance, because
look at the big circle there.

00:18:26.150 --> 00:18:28.490
We miss the VSYNC.

00:18:28.490 --> 00:18:33.220
We arrived slightly too
late with the VSYNC.

00:18:33.220 --> 00:18:36.335
So Android had
nothing to display.

00:18:36.335 --> 00:18:37.960
Then when there's
something to display,

00:18:37.960 --> 00:18:40.390
Android was doing its work.

00:18:40.390 --> 00:18:45.470
Immediately after the game
is presenting another frame--

00:18:45.470 --> 00:18:49.730
so it is a typical example
of a game presenting as fast

00:18:49.730 --> 00:18:51.390
as possible--

00:18:51.390 --> 00:18:54.270
and then immediately
later Android says great,

00:18:54.270 --> 00:18:55.340
I got the frame.

00:18:55.340 --> 00:18:58.230
off it goes to screen
16 milliseconds later.

00:18:58.230 --> 00:19:02.155
This translates when
you're playing into--

00:19:02.155 --> 00:19:03.780
I'm running at 20
frame for per second.

00:19:03.780 --> 00:19:07.640
And then I'm running a 60
and then 20 and then 60.

00:19:07.640 --> 00:19:11.720
So the user perceive this
as choppy frame rate.

00:19:11.720 --> 00:19:14.230
It's a choppy 60
frames per second.

00:19:14.230 --> 00:19:16.190
One star review straight away.

00:19:16.190 --> 00:19:19.090
It's very disturbing.

00:19:19.090 --> 00:19:23.560
Generally speaking, a 60 frame
per second game that is choppy

00:19:23.560 --> 00:19:27.250
is much worse than a
stable 30 frames per second

00:19:27.250 --> 00:19:28.950
that is nice as move.

00:19:28.950 --> 00:19:32.390
And that's how you
see it on Systrace.

00:19:32.390 --> 00:19:34.030
But that's in largest one.

00:19:37.770 --> 00:19:39.310
I'm slightly larger in the--

00:19:39.310 --> 00:19:41.060
it's the same thing
that we showed before.

00:19:41.060 --> 00:19:44.200
I'm just showing
you also the CPU.

00:19:44.200 --> 00:19:47.860
And we can see that this frame,
which is like the big bar,

00:19:47.860 --> 00:19:54.550
started a couple of milliseconds
too late after the VSYNC.

00:19:54.550 --> 00:19:58.360
And it literally missed
by 100 microseconds.

00:19:58.360 --> 00:20:01.750
It arrived slightly late
by 100 microseconds.

00:20:01.750 --> 00:20:05.380
So Android will present
this frame 60 milliseconds

00:20:05.380 --> 00:20:09.070
too late because we missed
by 100 microseconds.

00:20:09.070 --> 00:20:12.550
We missed because we
started slightly too late.

00:20:12.550 --> 00:20:18.670
Theoretically, this thread would
take less than 33 milliseconds

00:20:18.670 --> 00:20:19.930
to process the frame.

00:20:19.930 --> 00:20:22.880
This could run at 30 frame per
second, no problem whatsoever.

00:20:22.880 --> 00:20:23.910
But it's not.

00:20:23.910 --> 00:20:25.940
And it's not because
the game is too slow.

00:20:25.940 --> 00:20:28.120
It's because it's
missing the frame pacing.

00:20:37.010 --> 00:20:41.210
This is basically the cause
of most frame instabilities

00:20:41.210 --> 00:20:44.840
that I've seen, because
as a game developer,

00:20:44.840 --> 00:20:47.390
you know that if you want
to hit 30 frame per second,

00:20:47.390 --> 00:20:50.540
you have to run a frame in
less than 33 milliseconds.

00:20:50.540 --> 00:20:53.690
Most people do it
because they're good.

00:20:53.690 --> 00:20:55.580
But then they don't
present at the right time

00:20:55.580 --> 00:20:57.050
and the frame rate
is still choppy.

00:20:57.050 --> 00:20:58.790
And you have frame
time stability.

00:20:58.790 --> 00:21:03.530
But not only-- another issue
is imagine a touch input

00:21:03.530 --> 00:21:08.730
that comes when the
first frame that takes 50

00:21:08.730 --> 00:21:11.300
milliseconds to be displayed.

00:21:11.300 --> 00:21:16.800
Well, this is going to be the
showed 60 milliseconds later.

00:21:16.800 --> 00:21:21.410
So I touch and I see the
result of my touch 60

00:21:21.410 --> 00:21:22.400
milliseconds too late.

00:21:22.400 --> 00:21:24.770
And then I see the result
of I touch in the next frame

00:21:24.770 --> 00:21:26.610
like, 60 milliseconds too early.

00:21:26.610 --> 00:21:28.170
And this goes back and forth.

00:21:28.170 --> 00:21:33.160
The brain is trained to expect
input at a certain [INAUDIBLE]..

00:21:33.160 --> 00:21:37.820
If we just kept going back and
forth, it's a bad experience.

00:21:41.660 --> 00:21:42.650
We do have a solution.

00:21:42.650 --> 00:21:45.510
It's called Android
frame pacing API.

00:21:45.510 --> 00:21:47.590
Tian mentioned it before.

00:21:47.590 --> 00:21:51.760
This is a bunch of code that
doesn't live inside of Android.

00:21:51.760 --> 00:21:57.020
It lives as a library and you
can download it and try it.

00:21:57.020 --> 00:22:05.160
It supports several
case scenarios,

00:22:05.160 --> 00:22:06.890
and it's very easy to integrate.

00:22:06.890 --> 00:22:11.540
And basically what it does
is there's an innate--

00:22:11.540 --> 00:22:15.610
there's a swap, and there's
a set a bunch of parameters.

00:22:15.610 --> 00:22:17.860
And from there on,
it will take care

00:22:17.860 --> 00:22:22.240
of making sure that your frame
is nicely presented right

00:22:22.240 --> 00:22:24.890
before the VSYNC.

00:22:24.890 --> 00:22:27.290
And also it will give
you back callbacks

00:22:27.290 --> 00:22:31.010
that you can use to
start your game logic

00:22:31.010 --> 00:22:34.050
right on time in the VSYNC.

00:22:34.050 --> 00:22:36.420
You put the two things together.

00:22:36.420 --> 00:22:41.220
As long as you are running in
less than 30 milliseconds, 33,

00:22:41.220 --> 00:22:41.910
you're good.

00:22:41.910 --> 00:22:44.255
You will be frame
paced perfectly

00:22:44.255 --> 00:22:46.650
at 30 frames per second.

00:22:46.650 --> 00:22:48.865
And that's all done by us.

00:22:48.865 --> 00:22:50.240
You don't have to
care about what

00:22:50.240 --> 00:22:52.370
kinds of devices,
because devices is likely

00:22:52.370 --> 00:22:56.440
different in the way
they treat the VSYNC

00:22:56.440 --> 00:22:58.140
and they treat the logic.

00:22:58.140 --> 00:22:59.950
You just don't have
to care about it.

00:22:59.950 --> 00:23:02.170
Set your frame
interval as you're

00:23:02.170 --> 00:23:08.450
used to and all because it's
available for both Vulcan

00:23:08.450 --> 00:23:09.020
and Open GL.

00:23:12.020 --> 00:23:13.730
This is the [INAUDIBLE].

00:23:13.730 --> 00:23:16.850
It's innate, set
at swap interval,

00:23:16.850 --> 00:23:19.130
and then at some point
in the future, swap.

00:23:19.130 --> 00:23:23.490
When you swap, swap will return
and it will be presented.

00:23:23.490 --> 00:23:25.770
And then you will
have a callback.

00:23:25.770 --> 00:23:28.250
And you can start your
game logic straight away

00:23:28.250 --> 00:23:29.350
at the next VSYNC.

00:23:33.110 --> 00:23:35.120
It also comes with
auto mode, which

00:23:35.120 --> 00:23:42.090
is kind of a peculiar
mode to run in.

00:23:42.090 --> 00:23:43.980
There are situations
where imagine your game

00:23:43.980 --> 00:23:47.670
is running on a device
as not as performant.

00:23:47.670 --> 00:23:49.940
So it mostly hits 30
frames per second,

00:23:49.940 --> 00:23:53.380
but sometimes it slows
down on heavy scene

00:23:53.380 --> 00:23:55.934
and runs at 20 frame per second.

00:23:55.934 --> 00:24:02.050
Well, in the case that
we just saw earlier,

00:24:02.050 --> 00:24:04.140
all the framework come
at 50 frame per second.

00:24:04.140 --> 00:24:06.420
Then the second one
would probably be at 16

00:24:06.420 --> 00:24:07.930
because I arrived like, late.

00:24:07.930 --> 00:24:09.480
But then I present another one.

00:24:09.480 --> 00:24:10.960
Maybe it's going to be at 33.

00:24:10.960 --> 00:24:12.150
I don't know.

00:24:12.150 --> 00:24:14.390
It's going to be as
fast as possible.

00:24:14.390 --> 00:24:16.050
But the framework
will be choppy.

00:24:16.050 --> 00:24:19.710
Auto mode detects this
condition and says good.

00:24:19.710 --> 00:24:21.600
You're running at a stable 20.

00:24:21.600 --> 00:24:24.940
You're not hitting a stable 30?

00:24:24.940 --> 00:24:29.530
Well, I'm going to slowing
down for the time being.

00:24:29.530 --> 00:24:31.310
You can reset at any time.

00:24:31.310 --> 00:24:33.250
But when the frame
rate goes back

00:24:33.250 --> 00:24:36.460
to a more stable 30
frame per second,

00:24:36.460 --> 00:24:38.710
auto mode will
bump you up again.

00:24:38.710 --> 00:24:42.560
It has the very good
consequence that you are also

00:24:42.560 --> 00:24:47.420
going to save battery, because
it will take certain frames

00:24:47.420 --> 00:24:49.080
and will just slow
them down, just

00:24:49.080 --> 00:24:52.470
introduce weightings, which
means CPUs and GPUs will have

00:24:52.470 --> 00:24:53.896
more chances to go to sleep.

00:24:58.250 --> 00:25:03.240
That's how 30 frames
per second looks like.

00:25:03.240 --> 00:25:05.693
This is a stable pacing.

00:25:05.693 --> 00:25:07.110
Now if you come
over there, we can

00:25:07.110 --> 00:25:12.950
show you the frame basic
API on one of the devices.

00:25:12.950 --> 00:25:13.950
We can go more in-depth.

00:25:18.190 --> 00:25:23.940
Last but not least,
this is a fun one

00:25:23.940 --> 00:25:29.670
because you have phones that
are packed with four megapixels

00:25:29.670 --> 00:25:31.930
today.

00:25:31.930 --> 00:25:34.060
And many games make
sure that they're

00:25:34.060 --> 00:25:39.590
going to shape each megapixel,
each pixel in the megapixel.

00:25:39.590 --> 00:25:46.320
Four megapixel, for reference,
is twice give or take,

00:25:46.320 --> 00:25:51.220
a full HD resolution, which
probably a year ago was

00:25:51.220 --> 00:25:54.330
state of the art
console like, rendering

00:25:54.330 --> 00:25:57.400
sent to a 55-inch display.

00:25:57.400 --> 00:25:59.110
And there was like, awesome.

00:25:59.110 --> 00:26:00.430
This is a great looking game.

00:26:00.430 --> 00:26:02.720
It runs at full HD.

00:26:02.720 --> 00:26:05.390
When I was working on
console, I was running a 720.

00:26:05.390 --> 00:26:07.520
720 is one megapixel.

00:26:07.520 --> 00:26:09.770
Now phones, we have four
megapixel packed there.

00:26:09.770 --> 00:26:11.510
You do not need to
shade all of them.

00:26:11.510 --> 00:26:13.570
Please don't.

00:26:13.570 --> 00:26:15.670
Because that's so
I feel about it.

00:26:20.350 --> 00:26:22.510
How do you recognize
that you are probably

00:26:22.510 --> 00:26:23.770
shading too many pixels?

00:26:23.770 --> 00:26:26.080
Well, you're going to
be GPU-bound, likely.

00:26:26.080 --> 00:26:33.550
In SysTrace there is a bar that
gives you the buffer count.

00:26:33.550 --> 00:26:37.510
Buffer count means that the
CPU is presenting a frame.

00:26:37.510 --> 00:26:38.980
Buffer count goes to one.

00:26:38.980 --> 00:26:42.750
The GPU does its own thing,
just shade every single pixel.

00:26:42.750 --> 00:26:46.000
Then the CPU is doing its
work for the next frame.

00:26:46.000 --> 00:26:48.117
And if the GPU
isn't finished yet,

00:26:48.117 --> 00:26:50.450
well, the CPU will just put
another buffer in the field,

00:26:50.450 --> 00:26:52.990
just ready, good to go.

00:26:52.990 --> 00:26:54.480
And then wait, most probably.

00:26:54.480 --> 00:26:57.970
And the GPU will
just try to catch up.

00:26:57.970 --> 00:27:00.940
Well, that's a situation where
this buffer count goes back

00:27:00.940 --> 00:27:03.550
to two.

00:27:03.550 --> 00:27:06.120
Another way of
saying it is well,

00:27:06.120 --> 00:27:10.290
I have a frame that is
presented in 50 milliseconds.

00:27:10.290 --> 00:27:13.140
Let's assume we don't have
any frame pacing issue here.

00:27:13.140 --> 00:27:14.890
We already solved it.

00:27:14.890 --> 00:27:17.880
Well, but my frame time
is taking 40 milliseconds.

00:27:17.880 --> 00:27:21.660
Where the rest of the time
is spent most probably,

00:27:21.660 --> 00:27:24.300
is going to be spent
shading all four megapixel.

00:27:27.240 --> 00:27:30.910
This is very straightforward
to find out in Systrace.

00:27:30.910 --> 00:27:32.760
I've seen a bunch looking
exactly like this.

00:27:35.753 --> 00:27:36.920
Now here's how you solve it.

00:27:39.660 --> 00:27:43.950
Instead of a 3K by
1440 display, instead

00:27:43.950 --> 00:27:48.000
of rendering to all of it,
well, create a render target

00:27:48.000 --> 00:27:49.350
that is smaller.

00:27:49.350 --> 00:27:54.570
And make sure that you only
stretch in one direction.

00:27:54.570 --> 00:27:56.267
Reason is when you
interpolate back,

00:27:56.267 --> 00:27:58.350
it's going to be much
higher quality and much more

00:27:58.350 --> 00:27:59.700
cache [INAUDIBLE].

00:28:03.450 --> 00:28:07.710
And make sure that your
only rendering your gain

00:28:07.710 --> 00:28:10.380
word into this
smaller render target.

00:28:10.380 --> 00:28:11.640
Not your UI.

00:28:11.640 --> 00:28:15.240
The UI has generally thin things
and thin lines and phones.

00:28:15.240 --> 00:28:18.530
They don't scale well just
rendering at full resolution.

00:28:18.530 --> 00:28:23.700
UIs, except for some cases,
tend not to be too heavy.

00:28:23.700 --> 00:28:25.380
So they can go at
full resolution

00:28:25.380 --> 00:28:27.900
and then composite the two.

00:28:27.900 --> 00:28:32.100
In this case, you're
saving 58% of the pixels.

00:28:32.100 --> 00:28:38.130
This is going to be roughly
a full HD still on a smaller

00:28:38.130 --> 00:28:39.265
screen.

00:28:39.265 --> 00:28:40.390
It's going to look amazing.

00:28:40.390 --> 00:28:41.432
It's going to look great.

00:28:41.432 --> 00:28:42.960
Nobody's going to see it.

00:28:42.960 --> 00:28:45.450
If your artists think
that they're going to see

00:28:45.450 --> 00:28:48.900
the difference, just tell
them that they won't.

00:28:48.900 --> 00:28:52.710
If they still
insist, use my trick.

00:28:52.710 --> 00:28:55.380
I never told artists
that I was doing

00:28:55.380 --> 00:28:57.050
any of these optimizations.

00:28:57.050 --> 00:28:58.560
And they never spotted me.

00:28:58.560 --> 00:28:59.910
That's why I'm still here.

00:28:59.910 --> 00:29:03.500
If they spotted me,
I probably wouldn't--

00:29:03.500 --> 00:29:04.890
my artists were awfully mean.

00:29:07.620 --> 00:29:09.450
To do the resize,
it cost some time.

00:29:09.450 --> 00:29:12.600
It's got some GPU time because
you have to interpolate back

00:29:12.600 --> 00:29:15.890
to full screen for
the final presentation

00:29:15.890 --> 00:29:17.790
and final compositing.

00:29:17.790 --> 00:29:22.520
And every Android device
has an hardware composer

00:29:22.520 --> 00:29:27.680
that is not exposed to
the user, which doesn't

00:29:27.680 --> 00:29:30.640
make me particularly happy.

00:29:30.640 --> 00:29:37.210
On the other hand, any game that
would probably use this kind

00:29:37.210 --> 00:29:40.570
of techniques and will probably
be GPU bound has some kind

00:29:40.570 --> 00:29:43.230
of post-processing and
tone mapping at the end,

00:29:43.230 --> 00:29:44.710
where you're doing--

00:29:44.710 --> 00:29:46.270
I don't know-- some
kind of blooming

00:29:46.270 --> 00:29:48.200
some kind of color correction.

00:29:48.200 --> 00:29:52.790
Well, you can do the
process of stretching back

00:29:52.790 --> 00:29:57.100
to full resolution in
the post-processing step.

00:29:57.100 --> 00:29:59.590
It comes out not for free
because nothing is free,

00:29:59.590 --> 00:30:03.970
but it's a nice way
to hide the time

00:30:03.970 --> 00:30:07.810
and to use it for
something useful.

00:30:07.810 --> 00:30:12.490
This is a pretty common way
of doing the stretching back.

00:30:12.490 --> 00:30:14.950
The important thing-- and I
want to stress this point,

00:30:14.950 --> 00:30:17.860
is that please stretch
only one direction.

00:30:17.860 --> 00:30:22.320
Do not resize in two directions.

00:30:22.320 --> 00:30:25.387
The quality is much higher if
you do it in one direction.

00:30:29.500 --> 00:30:36.490
We've seen these
four big, I would

00:30:36.490 --> 00:30:40.100
say, performance pitfalls.

00:30:40.100 --> 00:30:44.420
And I showed you various
ways to tackle it.

00:30:44.420 --> 00:30:48.230
Now you have a better
knowledge of what

00:30:48.230 --> 00:30:50.510
you can encounter in the
field, and a better knowledge

00:30:50.510 --> 00:30:53.670
of how to solve these issues.

00:30:53.670 --> 00:30:57.460
They're pretty easy
at the end of the day,

00:30:57.460 --> 00:30:59.990
except probably the last one.

00:30:59.990 --> 00:31:02.120
It doesn't take long
to implement it.

00:31:02.120 --> 00:31:05.920
And use this knowledge now.

00:31:05.920 --> 00:31:09.790
Please go there and
make some great games.

00:31:09.790 --> 00:31:11.580
My name is Francesco Carucci.

00:31:11.580 --> 00:31:14.930
[MUSIC PLAYING]

