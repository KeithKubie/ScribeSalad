WEBVTT
Kind: captions
Language: en

00:00:03.147 --> 00:00:04.230
PROFESSOR: Continue today.

00:00:04.230 --> 00:00:06.930
We're still in the
spirit of origami.

00:00:06.930 --> 00:00:09.930
And we're going to do some
origami design and foldability

00:00:09.930 --> 00:00:12.830
again.

00:00:12.830 --> 00:00:15.710
There are two main topics
here on the design side

00:00:15.710 --> 00:00:19.930
we're going to talk about--
universal hinge patterns, which

00:00:19.930 --> 00:00:24.050
are the things that make
underlying this robot, which

00:00:24.050 --> 00:00:25.050
I showed in lecture one.

00:00:25.050 --> 00:00:26.150
You may recall.

00:00:26.150 --> 00:00:29.030
So it's called a
box pleat pattern.

00:00:29.030 --> 00:00:32.419
It's a square grid with
alternating diagonal creases.

00:00:32.419 --> 00:00:33.960
And the idea with
the robot is you're

00:00:33.960 --> 00:00:37.451
constrained to only-- you have
to build the creases ahead

00:00:37.451 --> 00:00:37.950
of time.

00:00:37.950 --> 00:00:40.440
You can't say, you
can't build one sheet

00:00:40.440 --> 00:00:42.084
that can fold
anywhere at anytime.

00:00:42.084 --> 00:00:43.500
You want to build
a sheet that can

00:00:43.500 --> 00:00:47.450
fold at any of the crease
lines, at the built

00:00:47.450 --> 00:00:49.870
crease lines whenever you want.

00:00:49.870 --> 00:00:53.860
And so whereas with
something like Origamizer,

00:00:53.860 --> 00:00:57.230
every design has a completely
different crease pattern

00:00:57.230 --> 00:00:59.680
and it's difficult to
control that, here we

00:00:59.680 --> 00:01:01.354
wanted to make one.

00:01:01.354 --> 00:01:02.770
It's not exactly
a crease pattern,

00:01:02.770 --> 00:01:03.990
because you're not
using all the creases.

00:01:03.990 --> 00:01:05.590
It's what we call
a hinge pattern,

00:01:05.590 --> 00:01:08.710
all the possible places
you could fold that thing

00:01:08.710 --> 00:01:10.520
and make lots of
different shapes

00:01:10.520 --> 00:01:13.300
from that one hinge pattern.

00:01:13.300 --> 00:01:16.714
So that's the first
part of the lecture.

00:01:16.714 --> 00:01:19.130
And the second part of the
lecture will be about hardness.

00:01:19.130 --> 00:01:21.550
And we'll see, I think,
four different kinds

00:01:21.550 --> 00:01:24.460
of origami problems
which are all NP-hard.

00:01:24.460 --> 00:01:26.360
And I'll tell you
what NP-hard means.

00:01:26.360 --> 00:01:27.924
And we'll prove all that.

00:01:27.924 --> 00:01:29.340
So there are lots
of problems that

00:01:29.340 --> 00:01:31.430
are computationally intractable.

00:01:31.430 --> 00:01:35.750
And we're going to cluster them
all together into one lecture.

00:01:35.750 --> 00:01:38.540
Because it's kind of fun
to see them together.

00:01:38.540 --> 00:01:42.780
Mostly we've been talking
about positive results so far.

00:01:42.780 --> 00:01:44.920
All right, so let's do
universal hinge patterns.

00:01:55.766 --> 00:01:56.890
This is pretty recent work.

00:01:56.890 --> 00:01:59.400
It just appeared at the
big origami math conference

00:01:59.400 --> 00:02:00.640
this summer.

00:02:00.640 --> 00:02:06.370
And its work by Nadia, and me,
and Marty, and Aviv Ovadya,

00:02:06.370 --> 00:02:10.039
who I think actually came out
of this class three years ago,

00:02:10.039 --> 00:02:10.720
if I recall.

00:02:10.720 --> 00:02:15.530
It just took us awhile
to write it all up.

00:02:15.530 --> 00:02:18.220
And it's why the robot
has a box pleat pattern.

00:02:22.140 --> 00:02:27.650
So the idea is to require that
the crease pattern of whatever

00:02:27.650 --> 00:02:36.940
you want to fold must be a
subset of some fixed hinge

00:02:36.940 --> 00:02:37.440
pattern.

00:02:41.520 --> 00:02:44.310
And the goal is to make one
hinge pattern to rule them

00:02:44.310 --> 00:02:47.190
all, one hinge pattern
that you can make anything.

00:02:47.190 --> 00:02:50.179
I mean you can't make literally
anything, I don't think.

00:02:50.179 --> 00:02:51.720
I was wondering
about this yesterday.

00:02:51.720 --> 00:02:55.840
But we're not going to
try to make everything out

00:02:55.840 --> 00:02:57.500
of one hinge pattern.

00:02:57.500 --> 00:02:59.410
But we want to make
lots of different things

00:02:59.410 --> 00:03:01.590
somehow from one hinge pattern.

00:03:01.590 --> 00:03:05.360
And here's the theorem
that formalizes

00:03:05.360 --> 00:03:06.710
this idea of lots of things.

00:03:09.650 --> 00:03:12.360
We're going to take the box
pleat pattern from an n by n.

00:03:12.360 --> 00:03:22.220
Grid so that's you take
a square grid, n by n.

00:03:22.220 --> 00:03:24.045
And then you fill in
alternating diagonals.

00:03:36.500 --> 00:03:40.350
Then that thing
that hinge pattern

00:03:40.350 --> 00:03:43.350
can make by using a
subset of those creases,

00:03:43.350 --> 00:03:51.520
you can make any
polycube of n cubes.

00:03:56.760 --> 00:03:58.160
I'm sorry, order n cubes.

00:04:03.050 --> 00:04:05.716
And what else?

00:04:05.716 --> 00:04:07.170
You can even do it seamless.

00:04:12.420 --> 00:04:15.824
So a polycube made of n cubes
is just you take n cubes.

00:04:15.824 --> 00:04:17.240
And you start
gluing them together

00:04:17.240 --> 00:04:21.230
face to face until you
have one connected monster.

00:04:21.230 --> 00:04:24.160
And that's a polycube.

00:04:24.160 --> 00:04:27.173
So you can make, for
example, I don't know,

00:04:27.173 --> 00:04:29.240
all the Tetris pieces.

00:04:29.240 --> 00:04:31.580
Tetris pieces would
be four cubes.

00:04:31.580 --> 00:04:37.890
Normally they're squares, but
you can 3-dimensionalize them.

00:04:37.890 --> 00:04:39.140
That's a four cube polycube.

00:04:39.140 --> 00:04:41.180
And you get the general idea.

00:04:41.180 --> 00:04:43.740
So this is cool because
there are exponentially

00:04:43.740 --> 00:04:46.250
many polycubes with n cubes.

00:04:46.250 --> 00:04:49.050
And here is one pattern
that can make all of them.

00:04:49.050 --> 00:04:51.130
And if you imagine
some crazy 3D shape,

00:04:51.130 --> 00:04:54.270
you can, of course,
approximate it by cubes,

00:04:54.270 --> 00:04:56.880
sort of voxelization
is the usual term,

00:04:56.880 --> 00:04:58.960
the same way that
we pixelize images.

00:04:58.960 --> 00:05:01.180
And then you can make
basically anything

00:05:01.180 --> 00:05:04.337
you want up to the resolution
provided by your sheet.

00:05:04.337 --> 00:05:06.295
So that's the sense in
which this is universal.

00:05:12.650 --> 00:05:15.500
So let's prove that.

00:05:15.500 --> 00:05:20.890
It's actually not too hard
to do in at least one way.

00:05:20.890 --> 00:05:25.750
The first idea is to build
something called a cube gadget.

00:05:28.565 --> 00:05:30.940
We're going to use the idea
of a gadget a lot, especially

00:05:30.940 --> 00:05:31.700
in this lecture.

00:05:31.700 --> 00:05:33.658
But in general, it's a
useful algorithmic tool.

00:05:33.658 --> 00:05:37.270
A gadget is just something
that you reuse many times.

00:05:37.270 --> 00:05:38.720
It's like a tool.

00:05:38.720 --> 00:05:45.420
And in this case, we're going
to use this folding many times.

00:05:45.420 --> 00:05:48.840
At a high level, it's just
a way to fold a single cube.

00:05:48.840 --> 00:05:50.430
But it has lots of
nice properties.

00:05:50.430 --> 00:05:52.210
So this is a crease pattern.

00:05:52.210 --> 00:05:53.210
Red lines are mountains.

00:05:53.210 --> 00:05:55.650
Blue dashed lines are valleys.

00:05:55.650 --> 00:05:59.050
It folds into this thing,
which you can see is a cube.

00:05:59.050 --> 00:06:01.130
Here it's some
semi-transparent material.

00:06:01.130 --> 00:06:05.150
And there's some pleats coming
out in the four directions.

00:06:05.150 --> 00:06:08.530
But it's basically
a cube on a plane.

00:06:08.530 --> 00:06:11.050
So we started with a
plane, a rectangle.

00:06:11.050 --> 00:06:12.920
We fold that pattern.

00:06:12.920 --> 00:06:17.130
And you get a rectangle
plus a cube sticking out.

00:06:17.130 --> 00:06:20.570
OK, so in particular, I can make
a one cube polycube out of this

00:06:20.570 --> 00:06:24.140
if I just made this, got
rid of the rectangular part.

00:06:24.140 --> 00:06:27.930
But by using this
gadget n times,

00:06:27.930 --> 00:06:30.740
I claim I can make
an n cube polycube.

00:06:30.740 --> 00:06:33.580
And this kind of a crazy
idea that, so for example,

00:06:33.580 --> 00:06:38.669
suppose the starting sheet
was not just a rectangle.

00:06:38.669 --> 00:06:40.960
But suppose it was a rectangle
with a cube sticking out

00:06:40.960 --> 00:06:42.530
right here.

00:06:42.530 --> 00:06:43.950
I could still do this folding.

00:06:43.950 --> 00:06:45.950
Because this folding
didn't touch The gray lines

00:06:45.950 --> 00:06:46.860
are not creases.

00:06:46.860 --> 00:06:48.270
They're just hinges.

00:06:48.270 --> 00:06:51.480
If I had a cube sticking out
here. and I folded this thing,

00:06:51.480 --> 00:06:53.920
it would now be a rectangle
with a cube in the center

00:06:53.920 --> 00:06:55.640
and a cube sticking
out of this corner.

00:06:55.640 --> 00:06:58.840
Because that corner just
folds to right there.

00:06:58.840 --> 00:07:01.917
In fact, I could have a cube
sticking out right here also.

00:07:01.917 --> 00:07:03.750
And then there'd be a
cube sticking out here

00:07:03.750 --> 00:07:05.180
in the finished product.

00:07:05.180 --> 00:07:08.680
And the idea is to just
keep using this gadget.

00:07:08.680 --> 00:07:10.850
And make your sheet
bumpier and bumpier

00:07:10.850 --> 00:07:13.312
with more and more
cubes sticking out.

00:07:13.312 --> 00:07:15.190
And this is the
sort of thing if you

00:07:15.190 --> 00:07:17.040
wanted to make-- so
there I had cubes

00:07:17.040 --> 00:07:19.264
that were separated
from each other.

00:07:19.264 --> 00:07:21.680
If you want to have cubes that
are attached to each other,

00:07:21.680 --> 00:07:23.720
you can do that too.

00:07:23.720 --> 00:07:28.970
Because all right, say here,
if you apply the cube gadget

00:07:28.970 --> 00:07:30.800
at this center
square, so you want

00:07:30.800 --> 00:07:33.730
to pull a cube out from there.

00:07:33.730 --> 00:07:37.100
Maybe I should show you
in the previous diagram.

00:07:37.100 --> 00:07:42.910
So you have these four squares
around the center square

00:07:42.910 --> 00:07:47.570
make up the four sides of the
cube, other than the top side.

00:07:47.570 --> 00:07:51.110
And so if you already had
a cube on that side face,

00:07:51.110 --> 00:07:52.650
when you fold this
thing, you end up

00:07:52.650 --> 00:07:57.130
with a cube that has a
cube attached on its right.

00:07:57.130 --> 00:07:59.520
So if I wave my hands
enough, I believe

00:07:59.520 --> 00:08:01.920
that it's possible to
make anything in this way.

00:08:01.920 --> 00:08:05.900
Let me convince you a
little more formally.

00:08:05.900 --> 00:08:06.710
Let's see.

00:08:06.710 --> 00:08:08.450
Here's a real example.

00:08:08.450 --> 00:08:10.560
It gives you an idea of
how you can make even

00:08:10.560 --> 00:08:12.100
overhanging cubes.

00:08:12.100 --> 00:08:16.880
All I did was initially
I made this first cube.

00:08:16.880 --> 00:08:20.610
Then I made this cube with
this one attached to the side,

00:08:20.610 --> 00:08:22.570
just like the previous picture.

00:08:22.570 --> 00:08:26.030
And then I just made another
cube right underneath that one,

00:08:26.030 --> 00:08:29.170
so this cube was already
attached to the center square.

00:08:29.170 --> 00:08:31.820
And it just got raised
up by another cube.

00:08:31.820 --> 00:08:33.762
So now you've got
this L overhang.

00:08:33.762 --> 00:08:35.470
And this is not quite
the crease pattern.

00:08:35.470 --> 00:08:37.840
This is there's some lines
that are not drawn here.

00:08:37.840 --> 00:08:41.650
But it's a rough sketch
of the crease pattern.

00:08:41.650 --> 00:08:44.320
Let's see.

00:08:44.320 --> 00:08:45.860
I'll worry about the rest next.

00:08:45.860 --> 00:08:48.565
Let me give you a little bit
of an argument why this works.

00:08:53.040 --> 00:08:58.710
So a cube gadget
let's say transforms

00:08:58.710 --> 00:09:07.640
a constant number of rows
and columns of the grid

00:09:07.640 --> 00:09:13.040
into a cube that's
sticking out of your sheet.

00:09:21.040 --> 00:09:24.250
And the key property is
it works even if there

00:09:24.250 --> 00:09:35.150
are bumps on your
sheet elsewhere.

00:09:35.150 --> 00:09:38.860
So when I say elsewhere, let me
show you the cube gadget again.

00:09:42.420 --> 00:09:47.500
There's actually two columns
sort of getting used up here.

00:09:47.500 --> 00:09:50.210
And there's one row
getting used up there.

00:09:50.210 --> 00:09:52.347
Sorry, actually one row here.

00:09:52.347 --> 00:09:54.430
So there's one row and two
columns in this corner.

00:09:54.430 --> 00:09:57.240
And there's actually one
row and two columns used up

00:09:57.240 --> 00:09:57.950
in each corner.

00:09:57.950 --> 00:10:01.130
And that material disappears
in some sense from the folding

00:10:01.130 --> 00:10:02.300
up here.

00:10:02.300 --> 00:10:05.020
But all the other
stuff, this column,

00:10:05.020 --> 00:10:07.885
everything out in this
corner, and those four squares

00:10:07.885 --> 00:10:09.510
around the center
and the center square

00:10:09.510 --> 00:10:11.604
itself, those can
all have bumps.

00:10:11.604 --> 00:10:13.770
You better not have bumps
here where I need to fold.

00:10:13.770 --> 00:10:15.590
But everywhere else
can have bumps.

00:10:15.590 --> 00:10:19.920
And it's OK-- so I just need
to set up my bump pattern so

00:10:19.920 --> 00:10:22.330
that when I finish
making that cube,

00:10:22.330 --> 00:10:25.540
I have the bumps
in the right place.

00:10:25.540 --> 00:10:28.520
So it's sort of a working
backwards process.

00:10:28.520 --> 00:10:35.790
And the idea is to
make a tree of cubes.

00:10:35.790 --> 00:10:39.010
So if you want to make
something that has cycles in it,

00:10:39.010 --> 00:10:42.690
like a big n by n
by n cube array,

00:10:42.690 --> 00:10:45.060
you can just cut it
up, subdivide it,

00:10:45.060 --> 00:10:48.230
so that it's just
a tree of objects.

00:10:48.230 --> 00:10:56.390
So for example, suppose I wanted
to build this shape, which

00:10:56.390 --> 00:10:57.860
is not really a tree.

00:10:57.860 --> 00:11:04.730
I can just pretend that
there's a slice here.

00:11:08.860 --> 00:11:10.940
So these guys are
connected in a path.

00:11:10.940 --> 00:11:12.800
But they're not connected here.

00:11:12.800 --> 00:11:15.270
In general, you can
just keep slicing

00:11:15.270 --> 00:11:19.530
until your thing is
connected like a tree.

00:11:19.530 --> 00:11:22.520
Then once you have a tree,
you may know this fact,

00:11:22.520 --> 00:11:26.940
every tree has at least two
leaves except in winter.

00:11:26.940 --> 00:11:31.390
But in this context,
we're thinking of a tree.

00:11:31.390 --> 00:11:33.880
Here the tree is just this path.

00:11:33.880 --> 00:11:36.690
And a leaf is a vertex
that has degree one.

00:11:36.690 --> 00:11:38.600
And every leaf has
at least, every tree

00:11:38.600 --> 00:11:42.950
has at least two leaves
is a fun fact about trees.

00:11:42.950 --> 00:11:49.350
And so what we do to make
this thing is make a leaf.

00:11:49.350 --> 00:11:51.970
So what I mean is we
start with a blank sheet.

00:11:51.970 --> 00:11:53.990
And we'll say OK, here's a leaf.

00:11:53.990 --> 00:11:55.840
I'm going to build
that cube first.

00:11:55.840 --> 00:11:57.510
So you apply cube gadget.

00:11:57.510 --> 00:11:59.250
You build a cube.

00:11:59.250 --> 00:12:02.570
Then you effectively
remove that leaf.

00:12:02.570 --> 00:12:04.682
Just pretend it was never there.

00:12:04.682 --> 00:12:06.140
This is sort of a
conceptual thing.

00:12:06.140 --> 00:12:10.800
You're not really removing
it, but and then you repeat.

00:12:14.100 --> 00:12:15.800
It's actually a super
simple algorithm.

00:12:15.800 --> 00:12:18.150
The details are a
little bit tricky,

00:12:18.150 --> 00:12:20.230
because we have to make
sure that this works.

00:12:20.230 --> 00:12:25.749
But once I remove that cube,
now my graph is like this.

00:12:25.749 --> 00:12:26.540
So I have a choice.

00:12:26.540 --> 00:12:30.940
I could either fold this leaf
next, or I could fold this one.

00:12:30.940 --> 00:12:31.830
I just keep going.

00:12:31.830 --> 00:12:34.240
In this case, I could just
go linearly along the path,

00:12:34.240 --> 00:12:37.330
like I did for making
the overhanging L.

00:12:37.330 --> 00:12:39.660
And you will make all the cubes.

00:12:39.660 --> 00:12:42.361
And the property you'll have is
that whenever I build a cube,

00:12:42.361 --> 00:12:44.110
all the things that
were hanging off of it

00:12:44.110 --> 00:12:45.910
have already been built.

00:12:45.910 --> 00:12:49.510
Because I'm always working
from the leaves up the tree.

00:12:49.510 --> 00:12:53.382
This is, for those
who know trees,

00:12:53.382 --> 00:12:54.965
this is called a
post-order traversal.

00:12:59.900 --> 00:13:02.680
It just means whenever
I touch a node, whenever

00:13:02.680 --> 00:13:05.570
I create a node, all
of its descendants, all

00:13:05.570 --> 00:13:08.060
of the leaves below it,
have already been built.

00:13:08.060 --> 00:13:10.640
And that's exactly how
this thing needs to work.

00:13:10.640 --> 00:13:12.354
Because you can have
existing bumps which

00:13:12.354 --> 00:13:14.270
are the things that were
attached to that cube

00:13:14.270 --> 00:13:16.972
and sort of are
deeper in the tree.

00:13:16.972 --> 00:13:17.680
Those are harder.

00:13:17.680 --> 00:13:18.810
You can't make those later.

00:13:18.810 --> 00:13:20.470
As long as they're
already built,

00:13:20.470 --> 00:13:22.250
you just sort of keep
working up the tree.

00:13:22.250 --> 00:13:24.500
And the stuff you've
already built hangs off.

00:13:24.500 --> 00:13:26.310
In the end, you'll
have your entire tree.

00:13:26.310 --> 00:13:29.090
And you'll have your polycube.

00:13:29.090 --> 00:13:30.080
That's it.

00:13:30.080 --> 00:13:33.720
So there are obviously details
here that I'm skipping.

00:13:33.720 --> 00:13:38.330
But I think this is
a fun essence of it.

00:13:38.330 --> 00:13:40.790
Another fact, this is
essentially optimal.

00:13:40.790 --> 00:13:45.520
So I'm using an n by n grid
to make around n cubes.

00:13:45.520 --> 00:13:48.170
You might hope in some
cases you can do better.

00:13:48.170 --> 00:13:50.840
In some cases, you can make
n squared cubes out of an n

00:13:50.840 --> 00:13:51.380
by n grid.

00:13:51.380 --> 00:13:53.510
That's the best case.

00:13:53.510 --> 00:13:55.670
The worst case
really is n cubes.

00:13:55.670 --> 00:14:02.154
Because if you want to
make a super long polycube,

00:14:02.154 --> 00:14:09.640
a one by one by n grid, then
the diameter of this thing

00:14:09.640 --> 00:14:11.090
is about n.

00:14:11.090 --> 00:14:13.660
And the diameter of my
square paper is like

00:14:13.660 --> 00:14:15.180
maybe root 2 times n.

00:14:15.180 --> 00:14:16.850
So maybe I could
save a root 2 factor.

00:14:16.850 --> 00:14:20.190
But just to get this diameter
n, I'm going to need about an n

00:14:20.190 --> 00:14:21.550
by n sheet.

00:14:21.550 --> 00:14:23.480
So in the worst case,
this is the best

00:14:23.480 --> 00:14:25.540
you can hope for from
our usual diameter

00:14:25.540 --> 00:14:28.247
argument like last class.

00:14:28.247 --> 00:14:29.580
But sometimes you can do better.

00:14:29.580 --> 00:14:36.620
So for example, here is an
MIT made by Aviv Ovadya.

00:14:36.620 --> 00:14:40.090
And this is much more
efficient, in some sense

00:14:40.090 --> 00:14:44.290
because everything
here is height one.

00:14:44.290 --> 00:14:48.030
You can share a lot
of those pleats.

00:14:48.030 --> 00:14:51.440
You don't have to waste rows
for every single gadget.

00:14:51.440 --> 00:14:53.920
You just, you can
share those wasted rows

00:14:53.920 --> 00:14:57.430
along all the guys
who are aligned.

00:14:57.430 --> 00:14:59.655
And general picture,
this is actually

00:14:59.655 --> 00:15:01.650
Aviv's master's thesis.

00:15:04.529 --> 00:15:07.070
The way I described it, if you
wanted to make two cubes right

00:15:07.070 --> 00:15:10.810
next to each other, you fold
two separate cube gadgets

00:15:10.810 --> 00:15:13.640
that each use up their
rows and columns.

00:15:13.640 --> 00:15:16.400
You can be a little bit more
clever like I was saying

00:15:16.400 --> 00:15:20.980
and share those used up
rows between the two guys.

00:15:20.980 --> 00:15:22.890
Because they are
horizontally aligned.

00:15:22.890 --> 00:15:24.810
And it's a little
more efficient.

00:15:24.810 --> 00:15:29.030
And that's essentially
what's done in that example.

00:15:29.030 --> 00:15:30.950
But there's still some
sort of wastage here.

00:15:30.950 --> 00:15:32.325
You don't really
need to do that.

00:15:32.325 --> 00:15:35.750
You really want to build
the two by one thing.

00:15:35.750 --> 00:15:38.470
And with some fancier version of
the algorithm, you can do that.

00:15:38.470 --> 00:15:39.970
If you want to check
it out, you can

00:15:39.970 --> 00:15:43.720
see Aviv's [INAUDIBLE]
thesis, which

00:15:43.720 --> 00:15:47.100
was just completed last month.

00:15:47.100 --> 00:15:52.370
And yeah, we don't have a formal
sense in which in how much

00:15:52.370 --> 00:15:53.210
better this is.

00:15:53.210 --> 00:15:55.382
But it's sort of
opportunistic, tries

00:15:55.382 --> 00:15:56.465
to be as good as possible.

00:16:00.440 --> 00:16:06.040
And that is one version
of box pleating.

00:16:06.040 --> 00:16:09.600
But in the same spirit, I want
to talk about another situation

00:16:09.600 --> 00:16:13.040
where we can do very well.

00:16:13.040 --> 00:16:17.030
And here we can prove
that we can do very well.

00:16:17.030 --> 00:16:19.990
So again, trying to
be more efficient

00:16:19.990 --> 00:16:22.750
and this sort of square wasted.

00:16:22.750 --> 00:16:24.350
We have n squared of material.

00:16:24.350 --> 00:16:25.910
We only make n things.

00:16:25.910 --> 00:16:29.220
Be really nice if we could make
n squared things out of an n

00:16:29.220 --> 00:16:32.290
by n grid.

00:16:32.290 --> 00:16:35.270
And oh, here's another
fun example which uses

00:16:35.270 --> 00:16:37.220
all those optimizations
building a car.

00:16:37.220 --> 00:16:41.930
This one there's a real version
of, but I don't have it here.

00:16:41.930 --> 00:16:47.000
And where we can be particularly
efficient is maze folding.

00:16:47.000 --> 00:16:51.600
So suppose you take a
graph on an n by n grid.

00:16:51.600 --> 00:16:54.170
Here it happens
not to be square.

00:16:54.170 --> 00:16:56.400
And then you just sort
of extrude that graph

00:16:56.400 --> 00:16:57.960
out from the sheet.

00:16:57.960 --> 00:16:59.750
That would give you
a bunch of walls

00:16:59.750 --> 00:17:03.500
in an orthogonal, 3D pattern.

00:17:03.500 --> 00:17:08.329
Let's say I extrude by one
unit, one unit of this square.

00:17:08.329 --> 00:17:11.540
And I claim I can
fold this 3D shape

00:17:11.540 --> 00:17:17.490
from a square of paper
that is just 3n by 3n.

00:17:17.490 --> 00:17:20.200
So it's just a constant
factor shrinkage.

00:17:20.200 --> 00:17:24.022
And this is essentially the
best you could hope for.

00:17:24.022 --> 00:17:26.160
Yeah, should I try to argue it.

00:17:26.160 --> 00:17:29.730
So if you look at where did
this material come from,

00:17:29.730 --> 00:17:32.610
well you've got to go up
this wall, down this wall,

00:17:32.610 --> 00:17:34.560
over the side, up the
wall, down the wall,

00:17:34.560 --> 00:17:36.961
over, over, over,
over, up, down.

00:17:36.961 --> 00:17:38.710
And in general, you
have to go up and down

00:17:38.710 --> 00:17:40.340
and along the floor.

00:17:40.340 --> 00:17:45.550
So that's three for every
square that you have here.

00:17:45.550 --> 00:17:46.670
So that's maze folding.

00:17:46.670 --> 00:17:50.650
And this is work with
Jason Ku and Marty, also

00:17:50.650 --> 00:17:55.010
from the big origami
conference this summer.

00:18:07.690 --> 00:18:09.500
So you could call it a maze.

00:18:09.500 --> 00:18:11.610
You could call it a graph.

00:18:11.610 --> 00:18:12.740
But it's orthogonal.

00:18:12.740 --> 00:18:14.380
It's on the grid.

00:18:14.380 --> 00:18:18.610
And it's extruded from an
n by n square let's say.

00:18:21.358 --> 00:18:31.820
And that thing can be
folded from an order n

00:18:31.820 --> 00:18:34.930
by order n square of paper.

00:18:38.920 --> 00:18:44.164
And if you're extruding by one
unit, this big O at that three.

00:18:44.164 --> 00:18:45.580
And to me this is
really exciting.

00:18:45.580 --> 00:18:49.950
Because one of the big mysteries
to me in origami design

00:18:49.950 --> 00:18:52.440
is in practical origami, you
usually start with a sheet.

00:18:52.440 --> 00:18:55.410
And you make something that's
like two or three times smaller

00:18:55.410 --> 00:18:57.494
and never much more.

00:18:57.494 --> 00:18:59.660
And it would be really nice
to capture theoretically

00:18:59.660 --> 00:19:03.130
what things can you make by only
shrinking by a constant factor.

00:19:03.130 --> 00:19:05.870
Like checkerboards,
we know, or we think,

00:19:05.870 --> 00:19:07.470
you have to shrink a lot.

00:19:07.470 --> 00:19:08.970
For an n by n
checkerboard, you have

00:19:08.970 --> 00:19:12.580
to shrink by like factor
of n over 2, n over 4,

00:19:12.580 --> 00:19:14.090
whatever the best bound is.

00:19:14.090 --> 00:19:16.287
But it seems the more
complicated you want,

00:19:16.287 --> 00:19:17.370
the more you have to fold.

00:19:17.370 --> 00:19:19.850
Here, I can make a
super complicated maze.

00:19:19.850 --> 00:19:21.780
It could be a
million by million.

00:19:21.780 --> 00:19:25.520
And I'm still only shrinking
the sheet by a factor of three.

00:19:25.520 --> 00:19:27.330
So this is one of
the few results

00:19:27.330 --> 00:19:29.550
we know where you can
get a large class,

00:19:29.550 --> 00:19:33.800
and yet you're only
shrinking by small factor.

00:19:33.800 --> 00:19:37.340
The proof of this is also
pretty easy, in fact even easier

00:19:37.340 --> 00:19:39.514
than the previous one.

00:19:39.514 --> 00:19:40.930
Again, we're going
to use gadgets.

00:19:40.930 --> 00:19:44.580
And we're going to combine
them in different ways.

00:19:44.580 --> 00:19:48.840
But the idea is we
just make a gadget

00:19:48.840 --> 00:19:53.020
for each possible
vertex in this graph.

00:19:55.570 --> 00:20:00.340
So a vertex in the graph could
have no edges incident to it.

00:20:00.340 --> 00:20:02.155
So we call this degree 0.

00:20:04.960 --> 00:20:09.740
Or it could have one incident
edge and the rest are absent.

00:20:09.740 --> 00:20:11.280
That's degree 1.

00:20:11.280 --> 00:20:12.850
Or it could have
two incident edges.

00:20:12.850 --> 00:20:14.641
And there's two ways
it could be like that.

00:20:14.641 --> 00:20:17.050
It could be a turn or
it could be straight.

00:20:20.946 --> 00:20:22.445
You could have three
incident edges.

00:20:25.247 --> 00:20:26.830
Or you could have
four incident edges.

00:20:29.720 --> 00:20:31.330
So that's all the
possible vertices

00:20:31.330 --> 00:20:32.770
in our orthogonal graph.

00:20:32.770 --> 00:20:35.470
And we're just going to make
a crease pattern, a folding

00:20:35.470 --> 00:20:39.200
for each one of these and then
just combine them together.

00:20:39.200 --> 00:20:43.360
Now it takes a lot of care
in designing those patterns

00:20:43.360 --> 00:20:45.380
that they actually fit together.

00:20:45.380 --> 00:20:48.970
But all you need to know
is that it can be done.

00:20:48.970 --> 00:20:52.450
And they're not trivial.

00:20:52.450 --> 00:20:54.580
But once you have
them, it's easy.

00:20:54.580 --> 00:20:56.550
So you've got
degree 0 on the top,

00:20:56.550 --> 00:21:01.250
degree 2 straight, degree 4,
degree 3, degree 1, degree 2

00:21:01.250 --> 00:21:02.630
turned.

00:21:02.630 --> 00:21:06.210
And they're at, I guess, an
increasing order of difficulty.

00:21:06.210 --> 00:21:09.240
And we need to know
that these things exist.

00:21:09.240 --> 00:21:11.260
One way is to in some
sense just to draw

00:21:11.260 --> 00:21:12.880
the picture of the folded state.

00:21:12.880 --> 00:21:15.530
But there's so many layers
here it's a little hard to see,

00:21:15.530 --> 00:21:18.950
and so in order to really
prove that these things exist,

00:21:18.950 --> 00:21:21.360
Jason drew diagrams of how
these things could actually

00:21:21.360 --> 00:21:23.459
be folded in isolation.

00:21:23.459 --> 00:21:25.750
In some sense, we only care
about this final 3D picture

00:21:25.750 --> 00:21:28.180
in knowing that it works and is
non self-intersecting and all

00:21:28.180 --> 00:21:28.680
that.

00:21:28.680 --> 00:21:31.710
But to show that
these exist, one way

00:21:31.710 --> 00:21:35.080
is to actually
build them or show

00:21:35.080 --> 00:21:37.680
the sequence that got there.

00:21:37.680 --> 00:21:39.612
But in reality, you
wouldn't fold it this way.

00:21:39.612 --> 00:21:41.820
Because what you do is you
take these crease patterns

00:21:41.820 --> 00:21:45.230
on the left and just start
pasting them together.

00:21:45.230 --> 00:21:47.200
It's like a big
cut and paste job.

00:21:47.200 --> 00:21:51.810
So you say, oh well maybe like
if I made the square of turns,

00:21:51.810 --> 00:21:55.140
I would just take one of
these, copy, rotate, put it

00:21:55.140 --> 00:21:58.150
here, copy, rotate, put it
here, copy, rotate, put it here.

00:21:58.150 --> 00:22:00.770
And that would make a
square root of turns.

00:22:00.770 --> 00:22:02.370
And what you need
for that to work

00:22:02.370 --> 00:22:05.381
is that the interfaces
here are compatible.

00:22:05.381 --> 00:22:07.130
You can think of it
in the crease pattern,

00:22:07.130 --> 00:22:09.160
or you can think of
it in the 3D state.

00:22:09.160 --> 00:22:11.890
The interface in all
of these pictures

00:22:11.890 --> 00:22:15.602
is that when you have an
actual edge that's raised,

00:22:15.602 --> 00:22:16.310
it's very simple.

00:22:16.310 --> 00:22:19.300
It just goes over,
up, down, over.

00:22:19.300 --> 00:22:22.470
And when you have an edge that
doesn't exist, you go over

00:22:22.470 --> 00:22:24.790
and then you have
a pleat underneath.

00:22:24.790 --> 00:22:26.980
And then you go over.

00:22:26.980 --> 00:22:29.630
And it's important that those
are the same total length.

00:22:29.630 --> 00:22:32.800
Because you need to be
able to choose whether it's

00:22:32.800 --> 00:22:35.380
a raised edge or
a non-raised edge.

00:22:35.380 --> 00:22:37.810
And because all of those
interfaces are the same,

00:22:37.810 --> 00:22:40.310
all of the down edges are
this kind of double pleat.

00:22:40.310 --> 00:22:43.400
And all of the up edges
are just the ridge.

00:22:43.400 --> 00:22:44.820
These things fit together.

00:22:44.820 --> 00:22:47.031
And you can see that in
the crease pattern also.

00:22:47.031 --> 00:22:48.405
Here's what the
pleat looks like.

00:22:48.405 --> 00:22:50.820
And it can match with
this pleat or this one.

00:22:50.820 --> 00:22:52.190
You can rotate.

00:22:52.190 --> 00:22:54.110
Here is the ridge.

00:22:54.110 --> 00:22:58.920
It just goes up and back down.

00:22:58.920 --> 00:23:01.280
And you just paste
those together.

00:23:01.280 --> 00:23:04.360
And you get your
desired crease pattern.

00:23:04.360 --> 00:23:06.020
So here's a simple example.

00:23:06.020 --> 00:23:08.810
The graph has almost all the
vertices, everything except 0

00:23:08.810 --> 00:23:11.800
I think, and straights.

00:23:11.800 --> 00:23:13.990
All right, not
quite all of them.

00:23:13.990 --> 00:23:15.920
But I've color coded here.

00:23:15.920 --> 00:23:17.280
So like you take the graph.

00:23:17.280 --> 00:23:19.280
You just embed it on a
slightly larger grid.

00:23:19.280 --> 00:23:21.680
And you replace each
of those vertices

00:23:21.680 --> 00:23:23.650
with the crease pattern
that makes that thing.

00:23:23.650 --> 00:23:26.140
You just have to rotate
it for it to work out.

00:23:26.140 --> 00:23:28.580
And then you see that
all of these creases

00:23:28.580 --> 00:23:30.500
just meet up correctly.

00:23:30.500 --> 00:23:34.454
And then that's your crease
pattern, which will fold this.

00:23:34.454 --> 00:23:35.870
So that once you
have the gadgets,

00:23:35.870 --> 00:23:38.330
the algorithm is super
simple, just a bunch

00:23:38.330 --> 00:23:41.290
of cutting and pasting.

00:23:41.290 --> 00:23:43.010
And you can do more
complicated examples.

00:23:43.010 --> 00:23:44.540
Here's an actual maze.

00:23:47.640 --> 00:23:50.450
Get some pretty complicated
crease patterns.

00:23:50.450 --> 00:23:52.560
Not so easy to fold.

00:23:52.560 --> 00:23:55.050
But it can be done.

00:23:55.050 --> 00:23:56.800
I didn't bring the
physical model of this,

00:23:56.800 --> 00:23:58.758
because it actually looks
better in photograph.

00:24:01.240 --> 00:24:01.970
It's a challenge.

00:24:01.970 --> 00:24:05.440
This was folded by an
undergrad here, Chris Chin.

00:24:05.440 --> 00:24:08.390
And in fact, it's such
an easy an algorithm,

00:24:08.390 --> 00:24:10.445
I implemented it as
a web application.

00:24:10.445 --> 00:24:12.230
It runs in JavaScript.

00:24:12.230 --> 00:24:14.500
And you can go play with it.

00:24:14.500 --> 00:24:17.870
It's [INAUDIBLE].

00:24:17.870 --> 00:24:20.040
And you can say, OK
give me a random maze.

00:24:20.040 --> 00:24:22.167
And you get a 3D representation.

00:24:22.167 --> 00:24:23.500
And you get your crease pattern.

00:24:23.500 --> 00:24:24.200
You hit print.

00:24:24.200 --> 00:24:26.270
It will print out this
part in vector forms,

00:24:26.270 --> 00:24:29.030
nice high resolution,
and all that.

00:24:29.030 --> 00:24:30.420
You can make more mazes.

00:24:30.420 --> 00:24:32.300
If you really want to
make a particular maze,

00:24:32.300 --> 00:24:35.090
you can fool around with that.

00:24:35.090 --> 00:24:38.000
And you can also write
important messages

00:24:38.000 --> 00:24:46.190
like something like that.

00:24:46.190 --> 00:24:50.520
And then you get this
3D representation,

00:24:50.520 --> 00:24:54.070
which you can fold by this
simple crease pattern.

00:24:54.070 --> 00:24:56.180
If you make that, one
please send it to me.

00:24:56.180 --> 00:25:02.656
But that may take several hours
and use a big sheet of paper.

00:25:02.656 --> 00:25:04.780
I mean, you're only shrinking
by a constant factor.

00:25:04.780 --> 00:25:06.490
How hard could it be?

00:25:06.490 --> 00:25:08.920
The answer is quite hard,
because the gadgets interact.

00:25:08.920 --> 00:25:11.600
It's tricky.

00:25:11.600 --> 00:25:13.730
All right, that's maze folding.

00:25:13.730 --> 00:25:16.990
Any questions about maze
folding or this stuff?

00:25:16.990 --> 00:25:19.820
I think that's the end of
positive results for today.

00:25:19.820 --> 00:25:21.180
And we move into NP-hardness.

00:25:23.935 --> 00:25:24.435
Good?

00:25:27.430 --> 00:25:32.980
All right, well every
origamist knows,

00:25:32.980 --> 00:25:35.060
and if you've been
working on a problem set,

00:25:35.060 --> 00:25:38.980
you should know by
now origami is hard.

00:25:38.980 --> 00:25:42.430
And we'd like to
prove that formally.

00:25:42.430 --> 00:25:46.010
And because we're
computer scientists,

00:25:46.010 --> 00:25:50.760
we like to know what we
can't know essentially.

00:25:55.546 --> 00:25:56.920
There are a lot
of problems where

00:25:56.920 --> 00:25:58.840
there's no efficient algorithm.

00:25:58.840 --> 00:26:01.010
And instead of
just giving up, we

00:26:01.010 --> 00:26:04.520
like to prove that no one can
find an efficient algorithm.

00:26:04.520 --> 00:26:07.080
Because then we know
we're kind of done.

00:26:07.080 --> 00:26:09.640
That's comforting.

00:26:09.640 --> 00:26:15.332
And NP-hardness,
let me change this,

00:26:15.332 --> 00:26:16.790
I don't want to
formally define it.

00:26:16.790 --> 00:26:18.910
Because it's a
little bit technical.

00:26:18.910 --> 00:26:21.280
But a working
definition, there are

00:26:21.280 --> 00:26:24.670
lots of working definitions
that are super easy to tell you.

00:26:28.830 --> 00:26:32.490
So the informal version
is that NP-hard problems

00:26:32.490 --> 00:26:36.700
are computationally
intractable problems,

00:26:36.700 --> 00:26:40.040
meaning there's no tractable
way, no efficient way, to solve

00:26:40.040 --> 00:26:41.580
it on a computer.

00:26:41.580 --> 00:26:48.130
But what it really means,
or what it really implies,

00:26:48.130 --> 00:27:01.240
is if a problem is NP-hard, then
there's no efficient algorithm.

00:27:01.240 --> 00:27:03.316
I wish we could just say that.

00:27:03.316 --> 00:27:14.240
But there's a slight
catch, unless P=NP.

00:27:14.240 --> 00:27:18.700
How many people know
about NP-hardness?

00:27:18.700 --> 00:27:21.040
Well, how many people don't?

00:27:21.040 --> 00:27:21.540
Just a few.

00:27:21.540 --> 00:27:24.790
All right, I'm going to go
relatively quickly then.

00:27:24.790 --> 00:27:28.040
Those who haven't heard
NP-hardness and haven't heard

00:27:28.040 --> 00:27:30.390
of P=NP?

00:27:30.390 --> 00:27:30.890
Good.

00:27:30.890 --> 00:27:33.060
So you've all heard about
this famous problem.

00:27:33.060 --> 00:27:39.380
It's almost certainly the
case that P does not equal NP.

00:27:39.380 --> 00:27:41.420
Pretty much everyone
believes that,

00:27:41.420 --> 00:27:46.940
unless you watch my April Foo;s
video and search for P equals

00:27:46.940 --> 00:27:50.170
NP in YouTube.

00:27:50.170 --> 00:27:56.440
And what this means intuitively
is that there's no cheating.

00:27:56.440 --> 00:28:00.322
There's no trick to make
lucky guesses in life.

00:28:00.322 --> 00:28:02.530
If you've got two choices
and you don't know which is

00:28:02.530 --> 00:28:07.030
the right choice,
and you're computer,

00:28:07.030 --> 00:28:09.740
you can't-- computers
aren't lucky.

00:28:09.740 --> 00:28:12.420
The best they can do
is try both options.

00:28:12.420 --> 00:28:14.960
That's what P does not
equal NP means basically.

00:28:14.960 --> 00:28:18.090
There are no lucky, there's
no way to simulate luckiness.

00:28:18.090 --> 00:28:20.140
That's the technical version.

00:28:22.710 --> 00:28:24.810
Those who know NP
should agree with me.

00:28:24.810 --> 00:28:25.480
That is real.

00:28:30.073 --> 00:28:32.210
It's not how most
people explain it.

00:28:32.210 --> 00:28:35.690
But it's how I like
to think about it.

00:28:35.690 --> 00:28:38.530
And from that perspective,
it's kind of obvious.

00:28:38.530 --> 00:28:40.380
But it's very annoying.

00:28:40.380 --> 00:28:45.100
It's unlikely anyone will
prove this in the near future,

00:28:45.100 --> 00:28:47.900
says Scott Aaronson,
who bet $200,000

00:28:47.900 --> 00:28:51.320
that that was the case.

00:28:51.320 --> 00:28:51.820
Right.

00:28:55.139 --> 00:28:57.430
So you don't need to know
the definition of NP-hardness

00:28:57.430 --> 00:29:01.130
except that it probably means
there's no efficient algorithm.

00:29:01.130 --> 00:29:04.390
For what we need here is
this idea of reduction,

00:29:04.390 --> 00:29:09.160
that we can take some
hard problem, known

00:29:09.160 --> 00:29:10.150
NP-hard problems.

00:29:10.150 --> 00:29:12.690
Why did I write ness there?

00:29:12.690 --> 00:29:17.090
NP-hard problems
show that a problem

00:29:17.090 --> 00:29:19.590
that we care about,
like origami design,

00:29:19.590 --> 00:29:22.360
is even harder than
those problems.

00:29:22.360 --> 00:29:24.120
Therefore, it's also NP-hard.

00:29:24.120 --> 00:29:25.889
That's the usual
way for NP-hardness.

00:29:25.889 --> 00:29:28.430
It's always showing that your
problem is harder than another.

00:29:28.430 --> 00:29:29.680
Or showing that one
of these problems

00:29:29.680 --> 00:29:30.950
is easier than your problem.

00:29:30.950 --> 00:29:32.730
And therefore, yours is harder.

00:29:32.730 --> 00:29:35.150
So I'm going to need
three problems today.

00:29:35.150 --> 00:29:38.320
I'll start just by defining two
of them, which you've probably

00:29:38.320 --> 00:29:39.590
seen before.

00:29:39.590 --> 00:29:41.300
One is called partition.

00:29:45.100 --> 00:29:46.420
And I give you n numbers.

00:29:49.050 --> 00:29:53.690
I want to know, can I split
them into equal halves?

00:30:07.184 --> 00:30:08.225
Be a little more precise.

00:30:12.308 --> 00:30:14.300
Two halves of equal sum.

00:30:18.100 --> 00:30:21.340
So suppose you're playing
video game Team Deathmatch.

00:30:21.340 --> 00:30:22.730
You've got two teams.

00:30:22.730 --> 00:30:24.370
You've got a ranking
for every player.

00:30:24.370 --> 00:30:26.400
You'd like to divide
your players so

00:30:26.400 --> 00:30:28.827
that the sum of the
rankings on the red side

00:30:28.827 --> 00:30:31.160
is the same as the sum of the
rankings on the blue side,

00:30:31.160 --> 00:30:34.090
so it's an even game,
more fun, whatever.

00:30:34.090 --> 00:30:35.740
This problem, sadly, is NP-hard.

00:30:35.740 --> 00:30:37.915
There's no way to do
that, even approximately.

00:30:40.570 --> 00:30:43.140
The only catch is this
problem is hard only

00:30:43.140 --> 00:30:46.310
when these integers
are super big,

00:30:46.310 --> 00:30:48.330
like exponentially large in n.

00:30:48.330 --> 00:30:52.181
This problem is
called weakly NP-hard.

00:30:52.181 --> 00:30:54.430
So as long as your player
rankings are nice and small,

00:30:54.430 --> 00:30:56.730
there actually is an
efficient way to solve that.

00:30:56.730 --> 00:30:59.790
Problem but when the integers
are big, this is NP-hard.

00:31:03.772 --> 00:31:07.460
An even nastier problem
is satisfiability, or SAT.

00:31:10.880 --> 00:31:12.540
Here you're given
some Boolean formula.

00:31:17.310 --> 00:31:20.550
So it has a bunch
variables, like x and y.

00:31:23.750 --> 00:31:24.910
You can do and.

00:31:24.910 --> 00:31:27.660
You can do not.

00:31:27.660 --> 00:31:30.840
And you can do or, let's say.

00:31:30.840 --> 00:31:34.500
That's all you need,
x and not y or z.

00:31:34.500 --> 00:31:38.320
And you want to know, can
I make that formula true?

00:31:38.320 --> 00:31:48.810
Is there some setting to
the variables x, y, and z,

00:31:48.810 --> 00:31:53.940
or in general there's
n variables, so

00:31:53.940 --> 00:31:54.990
that the formula is true?

00:32:00.300 --> 00:32:03.750
So we'd say the
formula's satisfied.

00:32:03.750 --> 00:32:04.740
And that's NP-hard.

00:32:04.740 --> 00:32:07.312
And here there's not even
any numbers to make it hard.

00:32:07.312 --> 00:32:09.020
So we call this problem
strongly NP-hard.

00:32:15.450 --> 00:32:18.620
And this is really the
prototypical hard problem,

00:32:18.620 --> 00:32:22.780
NP-hard problem, is the very
first one is proved NP-hard.

00:32:22.780 --> 00:32:24.650
It's the only one
really that we usually

00:32:24.650 --> 00:32:27.920
prove without a
reduction, you could say.

00:32:31.730 --> 00:32:35.440
So what we're going to do it
for four different origami

00:32:35.440 --> 00:32:41.185
problems is show those problems
are easier than our problems.

00:32:46.220 --> 00:32:48.400
Therefore, our problems
are NP-hard also.

00:32:55.470 --> 00:32:58.420
How do we show that,
say a partition

00:32:58.420 --> 00:33:00.970
is easier than some problem?

00:33:00.970 --> 00:33:04.270
Well, we just take a parti--
we show that partition

00:33:04.270 --> 00:33:06.097
is a special case
of our problem.

00:33:06.097 --> 00:33:06.930
It's a special case.

00:33:06.930 --> 00:33:08.430
Clearly it's easier.

00:33:08.430 --> 00:33:11.640
So to show that, we take one
of these partition problems,

00:33:11.640 --> 00:33:12.990
like n integers.

00:33:12.990 --> 00:33:15.850
We want to know whether you
can split them in equal halves.

00:33:15.850 --> 00:33:18.360
I'm going to convert
that into my problem,

00:33:18.360 --> 00:33:20.790
so that that problem has
a yes answer if and only

00:33:20.790 --> 00:33:22.620
if the partition problem
has a yes answer.

00:33:22.620 --> 00:33:25.750
Therefore, really this
problem becomes a special case

00:33:25.750 --> 00:33:26.750
of the one I care about.

00:33:26.750 --> 00:33:30.220
Therefore, that problem
is harder, and therefore

00:33:30.220 --> 00:33:31.030
also NP-hard.

00:33:33.560 --> 00:33:39.810
So I'm going to start out with
a super simple example which

00:33:39.810 --> 00:33:43.730
we did in the problem
session on Monday.

00:33:43.730 --> 00:33:48.510
Someone pose this to me after
class last week, I think.

00:33:51.360 --> 00:33:54.820
I think two lectures ago.

00:33:54.820 --> 00:33:58.100
So here's a problem.

00:33:58.100 --> 00:34:01.360
I give you a single
vertex hinge pattern.

00:34:06.670 --> 00:34:09.630
Someone built some crazy
robot with some crazy pattern

00:34:09.630 --> 00:34:11.810
of hinges all around
a single vertex.

00:34:11.810 --> 00:34:16.380
You want to know, can I
make anything out of it?

00:34:16.380 --> 00:34:19.150
Does some subset
of those hinges,

00:34:19.150 --> 00:34:22.330
if I take that as a
crease pattern, fold flat?

00:34:26.850 --> 00:34:29.310
Who posed this problem?

00:34:29.310 --> 00:34:31.100
Anybody remember?

00:34:31.100 --> 00:34:31.600
All right.

00:34:31.600 --> 00:34:32.980
Maybe he's not here.

00:34:32.980 --> 00:34:34.900
I forgot, unfortunately.

00:34:34.900 --> 00:34:37.929
He asked me, so what
about this problem?

00:34:37.929 --> 00:34:40.060
I said, yeah it's
obviously NP-hard.

00:34:40.060 --> 00:34:42.520
And we thought about
it for five minutes.

00:34:42.520 --> 00:34:45.446
And then after five minutes,
it's obviously NP-hard.

00:34:45.446 --> 00:34:51.420
So let me show you the
obvious proof once we have it.

00:34:51.420 --> 00:34:53.429
We're going to show
that this problem is

00:34:53.429 --> 00:34:55.070
harder than partition.

00:34:55.070 --> 00:34:58.430
So we take n integers, want
to know how to divide them.

00:34:58.430 --> 00:35:01.470
And it's really simple.

00:35:01.470 --> 00:35:03.285
So suppose someone
gives us n integers.

00:35:06.820 --> 00:35:09.450
For integers, we're
going to scale them

00:35:09.450 --> 00:35:15.960
all by the same scale factor,
so that their sum equals

00:35:15.960 --> 00:35:19.007
360 degrees.

00:35:19.007 --> 00:35:20.590
And now, lo and
behold, those integers

00:35:20.590 --> 00:35:23.870
are angles in a crease
pattern, in a hinge pattern.

00:35:23.870 --> 00:35:25.690
So you just take those numbers.

00:35:25.690 --> 00:35:26.510
You turn them.

00:35:26.510 --> 00:35:27.640
You put them on a wheel.

00:35:31.670 --> 00:35:32.170
OK.

00:35:32.170 --> 00:35:35.341
Now presumably, it's not a flat,
foldable, single vertex crease

00:35:35.341 --> 00:35:35.840
pattern.

00:35:35.840 --> 00:35:37.464
Otherwise, the
answer would be yes.

00:35:37.464 --> 00:35:39.380
We want to know, can I
remove some the creases

00:35:39.380 --> 00:35:41.236
to make it flat foldable?

00:35:41.236 --> 00:35:44.410
Now if you think about
Kawasaki's theorem,

00:35:44.410 --> 00:35:47.369
the sum, the alternating
sum of angles equals 0.

00:35:47.369 --> 00:35:48.660
Remember how that proof worked?

00:35:48.660 --> 00:35:51.260
We said, OK you follow
one angle for a while.

00:35:51.260 --> 00:35:51.870
Then you turn.

00:35:51.870 --> 00:35:52.578
Then you go back.

00:35:52.578 --> 00:35:56.460
And somehow, you have to end
up back where you started.

00:35:56.460 --> 00:35:57.850
That's the equals zero part.

00:35:57.850 --> 00:36:00.196
And it's the
alternating sum part.

00:36:00.196 --> 00:36:02.320
Now in this case, we have
a choice at every crease.

00:36:02.320 --> 00:36:04.540
We could include it or not.

00:36:04.540 --> 00:36:06.500
If we include the
crease, we turn around.

00:36:06.500 --> 00:36:10.310
If we remove the crease,
we keep going straight.

00:36:10.310 --> 00:36:13.220
So now the problem is I
give you all these integers.

00:36:13.220 --> 00:36:14.820
And I can go right.

00:36:14.820 --> 00:36:15.820
And now I have a choice.

00:36:15.820 --> 00:36:19.480
Do I go right or left by
the next integer, theta 2.

00:36:19.480 --> 00:36:22.127
There's theta 1, theta 2.

00:36:22.127 --> 00:36:23.210
Each one, I have a choice.

00:36:23.210 --> 00:36:24.126
Do I go right or left?

00:36:28.190 --> 00:36:30.610
In the end, the sum
must equal zero.

00:36:30.610 --> 00:36:33.900
So this problem is
the same problem

00:36:33.900 --> 00:36:37.190
really as given a
bunch of numbers,

00:36:37.190 --> 00:36:42.800
can I assign signs of plus or
minus so that they add up to 0?

00:36:42.800 --> 00:36:45.840
But assigning signs of plus
or minus so they add up to

00:36:45.840 --> 00:36:49.480
is the same as saying all the
plus guys equal all the minus

00:36:49.480 --> 00:36:51.100
guys.

00:36:51.100 --> 00:37:06.670
So really, this problem becomes
assigning pluses and minuses,

00:37:06.670 --> 00:37:10.520
so that the sum with
the appropriate pluses

00:37:10.520 --> 00:37:12.550
or minuses of
theta i is equal 0.

00:37:12.550 --> 00:37:15.000
That's the Kawasaki version.

00:37:15.000 --> 00:37:18.550
But that's the same thing as
saying the sum of the pluses

00:37:18.550 --> 00:37:22.690
equals the sum of the minuses.

00:37:22.690 --> 00:37:25.000
And if that's the case,
then really you've

00:37:25.000 --> 00:37:29.140
partitioned your numbers
into two halves of equal sum.

00:37:29.140 --> 00:37:32.320
So this is going to be
possible exactly when there's

00:37:32.320 --> 00:37:33.500
a partition.

00:37:33.500 --> 00:37:35.180
And so you've
converted partition

00:37:35.180 --> 00:37:37.980
into this problem, which
means this problem is harder.

00:37:37.980 --> 00:37:40.530
Because it has other
situations maybe.

00:37:40.530 --> 00:37:42.370
But you take any
partition, and are actually

00:37:42.370 --> 00:37:43.500
pretty much identical.

00:37:43.500 --> 00:37:47.190
But partition becomes a
special case with this problem.

00:37:47.190 --> 00:37:50.570
Therefore, this problem is
harder, and therefore NP-hard.

00:37:50.570 --> 00:37:52.780
It's only weakly NP-hard.

00:37:52.780 --> 00:37:56.260
But that's a minor detail.

00:37:56.260 --> 00:37:58.220
Clear?

00:37:58.220 --> 00:37:58.830
All right.

00:37:58.830 --> 00:38:04.000
Now we move on to the
more, I don't know,

00:38:04.000 --> 00:38:06.580
that's a brand new result,
and a very simple one.

00:38:09.660 --> 00:38:13.540
Now we move on to the sort of
more established, well-studied

00:38:13.540 --> 00:38:14.040
problems.

00:38:16.477 --> 00:38:18.810
The NP-hardness proofs are
quite a bit more complicated.

00:38:18.810 --> 00:38:22.660
But they're still, they
all follow the same spirit.

00:38:22.660 --> 00:38:24.970
And they're a lot of fun,
because they involve gadgets.

00:38:24.970 --> 00:38:27.080
Here there aren't
really any gadgets.

00:38:27.080 --> 00:38:30.080
We represented an
integer by an angle.

00:38:30.080 --> 00:38:30.910
It's pretty direct.

00:38:30.910 --> 00:38:32.451
But in some sense,
that's the gadget.

00:38:32.451 --> 00:38:33.890
And we just used n of them.

00:38:33.890 --> 00:38:36.740
All of the other proofs are
going to use tons of gadgets.

00:38:36.740 --> 00:38:39.070
And they're kind of fun.

00:38:39.070 --> 00:38:40.154
I love NP-hard proofs.

00:38:40.154 --> 00:38:41.570
They're one of my
favorite things.

00:38:46.294 --> 00:38:47.710
All right, one of
the first things

00:38:47.710 --> 00:38:51.170
we talked about in this
class was simple folds.

00:38:51.170 --> 00:38:53.105
And we showed that in
one dimension, if you

00:38:53.105 --> 00:38:54.650
had a one dimensional
piece of paper,

00:38:54.650 --> 00:38:55.880
simple folds were universal.

00:38:55.880 --> 00:38:59.060
You could make any flat,
foldable crease pattern.

00:38:59.060 --> 00:39:01.610
And if you remember,
at the very end,

00:39:01.610 --> 00:39:04.950
we talked about
map folding, which

00:39:04.950 --> 00:39:07.810
is where you have a bunch
of orthogonal creases

00:39:07.810 --> 00:39:13.510
in a rectangular paper, and
maybe also with mountain valley

00:39:13.510 --> 00:39:14.870
assignment.

00:39:14.870 --> 00:39:16.570
And we showed that
this problem really

00:39:16.570 --> 00:39:19.750
is a bunch of one
dimensional problems.

00:39:19.750 --> 00:39:22.220
And so if we wanted to
solve it was simple folds,

00:39:22.220 --> 00:39:24.470
where you only fold along
a single line at a time

00:39:24.470 --> 00:39:28.130
by 180 degrees, then
really this turned

00:39:28.130 --> 00:39:30.679
into a one dimensional
problem in one dimension, then

00:39:30.679 --> 00:39:32.720
a one dimensional problem
in the other dimension.

00:39:32.720 --> 00:39:34.590
You just kept doing
that until either you

00:39:34.590 --> 00:39:37.300
got stuck, in which case the
thing was not flat foldable,

00:39:37.300 --> 00:39:38.600
or you flat folded it.

00:39:38.600 --> 00:39:42.290
So this is an example where
simple folding is easy.

00:39:42.290 --> 00:39:44.200
But in general,
deciding whether you

00:39:44.200 --> 00:39:48.040
can fold a crease pattern flat
by simple folds is NP-hard.

00:39:48.040 --> 00:39:51.100
So for this special
case, it's easy.

00:39:51.100 --> 00:39:57.300
For another situation, which
is when the polygons are not

00:39:57.300 --> 00:39:59.851
just rectangles, but are
a little more general,

00:39:59.851 --> 00:40:00.850
then it becomes NP-hard.

00:40:04.570 --> 00:40:07.511
So in general, the problem
is given a crease pattern,

00:40:07.511 --> 00:40:09.260
possibly with mountain
valley assignments,

00:40:09.260 --> 00:40:18.290
doesn't really matter, can it
be folded flat by simple folds,

00:40:18.290 --> 00:40:19.937
by a sequence of simple folds?

00:40:19.937 --> 00:40:22.270
Initially we thought maybe
this problem was polynomially

00:40:22.270 --> 00:40:25.610
solvable, because simple
folds are so damn simple.

00:40:25.610 --> 00:40:33.270
We were wishful,
but it's not true.

00:40:33.270 --> 00:40:35.000
This turns out to be NP-hard.

00:40:39.870 --> 00:40:45.820
If we take this situation,
the map situation,

00:40:45.820 --> 00:40:52.890
and we add 45 degree
folds, creases, so I just

00:40:52.890 --> 00:40:55.590
add some things like that.

00:40:55.590 --> 00:40:57.275
It looks kind of crazy.

00:40:57.275 --> 00:40:59.390
Got to do some sub division.

00:40:59.390 --> 00:41:00.730
I just add 45 degree folds.

00:41:00.730 --> 00:41:02.350
Then this problem
becomes NP-hard.

00:41:02.350 --> 00:41:05.670
So with orthogonal creases
in a rectangle, it's easy.

00:41:05.670 --> 00:41:08.414
But you had one more
direction, it's hard.

00:41:08.414 --> 00:41:09.580
Another version that's hard.

00:41:09.580 --> 00:41:12.710
If I keep all the creases
horizontal and vertical

00:41:12.710 --> 00:41:19.586
but I make an orthogonal polygon
instead of just a rectangle,

00:41:19.586 --> 00:41:21.450
then it's also NP-hard.

00:41:21.450 --> 00:41:23.540
I'm going to show this
one because it's easier.

00:41:23.540 --> 00:41:26.280
But this actually just converts.

00:41:26.280 --> 00:41:28.180
You can set up 45
degree folds so

00:41:28.180 --> 00:41:30.740
that you are forced to make a
particular orthogonal polygon

00:41:30.740 --> 00:41:31.890
to get started.

00:41:31.890 --> 00:41:33.770
And then it's the same proof.

00:41:33.770 --> 00:41:35.720
So I think I have
the proof here.

00:41:39.070 --> 00:41:42.860
So again, we're going to
reduce from partition.

00:41:42.860 --> 00:41:44.730
So we're given n integers.

00:41:44.730 --> 00:41:46.500
We want to know whether
we can divide them

00:41:46.500 --> 00:41:48.569
into equal summing halves.

00:41:48.569 --> 00:41:50.360
And we're going to
represent those integers

00:41:50.360 --> 00:41:53.240
by these lengths.

00:41:53.240 --> 00:41:58.380
So here's an, then
a3, and a2, and a1.

00:41:58.380 --> 00:42:04.327
So the lengths in the top part
of the staircase are integers.

00:42:04.327 --> 00:42:06.410
We want to somehow divide
those into equal halves.

00:42:06.410 --> 00:42:11.050
And when they have two halves,
and I suppose at their sum

00:42:11.050 --> 00:42:14.120
is L, capital L. I can
just add them all up.

00:42:14.120 --> 00:42:15.020
I should get 2L.

00:42:15.020 --> 00:42:17.350
I divide by 2, I could get
what the target sum is.

00:42:17.350 --> 00:42:20.240
So I know ahead of time without
solving the partition problem

00:42:20.240 --> 00:42:24.000
what L ought to be, and
what twice L ought to be.

00:42:24.000 --> 00:42:26.710
And then I build this frame
over on the right whose height

00:42:26.710 --> 00:42:31.880
is exactly twice
L. And so there's

00:42:31.880 --> 00:42:36.850
these creases in the horizontal
creases down the staircase.

00:42:36.850 --> 00:42:38.850
All these creases have
to get folded eventually,

00:42:38.850 --> 00:42:40.870
and by simple folds.

00:42:40.870 --> 00:42:44.540
And then there's also
these two vertical creases

00:42:44.540 --> 00:42:46.750
bounding the frame.

00:42:46.750 --> 00:42:50.240
So the idea is, well you make
some of the horizontal creases.

00:42:50.240 --> 00:42:52.499
Then you fold one of
those horizontal creases.

00:42:52.499 --> 00:42:54.540
And then eventually you
have to fold-- I'm sorry,

00:42:54.540 --> 00:42:55.600
one of those vertical creases.

00:42:55.600 --> 00:42:57.516
I always get horizontal
and vertical confused,

00:42:57.516 --> 00:43:00.100
which causes me great
difficulty when trying to sleep.

00:43:00.100 --> 00:43:06.860
But so when I fold the first
vertical crease, whatever's

00:43:06.860 --> 00:43:08.550
over here comes over here.

00:43:08.550 --> 00:43:11.580
If it hits the frame,
I'm in big trouble.

00:43:11.580 --> 00:43:13.220
Because then how
am I going to fold

00:43:13.220 --> 00:43:16.070
the other horizontal,
other vertical crease

00:43:16.070 --> 00:43:20.890
without colliding
with the frame?

00:43:20.890 --> 00:43:23.630
If I want to avoid collision
with the frame by simple folds,

00:43:23.630 --> 00:43:25.296
and I fold the vertical
crease, I really

00:43:25.296 --> 00:43:27.102
should not be
touching the frame.

00:43:27.102 --> 00:43:28.370
So you try to fold through it.

00:43:28.370 --> 00:43:31.060
They're both valleys
in this case.

00:43:31.060 --> 00:43:33.590
It doesn't matter too much.

00:43:33.590 --> 00:43:37.130
So what I really need to do
is fold this thing compactly

00:43:37.130 --> 00:43:41.630
like this, so that it just
fits inside the frame.

00:43:41.630 --> 00:43:43.610
And the only way to
do that is for each

00:43:43.610 --> 00:43:46.050
of those vertical
segments of the staircase

00:43:46.050 --> 00:43:48.810
to decide should it go
up, or should it go down?

00:43:48.810 --> 00:43:50.530
And you do that in
actually pretty much

00:43:50.530 --> 00:43:53.290
the same way this proof works.

00:43:53.290 --> 00:43:54.765
For each of these
segments here, we

00:43:54.765 --> 00:43:57.950
were deciding should I
keep going straight and go,

00:43:57.950 --> 00:43:59.790
or should I turn around?

00:43:59.790 --> 00:44:01.190
Over here, it's the same deal.

00:44:01.190 --> 00:44:04.340
I either keep going
straight, whichever direction

00:44:04.340 --> 00:44:06.090
I was going, up or
down, or I turn around.

00:44:06.090 --> 00:44:07.881
But I always have a
choice at every crease.

00:44:07.881 --> 00:44:10.690
I'll just fold it or not to make
it go up or down how I want.

00:44:10.690 --> 00:44:12.607
The up guys are going
to be one of the halves.

00:44:12.607 --> 00:44:14.731
And the down guys are going
to be the other halves.

00:44:14.731 --> 00:44:16.380
Here, it's the other
side of the paper,

00:44:16.380 --> 00:44:18.920
the dark blue versus
the light blue.

00:44:18.920 --> 00:44:24.400
As long as those numbers
add up to exactly L,

00:44:24.400 --> 00:44:25.610
I've got this twice.

00:44:25.610 --> 00:44:33.480
Then I start here at
the middle of the frame.

00:44:33.480 --> 00:44:35.290
If I can get them
to balance out,

00:44:35.290 --> 00:44:40.700
I will end over here,
also at the middle.

00:44:40.700 --> 00:44:43.830
And then I go up by L.
And then I go down by 2L.

00:44:43.830 --> 00:44:46.840
And that will just
fit inside the frame.

00:44:46.840 --> 00:44:49.680
But only if I stay in
the middle will that 2L

00:44:49.680 --> 00:44:51.456
fit inside the frame.

00:44:51.456 --> 00:44:53.810
And so the only way
for these two creases

00:44:53.810 --> 00:44:56.550
to be foldable and not
collide with the frame

00:44:56.550 --> 00:44:59.560
is if I can solve the
partition problem.

00:44:59.560 --> 00:45:02.320
Therefore, so finding
simple fold sequences

00:45:02.320 --> 00:45:05.390
is actually way harder than
partition in some sense.

00:45:05.390 --> 00:45:07.330
Because this is just
a very specific kind

00:45:07.330 --> 00:45:10.290
of map, specific kind of crease
pattern you might want to fold.

00:45:10.290 --> 00:45:14.120
And folding that is
exactly partition.

00:45:14.120 --> 00:45:16.570
So the general simple
foldability problem

00:45:16.570 --> 00:45:19.420
is going to be NP-hard,
because it includes partition

00:45:19.420 --> 00:45:21.550
as a special case.

00:45:21.550 --> 00:45:22.050
Clear?

00:45:25.291 --> 00:45:25.790
Good.

00:45:28.300 --> 00:45:33.130
That's our easiest proof
among the next three.

00:45:33.130 --> 00:45:35.850
Going to get increasingly
difficult, I guess.

00:45:35.850 --> 00:45:38.130
But I'll just getting
increasingly sketchy,

00:45:38.130 --> 00:45:40.460
so it will be easy for me.

00:45:44.210 --> 00:45:45.960
I mean, the more
complicated a proof gets,

00:45:45.960 --> 00:45:50.160
somehow I feel like the
number of interesting details

00:45:50.160 --> 00:45:51.447
in a proof remains constant.

00:45:51.447 --> 00:45:52.905
If the proof gets
more complicated,

00:45:52.905 --> 00:45:56.105
then I throw away more
of the messy details.

00:46:21.030 --> 00:46:33.990
All right, the next theorem is
also about flat foldability.

00:46:33.990 --> 00:46:40.260
But now I don't just
care about simple folds,

00:46:40.260 --> 00:46:43.510
I want to look at
regular origami

00:46:43.510 --> 00:46:46.350
folds, which are folded states.

00:46:46.350 --> 00:46:51.160
So we talked a couple lectures
ago about local foldability,

00:46:51.160 --> 00:46:53.350
which was can we
assign mountains

00:46:53.350 --> 00:46:55.070
and valleys to
some crease pattern

00:46:55.070 --> 00:46:58.500
so that each vertex, if you
cut it out into a little disk,

00:46:58.500 --> 00:47:00.350
would by itself fold flat.

00:47:00.350 --> 00:47:05.120
And that was easy, polynomially
solvable, actually linear time.

00:47:05.120 --> 00:47:07.060
And that was a result
by Bern and Hayes.

00:47:07.060 --> 00:47:09.290
Another result in the same
paper by Bern and Hayes,

00:47:09.290 --> 00:47:11.350
which is actually sort
of the bigger result

00:47:11.350 --> 00:47:13.922
that everyone knows about,
is that if I give you

00:47:13.922 --> 00:47:15.380
an arbitrary crease
pattern, I want

00:47:15.380 --> 00:47:19.720
to know just does it fold
flat, that's NP-hard.

00:47:19.720 --> 00:47:22.150
They proved actually two
NP-hard hardness results.

00:47:30.400 --> 00:47:31.970
So this is way back in '96.

00:47:31.970 --> 00:47:35.390
This is one of
the oldest results

00:47:35.390 --> 00:47:37.950
in computational origami.

00:47:42.280 --> 00:47:44.110
So I give you a crease pattern.

00:47:44.110 --> 00:47:46.800
I just want to know, is it
flat foldable in the global,

00:47:46.800 --> 00:47:47.890
in the regular sense?

00:47:51.820 --> 00:47:54.740
This is strongly NP-hard.

00:47:58.959 --> 00:48:01.000
The proof I just gave is
actually weakly NP-hard.

00:48:01.000 --> 00:48:04.120
It is not known whether that
problem is strongly or weakly

00:48:04.120 --> 00:48:06.395
hard, but at least weekly.

00:48:22.270 --> 00:48:26.560
The other thing they
proved is that if you're

00:48:26.560 --> 00:48:34.167
given a flat foldable, even I
tell you it's flat foldable,

00:48:34.167 --> 00:48:36.250
and I even give you the
mountains and valleys that

00:48:36.250 --> 00:48:40.510
make it work, still flat
folding thing is NP-hard.

00:48:53.606 --> 00:48:55.980
So if I give you a flat foldable
mountain valley pattern,

00:48:55.980 --> 00:48:59.260
all that's left is to decide
I can fold each vertex.

00:48:59.260 --> 00:49:01.700
And then there's this
issue of layering.

00:49:01.700 --> 00:49:03.850
If I have two layers of
paper that are overlapping,

00:49:03.850 --> 00:49:04.850
they could be like this.

00:49:04.850 --> 00:49:06.300
Or they could be like this.

00:49:06.300 --> 00:49:08.310
And if I have, for
example, two crimps,

00:49:08.310 --> 00:49:11.860
I could decide
how the layers go.

00:49:11.860 --> 00:49:13.880
Figuring out what the
right layer ordering is

00:49:13.880 --> 00:49:15.610
is really the heart
of the problem.

00:49:15.610 --> 00:49:17.261
This is what makes it NP-hard.

00:49:17.261 --> 00:49:19.510
Because we know finding a
mountain valley assignment--

00:49:19.510 --> 00:49:21.590
locally things work-- is easy.

00:49:21.590 --> 00:49:24.840
But getting that
layering to work is hard.

00:49:24.840 --> 00:49:26.870
That's what all
these proofs say.

00:49:35.812 --> 00:49:38.145
So I'm going to talk about
the proof of the first result

00:49:38.145 --> 00:49:40.353
though, because the second
one is pretty complicated.

00:49:45.320 --> 00:49:47.765
It's the same spirit,
just a lot more details.

00:49:53.720 --> 00:49:56.080
Again, we're going
to do a reduction.

00:49:56.080 --> 00:49:59.420
And we have these two nice
problems, partition and SAT.

00:49:59.420 --> 00:50:00.920
I'm not going to
use either of them,

00:50:00.920 --> 00:50:02.840
though in theory
you could use SAT.

00:50:02.840 --> 00:50:06.440
I'm going to reduce from one
of my favorite problems, one

00:50:06.440 --> 00:50:09.240
of my favorite NP-hard
problems, I should say.

00:50:09.240 --> 00:50:10.314
Wait, no.

00:50:10.314 --> 00:50:11.230
That's the next proof.

00:50:11.230 --> 00:50:12.630
This is not my favorite.

00:50:12.630 --> 00:50:14.020
It's a pretty good one, though.

00:50:14.020 --> 00:50:16.350
I do like it.

00:50:16.350 --> 00:50:17.990
Is just a little more technical.

00:50:31.230 --> 00:50:33.930
All positive, not
all equal 3SAT,

00:50:33.930 --> 00:50:37.560
has anyone heard of
this problem before?

00:50:37.560 --> 00:50:41.506
Nadia's heard of it, because
she TA'd this class before.

00:50:41.506 --> 00:50:42.305
It's no surprise.

00:50:42.305 --> 00:50:43.987
So you've read the book.

00:50:43.987 --> 00:50:46.320
This is, there aren't a lot
of proofs that use this one.

00:50:46.320 --> 00:50:49.660
But not all equal 3SAT is
actually fairly common.

00:50:49.660 --> 00:50:52.361
All positive is just makes
a little more convenient.

00:50:52.361 --> 00:50:54.860
I think actually the original
proof didn't use all positive.

00:50:54.860 --> 00:50:56.030
But our book does.

00:50:56.030 --> 00:50:58.180
Because it simplifies things.

00:50:58.180 --> 00:51:01.907
So let me tell you
what this problem is.

00:51:01.907 --> 00:51:02.990
Most people don't know it.

00:51:02.990 --> 00:51:03.615
So don't worry.

00:51:08.830 --> 00:51:12.100
You could technically,
it's a version of SAT.

00:51:12.100 --> 00:51:13.790
But instead of giving
a Boolean formula,

00:51:13.790 --> 00:51:16.100
I'm going to think of that
it's really a Boolean formula.

00:51:16.100 --> 00:51:18.266
But I'm going to think of
it in a simpler way, which

00:51:18.266 --> 00:51:22.390
is I give you a bunch of triples
if variables, so like xi,

00:51:22.390 --> 00:51:23.850
xj xk.

00:51:23.850 --> 00:51:29.299
And I want to know is
there a Boolean assignment

00:51:29.299 --> 00:51:30.090
to those variables?

00:51:30.090 --> 00:51:31.955
I want to set each of
them to true or false.

00:51:43.730 --> 00:51:44.785
Say there's n variables.

00:51:47.800 --> 00:51:57.150
So that no triple is
all equal, no triple

00:51:57.150 --> 00:52:01.905
is all true or all false.

00:52:07.450 --> 00:52:10.570
Maybe we could call it
the all state problem.

00:52:10.570 --> 00:52:12.420
I've been watching too many ads.

00:52:12.420 --> 00:52:17.400
All right, so if not all equal
3SAT, that's this version.

00:52:17.400 --> 00:52:18.930
Actually, it's
also all positive,

00:52:18.930 --> 00:52:21.460
meaning I don't have
any nots in here.

00:52:21.460 --> 00:52:22.880
So ignore that.

00:52:22.880 --> 00:52:24.760
Ignore the technical term.

00:52:24.760 --> 00:52:26.220
This is the right definition.

00:52:26.220 --> 00:52:28.296
So I have a bunch of
triples of variables.

00:52:28.296 --> 00:52:30.670
I just don't want them all to
be true or all to be false.

00:52:30.670 --> 00:52:33.086
So two of them could be true
and one false, or two of them

00:52:33.086 --> 00:52:34.830
could be false, and one true.

00:52:34.830 --> 00:52:35.595
That's all.

00:52:35.595 --> 00:52:38.816
It turns out this is
basically equivalent to SAT.

00:52:38.816 --> 00:52:40.440
But the proof of that
is kind of messy.

00:52:40.440 --> 00:52:42.780
So I don't want to do it here.

00:52:46.040 --> 00:52:47.910
And so that problem is NP-hard.

00:52:47.910 --> 00:52:51.350
Just take that on faith.

00:52:51.350 --> 00:52:56.140
And now I want to show that
global flat foldability

00:52:56.140 --> 00:52:59.810
includes all positive
not all will equal 3SAT

00:52:59.810 --> 00:53:01.310
as a special case.

00:53:01.310 --> 00:53:03.050
And therefore,
it's also NP-hard.

00:53:12.010 --> 00:53:16.055
So I'll give you a preview.

00:53:24.490 --> 00:53:36.170
Start with a high level, what
we need in terms of gadgets.

00:53:45.072 --> 00:53:46.530
And then I'll show
you the gadgets,

00:53:46.530 --> 00:53:49.490
and then show you how
they fit together.

00:53:49.490 --> 00:53:52.420
So this is a general
picture, in fact,

00:53:52.420 --> 00:53:55.460
of what a SAT kind of
NP-hardness proof looks like.

00:53:55.460 --> 00:53:59.514
If you haven't done many
of them, now you'll know.

00:53:59.514 --> 00:54:00.930
If you have done
many of them, you

00:54:00.930 --> 00:54:02.740
will recognize
this pattern, which

00:54:02.740 --> 00:54:06.490
is to represent
Boolean-ness, we need

00:54:06.490 --> 00:54:08.290
something that represents
true and false.

00:54:08.290 --> 00:54:09.665
And that's usually
called a wire.

00:54:09.665 --> 00:54:13.209
We think of digital
signals like chips.

00:54:13.209 --> 00:54:15.750
And then we've got to be able
to connect those wires together

00:54:15.750 --> 00:54:16.920
to do interesting things.

00:54:16.920 --> 00:54:19.200
In this case, the interesting
thing we need to do

00:54:19.200 --> 00:54:21.480
is tell if I have
a triple of them,

00:54:21.480 --> 00:54:23.950
are they all true or
all false, and somehow

00:54:23.950 --> 00:54:26.570
force them to not be
all true or all false.

00:54:26.570 --> 00:54:29.880
And in this case, that will
be a not all equal clause.

00:54:29.880 --> 00:54:32.010
It'll be a gadget
the folds flat,

00:54:32.010 --> 00:54:34.920
exactly when those wires that
come together, three wires

00:54:34.920 --> 00:54:35.920
come together.

00:54:35.920 --> 00:54:38.080
And if they're all truth,
they won't fold flat.

00:54:38.080 --> 00:54:39.840
If they're all false,
it won't fold flat.

00:54:39.840 --> 00:54:42.260
In all of the cases,
it will fold flat.

00:54:42.260 --> 00:54:44.180
So if we could
build that, that'll

00:54:44.180 --> 00:54:46.430
constrain the variables
that I connect together

00:54:46.430 --> 00:54:48.410
with a not all equal clause.

00:54:48.410 --> 00:54:52.480
But how do I actually
move the wires around

00:54:52.480 --> 00:54:54.910
to make them connect
together at these clauses?

00:54:54.910 --> 00:54:56.920
Well, I need something
called a turn gadget.

00:54:56.920 --> 00:54:58.762
If I have a wire
going straight, I'd

00:54:58.762 --> 00:55:00.720
like to be able to turn
it to some other angle.

00:55:00.720 --> 00:55:02.400
I could just sort
of move them around.

00:55:02.400 --> 00:55:04.170
It's harder than it sounds.

00:55:04.170 --> 00:55:06.560
And I'll also need a split.

00:55:06.560 --> 00:55:10.230
Because in this, it's maybe not
obvious from this formulation,

00:55:10.230 --> 00:55:11.950
but I have these n variables.

00:55:11.950 --> 00:55:15.060
I might have many
more than n clauses.

00:55:15.060 --> 00:55:16.740
Each variable, like
x1, might appear

00:55:16.740 --> 00:55:19.990
in 100 different triples.

00:55:19.990 --> 00:55:22.551
And so I actually
need 100 copies of x1.

00:55:22.551 --> 00:55:24.050
And that's what a
split gadget does.

00:55:24.050 --> 00:55:25.330
And we're going to
build one gadget called

00:55:25.330 --> 00:55:27.790
a reflector, which actually
does both of those in one

00:55:27.790 --> 00:55:29.620
fell swoop.

00:55:29.620 --> 00:55:31.670
And the last thing we
need is a crossover.

00:55:31.670 --> 00:55:34.780
Because you make all these
connections between variables

00:55:34.780 --> 00:55:37.450
and clauses or triples.

00:55:37.450 --> 00:55:39.229
And they might have
to cross each other.

00:55:39.229 --> 00:55:40.770
And we want them to
cross each other,

00:55:40.770 --> 00:55:42.510
but not affect each other.

00:55:42.510 --> 00:55:44.620
And because we're
in a sheet of paper,

00:55:44.620 --> 00:55:45.841
we've got to deal with that.

00:55:45.841 --> 00:55:48.340
It's going to be these wires
to go right through each other.

00:55:48.340 --> 00:55:49.881
We got to make it
still flat foldable

00:55:49.881 --> 00:55:52.790
without affecting either wire.

00:55:52.790 --> 00:55:55.400
That's all.

00:55:55.400 --> 00:55:57.960
That's pretty standard
for this kind of proof.

00:55:57.960 --> 00:56:00.610
These are the proofs that
I like the most, actually.

00:56:00.610 --> 00:56:01.150
Pretty fun.

00:56:01.150 --> 00:56:04.110
So in our case, a wire is
going to be super easy.

00:56:04.110 --> 00:56:10.080
It's just pleat, so two very
nearby parallel creases.

00:56:10.080 --> 00:56:13.150
And because they're nearby,
I mean, if you look locally,

00:56:13.150 --> 00:56:14.714
it's like a one
dimensional problem.

00:56:14.714 --> 00:56:16.630
They can't both be valley
or both be mountain.

00:56:16.630 --> 00:56:19.770
Because then these
two big panels

00:56:19.770 --> 00:56:21.627
would intersect each other.

00:56:21.627 --> 00:56:23.710
So one of them is valley,
one of them is mountain.

00:56:23.710 --> 00:56:25.117
There's exactly two choices.

00:56:25.117 --> 00:56:26.950
I'm going to always
have an arrow on my wire

00:56:26.950 --> 00:56:28.490
so I have a sense
of orientation,

00:56:28.490 --> 00:56:29.770
which way the signal is going.

00:56:29.770 --> 00:56:32.230
And once I have an
orientation, the left side,

00:56:32.230 --> 00:56:34.520
if the left side is
valley, that's true.

00:56:34.520 --> 00:56:37.240
If the left side is
mountain, that's false.

00:56:37.240 --> 00:56:39.204
That's just I'm going
to decide it that way.

00:56:39.204 --> 00:56:41.370
It doesn't actually matter,
because in this problem,

00:56:41.370 --> 00:56:42.800
true and false are symmetric.

00:56:42.800 --> 00:56:47.380
But I just need to be
consistent about which is which.

00:56:47.380 --> 00:56:49.062
OK, so that was the wire gadget.

00:56:49.062 --> 00:56:50.770
The next one is the
not all equal gadget.

00:56:50.770 --> 00:56:54.650
And I'm guessing this is
where Bern and Hayes started.

00:56:54.650 --> 00:56:57.170
Because it's sort of
the heart of the proof.

00:56:57.170 --> 00:56:59.670
Then there's all these details
to connect up with the wires,

00:56:59.670 --> 00:57:00.836
and split them, and whatnot.

00:57:00.836 --> 00:57:05.289
But this is something
called a triangular twist.

00:57:05.289 --> 00:57:06.580
You may have folded one before.

00:57:06.580 --> 00:57:08.104
It's kind of classic.

00:57:08.104 --> 00:57:09.770
So the crease pattern's
in the top left.

00:57:09.770 --> 00:57:11.895
And the idea is I have
three wires coming together.

00:57:11.895 --> 00:57:15.600
I want this thing to fold flat
if, and only if, the wires are

00:57:15.600 --> 00:57:18.080
not all the same.

00:57:18.080 --> 00:57:21.270
And I've drawn here sort of
three of the possible patterns

00:57:21.270 --> 00:57:21.920
you could have.

00:57:21.920 --> 00:57:23.530
Here I have one
truth and two false.

00:57:23.530 --> 00:57:25.150
That folds flat.

00:57:25.150 --> 00:57:28.140
Here I have three false.

00:57:28.140 --> 00:57:30.330
And here I have two
true and one false.

00:57:30.330 --> 00:57:32.240
This also folds flat.

00:57:32.240 --> 00:57:37.602
In all cases, this is what
the folded state looks like.

00:57:37.602 --> 00:57:38.810
I maybe never mentioned this.

00:57:38.810 --> 00:57:40.570
But this is an
important concept.

00:57:40.570 --> 00:57:45.290
If you take a crease pattern and
you say I want to fold it flat,

00:57:45.290 --> 00:57:47.710
you can tell where
all the stuff is

00:57:47.710 --> 00:57:49.900
going to go in
terms of geometry.

00:57:49.900 --> 00:57:51.730
What you can't tell
is the layer ordering.

00:57:51.730 --> 00:57:53.190
That depends on the
mountain valley assignment.

00:57:53.190 --> 00:57:55.670
That depends on how you
decide the layers to stack.

00:57:55.670 --> 00:57:58.990
But you can tell already where
everything goes in the plane.

00:57:58.990 --> 00:58:03.070
Because you pick, let's see,
did anything stay fixed here.

00:58:03.070 --> 00:58:04.850
Yeah, the triangle stayed fix.

00:58:04.850 --> 00:58:07.100
So you pick some face to
stay fixed, like that center

00:58:07.100 --> 00:58:07.662
triangle.

00:58:07.662 --> 00:58:08.370
You put it there.

00:58:08.370 --> 00:58:09.900
And then you say, OK.

00:58:09.900 --> 00:58:11.070
Well, where is this flap?

00:58:11.070 --> 00:58:13.920
Where is this face of the
crease pattern going to go?

00:58:13.920 --> 00:58:17.620
Well, it gets reflected
through that horizontal line.

00:58:17.620 --> 00:58:19.416
So it goes here.

00:58:19.416 --> 00:58:21.540
And you can just keep
playing this reflection game.

00:58:21.540 --> 00:58:24.080
Because you know every
crease geometrically,

00:58:24.080 --> 00:58:24.830
it's a reflection.

00:58:24.830 --> 00:58:26.840
It could be a reflection
this way or this way.

00:58:26.840 --> 00:58:28.900
But it just, as soon
as you cross a crease,

00:58:28.900 --> 00:58:31.320
you end up reflecting
your material.

00:58:31.320 --> 00:58:34.020
And so you can draw this
picture without knowing anything

00:58:34.020 --> 00:58:34.972
about how it's folded.

00:58:34.972 --> 00:58:37.430
Just if there's a flat folding,
it's got to look like this.

00:58:37.430 --> 00:58:38.880
And the annoying
thing about this

00:58:38.880 --> 00:58:43.690
set up, because that angle
up there is 35 degrees,

00:58:43.690 --> 00:58:47.990
these guys are going to
overlap in this common center.

00:58:47.990 --> 00:58:51.510
And in this situation where
it's all false or all true,

00:58:51.510 --> 00:58:54.081
you get an intersection there.

00:58:54.081 --> 00:58:55.330
It's a little tricky to prove.

00:58:55.330 --> 00:58:56.955
And you've just got
to fiddle with one.

00:58:56.955 --> 00:59:01.400
I should have brought
one, but that is true.

00:59:01.400 --> 00:59:03.650
And so in the all false and
symmetrically the all true

00:59:03.650 --> 00:59:05.520
case, this thing
does not fold flat.

00:59:05.520 --> 00:59:07.430
In all the other
situations, it folds fine.

00:59:07.430 --> 00:59:10.640
Because the layers
get out of the way.

00:59:10.640 --> 00:59:13.860
OK, also over here, and there's
a bunch of these in the book,

00:59:13.860 --> 00:59:16.210
are little analyses of
which of the creases

00:59:16.210 --> 00:59:18.465
have to have the same
mountain valley assignment

00:59:18.465 --> 00:59:20.210
and which have to
have different.

00:59:20.210 --> 00:59:22.780
That's actually how
these patterns are drawn.

00:59:22.780 --> 00:59:26.340
This is from our old local
analysis of a single vertex

00:59:26.340 --> 00:59:27.520
crease pattern, right.

00:59:27.520 --> 00:59:29.399
You've got these four creases.

00:59:29.399 --> 00:59:29.940
Check it out.

00:59:29.940 --> 00:59:33.210
The only one that could
be crimped is this one.

00:59:33.210 --> 00:59:34.710
Because it's globally smallest.

00:59:34.710 --> 00:59:40.090
All the other guys have a bigger
neighbor or are in trouble.

00:59:40.090 --> 00:59:41.340
So this guy has to be crimped.

00:59:41.340 --> 00:59:43.866
So these two are not equal.

00:59:43.866 --> 00:59:45.490
And therefore, these
two must be equal.

00:59:45.490 --> 00:59:47.379
And that's symmetrical
all the way around.

00:59:47.379 --> 00:59:48.920
So in fact, you know
that this crease

00:59:48.920 --> 00:59:51.014
is different from this
one, is equal to this one.

00:59:51.014 --> 00:59:52.930
You already knew that
these two are different.

00:59:52.930 --> 00:59:55.030
So that's OK.

00:59:55.030 --> 00:59:57.760
So you can figure out
these crease patterns.

00:59:57.760 --> 01:00:01.019
There's a little bit of flexi--
once you have the mountains

01:00:01.019 --> 01:00:03.560
and valleys coming in, you know
how the mountains and valleys

01:00:03.560 --> 01:00:04.840
have to be in the center.

01:00:04.840 --> 01:00:06.099
Just makes life easier.

01:00:06.099 --> 01:00:07.890
There's only one mountain
valley assignment

01:00:07.890 --> 01:00:09.150
you need to consider.

01:00:09.150 --> 01:00:12.720
And the symmetric one
turns out to be bad.

01:00:12.720 --> 01:00:14.580
So that's two gadgets.

01:00:14.580 --> 01:00:17.520
We got the wire, the
not all equal clause.

01:00:17.520 --> 01:00:20.412
Of course, if we're
lucky, all the wires

01:00:20.412 --> 01:00:21.870
will just meet at
the right points.

01:00:21.870 --> 01:00:23.210
But I'm going to need
many copies of them.

01:00:23.210 --> 01:00:24.890
I've got to move
them around to reach

01:00:24.890 --> 01:00:29.050
all the different clauses,
all the different triples.

01:00:29.050 --> 01:00:30.765
So next up is reflector.

01:00:37.560 --> 01:00:40.320
This is actually in
some sense really easy.

01:00:40.320 --> 01:00:44.292
So we have, here's our input.

01:00:44.292 --> 01:00:46.000
What the reflector is
going to do is it's

01:00:46.000 --> 01:00:50.350
going to make two copies, one
down here which is negated,

01:00:50.350 --> 01:00:54.190
and one up here, which
is the same value.

01:00:54.190 --> 01:00:55.930
And it also effectively
turns the signal

01:00:55.930 --> 01:00:58.400
two different directions.

01:00:58.400 --> 01:01:02.100
So to see why it works
is actually pretty easy.

01:01:02.100 --> 01:01:04.400
It's just a local
analysis again.

01:01:04.400 --> 01:01:05.710
You look at this vertex.

01:01:05.710 --> 01:01:08.270
This is the only increase
they could be crimped.

01:01:08.270 --> 01:01:12.120
So we know that these two
guys have opposite assignment.

01:01:12.120 --> 01:01:16.147
Therefore, these two wires
will have opposite value.

01:01:16.147 --> 01:01:17.730
And actually, they
have the same value

01:01:17.730 --> 01:01:19.480
if they're pointing
in the same direction.

01:01:19.480 --> 01:01:21.680
But they'll have
opposite value because I

01:01:21.680 --> 01:01:24.686
decided this one's
pointing down.

01:01:24.686 --> 01:01:27.060
So if this one's a mountain,
this one has to be a valley.

01:01:27.060 --> 01:01:29.650
And so if this is true because
it's valley on the left,

01:01:29.650 --> 01:01:33.286
this one's false because
it's mountain on the left.

01:01:33.286 --> 01:01:35.030
OK, and then you can
do the same thing.

01:01:35.030 --> 01:01:37.520
Then you also know these
two guys are equal.

01:01:37.520 --> 01:01:40.650
And because again, this is
the only crimpable pair here,

01:01:40.650 --> 01:01:42.730
these two creases are not equal.

01:01:42.730 --> 01:01:44.482
And so you know these
two guys are equal

01:01:44.482 --> 01:01:45.690
and these two guys are equal.

01:01:45.690 --> 01:01:51.130
And so you know that this
valley is propagated up there.

01:01:51.130 --> 01:01:53.486
And therefore, these two
wires have the same value.

01:01:53.486 --> 01:01:54.610
So you've split the signal.

01:01:54.610 --> 01:01:57.790
You've made a positive
copy and a negated copy.

01:01:57.790 --> 01:01:59.740
And if you just do
this again, you'll

01:01:59.740 --> 01:02:04.990
get-- this will make
another negated copy

01:02:04.990 --> 01:02:07.292
and a positive copy.

01:02:07.292 --> 01:02:09.250
So I get two positive
copies and a negated one.

01:02:09.250 --> 01:02:10.875
You can just keep
doing this and you'll

01:02:10.875 --> 01:02:13.084
get tons of positive copies,
tons of negative copies.

01:02:13.084 --> 01:02:15.041
So it doesn't even matter
if it's all positive.

01:02:15.041 --> 01:02:16.500
But if you take
all positive ones.

01:02:16.500 --> 01:02:18.160
Let the others go
off to infinity.

01:02:18.160 --> 01:02:21.430
And now you want to
move around so that they

01:02:21.430 --> 01:02:23.307
hit those not all equal clauses.

01:02:23.307 --> 01:02:24.390
How do I move them around?

01:02:24.390 --> 01:02:26.040
I just use more reflectors.

01:02:26.040 --> 01:02:28.480
If I come in at some
angle, I can now

01:02:28.480 --> 01:02:30.470
turn by however much that is.

01:02:30.470 --> 01:02:32.656
Or I can turn by
however much that is.

01:02:32.656 --> 01:02:35.030
I'm not going to try to figure
out what those angles are.

01:02:35.030 --> 01:02:39.916
But it turns out, this is
enough to make everything work.

01:02:39.916 --> 01:02:42.290
The last thing you need are
a bunch of crossover gadgets.

01:02:42.290 --> 01:02:43.123
This is one of them.

01:02:43.123 --> 01:02:44.475
There's a second one.

01:02:44.475 --> 01:02:46.100
I'll just wave my
hands and say, if you

01:02:46.100 --> 01:02:48.500
take two pleats in
the obvious way,

01:02:48.500 --> 01:02:50.590
they really don't
care about each other.

01:02:50.590 --> 01:02:52.505
Because the way to
fold this locally,

01:02:52.505 --> 01:02:55.210
is to fold this diagonal
pleat and then fold

01:02:55.210 --> 01:02:56.310
the vertical pleat.

01:02:56.310 --> 01:02:58.876
And it will work whether
one pleat is true or false.

01:02:58.876 --> 01:03:01.500
It doesn't matter which side is
valley, which side is mountain.

01:03:01.500 --> 01:03:02.980
It always works.

01:03:02.980 --> 01:03:06.570
So crossovers aren't
actually that big a deal.

01:03:06.570 --> 01:03:08.630
Once you have that,
you take those gadgets.

01:03:08.630 --> 01:03:10.560
And you put them together
into a monstrosity

01:03:10.560 --> 01:03:14.240
of a crease pattern, which
looks something like this.

01:03:14.240 --> 01:03:17.530
And this took forever
to draw, I remember.

01:03:17.530 --> 01:03:20.660
So we have on the left
side our variables.

01:03:20.660 --> 01:03:21.680
These are just wires.

01:03:21.680 --> 01:03:22.960
They're pleats.

01:03:22.960 --> 01:03:26.080
And each one could be
folded true or false,

01:03:26.080 --> 01:03:28.620
left over right or
right over left.

01:03:28.620 --> 01:03:30.540
And then I do a whole
bunch of reflectors,

01:03:30.540 --> 01:03:32.810
just reflect, reflect,
reflect, reflect, reflect,

01:03:32.810 --> 01:03:35.940
just to make a whole
bunch of copies.

01:03:35.940 --> 01:03:44.110
And then at the top there, way
at that little yellow triangle,

01:03:44.110 --> 01:03:45.740
is a not all equal clause.

01:03:45.740 --> 01:03:49.870
And is a not all equal
clause between x3,

01:03:49.870 --> 01:03:51.570
where we make a copy.

01:03:51.570 --> 01:03:53.080
Wow, this is crazy.

01:03:53.080 --> 01:03:55.310
I end up making a copy,
negate it downwards,

01:03:55.310 --> 01:03:56.730
and I flip it around.

01:03:56.730 --> 01:03:58.640
And it goes up straight.

01:03:58.640 --> 01:04:01.400
And then I turn it at an angle
to hit the triangle dead on,

01:04:01.400 --> 01:04:03.450
the way it's supposed to.

01:04:03.450 --> 01:04:06.890
Then I also take x1
up the top, just get

01:04:06.890 --> 01:04:08.590
a copy straight
off the top there.

01:04:08.590 --> 01:04:10.799
And x2, I take a copy here.

01:04:10.799 --> 01:04:13.090
For some reason I feel like
negating it, and turning it

01:04:13.090 --> 01:04:15.390
around, and spitting
it up there.

01:04:15.390 --> 01:04:16.700
And then I turn it back down.

01:04:16.700 --> 01:04:18.990
It hits the yellow triangle
at just the right angle.

01:04:18.990 --> 01:04:21.073
And therefore, if this
thing's going to fold flat,

01:04:21.073 --> 01:04:23.500
it must be that x1, x2,
and x3 are not all equal.

01:04:23.500 --> 01:04:26.480
And you just keep doing
that, one for every triple.

01:04:26.480 --> 01:04:31.380
Remember, we're given as input
one of these not all equal SAT

01:04:31.380 --> 01:04:31.880
problems.

01:04:31.880 --> 01:04:33.270
I give you a bunch of triples.

01:04:33.270 --> 01:04:37.540
I just put the wires together
according to those triples.

01:04:37.540 --> 01:04:39.320
This thing we flat
foldable if and only

01:04:39.320 --> 01:04:43.290
if this formula is satisfiable.

01:04:43.290 --> 01:04:46.540
You can set the pleats so that
the desired triples are not

01:04:46.540 --> 01:04:47.510
equal.

01:04:47.510 --> 01:04:49.260
So that's pretty crazy.

01:04:49.260 --> 01:04:51.860
This is in some sense
one of the hardest proofs

01:04:51.860 --> 01:04:54.710
that we will see.

01:04:54.710 --> 01:04:56.715
But in the end,
you get NP-hardness

01:04:56.715 --> 01:04:59.605
of flat foldability.

01:04:59.605 --> 01:05:00.105
Questions?

01:05:02.860 --> 01:05:05.885
OK, I want to do one
more proof sketch.

01:05:40.890 --> 01:05:43.540
This is yet another
paper that was

01:05:43.540 --> 01:05:45.800
at this year's Origami in
Science Math and Education

01:05:45.800 --> 01:05:46.880
conference.

01:05:46.880 --> 01:05:49.810
This is, it's fun
to teach this class.

01:05:49.810 --> 01:05:53.220
Because it changes so much
over a period of three years.

01:05:53.220 --> 01:05:54.080
Lots of new results.

01:05:54.080 --> 01:05:55.460
This is a result
with a guy named

01:05:55.460 --> 01:05:57.380
Sandor Fekete from Germany.

01:05:57.380 --> 01:06:04.080
He does a lot of optimization,
and Robert Lang, and myself.

01:06:04.080 --> 01:06:08.730
So disk packing is something
we talked about last class

01:06:08.730 --> 01:06:11.550
in the context of the tree
method of origami design.

01:06:11.550 --> 01:06:14.360
We said, in particular we were
thinking of this situation

01:06:14.360 --> 01:06:17.290
where we wanted to make them
a Margulis napkin counter

01:06:17.290 --> 01:06:19.190
example.

01:06:19.190 --> 01:06:20.390
So this was equivalent.

01:06:20.390 --> 01:06:24.650
If we wanted to build this
uniaxial base and sides,

01:06:24.650 --> 01:06:31.210
was the same thing as packing
n disks into a square.

01:06:31.210 --> 01:06:34.830
That's what the
tree method shows.

01:06:34.830 --> 01:06:37.430
So in some sense, I'm
talking about this problem.

01:06:37.430 --> 01:06:39.430
But equivalently, I'm
talking about this problem

01:06:39.430 --> 01:06:41.440
of packing disks into a square.

01:06:41.440 --> 01:06:44.250
Now if I give you n unit
disks all the same size,

01:06:44.250 --> 01:06:49.710
I want to pack them in a square,
that problem cannot be NP-hard.

01:06:49.710 --> 01:06:51.800
That's annoying.

01:06:51.800 --> 01:06:53.520
But the input is only n.

01:06:53.520 --> 01:06:54.920
It's not very interesting.

01:06:54.920 --> 01:07:00.300
So to make it harder, be able
to show that this problem is

01:07:00.300 --> 01:07:02.200
computationally
intractable, I'm going

01:07:02.200 --> 01:07:04.370
to consider
generalization, which

01:07:04.370 --> 01:07:07.180
is I still have this
kind of star tree,

01:07:07.180 --> 01:07:09.280
still a very simple
kind of uniaxial base I

01:07:09.280 --> 01:07:10.680
might want to build.

01:07:10.680 --> 01:07:13.610
But now all the limbs
are different lengths.

01:07:13.610 --> 01:07:18.510
So what that corresponds to is
I have disks of various sizes.

01:07:22.310 --> 01:07:24.002
It's kind of fun.

01:07:24.002 --> 01:07:24.865
It's like bubbles.

01:07:27.446 --> 01:07:28.320
They all have to fit.

01:07:28.320 --> 01:07:29.750
They can't overlap each other.

01:07:29.750 --> 01:07:32.840
All of the centers of the
disks are inside the square.

01:07:35.430 --> 01:07:38.330
And I want to know,
can I-- how big

01:07:38.330 --> 01:07:39.985
a square do I need to pack them?

01:07:39.985 --> 01:07:44.500
OK, I'm going to formulate it as
a decision question, yes or no.

01:07:44.500 --> 01:07:50.360
Can you place n given disks,
I give you the sizes of them.

01:07:54.224 --> 01:07:55.640
I want them to be
non-overlapping.

01:07:59.100 --> 01:08:01.740
They can touch on the
boundary but the interiors

01:08:01.740 --> 01:08:03.600
can't overlap.

01:08:03.600 --> 01:08:10.720
And I need the centers
to lie in a given square.

01:08:10.720 --> 01:08:13.010
So I want to know, can I
make this uniaxial base

01:08:13.010 --> 01:08:15.280
from this square paper?

01:08:15.280 --> 01:08:18.560
And I claim that as NP-hard.

01:08:18.560 --> 01:08:21.580
So good luck solving
it perfectly.

01:08:21.580 --> 01:08:23.260
And what tree maker
does is it solves

01:08:23.260 --> 01:08:25.740
it approximately
with a heuristic.

01:08:32.625 --> 01:08:34.500
For those who know
approximation algorithims,

01:08:34.500 --> 01:08:38.300
this is a problem you can find
a constant factor approximation.

01:08:38.300 --> 01:08:39.990
There's one in the same paper.

01:08:39.990 --> 01:08:41.729
But it's still not,
still unresolved

01:08:41.729 --> 01:08:44.410
how close to
optimal you can get.

01:08:47.146 --> 01:08:48.979
But I want to focus
here on the NP-hardness.

01:08:54.350 --> 01:08:58.470
So I should say this
problem is NP-hard.

01:09:03.760 --> 01:09:04.979
So we're going to prove that.

01:09:08.279 --> 01:09:13.109
And now I get to reduce
for my favorite problem,

01:09:13.109 --> 01:09:15.390
favorite NP-hard.

01:09:15.390 --> 01:09:19.410
It's my favorite partly
because not many people know it

01:09:19.410 --> 01:09:22.279
unless you've done NP-hardness
proofs with me before.

01:09:22.279 --> 01:09:25.600
And it's very powerful.

01:09:25.600 --> 01:09:27.840
Whenever you have a problem
that involves numbers,

01:09:27.840 --> 01:09:29.256
and this problem
involves numbers.

01:09:29.256 --> 01:09:31.399
It's the radii of the disk's.

01:09:31.399 --> 01:09:34.500
Three partition is the
problem you should know.

01:09:34.500 --> 01:09:36.180
Partition is all right.

01:09:36.180 --> 01:09:38.140
The three partition
is like 50% better.

01:09:41.700 --> 01:09:44.920
Because partition is like you've
partitioned it to two parts.

01:09:44.920 --> 01:09:46.580
So it's like two partition.

01:09:46.580 --> 01:09:48.124
Three partition,
you partition into?

01:09:51.780 --> 01:09:53.850
Does not one have
the right answer?

01:09:53.850 --> 01:09:55.720
I hear three parts
and five parts.

01:09:55.720 --> 01:09:56.660
Any other guesses?

01:09:56.660 --> 01:09:57.660
AUDIENCE: Seven

01:09:57.660 --> 01:09:59.830
PROFESSOR: Seven.

01:09:59.830 --> 01:10:02.050
Keep going.

01:10:02.050 --> 01:10:04.630
n over three parts
is the answer.

01:10:04.630 --> 01:10:08.541
So it's not so obvious.

01:10:08.541 --> 01:10:10.415
Maybe it should be called
n over 3 partition.

01:10:16.884 --> 01:10:18.800
So instead of the number
of parts being three,

01:10:18.800 --> 01:10:21.845
the size of each part is three.

01:10:21.845 --> 01:10:23.720
So n should be divisible by 3.

01:10:26.997 --> 01:10:28.580
So I'm going to
partition it to n over

01:10:28.580 --> 01:10:31.300
3 triples of numbers
of equal sum.

01:10:39.500 --> 01:10:43.980
This problem is cool for
this technical reason

01:10:43.980 --> 01:10:45.730
that it is strongly NP-hard.

01:10:48.370 --> 01:10:54.720
So even when the numbers are
really small, like about n,

01:10:54.720 --> 01:10:56.260
this problem is NP-hard.

01:10:56.260 --> 01:10:59.100
With partition, the numbers
had to be exponential and n

01:10:59.100 --> 01:11:00.420
for the problem to be hard.

01:11:00.420 --> 01:11:02.190
And that's kind of
artificial here.

01:11:02.190 --> 01:11:05.390
So this is actually
strongly NP-hard.

01:11:05.390 --> 01:11:06.990
So this problem
is hard even when

01:11:06.990 --> 01:11:09.470
the disk sizes are
not that different.

01:11:09.470 --> 01:11:12.120
There's like a range between
one and n, let's say.

01:11:12.120 --> 01:11:14.690
If I reduce from partition,
I'd need some disks

01:11:14.690 --> 01:11:17.640
to be microscopic and
some to be ginormous,

01:11:17.640 --> 01:11:19.954
exponential difference.

01:11:19.954 --> 01:11:21.620
I'm going to reduce
from three partition

01:11:21.620 --> 01:11:23.080
because I get a better result.

01:11:23.080 --> 01:11:25.580
I get a stronger result the
says even when the disks are not

01:11:25.580 --> 01:11:28.190
so different in size,
this problem is NP-hard.

01:11:31.860 --> 01:11:42.500
That's my problem that
I've got to start from.

01:11:42.500 --> 01:11:45.055
So I give you n integers.

01:11:45.055 --> 01:11:53.430
I want to somehow triple
them up using a disk packing.

01:11:53.430 --> 01:11:55.380
So somehow solving a
disk packing problem

01:11:55.380 --> 01:11:58.720
is going to solve this
three partition problem.

01:11:58.720 --> 01:11:59.730
And it's kind of crazy.

01:12:03.600 --> 01:12:05.330
I'll give you the
high level picture.

01:12:16.027 --> 01:12:20.755
It's n over three
identical pockets.

01:12:36.250 --> 01:12:40.640
So in this case, there
is kind of like the proof

01:12:40.640 --> 01:12:45.564
where we had the simple folds
and we a frame and some stuff.

01:12:45.564 --> 01:12:47.480
We're going to have some
infrastructure, which

01:12:47.480 --> 01:12:48.604
in that case was the frame.

01:12:48.604 --> 01:12:51.070
That was sort of a basic
thing that always exists.

01:12:51.070 --> 01:12:53.528
In this case, we're going to
have some infrastructure which

01:12:53.528 --> 01:12:55.710
is a whole bunch of disks
that just sort of set,

01:12:55.710 --> 01:12:58.570
instead of having this very
open problem, open playing

01:12:58.570 --> 01:13:01.850
field with a square, and like
you could put disks anywhere,

01:13:01.850 --> 01:13:03.890
I want to partition
my square into lots

01:13:03.890 --> 01:13:07.900
of little pockets, all the
same size, all the same shape.

01:13:07.900 --> 01:13:13.452
And all other pockets are
going to be much smaller.

01:13:13.452 --> 01:13:14.910
So it's a little
hard to draw this.

01:13:14.910 --> 01:13:16.659
Because while I said
that the disks aren't

01:13:16.659 --> 01:13:18.890
that different size,
they're only a factor of n

01:13:18.890 --> 01:13:22.530
different in size, if you
try to draw these pictures,

01:13:22.530 --> 01:13:24.400
it gets tiny very quickly.

01:13:24.400 --> 01:13:26.460
So here's the high
level picture.

01:13:26.460 --> 01:13:28.660
You have a square.

01:13:28.660 --> 01:13:31.860
And I'm going to put
down these disks.

01:13:31.860 --> 01:13:40.140
There's 20 disks here, I
think, 4 times 4 is 16 plus 5.

01:13:40.140 --> 01:13:41.830
I'm sorry, 21.

01:13:41.830 --> 01:13:45.517
So these 21 disks, they
have a unique package,

01:13:45.517 --> 01:13:46.350
this one right here.

01:13:46.350 --> 01:13:48.450
You can see that
because these four disks

01:13:48.450 --> 01:13:51.660
have to be in the corners,
can't fit one in the center

01:13:51.660 --> 01:13:53.070
and have room for the others.

01:13:53.070 --> 01:13:55.190
Then this guy has
to go right there.

01:13:55.190 --> 01:13:58.439
And then these four disks are
unique if you set it up right.

01:13:58.439 --> 01:13:59.980
It's a little bit,
it's hard to draw.

01:13:59.980 --> 01:14:04.690
But these are little bit
wedged over to the right.

01:14:04.690 --> 01:14:05.880
So you set up these disks.

01:14:05.880 --> 01:14:06.900
That's infrastructure.

01:14:06.900 --> 01:14:08.720
It's the only way to put them.

01:14:08.720 --> 01:14:10.940
And then there's these
little pockets here.

01:14:10.940 --> 01:14:12.080
They're nice.

01:14:12.080 --> 01:14:13.400
They're symmetric.

01:14:13.400 --> 01:14:15.800
They're like a triangle,
an equilateral triangle

01:14:15.800 --> 01:14:17.840
so to speak, except
they have curved edges.

01:14:17.840 --> 01:14:19.640
They're all the same size.

01:14:19.640 --> 01:14:21.400
That gives me four pockets.

01:14:21.400 --> 01:14:23.260
But I want n over 3 pockets.

01:14:23.260 --> 01:14:25.310
So I'm going to need a lot more.

01:14:25.310 --> 01:14:27.070
So I take each of these pockets.

01:14:27.070 --> 01:14:30.060
That's these three disks.

01:14:30.060 --> 01:14:32.560
And this is the triangular
pocket in the center.

01:14:32.560 --> 01:14:37.000
And I put down these 17 disks.

01:14:37.000 --> 01:14:38.510
It's almost the same.

01:14:38.510 --> 01:14:40.390
And I can see it's not
quite drawn perfectly.

01:14:40.390 --> 01:14:42.730
This is supposed to touch here.

01:14:42.730 --> 01:14:45.310
This guy is floating
a little bit.

01:14:45.310 --> 01:14:48.655
And what we end up, this
guy's uniquely placed.

01:14:48.655 --> 01:14:51.030
And then these guys have got
to go in the three remaining

01:14:51.030 --> 01:14:51.530
pockets.

01:14:51.530 --> 01:14:55.690
What we end up getting is
another equilateral whole

01:14:55.690 --> 01:14:57.110
pocket right there.

01:14:57.110 --> 01:15:00.900
And these three will have the
same size and be identical.

01:15:00.900 --> 01:15:02.830
If I do that in
all four of these,

01:15:02.830 --> 01:15:05.650
now I'll have 16 pockets.

01:15:05.650 --> 01:15:07.900
And each time I do
this, side I quadruple

01:15:07.900 --> 01:15:09.770
the number of pockets.

01:15:09.770 --> 01:15:12.520
So after I do it,
whatever log n times,

01:15:12.520 --> 01:15:14.470
or I apply that
gadget around n times,

01:15:14.470 --> 01:15:17.020
I get around n over 3 pockets.

01:15:17.020 --> 01:15:18.020
They're all identical.

01:15:18.020 --> 01:15:20.270
The ones I don't want, I'll
just throw a disk in there

01:15:20.270 --> 01:15:22.270
to destroy it.

01:15:22.270 --> 01:15:24.017
That's the infrastructure.

01:15:24.017 --> 01:15:25.850
Now I've got n over
three identical pockets.

01:15:25.850 --> 01:15:27.200
There are these other pockets.

01:15:27.200 --> 01:15:28.535
Just throw in disks in there.

01:15:28.535 --> 01:15:30.160
I mean, I can't force
them to go there.

01:15:30.160 --> 01:15:32.200
But if you set disks
to the right size,

01:15:32.200 --> 01:15:34.210
they really have to go there.

01:15:34.210 --> 01:15:36.660
And so all of the other
pockets will get even tinier.

01:15:36.660 --> 01:15:39.767
It will destroy them.

01:15:39.767 --> 01:15:40.850
That's the infrastructure.

01:15:40.850 --> 01:15:42.454
It's already pretty crazy.

01:15:42.454 --> 01:15:44.120
But then the last
part is actually kind,

01:15:44.120 --> 01:15:49.137
is very cool and elegant.

01:15:49.137 --> 01:15:50.595
So I've got these
n over 3 pockets.

01:15:54.840 --> 01:15:56.829
And this was the central
idea we started with.

01:15:56.829 --> 01:15:58.620
It actually took us
awhile to find this way

01:15:58.620 --> 01:16:00.822
to force a bunch of
identical pockets.

01:16:00.822 --> 01:16:02.780
It's easy if you start
from a triangle of paper

01:16:02.780 --> 01:16:03.870
or a rectangle of paper.

01:16:03.870 --> 01:16:06.210
But we really wanted
to start from a square.

01:16:06.210 --> 01:16:08.560
So that's the case we
care about in origami.

01:16:08.560 --> 01:16:11.580
And so we came up
with that proof.

01:16:11.580 --> 01:16:15.840
This is hard to draw perfectly.

01:16:15.840 --> 01:16:17.950
Here's an equilateral
triangle, so to speak,

01:16:17.950 --> 01:16:21.310
of equal radius disks
pairwise kissing.

01:16:21.310 --> 01:16:23.666
A little slightly
wrong aspect ratio.

01:16:23.666 --> 01:16:24.540
But you get the idea.

01:16:27.800 --> 01:16:31.160
I'm going to put a disk here
that has a little bit of slack.

01:16:34.240 --> 01:16:39.905
I'm going to put a disk
here that-- actually, I'm

01:16:39.905 --> 01:16:41.530
going to draw them
without slack first.

01:16:41.530 --> 01:16:43.560
And then I'm going to
say how the slack is.

01:16:43.560 --> 01:16:45.620
Because that'll be
clearer what I mean.

01:16:45.620 --> 01:16:48.310
So suppose this guy was
actually kissing all three.

01:16:48.310 --> 01:16:52.074
And this guy was
kissing three and it's

01:16:52.074 --> 01:16:54.265
like a bunch of threesomes here.

01:16:54.265 --> 01:16:58.850
All right, now I want to
make each of these disks

01:16:58.850 --> 01:17:02.670
a little bit bigger, which
will make this impossible.

01:17:02.670 --> 01:17:06.100
But then I'm going to make
this guy a little bit smaller.

01:17:06.100 --> 01:17:11.745
So I'm going to make
this one ai bigger.

01:17:11.745 --> 01:17:13.920
I'm going to make
this one aj bigger.

01:17:17.150 --> 01:17:20.694
I'm going to make
this one ak bigger.

01:17:23.620 --> 01:17:31.090
And this one, what did
I call it, L, smaller.

01:17:31.090 --> 01:17:40.290
So L is the target
sum for a triple,

01:17:40.290 --> 01:17:43.570
meaning I take all the
integers that I'm given.

01:17:43.570 --> 01:17:47.790
And I add them all up.

01:17:47.790 --> 01:17:49.580
And then I divide by n over 3.

01:17:49.580 --> 01:17:51.310
That's what every
triple should sum to.

01:17:51.310 --> 01:17:53.770
Because they're all
supposed to be the same.

01:17:53.770 --> 01:17:58.000
So I call that L. This is
the sum divided by n over 3.

01:18:00.820 --> 01:18:03.880
So I'm going to make this
one that much smaller.

01:18:03.880 --> 01:18:05.710
This is all slightly
approximate.

01:18:05.710 --> 01:18:06.750
Bear with me.

01:18:06.750 --> 01:18:08.680
So that gives it a
little bit of slack,

01:18:08.680 --> 01:18:11.390
which is good because these
guys are little bit bigger.

01:18:11.390 --> 01:18:16.790
And if they are bigger, in total
if the sum of these two values

01:18:16.790 --> 01:18:19.600
is L, this will barely fit.

01:18:19.600 --> 01:18:21.610
If it's bigger than
L, it won't fit.

01:18:21.610 --> 01:18:24.710
If it's less than
L, it will fit.

01:18:24.710 --> 01:18:27.970
But because L has
to be, L is always

01:18:27.970 --> 01:18:31.670
the average sum of the
triples, if they're all

01:18:31.670 --> 01:18:33.760
going to-- if you have
a bunch of triples,

01:18:33.760 --> 01:18:36.870
all of whose sum is less
than or equal to L, in fact

01:18:36.870 --> 01:18:39.680
they all have to be exactly
equal L. Because there's

01:18:39.680 --> 01:18:41.430
no slack.

01:18:41.430 --> 01:18:44.340
So the only way for these guys
to pack, now I said this is ai,

01:18:44.340 --> 01:18:47.880
aj, ak, in fact I'm just giving
you a heap, a bag of disks.

01:18:47.880 --> 01:18:49.600
I don't say which ones go where.

01:18:49.600 --> 01:18:51.220
You have to choose.

01:18:51.220 --> 01:18:52.949
So clearly, these are
all the same size.

01:18:52.949 --> 01:18:54.740
And they're just going
to go in the center.

01:18:54.740 --> 01:18:57.280
And they'll wiggle
around a little.

01:18:57.280 --> 01:19:01.520
These guys, you get to
choose how I triple them up

01:19:01.520 --> 01:19:03.859
and how I put them into
these n over 3 pockets.

01:19:03.859 --> 01:19:05.650
So that's your flexibility
in disk packing.

01:19:05.650 --> 01:19:07.700
It's your only flexibility
in disk packing,

01:19:07.700 --> 01:19:09.200
is how you triple them up.

01:19:09.200 --> 01:19:10.630
And the only way
for it to work is

01:19:10.630 --> 01:19:13.590
if you can triple them up
so that their sums, the sum

01:19:13.590 --> 01:19:15.520
of the amount by
which they are bigger,

01:19:15.520 --> 01:19:18.570
is exactly L. Because that's
exactly the slack of this disk.

01:19:18.570 --> 01:19:20.740
And it will just fit.

01:19:20.740 --> 01:19:21.665
Question?

01:19:21.665 --> 01:19:25.060
AUDIENCE: So the fact that you
have an increase in the ai, j,

01:19:25.060 --> 01:19:30.965
k [INAUDIBLE] geometry work out
with some tangents and stuff?

01:19:30.965 --> 01:19:32.090
PROFESSOR: Yeah, all right.

01:19:32.090 --> 01:19:35.210
So you raise a good point, which
is I said this is ai bigger.

01:19:35.210 --> 01:19:37.310
I didn't really mean that
the radius is ai bigger,

01:19:37.310 --> 01:19:40.840
although it's actually
close to that.

01:19:40.840 --> 01:19:41.750
ai is an integer.

01:19:41.750 --> 01:19:44.320
If I made it that much
bigger, it might be huge.

01:19:44.320 --> 01:19:46.140
But what I really
mean is I take ai,

01:19:46.140 --> 01:19:49.580
I multiply it by a very small
number greater than zero

01:19:49.580 --> 01:19:51.220
called epsilon.

01:19:51.220 --> 01:19:54.020
And all of these are
actually by epsilon.

01:19:54.020 --> 01:19:56.964
And that is actually how
much you change the radius.

01:19:56.964 --> 01:19:58.380
Maybe there's a
second order term.

01:19:58.380 --> 01:20:01.782
But to the first order, yeah you
think, oh, there's this trig.

01:20:01.782 --> 01:20:03.990
And I've got to do tangents
and all this funny stuff.

01:20:03.990 --> 01:20:05.698
It turns out to the
first order, actually

01:20:05.698 --> 01:20:07.680
things work really simply.

01:20:07.680 --> 01:20:12.849
If I shrink this disk
by an additive amount,

01:20:12.849 --> 01:20:15.140
or sorry, if I grow these
disks by and additive amount,

01:20:15.140 --> 01:20:17.600
I shrink this by
the same amount,

01:20:17.600 --> 01:20:22.160
this will still work up
to the first order, so up

01:20:22.160 --> 01:20:23.160
to the first derivative.

01:20:23.160 --> 01:20:25.160
So you might have to do
a little bit of fudging.

01:20:25.160 --> 01:20:29.440
I can just subtract off an
epsilon squared or something

01:20:29.440 --> 01:20:31.680
to give me just a
little bit of freedom.

01:20:31.680 --> 01:20:34.140
And then this is actually
how big the disks are.

01:20:34.140 --> 01:20:35.270
But you raise a good point.

01:20:35.270 --> 01:20:37.310
There's details I'm hiding here.

01:20:37.310 --> 01:20:38.782
It's actually pretty clean.

01:20:38.782 --> 01:20:40.490
You work out the
tangents and things just

01:20:40.490 --> 01:20:42.570
are pretty, surprisingly.

01:20:42.570 --> 01:20:44.150
We thought this would be messy.

01:20:44.150 --> 01:20:45.972
But it actually
works pretty well.

01:20:45.972 --> 01:20:46.805
Other the questions?

01:20:49.420 --> 01:20:50.200
All right.

01:20:50.200 --> 01:20:53.170
Now you're experts at
NP-hardness of origami.

01:20:57.040 --> 01:21:03.450
So here's the no equal
set clause gadget.

01:21:03.450 --> 01:21:07.800
And if we fold it here
with all of the incoming

01:21:07.800 --> 01:21:13.520
signals the same direction,
in the center they collide.

01:21:13.520 --> 01:21:15.600
You can't go all
the way to flat.

01:21:15.600 --> 01:21:17.840
This thing is not yet folded.

01:21:17.840 --> 01:21:21.475
And it's stuck in the center.

01:21:21.475 --> 01:21:27.570
But if I flip one of
them, I'll flip this guy,

01:21:27.570 --> 01:21:29.269
then it very happily folds flat.

01:21:29.269 --> 01:21:31.560
Because you don't get that
collision because the center

01:21:31.560 --> 01:21:33.880
ends up going off to the side.

01:21:33.880 --> 01:21:36.652
And you can check that for all
three, it's actually symmetric.

01:21:36.652 --> 01:21:39.110
But no matter how these guys
are set, if they're all equal,

01:21:39.110 --> 01:21:40.900
you get collision in the center.

01:21:40.900 --> 01:21:43.490
If they're not all
equal, it folds flat.

