WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.000
[MUSIC PLAYING]

00:00:04.628 --> 00:00:06.420
JONATHAN GERRISH: Good
morning and welcome.

00:00:06.420 --> 00:00:10.410
My name's Jonathan, and
I'm an engineer at Google.

00:00:10.410 --> 00:00:12.260
And welcome to today's session.

00:00:12.260 --> 00:00:14.030
We're going to talk
about how to build

00:00:14.030 --> 00:00:15.890
testable apps for Android.

00:00:19.210 --> 00:00:22.840
So through the history of
time, architectures continually

00:00:22.840 --> 00:00:29.460
evolved in style and ambition
to fit our expanding visions.

00:00:29.460 --> 00:00:31.500
In order to build these
increasingly complex

00:00:31.500 --> 00:00:33.930
architectures, we've
needed to also innovate

00:00:33.930 --> 00:00:36.180
new tools and
patterns and methods

00:00:36.180 --> 00:00:38.730
to meet the demands
of building them.

00:00:38.730 --> 00:00:41.250
And just like in the
real world, in software,

00:00:41.250 --> 00:00:46.340
too, we've all had our
own evolutionary path.

00:00:46.340 --> 00:00:49.703
We've seen this in
Android Development, too.

00:00:49.703 --> 00:00:51.995
Who remembers building smaller
applications in Eclipse?

00:00:55.310 --> 00:00:58.140
And as the complexity of
our applications grew,

00:00:58.140 --> 00:01:01.940
so did the need for better
tools and testing tools.

00:01:01.940 --> 00:01:04.833
And now today, we're building
a quite complex applications

00:01:04.833 --> 00:01:05.750
within Android Studio.

00:01:08.510 --> 00:01:10.500
And last year, it
was Jetpack, which

00:01:10.500 --> 00:01:12.210
included a lot of
great libraries

00:01:12.210 --> 00:01:14.680
to abstract some of
the details, allowing

00:01:14.680 --> 00:01:17.250
those developers to focus
on writing great features.

00:01:20.500 --> 00:01:23.720
But sometimes the evolution
hasn't always been easy.

00:01:23.720 --> 00:01:25.620
And choices developers
have had to make

00:01:25.620 --> 00:01:28.310
haven't always been so clear.

00:01:28.310 --> 00:01:30.990
So how do you answer
questions such as,

00:01:30.990 --> 00:01:33.540
how should I architect
my application?

00:01:33.540 --> 00:01:36.820
Or, how do I organize
my code base?

00:01:36.820 --> 00:01:38.500
What library should I choose?

00:01:38.500 --> 00:01:41.980
And what tools should I pick?

00:01:41.980 --> 00:01:44.500
The choices that you make
early on in development

00:01:44.500 --> 00:01:48.160
have a long-lasting impact on
the testability of your app,

00:01:48.160 --> 00:01:51.250
and thereby, your development
velocity and your ability

00:01:51.250 --> 00:01:54.612
to add new features sustainably.

00:01:54.612 --> 00:01:56.070
Well, today we're
going to show you

00:01:56.070 --> 00:01:58.410
with some real-world
examples how

00:01:58.410 --> 00:02:01.020
to make the pragmatic
decisions in how you build

00:02:01.020 --> 00:02:04.405
your applications in order
to build a long-term testing

00:02:04.405 --> 00:02:04.905
strategy.

00:02:08.509 --> 00:02:12.400
In testing, the key attribute
to consider is scope.

00:02:12.400 --> 00:02:16.390
Now, scope means how much of
my applications in my test

00:02:16.390 --> 00:02:20.950
covering and test could run
in on just a single method,

00:02:20.950 --> 00:02:25.180
or they could span multiple
features, multiple screens.

00:02:25.180 --> 00:02:29.338
And scope directly impacts two
other attributes of testing.

00:02:29.338 --> 00:02:31.710
Speed.

00:02:31.710 --> 00:02:34.090
How fast does your test run?

00:02:34.090 --> 00:02:37.080
And some can take from the order
of milliseconds, and others

00:02:37.080 --> 00:02:40.490
all the way up to
minutes, or maybe more.

00:02:40.490 --> 00:02:42.970
And fidelity.

00:02:42.970 --> 00:02:45.820
How close to
real-world scenarios

00:02:45.820 --> 00:02:49.200
does your test case simulate?

00:02:49.200 --> 00:02:52.750
An increasing scope typically
increases the fidelity

00:02:52.750 --> 00:02:54.230
of your tests.

00:02:54.230 --> 00:02:59.000
But it does so at the expense
of speed, and vise versa.

00:02:59.000 --> 00:03:01.780
And you can't actually have
a single test that gives you

00:03:01.780 --> 00:03:04.510
the best of everything.

00:03:04.510 --> 00:03:08.340
The question is
when is good enough?

00:03:08.340 --> 00:03:10.770
When do you really need perfect?

00:03:10.770 --> 00:03:12.800
And how do you achieve
the right balance?

00:03:15.920 --> 00:03:18.190
The testing pyramid
is used as a guide

00:03:18.190 --> 00:03:21.100
to help you create that balance.

00:03:21.100 --> 00:03:23.650
As you go up the pyramid,
you improve on fidelity

00:03:23.650 --> 00:03:26.920
by increasing the scope.

00:03:26.920 --> 00:03:31.360
But remember, this comes at
the price of speed, focus,

00:03:31.360 --> 00:03:34.730
and scalability.

00:03:34.730 --> 00:03:38.840
Unit tests-- they've got to
be fast, lightweight, highly

00:03:38.840 --> 00:03:43.970
focused, in order that they
can achieve high scalability.

00:03:43.970 --> 00:03:46.790
They're really easy to define,
because most of the time

00:03:46.790 --> 00:03:50.030
we're just testing a single
method in a single class

00:03:50.030 --> 00:03:51.975
within our application.

00:03:51.975 --> 00:03:53.350
And this means
that they're going

00:03:53.350 --> 00:03:57.140
to give you really
high degree of focus

00:03:57.140 --> 00:03:59.450
to the origin of a failure.

00:04:02.540 --> 00:04:05.810
Integration tests are the
next category of test.

00:04:05.810 --> 00:04:08.540
And here we're trying to
bring together several units

00:04:08.540 --> 00:04:09.890
within our application.

00:04:09.890 --> 00:04:12.830
And we're interested in
verifying their collaboration,

00:04:12.830 --> 00:04:15.590
making sure that when we bring
them together, that they all

00:04:15.590 --> 00:04:17.660
behave expected as a whole.

00:04:20.380 --> 00:04:23.290
And end-to-end tests, they
step through key paths

00:04:23.290 --> 00:04:26.630
in our application, after
uncovering multiple screens

00:04:26.630 --> 00:04:28.340
and features.

00:04:28.340 --> 00:04:31.210
And these are also real easy to
define, because at this stage,

00:04:31.210 --> 00:04:33.608
we know we're testing
our whole application.

00:04:36.480 --> 00:04:39.990
Today, we're launching
a new to-do application.

00:04:39.990 --> 00:04:42.930
Well, it's not really an
official Google product.

00:04:42.930 --> 00:04:45.480
But it is a real application.

00:04:45.480 --> 00:04:48.270
It's part of the refreshed
Android testing code lab

00:04:48.270 --> 00:04:50.250
that we're launching today.

00:04:50.250 --> 00:04:54.000
So you can go ahead,
check it out, build, test,

00:04:54.000 --> 00:04:56.160
work through all the examples
that you'll see right

00:04:56.160 --> 00:04:58.950
here in this session today.

00:04:58.950 --> 00:05:00.750
Now we're going to
work through building

00:05:00.750 --> 00:05:02.500
this application together.

00:05:02.500 --> 00:05:04.740
And in doing so,
along the way, we'll

00:05:04.740 --> 00:05:07.230
discuss some of the
challenges and the choices

00:05:07.230 --> 00:05:08.310
that will be faced.

00:05:11.520 --> 00:05:13.890
Building an application
usually starts

00:05:13.890 --> 00:05:18.660
by defining some key
critical user journeys.

00:05:18.660 --> 00:05:21.780
And a critical user journey
is a step-by-step path

00:05:21.780 --> 00:05:25.470
that the user takes
through an application.

00:05:25.470 --> 00:05:32.990
And the idea is in order to
meet a predefined end goal,

00:05:32.990 --> 00:05:35.840
the journey may span
multiple screens and decision

00:05:35.840 --> 00:05:38.750
points to get to that end goal.

00:05:38.750 --> 00:05:42.020
And they're often sketched
out by a series of mockups.

00:05:42.020 --> 00:05:44.650
And let's take a look at some
that our UX designers just

00:05:44.650 --> 00:05:46.860
sent us.

00:05:46.860 --> 00:05:51.120
Our first user journey is
that of creating a new task.

00:05:51.120 --> 00:05:54.720
Users arrive on the home screen,
which has a list of tasks.

00:05:54.720 --> 00:05:57.930
The first time they get
there, it's going to be empty.

00:05:57.930 --> 00:06:00.600
There's a floating action
button that they can click.

00:06:00.600 --> 00:06:02.760
It takes them to the next
screen, where they can

00:06:02.760 --> 00:06:05.160
enter details for their tasks.

00:06:05.160 --> 00:06:08.753
They can click Save, and they
return back to the home screen.

00:06:08.753 --> 00:06:10.170
And their new task
should show up.

00:06:13.680 --> 00:06:17.790
Our second user journey is
about checking our progress.

00:06:17.790 --> 00:06:20.880
So users can select
an existing task.

00:06:20.880 --> 00:06:23.157
They can mark it as completed.

00:06:23.157 --> 00:06:24.990
And then they can go
and view their progress

00:06:24.990 --> 00:06:27.150
on a statistics
screen that shows them

00:06:27.150 --> 00:06:28.600
just how productive they are.

00:06:32.170 --> 00:06:35.200
Now, every project
starts off small.

00:06:35.200 --> 00:06:38.920
But if careful attention isn't
paid to design, architecture,

00:06:38.920 --> 00:06:43.000
organization, during the
growth of that code base,

00:06:43.000 --> 00:06:45.820
development can quickly
spiral out of control

00:06:45.820 --> 00:06:49.450
as your application
grows uncontrollably.

00:06:49.450 --> 00:06:51.310
Without any thought,
your code base

00:06:51.310 --> 00:06:55.150
can quickly turn to a huge
monolith, a spaghetti-like ball

00:06:55.150 --> 00:06:57.820
of incoherent
dependencies that are not

00:06:57.820 --> 00:07:00.265
only hard to reason
about but they're

00:07:00.265 --> 00:07:03.220
difficult to test as well.

00:07:03.220 --> 00:07:07.060
If individual units don't follow
key principles such as that

00:07:07.060 --> 00:07:10.920
of high cohesion
and low coupling,

00:07:10.920 --> 00:07:14.880
they become really difficult
to test alone in isolation.

00:07:14.880 --> 00:07:17.350
And furthermore, with
a monolithic code base

00:07:17.350 --> 00:07:20.230
like this, anytime you
make a single change

00:07:20.230 --> 00:07:24.800
to your application, you
have to rebuild everything.

00:07:24.800 --> 00:07:28.870
And these factors force
the majority of tests

00:07:28.870 --> 00:07:33.040
to end up being large
end-to-end tests.

00:07:33.040 --> 00:07:35.980
How does this
affect our pyramid?

00:07:35.980 --> 00:07:38.230
Well, with such
resulting chaos, you

00:07:38.230 --> 00:07:40.720
can see that our pyramid
is now completely

00:07:40.720 --> 00:07:42.760
disproportional to how
we'd like it to look.

00:07:46.210 --> 00:07:48.940
If we do try to think about
organization from when we start

00:07:48.940 --> 00:07:51.430
out, our first thought
might be following

00:07:51.430 --> 00:07:53.470
a layered architecture.

00:07:53.470 --> 00:07:54.940
At this stage in
development, it's

00:07:54.940 --> 00:07:58.310
the only dimension
that is visible to us.

00:07:58.310 --> 00:07:59.980
And there are also
Android concepts

00:07:59.980 --> 00:08:01.880
that map neatly to each layer.

00:08:01.880 --> 00:08:05.330
So maybe this makes sense.

00:08:05.330 --> 00:08:07.580
And by structuring
our code this way,

00:08:07.580 --> 00:08:10.490
we can slash dependencies,
follow those principles

00:08:10.490 --> 00:08:14.090
of high cohesion, low
coupling, maybe introduce

00:08:14.090 --> 00:08:16.580
dependency injection,
and now we can see

00:08:16.580 --> 00:08:20.130
that unit tests are possible.

00:08:20.130 --> 00:08:23.820
But as our application
grows in complexity,

00:08:23.820 --> 00:08:27.420
we start to notice that it grows
by the dimension of features

00:08:27.420 --> 00:08:30.030
rather than
architectural layers.

00:08:30.030 --> 00:08:34.320
So even if we did modulize
our code this way,

00:08:34.320 --> 00:08:36.460
a small change high
up in the tech stack

00:08:36.460 --> 00:08:39.309
is only going to save a
couple of layers of modules

00:08:39.309 --> 00:08:43.450
of rebuild, whereas something
lower down still causes

00:08:43.450 --> 00:08:47.050
a complete rebuild of
the old application.

00:08:47.050 --> 00:08:50.620
Furthermore, the layers
themselves become monolithic.

00:08:50.620 --> 00:08:54.190
And so we still end up writing
so many large end-to-end tests.

00:08:57.580 --> 00:09:00.160
Now, while the ability to
start writing unit tests

00:09:00.160 --> 00:09:03.130
is really good,
projects are still

00:09:03.130 --> 00:09:07.030
left with a pyramid that
doesn't quite look right.

00:09:07.030 --> 00:09:08.750
And the problem
with this setup is

00:09:08.750 --> 00:09:11.840
that in order to compensate
for our fidelity gap and unit

00:09:11.840 --> 00:09:16.070
tests, we're
overcompensating dramatically

00:09:16.070 --> 00:09:20.820
in end-to-end end tests, which
are slow and heavyweight.

00:09:20.820 --> 00:09:23.670
There's nothing here that's
guiding us so far in order

00:09:23.670 --> 00:09:25.050
to make a balanced pyramid.

00:09:28.890 --> 00:09:31.470
So poorly organized and
architected code base

00:09:31.470 --> 00:09:33.990
can quickly lead to severe
bottlenecks in your development

00:09:33.990 --> 00:09:36.000
workflow.

00:09:36.000 --> 00:09:38.990
By overrelying on these
large end-to-end tests,

00:09:38.990 --> 00:09:42.530
were faced with test suites
that take far too long to run.

00:09:42.530 --> 00:09:45.090
And the lack of focus in
them mean the bugs are really

00:09:45.090 --> 00:09:47.720
hard to track down.

00:09:47.720 --> 00:09:49.880
Without effective
marginalization,

00:09:49.880 --> 00:09:53.000
every change we make to the
app causes large swaths of it

00:09:53.000 --> 00:09:57.580
to be rebuilt, and all
the tests must be rerun.

00:09:57.580 --> 00:10:02.320
These key points can cripple
your team's velocity.

00:10:02.320 --> 00:10:04.150
But organizing
your code correctly

00:10:04.150 --> 00:10:08.570
has a big impact on testability
and development velocity.

00:10:08.570 --> 00:10:10.890
So we want to get it
right from the get-go.

00:10:10.890 --> 00:10:12.390
We want to create
a way that's going

00:10:12.390 --> 00:10:14.460
to be scalable as
we move forward

00:10:14.460 --> 00:10:16.350
and our application
grows over time.

00:10:19.060 --> 00:10:21.555
So let's think about how we
may decompose our project.

00:10:24.090 --> 00:10:27.248
At the top we've
got our application.

00:10:27.248 --> 00:10:29.040
And one of the key
areas of functionalities

00:10:29.040 --> 00:10:30.105
is managing tasks.

00:10:32.660 --> 00:10:37.880
We also have a progress module
that has a dependency on tasks.

00:10:37.880 --> 00:10:40.350
And as we dive in,
we notice that task

00:10:40.350 --> 00:10:41.910
is a really big feature.

00:10:41.910 --> 00:10:47.290
We can further decompose it
with add, edit, list, view.

00:10:47.290 --> 00:10:50.160
And organizing our code this
way allows our development

00:10:50.160 --> 00:10:51.975
to scale as our
application grows

00:10:51.975 --> 00:10:55.210
and new features are added.

00:10:55.210 --> 00:10:59.370
And we're also able to scale
in depth of complexity, too.

00:10:59.370 --> 00:11:01.620
As features become
more complex, we

00:11:01.620 --> 00:11:05.880
can continue breaking them
down, adding more modules.

00:11:05.880 --> 00:11:07.600
And this approach
to organization

00:11:07.600 --> 00:11:10.930
makes sense, since two
components in the same domain

00:11:10.930 --> 00:11:13.660
are much more related in
function than two components

00:11:13.660 --> 00:11:17.230
that might just happen
to be an activity.

00:11:17.230 --> 00:11:18.980
We can implement this
kind of organization

00:11:18.980 --> 00:11:22.250
both through language
features such as packaging

00:11:22.250 --> 00:11:25.340
but also through our build
system, like Gradle modules

00:11:25.340 --> 00:11:27.108
or [? basl ?] libraries.

00:11:30.320 --> 00:11:33.460
We can add domain-orientated
modules now to the application

00:11:33.460 --> 00:11:36.710
and define clear API
boundaries to contractualize

00:11:36.710 --> 00:11:38.700
their interactions.

00:11:38.700 --> 00:11:41.420
So now we have a way to
shard our application, which

00:11:41.420 --> 00:11:44.450
makes it possible to isolate
the components for more

00:11:44.450 --> 00:11:46.520
focused testing.

00:11:46.520 --> 00:11:50.650
Finally, we can see blueprints
for integration tests.

00:11:50.650 --> 00:11:52.240
And of course, all
these modules are

00:11:52.240 --> 00:11:56.210
going to be decomposed
and be unit testable.

00:11:56.210 --> 00:12:01.080
And we can still write
our large end-to-end test.

00:12:01.080 --> 00:12:03.030
Furthermore, this
organization allows

00:12:03.030 --> 00:12:07.390
us to scale as we add new
features that test scale along

00:12:07.390 --> 00:12:07.890
with them.

00:12:10.510 --> 00:12:12.898
You can use this guide
as a starting point.

00:12:12.898 --> 00:12:15.440
And of course, you can decompose
further or in different ways

00:12:15.440 --> 00:12:18.440
that make sense for
your application.

00:12:18.440 --> 00:12:20.540
The key thing here,
though, is to remember

00:12:20.540 --> 00:12:23.090
to provide natural
guides and templates

00:12:23.090 --> 00:12:25.897
for different categories of
tests for your application.

00:12:29.380 --> 00:12:31.210
To build our to-do
application, we're

00:12:31.210 --> 00:12:33.377
going to be using some of
the architecture component

00:12:33.377 --> 00:12:37.630
libraries from Jetpack
such as data binding, view

00:12:37.630 --> 00:12:42.760
model, live data,
navigation, and room.

00:12:45.800 --> 00:12:49.320
We're going to follow the model
view model pattern and MVVM

00:12:49.320 --> 00:12:52.410
to architecture application.

00:12:52.410 --> 00:12:55.350
This provides a really clear
separation of concerns.

00:12:55.350 --> 00:12:58.320
And Jetpack's architecture
component libraries really

00:12:58.320 --> 00:13:01.410
fit in well neatly with this.

00:13:01.410 --> 00:13:03.420
I'm going to start with
a single activity that

00:13:03.420 --> 00:13:07.340
uses the navigation component
to map the user's flows

00:13:07.340 --> 00:13:09.600
through a series of fragments.

00:13:09.600 --> 00:13:13.110
Each one managing
its own screen.

00:13:13.110 --> 00:13:15.900
Each fragment has
its own XML layout

00:13:15.900 --> 00:13:19.890
that's mapped directly
to its own view model,

00:13:19.890 --> 00:13:23.500
using data binding
architecture component.

00:13:23.500 --> 00:13:25.740
It will also use live
data to reflect changes

00:13:25.740 --> 00:13:27.420
back up into the view.

00:13:30.670 --> 00:13:32.830
And our model layer is
going to be abstracted

00:13:32.830 --> 00:13:36.790
under a repository that contains
both a remote data source

00:13:36.790 --> 00:13:40.420
and a local data source
that's backed by SQLite

00:13:40.420 --> 00:13:43.085
and using room
architecture component.

00:13:45.940 --> 00:13:49.860
On Android, the user interface
is updated on the UI thread.

00:13:49.860 --> 00:13:51.400
And so long as
the events that we

00:13:51.400 --> 00:13:54.070
post there are nice
and short tasks,

00:13:54.070 --> 00:13:57.400
our UI stays snappy
and responsive.

00:13:57.400 --> 00:13:59.540
In our application,
however, everything

00:13:59.540 --> 00:14:01.975
is not going to
fit that criteria.

00:14:01.975 --> 00:14:06.640
We use both a local database and
we make crests to a remote REST

00:14:06.640 --> 00:14:09.940
API for dealing with task data.

00:14:09.940 --> 00:14:15.780
Operations to both of these
components take a long time.

00:14:15.780 --> 00:14:18.560
And if we were to run
these on the UI thread,

00:14:18.560 --> 00:14:20.570
we'd quickly see that
our application becomes

00:14:20.570 --> 00:14:25.180
slow or even unresponsive.

00:14:25.180 --> 00:14:26.910
So of course, we
need to make sure

00:14:26.910 --> 00:14:30.120
that these long-running
operations occur asynchronously

00:14:30.120 --> 00:14:33.000
in the background somehow so
that we're not blocking our UI

00:14:33.000 --> 00:14:36.030
thread from responding while
we're waiting for these tasks

00:14:36.030 --> 00:14:38.775
to complete.

00:14:38.775 --> 00:14:40.400
In our application,
we're going to make

00:14:40.400 --> 00:14:44.360
use of Kotlin's coroutines
for asynchronous operations.

00:14:44.360 --> 00:14:48.430
You can think of coroutines
as lightweight threads.

00:14:48.430 --> 00:14:50.930
And although they've been stable
for only a relatively short

00:14:50.930 --> 00:14:55.250
amount of time, the community
has adopted them very quickly.

00:14:55.250 --> 00:14:58.242
And they've become a clear
trend in Android development.

00:15:01.080 --> 00:15:05.340
A coroutine scope keeps track of
all the coroutines it creates.

00:15:05.340 --> 00:15:07.420
And if you cancel
a scope, it thereby

00:15:07.420 --> 00:15:09.130
cancels all of the
coroutines that

00:15:09.130 --> 00:15:12.130
were created in that scope.

00:15:12.130 --> 00:15:14.440
In our application,
coroutines are

00:15:14.440 --> 00:15:16.750
launched from the
view model objects,

00:15:16.750 --> 00:15:20.850
using a special
view model scope.

00:15:20.850 --> 00:15:24.420
This is particularly useful when
our view model gets destroyed,

00:15:24.420 --> 00:15:27.660
because it automatically cancels
all of those existing child

00:15:27.660 --> 00:15:29.190
coroutines.

00:15:29.190 --> 00:15:32.160
It's going to save resources and
avoids potential memory leaks

00:15:32.160 --> 00:15:33.930
along the way.

00:15:33.930 --> 00:15:36.420
And from within a scope, we
can call down to our tasks

00:15:36.420 --> 00:15:37.543
repository.

00:15:41.250 --> 00:15:43.200
The coroutine scope
created in our task

00:15:43.200 --> 00:15:48.210
repository is concerned for
parallel decomposition of work.

00:15:48.210 --> 00:15:50.920
When any child coroutine
in this scope fails,

00:15:50.920 --> 00:15:53.990
the entire scope fails and all
of the remaining coroutines

00:15:53.990 --> 00:15:55.920
are canceled.

00:15:55.920 --> 00:15:58.170
This function returns
as soon as its given

00:15:58.170 --> 00:16:02.940
block and all of the child
coroutines are both complete.

00:16:02.940 --> 00:16:06.570
Coroutines can certainly make
developing asynchronous code

00:16:06.570 --> 00:16:07.230
a lot simpler.

00:16:10.050 --> 00:16:12.470
So let's start by implementing
our first critical user

00:16:12.470 --> 00:16:14.460
journey.

00:16:14.460 --> 00:16:18.373
Just to recap, we start
on the home screen.

00:16:18.373 --> 00:16:20.040
We click a floating
action button, which

00:16:20.040 --> 00:16:23.190
takes us to the detail screen.

00:16:23.190 --> 00:16:27.390
Here we enter text for
our new task, save,

00:16:27.390 --> 00:16:29.340
and we're back to the
home screen, where we

00:16:29.340 --> 00:16:31.190
can see our newly created note.

00:16:34.700 --> 00:16:36.290
We're going to develop
our application

00:16:36.290 --> 00:16:38.550
using test-driven development.

00:16:38.550 --> 00:16:41.090
And this is a school of
thought where we first

00:16:41.090 --> 00:16:44.450
codify the specification of
our application in tests,

00:16:44.450 --> 00:16:47.570
first of all, and only then
do we write the production

00:16:47.570 --> 00:16:52.350
code in order to satisfy
that specification.

00:16:52.350 --> 00:16:54.520
We're also going to
do all this top down,

00:16:54.520 --> 00:16:56.910
starting from the
end-to-end test,

00:16:56.910 --> 00:16:59.910
and then breaking this down,
and decomposing further

00:16:59.910 --> 00:17:03.450
and further, until we finally
reach the individual units that

00:17:03.450 --> 00:17:06.329
are required to satisfy
the feature we're building.

00:17:09.000 --> 00:17:12.450
So let's start by writing
an end-to-end test.

00:17:12.450 --> 00:17:15.480
It's going to be failing first,
but we know that by the time

00:17:15.480 --> 00:17:18.430
we make it pass, our
feature's complete.

00:17:18.430 --> 00:17:22.140
It's a good signal
for the end state.

00:17:22.140 --> 00:17:25.410
Let's review some key
qualities of end-to-end tests.

00:17:25.410 --> 00:17:27.119
The main thing we're
looking for here

00:17:27.119 --> 00:17:30.690
is that we've got confidence
in the final application when

00:17:30.690 --> 00:17:32.460
it's finished.

00:17:32.460 --> 00:17:35.310
Therefore, these
kinds of tests should

00:17:35.310 --> 00:17:38.708
run on a real or
a virtual device

00:17:38.708 --> 00:17:42.390
and make sure that our code
interacts with the Android

00:17:42.390 --> 00:17:46.000
environment as expected.

00:17:46.000 --> 00:17:48.400
Our application should
also look as close

00:17:48.400 --> 00:17:50.230
to the final
application as possible

00:17:50.230 --> 00:17:52.480
that will go into ship.

00:17:52.480 --> 00:17:55.600
And we should test it
in the very same way

00:17:55.600 --> 00:17:57.880
that our users are going
to interact with it.

00:17:57.880 --> 00:18:00.940
This means we're doing
blackbox testing.

00:18:00.940 --> 00:18:04.600
And here, we don't need to be
exhaustive with all the tests.

00:18:04.600 --> 00:18:06.520
That's the job of
testing other layers.

00:18:09.430 --> 00:18:12.480
Now, let's examine
the scope of the code

00:18:12.480 --> 00:18:15.510
and see what we're going
to exercise in our test.

00:18:15.510 --> 00:18:19.530
It looks like for
our first test case,

00:18:19.530 --> 00:18:23.280
the AddEditTasksFragment screen
and the TasksFragment screen

00:18:23.280 --> 00:18:24.750
are what's important.

00:18:24.750 --> 00:18:27.240
So for this particular
end-to-end test,

00:18:27.240 --> 00:18:28.893
we're just going to
discard and ignore

00:18:28.893 --> 00:18:30.060
task details for the moment.

00:18:33.820 --> 00:18:36.880
We can start on the home screen
by using activity scenario

00:18:36.880 --> 00:18:38.680
to launch the task
activity class.

00:18:41.083 --> 00:18:42.750
Then we can click on
the floating action

00:18:42.750 --> 00:18:45.080
button, which should take
us to the next screen.

00:18:49.490 --> 00:18:52.510
And here we can use
Espresso to enter text

00:18:52.510 --> 00:18:55.423
into the detail screen.

00:18:55.423 --> 00:18:57.090
And one more time
with Espresso to click

00:18:57.090 --> 00:19:02.450
the button, which would send
us back to the first screen.

00:19:02.450 --> 00:19:05.340
And here, make a
simple assertion

00:19:05.340 --> 00:19:08.730
to check that the newly added
task appears on the home

00:19:08.730 --> 00:19:11.490
screen.

00:19:11.490 --> 00:19:14.480
Now we're not using
any special APIs

00:19:14.480 --> 00:19:17.930
or any hooks or back doors.

00:19:17.930 --> 00:19:20.780
This is known as
black box testing.

00:19:20.780 --> 00:19:23.450
And interacting with
the application this way

00:19:23.450 --> 00:19:25.640
gives us the confidence
that it'll still

00:19:25.640 --> 00:19:29.000
work if a real user were to
step through the flow in exactly

00:19:29.000 --> 00:19:29.630
the same way.

00:19:33.330 --> 00:19:36.230
So now we need to add some
integration tests in order

00:19:36.230 --> 00:19:38.900
to bridge the gap between
those large end-to-end tests

00:19:38.900 --> 00:19:41.370
that we've just written
and the smaller,

00:19:41.370 --> 00:19:46.403
faster, exhaustive unit tests
that we'll be adding later.

00:19:46.403 --> 00:19:48.820
Here we're looking for something
that gives us a good clue

00:19:48.820 --> 00:19:52.820
that all of the individual units
that we're bringing together

00:19:52.820 --> 00:19:54.460
collaborate as planned.

00:19:54.460 --> 00:19:57.430
That's where the
focus should be here.

00:19:57.430 --> 00:19:59.950
These tests will be
relatively scalable.

00:19:59.950 --> 00:20:02.320
And providing enough
coverage at this level

00:20:02.320 --> 00:20:04.030
means we need to
lean less and less

00:20:04.030 --> 00:20:08.600
on those large, heavyweight
end-to-end tests.

00:20:08.600 --> 00:20:10.700
Here it's kind of less
important that we're

00:20:10.700 --> 00:20:13.070
using all real components.

00:20:13.070 --> 00:20:19.560
And it's OK to make judicious
use of testing APIs.

00:20:19.560 --> 00:20:21.440
But what exactly kind
of tests should we

00:20:21.440 --> 00:20:22.520
be writing at this level?

00:20:25.680 --> 00:20:28.140
When we introduced scope
earlier in the session,

00:20:28.140 --> 00:20:29.850
we defined it as the
amount of real code

00:20:29.850 --> 00:20:32.433
that's exercised by the test.

00:20:32.433 --> 00:20:34.350
And in the end-to-end
test we've already seen,

00:20:34.350 --> 00:20:36.660
that scope's pretty large.

00:20:36.660 --> 00:20:39.810
With integration tests,
it's a little more nuanced.

00:20:39.810 --> 00:20:43.140
Luckily, our architecture
and code organization

00:20:43.140 --> 00:20:46.570
leads us straight to
some good candidates.

00:20:46.570 --> 00:20:49.980
Let's approach this
by decomposition.

00:20:49.980 --> 00:20:52.230
If the previous
end-to-end tests just

00:20:52.230 --> 00:20:55.490
focused on the
AddEditTasksFragment screen

00:20:55.490 --> 00:20:58.320
and the TasksFragment
screen, we already

00:20:58.320 --> 00:21:00.690
know that this next
integration test

00:21:00.690 --> 00:21:03.990
has got to be a smaller
scope than that.

00:21:03.990 --> 00:21:06.600
And looking at our
architecture diagram,

00:21:06.600 --> 00:21:11.470
I can already see
the first candidate.

00:21:11.470 --> 00:21:13.840
Let's start by writing
an integration test

00:21:13.840 --> 00:21:18.800
for the entire tech stack that
supports the AddNewTest screen.

00:21:18.800 --> 00:21:23.090
So we remove the TaskList
screen from the equation.

00:21:23.090 --> 00:21:24.952
Do you see any other
candidates here

00:21:24.952 --> 00:21:26.660
where we might want
to limit their scope?

00:21:30.675 --> 00:21:32.550
Some of the objects in
the scope of your test

00:21:32.550 --> 00:21:35.730
might have some undesirable
characteristics.

00:21:35.730 --> 00:21:38.250
Perhaps one of them is too slow.

00:21:38.250 --> 00:21:42.000
Maybe it reads a
large file at startup.

00:21:42.000 --> 00:21:44.310
Perhaps another is a really
heavyweight dependency that

00:21:44.310 --> 00:21:47.460
takes a long time to build.

00:21:47.460 --> 00:21:50.400
Perhaps it makes an arbitrary
network connections,

00:21:50.400 --> 00:21:54.190
causing a test to be flaky.

00:21:54.190 --> 00:21:57.310
And some dependencies, they just
can't be controlled in the way

00:21:57.310 --> 00:22:01.670
that we need to simulate
within our tests.

00:22:01.670 --> 00:22:04.250
In such cases, you
may want to consider

00:22:04.250 --> 00:22:08.260
replacing that original
dependency with a test double.

00:22:08.260 --> 00:22:12.100
Test doubles are stand-ins
for the real object.

00:22:12.100 --> 00:22:16.060
There are several
categories of test doubles.

00:22:16.060 --> 00:22:19.060
Each of them range in fidelity.

00:22:19.060 --> 00:22:20.680
Dummies.

00:22:20.680 --> 00:22:24.790
These are just intended for
stand-in for the real behavior

00:22:24.790 --> 00:22:27.520
just to satisfy dependencies.

00:22:27.520 --> 00:22:31.720
Then stubs, which aim to offer
one-off specific behavior.

00:22:31.720 --> 00:22:35.590
It'll allow you to configure
it for the needs of your test.

00:22:35.590 --> 00:22:37.450
Either of these
could be hand-rolled

00:22:37.450 --> 00:22:39.190
or they could be
provided by your mocking

00:22:39.190 --> 00:22:40.232
library, such as Mockito.

00:22:43.310 --> 00:22:45.270
Or consider fakes,
which aim to be

00:22:45.270 --> 00:22:50.110
a more accurate, yet lightweight
substitute for the real thing.

00:22:50.110 --> 00:22:54.480
And you may be surprised to
still see real objects up here.

00:22:54.480 --> 00:22:56.070
Sometimes, though,
it makes sense

00:22:56.070 --> 00:22:58.620
to use real objects
in your tests

00:22:58.620 --> 00:23:00.420
if it avoids any
of those criteria

00:23:00.420 --> 00:23:03.030
that we considered
before, and where

00:23:03.030 --> 00:23:05.430
it makes the test more
readable and robust

00:23:05.430 --> 00:23:07.620
over the alternative.

00:23:07.620 --> 00:23:09.600
Value objects are
just one example

00:23:09.600 --> 00:23:12.225
of why you should always
prefer using a real object.

00:23:16.330 --> 00:23:18.650
Taking a closer
look, there are now

00:23:18.650 --> 00:23:20.770
some candidates where
we might want to start

00:23:20.770 --> 00:23:23.980
increasing removing the scope.

00:23:23.980 --> 00:23:26.900
We could drive our test
through TasksActivity.

00:23:26.900 --> 00:23:30.040
But this is concerned with the
navigation between screens.

00:23:30.040 --> 00:23:32.570
And we don't need to
test this at this level.

00:23:32.570 --> 00:23:35.020
That's more of an
end-to-end test.

00:23:35.020 --> 00:23:38.770
So instead, we're going to
reach for FragmentScenario

00:23:38.770 --> 00:23:42.610
and use Espresso to
test the UI directly.

00:23:42.610 --> 00:23:45.400
We're going to need switch in a
test double for our navigation

00:23:45.400 --> 00:23:46.390
controller, however.

00:23:48.910 --> 00:23:51.790
And we can use this to
verify that our navigation is

00:23:51.790 --> 00:23:54.950
working as expected.

00:23:54.950 --> 00:23:59.200
TaskRepository, it presents
a clear and well-defined API

00:23:59.200 --> 00:24:00.900
to all the layers above.

00:24:00.900 --> 00:24:04.850
So it's good practice to make
use of this API from tests

00:24:04.850 --> 00:24:07.950
and to use that to check
to see if our test had

00:24:07.950 --> 00:24:10.960
saved the task correctly.

00:24:10.960 --> 00:24:13.600
But look, including
a remote data source,

00:24:13.600 --> 00:24:15.640
which connects to
an external server,

00:24:15.640 --> 00:24:18.400
that's going to make
our test slow and flaky.

00:24:18.400 --> 00:24:20.830
So let's switch that out
also for a test double.

00:24:25.460 --> 00:24:28.160
So first, we're using
FragmentScenario

00:24:28.160 --> 00:24:29.150
to launch our fragment.

00:24:31.940 --> 00:24:34.710
And we need to verify that our
floating action button sends us

00:24:34.710 --> 00:24:36.630
to the right screen.

00:24:36.630 --> 00:24:40.852
And the navigation controller
handles this kind of thing.

00:24:40.852 --> 00:24:42.810
We don't actually need
to go to that new screen

00:24:42.810 --> 00:24:44.730
for this kind of test.

00:24:44.730 --> 00:24:47.730
We just need to record
that we went there.

00:24:47.730 --> 00:24:50.070
So we can swap out the
navigation controller

00:24:50.070 --> 00:24:52.200
for a test double.

00:24:52.200 --> 00:24:54.730
There isn't actually a
fake version provided.

00:24:54.730 --> 00:24:57.780
So in this case, I think it's
perfectly acceptable just

00:24:57.780 --> 00:24:59.160
to shim in a mock like this.

00:25:03.670 --> 00:25:06.010
And now we can use Espresso
APIs to enter some text

00:25:06.010 --> 00:25:10.060
in the fields as we did before,
clicking the floating action

00:25:10.060 --> 00:25:11.410
button to save the task.

00:25:14.442 --> 00:25:15.900
And for the final
part of the test,

00:25:15.900 --> 00:25:18.150
we need to check two things.

00:25:18.150 --> 00:25:21.960
First, was the task
saved correctly?

00:25:21.960 --> 00:25:25.170
So we can do this by obtaining
the task service or the task

00:25:25.170 --> 00:25:27.940
repository from the
service locator.

00:25:27.940 --> 00:25:30.360
And we can use its
APIs to get a list

00:25:30.360 --> 00:25:33.730
of the tasks that were saved.

00:25:33.730 --> 00:25:37.000
And then we can make
sure it contains

00:25:37.000 --> 00:25:39.460
one that was saved
that matches the one we

00:25:39.460 --> 00:25:40.780
tried to save through the UI.

00:25:44.260 --> 00:25:49.240
The next assertion is did we get
back to the right screen, OK?

00:25:49.240 --> 00:25:51.610
We can check with our
mock navigation controller

00:25:51.610 --> 00:25:53.200
to make sure that
the right navigation

00:25:53.200 --> 00:25:55.450
event was sent that
would have directed us

00:25:55.450 --> 00:25:56.350
to the right screen.

00:26:01.360 --> 00:26:03.930
And we can decompose further
and look for other ways

00:26:03.930 --> 00:26:07.140
that we might want
to limit scope

00:26:07.140 --> 00:26:11.350
in order to create smaller
and smaller integration tests.

00:26:11.350 --> 00:26:14.100
Let's take TaskRepository,
for example.

00:26:14.100 --> 00:26:15.970
It represents our model.

00:26:15.970 --> 00:26:19.200
It's got a well-defined API
that supports all the task UI

00:26:19.200 --> 00:26:22.860
features, as well as features in
other modules like the progress

00:26:22.860 --> 00:26:24.420
module.

00:26:24.420 --> 00:26:28.050
And it's also likely to contain
large amounts of complexity

00:26:28.050 --> 00:26:29.650
and business value.

00:26:29.650 --> 00:26:32.160
And it includes a good
deal of collaborators.

00:26:32.160 --> 00:26:34.380
And this makes it a great
candidate for covering

00:26:34.380 --> 00:26:36.690
with an integration test.

00:26:36.690 --> 00:26:41.640
So let's remove all of the UI
from the scope of this test.

00:26:41.640 --> 00:26:45.120
Now we can proceed to directly
test this well-defined API

00:26:45.120 --> 00:26:47.290
of our test repository.

00:26:47.290 --> 00:26:48.780
And here we'll make
similar choices

00:26:48.780 --> 00:26:52.050
when it comes to fidelity
to our metric principles

00:26:52.050 --> 00:26:56.850
and speed trade-offs, just
like we did in the last test.

00:26:56.850 --> 00:27:00.660
We'll keep using a fake to stand
in for the real data source,

00:27:00.660 --> 00:27:02.910
as well as providing us
with repeatable tests.

00:27:02.910 --> 00:27:05.100
A fake here allows
us to configure

00:27:05.100 --> 00:27:07.620
all kinds of test data
sets that we might

00:27:07.620 --> 00:27:09.750
want to wire up for
certain conditions,

00:27:09.750 --> 00:27:12.520
testing in different ways.

00:27:12.520 --> 00:27:14.920
Having a well-defined API
at the model layer also

00:27:14.920 --> 00:27:19.440
allows us to do something
else that's really cool.

00:27:19.440 --> 00:27:21.560
What if we take
our TaskRepository

00:27:21.560 --> 00:27:25.320
and extract away an interface?

00:27:25.320 --> 00:27:28.270
Now we can create
a fake version.

00:27:28.270 --> 00:27:30.740
And by running the same
test against the fake

00:27:30.740 --> 00:27:34.630
that we run against our
production repository,

00:27:34.630 --> 00:27:37.100
our fake becomes
a verified fake.

00:27:37.100 --> 00:27:38.600
And what we're doing
is guaranteeing

00:27:38.600 --> 00:27:42.320
its behavior meets
the same specification

00:27:42.320 --> 00:27:45.440
as our real production code.

00:27:45.440 --> 00:27:47.270
And if we create
separate modules

00:27:47.270 --> 00:27:51.500
for both our APIs and
our fakes, other modules

00:27:51.500 --> 00:27:53.360
that we interact
with will see faster

00:27:53.360 --> 00:27:57.190
build times and more
lightweight tests.

00:27:57.190 --> 00:27:58.940
So here we have a fake
for our model layer

00:27:58.940 --> 00:28:00.860
that we're confident
in, and we can

00:28:00.860 --> 00:28:04.400
start to use it in other tests.

00:28:04.400 --> 00:28:05.900
Coming back to the
first integration

00:28:05.900 --> 00:28:09.560
test we wrote for the
AddEditTask screen,

00:28:09.560 --> 00:28:11.690
we could have equally
written this integration test

00:28:11.690 --> 00:28:14.150
with a fake task repository.

00:28:14.150 --> 00:28:17.320
We trust our fake because
it's a verified fake.

00:28:17.320 --> 00:28:19.140
And it's really fast, too.

00:28:19.140 --> 00:28:23.090
It probably stores its data
in an in-memory hash map.

00:28:23.090 --> 00:28:24.920
We can apply that
same testing blueprint

00:28:24.920 --> 00:28:29.330
across all of the other
modules in the tasks UI.

00:28:29.330 --> 00:28:31.820
These UI modules
are another group

00:28:31.820 --> 00:28:35.805
of components whose integration
we're really concerned with.

00:28:35.805 --> 00:28:38.180
We want to be sure that view
models collaborate correctly

00:28:38.180 --> 00:28:41.150
with our fragments, is
our data binding wired up,

00:28:41.150 --> 00:28:43.700
are all the possible input
validation cases handled

00:28:43.700 --> 00:28:46.750
correctly?

00:28:46.750 --> 00:28:50.980
And unit tests, these
verify the operations

00:28:50.980 --> 00:28:53.170
are very small units of code.

00:28:53.170 --> 00:28:56.900
The scope of these kinds of
tests is as small as possible.

00:28:56.900 --> 00:29:00.030
So the code can be
tested exhaustively

00:29:00.030 --> 00:29:05.327
and give very fast and very
specific feedback on failures.

00:29:05.327 --> 00:29:07.660
Our large projects are going
to have thousands of these,

00:29:07.660 --> 00:29:10.720
so they should run
in milliseconds.

00:29:10.720 --> 00:29:14.440
It's totally OK to swap out
production dependencies.

00:29:14.440 --> 00:29:16.820
But they should still
be black box in nature.

00:29:16.820 --> 00:29:22.050
We want to be testing
behavior, not implementation.

00:29:22.050 --> 00:29:23.970
And the line between
the categories of tests

00:29:23.970 --> 00:29:26.770
here can get a little blurry.

00:29:26.770 --> 00:29:31.230
Let's consider writing a task
for our tasks local data store.

00:29:31.230 --> 00:29:34.780
TaskLocalDataStore takes
a TaskDao as a dependency.

00:29:34.780 --> 00:29:38.320
And in a real system, this
is provided by the to-do

00:29:38.320 --> 00:29:39.200
database--

00:29:39.200 --> 00:29:44.290
a class generated by room, which
is backed by Android SQLite.

00:29:44.290 --> 00:29:47.320
And if we follow the classic
principles of unit testing,

00:29:47.320 --> 00:29:50.740
we can ask Mockito to provide us
a mock for our TaskDao instead.

00:29:54.250 --> 00:29:56.350
Here in our test, we
can create that mock

00:29:56.350 --> 00:29:58.690
and then pass it
in as a dependency

00:29:58.690 --> 00:30:02.160
to our TaskLocalDataStore.

00:30:02.160 --> 00:30:07.305
We can create a new task, and
then save it in the repository.

00:30:07.305 --> 00:30:11.610
And then finally, we can
validate the insert task call

00:30:11.610 --> 00:30:15.190
was invoked on our TaskDao.

00:30:15.190 --> 00:30:18.365
But wait-- this test
here already knows

00:30:18.365 --> 00:30:19.740
too much about
the implementation

00:30:19.740 --> 00:30:23.580
details of save task,
how it's implemented.

00:30:23.580 --> 00:30:26.065
If we were ever going to
change that implementation,

00:30:26.065 --> 00:30:27.690
then the test is
going to need updating

00:30:27.690 --> 00:30:30.120
as well, even if
the behavior was

00:30:30.120 --> 00:30:32.980
supposed to remain the same.

00:30:32.980 --> 00:30:35.560
This is what is known as
a change detector test.

00:30:35.560 --> 00:30:39.390
And its burdensome maintenance
can start to quickly outgrow

00:30:39.390 --> 00:30:41.580
its usefulness.

00:30:41.580 --> 00:30:43.140
Effective unit
tests should really

00:30:43.140 --> 00:30:46.717
focus on testing
behavior instead.

00:30:46.717 --> 00:30:47.800
But how should we do that?

00:30:50.660 --> 00:30:53.600
We can do that by ignoring
the internal implementation

00:30:53.600 --> 00:30:56.780
and focusing on the
API contracts instead.

00:30:56.780 --> 00:30:59.410
Take TaskDataSource.

00:30:59.410 --> 00:31:01.910
The contract states
that when I save a task

00:31:01.910 --> 00:31:05.200
through the save task
method, I should still then

00:31:05.200 --> 00:31:08.440
be able to retrieve that same
task by looking it up by ID.

00:31:11.330 --> 00:31:14.330
So our test should
exercise that contract

00:31:14.330 --> 00:31:18.680
rather than concerning itself
with implementation details.

00:31:18.680 --> 00:31:21.460
So we'll exercise
the save task method

00:31:21.460 --> 00:31:23.190
on our LocalTaskDataStore.

00:31:23.190 --> 00:31:25.060
But we won't be
concerned with the fact

00:31:25.060 --> 00:31:28.330
that it calls insert
task on the Dao.

00:31:28.330 --> 00:31:31.060
Then, we'll call get
task on the data store

00:31:31.060 --> 00:31:35.660
again, again forgetting
about the implementation.

00:31:35.660 --> 00:31:39.280
And one thing to bear in mind
when writing tasks like this,

00:31:39.280 --> 00:31:42.100
where the code on the task
makes use of coroutines,

00:31:42.100 --> 00:31:44.620
is that we need to make
these asynchronous operations

00:31:44.620 --> 00:31:47.020
appear synchronous
so that our tasks are

00:31:47.020 --> 00:31:50.360
going to remain deterministic.

00:31:50.360 --> 00:31:51.280
If we were to get--

00:31:51.280 --> 00:31:54.340
if we were to call a get
task function and execute it,

00:31:54.340 --> 00:31:56.560
and sometimes the
save task function

00:31:56.560 --> 00:32:01.480
hadn't completed in time,
we'd end up with a flaky test.

00:32:01.480 --> 00:32:05.350
Luckily, doing so is rather
straightforward by asking

00:32:05.350 --> 00:32:06.820
our test to run blocking.

00:32:10.190 --> 00:32:11.660
One of the first
tools you'll learn

00:32:11.660 --> 00:32:14.420
to write tests that
uses coroutines

00:32:14.420 --> 00:32:17.390
is the run blocking construct.

00:32:17.390 --> 00:32:21.050
In the context of run blocking,
the given suspend function

00:32:21.050 --> 00:32:23.780
and all of the calls, children
in the call hierarchy,

00:32:23.780 --> 00:32:26.030
are effectively going
to block the main thread

00:32:26.030 --> 00:32:27.875
until it finishes executing.

00:32:27.875 --> 00:32:30.410
And you're going to find this
a really useful tool when

00:32:30.410 --> 00:32:33.980
exercising code whose
behavior relies on

00:32:33.980 --> 00:32:36.680
coroutines and needs to
be highly deterministic.

00:32:40.090 --> 00:32:42.150
So the test we actually
want to look at

00:32:42.150 --> 00:32:44.480
is going to look
something like this.

00:32:44.480 --> 00:32:49.220
We create a task, save
it to the data source,

00:32:49.220 --> 00:32:51.740
then we ask the local data
source to retrieve that task

00:32:51.740 --> 00:32:54.140
back for us.

00:32:54.140 --> 00:32:56.697
And finally, we can
make an assertion

00:32:56.697 --> 00:32:57.905
that we got what we expected.

00:33:01.330 --> 00:33:04.410
In fact, Google and JetBrains
have just recently collaborated

00:33:04.410 --> 00:33:08.700
to just launch the run blocking
test coroutine builder.

00:33:08.700 --> 00:33:12.570
And this makes testing
coroutines even easier.

00:33:12.570 --> 00:33:16.080
It's currently mocked as an
experimental coroutines API.

00:33:16.080 --> 00:33:18.330
So please, go and check
it out and give us

00:33:18.330 --> 00:33:20.490
some feedback on any
bugs that you might find.

00:33:23.430 --> 00:33:25.300
So in order to write
this test, it's

00:33:25.300 --> 00:33:27.680
important that our data
store maintain state.

00:33:27.680 --> 00:33:29.680
And it does this through
its dependency TaskDao.

00:33:32.850 --> 00:33:36.090
So the problem is with
using Mockito, trying

00:33:36.090 --> 00:33:39.180
to maintain state through
these one-off stubbing calls

00:33:39.180 --> 00:33:41.970
can get messy really fast.

00:33:41.970 --> 00:33:45.460
So we could instead
implement our fake using--

00:33:45.460 --> 00:33:49.410
implement our TaskDao using
a fake like we did earlier

00:33:49.410 --> 00:33:50.802
with the repository.

00:33:50.802 --> 00:33:53.010
Well, we're going to choose
not to go down that route

00:33:53.010 --> 00:33:55.330
for some good reasons.

00:33:55.330 --> 00:33:57.840
Firstly, it doesn't seem
that the TaskDao interface

00:33:57.840 --> 00:34:01.270
is going to be part of
our modules public API.

00:34:01.270 --> 00:34:04.980
And so no one else is going to
benefit from reusing that fake.

00:34:04.980 --> 00:34:06.967
And secondly, right
now I can't think

00:34:06.967 --> 00:34:09.550
of another part of our code that
would benefit from that fake,

00:34:09.550 --> 00:34:11.639
too.

00:34:11.639 --> 00:34:14.219
And this is one of those cases
where it actually makes sense

00:34:14.219 --> 00:34:20.130
to make use of the real objects
rather than putting in a fake.

00:34:20.130 --> 00:34:22.380
In this case, room provides
some really useful testing

00:34:22.380 --> 00:34:23.460
infrastructure for us.

00:34:26.230 --> 00:34:30.270
We can ask room to build us
an in-memory to-do database.

00:34:30.270 --> 00:34:34.510
And then we can use that to
obtain the TaskDao backed

00:34:34.510 --> 00:34:37.120
by that in-memory
database and provide it

00:34:37.120 --> 00:34:41.159
to our LocalDataStore.

00:34:41.159 --> 00:34:43.469
Of course, we'll clean
it up after tests.

00:34:43.469 --> 00:34:45.929
But in all other senses, it's
the same as the production

00:34:45.929 --> 00:34:49.800
database, but it's faster
as it doesn't write data

00:34:49.800 --> 00:34:52.710
to files on the file system.

00:34:52.710 --> 00:34:56.830
And therefore, it also provides
better isolation through tests.

00:34:56.830 --> 00:34:59.370
So is this still a unit test?

00:34:59.370 --> 00:35:01.410
Or is it now an
integration test,

00:35:01.410 --> 00:35:06.240
because we're using real
objects rather than just marks?

00:35:06.240 --> 00:35:11.130
It's a good question, and one
many people will disagree on.

00:35:11.130 --> 00:35:14.970
And it's true, the lines
can become blurry at times.

00:35:14.970 --> 00:35:17.160
But the key takeaway here
is that you shouldn't ever

00:35:17.160 --> 00:35:20.250
be afraid of using real
dependencies in your tests

00:35:20.250 --> 00:35:21.780
where it makes sense--

00:35:21.780 --> 00:35:24.525
where they're more readable,
more lightweight, and robust.

00:35:27.990 --> 00:35:32.840
So let's just recap the kinds
of tests that we wrote today.

00:35:32.840 --> 00:35:36.110
We added an end-to-end test
that covers a critical key user

00:35:36.110 --> 00:35:39.050
journey through our application.

00:35:39.050 --> 00:35:42.080
We decomposed a feature to
add an integration test that

00:35:42.080 --> 00:35:45.080
tests an entire vertical
slides through our application

00:35:45.080 --> 00:35:47.946
from the UI down
to the data layer.

00:35:47.946 --> 00:35:50.450
And we also added
an integration test

00:35:50.450 --> 00:35:53.000
that verifies our
model, which is key

00:35:53.000 --> 00:35:56.610
because other modules are
going to be depending on it.

00:35:56.610 --> 00:35:58.730
And finally, we're able
to decompose and write

00:35:58.730 --> 00:36:01.400
smaller groups of
integration and unit tests,

00:36:01.400 --> 00:36:03.860
such as the ones for the
UI or the local data store.

00:36:06.680 --> 00:36:09.080
Marginalization of your
codebase with clearly

00:36:09.080 --> 00:36:11.960
defined intermodule
contracts allows

00:36:11.960 --> 00:36:14.960
you to streamline
your project build,

00:36:14.960 --> 00:36:17.840
create compiled time
dependencies against small API

00:36:17.840 --> 00:36:20.330
modules, leading to
faster build times

00:36:20.330 --> 00:36:25.020
on each change, and export
testing infrastructure,

00:36:25.020 --> 00:36:27.350
such as lightweight
verified fakes

00:36:27.350 --> 00:36:30.260
that other modules can
swap in and thereby

00:36:30.260 --> 00:36:33.500
decouple their tests from
your heavyweight production

00:36:33.500 --> 00:36:36.780
dependencies.

00:36:36.780 --> 00:36:39.470
So while you can and should have
end-to-end tests to give you

00:36:39.470 --> 00:36:42.350
confidence in your app,
the vast majority of tests

00:36:42.350 --> 00:36:44.890
should not be in this category.

00:36:44.890 --> 00:36:47.630
Marginalizing your
app like this allows

00:36:47.630 --> 00:36:51.070
you to push down many of
those large end-to-end tests

00:36:51.070 --> 00:36:56.110
to more focused, smaller
tests at the module level.

00:36:56.110 --> 00:36:58.280
And each one is
decoupled from the next.

00:37:01.660 --> 00:37:06.700
Finally, this allows us to build
a really well-balanced pyramid.

00:37:06.700 --> 00:37:09.610
And through this
thoughtful architecture,

00:37:09.610 --> 00:37:11.830
there's a number of
obvious cutoff points

00:37:11.830 --> 00:37:15.290
that have surfaced naturally
within the pyramid.

00:37:15.290 --> 00:37:17.500
You'll need to identify
the right spots for testing

00:37:17.500 --> 00:37:19.760
in your own application.

00:37:19.760 --> 00:37:23.240
What works for one project
might not work for another.

00:37:23.240 --> 00:37:25.930
So it's really important
that whatever you choose,

00:37:25.930 --> 00:37:29.680
you document it clearly so that
all collaborators on your team

00:37:29.680 --> 00:37:30.640
are on the same page.

00:37:33.220 --> 00:37:36.190
In Android Development,
there's two kinds of tests.

00:37:36.190 --> 00:37:39.460
Local tests that run
on the VM level, JVM.

00:37:39.460 --> 00:37:41.770
They can be just
pure JUnit tests,

00:37:41.770 --> 00:37:44.080
or they can use
Robolectric to provide

00:37:44.080 --> 00:37:46.160
a simulation of Android.

00:37:46.160 --> 00:37:47.610
They're much faster.

00:37:47.610 --> 00:37:50.140
They're highly
scalable, but they

00:37:50.140 --> 00:37:52.540
don't offer the same confidence
that a real device would.

00:37:55.040 --> 00:37:57.040
On the other hand, there's
instrumentation tests

00:37:57.040 --> 00:38:00.010
that run on a real
or virtual device.

00:38:00.010 --> 00:38:04.000
While slower,
lacking scalability,

00:38:04.000 --> 00:38:06.130
they are true to the
behavior of real Android.

00:38:08.680 --> 00:38:11.740
Last year we launched
Jetpack, AndroidX test,

00:38:11.740 --> 00:38:14.830
which brought together a
unified set of APIs that will

00:38:14.830 --> 00:38:17.420
work on both kinds of tests.

00:38:17.420 --> 00:38:21.700
And these APIs allow us to
focus on writing Android tests

00:38:21.700 --> 00:38:25.330
without thinking about the tools
that we're using underneath

00:38:25.330 --> 00:38:27.970
or where the test is
going to be executed.

00:38:27.970 --> 00:38:31.120
And at the heart of what
we're releasing today

00:38:31.120 --> 00:38:33.700
is increased stability,
improved interoperation

00:38:33.700 --> 00:38:36.640
with Android Studio,
better off-device support

00:38:36.640 --> 00:38:41.250
for Espresso, resources,
and the UI thread control.

00:38:41.250 --> 00:38:43.310
And of course, the
support for the latest

00:38:43.310 --> 00:38:47.250
Jetpack architecture components.

00:38:47.250 --> 00:38:50.760
While tests of all sizes can run
on a real or a virtual device,

00:38:50.760 --> 00:38:53.160
these improvements have
made it possible to run

00:38:53.160 --> 00:38:59.130
increasingly larger integration
tests faster on the local JVM.

00:38:59.130 --> 00:39:01.660
All of the integration tests
that we've documented today

00:39:01.660 --> 00:39:04.230
and in the code lab
will run equally well

00:39:04.230 --> 00:39:07.710
on both the local JVM or in
a real or a virtual device.

00:39:10.460 --> 00:39:13.730
Project Nitrogen is our vision
for a unified test execution

00:39:13.730 --> 00:39:15.170
platform.

00:39:15.170 --> 00:39:17.570
It brings together all
these many disparate tools

00:39:17.570 --> 00:39:19.820
and environments.

00:39:19.820 --> 00:39:24.890
With Nitrogen, any test that's
written with a unified API

00:39:24.890 --> 00:39:28.160
using AndroidX tests can be
run on any of these execution

00:39:28.160 --> 00:39:30.350
platforms seamlessly
from Android

00:39:30.350 --> 00:39:33.170
Studio or your
continuous build system.

00:39:33.170 --> 00:39:35.090
You've got the option
to run any Android

00:39:35.090 --> 00:39:37.790
test on a variety
of these platforms,

00:39:37.790 --> 00:39:42.423
such as virtual devices, cloud
farms, simulator devices.

00:39:42.423 --> 00:39:44.090
And while the team
is still working hard

00:39:44.090 --> 00:39:46.920
to bring this vision to
reality, in the meantime,

00:39:46.920 --> 00:39:50.090
we'll share a little
trick with you.

00:39:50.090 --> 00:39:54.200
Normally, local tests would be
placed in the test source root.

00:39:54.200 --> 00:39:58.460
Instrumentation tests go in
the Android test source route.

00:39:58.460 --> 00:40:01.400
But to show you what's
possible with a unified API,

00:40:01.400 --> 00:40:03.800
in this code lab, we're
using a little trick

00:40:03.800 --> 00:40:08.070
to create a shared test
source root folder.

00:40:08.070 --> 00:40:09.920
And here we can
place tests that are

00:40:09.920 --> 00:40:16.622
written with the unified API run
on both device and off-device.

00:40:16.622 --> 00:40:18.080
And how and where
you decide to run

00:40:18.080 --> 00:40:20.163
them really depends on
your project's philosophies

00:40:20.163 --> 00:40:21.080
or needs.

00:40:21.080 --> 00:40:25.430
But here you can start
to see the possibilities.

00:40:25.430 --> 00:40:28.250
Today we're also launching
an early access program

00:40:28.250 --> 00:40:31.370
for Nitrogen for
tools integrators.

00:40:31.370 --> 00:40:33.110
So if you're a
developer that maintains

00:40:33.110 --> 00:40:37.100
monitoring profiling
performance tools,

00:40:37.100 --> 00:40:41.000
you provide continuous
integration platforms,

00:40:41.000 --> 00:40:45.230
you build real or device
services for developers,

00:40:45.230 --> 00:40:50.420
you make IDEs or build farms,
we're looking to hear from you

00:40:50.420 --> 00:40:55.080
and get your feedback
on our early access.

00:40:55.080 --> 00:40:58.650
So please go ahead, check
out the code in the code lab.

00:40:58.650 --> 00:41:00.960
You can see the great
examples for project structure

00:41:00.960 --> 00:41:02.190
and blueprints.

00:41:02.190 --> 00:41:03.630
Examples of the
kinds of tests you

00:41:03.630 --> 00:41:07.440
should be writing at different
level using the unified APIs.

00:41:07.440 --> 00:41:10.530
And see just what kinds of
tests are possible to run on-

00:41:10.530 --> 00:41:14.430
and off-device, which leads
the way to Project Nitrogen.

00:41:14.430 --> 00:41:17.640
This is all available online
now and it's available

00:41:17.640 --> 00:41:20.790
right here in the code lab
section for you to check out.

00:41:20.790 --> 00:41:25.340
[MUSIC PLAYING]

