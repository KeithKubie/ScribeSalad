WEBVTT
Kind: captions
Language: en

00:00:00.810 --> 00:00:03.190
Recall that we started with a problem of designing a robot,

00:00:03.190 --> 00:00:07.290
that can walk on water. Let us suppose that, that particular target

00:00:07.290 --> 00:00:12.170
problem resolves in the retrieval of a source case, of a robot design that we

00:00:12.170 --> 00:00:17.420
already encountered. One that can walk on ground. Now the question becomes,

00:00:17.420 --> 00:00:21.080
how can we adapt this particular design of the robot that can walk on

00:00:21.080 --> 00:00:26.455
the ground, into a robot design that can walk on water? Let us now suppose,

00:00:26.455 --> 00:00:32.299
if we reuse this particular problem of designing a robot to walk on water.

00:00:32.299 --> 00:00:36.830
As a probe into the case memory. And now the case returns to us,

00:00:36.830 --> 00:00:40.410
the design of the basilisk lizard. That might happen,

00:00:40.410 --> 00:00:44.290
because the design of the basilisk lizard, is indexed by it's functional model,

00:00:44.290 --> 00:00:48.500
walk on water. So there is a pragmatic similarity between the two.

00:00:48.500 --> 00:00:51.040
We now have the design of a robot who can walk on ground,

00:00:51.040 --> 00:00:55.070
and we have the design of a biological organism, the Basilisk Lizard,

00:00:55.070 --> 00:01:00.160
that can walk on water. For the Basilisk lizard, we also have a complete model,

00:01:00.160 --> 00:01:04.989
a complete explanation of how its structure achieves its function. Now that

00:01:04.989 --> 00:01:09.280
we have a partial design for the robot, this is a design of the robot that can

00:01:09.280 --> 00:01:14.230
walk on ground. And we have a design of an organism that can walk on water.

00:01:14.230 --> 00:01:17.830
We can try to do an alignment between these two. This alignment will be

00:01:17.830 --> 00:01:22.750
based on the similarity between relationships. Clearly, the objects here, and

00:01:22.750 --> 00:01:27.870
objects there are very different. Once we have aligned these structural models,

00:01:27.870 --> 00:01:31.170
or the robot that can walk on ground, and the basilisk lizard that can walk on

00:01:31.170 --> 00:01:37.190
water. Then, we can start doing transfer. We can transfer specific features,

00:01:37.190 --> 00:01:41.700
of the structure of the basilisk lizard. For example, the shape of its feet,

00:01:41.700 --> 00:01:45.400
to this model, of the robot that can walk on ground. In order to convert it

00:01:45.400 --> 00:01:50.110
into a robot, it can walk on water. Having constructed a structural model, for

00:01:50.110 --> 00:01:54.470
this robot that can walk on water then we can try to transport the behavioral

00:01:54.470 --> 00:01:59.400
model, and then the functional model. And then this way we have a complete model

00:01:59.400 --> 00:02:03.720
of a robot that can walk on water. Along with an explanation of how it

00:02:03.720 --> 00:02:07.370
will achieve it's function. This is sometimes called compositional analogy.

00:02:07.370 --> 00:02:09.979
We'll first do mapping at the level of structure, and

00:02:09.979 --> 00:02:13.690
that mapping at a level of structure helps us transfer some information.

00:02:14.810 --> 00:02:19.300
That in turn allows us to transfer information at the behavioral level.

00:02:19.300 --> 00:02:22.280
Once we have transferred information at the behavioral level, we can climb up

00:02:22.280 --> 00:02:26.290
this abstraction hierarchy, and transfer information at a functional level.

00:02:26.290 --> 00:02:30.520
We can now revisit our computational process, and our logical reasoning.

00:02:30.520 --> 00:02:33.660
Initially we had presented this particular process like, a linear chain,

00:02:33.660 --> 00:02:38.680
Retrieval, Mapping, Transfer, Evaluation and Storage. In general, however,

00:02:38.680 --> 00:02:42.820
there can be many loops here. We may do some initial mapping, for example,

00:02:42.820 --> 00:02:46.910
that may result in some transfer of information. But that transfer then,

00:02:46.910 --> 00:02:50.920
may lead to additional mapping, and then to additional transfer and so

00:02:50.920 --> 00:02:56.190
on. Here is another brief example, from biological inspired design, in this case

00:02:56.190 --> 00:03:01.010
we want to design a robot that can swim under water in a very slowly manner.

00:03:01.010 --> 00:03:04.230
This particular function of swimming underwater in a stealthy manner,

00:03:04.230 --> 00:03:09.640
reminds a design team of a copepod. A copepod is a biological organism,

00:03:09.640 --> 00:03:13.250
that has a large number of appendages. It moves underwater, in

00:03:13.250 --> 00:03:19.070
such a way that in generates minimum wake, especially when it moves very slowly.

00:03:19.070 --> 00:03:24.260
On the other hand, when it moves rapidly, then the wake becomes large,

00:03:24.260 --> 00:03:28.380
when the wake is small then its motion is very steady, when the wake is large,

00:03:28.380 --> 00:03:32.480
its motion is no longer steady. An analogically transfer of knowledge about this

00:03:32.480 --> 00:03:38.340
particular copepod, gives a design for the microbot for slow velocity.

00:03:39.370 --> 00:03:44.170
This analogy, decomposes our original design problem. We had the original design

00:03:44.170 --> 00:03:48.070
problem, as moving underwater in a stealthy manner. Now that we

00:03:48.070 --> 00:03:53.280
have a design of an organism, for moving underwater at low velocities,

00:03:53.280 --> 00:03:58.360
we are still left with the sub goal of moving underwater at high velocities.

00:03:58.360 --> 00:04:02.570
The goal of designing a microbot, that can move underwater in a stealthy manner,

00:04:02.570 --> 00:04:07.240
at fast velocities, may remind the design team of the squid. The squid uses

00:04:07.240 --> 00:04:11.170
a special mechanism, like the jet propulsion mechanism to move underwater in

00:04:11.170 --> 00:04:15.910
a stealthy manner at pretty high velocities. Now we have created a designed for

00:04:15.910 --> 00:04:19.410
microbot. Where part of the design comes from the design of the copepod,

00:04:19.410 --> 00:04:21.360
and the other part comes from the design of the squid.

00:04:21.360 --> 00:04:24.830
Instead of borrowing the design from one source case,

00:04:24.830 --> 00:04:28.170
we are borrowing parts of the design of multiple source cases.

00:04:28.170 --> 00:04:32.680
This is a compound analogy. Notice that there's a problem evolution going on,

00:04:32.680 --> 00:04:36.480
which started with one problem. We arrived at a partial solution to that.

00:04:36.480 --> 00:04:40.310
Which then leads us to a problem evolution. And the problem transformation.

00:04:40.310 --> 00:04:44.590
We then have a new understanding of the problem. So, this example we saw,

00:04:44.590 --> 00:04:48.850
how we first did analogical retrieval of the coco powder organism. Then Mapping,

00:04:48.850 --> 00:04:54.460
then Transfer. That then lead to addition retrieval, in this case with a squid.

00:04:54.460 --> 00:04:57.670
Once again this process is not linear. Just like we can iterate between

00:04:57.670 --> 00:05:01.800
Mapping and Transfer, similarly we can iterate between Transfer and Retrieval.

