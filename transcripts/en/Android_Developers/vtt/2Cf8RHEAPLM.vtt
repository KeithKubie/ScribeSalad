WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.122
[MUSIC PLAYING]

00:00:04.019 --> 00:00:06.090
FRANCESCO CARUCCI:
My name is Francesco.

00:00:06.090 --> 00:00:08.610
I'm a game developer advocate.

00:00:08.610 --> 00:00:11.070
Really, I'm a game developer.

00:00:11.070 --> 00:00:17.880
I've been making games
since 1999, give or take.

00:00:17.880 --> 00:00:19.290
I'm a graphics engineer.

00:00:19.290 --> 00:00:21.825
So I'm super excited
to talk about Vulkan.

00:00:21.825 --> 00:00:24.180
It's graphics APIs.

00:00:24.180 --> 00:00:28.700
I'm a geek, and
it's going to show.

00:00:28.700 --> 00:00:33.380
I worked on several engines
in my gaming career on--

00:00:33.380 --> 00:00:36.830
who has ever played
"Fable II" here?

00:00:36.830 --> 00:00:37.860
She did.

00:00:37.860 --> 00:00:39.350
Yep, that's my work.

00:00:39.350 --> 00:00:42.390
It's my engine with others.

00:00:42.390 --> 00:00:45.800
And I also work on
CRYENGINE from Crytek,

00:00:45.800 --> 00:00:49.550
the "does it run on
crysis" thinking.

00:00:49.550 --> 00:00:53.150
I'm a geek about graphics APIs.

00:00:53.150 --> 00:00:58.670
And today I'm super excited
to share this stage with two

00:00:58.670 --> 00:01:01.220
titans of the Vulkan ecosystem.

00:01:01.220 --> 00:01:04.720
Here with me, Tom and Jung-woo.

00:01:04.720 --> 00:01:08.770
They will show you what is
tools and best practices

00:01:08.770 --> 00:01:12.940
to bring to life console
quality experiences

00:01:12.940 --> 00:01:15.542
on mobile, which
is unprecedented.

00:01:21.690 --> 00:01:25.910
We're going to talk about
the Vulkan system, which

00:01:25.910 --> 00:01:27.980
is a big ecosystem.

00:01:27.980 --> 00:01:31.410
And Tom will go in
great details about it.

00:01:31.410 --> 00:01:34.470
And then we're going to talk
about tools, because I mean,

00:01:34.470 --> 00:01:39.870
really, an ecosystem
is as good as the tools

00:01:39.870 --> 00:01:41.680
that you can run on.

00:01:41.680 --> 00:01:46.620
If you remember back in the
day, the Xbox 360 and the PS 3,

00:01:46.620 --> 00:01:51.000
times the PS 3 had
arguably better hardware.

00:01:51.000 --> 00:01:53.970
But the games on 360 were
probably looking better

00:01:53.970 --> 00:01:56.880
for a long time because
of the amazing tools

00:01:56.880 --> 00:01:58.410
that were running
on the platform.

00:01:58.410 --> 00:02:02.670
I'm super biased, because
I worked on the 360.

00:02:02.670 --> 00:02:05.070
But someone working
on PS 3 will tell you

00:02:05.070 --> 00:02:06.630
that their tools
were amazing too.

00:02:06.630 --> 00:02:09.490
That's why they could
make fantastic games.

00:02:09.490 --> 00:02:14.990
So we're going to explore
tools on running on Vulkan.

00:02:14.990 --> 00:02:16.790
And now what the user tool for?

00:02:16.790 --> 00:02:20.240
Oh, use tools for
improving game performance.

00:02:20.240 --> 00:02:24.830
And Jung-woo will show you
how you can use these tools

00:02:24.830 --> 00:02:27.650
and you can use best
practices to literally make

00:02:27.650 --> 00:02:29.870
games sing using Vulkan.

00:02:29.870 --> 00:02:32.660
And then we are not
going to have Q&amp;A.

00:02:32.660 --> 00:02:35.960
I don't know why it's there.

00:02:35.960 --> 00:02:37.245
But you can come afterwards.

00:02:37.245 --> 00:02:41.070
So let's come talk to me.

00:02:41.070 --> 00:02:41.790
Here's the thing.

00:02:41.790 --> 00:02:46.620
I am here standing on the
shoulders of these titans

00:02:46.620 --> 00:02:52.030
to tell you that Vulkan
is viable on Android.

00:02:52.030 --> 00:02:53.180
It's been a bumpy road.

00:02:56.000 --> 00:02:57.630
There are issues.

00:02:57.630 --> 00:02:58.910
We know.

00:02:58.910 --> 00:03:03.470
But I personally worked
on games that either ship

00:03:03.470 --> 00:03:06.460
Vulkan only or shipped
with Vulkan render that

00:03:06.460 --> 00:03:08.240
are making games.

00:03:08.240 --> 00:03:11.690
And they're making money.

00:03:11.690 --> 00:03:12.830
Vulkan is viable.

00:03:12.830 --> 00:03:15.020
And we're going to
go to great lengths

00:03:15.020 --> 00:03:16.760
to show you how and why.

00:03:22.330 --> 00:03:25.180
One of the
characteristics of Vulkan

00:03:25.180 --> 00:03:29.260
is, well, the driver
overhead is much lower

00:03:29.260 --> 00:03:32.140
compared to OpenGL,
which basically means

00:03:32.140 --> 00:03:35.530
that things like state
validation in OpenGL

00:03:35.530 --> 00:03:37.430
happens all the time.

00:03:37.430 --> 00:03:41.290
Like, you are submitting a draw
call, and the driver's like,

00:03:41.290 --> 00:03:42.820
are the states correct?

00:03:42.820 --> 00:03:43.550
Yeah, they are.

00:03:43.550 --> 00:03:44.440
Submitting another draw call--

00:03:44.440 --> 00:03:45.580
but are they really correct?

00:03:45.580 --> 00:03:46.163
Yes, they are.

00:03:46.163 --> 00:03:49.240
You checked right a second ago.

00:03:49.240 --> 00:03:51.820
In Vulkan, it's something
that you do once.

00:03:51.820 --> 00:03:52.720
You cache.

00:03:52.720 --> 00:03:54.213
You build your state pipeline.

00:03:54.213 --> 00:03:54.880
And off it goes.

00:03:54.880 --> 00:03:57.850
You render as many draw calls
as you like with that pipeline.

00:03:57.850 --> 00:03:59.440
And it's immutable.

00:03:59.440 --> 00:04:03.100
It doesn't need to be
verified every time.

00:04:03.100 --> 00:04:06.360
This means lower driver
overhead, lower CPU

00:04:06.360 --> 00:04:10.988
consumption, lower CPU usage,
a lower power consumption,

00:04:10.988 --> 00:04:11.780
simple consumption.

00:04:11.780 --> 00:04:13.655
I mean, you can use CPUs
as much as you like.

00:04:16.269 --> 00:04:19.180
Which is, for me, one
of the main reasons

00:04:19.180 --> 00:04:22.350
to start thinking about Vulkan.

00:04:22.350 --> 00:04:26.040
Your CPU will be
engaged reasonably less

00:04:26.040 --> 00:04:30.180
than with a standard
OpenGL render, which

00:04:30.180 --> 00:04:31.680
means that you're
going to give more

00:04:31.680 --> 00:04:35.670
chances to the various course
to go to sleep and consume

00:04:35.670 --> 00:04:36.423
less power.

00:04:36.423 --> 00:04:37.840
Which also means
that you're going

00:04:37.840 --> 00:04:41.130
to have less chances go
into thermal throttling.

00:04:41.130 --> 00:04:45.900
I talked yesterday about it
too for about 20 minutes.

00:04:48.840 --> 00:04:52.000
Lower power consumption
means longer battery life,

00:04:52.000 --> 00:04:53.950
which means more
money in your pockets.

00:04:56.920 --> 00:05:00.880
Also, Vulkan has been
designed from the ground

00:05:00.880 --> 00:05:05.760
up from the beginning to be
a multi-threaded API, which

00:05:05.760 --> 00:05:11.720
means that you can build your
common buffers in parallel

00:05:11.720 --> 00:05:14.090
on several threads.

00:05:14.090 --> 00:05:17.610
You're not stuck
anymore into this world

00:05:17.610 --> 00:05:21.647
where all your comments are
serialized into one thread,

00:05:21.647 --> 00:05:22.980
and then off they go to the GPU.

00:05:22.980 --> 00:05:28.830
Now, you can take full advantage
of the multi-core architecture

00:05:28.830 --> 00:05:32.480
that we now run our phones on.

00:05:32.480 --> 00:05:37.490
Again, multi-thread API means
shorter render frame times,

00:05:37.490 --> 00:05:40.970
also means more chances for the
various cores to go to sleep,

00:05:40.970 --> 00:05:42.610
less battery consumption, again.

00:05:45.620 --> 00:05:50.360
And here is what I like
the most about Vulkan.

00:05:50.360 --> 00:05:53.570
The fact that I'm a
graphics engineer--

00:05:53.570 --> 00:05:55.100
I write this engine.

00:05:55.100 --> 00:05:56.840
I know when the
shuttle buffer happens.

00:05:56.840 --> 00:05:59.780
I know when the
various render targets

00:05:59.780 --> 00:06:05.040
I'm rendering to need
to be rendered to.

00:06:05.040 --> 00:06:06.360
I know which texture I'm using.

00:06:06.360 --> 00:06:08.360
I know everything
about my engine.

00:06:08.360 --> 00:06:10.310
At least I hope so.

00:06:10.310 --> 00:06:14.730
I can tell the
driver what resources

00:06:14.730 --> 00:06:16.200
depends on what resources.

00:06:16.200 --> 00:06:19.740
I don't need the driver to try
to figure it out every frame

00:06:19.740 --> 00:06:22.180
from what I submitting.

00:06:22.180 --> 00:06:25.740
I am in full
control with Vulkan.

00:06:25.740 --> 00:06:28.990
And with control comes
great responsibility.

00:06:28.990 --> 00:06:31.530
There is a higher
chance to get it wrong.

00:06:31.530 --> 00:06:34.617
And Tom will show you
how to detect these cases

00:06:34.617 --> 00:06:35.700
and do something about it.

00:06:39.740 --> 00:06:46.920
This is the latest
CRYENGINE demo

00:06:46.920 --> 00:06:49.930
that was featuring ray tracing.

00:06:49.930 --> 00:06:51.760
It's a Vulkan demo.

00:06:54.930 --> 00:06:56.295
It looks stunning.

00:06:59.530 --> 00:07:04.240
And it runs on mobile
without the ray tracing part.

00:07:04.240 --> 00:07:06.960
But this thing runs on mobile.

00:07:06.960 --> 00:07:08.880
It was running on my Pixel 3.

00:07:08.880 --> 00:07:11.520
This video is coming
from my Pixel 3.

00:07:11.520 --> 00:07:13.200
It's a direct capture.

00:07:13.200 --> 00:07:18.923
They posted this in
two or three weeks.

00:07:18.923 --> 00:07:19.590
Can you play it?

00:07:22.513 --> 00:07:23.013
Thanks.

00:07:26.930 --> 00:07:29.140
I strongly encourage
you to come over there

00:07:29.140 --> 00:07:31.890
and see it running on device.

00:07:31.890 --> 00:07:32.940
This is unheard of.

00:07:38.510 --> 00:07:41.480
Special thanks to
[INAUDIBLE] and Vladimir who

00:07:41.480 --> 00:07:44.203
put up this demo in no time.

00:07:44.203 --> 00:07:45.620
I was amazed to
seeing it running.

00:07:50.110 --> 00:07:53.290
And now it's time for Tom.

00:07:53.290 --> 00:07:53.790
Thank you.

00:07:59.980 --> 00:08:00.980
TOM OLSON: Thanks, Fran.

00:08:00.980 --> 00:08:04.180
So first, to correct all the
things he said that are wrong.

00:08:04.180 --> 00:08:07.000
We're not going to
go into deep detail

00:08:07.000 --> 00:08:09.610
about debugging tools
or the ecosystem,

00:08:09.610 --> 00:08:11.440
because we only have 20 minutes.

00:08:11.440 --> 00:08:13.250
And it's a big thing.

00:08:13.250 --> 00:08:17.860
And so what we're going to do
is take a very high level view

00:08:17.860 --> 00:08:19.370
of just a little bit of it.

00:08:19.370 --> 00:08:22.150
And then I'll go into great
detail on a few things

00:08:22.150 --> 00:08:24.160
that I think are exciting.

00:08:24.160 --> 00:08:27.830
I'm kind of assuming that Vulkan
is not new to most of you.

00:08:27.830 --> 00:08:30.230
You kind of know the
basic principles.

00:08:30.230 --> 00:08:31.930
And at least some
of you are probably

00:08:31.930 --> 00:08:34.460
more skilled than I
am, because by the way,

00:08:34.460 --> 00:08:36.520
I should say he's
a game developer.

00:08:36.520 --> 00:08:37.120
I'm not.

00:08:37.120 --> 00:08:38.140
Never have been.

00:08:38.140 --> 00:08:40.940
Sorry about that.

00:08:40.940 --> 00:08:44.510
So as to who I
am-- my name's Tom.

00:08:44.510 --> 00:08:47.910
I work for ARM on
the Mollie GPU team.

00:08:47.910 --> 00:08:50.190
And I also chair the
Vulkan working group.

00:08:50.190 --> 00:08:52.100
So I have two hats
with me today.

00:08:52.100 --> 00:08:54.360
I'm going to talk from
both perspectives.

00:08:54.360 --> 00:09:01.920
I will try to be clear about
when I'm talking about what.

00:09:01.920 --> 00:09:04.140
So 10,000-foot view--

00:09:04.140 --> 00:09:06.210
I tried to draw a picture.

00:09:06.210 --> 00:09:09.000
And the conclusion
was it is complicated.

00:09:09.000 --> 00:09:12.180
I don't mean that in the
creepy social media sense.

00:09:12.180 --> 00:09:16.360
I mean that there are
a lot of moving parts.

00:09:16.360 --> 00:09:18.420
I work mostly in the
red stuff over there

00:09:18.420 --> 00:09:21.540
with the specifications,
conformance, validation.

00:09:21.540 --> 00:09:24.510
But there is a whole army
of people working, including

00:09:24.510 --> 00:09:28.350
your friendly neighborhood
dev techs, at least one

00:09:28.350 --> 00:09:30.000
of whom you'll
recognize on the right.

00:09:32.610 --> 00:09:35.670
So the point of
this slide is not

00:09:35.670 --> 00:09:37.530
to say that it's complicated.

00:09:37.530 --> 00:09:40.560
It's to say that there's a lot
of people, a lot of software

00:09:40.560 --> 00:09:44.070
teams, working very hard
across the ecosystem

00:09:44.070 --> 00:09:46.170
to make Vulkan a good platform.

00:09:46.170 --> 00:09:48.450
The whole ecosystem
is much bigger

00:09:48.450 --> 00:09:50.940
than it looks from the outside.

00:09:50.940 --> 00:09:53.220
What this slide doesn't
show is the growth

00:09:53.220 --> 00:09:54.570
that's been happening.

00:09:54.570 --> 00:09:56.400
I tried to draw a
picture of that.

00:09:56.400 --> 00:09:58.290
It was a total non-starter.

00:09:58.290 --> 00:10:01.350
What I'll show instead is
just a few quick slices

00:10:01.350 --> 00:10:04.570
through the data to
give you some sense.

00:10:04.570 --> 00:10:07.560
So one thing I track
is SDK downloads.

00:10:07.560 --> 00:10:11.070
I don't actually have the data
for Android, I'm sorry to say,

00:10:11.070 --> 00:10:12.930
because their SDK is bundled.

00:10:12.930 --> 00:10:15.940
But for the Vulkan
SDK for desktop,

00:10:15.940 --> 00:10:17.190
this is what we're seeing.

00:10:17.190 --> 00:10:20.980
It's noisy, but the
growth is continuous.

00:10:20.980 --> 00:10:25.480
I also like to track what's
happening in open source.

00:10:25.480 --> 00:10:28.510
Monday night, I went to
GitHub and typed Vulkan

00:10:28.510 --> 00:10:30.310
at the very top
level search box.

00:10:30.310 --> 00:10:35.860
It told me there were 3,126
projects that mentioned Vulkan.

00:10:35.860 --> 00:10:37.630
I've been doing that
for three years.

00:10:37.630 --> 00:10:39.220
And I can plot the data.

00:10:39.220 --> 00:10:41.937
And it's as clean as a whistle.

00:10:41.937 --> 00:10:43.770
It's either linear, or
the second derivative

00:10:43.770 --> 00:10:46.300
might be slightly positive.

00:10:46.300 --> 00:10:49.200
But the rate of growth there
is very impressive as well.

00:10:52.680 --> 00:10:55.400
One of the things that my
committee worries about most

00:10:55.400 --> 00:10:59.000
is making sure that you have
quality drivers to develop on.

00:10:59.000 --> 00:11:01.520
So when we write
specs, we also write

00:11:01.520 --> 00:11:03.950
conformance tests
in as much detail

00:11:03.950 --> 00:11:07.390
as we can afford to to make
sure that implementations

00:11:07.390 --> 00:11:11.150
that say they implement
the spec actually do.

00:11:11.150 --> 00:11:16.520
So we launched three years
ago with 100,000 test cases

00:11:16.520 --> 00:11:17.780
in conformance.

00:11:17.780 --> 00:11:20.100
We're at 400,000 today.

00:11:20.100 --> 00:11:21.410
And you can do the math.

00:11:21.410 --> 00:11:22.910
Again, it's pretty linear.

00:11:22.910 --> 00:11:26.100
So we expect this to
continue indefinitely.

00:11:26.100 --> 00:11:27.910
We know it's working
because every time we

00:11:27.910 --> 00:11:32.180
add tests the GPU vendors
come back and say, oops.

00:11:32.180 --> 00:11:34.350
And then they go off and
they have work to do.

00:11:34.350 --> 00:11:37.240
So that's a good thing,
from my point of view.

00:11:40.100 --> 00:11:42.490
Finally, of course,
there is content.

00:11:42.490 --> 00:11:45.910
It was kind of a slow ramp
in mobile reflecting the fact

00:11:45.910 --> 00:11:48.790
that it took Vulkan
a while to build up

00:11:48.790 --> 00:11:51.670
a substantial footprint
in the market.

00:11:51.670 --> 00:11:54.490
Last year was the year
when Vulkan really

00:11:54.490 --> 00:11:56.170
became a thing on desktop.

00:11:56.170 --> 00:11:58.600
This year it's really
a thing on Android.

00:11:58.600 --> 00:12:02.740
So a lot of very high
quality stuff shipping.

00:12:02.740 --> 00:12:06.580
That's all the detail you get
on the ecosystem as a whole.

00:12:06.580 --> 00:12:07.700
Sorry.

00:12:07.700 --> 00:12:09.190
That's all I have time for.

00:12:09.190 --> 00:12:11.140
What I would like
to do is zoom in

00:12:11.140 --> 00:12:13.870
from 10,000 feet
to 10 inches, talk

00:12:13.870 --> 00:12:17.620
about a very narrow advance
in the tools ecosystem

00:12:17.620 --> 00:12:20.230
that I'm really excited
about and looking forward

00:12:20.230 --> 00:12:23.150
to seeing people use.

00:12:23.150 --> 00:12:25.090
It's called
GPU-assisted validation.

00:12:25.090 --> 00:12:28.060
The work was done by
LunarG with funding

00:12:28.060 --> 00:12:31.120
from Valve and in consultation
with the Working Group.

00:12:31.120 --> 00:12:32.410
They're both members.

00:12:32.410 --> 00:12:33.940
And we all go way back.

00:12:33.940 --> 00:12:37.780
I should say all of this part of
the talk is with my Vulkan hat

00:12:37.780 --> 00:12:40.720
on, talking for the
Working Group, not for ARM.

00:12:44.230 --> 00:12:46.780
So hopefully you know
how validation works.

00:12:46.780 --> 00:12:50.050
When your application
calls a Vulkan entry point,

00:12:50.050 --> 00:12:53.500
it's going through an
ICD table and reaching

00:12:53.500 --> 00:12:58.470
a hardware-specific,
GPU-specific driver underneath.

00:12:58.470 --> 00:13:02.020
And that ICD is doing
no error checking at all

00:13:02.020 --> 00:13:03.190
if it can help it.

00:13:03.190 --> 00:13:06.070
It assumes you're using
the API correctly.

00:13:06.070 --> 00:13:08.590
If you're not,
something will happen.

00:13:08.590 --> 00:13:11.350
But it's not the
driver's problem.

00:13:11.350 --> 00:13:17.770
So that's one of the reasons, as
Fran said, that the drivers are

00:13:17.770 --> 00:13:19.600
very efficient, very fast.

00:13:19.600 --> 00:13:21.920
But it's a hellish
debugging environment.

00:13:21.920 --> 00:13:25.270
So to make debugging and
development possible,

00:13:25.270 --> 00:13:27.320
we provide validation layers.

00:13:27.320 --> 00:13:28.900
So you can tell
the loader when it

00:13:28.900 --> 00:13:33.680
initializes the ICD interface
to insert validation underneath.

00:13:33.680 --> 00:13:36.010
Then when you call into
those entry points,

00:13:36.010 --> 00:13:37.810
the validation
layer checks them,

00:13:37.810 --> 00:13:42.400
tells you if you're doing
something wrong before it

00:13:42.400 --> 00:13:45.330
passes the data to the ICD.

00:13:45.330 --> 00:13:49.350
This works great for
things like invalid enum.

00:13:49.350 --> 00:13:54.420
It works for things like I'm
passing in shader code, which I

00:13:54.420 --> 00:13:56.130
hope you know how SPIR-V works.

00:13:56.130 --> 00:13:59.100
If it declares a
SPIR-V capability

00:13:59.100 --> 00:14:00.630
that your hardware
doesn't support,

00:14:00.630 --> 00:14:02.650
it can catch that kind of error.

00:14:02.650 --> 00:14:05.010
Those are all static errors.

00:14:05.010 --> 00:14:08.700
Unfortunately, most of the
interesting errors are dynamic.

00:14:08.700 --> 00:14:13.650
So for example, you
might have a GLSL shader

00:14:13.650 --> 00:14:16.845
that starts out declaring an
array of 6 texture samplers.

00:14:19.420 --> 00:14:22.720
And if in your code you
reference one of those,

00:14:22.720 --> 00:14:27.190
and you reference outside the
array, that's a static error.

00:14:27.190 --> 00:14:29.140
SPIR-V validation will catch it.

00:14:29.140 --> 00:14:30.650
But actually, the compiler--

00:14:30.650 --> 00:14:33.580
GLS glslang-- will
catch it first.

00:14:33.580 --> 00:14:37.000
So you will fix it,
and you'll be fine.

00:14:37.000 --> 00:14:39.270
But if your code is
doing something dynamic,

00:14:39.270 --> 00:14:43.740
if the index is coming
from a shader stage

00:14:43.740 --> 00:14:47.730
input or a buffer or a
texture, the compiler

00:14:47.730 --> 00:14:50.170
can't do anything on your host.

00:14:50.170 --> 00:14:54.300
So what's going to happen if
you actually execute this code

00:14:54.300 --> 00:14:57.670
and that index is out
of range, the spec says,

00:14:57.670 --> 00:15:00.140
you get undefined behavior.

00:15:00.140 --> 00:15:03.910
If you're lucky, what that
means is it draws your geometry.

00:15:03.910 --> 00:15:06.780
And there's a texture
corrupt or missing.

00:15:06.780 --> 00:15:10.400
And you can look at the
picture and figure it out.

00:15:10.400 --> 00:15:13.330
But honestly, you're
usually not that lucky.

00:15:13.330 --> 00:15:16.030
Usually you either get
"device lost," or you just

00:15:16.030 --> 00:15:18.070
get something totally weird.

00:15:18.070 --> 00:15:20.140
And you just have no
clue what's going on.

00:15:20.140 --> 00:15:22.540
And it takes you days and days
and days to figure it out.

00:15:26.890 --> 00:15:28.750
So now we have something better.

00:15:28.750 --> 00:15:30.600
This is as of JDC.

00:15:30.600 --> 00:15:33.570
Again, we've made
progress even since then.

00:15:33.570 --> 00:15:34.980
The way this works--

00:15:34.980 --> 00:15:37.410
your application wants
to make a shader.

00:15:37.410 --> 00:15:39.090
It loads in a SPIR-V blob.

00:15:39.090 --> 00:15:41.550
That's the binary
intermediate shading language.

00:15:44.590 --> 00:15:47.100
It passes it to
CreateShaderModule.

00:15:47.100 --> 00:15:50.480
If you have this validation
enabled, the shim--

00:15:50.480 --> 00:15:53.150
that is the validation
layer implementation--

00:15:53.150 --> 00:15:56.000
grabs the blob, runs
it through spirv-opt,

00:15:56.000 --> 00:16:00.470
which is a general purpose
shader transformation engine.

00:16:00.470 --> 00:16:04.400
And that spirv-opt in
this mode goes through,

00:16:04.400 --> 00:16:07.880
finds all the references to
texture descriptor arrays,

00:16:07.880 --> 00:16:11.360
and sticks in extra SPIR-V
code around them to check

00:16:11.360 --> 00:16:12.930
is it in range or not.

00:16:12.930 --> 00:16:15.770
If it's not, write
an error log message,

00:16:15.770 --> 00:16:18.410
and also coerce
it to be legal so

00:16:18.410 --> 00:16:20.900
that hopefully you
won't get "device lost,"

00:16:20.900 --> 00:16:22.770
at least not right away.

00:16:22.770 --> 00:16:26.590
So that gets passed back, goes
down into the native driver,

00:16:26.590 --> 00:16:28.925
and the whole schmear
gets compiled.

00:16:28.925 --> 00:16:30.800
When you eventually run
a command buffer that

00:16:30.800 --> 00:16:33.530
does this, that
contains this code,

00:16:33.530 --> 00:16:37.010
after the buffer completes,
validation checks the log

00:16:37.010 --> 00:16:38.780
and sees if there's
something there.

00:16:38.780 --> 00:16:42.930
If there is, it writes you
a human readable message.

00:16:42.930 --> 00:16:45.040
So it's a lot of text.

00:16:45.040 --> 00:16:47.440
But there is a lot
of information here.

00:16:47.440 --> 00:16:50.220
So it tells you, for example,
what's the name of the error.

00:16:50.220 --> 00:16:52.290
They're supposed to
have error ID codes.

00:16:52.290 --> 00:16:54.870
Sorry, we didn't get
around to that yet.

00:16:54.870 --> 00:16:56.280
It tells you the details.

00:16:56.280 --> 00:17:00.300
You indexed out of
range exactly like this.

00:17:00.300 --> 00:17:03.570
It gives you the handle of the
command buffer, which is OK.

00:17:03.570 --> 00:17:06.670
But mapping it to your
code is kind of awkward.

00:17:06.670 --> 00:17:09.569
So fortunately there's
a debug extension

00:17:09.569 --> 00:17:12.569
called ext debug utils.

00:17:12.569 --> 00:17:15.760
You can use that to give
symbolic names to your objects.

00:17:15.760 --> 00:17:18.300
And if you've done
that, the log message

00:17:18.300 --> 00:17:20.790
will include the symbolic
name of the object

00:17:20.790 --> 00:17:24.040
as well as the handle.

00:17:24.040 --> 00:17:27.400
It tells you which draw call,
in this case, the first one.

00:17:27.400 --> 00:17:29.890
It gives you pointers
to other objects

00:17:29.890 --> 00:17:35.550
involved-- the pipeline state
object and the fragment shader.

00:17:35.550 --> 00:17:38.280
It tells you the
invocation as best it can.

00:17:38.280 --> 00:17:39.780
So in the case of
a fragment shader,

00:17:39.780 --> 00:17:42.930
it gives you the frag coord
where this error occurred.

00:17:42.930 --> 00:17:46.650
Often you can look at the scene
and see what was being drawn

00:17:46.650 --> 00:17:50.210
or infer things
about it from that.

00:17:50.210 --> 00:17:53.120
It gives you the index of
the xspirv instruction.

00:17:53.120 --> 00:17:55.400
In order to actually
use that, you

00:17:55.400 --> 00:17:58.400
have to run the spirv
disassembler or on your blob

00:17:58.400 --> 00:18:00.910
and read through
it, jump to line 116

00:18:00.910 --> 00:18:03.030
and see what was
happening there.

00:18:03.030 --> 00:18:06.570
It's not the easiest thing
in the world to figure out.

00:18:06.570 --> 00:18:09.110
Fortunately, as part
of this project,

00:18:09.110 --> 00:18:11.630
we also added debug support--

00:18:11.630 --> 00:18:16.370
that is dash g support to GL
slang, the shader compiler.

00:18:16.370 --> 00:18:20.900
So if you're in this situation
and you debug dash gs,

00:18:20.900 --> 00:18:24.440
this log message will
include the file name where

00:18:24.440 --> 00:18:26.960
your error occurred,
the line number,

00:18:26.960 --> 00:18:29.930
and it'll print out the source
line, which is way cool.

00:18:29.930 --> 00:18:31.880
It's almost like
debugging a real computer.

00:18:35.200 --> 00:18:36.460
A few things to note--

00:18:36.460 --> 00:18:38.710
there are version dependencies.

00:18:38.710 --> 00:18:40.300
There is a performance
cost that is

00:18:40.300 --> 00:18:44.500
going to perturb the time course
behavior of your application.

00:18:44.500 --> 00:18:46.150
The two most important things--

00:18:46.150 --> 00:18:48.640
it needs a free
descriptor binding slot.

00:18:48.640 --> 00:18:50.710
If you're working on
an implementation that

00:18:50.710 --> 00:18:52.900
only has a few, and
you're using them all,

00:18:52.900 --> 00:18:54.220
it's not going to work.

00:18:54.220 --> 00:18:55.780
We have a fix for
that in flight.

00:18:55.780 --> 00:18:57.370
It's not here yet.

00:18:57.370 --> 00:19:00.190
The other thing is that
currently it only checks image

00:19:00.190 --> 00:19:02.020
and texture descriptor arrays.

00:19:02.020 --> 00:19:04.900
But that's just us
driving the golden spike.

00:19:04.900 --> 00:19:08.270
Obviously, this is extensible
to all kinds of things.

00:19:08.270 --> 00:19:11.560
And in fact, we've already
landed partial support

00:19:11.560 --> 00:19:14.860
for the EXT descriptor
indexing extension-- a.k.a.

00:19:14.860 --> 00:19:15.940
Bindless.

00:19:15.940 --> 00:19:17.590
So if you were
waiting for that, you

00:19:17.590 --> 00:19:20.980
know Bindless is kind
of narsty to debug.

00:19:20.980 --> 00:19:23.690
We have a fix for you coming.

00:19:23.690 --> 00:19:25.850
So more information available.

00:19:25.850 --> 00:19:29.180
Thanks again to LunarG.

00:19:29.180 --> 00:19:33.920
So switching to my other hat.

00:19:33.920 --> 00:19:35.030
You all saw the hats.

00:19:35.030 --> 00:19:36.436
Well, I can take it off.

00:19:36.436 --> 00:19:39.770
All right.

00:19:39.770 --> 00:19:45.200
So like most GPU vendors, we
have a developer support team

00:19:45.200 --> 00:19:50.460
based in Cambridge, UK, but
with outposts around the world.

00:19:50.460 --> 00:19:56.000
And their mission is to
help you use Vulkan well,

00:19:56.000 --> 00:19:58.910
use it efficiently,
particularly on Mollie.

00:19:58.910 --> 00:20:01.910
But most of what helps on
Mollie helps everywhere.

00:20:01.910 --> 00:20:05.940
So making Vulkan great
is part of their mission.

00:20:05.940 --> 00:20:12.350
And they do that typically
first by one-to-one interactions

00:20:12.350 --> 00:20:13.100
with you.

00:20:13.100 --> 00:20:16.730
If you file a support issue
at MollieDeveloper.com,

00:20:16.730 --> 00:20:20.420
they're the guys who answer
you and work with you.

00:20:20.420 --> 00:20:21.560
That doesn't scale well.

00:20:21.560 --> 00:20:23.330
So they also do blog posts.

00:20:23.330 --> 00:20:27.290
They do sample code,
tutorials, et cetera.

00:20:27.290 --> 00:20:29.240
That scales.

00:20:29.240 --> 00:20:31.370
But it is hard to
build intuition.

00:20:31.370 --> 00:20:34.100
You have to read it over
and over and talk to people.

00:20:34.100 --> 00:20:36.030
It's kind of annoying.

00:20:36.030 --> 00:20:39.080
So in hopes of making
that situation better,

00:20:39.080 --> 00:20:41.780
what we released
at GDC this year

00:20:41.780 --> 00:20:46.640
is a toolkit we call the
Vulkan Best Practices Toolkit.

00:20:46.640 --> 00:20:50.410
This bundles
together tutorials--

00:20:50.410 --> 00:20:53.300
sorry, it's sample
code that shows you

00:20:53.300 --> 00:20:55.340
things we think
you should do, also

00:20:55.340 --> 00:20:58.040
shows you things we
think you should not do.

00:20:58.040 --> 00:21:01.100
So we have that together
with text tutorials

00:21:01.100 --> 00:21:05.600
that walk through it and
explain the whys and wherefores.

00:21:05.600 --> 00:21:09.800
But then the thing that's
new, and I think novel,

00:21:09.800 --> 00:21:12.170
is that there's also
a plug-in framework

00:21:12.170 --> 00:21:16.850
that all of these samples plug
into so that you can experiment

00:21:16.850 --> 00:21:20.870
with them, toggle the
recommended and non-recommended

00:21:20.870 --> 00:21:25.290
practices on and off, and see
how that affects performance.

00:21:25.290 --> 00:21:27.570
So if you look at
it in this case,

00:21:27.570 --> 00:21:32.570
this is a sample that looks at
load store ops at the beginning

00:21:32.570 --> 00:21:33.160
and end of--

00:21:33.160 --> 00:21:35.240
you know, what you do
with a frame buffer

00:21:35.240 --> 00:21:37.430
at the beginning and
end of a render pass.

00:21:37.430 --> 00:21:43.664
And it lets you just toggle
between different options

00:21:43.664 --> 00:21:47.820
for the depth and
the color attachment.

00:21:47.820 --> 00:21:51.800
But important to note--

00:21:51.800 --> 00:21:55.880
the scene in the background
is totally boring.

00:21:55.880 --> 00:21:57.620
Can we play that again?

00:21:57.620 --> 00:21:59.490
The scene in the
background is boring,

00:21:59.490 --> 00:22:00.830
but that's configurable.

00:22:00.830 --> 00:22:02.420
All the source code is there.

00:22:02.420 --> 00:22:03.800
You can load different scenes.

00:22:03.800 --> 00:22:05.250
You can add your own.

00:22:05.250 --> 00:22:06.680
There's a GLTF importer.

00:22:06.680 --> 00:22:08.540
You can put your
own objects in it.

00:22:08.540 --> 00:22:10.640
So you can try all
sorts of things.

00:22:10.640 --> 00:22:15.410
You can change the shaders and
see all sorts of things happen

00:22:15.410 --> 00:22:17.360
and experiment with it.

00:22:17.360 --> 00:22:19.435
Thanks.

00:22:19.435 --> 00:22:21.560
The other thing to note is
that it's multiplatform.

00:22:21.560 --> 00:22:23.420
It is not Mollie-specific.

00:22:23.420 --> 00:22:27.380
Some of the performance counters
that print out at the top

00:22:27.380 --> 00:22:28.640
are Mollie-specific.

00:22:28.640 --> 00:22:31.910
But you can run this
code on a Adreno device.

00:22:31.910 --> 00:22:35.750
And you'll see what happens
in the case of demos

00:22:35.750 --> 00:22:39.770
that have a frame rate as
their principal metric.

00:22:39.770 --> 00:22:43.310
You can see differences between
how Mollie reacts to something

00:22:43.310 --> 00:22:45.075
and how Adreno reacts to it.

00:22:45.075 --> 00:22:45.950
And that's by design.

00:22:45.950 --> 00:22:50.030
We want you to have
that information.

00:22:50.030 --> 00:22:52.190
Other things to say about this--

00:22:52.190 --> 00:22:55.540
also included in the
project are guides to using

00:22:55.540 --> 00:22:57.590
our more advanced
development tools, which

00:22:57.590 --> 00:22:59.360
I'll talk about in a minute.

00:22:59.360 --> 00:23:01.040
As I said, it's all on GitHub.

00:23:01.040 --> 00:23:02.210
It's all free.

00:23:02.210 --> 00:23:05.300
And we're working on
trying to share this code

00:23:05.300 --> 00:23:08.400
base with other GPU vendors
in the Android space

00:23:08.400 --> 00:23:12.080
so that we give you a
better basis for exploring

00:23:12.080 --> 00:23:14.990
the performance quirks
but different GPUs.

00:23:14.990 --> 00:23:16.350
And tune your code--

00:23:16.350 --> 00:23:18.470
in other words, don't
always take our advice.

00:23:18.470 --> 00:23:20.470
It might be bad on another GPU.

00:23:20.470 --> 00:23:22.220
You need to make that
trade-off, and we

00:23:22.220 --> 00:23:24.530
want you to have the
information to let you do that.

00:23:27.930 --> 00:23:29.450
So the last thing
I'll talk about

00:23:29.450 --> 00:23:32.310
is what I call the power tools.

00:23:32.310 --> 00:23:35.000
These are the tools
that our support team

00:23:35.000 --> 00:23:39.200
uses if you call in with a
problem they can't figure out.

00:23:39.200 --> 00:23:41.210
And you send them
code, and they have

00:23:41.210 --> 00:23:47.240
to sit down or sit down
next to you and explore it.

00:23:47.240 --> 00:23:48.700
There's two.

00:23:48.700 --> 00:23:50.450
Graphics analyzer is one.

00:23:50.450 --> 00:23:53.080
This used to be called
Mollie Graphics Debugger.

00:23:53.080 --> 00:23:55.070
And it used to be
Mollie-specific.

00:23:55.070 --> 00:23:57.200
It no longer is.

00:23:57.200 --> 00:24:00.440
To be quite honest, it's
very similar to Render Doc.

00:24:00.440 --> 00:24:03.270
If you're using RenderDoc
today and you like it,

00:24:03.270 --> 00:24:04.520
you may not need this.

00:24:04.520 --> 00:24:07.300
The only thing it has
that RenderDoc doesn't is

00:24:07.300 --> 00:24:09.440
it's more aware of the
performance counters

00:24:09.440 --> 00:24:11.060
that Mollie exposes.

00:24:11.060 --> 00:24:13.820
We're hoping to add that
capability to RenderDoc.

00:24:13.820 --> 00:24:15.050
So it's a good tool.

00:24:15.050 --> 00:24:17.280
We use it all the time.

00:24:17.280 --> 00:24:20.150
But it's not something
that you necessarily

00:24:20.150 --> 00:24:23.000
should go and download unless
you're working with Mollie

00:24:23.000 --> 00:24:25.840
a lot and having trouble.

00:24:25.840 --> 00:24:28.960
The tool I do recommend
that everybody check out

00:24:28.960 --> 00:24:30.610
is Streamline.

00:24:30.610 --> 00:24:37.960
This is the total ARM
ecosystem performance analyzer,

00:24:37.960 --> 00:24:41.590
which gives you sort of
sys trace like traces

00:24:41.590 --> 00:24:45.180
of what's happening on all
the CPU cores, processes, et

00:24:45.180 --> 00:24:45.880
cetera.

00:24:45.880 --> 00:24:49.810
It also does that for all
the GPU cores if it's Mollie.

00:24:49.810 --> 00:24:54.010
And it also allows your code
to inject events and put

00:24:54.010 --> 00:24:57.820
little flags into the code so
you know exactly where to look.

00:24:57.820 --> 00:25:00.410
It's really quite awesome.

00:25:00.410 --> 00:25:02.830
There were two things
about these two tools

00:25:02.830 --> 00:25:05.930
that used to really
bother game developers

00:25:05.930 --> 00:25:08.100
and that kept a lot of
people from using them.

00:25:08.100 --> 00:25:10.690
And they kept telling
us, we can't use it.

00:25:10.690 --> 00:25:13.570
Those things were--
it cost money,

00:25:13.570 --> 00:25:17.200
and you had to route the
phone you were running on

00:25:17.200 --> 00:25:20.140
in order to have access to
the performance counters.

00:25:20.140 --> 00:25:26.830
So I'm very pleased to
say as of GDC-ish, there's

00:25:26.830 --> 00:25:29.650
now a starter edition,
which is free.

00:25:29.650 --> 00:25:32.920
So you can try it, kick the
tires, see how you like it.

00:25:35.490 --> 00:25:38.450
And the other thing,
with some caveats--

00:25:38.450 --> 00:25:40.760
you no longer have
to route the device.

00:25:40.760 --> 00:25:43.070
That is assuming that
the device is written

00:25:43.070 --> 00:25:44.810
according to our guidelines.

00:25:44.810 --> 00:25:48.050
We're working with our partners
to get them to do that.

00:25:48.050 --> 00:25:50.240
Some are quick to do it.

00:25:50.240 --> 00:25:51.950
Some are slower.

00:25:51.950 --> 00:25:54.920
If you have companies
like Samsung

00:25:54.920 --> 00:25:57.560
that are very dedicated to
providing a good developer

00:25:57.560 --> 00:26:01.260
experience, they are
very quick to adopt.

00:26:01.260 --> 00:26:02.950
So S9 is supported.

00:26:02.950 --> 00:26:06.180
S10 will be supported
in about two months.

00:26:06.180 --> 00:26:08.810
There are some things we
have to fix on our side that

00:26:08.810 --> 00:26:10.650
are keeping it from working.

00:26:10.650 --> 00:26:11.720
We have a list online.

00:26:11.720 --> 00:26:15.510
You can go and see what's there.

00:26:15.510 --> 00:26:19.220
So there's links, which I
hope you can find online.

00:26:19.220 --> 00:26:22.350
And with that, I'll turn
it over to Jung-woo,

00:26:22.350 --> 00:26:26.150
my good buddy from Samsung.

00:26:26.150 --> 00:26:27.140
Sorry, man.

00:26:32.585 --> 00:26:35.300
JUNG-WOO KIM: Thank you, Tom.

00:26:35.300 --> 00:26:37.150
Hi.

00:26:37.150 --> 00:26:41.520
I'm Jung-woo Kim, leading GPU
and game dev at Samsung Mobile.

00:26:41.520 --> 00:26:44.650
I will share a book on
optimism and practices

00:26:44.650 --> 00:26:47.130
from our partner collaboration.

00:26:47.130 --> 00:26:50.480
Before jumping to that, I hope
to give you some introduction

00:26:50.480 --> 00:26:52.030
first.

00:26:52.030 --> 00:26:54.460
The game is so
important for Samsung

00:26:54.460 --> 00:26:57.340
because what we
really care is not

00:26:57.340 --> 00:27:00.190
just device, but also
use experience that

00:27:00.190 --> 00:27:01.780
comes from the device.

00:27:01.780 --> 00:27:04.775
The high def game is one of
the most serious and hardest

00:27:04.775 --> 00:27:07.690
to achieve user
experience on mobile.

00:27:07.690 --> 00:27:12.450
Because in mobile, everything
is limited by form factor.

00:27:12.450 --> 00:27:14.190
The fundamental
performance difference

00:27:14.190 --> 00:27:16.885
between PC and mobile
is come from different

00:27:16.885 --> 00:27:21.460
of the thumbnail design, power
budget, and battery capacity

00:27:21.460 --> 00:27:24.250
within this form
factor limitation.

00:27:24.250 --> 00:27:27.280
And even we keep chasing
peak performance.

00:27:27.280 --> 00:27:31.070
It is not something you can
keep using for sustainable

00:27:31.070 --> 00:27:33.940
workers like gaming.

00:27:33.940 --> 00:27:36.910
Because of this, optimization
is so important in mobile

00:27:36.910 --> 00:27:39.740
than any other area.

00:27:39.740 --> 00:27:43.010
Not for the trade
optimization between quality

00:27:43.010 --> 00:27:45.500
and performance, but for
the real optimization

00:27:45.500 --> 00:27:48.880
for great performance
within even higher fidelity.

00:27:48.880 --> 00:27:52.850
The new technology to break
through the fundamental problem

00:27:52.850 --> 00:27:56.300
are essential, like Vulkan
64-bit multi-thread rendering

00:27:56.300 --> 00:27:58.340
are those.

00:27:58.340 --> 00:28:01.490
We believe Vulkan is the
most demand a new technology

00:28:01.490 --> 00:28:02.870
to achieve this.

00:28:02.870 --> 00:28:07.390
So we're heavily focused on
Vulkan for recent four years.

00:28:07.390 --> 00:28:09.130
To accelerate
adoption of Vulkan,

00:28:09.130 --> 00:28:13.060
we realize that making many
best practices with real market

00:28:13.060 --> 00:28:14.590
games are required.

00:28:14.590 --> 00:28:16.360
But game developers
are always busy.

00:28:16.360 --> 00:28:20.140
So we are announced the
Galaxy GameDev at 2016,

00:28:20.140 --> 00:28:22.790
Samsung new game
developer support for web,

00:28:22.790 --> 00:28:27.400
and helping Android game
ecosystem with adoption

00:28:27.400 --> 00:28:29.780
of new technologies.

00:28:29.780 --> 00:28:31.060
These are our key partners.

00:28:31.060 --> 00:28:36.160
And you can see both big players
and also the indie developers.

00:28:36.160 --> 00:28:39.190
You can see both the
unity and UE4 developers

00:28:39.190 --> 00:28:40.000
at the same time.

00:28:40.000 --> 00:28:42.280
The multiple in-house game
engine developers too.

00:28:47.030 --> 00:28:50.150
They were taking the risk
of bringing new technology

00:28:50.150 --> 00:28:52.490
into their game development
and always aiming

00:28:52.490 --> 00:28:56.180
a higher goal and
quality and performance.

00:28:56.180 --> 00:28:58.070
I want to say thank
you to all partners

00:28:58.070 --> 00:29:02.510
to give us a great
chance to work with them.

00:29:02.510 --> 00:29:05.050
The game that team
has around the 30 game

00:29:05.050 --> 00:29:07.510
dev engineers from five
different locations.

00:29:07.510 --> 00:29:11.650
They work hard, sometimes
on-site the partner developers

00:29:11.650 --> 00:29:16.010
studio, sometimes also remote
support at their offices.

00:29:16.010 --> 00:29:19.720
And also hope to say thank
you to the team for your

00:29:19.720 --> 00:29:22.720
all contribution to show
bright future of Android gaming

00:29:22.720 --> 00:29:25.570
ecosystem.

00:29:25.570 --> 00:29:27.670
During a collaboration
with the game developers,

00:29:27.670 --> 00:29:29.080
we learned a lot.

00:29:29.080 --> 00:29:33.580
There are four key areas of
game optimization we think--

00:29:33.580 --> 00:29:36.150
about tools and
SDK, Google and GPU

00:29:36.150 --> 00:29:40.440
vendor like [INAUDIBLE],, as
Francesco and Tom already

00:29:40.440 --> 00:29:41.720
mentioned.

00:29:41.720 --> 00:29:45.040
So now I focus more
on the other areas.

00:29:45.040 --> 00:29:48.100
GPU driver, the game engine,
and developer support--

00:29:48.100 --> 00:29:52.450
all these three are not perfect
at this moment in Android.

00:29:52.450 --> 00:29:54.860
That's true.

00:29:54.860 --> 00:29:57.670
The first, GPU driver--
the quality and performance

00:29:57.670 --> 00:30:02.020
both are two main requirements
from Android game developers.

00:30:02.020 --> 00:30:05.410
We are working tightly with
the GPU vendor [INAUDIBLE]

00:30:05.410 --> 00:30:07.460
for optimizing GPU driver.

00:30:07.460 --> 00:30:10.270
This is the graph of the
GPU frame time of heavy GPU

00:30:10.270 --> 00:30:12.220
seen in "Fortnite."

00:30:12.220 --> 00:30:16.420
It took around 29
milliseconds in March.

00:30:16.420 --> 00:30:19.030
But now it reduced
to 22 milliseconds

00:30:19.030 --> 00:30:22.210
in November with
the same model GPU.

00:30:22.210 --> 00:30:26.140
Average frame gain is around 5%,
just with the driver software

00:30:26.140 --> 00:30:29.160
optimization.

00:30:29.160 --> 00:30:31.950
Improving quality of a GPU
driver takes a longer time.

00:30:31.950 --> 00:30:35.590
So for accelerating
the process of this

00:30:35.590 --> 00:30:38.740
we are working with Google to
enhance the updatability of GPU

00:30:38.740 --> 00:30:40.620
driver in Android.

00:30:40.620 --> 00:30:43.890
This will bring better way of
updating GPU driver by play

00:30:43.890 --> 00:30:46.980
installation, and hope to
ship this feature as soon

00:30:46.980 --> 00:30:52.730
as possible to help both game
developers and also end users.

00:30:52.730 --> 00:30:57.050
Even with better quality and
performance of GPU driver,

00:30:57.050 --> 00:30:59.270
game engine is also
one of the big area

00:30:59.270 --> 00:31:03.175
to make Vulkan support well
for the real game development.

00:31:03.175 --> 00:31:05.300
Unity has something great
to support all the Vulkan

00:31:05.300 --> 00:31:09.410
community developers at 2017,
and now multiple Unity games

00:31:09.410 --> 00:31:15.240
support Vulkan and show
real performance benefit.

00:31:15.240 --> 00:31:18.600
"Final Fantasy XV Pocket
Edition" is one of those.

00:31:18.600 --> 00:31:23.160
We had a forum on on-site camp
at Okinawa for the screenings

00:31:23.160 --> 00:31:24.640
and Summertime Studio.

00:31:24.640 --> 00:31:28.650
We did many Vulkan optimization
on Unity pending render.

00:31:28.650 --> 00:31:32.130
And finally we got 42 to the 60
frames per second performance

00:31:32.130 --> 00:31:33.700
gain.

00:31:33.700 --> 00:31:36.730
One of the main
optimization we made

00:31:36.730 --> 00:31:39.730
was about pipeline barriers.

00:31:39.730 --> 00:31:43.350
Let's talk more about
the pipeline barriers.

00:31:43.350 --> 00:31:46.350
We pick up the heavy
vertex job example

00:31:46.350 --> 00:31:49.830
to show impact level using
wrong pipeline barrier setting.

00:31:49.830 --> 00:31:53.790
This Vulkan sample is
showing the serialized vertex

00:31:53.790 --> 00:31:57.810
and fragment job during GPU
processing with DS5 streamline

00:31:57.810 --> 00:31:58.750
capture.

00:31:58.750 --> 00:32:00.560
So performance is
not that good--

00:32:00.560 --> 00:32:04.640
62 milliseconds GPU frame time.

00:32:04.640 --> 00:32:07.750
A pipeline barrier created
an execution dependency

00:32:07.750 --> 00:32:10.040
between the two
active pipelines.

00:32:10.040 --> 00:32:11.760
Execution of the
current round path

00:32:11.760 --> 00:32:14.230
will wait at the
destination stage

00:32:14.230 --> 00:32:16.840
until the execution of
the former random pass

00:32:16.840 --> 00:32:21.050
has completed its source stage.

00:32:21.050 --> 00:32:26.030
And considering the narrow
down to the two render passes--

00:32:26.030 --> 00:32:30.080
example, shadow and main,
with the Naive Case main

00:32:30.080 --> 00:32:33.800
always wait until completion
of all pipeline stages

00:32:33.800 --> 00:32:36.020
in the shadow render path.

00:32:36.020 --> 00:32:39.590
All [INAUDIBLE] fragment
job are not fully paralyzed.

00:32:39.590 --> 00:32:45.740
And those two random cases
came at 28 milliseconds.

00:32:45.740 --> 00:32:50.680
If we consider pipeline barriers
set more optimal in this case,

00:32:50.680 --> 00:32:53.910
we can set beginning
of the fragment stage

00:32:53.910 --> 00:32:56.400
for the main render
path just need

00:32:56.400 --> 00:33:00.876
to wait until the completion
of the shadow round pass.

00:33:06.940 --> 00:33:09.260
After changing
pipeline barriers set,

00:33:09.260 --> 00:33:11.410
you can see shadow
and main render

00:33:11.410 --> 00:33:13.810
pass are in the [INAUDIBLE].

00:33:13.810 --> 00:33:16.090
And those two render
passes take last time

00:33:16.090 --> 00:33:19.520
now-- the 22 millisecond.

00:33:19.520 --> 00:33:23.750
We can optimize all render
passes of this simple

00:33:23.750 --> 00:33:26.360
with same manner and
see overall frame

00:33:26.360 --> 00:33:29.060
time reduced from
the 62-millisecond

00:33:29.060 --> 00:33:32.030
to the 40-millisecond.

00:33:32.030 --> 00:33:36.480
Same work load,
but take less time.

00:33:36.480 --> 00:33:40.040
We also supported the
Tencent Timi Studio-L1

00:33:40.040 --> 00:33:41.910
for "Honor of Kings."

00:33:41.910 --> 00:33:45.055
Vulkan have a lot to improve
the performance of "Honor

00:33:45.055 --> 00:33:46.050
of Kings."

00:33:46.050 --> 00:33:51.090
And even with the S7 it showed
a big performance gain like a 41

00:33:51.090 --> 00:33:54.240
to the 53 frames per second.

00:33:54.240 --> 00:33:56.800
Another optimization
we made is uploading

00:33:56.800 --> 00:34:00.210
unnecessary
load/store operation.

00:34:00.210 --> 00:34:03.630
Each attachment of render
pass has a set operation

00:34:03.630 --> 00:34:05.640
for load and store.

00:34:05.640 --> 00:34:08.850
This should be carefully managed
to avoid unnecessary overhead

00:34:08.850 --> 00:34:13.320
to road and store the attachment
between the ownership memory

00:34:13.320 --> 00:34:16.290
and host memory.

00:34:16.290 --> 00:34:20.340
"Hundred Soul" by Hound 13 also
gets a noticeable performance

00:34:20.340 --> 00:34:22.820
gain by Vulkan.

00:34:22.820 --> 00:34:25.889
And the render pass road
store optimization also

00:34:25.889 --> 00:34:28.020
has a lot in this case too.

00:34:30.739 --> 00:34:34.290
You all know Samsung and Epic
Games have a good relationship.

00:34:34.290 --> 00:34:37.610
We worked together
developing Protestor demo,

00:34:37.610 --> 00:34:40.909
and made the same agreement
to support only Vulkan UE4

00:34:40.909 --> 00:34:43.860
developers too.

00:34:43.860 --> 00:34:46.230
So we did many contributions
to you for Vulkan.

00:34:46.230 --> 00:34:48.870
One of the recent
UE4 bay collaboration

00:34:48.870 --> 00:34:52.530
was that Tencent
game for PUBG Mobile.

00:34:52.530 --> 00:34:57.730
And we did many works about
update descriptor set.

00:34:57.730 --> 00:35:02.080
Let's talk about
descriptor set more.

00:35:05.140 --> 00:35:08.410
In GL, the process of
setting uniform data

00:35:08.410 --> 00:35:10.570
is simple and readable.

00:35:10.570 --> 00:35:14.240
But how about Vulkan case?

00:35:14.240 --> 00:35:16.580
First, we define
how many descriptor

00:35:16.580 --> 00:35:19.940
sets descriptor type is
needed on the pipeline

00:35:19.940 --> 00:35:25.810
stage and allocated descriptor
set with that information.

00:35:25.810 --> 00:35:28.630
After this it should prepare
information of uniform

00:35:28.630 --> 00:35:32.350
buffer an image in the
WriteDescriptorSet structure.

00:35:32.350 --> 00:35:36.320
And here we need allocated
VkBuffer for uniform data.

00:35:36.320 --> 00:35:38.440
Now we can update
this script to set

00:35:38.440 --> 00:35:41.830
with the calling Vk
allocate descriptor set,

00:35:41.830 --> 00:35:44.380
and find the
descriptor set, finally

00:35:44.380 --> 00:35:47.470
we can use the data or
image on the pipeline.

00:35:47.470 --> 00:35:50.140
It's so complicated.

00:35:50.140 --> 00:35:51.490
But let's forget about it.

00:35:51.490 --> 00:35:54.460
Please just remember we
need to allocate buffer

00:35:54.460 --> 00:35:58.360
and call Vk descriptor set.

00:35:58.360 --> 00:36:01.570
In ideal case we should have
the static object and view

00:36:01.570 --> 00:36:02.080
direction.

00:36:02.080 --> 00:36:05.590
We can allocate a Vk buffer
once and update it for the set

00:36:05.590 --> 00:36:09.100
initially and just
reuse them everlasting.

00:36:09.100 --> 00:36:13.600
But in real cases, things are
more that dynamic we cannot

00:36:13.600 --> 00:36:18.550
predict which object and
are generated or destroyed.

00:36:18.550 --> 00:36:21.580
And so whenever the objects
are created or destroyed,

00:36:21.580 --> 00:36:26.210
we need to allocate or
release the buffer every time.

00:36:26.210 --> 00:36:30.250
And this will cause a
huge overhead in CPU.

00:36:30.250 --> 00:36:33.550
Solution is allocating
a huge buffer

00:36:33.550 --> 00:36:36.190
and using offset on
the buffer information

00:36:36.190 --> 00:36:41.500
structure in the sketch, we can
abort the frequent allocation

00:36:41.500 --> 00:36:42.235
of the VkBuffer.

00:36:45.640 --> 00:36:47.620
But because of buffer
information structure

00:36:47.620 --> 00:36:50.520
is a part of the Vk
WriteDescriptorSet,

00:36:50.520 --> 00:36:56.620
so we still need to call vk
UpdateDescriptorSet every time

00:36:56.620 --> 00:37:00.900
before binding a
descriptive set.

00:37:00.900 --> 00:37:03.720
Better solution for avoiding
overhead of a calling update

00:37:03.720 --> 00:37:06.870
DescriptorSets every time
is using dynamic offset

00:37:06.870 --> 00:37:10.980
when binding DescriptorSet.

00:37:10.980 --> 00:37:15.530
In this case, dynamic offset
when binding this could set.

00:37:15.530 --> 00:37:16.950
I'm not-- sorry.

00:37:16.950 --> 00:37:20.550
In this case, we can
set the offset value

00:37:20.550 --> 00:37:23.310
on the buffer information
as 0, and we just

00:37:23.310 --> 00:37:26.280
deliver the offset
information with a dynamic

00:37:26.280 --> 00:37:29.460
offset in the vkCmdBind
descriptor set.

00:37:33.050 --> 00:37:37.520
With summary, this optimization
is a multi CPU site uploading.

00:37:37.520 --> 00:37:41.810
We could manage VK
buffer by using Offset.

00:37:41.810 --> 00:37:45.080
We also could manage
VkUpdateDescriptor set

00:37:45.080 --> 00:37:48.830
caused by using dynamic offset.

00:37:48.830 --> 00:37:52.340
With this Vulkan
sample using offset

00:37:52.340 --> 00:37:55.540
case that shows about 90
frames per second with--

00:37:55.540 --> 00:37:57.380
and still CPU bounded--

00:37:57.380 --> 00:38:01.760
using dynamic offset case
show the 24 frames per second.

00:38:01.760 --> 00:38:07.850
And now less if you bound
it, but more GPU working.

00:38:07.850 --> 00:38:12.680
Android systrace show
the 25-millisecond taking

00:38:12.680 --> 00:38:17.120
a VkUpdateDescriptor
set is gone.

00:38:17.120 --> 00:38:19.540
After dynamic
offset optimization,

00:38:19.540 --> 00:38:24.590
uploading CPU have the
GPU work better and more.

00:38:24.590 --> 00:38:28.330
Traha is a very recent work with
an accent in worldwide games.

00:38:28.330 --> 00:38:32.170
And update disk is the set
optimization have a lot too.

00:38:32.170 --> 00:38:35.890
And this gave a 35 to
the 56-frames per second

00:38:35.890 --> 00:38:38.720
gained by overall Vulkan
optimization with it.

00:38:41.280 --> 00:38:44.550
Galaxy GameDev supports
the game developers

00:38:44.550 --> 00:38:47.430
who want to develop Hi-fi
for the Android games.

00:38:47.430 --> 00:38:51.000
We support optimization
in games and GPU driver

00:38:51.000 --> 00:38:54.060
for better Vulkan support
in Galaxy devices.

00:38:54.060 --> 00:39:00.680
But from this, all we found goes
to the GPU vendor and the game

00:39:00.680 --> 00:39:05.020
engine companies for
wider distribution.

00:39:05.020 --> 00:39:12.560
We are also contributing to the
Android with Google and Vulkan

00:39:12.560 --> 00:39:17.960
working group within
cronies our final goal is

00:39:17.960 --> 00:39:22.060
improving overall Android
gaming ecosystem better.

00:39:22.060 --> 00:39:23.530
Thank you.

00:39:23.530 --> 00:39:25.030
[APPLAUSE]

00:39:25.030 --> 00:39:28.380
[MUSIC PLAYING]

