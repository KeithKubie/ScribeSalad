WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:12.302
[MUSIC PLAYING]

00:00:12.302 --> 00:00:14.260
NAVNEET JONEJA: Thank
you for joining us today.

00:00:14.260 --> 00:00:16.379
My name does is Navneet Joneja.

00:00:16.379 --> 00:00:19.020
I lead product management for
App Engine and Compute Engine

00:00:19.020 --> 00:00:20.170
at Google.

00:00:20.170 --> 00:00:24.310
And today, we're here to share
how Google builds applications,

00:00:24.310 --> 00:00:27.320
what that means in terms of
the capabilities we provide

00:00:27.320 --> 00:00:29.970
to our customers in
the Cloud Platform,

00:00:29.970 --> 00:00:32.470
and finally, what that means
in terms of the benefits

00:00:32.470 --> 00:00:36.545
you can get from our
platform as a user.

00:00:36.545 --> 00:00:38.170
So what you see on
the screen right now

00:00:38.170 --> 00:00:40.490
is, literally, a page
from our history.

00:00:40.490 --> 00:00:43.910
It's the first infrastructure
build we received as Google.

00:00:43.910 --> 00:00:46.810
Now back in the day,
building applications

00:00:46.810 --> 00:00:50.510
started with buying, what
was back then very expensive,

00:00:50.510 --> 00:00:53.330
hardware and deploying
it and managing it.

00:00:53.330 --> 00:00:56.320
And quite frankly, the
tools available to do that

00:00:56.320 --> 00:00:57.334
were quite terrible.

00:00:57.334 --> 00:00:58.750
And we didn't think
we could build

00:00:58.750 --> 00:01:01.210
the company we wanted to
build with the technology that

00:01:01.210 --> 00:01:02.260
existed back in the day.

00:01:04.849 --> 00:01:08.060
For example, the
conventional wisdom back then

00:01:08.060 --> 00:01:11.940
was that in order to
build a very highly

00:01:11.940 --> 00:01:13.630
reliable application,
you started

00:01:13.630 --> 00:01:16.062
with the most reliable
hardware you could find.

00:01:16.062 --> 00:01:18.270
So let's say you start with
a piece of hardware which

00:01:18.270 --> 00:01:21.450
has a mean time between
failure of 10 years.

00:01:21.450 --> 00:01:23.240
That means you
expect, on average,

00:01:23.240 --> 00:01:26.060
that device will fail
once every 10 years.

00:01:26.060 --> 00:01:28.230
Now you take 100,000
of those devices,

00:01:28.230 --> 00:01:30.180
and you put them
in a data center.

00:01:30.180 --> 00:01:31.730
The system you've
just built actually

00:01:31.730 --> 00:01:34.520
has a mean time between
failure of one hour.

00:01:34.520 --> 00:01:38.810
In other words, you can expect
that on average, every hour,

00:01:38.810 --> 00:01:41.520
something in that
system is failing.

00:01:41.520 --> 00:01:44.190
So no matter how reliable
your hard way is,

00:01:44.190 --> 00:01:47.070
hardware is not the path
to reliable applications.

00:01:47.070 --> 00:01:48.780
It's really software.

00:01:48.780 --> 00:01:51.090
But that was only
half of the picture.

00:01:51.090 --> 00:01:53.677
It turns out that even though
hardware and infrastructure was

00:01:53.677 --> 00:01:56.010
really expensive back then,
and has gotten a lot cheaper

00:01:56.010 --> 00:01:56.980
over time.

00:01:56.980 --> 00:02:00.300
Even then, the scarce
resource was not actually

00:02:00.300 --> 00:02:02.990
compute resources,
it was our people.

00:02:02.990 --> 00:02:06.180
And specifically, the time
and energy of our engineers

00:02:06.180 --> 00:02:09.729
who were building and operating,
and keeping Google reliable.

00:02:09.729 --> 00:02:12.050
And so the more time
they had to spend

00:02:12.050 --> 00:02:14.570
on deploying applications and
building servers, and keeping

00:02:14.570 --> 00:02:16.330
them up and running,
the less time they

00:02:16.330 --> 00:02:18.630
had to spend on building Google.

00:02:18.630 --> 00:02:22.250
And so in order to
maximize Google's growth,

00:02:22.250 --> 00:02:24.500
we had to maximize the
growth and productivity

00:02:24.500 --> 00:02:25.590
of our engineers.

00:02:25.590 --> 00:02:29.550
And so we had to make the
most of that scarce resource.

00:02:29.550 --> 00:02:30.600
So what was our solution?

00:02:30.600 --> 00:02:32.020
Well really, three things.

00:02:32.020 --> 00:02:35.410
The first thing was, instead
of reacting to failure--

00:02:35.410 --> 00:02:36.900
we knew we had to
plan for failure,

00:02:36.900 --> 00:02:39.817
we knew we had to expect
that things would fail,

00:02:39.817 --> 00:02:41.400
and we had to build
systems that could

00:02:41.400 --> 00:02:43.445
handle failure transparently.

00:02:43.445 --> 00:02:45.570
The second thing was to
take everything we learned,

00:02:45.570 --> 00:02:49.040
and we learned a lot, because
we made mistakes a lot,

00:02:49.040 --> 00:02:51.190
and encode that into
everything we built.

00:02:51.190 --> 00:02:53.400
So those software
and platforms that

00:02:53.400 --> 00:02:55.790
took the best that we'd
learned in building operating

00:02:55.790 --> 00:02:58.700
Google at scale, and make that
available to all our engineers

00:02:58.700 --> 00:03:00.070
as a force multiplier.

00:03:00.070 --> 00:03:03.190
Because every time they
use this proven technology,

00:03:03.190 --> 00:03:05.700
they were benefiting from
all the accumulated learning

00:03:05.700 --> 00:03:07.870
of the engineers who'd
come before them.

00:03:07.870 --> 00:03:09.770
And then finally, to
make all this happen,

00:03:09.770 --> 00:03:13.540
we had to make investments
at all layers of the stack.

00:03:13.540 --> 00:03:16.350
Starting with the design
of our data centers.

00:03:16.350 --> 00:03:19.049
And all the way up to a high
level platforms and software

00:03:19.049 --> 00:03:20.965
that many engineers use
to build applications.

00:03:23.620 --> 00:03:25.300
Now, we had to do
all this ourselves

00:03:25.300 --> 00:03:28.670
because back then, these
tools didn't exist, right?

00:03:28.670 --> 00:03:30.260
We have to just
build from scratch.

00:03:30.260 --> 00:03:32.676
We had to figure out what
worked and build these platforms

00:03:32.676 --> 00:03:33.380
for our own use.

00:03:33.380 --> 00:03:35.920
And along the way, we wrote
white papers about many

00:03:35.920 --> 00:03:36.670
of these subjects.

00:03:36.670 --> 00:03:38.830
We talked about MapReduce, we
talked about the Google File

00:03:38.830 --> 00:03:40.260
System, we talked about Dremel.

00:03:40.260 --> 00:03:42.327
Many pieces of core
technology we were building,

00:03:42.327 --> 00:03:44.660
in terms of software and the
platforms we were building,

00:03:44.660 --> 00:03:46.820
we actually talked about
in terms-- very publicly--

00:03:46.820 --> 00:03:48.960
in terms of the white
papers we wrote.

00:03:48.960 --> 00:03:50.690
But that is only half
the picture, right?

00:03:50.690 --> 00:03:53.012
Half of what we learned
wasn't just the patterns,

00:03:53.012 --> 00:03:55.470
the software, the technology
that was going to work for us.

00:03:55.470 --> 00:03:57.297
It was also how we
operate those things

00:03:57.297 --> 00:03:59.630
at scale, how we make sure
that those things work really

00:03:59.630 --> 00:04:02.150
well when they're
being, when they're

00:04:02.150 --> 00:04:03.810
serving large
amounts of traffic.

00:04:03.810 --> 00:04:06.580
And if you want to get
the most of the benefit

00:04:06.580 --> 00:04:08.990
of our experience, the
best way to do that

00:04:08.990 --> 00:04:11.820
is to use the Google
Cloud platform.

00:04:11.820 --> 00:04:14.070
So to talk more about
specifically what we learned,

00:04:14.070 --> 00:04:16.120
some of the patterns we
think work really well.

00:04:16.120 --> 00:04:18.440
And how we really build
applications at Google.

00:04:18.440 --> 00:04:21.690
I'd like to invite Joe
Beda, one of our architects,

00:04:21.690 --> 00:04:22.870
to the Cloud platform.

00:04:22.870 --> 00:04:23.370
Joe?

00:04:28.787 --> 00:04:29.870
JOE BEDA: Thanks, Navneet.

00:04:29.870 --> 00:04:31.880
And that was
actually me up their.

00:04:31.880 --> 00:04:36.640
Navneet stole that picture and
kind of surprised me with that.

00:04:36.640 --> 00:04:40.594
So I want to give you a
little bit of an idea of what

00:04:40.594 --> 00:04:42.010
it's like to be a
Google engineer.

00:04:42.010 --> 00:04:43.760
What your first
week at Google looks

00:04:43.760 --> 00:04:46.130
like as you start
learning about what has,

00:04:46.130 --> 00:04:50.349
sort of, evolved as the
internal Google platform.

00:04:50.349 --> 00:04:51.890
And one of the things
to realize here

00:04:51.890 --> 00:04:55.400
is that the Google
Cloud Platform really

00:04:55.400 --> 00:04:57.100
is the internal
Google Cloud Platform.

00:04:57.100 --> 00:04:58.910
We're exposing the
exact same tools

00:04:58.910 --> 00:05:01.740
that we use internally
to you to use.

00:05:01.740 --> 00:05:04.310
And we're continuing to expose
more and more of those tools.

00:05:04.310 --> 00:05:07.089
So you're going to see
more coming from the Cloud

00:05:07.089 --> 00:05:08.380
platform in the months to come.

00:05:12.360 --> 00:05:14.830
So when we-- I mean
so the-- you know,

00:05:14.830 --> 00:05:16.360
we view these
things as a toolbox

00:05:16.360 --> 00:05:18.780
as sort of flexible tools
that you can bring to bear.

00:05:18.780 --> 00:05:21.010
And we're breaking
those things down along

00:05:21.010 --> 00:05:25.540
for the purposes of this
talk around compute, storage,

00:05:25.540 --> 00:05:27.650
networking, and then
sort of services and glue

00:05:27.650 --> 00:05:30.199
that really bind all
of this stuff together.

00:05:30.199 --> 00:05:31.740
And one of the things
to keep in mind

00:05:31.740 --> 00:05:34.980
is that you can use these
tools and these building blocks

00:05:34.980 --> 00:05:36.550
in a whole bunch
of different ways.

00:05:36.550 --> 00:05:38.990
So you can use them in
well understood patterns,

00:05:38.990 --> 00:05:39.970
like we do at Google.

00:05:39.970 --> 00:05:41.250
Things like MapReduce.

00:05:41.250 --> 00:05:43.760
Or the way that we'll
build a tree of services

00:05:43.760 --> 00:05:45.880
to actually do a query,
where you start at a route

00:05:45.880 --> 00:05:48.089
and it distributes the
query, collects the results,

00:05:48.089 --> 00:05:49.380
and then distills that back up.

00:05:49.380 --> 00:05:51.840
Very common architectural
pattern at Google.

00:05:51.840 --> 00:05:54.180
But if those things don't
work for you, if those well

00:05:54.180 --> 00:05:55.870
understood and
proven patterns, you

00:05:55.870 --> 00:05:58.050
can go off and build
your own solutions

00:05:58.050 --> 00:05:59.520
using your own architecture.

00:05:59.520 --> 00:06:01.435
And so this flexibility
of Building Blocks,

00:06:01.435 --> 00:06:03.810
which has really made our
platform stand the test of time

00:06:03.810 --> 00:06:07.170
as Google has grown and moved
from doing things like Search

00:06:07.170 --> 00:06:08.900
to doing things
like Gmail and Apps.

00:06:12.480 --> 00:06:14.190
Now let's dive into
Compute a little bit.

00:06:14.190 --> 00:06:17.900
When we look at Compute, one
of the things that Google tries

00:06:17.900 --> 00:06:21.040
very hard, and sort of is
necessary for us to do,

00:06:21.040 --> 00:06:23.580
is to really avoid snowflakes.

00:06:23.580 --> 00:06:26.865
And so the idea of a
snowflake is, so you know,

00:06:26.865 --> 00:06:28.230
you want to deploy a service.

00:06:28.230 --> 00:06:30.760
So you get a server, you log
in, you install some stuff,

00:06:30.760 --> 00:06:32.980
you install your application.

00:06:32.980 --> 00:06:33.480
You're done.

00:06:33.480 --> 00:06:34.780
Woohoo.

00:06:34.780 --> 00:06:37.314
Invoice your customer,
you're done, right?

00:06:37.314 --> 00:06:39.480
But now, let's say that you
have to do 100 of those.

00:06:39.480 --> 00:06:41.100
Or now let's say that
it's a big application,

00:06:41.100 --> 00:06:42.600
you need to scale
that thing out.

00:06:42.600 --> 00:06:44.860
Well that's where
things get complicated.

00:06:44.860 --> 00:06:47.740
And if you do that all
by hand you'll find,

00:06:47.740 --> 00:06:50.410
oh server number 2 is always a
little bit flakey, let me go in

00:06:50.410 --> 00:06:51.920
and fix that guy.

00:06:51.920 --> 00:06:53.390
So that's a snowflake.

00:06:53.390 --> 00:06:55.760
That's a unique server that
has its own unique problems

00:06:55.760 --> 00:06:57.310
that you have to deal with.

00:06:57.310 --> 00:07:00.380
We've built a ton of
tools and techniques

00:07:00.380 --> 00:07:03.490
to be able to manage
things at scale automation,

00:07:03.490 --> 00:07:05.800
so that we actually
avoid the situation where

00:07:05.800 --> 00:07:07.530
you have these special cases.

00:07:07.530 --> 00:07:10.360
And this applies not only
at the infrastructure level,

00:07:10.360 --> 00:07:13.099
at making sure that the
individual servers are managed

00:07:13.099 --> 00:07:14.640
and as identical as
we can make them.

00:07:14.640 --> 00:07:17.140
But also works up the stack
in terms of the software

00:07:17.140 --> 00:07:19.080
that we're deploying
onto these things

00:07:19.080 --> 00:07:22.170
and at the application level.

00:07:22.170 --> 00:07:23.650
So concretely, what
does this mean?

00:07:23.650 --> 00:07:25.108
Well, it breaks
down to two things.

00:07:25.108 --> 00:07:26.860
So the first is
declarative management.

00:07:26.860 --> 00:07:29.450
The idea here is that you
tell the system what you want.

00:07:29.450 --> 00:07:31.980
And then you let the system
take care of that for you.

00:07:31.980 --> 00:07:34.052
And when you deploy
and app to app engine,

00:07:34.052 --> 00:07:35.510
that's exactly what
you're getting.

00:07:35.510 --> 00:07:38.290
So that's an embodiment
of that technique.

00:07:38.290 --> 00:07:41.720
This builds on top of this
idea of idempotency, which

00:07:41.720 --> 00:07:44.200
means that if you do the same
thing over and over again,

00:07:44.200 --> 00:07:46.819
you get the same result and
you're actually not moving

00:07:46.819 --> 00:07:47.610
the system forward.

00:07:47.610 --> 00:07:51.590
It's a key principle for being
able to deal with failures

00:07:51.590 --> 00:07:54.160
because if something fails,
well you just try it again.

00:07:54.160 --> 00:07:56.810
And then things will work.

00:07:56.810 --> 00:08:00.216
Or you won't make the
system any worse, at least.

00:08:00.216 --> 00:08:01.590
And then building
on top of this,

00:08:01.590 --> 00:08:03.440
you have reproduceable
deployment.

00:08:03.440 --> 00:08:06.310
So this is the idea that if
you're deploying an application

00:08:06.310 --> 00:08:08.477
into your
infrastructure, you want

00:08:08.477 --> 00:08:10.310
to make sure that you
can repeat that again,

00:08:10.310 --> 00:08:11.540
and again, and again.

00:08:11.540 --> 00:08:14.180
And this is important
because, it's not only

00:08:14.180 --> 00:08:16.190
for your production
systems, but also when

00:08:16.190 --> 00:08:18.610
you look your test dev
staging, however you

00:08:18.610 --> 00:08:20.860
want to actually call your
pre-production systems,

00:08:20.860 --> 00:08:23.670
you want to make sure that those
near your production systems

00:08:23.670 --> 00:08:24.867
as closely as possible.

00:08:24.867 --> 00:08:26.450
One of the hard won
lessons, if you've

00:08:26.450 --> 00:08:30.268
done this stuff over time, is
that any issue, or any place,

00:08:30.268 --> 00:08:32.309
where your production
infrastructure and your dev

00:08:32.309 --> 00:08:33.956
and test infrastructure differ.

00:08:33.956 --> 00:08:35.789
Eventually you're going
to find a bug there.

00:08:35.789 --> 00:08:38.460
So the closer you can
make those things,

00:08:38.460 --> 00:08:40.750
the more you can
protect yourself

00:08:40.750 --> 00:08:45.020
from having issues make their
way out into production.

00:08:45.020 --> 00:08:47.950
So moving from
Compute to Networking.

00:08:47.950 --> 00:08:50.680
Google has made enormous
investments in networking.

00:08:50.680 --> 00:08:53.190
And we've done it both
at the cluster level, how

00:08:53.190 --> 00:08:56.530
one machine in one
data center talks

00:08:56.530 --> 00:08:59.340
to another machine in that
data-- in that same data

00:08:59.340 --> 00:08:59.940
center.

00:08:59.940 --> 00:09:01.600
But also across the world.

00:09:01.600 --> 00:09:03.544
In terms of wide
area networking,

00:09:03.544 --> 00:09:05.210
how one machine on
one side of the world

00:09:05.210 --> 00:09:07.543
talks to another machine on
the other side of the world.

00:09:07.543 --> 00:09:12.420
Or how your phone or your
laptop talks to Google server.

00:09:12.420 --> 00:09:16.109
And speaking specifically
about that wide area network,

00:09:16.109 --> 00:09:17.900
we've done a lot of
really interesting work

00:09:17.900 --> 00:09:19.490
about managing the
quality of service

00:09:19.490 --> 00:09:22.089
across our worldwide network.

00:09:22.089 --> 00:09:24.130
A little while ago,
[INAUDIBLE] presented a paper

00:09:24.130 --> 00:09:26.140
at a conference
describing a system

00:09:26.140 --> 00:09:29.390
called B4, that's B as in boy.

00:09:29.390 --> 00:09:32.280
And it's a global
software defined WAN

00:09:32.280 --> 00:09:34.840
and it's built on top of this
technology called OpenFlow,

00:09:34.840 --> 00:09:35.740
that we've pioneered.

00:09:35.740 --> 00:09:38.009
And we have the largest
implementation of it.

00:09:38.009 --> 00:09:39.550
So we're really
pioneers in this way,

00:09:39.550 --> 00:09:43.956
in terms of doing software
defined networking.

00:09:43.956 --> 00:09:45.580
The last piece of
the networking puzzle

00:09:45.580 --> 00:09:47.810
is high capacity load balancing.

00:09:47.810 --> 00:09:51.510
And we look at this from,
how do you actually,

00:09:51.510 --> 00:09:53.760
when something hits a data
center, how do you actually

00:09:53.760 --> 00:09:55.510
disperse that traffic
to the right servers

00:09:55.510 --> 00:09:57.126
in that particular data center?

00:09:57.126 --> 00:09:59.750
To how do you actually make sure
that it gets to the right data

00:09:59.750 --> 00:10:00.250
center?

00:10:00.250 --> 00:10:02.056
If you have a lot of
them around the world.

00:10:02.056 --> 00:10:03.680
And how do you actually
manage capacity

00:10:03.680 --> 00:10:06.350
and actually overflow
from one place to another.

00:10:06.350 --> 00:10:08.450
And a great example of
this is the 1 million

00:10:08.450 --> 00:10:12.840
QPS test that we ran, and
wrote a blog post about,

00:10:12.840 --> 00:10:14.590
I think it was mentioned
in the keynote.

00:10:14.590 --> 00:10:16.256
So if you want to
learn more about that,

00:10:16.256 --> 00:10:21.990
I highly recommend you read
that, you read that blog post.

00:10:21.990 --> 00:10:25.210
So moving from
networking to storage.

00:10:25.210 --> 00:10:27.350
At Google, pretty much
all of our storage

00:10:27.350 --> 00:10:28.620
is done over the network.

00:10:28.620 --> 00:10:32.880
And we built our networks to
be able to handle that load.

00:10:32.880 --> 00:10:34.500
And this really
achieves two things.

00:10:34.500 --> 00:10:36.090
So the first thing
that this achieves,

00:10:36.090 --> 00:10:38.400
is it gives us the
opportunity to implement

00:10:38.400 --> 00:10:39.795
reliable, durable systems.

00:10:39.795 --> 00:10:41.920
Once you have that interface,
where you're actually

00:10:41.920 --> 00:10:47.630
getting an API between you
and your storage system,

00:10:47.630 --> 00:10:51.650
you have the opportunity to
build distributed, reliable,

00:10:51.650 --> 00:10:52.850
durable systems there.

00:10:52.850 --> 00:10:56.250
Great examples of this are
at the Block Storage level.

00:10:56.250 --> 00:10:58.380
So our product,
Google Cloud Storage,

00:10:58.380 --> 00:11:00.070
is built on top
of Colossus, which

00:11:00.070 --> 00:11:02.809
is the successor for
GFS, which again, we

00:11:02.809 --> 00:11:04.350
have another paper
out there for that

00:11:04.350 --> 00:11:08.150
if you want to read
about how GFS works.

00:11:08.150 --> 00:11:10.000
But having that distance
over the network

00:11:10.000 --> 00:11:11.790
gives us the
opportunity to actually

00:11:11.790 --> 00:11:14.600
be smart about replication,
about directing you

00:11:14.600 --> 00:11:16.205
to the most performance replica.

00:11:16.205 --> 00:11:19.250
And when you're doing a
read, things like that.

00:11:19.250 --> 00:11:22.430
And we use that same technology,
both in our virtual VM Block

00:11:22.430 --> 00:11:25.470
solution, to this is
persistent disk is part of GCE,

00:11:25.470 --> 00:11:27.050
to Google Cloud Storage.

00:11:27.050 --> 00:11:29.280
To our structured storage
and analytic systems,

00:11:29.280 --> 00:11:36.040
including Google Cloud Data
Store, Google Cloud SQL,

00:11:36.040 --> 00:11:38.370
and our analytics
systems, like BigQuery.

00:11:42.834 --> 00:11:44.750
Back on that slide, so
one of the other things

00:11:44.750 --> 00:11:46.833
I wanted to mention is
because of this networking,

00:11:46.833 --> 00:11:50.132
we can actually integrate not
with just with Google systems,

00:11:50.132 --> 00:11:51.090
but with other systems.

00:11:51.090 --> 00:11:53.300
So there's also
another great blog post

00:11:53.300 --> 00:11:59.330
detailing running Hadoop,
accessing Google Cloud Storage

00:11:59.330 --> 00:12:01.800
directly, using
the Hadoop adapter

00:12:01.800 --> 00:12:04.550
for Google Cloud Storage.

00:12:04.550 --> 00:12:06.820
OK, so now, services and
glue, bringing all this stuff

00:12:06.820 --> 00:12:07.510
together.

00:12:07.510 --> 00:12:09.430
So the first thing I
want to talk about here

00:12:09.430 --> 00:12:12.160
is common data formats
and API mechanisms.

00:12:12.160 --> 00:12:14.780
And so with common data
formats, we use, pretty much

00:12:14.780 --> 00:12:17.880
universally, internally, this
system called Protocol Buffers.

00:12:17.880 --> 00:12:19.900
This is a way to
actually encode,

00:12:19.900 --> 00:12:24.650
persist, and can read
that data in a way that's

00:12:24.650 --> 00:12:26.450
tolerant to versioning
and changes,

00:12:26.450 --> 00:12:27.890
and moving this stuff forward.

00:12:27.890 --> 00:12:30.549
We use this, pretty much,
any time you write something

00:12:30.549 --> 00:12:32.590
to disk, any time one
server connects to another,

00:12:32.590 --> 00:12:34.180
we use Proto Buffs,
inside of Google.

00:12:34.180 --> 00:12:35.110
Configuration files?

00:12:35.110 --> 00:12:35.610
Proto Buffs.

00:12:35.610 --> 00:12:37.420
You name it, Proto Buffs.

00:12:37.420 --> 00:12:39.600
Now, there are-- we
have open sources,

00:12:39.600 --> 00:12:41.272
so this is available
on code.google.com.

00:12:41.272 --> 00:12:43.730
You can use this stuff
directly, if you want to.

00:12:43.730 --> 00:12:46.301
But there's also a whole set
of similar systems out there

00:12:46.301 --> 00:12:48.050
that give you a lot
of the same advantages

00:12:48.050 --> 00:12:51.020
that you should check out.

00:12:51.020 --> 00:12:52.600
And then we have API mechanisms.

00:12:52.600 --> 00:12:54.670
How do you actually
expose services

00:12:54.670 --> 00:12:57.730
so that one part of
your infrastructure

00:12:57.730 --> 00:12:59.760
can talk to another
part of the structure?

00:12:59.760 --> 00:13:04.350
And an interesting thing there
is that we built a set of API

00:13:04.350 --> 00:13:07.020
middleware that
we use internally

00:13:07.020 --> 00:13:09.480
to expose all of
our applications.

00:13:09.480 --> 00:13:12.420
Things like the
GC-API, for example.

00:13:12.420 --> 00:13:14.130
But we also make
this available to you

00:13:14.130 --> 00:13:16.370
through this product called
Google Cloud Endpoints.

00:13:16.370 --> 00:13:23.099
And so you can benefit from the
same rate limiting, and client

00:13:23.099 --> 00:13:25.140
libraries, and all the
services that we've built.

00:13:25.140 --> 00:13:27.130
That infrastructure
for our APIs,

00:13:27.130 --> 00:13:30.720
you can leverage those
for your APIs, as well.

00:13:30.720 --> 00:13:32.120
Monitoring and alerting.

00:13:32.120 --> 00:13:35.010
If you don't monitor what's
going on with your application,

00:13:35.010 --> 00:13:36.910
you don't know when
things are broken.

00:13:36.910 --> 00:13:39.370
And Google has
enormous investments

00:13:39.370 --> 00:13:40.760
around monitoring and alerting.

00:13:40.760 --> 00:13:42.926
And we're working hard to
bring some of that to you.

00:13:42.926 --> 00:13:44.510
I think you've seen
some of this today

00:13:44.510 --> 00:13:46.420
with the integrative logging.

00:13:46.420 --> 00:13:48.660
Another sort of
piece of this puzzle.

00:13:48.660 --> 00:13:50.590
But there's a lot
more to come there.

00:13:50.590 --> 00:13:54.290
Configuration brings back to
that declarative management.

00:13:54.290 --> 00:13:57.190
But you really need to take a
holistic view of configuration.

00:13:57.190 --> 00:14:00.370
Not only configuring which
resources you're running,

00:14:00.370 --> 00:14:02.950
but also what's happening
inside of those resources.

00:14:02.950 --> 00:14:04.499
And so a piece of
the puzzle here is,

00:14:04.499 --> 00:14:06.790
things like we're going to
talk about later with manage

00:14:06.790 --> 00:14:08.940
VMs and Deployment Manager.

00:14:08.940 --> 00:14:12.090
But you can also leverage
open systems like Puppet Chef

00:14:12.090 --> 00:14:13.650
or SaltStack to
manage what's going

00:14:13.650 --> 00:14:15.840
on inside of a virtual machine.

00:14:15.840 --> 00:14:18.300
And then finally, there's
automated build, testing,

00:14:18.300 --> 00:14:19.660
and life cycle management.

00:14:19.660 --> 00:14:21.400
This is making sure that you
know what you're building,

00:14:21.400 --> 00:14:23.024
you know that it's
well tested, and you

00:14:23.024 --> 00:14:25.160
know that it's actually
deployed when and how you

00:14:25.160 --> 00:14:26.600
want it to be deployed.

00:14:26.600 --> 00:14:28.070
There's a lot more
detail with that

00:14:28.070 --> 00:14:29.569
in the session that
was co-scheduled

00:14:29.569 --> 00:14:31.770
with this one, that's
going on in the other room.

00:14:31.770 --> 00:14:35.480
So I recommend that
you check out the video

00:14:35.480 --> 00:14:38.520
once it's posted on the
Cloud Platform Live site.

00:14:41.230 --> 00:14:42.730
So bringing all
this stuff together,

00:14:42.730 --> 00:14:44.396
I want to talk about
a couple of systems

00:14:44.396 --> 00:14:46.110
that are uniquely Google.

00:14:46.110 --> 00:14:48.920
And the first one is
Google Cloud Data Store.

00:14:48.920 --> 00:14:53.220
So this is, started life as the
Google App Engine Data Store,

00:14:53.220 --> 00:14:57.180
but now it's available as
a separate RESTful API,

00:14:57.180 --> 00:14:59.420
so that you can access
it outside of the context

00:14:59.420 --> 00:15:01.790
of an App Engine app.

00:15:01.790 --> 00:15:04.500
This is built on top of
a couple of technologies

00:15:04.500 --> 00:15:06.550
that, again, we've
released papers about,

00:15:06.550 --> 00:15:09.520
including Megastore in BigTable.

00:15:09.520 --> 00:15:11.340
These are really
interesting papers

00:15:11.340 --> 00:15:13.270
that I recommend
you take a look at.

00:15:13.270 --> 00:15:15.300
But one of, the most
interesting things

00:15:15.300 --> 00:15:17.330
here is that these
things take advantage

00:15:17.330 --> 00:15:19.280
of Google's entire data center.

00:15:19.280 --> 00:15:23.377
So when you buy some space in
Google's Cloud Data Center,

00:15:23.377 --> 00:15:24.710
you're just putting items there.

00:15:24.710 --> 00:15:26.293
And you let us take
care of the scale.

00:15:26.293 --> 00:15:29.770
And you're not buying a
discrete set of resources.

00:15:29.770 --> 00:15:31.270
Instead, you're
actually buying more

00:15:31.270 --> 00:15:34.010
of a horizontal slice of
the entire Data Center.

00:15:34.010 --> 00:15:37.100
Which means that as you scale
from the small to the very big,

00:15:37.100 --> 00:15:39.340
if you structure your
schema correctly,

00:15:39.340 --> 00:15:42.204
you're not going to hit
any cliffs along the way.

00:15:42.204 --> 00:15:44.620
And you won't have to make
discrete decisions that, oh I'm

00:15:44.620 --> 00:15:46.510
going to buy another
chunk of capacity.

00:15:46.510 --> 00:15:48.690
And so this really is
bringing the elasticity

00:15:48.690 --> 00:15:51.660
that is promised in
the Cloud to life.

00:15:51.660 --> 00:15:53.401
Another similar system
here is BigQuery.

00:15:53.401 --> 00:15:55.900
There was a session earlier
that went into a lot more detail

00:15:55.900 --> 00:15:56.430
here.

00:15:56.430 --> 00:15:58.138
But I just want to
put some numbers, sort

00:15:58.138 --> 00:16:00.820
of some hypothetical numbers,
and actually drive home

00:16:00.820 --> 00:16:04.640
this point of actually using the
entire sort of horizontal slice

00:16:04.640 --> 00:16:06.500
of the Data Center.

00:16:06.500 --> 00:16:09.370
And oh, and by the way, there's
a paper on BigQuery also

00:16:09.370 --> 00:16:10.450
the Dramel.

00:16:10.450 --> 00:16:14.100
This is a screenshot of
one of the pages there.

00:16:14.100 --> 00:16:18.930
So let's say that internally,
hypothetically, Dremel

00:16:18.930 --> 00:16:23.010
uses-- or BigQuery uses, 1,200
spindles to actually execute

00:16:23.010 --> 00:16:25.627
your query-- 1,200
spinning disks.

00:16:25.627 --> 00:16:27.460
I actually don't know
how many there are, so

00:16:27.460 --> 00:16:28.500
don't quote me on that.

00:16:28.500 --> 00:16:30.894
So hypothetically, let's say
that it takes half a second

00:16:30.894 --> 00:16:32.060
to actually running a query.

00:16:32.060 --> 00:16:35.330
You're essentially buying
half a second of spindle time

00:16:35.330 --> 00:16:37.080
across 1,200 spindles.

00:16:37.080 --> 00:16:40.430
That's the same as buying a
single spindle for 10 minutes.

00:16:40.430 --> 00:16:42.730
As far as Google is concerned,
that's the same cost.

00:16:42.730 --> 00:16:45.124
When you have enough customers
actually accessing that,

00:16:45.124 --> 00:16:47.040
it's actually the same
amount to spindle time.

00:16:47.040 --> 00:16:49.180
It's just unevenly distributed.

00:16:49.180 --> 00:16:50.890
But it's a game
changer when you're

00:16:50.890 --> 00:16:54.169
looking at the service in terms
of getting wall time results.

00:16:54.169 --> 00:16:55.710
Running a query that
takes 10 minutes

00:16:55.710 --> 00:16:57.030
is not very interesting.

00:16:57.030 --> 00:16:59.070
Running a query that
takes half a second

00:16:59.070 --> 00:17:01.472
is very, very interesting.

00:17:01.472 --> 00:17:02.930
So hopefully this
gives you a taste

00:17:02.930 --> 00:17:05.440
of what it's like to be an
engineer at Google, what

00:17:05.440 --> 00:17:06.910
our internal
platform looks like.

00:17:06.910 --> 00:17:08.868
And a little bit of a
hint of some of the stuff

00:17:08.868 --> 00:17:11.560
that you're going to be seeing
over the next coming months.

00:17:11.560 --> 00:17:13.361
So back to you, nothing Navneet.

00:17:13.361 --> 00:17:18.550
[APPLAUSE]

00:17:18.550 --> 00:17:19.740
NAVNEET JONEJA: Thanks, Joe.

00:17:19.740 --> 00:17:22.099
So if you've been watching
us over the past few months,

00:17:22.099 --> 00:17:23.567
you've seen several
of these pieces

00:17:23.567 --> 00:17:24.900
in action on the Cloud platform.

00:17:24.900 --> 00:17:28.180
We've talked about, for
example, how our internal Dramel

00:17:28.180 --> 00:17:31.130
system is BigQuery,
that you have access to.

00:17:31.130 --> 00:17:33.520
But I wanted to just spend
a few minutes recapping

00:17:33.520 --> 00:17:36.380
some of the more interesting
highlights of the capabilities

00:17:36.380 --> 00:17:38.550
we've launched recently.

00:17:38.550 --> 00:17:41.000
So Compute Engine
went GA in December.

00:17:41.000 --> 00:17:43.350
And we've launched
several enhancements.

00:17:43.350 --> 00:17:46.930
How many of you were
here at the keynote?

00:17:46.930 --> 00:17:48.550
So OK, a good number of you.

00:17:48.550 --> 00:17:50.570
So if you were there,
and if you want,

00:17:50.570 --> 00:17:52.830
I encourage you to
watch the video later.

00:17:52.830 --> 00:17:54.830
We did a demonstration
of this technology, which

00:17:54.830 --> 00:17:56.470
we call Transparent Maintenance.

00:17:56.470 --> 00:17:58.720
Let me go into a bit more
background about Transparent

00:17:58.720 --> 00:17:59.220
Maintenance.

00:17:59.220 --> 00:18:01.640
So it turns out
that the best way

00:18:01.640 --> 00:18:04.650
to keep any system functioning,
frankly, not just computing

00:18:04.650 --> 00:18:06.150
systems, is preventive
maintenance.

00:18:06.150 --> 00:18:08.400
You want to make sure all
the components of the system

00:18:08.400 --> 00:18:10.512
are functioning as
well as possible.

00:18:10.512 --> 00:18:12.470
Transferring that over
into the computer plate,

00:18:12.470 --> 00:18:15.230
you want to make sure that, for
example, your data center power

00:18:15.230 --> 00:18:16.450
infrastructure works well.

00:18:16.450 --> 00:18:20.830
You want to make sure
that your hardware is

00:18:20.830 --> 00:18:22.100
maintained properly.

00:18:22.100 --> 00:18:25.180
You want to make sure that your
software, your host software,

00:18:25.180 --> 00:18:27.250
is patched whenever there
is a security update.

00:18:27.250 --> 00:18:29.458
You want to make sure
everything is running, frankly,

00:18:29.458 --> 00:18:31.090
as smoothly as
possible, so you get

00:18:31.090 --> 00:18:34.700
the most reliable, most secure
environment for all of it,

00:18:34.700 --> 00:18:36.250
for everyone.

00:18:36.250 --> 00:18:38.970
Now, it turns out that many of
these things I talked about,

00:18:38.970 --> 00:18:41.310
like patching host software,
or doing power maintenance,

00:18:41.310 --> 00:18:42.340
are actually disruptive events.

00:18:42.340 --> 00:18:42.840
Right?

00:18:42.840 --> 00:18:44.670
If you have something
running on a machine,

00:18:44.670 --> 00:18:46.600
and you need to
upgrade the host OS,

00:18:46.600 --> 00:18:47.800
it's going to affect the VM.

00:18:47.800 --> 00:18:49.080
If you want to do
power maintenance

00:18:49.080 --> 00:18:51.410
and make sure generators
work by flipping the switch,

00:18:51.410 --> 00:18:53.090
it's going to effectively end.

00:18:53.090 --> 00:18:54.551
So you could have
a choice, I mean,

00:18:54.551 --> 00:18:55.800
that's one way to go about it.

00:18:55.800 --> 00:18:58.830
You could have a choice between
delaying those maintenances

00:18:58.830 --> 00:19:00.770
and hoping that
things don't go wrong.

00:19:00.770 --> 00:19:04.170
And so having fewer
disruptions to running VMs.

00:19:04.170 --> 00:19:06.770
Or, you could potentially go
the other way, and just say,

00:19:06.770 --> 00:19:07.860
we're going to do
preventive maintenance.

00:19:07.860 --> 00:19:09.860
Which means, you will
have planned downtime,

00:19:09.860 --> 00:19:11.202
and that's just how things work.

00:19:11.202 --> 00:19:13.410
We actually didn't want to
go either of those routes.

00:19:13.410 --> 00:19:16.210
We wanted to effectively let you
have your cake and eat it too.

00:19:16.210 --> 00:19:20.037
We wanted to give you a
minimal number of disruption

00:19:20.037 --> 00:19:21.745
on your VMs, while
simultaneously keeping

00:19:21.745 --> 00:19:24.615
our infrastructure as
secure, and as efficient,

00:19:24.615 --> 00:19:27.249
and as reliably
running as possible.

00:19:27.249 --> 00:19:28.665
And so we launched
this technology

00:19:28.665 --> 00:19:29.770
called Transparent Maintenance.

00:19:29.770 --> 00:19:32.050
Which really was us going
back to the drawing board

00:19:32.050 --> 00:19:34.580
and saying, how do you actually
design datacenter operations

00:19:34.580 --> 00:19:37.010
from the ground up so that
the applications running there

00:19:37.010 --> 00:19:38.870
can survive a maintenance event.

00:19:38.870 --> 00:19:40.500
So what we're doing,
really, and just

00:19:40.500 --> 00:19:42.990
to peel back the
covers a bit, is

00:19:42.990 --> 00:19:44.730
we're actually
taking running VMs

00:19:44.730 --> 00:19:47.520
and moving them out of the
way of a maintenance event.

00:19:47.520 --> 00:19:50.080
So if we know a particular
rack is about to be maintained,

00:19:50.080 --> 00:19:52.870
we'll take all the VMs on that
rack, move them somewhere else,

00:19:52.870 --> 00:19:53.890
perform the maintenance
of the rack,

00:19:53.890 --> 00:19:55.540
and now, you have
an updated rack.

00:19:55.540 --> 00:19:57.030
And we do this very quickly
throughout the whole data

00:19:57.030 --> 00:19:59.020
center, which means,
that actually, we

00:19:59.020 --> 00:20:01.220
can keep our software and
hardware running really

00:20:01.220 --> 00:20:02.637
efficiently without
impacting you.

00:20:02.637 --> 00:20:04.011
So there's a--
like I said, there

00:20:04.011 --> 00:20:06.410
was a great demo in the keynote
if you didn't catch that,

00:20:06.410 --> 00:20:08.240
I really encourage
you watching that.

00:20:08.240 --> 00:20:11.100
Because it really drives the
point home about how little

00:20:11.100 --> 00:20:13.822
the impact to VM is when
we're doing this stuff.

00:20:13.822 --> 00:20:15.530
OK, let me talk about
pricing a bit more.

00:20:15.530 --> 00:20:18.160
Now, we already spent a lot of
time about this in the keynote,

00:20:18.160 --> 00:20:20.760
so I don't want to reiterate
the points he talked about.

00:20:20.760 --> 00:20:22.960
I do want to share
some more color.

00:20:22.960 --> 00:20:25.010
So let me talk about
virtual machine pricing.

00:20:25.010 --> 00:20:27.530
So one of the things, which
is basically a truism,

00:20:27.530 --> 00:20:30.560
is that, when you run
a sustained workload,

00:20:30.560 --> 00:20:33.340
it costs less, whether you're
doing that on your own hardware

00:20:33.340 --> 00:20:34.965
or you're doing it
in the Cloud, right?

00:20:34.965 --> 00:20:37.170
It costs the provider
less because provisioning

00:20:37.170 --> 00:20:39.160
for spikes costs money,
If this hardware,

00:20:39.160 --> 00:20:41.287
which has not been used
for a large amount of time.

00:20:41.287 --> 00:20:42.870
And some of that
evens out when you're

00:20:42.870 --> 00:20:45.149
talking about Cloud Scale
because different customers

00:20:45.149 --> 00:20:46.190
spike at different times.

00:20:46.190 --> 00:20:47.830
But it's still
fundamentally a problem.

00:20:47.830 --> 00:20:49.285
And so you want to make
sure that customers

00:20:49.285 --> 00:20:50.660
who are doing
sustained workloads

00:20:50.660 --> 00:20:52.800
are actually getting
the best possible price.

00:20:52.800 --> 00:20:55.426
Now, one of the traditional ways
that many Cloud providers have

00:20:55.426 --> 00:20:57.258
looked to solve this
is through commitments.

00:20:57.258 --> 00:20:59.860
So they kind of know, because
you've committed to them what

00:20:59.860 --> 00:21:01.040
you're going to be
doing on that platform,

00:21:01.040 --> 00:21:02.590
and they kind of
structure pricing

00:21:02.590 --> 00:21:05.202
in a way to incentivizes,
kind of, sustained use.

00:21:05.202 --> 00:21:07.410
And that's a perfectly fine
way to solve the problem.

00:21:07.410 --> 00:21:08.868
But it creates a
few other problems

00:21:08.868 --> 00:21:10.140
that we wanted to avoid.

00:21:10.140 --> 00:21:13.090
Specifically, it forces you
to make a commitment, right?

00:21:13.090 --> 00:21:15.580
You have to choose the kind of
machine you're going to run,

00:21:15.580 --> 00:21:18.090
and probably commit to
it for a year or three.

00:21:18.090 --> 00:21:20.280
And so if you decide
that suddenly,

00:21:20.280 --> 00:21:22.194
actually, I kind of
think this is OK,

00:21:22.194 --> 00:21:23.610
but I want a bit
more RAM on this.

00:21:23.610 --> 00:21:25.130
And I want to do something else.

00:21:25.130 --> 00:21:26.650
Well, you've already
committed to the other thing.

00:21:26.650 --> 00:21:29.160
And now, you can't get the
best price on that other thing.

00:21:29.160 --> 00:21:31.540
And so we wanted to
make sure that you

00:21:31.540 --> 00:21:32.980
could get the best
possible price

00:21:32.980 --> 00:21:34.980
without any upfront
payments, without having

00:21:34.980 --> 00:21:37.500
to wade through a
large menu of options.

00:21:37.500 --> 00:21:39.630
Just get the best price
for your workload.

00:21:39.630 --> 00:21:42.050
And so what we did was, we
introduced sustained use

00:21:42.050 --> 00:21:43.280
pricing.

00:21:43.280 --> 00:21:45.410
And what, and we talk
about how that works.

00:21:45.410 --> 00:21:47.630
So I'm going to use a real
world example for that.

00:21:47.630 --> 00:21:52.120
So let's say, and this is
a very small application,

00:21:52.120 --> 00:21:55.640
but you have 1 VM running
your application today.

00:21:55.640 --> 00:21:57.271
You start at the
beginning of April.

00:21:57.271 --> 00:21:59.520
You run that VM for about
10 days, during which you're

00:21:59.520 --> 00:22:01.730
doing some analysis using
BigQuery on your logs,

00:22:01.730 --> 00:22:04.350
and you find out, there is
probably some optimization

00:22:04.350 --> 00:22:06.840
you could do to make sure
your pages load faster.

00:22:06.840 --> 00:22:07.340
Right?

00:22:07.340 --> 00:22:09.440
So you do that on a second VM.

00:22:09.440 --> 00:22:11.350
You send some
traffic to that VM,

00:22:11.350 --> 00:22:15.000
sort of canary it, and make
sure that you haven't actually

00:22:15.000 --> 00:22:17.250
changed anything for the
worse, everything works well.

00:22:17.250 --> 00:22:19.220
After about four or
five days of testing,

00:22:19.220 --> 00:22:21.250
you find that
actually, yes, you have

00:22:21.250 --> 00:22:23.345
founded a meaningful
optimization.

00:22:23.345 --> 00:22:25.220
This is how you want to
run your application.

00:22:25.220 --> 00:22:28.020
You shut down the first VM,
you keep the second VM running.

00:22:28.020 --> 00:22:29.930
Your users love this,
five days later you

00:22:29.930 --> 00:22:32.470
have tons more traffic, and
you need to set up a second VM

00:22:32.470 --> 00:22:34.400
to serve all that
additional traffic.

00:22:34.400 --> 00:22:36.030
And you keep that second
VM running the whole month.

00:22:36.030 --> 00:22:37.404
So that's kind of
what this looks

00:22:37.404 --> 00:22:39.510
like, the three VMs
running through the month.

00:22:39.510 --> 00:22:41.920
So how does that look like
from a sustained use discount

00:22:41.920 --> 00:22:42.420
perspective?

00:22:42.420 --> 00:22:44.970
How do we actually treat
that in terms of the prices

00:22:44.970 --> 00:22:45.870
we offer you?

00:22:45.870 --> 00:22:47.828
Well, so what we
basically do is we kind of

00:22:47.828 --> 00:22:49.536
play a little game of
Tetris here, right?

00:22:49.536 --> 00:22:51.710
We look at how you used
VMs during the month.

00:22:51.710 --> 00:22:53.835
So if you look at the
chart on the screen,

00:22:53.835 --> 00:22:56.310
for the first 10 days
you had one VM running.

00:22:56.310 --> 00:22:58.550
The second five days,
five day after that

00:22:58.550 --> 00:22:59.846
you had two VMs running.

00:22:59.846 --> 00:23:01.720
Then you had a short
period when you had just

00:23:01.720 --> 00:23:03.854
the new updated VM
running for five days.

00:23:03.854 --> 00:23:05.270
And then for the
rest of the month

00:23:05.270 --> 00:23:07.478
you've got two VMs running,
serving all your traffic.

00:23:07.478 --> 00:23:08.850
So that's basically what we do.

00:23:08.850 --> 00:23:10.683
We say, you know, as
far as we're concerned,

00:23:10.683 --> 00:23:11.930
this is two logical VMs.

00:23:11.930 --> 00:23:14.570
You had one logical VM
running the entire month.

00:23:14.570 --> 00:23:16.430
And so you used it
for 100% and you

00:23:16.430 --> 00:23:18.730
get a 30% discount on that VM.

00:23:18.730 --> 00:23:21.660
You had a second VM which
ran, although disjointedly,

00:23:21.660 --> 00:23:23.000
for about a half the month.

00:23:23.000 --> 00:23:24.840
And so you get a
discount on that too.

00:23:24.840 --> 00:23:26.360
You get a 10% discount on that.

00:23:26.360 --> 00:23:28.600
And so we are
automatically taking

00:23:28.600 --> 00:23:31.400
care of all the complexities
so that you build and operate

00:23:31.400 --> 00:23:33.430
your service in a way
that makes sense to you.

00:23:33.430 --> 00:23:35.450
So you don't have to
do anything artificial

00:23:35.450 --> 00:23:36.990
to make sure you
get the best price.

00:23:36.990 --> 00:23:38.290
We take care of that for you.

00:23:38.290 --> 00:23:40.070
And that's really
what we believe

00:23:40.070 --> 00:23:41.490
is at the heart of Cloud, right?

00:23:41.490 --> 00:23:43.281
The provider should
handle the complexities

00:23:43.281 --> 00:23:47.401
so you get a simple experience,
so that's what we're all about.

00:23:47.401 --> 00:23:47.900
OK.

00:23:47.900 --> 00:23:49.740
So let's talk about disk.

00:23:49.740 --> 00:23:51.460
Joe talked a bit
about how at Google we

00:23:51.460 --> 00:23:53.680
build all of our storage
over the network, right?

00:23:53.680 --> 00:23:56.400
So we believe that
there's tons of benefits

00:23:56.400 --> 00:23:58.670
to that, for example,
you can scale a computer

00:23:58.670 --> 00:24:00.380
and storage independently.

00:24:00.380 --> 00:24:03.770
You shouldn't have to buy a
really beefy compute machine

00:24:03.770 --> 00:24:05.390
to get a lot of storage.

00:24:05.390 --> 00:24:07.970
You shouldn't necessarily
buy a ton of storage

00:24:07.970 --> 00:24:09.720
and not be able to use
it because you want

00:24:09.720 --> 00:24:12.480
to beefy compute machine,
you should use what you need.

00:24:12.480 --> 00:24:15.290
At the same time, you get
benefits like Network Attach

00:24:15.290 --> 00:24:18.095
Storage lets you do things
like Snapshot your storage.

00:24:18.095 --> 00:24:20.450
So you can go back to a
previous point in time

00:24:20.450 --> 00:24:21.570
if something breaks.

00:24:21.570 --> 00:24:25.930
Or you can you know,
basically look at tuning,

00:24:25.930 --> 00:24:28.770
how move your storage
from one VM to another.

00:24:28.770 --> 00:24:30.720
So let's say, you
have a SQL database

00:24:30.720 --> 00:24:32.180
that's running a
two core machine,

00:24:32.180 --> 00:24:33.720
you want to run a
four core machine.

00:24:33.720 --> 00:24:35.465
Shut down the two core
machine, spit up the same disk

00:24:35.465 --> 00:24:36.300
as on the four core machine.

00:24:36.300 --> 00:24:37.341
You're good to go, right?

00:24:37.341 --> 00:24:39.090
So it makes your
operation a lot simpler.

00:24:39.090 --> 00:24:41.020
It makes everything
more reliable,

00:24:41.020 --> 00:24:42.787
more easy to run and administer.

00:24:42.787 --> 00:24:44.370
And so we wanted to
make sure that you

00:24:44.370 --> 00:24:46.574
got all those benefits,
but at a good price.

00:24:46.574 --> 00:24:47.990
And so what we did
was we actually

00:24:47.990 --> 00:24:51.510
launched the system disk, which
is our network attached disk,

00:24:51.510 --> 00:24:53.250
at the same price
as a scratch disk.

00:24:53.250 --> 00:24:55.800
So basically, you get all
the benefits of network disk

00:24:55.800 --> 00:24:57.915
with a single per
gigabyte price that

00:24:57.915 --> 00:25:00.072
includes all the I/O,
which scales its size.

00:25:00.072 --> 00:25:01.780
So if you want to
scale your performance,

00:25:01.780 --> 00:25:03.660
you just know how to do
it, you just scale size.

00:25:03.660 --> 00:25:05.201
It's very predictable,
you don't have

00:25:05.201 --> 00:25:07.740
any two independent
dimensions to think about.

00:25:07.740 --> 00:25:08.610
And it's very cheap.

00:25:08.610 --> 00:25:10.280
And so that's really,
you know, again,

00:25:10.280 --> 00:25:12.060
going back to the
heart of offering you

00:25:12.060 --> 00:25:14.850
a simple, powerful mechanism
to build your applications.

00:25:14.850 --> 00:25:17.250
That's what we're about.

00:25:17.250 --> 00:25:20.635
OK, so let's talk
App Engine briefly.

00:25:20.635 --> 00:25:22.260
We've done a lot on
App Engine pricing,

00:25:22.260 --> 00:25:23.840
and really, to get
the full flavor for it

00:25:23.840 --> 00:25:24.820
you should just visit the site.

00:25:24.820 --> 00:25:27.060
But I wanted to highlight
some of the changes we've

00:25:27.060 --> 00:25:27.940
made there.

00:25:27.940 --> 00:25:30.740
We've drastically simplified
pricing across the board.

00:25:30.740 --> 00:25:35.020
We've cut the price for
instance hours by 37.5%.

00:25:35.020 --> 00:25:38.880
We've cut the price for
Dedicated Memcache by 50%.

00:25:38.880 --> 00:25:41.680
And for Datastore Writes,
which was one of our most

00:25:41.680 --> 00:25:44.440
frequently received
requests, by 33%.

00:25:44.440 --> 00:25:46.857
We've also taken a number of
services that were previously

00:25:46.857 --> 00:25:48.356
charged for
independently, and we've

00:25:48.356 --> 00:25:50.040
bundled them into
the price App Engine.

00:25:50.040 --> 00:25:52.457
And so overall, you see a much
simpler, much shorter price

00:25:52.457 --> 00:25:55.890
sheet with lower prices
across the board.

00:25:55.890 --> 00:25:56.390
OK.

00:25:56.390 --> 00:25:59.980
So let's talk about
networking here.

00:25:59.980 --> 00:26:03.222
We've launched several advances
in the area of networking,

00:26:03.222 --> 00:26:05.180
starting with low level
things, like giving you

00:26:05.180 --> 00:26:08.170
access to the software
defined router that underlies

00:26:08.170 --> 00:26:10.640
the network through
our capabilities

00:26:10.640 --> 00:26:12.010
in advanced routing.

00:26:12.010 --> 00:26:16.010
We also launched higher level
capabilities like, layer 3 load

00:26:16.010 --> 00:26:18.610
balancing, and
protocol forwarding.

00:26:18.610 --> 00:26:20.740
And today, we are also
announcing a new service,

00:26:20.740 --> 00:26:22.810
Google Cloud DNS,
which gives you

00:26:22.810 --> 00:26:24.920
access to same
DNS infrastructure

00:26:24.920 --> 00:26:29.020
that we use to serve all
of our own DNS queries,

00:26:29.020 --> 00:26:30.160
to serve your own domains.

00:26:30.160 --> 00:26:32.570
And so you get access to the
same low latency worldwide

00:26:32.570 --> 00:26:35.050
serving, you have Command
Line API Access to it,

00:26:35.050 --> 00:26:38.110
and it's priced at a
very simple low price.

00:26:38.110 --> 00:26:41.500
OK, moving on, let's talk
about operating systems.

00:26:41.500 --> 00:26:44.540
We've worked with commercial
software providers like Red Hat

00:26:44.540 --> 00:26:46.966
and SuSE to provide
their operating

00:26:46.966 --> 00:26:48.090
systems on computer engine.

00:26:48.090 --> 00:26:51.290
We also work with the community
to provide that [INAUDIBLE]

00:26:51.290 --> 00:26:56.090
and recently, FreeBSD, which was
our first non-Linux OS to you.

00:26:56.090 --> 00:26:58.060
Now, we didn't
stop there though.

00:26:58.060 --> 00:27:01.352
We actually made the underlying
virtualization technology

00:27:01.352 --> 00:27:02.060
available to you.

00:27:02.060 --> 00:27:04.460
So that if you wanted to use
a different distribution,

00:27:04.460 --> 00:27:07.590
you can bring your own
distribution to Compute Engine.

00:27:07.590 --> 00:27:09.691
And today we're announcing
the limited preview

00:27:09.691 --> 00:27:11.190
of Windows supported
Compute Engine.

00:27:11.190 --> 00:27:13.110
So if you are one
of those developers

00:27:13.110 --> 00:27:15.810
who has a portion of
your, or frankly, all,

00:27:15.810 --> 00:27:17.850
of your infrastructure
running on Windows,

00:27:17.850 --> 00:27:22.490
you can now get that on
Compute Engine, as well.

00:27:22.490 --> 00:27:27.300
So App Engine, we haven't taken
our off the gas there either.

00:27:27.300 --> 00:27:30.050
So let's talk about some
of the changes we've made.

00:27:30.050 --> 00:27:32.820
We recently launched the
Modules capability App Engine,

00:27:32.820 --> 00:27:35.110
which lets you take
your App Engine app

00:27:35.110 --> 00:27:38.560
and build it in terms of a
number of different modules,

00:27:38.560 --> 00:27:39.800
components.

00:27:39.800 --> 00:27:43.140
And you can have each of these
components scale independently.

00:27:43.140 --> 00:27:44.840
You can have them
perform differently,

00:27:44.840 --> 00:27:46.669
have different performance
characteristics.

00:27:46.669 --> 00:27:48.710
You can even use different
programming languages.

00:27:48.710 --> 00:27:50.751
So let's say, you're in
a company where you have,

00:27:50.751 --> 00:27:54.420
you know, the people
who built the back end

00:27:54.420 --> 00:27:56.290
parts of the application
really like coding

00:27:56.290 --> 00:27:58.206
in Java and the people
who build the front end

00:27:58.206 --> 00:27:59.102
are all about Python.

00:27:59.102 --> 00:27:59.810
They can do that.

00:27:59.810 --> 00:28:02.260
You can build the two
different modules independently

00:28:02.260 --> 00:28:03.634
and have them talk
to each other.

00:28:03.634 --> 00:28:05.630
So you can actually
really get the benefits

00:28:05.630 --> 00:28:07.955
of componentization
and modulization

00:28:07.955 --> 00:28:08.830
for your application.

00:28:12.060 --> 00:28:14.480
Since we launched the php,
which is a fourth officially

00:28:14.480 --> 00:28:16.360
supported language
on App Engine,

00:28:16.360 --> 00:28:18.080
we've seen great traction.

00:28:18.080 --> 00:28:21.230
For example, Sony Music
used php on App Engine

00:28:21.230 --> 00:28:23.790
to serve back end for
One Direction Day, which

00:28:23.790 --> 00:28:27.320
was actually, the largest
streaming event on YouTube.

00:28:29.840 --> 00:28:32.220
Memcache is something
a lot of developers

00:28:32.220 --> 00:28:34.750
use to build scalability
and performance

00:28:34.750 --> 00:28:36.930
and acceleration for
the applications.

00:28:36.930 --> 00:28:39.410
And one of the things App
Engine has offered for while

00:28:39.410 --> 00:28:42.150
is access to a
shared Memcache pool

00:28:42.150 --> 00:28:44.239
where you can actually
get all those benefits

00:28:44.239 --> 00:28:46.030
without having to do
any advanced planning.

00:28:46.030 --> 00:28:48.170
So you just show up
and use memcache API

00:28:48.170 --> 00:28:49.862
and you have Memcache.

00:28:49.862 --> 00:28:52.070
But it turns out that for
some specific applications,

00:28:52.070 --> 00:28:53.611
you actually benefit
from the ability

00:28:53.611 --> 00:28:56.830
to do some of that planning and
get a dedicated pool so you can

00:28:56.830 --> 00:28:58.700
control the
performance parameters

00:28:58.700 --> 00:28:59.980
for your application.

00:28:59.980 --> 00:29:03.200
And so for those developers,
we launched Dedicated Memcache,

00:29:03.200 --> 00:29:06.764
which as of today, is now
$0.6 per gigabyte, per hour.

00:29:06.764 --> 00:29:08.430
And we've seen great
traction there too.

00:29:08.430 --> 00:29:11.740
We now have over 10 terabytes
of dedicated Memcache

00:29:11.740 --> 00:29:13.320
being served to our developers.

00:29:16.490 --> 00:29:21.240
Now again, we showed you a demo
of this in the keynote today,

00:29:21.240 --> 00:29:23.309
Git Push to Deploy, but
I wanted to kind of talk

00:29:23.309 --> 00:29:24.600
about the philosophy behind it.

00:29:24.600 --> 00:29:26.950
So really, we believe
that using tools

00:29:26.950 --> 00:29:29.520
that you're familiar with, and
being able to integrate those

00:29:29.520 --> 00:29:31.610
tightly with the
platform, gives you

00:29:31.610 --> 00:29:34.640
much, much faster
innovation cycles.

00:29:34.640 --> 00:29:37.180
It makes it much easier
to build the applications

00:29:37.180 --> 00:29:38.190
on the platform.

00:29:38.190 --> 00:29:41.000
And so Git Push to Deploy
capability effectively

00:29:41.000 --> 00:29:43.310
lets you connect
any Git repository

00:29:43.310 --> 00:29:45.310
to App Engine application.

00:29:45.310 --> 00:29:49.890
And have a Git Push
to come and deploy.

00:29:49.890 --> 00:29:52.590
And so you can iterate much
faster on App Engine using it

00:29:52.590 --> 00:29:54.830
Git Push to Deploy.

00:29:54.830 --> 00:29:58.840
OK, so today when
you come and try

00:29:58.840 --> 00:30:00.500
to build and application
in the Cloud,

00:30:00.500 --> 00:30:02.730
you're often faced
with a choice.

00:30:02.730 --> 00:30:06.045
Do you want to build the
application on infrastructure

00:30:06.045 --> 00:30:10.220
as a service, and get all the
benefits of a very flexible

00:30:10.220 --> 00:30:12.590
platform, but have to do a
lot of the plumbing yourself,

00:30:12.590 --> 00:30:13.089
right?

00:30:13.089 --> 00:30:16.770
You have to build a bunch of
management pieces yourself.

00:30:16.770 --> 00:30:19.970
Or, you could choose to build
on a platform as a service,

00:30:19.970 --> 00:30:21.772
and get a lot of
agility because you

00:30:21.772 --> 00:30:23.355
don't have to build
all that plumbing.

00:30:23.355 --> 00:30:25.313
You don't have to tweak
it, fine tune it, learn

00:30:25.313 --> 00:30:27.090
how to make it work
better for yourself,

00:30:27.090 --> 00:30:28.620
you just focus on your own code.

00:30:28.620 --> 00:30:30.990
But to do that, you have
to fit within a framework

00:30:30.990 --> 00:30:33.460
that the platform
provider defines.

00:30:33.460 --> 00:30:35.950
So that they can do all that
managment for you, right?

00:30:35.950 --> 00:30:38.033
That turns out that we
think that this is actually

00:30:38.033 --> 00:30:38.940
a flase dichotomy.

00:30:38.940 --> 00:30:40.769
It shouldn't have
to be a trade off.

00:30:40.769 --> 00:30:43.060
If what you want to be able
to do is focus on your code

00:30:43.060 --> 00:30:45.710
and not worry about
the mundane details

00:30:45.710 --> 00:30:49.070
that it takes to maintain
and run your application,

00:30:49.070 --> 00:30:51.070
you can do that
with a combination

00:30:51.070 --> 00:30:53.387
of several new technologies
we're launching today.

00:30:53.387 --> 00:30:55.470
Specifically, we think
that these technologies are

00:30:55.470 --> 00:30:58.160
the foundation of the next
Generation Cloud, where

00:30:58.160 --> 00:31:01.205
you get all the productivity,
all the art of management

00:31:01.205 --> 00:31:03.660
of platform as a
service, but you get that

00:31:03.660 --> 00:31:05.890
with the open and
flexible environment

00:31:05.890 --> 00:31:07.410
that [INAUDIBLE] provide.

00:31:07.410 --> 00:31:10.460
So to talk about some new
technology in that area,

00:31:10.460 --> 00:31:12.970
manage virtual machines,
deployment manager, and replica

00:31:12.970 --> 00:31:15.932
pools, I'd like to
invite Chris Ramsdale.

00:31:15.932 --> 00:31:20.697
[APPLAUSE]

00:31:20.697 --> 00:31:22.030
CHRIS RAMSDALE: Thanks, Navneet.

00:31:22.030 --> 00:31:24.050
As Navneet mentioned,
I'm a Product Manager

00:31:24.050 --> 00:31:25.560
for the Google Cloud Platform.

00:31:25.560 --> 00:31:27.832
I was up for the keynote
demoing Manage VMs today.

00:31:27.832 --> 00:31:29.290
And so what I'm
going to talk about

00:31:29.290 --> 00:31:32.630
is that technology plus
two others that we believe

00:31:32.630 --> 00:31:34.909
will, not only end this
false dichotomy where

00:31:34.909 --> 00:31:36.950
you have to select as a
customer, as a developer,

00:31:36.950 --> 00:31:39.730
between platform as a service
or infrastructure as a service,

00:31:39.730 --> 00:31:42.280
but also how we're going to
enhance developer productivity

00:31:42.280 --> 00:31:44.722
when building Cloud
based applications.

00:31:44.722 --> 00:31:46.680
So first of all, how many
App Engine developers

00:31:46.680 --> 00:31:49.080
do we have in the
crowd right now?

00:31:49.080 --> 00:31:49.990
OK, all right.

00:31:49.990 --> 00:31:52.406
How many of you are actually
building on virtual machines,

00:31:52.406 --> 00:31:54.820
as well, be it Amazon,
or [INAUDIBLE] or GC?

00:31:54.820 --> 00:31:56.236
OK, I'm going to
get a good blend.

00:31:56.236 --> 00:31:57.340
This great, this is great.

00:31:57.340 --> 00:31:58.200
OK so let me jump right in.

00:31:58.200 --> 00:31:59.741
One of the first
technologies that we

00:31:59.741 --> 00:32:02.057
had alluded to in the
keynote today is Manage VMs.

00:32:02.057 --> 00:32:04.140
With Manage VMs, you get
the control and the power

00:32:04.140 --> 00:32:06.500
and flexibility of
Compute Engine VMs

00:32:06.500 --> 00:32:10.060
mixed with, and combined with,
the proven auto management

00:32:10.060 --> 00:32:11.185
capabilities of App Engine.

00:32:11.185 --> 00:32:13.184
For example, say you're
an App Engine developer,

00:32:13.184 --> 00:32:14.680
you're building an application.

00:32:14.680 --> 00:32:16.263
Then suddenly, you
want to have access

00:32:16.263 --> 00:32:18.600
to a language or a library,
or some native resource,

00:32:18.600 --> 00:32:20.145
that you don't have access to.

00:32:20.145 --> 00:32:22.020
That a typical platform
as a service offering

00:32:22.020 --> 00:32:22.956
doesn't support.

00:32:22.956 --> 00:32:25.330
Now, typically what happens,
is you're pushed off a cliff

00:32:25.330 --> 00:32:27.121
into the infrastructure
as a service world.

00:32:27.121 --> 00:32:29.500
And you're left managing
all by yourself,

00:32:29.500 --> 00:32:31.250
in managing the
entire deployment.

00:32:31.250 --> 00:32:32.910
With Manage VMs
that's not the case.

00:32:32.910 --> 00:32:34.710
We can handle that
management for you.

00:32:34.710 --> 00:32:36.620
Alternatively, say you
start with a vanilla

00:32:36.620 --> 00:32:38.889
VM, an unmanaged Compute
Engine VM, for example.

00:32:38.889 --> 00:32:40.930
And you build out your
solution and it's running,

00:32:40.930 --> 00:32:43.140
and at some point in time
you want us to manage it.

00:32:43.140 --> 00:32:45.181
You can flip that unmanaged
VM to being a managed

00:32:45.181 --> 00:32:48.067
VM and Google Cloud
Platform takes over for you.

00:32:48.067 --> 00:32:49.650
And for more on that,
I encourage you,

00:32:49.650 --> 00:32:53.020
there's a session at 2:30 called
Runtime Yours, that our friend

00:32:53.020 --> 00:32:55.340
Andrew Jessup is giving with
the help of a few others

00:32:55.340 --> 00:32:57.854
you should definitely check out.

00:32:57.854 --> 00:32:59.645
But it's not just about
the openness there.

00:32:59.645 --> 00:33:02.220
It's not just about access
to the native resources

00:33:02.220 --> 00:33:03.780
or being able to
run native code.

00:33:03.780 --> 00:33:05.480
There's much more
to it, as well.

00:33:05.480 --> 00:33:07.250
With Manage VMs you
get Google SREs,

00:33:07.250 --> 00:33:09.500
you get a team of Sight
Reliable Engineers that

00:33:09.500 --> 00:33:12.160
are monitoring deployments,
co-locating them, and making

00:33:12.160 --> 00:33:14.242
sure everything's
running smoothly.

00:33:14.242 --> 00:33:16.450
Manage VMs has access to
all of our managed services.

00:33:16.450 --> 00:33:18.667
So Datastore, Task
Queues and Memcache.

00:33:18.667 --> 00:33:20.750
And furthermore, it's not
just about communication

00:33:20.750 --> 00:33:22.880
between your compute and
our managed services.

00:33:22.880 --> 00:33:24.480
It's about communication
between all

00:33:24.480 --> 00:33:26.430
of the compute units
inside your application,

00:33:26.430 --> 00:33:27.940
inside your project.

00:33:27.940 --> 00:33:30.075
For example, say you're
running a bit of your front

00:33:30.075 --> 00:33:31.560
ends in App Engine today.

00:33:31.560 --> 00:33:32.935
Maybe it's built
in Python, maybe

00:33:32.935 --> 00:33:35.117
it's built in PHP, who
knows, pick your runtime.

00:33:35.117 --> 00:33:36.950
But you've also got
some back end processing

00:33:36.950 --> 00:33:38.630
that's running on Manage VMs.

00:33:38.630 --> 00:33:40.220
Because we're
managing those VMs,

00:33:40.220 --> 00:33:42.431
our services and our
SRE team can make sure

00:33:42.431 --> 00:33:43.930
that everything is
co-located so you

00:33:43.930 --> 00:33:47.607
get low latency and improved
overall performance.

00:33:47.607 --> 00:33:49.565
And finally, it's about
developer productivity.

00:33:49.565 --> 00:33:52.270
And because of that, we've
brought all this technology

00:33:52.270 --> 00:33:54.479
and Manage VMs through our
Cloud SDK so you can get

00:33:54.479 --> 00:33:56.437
added via the command
line or developer consule

00:33:56.437 --> 00:33:57.420
as I showed today.

00:34:00.030 --> 00:34:01.995
The second technology
is Replica Pools.

00:34:01.995 --> 00:34:04.564
Replica Pools are in addition
to our core compute API.

00:34:04.564 --> 00:34:07.230
As Joe had mentioned earlier on,
one of the interesting problems

00:34:07.230 --> 00:34:08.370
that we had to
solve at Google, was

00:34:08.370 --> 00:34:10.703
how do you have declarative
management and reproduceable

00:34:10.703 --> 00:34:11.420
deployments.

00:34:11.420 --> 00:34:13.086
How do you build a
system that optimizes

00:34:13.086 --> 00:34:15.239
so that you don't have
special snowflakes?

00:34:15.239 --> 00:34:18.339
Turns out that Manage VMs
we did that as well, right?

00:34:18.339 --> 00:34:19.755
When we looked at
it and said, how

00:34:19.755 --> 00:34:21.463
can we take what we've
learned at Google,

00:34:21.463 --> 00:34:23.489
and bring that through
to external developers

00:34:23.489 --> 00:34:26.770
so that our customers could
use it in the same way we have?

00:34:26.770 --> 00:34:28.179
Replica Pools is just that.

00:34:28.179 --> 00:34:30.320
A consistent, easy
to use mechanism

00:34:30.320 --> 00:34:34.240
for getting homogeneous, fleet
of VMs running in production.

00:34:34.240 --> 00:34:35.739
All you have to do
as a developer is

00:34:35.739 --> 00:34:36.570
specify a template.

00:34:36.570 --> 00:34:39.230
That template
specifies a base image.

00:34:39.230 --> 00:34:41.654
A set of commands that
should be run in start up.

00:34:41.654 --> 00:34:44.070
Netowrk configuration, and the
initial number of instances

00:34:44.070 --> 00:34:45.215
that you want up and running.

00:34:45.215 --> 00:34:47.670
And with Replica Pools, much
like the rest of Google Cloud

00:34:47.670 --> 00:34:49.070
Platform, what
we're trying to do

00:34:49.070 --> 00:34:50.690
is take on some
of the complexity.

00:34:50.690 --> 00:34:52.096
And sometimes the
mundane task is

00:34:52.096 --> 00:34:53.929
running Cloud based
application, so that you

00:34:53.929 --> 00:34:59.250
can focus on applications, and
awesome end user experiences.

00:34:59.250 --> 00:35:01.750
And finally, because developer
productivity is near and dear

00:35:01.750 --> 00:35:04.070
to our heart, we're bringing
all this great technology

00:35:04.070 --> 00:35:06.520
through to our SDK via a new
component called Deployment

00:35:06.520 --> 00:35:07.511
Manager.

00:35:07.511 --> 00:35:09.552
With Deployment Manager,
you can take and specify

00:35:09.552 --> 00:35:12.889
end number of VMs to be
managed as a single unit.

00:35:12.889 --> 00:35:15.180
And with that single unit
you can apply a health model.

00:35:15.180 --> 00:35:17.030
So our system can then
take and do health

00:35:17.030 --> 00:35:18.446
checking against
that health model

00:35:18.446 --> 00:35:21.110
and healing when there's
an issue that arises.

00:35:21.110 --> 00:35:23.100
We also can specify an
auto-scaling policy so

00:35:23.100 --> 00:35:25.900
that our system can go and
stamp out new VMs as traffic

00:35:25.900 --> 00:35:29.500
increases, or as utilization
across CPU or memory

00:35:29.500 --> 00:35:31.390
increases as well.

00:35:31.390 --> 00:35:33.450
So we not only think
that it's an actual,

00:35:33.450 --> 00:35:35.408
not only do we think that
Development Manager--

00:35:35.408 --> 00:35:38.580
or Deployment Manager, excuse
me-- is a way for developers

00:35:38.580 --> 00:35:40.560
to interact with
complex environments.

00:35:40.560 --> 00:35:42.260
We also think it's
a very great way

00:35:42.260 --> 00:35:44.343
to get started with some
of these new capabilities

00:35:44.343 --> 00:35:45.935
or reducing to our platform.

00:35:45.935 --> 00:35:47.560
So those are the
three new technologies

00:35:47.560 --> 00:35:50.100
that we're announcing today
and talking about in terms

00:35:50.100 --> 00:35:52.560
of building Cloud
based applications.

00:35:52.560 --> 00:35:54.560
What I want to do is I
want to take a step back,

00:35:54.560 --> 00:35:56.360
and I want to look at
how we're transitioning

00:35:56.360 --> 00:35:57.901
from a binary decision
where you have

00:35:57.901 --> 00:36:00.100
to choose upfront how
much management you want,

00:36:00.100 --> 00:36:02.850
platform of service or
infrastructure as a service,

00:36:02.850 --> 00:36:05.370
and change that into a
spectrum of management options

00:36:05.370 --> 00:36:10.030
that you can choose from as
your application evolves.

00:36:10.030 --> 00:36:10.620
OK.

00:36:10.620 --> 00:36:13.370
So we take a look at the stack
with this new technology,

00:36:13.370 --> 00:36:15.870
we see that we actually have a
collection of tiered services

00:36:15.870 --> 00:36:17.340
that layer on top of each other.

00:36:17.340 --> 00:36:20.520
At the lowest level, you've
got the best of breed VMs

00:36:20.520 --> 00:36:22.360
with compute engine
VMs where you're

00:36:22.360 --> 00:36:24.070
managing the rest of the stack.

00:36:24.070 --> 00:36:26.570
Maybe it's you, maybe you are
using open source technologies

00:36:26.570 --> 00:36:28.530
like Chef, Puppet, or
SaltStack, but you're

00:36:28.530 --> 00:36:30.699
managing that portion.

00:36:30.699 --> 00:36:32.240
Or you decide that
you want, you know

00:36:32.240 --> 00:36:34.390
what, I want Google to
manage my deployments.

00:36:34.390 --> 00:36:35.690
So via Replica Pools.

00:36:35.690 --> 00:36:37.065
So we're managing
the deployments

00:36:37.065 --> 00:36:39.482
and you're managing things
like the OS updates, security

00:36:39.482 --> 00:36:40.940
patches, and maybe
you're deploying

00:36:40.940 --> 00:36:43.359
some kind of centralized
logging and monitoring.

00:36:43.359 --> 00:36:45.150
But let's say you want
out of that business

00:36:45.150 --> 00:36:46.640
as well, moving up the stack.

00:36:46.640 --> 00:36:48.349
You can have Google Manager VMs.

00:36:48.349 --> 00:36:49.890
At this point in
time, we're managing

00:36:49.890 --> 00:36:51.015
everything underneath that.

00:36:51.015 --> 00:36:52.432
And what you're
really focusing on

00:36:52.432 --> 00:36:54.765
is managing the software
that's running inside of there.

00:36:54.765 --> 00:36:57.090
So maybe it's your serving
stack, maybe it's engine x,

00:36:57.090 --> 00:36:58.946
whatever you may want.

00:36:58.946 --> 00:37:00.570
But then for some
workloads, you really

00:37:00.570 --> 00:37:02.750
just want to focus on the
application and the end user

00:37:02.750 --> 00:37:04.875
experience and you want to
let Google manage pretty

00:37:04.875 --> 00:37:06.225
much the entire stack below you.

00:37:06.225 --> 00:37:07.725
And it's at this
level you're really

00:37:07.725 --> 00:37:10.620
taking advantage of the benefits
of platform as a service.

00:37:10.620 --> 00:37:13.580
You get auto updated
software, integrated APIs,

00:37:13.580 --> 00:37:15.570
and smart defaults.

00:37:15.570 --> 00:37:16.195
Right?

00:37:16.195 --> 00:37:18.070
But because these are
running on managed VMs,

00:37:18.070 --> 00:37:20.000
you're not losing that
control and that power

00:37:20.000 --> 00:37:21.440
of the underlying
infrastructure.

00:37:21.440 --> 00:37:24.560
You can always get at the native
network, native network stack,

00:37:24.560 --> 00:37:27.594
or the file system,
or run native code.

00:37:27.594 --> 00:37:29.760
So what we do is, and,
looking at this holistically,

00:37:29.760 --> 00:37:31.218
we believe that
we're shifting away

00:37:31.218 --> 00:37:34.190
from having developers
have to choose upfront

00:37:34.190 --> 00:37:35.750
how much management they want.

00:37:35.750 --> 00:37:38.240
And as their
application evolves,

00:37:38.240 --> 00:37:40.310
they can switch the
amount of management

00:37:40.310 --> 00:37:42.930
that they have, moving
between these various tiers,

00:37:42.930 --> 00:37:44.700
so that evolves with
your application,

00:37:44.700 --> 00:37:48.261
without you having to do a huge
code rewrite or refactoring.

00:37:48.261 --> 00:37:50.385
So that's a bunch of me
talking, a bunch of slides,

00:37:50.385 --> 00:37:51.496
so to see this in
action, I'm going

00:37:51.496 --> 00:37:53.871
to bring up one of our amazing
Developer Advocates, Brian

00:37:53.871 --> 00:37:56.330
Dorsey.

00:37:56.330 --> 00:37:57.668
BRIAN DORSEY: Thank you, sir.

00:37:57.668 --> 00:37:59.210
Hello everybody.

00:37:59.210 --> 00:38:00.700
It's almost demo time.

00:38:00.700 --> 00:38:05.130
OK, so after all of
these really big ideas,

00:38:05.130 --> 00:38:07.450
we need a really
big demo, right?

00:38:07.450 --> 00:38:10.920
So sudoku, how do you
get bigger than that?

00:38:10.920 --> 00:38:13.180
It's this international,
world sensation.

00:38:13.180 --> 00:38:14.760
It's big in Japan.

00:38:14.760 --> 00:38:17.510
If you haven't seen
sudoku, it's actually

00:38:17.510 --> 00:38:19.760
a fill in the blank puzzle game.

00:38:19.760 --> 00:38:22.770
Got numbers, just don't repeat
them horizontally, vertically,

00:38:22.770 --> 00:38:24.160
or in the same square, right?

00:38:24.160 --> 00:38:28.599
So let's use Google Cloud
to play some Sudoku.

00:38:28.599 --> 00:38:30.390
So first off, we need
to teach the computer

00:38:30.390 --> 00:38:31.920
to actually solve Sudoku.

00:38:31.920 --> 00:38:34.980
And we're lucky there because
Peter Norvig, the gentleman who

00:38:34.980 --> 00:38:39.290
actually wrote the book on
AI, wrote this fantastic essay

00:38:39.290 --> 00:38:41.110
that I highly recommend
you take a look at.

00:38:41.110 --> 00:38:43.190
And it walks through
all the permutations

00:38:43.190 --> 00:38:46.200
of how to write a Sudoku solver
in Python, including code,

00:38:46.200 --> 00:38:48.100
so we've got that, awesome.

00:38:48.100 --> 00:38:49.970
But what I'd like
to do, is actually

00:38:49.970 --> 00:38:52.960
solve like, real
physical puzzles, right?

00:38:52.960 --> 00:38:54.955
Like I want to take this
puzzle and solve it.

00:38:54.955 --> 00:38:57.080
So we've got to get this
into the computer somehow.

00:38:57.080 --> 00:38:58.640
And that means computer vision.

00:38:58.640 --> 00:39:00.690
So we're lucky there as well.

00:39:00.690 --> 00:39:03.630
There's a fantastic
library called OpenCV,

00:39:03.630 --> 00:39:07.850
that is a collection of computer
vision algorithms written in C

00:39:07.850 --> 00:39:09.030
and C++.

00:39:09.030 --> 00:39:10.469
So I should be
good to go, right?

00:39:10.469 --> 00:39:12.260
I'll just mash those
together and I'm done.

00:39:15.040 --> 00:39:16.810
And this hits that
like, classic dilemma,

00:39:16.810 --> 00:39:19.030
that we've talked about like
in the keynote and stage here,

00:39:19.030 --> 00:39:21.030
and as a developer, I
run into it all the time.

00:39:21.030 --> 00:39:23.690
I want it to be really
easy to get my stuff out.

00:39:23.690 --> 00:39:27.960
I want it to be really reliable,
automatically maintained.

00:39:27.960 --> 00:39:30.620
But at some point, you run into
a wall with whatever system

00:39:30.620 --> 00:39:31.520
you're using.

00:39:31.520 --> 00:39:34.591
And in this case, the wall
is that I need this C and C++

00:39:34.591 --> 00:39:35.090
library.

00:39:35.090 --> 00:39:38.220
So even if I had the whole
thing written on App Engine,

00:39:38.220 --> 00:39:41.150
I still have a place to run
this computer vision code.

00:39:41.150 --> 00:39:42.900
And so I can run that
on Compute Engine.

00:39:42.900 --> 00:39:44.191
It's going to run great.

00:39:44.191 --> 00:39:45.690
But then I've kind
of signed back up

00:39:45.690 --> 00:39:48.260
for all of the maintenance
and automation.

00:39:48.260 --> 00:39:52.530
So that's why I'm just super
excited about Managed VMs.

00:39:52.530 --> 00:39:56.100
So here's what this looks like,
the Sudoku solver in the cloud.

00:39:56.100 --> 00:39:57.780
We've got App Engine,
it's a web app.

00:39:57.780 --> 00:40:00.380
So App Engine is handling all
of the regular apps serving

00:40:00.380 --> 00:40:01.800
HTTP and that sort of thing.

00:40:01.800 --> 00:40:03.665
We've got a special
URL that accepts

00:40:03.665 --> 00:40:06.270
an image as a foreign post.

00:40:06.270 --> 00:40:08.880
And that ends up going
back into task queues,

00:40:08.880 --> 00:40:11.380
and then we run the
actual computer vision

00:40:11.380 --> 00:40:12.690
on Compute Engine.

00:40:12.690 --> 00:40:16.100
So awesome.

00:40:16.100 --> 00:40:19.370
From the developer prospective,
what that looks like is,

00:40:19.370 --> 00:40:21.840
the front end part is
regular App Engine.

00:40:21.840 --> 00:40:25.920
So we've got an app.yaml
here, standard, normal thing.

00:40:25.920 --> 00:40:29.610
On this side, we have what
managed VMs looks like.

00:40:29.610 --> 00:40:31.740
And there's very few changes.

00:40:31.740 --> 00:40:33.527
We're using modules,
the same bit that

00:40:33.527 --> 00:40:35.360
lets you use different
programming languages

00:40:35.360 --> 00:40:37.400
or different performance
characteristics.

00:40:37.400 --> 00:40:39.970
And this extra line,
VM equals true,

00:40:39.970 --> 00:40:41.970
which tells the
infrastructure, by the way,

00:40:41.970 --> 00:40:45.700
deploy this code to
VMs and run it for me.

00:40:45.700 --> 00:40:48.130
And there's another
file that lets

00:40:48.130 --> 00:40:51.680
you say what URLs
go to which module.

00:40:51.680 --> 00:40:54.250
So then this is the actual
script where my code is.

00:40:54.250 --> 00:40:59.440
And down at the bottom is the
key and most important part.

00:40:59.440 --> 00:41:01.500
But that's where
we specify which

00:41:01.500 --> 00:41:03.162
Compute Engine machines we use.

00:41:03.162 --> 00:41:05.370
So we can choose any kind
of Compute Engine instance,

00:41:05.370 --> 00:41:09.080
you know, 1, 2,
4, 8 CPUs or more.

00:41:09.080 --> 00:41:11.990
You can say I need a
high CPU, or high memory,

00:41:11.990 --> 00:41:14.191
to do this workload.

00:41:14.191 --> 00:41:17.350
And at the bottom, you
can actually just say,

00:41:17.350 --> 00:41:21.820
list your dependencies as
app to get install line.

00:41:21.820 --> 00:41:25.500
So in this case, I want to have
the Python bindings for open CV

00:41:25.500 --> 00:41:27.270
and everything it needs.

00:41:27.270 --> 00:41:29.869
And I just put one line there
and Python open CV and it

00:41:29.869 --> 00:41:32.244
brings in like the 30+ shared
libraries and everything it

00:41:32.244 --> 00:41:33.030
needs.

00:41:33.030 --> 00:41:35.190
So OK.

00:41:35.190 --> 00:41:36.490
And then its deployment time.

00:41:36.490 --> 00:41:39.130
So you've got one command,
and deploys your whole app

00:41:39.130 --> 00:41:40.000
to a given version.

00:41:40.000 --> 00:41:41.190
You've got all the
App Engine goodness

00:41:41.190 --> 00:41:43.280
where you can say OK, this
version is good enough.

00:41:43.280 --> 00:41:45.600
Let's make that
the production one.

00:41:45.600 --> 00:41:47.150
And let's go to the slides.

00:41:47.150 --> 00:41:49.400
Or I'm sorry, let's
go to the demo.

00:41:49.400 --> 00:41:50.550
OK.

00:41:50.550 --> 00:41:53.250
So on demo, and
here we we've got

00:41:53.250 --> 00:41:54.700
a Web App it's a real Web App.

00:41:54.700 --> 00:41:56.420
This is our Sudoku Solver.

00:41:56.420 --> 00:41:58.005
I've got a webcam hooked up.

00:41:58.005 --> 00:41:59.730
Hello everyone.

00:41:59.730 --> 00:42:04.670
And right here, if we pull
the cord out of the way,

00:42:04.670 --> 00:42:08.696
we will try to get
an actual image

00:42:08.696 --> 00:42:10.070
that we're going
to try to solve.

00:42:10.070 --> 00:42:11.570
So we've got this image.

00:42:11.570 --> 00:42:13.130
And it's saved there.

00:42:13.130 --> 00:42:15.280
And when I hit Solve
here, it's going

00:42:15.280 --> 00:42:17.396
to send that off the App Engine.

00:42:17.396 --> 00:42:18.770
It goes through
this architecture

00:42:18.770 --> 00:42:21.760
we talked about, hits the task
queue, hits Compute Engine,

00:42:21.760 --> 00:42:24.090
saves it in Cloud
Storage, and goes online.

00:42:24.090 --> 00:42:27.190
So moment of truth, we hit
the button, send it on out,

00:42:27.190 --> 00:42:28.350
and solved.

00:42:28.350 --> 00:42:34.725
[APPLAUSE]

00:42:34.725 --> 00:42:36.600
So this is a probably
my life solved forever.

00:42:36.600 --> 00:42:39.230
I never have to solve
another Sudoku puzzle.

00:42:39.230 --> 00:42:41.910
We're good.

00:42:41.910 --> 00:42:44.244
So that's pretty cool.

00:42:44.244 --> 00:42:45.910
But I just wanted to
kind of poke around

00:42:45.910 --> 00:42:47.701
behind the scenes a
little bit and show you

00:42:47.701 --> 00:42:48.640
what this looks like.

00:42:48.640 --> 00:42:50.887
So this is our
developer's console.

00:42:50.887 --> 00:42:52.970
And we're down in the
Compute Engine section here.

00:42:52.970 --> 00:42:54.850
And so we can
actually see, we have

00:42:54.850 --> 00:42:56.980
a couple of running instances.

00:42:56.980 --> 00:42:59.240
And that's this demo
actually running.

00:42:59.240 --> 00:43:01.790
We can take a look in
a particular instance,

00:43:01.790 --> 00:43:04.960
see different things
about it, get its name,

00:43:04.960 --> 00:43:06.970
that we're going to
need here in a moment.

00:43:06.970 --> 00:43:09.860
And let's dive to
the command line.

00:43:09.860 --> 00:43:12.140
And we're still
connected, awesome.

00:43:12.140 --> 00:43:14.540
So they talked
earlier about how--

00:43:14.540 --> 00:43:16.640
so these are manage VMs, right?

00:43:16.640 --> 00:43:19.470
The Google infrastructure
runs these VMs for you,

00:43:19.470 --> 00:43:21.670
so you don't really want
them to be different.

00:43:21.670 --> 00:43:22.967
We don't want snowflakes here.

00:43:22.967 --> 00:43:25.550
So but sometimes, you want to
go take a look under the covers,

00:43:25.550 --> 00:43:27.174
and see what things
actually look like.

00:43:27.174 --> 00:43:28.840
So there's a command for that.

00:43:28.840 --> 00:43:30.167
glcloud computer debug.

00:43:30.167 --> 00:43:31.750
And then give it the
current directory

00:43:31.750 --> 00:43:33.080
that you're working in.

00:43:33.080 --> 00:43:35.620
And it will go out and
say, OK, these guys

00:43:35.620 --> 00:43:38.030
are ready for debugging.

00:43:38.030 --> 00:43:44.860
And we can SSH into this
instance that we got there.

00:43:44.860 --> 00:43:49.457
Connects off and, just to
prove it, look at that.

00:43:49.457 --> 00:43:50.415
We're in this instance.

00:43:52.930 --> 00:43:53.860
And it's ready to go.

00:43:53.860 --> 00:43:56.900
So now, being a
developer, right?

00:43:56.900 --> 00:43:59.190
I like to have environments
look a certain way.

00:43:59.190 --> 00:44:07.870
So I might go apt-get
install tmux, or maybe vim.

00:44:07.870 --> 00:44:10.480
Go ahead and kind of get
things in there a little bit.

00:44:10.480 --> 00:44:13.160
It's also a real virtual
machine with all,

00:44:13.160 --> 00:44:15.550
and a Google Cloud
computer-- Compute Engine

00:44:15.550 --> 00:44:19.110
virtual machine, with all
of our security set up,

00:44:19.110 --> 00:44:21.020
the way it works-- easy for you.

00:44:21.020 --> 00:44:27.040
So I can use gsutil
and pull a file down

00:44:27.040 --> 00:44:32.320
from Cloud Storage that contains
my tmux config, because I

00:44:32.320 --> 00:44:34.900
like things this way.

00:44:34.900 --> 00:44:36.940
And I have to type
the command correctly.

00:44:36.940 --> 00:44:38.626
Software.

00:44:38.626 --> 00:44:41.390
And I bring that
down, run tmux, I'm

00:44:41.390 --> 00:44:45.610
all in, ready to do some
looking around this machine.

00:44:45.610 --> 00:44:56.085
So let's first off, we'll
go into var/log/app.engine

00:44:56.085 --> 00:44:58.480
and look around there.

00:44:58.480 --> 00:45:01.040
We can use vim, go and take
a look at the request log.

00:45:01.040 --> 00:45:03.080
See a bunch of help
checks coming through.

00:45:03.080 --> 00:45:05.920
That looks pretty OK.

00:45:05.920 --> 00:45:08.550
Maybe we want to see
how the network like.

00:45:08.550 --> 00:45:10.830
So what's going
on in the network?

00:45:10.830 --> 00:45:14.170
So sudo apt-get install.

00:45:14.170 --> 00:45:17.499
And we'll look at
iftop, for example.

00:45:17.499 --> 00:45:18.165
Bring that down.

00:45:21.310 --> 00:45:24.390
Kind of run, we need
to be root to do that.

00:45:24.390 --> 00:45:26.750
Run iftop, kind
of see how things

00:45:26.750 --> 00:45:28.170
are going in the backend.

00:45:28.170 --> 00:45:29.961
You can see a little
bit of activity there,

00:45:29.961 --> 00:45:31.120
but nothing unusual.

00:45:31.120 --> 00:45:35.270
I keep debugging,
[INAUDIBLE], and we'll just

00:45:35.270 --> 00:45:37.410
assume that I look
through here and notice

00:45:37.410 --> 00:45:41.220
it's really my code, as it
usually is, eating all the CPU.

00:45:41.220 --> 00:45:44.890
So I'm going to go back
and like, fix my code.

00:45:44.890 --> 00:45:46.720
And that pretty
much wraps it up.

00:45:46.720 --> 00:45:48.337
Wait, you just
created a snowflake.

00:45:48.337 --> 00:45:50.170
You installed a bunch
of stuff on a machine,

00:45:50.170 --> 00:45:52.060
and like, that might
break something.

00:45:52.060 --> 00:45:53.132
Oh, I did.

00:45:53.132 --> 00:45:55.090
I think this will be OK,
I didn't do that much.

00:45:55.090 --> 00:45:55.994
Like--

00:45:55.994 --> 00:45:57.844
That's how this happens.

00:45:57.844 --> 00:45:59.510
That's how you get
yourself into trouble

00:45:59.510 --> 00:46:00.570
OK, point taken.

00:46:00.570 --> 00:46:02.320
I've made that mistake before.

00:46:02.320 --> 00:46:04.290
So how do we fix this?

00:46:04.290 --> 00:46:06.500
Basically, here's this
instance we have, again.

00:46:06.500 --> 00:46:08.750
And so I can go
down to the bottom

00:46:08.750 --> 00:46:12.070
and just click Delete
amd really delete this.

00:46:12.070 --> 00:46:15.260
And trust that the Manage VMs
infrastructure will start up

00:46:15.260 --> 00:46:17.660
new ones to run the right
number of instances.

00:46:17.660 --> 00:46:19.330
So it's all good to go.

00:46:19.330 --> 00:46:20.980
So back to the slides.

00:46:20.980 --> 00:46:25.210
And so here is what
that looked like.

00:46:25.210 --> 00:46:26.830
So we take things in.

00:46:26.830 --> 00:46:30.140
App Engine handles all
of the main web requests.

00:46:30.140 --> 00:46:32.570
So this is regular App Engine
auto-scaling, scaling up

00:46:32.570 --> 00:46:34.710
to all the things
you've seen before.

00:46:34.710 --> 00:46:38.595
We create a buffer in task
queues, so that you know,

00:46:38.595 --> 00:46:40.970
if we get a sudden load spike
and then it goes right back

00:46:40.970 --> 00:46:43.340
down, we can kind of, have
a few more things there.

00:46:43.340 --> 00:46:46.190
And then we're using
application specific scaling

00:46:46.190 --> 00:46:48.260
on the Sudoku solvers
side of things.

00:46:48.260 --> 00:46:51.450
And what that looks like
in code, it's really easy.

00:46:51.450 --> 00:46:53.400
I basically just make
a one call and say,

00:46:53.400 --> 00:46:55.270
I want this many
instances running.

00:46:55.270 --> 00:46:58.100
So what I can do is I can watch
the stats on that task queue,

00:46:58.100 --> 00:47:00.510
for example, and say
oh, it's gotten behind,

00:47:00.510 --> 00:47:01.890
let's start some more instances.

00:47:01.890 --> 00:47:04.550
Or it's all caught up, we
can shut some more down.

00:47:04.550 --> 00:47:05.289
So there we go.

00:47:05.289 --> 00:47:06.080
Thank you very much

00:47:06.080 --> 00:47:14.080
[APPLAUSE]

00:47:14.080 --> 00:47:15.410
NAVNEET JONEJA: Thanks, Brian.

00:47:15.410 --> 00:47:16.910
So let me just
quickly wrap this up.

00:47:16.910 --> 00:47:17.920
What did we learn today?

00:47:17.920 --> 00:47:20.491
So Joe talked about how we
build applications at Google.

00:47:20.491 --> 00:47:20.990
[COUGH]

00:47:20.990 --> 00:47:23.260
Pardon me.

00:47:23.260 --> 00:47:25.343
He talked about a
number of the patterns

00:47:25.343 --> 00:47:27.640
that we found to
work really well.

00:47:27.640 --> 00:47:30.700
Like, for example, storing
your data on the network.

00:47:30.700 --> 00:47:33.480
Like making sure you avoid
snowflakes, thanks Brian

00:47:33.480 --> 00:47:34.970
and Joe.

00:47:34.970 --> 00:47:39.590
Making sure that fundamentally,
that you try to leverage

00:47:39.590 --> 00:47:41.340
as much as possible
the learning of people

00:47:41.340 --> 00:47:43.500
that came before you
by leveraging platforms

00:47:43.500 --> 00:47:47.190
that embody what
they've learned.

00:47:47.190 --> 00:47:50.360
And you know, we'll
continue to share details

00:47:50.360 --> 00:47:53.270
about that software, we
will continue to do so.

00:47:53.270 --> 00:47:54.730
We also talked
about how we believe

00:47:54.730 --> 00:47:56.350
that the choice
between infrastructure

00:47:56.350 --> 00:47:58.740
as a service and flexibility.

00:47:58.740 --> 00:48:03.470
And pass, and sort of
time to market and develop

00:48:03.470 --> 00:48:05.730
a productivity is
actually a false choice.

00:48:05.730 --> 00:48:08.790
And we're going to keep
making that something

00:48:08.790 --> 00:48:12.830
that you don't have to worry
about in the days to come.

00:48:12.830 --> 00:48:15.560
We talked about several products
that make this vision of ours

00:48:15.560 --> 00:48:16.060
a reality.

00:48:16.060 --> 00:48:19.010
Manage VMs, we talked
about Deployment Manager.

00:48:19.010 --> 00:48:21.680
And Replica Pools that are
different levels of abstraction

00:48:21.680 --> 00:48:24.900
and different levels
of detail that you

00:48:24.900 --> 00:48:27.345
employ some of the patterns
that Joe talked about.

00:48:27.345 --> 00:48:28.720
And then I just
want to leave you

00:48:28.720 --> 00:48:30.640
with one thought, which is that
we're just getting started.

00:48:30.640 --> 00:48:32.140
What you've seen today
is just the beginning.

00:48:32.140 --> 00:48:34.120
There's lots more to come
from us in the days and months

00:48:34.120 --> 00:48:34.814
to come.

00:48:34.814 --> 00:48:36.730
We'd love to have you
come and sign up and try

00:48:36.730 --> 00:48:40.747
Manage VMs, the URL for
that is on the screen.

00:48:40.747 --> 00:48:42.830
And we've also pulled
together some resources that

00:48:42.830 --> 00:48:46.747
go into more detail about the
subjects that Joe talked about,

00:48:46.747 --> 00:48:49.080
as well as some of the products
that we announced today,

00:48:49.080 --> 00:48:51.577
that URL is on the
screen right now.

00:48:51.577 --> 00:48:52.410
Thank you very much.

00:48:52.410 --> 00:48:54.326
And we've love to take
any questions you have.

00:48:54.326 --> 00:49:07.459
[APPLAUSE]

00:49:10.880 --> 00:49:14.000
AUDIENCE: So you've
talked a lot about VMs,

00:49:14.000 --> 00:49:16.740
nobody has said a
word about containers.

00:49:16.740 --> 00:49:19.630
Do you envision making
containerization

00:49:19.630 --> 00:49:25.330
a mode which could be available
on the Cloud infrastructure.

00:49:25.330 --> 00:49:27.680
JOE BEDA: We've been
looking really closely

00:49:27.680 --> 00:49:29.380
at all the technology
that's been

00:49:29.380 --> 00:49:30.610
developing around containers.

00:49:30.610 --> 00:49:35.650
And in fact, Google
actually submitted a bunch

00:49:35.650 --> 00:49:37.340
of that technology
upstream in terms

00:49:37.340 --> 00:49:39.100
of sea groups,
that was originally

00:49:39.100 --> 00:49:40.880
something that was
built inside of Google.

00:49:40.880 --> 00:49:43.280
And we think it's
a perfect fit for

00:49:43.280 --> 00:49:44.530
those repeatable deployments.

00:49:44.530 --> 00:49:46.940
And so I think it's still early.

00:49:46.940 --> 00:49:48.790
People are still
getting used to that.

00:49:48.790 --> 00:49:51.290
I mean, we've been doing that
type of stuff inside of Google

00:49:51.290 --> 00:49:52.780
all the time.

00:49:52.780 --> 00:49:54.620
But it's super complementary.

00:49:54.620 --> 00:49:55.500
And so yeah.

00:49:55.500 --> 00:49:58.530
I think it's a great technique,
and using those in conjunction

00:49:58.530 --> 00:50:02.560
with the stuff that we're doing
here is a great way to go.

00:50:02.560 --> 00:50:04.450
CHRIS RAMSDALE: And I
had mentioned this this

00:50:04.450 --> 00:50:07.350
when I was speaking that there
is a session called Runtime

00:50:07.350 --> 00:50:09.387
Yours, that's scheduled
at 2:30, where

00:50:09.387 --> 00:50:11.595
we talk a little bit about
some of these technologies

00:50:11.595 --> 00:50:14.191
we are looking at, and how they
might work with our platform.

00:50:14.191 --> 00:50:16.440
So I encourage you, if
interested, to go check it out.

00:50:19.120 --> 00:50:19.995
BRIAN DORSEY: Others?

00:50:27.790 --> 00:50:30.880
AUDIENCE:You listed several
different levels of management

00:50:30.880 --> 00:50:32.220
for VMs.

00:50:32.220 --> 00:50:35.287
Is the pricing per hour
the same on all those?

00:50:35.287 --> 00:50:36.370
CHRIS RAMSDALE: Yes it is.

00:50:36.370 --> 00:50:37.203
AUDIENCE: Thank you.

00:50:39.776 --> 00:50:41.900
JOE BEDA: There's a couple
questions up front here.

00:50:45.500 --> 00:50:46.000
You up here.

00:50:49.700 --> 00:50:51.390
Thanks for waiting
for the mic, guys.

00:50:51.390 --> 00:50:54.010
Make it easier for everybody
who's listening remotely.

00:50:54.010 --> 00:50:56.570
AUDIENCE: Is there a
story for get to deploy

00:50:56.570 --> 00:51:00.304
for Compute Engine
and or Managed VMs?

00:51:00.304 --> 00:51:01.970
CHRIS RAMSDALE: Yes,
so that's something

00:51:01.970 --> 00:51:02.900
that we're working on.

00:51:02.900 --> 00:51:04.960
So what you've seen
today was git push deploy

00:51:04.960 --> 00:51:06.457
going to app engine.

00:51:06.457 --> 00:51:08.040
But clearly, the
next path we're going

00:51:08.040 --> 00:51:09.480
to go down, since a
lot of this is running

00:51:09.480 --> 00:51:11.660
through the same deployment
architecture, this

00:51:11.660 --> 00:51:12.840
is the whole idea of
convergence, right?

00:51:12.840 --> 00:51:15.280
When we converge and it actually
works for any compute unit

00:51:15.280 --> 00:51:16.190
that we have at Google.

00:51:16.190 --> 00:51:17.648
So the next steps
on the roadmap is

00:51:17.648 --> 00:51:20.535
to work with unmanaged Compute
Engine VMs and managed VMs

00:51:20.535 --> 00:51:21.910
that we were
talking about today.

00:51:30.209 --> 00:51:31.750
AUDIENCE: Yeah, just
a quick question

00:51:31.750 --> 00:51:34.740
about the endpoints,
the RESTful API.

00:51:34.740 --> 00:51:36.350
Is that only at the
App Engine level?

00:51:36.350 --> 00:51:39.134
Or does the VM also include,
that was a little bit unclear.

00:51:39.134 --> 00:51:41.300
JOE BEDA:Well currently,
Cloud Endpoint is something

00:51:41.300 --> 00:51:44.550
that's only available
through App Engine,

00:51:44.550 --> 00:51:46.960
through the App Engine,
sort of, front door.

00:51:46.960 --> 00:51:49.010
But that's the type
of thing that we'd

00:51:49.010 --> 00:51:51.520
be looking at expanding.

00:51:51.520 --> 00:51:52.604
Nothing ready to announce.

00:51:52.604 --> 00:51:54.603
BRIAN DORSEY: But you can
use the same technique

00:51:54.603 --> 00:51:57.220
that we did the Sudoku solver
to have the endpoints cooperate

00:51:57.220 --> 00:51:59.386
with workloads that are
also running on Managed VMs.

00:51:59.386 --> 00:52:01.469
AUDIENCE: But then you're
stuck with the languages

00:52:01.469 --> 00:52:02.260
that you have.

00:52:02.260 --> 00:52:04.060
BRIAN DORSEY: For that
actual part, right.

00:52:04.060 --> 00:52:05.851
NAVNEET JONEJA: For
the front end, correct.

00:52:05.851 --> 00:52:07.740
Yes.

00:52:07.740 --> 00:52:09.490
JOE BEDA: Any, may be
blocked by a pillar,

00:52:09.490 --> 00:52:11.292
there we go, a
couple over there.

00:52:11.292 --> 00:52:12.750
NAVNEET JONEJA: We
have, over here.

00:52:12.750 --> 00:52:13.250
In the blue.

00:52:17.440 --> 00:52:21.040
AUDIENCE: Just a clarification
on that question, they said,

00:52:21.040 --> 00:52:25.109
so when you do on VMs, any
changes, like packages,

00:52:25.109 --> 00:52:26.400
installs, and things like that.

00:52:26.400 --> 00:52:30.200
Is the-- how do you
manage that today?

00:52:30.200 --> 00:52:33.310
Do you have, like let's say if
you did something on the VMs

00:52:33.310 --> 00:52:35.110
and you now have
to deploy new VM,

00:52:35.110 --> 00:52:37.754
how do you save it back
and then laucnh a new VM.

00:52:37.754 --> 00:52:38.670
CHRIS RAMSDALE: Right.

00:52:38.670 --> 00:52:40.060
So it's a really question.

00:52:40.060 --> 00:52:42.500
So the typical life cycle
that we're encouraging here

00:52:42.500 --> 00:52:44.955
is, that you start with
Declarative Management,

00:52:44.955 --> 00:52:46.470
that I've shown a
couple of times,

00:52:46.470 --> 00:52:47.780
the Brian showed as well.

00:52:47.780 --> 00:52:50.072
To say, this is what I
want running on these VMs.

00:52:50.072 --> 00:52:52.030
And assuming there's no
problems, that's great.

00:52:52.030 --> 00:52:53.195
We're looking into ways
that we can turn that

00:52:53.195 --> 00:52:55.820
into a static binary that we can
easily scale up and scale down

00:52:55.820 --> 00:52:57.140
and things like that.

00:52:57.140 --> 00:52:59.779
In the case that you do want
to debug those VMs and SSH

00:52:59.779 --> 00:53:01.820
and do something like
Brian did where you've got,

00:53:01.820 --> 00:53:05.460
you know, various open source
technologies running on there.

00:53:05.460 --> 00:53:07.425
We expect that you'll
either, for example,

00:53:07.425 --> 00:53:09.550
if you're debugging, you
figure out what's going on

00:53:09.550 --> 00:53:11.300
and you make that
change locally.

00:53:11.300 --> 00:53:16.000
And, or doing, or in your
git repository, for example.

00:53:16.000 --> 00:53:18.360
And then once that's
done, you do a push.

00:53:18.360 --> 00:53:20.300
And because these
Managed VMs are funneling

00:53:20.300 --> 00:53:21.966
through the same
deployment architecture

00:53:21.966 --> 00:53:23.430
that App Engine
has, you get things

00:53:23.430 --> 00:53:27.580
like, versioning out the
box, rolling deployments,

00:53:27.580 --> 00:53:30.510
the ability to canary traffic,
shift it, do a slow roll out,

00:53:30.510 --> 00:53:31.390
things like that.

00:53:31.390 --> 00:53:33.390
But the idea is that you
go into those machines,

00:53:33.390 --> 00:53:34.463
you figure out
what's going on, you

00:53:34.463 --> 00:53:36.212
figure there's a problem
with one of them.

00:53:36.212 --> 00:53:38.862
And say, one of a fleet of say,
10 or 20, whatever it may be.

00:53:38.862 --> 00:53:40.570
And say OK, I've got
it, this is probably

00:53:40.570 --> 00:53:42.420
systemic across my entire fleet.

00:53:42.420 --> 00:53:44.878
I'm going to change it locally,
store wherever you need to,

00:53:44.878 --> 00:53:46.580
do a push that
revs your version,

00:53:46.580 --> 00:53:48.614
test it out, do a
slow deployment over,

00:53:48.614 --> 00:53:49.530
and you're good to go.

00:53:49.530 --> 00:53:53.780
And then you can get rid of
the minus one of the VMs.

00:53:53.780 --> 00:53:55.530
NAVNEET JONEJA: So let
me just, can I just

00:53:55.530 --> 00:53:57.800
take a step back and talk
about that conceptually?

00:53:57.800 --> 00:54:01.370
I mean, the goal here, with both
Deployment Manager and Manage

00:54:01.370 --> 00:54:04.529
VMs is to make it very easy
to build the patterns that

00:54:04.529 --> 00:54:06.320
will scale with you
and that would lead you

00:54:06.320 --> 00:54:09.370
to a place where you have a
well running application, right?

00:54:09.370 --> 00:54:13.180
So you want to specify
everything declaratively,

00:54:13.180 --> 00:54:16.749
so that when you spit out more
VMs, when the system spits

00:54:16.749 --> 00:54:18.540
up more VMs, they look
like all the others.

00:54:18.540 --> 00:54:20.860
There's no weird cases where
one VM is faster than the rest,

00:54:20.860 --> 00:54:22.234
you don't know
why or vice versa.

00:54:22.234 --> 00:54:22.920
Right?

00:54:22.920 --> 00:54:25.610
So the two are
designed to do that.

00:54:25.610 --> 00:54:29.530
But in the Manage VMs demo,
I know if you caught this,

00:54:29.530 --> 00:54:32.770
but I'll just kind of
just reiterate this again.

00:54:32.770 --> 00:54:35.135
The stuff that Brian
installed with app

00:54:35.135 --> 00:54:36.510
get, he could have
also specified

00:54:36.510 --> 00:54:38.670
in the app.yamel file, right?

00:54:38.670 --> 00:54:41.100
So once you figure out,
let's say you-- there's

00:54:41.100 --> 00:54:46.700
a version of OpenSSH that you
want to install on the VM.

00:54:46.700 --> 00:54:48.380
And the version you
have is not working.

00:54:48.380 --> 00:54:50.490
You debug, you find
a version that works.

00:54:50.490 --> 00:54:53.740
You just go back, update
your app.yamel file, right?

00:54:53.740 --> 00:54:55.440
And you say, I want
to use this version.

00:54:55.440 --> 00:54:57.439
The next time around, you
have the right version

00:54:57.439 --> 00:54:58.230
on all your VMs.

00:54:58.230 --> 00:55:00.330
So if you manage it
declaratively rather than

00:55:00.330 --> 00:55:03.110
configuring on the fly, you
have a much better running

00:55:03.110 --> 00:55:03.760
application.

00:55:03.760 --> 00:55:05.180
And that's kind
of the goal here.

00:55:05.180 --> 00:55:05.680
Does that help?

00:55:05.680 --> 00:55:06.180
Thanks.

00:55:10.339 --> 00:55:12.880
AUDIENCE:I was wondering if you
could talk a little bit about

00:55:12.880 --> 00:55:14.590
dependency version management.

00:55:14.590 --> 00:55:17.080
Like, if the Python
open CV library

00:55:17.080 --> 00:55:18.580
were to have a new
version, it seems

00:55:18.580 --> 00:55:20.910
like you'd be creating
snowflakes if one of them

00:55:20.910 --> 00:55:22.540
gets rebooted and
gets the new version

00:55:22.540 --> 00:55:25.630
of the library
versus the other VMs.

00:55:25.630 --> 00:55:28.085
And maybe it breaks some
dependency tree that you have

00:55:28.085 --> 00:55:29.900
that some library
call that you may

00:55:29.900 --> 00:55:31.400
and so only that
instance is broken.

00:55:31.400 --> 00:55:34.215
I'm wondering if you can
talk about that a little bit.

00:55:34.215 --> 00:55:35.840
CHRIS RAMSDALE: So
in that case though,

00:55:35.840 --> 00:55:38.560
the-- you would
actually be installing

00:55:38.560 --> 00:55:39.660
the version of OpenCV.

00:55:39.660 --> 00:55:41.620
So you would say, I
want to have OpenCV

00:55:41.620 --> 00:55:44.840
and you can pass in,
I want to have OpenCV,

00:55:44.840 --> 00:55:46.190
3.1, or 3.2, or 3.3.

00:55:46.190 --> 00:55:48.770
AUDIENCE: So you can pass in
a version number and pin it?

00:55:48.770 --> 00:55:50.435
CHRIS RAMSDALE: Right.

00:55:50.435 --> 00:55:52.310
But then there's actually
another good point.

00:55:52.310 --> 00:55:53.680
Actually, I don't know
if you meant this,

00:55:53.680 --> 00:55:55.638
but I'm going to kind of
tease it out of there.

00:55:55.638 --> 00:55:58.874
That again, because you're
running on the deployment

00:55:58.874 --> 00:56:00.790
infrastructure that we
have, you can do things

00:56:00.790 --> 00:56:02.520
like versioning very easily.

00:56:02.520 --> 00:56:06.600
You say, you know what, I want
to test out version 3.2 or 3

00:56:06.600 --> 00:56:08.410
dot x of OpenCV.

00:56:08.410 --> 00:56:11.160
I do that with a new version,
that's not my default version.

00:56:11.160 --> 00:56:12.940
So all my live traffic
here is running

00:56:12.940 --> 00:56:14.346
back to what I know was good.

00:56:14.346 --> 00:56:15.470
I want to canary a new one.

00:56:15.470 --> 00:56:17.560
I'll do some QA, do some
integration testing,

00:56:17.560 --> 00:56:18.557
things look good.

00:56:18.557 --> 00:56:20.890
Flip the bit, and now you've
got all the traffic running

00:56:20.890 --> 00:56:24.300
to the new updated
OpenCV insert,

00:56:24.300 --> 00:56:25.590
open source technology there.

00:56:25.590 --> 00:56:26.560
JOE BEDA: Yeah,
and I just wanted

00:56:26.560 --> 00:56:27.790
one more fine point on that.

00:56:27.790 --> 00:56:31.060
I mean, this is when
leveraging something

00:56:31.060 --> 00:56:33.677
like the container technology
that was mentioned earlier

00:56:33.677 --> 00:56:34.760
can really come into play.

00:56:34.760 --> 00:56:37.690
Because now, you have
essentially an artifact,

00:56:37.690 --> 00:56:41.146
which is that container image,
that really encapsulates

00:56:41.146 --> 00:56:42.520
everything about
your application

00:56:42.520 --> 00:56:43.603
that you're interested in.

00:56:43.603 --> 00:56:46.000
And so those things work
really well together

00:56:46.000 --> 00:56:49.300
in terms of trying to actually
specify all the versions down

00:56:49.300 --> 00:56:53.390
to the umpteenth degree that
you're actually working with.

00:56:53.390 --> 00:56:56.405
CHRIS RAMSDALE: You got a
question in the back there?

00:56:56.405 --> 00:56:57.946
While he's making
his way back I want

00:56:57.946 --> 00:57:01.070
to highlight another
fine point there, too.

00:57:01.070 --> 00:57:03.739
That while you can
specify the technology

00:57:03.739 --> 00:57:05.280
you want to run on
these Managed VMs,

00:57:05.280 --> 00:57:08.320
you can also take advantage of
App Engine's manage runtimes.

00:57:08.320 --> 00:57:10.940
So Java, Python, PHP, et cetera.

00:57:10.940 --> 00:57:13.480
And in that case, we actually
will do the updating for you,

00:57:13.480 --> 00:57:13.700
right?

00:57:13.700 --> 00:57:15.420
So if we realize that there is
a security patch that we need

00:57:15.420 --> 00:57:17.650
to update for that runtime,
we can do it for you.

00:57:17.650 --> 00:57:18.730
Just like we've
done in the past.

00:57:18.730 --> 00:57:19.600
So I don't know if
everybody knows,

00:57:19.600 --> 00:57:21.610
but if you're a Java
developer on App Engine,

00:57:21.610 --> 00:57:24.490
back over this last summer
we did an update from Java 6

00:57:24.490 --> 00:57:25.500
to Java 7.

00:57:25.500 --> 00:57:27.260
On the behalf of
developers, we upgraded

00:57:27.260 --> 00:57:30.175
millions of applications
in C2, like in real time.

00:57:30.175 --> 00:57:33.420
And we did that because we
could actually do a clone of it,

00:57:33.420 --> 00:57:34.660
do some canary.

00:57:34.660 --> 00:57:36.805
Run some tests, run some
anonymized traffic back

00:57:36.805 --> 00:57:38.930
at those things to make
sure everything was working

00:57:38.930 --> 00:57:40.270
and that we felt comfortable.

00:57:40.270 --> 00:57:41.686
Roll that deployment
out and we're

00:57:41.686 --> 00:57:44.507
going to make that available
as well, within managed VMs.

00:57:44.507 --> 00:57:46.090
AUDIENCE: So this
is a quick follow up

00:57:46.090 --> 00:57:49.280
to the question about
version packages.

00:57:49.280 --> 00:57:52.520
What's the default behavior if
you don't specify a version?

00:57:52.520 --> 00:57:55.200
Are they upgraded and
are some machines--

00:57:55.200 --> 00:57:57.450
CHRIS RAMSDALE: So we don't
do anything special there.

00:57:57.450 --> 00:57:59.700
It's like, it's the same,
it's whatever the repository

00:57:59.700 --> 00:58:01.840
that you're fetching
the libraries from,

00:58:01.840 --> 00:58:02.710
however it behaves.

00:58:02.710 --> 00:58:04.050
It's probably going to get
the latest in that case.

00:58:04.050 --> 00:58:05.590
AUDIENCE: So as new
VMs are spun up,

00:58:05.590 --> 00:58:06.750
they may have newer versions.

00:58:06.750 --> 00:58:07.870
So you'll have differences.

00:58:07.870 --> 00:58:09.690
BRIAN DORSEY: So full circle,
we should update the demo

00:58:09.690 --> 00:58:10.690
to conclude the version.

00:58:19.140 --> 00:58:21.740
AUDIENCE:Could you comment on
what the experience is going

00:58:21.740 --> 00:58:26.040
to be for the developer in terms
of debt server and managed VMs.

00:58:26.040 --> 00:58:27.880
CHRIS RAMSDALE: Yes.

00:58:27.880 --> 00:58:34.670
So again, I could go into it,
I would suggest you check out

00:58:34.670 --> 00:58:36.450
the 2:30 session,
Runtime Yours, they're

00:58:36.450 --> 00:58:38.810
going to talk about ways
that we can make that happen.

00:58:38.810 --> 00:58:41.139
Because it is a
very intrinsic issue

00:58:41.139 --> 00:58:42.930
in how you want to
handle it because you've

00:58:42.930 --> 00:58:44.669
got dependencies and
things like that.

00:58:44.669 --> 00:58:46.460
Containers actually
play into that as well.

00:58:46.460 --> 00:58:48.877
And some of the technologies
evolving in the market today.

00:58:48.877 --> 00:58:50.668
We're looking at how
we can leverage those.

00:58:50.668 --> 00:58:53.180
And again, we can do some
foreshadowing in that session.

00:58:53.180 --> 00:58:54.555
I don't want to
just [INAUDIBLE],

00:58:54.555 --> 00:58:56.390
but it's a pretty
deep, deep answer.

00:58:56.390 --> 00:58:58.424
We had somebody in
the back, I think.

00:58:58.424 --> 00:59:00.090
I think this might
be the last question.

00:59:00.090 --> 00:59:03.210
AUDIENCE: So on performance, so
great, perfect last question.

00:59:03.210 --> 00:59:04.380
Performance related.

00:59:04.380 --> 00:59:07.240
Do you envision any
future extensions or APIs

00:59:07.240 --> 00:59:09.950
for doing things for high
performance computing.

00:59:09.950 --> 00:59:11.760
For instance, pinning
threads to cores

00:59:11.760 --> 00:59:14.431
to optimize L3 cash
management, understanding

00:59:14.431 --> 00:59:15.930
what's happening
at the lower levels

00:59:15.930 --> 00:59:18.995
mechanical sympathy
kind of programming.

00:59:18.995 --> 00:59:23.600
NAVNEET JONEJA:So I don't have
any specific details to share.

00:59:23.600 --> 00:59:26.194
But I just want to say that
HPC is a very world code to us.

00:59:26.194 --> 00:59:28.610
We're definitely looking at
what we can do to make it work

00:59:28.610 --> 00:59:31.282
as well as possible
on Compute Engine.

00:59:31.282 --> 00:59:32.490
CHRIS RAMSDALE: Anybody else?

00:59:32.490 --> 00:59:33.281
We have 50 seconds.

00:59:33.281 --> 00:59:35.030
49, 48, 47.

00:59:35.030 --> 00:59:36.735
One more right here.

00:59:36.735 --> 00:59:39.360
AUDIENCE: I know there's like a
big emphasis on Git and GitHub.

00:59:39.360 --> 00:59:43.039
Is there any support
for subservsion?

00:59:43.039 --> 00:59:45.580
JOE BEDA: So the question was,
Git and GitHub are great, what

00:59:45.580 --> 00:59:47.377
about the subversion?

00:59:47.377 --> 00:59:48.710
I don't know the answer to that.

00:59:48.710 --> 00:59:49.550
NAVNEET JONEJA: We don't
have anything to say on that.

00:59:49.550 --> 00:59:50.365
Sorry

00:59:50.365 --> 00:59:52.490
CHRIS RAMSDALE: I think I
can see a guy in the back

00:59:52.490 --> 00:59:55.980
that I can connect you with
that might have an answer.

00:59:55.980 --> 00:59:57.397
NAVNEET JONEJA: I
think we're out.

00:59:57.397 --> 00:59:58.813
CHRIS RAMSDALE:
Thanks for coming.

00:59:58.813 --> 01:00:00.460
Thanks for watching online.

