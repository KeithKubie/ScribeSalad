WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.904
[MUSIC PLAYING]

00:00:08.084 --> 00:00:09.250
PHIL ADAMS: Hello, everyone.

00:00:09.250 --> 00:00:11.470
It's great to be here
with you all today.

00:00:11.470 --> 00:00:13.945
My name is Phil Adams, and I'm
a researcher here at Google.

00:00:13.945 --> 00:00:15.570
PIERRE LECESNE: And
I'm Pierre Lecesne,

00:00:15.570 --> 00:00:16.857
software engineer at Google.

00:00:16.857 --> 00:00:18.690
PHIL ADAMS: We are here
to talk to you today

00:00:18.690 --> 00:00:22.384
about how we're rethinking app
distribution on Google Play.

00:00:22.384 --> 00:00:24.300
We'll talk about the new
app publishing format

00:00:24.300 --> 00:00:27.060
that we announced at I/O
and share some new features

00:00:27.060 --> 00:00:29.640
that we've been working on,
digging deeper into some

00:00:29.640 --> 00:00:32.369
of the topics that you saw
covered during the keynote.

00:00:32.369 --> 00:00:35.430
To start with, let's talk
about app size and the impact

00:00:35.430 --> 00:00:37.350
that it's having on your app.

00:00:37.350 --> 00:00:40.770
Why does app size even matter?

00:00:40.770 --> 00:00:42.430
We shared this
chart at Google I/O,

00:00:42.430 --> 00:00:43.900
and you saw it earlier today.

00:00:43.900 --> 00:00:47.200
Play Store data does show
that when the app gets bigger,

00:00:47.200 --> 00:00:50.420
install success rate goes down.

00:00:50.420 --> 00:00:53.350
Many users don't have enough
space left on their device,

00:00:53.350 --> 00:00:56.580
and especially in emerging
markets, data can be expensive,

00:00:56.580 --> 00:00:59.780
and connection speeds slow.

00:00:59.780 --> 00:01:02.132
I want you to think about
your own experience, too.

00:01:02.132 --> 00:01:03.590
How many of you
have seen a warning

00:01:03.590 --> 00:01:07.000
from Play to uninstall apps?

00:01:07.000 --> 00:01:10.495
Millions of people see
things like this everyday.

00:01:10.495 --> 00:01:13.250
We've started looking into
this area more closely,

00:01:13.250 --> 00:01:15.060
and we have found
that freeing up space

00:01:15.060 --> 00:01:18.006
is a major driver of uninstalls.

00:01:18.006 --> 00:01:19.380
PIERRE LECESNE:
This is obviously

00:01:19.380 --> 00:01:22.720
a problem for people
with low-storage devices,

00:01:22.720 --> 00:01:25.320
but it's also a problem for
people with high-end devices

00:01:25.320 --> 00:01:28.410
who fill up their
devices with HD content.

00:01:28.410 --> 00:01:30.540
Take the US and the UK.

00:01:30.540 --> 00:01:34.410
One in five [INAUDIBLE]---- one
in five devices have very low

00:01:34.410 --> 00:01:37.410
storage and are reaching the
limit where they can't install

00:01:37.410 --> 00:01:39.336
or update.

00:01:39.336 --> 00:01:41.820
A key request we
hear from developers

00:01:41.820 --> 00:01:46.410
is also for help understanding
and reducing uninstalls.

00:01:46.410 --> 00:01:48.840
We ran a user research
study last year

00:01:48.840 --> 00:01:53.070
to look into why users
in the US uninstall apps.

00:01:53.070 --> 00:01:55.950
The leading reason apps were
uninstalled straight away,

00:01:55.950 --> 00:01:58.420
within a day, was quality.

00:01:58.420 --> 00:02:00.540
However, the leading
reason apps or games

00:02:00.540 --> 00:02:05.218
were uninstalled after a
month was to free up space.

00:02:05.218 --> 00:02:07.190
Apps and games keep
getting bigger.

00:02:07.190 --> 00:02:09.680
Since 2012, apps
and games have grown

00:02:09.680 --> 00:02:11.810
over five times on average.

00:02:11.810 --> 00:02:15.350
Newer devices have more
storage, but the apps, games,

00:02:15.350 --> 00:02:20.950
high-res photos, and HD videos
keep getting bigger, too.

00:02:20.950 --> 00:02:23.110
Making your app
big puts it at risk

00:02:23.110 --> 00:02:25.720
to suffer from all
these downsides.

00:02:25.720 --> 00:02:28.720
Bigger app lose acquisitions,
and bigger apps also

00:02:28.720 --> 00:02:30.910
get uninstalled
to free up space.

00:02:30.910 --> 00:02:33.820
I'm sure you already know
that, and you've probably just

00:02:33.820 --> 00:02:35.620
considered it a tradeoff.

00:02:35.620 --> 00:02:38.020
Do you add new features
and support more device

00:02:38.020 --> 00:02:40.810
configurations,
but lose installs

00:02:40.810 --> 00:02:42.880
and drive more uninstalls?

00:02:42.880 --> 00:02:47.010
We don't want you to have to
worry about these tradeoffs.

00:02:47.010 --> 00:02:48.770
For a few years,
there has been a way

00:02:48.770 --> 00:02:51.140
to optimize for
device configurations.

00:02:51.140 --> 00:02:53.330
You can use multiple APKs.

00:02:53.330 --> 00:02:57.505
But it's incredibly inefficient,
and it's a painful process.

00:02:57.505 --> 00:02:59.630
This is what it looks like
in the Play Console when

00:02:59.630 --> 00:03:03.440
you have to upload dozens of
APKs for a single release.

00:03:03.440 --> 00:03:06.620
The number of APKs grows
quickly across dimensions--

00:03:06.620 --> 00:03:10.860
for example, 64-bit, 32-bit,
and all the screen densities,

00:03:10.860 --> 00:03:14.600
and you have to version
every APK for each release.

00:03:14.600 --> 00:03:17.270
It also doesn't help with
some of the dimensions.

00:03:17.270 --> 00:03:20.090
For example, all the
languages are still

00:03:20.090 --> 00:03:23.140
in all the APK-- in every APK.

00:03:23.140 --> 00:03:24.700
We can do better.

00:03:24.700 --> 00:03:27.060
Let us show you the solution
that we have built for this

00:03:27.060 --> 00:03:32.032
and see how the new app model
helps make your life easier.

00:03:32.032 --> 00:03:33.490
PHIL ADAMS: So the
new app model is

00:03:33.490 --> 00:03:35.950
focused on improving the
whole user acquisition

00:03:35.950 --> 00:03:39.160
journey, from discovery
through to retention.

00:03:39.160 --> 00:03:41.980
It helps by making your app
smaller, directly improving

00:03:41.980 --> 00:03:44.300
install and uninstall rates.

00:03:44.300 --> 00:03:45.970
And in addition
to that, it makes

00:03:45.970 --> 00:03:48.850
your releases more manageable.

00:03:48.850 --> 00:03:51.340
In that context, for the
rest of today's session,

00:03:51.340 --> 00:03:53.050
we'll talk about
three important steps

00:03:53.050 --> 00:03:54.950
that we want to help you with.

00:03:54.950 --> 00:03:57.700
First, we want to help you
convert more installers

00:03:57.700 --> 00:04:02.112
and minimize uninstalls
by building smaller apps.

00:04:02.112 --> 00:04:04.250
Then we want to make
it possible for you

00:04:04.250 --> 00:04:08.360
to deliver different features to
different audiences on demand,

00:04:08.360 --> 00:04:10.755
only for those
users who need them.

00:04:10.755 --> 00:04:14.570
And finally, we want to help
you keep your users up to date

00:04:14.570 --> 00:04:17.880
on the latest and greatest
versions of your app.

00:04:17.880 --> 00:04:20.140
Let's start with how to
make your app smaller.

00:04:20.140 --> 00:04:22.780
This is where we began with
our major announcement at I/O

00:04:22.780 --> 00:04:26.044
about the Android App Bundle.

00:04:26.044 --> 00:04:30.196
The App Bundle is the official
Android app publishing format.

00:04:30.196 --> 00:04:32.490
Apps that have already
adopted the bundle

00:04:32.490 --> 00:04:36.590
are seeing an average
size saving of 35%.

00:04:36.590 --> 00:04:40.570
That's compared to a universal
APK, and that's quite a lot.

00:04:40.570 --> 00:04:44.414
How does adopting a bundle
lead to such savings?

00:04:44.414 --> 00:04:46.340
Here's the big idea.

00:04:46.340 --> 00:04:48.260
Google Play can
assist and take care

00:04:48.260 --> 00:04:52.476
of delivering just what's needed
to each device on your behalf.

00:04:52.476 --> 00:04:55.050
There's no need to send a
bunch of languages and device

00:04:55.050 --> 00:04:58.066
resources, which
are not necessary.

00:04:58.066 --> 00:05:01.510
We support three slicing
dimensions out of the box--

00:05:01.510 --> 00:05:07.010
languages, screen densities,
and CPU architecture.

00:05:07.010 --> 00:05:10.300
All of this is made
possible by split APKs,

00:05:10.300 --> 00:05:12.410
a feature we added to
the Android platform

00:05:12.410 --> 00:05:14.640
in Android Lollipop.

00:05:14.640 --> 00:05:18.500
Split APKs allow multiple APKs
to be installed on a device

00:05:18.500 --> 00:05:21.120
and behave as if they're
part of the same app.

00:05:21.120 --> 00:05:23.040
These split APKs
can be installed

00:05:23.040 --> 00:05:25.740
in different combinations
on different devices

00:05:25.740 --> 00:05:29.460
and can be installed all at
once upfront or over time, piece

00:05:29.460 --> 00:05:30.030
by piece.

00:05:32.658 --> 00:05:35.090
Given a bundle,
Google Play starts

00:05:35.090 --> 00:05:38.000
by putting everything that
is common to all devices

00:05:38.000 --> 00:05:40.070
in the base APK.

00:05:40.070 --> 00:05:42.650
This includes the Android
manifest and the dex files,

00:05:42.650 --> 00:05:44.930
for instance.

00:05:44.930 --> 00:05:47.830
We then generate a
different split APK

00:05:47.830 --> 00:05:50.275
for each screen density.

00:05:50.275 --> 00:05:52.270
Each split will contain
all the drawables

00:05:52.270 --> 00:05:54.640
that would have been selected
by the Android framework

00:05:54.640 --> 00:05:58.790
on that device
with that density.

00:05:58.790 --> 00:06:01.020
We then also generate
different split APKs

00:06:01.020 --> 00:06:04.180
for each native
architecture, and we

00:06:04.180 --> 00:06:06.730
can generate a separate split
for each language supported

00:06:06.730 --> 00:06:08.500
by your app, putting
each language's

00:06:08.500 --> 00:06:10.960
strings in a different APK.

00:06:10.960 --> 00:06:14.260
Together, we call these
splits configuration splits,

00:06:14.260 --> 00:06:17.410
or config splits.

00:06:17.410 --> 00:06:20.210
PIERRE LECESNE: Now, when we
go to serve an app to a device,

00:06:20.210 --> 00:06:22.640
we only need to serve a
subset of these splits.

00:06:22.640 --> 00:06:25.900
So if Phil, for example,
has a Samsung Galaxy J5,

00:06:25.900 --> 00:06:29.350
we will install the base APKs,
as well as the xhdpi density

00:06:29.350 --> 00:06:33.130
split, the arm architecture
split, and the English language

00:06:33.130 --> 00:06:34.480
split.

00:06:34.480 --> 00:06:36.920
But it can get a bit
trickier than that.

00:06:36.920 --> 00:06:38.650
I speak both French
and English, and I

00:06:38.650 --> 00:06:41.620
have specified both languages
in my device settings.

00:06:41.620 --> 00:06:45.310
So my Pixel 2XL will not only
receive the correct density

00:06:45.310 --> 00:06:47.680
and architecture split,
but also the French

00:06:47.680 --> 00:06:49.710
and the English language splits.

00:06:49.710 --> 00:06:53.080
And if I then move to
Brazil and learn Portuguese,

00:06:53.080 --> 00:06:55.570
I might add Portuguese as
a language on my device.

00:06:55.570 --> 00:06:57.219
When I do this,
the Play Store will

00:06:57.219 --> 00:06:59.260
attempt to download the
Portuguese language split

00:06:59.260 --> 00:07:02.084
for all the apps on my phone.

00:07:02.084 --> 00:07:05.970
For devices pre-L which
don't support split APKs,

00:07:05.970 --> 00:07:08.670
Play will generator a
matrix of standalone APKs

00:07:08.670 --> 00:07:11.970
for each combination of
API and screen density

00:07:11.970 --> 00:07:13.500
that your app supports.

00:07:13.500 --> 00:07:15.660
Each of these APK
contains all the files

00:07:15.660 --> 00:07:19.560
necessary for the device, so my
old Galaxy Nexus still running

00:07:19.560 --> 00:07:23.490
Android KitKat would receive
the hdpi API and arm APK.

00:07:23.490 --> 00:07:28.770
Note that all the languages
are included in those APKs.

00:07:28.770 --> 00:07:31.690
Putting it all together,
the picture looks like this.

00:07:31.690 --> 00:07:34.600
You actually don't need to worry
about all the details of how

00:07:34.600 --> 00:07:36.400
these APKs are generated.

00:07:36.400 --> 00:07:39.152
All you have to do is
upload a single app bundle,

00:07:39.152 --> 00:07:41.110
and Play generates and
selects the right things

00:07:41.110 --> 00:07:43.840
to serve for each device.

00:07:43.840 --> 00:07:47.720
To summarize-- the App
Bundle contains everything.

00:07:47.720 --> 00:07:51.140
Play processes the bundle,
generates optimized APKs,

00:07:51.140 --> 00:07:54.650
and then signs each APK to
deliver to user devices.

00:07:54.650 --> 00:07:58.220
Note that because Play
is now sending the APKs,

00:07:58.220 --> 00:08:00.440
this means that you need
to upload your signing

00:08:00.440 --> 00:08:01.970
key to Google Play.

00:08:01.970 --> 00:08:05.686
This is part of the program
called App Signing by Play.

00:08:05.686 --> 00:08:08.400
In conversations we've
had with developers,

00:08:08.400 --> 00:08:10.590
they've asked a
reasonable question.

00:08:10.590 --> 00:08:12.030
Is this secure?

00:08:12.030 --> 00:08:14.070
The answer is absolutely.

00:08:14.070 --> 00:08:17.080
As you can imagine, Google
takes this very seriously.

00:08:17.080 --> 00:08:19.590
We protect your key
in the same storage

00:08:19.590 --> 00:08:21.900
we protect Google's own keys.

00:08:21.900 --> 00:08:24.390
We have engineers
for custom security,

00:08:24.390 --> 00:08:28.755
and you'll benefit from
our ongoing investments.

00:08:28.755 --> 00:08:30.630
PHIL ADAMS: We've been
chatting to developers

00:08:30.630 --> 00:08:34.830
who are already using the App
Bundle about what they like.

00:08:34.830 --> 00:08:36.659
Recently, we've
conducted a workshop

00:08:36.659 --> 00:08:39.990
with some developers from India
who make really popular apps.

00:08:39.990 --> 00:08:42.597
These developers have
millions of active installs,

00:08:42.597 --> 00:08:44.430
and they're very
sophisticated about keeping

00:08:44.430 --> 00:08:46.470
their app size small
because their users are

00:08:46.470 --> 00:08:48.160
very sensitive to it.

00:08:48.160 --> 00:08:51.121
So this is a useful group
for us to learn from.

00:08:51.121 --> 00:08:53.110
Riafy found that
smaller installs

00:08:53.110 --> 00:08:55.480
improve their conversion rates.

00:08:55.480 --> 00:08:57.520
RedBus speaks to
their release process

00:08:57.520 --> 00:09:00.450
being more streamlined
and easier to manage.

00:09:00.450 --> 00:09:03.670
And Swiggy reports that
switching was a simple process,

00:09:03.670 --> 00:09:07.790
and they were testing using
the bundle within an hour.

00:09:07.790 --> 00:09:10.189
And it's not just developers
in India, of course.

00:09:10.189 --> 00:09:11.730
All these developers
around the world

00:09:11.730 --> 00:09:14.970
have switched and are seeing
fantastic size savings.

00:09:14.970 --> 00:09:18.360
Duolingo, for example,
saw a 56% size saving

00:09:18.360 --> 00:09:21.240
compared to a universal
APK, and it's really hard

00:09:21.240 --> 00:09:25.730
to get such big savings from
incremental optimizations.

00:09:25.730 --> 00:09:28.110
Switching to the
bundle is the simplest

00:09:28.110 --> 00:09:30.360
and highest-impact thing
that most developers

00:09:30.360 --> 00:09:32.310
can do to reduce app size.

00:09:34.974 --> 00:09:38.090
Google apps are also adopting
the bundle in production,

00:09:38.090 --> 00:09:40.220
and they're seeing
strong savings as well.

00:09:40.220 --> 00:09:44.390
Google Maps is saving about
15% in size; YouTube, 24%;

00:09:44.390 --> 00:09:46.280
Google News, 27%.

00:09:46.280 --> 00:09:48.500
They also report some
streamlining of their release

00:09:48.500 --> 00:09:51.350
process and have even noticed
a lift in update rates.

00:09:53.950 --> 00:09:55.840
So you can see this
isn't experimental.

00:09:55.840 --> 00:09:57.100
This is ready.

00:09:57.100 --> 00:09:58.930
There are thousands of apps--

00:09:58.930 --> 00:10:01.050
thousands of app
bundles in production,

00:10:01.050 --> 00:10:02.890
and it's time for all
developers to start

00:10:02.890 --> 00:10:06.590
moving towards this
new publishing format.

00:10:06.590 --> 00:10:09.120
PIERRE LECESNE: So when
you adopt the App Bundle,

00:10:09.120 --> 00:10:11.530
you're not only gaining
size savings today.

00:10:11.530 --> 00:10:15.240
You will also be benefiting
from automatic optimizations

00:10:15.240 --> 00:10:18.450
in the future as
Play introduces them.

00:10:18.450 --> 00:10:20.700
Here's a cool example
of another optimization

00:10:20.700 --> 00:10:22.500
we're just introducing.

00:10:22.500 --> 00:10:24.780
We've added a new Android
platform optimisation

00:10:24.780 --> 00:10:29.540
to the App Bundle called
Uncompressed Native Libraries.

00:10:29.540 --> 00:10:30.510
Here's how it works.

00:10:30.510 --> 00:10:32.400
On Android L and
below, native libraries

00:10:32.400 --> 00:10:34.320
have to be uncompressed
from the APK

00:10:34.320 --> 00:10:36.150
before the platform
can use them,

00:10:36.150 --> 00:10:40.065
meaning the user ends up with
two copies of the library.

00:10:40.065 --> 00:10:43.040
After Android M, the
platform can read the library

00:10:43.040 --> 00:10:46.700
directly from the APK if it's
left uncompressed, thus saving

00:10:46.700 --> 00:10:48.430
a copy on the device.

00:10:48.430 --> 00:10:50.870
To do it yourself, you
will need to upload

00:10:50.870 --> 00:10:54.410
two versions of your app
and create multi APK for pre

00:10:54.410 --> 00:10:57.170
and post M. If you're
using the App Bundle,

00:10:57.170 --> 00:11:00.560
you just give us your libraries,
and we create the required

00:11:00.560 --> 00:11:03.500
flavor for pre and post
M and serve the right APK

00:11:03.500 --> 00:11:05.510
to the right user.

00:11:05.510 --> 00:11:07.770
The size savings we're
seeing on average

00:11:07.770 --> 00:11:11.760
are significant-- around 16%
reduction in size on disk

00:11:11.760 --> 00:11:14.820
and 8% reduction
in download size.

00:11:14.820 --> 00:11:16.794
As I explained, the
app is smaller on disk

00:11:16.794 --> 00:11:18.210
because the platform
does not need

00:11:18.210 --> 00:11:21.390
to make a copy of the
library, but the download size

00:11:21.390 --> 00:11:25.170
is also smaller because our
compression algorithms perform

00:11:25.170 --> 00:11:28.980
much better on data that
is not already compressed.

00:11:28.980 --> 00:11:34.440
Our partner Gameloft saw size
savings on disk of 22% and 16%

00:11:34.440 --> 00:11:37.290
on the download size for
their game "My Little Pony"

00:11:37.290 --> 00:11:39.690
using this optimization
in the App Bundle.

00:11:39.690 --> 00:11:42.012
And these savings
are in addition

00:11:42.012 --> 00:11:43.470
to the size savings
they're already

00:11:43.470 --> 00:11:46.406
seeing from switching
to the App Bundle.

00:11:46.406 --> 00:11:49.620
With this optimization, the
download is size is smaller,

00:11:49.620 --> 00:11:52.930
it's faster to install, and
takes up less space on disk.

00:11:52.930 --> 00:11:55.740
If you're using the App Bundle,
you get this new optimization

00:11:55.740 --> 00:11:58.822
without any extra effort.

00:11:58.822 --> 00:12:01.770
Now, we still want you
to remain in control

00:12:01.770 --> 00:12:05.310
to when these optimizations
should be pushed to your users.

00:12:05.310 --> 00:12:08.640
For that reason, Play will
only apply optimizations

00:12:08.640 --> 00:12:10.770
on App Bundle that
have been built

00:12:10.770 --> 00:12:14.580
with the version of Gradle that
introduces the optimization.

00:12:14.580 --> 00:12:18.180
For example, the Uncompressed
Native Libraries optimization

00:12:18.180 --> 00:12:21.030
will only be applied to
your app if you build it

00:12:21.030 --> 00:12:23.940
with the latest Gradle
3.3, which is already

00:12:23.940 --> 00:12:25.330
available for download in beta.

00:12:28.474 --> 00:12:29.890
PHIL ADAMS: Now,
let's take a look

00:12:29.890 --> 00:12:33.670
at how you can build, test, and
publish Android app bundles.

00:12:36.280 --> 00:12:39.130
You can build app bundles
in the 3.2 stable release

00:12:39.130 --> 00:12:40.720
of Android Studio.

00:12:40.720 --> 00:12:43.000
The build process is
very similar to building

00:12:43.000 --> 00:12:46.622
an APK for most developers,
so it's easy to switch.

00:12:46.622 --> 00:12:48.540
For those who prefer
the command line

00:12:48.540 --> 00:12:51.700
or wish to integrate with
automated build systems,

00:12:51.700 --> 00:12:55.170
the new Gradle Android plugin
provides a new set of tasks

00:12:55.170 --> 00:12:57.312
to build Android app bundles.

00:12:57.312 --> 00:13:00.470
As you'll remember, you
would use the assemble task

00:13:00.470 --> 00:13:03.010
on the command line
for building APKs,

00:13:03.010 --> 00:13:04.610
and now with the
Android App Bundle,

00:13:04.610 --> 00:13:07.216
you use the new bundle task.

00:13:07.216 --> 00:13:09.690
Similar to assemble
tasks, bundle tasks

00:13:09.690 --> 00:13:11.850
also allow you to
build specific flavors.

00:13:14.694 --> 00:13:17.240
The bundle task will generate
an Android App Bundle

00:13:17.240 --> 00:13:19.850
and place it in the Outputs
folder with the flavor

00:13:19.850 --> 00:13:21.890
and build type chosen.

00:13:21.890 --> 00:13:24.160
The build artifact is
simply called bundle.aab.

00:13:26.780 --> 00:13:29.820
We do want developers to retain
control over their splits,

00:13:29.820 --> 00:13:32.790
and so for, if any reason,
you need to disable splitting

00:13:32.790 --> 00:13:35.970
by a particular dimension, you
can do so using the new bundle

00:13:35.970 --> 00:13:37.160
block as shown here.

00:13:40.570 --> 00:13:43.570
Android Studio and Gradle
are not the only ways

00:13:43.570 --> 00:13:46.990
that you can build bundles today
because the format and bundle

00:13:46.990 --> 00:13:48.760
tool are open source.

00:13:48.760 --> 00:13:51.040
Others are already
adopting them.

00:13:51.040 --> 00:13:54.130
For example, we're excited to
share that games using Unity

00:13:54.130 --> 00:13:56.960
can now build Android
app bundles, too.

00:13:56.960 --> 00:14:01.070
Unity added support in
the 2018 0.3 beta release,

00:14:01.070 --> 00:14:04.900
and you can join the
beta program now.

00:14:04.900 --> 00:14:07.730
PIERRE LECESNE: So now let's see
how you can adapt your testing

00:14:07.730 --> 00:14:10.260
with the App Bundle.

00:14:10.260 --> 00:14:12.309
During the development
phase, when

00:14:12.309 --> 00:14:14.100
you need to iterate
quickly, you don't need

00:14:14.100 --> 00:14:15.570
to go through the App Bundle.

00:14:15.570 --> 00:14:18.060
You can keep building
APKs directly from Studio.

00:14:18.060 --> 00:14:20.820
Much faster.

00:14:20.820 --> 00:14:23.010
Before a release,
you may want to test

00:14:23.010 --> 00:14:25.740
the APKs that would be
generated from the App Bundle.

00:14:25.740 --> 00:14:28.410
From Studio, this is as
easy as creating a new run

00:14:28.410 --> 00:14:30.940
configuration and
selecting APK from App

00:14:30.940 --> 00:14:33.210
Bundle in the deploy menu.

00:14:33.210 --> 00:14:35.970
Studio, under the hood, uses
the same tool, Playtest,

00:14:35.970 --> 00:14:40.820
to generate the APKs, so
you'll get high fidelity.

00:14:40.820 --> 00:14:43.940
When you want to share the APKs
generated from the App Bundle,

00:14:43.940 --> 00:14:46.850
say with your QA team, you
can use the bundletool command

00:14:46.850 --> 00:14:47.900
line.

00:14:47.900 --> 00:14:50.180
This tool is what Play and
Gradle use under the hood

00:14:50.180 --> 00:14:51.980
to generate APKs.

00:14:51.980 --> 00:14:54.620
We have open source bundletool
to be transparent about how

00:14:54.620 --> 00:14:56.640
we generate APKs,
and you can download

00:14:56.640 --> 00:14:59.180
the bundletool library on
the GitHub repo you see here.

00:15:01.810 --> 00:15:05.770
Bundletool generates what we
call an APK set archive, which

00:15:05.770 --> 00:15:09.130
will contain all the
APKs for all the devices

00:15:09.130 --> 00:15:10.490
that your app supports.

00:15:10.490 --> 00:15:13.180
We can share this archive,
and still using bundletool,

00:15:13.180 --> 00:15:16.060
you can install it on a
connected device, which

00:15:16.060 --> 00:15:18.730
will simulate what Play
does when serving APKs

00:15:18.730 --> 00:15:21.630
to that device.

00:15:21.630 --> 00:15:24.540
As you can imagine, an APK
set can become quite big,

00:15:24.540 --> 00:15:26.990
so if you want to build the
APKs only for a given device

00:15:26.990 --> 00:15:30.440
configuration, you can do so by
passing to bundletool a device

00:15:30.440 --> 00:15:32.980
specification in a JSON format.

00:15:32.980 --> 00:15:34.670
We can share that
archive around,

00:15:34.670 --> 00:15:39.270
which can then be installed on
the devices matching the spec.

00:15:39.270 --> 00:15:41.970
This is what the command line
looks like to build an APK set

00:15:41.970 --> 00:15:43.950
archive from the App Bundle.

00:15:43.950 --> 00:15:47.124
In this case, we're instructing
bundletool to build APKs only

00:15:47.124 --> 00:15:48.165
for the connected device.

00:15:50.980 --> 00:15:53.070
If you don't have
a device at hand--

00:15:53.070 --> 00:15:56.560
if you're generating the archive
from a CI system, for example--

00:15:56.560 --> 00:15:58.570
you can pass, instead,
a device specification

00:15:58.570 --> 00:15:59.445
in this JSON format.

00:16:02.040 --> 00:16:05.630
Finally, if you want a
unique, easily sharable APK,

00:16:05.630 --> 00:16:08.540
you can also choose to
build a universal APK.

00:16:08.540 --> 00:16:10.820
This APK does not
use splits, but it

00:16:10.820 --> 00:16:12.930
can be installed on
any device, so it

00:16:12.930 --> 00:16:16.530
is very convenient for sharing.

00:16:16.530 --> 00:16:19.434
But the best way to test
exactly what your users will get

00:16:19.434 --> 00:16:21.100
is still to go through
the internal test

00:16:21.100 --> 00:16:22.900
track on the Play Console.

00:16:22.900 --> 00:16:24.400
This way, you are
guaranteed to get,

00:16:24.400 --> 00:16:28.690
byte for bytes, what
your users will get.

00:16:28.690 --> 00:16:31.450
The internal test track is
similar to the alpha and beta

00:16:31.450 --> 00:16:34.650
tracks that you may
already be familiar with,

00:16:34.650 --> 00:16:36.880
but it differs from these
tracks in that there

00:16:36.880 --> 00:16:39.190
is almost no delay
between the upload

00:16:39.190 --> 00:16:42.010
of the bundle and the update
being available on the tester's

00:16:42.010 --> 00:16:44.610
device.

00:16:44.610 --> 00:16:46.910
You can see, here, how it
looks in the Play Console.

00:16:46.910 --> 00:16:50.230
You can create a list of emails
for up to 100 QA testers.

00:16:50.230 --> 00:16:52.912
The QA testers can then
follow the update link,

00:16:52.912 --> 00:16:54.370
and they'll receive,
automatically,

00:16:54.370 --> 00:16:56.440
the latest version.

00:16:56.440 --> 00:16:59.350
We know that, for some of you,
these testing options are not

00:16:59.350 --> 00:17:00.040
ideal.

00:17:00.040 --> 00:17:02.740
And we see a gap in particular
between testing in Android

00:17:02.740 --> 00:17:05.020
Studio and Play's test tracks.

00:17:05.020 --> 00:17:06.780
So I just want you
to know that we're

00:17:06.780 --> 00:17:09.020
thinking really hard about
how to close this gap.

00:17:11.996 --> 00:17:14.079
PHIL ADAMS: So now, you've
built and test bundles.

00:17:14.079 --> 00:17:16.900
Let's discuss publishing
bundles and also a new view

00:17:16.900 --> 00:17:20.822
that we've added to
the releases section.

00:17:20.822 --> 00:17:22.280
In the Play Console,
we're starting

00:17:22.280 --> 00:17:24.950
to show an estimate when we
think that an app could really

00:17:24.950 --> 00:17:27.079
benefit from using
the App Bundle.

00:17:27.079 --> 00:17:28.790
We'll take a common
reference device

00:17:28.790 --> 00:17:30.510
and calculate what
you could save

00:17:30.510 --> 00:17:33.334
were you switch to the bundle.

00:17:33.334 --> 00:17:35.970
Once you choose to switch,
you manage your release

00:17:35.970 --> 00:17:38.070
just like you did with APKs.

00:17:38.070 --> 00:17:40.770
Simply create a new release
and drop the App Bundle

00:17:40.770 --> 00:17:44.576
in the same location where
you currently drop your APKs.

00:17:44.576 --> 00:17:47.820
Do note, in order to
aid your migration,

00:17:47.820 --> 00:17:51.020
you can keep uploading APKs
on your production track

00:17:51.020 --> 00:17:53.500
while you test the
bundle in a test track.

00:17:53.500 --> 00:17:58.004
And when you do this, Play is
not going to reassign the APK.

00:17:58.004 --> 00:17:59.960
We did this so that
you can feel confident

00:17:59.960 --> 00:18:02.360
trying out the App Bundle
with a smaller number of users

00:18:02.360 --> 00:18:05.090
first without affecting your
current production user base.

00:18:08.110 --> 00:18:10.870
Once you've uploaded it,
you review your release,

00:18:10.870 --> 00:18:13.140
you roll it out, and that's it.

00:18:13.140 --> 00:18:14.820
I can't stress this enough.

00:18:14.820 --> 00:18:17.800
As Pierre mentioned, there's
no more multi APK to deal with.

00:18:17.800 --> 00:18:19.690
Play Console has created
in the background

00:18:19.690 --> 00:18:24.860
all the APKs for the
devices supportive for you.

00:18:24.860 --> 00:18:26.780
Now that you've uploaded
your App Bundle,

00:18:26.780 --> 00:18:28.735
and Play has done
this heavy lifting,

00:18:28.735 --> 00:18:30.860
it would be really nice to
have an overview of what

00:18:30.860 --> 00:18:33.586
Play has generated for you.

00:18:33.586 --> 00:18:35.650
To give you this
transparency, we've

00:18:35.650 --> 00:18:38.920
built a new tool in the Play
Console called Bundle Explorer,

00:18:38.920 --> 00:18:40.900
which lets you navigate
your uploaded bundles

00:18:40.900 --> 00:18:44.225
and the generated artifacts.

00:18:44.225 --> 00:18:46.380
On the first screen
of Bundle Explorer,

00:18:46.380 --> 00:18:48.000
you'll see how much
of a size savings

00:18:48.000 --> 00:18:49.890
you've gained by
publishing a bundle.

00:18:49.890 --> 00:18:52.480
Of course, this is going to
be different device by device,

00:18:52.480 --> 00:18:55.740
and so we calculate this using
a popular device configuration.

00:18:55.740 --> 00:18:59.010
You can also see below a
list of device configurations

00:18:59.010 --> 00:19:02.430
and the total size of the HP
case served to those devices.

00:19:02.430 --> 00:19:04.170
If you click on
View Devices, you

00:19:04.170 --> 00:19:07.410
can see which devices
are in each bucket.

00:19:07.410 --> 00:19:12.030
Alternatively, you can search
for supported device by name

00:19:12.030 --> 00:19:14.240
to download the set of
generated APKs that gets

00:19:14.240 --> 00:19:16.206
served to that specific device.

00:19:16.206 --> 00:19:17.580
And this is
particularly helpful,

00:19:17.580 --> 00:19:20.740
for example, when you get a bug
report for a particular device.

00:19:20.740 --> 00:19:22.560
So you can get the
exact same APKs

00:19:22.560 --> 00:19:23.750
that Play has served to it.

00:19:26.174 --> 00:19:28.090
Of course, we haven't
forgotten about everyone

00:19:28.090 --> 00:19:30.370
who uses our publishing API.

00:19:30.370 --> 00:19:33.660
Uploading bundles is also
available via the API,

00:19:33.660 --> 00:19:36.940
and automation and CI tools are
already adopting the bundle--

00:19:36.940 --> 00:19:39.160
for example, Fast Lane.

00:19:39.160 --> 00:19:41.495
You'll find all the
documentation at these URLs.

00:19:44.100 --> 00:19:47.010
PIERRE LECESNE: To recap, that's
the latest on the Android App

00:19:47.010 --> 00:19:50.670
Bundle and how we're making
your apps smaller and releases

00:19:50.670 --> 00:19:51.690
simpler.

00:19:51.690 --> 00:19:54.420
The next big change the
App Bundle introduces

00:19:54.420 --> 00:19:57.660
is modularization and
dynamic code loading.

00:19:57.660 --> 00:20:00.300
This is an approved,
safe way to load features

00:20:00.300 --> 00:20:03.930
and functionality dynamically,
making your app even smaller

00:20:03.930 --> 00:20:05.580
at install time.

00:20:05.580 --> 00:20:07.900
Let me tell you how it works.

00:20:07.900 --> 00:20:10.000
Dynamic features
offer yet another way

00:20:10.000 --> 00:20:11.770
you can reduce the
size of your app.

00:20:11.770 --> 00:20:14.740
Some big features in your
app may be used by only 10%

00:20:14.740 --> 00:20:18.010
of your users, so to avoid
having the 90-other percent pay

00:20:18.010 --> 00:20:21.500
the price of disk space for
a feature they don't use,

00:20:21.500 --> 00:20:25.800
you can choose to extract it in
what we call a dynamic feature.

00:20:25.800 --> 00:20:27.540
Dynamic features
can be installed

00:20:27.540 --> 00:20:30.150
on demand when
user requests them,

00:20:30.150 --> 00:20:33.630
or you can choose to defer
installing them to a later time

00:20:33.630 --> 00:20:35.740
when the app goes
to the background.

00:20:35.740 --> 00:20:39.700
For pre-L devices, which don't
support on-demand features,

00:20:39.700 --> 00:20:42.370
we can fuse the modules
into the main app

00:20:42.370 --> 00:20:45.100
so they're delivered
at install time.

00:20:45.100 --> 00:20:47.530
All of these use cases are
supported in production

00:20:47.530 --> 00:20:50.860
to date, with millions of
users benefiting already.

00:20:50.860 --> 00:20:53.439
Facebook was actually one
of our launch partners,

00:20:53.439 --> 00:20:55.480
and they are using dynamic
features in production

00:20:55.480 --> 00:20:57.500
across their app portfolio.

00:20:57.500 --> 00:21:00.470
Let's take a look
at their story.

00:21:00.470 --> 00:21:03.120
PHIL ADAMS: App size is
really important to Facebook.

00:21:03.120 --> 00:21:04.890
They evaluate the
app size impacts

00:21:04.890 --> 00:21:07.170
of each new feature
carefully to ensure

00:21:07.170 --> 00:21:10.950
that the benefit of the feature
is worth the size increase.

00:21:10.950 --> 00:21:13.260
Dynamic features means that
they can build new features

00:21:13.260 --> 00:21:16.020
without increasing the size of
apps like Facebook and Facebook

00:21:16.020 --> 00:21:19.710
Lite at install time.

00:21:19.710 --> 00:21:21.640
Dynamic features
also help Facebook

00:21:21.640 --> 00:21:24.160
with their high-end
device strategy.

00:21:24.160 --> 00:21:26.650
Facebook is able to
deliver advanced features

00:21:26.650 --> 00:21:28.990
to just supported devices.

00:21:28.990 --> 00:21:30.850
And they can also
remove large features

00:21:30.850 --> 00:21:34.640
that are not used often to avoid
taking up space on that device

00:21:34.640 --> 00:21:35.140
forever.

00:21:37.730 --> 00:21:39.882
Facebook has told us that
dynamic features work

00:21:39.882 --> 00:21:41.840
well when they're working
on a new feature that

00:21:41.840 --> 00:21:43.640
is separate from the main app.

00:21:43.640 --> 00:21:46.770
They can have a separate team
of engineers working on it.

00:21:46.770 --> 00:21:51.180
They can then add it to the app
without increasing the base app

00:21:51.180 --> 00:21:52.470
size at install time.

00:21:55.564 --> 00:21:57.960
Here are some of the
examples of dynamic features

00:21:57.960 --> 00:22:00.270
that Facebook has
added to their apps.

00:22:00.270 --> 00:22:02.810
These are all features
that are in production.

00:22:02.810 --> 00:22:05.200
For example, card
scanning is a feature

00:22:05.200 --> 00:22:09.070
that only a small percentage
of Facebook's users are using,

00:22:09.070 --> 00:22:11.110
so moving it to
a dynamic feature

00:22:11.110 --> 00:22:12.820
avoids it taking
up two megabytes

00:22:12.820 --> 00:22:16.950
on every user's device for
the lifetime of that app.

00:22:16.950 --> 00:22:20.070
Another example is
real-time communication.

00:22:20.070 --> 00:22:23.430
By moving voice and video
chat to a dynamic feature,

00:22:23.430 --> 00:22:26.040
only users with devices
that can support them,

00:22:26.040 --> 00:22:28.680
and who actually want to use
them, need to download it.

00:22:31.512 --> 00:22:34.550
What might that experience
look like for a user?

00:22:34.550 --> 00:22:36.740
Let's take a simple example.

00:22:36.740 --> 00:22:38.960
Imagine that you
have a recipe app,

00:22:38.960 --> 00:22:41.680
and you want to keep the
initial download size small.

00:22:41.680 --> 00:22:43.690
You observe that,
while all of your users

00:22:43.690 --> 00:22:46.750
like to browse for recipes,
only a small fraction of them

00:22:46.750 --> 00:22:48.790
like to add recipes,
and you notice

00:22:48.790 --> 00:22:52.790
that this functionality takes
up significant size in your app.

00:22:52.790 --> 00:22:55.120
You can choose, therefore,
to break this feature out

00:22:55.120 --> 00:22:59.015
into its own module and
serve it only when needed.

00:22:59.015 --> 00:23:00.950
We can see what it
looks like for the user,

00:23:00.950 --> 00:23:03.270
or what it might look
like for the user, here.

00:23:03.270 --> 00:23:07.721
The app opens, and then the
user goes to add a recipe.

00:23:07.721 --> 00:23:10.570
The app then requests that
the module be installed.

00:23:10.570 --> 00:23:12.890
It's downloaded and
installed with progress

00:23:12.890 --> 00:23:15.186
visible to the user,
and the new feature

00:23:15.186 --> 00:23:17.060
is ready to be used
after just a few seconds.

00:23:22.020 --> 00:23:24.890
Which parts of your app
might make good candidates

00:23:24.890 --> 00:23:27.520
to be broken out as
separate features?

00:23:27.520 --> 00:23:29.970
We think about it using
this Venn diagram.

00:23:29.970 --> 00:23:32.900
If only a smaller fraction of
your users use this feature,

00:23:32.900 --> 00:23:35.240
it could be a good
candidate, especially

00:23:35.240 --> 00:23:38.420
if that feature takes up
significant amounts of space.

00:23:38.420 --> 00:23:40.040
And finally,
consider if users can

00:23:40.040 --> 00:23:42.620
wait a few seconds before
downloading and using

00:23:42.620 --> 00:23:45.530
that feature.

00:23:45.530 --> 00:23:47.890
If you're interested in
modularizing your app,

00:23:47.890 --> 00:23:49.829
I invite you to check
out the Plaid 2.0

00:23:49.829 --> 00:23:52.120
project that some of our dev
roles have been working on

00:23:52.120 --> 00:23:54.550
and the associated articles
that they published

00:23:54.550 --> 00:23:57.220
that describe how modularization
was achieved for the app.

00:24:00.434 --> 00:24:02.100
PIERRE LECESNE: Now
that we have covered

00:24:02.100 --> 00:24:05.800
how dynamic features work,
let's see how to create them.

00:24:05.800 --> 00:24:09.930
To create a dynamic module
in Android Studio 3.2,

00:24:09.930 --> 00:24:13.050
all you need to do is use the
new dynamic feature wizard.

00:24:13.050 --> 00:24:17.330
Click on File, New Module, then
choose Dynamic Feature Module.

00:24:17.330 --> 00:24:19.680
Just type in your module's
name, and Android Studio

00:24:19.680 --> 00:24:22.680
will generate a new
dynamic feature for you.

00:24:22.680 --> 00:24:25.280
Under the hood, this
is what Studio does.

00:24:25.280 --> 00:24:27.060
In the manifest of
your new module,

00:24:27.060 --> 00:24:28.950
a split identifier is added.

00:24:28.950 --> 00:24:31.390
In this case, we'll
call it Add Recipe.

00:24:31.390 --> 00:24:33.390
This is how the Android
platform recognizes

00:24:33.390 --> 00:24:36.060
that, although this APK
has the same package name,

00:24:36.060 --> 00:24:38.625
it's still a different module.

00:24:38.625 --> 00:24:41.130
Then a new module
tag element is added,

00:24:41.130 --> 00:24:42.840
which allows to
configure distribution

00:24:42.840 --> 00:24:44.410
aspects of the module.

00:24:44.410 --> 00:24:46.290
This tag is used
by the Play Store

00:24:46.290 --> 00:24:50.340
to read properties of
the modules of your app.

00:24:50.340 --> 00:24:53.400
Next, you declare that this
module is an on-demand module

00:24:53.400 --> 00:24:55.810
by adding the On
Demand attribute,

00:24:55.810 --> 00:24:58.830
meaning that it will be only
delivered to users' devices

00:24:58.830 --> 00:25:02.460
when you request it
instead of at install time.

00:25:02.460 --> 00:25:06.460
Note that on-demand modules are
only supported since Android L,

00:25:06.460 --> 00:25:07.990
so you have to
specify as well what

00:25:07.990 --> 00:25:09.640
Play should do with
this module when

00:25:09.640 --> 00:25:12.160
it generates the pre-L APKs.

00:25:12.160 --> 00:25:15.040
You can choose to fuse
that module into base APK

00:25:15.040 --> 00:25:16.660
or exclude it completely.

00:25:16.660 --> 00:25:21.050
And this is configured
using the Fusing tag.

00:25:21.050 --> 00:25:23.936
Here's an example
with our recipe app.

00:25:23.936 --> 00:25:27.270
In addition to the base module,
we have two dynamic features.

00:25:27.270 --> 00:25:29.700
The Add Recipe module is
marked with Fuse Equal

00:25:29.700 --> 00:25:31.920
True, while the
other VR module is

00:25:31.920 --> 00:25:34.410
marked with Fuse Equal False.

00:25:34.410 --> 00:25:37.110
And you can see that Play will
only include the Add Recipe

00:25:37.110 --> 00:25:40.760
module in the pre-L APK.

00:25:40.760 --> 00:25:43.630
Now let's look at the
build the Gradle files.

00:25:43.630 --> 00:25:46.880
In the dynamic module,
you can see a new Gradle

00:25:46.880 --> 00:25:50.120
plugin being used called Come
and Read Dynamic Feature.

00:25:50.120 --> 00:25:51.860
You also have to
add the base module

00:25:51.860 --> 00:25:53.540
as a dependency of
this dynamic module

00:25:53.540 --> 00:25:56.830
to access functionality
from the base module.

00:25:56.830 --> 00:25:59.230
Looking at the build Gradle
from the base module,

00:25:59.230 --> 00:26:02.440
the only change is to
declare all dynamic modules.

00:26:02.440 --> 00:26:04.210
This is to instruct
Gradle to make

00:26:04.210 --> 00:26:09.005
the resources stored in the
base module available to them.

00:26:09.005 --> 00:26:11.600
Now that we've created
our on-demand modules,

00:26:11.600 --> 00:26:14.030
let's write the code
to download them.

00:26:14.030 --> 00:26:15.920
In order to interact
with the Play Store

00:26:15.920 --> 00:26:17.930
to request these
on-demand modules,

00:26:17.930 --> 00:26:21.050
we have to use the split
install API, which is

00:26:21.050 --> 00:26:23.320
part of the Play core library.

00:26:23.320 --> 00:26:25.520
This is a Java clone
library that communicates

00:26:25.520 --> 00:26:28.506
with the Play Store via IPC.

00:26:28.506 --> 00:26:32.800
The Play Store IPC then
communicate with Play servers.

00:26:32.800 --> 00:26:35.560
The API is structured using
the same task framework

00:26:35.560 --> 00:26:37.510
that you may be familiar
with from Google Play

00:26:37.510 --> 00:26:40.270
services and Firebase APIs.

00:26:40.270 --> 00:26:42.070
Installation of
splits is coordinated

00:26:42.070 --> 00:26:43.890
by the Split Install Manager.

00:26:43.890 --> 00:26:46.270
You construct a request
with all the modules

00:26:46.270 --> 00:26:48.010
that you wish to
download, and then

00:26:48.010 --> 00:26:51.010
invoke Start Install to trigger
the Play Store to download

00:26:51.010 --> 00:26:55.378
and install the splits required
for the requested modules.

00:26:55.378 --> 00:26:59.020
For large modules, you'll need
to obtain the user confirmation

00:26:59.020 --> 00:27:03.400
prior to the download via
the Split Install API.

00:27:03.400 --> 00:27:05.560
You'll need to do this
whenever an app requests

00:27:05.560 --> 00:27:07.840
more than 10 megabytes
of on-demand modules

00:27:07.840 --> 00:27:09.955
to be downloaded.

00:27:09.955 --> 00:27:13.640
The API allows you to listen for
updates throughout the download

00:27:13.640 --> 00:27:17.120
and install process and
display this progress--

00:27:17.120 --> 00:27:19.700
to allow to display
this progress to users.

00:27:19.700 --> 00:27:23.710
Here, we show the
download progress bar.

00:27:23.710 --> 00:27:26.130
An alternative option
for installing modules

00:27:26.130 --> 00:27:28.380
that aren't required
immediately is

00:27:28.380 --> 00:27:31.350
to use the deferred
installation API.

00:27:31.350 --> 00:27:34.860
These will be installed at a
convenient time for the user,

00:27:34.860 --> 00:27:36.990
generally when they
aren't using the device

00:27:36.990 --> 00:27:39.300
and are on Wi-Fi and charging.

00:27:39.300 --> 00:27:42.540
And because of this, we allow
you to install larger modules--

00:27:42.540 --> 00:27:44.370
up to 100 megabytes--

00:27:44.370 --> 00:27:48.110
without requiring
user confirmation.

00:27:48.110 --> 00:27:50.150
The Split Install
API also allows

00:27:50.150 --> 00:27:52.120
you to manage your
on-demand modules.

00:27:52.120 --> 00:27:54.350
You can see which
modules are installed.

00:27:54.350 --> 00:27:56.390
And you can choose to
uninstall modules that are

00:27:56.390 --> 00:27:58.560
no longer required by the app.

00:27:58.560 --> 00:28:00.990
This will free up precious
disk space for your users.

00:28:03.505 --> 00:28:07.620
So when installing an
on-demand module on N+ devices,

00:28:07.620 --> 00:28:09.900
the app does not
need to be restarted.

00:28:09.900 --> 00:28:13.080
Code is available immediately,
and new resources and assets

00:28:13.080 --> 00:28:16.350
are available once you
refresh the context object.

00:28:16.350 --> 00:28:19.890
However, on Android L
and M, installing splits

00:28:19.890 --> 00:28:22.260
requires the app
to fully restart.

00:28:22.260 --> 00:28:26.130
To avoid this, we include
a split compact library,

00:28:26.130 --> 00:28:29.880
which emulates the installation
of splits on L and M

00:28:29.880 --> 00:28:31.710
until the app goes
into the background

00:28:31.710 --> 00:28:33.780
and we can properly install it.

00:28:33.780 --> 00:28:36.570
If you are familiar with the
multidex support library,

00:28:36.570 --> 00:28:39.540
you will set up split compact
in a very similar way.

00:28:39.540 --> 00:28:41.760
Let's have a look.

00:28:41.760 --> 00:28:44.400
You have three options
to install split compact.

00:28:44.400 --> 00:28:46.980
You can use the split compact
application as your default

00:28:46.980 --> 00:28:49.830
application, or if you
already have an application,

00:28:49.830 --> 00:28:51.940
you can simply extend it.

00:28:51.940 --> 00:28:54.480
And if none of these
options suits you,

00:28:54.480 --> 00:28:57.270
then you can still also choose
to override the attach base

00:28:57.270 --> 00:29:02.830
context in your application
and invoke splitcomact.install.

00:29:02.830 --> 00:29:05.110
Now, let's talk
about versioning.

00:29:05.110 --> 00:29:07.240
When you release an
update to your app,

00:29:07.240 --> 00:29:10.210
Play will automatically
update both the base module

00:29:10.210 --> 00:29:13.460
and any on-demand modules
that are already installed.

00:29:13.460 --> 00:29:17.290
So the version of your
modules are always in sync.

00:29:17.290 --> 00:29:19.524
Partners tell us this
is something they really

00:29:19.524 --> 00:29:20.440
like about this model.

00:29:23.960 --> 00:29:26.320
PHIL ADAMS: Let's now talk
about the final step here--

00:29:26.320 --> 00:29:29.020
helping users update to the
latest and greatest version

00:29:29.020 --> 00:29:30.620
of your app.

00:29:30.620 --> 00:29:33.330
You know that Play offers
auto update functionality.

00:29:33.330 --> 00:29:36.250
And many users do have
auto update turned on,

00:29:36.250 --> 00:29:37.510
but not all of them.

00:29:37.510 --> 00:29:40.750
And in some markets, it's
not uncommon for users

00:29:40.750 --> 00:29:43.780
to have auto updates turned
on, but for the device

00:29:43.780 --> 00:29:46.610
not to meet the requirements for
the auto update to take place.

00:29:46.610 --> 00:29:48.510
For example, they may
not connect to Wi-Fi.

00:29:51.180 --> 00:29:54.030
I'm happy to share that we're
launching a new API that

00:29:54.030 --> 00:29:59.790
helps you prompt users to update
without ever leaving your app.

00:29:59.790 --> 00:30:02.050
You can call this API
to determine, first,

00:30:02.050 --> 00:30:03.590
if there's an update available.

00:30:03.590 --> 00:30:06.610
And then if so, you can
show a prompt to your users

00:30:06.610 --> 00:30:09.190
so that they can update the app.

00:30:09.190 --> 00:30:11.510
In this example,
the flow is designed

00:30:11.510 --> 00:30:14.930
for immediate, critical use
cases, such as user privacy

00:30:14.930 --> 00:30:17.172
or revenue-affecting bugs.

00:30:17.172 --> 00:30:19.490
It's a full-screen
experience, where

00:30:19.490 --> 00:30:22.974
the user is expected to wait
for the update to be applied.

00:30:22.974 --> 00:30:24.640
It's an easy one for
you, the developer,

00:30:24.640 --> 00:30:26.570
to implement
because we take care

00:30:26.570 --> 00:30:29.506
of restarting the app for you.

00:30:29.506 --> 00:30:32.726
Some of you have built
similar flows for yourselves,

00:30:32.726 --> 00:30:34.100
but this is a
standardized method

00:30:34.100 --> 00:30:35.808
that you can use with
very little effort.

00:30:38.530 --> 00:30:40.610
Instead of that
immediate update,

00:30:40.610 --> 00:30:43.400
you can also put together
a flexible update,

00:30:43.400 --> 00:30:46.340
which does not have to
be applied straight away.

00:30:46.340 --> 00:30:47.990
The really cool
thing about this API

00:30:47.990 --> 00:30:50.600
is that you can completely
customize the update

00:30:50.600 --> 00:30:54.180
flow so that it feels
like part of your app.

00:30:54.180 --> 00:30:56.450
For example, you
may choose to nudge

00:30:56.450 --> 00:30:58.550
users to update
with an inline flow,

00:30:58.550 --> 00:31:02.070
like Google Chrome is
doing in this example.

00:31:02.070 --> 00:31:04.020
Once the user
accepts the update,

00:31:04.020 --> 00:31:05.700
the download happens
in the background,

00:31:05.700 --> 00:31:08.096
so the user can
keep using the app.

00:31:08.096 --> 00:31:10.480
And once the update
is complete, it's

00:31:10.480 --> 00:31:13.390
up to you and your app to
decide how to prompt the user

00:31:13.390 --> 00:31:15.430
to restart, or you
can simply wait

00:31:15.430 --> 00:31:17.070
until the app goes
into the background

00:31:17.070 --> 00:31:19.330
or is closed by the user.

00:31:19.330 --> 00:31:21.570
Google Chrome is
testing this now,

00:31:21.570 --> 00:31:23.410
and we're inviting
early access partners

00:31:23.410 --> 00:31:26.620
to start testing
this with us as well.

00:31:26.620 --> 00:31:30.024
Talk to your BD manager
if you're interested.

00:31:30.024 --> 00:31:31.440
Let's take a look
at the code that

00:31:31.440 --> 00:31:35.196
allows that flexible
in-app update to work.

00:31:35.196 --> 00:31:38.950
First, you can request an
instance of App Update Manager

00:31:38.950 --> 00:31:41.876
and then request
the app update info.

00:31:41.876 --> 00:31:45.755
This result is going to contain
the update availability status.

00:31:45.755 --> 00:31:49.370
If an update is available,
and the update is allowed,

00:31:49.370 --> 00:31:52.220
the return to app
update info object also

00:31:52.220 --> 00:31:56.440
contains an intent
to start the flow.

00:31:56.440 --> 00:31:58.560
If the app is allowed
to start, then you

00:31:58.560 --> 00:32:01.020
extract this pending
intent, and you start it.

00:32:01.020 --> 00:32:05.520
This will start the
download and installation.

00:32:05.520 --> 00:32:08.210
You can monitor the
state of an update

00:32:08.210 --> 00:32:11.960
by registering a listener
for status updates.

00:32:11.960 --> 00:32:13.940
When the download
is complete, you

00:32:13.940 --> 00:32:16.430
can choose again to install
it directly or defer

00:32:16.430 --> 00:32:18.830
the installation to a
more convenient time,

00:32:18.830 --> 00:32:21.130
for example using a snack bar.

00:32:21.130 --> 00:32:24.330
The restart happens when
complete update is called.

00:32:27.445 --> 00:32:30.410
So to recap this new
API, ensuring your users

00:32:30.410 --> 00:32:32.350
get the latest
update is important.

00:32:32.350 --> 00:32:34.850
And you can make that happen
by following some of these best

00:32:34.850 --> 00:32:37.250
practices up here on
the screen, and also

00:32:37.250 --> 00:32:41.050
by integrating with our
brand-new in-app updates API.

00:32:41.050 --> 00:32:42.704
The API is available
for any app,

00:32:42.704 --> 00:32:44.120
and so you can get
started with it

00:32:44.120 --> 00:32:48.500
in parallel to switching
to the Android App Bundle.

00:32:48.500 --> 00:32:49.900
PIERRE LECESNE: And that's it.

00:32:49.900 --> 00:32:52.210
We've now covered how
to make your app smaller

00:32:52.210 --> 00:32:55.120
and create dynamic features
using the Android App Bundle,

00:32:55.120 --> 00:32:57.130
and how you can ensure
that your users stay

00:32:57.130 --> 00:32:58.540
on the latest
version of your app

00:32:58.540 --> 00:33:01.300
using the new in
app updates API.

00:33:01.300 --> 00:33:03.320
If you want to come and
chat about any of this,

00:33:03.320 --> 00:33:05.470
you can find us at the
office hours or the demos

00:33:05.470 --> 00:33:07.847
on the Google Play stand
today and tomorrow.

00:33:07.847 --> 00:33:10.180
Also, if you want to share
about what we've talked today

00:33:10.180 --> 00:33:12.430
with your team, the
medium post at this link

00:33:12.430 --> 00:33:14.220
is a great place to start.

00:33:14.220 --> 00:33:15.830
Enjoy the rest of your day.

00:33:15.830 --> 00:33:16.540
Thank you.

00:33:16.540 --> 00:33:19.590
[MUSIC PLAYING]

