WEBVTT
Kind: captions
Language: en

00:00:03.486 --> 00:00:04.490
YIGIT BOYAR: Hello.

00:00:04.490 --> 00:00:05.470
Welcome, everybody.

00:00:05.470 --> 00:00:06.630
My name is Yigit Boyar.

00:00:06.630 --> 00:00:08.470
I'm an engineer in
the Android team.

00:00:08.470 --> 00:00:10.220
SERGEY VASILINETC:
Hey, my name is Sergey.

00:00:10.220 --> 00:00:11.480
And I work in the same team.

00:00:11.480 --> 00:00:12.780
SEAN MCQUILLAN: Hi, I'm Sean.

00:00:12.780 --> 00:00:14.890
I'm from Android Developer.

00:00:14.890 --> 00:00:17.640
YIGIT BOYAR: Today we are
going to talk about coroutines

00:00:17.640 --> 00:00:21.160
on Androids, but before
we talk about that,

00:00:21.160 --> 00:00:24.810
let's try to figure out why do
we even need some coroutines.

00:00:24.810 --> 00:00:26.910
And to understand
that, let's forget how

00:00:26.910 --> 00:00:30.330
you write AI code on Androids.

00:00:30.330 --> 00:00:33.170
So this is the dream
code we want to write.

00:00:33.170 --> 00:00:36.620
We're like, calling function
makes a network request,

00:00:36.620 --> 00:00:37.650
whatever.

00:00:37.650 --> 00:00:40.290
You get the user, set
it on the text field.

00:00:40.290 --> 00:00:43.440
This is what you want to
write, but if you write that,

00:00:43.440 --> 00:00:46.200
you get an exception, because
you cannot make a network

00:00:46.200 --> 00:00:48.480
request on the main thread.

00:00:48.480 --> 00:00:49.180
Easy.

00:00:49.180 --> 00:00:52.650
We just put it inside a
thread and run the code.

00:00:52.650 --> 00:00:55.800
Now you're going to complain
is the textView, which is like,

00:00:55.800 --> 00:01:00.180
you cannot touch the UI thread
from a background thread.

00:01:00.180 --> 00:01:02.310
And OK, we'll write
this kind of code

00:01:02.310 --> 00:01:04.470
where you make it asynchronous.

00:01:04.470 --> 00:01:07.800
You provide a callback, it
draws on the background thread

00:01:07.800 --> 00:01:10.780
and calls your callback
on the UI thread.

00:01:10.780 --> 00:01:14.040
And this code works fine,
except, if you're writing code

00:01:14.040 --> 00:01:15.780
like this, you're
going to receive

00:01:15.780 --> 00:01:18.180
out-of-memory exceptions,
because you're

00:01:18.180 --> 00:01:21.650
going to be leaking those
callbacks left and right.

00:01:21.650 --> 00:01:24.540
There is a solution
to this as well,

00:01:24.540 --> 00:01:27.450
where we can have an
understanding of a subscription

00:01:27.450 --> 00:01:29.130
that keeps this chain.

00:01:29.130 --> 00:01:30.990
And whenever you are
a stop, we can just

00:01:30.990 --> 00:01:32.850
cancel the subscription.

00:01:32.850 --> 00:01:37.500
That one works, but then you
end up with something like this.

00:01:37.500 --> 00:01:39.840
And I'm not making
this up, by the way.

00:01:39.840 --> 00:01:42.660
Three years ago, when we
started Architecture Components,

00:01:42.660 --> 00:01:45.180
I was looking at the
Google App codes.

00:01:45.180 --> 00:01:48.330
And I found one application
that had 26 lines

00:01:48.330 --> 00:01:50.740
of [INAUDIBLE] on register.

00:01:50.740 --> 00:01:53.340
So if it happens at Google,
it happens everywhere.

00:01:53.340 --> 00:01:55.860
We don't always
write the best code.

00:01:55.860 --> 00:01:58.360
But there's a solution
to this as well,

00:01:58.360 --> 00:02:01.390
which, if you're using
something like RxJava

00:02:01.390 --> 00:02:04.740
and this function
returns an observable,

00:02:04.740 --> 00:02:07.730
you could just use the
AutoDispose library.

00:02:07.730 --> 00:02:11.860
Associated subscription with
your [INAUDIBLE] lifecycle

00:02:11.860 --> 00:02:14.000
and safely subscribe.

00:02:14.000 --> 00:02:15.780
And this works perfectly.

00:02:15.780 --> 00:02:17.850
Similarly, you could
be using LiveData,

00:02:17.850 --> 00:02:21.100
which enforces you to have
a lifecycle to observe,

00:02:21.100 --> 00:02:23.670
and this also works.

00:02:23.670 --> 00:02:25.050
So it's this old problem, right?

00:02:25.050 --> 00:02:28.200
Why are we even talking here
about this if there is already

00:02:28.200 --> 00:02:30.780
good solutions?

00:02:30.780 --> 00:02:33.600
Every year, we run these
developer benchmark surveys.

00:02:33.600 --> 00:02:36.780
We ask developers how are they
doing, what are their problems.

00:02:36.780 --> 00:02:40.860
And the surveys we ran last
year, one of the top complaints

00:02:40.860 --> 00:02:42.450
was threading and concurrency.

00:02:42.450 --> 00:02:46.200
Developers say this
is hard on Android.

00:02:46.200 --> 00:02:50.460
And one of the top requests was
this, what we call, LiveData++.

00:02:50.460 --> 00:02:53.070
People want us to
extend LiveData,

00:02:53.070 --> 00:02:55.800
make it more like RxJava.

00:02:55.800 --> 00:02:57.930
And we're like, why?

00:02:57.930 --> 00:02:59.070
Why do you want this?

00:02:59.070 --> 00:03:00.180
We have good solutions.

00:03:00.180 --> 00:03:01.930
Just use one of them.

00:03:01.930 --> 00:03:04.020
So we did what we do
best when we don't know.

00:03:04.020 --> 00:03:06.400
We did UX Research--

00:03:06.400 --> 00:03:10.750
this is User Experience
Research-- on concurrency.

00:03:10.750 --> 00:03:13.620
So we did in-depth interviews
with nine developers.

00:03:13.620 --> 00:03:16.650
What they do is they do their
regular work for a couple

00:03:16.650 --> 00:03:19.140
of weeks in their own company.

00:03:19.140 --> 00:03:22.770
And every time they see a
problem about concurrency,

00:03:22.770 --> 00:03:25.840
like this observable,
they just write it down.

00:03:25.840 --> 00:03:26.730
This was the problem.

00:03:26.730 --> 00:03:27.840
This is how I solved it.

00:03:27.840 --> 00:03:30.130
And this is how I feel about it.

00:03:30.130 --> 00:03:32.580
And in this study, we
focused on three main things.

00:03:32.580 --> 00:03:36.180
Focused on LiveData, which is
our observable data holder.

00:03:36.180 --> 00:03:37.710
We focused on RxJava.

00:03:37.710 --> 00:03:40.020
We saw the Reactive
Extensions library.

00:03:40.020 --> 00:03:44.490
And coroutines, which provides
suspendable computations.

00:03:44.490 --> 00:03:47.310
And in the result of that
study, this was the conclusion.

00:03:47.310 --> 00:03:50.130
For LiveData, people
say, we love it,

00:03:50.130 --> 00:03:52.147
but we want the
complete solution.

00:03:52.147 --> 00:03:52.980
In fact, it's funny.

00:03:52.980 --> 00:03:56.490
LiveData doesn't even support
anything but the main thread,

00:03:56.490 --> 00:04:00.150
but we talk about it
in a concurrency study.

00:04:00.150 --> 00:04:02.160
For RxJava, it is amazing.

00:04:02.160 --> 00:04:04.680
People love and hate it.

00:04:04.680 --> 00:04:07.830
They love how powerful it
is, but the common complaint

00:04:07.830 --> 00:04:10.230
we always heard was
it's always misused.

00:04:10.230 --> 00:04:12.446
It feels like an overkill.

00:04:12.446 --> 00:04:15.720
And for coroutines,
this was like, it really

00:04:15.720 --> 00:04:19.110
looks like the best
solution, but I'm not sure.

00:04:19.110 --> 00:04:20.149
It's very new.

00:04:20.149 --> 00:04:21.459
It's not mature.

00:04:21.459 --> 00:04:23.610
So this was the
overall conclusion.

00:04:23.610 --> 00:04:27.540
We said, we need a
solution that is simple.

00:04:27.540 --> 00:04:30.860
It shouldn't be hard
to learn that solution.

00:04:30.860 --> 00:04:32.530
It should be comprehensive.

00:04:32.530 --> 00:04:35.980
So it should be able to
scale to different use cases.

00:04:35.980 --> 00:04:37.110
And it should be robust.

00:04:37.110 --> 00:04:40.140
There should be a
built-in testing story.

00:04:40.140 --> 00:04:42.180
So we made two decisions.

00:04:42.180 --> 00:04:45.360
We said, OK, we are going
to have first-class quality

00:04:45.360 --> 00:04:47.910
support in Jetpack.

00:04:47.910 --> 00:04:51.080
And we are going to have
more support for RxJava

00:04:51.080 --> 00:04:52.980
in our documentation.

00:04:52.980 --> 00:04:56.040
But, today, it is
all about coroutines.

00:04:56.040 --> 00:04:58.620
So Sean, why don't you
tell us a little bit more

00:04:58.620 --> 00:05:00.250
about what coroutines are?

00:05:00.250 --> 00:05:02.330
SEAN MCQUILLAN: Thanks, Yigit.

00:05:02.330 --> 00:05:04.100
So I want to just
take five minutes

00:05:04.100 --> 00:05:06.890
and talk a little bit about
what problem coroutines are

00:05:06.890 --> 00:05:08.220
great at solving.

00:05:08.220 --> 00:05:11.180
So, in a sentence, the main
problem that coroutines solve

00:05:11.180 --> 00:05:14.510
is simplifying async programming
by replacing callbacks,

00:05:14.510 --> 00:05:16.020
which is quite abstract.

00:05:16.020 --> 00:05:19.100
So let's look at some samples
and see what that looks like.

00:05:19.100 --> 00:05:21.950
I'm going to make an imaginary
network request three ways.

00:05:21.950 --> 00:05:24.750
The first style is what's
called blocking style.

00:05:24.750 --> 00:05:26.810
This is where the result
is returned directly

00:05:26.810 --> 00:05:27.860
from the function.

00:05:27.860 --> 00:05:29.450
Let's see how that executes.

00:05:29.450 --> 00:05:33.470
And, for fun, I'm going to
run that on the main thread.

00:05:33.470 --> 00:05:35.330
When called, a
blocking network call

00:05:35.330 --> 00:05:36.920
will block the thread
that called it.

00:05:36.920 --> 00:05:40.550
So the entire time that
network request is running,

00:05:40.550 --> 00:05:41.990
the main thread will be blocked.

00:05:41.990 --> 00:05:44.000
And that's the thread
that has to update the UI

00:05:44.000 --> 00:05:45.860
and handle user
touches, so the user

00:05:45.860 --> 00:05:48.755
will see your app is frozen,
or it might even crash.

00:05:48.755 --> 00:05:50.380
Now, I do want to
pause and say there's

00:05:50.380 --> 00:05:52.880
nothing wrong with a blocking
style of network APIs,

00:05:52.880 --> 00:05:54.740
but it's not what we
want to do on Android.

00:05:54.740 --> 00:05:57.090
So, to fix that, as Yigit
already talked about,

00:05:57.090 --> 00:05:59.520
we commonly
introduced callbacks.

00:05:59.520 --> 00:06:01.100
So let's see how that executes.

00:06:01.100 --> 00:06:03.500
We're still going to call
this from the main thread,

00:06:03.500 --> 00:06:05.750
but now, when
fetchUser is called,

00:06:05.750 --> 00:06:08.660
the main thread is free
to perform other work.

00:06:08.660 --> 00:06:12.080
It can handle onDraw or
respond to user touches.

00:06:12.080 --> 00:06:14.990
And the networking library
is responsible for finding

00:06:14.990 --> 00:06:17.800
another thread to
actually run the request.

00:06:17.800 --> 00:06:20.270
When the result is ready,
the network library

00:06:20.270 --> 00:06:22.070
can then use another
callback I gave

00:06:22.070 --> 00:06:26.450
it to call back into my code
and let me know that it's ready.

00:06:26.450 --> 00:06:30.020
Let's rewrite that exact
same code with coroutines.

00:06:30.020 --> 00:06:32.240
It looks just like
the blocking style.

00:06:32.240 --> 00:06:35.120
The result of fetchUser
is available immediately.

00:06:35.120 --> 00:06:37.610
And I don't have to
introduce a callback.

00:06:37.610 --> 00:06:40.320
To tell Kotlin I want to
execute this with coroutines,

00:06:40.320 --> 00:06:43.170
it has a suspend
modifier on the function.

00:06:43.170 --> 00:06:46.070
And when we run it,
still on the main thread.

00:06:46.070 --> 00:06:49.640
The main thread is unblocked
just like with callbacks.

00:06:49.640 --> 00:06:52.580
And this is a key
concept of coroutines.

00:06:52.580 --> 00:06:56.900
The networking request still
runs on another thread.

00:06:56.900 --> 00:06:59.720
When the result is ready,
it resumes the coroutine

00:06:59.720 --> 00:07:01.370
where it left off.

00:07:01.370 --> 00:07:04.490
This code is much simpler
than the callback style

00:07:04.490 --> 00:07:07.400
while still ensuring that
I can write my Android app

00:07:07.400 --> 00:07:10.350
and make it never
freeze for the user.

00:07:10.350 --> 00:07:12.500
This is the key mechanism
here of coroutines--

00:07:12.500 --> 00:07:14.870
suspend and resume.

00:07:14.870 --> 00:07:17.210
When a coroutine is
suspended, it's not running.

00:07:17.210 --> 00:07:18.560
It's paused.

00:07:18.560 --> 00:07:21.740
And when it resumes, it picks
up from where it left off.

00:07:21.740 --> 00:07:25.670
You can think of suspending a
coroutine as taking a callback

00:07:25.670 --> 00:07:27.660
from the rest of the function.

00:07:27.660 --> 00:07:29.750
So you've put it together--
suspend and resume

00:07:29.750 --> 00:07:31.250
replace callbacks.

00:07:31.250 --> 00:07:32.660
We can even visualize that.

00:07:32.660 --> 00:07:35.240
The callback version and
the coroutine version

00:07:35.240 --> 00:07:38.370
execute almost
exactly the same way.

00:07:38.370 --> 00:07:41.240
Let's switch back and
take a look at fetchUser.

00:07:41.240 --> 00:07:43.220
How can we call a function
that makes a network

00:07:43.220 --> 00:07:46.100
request from the main thread?

00:07:46.100 --> 00:07:48.570
To start, we'll need
to make fetchUser

00:07:48.570 --> 00:07:50.270
another suspending function.

00:07:50.270 --> 00:07:53.120
This tells Kotlin that
it works with coroutines.

00:07:53.120 --> 00:07:55.970
And inside, we'll call
another suspending function

00:07:55.970 --> 00:07:57.540
called withContext.

00:07:57.540 --> 00:07:59.960
We'll pass it dispatchers.io.

00:07:59.960 --> 00:08:02.150
Zooming in on those
dispatchers, Kotlin

00:08:02.150 --> 00:08:06.340
gives us three dispatchers--
default, IO, and main.

00:08:06.340 --> 00:08:08.810
And they're used for
different things.

00:08:08.810 --> 00:08:11.930
Default should be used
for CPU-intensive work--

00:08:11.930 --> 00:08:14.750
things like transforming
a list of 100 elements,

00:08:14.750 --> 00:08:18.200
calling DiffUtil, or
precomputing text.

00:08:18.200 --> 00:08:20.990
Anything that takes too long
to run in the main thread

00:08:20.990 --> 00:08:23.300
should run on the
default dispatcher.

00:08:23.300 --> 00:08:27.320
IO is a dispatcher that's
optimized for blocking network

00:08:27.320 --> 00:08:28.730
in disk IO.

00:08:28.730 --> 00:08:30.260
You should use it
anytime you need

00:08:30.260 --> 00:08:34.309
to write code that blocks
an API, like writing a file

00:08:34.309 --> 00:08:36.700
or reading from a socket.

00:08:36.700 --> 00:08:39.799
And main-- this is the
main thread on Android.

00:08:39.799 --> 00:08:42.260
And surprisingly, it's
our recommendation

00:08:42.260 --> 00:08:44.810
as the right place to start
coroutines in response

00:08:44.810 --> 00:08:46.323
to UI events.

00:08:46.323 --> 00:08:47.990
Since you're usually
starting coroutines

00:08:47.990 --> 00:08:50.120
from the main
thread, staying there

00:08:50.120 --> 00:08:53.100
will avoid extra work
for simple operations.

00:08:53.100 --> 00:08:57.410
Then, when you need to transform
a list or write a file,

00:08:57.410 --> 00:09:00.170
coroutines let you switch to
one of the other dispatchers

00:09:00.170 --> 00:09:02.780
by using withContext.

00:09:02.780 --> 00:09:05.750
withContext will run the
block that you pass it

00:09:05.750 --> 00:09:07.720
on the dispatcher
you tell it to.

00:09:07.720 --> 00:09:11.150
So this block here is going
to run on dispatchers.io,

00:09:11.150 --> 00:09:14.360
and I'm free to make
blocking network calls.

00:09:14.360 --> 00:09:17.600
This allows us to
provide main-safe APIs.

00:09:17.600 --> 00:09:19.820
You can just make a function
that reads and writes

00:09:19.820 --> 00:09:23.760
from the network like this and
call it from the main thread.

00:09:23.760 --> 00:09:25.270
This is a huge
benefit on Android.

00:09:25.270 --> 00:09:28.610
Now, I don't have to worry about
what every single function--

00:09:28.610 --> 00:09:30.560
what thread it needs to run on.

00:09:30.560 --> 00:09:32.190
Instead, I can just call it.

00:09:32.190 --> 00:09:33.830
And the function
itself can ensure

00:09:33.830 --> 00:09:37.430
that it's safe to be called
from the main thread.

00:09:37.430 --> 00:09:39.490
To finish up introducing
coroutines, let's

00:09:39.490 --> 00:09:41.650
take a look at how
Kotlin implements them.

00:09:41.650 --> 00:09:43.480
Every thread has a call stack.

00:09:43.480 --> 00:09:46.000
It's what you see in the
debugger or a stack trace.

00:09:46.000 --> 00:09:48.880
It's how Kotlin keeps track
of which function is running

00:09:48.880 --> 00:09:50.590
and its local variables.

00:09:50.590 --> 00:09:52.150
When you call a
suspend function,

00:09:52.150 --> 00:09:54.070
Kotlin needs to keep
track of the fact it's

00:09:54.070 --> 00:09:57.160
running a coroutine instead
of a regular function.

00:09:57.160 --> 00:09:59.920
I'm going to represent
this as a suspend marker.

00:09:59.920 --> 00:10:02.410
Everything above the suspend
marker will be a coroutine

00:10:02.410 --> 00:10:05.260
and everything below will
be a regular function.

00:10:05.260 --> 00:10:08.650
Then Kotlin calls loadUser
just like a normal function.

00:10:08.650 --> 00:10:11.720
It's going to put a stack
entry onto the call stack.

00:10:11.720 --> 00:10:13.810
And this is where any local
variables for loadUser

00:10:13.810 --> 00:10:15.540
would be stored.

00:10:15.540 --> 00:10:17.530
And then it just
executes until it finds

00:10:17.530 --> 00:10:20.110
another suspend function call.

00:10:20.110 --> 00:10:22.200
Now Kotlin has to
implement suspend.

00:10:22.200 --> 00:10:24.380
How does it do that?

00:10:24.380 --> 00:10:26.700
It's kind of simple
once you figure it out.

00:10:26.700 --> 00:10:29.400
All Kotlin has to
do is copy the state

00:10:29.400 --> 00:10:32.340
of the function from the
stack to a place where

00:10:32.340 --> 00:10:34.380
it can save it for later.

00:10:34.380 --> 00:10:36.510
It'll put all suspended
coroutines out here.

00:10:36.510 --> 00:10:39.060
And it's not structured
like a stack.

00:10:39.060 --> 00:10:41.220
Then Kotlin will
actually call fetchUser,

00:10:41.220 --> 00:10:44.340
create another stack entry,
and when it calls withContext,

00:10:44.340 --> 00:10:46.720
suspends that as well.

00:10:46.720 --> 00:10:53.520
So at this point, all of the
coroutines on the main thread

00:10:53.520 --> 00:10:54.755
are suspended.

00:10:54.755 --> 00:10:56.130
And this means
the main thread is

00:10:56.130 --> 00:10:58.590
free to do other work
like handle onDraw

00:10:58.590 --> 00:11:00.420
or respond to user touches.

00:11:00.420 --> 00:11:02.400
And this is really,
really important.

00:11:02.400 --> 00:11:05.890
When all of the coroutines
on a thread are suspended,

00:11:05.890 --> 00:11:07.890
the thread is free
to do other work.

00:11:07.890 --> 00:11:09.330
If we fast forward
a few seconds,

00:11:09.330 --> 00:11:11.250
the network result
will be ready.

00:11:11.250 --> 00:11:14.310
And Kotlin will
have to call resume.

00:11:14.310 --> 00:11:16.810
In order to do that, it just
takes the save state and copies

00:11:16.810 --> 00:11:18.480
it back over, puts
it on the stack,

00:11:18.480 --> 00:11:20.940
and resumes the function.

00:11:20.940 --> 00:11:23.100
When it resumes
loadUser, it'll just

00:11:23.100 --> 00:11:26.820
go ahead and continue
executing just like normal.

00:11:26.820 --> 00:11:29.670
If loadUser had errored, it
would have thrown an exception

00:11:29.670 --> 00:11:30.900
right there.

00:11:30.900 --> 00:11:34.080
The suspend and resume mechanism
is the magic behind coroutines.

00:11:34.080 --> 00:11:35.730
And we wanted to
show it to you so you

00:11:35.730 --> 00:11:37.200
could understand
how they work as you

00:11:37.200 --> 00:11:38.450
start using them in your code.

00:11:41.720 --> 00:11:43.250
That wraps up the
coroutines intro.

00:11:43.250 --> 00:11:45.500
Coroutines on Android
offer us the ability

00:11:45.500 --> 00:11:48.310
to simplify our code
by replacing callbacks

00:11:48.310 --> 00:11:51.560
and allow us the ability to
create main safety to ensure

00:11:51.560 --> 00:11:53.630
we never block the main thread.

00:11:53.630 --> 00:11:55.130
Now I'm going to
hand over to Sergey

00:11:55.130 --> 00:11:57.338
who will talk a bit about
libraries you can use today

00:11:57.338 --> 00:11:59.855
with coroutines.

00:11:59.855 --> 00:12:01.410
SERGEY VASILINETC: Thanks, Sean.

00:12:01.410 --> 00:12:04.560
Yeah, those threads
[INAUDIBLE],, but we really

00:12:04.560 --> 00:12:07.470
want to benefit in our
real application for that.

00:12:07.470 --> 00:12:10.110
And despite the very
young age of coroutines,

00:12:10.110 --> 00:12:12.690
there are libraries that
already support them

00:12:12.690 --> 00:12:14.910
in their stable or
better artifacts.

00:12:14.910 --> 00:12:16.920
And I want to start
with WorkManager

00:12:16.920 --> 00:12:20.940
that is brand new for us in
AndroidX, because it already

00:12:20.940 --> 00:12:24.550
supports coroutines
in its stable release.

00:12:24.550 --> 00:12:26.520
And you can use
with coroutine work.

00:12:26.520 --> 00:12:31.080
But let's make a step
back and try to figure out

00:12:31.080 --> 00:12:33.610
why we do that, we use it.

00:12:33.610 --> 00:12:37.240
So this is a typical
flow of workers.

00:12:37.240 --> 00:12:39.100
So if you are not
familiar of WorkManager,

00:12:39.100 --> 00:12:40.860
you can think of worker
just as something

00:12:40.860 --> 00:12:43.680
that does long background job.

00:12:43.680 --> 00:12:47.610
It may have some constraints,
but that's very simple--

00:12:47.610 --> 00:12:49.020
just some work.

00:12:49.020 --> 00:12:51.000
And typical use
case for that, you

00:12:51.000 --> 00:12:55.210
need to synchronize some local
data with your web server.

00:12:55.210 --> 00:12:57.150
And this flow
would look like you

00:12:57.150 --> 00:13:01.390
query your new nodes
from your database,

00:13:01.390 --> 00:13:04.290
then upload it to the server.

00:13:04.290 --> 00:13:09.250
Lastly, you just mark those
nodes as successfully synced.

00:13:09.250 --> 00:13:11.800
Well, you see, no
need for coroutines.

00:13:11.800 --> 00:13:15.630
Well, actually, we didn't start
to talk about cancellation,

00:13:15.630 --> 00:13:19.660
because cancellation may happen
due to a variety of reasons.

00:13:19.660 --> 00:13:23.640
For example, constraints for
this worker aren't met anymore

00:13:23.640 --> 00:13:27.960
or user explicitly canceled this
job if you provided with UI.

00:13:27.960 --> 00:13:29.910
So how you would
support cancellation?

00:13:29.910 --> 00:13:31.920
Well, you can try to
do something like that.

00:13:31.920 --> 00:13:35.220
You try to put every
other line with ifCheck,

00:13:35.220 --> 00:13:37.270
and it starts to look silly.

00:13:37.270 --> 00:13:39.240
And even more, it
doesn't actually

00:13:39.240 --> 00:13:43.560
work, because this call, which
is probably most expensive call

00:13:43.560 --> 00:13:47.010
because it goes to a network
and does some work there,

00:13:47.010 --> 00:13:50.340
doesn't have any cancellation
signal propagation,

00:13:50.340 --> 00:13:53.010
because if it was
started, it will

00:13:53.010 --> 00:13:56.040
run to its end no matter what.

00:13:56.040 --> 00:14:02.220
And this actually will cause
the worker to help us with that.

00:14:02.220 --> 00:14:07.260
We didn't talk about that
yet, but coroutines don't only

00:14:07.260 --> 00:14:08.610
grab callbacks nicely.

00:14:08.610 --> 00:14:12.540
It also provides nice
cancellation property.

00:14:12.540 --> 00:14:15.540
So every suspend
function can be canceled.

00:14:15.540 --> 00:14:17.280
It can react on
this cancellation.

00:14:17.280 --> 00:14:20.220
And, also, it propagates
the all inner calls--

00:14:20.220 --> 00:14:22.560
this cancellation signal.

00:14:22.560 --> 00:14:28.230
You may say, our code inside
those calls are still blocking.

00:14:28.230 --> 00:14:30.250
We don't benefit
from that anyhow.

00:14:30.250 --> 00:14:30.950
This is true.

00:14:30.950 --> 00:14:35.880
However, if you use Room
as your database solution,

00:14:35.880 --> 00:14:39.270
you can mark your queries
as suspend functions.

00:14:39.270 --> 00:14:43.200
And then Room will take care
of cancellation for you.

00:14:43.200 --> 00:14:47.310
As well as threading, as Sean
mentioned that multiple times,

00:14:47.310 --> 00:14:49.200
this thing will remain safe.

00:14:49.200 --> 00:14:50.940
Room takes care of threading.

00:14:50.940 --> 00:14:55.650
It will run the query
on a background thread.

00:14:55.650 --> 00:15:00.040
Then, well, nice-- our database
calls are cancelable now,

00:15:00.040 --> 00:15:04.410
but as we discussed before,
the main call is this one.

00:15:04.410 --> 00:15:06.750
And, actually, if
you use Retrofit,

00:15:06.750 --> 00:15:10.350
you can make it suspend as
well, because Retrofit already

00:15:10.350 --> 00:15:16.290
supports suspend identifier
for its network calls.

00:15:16.290 --> 00:15:18.660
And I want to
highlight that Retrofit

00:15:18.660 --> 00:15:20.330
isn't part of AndroidX.

00:15:20.330 --> 00:15:22.660
It's just Java
designed by Android.

00:15:22.660 --> 00:15:25.600
Next time you use Android,
Android [INAUDIBLE] embraces

00:15:25.600 --> 00:15:27.600
coroutines, and we like it.

00:15:27.600 --> 00:15:29.520
At the end of the day,
it's less work for us.

00:15:32.640 --> 00:15:33.370
Nice.

00:15:33.370 --> 00:15:37.260
Now this code
supports cancellation.

00:15:37.260 --> 00:15:41.880
And it looks as easy
as it looked before.

00:15:41.880 --> 00:15:44.070
So we got cancellation for free.

00:15:44.070 --> 00:15:46.110
So this was a quick
look on the things

00:15:46.110 --> 00:15:48.360
that were available today.

00:15:48.360 --> 00:15:53.760
And Yigit will present you a lot
of new guys that we just made.

00:15:53.760 --> 00:15:55.800
YIGIT BOYAR: Thanks, Sergey.

00:15:55.800 --> 00:15:59.490
So, so far, we talked about what
you could do with coroutines.

00:15:59.490 --> 00:16:01.200
And for the rest
part of this talk,

00:16:01.200 --> 00:16:04.150
we are going to talk
about new stuff.

00:16:04.150 --> 00:16:08.020
So first one is
LiveData and coroutines.

00:16:08.020 --> 00:16:09.990
Now, just to be
very clear, LiveData

00:16:09.990 --> 00:16:12.390
is not designed for concurrency.

00:16:12.390 --> 00:16:14.570
It's an observable value holder.

00:16:14.570 --> 00:16:16.740
And you are expected
to be able to access

00:16:16.740 --> 00:16:18.250
the value from the main thread.

00:16:18.250 --> 00:16:19.883
That's intentional.

00:16:22.990 --> 00:16:26.130
But that doesn't mean it
should not be interoperable.

00:16:26.130 --> 00:16:28.810
So this is what we're
going to provide you today.

00:16:28.810 --> 00:16:32.920
There will be an easy way to
use LiveData with coroutines.

00:16:32.920 --> 00:16:35.800
So the most common use case
is you have some value.

00:16:35.800 --> 00:16:37.540
You want to compute
in a coroutine,

00:16:37.540 --> 00:16:41.500
but you want to serve
the result as a LiveData.

00:16:41.500 --> 00:16:46.570
So starting today, with the
Lifecycle 2.2 alpha01 artifact,

00:16:46.570 --> 00:16:50.960
you get this new one,
new API, called LiveData.

00:16:50.960 --> 00:16:53.530
So it's a builder function
very similar to the sequence

00:16:53.530 --> 00:16:55.780
builders in Kotlin.

00:16:55.780 --> 00:16:59.438
Inside that, you pass
a coroutines block.

00:16:59.438 --> 00:17:01.480
And inside, you can do
whatever you want and call

00:17:01.480 --> 00:17:05.180
this emit function
to dispatch values.

00:17:05.180 --> 00:17:07.569
So if you look at this
database load function,

00:17:07.569 --> 00:17:11.099
it is HLS [INAUDIBLE] function.

00:17:11.099 --> 00:17:14.599
Because you are calling the
emit with the user in this case,

00:17:14.599 --> 00:17:16.990
we can infer that type
for you, so you don't even

00:17:16.990 --> 00:17:18.910
need to specify this.

00:17:18.910 --> 00:17:21.400
So this really
simple LiveData API

00:17:21.400 --> 00:17:24.819
bridges the gap between
your LiveData elements

00:17:24.819 --> 00:17:26.920
and your coroutines.

00:17:26.920 --> 00:17:29.990
So let's get that API a
little bit more in detail.

00:17:29.990 --> 00:17:31.490
So this is three parameters.

00:17:31.490 --> 00:17:33.160
And the first one is a context.

00:17:33.160 --> 00:17:36.530
So why do we need a context?

00:17:36.530 --> 00:17:41.220
Well, if this data is loadUser
function, wasn't the--

00:17:41.220 --> 00:17:43.390
[INAUDIBLE] function
was a regular function,

00:17:43.390 --> 00:17:45.790
and you write this
code, you are going

00:17:45.790 --> 00:17:48.640
to receive an IO on
main thread exception,

00:17:48.640 --> 00:17:52.730
because this block, by default,
draws on this picture's main.

00:17:52.730 --> 00:17:53.830
But we can change that.

00:17:53.830 --> 00:17:58.090
We can give it a context,
as this picture's IO,

00:17:58.090 --> 00:18:01.030
and now this code
will work perfectly.

00:18:01.030 --> 00:18:03.580
I want you to notice
that I didn't change

00:18:03.580 --> 00:18:05.350
any contents of the
code, because you

00:18:05.350 --> 00:18:08.450
can emit from whatever
dispatcher you want.

00:18:08.450 --> 00:18:13.830
You don't need to be on the main
dispatcher to change the value.

00:18:13.830 --> 00:18:16.720
Now, the second way is a
really awkward parameter

00:18:16.720 --> 00:18:19.210
called timeout.

00:18:19.210 --> 00:18:22.610
To understand why we
needed a timeout parameter,

00:18:22.610 --> 00:18:27.040
let's look at the infamous
rotation problem on Android.

00:18:27.040 --> 00:18:30.220
So on the left, I have a
ViewModel that serves LiveData.

00:18:30.220 --> 00:18:33.580
And on the right, I have an
activity disk observing it.

00:18:33.580 --> 00:18:36.480
So while my activity
goes to a started state,

00:18:36.480 --> 00:18:38.530
the LiveData will
become active, which

00:18:38.530 --> 00:18:41.540
means OK, you're an observer
visible to the user.

00:18:41.540 --> 00:18:44.440
You are better off
creating some values.

00:18:44.440 --> 00:18:48.370
But, during that time, what
if our activity rotates?

00:18:48.370 --> 00:18:51.300
So it's going to be stopped.

00:18:51.300 --> 00:18:54.130
LiveData will become
inactive, be destroyed,

00:18:54.130 --> 00:18:56.410
and a new activity will come.

00:18:56.410 --> 00:18:58.760
So right now, there is no
one observing LiveData,

00:18:58.760 --> 00:19:01.280
so there's no reason
to produce results,

00:19:01.280 --> 00:19:04.690
except after the new
one goes start it again,

00:19:04.690 --> 00:19:06.230
it becomes active again.

00:19:06.230 --> 00:19:08.350
So the problem we are
trying to solve here

00:19:08.350 --> 00:19:10.870
is this gap while
LiveData quickly

00:19:10.870 --> 00:19:14.920
becomes inactive and active in
a very quick succession, like

00:19:14.920 --> 00:19:18.370
usually less than one second.

00:19:18.370 --> 00:19:20.770
So how do we fix that?

00:19:20.770 --> 00:19:25.050
Let's look at the detail
how we run that code block.

00:19:25.050 --> 00:19:27.090
And to understand
it better, we're

00:19:27.090 --> 00:19:29.740
just going to write
a timer function.

00:19:29.740 --> 00:19:32.970
It basically creates
a timer for LiveData.

00:19:32.970 --> 00:19:38.040
It gets the current time,
returns a LiveData builder,

00:19:38.040 --> 00:19:40.950
and in an infinite
loop, it just emits

00:19:40.950 --> 00:19:44.100
the time, delays one second,
emits the time, delays

00:19:44.100 --> 00:19:46.230
one second, and never ends.

00:19:46.230 --> 00:19:51.540
And this code I'm showing
is 100% OK to write.

00:19:51.540 --> 00:19:54.210
How does it actually work?

00:19:54.210 --> 00:19:58.380
When the LiveData returned
by this block becomes active,

00:19:58.380 --> 00:20:01.200
we check, OK, did
we run this block.

00:20:01.200 --> 00:20:03.840
And if we did not
run that block,

00:20:03.840 --> 00:20:06.060
now we start executing it.

00:20:06.060 --> 00:20:09.910
While we're executing it, if
that block becomes inactive,

00:20:09.910 --> 00:20:12.390
if LiveData becomes
inactive, we check,

00:20:12.390 --> 00:20:14.370
OK, is this block still running.

00:20:14.370 --> 00:20:18.600
And if it is still running, we
give it some time to finish.

00:20:18.600 --> 00:20:21.600
But even after the timeout,
if it is still running

00:20:21.600 --> 00:20:23.520
and we are inactive,
this basically

00:20:23.520 --> 00:20:25.020
is unnecessary computation.

00:20:25.020 --> 00:20:26.820
There is no one
observing the LiveData,

00:20:26.820 --> 00:20:29.370
but the board keeps running.

00:20:29.370 --> 00:20:32.130
So we just cancel
the continuation--

00:20:32.130 --> 00:20:34.000
the coroutine.

00:20:34.000 --> 00:20:36.890
So if the LiveData
becomes active again,

00:20:36.890 --> 00:20:38.730
we're just going to restart it.

00:20:38.730 --> 00:20:39.810
You only do it once.

00:20:39.810 --> 00:20:41.830
So if it finished
to completion, there

00:20:41.830 --> 00:20:45.230
is no reason to restart it.

00:20:45.230 --> 00:20:49.510
Now, you can also emit
more than one value.

00:20:49.510 --> 00:20:52.590
So let's put some structure
around the sample we had before

00:20:52.590 --> 00:20:55.410
where we have a repository
that has a getUser

00:20:55.410 --> 00:20:58.290
function, a loadUser
function, and the loads

00:20:58.290 --> 00:21:01.410
from the database,
and emits that value.

00:21:01.410 --> 00:21:04.440
Now, most of the time, this
is not the code you write.

00:21:04.440 --> 00:21:08.220
You need to go to the web
service, fetch an updated user,

00:21:08.220 --> 00:21:11.470
update the database, and
emit that value again.

00:21:11.470 --> 00:21:13.560
So you can call
emit as many times

00:21:13.560 --> 00:21:18.510
as you want as long as you are
inside that quarantine block.

00:21:18.510 --> 00:21:21.390
But you might say, well, most
of the time the database doesn't

00:21:21.390 --> 00:21:24.150
return your user, it returns
you LiveData for user,

00:21:24.150 --> 00:21:28.140
because you want to be
notified about the changes.

00:21:28.140 --> 00:21:32.830
Well, all you can say is you
could just call emit source.

00:21:32.830 --> 00:21:34.890
If you ever use
MediatorLiveData,

00:21:34.890 --> 00:21:37.020
this is very similar
to emitSource

00:21:37.020 --> 00:21:41.100
where it says whatever value
comes from the LiveData,

00:21:41.100 --> 00:21:42.610
just make it my value.

00:21:42.610 --> 00:21:45.940
You can run things like
transformations here.

00:21:45.940 --> 00:21:48.870
Oh, also, we don't
need this extra emit,

00:21:48.870 --> 00:21:51.730
because we're already
observing the database,

00:21:51.730 --> 00:21:55.050
so you can get rid of it.

00:21:55.050 --> 00:21:57.870
So this LiveData API
basically provides us

00:21:57.870 --> 00:22:02.010
a very nice way to make
LiveData work with coroutines.

00:22:02.010 --> 00:22:04.836
But how about ViewModels?

00:22:04.836 --> 00:22:06.610
SEAN MCQUILLAN: Thanks, Yigit.

00:22:06.610 --> 00:22:10.207
So let's talk a little bit about
how to integrate coroutines

00:22:10.207 --> 00:22:11.040
into your ViewModel.

00:22:11.040 --> 00:22:14.160
But, first, I want to talk
a little bit about leaks--

00:22:14.160 --> 00:22:15.990
specifically, coroutines leaks.

00:22:15.990 --> 00:22:17.950
And these are a very
serious problem.

00:22:17.950 --> 00:22:19.560
They're kind of
like a memory leak

00:22:19.560 --> 00:22:22.880
that we're all familiar
with, but way worse.

00:22:22.880 --> 00:22:24.880
A coroutine can resume itself.

00:22:24.880 --> 00:22:27.580
And in addition to using
memory, it can use CPU.

00:22:27.580 --> 00:22:29.430
It could write a file.

00:22:29.430 --> 00:22:33.690
It could make a network request
that doesn't need to happen.

00:22:33.690 --> 00:22:35.790
To help us deal with
coroutines leaks,

00:22:35.790 --> 00:22:39.270
Kotlin introduced this
idea of coroutine scopes.

00:22:39.270 --> 00:22:40.630
So what is a scope?

00:22:40.630 --> 00:22:43.380
Well, it's really just
a way of keeping track

00:22:43.380 --> 00:22:44.940
of your coroutines.

00:22:44.940 --> 00:22:47.310
All coroutines must
run in a scope.

00:22:47.310 --> 00:22:49.890
And a scope gets the
ability to cancel all

00:22:49.890 --> 00:22:52.182
of the coroutines inside of it.

00:22:52.182 --> 00:22:53.640
In addition, they're
also the place

00:22:53.640 --> 00:22:56.670
that uncaught exceptions from a
coroutine get shuffled off to.

00:22:56.670 --> 00:22:58.500
You put that all
together, and you

00:22:58.500 --> 00:23:03.150
can use scopes help ensure that
you never leak a coroutine.

00:23:03.150 --> 00:23:05.760
WorkManager that Sergey
talked about provides a scope.

00:23:05.760 --> 00:23:08.600
So does the LiveData Builder
that Yigit just talked about.

00:23:08.600 --> 00:23:11.080
viewModelScope is a scope.

00:23:11.080 --> 00:23:15.300
It's an extinction property on
ViewModel from the KTX library.

00:23:15.300 --> 00:23:17.760
I'm going to do another one
of those scary infinite loop

00:23:17.760 --> 00:23:20.220
things that Yigit showed,
but this time in a coroutine

00:23:20.220 --> 00:23:22.280
that I start myself
in a ViewModel.

00:23:22.280 --> 00:23:25.560
It uses viewModelScope to
launch a coroutine in the scope.

00:23:25.560 --> 00:23:27.900
And by default, this
launches on main.

00:23:27.900 --> 00:23:30.450
Then it starts an
infinite loop that doesn't

00:23:30.450 --> 00:23:32.230
know how to stop itself.

00:23:32.230 --> 00:23:35.450
And every second it's going
to go ahead and write a file.

00:23:35.450 --> 00:23:38.540
Now, that's pretty expensive.

00:23:38.540 --> 00:23:41.430
Coroutines don't make writing
files faster or cheaper,

00:23:41.430 --> 00:23:44.520
and we definitely don't
want to leak this work.

00:23:44.520 --> 00:23:48.020
ViewModelScope lets us
write code like this safely.

00:23:48.020 --> 00:23:50.100
When the user navigates
away from the screen,

00:23:50.100 --> 00:23:51.720
the scope will be
canceled, which

00:23:51.720 --> 00:23:55.680
guarantees this very
expensive work won't leak.

00:23:55.680 --> 00:23:58.260
So viewModelScope can help
you avoid coroutine leaks

00:23:58.260 --> 00:24:00.270
by guaranteeing all
your coroutines are

00:24:00.270 --> 00:24:03.305
canceled whenever a
user leaves the screen.

00:24:03.305 --> 00:24:04.763
I'm going to pass
it over to Sergey

00:24:04.763 --> 00:24:07.138
who's going to talk about some
other scopes we're adding.

00:24:07.138 --> 00:24:08.770
SERGEY VASILINETC:
Yeah, thanks, Sean.

00:24:08.770 --> 00:24:09.350
Yeah.

00:24:09.350 --> 00:24:11.100
Another thing that
very naturally provides

00:24:11.100 --> 00:24:13.590
scope is Lifecycle
because, as you

00:24:13.590 --> 00:24:17.062
can see from its name, something
that has a start and the end.

00:24:17.062 --> 00:24:19.520
And if you think, yeah, that's
familiar with this Lifecycle

00:24:19.520 --> 00:24:21.440
owner interface,
you actually are,

00:24:21.440 --> 00:24:23.730
because it is your activity.

00:24:23.730 --> 00:24:25.200
It is your fragment.

00:24:25.200 --> 00:24:28.140
And don't forget that
fragment conveniently

00:24:28.140 --> 00:24:29.580
has two different lifecycles.

00:24:29.580 --> 00:24:31.610
And the second one
is associated with--

00:24:31.610 --> 00:24:33.120
we use inside of it.

00:24:33.120 --> 00:24:36.130
Unfortunately, for me, I
now have to talk about that.

00:24:36.130 --> 00:24:40.990
But let's define scope
more precise there.

00:24:40.990 --> 00:24:43.800
So as you know, your
fragments get recreated

00:24:43.800 --> 00:24:46.440
over your configuration changes.

00:24:46.440 --> 00:24:49.540
So its lifetime can be shorter.

00:24:49.540 --> 00:24:50.640
It can be longer.

00:24:50.640 --> 00:24:54.780
And lifecycleScope just
mirrors that, meaning

00:24:54.780 --> 00:24:59.760
that once your Lifecycle
owner receives destroy event,

00:24:59.760 --> 00:25:02.040
lifecycleScope gets canceled.

00:25:02.040 --> 00:25:05.530
And all its inner jobs
are canceled as well.

00:25:05.530 --> 00:25:08.910
So, as you can see,
the lifecycleScope

00:25:08.910 --> 00:25:10.860
is very tightly coupled with UI.

00:25:10.860 --> 00:25:14.200
And it works best in
situations like that.

00:25:14.200 --> 00:25:17.880
So previously, you
would do something

00:25:17.880 --> 00:25:22.290
like this when you decide
to show some UI with delay.

00:25:22.290 --> 00:25:24.910
And, well, this
looks pretty simple,

00:25:24.910 --> 00:25:26.930
so we can make it a bit harder.

00:25:26.930 --> 00:25:30.410
And if we have two
steps, it becomes

00:25:30.410 --> 00:25:34.050
to look very ugly because
of this deepness thing.

00:25:34.050 --> 00:25:36.180
And actually, if you
take a closer look,

00:25:36.180 --> 00:25:39.960
you have some real issues
here, because this mainHandler.

00:25:39.960 --> 00:25:42.990
And those functions that
touch UI don't really

00:25:42.990 --> 00:25:45.930
work nicely together,
because mainHandler

00:25:45.930 --> 00:25:47.100
is kind of a GlobalScope.

00:25:47.100 --> 00:25:49.890
It doesn't care about
your Lifecycle at all.

00:25:49.890 --> 00:25:52.300
And those functions
have reference

00:25:52.300 --> 00:25:54.790
to fragments or activities.

00:25:54.790 --> 00:25:57.140
So if your delay
is long enough, you

00:25:57.140 --> 00:26:01.140
can easily leak a lot of
them and receive out of them

00:26:01.140 --> 00:26:02.580
their exception.

00:26:02.580 --> 00:26:08.780
While lifecycleScope
will cancel those codecs,

00:26:08.780 --> 00:26:10.320
they are showFullHint for us.

00:26:10.320 --> 00:26:12.910
It's kind of a callback because
it's a suspend function.

00:26:12.910 --> 00:26:14.700
It will cancel it
off the [INAUDIBLE]

00:26:14.700 --> 00:26:17.070
once your Lifecycle
is destroyed.

00:26:17.070 --> 00:26:20.930
So this code looks nicely,
because it's very sequential.

00:26:20.930 --> 00:26:23.130
And it is actually safer.

00:26:23.130 --> 00:26:25.980
However, I have to say
that lifecycleScope

00:26:25.980 --> 00:26:28.030
is a bit of a danger zone.

00:26:28.030 --> 00:26:29.490
So let's rewind a little bit.

00:26:29.490 --> 00:26:32.880
I was the one who showed you
that Retrofit and Room supports

00:26:32.880 --> 00:26:34.890
suspend functions.

00:26:34.890 --> 00:26:38.430
Yigit showed you something
that-- very familiar--

00:26:38.430 --> 00:26:39.480
looks like that.

00:26:39.480 --> 00:26:43.110
When you say, OK, I'll
combine those functions

00:26:43.110 --> 00:26:46.670
to network and database into
some repository pattern,

00:26:46.670 --> 00:26:48.300
you now have just
one function, which

00:26:48.300 --> 00:26:52.230
is the suspend function that
orchestrates all of this work.

00:26:52.230 --> 00:26:55.150
So I just need the
scope to call it.

00:26:55.150 --> 00:26:59.080
So why wouldn't I just call
it in my lifecycleScope?

00:26:59.080 --> 00:27:04.260
It's actually not the
brightest idea, though.

00:27:04.260 --> 00:27:05.700
Why?

00:27:05.700 --> 00:27:07.300
And don't get me wrong.

00:27:07.300 --> 00:27:10.140
Yigit and Sean sold you
everything correctly.

00:27:10.140 --> 00:27:11.670
It won't lock main thread.

00:27:11.670 --> 00:27:13.170
It won't leak [INAUDIBLE].

00:27:13.170 --> 00:27:15.180
However, do you
remember this picture?

00:27:15.180 --> 00:27:19.690
lifecycleScope get canceled,
and every configuration change,

00:27:19.690 --> 00:27:23.160
meaning that your
network request gets

00:27:23.160 --> 00:27:26.340
canceled every time,
so it is just wasteful.

00:27:26.340 --> 00:27:29.170
You're wasting user
resources, better resources.

00:27:29.170 --> 00:27:30.810
It's just bad for environment.

00:27:30.810 --> 00:27:37.117
So how you would do it properly.

00:27:37.117 --> 00:27:39.450
Well, one of the things
actually was presented by Yigit.

00:27:39.450 --> 00:27:42.160
Like this LiveData builder
will work very nicely

00:27:42.160 --> 00:27:43.650
in these kind of situations.

00:27:43.650 --> 00:27:47.160
I'll present to you in our
way how you can approach this.

00:27:47.160 --> 00:27:50.430
So your starting point
for this kind of task

00:27:50.430 --> 00:27:51.530
is a ViewModel scope.

00:27:51.530 --> 00:27:54.170
So you just run this
loadNote function

00:27:54.170 --> 00:27:55.800
in this ViewModel scope.

00:27:55.800 --> 00:27:57.870
Then we introduced a
function in ViewModel

00:27:57.870 --> 00:28:02.070
that will connect our UI in the
ViewModel when you grab a note.

00:28:02.070 --> 00:28:06.000
Well, as we discussed, it's a
network call somewhere inside

00:28:06.000 --> 00:28:07.600
of its loadNote.

00:28:07.600 --> 00:28:09.210
So it's a synchronous operation.

00:28:09.210 --> 00:28:11.030
So it should be suspended.

00:28:11.030 --> 00:28:14.550
And, well, now we need to
somehow connect this node that

00:28:14.550 --> 00:28:17.100
is loaded in one scope.

00:28:17.100 --> 00:28:20.760
And loadNote function will be
called in some other scope.

00:28:20.760 --> 00:28:23.160
Well, I will use
CompletableDeferred.

00:28:23.160 --> 00:28:25.960
Well, it sounds a bit
scary, but it's actually

00:28:25.960 --> 00:28:27.090
a very simple thing.

00:28:27.090 --> 00:28:28.450
You'll see in a second.

00:28:28.450 --> 00:28:29.860
So how we use it--

00:28:29.860 --> 00:28:32.940
we complete our deferred
with a note that we loaded.

00:28:32.940 --> 00:28:35.640
It just put the note
into this object.

00:28:35.640 --> 00:28:38.220
Nothing happens.

00:28:38.220 --> 00:28:43.440
And readers request the
note with a weight function

00:28:43.440 --> 00:28:44.970
from this deferred.

00:28:44.970 --> 00:28:51.600
If a note isn't ready yet, then
the reader will be suspended.

00:28:51.600 --> 00:28:55.770
If it is ready, reader
will resume right away.

00:28:55.770 --> 00:28:59.040
So this is how we
implemented our ViewModel.

00:28:59.040 --> 00:29:03.360
And last step, we just call
that in our Lifecycle scope

00:29:03.360 --> 00:29:07.710
this loadNote function that we
introduced in the ViewModel.

00:29:07.710 --> 00:29:14.460
And our network call is properly
executed in the ViewModel

00:29:14.460 --> 00:29:18.030
scope, so it's not affected
by configuration changes.

00:29:18.030 --> 00:29:21.030
And our update UI
function doesn't

00:29:21.030 --> 00:29:26.260
leak once your Lifecycle
owner gets destroyed.

00:29:26.260 --> 00:29:29.130
However, once we add the
fragment into the picture,

00:29:29.130 --> 00:29:31.350
things get
complicated as always.

00:29:31.350 --> 00:29:34.530
So we decided to run the
fragment transaction.

00:29:34.530 --> 00:29:36.930
And you will get a
legal state exception,

00:29:36.930 --> 00:29:39.720
because nothing
guarantees you that you

00:29:39.720 --> 00:29:44.280
are in the correct state that
allows you to execute fragment

00:29:44.280 --> 00:29:45.450
transactions.

00:29:45.450 --> 00:29:48.510
And we did something
smart and introduced

00:29:48.510 --> 00:29:51.440
some special functions
that help you to deal

00:29:51.440 --> 00:29:53.880
with these kind of situations.

00:29:53.880 --> 00:29:57.860
And this is going to be a bit
tricky, because it's actually

00:29:57.860 --> 00:29:59.380
a fairly complicated thing.

00:29:59.380 --> 00:30:03.420
But what it does, this
block will run only

00:30:03.420 --> 00:30:07.110
when your application
is started or resumed,

00:30:07.110 --> 00:30:09.450
meaning that it's
in the foreground.

00:30:09.450 --> 00:30:13.910
And this block will
be suspended when

00:30:13.910 --> 00:30:16.750
your Lifecycle is just created.

00:30:16.750 --> 00:30:19.200
So let's take a look on the
example of what it actually

00:30:19.200 --> 00:30:20.050
means.

00:30:20.050 --> 00:30:23.700
So you have this function.

00:30:23.700 --> 00:30:26.430
It is called, probably
in the beginning.

00:30:26.430 --> 00:30:30.390
Your block will be suspended,
because note is not ready.

00:30:30.390 --> 00:30:35.850
Then, once this is ready,
in usual situation,

00:30:35.850 --> 00:30:39.700
we would resume execution
and proceed to the next line.

00:30:39.700 --> 00:30:42.210
But with launchWhenStarted
function,

00:30:42.210 --> 00:30:45.280
we are going to go
and check Lifecycle

00:30:45.280 --> 00:30:47.530
If it's not started,
we are going

00:30:47.530 --> 00:30:50.430
to suspend further
until the Lifecycle will

00:30:50.430 --> 00:30:52.490
become started again.

00:30:52.490 --> 00:30:54.990
And once it is
started, then we are

00:30:54.990 --> 00:30:56.730
going to proceed
to the next line

00:30:56.730 --> 00:30:58.650
and easily execute
this transaction.

00:30:58.650 --> 00:31:03.190
So we won't run into this
exceptional situation.

00:31:03.190 --> 00:31:09.300
So one thing I want to
highlight that this block is

00:31:09.300 --> 00:31:10.950
suspended during creation.

00:31:10.950 --> 00:31:14.160
And it is a different
thing from being canceled,

00:31:14.160 --> 00:31:18.660
because cancellation is still
provided by lifecycleScope when

00:31:18.660 --> 00:31:20.910
destroyEvent happened.

00:31:20.910 --> 00:31:24.660
And now, as you can
see, it is something

00:31:24.660 --> 00:31:28.350
that we definitely need to test,
and Sean will help with that.

00:31:28.350 --> 00:31:30.118
SEAN MCQUILLAN: Thanks, Sergey.

00:31:30.118 --> 00:31:32.160
So we talked to you a lot
about coroutines today.

00:31:32.160 --> 00:31:34.530
We talked about how they
can help clean up APIs

00:31:34.530 --> 00:31:36.660
by replacing callbacks
to suspend and resume.

00:31:36.660 --> 00:31:38.640
We talked about different
ways they can be

00:31:38.640 --> 00:31:40.750
used in different situations.

00:31:40.750 --> 00:31:41.850
And that's all great.

00:31:41.850 --> 00:31:42.970
That's awesome.

00:31:42.970 --> 00:31:44.890
But if they were
difficult to test,

00:31:44.890 --> 00:31:46.120
that'd just be a non-starter.

00:31:46.120 --> 00:31:48.578
That wouldn't be something that
I would take very seriously

00:31:48.578 --> 00:31:51.122
as a thing to use.

00:31:51.122 --> 00:31:52.830
So what I want to talk
to you about right

00:31:52.830 --> 00:31:55.200
now is Kotlinx-coroutines-test.

00:31:55.200 --> 00:31:58.600
It's a new library that came
out about a week and a half ago.

00:31:58.600 --> 00:32:03.180
It's currently marked
experimental coroutines API,

00:32:03.180 --> 00:32:05.340
because it needs more
feedback before it makes

00:32:05.340 --> 00:32:06.660
it all the way to the stable.

00:32:06.660 --> 00:32:09.150
It's a collaboration
between Google and JetBrains

00:32:09.150 --> 00:32:14.290
to make testing coroutines
on Android very easy.

00:32:14.290 --> 00:32:16.790
So it's not coupled to
any testing libraries.

00:32:16.790 --> 00:32:18.630
So you can use JUnit 4.

00:32:18.630 --> 00:32:20.310
You can use JUnit 5.

00:32:20.310 --> 00:32:23.370
You can use your own custom
test runner that you've built.

00:32:23.370 --> 00:32:26.670
And this library is going
to help you test coroutines.

00:32:26.670 --> 00:32:29.340
So I'm going to focus in
on that LiveData Builder

00:32:29.340 --> 00:32:30.160
that Yigit showed.

00:32:30.160 --> 00:32:32.800
And we're going to talk about
how to write a test for that.

00:32:32.800 --> 00:32:34.095
So I'm going to emit one.

00:32:34.095 --> 00:32:35.220
I'm going to wait a second.

00:32:35.220 --> 00:32:36.512
And then I'm going to emit two.

00:32:36.512 --> 00:32:38.550
This is a relatively
simple LiveData

00:32:38.550 --> 00:32:42.720
so I can focus in on how
to write the test for it.

00:32:42.720 --> 00:32:46.700
So to get started, we need to
mock out that main dispatcher.

00:32:46.700 --> 00:32:49.520
The LiveData Builder
uses dispatchers.main

00:32:49.520 --> 00:32:52.820
by default, which is the
actual main thread on Android.

00:32:52.820 --> 00:32:55.970
We can replace it with a
test coroutine dispatcher.

00:32:55.970 --> 00:32:58.040
This is a special
dispatcher designed

00:32:58.040 --> 00:33:00.030
for testing coroutines.

00:33:00.030 --> 00:33:02.180
And we can make a
test coroutine scope.

00:33:02.180 --> 00:33:05.480
This is a scope designed
for testing coroutines.

00:33:05.480 --> 00:33:09.320
So then in Setup, you can
switch out dispatchers.main

00:33:09.320 --> 00:33:11.300
for a testing dispatcher.

00:33:11.300 --> 00:33:13.880
This will change the global
value for dispatchers.main

00:33:13.880 --> 00:33:16.160
immediately, so the
LiveData Builder

00:33:16.160 --> 00:33:18.710
will use the
dispatcher we give it.

00:33:18.710 --> 00:33:22.390
And then in tearDown,
resetMain to the default value.

00:33:22.390 --> 00:33:24.140
And then this last
line here on the bottom

00:33:24.140 --> 00:33:25.530
is really, really important.

00:33:25.530 --> 00:33:28.400
It says
testScope.cleanupTestCoroutines.

00:33:28.400 --> 00:33:30.770
If you think about what
a dispatcher and a scope

00:33:30.770 --> 00:33:32.353
are doing, they're
very stable, right?

00:33:32.353 --> 00:33:34.103
They have to keep track
of your coroutines

00:33:34.103 --> 00:33:35.180
and actually run them.

00:33:35.180 --> 00:33:36.890
If you don't call
this, it's very easy

00:33:36.890 --> 00:33:39.090
to leak state between tests.

00:33:39.090 --> 00:33:41.280
So that's a lot of boilerplate.

00:33:41.280 --> 00:33:43.610
So you can go ahead
and put that together

00:33:43.610 --> 00:33:45.350
in maybe a JUnit 4 rule.

00:33:45.350 --> 00:33:47.030
This doesn't come
in the library,

00:33:47.030 --> 00:33:49.293
but you can write all of
that code into a rule.

00:33:49.293 --> 00:33:50.960
And I would expect
to see a library that

00:33:50.960 --> 00:33:53.900
does this relatively shortly.

00:33:53.900 --> 00:33:55.910
So whatever testing
framework you're using,

00:33:55.910 --> 00:33:57.770
however, you should
build an abstraction

00:33:57.770 --> 00:33:59.645
that's appropriate for
your testing framework

00:33:59.645 --> 00:34:01.070
to do that code.

00:34:01.070 --> 00:34:03.110
The rules that I'm
defining here exposes

00:34:03.110 --> 00:34:05.660
testCoroutineScope
interface, which

00:34:05.660 --> 00:34:08.120
lets me call runBlockingTest.

00:34:08.120 --> 00:34:11.690
This is a coroutine builder
that's optimized for testing.

00:34:11.690 --> 00:34:14.000
It works kind of
like runBlocking,

00:34:14.000 --> 00:34:16.219
but it makes writing
a lot of tests easier.

00:34:16.219 --> 00:34:20.570
Oh, and it returns unit, so you
can use it in single expression

00:34:20.570 --> 00:34:23.060
style in your test.

00:34:23.060 --> 00:34:24.889
Then we get the subject.

00:34:24.889 --> 00:34:26.960
And then we need to start
observing the LiveData

00:34:26.960 --> 00:34:28.370
so it will execute.

00:34:28.370 --> 00:34:30.409
Remember the LiveData
Builder won't run

00:34:30.409 --> 00:34:31.730
until someone's observing it.

00:34:31.730 --> 00:34:34.400
I'll define a little test
helper called observeForTesting.

00:34:34.400 --> 00:34:35.510
This is just my test code.

00:34:35.510 --> 00:34:37.440
It's not in a library anywhere.

00:34:37.440 --> 00:34:39.020
It's just going to
start an observer

00:34:39.020 --> 00:34:42.980
and then call the
block that I passed in.

00:34:42.980 --> 00:34:44.639
And back to the test.

00:34:44.639 --> 00:34:46.620
The first value has
already been emitted,

00:34:46.620 --> 00:34:49.350
because I've made everything
deterministic with this test

00:34:49.350 --> 00:34:50.514
rule that I'm using.

00:34:50.514 --> 00:34:52.139
I'm going to use
[INAUDIBLE] assertions

00:34:52.139 --> 00:34:54.300
to check that the
value should equal one,

00:34:54.300 --> 00:34:57.100
and then I'm going to advance
the time by one second.

00:34:57.100 --> 00:34:58.680
This is one of
the big advantages

00:34:58.680 --> 00:35:00.180
of testCoroutineDispatcher.

00:35:00.180 --> 00:35:02.520
You can control virtual time.

00:35:02.520 --> 00:35:04.740
So advancedTimeBy
will cause that delay

00:35:04.740 --> 00:35:06.000
to return immediately.

00:35:06.000 --> 00:35:08.910
And I have control
over it in my test.

00:35:08.910 --> 00:35:10.860
So the second emit
is already done when

00:35:10.860 --> 00:35:12.190
I get to this line of code.

00:35:12.190 --> 00:35:14.970
There's no need to spin
and wait for a result.

00:35:14.970 --> 00:35:16.710
And this test won't be flaky.

00:35:16.710 --> 00:35:19.890
I can just say subject.value
should equal two.

00:35:19.890 --> 00:35:22.890
And if we run it, we see
that our test passes.

00:35:22.890 --> 00:35:26.310
The test runs instantly instead
of taking an entire second.

00:35:26.310 --> 00:35:27.960
So go check out the library.

00:35:27.960 --> 00:35:30.060
Be sure to file any
bugs that you find.

00:35:30.060 --> 00:35:32.430
It's currently marked
experimental coroutines API

00:35:32.430 --> 00:35:35.575
until it's had enough feedback
to elevate the stable.

00:35:35.575 --> 00:35:37.200
And now, I'm going
to hand the mic back

00:35:37.200 --> 00:35:40.985
to Yigit to suspend the talk.

00:35:40.985 --> 00:35:42.780
YIGIT BOYAR: Thanks, Sean.

00:35:42.780 --> 00:35:45.870
OK, so much of this stuff--

00:35:45.870 --> 00:35:47.620
what is next.

00:35:47.620 --> 00:35:50.190
So today we talk to you
about how you can already

00:35:50.190 --> 00:35:54.960
use coroutines in AndroidX
and other Android libraries.

00:35:54.960 --> 00:35:57.030
We introduced a new
LiveData Builder

00:35:57.030 --> 00:36:00.720
that lets you integrate
live data with coroutines.

00:36:00.720 --> 00:36:03.820
And the new Lifecycle
skills for your view model.

00:36:03.820 --> 00:36:07.260
So coroutines scopes for
your view model and your life

00:36:07.260 --> 00:36:09.351
cycles.

00:36:09.351 --> 00:36:11.600
And then we also introduced
this new functionality

00:36:11.600 --> 00:36:15.330
we started which allows
you to run coroutines

00:36:15.330 --> 00:36:18.110
based on your lifecycle state.

00:36:18.110 --> 00:36:21.240
And last but not least, we
have introduced a new testing

00:36:21.240 --> 00:36:22.815
library for coroutines.

00:36:26.660 --> 00:36:30.100
So earlier today we
announced Kotlin first,

00:36:30.100 --> 00:36:32.640
and for Android
[INAUDIBLE] and Jetpack

00:36:32.640 --> 00:36:35.680
it's more like coroutines first.

00:36:35.680 --> 00:36:37.480
This is a recommendation.

00:36:37.480 --> 00:36:41.650
We believe coroutines provide
the best functionality

00:36:41.650 --> 00:36:45.850
and ease of use for
concurrency on Android.

00:36:45.850 --> 00:36:48.550
But we acknowledge that
this is work in progress.

00:36:48.550 --> 00:36:50.530
Most of these
libraries we have shown

00:36:50.530 --> 00:36:53.680
are either experimental
or alpha one,

00:36:53.680 --> 00:36:56.410
but we want to develop
this with the community

00:36:56.410 --> 00:36:59.140
the same way we do with
architecture companies

00:36:59.140 --> 00:37:00.970
and other Jetpack libraries.

00:37:00.970 --> 00:37:04.060
So you can either join
us or wait six months

00:37:04.060 --> 00:37:07.480
and then start using them.

00:37:07.480 --> 00:37:10.770
And as part of this, you will
see more and more of Kotlin

00:37:10.770 --> 00:37:14.410
and coroutines coming
out of Jetpack.

00:37:14.410 --> 00:37:17.690
So all of these are
available in lifecycle 2.0,

00:37:17.690 --> 00:37:21.910
offer 01 starting today,
so please take a look at it

00:37:21.910 --> 00:37:25.030
and let us know how
you feel about that.

00:37:25.030 --> 00:37:28.100
Also, we really,
really like coroutines.

00:37:28.100 --> 00:37:29.310
Thank you.

00:37:29.310 --> 00:37:32.660
[MUSIC PLAYING]

