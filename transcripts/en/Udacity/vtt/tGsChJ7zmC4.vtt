WEBVTT
Kind: captions
Language: en

00:00:00.120 --> 00:00:03.766
We've had a series of transforms apply to the object. The object's model

00:00:03.766 --> 00:00:06.664
transform followed by the view and projection transforms generated by the

00:00:06.664 --> 00:00:11.319
camera. The perspective divide converts from clip coordinates to normalized

00:00:11.319 --> 00:00:15.467
device coordinates. There's one last transform and it's a simple one, moving

00:00:15.467 --> 00:00:19.891
from normalized device coordinates to window coordinates. In other words how do

00:00:19.891 --> 00:00:23.018
you move from a space of negative 1 to 1 in X, Y and Z to an image with a depth

00:00:23.018 --> 00:00:27.714
buffer. The answer is simple enough. Add 1, divide by 2, then multiply by the

00:00:27.714 --> 00:00:32.759
window's resolution. Doing this operation changes from negative 1 to 1 to a

00:00:32.759 --> 00:00:37.104
range of 0 to 1. I should mention at this point that the other popular API,

00:00:37.104 --> 00:00:40.602
DirectX, has normalized device coordinates for the Z value that range from 0 to

00:00:40.602 --> 00:00:45.189
1 instead of negative 1 to 1. It doesn't really matter what range is used, it's

00:00:45.189 --> 00:00:49.004
just important to know that this range can vary. The X and Y ranges of going

00:00:49.004 --> 00:00:52.824
from negative 1 to 1 is standard throughout any system I've ever seen. In 3JS,

00:00:52.824 --> 00:00:56.246
you select some part of the screen using the set viewport method on the

00:00:56.246 --> 00:01:01.130
renderer. You give the lower left hand corner, and set the width and height.

00:01:01.130 --> 00:01:03.490
The settings here say to put the lower left hand corner of the view port a

00:01:03.490 --> 00:01:07.940
quarter of the way to the right of the origin, and at the bottom of the screen.

00:01:07.940 --> 00:01:10.900
The viewport itself should be half the width and height of the window. It's

00:01:10.900 --> 00:01:14.705
possible to have multiple viewports. Each viewport defines a piece of the image

00:01:14.705 --> 00:01:18.578
and you render separately to each one. This is very handy in modeling where you

00:01:18.578 --> 00:01:20.846
can have a few different views of the scene, possibly rendered in different

00:01:20.846 --> 00:01:25.804
ways. The conversion I gave from NDC to window coordinates assumes that the

00:01:25.804 --> 00:01:29.989
lower left hand corner of the image is the origin at 0, 0. It's worth

00:01:29.989 --> 00:01:33.151
mentioning there can be a flip in the y-axis within some systems such as the

00:01:33.151 --> 00:01:37.864
Document Object Model. Some systems that display the image generated consider

00:01:37.864 --> 00:01:41.706
that the upper left hand corner is 0, 0. If you see a flip in the Y direction

00:01:41.706 --> 00:01:46.055
during manipulation of the resulting image, this is likely the mismatch. While

00:01:46.055 --> 00:01:48.969
we're talking about 0, 0, please note that the lower left hand corner of the

00:01:48.969 --> 00:01:53.429
lower left pixel is at 0.0, 0.0. In other words, in floating point. The center

00:01:53.429 --> 00:02:01.530
of the pixel is not 0.0, 0.0. It's 0.5, 0.5. Almost all of the time, this is

00:02:01.530 --> 00:02:05.435
how you want to consider the center of the pixel. DirectX 9 got it wrong,

00:02:05.435 --> 00:02:11.790
making the center 0.0, 0.0. They fixed this in DirectX 10. I've seen textbooks

00:02:11.790 --> 00:02:16.303
talk about 0.0, 0.0 as the center of the pixel. Don't believe them. Using 0.0,

00:02:16.303 --> 00:02:21.154
0.0 as the center of the pixel has the odd effect of making the lower left hand

00:02:21.154 --> 00:02:26.782
corner negative 0.5, negative 0.5. It makes simple conversion between floats

00:02:26.782 --> 00:02:30.416
and integers trickier much of the time. With the proper center, you just drop

00:02:30.416 --> 00:02:34.177
the fraction. I've occasionally seen circumstances where offsetting half a

00:02:34.177 --> 00:02:38.070
pixel can make things work out more efficiently. But much of the time, you

00:02:38.070 --> 00:02:39.020
don't want to do this.

