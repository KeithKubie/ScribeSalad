WEBVTT
Kind: captions
Language: en

00:00:00.250 --> 00:00:03.400
David, which of these topics do you
think are applied to using a script?

00:00:03.400 --> 00:00:06.350
&gt;&gt; So I chose four of the seven
as applied to using a script.

00:00:06.350 --> 00:00:10.850
So for problem reduction, we saw earlier
that the script breaks down the overall

00:00:10.850 --> 00:00:14.710
scene into smaller scenes, and
even further into smaller actions.

00:00:14.710 --> 00:00:16.910
What that means is that when
we're executing the script,

00:00:16.910 --> 00:00:19.660
and it kind of gets caught
somewhere we can break it down and

00:00:19.660 --> 00:00:22.420
see exactly where the script got caught.

00:00:22.420 --> 00:00:25.400
So we can see exactly where
an expectation was violated.

00:00:25.400 --> 00:00:28.270
Classification we actually already
discussed because classification

00:00:28.270 --> 00:00:32.299
can help us identify which script to
execute in a given situation based on

00:00:32.299 --> 00:00:33.580
what we see.

00:00:33.580 --> 00:00:35.880
So if we walk into a restaurant and
see a hostess for

00:00:35.880 --> 00:00:39.780
example we can classify that as
a specific kind of restaurant and

00:00:39.780 --> 00:00:41.870
launch the script that
goes along with it.

00:00:41.870 --> 00:00:43.150
Although it would take a bigger jump,

00:00:43.150 --> 00:00:46.010
I can also imagine putting
a script in terms of formal logic.

00:00:46.010 --> 00:00:49.440
Especially because we discussed before,
that a script can be considered a plan

00:00:49.440 --> 00:00:53.210
that has already been executed once, and
can be transferred to new situations.

00:00:53.210 --> 00:00:55.880
So if we're discussing plans
in the form of formal logic,

00:00:55.880 --> 00:00:58.820
we may also be able to put scripts
in those same kind of terms.

00:00:58.820 --> 00:01:02.490
In terms of what they're asserting is
true for a given state of the script.

00:01:02.490 --> 00:01:04.849
So if we could put plans in
the form of formal logic,

00:01:04.849 --> 00:01:07.950
we can also imagine rewriting our
script in the form of formal logic.

00:01:07.950 --> 00:01:11.250
That would give us a script in
terms of what different elements

00:01:11.250 --> 00:01:14.270
of the script assert about the state
of the world at different points of

00:01:14.270 --> 00:01:15.820
the script's execution.

00:01:15.820 --> 00:01:18.940
Finally, we can also see understanding
applying pretty directly to scripts

00:01:18.940 --> 00:01:23.670
because it helps us disambiguate
similar events in different situations.

00:01:23.670 --> 00:01:26.480
So to go with Ashok's example about
receiving the bill right when you sit

00:01:26.480 --> 00:01:31.040
down at the table, understanding talks
about how we can disambiguate that event

00:01:31.040 --> 00:01:33.680
based on what else has
happened before and after.

00:01:33.680 --> 00:01:36.710
I didn't see the other three as
being as applicable to scripts for

00:01:36.710 --> 00:01:38.500
a couple different reasons.

00:01:38.500 --> 00:01:40.570
For Generate &amp; Test and
Means-Ends Analysis,

00:01:40.570 --> 00:01:42.230
these are problem solving methods.

00:01:42.230 --> 00:01:46.320
And as we talked about with planning in
the previous exercise, scripts are often

00:01:46.320 --> 00:01:48.850
used when we already have a solution and
we simply need to execute it.

00:01:48.850 --> 00:01:52.860
Case-Based Reasoning keeps things at the
level of individual cases that can be

00:01:52.860 --> 00:01:54.650
adapted to our current problem.

00:01:54.650 --> 00:01:58.090
Where as scripts serve as
an abstraction over a number of cases.

00:01:58.090 --> 00:02:01.140
So I don't really see case-based
reasoning applying as much here either.

00:02:01.140 --> 00:02:01.920
&gt;&gt; This is good, David.

00:02:01.920 --> 00:02:03.570
Thank you for sharing this.

00:02:03.570 --> 00:02:06.947
Note that Generate and &amp; Test, and
Case-Based Reasoning might be able to

00:02:06.947 --> 00:02:08.889
have the ability to
use scripts after all.

00:02:08.889 --> 00:02:12.150
So one can imagine a situation where
there are a large number of scripts

00:02:12.150 --> 00:02:15.522
available and the robot has to decide
which of the scripts should I use for

00:02:15.522 --> 00:02:16.750
a particular situation.

00:02:16.750 --> 00:02:20.245
And may not be able to classify
the situation dashed into scripts and

00:02:20.245 --> 00:02:23.859
with that case the robot will pick
a script, generate it, try it out,

00:02:23.859 --> 00:02:26.504
see if it works,
if it does not pick another one.

00:02:26.504 --> 00:02:30.858
Also Case-Based Reasoning is currently
the application of scripts in the sense

00:02:30.858 --> 00:02:32.843
that both Case-Based Reasoning and

00:02:32.843 --> 00:02:36.580
script-based reasoning
are extremely memory intensive.

00:02:36.580 --> 00:02:39.650
What both of them are saying is
that memory often supplies most of

00:02:39.650 --> 00:02:40.760
the answer.

00:02:40.760 --> 00:02:43.120
Like we said earlier when we were
discussing Case-Based Reasoning,

00:02:43.120 --> 00:02:45.910
we don't think as much
as we think we do.

00:02:45.910 --> 00:02:48.360
Most of the time memory
gives us the answer.

00:02:48.360 --> 00:02:51.510
The difference, of course, like David
pointed out is, that cases defer to

00:02:51.510 --> 00:02:54.680
instances whereas scripts
are abstractions of the instances.

