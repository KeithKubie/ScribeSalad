WEBVTT
Kind: captions
Language: en

00:00:00.162 --> 00:00:00.870
GUY PODJARNY: Hi.

00:00:00.870 --> 00:00:03.450
We've got Ilya Grigorik,
who's in developer

00:00:03.450 --> 00:00:05.560
relations in Chrome.

00:00:05.560 --> 00:00:08.960
And specifically has promoted
a lot WebP and, in general,

00:00:08.960 --> 00:00:11.610
many, many different
performance topics.

00:00:11.610 --> 00:00:15.590
So I'll let Kornel
introduce the topic here.

00:00:15.590 --> 00:00:17.050
KORNEL LESINSKI: Hello everyone.

00:00:17.050 --> 00:00:19.850
I'm going to start with
an obligatory HDV archive

00:00:19.850 --> 00:00:21.480
statistic.

00:00:21.480 --> 00:00:25.060
Since 2010 the amount of bytes
on a typical website used

00:00:25.060 --> 00:00:27.640
for images has tripled.

00:00:27.640 --> 00:00:29.350
And it'll probably
continue to grow

00:00:29.350 --> 00:00:34.010
as larger and larger screens
become more affordable.

00:00:34.010 --> 00:00:37.240
However, the situation is
not as terrible as it seems,

00:00:37.240 --> 00:00:39.560
because average
connection speed is also

00:00:39.560 --> 00:00:42.590
growing all across the board.

00:00:42.590 --> 00:00:44.720
In the last three
years broadband speed

00:00:44.720 --> 00:00:46.560
in United States has doubled.

00:00:46.560 --> 00:00:50.230
And in China it has
more than tripled.

00:00:50.230 --> 00:00:53.500
So on one hand if you
do absolutely nothing

00:00:53.500 --> 00:00:59.180
with your images they'll load
faster by 20, 30% every year,

00:00:59.180 --> 00:01:02.380
but on the other hand we'll
be using up all the bandwidth

00:01:02.380 --> 00:01:05.470
that we possibly can.

00:01:05.470 --> 00:01:07.180
Now looking on it
the other way, where

00:01:07.180 --> 00:01:09.730
are those bytes coming from?

00:01:09.730 --> 00:01:12.440
It's probably safe for web.

00:01:12.440 --> 00:01:15.982
Adobe nailed this
interface 15 years ago.

00:01:15.982 --> 00:01:20.210
And it's probably still
the most popular tool.

00:01:20.210 --> 00:01:23.980
However, this is
a manual workflow.

00:01:23.980 --> 00:01:27.250
It requires authors
to know specifics

00:01:27.250 --> 00:01:28.942
of image formats,
which are the best,

00:01:28.942 --> 00:01:30.025
and tune all the settings.

00:01:32.610 --> 00:01:36.170
And as we get new image
formats, new optimizations,

00:01:36.170 --> 00:01:41.220
the workflow becomes even
more tedious and complex.

00:01:41.220 --> 00:01:44.630
Fortunately, new
tools are coming.

00:01:44.630 --> 00:01:49.240
For example, Adobe
Generator can automatically

00:01:49.240 --> 00:01:52.830
export all layers
of a Photoshop file

00:01:52.830 --> 00:01:55.440
and optimize it
using latest tools.

00:01:55.440 --> 00:02:00.830
There are also tools like
Mod_Page Speed or Akamai

00:02:00.830 --> 00:02:03.700
front end optimization proxy
that will automatically

00:02:03.700 --> 00:02:07.455
compress images optimized for
each browser specifically.

00:02:10.139 --> 00:02:12.030
We have more new stuff.

00:02:12.030 --> 00:02:14.680
The picture element now
in the latest browsers,

00:02:14.680 --> 00:02:19.170
we can adapt images to screen
depth, screen size, aspect

00:02:19.170 --> 00:02:23.390
ratio, and we can
also use new formats

00:02:23.390 --> 00:02:27.040
with a graceful fallback.

00:02:27.040 --> 00:02:31.800
HTP2 is going to make
delivery of images

00:02:31.800 --> 00:02:33.130
really, really interesting.

00:02:33.130 --> 00:02:36.940
With HTP1, browsers have
to delay image requests

00:02:36.940 --> 00:02:39.830
to let CSS and
JavaScript load first.

00:02:39.830 --> 00:02:43.000
However, in HTP2 the server
has control over this

00:02:43.000 --> 00:02:47.190
and can send the first 5 or
10% of an image file that

00:02:47.190 --> 00:02:52.160
contains image size and the
first progressive layer,

00:02:52.160 --> 00:02:55.810
then let CSS load, then
send the rest of the data.

00:02:55.810 --> 00:02:58.560
This way the browser, when
it does the very first line

00:02:58.560 --> 00:03:00.420
layout, very first
paint of the page,

00:03:00.420 --> 00:03:05.220
can already put some rough
version of the images in.

00:03:05.220 --> 00:03:09.170
Next, new formats like the PNG.

00:03:09.170 --> 00:03:14.780
It's been 17 years and
GIF is still doing great.

00:03:14.780 --> 00:03:19.360
Why are we so bad at getting
rid of all the formats?

00:03:19.360 --> 00:03:22.530
PNG with GIF-like
transparency worked

00:03:22.530 --> 00:03:26.960
since IE4, that would be
like 147 Chrome versions ago.

00:03:29.572 --> 00:03:32.030
And you might be thinking, oh
those are probably anim GIFs,

00:03:32.030 --> 00:03:32.830
but, no.

00:03:32.830 --> 00:03:35.770
With an average size of
just seven kilobytes,

00:03:35.770 --> 00:03:38.620
all those GIFs, like a
quarter of images on the web,

00:03:38.620 --> 00:03:41.630
could be replaced with a
better format already today

00:03:41.630 --> 00:03:44.190
or 17 years ago.

00:03:44.190 --> 00:03:49.210
Now the real, real new formats,
it's an interesting situation.

00:03:49.210 --> 00:03:51.470
With dot WebP, which
is a very clever hack,

00:03:51.470 --> 00:03:56.370
it's like one frame of a video
adopted into an image format,

00:03:56.370 --> 00:04:01.600
so it's very good at
saving low quality images.

00:04:01.600 --> 00:04:03.720
Google is promoting
the format very heavily

00:04:03.720 --> 00:04:05.820
and is [INAUDIBLE] this.

00:04:05.820 --> 00:04:09.590
However, other vendors
are still unconvinced.

00:04:09.590 --> 00:04:14.520
Microsoft developed JPEG
extended range format, which

00:04:14.520 --> 00:04:17.029
is aiming to be a
very high quality

00:04:17.029 --> 00:04:22.310
format for digital cameras
that could potentially replace

00:04:22.310 --> 00:04:24.800
the raw format in
digital cameras.

00:04:24.800 --> 00:04:27.080
However, for the
use cases on the web

00:04:27.080 --> 00:04:30.540
the compression is
not that impressive.

00:04:30.540 --> 00:04:34.030
And Apple has been supporting
JPEG 2000 for a while.

00:04:34.030 --> 00:04:37.420
The format itself is
as old as it seems.

00:04:37.420 --> 00:04:42.690
And yet it failed to get
significant traction.

00:04:42.690 --> 00:04:45.620
Arguments against
JPEG 2000 are the same

00:04:45.620 --> 00:04:48.790
as arguments against
the other formats.

00:04:48.790 --> 00:04:52.380
That is, anything
younger than 20 years

00:04:52.380 --> 00:04:54.400
could be subject
to summary patents.

00:04:54.400 --> 00:04:56.420
And the large corporations
that are already

00:04:56.420 --> 00:05:01.590
harassed by patent controls
don't want to take extra risk.

00:05:01.590 --> 00:05:05.020
Newer formats are more
computationally complex,

00:05:05.020 --> 00:05:07.390
so could be slower to decode.

00:05:07.390 --> 00:05:09.890
And, finally, it's
a matter of opinion

00:05:09.890 --> 00:05:15.380
whether the gain of 20
or 30% of the file size

00:05:15.380 --> 00:05:19.260
is worth the pain of adopting
the new format in all

00:05:19.260 --> 00:05:23.480
the browsers, image editing
tools, image viewers,

00:05:23.480 --> 00:05:25.730
native apps, and
everything else.

00:05:25.730 --> 00:05:29.100
Mozilla has studied
some of the new formats

00:05:29.100 --> 00:05:31.490
and they've concluded
it's not worth it.

00:05:31.490 --> 00:05:34.910
They decided to stick
with JPEG, and improve

00:05:34.910 --> 00:05:37.120
the compression of JPEG instead.

00:05:37.120 --> 00:05:40.190
So most JPEG encoder
has been released.

00:05:40.190 --> 00:05:44.710
It narrows the compression gap
a little bit with newer formats.

00:05:44.710 --> 00:05:48.844
However, because of the
backwards compatibility,

00:05:48.844 --> 00:05:50.010
it cannot add Alpha Channel.

00:05:50.010 --> 00:05:52.390
It works with all browsers,
but its limited to what

00:05:52.390 --> 00:05:54.582
JPEG can do already.

00:05:54.582 --> 00:05:56.540
So for Alpha Channel we
have to resort to hacks

00:05:56.540 --> 00:06:00.580
like lose.png encoders
or masking with SVG,

00:06:00.580 --> 00:06:04.020
unless we have a newer format.

00:06:04.020 --> 00:06:07.030
And there are even newer formats
that's like next generation

00:06:07.030 --> 00:06:11.050
ahead, that maybe will
be in the future or not.

00:06:11.050 --> 00:06:15.970
So H.264 is the most popular
video codec on the web today.

00:06:15.970 --> 00:06:18.240
And its successor
could potentially

00:06:18.240 --> 00:06:20.480
be used as a static
image format.

00:06:20.480 --> 00:06:24.050
In tests it looks really good.

00:06:24.050 --> 00:06:25.510
However, it's a non-free codec.

00:06:25.510 --> 00:06:27.490
It's patented, so
it's a big problem

00:06:27.490 --> 00:06:30.350
for open source software.

00:06:30.350 --> 00:06:34.090
VP family of codecs is being
developed and extended.

00:06:34.090 --> 00:06:37.880
And it's looking really well.

00:06:37.880 --> 00:06:42.550
And there's an experimental
new codec from Xiph and Mozilla

00:06:42.550 --> 00:06:45.730
called Daala.

00:06:45.730 --> 00:06:48.800
But it's still too early to say
whether this will be successful

00:06:48.800 --> 00:06:49.810
or not.

00:06:49.810 --> 00:06:51.880
And a surprise.

00:06:51.880 --> 00:06:55.100
JPEG extensions are
being worked on.

00:06:55.100 --> 00:06:56.760
This is a way of
adding new features

00:06:56.760 --> 00:07:00.890
to the old JPEG in a way that's
hidden from old decoders.

00:07:00.890 --> 00:07:04.060
So the old browser will
see boring old JPEG.

00:07:04.060 --> 00:07:06.350
But new browsers that
adapt the extensions

00:07:06.350 --> 00:07:09.930
could support JPEG with Alpha
Channel, JPEG with better

00:07:09.930 --> 00:07:13.170
dynamic range, and
all the new features.

00:07:13.170 --> 00:07:14.710
And this work is
ongoing and could

00:07:14.710 --> 00:07:16.860
be finished within a year.

00:07:16.860 --> 00:07:19.990
So that's where
we are currently.

00:07:19.990 --> 00:07:21.240
GUY PODJARNY: Thanks for that.

00:07:26.220 --> 00:07:29.120
So I guess kicking off that,
the first question deals exactly

00:07:29.120 --> 00:07:32.400
with these new image formats,
and one that's constantly

00:07:32.400 --> 00:07:36.810
on my mind, which is, what's the
end game with these new image

00:07:36.810 --> 00:07:37.390
formats?

00:07:37.390 --> 00:07:39.137
Does one of these
formats prevail

00:07:39.137 --> 00:07:41.220
and we all agree that it's
better than the others?

00:07:41.220 --> 00:07:43.780
Do all browsers support
all the formats?

00:07:43.780 --> 00:07:46.320
Or do we just need to
cope, to deal with it,

00:07:46.320 --> 00:07:49.270
and learn to live with
this fragmentation?

00:07:49.270 --> 00:07:51.300
I guess, maybe, Ilya,
I'll start with you.

00:07:51.300 --> 00:07:54.490
I bug you about this
question every now and then.

00:07:54.490 --> 00:07:59.310
Should Chrome support JPEG
XR and IE support WebP?

00:07:59.310 --> 00:08:01.447
And have everybody
do everything?

00:08:01.447 --> 00:08:03.030
ILYA GRIGORIK: Ideally
everybody would

00:08:03.030 --> 00:08:05.130
implement every other's format.

00:08:05.130 --> 00:08:07.535
There's a lot of
gotchas with doing that.

00:08:07.535 --> 00:08:08.910
There's cyclical
reasons, there's

00:08:08.910 --> 00:08:13.725
political reasons, anything
to do with patents.

00:08:13.725 --> 00:08:15.900
It's a very complicated subject.

00:08:15.900 --> 00:08:22.520
I think we need to get away
from trying to design one image

00:08:22.520 --> 00:08:24.570
format that will rule them all.

00:08:24.570 --> 00:08:27.190
And instead accept that
there is experimentation.

00:08:27.190 --> 00:08:29.650
There will be different
formats to back.

00:08:29.650 --> 00:08:31.950
Why is it so hard to
develop a new format?

00:08:31.950 --> 00:08:35.140
Why did it take us 10 years
to deploy PNGs on the web?

00:08:35.140 --> 00:08:37.350
That was a very painful process.

00:08:37.350 --> 00:08:41.015
So what do we need to fix in
the ecosystem, in the platform,

00:08:41.015 --> 00:08:42.770
in the browsers,
and everywhere else

00:08:42.770 --> 00:08:44.500
to enable this sort of thing?

00:08:44.500 --> 00:08:47.570
So there's gotchas with
deploying new formats,

00:08:47.570 --> 00:08:48.980
like more fragmentation.

00:08:48.980 --> 00:08:51.840
The developers have to deal
with all of these more settings.

00:08:51.840 --> 00:08:53.730
I think a lot of that
can be automated.

00:08:53.730 --> 00:08:58.390
So I don't think we're going to
see a future where everybody's

00:08:58.390 --> 00:09:00.997
going to support
everybody else's format.

00:09:00.997 --> 00:09:02.580
GUY PODJARNY: So you
think, basically,

00:09:02.580 --> 00:09:04.210
to live with that fragmentation?

00:09:04.210 --> 00:09:06.751
ILYA GRIGORIK: Yeah, I think we
need to remove some barriers.

00:09:06.751 --> 00:09:07.910
Today it's just very hard.

00:09:07.910 --> 00:09:10.076
I think we're going to get
to some of the discussion

00:09:10.076 --> 00:09:12.580
around saving different
formats, and what

00:09:12.580 --> 00:09:15.930
happens when I can do
something in browser A,

00:09:15.930 --> 00:09:18.850
but I can't do it in browser
B, and my operating system

00:09:18.850 --> 00:09:19.674
can't preview it.

00:09:19.674 --> 00:09:21.340
So we just need to
work out those kinks,

00:09:21.340 --> 00:09:24.797
but I think once that's fixed,
it just becomes much easier.

00:09:24.797 --> 00:09:26.380
GUY PODJARNY: And
Kornel, do you think

00:09:26.380 --> 00:09:28.990
that when you look
out into the future,

00:09:28.990 --> 00:09:33.362
one of these backward compatible
image formats is the way to go?

00:09:33.362 --> 00:09:35.070
KORNEL LESINSKI: I
don't know the future,

00:09:35.070 --> 00:09:37.520
but looking at the
web's past, you

00:09:37.520 --> 00:09:39.560
can see that the
web is resisting

00:09:39.560 --> 00:09:41.380
backwards incompatible changes.

00:09:41.380 --> 00:09:44.870
So we had XHTML but
that didn't work.

00:09:44.870 --> 00:09:46.800
Now we have HTML5
that they're built

00:09:46.800 --> 00:09:48.540
on backwards compatibility.

00:09:48.540 --> 00:09:50.520
XForms didn't catch on.

00:09:50.520 --> 00:09:52.210
We had JPEG 2000 for a while.

00:09:52.210 --> 00:09:54.080
That didn't catch on.

00:09:54.080 --> 00:09:55.840
And GIF is still alive.

00:09:55.840 --> 00:09:58.560
We have made a video
in the browser that's

00:09:58.560 --> 00:10:01.290
15 times better than GIF
and hardware accelerated,

00:10:01.290 --> 00:10:02.750
but anim GIFs are
still everywhere,

00:10:02.750 --> 00:10:05.400
because they work everywhere.

00:10:05.400 --> 00:10:10.030
So I think the existing formats,
even though they're technically

00:10:10.030 --> 00:10:12.695
not the best, they have
a huge advantage because

00:10:12.695 --> 00:10:14.220
of the network effect.

00:10:14.220 --> 00:10:16.150
Because JPEG works everywhere.

00:10:16.150 --> 00:10:18.330
We don't even realize
how much the pain there

00:10:18.330 --> 00:10:23.170
is, that it has to be supported,
not only by top four browsers,

00:10:23.170 --> 00:10:25.910
it has to be supported by
your desktop operating system,

00:10:25.910 --> 00:10:28.090
by your mobile app, by
your Twitter client,

00:10:28.090 --> 00:10:30.820
by the website where
you upload your avatar.

00:10:30.820 --> 00:10:33.144
Those decoders have
to be everywhere.

00:10:33.144 --> 00:10:35.060
GUY PODJARNY: So what's
the solution for that?

00:10:35.060 --> 00:10:39.340
So we have that problem-- and I
guess Ilya you touched on this

00:10:39.340 --> 00:10:42.280
as well-- do you think--
is it picture element,

00:10:42.280 --> 00:10:44.360
and then kind of smarter--

00:10:44.360 --> 00:10:50.670
YOAV WEISS: I think that the
picture mind switching use case

00:10:50.670 --> 00:10:53.610
is part of the solution.

00:10:53.610 --> 00:10:59.860
Another part of that would
be adding key header support

00:10:59.860 --> 00:11:02.060
so that they accept header.

00:11:02.060 --> 00:11:08.290
Assuming that all browsers will
publicize properly their newer

00:11:08.290 --> 00:11:10.430
formats and their
access headers,

00:11:10.430 --> 00:11:14.490
you could actually cache it
better using the key header.

00:11:14.490 --> 00:11:17.230
And so yeah.

00:11:17.230 --> 00:11:18.430
Hope for the best.

00:11:18.430 --> 00:11:20.780
Hope that everyone
will converge.

00:11:20.780 --> 00:11:22.090
And plan for the worst.

00:11:22.090 --> 00:11:23.530
Plan for fragmentation.

00:11:23.530 --> 00:11:27.330
GUY PODJARNY: So I think if
we're moving toward this as

00:11:27.330 --> 00:11:29.900
if as we need to live with it,
because Chrome would always

00:11:29.900 --> 00:11:33.710
try to go out-innovate
IE, and vice versa.

00:11:33.710 --> 00:11:35.940
And also generally where
competition is good,

00:11:35.940 --> 00:11:37.640
and it's moving us along.

00:11:37.640 --> 00:11:41.149
Do you think that-- is
that realistic for somebody

00:11:41.149 --> 00:11:41.940
building a website?

00:11:41.940 --> 00:11:44.572
I mean, it's all good and well
on the technology front, but--

00:11:44.572 --> 00:11:45.280
ANN ROBSON: Yeah.

00:11:45.280 --> 00:11:49.980
I'd like to speak to
the question, which is,

00:11:49.980 --> 00:11:52.010
will we have all these
different image formats,

00:11:52.010 --> 00:11:53.310
or will one prevail?

00:11:53.310 --> 00:11:55.960
And I think, I mean,
I agree that we

00:11:55.960 --> 00:12:00.840
should be open to new formats
and support them and new ideas.

00:12:00.840 --> 00:12:01.950
But Kornel's right.

00:12:01.950 --> 00:12:04.430
We have these image formats
and they're like cockroaches.

00:12:04.430 --> 00:12:08.120
You know GIFS, animated
GIFs, aren't going away.

00:12:08.120 --> 00:12:11.370
And I think that we discovered
in the last few years

00:12:11.370 --> 00:12:13.780
that we haven't
actually appreciated

00:12:13.780 --> 00:12:16.060
what we've had quite enough.

00:12:16.060 --> 00:12:19.900
And that JPEG is actually
a really good image format.

00:12:19.900 --> 00:12:21.770
And there's a lot
we can do with JPEG.

00:12:21.770 --> 00:12:30.600
So I feel like we should
probably respect it a bit more.

00:12:30.600 --> 00:12:33.210
It's a 20-year-old format,
but-- what is it Kornel?

00:12:33.210 --> 00:12:35.580
I think somebody was
calling it the alien

00:12:35.580 --> 00:12:36.840
from the future, or something?

00:12:36.840 --> 00:12:38.040
KORNEL LESINSKI: Alien
technology from the future.

00:12:38.040 --> 00:12:38.950
Yes.

00:12:38.950 --> 00:12:40.540
ANN ROBSON: Yeah.

00:12:40.540 --> 00:12:42.460
KORNEL LESINSKI: That
quote is in a context

00:12:42.460 --> 00:12:45.555
of how hard it is to beat
JPEG, even though it's

00:12:45.555 --> 00:12:47.270
an old format
designed for computers

00:12:47.270 --> 00:12:50.270
that had 25 megahertz CPUs.

00:12:50.270 --> 00:12:54.180
Now we have codecs designed for
computers with gigahertz CPUs,

00:12:54.180 --> 00:12:58.220
and we're not beating JPEG by
a large margin, maybe 20, 30%,

00:12:58.220 --> 00:13:01.360
maybe 40% in very expensive,
experimental codecs.

00:13:01.360 --> 00:13:04.860
But we don't have a format
that is 10 times better.

00:13:04.860 --> 00:13:10.455
So for its age, JPEG
really nailed compression.

00:13:10.455 --> 00:13:12.140
GUY PODJARNY: Can we
get a mic to Jack?

00:13:15.000 --> 00:13:17.130
ANN ROBSON: And I think
that's really important.

00:13:17.130 --> 00:13:20.570
Because we have JPEG
and we can improve it.

00:13:20.570 --> 00:13:22.850
So I think that-- what is it?

00:13:22.850 --> 00:13:24.660
Mozjpeg is there.

00:13:24.660 --> 00:13:29.250
Mozilla is actually working on
improving the JPEG encoding.

00:13:29.250 --> 00:13:31.940
And I don't think anybody has
done this for a long time.

00:13:31.940 --> 00:13:33.440
We have just had
JPEG and we haven't

00:13:33.440 --> 00:13:36.630
thought about improving what
we have and what already works.

00:13:36.630 --> 00:13:39.210
So that's something
that we should focus on.

00:13:39.210 --> 00:13:42.500
I do want to have
all these good ideas,

00:13:42.500 --> 00:13:44.685
and have people creating
new image formats,

00:13:44.685 --> 00:13:46.310
and try to support
them, and figure out

00:13:46.310 --> 00:13:48.690
ways we can support them.

00:13:48.690 --> 00:13:52.070
But at the same time,
we want to move forward

00:13:52.070 --> 00:13:56.690
and we haven't moved forward
with image formats very much.

00:13:56.690 --> 00:14:01.910
So I feel like we should think
about what's important to us,

00:14:01.910 --> 00:14:03.830
and agree on that,
and move forward.

00:14:03.830 --> 00:14:06.760
And I think that-- sorry
for taking so much time-- I

00:14:06.760 --> 00:14:09.090
think that one of the things
that's important to me

00:14:09.090 --> 00:14:11.810
is progressive scans.

00:14:11.810 --> 00:14:14.140
I think that the image
format that we invest in,

00:14:14.140 --> 00:14:17.020
that we spend our time talking
about, and implementing,

00:14:17.020 --> 00:14:22.710
and serving, should be one
supports progressive scans.

00:14:22.710 --> 00:14:24.940
GUY PODJARNY: If you
can stand up for the AV.

00:14:24.940 --> 00:14:27.480
AUDIENCE: So speaking from
a browser point of view,

00:14:27.480 --> 00:14:28.995
I agree with Ilya,
that we're never

00:14:28.995 --> 00:14:31.370
going to see full support
across all the browsers for all

00:14:31.370 --> 00:14:32.370
these different formats.

00:14:32.370 --> 00:14:35.990
But I don't see why
they really need

00:14:35.990 --> 00:14:39.770
to if we can somehow figure
out a way for a new element,

00:14:39.770 --> 00:14:42.010
or something like that, to
basically-- you just say,

00:14:42.010 --> 00:14:44.760
here's the resource that I want,
regardless of some extension

00:14:44.760 --> 00:14:45.570
on the end of it.

00:14:45.570 --> 00:14:50.110
And just have the browser send
along its accepted abilities,

00:14:50.110 --> 00:14:52.220
of what it can have
returned to it.

00:14:52.220 --> 00:14:54.370
Is that something that
is on the horizon?

00:14:54.370 --> 00:14:56.424
Or is that something
that anybody's

00:14:56.424 --> 00:14:57.340
had interest in doing?

00:14:57.340 --> 00:14:58.600
YOAV WEISS: It's already here.

00:14:58.600 --> 00:15:00.230
ILYA GRIGORIK: Yeah,
so that exists.

00:15:00.230 --> 00:15:01.640
That's content negotiation.

00:15:01.640 --> 00:15:04.300
And you send an accept
header that's says,

00:15:04.300 --> 00:15:06.140
I support these formats.

00:15:06.140 --> 00:15:08.430
And the server then
picks the right format,

00:15:08.430 --> 00:15:11.230
the optimal format, perhaps,
for that particular client.

00:15:11.230 --> 00:15:12.660
So that works today.

00:15:12.660 --> 00:15:13.371
You can--

00:15:13.371 --> 00:15:15.496
AUDIENCE: Is it for a
specific content [INAUDIBLE]?

00:15:15.496 --> 00:15:18.719
Like I could get WebP
versus JPEG and [INAUDIBLE]?

00:15:18.719 --> 00:15:19.510
ILYA GRIGORIK: Yes.

00:15:19.510 --> 00:15:21.190
Yes, so that works today.

00:15:21.190 --> 00:15:23.350
Chrome will send an
accept header that says,

00:15:23.350 --> 00:15:24.880
I support WebP.

00:15:24.880 --> 00:15:27.120
So in fact, that's how we
recommend you deploy WebP.

00:15:27.120 --> 00:15:29.720
And now you can also use
Picture where you can manually

00:15:29.720 --> 00:15:32.190
specify all the
different variants,

00:15:32.190 --> 00:15:35.330
if you're willing to do that.

00:15:35.330 --> 00:15:38.190
GUY PODJARNY: So just maybe
to push back a little bit--

00:15:38.190 --> 00:15:40.810
so Kornel, you pointed out, hey
it's just 20 to 30% percent,

00:15:40.810 --> 00:15:43.370
but image bytes on the
web have grown by two

00:15:43.370 --> 00:15:46.700
or three-fold in just
two or three years.

00:15:46.700 --> 00:15:49.930
And for all indications,
generally, that trajectory

00:15:49.930 --> 00:15:52.190
is up and to the right.

00:15:52.190 --> 00:15:56.604
Saving 20 or 30% is not
an insubstantial amount.

00:15:56.604 --> 00:15:58.270
Should somebody make
an effort, if we're

00:15:58.270 --> 00:16:00.790
doing all these
different-- if we're

00:16:00.790 --> 00:16:03.610
going towards the
path of fragmentation,

00:16:03.610 --> 00:16:04.475
is it worthwhile?

00:16:04.475 --> 00:16:06.350
KORNEL LESINSKI: It's
a matter of trade offs.

00:16:06.350 --> 00:16:09.380
I don't think new format will
advance the industry by one

00:16:09.380 --> 00:16:14.480
year, because the connection
speeds grow by 20, 30% so--

00:16:14.480 --> 00:16:15.480
GUY PODJARNY: Arguably--

00:16:15.480 --> 00:16:16.332
[INTERPOSING VOICES]

00:16:16.332 --> 00:16:17.790
KORNEL LESINSKI:
With new format we

00:16:17.790 --> 00:16:21.840
can do this year what we would
be able to do anyway next year.

00:16:21.840 --> 00:16:24.640
So I think if we're looking
for a completely new format we

00:16:24.640 --> 00:16:27.750
should also look for something
that current formats completely

00:16:27.750 --> 00:16:28.590
cannot do.

00:16:28.590 --> 00:16:30.460
Because what we have
is the same thing

00:16:30.460 --> 00:16:33.340
we had 20 years ago,
but better compressed.

00:16:33.340 --> 00:16:37.020
But how about new formats
that support different kinds

00:16:37.020 --> 00:16:40.150
of Alpha Channel that
can do attitude blending,

00:16:40.150 --> 00:16:43.120
like all the blending
modes in Photoshop,

00:16:43.120 --> 00:16:46.710
or hybrid pixel vector formats.

00:16:46.710 --> 00:16:49.600
ANN ROBSON: Also, I think
that also stereo images.

00:16:49.600 --> 00:16:51.580
We never do 3D or
think about 3D,

00:16:51.580 --> 00:16:53.800
but our eyes are actually
seeing different pictures

00:16:53.800 --> 00:16:54.350
all the time.

00:16:54.350 --> 00:16:58.290
Why not support
this in the future?

00:16:58.290 --> 00:17:01.796
Stereo cameras may become
a big hit in a year.

00:17:01.796 --> 00:17:03.790
ILYA GRIGORIK: So it's
also a little bit of,

00:17:03.790 --> 00:17:06.760
maybe, push back on, the
bandwidth is increasing

00:17:06.760 --> 00:17:08.599
and hence everything
will be solved.

00:17:08.599 --> 00:17:10.390
That's not entirely
true, because bandwidth

00:17:10.390 --> 00:17:11.680
is only one part of it.

00:17:11.680 --> 00:17:12.930
We still have the round trips.

00:17:12.930 --> 00:17:15.130
And those round trips can
only carry so much data.

00:17:15.130 --> 00:17:18.089
So even the fact that you
have the latest LTE connection

00:17:18.089 --> 00:17:21.010
on your phone, doesn't mean
you can just push a 10 megabyte

00:17:21.010 --> 00:17:22.089
image immediately.

00:17:22.089 --> 00:17:22.880
GUY PODJARNY: Yeah.

00:17:22.880 --> 00:17:23.420
Right.

00:17:23.420 --> 00:17:25.180
Also we have
[INAUDIBLE] which is--

00:17:25.180 --> 00:17:26.055
ILYA GRIGORIK: Right.

00:17:26.055 --> 00:17:30.786
In fact, a 10 megabit connection
is but one megabyte a second.

00:17:30.786 --> 00:17:33.300
So it'll take a second
to download that image.

00:17:33.300 --> 00:17:35.770
And according to some of the
best practices that we're

00:17:35.770 --> 00:17:38.800
pushing, we're saying that your
page should load in one second.

00:17:38.800 --> 00:17:40.400
So what about all
the other resources?

00:17:40.400 --> 00:17:42.260
So I don't think
it's completely fair.

00:17:42.260 --> 00:17:44.900
It's certainly true that
as bandwidth is increasing,

00:17:44.900 --> 00:17:48.410
but that's not really
enough of a justification

00:17:48.410 --> 00:17:50.580
to say these 20,
30% don't matter,

00:17:50.580 --> 00:17:53.152
and these two things will
always go up at the same rate.

00:17:53.152 --> 00:17:55.610
GUY PODJARNY: Let's try to move
to the next question, which

00:17:55.610 --> 00:17:57.584
is actually along these lines.

00:17:57.584 --> 00:18:00.000
So let's say we want to live
with these different multiple

00:18:00.000 --> 00:18:03.172
image formats, what
do you think-- well I

00:18:03.172 --> 00:18:04.380
guess I'll read the question.

00:18:04.380 --> 00:18:06.505
Given the need to serve a
different image depending

00:18:06.505 --> 00:18:09.670
on factors like
displays, so small screen

00:18:09.670 --> 00:18:11.590
to small image to
small screen, browser

00:18:11.590 --> 00:18:13.460
capabilities for
the image formats,

00:18:13.460 --> 00:18:15.150
network conditions,
potentially lower

00:18:15.150 --> 00:18:17.890
quality image in poor
condition, should we

00:18:17.890 --> 00:18:19.670
be advocating for
different URLs for all

00:18:19.670 --> 00:18:20.920
of these different situations?

00:18:20.920 --> 00:18:24.920
Or for one dynamic
URL that adjusts?

00:18:24.920 --> 00:18:27.730
And, I guess, if the latter,
what's the right approach?

00:18:27.730 --> 00:18:29.371
Is it picture?

00:18:29.371 --> 00:18:30.370
Is a client negotiation?

00:18:35.310 --> 00:18:38.180
YOAV WEISS: Ideally, I would
say the best approach is

00:18:38.180 --> 00:18:41.490
the approach that works
for the developer that's

00:18:41.490 --> 00:18:44.540
maintaining the website.

00:18:44.540 --> 00:18:48.010
Currently there are problems
with the single URL approach,

00:18:48.010 --> 00:18:50.310
mostly related to
caching, mostly related

00:18:50.310 --> 00:18:52.770
to lack of key support.

00:18:56.630 --> 00:19:02.060
So this is something we will
have to work on in order

00:19:02.060 --> 00:19:06.290
to enable cache-able
single URL images.

00:19:06.290 --> 00:19:10.900
But after that it depends on--
it's a development preference.

00:19:10.900 --> 00:19:13.520
GUY PODJARNY: Yeah, but
still, what do we recommend?

00:19:13.520 --> 00:19:14.720
Everything depends.

00:19:14.720 --> 00:19:15.830
There is no golden answer.

00:19:15.830 --> 00:19:18.520
But should we try to advocate
towards pushing people

00:19:18.520 --> 00:19:22.302
towards one dynamic URL
and to put the effort

00:19:22.302 --> 00:19:23.260
behind that key header?

00:19:23.260 --> 00:19:26.522
Or should we be advocating
towards the picture element?

00:19:26.522 --> 00:19:28.230
YOAV WEISS: I think
we should enable both

00:19:28.230 --> 00:19:29.770
because the use
cases are different.

00:19:29.770 --> 00:19:36.830
A single URL means you have
a smart backend CDN module,

00:19:36.830 --> 00:19:40.900
something that you control
on the server side that

00:19:40.900 --> 00:19:45.070
pushes the right format
to the right browser.

00:19:45.070 --> 00:19:51.000
Multiple URL gives the
control to site's author.

00:19:51.000 --> 00:19:52.390
So you can do that.

00:19:52.390 --> 00:19:55.870
You can basically support
multiple image formats

00:19:55.870 --> 00:19:57.370
and mark up.

00:19:57.370 --> 00:19:58.960
These are different audiences.

00:19:58.960 --> 00:20:00.540
GUY PODJARNY: So you think
we have to have them both?

00:20:00.540 --> 00:20:01.910
YOAV WEISS: I think
we have to have both.

00:20:01.910 --> 00:20:04.070
ILYA GRIGORIK: I think the
practical answer is, today

00:20:04.070 --> 00:20:06.361
if you want to make it work
and work well, you probably

00:20:06.361 --> 00:20:10.380
have to end up erring on
the side of dedicated URLs.

00:20:10.380 --> 00:20:12.670
Just because your infrastructure
in between your CDN,

00:20:12.670 --> 00:20:14.045
your whatever, is
not configured,

00:20:14.045 --> 00:20:16.660
is not flexible enough
to allow all of that.

00:20:16.660 --> 00:20:18.110
But I would like
to fix that such

00:20:18.110 --> 00:20:19.740
that we move towards
the world where

00:20:19.740 --> 00:20:21.220
you don't have to do that.

00:20:21.220 --> 00:20:23.810
You don't have to have
a unique URL for each--

00:20:23.810 --> 00:20:27.754
you have to have a 100 URLs
for the same damn image,

00:20:27.754 --> 00:20:29.920
because one happens to be
in a different format, one

00:20:29.920 --> 00:20:31.419
the scale is set
slightly different,

00:20:31.419 --> 00:20:33.007
one is cropped this
way or that way.

00:20:33.007 --> 00:20:34.090
GUY PODJARNY: Why is that?

00:20:34.090 --> 00:20:37.692
I mean, what do you think
is the primary motivation,

00:20:37.692 --> 00:20:39.900
I guess, for having one URL
versus-- like today we're

00:20:39.900 --> 00:20:42.370
used to having one URL and we
don't need that complexity to

00:20:42.370 --> 00:20:42.530
[INAUDIBLE].

00:20:42.530 --> 00:20:44.280
ILYA GRIGORIK: To me
it's just automation.

00:20:44.280 --> 00:20:47.900
I just want to move the world
towards more automation.

00:20:47.900 --> 00:20:50.970
I shouldn't have to
think about negotiating

00:20:50.970 --> 00:20:54.119
the right image based on DPR.

00:20:54.119 --> 00:20:55.160
We have to do that today.

00:20:55.160 --> 00:20:58.110
And I think in the
long term, that's

00:20:58.110 --> 00:21:00.020
just too much complexity.

00:21:00.020 --> 00:21:03.990
YOAV WEISS: Yeah, you can also
automate it with a build step,

00:21:03.990 --> 00:21:07.940
assuming-- but I think we agree.

00:21:07.940 --> 00:21:11.310
ANN ROBSON: Oh, just that I
think that we'd screw it up.

00:21:11.310 --> 00:21:15.070
We wouldn't do it quite right
if we did ourselves, and, yeah.

00:21:15.070 --> 00:21:17.210
GUY PODJARNY: So
you think we should

00:21:17.210 --> 00:21:19.580
strive towards that single
URL, but we should also

00:21:19.580 --> 00:21:22.654
have automated tools,
have a generator,

00:21:22.654 --> 00:21:24.070
or make some
decisions, or help us

00:21:24.070 --> 00:21:25.570
make the decisions
about which image

00:21:25.570 --> 00:21:26.665
to send at any given time.

00:21:26.665 --> 00:21:27.300
ANN ROBSON: Yes.

00:21:27.300 --> 00:21:29.508
ILYA GRIGORIK: We're already
doing a lot of the stuff

00:21:29.508 --> 00:21:30.170
by encoding.

00:21:30.170 --> 00:21:33.700
Any sizable applications
already has an image resizing,

00:21:33.700 --> 00:21:35.900
manipulation-something server.

00:21:35.900 --> 00:21:39.060
You have one source of
origin, or source of truth,

00:21:39.060 --> 00:21:40.932
and then that one thing
gets rescaled to all

00:21:40.932 --> 00:21:41.890
the different variants.

00:21:41.890 --> 00:21:44.460
And right now we end up
encoding a lot of information

00:21:44.460 --> 00:21:47.020
in the URL, even though
a lot of that metadata

00:21:47.020 --> 00:21:50.170
is already available in an
image tag or the picture tag.

00:21:50.170 --> 00:21:51.890
Because you're saying,
my width is this,

00:21:51.890 --> 00:21:54.710
then you duplicate the
width in the URL as well.

00:21:54.710 --> 00:21:56.340
We can just get rid
of a lot of that,

00:21:56.340 --> 00:21:58.079
just make it much simpler.

00:21:58.079 --> 00:21:59.620
GUY PODJARNY: Well,
if I can actually

00:21:59.620 --> 00:22:01.540
pull in something from a
question we had further down.

00:22:01.540 --> 00:22:02.956
I mean, if we do
that when we talk

00:22:02.956 --> 00:22:05.034
about multiple
image and one image,

00:22:05.034 --> 00:22:06.450
one use case that
comes to mind is

00:22:06.450 --> 00:22:11.990
the notion of a single URL that
can be fetched by any client.

00:22:11.990 --> 00:22:15.050
And then maybe
subsequently opened

00:22:15.050 --> 00:22:17.370
by your operating system
and things like that.

00:22:17.370 --> 00:22:21.680
If we focus for now on
sharing a link on Twitter

00:22:21.680 --> 00:22:23.430
and having anybody be
able to [INAUDIBLE].

00:22:23.430 --> 00:22:28.130
Do you think that that basically
eliminated the possibility

00:22:28.130 --> 00:22:31.490
of making it be
picture element based?

00:22:31.490 --> 00:22:33.990
ILYA GRIGORIK: So
this-- can I jump in?

00:22:33.990 --> 00:22:37.660
This is actually a good argument
against having a dedicated URL.

00:22:37.660 --> 00:22:41.670
So let's say you have a
dot JPEG, and a dot WebP,

00:22:41.670 --> 00:22:43.840
and a dot something else.

00:22:43.840 --> 00:22:48.160
And the dot WebP is only
configured to serve WebP.

00:22:48.160 --> 00:22:50.820
I see that because I accessed
that thing in my browser

00:22:50.820 --> 00:22:51.770
that understands WebP.

00:22:51.770 --> 00:22:52.470
I copy that.

00:22:52.470 --> 00:22:53.990
I paste it into my email.

00:22:53.990 --> 00:22:58.150
And then you open it in
some other browser and you--

00:22:58.150 --> 00:22:58.730
what then?

00:22:58.730 --> 00:22:59.880
You can't open it.

00:22:59.880 --> 00:23:00.990
Now it's a broken image.

00:23:00.990 --> 00:23:03.475
So really that URL, even
though it says it's a dot WebP,

00:23:03.475 --> 00:23:05.100
needs to understand
the fact that there

00:23:05.100 --> 00:23:08.050
are other clients that may
not understand it and serve

00:23:08.050 --> 00:23:08.960
a different asset.

00:23:08.960 --> 00:23:10.532
So we're back to
the same one URL.

00:23:10.532 --> 00:23:11.990
GUY PODJARNY: So
given that, why do

00:23:11.990 --> 00:23:14.550
we need MIME type
decision in picture?

00:23:14.550 --> 00:23:18.220
YOAV WEISS: You could
also, for example,

00:23:18.220 --> 00:23:27.320
have the browser expose,
save shareable link--

00:23:27.320 --> 00:23:33.640
expose the JPEG URL
when sharing stuff.

00:23:33.640 --> 00:23:38.540
Exposed the-- You can Save As
even though you view the WebP.

00:23:38.540 --> 00:23:42.930
If you're doing Save As,
save as a sharable format

00:23:42.930 --> 00:23:45.679
you're saving to disc as JPEG.

00:23:45.679 --> 00:23:48.220
ILYA GRIGORIK: So Save As is a
little bit of a different case

00:23:48.220 --> 00:23:49.140
though.

00:23:49.140 --> 00:23:50.580
So I agree.

00:23:50.580 --> 00:23:55.280
Now we're into the discussion
of save a safe version.

00:23:55.280 --> 00:23:56.907
Whatever that means.

00:23:56.907 --> 00:23:58.990
And perhaps this is something
that browsers should

00:23:58.990 --> 00:24:01.620
do, like you viewing this
thing in whatever format,

00:24:01.620 --> 00:24:05.090
and when you're right
clicking and doing Save As,

00:24:05.090 --> 00:24:09.060
should we give you a PNG?

00:24:09.060 --> 00:24:12.150
It may be not good for
size, but at least it

00:24:12.150 --> 00:24:14.430
preserves the quality and
you can open it everywhere.

00:24:14.430 --> 00:24:15.180
Should we do that?

00:24:15.180 --> 00:24:15.680
Maybe.

00:24:15.680 --> 00:24:16.179
Maybe not.

00:24:16.179 --> 00:24:19.270
That doesn't really address the
sharing of a copy of the URL

00:24:19.270 --> 00:24:20.660
and paste it into email.

00:24:20.660 --> 00:24:20.940
[INTERPOSING VOICES]

00:24:20.940 --> 00:24:21.580
YOAV WEISS: --copy the URL.

00:24:21.580 --> 00:24:22.510
Yes, I agree.

00:24:22.510 --> 00:24:23.520
This is a downside.

00:24:23.520 --> 00:24:27.346
GUY PODJARNY: Let's take a
thought from the audience.

00:24:27.346 --> 00:24:28.220
AUDIENCE: Is this on?

00:24:28.220 --> 00:24:31.540
So in regards to having a
single URL and it not working

00:24:31.540 --> 00:24:33.340
if you copied to
another-- if you

00:24:33.340 --> 00:24:36.900
go to WebP in Firefox,
or IE, or whatever--

00:24:36.900 --> 00:24:39.220
isn't that true of any
proprietary format though?

00:24:39.220 --> 00:24:42.080
It was pushed like MHTML
formats didn't work in Chrome

00:24:42.080 --> 00:24:43.730
for the first 10
versions of Chrome,

00:24:43.730 --> 00:24:45.190
although they
always worked in IE.

00:24:45.190 --> 00:24:47.640
Why is that just because
something doesn't work,

00:24:47.640 --> 00:24:50.160
why is that necessarily
a bad thing?

00:24:50.160 --> 00:24:53.571
And how is that-- so if I
try and Coral that image

00:24:53.571 --> 00:24:55.570
and there's no content
negotiation automatically

00:24:55.570 --> 00:24:57.403
in Coral without that,
what would you serve?

00:24:57.403 --> 00:25:00.639
Or how does that fit into this
when you want a single URL?

00:25:00.639 --> 00:25:01.930
ILYA GRIGORIK: So you're right.

00:25:01.930 --> 00:25:04.280
It's nothing new.

00:25:04.280 --> 00:25:07.640
I don't think that's a
good experience overall,

00:25:07.640 --> 00:25:12.677
because people tend to
like to share photos and--

00:25:12.677 --> 00:25:13.510
ANN ROBSON: Exactly.

00:25:13.510 --> 00:25:14.010
That's all.

00:25:14.010 --> 00:25:15.880
I mean, people get pissed off.

00:25:15.880 --> 00:25:18.380
They're just going to
get angry at your site,

00:25:18.380 --> 00:25:23.280
at the site that provided this
image that they couldn't share

00:25:23.280 --> 00:25:24.840
the way they're used to sharing.

00:25:24.840 --> 00:25:26.381
KORNEL LESINSKI: It
just has to work.

00:25:26.381 --> 00:25:30.340
Plus having one URL for
negotiation off the format

00:25:30.340 --> 00:25:32.920
might actually be the easiest
option for the developer

00:25:32.920 --> 00:25:34.670
if they install some
kind of a server side

00:25:34.670 --> 00:25:39.630
software like Mod_Pagespeed that
will just do it automatically.

00:25:39.630 --> 00:25:42.590
So this is good for users
because URLs just work.

00:25:42.590 --> 00:25:44.990
This is the best in
terms of bandwidth,

00:25:44.990 --> 00:25:47.770
because every browser will
get the best format it can.

00:25:47.770 --> 00:25:50.420
And it's convenient
for the developer,

00:25:50.420 --> 00:25:52.655
because they just put
one format on the server,

00:25:52.655 --> 00:25:56.841
it could be even a PNG, and then
don't worry about compression.

00:25:56.841 --> 00:25:58.590
GUY PODJARNY: Should
we-- can we get a mic

00:25:58.590 --> 00:26:03.052
to wesbrock and Lucas.

00:26:03.052 --> 00:26:05.510
And in the meantime, it's worth
noting to highlight a point

00:26:05.510 --> 00:26:09.399
that Yoav made before, that
we do need to handle caches.

00:26:09.399 --> 00:26:11.940
And that if we are going to have
a single URL that's dynamic,

00:26:11.940 --> 00:26:13.450
it's important
that we make sure,

00:26:13.450 --> 00:26:16.070
whether it's your CDN, or
your server side caches,

00:26:16.070 --> 00:26:18.272
or whatever, support
that type of flexibility.

00:26:18.272 --> 00:26:19.730
GUY PODJARNY: Can
we just-- sorry--

00:26:19.730 --> 00:26:21.160
sorry let me just take a--

00:26:21.160 --> 00:26:24.310
YOAV WEISS: Just
one second point.

00:26:24.310 --> 00:26:28.650
We have had the same situation
for video for a while.

00:26:28.650 --> 00:26:32.460
So I don't know if this is
a big problem for video,

00:26:32.460 --> 00:26:33.680
but it's the same problem.

00:26:36.581 --> 00:26:38.080
AUDIENCE: I really
like this concept

00:26:38.080 --> 00:26:42.280
of having the Save As
attach to a different file,

00:26:42.280 --> 00:26:46.100
that you can source after you're
starting with a dynamic URL,

00:26:46.100 --> 00:26:49.850
because we've been talking
so far about the developer,

00:26:49.850 --> 00:26:52.970
and the developer
facing the end user.

00:26:52.970 --> 00:26:54.970
But one thing that we
haven't been talking about

00:26:54.970 --> 00:26:57.000
has been the content creator.

00:26:57.000 --> 00:26:59.150
And if I'm talking
about my friend's image

00:26:59.150 --> 00:27:01.920
that he took in Cabo,
maybe it doesn't really

00:27:01.920 --> 00:27:05.100
matter if all of the
attributions and metadata

00:27:05.100 --> 00:27:06.630
that we're pulling
out of that file

00:27:06.630 --> 00:27:10.680
to make our website's
performance is attached.

00:27:10.680 --> 00:27:15.650
But if this is a
Nobel winning image.

00:27:15.650 --> 00:27:17.380
It just came straight
out of Pulitzer's.

00:27:17.380 --> 00:27:19.690
You're going to want to
keep all of that metadata

00:27:19.690 --> 00:27:21.590
when someone saves
it, because you're not

00:27:21.590 --> 00:27:24.960
going to lose that attribution.

00:27:24.960 --> 00:27:29.650
So just in support
of the single URL

00:27:29.650 --> 00:27:31.960
allowing you to have multiple
options, because then you

00:27:31.960 --> 00:27:38.980
get to serve all three, if
not more, constituencies.

00:27:38.980 --> 00:27:40.786
GUY PODJARNY: Can we get Lucas?

00:27:40.786 --> 00:27:42.246
He has been waiting for--

00:27:42.246 --> 00:27:44.120
KORNEL LESINSKI: So in
the meantime, actually

00:27:44.120 --> 00:27:47.440
single URL for the
use case of metadata

00:27:47.440 --> 00:27:49.560
is not that helpful, because
we don't have any way

00:27:49.560 --> 00:27:51.740
to tell browser when
you want the version

00:27:51.740 --> 00:27:53.670
with metadata or without.

00:27:53.670 --> 00:27:56.320
Maybe that's something actually
for the picture element,

00:27:56.320 --> 00:27:58.420
where you could specify
different resolutions,

00:27:58.420 --> 00:28:00.870
some for the web and
some special version

00:28:00.870 --> 00:28:04.702
that's original, or lossless
or metadata-rich one.

00:28:04.702 --> 00:28:06.160
ILYA GRIGORIK: But
you could tackle

00:28:06.160 --> 00:28:07.730
that with the same mechanisms.

00:28:07.730 --> 00:28:09.830
Because basically what
you're asking for is,

00:28:09.830 --> 00:28:12.550
you have an asset, you want
to right-click and use--

00:28:12.550 --> 00:28:13.982
or just Save As.

00:28:13.982 --> 00:28:15.440
And in your except
header you could

00:28:15.440 --> 00:28:18.640
advertise, I want the
full fidelity thing,

00:28:18.640 --> 00:28:20.260
whatever that means.

00:28:20.260 --> 00:28:24.150
Perhaps your proxy re-sized
it to my view-port.

00:28:24.150 --> 00:28:25.740
I want the full thing.

00:28:25.740 --> 00:28:28.120
I want the high
resolution image.

00:28:28.120 --> 00:28:30.380
GUY PODJARNY: Let me take
the two, Lucas and Mark,

00:28:30.380 --> 00:28:32.385
and then we'll move
on to the next topic.

00:28:32.385 --> 00:28:35.860
AUDIENCE: So content
negotiation is not a new thing.

00:28:35.860 --> 00:28:37.900
And the ability to
have a single URL

00:28:37.900 --> 00:28:40.680
has been around for probably
10 years, I imagine.

00:28:40.680 --> 00:28:44.640
And in my experience
it's tough sledding

00:28:44.640 --> 00:28:47.210
to sell that to a
development team.

00:28:47.210 --> 00:28:50.130
So I think there's
a lot of elegance

00:28:50.130 --> 00:28:54.053
to content negotiation, or the
idea of having a single URL,

00:28:54.053 --> 00:28:56.080
that it presents
itself differently.

00:28:56.080 --> 00:28:57.900
But I think that's a
dedicated project that

00:28:57.900 --> 00:28:59.149
probably needs to be taken on.

00:28:59.149 --> 00:29:01.530
I imagine Mark
Nottingham, for example,

00:29:01.530 --> 00:29:07.190
and other people who have gotten
close to the problems there.

00:29:07.190 --> 00:29:09.430
But it's a separate issue.

00:29:09.430 --> 00:29:13.250
I think that the web developer
community has spoken clearly

00:29:13.250 --> 00:29:14.500
against it.

00:29:14.500 --> 00:29:16.760
I don't quite understand
why, because I

00:29:16.760 --> 00:29:18.350
appreciate the elegance of it.

00:29:18.350 --> 00:29:21.340
But I think the voice of
the developer community

00:29:21.340 --> 00:29:22.830
is pretty clear.

00:29:22.830 --> 00:29:25.480
ILYA GRIGORIK: So I'm not
convinced by that argument

00:29:25.480 --> 00:29:27.540
because we have GZIP.

00:29:27.540 --> 00:29:33.530
And you don't upload a dot
HTML dot GZ, or CSS dot GZ.

00:29:33.530 --> 00:29:34.870
That's content negotiation.

00:29:34.870 --> 00:29:37.150
There is a GZIP version
and some other version.

00:29:37.150 --> 00:29:39.525
It's the same thing as saying,
here's a PNG which is high

00:29:39.525 --> 00:29:41.760
fidelity, versus
a compressed JPEG.

00:29:41.760 --> 00:29:43.360
So it works.

00:29:43.360 --> 00:29:44.830
We use it every day.

00:29:44.830 --> 00:29:49.050
I think there are
problems in our facts,

00:29:49.050 --> 00:29:52.350
in terms of the caches, and all
the rest, where we don't have

00:29:52.350 --> 00:29:57.030
enough granularity to be
able to precisely target

00:29:57.030 --> 00:29:58.450
particular assets.

00:29:58.450 --> 00:30:00.210
So we end up doing
things like oh, vary on

00:30:00.210 --> 00:30:02.150
accept, but the
accept header happens

00:30:02.150 --> 00:30:06.290
to be this very highly
fragmented-- or high entropy

00:30:06.290 --> 00:30:08.650
string, which basically
fragments the cache.

00:30:08.650 --> 00:30:09.900
So we got to fix those things.

00:30:09.900 --> 00:30:13.930
That's what Yoav was referencing
by the key stack, which

00:30:13.930 --> 00:30:15.619
is something that
Mark is working on.

00:30:15.619 --> 00:30:16.910
GUY PODJARNY: Let me take Mark.

00:30:16.910 --> 00:30:18.410
One last note, and
then we're really

00:30:18.410 --> 00:30:21.820
way over time on this one.

00:30:21.820 --> 00:30:23.920
AUDIENCE: So-- oh jeez.

00:30:23.920 --> 00:30:26.780
Yeah, I think 10 years ago,
15 years ago the community

00:30:26.780 --> 00:30:30.494
was fairly anti, but I
think I agree with Ilya.

00:30:30.494 --> 00:30:31.660
The tools are getting there.

00:30:31.660 --> 00:30:33.270
There's a lot more
intermediaries doing things

00:30:33.270 --> 00:30:34.120
with [INAUDIBLE].

00:30:34.120 --> 00:30:35.560
It's getting easier.

00:30:35.560 --> 00:30:36.930
My question was about key.

00:30:36.930 --> 00:30:41.400
It sounds like you guys were
depending on it, more or less.

00:30:41.400 --> 00:30:43.230
It's not done.

00:30:43.230 --> 00:30:45.900
And there are actually some
hard problems inside of it.

00:30:45.900 --> 00:30:49.520
But we've also not seen a lot
of browser interest in it yet.

00:30:49.520 --> 00:30:51.690
I need browser
engagement by those guys.

00:30:51.690 --> 00:30:53.330
And we need to
actually implement.

00:30:53.330 --> 00:30:57.460
Unless Yoav pulls this trick
again and raises 15 grand,

00:30:57.460 --> 00:30:59.364
somebody needs to go
and write the code.

00:30:59.364 --> 00:31:00.780
GUY PODJARNY:
That's a fair point.

00:31:00.780 --> 00:31:02.155
I'm actually going
to pause here,

00:31:02.155 --> 00:31:05.810
because we're almost
two questions in there.

00:31:05.810 --> 00:31:07.490
Let's talk about the next one.

00:31:07.490 --> 00:31:11.540
So when we look at these
different image formats,

00:31:11.540 --> 00:31:14.600
it seems like every entity
has their own different image

00:31:14.600 --> 00:31:15.400
formats.

00:31:15.400 --> 00:31:18.320
So came the question
from Patty, when

00:31:18.320 --> 00:31:21.730
will we have a test benchmark
for image performance?

00:31:21.730 --> 00:31:25.640
And if we have that,
what should it include?

00:31:25.640 --> 00:31:27.157
ANN ROBSON: No good reason.

00:31:27.157 --> 00:31:28.740
Definitely, we should
have a benchmark

00:31:28.740 --> 00:31:31.000
for image performance.

00:31:31.000 --> 00:31:35.110
I think that we should have a
benchmark for image compression

00:31:35.110 --> 00:31:35.930
as well.

00:31:35.930 --> 00:31:40.460
We don't even have a-- well
I guess we do, the Lenna.

00:31:40.460 --> 00:31:45.490
There's this image that
people use from 1973.

00:31:45.490 --> 00:31:47.630
So I think that we
could update this.

00:31:47.630 --> 00:31:51.920
And we need to understand
what these lossy image

00:31:51.920 --> 00:31:53.260
formats do to our image.

00:31:53.260 --> 00:31:56.350
So I think that we should
have a set of images

00:31:56.350 --> 00:32:01.200
that we use that are good
examples of how images get

00:32:01.200 --> 00:32:02.800
degraded when they get encoded.

00:32:02.800 --> 00:32:06.010
So we should do that, and then
also for image performance,

00:32:06.010 --> 00:32:06.946
definitely.

00:32:06.946 --> 00:32:08.070
We should think about that.

00:32:08.070 --> 00:32:09.900
When we're considering
these things

00:32:09.900 --> 00:32:12.712
we should figure out
exactly what we need.

00:32:12.712 --> 00:32:14.836
GUY PODJARNY: Let's take,
actually, Jonas's opinion

00:32:14.836 --> 00:32:16.120
and then go back to panel.

00:32:16.120 --> 00:32:17.310
AUDIENCE: Yeah, I
was actually-- when

00:32:17.310 --> 00:32:18.760
we were on the
first topic, I was

00:32:18.760 --> 00:32:21.510
going to suggest
exactly this, that one

00:32:21.510 --> 00:32:24.220
of the big reasons Mozilla
has not gotten behind WebP

00:32:24.220 --> 00:32:26.580
is that there
plainly disagreements

00:32:26.580 --> 00:32:29.220
about how much better
is compared to JPEG.

00:32:29.220 --> 00:32:34.090
And I have no idea who
is right about this.

00:32:34.090 --> 00:32:38.600
But I think having a benchmark
that people can agree

00:32:38.600 --> 00:32:41.030
is sort of representative
of today's web,

00:32:41.030 --> 00:32:43.236
would provide a lot more
information than what

00:32:43.236 --> 00:32:44.360
we have to go on right now.

00:32:44.360 --> 00:32:47.720
Because people just disagree
on how many percent better

00:32:47.720 --> 00:32:48.695
is this versus that.

00:32:48.695 --> 00:32:51.830
And this is not just
WebP versus JPEG,

00:32:51.830 --> 00:32:53.380
it's between all
of these formats.

00:32:53.380 --> 00:32:54.990
GUY PODJARNY: What
would you include?

00:32:54.990 --> 00:32:58.022
So in that debate back then, one
of the, for instance, questions

00:32:58.022 --> 00:33:00.230
was around whether you should
use the existing images

00:33:00.230 --> 00:33:02.064
on the web as the
source, or whatever

00:33:02.064 --> 00:33:03.480
it is you were
going to encode to,

00:33:03.480 --> 00:33:09.030
versus the pristine image that
might have been your original.

00:33:09.030 --> 00:33:10.280
Maybe there are other debates.

00:33:10.280 --> 00:33:12.410
What would you include
in that type of image?

00:33:12.410 --> 00:33:13.630
And that type of a benchmark?

00:33:13.630 --> 00:33:15.290
AUDIENCE: I think
compare-- I think

00:33:15.290 --> 00:33:17.740
what you want to do-- the
thing that actually matters

00:33:17.740 --> 00:33:22.134
is how fast can you
download, and the image that

00:33:22.134 --> 00:33:23.550
is being displayed
in the browser.

00:33:23.550 --> 00:33:26.280
I don't care how
you can compress

00:33:26.280 --> 00:33:28.800
that the 10 megabyte
original image,

00:33:28.800 --> 00:33:30.560
and how much smaller
you can make that.

00:33:30.560 --> 00:33:33.780
What actually matters is that
the smaller images that we

00:33:33.780 --> 00:33:38.830
downloaded and render on web
pages, how many bytes smaller

00:33:38.830 --> 00:33:40.160
can we make them?

00:33:40.160 --> 00:33:41.900
One of the really
hard things is there

00:33:41.900 --> 00:33:46.230
are four different ways of
measuring image quality.

00:33:46.230 --> 00:33:50.070
And I have no idea what the
different algorithms are.

00:33:52.504 --> 00:33:54.420
I don't know if we need
to measure all of them

00:33:54.420 --> 00:33:56.870
in this benchmark, or if we
just need to as a community

00:33:56.870 --> 00:33:59.800
agree on one or two
that are sort of more

00:33:59.800 --> 00:34:04.750
representative for what the
human eye actually appreciates.

00:34:04.750 --> 00:34:13.510
But I think that having a
discussion around what we

00:34:13.510 --> 00:34:16.290
should actually measure,
because a bad benchmark--

00:34:16.290 --> 00:34:18.665
this something we see lot in
JavaScript-- a bad benchmark

00:34:18.665 --> 00:34:22.864
can do just as much harm
as a good benchmark.

00:34:22.864 --> 00:34:24.780
GUY PODJARNY: Now, Kornel,
you deal with this.

00:34:24.780 --> 00:34:26.920
You benchmark your own
tools all the time.

00:34:26.920 --> 00:34:28.860
KORNEL LESINSKI: Yes,
that's a big problem

00:34:28.860 --> 00:34:32.880
for my work on PNG compressors.

00:34:32.880 --> 00:34:37.520
Although there are standard test
suites for photo-like images

00:34:37.520 --> 00:34:40.600
there's popular
codec image suite.

00:34:40.600 --> 00:34:43.469
There is no test
suite that includes

00:34:43.469 --> 00:34:45.420
Alpha Channel for images.

00:34:45.420 --> 00:34:48.420
So for testing how well
Alpha Channel compresses,

00:34:48.420 --> 00:34:51.210
I have to steal
images from the web.

00:34:51.210 --> 00:34:54.710
But this is not a set of images
that I could share with anybody

00:34:54.710 --> 00:34:59.810
to let them compare
their results with mine.

00:34:59.810 --> 00:35:04.750
There's also a big problem
of judging actual quality.

00:35:04.750 --> 00:35:09.650
So we have machine algorithms
that sort of emulate

00:35:09.650 --> 00:35:13.620
how the eyes see
distortions in images,

00:35:13.620 --> 00:35:15.690
but this is very imperfect.

00:35:15.690 --> 00:35:16.930
But it's also very sensitive.

00:35:16.930 --> 00:35:20.050
The algorithm can detect
a half a percent change

00:35:20.050 --> 00:35:21.720
in image quality,
which is needed

00:35:21.720 --> 00:35:24.255
when you're
developing your codec.

00:35:24.255 --> 00:35:26.630
When you tweak something and
make it half percent better,

00:35:26.630 --> 00:35:28.110
you want to keep that change.

00:35:28.110 --> 00:35:31.020
But if you ask a human, is
that half percent better

00:35:31.020 --> 00:35:34.707
than the other image, they
will not be able to tell you.

00:35:34.707 --> 00:35:36.290
GUY PODJARNY: Which
is similar to the,

00:35:36.290 --> 00:35:38.230
which algorithm do
we use for quality?

00:35:38.230 --> 00:35:38.880
What's the bar?

00:35:38.880 --> 00:35:39.420
What's the threshold?

00:35:39.420 --> 00:35:41.260
KORNEL LESINSKI:
Yes, and since there

00:35:41.260 --> 00:35:44.490
are different implementations of
different approximations of how

00:35:44.490 --> 00:35:47.460
people judge quality, there
are different opinions.

00:35:47.460 --> 00:35:50.430
And if you use one
algorithm, then

00:35:50.430 --> 00:35:53.892
somebody developing a
different codec will tell you,

00:35:53.892 --> 00:35:55.350
no you've used the
wrong algorithm.

00:35:55.350 --> 00:35:59.310
You should be benchmarking
using my algorithm on my images.

00:35:59.310 --> 00:36:02.900
ILYA GRIGORIK: So I think this
is also one of the reasons

00:36:02.900 --> 00:36:06.370
why we have so much disagreement
in all the different formats,

00:36:06.370 --> 00:36:08.650
is because everybody
uses their own test set.

00:36:08.650 --> 00:36:11.140
So when we say images,
do we mean photos?

00:36:11.140 --> 00:36:12.110
High res photos?

00:36:12.110 --> 00:36:15.142
Do we mean the PNGs,
and the Alpha Channel,

00:36:15.142 --> 00:36:15.850
and all the rest?

00:36:15.850 --> 00:36:16.920
GUY PODJARNY: And animated GIFs.

00:36:16.920 --> 00:36:17.460
ILYA GRIGORIK:
And animated GIFs.

00:36:17.460 --> 00:36:18.370
Right.

00:36:18.370 --> 00:36:22.420
So one of the things that the
WebP team has been pushing

00:36:22.420 --> 00:36:26.330
for all time is, we always say
we're optimized for the web.

00:36:26.330 --> 00:36:31.870
In the sense that, we try
to grab images off the web

00:36:31.870 --> 00:36:34.650
as they are being
used today, not just

00:36:34.650 --> 00:36:37.851
a bunch of really high def
raw formats off my camera.

00:36:37.851 --> 00:36:38.600
That's a use case.

00:36:38.600 --> 00:36:40.620
That's a totally
valid use case, that

00:36:40.620 --> 00:36:43.460
is not representative
of the entire web.

00:36:43.460 --> 00:36:44.890
And we try to
optimize for those.

00:36:44.890 --> 00:36:48.500
In fact, we see a lot
better compression and gains

00:36:48.500 --> 00:36:54.180
on the long tail
of weird images.

00:36:54.180 --> 00:36:56.274
The stuff we put
in PNGs is bizarre,

00:36:56.274 --> 00:36:57.190
KORNEL LESINSKI: Yeah.

00:36:57.190 --> 00:37:00.360
The problem for me is, I
don't run Google Images,

00:37:00.360 --> 00:37:02.220
so I don't have
access to that set.

00:37:02.220 --> 00:37:02.950
ILYA GRIGORIK: Well,
we don't actually

00:37:02.950 --> 00:37:04.660
have good access
to that set either.

00:37:04.660 --> 00:37:06.161
But one idea would
be to say, great,

00:37:06.161 --> 00:37:08.535
let's go to [INAUDIBLE] archive,
download all the images,

00:37:08.535 --> 00:37:10.760
and just re-compress all of
them with our algorithms.

00:37:10.760 --> 00:37:12.135
But then you
discover that you're

00:37:12.135 --> 00:37:14.960
re-compressing artifacts
of other formats.

00:37:14.960 --> 00:37:18.480
So really, ideally we
would have the origin

00:37:18.480 --> 00:37:19.790
or the original asset.

00:37:19.790 --> 00:37:21.984
And then we would have
a test against all

00:37:21.984 --> 00:37:22.900
the different formats.

00:37:22.900 --> 00:37:25.330
But that's very hard to come by.

00:37:25.330 --> 00:37:28.440
YOAV WEISS: That's one of the
criticisms I heard regarding

00:37:28.440 --> 00:37:34.160
WebP, the fact that current
numbers are achieved

00:37:34.160 --> 00:37:37.130
by re-compressing,
introduce their own bias,

00:37:37.130 --> 00:37:39.260
and their own artifacts.

00:37:39.260 --> 00:37:40.109
So--

00:37:40.109 --> 00:37:41.650
ILYA GRIGORIK: So,
and this is funny,

00:37:41.650 --> 00:37:44.520
because we actually had this
really long discussion--

00:37:44.520 --> 00:37:47.140
the WebP team with
the Google+ team--

00:37:47.140 --> 00:37:49.270
that they really
care about photos.

00:37:49.270 --> 00:37:51.510
They want to deliver
really beautiful photos.

00:37:51.510 --> 00:37:52.920
And at one point
we found that we

00:37:52.920 --> 00:37:55.480
were talking to the
product managers,

00:37:55.480 --> 00:38:00.277
effectively trying to replicate
JPEG compression artifact.

00:38:00.277 --> 00:38:01.360
The formats are different.

00:38:01.360 --> 00:38:03.026
You're going to get
different artifacts.

00:38:03.026 --> 00:38:04.770
But they really liked
the JPEG artifacts.

00:38:04.770 --> 00:38:05.970
GUY PODJARNY: Which once again--

00:38:05.970 --> 00:38:06.680
ILYA GRIGORIK:
Because it's like,

00:38:06.680 --> 00:38:08.055
that's what we're
used to seeing.

00:38:08.055 --> 00:38:09.450
But look this is so--

00:38:09.450 --> 00:38:09.600
GUY PODJARNY: Similarity.

00:38:09.600 --> 00:38:10.900
Do you need to be
similar to the original,

00:38:10.900 --> 00:38:12.130
or similar to the codec?

00:38:12.130 --> 00:38:14.867
Let's take Wesley's point.

00:38:14.867 --> 00:38:15.950
AUDIENCE: Can you hear me?

00:38:15.950 --> 00:38:16.992
There we go.

00:38:16.992 --> 00:38:18.950
Going back to the comment
that was made earlier

00:38:18.950 --> 00:38:21.200
about file size,
does that really

00:38:21.200 --> 00:38:25.900
matter when the decoder
may take longer,

00:38:25.900 --> 00:38:28.830
say for the instance
WebP versus JPEG?

00:38:28.830 --> 00:38:30.550
WebP's going to take
longer to decode

00:38:30.550 --> 00:38:32.830
that image based
on the CPU and what

00:38:32.830 --> 00:38:35.160
system resources
that computer has.

00:38:35.160 --> 00:38:38.460
So how do you get a benchmark
for that kind of performance

00:38:38.460 --> 00:38:40.987
and are you guys
concerned about that?

00:38:40.987 --> 00:38:41.820
ILYA GRIGORIK: Yeah.

00:38:41.820 --> 00:38:43.620
So definitely a big concern.

00:38:43.620 --> 00:38:47.550
So in speaking about WebP,
it's definitely an area

00:38:47.550 --> 00:38:49.200
that we're looking to improve.

00:38:49.200 --> 00:38:53.022
So we're lending new incremental
decoding improvements

00:38:53.022 --> 00:38:53.730
and all the rest.

00:38:53.730 --> 00:38:56.021
There is hardware support
that will come down the road.

00:38:56.021 --> 00:38:58.110
It's kind of a chicken
and egg problem.

00:38:58.110 --> 00:39:03.691
And despite that, we do see
that when we run test studies--

00:39:03.691 --> 00:39:05.190
eBay actually did
a study where they

00:39:05.190 --> 00:39:06.740
converted all their
images to WebP.

00:39:06.740 --> 00:39:10.425
And they compared decoding
time versus the delivery time.

00:39:10.425 --> 00:39:13.050
Because the images were shipped
much faster, even though you're

00:39:13.050 --> 00:39:15.830
decoding it longer, they
still showed up faster.

00:39:15.830 --> 00:39:17.270
So you can quantify
these things.

00:39:17.270 --> 00:39:20.445
You can use something like,
see how much of the image

00:39:20.445 --> 00:39:24.654
is rendered at each point in
time and-- It is quantifiable.

00:39:24.654 --> 00:39:26.570
GUY PODJARNY: Let's get
David's point and move

00:39:26.570 --> 00:39:27.319
to the next topic.

00:39:30.000 --> 00:39:30.940
David.

00:39:30.940 --> 00:39:33.750
AUDIENCE: I guess
the one other thing

00:39:33.750 --> 00:39:41.530
to think about is that there's
this final size versus quality

00:39:41.530 --> 00:39:42.580
trade off.

00:39:42.580 --> 00:39:45.570
And what these new
formats are doing

00:39:45.570 --> 00:39:48.080
is sort of very
slightly shifting

00:39:48.080 --> 00:39:52.340
that curve in the file size
versus quality trade off.

00:39:52.340 --> 00:39:57.407
But I guess the other question
the developers, I think,

00:39:57.407 --> 00:39:59.490
should think about is, are
they at the right point

00:39:59.490 --> 00:40:00.150
on that curve.

00:40:00.150 --> 00:40:02.500
Are people making the
file size versus quality

00:40:02.500 --> 00:40:04.179
trade off that they
want to be making?

00:40:04.179 --> 00:40:04.970
ILYA GRIGORIK: Yes.

00:40:04.970 --> 00:40:05.470
OK.

00:40:05.470 --> 00:40:09.310
This is a big topic and
an under-explored topic.

00:40:09.310 --> 00:40:13.240
So we're pushing new formats
that are getting 10, 15, 20,

00:40:13.240 --> 00:40:15.355
30% improvement in file size.

00:40:15.355 --> 00:40:17.480
But there is the other side
of this equation, which

00:40:17.480 --> 00:40:21.100
is all those formats have
the quality slider, which

00:40:21.100 --> 00:40:23.120
the developers and designers
are just not using.

00:40:23.120 --> 00:40:24.770
Because we don't have
the right tooling

00:40:24.770 --> 00:40:26.090
to expose that sort of thing.

00:40:26.090 --> 00:40:29.780
And it's like a quality
40 or 50 on a WebP

00:40:29.780 --> 00:40:32.020
is completely different
from a quality 50 on JPEG.

00:40:32.020 --> 00:40:34.180
In fact, it's a
different output,

00:40:34.180 --> 00:40:36.890
even if you use different
JPEG compressors.

00:40:36.890 --> 00:40:38.940
Each one introduces
its own artifacts.

00:40:38.940 --> 00:40:42.890
So I think we could
do way, way better job

00:40:42.890 --> 00:40:46.610
by providing some better tooling
and visualization to when

00:40:46.610 --> 00:40:49.284
you're saving these
images, or automation.

00:40:49.284 --> 00:40:51.450
How do you find the right
point on that curve, where

00:40:51.450 --> 00:40:54.260
the trade off between
how much the image has

00:40:54.260 --> 00:40:56.650
degraded versus savings.

00:40:56.650 --> 00:40:58.860
YOAV WEISS: The
thing is there are--

00:40:58.860 --> 00:41:00.690
I'm not sure we have
the ideal tools,

00:41:00.690 --> 00:41:08.370
but we have tools like image
men that Kornel worked on.

00:41:08.370 --> 00:41:11.910
It was based on some
previous metric.

00:41:11.910 --> 00:41:17.080
He added SM, which is more
standard image visual metric,

00:41:17.080 --> 00:41:22.900
in order to just binary
search is the ideal quantity.

00:41:22.900 --> 00:41:27.250
So a developer can define,
I want a 5% quality loss,

00:41:27.250 --> 00:41:29.090
or something much
more quantifiable

00:41:29.090 --> 00:41:31.355
than the quality
setting which is--

00:41:31.355 --> 00:41:32.980
GUY PODJARNY: We're
kind of going over.

00:41:32.980 --> 00:41:34.330
But I think that
actually shows up.

00:41:34.330 --> 00:41:36.246
We can probably discuss
this a little bit more

00:41:36.246 --> 00:41:39.030
in the next question,
which is, what

00:41:39.030 --> 00:41:40.830
should be our
strategy for managing

00:41:40.830 --> 00:41:42.430
these multi-resolution images.

00:41:42.430 --> 00:41:44.655
So a part of it is about,
maybe, just the image,

00:41:44.655 --> 00:41:45.530
the straight tooling.

00:41:45.530 --> 00:41:49.100
But as dealing with that
image becomes more complex,

00:41:49.100 --> 00:41:52.260
as we mentioned before already
a certain bias in favor

00:41:52.260 --> 00:41:56.077
of automation, if we're going
to use the single URL, what

00:41:56.077 --> 00:41:57.035
should be the strategy?

00:41:57.035 --> 00:41:59.120
Should people try
and pre-generate

00:41:59.120 --> 00:42:00.170
these ahead of time?

00:42:00.170 --> 00:42:02.975
Because a lot of these tools
around the binary search,

00:42:02.975 --> 00:42:05.100
for instance, are very hard
to do real time, or not

00:42:05.100 --> 00:42:08.414
practical at all sometimes
to do in real time.

00:42:08.414 --> 00:42:09.330
What's the right move?

00:42:09.330 --> 00:42:10.871
Kornel, what do you
think about that?

00:42:10.871 --> 00:42:13.850
KORNEL LESINSKI: So generating
multiple resolution images

00:42:13.850 --> 00:42:15.520
by hand is super boring.

00:42:15.520 --> 00:42:17.430
So we definitely,
definitely should

00:42:17.430 --> 00:42:20.430
have tools that automate this.

00:42:20.430 --> 00:42:22.760
And when we have a tool
that automatically generates

00:42:22.760 --> 00:42:24.760
different sizes,
we can no longer

00:42:24.760 --> 00:42:28.910
ask the author to tweak this
quality slider themselves.

00:42:28.910 --> 00:42:31.700
So I want to completely
eliminate the quality slider

00:42:31.700 --> 00:42:33.630
from all [INAUDIBLE] for images.

00:42:33.630 --> 00:42:34.690
It's a complete lie.

00:42:34.690 --> 00:42:36.870
It's not actual
quality you're getting.

00:42:36.870 --> 00:42:39.700
It's just arbitrary
mathematical formula

00:42:39.700 --> 00:42:42.380
for throwing away bits
of data from the file.

00:42:42.380 --> 00:42:45.270
And it makes some
files ugly, some files

00:42:45.270 --> 00:42:48.790
can tolerate more compression.

00:42:48.790 --> 00:42:52.330
And we should use CPU
power that we have,

00:42:52.330 --> 00:42:56.490
algorithms that we to try
to get the right quality.

00:42:56.490 --> 00:42:58.350
Even if the algorithm
is not perfect,

00:42:58.350 --> 00:43:01.290
it's probably still going to
be better than many authors who

00:43:01.290 --> 00:43:04.120
have their favorite
number they always

00:43:04.120 --> 00:43:06.135
use for all their images.

00:43:06.135 --> 00:43:08.010
GUY PODJARNY: Ann, what
would you want to do?

00:43:08.010 --> 00:43:11.410
What's your optimal-- you
need to support these 17

00:43:11.410 --> 00:43:13.786
different variants images and
optimize them in your site.

00:43:13.786 --> 00:43:15.035
ANN ROBSON: I mean, automatic.

00:43:15.035 --> 00:43:16.415
I'm not going to
do that by hand.

00:43:16.415 --> 00:43:17.831
GUY PODJARNY:
Automatic real time?

00:43:17.831 --> 00:43:19.760
Or automatic build time?

00:43:19.760 --> 00:43:21.907
Like automatic in the delivery?

00:43:21.907 --> 00:43:23.240
ANN ROBSON: Yeah, I am not sure.

00:43:23.240 --> 00:43:24.940
I think probably in delivery.

00:43:24.940 --> 00:43:27.680
Although it'd be nice
to check them, right?

00:43:27.680 --> 00:43:29.410
I think that's
amazing what Kornel

00:43:29.410 --> 00:43:32.009
is saying, that we should
get rid of the sliders.

00:43:32.009 --> 00:43:33.050
I mean, he's saying that.

00:43:33.050 --> 00:43:34.840
He saying we should
get rid of the quality

00:43:34.840 --> 00:43:38.000
sliders in our images
that we're optimizing.

00:43:38.000 --> 00:43:39.870
Wow.

00:43:39.870 --> 00:43:41.150
I think that's right.

00:43:41.150 --> 00:43:44.850
I think we as humans-- the
numbers are magic numbers

00:43:44.850 --> 00:43:47.950
that we come up with, don't
work for all of the photos.

00:43:47.950 --> 00:43:50.450
And that maybe we can
automatically figure out

00:43:50.450 --> 00:43:53.100
what's the best,
exactly the best

00:43:53.100 --> 00:43:55.070
quality, to set a
certain photo at.

00:43:55.070 --> 00:43:56.382
That's cool.

00:43:56.382 --> 00:43:57.840
GUY PODJARNY: I
think I cut you off

00:43:57.840 --> 00:44:00.590
before Yoav, but [INAUDIBLE].

00:44:00.590 --> 00:44:03.550
YOAV WEISS: I think that
the question of offline

00:44:03.550 --> 00:44:09.100
versus online-- so offline will
always get you better ratios,

00:44:09.100 --> 00:44:10.500
but you can't always do that.

00:44:10.500 --> 00:44:17.900
So offline when you can,
and otherwise-- I mean,

00:44:17.900 --> 00:44:21.260
even if you compress on the fly,
you should probably cache it,

00:44:21.260 --> 00:44:24.470
and you should probably
try to re-compress

00:44:24.470 --> 00:44:28.100
the original after the fact.

00:44:28.100 --> 00:44:31.280
But we're talking about
fairly complex back end, but--

00:44:34.170 --> 00:44:37.990
As we said, the image mend
stuff, the binary search,

00:44:37.990 --> 00:44:42.830
re-compress the image multiple
times, that's CPU consuming.

00:44:42.830 --> 00:44:45.080
That's not something
you can do on the fly.

00:44:45.080 --> 00:44:48.909
GUY PODJARNY: Let's take
a question from Mark.

00:44:48.909 --> 00:44:50.450
AUDIENCE: So I just
wanted to provide

00:44:50.450 --> 00:44:52.360
a little color for that.

00:44:52.360 --> 00:44:54.100
We do generate a photo-shelter.

00:44:54.100 --> 00:44:56.230
We deal with a lot
of image delivery

00:44:56.230 --> 00:45:01.660
from very high resolution
files to non-lossy files,

00:45:01.660 --> 00:45:03.220
raws, et cetera.

00:45:03.220 --> 00:45:06.070
And we have to generate
web-friendly versions.

00:45:06.070 --> 00:45:09.125
So we do do the image
variants multi res on the fly.

00:45:09.125 --> 00:45:12.520
But I just want to tie together
with the previous compression

00:45:12.520 --> 00:45:15.900
discussion and how difficult
it is to benchmark.

00:45:15.900 --> 00:45:20.730
And even with algorithmic
ways to analyze quality,

00:45:20.730 --> 00:45:24.060
it doesn't really
capture the subjective,

00:45:24.060 --> 00:45:25.580
the perceptual aspect of it.

00:45:25.580 --> 00:45:29.584
And we basically change our
image pipeline, not too often,

00:45:29.584 --> 00:45:30.250
every few years.

00:45:30.250 --> 00:45:32.450
But when we do it
takes a whole year

00:45:32.450 --> 00:45:35.440
to decide what trade
offs are worthwhile.

00:45:35.440 --> 00:45:36.920
And we did find
that this question

00:45:36.920 --> 00:45:39.594
about JPEG quality--
we're using JPEG.

00:45:39.594 --> 00:45:41.010
We're not using
any-- because it's

00:45:41.010 --> 00:45:43.110
the only thing that
works universally.

00:45:43.110 --> 00:45:46.650
But it gets complicated, because
with the multi-resolution,

00:45:46.650 --> 00:45:49.410
and also the compression,
the rescaling,

00:45:49.410 --> 00:45:51.560
they are all interactive.

00:45:51.560 --> 00:45:55.530
So we have found that
actually that doing

00:45:55.530 --> 00:45:59.496
that file size and quality trade
off depends on also the size

00:45:59.496 --> 00:46:00.870
that you're
delivering the image.

00:46:00.870 --> 00:46:02.700
That actually on a
larger resolution image

00:46:02.700 --> 00:46:04.850
you can get away with
more compression and kind

00:46:04.850 --> 00:46:06.520
of counterbalance.

00:46:06.520 --> 00:46:08.434
So I think that is very
important, obviously.

00:46:08.434 --> 00:46:10.350
I'm not saying that any
of these image formats

00:46:10.350 --> 00:46:12.308
are trying to be
prescriptive, but you can only

00:46:12.308 --> 00:46:15.360
get so far trying to optimize
the algorithm and the format.

00:46:15.360 --> 00:46:17.890
Because you need to leave
a certain amount of control

00:46:17.890 --> 00:46:20.320
to the developer and
the delivery mechanism.

00:46:20.320 --> 00:46:23.690
Because we did find that we have
to fine tune it significantly.

00:46:23.690 --> 00:46:25.610
And now with high
DPI displays, now you

00:46:25.610 --> 00:46:27.901
can get away with even more
compression to deliver even

00:46:27.901 --> 00:46:30.720
a larger asset, that's
not perceptually relevant.

00:46:30.720 --> 00:46:32.202
So that's just a
little feedback.

00:46:32.202 --> 00:46:32.910
GUY PODJARNY: OK.

00:46:32.910 --> 00:46:33.410
Thanks.

00:46:33.410 --> 00:46:34.190
That's good input.

00:46:34.190 --> 00:46:35.740
So we only have a
few more minutes,

00:46:35.740 --> 00:46:37.364
let me actually skip
a couple questions

00:46:37.364 --> 00:46:40.620
and switch to the crystal
ball question at the end.

00:46:40.620 --> 00:46:44.180
Which is, one of the reasons
for the growth of images

00:46:44.180 --> 00:46:50.130
has been retina displays, and
now we have a batch of new 3X,

00:46:50.130 --> 00:46:53.460
or kind of 3X
screens, which Android

00:46:53.460 --> 00:46:56.052
has been doing in
iOS, which Android

00:46:56.052 --> 00:46:57.400
has been doing for awhile.

00:46:57.400 --> 00:47:01.130
What would you guess,
I guess-- what's

00:47:01.130 --> 00:47:03.830
your prediction for the future?

00:47:03.830 --> 00:47:06.030
Are we done at the 2, 3X?

00:47:06.030 --> 00:47:09.590
Is there ever a done component
of their virtual reality

00:47:09.590 --> 00:47:11.099
of 3D images?

00:47:11.099 --> 00:47:12.640
You had an opinion
about this before.

00:47:12.640 --> 00:47:14.556
ANN ROBSON: Yeah, my
opinion was I don't care,

00:47:14.556 --> 00:47:18.020
because we're not doing what
we can right now with 2X.

00:47:18.020 --> 00:47:22.820
So I think that
at a certain point

00:47:22.820 --> 00:47:24.320
we can't really
tell the difference.

00:47:24.320 --> 00:47:26.830
Like there's not going to be
such a jump from 2X to 3X.

00:47:26.830 --> 00:47:28.800
It's not really going to be 3X.

00:47:28.800 --> 00:47:33.930
I don't think that-- I
think that-- I don't know--

00:47:33.930 --> 00:47:37.150
I'm on the side delivering
worse images faster,

00:47:37.150 --> 00:47:39.964
than delivering perfect images.

00:47:39.964 --> 00:47:41.630
GUY PODJARNY: It's
not about the density

00:47:41.630 --> 00:47:44.387
but more about, we need
to educate our users

00:47:44.387 --> 00:47:45.720
to try to get progressive image.

00:47:45.720 --> 00:47:46.690
First get something then--

00:47:46.690 --> 00:47:47.200
ANN ROBSON: Definitely.

00:47:47.200 --> 00:47:47.699
Definitely.

00:47:47.699 --> 00:47:49.430
Let's focus on that first.

00:47:49.430 --> 00:47:50.640
But I think it's exciting.

00:47:50.640 --> 00:47:53.680
I'd love to see a high
retina image on the web.

00:47:53.680 --> 00:47:55.990
I think it's really beautiful.

00:47:55.990 --> 00:47:59.350
But I'm not sure how much
more we could push it.

00:47:59.350 --> 00:48:02.100
GUY PODJARNY: And Kornel, did
have some opinions on this?

00:48:02.100 --> 00:48:04.308
KORNEL LESINSKI: Well, we
are upgrading our displays,

00:48:04.308 --> 00:48:06.142
but we're not
upgrading our eyes yet.

00:48:06.142 --> 00:48:08.490
And the eyes are the
ultimate benchmark.

00:48:08.490 --> 00:48:09.010
So I think--

00:48:09.010 --> 00:48:10.630
GUY PODJARNY: We should
work on upgrading our eyes.

00:48:10.630 --> 00:48:12.720
KORNEL LESINSKI: Yes, we
should go for cyborgs.

00:48:12.720 --> 00:48:15.080
But before that, I think
we'll settle on something

00:48:15.080 --> 00:48:17.970
like 2X or 3X, because it
just doesn't make any sense

00:48:17.970 --> 00:48:19.590
to put more pixels.

00:48:19.590 --> 00:48:21.465
GUY PODJARNY: What do
you think Ilya of that?

00:48:21.465 --> 00:48:23.673
ILYA GRIGORIK: If I remember
the marketing correctly,

00:48:23.673 --> 00:48:25.120
retina was supposed
to be defined

00:48:25.120 --> 00:48:27.280
as you can see the
difference anymore.

00:48:27.280 --> 00:48:31.890
So when they come up with retina
HD, and you're just like--

00:48:31.890 --> 00:48:33.820
can't see the difference.

00:48:33.820 --> 00:48:37.260
GUY PODJARNY: But practically
speaking, that's fine for us,

00:48:37.260 --> 00:48:40.290
maybe, performance
nerds here saying that.

00:48:40.290 --> 00:48:43.710
But the reality is
that they did shift 3X

00:48:43.710 --> 00:48:46.060
and would they shift 4X?

00:48:46.060 --> 00:48:49.874
And would our designers insist
that they want to use those?

00:48:49.874 --> 00:48:54.150
YOAV WEISS: I think we need
data on how much of a difference

00:48:54.150 --> 00:49:00.540
does it make if we send
out 2X images, to 3X,

00:49:00.540 --> 00:49:04.970
4X whatever-X displays,
and have hard data so

00:49:04.970 --> 00:49:07.940
that if the designers
come with 4X images,

00:49:07.940 --> 00:49:09.490
we can throw them out the door.

00:49:09.490 --> 00:49:14.800
And there was at
Velocity last week--

00:49:14.800 --> 00:49:19.680
this week-- research regarding
that progressive JPEGs that

00:49:19.680 --> 00:49:23.940
was done, basically, by
looking at how people react

00:49:23.940 --> 00:49:26.720
to images displayed
on the screen.

00:49:26.720 --> 00:49:33.670
And regardless of the result,
which is somewhat surprising,

00:49:33.670 --> 00:49:40.770
I think we need to do the same
for contentiously bad images.

00:49:40.770 --> 00:49:44.550
What happens if we display
1X images on a 3X display?

00:49:44.550 --> 00:49:47.410
How bad is it, as far
as user experience goes?

00:49:47.410 --> 00:49:49.510
Same for 2X images, et cetera.

00:49:49.510 --> 00:49:50.052
We need data.

00:49:50.052 --> 00:49:51.884
GUY PODJARNY: We need
to switch to the data.

00:49:51.884 --> 00:49:53.730
Yeah, the results there
were not favorable

00:49:53.730 --> 00:49:57.280
of progressive images,
despite everybody's hypothesis

00:49:57.280 --> 00:50:00.320
in the room ahead of time.

00:50:00.320 --> 00:50:04.160
So I think-- OK we still
have five more minutes.

00:50:04.160 --> 00:50:07.320
So I misestimated
the times here.

00:50:07.320 --> 00:50:10.460
So I guess we switch
to Andrew's question

00:50:10.460 --> 00:50:14.810
from here, which is those
are all technical questions,

00:50:14.810 --> 00:50:17.210
but if we talk a little bit
about a use case question.

00:50:17.210 --> 00:50:19.460
Move one back.

00:50:19.460 --> 00:50:20.940
How important is
it that an image

00:50:20.940 --> 00:50:25.430
format we use on
a website is one

00:50:25.430 --> 00:50:27.920
that a user can save and
view in a different spot.

00:50:27.920 --> 00:50:29.420
I mean, we touched
this a little bit

00:50:29.420 --> 00:50:32.030
because we talked
about the multi URL,

00:50:32.030 --> 00:50:34.100
so they can open it
everywhere, but does it

00:50:34.100 --> 00:50:36.170
matter that the OS
gets into the display?

00:50:36.170 --> 00:50:39.090
Or are we done with browsers?

00:50:39.090 --> 00:50:41.320
ILYA GRIGORIK: So
I think it really

00:50:41.320 --> 00:50:42.570
depends on the use case of it.

00:50:42.570 --> 00:50:44.620
Ideally, it should be viewable.

00:50:44.620 --> 00:50:46.462
So if I save it, I
should be able to view it

00:50:46.462 --> 00:50:49.730
with whatever software
that I have, by default.

00:50:49.730 --> 00:50:50.870
That would be nice.

00:50:50.870 --> 00:50:53.190
We do have some
examples where that

00:50:53.190 --> 00:50:54.540
doesn't appear to be a problem.

00:50:54.540 --> 00:50:56.827
So, for example,
Opera and Chrome,

00:50:56.827 --> 00:50:58.410
we have the compression
proxies, which

00:50:58.410 --> 00:51:02.380
have been transcoding all
images WebP for years.

00:51:02.380 --> 00:51:03.620
And users are happy.

00:51:03.620 --> 00:51:06.670
And as far I'm aware I have
not heard anybody scream

00:51:06.670 --> 00:51:09.414
about saving out
images as WebPs,

00:51:09.414 --> 00:51:10.580
which is what you would get.

00:51:10.580 --> 00:51:14.940
Because if you don't have a the
safe save, or something else.

00:51:14.940 --> 00:51:15.900
So that's an example.

00:51:15.900 --> 00:51:17.316
There are plenty
of big sites that

00:51:17.316 --> 00:51:21.810
also use WebP, eBay,
OKCupid, all those sites.

00:51:21.810 --> 00:51:23.370
It doesn't appear
to be a problem.

00:51:23.370 --> 00:51:24.930
Is that a good answer?

00:51:24.930 --> 00:51:26.389
I'm not convinced
that it is, but--

00:51:26.389 --> 00:51:28.346
GUY PODJARNY: But you
don't think it's blocker.

00:51:28.346 --> 00:51:29.230
ILYA GRIGORIK: No.

00:51:29.230 --> 00:51:31.563
GUY PODJARNY: You think our
primary conversations should

00:51:31.563 --> 00:51:34.714
remain in browser-land
and the OS would catch up.

00:51:34.714 --> 00:51:36.380
ILYA GRIGORIK: If
your use case actually

00:51:36.380 --> 00:51:39.240
involves downloading an image,
you have a photo gallery

00:51:39.240 --> 00:51:44.030
and an actual "save as"
is not a right click--

00:51:44.030 --> 00:51:46.450
I'm not even sure how many
like nontechnical users know

00:51:46.450 --> 00:51:48.190
to right click and "save as."

00:51:48.190 --> 00:51:50.320
They're probably fishing
for the Download button

00:51:50.320 --> 00:51:51.547
somewhere in the UI.

00:51:51.547 --> 00:51:53.130
That button should
do something smart,

00:51:53.130 --> 00:51:56.100
like not save the
fancy new format.

00:51:56.100 --> 00:51:58.170
It should save the safe format.

00:51:58.170 --> 00:51:59.440
Can browsers do a better job?

00:51:59.440 --> 00:52:00.296
Probably.

00:52:00.296 --> 00:52:02.140
GUY PODJARNY: And Ann
do you think that when

00:52:02.140 --> 00:52:04.256
you deal with the social
sharing platform--

00:52:04.256 --> 00:52:06.130
ANN ROBSON: Yeah, I
think it's very important

00:52:06.130 --> 00:52:10.340
to be able to not
break the image.

00:52:10.340 --> 00:52:11.944
But yeah, and I think
Ilya was getting

00:52:11.944 --> 00:52:13.610
on something really
kind of interesting.

00:52:13.610 --> 00:52:15.318
It depends on what
kind of site you have.

00:52:15.318 --> 00:52:17.601
If you have your
own photo gallery,

00:52:17.601 --> 00:52:19.100
I think it's important
for you to be

00:52:19.100 --> 00:52:22.690
able to "save as" right
click, drag to your desktop.

00:52:22.690 --> 00:52:25.565
There's kind of cool hack I
think only with Chrome where

00:52:25.565 --> 00:52:26.940
when you drag to
your desktop you

00:52:26.940 --> 00:52:29.040
can deliver a different
high res image.

00:52:29.040 --> 00:52:31.000
That's kind of cool.

00:52:31.000 --> 00:52:32.550
But yeah, definitely.

00:52:32.550 --> 00:52:33.680
I don't like the idea.

00:52:33.680 --> 00:52:35.210
I love right clicking.

00:52:35.210 --> 00:52:38.429
I love like taking images
offline and sharing them.

00:52:38.429 --> 00:52:39.970
GUY PODJARNY: So
it's important to be

00:52:39.970 --> 00:52:41.962
able to do the Save As
we talked about before,

00:52:41.962 --> 00:52:44.170
but then if you'd need to
convert to something that's

00:52:44.170 --> 00:52:45.864
a little bit more universal.

00:52:45.864 --> 00:52:46.530
ANN ROBSON: Yes.

00:52:46.530 --> 00:52:48.440
KORNEL LESINSKI: But
people do share images.

00:52:48.440 --> 00:52:50.610
They remics images.

00:52:50.610 --> 00:52:56.150
All your LOLCat images, they
were saved from somewhere.

00:52:56.150 --> 00:52:58.860
So WebP can work
as sort of a DRM

00:52:58.860 --> 00:53:01.150
for photos, where you
save it to desktop,

00:53:01.150 --> 00:53:02.590
and then you try to open it.

00:53:02.590 --> 00:53:04.090
Oh you don't have
the right plug in.

00:53:07.435 --> 00:53:10.210
GUY PODJARNY: Can we
get Margaret a mic?

00:53:10.210 --> 00:53:11.440
AUDIENCE: Hi.

00:53:11.440 --> 00:53:13.180
I work on Firefox for Android.

00:53:13.180 --> 00:53:16.510
And we actually
have UI telemetry

00:53:16.510 --> 00:53:18.780
to see what people
use in the browser.

00:53:18.780 --> 00:53:22.260
And actually the Save
Image context menu,

00:53:22.260 --> 00:53:25.970
in Firefox at least, is one
of the highest menu items

00:53:25.970 --> 00:53:26.860
that people use.

00:53:26.860 --> 00:53:28.726
And we kind of wonder
what kind of images

00:53:28.726 --> 00:53:29.850
they're saving necessarily.

00:53:29.850 --> 00:53:32.690
But I just want to
throw out that data.

00:53:32.690 --> 00:53:34.940
That we do have data that
people use that a lot

00:53:34.940 --> 00:53:36.794
so you probably wouldn't
want to break that.

00:53:36.794 --> 00:53:38.450
ANN ROBSON: Excellent.

00:53:38.450 --> 00:53:39.790
GUY PODJARNY: Interesting.

00:53:39.790 --> 00:53:42.670
YOAV WEISS: So safe
sharing, safe saving

00:53:42.670 --> 00:53:44.770
should probably be a thing.

00:53:44.770 --> 00:53:51.390
Either for client side markup
picture-based multiple images,

00:53:51.390 --> 00:53:54.110
or for server side, because
we can play with the except

00:53:54.110 --> 00:53:55.817
headers.

00:53:55.817 --> 00:53:57.650
ANN ROBSON: I think
that this panel actually

00:53:57.650 --> 00:53:58.920
has an action item.

00:53:58.920 --> 00:53:59.580
GUY PODJARNY: I think
there are good items.

00:53:59.580 --> 00:54:01.163
So we talked about--
I think we agreed

00:54:01.163 --> 00:54:03.864
that we want a single
URL, not multiple images,

00:54:03.864 --> 00:54:05.530
that we need to create
a test benchmark,

00:54:05.530 --> 00:54:08.120
although we haven't talked
about how we actually

00:54:08.120 --> 00:54:10.936
go about doing that-- one
that everybody agrees upon.

00:54:10.936 --> 00:54:13.540
KORNEL LESINSKI: So maybe if
you have really good images that

00:54:13.540 --> 00:54:16.670
you cannot compress well,
send them to [INAUDIBLE].

00:54:16.670 --> 00:54:17.610
GUY PODJARNY: Just email
them to Kornel or put them

00:54:17.610 --> 00:54:19.735
in DropBox or something,
because the email is going

00:54:19.735 --> 00:54:21.860
to be too big, and
compress them before.

00:54:21.860 --> 00:54:22.710
No don't

00:54:22.710 --> 00:54:24.250
KORNEL LESINSKI: No don't.

00:54:24.250 --> 00:54:25.355
PNG is good.

00:54:25.355 --> 00:54:26.980
ANN ROBSON: I think
we should seriously

00:54:26.980 --> 00:54:29.500
try to get a set of
images that are going

00:54:29.500 --> 00:54:33.200
to be our test
benchmark and do this.

00:54:33.200 --> 00:54:37.064
Kornel or one of us should take
the responsibility for this.

00:54:37.064 --> 00:54:38.480
GUY PODJARNY: So
on that note, let

00:54:38.480 --> 00:54:40.030
me use the last
minute we have here

00:54:40.030 --> 00:54:43.230
to talk about building
that benchmark.

00:54:43.230 --> 00:54:45.920
Who do you think should that
type of effort come from?

00:54:45.920 --> 00:54:49.880
Should that be Mozilla, Chrome,
like one of the browser vendors

00:54:49.880 --> 00:54:52.310
that's switching the
image formats, doing it?

00:54:52.310 --> 00:54:53.710
Should it be a standards--

00:54:53.710 --> 00:54:55.400
ILYA GRIGORIK: It's
a moving target.

00:54:55.400 --> 00:54:58.200
Ideally, I'd like to have
some sort of a process,

00:54:58.200 --> 00:55:01.190
sort of like [INAUDIBLE]
archive, where we just say,

00:55:01.190 --> 00:55:02.840
here's the latest set of images.

00:55:02.840 --> 00:55:06.050
And perhaps our job is to
define some sort of filters

00:55:06.050 --> 00:55:09.990
on all those images, to say
these are the safe ones to use.

00:55:09.990 --> 00:55:12.520
Because I also don't
want to freeze that

00:55:12.520 --> 00:55:15.610
set, because the web evolves.

00:55:15.610 --> 00:55:18.710
All a sudden we are
serving 2X and 3X images.

00:55:18.710 --> 00:55:20.680
And perhaps they're at
different algorithms

00:55:20.680 --> 00:55:23.290
and do better at high
resolution images.

00:55:23.290 --> 00:55:23.999
So that process--

00:55:23.999 --> 00:55:25.456
ANN ROBSON: Yeah,
it's interesting.

00:55:25.456 --> 00:55:27.750
It's like, what is the
average kind of content also

00:55:27.750 --> 00:55:30.250
that is being served
on the internet?

00:55:30.250 --> 00:55:31.670
How do we even get that?

00:55:31.670 --> 00:55:32.920
But that's important because--

00:55:32.920 --> 00:55:35.461
ILYA GRIGORIK: It turns out the
most popular image on the web

00:55:35.461 --> 00:55:37.230
is a one by one pixel.

00:55:37.230 --> 00:55:39.086
It's like, let's compress that.

00:55:39.086 --> 00:55:40.946
ANN ROBSON: Done.

00:55:40.946 --> 00:55:42.570
GUY PODJARNY: Well,
I think we're done.

00:55:42.570 --> 00:55:44.800
Thank you very much.

