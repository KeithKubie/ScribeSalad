WEBVTT
Kind: captions
Language: en

00:00:00.500 --> 00:00:03.367
[MUSIC PLAYING]

00:00:04.190 --> 00:00:05.440
HIDEAKI OSHIMA: Hi, everybody.

00:00:05.440 --> 00:00:07.450
Thank you for joining us today.

00:00:07.450 --> 00:00:09.480
My name is Hideaki
Oshima, and I'm

00:00:09.480 --> 00:00:12.360
the product manager on the
Android Authentication team

00:00:12.360 --> 00:00:14.340
here at Google.

00:00:14.340 --> 00:00:17.520
And we are here today to
talk about best practices

00:00:17.520 --> 00:00:21.207
for getting your users
signed into your Android app.

00:00:21.207 --> 00:00:22.290
So let's dive straight in.

00:00:26.500 --> 00:00:28.680
Now, as I'm sure
you're all aware,

00:00:28.680 --> 00:00:32.240
user authentication can
be a complex problem.

00:00:32.240 --> 00:00:34.610
There are lots of different
solutions out there,

00:00:34.610 --> 00:00:38.000
and it can get very confusing
very quickly, especially

00:00:38.000 --> 00:00:40.840
from the user's perspective.

00:00:40.840 --> 00:00:43.560
Now, let's imagine
your user, or a user,

00:00:43.560 --> 00:00:48.390
goes and downloads an app and
is taken to this sign-in page.

00:00:48.390 --> 00:00:50.060
Now, at the top
of the page, they

00:00:50.060 --> 00:00:53.270
might see buttons to sign in
using a federated identity

00:00:53.270 --> 00:00:54.740
provider.

00:00:54.740 --> 00:00:58.120
And, at this point, the
user might be wondering, hm,

00:00:58.120 --> 00:00:59.320
what are these buttons?

00:00:59.320 --> 00:01:01.100
Have I used them before?

00:01:01.100 --> 00:01:03.040
Can I trust them?

00:01:03.040 --> 00:01:05.550
And as a user makes their
way further down the page,

00:01:05.550 --> 00:01:08.470
now they might see the classic
username and password entry

00:01:08.470 --> 00:01:09.676
fields.

00:01:09.676 --> 00:01:12.790
And, at this point, if the
user is anything like me,

00:01:12.790 --> 00:01:15.070
they're probably realizing
that they completely

00:01:15.070 --> 00:01:17.870
forgot their credentials.

00:01:17.870 --> 00:01:19.760
Ultimately, if
this were your app,

00:01:19.760 --> 00:01:23.330
your user might go through a
password or account recovery

00:01:23.330 --> 00:01:26.780
flow, which could be
costly for you guys,

00:01:26.780 --> 00:01:29.480
or they might end up
creating and signing up

00:01:29.480 --> 00:01:31.880
with a brand new
account, which could lead

00:01:31.880 --> 00:01:35.390
to a loss of user data and,
ultimately or possibly,

00:01:35.390 --> 00:01:37.830
less user engagement.

00:01:37.830 --> 00:01:43.180
Worse yet, you might end up
losing that user entirely.

00:01:43.180 --> 00:01:45.020
So as you think through
the sign-in problem,

00:01:45.020 --> 00:01:47.760
you're probably wondering
which of the different options

00:01:47.760 --> 00:01:50.290
you should be offering
to your users.

00:01:50.290 --> 00:01:52.180
As I mentioned in
the previous slide,

00:01:52.180 --> 00:01:55.690
you can allow your user to sign
in using a federated identity

00:01:55.690 --> 00:01:57.970
provider such as Google.

00:01:57.970 --> 00:02:02.510
You can also offer the classic
username and password option.

00:02:02.510 --> 00:02:06.310
You can also allow users to
sign up using their phone number

00:02:06.310 --> 00:02:10.009
or sign in using biometrics.

00:02:10.009 --> 00:02:12.740
And it's not just sign-in that
you're worried about, right?

00:02:12.740 --> 00:02:14.750
Once your users
are signed in, you

00:02:14.750 --> 00:02:18.110
want to make sure that both
your users and your app

00:02:18.110 --> 00:02:21.110
are protected from
account abuse.

00:02:21.110 --> 00:02:23.060
You also want to make
sure your users can

00:02:23.060 --> 00:02:28.852
easily and securely submit
their payment information.

00:02:28.852 --> 00:02:30.310
So with all of the
different things

00:02:30.310 --> 00:02:33.170
that you have to consider,
you might be asking yourself,

00:02:33.170 --> 00:02:34.760
so where do I start?

00:02:34.760 --> 00:02:37.120
What are all of the things
that I should be considering

00:02:37.120 --> 00:02:40.730
as I design and develop my app?

00:02:40.730 --> 00:02:43.480
So our objective for today
is to provide guidance

00:02:43.480 --> 00:02:45.410
on the following questions.

00:02:45.410 --> 00:02:48.940
Number one, how do I simplify
the onboarding process

00:02:48.940 --> 00:02:51.620
for my users?

00:02:51.620 --> 00:02:54.410
Number two, once my
users are signed in,

00:02:54.410 --> 00:02:58.070
how do I facilitate
payment transactions?

00:02:58.070 --> 00:03:02.460
And number three, how do
I prevent account abuse?

00:03:02.460 --> 00:03:04.560
And as we walk through
these questions today,

00:03:04.560 --> 00:03:07.320
we want to make sure that we
keep the end customer user

00:03:07.320 --> 00:03:10.410
journey in mind, because
as I'm sure we all agree,

00:03:10.410 --> 00:03:12.090
that's what's most important.

00:03:12.090 --> 00:03:15.750
And we want to make sure that
we do our best to put you guys

00:03:15.750 --> 00:03:18.580
in a position to be successful.

00:03:18.580 --> 00:03:20.360
So now I'm going to
hand it off to Carlos,

00:03:20.360 --> 00:03:22.402
who's going to talk about
the onboarding process.

00:03:25.125 --> 00:03:26.500
CARLOS VALDIVIA:
Thanks, Hideaki.

00:03:26.500 --> 00:03:30.310
My name is Carlos, and I lead
the account authentication,

00:03:30.310 --> 00:03:33.280
management, and security
efforts within Android.

00:03:33.280 --> 00:03:35.230
And I'm here today to
talk to you about both

00:03:35.230 --> 00:03:38.290
getting your users into your
app and having them authenticate

00:03:38.290 --> 00:03:41.327
well as well as to sort
of keep them in your app.

00:03:41.327 --> 00:03:42.910
Specifically, I'm
going to talk to you

00:03:42.910 --> 00:03:45.760
about Google Sign-In, Google
Smart Lock for passwords,

00:03:45.760 --> 00:03:47.710
as well as Autofill with Google.

00:03:47.710 --> 00:03:49.720
I should note that
I'm not going to work

00:03:49.720 --> 00:03:51.710
through any sort of
code examples here,

00:03:51.710 --> 00:03:53.350
but at the end of
the presentation,

00:03:53.350 --> 00:03:54.790
we'll have a slide
with a bunch of links

00:03:54.790 --> 00:03:56.800
that are sort of links
to the relevant developer

00:03:56.800 --> 00:03:58.970
documentation.

00:03:58.970 --> 00:04:02.450
Google Sign-In provides the
simplest onboarding as well as

00:04:02.450 --> 00:04:04.920
reboarding experience
for your users.

00:04:04.920 --> 00:04:07.820
It is one tap to get
your users on board.

00:04:07.820 --> 00:04:12.020
And subsequent sign-ins from
the user either on the web,

00:04:12.020 --> 00:04:14.705
or on Android, or
on iOS devices,

00:04:14.705 --> 00:04:16.850
it's completely automatic.

00:04:16.850 --> 00:04:19.670
And it also provides the best
security story for your users.

00:04:19.670 --> 00:04:22.310
As Google sort of provides
more services to users

00:04:22.310 --> 00:04:24.860
to be able to prevent
phishing, et cetera,

00:04:24.860 --> 00:04:29.360
you'll benefit from that if
your users are Google-signed-in.

00:04:29.360 --> 00:04:33.590
The Doodle app, which does
meetings and sort of meeting

00:04:33.590 --> 00:04:36.560
organization, it saw
substantial improvement

00:04:36.560 --> 00:04:38.690
when they went over
to the Google Sign-In

00:04:38.690 --> 00:04:41.310
for their initial registrations.

00:04:41.310 --> 00:04:43.950
If you're unable to do
client-side and server-side

00:04:43.950 --> 00:04:47.100
integrations, then Google Smart
Lock may be your best bet.

00:04:47.100 --> 00:04:49.440
It's only a client-side
integration.

00:04:49.440 --> 00:04:51.960
And what it allows you
to do is programmatically

00:04:51.960 --> 00:04:54.120
integrate with a store of
usernames and passwords

00:04:54.120 --> 00:04:55.650
that are managed by Google.

00:04:55.650 --> 00:04:58.680
Those passwords are also used
for Chrome password management

00:04:58.680 --> 00:05:00.930
as well as for Autofill.

00:05:00.930 --> 00:05:02.760
And with this, you
can sort of have

00:05:02.760 --> 00:05:05.100
your users go through a
traditional sign-in flow,

00:05:05.100 --> 00:05:07.200
but when they
subsequently re-sign in,

00:05:07.200 --> 00:05:09.120
it can just be
completely automatic.

00:05:09.120 --> 00:05:10.980
You just programmatically
get the password,

00:05:10.980 --> 00:05:13.640
you don't need to show a
username or password prompt,

00:05:13.640 --> 00:05:15.840
and it's a fantastic
user experience.

00:05:15.840 --> 00:05:17.700
Netflix, as a
result of this, has

00:05:17.700 --> 00:05:21.868
seen a substantial reduction
in contacts with their users

00:05:21.868 --> 00:05:23.910
when they're asking for
help, because they forgot

00:05:23.910 --> 00:05:26.070
their usernames and passwords.

00:05:26.070 --> 00:05:28.920
Finally, if you're unable to
do any substantial integration

00:05:28.920 --> 00:05:31.470
on the client side,
Autofill with Google

00:05:31.470 --> 00:05:35.580
is our attempt to help your
users get into your apps.

00:05:35.580 --> 00:05:38.130
It's available on Oreo+ devices.

00:05:38.130 --> 00:05:41.490
About 45% of those
users are opted in.

00:05:41.490 --> 00:05:44.400
And we're filling millions
of passwords every day.

00:05:44.400 --> 00:05:47.370
And how it works,
again, is that your app

00:05:47.370 --> 00:05:50.160
is in front of the user, it's
showing a username and password

00:05:50.160 --> 00:05:52.980
field, we do our best
integrating with the framework

00:05:52.980 --> 00:05:55.050
to be able to detect
that field and make

00:05:55.050 --> 00:05:59.820
a suggestion to the user about
what the right sign-in is.

00:05:59.820 --> 00:06:01.820
In all of these cases,
there are things that you

00:06:01.820 --> 00:06:04.290
can do to help us help you.

00:06:04.290 --> 00:06:06.650
Specifically, if you're
going to use Google Sign-In

00:06:06.650 --> 00:06:08.880
or you're going to use
Smart Lock for passwords,

00:06:08.880 --> 00:06:12.140
you can register your app with
the Google Developer Console.

00:06:12.140 --> 00:06:15.530
This will help Google
tell us what your app is,

00:06:15.530 --> 00:06:18.140
and it helps with quota, and
it's just a necessary feature

00:06:18.140 --> 00:06:20.030
of using those APIs.

00:06:20.030 --> 00:06:24.620
In addition, I want to suggest
that you also set up Digital

00:06:24.620 --> 00:06:26.760
Asset Links with your apps.

00:06:26.760 --> 00:06:28.220
If you have a
presence on the web

00:06:28.220 --> 00:06:30.260
and a presence on
an Android app,

00:06:30.260 --> 00:06:33.590
it really helps us reuse
passwords between the two

00:06:33.590 --> 00:06:35.450
for both Smart
Lock for passwords

00:06:35.450 --> 00:06:37.490
and for Autofill with Google.

00:06:37.490 --> 00:06:40.280
And how you do that is you just
have your domain serve an Asset

00:06:40.280 --> 00:06:43.550
Link file, and then you make
a declaration in your Android

00:06:43.550 --> 00:06:44.310
manifest.

00:06:44.310 --> 00:06:48.330
Again, there will be a link at
the end of the presentation.

00:06:48.330 --> 00:06:51.180
So to summarize,
Google Sign-In--

00:06:51.180 --> 00:06:53.340
one tap to get your users on.

00:06:53.340 --> 00:06:55.290
And then it's just
automatic afterwards.

00:06:55.290 --> 00:06:58.240
Well, programmatic for you,
but automatic for your users.

00:06:58.240 --> 00:07:00.690
And it works on all
Android operating systems.

00:07:00.690 --> 00:07:01.650
It works on iOS.

00:07:01.650 --> 00:07:03.150
It works on the web.

00:07:03.150 --> 00:07:05.100
Smart Lock for passwords?

00:07:05.100 --> 00:07:07.300
There will be a manual
onboarding process,

00:07:07.300 --> 00:07:09.990
but once you programmatically
integrate with it,

00:07:09.990 --> 00:07:13.290
it means that subsequent
sign-ins by your users

00:07:13.290 --> 00:07:15.330
will work on all
Android devices.

00:07:15.330 --> 00:07:17.600
And it's, again, auto-magical.

00:07:17.600 --> 00:07:20.310
Finally, Autofill
with Google will

00:07:20.310 --> 00:07:23.580
allow you to have your
users get back into your app

00:07:23.580 --> 00:07:27.425
with suggested usernames
and passwords from Google.

00:07:27.425 --> 00:07:28.800
And that will make
it much easier

00:07:28.800 --> 00:07:30.930
to get your users back
on board with identities

00:07:30.930 --> 00:07:32.770
that you are already aware of.

00:07:32.770 --> 00:07:36.880
And it's available on
Oreo+ Android phones.

00:07:36.880 --> 00:07:39.370
Finally, if you're going
to be using phone number

00:07:39.370 --> 00:07:40.420
verification--

00:07:40.420 --> 00:07:42.490
for example, it's
very common for apps

00:07:42.490 --> 00:07:49.587
to use OTPs to verify
their user's identity--

00:07:49.587 --> 00:07:51.670
there will be policy changes
coming in the future.

00:07:51.670 --> 00:07:54.820
Traditionally, apps have
taken the SMS permission

00:07:54.820 --> 00:07:56.118
or the call logs permission.

00:07:56.118 --> 00:07:58.660
But the Play Store is changing
their policies regarding this,

00:07:58.660 --> 00:08:01.250
and those apps that take
those permissions are going

00:08:01.250 --> 00:08:02.782
to get a lot more scrutiny.

00:08:02.782 --> 00:08:04.990
So we suggest that you take
a look at the Google Play

00:08:04.990 --> 00:08:07.335
Services' SMS Retriever API.

00:08:07.335 --> 00:08:09.760
It allows you to
programmatically integrate

00:08:09.760 --> 00:08:11.562
with the Google Play Services.

00:08:11.562 --> 00:08:13.270
And what will happen
is that you'll still

00:08:13.270 --> 00:08:15.680
send an SMS message
to the phone,

00:08:15.680 --> 00:08:18.340
but Google Play Services
will mediate that message,

00:08:18.340 --> 00:08:20.848
and you will only get your OTP.

00:08:20.848 --> 00:08:22.390
The benefit of this
is that you don't

00:08:22.390 --> 00:08:24.850
need to ask your users
for scary permissions

00:08:24.850 --> 00:08:27.550
to still be able to verify
their phone numbers.

00:08:27.550 --> 00:08:30.220
And Flipkart,
using this API, has

00:08:30.220 --> 00:08:34.450
found a substantial
increase in sign-up.

00:08:34.450 --> 00:08:37.559
To reiterate, don't ask
for tons of permissions,

00:08:37.559 --> 00:08:39.309
especially if they're
not directly related

00:08:39.309 --> 00:08:40.929
to your business case.

00:08:40.929 --> 00:08:44.740
We live in a climate where users
are very privacy-sensitive.

00:08:44.740 --> 00:08:46.780
And asking for lots of
extraneous permissions

00:08:46.780 --> 00:08:48.910
that aren't clearly
and obviously related

00:08:48.910 --> 00:08:53.890
to your business case is
a recipe for problems.

00:08:53.890 --> 00:08:56.710
So part of the
onboarding flow is also

00:08:56.710 --> 00:09:00.850
keeping your users onboard when
they eventually switch devices.

00:09:00.850 --> 00:09:02.830
And a lot of what I've
talked about already

00:09:02.830 --> 00:09:06.250
is relevant to that case, where
a user leaves their old device,

00:09:06.250 --> 00:09:08.530
they move to a new device.

00:09:08.530 --> 00:09:10.570
Google Sign-In, Smart
Lock for passwords,

00:09:10.570 --> 00:09:13.180
they will just smoothly
have your users transfer

00:09:13.180 --> 00:09:15.430
their identity from
one phone to the other

00:09:15.430 --> 00:09:18.160
because it'll just be portable.

00:09:18.160 --> 00:09:21.460
When you do have an
app, we do suggest

00:09:21.460 --> 00:09:24.100
that you test to make sure
that Autofill with Google

00:09:24.100 --> 00:09:28.120
is correctly identifying your
usernames and your passwords.

00:09:28.120 --> 00:09:29.950
Help us help you.

00:09:29.950 --> 00:09:32.650
In addition, add
recovery options

00:09:32.650 --> 00:09:35.030
for your usernames
and passwords.

00:09:35.030 --> 00:09:36.640
It's very common,
in an Android app,

00:09:36.640 --> 00:09:39.370
as Hideaki mentioned,
for a user to only enter

00:09:39.370 --> 00:09:42.370
their username once and only
enter their password once

00:09:42.370 --> 00:09:44.200
and then, two or
three years later,

00:09:44.200 --> 00:09:49.310
have no idea what that password
is when they get a new device.

00:09:49.310 --> 00:09:51.220
So, if you add recovery
options, you're

00:09:51.220 --> 00:09:54.080
going to increase the chances
of keeping your users.

00:09:54.080 --> 00:09:56.200
Finally, Google does
provide a backup

00:09:56.200 --> 00:09:58.750
and restore service
to our users.

00:09:58.750 --> 00:10:02.470
And the benefit of that is that
it also backs up and restores

00:10:02.470 --> 00:10:04.510
app data, including your data.

00:10:04.510 --> 00:10:07.720
So test to make sure that
that's working properly for you

00:10:07.720 --> 00:10:10.130
and that you can get the
most value out of that.

00:10:10.130 --> 00:10:12.760
And it should make that
transition from one device

00:10:12.760 --> 00:10:15.310
to another as smooth as
possible for the user

00:10:15.310 --> 00:10:18.700
and ensure that you get the
most value from your user

00:10:18.700 --> 00:10:20.920
re-engagement on a new phone.

00:10:20.920 --> 00:10:25.510
Next, Jay is going to talk about
how to facilitate payments.

00:10:25.510 --> 00:10:27.220
JAY CIVELLI: Thank you, Carlos.

00:10:27.220 --> 00:10:27.760
Hi.

00:10:27.760 --> 00:10:30.610
My name is Jay Civelli,
and I'm a software engineer

00:10:30.610 --> 00:10:32.500
on the Autofill
with Google team.

00:10:32.500 --> 00:10:34.240
So Carlos talked
about how we can

00:10:34.240 --> 00:10:36.050
improve the log-in experience.

00:10:36.050 --> 00:10:38.800
I'd like to talk about how we
can make the payment experience

00:10:38.800 --> 00:10:40.780
better for our users.

00:10:40.780 --> 00:10:43.180
Making a payment
on a mobile device

00:10:43.180 --> 00:10:45.580
can be quite a tedious task.

00:10:45.580 --> 00:10:47.520
You have to get your
physical credit card,

00:10:47.520 --> 00:10:49.600
enter a bunch of numbers
on a soft keyboard.

00:10:49.600 --> 00:10:52.000
It's error-prone, it's tedious,
and, if you're like me,

00:10:52.000 --> 00:10:53.800
chances are you've
been in a situation

00:10:53.800 --> 00:10:57.100
where you've given up on making
a transaction just because

00:10:57.100 --> 00:11:01.250
of that, the pain, because that
process was just too painful.

00:11:01.250 --> 00:11:03.450
So what can we do?

00:11:03.450 --> 00:11:06.210
The best thing you can do
to make transaction payments

00:11:06.210 --> 00:11:08.930
easier into your application is
integrate with the Google Pay

00:11:08.930 --> 00:11:09.600
APIs.

00:11:09.600 --> 00:11:12.870
They provide a seamless
checkout experience for users,

00:11:12.870 --> 00:11:17.910
and there is a best way to
get your users checked out.

00:11:17.910 --> 00:11:19.760
So how does that work?

00:11:19.760 --> 00:11:22.640
You basically provide--
integrate with Google Pay APIs.

00:11:22.640 --> 00:11:25.310
You have a Google Pay
button in your app.

00:11:25.310 --> 00:11:26.870
When the user
presses that button,

00:11:26.870 --> 00:11:28.430
they're presented
with the credit

00:11:28.430 --> 00:11:30.890
card, debit cards available
on their Google account.

00:11:30.890 --> 00:11:32.960
And they can easily
check out by selecting

00:11:32.960 --> 00:11:36.200
one of those accounts.

00:11:36.200 --> 00:11:39.860
Actually, we've seen,
for instance, [INAUDIBLE]

00:11:39.860 --> 00:11:42.590
conversion rate increase by
65% when they transitioned

00:11:42.590 --> 00:11:44.400
to those Google Pay APIs.

00:11:44.400 --> 00:11:46.863
So that's really
what we recommend.

00:11:46.863 --> 00:11:48.530
Something to keep in
mind-- that there's

00:11:48.530 --> 00:11:51.530
kind of an investment to getting
integrated with these APIs.

00:11:51.530 --> 00:11:54.360
You have to integrate with
the entire flow of the API

00:11:54.360 --> 00:11:56.760
and with your payment
service providers.

00:11:56.760 --> 00:11:59.960
So if you're not yet
ready to do that work,

00:11:59.960 --> 00:12:01.670
something else you
can do is make sure

00:12:01.670 --> 00:12:04.190
that Autofill works great
with your app, something

00:12:04.190 --> 00:12:05.660
that Carlos mentioned already.

00:12:05.660 --> 00:12:09.180
So Autofill is not just
about username and passwords.

00:12:09.180 --> 00:12:11.180
It can actually help with
many of the scenarios

00:12:11.180 --> 00:12:15.990
like credit cards, names, first
name, last name, phone numbers,

00:12:15.990 --> 00:12:17.577
email addresses,
physical addresses.

00:12:17.577 --> 00:12:19.910
So anything that's tedious
to enter into an application,

00:12:19.910 --> 00:12:22.750
Autofill can help.

00:12:22.750 --> 00:12:27.000
So here we can see how
it works with payments.

00:12:27.000 --> 00:12:30.520
We are in an app, and the
user tapped on the Credit Card

00:12:30.520 --> 00:12:31.330
field.

00:12:31.330 --> 00:12:33.100
And what Autofill
provides-- it shows

00:12:33.100 --> 00:12:36.040
you that dropdown with
a credit card that's

00:12:36.040 --> 00:12:38.462
available in the Google
account of the user.

00:12:38.462 --> 00:12:40.490
The user can select
that dropdown

00:12:40.490 --> 00:12:44.260
to autofill that credit
card into their form.

00:12:44.260 --> 00:12:45.850
So that's actually used.

00:12:45.850 --> 00:12:50.220
We see millions of payments
forms filled with Autofill

00:12:50.220 --> 00:12:50.720
every week.

00:12:50.720 --> 00:12:55.150
So that's definitely something
that brings value to the user.

00:12:55.150 --> 00:12:57.850
Something you might be
wondering is, how does Autofill

00:12:57.850 --> 00:13:00.070
know, when I tap on
a Credit Card field,

00:13:00.070 --> 00:13:02.450
that this is actually
a Credit Card field?

00:13:02.450 --> 00:13:05.950
And so the way it works is
that Autofill Services will

00:13:05.950 --> 00:13:08.950
use a bunch of heuristics
or other techniques,

00:13:08.950 --> 00:13:11.200
and they will extract
data from the views

00:13:11.200 --> 00:13:13.430
to figure out what
that field is.

00:13:13.430 --> 00:13:17.220
But, if you want to make
sure Autofill gets it

00:13:17.220 --> 00:13:19.720
right 100% of the time,
there's something fairly easy

00:13:19.720 --> 00:13:20.600
you can do.

00:13:20.600 --> 00:13:22.940
And this is using
Autofill Hints.

00:13:22.940 --> 00:13:27.010
So here we have a code
snippet of a layout XML file.

00:13:27.010 --> 00:13:29.740
And you can see there's
a TextView in there.

00:13:29.740 --> 00:13:33.790
And what we've done is that
we've tagged that TextView

00:13:33.790 --> 00:13:35.515
with the AUTOFILL
HINT, and we've

00:13:35.515 --> 00:13:37.390
tagged it with the
creditCardNumber, AUTOFILL

00:13:37.390 --> 00:13:38.420
HINT.

00:13:38.420 --> 00:13:39.440
What does that do?

00:13:39.440 --> 00:13:41.710
It basically tells the
Autofill service provider

00:13:41.710 --> 00:13:43.667
that this field
is a credit card.

00:13:43.667 --> 00:13:46.000
So there's no guessing involved
by the Autofill service,

00:13:46.000 --> 00:13:48.102
and it will show the
right suggestion.

00:13:48.102 --> 00:13:50.560
So you might also be wondering,
where does that credit card

00:13:50.560 --> 00:13:52.090
number come from?

00:13:52.090 --> 00:13:55.810
It's actually a constant found
in the Android View class.

00:13:55.810 --> 00:13:57.650
If you go and take
a look in there,

00:13:57.650 --> 00:14:00.500
you'll see that there's
a bunch of those hints.

00:14:00.500 --> 00:14:02.950
They use the
AUTOFILL HINT prefix.

00:14:02.950 --> 00:14:05.740
So those Autofill
hints have been

00:14:05.740 --> 00:14:10.720
added in Android O when
the Autofill capability was

00:14:10.720 --> 00:14:11.920
introduced in Android.

00:14:11.920 --> 00:14:13.870
But we found out that
they're not always

00:14:13.870 --> 00:14:16.130
as granular as user may want.

00:14:16.130 --> 00:14:17.590
For instance, if
you look at Name,

00:14:17.590 --> 00:14:19.390
there's only one hint for names.

00:14:19.390 --> 00:14:22.330
There's no distinction between
first name and last name.

00:14:22.330 --> 00:14:26.370
For that reason,
we're introducing soon

00:14:26.370 --> 00:14:27.860
Extended Autofill Hints.

00:14:27.860 --> 00:14:30.380
So those new hints will be
included in the Compatibility

00:14:30.380 --> 00:14:32.480
library, and it will
give you more control

00:14:32.480 --> 00:14:34.580
over all different kind
of things you may want

00:14:34.580 --> 00:14:36.540
to have in your application.

00:14:36.540 --> 00:14:37.940
So I was talking about names.

00:14:37.940 --> 00:14:40.760
You see we have now
a greater breakdown

00:14:40.760 --> 00:14:43.910
of all the different names you
could have in your app as well

00:14:43.910 --> 00:14:47.100
as addresses and other types.

00:14:47.100 --> 00:14:50.870
So we saw how you can
actually help Autofill suggest

00:14:50.870 --> 00:14:52.130
the right thing in your app.

00:14:52.130 --> 00:14:54.500
However, there are cases
where you actually don't want

00:14:54.500 --> 00:14:57.350
Autofill to suggest anything.

00:14:57.350 --> 00:14:59.990
Imagine you have an app
where you have an activity

00:14:59.990 --> 00:15:02.870
to add friends with
their phone numbers.

00:15:02.870 --> 00:15:04.670
So that activity would
have only one field,

00:15:04.670 --> 00:15:05.840
which is Phone Number.

00:15:05.840 --> 00:15:09.800
When the user taps
that field, Autofill

00:15:09.800 --> 00:15:11.970
might detect it as a phone
number, but in that case,

00:15:11.970 --> 00:15:13.760
we obviously don't want
to suggest a phone number

00:15:13.760 --> 00:15:15.260
as a user's phone
number, because it

00:15:15.260 --> 00:15:16.920
is forwarding somebody else.

00:15:16.920 --> 00:15:19.430
So in those cases where
you don't want Autofill

00:15:19.430 --> 00:15:24.500
to do any suggestion, you can
actually turn off Autofill

00:15:24.500 --> 00:15:28.700
by tagging the field with the
Imported for Autofill property.

00:15:28.700 --> 00:15:31.250
So you see in that snippet
here there is a text view.

00:15:31.250 --> 00:15:33.920
And it's being tagged with
Imported for Autofill, No.

00:15:33.920 --> 00:15:34.930
What does that do?

00:15:34.930 --> 00:15:36.650
That instructs the
Autofill service,

00:15:36.650 --> 00:15:39.420
please ignore that
view entirely.

00:15:39.420 --> 00:15:42.852
And so you can use that to
disable one field or more.

00:15:42.852 --> 00:15:44.810
And actually, if you have
more than one field--

00:15:44.810 --> 00:15:46.640
let's say, in our
previous example,

00:15:46.640 --> 00:15:49.650
in that Add Friend
activity, if you

00:15:49.650 --> 00:15:51.900
had multiple fields with
first name, last name, email,

00:15:51.900 --> 00:15:53.510
and you want to
disable all of them,

00:15:53.510 --> 00:15:56.150
you can actually set that
Imported for Autofill property

00:15:56.150 --> 00:15:59.840
on a parent node and you set
it with no exclude descendants.

00:15:59.840 --> 00:16:02.780
And what that does is that it
excludes all the nodes located

00:16:02.780 --> 00:16:05.590
under that specific node.

00:16:05.590 --> 00:16:07.960
So, to recap, what
we suggest you

00:16:07.960 --> 00:16:10.250
do if you want Autofill
to work great in your app

00:16:10.250 --> 00:16:12.670
is to go through your
layout XML files.

00:16:12.670 --> 00:16:14.440
And, every time you
have an input field,

00:16:14.440 --> 00:16:16.732
make sure it's either disabled
if it doesn't make sense

00:16:16.732 --> 00:16:18.960
to have it enabled or it
specifies the right types,

00:16:18.960 --> 00:16:22.390
Autofill works all the time.

00:16:22.390 --> 00:16:25.080
So that's one aspect of
the payment experience.

00:16:25.080 --> 00:16:29.970
We want to be able to suggest
and to make it easy for users

00:16:29.970 --> 00:16:32.340
to enter their credit
card information.

00:16:32.340 --> 00:16:34.380
There's another
thing that comes up.

00:16:34.380 --> 00:16:36.277
It's related to OTPs.

00:16:36.277 --> 00:16:38.110
And so, in markets like
India, for instance,

00:16:38.110 --> 00:16:40.930
every time you make a
purchase online or in an app,

00:16:40.930 --> 00:16:42.450
you have to provide
an OTP provided

00:16:42.450 --> 00:16:44.950
by your financial institution.

00:16:44.950 --> 00:16:47.890
So, as Carlos talked about,
we could use the SMS Retriever

00:16:47.890 --> 00:16:48.390
app.

00:16:48.390 --> 00:16:49.807
We can use two
[INAUDIBLE] the SMS

00:16:49.807 --> 00:16:52.050
Retriever app to retrieve OTPs.

00:16:52.050 --> 00:16:54.547
But this is restricted to
OTPs you send yourself.

00:16:54.547 --> 00:16:56.130
In those kind of
scenarios, those OTPs

00:16:56.130 --> 00:16:57.810
are sent by a
third party, so you

00:16:57.810 --> 00:17:00.030
don't have control over
who's sending that.

00:17:00.030 --> 00:17:03.390
In the past, you would
probably have used the SMS read

00:17:03.390 --> 00:17:06.720
permission to actually read
the SMS as they come in

00:17:06.720 --> 00:17:08.589
and try to find
that OTP yourself.

00:17:08.589 --> 00:17:12.810
But as Carlos, the Play
Store policy is changing

00:17:12.810 --> 00:17:18.480
and we now are trying
to help developers not

00:17:18.480 --> 00:17:23.010
get access to all the SMS from
the user for privacy reasons.

00:17:23.010 --> 00:17:25.170
So we're introducing
another API, which

00:17:25.170 --> 00:17:27.490
is the SMS User Consent API.

00:17:27.490 --> 00:17:29.490
What that API does is
that it will let you still

00:17:29.490 --> 00:17:32.490
access third-party
OTPs, but we will

00:17:32.490 --> 00:17:35.410
prompt the user to
make sure they agree

00:17:35.410 --> 00:17:37.470
of providing you that OTP.

00:17:37.470 --> 00:17:39.490
So let's take a look
at how it works.

00:17:39.490 --> 00:17:43.230
Here we have Zomato, which
is one of our partner apps.

00:17:43.230 --> 00:17:44.592
And they are using the API.

00:17:44.592 --> 00:17:45.550
Let's see what they do.

00:17:45.550 --> 00:17:48.280
So first of all,
you start the app.

00:17:48.280 --> 00:17:50.010
At this point, it
requires an OTP.

00:17:50.010 --> 00:17:52.750
It's going to call the SMS
Retriever, Start SMS Retriever

00:17:52.750 --> 00:17:54.240
Consent API.

00:17:54.240 --> 00:17:56.730
What that does is that
it instructs the SMS User

00:17:56.730 --> 00:17:58.530
Consent to start
paying attention

00:17:58.530 --> 00:18:02.550
for SMS messages coming in
with potential OTPs in them.

00:18:05.940 --> 00:18:08.280
Once an SMS message
with an OTP comes in,

00:18:08.280 --> 00:18:11.870
the Consent API will
actually send a broadcast

00:18:11.870 --> 00:18:13.800
to your application,
and that broadcast

00:18:13.800 --> 00:18:17.610
will contain consent intent
that it can extract out

00:18:17.610 --> 00:18:19.410
of the broadcast.

00:18:19.410 --> 00:18:22.350
And you will have to
start that consent intent

00:18:22.350 --> 00:18:24.580
with startActivityForResult.

00:18:24.580 --> 00:18:25.560
What does it do?

00:18:25.560 --> 00:18:28.710
It will show that dialogue
you're seeing there

00:18:28.710 --> 00:18:31.780
at the bottom of the screen,
and this will show two things

00:18:31.780 --> 00:18:32.640
to the user.

00:18:32.640 --> 00:18:35.700
First of them, it will tell them
which app is requiring access

00:18:35.700 --> 00:18:36.870
to the SMS.

00:18:36.870 --> 00:18:40.500
And, second, it will actually
list the content of the SMS.

00:18:40.500 --> 00:18:42.900
The user will then be
able to see clearly

00:18:42.900 --> 00:18:44.580
what it's given to the app.

00:18:44.580 --> 00:18:48.970
Once it click Allow,
then in your app,

00:18:48.970 --> 00:18:50.860
you will, on the
Activity Result,

00:18:50.860 --> 00:18:53.590
get the actual SMS
message as part

00:18:53.590 --> 00:18:57.580
of the data intent provided
on the activity result.

00:18:57.580 --> 00:19:00.460
So you can then extract the
SMS message, parse the OTP,

00:19:00.460 --> 00:19:03.620
and use it in your application.

00:19:03.620 --> 00:19:09.820
So, to recap, when it comes
to automated SMS verification,

00:19:09.820 --> 00:19:11.210
you have two options.

00:19:11.210 --> 00:19:13.630
The first option is
using SMS Retriever API.

00:19:13.630 --> 00:19:17.780
That means you have
access to the back end.

00:19:17.780 --> 00:19:19.600
You're sending data actual SMS.

00:19:19.600 --> 00:19:22.150
This is a preferred API
to use in that case,

00:19:22.150 --> 00:19:24.220
because no user
consent is required.

00:19:24.220 --> 00:19:25.660
The experience is
pretty seamless.

00:19:25.660 --> 00:19:28.870
No interaction from the user.

00:19:28.870 --> 00:19:32.095
If you don't have
access to the back end,

00:19:32.095 --> 00:19:33.970
if it's a third-party
OTP, then you

00:19:33.970 --> 00:19:35.877
want to use the SMS Consent API.

00:19:35.877 --> 00:19:38.210
So in that case, you can use
it in any kind of scenario,

00:19:38.210 --> 00:19:41.320
but user will have
to give permission

00:19:41.320 --> 00:19:44.380
for every message you receive
that your app needs to consume.

00:19:44.380 --> 00:19:47.740
And there will be one tap
involved in that case.

00:19:47.740 --> 00:19:49.643
And with that, I'm
going to hand it over

00:19:49.643 --> 00:19:51.310
to Steven, who's going
to talk about how

00:19:51.310 --> 00:19:54.450
to prevent account abuse.

00:19:54.450 --> 00:19:55.200
STEVEN SONEFF: OK.

00:19:55.200 --> 00:19:56.790
Thanks very much, Jay.

00:19:56.790 --> 00:19:58.070
So my name is Steven.

00:19:58.070 --> 00:19:59.720
I'm a product manager
here at Google

00:19:59.720 --> 00:20:02.240
working on authentication
and security.

00:20:02.240 --> 00:20:03.890
So in this last
section, we're going

00:20:03.890 --> 00:20:07.100
to talk about another problem
that comes up for developers.

00:20:07.100 --> 00:20:10.070
Eventually, after improving
your onboarding flows

00:20:10.070 --> 00:20:12.360
and helping users do
things in your apps,

00:20:12.360 --> 00:20:15.230
you'll inevitably run
into the problem of abuse.

00:20:15.230 --> 00:20:17.520
So we're going to cover a
couple different categories.

00:20:17.520 --> 00:20:21.823
The first is about the creation
of illegitimate accounts.

00:20:21.823 --> 00:20:23.240
So you might have
encountered this

00:20:23.240 --> 00:20:24.470
before as you build an app.

00:20:24.470 --> 00:20:27.770
You'll have people,
often through automation,

00:20:27.770 --> 00:20:30.333
trying to create
accounts at scale.

00:20:30.333 --> 00:20:32.000
And there's a variety
of different tools

00:20:32.000 --> 00:20:35.480
that you are able to use to
help mitigate this problem.

00:20:35.480 --> 00:20:37.490
So one of the first
ones that we recommend

00:20:37.490 --> 00:20:40.685
is using a trusted identity
provider for your users.

00:20:40.685 --> 00:20:42.560
So encouraging people
to go through something

00:20:42.560 --> 00:20:44.540
like a Sign-In with Google flow.

00:20:44.540 --> 00:20:46.520
And the opportunity,
the advantage

00:20:46.520 --> 00:20:49.430
here is that these identity
providers, like Google,

00:20:49.430 --> 00:20:51.570
have done a lot of
checks on their users.

00:20:51.570 --> 00:20:53.270
So in the case of
Google accounts,

00:20:53.270 --> 00:20:56.060
when someone creates
a new Google account,

00:20:56.060 --> 00:20:59.023
we look for all forms of
automation, try to detect that

00:20:59.023 --> 00:21:00.440
and stop these
accounts from being

00:21:00.440 --> 00:21:02.250
created in the first place.

00:21:02.250 --> 00:21:04.430
So what you can do as an
application developer is

00:21:04.430 --> 00:21:07.280
when you see someone come in
with a Google Sign-In account,

00:21:07.280 --> 00:21:10.850
you will know that this
person has been through checks

00:21:10.850 --> 00:21:11.575
from Google.

00:21:11.575 --> 00:21:12.950
And you're getting
those for free

00:21:12.950 --> 00:21:15.950
by just having a
user use these flows.

00:21:15.950 --> 00:21:17.720
Beyond that, of course,
people may sign up

00:21:17.720 --> 00:21:19.220
with other mechanisms.

00:21:19.220 --> 00:21:22.850
And things like verifying
users' phone numbers

00:21:22.850 --> 00:21:25.190
or forms of payments can
be additional signals

00:21:25.190 --> 00:21:27.200
that you look at to
try to mitigate abuse

00:21:27.200 --> 00:21:29.582
from these types of
account creation.

00:21:29.582 --> 00:21:31.040
Now, the thing to
keep in mind here

00:21:31.040 --> 00:21:33.650
is that adding checks on
people's phone numbers

00:21:33.650 --> 00:21:36.230
or forms of payment
introduce additional friction

00:21:36.230 --> 00:21:39.030
into the onboarding flows you're
trying to build for users,

00:21:39.030 --> 00:21:40.970
so you have to use
them really carefully.

00:21:40.970 --> 00:21:43.460
And there's the tools, like
Carlos mentioned earlier,

00:21:43.460 --> 00:21:46.370
the SMS Retriever that can
help you verify something

00:21:46.370 --> 00:21:49.070
like a phone number more
easily by automatically

00:21:49.070 --> 00:21:54.102
reading the contents of an SMS
that contains a one-time code.

00:21:54.102 --> 00:21:56.060
So keep that in mind when
you're building flows

00:21:56.060 --> 00:21:59.250
where you have to verify
additional user information.

00:21:59.250 --> 00:22:01.790
And, finally, there
are APIs on Android

00:22:01.790 --> 00:22:05.210
that help you detect and
prevent the usage of your app

00:22:05.210 --> 00:22:08.030
through automated mechanisms
like scripts and bots.

00:22:08.030 --> 00:22:10.990
And let's go into a little
bit of detail about those two.

00:22:10.990 --> 00:22:13.570
So the first one here
is the Safety Net API.

00:22:13.570 --> 00:22:16.270
And so the Safety Net
API will help give you

00:22:16.270 --> 00:22:19.780
an assertion, or an attestation,
that the user of your app

00:22:19.780 --> 00:22:23.830
is on a legitimate, real device.

00:22:23.830 --> 00:22:27.490
How this works is in
calling a Play Services API,

00:22:27.490 --> 00:22:30.820
you can ask the device to
collect a bunch of information,

00:22:30.820 --> 00:22:34.090
send that to Google, and have
Google analyze and determine

00:22:34.090 --> 00:22:36.430
the integrity of this
device, whether it's real,

00:22:36.430 --> 00:22:39.670
that the OS is intact, and so
on, and return this assertion

00:22:39.670 --> 00:22:41.422
back to your app.

00:22:41.422 --> 00:22:42.880
Once you have this
information, you

00:22:42.880 --> 00:22:45.100
can send it to your own
server and then use it

00:22:45.100 --> 00:22:47.350
as a signal in
your own onboarding

00:22:47.350 --> 00:22:50.230
flows you have
positive reinforcement

00:22:50.230 --> 00:22:52.640
that this is, in fact,
a legitimate device.

00:22:52.640 --> 00:22:54.250
So if you think about
it, when someone

00:22:54.250 --> 00:22:56.920
is trying to create
accounts at scale,

00:22:56.920 --> 00:22:58.630
it becomes really
expensive when they

00:22:58.630 --> 00:23:02.780
have to have real devices in
order to create those accounts.

00:23:02.780 --> 00:23:05.710
But sometimes having a
real device isn't enough.

00:23:05.710 --> 00:23:07.300
And there's another
option here, which

00:23:07.300 --> 00:23:10.445
is to put a ReCAPTCHA
flow into your apps.

00:23:10.445 --> 00:23:12.820
Now, again, this is one that
you want to use judiciously,

00:23:12.820 --> 00:23:15.400
because people will
potentially run

00:23:15.400 --> 00:23:18.157
into this when they
are legitimate users

00:23:18.157 --> 00:23:19.990
and this is going to
add additional friction

00:23:19.990 --> 00:23:21.148
for those users.

00:23:21.148 --> 00:23:22.690
So keep in mind that
this should only

00:23:22.690 --> 00:23:24.760
be used when you
really need it, when

00:23:24.760 --> 00:23:28.270
you have an indication that
this is a risky transaction

00:23:28.270 --> 00:23:30.030
or that there is some
form of abuse that

00:23:30.030 --> 00:23:32.980
has happened in the past.

00:23:32.980 --> 00:23:33.520
OK.

00:23:33.520 --> 00:23:35.230
With that, you have
hopefully created

00:23:35.230 --> 00:23:36.645
an account that's legitimate.

00:23:36.645 --> 00:23:38.770
And the next problem that
you'll have to go through

00:23:38.770 --> 00:23:42.100
is keeping that account safe,
so preventing bad actors

00:23:42.100 --> 00:23:45.790
from accessing this account,
and stealing user data,

00:23:45.790 --> 00:23:48.100
performing transactions
that could be harmful

00:23:48.100 --> 00:23:50.073
to the users of your apps.

00:23:50.073 --> 00:23:52.240
So for this, you can use
several of the technologies

00:23:52.240 --> 00:23:53.500
that we've already mentioned.

00:23:53.500 --> 00:23:55.240
The first one that
we brought up earlier

00:23:55.240 --> 00:23:57.962
was using Google Sign-In and
a trusted identity provider.

00:23:57.962 --> 00:23:59.920
And this is a great
opportunity, because Google

00:23:59.920 --> 00:24:02.770
does so many checks when
people activate their Google

00:24:02.770 --> 00:24:04.660
accounts on an Android device.

00:24:04.660 --> 00:24:06.670
You've probably
encountered this yourself--

00:24:06.670 --> 00:24:08.830
that we do things like
send notifications

00:24:08.830 --> 00:24:12.370
on a new sign-in event, allow
users to go into their account

00:24:12.370 --> 00:24:15.070
settings and audit where
their account is active,

00:24:15.070 --> 00:24:17.110
and look at a multitude
of signals about where

00:24:17.110 --> 00:24:19.930
this event is happening, the
history of the device that you

00:24:19.930 --> 00:24:22.540
can leverage as a developer
by simply having someone

00:24:22.540 --> 00:24:25.810
go through a Google Sign-In
flow and have those signals when

00:24:25.810 --> 00:24:29.590
they're accessing an
account and your service.

00:24:29.590 --> 00:24:31.420
There's actually an
interesting new feature

00:24:31.420 --> 00:24:33.790
that came out recently
called Cross Account

00:24:33.790 --> 00:24:38.140
protection, where, if you've
had a user sign in with a Google

00:24:38.140 --> 00:24:40.180
account into your
service, you can

00:24:40.180 --> 00:24:43.090
subscribe for notifications
on security events related

00:24:43.090 --> 00:24:44.090
to that account.

00:24:44.090 --> 00:24:47.080
So for example, if this user's
account is hijacked at Google,

00:24:47.080 --> 00:24:49.960
you'll know about that and can
help them secure their account

00:24:49.960 --> 00:24:51.860
with your service.

00:24:51.860 --> 00:24:55.150
So a trusted identity provider
is one place to start with,

00:24:55.150 --> 00:24:56.650
but, of course,
there are people who

00:24:56.650 --> 00:24:59.705
are going to sign up without
using an identity provider.

00:24:59.705 --> 00:25:02.080
And for those users, you may
want to add additional steps

00:25:02.080 --> 00:25:04.170
in the verification flows.

00:25:04.170 --> 00:25:08.410
So that's things like sending
them a one-time code via SMS

00:25:08.410 --> 00:25:12.130
or some sort of
a time-based flow

00:25:12.130 --> 00:25:14.260
to get additional
signals that it's them

00:25:14.260 --> 00:25:17.290
and prevent and/or combat
the problem of password

00:25:17.290 --> 00:25:20.530
reuse or weak passwords.

00:25:20.530 --> 00:25:23.630
So there, again, this is adding
friction potentially for users,

00:25:23.630 --> 00:25:26.500
so you'll want to use the
APIs like SMS Retriever

00:25:26.500 --> 00:25:30.160
to try to mitigate and
ease these flows for users,

00:25:30.160 --> 00:25:34.520
so that they don't have to
enter this information manually.

00:25:34.520 --> 00:25:36.860
But keep in mind, if you
saw the talk that was just

00:25:36.860 --> 00:25:39.290
happening before this
on protecting users

00:25:39.290 --> 00:25:42.140
from deception, that there
is, in fact, another problem

00:25:42.140 --> 00:25:43.790
here, which is phishing.

00:25:43.790 --> 00:25:47.030
So even with the use of
one-time codes over SMS,

00:25:47.030 --> 00:25:50.390
we find that it's very common
that when a user encounters

00:25:50.390 --> 00:25:53.270
a malicious site that's asking
them for this information,

00:25:53.270 --> 00:25:55.790
they will happily enter that
into this malicious phishing

00:25:55.790 --> 00:25:58.230
website or app.

00:25:58.230 --> 00:26:01.610
So to combat that, we've been
working with the FIDO Alliance

00:26:01.610 --> 00:26:04.910
to introduce APIs on Android
that provide resistance

00:26:04.910 --> 00:26:06.380
to phishing.

00:26:06.380 --> 00:26:10.130
And so these are APIs that
allow you, as a developer,

00:26:10.130 --> 00:26:13.370
to talk to the authentication
hardware built in on Android,

00:26:13.370 --> 00:26:18.050
so things like biometric sensors
or external security keys,

00:26:18.050 --> 00:26:20.930
and use that information to help
mitigate against the phishing

00:26:20.930 --> 00:26:21.813
problem.

00:26:21.813 --> 00:26:23.480
Now, there's a couple
of different flows

00:26:23.480 --> 00:26:24.620
that this supports.

00:26:24.620 --> 00:26:27.920
So for example, imagine you
have a user coming to your app,

00:26:27.920 --> 00:26:29.990
logging in for the first
time, and then enrolling

00:26:29.990 --> 00:26:31.100
a fingerprint.

00:26:31.100 --> 00:26:32.840
You can really easily
check that it's

00:26:32.840 --> 00:26:35.510
that person when they come
back, using this flow known

00:26:35.510 --> 00:26:37.580
as Local User Verification.

00:26:37.580 --> 00:26:40.070
Furthermore, you can support
this cross-device usage

00:26:40.070 --> 00:26:42.410
where someone comes
back on another device

00:26:42.410 --> 00:26:45.470
and, having enrolled a
security key or some sort

00:26:45.470 --> 00:26:47.600
of external
authenticator previously,

00:26:47.600 --> 00:26:49.982
check that it's them
on this new one.

00:26:49.982 --> 00:26:51.440
So there's a couple
different flows

00:26:51.440 --> 00:26:52.860
that you can support here.

00:26:52.860 --> 00:26:55.470
And there's a few things that
you really should keep in mind.

00:26:55.470 --> 00:26:57.710
So the first is
about biometrics.

00:26:57.710 --> 00:27:00.630
The biometrics on Android
never leave the device.

00:27:00.630 --> 00:27:04.040
So what happens is, when someone
enrolls their fingerprint,

00:27:04.040 --> 00:27:07.220
they're just locally
setting up the information

00:27:07.220 --> 00:27:10.675
such that secure keys can
be released to the app

00:27:10.675 --> 00:27:12.800
or signature-produced from
them that you could then

00:27:12.800 --> 00:27:13.850
send to your server.

00:27:13.850 --> 00:27:17.170
The biometrics themselves don't
actually leave the device.

00:27:17.170 --> 00:27:19.400
And the second is that
this phishing resistance

00:27:19.400 --> 00:27:21.990
is provided by a couple
of different properties.

00:27:21.990 --> 00:27:24.500
One is that the
authenticator in question

00:27:24.500 --> 00:27:28.610
here is either built into the
device or physically nearby.

00:27:28.610 --> 00:27:31.790
And the fact then that this
credential, these keys that I

00:27:31.790 --> 00:27:34.910
mentioned, which are unlocked,
are only provided to your app

00:27:34.910 --> 00:27:37.700
signed with your
developer sign-in keys

00:27:37.700 --> 00:27:40.440
or to an associated website.

00:27:40.440 --> 00:27:43.050
And so one thing that you can
do today when you get home

00:27:43.050 --> 00:27:44.670
is check that the
association has

00:27:44.670 --> 00:27:47.490
been set up between your
app and your website.

00:27:47.490 --> 00:27:48.870
As Carlos mentioned
earlier, that

00:27:48.870 --> 00:27:52.680
enables password sharing between
a native app and a website.

00:27:52.680 --> 00:27:56.910
And it will also support this
phishing-resistant log-in flows

00:27:56.910 --> 00:27:59.020
with FIDO credentials.

00:27:59.020 --> 00:28:00.750
So that's the
tricks that you can

00:28:00.750 --> 00:28:03.283
employ in your app to get
people signed in more securely.

00:28:03.283 --> 00:28:04.950
And I'm going to hand
it back to Hideaki

00:28:04.950 --> 00:28:07.500
to wrap up and give you some
links for all the information

00:28:07.500 --> 00:28:09.730
we've shown today.

00:28:09.730 --> 00:28:11.004
HIDEAKI OSHIMA: Not yet.

00:28:11.004 --> 00:28:13.720
[APPLAUSE]

00:28:13.720 --> 00:28:14.220
All right.

00:28:14.220 --> 00:28:18.110
So, to wrap up, we want to
make sure we minimize friction

00:28:18.110 --> 00:28:21.240
for users at each step
of the customer journey.

00:28:21.240 --> 00:28:25.640
So step 1, we want to offer
seamless sign-up and sign-in

00:28:25.640 --> 00:28:29.480
by using Google Sign-In,
Smart Lock for passwords,

00:28:29.480 --> 00:28:31.940
or Autofill Hints
for credentials.

00:28:31.940 --> 00:28:34.730
We also want to automate
the OTP verification

00:28:34.730 --> 00:28:39.140
process by utilizing
the SMS Retriever API.

00:28:39.140 --> 00:28:42.770
Next, we want to simplify the
checkout process for our users

00:28:42.770 --> 00:28:46.160
by utilizing the Google
Pay API or Autofill

00:28:46.160 --> 00:28:49.140
Hints for payment information.

00:28:49.140 --> 00:28:52.070
We also want to streamline
the OTP verification process

00:28:52.070 --> 00:28:56.360
from financial institutions by
utilizing the SMS User Consent

00:28:56.360 --> 00:28:57.860
API.

00:28:57.860 --> 00:29:00.890
And finally, we want to make
sure we consider security

00:29:00.890 --> 00:29:03.650
at each step by
utilizing, again,

00:29:03.650 --> 00:29:07.250
Google Sign-In, our
Safety Net APIs,

00:29:07.250 --> 00:29:13.350
multi-factor authentication,
and/or our FIDO APIs.

00:29:13.350 --> 00:29:15.160
And if you want
more information,

00:29:15.160 --> 00:29:18.040
you can always refer
to our developer pages.

00:29:18.040 --> 00:29:21.120
You can also visit our sandbox
session tomorrow afternoon

00:29:21.120 --> 00:29:25.860
from 12:30 to 4:30 PM in
the Android platform area.

00:29:25.860 --> 00:29:27.500
And I'm going to
pause for a sec,

00:29:27.500 --> 00:29:29.180
so you guys can take
notes, take photos.

00:29:33.510 --> 00:29:34.010
All right.

00:29:34.010 --> 00:29:35.860
And thank you very much.

00:29:35.860 --> 00:29:39.210
[MUSIC PLAYING]

