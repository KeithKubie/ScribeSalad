WEBVTT
Kind: captions
Language: en

00:00:01.080 --> 00:00:04.450
Hi, I'm Jarek Wilkiewicz,
and I'm a developer advocate.

00:00:04.450 --> 00:00:05.660
I was born in Poland.

00:00:05.660 --> 00:00:07.450
And like many other
engineers, I grew up

00:00:07.450 --> 00:00:09.250
reading science fiction.

00:00:09.250 --> 00:00:11.680
In fact, this is
my favorite author.

00:00:11.680 --> 00:00:13.470
My childhood home
was actually very

00:00:13.470 --> 00:00:15.140
close to his house in Krakow.

00:00:15.140 --> 00:00:16.940
And little did I know
that his work would

00:00:16.940 --> 00:00:19.280
have major influence on my life.

00:00:19.280 --> 00:00:21.170
Did you red science fiction too?

00:00:21.170 --> 00:00:23.600
Do you remember the moment
when the protagonist,

00:00:23.600 --> 00:00:26.230
while busy saving the
world, asks her computer

00:00:26.230 --> 00:00:27.070
for something?

00:00:27.070 --> 00:00:29.310
Computer, make it so.

00:00:29.310 --> 00:00:32.640
And the machine just
does it, and it nails it.

00:00:32.640 --> 00:00:36.510
Now, why can't the real
world be more like this?

00:00:36.510 --> 00:00:39.420
For example, when a
user says, OK, Google,

00:00:39.420 --> 00:00:42.230
and asks for something,
the applicational service

00:00:42.230 --> 00:00:44.550
most suitable to
fulfill the request

00:00:44.550 --> 00:00:48.910
should be involved and get
the job done just like that.

00:00:48.910 --> 00:00:51.370
Today I want to talk to
you about technology-based

00:00:51.370 --> 00:00:53.910
on Schema.org
Actions, which I think

00:00:53.910 --> 00:00:56.490
is a small step
in that direction.

00:00:56.490 --> 00:00:58.750
With Actions, we
have an opportunity

00:00:58.750 --> 00:01:02.670
to delight your users and bring
more engagement to your app.

00:01:02.670 --> 00:01:04.860
However, we can't do it alone.

00:01:04.860 --> 00:01:06.430
We need your help.

00:01:06.430 --> 00:01:09.400
At Google, we have been working
on organizing the world's

00:01:09.400 --> 00:01:11.180
information to
make it universally

00:01:11.180 --> 00:01:12.810
accessible and useful.

00:01:12.810 --> 00:01:15.404
To help with that we've
built the Knowledge Graph.

00:01:15.404 --> 00:01:17.070
The Knowledge Graph
contains information

00:01:17.070 --> 00:01:19.934
about entities and
their relationships.

00:01:19.934 --> 00:01:22.100
One of the interesting
applications of the Knowledge

00:01:22.100 --> 00:01:24.330
Graph is resolving
ambiguities when

00:01:24.330 --> 00:01:25.850
processing language queries.

00:01:25.850 --> 00:01:28.350
For example, the
artist Dual Core

00:01:28.350 --> 00:01:32.790
is a band, which is different
than the concept of dual core.

00:01:32.790 --> 00:01:35.500
As far as the strings are
concerned, these two are equal.

00:01:35.500 --> 00:01:39.320
But to a user who is asking
their phone to play Dual Core,

00:01:39.320 --> 00:01:41.280
the difference is quite clear.

00:01:41.280 --> 00:01:45.250
Dual Core the band is assigned
a machine ID in the graph.

00:01:45.250 --> 00:01:48.490
We like to refer to these types
of object-based identifiers

00:01:48.490 --> 00:01:52.200
as things, not strings.

00:01:52.200 --> 00:01:55.840
Having a graph entity
with a machine ID, or MID,

00:01:55.840 --> 00:01:57.700
makes a big difference.

00:01:57.700 --> 00:02:00.520
The Knowledge Graph can also
help satisfy user requests

00:02:00.520 --> 00:02:02.230
with your application.

00:02:02.230 --> 00:02:05.800
I thought a good way to show you
how this works is to actually

00:02:05.800 --> 00:02:08.840
build a small Knowledge
Graph together with you.

00:02:08.840 --> 00:02:12.840
But first, let me introduce
you to my buddy Shawn.

00:02:12.840 --> 00:02:13.810
This is Shawn.

00:02:13.810 --> 00:02:15.160
We both like music.

00:02:15.160 --> 00:02:18.910
Shawn likes to DJ and spin
dance LPs in his free time.

00:02:18.910 --> 00:02:21.990
One day, we would love
to open a record store.

00:02:21.990 --> 00:02:24.220
We would curate an
awesome selection of LPs.

00:02:24.220 --> 00:02:27.090
And on weekends, we would
invite our favorite artists

00:02:27.090 --> 00:02:29.040
to give concerts at our store.

00:02:29.040 --> 00:02:31.020
Now, wouldn't that be great?

00:02:31.020 --> 00:02:32.780
Our music selection
would of course

00:02:32.780 --> 00:02:34.960
be available for
purchases online.

00:02:34.960 --> 00:02:38.740
We would offer web and mobile
streaming access as well.

00:02:38.740 --> 00:02:41.410
Since today most
music recommendations

00:02:41.410 --> 00:02:43.270
are provided by
computers, we would

00:02:43.270 --> 00:02:45.210
want to make it
easy for computers

00:02:45.210 --> 00:02:48.640
to discover and understand
what we have to offer.

00:02:48.640 --> 00:02:50.710
For example, when
they user says,

00:02:50.710 --> 00:02:52.940
OK, Google, play
Dual Core, we would

00:02:52.940 --> 00:02:56.920
like our out to be ready
to fulfill users request.

00:02:56.920 --> 00:02:57.670
All right.

00:02:57.670 --> 00:02:59.130
So we have this music store.

00:02:59.130 --> 00:03:01.630
We are selling LPs,
offering streaming access,

00:03:01.630 --> 00:03:03.800
and hosting events on weekends.

00:03:03.800 --> 00:03:05.900
How do we express
this information

00:03:05.900 --> 00:03:07.970
in the machine readable way?

00:03:07.970 --> 00:03:10.490
And how would it be used?

00:03:10.490 --> 00:03:13.230
Let's look at a simple
architecture diagram.

00:03:13.230 --> 00:03:15.010
The flow of information
is illustrated

00:03:15.010 --> 00:03:16.870
by the direction of the arrows.

00:03:16.870 --> 00:03:19.120
As you can see, the
crawler fetches data

00:03:19.120 --> 00:03:22.810
from our music website and
saves it in the Knowledge Graph.

00:03:22.810 --> 00:03:25.170
The graph is then consulted
when the user issues

00:03:25.170 --> 00:03:27.730
a voice command or a web search.

00:03:27.730 --> 00:03:29.640
Sean and I publish
this information

00:03:29.640 --> 00:03:33.020
about our music artists and
albums on our store website.

00:03:33.020 --> 00:03:35.660
Now, how do we do that?

00:03:35.660 --> 00:03:38.210
Rather than inventing a
new publishing format,

00:03:38.210 --> 00:03:41.080
we will apply the
lined data principles.

00:03:41.080 --> 00:03:44.460
The term "linked data" refers
to a set of best practices

00:03:44.460 --> 00:03:48.540
for publishing and connecting
structured data on the web.

00:03:48.540 --> 00:03:52.420
We'll use Schema.org vocabulary
and JSON-LD serialization

00:03:52.420 --> 00:03:55.850
to describe the entities
in our music store.

00:03:55.850 --> 00:03:58.850
If you haven't heard about
JSON-LD or Schema.org,

00:03:58.850 --> 00:03:59.760
don't worry.

00:03:59.760 --> 00:04:02.597
Click the links on the
screen or follow along.

00:04:02.597 --> 00:04:03.805
It's pretty straight forward.

00:04:03.805 --> 00:04:07.360
For example, here's what an
artist looks like in JSON-LD.

00:04:07.360 --> 00:04:09.760
The JSON-LD markup is
embedded in an artist web

00:04:09.760 --> 00:04:11.500
page on our site.

00:04:11.500 --> 00:04:14.450
Now, take a look at
the sameAs property.

00:04:14.450 --> 00:04:16.100
This property will
make it easier

00:04:16.100 --> 00:04:19.760
to reconcile a match-- the
JSON-LD document describing

00:04:19.760 --> 00:04:24.070
an artist with a corresponding
entity in our Knowledge Graph.

00:04:24.070 --> 00:04:27.090
In the spirit of linked
data, the sameAs property

00:04:27.090 --> 00:04:30.760
links the artist with
information on another site.

00:04:30.760 --> 00:04:32.580
This stuff is pretty
important, but we'll

00:04:32.580 --> 00:04:35.640
show you more about how
that's used in the next video.

00:04:35.640 --> 00:04:37.890
As I mentioned earlier,
we built a mobile app

00:04:37.890 --> 00:04:41.000
so our customers can
enjoy music on the go.

00:04:41.000 --> 00:04:45.530
How do we express the fact
that our music artist we carry

00:04:45.530 --> 00:04:48.260
can be listened
to using our app?

00:04:48.260 --> 00:04:51.380
Remember, I want our
mobile app to be triggered

00:04:51.380 --> 00:04:53.780
by the OK Google voice command.

00:04:53.780 --> 00:04:57.260
Fortunately, we can also
use Schema.org and JSON-LD

00:04:57.260 --> 00:04:57.990
for that.

00:04:57.990 --> 00:05:00.670
A recent addition to the
Schema.org vocabulary

00:05:00.670 --> 00:05:02.380
makes it possible
through something

00:05:02.380 --> 00:05:04.530
called potential Actions.

00:05:04.530 --> 00:05:06.290
Here's an example.

00:05:06.290 --> 00:05:08.300
Note that in our
markup, we are making

00:05:08.300 --> 00:05:12.270
an association between an artist
and the mobile application

00:05:12.270 --> 00:05:14.050
we have built.

00:05:14.050 --> 00:05:15.250
Let's recap.

00:05:15.250 --> 00:05:19.590
Shawn and I described our store
using JSON-LD and Schema.org,

00:05:19.590 --> 00:05:22.370
so now this information
is machine readable.

00:05:22.370 --> 00:05:26.230
We have also associated
our music app with artists

00:05:26.230 --> 00:05:28.230
that it can handle.

00:05:28.230 --> 00:05:30.950
Does this mean that
our music app will now

00:05:30.950 --> 00:05:33.180
be triggered when
the user asks Google

00:05:33.180 --> 00:05:35.970
to listen to the music
we have marked up?

00:05:35.970 --> 00:05:37.060
Not quite.

00:05:37.060 --> 00:05:39.980
First we need to test.

00:05:39.980 --> 00:05:41.870
There are several things
that can go wrong.

00:05:41.870 --> 00:05:43.240
We want to verify.

00:05:43.240 --> 00:05:45.620
The crawler has to
be able to parse

00:05:45.620 --> 00:05:48.600
the JSON-LD markup
we have published.

00:05:48.600 --> 00:05:50.800
Artists described in
our JSON-LD documents

00:05:50.800 --> 00:05:53.710
have to successfully
reconcile or match

00:05:53.710 --> 00:05:56.000
with entities in
our Knowledge Graph.

00:05:56.000 --> 00:05:59.220
Our mobile app has to
handle specific intents

00:05:59.220 --> 00:06:02.480
so that the music starts playing
when the app is triggered.

00:06:02.480 --> 00:06:04.690
Quite a few things
to test, isn't it?

00:06:04.690 --> 00:06:05.384
Don't worry.

00:06:05.384 --> 00:06:06.800
To help you with
testing all this,

00:06:06.800 --> 00:06:09.420
we have provided sample
open source implementations

00:06:09.420 --> 00:06:12.240
of the components you see
highlighted in this diagram--

00:06:12.240 --> 00:06:14.640
the website, the mobile
app, the crawler,

00:06:14.640 --> 00:06:16.320
and the small
Knowledge Graph running

00:06:16.320 --> 00:06:18.590
in the graph database
called Cayley.

00:06:18.590 --> 00:06:21.340
We have also built a
mobile and web simulator

00:06:21.340 --> 00:06:24.210
to help you trigger the
Schema.org actions defined

00:06:24.210 --> 00:06:26.910
in the JSON-LD documents
for the music store.

00:06:26.910 --> 00:06:27.600
All right.

00:06:27.600 --> 00:06:29.440
What do we do next?

00:06:29.440 --> 00:06:33.050
Now that our JSON-LD markup
is on our music store site,

00:06:33.050 --> 00:06:36.670
we can run the crawler to make
sure our markup is correct.

00:06:36.670 --> 00:06:39.350
The crawler parses
the JSON-LD markup

00:06:39.350 --> 00:06:42.770
and transforms it into a
graph database called Triples.

00:06:42.770 --> 00:06:44.080
It looks like this.

00:06:44.080 --> 00:06:45.520
If this sounds
intriguing to you--

00:06:45.520 --> 00:06:47.700
it sure is for me--
see the second video

00:06:47.700 --> 00:06:49.860
where the my colleague
Barak will show you

00:06:49.860 --> 00:06:52.570
how the output of the
crawler can be loaded

00:06:52.570 --> 00:06:55.550
into an open source
database called Cayley.

00:06:55.550 --> 00:06:58.590
Barak will also show you how
you can join the music store

00:06:58.590 --> 00:07:02.140
data with Freebase, a free
structured data repository

00:07:02.140 --> 00:07:04.670
with millions of people,
places, and things.

00:07:04.670 --> 00:07:07.610
If you would rather skip
ahead and learn more about how

00:07:07.610 --> 00:07:11.300
the entities published on
our music store website work

00:07:11.300 --> 00:07:14.180
in conjunction with
Schema.org actions,

00:07:14.180 --> 00:07:16.180
see the third video
in this series.

00:07:16.180 --> 00:07:18.964
Better yet, clone the
repository that we have shared

00:07:18.964 --> 00:07:20.630
and play around with
the code before you

00:07:20.630 --> 00:07:22.250
proceed to the next video.

00:07:22.250 --> 00:07:24.820
Thank you, and have a great day.

