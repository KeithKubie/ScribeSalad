WEBVTT
Kind: captions
Language: en

00:00:01.500 --> 00:00:05.680
 
[Music]

00:00:05.680 --> 00:00:05.690
[Music]
 

00:00:05.690 --> 00:00:07.639
[Music]
hello welcome

00:00:07.639 --> 00:00:07.649
hello welcome
 

00:00:07.649 --> 00:00:10.100
hello welcome
I'm Huntsville I'm a software engineer

00:00:10.100 --> 00:00:10.110
I'm Huntsville I'm a software engineer
 

00:00:10.110 --> 00:00:12.230
I'm Huntsville I'm a software engineer
in the Android runtime group and I'm

00:00:12.230 --> 00:00:12.240
in the Android runtime group and I'm
 

00:00:12.240 --> 00:00:13.700
in the Android runtime group and I'm
here to talk to you about how to manage

00:00:13.700 --> 00:00:13.710
here to talk to you about how to manage
 

00:00:13.710 --> 00:00:20.439
here to talk to you about how to manage
native C++ from memory in Android

00:00:20.439 --> 00:00:20.449
 
 

00:00:20.449 --> 00:00:23.210
 
generally most Android applications are

00:00:23.210 --> 00:00:23.220
generally most Android applications are
 

00:00:23.220 --> 00:00:25.759
generally most Android applications are
written in Java today maybe Catalan in

00:00:25.759 --> 00:00:25.769
written in Java today maybe Catalan in
 

00:00:25.769 --> 00:00:28.220
written in Java today maybe Catalan in
the future but there are sometimes

00:00:28.220 --> 00:00:28.230
the future but there are sometimes
 

00:00:28.230 --> 00:00:30.200
the future but there are sometimes
reasons to also write pieces of the

00:00:30.200 --> 00:00:30.210
reasons to also write pieces of the
 

00:00:30.210 --> 00:00:34.670
reasons to also write pieces of the
application in C or C++ code it may be

00:00:34.670 --> 00:00:34.680
application in C or C++ code it may be
 

00:00:34.680 --> 00:00:36.680
application in C or C++ code it may be
the case that you can implement some

00:00:36.680 --> 00:00:36.690
the case that you can implement some
 

00:00:36.690 --> 00:00:38.780
the case that you can implement some
algorithm more efficiently in the

00:00:38.780 --> 00:00:38.790
algorithm more efficiently in the
 

00:00:38.790 --> 00:00:43.490
algorithm more efficiently in the
language like C++ or you may have a

00:00:43.490 --> 00:00:43.500
language like C++ or you may have a
 

00:00:43.500 --> 00:00:46.040
language like C++ or you may have a
native library that already exists that

00:00:46.040 --> 00:00:46.050
native library that already exists that
 

00:00:46.050 --> 00:00:49.340
native library that already exists that
you wanted to use or the like here we're

00:00:49.340 --> 00:00:49.350
you wanted to use or the like here we're
 

00:00:49.350 --> 00:00:50.600
you wanted to use or the like here we're
really talking about multi-language

00:00:50.600 --> 00:00:50.610
really talking about multi-language
 

00:00:50.610 --> 00:00:53.660
really talking about multi-language
applications that combines a Java and

00:00:53.660 --> 00:00:53.670
applications that combines a Java and
 

00:00:53.670 --> 00:00:59.180
applications that combines a Java and
C++ and it turns out that even if you're

00:00:59.180 --> 00:00:59.190
C++ and it turns out that even if you're
 

00:00:59.190 --> 00:01:00.619
C++ and it turns out that even if you're
in the business of writing a hundred

00:01:00.619 --> 00:01:00.629
in the business of writing a hundred
 

00:01:00.629 --> 00:01:03.740
in the business of writing a hundred
percent Java apps as you maybe some of

00:01:03.740 --> 00:01:03.750
percent Java apps as you maybe some of
 

00:01:03.750 --> 00:01:05.359
percent Java apps as you maybe some of
what I'm going to talk about what may

00:01:05.359 --> 00:01:05.369
what I'm going to talk about what may
 

00:01:05.369 --> 00:01:07.399
what I'm going to talk about what may
still occur may still be an issue in

00:01:07.399 --> 00:01:07.409
still occur may still be an issue in
 

00:01:07.409 --> 00:01:11.570
still occur may still be an issue in
certain isolated cases for example if

00:01:11.570 --> 00:01:11.580
certain isolated cases for example if
 

00:01:11.580 --> 00:01:14.289
certain isolated cases for example if
you look at the Android platform

00:01:14.289 --> 00:01:14.299
you look at the Android platform
 

00:01:14.299 --> 00:01:16.580
you look at the Android platform
implementation the big integer

00:01:16.580 --> 00:01:16.590
implementation the big integer
 

00:01:16.590 --> 00:01:18.260
implementation the big integer
implementation that you're using if you

00:01:18.260 --> 00:01:18.270
implementation that you're using if you
 

00:01:18.270 --> 00:01:21.440
implementation that you're using if you
bake it using big integer at all is

00:01:21.440 --> 00:01:21.450
bake it using big integer at all is
 

00:01:21.450 --> 00:01:24.050
bake it using big integer at all is
actually implemented in terms of native

00:01:24.050 --> 00:01:24.060
actually implemented in terms of native
 

00:01:24.060 --> 00:01:26.749
actually implemented in terms of native
code underneath and that may in other

00:01:26.749 --> 00:01:26.759
code underneath and that may in other
 

00:01:26.759 --> 00:01:28.280
code underneath and that may in other
cases that sort of thing may actually

00:01:28.280 --> 00:01:28.290
cases that sort of thing may actually
 

00:01:28.290 --> 00:01:30.800
cases that sort of thing may actually
show too so that was one of the reasons

00:01:30.800 --> 00:01:30.810
show too so that was one of the reasons
 

00:01:30.810 --> 00:01:32.749
show too so that was one of the reasons
I got involved in this I actually spent

00:01:32.749 --> 00:01:32.759
I got involved in this I actually spent
 

00:01:32.759 --> 00:01:34.069
I got involved in this I actually spent
some time working on the Android

00:01:34.069 --> 00:01:34.079
some time working on the Android
 

00:01:34.079 --> 00:01:35.749
some time working on the Android
calculator app which happens to be a

00:01:35.749 --> 00:01:35.759
calculator app which happens to be a
 

00:01:35.759 --> 00:01:41.210
calculator app which happens to be a
major client of big integer and here

00:01:41.210 --> 00:01:41.220
major client of big integer and here
 

00:01:41.220 --> 00:01:44.480
major client of big integer and here
we're going to use a running example of

00:01:44.480 --> 00:01:44.490
we're going to use a running example of
 

00:01:44.490 --> 00:01:47.600
we're going to use a running example of
a hypothetical C++ package that we want

00:01:47.600 --> 00:01:47.610
a hypothetical C++ package that we want
 

00:01:47.610 --> 00:01:50.179
a hypothetical C++ package that we want
to access from Java language code that

00:01:50.179 --> 00:01:50.189
to access from Java language code that
 

00:01:50.189 --> 00:01:52.670
to access from Java language code that
manipulates polynomials over GF 2 does

00:01:52.670 --> 00:01:52.680
manipulates polynomials over GF 2 does
 

00:01:52.680 --> 00:01:55.639
manipulates polynomials over GF 2 does
anybody know what that means good you're

00:01:55.639 --> 00:01:55.649
anybody know what that means good you're
 

00:01:55.649 --> 00:01:58.399
anybody know what that means good you're
not supposed to it doesn't matter as far

00:01:58.399 --> 00:01:58.409
not supposed to it doesn't matter as far
 

00:01:58.409 --> 00:02:00.230
not supposed to it doesn't matter as far
as we're concerned these are basically

00:02:00.230 --> 00:02:00.240
as we're concerned these are basically
 

00:02:00.240 --> 00:02:01.940
as we're concerned these are basically
bit vectors with an odd notion of

00:02:01.940 --> 00:02:01.950
bit vectors with an odd notion of
 

00:02:01.950 --> 00:02:03.469
bit vectors with an odd notion of
multiplication but I don't even care

00:02:03.469 --> 00:02:03.479
multiplication but I don't even care
 

00:02:03.479 --> 00:02:04.969
multiplication but I don't even care
about that I'm not going to show you the

00:02:04.969 --> 00:02:04.979
about that I'm not going to show you the
 

00:02:04.979 --> 00:02:08.570
about that I'm not going to show you the
C++ code actually in this this

00:02:08.570 --> 00:02:08.580
C++ code actually in this this
 

00:02:08.580 --> 00:02:10.850
C++ code actually in this this
particular example is good because it

00:02:10.850 --> 00:02:10.860
particular example is good because it
 

00:02:10.860 --> 00:02:12.140
particular example is good because it
turns out that in spite of

00:02:12.140 --> 00:02:12.150
turns out that in spite of
 

00:02:12.150 --> 00:02:13.729
turns out that in spite of
fact that it seems esoteric modern

00:02:13.729 --> 00:02:13.739
fact that it seems esoteric modern
 

00:02:13.739 --> 00:02:16.339
fact that it seems esoteric modern
Harvard often has a hardware support for

00:02:16.339 --> 00:02:16.349
Harvard often has a hardware support for
 

00:02:16.349 --> 00:02:17.690
Harvard often has a hardware support for
this so you can actually build a

00:02:17.690 --> 00:02:17.700
this so you can actually build a
 

00:02:17.700 --> 00:02:19.690
this so you can actually build a
blazingly fast really low-level

00:02:19.690 --> 00:02:19.700
blazingly fast really low-level
 

00:02:19.700 --> 00:02:22.100
blazingly fast really low-level
implementation so what we want to do is

00:02:22.100 --> 00:02:22.110
implementation so what we want to do is
 

00:02:22.110 --> 00:02:24.110
implementation so what we want to do is
we have this library and we want to call

00:02:24.110 --> 00:02:24.120
we have this library and we want to call
 

00:02:24.120 --> 00:02:30.649
we have this library and we want to call
that library from Java code so what this

00:02:30.649 --> 00:02:30.659
that library from Java code so what this
 

00:02:30.659 --> 00:02:36.349
that library from Java code so what this
looks like roughly is the following it's

00:02:36.349 --> 00:02:36.359
looks like roughly is the following it's
 

00:02:36.359 --> 00:02:39.949
looks like roughly is the following it's
because that you see up here so the

00:02:39.949 --> 00:02:39.959
because that you see up here so the
 

00:02:39.959 --> 00:02:42.649
because that you see up here so the
important part here is we have a Java

00:02:42.649 --> 00:02:42.659
important part here is we have a Java
 

00:02:42.659 --> 00:02:47.539
important part here is we have a Java
class which logically owns a C++ object

00:02:47.539 --> 00:02:47.549
class which logically owns a C++ object
 

00:02:47.549 --> 00:02:49.190
class which logically owns a C++ object
that actually contains the guts of the

00:02:49.190 --> 00:02:49.200
that actually contains the guts of the
 

00:02:49.200 --> 00:02:51.199
that actually contains the guts of the
implementation that actually implements

00:02:51.199 --> 00:02:51.209
implementation that actually implements
 

00:02:51.209 --> 00:02:54.379
implementation that actually implements
the the real functionality which I'm not

00:02:54.379 --> 00:02:54.389
the the real functionality which I'm not
 

00:02:54.389 --> 00:02:56.890
the the real functionality which I'm not
going to show you what the Java object

00:02:56.890 --> 00:02:56.900
going to show you what the Java object
 

00:02:56.900 --> 00:03:00.470
going to show you what the Java object
holds is a Java long which is really a

00:03:00.470 --> 00:03:00.480
holds is a Java long which is really a
 

00:03:00.480 --> 00:03:04.940
holds is a Java long which is really a
C++ pointed in disguise this then what

00:03:04.940 --> 00:03:04.950
C++ pointed in disguise this then what
 

00:03:04.950 --> 00:03:06.920
C++ pointed in disguise this then what
it's going to do is for example when you

00:03:06.920 --> 00:03:06.930
it's going to do is for example when you
 

00:03:06.930 --> 00:03:08.509
it's going to do is for example when you
want to multiply two of these this is

00:03:08.509 --> 00:03:08.519
want to multiply two of these this is
 

00:03:08.519 --> 00:03:10.250
want to multiply two of these this is
eventually going to call this native

00:03:10.250 --> 00:03:10.260
eventually going to call this native
 

00:03:10.260 --> 00:03:13.069
eventually going to call this native
multiply function it's going to pass it

00:03:13.069 --> 00:03:13.079
multiply function it's going to pass it
 

00:03:13.079 --> 00:03:16.520
multiply function it's going to pass it
to Java Long's this is going to go into

00:03:16.520 --> 00:03:16.530
to Java Long's this is going to go into
 

00:03:16.530 --> 00:03:18.890
to Java Long's this is going to go into
some J&amp;I code which will cast those Java

00:03:18.890 --> 00:03:18.900
some J&amp;I code which will cast those Java
 

00:03:18.900 --> 00:03:22.099
some J&amp;I code which will cast those Java
Long's to C++ pointers and manipulate

00:03:22.099 --> 00:03:22.109
Long's to C++ pointers and manipulate
 

00:03:22.109 --> 00:03:24.500
Long's to C++ pointers and manipulate
the C++ object and in this particular

00:03:24.500 --> 00:03:24.510
the C++ object and in this particular
 

00:03:24.510 --> 00:03:27.080
the C++ object and in this particular
case we turn another Java long which is

00:03:27.080 --> 00:03:27.090
case we turn another Java long which is
 

00:03:27.090 --> 00:03:31.640
case we turn another Java long which is
really a C++ pointer so the the Java

00:03:31.640 --> 00:03:31.650
really a C++ pointer so the the Java
 

00:03:31.650 --> 00:03:34.099
really a C++ pointer so the the Java
level multiplication routine is really

00:03:34.099 --> 00:03:34.109
level multiplication routine is really
 

00:03:34.109 --> 00:03:37.430
level multiplication routine is really
one that just gives me back a new binary

00:03:37.430 --> 00:03:37.440
one that just gives me back a new binary
 

00:03:37.440 --> 00:03:42.259
one that just gives me back a new binary
poly object containing this Java long

00:03:42.259 --> 00:03:42.269
poly object containing this Java long
 

00:03:42.269 --> 00:03:45.710
poly object containing this Java long
which really points to C++ code which I

00:03:45.710 --> 00:03:45.720
which really points to C++ code which I
 

00:03:45.720 --> 00:03:48.500
which really points to C++ code which I
obtained by I obtained the the

00:03:48.500 --> 00:03:48.510
obtained by I obtained the the
 

00:03:48.510 --> 00:03:52.309
obtained by I obtained the the
underlying the underlying C++ pointer by

00:03:52.309 --> 00:03:52.319
underlying the underlying C++ pointer by
 

00:03:52.319 --> 00:03:56.479
underlying the underlying C++ pointer by
calling this native multiply routine so

00:03:56.479 --> 00:03:56.489
calling this native multiply routine so
 

00:03:56.489 --> 00:03:58.039
calling this native multiply routine so
what here's a pictorial representation

00:03:58.039 --> 00:03:58.049
what here's a pictorial representation
 

00:03:58.049 --> 00:04:00.920
what here's a pictorial representation
of what this looks like I have a the

00:04:00.920 --> 00:04:00.930
of what this looks like I have a the
 

00:04:00.930 --> 00:04:03.099
of what this looks like I have a the
Java object at the top of the slide

00:04:03.099 --> 00:04:03.109
Java object at the top of the slide
 

00:04:03.109 --> 00:04:05.390
Java object at the top of the slide
which is the only thing that the job

00:04:05.390 --> 00:04:05.400
which is the only thing that the job
 

00:04:05.400 --> 00:04:08.629
which is the only thing that the job
that my client actually sees so I want

00:04:08.629 --> 00:04:08.639
that my client actually sees so I want
 

00:04:08.639 --> 00:04:11.479
that my client actually sees so I want
the client to be able to treat this Java

00:04:11.479 --> 00:04:11.489
the client to be able to treat this Java
 

00:04:11.489 --> 00:04:13.039
the client to be able to treat this Java
object as though it were implemented

00:04:13.039 --> 00:04:13.049
object as though it were implemented
 

00:04:13.049 --> 00:04:14.990
object as though it were implemented
completely in Java and ignore the fact

00:04:14.990 --> 00:04:15.000
completely in Java and ignore the fact
 

00:04:15.000 --> 00:04:18.050
completely in Java and ignore the fact
that the C++ code underneath the

00:04:18.050 --> 00:04:18.060
that the C++ code underneath the
 

00:04:18.060 --> 00:04:20.390
that the C++ code underneath the
dot-dash line here is the Java long

00:04:20.390 --> 00:04:20.400
dot-dash line here is the Java long
 

00:04:20.400 --> 00:04:23.450
dot-dash line here is the Java long
which is really a C++ pointer which sort

00:04:23.450 --> 00:04:23.460
which is really a C++ pointer which sort
 

00:04:23.460 --> 00:04:25.850
which is really a C++ pointer which sort
of points to the C++ object reference

00:04:25.850 --> 00:04:25.860
of points to the C++ object reference
 

00:04:25.860 --> 00:04:28.640
of points to the C++ object reference
though Java doesn't know that and inside

00:04:28.640 --> 00:04:28.650
though Java doesn't know that and inside
 

00:04:28.650 --> 00:04:30.770
though Java doesn't know that and inside
the C++ object representation there may

00:04:30.770 --> 00:04:30.780
the C++ object representation there may
 

00:04:30.780 --> 00:04:32.330
the C++ object representation there may
be additional pointers that point to

00:04:32.330 --> 00:04:32.340
be additional pointers that point to
 

00:04:32.340 --> 00:04:37.249
be additional pointers that point to
additional C++ data structures so what's

00:04:37.249 --> 00:04:37.259
additional C++ data structures so what's
 

00:04:37.259 --> 00:04:41.059
additional C++ data structures so what's
the problem with doing this the problem

00:04:41.059 --> 00:04:41.069
the problem with doing this the problem
 

00:04:41.069 --> 00:04:43.459
the problem with doing this the problem
comes into play when we try to think

00:04:43.459 --> 00:04:43.469
comes into play when we try to think
 

00:04:43.469 --> 00:04:45.860
comes into play when we try to think
about how objects how memory gets

00:04:45.860 --> 00:04:45.870
about how objects how memory gets
 

00:04:45.870 --> 00:04:48.529
about how objects how memory gets
managed and how objects get be allocated

00:04:48.529 --> 00:04:48.539
managed and how objects get be allocated
 

00:04:48.539 --> 00:04:51.619
managed and how objects get be allocated
on the on the Java language side we have

00:04:51.619 --> 00:04:51.629
on the on the Java language side we have
 

00:04:51.629 --> 00:04:53.270
on the on the Java language side we have
a garbage collector that cleans up after

00:04:53.270 --> 00:04:53.280
a garbage collector that cleans up after
 

00:04:53.280 --> 00:04:55.040
a garbage collector that cleans up after
us and we generally don't have to worry

00:04:55.040 --> 00:04:55.050
us and we generally don't have to worry
 

00:04:55.050 --> 00:04:56.540
us and we generally don't have to worry
about this too much when things are no

00:04:56.540 --> 00:04:56.550
about this too much when things are no
 

00:04:56.550 --> 00:04:58.159
about this too much when things are no
longer reference they go away when they

00:04:58.159 --> 00:04:58.169
longer reference they go away when they
 

00:04:58.169 --> 00:05:02.059
longer reference they go away when they
become unreachable they go away on the

00:05:02.059 --> 00:05:02.069
become unreachable they go away on the
 

00:05:02.069 --> 00:05:04.279
become unreachable they go away on the
c++ side we have a manual memory

00:05:04.279 --> 00:05:04.289
c++ side we have a manual memory
 

00:05:04.289 --> 00:05:06.920
c++ side we have a manual memory
management discipline usually which

00:05:06.920 --> 00:05:06.930
management discipline usually which
 

00:05:06.930 --> 00:05:09.050
management discipline usually which
means we explicitly need to call some

00:05:09.050 --> 00:05:09.060
means we explicitly need to call some
 

00:05:09.060 --> 00:05:11.330
means we explicitly need to call some
delete functions and bolita in order to

00:05:11.330 --> 00:05:11.340
delete functions and bolita in order to
 

00:05:11.340 --> 00:05:12.920
delete functions and bolita in order to
deallocate the memory when it's no

00:05:12.920 --> 00:05:12.930
deallocate the memory when it's no
 

00:05:12.930 --> 00:05:16.040
deallocate the memory when it's no
longer reachable and so how do we

00:05:16.040 --> 00:05:16.050
longer reachable and so how do we
 

00:05:16.050 --> 00:05:17.779
longer reachable and so how do we
actually do that we have to arrange for

00:05:17.779 --> 00:05:17.789
actually do that we have to arrange for
 

00:05:17.789 --> 00:05:19.820
actually do that we have to arrange for
somebody to call the delete function on

00:05:19.820 --> 00:05:19.830
somebody to call the delete function on
 

00:05:19.830 --> 00:05:24.529
somebody to call the delete function on
the c++ object so here's the traditional

00:05:24.529 --> 00:05:24.539
the c++ object so here's the traditional
 

00:05:24.539 --> 00:05:26.390
the c++ object so here's the traditional
way to do this and the point of this

00:05:26.390 --> 00:05:26.400
way to do this and the point of this
 

00:05:26.400 --> 00:05:28.939
way to do this and the point of this
talk is largely to talk you out of doing

00:05:28.939 --> 00:05:28.949
talk is largely to talk you out of doing
 

00:05:28.949 --> 00:05:33.829
talk is largely to talk you out of doing
it this way so the traditional way of

00:05:33.829 --> 00:05:33.839
it this way so the traditional way of
 

00:05:33.839 --> 00:05:35.510
it this way so the traditional way of
doing this which has the attraction

00:05:35.510 --> 00:05:35.520
doing this which has the attraction
 

00:05:35.520 --> 00:05:37.550
doing this which has the attraction
admittedly that it's relatively simple

00:05:37.550 --> 00:05:37.560
admittedly that it's relatively simple
 

00:05:37.560 --> 00:05:38.990
admittedly that it's relatively simple
to write the code compared to what I'm

00:05:38.990 --> 00:05:39.000
to write the code compared to what I'm
 

00:05:39.000 --> 00:05:41.839
to write the code compared to what I'm
going to show you is that in addition to

00:05:41.839 --> 00:05:41.849
going to show you is that in addition to
 

00:05:41.849 --> 00:05:43.820
going to show you is that in addition to
things like the native multiply method

00:05:43.820 --> 00:05:43.830
things like the native multiply method
 

00:05:43.830 --> 00:05:46.040
things like the native multiply method
I'll have a native delete method to

00:05:46.040 --> 00:05:46.050
I'll have a native delete method to
 

00:05:46.050 --> 00:05:49.369
I'll have a native delete method to
which I also pass a job along and then

00:05:49.369 --> 00:05:49.379
which I also pass a job along and then
 

00:05:49.379 --> 00:05:51.019
which I also pass a job along and then
the native delete method will again

00:05:51.019 --> 00:05:51.029
the native delete method will again
 

00:05:51.029 --> 00:05:52.909
the native delete method will again
convert that to the C++ pointer and

00:05:52.909 --> 00:05:52.919
convert that to the C++ pointer and
 

00:05:52.919 --> 00:05:54.529
convert that to the C++ pointer and
invoke delete on it or invoke the

00:05:54.529 --> 00:05:54.539
invoke delete on it or invoke the
 

00:05:54.539 --> 00:05:57.230
invoke delete on it or invoke the
appropriate D leader on it and I will

00:05:57.230 --> 00:05:57.240
appropriate D leader on it and I will
 

00:05:57.240 --> 00:06:01.369
appropriate D leader on it and I will
call this I will call that native delete

00:06:01.369 --> 00:06:01.379
call this I will call that native delete
 

00:06:01.379 --> 00:06:04.450
call this I will call that native delete
from a java finalizer

00:06:04.450 --> 00:06:04.460
from a java finalizer
 

00:06:04.460 --> 00:06:07.219
from a java finalizer
the finalizer is invoked more or less

00:06:07.219 --> 00:06:07.229
the finalizer is invoked more or less
 

00:06:07.229 --> 00:06:09.649
the finalizer is invoked more or less
when the object becomes unreachable so

00:06:09.649 --> 00:06:09.659
when the object becomes unreachable so
 

00:06:09.659 --> 00:06:11.659
when the object becomes unreachable so
that then goes ahead and invoke the ADT

00:06:11.659 --> 00:06:11.669
that then goes ahead and invoke the ADT
 

00:06:11.669 --> 00:06:13.519
that then goes ahead and invoke the ADT
Leeton correctly allocates the c++

00:06:13.519 --> 00:06:13.529
Leeton correctly allocates the c++
 

00:06:13.529 --> 00:06:16.129
Leeton correctly allocates the c++
object as well I'll show you some

00:06:16.129 --> 00:06:16.139
object as well I'll show you some
 

00:06:16.139 --> 00:06:21.709
object as well I'll show you some
reasons why this is problematic here so

00:06:21.709 --> 00:06:21.719
reasons why this is problematic here so
 

00:06:21.719 --> 00:06:23.839
reasons why this is problematic here so
I'll go through a long list of finalizer

00:06:23.839 --> 00:06:23.849
I'll go through a long list of finalizer
 

00:06:23.849 --> 00:06:26.749
I'll go through a long list of finalizer
of finalizer problems finalizes have a

00:06:26.749 --> 00:06:26.759
of finalizer problems finalizes have a
 

00:06:26.759 --> 00:06:29.059
of finalizer problems finalizes have a
deserved reputation for being hazardous

00:06:29.059 --> 00:06:29.069
deserved reputation for being hazardous
 

00:06:29.069 --> 00:06:31.820
deserved reputation for being hazardous
and I'll only confirm that here but I'll

00:06:31.820 --> 00:06:31.830
and I'll only confirm that here but I'll
 

00:06:31.830 --> 00:06:34.339
and I'll only confirm that here but I'll
actually emphasize some some relatively

00:06:34.339 --> 00:06:34.349
actually emphasize some some relatively
 

00:06:34.349 --> 00:06:35.930
actually emphasize some some relatively
lesser known problems which in my

00:06:35.930 --> 00:06:35.940
lesser known problems which in my
 

00:06:35.940 --> 00:06:37.140
lesser known problems which in my
opinion actually the

00:06:37.140 --> 00:06:37.150
opinion actually the
 

00:06:37.150 --> 00:06:38.910
opinion actually the
serious ones to try to get to get come

00:06:38.910 --> 00:06:38.920
serious ones to try to get to get come
 

00:06:38.920 --> 00:06:40.860
serious ones to try to get to get come
to grips with and then I'll show you how

00:06:40.860 --> 00:06:40.870
to grips with and then I'll show you how
 

00:06:40.870 --> 00:06:44.670
to grips with and then I'll show you how
to work around those so the the first

00:06:44.670 --> 00:06:44.680
to work around those so the the first
 

00:06:44.680 --> 00:06:47.730
to work around those so the the first
problem is that if two objects become

00:06:47.730 --> 00:06:47.740
problem is that if two objects become
 

00:06:47.740 --> 00:06:51.090
problem is that if two objects become
unreachable the finalizes actually run

00:06:51.090 --> 00:06:51.100
unreachable the finalizes actually run
 

00:06:51.100 --> 00:06:53.760
unreachable the finalizes actually run
in arbitrary order that includes the

00:06:53.760 --> 00:06:53.770
in arbitrary order that includes the
 

00:06:53.770 --> 00:06:56.040
in arbitrary order that includes the
case in which two objects that point to

00:06:56.040 --> 00:06:56.050
case in which two objects that point to
 

00:06:56.050 --> 00:06:57.690
case in which two objects that point to
each other become unreachable at the

00:06:57.690 --> 00:06:57.700
each other become unreachable at the
 

00:06:57.700 --> 00:07:00.630
each other become unreachable at the
same time they can be finalized in the

00:07:00.630 --> 00:07:00.640
same time they can be finalized in the
 

00:07:00.640 --> 00:07:04.740
same time they can be finalized in the
wrong order meaning that the the second

00:07:04.740 --> 00:07:04.750
wrong order meaning that the the second
 

00:07:04.750 --> 00:07:06.930
wrong order meaning that the the second
one to be finalized actually try to

00:07:06.930 --> 00:07:06.940
one to be finalized actually try to
 

00:07:06.940 --> 00:07:08.610
one to be finalized actually try to
access an object that's already been

00:07:08.610 --> 00:07:08.620
access an object that's already been
 

00:07:08.620 --> 00:07:11.070
access an object that's already been
finalized I'll go into some more details

00:07:11.070 --> 00:07:11.080
finalized I'll go into some more details
 

00:07:11.080 --> 00:07:14.130
finalized I'll go into some more details
there so as a result of that what can

00:07:14.130 --> 00:07:14.140
there so as a result of that what can
 

00:07:14.140 --> 00:07:15.870
there so as a result of that what can
happen is that you can get dangling

00:07:15.870 --> 00:07:15.880
happen is that you can get dangling
 

00:07:15.880 --> 00:07:20.000
happen is that you can get dangling
pointers and CD allocated C++ objects

00:07:20.000 --> 00:07:20.010
pointers and CD allocated C++ objects
 

00:07:20.010 --> 00:07:22.860
pointers and CD allocated C++ objects
the thing to keep in mind here is that

00:07:22.860 --> 00:07:22.870
the thing to keep in mind here is that
 

00:07:22.870 --> 00:07:25.500
the thing to keep in mind here is that
as a result of dangling pointers in this

00:07:25.500 --> 00:07:25.510
as a result of dangling pointers in this
 

00:07:25.510 --> 00:07:28.260
as a result of dangling pointers in this
environment is that you and very often

00:07:28.260 --> 00:07:28.270
environment is that you and very often
 

00:07:28.270 --> 00:07:32.790
environment is that you and very often
end up corrupting the c++ c but what's

00:07:32.790 --> 00:07:32.800
end up corrupting the c++ c but what's
 

00:07:32.800 --> 00:07:36.120
end up corrupting the c++ c but what's
the math the the java language runtime

00:07:36.120 --> 00:07:36.130
the math the the java language runtime
 

00:07:36.130 --> 00:07:39.570
the math the the java language runtime
actually relies on the c++ heap as well

00:07:39.570 --> 00:07:39.580
actually relies on the c++ heap as well
 

00:07:39.580 --> 00:07:42.390
actually relies on the c++ heap as well
so what if when this happens often what

00:07:42.390 --> 00:07:42.400
so what if when this happens often what
 

00:07:42.400 --> 00:07:45.030
so what if when this happens often what
you end up with is also a compacted Java

00:07:45.030 --> 00:07:45.040
you end up with is also a compacted Java
 

00:07:45.040 --> 00:07:47.760
you end up with is also a compacted Java
Runtime and you may end up seeing caches

00:07:47.760 --> 00:07:47.770
Runtime and you may end up seeing caches
 

00:07:47.770 --> 00:07:49.350
Runtime and you may end up seeing caches
that actually look like Java garbage

00:07:49.350 --> 00:07:49.360
that actually look like Java garbage
 

00:07:49.360 --> 00:07:56.130
that actually look like Java garbage
collector caches or the like so here's

00:07:56.130 --> 00:07:56.140
collector caches or the like so here's
 

00:07:56.140 --> 00:08:00.390
collector caches or the like so here's
to illustrate how this can go on here's

00:08:00.390 --> 00:08:00.400
to illustrate how this can go on here's
 

00:08:00.400 --> 00:08:02.580
to illustrate how this can go on here's
a sample client application that

00:08:02.580 --> 00:08:02.590
a sample client application that
 

00:08:02.590 --> 00:08:05.100
a sample client application that
actually uses the binary poly class that

00:08:05.100 --> 00:08:05.110
actually uses the binary poly class that
 

00:08:05.110 --> 00:08:08.790
actually uses the binary poly class that
we just talked about and this is this in

00:08:08.790 --> 00:08:08.800
we just talked about and this is this in
 

00:08:08.800 --> 00:08:10.920
we just talked about and this is this in
combination with the previous class will

00:08:10.920 --> 00:08:10.930
combination with the previous class will
 

00:08:10.930 --> 00:08:13.170
combination with the previous class will
definitely break so definitely do not do

00:08:13.170 --> 00:08:13.180
definitely break so definitely do not do
 

00:08:13.180 --> 00:08:16.080
definitely break so definitely do not do
this so what this is doing in its

00:08:16.080 --> 00:08:16.090
this so what this is doing in its
 

00:08:16.090 --> 00:08:18.150
this so what this is doing in its
finalized method it's just doing

00:08:18.150 --> 00:08:18.160
finalized method it's just doing
 

00:08:18.160 --> 00:08:21.690
finalized method it's just doing
something innocuous on my binary poly

00:08:21.690 --> 00:08:21.700
something innocuous on my binary poly
 

00:08:21.700 --> 00:08:23.820
something innocuous on my binary poly
which is this field that happens to hold

00:08:23.820 --> 00:08:23.830
which is this field that happens to hold
 

00:08:23.830 --> 00:08:25.950
which is this field that happens to hold
a pointer to the binary poly now the

00:08:25.950 --> 00:08:25.960
a pointer to the binary poly now the
 

00:08:25.960 --> 00:08:27.960
a pointer to the binary poly now the
problem here is that it's entirely

00:08:27.960 --> 00:08:27.970
problem here is that it's entirely
 

00:08:27.970 --> 00:08:31.560
problem here is that it's entirely
possible that the my binary poly object

00:08:31.560 --> 00:08:31.570
possible that the my binary poly object
 

00:08:31.570 --> 00:08:35.790
possible that the my binary poly object
actually gets finalized first so what

00:08:35.790 --> 00:08:35.800
actually gets finalized first so what
 

00:08:35.800 --> 00:08:38.010
actually gets finalized first so what
you're accessing here is in my binary

00:08:38.010 --> 00:08:38.020
you're accessing here is in my binary
 

00:08:38.020 --> 00:08:40.590
you're accessing here is in my binary
poly which actually has already been

00:08:40.590 --> 00:08:40.600
poly which actually has already been
 

00:08:40.600 --> 00:08:44.070
poly which actually has already been
finalized so by the time you you access

00:08:44.070 --> 00:08:44.080
finalized so by the time you you access
 

00:08:44.080 --> 00:08:47.010
finalized so by the time you you access
it the pointer the c++ object underlying

00:08:47.010 --> 00:08:47.020
it the pointer the c++ object underlying
 

00:08:47.020 --> 00:08:49.500
it the pointer the c++ object underlying
it will have been de-allocated and the

00:08:49.500 --> 00:08:49.510
it will have been de-allocated and the
 

00:08:49.510 --> 00:08:50.850
it will have been de-allocated and the
native pointer that you're using

00:08:50.850 --> 00:08:50.860
native pointer that you're using
 

00:08:50.860 --> 00:08:54.720
native pointer that you're using
actually points to nowhere so that's a

00:08:54.720 --> 00:08:54.730
actually points to nowhere so that's a
 

00:08:54.730 --> 00:08:57.030
actually points to nowhere so that's a
bad thing

00:08:57.030 --> 00:08:57.040
 
 

00:08:57.040 --> 00:08:58.950
 
there's the second problem with

00:08:58.950 --> 00:08:58.960
there's the second problem with
 

00:08:58.960 --> 00:09:01.320
there's the second problem with
finalizes which is actually it turns out

00:09:01.320 --> 00:09:01.330
finalizes which is actually it turns out
 

00:09:01.330 --> 00:09:04.140
finalizes which is actually it turns out
to be more complicated to work around in

00:09:04.140 --> 00:09:04.150
to be more complicated to work around in
 

00:09:04.150 --> 00:09:06.420
to be more complicated to work around in
it's less employ less important on

00:09:06.420 --> 00:09:06.430
it's less employ less important on
 

00:09:06.430 --> 00:09:09.300
it's less employ less important on
Android but it's generally important

00:09:09.300 --> 00:09:09.310
Android but it's generally important
 

00:09:09.310 --> 00:09:12.690
Android but it's generally important
when writing java language code so by

00:09:12.690 --> 00:09:12.700
when writing java language code so by
 

00:09:12.700 --> 00:09:14.880
when writing java language code so by
Java language rules and this is not

00:09:14.880 --> 00:09:14.890
Java language rules and this is not
 

00:09:14.890 --> 00:09:16.890
Java language rules and this is not
currently - on Android and not currently

00:09:16.890 --> 00:09:16.900
currently - on Android and not currently
 

00:09:16.900 --> 00:09:18.830
currently - on Android and not currently
believed to be true on Android and

00:09:18.830 --> 00:09:18.840
believed to be true on Android and
 

00:09:18.840 --> 00:09:21.840
believed to be true on Android and
object X is finalized it may actually be

00:09:21.840 --> 00:09:21.850
object X is finalized it may actually be
 

00:09:21.850 --> 00:09:24.090
object X is finalized it may actually be
invoked while one of X's methods is

00:09:24.090 --> 00:09:24.100
invoked while one of X's methods is
 

00:09:24.100 --> 00:09:27.180
invoked while one of X's methods is
still running so while while I'm still

00:09:27.180 --> 00:09:27.190
still running so while while I'm still
 

00:09:27.190 --> 00:09:28.770
still running so while while I'm still
running a method on that object that

00:09:28.770 --> 00:09:28.780
running a method on that object that
 

00:09:28.780 --> 00:09:31.980
running a method on that object that
object may end up getting finalized this

00:09:31.980 --> 00:09:31.990
object may end up getting finalized this
 

00:09:31.990 --> 00:09:33.600
object may end up getting finalized this
can result in the same sort of

00:09:33.600 --> 00:09:33.610
can result in the same sort of
 

00:09:33.610 --> 00:09:35.490
can result in the same sort of
phenomenon I get native heat corruption

00:09:35.490 --> 00:09:35.500
phenomenon I get native heat corruption
 

00:09:35.500 --> 00:09:37.830
phenomenon I get native heat corruption
as and as a result possibly Java Runtime

00:09:37.830 --> 00:09:37.840
as and as a result possibly Java Runtime
 

00:09:37.840 --> 00:09:39.000
as and as a result possibly Java Runtime
corruption

00:09:39.000 --> 00:09:39.010
corruption
 

00:09:39.010 --> 00:09:43.200
corruption
let me explain why that happens so

00:09:43.200 --> 00:09:43.210
let me explain why that happens so
 

00:09:43.210 --> 00:09:45.090
let me explain why that happens so
here's sort of again an excerpt from the

00:09:45.090 --> 00:09:45.100
here's sort of again an excerpt from the
 

00:09:45.100 --> 00:09:49.050
here's sort of again an excerpt from the
binary poly class I have I used native

00:09:49.050 --> 00:09:49.060
binary poly class I have I used native
 

00:09:49.060 --> 00:09:51.480
binary poly class I have I used native
mobile I use multiply before I'll use it

00:09:51.480 --> 00:09:51.490
mobile I use multiply before I'll use it
 

00:09:51.490 --> 00:09:53.190
mobile I use multiply before I'll use it
again here's I have this native multiply

00:09:53.190 --> 00:09:53.200
again here's I have this native multiply
 

00:09:53.200 --> 00:09:57.030
again here's I have this native multiply
method that gets called by multiply if

00:09:57.030 --> 00:09:57.040
method that gets called by multiply if
 

00:09:57.040 --> 00:09:58.920
method that gets called by multiply if
you look at what this actually gets

00:09:58.920 --> 00:09:58.930
you look at what this actually gets
 

00:09:58.930 --> 00:10:00.960
you look at what this actually gets
compiled to and this isn't real this is

00:10:00.960 --> 00:10:00.970
compiled to and this isn't real this is
 

00:10:00.970 --> 00:10:04.010
compiled to and this isn't real this is
sort of pseudocode

00:10:04.010 --> 00:10:04.020
 
 

00:10:04.020 --> 00:10:07.890
 
pseudocode it gets compiled to look

00:10:07.890 --> 00:10:07.900
pseudocode it gets compiled to look
 

00:10:07.900 --> 00:10:12.570
pseudocode it gets compiled to look
something like this so what happens when

00:10:12.570 --> 00:10:12.580
something like this so what happens when
 

00:10:12.580 --> 00:10:16.080
something like this so what happens when
I want to multiply to two values I first

00:10:16.080 --> 00:10:16.090
I want to multiply to two values I first
 

00:10:16.090 --> 00:10:19.350
I want to multiply to two values I first
end up leaving the the native handles

00:10:19.350 --> 00:10:19.360
end up leaving the the native handles
 

00:10:19.360 --> 00:10:21.690
end up leaving the the native handles
from both of them in this case from this

00:10:21.690 --> 00:10:21.700
from both of them in this case from this
 

00:10:21.700 --> 00:10:24.390
from both of them in this case from this
and I may put this in here explicitly to

00:10:24.390 --> 00:10:24.400
and I may put this in here explicitly to
 

00:10:24.400 --> 00:10:25.350
and I may put this in here explicitly to
make that clear

00:10:25.350 --> 00:10:25.360
make that clear
 

00:10:25.360 --> 00:10:27.540
make that clear
so I repeat and native handle from this

00:10:27.540 --> 00:10:27.550
so I repeat and native handle from this
 

00:10:27.550 --> 00:10:29.520
so I repeat and native handle from this
and I repeat and they don't handle from

00:10:29.520 --> 00:10:29.530
and I repeat and they don't handle from
 

00:10:29.530 --> 00:10:31.830
and I repeat and they don't handle from
other then I might allocate the new

00:10:31.830 --> 00:10:31.840
other then I might allocate the new
 

00:10:31.840 --> 00:10:36.180
other then I might allocate the new
binary poly object and then I will go

00:10:36.180 --> 00:10:36.190
binary poly object and then I will go
 

00:10:36.190 --> 00:10:39.480
binary poly object and then I will go
ahead and call the native method so the

00:10:39.480 --> 00:10:39.490
ahead and call the native method so the
 

00:10:39.490 --> 00:10:42.330
ahead and call the native method so the
problem with this is if we look at the

00:10:42.330 --> 00:10:42.340
problem with this is if we look at the
 

00:10:42.340 --> 00:10:45.870
problem with this is if we look at the
uses of the actual Java objects the last

00:10:45.870 --> 00:10:45.880
uses of the actual Java objects the last
 

00:10:45.880 --> 00:10:48.900
uses of the actual Java objects the last
use of this and other actually happened

00:10:48.900 --> 00:10:48.910
use of this and other actually happened
 

00:10:48.910 --> 00:10:53.130
use of this and other actually happened
before allocate the new binary poly at

00:10:53.130 --> 00:10:53.140
before allocate the new binary poly at
 

00:10:53.140 --> 00:10:56.820
before allocate the new binary poly at
that point from that point on this

00:10:56.820 --> 00:10:56.830
that point from that point on this
 

00:10:56.830 --> 00:10:59.040
that point from that point on this
method doesn't use either this or other

00:10:59.040 --> 00:10:59.050
method doesn't use either this or other
 

00:10:59.050 --> 00:10:59.840
method doesn't use either this or other
anymore

00:10:59.840 --> 00:10:59.850
anymore
 

00:10:59.850 --> 00:11:02.000
anymore
and it may so happen that this is in

00:11:02.000 --> 00:11:02.010
and it may so happen that this is in
 

00:11:02.010 --> 00:11:04.790
and it may so happen that this is in
fact the last call on those so this is

00:11:04.790 --> 00:11:04.800
fact the last call on those so this is
 

00:11:04.800 --> 00:11:06.680
fact the last call on those so this is
in fact the point at which those become

00:11:06.680 --> 00:11:06.690
in fact the point at which those become
 

00:11:06.690 --> 00:11:08.330
in fact the point at which those become
garbage and the garbage collected

00:11:08.330 --> 00:11:08.340
garbage and the garbage collected
 

00:11:08.340 --> 00:11:10.100
garbage and the garbage collected
notices that they're no longer teachable

00:11:10.100 --> 00:11:10.110
notices that they're no longer teachable
 

00:11:10.110 --> 00:11:14.120
notices that they're no longer teachable
so what can happen at that point if the

00:11:14.120 --> 00:11:14.130
so what can happen at that point if the
 

00:11:14.130 --> 00:11:18.770
so what can happen at that point if the
if the ad is designed to allow this and

00:11:18.770 --> 00:11:18.780
if the ad is designed to allow this and
 

00:11:18.780 --> 00:11:21.950
if the ad is designed to allow this and
if all the stalls line up just right it

00:11:21.950 --> 00:11:21.960
if all the stalls line up just right it
 

00:11:21.960 --> 00:11:23.420
if all the stalls line up just right it
can in fact happen that the garbage

00:11:23.420 --> 00:11:23.430
can in fact happen that the garbage
 

00:11:23.430 --> 00:11:26.030
can in fact happen that the garbage
collector at that point besides that

00:11:26.030 --> 00:11:26.040
collector at that point besides that
 

00:11:26.040 --> 00:11:28.220
collector at that point besides that
these are no longer that this and other

00:11:28.220 --> 00:11:28.230
these are no longer that this and other
 

00:11:28.230 --> 00:11:31.220
these are no longer that this and other
no longer needed and arrange for the

00:11:31.220 --> 00:11:31.230
no longer needed and arrange for the
 

00:11:31.230 --> 00:11:33.230
no longer needed and arrange for the
finalizes on both of those to get it

00:11:33.230 --> 00:11:33.240
finalizes on both of those to get it
 

00:11:33.240 --> 00:11:37.580
finalizes on both of those to get it
vote roughly where the new binary poly

00:11:37.580 --> 00:11:37.590
vote roughly where the new binary poly
 

00:11:37.590 --> 00:11:40.700
vote roughly where the new binary poly
happens occurs what then happens is that

00:11:40.700 --> 00:11:40.710
happens occurs what then happens is that
 

00:11:40.710 --> 00:11:43.010
happens occurs what then happens is that
when we call native multiply we don't

00:11:43.010 --> 00:11:43.020
when we call native multiply we don't
 

00:11:43.020 --> 00:11:44.570
when we call native multiply we don't
need the objects anymore but we still

00:11:44.570 --> 00:11:44.580
need the objects anymore but we still
 

00:11:44.580 --> 00:11:46.580
need the objects anymore but we still
need the native handles but now the

00:11:46.580 --> 00:11:46.590
need the native handles but now the
 

00:11:46.590 --> 00:11:48.350
need the native handles but now the
native handles that would be allocated

00:11:48.350 --> 00:11:48.360
native handles that would be allocated
 

00:11:48.360 --> 00:11:51.620
native handles that would be allocated
so in fact I'm accessing objects that

00:11:51.620 --> 00:11:51.630
so in fact I'm accessing objects that
 

00:11:51.630 --> 00:11:54.830
so in fact I'm accessing objects that
are no longer around this is allowed by

00:11:54.830 --> 00:11:54.840
are no longer around this is allowed by
 

00:11:54.840 --> 00:11:57.470
are no longer around this is allowed by
the Java language specification and it's

00:11:57.470 --> 00:11:57.480
the Java language specification and it's
 

00:11:57.480 --> 00:11:59.930
the Java language specification and it's
something that that has been seen on the

00:11:59.930 --> 00:11:59.940
something that that has been seen on the
 

00:11:59.940 --> 00:12:01.640
something that that has been seen on the
ground occasion in the wild but it

00:12:01.640 --> 00:12:01.650
ground occasion in the wild but it
 

00:12:01.650 --> 00:12:07.010
ground occasion in the wild but it
doesn't happen very often there are more

00:12:07.010 --> 00:12:07.020
doesn't happen very often there are more
 

00:12:07.020 --> 00:12:10.130
doesn't happen very often there are more
problems with finalizes you can see a

00:12:10.130 --> 00:12:10.140
problems with finalizes you can see a
 

00:12:10.140 --> 00:12:12.170
problems with finalizes you can see a
lot of them by looking at the joshua

00:12:12.170 --> 00:12:12.180
lot of them by looking at the joshua
 

00:12:12.180 --> 00:12:14.570
lot of them by looking at the joshua
blocks effective java book which

00:12:14.570 --> 00:12:14.580
blocks effective java book which
 

00:12:14.580 --> 00:12:16.100
blocks effective java book which
actually has a section on the on

00:12:16.100 --> 00:12:16.110
actually has a section on the on
 

00:12:16.110 --> 00:12:21.560
actually has a section on the on
entitled I believe avoid finalizes one

00:12:21.560 --> 00:12:21.570
entitled I believe avoid finalizes one
 

00:12:21.570 --> 00:12:23.570
entitled I believe avoid finalizes one
one thing to indicate the problems is

00:12:23.570 --> 00:12:23.580
one thing to indicate the problems is
 

00:12:23.580 --> 00:12:26.090
one thing to indicate the problems is
that it's actually the plan as I believe

00:12:26.090 --> 00:12:26.100
that it's actually the plan as I believe
 

00:12:26.100 --> 00:12:29.540
that it's actually the plan as I believe
to deprecate finalized and finalized in

00:12:29.540 --> 00:12:29.550
to deprecate finalized and finalized in
 

00:12:29.550 --> 00:12:33.740
to deprecate finalized and finalized in
JDK 9 another issue which I look at

00:12:33.740 --> 00:12:33.750
JDK 9 another issue which I look at
 

00:12:33.750 --> 00:12:36.650
JDK 9 another issue which I look at
occasional here a little bit is that for

00:12:36.650 --> 00:12:36.660
occasional here a little bit is that for
 

00:12:36.660 --> 00:12:39.680
occasional here a little bit is that for
these for this to work correctly and if

00:12:39.680 --> 00:12:39.690
these for this to work correctly and if
 

00:12:39.690 --> 00:12:42.290
these for this to work correctly and if
you run an application that allocates

00:12:42.290 --> 00:12:42.300
you run an application that allocates
 

00:12:42.300 --> 00:12:44.660
you run an application that allocates
lots of native memory and relatively

00:12:44.660 --> 00:12:44.670
lots of native memory and relatively
 

00:12:44.670 --> 00:12:47.030
lots of native memory and relatively
little Java memory it may actually not

00:12:47.030 --> 00:12:47.040
little Java memory it may actually not
 

00:12:47.040 --> 00:12:48.830
little Java memory it may actually not
be the case that you the garbage

00:12:48.830 --> 00:12:48.840
be the case that you the garbage
 

00:12:48.840 --> 00:12:50.720
be the case that you the garbage
collector runs fondly enough to actually

00:12:50.720 --> 00:12:50.730
collector runs fondly enough to actually
 

00:12:50.730 --> 00:12:53.330
collector runs fondly enough to actually
invoke finalizes or the other mechanism

00:12:53.330 --> 00:12:53.340
invoke finalizes or the other mechanism
 

00:12:53.340 --> 00:12:56.000
invoke finalizes or the other mechanism
also just in a minute here so you

00:12:56.000 --> 00:12:56.010
also just in a minute here so you
 

00:12:56.010 --> 00:12:57.680
also just in a minute here so you
actually may have to invoke these

00:12:57.680 --> 00:12:57.690
actually may have to invoke these
 

00:12:57.690 --> 00:12:59.690
actually may have to invoke these
systems RTC and system to run

00:12:59.690 --> 00:12:59.700
systems RTC and system to run
 

00:12:59.700 --> 00:13:02.060
systems RTC and system to run
finalization occasionally which is

00:13:02.060 --> 00:13:02.070
finalization occasionally which is
 

00:13:02.070 --> 00:13:03.740
finalization occasionally which is
tricky to do because if you do it too

00:13:03.740 --> 00:13:03.750
tricky to do because if you do it too
 

00:13:03.750 --> 00:13:05.270
tricky to do because if you do it too
much it will greatly slow down your

00:13:05.270 --> 00:13:05.280
much it will greatly slow down your
 

00:13:05.280 --> 00:13:07.340
much it will greatly slow down your
application and many people have fallen

00:13:07.340 --> 00:13:07.350
application and many people have fallen
 

00:13:07.350 --> 00:13:10.220
application and many people have fallen
into that trap there's a more subtle

00:13:10.220 --> 00:13:10.230
into that trap there's a more subtle
 

00:13:10.230 --> 00:13:12.350
into that trap there's a more subtle
issue that they sometimes finalize those

00:13:12.350 --> 00:13:12.360
issue that they sometimes finalize those
 

00:13:12.360 --> 00:13:12.980
issue that they sometimes finalize those
actually

00:13:12.980 --> 00:13:12.990
actually
 

00:13:12.990 --> 00:13:15.320
actually
extend the lifetime of the Java object

00:13:15.320 --> 00:13:15.330
extend the lifetime of the Java object
 

00:13:15.330 --> 00:13:17.000
extend the lifetime of the Java object
for another garbage collection cycle

00:13:17.000 --> 00:13:17.010
for another garbage collection cycle
 

00:13:17.010 --> 00:13:19.040
for another garbage collection cycle
which means for generational garbage

00:13:19.040 --> 00:13:19.050
which means for generational garbage
 

00:13:19.050 --> 00:13:21.050
which means for generational garbage
collected they may actually cause it to

00:13:21.050 --> 00:13:21.060
collected they may actually cause it to
 

00:13:21.060 --> 00:13:23.360
collected they may actually cause it to
survive into the old generation that it

00:13:23.360 --> 00:13:23.370
survive into the old generation that it
 

00:13:23.370 --> 00:13:25.670
survive into the old generation that it
may be the lifetime may be greatly

00:13:25.670 --> 00:13:25.680
may be the lifetime may be greatly
 

00:13:25.680 --> 00:13:27.500
may be the lifetime may be greatly
extended as a result of just having a

00:13:27.500 --> 00:13:27.510
extended as a result of just having a
 

00:13:27.510 --> 00:13:28.810
extended as a result of just having a
finalizar

00:13:28.810 --> 00:13:28.820
finalizar
 

00:13:28.820 --> 00:13:32.090
finalizar
and there are other issues which I won't

00:13:32.090 --> 00:13:32.100
and there are other issues which I won't
 

00:13:32.100 --> 00:13:35.210
and there are other issues which I won't
go into here so how do you really delete

00:13:35.210 --> 00:13:35.220
go into here so how do you really delete
 

00:13:35.220 --> 00:13:42.560
go into here so how do you really delete
C++ objects I should point out the usual

00:13:42.560 --> 00:13:42.570
C++ objects I should point out the usual
 

00:13:42.570 --> 00:13:46.010
C++ objects I should point out the usual
advice here which I'll skim over briefly

00:13:46.010 --> 00:13:46.020
advice here which I'll skim over briefly
 

00:13:46.020 --> 00:13:49.100
advice here which I'll skim over briefly
is to use explicit clothes and tie with

00:13:49.100 --> 00:13:49.110
is to use explicit clothes and tie with
 

00:13:49.110 --> 00:13:51.110
is to use explicit clothes and tie with
resources so Java has a syntactic

00:13:51.110 --> 00:13:51.120
resources so Java has a syntactic
 

00:13:51.120 --> 00:13:54.829
resources so Java has a syntactic
facility which allow us essentially C++

00:13:54.829 --> 00:13:54.839
facility which allow us essentially C++
 

00:13:54.839 --> 00:13:57.290
facility which allow us essentially C++
style distraction when you leave a scope

00:13:57.290 --> 00:13:57.300
style distraction when you leave a scope
 

00:13:57.300 --> 00:14:00.290
style distraction when you leave a scope
you can arrange to to explicitly call

00:14:00.290 --> 00:14:00.300
you can arrange to to explicitly call
 

00:14:00.300 --> 00:14:04.160
you can arrange to to explicitly call
the close function and that works when

00:14:04.160 --> 00:14:04.170
the close function and that works when
 

00:14:04.170 --> 00:14:06.920
the close function and that works when
it's applicable so there cases like file

00:14:06.920 --> 00:14:06.930
it's applicable so there cases like file
 

00:14:06.930 --> 00:14:09.620
it's applicable so there cases like file
like object system allocated objects and

00:14:09.620 --> 00:14:09.630
like object system allocated objects and
 

00:14:09.630 --> 00:14:11.630
like object system allocated objects and
torn with it's generally that I approach

00:14:11.630 --> 00:14:11.640
torn with it's generally that I approach
 

00:14:11.640 --> 00:14:14.840
torn with it's generally that I approach
and that's the main recommendation on

00:14:14.840 --> 00:14:14.850
and that's the main recommendation on
 

00:14:14.850 --> 00:14:16.220
and that's the main recommendation on
the other hand there are many cases in

00:14:16.220 --> 00:14:16.230
the other hand there are many cases in
 

00:14:16.230 --> 00:14:18.680
the other hand there are many cases in
my experience where that doesn't work

00:14:18.680 --> 00:14:18.690
my experience where that doesn't work
 

00:14:18.690 --> 00:14:20.960
my experience where that doesn't work
and in general people already use this

00:14:20.960 --> 00:14:20.970
and in general people already use this
 

00:14:20.970 --> 00:14:23.329
and in general people already use this
wing in those cases where it where it's

00:14:23.329 --> 00:14:23.339
wing in those cases where it where it's
 

00:14:23.339 --> 00:14:27.829
wing in those cases where it where it's
applicable so for example if I mention C

00:14:27.829 --> 00:14:27.839
applicable so for example if I mention C
 

00:14:27.839 --> 00:14:30.889
applicable so for example if I mention C
is the java.lang big integer and example

00:14:30.889 --> 00:14:30.899
is the java.lang big integer and example
 

00:14:30.899 --> 00:14:32.810
is the java.lang big integer and example
in the platform you really don't want to

00:14:32.810 --> 00:14:32.820
in the platform you really don't want to
 

00:14:32.820 --> 00:14:34.460
in the platform you really don't want to
have to call big integer that close

00:14:34.460 --> 00:14:34.470
have to call big integer that close
 

00:14:34.470 --> 00:14:35.960
have to call big integer that close
every time one of those goes out of

00:14:35.960 --> 00:14:35.970
every time one of those goes out of
 

00:14:35.970 --> 00:14:38.150
every time one of those goes out of
scope that would be completely untenable

00:14:38.150 --> 00:14:38.160
scope that would be completely untenable
 

00:14:38.160 --> 00:14:40.340
scope that would be completely untenable
and there are many or more examples like

00:14:40.340 --> 00:14:40.350
and there are many or more examples like
 

00:14:40.350 --> 00:14:45.800
and there are many or more examples like
that in the Android platform I should

00:14:45.800 --> 00:14:45.810
that in the Android platform I should
 

00:14:45.810 --> 00:14:47.569
that in the Android platform I should
warn you that for what are the solutions

00:14:47.569 --> 00:14:47.579
warn you that for what are the solutions
 

00:14:47.579 --> 00:14:49.670
warn you that for what are the solutions
I'm talking about a lot of this is

00:14:49.670 --> 00:14:49.680
I'm talking about a lot of this is
 

00:14:49.680 --> 00:14:51.470
I'm talking about a lot of this is
actually not fully settled in the

00:14:51.470 --> 00:14:51.480
actually not fully settled in the
 

00:14:51.480 --> 00:14:53.810
actually not fully settled in the
community as a whole this is sort of

00:14:53.810 --> 00:14:53.820
community as a whole this is sort of
 

00:14:53.820 --> 00:14:57.170
community as a whole this is sort of
beyond Android as well it's still trying

00:14:57.170 --> 00:14:57.180
beyond Android as well it's still trying
 

00:14:57.180 --> 00:14:58.430
beyond Android as well it's still trying
to figure out what the right way to do

00:14:58.430 --> 00:14:58.440
to figure out what the right way to do
 

00:14:58.440 --> 00:15:00.019
to figure out what the right way to do
this is these are mostly sort of general

00:15:00.019 --> 00:15:00.029
this is these are mostly sort of general
 

00:15:00.029 --> 00:15:01.639
this is these are mostly sort of general
Java language issues that are actually

00:15:01.639 --> 00:15:01.649
Java language issues that are actually
 

00:15:01.649 --> 00:15:06.380
Java language issues that are actually
not specific to Android but there seems

00:15:06.380 --> 00:15:06.390
not specific to Android but there seems
 

00:15:06.390 --> 00:15:08.780
not specific to Android but there seems
to be it seems to be agreement that you

00:15:08.780 --> 00:15:08.790
to be it seems to be agreement that you
 

00:15:08.790 --> 00:15:10.610
to be it seems to be agreement that you
shouldn't use object not finalized as

00:15:10.610 --> 00:15:10.620
shouldn't use object not finalized as
 

00:15:10.620 --> 00:15:12.170
shouldn't use object not finalized as
evidenced by the fact that it's going to

00:15:12.170 --> 00:15:12.180
evidenced by the fact that it's going to
 

00:15:12.180 --> 00:15:16.670
evidenced by the fact that it's going to
be deprecated sometime in the future so

00:15:16.670 --> 00:15:16.680
be deprecated sometime in the future so
 

00:15:16.680 --> 00:15:18.440
be deprecated sometime in the future so
the advice here and I'll go into how to

00:15:18.440 --> 00:15:18.450
the advice here and I'll go into how to
 

00:15:18.450 --> 00:15:20.720
the advice here and I'll go into how to
do this is we use something called

00:15:20.720 --> 00:15:20.730
do this is we use something called
 

00:15:20.730 --> 00:15:24.199
do this is we use something called
java.lang graph phantom reference and

00:15:24.199 --> 00:15:24.209
java.lang graph phantom reference and
 

00:15:24.209 --> 00:15:26.939
java.lang graph phantom reference and
many of you may have encountered that as

00:15:26.939 --> 00:15:26.949
many of you may have encountered that as
 

00:15:26.949 --> 00:15:28.740
many of you may have encountered that as
far as I can tell most people look at it

00:15:28.740 --> 00:15:28.750
far as I can tell most people look at it
 

00:15:28.750 --> 00:15:31.980
far as I can tell most people look at it
and ignore it because it's it's somewhat

00:15:31.980 --> 00:15:31.990
and ignore it because it's it's somewhat
 

00:15:31.990 --> 00:15:33.689
and ignore it because it's it's somewhat
complicated probably appears even more

00:15:33.689 --> 00:15:33.699
complicated probably appears even more
 

00:15:33.699 --> 00:15:36.780
complicated probably appears even more
complicated than it actually is it's not

00:15:36.780 --> 00:15:36.790
complicated than it actually is it's not
 

00:15:36.790 --> 00:15:38.639
complicated than it actually is it's not
really commonly used but it actually is

00:15:38.639 --> 00:15:38.649
really commonly used but it actually is
 

00:15:38.649 --> 00:15:41.600
really commonly used but it actually is
a better replacement for finalizes it

00:15:41.600 --> 00:15:41.610
a better replacement for finalizes it
 

00:15:41.610 --> 00:15:44.069
a better replacement for finalizes it
avoids the problem that the finalizar

00:15:44.069 --> 00:15:44.079
avoids the problem that the finalizar
 

00:15:44.079 --> 00:15:46.800
avoids the problem that the finalizar
can see finalized objects because of the

00:15:46.800 --> 00:15:46.810
can see finalized objects because of the
 

00:15:46.810 --> 00:15:49.860
can see finalized objects because of the
ordering issues phantom references

00:15:49.860 --> 00:15:49.870
ordering issues phantom references
 

00:15:49.870 --> 00:15:52.019
ordering issues phantom references
ensure that you run the cleanup code

00:15:52.019 --> 00:15:52.029
ensure that you run the cleanup code
 

00:15:52.029 --> 00:15:54.329
ensure that you run the cleanup code
only when the object really is about to

00:15:54.329 --> 00:15:54.339
only when the object really is about to
 

00:15:54.339 --> 00:15:56.040
only when the object really is about to
go away and nobody can use it and nobody

00:15:56.040 --> 00:15:56.050
go away and nobody can use it and nobody
 

00:15:56.050 --> 00:15:57.650
go away and nobody can use it and nobody
can see it anymore

00:15:57.650 --> 00:15:57.660
can see it anymore
 

00:15:57.660 --> 00:16:00.059
can see it anymore
it suddenly deals with finalized

00:16:00.059 --> 00:16:00.069
it suddenly deals with finalized
 

00:16:00.069 --> 00:16:02.720
it suddenly deals with finalized
application issues it's not going away

00:16:02.720 --> 00:16:02.730
application issues it's not going away
 

00:16:02.730 --> 00:16:06.329
application issues it's not going away
it also ends up dealing with some of the

00:16:06.329 --> 00:16:06.339
it also ends up dealing with some of the
 

00:16:06.339 --> 00:16:08.819
it also ends up dealing with some of the
more subtle issues though not all of

00:16:08.819 --> 00:16:08.829
more subtle issues though not all of
 

00:16:08.829 --> 00:16:11.100
more subtle issues though not all of
them it does not feel with the premature

00:16:11.100 --> 00:16:11.110
them it does not feel with the premature
 

00:16:11.110 --> 00:16:12.840
them it does not feel with the premature
cleanup issue that I mentioned earlier

00:16:12.840 --> 00:16:12.850
cleanup issue that I mentioned earlier
 

00:16:12.850 --> 00:16:14.850
cleanup issue that I mentioned earlier
that an object can be finalized while

00:16:14.850 --> 00:16:14.860
that an object can be finalized while
 

00:16:14.860 --> 00:16:16.499
that an object can be finalized while
one of its methods is still running for

00:16:16.499 --> 00:16:16.509
one of its methods is still running for
 

00:16:16.509 --> 00:16:19.769
one of its methods is still running for
example the major difficulty with using

00:16:19.769 --> 00:16:19.779
example the major difficulty with using
 

00:16:19.779 --> 00:16:21.449
example the major difficulty with using
it and I'll go through an example here

00:16:21.449 --> 00:16:21.459
it and I'll go through an example here
 

00:16:21.459 --> 00:16:24.090
it and I'll go through an example here
is that it's relatively complicated to

00:16:24.090 --> 00:16:24.100
is that it's relatively complicated to
 

00:16:24.100 --> 00:16:26.340
is that it's relatively complicated to
use at the moment and we're in the

00:16:26.340 --> 00:16:26.350
use at the moment and we're in the
 

00:16:26.350 --> 00:16:27.990
use at the moment and we're in the
process of making that better I think

00:16:27.990 --> 00:16:28.000
process of making that better I think
 

00:16:28.000 --> 00:16:29.550
process of making that better I think
various groups are in the process of

00:16:29.550 --> 00:16:29.560
various groups are in the process of
 

00:16:29.560 --> 00:16:33.240
various groups are in the process of
making that better so Java 9 actually

00:16:33.240 --> 00:16:33.250
making that better so Java 9 actually
 

00:16:33.250 --> 00:16:35.249
making that better so Java 9 actually
has this notion of a cleaner which makes

00:16:35.249 --> 00:16:35.259
has this notion of a cleaner which makes
 

00:16:35.259 --> 00:16:39.120
has this notion of a cleaner which makes
this a little bit simpler weave inside

00:16:39.120 --> 00:16:39.130
this a little bit simpler weave inside
 

00:16:39.130 --> 00:16:41.400
this a little bit simpler weave inside
the platform we actually have something

00:16:41.400 --> 00:16:41.410
the platform we actually have something
 

00:16:41.410 --> 00:16:43.319
the platform we actually have something
called native allocation registry that

00:16:43.319 --> 00:16:43.329
called native allocation registry that
 

00:16:43.329 --> 00:16:45.509
called native allocation registry that
deals with some of this this is at the

00:16:45.509 --> 00:16:45.519
deals with some of this this is at the
 

00:16:45.519 --> 00:16:48.870
deals with some of this this is at the
moment not a public API but if you're

00:16:48.870 --> 00:16:48.880
moment not a public API but if you're
 

00:16:48.880 --> 00:16:50.400
moment not a public API but if you're
interested in this we're trying to

00:16:50.400 --> 00:16:50.410
interested in this we're trying to
 

00:16:50.410 --> 00:16:51.929
interested in this we're trying to
assess whether it would be good to make

00:16:51.929 --> 00:16:51.939
assess whether it would be good to make
 

00:16:51.939 --> 00:16:54.120
assess whether it would be good to make
that a public API or whether and whether

00:16:54.120 --> 00:16:54.130
that a public API or whether and whether
 

00:16:54.130 --> 00:17:00.420
that a public API or whether and whether
this is the right API to do that with so

00:17:00.420 --> 00:17:00.430
this is the right API to do that with so
 

00:17:00.430 --> 00:17:02.340
this is the right API to do that with so
what should you use instead well I

00:17:02.340 --> 00:17:02.350
what should you use instead well I
 

00:17:02.350 --> 00:17:04.319
what should you use instead well I
mentioned these phantom references so

00:17:04.319 --> 00:17:04.329
mentioned these phantom references so
 

00:17:04.329 --> 00:17:08.179
mentioned these phantom references so
what are they a phantom reference is

00:17:08.179 --> 00:17:08.189
what are they a phantom reference is
 

00:17:08.189 --> 00:17:10.949
what are they a phantom reference is
shown here with the ghost next to it

00:17:10.949 --> 00:17:10.959
shown here with the ghost next to it
 

00:17:10.959 --> 00:17:15.569
shown here with the ghost next to it
it's an object that's associated with

00:17:15.569 --> 00:17:15.579
it's an object that's associated with
 

00:17:15.579 --> 00:17:17.279
it's an object that's associated with
the object whose lifetime you want to

00:17:17.279 --> 00:17:17.289
the object whose lifetime you want to
 

00:17:17.289 --> 00:17:20.819
the object whose lifetime you want to
monitor so it doesn't actually it

00:17:20.819 --> 00:17:20.829
monitor so it doesn't actually it
 

00:17:20.829 --> 00:17:24.120
monitor so it doesn't actually it
doesn't actually point to or equal to

00:17:24.120 --> 00:17:24.130
doesn't actually point to or equal to
 

00:17:24.130 --> 00:17:26.539
doesn't actually point to or equal to
the the binary poly object that we want

00:17:26.539 --> 00:17:26.549
the the binary poly object that we want
 

00:17:26.549 --> 00:17:28.919
the the binary poly object that we want
monitored and then we want to be cleaned

00:17:28.919 --> 00:17:28.929
monitored and then we want to be cleaned
 

00:17:28.929 --> 00:17:31.320
monitored and then we want to be cleaned
up after so you can sort of think of the

00:17:31.320 --> 00:17:31.330
up after so you can sort of think of the
 

00:17:31.330 --> 00:17:33.240
up after so you can sort of think of the
phantom reference as the last will and

00:17:33.240 --> 00:17:33.250
phantom reference as the last will and
 

00:17:33.250 --> 00:17:35.490
phantom reference as the last will and
testament of the years of Java object

00:17:35.490 --> 00:17:35.500
testament of the years of Java object
 

00:17:35.500 --> 00:17:37.560
testament of the years of Java object
it tells you what to do how to clean up

00:17:37.560 --> 00:17:37.570
it tells you what to do how to clean up
 

00:17:37.570 --> 00:17:39.330
it tells you what to do how to clean up
the object once a die once the Java

00:17:39.330 --> 00:17:39.340
the object once a die once the Java
 

00:17:39.340 --> 00:17:44.460
the object once a die once the Java
object dies and so both the the way this

00:17:44.460 --> 00:17:44.470
object dies and so both the the way this
 

00:17:44.470 --> 00:17:48.360
object dies and so both the the way this
works normally in order to actually use

00:17:48.360 --> 00:17:48.370
works normally in order to actually use
 

00:17:48.370 --> 00:17:49.890
works normally in order to actually use
a phantom reference you'll usually

00:17:49.890 --> 00:17:49.900
a phantom reference you'll usually
 

00:17:49.900 --> 00:17:52.620
a phantom reference you'll usually
inherit from it and the inherited

00:17:52.620 --> 00:17:52.630
inherit from it and the inherited
 

00:17:52.630 --> 00:17:55.920
inherit from it and the inherited
derived class the Class VI from Phantom

00:17:55.920 --> 00:17:55.930
derived class the Class VI from Phantom
 

00:17:55.930 --> 00:17:58.290
derived class the Class VI from Phantom
reference will have a pointer to the C++

00:17:58.290 --> 00:17:58.300
reference will have a pointer to the C++
 

00:17:58.300 --> 00:18:01.830
reference will have a pointer to the C++
object along with the the Java binary

00:18:01.830 --> 00:18:01.840
object along with the the Java binary
 

00:18:01.840 --> 00:18:03.990
object along with the the Java binary
poly object there's also a reference

00:18:03.990 --> 00:18:04.000
poly object there's also a reference
 

00:18:04.000 --> 00:18:07.260
poly object there's also a reference
queue off to the side here which I'll

00:18:07.260 --> 00:18:07.270
queue off to the side here which I'll
 

00:18:07.270 --> 00:18:09.180
queue off to the side here which I'll
show you what all that plays in a second

00:18:09.180 --> 00:18:09.190
show you what all that plays in a second
 

00:18:09.190 --> 00:18:11.190
show you what all that plays in a second
here notice that I put those grounds

00:18:11.190 --> 00:18:11.200
here notice that I put those grounds
 

00:18:11.200 --> 00:18:12.900
here notice that I put those grounds
symbols in here in a few places to

00:18:12.900 --> 00:18:12.910
symbols in here in a few places to
 

00:18:12.910 --> 00:18:15.150
symbols in here in a few places to
indicate that these are those are

00:18:15.150 --> 00:18:15.160
indicate that these are those are
 

00:18:15.160 --> 00:18:16.800
indicate that these are those are
objects that we need to make sure don't

00:18:16.800 --> 00:18:16.810
objects that we need to make sure don't
 

00:18:16.810 --> 00:18:18.540
objects that we need to make sure don't
get garbage collected so we need to have

00:18:18.540 --> 00:18:18.550
get garbage collected so we need to have
 

00:18:18.550 --> 00:18:20.160
get garbage collected so we need to have
some mechanism for keeping those around

00:18:20.160 --> 00:18:20.170
some mechanism for keeping those around
 

00:18:20.170 --> 00:18:21.810
some mechanism for keeping those around
that applies to both defense and

00:18:21.810 --> 00:18:21.820
that applies to both defense and
 

00:18:21.820 --> 00:18:24.930
that applies to both defense and
reference and the reference queue so

00:18:24.930 --> 00:18:24.940
reference and the reference queue so
 

00:18:24.940 --> 00:18:27.720
reference and the reference queue so
what happens after binary poly becomes

00:18:27.720 --> 00:18:27.730
what happens after binary poly becomes
 

00:18:27.730 --> 00:18:31.740
what happens after binary poly becomes
unreachable the phantom reference itself

00:18:31.740 --> 00:18:31.750
unreachable the phantom reference itself
 

00:18:31.750 --> 00:18:33.660
unreachable the phantom reference itself
gets added to the associated reference

00:18:33.660 --> 00:18:33.670
gets added to the associated reference
 

00:18:33.670 --> 00:18:36.180
gets added to the associated reference
queue and that's basically all that

00:18:36.180 --> 00:18:36.190
queue and that's basically all that
 

00:18:36.190 --> 00:18:38.220
queue and that's basically all that
happens the Java object gets immediately

00:18:38.220 --> 00:18:38.230
happens the Java object gets immediately
 

00:18:38.230 --> 00:18:40.410
happens the Java object gets immediately
collected there's no longer any need for

00:18:40.410 --> 00:18:40.420
collected there's no longer any need for
 

00:18:40.420 --> 00:18:42.420
collected there's no longer any need for
it because the phantom reference itself

00:18:42.420 --> 00:18:42.430
it because the phantom reference itself
 

00:18:42.430 --> 00:18:49.890
it because the phantom reference itself
knows how to clean up so I'll show you a

00:18:49.890 --> 00:18:49.900
knows how to clean up so I'll show you a
 

00:18:49.900 --> 00:18:52.110
knows how to clean up so I'll show you a
sort of quick implementation of this

00:18:52.110 --> 00:18:52.120
sort of quick implementation of this
 

00:18:52.120 --> 00:18:55.680
sort of quick implementation of this
year in in this case this pub actually

00:18:55.680 --> 00:18:55.690
year in in this case this pub actually
 

00:18:55.690 --> 00:18:57.900
year in in this case this pub actually
is fairly easy so we've modified binary

00:18:57.900 --> 00:18:57.910
is fairly easy so we've modified binary
 

00:18:57.910 --> 00:19:00.960
is fairly easy so we've modified binary
poly to deal with this sort of reference

00:19:00.960 --> 00:19:00.970
poly to deal with this sort of reference
 

00:19:00.970 --> 00:19:04.320
poly to deal with this sort of reference
cleanup and what I've done is and on the

00:19:04.320 --> 00:19:04.330
cleanup and what I've done is and on the
 

00:19:04.330 --> 00:19:06.540
cleanup and what I've done is and on the
next slide I'll show you BP phantom

00:19:06.540 --> 00:19:06.550
next slide I'll show you BP phantom
 

00:19:06.550 --> 00:19:09.600
next slide I'll show you BP phantom
reference implementation that inherits

00:19:09.600 --> 00:19:09.610
reference implementation that inherits
 

00:19:09.610 --> 00:19:11.340
reference implementation that inherits
from phantom references the kind of

00:19:11.340 --> 00:19:11.350
from phantom references the kind of
 

00:19:11.350 --> 00:19:13.470
from phantom references the kind of
phantom reference that specialized with

00:19:13.470 --> 00:19:13.480
phantom reference that specialized with
 

00:19:13.480 --> 00:19:15.890
phantom reference that specialized with
some additional functionality here and

00:19:15.890 --> 00:19:15.900
some additional functionality here and
 

00:19:15.900 --> 00:19:19.200
some additional functionality here and
what this what this does here is we

00:19:19.200 --> 00:19:19.210
what this what this does here is we
 

00:19:19.210 --> 00:19:20.910
what this what this does here is we
still have the native delete method that

00:19:20.910 --> 00:19:20.920
still have the native delete method that
 

00:19:20.920 --> 00:19:24.770
still have the native delete method that
actually he allocates the C++ object

00:19:24.770 --> 00:19:24.780
actually he allocates the C++ object
 

00:19:24.780 --> 00:19:28.500
actually he allocates the C++ object
when I whenever I allocate a binary

00:19:28.500 --> 00:19:28.510
when I whenever I allocate a binary
 

00:19:28.510 --> 00:19:30.270
when I whenever I allocate a binary
object and now do it through this

00:19:30.270 --> 00:19:30.280
object and now do it through this
 

00:19:30.280 --> 00:19:33.690
object and now do it through this
factory method which allocates via which

00:19:33.690 --> 00:19:33.700
factory method which allocates via which
 

00:19:33.700 --> 00:19:35.850
factory method which allocates via which
constructs and allocates the object but

00:19:35.850 --> 00:19:35.860
constructs and allocates the object but
 

00:19:35.860 --> 00:19:38.180
constructs and allocates the object but
then immediately goes and registers it

00:19:38.180 --> 00:19:38.190
then immediately goes and registers it
 

00:19:38.190 --> 00:19:41.070
then immediately goes and registers it
through a static method in VP phantom

00:19:41.070 --> 00:19:41.080
through a static method in VP phantom
 

00:19:41.080 --> 00:19:42.600
through a static method in VP phantom
reference the way I've implemented it

00:19:42.600 --> 00:19:42.610
reference the way I've implemented it
 

00:19:42.610 --> 00:19:46.580
reference the way I've implemented it
here now what's pp phantom reference

00:19:46.580 --> 00:19:46.590
here now what's pp phantom reference
 

00:19:46.590 --> 00:19:50.279
here now what's pp phantom reference
so that fits on a slide in the same in

00:19:50.279 --> 00:19:50.289
so that fits on a slide in the same in
 

00:19:50.289 --> 00:19:52.980
so that fits on a slide in the same in
the same way that in the sense of the

00:19:52.980 --> 00:19:52.990
the same way that in the sense of the
 

00:19:52.990 --> 00:19:54.600
the same way that in the sense of the
old Midas commercial if you remember

00:19:54.600 --> 00:19:54.610
old Midas commercial if you remember
 

00:19:54.610 --> 00:20:01.409
old Midas commercial if you remember
that but I fetched it to fit it on a

00:20:01.409 --> 00:20:01.419
that but I fetched it to fit it on a
 

00:20:01.419 --> 00:20:04.649
that but I fetched it to fit it on a
slide here so what that does is it

00:20:04.649 --> 00:20:04.659
slide here so what that does is it
 

00:20:04.659 --> 00:20:06.570
slide here so what that does is it
introduces a couple of static data

00:20:06.570 --> 00:20:06.580
introduces a couple of static data
 

00:20:06.580 --> 00:20:09.240
introduces a couple of static data
structures one of them is the actual

00:20:09.240 --> 00:20:09.250
structures one of them is the actual
 

00:20:09.250 --> 00:20:11.070
structures one of them is the actual
reference cue which will be used to in

00:20:11.070 --> 00:20:11.080
reference cue which will be used to in
 

00:20:11.080 --> 00:20:14.430
reference cue which will be used to in
cue phantom these PP phantom references

00:20:14.430 --> 00:20:14.440
cue phantom these PP phantom references
 

00:20:14.440 --> 00:20:16.260
cue phantom these PP phantom references
once the corresponding java object is no

00:20:16.260 --> 00:20:16.270
once the corresponding java object is no
 

00:20:16.270 --> 00:20:20.130
once the corresponding java object is no
longer needed and I also have a need to

00:20:20.130 --> 00:20:20.140
longer needed and I also have a need to
 

00:20:20.140 --> 00:20:22.470
longer needed and I also have a need to
have a concurrently accessible set here

00:20:22.470 --> 00:20:22.480
have a concurrently accessible set here
 

00:20:22.480 --> 00:20:25.529
have a concurrently accessible set here
some way to just keep the BP phantom

00:20:25.529 --> 00:20:25.539
some way to just keep the BP phantom
 

00:20:25.539 --> 00:20:27.899
some way to just keep the BP phantom
references around so they don't get

00:20:27.899 --> 00:20:27.909
references around so they don't get
 

00:20:27.909 --> 00:20:30.510
references around so they don't get
garbage collected themselves so I just

00:20:30.510 --> 00:20:30.520
garbage collected themselves so I just
 

00:20:30.520 --> 00:20:33.779
garbage collected themselves so I just
keep those around as long as basically

00:20:33.779 --> 00:20:33.789
keep those around as long as basically
 

00:20:33.789 --> 00:20:37.320
keep those around as long as basically
until they explicitly removed and so

00:20:37.320 --> 00:20:37.330
until they explicitly removed and so
 

00:20:37.330 --> 00:20:42.659
until they explicitly removed and so
what I do then is whenever I whenever I

00:20:42.659 --> 00:20:42.669
what I do then is whenever I whenever I
 

00:20:42.669 --> 00:20:44.610
what I do then is whenever I whenever I
allocate whenever I can select one of

00:20:44.610 --> 00:20:44.620
allocate whenever I can select one of
 

00:20:44.620 --> 00:20:47.460
allocate whenever I can select one of
these PP phantom references I first of

00:20:47.460 --> 00:20:47.470
these PP phantom references I first of
 

00:20:47.470 --> 00:20:49.139
these PP phantom references I first of
all can select the Phantom reference

00:20:49.139 --> 00:20:49.149
all can select the Phantom reference
 

00:20:49.149 --> 00:20:50.880
all can select the Phantom reference
giving it the Java object and the

00:20:50.880 --> 00:20:50.890
giving it the Java object and the
 

00:20:50.890 --> 00:20:53.159
giving it the Java object and the
reference cue so that this helps the

00:20:53.159 --> 00:20:53.169
reference cue so that this helps the
 

00:20:53.169 --> 00:20:54.389
reference cue so that this helps the
underlying phantom reference

00:20:54.389 --> 00:20:54.399
underlying phantom reference
 

00:20:54.399 --> 00:20:57.930
underlying phantom reference
implementation to watch that Java object

00:20:57.930 --> 00:20:57.940
implementation to watch that Java object
 

00:20:57.940 --> 00:20:59.909
implementation to watch that Java object
and put it onto the cue that I gave it

00:20:59.909 --> 00:20:59.919
and put it onto the cue that I gave it
 

00:20:59.919 --> 00:21:04.560
and put it onto the cue that I gave it
when the Java object goes away and then

00:21:04.560 --> 00:21:04.570
when the Java object goes away and then
 

00:21:04.570 --> 00:21:07.049
when the Java object goes away and then
I also remember the native handle so I

00:21:07.049 --> 00:21:07.059
I also remember the native handle so I
 

00:21:07.059 --> 00:21:08.880
I also remember the native handle so I
can actually invoke the allocation

00:21:08.880 --> 00:21:08.890
can actually invoke the allocation
 

00:21:08.890 --> 00:21:12.690
can actually invoke the allocation
function when it's time so what happens

00:21:12.690 --> 00:21:12.700
function when it's time so what happens
 

00:21:12.700 --> 00:21:14.730
function when it's time so what happens
when I register one of these things I

00:21:14.730 --> 00:21:14.740
when I register one of these things I
 

00:21:14.740 --> 00:21:16.380
when I register one of these things I
register Java object and the

00:21:16.380 --> 00:21:16.390
register Java object and the
 

00:21:16.390 --> 00:21:19.860
register Java object and the
corresponding native handle I create a

00:21:19.860 --> 00:21:19.870
corresponding native handle I create a
 

00:21:19.870 --> 00:21:24.269
corresponding native handle I create a
new BP phantom reference and I added to

00:21:24.269 --> 00:21:24.279
new BP phantom reference and I added to
 

00:21:24.279 --> 00:21:26.220
new BP phantom reference and I added to
my set here just to make sure that it

00:21:26.220 --> 00:21:26.230
my set here just to make sure that it
 

00:21:26.230 --> 00:21:30.960
my set here just to make sure that it
doesn't go away and then and this is

00:21:30.960 --> 00:21:30.970
doesn't go away and then and this is
 

00:21:30.970 --> 00:21:32.730
doesn't go away and then and this is
sort of part of the ugliness of the

00:21:32.730 --> 00:21:32.740
sort of part of the ugliness of the
 

00:21:32.740 --> 00:21:34.470
sort of part of the ugliness of the
scheme unfortunately that we're trying

00:21:34.470 --> 00:21:34.480
scheme unfortunately that we're trying
 

00:21:34.480 --> 00:21:37.260
scheme unfortunately that we're trying
to address at some point every once in a

00:21:37.260 --> 00:21:37.270
to address at some point every once in a
 

00:21:37.270 --> 00:21:40.470
to address at some point every once in a
while I I actually need to arrange that

00:21:40.470 --> 00:21:40.480
while I I actually need to arrange that
 

00:21:40.480 --> 00:21:42.120
while I I actually need to arrange that
everything that's on the reference queue

00:21:42.120 --> 00:21:42.130
everything that's on the reference queue
 

00:21:42.130 --> 00:21:44.820
everything that's on the reference queue
gets deleted and I've done that here by

00:21:44.820 --> 00:21:44.830
gets deleted and I've done that here by
 

00:21:44.830 --> 00:21:48.120
gets deleted and I've done that here by
providing a method do deletes which just

00:21:48.120 --> 00:21:48.130
providing a method do deletes which just
 

00:21:48.130 --> 00:21:49.889
providing a method do deletes which just
checks whether there's anything

00:21:49.889 --> 00:21:49.899
checks whether there's anything
 

00:21:49.899 --> 00:21:53.190
checks whether there's anything
available for deletion and if so it goes

00:21:53.190 --> 00:21:53.200
available for deletion and if so it goes
 

00:21:53.200 --> 00:21:57.240
available for deletion and if so it goes
ahead and deletes that in other context

00:21:57.240 --> 00:21:57.250
ahead and deletes that in other context
 

00:21:57.250 --> 00:21:58.770
ahead and deletes that in other context
you may want to do this differently

00:21:58.770 --> 00:21:58.780
you may want to do this differently
 

00:21:58.780 --> 00:21:59.860
you may want to do this differently
rather than

00:21:59.860 --> 00:21:59.870
rather than
 

00:21:59.870 --> 00:22:01.210
rather than
just polling whether something is

00:22:01.210 --> 00:22:01.220
just polling whether something is
 

00:22:01.220 --> 00:22:02.680
just polling whether something is
available you may actually want to

00:22:02.680 --> 00:22:02.690
available you may actually want to
 

00:22:02.690 --> 00:22:05.410
available you may actually want to
template fed for this and block it sort

00:22:05.410 --> 00:22:05.420
template fed for this and block it sort
 

00:22:05.420 --> 00:22:07.720
template fed for this and block it sort
of depends on the context it's a little

00:22:07.720 --> 00:22:07.730
of depends on the context it's a little
 

00:22:07.730 --> 00:22:10.780
of depends on the context it's a little
bit tricky here to do this well in a

00:22:10.780 --> 00:22:10.790
bit tricky here to do this well in a
 

00:22:10.790 --> 00:22:13.840
bit tricky here to do this well in a
loft system because the easy way to do

00:22:13.840 --> 00:22:13.850
loft system because the easy way to do
 

00:22:13.850 --> 00:22:15.520
loft system because the easy way to do
this is to create a new thread for every

00:22:15.520 --> 00:22:15.530
this is to create a new thread for every
 

00:22:15.530 --> 00:22:17.170
this is to create a new thread for every
class that does this which may or may

00:22:17.170 --> 00:22:17.180
class that does this which may or may
 

00:22:17.180 --> 00:22:18.640
class that does this which may or may
not be acceptable depending on how many

00:22:18.640 --> 00:22:18.650
not be acceptable depending on how many
 

00:22:18.650 --> 00:22:26.230
not be acceptable depending on how many
of these you have so then in order to

00:22:26.230 --> 00:22:26.240
of these you have so then in order to
 

00:22:26.240 --> 00:22:28.660
of these you have so then in order to
actually make this work my application

00:22:28.660 --> 00:22:28.670
actually make this work my application
 

00:22:28.670 --> 00:22:30.450
actually make this work my application
needs to do the following things

00:22:30.450 --> 00:22:30.460
needs to do the following things
 

00:22:30.460 --> 00:22:33.220
needs to do the following things
periodically in simple cases you can

00:22:33.220 --> 00:22:33.230
periodically in simple cases you can
 

00:22:33.230 --> 00:22:35.260
periodically in simple cases you can
skip the system GC and system dot run

00:22:35.260 --> 00:22:35.270
skip the system GC and system dot run
 

00:22:35.270 --> 00:22:37.210
skip the system GC and system dot run
finalization if you notice that the

00:22:37.210 --> 00:22:37.220
finalization if you notice that the
 

00:22:37.220 --> 00:22:38.740
finalization if you notice that the
garbage collector isn't running enough

00:22:38.740 --> 00:22:38.750
garbage collector isn't running enough
 

00:22:38.750 --> 00:22:40.180
garbage collector isn't running enough
because you're not allocating enough

00:22:40.180 --> 00:22:40.190
because you're not allocating enough
 

00:22:40.190 --> 00:22:41.799
because you're not allocating enough
Java objects in order to actually

00:22:41.799 --> 00:22:41.809
Java objects in order to actually
 

00:22:41.809 --> 00:22:44.290
Java objects in order to actually
trigger it you may have to explicitly do

00:22:44.290 --> 00:22:44.300
trigger it you may have to explicitly do
 

00:22:44.300 --> 00:22:47.260
trigger it you may have to explicitly do
that but usually that's not an issue but

00:22:47.260 --> 00:22:47.270
that but usually that's not an issue but
 

00:22:47.270 --> 00:22:49.510
that but usually that's not an issue but
you do have to regularly call BP plan

00:22:49.510 --> 00:22:49.520
you do have to regularly call BP plan
 

00:22:49.520 --> 00:22:50.980
you do have to regularly call BP plan
time reference not do deletes to

00:22:50.980 --> 00:22:50.990
time reference not do deletes to
 

00:22:50.990 --> 00:22:53.020
time reference not do deletes to
actually do the cleanup the way I've

00:22:53.020 --> 00:22:53.030
actually do the cleanup the way I've
 

00:22:53.030 --> 00:22:58.330
actually do the cleanup the way I've
done things here so the next problem

00:22:58.330 --> 00:22:58.340
done things here so the next problem
 

00:22:58.340 --> 00:23:01.799
done things here so the next problem
here that I that I mentioned is the

00:23:01.799 --> 00:23:01.809
here that I that I mentioned is the
 

00:23:01.809 --> 00:23:04.299
here that I that I mentioned is the
premature and queuing while a method is

00:23:04.299 --> 00:23:04.309
premature and queuing while a method is
 

00:23:04.309 --> 00:23:08.470
premature and queuing while a method is
still running as I said this is not

00:23:08.470 --> 00:23:08.480
still running as I said this is not
 

00:23:08.480 --> 00:23:10.419
still running as I said this is not
actually an issue for Android but it is

00:23:10.419 --> 00:23:10.429
actually an issue for Android but it is
 

00:23:10.429 --> 00:23:14.290
actually an issue for Android but it is
an issue for portable code so there's a

00:23:14.290 --> 00:23:14.300
an issue for portable code so there's a
 

00:23:14.300 --> 00:23:16.990
an issue for portable code so there's a
partial solution to this in actually in

00:23:16.990 --> 00:23:17.000
partial solution to this in actually in
 

00:23:17.000 --> 00:23:20.140
partial solution to this in actually in
Java 9 which is this thing called a

00:23:20.140 --> 00:23:20.150
Java 9 which is this thing called a
 

00:23:20.150 --> 00:23:21.730
Java 9 which is this thing called a
teachability fence which you can

00:23:21.730 --> 00:23:21.740
teachability fence which you can
 

00:23:21.740 --> 00:23:23.530
teachability fence which you can
explicitly invoke to tell the

00:23:23.530 --> 00:23:23.540
explicitly invoke to tell the
 

00:23:23.540 --> 00:23:26.110
explicitly invoke to tell the
implementation don't let the argument go

00:23:26.110 --> 00:23:26.120
implementation don't let the argument go
 

00:23:26.120 --> 00:23:28.210
implementation don't let the argument go
away yet it's still live to the should

00:23:28.210 --> 00:23:28.220
away yet it's still live to the should
 

00:23:28.220 --> 00:23:29.650
away yet it's still live to the should
still be live to the garbage collector

00:23:29.650 --> 00:23:29.660
still be live to the garbage collector
 

00:23:29.660 --> 00:23:31.390
still be live to the garbage collector
even though it might not look it might

00:23:31.390 --> 00:23:31.400
even though it might not look it might
 

00:23:31.400 --> 00:23:33.910
even though it might not look it might
not look like it and that's not really

00:23:33.910 --> 00:23:33.920
not look like it and that's not really
 

00:23:33.920 --> 00:23:35.470
not look like it and that's not really
available basically in any

00:23:35.470 --> 00:23:35.480
available basically in any
 

00:23:35.480 --> 00:23:37.090
available basically in any
implementation that you can use at the

00:23:37.090 --> 00:23:37.100
implementation that you can use at the
 

00:23:37.100 --> 00:23:40.000
implementation that you can use at the
moment so the best solution that my

00:23:40.000 --> 00:23:40.010
moment so the best solution that my
 

00:23:40.010 --> 00:23:41.650
moment so the best solution that my
colleagues and I could come up with at

00:23:41.650 --> 00:23:41.660
colleagues and I could come up with at
 

00:23:41.660 --> 00:23:45.250
colleagues and I could come up with at
the moment is the following which is

00:23:45.250 --> 00:23:45.260
the moment is the following which is
 

00:23:45.260 --> 00:23:47.020
the moment is the following which is
relatively simple but not exactly

00:23:47.020 --> 00:23:47.030
relatively simple but not exactly
 

00:23:47.030 --> 00:23:51.549
relatively simple but not exactly
performance neutral is that is that

00:23:51.549 --> 00:23:51.559
performance neutral is that is that
 

00:23:51.559 --> 00:23:54.820
performance neutral is that is that
instead of having simple methods like

00:23:54.820 --> 00:23:54.830
instead of having simple methods like
 

00:23:54.830 --> 00:23:56.980
instead of having simple methods like
multiply that just invoked the native

00:23:56.980 --> 00:23:56.990
multiply that just invoked the native
 

00:23:56.990 --> 00:23:59.350
multiply that just invoked the native
method with the native handles what we

00:23:59.350 --> 00:23:59.360
method with the native handles what we
 

00:23:59.360 --> 00:24:01.330
method with the native handles what we
do instead is we invoke the native

00:24:01.330 --> 00:24:01.340
do instead is we invoke the native
 

00:24:01.340 --> 00:24:03.580
do instead is we invoke the native
method with both the native handles and

00:24:03.580 --> 00:24:03.590
method with both the native handles and
 

00:24:03.590 --> 00:24:08.440
method with both the native handles and
the java object so what I do instead is

00:24:08.440 --> 00:24:08.450
the java object so what I do instead is
 

00:24:08.450 --> 00:24:10.510
the java object so what I do instead is
I have a native multiply that takes the

00:24:10.510 --> 00:24:10.520
I have a native multiply that takes the
 

00:24:10.520 --> 00:24:13.280
I have a native multiply that takes the
2j object as well

00:24:13.280 --> 00:24:13.290
2j object as well
 

00:24:13.290 --> 00:24:15.350
2j object as well
and current implementations though the

00:24:15.350 --> 00:24:15.360
and current implementations though the
 

00:24:15.360 --> 00:24:18.260
and current implementations though the
spec doesn't 100% guarantee that current

00:24:18.260 --> 00:24:18.270
spec doesn't 100% guarantee that current
 

00:24:18.270 --> 00:24:19.700
spec doesn't 100% guarantee that current
implementations are essentially

00:24:19.700 --> 00:24:19.710
implementations are essentially
 

00:24:19.710 --> 00:24:21.500
implementations are essentially
essentially guarantee that this and

00:24:21.500 --> 00:24:21.510
essentially guarantee that this and
 

00:24:21.510 --> 00:24:23.240
essentially guarantee that this and
other turns into a local graph which

00:24:23.240 --> 00:24:23.250
other turns into a local graph which
 

00:24:23.250 --> 00:24:26.000
other turns into a local graph which
tells the garbage collector to keep

00:24:26.000 --> 00:24:26.010
tells the garbage collector to keep
 

00:24:26.010 --> 00:24:28.130
tells the garbage collector to keep
these around as long as the native

00:24:28.130 --> 00:24:28.140
these around as long as the native
 

00:24:28.140 --> 00:24:29.960
these around as long as the native
method is running so things will

00:24:29.960 --> 00:24:29.970
method is running so things will
 

00:24:29.970 --> 00:24:31.340
method is running so things will
actually work out correctly at the

00:24:31.340 --> 00:24:31.350
actually work out correctly at the
 

00:24:31.350 --> 00:24:33.470
actually work out correctly at the
expense of passing additional parameters

00:24:33.470 --> 00:24:33.480
expense of passing additional parameters
 

00:24:33.480 --> 00:24:38.390
expense of passing additional parameters
to J&amp;I again this is recommended if you

00:24:38.390 --> 00:24:38.400
to J&amp;I again this is recommended if you
 

00:24:38.400 --> 00:24:40.460
to J&amp;I again this is recommended if you
have to write for if you write portable

00:24:40.460 --> 00:24:40.470
have to write for if you write portable
 

00:24:40.470 --> 00:24:43.490
have to write for if you write portable
code for Android I currently wouldn't

00:24:43.490 --> 00:24:43.500
code for Android I currently wouldn't
 

00:24:43.500 --> 00:24:45.530
code for Android I currently wouldn't
recommend doing that eventually sometime

00:24:45.530 --> 00:24:45.540
recommend doing that eventually sometime
 

00:24:45.540 --> 00:24:46.820
recommend doing that eventually sometime
in the future I think we'll have a

00:24:46.820 --> 00:24:46.830
in the future I think we'll have a
 

00:24:46.830 --> 00:24:48.410
in the future I think we'll have a
better we will probably have a better

00:24:48.410 --> 00:24:48.420
better we will probably have a better
 

00:24:48.420 --> 00:24:58.370
better we will probably have a better
solution to this so one more hazard that

00:24:58.370 --> 00:24:58.380
solution to this so one more hazard that
 

00:24:58.380 --> 00:25:00.680
solution to this so one more hazard that
I want to go over quickly in pulse

00:25:00.680 --> 00:25:00.690
I want to go over quickly in pulse
 

00:25:00.690 --> 00:25:04.850
I want to go over quickly in pulse
because this actually this is near and

00:25:04.850 --> 00:25:04.860
because this actually this is near and
 

00:25:04.860 --> 00:25:07.220
because this actually this is near and
dear to my heart because it sort of took

00:25:07.220 --> 00:25:07.230
dear to my heart because it sort of took
 

00:25:07.230 --> 00:25:08.990
dear to my heart because it sort of took
several months of several people's time

00:25:08.990 --> 00:25:09.000
several months of several people's time
 

00:25:09.000 --> 00:25:11.480
several months of several people's time
to debug platform code that had this

00:25:11.480 --> 00:25:11.490
to debug platform code that had this
 

00:25:11.490 --> 00:25:14.420
to debug platform code that had this
issue if you're using C++ code in this

00:25:14.420 --> 00:25:14.430
issue if you're using C++ code in this
 

00:25:14.430 --> 00:25:16.910
issue if you're using C++ code in this
way you need to be really careful that

00:25:16.910 --> 00:25:16.920
way you need to be really careful that
 

00:25:16.920 --> 00:25:18.710
way you need to be really careful that
you're actually calling it correctly and

00:25:18.710 --> 00:25:18.720
you're actually calling it correctly and
 

00:25:18.720 --> 00:25:20.960
you're actually calling it correctly and
not violating the C++ levels underneath

00:25:20.960 --> 00:25:20.970
not violating the C++ levels underneath
 

00:25:20.970 --> 00:25:23.300
not violating the C++ levels underneath
and that can be quite tricky to do

00:25:23.300 --> 00:25:23.310
and that can be quite tricky to do
 

00:25:23.310 --> 00:25:26.210
and that can be quite tricky to do
correctly so in particular if you're

00:25:26.210 --> 00:25:26.220
correctly so in particular if you're
 

00:25:26.220 --> 00:25:28.670
correctly so in particular if you're
calling C++ code from Java sets it still

00:25:28.670 --> 00:25:28.680
calling C++ code from Java sets it still
 

00:25:28.680 --> 00:25:30.230
calling C++ code from Java sets it still
has to be fed safe as though you were

00:25:30.230 --> 00:25:30.240
has to be fed safe as though you were
 

00:25:30.240 --> 00:25:34.640
has to be fed safe as though you were
calling it for multiple C++ beds and you

00:25:34.640 --> 00:25:34.650
calling it for multiple C++ beds and you
 

00:25:34.650 --> 00:25:35.780
calling it for multiple C++ beds and you
have to make sure to follow those rules

00:25:35.780 --> 00:25:35.790
have to make sure to follow those rules
 

00:25:35.790 --> 00:25:38.030
have to make sure to follow those rules
this is a bit aggravated by the fact

00:25:38.030 --> 00:25:38.040
this is a bit aggravated by the fact
 

00:25:38.040 --> 00:25:40.550
this is a bit aggravated by the fact
that some some android framework classes

00:25:40.550 --> 00:25:40.560
that some some android framework classes
 

00:25:40.560 --> 00:25:43.640
that some some android framework classes
actually use C++ code internally so this

00:25:43.640 --> 00:25:43.650
actually use C++ code internally so this
 

00:25:43.650 --> 00:25:45.290
actually use C++ code internally so this
gets back to the point I was making at

00:25:45.290 --> 00:25:45.300
gets back to the point I was making at
 

00:25:45.300 --> 00:25:47.690
gets back to the point I was making at
the beginning that you have to make sure

00:25:47.690 --> 00:25:47.700
the beginning that you have to make sure
 

00:25:47.700 --> 00:25:49.340
the beginning that you have to make sure
to use those frameworks classes

00:25:49.340 --> 00:25:49.350
to use those frameworks classes
 

00:25:49.350 --> 00:25:50.840
to use those frameworks classes
correctly because otherwise you can run

00:25:50.840 --> 00:25:50.850
correctly because otherwise you can run
 

00:25:50.850 --> 00:25:52.850
correctly because otherwise you can run
into this problem even without actually

00:25:52.850 --> 00:25:52.860
into this problem even without actually
 

00:25:52.860 --> 00:25:58.010
into this problem even without actually
writing native code and one particular

00:25:58.010 --> 00:25:58.020
writing native code and one particular
 

00:25:58.020 --> 00:26:00.110
writing native code and one particular
issue one issue that's particularly

00:26:00.110 --> 00:26:00.120
issue one issue that's particularly
 

00:26:00.120 --> 00:26:02.930
issue one issue that's particularly
subtle on the C++ side that actually

00:26:02.930 --> 00:26:02.940
subtle on the C++ side that actually
 

00:26:02.940 --> 00:26:04.790
subtle on the C++ side that actually
contributed to this problem that we

00:26:04.790 --> 00:26:04.800
contributed to this problem that we
 

00:26:04.800 --> 00:26:08.390
contributed to this problem that we
spend lots of time on is that often on

00:26:08.390 --> 00:26:08.400
spend lots of time on is that often on
 

00:26:08.400 --> 00:26:10.730
spend lots of time on is that often on
the C++ side when you call the leaf you

00:26:10.730 --> 00:26:10.740
the C++ side when you call the leaf you
 

00:26:10.740 --> 00:26:12.620
the C++ side when you call the leaf you
actually end up invoking some reference

00:26:12.620 --> 00:26:12.630
actually end up invoking some reference
 

00:26:12.630 --> 00:26:14.450
actually end up invoking some reference
counting mechanism that then takes care

00:26:14.450 --> 00:26:14.460
counting mechanism that then takes care
 

00:26:14.460 --> 00:26:16.520
counting mechanism that then takes care
of the underlying C++ objects that I

00:26:16.520 --> 00:26:16.530
of the underlying C++ objects that I
 

00:26:16.530 --> 00:26:20.930
of the underlying C++ objects that I
indirectly reference you have to be you

00:26:20.930 --> 00:26:20.940
indirectly reference you have to be you
 

00:26:20.940 --> 00:26:22.880
indirectly reference you have to be you
have to be really careful in that doing

00:26:22.880 --> 00:26:22.890
have to be really careful in that doing
 

00:26:22.890 --> 00:26:23.960
have to be really careful in that doing
that correctly

00:26:23.960 --> 00:26:23.970
that correctly
 

00:26:23.970 --> 00:26:26.899
that correctly
I highly recommend using an expert

00:26:26.899 --> 00:26:26.909
I highly recommend using an expert
 

00:26:26.909 --> 00:26:29.180
I highly recommend using an expert
developed implementation of reference

00:26:29.180 --> 00:26:29.190
developed implementation of reference
 

00:26:29.190 --> 00:26:31.850
developed implementation of reference
counting not to all your own I spend a

00:26:31.850 --> 00:26:31.860
counting not to all your own I spend a
 

00:26:31.860 --> 00:26:33.769
counting not to all your own I spend a
lot of time recently fixing bugs in

00:26:33.769 --> 00:26:33.779
lot of time recently fixing bugs in
 

00:26:33.779 --> 00:26:35.360
lot of time recently fixing bugs in
Android platform reference counting

00:26:35.360 --> 00:26:35.370
Android platform reference counting
 

00:26:35.370 --> 00:26:39.980
Android platform reference counting
implementations so it's not too likely I

00:26:39.980 --> 00:26:39.990
implementations so it's not too likely I
 

00:26:39.990 --> 00:26:41.779
implementations so it's not too likely I
think that most people will get this

00:26:41.779 --> 00:26:41.789
think that most people will get this
 

00:26:41.789 --> 00:26:44.779
think that most people will get this
right implementing it themselves there

00:26:44.779 --> 00:26:44.789
right implementing it themselves there
 

00:26:44.789 --> 00:26:46.340
right implementing it themselves there
are whole bunch of different issues here

00:26:46.340 --> 00:26:46.350
are whole bunch of different issues here
 

00:26:46.350 --> 00:26:48.200
are whole bunch of different issues here
having to do with memory ordering bugs

00:26:48.200 --> 00:26:48.210
having to do with memory ordering bugs
 

00:26:48.210 --> 00:26:51.110
having to do with memory ordering bugs
and self assignments and so on it only

00:26:51.110 --> 00:26:51.120
and self assignments and so on it only
 

00:26:51.120 --> 00:26:53.840
and self assignments and so on it only
is this tiny amount of code but it's a

00:26:53.840 --> 00:26:53.850
is this tiny amount of code but it's a
 

00:26:53.850 --> 00:26:59.690
is this tiny amount of code but it's a
really tricky tricky piece of code but

00:26:59.690 --> 00:26:59.700
really tricky tricky piece of code but
 

00:26:59.700 --> 00:27:00.950
really tricky tricky piece of code but
assuming you have a correct reference

00:27:00.950 --> 00:27:00.960
assuming you have a correct reference
 

00:27:00.960 --> 00:27:03.680
assuming you have a correct reference
counting implementation it's still hard

00:27:03.680 --> 00:27:03.690
counting implementation it's still hard
 

00:27:03.690 --> 00:27:06.980
counting implementation it's still hard
to use it correctly so one thing you

00:27:06.980 --> 00:27:06.990
to use it correctly so one thing you
 

00:27:06.990 --> 00:27:08.629
to use it correctly so one thing you
have to remember for something like the

00:27:08.629 --> 00:27:08.639
have to remember for something like the
 

00:27:08.639 --> 00:27:10.250
have to remember for something like the
walls vary a little bit depending on the

00:27:10.250 --> 00:27:10.260
walls vary a little bit depending on the
 

00:27:10.260 --> 00:27:11.750
walls vary a little bit depending on the
implementation but for something like

00:27:11.750 --> 00:27:11.760
implementation but for something like
 

00:27:11.760 --> 00:27:13.370
implementation but for something like
stitch footer

00:27:13.370 --> 00:27:13.380
stitch footer
 

00:27:13.380 --> 00:27:15.409
stitch footer
when you create your shell put it to

00:27:15.409 --> 00:27:15.419
when you create your shell put it to
 

00:27:15.419 --> 00:27:19.399
when you create your shell put it to
something the object will will be

00:27:19.399 --> 00:27:19.409
something the object will will be
 

00:27:19.409 --> 00:27:21.409
something the object will will be
de-allocated when the reference counts

00:27:21.409 --> 00:27:21.419
de-allocated when the reference counts
 

00:27:21.419 --> 00:27:23.539
de-allocated when the reference counts
associated with copies of that shared

00:27:23.539 --> 00:27:23.549
associated with copies of that shared
 

00:27:23.549 --> 00:27:26.269
associated with copies of that shared
Potter goes to zero so creating multiple

00:27:26.269 --> 00:27:26.279
Potter goes to zero so creating multiple
 

00:27:26.279 --> 00:27:29.480
Potter goes to zero so creating multiple
shell footers to the same underlying to

00:27:29.480 --> 00:27:29.490
shell footers to the same underlying to
 

00:27:29.490 --> 00:27:31.250
shell footers to the same underlying to
the same corresponding to the same

00:27:31.250 --> 00:27:31.260
the same corresponding to the same
 

00:27:31.260 --> 00:27:33.980
the same corresponding to the same
underlying bare pointer it's not likely

00:27:33.980 --> 00:27:33.990
underlying bare pointer it's not likely
 

00:27:33.990 --> 00:27:37.460
underlying bare pointer it's not likely
to work well it's also not likely to

00:27:37.460 --> 00:27:37.470
to work well it's also not likely to
 

00:27:37.470 --> 00:27:39.139
to work well it's also not likely to
work well to generate a reference

00:27:39.139 --> 00:27:39.149
work well to generate a reference
 

00:27:39.149 --> 00:27:40.789
work well to generate a reference
counter pointer to this and they can

00:27:40.789 --> 00:27:40.799
counter pointer to this and they can
 

00:27:40.799 --> 00:27:42.620
counter pointer to this and they can
selectively for similar sort of reason

00:27:42.620 --> 00:27:42.630
selectively for similar sort of reason
 

00:27:42.630 --> 00:27:44.720
selectively for similar sort of reason
because probably by the time you leave

00:27:44.720 --> 00:27:44.730
because probably by the time you leave
 

00:27:44.730 --> 00:27:46.370
because probably by the time you leave
the constructor that reference count

00:27:46.370 --> 00:27:46.380
the constructor that reference count
 

00:27:46.380 --> 00:27:47.750
the constructor that reference count
will have gone to zero and you will be

00:27:47.750 --> 00:27:47.760
will have gone to zero and you will be
 

00:27:47.760 --> 00:27:49.129
will have gone to zero and you will be
allocate the object before you ever

00:27:49.129 --> 00:27:49.139
allocate the object before you ever
 

00:27:49.139 --> 00:27:50.779
allocate the object before you ever
leave the constructor which is not good

00:27:50.779 --> 00:27:50.789
leave the constructor which is not good
 

00:27:50.789 --> 00:27:53.330
leave the constructor which is not good
so you have to be careful with that sort

00:27:53.330 --> 00:27:53.340
so you have to be careful with that sort
 

00:27:53.340 --> 00:27:57.019
so you have to be careful with that sort
of thing the dead safety walls are in

00:27:57.019 --> 00:27:57.029
of thing the dead safety walls are in
 

00:27:57.029 --> 00:27:59.600
of thing the dead safety walls are in
some ways even more subtle and something

00:27:59.600 --> 00:27:59.610
some ways even more subtle and something
 

00:27:59.610 --> 00:28:01.399
some ways even more subtle and something
and also something that you really want

00:28:01.399 --> 00:28:01.409
and also something that you really want
 

00:28:01.409 --> 00:28:02.889
and also something that you really want
to watch out for

00:28:02.889 --> 00:28:02.899
to watch out for
 

00:28:02.899 --> 00:28:05.840
to watch out for
so assuming here I have a bunch of

00:28:05.840 --> 00:28:05.850
so assuming here I have a bunch of
 

00:28:05.850 --> 00:28:10.360
so assuming here I have a bunch of
shared photos it's actually okay

00:28:10.360 --> 00:28:10.370
shared photos it's actually okay
 

00:28:10.370 --> 00:28:13.039
shared photos it's actually okay
according to the normal C++ thread

00:28:13.039 --> 00:28:13.049
according to the normal C++ thread
 

00:28:13.049 --> 00:28:16.789
according to the normal C++ thread
safety rules if I take X the shell put X

00:28:16.789 --> 00:28:16.799
safety rules if I take X the shell put X
 

00:28:16.799 --> 00:28:19.370
safety rules if I take X the shell put X
and copy it simultaneously in two

00:28:19.370 --> 00:28:19.380
and copy it simultaneously in two
 

00:28:19.380 --> 00:28:21.769
and copy it simultaneously in two
different threads to two different other

00:28:21.769 --> 00:28:21.779
different threads to two different other
 

00:28:21.779 --> 00:28:24.440
different threads to two different other
pointers this will tie to simultaneously

00:28:24.440 --> 00:28:24.450
pointers this will tie to simultaneously
 

00:28:24.450 --> 00:28:26.330
pointers this will tie to simultaneously
update the reference count associated

00:28:26.330 --> 00:28:26.340
update the reference count associated
 

00:28:26.340 --> 00:28:28.250
update the reference count associated
with X but that's okay it's the

00:28:28.250 --> 00:28:28.260
with X but that's okay it's the
 

00:28:28.260 --> 00:28:29.990
with X but that's okay it's the
implementations job to make sure that

00:28:29.990 --> 00:28:30.000
implementations job to make sure that
 

00:28:30.000 --> 00:28:32.779
implementations job to make sure that
that works correctly so that's that's

00:28:32.779 --> 00:28:32.789
that works correctly so that's that's
 

00:28:32.789 --> 00:28:35.690
that works correctly so that's that's
fine what's not fine and what in fact

00:28:35.690 --> 00:28:35.700
fine what's not fine and what in fact
 

00:28:35.700 --> 00:28:37.460
fine what's not fine and what in fact
calls the sort of law

00:28:37.460 --> 00:28:37.470
calls the sort of law
 

00:28:37.470 --> 00:28:39.260
calls the sort of law
extending bugs that we have to deal with

00:28:39.260 --> 00:28:39.270
extending bugs that we have to deal with
 

00:28:39.270 --> 00:28:42.520
extending bugs that we have to deal with
here is the last thing on the slide here

00:28:42.520 --> 00:28:42.530
here is the last thing on the slide here
 

00:28:42.530 --> 00:28:44.750
here is the last thing on the slide here
simultaneous assignments to the same

00:28:44.750 --> 00:28:44.760
simultaneous assignments to the same
 

00:28:44.760 --> 00:28:46.880
simultaneous assignments to the same
reference counted pointers if I

00:28:46.880 --> 00:28:46.890
reference counted pointers if I
 

00:28:46.890 --> 00:28:49.220
reference counted pointers if I
simultaneously assign even null to the

00:28:49.220 --> 00:28:49.230
simultaneously assign even null to the
 

00:28:49.230 --> 00:28:51.110
simultaneously assign even null to the
same reference counted pointer that

00:28:51.110 --> 00:28:51.120
same reference counted pointer that
 

00:28:51.120 --> 00:28:52.880
same reference counted pointer that
looks pretty benign I'm assigning the

00:28:52.880 --> 00:28:52.890
looks pretty benign I'm assigning the
 

00:28:52.890 --> 00:28:54.590
looks pretty benign I'm assigning the
same thing concurrently to two different

00:28:54.590 --> 00:28:54.600
same thing concurrently to two different
 

00:28:54.600 --> 00:28:56.810
same thing concurrently to two different
threads which what could go wrong the

00:28:56.810 --> 00:28:56.820
threads which what could go wrong the
 

00:28:56.820 --> 00:28:59.690
threads which what could go wrong the
problem is its disallowed by C++ rules

00:28:59.690 --> 00:28:59.700
problem is its disallowed by C++ rules
 

00:28:59.700 --> 00:29:01.520
problem is its disallowed by C++ rules
for good reason because what happens

00:29:01.520 --> 00:29:01.530
for good reason because what happens
 

00:29:01.530 --> 00:29:04.039
for good reason because what happens
here is both threads will try to

00:29:04.039 --> 00:29:04.049
here is both threads will try to
 

00:29:04.049 --> 00:29:07.430
here is both threads will try to
simultaneously the allocated decremented

00:29:07.430 --> 00:29:07.440
simultaneously the allocated decremented
 

00:29:07.440 --> 00:29:10.070
simultaneously the allocated decremented
reference count associated with the

00:29:10.070 --> 00:29:10.080
reference count associated with the
 

00:29:10.080 --> 00:29:13.490
reference count associated with the
original value of P if they race each

00:29:13.490 --> 00:29:13.500
original value of P if they race each
 

00:29:13.500 --> 00:29:16.039
original value of P if they race each
other just right so they both do this

00:29:16.039 --> 00:29:16.049
other just right so they both do this
 

00:29:16.049 --> 00:29:18.740
other just right so they both do this
before either one actually assigns no to

00:29:18.740 --> 00:29:18.750
before either one actually assigns no to
 

00:29:18.750 --> 00:29:20.659
before either one actually assigns no to
the pointer they will end up both

00:29:20.659 --> 00:29:20.669
the pointer they will end up both
 

00:29:20.669 --> 00:29:22.820
the pointer they will end up both
decrementing the reference count which

00:29:22.820 --> 00:29:22.830
decrementing the reference count which
 

00:29:22.830 --> 00:29:25.159
decrementing the reference count which
was originally had a value of 1 because

00:29:25.159 --> 00:29:25.169
was originally had a value of 1 because
 

00:29:25.169 --> 00:29:29.600
was originally had a value of 1 because
it was referenced by P that doesn't go

00:29:29.600 --> 00:29:29.610
it was referenced by P that doesn't go
 

00:29:29.610 --> 00:29:32.000
it was referenced by P that doesn't go
well in the excellent reference count

00:29:32.000 --> 00:29:32.010
well in the excellent reference count
 

00:29:32.010 --> 00:29:39.159
well in the excellent reference count
that Commander's is always there so

00:29:39.159 --> 00:29:39.169
 
 

00:29:39.169 --> 00:29:43.399
 
summarizing here important point is

00:29:43.399 --> 00:29:43.409
summarizing here important point is
 

00:29:43.409 --> 00:29:47.779
summarizing here important point is
avoid finalization use java.lang that

00:29:47.779 --> 00:29:47.789
avoid finalization use java.lang that
 

00:29:47.789 --> 00:29:50.659
avoid finalization use java.lang that
phantom reference instead currently

00:29:50.659 --> 00:29:50.669
phantom reference instead currently
 

00:29:50.669 --> 00:29:52.760
phantom reference instead currently
that's a little bit clumsy but it boyd's

00:29:52.760 --> 00:29:52.770
that's a little bit clumsy but it boyd's
 

00:29:52.770 --> 00:29:54.169
that's a little bit clumsy but it boyd's
you also the source of potential

00:29:54.169 --> 00:29:54.179
you also the source of potential
 

00:29:54.179 --> 00:29:58.340
you also the source of potential
headaches it's if you want to read up on

00:29:58.340 --> 00:29:58.350
headaches it's if you want to read up on
 

00:29:58.350 --> 00:30:00.919
headaches it's if you want to read up on
this more I suggest you actually look up

00:30:00.919 --> 00:30:00.929
this more I suggest you actually look up
 

00:30:00.929 --> 00:30:03.909
this more I suggest you actually look up
the the Java 9 reach ability fence

00:30:03.909 --> 00:30:03.919
the the Java 9 reach ability fence
 

00:30:03.919 --> 00:30:06.380
the the Java 9 reach ability fence
contact and discussion that'll give you

00:30:06.380 --> 00:30:06.390
contact and discussion that'll give you
 

00:30:06.390 --> 00:30:08.830
contact and discussion that'll give you
a little more insight as to why this is

00:30:08.830 --> 00:30:08.840
a little more insight as to why this is
 

00:30:08.840 --> 00:30:11.480
a little more insight as to why this is
why some of these things are problem and

00:30:11.480 --> 00:30:11.490
why some of these things are problem and
 

00:30:11.490 --> 00:30:13.000
why some of these things are problem and
particular why you have to worry about

00:30:13.000 --> 00:30:13.010
particular why you have to worry about
 

00:30:13.010 --> 00:30:16.820
particular why you have to worry about
premature premature cleanup with the

00:30:16.820 --> 00:30:16.830
premature premature cleanup with the
 

00:30:16.830 --> 00:30:18.950
premature premature cleanup with the
Java semantics again not so much on

00:30:18.950 --> 00:30:18.960
Java semantics again not so much on
 

00:30:18.960 --> 00:30:22.340
Java semantics again not so much on
Android and then stay tuned for future

00:30:22.340 --> 00:30:22.350
Android and then stay tuned for future
 

00:30:22.350 --> 00:30:26.990
Android and then stay tuned for future
improvements in this area here if you

00:30:26.990 --> 00:30:27.000
improvements in this area here if you
 

00:30:27.000 --> 00:30:29.810
improvements in this area here if you
allocate a lot of C++ objects if that's

00:30:29.810 --> 00:30:29.820
allocate a lot of C++ objects if that's
 

00:30:29.820 --> 00:30:31.850
allocate a lot of C++ objects if that's
where most of your heat space ends up

00:30:31.850 --> 00:30:31.860
where most of your heat space ends up
 

00:30:31.860 --> 00:30:33.380
where most of your heat space ends up
getting spent then you should think

00:30:33.380 --> 00:30:33.390
getting spent then you should think
 

00:30:33.390 --> 00:30:36.260
getting spent then you should think
about explicit DC triggering but doing

00:30:36.260 --> 00:30:36.270
about explicit DC triggering but doing
 

00:30:36.270 --> 00:30:37.730
about explicit DC triggering but doing
it really carefully make sure you keep

00:30:37.730 --> 00:30:37.740
it really carefully make sure you keep
 

00:30:37.740 --> 00:30:39.740
it really carefully make sure you keep
track of how much C++ memory you've

00:30:39.740 --> 00:30:39.750
track of how much C++ memory you've
 

00:30:39.750 --> 00:30:41.840
track of how much C++ memory you've
allocated and when you've allocated a

00:30:41.840 --> 00:30:41.850
allocated and when you've allocated a
 

00:30:41.850 --> 00:30:44.570
allocated and when you've allocated a
lot so you think it might be useful then

00:30:44.570 --> 00:30:44.580
lot so you think it might be useful then
 

00:30:44.580 --> 00:30:47.090
lot so you think it might be useful then
you can invoke the garbage collector so

00:30:47.090 --> 00:30:47.100
you can invoke the garbage collector so
 

00:30:47.100 --> 00:30:49.520
you can invoke the garbage collector so
phantom references for dead objects

00:30:49.520 --> 00:30:49.530
phantom references for dead objects
 

00:30:49.530 --> 00:30:50.820
phantom references for dead objects
getting queued at that point

00:30:50.820 --> 00:30:50.830
getting queued at that point
 

00:30:50.830 --> 00:30:52.889
getting queued at that point
you can actually do the C++ cleanup at

00:30:52.889 --> 00:30:52.899
you can actually do the C++ cleanup at
 

00:30:52.899 --> 00:30:55.230
you can actually do the C++ cleanup at
that point otherwise if you know how not

00:30:55.230 --> 00:30:55.240
that point otherwise if you know how not
 

00:30:55.240 --> 00:30:57.450
that point otherwise if you know how not
allocating any Java memory usually the

00:30:57.450 --> 00:30:57.460
allocating any Java memory usually the
 

00:30:57.460 --> 00:30:58.889
allocating any Java memory usually the
Java garbage collector will not get

00:30:58.889 --> 00:30:58.899
Java garbage collector will not get
 

00:30:58.899 --> 00:31:02.610
Java garbage collector will not get
otherwise get triggered and be careful

00:31:02.610 --> 00:31:02.620
otherwise get triggered and be careful
 

00:31:02.620 --> 00:31:04.769
otherwise get triggered and be careful
with C++ memory management and

00:31:04.769 --> 00:31:04.779
with C++ memory management and
 

00:31:04.779 --> 00:31:12.810
with C++ memory management and
understand the walls so we actually have

00:31:12.810 --> 00:31:12.820
understand the walls so we actually have
 

00:31:12.820 --> 00:31:14.700
understand the walls so we actually have
a little bit of time for questions here

00:31:14.700 --> 00:31:14.710
a little bit of time for questions here
 

00:31:14.710 --> 00:31:18.090
a little bit of time for questions here
if there are any that's the end of it

00:31:18.090 --> 00:31:18.100
if there are any that's the end of it
 

00:31:18.100 --> 00:31:20.270
if there are any that's the end of it
thank you very much for attending

00:31:20.270 --> 00:31:20.280
thank you very much for attending
 

00:31:20.280 --> 00:31:25.810
thank you very much for attending
[Applause]

00:31:25.810 --> 00:31:25.820
[Applause]
 

00:31:25.820 --> 00:31:39.749
[Applause]
[Music]

