WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.000
Today we are doing the number

00:00:02.400 --> 00:00:03.400
2

00:00:03.400 --> 00:00:10.620
777 777 88888 99

00:00:10.620 --> 00:00:15.940
So I guess if you want to split that up, two hundred seventy seven trillion seven hundred and seventy seven

00:00:16.000 --> 00:00:20.700
Billion seven hundred and seventy eight million eight hundred eighty eight thousand eight hundred and ninety nine.

00:00:20.760 --> 00:00:27.340
This is a record-breaking number when it comes to the multiplication persistence of a number.

00:00:27.340 --> 00:00:29.540
so we'll do a smaller one just to get a

00:00:29.580 --> 00:00:33.940
handle on it. We'd like to give me a small. I don't know like three or four digit number. Would you like Brady?

00:00:33.960 --> 00:00:36.700
Oh, I always regret asking you this

00:00:37.420 --> 00:00:43.060
5428, alright, so the first thing we do is we multiply all the digits together.

00:00:43.120 --> 00:00:50.020
So 5 and 2 is gonna give us 10, 4 and 8 to give us 32, so it's gonna be 320

00:00:50.540 --> 00:00:55.400
and then we continue we multiply all the digits together now, there's a zero so zero

00:00:55.500 --> 00:00:57.920
So you made it two steps,

00:00:58.560 --> 00:01:02.000
before we hit a one digit number and if we have any one digit number

00:01:02.140 --> 00:01:07.739
You just you can't multiply the digits anymore and you stop so the question is I'm so disappointed

00:01:08.110 --> 00:01:13.319
Yeah, can I have another try did you want another go? Yeah, let's try this. It's not called persistence for nothing. What would you like?

00:01:15.700 --> 00:01:21.330
See where you went wrong brady is a 502 spells doom because that's gonna chuck a 0 on the end straight away

00:01:21.330 --> 00:01:23.320
So don't make that mistake again

00:01:24.940 --> 00:01:32.220
327? 327. Nice, you're going for primes. look at you? Okay. Let's see how that goes

00:01:32.220 --> 00:01:37.060
So that's six sevens which is 42. Someone will correct me if I'm wrong

00:01:37.680 --> 00:01:41.220
Four times two is gonna give us eight and then we're stuck

00:01:42.009 --> 00:01:49.229
Two steps. At home if you want try and pick a number. See if you can beat Brady's current record of 2

00:01:50.259 --> 00:01:54.539
So, how long do you reckon this one goes for? Your big number? Yeah big number

00:01:54.570 --> 00:01:57.180
What do you what do you think we're gonna get out of that one. have a guess, what do you reckon?

00:01:57.180 --> 00:01:59.100
You've already told me it's a record holder. That's right

00:01:59.100 --> 00:02:03.500
But because you're willing to do it for me now makes me think it's not crazy big.

00:02:03.500 --> 00:02:06.180
When have I shied away from a crazy-big calculations?

00:02:06.180 --> 00:02:09.540
So I'm gonna go for something surprisingly smaller. I'm gonna go for like

00:02:10.420 --> 00:02:12.420
10

00:02:12.600 --> 00:02:14.590
Getting my calculator out

00:02:14.590 --> 00:02:17.429
two times seven equals

00:02:18.790 --> 00:02:20.380
There's one seven

00:02:20.380 --> 00:02:22.150
two four

00:02:22.150 --> 00:02:23.290
nine nine

00:02:23.290 --> 00:02:28.940
Six. ... times six times two.... Oh, okay. So now we're down to

00:02:29.640 --> 00:02:36.280
Four times three times eight.... What's very exciting about this is I've never actually checked this

00:02:36.550 --> 00:02:39.960
This is the first time I've actually and now I'm feeling a little nervous

00:02:40.030 --> 00:02:45.809
like that's the level of preparation yet on numberphile how much prep I put into these videos pretty is like

00:02:45.940 --> 00:02:53.640
What numbers are you into currently? I like are kind of interested in this one... two, seven seven times eight

00:02:54.060 --> 00:02:57.760
54 5 times 4 is

00:02:59.880 --> 00:03:00.380
20

00:03:00.580 --> 00:03:02.580
Is 0

00:03:02.770 --> 00:03:07.320
1 2 3 4 5 6 7 8 9 10 11

00:03:07.860 --> 00:03:08.560
Oh

00:03:08.560 --> 00:03:13.920
11 and that's the correct answer. Thank goodness. It has a persistence of 11, which is the current

00:03:14.650 --> 00:03:20.519
world record for multiplication persistence of a number other numbers equaled the record

00:03:20.520 --> 00:03:23.339
But this is the shortest number with the biggest

00:03:23.920 --> 00:03:25.420
currently known

00:03:25.420 --> 00:03:28.140
Persistence and so that is the current champion.

00:03:28.140 --> 00:03:31.259
Hang on so you're with no limit on the number of digits?

00:03:31.810 --> 00:03:34.740
No-knock is about managers everyone and often in these videos

00:03:34.740 --> 00:03:40.439
I say I went away and I programmed a thing and then I calculate it and I found this I found that I have not

00:03:41.020 --> 00:03:45.420
Programmed this yet because as you may have those little underprepared today, I haven't coded it up

00:03:45.420 --> 00:03:47.729
But we could should we do it live do me do it?

00:03:48.460 --> 00:03:53.640
Do it cuz I always say I code something and I find them. Let's code something. Let's find it

00:03:53.800 --> 00:03:56.939
I'll get my laptop so funny story last week my

00:03:57.910 --> 00:04:03.299
Keyboard stopped working and the trackpad on my laptop, which is a bit awkward. Okay

00:04:03.300 --> 00:04:07.950
So first things first, we're gonna set something going which is going to do this process over and over and over again

00:04:08.440 --> 00:04:12.300
But we want it to stop once it gets to a thing which is only one

00:04:12.430 --> 00:04:17.460
okay, so this is gonna take some number and the first thing we're gonna say is if the

00:04:18.000 --> 00:04:21.800
the length of the number of digits to the string

00:04:22.740 --> 00:04:25.920
n so the great thing about n is, it's not only a number

00:04:26.500 --> 00:04:28.140
When we care about digits

00:04:28.150 --> 00:04:29.600
I'm going to turn it into a strings

00:04:29.600 --> 00:04:34.359
that goes from being like a number represented in binary or whatever base to just being

00:04:34.460 --> 00:04:39.909
The base ten digits in a string and if the length of that string equals one

00:04:40.490 --> 00:04:42.759
Then we're done right? We're at the very end of the thing, right?

00:04:42.760 --> 00:04:49.990
So that's at that point print whatever n is and then finish so return I don't know like "DONE"

00:04:50.270 --> 00:04:55.749
All right, that's just gonna tell it you know, your job here is done. Okay. Otherwise we need to

00:04:56.390 --> 00:04:57.960
multiply together all the digits.

00:04:57.960 --> 00:04:58.599
digits

00:04:59.630 --> 00:05:00.920
equals

00:05:00.920 --> 00:05:05.100
Let's do it as a list. i for i in

00:05:05.320 --> 00:05:08.100
The string version of the number, right?

00:05:08.110 --> 00:05:10.060
So they're turning into a string of digits

00:05:10.060 --> 00:05:12.520
and then it's taking out each one individually

00:05:12.520 --> 00:05:14.169
Oh, but we want them as as numbers

00:05:14.170 --> 00:05:16.170
So let's turn them

00:05:16.580 --> 00:05:18.230
back into numbers

00:05:18.230 --> 00:05:22.180
So bizarrely I'm turning it into digits as a string

00:05:22.180 --> 00:05:25.450
then taking out each one separately then turning them back into numbers, right?

00:05:25.450 --> 00:05:29.650
Which is kind of, because this is a base-10 thing one of the sad things about stuff like this is its base

00:05:30.320 --> 00:05:32.320
Specific so now we've got all the digits

00:05:33.080 --> 00:05:34.310
for

00:05:34.310 --> 00:05:37.440
j I'm just using j is the placeholder in

00:05:38.120 --> 00:05:42.860
Digits so now we want to multiply them all together. Okay, you know, let's have

00:05:44.420 --> 00:05:46.420
Current result

00:05:47.480 --> 00:05:51.700
Result equals one to start with and then each time

00:05:52.100 --> 00:05:54.160
result equals result

00:05:55.040 --> 00:06:00.969
Multiplied by that digit and you can do x equals just means make it equal to this times

00:06:01.610 --> 00:06:03.170
J whoops

00:06:03.170 --> 00:06:05.780
J. Okay, I think that's it

00:06:05.780 --> 00:06:09.099
and that's gonna give us a new result, but then we've got to repeat the process

00:06:09.440 --> 00:06:11.440
So this is where we can cheat

00:06:11.660 --> 00:06:15.910
And I haven't genuinely haven't tried coding this before so I don't know if this is going to work

00:06:15.910 --> 00:06:22.140
I'm going to try and get recursive and then put that new result into the same function.

00:06:23.100 --> 00:06:26.960
So, if it's one long, it'll stop otherwise

00:06:27.260 --> 00:06:31.299
It'll multiply all the digits together and then put it back into the beginning and it will

00:06:31.420 --> 00:06:36.550
Keep repeating through this process and you know what? Let's make it print the result each time

00:06:36.740 --> 00:06:42.039
So we get, we get to see them all as it as it loops through and then when it hits here

00:06:42.040 --> 00:06:44.040
It'll stop and say done. Okay?

00:06:45.380 --> 00:06:46.940
That can't go wrong

00:06:46.940 --> 00:06:51.180
Let's find out. I really should have checked this in advance.

00:06:51.180 --> 00:06:53.380
Okay copy. I'm just gonna fire up terminal

00:06:53.380 --> 00:06:59.480
Okay. So what I'm actually gonna do this is the laziest way to run something; literally paste it into terminal.

00:06:59.480 --> 00:07:01.540
Let's do the

00:07:02.080 --> 00:07:06.620
Persistence of 327 which is the second one, you said.

00:07:07.550 --> 00:07:08.930
42

00:07:08.930 --> 00:07:12.789
8 and then 8 forever, right? And so it's done twice and then going we're out

00:07:12.890 --> 00:07:18.189
Okay, I couldn't fix the code to not get the the last one twice. I just changed where the check is

00:07:18.190 --> 00:07:21.370
So actually what I could have done is have another check in here

00:07:21.950 --> 00:07:27.020
So I don't print the result and then print it again before stopping

00:07:27.020 --> 00:07:29.170
I could put the check in but I'm not gonna

00:07:29.420 --> 00:07:34.509
It fit for purpose. Alright for a first pass it's fine. And then the very first one

00:07:34.510 --> 00:07:38.619
Let's just check the first one just to make sure I've messed this up five

00:07:39.230 --> 00:07:41.230
four two eight

00:07:42.830 --> 00:07:50.319
It goes to 320 goes to 0. right? And now the ultimate test can it handle 2 six sevens six eights two nines

00:07:52.660 --> 00:07:58.060
There we go, right so and that's that's so much quicker! Right? so it's now spat out

00:07:58.760 --> 00:08:02.780
Exactly these all the way down and then it stops doesn't give us a number

00:08:03.470 --> 00:08:06.500
Ah, do we want like a, do we want a number of steps at the end?

00:08:06.500 --> 00:08:07.270
number of steps?

00:08:09.740 --> 00:08:13.509
Okay, okay Brady will cut this out and put it on the second channel

00:08:16.460 --> 00:08:21.069
2 one two, three, four five six oops 1 2 3 4 5 6 1 2

00:08:22.850 --> 00:08:24.999
There, total steps 11, okay, right

00:08:25.000 --> 00:08:26.780
So now we can put a number in

00:08:26.780 --> 00:08:28.600
and instantly we get everything.

00:08:28.600 --> 00:08:29.530
we could no longer

00:08:29.660 --> 00:08:34.330
print every single step along the way. It's kind of fun to see and we get the total number steps

00:08:34.330 --> 00:08:37.780
So Brady, let's put on what would you like? You know, let's

00:08:38.540 --> 00:08:43.059
Put put as we just mash it for a while and see what we get. No, cuz you can be strategic

00:08:43.060 --> 00:08:45.060
Ah, you're right to put a 5

00:08:45.500 --> 00:08:47.500
Just put in a bunch put in

00:08:47.810 --> 00:08:48.760
Fifteen 9's.

00:08:48.760 --> 00:08:52.959
Fifteen 9's. one two three, four, five six seven eight nine 10, 11 12 13 14 15

00:08:52.959 --> 00:08:54.780
Which is just nine to the 15.

00:08:54.780 --> 00:08:56.260
No, I put in another 10.

00:08:56.260 --> 00:08:57.518
Oh another ten nines. Yep

00:08:57.699 --> 00:08:59.699
Well, let's just see if that one works

00:08:59.959 --> 00:09:01.459
Two steps. Oh

00:09:01.459 --> 00:09:06.518
because we got the zero in the answer next time but what I can do in your in terminal just push up you get the

00:09:06.519 --> 00:09:09.008
Previous one stuck a few more 9s on the end

00:09:09.949 --> 00:09:12.429
two steps now what if we um,

00:09:13.100 --> 00:09:15.100
Put in eight instead

00:09:15.170 --> 00:09:17.170
two steps

00:09:21.230 --> 00:09:27.519
What about, what about the string you used like at the current record holder? Yeah, but put a three on the front

00:09:27.519 --> 00:09:29.519
I love it. Okay, so 3

00:09:29.750 --> 00:09:34.659
2 1 2 3 4 5 6 1 2 3 4 5 6 9 9 ah brilliant

00:09:34.660 --> 00:09:37.149
I love like I love you thinking ready and 2 steps

00:09:38.300 --> 00:09:40.220
This is harder than it looks!

00:09:40.970 --> 00:09:42.529
So it's zeros are like a

00:09:42.529 --> 00:09:44.000
Zeros are the land mines

00:09:44.000 --> 00:09:49.209
Boom, hit a zero, you're out. This is minesweeper, but for number searches, okay

00:09:49.420 --> 00:09:54.190
So this is what I would do I would now play with this for a while and it seems to be whenever you put in

00:09:54.410 --> 00:09:56.440
some random string of

00:09:57.290 --> 00:10:00.730
Numbers and boom, right because it was a zero the next one it's gone

00:10:02.149 --> 00:10:03.580
We need to be more strategic

00:10:03.580 --> 00:10:05.640
What about all the digits of pi.

00:10:05.640 --> 00:10:06.540
All of them?

00:10:07.300 --> 00:10:10.820
I will Get cracking on that. three eight one four one five nine two

00:10:11.980 --> 00:10:15.520
six five I forgot, that's that's enough -

00:10:16.060 --> 00:10:16.560
2

00:10:16.960 --> 00:10:21.540
Wow, 11 seems a lot more impressive all of a sudden, no wonder it's the world record.

00:10:21.550 --> 00:10:24.819
so does this mean that you could set up a program that would just

00:10:25.130 --> 00:10:29.349
Put every number in one after another and just leave it, you know, leave it for an hour or two

00:10:29.380 --> 00:10:34.260
so what we've done now is we've built the basics of checking

00:10:34.260 --> 00:10:37.360
Next, we want to build something to do the search.

00:10:37.360 --> 00:10:40.840
so we could just get something to generate random numbers of a certain size

00:10:41.000 --> 00:10:45.939
Shove them in and send us an email if it gets a good one. The next step would be to be

00:10:47.029 --> 00:10:50.078
Strategic about what numbers we were putting in because already you realized

00:10:50.300 --> 00:10:55.810
Don't put it in a 5 you put in a 5 it's not gonna work so we could create a search

00:10:56.240 --> 00:10:58.240
Which doesn't put in fives?

00:10:58.540 --> 00:11:01.990
Doesn't put in any combination we know will definitely give us

00:11:02.270 --> 00:11:08.980
Zero and actually we can get even smarter than that because if we're looking for the smallest number that it works for

00:11:09.410 --> 00:11:11.410
It doesn't matter what order the digits are in

00:11:11.540 --> 00:11:17.829
So in fact all the current record holders the shortest number of digits for different persistence values

00:11:17.840 --> 00:11:20.920
So there's a record holder for 10 and for 9 and so on

00:11:20.920 --> 00:11:23.230
They're always, the digits are always in ascending order

00:11:23.740 --> 00:11:28.820
Because you want the smallest number with those digits. So in fact, you don't have to search for

00:11:28.880 --> 00:11:33.130
Shuffled around versions; you just need that set of digits in that order and then there's other things

00:11:33.130 --> 00:11:35.679
So for example this one here

00:11:35.870 --> 00:11:43.179
we'll use your first one you put in 5428, that's going to give you exactly the same result as

00:11:43.700 --> 00:11:46.000
First of all, you could have put in two four

00:11:46.670 --> 00:11:48.729
Five eight, which is smaller

00:11:48.800 --> 00:11:52.660
But actually two times four is going to give you eight,

00:11:52.660 --> 00:11:56.169
so you could actually have just put in 588

00:11:56.900 --> 00:12:01.209
That's going to give you exactly the same sequence as that and it's smaller

00:12:01.210 --> 00:12:04.960
So if all you care about are the smallest possible values

00:12:04.960 --> 00:12:08.440
for that sequence of persistence afterwards (multiplication persistence)

00:12:08.600 --> 00:12:10.690
Then you never want to have a 2 and a 4

00:12:10.790 --> 00:12:15.279
You never want to have two threes because I could be a 9 you never want a 5 at all

00:12:15.280 --> 00:12:19.509
In fact, you only ever end up with a few small numbers at the beginning

00:12:20.990 --> 00:12:23.349
Never more than one 2 never more than one 3

00:12:23.930 --> 00:12:28.320
Never more than one 4 I think and then all sevens eights and nines

00:12:28.320 --> 00:12:31.329
for the rest of it so we could reduce our search space

00:12:32.420 --> 00:12:36.250
dramatically with a little bit of logic the current search has gone as far as

00:12:37.310 --> 00:12:41.979
233 digits so if you do code it up you've got to start searching from

00:12:42.530 --> 00:12:46.959
233 it's not gonna be smaller than that. We've already checked and it's currently

00:12:47.570 --> 00:12:50.229
The conjecture is you would never be 11

00:12:50.480 --> 00:12:55.300
So if people want to have a go, I mean, I'm always one to give it a go

00:12:55.730 --> 00:12:59.709
See if you can write some code see if it does a clever search and you know

00:12:59.710 --> 00:13:01.480
It would be a major breakthrough.

00:13:01.480 --> 00:13:05.230
If someone could find a number with a multiplication of persistance of 12

00:13:06.830 --> 00:13:09.940
Will you be the person to make that major breakthrough?

00:13:09.940 --> 00:13:12.619
Certainly the sorts of people who cracked tough nuts

00:13:12.620 --> 00:13:18.469
are those who think outside the box, creative thinkers, people who don't follow the flock and

00:13:19.050 --> 00:13:21.760
Brilliant wants to make you that type of person.

00:13:21.760 --> 00:13:25.310
Their courses quizzes puzzles, like the ones you see on the screen at the moment

00:13:25.560 --> 00:13:30.469
They're carefully crafted to mould people into smarter thinkers.

00:13:31.050 --> 00:13:37.399
Not memorizers, not people who just know all the equations and how to pass a test, but problem solvers.

00:13:37.800 --> 00:13:40.240
People with better wired brains.

00:13:40.240 --> 00:13:44.630
if you'd like to find out more about brilliant; what they're making and how they might help you,

00:13:44.699 --> 00:13:47.720
Go to brilliant.org/numberphile.

00:13:47.720 --> 00:13:51.319
There's free stuff on their site, but that /numberphile URL

00:13:51.540 --> 00:13:55.180
That'll get you 20% off one of their premium memberships

00:13:55.180 --> 00:13:57.560
and it'll also let them know you came from here.

