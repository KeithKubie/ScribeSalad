WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:09.067
So today we are going to talk
about another process of lumping

00:00:09.067 --> 00:00:16.945
or another process of
discretization what will lead to

00:00:16.945 --> 00:00:24.675
the digital abstraction.
So today's lecture is titled

00:00:24.675 --> 00:00:30.770
"Go Digital".
So let me begin with a usual

00:00:30.770 --> 00:00:36.145
review.
And so in the first lecture we

00:00:36.145 --> 00:00:41.491
started out by looking at
elements and lumping them.

00:00:41.491 --> 00:00:46.000
For example,
we took an element and said for

00:00:46.000 --> 00:00:51.870
the purpose of analyzing
electrical properties let's lump

00:00:51.870 --> 00:00:57.846
this element into a single
lumped value called a resistor,

00:00:57.846 --> 00:01:01.019
R.
And this led to the lumped

00:01:01.019 --> 00:01:04.902
circuit abstraction.
The lumped circuit abstraction

00:01:04.902 --> 00:01:09.407
says let's take these elements,
connect them with wires and

00:01:09.407 --> 00:01:13.679
analyze the properties of these
using a sort of analysis

00:01:13.679 --> 00:01:15.000
technique.

00:01:22.000 --> 00:01:28.237
So a set of a methods.
We've looked at the KVL,

00:01:28.237 --> 00:01:33.197
KCL method.
Another example of a method we

00:01:33.197 --> 00:01:39.487
looked at was the node method.
And of this category there is

00:01:39.487 --> 00:01:45.776
one method you should remember,
which you can apply to every

00:01:45.776 --> 00:01:51.959
single circuit and it will
simply work, is the node method.

00:01:51.959 --> 00:01:56.649
For linear circuits other
methods also apply,

00:01:56.649 --> 00:01:59.954
and these include
superposition,

00:01:59.954 --> 00:02:04.644
Thevenin method,
and in recitation or in your

00:02:04.644 --> 00:02:12.000
course notes you would have
looked at the Norton method.

00:02:12.000 --> 00:02:15.431
So that's what we did so far.
So this is a toolkit.

00:02:15.431 --> 00:02:19.411
So now you have a utility belt
with a bunch of tools in it,

00:02:19.411 --> 00:02:21.676
and you can draw from those
tools.

00:02:21.676 --> 00:02:24.627
And, just like any good
carpenter, you know,

00:02:24.627 --> 00:02:27.372
the carpenter has to cut a
piece of wood.

00:02:27.372 --> 00:02:30.186
He could use a chisel.
He could use a saw.

00:02:30.186 --> 00:02:34.746
He could use an electric saw.
And the reason you pay

00:02:34.746 --> 00:02:39.349
carpenters $80 an hour in the
Boston region is because they

00:02:39.349 --> 00:02:42.126
know which tool to use for what
job.

00:02:42.126 --> 00:02:46.492
So what we'll learn today is,
so this was one process of

00:02:46.492 --> 00:02:49.428
discretization.
We discretized matter.

00:02:49.428 --> 00:02:54.031
This gave us the discipline
here that we decided to follow,

00:02:54.031 --> 00:02:58.238
lumped matter discipline,
that moved us from Maxwell's

00:02:58.238 --> 00:03:03.000
equations into this new
playground called EECS.

00:03:03.000 --> 00:03:06.881
Where all elements looked like
these rinky-dinky little values

00:03:06.881 --> 00:03:09.681
like resistors and voltage
sources and so on.

00:03:09.681 --> 00:03:12.800
What we'll do today,
if that wasn't simple enough,

00:03:12.800 --> 00:03:15.154
let's simplify our lives even
further.

00:03:15.154 --> 00:03:17.699
What we're going to do is lump
some more.

00:03:17.699 --> 00:03:20.563
So what else can we lump?
We've lumped matter,

00:03:20.563 --> 00:03:24.254
so all matter is taken care of.
So what can we lump to make

00:03:24.254 --> 00:03:26.227
life even easier?
When in doubt,

00:03:26.227 --> 00:03:29.472
if things are complicated,
discretize it or lump it,

00:03:29.472 --> 00:03:32.590
right?
So what do you think?

00:03:32.590 --> 00:03:36.000
What we will do today is lump
signal values.

00:03:45.000 --> 00:03:47.611
So we'll just deal with lumped
values.

00:03:47.611 --> 00:03:51.000
And this will lead to the
digital abstraction.

00:04:02.000 --> 00:04:10.000
And the related reading is
Chapter 5 of the course notes.

00:04:15.000 --> 00:04:19.230
So before we do this kind of
lumping, let me motivate why we

00:04:19.230 --> 00:04:21.883
do this.
One reason is to simplify our

00:04:21.883 --> 00:04:25.898
lives, but there is no need to
just go around simplifying

00:04:25.898 --> 00:04:29.913
things just because we can.
Let's try to see if there are

00:04:29.913 --> 00:04:34.000
other reasons motivating the
digital abstraction.

00:04:34.000 --> 00:04:39.336
So what I would like to start
with is a simple example of a

00:04:39.336 --> 00:04:44.396
analog processing circuit that
you should now be able to

00:04:44.396 --> 00:04:47.800
analyze.
So I'm going to be motivating

00:04:47.800 --> 00:04:51.204
digital.
So let's start with an analog

00:04:51.204 --> 00:04:55.160
circuit that looks like this,
two resistors,

00:04:55.160 --> 00:05:00.118
R1 and R2.
And what I'm going to do is

00:05:00.118 --> 00:05:06.471
apply a voltage source here,
V1, apply another one here,

00:05:06.471 --> 00:05:13.285
V2, and make this connection.
And let me call this voltage V

00:05:13.285 --> 00:05:20.100
nought and call this my output.
This voltage with respect to

00:05:20.100 --> 00:05:25.528
ground node, rather than drawing
this wire here,

00:05:25.528 --> 00:05:31.881
I often times draw a ground
here and simply throw ground

00:05:31.881 --> 00:05:36.811
wherever I want.
This symbol simply refers to

00:05:36.811 --> 00:05:40.692
the fact that the other terminal
is taken at the ground node.

00:05:40.692 --> 00:05:44.121
So here is my V nought.
Now, let's go and analyze this

00:05:44.121 --> 00:05:46.773
and see what it gives us.
In this example,

00:05:46.773 --> 00:05:50.719
V1 and V2 may be outputs of two
sensors, maybe heat sensors or

00:05:50.719 --> 00:05:53.889
something like that.
This is a heat sensor on that

00:05:53.889 --> 00:05:57.835
side of the room and this is a
heat sensor on this side of the

00:05:57.835 --> 00:06:01.043
room.
And I pass their signals

00:06:01.043 --> 00:06:05.557
through two resistors and I look
at the voltage there.

00:06:05.557 --> 00:06:10.412
So by now you should be able to
write the answer V nought,

00:06:10.412 --> 00:06:13.989
or the value V nought almost by
inspection.

00:06:13.989 --> 00:06:17.565
Just to show you,
let me use superposition.

00:06:17.565 --> 00:06:22.335
When you see multiple sources,
the first thing you should

00:06:22.335 --> 00:06:26.763
think about is can I use
superposition to simplify my

00:06:26.763 --> 00:06:30.000
life?
And let me do that.

00:06:30.000 --> 00:06:35.452
V nought here is the sum of two
voltages, one due to V1 acting

00:06:35.452 --> 00:06:38.670
alone and one due to V2 acting
alone.

00:06:38.670 --> 00:06:43.050
So what's the voltage here due
to V1 acting alone?

00:06:43.050 --> 00:06:48.502
To find out that I short this
voltage, I zero out this voltage

00:06:48.502 --> 00:06:52.882
and look at the effect of V1.
So the effect of V1,

00:06:52.882 --> 00:06:57.620
if this were shorted out,
is simply V1 x R2 / R1 + R2.

00:06:57.620 --> 00:07:02.000
This is now a voltage divider,
right?

00:07:02.000 --> 00:07:06.687
A voltage V applied across two
resistors and the output taken

00:07:06.687 --> 00:07:09.890
across one resistor.
So that's this value.

00:07:09.890 --> 00:07:12.312
Then I could do the second
part.

00:07:12.312 --> 00:07:16.687
To look at the effect of V2,
what I will do is short this

00:07:16.687 --> 00:07:19.656
voltage and look at the effect
of this.

00:07:19.656 --> 00:07:23.484
Now, this voltage is across
this resistor divider.

00:07:23.484 --> 00:07:27.000
And so I get R1 / (R1 + R2)
here.

00:07:27.000 --> 00:07:30.270
So you'll notice that for
something like this,

00:07:30.270 --> 00:07:34.559
if I had applied KVL and KCL of
the node method I would have

00:07:34.559 --> 00:07:38.557
gotten a bunch of equations,
but here I wrote it just by

00:07:38.557 --> 00:07:41.464
inspection.
You should be able to look at

00:07:41.464 --> 00:07:45.607
circuit patterns like this and
write the answers down very

00:07:45.607 --> 00:07:48.297
quickly.
Let's say if I chose R1 to be

00:07:48.297 --> 00:07:52.295
equal to R2 then V nought would
simply be (V1 + V2) / 2.

00:07:52.295 --> 00:07:56.511
So if these two values were
equal, I simply get the output,

00:07:56.511 --> 00:08:00.000
the average of the two
voltages.

00:08:00.000 --> 00:08:02.066
So this guy is an adder
circuit.

00:08:02.066 --> 00:08:05.800
It adds up these two voltages.
But more precisely it's an

00:08:05.800 --> 00:08:09.066
averaging circuit.
It takes two voltages and gives

00:08:09.066 --> 00:08:12.533
me the average value.
Now, if you have two sensors in

00:08:12.533 --> 00:08:16.600
the room, you might think of why
you want to take that average

00:08:16.600 --> 00:08:19.533
value to control the temperature
of the room.

00:08:19.533 --> 00:08:23.533
But suffice it to say that V
nought is the average of the two

00:08:23.533 --> 00:08:26.066
values.
So let me show you a quick demo

00:08:26.066 --> 00:08:30.266
of this example and then look at
what the problems are with this

00:08:30.266 --> 00:08:33.050
example.
So let's say,

00:08:33.050 --> 00:08:36.688
as one example,
I applied a square wave at V1,

00:08:36.688 --> 00:08:39.841
which is the top curve,
the green curve,

00:08:39.841 --> 00:08:44.691
and I applied a triangular wave
at V2, that's the second one.

00:08:44.691 --> 00:08:48.167
As you expect,
the output is going to be the

00:08:48.167 --> 00:08:51.724
sum of the two voltages scaled
appropriately.

00:08:51.724 --> 00:08:56.089
So notice that I have a square
wave with a superimposed

00:08:56.089 --> 00:09:01.068
triangular wave on top.
And I can play around.

00:09:01.068 --> 00:09:06.709
What I could do is change the
amplitude of my wave form here.

00:09:06.709 --> 00:09:11.034
And, as you notice,
the amplitude of the output

00:09:11.034 --> 00:09:14.230
component also changes
accordingly.

00:09:14.230 --> 00:09:18.837
So this is one simple example
of an adder circuit,

00:09:18.837 --> 00:09:24.196
and the two wave forms get
summed up and I get the output.

00:09:24.196 --> 00:09:28.897
So I'll switch to Page 3.
Let me just draw a little

00:09:28.897 --> 00:09:35.866
sketch for you here.
Here, what I showed you was I

00:09:35.866 --> 00:09:44.133
had a triangular wave coming on
one of these inputs and I had a

00:09:44.133 --> 00:09:52.000
square wave on the other one,
and the output looks something

00:09:52.000 --> 00:09:54.000
like this.

00:10:04.000 --> 00:10:05.750
OK?
No surprise here.

00:10:05.750 --> 00:10:11.003
This is a simple analog signal
processing circuit which gives

00:10:11.003 --> 00:10:13.804
me the average of two wave
forms.

00:10:13.804 --> 00:10:18.969
Now, let me do the following.
Often times I may need to look

00:10:18.969 --> 00:10:21.771
at this value some distance
away.

00:10:21.771 --> 00:10:26.673
So let's say this person here
wants to look at the value.

00:10:26.673 --> 00:10:32.877
So I bring this wire here.
And I also bring the ground

00:10:32.877 --> 00:10:38.633
connection and I look at it.
I look at this value here.

00:10:38.633 --> 00:10:44.708
And when I have a long wire I
can get noise added onto the

00:10:44.708 --> 00:10:48.652
circuit.
So let's say a bunch of noise

00:10:48.652 --> 00:10:52.062
gets added into the signal
there.

00:10:52.062 --> 00:10:58.564
And what I end up seeing here
is not something that looks like

00:10:58.564 --> 00:11:04.000
this but something that looks
like that.

00:11:04.000 --> 00:11:08.170
That's not unusual.
And the problem with this is

00:11:08.170 --> 00:11:12.873
now when I look at this,
if I'm looking to distinguish

00:11:12.873 --> 00:11:15.447
between, say,
a 3.9 and a 3.8,

00:11:15.447 --> 00:11:20.682
it's really hard to do that
because my noise is overwhelming

00:11:20.682 --> 00:11:23.522
my signal.
I have a real problem,

00:11:23.522 --> 00:11:27.426
a real problem here.
Noise is a fact of life.

00:11:27.426 --> 00:11:31.703
So what do we do?
This is so fundamental.

00:11:31.703 --> 00:11:35.555
Large bodies of courses in
electrical engineering are

00:11:35.555 --> 00:11:40.000
devoted to how do I carefully
analyze signals in the presence

00:11:40.000 --> 00:11:42.814
of noise?
You'll take courses in speech

00:11:42.814 --> 00:11:47.259
processing that look at clever
techniques to recognize speech

00:11:47.259 --> 00:11:50.740
in the presence of noise and so
on and so forth.

00:11:50.740 --> 00:11:54.370
One technique we adopt that
we'll talk about here,

00:11:54.370 --> 00:11:58.000
which is fundamental to EECS,
is using the digital

00:11:58.000 --> 00:12:03.151
abstraction.
Let me show you how it can

00:12:03.151 --> 00:12:07.272
really help with the noise
problem.

00:12:07.272 --> 00:12:13.575
So the idea is value lumping or
value discretization.

00:12:13.575 --> 00:12:20.363
Much like we lumped matter,
we've discretized matter into

00:12:20.363 --> 00:12:26.060
discrete chunks,
let's discretize value into two

00:12:26.060 --> 00:12:31.020
chunks.
Let's simply say that now I'm

00:12:31.020 --> 00:12:35.604
going to deal with two values
and I can, say,

00:12:35.604 --> 00:12:37.583
call them high,
low.

00:12:37.583 --> 00:12:43.625
I have a bunch of choices here.
I may call it 5 volts and 0

00:12:43.625 --> 00:12:47.270
volts.
I may call it true and false.

00:12:47.270 --> 00:12:53.208
What I'm doing is I'm just
restricting my universe to deal

00:12:53.208 --> 00:12:58.000
with just two values,
zero and one.

00:12:58.000 --> 00:13:01.823
This is like dealing with a
number system with only two

00:13:01.823 --> 00:13:04.230
digits.
And these are zero and one.

00:13:04.230 --> 00:13:08.407
So what I've now done is I'm
saying that rather than dealing

00:13:08.407 --> 00:13:12.442
with all possible continuous
values, 0.1, 3.9999 recurring

00:13:12.442 --> 00:13:16.194
and so on and so forth,
what I'm going to do is simply

00:13:16.194 --> 00:13:19.734
deal with a high and a low.
Dealing with this whole

00:13:19.734 --> 00:13:22.707
continuum of numbers is really
complicated.

00:13:22.707 --> 00:13:26.743
Let me simplify my life and
just postulate that I am going

00:13:26.743 --> 00:13:32.549
to be looking at high and low.
Whenever I see something I'll

00:13:32.549 --> 00:13:37.120
look at it and say high or low,
is it black or white,

00:13:37.120 --> 00:13:39.758
period.
There's no choice here,

00:13:39.758 --> 00:13:44.065
just two individual values.
So that sounds simple,

00:13:44.065 --> 00:13:47.582
and nice and so on,
but what's the point?

00:13:47.582 --> 00:13:52.153
What do we get by doing that?
Let's take our example.

00:13:52.153 --> 00:13:55.758
Let's take what might be a
digital system.

00:13:55.758 --> 00:14:02.000
Let's take a digital system and
let's say I have a sender.

00:14:02.000 --> 00:14:07.289
Much like I sent a signal value
a long distance,

00:14:07.289 --> 00:14:13.141
let me have a sender,
and I have a ground as well and

00:14:13.141 --> 00:14:18.430
here is a receiver.
This symbol simply says that

00:14:18.430 --> 00:14:22.032
both of them share a ground
wire.

00:14:22.032 --> 00:14:28.221
So the sender and a receiver.
And what I'm interested in

00:14:28.221 --> 00:14:34.636
doing, the sender is interested
in sending a signal to the

00:14:34.636 --> 00:14:39.118
receiver.
And in the digital system,

00:14:39.118 --> 00:14:44.088
the way I would send a digital
signal is all I can use is ones

00:14:44.088 --> 00:14:47.592
and zeros, OK?
So let's say the sender sends

00:14:47.592 --> 00:14:51.340
something like this.
The sender wants to send a

00:14:51.340 --> 00:14:54.192
value.
This is my time axis and this

00:14:54.192 --> 00:14:57.614
is 2.5 volts,
this is 0 volts and this is 5

00:14:57.614 --> 00:15:01.008
volts.
My sender has some agreement

00:15:01.008 --> 00:15:05.384
with the receiver and says I'm
just going to be sending to you

00:15:05.384 --> 00:15:09.186
low values and high values.
And this signal here would

00:15:09.186 --> 00:15:12.056
correspond to "0" "1" "0".
It's a symbol.

00:15:12.056 --> 00:15:15.213
That's why I have input zero in
quotes there.

00:15:15.213 --> 00:15:18.369
We'll go into this in much more
detail later,

00:15:18.369 --> 00:15:22.243
but for now suffice it to say
that I'm sending a set of

00:15:22.243 --> 00:15:26.260
signals here "0" "1" "0".
This simplistic scheme will not

00:15:26.260 --> 00:15:30.206
work in many situations but go
along with this for a few

00:15:30.206 --> 00:15:34.236
seconds.
So I send the signal sequence

00:15:34.236 --> 00:15:38.245
"0" "1" "0" out here.
And notice that there is a high

00:15:38.245 --> 00:15:41.175
and a low.
And the agreement the sender

00:15:41.175 --> 00:15:45.879
and the receiver have is that,
look, if you see a value that's

00:15:45.879 --> 00:15:48.578
higher than 2.5 volts that's a
high.

00:15:48.578 --> 00:15:53.127
If you see a value below 2.5
volts in the wire that's a low.

00:15:53.127 --> 00:15:57.214
And I'm going to send a 0 volt
and a 5 volt from here.

00:15:57.214 --> 00:16:01.686
So now at the sending site
let's say I don't have any noise

00:16:01.686 --> 00:16:06.701
in this system.
Let's say this is my Vn,

00:16:06.701 --> 00:16:11.766
some noise being added.
And let's say Vn is 0.

00:16:11.766 --> 00:16:18.069
Then in that case I will
receive exactly what is sent "0"

00:16:18.069 --> 00:16:22.233
"0" 5, 2.5, 0 volts.
And this is time.

00:16:22.233 --> 00:16:25.047
Nothing fancy here,
right?

00:16:25.047 --> 00:16:30.000
My receiver receives a "0" "1"
"0".

00:16:30.000 --> 00:16:36.575
Now, the beauty of this is that
now suppose I were to impose

00:16:36.575 --> 00:16:42.594
noise much like I had noise out
there and Vn was not 0.

00:16:42.594 --> 00:16:48.390
Rather Vn was some noise
voltage, let's say 0.2 volts

00:16:48.390 --> 00:16:52.625
peak to peak.
Let's say that simply got

00:16:52.625 --> 00:16:58.532
superposed on the signal.
In which case what do I get?

00:16:58.532 --> 00:17:06.000
What I end up here with is a
signal that looks like this.

00:17:06.000 --> 00:17:09.918
So the receiver gets that
signal because a noise is added

00:17:09.918 --> 00:17:12.437
into my signal and that's what I
get.

00:17:12.437 --> 00:17:14.256
But guess what?
No problem.

00:17:14.256 --> 00:17:17.755
The receiver says oh,
yeah, this is a 0 because the

00:17:17.755 --> 00:17:21.463
values are less than 2.5,
this is a 1 and this is a 0.

00:17:21.463 --> 00:17:24.472
"0" "1" "0".
So here my receiver was able to

00:17:24.472 --> 00:17:28.390
receive the signal and correctly
interpret it without any

00:17:28.390 --> 00:17:32.032
problems.
So because I used this value

00:17:32.032 --> 00:17:36.024
discretization and because I had
this agreement with the

00:17:36.024 --> 00:17:39.000
receiver, I had better noise
immunity.

00:17:45.000 --> 00:17:48.871
Consequently,
I had what is called a noise

00:17:48.871 --> 00:17:51.987
margin.
Noise margin says how much

00:17:51.987 --> 00:17:56.047
noise can I tolerate?
And in this situation,

00:17:56.047 --> 00:18:00.201
because the sender sends 5
volts and 0 volts,

00:18:00.201 --> 00:18:04.450
the 5 volts can creep all the
way down to 2.5,

00:18:04.450 --> 00:18:10.502
I'll still be OK.
Similarly, 0 could go all the

00:18:10.502 --> 00:18:14.125
way up to 2.5,
I'd still be OK.

00:18:14.125 --> 00:18:21.492
So in this case I have a noise
margin of 2.5 volts for a 1 and

00:18:21.492 --> 00:18:28.135
similarly 2.5 volts for a 0,
because there are 2.5 volts

00:18:28.135 --> 00:18:34.071
between a 0 volt and 2.5.
So notice that I have a nice

00:18:34.071 --> 00:18:37.918
little noise margin here,
which simply is the English

00:18:37.918 --> 00:18:41.396
meaning of the term there is a
margin for noise.

00:18:41.396 --> 00:18:45.613
And even though I can change
the signal value by up to 2.5

00:18:45.613 --> 00:18:50.126
volts, the receiver will still
correctly interpret the signal.

00:18:50.126 --> 00:18:54.269
So I've decided to discretize
values into highs and lows.

00:18:54.269 --> 00:18:57.894
And because of that,
if all I wanted to do in life

00:18:57.894 --> 00:19:03.000
is send highs and lows I can
send them very effectively.

00:19:03.000 --> 00:19:08.403
There are many complications,
but if all I care about is

00:19:08.403 --> 00:19:14.200
sending highs and lows I can
send it with a lot of tolerance

00:19:14.200 --> 00:19:17.933
to noise.
So many of you are saying but

00:19:17.933 --> 00:19:21.470
what about this,
but what about that?

00:19:21.470 --> 00:19:27.070
There are lots of buts here.
And let's take a look at some

00:19:27.070 --> 00:19:31.000
of them.
If you look up there.

00:19:31.000 --> 00:19:38.079
What I ended up doing was
creating a design space that

00:19:38.079 --> 00:19:42.754
looked like this.
This is on Page 6.

00:19:42.754 --> 00:19:50.234
What I did was I said with a
range of values from 0 to 5,

00:19:50.234 --> 00:19:58.115
what I'm going to do is at 2.5
I drew a line and I said as a

00:19:58.115 --> 00:20:05.996
sender if you wanted to send a 0
then you would send a value

00:20:05.996 --> 00:20:10.193
here.
And if you wanted to send a 1

00:20:10.193 --> 00:20:14.277
you would send a value here.
Similarly, for a receiver.

00:20:14.277 --> 00:20:18.815
And if the sender sent a value
all the way up in 5 volts that

00:20:18.815 --> 00:20:22.218
was the best thing,
but technically the sender

00:20:22.218 --> 00:20:25.092
could send any value between 2.5
and 5.

00:20:25.092 --> 00:20:29.478
And if there was no noise then
the receiver could correctly

00:20:29.478 --> 00:20:35.000
interpret a 1 if it was above
this and 0 if it was below this.

00:20:35.000 --> 00:20:39.565
The problem with this approach
really is that if I allow the

00:20:39.565 --> 00:20:44.285
sender to send any value above
2.5 all the way to 5 then there

00:20:44.285 --> 00:20:48.000
really is no noise margin in
this situation.

00:20:53.000 --> 00:20:55.732
OK?
Because if I allowed the sender

00:20:55.732 --> 00:21:00.232
to send any value between 2.5
and 5 then what if I have a

00:21:00.232 --> 00:21:04.709
value 2.5 for a 1?
Then I may end up getting very

00:21:04.709 --> 00:21:08.051
little noise margin on the other
side.

00:21:08.051 --> 00:21:11.303
Worse yet, what if I get a
value 2.5?

00:21:11.303 --> 00:21:16.812
That's a much worse situation.
What if the receiver receives a

00:21:16.812 --> 00:21:18.799
value of 2.5?
Now what?

00:21:18.799 --> 00:21:23.316
What does the receiver do?
The receiver cannot tell

00:21:23.316 --> 00:21:28.012
whether it's a 1 or a 0.
The receiver gets hopelessly

00:21:28.012 --> 00:21:33.268
confused.
So to deal with that,

00:21:33.268 --> 00:21:40.894
I'm going to fix this,
what I'm going to do is the

00:21:40.894 --> 00:21:45.097
following.
Switch to Page 7.

00:21:45.097 --> 00:21:53.813
What I'll do here is to prevent
the receiver from getting

00:21:53.813 --> 00:22:02.684
confused, if the receiver saw
2.5, what I'm going to do is

00:22:02.684 --> 00:22:10.000
define what is called "no man's
land".

00:22:10.000 --> 00:22:15.400
I'm going to define the region
of my voltage space called the

00:22:15.400 --> 00:22:19.450
forbidden region.
And what I'm going to do is,

00:22:19.450 --> 00:22:24.759
say, let's say I defined it as
2 volts, 3 volts and 5 volts,

00:22:24.759 --> 00:22:28.269
0, 2, 3 and 5.
With my forbidden region,

00:22:28.269 --> 00:22:33.400
if I have a sender then I tell
the sender you can send any

00:22:33.400 --> 00:22:39.629
value between 3 and 5 for a 1.
And you can send any value

00:22:39.629 --> 00:22:44.179
between 2 and 0 for a 0.
To send the symbol 0,

00:22:44.179 --> 00:22:50.146
I can send any voltage between
0 and 2, and similarly for 1.

00:22:50.146 --> 00:22:55.202
At the receiving side,
if I see any value between 3

00:22:55.202 --> 00:23:00.966
and 5, I read that as a 0,
and any value between 0 and 2 I

00:23:00.966 --> 00:23:06.410
read that as 2 volts.
So I may label this value VH

00:23:06.410 --> 00:23:11.490
and label this threshold VL,
so there's a high threshold and

00:23:11.490 --> 00:23:15.192
a low threshold.
So this solves one problem.

00:23:15.192 --> 00:23:20.529
Now the receiver can never see
a value in the forbidden region.

00:23:20.529 --> 00:23:24.317
Now, I can stand her and
pontificate and say,

00:23:24.317 --> 00:23:30.000
oops, that's a forbidden
region, thou shalt not go there.

00:23:30.000 --> 00:23:33.593
But what if I get some noise
and a value goes in there?

00:23:33.593 --> 00:23:36.121
In real systems values may
enter there.

00:23:36.121 --> 00:23:39.449
But what I'm saying,
so this is the beauty of using

00:23:39.449 --> 00:23:41.911
a discipline.
Let me use my playground

00:23:41.911 --> 00:23:43.907
analogy.
This is my playground.

00:23:43.907 --> 00:23:47.567
We got into this playground
using the discrete matter of

00:23:47.567 --> 00:23:51.360
discipline, the playground of
EECS, but in that playground

00:23:51.360 --> 00:23:55.219
some region of that playground
deals with just high and low

00:23:55.219 --> 00:23:57.149
values.
I further restrict the

00:23:57.149 --> 00:24:00.543
playground and I say I'm only
going to focus on that

00:24:00.543 --> 00:24:06.000
playground in which all signal
values have a forbidden region.

00:24:06.000 --> 00:24:09.987
All senders and receivers
adhere to a forbidden region.

00:24:09.987 --> 00:24:14.196
And if there is any signal in
this space, in the forbidden

00:24:14.196 --> 00:24:16.781
space then my behavior is
undefined.

00:24:16.781 --> 00:24:19.292
I don't care.
You want to go there?

00:24:19.292 --> 00:24:21.729
Sure.
I don't know what's going to

00:24:21.729 --> 00:24:24.313
happen to you.
Now, we're engineers,

00:24:24.313 --> 00:24:26.972
right?
So we've disciplined ourselves

00:24:26.972 --> 00:24:32.301
to play in this playground.
It's like I tell my 9-year-old,

00:24:32.301 --> 00:24:33.861
don't go there,
right?

00:24:33.861 --> 00:24:36.386
And of course he wants to go
there.

00:24:36.386 --> 00:24:39.207
He says what will happen if I
go there?

00:24:39.207 --> 00:24:42.252
And the answer here will be
undefined, OK?

00:24:42.252 --> 00:24:45.222
Something really bad could
happen to you.

00:24:45.222 --> 00:24:48.787
I don't know what it is but
something really bad,

00:24:48.787 --> 00:24:52.128
you know, a lightening bolt or
who knows what,

00:24:52.128 --> 00:24:55.915
but something really bad.
And you as a designer of a

00:24:55.915 --> 00:25:00.000
circuit can, let's say you were
Intel.

00:25:00.000 --> 00:25:02.902
Intel designs its chips.
And let's say Intel decides to

00:25:02.902 --> 00:25:05.857
play in this playground and
there is a forbidden region.

00:25:05.857 --> 00:25:08.330
So Intel says oh,
it's really easy for me if in

00:25:08.330 --> 00:25:11.339
the forbidden region the chip
simply burns up and catches

00:25:11.339 --> 00:25:13.489
fire, we'll sell more chips.
That's fine.

00:25:13.489 --> 00:25:15.961
Whatever you want.
The key here is that all I'm

00:25:15.961 --> 00:25:19.078
saying is that I am going to
discipline myself into playing

00:25:19.078 --> 00:25:22.195
in this playground and that's
where I will define my rules,

00:25:22.195 --> 00:25:24.936
and you stay within the
boundaries and all the rules

00:25:24.936 --> 00:25:28.000
will apply.
It's called a "discipline."

00:25:28.000 --> 00:25:31.099
You're disciplining yourselves
to stay within it.

00:25:31.099 --> 00:25:34.070
There's no logic to it.
It's just a discipline.

00:25:34.070 --> 00:25:37.493
Just do it and you'll be OK.
When we look at practical

00:25:37.493 --> 00:25:40.722
circuits and so on,
we have to address the issue of

00:25:40.722 --> 00:25:43.047
what happens when things go in
there.

00:25:43.047 --> 00:25:45.243
But let's postpone that
discussion.

00:25:45.243 --> 00:25:48.343
For now I've solved one of my
problems, which is,

00:25:48.343 --> 00:25:52.154
the previous problem was what
does a receiver do if it saw a

00:25:52.154 --> 00:25:53.897
2.5?
Now it can't see a 2.5.

00:25:53.897 --> 00:25:57.450
But then the receiver asks,
Agarwal, but what if I see a

00:25:57.450 --> 00:26:00.929
2.5?
I can tell the receiver you can

00:26:00.929 --> 00:26:03.668
do whatever you want to do.
You can stomp it.

00:26:03.668 --> 00:26:05.785
You can squish it.
You can burn it.

00:26:05.785 --> 00:26:07.963
You can chuck it.
Whatever you want.

00:26:07.963 --> 00:26:10.204
It's up to you.
Do whatever you want.

00:26:10.204 --> 00:26:13.192
You won't see a value.
If you do, do whatever you

00:26:13.192 --> 00:26:14.437
want.
It's undefined.

00:26:14.437 --> 00:26:16.554
That works.
So you, as the receiver

00:26:16.554 --> 00:26:19.791
designer can do whatever you
want when you see a 2.5.

00:26:19.791 --> 00:26:22.716
You can say yeah,
I'll just put out a 1 if I see

00:26:22.716 --> 00:26:25.082
a 2.5 or a 2.6.
I'll just do something.

00:26:25.082 --> 00:26:27.323
No one cares.
So this is pretty good.

00:26:27.323 --> 00:26:32.292
This is pretty good.
We still have a problem,

00:26:32.292 --> 00:26:35.923
though.
Do people see the problem here?

00:26:35.923 --> 00:26:40.509
This still doesn't quite work.
If Intel did this,

00:26:40.509 --> 00:26:46.242
instead of your laptops failing
and blue-screening every hour

00:26:46.242 --> 00:26:49.681
they'd be doing it every
millisecond.

00:26:49.681 --> 00:26:54.363
So the problem is this
discipline have allowed the

00:26:54.363 --> 00:27:00.000
sender to send any value between
3 and 5 as a 1.

00:27:00.000 --> 00:27:05.607
And any value between 3 and 5
at the receiver is treated as a

00:27:05.607 --> 00:27:08.411
1.
Do you see where the problem

00:27:08.411 --> 00:27:09.065
is?
Yes?

00:27:09.065 --> 00:27:14.672
The sender sends a 1.99 and the
noise pumps it into forbidden

00:27:14.672 --> 00:27:16.074
region.
Exactly.

00:27:16.074 --> 00:27:20.280
So the sender says it's
legitimate, I'm Intel.

00:27:20.280 --> 00:27:23.271
They've told me stick to 0 and
2.

00:27:23.271 --> 00:27:30.000
And Intel parts will be sending
to values between 0 and 2.

00:27:30.000 --> 00:27:32.740
And Motorola parts,
which are receivers,

00:27:32.740 --> 00:27:35.339
you know they have to receive 0
and 2.

00:27:35.339 --> 00:27:37.447
So Intel can send the value,
2.

00:27:37.447 --> 00:27:39.836
They can because it's 1.9 out
of 2.

00:27:39.836 --> 00:27:42.435
It's legal.
This way I can make really

00:27:42.435 --> 00:27:45.175
cheap parts.
But now the problem is that

00:27:45.175 --> 00:27:48.969
even the smallest amount of
noise will bump it into the

00:27:48.969 --> 00:27:52.341
forbidden region,
and so therefore this one has a

00:27:52.341 --> 00:27:54.871
problem.
And the problem is that this

00:27:54.871 --> 00:28:00.000
one offers zero noise margin.
There is no noise margin.

00:28:00.000 --> 00:28:05.227
There is no margin for noise in
the discipline.

00:28:05.227 --> 00:28:10.113
All right, back to the drawing
board, folks.

00:28:10.113 --> 00:28:15.568
Switch to Page 8.
Let's get rid of all this stuff

00:28:15.568 --> 00:28:20.000
and go back to the drawing
board.

00:28:31.000 --> 00:28:35.583
OK, so what do we do now?
How about the following?

00:28:35.583 --> 00:28:39.419
How, about as before I say,
as a receiver,

00:28:39.419 --> 00:28:44.938
if you see a value between 3
and 5 you treat that as a 1 and

00:28:44.938 --> 00:28:49.148
a value between 0 and 2 you
treat that as a 0.

00:28:49.148 --> 00:28:52.703
No difference.
So as a receiver same as

00:28:52.703 --> 00:28:56.258
before.
But now what I do is I hold the

00:28:56.258 --> 00:29:03.152
sender to tougher standards.
I hold the feet of the sender

00:29:03.152 --> 00:29:09.565
to the fire and say you have to
adhere to tougher standards.

00:29:09.565 --> 00:29:16.413
So what I'm going to do is hold
the sender to tougher standards,

00:29:16.413 --> 00:29:21.630
maybe four walls.
That is tell the sender that if

00:29:21.630 --> 00:29:27.608
you want to send to 0 or a 1,
for a 1 you have to send a

00:29:27.608 --> 00:29:33.152
value between 4 and 5,
and for a 0 a value between 0

00:29:33.152 --> 00:29:37.865
and 1.
Sender is now held to tougher

00:29:37.865 --> 00:29:41.521
standards.
This is what my chart looks

00:29:41.521 --> 00:29:44.683
like.
So now I do have some noise

00:29:44.683 --> 00:29:48.438
margin.
Can someone tell me what is the

00:29:48.438 --> 00:29:51.699
noise margin here for a 1?
1 volt.

00:29:51.699 --> 00:29:57.430
And the reason is that the
lowest voltage a sender can send

00:29:57.430 --> 00:30:02.081
is 4 volts, OK?
If the 4 leaks down to 2.99

00:30:02.081 --> 00:30:05.628
that's in the forbidden region,
I'm in trouble.

00:30:05.628 --> 00:30:08.096
2.99.
This is my forbidden region

00:30:08.096 --> 00:30:10.640
here.
And 2.99 is in the forbidden

00:30:10.640 --> 00:30:12.337
region.
I'm in trouble.

00:30:12.337 --> 00:30:17.195
So notice that the lowest value
that the receiver can receive is

00:30:17.195 --> 00:30:19.893
3 volts.
So if I sent the 4 and sent

00:30:19.893 --> 00:30:24.443
this over a long cable to you,
the value can be beaten up by

00:30:24.443 --> 00:30:28.915
noise to such an extent that you
may begin receiving 3s but

00:30:28.915 --> 00:30:35.017
nothing lower than a 3.
So this is a noise margin,

00:30:35.017 --> 00:30:39.080
1 volt.
Similarly, for a 0 the noise

00:30:39.080 --> 00:30:44.187
margin is also 1 volt.
So let me label these.

00:30:44.187 --> 00:30:48.830
There are four important
thresholds here.

00:30:48.830 --> 00:30:53.705
This threshold is called VOL.
V output low.

00:30:53.705 --> 00:31:01.171
These have special meanings.
This threshold here is called

00:31:01.171 --> 00:31:06.640
VOH, V output high.
This threshold here is called V

00:31:06.640 --> 00:31:12.765
input high and this threshold
here is called V input low.

00:31:12.765 --> 00:31:19.437
So VOH simply says that senders
must send voltages higher than

00:31:19.437 --> 00:31:23.046
VOH.
Receivers must receive values

00:31:23.046 --> 00:31:28.187
higher than VIH as a 1.
So these four thresholds

00:31:28.187 --> 00:31:33.000
together give you your
threshold.

00:31:46.000 --> 00:31:50.219
For the sender gets 2.5,
what does sender do?

00:31:50.219 --> 00:31:53.479
It could do that.
So, in that case,

00:31:53.479 --> 00:31:57.794
you can do that.
If all you want to do is have

00:31:57.794 --> 00:32:03.356
one value here then what you
have is an infinitesimal value

00:32:03.356 --> 00:32:07.726
here for the forbidden region.
That's fine.

00:32:07.726 --> 00:32:09.905
It's up to you to design it
that way.

00:32:09.905 --> 00:32:12.205
You can.
But it turns out that when you

00:32:12.205 --> 00:32:14.868
design circuits,
when we see some examples in

00:32:14.868 --> 00:32:18.681
the next lecture it turns out to
be fairly practical and easy to

00:32:18.681 --> 00:32:21.284
do it this way.
But, again, these are design

00:32:21.284 --> 00:32:22.555
choices.
If I'm Intel,

00:32:22.555 --> 00:32:25.097
Intel wants all its parts to
work together.

00:32:25.097 --> 00:32:28.607
So parts that follow a common
discipline can work together,

00:32:28.607 --> 00:32:33.048
right?
Because senders will send

00:32:33.048 --> 00:32:38.902
values, receivers will receive
these values here,

00:32:38.902 --> 00:32:45.000
so it will simply work.
So the noise margin for a 1

00:32:45.000 --> 00:32:52.682
here is simply VOH minus VIH and
the noise margin for a 0 is VIL

00:32:52.682 --> 00:32:57.073
minus VOL.
VIL minus VOL is the noise

00:32:57.073 --> 00:33:02.037
margin for a 0.
So what do we have here?

00:33:02.037 --> 00:33:06.535
What we have here is a
discipline that we've agreed to

00:33:06.535 --> 00:33:11.798
follow where senders are held to
a tough standard and receivers

00:33:11.798 --> 00:33:16.806
are held to a different standard
so that I allow myself some

00:33:16.806 --> 00:33:20.201
margin for error.
And it's up to you as a

00:33:20.201 --> 00:33:24.445
designer to choose ranges for
the forbidden region.

00:33:24.445 --> 00:33:29.368
Now, you may say that I want to
make my forbidden region as

00:33:29.368 --> 00:33:34.212
small as possible.
But you will see in practical

00:33:34.212 --> 00:33:37.188
circuits it's very hard to
achieve that.

00:33:37.188 --> 00:33:41.918
Practical devices that you get,
they have a natural region that

00:33:41.918 --> 00:33:45.961
gets very, very hard to break
apart, and that tends to

00:33:45.961 --> 00:33:48.784
establish what that region looks
like.

00:33:48.784 --> 00:33:53.362
So to continue with an example
here, I may have the following

00:33:53.362 --> 00:33:57.405
voltage wave form for a sender.
So I have some sender,

00:33:57.405 --> 00:34:00.000
I have a sender here.

00:34:08.000 --> 00:34:13.365
I have VOL, VIL,
VIH, VOH and some other high

00:34:13.365 --> 00:34:17.024
voltage.
And then, as a sender,

00:34:17.024 --> 00:34:22.756
if I want to send a "0" "1" "0"
then I send a 0.

00:34:22.756 --> 00:34:29.951
I have to be within this band.
And then for a 1 I have to be

00:34:29.951 --> 00:34:35.857
within this band.
So this is an example of,

00:34:35.857 --> 00:34:41.000
say, "0" "1" "0" "1".
And at the receiver --

00:34:51.000 --> 00:34:55.461
Let's have VOL,
VIL, VIH, VOH.

00:34:55.461 --> 00:35:02.692
So at the receiver,
I interpret any signal below

00:35:02.692 --> 00:35:06.891
VIL as a 0.
So I may get some signal that

00:35:06.891 --> 00:35:08.000
looks like this.

00:35:16.000 --> 00:35:21.357
And I'll still interpret that
as a "0" "1" "0" "1".

00:35:21.357 --> 00:35:26.821
So to summarize here,
this discipline that forms the

00:35:26.821 --> 00:35:34.000
foundations of digital systems
is called "a static discipline".

00:35:41.000 --> 00:36:03.000
The static discipline says if
inputs meet input thresholds --

00:36:03.000 --> 00:36:08.560
So if an input to a digital
system meets the input

00:36:08.560 --> 00:36:14.801
thresholds then outputs will
meet, or the digital system

00:36:14.801 --> 00:36:19.000
should ensure that the outputs
--

00:36:24.000 --> 00:36:29.443
Output thresholds.
So this means that if I have a

00:36:29.443 --> 00:36:35.000
system like this then if I give
it good inputs.

00:36:35.000 --> 00:36:40.244
And by giving it good inputs I
mean for 1s I have signal values

00:36:40.244 --> 00:36:45.235
that are greater than VIH and
for 0s signal values which are

00:36:45.235 --> 00:36:48.365
less than VIL.
These are valid inputs.

00:36:48.365 --> 00:36:53.018
So if my inputs are valid,
that is below VIL for a 0 and

00:36:53.018 --> 00:36:57.755
above VIH for a 1 then this
digital system D will produce

00:36:57.755 --> 00:37:03.000
corresponding outputs that
follow output thresholds.

00:37:03.000 --> 00:37:07.832
For a 1 it will produce outputs
that are greater than VOH and if

00:37:07.832 --> 00:37:12.434
it needs to produce a 0 it will
produce outputs that are less

00:37:12.434 --> 00:37:15.272
than VOL.
So notice that there is this

00:37:15.272 --> 00:37:19.568
tough requirement in digital
systems that for the inputs,

00:37:19.568 --> 00:37:23.556
I should recognize as a 1
anything higher than a VIH.

00:37:23.556 --> 00:37:27.852
But if I want to produce a 1,
I have to produce a tough 1

00:37:27.852 --> 00:37:31.986
like a 4-volt 1.
So there is a discipline that

00:37:31.986 --> 00:37:35.890
all my digital systems must
follow, and that discipline is

00:37:35.890 --> 00:37:39.657
called a static discipline.
So static discipline encodes

00:37:39.657 --> 00:37:42.602
the thresholds,
encodes four thresholds that

00:37:42.602 --> 00:37:46.712
all digital systems must follow
so that they can talk to each

00:37:46.712 --> 00:37:49.109
other.
So if Intel and Motorola want

00:37:49.109 --> 00:37:51.712
to make parts that are
compatible with,

00:37:51.712 --> 00:37:55.410
say, Pentium 4 devices then
they will all talk over the

00:37:55.410 --> 00:38:00.000
phone or something and agree on
a static discipline.

00:38:00.000 --> 00:38:02.523
We will say that,
all right, all my peripherals

00:38:02.523 --> 00:38:05.594
will follow a static discipline
with the following volted

00:38:05.594 --> 00:38:07.624
thresholds.
And this way parts made by

00:38:07.624 --> 00:38:10.751
different manufacturers can
interoperate and still provide

00:38:10.751 --> 00:38:11.957
immunity to noise.
Yes.

00:38:11.957 --> 00:38:13.000
Question?

00:38:19.000 --> 00:38:21.767
Absolutely.
There are many constraints on

00:38:21.767 --> 00:38:24.880
how you as a designer choose the
noise margin.

00:38:24.880 --> 00:38:28.962
As a designer you want to make
your noise margin as large as

00:38:28.962 --> 00:38:32.441
possible.
The larger the noise margin the

00:38:32.441 --> 00:38:35.749
better you can tolerate noise
which is why,

00:38:35.749 --> 00:38:40.238
how many people have heard of
some devices called rad hard

00:38:40.238 --> 00:38:44.097
devices, radiation hard devices?
Some of you have.

00:38:44.097 --> 00:38:48.587
There are a bunch of devices.
Different manufacturers make

00:38:48.587 --> 00:38:52.367
different kinds of devices for
different markets.

00:38:52.367 --> 00:38:57.093
For consumer markets they use
parts which may have relatively

00:38:57.093 --> 00:39:01.267
poor noise margins because
consumers can tolerate more

00:39:01.267 --> 00:39:05.165
faults.
But if you're building devices

00:39:05.165 --> 00:39:09.352
for, say, the medical industry
or for spaceships and so on,

00:39:09.352 --> 00:39:13.106
you need to be held to a much,
much tougher standard.

00:39:13.106 --> 00:39:16.500
So for those devices you may
end up having much,

00:39:16.500 --> 00:39:20.831
much tighter bands in which you
have to operate so you have a

00:39:20.831 --> 00:39:23.791
tougher noise margin.
So that leads us to,

00:39:23.791 --> 00:39:28.050
given these sort of voltage
thresholds, we now move into the

00:39:28.050 --> 00:39:31.669
digital world.
And in the digital world we can

00:39:31.669 --> 00:39:33.392
build a bunch of digital
devices.

00:39:33.392 --> 00:39:36.461
The first device we will look
at is called a combinational

00:39:36.461 --> 00:39:37.000
gate.

00:39:42.000 --> 00:39:46.857
A combinational gate is a
device that adheres to the

00:39:46.857 --> 00:39:51.333
static discipline,
Page 11, and this is a device

00:39:51.333 --> 00:39:56.000
whose outputs are a function of
inputs alone.

00:40:03.000 --> 00:40:07.716
So I can build little boxes
which take some inputs,

00:40:07.716 --> 00:40:13.094
produces an output where the
outputs are a function of the

00:40:13.094 --> 00:40:17.245
existing inputs.
And this kind of a device is

00:40:17.245 --> 00:40:22.716
called a combinational gate.
And I can analyze such devices

00:40:22.716 --> 00:40:28.000
for the kinds of things that I
would like to do.

00:40:28.000 --> 00:40:34.068
Before I go into the kinds of
devices I'd like to build,

00:40:34.068 --> 00:40:39.917
let's spend a few minutes
talking about how to process

00:40:39.917 --> 00:40:44.220
signals.
How to process digital signals,

00:40:44.220 --> 00:40:48.082
Page 10.
So notice that you have two

00:40:48.082 --> 00:40:52.055
values, 0 and a 1.
So devices like my

00:40:52.055 --> 00:40:55.475
combinational gate,
for example,

00:40:55.475 --> 00:41:02.016
can only deal with 0s and 1s.
So I have to come up with some

00:41:02.016 --> 00:41:06.117
kind of a mathematics or some
kind of a set of processing that

00:41:06.117 --> 00:41:10.506
can work with 0,1 values.
So 0,1 map completely natural

00:41:10.506 --> 00:41:15.518
to the logic true and false.
So I can borrow from logic and

00:41:15.518 --> 00:41:19.753
use true and false to do my
processing of signals.

00:41:19.753 --> 00:41:23.987
So if all I care about is
processing logic values,

00:41:23.987 --> 00:41:29.000
0s and 1s, trues and falses
then that's all I need.

00:41:29.000 --> 00:41:33.775
I can also use numbers.
How do I represent a number?

00:41:33.775 --> 00:41:38.458
3.9 which is 0s and 1s.
It turns out that this is a

00:41:38.458 --> 00:41:43.327
whole field in itself.
You'll hear more about this in

00:41:43.327 --> 00:41:46.979
recitation.
Let me also point you to the

00:41:46.979 --> 00:41:52.130
last section of the course
notes, Chapter 5.6 I believe,

00:41:52.130 --> 00:41:57.000
that talks about how to
represent numbers.

00:41:57.000 --> 00:42:01.428
The basic insight is much like
you can represent arbitrary long

00:42:01.428 --> 00:42:05.071
numbers with the digits 0
through 9 in the same way,

00:42:05.071 --> 00:42:09.071
but concatenating digits you
can represent arbitrary long

00:42:09.071 --> 00:42:11.500
numbers with 0-1-1-1-0-0 and so
on.

00:42:11.500 --> 00:42:15.285
So you can have a whole
sequence of digits and you can

00:42:15.285 --> 00:42:19.285
build a binary number system.
So you can read A&amp;L Section

00:42:19.285 --> 00:42:22.142
5.6, I believe.
It's the last section for

00:42:22.142 --> 00:42:24.857
numbers.
And you will also discuss this

00:42:24.857 --> 00:42:31.141
in your recitation tomorrow.
Let me spend some more time

00:42:31.141 --> 00:42:36.378
talking about Boolean logic,
two-valued logic,

00:42:36.378 --> 00:42:40.101
and how to process these
systems.

00:42:40.101 --> 00:42:46.967
So one way of processing it is
using logic statements of the

00:42:46.967 --> 00:42:52.320
following form.
If X is true and Y is true then

00:42:52.320 --> 00:43:00.000
Z is true, else is Z false.
So this is a logic statement.

00:43:00.000 --> 00:43:04.468
It says if X is true and Y is
true then Z is true,

00:43:04.468 --> 00:43:08.571
else Z is false.
So I can process this with 0s

00:43:08.571 --> 00:43:13.677
and 1s, trues and falses.
And I do this all the time so I

00:43:13.677 --> 00:43:16.686
have a succinct notation for
this.

00:43:16.686 --> 00:43:20.060
I express this as Z is X anded
with Y.

00:43:20.060 --> 00:43:24.072
X and Y is Z.
So Z is true if X is true and Y

00:43:24.072 --> 00:43:27.446
is true.
A shorthand notation for this

00:43:27.446 --> 00:43:33.199
is just a dot.
And a circuit notation for this

00:43:33.199 --> 00:43:38.153
is called an "AND gate".
That's a little circuit.

00:43:38.153 --> 00:43:41.765
I haven't told you what's
inside it.

00:43:41.765 --> 00:43:47.957
It's an abstract little device
called an AND gate which takes

00:43:47.957 --> 00:43:54.459
two inputs, produces one output
Z where the output is related to

00:43:54.459 --> 00:43:59.000
the inputs in the following
manner.

00:43:59.000 --> 00:44:03.047
That's a little device called
an AND gate.

00:44:03.047 --> 00:44:07.391
I could also represent logic in
truth tables.

00:44:07.391 --> 00:44:12.821
And truth tables simply
enumerate all the values and the

00:44:12.821 --> 00:44:17.757
corresponding outputs.
Inputs can be 0-0-0-1-1-0 or

00:44:17.757 --> 00:44:21.114
1-1.
For an AND system output is 1,

00:44:21.114 --> 00:44:25.162
only if both are ones,
it's a 0 otherwise.

00:44:25.162 --> 00:44:30.000
So that's a truth table for AND
gate.

00:44:30.000 --> 00:44:36.179
So from 0s and 1s we deal with
logic and we create devices like

00:44:36.179 --> 00:44:40.066
the AND gate to process digital
signals.

00:44:40.066 --> 00:44:46.146
And what we will do is look at
a whole bunch of little symbols

00:44:46.146 --> 00:44:51.827
like this, like the AND gate to
process our input signals.

00:44:51.827 --> 00:44:57.408
And these devices might look
like other functions like OR

00:44:57.408 --> 00:45:03.138
gates and so on.
Let me show you a quick demo.

00:45:03.138 --> 00:45:09.414
What I'm going to show you is a
signal feeding an AND gate.

00:45:09.414 --> 00:45:15.906
And one signal is going to look
like this, and my signal Y is

00:45:15.906 --> 00:45:21.208
going to look like this.
So you expect a processed

00:45:21.208 --> 00:45:23.805
output.
So 1-0-1-0-1-0-1.

00:45:23.805 --> 00:45:29.000
And the output is simply going
to be --

00:45:29.000 --> 00:45:31.416
This is my time axis going this
way.

00:45:31.416 --> 00:45:35.766
It is going to be an AND-ing of
these two signal values like so.

00:45:35.766 --> 00:45:39.770
What I'm also going to show you
is I'm going to superimpose

00:45:39.770 --> 00:45:43.153
noise on this wire.
I'm going to superimpose noise

00:45:43.153 --> 00:45:47.572
on the wire, and what I want you
to observe is the output of this

00:45:47.572 --> 00:45:50.403
digital gate.
The output will stay exactly

00:45:50.403 --> 00:45:52.957
like this, even though I impose
noise.

00:45:52.957 --> 00:45:55.581
The ultimate test.
So stay right there.

00:45:55.581 --> 00:46:00.000
Let's do this demo.
Give me a couple of seconds.

00:47:42.000 --> 00:47:45.697
If you look at the signal up
there, look at the middle wave

00:47:45.697 --> 00:47:49.521
form, and I'm imposing let's
have a digital system in a noisy

00:47:49.521 --> 00:47:52.199
environment like a lumberyard,
for example,

00:47:52.199 --> 00:47:56.215
or chopping a bunch of trees in
my backyard and building digital

00:47:56.215 --> 00:48:00.140
systems on the side.
And if I have my buddies

00:48:00.140 --> 00:48:04.778
revving up chainsaws
superimposing noise on my second

00:48:04.778 --> 00:48:10.040
input, but look at the output.
And just to show that I'm not

00:48:10.040 --> 00:48:13.875
bluffing here,
what I'll do is I'll pass the

00:48:13.875 --> 00:48:17.354
noise through and make the noise
larger.

00:48:17.354 --> 00:48:22.527
And you'll notice that when the
noise begins to surpass the

00:48:22.527 --> 00:48:26.540
noise margins the output begins
to go berserk.

00:48:26.540 --> 00:48:31.000
Watch.
Can you increase it gradually?

00:48:31.000 --> 00:48:35.891
Notice that as I put in a lot
more noise then the output

00:48:35.891 --> 00:48:40.072
begins to go berserk,
but as long as my input is

00:48:40.072 --> 00:48:45.052
within the noise margin my
output stays perfectly stable.

00:48:45.052 --> 00:48:48.610
So that's the "Intro to Digital
Systems".

00:48:48.610 --> 00:48:51.456
You'll see numbers in
recitation.

00:48:51.456 --> 00:48:54.056
And we'll see you at lecture on
Tuesday.

