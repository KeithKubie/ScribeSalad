WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.402
[MUSIC PLAYING]

00:00:09.240 --> 00:00:10.760
DAN GALPIN: All right.

00:00:10.760 --> 00:00:13.410
Welcome to "Migrating
Your Android App

00:00:13.410 --> 00:00:15.240
to Android O and Beyond."

00:00:18.620 --> 00:00:19.640
FRED CHUNG: Hi.

00:00:19.640 --> 00:00:21.840
I'm Fred Chung,
developer advocate.

00:00:21.840 --> 00:00:24.350
DAN GALPIN: Hi, I'm Dan
Galpin, developer advocate.

00:00:24.350 --> 00:00:27.950
ERIC KUXHAUSEN: Hi, I'm Eric,
not a developer advocate.

00:00:27.950 --> 00:00:30.440
I'm the lead software engineer
responsible for migrating

00:00:30.440 --> 00:00:34.112
the Google Play Store
app to target API 26.

00:00:34.112 --> 00:00:36.320
DAN GALPIN: Thank you for
joining us on the afternoon

00:00:36.320 --> 00:00:37.610
of the last day.

00:00:37.610 --> 00:00:42.200
This is where they schedule
the most anticipated sessions,

00:00:42.200 --> 00:00:45.050
except for that funny improv
one that we don't record.

00:00:45.050 --> 00:00:46.370
Sorry, home viewers.

00:00:46.370 --> 00:00:49.010
So you're here
for what is really

00:00:49.010 --> 00:00:53.260
the grand finale of Google I/O.

00:00:53.260 --> 00:00:56.590
FRED CHUNG: Well, let
the grand finale begin.

00:00:56.590 --> 00:00:58.910
So, why migrate?

00:00:58.910 --> 00:01:02.300
There are lots of reasons,
but foremost in your mind,

00:01:02.300 --> 00:01:04.760
especially if you are
distributing on Google Play,

00:01:04.760 --> 00:01:11.690
is that for new apps, by the end
of this year, in August 2018,

00:01:11.690 --> 00:01:18.140
you must be targeting at least
API level 26, or Android 8.0.

00:01:18.140 --> 00:01:21.350
Likewise, for app
updates, they must also

00:01:21.350 --> 00:01:26.750
be targeting at least API
level 26 by November of 2018.

00:01:26.750 --> 00:01:28.490
That is if you wish
to continue releasing

00:01:28.490 --> 00:01:30.680
app updates going forward.

00:01:30.680 --> 00:01:32.990
DAN GALPIN: Now, every
new Android version

00:01:32.990 --> 00:01:35.750
introduces changes that
bring significant security

00:01:35.750 --> 00:01:38.240
and performance improvements,
and enhance the experience

00:01:38.240 --> 00:01:39.460
of Android overall.

00:01:39.460 --> 00:01:43.610
Some of these changes only apply
to apps that explicitly declare

00:01:43.610 --> 00:01:47.060
support through their target
SDK version manifest attribute,

00:01:47.060 --> 00:01:49.260
also known as the
target API level.

00:01:49.260 --> 00:01:52.090
In fact, if you try to
upload an APK with a target

00:01:52.090 --> 00:01:55.790
SDK less than 26, you'll begin
to see a friendly reminder

00:01:55.790 --> 00:01:57.436
like this.

00:01:57.436 --> 00:01:59.060
ERIC KUXHAUSEN: And
I'm here because we

00:01:59.060 --> 00:02:02.034
wanted to keep updating the
Play Store app on Google Play

00:02:02.034 --> 00:02:03.200
after the November deadline.

00:02:06.040 --> 00:02:08.770
FRED CHUNG: So let's go
over some basics real quick,

00:02:08.770 --> 00:02:09.949
everyone.

00:02:09.949 --> 00:02:13.960
Minimum SDK is the
lowest platform version

00:02:13.960 --> 00:02:16.120
your app is willing to support.

00:02:16.120 --> 00:02:19.390
It's often the decision
tied to market penetration

00:02:19.390 --> 00:02:22.590
of various Android releases.

00:02:22.590 --> 00:02:24.730
DAN GALPIN: The compile
SDK is literally

00:02:24.730 --> 00:02:28.569
the SDK headers and stub library
that your project links to.

00:02:28.569 --> 00:02:30.610
ERIC KUXHAUSEN: And the
important one, of course,

00:02:30.610 --> 00:02:32.540
is the one I'm talking about.

00:02:32.540 --> 00:02:35.470
The targetSdkVersion
is the platform's way

00:02:35.470 --> 00:02:37.570
to ensure backwards
compatibility.

00:02:37.570 --> 00:02:39.820
This means that you only
have certain behavior

00:02:39.820 --> 00:02:45.980
changes applied as certain
specific target SDK versions.

00:02:45.980 --> 00:02:51.240
FRED CHUNG: So, technically,
this needs to be true.

00:02:51.240 --> 00:02:54.840
And this is the typical
and recommended case,

00:02:54.840 --> 00:02:58.439
since you probably
care, about 95% of users

00:02:58.439 --> 00:03:00.480
out there that are not
quite targeting the latest

00:03:00.480 --> 00:03:03.300
versions of Androids
just yet, although we

00:03:03.300 --> 00:03:06.040
are working to improve that.

00:03:06.040 --> 00:03:08.250
DAN GALPIN: So if you
don't change your target

00:03:08.250 --> 00:03:11.790
SDK to at least version
26, you might not

00:03:11.790 --> 00:03:14.730
have to deal with things
like runtime permissions,

00:03:14.730 --> 00:03:18.060
AlarmManager changes, coming
up with different ways

00:03:18.060 --> 00:03:20.250
to handle
BroadcastReceiver actions,

00:03:20.250 --> 00:03:22.172
and avoiding
background services.

00:03:22.172 --> 00:03:23.880
ERIC KUXHAUSEN: But
there's a good chance

00:03:23.880 --> 00:03:26.040
that your app would waste
network and battery,

00:03:26.040 --> 00:03:30.440
while making the device
experience less fast and fluid.

00:03:30.440 --> 00:03:34.890
FRED CHUNG: So if you are
migrating from a pre-M version,

00:03:34.890 --> 00:03:38.050
one of the bigger changes
is probably the support

00:03:38.050 --> 00:03:40.180
for runtime permissions.

00:03:40.180 --> 00:03:44.600
Runtime permissions are really
about user privacy and trust.

00:03:44.600 --> 00:03:48.190
But it also allows for apps to
ask for sensitive permissions

00:03:48.190 --> 00:03:48.795
in context.

00:03:48.795 --> 00:03:50.170
And that's a good
thing for apps,

00:03:50.170 --> 00:03:53.890
because you don't want someone
to not install your apps

00:03:53.890 --> 00:03:56.740
just because you are
asking for permission

00:03:56.740 --> 00:03:59.760
for some sensitive information
in one particular flow

00:03:59.760 --> 00:04:02.440
within your app.

00:04:02.440 --> 00:04:05.610
So, first of all,
not all permissions

00:04:05.610 --> 00:04:11.360
are runtime ones, just this
simple, easy to remember this.

00:04:11.360 --> 00:04:13.380
FRED CHUNG: But worry
not, developers.

00:04:13.380 --> 00:04:15.046
You can think of the
permissions the way

00:04:15.046 --> 00:04:17.529
the user sees them in terms
of these broader categories.

00:04:17.529 --> 00:04:19.112
And the first question
you should have

00:04:19.112 --> 00:04:22.130
is whether the app really
needs the provision at all.

00:04:22.130 --> 00:04:24.310
After all, removing
the permission is easy.

00:04:24.310 --> 00:04:27.314
Now, Eric, how did the
Play Store app handle this?

00:04:27.314 --> 00:04:28.730
ERIC KUXHAUSEN:
Well, it's simple.

00:04:28.730 --> 00:04:30.605
All you need to do is
make sure that your app

00:04:30.605 --> 00:04:33.910
has pre-granted the permissions
on the system image.

00:04:33.910 --> 00:04:35.800
FRED CHUNG: That's not
very helpful, Eric.

00:04:35.800 --> 00:04:38.008
ERIC KUXHAUSEN: That being
said, we, too, try and use

00:04:38.008 --> 00:04:40.220
as few of these as possible.

00:04:40.220 --> 00:04:43.870
DAN GALPIN: And, of course,
just because your app isn't yet

00:04:43.870 --> 00:04:46.570
targeting M, it doesn't
mean that your users can't

00:04:46.570 --> 00:04:50.135
go and disable any permissions
they don't want you to have.

00:04:50.135 --> 00:04:52.010
FRED CHUNG: And there
are special permissions

00:04:52.010 --> 00:04:55.280
that you need to redirect the
user to settings to obtain.

00:04:55.280 --> 00:04:58.280
For example, drawing
overlay windows, or there

00:04:58.280 --> 00:05:00.230
could be some
procession permissions

00:05:00.230 --> 00:05:03.161
like screen capture.

00:05:03.161 --> 00:05:04.910
DAN GALPIN: Now, being
the work of the UI,

00:05:04.910 --> 00:05:08.120
runtime permissions actually
require an activity or fragment

00:05:08.120 --> 00:05:10.610
that has overridden the
onRequestPermissionResult

00:05:10.610 --> 00:05:11.169
method.

00:05:11.169 --> 00:05:12.710
Now, this means that
your view layer,

00:05:12.710 --> 00:05:14.200
like activities
and fragments, need

00:05:14.200 --> 00:05:16.880
to anticipate any
permissions actually required

00:05:16.880 --> 00:05:19.160
by the other layers.

00:05:19.160 --> 00:05:21.140
All right, here's
a great transition.

00:05:21.140 --> 00:05:24.500
Let's talk about alarms.

00:05:24.500 --> 00:05:27.140
Alarms in Android
take two basic forms.

00:05:27.140 --> 00:05:30.937
They are literal alarms that
allow an app to wake itself up

00:05:30.937 --> 00:05:33.020
to deliver a notification
of some real-time event,

00:05:33.020 --> 00:05:36.830
such as waking you up, or
an upcoming appointment.

00:05:36.830 --> 00:05:38.640
Or they are a way
of scheduling work

00:05:38.640 --> 00:05:42.530
to happen at some time in the
future after the app is closed.

00:05:42.530 --> 00:05:47.420
And at the beginning of
Android, this was a single API.

00:05:47.420 --> 00:05:51.110
But back in KitKat, we
made AlarmManager not exact

00:05:51.110 --> 00:05:53.630
unless it was
explicitly requested,

00:05:53.630 --> 00:05:56.510
which makes it better for
scheduling future work.

00:05:56.510 --> 00:05:59.540
Now if an app needs to notify
the user at a precise time,

00:05:59.540 --> 00:06:01.934
we added the method setExact.

00:06:01.934 --> 00:06:03.350
And here's where
we've implemented

00:06:03.350 --> 00:06:06.975
a method in the support library
to call it on KitKat and above.

00:06:06.975 --> 00:06:09.600
ERIC KUXHAUSEN: We don't use any
exact alarms in the Play Store

00:06:09.600 --> 00:06:10.340
app.

00:06:10.340 --> 00:06:12.830
The alarms we do
use are inexact,

00:06:12.830 --> 00:06:15.140
which allows the system
to batch them for better

00:06:15.140 --> 00:06:17.060
battery and system health.

00:06:17.060 --> 00:06:18.560
DAN GALPIN: Now,
Android Marshmallow

00:06:18.560 --> 00:06:20.601
added doze, which allowed
Android to go idle when

00:06:20.601 --> 00:06:22.250
alarms would normally fire.

00:06:22.250 --> 00:06:27.410
So we added the obvious method,
setExactAndAllowWhileIdle,

00:06:27.410 --> 00:06:29.897
to allow alarms to awake
the device from doze.

00:06:29.897 --> 00:06:32.480
And we've implemented a method
in the support library for that

00:06:32.480 --> 00:06:33.390
as well.

00:06:33.390 --> 00:06:36.500
And note that it actually calls
the previous support library

00:06:36.500 --> 00:06:41.910
method for setExact on
earlier platform versions.

00:06:41.910 --> 00:06:44.400
FRED CHUNG: So after
all that exposition,

00:06:44.400 --> 00:06:46.980
so the takeaways are
pretty simple, right?

00:06:46.980 --> 00:06:52.680
Consider moving future work
to GCM job via WorkManager.

00:06:52.680 --> 00:06:55.920
WorkManager is the new
work scheduling thing

00:06:55.920 --> 00:06:57.120
that we launched.

00:06:57.120 --> 00:07:00.090
DAN GALPIN: Now WorkManager
is a part of Jetpack.

00:07:00.090 --> 00:07:02.490
And it chooses the best
way to run your tasks

00:07:02.490 --> 00:07:06.900
based upon things such as
API version and app state.

00:07:06.900 --> 00:07:10.980
And when it becomes stable,
it will be the recommended API

00:07:10.980 --> 00:07:13.980
for running tasks, unless
we come up with something

00:07:13.980 --> 00:07:15.685
better before then.

00:07:15.685 --> 00:07:18.060
ERIC KUXHAUSEN: Play Store
was able to see our background

00:07:18.060 --> 00:07:22.350
tasks regularly reach
2% more users on KitKat

00:07:22.350 --> 00:07:25.140
when we adopted Firebase
JobDispatcher, rather than just

00:07:25.140 --> 00:07:26.350
using alarms.

00:07:26.350 --> 00:07:29.220
This improves system
health and battery usage.

00:07:29.220 --> 00:07:32.700
If you do have to use alarms,
use the least exact ones

00:07:32.700 --> 00:07:34.080
you can.

00:07:34.080 --> 00:07:36.390
FRED CHUNG: Now, remember
that the most exact alarms,

00:07:36.390 --> 00:07:40.450
like [INAUDIBLE],, should only
be used every 15 minutes or so.

00:07:40.450 --> 00:07:43.022
So you should only be
using those judiciously.

00:07:45.800 --> 00:07:47.910
DAN GALPIN: Oh,
yeah, WorkManager.

00:07:47.910 --> 00:07:49.865
So let's talk again
about BroadcastReceiver.

00:07:49.865 --> 00:07:51.990
FRED CHUNG: Should we talk
about BroadcastReceiver?

00:07:51.990 --> 00:07:52.510
DAN GALPIN: We should
talk about them.

00:07:52.510 --> 00:07:53.593
FRED CHUNG: Let's do that.

00:07:53.593 --> 00:07:54.930
DAN GALPIN: Yes.

00:07:54.930 --> 00:07:56.517
FRED CHUNG: So
BroadcastReceiver, I

00:07:56.517 --> 00:07:58.350
think many of you
probably know that, right?

00:07:58.350 --> 00:08:01.680
That's used by the platform
to notify and launch

00:08:01.680 --> 00:08:05.130
apps in response to
system-wide events.

00:08:05.130 --> 00:08:08.040
It's one of the reasons that
Android has such a powerful API

00:08:08.040 --> 00:08:08.910
service.

00:08:08.910 --> 00:08:13.710
DAN GALPIN: Now with great power
comes great responsibility.

00:08:13.710 --> 00:08:16.380
And, in response to the
way that these end points

00:08:16.380 --> 00:08:20.760
have been used, most of these
can no longer launch your app,

00:08:20.760 --> 00:08:24.237
at least once you target O.

00:08:24.237 --> 00:08:26.320
FRED CHUNG: Well, there
are exceptions, of course.

00:08:26.320 --> 00:08:29.760
It's Android, right?

00:08:29.760 --> 00:08:31.920
Many of these
happen very rarely,

00:08:31.920 --> 00:08:33.929
such as changes in locale.

00:08:33.929 --> 00:08:37.110
Or, in some cases, there are
just no alternatives just yet

00:08:37.110 --> 00:08:40.590
to the broadcast for the apps
that need them, for example,

00:08:40.590 --> 00:08:44.800
like those USB accessory ones.

00:08:44.800 --> 00:08:48.610
Let's check an example on how
to avoid using broadcasts.

00:08:48.610 --> 00:08:52.570
So for a job, you can do so by
setting up the proper execution

00:08:52.570 --> 00:08:55.804
criteria, suggest
requiring network service,

00:08:55.804 --> 00:08:57.220
and then we can
have functionality

00:08:57.220 --> 00:09:00.400
that's comparable to listening
to network state change

00:09:00.400 --> 00:09:02.990
broadcasts.

00:09:02.990 --> 00:09:06.080
And if you do have code
like this in your manifest

00:09:06.080 --> 00:09:08.600
on the older
versions of Android,

00:09:08.600 --> 00:09:13.910
you can disable the listener
to the connectivity change,

00:09:13.910 --> 00:09:16.010
and just leave it disabled.

00:09:16.010 --> 00:09:17.540
And then, what are
you going to do?

00:09:17.540 --> 00:09:19.790
You can then enable
the receiver by setting

00:09:19.790 --> 00:09:24.486
the ComponentEnableSetting
in the PackageManager.

00:09:24.486 --> 00:09:25.860
ERIC KUXHAUSEN:
Another exception

00:09:25.860 --> 00:09:28.980
is if you need to perform many
tasks after your pack has been

00:09:28.980 --> 00:09:32.190
updated, for example,
rescheduling alarms or updating

00:09:32.190 --> 00:09:33.515
your database.

00:09:33.515 --> 00:09:34.890
You can still
register a receiver

00:09:34.890 --> 00:09:38.269
in your manifest for the
action_my_package_replaced,

00:09:38.269 --> 00:09:39.810
which continues to
work, because it's

00:09:39.810 --> 00:09:42.432
one of the explicit broadcasts
targeted just to your app.

00:09:42.432 --> 00:09:43.890
DAN GALPIN: Now,
if you really need

00:09:43.890 --> 00:09:47.050
to do some work in
every package update,

00:09:47.050 --> 00:09:49.500
and you probably
don't, because you

00:09:49.500 --> 00:09:52.600
can no longer be launched by
action_package_replace_events.

00:09:52.600 --> 00:09:55.626
But we do have an API
called getChangedPackages,

00:09:55.626 --> 00:09:57.000
which allows your
app to see what

00:09:57.000 --> 00:10:01.950
packages have changed since the
previous saved sequence number.

00:10:01.950 --> 00:10:05.390
Now, in life, running
is usually healthy.

00:10:05.390 --> 00:10:06.485
I probably should do more.

00:10:06.485 --> 00:10:09.410
But an Android app wants to
run as little as possible.

00:10:09.410 --> 00:10:11.780
And lazy apps are
actually better apps.

00:10:11.780 --> 00:10:13.820
And I should make a
manifesto or something.

00:10:13.820 --> 00:10:16.400
Fred, what do you think
that we should actually--

00:10:16.400 --> 00:10:19.070
FRED CHUNG: Sounds good to me.

00:10:19.070 --> 00:10:22.130
First of all, let's
talk about what

00:10:22.130 --> 00:10:24.920
it means to be in
the foreground,

00:10:24.920 --> 00:10:27.270
because it's not
completely obvious, right?

00:10:27.270 --> 00:10:29.570
There are some typical
cases, like when

00:10:29.570 --> 00:10:32.510
your app is visible to
users, or when you're

00:10:32.510 --> 00:10:35.000
using foreground service,
or if your app is

00:10:35.000 --> 00:10:38.710
bound to a foreground app.

00:10:38.710 --> 00:10:40.840
So your app is also
in the foreground

00:10:40.840 --> 00:10:44.160
in these exceptional cases.

00:10:44.160 --> 00:10:47.980
Your app is in the background
when you're not visible,

00:10:47.980 --> 00:10:50.980
such as when it's running
a standard service, job

00:10:50.980 --> 00:10:54.690
service, or BroadcastReceiver.

00:10:54.690 --> 00:10:57.089
And when you're on O+.

00:10:57.089 --> 00:10:59.130
Starting a service when
running in the background

00:10:59.130 --> 00:11:02.350
will throw an exception
called IllegalStateException,

00:11:02.350 --> 00:11:03.670
which is not good.

00:11:03.670 --> 00:11:04.860
DAN GALPIN: Now you
can start services when

00:11:04.860 --> 00:11:05.940
your app is in the foreground.

00:11:05.940 --> 00:11:07.856
And they'll continue to
run for about a minute

00:11:07.856 --> 00:11:09.612
after your app is backgrounded.

00:11:09.612 --> 00:11:11.070
And this is
particularly important,

00:11:11.070 --> 00:11:13.620
because on O, the
system releases

00:11:13.620 --> 00:11:15.420
any wake locks
that your app holds

00:11:15.420 --> 00:11:17.940
when you have no active
components, such as activities

00:11:17.940 --> 00:11:18.510
or services.

00:11:18.510 --> 00:11:23.166
And this applies to all apps,
not just apps targeting O.

00:11:23.166 --> 00:11:25.540
FRED CHUNG: There are a few
cases where your app is still

00:11:25.540 --> 00:11:28.090
allowed to run if
it's foreground

00:11:28.090 --> 00:11:32.740
and start services, for example,
in response to notification

00:11:32.740 --> 00:11:36.700
action, a high priority
Firebase Cloud message,

00:11:36.700 --> 00:11:41.180
or in response to
MMS or SMS delivery.

00:11:41.180 --> 00:11:43.140
So let's talk through
some solutions

00:11:43.140 --> 00:11:47.570
for running in the background
without background services.

00:11:47.570 --> 00:11:51.610
DAN GALPIN: First of all,
use GCM fire job-- ah!--

00:11:51.610 --> 00:11:54.470
WorkManager for
background tasks.

00:11:54.470 --> 00:11:57.010
Now there are very many
good reasons for this.

00:11:57.010 --> 00:11:59.980
It creates a consistent API
service across many Android

00:11:59.980 --> 00:12:01.295
versions, for example.

00:12:01.295 --> 00:12:03.670
ERIC KUXHAUSEN: Or if you
don't care as much about having

00:12:03.670 --> 00:12:06.340
your app behave consistently
across platforms,

00:12:06.340 --> 00:12:09.350
or want to move to O with the
least amount of work required,

00:12:09.350 --> 00:12:11.060
you can also use
JobIntentService.

00:12:11.060 --> 00:12:13.570
DAN GALPIN: But, seriously,
consider using WorkManager.

00:12:13.570 --> 00:12:15.740
Leverage its constraints
and make your life easier.

00:12:18.270 --> 00:12:20.510
ERIC KUXHAUSEN: So the
Google Play Store app

00:12:20.510 --> 00:12:23.030
didn't have the luxury
of using WorkManager,

00:12:23.030 --> 00:12:24.710
because it didn't exist yet.

00:12:24.710 --> 00:12:27.710
That meant we had to use
JobScheduler and Firebase

00:12:27.710 --> 00:12:29.180
JobDispatcher.

00:12:29.180 --> 00:12:31.070
Now, the first thing
we learned is not

00:12:31.070 --> 00:12:33.950
to use JobScheduler
on Android L,

00:12:33.950 --> 00:12:35.450
unless you really
understand how it

00:12:35.450 --> 00:12:38.300
behaves, and have
alarm watchdogs when

00:12:38.300 --> 00:12:40.880
it doesn't behave as expected.

00:12:40.880 --> 00:12:43.130
Also, use workarounds.

00:12:43.130 --> 00:12:46.670
For example, on L and
the first release of M,

00:12:46.670 --> 00:12:52.310
JobScheduler won't
actually run your job,

00:12:52.310 --> 00:12:55.850
unless there are two jobs
with the same constraints met.

00:12:55.850 --> 00:12:58.220
You can work around this
by scheduling two jobs

00:12:58.220 --> 00:13:00.140
with matching constraints.

00:13:00.140 --> 00:13:02.250
DAN GALPIN: But, seriously,
like WorkManager.

00:13:02.250 --> 00:13:04.114
FRED CHUNG: WorkManager.

00:13:04.114 --> 00:13:06.530
ERIC KUXHAUSEN: Things do get
much better for JobScheduler

00:13:06.530 --> 00:13:10.030
on M, MR1, and above.

00:13:10.030 --> 00:13:12.020
However, another
quirk is that you

00:13:12.020 --> 00:13:14.750
should avoid calling set
minimum latency to zero.

00:13:14.750 --> 00:13:16.250
This can interfere
with the override

00:13:16.250 --> 00:13:18.410
deadline on some releases.

00:13:18.410 --> 00:13:20.300
The override deadline
is a way of making sure

00:13:20.300 --> 00:13:22.890
that your job runs with
a fixed period of time,

00:13:22.890 --> 00:13:25.280
even if the
constraints aren't met.

00:13:25.280 --> 00:13:27.260
DAN GALPIN: Or
you could just use

00:13:27.260 --> 00:13:29.870
WorkManager, which
doesn't actually

00:13:29.870 --> 00:13:31.610
have override deadlines.

00:13:31.610 --> 00:13:34.040
But what you should do
is schedule a second job

00:13:34.040 --> 00:13:37.299
as a watchdog to perform
a similar function.

00:13:37.299 --> 00:13:38.840
ERIC KUXHAUSEN: Here
are a few things

00:13:38.840 --> 00:13:42.230
to consider when using
JobScheduler or WorkManager.

00:13:42.230 --> 00:13:45.350
Android tries to detect captive
portal and [INAUDIBLE] never

00:13:45.350 --> 00:13:48.170
conditions, but is
an imperfect art.

00:13:48.170 --> 00:13:50.510
In addition, Android
will occasionally

00:13:50.510 --> 00:13:52.370
wake up your app
right before network

00:13:52.370 --> 00:13:53.840
is available to your app.

00:13:53.840 --> 00:13:57.260
All this means is that you need
to have proper error handling

00:13:57.260 --> 00:13:59.560
to ensure rescheduling of jobs.

00:13:59.560 --> 00:14:01.580
When Play Store added
exponential backoff

00:14:01.580 --> 00:14:08.300
to our jobs, we saw 19% more
successful background tasks.

00:14:08.300 --> 00:14:11.510
The key here, though, is
let the system do its work.

00:14:11.510 --> 00:14:14.660
It's easy to make the mistake of
rescheduling with the same job

00:14:14.660 --> 00:14:17.510
ID, while also using
system backoffs.

00:14:17.510 --> 00:14:20.570
This can interfere, or even
reset, the backoff rate.

00:14:20.570 --> 00:14:23.480
DAN GALPIN: Or
with WorkManager--

00:14:23.480 --> 00:14:25.070
actually, yeah,
don't do that either,

00:14:25.070 --> 00:14:29.000
because it'll have
the same result.

00:14:29.000 --> 00:14:31.960
FRED CHUNG: So for
APIs that require

00:14:31.960 --> 00:14:35.670
that you use PendingIntents,
you can change the PendingIntent

00:14:35.670 --> 00:14:40.010
targets from service
to a BroadcastReceiver.

00:14:40.010 --> 00:14:43.820
Now, if your task will
execute within 30 seconds,

00:14:43.820 --> 00:14:46.810
you can then call goAsync
and run your work right

00:14:46.810 --> 00:14:49.090
within the BroadcastReceiver,
which, by the way,

00:14:49.090 --> 00:14:52.720
is a super lightweight way
of getting something done.

00:14:52.720 --> 00:14:55.990
Note that you aren't guaranteed
to have network or wakelocks.

00:14:55.990 --> 00:14:58.550
So there are still many
cases where you should--

00:14:58.550 --> 00:15:01.030
DAN GALPIN: Schedule a job
within your BroadcastReceiver

00:15:01.030 --> 00:15:04.500
using a WorkManager.

00:15:04.500 --> 00:15:06.460
FRED CHUNG: So, if
you have externally

00:15:06.460 --> 00:15:09.740
triggered time-sensitive events
that require immediate user

00:15:09.740 --> 00:15:12.440
attention, consider
using Firebase Cloud

00:15:12.440 --> 00:15:14.640
Messaging to notify your app.

00:15:14.640 --> 00:15:18.590
FCM supports high and
normal priority messaging

00:15:18.590 --> 00:15:20.710
for high priority messages.

00:15:20.710 --> 00:15:24.230
It'll wake the device from doze,
which means that a lot of them

00:15:24.230 --> 00:15:27.050
won't be a good thing
for system health.

00:15:27.050 --> 00:15:31.640
If the task can run within
less than 10 seconds or so,

00:15:31.640 --> 00:15:32.930
you can execute it right away.

00:15:32.930 --> 00:15:34.760
Or else schedule a job with--

00:15:34.760 --> 00:15:37.160
DAN GALPIN: WorkManager.

00:15:37.160 --> 00:15:39.800
There are actually cases
when foreground services

00:15:39.800 --> 00:15:41.750
are desired or required.

00:15:41.750 --> 00:15:44.900
Ideally, these are
user-initiated tasks

00:15:44.900 --> 00:15:47.360
that run for a
long time and want

00:15:47.360 --> 00:15:49.880
to supply some sort of
constant update to the user.

00:15:49.880 --> 00:15:54.260
Examples are maps,
navigation fitness tracking,

00:15:54.260 --> 00:15:55.795
playing music.

00:15:55.795 --> 00:15:57.170
ERIC KUXHAUSEN:
In Play Store, we

00:15:57.170 --> 00:15:59.240
use a foreground service
when we restore apps

00:15:59.240 --> 00:16:00.570
after device set up.

00:16:00.570 --> 00:16:03.440
This is OK, because it's
long running work in response

00:16:03.440 --> 00:16:04.490
to user interaction.

00:16:04.490 --> 00:16:08.790
DAN GALPIN: But it's not as
fun as listening to music.

00:16:08.790 --> 00:16:11.530
FRED CHUNG: Some good news is
that these other things are

00:16:11.530 --> 00:16:13.270
already impacting your apps.

00:16:13.270 --> 00:16:15.230
But perhaps you
haven't noticed yet.

00:16:18.440 --> 00:16:20.170
That.

00:16:20.170 --> 00:16:24.190
So, in Android N,
new photo broadcasts

00:16:24.190 --> 00:16:28.410
no longer happen, but can be
replaced by TriggerContentUris

00:16:28.410 --> 00:16:32.180
for jobs, I mean, work.

00:16:32.180 --> 00:16:37.037
So, here's what it looks like
using the new WorkManager API.

00:16:37.037 --> 00:16:39.370
DAN GALPIN: Now if your app
is running in the background

00:16:39.370 --> 00:16:43.000
on an Android O+ device,
the location system service

00:16:43.000 --> 00:16:45.880
computes a new location
for your app less often,

00:16:45.880 --> 00:16:48.730
even if your app requests
more frequent updates.

00:16:48.730 --> 00:16:52.810
Even full Wi-Fi scans are only
performed for background apps

00:16:52.810 --> 00:16:54.109
a few times every hour.

00:16:54.109 --> 00:16:56.650
So if you're called more often,
the Wi-Fi Manager [INAUDIBLE]

00:16:56.650 --> 00:17:00.025
actually just provide
cache results.

00:17:00.025 --> 00:17:02.020
Now, if you need to know
when the user reaches

00:17:02.020 --> 00:17:05.530
a specific location,
use geofencing.

00:17:05.530 --> 00:17:08.231
Now, there are only 100
geofences that can be active.

00:17:08.231 --> 00:17:09.730
So if you need more
sites than that,

00:17:09.730 --> 00:17:11.770
you can actually use
regional geofences

00:17:11.770 --> 00:17:15.301
to swap in and out different
sets of geofences as needed.

00:17:15.301 --> 00:17:16.780
Now, that being said--

00:17:16.780 --> 00:17:20.740
beacons are awesome-- you can
use the nearby notifications

00:17:20.740 --> 00:17:21.280
API.

00:17:21.280 --> 00:17:23.260
And that's important,
particularly

00:17:23.260 --> 00:17:26.847
if you're a certain
prolific coffee vendor.

00:17:26.847 --> 00:17:28.930
ERIC KUXHAUSEN: You can
also use the batch version

00:17:28.930 --> 00:17:31.150
of the FusedLocationProvider.

00:17:31.150 --> 00:17:33.130
Specify a maximum
location update

00:17:33.130 --> 00:17:35.920
wait time that is acceptable
for your use case.

00:17:35.920 --> 00:17:39.580
And the system will attempt
to batch location updates,

00:17:39.580 --> 00:17:41.860
so that your app is
woken up less frequently.

00:17:41.860 --> 00:17:44.900
This will optimize battery use.

00:17:44.900 --> 00:17:46.930
You can also use
passive location.

00:17:46.930 --> 00:17:50.350
That enables your app to
opportunistically piggyback

00:17:50.350 --> 00:17:53.230
on other apps' location
updates, up to the fastest

00:17:53.230 --> 00:17:54.649
interval specified.

00:17:54.649 --> 00:17:57.190
Keep in mind, though, that if
your app's location updates are

00:17:57.190 --> 00:17:59.850
tied to any expensive
operations, such as network

00:17:59.850 --> 00:18:02.980
calls, you should
throttle those as well.

00:18:02.980 --> 00:18:07.390
FRED CHUNG: So, through
batching and passive location,

00:18:07.390 --> 00:18:09.760
we can work with location
updates in a power

00:18:09.760 --> 00:18:11.310
efficient manner.

00:18:11.310 --> 00:18:13.750
Next, let's go through
some related improvements

00:18:13.750 --> 00:18:15.860
in the platform.

00:18:15.860 --> 00:18:18.580
So, in the past several
releases of Android,

00:18:18.580 --> 00:18:21.490
we've introduced a series of
battery optimization features

00:18:21.490 --> 00:18:26.290
that are based on deferring and
restricting background tasks.

00:18:26.290 --> 00:18:30.040
So you probably are familiar
with some of these already.

00:18:30.040 --> 00:18:33.580
For example, a device
could enter doze,

00:18:33.580 --> 00:18:36.460
when the device is unplugged,
and when the device isn't

00:18:36.460 --> 00:18:38.440
being used for quite some time.

00:18:38.440 --> 00:18:41.710
In doze, apps have
to finish any pending

00:18:41.710 --> 00:18:45.190
jobs in some periodic
maintenance windows.

00:18:45.190 --> 00:18:47.650
DAN GALPIN: On N+, doze is
extended for on the go use

00:18:47.650 --> 00:18:51.580
cases, such as when a device is
sitting in the user's pocket.

00:18:51.580 --> 00:18:53.980
Now, app standby
was introduced in M,

00:18:53.980 --> 00:18:56.590
where it imposes tax
restrictions based

00:18:56.590 --> 00:18:58.450
upon app usage.

00:18:58.450 --> 00:19:01.360
ERIC KUXHAUSEN: And let me tell
you about the brand new stuff.

00:19:01.360 --> 00:19:03.970
In Android P,
usage-based restrictions

00:19:03.970 --> 00:19:06.504
are applied in a more
fine-grained way.

00:19:06.504 --> 00:19:08.920
You may have already learned
about this in the earlier I/O

00:19:08.920 --> 00:19:12.700
talk, "Don't Let Your App
Drain Your User's Battery."

00:19:12.700 --> 00:19:15.040
Apps will be added to one
of the app's standby buckets

00:19:15.040 --> 00:19:16.380
based on usage.

00:19:16.380 --> 00:19:19.330
The system applies progressively
more restrictions to your app

00:19:19.330 --> 00:19:22.840
as it goes from the
active to the rare bucket.

00:19:22.840 --> 00:19:25.230
Additionally, battery
saver is enhanced

00:19:25.230 --> 00:19:27.490
in P. It allows users
to have extended

00:19:27.490 --> 00:19:31.470
battery life by prioritizing
battery over everything else.

00:19:31.470 --> 00:19:33.700
This leads to some
degradation in functionality,

00:19:33.700 --> 00:19:36.250
such as location requests,
which are not available

00:19:36.250 --> 00:19:38.032
when the screen is off.

00:19:38.032 --> 00:19:39.490
However, this mode
is really useful

00:19:39.490 --> 00:19:43.870
when you need your device
to last just a bit longer.

00:19:43.870 --> 00:19:46.030
FRED CHUNG: So, the features
that we just discussed

00:19:46.030 --> 00:19:49.410
have additive impact
on an app's alarms,

00:19:49.410 --> 00:19:53.650
jobs, sync, network
access, and FCM messages.

00:19:53.650 --> 00:19:55.600
So we really strongly
encourage everyone

00:19:55.600 --> 00:19:58.360
to thoroughly test
these scenarios

00:19:58.360 --> 00:19:59.730
within your applications.

00:19:59.730 --> 00:20:03.000
DAN GALPIN: And the good news is
that there are tools for that.

00:20:03.000 --> 00:20:04.570
So, for example,
this ADB command

00:20:04.570 --> 00:20:09.460
forces the device into an idle
state, making all apps doze.

00:20:09.460 --> 00:20:11.080
ERIC KUXHAUSEN: To
test app standby,

00:20:11.080 --> 00:20:13.430
first simulate
unplugging the device.

00:20:13.430 --> 00:20:15.700
And then you can use the get
and set inactive commands

00:20:15.700 --> 00:20:19.040
to get the device in
and out of app standby.

00:20:19.040 --> 00:20:21.070
FRED CHUNG: For app
standby buckets,

00:20:21.070 --> 00:20:25.090
you can get and set buckets
for a given package using

00:20:25.090 --> 00:20:26.140
similar AD commands.

00:20:26.140 --> 00:20:27.640
But remember to
simulate unplugging

00:20:27.640 --> 00:20:30.010
your device before testing.

00:20:30.010 --> 00:20:34.920
There's also framework
APIs available to do that.

00:20:34.920 --> 00:20:39.620
Finally, these are commands
for testing battery saver.

00:20:39.620 --> 00:20:43.610
One note is that if your
app's UI has a dark theme,

00:20:43.610 --> 00:20:45.500
you can consider
enabling the dark theme

00:20:45.500 --> 00:20:48.680
when battery saver is turned
on to further to conserve power

00:20:48.680 --> 00:20:50.900
on OLED devices.

00:20:50.900 --> 00:20:54.020
Through PowerManager,
you can check with an API

00:20:54.020 --> 00:20:56.547
and listen to a
broadcast to do that.

00:20:56.547 --> 00:20:58.130
DAN GALPIN: So, there
are lots of ways

00:20:58.130 --> 00:21:00.470
to make your apps do cool
stuff in the background

00:21:00.470 --> 00:21:02.870
without using
foreground services.

00:21:02.870 --> 00:21:06.500
Leverage the new
functionality in WorkManager,

00:21:06.500 --> 00:21:09.860
use efficient location
strategies, use the new APIs,

00:21:09.860 --> 00:21:11.690
and make sure to
tell us what doesn't

00:21:11.690 --> 00:21:13.940
meet your needs by
submitting feedback

00:21:13.940 --> 00:21:16.798
through the issue tracker.

00:21:16.798 --> 00:21:18.420
FRED CHUNG: So, right
after this talk,

00:21:18.420 --> 00:21:21.000
you'll probably be busy
updating your target

00:21:21.000 --> 00:21:22.800
SDKs, which is all good.

00:21:22.800 --> 00:21:24.810
While you are at it,
we strongly encourage

00:21:24.810 --> 00:21:29.400
you to check out some selected,
modern features on Android that

00:21:29.400 --> 00:21:30.885
are relevant to your use cases.

00:21:33.900 --> 00:21:37.710
So you have to add, for
example, notification channels

00:21:37.710 --> 00:21:41.430
to your app on O. Otherwise,
well, notifications just won't

00:21:41.430 --> 00:21:43.290
show, which won't be good.

00:21:43.290 --> 00:21:46.710
Plan your channels carefully, so
that your users can selectively

00:21:46.710 --> 00:21:50.910
turn off notifications
that they don't want.

00:21:50.910 --> 00:21:52.730
DAN GALPIN: Back
one slide, please.

00:21:52.730 --> 00:21:55.188
ERIC KUXHAUSEN: On devices
where the Play Store implemented

00:21:55.188 --> 00:21:56.610
support for
notification channels,

00:21:56.610 --> 00:21:59.220
we see a fewer percentage
of users disabling

00:21:59.220 --> 00:22:02.820
all of our notifications.

00:22:02.820 --> 00:22:05.450
DAN GALPIN: So if your app is
using a translucent status bar,

00:22:05.450 --> 00:22:07.640
you can use the inset
APIs to make sure

00:22:07.640 --> 00:22:10.460
that your code doesn't assume
that the status bar is a fixed

00:22:10.460 --> 00:22:11.220
size.

00:22:11.220 --> 00:22:13.040
Now, if you're using
the navigation drawer,

00:22:13.040 --> 00:22:14.510
this is actually really common.

00:22:14.510 --> 00:22:16.010
Now if you target
P, you can also

00:22:16.010 --> 00:22:18.540
do something interesting
in that cutout area.

00:22:18.540 --> 00:22:20.960
Now, public service
announcement,

00:22:20.960 --> 00:22:22.350
you don't have to
put your system

00:22:22.350 --> 00:22:24.390
image on your only device.

00:22:24.390 --> 00:22:26.270
If you haven't used the
emulator in a while,

00:22:26.270 --> 00:22:27.950
it's pretty awesome.

00:22:27.950 --> 00:22:30.350
Recently, we've added support
for super fast loading,

00:22:30.350 --> 00:22:33.290
along with AR support on any
device with a P Developer

00:22:33.290 --> 00:22:36.290
Preview system image, you
can simulate DisplayCutout

00:22:36.290 --> 00:22:37.550
through the Developer options.

00:22:37.550 --> 00:22:41.030
This ends the public
service announcement.

00:22:41.030 --> 00:22:41.780
FRED CHUNG: Great.

00:22:41.780 --> 00:22:46.290
So, long aspect ratio screens.

00:22:46.290 --> 00:22:49.410
So it's become a trend
for OEMs to be shipping

00:22:49.410 --> 00:22:52.800
devices like these, with
screens longer than 16

00:22:52.800 --> 00:22:55.080
by 9 aspect ratio.

00:22:55.080 --> 00:22:57.270
Make sure your apps
immersive experiences

00:22:57.270 --> 00:23:00.160
can fully take advantage of
these screen capabilities,

00:23:00.160 --> 00:23:01.630
which is pretty awesome.

00:23:01.630 --> 00:23:05.190
So, as a last resort, the
system still provides you

00:23:05.190 --> 00:23:10.200
a way to declare your maximum
supported aspect ratio.

00:23:10.200 --> 00:23:14.280
But it will display a letterbox
around your application

00:23:14.280 --> 00:23:18.090
ERIC KUXHAUSEN: And, seriously,
do you really want letterboxes?

00:23:18.090 --> 00:23:21.200
DAN GALPIN: With bigger screens
comes more responsibility.

00:23:21.200 --> 00:23:23.070
Now, consider taking
advantage of picture

00:23:23.070 --> 00:23:25.750
in picture for use cases
such as video chat, movie

00:23:25.750 --> 00:23:30.180
playback, fitness
tracking, or Pokemon Go.

00:23:30.180 --> 00:23:32.405
Multi-display support
also allows a user

00:23:32.405 --> 00:23:34.155
to launch an activity
for your application

00:23:34.155 --> 00:23:34.989
on a second display.

00:23:34.989 --> 00:23:37.113
And the only thing you have
to really consider here

00:23:37.113 --> 00:23:39.042
is it has a second
configuration, which

00:23:39.042 --> 00:23:41.500
is going to be different than
the one year app most likely.

00:23:41.500 --> 00:23:44.070
So be careful not to make
application-wide assumptions

00:23:44.070 --> 00:23:46.800
about hardworking configuration.

00:23:46.800 --> 00:23:49.470
And, in conclusion,
Android development

00:23:49.470 --> 00:23:53.460
has evolved, to mean using the
latest tools and APIs to enable

00:23:53.460 --> 00:23:56.490
better battery life,
smoother multitasking,

00:23:56.490 --> 00:23:58.980
supporting the latest hardware
and platform features,

00:23:58.980 --> 00:24:01.530
and taking advantage
of Jetpack to build

00:24:01.530 --> 00:24:06.180
a modern, testable architecture.

00:24:06.180 --> 00:24:06.680
Thank you.

00:24:09.630 --> 00:24:10.250
All right.

00:24:10.250 --> 00:24:12.950
Actually, no, no, no.

00:24:12.950 --> 00:24:14.810
There's actually one more thing.

00:24:14.810 --> 00:24:16.520
Android is actually
restricting the use

00:24:16.520 --> 00:24:20.330
of some non-SDK interfaces
in Developer Preview 1.

00:24:20.330 --> 00:24:22.430
And you saw this,
because we actually

00:24:22.430 --> 00:24:25.140
warned you with like
toast and log entries

00:24:25.140 --> 00:24:26.690
if these methods were used.

00:24:26.690 --> 00:24:28.974
But you'll notice, if
you're testing against DP2,

00:24:28.974 --> 00:24:30.890
some of these methods
will just cease to work,

00:24:30.890 --> 00:24:32.730
and will cause
your app to crash.

00:24:32.730 --> 00:24:35.200
So, please test and
file issues if you

00:24:35.200 --> 00:24:36.950
don't think there's
any way your app could

00:24:36.950 --> 00:24:39.020
work other than these methods.

00:24:39.020 --> 00:24:41.060
And, to help you
out in the future,

00:24:41.060 --> 00:24:43.970
we've actually added a new
VM policy for StrictMode

00:24:43.970 --> 00:24:47.065
that you can use to turn on
and detect all non-SDK API

00:24:47.065 --> 00:24:48.440
usage, which is
really important,

00:24:48.440 --> 00:24:50.570
because this non-SDK
usage may actually

00:24:50.570 --> 00:24:52.370
be happening in your libraries.

00:24:52.370 --> 00:24:54.891
So this is a really great
way to actually make sure

00:24:54.891 --> 00:24:57.140
that your app is going to
be compatible going forward.

00:24:57.140 --> 00:25:00.620
Because we don't guarantee the
compatibility of any non-SDK

00:25:00.620 --> 00:25:03.260
API.

00:25:03.260 --> 00:25:05.630
And so that really is it now.

00:25:05.630 --> 00:25:07.760
If you haven't been paying
attention in the last 30

00:25:07.760 --> 00:25:11.252
minutes, that's OK, because
clearly my jokes need work.

00:25:11.252 --> 00:25:13.460
ERIC KUXHAUSEN: If you're
an engineer, hopefully much

00:25:13.460 --> 00:25:16.220
of the information shared
today was a review for you.

00:25:16.220 --> 00:25:18.420
And we hope you found
the tips useful.

00:25:18.420 --> 00:25:21.470
FRED CHUNG: So if you are PM,
and if your app is not quite

00:25:21.470 --> 00:25:24.620
targeting 26 just yet, it's not
too late to plan things out,

00:25:24.620 --> 00:25:28.070
work with your teams to figure
out how much work is needed.

00:25:28.070 --> 00:25:29.660
And, in fact, we
prepared a guide

00:25:29.660 --> 00:25:32.960
on Android Developer sites
to help people understand,

00:25:32.960 --> 00:25:36.590
based on your current release,
the amount of work needed,

00:25:36.590 --> 00:25:39.900
so that we can collectively
push the ecosystem forward.

00:25:39.900 --> 00:25:42.620
Thank you very much.

00:25:42.620 --> 00:25:45.970
[MUSIC PLAYING]

