WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:08.466
[MUSIC PLAYING]

00:00:08.466 --> 00:00:11.050
TODD KERPELMAN: Hello and
welcome to episode

00:00:11.050 --> 00:00:12.530
five of Game On.

00:00:12.530 --> 00:00:13.840
I am your host, Todd
Kerpelman.

00:00:13.840 --> 00:00:15.080
And with me today--

00:00:15.080 --> 00:00:17.410
KRISTAN UCCELLO: Krispy,
developer relations.

00:00:17.410 --> 00:00:19.220
TODD KERPELMAN: It's
Krispy Uccello.

00:00:19.220 --> 00:00:23.180
And we are here to talk to you
today about game controllers.

00:00:23.180 --> 00:00:25.870
But firstly, with some news
and updates from the

00:00:25.870 --> 00:00:29.270
google-play-game-services
side of things.

00:00:29.270 --> 00:00:31.690
First off, we have an official
Stack Overflow tag.

00:00:31.690 --> 00:00:32.900
So yea!

00:00:32.900 --> 00:00:36.730
If you've got questions about
achievements, leader board,

00:00:36.730 --> 00:00:39.990
cloud save, multi-player, any
of that, you can go to Stack

00:00:39.990 --> 00:00:41.770
Overflow and find us under the

00:00:41.770 --> 00:00:45.020
google-play-games-services tag.

00:00:45.020 --> 00:00:47.290
Hopefully by the time this video
comes up this tag will

00:00:47.290 --> 00:00:47.990
be available.

00:00:47.990 --> 00:00:49.300
They're working on it.

00:00:49.300 --> 00:00:51.810
And you can start asking
us questions there.

00:00:51.810 --> 00:00:55.150
We've got guys much smarter
than me that are

00:00:55.150 --> 00:00:56.260
monitoring that tag.

00:00:56.260 --> 00:00:57.630
And they answer a lot
of your questions.

00:00:57.630 --> 00:01:02.440
So go there if you've got a
question about support on a

00:01:02.440 --> 00:01:03.570
specific platform.

00:01:03.570 --> 00:01:06.050
You pair it with an Android
or iOS tag.

00:01:06.050 --> 00:01:09.400
And we'll try and answer
your questions.

00:01:09.400 --> 00:01:12.660
Also, there is a great new
feature on the play games

00:01:12.660 --> 00:01:14.085
developer console.

00:01:14.085 --> 00:01:16.320
It's the greatest feature that
you've probably overlooked

00:01:16.320 --> 00:01:18.870
because it's this tiny little
link at the bottom.

00:01:18.870 --> 00:01:20.820
But it's the new "Get
Resources" feature.

00:01:20.820 --> 00:01:22.820
So you've got to
check this out.

00:01:22.820 --> 00:01:26.700
This is from our sample game,
the Typer-Number-Challenge.

00:01:26.700 --> 00:01:29.480
You'll notice I've got six
achievements here.

00:01:29.480 --> 00:01:30.900
And I've got a couple
leader boards.

00:01:30.900 --> 00:01:34.990
And in the past I had to
copy and paste all of

00:01:34.990 --> 00:01:36.230
those random strings.

00:01:36.230 --> 00:01:38.535
And half the time when I clicked
on something to try

00:01:38.535 --> 00:01:41.150
and copy the string it would
take me into the details page

00:01:41.150 --> 00:01:42.250
and it was really annoying.

00:01:42.250 --> 00:01:45.110
Well, now I can click
on this little

00:01:45.110 --> 00:01:46.500
link here at the bottom.

00:01:46.500 --> 00:01:49.660
And this will bring up a dialog
box where I have all

00:01:49.660 --> 00:01:54.150
the text I need ready to copy
and paste into my Android

00:01:54.150 --> 00:01:59.330
application or my iOS
application or my JavaScript

00:01:59.330 --> 00:02:00.090
application.

00:02:00.090 --> 00:02:04.170
And if none of these code
samples exactly matches the

00:02:04.170 --> 00:02:07.570
way you're implementing your
achievement in leader board

00:02:07.570 --> 00:02:10.320
strings we also just have plain
old text version that

00:02:10.320 --> 00:02:13.810
you can copy and paste and run
through a Python script or

00:02:13.810 --> 00:02:14.750
what have you.

00:02:14.750 --> 00:02:18.000
So for all of you that are
implementing 200 achievements

00:02:18.000 --> 00:02:21.870
all at once, this should be
a really big time saver.

00:02:21.870 --> 00:02:24.080
And we're really excited
to have this out there.

00:02:24.080 --> 00:02:25.010
So check it out.

00:02:25.010 --> 00:02:27.080
If you haven't seen
it yet, it's the

00:02:27.080 --> 00:02:28.690
greatest new feature ever.

00:02:28.690 --> 00:02:29.680
Well, maybe not ever.

00:02:29.680 --> 00:02:31.590
But it's close.

00:02:31.590 --> 00:02:33.910
And so with that out of the
way, let's get into game

00:02:33.910 --> 00:02:34.980
controllers on Android.

00:02:34.980 --> 00:02:36.706
I'm going to hand the clicker
off to Krispy here.

00:02:36.706 --> 00:02:37.490
KRISTAN UCCELLO: Thank
you very much.

00:02:37.490 --> 00:02:38.010
TODD KERPELMAN: Sure thing.

00:02:38.010 --> 00:02:40.385
Because he's the expert.

00:02:40.385 --> 00:02:41.820
KRISTAN UCCELLO: I don't know
if I'm an expert yet.

00:02:41.820 --> 00:02:43.160
I'm hoping to become one.

00:02:43.160 --> 00:02:45.500
And this is sort of the
first Foray into that.

00:02:45.500 --> 00:02:49.028
So I spent a lot of time with
game controllers, working of

00:02:49.028 --> 00:02:50.190
the stuff that I work on.

00:02:50.190 --> 00:02:52.990
And I've had a slew of
them cross my desk.

00:02:52.990 --> 00:02:56.550
And with that, this is
the first thing.

00:02:56.550 --> 00:02:59.020
What does it mean to support a
game controller on Android?

00:02:59.020 --> 00:03:00.720
Because there's so many
different devices.

00:03:00.720 --> 00:03:04.260
And they all choose slightly
different ways of connecting

00:03:04.260 --> 00:03:05.740
to Android itself.

00:03:05.740 --> 00:03:08.350
A lot of them are either
Bluetooth or USB.

00:03:08.350 --> 00:03:10.290
Those are typically the
only options that

00:03:10.290 --> 00:03:12.150
you're going to have.

00:03:12.150 --> 00:03:15.650
But one interesting thing is,
when you're building an

00:03:15.650 --> 00:03:18.120
application that utilizes game
controllers, you have to

00:03:18.120 --> 00:03:21.760
factor in that you're taking the
user's ability to really

00:03:21.760 --> 00:03:24.510
touch a screen away from them.

00:03:24.510 --> 00:03:26.460
And this is a good thing
and a bag thing.

00:03:26.460 --> 00:03:29.460
It's a good thing in that it
gives you that tactile

00:03:29.460 --> 00:03:32.390
feedback when you're
manipulating the controls,

00:03:32.390 --> 00:03:33.290
pressing buttons.

00:03:33.290 --> 00:03:35.740
It's something that doesn't
require you to focus your

00:03:35.740 --> 00:03:37.990
attention on what
you're touching.

00:03:37.990 --> 00:03:39.510
You could, instead, look
somewhere else.

00:03:39.510 --> 00:03:42.910
So this is great for Google TV,
Android TV, anything that

00:03:42.910 --> 00:03:46.500
is far away from you that
you can't really touch.

00:03:46.500 --> 00:03:49.880
But on the opposite side,
you can't really

00:03:49.880 --> 00:03:51.360
input text that easily.

00:03:51.360 --> 00:03:54.170
So if there's a lot of input
controls that would require

00:03:54.170 --> 00:03:56.470
keyboard input that's
not always there.

00:03:56.470 --> 00:03:59.930
So the plus points, I'll
just summarize again.

00:03:59.930 --> 00:04:02.150
Physical feedback, some
kind of [INAUDIBLE]

00:04:02.150 --> 00:04:03.360
feedback with vibrators.

00:04:03.360 --> 00:04:06.780
The negative side, harder to
input text and there's a

00:04:06.780 --> 00:04:09.080
little bit more design work that
has to go into your UI.

00:04:09.080 --> 00:04:12.360
But we're going to cover some
more later on in the slides.

00:04:12.360 --> 00:04:17.120
So let's talk about where
the APIs came from.

00:04:17.120 --> 00:04:20.690
API level 12 we saw the
introduction of a lot of the

00:04:20.690 --> 00:04:23.650
constants that were available
for dipping into game

00:04:23.650 --> 00:04:26.000
controllers, understanding
whether an input device is

00:04:26.000 --> 00:04:29.650
actually a joystick or whether
it has joysticks, whether it's

00:04:29.650 --> 00:04:32.350
a game pad, whether it
supports buttons.

00:04:32.350 --> 00:04:34.660
And this has all that available
in the documentation

00:04:34.660 --> 00:04:35.780
since API level 12.

00:04:35.780 --> 00:04:37.780
There's a link on the
slide right now.

00:04:37.780 --> 00:04:39.670
If you're new to game
controllers this is

00:04:39.670 --> 00:04:40.950
the place to start.

00:04:40.950 --> 00:04:43.610
There's a summary section that
really details things like

00:04:43.610 --> 00:04:46.920
what to do with source-class
joystick and source-class

00:04:46.920 --> 00:04:48.335
buttons and game pads.

00:04:48.335 --> 00:04:49.420
It's a good primer.

00:04:49.420 --> 00:04:51.650
It's not going to tell you
everything you need to do.

00:04:51.650 --> 00:04:53.190
But it's a good place
to start to get

00:04:53.190 --> 00:04:54.930
ramped up on that material.

00:04:54.930 --> 00:04:59.090
Now, with API level 16 we saw
even more game controller

00:04:59.090 --> 00:04:59.760
support added.

00:04:59.760 --> 00:05:03.750
And this is where you can,
actually, tap into listening

00:05:03.750 --> 00:05:05.800
to connection and disconnection
events.

00:05:05.800 --> 00:05:09.980
Previous to API level 16, you
had to write your own

00:05:09.980 --> 00:05:14.030
broadcast listeners to tap into
when a USB devices was

00:05:14.030 --> 00:05:16.050
connected or disconnected.

00:05:16.050 --> 00:05:19.670
And you would also have to
implement a Bluetooth event

00:05:19.670 --> 00:05:22.980
listener that would tell you
whether a Bluetooth device had

00:05:22.980 --> 00:05:24.180
connected or not.

00:05:24.180 --> 00:05:26.730
You didn't have to write a lot
of boilerplate code for all

00:05:26.730 --> 00:05:28.200
these applications.

00:05:28.200 --> 00:05:32.130
Now with API level 16, there is
the input listener that you

00:05:32.130 --> 00:05:33.270
can take advantage of.

00:05:33.270 --> 00:05:35.980
And it's definitely a big one.

00:05:35.980 --> 00:05:37.900
So there's a lot of support
already there for game

00:05:37.900 --> 00:05:38.810
controllers.

00:05:38.810 --> 00:05:42.460
So the two places you're going
to want to look, API level 12,

00:05:42.460 --> 00:05:45.520
the link is on the screen,
and API level 16.

00:05:45.520 --> 00:05:46.380
Check those out.

00:05:46.380 --> 00:05:48.390
TODD KERPELMAN: I notice the
slide here says something

00:05:48.390 --> 00:05:49.060
about querying.

00:05:49.060 --> 00:05:49.720
What's that?

00:05:49.720 --> 00:05:54.050
KRISTAN UCCELLO: Querying is
pulling of a sort to find out

00:05:54.050 --> 00:05:56.130
what devices are actually
game pads.

00:05:56.130 --> 00:05:59.370
One of the things that we'll
talk about later on in the

00:05:59.370 --> 00:06:02.370
slides is how to identify an
input device, whether it's a

00:06:02.370 --> 00:06:06.430
keyboard or a pointer, or a
stylus, or an actual game pad.

00:06:06.430 --> 00:06:11.280
And querying is kind of an easy
way to just getting the

00:06:11.280 --> 00:06:14.260
subset of input devices that you
care about in that case.

00:06:14.260 --> 00:06:17.760
We'll cover some of the methods
of detecting input

00:06:17.760 --> 00:06:19.970
devices without using
a query right now.

00:06:19.970 --> 00:06:22.006
I don't want to go too
much into that.

00:06:22.006 --> 00:06:24.110
All right?

00:06:24.110 --> 00:06:26.720
So moving along here.

00:06:26.720 --> 00:06:28.090
Oh, I'm scrolling
the wrong thing.

00:06:28.090 --> 00:06:28.480
There we go.

00:06:28.480 --> 00:06:32.180
So connecting controllers,
this is the first step in

00:06:32.180 --> 00:06:34.660
being able to use them.

00:06:34.660 --> 00:06:37.970
Phones and tablets, you're
typically going to rely on a

00:06:37.970 --> 00:06:38.980
Bluetooth connection.

00:06:38.980 --> 00:06:44.190
Because it's really hard to plug
a fat USB port into your

00:06:44.190 --> 00:06:47.350
Nexus device, I found anyway.

00:06:47.350 --> 00:06:52.590
But on Android TV devices like
Google TV, you can typically

00:06:52.590 --> 00:06:55.680
plug right into the USB port
and take advantage of that.

00:06:55.680 --> 00:06:57.600
And you can leverage
Bluetooth.

00:06:57.600 --> 00:07:02.330
So I think I'm kind of
recommending Bluetooth here.

00:07:02.330 --> 00:07:04.680
But you shouldn't feel that
you're limited to only using

00:07:04.680 --> 00:07:07.690
Bluetooth, especially if
you want to target a

00:07:07.690 --> 00:07:12.290
living-room-console style game
play for your users.

00:07:12.290 --> 00:07:16.900
So just quick, short facts about
where USB came from.

00:07:16.900 --> 00:07:18.330
It was from 1994.

00:07:18.330 --> 00:07:19.820
There was a collaboration
of a bunch of

00:07:19.820 --> 00:07:20.890
companies that got involved.

00:07:20.890 --> 00:07:22.490
And they created the
USB standard.

00:07:22.490 --> 00:07:25.620
And that's evolved over the
years to our micro standard

00:07:25.620 --> 00:07:26.900
that we see now.

00:07:26.900 --> 00:07:29.500
You're not going to find any
game controllers that really

00:07:29.500 --> 00:07:33.600
connect with the
micro USB spec.

00:07:33.600 --> 00:07:34.440
I haven't found any yet.

00:07:34.440 --> 00:07:35.860
I'd be interested if
there were any.

00:07:35.860 --> 00:07:38.150
But we'll see.

00:07:38.150 --> 00:07:40.400
I'll just mention, again, API
level 16 introduced the

00:07:40.400 --> 00:07:42.730
ability to easily search and
listen for connected and

00:07:42.730 --> 00:07:45.130
disconnected devices.

00:07:45.130 --> 00:07:49.250
And actually, before I forget,
the button mappings, when you

00:07:49.250 --> 00:07:53.550
connect your game controllers,
button mappings are a little

00:07:53.550 --> 00:07:58.010
weird if it's non-hid or
hid device sometimes.

00:07:58.010 --> 00:08:01.520
You can press the A button or
the B button on your remote or

00:08:01.520 --> 00:08:02.650
on your game pad.

00:08:02.650 --> 00:08:05.220
And it will act as
the back button.

00:08:05.220 --> 00:08:08.370
So we'll talk about how
you can fix that a

00:08:08.370 --> 00:08:09.120
little later on.

00:08:09.120 --> 00:08:11.370
But just be aware that when you
first connect, even though

00:08:11.370 --> 00:08:15.050
you can navigate the home
launcher with it, it might not

00:08:15.050 --> 00:08:17.570
have the expected behavior
right out of the box.

00:08:17.570 --> 00:08:19.580
So it's good for applications,
maybe not so good for

00:08:19.580 --> 00:08:20.620
home-screen navigation.

00:08:20.620 --> 00:08:22.890
TODD KERPELMAN: OK,

00:08:22.890 --> 00:08:25.680
KRISTAN UCCELLO: So let's talk
about querying for game

00:08:25.680 --> 00:08:27.840
controllers.

00:08:27.840 --> 00:08:30.020
This might be a little
small on the screen.

00:08:30.020 --> 00:08:31.710
I say that because even
I'm having trouble

00:08:31.710 --> 00:08:33.049
reading this slide now.

00:08:33.049 --> 00:08:36.260
But I'll cover the
basics here.

00:08:36.260 --> 00:08:37.590
What you want to do, is
you want to take the

00:08:37.590 --> 00:08:38.760
input device class.

00:08:38.760 --> 00:08:42.700
And you're going to basically,
say, get all my device IDs.

00:08:42.700 --> 00:08:46.220
And you'll get back an integer
array of all the devices that

00:08:46.220 --> 00:08:49.620
are currently connected to the
Android system, whether

00:08:49.620 --> 00:08:52.020
they're virtual or real.

00:08:52.020 --> 00:08:54.540
What you want to do, then, is
actually iterate over all

00:08:54.540 --> 00:08:58.650
those device IDs and request,
again, from the input device

00:08:58.650 --> 00:09:00.250
class, getDevice.

00:09:00.250 --> 00:09:02.440
And you're going to pass in the
ID that you're currently

00:09:02.440 --> 00:09:03.980
iterating on.

00:09:03.980 --> 00:09:06.690
That will give you an
input device object.

00:09:06.690 --> 00:09:09.860
And you can now start to
ask that input device

00:09:09.860 --> 00:09:11.460
object about itself.

00:09:11.460 --> 00:09:14.680
And the key here for detecting
game controllers, is in fact,

00:09:14.680 --> 00:09:17.430
to use device.getSource.

00:09:17.430 --> 00:09:20.570
So devices, our input device
object that we've created,

00:09:20.570 --> 00:09:26.960
getSources, returns an integer
value which is actually a set

00:09:26.960 --> 00:09:32.700
of bitmaps, bitmapped values
that create a large integer.

00:09:32.700 --> 00:09:36.400
You will logically end those
with an input device

00:09:36.400 --> 00:09:38.360
source-class joystick.

00:09:38.360 --> 00:09:40.290
Effectively what you're doing
there is you're filtering out

00:09:40.290 --> 00:09:40.870
all the other bits.

00:09:40.870 --> 00:09:42.950
And you're just looking at the
one that's going to tell you,

00:09:42.950 --> 00:09:45.960
hey, this is a joystick
device or it's not.

00:09:45.960 --> 00:09:50.770
And if that returns non-zero
than it is a joystick device.

00:09:50.770 --> 00:09:53.015
That means there's an analog
stick on it that

00:09:53.015 --> 00:09:55.420
is a joystick axis.

00:09:55.420 --> 00:09:58.590
From there, you're going to
want to possibly check the

00:09:58.590 --> 00:10:01.000
ranges that are available for
that joystick device.

00:10:01.000 --> 00:10:03.500
So we're going to look
at that now.

00:10:03.500 --> 00:10:04.330
TODD KERPELMAN: OK,
actually, sorry.

00:10:04.330 --> 00:10:05.230
So going back--

00:10:05.230 --> 00:10:06.395
KRISTAN UCCELLO: You want
to go back a slide?

00:10:06.395 --> 00:10:08.480
TODD KERPELMAN: So I actually
can't tell the device, like,

00:10:08.480 --> 00:10:09.530
are you a game pad?

00:10:09.530 --> 00:10:12.000
I would say, hey, out of all the
features that you have, do

00:10:12.000 --> 00:10:14.620
you have maybe a couple of
joysticks and some buttons?

00:10:14.620 --> 00:10:15.570
KRISTAN UCCELLO: Exactly.

00:10:15.570 --> 00:10:18.010
You're going to take the
getSources and you're going to

00:10:18.010 --> 00:10:21.190
ask it yes, do you have
the ability to

00:10:21.190 --> 00:10:22.430
provide me joystick input?

00:10:22.430 --> 00:10:24.350
Do you have the ability to
provide me button input?

00:10:24.350 --> 00:10:27.415
Chances are, if it has a
joystick, it's a game pad.

00:10:27.415 --> 00:10:28.020
TODD KERPELMAN: Yeah?

00:10:28.020 --> 00:10:30.630
Is there anything that would
have a joystick that would not

00:10:30.630 --> 00:10:31.980
be a game pad?

00:10:31.980 --> 00:10:33.370
KRISTAN UCCELLO: I've done lot
of tests with a lot of

00:10:33.370 --> 00:10:34.190
different input devices.

00:10:34.190 --> 00:10:35.160
I haven't come across any.

00:10:35.160 --> 00:10:39.720
It's entirely possible but
probably not the normal case.

00:10:39.720 --> 00:10:41.730
TODD KERPELMAN: What about a
stylus then, that would say,

00:10:41.730 --> 00:10:42.730
I'm not a joystick.

00:10:42.730 --> 00:10:45.530
KRISTAN UCCELLO: Yeah, the
stylus does have axes

00:10:45.530 --> 00:10:46.670
based on the angle.

00:10:46.670 --> 00:10:49.160
But it's not classified
as a game device.

00:10:49.160 --> 00:10:51.180
It won't register
itself that way.

00:10:51.180 --> 00:10:51.860
TODD KERPELMAN: Got you, OK.

00:10:51.860 --> 00:10:56.070
KRISTAN UCCELLO: So with our
joystick identified, or the

00:10:56.070 --> 00:11:00.220
device having a joystick, we can
go in further and ask that

00:11:00.220 --> 00:11:03.760
joystick what motion
ranges it has.

00:11:03.760 --> 00:11:07.060
And this is useful for
determining the number of axes

00:11:07.060 --> 00:11:07.580
that are available.

00:11:07.580 --> 00:11:11.480
So if you have a game pad or
some sort of game input device

00:11:11.480 --> 00:11:14.310
that had two joysticks on it,
it's going to have eight axes

00:11:14.310 --> 00:11:15.160
right there.

00:11:15.160 --> 00:11:17.600
One for the vertical on each
stick and one for the

00:11:17.600 --> 00:11:19.400
horizontal on each stick.

00:11:19.400 --> 00:11:22.960
Now, if it also had analog
triggers for the left and

00:11:22.960 --> 00:11:27.100
right, those will also show up
as axes but single axes.

00:11:27.100 --> 00:11:28.910
So you could have a device--

00:11:28.910 --> 00:11:30.250
or maybe I did my math wrong.

00:11:30.250 --> 00:11:31.970
TODD KERPELMAN: Yeah, I was
going to say, that would be

00:11:31.970 --> 00:11:33.830
four for the joysticks
and then two

00:11:33.830 --> 00:11:34.640
more for the triggers.

00:11:34.640 --> 00:11:34.770
KRISTAN UCCELLO: I
doubled it up.

00:11:34.770 --> 00:11:35.200
Two more for the triggers.

00:11:35.200 --> 00:11:38.150
I was jumping ahead of
myself in my head.

00:11:38.150 --> 00:11:41.560
So six axes in that case.

00:11:41.560 --> 00:11:46.430
And the thing that looks like
a D-pad, actually, on game

00:11:46.430 --> 00:11:49.410
input devices, people think
that it's a digital input.

00:11:49.410 --> 00:11:50.366
And it's not.

00:11:50.366 --> 00:11:54.100
It's actually a Hat
device with axes.

00:11:54.100 --> 00:11:55.700
So you get another
two off of that.

00:11:55.700 --> 00:11:58.710
TODD KERPELMAN: So a D-pad
looks like, basically, it

00:11:58.710 --> 00:12:01.480
looks almost like an analog
joystick except that the

00:12:01.480 --> 00:12:02.680
numbers aren't really analog.

00:12:02.680 --> 00:12:07.110
KRISTAN UCCELLO: Right, while it
returns it's axes values as

00:12:07.110 --> 00:12:09.570
floats it'll either
be 0 or one.

00:12:09.570 --> 00:12:10.550
You won't get any of
the middle ranges.

00:12:10.550 --> 00:12:14.280
Whereas the other more
analog-style inputs like the

00:12:14.280 --> 00:12:18.180
triggers and the joysticks will
return in an analog value

00:12:18.180 --> 00:12:22.280
range between 0 or
negative 1 and 1.

00:12:22.280 --> 00:12:23.580
So that's just something
to be aware of.

00:12:23.580 --> 00:12:28.590
So we check the motion ranges
just to get a principle idea

00:12:28.590 --> 00:12:31.130
of how many axes are actually
on this device.

00:12:31.130 --> 00:12:34.185
And from there, we want to
take that information.

00:12:34.185 --> 00:12:35.260
We want to restore
it in a state.

00:12:35.260 --> 00:12:38.010
We want to create a class that
allows us to know how many

00:12:38.010 --> 00:12:42.240
axes we have, the IDs of those
axes and the values

00:12:42.240 --> 00:12:43.520
associated with them.

00:12:43.520 --> 00:12:46.400
So I'm just showing, really,
the skeleton of

00:12:46.400 --> 00:12:48.280
a state class here.

00:12:48.280 --> 00:12:51.810
You're going to want to extend
that with things to process

00:12:51.810 --> 00:12:54.470
the axis input and normalize
it and all that stuff.

00:12:54.470 --> 00:12:56.600
And we'll cover a bit of
that as we go forward.

00:12:56.600 --> 00:12:58.530
But I just want to point out the
critical things you want

00:12:58.530 --> 00:13:02.030
to store, the number of axes,
the axes values, and you're

00:13:02.030 --> 00:13:05.130
going to want to use, probably,
a sparse array to

00:13:05.130 --> 00:13:08.550
store the number of keys
that you encounter.

00:13:08.550 --> 00:13:10.440
And the keys are actually
the buttons.

00:13:10.440 --> 00:13:12.550
So these map as keys.

00:13:12.550 --> 00:13:16.420
I think it's a little weird,
but buttons or keys.

00:13:16.420 --> 00:13:20.040
TODD KERPELMAN: OK, correct me
if I'm wrong, but an Xbox 360

00:13:20.040 --> 00:13:22.090
controller, for instance, I
believe those buttons are

00:13:22.090 --> 00:13:22.980
actually analog.

00:13:22.980 --> 00:13:24.610
Is that true?

00:13:24.610 --> 00:13:27.850
And if I had something that
was similar would those--

00:13:27.850 --> 00:13:29.680
KRISTAN UCCELLO: I'm actually
not aware of that.

00:13:29.680 --> 00:13:30.680
I didn't know that
they were analog.

00:13:30.680 --> 00:13:31.630
TODD KERPELMAN: OK, I could
be totally wrong.

00:13:31.630 --> 00:13:34.020
That's what I vaguely remember
reading sometime.

00:13:34.020 --> 00:13:34.890
KRISTAN UCCELLO: Different
manufacturers can

00:13:34.890 --> 00:13:35.690
do different things.

00:13:35.690 --> 00:13:37.450
And this just goes back to
what I said earlier.

00:13:37.450 --> 00:13:40.700
There are so many different
types of, again, controller

00:13:40.700 --> 00:13:41.850
inputs out there.

00:13:41.850 --> 00:13:43.480
It's really hard to know
what they all are.

00:13:43.480 --> 00:13:46.910
Which is why the way Android
has approached

00:13:46.910 --> 00:13:47.720
it is really good.

00:13:47.720 --> 00:13:50.570
It lets you query the device
for what it's capable of,

00:13:50.570 --> 00:13:53.880
which lets you, then, determine
if the device is

00:13:53.880 --> 00:13:55.850
capable of providing the right
kind of input for your

00:13:55.850 --> 00:13:56.916
application. or game.

00:13:56.916 --> 00:14:00.380
TODD KERPELMAN: OK, So let's
say a query device, it's a

00:14:00.380 --> 00:14:04.310
standard two-analog joystick,
a couple of triggers.

00:14:04.310 --> 00:14:08.360
And it says, OK, I've got
these six analog axes.

00:14:08.360 --> 00:14:11.390
How do I know which two, for
instance, correspond to the

00:14:11.390 --> 00:14:12.640
joystick on the left?

00:14:16.940 --> 00:14:18.040
KRISTAN UCCELLO: We'll
talk about some

00:14:18.040 --> 00:14:19.110
of this going forward.

00:14:19.110 --> 00:14:21.810
When you get a dispatch
on-motion event from your

00:14:21.810 --> 00:14:24.700
activity class, that the event
object is either a motion

00:14:24.700 --> 00:14:26.590
event or a key input event.

00:14:26.590 --> 00:14:27.990
We'll ignore the key
input event.

00:14:27.990 --> 00:14:29.060
So you get a motion event.

00:14:29.060 --> 00:14:33.300
And the event object itself
has information about what

00:14:33.300 --> 00:14:36.800
input source on the device is
providing that particular

00:14:36.800 --> 00:14:38.070
input event.

00:14:38.070 --> 00:14:39.990
So there's a couple things
you can check.

00:14:39.990 --> 00:14:43.510
Whether it's a move, action,
associated with a particular

00:14:43.510 --> 00:14:44.300
axis label.

00:14:44.300 --> 00:14:49.660
So back to the APIs I mentioned
before, API level

00:14:49.660 --> 00:14:52.260
12, it introduced a whole bunch
of constants that you

00:14:52.260 --> 00:14:55.640
can use to determine
which axes it

00:14:55.640 --> 00:14:57.920
actually is on the device.

00:14:57.920 --> 00:15:00.960
So they all map to different
constant values.

00:15:00.960 --> 00:15:01.750
TODD KERPELMAN: Got you.

00:15:01.750 --> 00:15:05.830
So for instance, looking at
a controller, that analog

00:15:05.830 --> 00:15:08.980
control on the left, those two
axes generally correspond to

00:15:08.980 --> 00:15:10.010
constants like what?

00:15:10.010 --> 00:15:11.160
Like move vertical and
move horizontal?

00:15:11.160 --> 00:15:14.720
KRISTAN UCCELLO: It's actually
access underscore x-axis

00:15:14.720 --> 00:15:15.790
underscore y.

00:15:15.790 --> 00:15:18.930
Now the one on the other side
the controller, if it's there,

00:15:18.930 --> 00:15:23.470
is typically labeled
axes underscore rx.

00:15:23.470 --> 00:15:24.890
My memory's a little
fuzzy on this.

00:15:24.890 --> 00:15:27.540
But it's labeled
appropriately.

00:15:27.540 --> 00:15:30.480
TODD KERPELMAN: So I got my axis
left, axes y, axes rx and

00:15:30.480 --> 00:15:31.720
axes ry basically?

00:15:31.720 --> 00:15:33.230
KRISTAN UCCELLO: Right, but it's
not always guaranteed to

00:15:33.230 --> 00:15:33.630
be that way.

00:15:33.630 --> 00:15:37.170
You might actually end up in the
case where that secondary

00:15:37.170 --> 00:15:40.600
joystick axis is labeled
with a z.

00:15:40.600 --> 00:15:45.630
So zx, z, none of it is
constant with game

00:15:45.630 --> 00:15:46.060
controllers.

00:15:46.060 --> 00:15:48.970
And so you have to do a bit
of experimentation.

00:15:48.970 --> 00:15:51.570
My advice is to stick with some
of the more established

00:15:51.570 --> 00:15:54.220
brands because you're going to
get consistent behavior across

00:15:54.220 --> 00:15:56.540
them, more or less.

00:15:56.540 --> 00:15:58.430
But it's a bit of
trial and error.

00:15:58.430 --> 00:16:02.080
And you will probably end up
having to map a couple of

00:16:02.080 --> 00:16:05.460
different types of controllers
and adjust what they're

00:16:05.460 --> 00:16:07.745
reporting their axes to
be to be consistent

00:16:07.745 --> 00:16:09.180
with your game logic.

00:16:09.180 --> 00:16:12.440
TODD KERPELMAN: And the time to
find that out is on my very

00:16:12.440 --> 00:16:16.040
first get move event
from that game pad?

00:16:16.040 --> 00:16:17.520
KRISTAN UCCELLO: Exactly,
because you're not going to be

00:16:17.520 --> 00:16:21.710
able to determine everything
on initial poling yet.

00:16:21.710 --> 00:16:26.150
But everything can be dealt
with on those events.

00:16:26.150 --> 00:16:28.990
So one thing I want to put in,
since we've talked about the

00:16:28.990 --> 00:16:31.910
state of the device and storing
it, you're going to

00:16:31.910 --> 00:16:35.030
want to probably figure out an
abstraction where each player

00:16:35.030 --> 00:16:37.500
should be assigned a controller
device and let that

00:16:37.500 --> 00:16:38.700
be consistent.

00:16:38.700 --> 00:16:43.280
As well, you want to let the
users sort out or whose

00:16:43.280 --> 00:16:45.250
controller is mapping
to which player.

00:16:45.250 --> 00:16:47.990
So one concept I have for
this-- which I haven't

00:16:47.990 --> 00:16:51.690
implemented yet but I've
seen in certain games--

00:16:51.690 --> 00:16:53.990
is something along these
lines, where

00:16:53.990 --> 00:16:55.070
the game starts up.

00:16:55.070 --> 00:16:56.940
And it's like, all right, which
players are assigned to

00:16:56.940 --> 00:16:57.720
which controller?

00:16:57.720 --> 00:17:00.490
So you have a list of all the
game pad identified devices

00:17:00.490 --> 00:17:02.830
down one column and all the
players along the top.

00:17:02.830 --> 00:17:08.780
And any device can push these
controller things into the

00:17:08.780 --> 00:17:10.000
right player slot.

00:17:10.000 --> 00:17:12.440
And then that player could go
ahead and configure their

00:17:12.440 --> 00:17:14.560
device to their preferences.

00:17:14.560 --> 00:17:16.160
So just something I wanted
to point out.

00:17:16.160 --> 00:17:21.240
It's always a good idea, if it's
a multi-player game, to

00:17:21.240 --> 00:17:23.359
allow the players to decide
which controllers are which.

00:17:23.359 --> 00:17:24.920
Otherwise they're having to
physically switch it.

00:17:24.920 --> 00:17:27.050
And it's not a great
user experience.

00:17:27.050 --> 00:17:28.674
TODD KERPELMAN: That's
not so good, OK.

00:17:28.674 --> 00:17:30.540
KRISTAN UCCELLO: So now let's
get back to what we were

00:17:30.540 --> 00:17:32.460
talking about before that,
the handling of events.

00:17:32.460 --> 00:17:36.340
So there's two methods you're
going to want to override in

00:17:36.340 --> 00:17:38.240
your activity.

00:17:38.240 --> 00:17:40.300
And that is dispatched generic
motion event and

00:17:40.300 --> 00:17:42.570
dispatched key event.

00:17:42.570 --> 00:17:45.060
My recommendation is, whatever
you're going to write for your

00:17:45.060 --> 00:17:48.500
logic to manage your input from
a game controller, you're

00:17:48.500 --> 00:17:50.440
going to want to feed these
motion events from your

00:17:50.440 --> 00:17:52.430
activity into that class.

00:17:52.430 --> 00:17:54.610
Don't try and deal with them,
necessarily, in the activity.

00:17:54.610 --> 00:17:59.500
Because it'll just bloat your
code and it's not a good way

00:17:59.500 --> 00:18:01.240
to abstract, I think.

00:18:01.240 --> 00:18:06.240
So whenever there is an access
movement or a Hat movement or

00:18:06.240 --> 00:18:08.540
an analog trigger you're going
to get the motion event.

00:18:08.540 --> 00:18:11.120
So anything that's analog
will cause motion.

00:18:11.120 --> 00:18:15.770
Any button event will trigger
the dispatch key event.

00:18:15.770 --> 00:18:18.415
And this is where you start
to get into filtering.

00:18:18.415 --> 00:18:20.230
So you use the constants--

00:18:20.230 --> 00:18:24.000
again, look at API level 12
documentation on this--

00:18:24.000 --> 00:18:29.580
to sort out which mappings
are actually to the

00:18:29.580 --> 00:18:31.390
keys you care about.

00:18:31.390 --> 00:18:34.260
And I'm not going to cover too
much about establishing how to

00:18:34.260 --> 00:18:35.190
remap keys.

00:18:35.190 --> 00:18:38.420
But allow the user to
reconfigure the layout of

00:18:38.420 --> 00:18:42.720
their device, their
abstraction layer.

00:18:42.720 --> 00:18:44.530
So you're going to want to pass
this off to something

00:18:44.530 --> 00:18:47.780
that manages the device state
and then returns it back to

00:18:47.780 --> 00:18:51.240
whatever's going to use that
state to then modify the

00:18:51.240 --> 00:18:54.230
player-controllable objects
in your application.

00:18:54.230 --> 00:18:55.770
So it looks something
like this.

00:18:55.770 --> 00:18:57.890
So your dispatch key event and
your dispatch generic motion

00:18:57.890 --> 00:18:59.730
event come into the activity.

00:18:59.730 --> 00:19:03.050
You're going to hand it off to
whatever system to get the

00:19:03.050 --> 00:19:08.890
state back and use that to
power your application.

00:19:08.890 --> 00:19:11.370
I want to point out a few things
about analog joysticks.

00:19:11.370 --> 00:19:13.860
You will have to be aware
of the dead zone.

00:19:13.860 --> 00:19:20.220
Not all joysticks
center on zero.

00:19:20.220 --> 00:19:21.540
They're moved around a lot.

00:19:21.540 --> 00:19:22.800
They're mechanical things.

00:19:22.800 --> 00:19:24.890
And so they can get a little
off and it can

00:19:24.890 --> 00:19:26.300
report to the sensors.

00:19:26.300 --> 00:19:29.160
Luckily, we have this thing
called the dead zone, usually

00:19:29.160 --> 00:19:33.080
by calling getFlat on
the motion range.

00:19:33.080 --> 00:19:36.110
This allows you to determine
some sort of air tolerance

00:19:36.110 --> 00:19:39.730
when the joystick is released
and not being

00:19:39.730 --> 00:19:43.050
touched by the player.

00:19:43.050 --> 00:19:47.180
Use the motion range
of the joystick to

00:19:47.180 --> 00:19:47.950
determine this stuff.

00:19:47.950 --> 00:19:50.950
So the ones you care about are
getMin, getMax and getFlat,

00:19:50.950 --> 00:19:52.070
which I just mentioned.

00:19:52.070 --> 00:19:54.810
You'll have to normalize your
axis values accordingly.

00:19:54.810 --> 00:19:58.180
So I actually have a bit of code
here that shows this off.

00:19:58.180 --> 00:19:59.500
Pardon me.

00:19:59.500 --> 00:20:02.900
So if we want to process an
axes and we have some axis

00:20:02.900 --> 00:20:07.610
value that we've gotten from our
input state or controller

00:20:07.610 --> 00:20:09.790
state object, so we have
the motion range.

00:20:09.790 --> 00:20:10.940
We have the axis value.

00:20:10.940 --> 00:20:13.340
What we want to do, is we want
to get the absolute value of

00:20:13.340 --> 00:20:14.560
that axis value.

00:20:14.560 --> 00:20:16.005
And then we want to determine
the dead zone.

00:20:16.005 --> 00:20:17.920
So we're going to go getFlat.

00:20:17.920 --> 00:20:21.480
And then we want to determine if
the absolute value is less

00:20:21.480 --> 00:20:22.680
than or equal to
the dead zone.

00:20:22.680 --> 00:20:24.000
If it is, return 0.

00:20:24.000 --> 00:20:26.380
That means that it's actually
within that range.

00:20:26.380 --> 00:20:27.860
And we shouldn't do anything
with this.

00:20:27.860 --> 00:20:32.070
Or if the access value is
greater than 0, we want to

00:20:32.070 --> 00:20:35.400
return the absolute value
divided by the minimum range,

00:20:35.400 --> 00:20:38.320
which gives us a normalized
value.

00:20:38.320 --> 00:20:42.550
If it's less than 0 we're going
to do absolute value

00:20:42.550 --> 00:20:45.610
divided by maximum range.

00:20:45.610 --> 00:20:47.640
TODD KERPELMAN: So what
do these numbers

00:20:47.640 --> 00:20:50.960
typically look like?

00:20:50.960 --> 00:20:53.972
So I'm assuming getMin
is a negative value?

00:20:53.972 --> 00:20:59.660
KRISTAN UCCELLO: Yes So getMin
is a typically negative one.

00:20:59.660 --> 00:21:02.400
And getMax is typically
one, yes.

00:21:02.400 --> 00:21:03.800
But you can actually
modify this.

00:21:03.800 --> 00:21:06.480
If you want to actually get out
of, let's say, a method

00:21:06.480 --> 00:21:09.380
like this, you wanted to
get some greater range.

00:21:09.380 --> 00:21:10.610
You want to expand
it as you're not

00:21:10.610 --> 00:21:12.210
dealing with decimals.

00:21:12.210 --> 00:21:14.050
You're instead dealing
with integers, which

00:21:14.050 --> 00:21:16.300
is completely possible.

00:21:16.300 --> 00:21:20.300
You could add biases to your
calculations here to actually

00:21:20.300 --> 00:21:23.825
spit out oh, 1,000 or 200.

00:21:23.825 --> 00:21:26.240
TODD KERPELMAN: And getFlat here
would probably look like,

00:21:26.240 --> 00:21:28.280
say, 0.05 or something
like that?

00:21:28.280 --> 00:21:31.540
KRISTAN UCCELLO: Oh, I think
it would look even smaller.

00:21:31.540 --> 00:21:33.030
From what I've seen, from what
I've played with, it's like,

00:21:33.030 --> 00:21:35.830
0.02 or 0.02, 0.01.

00:21:35.830 --> 00:21:38.330
It's a very small percentage.

00:21:38.330 --> 00:21:39.990
Because remember, the values
we're dealing with here are

00:21:39.990 --> 00:21:41.350
negative one to one.

00:21:41.350 --> 00:21:44.560
And 0 is supposed to be
that absolute center.

00:21:44.560 --> 00:21:46.670
But it fluctuates a tiny bit.

00:21:46.670 --> 00:21:50.060
Not a great amount, but if
there's a lot of wear and tear

00:21:50.060 --> 00:21:55.840
on the physical device you
might see greater values.

00:21:55.840 --> 00:21:59.070
So one more thing that I want
to talk about here is just

00:21:59.070 --> 00:22:00.400
about the user experience.

00:22:00.400 --> 00:22:03.010
When you're designing
applications and games that

00:22:03.010 --> 00:22:06.620
utilize digital input--

00:22:06.620 --> 00:22:09.360
and I'm going to steer away from
the analogs for a minute

00:22:09.360 --> 00:22:11.340
because you're not really going
to navigate around with

00:22:11.340 --> 00:22:15.080
that-- let's say, using the
Hat or D-pad, don't punish

00:22:15.080 --> 00:22:16.180
your users.

00:22:16.180 --> 00:22:19.460
Provide layouts that are
actually navigable and don't

00:22:19.460 --> 00:22:21.060
lead them into traps.

00:22:21.060 --> 00:22:24.080
So patterns that we found useful
are using shelves.

00:22:24.080 --> 00:22:26.840
You might remember or you might
have seen this in things

00:22:26.840 --> 00:22:30.670
like Netflix, where everything
is stacked as a shelf and you

00:22:30.670 --> 00:22:31.750
can just go along.

00:22:31.750 --> 00:22:35.070
It allows you to jump down or
jump up to get out of your

00:22:35.070 --> 00:22:37.480
current horizontal scroll.

00:22:37.480 --> 00:22:39.860
Because you might have gotten
100 units over.

00:22:39.860 --> 00:22:41.840
And you want to get back to some
menu item on the other

00:22:41.840 --> 00:22:42.975
side of the screen.

00:22:42.975 --> 00:22:44.910
TODD KERPELMAN: If I go down
and up or something?

00:22:44.910 --> 00:22:46.920
KRISTAN UCCELLO: Yeah, that's
your shortcut out, as opposed

00:22:46.920 --> 00:22:48.710
to having to scroll
all the way back.

00:22:48.710 --> 00:22:53.740
And tabs can be utilized in this
fashion to help a user

00:22:53.740 --> 00:22:56.520
jump between a lot
of content lists.

00:22:56.520 --> 00:22:59.980
It's OK to use lists but
always provide the out.

00:22:59.980 --> 00:23:02.830
Allow the user to jump to the
left or to the right as

00:23:02.830 --> 00:23:04.060
appropriate.

00:23:04.060 --> 00:23:05.360
And great grid is always good.

00:23:05.360 --> 00:23:08.890
Grid, it maps very well
to D-pad we find.

00:23:08.890 --> 00:23:12.980
So one last thing, I think
I mentioned it already.

00:23:12.980 --> 00:23:16.660
Allow the user to
remap the keys.

00:23:16.660 --> 00:23:17.330
This is important.

00:23:17.330 --> 00:23:18.650
Some people have preferences.

00:23:18.650 --> 00:23:20.530
Some people, when playing
first-person shooters, prefer

00:23:20.530 --> 00:23:23.490
the inverted axes control,
which means down is

00:23:23.490 --> 00:23:25.065
up and up is down.

00:23:25.065 --> 00:23:26.840
TODD KERPELMAN: Those people
are crazy, I think.

00:23:26.840 --> 00:23:28.200
KRISTAN UCCELLO: Well, what
do you prefer to use?

00:23:28.200 --> 00:23:29.620
TODD KERPELMAN: No,
I like up is up.

00:23:29.620 --> 00:23:30.047
KRISTAN UCCELLO: No
inverted control?

00:23:30.047 --> 00:23:32.370
I like up is up too.

00:23:32.370 --> 00:23:34.060
TODD KERPELMAN: What, you?

00:23:34.060 --> 00:23:36.490
This is crazy.

00:23:36.490 --> 00:23:37.990
KRISTAN UCCELLO: So yeah,
allow the user to assign

00:23:37.990 --> 00:23:39.493
different controllers to
different players, which we

00:23:39.493 --> 00:23:40.210
already covered.

00:23:40.210 --> 00:23:43.140
So at this point we're
going to demo.

00:23:43.140 --> 00:23:46.240
So we'll just go to that now.

00:23:46.240 --> 00:23:49.300
All right, so we chose
Cordy 2 here.

00:23:49.300 --> 00:23:52.620
I like this game because it's
very responsive when using

00:23:52.620 --> 00:23:53.700
controllers.

00:23:53.700 --> 00:23:55.400
I had a lot of fun playing
it on the TV.

00:23:55.400 --> 00:24:00.130
So on the first screen here,
we've got an example of using

00:24:00.130 --> 00:24:01.220
focus to your advantage.

00:24:01.220 --> 00:24:03.612
So those little white--

00:24:03.612 --> 00:24:06.460
TODD KERPELMAN: Yeah, if I
move my game pad left and

00:24:06.460 --> 00:24:10.610
right it'll go back and forth
between buy full game and

00:24:10.610 --> 00:24:11.590
choosing a level.

00:24:11.590 --> 00:24:13.730
KRISTAN UCCELLO: So this is a
really good example of how to

00:24:13.730 --> 00:24:15.030
illustrate visual focus.

00:24:15.030 --> 00:24:17.360
And this goes to what I was
talking about before when we

00:24:17.360 --> 00:24:20.670
were talking about the layouts
and how not to trap the user.

00:24:20.670 --> 00:24:23.260
So it's very important to orient
the user when they're

00:24:23.260 --> 00:24:27.310
navigating with an analog
stick or D-pad or hat.

00:24:27.310 --> 00:24:30.900
So we've got our little
game intro piece here.

00:24:30.900 --> 00:24:33.366
And Cordy's coming out.

00:24:33.366 --> 00:24:37.610
All right, let's jump through
the text that comes up.

00:24:37.610 --> 00:24:40.870
So this is all being done with
clicking on the button.

00:24:40.870 --> 00:24:42.620
TODD KERPELMAN: Right, you guys,
we're full screen so you

00:24:42.620 --> 00:24:43.150
can't see me.

00:24:43.150 --> 00:24:45.320
But listen, these are
joystick noises.

00:24:45.320 --> 00:24:47.900
I'm really actually playing
with a joystick,

00:24:47.900 --> 00:24:48.945
not the game pad.

00:24:48.945 --> 00:24:52.830
KRISTAN UCCELLO: It just it
feels very natural, almost

00:24:52.830 --> 00:24:55.220
like you're playing
a console, really.

00:24:55.220 --> 00:24:57.850
TODD KERPELMAN: Yeah,

00:24:57.850 --> 00:24:58.680
KRISTAN UCCELLO: It's
nice and smooth.

00:24:58.680 --> 00:25:02.004
And you can actually double
jump in this.

00:25:02.004 --> 00:25:02.830
There you go.

00:25:02.830 --> 00:25:03.490
TODD KERPELMAN: Oh,
look at that.

00:25:03.490 --> 00:25:07.520
KRISTAN UCCELLO: And for me,
playing platformers like this,

00:25:07.520 --> 00:25:09.030
it just makes all the
difference to use a

00:25:09.030 --> 00:25:10.270
controller.

00:25:10.270 --> 00:25:15.100
You're not distracted by any
on-screen touch needs.

00:25:15.100 --> 00:25:17.690
Even though the UI, in this
case, is still showing some

00:25:17.690 --> 00:25:21.620
touch commands, you have the
option to jump back on touch

00:25:21.620 --> 00:25:23.380
screen, which is great.

00:25:23.380 --> 00:25:26.200
TODD KERPELMAN: Yeah, I have to
say, this a lot more fun to

00:25:26.200 --> 00:25:29.750
control using a game
pad controller.

00:25:29.750 --> 00:25:32.390
I don't have to look to
see if my fingers are

00:25:32.390 --> 00:25:33.340
in the right place.

00:25:33.340 --> 00:25:34.580
I can just feel that.

00:25:34.580 --> 00:25:38.050
And this just feels, for me, a
lot more natural, playing a

00:25:38.050 --> 00:25:39.180
platformer game like this.

00:25:39.180 --> 00:25:39.770
KRISTAN UCCELLO: Absolutely.

00:25:39.770 --> 00:25:41.930
And one thing that actually
frustrates me a little bit

00:25:41.930 --> 00:25:45.980
about the on-screen controller
simulators, and that's what I

00:25:45.980 --> 00:25:49.520
call them is just simulation
of game pads.

00:25:49.520 --> 00:25:52.600
Sometimes when there's garbage
collection going on within the

00:25:52.600 --> 00:25:56.730
app or even on the platform,
you can get some lanky

00:25:56.730 --> 00:26:00.500
feedback from what you're
touching and actually cause

00:26:00.500 --> 00:26:02.880
the game not to do what
you intended it to do.

00:26:02.880 --> 00:26:05.376
I don't know if you've ever
experienced that.

00:26:05.376 --> 00:26:07.660
TODD KERPELMAN: I have
on occasion.

00:26:07.660 --> 00:26:10.810
KRISTAN UCCELLO: So it just
makes, for me, anyway, the

00:26:10.810 --> 00:26:14.055
argument that all games, really,
should try and strive

00:26:14.055 --> 00:26:17.200
and support game controllers
in this way.

00:26:17.200 --> 00:26:18.167
TODD KERPELMAN: Sounds good.

00:26:18.167 --> 00:26:21.650
Yeah, my only complaint here
is I'm sure this maps to a

00:26:21.650 --> 00:26:22.830
game pad button.

00:26:22.830 --> 00:26:23.450
But I don't know which
one it is.

00:26:23.450 --> 00:26:25.170
KRISTAN UCCELLO: Yeah, actually,
that's a good thing

00:26:25.170 --> 00:26:26.440
to point out.

00:26:26.440 --> 00:26:29.950
A lot of the on-screen
instructions in a game, if

00:26:29.950 --> 00:26:32.540
there is controller support,
they should detect that the

00:26:32.540 --> 00:26:35.800
input is mostly coming from a
controller and maybe adjust

00:26:35.800 --> 00:26:38.750
the instructions to map
to the buttons.

00:26:38.750 --> 00:26:39.630
So there you go.

00:26:39.630 --> 00:26:39.810
You figured it out.

00:26:39.810 --> 00:26:42.360
TODD KERPELMAN: There's
the B button.

00:26:42.360 --> 00:26:43.560
Wee!

00:26:43.560 --> 00:26:44.060
Look at that.

00:26:44.060 --> 00:26:44.780
There I go.

00:26:44.780 --> 00:26:45.120
All right.

00:26:45.120 --> 00:26:47.930
KRISTAN UCCELLO: So yeah, a
great game to play with a

00:26:47.930 --> 00:26:48.470
controller.

00:26:48.470 --> 00:26:50.120
There's lots out there.

00:26:50.120 --> 00:26:53.270
A lot of the controller vendors
highlight the apps

00:26:53.270 --> 00:26:57.050
that support their controllers
in the market.

00:26:57.050 --> 00:26:59.750
And you should check it
out for some examples.

00:26:59.750 --> 00:27:02.230
TODD KERPELMAN: Cool.

00:27:02.230 --> 00:27:03.840
All right, well, I could
play this for

00:27:03.840 --> 00:27:04.820
the rest of the video.

00:27:04.820 --> 00:27:07.302
But I won't because we got
some wrapping up to do.

00:27:07.302 --> 00:27:10.630
KRISTAN UCCELLO: All right,
let's get back into it.

00:27:10.630 --> 00:27:13.270
TODD KERPELMAN: All right,
and so we've got

00:27:13.270 --> 00:27:14.240
some Q&amp;A at the end.

00:27:14.240 --> 00:27:16.350
I actually had a couple
questions

00:27:16.350 --> 00:27:17.630
that are not on here.

00:27:17.630 --> 00:27:19.710
KRISTAN UCCELLO: Oh, yeah,
let's do some improv.

00:27:19.710 --> 00:27:23.280
TODD KERPELMAN: So at the
beginning, you talked about

00:27:23.280 --> 00:27:28.060
there's two ways to do connect,
Bluetooth or USB.

00:27:28.060 --> 00:27:30.450
Does a developer need to care?

00:27:30.450 --> 00:27:34.131
Do I need to know how my
device is connected?

00:27:34.131 --> 00:27:36.860
KRISTAN UCCELLO: If you're
developing for Android at

00:27:36.860 --> 00:27:39.960
anything less than API level
16 you're going to care.

00:27:39.960 --> 00:27:44.630
Because while Android treats
both USB and Bluetooth devices

00:27:44.630 --> 00:27:49.150
as just input devices, when it
comes to monitoring their

00:27:49.150 --> 00:27:50.520
connections and disconnections--

00:27:50.520 --> 00:27:52.600
which is something you will have
to do on anything lower

00:27:52.600 --> 00:27:54.150
than API level 16--

00:27:54.150 --> 00:27:56.920
you're going to have to write
two broadcast listeners, one

00:27:56.920 --> 00:27:59.830
for the USB, one
for Bluetooth.

00:27:59.830 --> 00:28:01.235
That's where the differentiation
comes in.

00:28:01.235 --> 00:28:02.000
TODD KERPELMAN: Got you.

00:28:02.000 --> 00:28:06.710
OK, so if I've got a high-end
game, clearly only modern

00:28:06.710 --> 00:28:09.390
devices might work moving
forward, maybe I don't have to

00:28:09.390 --> 00:28:11.950
care if I want to reach
the broadest range of

00:28:11.950 --> 00:28:12.825
customers as possible.

00:28:12.825 --> 00:28:13.620
KRISTAN UCCELLO:
Exactly, yeah.

00:28:13.620 --> 00:28:17.010
TODD KERPELMAN: OK, now I've
seen some game controllers or

00:28:17.010 --> 00:28:20.440
gaming devices where essentially
the controller is

00:28:20.440 --> 00:28:23.315
integrated right into
the device.

00:28:23.315 --> 00:28:24.960
KRISTAN UCCELLO: I've seen
a few of those myself.

00:28:24.960 --> 00:28:26.620
They're quite amazing.

00:28:26.620 --> 00:28:28.990
TODD KERPELMAN: How is
that represented?

00:28:28.990 --> 00:28:31.320
And I guess, do I need to
care about connected or

00:28:31.320 --> 00:28:32.120
disconnected?

00:28:32.120 --> 00:28:35.840
Because it'd be hard to
disconnect a shield controller

00:28:35.840 --> 00:28:37.255
without breaking it.

00:28:37.255 --> 00:28:40.120
KRISTAN UCCELLO: You're
probably right.

00:28:40.120 --> 00:28:43.170
If we think about other ones
that are similar form factor,

00:28:43.170 --> 00:28:46.040
it all depends on how
it's connected.

00:28:46.040 --> 00:28:49.300
If you're just targeting
one device--

00:28:49.300 --> 00:28:51.580
I don't know how likely
a case that would be--

00:28:51.580 --> 00:28:55.300
you're still going to have to
detect the input device as

00:28:55.300 --> 00:28:56.070
being there.

00:28:56.070 --> 00:29:00.310
So that's a good question.

00:29:00.310 --> 00:29:03.800
I'm not quite sure what the
right answer is there.

00:29:03.800 --> 00:29:05.940
You get a point for that one.

00:29:05.940 --> 00:29:07.800
I would say, just treat
it like you

00:29:07.800 --> 00:29:08.690
would any other device.

00:29:08.690 --> 00:29:09.960
Don't assume that it's there.

00:29:09.960 --> 00:29:12.020
You're going to try and build
your application as you said

00:29:12.020 --> 00:29:15.990
before, for multiple devices
and form factors.

00:29:15.990 --> 00:29:17.170
Don't make assumptions.

00:29:17.170 --> 00:29:17.950
That's what I would say.

00:29:17.950 --> 00:29:20.000
TODD KERPELMAN: Fair enough.

00:29:20.000 --> 00:29:22.470
Moving forward, the world's
going wireless.

00:29:22.470 --> 00:29:23.910
Do you think Bluetooth
is basically

00:29:23.910 --> 00:29:25.740
going to be the standard?

00:29:25.740 --> 00:29:29.060
KRISTAN UCCELLO: I absolutely
think so.

00:29:29.060 --> 00:29:32.000
If we just think about what it
means to have wires-- and I'm

00:29:32.000 --> 00:29:33.700
going to go back to TV
because I'm a bit

00:29:33.700 --> 00:29:35.470
passionate about TV--

00:29:35.470 --> 00:29:38.650
it really doesn't make sense
to have a really long USB

00:29:38.650 --> 00:29:42.360
cable plugged into your TV pr
your set-top box while you're

00:29:42.360 --> 00:29:43.240
sitting on the couch.

00:29:43.240 --> 00:29:45.360
People trip over it.

00:29:45.360 --> 00:29:47.630
Yes it provides a very
clean signal.

00:29:47.630 --> 00:29:49.520
But it's at the expense
of being tethered.

00:29:49.520 --> 00:29:53.935
So as we, in our lives, move
around more and care about

00:29:53.935 --> 00:29:56.460
bringing our data with us and
interoperability between

00:29:56.460 --> 00:30:01.270
devices, I think Bluetooth is
only natural as the de facto

00:30:01.270 --> 00:30:03.020
standard, if it's not already.

00:30:03.020 --> 00:30:04.485
TODD KERPELMAN: Is that going
to be replaced by a

00:30:04.485 --> 00:30:05.650
new-and-improved standard?

00:30:05.650 --> 00:30:07.080
KRISTAN UCCELLO: I don't know.

00:30:07.080 --> 00:30:07.410
Do you know of a new standard?

00:30:07.410 --> 00:30:08.970
TODD KERPELMAN: No,
but I figured if

00:30:08.970 --> 00:30:09.810
anyone knew, you would.

00:30:09.810 --> 00:30:10.980
KRISTAN UCCELLO: I
mean, who knows?

00:30:10.980 --> 00:30:12.210
It could be the internet
is everywhere

00:30:12.210 --> 00:30:14.330
and just powers things.

00:30:14.330 --> 00:30:17.400
TODD KERPELMAN: OK, let's see.

00:30:17.400 --> 00:30:22.120
And then, so speaking of modern
game controllers,

00:30:22.120 --> 00:30:25.360
there's been, certainly in
the news, a lot about

00:30:25.360 --> 00:30:28.730
Android-powered gaming
devices.

00:30:28.730 --> 00:30:32.410
I'm thinking like the Ouya and
the Shield and probably more

00:30:32.410 --> 00:30:33.810
in the future.

00:30:33.810 --> 00:30:37.020
If I'm a game developer, is
there anything I need to know

00:30:37.020 --> 00:30:41.420
specifically about developing
for this new generation of

00:30:41.420 --> 00:30:43.680
Android-powered game devices?

00:30:43.680 --> 00:30:48.084
Or can I just address them
like normal controllers?

00:30:48.084 --> 00:30:50.610
KRISTAN UCCELLO: I'm going
to answer it this way--

00:30:50.610 --> 00:30:53.130
first piece of advice, do
not lock yourself in

00:30:53.130 --> 00:30:55.590
any vendors' APIs.

00:30:55.590 --> 00:30:58.240
That is a good way to shoot
yourself in the foot.

00:30:58.240 --> 00:31:01.630
Now, there are reasons to do
that if you have deals with a

00:31:01.630 --> 00:31:02.600
particular device.

00:31:02.600 --> 00:31:04.190
But it means you're going
to limit yourself

00:31:04.190 --> 00:31:06.490
to just that device.

00:31:06.490 --> 00:31:10.860
A lot of these Android game
consoles all share a lot of

00:31:10.860 --> 00:31:13.530
similar characteristics.

00:31:13.530 --> 00:31:14.645
They're usually boxes.

00:31:14.645 --> 00:31:17.140
They're usually boxes connected
to televisions.

00:31:17.140 --> 00:31:20.600
And they usually have wireless
controllers.

00:31:20.600 --> 00:31:25.530
And they all have four buttons
on the right hand.

00:31:25.530 --> 00:31:27.860
And they have an analog stick
available on the left hand.

00:31:27.860 --> 00:31:30.240
Some of them have a second
analog stick.

00:31:30.240 --> 00:31:31.080
And they usually
have triggers.

00:31:31.080 --> 00:31:35.130
So if you've ever played with
any one of the popular

00:31:35.130 --> 00:31:36.786
consoles out there--

00:31:36.786 --> 00:31:38.440
TODD KERPELMAN: You generally
know the capabilities?

00:31:38.440 --> 00:31:40.660
KRISTAN UCCELLO: They kind of
all look the same, yeah.

00:31:40.660 --> 00:31:44.140
That said, what those
keys map to for that

00:31:44.140 --> 00:31:46.970
device could be different.

00:31:46.970 --> 00:31:53.260
So I would say, see if you can
take a controller from one

00:31:53.260 --> 00:31:55.110
device and connect it
to another one.

00:31:55.110 --> 00:31:59.050
And see if it actually gives
you what you expect back on

00:31:59.050 --> 00:32:02.420
what the axes names are and
what the buttons are when

00:32:02.420 --> 00:32:03.535
those events come in.

00:32:03.535 --> 00:32:07.700
TODD KERPELMAN: All right, and
finally, if I'm looking at all

00:32:07.700 --> 00:32:09.810
this and thinking, boy this
sounds like a lot of work.

00:32:09.810 --> 00:32:13.384
Maybe there's a game engine
that can do it all for me?

00:32:13.384 --> 00:32:16.630
KRISTAN UCCELLO: There
are game engines.

00:32:16.630 --> 00:32:18.180
I'm partial to a few myself.

00:32:18.180 --> 00:32:21.340
I mean, I haven't played
with Unity that much.

00:32:21.340 --> 00:32:24.090
But I hear good things and
I've seen it around.

00:32:24.090 --> 00:32:26.190
libgdx is one of my favorites.

00:32:26.190 --> 00:32:28.400
And it does come with game
controller support.

00:32:28.400 --> 00:32:29.700
It's an open-source project.

00:32:29.700 --> 00:32:33.580
I played with jMonkeyEngine,
which is also pretty good.

00:32:36.190 --> 00:32:38.680
If we were to think about web
games just for a second-- and

00:32:38.680 --> 00:32:39.760
I know it's a little weird
to mention it.

00:32:39.760 --> 00:32:42.500
But if you load a web page on
your Android device and you

00:32:42.500 --> 00:32:46.540
try and use a game controller,
none of that ever works.

00:32:46.540 --> 00:32:47.640
TODD KERPELMAN: I've
never tried.

00:32:47.640 --> 00:32:49.200
But I'll assume that.

00:32:49.200 --> 00:32:51.030
KRISTAN UCCELLO: So there's
no good engines--

00:32:51.030 --> 00:32:52.100
is what I'm trying to say--

00:32:52.100 --> 00:32:55.050
that I've seen that support game
controllers on a browser.

00:32:58.340 --> 00:33:01.270
TODD KERPELMAN: But it seems
like most modern game engines

00:33:01.270 --> 00:33:03.335
these days will have some type
of controller support?

00:33:03.335 --> 00:33:04.340
KRISTAN UCCELLO: Absolutely.

00:33:04.340 --> 00:33:07.140
It's sort of essential for
a game engine to provide

00:33:07.140 --> 00:33:09.470
game-controller support.

00:33:09.470 --> 00:33:12.430
So if you're choosing one and it
doesn't, maybe you want to

00:33:12.430 --> 00:33:13.205
question using that.

00:33:13.205 --> 00:33:13.940
TODD KERPELMAN: Write them
an angry letter.

00:33:13.940 --> 00:33:16.010
KRISTAN UCCELLO: Or you know
what, better yet, if it's an

00:33:16.010 --> 00:33:18.060
open-sourced project,
fix the problem.

00:33:18.060 --> 00:33:18.920
Submit the code.

00:33:18.920 --> 00:33:19.920
Patch it.

00:33:19.920 --> 00:33:21.310
Make the internet and world
a better place.

00:33:21.310 --> 00:33:23.560
TODD KERPELMAN: Oh, it's much
better than an angry letter.

00:33:23.560 --> 00:33:24.820
KRISTAN UCCELLO: There's
too many angry

00:33:24.820 --> 00:33:25.795
letters in the world.

00:33:25.795 --> 00:33:26.730
TODD KERPELMAN: That is true.

00:33:26.730 --> 00:33:28.720
I get them.

00:33:28.720 --> 00:33:31.120
All right, well, I think that
just about wraps it up.

00:33:31.120 --> 00:33:32.850
Let me see, do we have anything
else on our slides?

00:33:32.850 --> 00:33:35.110
KRISTAN UCCELLO: I think
there's just one more.

00:33:35.110 --> 00:33:36.275
TODD KERPELMAN: Oh,
that's right.

00:33:36.275 --> 00:33:39.060
KRISTAN UCCELLO: So I guess
we'll point out here, I'm in

00:33:39.060 --> 00:33:41.610
the process of writing a
series of blog posts.

00:33:41.610 --> 00:33:45.020
I'm targeting about five
different posts right now that

00:33:45.020 --> 00:33:48.280
really go in depth technically
on all the stuff that we

00:33:48.280 --> 00:33:50.570
talked about today and
a little bit more

00:33:50.570 --> 00:33:52.030
around the UX guidance.

00:33:52.030 --> 00:33:54.035
So keep an eye out for those.

00:33:54.035 --> 00:33:55.620
They should be in
the near future.

00:33:55.620 --> 00:33:57.610
TODD KERPELMAN: Where would
I find these blog posts?

00:33:57.610 --> 00:34:00.140
KRISTAN UCCELLO: You would
find them on the Android

00:34:00.140 --> 00:34:01.735
Developers blog.

00:34:01.735 --> 00:34:03.525
TODD KERPELMAN: OK, I
sometime read that.

00:34:03.525 --> 00:34:05.180
KRISTAN UCCELLO: I read
that regularly.

00:34:05.180 --> 00:34:06.570
I'm a fan.

00:34:06.570 --> 00:34:08.480
TODD KERPELMAN: All right,
so people just

00:34:08.480 --> 00:34:09.370
keep an eye out there.

00:34:09.370 --> 00:34:13.000
And they'll see your blog posts
in the next week or two?

00:34:13.000 --> 00:34:14.170
KRISTAN UCCELLO: I don't know
if it's going to be in the

00:34:14.170 --> 00:34:15.159
next week or two.

00:34:15.159 --> 00:34:18.640
I want to make sure all the
details are nailed down solid.

00:34:18.640 --> 00:34:20.340
I don't want to give
anybody bad advice.

00:34:20.340 --> 00:34:21.670
So very, very soon.

00:34:21.670 --> 00:34:23.390
TODD KERPELMAN: I'm trying to
hold you to a deadline.

00:34:23.390 --> 00:34:25.132
KRISTAN UCCELLO:
I don't get it.

00:34:25.132 --> 00:34:26.815
You can't estimate
things like that.

00:34:26.815 --> 00:34:29.429
TODD KERPELMAN: So by the time
this video's out, all five

00:34:29.429 --> 00:34:32.610
blog posts will be published
and they'll be perfect.

00:34:32.610 --> 00:34:33.928
KRISTAN UCCELLO: Todd's
going to write them.

00:34:33.928 --> 00:34:36.514
TODD KERPELMAN: You heard
it here first.

00:34:36.514 --> 00:34:37.330
KRISTAN UCCELLO: Thanks, Todd.

00:34:37.330 --> 00:34:37.940
TODD KERPELMAN: All
right, well, cool.

00:34:37.940 --> 00:34:40.510
Thank you very much for joining
us, internet audience.

00:34:40.510 --> 00:34:41.940
And thank you, Krispy.

00:34:41.940 --> 00:34:43.170
KRISTAN UCCELLO: My pleasure.

00:34:43.170 --> 00:34:44.920
TODD KERPELMAN: For providing
some really excellent

00:34:44.920 --> 00:34:45.949
content this week.

00:34:45.949 --> 00:34:46.209
KRISTAN UCCELLO: Thanks.

00:34:46.209 --> 00:34:47.440
TODD KERPELMAN: And
we will see you

00:34:47.440 --> 00:34:49.200
guys in a couple weeks.

00:34:49.200 --> 00:34:50.450
Bye.

