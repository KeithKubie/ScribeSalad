WEBVTT
Kind: captions
Language: en-GB

00:00:07.984 --> 00:00:11.477
[APPLAUSE]

00:00:21.960 --> 00:00:24.410
Killer robots.

00:00:24.410 --> 00:00:29.900
So killer robots
actually are real,

00:00:29.900 --> 00:00:32.189
and there are companies
making killer robots.

00:00:32.189 --> 00:00:34.160
And so you need to know
about killer robots.

00:00:34.160 --> 00:00:36.055
The characteristics
of killer robots.

00:00:36.055 --> 00:00:37.430
There's two main
characteristics.

00:00:37.430 --> 00:00:40.130
Of course, firstly,
killer robots can kill.

00:00:40.130 --> 00:00:42.080
Secondly killer
robots are robots.

00:00:42.080 --> 00:00:44.000
But there's another
key characteristic.

00:00:44.000 --> 00:00:46.340
See, killer robots are
controlled by humans.

00:00:46.340 --> 00:00:51.660
Because there's a
line at this point.

00:00:51.660 --> 00:00:54.732
So this is a YouTube
screenshot of Boston Dynamics,

00:00:54.732 --> 00:00:55.940
a company that makes killer--

00:00:55.940 --> 00:00:57.260
I won't play the video--

00:00:57.260 --> 00:01:02.260
but this is a, well, you
can find it on YouTube.

00:01:02.260 --> 00:01:04.470
It's uploaded in October 2003.

00:01:04.470 --> 00:01:07.490
It's fabulous video
of a killer robot.

00:01:07.490 --> 00:01:10.280
And basically it just spends
eight minutes running around

00:01:10.280 --> 00:01:12.810
the car park of this
company in America

00:01:12.810 --> 00:01:14.490
that designed this killer robot.

00:01:14.490 --> 00:01:18.860
And occasionally it runs
past a fat, balding bloke

00:01:18.860 --> 00:01:20.360
who's holding a controller.

00:01:20.360 --> 00:01:23.030
And he's running around you
know he's running this killer

00:01:23.030 --> 00:01:23.985
robot around.

00:01:23.985 --> 00:01:26.360
And then you see at the end
of the day, that's the point.

00:01:26.360 --> 00:01:28.193
The point is it's not
just the killer robot.

00:01:28.193 --> 00:01:30.440
It's the bloke with
the controller.

00:01:30.440 --> 00:01:32.830
He's controlling
the killer robot.

00:01:32.830 --> 00:01:36.840
So the robot running
around the car park

00:01:36.840 --> 00:01:38.850
is being controlled by a human.

00:01:38.850 --> 00:01:41.610
And the question is, can a
computer control that killer

00:01:41.610 --> 00:01:43.620
robot instead?

00:01:43.620 --> 00:01:45.250
Computers, disruptive
technology,

00:01:45.250 --> 00:01:48.000
computers like to relieve
humans of their jobs.

00:01:48.000 --> 00:01:51.210
So could a computer
control a killer robot?

00:01:51.210 --> 00:01:52.980
And in fact, we could
go a step further.

00:01:52.980 --> 00:01:55.105
Could we write an app that
people could download on

00:01:55.105 --> 00:02:05.620
their phone now I know how much time I have. On our phone, when
you type in someone's name

00:02:05.620 --> 00:02:08.604
into the app, then some killer
robots are unleashed and goes

00:02:08.604 --> 00:02:09.520
and kills that person.

00:02:09.520 --> 00:02:13.930
So could there be a killer
robot app, can computers do that?

00:02:13.930 --> 00:02:17.600
So that's kind of an
interesting question.

00:02:17.600 --> 00:02:20.320
So what would a
company need in order

00:02:20.320 --> 00:02:21.780
to make that killer robot app?

00:02:23.260 --> 00:02:25.832
So firstly, they'd need
a good database, right?

00:02:25.832 --> 00:02:27.790
Because obviously you'd
type someone's name in,

00:02:27.790 --> 00:02:28.873
and it's got to find them.

00:02:28.873 --> 00:02:31.150
So you need names, address,
and accurate information

00:02:31.150 --> 00:02:33.292
about the daily routines
of billions of people.

00:02:33.292 --> 00:02:35.500
Secondly, we need some people
that can write the app.

00:02:35.500 --> 00:02:37.240
So we need employees who are
very good at writing computer

00:02:37.240 --> 00:02:37.870
programmes.

00:02:37.870 --> 00:02:41.110
Thirdly, we need very good
facial recognition software

00:02:41.110 --> 00:02:43.780
to make sure that the killer
robot kills the right person.

00:02:43.780 --> 00:02:47.720
Fourthly, we're going to need
experience in kind of control--

00:02:47.720 --> 00:02:50.350
now this is one of the hardest
parts-- we need to control

00:02:50.350 --> 00:02:53.770
the killer robots
out of this car park

00:02:53.770 --> 00:02:57.127
and towards the correct person.

00:02:57.127 --> 00:02:59.710
And then finally, of course, we
need an army of killer robots.

00:02:59.710 --> 00:03:02.370
So if we have all
of those things,

00:03:02.370 --> 00:03:04.720
then we can write
a killer robot app.

00:03:04.720 --> 00:03:07.300
So once the company
what's the company that

00:03:07.300 --> 00:03:10.900
has all of those things?

00:03:10.900 --> 00:03:12.650
How about Google?

00:03:12.650 --> 00:03:14.894
So let's have a look.

00:03:14.894 --> 00:03:16.685
Does Google have names,
addresses, location

00:03:16.685 --> 00:03:17.601
of billions of people?

00:03:17.601 --> 00:03:18.520
Absolutely.

00:03:18.520 --> 00:03:20.329
Even if you don't
have an Android phone,

00:03:20.329 --> 00:03:22.120
even if you don't have
a smartphone at all,

00:03:22.120 --> 00:03:23.470
somebody you know--

00:03:23.470 --> 00:03:28.930
your boss, your work colleague,
your wife, your granddaughter,

00:03:28.930 --> 00:03:31.600
somebody has typed your
name and your phone

00:03:31.600 --> 00:03:35.709
number and your address
into their Android contacts,

00:03:35.709 --> 00:03:37.750
and they've synced that
contact list with Google.

00:03:37.750 --> 00:03:40.870
And Google knows what your
name is, what your address is,

00:03:40.870 --> 00:03:43.474
and where you live, and
your phone number too.

00:03:43.474 --> 00:03:45.890
So does Google have employees
that can write good computer

00:03:45.890 --> 00:03:46.919
programmes?
Of course it does.

00:03:46.919 --> 00:03:49.180
Does Google have facial
recognition software?

00:03:49.180 --> 00:03:49.930
Of course it does.

00:03:49.930 --> 00:03:52.138
I had an Android tablet
once, and I just looked at it

00:03:52.138 --> 00:03:54.584
and it would unlock it
was a very cool thing.

00:03:54.584 --> 00:03:57.250
Does it have computer programmes
that can drive machines around?

00:03:57.250 --> 00:03:59.066
Of course it does,
because it's currently

00:03:59.066 --> 00:04:00.940
spending a lot of money
on self-driving cars.

00:04:00.940 --> 00:04:04.330
So the only question
left is does Google

00:04:04.330 --> 00:04:07.670
have an army of killer robots?

00:04:07.670 --> 00:04:10.090
And the answer
is, well, you see,

00:04:10.090 --> 00:04:13.870
Google has a motto,
which says don't be evil,

00:04:13.870 --> 00:04:17.680
which it quietly
dropped in 2015,

00:04:17.680 --> 00:04:23.140
and possibly unrelated to
that, in December 2013,

00:04:23.140 --> 00:04:27.400
Google bought Boston Dynamics
and seven other robot

00:04:27.400 --> 00:04:29.900
companies.

00:04:29.900 --> 00:04:33.895
And now suddenly Google owns
all these scary killer robots.

00:04:38.455 --> 00:04:40.580
So how many killer robots
have Google actually got?

00:04:40.580 --> 00:04:43.490
Probably enough to make it
feasible to write that app.

00:04:43.490 --> 00:04:46.670
So actually, I think
in theory, I've

00:04:46.670 --> 00:04:48.500
attempted to
construct a proof that

00:04:48.500 --> 00:04:52.040
in theory somebody at Google
could write an app which really

00:04:52.040 --> 00:04:54.960
would have the property that
if you type someone's name in

00:04:54.960 --> 00:04:56.630
and it unleashes several--

00:04:56.630 --> 00:04:59.480
I mean, you'd probably have to
do some experiments to work out

00:04:59.480 --> 00:05:00.590
how many was enough--

00:05:00.590 --> 00:05:03.590
but enough killer robots
to finish this person off.

00:05:03.590 --> 00:05:06.050
So that's something
computers can do.

00:05:06.050 --> 00:05:10.010
I think at this point in time,
all the ingredients are there.

00:05:10.010 --> 00:05:13.190
So this talk about what
computers can't do.

00:05:13.190 --> 00:05:17.510
This, I think, puts it into
some kind of perspective.

00:05:17.510 --> 00:05:19.250
So here's another question.

00:05:19.250 --> 00:05:24.679
If Google was sentient it
and realised that it could,

00:05:24.679 --> 00:05:26.720
maybe you wouldn't need
a human to write the app.

00:05:26.720 --> 00:05:28.345
Maybe the computer
could write the app.

00:05:28.345 --> 00:05:29.845
Maybe very 2001.

00:05:29.845 --> 00:05:31.470
Maybe the computer
could write the app.

00:05:31.470 --> 00:05:32.540
And maybe the
computer could just

00:05:32.540 --> 00:05:34.280
decide to take over
the world because it's

00:05:34.280 --> 00:05:35.780
got access to the
facial recognition

00:05:35.780 --> 00:05:36.863
software and the database.

00:05:36.863 --> 00:05:41.520
Maybe the computer could just
go rogue and take over the world

00:05:41.520 --> 00:05:42.180
anyway.

00:05:42.180 --> 00:05:44.390
So maybe computers would
find that appealing.

00:05:44.390 --> 00:05:47.146
But I'm not so sure, because
for a computer to make that leap

00:05:47.146 --> 00:05:49.520
and decide that it's going to
kill everyone in the world,

00:05:49.520 --> 00:05:52.190
the computer would have
to be able to think.

00:05:52.190 --> 00:05:54.170
And I don't know if
computers can think.

00:05:54.170 --> 00:05:56.450
So we've seen something
computers can do if somebody

00:05:56.450 --> 00:05:58.550
writes the programme,
they'd kill everyone.

00:05:58.550 --> 00:06:01.340
But we've also seen
maybe they can't think.

00:06:01.340 --> 00:06:03.440
And in my personal
opinion, I don't

00:06:03.440 --> 00:06:05.530
think computers can think.

00:06:05.530 --> 00:06:08.210
So here's a picture
of two things.

00:06:08.210 --> 00:06:10.630
The thing on the left
is Garry Kasparov.

00:06:10.630 --> 00:06:14.210
He was the world chess
champion in 1997, which

00:06:14.210 --> 00:06:15.470
is when this photo was taken.

00:06:15.470 --> 00:06:17.640
And the thing on the
right is what at the time

00:06:17.640 --> 00:06:19.380
was a very
fancy-looking monitor.

00:06:19.380 --> 00:06:21.579
And that monitor is
attached to a computer.

00:06:21.579 --> 00:06:23.120
And the computer is
called Deep Blue.

00:06:23.120 --> 00:06:24.320
And it was made by IBM.

00:06:24.320 --> 00:06:27.570
And it was the best
chess-playing computer

00:06:27.570 --> 00:06:28.520
of that time.

00:06:28.520 --> 00:06:32.210
So world chess champion versus
computer chess champion.

00:06:32.210 --> 00:06:34.890
This was a six-game
match played in 1997.

00:06:34.890 --> 00:06:35.780
And it was big news.

00:06:35.780 --> 00:06:39.500
Kasparov lost, and
1997 marked the era

00:06:39.500 --> 00:06:42.602
when computers became
better at chess than humans.

00:06:42.602 --> 00:06:44.060
And since then,
all that's happened

00:06:44.060 --> 00:06:45.976
is that computers got
much, much, much better.

00:06:45.976 --> 00:06:47.750
And now there aren't
any more competitions

00:06:47.750 --> 00:06:50.960
between humans and computers,
because no human with any sense

00:06:50.960 --> 00:06:53.510
would ever dream of trying
to compete for chess.

00:06:53.510 --> 00:06:55.140
So who's thinking
in this picture?

00:06:55.140 --> 00:06:59.960
Well, Garry Kasparov certainly
looks as if he's thinking.

00:06:59.960 --> 00:07:02.090
I think that's a
Sicilian defence.

00:07:02.090 --> 00:07:03.890
They're a few moves
in, and he's probably

00:07:03.890 --> 00:07:06.860
trying to work out what
the best move to play is.

00:07:06.860 --> 00:07:09.140
And he's using his intuition.

00:07:09.140 --> 00:07:10.130
He's using insight.

00:07:10.130 --> 00:07:11.330
He's using experience.

00:07:11.330 --> 00:07:14.340
He's also using psychology, even
though he's playing a computer.

00:07:14.340 --> 00:07:16.130
He's played this
computer before.

00:07:16.130 --> 00:07:17.780
He knows what kind of positions
that computer plays well

00:07:17.780 --> 00:07:19.988
and what kind of positions
that computer plays badly.

00:07:19.988 --> 00:07:22.640
And he's adapting his play to
try and beat that computer.

00:07:22.640 --> 00:07:24.152
What's the thing
on the right doing?

00:07:24.152 --> 00:07:25.610
Is the thing on
the right thinking?

00:07:25.610 --> 00:07:27.740
I'm not so sure that
thing he's thinking.

00:07:27.740 --> 00:07:29.060
Is Deep Blue thinking?

00:07:29.060 --> 00:07:29.870
I don't know.

00:07:29.870 --> 00:07:30.952
What does a computer do?

00:07:30.952 --> 00:07:32.660
A computer is a device
that is very, very

00:07:32.660 --> 00:07:37.110
good at following instructions
very, very quickly.

00:07:37.110 --> 00:07:39.650
And that's different to
thinking, in my opinion.

00:07:39.650 --> 00:07:42.050
So the basic logical
instructions that the computer

00:07:42.050 --> 00:07:44.690
follows contain something
called a computer programme.

00:07:44.690 --> 00:07:46.640
But I'm going to have to tell
you something about computers

00:07:46.640 --> 00:07:48.181
and computer programmes
in this talk,

00:07:48.181 --> 00:07:50.310
but I'm going to try
and keep it simple,

00:07:50.310 --> 00:07:53.600
whilst also attempting to
get to the difficult point.

00:07:53.600 --> 00:07:56.960
So let me tell you two
things about a computer.

00:07:56.960 --> 00:07:58.670
First thing is the
computer has memory.

00:07:58.670 --> 00:08:00.380
A computer needs to
store information.

00:08:00.380 --> 00:08:01.970
Because sometimes it
does calculations then

00:08:01.970 --> 00:08:03.840
remembers the answer to look
back at the answer later.

00:08:03.840 --> 00:08:06.120
So the computer needs memory
because a computer stores

00:08:06.120 --> 00:08:06.620
information.

00:08:06.620 --> 00:08:08.420
The computer programme is
typically stored in the memory

00:08:08.420 --> 00:08:09.050
as well.

00:08:09.050 --> 00:08:11.240
And a computer also
needs a processor.

00:08:11.240 --> 00:08:14.300
The processor is basically the
bit of the computer that reads

00:08:14.300 --> 00:08:16.670
all the instructions in the
programme and does them one

00:08:16.670 --> 00:08:18.110
by one very, very quickly.

00:08:18.110 --> 00:08:19.550
And sometimes the
instructions say, go and do

00:08:19.550 --> 00:08:20.600
this instruction instead.

00:08:20.600 --> 00:08:21.620
Jump over here.

00:08:21.620 --> 00:08:24.980
And the processor
works very, very fast

00:08:24.980 --> 00:08:27.290
following these instructions.

00:08:27.290 --> 00:08:32.480
So nowadays a 4 gigahertz
processor, you probably

00:08:32.480 --> 00:08:34.009
have one of those
in your phone now,

00:08:34.009 --> 00:08:41.020
that's following 4 billion
instructions per second.

00:08:41.020 --> 00:08:44.810
And so you can see even in
1997, because IBM had a lot

00:08:44.810 --> 00:08:47.450
of interest in computers
and doing a lot of research

00:08:47.450 --> 00:08:50.480
into making computers very fast,
that computer Deep Blue was

00:08:50.480 --> 00:08:53.720
analysing 200 million chess
positions every second.

00:08:53.720 --> 00:08:54.650
So what was it doing?

00:08:54.650 --> 00:08:56.180
It was just trying
all the moves--

00:08:56.180 --> 00:08:57.600
even the most ridiculous.

00:08:57.600 --> 00:08:59.262
It would try moves.

00:08:59.262 --> 00:09:01.470
That piece I moved last
time, let's just put it back.

00:09:01.470 --> 00:09:03.080
That's the kind of
move it would try.

00:09:03.080 --> 00:09:04.410
It would try every single move.

00:09:04.410 --> 00:09:06.020
And it would try
all the responses

00:09:06.020 --> 00:09:07.380
and keep going very, very fast.

00:09:07.380 --> 00:09:09.088
And then it would make
some kind of guess

00:09:09.088 --> 00:09:11.120
as to which positions
looked OK, and then they

00:09:11.120 --> 00:09:11.970
follow up with them.

00:09:11.970 --> 00:09:13.520
But Kasparov wasn't
playing like that.

00:09:13.520 --> 00:09:15.478
There were many moves in
a given chess position

00:09:15.478 --> 00:09:18.340
the Kasparov wouldn't even
consider because he could see.

00:09:18.340 --> 00:09:19.070
He had intuition.

00:09:19.070 --> 00:09:20.486
He knew they were
going backwards.

00:09:20.486 --> 00:09:24.197
But intuition ultimately gets
defeated by brute force search,

00:09:24.197 --> 00:09:26.780
analysing millions and millions
of chess positions per second.

00:09:26.780 --> 00:09:29.000
Eventually we've now
proved that computers

00:09:29.000 --> 00:09:30.570
can do this better than humans.

00:09:30.570 --> 00:09:32.330
So I don't think
that's thinking.

00:09:32.330 --> 00:09:35.720
So I think they're kind of
safe from computers going rogue

00:09:35.720 --> 00:09:37.050
and trying to kill us all.

00:09:37.050 --> 00:09:39.570
But you see the reason I
don't think it is thinking

00:09:39.570 --> 00:09:41.790
is because I do a lot of
unloading the dishwasher.

00:09:41.790 --> 00:09:43.200
And unloading the
dishwasher it's

00:09:43.200 --> 00:09:44.890
a very mechanical procedure.

00:09:44.890 --> 00:09:45.840
There's a plate.

00:09:45.840 --> 00:09:46.980
I know where the plates go.

00:09:46.980 --> 00:09:47.640
There's the bowls.

00:09:47.640 --> 00:09:48.580
And I know where the bowls go.

00:09:48.580 --> 00:09:50.830
There's the cutlery and I
know where the cutlery goes.

00:09:50.830 --> 00:09:53.700
And I just sit,
just unthinkingly,

00:09:53.700 --> 00:09:55.340
I sit and put everything away.

00:09:55.340 --> 00:09:57.450
And I actually even
unload the dishwasher

00:09:57.450 --> 00:09:59.880
in exactly the same
order every time.

00:09:59.880 --> 00:10:03.030
Because I'm trying to be like
a computer in some sense.

00:10:03.030 --> 00:10:05.074
And while I'm doing
that I'm thinking.

00:10:05.074 --> 00:10:07.240
And I'm certainly not
thinking about what I'm doing.

00:10:07.240 --> 00:10:09.281
What I'm doing is somehow
subconsciously hovering

00:10:09.281 --> 00:10:10.290
in the background.

00:10:10.290 --> 00:10:12.540
Yeah, I tend to be
thinking about mathematics,

00:10:12.540 --> 00:10:14.130
or whether I'm
hungry, or what I'm

00:10:14.130 --> 00:10:17.190
going to do after I finish
unloading the dishwasher.

00:10:17.190 --> 00:10:19.107
And that's thinking.

00:10:19.107 --> 00:10:21.690
And both the computer, when we
have robots unload dishwashers,

00:10:21.690 --> 00:10:26.340
they would just download the
dishwasher and they'd be gone.

00:10:26.340 --> 00:10:29.679
So I need to talk
about certain puzzles.

00:10:29.679 --> 00:10:31.470
We need to talk about
problems, and whether

00:10:31.470 --> 00:10:32.885
or not we can do them or not.

00:10:32.885 --> 00:10:34.260
So I want to talk
about problems,

00:10:34.260 --> 00:10:36.370
but the only problems
I've mentioned so far

00:10:36.370 --> 00:10:37.786
have been very
difficult problems.

00:10:37.786 --> 00:10:41.460
I've talked about the problems
of writing an app that will

00:10:41.460 --> 00:10:42.750
somehow unleash killer robots.

00:10:42.750 --> 00:10:45.030
That's actually a very difficult
problem for an engineer,

00:10:45.030 --> 00:10:46.320
because there's lots
and lots of components

00:10:46.320 --> 00:10:47.264
that need to go in it.

00:10:47.264 --> 00:10:49.680
And then somehow beating the
world chess champion at chest

00:10:49.680 --> 00:10:52.602
is also very
difficult. Even trying

00:10:52.602 --> 00:10:54.810
to work out what the question
is, do computers think,

00:10:54.810 --> 00:10:56.250
that's very, very hard.

00:10:56.250 --> 00:10:58.650
And different people
have different opinions.

00:10:58.650 --> 00:11:00.750
So we need to think about
some similar problems

00:11:00.750 --> 00:11:02.080
if we actually want
to get anywhere.

00:11:02.080 --> 00:11:03.900
What I'm going to do
first, because I don't know

00:11:03.900 --> 00:11:06.300
how many of you are very
happy with the abstract notion

00:11:06.300 --> 00:11:08.670
of a computer, I want to
forget about computers as well,

00:11:08.670 --> 00:11:11.280
and I just don't talk about
the idea of what a problem is

00:11:11.280 --> 00:11:13.120
and how to solve it.

00:11:13.120 --> 00:11:14.550
And how to know we've solved it.

00:11:14.550 --> 00:11:16.050
But also, if you
get a problem we're

00:11:16.050 --> 00:11:19.289
stuck on, then wondering whether
that problem can be solved.

00:11:19.289 --> 00:11:20.580
I want to consider these ideas.

00:11:20.580 --> 00:11:22.413
And the reason I'm
giving this talk, really,

00:11:22.413 --> 00:11:25.140
is because I gave a
big course this summer.

00:11:25.140 --> 00:11:28.337
I thought a lot about proving
things and how to prove things.

00:11:28.337 --> 00:11:29.670
And so one thing led to another.

00:11:29.670 --> 00:11:32.969
I got very interested
in this topic.

00:11:32.969 --> 00:11:35.010
So here's a problem raised
by the Ancient Greeks.

00:11:35.010 --> 00:11:38.040
Can I bisect an angle
using ruler and compasses?

00:11:38.040 --> 00:11:41.595
So this is an ancient,
2000-year-old problem.

00:11:41.595 --> 00:11:43.470
The ancient Greeks, you
know, we have Euclid,

00:11:43.470 --> 00:11:46.175
they were very good at this kind
of thing, the ancient Greeks.

00:11:46.175 --> 00:11:48.300
They were very interested
in this kind of question.

00:11:48.300 --> 00:11:50.880
So if could have
the visualizer on,

00:11:50.880 --> 00:11:53.490
I will now demonstrate
what an angle is

00:11:53.490 --> 00:11:55.650
and how to bisect it
using ruler and compasses.

00:11:55.650 --> 00:11:57.450
All this on the
Holloway Road today,

00:11:57.450 --> 00:12:00.840
just the same as the one I
had when I was in the C form.

00:12:00.840 --> 00:12:04.020
And lo and behold,
a pair of compasses.

00:12:04.020 --> 00:12:05.550
Fabulous.

00:12:05.550 --> 00:12:08.830
And a ruler.

00:12:08.830 --> 00:12:13.030
And I've also pinched one of
my daughter's felt tip pens.

00:12:19.090 --> 00:12:22.260
So first of all I
need to draw an angle.

00:12:22.260 --> 00:12:26.380
So there's an angle.

00:12:26.380 --> 00:12:27.910
That looks OK.

00:12:27.910 --> 00:12:30.010
I think it's OK.

00:12:30.010 --> 00:12:31.330
Can you see the angle?

00:12:31.330 --> 00:12:32.260
I think it's OK.

00:12:32.260 --> 00:12:33.290
There's a shadow.

00:12:33.290 --> 00:12:34.290
Maybe I shouldn't worry.

00:12:37.270 --> 00:12:38.500
So here's the angle.

00:12:38.500 --> 00:12:40.330
And what the job is,
what's the question,

00:12:40.330 --> 00:12:43.150
the question is can
we bisect the angle.

00:12:43.150 --> 00:12:46.300
And bisect, as maybe
many of you remember,

00:12:46.300 --> 00:12:50.870
bisect means I need to draw a
line just around down there,

00:12:50.870 --> 00:12:54.140
exactly in the
middle of this angle.

00:12:54.140 --> 00:12:57.160
I need to cut this angle
into two equal pieces.

00:12:57.160 --> 00:13:01.570
That's the kind of thing that
the ancient Greeks were doing.

00:13:01.570 --> 00:13:03.880
Euclid wrote an
entire book on it.

00:13:03.880 --> 00:13:06.290
So can we bisect this angle?

00:13:06.290 --> 00:13:09.653
And the point is you can't
kind of go, well, it's kind of,

00:13:09.653 --> 00:13:10.800
it's sort of.

00:13:10.800 --> 00:13:12.050
You're not allowed to do that.

00:13:12.050 --> 00:13:13.000
You're not allowed to guess.

00:13:13.000 --> 00:13:14.229
You've got to do it exactly.

00:13:14.229 --> 00:13:15.520
But we don't just have a ruler.

00:13:15.520 --> 00:13:18.730
We've got some compasses.

00:13:18.730 --> 00:13:19.480
So watch this.

00:13:19.480 --> 00:13:21.465
Here's how you do it.

00:13:21.465 --> 00:13:23.590
First of all, you put the
point of the compass dead

00:13:23.590 --> 00:13:24.790
on that angle.

00:13:24.790 --> 00:13:27.200
And then, of course,
we draw a circle.

00:13:27.200 --> 00:13:30.700
Or I'm only going to draw
that bit of that circle.

00:13:30.700 --> 00:13:35.050
Now the thing about circles
is that the distance from

00:13:35.050 --> 00:13:37.474
the centre of the circle
to the edge of the circle,

00:13:37.474 --> 00:13:39.640
the circumference of the
circle, is always the same,

00:13:39.640 --> 00:13:41.210
wherever you draw
the circumference.

00:13:41.210 --> 00:13:47.190
So one thing I know for sure
is that that line there,

00:13:47.190 --> 00:13:52.810
that red line there, is exactly
the same length as that line

00:13:52.810 --> 00:13:54.930
there.

00:13:54.930 --> 00:13:57.449
Because I'll even tell
you what the length is.

00:13:57.449 --> 00:13:58.740
The length is this length here.

00:13:58.740 --> 00:14:01.230
The length is the distance
between the pencil

00:14:01.230 --> 00:14:05.400
tip and the spiky bit.

00:14:05.400 --> 00:14:08.455
So those two lines are
definitely the same length.

00:14:08.455 --> 00:14:10.080
And now I'm going to
do something else.

00:14:10.080 --> 00:14:12.240
I'm going to put
that spiky bit here.

00:14:12.240 --> 00:14:14.446
It's probably got a
name, but I never--

00:14:14.446 --> 00:14:15.570
they don't even have these.

00:14:15.570 --> 00:14:17.692
I went to the stationery
cupboard said, could I

00:14:17.692 --> 00:14:19.650
have a pair of compasses,
and they looked at me

00:14:19.650 --> 00:14:20.483
like I was an idiot.

00:14:23.040 --> 00:14:24.670
Apparently things have moved on.

00:14:24.670 --> 00:14:26.670
I don't know.

00:14:26.670 --> 00:14:29.119
So there, while I'm
chatting, I'm doing it.

00:14:29.119 --> 00:14:30.660
You didn't even see
what I was doing.

00:14:30.660 --> 00:14:33.990
I put the point thing
there, and I drew an arc.

00:14:33.990 --> 00:14:36.630
And I put the pointy thing
there and I drew an arc.

00:14:36.630 --> 00:14:39.640
And those two arcs have
met at that point there.

00:14:39.640 --> 00:14:41.990
And I'm going to draw
these two lines now.

00:14:41.990 --> 00:14:50.260
And again, in both
cases that is a line

00:14:50.260 --> 00:14:53.160
that went from where
the point of it

00:14:53.160 --> 00:14:54.810
was to where the pencil bit was.

00:14:54.810 --> 00:14:57.240
So I've drawn four lines
now, and all those lines

00:14:57.240 --> 00:14:58.090
are the same length.

00:14:58.090 --> 00:14:58.590
So great.

00:14:58.590 --> 00:15:00.630
Four-sided shape, all
lines are the same length.

00:15:00.630 --> 00:15:01.500
What's it going to be?

00:15:01.500 --> 00:15:02.583
It's going to be a square.

00:15:02.583 --> 00:15:04.980
But it's not square because
it's a bit squashed.

00:15:04.980 --> 00:15:06.750
It's called a rhombus.

00:15:06.750 --> 00:15:10.820
And now we open our copy of
Euclid's Elements from 300 B.C.

00:15:10.820 --> 00:15:12.750
And we find the
proposition that says

00:15:12.750 --> 00:15:15.450
you've got a rhombus
like this, and you draw

00:15:15.450 --> 00:15:16.710
the diagonal of the rhombus.

00:15:16.710 --> 00:15:19.020
Let's do it in pencil,
because it's not the same.

00:15:19.020 --> 00:15:20.640
All the red lines
are the same length.

00:15:20.640 --> 00:15:21.139
Here we go.

00:15:21.139 --> 00:15:23.940
Let's do that in pencil.

00:15:23.940 --> 00:15:25.830
There's the diagonal
of the rhombus.

00:15:25.830 --> 00:15:29.070
And you can see the rhombus
is very, very symmetric.

00:15:29.070 --> 00:15:31.439
And so this is a line of
symmetry of the rhombus,

00:15:31.439 --> 00:15:32.730
and everything is all the same.

00:15:32.730 --> 00:15:35.060
This angle, this
angle, and this angle

00:15:35.060 --> 00:15:37.530
are going to be the same, right?

00:15:37.530 --> 00:15:39.044
Oh, it looks quite--

00:15:39.044 --> 00:15:40.710
oh yeah, I just was
looking at that one.

00:15:40.710 --> 00:15:41.501
It looked terrible.

00:15:41.501 --> 00:15:43.380
It does look quite
good up there.

00:15:43.380 --> 00:15:44.340
So there we go.

00:15:44.340 --> 00:15:48.000
So we've drawn this line,
and it's cut the angle into--

00:15:48.000 --> 00:15:49.110
Euclid is clever.

00:15:49.110 --> 00:15:51.720
It's been know for
over 2,300 years.

00:15:51.720 --> 00:15:55.020
And in a book that
was apparently

00:15:55.020 --> 00:15:57.000
the thing to read, even
up to the 19th century.

00:15:57.000 --> 00:15:59.416
If you were an educated person
then you would read Euclid.

00:16:08.190 --> 00:16:10.030
So I bisected that angle.

00:16:10.030 --> 00:16:11.040
So here's the question.

00:16:11.040 --> 00:16:14.040
Here's a theorem, a
mathematical theorem.

00:16:14.040 --> 00:16:18.120
It's possible to bisect an angle
using a ruler and compasses.

00:16:18.120 --> 00:16:21.100
And the proof of the theorem
is you just watched me do it.

00:16:21.100 --> 00:16:23.670
And I talked your
way through it,

00:16:23.670 --> 00:16:26.162
so I convinced you
that I was doing it.

00:16:26.162 --> 00:16:27.870
And of course Euclid
does more than that.

00:16:27.870 --> 00:16:31.050
He labels the
things A and B and C

00:16:31.050 --> 00:16:34.050
to solve math things that
you maybe do at school.

00:16:34.050 --> 00:16:37.590
And ends up proving that you
can bisect an angle using

00:16:37.590 --> 00:16:39.490
ruler and compasses.

00:16:39.490 --> 00:16:41.210
So it can be done.

00:16:41.210 --> 00:16:43.220
And not only that, the
reason it can be done

00:16:43.220 --> 00:16:44.750
is because I did it.

00:16:44.750 --> 00:16:49.070
So if Euclid did it 2,300
years ago-- and now here's

00:16:49.070 --> 00:16:51.350
another problem raised
by the Ancient Greeks.

00:16:51.350 --> 00:16:54.080
Can you trisect an angle
using ruler and compasses?

00:16:54.080 --> 00:16:56.480
So bisect means cut it
into two equal bits.

00:16:56.480 --> 00:16:58.790
Trisect means cut it
into three equal bits.

00:16:58.790 --> 00:17:00.957
So can you trisect an angle
using ruler and compass?

00:17:00.957 --> 00:17:02.456
You've got to think
what you've got.

00:17:02.456 --> 00:17:05.160
Bisecting, you kind of think,
you know, you're on a roll.

00:17:05.160 --> 00:17:09.170
You try trisecting, and the
ancient Greeks couldn't do it.

00:17:09.170 --> 00:17:12.280
They found it very
difficult to trisect angles

00:17:12.280 --> 00:17:15.930
using ruler and compasses.

00:17:15.930 --> 00:17:19.619
So that problem sat
around unsolved,

00:17:19.619 --> 00:17:24.430
with nobody doing it, and
somehow if you can't do it,

00:17:24.430 --> 00:17:27.020
then what other
alternative is there?

00:17:27.020 --> 00:17:30.450
And 2000 years later,
in 1837, Pierre Wantzel

00:17:30.450 --> 00:17:31.742
proved it was impossible to do.

00:17:31.742 --> 00:17:33.866
So that's why the Greeks
couldn't do it, because it

00:17:33.866 --> 00:17:35.080
was impossible to do it.

00:17:35.080 --> 00:17:38.380
And bisecting the
angle is kind of cool.

00:17:38.380 --> 00:17:41.160
But this is super
interesting, because proving

00:17:41.160 --> 00:17:44.130
that it's impossible
to do something,

00:17:44.130 --> 00:17:45.930
the questions are
formally very similar,

00:17:45.930 --> 00:17:48.190
bisect an angle,
trisect an angle.

00:17:48.190 --> 00:17:50.790
But we solved one
of them by doing it,

00:17:50.790 --> 00:17:53.434
and then 2000 years later
we solved the other way

00:17:53.434 --> 00:17:54.600
by proving it can't be done.

00:17:54.600 --> 00:17:56.190
We resolved the question.

00:17:56.190 --> 00:17:57.366
It cannot be done.

00:17:57.366 --> 00:17:58.740
And that's why
the Greeks failed.

00:17:58.740 --> 00:18:01.198
But the Greeks didn't want to
conclude it couldn't be done.

00:18:01.198 --> 00:18:03.680
They just wanted to conclude
they couldn't do it.

00:18:03.680 --> 00:18:07.154
So how does one prove it's
impossible to do something?

00:18:09.760 --> 00:18:13.900
Somehow, I don't know, that
result seems striking to me.

00:18:13.900 --> 00:18:17.710
So what did Wantzel have that
the ancient Greeks didn't have?

00:18:17.710 --> 00:18:21.240
The ancient Greeks had geometry.

00:18:21.240 --> 00:18:23.890
They were beginning to
develop some arithmetic.

00:18:23.890 --> 00:18:26.230
And these were somehow the
two fields of mathematics

00:18:26.230 --> 00:18:28.150
that we completely
disjoin sometimes.

00:18:28.150 --> 00:18:30.580
They didn't have much abstract
mathematical machinery

00:18:30.580 --> 00:18:32.500
available to them.

00:18:32.500 --> 00:18:35.080
By the early 1800s,
when Wantzel was around,

00:18:35.080 --> 00:18:37.470
mathematicians had
worked out what zero was.

00:18:37.470 --> 00:18:40.070
Remember for the Greeks
every number was positive.

00:18:40.070 --> 00:18:42.360
They'd invented zero,
negative numbers.

00:18:42.360 --> 00:18:44.560
That Cartesian Coordinates,
this is the big insight.

00:18:44.560 --> 00:18:47.400
Rene Descartes observed that if
you have a point on the plane,

00:18:47.400 --> 00:18:49.650
you can think of that point,
something in x=coordinate

00:18:49.650 --> 00:18:51.080
and a y-coordinate.

00:18:51.080 --> 00:18:54.310
So suddenly that
point which hitherto

00:18:54.310 --> 00:18:58.190
had been a geometric notion,
that point suddenly has

00:18:58.190 --> 00:19:01.990
an arithmetic interpretation.

00:19:01.990 --> 00:19:04.590
We can explain where that
point is using numbers.

00:19:04.590 --> 00:19:07.200
This is a link between
geometry and arithmetic

00:19:07.200 --> 00:19:08.500
that the Greeks didn't have.

00:19:08.500 --> 00:19:12.340
So it took Rene Descartes,
and but nowadays it's

00:19:12.340 --> 00:19:13.660
kind of a trivial thing.

00:19:13.660 --> 00:19:15.477
You draw graphs, and
this is y this is x,

00:19:15.477 --> 00:19:16.560
and you're just taught it.

00:19:16.560 --> 00:19:17.934
But someone had
to discover this.

00:19:17.934 --> 00:19:19.990
Turned out it was a
genius who discovered it.

00:19:19.990 --> 00:19:24.040
And also these people,
because they were also

00:19:24.040 --> 00:19:26.710
quite good at arithmetic,
they had long since

00:19:26.710 --> 00:19:28.540
isolated these four basic--

00:19:28.540 --> 00:19:30.009
plus, minus, times, and divide--

00:19:30.009 --> 00:19:32.050
but now instead of thinking
about all the numbers

00:19:32.050 --> 00:19:34.695
they were interested
in subsets of numbers.

00:19:34.695 --> 00:19:36.070
Things like the
rational numbers.

00:19:36.070 --> 00:19:38.111
You can do addition,
subtraction, multiplication,

00:19:38.111 --> 00:19:39.260
division on them.

00:19:39.260 --> 00:19:41.860
And now this is
somehow when things

00:19:41.860 --> 00:19:43.120
begin to get interesting.

00:19:43.120 --> 00:19:45.220
They developed an abstract
theory of dimension.

00:19:45.220 --> 00:19:47.137
So they consider these
fields of numbers.

00:19:47.137 --> 00:19:48.970
They can see a collection
of numbers, called

00:19:48.970 --> 00:19:51.010
it a field of numbers, then they
consider a bigger collection

00:19:51.010 --> 00:19:53.420
of numbers, they call it
a bigger field of numbers.

00:19:53.420 --> 00:19:55.711
And they realised that there
was a notion of dimension.

00:19:55.711 --> 00:19:58.652
The bigger thing had a dimension
over the smaller thing.

00:19:58.652 --> 00:20:00.610
And if you make the
smaller thing really small,

00:20:00.610 --> 00:20:02.690
you can make the
dimension get very big.

00:20:02.690 --> 00:20:05.020
So this is not kind of
a real-world dimension.

00:20:05.020 --> 00:20:08.410
This is an abstract mathematical
notion of degrees of freedom.

00:20:08.410 --> 00:20:10.930
And using these
abstract collections

00:20:10.930 --> 00:20:14.110
of fields of numbers,
they could construct

00:20:14.110 --> 00:20:17.720
objects that had some
abstract, very large dimension.

00:20:17.720 --> 00:20:20.270
So it took 2,000 years to
develop these concepts.

00:20:20.270 --> 00:20:22.520
And once they were developed,
Wantzel could take them,

00:20:22.520 --> 00:20:24.820
and he realised that it was
impossible to trisect not just

00:20:24.820 --> 00:20:25.319
any angle.

00:20:25.319 --> 00:20:28.630
He proved it was impossible even
to trisect a 60-degree angle

00:20:28.630 --> 00:20:29.860
using ruler and compasses.

00:20:29.860 --> 00:20:32.170
So basically he
looked to the system--

00:20:32.170 --> 00:20:33.640
I don't want to
bore you, really,

00:20:33.640 --> 00:20:36.260
but this is what I teach in
my third-year Galois theory

00:20:36.260 --> 00:20:36.820
course.

00:20:36.820 --> 00:20:38.278
He looked at the
systems of numbers

00:20:38.278 --> 00:20:40.000
generated by the coordinates.

00:20:40.000 --> 00:20:43.120
You see, he turns a geometric
problem into arithmetic one.

00:20:43.120 --> 00:20:45.070
He looks at the number
systems generated

00:20:45.070 --> 00:20:47.210
by the coordinates
of these points

00:20:47.210 --> 00:20:49.682
that you can only reconstruct
with a ruler and compass.

00:20:49.682 --> 00:20:51.890
And he proved that the
dimensions of all these fields

00:20:51.890 --> 00:20:54.059
was always a power of two.

00:20:54.059 --> 00:20:56.350
Then he proved that the system
of numbers you generate,

00:20:56.350 --> 00:20:59.050
if you can trisect a 360-degree
angle, got dimension 3.

00:20:59.050 --> 00:21:00.200
And 3 is not in that list.

00:21:00.200 --> 00:21:02.187
The list goes 1, 2,
4, 16, dah, dah, dah.

00:21:02.187 --> 00:21:03.520
Never contains the number three.

00:21:03.520 --> 00:21:06.020
So this is how the proof worked.

00:21:06.020 --> 00:21:10.060
So the conclusion so
far is that Euclid

00:21:10.060 --> 00:21:11.980
proved it was possible
to bisect an angle

00:21:11.980 --> 00:21:14.530
and Wantzel proved it was
impossible to trisect an angle

00:21:14.530 --> 00:21:16.930
using ruler and compasses.

00:21:16.930 --> 00:21:18.940
And so we learned from
this that mathematicians

00:21:18.940 --> 00:21:21.540
can prove something is
impossible by just doing it.

00:21:21.540 --> 00:21:24.760
And they could also prove
that something is impossible.

00:21:24.760 --> 00:21:26.980
But actually it lies deeper.

00:21:26.980 --> 00:21:29.100
It often lies deeper.

00:21:29.100 --> 00:21:33.520
And it might take thousands
of years to develop a theory.

00:21:33.520 --> 00:21:36.270
So we're going to see
another example of this next.

00:21:36.270 --> 00:21:38.590
And of course, as
a remark, that's

00:21:38.590 --> 00:21:43.060
if we use modern tools, modern
things that were nowhere near

00:21:43.060 --> 00:21:44.350
known to the ancient Greeks.

00:21:44.350 --> 00:21:47.377
But the modern tools, as well
as doing modern mathematics,

00:21:47.377 --> 00:21:48.710
they can solve ancient problems.

00:21:48.710 --> 00:21:50.736
This is in some
sense a vindication

00:21:50.736 --> 00:21:52.360
of the modern tools,
the fact that they

00:21:52.360 --> 00:21:54.321
can resolve ancient problems.

00:21:54.321 --> 00:21:56.320
So this phenomena is
commonplace in mathematics.

00:21:56.320 --> 00:21:58.240
You get questions that a
raised and sometimes take

00:21:58.240 --> 00:21:59.530
hundreds of years of answer.

00:21:59.530 --> 00:22:01.780
And the tools you'll
use in answering them

00:22:01.780 --> 00:22:03.990
are often not tools that
were even in existence

00:22:03.990 --> 00:22:05.410
when the questions were stated.

00:22:05.410 --> 00:22:06.368
So there's mathematics.

00:22:06.368 --> 00:22:09.190
Now let's talk about computers.

00:22:09.190 --> 00:22:11.430
So there's the first-ever
computer programmer,

00:22:11.430 --> 00:22:13.090
Ada, Countess of Lovelace.

00:22:13.090 --> 00:22:15.370
So why is she the first-ever
computer programmer?

00:22:15.370 --> 00:22:18.490
Because she wrote the
first-ever computer programme.

00:22:18.490 --> 00:22:22.150
So a guy called Charles
Babbage, he was not really

00:22:22.150 --> 00:22:23.890
a mathematician, he
was more an engineer,

00:22:23.890 --> 00:22:28.495
but he designed something called
Babbage's analytical engine.

00:22:31.670 --> 00:22:33.580
It was a machine,
but actually it

00:22:33.580 --> 00:22:35.140
was a machine you
could set the dials

00:22:35.140 --> 00:22:36.764
and you could actually
tell the machine

00:22:36.764 --> 00:22:38.260
to do lots of different things.

00:22:38.260 --> 00:22:40.420
It was a very primitive
kind of computer.

00:22:40.420 --> 00:22:42.879
You set the dials, that's
like writing a programme.

00:22:42.879 --> 00:22:44.920
And then you run the
machine and the machine runs

00:22:44.920 --> 00:22:46.550
according where
the dials are set.

00:22:46.550 --> 00:22:50.710
So this is really
the first computer

00:22:50.710 --> 00:22:53.450
that was around in some
sense, this analytical engine.

00:22:53.450 --> 00:22:55.390
And Babbage gave
lectures on it in Italy,

00:22:55.390 --> 00:22:57.966
somebody took notes in
French, and these notes

00:22:57.966 --> 00:23:00.340
made it into the hands of Ada
Lovelace, who decided she'd

00:23:00.340 --> 00:23:01.672
translate them into English.

00:23:01.672 --> 00:23:03.130
And while she was
translating them,

00:23:03.130 --> 00:23:04.780
of course, you translate
something, you read it,

00:23:04.780 --> 00:23:06.670
she read it and she
learned the material.

00:23:06.670 --> 00:23:09.760
And then she wrote a series
of appendices at the end

00:23:09.760 --> 00:23:12.700
of Babbage's notes, and
Appendix G, the last appendix,

00:23:12.700 --> 00:23:16.600
there's an example of where
you can set the dials in order

00:23:16.600 --> 00:23:19.090
to run a programme that would
compute Bernoulli numbers,

00:23:19.090 --> 00:23:21.210
which were the thing, you know.

00:23:21.210 --> 00:23:24.404
And people would compute
things by sitting down

00:23:24.404 --> 00:23:26.320
with pieces of paper and
writing them all out.

00:23:26.320 --> 00:23:28.340
In her observations,
Bernoulli numbers a bit

00:23:28.340 --> 00:23:29.290
annoying to compute.

00:23:29.290 --> 00:23:31.590
But if we have one of these
analytical engines, then

00:23:31.590 --> 00:23:33.548
actually we could just
set the dials like this,

00:23:33.548 --> 00:23:36.630
switch it on, and out come
the Bernoulli numbers.

00:23:36.630 --> 00:23:39.070
So it would save somebody a job.

00:23:39.070 --> 00:23:41.680
So Ada Lovelace.

00:23:41.680 --> 00:23:43.760
She wrote the first
computer programme,

00:23:43.760 --> 00:23:46.180
also we can ascribe
to her a theorem,

00:23:46.180 --> 00:23:49.270
a computer can calculate
Bernoulli numbers.

00:23:49.270 --> 00:23:50.867
And the proof is do it.

00:23:50.867 --> 00:23:53.200
Just like the proof of bisecting
the angle was doing it,

00:23:53.200 --> 00:23:56.050
the proof is let's just write
a computer programme that

00:23:56.050 --> 00:23:57.232
computes Bernoulli numbers.

00:23:57.232 --> 00:23:58.190
So that's what she did.

00:23:58.190 --> 00:24:01.900
She never saw it run, because
Babbage's analytical engine was

00:24:01.900 --> 00:24:03.760
never built, in fact.

00:24:03.760 --> 00:24:07.070
There were technical design
problems at the beginning.

00:24:07.070 --> 00:24:09.220
By the time these
things were resolved,

00:24:09.220 --> 00:24:11.430
the money had run out,
the funding dried up,

00:24:11.430 --> 00:24:13.390
and the analytical
engine never got built,

00:24:13.390 --> 00:24:17.350
and Lovelace died at 36 and
never saw her programme run.

00:24:17.350 --> 00:24:21.720
But of course nerds went
away and made other ones.

00:24:21.720 --> 00:24:23.372
So it does work.

00:24:23.372 --> 00:24:24.830
And they compute
Bernoulli numbers.

00:24:28.260 --> 00:24:30.480
If you're thinking, you see
where the story is going.

00:24:30.480 --> 00:24:34.470
So now we skip forward
100 years to Alan Turing.

00:24:34.470 --> 00:24:38.460
And Alan Turing, he thought
about computers as well,

00:24:38.460 --> 00:24:39.700
but he wasn't an engineer.

00:24:39.700 --> 00:24:40.950
He was a mathematician.

00:24:40.950 --> 00:24:43.500
And so he started thinking
about mathematically

00:24:43.500 --> 00:24:44.940
modelling a computer.

00:24:44.940 --> 00:24:50.700
Kind of like using arithmetic
to study points in geometry.

00:24:50.700 --> 00:24:54.030
He started to wonder whether
you could model a computer using

00:24:54.030 --> 00:24:55.830
the language of mathematics.

00:24:55.830 --> 00:24:59.470
And nowadays it's
called a Turing machine.

00:24:59.470 --> 00:25:01.720
And Turing's mathematical
description of a computer

00:25:01.720 --> 00:25:03.550
opened the doors
for mathematicians

00:25:03.550 --> 00:25:07.060
now to start proving much more
deeper and profound results

00:25:07.060 --> 00:25:08.840
about what computers
could or couldn't do.

00:25:08.840 --> 00:25:10.840
And of course, we're in
just the same situation.

00:25:10.840 --> 00:25:11.759
you've got a problem.

00:25:11.759 --> 00:25:13.300
The question is can
a computer do it?

00:25:13.300 --> 00:25:15.429
If the answer is yes, how
do you show the answers?

00:25:15.429 --> 00:25:17.470
You just write a computer
programme that does it.

00:25:17.470 --> 00:25:18.844
How do you show
the answer is no?

00:25:18.844 --> 00:25:22.390
That's going to be difficult.

00:25:22.390 --> 00:25:24.530
So Lovelace cited this
interesting problem

00:25:24.530 --> 00:25:26.120
computing Bernoulli
numbers and showed

00:25:26.120 --> 00:25:27.230
the computer could do it.

00:25:27.230 --> 00:25:30.310
And Turing also isolated an
interesting abstract problem,

00:25:30.310 --> 00:25:32.900
but he showed, because he
had more tools than Lovelace,

00:25:32.900 --> 00:25:35.940
he showed a computer could
not solve this problem.

00:25:35.940 --> 00:25:38.390
And again, when you
just step back, how ever

00:25:38.390 --> 00:25:40.560
are you going to prove
something like that?

00:25:40.560 --> 00:25:43.800
How can you check that every
single computer programme ever

00:25:43.800 --> 00:25:46.310
was written, will be
written, can be written,

00:25:46.310 --> 00:25:48.630
will not solve this problem?

00:25:48.630 --> 00:25:51.780
I'm going to try to explain
to you how he did it.

00:25:51.780 --> 00:25:54.170
And the problem wasn't just
an abstract problem as well.

00:25:54.170 --> 00:25:56.589
It's not just this bisect
the angle nonsense,

00:25:56.589 --> 00:25:59.130
this sad thing Wantzel proved
you couldn't trisect the angle.

00:25:59.130 --> 00:26:01.050
By this stage, nobody cared.

00:26:01.050 --> 00:26:03.670
Whereas Turing, Turing
works on a problem

00:26:03.670 --> 00:26:07.579
that actually even though
in 1936 when he worked on it

00:26:07.579 --> 00:26:09.120
there were still no
computers, right?

00:26:09.120 --> 00:26:11.760
The first computers started
appearing in the 40s.

00:26:11.760 --> 00:26:15.320
And Turing actually was
involved in several of them.

00:26:15.320 --> 00:26:17.820
But Turing proved
this theory in 1936,

00:26:17.820 --> 00:26:19.800
before a single computer
had ever been built,

00:26:19.800 --> 00:26:23.760
a single computer programme
had ever been run.

00:26:23.760 --> 00:26:26.350
He was interested in the idea
that computers might sometimes

00:26:26.350 --> 00:26:26.850
crash.

00:26:26.850 --> 00:26:29.220
And computers crashing
is a pain, right?

00:26:29.220 --> 00:26:30.835
You lose data, you
lose information.

00:26:30.835 --> 00:26:32.460
You have to switch
it off and on again.

00:26:32.460 --> 00:26:33.850
We don't want
computers crashing.

00:26:33.850 --> 00:26:35.490
Turing could see
that this was going

00:26:35.490 --> 00:26:40.600
to be an issue before any
computers ever even existed.

00:26:40.600 --> 00:26:43.770
So I'm going to try to tell
you about what Turing did.

00:26:43.770 --> 00:26:46.440
So let me try and explain to you
what a computer programme looks

00:26:46.440 --> 00:26:46.960
like.

00:26:46.960 --> 00:26:49.560
So this is a computer
programme read in pseudo code.

00:26:49.560 --> 00:26:51.720
So it's kind of read
in English but there's

00:26:51.720 --> 00:26:53.020
lots and lots of steps.

00:26:53.020 --> 00:26:55.080
And what the
processor will do is

00:26:55.080 --> 00:26:57.660
it will just go from each
step to the next step,

00:26:57.660 --> 00:27:00.000
unless somebody tells
it to do something else.

00:27:00.000 --> 00:27:02.370
And each step will
carefully read what's there,

00:27:02.370 --> 00:27:04.320
and it will do what it's told.

00:27:04.320 --> 00:27:06.760
And it will to do it
very, very quickly.

00:27:06.760 --> 00:27:11.489
So this computer programme
here, step 1, run it.

00:27:11.489 --> 00:27:13.530
You have it on your phone,
you click on that app,

00:27:13.530 --> 00:27:16.650
and little screen pops
up, says type in a number.

00:27:16.650 --> 00:27:19.070
And you type in a number
like 53, and you click OK.

00:27:19.070 --> 00:27:22.786
And you've typed in 53
and the box disappears.

00:27:22.786 --> 00:27:24.410
And our step 2 is
let x be that number.

00:27:24.410 --> 00:27:26.940
So now if we typed
a 53, x will be 53.

00:27:26.940 --> 00:27:29.850
Now step three is a
funny thing that involves

00:27:29.850 --> 00:27:31.410
the question is x equal to 7?

00:27:31.410 --> 00:27:34.187
But we've typed in 53,
so x isn't equal to 7.

00:27:34.187 --> 00:27:36.270
If x was equal to 7, we
would have gone somewhere.

00:27:36.270 --> 00:27:38.980
So x isn't equal to
7, so we go to step 6.

00:27:38.980 --> 00:27:41.400
So we've typed in 53, x is 53.

00:27:41.400 --> 00:27:43.420
We're at step 3, x isn't 7.

00:27:43.420 --> 00:27:44.670
So let's go to step 6.

00:27:44.670 --> 00:27:46.976
Step 6 we print hello on
the screen and then we stop.

00:27:46.976 --> 00:27:48.600
So when you run this
app on your phone,

00:27:48.600 --> 00:27:50.300
you click on the little app,
it says type in a number.

00:27:50.300 --> 00:27:51.290
We type 53.

00:27:51.290 --> 00:27:52.250
We click OK.

00:27:52.250 --> 00:27:54.090
Another little box
pops up saying hello,

00:27:54.090 --> 00:27:55.080
and then that's it.

00:27:55.080 --> 00:27:56.907
App is finished.

00:27:56.907 --> 00:27:59.490
If you play with it for a bit,
you'll realise that that's what

00:27:59.490 --> 00:28:00.570
it normally does.

00:28:00.570 --> 00:28:03.120
But then eventually
you hit on the idea

00:28:03.120 --> 00:28:05.540
of typing in the number 7.

00:28:05.540 --> 00:28:07.580
And so you type in number 7.

00:28:07.580 --> 00:28:09.470
The computer lets
x be 7 in step 2.

00:28:09.470 --> 00:28:11.990
In step 3, notice
the x is equal to 7.

00:28:11.990 --> 00:28:14.270
And instead of going to
step 3, you go to step 4.

00:28:14.270 --> 00:28:16.900
And in step 4, you can
see what to do in step 4.

00:28:16.900 --> 00:28:18.830
You just go to step 5.
so it goes to step 5.

00:28:18.830 --> 00:28:20.930
And step 5 says go to step 4.

00:28:20.930 --> 00:28:22.090
And so it goes to step 4.

00:28:22.090 --> 00:28:23.780
Then step 4 says go to step 5.

00:28:23.780 --> 00:28:25.170
So it goes to step
4, and it just

00:28:25.170 --> 00:28:27.191
alternates between step 4 and 5.

00:28:27.191 --> 00:28:28.940
You can tell the
computer is not thinking,

00:28:28.940 --> 00:28:30.530
because if a human
had to do that,

00:28:30.530 --> 00:28:32.220
they'd get bored at some point.

00:28:32.220 --> 00:28:34.310
But the computer will
just keep doing it.

00:28:34.310 --> 00:28:36.260
That's exactly what
they're paid to do.

00:28:36.260 --> 00:28:38.360
They just quite happily,
mindlessly follow

00:28:38.360 --> 00:28:39.240
the instructions.

00:28:39.240 --> 00:28:42.210
So the computer will get
stuck going between step 4

00:28:42.210 --> 00:28:42.710
and step 5.

00:28:42.710 --> 00:28:44.564
Now you're running
this, if your operating

00:28:44.564 --> 00:28:46.980
system gets stuck in that kind
of loop, then it's stopped.

00:28:46.980 --> 00:28:49.280
You see, line 1 is kind
of implicitly saying,

00:28:49.280 --> 00:28:51.190
what's the person
pressing on the keyboard?

00:28:51.190 --> 00:28:53.679
But if you're just hopping
between step 4 and step 5,

00:28:53.679 --> 00:28:55.970
the computer isn't looking
at the keyboard or the mouse

00:28:55.970 --> 00:28:56.570
or anything like that.

00:28:56.570 --> 00:28:58.695
You wiggle these things
around and nothing happens,

00:28:58.695 --> 00:28:59.930
and you know what's happened.

00:28:59.930 --> 00:29:01.310
When your computer
is in that state,

00:29:01.310 --> 00:29:03.500
you press the Caps Lock key
and the light doesn't come on,

00:29:03.500 --> 00:29:05.090
you know that your
computer's had it,

00:29:05.090 --> 00:29:06.890
and you have to switch
off and on again.

00:29:06.890 --> 00:29:08.840
So computer programmes
sometimes get stuck in loops,

00:29:08.840 --> 00:29:10.089
and you've all seen it happen.

00:29:12.754 --> 00:29:13.420
So there you go.

00:29:13.420 --> 00:29:14.880
If the user types
in the number 7,

00:29:14.880 --> 00:29:17.213
that computer programme can
get stuck in a endless loop,

00:29:17.213 --> 00:29:18.640
so it crashes.

00:29:18.640 --> 00:29:20.830
So here is a much more
complicated programme.

00:29:20.830 --> 00:29:23.246
We're not going to analyse it,
because we'd just basically

00:29:23.246 --> 00:29:24.560
spend all day analysing it.

00:29:24.560 --> 00:29:25.930
That other one had seven steps.

00:29:25.930 --> 00:29:29.380
This one's got nine steps,
but it's vastly complicated.

00:29:29.380 --> 00:29:31.750
You ask a user to
type in a number.

00:29:31.750 --> 00:29:33.610
Let's say they type
in the number 9.

00:29:33.610 --> 00:29:35.920
Step 2, let x be that number.

00:29:35.920 --> 00:29:38.740
Step 3, if x is bigger than 10.

00:29:38.740 --> 00:29:40.670
It's not bigger than
10, 9 is less than 10.

00:29:40.670 --> 00:29:42.200
So we get to step 6.

00:29:42.200 --> 00:29:45.190
Step 6 says if it's less than
10, and it is less than 10,

00:29:45.190 --> 00:29:47.530
because 9 is less than
10, so we go to step 4.

00:29:47.530 --> 00:29:49.690
Step 4, x changes.

00:29:49.690 --> 00:29:51.850
Step 4 we replace
x by 2 times x.

00:29:51.850 --> 00:29:54.792
So now suddenly x was
9 and now it's 18.

00:29:54.792 --> 00:29:55.750
And then what do we do?

00:29:55.750 --> 00:29:57.070
We go back to step 3.

00:29:57.070 --> 00:30:00.566
Now x is 18, and now x is
bigger than 10, so we go to 7.

00:30:00.566 --> 00:30:02.440
And you can see we're
kind of jumping around.

00:30:02.440 --> 00:30:03.730
The x is 18.

00:30:03.730 --> 00:30:06.160
Step 7 says if x is less
than 100, go to step 4.

00:30:06.160 --> 00:30:07.708
Step 4, we've been
to step 4 before,

00:30:07.708 --> 00:30:09.666
so you're going to think,
oh, an infinite loop.

00:30:09.666 --> 00:30:11.082
But we're not in
an infinite loop,

00:30:11.082 --> 00:30:13.480
because when we were at
step 4 before, x was 9.

00:30:13.480 --> 00:30:16.010
And now we're at step
4 again, x is 18.

00:30:16.010 --> 00:30:18.410
And so we're not exactly
the same state as before.

00:30:18.410 --> 00:30:20.080
So we might not be
in an infinite loop.

00:30:20.080 --> 00:30:21.850
And x is going to
be replaced by 36.

00:30:21.850 --> 00:30:23.430
And you see it jumps around.

00:30:23.430 --> 00:30:25.060
We didn't even go to--

00:30:25.060 --> 00:30:27.130
step 5 is ridiculous.

00:30:27.130 --> 00:30:29.232
It's not really clear.

00:30:29.232 --> 00:30:31.190
This is the question,
can this computer problem

00:30:31.190 --> 00:30:32.439
get stuck in an infinite loop?

00:30:32.439 --> 00:30:34.640
That is a tricky
logic puzzle, right?

00:30:34.640 --> 00:30:36.776
And I don't fancy doing it.

00:30:36.776 --> 00:30:38.650
Somehow I would try to
do it using intuition.

00:30:38.650 --> 00:30:41.680
I would try to find key numbers
which behave differently

00:30:41.680 --> 00:30:42.570
to other numbers.

00:30:42.570 --> 00:30:44.830
But can this computer get
stuck in an infinite loop?

00:30:44.830 --> 00:30:46.390
Figuring out that
kind of question

00:30:46.390 --> 00:30:47.950
is a complicated logic puzzle.

00:30:47.950 --> 00:30:51.080
Now I like doing complicated
logic puzzles, but actually,

00:30:51.080 --> 00:30:54.130
at the end of the day,
what kind of gadget

00:30:54.130 --> 00:30:57.430
is really suited to solving
complicated logic problems?

00:30:57.430 --> 00:30:58.910
It's a computer.

00:30:58.910 --> 00:31:00.610
So what we should
really do is not

00:31:00.610 --> 00:31:02.617
bother solving that
problem at all.

00:31:02.617 --> 00:31:03.450
What does that mean?

00:31:03.450 --> 00:31:04.920
That doesn't mean I stop.

00:31:04.920 --> 00:31:06.690
I'm halfway.

00:31:06.690 --> 00:31:08.940
Oh that's good, because I'm
halfway through the slides

00:31:08.940 --> 00:31:10.898
as well, because the last
two slides are jokes.

00:31:12.992 --> 00:31:14.450
So this is the sort
of puzzle which

00:31:14.450 --> 00:31:17.170
would be ideal for a
computer to work on.

00:31:17.170 --> 00:31:19.950
And so this is what
Turing decided to work on.

00:31:19.950 --> 00:31:22.480
Let's write a computer programme
that checks other computer

00:31:22.480 --> 00:31:24.637
programmes to see if I get
stuck in infinite loops.

00:31:24.637 --> 00:31:26.720
So when a computer gets
stuck in an infinite loop,

00:31:26.720 --> 00:31:27.820
we'll let it crash.

00:31:27.820 --> 00:31:29.020
And that's bad, right?

00:31:29.020 --> 00:31:31.660
So we'll say a computer
programme is bad if it can get

00:31:31.660 --> 00:31:32.830
stuck in an infinite loop.

00:31:32.830 --> 00:31:35.079
And we'll say a computer
programme is good if it never

00:31:35.079 --> 00:31:36.550
gets stuck in an infinite loop.

00:31:36.550 --> 00:31:39.490
So there's some definitions.

00:31:39.490 --> 00:31:42.190
And now Turing says, how do
we check to see if a computer

00:31:42.190 --> 00:31:42.940
programme is good?

00:31:42.940 --> 00:31:44.939
We want to tell the good
programmes from the bad

00:31:44.939 --> 00:31:45.547
programmes.

00:31:45.547 --> 00:31:47.380
So he's going to write
a computer programme.

00:31:47.380 --> 00:31:52.030
So in his 1936 paper he
abstractly axiomatised

00:31:52.030 --> 00:31:53.680
mathematically what
a computer was.

00:31:53.680 --> 00:31:55.330
And so now he can
use mathematics

00:31:55.330 --> 00:31:56.520
to work on this question.

00:31:56.520 --> 00:31:58.270
And he found the
solution, which as I say,

00:31:58.270 --> 00:31:59.677
you probably guessed by now.

00:31:59.677 --> 00:32:02.010
So Turing's going to try and
write a computer programme.

00:32:02.010 --> 00:32:05.740
And the input to the computer
programme is not a number.

00:32:05.740 --> 00:32:08.130
You've probably gone
to some website,

00:32:08.130 --> 00:32:10.217
I do this when I'm
writing references.

00:32:10.217 --> 00:32:12.550
You click on something that
says, upload your reference.

00:32:12.550 --> 00:32:15.340
And you find the reference and
then you just drag it over.

00:32:15.340 --> 00:32:18.430
Computer programmes will quite
happily accept random files

00:32:18.430 --> 00:32:19.895
as inputs rather
than just numbers.

00:32:19.895 --> 00:32:22.270
So this computer programme
that Turing is going to write,

00:32:22.270 --> 00:32:24.603
he's going to write a computer
programme that takes this

00:32:24.603 --> 00:32:26.350
input, an arbitrary
computer programme,

00:32:26.350 --> 00:32:29.129
a different computer programme,
and then Turing's computer is

00:32:29.129 --> 00:32:30.920
going to print out good
if it's a good one,

00:32:30.920 --> 00:32:33.620
and bad if it's a bad one.

00:32:33.620 --> 00:32:38.430
So Turing's going to try and
design that computer programme.

00:32:38.430 --> 00:32:40.641
But actually something
interesting has happened here.

00:32:40.641 --> 00:32:42.890
Because if I've got a computer
programme that takes us

00:32:42.890 --> 00:32:45.710
into the computer programme,
that means that you take

00:32:45.710 --> 00:32:48.260
the computer programme itself
and put the computer programme

00:32:48.260 --> 00:32:52.400
into itself, which
is a little bit meta.

00:32:52.400 --> 00:32:56.630
And that was where
the fun started.

00:32:56.630 --> 00:33:00.230
So Turing realised if he
could tell good from bad with

00:33:00.230 --> 00:33:02.570
a computer programme, then
he could write a ridiculous,

00:33:02.570 --> 00:33:05.199
useless computer programme,
computer programme k,

00:33:05.199 --> 00:33:07.490
which would behave like a
bad programme if you inputted

00:33:07.490 --> 00:33:09.710
a good programme and behave
like a good programme if you

00:33:09.710 --> 00:33:10.520
inputted a bad one.

00:33:10.520 --> 00:33:12.145
So the idea is you
input the programme,

00:33:12.145 --> 00:33:15.690
the crazy programme k figures
out if it's good or bad.

00:33:15.690 --> 00:33:18.000
If it's bad, that's great.

00:33:18.000 --> 00:33:19.426
if it's bad, it will just stop.

00:33:19.426 --> 00:33:21.050
And if it's good, it
will intentionally

00:33:21.050 --> 00:33:23.030
go into an infinite
loop and be bad.

00:33:23.030 --> 00:33:25.355
So programme k is bad
if the input is good.

00:33:25.355 --> 00:33:27.230
And programme k is good
it's the input's bad.

00:33:27.230 --> 00:33:29.521
And then of course you take
programme k and you feed it

00:33:29.521 --> 00:33:31.416
into itself.

00:33:31.416 --> 00:33:32.540
Now what's the consequence?

00:33:32.540 --> 00:33:35.250
So now we could ask is the
answer going to be good or bad?

00:33:35.250 --> 00:33:39.320
If k is bad, then you feed it
into k, and it is good, right?

00:33:39.320 --> 00:33:41.160
If k is bad, then
k must be good.

00:33:41.160 --> 00:33:42.980
And if k is good,
then i must be bad.

00:33:42.980 --> 00:33:44.300
So there's something wrong.

00:33:44.300 --> 00:33:46.895
Because the computer programme
can't be both good or bad.

00:33:46.895 --> 00:33:48.770
So we must have made a
mistake, because we've

00:33:48.770 --> 00:33:49.820
got a contradiction.

00:33:49.820 --> 00:33:52.480
And the mistake is because
the two-letter word

00:33:52.480 --> 00:33:55.460
I've underlined,
that I've put in red.

00:33:55.460 --> 00:33:59.170
The mistake is Turing's initial
assumption that we could write

00:33:59.170 --> 00:34:02.180
a computer programme which can
tell good code from bad code.

00:34:02.180 --> 00:34:03.541
So that's Turing's mistake.

00:34:03.541 --> 00:34:05.540
I mean it's not a mistake,
it was an assumption.

00:34:05.540 --> 00:34:08.929
The assumption is the
only part of the argument

00:34:08.929 --> 00:34:11.400
that he couldn't make
completely logically valid.

00:34:11.400 --> 00:34:12.980
So his assumption is wrong.

00:34:12.980 --> 00:34:16.310
And Turing's conclusion is it is
impossible to write a computer

00:34:16.310 --> 00:34:19.699
programme which can check
any and every other computer

00:34:19.699 --> 00:34:20.719
programme for bugs.

00:34:20.719 --> 00:34:21.380
You cannot.

00:34:21.380 --> 00:34:23.659
And this is why computer
programmes will crash.

00:34:23.659 --> 00:34:27.949
Because it's impossible to
tell if they've got bugs.

00:34:27.949 --> 00:34:30.380
So Turing rigorously
proved that in 1936.

00:34:30.380 --> 00:34:35.219
Remark, still before any
computers had existed.

00:34:35.219 --> 00:34:38.410
I've sketched the
idea but what I

00:34:38.410 --> 00:34:40.159
want to stress as
absolutely crucial to it

00:34:40.159 --> 00:34:44.780
all was the fact that he'd
abstracted what a computer was

00:34:44.780 --> 00:34:46.814
and put it in mathematics.

00:34:46.814 --> 00:34:47.480
So there you go.

00:34:47.480 --> 00:34:48.860
So there's a
summary of this bit.

00:34:48.860 --> 00:34:51.380
Lovelace proved that a certain
interesting problem can be

00:34:51.380 --> 00:34:52.889
solved using a
computer programme.

00:34:52.889 --> 00:34:54.650
The proof was just do it.

00:34:54.650 --> 00:34:59.090
Turing proved that a certain
problem could not be solved

00:34:59.090 --> 00:35:03.530
using a computer programme 100
years later once the machinery

00:35:03.530 --> 00:35:05.570
got more sophisticated.

00:35:05.570 --> 00:35:07.270
So again we see an example.

00:35:07.270 --> 00:35:09.740
Turing proved that it was
impossible to do something.

00:35:09.740 --> 00:35:14.390
In my mind, it's
an amazing thing

00:35:14.390 --> 00:35:16.760
to prove you can't do something.

00:35:16.760 --> 00:35:19.700
So it's formally just
like trisecting angles.

00:35:19.700 --> 00:35:21.260
So this is what happens in life.

00:35:21.260 --> 00:35:22.574
This is obviously mathematics.

00:35:22.574 --> 00:35:24.740
People work on areas of
interest and eventually they

00:35:24.740 --> 00:35:25.656
run into obstructions.

00:35:25.656 --> 00:35:27.630
They run into problems
which they can't solve.

00:35:27.630 --> 00:35:29.630
And people work on them,
and of course sometimes

00:35:29.630 --> 00:35:30.680
they get solved later on.

00:35:30.680 --> 00:35:33.620
But sometimes they remain
obstinate and then eventually

00:35:33.620 --> 00:35:36.470
it turns out the reason
they remain obstinate is

00:35:36.470 --> 00:35:41.990
because the answer is that your
mathematical machinery cannot

00:35:41.990 --> 00:35:42.800
solve this problem.

00:35:47.600 --> 00:35:49.059
So very brief
summary, we can prove

00:35:49.059 --> 00:35:50.808
it's possible to do
something by doing it.

00:35:50.808 --> 00:35:52.880
We can prove it's
impossible to do something,

00:35:52.880 --> 00:35:55.250
but it often lies deep.

00:35:55.250 --> 00:35:57.159
So we've seen an example
in pure mathematics

00:35:57.159 --> 00:35:59.450
and we've seen example in
theoretical computer science.

00:35:59.450 --> 00:36:01.940
Theoretical computer
science with a capital

00:36:01.940 --> 00:36:04.910
T, really, because
what do I mean?

00:36:04.910 --> 00:36:06.680
There's an issue with
Turing's computers

00:36:06.680 --> 00:36:08.039
that I'll come to now.

00:36:08.039 --> 00:36:09.830
So what we're really
interested in nowadays

00:36:09.830 --> 00:36:11.510
is because our
computers do exist,

00:36:11.510 --> 00:36:15.572
and they're becoming vastly
dominant in our lives,

00:36:15.572 --> 00:36:17.780
I'm going to talk about a
practical problem involving

00:36:17.780 --> 00:36:19.190
computers.

00:36:19.190 --> 00:36:21.230
So let me first
tell you, I told you

00:36:21.230 --> 00:36:24.710
the Turing axiomatised
abstractly what a computer was.

00:36:24.710 --> 00:36:26.900
And here's some of the
problems with Turing's

00:36:26.900 --> 00:36:28.340
theoretical notion
of a computer.

00:36:28.340 --> 00:36:30.494
Firstly, had an infinite
amount of memory.

00:36:30.494 --> 00:36:31.910
Because mathematicians
are kind of

00:36:31.910 --> 00:36:32.900
used to things being infinite.

00:36:32.900 --> 00:36:34.483
There's an infinite
amount of numbers.

00:36:34.483 --> 00:36:36.170
So it had an infinite
amount of memory.

00:36:36.170 --> 00:36:39.020
And he didn't really care
about processing speed.

00:36:39.020 --> 00:36:42.020
All he cared about was did he
get stuck in an infinite loop

00:36:42.020 --> 00:36:43.160
or not?

00:36:43.160 --> 00:36:45.914
So if he had a programme that it
turned out got stuck in a loop

00:36:45.914 --> 00:36:48.080
that would basically take
a million years to get out

00:36:48.080 --> 00:36:50.750
of, but in a million years
your mouse will magically start

00:36:50.750 --> 00:36:53.710
working again and your computer
didn't crash after all,

00:36:53.710 --> 00:36:55.910
you see you don't really--

00:36:55.910 --> 00:36:59.830
you don't somehow, if it is
going to take a million years,

00:36:59.830 --> 00:37:01.670
you're not really interested.

00:37:01.670 --> 00:37:04.330
So in reality
computers have memory.

00:37:04.330 --> 00:37:08.250
And memory, this is engineering,
memory is made of stuff, right?

00:37:08.250 --> 00:37:09.730
Like terabyte hard
drives are made

00:37:09.730 --> 00:37:11.744
out tiny, tiny little magnets.

00:37:11.744 --> 00:37:13.160
And solid-state
drives are made up

00:37:13.160 --> 00:37:15.920
of tiny little
electrical circuits.

00:37:15.920 --> 00:37:20.501
But any memory location that
stores a piece of information

00:37:20.501 --> 00:37:22.000
needs to be physically
made if we're

00:37:22.000 --> 00:37:23.540
going to make one
in our universe

00:37:23.540 --> 00:37:25.665
and stop looking at abstract
computers like Turing.

00:37:25.665 --> 00:37:28.500
So we are going to need
at least a particle.

00:37:28.500 --> 00:37:29.870
One at least.

00:37:29.870 --> 00:37:32.270
Bare minimum, we're
going to need a particle

00:37:32.270 --> 00:37:33.510
to make that thing.

00:37:33.510 --> 00:37:36.350
And unfortunately there's
only 10 to the power of 80--

00:37:36.350 --> 00:37:37.575
that's one with 80 zeros--

00:37:37.575 --> 00:37:39.200
there's only one with
80 zeros, there's

00:37:39.200 --> 00:37:42.000
only that number of particles
in the entire universe.

00:37:42.000 --> 00:37:46.410
So that puts a limit on how
much memory a computer can have.

00:37:46.410 --> 00:37:50.751
And similarly,
quantum mechanics says

00:37:50.751 --> 00:37:52.250
that when you look
very, very small,

00:37:52.250 --> 00:37:54.240
things get much weirder
than you might expect.

00:37:54.240 --> 00:37:56.750
So one of the consequences
of quantum mechanics

00:37:56.750 --> 00:37:59.630
currently believed theory
is that there is basically

00:37:59.630 --> 00:38:02.420
a smallest unit
of distance which

00:38:02.420 --> 00:38:04.160
is meaningful to talk about.

00:38:04.160 --> 00:38:06.100
And beyond that, things
just get to strange.

00:38:06.100 --> 00:38:08.220
And it's a very tiny distance.

00:38:08.220 --> 00:38:11.330
But beyond that distance,
somehow everything

00:38:11.330 --> 00:38:13.190
becomes meaningless.

00:38:13.190 --> 00:38:15.770
If you believe relativity,
information can't travel faster

00:38:15.770 --> 00:38:16.950
than the speed of light.

00:38:16.950 --> 00:38:18.830
So one might ask,
how long the light

00:38:18.830 --> 00:38:23.010
would take to travel one
of these Planck distances.

00:38:23.010 --> 00:38:25.130
It's all to do with
Planck's constant and stuff.

00:38:25.130 --> 00:38:27.710
And it turns out that
a light would take 10

00:38:27.710 --> 00:38:28.840
to power minus 44.

00:38:28.840 --> 00:38:31.879
So that's naught point and
then 44 noughts and a 1.

00:38:31.879 --> 00:38:32.420
No, it's not.

00:38:32.420 --> 00:38:35.060
It's naught point that
43 naughts and than one.

00:38:35.060 --> 00:38:36.590
There's one Planck time.

00:38:36.590 --> 00:38:38.390
10 to the minus 44 seconds.

00:38:38.390 --> 00:38:42.560
So you cannot hope that your
computer can do anything,

00:38:42.560 --> 00:38:45.860
because it's impossible to
do anything in a unit of time

00:38:45.860 --> 00:38:47.390
shorter than one Planck time.

00:38:47.390 --> 00:38:49.882
Well of course, the Earth
will become uninhabitable

00:38:49.882 --> 00:38:50.840
around a billion years.

00:38:50.840 --> 00:38:52.764
We're interested in
computers on Earth.

00:38:52.764 --> 00:38:54.180
Then this is going
to be an issue.

00:38:54.180 --> 00:38:56.510
And more generally we'll
be interested in computers

00:38:56.510 --> 00:38:58.790
in the universe, then we
have to kind of figure out

00:38:58.790 --> 00:39:00.710
when the heat death of
the universe will be.

00:39:00.710 --> 00:39:02.418
But I read a lot about
this on Wikipedia,

00:39:02.418 --> 00:39:04.910
and scientists aren't sure.

00:39:04.910 --> 00:39:06.830
They don't really
know if the universe

00:39:06.830 --> 00:39:08.240
is going to expand forever.

00:39:08.240 --> 00:39:09.980
I mean they believe
in the Big Bang,

00:39:09.980 --> 00:39:11.450
but they don't know if there's
going to be a big crash,

00:39:11.450 --> 00:39:12.865
or if it's just going to stop.

00:39:12.865 --> 00:39:14.990
So I don't really know
where the universe will end,

00:39:14.990 --> 00:39:18.600
but certainly the sun will burn
out in a few billion years,

00:39:18.600 --> 00:39:21.830
and by 1 billion years
it will be this red dwarf

00:39:21.830 --> 00:39:25.700
and the seas will be boiling.

00:39:25.700 --> 00:39:27.290
And again, if you
think about it,

00:39:27.290 --> 00:39:31.460
that puts some theoretical limit
on the number of instructions

00:39:31.460 --> 00:39:32.520
that any computer can do.

00:39:32.520 --> 00:39:33.635
So let me just summarise.

00:39:33.635 --> 00:39:36.620
So to summarise, I'm not
now interested in Turing's

00:39:36.620 --> 00:39:38.120
abstract theoretical computers.

00:39:38.120 --> 00:39:40.970
What about computers on
this planet that can't run

00:39:40.970 --> 00:39:44.170
a programme which involves
storing that much information,

00:39:44.170 --> 00:39:45.980
where that much is some
number I've chosen,

00:39:45.980 --> 00:39:48.229
very large to make sure that
it's more than the number

00:39:48.229 --> 00:39:49.700
of particles in the universe.

00:39:49.700 --> 00:39:53.060
And similarly, they can't run
computer programmes in which

00:39:53.060 --> 00:39:55.139
the processor has to do
that many instructions.

00:39:55.139 --> 00:39:57.680
Because again, I've just chosen
these very, very large number

00:39:57.680 --> 00:40:00.870
to make sure that even if it did
10 to the power 44 instructions

00:40:00.870 --> 00:40:03.780
every second, it
still, you know,

00:40:03.780 --> 00:40:09.040
the world is going to
be a dead hulk by then.

00:40:09.040 --> 00:40:11.297
So there these limitations
that Turing didn't have.

00:40:11.297 --> 00:40:12.380
Turing didn't really care.

00:40:12.380 --> 00:40:14.170
Turing had other
things to think about.

00:40:14.170 --> 00:40:17.470
I mean there was a war on.

00:40:17.470 --> 00:40:21.250
But these issues are
now practical, right?

00:40:21.250 --> 00:40:23.410
It's not just can we
solve the problem or not.

00:40:23.410 --> 00:40:25.570
It's can solve the
problem quickly?

00:40:25.570 --> 00:40:27.370
So these now give
rise to new questions

00:40:27.370 --> 00:40:28.840
here's the last thing
I need to talk about.

00:40:28.840 --> 00:40:30.298
The remainder of
the talk I'm going

00:40:30.298 --> 00:40:32.554
to talk about a third question.

00:40:32.554 --> 00:40:33.970
So here's two
computer programmes.

00:40:33.970 --> 00:40:35.740
They're not like these nightmare
ones that I just showed.

00:40:35.740 --> 00:40:37.656
These are two very simple
computer programmes,

00:40:37.656 --> 00:40:40.690
because I need to
teach you a concept.

00:40:40.690 --> 00:40:42.800
Computer programme 1, the
user types in a number.

00:40:42.800 --> 00:40:44.350
The user types in 53.

00:40:44.350 --> 00:40:46.270
And then step 2, let
x be that number.

00:40:46.270 --> 00:40:47.234
So x is 53.

00:40:47.234 --> 00:40:48.900
And all it does, it
doesn't print hello.

00:40:48.900 --> 00:40:51.070
It prints out x.

00:40:51.070 --> 00:40:52.210
Sample run for Programme 1.

00:40:52.210 --> 00:40:55.060
The user types in
number 53 and clicks OK,

00:40:55.060 --> 00:40:56.530
and the computer prints out 53.

00:40:56.530 --> 00:40:59.230
So it just prints
out what you type.

00:40:59.230 --> 00:41:02.170
So computer Programme 2
formally looks very similar.

00:41:02.170 --> 00:41:04.160
This time the user
types in a number.

00:41:04.160 --> 00:41:05.560
You let x be that number.

00:41:05.560 --> 00:41:08.844
But now instead of printing
out x using our normal notation

00:41:08.844 --> 00:41:10.510
for printing numbers
out, instead all it

00:41:10.510 --> 00:41:11.500
does is print out x.

00:41:11.500 --> 00:41:13.970
Think, 53 has a meaning, right?

00:41:13.970 --> 00:41:16.670
53 means 53 things.

00:41:16.670 --> 00:41:21.070
So instead of printing
out our clever notation,

00:41:21.070 --> 00:41:23.490
it actually prints out
the meaning of the number.

00:41:23.490 --> 00:41:25.030
So it prints out 53 things.

00:41:25.030 --> 00:41:29.110
So if you don't like
line 3, then how

00:41:29.110 --> 00:41:30.490
do you actually print out x 0.

00:41:30.490 --> 00:41:33.100
What you would really do is
you just print out 1 zero,

00:41:33.100 --> 00:41:34.780
and then you'll decrease x by 1.

00:41:34.780 --> 00:41:36.488
And if it was still
positive, then you'll

00:41:36.488 --> 00:41:38.740
keep going so you'd actually
do this using a loop.

00:41:38.740 --> 00:41:42.350
So that's how you print out x
0s, using a computer Programme.

00:41:42.350 --> 00:41:45.012
So now of course sample
1, let's type in 53 again,

00:41:45.012 --> 00:41:45.970
and this is the output.

00:41:45.970 --> 00:41:48.900
We just get 53 zeros.

00:41:48.900 --> 00:41:50.917
So now let's have
a race, Programme 1

00:41:50.917 --> 00:41:51.750
against Programme 2.

00:41:51.750 --> 00:41:53.850
We'll type in 53 to both of
them, and who's going to win?

00:41:53.850 --> 00:41:55.850
Programme 1 is going to
win, because Programme 2

00:41:55.850 --> 00:41:57.781
has got to do a lot more work.

00:41:57.781 --> 00:41:59.280
First Programme is
going to finish--

00:41:59.280 --> 00:42:01.881
I mean, in practise of course,
both are finished in the blink

00:42:01.881 --> 00:42:02.380
of an eye.

00:42:02.380 --> 00:42:05.320
So you won't even
be able to notice.

00:42:05.320 --> 00:42:07.500
But I want to explain
a way of telling

00:42:07.500 --> 00:42:09.319
why this second
Programme must be worse

00:42:09.319 --> 00:42:10.360
than the first Programme.

00:42:10.360 --> 00:42:12.960
Why it's sort of less,
why it works more slowly.

00:42:12.960 --> 00:42:15.300
And it's because of scaling.

00:42:15.300 --> 00:42:18.490
So by scaling I mean
let's not type in 53.

00:42:18.490 --> 00:42:20.760
Let's now think about
typing in a bigger number.

00:42:20.760 --> 00:42:23.920
Let's type a 5 and then 3,
then let's type another number.

00:42:23.920 --> 00:42:27.570
So instead of typing in
53, let's type in 531.

00:42:27.570 --> 00:42:29.460
And now let's run
our two programmes.

00:42:29.460 --> 00:42:31.230
We saw what happened
when we typed in 53.

00:42:31.230 --> 00:42:33.180
Now let's type in 531.

00:42:33.180 --> 00:42:35.850
The first Programme used
to have to print out 53.

00:42:35.850 --> 00:42:37.560
Now it's got to print out 531.

00:42:37.560 --> 00:42:39.180
It just takes one
more digit, right?

00:42:39.180 --> 00:42:40.590
Not very much more time at all.

00:42:40.590 --> 00:42:44.450
The second Programme is going
to print out 531 things now.

00:42:44.450 --> 00:42:46.555
And 531 is about 10 times 53.

00:42:46.555 --> 00:42:48.930
So the second Programme is
going to take 10 times as long

00:42:48.930 --> 00:42:50.640
to finish.

00:42:50.640 --> 00:42:52.590
So they behave in
very different ways

00:42:52.590 --> 00:42:54.570
with a small perturbation
of the input data.

00:42:54.570 --> 00:42:56.620
If I make the input data
a little bit bigger,

00:42:56.620 --> 00:43:00.239
The first Programme
deals with it easily.

00:43:00.239 --> 00:43:02.280
The second Programme, the
amount of time it takes

00:43:02.280 --> 00:43:03.810
gets multiplied by a constant.

00:43:03.810 --> 00:43:06.890
So you have this compound
interest phenomenon.

00:43:06.890 --> 00:43:08.890
If you leave a penny
in a bank long enough,

00:43:08.890 --> 00:43:11.223
eventually you'll get to a
million pounds sort of thing.

00:43:11.223 --> 00:43:16.050
Because things can
blow up substantially.

00:43:16.050 --> 00:43:18.060
if you double your
money every time, then

00:43:18.060 --> 00:43:21.550
by the time you doubled
your money 10 times,

00:43:21.550 --> 00:43:25.020
you've multiplied your
money by over 1,000.

00:43:25.020 --> 00:43:27.120
So this is an issue that
the second Programme has.

00:43:27.120 --> 00:43:28.130
It doesn't scale well.

00:43:28.130 --> 00:43:30.180
You make the input
a little bit bigger

00:43:30.180 --> 00:43:32.880
and suddenly it takes
a lot longer to run.

00:43:32.880 --> 00:43:35.610
So when you're trying to
solve real-world problems,

00:43:35.610 --> 00:43:37.890
the input data might
well slowly increase.

00:43:37.890 --> 00:43:40.440
So you want to make sure that
your computer Programme doesn't

00:43:40.440 --> 00:43:42.600
ground to a halt if
the input data starts

00:43:42.600 --> 00:43:44.760
getting bigger and bigger.

00:43:44.760 --> 00:43:47.670
So an example is it's a very
complicated problem trying

00:43:47.670 --> 00:43:50.690
to work out when all the
students in the college

00:43:50.690 --> 00:43:51.805
are going to take exams.

00:43:51.805 --> 00:43:53.180
Because lots and
lots of students

00:43:53.180 --> 00:43:55.263
registered for lots and
lots of different courses,

00:43:55.263 --> 00:43:57.170
so you have to make
sure that every student,

00:43:57.170 --> 00:43:58.910
they haven't taken
two courses for which

00:43:58.910 --> 00:44:00.140
the exams at the same time.

00:44:00.140 --> 00:44:01.370
But all these exams
are going to be crammed

00:44:01.370 --> 00:44:02.660
in to a small part of time.

00:44:02.660 --> 00:44:04.659
So you have to have some
exams at the same time.

00:44:04.659 --> 00:44:06.090
It's a very delicate question.

00:44:09.475 --> 00:44:11.850
Of course, we do have a computer
Programme to solve this.

00:44:11.850 --> 00:44:13.766
And we want to make it
scale like Programme 1,

00:44:13.766 --> 00:44:15.310
not like Programme 2.

00:44:15.310 --> 00:44:17.350
So scaling, I talked
about it informally.

00:44:17.350 --> 00:44:20.140
The mathematicians have
formalised these notions.

00:44:20.140 --> 00:44:24.130
So the first time you
do a historical search,

00:44:24.130 --> 00:44:27.190
the first time you see this
notion of people really

00:44:27.190 --> 00:44:29.950
beginning to care about not just
abstractly whether computers

00:44:29.950 --> 00:44:32.075
can do things but how long
it takes them to do them

00:44:32.075 --> 00:44:34.150
is in a 1954 letter.

00:44:34.150 --> 00:44:37.390
This is the Beautiful Mind
guy, 1955 letter from John Nash

00:44:37.390 --> 00:44:41.860
the NSA, the American
security agency,

00:44:41.860 --> 00:44:45.686
where he began to lay
down that he isolated

00:44:45.686 --> 00:44:48.310
the issue that actually it's not
about whether the computer can

00:44:48.310 --> 00:44:49.180
solve it.

00:44:49.180 --> 00:44:51.640
It's about how quickly
the computer can solve it.

00:44:51.640 --> 00:44:55.450
And he writes explicit problems
in the area, some of which

00:44:55.450 --> 00:44:56.750
he can solve.

00:44:56.750 --> 00:44:59.860
So I'll tell you what
Nash said, because these

00:44:59.860 --> 00:45:02.500
are kind of important words.

00:45:02.500 --> 00:45:04.120
"A computer runs
in polynomial time

00:45:04.120 --> 00:45:05.800
if it scales like
the first Programme."

00:45:05.800 --> 00:45:07.160
That's an informal definition.

00:45:07.160 --> 00:45:08.621
I'll give you a
proper definition.

00:45:11.330 --> 00:45:13.774
Here's the proper
definition there.

00:45:13.774 --> 00:45:15.190
So formally, "A
computer Programme

00:45:15.190 --> 00:45:20.070
runs in polynomial time if
there's a polynomial function

00:45:20.070 --> 00:45:22.550
n to the power 20 plus 1,000."

00:45:22.550 --> 00:45:25.900
So if you input a
number with n digits,

00:45:25.900 --> 00:45:28.270
then the computer will churn
away and it will finish.

00:45:28.270 --> 00:45:29.770
But how long will
it take to finish?

00:45:29.770 --> 00:45:30.853
The Programme will finish.

00:45:30.853 --> 00:45:33.484
But it will do at
most o of n steps.

00:45:33.484 --> 00:45:34.150
That's the idea.

00:45:34.150 --> 00:45:36.149
If you can write a computer
Programme like that,

00:45:36.149 --> 00:45:37.720
then you've got a
polynomial that's

00:45:37.720 --> 00:45:40.930
kind of controlling how
fast your computer will

00:45:40.930 --> 00:45:42.420
take to calculate.

00:45:42.420 --> 00:45:44.270
And polynomials don't
grow too quickly.

00:45:44.270 --> 00:45:46.420
This is sort of
morally the thought.

00:45:46.420 --> 00:45:49.930
But also in practise, polynomial
time computer programmes are

00:45:49.930 --> 00:45:51.989
what people are after.

00:45:51.989 --> 00:45:54.530
If you've got a problem and you
can solve in polynomial time,

00:45:54.530 --> 00:45:55.600
then somebody has
already written

00:45:55.600 --> 00:45:57.516
the code that will solve
that problem for you,

00:45:57.516 --> 00:46:00.170
and it will run
very efficiently.

00:46:00.170 --> 00:46:03.880
So we're interested now in the
collection of problems which

00:46:03.880 --> 00:46:07.860
can be solved with a computer,
and furthermore, the computer

00:46:07.860 --> 00:46:08.739
can solve it quickly.

00:46:08.739 --> 00:46:10.780
Problems that could be
solved in polynomial time.

00:46:10.780 --> 00:46:12.400
And mathematicians
being what they are,

00:46:12.400 --> 00:46:14.441
they needed a name for
these collection problems,

00:46:14.441 --> 00:46:17.600
so they call it p because
that's what they do.

00:46:17.600 --> 00:46:20.800
So that's now called p, the
collection of problems which we

00:46:20.800 --> 00:46:22.470
can solve in practise quickly.

00:46:25.060 --> 00:46:27.980
So now let me just mention
codes a little bit.

00:46:27.980 --> 00:46:29.230
Secret codes are really good.

00:46:29.230 --> 00:46:31.300
You agree on a secret
code with your friends

00:46:31.300 --> 00:46:33.370
and then you've got
the secret code,

00:46:33.370 --> 00:46:35.110
your friends have got the secret
code, but nobody else has.

00:46:35.110 --> 00:46:36.610
And now you can send
messages to your friend

00:46:36.610 --> 00:46:37.720
using the secret code.

00:46:37.720 --> 00:46:39.435
Because you got
your message and you

00:46:39.435 --> 00:46:40.810
encrypt it using
the secret code.

00:46:40.810 --> 00:46:42.065
You send to your
friend, and they decrypt

00:46:42.065 --> 00:46:43.030
it using the secret code.

00:46:43.030 --> 00:46:45.030
You've both got the secret
code, but no one else

00:46:45.030 --> 00:46:46.560
has got the secret
code so it works.

00:46:46.560 --> 00:46:49.270
So I'm afraid nowadays
things aren't so easy.

00:46:49.270 --> 00:46:53.410
Because I want my phone to
kind of connect to random--

00:46:53.410 --> 00:46:55.622
yeah, I want my computer
to talk to other--

00:46:55.622 --> 00:46:57.580
if I go to a website I've
never been to before,

00:46:57.580 --> 00:46:59.440
my computer is suddenly
talking to another computer

00:46:59.440 --> 00:47:00.550
that it's never met before.

00:47:00.550 --> 00:47:02.633
And I might have to type
in my credit card details

00:47:02.633 --> 00:47:03.930
if I want to buy something.

00:47:03.930 --> 00:47:05.846
And now I need to talk
to this other computer.

00:47:05.846 --> 00:47:08.680
I need to send the computer a
secret piece of information,

00:47:08.680 --> 00:47:10.827
but we haven't
got a secret code.

00:47:10.827 --> 00:47:12.660
You see, the problem
is people can hear what

00:47:12.660 --> 00:47:13.420
you're doing on the internet.

00:47:13.420 --> 00:47:14.810
Your ISP knows
what you're doing.

00:47:14.810 --> 00:47:16.810
The government probably
knows what you're doing.

00:47:16.810 --> 00:47:18.580
And people that are just
generally snooping around

00:47:18.580 --> 00:47:20.050
on the internet
might see packets

00:47:20.050 --> 00:47:22.510
going by from your computer.

00:47:22.510 --> 00:47:25.180
So this is a problem.

00:47:25.180 --> 00:47:26.900
Secret codes aren't
good enough anymore.

00:47:26.900 --> 00:47:29.275
We need something called
"public key cryptography," where

00:47:29.275 --> 00:47:31.720
the idea is I establish a
code we're going to use.

00:47:31.720 --> 00:47:33.762
And even if somebody is
snooping on my packets,

00:47:33.762 --> 00:47:36.220
even if my next-door neighbour
who's got some kind of Wi-Fi

00:47:36.220 --> 00:47:39.570
detector thing and they're
watching all my Wi-Fi packets,

00:47:39.570 --> 00:47:42.730
I need to make sure that they
can't find out what my credit

00:47:42.730 --> 00:47:44.050
card is.

00:47:44.050 --> 00:47:46.270
So these things are
called public key codes,

00:47:46.270 --> 00:47:47.700
public key cryptography.

00:47:47.700 --> 00:47:52.110
And rather surprisingly,
they exist.

00:47:52.110 --> 00:47:54.940
They were invented in the 70s,
when it was realised that these

00:47:54.940 --> 00:47:56.180
things were important.

00:47:56.180 --> 00:47:59.350
And the way they work is
they exploit asymmetries

00:47:59.350 --> 00:48:01.090
in encoding and
decoding algorithms.

00:48:01.090 --> 00:48:03.256
So the idea is you want to
make sure the encoding is

00:48:03.256 --> 00:48:05.080
quick but decoding is slow.

00:48:05.080 --> 00:48:07.060
So let me give you an
example of an asymmetry.

00:48:07.060 --> 00:48:08.601
If you've got a
piece of cotton, I'll

00:48:08.601 --> 00:48:11.691
give you a long piece of cotton,
and I'll give you two minutes

00:48:11.691 --> 00:48:13.690
and you can tie as many
knots in it as you like.

00:48:13.690 --> 00:48:15.220
And you can tie lots
and lots of knots.

00:48:15.220 --> 00:48:16.630
And at the end of
it you can imagine

00:48:16.630 --> 00:48:18.530
you can make this piece of
cotton into a real mess.

00:48:18.530 --> 00:48:19.720
Lots and lots of
tiny little knots.

00:48:19.720 --> 00:48:21.303
You pull them tight,
but after a while

00:48:21.303 --> 00:48:23.929
the knots kind of get-- you've
done this, I've done this.

00:48:23.929 --> 00:48:25.970
The knots kind of get
closer and closer together.

00:48:25.970 --> 00:48:28.145
And they kind of start
compiling up on each other.

00:48:28.145 --> 00:48:30.520
And at the end you get a nice
kind of chunky little thing

00:48:30.520 --> 00:48:32.202
that's really
difficult to untie.

00:48:32.202 --> 00:48:34.660
So you turn a piece of cotton
into a big, complicated knot.

00:48:34.660 --> 00:48:35.380
It's very easy.

00:48:35.380 --> 00:48:36.490
Give me a couple
of minutes, I'll

00:48:36.490 --> 00:48:37.656
give you a complicated knot.

00:48:37.656 --> 00:48:39.970
On the other hand, you've
got a big, complicated knot.

00:48:39.970 --> 00:48:43.170
If you go to untie it,
it can be very difficult.

00:48:43.170 --> 00:48:45.290
It's going to be
possible, but it's

00:48:45.290 --> 00:48:47.930
going to take a lot
more than two minutes.

00:48:47.930 --> 00:48:50.290
So some things in
life are asymmetric.

00:48:50.290 --> 00:48:53.080
And surprisingly, something
you know a lot about,

00:48:53.080 --> 00:48:55.550
multiplication, turns out
to be one of those things.

00:48:58.160 --> 00:48:59.714
So here's a
multiplication problem.

00:48:59.714 --> 00:49:01.630
I'm going to tell you
the answer, don't worry.

00:49:01.630 --> 00:49:03.470
What's 43 times 61?

00:49:03.470 --> 00:49:04.290
There's a method.

00:49:04.290 --> 00:49:05.290
You learnt it at school.

00:49:05.290 --> 00:49:06.260
Long multiplication.

00:49:06.260 --> 00:49:11.074
43 times 61, we do 1, 3 we
do 4, 3 6s and 4 6s as well.

00:49:11.074 --> 00:49:13.240
And then we do some adding
and we've got the answer.

00:49:13.240 --> 00:49:14.906
And how many steps
did be actually take.

00:49:14.906 --> 00:49:16.190
We did 1 times 3, 1 times 4.

00:49:16.190 --> 00:49:17.900
3 times 6, 4 times 6.

00:49:17.900 --> 00:49:21.110
We did under 10 steps.

00:49:21.110 --> 00:49:23.750
So long multiplication
is actually

00:49:23.750 --> 00:49:26.264
a really good method for
multiplying numbers together.

00:49:26.264 --> 00:49:27.180
That scales very well.

00:49:27.180 --> 00:49:29.700
Here's the clue that
it scales very well.

00:49:29.700 --> 00:49:30.950
What are the numbers involved?

00:49:30.950 --> 00:49:36.830
The smallest number involved is
43, but did it take 43 steps?

00:49:36.830 --> 00:49:38.990
With that computer Programme
that you typed in 43

00:49:38.990 --> 00:49:40.370
print out 43 zeros.

00:49:40.370 --> 00:49:41.650
That takes 43 steps.

00:49:41.650 --> 00:49:44.240
Here we didn't use
anywhere near 43 steps.

00:49:44.240 --> 00:49:45.440
We did it at under 10.

00:49:45.440 --> 00:49:48.740
So that's the clue
it scales very well.

00:49:48.740 --> 00:49:50.750
So now let's un-multiply.

00:49:50.750 --> 00:49:52.410
So here is the answer, 2,183.

00:49:52.410 --> 00:49:57.950
I times two numbers
together and I got 2,183.

00:49:57.950 --> 00:49:59.600
And what were those two numbers?

00:49:59.600 --> 00:50:01.683
Now they don't teach you
now to do that at school.

00:50:04.070 --> 00:50:05.420
So let's do trial and error.

00:50:05.420 --> 00:50:06.590
Was it 2 times something?

00:50:06.590 --> 00:50:08.534
We could divide 2,183 by 2.

00:50:08.534 --> 00:50:09.200
It doesn't work.

00:50:09.200 --> 00:50:10.070
We get remainder 1.

00:50:10.070 --> 00:50:11.144
So let's divide it by 3.

00:50:11.144 --> 00:50:11.810
It doesn't work.

00:50:11.810 --> 00:50:13.009
We get remainder 2.

00:50:13.009 --> 00:50:15.050
And so we just divide it
by 4, or if you're smart

00:50:15.050 --> 00:50:17.070
you'll skip 4 because you've
done 2 and you'll go to 5.

00:50:17.070 --> 00:50:19.160
But you keep dividing and
dividing and dividing,

00:50:19.160 --> 00:50:21.720
and eventually you divide
it by 36, it doesn't work.

00:50:21.720 --> 00:50:23.060
You get remainder 33.

00:50:23.060 --> 00:50:26.270
You divide 2,183 by 37,
it works on the nose.

00:50:26.270 --> 00:50:27.400
There's no remainder.

00:50:27.400 --> 00:50:28.220
It's 59.

00:50:28.220 --> 00:50:34.000
So we conclude 2,183
is 37 times 59.

00:50:34.000 --> 00:50:35.500
But when you think
about it, so what

00:50:35.500 --> 00:50:37.249
are the numbers involved
in this question?

00:50:37.249 --> 00:50:39.690
2,183, 37, and 59.

00:50:39.690 --> 00:50:41.370
And how many steps did it take?

00:50:41.370 --> 00:50:43.890
You see, this method is
going to scale poorly

00:50:43.890 --> 00:50:44.940
because we took 37--

00:50:44.940 --> 00:50:48.960
I guess we took 36 steps
because we didn't divide by 1.

00:50:48.960 --> 00:50:52.560
But this particular method for
undoing multiplication scales

00:50:52.560 --> 00:50:55.320
very, very poorly, just
like the second Programme.

00:50:55.320 --> 00:50:59.820
Because the answer involved
37, but it's took steps.

00:50:59.820 --> 00:51:02.460
Whereas, before you multiply
these things together,

00:51:02.460 --> 00:51:05.641
we do it in under 10 steps.

00:51:05.641 --> 00:51:06.640
So there's an asymmetry.

00:51:06.640 --> 00:51:08.800
You can multiply them
together in just a few steps,

00:51:08.800 --> 00:51:11.440
but un-multiplying them,
factoring them it's called,

00:51:11.440 --> 00:51:12.140
it took forever.

00:51:12.140 --> 00:51:13.750
It took 37 steps.

00:51:13.750 --> 00:51:18.649
37 isn't very long, really,
but before I go into that point

00:51:18.649 --> 00:51:20.440
I was about to make,
every published method

00:51:20.440 --> 00:51:22.870
for un-multiplying numbers,
in fact, scales poorly.

00:51:22.870 --> 00:51:25.150
Some of them scale less
poorly than this one,

00:51:25.150 --> 00:51:29.140
but every published
method scales poorly.

00:51:29.140 --> 00:51:30.490
We don't know how to do that.

00:51:30.490 --> 00:51:32.630
So factoring actually
might be a problem,

00:51:32.630 --> 00:51:37.080
that it is not possible
in polynomial time.

00:51:37.080 --> 00:51:38.284
And now let's scale.

00:51:38.284 --> 00:51:40.450
If instead of multiplying
two-digit numbers together

00:51:40.450 --> 00:51:42.940
we started multiplying
100-digit numbers together,

00:51:42.940 --> 00:51:44.530
then we can multiply
them together.

00:51:44.530 --> 00:51:46.180
We have to do this times
this, this times this.

00:51:46.180 --> 00:51:48.760
We have to take a digit from
the first and the second number.

00:51:48.760 --> 00:51:50.710
That'll take 100
times 100 is 10,000.

00:51:50.710 --> 00:51:52.530
So we do 10,000 multiplications.

00:51:52.530 --> 00:51:53.820
We do 10,000 additions.

00:51:53.820 --> 00:51:55.800
We do about 20,000 steps.

00:51:55.800 --> 00:51:56.950
That's not a problem.

00:51:56.950 --> 00:51:58.930
Do 30,000 steps in
the blink of an eye.

00:51:58.930 --> 00:52:02.260
But remember, I'm talking about
numbers with 100 digits here.

00:52:02.260 --> 00:52:05.066
Those numbers have
a meaning, right?

00:52:05.066 --> 00:52:06.690
We write them down
in this neat way, 1,

00:52:06.690 --> 00:52:07.330
naught, naught, naught, naught.

00:52:07.330 --> 00:52:08.230
It's very clever.

00:52:08.230 --> 00:52:09.300
But they have a meaning.

00:52:09.300 --> 00:52:13.060
And the meaning is a vastly,
vastly huge number of things

00:52:13.060 --> 00:52:14.380
that you can't even comprehend.

00:52:14.380 --> 00:52:16.714
And indeed it's a number too
big to fit in the universe.

00:52:16.714 --> 00:52:18.213
It's a number bigger
than the number

00:52:18.213 --> 00:52:19.455
a particles in the universe.

00:52:19.455 --> 00:52:21.330
So that number is
representing an idea that's

00:52:21.330 --> 00:52:23.860
too big for our universe.

00:52:23.860 --> 00:52:26.895
If we just know the answer,
the 200-digit number, which

00:52:26.895 --> 00:52:28.270
we get by timesing
them together,

00:52:28.270 --> 00:52:29.800
and we want to
recover the factors,

00:52:29.800 --> 00:52:31.758
and we're going to use
this method I explained,

00:52:31.758 --> 00:52:34.270
we might have to count all the
way up to a 100-digit number.

00:52:34.270 --> 00:52:37.370
And we can't do that, because
the universe isn't big enough,

00:52:37.370 --> 00:52:39.910
we don't have enough time, and
we don't have enough space,

00:52:39.910 --> 00:52:41.200
and it can't be done--

00:52:41.200 --> 00:52:42.370
at least within my lifetime.

00:52:42.370 --> 00:52:43.930
And when you're
sending secret codes,

00:52:43.930 --> 00:52:45.850
you're not really worried
about whether they're

00:52:45.850 --> 00:52:46.933
cracked after you're gone.

00:52:50.380 --> 00:52:52.640
Yeah, my lifetime.

00:52:52.640 --> 00:52:56.252
This is relevant data.

00:52:56.252 --> 00:52:57.960
But here's a funny
thing about factoring.

00:52:57.960 --> 00:52:59.680
If somebody actually
told you the answer,

00:52:59.680 --> 00:53:01.680
somebody said, I think
the answer might be this,

00:53:01.680 --> 00:53:04.570
and they just gave you
two 100-digit numbers,

00:53:04.570 --> 00:53:08.105
you would be surprised that
they solved the problem.

00:53:08.105 --> 00:53:09.730
But you can check to
see if they're are

00:53:09.730 --> 00:53:12.910
right or not, because if you've
got these 100-digit numbers,

00:53:12.910 --> 00:53:14.440
you can times them
together and see

00:53:14.440 --> 00:53:17.060
if you get that 200-number
you're supposed to get.

00:53:17.060 --> 00:53:21.240
So factoring has this sort
of funny thing about it.

00:53:21.240 --> 00:53:24.430
It's hard to do, but if somebody
tells you what the answer is,

00:53:24.430 --> 00:53:28.740
it's very easy to check,
because multiplying is easy.

00:53:28.740 --> 00:53:31.260
So factoring, it seems
to be hard to do,

00:53:31.260 --> 00:53:33.300
but it's definitely
easy to check.

00:53:33.300 --> 00:53:36.120
And the notion of a
problem being easy to check

00:53:36.120 --> 00:53:38.250
turned out to be
another central notion

00:53:38.250 --> 00:53:41.310
in modern computational
complexity theory.

00:53:41.310 --> 00:53:42.600
So we got a name.

00:53:42.600 --> 00:53:45.540
Np is the collection of
all problems for which we

00:53:45.540 --> 00:53:48.600
can check a solution is correct
very quickly, by which I

00:53:48.600 --> 00:53:51.794
mean in polynomial time.

00:53:51.794 --> 00:53:53.460
So I've defined two
classes of problems.

00:53:53.460 --> 00:53:55.980
P is the class of problems
we can solve quickly,

00:53:55.980 --> 00:53:59.544
and NP, the class of problems
that, if somebody tells you

00:53:59.544 --> 00:54:00.960
what they think
the answer is, you

00:54:00.960 --> 00:54:03.010
can check if they're right
or wrong very quickly.

00:54:03.010 --> 00:54:08.400
So there's subtle differences,
but different they are.

00:54:08.400 --> 00:54:11.160
So every problem in p is an NP.

00:54:11.160 --> 00:54:12.900
All the problems you
can solve quickly,

00:54:12.900 --> 00:54:14.275
you can check the
answer quickly,

00:54:14.275 --> 00:54:17.722
because if you've got your
p problem that you can solve

00:54:17.722 --> 00:54:20.180
quickly, and somebody says,
oh, I think I know the solution

00:54:20.180 --> 00:54:21.510
and they give you
the solution, you

00:54:21.510 --> 00:54:23.400
can check it by just solving
the problem yourself.

00:54:23.400 --> 00:54:24.941
You solve the problem
yourself to see

00:54:24.941 --> 00:54:26.450
if you get the same answer.

00:54:26.450 --> 00:54:28.905
So any problem in
p is also in NP.

00:54:33.810 --> 00:54:37.309
But unfortunately there's
plenty of NP problems, problems

00:54:37.309 --> 00:54:38.850
that we can check
the answers quickly

00:54:38.850 --> 00:54:40.982
but which we don't know
how to solve them quickly.

00:54:40.982 --> 00:54:42.065
So this raises a question.

00:54:46.810 --> 00:54:49.330
So here are some
examples of NP problems,

00:54:49.330 --> 00:54:50.830
problems which we
can check quickly,

00:54:50.830 --> 00:54:52.466
which are not known to be in p.

00:54:52.466 --> 00:54:53.590
So factoring large numbers.

00:54:53.590 --> 00:54:54.370
I've mentioned that already.

00:54:54.370 --> 00:54:55.840
We don't know how
to do that quickly.

00:54:55.840 --> 00:54:57.340
But if someone tells
you what the answer is,

00:54:57.340 --> 00:54:58.215
we can do it quickly.

00:54:58.215 --> 00:55:00.370
Timetable exams,
unfortunately, turns out

00:55:00.370 --> 00:55:01.380
to be another problem.

00:55:01.380 --> 00:55:04.960
And in general problems
of that nature,

00:55:04.960 --> 00:55:06.880
I've had three kids going
to secondary school,

00:55:06.880 --> 00:55:10.469
and the way it works is the
council sends you a form,

00:55:10.469 --> 00:55:12.010
and you fill in the
form, and this is

00:55:12.010 --> 00:55:13.880
in like November or something.

00:55:13.880 --> 00:55:15.880
You send in the form, and
then the glorious news

00:55:15.880 --> 00:55:18.046
comes out where your kid's
going to secondary school

00:55:18.046 --> 00:55:19.250
on the 1st of March.

00:55:19.250 --> 00:55:21.015
And why does that
take four months?

00:55:21.015 --> 00:55:22.390
It's because trying
to figure out

00:55:22.390 --> 00:55:25.690
a way of fitting every
11-year-old in the country

00:55:25.690 --> 00:55:27.550
into a school so
that there's just

00:55:27.550 --> 00:55:29.341
the right number of
students in each school

00:55:29.341 --> 00:55:31.700
is really, really hard.

00:55:31.700 --> 00:55:33.790
So there's examples
all over science.

00:55:33.790 --> 00:55:35.540
I just took these
things off the computer.

00:55:35.540 --> 00:55:37.910
I've got no idea what
any of those things mean,

00:55:37.910 --> 00:55:41.770
but they looked very important,
so I thought I'd mention them.

00:55:41.770 --> 00:55:44.270
This one I do know
what it means.

00:55:44.270 --> 00:55:45.270
Decrypting data sent.

00:55:45.270 --> 00:55:48.570
We have a standard way to
send data to a secure website

00:55:48.570 --> 00:55:53.855
to secure a website where we are
typing in credit card numbers

00:55:53.855 --> 00:55:55.240
to buy things on the internet.

00:55:55.240 --> 00:55:58.840
And decrypting that
without the decryption key

00:55:58.840 --> 00:56:01.160
is something we don't know
how to do very quickly.

00:56:01.160 --> 00:56:04.180
But this is in NP.

00:56:04.180 --> 00:56:06.640
There's various other
things Candy Crush is an NP.

00:56:06.640 --> 00:56:08.530
Pokemon also an NP.

00:56:08.530 --> 00:56:10.927
Super Mario Bros also an NP.

00:56:10.927 --> 00:56:13.010
Basically trying to solve
a Super Mario Bros level

00:56:13.010 --> 00:56:13.990
is very hard.

00:56:13.990 --> 00:56:16.741
But if somebody comes
along and does it,

00:56:16.741 --> 00:56:18.490
you can clearly check
that they've done it

00:56:18.490 --> 00:56:20.701
because I got to the end.

00:56:20.701 --> 00:56:22.450
So we don't know a
fast method for solving

00:56:22.450 --> 00:56:24.045
any of those problems.

00:56:24.045 --> 00:56:26.170
But we know a fast method
for checking the answers.

00:56:26.170 --> 00:56:29.110
So there are examples
of problems that are NP.

00:56:29.110 --> 00:56:31.180
They're in NP, but we
don't know if they're in p.

00:56:34.290 --> 00:56:35.290
So there's the question.

00:56:35.290 --> 00:56:36.150
Does p equal NP?

00:56:40.320 --> 00:56:42.450
If we have a problem,
and it turns out

00:56:42.450 --> 00:56:45.059
we can check to see if the
solution is correct quickly,

00:56:45.059 --> 00:56:47.100
could we actually have
solved the problem quickly

00:56:47.100 --> 00:56:51.527
in the first place without
knowing what the solution was?

00:56:51.527 --> 00:56:52.360
I'm doing all right.

00:56:52.360 --> 00:56:53.740
I thought I was
going to overrun.

00:56:53.740 --> 00:56:55.810
I'm doing great.

00:56:55.810 --> 00:56:56.590
So there you go.

00:56:56.590 --> 00:56:59.980
By 1971, Stephen Cook had
formalised this notion.

00:56:59.980 --> 00:57:02.860
And he raised this question
explicitly in 1971,

00:57:02.860 --> 00:57:05.080
having laid down some
mathematical background.

00:57:05.080 --> 00:57:07.060
So he'd given a rigorous
mathematical notion

00:57:07.060 --> 00:57:09.940
of what a problem was,
of what the solution was,

00:57:09.940 --> 00:57:11.917
and the class of
problems that are in p

00:57:11.917 --> 00:57:13.625
and the class of
problems that are in NP.

00:57:13.625 --> 00:57:16.540
There's lots of mathematics and
rigour that I'm suppressing,

00:57:16.540 --> 00:57:19.096
but he did it, and he raised
this question explicitly.

00:57:19.096 --> 00:57:20.470
And then the year
after he failed

00:57:20.470 --> 00:57:25.660
to get tenure at UC Berkeley,
because computers in 1971

00:57:25.660 --> 00:57:28.000
were really irrelevant.

00:57:28.000 --> 00:57:30.280
So it's an abstract,
well-defined mathematical

00:57:30.280 --> 00:57:30.791
question.

00:57:30.791 --> 00:57:33.040
And it was an unsolved problem
that the mathematicians

00:57:33.040 --> 00:57:37.720
at UC Berkeley decided was
of peripheral interest.

00:57:37.720 --> 00:57:42.211
But you've seen now the kind
of implications that solving

00:57:42.211 --> 00:57:43.210
this problem might have.

00:57:43.210 --> 00:57:45.100
And it's now regarded as one
of the most important problems

00:57:45.100 --> 00:57:45.880
in mathematics.

00:57:45.880 --> 00:57:48.180
Is one of the seven "Clay
Millennium Problems."

00:57:48.180 --> 00:57:50.085
So if you solve it,
some entrepreneur

00:57:50.085 --> 00:57:52.720
has donated a million
bucks as motivation

00:57:52.720 --> 00:57:55.900
to try and solve these problems.

00:57:55.900 --> 00:57:57.622
So we've got the problems in p.

00:57:57.622 --> 00:57:58.330
They're in there.

00:57:58.330 --> 00:57:59.289
We have problems in NP.

00:57:59.289 --> 00:58:01.080
And then the question
is, is there actually

00:58:01.080 --> 00:58:03.640
definitely a problem that's
lurking where that question

00:58:03.640 --> 00:58:06.910
mark is that's in NP,
you can check quickly

00:58:06.910 --> 00:58:08.680
but it's definitely not in p.

00:58:08.680 --> 00:58:10.870
So we know plenty of
problems that are in p,

00:58:10.870 --> 00:58:12.970
and we know plenty of
problems that are in NP,

00:58:12.970 --> 00:58:14.860
and we don't know if
they're in p or not.

00:58:14.860 --> 00:58:18.250
But that's the current
state of our knowledge.

00:58:18.250 --> 00:58:20.920
So what would happen if somebody
proved that p equaled an NP?

00:58:20.920 --> 00:58:22.510
Because mathematicians
are working--

00:58:22.510 --> 00:58:23.890
mathematicians, theorists,
computer scientists,

00:58:23.890 --> 00:58:25.120
working very hard
on this problem.

00:58:25.120 --> 00:58:27.080
What would happen if
somebody proved p was NP.

00:58:27.080 --> 00:58:29.340
Then all of a sudden a
whole bunch of problems

00:58:29.340 --> 00:58:30.910
which we didn't
know how to solve,

00:58:30.910 --> 00:58:34.300
suddenly we could solve very,
very quickly using a computer.

00:58:34.300 --> 00:58:37.120
So suddenly transportation
get scheduled optimally.

00:58:37.120 --> 00:58:38.290
We save lots of fuel.

00:58:38.290 --> 00:58:40.420
People and goods move
around quicker and cheaper.

00:58:40.420 --> 00:58:42.430
Factories become
infinitely more efficient.

00:58:42.430 --> 00:58:44.680
Dramatic advances in
medicine, because suddenly

00:58:44.680 --> 00:58:46.570
we can cure cancer.

00:58:46.570 --> 00:58:49.080
I don't know if we
can cure cancer.

00:58:49.080 --> 00:58:51.550
We could certainly do
much quicker experiments.

00:58:51.550 --> 00:58:54.730
Perfect computer vision,
computer language recognition.

00:58:54.730 --> 00:58:56.080
So you see the problem.

00:58:56.080 --> 00:58:59.200
It wasn't very important
in 1971, but predictions

00:58:59.200 --> 00:59:00.460
of weather and of earthquakes.

00:59:00.460 --> 00:59:02.050
Huge advances in
modern mathematics,

00:59:02.050 --> 00:59:04.420
because solving a
mathematical problem

00:59:04.420 --> 00:59:06.550
is a great example of
something that's an NP.

00:59:06.550 --> 00:59:08.320
How you work on a
problem, I can't do it.

00:59:08.320 --> 00:59:09.278
There's lots of axioms.

00:59:09.278 --> 00:59:10.727
I don't know which to--

00:59:10.727 --> 00:59:13.310
I don't know how to apply them
or what order to apply them in.

00:59:13.310 --> 00:59:15.990
But if somebody comes along
and hands me a proof of this,

00:59:15.990 --> 00:59:18.379
you know, if someone says,
I can prove the thing.

00:59:18.379 --> 00:59:20.170
I can sort out the
thing you're working on,

00:59:20.170 --> 00:59:21.470
here's the question
you are working on,

00:59:21.470 --> 00:59:22.240
here's a proof of it.

00:59:22.240 --> 00:59:23.840
I can read the proof
really quickly.

00:59:23.840 --> 00:59:25.715
I can check that that's
a mathematical proof.

00:59:25.715 --> 00:59:27.220
That's part of my training.

00:59:27.220 --> 00:59:29.745
So I can check the answer
quickly, and so if p was NP,

00:59:29.745 --> 00:59:31.240
I can solve the problem quickly.

00:59:31.240 --> 00:59:33.240
So we can just get computers
to do lots and lots

00:59:33.240 --> 00:59:34.324
and in modern mathematics.

00:59:34.324 --> 00:59:36.906
It also means, of course, there
is no such thing as encryption

00:59:36.906 --> 00:59:37.459
anymore.

00:59:37.459 --> 00:59:39.250
So the government can
read all your emails,

00:59:39.250 --> 00:59:40.460
even if you encrypt them.

00:59:40.460 --> 00:59:42.417
And internet security
is now broken.

00:59:42.417 --> 00:59:44.500
You can't type your credit
card into the internet,

00:59:44.500 --> 00:59:46.680
so online banks instantly,
everything gets--

00:59:46.680 --> 00:59:47.920
So society really changes.

00:59:50.830 --> 00:59:54.674
The internet stops working,
but maybe we can cure cancer.

00:59:54.674 --> 00:59:56.590
But the world would be
a very different place.

00:59:59.290 --> 01:00:01.770
Unfortunately, or
possibly fortunately,

01:00:01.770 --> 01:00:04.240
most computer scientists believe
that p is not equal to NP.

01:00:04.240 --> 01:00:06.970
They believe that there are
problems out there which

01:00:06.970 --> 01:00:09.760
are easy to check but
hard to solve, easy

01:00:09.760 --> 01:00:11.480
to check the solutions
but hard to solve.

01:00:11.480 --> 01:00:12.855
So what would
happen if we proved

01:00:12.855 --> 01:00:14.350
that p was not equal to NP?

01:00:14.350 --> 01:00:17.260
Then we know then
these guaranteed--

01:00:17.260 --> 01:00:19.950
we have algorithms
which we now guarantee

01:00:19.950 --> 01:00:21.050
can't be solved quickly.

01:00:21.050 --> 01:00:23.150
Now, we definitely know
we can talk in code.

01:00:23.150 --> 01:00:25.750
So I know that the
government can't spy on me.

01:00:25.750 --> 01:00:26.660
That's really good.

01:00:26.660 --> 01:00:28.930
And terrorists also
know that the government

01:00:28.930 --> 01:00:30.130
can't spy on them.

01:00:30.130 --> 01:00:32.644
And all the people that are
currently selling illegal drugs

01:00:32.644 --> 01:00:34.060
and weapons on the
dark internet--

01:00:34.060 --> 01:00:35.680
and that really is
happening-- they

01:00:35.680 --> 01:00:39.880
can sit comfortably knowing full
well that they can definitely

01:00:39.880 --> 01:00:41.510
not be traced.

01:00:41.510 --> 01:00:44.080
So again, the world
changes a little bit.

01:00:44.080 --> 01:00:46.360
And this is currently
the working model right.

01:00:46.360 --> 01:00:50.290
Theresa May was very,
very upset about there

01:00:50.290 --> 01:00:51.250
was an iPhone story.

01:00:51.250 --> 01:00:53.740
You remember some guy, there
was incriminating evidence

01:00:53.740 --> 01:00:56.440
on his iPhone, but they
couldn't unlock it,

01:00:56.440 --> 01:01:00.146
and Apple said they
weren't going to unlock it.

01:01:00.146 --> 01:01:02.770
The problem resolved itself, but
that's the tip of the iceberg.

01:01:02.770 --> 01:01:03.478
More will happen.

01:01:03.478 --> 01:01:05.010
Again, there will
be police officers

01:01:05.010 --> 01:01:07.676
that know full well that there's
an encrypted drive that if they

01:01:07.676 --> 01:01:09.610
could decrypt, then
this guy is nailed.

01:01:09.610 --> 01:01:11.110
But they can't decrypt it.

01:01:11.110 --> 01:01:13.270
If p is an NP, we
can design code

01:01:13.270 --> 01:01:14.980
that can be possible to break.

01:01:14.980 --> 01:01:17.833
So it should be clear that it's
clearly important to work out

01:01:17.833 --> 01:01:20.650
p is NP or not, right?

01:01:20.650 --> 01:01:22.780
So all the problems
in p are in NP.

01:01:22.780 --> 01:01:25.950
But the question is, are there
problems in NP but not in p?

01:01:29.552 --> 01:01:31.510
If you tell me this is
your problem in class p,

01:01:31.510 --> 01:01:32.950
we said all this already.

01:01:32.950 --> 01:01:34.617
So this is the point.

01:01:34.617 --> 01:01:35.950
I'm going to tell you the point.

01:01:35.950 --> 01:01:39.100
How does a mathematician-- so
p probably isn't equal to NP,

01:01:39.100 --> 01:01:41.484
so how is a mathematician
going to prove that?

01:01:41.484 --> 01:01:42.400
And this is the point.

01:01:42.400 --> 01:01:44.512
All they have to do is
they have to find something

01:01:44.512 --> 01:01:45.220
in that question.

01:01:45.220 --> 01:01:47.830
They have to find a
problem which is in np.

01:01:47.830 --> 01:01:49.270
We can check the answer quickly.

01:01:49.270 --> 01:01:53.560
But they have to prove that
this problem cannot be solved

01:01:53.560 --> 01:01:54.370
quickly.

01:01:54.370 --> 01:01:56.380
That's what the problem is.

01:01:56.380 --> 01:01:58.960
And we're not yet
at the stage where

01:01:58.960 --> 01:02:01.210
we have the theoretical
tools to do that.

01:02:01.210 --> 01:02:02.860
This is the issue.

01:02:02.860 --> 01:02:05.380
We have to prove that
you can't do something,

01:02:05.380 --> 01:02:07.954
and we could only prove you
could do things in the 70s,

01:02:07.954 --> 01:02:09.620
so when are we going
to be able to prove

01:02:09.620 --> 01:02:11.200
that you can't do things?

01:02:11.200 --> 01:02:13.930
So here's the time frame
now, the third example

01:02:13.930 --> 01:02:15.550
of doing things and
not doing things.

01:02:15.550 --> 01:02:19.060
Nash formulated the question,
gave easy examples of problems

01:02:19.060 --> 01:02:20.830
that could be solved quickly.

01:02:20.830 --> 01:02:25.120
Cook formalises the mathematics,
raises the question explicitly,

01:02:25.120 --> 01:02:27.100
and then we don't
know what happens.

01:02:27.100 --> 01:02:30.730
Somebody at some point
probably will find an example

01:02:30.730 --> 01:02:34.000
of a problem where they can
check answers quickly but they

01:02:34.000 --> 01:02:36.550
can prove that you
cannot solve it quickly.

01:02:36.550 --> 01:02:38.230
But we are not yet there.

01:02:38.230 --> 01:02:41.140
It took 2,000 years
for the Euclid one.

01:02:41.140 --> 01:02:42.141
How long will this take?

01:02:42.141 --> 01:02:44.431
So many modern mathematical
techniques have been tried.

01:02:44.431 --> 01:02:45.230
All have failed.

01:02:48.070 --> 01:02:53.470
There was a promising
approach developed initially

01:02:53.470 --> 01:02:57.040
in 2001, and then really
prominently in 2011,

01:02:57.040 --> 01:02:58.484
using geometric
complexity theory.

01:02:58.484 --> 01:03:00.400
And again, it follows
exactly the same pattern

01:03:00.400 --> 01:03:01.280
as the other things.

01:03:01.280 --> 01:03:02.920
This used modern
algebraic geometry,

01:03:02.920 --> 01:03:05.170
which was only
invented in the 1960s,

01:03:05.170 --> 01:03:06.919
and modern
representation theory.

01:03:06.919 --> 01:03:08.710
So using these very,
very modern techniques

01:03:08.710 --> 01:03:11.770
that weren't around for
people like Cook and Nash.

01:03:11.770 --> 01:03:14.110
Geometric complexity
theory was an attempt

01:03:14.110 --> 01:03:15.280
to resolve this question.

01:03:15.280 --> 01:03:16.870
But the big
breakthrough in April

01:03:16.870 --> 01:03:21.280
last year was a team
of people proved

01:03:21.280 --> 01:03:23.800
that actually the path
that we were following

01:03:23.800 --> 01:03:26.330
using geometric complexity
theory to prove that p was not

01:03:26.330 --> 01:03:30.506
in NP, they proved
that it would not work.

01:03:30.506 --> 01:03:32.380
So you see mathematicians
are good at proving

01:03:32.380 --> 01:03:33.470
that things don't happen.

01:03:33.470 --> 01:03:36.100
But in this case it wasn't
proving that p wasn't in NP.

01:03:36.100 --> 01:03:38.980
It was proving that our idea
is even sort of meta meta.

01:03:38.980 --> 01:03:43.554
The strategy of
proof cannot succeed.

01:03:43.554 --> 01:03:44.220
So there you go.

01:03:44.220 --> 01:03:45.470
So that's the end of the talk.

01:03:45.470 --> 01:03:48.060
How do we prove that we can't
solve a problem quickly?

01:03:48.060 --> 01:03:52.200
Currently we don't
have the answer.

01:03:52.200 --> 01:03:53.400
So thank you.

01:03:53.400 --> 01:03:57.050
[APPLAUSE]

