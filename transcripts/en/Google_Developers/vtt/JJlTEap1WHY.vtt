WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:01:02.874
[MUSIC PLAYING]

00:01:14.460 --> 00:01:16.150
PAUL SAXMAN: Hello, and welcome
to this week's episode

00:01:16.150 --> 00:01:18.080
of Google Maps Developers
Live.

00:01:18.080 --> 00:01:19.140
I'm Paul Saxman.

00:01:19.140 --> 00:01:21.770
And with me this week
is Brendan, The

00:01:21.770 --> 00:01:23.890
Tessellator, Kenny.

00:01:23.890 --> 00:01:25.050
BRENDAN KENNY: That is
what they call me.

00:01:25.050 --> 00:01:26.360
PAUL SAXMAN: Yes.

00:01:26.360 --> 00:01:30.060
And this week, we're going to
talk about some advanced

00:01:30.060 --> 00:01:33.370
visualization techniques
using WebGL.

00:01:33.370 --> 00:01:36.845
And specifically, we're going
to talk about a library that

00:01:36.845 --> 00:01:40.650
you recently ported from C
to the JavaScript, right?

00:01:40.650 --> 00:01:41.120
BRENDAN KENNY: Right.

00:01:41.120 --> 00:01:47.030
PAUL SAXMAN: To do exactly what
your title describes,

00:01:47.030 --> 00:01:47.730
tessellation.

00:01:47.730 --> 00:01:49.590
BRENDAN KENNY: Yeah.

00:01:49.590 --> 00:01:50.010
Yeah.

00:01:50.010 --> 00:01:53.390
So this one, this library,
it's a--

00:01:53.390 --> 00:01:55.310
I don't know what I'm
trying to say.

00:01:55.310 --> 00:01:56.750
It's a little bit
of a step back.

00:01:56.750 --> 00:01:58.280
It's not necessarily
an application.

00:01:58.280 --> 00:02:01.000
It's more of a tool that you
can use for applications.

00:02:01.000 --> 00:02:03.760
And so we're going to mostly
talk about the tool itself

00:02:03.760 --> 00:02:09.259
today, and show some examples,
but not anything that will be

00:02:09.259 --> 00:02:10.669
really mind blowing.

00:02:10.669 --> 00:02:12.770
It will be more like, this will
be useful if you need

00:02:12.770 --> 00:02:13.350
this sort of thing.

00:02:13.350 --> 00:02:14.140
PAUL SAXMAN: I don't know.

00:02:14.140 --> 00:02:19.710
I mean, maybe for the uneducated
of us, maybe

00:02:19.710 --> 00:02:22.150
explain what tessellation
actually is.

00:02:22.150 --> 00:02:27.610
Because for graphics guys, it's
pretty straightforward.

00:02:27.610 --> 00:02:32.460
BRENDAN KENNY: So the reason
that we need this--

00:02:32.460 --> 00:02:35.640
in the past, we've talked about
how it can be useful to

00:02:35.640 --> 00:02:39.990
draw WebGL stuff on
top of a map.

00:02:39.990 --> 00:02:41.030
It gets you a couple
of things.

00:02:41.030 --> 00:02:43.010
It gets you really
good performance

00:02:43.010 --> 00:02:44.170
for a lot of things.

00:02:44.170 --> 00:02:47.110
So say you want to put even
millions of markers down or

00:02:47.110 --> 00:02:47.610
something like that.

00:02:47.610 --> 00:02:51.990
You can't do that today with
Canvas or any of the mapping

00:02:51.990 --> 00:02:54.660
libraries out there.

00:02:54.660 --> 00:02:57.820
So, you need to cluster, or
generate tiles, or whatever.

00:02:57.820 --> 00:03:00.170
But with WebGL-- putting WebGL
on top of a map-- you could do

00:03:00.170 --> 00:03:01.990
that, if you wanted to.

00:03:01.990 --> 00:03:03.700
You'd have to think about
the usability of

00:03:03.700 --> 00:03:05.050
those millions of markers.

00:03:05.050 --> 00:03:07.175
But you could, if you wanted
to, is the key.

00:03:07.175 --> 00:03:08.970
PAUL SAXMAN: And we talked about
the trick with all this

00:03:08.970 --> 00:03:10.870
is using what we [? presented ?]
at the

00:03:10.870 --> 00:03:12.540
previous show is the
CanvasLayer.

00:03:12.540 --> 00:03:12.950
BRENDAN KENNY: Yeah.

00:03:12.950 --> 00:03:15.340
So, there's the CanvasLayer
library.

00:03:15.340 --> 00:03:17.560
You can just Google for
that, one word.

00:03:17.560 --> 00:03:18.760
It's the top result.

00:03:18.760 --> 00:03:21.160
And it's in the Maps API
utility library.

00:03:21.160 --> 00:03:26.510
And what it does is it just
sticks an HTML5 canvas as a

00:03:26.510 --> 00:03:28.680
layer in your Google Map.

00:03:28.680 --> 00:03:30.320
And then you get
a handle to it.

00:03:30.320 --> 00:03:32.280
And you can draw whatever you
want to it, whether that's 2D

00:03:32.280 --> 00:03:34.980
Canvas or WebGL.

00:03:34.980 --> 00:03:36.900
So points are easy.

00:03:36.900 --> 00:03:40.730
But a lot of geographic data
is in the form of polygons.

00:03:40.730 --> 00:03:45.560
And the problem is that WebGL
can only draw triangles.

00:03:45.560 --> 00:03:49.420
That's the simplest primitive
there is that has area.

00:03:49.420 --> 00:03:55.120
But the fact is that most
geographic data actually

00:03:55.120 --> 00:03:57.330
stores things as polygons,
both for efficiency and

00:03:57.330 --> 00:03:58.790
because it's kind of
a more natural way

00:03:58.790 --> 00:04:02.350
to describe an area.

00:04:02.350 --> 00:04:07.150
And so you need something to
be able to draw polygons.

00:04:07.150 --> 00:04:08.520
So you get speed.

00:04:08.520 --> 00:04:10.050
But you can also do things like
you can start getting

00:04:10.050 --> 00:04:13.620
custom effects per pixel, and
do crazy lighting, or just

00:04:13.620 --> 00:04:16.740
things based on demographic
data or whatever.

00:04:16.740 --> 00:04:20.029
All these things are unlocked
when you can really do fancy

00:04:20.029 --> 00:04:22.980
WebGL, especially if you want
to do it for, say, every

00:04:22.980 --> 00:04:27.500
county, or every country,
or political

00:04:27.500 --> 00:04:30.990
district within some area.

00:04:30.990 --> 00:04:31.360
So yeah.

00:04:31.360 --> 00:04:33.500
So the key is that
we need to make

00:04:33.500 --> 00:04:34.820
triangles out of polygons.

00:04:34.820 --> 00:04:37.490
And then there's another layer
of things where geographic

00:04:37.490 --> 00:04:40.850
data is also extremely messy
usually, whether it's coming

00:04:40.850 --> 00:04:44.160
in in real time-- in which case
you excuse for polygons

00:04:44.160 --> 00:04:47.220
to backtrack on themselves and
intersect with themselves and

00:04:47.220 --> 00:04:53.160
have repeated vertices within
their descriptions--

00:04:53.160 --> 00:04:55.540
or when you don't really
have an excuse.

00:04:55.540 --> 00:04:59.570
You get a file from a customer
or something like that, and

00:04:59.570 --> 00:05:04.250
maybe the file format says that
all the polygons have to

00:05:04.250 --> 00:05:07.370
the wind a certain direction
and not self intersect.

00:05:07.370 --> 00:05:11.260
But inevitably, someone will
give you a file that's

00:05:11.260 --> 00:05:14.130
horribly garbled and you need
to display it on screen.

00:05:14.130 --> 00:05:15.250
So you have to deal with
both of those things.

00:05:15.250 --> 00:05:17.360
We have to make triangles, but
we have to make triangles out

00:05:17.360 --> 00:05:18.460
of nasty data.

00:05:18.460 --> 00:05:20.680
PAUL SAXMAN: And there's
also doughnuts, right?

00:05:20.680 --> 00:05:20.970
BRENDAN KENNY: Right.

00:05:20.970 --> 00:05:21.240
Yes.

00:05:21.240 --> 00:05:25.800
And so then you can
have multiple--

00:05:25.800 --> 00:05:26.860
like in KML--

00:05:26.860 --> 00:05:31.850
rings where some define inside,
and some define holes

00:05:31.850 --> 00:05:35.660
on the inside of the polygon.

00:05:35.660 --> 00:05:37.400
So it's complicated.

00:05:37.400 --> 00:05:40.060
And so we kind of looked around
a few months ago.

00:05:40.060 --> 00:05:43.850
And we're looking for kind of
libraries that would let you

00:05:43.850 --> 00:05:46.070
do that, and do it
efficiently.

00:05:46.070 --> 00:05:47.560
And there wasn't really
a lot of options.

00:05:47.560 --> 00:05:51.180
There's a few triangulation,
or tessellation

00:05:51.180 --> 00:05:53.230
libraries out there.

00:05:53.230 --> 00:05:57.680
But they're not necessarily
super fast or super stable and

00:05:57.680 --> 00:06:00.220
really let you throw
anything at them.

00:06:00.220 --> 00:06:06.750
So I decided to port the GLU
tessellator which is the--

00:06:06.750 --> 00:06:12.200
GLU is the OpenGL utility
library from years gone by.

00:06:12.200 --> 00:06:19.370
Originally late '80s, early '90s
is most of the code, so

00:06:19.370 --> 00:06:21.200
generally about 20 years old.

00:06:21.200 --> 00:06:22.730
PAUL SAXMAN: And kind of an
interesting piece of trivia is

00:06:22.730 --> 00:06:26.030
that it was probably written
over in the Google Main

00:06:26.030 --> 00:06:28.420
Campus, which was then SGI.

00:06:28.420 --> 00:06:28.690
BRENDAN KENNY: Right.

00:06:28.690 --> 00:06:32.010
So the implementation that I
was looking at was the SGI

00:06:32.010 --> 00:06:37.410
open source implementation,
which was written just a few

00:06:37.410 --> 00:06:38.760
blocks next door.

00:06:38.760 --> 00:06:41.230
Actually, it says you can go to
that address and get your

00:06:41.230 --> 00:06:45.480
software license in writing,
even though Google's there

00:06:45.480 --> 00:06:46.730
now, not SGI.

00:06:48.950 --> 00:06:50.420
So let's take a look.

00:06:50.420 --> 00:06:54.150
If you go on GitHub and you
look for libtess.js.

00:06:54.150 --> 00:06:55.900
Libtess is the name
of the library.

00:06:55.900 --> 00:07:02.090
It implements the GLU
tessellator interface.

00:07:02.090 --> 00:07:02.880
You can see it.

00:07:02.880 --> 00:07:05.470
And right now you see
license information.

00:07:05.470 --> 00:07:08.140
And actually, there's no
examples right now, so I'm

00:07:08.140 --> 00:07:11.260
going to rectify that after
this with the example that

00:07:11.260 --> 00:07:12.365
we're about to look at.

00:07:12.365 --> 00:07:14.370
And you can see kind
of how it's used.

00:07:14.370 --> 00:07:15.550
It's a little esoteric.

00:07:15.550 --> 00:07:16.720
It's very C-like.

00:07:16.720 --> 00:07:18.440
So it was originally C code.

00:07:18.440 --> 00:07:21.190
And I left it as close to the
original interface as possible

00:07:21.190 --> 00:07:23.690
when I was porting to make
sure that it worked.

00:07:23.690 --> 00:07:26.170
And now that it's working, I'm
going to start looking at

00:07:26.170 --> 00:07:29.380
options for more JavaScript
interface.

00:07:29.380 --> 00:07:34.800
There's lots of enumerated
property values that you pass

00:07:34.800 --> 00:07:35.620
in and flags.

00:07:35.620 --> 00:07:36.500
And there's a weird mix.

00:07:36.500 --> 00:07:38.430
And I don't know if this has
to with just historical

00:07:38.430 --> 00:07:40.550
reasons, but there's
a weird mix of--

00:07:40.550 --> 00:07:42.740
for some things, you actually
pass in call backs.

00:07:42.740 --> 00:07:45.250
You pass in function pointers
in the C code.

00:07:45.250 --> 00:07:47.710
And sometimes it's like you get
this insanely long switch

00:07:47.710 --> 00:07:51.960
function based on different
enumerated values.

00:07:51.960 --> 00:07:52.270
It's a weird mix.

00:07:52.270 --> 00:07:54.230
And there's no reason it needs
to be like that, because

00:07:54.230 --> 00:07:55.876
there's not going to be a lot of
legacy code that people are

00:07:55.876 --> 00:07:56.560
going to be using here.

00:07:56.560 --> 00:07:58.390
So why not make a
new interface?

00:07:58.390 --> 00:08:00.520
But for now it's very C-like,
which is what we're going to

00:08:00.520 --> 00:08:03.460
be talking about today.

00:08:03.460 --> 00:08:05.170
So can see the information
and the license.

00:08:05.170 --> 00:08:08.550
The license is kind of a weird
SGI-specific license.

00:08:08.550 --> 00:08:11.790
But the Free Software Foundation
has actually worked

00:08:11.790 --> 00:08:14.320
with the remnant of SGI
to get it under a

00:08:14.320 --> 00:08:15.430
nice friendly license.

00:08:15.430 --> 00:08:18.840
And now it's fully compatible
with all your--

00:08:18.840 --> 00:08:23.710
it's BSD-like, but it's also
compatible with all your other

00:08:23.710 --> 00:08:24.890
Copyleft licenses.

00:08:24.890 --> 00:08:25.930
So feel free to use it.

00:08:25.930 --> 00:08:27.160
Rip stuff out of it.

00:08:27.160 --> 00:08:28.410
Do anything you want with it.

00:08:31.750 --> 00:08:34.780
So let's look at an
example first.

00:08:34.780 --> 00:08:35.280
Sound good?

00:08:35.280 --> 00:08:36.780
PAUL SAXMAN: [INAUDIBLE]

00:08:36.780 --> 00:08:39.219
BRENDAN KENNY: Oh, right.

00:08:39.219 --> 00:08:40.469
Let's go full screen.

00:08:43.820 --> 00:08:47.290
So here is all the--

00:08:47.290 --> 00:08:50.230
well it's basically zip codes,
but it's actually pseudo zip

00:08:50.230 --> 00:08:55.680
codes from the Census
Department, Bureau, whatever,

00:08:55.680 --> 00:08:56.870
in California.

00:08:56.870 --> 00:09:02.370
And I think we have, I don't
know, a few hundred-thousand

00:09:02.370 --> 00:09:05.060
triangles make up
to this drawing.

00:09:05.060 --> 00:09:08.910
This is actually from a
shapefile parser that Mano

00:09:08.910 --> 00:09:12.850
Marks ported over
to JavaScript.

00:09:12.850 --> 00:09:14.990
And so it parses a shapefile.

00:09:14.990 --> 00:09:17.970
And then it takes all those
polygons and runs it through

00:09:17.970 --> 00:09:21.540
the triangulation, the
tessellator library, to make

00:09:21.540 --> 00:09:24.190
polygons, and then fills them
in with random colors.

00:09:24.190 --> 00:09:25.130
I just picked random colors.

00:09:25.130 --> 00:09:28.790
But you could imagine that this
is based on zip code data

00:09:28.790 --> 00:09:30.370
or demographic data.

00:09:30.370 --> 00:09:34.330
And I think we actually showed
this a month or two ago on one

00:09:34.330 --> 00:09:37.570
of our visualization
sessions with Mano.

00:09:37.570 --> 00:09:40.640
And if we get down to it, you
can actually see this handles

00:09:40.640 --> 00:09:44.870
well even cases where there's
holes within polygons, where

00:09:44.870 --> 00:09:47.960
there's smaller zip codes
within larger zip codes.

00:09:50.900 --> 00:09:54.108
And if I open up the
console here--

00:09:54.108 --> 00:09:56.820
ooh, that's fun.

00:09:56.820 --> 00:10:02.700
Let's pop it into here.

00:10:02.700 --> 00:10:09.406
If we open up the console, we
can then make a function.

00:10:12.960 --> 00:10:13.750
Let's see.

00:10:13.750 --> 00:10:15.660
Change places, I call it.

00:10:15.660 --> 00:10:21.830
And so what this does is it
loops over all the zip codes

00:10:21.830 --> 00:10:24.340
and assigns a random
color to them.

00:10:24.340 --> 00:10:27.000
It just takes picks a
random RGB value and

00:10:27.000 --> 00:10:28.270
assigns a random color.

00:10:28.270 --> 00:10:30.950
And then I call Schedule Update
on the CanvasLayer,

00:10:30.950 --> 00:10:33.340
which just calls a paint.

00:10:33.340 --> 00:10:40.030
So if I call that, everything
will change to a random color.

00:10:40.030 --> 00:10:43.030
And then if we just want to
make sure that we have the

00:10:43.030 --> 00:10:47.380
proper disco party feel,
we could actually put--

00:10:47.380 --> 00:10:51.570
let's put that in an interval,
because why not?

00:10:51.570 --> 00:10:53.870
It's like the blink
tag, but for Maps.

00:10:53.870 --> 00:10:55.020
PAUL SAXMAN: Don't cause
any seizures.

00:10:55.020 --> 00:10:55.400
BRENDAN KENNY: Yeah.

00:10:55.400 --> 00:10:56.900
So I'm going to put it
at 500 milliseconds.

00:10:56.900 --> 00:10:57.810
So it's a little slower.

00:10:57.810 --> 00:11:00.400
We can do it at the frame
rate if we wanted to.

00:11:00.400 --> 00:11:01.650
And now--

00:11:03.830 --> 00:11:05.530
PAUL SAXMAN: That's the
amazing thing, right?

00:11:05.530 --> 00:11:08.500
So you have I don't know how
many polygon on there.

00:11:08.500 --> 00:11:09.450
BRENDAN KENNY: I think
this comes down.

00:11:09.450 --> 00:11:10.150
Yeah, I don't know.

00:11:10.150 --> 00:11:13.720
Actually, I should count the
number of zip codes.

00:11:13.720 --> 00:11:17.300
But even in LA, you have just
a crazy number of--

00:11:17.300 --> 00:11:19.270
including these ones.

00:11:19.270 --> 00:11:22.900
I don't know if that's due to
the post office, or if it has

00:11:22.900 --> 00:11:25.170
something to do with
gerrymandering at some point

00:11:25.170 --> 00:11:26.030
in the past.

00:11:26.030 --> 00:11:27.310
PAUL SAXMAN: So it's like
political boundary.

00:11:27.310 --> 00:11:27.440
BRENDAN KENNY: Yeah.

00:11:27.440 --> 00:11:29.590
It follows rivers.

00:11:29.590 --> 00:11:32.460
And I guess that's because
they tried to get at

00:11:32.460 --> 00:11:34.510
neighborhoods maybe at some
time in the past.

00:11:34.510 --> 00:11:39.250
But yeah, so you can
make really amazing

00:11:39.250 --> 00:11:40.580
beautiful maps like this.

00:11:40.580 --> 00:11:45.020
But the key is that we're
redrawing all these triangles

00:11:45.020 --> 00:11:46.000
in real time.

00:11:46.000 --> 00:11:48.180
And if we wanted to
do at 60 frames a

00:11:48.180 --> 00:11:50.140
second, I could do that.

00:11:50.140 --> 00:11:52.660
But I'm refraining, because I
don't think the video will

00:11:52.660 --> 00:11:53.660
even record that.

00:11:53.660 --> 00:11:55.650
PAUL SAXMAN: Brendan, you've
reinvented the blink tag for

00:11:55.650 --> 00:11:55.970
Google Maps.

00:11:55.970 --> 00:11:56.400
BRENDAN KENNY: Exactly.

00:11:56.400 --> 00:11:58.550
For Maps.

00:11:58.550 --> 00:12:01.460
So if we refresh here, I can
show you a little bit.

00:12:01.460 --> 00:12:05.140
I can switch the mode so it's
actually drawing lines instead

00:12:05.140 --> 00:12:05.680
of polygons.

00:12:05.680 --> 00:12:10.200
So it doesn't draw all the
triangle lines, because I'd

00:12:10.200 --> 00:12:13.230
actually have to change the
triangles to do them

00:12:13.230 --> 00:12:13.680
differently.

00:12:13.680 --> 00:12:19.760
But if we zoom in on one of
these zip codes, we can see

00:12:19.760 --> 00:12:21.600
kind of what's going on.

00:12:21.600 --> 00:12:23.610
So it's not the prettiest
triangulation.

00:12:23.610 --> 00:12:28.710
It actually breaks things down
into these mono polygons,

00:12:28.710 --> 00:12:32.100
which are polygons
that are easily

00:12:32.100 --> 00:12:34.810
splittable with triangles.

00:12:34.810 --> 00:12:39.120
So you have some more modern
techniques involved like

00:12:39.120 --> 00:12:43.910
Delaunay triangulations where
you can get optimal angles

00:12:43.910 --> 00:12:47.670
where you maximize the size
of each triangle.

00:12:47.670 --> 00:12:51.290
But the nice thing about this
is that it's super stable.

00:12:51.290 --> 00:12:53.060
It's also well tested.

00:12:53.060 --> 00:12:57.100
It's 18-year-old code.

00:12:57.100 --> 00:13:00.590
And software projects will just
import it directly and

00:13:00.590 --> 00:13:03.450
not make any changes, because
they know that it's been so

00:13:03.450 --> 00:13:05.990
well time tested that
everything's stable.

00:13:05.990 --> 00:13:06.850
PAUL SAXMAN: And it works.

00:13:06.850 --> 00:13:07.230
BRENDAN KENNY: And it works.

00:13:07.230 --> 00:13:09.680
PAUL SAXMAN: I mean, you can get
60 frames per second out

00:13:09.680 --> 00:13:10.200
of this code.

00:13:10.200 --> 00:13:10.500
BRENDAN KENNY: Right.

00:13:10.500 --> 00:13:11.830
PAUL SAXMAN: Or your
tessellation, it looked like

00:13:11.830 --> 00:13:15.850
it took one second.

00:13:15.850 --> 00:13:16.340
BRENDAN KENNY: Less than
a second, yeah.

00:13:16.340 --> 00:13:20.500
800 milliseconds for about
890 triangles.

00:13:20.500 --> 00:13:23.340
890,000 triangles is what
you end up with.

00:13:23.340 --> 00:13:25.050
And it can be faster.

00:13:25.050 --> 00:13:27.690
When you profile it right now,
about 20% of the time is spent

00:13:27.690 --> 00:13:30.395
on garbage collection, which
we can eliminate.

00:13:30.395 --> 00:13:34.360
We have the technology, but that
will come in the future.

00:13:34.360 --> 00:13:35.390
So it's fast.

00:13:35.390 --> 00:13:39.030
And Delaunay triangulation is
not necessarily bounded except

00:13:39.030 --> 00:13:41.480
for if you make compromises.

00:13:41.480 --> 00:13:42.730
It's execution time.

00:13:45.480 --> 00:13:47.640
And for graphics, this
is usually fine.

00:13:47.640 --> 00:13:50.470
You can deal with these
skinny triangles and

00:13:50.470 --> 00:13:52.530
do per pixel effects.

00:13:52.530 --> 00:13:54.760
If you're doing a numerical
simulation where you're

00:13:54.760 --> 00:13:59.440
showing the spread of heat,
or I don't know, zombie

00:13:59.440 --> 00:14:02.480
infections or something, you
might run into some numerical

00:14:02.480 --> 00:14:03.600
problems with these
skinny triangles.

00:14:03.600 --> 00:14:04.870
But it's fine for
the most part.

00:14:04.870 --> 00:14:06.730
And you can tell it's
completely stable,

00:14:06.730 --> 00:14:07.740
even as we zoom in.

00:14:07.740 --> 00:14:09.610
Way in here, these things
share a border.

00:14:09.610 --> 00:14:14.910
And as a result, you can't see
any break between them.

00:14:14.910 --> 00:14:16.280
Stray pixels.

00:14:16.280 --> 00:14:18.730
So that's this.

00:14:18.730 --> 00:14:20.030
It's pretty exciting.

00:14:20.030 --> 00:14:21.280
It's pretty fast.

00:14:24.290 --> 00:14:26.540
PAUL SAXMAN: So what are some
applications of this?

00:14:26.540 --> 00:14:29.760
So you mentioned we can actually
get all the counties

00:14:29.760 --> 00:14:30.620
in California.

00:14:30.620 --> 00:14:31.640
BRENDAN KENNY: Right.

00:14:31.640 --> 00:14:33.390
PAUL SAXMAN: So what are some
other things you can do with

00:14:33.390 --> 00:14:34.470
this technique?

00:14:34.470 --> 00:14:37.760
BRENDAN KENNY: As I said, it
really comes down to we have

00:14:37.760 --> 00:14:40.770
geographic data that's in
polygons, and if we want to

00:14:40.770 --> 00:14:42.730
draw polygons, we need some
way to draw polygons.

00:14:42.730 --> 00:14:46.310
So anything you need to draw
a polygon for today

00:14:46.310 --> 00:14:48.850
you can with this.

00:14:48.850 --> 00:14:53.230
So that's not necessarily an
application in itself, but any

00:14:53.230 --> 00:14:55.000
reason that you need to.

00:14:55.000 --> 00:14:58.630
So an example would be if you
have effects per zip code.

00:14:58.630 --> 00:15:02.150
But if you imagine zip codes for
the entire United States,

00:15:02.150 --> 00:15:04.000
and you want to change that
per frame, there's nothing

00:15:04.000 --> 00:15:08.155
right now that you could
draw that in real time.

00:15:08.155 --> 00:15:09.360
You could draw it statically.

00:15:09.360 --> 00:15:13.490
You could draw its 2D canvas
and not change anything.

00:15:13.490 --> 00:15:15.470
But as soon as you pan or
zoom in, you'd have to

00:15:15.470 --> 00:15:17.075
redraw it all again.

00:15:17.075 --> 00:15:18.570
And that takes some time.

00:15:18.570 --> 00:15:21.980
And this would do it virtually
instantly.

00:15:21.980 --> 00:15:25.250
But then as soon as you want to
run effects across those,

00:15:25.250 --> 00:15:28.580
you wouldn't be able to do that
at 60 frames a second.

00:15:28.580 --> 00:15:32.490
PAUL SAXMAN: Can you do things
like for example, instead of

00:15:32.490 --> 00:15:34.960
filling the polygons, can we
actually just get the stroke

00:15:34.960 --> 00:15:36.170
and stroke the polygons?

00:15:36.170 --> 00:15:38.270
BRENDAN KENNY: Yeah, so you
can get that outer border.

00:15:38.270 --> 00:15:40.230
And the cool thing about that
is that you can actually

00:15:40.230 --> 00:15:45.220
adjust the winding order and
then do kind of shape algebra.

00:15:45.220 --> 00:15:48.090
So you could find the union
or the intersection

00:15:48.090 --> 00:15:49.460
of different polygons.

00:15:49.460 --> 00:15:51.630
And you can do that real time.

00:15:51.630 --> 00:15:59.160
And so if you wanted to do
something like take the area

00:15:59.160 --> 00:16:01.770
of some effect, like some
environmental thing, and then

00:16:01.770 --> 00:16:06.030
intersect it with zip code data
to find out exactly which

00:16:06.030 --> 00:16:08.180
zip codes are affected by
this, you could do that.

00:16:08.180 --> 00:16:11.860
And you could do that offline
or something already.

00:16:11.860 --> 00:16:14.070
But this let's you do it
in 60 frames a second.

00:16:14.070 --> 00:16:17.830
And as you move your blobby
thing around, you could find

00:16:17.830 --> 00:16:20.180
out that intersection.

00:16:20.180 --> 00:16:24.490
And also the great thing about
libtess is that it will take

00:16:24.490 --> 00:16:26.550
extremely degenerate polygons.

00:16:26.550 --> 00:16:28.540
It will take the nastiest
polygons you can throw at it.

00:16:28.540 --> 00:16:30.940
It'll take any winding
order that you want.

00:16:30.940 --> 00:16:34.270
So whether you want it to be
clockwise is inside and

00:16:34.270 --> 00:16:39.550
counterclockwise vertices is
outside, or the opposite, or

00:16:39.550 --> 00:16:42.260
you have two clockwise, but you
want to count one as the

00:16:42.260 --> 00:16:45.690
outside, you can just specify
that you want even winding

00:16:45.690 --> 00:16:49.050
orders to be outside
if you want.

00:16:49.050 --> 00:16:51.050
PAUL SAXMAN: It's really
friendly to kind of dirty

00:16:51.050 --> 00:16:52.020
geographic data--

00:16:52.020 --> 00:16:52.590
BRENDAN KENNY: Right.

00:16:52.590 --> 00:16:53.780
PAUL SAXMAN: --which
we regularly see.

00:16:53.780 --> 00:16:54.880
BRENDAN KENNY: Exactly,
which is actually

00:16:54.880 --> 00:16:56.840
most geographic data.

00:16:56.840 --> 00:16:59.070
And you don't necessarily have
time to sit there and say,

00:16:59.070 --> 00:17:02.380
well, they input this
data, but they

00:17:02.380 --> 00:17:03.780
probably meant this data.

00:17:03.780 --> 00:17:06.060
So do you mean fix
it this way?

00:17:06.060 --> 00:17:08.010
And instead it's like,
just draw something.

00:17:08.010 --> 00:17:11.020
And if it doesn't look
reasonable, then you say, OK,

00:17:11.020 --> 00:17:12.859
let's fix your data.

00:17:12.859 --> 00:17:14.619
You don't want to sit there and
say, well I can draw it

00:17:14.619 --> 00:17:17.510
for you as soon as you
have reasonable data.

00:17:17.510 --> 00:17:22.630
So here's the example that I'm
going to be including with

00:17:22.630 --> 00:17:24.750
libtess in the repository.

00:17:24.750 --> 00:17:27.520
And this is just a simple
triangulation.

00:17:27.520 --> 00:17:31.530
And all I'm doing is kind of
making a circle and then just

00:17:31.530 --> 00:17:34.980
adding a random radius
to each point as I

00:17:34.980 --> 00:17:36.560
go around the circle.

00:17:36.560 --> 00:17:38.920
Just to give you an idea.

00:17:38.920 --> 00:17:46.240
So we can look at the actual
code that does this.

00:17:46.240 --> 00:17:52.060
And as I said, it's kind
of nasty C-like code.

00:17:52.060 --> 00:17:57.550
It's very flat and there's no
real object hierarchy you have

00:17:57.550 --> 00:17:58.270
to worry about.

00:17:58.270 --> 00:18:00.810
But on the other hand, it's very
verbose, and you think

00:18:00.810 --> 00:18:03.510
about all the different
properties you have to set.

00:18:03.510 --> 00:18:05.930
So here's the triangulate
function if we

00:18:05.930 --> 00:18:09.690
look here in Dev Tools.

00:18:09.690 --> 00:18:11.880
And you can ignore this.

00:18:11.880 --> 00:18:14.970
The triangulation actually
supports triangulation in 3D.

00:18:14.970 --> 00:18:18.290
So you can actually do an X,Y,Z.
But we just set zero

00:18:18.290 --> 00:18:20.880
for all our z-coordinates.

00:18:20.880 --> 00:18:23.240
And so I have this--

00:18:23.240 --> 00:18:28.460
I call it Tessy-- but it's the
tessellation object that you

00:18:28.460 --> 00:18:32.220
just call the new GLU
tessellator And when you're

00:18:32.220 --> 00:18:34.900
ready to start, you say,
begin polygon.

00:18:34.900 --> 00:18:39.060
And you posit the array that
you want to put your final

00:18:39.060 --> 00:18:40.800
vertices into.

00:18:40.800 --> 00:18:43.390
You loop over contours,
it's called.

00:18:43.390 --> 00:18:44.550
Sometimes they're
called rings.

00:18:44.550 --> 00:18:47.380
Sometimes they're called
faces, even.

00:18:47.380 --> 00:18:52.520
And that's each ring
of vertices that

00:18:52.520 --> 00:18:53.730
make up your polygon.

00:18:53.730 --> 00:18:58.930
So a polygon can be made up of
multiple rings or contours.

00:18:58.930 --> 00:19:01.290
And they could be both additive,
so that they

00:19:01.290 --> 00:19:04.450
actually add area
to your polygon.

00:19:04.450 --> 00:19:06.970
And they can be subtractive, so
they actually take away and

00:19:06.970 --> 00:19:09.810
make holes in the polygon.

00:19:09.810 --> 00:19:12.200
And so we just loop
over our contours.

00:19:12.200 --> 00:19:13.530
And so for each--

00:19:13.530 --> 00:19:16.020
we have begin polygon
on the outside.

00:19:16.020 --> 00:19:19.480
Inside of that, we have begin
contour and in contour.

00:19:19.480 --> 00:19:22.490
And you have as many of those
as you have contours.

00:19:22.490 --> 00:19:26.870
And then within that,
you have vertices.

00:19:26.870 --> 00:19:30.370
You set each vertex,
one at a time.

00:19:30.370 --> 00:19:33.220
For each contour,
I begin contour.

00:19:33.220 --> 00:19:37.770
And for each contour, I then
loop over vertices.

00:19:37.770 --> 00:19:41.770
And for each vertex, I
then add that vertex.

00:19:41.770 --> 00:19:45.130
And then finally, we
say, end polygon.

00:19:45.130 --> 00:19:48.060
And that's when it actually does
it it's calculation and

00:19:48.060 --> 00:19:50.010
spits out your triangles.

00:19:50.010 --> 00:19:52.230
So here I'm just getting
the triangles directly.

00:19:52.230 --> 00:19:54.490
But there's a lot of things you
can do with things like,

00:19:54.490 --> 00:19:56.300
just give me the
outside border.

00:19:56.300 --> 00:20:00.665
Or it can actually split it
up into triangle fans and

00:20:00.665 --> 00:20:03.380
triangle strips, if that's
more efficient

00:20:03.380 --> 00:20:04.810
for your use case.

00:20:04.810 --> 00:20:08.710
And there's a couple different
things it can do.

00:20:08.710 --> 00:20:11.210
And then you can do crazy things
like get the outside

00:20:11.210 --> 00:20:14.070
border, and then run it
through it again and

00:20:14.070 --> 00:20:18.110
triangulate the outside border
so that you're not ignoring

00:20:18.110 --> 00:20:21.450
all the internal lines
that you might have

00:20:21.450 --> 00:20:22.680
had to generate triangles.

00:20:22.680 --> 00:20:25.300
Whereas by default, it will
actually generate triangles

00:20:25.300 --> 00:20:26.410
within those.

00:20:26.410 --> 00:20:27.980
PAUL SAXMAN: And all these
functions are built into

00:20:27.980 --> 00:20:28.380
libtess, right?

00:20:28.380 --> 00:20:29.660
BRENDAN KENNY: Yeah,
it's all built in.

00:20:29.660 --> 00:20:30.090
Yeah.

00:20:30.090 --> 00:20:33.260
PAUL SAXMAN: So we have some
kind of documentation on

00:20:33.260 --> 00:20:33.570
[INAUDIBLE]

00:20:33.570 --> 00:20:34.070
BRENDAN KENNY: Yeah.

00:20:34.070 --> 00:20:35.570
So it's all documented.

00:20:35.570 --> 00:20:37.790
It's closure style docs,
so it's even

00:20:37.790 --> 00:20:40.680
typed, if you want that.

00:20:40.680 --> 00:20:41.370
You don't have to use it.

00:20:41.370 --> 00:20:42.025
It's not enforced.

00:20:42.025 --> 00:20:44.070
It's just enforced by the
Closure Compiler.

00:20:44.070 --> 00:20:46.400
But the nice thing about that
is that it can compile down

00:20:46.400 --> 00:20:47.510
and eliminate dead code.

00:20:47.510 --> 00:20:51.220
And I think it's about
7K with gzip.

00:20:51.220 --> 00:20:54.210
So it's pretty small when
you get down to it.

00:20:54.210 --> 00:21:00.310
So finally, this array that I
passed to the tessellator in

00:21:00.310 --> 00:21:02.790
the beginning is now full
of my triangles.

00:21:02.790 --> 00:21:05.250
And now I do my normal
WebGL stuff, which

00:21:05.250 --> 00:21:06.250
you can look up elsewhere.

00:21:06.250 --> 00:21:07.430
But you could use 3GS.

00:21:07.430 --> 00:21:09.560
You could use any library
you want.

00:21:09.560 --> 00:21:12.520
Or you could use plain WebGL,
which is what I used in this

00:21:12.520 --> 00:21:16.480
example, to create an array
buffer, pass it to your GPU,

00:21:16.480 --> 00:21:17.810
and then say, draw it.

00:21:17.810 --> 00:21:25.370
So you can see here in
this example that I'm

00:21:25.370 --> 00:21:26.120
drawing this polygon.

00:21:26.120 --> 00:21:29.315
And every time I refresh, it
adds different randomness.

00:21:29.315 --> 00:21:33.160
And so this takes about nine
milliseconds to tessellate.

00:21:33.160 --> 00:21:34.770
But that's actually misleading,
because that's

00:21:34.770 --> 00:21:42.590
before the v8 has had time you
to profile itself and then run

00:21:42.590 --> 00:21:43.910
Crankshaft to optimize
your code.

00:21:43.910 --> 00:21:48.640
So this gets down to less than
a millisecond, usually, when

00:21:48.640 --> 00:21:50.955
you run it through a
couple of times.

00:21:50.955 --> 00:21:53.420
And now, actually, I can do the
same thing and set fill

00:21:53.420 --> 00:21:56.853
mode equal to false, and
schedule an update.

00:21:59.980 --> 00:22:02.490
And you can see, once again,
the lines that are drawing

00:22:02.490 --> 00:22:04.810
here, which is exciting.

00:22:04.810 --> 00:22:07.660
So what I do here is I just
generate a circle.

00:22:07.660 --> 00:22:10.380
But let's say I wanted to add
another circle to make a

00:22:10.380 --> 00:22:12.730
doughnut, as you said.

00:22:12.730 --> 00:22:16.180
So I can go back to my code
and [? uncomment ?] this.

00:22:16.180 --> 00:22:18.440
So this just makes
another contour.

00:22:18.440 --> 00:22:19.920
So I have an array
of contours.

00:22:19.920 --> 00:22:21.720
This makes another
contour with a

00:22:21.720 --> 00:22:23.860
slightly smaller radius.

00:22:23.860 --> 00:22:29.300
And I said a counterclockwise
flag here, so the internal

00:22:29.300 --> 00:22:33.720
one, the slightly smaller
loop, will be clockwise.

00:22:33.720 --> 00:22:34.990
So it's opposite.

00:22:34.990 --> 00:22:41.560
So now if I go back to Chrome
and I refresh, I now have a

00:22:41.560 --> 00:22:44.870
nice thing here, which
is very exciting.

00:22:44.870 --> 00:22:46.070
PAUL SAXMAN: Can we see
what the polygon--

00:22:46.070 --> 00:22:46.410
BRENDAN KENNY: Sure.

00:22:46.410 --> 00:22:47.440
PAUL SAXMAN: --or triangles
look like?

00:22:47.440 --> 00:22:48.880
BRENDAN KENNY: So it's a little
confusing because it's

00:22:48.880 --> 00:22:52.430
drawing these lines which
aren't actually there.

00:22:52.430 --> 00:22:54.450
Because they are individual
triangles, if the next

00:22:54.450 --> 00:22:57.995
triangle is way across the
polygon, it will actually draw

00:22:57.995 --> 00:22:58.860
a connecting line.

00:22:58.860 --> 00:23:02.280
But it's enough to give you an
idea of what it's doing.

00:23:02.280 --> 00:23:05.330
It will actually create the
two borders and then find

00:23:05.330 --> 00:23:09.680
those polygons that it can
easily triangulate first.

00:23:09.680 --> 00:23:14.070
Not quite [? greedy, ?] but not
that far off, to find what

00:23:14.070 --> 00:23:16.350
it can tessellate.

00:23:16.350 --> 00:23:17.050
So, yeah.

00:23:17.050 --> 00:23:18.010
So there you go.

00:23:18.010 --> 00:23:19.850
PAUL SAXMAN: And as a developer,
you're not that

00:23:19.850 --> 00:23:21.030
worried about the lines.

00:23:21.030 --> 00:23:22.900
I mean, once it's tessellated,
you're

00:23:22.900 --> 00:23:23.920
not working in triangles.

00:23:23.920 --> 00:23:24.700
BRENDAN KENNY: Right, right.

00:23:24.700 --> 00:23:26.160
PAUL SAXMAN: You're still just
working in polygons.

00:23:26.160 --> 00:23:26.510
BRENDAN KENNY: Right.

00:23:26.510 --> 00:23:28.060
PAUL SAXMAN: And you take the
vertices out, if you need to.

00:23:28.060 --> 00:23:28.800
BRENDAN KENNY: It's more
WebGL that needs

00:23:28.800 --> 00:23:29.520
to worry about that.

00:23:29.520 --> 00:23:31.420
But it interpolates it
across correctly.

00:23:31.420 --> 00:23:34.340
And as you can see, there's no
there's no visible artifacts.

00:23:34.340 --> 00:23:37.200
And as we refresh, we can
see the nice dance of.

00:23:37.200 --> 00:23:40.030
And so this scales
fairly well.

00:23:40.030 --> 00:23:43.376
If we go back here,
we can say--

00:23:43.376 --> 00:23:44.280
PAUL SAXMAN: Quick question.

00:23:44.280 --> 00:23:47.600
Are all the vertices part of
your original polygon?

00:23:47.600 --> 00:23:50.320
So the tessellation library
doesn't create vertices?

00:23:50.320 --> 00:23:51.802
Is that true?

00:23:51.802 --> 00:23:52.740
BRENDAN KENNY: Let's see.

00:23:52.740 --> 00:23:54.720
Is that correct?

00:23:54.720 --> 00:23:57.870
Yes, except intersections.

00:23:57.870 --> 00:24:01.870
So where lines intersect, it
will split both lines and

00:24:01.870 --> 00:24:06.560
insert a new vertex
between those.

00:24:06.560 --> 00:24:10.260
Now the two line segments become
four line segments.

00:24:10.260 --> 00:24:13.380
So yes, other than that, it
won't create any new vertices.

00:24:13.380 --> 00:24:16.220
Which is part of the problem
with some of those uglier

00:24:16.220 --> 00:24:19.970
tessellations is that really
what you want to do is create

00:24:19.970 --> 00:24:22.350
internal vertices and
use those to kind of

00:24:22.350 --> 00:24:23.620
split up the space.

00:24:23.620 --> 00:24:27.500
But that becomes a much
different problem, because

00:24:27.500 --> 00:24:30.220
then you're minimizing energies
rather than just

00:24:30.220 --> 00:24:35.750
doing kind of more deterministic
working through

00:24:35.750 --> 00:24:37.250
your vertices.

00:24:37.250 --> 00:24:41.230
So just to show that this is
very possible, we can scale

00:24:41.230 --> 00:24:44.050
this up to like 5,000 vertices,
because why not?

00:24:44.050 --> 00:24:49.995
And suddenly we get kind of this
insane fuzzy thing here.

00:24:52.700 --> 00:24:53.560
PAUL SAXMAN: Which
is just because

00:24:53.560 --> 00:24:54.860
you're scaling the radius.

00:24:54.860 --> 00:24:58.170
BRENDAN KENNY: Yeah, so
the radius is a random

00:24:58.170 --> 00:25:00.790
0.1, plus or minus.

00:25:00.790 --> 00:25:03.020
And so you get kind of
this really fuzzy--

00:25:03.020 --> 00:25:03.460
whoa.

00:25:03.460 --> 00:25:06.100
I don't know what
happened there.

00:25:06.100 --> 00:25:10.010
And it's actually somewhat
difficult for the tessellator,

00:25:10.010 --> 00:25:13.590
because when they're so close,
they might be intersecting.

00:25:13.590 --> 00:25:15.040
And so it has to check.

00:25:15.040 --> 00:25:18.870
Every time you get a new one, it
actually has to check from

00:25:18.870 --> 00:25:20.160
either side if it's
intersecting.

00:25:20.160 --> 00:25:24.610
And it's a sweep line method.

00:25:24.610 --> 00:25:27.980
And so anyway, the point though
is that it can handle

00:25:27.980 --> 00:25:31.590
this quite rapidly without
any issue.

00:25:31.590 --> 00:25:38.830
And if we do this again, we can
see that the lines become

00:25:38.830 --> 00:25:43.090
almost as complicated as the
filled version, to the point

00:25:43.090 --> 00:25:46.830
where it's no longer a
useful visualization.

00:25:46.830 --> 00:25:47.420
So that's it.

00:25:47.420 --> 00:25:50.580
I'm going to put this
example up.

00:25:50.580 --> 00:25:54.730
And so that should make the
library a little bit clearer.

00:25:54.730 --> 00:25:56.770
And then look for some
interesting applications of

00:25:56.770 --> 00:25:59.230
this in the near future.

00:25:59.230 --> 00:26:01.600
But I just wanted to get this
out there and get people

00:26:01.600 --> 00:26:04.220
introduced to it.

00:26:04.220 --> 00:26:08.260
And if you have any issues, if
you have any suggestions about

00:26:08.260 --> 00:26:10.930
the JavaScript interface, if you
have things that you wish

00:26:10.930 --> 00:26:13.420
that it could do but it
can't, let me know.

00:26:13.420 --> 00:26:14.975
I'm going to work on
performance and

00:26:14.975 --> 00:26:16.270
the JavaScript interface.

00:26:16.270 --> 00:26:21.080
And yeah, that's what's
coming up.

00:26:21.080 --> 00:26:21.690
PAUL SAXMAN: Cool.

00:26:21.690 --> 00:26:22.210
All right.

00:26:22.210 --> 00:26:22.890
Well, thanks a lot.

00:26:22.890 --> 00:26:25.110
So thank you everybody
for joining us today.

00:26:25.110 --> 00:26:28.540
Again, if you want to find the
code, GitHub, search for

00:26:28.540 --> 00:26:30.060
libtess.js.

00:26:30.060 --> 00:26:30.370
BRENDAN KENNY: Dot js.

00:26:30.370 --> 00:26:33.830
So there's a lot of libtess's
and libtess2, but they'll be

00:26:33.830 --> 00:26:37.040
C. So you want to
look for dot js.

00:26:37.040 --> 00:26:39.000
PAUL SAXMAN: And the
example's coming.

00:26:39.000 --> 00:26:41.720
And if you guys have any
questions, comments, put them

00:26:41.720 --> 00:26:44.450
in the comment section of
YouTube, and we'll get back to

00:26:44.450 --> 00:26:46.410
you as quickly as we can.

00:26:46.410 --> 00:26:48.470
So thanks again, and
see you next week.

00:26:59.870 --> 00:27:12.800
[MUSIC PLAYING]

