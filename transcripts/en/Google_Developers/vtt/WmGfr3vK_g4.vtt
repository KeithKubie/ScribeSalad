WEBVTT
Kind: captions
Language: en

00:00:08.124 --> 00:00:09.290
DAN GALPIN: Can you hear me?

00:00:09.290 --> 00:00:09.950
All right.

00:00:09.950 --> 00:00:12.470
I'm Dan Galpin,
and Lisa Wray and I

00:00:12.470 --> 00:00:14.990
will be giving you a tour of
the highlights of the latest

00:00:14.990 --> 00:00:17.330
platform and support
library updates.

00:00:17.330 --> 00:00:19.550
And we've got so much
to cover, so I'm just

00:00:19.550 --> 00:00:21.300
going to jump right into it.

00:00:21.300 --> 00:00:23.030
So one of the biggest
changes to know

00:00:23.030 --> 00:00:25.899
is we added adaptive
launcher icons.

00:00:25.899 --> 00:00:27.440
And this is a big
deal because if you

00:00:27.440 --> 00:00:29.710
have any of these phones
from these lovely OEMs,

00:00:29.710 --> 00:00:32.720
you saw they are using their
own custom launchers with custom

00:00:32.720 --> 00:00:33.650
icon shapes.

00:00:33.650 --> 00:00:37.940
And Android icons, shapes
and sizes are all random.

00:00:37.940 --> 00:00:40.610
And so what they would do, like
with Chrome and the Play Store

00:00:40.610 --> 00:00:42.620
here, they would
shrink the icon,

00:00:42.620 --> 00:00:45.690
and stamp on it a random color
or shape that they choose.

00:00:45.690 --> 00:00:48.380
And we thought, you know, we can
do something better for this.

00:00:48.380 --> 00:00:51.980
So what we did is we
created adaptive icons.

00:00:51.980 --> 00:00:53.720
And to enable this
kind of customization,

00:00:53.720 --> 00:00:56.450
your app provides
icons in two layers--

00:00:56.450 --> 00:00:57.800
background and foreground.

00:00:57.800 --> 00:01:01.550
So if the OEM defines a
rounded rectangle mask shape,

00:01:01.550 --> 00:01:03.500
the user will see this.

00:01:03.500 --> 00:01:05.330
And if they define
a circular shape,

00:01:05.330 --> 00:01:07.082
it's going to look like this.

00:01:07.082 --> 00:01:07.790
And this is cool.

00:01:07.790 --> 00:01:09.830
And this goes every
single way or place

00:01:09.830 --> 00:01:12.590
your icon appears in the system
UI, such as inside the setting

00:01:12.590 --> 00:01:15.080
app list, the recents
or overview title bar,

00:01:15.080 --> 00:01:17.180
and your shared sheet dialog.

00:01:17.180 --> 00:01:20.300
So to support wider
ranges of icon sizes,

00:01:20.300 --> 00:01:22.250
because not every
launcher makes the icons

00:01:22.250 --> 00:01:24.980
the same size, as you've
also probably noticed,

00:01:24.980 --> 00:01:27.390
bigger than 48 DP,
we now recommend

00:01:27.390 --> 00:01:31.550
that apps contain an icon
asset of at least 72 DP in size

00:01:31.550 --> 00:01:32.900
with a visible area.

00:01:32.900 --> 00:01:34.760
Sort if an OEM or
third party launcher

00:01:34.760 --> 00:01:38.880
wants to render icons in 60 DP,
it will not be super sampled.

00:01:38.880 --> 00:01:41.660
Now, the actual size of this
foreground and background

00:01:41.660 --> 00:01:45.747
layer that we want to
update to is 108 DP.

00:01:45.747 --> 00:01:48.080
And we recommend that both
the foreground and background

00:01:48.080 --> 00:01:51.230
layers are actually padded
with 25% of the extra image

00:01:51.230 --> 00:01:52.275
around each side.

00:01:52.275 --> 00:01:53.900
And the reason we do
this is because we

00:01:53.900 --> 00:01:57.860
want to use it to add delightful
animations such as parallax

00:01:57.860 --> 00:01:58.820
and pulsing.

00:01:58.820 --> 00:01:59.990
And this is just an example.

00:01:59.990 --> 00:02:02.510
No, we haven't actually added
this to a shipping launcher,

00:02:02.510 --> 00:02:04.670
but someday we might.

00:02:04.670 --> 00:02:06.230
So you can now
control how your brand

00:02:06.230 --> 00:02:08.660
is going to look no
matter what icon shape

00:02:08.660 --> 00:02:11.249
your OEM chooses
while integrating well

00:02:11.249 --> 00:02:12.290
into their visual design.

00:02:12.290 --> 00:02:13.877
This is actually important.

00:02:13.877 --> 00:02:14.960
So here's what we've done.

00:02:14.960 --> 00:02:17.630
We've added this adaptive
icon drawable class to Oreo,

00:02:17.630 --> 00:02:20.420
and it supports the foreground
and a background inner tag

00:02:20.420 --> 00:02:22.790
that supports one
drawable attribute.

00:02:22.790 --> 00:02:25.100
And also as a [INAUDIBLE]
to help us out,

00:02:25.100 --> 00:02:29.700
we added this
fractional inset value.

00:02:29.700 --> 00:02:32.900
And this means your insight can
now be density invariant, which

00:02:32.900 --> 00:02:34.740
is really, really cool.

00:02:34.740 --> 00:02:39.300
So as it turns out,
18 over 8 is 16%.

00:02:39.300 --> 00:02:43.120
So if you use this value to pad
your 72 DP launcher icon there

00:02:43.120 --> 00:02:46.340
will be no APK size increase
from a non-adaptive icon that's

00:02:46.340 --> 00:02:47.480
big enough.

00:02:47.480 --> 00:02:49.590
But better yet, the
really cool thing

00:02:49.590 --> 00:02:51.630
is that because these
are only used in O,

00:02:51.630 --> 00:02:56.270
in Android N the vector drawable
became expressive enough

00:02:56.270 --> 00:02:59.330
to support most
of the SVG format.

00:02:59.330 --> 00:03:02.370
So you can actually
now make vector icons,

00:03:02.370 --> 00:03:04.980
which is really cool.

00:03:04.980 --> 00:03:08.060
So once again, O made a
bunch of critical changes

00:03:08.060 --> 00:03:08.989
to other areas, too.

00:03:08.989 --> 00:03:11.030
Not just adaptive icons,
we made critical changes

00:03:11.030 --> 00:03:12.069
to notifications.

00:03:12.069 --> 00:03:13.610
Now, in previous
releases of Android,

00:03:13.610 --> 00:03:16.120
the user could only block all
the notifications for an app

00:03:16.120 --> 00:03:17.680
for sending a
spammy notification.

00:03:17.680 --> 00:03:19.430
But in Android O, of
course, we introduced

00:03:19.430 --> 00:03:21.620
notification channels,
which are named categories

00:03:21.620 --> 00:03:24.440
of notifications that share
the same behavior so users

00:03:24.440 --> 00:03:25.910
can control them.

00:03:25.910 --> 00:03:29.180
And the user can also click
here to see all the categories.

00:03:29.180 --> 00:03:32.420
And clicking on the category
reveals per-category things

00:03:32.420 --> 00:03:34.760
like vibration and
sound, et cetera.

00:03:34.760 --> 00:03:36.360
And of course we
also added these dots

00:03:36.360 --> 00:03:38.151
in the launcher, which
are a low-stress way

00:03:38.151 --> 00:03:39.780
to see if apps
have notifications.

00:03:39.780 --> 00:03:41.780
I don't have to look how
many numbers there are.

00:03:41.780 --> 00:03:45.140
Long pressing the icon also
reveals the notification.

00:03:45.140 --> 00:03:47.177
And widgets can also
really be installed easily

00:03:47.177 --> 00:03:49.010
in this way, which is
so cool because people

00:03:49.010 --> 00:03:53.125
don't have to stress and
figure out how to install them.

00:03:53.125 --> 00:03:54.500
All right, and
all the stuff used

00:03:54.500 --> 00:03:56.360
to customize per
notifications now

00:03:56.360 --> 00:03:57.727
applies to the whole channel.

00:03:57.727 --> 00:03:58.560
This is pretty cool.

00:03:58.560 --> 00:04:01.880
You can set all this
stuff on a channel.

00:04:01.880 --> 00:04:03.740
OK, I do have a bullet
point slide here.

00:04:03.740 --> 00:04:04.550
I'm sorry.

00:04:04.550 --> 00:04:08.120
But seriously, don't overwhelm
your users with channels.

00:04:08.120 --> 00:04:10.550
Make the distinctions
between them make sense.

00:04:10.550 --> 00:04:11.900
Give them reasonable defaults.

00:04:11.900 --> 00:04:14.300
And of course, you can
use notification compact

00:04:14.300 --> 00:04:15.839
to set channel information.

00:04:15.839 --> 00:04:17.630
And remember that if
you don't use channels

00:04:17.630 --> 00:04:20.360
and you're targeting
Oreo, your notifications

00:04:20.360 --> 00:04:22.130
aren't going to show up.

00:04:22.130 --> 00:04:25.040
All right, let's talk about
shortcuts and app widgets.

00:04:25.040 --> 00:04:28.880
So way back in
Android 7.1 we added

00:04:28.880 --> 00:04:30.710
these nifty launcher shortcuts.

00:04:30.710 --> 00:04:33.380
And users can drag them and
pin them to the launcher.

00:04:33.380 --> 00:04:36.057
An app could request that
a shortcut gets pinned,

00:04:36.057 --> 00:04:37.640
but there was no
indication to the app

00:04:37.640 --> 00:04:39.814
that it actually
worked, and the user

00:04:39.814 --> 00:04:42.230
wasn't notified that it was
happening, which wasn't really

00:04:42.230 --> 00:04:44.150
great for users or developers.

00:04:44.150 --> 00:04:47.300
And it doesn't work anymore
if you're targeting O.

00:04:47.300 --> 00:04:51.380
So we now have the new
way with Shortcut Manager.

00:04:51.380 --> 00:04:52.640
And it has an API.

00:04:52.640 --> 00:04:56.420
And it takes the same shortcut
info as we used in Android 7.1,

00:04:56.420 --> 00:04:58.130
but the launcher
will now ask the user

00:04:58.130 --> 00:05:00.830
whether to add the shortcut
and where to place it.

00:05:00.830 --> 00:05:02.960
So the app can now adapt
to-- and the app also

00:05:02.960 --> 00:05:06.170
has the ability to actually
update the shortcut icon later,

00:05:06.170 --> 00:05:07.900
as well, with this.

00:05:07.900 --> 00:05:11.210
And custom shortcuts
are also in 7.1.

00:05:11.210 --> 00:05:13.540
It allowed shortcuts to be
added from the widget tray

00:05:13.540 --> 00:05:15.190
with an optional
configuration screen.

00:05:15.190 --> 00:05:17.950
And the Oreo API is an
improvement there, as well.

00:05:17.950 --> 00:05:21.180
As before, you register the
custom shortcut activity

00:05:21.180 --> 00:05:23.470
with the Create
Shortcut Intent folder.

00:05:23.470 --> 00:05:26.770
And in 7.1 it would return
the shortcut as intent extras

00:05:26.770 --> 00:05:29.740
directly to the activity
return, which is OK.

00:05:29.740 --> 00:05:31.720
But now we wrap all
of that functionality,

00:05:31.720 --> 00:05:34.230
which also allows the app
to update the shortcut.

00:05:34.230 --> 00:05:36.950
So again, just making
the launch better.

00:05:36.950 --> 00:05:40.990
And this has been a
really long time coming.

00:05:40.990 --> 00:05:43.810
But we actually
have a way for you

00:05:43.810 --> 00:05:47.910
to surface your app
widgets in your app.

00:05:47.910 --> 00:05:49.405
You no longer have
to beg the user

00:05:49.405 --> 00:05:50.530
to find it in the launcher.

00:05:50.530 --> 00:05:52.480
You can say, hey, I've
got an app widget,

00:05:52.480 --> 00:05:54.140
please install it
on your behalf.

00:05:54.140 --> 00:05:55.975
And they get prompted, and they
get added to the home screen,

00:05:55.975 --> 00:05:57.070
and it's just awesome.

00:05:57.070 --> 00:05:58.990
I can't believe it
took us this long.

00:05:58.990 --> 00:06:01.547
All right, let's
talk about Autofill.

00:06:01.547 --> 00:06:03.880
All right, so apps that use
standard views automatically

00:06:03.880 --> 00:06:04.799
work with Autofill.

00:06:04.799 --> 00:06:07.090
But you can help it do a
better job by providing hints,

00:06:07.090 --> 00:06:08.890
like postal address.

00:06:08.890 --> 00:06:11.530
You could also mark fields
that Autofill should ignore.

00:06:14.565 --> 00:06:15.940
You can integrate
it more deeply.

00:06:15.940 --> 00:06:19.270
So you can actually request
Autofill in your app.

00:06:19.270 --> 00:06:22.000
And you can use Autofill
on completely custom views

00:06:22.000 --> 00:06:25.170
such as those are drawn
with OpenGL or Vulcan

00:06:25.170 --> 00:06:27.527
by providing an Autofill
virtual structure.

00:06:27.527 --> 00:06:29.110
And no matter how
you build your apps,

00:06:29.110 --> 00:06:31.380
you should really
consider doing this.

00:06:31.380 --> 00:06:33.320
And this is kind of cool.

00:06:33.320 --> 00:06:36.160
You have a website, the
Google Autofill provider

00:06:36.160 --> 00:06:38.740
can actually share
credential information

00:06:38.740 --> 00:06:41.650
between your web and your app
if you create a digital asset

00:06:41.650 --> 00:06:42.340
link.

00:06:42.340 --> 00:06:44.170
And this is pretty
straightforward.

00:06:44.170 --> 00:06:47.220
You've got to put something on
your server, some JSON here,

00:06:47.220 --> 00:06:49.720
which allows you to define that
you want to share your login

00:06:49.720 --> 00:06:52.000
credentials between your
website and your app.

00:06:52.000 --> 00:06:54.850
And then you go and
modify your manifest

00:06:54.850 --> 00:06:57.910
with this string that points
to a similar JSON resource that

00:06:57.910 --> 00:07:00.670
contains a list of web
targets and permissions

00:07:00.670 --> 00:07:03.130
just like what you've
hosted on your website.

00:07:03.130 --> 00:07:03.730
And that's it.

00:07:03.730 --> 00:07:05.646
With these two steps you
can share credentials

00:07:05.646 --> 00:07:06.670
between your website.

00:07:06.670 --> 00:07:09.070
And this works for Autofill,
and it's also the first step

00:07:09.070 --> 00:07:11.434
in implementing Smart Lock.

00:07:11.434 --> 00:07:12.850
So you might want
to do that also,

00:07:12.850 --> 00:07:14.830
which this lets your users
automatically sign in.

00:07:14.830 --> 00:07:16.480
But if you don't want to go
all the way to Smart Lock,

00:07:16.480 --> 00:07:19.240
this is a really cool way of
leveraging that credential

00:07:19.240 --> 00:07:21.950
information between your
mobile app and your website.

00:07:21.950 --> 00:07:23.270
Some other O stuff.

00:07:23.270 --> 00:07:25.960
We added a whole bunch more
cool StrictMode behavior,

00:07:25.960 --> 00:07:26.870
which is great.

00:07:26.870 --> 00:07:30.190
We now actually-- this is great
for finding bad app behaviors.

00:07:30.190 --> 00:07:33.010
We can detect unbuffered
I/O with thread policy,

00:07:33.010 --> 00:07:37.150
and VM policy allows you
to detect untagged sockets,

00:07:37.150 --> 00:07:39.970
as well as when a content URI
is sent that doesn't grant

00:07:39.970 --> 00:07:42.460
the calling app read or write
permission, because it's not

00:07:42.460 --> 00:07:43.790
very useful to have a call--

00:07:43.790 --> 00:07:44.290
yeah.

00:07:44.290 --> 00:07:46.180
And we've also added
seekable file descriptors

00:07:46.180 --> 00:07:47.638
from document
providers, so you can

00:07:47.638 --> 00:07:50.050
use this for large remote
sources such as big audio

00:07:50.050 --> 00:07:51.880
and video files.

00:07:51.880 --> 00:07:55.450
OK, another thing we did is we
actually added proper support

00:07:55.450 --> 00:07:56.800
for caching.

00:07:56.800 --> 00:07:59.710
So the quota here can change
depending how frequently

00:07:59.710 --> 00:08:04.240
the user actually
interacts with your app

00:08:04.240 --> 00:08:07.270
and the amount used while
the allocate actually takes

00:08:07.270 --> 00:08:09.730
deletable cache into account.

00:08:09.730 --> 00:08:11.020
So pretty slick.

00:08:11.020 --> 00:08:12.580
And there's tons
of more stuff in O,

00:08:12.580 --> 00:08:13.840
I'm not going to go
through it all here.

00:08:13.840 --> 00:08:15.680
Most of you have seen
a lot of this stuff.

00:08:15.680 --> 00:08:17.530
But we have enhancements
to accessibility,

00:08:17.530 --> 00:08:20.222
including the ability for users
to add an accessibility button

00:08:20.222 --> 00:08:22.180
on devices that have soft
navigation, something

00:08:22.180 --> 00:08:23.500
else for that bar.

00:08:23.500 --> 00:08:25.470
Paging and content providers.

00:08:25.470 --> 00:08:27.220
A bunch of great stuff
to make the runtime

00:08:27.220 --> 00:08:29.636
faster as I mentioned before,
such as a concurrent copying

00:08:29.636 --> 00:08:32.500
collector and a whole
bunch of changes in media.

00:08:32.500 --> 00:08:34.730
All right, but let's get
into the support library.

00:08:34.730 --> 00:08:37.271
So you know what I'm going to
say here, which is devices that

00:08:37.271 --> 00:08:40.539
are running SDKs less than
14 comprise less than 1%

00:08:40.539 --> 00:08:41.950
of the Play Store active users.

00:08:41.950 --> 00:08:44.033
So we've updated the support
libraries [INAUDIBLE]

00:08:44.033 --> 00:08:44.810
SDK level.

00:08:44.810 --> 00:08:47.309
And as you might have guessed,
we got rid of these two guys.

00:08:47.309 --> 00:08:49.300
We'll be focusing
on the SDK versions

00:08:49.300 --> 00:08:51.370
that most developers
are actually targeting.

00:08:51.370 --> 00:08:53.380
So the minimum
version is now 14,

00:08:53.380 --> 00:08:55.520
and Google Play services
also recently dropped

00:08:55.520 --> 00:08:57.294
that support in version 10.2.

00:08:57.294 --> 00:08:59.710
However, you can still use an
older version of the support

00:08:59.710 --> 00:09:01.600
library if you
really, really want

00:09:01.600 --> 00:09:03.930
to still target
gingerbread [INAUDIBLE]..

00:09:03.930 --> 00:09:07.360
And dropping API 14 gives
us a bunch of benefits.

00:09:07.360 --> 00:09:09.130
Removed over 1,400 methods.

00:09:09.130 --> 00:09:12.110
And remember, we still have
a 65k method, [? decs ?]

00:09:12.110 --> 00:09:14.560
limit on API is less than 21.

00:09:14.560 --> 00:09:18.010
And there's more to
go in later versions.

00:09:18.010 --> 00:09:22.390
Our public API surface reduced
by 30 classes for 100 methods.

00:09:22.390 --> 00:09:25.090
And what we need to do
now is you can still

00:09:25.090 --> 00:09:26.740
use a lot of these
things as they are,

00:09:26.740 --> 00:09:28.000
but you should start
actually getting

00:09:28.000 --> 00:09:30.083
rid of the deprecated stuff
because we're actually

00:09:30.083 --> 00:09:33.460
going to get rid of it to
even make things smaller.

00:09:33.460 --> 00:09:35.710
And of course, we're using
the Google Maven repository

00:09:35.710 --> 00:09:37.918
for this, which you can
specify in your build gradle.

00:09:37.918 --> 00:09:41.140
This is on Android Studio 2.3.

00:09:41.140 --> 00:09:43.600
And if you're using
3.0 plugins you

00:09:43.600 --> 00:09:46.660
can actually just say Google,
which is kind of sweet.

00:09:46.660 --> 00:09:49.720
All right, text and fonts, which
is one of my favorite things.

00:09:49.720 --> 00:09:50.595
I love fonts.

00:09:50.595 --> 00:09:51.970
In the old world,
how many people

00:09:51.970 --> 00:09:54.190
actually did custom fonts
on their Android app?

00:09:54.190 --> 00:09:55.090
Yeah, a lot of you.

00:09:55.090 --> 00:09:56.620
You know how much
it kind of sucked.

00:09:56.620 --> 00:09:58.690
You had to load typeface
into the constructor,

00:09:58.690 --> 00:10:01.120
and then you could go and
use this custom text view

00:10:01.120 --> 00:10:03.480
everywhere, and you know, yeah.

00:10:03.480 --> 00:10:05.370
But now we have a
new resource type

00:10:05.370 --> 00:10:08.670
which both accepts single font
files as well as families.

00:10:08.670 --> 00:10:10.759
And font files
get a resource ID.

00:10:10.759 --> 00:10:12.300
And you can also
make these families,

00:10:12.300 --> 00:10:14.250
which are groups of
fonts that are together.

00:10:14.250 --> 00:10:15.874
So you can define
them and say, like, I

00:10:15.874 --> 00:10:19.070
want normal to be this font,
and I want bold to be this font,

00:10:19.070 --> 00:10:21.630
and you know, et cetera,
very, very sweet.

00:10:21.630 --> 00:10:24.560
And this one generates
r.font, .myfont.

00:10:24.560 --> 00:10:26.970
And this is super
easy to use in XML.

00:10:26.970 --> 00:10:29.940
The text view font
family attribute is used

00:10:29.940 --> 00:10:32.310
and it can handle families,
which is even better.

00:10:32.310 --> 00:10:33.851
So you just get to
use the same thing

00:10:33.851 --> 00:10:36.180
you've been using all the time.

00:10:36.180 --> 00:10:39.570
Both textile attribute as well
as style spans are supported,

00:10:39.570 --> 00:10:41.240
which is really great.

00:10:41.240 --> 00:10:43.240
And you can also define
them in styles as usual.

00:10:43.240 --> 00:10:46.350
You can use them in code
by resources compat.

00:10:46.350 --> 00:10:49.170
And more importantly,
it's supported on API 14

00:10:49.170 --> 00:10:50.670
above with the support library.

00:10:50.670 --> 00:10:54.199
So go out there
and use more fonts.

00:10:54.199 --> 00:10:56.490
And the only problem, of
course, is that fonts actually

00:10:56.490 --> 00:10:58.030
bloat the size of your app.

00:10:58.030 --> 00:10:59.550
So we had to think about this.

00:10:59.550 --> 00:11:03.300
The top 25 fonts in
Google Fonts actually

00:11:03.300 --> 00:11:04.762
average 500 kilobytes or more.

00:11:04.762 --> 00:11:06.845
And they're not optimized
for mobile, necessarily.

00:11:06.845 --> 00:11:08.053
So we're like, what do we do?

00:11:08.053 --> 00:11:09.400
How do we fix this?

00:11:09.400 --> 00:11:12.850
So of course we added
downloadable fonts.

00:11:12.850 --> 00:11:16.030
And the font provider fetches
and service fonts to your apps.

00:11:16.030 --> 00:11:18.565
So more importantly, you don't
have to bundle them anymore.

00:11:18.565 --> 00:11:20.940
And this is really cool too,
because this font provider's

00:11:20.940 --> 00:11:22.990
actually shared between apps.

00:11:22.990 --> 00:11:24.880
So it gives you memory,
gives you network,

00:11:24.880 --> 00:11:26.280
it gives you space savings.

00:11:26.280 --> 00:11:29.100
And with Google Play
services and Google Fonts

00:11:29.100 --> 00:11:31.590
you get over 800 fonts.

00:11:31.590 --> 00:11:33.835
So it's really nice.

00:11:33.835 --> 00:11:35.460
And in code you can
request these fonts

00:11:35.460 --> 00:11:37.650
using a font request,
which [INAUDIBLE] things

00:11:37.650 --> 00:11:40.050
like authority, and
package, inserts,

00:11:40.050 --> 00:11:43.770
or security, and callbacks for
success or failure now exist.

00:11:47.220 --> 00:11:50.790
And of course you just
use fonts contract compat,

00:11:50.790 --> 00:11:53.610
and you do control what thread
this runs on, so don't run it

00:11:53.610 --> 00:11:56.780
on the UI thread.

00:11:56.780 --> 00:11:59.220
And this you can
also throw it in XML.

00:11:59.220 --> 00:12:00.540
So it's really easy to use.

00:12:00.540 --> 00:12:03.360
The search is actually
a string array.

00:12:03.360 --> 00:12:05.800
And it actually is pretty cool.

00:12:05.800 --> 00:12:07.357
So we've also done
full integration

00:12:07.357 --> 00:12:08.190
with Android Studio.

00:12:08.190 --> 00:12:09.090
It looks like this.

00:12:09.090 --> 00:12:11.040
We have some boring
text in a layout,

00:12:11.040 --> 00:12:12.519
and we go and select More Fonts.

00:12:12.519 --> 00:12:14.310
You see where you've
got Google Fonts here,

00:12:14.310 --> 00:12:16.185
you've got this beautiful
selection of fonts.

00:12:16.185 --> 00:12:18.270
But it's so many I'm just
going to search for one.

00:12:18.270 --> 00:12:18.870
There we are.

00:12:18.870 --> 00:12:21.580
Yesteryear, we say
downloadable font,

00:12:21.580 --> 00:12:23.785
and it's going to show
up in the layout editor,

00:12:23.785 --> 00:12:26.160
and then it's going to add
this beautiful file-- actually

00:12:26.160 --> 00:12:27.720
two files-- to the project.

00:12:27.720 --> 00:12:28.920
So pretty sweet.

00:12:28.920 --> 00:12:31.680
So check out the sample
app, the Google Fonts docs,

00:12:31.680 --> 00:12:33.540
and the guide on
developer.android.com

00:12:33.540 --> 00:12:34.290
for all the info.

00:12:34.290 --> 00:12:36.390
And best of all,
downloadable fonts

00:12:36.390 --> 00:12:39.210
are all supported
in API 14 plus.

00:12:39.210 --> 00:12:40.669
All right, so
there's nothing worse

00:12:40.669 --> 00:12:42.251
than when someone
sends you a message,

00:12:42.251 --> 00:12:44.250
and you get a box that
provides no information.

00:12:44.250 --> 00:12:45.990
We call this tofu
because it's box.

00:12:45.990 --> 00:12:48.304
So it's time to
get rid of this--

00:12:48.304 --> 00:12:50.220
and this is there because
the system is always

00:12:50.220 --> 00:12:53.089
bundled the emoji font, and
unicode keeps adding new emoji,

00:12:53.089 --> 00:12:54.630
and it's impossible
for us to keep up

00:12:54.630 --> 00:12:57.190
unless we can make it
show up in older versions.

00:12:57.190 --> 00:12:59.400
So the support library has
access to this new font.

00:12:59.400 --> 00:13:02.039
And it checks per glyph
if it can be rendered,

00:13:02.039 --> 00:13:04.080
or it replaces this with
these emoji [? stamps ?]

00:13:04.080 --> 00:13:05.659
if it can't, which is great.

00:13:05.659 --> 00:13:07.700
There are two ways for
you to use it in your app.

00:13:07.700 --> 00:13:09.390
The download
configuration just happens

00:13:09.390 --> 00:13:11.880
to integrate with
downloadable fonts.

00:13:11.880 --> 00:13:13.740
So you just add
your dependencies,

00:13:13.740 --> 00:13:16.200
you make your font request,
and you initialize it

00:13:16.200 --> 00:13:17.820
in your application on create.

00:13:17.820 --> 00:13:18.440
Very simple.

00:13:18.440 --> 00:13:20.190
It means you don't
have to actually bundle

00:13:20.190 --> 00:13:23.060
the emoji font with your app.

00:13:23.060 --> 00:13:23.800
But you can.

00:13:23.800 --> 00:13:26.720
If you're targeting a non-GMS
devices, you can do that.

00:13:26.720 --> 00:13:29.190
It'll add about 7 megabytes.

00:13:29.190 --> 00:13:30.990
And you configure
it in a similar way,

00:13:30.990 --> 00:13:34.860
again, with a just
bundled emoji pack config.

00:13:34.860 --> 00:13:37.810
So very straightforward.

00:13:37.810 --> 00:13:41.280
Again, you can just-- you have
to use these emoji text views.

00:13:41.280 --> 00:13:42.690
Instead of text
view, you can use

00:13:42.690 --> 00:13:45.120
emoji edit text, and emoji
button instead of edit text

00:13:45.120 --> 00:13:46.380
and button.

00:13:46.380 --> 00:13:49.149
And you don't have to use these,
but if you don't use them,

00:13:49.149 --> 00:13:51.690
you have to integrate it into
your own custom views yourself.

00:13:51.690 --> 00:13:54.840
So we do supply these
to help you out.

00:13:54.840 --> 00:13:59.760
And so now tacos and
unicorns both exist.

00:13:59.760 --> 00:14:01.365
Important things for
us to get across.

00:14:01.365 --> 00:14:04.320
So check out this sample
on [? DAC, ?] there's

00:14:04.320 --> 00:14:05.070
more information.

00:14:05.070 --> 00:14:07.260
Now, one caveat here.

00:14:07.260 --> 00:14:09.810
We didn't actually back port
this all the way to kit-kat.

00:14:09.810 --> 00:14:12.195
This does require API 19 plus.

00:14:12.195 --> 00:14:15.030
So that's the one
minor caveat here.

00:14:15.030 --> 00:14:17.790
But again, so get tofu
on some older devices

00:14:17.790 --> 00:14:21.330
if you try to set this
up to use it both ways.

00:14:21.330 --> 00:14:22.269
TextView autosizing.

00:14:22.269 --> 00:14:24.810
This is a feature I've wanted,
and how many people have built

00:14:24.810 --> 00:14:26.760
their own TextView autosizer?

00:14:26.760 --> 00:14:29.700
Yes, I've been wanting
this feature forever.

00:14:29.700 --> 00:14:32.910
So I'm so happy that it's
finally here in the platform.

00:14:32.910 --> 00:14:35.490
Text actually resizes to
fill in its container.

00:14:35.490 --> 00:14:38.820
I can't tell you how excited I
was when we built this thing.

00:14:38.820 --> 00:14:42.435
So you use auto size
text type uniform.

00:14:45.480 --> 00:14:47.550
And you can use an
array of preset sizes

00:14:47.550 --> 00:14:50.040
or an array of values, or
a set of min and max size

00:14:50.040 --> 00:14:50.780
with a stack.

00:14:50.780 --> 00:14:51.750
That's really easy.

00:14:51.750 --> 00:14:55.080
And once again, we've
brought this to API 14 plus.

00:14:55.080 --> 00:14:57.060
We bring improvements
to VectorDrawable.

00:14:57.060 --> 00:14:59.620
This gives it feature parity
with support for fill types.

00:14:59.620 --> 00:15:03.040
So if it looks like
this in Android Studio

00:15:03.040 --> 00:15:05.151
and you shove this
in, this might

00:15:05.151 --> 00:15:07.650
be what you get before because
you get these weird artifacts

00:15:07.650 --> 00:15:10.800
because we're using these
even-odd fill rules,

00:15:10.800 --> 00:15:12.675
and we didn't support that.

00:15:12.675 --> 00:15:14.550
There was a big TBD in
the source code of you

00:15:14.550 --> 00:15:16.642
went and looked.

00:15:16.642 --> 00:15:18.600
So a fill rule defines
how this render designs,

00:15:18.600 --> 00:15:20.891
which of the regions are
inside, and which are outside.

00:15:20.891 --> 00:15:25.710
And we added support for this,
which we actually fixed finally

00:15:25.710 --> 00:15:28.560
in SDK 24 and we've
backported it to 14 plus.

00:15:28.560 --> 00:15:29.630
So this is really cool.

00:15:29.630 --> 00:15:32.270
It means your vectors are
more likely to work, which

00:15:32.270 --> 00:15:34.800
if you've ever had to deal
with, you know how awesome this

00:15:34.800 --> 00:15:36.370
is that we finally fixed it.

00:15:36.370 --> 00:15:43.890
We also ported the stuff
from animated drawable compat

00:15:43.890 --> 00:15:45.720
for path data morphing.

00:15:45.720 --> 00:15:46.720
And this is really cool.

00:15:46.720 --> 00:15:49.410
This is an example of using
shapeshifter, Alex Lockwood's

00:15:49.410 --> 00:15:51.600
tool, to generate compatible
images with matching

00:15:51.600 --> 00:15:53.070
path formats.

00:15:53.070 --> 00:15:55.800
And let's look along at what's
going on here at the XML level.

00:15:55.800 --> 00:15:57.260
We start with our
vector, defining

00:15:57.260 --> 00:15:58.920
our starting image, a buffalo.

00:15:58.920 --> 00:16:00.660
We've extracted the path data.

00:16:00.660 --> 00:16:02.790
And for the buffalo,
hippo and elephant,

00:16:02.790 --> 00:16:04.050
they're string resources.

00:16:04.050 --> 00:16:06.790
And then we use an
object animator.

00:16:06.790 --> 00:16:08.160
Pretty sweet.

00:16:08.160 --> 00:16:10.800
So again, we're
specifying the path values

00:16:10.800 --> 00:16:12.990
to morph a buffalo to a hippo.

00:16:12.990 --> 00:16:14.850
And once again, we
tie it all together

00:16:14.850 --> 00:16:16.710
in an animated vector XML.

00:16:16.710 --> 00:16:19.680
Now we can actually do stuff
with bundled XML formats

00:16:19.680 --> 00:16:21.420
to make this even cleaner.

00:16:21.420 --> 00:16:25.790
So again, we can actually
use an attr element here,

00:16:25.790 --> 00:16:28.075
and it in-lines the XML
from the buffalo drawable.

00:16:28.075 --> 00:16:30.450
And then we can do the same
with the animation attribute.

00:16:30.450 --> 00:16:31.950
And so we have a
bundle package that

00:16:31.950 --> 00:16:34.470
actually includes the entire
vector drawable animation,

00:16:34.470 --> 00:16:36.510
which is really cool.

00:16:36.510 --> 00:16:38.280
We also have a
path interpolator.

00:16:38.280 --> 00:16:39.870
Once again, that's parity.

00:16:39.870 --> 00:16:41.640
So this one is kind
of complicated,

00:16:41.640 --> 00:16:44.230
but we can take a simple
example and show how it works.

00:16:44.230 --> 00:16:47.189
So for a UX designer, it wants
to shrink a [INAUDIBLE] square,

00:16:47.189 --> 00:16:49.230
but they want to have an
interesting acceleration

00:16:49.230 --> 00:16:52.050
curve as it shrinks, we can
use a path interpolator.

00:16:52.050 --> 00:16:54.190
And this is kind of cool.

00:16:54.190 --> 00:16:56.550
We can make a curve that
that drops off quickly,

00:16:56.550 --> 00:16:59.054
snaps back a small amount
and slowly tapers off.

00:16:59.054 --> 00:17:01.470
Here's our morph animation,
and we'll set the interpolator

00:17:01.470 --> 00:17:02.910
to be our path interpolator.

00:17:02.910 --> 00:17:05.430
So once again we can bundle
it in a single file using

00:17:05.430 --> 00:17:09.270
these attrs, and this
results in this slightly more

00:17:09.270 --> 00:17:10.410
cool animation.

00:17:10.410 --> 00:17:12.609
Still just a rectangle.

00:17:12.609 --> 00:17:14.480
OK, final thing I'm
going to talk about

00:17:14.480 --> 00:17:16.849
is transition support library.

00:17:16.849 --> 00:17:18.530
So if you've noticed
that we actually

00:17:18.530 --> 00:17:21.436
added some additional transition
type in Lollipop and above,

00:17:21.436 --> 00:17:23.810
things like path motion, and
propagation, and all of this

00:17:23.810 --> 00:17:26.794
is available in the
transition library.

00:17:26.794 --> 00:17:29.210
So when you use the transition
XML with a support library,

00:17:29.210 --> 00:17:32.030
you have to specify this
dash dash no dash version

00:17:32.030 --> 00:17:34.880
transitions as an APT option.

00:17:34.880 --> 00:17:38.770
And after that, you can use
all the same transition XMLs

00:17:38.770 --> 00:17:42.260
that you use for platform
transition API on API 14

00:17:42.260 --> 00:17:43.820
and above.

00:17:43.820 --> 00:17:45.290
And the reason I'm
talking so fast

00:17:45.290 --> 00:17:47.666
is because I want to get my
amazing collaborator on here,

00:17:47.666 --> 00:17:49.123
who is really the
star of the show.

00:17:49.123 --> 00:17:50.270
I'm just the opening act.

00:17:50.270 --> 00:17:52.880
I'd like you to welcome
Lisa Wray, who's

00:17:52.880 --> 00:17:55.409
going to talk about some
amazing animation features.

00:17:55.409 --> 00:17:56.284
LISA WRAY: Thank you.

00:17:59.810 --> 00:18:02.470
So I only have one
thing to talk about,

00:18:02.470 --> 00:18:05.680
and that's physics-based
animations.

00:18:05.680 --> 00:18:08.740
So we've known for a
long time that motion is

00:18:08.740 --> 00:18:11.110
important in material design.

00:18:11.110 --> 00:18:15.040
Natural movement inspired
by forces in the real world.

00:18:15.040 --> 00:18:17.500
And I've tried, I really have.

00:18:17.500 --> 00:18:19.900
But it hasn't always been easy.

00:18:19.900 --> 00:18:22.900
So the support library has now
introduced two implementations

00:18:22.900 --> 00:18:24.700
of physics-based animation.

00:18:24.700 --> 00:18:26.920
Not approximations of
motion with a stock

00:18:26.920 --> 00:18:30.760
interpolator, but motion
based on natural forces.

00:18:30.760 --> 00:18:32.980
Could you have done this before?

00:18:32.980 --> 00:18:34.720
Maybe, but it wouldn't
have been easy.

00:18:34.720 --> 00:18:36.520
With dynamic
animation, these ideas

00:18:36.520 --> 00:18:39.250
are now central to the
way we can animate.

00:18:39.250 --> 00:18:41.170
So my hope is to make
this type of motion

00:18:41.170 --> 00:18:43.150
easy for you to
think about and easy

00:18:43.150 --> 00:18:45.820
for you to use in your app.

00:18:45.820 --> 00:18:49.030
Some things that are easy
now that were hard before.

00:18:49.030 --> 00:18:53.710
Responding to user interaction--
by which I just mean a touch--

00:18:53.710 --> 00:18:57.580
chaining animations,
modifying them on the fly;

00:18:57.580 --> 00:19:01.402
getting great natural movement
with much less visual jank.

00:19:01.402 --> 00:19:03.610
So I'm going to step through
the mechanics of the two

00:19:03.610 --> 00:19:08.020
dynamic animations we have right
now and then we'll mix it up.

00:19:08.020 --> 00:19:09.720
So the first, a fling animation.

00:19:09.720 --> 00:19:12.820
It starts with an initial
velocity, it slows down,

00:19:12.820 --> 00:19:14.470
and it ends gradually.

00:19:14.470 --> 00:19:16.690
So every time that
color changes,

00:19:16.690 --> 00:19:20.300
it's starting a new fling.

00:19:20.300 --> 00:19:23.630
And here's the simplest fling
that you can possibly make.

00:19:23.630 --> 00:19:25.340
Ball is a view.

00:19:25.340 --> 00:19:28.230
Translation y is the
property we're changing.

00:19:28.230 --> 00:19:30.620
And its velocity is
pixels per second.

00:19:30.620 --> 00:19:32.390
I discovered while
making this that pixels

00:19:32.390 --> 00:19:34.100
are a lot smaller
than I thought.

00:19:34.100 --> 00:19:36.050
Everything else is defaults.

00:19:36.050 --> 00:19:38.830
And so that's what you just saw.

00:19:38.830 --> 00:19:40.810
You can customize
a fling by changing

00:19:40.810 --> 00:19:43.670
its friction, the factor
by which it slows down.

00:19:46.790 --> 00:19:48.860
So here's an
example of friction.

00:19:48.860 --> 00:19:51.710
So from left, you
have high friction

00:19:51.710 --> 00:19:53.402
to low friction on the right.

00:19:53.402 --> 00:19:54.860
So the less friction
that you have,

00:19:54.860 --> 00:19:58.040
the more distance your view will
travel for a given velocity.

00:20:00.910 --> 00:20:02.890
And here's a spring animation.

00:20:02.890 --> 00:20:05.260
And it looks just
like what we'd imagine

00:20:05.260 --> 00:20:07.540
from the motion of
a physical spring.

00:20:07.540 --> 00:20:10.900
It exerts a force back to
the endpoint of the spring,

00:20:10.900 --> 00:20:12.910
and you can even get a bounce.

00:20:12.910 --> 00:20:18.960
So every time the color changes
that is a new spring animation.

00:20:18.960 --> 00:20:22.220
And here's the simplest
spring you can possibly make.

00:20:22.220 --> 00:20:26.260
Ball is a view, translation y
is the property we're changing,

00:20:26.260 --> 00:20:28.230
and zero is where
it's going to stop,

00:20:28.230 --> 00:20:31.200
which is its final
translation at equilibrium.

00:20:31.200 --> 00:20:34.170
And its velocity is
pixels per second.

00:20:34.170 --> 00:20:35.640
And everything else is defaults.

00:20:35.640 --> 00:20:38.000
And it just goes.

00:20:38.000 --> 00:20:39.500
So to customize
this, you can call

00:20:39.500 --> 00:20:42.110
getSpring on your animation,
and that gives you

00:20:42.110 --> 00:20:45.200
its internal spring
force object.

00:20:45.200 --> 00:20:48.200
And that has a damping
ratio, a stiffness,

00:20:48.200 --> 00:20:51.470
and you can see that
the final position.

00:20:51.470 --> 00:20:54.440
Damping is the ratio by
which the size of your bounce

00:20:54.440 --> 00:20:55.880
is reduced over time.

00:20:55.880 --> 00:20:57.830
And the default
is medium bouncy.

00:20:57.830 --> 00:21:00.860
In general, the lower the
number, the more oscillation

00:21:00.860 --> 00:21:02.380
you'll see-- a.k.a.

00:21:02.380 --> 00:21:05.880
bouncing-- before the force
is going to reach equilibrium.

00:21:05.880 --> 00:21:09.280
At 1 you get critical damping,
which means no bounce,

00:21:09.280 --> 00:21:13.160
and at 0 you get no damping,
which means infinite bounce.

00:21:13.160 --> 00:21:14.210
Don't do that.

00:21:14.210 --> 00:21:17.660
In general, please do not
under-damp your views.

00:21:17.660 --> 00:21:21.020
This crazy bouncing is what made
me think at first, why on earth

00:21:21.020 --> 00:21:22.790
would you ever want
to do this to a view?

00:21:22.790 --> 00:21:24.290
So try little or
no bounce, and I

00:21:24.290 --> 00:21:29.500
think you'll be surprised how
useful this animation can be.

00:21:29.500 --> 00:21:32.860
Stiffness is like the
stiffness of a physical spring.

00:21:32.860 --> 00:21:34.270
So for a given
starting velocity,

00:21:34.270 --> 00:21:35.990
how far will it travel
from the endpoint,

00:21:35.990 --> 00:21:39.220
and how fast will
it be pulled back?

00:21:39.220 --> 00:21:41.920
This example has no
bounds so that you

00:21:41.920 --> 00:21:44.360
can see the difference
in the stiffness better.

00:21:44.360 --> 00:21:46.160
The lowest stiffness
is on the left,

00:21:46.160 --> 00:21:47.410
so it's traveling further.

00:21:47.410 --> 00:21:51.360
The highest stiffness
is on the right.

00:21:51.360 --> 00:21:54.290
And you can also create your
own external spring force

00:21:54.290 --> 00:21:57.680
in order to share it
among multiple animations.

00:21:57.680 --> 00:22:01.600
We'll see why you might
want to do that in a moment.

00:22:01.600 --> 00:22:03.930
So one thing you might want
to do with these animations

00:22:03.930 --> 00:22:06.560
is allow user input.

00:22:06.560 --> 00:22:09.240
So velocity tracker is
one option to handle this.

00:22:09.240 --> 00:22:10.770
It's an older, but a goodie.

00:22:10.770 --> 00:22:14.070
This class has been
around since API 1.

00:22:14.070 --> 00:22:15.720
It does what it says on the tin.

00:22:15.720 --> 00:22:19.410
It tracks velocity
from a user's touch.

00:22:19.410 --> 00:22:22.590
You can also use just
your detector if you only

00:22:22.590 --> 00:22:24.090
care what the end
state of the fling

00:22:24.090 --> 00:22:28.867
is because its fling
callback has velocity.

00:22:28.867 --> 00:22:29.950
So how would you use this?

00:22:29.950 --> 00:22:32.200
We're going to go with
velocity tracker for now.

00:22:32.200 --> 00:22:34.840
You'd use it in a touch
listener on the parent

00:22:34.840 --> 00:22:36.730
of the view you want to track.

00:22:36.730 --> 00:22:38.410
Parent is important.

00:22:38.410 --> 00:22:40.480
Call velocity tracker
to obtain to get

00:22:40.480 --> 00:22:42.550
an instance of the
tracker, then you

00:22:42.550 --> 00:22:45.850
can feed in the user's touch
events, starting with down

00:22:45.850 --> 00:22:49.050
and continuing with move.

00:22:49.050 --> 00:22:53.520
Then in action up you'll call
compute current velocity,

00:22:53.520 --> 00:22:56.430
and it will compute a
nice velocity for you.

00:22:56.430 --> 00:23:00.190
After you're done
make sure to clear it.

00:23:00.190 --> 00:23:04.220
That velocity is going to come
in two components, x and y.

00:23:04.220 --> 00:23:06.770
Then you're going to start
two dynamic animations

00:23:06.770 --> 00:23:08.060
at the same time--

00:23:08.060 --> 00:23:10.520
one for the x velocity and
one for the y velocity.

00:23:10.520 --> 00:23:12.690
This would be a good reason
to share a spring force.

00:23:12.690 --> 00:23:14.740
They're going to
run simultaneously.

00:23:14.740 --> 00:23:17.130
And as you can see,
this is enough.

00:23:17.130 --> 00:23:21.590
This gives you a smoothly moving
interactive two-dimensional

00:23:21.590 --> 00:23:22.910
animation .

00:23:22.910 --> 00:23:24.650
As you can see, it
works pretty well.

00:23:24.650 --> 00:23:26.780
Just be careful when you
fling because they do not

00:23:26.780 --> 00:23:28.356
automatically stay
on the screen.

00:23:28.356 --> 00:23:30.230
And when they're gone,
they do not come back.

00:23:33.500 --> 00:23:35.500
Just like other animations
you're familiar with,

00:23:35.500 --> 00:23:39.700
dynamic animation also has
end and update listeners.

00:23:39.700 --> 00:23:41.710
So that's how I was
chaining them in my earlier

00:23:41.710 --> 00:23:44.020
demonstration and
changing the ball colors

00:23:44.020 --> 00:23:46.680
to repeat over and over again.

00:23:46.680 --> 00:23:49.590
So let's chain two
fling animations.

00:23:49.590 --> 00:23:51.060
We're going to
fling just as we did

00:23:51.060 --> 00:23:55.370
before using the velocity from
our drag listener and velocity

00:23:55.370 --> 00:23:56.874
tracker.

00:23:56.874 --> 00:23:59.290
And we're going to create two
fling animations at the same

00:23:59.290 --> 00:24:01.270
time-- one for x and one for y--

00:24:01.270 --> 00:24:02.920
to get natural movement.

00:24:02.920 --> 00:24:06.524
Then we're going to stop the
first animation at the edge

00:24:06.524 --> 00:24:08.440
and create a new one in
a different direction,

00:24:08.440 --> 00:24:11.680
giving the impression
the ball has bounced.

00:24:11.680 --> 00:24:14.410
This time we'll add an update
listener and an end listener

00:24:14.410 --> 00:24:15.700
to each of our flings.

00:24:15.700 --> 00:24:17.950
On each update,
we'll check to see

00:24:17.950 --> 00:24:20.532
if the ball has slipped outside
the bounds of its parent.

00:24:20.532 --> 00:24:22.240
There's probably a
better way to do this,

00:24:22.240 --> 00:24:25.400
but that's an exercise
for the reader.

00:24:25.400 --> 00:24:29.380
If it did go outside we'll
cancel the animation.

00:24:29.380 --> 00:24:32.860
That means we'll get a
callback to on animation end.

00:24:32.860 --> 00:24:35.800
If we canceled it,
meaning it hit the edge,

00:24:35.800 --> 00:24:37.354
then fling it back.

00:24:37.354 --> 00:24:39.520
As you can see, I made an
extension function on view

00:24:39.520 --> 00:24:42.040
here because I got
tired of typing.

00:24:42.040 --> 00:24:44.450
We'll use the
velocity past here,

00:24:44.450 --> 00:24:48.940
which is the remaining velocity
from the canceled animation.

00:24:48.940 --> 00:24:52.210
And we'll use it in the opposite
direction, which is the minus

00:24:52.210 --> 00:24:54.010
sign you'll see there.

00:24:54.010 --> 00:24:56.560
Of course, it's not
exactly that simple.

00:24:56.560 --> 00:25:00.730
What this does is it flings
the ball straight back at you

00:25:00.730 --> 00:25:04.150
because it reverses both
of its velocities, x and y.

00:25:04.150 --> 00:25:06.880
So what we really want
is natural reflection.

00:25:06.880 --> 00:25:09.490
We want it to only reverse
its velocity on one axis

00:25:09.490 --> 00:25:10.700
but continue on the other.

00:25:10.700 --> 00:25:13.310
And that's what will give us
this 90-degree bounce angle.

00:25:16.370 --> 00:25:17.430
So it's not too hard.

00:25:17.430 --> 00:25:18.980
It looks like this.

00:25:18.980 --> 00:25:23.240
If it's hitting the
horizontal edge, reverse x.

00:25:23.240 --> 00:25:26.380
Otherwise, reverse y.

00:25:26.380 --> 00:25:30.290
And we get a nice
reflection or bounce.

00:25:30.290 --> 00:25:34.070
And it also works with
different animations.

00:25:34.070 --> 00:25:36.000
Ever seen something like this?

00:25:36.000 --> 00:25:38.819
There's an app that keeps trying
to do this on my home screen.

00:25:38.819 --> 00:25:40.610
I don't why I'm
encouraging you to do this,

00:25:40.610 --> 00:25:43.006
but it's interesting
because it's quite simple.

00:25:43.006 --> 00:25:44.630
And it's sort of a
sticky effect, where

00:25:44.630 --> 00:25:47.390
if you fling it to the edge,
it sticks there and absorbs

00:25:47.390 --> 00:25:51.204
the extra momentum
with a spring bounce.

00:25:51.204 --> 00:25:53.620
So if you do this, it's going
to look something like this.

00:25:53.620 --> 00:25:55.120
The thing to note
here is that we're

00:25:55.120 --> 00:25:58.540
using the ball's current
translation value as its end

00:25:58.540 --> 00:26:00.400
value for the spring.

00:26:00.400 --> 00:26:03.430
So we're going to fling as
before, put an end listener.

00:26:03.430 --> 00:26:06.670
And then when we
get the callback,

00:26:06.670 --> 00:26:11.530
go ahead and oscillate until you
reach equilibrium, dissipating

00:26:11.530 --> 00:26:12.810
the remaining velocity.

00:26:16.820 --> 00:26:18.470
Chaining springs.

00:26:18.470 --> 00:26:20.720
There was a really cool
demo in the Google I/O talk

00:26:20.720 --> 00:26:22.721
I went to of three balls
connected with springs.

00:26:22.721 --> 00:26:24.136
I'm not going to
explain that here

00:26:24.136 --> 00:26:26.330
because they did a great
job already in that talk.

00:26:26.330 --> 00:26:28.980
So if you want, go look
it up and then come back.

00:26:28.980 --> 00:26:32.270
So here's a real
layout from an Android

00:26:32.270 --> 00:26:33.650
app using the same effect.

00:26:33.650 --> 00:26:37.030
This is inspired by a screen in
the plaid app by Nick Butcher--

00:26:37.030 --> 00:26:40.070
sorry, Nick-- where as part
of the screen transitions,

00:26:40.070 --> 00:26:43.010
there's several onscreen
components that translate up

00:26:43.010 --> 00:26:46.100
subtly one after another.

00:26:46.100 --> 00:26:49.100
So in that effect, the
distance translated,

00:26:49.100 --> 00:26:52.880
the delay of each element,
and the interpolation used

00:26:52.880 --> 00:26:55.760
to simulate acceleration
and deceleration

00:26:55.760 --> 00:26:58.880
are all hard coded by hand.

00:26:58.880 --> 00:27:01.330
That's a pain in the butt.

00:27:01.330 --> 00:27:04.330
Here it's all done with
the same chained spring

00:27:04.330 --> 00:27:06.539
we just saw with the balls.

00:27:06.539 --> 00:27:07.830
I'll go through how that works.

00:27:07.830 --> 00:27:09.205
So what's actually
going on here?

00:27:09.205 --> 00:27:14.040
These two springs are almost
exactly the same effect.

00:27:14.040 --> 00:27:17.640
Obviously the top ball,
the blue ball, is the lead,

00:27:17.640 --> 00:27:20.640
the yellow ball follows
it, and the green ball

00:27:20.640 --> 00:27:22.121
follows the yellow
ball, almost as

00:27:22.121 --> 00:27:24.120
if they're chained together
with bouncy springs.

00:27:26.940 --> 00:27:30.510
In the actual app
example, the lead view

00:27:30.510 --> 00:27:32.880
is the headline and icons.

00:27:32.880 --> 00:27:35.280
The next view, the
paragraphs, follow it,

00:27:35.280 --> 00:27:37.860
and finally, the FAB is
following the paragraphs.

00:27:37.860 --> 00:27:41.850
You can see here that there's no
rule that these views actually

00:27:41.850 --> 00:27:45.150
have to be in a line
in terms of position.

00:27:45.150 --> 00:27:46.050
They can be anywhere.

00:27:46.050 --> 00:27:48.810
What matters is the
propagation of effects

00:27:48.810 --> 00:27:51.450
from one animation to the next.

00:27:51.450 --> 00:27:52.680
So how do we do this?

00:27:52.680 --> 00:27:55.230
Instead of a touch listener,
I started with a fixed spring

00:27:55.230 --> 00:27:57.120
animation on the headline.

00:27:57.120 --> 00:27:58.830
The thing to notice
here is that instead

00:27:58.830 --> 00:28:01.890
of giving it a velocity,
I gave it a start value.

00:28:01.890 --> 00:28:05.160
Basically I said, pull
the spring back this far

00:28:05.160 --> 00:28:06.570
and start it there.

00:28:06.570 --> 00:28:08.260
And I gave it an
update listener,

00:28:08.260 --> 00:28:10.350
which we've seen before.

00:28:10.350 --> 00:28:13.110
Then I made a spring
animation for the paragraphs,

00:28:13.110 --> 00:28:14.730
exact same thing.

00:28:14.730 --> 00:28:18.060
In the listener getting
callbacks from the headline,

00:28:18.060 --> 00:28:23.490
I call animate to final position
on the paragraph animation.

00:28:23.490 --> 00:28:26.619
This [? isn't ?] a really
important and useful method.

00:28:26.619 --> 00:28:27.910
So it's going to do two things.

00:28:27.910 --> 00:28:30.720
One, it sets the
new final position

00:28:30.720 --> 00:28:33.780
of the paragraph spring
to the current position

00:28:33.780 --> 00:28:35.790
of the headline animation.

00:28:35.790 --> 00:28:41.920
And two, it starts the paragraph
animation if it hasn't yet.

00:28:41.920 --> 00:28:44.480
And then finally, we'll do
the same thing for the FAB.

00:28:44.480 --> 00:28:46.890
We'll set an update
listener on the paragraphs

00:28:46.890 --> 00:28:51.430
and chain a spring
animation to that.

00:28:51.430 --> 00:28:53.080
And that's how chaining works.

00:28:53.080 --> 00:28:55.663
The difference here from what
we were doing before with flings

00:28:55.663 --> 00:28:58.280
is that those animations were
subsequent one after another,

00:28:58.280 --> 00:29:01.290
and these are actually
happening simultaneously.

00:29:01.290 --> 00:29:03.930
You might also notice if you're
looking very closely that I

00:29:03.930 --> 00:29:06.300
also used a spring on
the alphas of the views

00:29:06.300 --> 00:29:09.150
and on the scale of the FAB.

00:29:09.150 --> 00:29:10.810
So what else can you animate?

00:29:10.810 --> 00:29:13.500
And you can animate a lot
of built-in properties.

00:29:13.500 --> 00:29:16.410
Certainly everything I can think
of flinging or springing off

00:29:16.410 --> 00:29:18.120
the top of my head
you can animate.

00:29:18.120 --> 00:29:21.630
Alphas, translation, rotation,
scroll, scale, and x,

00:29:21.630 --> 00:29:25.440
y, and z, which are absolute
positions, including

00:29:25.440 --> 00:29:27.179
translation.

00:29:27.179 --> 00:29:29.220
But if you want to animate
something even crazier

00:29:29.220 --> 00:29:31.920
or just make a custom property
that groups a couple of these,

00:29:31.920 --> 00:29:35.730
you just make an instance
of float property compact.

00:29:35.730 --> 00:29:37.812
You also need to set the
minimum visible change

00:29:37.812 --> 00:29:39.270
so the animation
knows when to stop

00:29:39.270 --> 00:29:42.600
and doesn't keep on animating
tiny, tiny bits forever.

00:29:42.600 --> 00:29:45.450
You can also start every dynamic
animation at a particular start

00:29:45.450 --> 00:29:47.580
value, give them a
minimum and maximum,

00:29:47.580 --> 00:29:49.497
and finally cancel
your animations.

00:29:49.497 --> 00:29:52.080
Because if your user quits the
activity while they're running,

00:29:52.080 --> 00:29:53.550
your app will crash.

00:29:53.550 --> 00:29:56.100
So cancel them.

00:29:56.100 --> 00:30:00.500
These APIs are available
from Jellybean and above.

00:30:00.500 --> 00:30:03.140
And I'm sure you
got all of that.

00:30:03.140 --> 00:30:06.170
But if you didn't, all the code
for every one of these demos is

00:30:06.170 --> 00:30:10.310
on my GitHub,
lisawray/physics-playground.

00:30:10.310 --> 00:30:15.230
So my takeaway here that I want
is physics-based animations.

00:30:15.230 --> 00:30:17.279
They're not toys, and
they're not just for games.

00:30:17.279 --> 00:30:18.820
They're way more
than bouncing balls.

00:30:18.820 --> 00:30:20.780
They're a great way to
bring natural motion

00:30:20.780 --> 00:30:23.180
and interaction your current UI.

00:30:23.180 --> 00:30:25.910
So I look forward to seeing
what you make with them.

00:30:25.910 --> 00:30:26.480
Thank you.

00:30:26.480 --> 00:30:29.530
[APPLAUSE]

