WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:01.956
VAN RIPER: I'm going to start.

00:00:07.335 --> 00:00:08.802
I apologize for the delay.

00:00:11.736 --> 00:00:15.470
I was about ready to throw that
guest's bad reader thing

00:00:15.470 --> 00:00:19.350
through the window out there,
to get it to work.

00:00:19.350 --> 00:00:23.700
Anyway, someone is going to
hear about that tomorrow.

00:00:23.700 --> 00:00:25.700
I'm going to try to do some
real quick things.

00:00:25.700 --> 00:00:30.150
Who's going to Silicon
Valley Code Camp?

00:00:30.150 --> 00:00:31.300
No, keep your hands up.

00:00:31.300 --> 00:00:32.535
I need to see who you are.

00:00:32.535 --> 00:00:33.665
AUDIENCE: What was
the question?

00:00:33.665 --> 00:00:35.670
VAN RIPER: Who is already signed
up to go to Silicon

00:00:35.670 --> 00:00:38.336
Valley Code Camp in October?

00:00:38.336 --> 00:00:39.740
All right.

00:00:39.740 --> 00:00:41.420
You guys need to come and
see me to get one of

00:00:41.420 --> 00:00:42.730
these really cool--

00:00:42.730 --> 00:00:45.140
as Peter Kellner in the
front row tells me--

00:00:45.140 --> 00:00:46.730
not a sticker.

00:00:46.730 --> 00:00:48.065
It's a mule skin.

00:00:48.065 --> 00:00:49.315
They're very special.

00:00:51.626 --> 00:00:53.240
You didn't tell me
why it's special.

00:00:56.050 --> 00:01:00.810
Oh, because it comes off, and
it doesn't trash your

00:01:00.810 --> 00:01:01.690
important laptop.

00:01:01.690 --> 00:01:04.090
So if you're coming to Code Camp
or if you're willing to

00:01:04.090 --> 00:01:05.230
look me in the eye
and say, you're

00:01:05.230 --> 00:01:06.360
going to sign up tonight.

00:01:06.360 --> 00:01:07.898
Come by and get on
of these from me.

00:01:10.590 --> 00:01:12.470
And if you want to learn more
about Code Camp, you should

00:01:12.470 --> 00:01:14.690
talk to the guy who started it
all, several years ago, Peter

00:01:14.690 --> 00:01:15.940
Kellner, in the front row.

00:01:20.290 --> 00:01:22.894
Oh, how many Java User
Group members do

00:01:22.894 --> 00:01:25.090
we have in the audience?

00:01:25.090 --> 00:01:25.580
Awesome.

00:01:25.580 --> 00:01:28.040
How many Google Developer Group
members do we have in

00:01:28.040 --> 00:01:28.360
the audience?

00:01:28.360 --> 00:01:31.360
It's OK if you raise your hand
twice, if you're in both.

00:01:31.360 --> 00:01:32.125
That's what I thought.

00:01:32.125 --> 00:01:34.720
We've got a lot of overlap.

00:01:34.720 --> 00:01:35.410
OK.

00:01:35.410 --> 00:01:39.190
Or maybe it's just the subset of
our 5,000-member GDG that's

00:01:39.190 --> 00:01:42.210
also in the JUG is
here tonight.

00:01:42.210 --> 00:01:44.490
Anyway, thank you
for all coming.

00:01:44.490 --> 00:01:47.990
I'm actually wearing the old
GTUG logo because this is kind

00:01:47.990 --> 00:01:50.400
of a special meaning, in that
we started the whole GDG

00:01:50.400 --> 00:01:53.400
movement with a joint Java User
Group meeting that Kevin

00:01:53.400 --> 00:01:57.170
and I ran over at the main
campus, to be the very first

00:01:57.170 --> 00:02:00.150
meeting of what we called
Silicon Valley GTUG, Google

00:02:00.150 --> 00:02:02.730
Technology User Group
back then.

00:02:02.730 --> 00:02:04.160
That was over five years ago.

00:02:04.160 --> 00:02:08.160
So this is kind of a blast from
the past, having a joint

00:02:08.160 --> 00:02:09.360
meeting again.

00:02:09.360 --> 00:02:12.730
Only this time, it's the younger
sibling that's now

00:02:12.730 --> 00:02:15.960
grow up to be able to beat
up the older brother.

00:02:15.960 --> 00:02:18.610
And we reached the 5,000
member mark.

00:02:18.610 --> 00:02:22.540
[APPLAUSE]

00:02:22.540 --> 00:02:24.620
So you JUG guys have
got to get working.

00:02:24.620 --> 00:02:26.890
You're only at 3,300.

00:02:26.890 --> 00:02:29.545
There's nothing wrong
with that.

00:02:29.545 --> 00:02:30.770
I know we're really late.

00:02:30.770 --> 00:02:31.720
So want to get this going.

00:02:31.720 --> 00:02:34.120
I do want to give a shout out
to Paul in the front row,

00:02:34.120 --> 00:02:36.230
who's been our Google Developer
Group photographer

00:02:36.230 --> 00:02:38.502
for forever, since
the beginning.

00:02:38.502 --> 00:02:39.918
[APPLAUSE]

00:02:39.918 --> 00:02:41.810
Paul is leaving the area.

00:02:41.810 --> 00:02:42.640
So he came out.

00:02:42.640 --> 00:02:43.990
This is his last meeting.

00:02:43.990 --> 00:02:45.490
So we really appreciate
his help.

00:02:45.490 --> 00:02:48.990
And if someone has photography
skills or would like to be

00:02:48.990 --> 00:02:52.145
doing things like blogging
about our events or on

00:02:52.145 --> 00:02:54.490
Google+, talk to
us about that.

00:02:54.490 --> 00:02:56.055
We'd love to have people helping
us share what we're

00:02:56.055 --> 00:02:56.480
doing here.

00:02:56.480 --> 00:03:02.800
I put on the Meetup, on Twitter,
and on Google+ the

00:03:02.800 --> 00:03:04.170
YouTube link.

00:03:04.170 --> 00:03:06.680
So make sure if you
have friends--

00:03:06.680 --> 00:03:08.890
I'm sure you're going to think
this is a great talk by Hans.

00:03:08.890 --> 00:03:10.440
And you're going to want
other people to see it.

00:03:10.440 --> 00:03:12.240
So share that link with them.

00:03:12.240 --> 00:03:14.210
And I'm going to stop talking.

00:03:14.210 --> 00:03:16.320
Is there anything
I needed to say?

00:03:16.320 --> 00:03:17.390
Turn your phones off.

00:03:17.390 --> 00:03:19.570
Turn your phones off.

00:03:19.570 --> 00:03:21.530
And remember to turn them
on when you come back.

00:03:21.530 --> 00:03:26.640
And we're very fortunate to
have Hans here all the way

00:03:26.640 --> 00:03:27.000
from Germany.

00:03:27.000 --> 00:03:28.497
So give him a big hand.

00:03:28.497 --> 00:03:34.984
[APPLAUSE]

00:03:42.469 --> 00:03:43.467
HANS DOCKTER: Good?

00:03:43.467 --> 00:03:46.650
AUDIENCE: A little higher, on
your collar would be good.

00:04:00.342 --> 00:04:05.560
HANS DOCKTER: Yeah, welcome to
this talk, which tries to

00:04:05.560 --> 00:04:09.310
bridge the people who have an
interest in Android, to people

00:04:09.310 --> 00:04:10.440
who have an interest
in Gradle.

00:04:10.440 --> 00:04:14.330
So my first question would be
who of you is doing Android

00:04:14.330 --> 00:04:15.580
development?

00:04:18.519 --> 00:04:23.730
And who of you is mostly here
to learn about Gradle?

00:04:23.730 --> 00:04:27.275
So I once gave that talk at a
Java Enterprise conference.

00:04:27.275 --> 00:04:29.680
And I thought, hey, this
is really a hot topic.

00:04:29.680 --> 00:04:31.730
And I was asking, who is doing
Android Development, not a

00:04:31.730 --> 00:04:32.690
single hand.

00:04:32.690 --> 00:04:34.440
I was like, hm, ah.

00:04:34.440 --> 00:04:35.875
So this is a really
nice mixture.

00:04:35.875 --> 00:04:38.140
And the other interesting
thing I found out--

00:04:38.140 --> 00:04:41.830
initially, I wasn't aware, in
Europe, how separate those

00:04:41.830 --> 00:04:43.790
communities are.

00:04:43.790 --> 00:04:46.260
So I was talking with them, how
excited we are about the

00:04:46.260 --> 00:04:46.950
Android store.

00:04:46.950 --> 00:04:49.078
And then I was saying stuff
like, oh yeah, we think

00:04:49.078 --> 00:04:51.920
Android will become important.

00:04:51.920 --> 00:04:53.310
So well, you think so?

00:04:53.310 --> 00:04:54.050
Yeah.

00:04:54.050 --> 00:04:58.280
So it's kind of an interesting
experience to see.

00:04:58.280 --> 00:05:01.691
Although, it's Java based, that
there are, at least in

00:05:01.691 --> 00:05:03.890
quite a few areas of the
world, really separate

00:05:03.890 --> 00:05:06.050
communities.

00:05:06.050 --> 00:05:09.970
And I'm excited that we have
a really nice mix here.

00:05:09.970 --> 00:05:11.220
So let's start.

00:05:13.660 --> 00:05:14.910
What is Gradle?

00:05:17.360 --> 00:05:21.950
So Gradle is a general purpose
build and automation tool.

00:05:21.950 --> 00:05:28.195
And we see two axes to describe
where we want to go

00:05:28.195 --> 00:05:29.120
and where we are.

00:05:29.120 --> 00:05:30.580
So one is the horizontal axis.

00:05:30.580 --> 00:05:36.115
It's the platforms we are
already covering or are going

00:05:36.115 --> 00:05:39.470
to cover in the future, so that
would start with Java and

00:05:39.470 --> 00:05:41.230
Google Scholar, now Android.

00:05:41.230 --> 00:05:44.045
We're working with high
intensity of work classes in,

00:05:44.045 --> 00:05:47.596
if that's possible, which will
then also be interesting for

00:05:47.596 --> 00:05:50.500
group and case support, from
an endpoint point of view.

00:05:50.500 --> 00:05:51.670
We have JSON support
for JavaScript.

00:05:51.670 --> 00:05:54.090
iOS, we have some
wrapping around

00:05:54.090 --> 00:05:56.610
xcode.net, not so much yet.

00:05:56.610 --> 00:06:00.470
So that is the horizontal axis,
where we just want to

00:06:00.470 --> 00:06:03.848
appreciate the reality that
the software stacks--

00:06:03.848 --> 00:06:05.680
nowadays, they are
into a genus.

00:06:05.680 --> 00:06:09.530
It's no longer, in the old days,
people were thinking, I

00:06:09.530 --> 00:06:11.200
hate the way genus software
stacks are

00:06:11.200 --> 00:06:12.620
kind of a legacy burden.

00:06:12.620 --> 00:06:16.450
We all know that the software
stacks of the

00:06:16.450 --> 00:06:17.250
future have to be genus.

00:06:17.250 --> 00:06:18.910
And the building of the
information tool has to

00:06:18.910 --> 00:06:19.880
request that fact.

00:06:19.880 --> 00:06:23.580
It has to be able to make all of
those platforms first class

00:06:23.580 --> 00:06:26.550
citizens and not say, OK,
I'm a Java build tool.

00:06:26.550 --> 00:06:28.830
And now, let's somehow try
to squeeze some Glasgow

00:06:28.830 --> 00:06:30.780
support into it.

00:06:30.780 --> 00:06:33.020
So it has to be open for that.

00:06:33.020 --> 00:06:36.506
And Android is a really nice
example of how open the Gradle

00:06:36.506 --> 00:06:38.000
platform is in Java.

00:06:38.000 --> 00:06:39.830
So we'll talk about that.

00:06:39.830 --> 00:06:45.100
So the other axis is what
we call beyond build.

00:06:45.100 --> 00:06:48.730
Yes, originally we have
Build Tool and all--

00:06:48.730 --> 00:06:52.100
so filing, and then creating
[INAUDIBLE].

00:06:52.100 --> 00:06:55.900
But then we have a lot of
functionality for interesting

00:06:55.900 --> 00:06:58.945
testing scenarios, interesting
integration-testing scenarios.

00:06:58.945 --> 00:07:03.640
We now added features where you
can use your local Gradle

00:07:03.640 --> 00:07:06.303
build and use a build forum, to
distribute your integration

00:07:06.303 --> 00:07:08.400
tasks across that build forum.

00:07:08.400 --> 00:07:12.330
Dependency management is another
very important topic.

00:07:12.330 --> 00:07:15.170
We'll talk a little bit about
that later on; configuration

00:07:15.170 --> 00:07:17.680
management; deep CI integration;
the whole

00:07:17.680 --> 00:07:21.020
promotion and releasing and
staging of your software; and

00:07:21.020 --> 00:07:22.280
finally, provisioning.

00:07:22.280 --> 00:07:26.040
So all those areas Gradle plays
a role, sometimes by

00:07:26.040 --> 00:07:28.570
integrating with our tools,
sometimes by natively

00:07:28.570 --> 00:07:29.530
implementing them.

00:07:29.530 --> 00:07:31.306
So just to give you
an overview--

00:07:31.306 --> 00:07:33.508
AUDIENCE: I'm really
sorry to interrupt.

00:07:33.508 --> 00:07:36.164
Someone pointed out in the back.
they can't hear you in

00:07:36.164 --> 00:07:37.990
the back because you're
wearing your mic

00:07:37.990 --> 00:07:39.484
for the live stream.

00:07:39.484 --> 00:07:41.476
This is the mic for
the auditorium.

00:07:41.476 --> 00:07:44.015
And it's a little
bit sensitive.

00:07:44.015 --> 00:07:47.452
If you're a little bit closer
to that, the people in the

00:07:47.452 --> 00:07:48.500
back will be able to hear you.

00:07:48.500 --> 00:07:49.200
I'm sorry about that.

00:07:49.200 --> 00:07:51.300
HANS DOCKTER: It's good
that you mentioned it.

00:07:51.300 --> 00:07:54.538
So usually, people complain that
I'm speaking too loud, at

00:07:54.538 --> 00:07:55.222
least at home.

00:07:55.222 --> 00:07:56.134
[LAUGHING]

00:07:56.134 --> 00:07:58.414
AUDIENCE: Is that OK
in the back now?

00:07:58.414 --> 00:07:59.330
AUDIENCE: Better.

00:07:59.330 --> 00:08:02.550
AUDIENCE: So although it's now
a challenge to watch, to see

00:08:02.550 --> 00:08:04.549
the screen, I will
figure that out.

00:08:04.549 --> 00:08:05.998
AUDIENCE: I'm sorry.

00:08:08.896 --> 00:08:11.610
HANS DOCKTER: Is that
OK in the back?

00:08:11.610 --> 00:08:12.860
Excellent, OK.

00:08:17.660 --> 00:08:22.260
And to give you an overview of
where Gradle is, let's say,

00:08:22.260 --> 00:08:25.820
before Android--

00:08:25.820 --> 00:08:30.915
so Gradle is used for quite a
while in massive production

00:08:30.915 --> 00:08:34.429
builds, NS-40 switched almost
before they switched their

00:08:34.429 --> 00:08:38.360
stack to Gradle, many other
companies, major financial

00:08:38.360 --> 00:08:40.360
institutes.

00:08:40.360 --> 00:08:44.311
One of the biggest investment
banks is using it for 5,000 of

00:08:44.311 --> 00:08:45.220
their developers.

00:08:45.220 --> 00:08:46.270
This is not boasting.

00:08:46.270 --> 00:08:49.660
It's just to give you an idea
of where we are coming from,

00:08:49.660 --> 00:08:51.780
before the Android team
made the decision.

00:08:51.780 --> 00:08:52.870
Hey, let's use Gradle.

00:08:52.870 --> 00:08:55.780
So Gradle is a well-established
technology in

00:08:55.780 --> 00:08:56.816
many areas.

00:08:56.816 --> 00:08:59.710
We had, a couple of weeks ago,
our first conference The

00:08:59.710 --> 00:09:01.530
Gradle Summit, in
the Bay Area.

00:09:01.530 --> 00:09:03.340
We have another one in London
at the end of the year.

00:09:03.340 --> 00:09:06.500
And now, [INAUDIBLE]
is coming.

00:09:06.500 --> 00:09:11.860
So that is basically
where Gradle is.

00:09:11.860 --> 00:09:15.895
And then, we got really excited
that Gradle is going

00:09:15.895 --> 00:09:18.235
to be the new Android
build system.

00:09:18.235 --> 00:09:20.190
So what exactly does it mean?

00:09:20.190 --> 00:09:23.170
Initially, people thought, hey,
Gradle will be used for

00:09:23.170 --> 00:09:24.370
building Android SDK.

00:09:24.370 --> 00:09:27.290
But that's not what this is
about, as most of you know.

00:09:27.290 --> 00:09:29.060
So it's a combination.

00:09:29.060 --> 00:09:32.300
It's basically Gradle+.

00:09:32.300 --> 00:09:35.520
The Android Gradle Plugin that
is maintained by the Google

00:09:35.520 --> 00:09:36.110
Android team.

00:09:36.110 --> 00:09:37.070
It's not maintained by us.

00:09:37.070 --> 00:09:39.730
They are developing that, in
close cooperation with us.

00:09:39.730 --> 00:09:41.890
Last, IDE integration,
a very important

00:09:41.890 --> 00:09:43.330
piece of the puzzle--

00:09:43.330 --> 00:09:47.150
most of you have heard
about Android Studio.

00:09:47.150 --> 00:09:52.000
And that is, by itself,
very exciting.

00:09:52.000 --> 00:09:57.870
But what is also very exciting
for us is that, in cooperation

00:09:57.870 --> 00:10:01.990
with the Android team, we think
it is a showcase for a

00:10:01.990 --> 00:10:03.790
state of the art build system
for any domain.

00:10:03.790 --> 00:10:09.170
There are really cool features
we think should be developed

00:10:09.170 --> 00:10:10.650
the same way for other
platforms.

00:10:10.650 --> 00:10:13.730
And we'll talk about that
during my talk.

00:10:13.730 --> 00:10:14.070
OK.

00:10:14.070 --> 00:10:17.685
So what is so exciting
about that new build

00:10:17.685 --> 00:10:21.110
system, in mind opinion?

00:10:21.110 --> 00:10:26.170
So one thing is, it is
heavily declarative.

00:10:26.170 --> 00:10:28.710
What does it mean,
declarative?

00:10:28.710 --> 00:10:30.230
So you all know.

00:10:30.230 --> 00:10:33.760
And I guess you all
know Maven.

00:10:33.760 --> 00:10:37.560
So an imperative build system is
basically where you-- like

00:10:37.560 --> 00:10:41.390
an and-- in your build script,
you write the target.

00:10:41.390 --> 00:10:42.930
And then you execute
this target.

00:10:42.930 --> 00:10:47.700
So basically, the build author
has the granularity of the

00:10:47.700 --> 00:10:49.080
executional unit.

00:10:49.080 --> 00:10:50.940
That's how you model
your build.

00:10:50.940 --> 00:10:53.910
You use the executional units
and link them together.

00:10:53.910 --> 00:10:55.810
And then you execute them.

00:10:55.810 --> 00:11:00.345
And a declarative build system
is a different animal.

00:11:00.345 --> 00:11:04.250
The build author does not
necessarily work on the

00:11:04.250 --> 00:11:06.500
executional unit path.

00:11:06.500 --> 00:11:11.680
But the build author can use
many extractions, from which

00:11:11.680 --> 00:11:13.740
the executional units
are derived.

00:11:13.740 --> 00:11:15.534
That's an example.

00:11:22.070 --> 00:11:25.160
Oops, sorry.

00:11:25.160 --> 00:11:30.390
So this is a very simple
Gradle built.

00:11:30.390 --> 00:11:31.420
It's empty.

00:11:31.420 --> 00:11:36.130
And if you're now go to the
command line and ask Gradle,

00:11:36.130 --> 00:11:39.130
hey, what can I do
with this build.

00:11:39.130 --> 00:11:41.425
It will tell you there are a
couple of built-in tasks.

00:11:41.425 --> 00:11:42.860
There's a set up task,
where you can

00:11:42.860 --> 00:11:45.056
generate a template project.

00:11:45.056 --> 00:11:47.890
There are tasks where you can
watch dependencies and stuff

00:11:47.890 --> 00:11:51.880
like that, but no
domain-specific tasks.

00:11:51.880 --> 00:12:01.167
You could now do it the end way
and specify the tasks you

00:12:01.167 --> 00:12:02.490
want to execute.

00:12:02.490 --> 00:12:07.520
But when we say it's a
declarative build system, we

00:12:07.520 --> 00:12:09.920
mean that you can do something
like this.

00:12:09.920 --> 00:12:15.960
You say, hey, Gradle, I want to
build an Android project.

00:12:15.960 --> 00:12:19.340
And then you specify a couple
of more properties, like the

00:12:19.340 --> 00:12:22.150
SDK version and the Build
Tools version.

00:12:22.150 --> 00:12:23.090
And that's it.

00:12:23.090 --> 00:12:28.180
With those few lines, you can
now go to Gradle and say, hey

00:12:28.180 --> 00:12:30.060
Gradle, what can I do
with this project.

00:12:33.680 --> 00:12:35.490
And there's now quite
a lot that you can

00:12:35.490 --> 00:12:36.716
do with this project.

00:12:36.716 --> 00:12:39.740
You can assemble it.

00:12:39.740 --> 00:12:41.880
It means building the SDKs.

00:12:41.880 --> 00:12:44.560
You can install them to
a virtual device.

00:12:44.560 --> 00:12:45.670
You can uninstall them.

00:12:45.670 --> 00:12:50.420
You can run all the instrument
tests, et cetera, et cetera.

00:12:50.420 --> 00:12:54.470
So you didn't need to specify
those executionable units.

00:12:54.470 --> 00:12:57.900
And you won't have to specify
each one by one.

00:12:57.900 --> 00:13:02.850
Declarative means you add an
abstraction that automatically

00:13:02.850 --> 00:13:06.580
creates those executionable
units for you.

00:13:06.580 --> 00:13:13.480
And Android is interesting
because even simple Android

00:13:13.480 --> 00:13:17.260
projects are much more complex
than a simple Java project.

00:13:17.260 --> 00:13:21.425
This complexity is hidden,
to some degree.

00:13:21.425 --> 00:13:26.640
So if you now ask Gradle, show
me all of the tasks, all the

00:13:26.640 --> 00:13:31.100
executionable units that I added
after our heading of the

00:13:31.100 --> 00:13:31.740
Android plugin.

00:13:31.740 --> 00:13:37.040
You see there's now a lot
going on, the AID,

00:13:37.040 --> 00:13:39.180
Renderscript functionality, all
the resource processing,

00:13:39.180 --> 00:13:41.040
et cetera, et cetera.

00:13:41.040 --> 00:13:44.060
Android is a very complex
workflow, simple line,

00:13:44.060 --> 00:13:46.048
ProGuard stuff.

00:13:46.048 --> 00:13:49.700
And you all know that.

00:13:49.700 --> 00:13:54.500
And one thing Gradle tries
to do is to hide as much

00:13:54.500 --> 00:13:57.270
complexity as possible for a
normal Android developer.

00:13:57.270 --> 00:14:00.170
So that is what we think are
a normal life cycle phase.

00:14:00.170 --> 00:14:02.790
And usually, you're not
interested in executing the

00:14:02.790 --> 00:14:04.040
zipalign task by itself.

00:14:07.120 --> 00:14:10.480
So we would now say, Gradle,
hey, build everything.

00:14:10.480 --> 00:14:16.400
And everything is up to date,
because I tried it out before.

00:14:16.400 --> 00:14:21.850
And what you end up with
is now all the ATKs

00:14:21.850 --> 00:14:24.000
that you have specified.

00:14:24.000 --> 00:14:27.430
So let's go back.

00:14:27.430 --> 00:14:31.670
And let's think a little bit
about how this works.

00:14:31.670 --> 00:14:34.450
So how could Gradle just
compile that build?

00:14:34.450 --> 00:14:38.380
Well, the Android plugin
is making a couple of

00:14:38.380 --> 00:14:38.810
assumptions.

00:14:38.810 --> 00:14:42.240
It's making, for example, an
assumption where do you put

00:14:42.240 --> 00:14:44.480
your main Android code.

00:14:44.480 --> 00:14:47.580
And what I mean with main code,
I will talk about a

00:14:47.580 --> 00:14:48.910
little bit later.

00:14:48.910 --> 00:14:54.140
So if you stick to the
assumptions like, they live in

00:14:54.140 --> 00:14:56.670
source main Java and source main
assets and source main

00:14:56.670 --> 00:15:00.590
resources and the
AndroidManifest.xml is here.

00:15:00.590 --> 00:15:04.524
Then you don't need to specify
anything of where your code

00:15:04.524 --> 00:15:06.990
lives, when you put your test
in Source, instrumentTest,

00:15:06.990 --> 00:15:10.150
they will be automatically
executed.

00:15:10.150 --> 00:15:14.950
And the same is true for the
output of the build.

00:15:14.950 --> 00:15:20.260
If you now go into the build
directory, you didn't need to

00:15:20.260 --> 00:15:22.210
specify where to
put the stuff.

00:15:22.210 --> 00:15:25.030
So you could have a look
at the APK directory.

00:15:25.030 --> 00:15:25.930
And here we go.

00:15:25.930 --> 00:15:28.460
There you see all the APKs
that are built by Gradle.

00:15:28.460 --> 00:15:30.340
It's all defined
by conventions.

00:15:38.670 --> 00:15:41.560
So that is one thing that
I mean with declarative.

00:15:41.560 --> 00:15:46.170
People who know Maven kind
of get the idea.

00:15:46.170 --> 00:15:50.230
But this is a declarativeness
that you say, this is an

00:15:50.230 --> 00:15:51.180
Android project.

00:15:51.180 --> 00:15:54.020
There's a certain
rigidity in it.

00:15:54.020 --> 00:15:56.420
This saying, this is an Android
project is what we

00:15:56.420 --> 00:16:00.700
call a project-level element
and tells a specific story.

00:16:00.700 --> 00:16:06.350
And the interesting thing with
the Android plugin is that you

00:16:06.350 --> 00:16:10.070
have many ways now to customize
that story.

00:16:10.070 --> 00:16:15.000
And what the Android folks did--
they created a language

00:16:15.000 --> 00:16:20.030
that allows you to elegantly
customize typical variations

00:16:20.030 --> 00:16:23.670
of Android applications
and Android libraries.

00:16:23.670 --> 00:16:27.690
So for example, they introduced
the concept of a

00:16:27.690 --> 00:16:28.350
build type.

00:16:28.350 --> 00:16:29.680
What is a build type?

00:16:29.680 --> 00:16:33.820
A Build Type is an abstraction
that controls

00:16:33.820 --> 00:16:35.970
how an app is built.

00:16:35.970 --> 00:16:40.630
So for every build type, you can
specify additional source

00:16:40.630 --> 00:16:42.540
code and resources.

00:16:42.540 --> 00:16:48.760
So the main code base is used
by any APK that is produced.

00:16:48.760 --> 00:16:52.020
And now you can additionally
specify source code that

00:16:52.020 --> 00:16:53.779
should be only used for
this build type or

00:16:53.779 --> 00:16:54.591
for that build type.

00:16:54.591 --> 00:16:57.780
The Android plugin
automatically, by default,

00:16:57.780 --> 00:17:00.200
adds a debug and release
build type.

00:17:00.200 --> 00:17:03.300
And for example, the debug build
type automatically uses

00:17:03.300 --> 00:17:04.470
the debug signing.

00:17:04.470 --> 00:17:07.040
And of course, the release build
type is not doing that.

00:17:07.040 --> 00:17:08.790
And you can specify different
program options

00:17:08.790 --> 00:17:10.170
and things like that.

00:17:10.170 --> 00:17:12.410
So there are two default
build types.

00:17:12.410 --> 00:17:16.170
But you can define your
own build types.

00:17:16.170 --> 00:17:19.490
One example would
be, Dick Wall,

00:17:19.490 --> 00:17:20.680
from the Scala community.

00:17:20.680 --> 00:17:23.886
He's really interested in
using Scala for Android

00:17:23.886 --> 00:17:25.810
applications.

00:17:25.810 --> 00:17:29.290
And one problem he has-- he
always has to ship the Scala

00:17:29.290 --> 00:17:31.380
library with an Android
application.

00:17:31.380 --> 00:17:37.720
And what he would like to do is,
to make it small, he wants

00:17:37.720 --> 00:17:40.270
to use Proguard to
really shrink it.

00:17:40.270 --> 00:17:45.740
But doing this during
development really reduces the

00:17:45.740 --> 00:17:46.720
performance.

00:17:46.720 --> 00:17:50.805
So what he would like to is he
wants to stick with the debug

00:17:50.805 --> 00:17:53.430
build type that is not doing
any Proguard and with the

00:17:53.430 --> 00:17:55.380
release that is doing
the Proguard stuff.

00:17:55.380 --> 00:17:59.060
But he also wants to introduce a
staging build type, which is

00:17:59.060 --> 00:18:02.055
then used by the QA folks, which
does all the Proguard

00:18:02.055 --> 00:18:04.734
stuff but still has the
Debug Flag and the

00:18:04.734 --> 00:18:06.060
Debug Signing activated.

00:18:06.060 --> 00:18:09.190
So that the QA can work with and
APK that is very close to

00:18:09.190 --> 00:18:10.780
the production APK.

00:18:10.780 --> 00:18:14.180
That is the stuff you can do
with different build types.

00:18:14.180 --> 00:18:16.860
So we look at an example.

00:18:22.790 --> 00:18:30.810
So here you can see another
basic Android project.

00:18:30.810 --> 00:18:33.040
But we do a little
bit more here

00:18:33.040 --> 00:18:37.510
So we, for example, define some
signing configuration.

00:18:37.510 --> 00:18:41.980
It should be used by
the releasable APK.

00:18:41.980 --> 00:18:45.900
We also define an additional
build type, with staging.

00:18:45.900 --> 00:18:49.390
We additionally configured the
debug build type that was

00:18:49.390 --> 00:18:52.575
added by the Android plug in.

00:18:52.575 --> 00:18:55.310
And then we also specify
the test build type.

00:18:55.310 --> 00:19:01.260
We tell the test task, hey, use
this APK, the debug APK

00:19:01.260 --> 00:19:03.990
basically, for running tests.

00:19:03.990 --> 00:19:06.030
We could easily parameterize
that.

00:19:06.030 --> 00:19:08.460
Then we say, on the
local machine, use

00:19:08.460 --> 00:19:09.560
the debug build type.

00:19:09.560 --> 00:19:13.750
On the CI machine, use the
staging build type.

00:19:13.750 --> 00:19:19.170
And if we now go to this
project, we can say, hey

00:19:19.170 --> 00:19:23.260
Gradle, what can I
do with this guy.

00:19:23.260 --> 00:19:27.150
And you now see all the stuff.

00:19:35.844 --> 00:19:36.700
OK, no.

00:19:36.700 --> 00:19:37.990
It is OK, sorry.

00:19:37.990 --> 00:19:41.020
So I missed that.

00:19:41.020 --> 00:19:44.330
So there is an Assemble Staging
task, an Assemble

00:19:44.330 --> 00:19:46.330
Release task, an Assemble
Debug task.

00:19:46.330 --> 00:19:49.750
There is an Install
Staging task.

00:19:49.750 --> 00:19:55.120
So what you get, when you
define this guy here.

00:19:55.120 --> 00:19:57.930
This is a little mini framework
that you apply.

00:19:57.930 --> 00:20:02.840
You say, hey, I have a
staging build type.

00:20:02.840 --> 00:20:05.080
And that triggers a
couple of stuff.

00:20:05.080 --> 00:20:09.640
First of all, it means you
could now create a source

00:20:09.640 --> 00:20:13.410
directory, Source, Staging.

00:20:13.410 --> 00:20:16.030
And it will be automatically
picked up and put into the

00:20:16.030 --> 00:20:18.180
staging APK.

00:20:18.180 --> 00:20:22.190
And it creates a little life
cycle for all the stuff that's

00:20:22.190 --> 00:20:24.390
related to the Staging
build type.

00:20:24.390 --> 00:20:25.340
You can assemble it.

00:20:25.340 --> 00:20:26.760
You can install it.

00:20:26.760 --> 00:20:28.160
You can uninstall it.

00:20:28.160 --> 00:20:30.515
So this is what we call a
dynamic declarative element.

00:20:33.790 --> 00:20:39.880
And imagine you would have to
write this here with ANT.

00:20:39.880 --> 00:20:43.730
And I will bring another
example for that soon.

00:20:43.730 --> 00:20:50.740
So this is one concept that
was added to describe a

00:20:50.740 --> 00:20:54.160
variation of an Android
program.

00:20:54.160 --> 00:20:59.190
And now, another important
concept is Product Flavor.

00:20:59.190 --> 00:21:03.740
So this is a way, as written
there, to generate several

00:21:03.740 --> 00:21:05.150
versions of the same app.

00:21:05.150 --> 00:21:10.160
So you might want to have an
application that is almost the

00:21:10.160 --> 00:21:14.060
same, with some variations for
the free application and the

00:21:14.060 --> 00:21:15.860
paid application.

00:21:15.860 --> 00:21:20.970
And this is a really
flexible context.

00:21:20.970 --> 00:21:26.040
So you can, for example, not
just add specific source code

00:21:26.040 --> 00:21:29.095
and resources to the free and
the paid application.

00:21:29.095 --> 00:21:32.690
You can also add different
kind of dependencies.

00:21:32.690 --> 00:21:36.270
And you can also add different
kinds of check rules.

00:21:36.270 --> 00:21:40.890
You could add a plugin to all
your Android applications, a

00:21:40.890 --> 00:21:46.770
Gradle plugin that says, for all
persons the free Product

00:21:46.770 --> 00:21:50.010
Flavors of my Android
application, do a check

00:21:50.010 --> 00:21:56.360
whether any of the custom
dependencies of that APK is

00:21:56.360 --> 00:21:57.610
commercial.

00:22:00.450 --> 00:22:04.580
So you customize other app
parameters like a target SDK

00:22:04.580 --> 00:22:06.800
version, signing in
for package name,

00:22:06.800 --> 00:22:08.050
and things like that.

00:22:11.150 --> 00:22:12.400
Let's look at an example.

00:22:16.000 --> 00:22:20.820
So here we have added
two Product Flavors

00:22:20.820 --> 00:22:22.150
one is called free.

00:22:22.150 --> 00:22:24.040
The other is called paid.

00:22:24.040 --> 00:22:29.670
And you see, there is now
an optional source free

00:22:29.670 --> 00:22:34.240
directory, which will
be better added.

00:22:34.240 --> 00:22:36.332
The binaries will be added
to the free APK.

00:22:39.281 --> 00:22:43.110
And you see, you can also easily
add tests just for the

00:22:43.110 --> 00:22:48.160
paid variant, for the paid
flavor, by following the

00:22:48.160 --> 00:22:49.330
simple convention.

00:22:49.330 --> 00:22:52.490
Call you directory source
instrumentTestPaid.

00:22:52.490 --> 00:22:54.900
And it will automatically
pick up and be tested.

00:22:54.900 --> 00:22:56.100
That's one of the nice things.

00:22:56.100 --> 00:22:58.220
With the Android plugin, you
don't need any separate

00:22:58.220 --> 00:23:00.090
projects for your tests.

00:23:00.090 --> 00:23:02.940
So tests are part of
the same projects.

00:23:02.940 --> 00:23:05.870
The Android manifest for
the test package is

00:23:05.870 --> 00:23:06.900
automatically generated.

00:23:06.900 --> 00:23:07.920
You don't need to
worry about it.

00:23:07.920 --> 00:23:09.170
It just works.

00:23:11.500 --> 00:23:14.570
And if you think now, what it
would take to write and

00:23:14.570 --> 00:23:18.936
Android build that covers
all those requirements.

00:23:18.936 --> 00:23:22.370
Sorry, an end build, that
would be quite a

00:23:22.370 --> 00:23:23.540
few lines of code.

00:23:23.540 --> 00:23:30.840
So have a look at this guy
and see what he can do.

00:23:34.880 --> 00:23:40.590
And you see there's now some
Cartesian product, right.

00:23:40.590 --> 00:23:44.750
You can assemble the
free debug version.

00:23:44.750 --> 00:23:46.860
You can assemble the free
release version, the free

00:23:46.860 --> 00:23:47.605
staging version.

00:23:47.605 --> 00:23:51.500
You can also say, assembleFree,
which assembles

00:23:51.500 --> 00:23:54.460
all the different variants of
all free version, debug,

00:23:54.460 --> 00:23:56.190
release, and staging.

00:23:56.190 --> 00:24:01.930
And at the same time, you can
also say, assembleStaging,

00:24:01.930 --> 00:24:04.885
which builds the free and the
paid version, for the staging

00:24:04.885 --> 00:24:06.370
build type.

00:24:06.370 --> 00:24:10.650
And the same is true
for tests.

00:24:10.650 --> 00:24:11.710
You have a separate pay test.

00:24:11.710 --> 00:24:13.030
You have a separate free test.

00:24:13.030 --> 00:24:15.746
Usually, you don't need
to bother about that.

00:24:15.746 --> 00:24:20.960
That is happening on the road,
all the test execution.

00:24:20.960 --> 00:24:25.050
So that's way, you think very
elegantly deal with the very

00:24:25.050 --> 00:24:28.730
typical use case, that you have
slight variations of an

00:24:28.730 --> 00:24:29.910
application.

00:24:29.910 --> 00:24:35.650
So who of you is using Maven
for Android development?

00:24:35.650 --> 00:24:40.425
Who of you is using ANT for
Android development?

00:24:40.425 --> 00:24:43.010
Who of you is using no
particular build tool for

00:24:43.010 --> 00:24:44.330
Android development,
just the IDE?

00:24:47.570 --> 00:24:49.190
OK, thanks.

00:24:52.400 --> 00:24:59.790
And if you look at that, if I
went to here, gradle tasks -

00:24:59.790 --> 00:25:03.340
all, I would get quite
an explosion of

00:25:03.340 --> 00:25:07.760
tasks, hundreds of tasks.

00:25:07.760 --> 00:25:09.220
don't need to bother
about that.

00:25:09.220 --> 00:25:12.710
But if I had to do this with a
non-declarative build, there

00:25:12.710 --> 00:25:16.700
are quite a few tasks to
define, like with ANT.

00:25:16.700 --> 00:25:20.960
If I would do that with a
declarative build system that

00:25:20.960 --> 00:25:23.770
doesn't have this model,
this flexibility, I

00:25:23.770 --> 00:25:25.030
would be kind of stuck.

00:25:25.030 --> 00:25:29.280
I would possibly need to create
a separate project for

00:25:29.280 --> 00:25:32.740
every barrier, a project for my
main code base, a project

00:25:32.740 --> 00:25:36.150
for my free code base, for my
release code base, for my

00:25:36.150 --> 00:25:37.720
staging code base.

00:25:37.720 --> 00:25:41.280
Additional projects for the
testing of the main code base,

00:25:41.280 --> 00:25:43.970
for the testing of the free code
base, you get the idea.

00:25:43.970 --> 00:25:45.450
I have a pretty simple Android

00:25:45.450 --> 00:25:47.040
application with some variants.

00:25:47.040 --> 00:25:50.800
And I end up with 40 or 50
sub-projects, which is kind of

00:25:50.800 --> 00:25:52.050
ridiculous.

00:25:57.970 --> 00:25:59.960
And we already used
the terminology.

00:25:59.960 --> 00:26:03.200
So one thing the Android package
is introducing is the

00:26:03.200 --> 00:26:04.445
concept of a Build Variant.

00:26:04.445 --> 00:26:08.480
You have different variants,
as we described.

00:26:08.480 --> 00:26:11.770
And there are rules to manage
the resource overlay.

00:26:11.770 --> 00:26:15.380
So you can overwrite code
and resources of

00:26:15.380 --> 00:26:17.045
the main code base.

00:26:17.045 --> 00:26:18.890
And flavor wins over main.

00:26:18.890 --> 00:26:23.100
And build type wins
over flavor.

00:26:23.100 --> 00:26:26.350
But there's even more
flexibility and power.

00:26:26.350 --> 00:26:30.140
What if you have multiple build
flavors, in terms of

00:26:30.140 --> 00:26:31.660
multiple dimensions
of build flavor.

00:26:31.660 --> 00:26:34.390
Let's say, you have a free and
a paid version for the

00:26:34.390 --> 00:26:37.130
different build types.

00:26:37.130 --> 00:26:41.030
Now, you also have different
versions for ARM and

00:26:41.030 --> 00:26:42.280
inter-processors.

00:26:44.730 --> 00:26:48.190
And that's where there's also
the concept of a Product

00:26:48.190 --> 00:26:50.410
Flavor group.

00:26:50.410 --> 00:26:54.050
So you can add basically as many
dimensions as you want.

00:26:54.050 --> 00:26:58.640
So you can have a free and
a paid version and

00:26:58.640 --> 00:27:01.440
then x86 and ARM.

00:27:01.440 --> 00:27:06.240
So you have now an
additional, more

00:27:06.240 --> 00:27:07.440
complex Cartesian product.

00:27:07.440 --> 00:27:11.730
But it's all very manageable
with because you have the

00:27:11.730 --> 00:27:13.340
proper abstractions to
deal with those.

00:27:13.340 --> 00:27:16.150
And you don't need to deal
with the implementation

00:27:16.150 --> 00:27:21.152
details to build all those
and to test all those.

00:27:21.152 --> 00:27:23.200
Let's look at an example
for those.

00:27:26.210 --> 00:27:31.910
So here we have something a
little bit more abstract.

00:27:31.910 --> 00:27:33.410
So we introduce here the flavor

00:27:33.410 --> 00:27:35.950
groups, group1 and group2.

00:27:35.950 --> 00:27:43.350
And the f1 flavor belongs
to group1.

00:27:43.350 --> 00:27:45.260
The f2 flavor belongs
to group1.

00:27:45.260 --> 00:27:47.580
So that could be
paid and free.

00:27:47.580 --> 00:27:49.550
And the flavor group
could be version.

00:27:49.550 --> 00:27:54.130
fa and fb could be
ARM and x86.

00:27:54.130 --> 00:27:57.833
And the flavor group
could be maybe i or

00:27:57.833 --> 00:27:59.220
something like that.

00:27:59.220 --> 00:28:12.510
And if you now go to this guy
and you ask, what can I do

00:28:12.510 --> 00:28:15.116
with this project.

00:28:15.116 --> 00:28:16.800
It's now quite a bit.

00:28:16.800 --> 00:28:19.530
You see all the different
things you can install.

00:28:19.530 --> 00:28:22.440
And the good thing is, you
always have aggregating tasks.

00:28:22.440 --> 00:28:26.035
You can say, just build me every
APK or build me every

00:28:26.035 --> 00:28:29.530
debug version of all the
different flavors and

00:28:29.530 --> 00:28:33.210
combinations, F1Fa,
F1Fa debug.

00:28:33.210 --> 00:28:34.460
You get the idea.

00:28:41.410 --> 00:28:45.910
So there is also a
library plugin to

00:28:45.910 --> 00:28:47.570
support library projects.

00:28:47.570 --> 00:28:52.260
As part of this new build
system, there is a new form

00:28:52.260 --> 00:28:53.760
for Android libraries.

00:28:53.760 --> 00:28:55.900
It's called AAR.

00:28:55.900 --> 00:28:58.180
And it produces Android
library bundle.

00:28:58.180 --> 00:29:02.020
You can upload them to any Maven
or Ivy repository and to

00:29:02.020 --> 00:29:06.190
contain the compiled code,
resources, and then additional

00:29:06.190 --> 00:29:08.860
Proguard rules, and
stuff like that.

00:29:08.860 --> 00:29:10.850
And it's a first
class citizen.

00:29:10.850 --> 00:29:14.200
You can easily have dependencies
from and Android

00:29:14.200 --> 00:29:16.050
application to an
Android library.

00:29:16.050 --> 00:29:17.550
And of course, Gradle knows
what to do with that.

00:29:20.980 --> 00:29:27.250
So what we have here, what the
Android plugin provides to the

00:29:27.250 --> 00:29:30.640
Android developer
is a rich model.

00:29:30.640 --> 00:29:37.700
And so instead, you have to
think how can I implement the

00:29:37.700 --> 00:29:42.510
Android requirements with the
concept of the build system.

00:29:42.510 --> 00:29:44.020
For example, in ANT,
how do I have to

00:29:44.020 --> 00:29:44.990
create all the targets?

00:29:44.990 --> 00:29:48.750
Or in Maven, how do I have to
create all the subprojects?

00:29:48.750 --> 00:29:50.650
It provides you a
much better way.

00:29:50.650 --> 00:29:53.850
It provides you the language
of the solution space.

00:29:53.850 --> 00:29:56.960
You can just say, hey, this is
how my Android project is

00:29:56.960 --> 00:29:57.315
structured.

00:29:57.315 --> 00:29:58.330
It should look like.

00:29:58.330 --> 00:30:00.030
Those are the flavors.

00:30:00.030 --> 00:30:02.020
And the rest is figured out by
the build system, which is a

00:30:02.020 --> 00:30:08.065
much more efficient way to solve
such a problem-- much

00:30:08.065 --> 00:30:12.930
lower learning curve and much
better maintainability, much

00:30:12.930 --> 00:30:15.630
better visibility.

00:30:15.630 --> 00:30:19.315
So a rich model has
many advantages.

00:30:19.315 --> 00:30:22.700
We will talk more about
the advantages later.

00:30:22.700 --> 00:30:28.680
So you have even pretty complex
scenarios like this

00:30:28.680 --> 00:30:31.060
multi-flavored application I've
shown you, that would

00:30:31.060 --> 00:30:34.900
take thousands of lines
of ANT code.

00:30:34.900 --> 00:30:37.160
You can describe with,
I don't know, with

00:30:37.160 --> 00:30:40.560
something like 30, 40 lines.

00:30:40.560 --> 00:30:44.060
So that's one of the things I
really like with the Android

00:30:44.060 --> 00:30:46.630
plugin, that they are pushing
this concept of a rich

00:30:46.630 --> 00:30:53.040
declarative build system that
models to the main, to a state

00:30:53.040 --> 00:30:54.820
that is very, very convincing.

00:30:54.820 --> 00:30:58.930
I'm very excited about that
because I think that's how a

00:30:58.930 --> 00:31:00.040
build system should work.

00:31:00.040 --> 00:31:01.460
It should provide
your language of

00:31:01.460 --> 00:31:03.080
the solution space.

00:31:03.080 --> 00:31:06.220
Of course, this is all
highly customizable.

00:31:06.220 --> 00:31:10.720
If you have some special
requirements, you can create

00:31:10.720 --> 00:31:14.760
any low-level custom Gradle task
and hook that into you

00:31:14.760 --> 00:31:16.591
lifestyle, whatever
you want to do.

00:31:19.240 --> 00:31:20.250
OK.

00:31:20.250 --> 00:31:27.210
So one other thing that is very
cool about this new build

00:31:27.210 --> 00:31:33.260
system is that it's now also a
base for Android-specific.

00:31:33.260 --> 00:31:34.510
It's Gradle enriched.

00:31:38.730 --> 00:31:40.430
And the Android plug
in is what we

00:31:40.430 --> 00:31:42.820
consider the base plugin.

00:31:42.820 --> 00:31:45.290
It has no implementation
aspect.

00:31:45.290 --> 00:31:46.860
It's just a semantical thing.

00:31:46.860 --> 00:31:47.790
It's a base plugin.

00:31:47.790 --> 00:31:50.480
It's the core plugin for a
specific platform, for the

00:31:50.480 --> 00:31:51.950
Android platform.

00:31:51.950 --> 00:31:57.110
Now, other plugins, like the
Droidcon plugin or other

00:31:57.110 --> 00:32:01.850
testing providers, they can now
write their own plugins

00:32:01.850 --> 00:32:05.170
that hook in with the Android
core plugins.

00:32:05.170 --> 00:32:06.810
So for example the guys
from MoneyMall--

00:32:06.810 --> 00:32:08.810
I don't know who knows
that company.

00:32:08.810 --> 00:32:11.870
This is a company that
provides virtual

00:32:11.870 --> 00:32:15.390
devices in the cloud.

00:32:15.390 --> 00:32:20.200
And so if you write a single
line, applied like in

00:32:20.200 --> 00:32:24.780
MoneyMall, what this plugin
does, it automatically rewires

00:32:24.780 --> 00:32:27.600
how the Android plugin
executes the tests.

00:32:27.600 --> 00:32:31.040
It no longer looks for virtual
devices locally.

00:32:31.040 --> 00:32:35.930
It automatically routes them
into the cloud and executes

00:32:35.930 --> 00:32:37.550
them in parallel.

00:32:37.550 --> 00:32:39.230
And gets the test
reports back.

00:32:39.230 --> 00:32:41.990
So it's completely
test transparent.

00:32:41.990 --> 00:32:43.560
with a one-liner.

00:32:43.560 --> 00:32:48.180
And this is because the Android
core plugin provides

00:32:48.180 --> 00:32:52.960
so many hooks, so that this
other plugin can hook into the

00:32:52.960 --> 00:32:54.800
Android core plugin
and rewire it.

00:32:54.800 --> 00:32:57.560
And say, the testing should, if
you're using MoneyMall, the

00:32:57.560 --> 00:33:00.490
testing should happen a little
bit differently.

00:33:00.490 --> 00:33:07.190
So it is very easy for the
user to make use of the

00:33:07.190 --> 00:33:09.520
Android tooling automation
system.

00:33:09.520 --> 00:33:12.400
So they're are now plugins out
there for Roboelectric, for

00:33:12.400 --> 00:33:14.350
MoneyMall, for Troycon.

00:33:14.350 --> 00:33:17.740
So initially, mostly from the
testing providers, a lot of

00:33:17.740 --> 00:33:19.558
other cool stuff
is yet to come.

00:33:22.700 --> 00:33:29.830
So there are a couple of generic
concepts that are

00:33:29.830 --> 00:33:34.520
brought into the open by the
Gradle Android plugin.

00:33:34.520 --> 00:33:38.050
So one interesting thing is the
source to output mapping.

00:33:41.015 --> 00:33:43.750
In Gradle, you have abstractions
to model a

00:33:43.750 --> 00:33:47.380
logical group of sources.

00:33:47.380 --> 00:33:49.490
And initially, in Gradle, it
was always, you have this

00:33:49.490 --> 00:33:52.250
group of sources, like
some Java directory.

00:33:52.250 --> 00:33:54.760
And there is exactly one
binary, one jar that

00:33:54.760 --> 00:33:55.932
comes out of that.

00:33:55.932 --> 00:33:59.293
With Android, this
is now different.

00:33:59.293 --> 00:34:01.890
You have multiple groups
of sources that should

00:34:01.890 --> 00:34:04.020
end up in one APK.

00:34:04.020 --> 00:34:06.400
And this is a similar concept.

00:34:06.400 --> 00:34:09.920
We're now also using for
our C/C++ support.

00:34:09.920 --> 00:34:12.409
So you have a logical group
of sources, even

00:34:12.409 --> 00:34:14.570
from different languages.

00:34:14.570 --> 00:34:18.270
You have group of C sources and
a group of C++ sources,

00:34:18.270 --> 00:34:21.150
that it should end
up in one binary.

00:34:21.150 --> 00:34:25.150
And of course, what we don't
want you to do is, that you

00:34:25.150 --> 00:34:27.159
have to the wiring yourself.

00:34:27.159 --> 00:34:31.850
So we provide you very nice
abstractions that you can

00:34:31.850 --> 00:34:35.889
assign binaries to different
groups of sources, without

00:34:35.889 --> 00:34:38.310
bothering about how to
compile archiving.

00:34:38.310 --> 00:34:41.380
It's actually taking place.

00:34:41.380 --> 00:34:44.120
Another thing of the source to
output mapping that's also

00:34:44.120 --> 00:34:49.290
from the C/C++ world
is that you have a

00:34:49.290 --> 00:34:50.469
logical group of sources.

00:34:50.469 --> 00:34:53.190
But you want to have multiple
binaries like aesthetic and a

00:34:53.190 --> 00:34:54.949
shared library.

00:34:54.949 --> 00:35:01.600
So this is a concept that was
enriched by the experience

00:35:01.600 --> 00:35:03.890
with the Android plugin.

00:35:03.890 --> 00:35:08.140
The other very exciting
concept is the

00:35:08.140 --> 00:35:08.985
concept of a variant.

00:35:08.985 --> 00:35:11.650
You see this all over
the place, not just

00:35:11.650 --> 00:35:12.520
in the Android world.

00:35:12.520 --> 00:35:14.080
We just were at the client.

00:35:14.080 --> 00:35:17.060
And they had some 20-year-old
legacy software stack.

00:35:17.060 --> 00:35:18.920
And they had exactly
the same problem.

00:35:18.920 --> 00:35:20.630
They had a main core base.

00:35:20.630 --> 00:35:24.430
And then they were shipping
software to different banks.

00:35:24.430 --> 00:35:26.190
Some of the banks were
using WebLogic.

00:35:26.190 --> 00:35:30.450
Others were using WebSphere,
different versions of those

00:35:30.450 --> 00:35:31.950
application containers.

00:35:31.950 --> 00:35:35.380
And they needed to have certain
variations for all of

00:35:35.380 --> 00:35:39.840
those different application
servers.

00:35:39.840 --> 00:35:41.160
It's exactly the same thing.

00:35:41.160 --> 00:35:43.070
There is a main code base.

00:35:43.070 --> 00:35:45.180
And then you have certain
variations.

00:35:45.180 --> 00:35:50.370
Obviously, in the C/C++ world,
this is a core concept, the

00:35:50.370 --> 00:35:53.432
idea of variants.

00:35:53.432 --> 00:35:56.890
And it is the next thing that
is pushed by Android.

00:35:56.890 --> 00:36:00.100
It's the idea of variant-aware
dependency management.

00:36:06.990 --> 00:36:09.690
So if you have different
dependencies between libraries

00:36:09.690 --> 00:36:14.420
and applications in the Android
world, we can use the

00:36:14.420 --> 00:36:16.355
variant information for smart
conflict resolution.

00:36:16.355 --> 00:36:20.630
So we could always decide,
this is the debug APK.

00:36:20.630 --> 00:36:25.540
So this debug APK should also
use the debug variant of the

00:36:25.540 --> 00:36:26.290
depending library.

00:36:26.290 --> 00:36:29.830
You shouldn't be required
to specify that.

00:36:29.830 --> 00:36:33.110
And the same is true
in the C/C++ world.

00:36:33.110 --> 00:36:35.540
So you can find automatically
the affinities that the

00:36:35.540 --> 00:36:38.660
dependencies are assigned
the right way.

00:36:41.990 --> 00:36:44.790
So this was kind of the
modeling aspect

00:36:44.790 --> 00:36:45.900
of the Android plugin.

00:36:45.900 --> 00:36:51.220
But there's also kind of a
deeper aspect why Gradle was

00:36:51.220 --> 00:36:52.090
chosen as the platform.

00:36:52.090 --> 00:36:53.420
And one reason is performance.

00:36:55.990 --> 00:37:00.220
And Android builds can be
heavy on performance.

00:37:00.220 --> 00:37:03.450
And there are many things that
Gradle offers in regard to

00:37:03.450 --> 00:37:04.490
performance.

00:37:04.490 --> 00:37:11.030
So I will just pick on of the
things we like in particular.

00:37:11.030 --> 00:37:13.460
It's the incremental build.

00:37:13.460 --> 00:37:17.830
So the example I'm showing now
is not for Android project.

00:37:17.830 --> 00:37:20.140
It's for a normal
Java project.

00:37:20.140 --> 00:37:22.920
But it's the same concept.

00:37:22.920 --> 00:37:24.440
Sorry, I have to go back.

00:37:24.440 --> 00:37:27.310
So here, we don't say, applied,
like in Java.

00:37:27.310 --> 00:37:29.330
We say applied like
in Android.

00:37:29.330 --> 00:37:32.920
And we stick to certain
conventions, like the

00:37:32.920 --> 00:37:34.760
production code lists
in source main Java.

00:37:34.760 --> 00:37:36.965
The test code list in source
test Java, et cetera.

00:37:36.965 --> 00:37:38.720
It's the same game
as we're playing

00:37:38.720 --> 00:37:39.550
with the Android plugin.

00:37:39.550 --> 00:37:42.950
So this is a very short
build script.

00:37:42.950 --> 00:37:46.991
And now we're using Gradle
to execute that build.

00:37:49.817 --> 00:37:54.660
And we say, Gradle,
do a clean build.

00:37:54.660 --> 00:37:59.100
And everything is built.

00:37:59.100 --> 00:38:00.840
And the next thing,
we're now saying,

00:38:00.840 --> 00:38:02.912
don't do a clean build.

00:38:02.912 --> 00:38:05.250
And see, everything
is up to date.

00:38:05.250 --> 00:38:08.080
So now the question is,
how reliable is that.

00:38:08.080 --> 00:38:09.960
So let's play around
a little bit.

00:38:09.960 --> 00:38:14.340
Let's, for example, change
a production class.

00:38:14.340 --> 00:38:17.145
Let's move a field from
a production class.

00:38:17.145 --> 00:38:18.900
And let's re-execute
the build.

00:38:23.920 --> 00:38:26.010
And you see, Gradle
has figured out.

00:38:26.010 --> 00:38:27.810
Hey, the code has changed.

00:38:27.810 --> 00:38:30.460
So the jar needs
to be rebuilt.

00:38:30.460 --> 00:38:32.680
The test needs to be re-executed
because the class

00:38:32.680 --> 00:38:33.510
passed, whatever.

00:38:33.510 --> 00:38:34.590
For a test has changed.

00:38:34.590 --> 00:38:36.110
The production code has
changed, et cetera.

00:38:36.110 --> 00:38:37.550
So we haven't saved
much time here.

00:38:37.550 --> 00:38:43.230
But at least the incremental
build works reliably.

00:38:43.230 --> 00:38:46.180
So let's do something else.

00:38:46.180 --> 00:38:47.610
Let's remove this comment.

00:38:53.130 --> 00:38:54.690
say, gradle build.

00:38:54.690 --> 00:38:56.690
And now it's interesting.

00:38:56.690 --> 00:39:00.550
Gradle recompiled the sources.

00:39:00.550 --> 00:39:02.710
But the bytecode
hasn't changed.

00:39:02.710 --> 00:39:04.370
So the jar is still
up to date.

00:39:04.370 --> 00:39:07.240
It's the same bytecode as
when you ran it before.

00:39:07.240 --> 00:39:09.410
So therefore, everything
is up to date.

00:39:09.410 --> 00:39:13.050
So that was a nice time
saver, even for

00:39:13.050 --> 00:39:14.680
this very small project.

00:39:14.680 --> 00:39:16.790
And you can even change
properties

00:39:16.790 --> 00:39:17.800
in your build script.

00:39:17.800 --> 00:39:23.180
So let's change the source
compatibility version.

00:39:23.180 --> 00:39:26.660
And if you re-execute that,
Gradle picked that up.

00:39:26.660 --> 00:39:30.170
And everything is to
rebuilt because the

00:39:30.170 --> 00:39:31.326
bytecode has changed.

00:39:31.326 --> 00:39:34.880
And the tests are re-executed.

00:39:34.880 --> 00:39:39.946
So you can also change the
version of junit that you're

00:39:39.946 --> 00:39:44.280
using to run your tests and
compile your tests.

00:39:44.280 --> 00:39:45.730
And this is also picked up.

00:39:45.730 --> 00:39:49.170
And you see everything is up
to date, until you come to

00:39:49.170 --> 00:39:49.960
compiling the tests.

00:39:49.960 --> 00:39:52.730
And that is where the tests
are recompiled because the

00:39:52.730 --> 00:39:55.490
class path has changed.

00:39:55.490 --> 00:39:57.580
So it is sensitive in
regard to input.

00:39:57.580 --> 00:40:00.330
It is also sensitive in
regard to the output.

00:40:00.330 --> 00:40:04.160
So if you remove, for example,
a compact class and you rerun

00:40:04.160 --> 00:40:09.710
the build, what you can see
is, the classes were

00:40:09.710 --> 00:40:09.830
recompiled.

00:40:09.830 --> 00:40:11.950
But the bytecode
hasn't changed.

00:40:11.950 --> 00:40:14.650
So all the rest is
still up to date.

00:40:17.430 --> 00:40:23.810
So an interesting question is
now, how can you use that if

00:40:23.810 --> 00:40:26.490
you have custom build logic.

00:40:26.490 --> 00:40:30.510
So let's say you have
some XML file.

00:40:30.510 --> 00:40:33.700
And the requirement you're
having is, you want to create,

00:40:33.700 --> 00:40:37.230
for every node of this XML file,
for every mountain node,

00:40:37.230 --> 00:40:40.390
you want to create a text file
where the name of the mountain

00:40:40.390 --> 00:40:41.230
is the name of the text file.

00:40:41.230 --> 00:40:43.160
And the height of the
mountain is the

00:40:43.160 --> 00:40:45.630
content of the text file.

00:40:45.630 --> 00:40:52.310
So let's create some logic for
this in the gradle build.

00:40:52.310 --> 00:40:55.050
So we create a task,
generateMountainFiles.

00:40:55.050 --> 00:41:00.750
And we have some scripting logic
that passes the XML file

00:41:00.750 --> 00:41:02.040
and creates the text files.

00:41:02.040 --> 00:41:04.850
We don't need to go
into the details.

00:41:04.850 --> 00:41:08.450
Now, one thing that
is very handy.

00:41:08.450 --> 00:41:12.840
You can do [INAUDIBLE] case task
execution, also for all

00:41:12.840 --> 00:41:14.340
the tasks you've seen before.

00:41:14.340 --> 00:41:18.000
So if you say, GMF, Gradle
will find the appropriate

00:41:18.000 --> 00:41:21.140
task, in that case,
generateMountainFiles.

00:41:21.140 --> 00:41:28.340
So if we now look, we
need to refresh.

00:41:28.340 --> 00:41:31.100
There's now Mountains directory,
with a K2 text and

00:41:31.100 --> 00:41:32.916
a Mount Everest text.

00:41:32.916 --> 00:41:35.020
Don't bother about
the numbers.

00:41:35.020 --> 00:41:36.270
They're wrong.

00:41:39.540 --> 00:41:43.690
And now, the question is,
if I we execute this--

00:41:43.690 --> 00:41:46.140
and I haven't changed
anything--

00:41:46.140 --> 00:41:47.120
will it be up to date.

00:41:47.120 --> 00:41:48.030
Or will it be not up to date?

00:41:48.030 --> 00:41:50.950
What do you think?

00:41:50.950 --> 00:41:52.810
I haven't changed anything
of the input.

00:41:52.810 --> 00:41:55.440
And we're claiming Gradle
has incremental build

00:41:55.440 --> 00:41:55.920
functionality.

00:41:55.920 --> 00:42:01.560
So let's see.

00:42:01.560 --> 00:42:05.340
No, Gradle regenerated
the mountain files.

00:42:05.340 --> 00:42:07.750
It regenerated again.

00:42:07.750 --> 00:42:10.540
So what is going wrong here?

00:42:10.540 --> 00:42:15.393
So well, we also
have a company.

00:42:15.393 --> 00:42:16.730
We have Gradleware.

00:42:16.730 --> 00:42:21.530
And incremental build for custom
build logic, is it

00:42:21.530 --> 00:42:21.940
commercial?

00:42:21.940 --> 00:42:24.190
No.

00:42:24.190 --> 00:42:25.440
It's not.

00:42:27.310 --> 00:42:34.095
So one thing we don't like here
is, we don't want to see

00:42:34.095 --> 00:42:38.050
too much scripting logic in our
build script, mixed with

00:42:38.050 --> 00:42:39.990
the declarative parts
of the build.

00:42:39.990 --> 00:42:46.200
So what we do now, initially, we
extract the logic into what

00:42:46.200 --> 00:42:48.110
we call the custom task.

00:42:48.110 --> 00:42:51.470
We call it ConvertMountainXml.

00:42:51.470 --> 00:42:56.740
And we specify the properties
of this custom task to XML5,

00:42:56.740 --> 00:43:00.830
which is the mountains XML file,
the separator in the

00:43:00.830 --> 00:43:02.290
text file, the output directory,
which is the

00:43:02.290 --> 00:43:03.770
mountains directory.

00:43:03.770 --> 00:43:07.980
And then we specify the task
action, which is basically the

00:43:07.980 --> 00:43:10.190
same logic as above.

00:43:10.190 --> 00:43:15.360
And now, we are changing this
and saying, this task is now

00:43:15.360 --> 00:43:17.910
from type ConvertMountainXml.

00:43:17.910 --> 00:43:22.980
And we specify now
the properties.

00:43:22.980 --> 00:43:25.720
So it's the mountains directory
where the mountain

00:43:25.720 --> 00:43:27.390
text file should be placed.

00:43:27.390 --> 00:43:30.680
the XML file that needs
to be passed, the

00:43:30.680 --> 00:43:32.760
input file into separator.

00:43:32.760 --> 00:43:39.940
So if we now execute this build,
let's do a clean build

00:43:39.940 --> 00:43:41.280
as a start.

00:43:41.280 --> 00:43:46.540
And if we now re-execute it,
what you can see is, now

00:43:46.540 --> 00:43:48.100
everything is up to date.

00:43:48.100 --> 00:43:49.170
And how does it work?

00:43:49.170 --> 00:43:55.540
Well, let's first check
whether they are still

00:43:55.540 --> 00:43:57.310
product, the mountain,
the text files.

00:43:57.310 --> 00:43:58.080
Yes.

00:43:58.080 --> 00:43:59.830
Let's change a number in here.

00:44:02.910 --> 00:44:04.040
Let's re-execute.

00:44:04.040 --> 00:44:06.310
And you see, this change
was detected.

00:44:06.310 --> 00:44:08.100
And the mountains files
were regenerated.

00:44:08.100 --> 00:44:10.810
If I execute it again,
it's up to date.

00:44:10.810 --> 00:44:15.700
And you can, for example, also
change separator value.

00:44:18.610 --> 00:44:24.610
If you now have a look,
this change in the

00:44:24.610 --> 00:44:26.190
property was detected.

00:44:26.190 --> 00:44:29.800
And the separator is
now a semicolon.

00:44:29.800 --> 00:44:31.280
So how does this work?

00:44:33.908 --> 00:44:36.280
Well, it's extremely simple.

00:44:36.280 --> 00:44:38.400
You just need annotate
the properties

00:44:38.400 --> 00:44:39.840
of your custom task.

00:44:39.840 --> 00:44:40.940
This is an input file.

00:44:40.940 --> 00:44:41.745
This is an input property.

00:44:41.745 --> 00:44:43.600
This is the output directory.

00:44:43.600 --> 00:44:44.770
That's all you need to do.

00:44:44.770 --> 00:44:46.690
You don't need to tell Gradle
anything about the incremental

00:44:46.690 --> 00:44:47.845
build or whatever.

00:44:47.845 --> 00:44:52.300
Just what are the input and
outputs of your task?

00:44:52.300 --> 00:44:55.280
And from that, Gradle can do
all the smartness that is

00:44:55.280 --> 00:44:58.105
necessary to provide you with
an incremental build.

00:44:58.105 --> 00:45:00.260
But it also provides you
some other logic.

00:45:00.260 --> 00:45:08.090
For example, you get
automatically validation of

00:45:08.090 --> 00:45:10.270
your input value.

00:45:10.270 --> 00:45:13.910
So if you specify this check,
you don't need to code in your

00:45:13.910 --> 00:45:14.730
custom task.

00:45:14.730 --> 00:45:17.080
It is automatically done
because you specified a

00:45:17.080 --> 00:45:20.040
property as an input value.

00:45:20.040 --> 00:45:20.350
OK.

00:45:20.350 --> 00:45:23.510
So there's another thing
that came out

00:45:23.510 --> 00:45:27.190
all the Android effort.

00:45:27.190 --> 00:45:29.930
Initially, the incremental build
function in Gradle was a

00:45:29.930 --> 00:45:32.700
binary function.

00:45:32.700 --> 00:45:37.750
So Gradle was telling a task,
either nothing has changed.

00:45:37.750 --> 00:45:39.290
So you don't need
to do anything.

00:45:39.290 --> 00:45:41.206
Or something has changed.

00:45:41.206 --> 00:45:43.730
So you need to redo
everything.

00:45:43.730 --> 00:45:45.520
It was a binary thing.

00:45:45.520 --> 00:45:49.030
And what we added as part of the
Android cooperation, there

00:45:49.030 --> 00:45:50.330
is now an API.

00:45:50.330 --> 00:45:54.265
So if you write a task that
can be very smart

00:45:54.265 --> 00:45:56.180
if stuff has changed.

00:45:56.180 --> 00:45:57.250
You can now ask Gradle.

00:45:57.250 --> 00:46:01.880
When the generic incremental
build in Gradle figures out

00:46:01.880 --> 00:46:05.380
something has changed, it passes
you the information of

00:46:05.380 --> 00:46:08.640
what exactly has changed of
what exactly was removed,

00:46:08.640 --> 00:46:10.270
since you last ran the build.

00:46:10.270 --> 00:46:13.450
And then you can be really
smart and say, OK.

00:46:13.450 --> 00:46:17.280
I only need to generate the
stuff that has changed.

00:46:21.970 --> 00:46:23.520
Another thing we do for
the performance

00:46:23.520 --> 00:46:25.250
is the Gradle Daemon.

00:46:25.250 --> 00:46:27.356
The Gradle Daemon is a
long-running process.

00:46:30.820 --> 00:46:34.730
So when you use Gradle with
the Gradle Daemon, a

00:46:34.730 --> 00:46:37.670
long-running JBM is created
with a warmed up Gradle.

00:46:37.670 --> 00:46:40.950
And when you execute the build
a second, third or fourth

00:46:40.950 --> 00:46:43.890
time, the responsiveness
will be each better.

00:46:43.890 --> 00:46:46.570
Especially when you work with
dynamic languages that need

00:46:46.570 --> 00:46:50.900
some warm up time, then it is
a very important feature.

00:46:50.900 --> 00:46:51.160
OK.

00:46:51.160 --> 00:46:56.610
There are some other reasons why
Android chose Gradle for

00:46:56.610 --> 00:46:57.580
the Android build system.

00:46:57.580 --> 00:47:00.750
It's that it's already a
platform, like the incremental

00:47:00.750 --> 00:47:04.710
build, that provides a lot
of interesting services.

00:47:04.710 --> 00:47:08.130
And I want to show you
one of those services

00:47:08.130 --> 00:47:09.680
that is really cool.

00:47:09.680 --> 00:47:12.825
And I guess most of you
are using, as soon as

00:47:12.825 --> 00:47:14.640
you're using Gradle.

00:47:14.640 --> 00:47:17.520
So in Gradle, we have the
concept of a wrapper.

00:47:17.520 --> 00:47:22.560
So for any Gradle, Android,
Java, whatever, you can

00:47:22.560 --> 00:47:24.430
specify a wrapper task.

00:47:24.430 --> 00:47:26.410
It's a one-liner basically.

00:47:26.410 --> 00:47:28.760
In the latest version of Gradle,
you don't even need to

00:47:28.760 --> 00:47:30.280
specify it in the
build script.

00:47:30.280 --> 00:47:32.550
It's automatically available.

00:47:32.550 --> 00:47:37.710
And as the build master, you can
do and the following, you

00:47:37.710 --> 00:47:40.920
can execute this wrapper task.

00:47:40.920 --> 00:47:46.790
And what wrapper task does, it
creates a couple of files in

00:47:46.790 --> 00:47:49.080
the route directory
of your project--

00:47:49.080 --> 00:47:55.580
gradlew, gradlew.bat, and the
directory, gradle-wrapper,

00:47:55.580 --> 00:47:58.340
with a gradle-wrapper.jar, which
only has a couple of

00:47:58.340 --> 00:47:59.792
kilobytes and gradle-wrapper
properties.

00:48:03.350 --> 00:48:06.620
So what you're doing with
those four files, you're

00:48:06.620 --> 00:48:08.788
committing them to
version control.

00:48:11.850 --> 00:48:16.730
And the next time someone checks
out version control and

00:48:16.730 --> 00:48:19.430
wants to build this project,
this person doesn't need to

00:48:19.430 --> 00:48:21.450
have Gradle installed.

00:48:21.450 --> 00:48:24.480
This person can just use
the gradlew script.

00:48:24.480 --> 00:48:28.280
And then Gradle will be
automatically downloaded for

00:48:28.280 --> 00:48:32.985
them, with the URL specified
in the Gradle wrapper

00:48:32.985 --> 00:48:33.930
properties file.

00:48:33.930 --> 00:48:35.705
And the build will work.

00:48:35.705 --> 00:48:38.380
And the next time, of course,
Gradle won't be downloaded

00:48:38.380 --> 00:48:40.900
another time because it's
in a local cache.

00:48:40.900 --> 00:48:44.395
So if you want that all your
team is upgrading to a new

00:48:44.395 --> 00:48:47.520
version of Gradle, you just
change the distribution URL,

00:48:47.520 --> 00:48:49.440
commit it to version control.

00:48:49.440 --> 00:48:54.060
The next time some of your
developers do a check out and

00:48:54.060 --> 00:48:56.350
run the build, they will
automatically pick up the

00:48:56.350 --> 00:48:57.740
newest version of Gradle.

00:48:57.740 --> 00:48:58.505
So you have zero administration

00:48:58.505 --> 00:48:59.364
on the client side.

00:48:59.364 --> 00:49:01.340
That's one aspect of that.

00:49:01.340 --> 00:49:04.910
The other aspect of that
is historical build,

00:49:04.910 --> 00:49:06.750
reproducible builds.

00:49:06.750 --> 00:49:10.010
So we have client in the
medical industry.

00:49:10.010 --> 00:49:16.160
And I guess Android is more
and more into also I think

00:49:16.160 --> 00:49:19.340
mission-critical areas.

00:49:19.340 --> 00:49:22.970
They get auditing once a year.

00:49:22.970 --> 00:49:28.030
And if they can't show that
they're able reproducibly

00:49:28.030 --> 00:49:32.060
build their software, they have
to call back all of the

00:49:32.060 --> 00:49:34.810
medical devices they have
sold to the hospitals.

00:49:34.810 --> 00:49:38.080
They are no longer allowed
to have them in use.

00:49:38.080 --> 00:49:42.826
So for them, reproducibility is
a mission-critical aspect.

00:49:42.826 --> 00:49:45.910
Financial industries, there
are sometimes similar

00:49:45.910 --> 00:49:48.460
requirements.

00:49:48.460 --> 00:49:50.180
It depends on the domain,
whether this is an interesting

00:49:50.180 --> 00:49:54.140
feature or not, the
reproducibility aspect of it.

00:49:54.140 --> 00:49:56.495
In any case, it's very
convenient, whatever domain

00:49:56.495 --> 00:49:57.745
you are working with.

00:50:05.360 --> 00:50:10.470
Another thing that is
interesting is the concept of

00:50:10.470 --> 00:50:12.410
init scripts in Gradle.

00:50:12.410 --> 00:50:21.530
So if you have multiple projects
that share similar

00:50:21.530 --> 00:50:23.310
configuration information.

00:50:23.310 --> 00:50:25.350
Like here, we have a project
that is called

00:50:25.350 --> 00:50:27.240
testing with Gradle.

00:50:27.240 --> 00:50:30.880
And we specified the location
where to retrieve the

00:50:30.880 --> 00:50:32.470
dependencies from.

00:50:32.470 --> 00:50:37.560
What we did now, we removed
that information.

00:50:37.560 --> 00:50:42.770
And we now created an init
script, what we call an init

00:50:42.770 --> 00:50:45.385
script, where we put that
information in.

00:50:45.385 --> 00:50:48.790
Get your dependencies
from Maven central.

00:50:48.790 --> 00:50:53.330
So what we can do now on the
command line is, we can say,

00:50:53.330 --> 00:50:57.380
hey Gradle, run this build.

00:50:57.380 --> 00:51:02.400
And this build would
fail without--

00:51:02.400 --> 00:51:06.560
if we wouldn't specify the -i
init script, the build would

00:51:06.560 --> 00:51:08.415
fail because it wouldn't
know where to get the

00:51:08.415 --> 00:51:09.340
dependencies from.

00:51:09.340 --> 00:51:12.890
But with this init script, you
can inject this information

00:51:12.890 --> 00:51:16.350
into any Gradle build.

00:51:16.350 --> 00:51:21.722
And the build works
and runs the test.

00:51:21.722 --> 00:51:25.900
And one thing I want to use
to show you is, Gradle is

00:51:25.900 --> 00:51:27.650
extremely customizable.

00:51:27.650 --> 00:51:33.930
You can put amazing stuff into
the script, to do really deep

00:51:33.930 --> 00:51:34.740
customization.

00:51:34.740 --> 00:51:41.070
So for example, let's assume
what you want to do is say, I

00:51:41.070 --> 00:51:46.030
want to issue a warning to my
developers, if any of their

00:51:46.030 --> 00:51:50.420
tests is taking longer
than 20 milliseconds.

00:51:50.420 --> 00:51:53.660
So how would you do that with
other build systems?

00:51:53.660 --> 00:51:56.490
With Gradle, you can do
the following way.

00:51:56.490 --> 00:52:00.550
You can't say, in the init
script, give me the Gradle

00:52:00.550 --> 00:52:03.140
object which represents
the build wrap time.

00:52:03.140 --> 00:52:06.690
And then you say, hey Gradle,
after you have evaluated all

00:52:06.690 --> 00:52:12.800
the projects, give me
the route project.

00:52:12.800 --> 00:52:15.520
In the simple builds we
have seen so far,

00:52:15.520 --> 00:52:16.730
there is only one project.

00:52:16.730 --> 00:52:17.760
There is only a route project.

00:52:17.760 --> 00:52:21.130
But you can, in Gradle, have
mighty module builds, where

00:52:21.130 --> 00:52:23.490
you have multiple project
in one build.

00:52:23.490 --> 00:52:28.305
And then you say, iterate
over all the projects.

00:52:28.305 --> 00:52:32.430
And for all the test tasks, I
want to hook in a listener

00:52:32.430 --> 00:52:35.720
into the test task.

00:52:35.720 --> 00:52:39.730
So this listener is
called after test.

00:52:39.730 --> 00:52:44.550
So Gradle now calls this
hook after it has

00:52:44.550 --> 00:52:47.910
executed the test method.

00:52:47.910 --> 00:52:50.090
And it gives you the results.

00:52:50.090 --> 00:52:52.710
And you can then calculate
the time it took to

00:52:52.710 --> 00:52:55.070
execute that test.

00:52:55.070 --> 00:52:57.810
And if the time is
greater than 20

00:52:57.810 --> 00:52:59.490
milliseconds, issue a warning.

00:53:02.770 --> 00:53:04.020
OK.

00:53:08.060 --> 00:53:12.300
So let's see whether
this works.

00:53:14.880 --> 00:53:17.040
And here we go.

00:53:17.040 --> 00:53:19.977
In real time, you get the
warning that the tests are

00:53:19.977 --> 00:53:23.050
long running, with a
few lines of code.

00:53:23.050 --> 00:53:24.450
And you can do interesting
stuff.

00:53:24.450 --> 00:53:28.502
You could, for example, say,
I want to the let the build

00:53:28.502 --> 00:53:29.940
fail, if the tests
are long running.

00:53:29.940 --> 00:53:32.750
But I only want to do this on
continuous integration,

00:53:32.750 --> 00:53:35.130
because there I have a
defined environment.

00:53:35.130 --> 00:53:39.800
You can use this injection
principal that you inject

00:53:39.800 --> 00:53:43.435
additional behavior, depending
on which platform you're

00:53:43.435 --> 00:53:46.960
running-- either local build or
the continuous integration

00:53:46.960 --> 00:53:50.865
build or the build that
is the release build.

00:53:50.865 --> 00:53:53.110
Yet that gives you a
lot of flexibility.

00:53:53.110 --> 00:53:57.200
And the example shows how deep
you can enter the guts of

00:53:57.200 --> 00:54:02.210
Gradle runtime to get
information, to help the AVR,

00:54:02.210 --> 00:54:04.200
et cetera, et cetera.

00:54:04.200 --> 00:54:10.370
We had a user and now we have
multiple users, actually, they

00:54:10.370 --> 00:54:14.430
have a lot of problems with
fragile integration tests.

00:54:14.430 --> 00:54:16.040
And they had one with
a couple of very

00:54:16.040 --> 00:54:17.910
important integration tests.

00:54:17.910 --> 00:54:20.680
And the rule for them was,
if they fail the

00:54:20.680 --> 00:54:22.540
first time, it's OK.

00:54:22.540 --> 00:54:25.010
If they fail a second
time, then it's

00:54:25.010 --> 00:54:26.000
considered a failure.

00:54:26.000 --> 00:54:28.030
Otherwise, it's considered
a success.

00:54:28.030 --> 00:54:30.350
You can't help laughing
about this company.

00:54:30.350 --> 00:54:34.250
But it's a hard problem
sometimes to solve.

00:54:34.250 --> 00:54:37.330
One of the team members there
was Szczepan Faber, the

00:54:37.330 --> 00:54:38.250
founder of Mockito.

00:54:38.250 --> 00:54:42.182
You don't have to tell him
about testing and being a

00:54:42.182 --> 00:54:42.820
smart developer.

00:54:42.820 --> 00:54:45.850
They couldn't change it, also
for the reason that it was a

00:54:45.850 --> 00:54:46.630
different team.

00:54:46.630 --> 00:54:48.350
It was related to
infrastructure.

00:54:48.350 --> 00:54:51.140
So those are sometimes the
realities you run into in

00:54:51.140 --> 00:54:51.800
enterprise.

00:54:51.800 --> 00:54:53.880
You can say, this is not
a good situation.

00:54:53.880 --> 00:54:55.110
Well, we all know that.

00:54:55.110 --> 00:54:56.916
But that doesn't help
you in that moment.

00:54:56.916 --> 00:55:02.180
You need a tune that is humble
and say, OK, I'll give you a

00:55:02.180 --> 00:55:03.488
took kit to solve that.

00:55:03.488 --> 00:55:09.150
Don't ask us to put, in the
Gradle API, a new method--

00:55:12.450 --> 00:55:15.360
succeed after two failures
or something like that.

00:55:15.360 --> 00:55:17.090
We won't do that.

00:55:17.090 --> 00:55:19.730
Your pathologies won't pollute
the Gradle API.

00:55:19.730 --> 00:55:23.700
But you can use the tool kit
to solve this problem.

00:55:23.700 --> 00:55:28.680
And as soon as you're in
a more complex delivery

00:55:28.680 --> 00:55:33.290
scenario, there's always
unanticipated stuff happening.

00:55:33.290 --> 00:55:37.950
And you don't need a tool that
thinks it knows how the world

00:55:37.950 --> 00:55:38.820
looks like for you.

00:55:38.820 --> 00:55:42.680
You need a humble tool that
provides you opinions, out of

00:55:42.680 --> 00:55:44.460
the box behavior.

00:55:44.460 --> 00:55:47.080
But when you really need it,
must provide you a tool kit to

00:55:47.080 --> 00:55:48.600
solve you custom problems.

00:55:48.600 --> 00:55:50.625
And at least not stand
in the way.

00:55:50.625 --> 00:55:53.680
And even better, it should make
it very efficient for you

00:55:53.680 --> 00:55:57.370
to solve those problems.

00:55:57.370 --> 00:56:00.420
And this goes one step further,
this concept.

00:56:00.420 --> 00:56:05.860
What you can do with this init
script, you can now go to your

00:56:05.860 --> 00:56:08.490
local Gradle distribution.

00:56:08.490 --> 00:56:12.100
And every Gradle distribution
has an init.d directory.

00:56:12.100 --> 00:56:15.990
And in this init.d directory,
you can put an arbitrary

00:56:15.990 --> 00:56:17.240
amount of init scripts.

00:56:20.360 --> 00:56:22.070
And we're doing this
right now.

00:56:26.840 --> 00:56:34.860
And if we now run this project,
we see this init

00:56:34.860 --> 00:56:38.590
script is now automatically
applied.

00:56:38.590 --> 00:56:41.770
You can now argue, with
good reasons.

00:56:41.770 --> 00:56:44.540
I don't want to mess around
with my local Gradle

00:56:44.540 --> 00:56:45.160
distribution.

00:56:45.160 --> 00:56:47.330
Especially people used to
wrapper, they don't even know

00:56:47.330 --> 00:56:49.360
where it's located.

00:56:49.360 --> 00:56:52.380
So this is now the interesting
thing.

00:56:52.380 --> 00:56:57.070
You can use the Gradle wrapper
and can let the Gradle wrapper

00:56:57.070 --> 00:57:02.210
point to a Gradle distribution
on a shared network drive, on

00:57:02.210 --> 00:57:07.000
your binary repository manager,
with init scripts

00:57:07.000 --> 00:57:10.380
that preconfigure your local
build environment.

00:57:10.380 --> 00:57:11.250
You get the idea.

00:57:11.250 --> 00:57:13.530
And then when the developers
use the Gradle wrappers

00:57:13.530 --> 00:57:15.650
scripts, they'll automatically
download to Gradle

00:57:15.650 --> 00:57:18.460
distribution with your init
scripts, where you can do all

00:57:18.460 --> 00:57:19.190
kinds of stuff.

00:57:19.190 --> 00:57:23.250
You can redefine where to get
the dependencies from.

00:57:23.250 --> 00:57:29.360
You can specify rules, whatever
you want, with the

00:57:29.360 --> 00:57:31.445
deep API that Gradle
provides you.

00:57:31.445 --> 00:57:34.400
So no build wikis, the
developers have to read how to

00:57:34.400 --> 00:57:36.630
set up their local build
environment.

00:57:36.630 --> 00:57:38.170
It will just work.

00:57:38.170 --> 00:57:40.780
So the init scripts and the
init.d directory, in

00:57:40.780 --> 00:57:42.730
conjunction with the wrapper,
is a really, really cool

00:57:42.730 --> 00:57:47.510
feature, and much appreciated,
especially by

00:57:47.510 --> 00:57:48.760
the enterprise users.

00:57:52.420 --> 00:57:55.440
You can also nail down other
aspects of your build

00:57:55.440 --> 00:57:57.262
environment.

00:57:57.262 --> 00:57:58.060
The JVMArchs.

00:57:58.060 --> 00:58:03.475
used by the Gradle build
tool or with Java

00:58:03.475 --> 00:58:05.010
version need to be used.

00:58:05.010 --> 00:58:07.140
So you can put this also
in version control.

00:58:07.140 --> 00:58:09.840
With other build tools, you have
to create an ANT ops or

00:58:09.840 --> 00:58:12.740
Maven ops environment variable,
which is global and

00:58:12.740 --> 00:58:15.160
which is not in version control,
which you have to

00:58:15.160 --> 00:58:16.300
describe in the build wiki.

00:58:16.300 --> 00:58:19.060
Every developer has to set that
environment variable.

00:58:19.060 --> 00:58:21.060
In Gradle, you just put
a Gradle properties

00:58:21.060 --> 00:58:22.380
file in your project.

00:58:22.380 --> 00:58:23.710
And those properties
are defined.

00:58:23.710 --> 00:58:25.060
They are version controlled.

00:58:25.060 --> 00:58:29.310
And the developers don't even
need to be aware of that.

00:58:29.310 --> 00:58:30.650
OK.

00:58:30.650 --> 00:58:35.730
Another interesting aspect of
the Android plugin is the deep

00:58:35.730 --> 00:58:37.920
IDE integration.

00:58:37.920 --> 00:58:39.280
So what is that about?

00:58:43.030 --> 00:58:46.200
A major thing the Android folks
wanted to resolve is

00:58:46.200 --> 00:58:48.880
that they basically had to
maintain, for Android, two

00:58:48.880 --> 00:58:50.340
build systems.

00:58:50.340 --> 00:58:54.470
One was the ANT-based build
system that you would be using

00:58:54.470 --> 00:58:56.280
on a continuous integration
machine.

00:58:56.280 --> 00:59:00.360
The other was the build system
they had to provide with the

00:59:00.360 --> 00:59:04.430
ADT tooling, two different
build systems.

00:59:04.430 --> 00:59:05.830
Because the IDE was
not delegating

00:59:05.830 --> 00:59:06.960
to any build system.

00:59:06.960 --> 00:59:09.298
It was doing the build
action themselves.

00:59:09.298 --> 00:59:16.720
And this is problematic and
has a lot of problems, for

00:59:16.720 --> 00:59:17.970
multiple reasons.

00:59:19.970 --> 00:59:21.740
So one is--

00:59:21.740 --> 00:59:24.640
and if let the IDE not
do any build actions.

00:59:24.640 --> 00:59:29.340
But the IDE would reach out
to the build system to do

00:59:29.340 --> 00:59:31.380
whatever needs to be
done, compiling,

00:59:31.380 --> 00:59:34.040
texting, testing, et cetera.

00:59:34.040 --> 00:59:37.080
Then you still have the
richness of an IDE.

00:59:37.080 --> 00:59:40.340
But the feedback you get from
the IDE is close to the

00:59:40.340 --> 00:59:41.970
canonical build that runs on
continuous integration.

00:59:44.700 --> 00:59:48.510
Separate jobs for different
build variants, depending on

00:59:48.510 --> 00:59:52.990
how long the tests are running
or how many tests they have,

00:59:52.990 --> 00:59:57.120
we will provide you, like for
the IDEs, a model for Jenkins,

00:59:57.120 --> 01:00:02.280
that you can, in very smart
ways, programmatically script

01:00:02.280 --> 01:00:04.580
the job setup in Jenkins.

01:00:04.580 --> 01:00:08.160
That's really good stuff.

01:00:08.160 --> 01:00:10.130
So we talked about that.

01:00:10.130 --> 01:00:11.550
So this is work in progress.

01:00:11.550 --> 01:00:13.390
We started work on
that, together

01:00:13.390 --> 01:00:14.550
with the Jenkins guys.

01:00:14.550 --> 01:00:19.880
And Android, again, will be
leading the whole movement.

01:00:19.880 --> 01:00:22.397
So the first platform
we implement that

01:00:22.397 --> 01:00:24.003
for won't be Java.

01:00:24.003 --> 01:00:27.320
It will be Android.

01:00:27.320 --> 01:00:27.620
OK.

01:00:27.620 --> 01:00:33.480
So this is the last
content slide.

01:00:33.480 --> 01:00:39.420
So the deeper mission of Gradle
is related to the fact

01:00:39.420 --> 01:00:43.460
that we see a lot of suffering
with any kind of medium or

01:00:43.460 --> 01:00:46.570
large-scale software stack, in
regard to missing automations.

01:00:46.570 --> 01:00:48.400
We see projects that
have build timed of

01:00:48.400 --> 01:00:50.810
eight hours or 14 hours.

01:00:50.810 --> 01:00:55.390
Distributed teams that hardly
ever get back to a state where

01:00:55.390 --> 01:00:57.630
everything works together,
and all the

01:00:57.630 --> 01:00:59.220
components can work together.

01:00:59.220 --> 01:01:05.820
So a lot of waste, a lot of
wasting time because QA gets

01:01:05.820 --> 01:01:07.160
crappy versions all the time.

01:01:07.160 --> 01:01:09.940
And they have to wait another
day, until the four-hour-long

01:01:09.940 --> 01:01:13.770
deployment is done for a new
version to try again.

01:01:17.190 --> 01:01:19.690
The continuous delivery domain,
at the moment, is the

01:01:19.690 --> 01:01:21.540
domain full of suffering.

01:01:21.540 --> 01:01:25.670
And when I talk about
theoretical versus practical

01:01:25.670 --> 01:01:29.350
freedom, theoretically, you
could solve all those

01:01:29.350 --> 01:01:31.410
problems, even with ANT.

01:01:31.410 --> 01:01:34.110
Although, it would be hard.

01:01:34.110 --> 01:01:37.950
But there are only a few
companies in the world that

01:01:37.950 --> 01:01:41.230
have the skills, the resources,
and the backing

01:01:41.230 --> 01:01:45.880
from management, that they can
really achieve what is

01:01:45.880 --> 01:01:48.165
theoretically possible for
a really good continuous

01:01:48.165 --> 01:01:48.846
delivery pipeline.

01:01:48.846 --> 01:01:51.772
And Google is one of those.

01:01:51.772 --> 01:01:53.560
But there are not many.

01:01:53.560 --> 01:01:57.560
And for the majority of
the companies, what is

01:01:57.560 --> 01:02:02.500
theoretically possible is just
unachievable, because they

01:02:02.500 --> 01:02:06.070
don't have the skills or the
resources with to implement

01:02:06.070 --> 01:02:07.270
that with the legacy tooling.

01:02:07.270 --> 01:02:13.840
And the job o Gradle is
basically to enable the big

01:02:13.840 --> 01:02:17.710
majority of the companies to
get much closer to the

01:02:17.710 --> 01:02:21.160
theoretical possibility of a
very strong, powerful, fast

01:02:21.160 --> 01:02:23.820
continuous delivery pipeline,
as I said,

01:02:23.820 --> 01:02:25.090
with reasonable effort.

01:02:25.090 --> 01:02:27.080
There will always be
effort involved.

01:02:27.080 --> 01:02:30.095
Modeling continuous delivery for
any organization with more

01:02:30.095 --> 01:02:33.490
than 50 developers is a job,
the modeling of an

01:02:33.490 --> 01:02:36.540
organization, at the end of the
day-- how they cooperate,

01:02:36.540 --> 01:02:38.840
how they release.

01:02:38.840 --> 01:02:42.230
But with reasonable effort,
that is our goal.

01:02:42.230 --> 01:02:46.010
Gradle provides you the tool kit
that you can really push

01:02:46.010 --> 01:02:47.850
your automation to the limits.

01:02:47.850 --> 01:02:50.364
So Gradle is not so much about
the cookie-cutter solutions.

01:02:50.364 --> 01:02:52.530
Gradle provides cookie-cutter
solutions.

01:02:52.530 --> 01:02:54.080
We've seen some of
the examples.

01:02:54.080 --> 01:02:56.655
But this is really what
an enterprise needs.

01:02:56.655 --> 01:03:00.480
There are always customization
you need to do, always special

01:03:00.480 --> 01:03:03.750
behaviors, special problems.

01:03:03.750 --> 01:03:06.840
And Gradle is the tool
kit that you can

01:03:06.840 --> 01:03:11.130
use to solve those.

01:03:11.130 --> 01:03:13.360
If you want to learn more about
the new Android build

01:03:13.360 --> 01:03:20.900
system there is very decent
documentation on the Android

01:03:20.900 --> 01:03:22.150
tooling website.

01:03:24.770 --> 01:03:27.380
If you want to learn more
about Gradle, go to

01:03:27.380 --> 01:03:28.554
Gradle.org.

01:03:28.554 --> 01:03:32.580
You can also subscribe to our
newsletters and notifications

01:03:32.580 --> 01:03:35.090
if you're interested.

01:03:35.090 --> 01:03:38.660
We also offer trainings for
Gradle and for Gradle Android.

01:03:38.660 --> 01:03:42.550
And at the end of the day,
Gradleware is the company

01:03:42.550 --> 01:03:43.750
behind Gradle.

01:03:43.750 --> 01:03:45.620
So we know a lot about Gradle.

01:03:45.620 --> 01:03:47.580
But we also know a lot
about continuous

01:03:47.580 --> 01:03:49.110
delivery as a whole.

01:03:49.110 --> 01:03:51.915
So if you have questions, if
you're struggling, if you want

01:03:51.915 --> 01:03:55.400
to improve your continuous
delivery pipeline, go to our

01:03:55.400 --> 01:03:57.140
website, fill out the
contact form.

01:03:57.140 --> 01:03:59.540
We are more than happy to help
you with our experience.

01:03:59.540 --> 01:04:02.710
We are involved with some of the
largest software stacks in

01:04:02.710 --> 01:04:05.860
the world but also with many
smaller companies.

01:04:05.860 --> 01:04:09.430
All of them can benefit
a lot from improving

01:04:09.430 --> 01:04:10.560
their delivery pipeline.

01:04:10.560 --> 01:04:16.210
And we help you with our
experience and our skills.

01:04:16.210 --> 01:04:17.390
Yes, that's it.

01:04:17.390 --> 01:04:20.860
Do we have any questions?

01:04:20.860 --> 01:04:21.530
Yes, please.

01:04:21.530 --> 01:04:25.343
AUDIENCE: I really liked the
idea of using a simulated

01:04:25.343 --> 01:04:27.626
calculator tools to test with.

01:04:27.626 --> 01:04:28.930
And you said that was coming.

01:04:28.930 --> 01:04:30.340
Is there any time
frame for that?

01:04:30.340 --> 01:04:32.690
And also, I didn't hear anything
about being able to

01:04:32.690 --> 01:04:35.040
test on devices, pushing
out to devices.

01:04:35.040 --> 01:04:36.570
HANS DOCKTER: OK.

01:04:36.570 --> 01:04:39.540
So this is already available
for Testdroid.

01:04:39.540 --> 01:04:42.010
They have released their first
version of the plugin and the

01:04:42.010 --> 01:04:43.810
MoneyMall folks.

01:04:43.810 --> 01:04:44.950
And I think the first
Roboelectric

01:04:44.950 --> 01:04:45.870
plugin is out there.

01:04:45.870 --> 01:04:47.960
I don't know about
the quality.

01:04:47.960 --> 01:04:49.735
But this is already available.

01:04:49.735 --> 01:04:50.630
I'm sorry.

01:04:50.630 --> 01:04:58.320
The question was, I talked about
this additional Android

01:04:58.320 --> 01:05:00.590
plugin with a testing domain,
from some of the testing

01:05:00.590 --> 01:05:03.960
providers, when it
can be used.

01:05:03.960 --> 01:05:07.760
And I said, this is already
available stuff.

01:05:07.760 --> 01:05:08.260
They're working on it.

01:05:08.260 --> 01:05:09.010
It will be improved.

01:05:09.010 --> 01:05:10.050
But it's already available.

01:05:10.050 --> 01:05:14.550
You can at least spike it
and see how much it

01:05:14.550 --> 01:05:16.120
does what you want.

01:05:16.120 --> 01:05:21.250
The other question was how, with
the Gradle Android build

01:05:21.250 --> 01:05:23.930
system, you can work with
actual devices.

01:05:23.930 --> 01:05:24.560
It's easy.

01:05:24.560 --> 01:05:25.510
You have install tasks.

01:05:25.510 --> 01:05:28.510
You have uninstall tasks.

01:05:28.510 --> 01:05:34.350
So the build tool checks which
devices are available and then

01:05:34.350 --> 01:05:36.650
pushes to them.

01:05:36.650 --> 01:05:39.540
So this is kind of
a [? hybrid ?]

01:05:39.540 --> 01:05:40.920
talk, by design.

01:05:40.920 --> 01:05:44.600
So there is a really good talk
from Xavier Decoret.

01:05:44.600 --> 01:05:47.990
He presented the build system at
the Google I/O conference,

01:05:47.990 --> 01:05:50.780
with more details than
I did here, because

01:05:50.780 --> 01:05:52.300
I had a mixed approach.

01:05:52.300 --> 01:05:57.945
So that's available on the
Android web page and on Google

01:05:57.945 --> 01:05:58.510
I/O channel.

01:05:58.510 --> 01:06:01.522
So this is also where you can
learn more about some of the

01:06:01.522 --> 01:06:03.890
stuff I have mentioned.

01:06:03.890 --> 01:06:04.695
Yes, please.

01:06:04.695 --> 01:06:10.680
AUDIENCE: So I do a lot of the
ANT scrips and trying to debug

01:06:10.680 --> 01:06:13.680
those and track down which
targets are defined where.

01:06:13.680 --> 01:06:15.969
And the properties is
kind of like a pain.

01:06:15.969 --> 01:06:18.927
Is there an easy way to
debug Gradle scripts?

01:06:18.927 --> 01:06:22.378
Is there IDE that really
makes it easy for you?

01:06:22.378 --> 01:06:23.857
You can quickly go
to the target

01:06:23.857 --> 01:06:25.336
definition and so forth?

01:06:25.336 --> 01:06:26.650
HANS DOCKTER: Yes.

01:06:26.650 --> 01:06:31.050
So you can debug on
the source level.

01:06:31.050 --> 01:06:33.070
So we do this all the time.

01:06:33.070 --> 01:06:34.670
And you can do that.

01:06:34.670 --> 01:06:35.920
There's no problem.

01:06:38.725 --> 01:06:41.225
And often, it's easy to
run down the bugs.

01:06:41.225 --> 01:06:41.970
Sometimes--

01:06:41.970 --> 01:06:46.690
and that's one area
we're invested in.

01:06:46.690 --> 01:06:48.010
It's a little bit harder
with debugging.

01:06:48.010 --> 01:06:49.330
You always can't
find the cause.

01:06:49.330 --> 01:06:53.530
But we want to invest quite a
bit of effort over the next

01:06:53.530 --> 01:06:57.310
six months, that in most of the
cases, the error message

01:06:57.310 --> 01:06:59.080
should give you a good hint
what is going on.

01:06:59.080 --> 01:07:00.740
This is sometimes still
a little bit

01:07:00.740 --> 01:07:01.890
cryptic at the moment.

01:07:01.890 --> 01:07:03.150
But yes, you can debug.

01:07:06.950 --> 01:07:09.610
There was a question.

01:07:09.610 --> 01:07:12.600
I say a hand before,
somewhere.

01:07:12.600 --> 01:07:13.360
Yes, please.

01:07:13.360 --> 01:07:18.978
AUDIENCE: So if you're importing
a module from like

01:07:18.978 --> 01:07:19.926
Maven central.

01:07:19.926 --> 01:07:22.965
And it'll say it's like
action bar share one.

01:07:22.965 --> 01:07:26.880
But it includes and Android
manifest file.

01:07:26.880 --> 01:07:29.625
Gradle refuses to compile
because now there's two

01:07:29.625 --> 01:07:31.110
Android manifest files.

01:07:31.110 --> 01:07:33.090
Is there any--

01:07:33.090 --> 01:07:35.910
HANS DOCKTER: Yes.

01:07:35.910 --> 01:07:40.200
So I think you're talking about
the old Maven library

01:07:40.200 --> 01:07:41.115
form, right?

01:07:41.115 --> 01:07:42.970
AUDIENCE: Go ahead and repeat
the question, Hans.

01:07:42.970 --> 01:07:43.790
HANS DOCKTER: OK, sorry.

01:07:43.790 --> 01:07:49.690
There was a question how Gradle
works together with the

01:07:49.690 --> 01:07:52.440
Maven Android library
form, basically.

01:07:55.456 --> 01:07:59.930
That's a feature, Edit in
Master, of the Android plugin.

01:07:59.930 --> 01:08:04.050
So the next release
should make this

01:08:04.050 --> 01:08:07.290
work without problem.

01:08:07.290 --> 01:08:08.620
So many people ask for that.

01:08:08.620 --> 01:08:11.790
Because they say, hey,
basically, I can't use it.

01:08:11.790 --> 01:08:13.990
Because I can't use
those libraries.

01:08:13.990 --> 01:08:14.950
So that is solved.

01:08:14.950 --> 01:08:16.600
And that was one of the--

01:08:16.600 --> 01:08:19.719
I would say-- number one
complaints about the current

01:08:19.719 --> 01:08:23.946
state of the build system.

01:08:23.946 --> 01:08:27.324
AUDIENCE: Is there support for
Atlassian Bamboo with Gradle?

01:08:27.324 --> 01:08:29.680
HANS DOCKTER: Yes, so he's
saying support for Atlassian

01:08:29.680 --> 01:08:31.160
Bamboo with Gradle.

01:08:31.160 --> 01:08:32.410
Yes.

01:08:34.319 --> 01:08:36.130
So Gradle works with
any CI server.

01:08:36.130 --> 01:08:38.880
Some have a richer integration,
some not so rich.

01:08:38.880 --> 01:08:43.310
But the main job, you can
do with any CI server.

01:08:43.310 --> 01:08:47.109
AUDIENCE: So you showed us
inside Gradle task and it

01:08:47.109 --> 01:08:48.552
showed a bunch of tasks.

01:08:48.552 --> 01:08:50.810
Now, how many of those
were out of the box?

01:08:50.810 --> 01:08:52.925
And how many were defined?

01:08:52.925 --> 01:08:54.450
So it was per project.

01:08:54.450 --> 01:08:55.790
It was for Android.

01:08:55.790 --> 01:08:57.314
What is the difference between
the Android task

01:08:57.314 --> 01:08:58.238
and the Java task?

01:08:58.238 --> 01:09:01.130
They all just come free,
bundled with Gradle?

01:09:01.130 --> 01:09:02.520
HANS DOCKTER: Yes.

01:09:02.520 --> 01:09:04.390
It was just a few
lines of code.

01:09:04.390 --> 01:09:07.060
There was nothing no custom
logic to load.

01:09:07.060 --> 01:09:10.655
That all came from the
Android plugin.

01:09:10.655 --> 01:09:12.510
There was nothing to
be done on my side.

01:09:12.510 --> 01:09:14.395
AUDIENCE: What if you're not
using Android plugin, and

01:09:14.395 --> 01:09:15.560
you're just using
regular Gradle?

01:09:15.560 --> 01:09:18.750
HANS DOCKTER: So if you're using
the Gradle plugin, then

01:09:18.750 --> 01:09:22.160
if you're using the Java plugin,
then you wouldn't get

01:09:22.160 --> 01:09:23.470
all the Android tasks.

01:09:23.470 --> 01:09:28.490
So you would get a life cycle
for a Java project.

01:09:28.490 --> 01:09:31.250
And they share some of the life
cycle phases, like the

01:09:31.250 --> 01:09:34.689
concept of assembling
of compiling.

01:09:34.689 --> 01:09:36.149
But the Android life cycle
is much richer.

01:09:39.830 --> 01:09:43.010
And you can easily work with
mixed projects in Gradle.

01:09:43.010 --> 01:09:45.979
You can have a mighty module
build with a Java backend

01:09:45.979 --> 01:09:49.500
service, with Android
application and all that.

01:09:49.500 --> 01:09:51.724
So that is one of the
strengths of Gradle.

01:09:51.724 --> 01:09:55.780
It can provide you a unified
view and a unified build

01:09:55.780 --> 01:09:58.724
process, even if you're using
very different platforms.

01:10:04.048 --> 01:10:05.900
Yeah, thanks a lot for
your attention.

01:10:05.900 --> 01:10:07.600
I really enjoyed it.

01:10:07.600 --> 01:10:12.440
[APPLAUSE]

01:10:12.440 --> 01:10:15.430
VAN RIPER: So if you can stop
the live streaming.

01:10:15.430 --> 01:10:18.760
So what we usually do at the
beginning is get a chance for

01:10:18.760 --> 01:10:19.150
announcements.

01:10:19.150 --> 01:10:22.485
So since you made it to the
end, I wanted people who I

01:10:22.485 --> 01:10:23.380
didn't give a chance
to go down.

01:10:23.380 --> 01:10:25.800
So come up her now,
really quick.

01:10:25.800 --> 01:10:28.745
And then, what we'd like to do
is give those of you who

01:10:28.745 --> 01:10:31.210
stayed patiently to talk
to the speaker.

01:10:31.210 --> 01:10:33.198
But let's get quick
announcements first.

01:10:33.198 --> 01:10:34.192
And then we'll do that.

01:10:34.192 --> 01:10:35.683
GOPAL: Thanks, Van.

01:10:35.683 --> 01:10:36.677
I'm Gopal.

01:10:36.677 --> 01:10:38.168
VAN RIPER: Use the mic.

01:10:38.168 --> 01:10:39.162
Just go closely.

01:10:39.162 --> 01:10:41.740
GOPAL: I'm Gopal.

01:10:41.740 --> 01:10:44.840
I normally come here to learn
one of the technologies and

01:10:44.840 --> 01:10:46.241
also do networking.

01:10:46.241 --> 01:10:49.510
I have good news to share.

01:10:49.510 --> 01:10:51.520
Right now, I work for
a company called

01:10:51.520 --> 01:10:53.070
lendingclub.com.

01:10:53.070 --> 01:10:54.628
So it's a peer-to-peer
lending.

01:10:54.628 --> 01:10:58.370
And we are growing, really
exponentially.

01:10:58.370 --> 01:11:02.325
So we took a platform.

01:11:02.325 --> 01:11:05.683
We took it five to six years to
fund the first $1 billion.

01:11:05.683 --> 01:11:10.513
And the next seven months, we
reached the second $1 billion.

01:11:10.513 --> 01:11:14.740
So we developed Java double
parse and the QA.

01:11:14.740 --> 01:11:16.717
If you any of you have interest
or know any of your

01:11:16.717 --> 01:11:17.930
friends, you can just
come to me.

01:11:17.930 --> 01:11:20.031
VAN RIPER: Come and talk to
him before you leave, if

01:11:20.031 --> 01:11:20.840
you're looking for a Java QA.

01:11:20.840 --> 01:11:22.250
SUYASH: Hi, my name is Suyash.

01:11:22.250 --> 01:11:24.645
I run the Bay Area Android
Study Group.

01:11:24.645 --> 01:11:27.050
And we have a meetup,
coming up next week.

01:11:27.050 --> 01:11:30.880
Chiu-ki Chan, she's an Android
expert, going to talk about

01:11:30.880 --> 01:11:33.800
how do you handle a device
fragmentation and all those

01:11:33.800 --> 01:11:35.210
bugs that come with it.

01:11:35.210 --> 01:11:39.590
So it's on Wednesday July 17,
Bay Area Android Study Group.

01:11:39.590 --> 01:11:41.512
I'll put a link on
the meetup board.

01:11:41.512 --> 01:11:43.867
VAN RIPER: Put a comment
on tonight's meetup.

01:11:43.867 --> 01:11:44.809
So everybody here can see it.

01:11:44.809 --> 01:11:45.760
All right, that's it.

01:11:45.760 --> 01:11:49.390
And now we can stay here
for a few more minutes.

01:11:49.390 --> 01:11:51.960
So if some of you want to
go up and talk to Hans

01:11:51.960 --> 01:11:54.430
personally, I'm sure he'd be
happy to talk to you at least

01:11:54.430 --> 01:11:55.840
for a few minutes, before
he has to go.

