WEBVTT
Kind: captions
Language: en

00:00:06.260 --> 00:00:07.730
ANDREW GERRAND: Good morning
everyone, and welcome to the

00:00:07.730 --> 00:00:09.670
session, Go In Production.

00:00:09.670 --> 00:00:12.750
This morning I've invited four
members of the Go community,

00:00:12.750 --> 00:00:16.329
and people who use Go in their
companies, in production

00:00:16.329 --> 00:00:19.830
systems to talk to you about
how they use Go, and their

00:00:19.830 --> 00:00:22.570
experience with using Go.

00:00:22.570 --> 00:00:26.950
And so without further ado, and
the format of this panel

00:00:26.950 --> 00:00:31.610
is that we'll have four short
presentations from the

00:00:31.610 --> 00:00:35.980
panelists, and then I'll open
the floor to questions.

00:00:35.980 --> 00:00:39.180
And we'll have about half an
hour worth of questions.

00:00:39.180 --> 00:00:42.310
During each of the slides, there
will be a little link in

00:00:42.310 --> 00:00:44.640
the bottom left corner,
which will be to a

00:00:44.640 --> 00:00:45.530
Google moderator link.

00:00:45.530 --> 00:00:48.930
So if you want to enter
questions there as you think

00:00:48.930 --> 00:00:52.780
of them during the talks,
that's also a good idea.

00:00:52.780 --> 00:00:57.870
So without further ado, I'll
invite my first panelist.

00:00:57.870 --> 00:01:00.080
He believes that the world needs
better software, and he

00:01:00.080 --> 00:01:02.190
works at Canonical currently,
where he

00:01:02.190 --> 00:01:03.670
works on the Juju project.

00:01:03.670 --> 00:01:08.520
And he's also built Landscape
and the Storm ORM.

00:01:08.520 --> 00:01:11.180
And as a Go contributer and a
member of the Go community,

00:01:11.180 --> 00:01:15.670
he's worked on the Go core and
the Mango, MongoDB driver,

00:01:15.670 --> 00:01:18.560
Gocheck, [INAUDIBLE],
and others.

00:01:18.560 --> 00:01:20.370
Please welcome Gustavo
Neimeyer, thank you.

00:01:30.100 --> 00:01:31.590
GUSTAVO NIEMEYER:
Thanks, Andrew.

00:01:31.590 --> 00:01:33.830
And thank you very much as
well for the Go team for

00:01:33.830 --> 00:01:38.850
inviting me to talk to you and
have a chance to describe why

00:01:38.850 --> 00:01:42.275
we believe Go is a better
language for our workloads.

00:01:48.610 --> 00:01:52.920
Juju, I'm going to quickly
describe what problem we're

00:01:52.920 --> 00:01:54.380
trying to solve.

00:01:54.380 --> 00:01:57.290
And then I will describe how
we're solving it, and then

00:01:57.290 --> 00:02:01.330
I'll go and tell few bits about
why Go is helping us in

00:02:01.330 --> 00:02:04.070
those tasks.

00:02:04.070 --> 00:02:09.610
So imagine you wanted to
develop, to deploy a service

00:02:09.610 --> 00:02:16.180
with a couple of, let's say a
couple of softwares, right?

00:02:16.180 --> 00:02:19.540
Either you have a database
and your

00:02:19.540 --> 00:02:21.260
application, for instance.

00:02:21.260 --> 00:02:25.173
And you're doing that with a
tool, sometimes with the help

00:02:25.173 --> 00:02:29.210
of a tool, or by hand.

00:02:29.210 --> 00:02:31.336
So it usually goes like that.

00:02:31.336 --> 00:02:34.050
You've got a couple
of machines.

00:02:34.050 --> 00:02:38.850
You give them some names, and
you develop some affection for

00:02:38.850 --> 00:02:41.300
those machines.

00:02:41.300 --> 00:02:46.390
And you put configuration files
into those machines.

00:02:46.390 --> 00:02:49.010
Those configuration files
generally will have details

00:02:49.010 --> 00:02:54.050
such as the IP address for your
database, and information

00:02:54.050 --> 00:02:57.580
for exposing that service and
the deals to interconnect to

00:02:57.580 --> 00:02:58.540
those machines.

00:02:58.540 --> 00:03:01.460
If you think about that, what
you're actually doing is that

00:03:01.460 --> 00:03:06.210
you're creating a topology of
services so that the things

00:03:06.210 --> 00:03:08.140
communicate with each other.

00:03:08.140 --> 00:03:10.980
But what's occurred to us, which
is really interesting,

00:03:10.980 --> 00:03:16.540
is that in most cases that
topology is actually in the

00:03:16.540 --> 00:03:18.770
administrator's head.

00:03:18.770 --> 00:03:21.120
You don't have that in
the system itself.

00:03:21.120 --> 00:03:27.440
So this is all good, but then
some issues started to occur.

00:03:27.440 --> 00:03:30.610
For instance, it became a
bit hard to give names.

00:03:30.610 --> 00:03:34.880
Can you imagine, for instance,
giving like 600,000 names in

00:03:34.880 --> 00:03:36.370
the [INAUDIBLE]

00:03:36.370 --> 00:03:37.620
morning?

00:03:40.760 --> 00:03:44.600
It's a bit tragic as well,
because things, when you start

00:03:44.600 --> 00:03:50.340
to get a lot of resources,
whatever those resources are,

00:03:50.340 --> 00:03:52.970
even if just a few are failing,
you start to get lots

00:03:52.970 --> 00:03:56.070
of failures and you have
to deal with those.

00:03:56.070 --> 00:03:58.070
So the topology in that
case becomes a little

00:03:58.070 --> 00:03:59.680
bit complex as well.

00:03:59.680 --> 00:04:02.700
It's harder to get
things together.

00:04:02.700 --> 00:04:04.550
It's hard to keep in your mind
what's actually happening in

00:04:04.550 --> 00:04:05.510
the system.

00:04:05.510 --> 00:04:08.570
So this is really what
we were after.

00:04:08.570 --> 00:04:11.590
We wanted to see not only how to
solve this problem, but how

00:04:11.590 --> 00:04:15.740
to enable people to collaborate
while doing so.

00:04:15.740 --> 00:04:19.510
And to collaborate, you have
to re-use, you have to

00:04:19.510 --> 00:04:23.060
understand how to manage
those resources.

00:04:23.060 --> 00:04:25.170
This is what Juju is about.

00:04:25.170 --> 00:04:28.920
When we were planning the
system, we very much has the

00:04:28.920 --> 00:04:29.930
use case in mind.

00:04:29.930 --> 00:04:35.250
How can we implement that in a
very straightforward workflow?

00:04:35.250 --> 00:04:37.830
We think a little bit about
it, as like a [INAUDIBLE]

00:04:37.830 --> 00:04:40.440
services.

00:04:40.440 --> 00:04:43.290
You basically, for instance,
Juju bootstrap, it not only

00:04:43.290 --> 00:04:47.990
deploys the service itself,
but it deploys the servers

00:04:47.990 --> 00:04:50.280
that run the service.

00:04:50.280 --> 00:04:52.780
And then you deploy a couple of
services, just so you know,

00:04:52.780 --> 00:04:55.310
deployment application
MongoDB for instance.

00:04:55.310 --> 00:04:59.370
And it will actually get those
systems running on a service,

00:04:59.370 --> 00:05:02.410
on a machine being managed.

00:05:02.410 --> 00:05:05.570
OK, but how do I tell the system
that those two servers

00:05:05.570 --> 00:05:08.010
are communicating?

00:05:08.010 --> 00:05:11.480
We explicitly say add a
relation between them.

00:05:11.480 --> 00:05:15.120
And the bits that are composed,
the services, the

00:05:15.120 --> 00:05:21.620
charms, as we call them that
compose the system, they have

00:05:21.620 --> 00:05:22.990
knowledge about how
to establish

00:05:22.990 --> 00:05:24.260
that relation, right?

00:05:24.260 --> 00:05:27.830
So since that knowledge is
within the system you can

00:05:27.830 --> 00:05:31.140
start to do tricks, like very
easily add GNU new units.

00:05:31.140 --> 00:05:34.235
You can add new bits to the
system, and the system knows

00:05:34.235 --> 00:05:38.810
how to interconnect those bits
to the rest of the system.

00:05:38.810 --> 00:05:41.390
Where is the topology
in that case?

00:05:41.390 --> 00:05:43.660
It is inside.

00:05:43.660 --> 00:05:46.350
The system knows what's
going on.

00:05:46.350 --> 00:05:50.060
Those bits are reusable, they're
independent, and they

00:05:50.060 --> 00:05:52.970
are exchangeable so that people
can deploy a better

00:05:52.970 --> 00:05:59.380
MongoDB deploy bits of those
systems, and everybody in the

00:05:59.380 --> 00:06:03.000
community benefits from that.

00:06:03.000 --> 00:06:06.740
So we're porting everything
to Go.

00:06:06.740 --> 00:06:10.220
It was originally made in
Twisted, in Python with

00:06:10.220 --> 00:06:13.010
Twisted, and we're porting
the whole system to Go

00:06:13.010 --> 00:06:15.950
for quite a bit now.

00:06:15.950 --> 00:06:19.800
And we already have base work
in production, such as the

00:06:19.800 --> 00:06:23.400
database, the service, the
services themselves are served

00:06:23.400 --> 00:06:25.590
from, they're all
running from Go.

00:06:25.590 --> 00:06:28.870
So why are we doing that?

00:06:28.870 --> 00:06:30.260
There are a few reasons.

00:06:30.260 --> 00:06:32.180
One of them, for instance,
is error checking.

00:06:35.850 --> 00:06:38.780
One of the beautiful things
about Juju, and the thing that

00:06:38.780 --> 00:06:40.950
really attracts people is
that it's kind of a

00:06:40.950 --> 00:06:42.000
magic system, right?

00:06:42.000 --> 00:06:43.830
You just type some commands,
and whoah, I

00:06:43.830 --> 00:06:45.760
have a service running.

00:06:45.760 --> 00:06:50.610
But magic systems can also
break magically.

00:06:50.610 --> 00:06:53.510
This is a very sensitive
subject, right?

00:06:53.510 --> 00:06:54.840
We want things to be running.

00:06:54.840 --> 00:06:58.240
We want people to not have
to go after the issues

00:06:58.240 --> 00:07:01.110
and the bugs then.

00:07:01.110 --> 00:07:02.600
We want to reduce the
chance at least.

00:07:02.600 --> 00:07:04.920
It's going to happen, but we
want to reduce the chance of

00:07:04.920 --> 00:07:05.920
that happening.

00:07:05.920 --> 00:07:10.880
Go gives us a very visual way to
say here you have an error,

00:07:10.880 --> 00:07:14.420
do something with it.

00:07:14.420 --> 00:07:18.080
Another very interesting point
for us was the fact that, for

00:07:18.080 --> 00:07:22.370
instance, when we requested a
watch from Zoo Keeper, which

00:07:22.370 --> 00:07:26.700
is one of the systems we use
in the back-end, we get two

00:07:26.700 --> 00:07:28.560
futures back.

00:07:28.560 --> 00:07:31.530
Each one of those futures, the
first one gives us the data,

00:07:31.530 --> 00:07:33.160
and the second one gives
us notifications

00:07:33.160 --> 00:07:35.390
once the data changes.

00:07:35.390 --> 00:07:38.630
And that means that you
basically have different paths

00:07:38.630 --> 00:07:41.280
that your code has to
deal with, right?

00:07:41.280 --> 00:07:43.680
You have the first future that
may fire, you have the second

00:07:43.680 --> 00:07:46.400
one, and you have the path that
is the function that is

00:07:46.400 --> 00:07:48.650
currently executing.

00:07:48.650 --> 00:07:51.150
But all of that is a single
algorithm so we have to take

00:07:51.150 --> 00:07:54.240
those three features and have to
put them back into a single

00:07:54.240 --> 00:07:57.240
logic that makes sense.

00:07:57.240 --> 00:08:00.710
Go gives us a very
straightforward path for that.

00:08:00.710 --> 00:08:03.570
You can just say give me a
watch, it can block until the

00:08:03.570 --> 00:08:08.680
data comes back, and the channel
actually gives you a

00:08:08.680 --> 00:08:11.290
good way to wait for that
information as well in line,

00:08:11.290 --> 00:08:12.540
without having to go out.

00:08:16.500 --> 00:08:19.330
I don't have time to go
over each detail.

00:08:19.330 --> 00:08:22.490
Changing a language for a
project from one side to the

00:08:22.490 --> 00:08:25.240
other is a very important
decision.

00:08:25.240 --> 00:08:28.710
There are many, many small bits
that would take a full

00:08:28.710 --> 00:08:31.800
talk to go over.

00:08:31.800 --> 00:08:34.150
So this is basically
what we're doing.

00:08:34.150 --> 00:08:38.740
If you want more information,
please, this is the URL.

00:08:38.740 --> 00:08:39.990
Andrew, thank you.

00:08:46.670 --> 00:08:47.920
ANDREW GERRAND: Thanks,
Gustavo.

00:08:50.590 --> 00:08:55.280
So my next speaker is one of the
first engineers at Heroku,

00:08:55.280 --> 00:08:57.410
and didn't respond to my
request to send me a

00:08:57.410 --> 00:08:59.340
biography, and is also
a great guy.

00:08:59.340 --> 00:09:00.730
Please welcome Keith Rarick.

00:09:10.860 --> 00:09:12.110
KEITH RARICK: Thanks, Andrew.

00:09:14.390 --> 00:09:17.610
I'd like to give you a quick
story about one of the first

00:09:17.610 --> 00:09:20.640
production systems that we
used Go for at Heroku.

00:09:20.640 --> 00:09:22.520
So first of all what's Heroku?

00:09:22.520 --> 00:09:25.410
For those of you who haven't
looked at it before, it's a

00:09:25.410 --> 00:09:28.070
platform as a service for
running primarily web

00:09:28.070 --> 00:09:29.450
applications.

00:09:29.450 --> 00:09:32.920
It started out just as Ruby on
Rails, but these days you can

00:09:32.920 --> 00:09:36.700
run just anything,
including Go.

00:09:36.700 --> 00:09:40.180
Right now we have about 1.9
million apps, and the company

00:09:40.180 --> 00:09:44.210
itself has about 85 employees.

00:09:44.210 --> 00:09:49.180
How Heroku works, just in a
super short nutshell is each

00:09:49.180 --> 00:09:54.560
app runs as a handful, one or
more lightweight containers

00:09:54.560 --> 00:09:57.230
that we call dynos.

00:09:57.230 --> 00:10:02.260
And one of the most important
pieces of Heroku is our HTTP

00:10:02.260 --> 00:10:05.890
front end routing service.

00:10:05.890 --> 00:10:10.590
It has to have a table of all
the processes that are running

00:10:10.590 --> 00:10:13.080
and where they are at any
moment, so that it can handle

00:10:13.080 --> 00:10:15.820
incoming user requests and send
them to the right place.

00:10:15.820 --> 00:10:17.620
And of course it changes
whenever

00:10:17.620 --> 00:10:19.080
processes start and stop.

00:10:19.080 --> 00:10:24.640
For example, when a user scales
up to more dynos.

00:10:24.640 --> 00:10:26.790
Now not all of these 1.9 millio
apps are actually

00:10:26.790 --> 00:10:29.930
active at any moment, but a
significant fraction are.

00:10:29.930 --> 00:10:32.050
And of course it's changing
all the time.

00:10:35.340 --> 00:10:39.000
The way we've implemented this
is we have a service to store

00:10:39.000 --> 00:10:40.345
just the routing table.

00:10:40.345 --> 00:10:43.300
It keeps the canonical copy of
this table in a Postgres

00:10:43.300 --> 00:10:48.880
database, and it was originally
written in Ruby as

00:10:48.880 --> 00:10:53.790
a RESTful HTTP sort of API in
front of this database.

00:10:53.790 --> 00:10:56.610
So whenever the Process Manager
starts or stops a

00:10:56.610 --> 00:10:59.110
process, it makes a call
to this service

00:10:59.110 --> 00:11:01.010
to update its record.

00:11:01.010 --> 00:11:05.210
And then on the other side,
whenever we start up a new

00:11:05.210 --> 00:11:08.640
instance of the front end
router, it connects into the

00:11:08.640 --> 00:11:13.800
service, gets an initial JSON
dump of the entire table, and

00:11:13.800 --> 00:11:16.220
then after that, streaming
updates.

00:11:16.220 --> 00:11:18.820
So it saves in the sync.

00:11:18.820 --> 00:11:22.840
So here's a picture of roughly
what that looks like.

00:11:22.840 --> 00:11:26.470
Things go in from the left and
come out on the right.

00:11:26.470 --> 00:11:30.060
And this works pretty great,
especially because each front

00:11:30.060 --> 00:11:32.590
end router has a complete copy
of the table in memory, so it

00:11:32.590 --> 00:11:37.080
can do fast look ups with no
IPC or anything like that.

00:11:37.080 --> 00:11:43.420
But there's a problem, and
that's just that bootstrapping

00:11:43.420 --> 00:11:45.940
a new instance of the
front end router is

00:11:45.940 --> 00:11:47.250
prohibitively slow.

00:11:47.250 --> 00:11:50.450
And it turns out that that's
just because of the process

00:11:50.450 --> 00:11:52.430
generating, the Ruby process
generating this

00:11:52.430 --> 00:11:53.680
initial JSON dump.

00:11:56.610 --> 00:11:59.270
So the guy who's working on this
project, he had already

00:11:59.270 --> 00:12:02.480
used Go for a couple of
experiments on smaller things.

00:12:02.480 --> 00:12:05.740
And he decided it might be worth
taking a look to see if

00:12:05.740 --> 00:12:07.760
it would help out in
the situation.

00:12:07.760 --> 00:12:12.660
So he decided he just wanted to
make a drop in replacement

00:12:12.660 --> 00:12:15.090
for the piece that generates
the dump of the table and

00:12:15.090 --> 00:12:17.760
sends out streaming updates.

00:12:17.760 --> 00:12:20.560
And the nice thing was that he
felt like he could just mess

00:12:20.560 --> 00:12:23.420
around in an afternoon to get a
good feel for whether or not

00:12:23.420 --> 00:12:25.240
it would work out.

00:12:25.240 --> 00:12:28.350
And in just a couple of hours,
he had a working prototype

00:12:28.350 --> 00:12:33.660
which was very encouraging, so
we decided to go ahead and

00:12:33.660 --> 00:12:38.860
make it into a real, clean it
up and go through our normal

00:12:38.860 --> 00:12:43.420
testing and staging procedures,
and so we finally

00:12:43.420 --> 00:12:46.400
deployed it to production,
initially alongside the

00:12:46.400 --> 00:12:47.620
existing Ruby process.

00:12:47.620 --> 00:12:51.510
But here's the new picture with
the Go piece in place.

00:12:51.510 --> 00:12:55.440
And after running it for
a while and getting

00:12:55.440 --> 00:12:57.250
operationally comfortable
with this new piece,

00:12:57.250 --> 00:12:58.400
we flipped the switch.

00:12:58.400 --> 00:13:01.550
This was some time ago, so that
the Go process is now the

00:13:01.550 --> 00:13:02.800
canonical one.

00:13:05.500 --> 00:13:09.170
And honestly, it was pretty
much a win all around.

00:13:09.170 --> 00:13:11.250
First of all, it solved the
initial problem that we set

00:13:11.250 --> 00:13:14.540
out to solve with more
than a 10x speedup

00:13:14.540 --> 00:13:16.340
generating that dump.

00:13:16.340 --> 00:13:21.640
And in addition to that, it's
just the ops burden is

00:13:21.640 --> 00:13:23.040
actually significantly less.

00:13:23.040 --> 00:13:25.540
We can just take that single
binary and throw it up on a

00:13:25.540 --> 00:13:28.030
server, and it's easy to run,
it's easy to manage.

00:13:31.300 --> 00:13:35.500
And that's actually been sort of
a recurring theme, sort of

00:13:35.500 --> 00:13:36.950
overall at Heroku.

00:13:36.950 --> 00:13:39.080
We've seen people sort of start
to play around with Go a

00:13:39.080 --> 00:13:41.450
little bit on some smaller
things, or

00:13:41.450 --> 00:13:43.080
just on a side project.

00:13:43.080 --> 00:13:46.770
And then we've sort of adopted
it for more and more things

00:13:46.770 --> 00:13:47.640
actually in production.

00:13:47.640 --> 00:13:52.630
So now we have a handful of
systems running in production.

00:13:52.630 --> 00:13:56.460
And there's several more on
the way, in the pipeline.

00:13:56.460 --> 00:13:57.710
Thanks.

00:14:05.830 --> 00:14:08.380
ANDREW GERRAND: Thank
you, Keith.

00:14:08.380 --> 00:14:11.710
So my next guest has written
software for heart devices,

00:14:11.710 --> 00:14:15.280
video games, online dating
systems and mobile apps.

00:14:15.280 --> 00:14:17.730
Formally the CTO of
OK Cupid, he's now

00:14:17.730 --> 00:14:18.810
the founder of StatHat.

00:14:18.810 --> 00:14:20.110
Please, oh.

00:14:20.110 --> 00:14:20.920
I've done in the wrong order.

00:14:20.920 --> 00:14:22.460
Oh my God.

00:14:22.460 --> 00:14:24.440
Since I've introduced
him, he can start.

00:14:24.440 --> 00:14:26.290
Please welcome Patrick Crosby.

00:14:34.680 --> 00:14:35.950
PATRICK CROSBY: We've all
listened to our talks so much,

00:14:35.950 --> 00:14:37.200
I probably could have
done Evan's.

00:14:39.900 --> 00:14:42.890
So StatHat as a service to
track statistics in your

00:14:42.890 --> 00:14:46.620
applications, you can
add one line of

00:14:46.620 --> 00:14:48.240
code and you get graphs.

00:14:48.240 --> 00:14:52.620
You can track alerts and embed
charts on your own site.

00:14:52.620 --> 00:14:55.540
For example, say you have
an online dating site.

00:14:55.540 --> 00:14:58.620
One good metric to see if you
have an effective site is to

00:14:58.620 --> 00:15:02.070
track if the user gets a
reply to their message.

00:15:02.070 --> 00:15:03.940
So if you do something like
change the matching algorithm

00:15:03.940 --> 00:15:08.430
and the reply counts
go up, then--

00:15:08.430 --> 00:15:10.180
thank you--

00:15:10.180 --> 00:15:14.540
then the matching algorithm
has gotten better, and

00:15:14.540 --> 00:15:17.980
StatHat's perfect for tracking
something like this.

00:15:17.980 --> 00:15:20.150
So this how you would track
reply counts in the 15

00:15:20.150 --> 00:15:22.090
different languages
we support.

00:15:22.090 --> 00:15:26.940
We have Go, Ruby, Python, and
all the rest of these.

00:15:26.940 --> 00:15:30.750
Once you add that one line, you
get time charts showing

00:15:30.750 --> 00:15:33.600
the value changing over time,
histograms showing the

00:15:33.600 --> 00:15:36.850
distribution of the data,
and you can embed

00:15:36.850 --> 00:15:38.380
charts in any site.

00:15:38.380 --> 00:15:40.830
This is example from GitHub
archive where they're tracking

00:15:40.830 --> 00:15:43.660
every single GitHub event, and
they show a StatHat chart on

00:15:43.660 --> 00:15:45.690
their main site.

00:15:45.690 --> 00:15:47.660
So you can track anything.

00:15:47.660 --> 00:15:50.020
Here's a bunch of examples, but
basically any number in

00:15:50.020 --> 00:15:56.380
your code, any count, any event
you can send to StatHat.

00:15:56.380 --> 00:15:58.270
Almost everything in StatHat's
written in Go.

00:15:58.270 --> 00:16:01.780
We use a standard net HTTP
package for our web and data

00:16:01.780 --> 00:16:02.890
collection.

00:16:02.890 --> 00:16:06.390
Our back-end all communicates
over RPC, and we use a ton of

00:16:06.390 --> 00:16:10.410
third party and standard
packages.

00:16:10.410 --> 00:16:12.950
We often get asked
why we chose Go.

00:16:12.950 --> 00:16:14.330
The main reasons is
that it's fast.

00:16:14.330 --> 00:16:18.670
Our services and request
times are very low.

00:16:18.670 --> 00:16:20.960
And it's also fast to develop,
and because it's statically

00:16:20.960 --> 00:16:23.730
typed, we don't have to write
as many unit tests.

00:16:23.730 --> 00:16:25.490
It's also very resource
friendly.

00:16:25.490 --> 00:16:27.500
Our server costs are much
less than if we used

00:16:27.500 --> 00:16:29.920
something like Rails.

00:16:29.920 --> 00:16:32.370
It's an easy to deploy
system, which I'll

00:16:32.370 --> 00:16:33.390
talk about in a bit.

00:16:33.390 --> 00:16:35.320
And it's also a fun language
to spend your

00:16:35.320 --> 00:16:37.650
time coding all day.

00:16:37.650 --> 00:16:39.930
So a brief overview of
our architecture.

00:16:39.930 --> 00:16:42.180
So the stat we talked about
before, the message reply

00:16:42.180 --> 00:16:46.180
count comes in over HTTP to our
data collection servers,

00:16:46.180 --> 00:16:49.100
and it gets sent over RPC
to the dataset services.

00:16:49.100 --> 00:16:52.050
And the user interacting with
the web service gets all the

00:16:52.050 --> 00:16:57.920
components from the various RPC
services, and then we have

00:16:57.920 --> 00:16:59.930
some other Go applications
that send

00:16:59.930 --> 00:17:03.060
alerts and email reports.

00:17:03.060 --> 00:17:06.480
Here's some details of the
data collection service.

00:17:06.480 --> 00:17:09.619
Once the stack comes in over
HTTP, it gets put in the cache

00:17:09.619 --> 00:17:12.550
right away, and we respond to
the caller as soon as we can.

00:17:12.550 --> 00:17:15.480
Then there's a Go routine that
serializes this cache to disk

00:17:15.480 --> 00:17:17.859
in case the server crashes, and
another Go routine that

00:17:17.859 --> 00:17:19.379
takes data out of the
cache and puts it

00:17:19.379 --> 00:17:20.819
in the update channel.

00:17:20.819 --> 00:17:22.819
We then have a pool of hundreds
of Go routines that

00:17:22.819 --> 00:17:25.700
takes data out of the update
channel and sends it over RPC

00:17:25.700 --> 00:17:28.490
to the dataset services.

00:17:28.490 --> 00:17:30.950
So deployment of Go applications
is very easy, and

00:17:30.950 --> 00:17:32.940
the main reason is the binaries
are self-contained,

00:17:32.940 --> 00:17:35.030
so there's no shared
libraries, gems or

00:17:35.030 --> 00:17:37.030
dependencies you have
to worry about.

00:17:37.030 --> 00:17:40.320
And the Go tool also downloads
any third party packages for

00:17:40.320 --> 00:17:41.620
you and installs them.

00:17:41.620 --> 00:17:43.390
So basically if you can get
your app to compile,

00:17:43.390 --> 00:17:45.540
you can deploy it.

00:17:45.540 --> 00:17:48.880
At StatHat, every time we do
a get push it starts the

00:17:48.880 --> 00:17:50.740
deployment process.

00:17:50.740 --> 00:17:53.850
What this entails is it pulls
all the code, runs all the

00:17:53.850 --> 00:17:56.390
tests, and compiles all
of our applications.

00:17:56.390 --> 00:17:59.150
If all of that works, it then
makes a bundle and adds all

00:17:59.150 --> 00:18:00.950
the content resources.

00:18:00.950 --> 00:18:03.230
And then we have a web service
where we select the servers

00:18:03.230 --> 00:18:06.010
that are supposed to receive
this bundle, and just rsyncs

00:18:06.010 --> 00:18:08.910
the bundle over and tells them
that they have a new bundle

00:18:08.910 --> 00:18:10.580
and they should restart
anything.

00:18:10.580 --> 00:18:12.930
And these servers don't have
Go installed, they're just

00:18:12.930 --> 00:18:16.080
basic Linux installations.

00:18:16.080 --> 00:18:19.790
And this whole process to make
the bundle takes about two

00:18:19.790 --> 00:18:24.860
minutes, and it's 100,000
lines of code.

00:18:24.860 --> 00:18:27.550
StatHat's an invitation only
service, but if you go to

00:18:27.550 --> 00:18:31.660
stathat.com/io2012 you can sign
up without an invite, and

00:18:31.660 --> 00:18:36.170
we also have some open source
go code at stathat.com/src.

00:18:36.170 --> 00:18:37.420
Thank you.

00:18:43.490 --> 00:18:45.230
ANDREW GERRAND: Thanks,
Patrick.

00:18:45.230 --> 00:18:49.700
And I'll just jump back in my
slides to the right spot.

00:18:49.700 --> 00:18:51.600
I hope.

00:18:51.600 --> 00:18:53.890
All right.

00:18:53.890 --> 00:18:58.340
So my final guest is the lead
engineer at Iron.io.

00:18:58.340 --> 00:19:01.030
He was an early Go contributor
and contributed to the FastCGI

00:19:01.030 --> 00:19:04.420
and SMTP packages, and is now
working on a book called Go In

00:19:04.420 --> 00:19:06.480
Action from Manning
publishing, please

00:19:06.480 --> 00:19:07.730
welcome Evan Shaw.

00:19:17.220 --> 00:19:19.450
EVAN SHAW: Hi, I'm just going
to talk a little bit about

00:19:19.450 --> 00:19:22.710
Iron.io and what we do, and
how we're using Go.

00:19:22.710 --> 00:19:25.780
So Iron.io builds cloud
application services, that is

00:19:25.780 --> 00:19:29.500
we build applications on top
of cloud platforms like AWS

00:19:29.500 --> 00:19:33.730
and Rackspace, maybe Google
compute engine in the future.

00:19:33.730 --> 00:19:37.750
And our main goal is to remove
infrastructure worries.

00:19:37.750 --> 00:19:40.680
So most companies have a small
set of problems that they want

00:19:40.680 --> 00:19:42.970
to focus on, and infrastructure
is usually not

00:19:42.970 --> 00:19:44.590
one of those problems.

00:19:44.590 --> 00:19:47.430
And once we can remove these
worries, we can enable smaller

00:19:47.430 --> 00:19:49.150
teams to do bigger things,
which is another

00:19:49.150 --> 00:19:51.360
major goal of ours.

00:19:51.360 --> 00:19:54.400
So the first product we came out
with is called IronWorker.

00:19:54.400 --> 00:19:57.510
It's a massively parallel
worker platform.

00:19:57.510 --> 00:20:00.820
So you upload your code or
binary, and then start sending

00:20:00.820 --> 00:20:05.440
us task data or payloads, and
for each one of those you send

00:20:05.440 --> 00:20:08.020
us, we'll queue a task,
and then run it in

00:20:08.020 --> 00:20:10.300
our pool server somewhere.

00:20:10.300 --> 00:20:13.630
Our API for the service was
originally written with Ruby

00:20:13.630 --> 00:20:17.100
on Rails, but it wasn't really
keeping up with demand, not

00:20:17.100 --> 00:20:18.700
scaling how we wanted to.

00:20:18.700 --> 00:20:22.510
So we wrote version two in Go,
and that made it a lot faster.

00:20:22.510 --> 00:20:26.230
We were able to take our roughly
30 Ruby servers and

00:20:26.230 --> 00:20:28.590
condense them down to
two Go servers.

00:20:28.590 --> 00:20:32.700
And the second one is mostly
for redundancy.

00:20:32.700 --> 00:20:34.900
We have a couple other products
written in Go.

00:20:34.900 --> 00:20:37.560
One is IronMQ, a scalable
message queue.

00:20:37.560 --> 00:20:41.160
It runs underneath IronWorker
and sends all your task data

00:20:41.160 --> 00:20:42.300
to the runners.

00:20:42.300 --> 00:20:45.780
And then IronCache, which is
our latest product, it's a

00:20:45.780 --> 00:20:47.450
distributed key value store.

00:20:47.450 --> 00:20:51.720
Both of these have RESTful HTTP
APIs and text protocol

00:20:51.720 --> 00:20:54.400
support, being stock in the case
of IronMQ and memchache

00:20:54.400 --> 00:20:56.970
in the case of IronCache.

00:20:56.970 --> 00:21:01.000
So here's just an illustration
of the flow of data through

00:21:01.000 --> 00:21:02.340
IronWorker and IronMQ.

00:21:02.340 --> 00:21:06.450
You send it an HTTP request to
go through the API, and then

00:21:06.450 --> 00:21:09.870
we do a little processing there
and put it on IronMQ.

00:21:09.870 --> 00:21:12.290
And we have all these runners,
which is what we call the

00:21:12.290 --> 00:21:17.740
servers that actually run the
job, polling tasks off of this

00:21:17.740 --> 00:21:21.300
queue, and then running them.

00:21:21.300 --> 00:21:25.330
So we serve a lot of HTTP
requests in Iron.io using Go,

00:21:25.330 --> 00:21:28.670
and the strategy that we use to
serve those is generally by

00:21:28.670 --> 00:21:31.800
composing HTTP handlers
together into a chain.

00:21:31.800 --> 00:21:34.050
So the first handler in
the chain is typically

00:21:34.050 --> 00:21:35.330
authentication.

00:21:35.330 --> 00:21:38.960
We decide whether the request
shold be able to continue, and

00:21:38.960 --> 00:21:40.670
if not, it's unauthorized.

00:21:40.670 --> 00:21:42.820
It if it is able to continue,
it delegates to the next

00:21:42.820 --> 00:21:44.130
handler in the chain.

00:21:44.130 --> 00:21:48.010
Then we do something similar
with statistics and usage.

00:21:48.010 --> 00:21:50.480
So each one of these handlers
has a very specific purpose,

00:21:50.480 --> 00:21:52.800
and then it delegates onto the
next handler until it gets to

00:21:52.800 --> 00:21:56.330
the end, which does the
validation of the request and

00:21:56.330 --> 00:22:01.470
the database operations, and
finally serves the response.

00:22:01.470 --> 00:22:05.000
We don't use a lot of
concurrency directly in our

00:22:05.000 --> 00:22:07.290
applications, but that's really
kind of a testament to

00:22:07.290 --> 00:22:12.000
the good design of
the Go libraries.

00:22:12.000 --> 00:22:16.220
So the HTTP package
automatically serves requests

00:22:16.220 --> 00:22:19.460
in separate Go routines for us,
we just have to make sure

00:22:19.460 --> 00:22:21.800
that our handlers aren't sharing
any state that's not

00:22:21.800 --> 00:22:23.100
synchronized.

00:22:23.100 --> 00:22:27.170
For text protocols, we do run
separate Go routines for each

00:22:27.170 --> 00:22:31.170
client, which doesn't require
much communication.

00:22:31.170 --> 00:22:34.140
But we automatically get
Asynchronous I/O with that,

00:22:34.140 --> 00:22:35.380
which is really awesome.

00:22:35.380 --> 00:22:38.040
If we were writing this in
node js we would have all

00:22:38.040 --> 00:22:39.510
these callbacks while
we waited for

00:22:39.510 --> 00:22:40.770
operations to complete.

00:22:40.770 --> 00:22:44.130
Or if we were writing it in C
or C++ we would have to mess

00:22:44.130 --> 00:22:45.240
with [? e-poll. ?]

00:22:45.240 --> 00:22:48.500
It's just a big pain, but Go
takes care of that for us in

00:22:48.500 --> 00:22:51.070
the libraries, and we can just
write code the way we

00:22:51.070 --> 00:22:53.480
want to write it.

00:22:53.480 --> 00:22:56.230
So one other place we use
concurrency is as kind of an

00:22:56.230 --> 00:22:57.010
optimization.

00:22:57.010 --> 00:23:01.580
Sometimes you have these
actions in the request,

00:23:01.580 --> 00:23:04.170
response path that don't
actually need to be completed

00:23:04.170 --> 00:23:06.830
by the time you serve
the response.

00:23:06.830 --> 00:23:09.880
So we can move those into
a separate Go routine.

00:23:09.880 --> 00:23:12.970
Even less critical things can
just have a dedicated go

00:23:12.970 --> 00:23:15.800
routine that's kind of running
in the background, gathering

00:23:15.800 --> 00:23:19.050
up all this information and
patching it together into one

00:23:19.050 --> 00:23:22.600
request or one database update,
or whatever it is.

00:23:22.600 --> 00:23:26.750
So as an example of that first
point, we have here an HTTP

00:23:26.750 --> 00:23:30.920
handler that is getting a
project ID and then updating

00:23:30.920 --> 00:23:34.230
some statistics related
to that project ID.

00:23:34.230 --> 00:23:37.750
And this is a somewhat
expensive operation,

00:23:37.750 --> 00:23:42.160
noticeable if we keep it in
the request response path.

00:23:42.160 --> 00:23:47.620
So in the after code, we've
moved that into an anonymous

00:23:47.620 --> 00:23:51.250
function, put Go at the front,
and made it into a call.

00:23:51.250 --> 00:23:54.070
And now that code runs in a
separate Go routine, and it

00:23:54.070 --> 00:23:58.530
greatly reduces the latency
of this request.

00:23:58.530 --> 00:24:01.640
And this is something that's
really cheap and easy to do,

00:24:01.640 --> 00:24:03.930
and we've hardly even
changed the code.

00:24:03.930 --> 00:24:07.990
It looks almost the same.

00:24:07.990 --> 00:24:11.070
So why do we use Go?

00:24:11.070 --> 00:24:12.870
Well for one, it's fast.

00:24:12.870 --> 00:24:16.070
It right not only runs fast,
but it compiles quickly.

00:24:16.070 --> 00:24:18.490
And I've worked on projects
that take 45 minutes or an

00:24:18.490 --> 00:24:21.060
hour to compile, and
it's not fun.

00:24:21.060 --> 00:24:23.800
It's still fairly expressive
for a compiled, statically

00:24:23.800 --> 00:24:24.860
typed language.

00:24:24.860 --> 00:24:27.480
You don't tend to miss features
from languages like

00:24:27.480 --> 00:24:28.770
Ruby and Python.

00:24:28.770 --> 00:24:31.770
It has a very rich
standard library.

00:24:31.770 --> 00:24:36.120
If you wanted to operate with
formats like JSON or protocols

00:24:36.120 --> 00:24:39.440
like HTTP and other languages,
you might have to enlist in a

00:24:39.440 --> 00:24:42.730
third party or non-standard
library to get things done.

00:24:42.730 --> 00:24:44.550
But almost everything
we need is

00:24:44.550 --> 00:24:48.270
built into the Go libraries.

00:24:48.270 --> 00:24:51.350
It's not tied to a VM, which
makes deployment really easy.

00:24:51.350 --> 00:24:55.420
Go compiles static binaries with
no dependencies, so you

00:24:55.420 --> 00:24:58.600
just drop it on a server,
run it, and that's it.

00:24:58.600 --> 00:25:00.520
Nothing to really think about.

00:25:00.520 --> 00:25:01.740
And finally, Go is awesome.

00:25:01.740 --> 00:25:03.980
We have a lot of
fun writing Go.

00:25:03.980 --> 00:25:06.850
And so I hope if you were
harboring any doubts about

00:25:06.850 --> 00:25:09.960
using Go in production before
this presentation, we've kind

00:25:09.960 --> 00:25:11.750
of helped dispel those doubts.

00:25:11.750 --> 00:25:13.000
Thank you.

00:25:22.200 --> 00:25:23.530
ANDREW GERRAND: Thanks.

00:25:23.530 --> 00:25:27.390
All right, so now I've invited
to the others back on stage,

00:25:27.390 --> 00:25:30.980
and if anybody would like to
step up to the mic and ask

00:25:30.980 --> 00:25:33.080
questions to our panelists,
we'd be more than happy to

00:25:33.080 --> 00:25:34.330
answer them.

00:25:36.470 --> 00:25:37.980
First person to do so gets
a Go [INAUDIBLE].

00:25:45.570 --> 00:25:49.840
AUDIENCE: The guy from
Heroku, one question.

00:25:49.840 --> 00:25:52.180
Keith.

00:25:52.180 --> 00:25:58.670
You're using Erlang as well at
Heroku, and then what do you

00:25:58.670 --> 00:26:02.110
use rather Erlang versus Go?

00:26:02.110 --> 00:26:08.450
Because both languages do
concurrency correctly, they're

00:26:08.450 --> 00:26:14.870
one of the few languages that
doesn't suck when it comes to

00:26:14.870 --> 00:26:17.970
writing [? an array ?] of
concurrent software and

00:26:17.970 --> 00:26:19.220
reliable software.

00:26:21.750 --> 00:26:24.220
KEITH RARICK: So how do we
decide whether to use Erlang

00:26:24.220 --> 00:26:28.590
or Go for any given project?

00:26:28.590 --> 00:26:32.010
It's mostly up to whoever's
working on the project.

00:26:34.630 --> 00:26:38.690
The most well known thing that
we have in Erlang is the

00:26:38.690 --> 00:26:41.990
actual HTTP front end routers
that I was mentioning earlier,

00:26:41.990 --> 00:26:45.680
those are all written
in Erlang.

00:26:45.680 --> 00:26:48.975
I guess the biggest reason for
those is that that project was

00:26:48.975 --> 00:26:53.000
started before, I believe
before Go even existed.

00:26:53.000 --> 00:26:56.680
Certainly before it was
publicly available.

00:26:56.680 --> 00:27:01.500
And the team that maintains it,
they like Erlang and they

00:27:01.500 --> 00:27:05.870
don't feel like rewriting
the whole thing.

00:27:05.870 --> 00:27:09.440
But yeah, it's pretty much
a personal choice.

00:27:09.440 --> 00:27:10.970
I don't think we've
started many new

00:27:10.970 --> 00:27:14.120
projects in Erlang lately.

00:27:14.120 --> 00:27:15.460
AUDIENCE: So why?

00:27:15.460 --> 00:27:17.280
KEITH RARICK: Why?

00:27:17.280 --> 00:27:21.410
Well, it's hard to find
Erlang developers.

00:27:21.410 --> 00:27:26.280
AUDIENCE: So Go might be a
bit more approachable to

00:27:26.280 --> 00:27:28.190
developers than compared
to Erlang.

00:27:28.190 --> 00:27:28.970
KEITH RARICK: Absolutely.

00:27:28.970 --> 00:27:30.510
AUDIENCE: OK.

00:27:30.510 --> 00:27:31.930
Thanks.

00:27:31.930 --> 00:27:33.655
ANDREW GERRAND: Maybe you could
say a little bit, maybe

00:27:33.655 --> 00:27:36.150
each of you could say a little
bit about your experience

00:27:36.150 --> 00:27:39.540
bringing new developers
up to speed with Go.

00:27:39.540 --> 00:27:40.790
Leading on from there.

00:27:43.580 --> 00:27:44.836
Someone.

00:27:44.836 --> 00:27:46.086
EVAN SHAW: Okay, I'll Go.

00:27:49.299 --> 00:27:53.910
Should I talk about hiring
Go developers as well?

00:27:53.910 --> 00:27:55.840
ANDREW GERRAND: Sure, whatever's
most interesting.

00:27:55.840 --> 00:27:59.792
EVAN SHAW: So since I've been
working on Iron.io, we've had

00:27:59.792 --> 00:28:03.250
I think a couple times where
we've tried to hire Go

00:28:03.250 --> 00:28:05.720
programmers, and we've
been really

00:28:05.720 --> 00:28:07.696
succesful in that so far.

00:28:07.696 --> 00:28:15.567
We just put out a job notice
on the [INAUDIBLE], and I

00:28:15.567 --> 00:28:21.350
think within two days we had
between [INAUDIBLE].

00:28:21.350 --> 00:28:25.474
Some, not so good, but others
very good, to the point where

00:28:25.474 --> 00:28:30.444
we had to pool some time
deciding who to hire.

00:28:30.444 --> 00:28:33.923
So, no concern there.

00:28:33.923 --> 00:28:38.147
We've also had a couple of
developers who did not have

00:28:38.147 --> 00:28:41.129
any Go experience, or did not
have much Go experience come

00:28:41.129 --> 00:28:47.590
in, and we found it very easy to
get them up to speed on how

00:28:47.590 --> 00:28:49.330
Go works, and [INAUDIBLE].

00:28:55.820 --> 00:28:57.270
GUSTAVO NIEMEYER: After this
talk, it's probably going to

00:28:57.270 --> 00:29:00.660
get harder to find people.

00:29:00.660 --> 00:29:03.500
KEITH RARICK: Yeah, I just
wanted to add that something

00:29:03.500 --> 00:29:06.970
that I've seen over and over
again is talking with people

00:29:06.970 --> 00:29:11.640
who are looking at Go or
thinking about it, or maybe

00:29:11.640 --> 00:29:14.110
they haven't even really looked
at it carefully, but

00:29:14.110 --> 00:29:19.220
you can talk to them about a new
language, especially Go.

00:29:19.220 --> 00:29:21.730
You can show them some examples,
or you can say, oh,

00:29:21.730 --> 00:29:24.220
look, it has all these great
features, and it's easy to

00:29:24.220 --> 00:29:26.970
deploy, and all this stuff.

00:29:26.970 --> 00:29:29.280
But then if you can get someone
to actually sit down

00:29:29.280 --> 00:29:32.430
and write a page of code, spend
10 minutes actually

00:29:32.430 --> 00:29:34.530
using it, that's a whole
different story.

00:29:34.530 --> 00:29:37.430
Then the light bulbs start going
off, and then they are

00:29:37.430 --> 00:29:42.870
going on, and then they really
start to appreciate it.

00:29:42.870 --> 00:29:45.520
But until that moment, that's
usually a big turning point.

00:29:45.520 --> 00:29:47.760
It's like people look at it,
and they go, oh, that looks

00:29:47.760 --> 00:29:50.020
interesting, it's pretty cool,
and then they forget about it.

00:29:50.020 --> 00:29:52.150
And then you do it again,
and they give

00:29:52.150 --> 00:29:53.010
you the same response.

00:29:53.010 --> 00:29:55.650
But then when they actually
start using it, then it's

00:29:55.650 --> 00:29:56.793
pretty different.

00:29:56.793 --> 00:29:58.370
GUSTAVO NIEMEYER: At Canonical,
it's been quite a

00:29:58.370 --> 00:30:01.070
ride as well.

00:30:01.070 --> 00:30:03.330
Even more if you have a good

00:30:03.330 --> 00:30:05.800
development body in the company.

00:30:05.800 --> 00:30:08.430
It's not straightforward to
just switch languages.

00:30:08.430 --> 00:30:11.710
People are, sometimes they're
passionate about the language.

00:30:11.710 --> 00:30:15.080
Sometimes they're unwilling,
they just don't have the time

00:30:15.080 --> 00:30:17.660
to try something new.

00:30:17.660 --> 00:30:21.240
I personally find people all
over the place, but I share as

00:30:21.240 --> 00:30:26.830
well Keith's feeling that when
people do take the time to

00:30:26.830 --> 00:30:29.830
experiment with it, and have
an open mind about the

00:30:29.830 --> 00:30:33.590
benefits of developing it, I do
see people switching over

00:30:33.590 --> 00:30:36.135
and getting closer
to the language.

00:30:36.135 --> 00:30:38.700
ANDREW GERRAND: Wanna
take this question?

00:30:38.700 --> 00:30:40.930
AUDIENCE: One of the common
recurring themes we heard was

00:30:40.930 --> 00:30:45.400
that we used to use Ruby, and so
I was wondering what's the

00:30:45.400 --> 00:30:48.830
Rails of Go, and what do you
guys think about the packages,

00:30:48.830 --> 00:30:51.830
and Ruby has a really huge
community, and a lot of

00:30:51.830 --> 00:30:54.960
different gems, and what do
you guys think about the

00:30:54.960 --> 00:30:56.210
community around Go?

00:30:58.780 --> 00:31:00.770
ANDREW GERRAND: So that's kind
of two questions there.

00:31:00.770 --> 00:31:04.080
Maybe Patrick's best suited to
answering about doing front

00:31:04.080 --> 00:31:06.160
end development with Go, because
I know his entire

00:31:06.160 --> 00:31:08.680
stack is written in Go.

00:31:08.680 --> 00:31:10.530
PATRICK CROSBY: We did have a
prototype that was in Rails,

00:31:10.530 --> 00:31:14.605
and we were worried about
switching mainly because of

00:31:14.605 --> 00:31:15.130
the plug-ins.

00:31:15.130 --> 00:31:18.810
We didn't want to write user
authentication again.

00:31:18.810 --> 00:31:23.460
But then it actually took about
an afternoon to write

00:31:23.460 --> 00:31:26.270
the equivalent of [INAUDIBLE] in
Go, and so we haven't been

00:31:26.270 --> 00:31:29.480
spending our time on
stuff like that.

00:31:29.480 --> 00:31:32.050
But it's actually very easy.

00:31:32.050 --> 00:31:34.760
The net HTTP package is great.

00:31:34.760 --> 00:31:38.700
All you do is provide a function
that handles a route,

00:31:38.700 --> 00:31:43.950
and the template package is
incredibly fast compared to

00:31:43.950 --> 00:31:45.600
ERB or something.

00:31:45.600 --> 00:31:48.480
So I wouldn't hesitate
to try it.

00:31:48.480 --> 00:31:53.760
And I don't think there's a
Rails, there's a few other

00:31:53.760 --> 00:31:56.210
third party packages for
providing web services, but

00:31:56.210 --> 00:32:00.890
the standard net HTTP
works great for us.

00:32:00.890 --> 00:32:01.930
ANDREW GERRAND: And do
any of you want to

00:32:01.930 --> 00:32:03.975
speak to the Go community?

00:32:03.975 --> 00:32:06.630
The size of standard
[INAUDIBLE]?

00:32:06.630 --> 00:32:09.310
Well I know I know that at least
a few people here are

00:32:09.310 --> 00:32:11.220
active members of it.

00:32:11.220 --> 00:32:13.080
GUSTAVO NIEMEYER: So the Go
community, in a way it's like

00:32:13.080 --> 00:32:15.930
we are the Go community
as well.

00:32:15.930 --> 00:32:17.180
ANDREW GERRAND: Not in total.

00:32:20.870 --> 00:32:22.890
GUSTAVO NIEMEYER: Well, it's
been growing, right?

00:32:22.890 --> 00:32:25.540
The packages are just like
any other language.

00:32:25.540 --> 00:32:27.770
The quality of the packages
are all over the place.

00:32:27.770 --> 00:32:31.490
The number of packages, we have
quite a few of those.

00:32:31.490 --> 00:32:38.330
The core packages for our
development, we pretty much

00:32:38.330 --> 00:32:41.700
find what we want, or we develop
the missing pieces

00:32:41.700 --> 00:32:45.430
somewhat easily as well.

00:32:45.430 --> 00:32:52.170
In terms of the question about
Rails, or which platform to

00:32:52.170 --> 00:32:55.170
use, I share Patrick's
view as well.

00:32:55.170 --> 00:32:58.800
The standard library is
really good as well.

00:32:58.800 --> 00:33:00.860
The HTTP package, for instance,
it's unlike other

00:33:00.860 --> 00:33:03.520
languages we've tried.

00:33:03.520 --> 00:33:04.920
ANDREW GERRAND: And I think the
man in the glasses of at

00:33:04.920 --> 00:33:06.323
back there has a question.

00:33:06.323 --> 00:33:07.290
AUDIENCE: Hi.

00:33:07.290 --> 00:33:10.700
One of the questions I've
heard from people when I

00:33:10.700 --> 00:33:14.060
prophecise about Go is whether
having a mark-and-sweep

00:33:14.060 --> 00:33:17.350
garbage collector in a systems
language makes any sense.

00:33:17.350 --> 00:33:21.170
And I pushed back a little
bit, obviously.

00:33:21.170 --> 00:33:22.940
But I'm wondering if you guys
have actually, using it in

00:33:22.940 --> 00:33:26.050
production, can talk about
whether having a garbage

00:33:26.050 --> 00:33:29.070
collector in that language is an
issue for you guys or not.

00:33:29.070 --> 00:33:30.320
I'm just curious.

00:33:34.560 --> 00:33:35.200
PATRICK CROSBY: It has not.

00:33:35.200 --> 00:33:40.290
The only issue we had is there
is a bug using 32-bit servers

00:33:40.290 --> 00:33:41.440
with garbage collection.

00:33:41.440 --> 00:33:44.110
But once we found out that there
was a bug and switched

00:33:44.110 --> 00:33:46.780
to 64-bit servers, we haven't
had any problem with garbage

00:33:46.780 --> 00:33:47.660
collection.

00:33:47.660 --> 00:33:49.990
ANDREW GERRAND: And it's worth
noting that that issue is

00:33:49.990 --> 00:33:51.800
within a few weeks of being
fixed entirely.

00:33:55.750 --> 00:33:58.160
KEITH RARICK: One thing that I
can say is we haven't yet used

00:33:58.160 --> 00:34:03.830
Go for anything that's highly
sensitive to latency, but

00:34:03.830 --> 00:34:08.550
Heroku has a lot of pieces
inside, a lot of different

00:34:08.550 --> 00:34:12.020
components that were running in
production, and honestly,

00:34:12.020 --> 00:34:15.300
very few of them are actually
that latency sensitive.

00:34:15.300 --> 00:34:21.659
One example is something like
again, this front end HTTP

00:34:21.659 --> 00:34:24.480
router that handles user
requests, that matters.

00:34:24.480 --> 00:34:28.670
It matters that when a request
comes in, it's not waiting for

00:34:28.670 --> 00:34:30.909
a GC pause.

00:34:30.909 --> 00:34:37.270
But relatively few pieces
actually depend on that

00:34:37.270 --> 00:34:40.409
particular kind of performance
sensitivity.

00:34:40.409 --> 00:34:45.090
So for most things that we're
doing, it's batch operations,

00:34:45.090 --> 00:34:51.159
it's background tasks, and
it's not a big deal.

00:34:51.159 --> 00:34:53.610
ANDREW GERRAND: But have you
actually observed any GC

00:34:53.610 --> 00:34:56.800
issues in what you're
doing anyway?

00:34:56.800 --> 00:34:58.050
KEITH RARICK: No.

00:35:00.850 --> 00:35:02.980
GUSTAVO NIEMEYER: I think in
our case it's similar.

00:35:02.980 --> 00:35:09.000
We don't have workload with very
low latency requirements.

00:35:09.000 --> 00:35:11.540
And I also feel a little bit
like the speed of the

00:35:11.540 --> 00:35:14.290
language, the speed in which
everything else executes, like

00:35:14.290 --> 00:35:18.580
dwarfs the garbage collection
problems we might have.

00:35:18.580 --> 00:35:21.370
And I have to say as well,
that in fact, from some

00:35:21.370 --> 00:35:26.330
perspectives I've developed
quite a few [INAUDIBLE]

00:35:26.330 --> 00:35:29.300
extensions for Python
to speed things up.

00:35:29.300 --> 00:35:34.600
And while the reference counting
could be faster, it

00:35:34.600 --> 00:35:37.840
also creates a lot of issues
in terms of leaks that are

00:35:37.840 --> 00:35:43.020
really hard to find, and it's
always a hunt going after

00:35:43.020 --> 00:35:44.030
what's going on.

00:35:44.030 --> 00:35:49.940
So in that regard, we have six
stations as well in at least a

00:35:49.940 --> 00:35:53.560
couple of our packages, and we
haven't had any such issues.

00:35:53.560 --> 00:35:57.600
So in that sense, the, garbage
collector actually helps us.

00:35:57.600 --> 00:36:00.790
ANDREW GERRAND: We'll take
another question.

00:36:00.790 --> 00:36:03.000
AUDIENCE: So all of the
presentations said that while

00:36:03.000 --> 00:36:05.530
Go is awesome, could you share,
like, some of either

00:36:05.530 --> 00:36:08.460
your favorite parts of it,
or maybe things that your

00:36:08.460 --> 00:36:10.730
developers, as you've been
wrapping them up are like,

00:36:10.730 --> 00:36:14.260
aha, that's so great.

00:36:14.260 --> 00:36:16.650
KEITH RARICK: Gofmt.

00:36:16.650 --> 00:36:19.690
That is my favorite
part of Go.

00:36:19.690 --> 00:36:21.110
ANDREW GERRAND: It's
not a swear word.

00:36:21.110 --> 00:36:26.000
Gofmt is the formatting tool
that makes all Go code look

00:36:26.000 --> 00:36:29.330
the same, ending all the style
wars about why it's best in

00:36:29.330 --> 00:36:31.280
[INAUDIBLE] placement
and so on.

00:36:31.280 --> 00:36:33.020
KEITH RARICK: More specifically,
it's not just

00:36:33.020 --> 00:36:38.800
that it exists, but that I am
astounded at what a good job

00:36:38.800 --> 00:36:41.950
the community has done at sort
of adopting it and sticking

00:36:41.950 --> 00:36:45.720
with it, and consistently using
this tool, and never

00:36:45.720 --> 00:36:48.960
having to worry about that stuff
again is just, I mean

00:36:48.960 --> 00:36:50.210
don't waste that time.

00:36:52.870 --> 00:36:55.650
GUSTAVO NIEMEYER: So to
kind of restate what I

00:36:55.650 --> 00:36:57.170
said earlier again.

00:36:57.170 --> 00:37:00.780
To me there's no single feature
of Go that I find, oh

00:37:00.780 --> 00:37:04.630
my God, this is so amazing,
and I've never

00:37:04.630 --> 00:37:05.710
seen anything similar.

00:37:05.710 --> 00:37:09.340
Perhaps gofmt is a little bit
unlike anything else.

00:37:09.340 --> 00:37:14.620
But I think what's really
fantastic about Go and unlike

00:37:14.620 --> 00:37:17.890
anything else in my perspective
is precisely the

00:37:17.890 --> 00:37:20.945
fact of all the bits together,
how they make sense.

00:37:23.710 --> 00:37:24.900
EVAN SHAW: Yeah, I
really agree with

00:37:24.900 --> 00:37:26.740
what Gustavo was saying.

00:37:26.740 --> 00:37:29.642
It's hard to really single
out any one thing

00:37:29.642 --> 00:37:31.360
that makes Go great.

00:37:31.360 --> 00:37:33.547
But if you really force
me to do it, I

00:37:33.547 --> 00:37:35.600
would say the libraries.

00:37:35.600 --> 00:37:39.005
I think of all the languages
I've used, most libraries

00:37:39.005 --> 00:37:41.903
[INAUDIBLE]

00:37:41.903 --> 00:37:43.352
libraries I've seen.

00:37:43.352 --> 00:37:44.602
[INAUDIBLE].

00:37:47.216 --> 00:37:51.060
If you are curious about how
something works internally,

00:37:51.060 --> 00:37:55.140
it's very easy to dive in and
start reading the code.

00:37:55.140 --> 00:37:57.742
It's very accessible
code, and good for

00:37:57.742 --> 00:38:00.770
learning code as well.

00:38:00.770 --> 00:38:02.190
KEITH RARICK: Yeah, I want
to echo that too.

00:38:02.190 --> 00:38:05.660
It's just systemic
good design.

00:38:05.660 --> 00:38:06.410
ANDREW GERRAND: Thanks.

00:38:06.410 --> 00:38:07.550
Next question?

00:38:07.550 --> 00:38:12.210
AUDIENCE: So I'm also using Go
on production at SmugMug.

00:38:12.210 --> 00:38:14.970
First of all I wanted to say
thanks to everyone, and people

00:38:14.970 --> 00:38:17.950
who are on the golang-nuts list,
I read a lot of your

00:38:17.950 --> 00:38:20.480
pots, and they're
very helpful.

00:38:20.480 --> 00:38:22.690
I mean, personally the thing
for me that I like about Go

00:38:22.690 --> 00:38:26.020
the most is it's impossible to
get confused by most Go code.

00:38:26.020 --> 00:38:28.280
I can show it to other
people I work with.

00:38:28.280 --> 00:38:29.440
It's always very
straightforward, so I

00:38:29.440 --> 00:38:31.540
appreciate the fact that there's
been a tendency to

00:38:31.540 --> 00:38:33.000
keep it simple.

00:38:33.000 --> 00:38:35.910
So two questions I have
for the panel.

00:38:35.910 --> 00:38:40.350
One thing I noticed when I
started building the proxy

00:38:40.350 --> 00:38:42.970
server I wrote was sort
of a lack of a

00:38:42.970 --> 00:38:45.550
standard make like tool.

00:38:45.550 --> 00:38:47.320
And there are a lot of them
out there, and I'm just

00:38:47.320 --> 00:38:49.900
wondering, and I just went with
shell scripts because I

00:38:49.900 --> 00:38:52.370
couldn't really see one
that had traction.

00:38:52.370 --> 00:38:57.660
Just wondering if there's a
preference among the panel for

00:38:57.660 --> 00:39:00.380
build tools automation.

00:39:00.380 --> 00:39:02.850
PATRICK CROSBY: I think a lot of
that's changed since Go 1.

00:39:02.850 --> 00:39:06.900
Go install basically does
everything for you.

00:39:06.900 --> 00:39:12.660
We use that just go install
StatHat basically.

00:39:12.660 --> 00:39:16.790
GUSTAVO NIEMEYER: It's not even
just the building part,

00:39:16.790 --> 00:39:21.040
there's a good, consistent
scheme in which

00:39:21.040 --> 00:39:22.970
libraries are organized.

00:39:22.970 --> 00:39:26.280
They're fetched from the network
as well, so you can

00:39:26.280 --> 00:39:29.270
do, like, goget and URL all with
the command, and you get

00:39:29.270 --> 00:39:29.880
the command running.

00:39:29.880 --> 00:39:31.960
Even though it has dependencies,
it has build

00:39:31.960 --> 00:39:34.845
tools, so I find
it pretty good.

00:39:34.845 --> 00:39:36.705
ANDREW GERRAND: Yeah, but what
they're referring to is, for

00:39:36.705 --> 00:39:39.590
those who aren't familiar, is
this Go tool that ships with

00:39:39.590 --> 00:39:43.410
the Go tool chain, that's just
called Go and there are

00:39:43.410 --> 00:39:46.150
various verbs like gobuild,
gotest, goinstall,

00:39:46.150 --> 00:39:49.440
gofmt, and so on.

00:39:49.440 --> 00:39:51.740
AUDIENCE: So my second question
was if there's

00:39:51.740 --> 00:39:55.610
anything from the libraries
you think is missing that

00:39:55.610 --> 00:39:56.860
you'd really like to see.

00:40:05.040 --> 00:40:06.830
GUSTAVO NIEMEYER: There are
certain things I'd like to see

00:40:06.830 --> 00:40:08.340
better done, perhaps.

00:40:08.340 --> 00:40:14.610
Like SSH package is one that is
evolving, but it's complex

00:40:14.610 --> 00:40:17.490
to get something that really
works across all the cases in

00:40:17.490 --> 00:40:19.270
a consistent and stable way.

00:40:19.270 --> 00:40:21.810
So I appreciate the package.

00:40:21.810 --> 00:40:24.660
I want to see it being
polished over time.

00:40:28.200 --> 00:40:28.700
ANDREW GERRAND: Thanks.

00:40:28.700 --> 00:40:32.260
Take the next question.

00:40:32.260 --> 00:40:35.120
AUDIENCE: So this is just from
the Google moderator, which is

00:40:35.120 --> 00:40:36.330
linked to from the screen.

00:40:36.330 --> 00:40:37.870
So Jason asked, and
you might have

00:40:37.870 --> 00:40:38.550
covered this early, actually.

00:40:38.550 --> 00:40:43.070
Can you talk about how long
it would take to learn Go?

00:40:43.070 --> 00:40:44.790
ANDREW GERRAND: How long does
it take to learn Go?

00:40:47.520 --> 00:40:49.430
KEITH RARICK: I know I referred
to someone to the Go

00:40:49.430 --> 00:40:53.100
tour who wanted to learn Go, and
they learned it within a

00:40:53.100 --> 00:40:56.400
few weeks, and they're now
working somewhere programming

00:40:56.400 --> 00:40:57.300
Go every day.

00:40:57.300 --> 00:41:01.930
GUSTAVO NIEMEYER: So this is a
tricky question, I find as

00:41:01.930 --> 00:41:04.250
well, personally at least.

00:41:04.250 --> 00:41:05.830
I find that I never
stop learning.

00:41:08.590 --> 00:41:10.880
I'm still learning Go as well,
even though I've started a

00:41:10.880 --> 00:41:15.520
couple of years ago, and I hope
I don't stop learning.

00:41:15.520 --> 00:41:19.680
People can get up to speed with
the basic language and

00:41:19.680 --> 00:41:22.240
productive as Keith
was saying.

00:41:22.240 --> 00:41:25.300
And if you're proficient with
language, in just a few

00:41:25.300 --> 00:41:27.360
minutes you're going to
be doing something.

00:41:27.360 --> 00:41:29.570
It's going to take a little bit
longer for you to get used

00:41:29.570 --> 00:41:34.490
to the conventions and what it
takes to get a feeling for

00:41:34.490 --> 00:41:38.750
what is Go proper,
and it's learning

00:41:38.750 --> 00:41:40.420
to program in general.

00:41:40.420 --> 00:41:41.985
It's a lifelong task, I think.

00:41:44.780 --> 00:41:46.980
ANDREW GERRAND: Thanks,
next question?

00:41:46.980 --> 00:41:47.520
AUDIENCE: Hi.

00:41:47.520 --> 00:41:49.540
I was wondering if you guys
could share your experiences

00:41:49.540 --> 00:41:52.820
with other parts of the
development tooling, like

00:41:52.820 --> 00:41:55.960
debuggers, profilers,
even ID support.

00:41:58.930 --> 00:42:02.310
how easy is to work with and
use, and help solve real

00:42:02.310 --> 00:42:03.560
problems, that kind of thing?

00:42:07.930 --> 00:42:10.320
KEITH RARICK: I can just
comment briefly.

00:42:10.320 --> 00:42:14.715
When working on Doozer, the Go
Profiler was invaluable.

00:42:18.190 --> 00:42:23.750
It's one of the things that, I
don't have a whole lot to say

00:42:23.750 --> 00:42:25.365
about it, but it was nice.

00:42:25.365 --> 00:42:30.180
It was pretty easy to use, and
told me what I need to know.

00:42:30.180 --> 00:42:32.550
ANDREW GERRAND: So the profiler
that comes with Go is

00:42:32.550 --> 00:42:36.190
a very intuitive pprof which is
a C++ profiling tool that

00:42:36.190 --> 00:42:41.790
Google built, and it provides
graphs of memory allocations,

00:42:41.790 --> 00:42:46.340
and also CPU utilization in
a core graph kind of cell.

00:42:46.340 --> 00:42:48.430
KEITH RARICK: And one of my
coworkers also said that he

00:42:48.430 --> 00:42:50.530
was very happy with the
GDP integration.

00:42:50.530 --> 00:42:53.170
He was pleasantly surprised.

00:42:53.170 --> 00:42:56.496
And if you know him, that's
an understatement.

00:42:56.496 --> 00:43:00.060
He was pleasantly surprised that
it just worked, and it

00:43:00.060 --> 00:43:01.610
and it was really,
really well.

00:43:01.610 --> 00:43:02.860
Nicely done.

00:43:04.770 --> 00:43:06.140
ANDREW GERRAND: Take
another question.

00:43:06.140 --> 00:43:07.750
AUDIENCE: Another moderator
question from Josh.

00:43:07.750 --> 00:43:09.350
What books on Go would
you recommend?

00:43:15.820 --> 00:43:17.070
PATRICK CROSBY: Golang.org.

00:43:21.130 --> 00:43:23.310
Sorry, I haven't actually
read any other Go books,

00:43:23.310 --> 00:43:27.124
but it's a good site.

00:43:27.124 --> 00:43:29.992
EVAN SHAW: I haven't read any
Go books either, but I will

00:43:29.992 --> 00:43:33.570
point out again that
I'm writing one.

00:43:33.570 --> 00:43:35.730
GUSTAVO NIEMEYER: Sorry.

00:43:35.730 --> 00:43:37.200
ANDREW GERRAND: Thanks,
Gustavo.

00:43:37.200 --> 00:43:37.900
AUDIENCE: Thanks.

00:43:37.900 --> 00:43:40.360
First I'd like to congratulate
the Go team on making

00:43:40.360 --> 00:43:42.520
something simple enough that the
most interesting thing you

00:43:42.520 --> 00:43:45.490
can do is write useful code,
which I think is a pretty

00:43:45.490 --> 00:43:46.740
impressive achievement.

00:43:48.890 --> 00:43:52.180
So I'm first interested in any
advice you might have for

00:43:52.180 --> 00:43:57.210
people looking to deploy Go
potentially into a high

00:43:57.210 --> 00:44:00.780
traffic environment, in terms
of for instance, like

00:44:00.780 --> 00:44:01.770
segmented stacks.

00:44:01.770 --> 00:44:04.670
But boundaries, trying to
avoid going over those.

00:44:04.670 --> 00:44:06.270
I know that there might be a
performance issue associated

00:44:06.270 --> 00:44:08.710
with that, or Scheduler
being rather young.

00:44:08.710 --> 00:44:13.130
Are there any words of wisdom
to avoid unforeseen

00:44:13.130 --> 00:44:14.380
consequences?

00:44:18.935 --> 00:44:20.930
ANDREW GERRAND: Do you mean like
to avoid trouble spots,

00:44:20.930 --> 00:44:21.720
essentially?

00:44:21.720 --> 00:44:23.770
AUDIENCE: Yeah, performance
or reliability gotchas,

00:44:23.770 --> 00:44:25.020
effectively.

00:44:26.900 --> 00:44:29.020
ANDREW GERRAND: Maybe you can
speak to it, but I was just

00:44:29.020 --> 00:44:31.930
going to say the general
approach that I've seen inside

00:44:31.930 --> 00:44:34.030
Google is just write the
simplest code that is

00:44:34.030 --> 00:44:38.130
obviously correct, and then if
things start going pear shaped

00:44:38.130 --> 00:44:43.260
profile, and that recipe tends
to work pretty well.

00:44:43.260 --> 00:44:45.530
KEITH RARICK: That's exactly
what I was going to say.

00:44:45.530 --> 00:44:48.870
I mean, that's just you do in
general with programming.

00:44:48.870 --> 00:44:51.490
Don't worry too much about
performance at first, just

00:44:51.490 --> 00:44:52.360
write it correctly.

00:44:52.360 --> 00:44:55.570
And then if you have performance
problems, fix

00:44:55.570 --> 00:44:58.920
them, but only the places that
you actually need to.

00:44:58.920 --> 00:45:01.250
Just profile.

00:45:01.250 --> 00:45:02.550
GUSTAVO NIEMEYER: It's good as
well to have a good idea of

00:45:02.550 --> 00:45:09.780
what operations take the basic
timing of operations, right?

00:45:09.780 --> 00:45:13.800
Because after you learn that,
then you don't worry as much

00:45:13.800 --> 00:45:17.060
because you know what are the
obvious things that will take

00:45:17.060 --> 00:45:18.742
a long time.

00:45:18.742 --> 00:45:19.700
AUDIENCE: All right.

00:45:19.700 --> 00:45:20.500
Everything works as expected.

00:45:20.500 --> 00:45:20.795
Cool.

00:45:20.795 --> 00:45:22.045
Thanks.

00:45:24.370 --> 00:45:26.430
AUDIENCE: Having used and worked
with Go for a while,

00:45:26.430 --> 00:45:29.420
how do you feel about using it
in, like, offline desktop type

00:45:29.420 --> 00:45:30.670
applications?

00:45:33.630 --> 00:45:36.890
KEITH RARICK: So this is one
of the most fun recent

00:45:36.890 --> 00:45:39.580
projects that I've worked
on at Heroku.

00:45:39.580 --> 00:45:45.840
So we have a command line tool
called Heroku that has existed

00:45:45.840 --> 00:45:49.480
since the beginning of Heroku,
that we use, that all of our

00:45:49.480 --> 00:45:54.340
users use to interact with the
system, to create new apps and

00:45:54.340 --> 00:45:58.140
to change their environment
variables, and do all that

00:45:58.140 --> 00:45:59.390
sort of stuff.

00:46:03.040 --> 00:46:07.690
It's one of those projects that
it's been around for a

00:46:07.690 --> 00:46:11.670
long time, and it's quite a bit
of code, and for a long

00:46:11.670 --> 00:46:14.100
time, and so now it's
well maintained.

00:46:14.100 --> 00:46:16.520
It has a great maintainer who's
done a lot of good work,

00:46:16.520 --> 00:46:19.110
but for a long time it sort of
floated around without a clear

00:46:19.110 --> 00:46:21.830
owner, and it sort of a
accumulated a whole lot of

00:46:21.830 --> 00:46:25.000
code, and it got really
slow and bloated, and

00:46:25.000 --> 00:46:26.430
it wasn't very fun.

00:46:26.430 --> 00:46:30.760
And so one of the things that
another coworker did to sort

00:46:30.760 --> 00:46:36.700
of jumpstart, or at least
compete a little bit and

00:46:36.700 --> 00:46:39.550
motivate work on the official
command line tool is to make

00:46:39.550 --> 00:46:43.930
an alternative in Go
just for speed.

00:46:43.930 --> 00:46:48.620
So there's a tool out there, you
can find it on my GitHub,

00:46:48.620 --> 00:46:53.960
and it's called HK, and
it's very simple.

00:46:53.960 --> 00:46:56.670
It's very similar to the
existing Heroku tool, except

00:46:56.670 --> 00:46:57.910
it's written in Go.

00:46:57.910 --> 00:47:01.570
And there are a couple of other
nice things, too, like

00:47:01.570 --> 00:47:05.700
the fact that it's a single
binary means that the

00:47:05.700 --> 00:47:07.610
installation instructions
are simple.

00:47:07.610 --> 00:47:11.180
You just curl this file down and
stick it in the directory,

00:47:11.180 --> 00:47:12.510
and you've got it installed.

00:47:12.510 --> 00:47:15.380
There's no downloading all
these packages and

00:47:15.380 --> 00:47:17.180
dependencies and stuff
like that.

00:47:17.180 --> 00:47:20.950
And in fact, because it's just
a single binary, it took

00:47:20.950 --> 00:47:26.890
literally an evening for me to
write a self update feature,

00:47:26.890 --> 00:47:32.440
including a nice binary diff
so that the updates are a

00:47:32.440 --> 00:47:34.230
tenth of the size that they
would otherwise be.

00:47:34.230 --> 00:47:38.240
And so it can periodically check
to see if there's an

00:47:38.240 --> 00:47:41.220
update, and download the update,
and apply the patch,

00:47:41.220 --> 00:47:44.240
and ask you if you'd like to,
yes, do you want this update?

00:47:44.240 --> 00:47:50.590
And then it just renamed the
file over top, and it's great.

00:47:50.590 --> 00:47:52.780
ANDREW GERRAND: I think the
process you were describing is

00:47:52.780 --> 00:47:54.530
trolling driven development.

00:47:54.530 --> 00:47:55.610
KEITH RARICK: Yes, that's
what he called it.

00:47:55.610 --> 00:47:58.050
Trolling driven development.

00:47:58.050 --> 00:47:59.480
ANDREW GERRAND: Rewrite
the bad stuff in Go.

00:48:02.312 --> 00:48:05.280
Do any of you have any thoughts
on, like, GUI stuff,

00:48:05.280 --> 00:48:08.700
because I said desktop
applications.

00:48:08.700 --> 00:48:11.248
I guess none of you are really
working on them.

00:48:11.248 --> 00:48:14.531
EVAN SHAW: I think where Go is
really strong right now is in

00:48:14.531 --> 00:48:17.350
the server back-end area.

00:48:17.350 --> 00:48:20.006
I would really like to see
desktop graphical applications

00:48:20.006 --> 00:48:21.978
written to Go.

00:48:21.978 --> 00:48:28.387
But I think the library bindings
are still young and

00:48:28.387 --> 00:48:32.495
there's at least one effort to
write a graphical toolkit in

00:48:32.495 --> 00:48:35.289
Go itself, which is really
interesting.

00:48:35.289 --> 00:48:40.219
But that's young as well.

00:48:40.219 --> 00:48:45.149
And yeah, I recently saw
somebody was [INAUDIBLE].

00:48:48.610 --> 00:48:49.190
ANDREW GERRAND: There's
actually been

00:48:49.190 --> 00:48:50.330
more than one game.

00:48:50.330 --> 00:48:53.710
There's a few over the years.

00:48:53.710 --> 00:48:55.890
GUSTAVO NIEMEYER: I think
I agree with what you

00:48:55.890 --> 00:48:58.470
just said as well.

00:48:58.470 --> 00:49:03.200
I'm pretty excited about being
able to use a graphical

00:49:03.200 --> 00:49:04.550
toolkit in Go.

00:49:04.550 --> 00:49:08.880
I don't think the toolkits are
quite there yet, but the

00:49:08.880 --> 00:49:12.560
concepts that Go allows us to
use, they do make sense in a

00:49:12.560 --> 00:49:15.140
graphical application as well.

00:49:15.140 --> 00:49:20.060
So the concurrency aspects, the
way that you can handle

00:49:20.060 --> 00:49:23.420
information asynchronously while
waiting for data and

00:49:23.420 --> 00:49:24.380
channels and so on.

00:49:24.380 --> 00:49:27.330
this It's usable in graphical
applications as well.

00:49:29.900 --> 00:49:31.165
ANDREW GERRAND: Great, are there
any other questions?

00:49:35.200 --> 00:49:38.160
All right, well thanks everybody
for coming along.

00:49:38.160 --> 00:49:39.800
And thank you very much
to our guests.

00:49:39.800 --> 00:49:41.100
If we could give them a warm
round of applause.

