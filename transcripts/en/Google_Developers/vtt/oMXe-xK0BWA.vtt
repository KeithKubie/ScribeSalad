WEBVTT
Kind: captions
Language: en

00:00:00.459 --> 00:00:01.910
BRETT BAVAR: All right,
welcome everybody.

00:00:03.280 --> 00:00:05.850
Today's talk is "Building
Real-time Web Apps with App

00:00:05.850 --> 00:00:06.520
Engine and the Feed API".

00:00:07.160 --> 00:00:10.519
My name is Brett Bavar, and I'm
a software engineer on the

00:00:10.519 --> 00:00:12.339
Google Ajax API's team.

00:00:12.339 --> 00:00:14.529
MOISHE LETTVIN: And, I'm Moishe
Lettvin, and I'm a software

00:00:14.529 --> 00:00:18.539
engineer on the developer
platforms team.

00:00:18.539 --> 00:00:20.449
BRETT BAVAR: If you want to
view live notes or participate

00:00:20.449 --> 00:00:22.390
in the wave for this session,
you can go to this URL.

00:00:22.740 --> 00:00:24.500
I'm going to leave it up for a
second and read it off to you,

00:00:24.500 --> 00:00:25.679
because it's kind of crazy.

00:00:26.329 --> 00:00:26.699
[? Bit ?]

00:00:26.699 --> 00:00:27.189
[? lee ?]

00:00:27.189 --> 00:00:30.599
slash DC6 capital-Q
X capital-D.

00:00:31.400 --> 00:00:31.533
Or,

00:00:31.533 --> 00:00:34.230
if you've been doing waves, you
should be able to look through

00:00:34.230 --> 00:00:35.730
the official Google
IO wave list.

00:00:37.500 --> 00:00:40.250
You should find our session
amongst theirs with the wave

00:00:40.250 --> 00:00:43.739
button I believe on the
official Google IO web site

00:00:43.739 --> 00:00:45.949
for the information
on this session.

00:00:45.949 --> 00:00:51.590
You should be able to find the
wave button is there as well.

00:00:51.590 --> 00:00:54.380
All right, so before we get
started, I wanted to give you a

00:00:54.380 --> 00:00:56.620
little bit of context about
what we're talking about when

00:00:56.620 --> 00:01:00.040
we say the real time web.

00:01:00.040 --> 00:01:00.256
So, I'm

00:01:00.256 --> 00:01:03.800
sure all of you are familiar
with this site right

00:01:03.800 --> 00:01:04.180
here, Google.com.

00:01:06.880 --> 00:01:09.720
For a long time, Google.com
has made search results

00:01:09.720 --> 00:01:10.150
available to us.

00:01:10.150 --> 00:01:12.510
Say I wanted to search for
what people are saying

00:01:12.510 --> 00:01:13.390
about Google IO.

00:01:15.280 --> 00:01:17.860
You can see here, I get
some very good results.

00:01:17.860 --> 00:01:20.530
But, they don't change.

00:01:21.500 --> 00:01:24.009
When I'm viewing the page,
they just stay the same.

00:01:24.009 --> 00:01:26.259
I'd have to refresh if I
wanted to get new content.

00:01:26.259 --> 00:01:29.560
It's probably not even going to
change that frequently anyway.

00:01:29.560 --> 00:01:32.460
The one thing I can do now, as
you may know, -- there is a

00:01:32.460 --> 00:01:37.720
new version of this called
Google Real-time Search.

00:01:37.760 --> 00:01:39.420
I can see new things
that are coming in.

00:01:39.420 --> 00:01:42.609
You can see right here 24
seconds ago, something was said

00:01:42.609 --> 00:01:44.639
on Twitter about Google IO and
things are continuing

00:01:44.639 --> 00:01:46.150
to come in.

00:01:46.150 --> 00:01:49.490
This is one example of
the real time web.

00:01:49.490 --> 00:01:52.090
Things are coming in
constantly, content that

00:01:52.090 --> 00:01:53.170
users are interested in.

00:01:53.170 --> 00:01:56.049
And we want to make it
available to them as easy and

00:01:56.049 --> 00:01:59.230
fast as possible without
having to refresh the page.

00:01:59.230 --> 00:02:01.720
This is one example of
the real-time web.

00:02:01.720 --> 00:02:03.815
And lots of people are trying
to add this to their web

00:02:03.815 --> 00:02:05.180
apps and their web sites.

00:02:05.310 --> 00:02:07.660
But, it's not as easy to
do as you might think.

00:02:07.660 --> 00:02:10.720
So, we want to talk to you
about some new ways that you

00:02:10.720 --> 00:02:17.009
can add this kind of real-time
functionality to your web page.

00:02:17.459 --> 00:02:19.729
We're here to announce
and explain a couple

00:02:19.729 --> 00:02:22.539
new tools for this.

00:02:22.539 --> 00:02:25.859
First, the app engine channel
API which Moishe has built, and

00:02:25.859 --> 00:02:27.210
will introduce you to that.

00:02:27.210 --> 00:02:30.549
It allows you to push things
in real time in App Engine.

00:02:30.549 --> 00:02:33.980
And, second, I will talk to you
about Feed API Version 2 with

00:02:33.980 --> 00:02:38.369
the new functionality for
push updates on feeds.

00:02:38.369 --> 00:02:40.299
At this point I'll pass it
over to Moishe to explain

00:02:40.299 --> 00:02:42.020
the App Engine Channel API.

00:02:42.020 --> 00:02:43.789
MOISHE LETTVIN: Cool,
thanks, Brett.

00:02:44.039 --> 00:02:46.620
I have a brief agenda of what
I'm going to cover here.

00:02:48.119 --> 00:02:50.389
As a way of introducing this
API, I want to talk about how

00:02:50.389 --> 00:02:53.079
things are now, and a problem
that you may have run

00:02:53.079 --> 00:02:55.769
into with the way things
are now at App Engine.

00:02:55.769 --> 00:02:57.269
Then, I'll describe what
the Channel API does

00:02:57.269 --> 00:02:58.639
to solve that problem.

00:02:58.639 --> 00:02:59.989
I'll talk about how to use it.

00:02:59.989 --> 00:03:02.079
I'll show some code snippets,
and how it works under

00:03:02.079 --> 00:03:04.929
the covers briefly, some
implementation details.

00:03:04.929 --> 00:03:07.749
So, to get started, have
you all used App Engine?

00:03:07.749 --> 00:03:11.229
Do we have App Engine
developers in the room?

00:03:11.229 --> 00:03:11.589
Sweet!

00:03:11.589 --> 00:03:14.029
So, you know the
basic flow, right?

00:03:14.789 --> 00:03:17.612
App Engine is basically, you
write your app as a bunch

00:03:17.612 --> 00:03:18.569
of request handlers.

00:03:18.569 --> 00:03:23.550
So typical case, a user types
your apps address into the

00:03:23.550 --> 00:03:27.459
browser, they navigate to
your site, and you get

00:03:27.459 --> 00:03:29.539
a request in your app.

00:03:29.539 --> 00:03:32.560
Your app delivers a response
down to the browser.

00:03:32.560 --> 00:03:36.539
The browser renders your
client page and then

00:03:36.539 --> 00:03:37.379
that's kind of it.

00:03:38.179 --> 00:03:41.879
Your browser now has the bundle
of Javascript and HTML and

00:03:41.879 --> 00:03:43.419
whatever data you
delivered to it.

00:03:43.419 --> 00:03:45.809
And the user can
interact with that.

00:03:45.809 --> 00:03:49.629
The problem is, let's say you
are writing a chess game, just

00:03:49.629 --> 00:03:52.279
a simple two-player chess game,
and the other player

00:03:52.279 --> 00:03:53.090
makes a move.

00:03:53.090 --> 00:03:55.489
Some event happens to your app.

00:03:55.489 --> 00:03:58.369
Your app's state in
the clolud changes.

00:03:58.369 --> 00:04:00.879
How do you tell the
client that happen?

00:04:01.469 --> 00:04:02.590
Anybody?

00:04:02.590 --> 00:04:06.319
How do you tell the other
person in this chess game that

00:04:06.319 --> 00:04:10.059
somebody moved their rook
up, or moved a pawn, or

00:04:10.059 --> 00:04:12.429
captured their queen?

00:04:12.429 --> 00:04:13.579
You poll.

00:04:13.579 --> 00:04:14.569
Exactly.

00:04:14.569 --> 00:04:18.069
Exactly.

00:04:18.069 --> 00:04:19.049
And, this is a
pretty common case.

00:04:20.199 --> 00:04:22.669
There's this is really neat app
that someone wrote called

00:04:22.669 --> 00:04:25.620
SeeMyCode.com I don't know how
many of you guys do phone

00:04:25.620 --> 00:04:30.820
interviews, but a really common
challenge with phone interviews

00:04:30.820 --> 00:04:33.490
is you want to talk to somebody
over the phone and see if they

00:04:33.490 --> 00:04:35.289
actually write code before you
bring them on site to see

00:04:35.289 --> 00:04:37.789
if they can write
code even better.

00:04:37.789 --> 00:04:41.240
But, it's super-hard to
dictate code over the phone.

00:04:41.240 --> 00:04:44.270
When I did my phone screen for
Google, they asked me this

00:04:44.270 --> 00:04:47.039
complicated thing and I had a
note pad with like ten pages

00:04:47.039 --> 00:04:48.770
of code, and I was trying
to dictate this over my

00:04:48.770 --> 00:04:49.839
interviewer, and it sucked.

00:04:49.839 --> 00:04:53.039
So this guy wrote this
SeeMyCode.com web site,

00:04:53.039 --> 00:04:54.309
which is awesome.

00:04:54.309 --> 00:04:56.999
You go there and you basically
see as the other person

00:04:56.999 --> 00:04:58.610
types what they typed in.

00:04:58.610 --> 00:05:01.079
But he has to use
polling to do that.

00:05:01.079 --> 00:05:03.610
So thats an example of
something where you end up

00:05:03.610 --> 00:05:04.580
falling back to polling.

00:05:05.450 --> 00:05:08.280
If you want to write a group
chat on top of your app,

00:05:08.280 --> 00:05:09.459
you'd need to do polling.

00:05:09.459 --> 00:05:11.935
Basically, any time that
there's a person who you're

00:05:11.935 --> 00:05:14.990
interacting with on the other
side where there's basically

00:05:14.990 --> 00:05:19.289
there's no set time limit
where something happens.

00:05:19.289 --> 00:05:21.659
You don't have a good
way to be notified when

00:05:21.659 --> 00:05:22.770
something's changed.

00:05:22.770 --> 00:05:25.319
So you can use polling.

00:05:25.319 --> 00:05:27.959
As you're probably aware if
you've ever written anything

00:05:27.959 --> 00:05:29.680
with polling, polling sucks.

00:05:29.680 --> 00:05:31.380
And why does it suck?

00:05:31.380 --> 00:05:35.859
Here's typical flow; you set a
set interval call in your

00:05:35.859 --> 00:05:38.800
Javascript to ask your app up
on the server, did

00:05:38.800 --> 00:05:41.419
something happen?

00:05:41.419 --> 00:05:41.830
Nope.

00:05:41.830 --> 00:05:42.179
Did something happen?

00:05:42.179 --> 00:05:43.049
Nope.

00:05:43.049 --> 00:05:43.599
Something happen?

00:05:43.599 --> 00:05:45.199
Nope.

00:05:45.199 --> 00:05:48.259
Eventually something may
happen, but you're putting a

00:05:48.259 --> 00:05:51.459
lot of load on your service
for nothing, really.

00:05:51.459 --> 00:05:54.650
For something that may
or may not happen.

00:05:54.650 --> 00:05:59.180
So, the other thing that stinks
-- I actually just had to write

00:05:59.180 --> 00:06:01.879
a polling implementation for
the development app server for

00:06:01.879 --> 00:06:04.439
the channel API, so that we can
simulate this on your own

00:06:04.439 --> 00:06:06.159
machine without comment.

00:06:06.159 --> 00:06:09.300
So, you end having all these
cues of messages that are

00:06:09.300 --> 00:06:13.199
waiting to be delivered to
your app and then you've got

00:06:13.199 --> 00:06:16.040
delivery happening on the
Javascript and the client side.

00:06:16.040 --> 00:06:18.830
Its a big pain in the butt, and
everybody ends up writting that

00:06:18.830 --> 00:06:20.500
same basic code over
and over again.

00:06:20.830 --> 00:06:23.899
It should a solved problem.

00:06:23.999 --> 00:06:27.769
And, the other thing that about
polling, if you want any sort

00:06:27.769 --> 00:06:29.699
of reasonable latency you're
going drive your CPU and

00:06:29.699 --> 00:06:32.919
codings up or if you want to
pay any reasonable amount for

00:06:32.919 --> 00:06:36.409
CPU and quota usage, your
latency is going to go down to

00:06:36.409 --> 00:06:37.949
something that might be
unacceptable depending

00:06:37.949 --> 00:06:39.360
on your app.

00:06:39.360 --> 00:06:41.819
And what you don't see on this
graph, because it's not 3D, is,

00:06:41.819 --> 00:06:44.659
of course, this whole curve
gets pushed out a lot as you

00:06:44.659 --> 00:06:48.639
get more and more users.

00:06:48.639 --> 00:06:51.509
So, I have a solution for you.

00:06:51.509 --> 00:06:52.919
Same basic flow.

00:06:52.919 --> 00:06:55.529
The browser makes request
to your app engine app.

00:06:55.529 --> 00:06:59.529
Your app engine app delivers a
bundle of Javascript, HTML

00:06:59.529 --> 00:07:06.669
and data, but, bonus, your
Javascript app creates a

00:07:06.669 --> 00:07:10.080
long-standing comet connection
up to the app engine service.

00:07:10.080 --> 00:07:12.219
It's not actually
connected to your app.

00:07:12.219 --> 00:07:15.610
It's connected to a Google
server that's able to

00:07:15.610 --> 00:07:16.339
push data down to it.

00:07:16.339 --> 00:07:19.969
So, now, when something happens
in your app, your app can

00:07:19.969 --> 00:07:25.999
notify your client that
there's something new there.

00:07:25.999 --> 00:07:29.039
The API itself is much easier
than ginning up your own

00:07:29.039 --> 00:07:32.249
polling API where you've got to
deal with messages and so on.

00:07:32.249 --> 00:07:34.399
And, also it lets you just
step off this curve of

00:07:34.399 --> 00:07:36.479
latency to CPU you use.

00:07:37.819 --> 00:07:40.150
I don't have exact numbers for
this yet, the PM's are still

00:07:40.150 --> 00:07:43.589
figuring that out, but
it is cheaper, and

00:07:43.589 --> 00:07:45.919
significantly faster.

00:07:45.919 --> 00:07:49.589
So I'd like to show a demo
of this, and you guys are

00:07:49.589 --> 00:07:53.379
welcome to join me in this.

00:07:53.379 --> 00:07:56.145
I'll tell you the

00:07:56.145 --> 00:07:56.699
URL.

00:07:56.699 --> 00:08:02.479
So if you go to
IOTriviaQuiz.AppsBot.com

00:08:02.479 --> 00:08:04.679
Now, we'll set up the game.

00:08:04.679 --> 00:08:05.239
We've got some questions.

00:08:05.239 --> 00:08:09.069
You guys can shout out answers
to these and I'll answer these.

00:08:09.069 --> 00:08:12.430
The author of a webcomic
of Romance, Sarcasm,

00:08:12.430 --> 00:08:15.369
Math and Language?

00:08:15.369 --> 00:08:17.770
All right, Randall Munroe.

00:08:17.770 --> 00:08:21.239
And you see other
people are joining in.

00:08:21.239 --> 00:08:22.799
You can see there's an
activities stream at the bottom

00:08:22.799 --> 00:08:27.120
that's being updated as people
answer questions and there's no

00:08:27.120 --> 00:08:27.800
polling involving here.

00:08:27.800 --> 00:08:31.399
At least no polling that
you as a user of the API

00:08:31.399 --> 00:08:33.040
have to worry about.

00:08:33.040 --> 00:08:42.410
And, we can actually look at
the Chrome resources here, you

00:08:42.410 --> 00:08:43.660
can see that there's binds.

00:08:44.750 --> 00:08:47.820
This is the comet connection
that's happening, and there's

00:08:47.820 --> 00:08:51.180
posts that I'm making up to the
server when I make a response.

00:08:51.180 --> 00:08:54.540
But there's no-- if this was a
polling app, you'd actually see

00:08:54.540 --> 00:08:56.760
every second or every ten
seconds or whatever, another

00:08:56.760 --> 00:09:02.650
request going up and you
don't see that here.

00:09:02.650 --> 00:09:03.830
So, that's that.

00:09:03.830 --> 00:09:06.929
Now one thing to note with
this app, we are sharding.

00:09:06.929 --> 00:09:08.970
There's 10 users per games,
so if you don't see your

00:09:08.970 --> 00:09:09.949
name up here, that's why.

00:09:09.949 --> 00:09:15.970
You're in a game with
another set of nine users.

00:09:15.970 --> 00:09:19.850
So, let me tell you to
actually build that.

00:09:20.450 --> 00:09:30.940
So, you can see there in upper
right, there's little key and

00:09:30.940 --> 00:09:32.420
basically I'll highlight
whether I'm talking about

00:09:32.420 --> 00:09:34.800
server code or client code
as I talk through this.

00:09:34.800 --> 00:09:36.570
It should be pretty obvious
because its Python on the

00:09:36.570 --> 00:09:40.120
server side and Javascript
on the client's side.

00:09:40.120 --> 00:09:44.570
So, to start with when you get
a request in your app, you'll

00:09:44.570 --> 00:09:48.110
have a get-handler for your
index page or whatever and

00:09:48.110 --> 00:09:50.570
there's basically two
calls you need to make.

00:09:50.570 --> 00:09:53.220
The first is, you create a
channel, and you can see

00:09:53.220 --> 00:09:56.680
that you specify a key to
identify that channel.

00:09:56.680 --> 00:10:01.090
That's up to your application
to provide and it can

00:10:01.090 --> 00:10:01.920
be whatever you want.

00:10:01.920 --> 00:10:05.210
What I usually use is get
current users user ID.

00:10:05.210 --> 00:10:08.250
Basically one client per user,
but you could use database

00:10:08.250 --> 00:10:11.310
key or whatever you choose.

00:10:11.310 --> 00:10:14.040
And you're given back an ID
which is a token that the

00:10:14.040 --> 00:10:16.210
client uses to connect
to that channel.

00:10:16.210 --> 00:10:20.130
So the next line you can see
here; we inject that token

00:10:20.130 --> 00:10:24.460
into a template, write
that as the response.

00:10:24.460 --> 00:10:28.399
Now on the client's side,
similarly, this is a template,

00:10:28.399 --> 00:10:30.940
so we're getting that channel
ID that was injected

00:10:30.940 --> 00:10:32.990
in previously.

00:10:32.990 --> 00:10:36.510
We use that channel ID to
create a new channel.

00:10:36.510 --> 00:10:40.040
Then we open a socket on that
channel, and set a call back

00:10:40.040 --> 00:10:42.630
handler for when an event
happens on that channel.

00:10:42.630 --> 00:10:43.820
So, very straightforward.

00:10:43.820 --> 00:10:45.560
And that really is all
there is to the API.

00:10:46.260 --> 00:10:51.310
There's a few other event
handlers and the like.

00:10:51.310 --> 00:10:54.810
But in essence, you create a
channel, you passed the token

00:10:54.810 --> 00:10:57.149
down to the client, you open
that channel on the client,

00:10:57.149 --> 00:11:02.750
and you set callback handlers
for when things happen.

00:11:04.980 --> 00:11:06.930
And, then, of course, now
you've got this channel

00:11:06.930 --> 00:11:08.280
open on the client's side.

00:11:08.280 --> 00:11:09.230
Something else happens.

00:11:09.230 --> 00:11:13.529
You've got your other page;
you're make move or your answer

00:11:13.529 --> 00:11:17.050
questions page or what have
you, and you send a message to

00:11:17.050 --> 00:11:21.020
that channel with the key that
you used above to create it.

00:11:21.020 --> 00:11:24.200
Not the ID that is handed back
but the key that you used,

00:11:24.200 --> 00:11:25.910
and then a string message.

00:11:25.910 --> 00:11:30.169
This is typically like a JSON
encoded object that you decode

00:11:30.169 --> 00:11:32.140
in javascript or whatever.

00:11:32.140 --> 00:11:33.020
But it's just a string.

00:11:33.020 --> 00:11:35.580
Whatever you want to
put in there, you can.

00:11:35.580 --> 00:11:38.840
And then, when you do that, the
callback handler is called

00:11:38.840 --> 00:11:40.620
on the client's side.

00:11:40.620 --> 00:11:43.350
And, in this case, we alert,
but you'd update your UI as

00:11:43.350 --> 00:11:47.220
appropriate based on that.

00:11:47.220 --> 00:11:51.080
Some quick details, the
Python implementation

00:11:51.080 --> 00:11:52.310
again is just two methods.

00:11:52.310 --> 00:11:54.930
Create a channel, send a
message to that channel.

00:11:54.930 --> 00:11:57.400
Java implementation
is the same.

00:11:57.400 --> 00:11:58.560
Some tactics differences.

00:11:58.560 --> 00:12:02.500
You pass a channel message
object in for Java instead of

00:12:02.500 --> 00:12:06.470
just two parameters, but its
effectively the same thing.

00:12:06.470 --> 00:12:08.810
A couple more details on
the javascript side.

00:12:08.810 --> 00:12:12.050
You include this is underscore
AH channel JS API.

00:12:12.860 --> 00:12:19.200
Underscore AH is like the App
Engine kind of internal stuff,

00:12:19.200 --> 00:12:21.760
so we have this JS API
depending on whether you are

00:12:21.760 --> 00:12:24.510
running on the development apps
server or on production,

00:12:24.510 --> 00:12:25.193
this will return

00:12:25.193 --> 00:12:26.380
you a different bundle
of Javascript.

00:12:26.650 --> 00:12:29.390
So we basically do a
redirect in production.

00:12:29.390 --> 00:12:33.210
On the develop app server,
it's our clunky pulling

00:12:33.210 --> 00:12:34.560
implementation, but it, at
least, lets you try it

00:12:34.560 --> 00:12:37.890
out before pushing it.

00:12:37.890 --> 00:12:41.029
And, this socket, you may
notice, instead of just opening

00:12:41.029 --> 00:12:43.330
the channel, we open a
socket on the channel.

00:12:43.390 --> 00:12:47.400
The reason for that is, we want
to maintain compatibility kind

00:12:47.400 --> 00:12:52.960
of moving forward with
the web socket API.

00:12:52.960 --> 00:12:55.690
So, the object you get back
from channel.open is a normal

00:12:55.690 --> 00:12:58.520
Javascript object but it
mirrors this functionality.

00:12:58.520 --> 00:13:00.670
It has all these methods on it.

00:13:00.670 --> 00:13:03.635
It will set the ready state,
buffered amount, it doesn't

00:13:03.635 --> 00:13:06.400
use, because its not relevant
here, but the idea is that in

00:13:06.400 --> 00:13:09.470
the future if we can support
web sockets for this

00:13:09.470 --> 00:13:10.660
channel API, we will.

00:13:10.660 --> 00:13:12.850
It'll be a transparent
switch for people who

00:13:12.850 --> 00:13:17.470
are using this API.

00:13:17.470 --> 00:13:20.400
Couple more implication
details here.

00:13:20.400 --> 00:13:22.910
Before, I' just had this big
generic block for App Engine.

00:13:23.860 --> 00:13:26.320
The way this actually works is
that App Engine will actually

00:13:26.320 --> 00:13:30.060
talk to the Google Talk XMPP
layer, so we're using -- I

00:13:30.060 --> 00:13:31.610
don't know if you guys are
familiar with the XMPP API for

00:13:31.610 --> 00:13:36.030
App Engine already -- We've
basically built this on top of

00:13:36.030 --> 00:13:40.010
that, so we can use our
existing stack, this very

00:13:40.010 --> 00:13:45.010
scalable stack to deliver XMPP
messages, for this stuff, so

00:13:45.010 --> 00:13:48.580
basically it's routed through
the whole stack to get

00:13:48.580 --> 00:13:52.300
messages down to your app.

00:13:52.300 --> 00:13:55.980
And, on the the client side,
since we're connecting to talk

00:13:55.980 --> 00:13:59.030
front-ends to get these
messages, rather than a server

00:13:59.030 --> 00:14:02.740
on your domain we've created an
invisible i-frame that actually

00:14:02.740 --> 00:14:05.650
handles the long pull, the
comet connection, up to a

00:14:05.650 --> 00:14:07.750
Google server and then
communicate from that

00:14:07.750 --> 00:14:09.350
i-frame using closure XPC.

00:14:09.350 --> 00:14:12.110
I don't know if you guys are
familiar with this, but it's a

00:14:12.110 --> 00:14:16.370
way to do communication between
frames on different domains

00:14:16.370 --> 00:14:19.129
inside a browser, and it'll
basically use whatever the most

00:14:19.129 --> 00:14:22.550
efficient method is for the
browser that's hosting it.

00:14:22.550 --> 00:14:25.380
So the flow is, you get
a message down from

00:14:25.380 --> 00:14:27.610
the top front.

00:14:27.610 --> 00:14:31.100
It's been translated into an
XPC call out to your frame,

00:14:31.100 --> 00:14:34.740
and your callback is called.

00:14:36.060 --> 00:14:39.980
So, the status of this is it's
coming soon to trusted testers.

00:14:41.690 --> 00:14:43.000
Probably early next week.

00:14:43.490 --> 00:14:46.380
On the wave, I'll add link for
you to sign up, if you are

00:14:46.380 --> 00:14:48.420
interesed in being a trusted
testor for this, and we're

00:14:48.420 --> 00:14:51.160
shipping very soon.

00:14:51.160 --> 00:14:54.830
And, with that, I'll
hand it off to Brett.

00:14:54.830 --> 00:14:57.250
BRETT BAVAR: Thank you, Moishe.

00:15:02.970 --> 00:15:04.800
All right, I'm very
excited about that API.

00:15:04.800 --> 00:15:06.080
Thank you, Moishe.

00:15:06.370 --> 00:15:08.230
Hopefully, you see the
usefulness of this.

00:15:08.230 --> 00:15:10.660
Particularly if you're working
an App engine and you want to

00:15:10.660 --> 00:15:12.570
control both ends of a
real-time stream of

00:15:12.570 --> 00:15:14.450
data in your app.

00:15:14.450 --> 00:15:16.310
But there's also a lot
of data out there.

00:15:16.310 --> 00:15:19.630
Real time streams that exist
that you don't control.

00:15:19.630 --> 00:15:22.030
And what can you do to can
harness the power of that

00:15:22.030 --> 00:15:23.720
in your own web apps?

00:15:23.720 --> 00:15:25.720
Well I'd like to give
you one solution.

00:15:25.720 --> 00:15:30.270
And that is version 2 of the
Feed API with Push Updates.

00:15:30.270 --> 00:15:33.280
To give you a little agenda of
what I'm going to talk about,

00:15:33.280 --> 00:15:36.430
first I'm going to introduce
the difference between Feed API

00:15:36.430 --> 00:15:39.480
Version 1 which you may be
familiar with, and Feed API

00:15:39.480 --> 00:15:42.940
Version 2 focusing on the
difference between simply

00:15:42.940 --> 00:15:45.520
loading the contents of the
feed and subscribing

00:15:45.520 --> 00:15:48.000
to update on a feed.

00:15:48.000 --> 00:15:49.980
Then, I'm going to get into a
little more detail of how

00:15:49.980 --> 00:15:54.080
exactly you load the contents
of a feed in Feed API v1, so

00:15:54.080 --> 00:15:57.750
that we can then see how simple
it is to migrate from the

00:15:57.750 --> 00:16:01.490
subscribing to the contents
of the feed on version 2.

00:16:01.490 --> 00:16:04.000
Then, we'll talk a little bit
about implementation details.

00:16:04.000 --> 00:16:05.160
What's happening
under the hood?

00:16:05.160 --> 00:16:07.000
How are updates actually
getting to the browser?

00:16:07.000 --> 00:16:08.960
Which is quite similar to
some things that Moishe

00:16:08.960 --> 00:16:10.470
just showed you.

00:16:10.470 --> 00:16:12.850
And, finally, I'll show you a
few the advanced uses of the

00:16:12.850 --> 00:16:15.179
feed API and some of the
function calls and things that

00:16:15.179 --> 00:16:17.800
are available to you if you
want to do more than

00:16:17.800 --> 00:16:21.760
simply subscribing.

00:16:21.760 --> 00:16:24.960
So, the differences in Feed API
Version 1 and Version 2 as I

00:16:24.960 --> 00:16:27.060
briefly mentioned before is
the difference between the

00:16:27.060 --> 00:16:28.850
loading and subscribing.

00:16:28.850 --> 00:16:32.449
In the first case, in Feed API
Version 1 the Feed API makes it

00:16:32.449 --> 00:16:35.360
very easy for you to load the
contents of the feed in a

00:16:35.360 --> 00:16:37.730
format that's easy to consume
in the browser which I'll talk

00:16:37.730 --> 00:16:40.120
about a little bit more later.

00:16:40.120 --> 00:16:42.680
It sends it to the browser in
JSON so that it will be used

00:16:42.680 --> 00:16:43.810
in Javascript natively.

00:16:44.880 --> 00:16:47.400
However, it only loads what the
current contents of the feed

00:16:47.400 --> 00:16:50.730
are, and in order to continue
to get updates on that feed,

00:16:50.730 --> 00:16:52.769
you have to do polling like
Moishe was talking

00:16:52.769 --> 00:16:54.200
about earlier.

00:16:54.200 --> 00:16:57.650
In Feed API2 instead,
you subscribe to the

00:16:57.650 --> 00:16:58.820
updates on the feeds.

00:16:58.820 --> 00:17:01.660
And for any feed that is
pubsubhubbub enabled, you'll be

00:17:01.660 --> 00:17:04.189
given the updates of that feed
within seconds of them

00:17:04.189 --> 00:17:08.350
being published.

00:17:08.350 --> 00:17:10.450
So, lets talk a little bit
about what loading in Feed API

00:17:10.450 --> 00:17:12.800
version 1 looks like, so that
we have a little

00:17:12.800 --> 00:17:14.560
bit of context.

00:17:14.560 --> 00:17:17.619
Here's a simple example
of code using version

00:17:17.619 --> 00:17:18.209
1 of the Feed API.

00:17:19.040 --> 00:17:21.970
I'll walk you through what
exactly it is doing to load

00:17:21.970 --> 00:17:24.290
contents onto the page.

00:17:24.290 --> 00:17:26.640
The first thing that happens
is we simply load the API.

00:17:26.990 --> 00:17:28.430
This is the Google common
Javascript loader.

00:17:29.749 --> 00:17:33.370
We load the module called Feeds
and we load version 1 of it.

00:17:33.370 --> 00:17:37.070
We then set an on-load callback
because the API's going to be

00:17:37.070 --> 00:17:38.500
loaded asynchronously via JSON.

00:17:39.590 --> 00:17:42.750
And we can't be sure that we
can use the API if we simply

00:17:42.750 --> 00:17:45.210
run some code using the API
immediately after that.

00:17:45.210 --> 00:17:48.320
So, instead, we define a call
back, which I'll show you in a

00:17:48.320 --> 00:17:50.919
second, which is going to use
the Feed API code when we know

00:17:50.919 --> 00:17:55.090
that it's available because
the load is completed.

00:17:55.090 --> 00:17:57.820
So, in that call back function,
we use the feed API,

00:17:57.820 --> 00:17:58.750
and it's very simple.

00:17:58.750 --> 00:18:00.370
We create an object of
type Google.feeds.feed.

00:18:02.150 --> 00:18:04.960
We pass it, in this case, the
URL of the official Google

00:18:04.960 --> 00:18:07.570
blog, which we want
to use on our page.

00:18:07.570 --> 00:18:11.170
And then we call feed.load with
another call back function.

00:18:11.170 --> 00:18:14.039
In this case, to do something
with feed contents.

00:18:14.039 --> 00:18:17.450
This call back function is
going to be called one time

00:18:17.450 --> 00:18:19.960
after the fetch of the feed
contents is complete.

00:18:19.960 --> 00:18:22.650
So, the feed contents are
fetched asnycronously and

00:18:22.650 --> 00:18:27.350
passed into this call back
which is defined below.

00:18:27.350 --> 00:18:29.050
So that result object is
going to contain the

00:18:29.050 --> 00:18:30.549
contents of the feed.

00:18:30.549 --> 00:18:34.320
But before I implement this for
you, I want to talk a little

00:18:34.320 --> 00:18:38.300
bit about what this result
format looks like.

00:18:38.300 --> 00:18:41.350
So you may be familiar with
what feeds look like typically.

00:18:41.739 --> 00:18:43.659
They're normally done
in XML, either RSS or

00:18:43.659 --> 00:18:44.470
Atom forms of that.

00:18:44.919 --> 00:18:46.970
This is a simple RSS Feed.

00:18:46.970 --> 00:18:50.110
You can see that the title and
link and description of the

00:18:50.110 --> 00:18:53.340
feed are represented here
under the channel tag.

00:18:53.340 --> 00:18:55.250
Then there are multiple
items which represent

00:18:55.250 --> 00:18:56.150
the entries in the feed.

00:18:56.150 --> 00:18:59.740
Each of them also have their
own title link and description.

00:19:00.740 --> 00:19:04.600
This is basically what
an RSS feed looks like.

00:19:04.600 --> 00:19:05.870
Now, the unfortunate thing
about this, if you working

00:19:05.870 --> 00:19:08.709
on a web app, this
XML is heavyweight.

00:19:08.979 --> 00:19:10.339
It's complicated to parse.

00:19:10.339 --> 00:19:12.970
You really don't want to deal
with this in your web app.

00:19:13.180 --> 00:19:16.700
So, what we do in the Feed API,
is we map this in almost a

00:19:16.700 --> 00:19:19.830
one-to-one mapping to a JSON
representation, which is

00:19:19.830 --> 00:19:20.750
easy to use in Javascript.

00:19:21.280 --> 00:19:23.919
As you can see, if I flip back
and forth between these, the

00:19:23.919 --> 00:19:25.980
mapping is pretty
straight forward between

00:19:25.980 --> 00:19:27.620
the two formats.

00:19:27.620 --> 00:19:29.990
Now, JSON, on the the other
hand, if you're familiar with

00:19:29.990 --> 00:19:33.060
it, makes it very easy for you
to just use the object as a

00:19:33.060 --> 00:19:38.460
native object on Javascript, so
we can look for member feed,

00:19:38.460 --> 00:19:40.290
member title, underneath that
and get the title of

00:19:40.290 --> 00:19:43.180
the feed and so on.

00:19:43.180 --> 00:19:46.460
So given that, I can implement
the call back function here.

00:19:46.529 --> 00:19:49.700
You can see I have a very
simple four loop here that

00:19:49.700 --> 00:19:53.970
simply iterates through the
entries and it's alerts a

00:19:53.970 --> 00:19:56.650
dialog box, telling me what the
title of the each entry is.

00:19:56.650 --> 00:19:59.100
Very simple, not very useful,
but you can do some pretty

00:19:59.100 --> 00:20:01.110
powerful stuff with
this [? Jason ?]

00:20:01.110 --> 00:20:04.910
result format in this
callback function.

00:20:04.910 --> 00:20:08.017
So let's look at a demo that
its built with this API.

00:20:14.770 --> 00:20:16.550
Here's a page which is
aggregating a couple of

00:20:16.550 --> 00:20:19.500
my feeds; a word press
blog and my buzz feed.

00:20:19.860 --> 00:20:22.190
You can see that I'm collating
the two together in the

00:20:22.190 --> 00:20:23.660
order they were posted.

00:20:23.660 --> 00:20:27.130
It's got a bunch of things that
I've posted on to these feeds.

00:20:27.130 --> 00:20:28.630
So what does the code
for this look like?

00:20:33.160 --> 00:20:35.400
The code starts here.

00:20:35.400 --> 00:20:37.660
As you can see, I'm doing some
of the same things that I

00:20:37.660 --> 00:20:38.850
did in the sample earlier.

00:20:38.850 --> 00:20:41.980
I'm loading Feeds Version
1, setting an on-load call

00:20:41.980 --> 00:20:42.970
back, this time called
"in it".

00:20:42.970 --> 00:20:43.990
It.

00:20:43.990 --> 00:20:46.520
In the in it function
then, I'm declaring two

00:20:46.520 --> 00:20:47.540
different objects of type
Google.Google.feeds.feed.

00:20:48.679 --> 00:20:52.310
One of which is my buzz feed,
another which is the word

00:20:52.310 --> 00:20:56.060
press feed, here with
this wordpress URL.

00:20:56.060 --> 00:20:58.420
I'm also using a function I
didn't introduce here which is

00:20:58.420 --> 00:21:00.455
simply setting the number of
entries I'm interested in

00:21:00.455 --> 00:21:01.460
loading on each feed.

00:21:01.460 --> 00:21:04.210
And I'm just setting that right
now to max entries which is the

00:21:04.210 --> 00:21:06.520
max entries I want to
display on the page.

00:21:06.520 --> 00:21:08.690
So I want to display
12 items on the page.

00:21:08.690 --> 00:21:11.100
I'm going to load 12 from each
feed and then collate them and

00:21:11.100 --> 00:21:11.870
get rid of the extra ones.

00:21:14.429 --> 00:21:16.350
Then I called dot load
on each of these with

00:21:16.350 --> 00:21:17.779
a separate call back.

00:21:17.779 --> 00:21:20.309
One defined from buzz
updates, one defined

00:21:20.309 --> 00:21:21.899
from word press updates.

00:21:22.450 --> 00:21:26.369
In each case, I simply add
an entry to the page with

00:21:26.369 --> 00:21:28.770
a difference CSS class.

00:21:28.830 --> 00:21:31.615
In this case buzz update is the
CSS class and the other word a

00:21:31.615 --> 00:21:34.329
press update is the CSS
class, and that allows me to

00:21:34.329 --> 00:21:35.059
add the custom styling.

00:21:35.059 --> 00:21:37.779
As you can see here; the word
press logo for word press

00:21:37.779 --> 00:21:39.440
updates, the buzz logo
for buzz updates.

00:21:42.390 --> 00:21:45.210
Then I have some code here that
we don't need to go into detail

00:21:45.210 --> 00:21:48.540
of that's simply is creating
the divs to put onto the page.

00:21:49.330 --> 00:21:52.146
Collating them by published
date and getting rid of some of

00:21:52.146 --> 00:21:54.710
the extra ones at the end since
we're loading twice as many

00:21:54.710 --> 00:21:58.810
as we actually want to
display in the beginning.

00:21:58.810 --> 00:22:00.220
And that's really
all there is to it.

00:22:00.390 --> 00:22:02.309
There's also some CSS
and so on that's doing

00:22:02.309 --> 00:22:03.270
styling on the page.

00:22:09.520 --> 00:22:10.440
So, that's cool.

00:22:11.029 --> 00:22:14.930
What if I wanted to get the
updates from the feeds in real

00:22:14.930 --> 00:22:18.379
time so that my users could see
them come in without having to

00:22:18.379 --> 00:22:21.850
refresh their page
within seconds?

00:22:21.850 --> 00:22:24.760
Well as Moishe talked about,
one thing that we could try,

00:22:24.760 --> 00:22:27.240
the old state of the
art, is polling.

00:22:27.680 --> 00:22:29.970
But there's not only the
reasons that Moishe talked

00:22:29.970 --> 00:22:33.890
about that all apply this case
as well, there's also a couple

00:22:33.890 --> 00:22:35.690
of things that we need to
consider specifically

00:22:35.690 --> 00:22:36.610
in this case.

00:22:36.870 --> 00:22:40.679
For one, we have multiple
levels of cache which prevent

00:22:40.679 --> 00:22:42.970
updates from showing
up very quickly.

00:22:42.970 --> 00:22:46.830
The Feed API gets lots and lots
of traffic which was mentioned

00:22:46.830 --> 00:22:48.380
earlier in a talk this week.

00:22:49.559 --> 00:22:52.820
We have to have some
caching to handle that.

00:22:53.140 --> 00:22:55.370
There could be anywhere up to
a few minutes of lag caused

00:22:55.370 --> 00:22:59.640
by the caches holding onto
updates of the popular feeds.

00:22:59.860 --> 00:23:02.390
In addition to that, if you
pull too much, your traffic may

00:23:02.390 --> 00:23:04.820
look abusive because you're
hitting that same thing over

00:23:04.820 --> 00:23:06.620
and over and over again,
and you may get either

00:23:06.620 --> 00:23:10.110
throttled or blocked.

00:23:10.110 --> 00:23:12.130
Also if you pull to little,
you might as well just not,

00:23:12.130 --> 00:23:17.980
because you're not getting
things quickly anyway.

00:23:17.980 --> 00:23:19.610
So, here's the example
I showed you earlier.

00:23:20.050 --> 00:23:22.750
I'm proud to introduce very
simple changes that you can

00:23:22.750 --> 00:23:26.150
make to this to use the Feed
API version 2, and subscribed

00:23:26.150 --> 00:23:29.360
updates in the browser
without polling.

00:23:29.520 --> 00:23:31.360
Here's all that I
have to change.

00:23:31.360 --> 00:23:35.289
You see here between Feed
API Version 1 and Feed API

00:23:35.289 --> 00:23:38.150
Version 2, in order to
subscribe to my feeds.

00:23:38.150 --> 00:23:40.120
As you can see, there's
only three simple changes.

00:23:40.120 --> 00:23:46.810
First I load Version 2 of the
Feed API, then I create an

00:23:46.810 --> 00:23:50.410
object of type feed under the
push named space which is the

00:23:50.410 --> 00:23:52.410
type of feed that actually
supports the push up

00:23:52.410 --> 00:23:54.210
dates we're going to do.

00:23:54.270 --> 00:23:56.560
The reason we have a separate
named space for this is simply

00:23:56.560 --> 00:24:00.090
so that we can also support the
old loading cases and Version

00:24:00.090 --> 00:24:03.930
2, just in case you still want
to do those kinds of things.

00:24:03.930 --> 00:24:06.000
And then I use the dot
subscribe function which is on

00:24:06.000 --> 00:24:09.990
the push type feeds, which
takes the same kind

00:24:09.990 --> 00:24:10.909
of call back.

00:24:10.909 --> 00:24:13.080
But now the call back is going
to be called any time there's

00:24:13.080 --> 00:24:16.590
new updates on the feeds
instead of just once.

00:24:16.590 --> 00:24:19.340
You can see here, I'll point
out that this call back

00:24:19.340 --> 00:24:20.960
actually hasn't changed at all.

00:24:21.390 --> 00:24:23.690
Currently the result format
of these is exactly the

00:24:23.690 --> 00:24:24.440
same as Feed API Version 1.

00:24:25.780 --> 00:24:29.490
This will probably change with
time, but I believe that we

00:24:29.490 --> 00:24:33.990
would like to keep at least the
resolve format, consistent

00:24:33.990 --> 00:24:37.850
between loading and subscribing
in Version 2, and so that it's

00:24:37.850 --> 00:24:40.710
very easy to work between two.

00:24:40.710 --> 00:24:43.380
So, if you actually wanted to
take some code that you've had

00:24:43.380 --> 00:24:46.610
that does this already in Feed
API Version 1, your call back

00:24:46.610 --> 00:24:48.400
doesn't need to change at all.

00:24:48.400 --> 00:24:50.460
Although in practical
applications you're probably

00:24:50.460 --> 00:24:52.800
going to want to do something
different, because it's no

00:24:52.800 --> 00:24:54.530
longer going to just be called
once, its going to be

00:24:54.530 --> 00:24:55.779
called multiple time.

00:24:55.839 --> 00:24:59.129
You want some items to expire
and not continue to add things

00:24:59.129 --> 00:25:01.099
to page, and just make
it growing indefinitely

00:25:01.099 --> 00:25:03.809
and kill your browser.

00:25:03.809 --> 00:25:06.059
You also may want to add some
cool animation or something

00:25:06.059 --> 00:25:09.450
and things pop in.

00:25:09.450 --> 00:25:13.289
Let's look at this same demo
that I showed you before, but

00:25:13.289 --> 00:25:16.290
slightly modified in ways that
showed you in order to

00:25:16.290 --> 00:25:19.480
enable push up dates.

00:25:19.480 --> 00:25:22.280
I am going to bring up the
dashboard of my word press

00:25:22.280 --> 00:25:26.125
blog and I'm going
to add a new post.

00:25:33.900 --> 00:25:38.056
All right, let me resize
this, so we can see a little

00:25:38.056 --> 00:25:41.690
better what's going on.

00:25:41.690 --> 00:25:44.030
I'm going publish
this to word press.

00:25:44.120 --> 00:25:46.140
You can see word press is
working on that a little

00:25:46.140 --> 00:25:48.550
bit, and there it is.

00:25:48.550 --> 00:25:50.900
Popped into my page without
doing any sort of refresh

00:25:50.900 --> 00:25:54.110
in just a matter of
a couple seconds.

00:25:54.110 --> 00:25:55.820
I'll explain to you in a
second what actually went

00:25:55.820 --> 00:25:58.299
on behind the scenes.

00:25:58.299 --> 00:26:00.109
I can do the same
thing with buzz.

00:26:07.940 --> 00:26:13.800
And we should see this pop
also in just a few seconds.

00:26:13.800 --> 00:26:13.960
There it is.

00:26:13.960 --> 00:26:15.299
So, what's different?

00:26:20.610 --> 00:26:22.620
This looks very much like the
demo code I showed you before.

00:26:23.530 --> 00:26:25.679
All that's different here, as
I said before, we changed

00:26:25.679 --> 00:26:26.340
this to Version 2.

00:26:27.570 --> 00:26:29.910
We have the same
on-load call back.

00:26:29.910 --> 00:26:32.870
Now we're using dot
push, dot feed.

00:26:34.010 --> 00:26:38.070
We're also using dot subscribe
in the same way I explained.

00:26:38.070 --> 00:26:39.820
I'll also introduce this
a little bit later.

00:26:39.820 --> 00:26:41.409
This includes historical
entries function.

00:26:41.929 --> 00:26:44.609
This allows me to load some
historical content, so the

00:26:44.609 --> 00:26:47.590
page doesn't start being
blank at the beginning.

00:26:47.590 --> 00:26:50.109
Everything else after that
is actually identical code.

00:26:50.679 --> 00:26:53.530
In both cases, I was loading
more than I needed at the the

00:26:53.530 --> 00:26:55.940
beginning and discarded
extra entries.

00:26:55.940 --> 00:26:58.044
In this case, as entries
continue to come in all, I'll

00:26:58.044 --> 00:26:59.899
continue to throw out the
entries that are off

00:26:59.899 --> 00:27:10.460
the end of the list.

00:27:10.460 --> 00:27:12.520
OK, so how does this work?

00:27:12.520 --> 00:27:15.170
In order to explain that, I
need to first introduce you to

00:27:15.170 --> 00:27:15.730
something called pubsubhubbub.

00:27:19.760 --> 00:27:24.540
You may seen Brett Slakins talk
on this earlier this week.

00:27:24.540 --> 00:27:25.630
If not, I recommend it.

00:27:25.630 --> 00:27:26.810
It was very good.

00:27:26.810 --> 00:27:30.289
And it will be on YouTube
hopefully very soon.

00:27:30.289 --> 00:27:33.490
You can also the
code.google.com/p/pubsubhubbub

00:27:33.490 --> 00:27:36.160
to get some details on this.

00:27:36.160 --> 00:27:39.460
Pubsubhubbub was a protocol
that was invented by couple of

00:27:39.460 --> 00:27:43.760
engineers including Brett
Slatkin, himself at Google, and

00:27:43.760 --> 00:27:46.470
some other people they
cooperated with, for the

00:27:46.470 --> 00:27:51.710
sake of turning feeds into
streaming content streams.

00:27:51.710 --> 00:27:54.270
And the way this happens
is using a pubsub model

00:27:54.270 --> 00:27:56.390
with a hub in between.

00:27:56.390 --> 00:27:58.400
So, I'm going to brush
over this very quickly.

00:27:58.400 --> 00:28:00.540
You should get the details
elsewhere, because this is a

00:28:00.540 --> 00:28:02.475
little bit beyond the scope of
my talk, but I just want to

00:28:02.475 --> 00:28:04.710
introduce it very briefly.

00:28:04.710 --> 00:28:07.980
So the whole protocol
uses HTTP posts.

00:28:08.169 --> 00:28:10.799
The subscribers are going to
post their interest on a

00:28:10.799 --> 00:28:13.500
particular feed to the hub.

00:28:15.290 --> 00:28:20.159
They know which hub the feed
uses by reading it out of the

00:28:20.159 --> 00:28:22.760
feed, which I'll show
you very shortly.

00:28:22.760 --> 00:28:24.460
They tell the hub, I'm
interested in this.

00:28:24.460 --> 00:28:29.980
Please post all updates to
x-URL, then whenever the

00:28:29.980 --> 00:28:33.250
publisher publishes update on
that feed, it tells the hub

00:28:33.250 --> 00:28:34.950
there's new content
on this feed.

00:28:34.950 --> 00:28:38.840
The hub fetches that new
content and pushes it through

00:28:38.840 --> 00:28:41.330
an HTP post to all of
the URLs that have been

00:28:41.330 --> 00:28:45.090
registered to that feed.

00:28:45.090 --> 00:28:47.060
So there's a lot of content
out there that's all ready

00:28:47.060 --> 00:28:50.210
pubsubhubbub enabled and you
may wonder how you can know

00:28:50.210 --> 00:28:54.030
which of those do this already.

00:28:54.430 --> 00:28:57.539
One thing very simply is this
the same feed I showed you

00:28:57.539 --> 00:29:01.059
before, and if you were to open
up this feed, and you saw

00:29:01.059 --> 00:29:03.900
something like this; link
rel="hub", with some

00:29:03.900 --> 00:29:08.700
URL of a hub, you could know
that this feed should be

00:29:08.700 --> 00:29:09.090
pubsubhubbub enabled.

00:29:09.220 --> 00:29:13.549
And you should be able to go
to that and subscribe on it.

00:29:13.940 --> 00:29:15.870
Using the Feed API, however,
you don't need to worry

00:29:15.870 --> 00:29:16.580
about those details.

00:29:16.580 --> 00:29:18.110
You can just know that
this will work with

00:29:18.110 --> 00:29:20.670
Feed API Version 2.

00:29:20.670 --> 00:29:23.730
Some things that actually come
out of the box right now with

00:29:23.730 --> 00:29:27.269
pubsubhubbub; support on, blogs
on blogger dot com, on word

00:29:27.269 --> 00:29:31.420
press doc com, on type pad,
your own hosted word press

00:29:31.420 --> 00:29:34.770
blogs if you use the push press
plug in, tumbler,

00:29:34.770 --> 00:29:37.520
[? posterous ?]

00:29:37.520 --> 00:29:40.310
all sorts of things that
I've probably left out.

00:29:40.310 --> 00:29:43.019
Google buzz, of course,
as I showed you earlier.

00:29:43.019 --> 00:29:44.980
All these things come
with pubsubhubbub just

00:29:44.980 --> 00:29:46.120
built-in to the box.

00:29:46.120 --> 00:29:49.480
So you should have no trouble
if you want to publish yourself

00:29:49.480 --> 00:29:51.020
to one of these kinds of the
feeds with pubsubhubbub

00:29:51.020 --> 00:29:53.959
enabled, or if you just want to
consume the content

00:29:53.959 --> 00:29:58.470
from someone else.

00:29:58.470 --> 00:30:03.030
All right, so pubsubhubbub
works pushing between servers

00:30:03.030 --> 00:30:04.560
because it uses HTPP posts.

00:30:04.560 --> 00:30:07.000
But how exactly do we get
from there to pushing

00:30:07.000 --> 00:30:10.640
to the browser?

00:30:10.640 --> 00:30:13.200
Well, the first thing that
happens when feed.subscribe is

00:30:13.200 --> 00:30:20.440
called is that a request is
made to Google's servers saying

00:30:20.440 --> 00:30:22.730
please bind a comet
channel for me.

00:30:22.730 --> 00:30:25.419
This is the same technology,
basically, that Moishe was

00:30:25.419 --> 00:30:26.620
talking about earlier.

00:30:26.620 --> 00:30:30.860
It's going to bind a comet
channel and I'll show you a

00:30:30.860 --> 00:30:34.549
little bit about that
a little bit later.

00:30:35.660 --> 00:30:38.859
So the comet channel is
established and then another

00:30:38.859 --> 00:30:41.850
message is sent to Google's
server saying, I'm interested

00:30:41.850 --> 00:30:43.260
in this particular feed URL.

00:30:44.400 --> 00:30:48.340
So, it's going to send Google
Blog to blogspot.com and so on,

00:30:48.340 --> 00:30:50.119
send that to Google server,
saying please give me updates

00:30:50.119 --> 00:30:54.220
on this feed, I want
to subscribe to it.

00:30:54.220 --> 00:30:57.400
So Google is going to check
and say, OK, am I already

00:30:57.400 --> 00:30:59.350
subscribed to the
updates on this feed?

00:30:59.350 --> 00:31:02.900
If it is, it doesn't need to do
anything, but in a lot of cases

00:31:02.900 --> 00:31:06.650
it may not yet be subscribed to
that, so it's going to do the

00:31:06.650 --> 00:31:09.510
pubsubhubbub subscriptions
step with the hub that was

00:31:09.510 --> 00:31:10.380
declared for that feed.

00:31:10.380 --> 00:31:14.490
So, Google's going to send a
URL to the hub saying whenever

00:31:14.490 --> 00:31:16.940
there's updates on this feed,
send them to this URL that

00:31:16.940 --> 00:31:24.510
Google controls and that we
can receive updates on.

00:31:24.510 --> 00:31:26.600
Then, at some point, the feed
publisher publishes via

00:31:26.600 --> 00:31:30.830
pubsubhubbub, let'ls the hub
know there's new content, the

00:31:30.830 --> 00:31:34.449
hub fetches that content from
feed publisher, and it turns

00:31:34.449 --> 00:31:36.610
around and posts that to all
of the subscribers including

00:31:36.610 --> 00:31:42.000
the URLS that were
registered by Google.

00:31:42.000 --> 00:31:44.450
Then, Google can check and
see if anyone currently

00:31:44.450 --> 00:31:46.240
interested in this update?

00:31:46.240 --> 00:31:50.170
Is there anyone subscribed in
Feed API Version 2, and if so,

00:31:50.170 --> 00:31:53.910
it will push along those
channels that were established

00:31:53.910 --> 00:32:00.440
for all the users that are
subscribed in that feed.

00:32:00.440 --> 00:32:04.280
That is really all
there is to it.

00:32:04.280 --> 00:32:08.440
Let me go back to the demo
I showed you a second ago,

00:32:08.440 --> 00:32:12.450
and give you a feel for
what this looks like.

00:32:12.450 --> 00:32:15.840
We look in Chrome developer
tools and see alot of

00:32:15.840 --> 00:32:18.670
the resources that
were loaded here.

00:32:18.940 --> 00:32:23.950
You can see that we started the
channel around here, so you'll

00:32:23.950 --> 00:32:27.590
notice first we do a couple
tests to see what kind of comet

00:32:27.590 --> 00:32:29.240
channel is supported
on this browser.

00:32:29.900 --> 00:32:33.910
We do an initial bind to get a
channel ID, and then we get

00:32:33.910 --> 00:32:37.510
this hanging get request.

00:32:37.510 --> 00:32:40.590
You can see it lasted for about
a minute before it timed out

00:32:40.590 --> 00:32:42.690
and then another one was
created and continued to

00:32:42.690 --> 00:32:43.850
keep this connection open.

00:32:46.990 --> 00:32:50.060
In some of the cases, when
contact was sent along probably

00:32:50.060 --> 00:32:56.419
much later on here when I did
the pushes -- well I'm not

00:32:56.419 --> 00:32:59.879
finding it-- in one of these,
we would see the content that

00:32:59.879 --> 00:33:01.290
was actually pushed along.

00:33:01.390 --> 00:33:03.830
The connection is held out as
long as it possibly can and

00:33:03.830 --> 00:33:06.630
whenever it closes the client's
going to re-open that

00:33:06.630 --> 00:33:11.970
connection hold it out longer,
and oh -- here we go-- here's

00:33:11.970 --> 00:33:13.649
exactly where I push to
both of those feeds.

00:33:13.779 --> 00:33:16.679
You can see it went over this
connection during that one

00:33:16.679 --> 00:33:18.240
minute that one was open.

00:33:19.230 --> 00:33:21.929
And you can just see the
content of the feed updates

00:33:21.929 --> 00:33:23.160
that were sent along there.

00:33:23.160 --> 00:33:25.920
So the client is holding this
connection open as the content

00:33:25.920 --> 00:33:29.089
comes along, it is grabbing it
and throwing it into the call

00:33:29.089 --> 00:33:33.250
back that was registered
by the developer.

00:33:38.067 --> 00:33:41.240
So, that's how
things are pushed.

00:33:41.240 --> 00:33:44.350
Now let's talk a little
bit about some advanced

00:33:44.350 --> 00:33:45.550
uses of the API.

00:33:45.550 --> 00:33:47.860
So first of all, as you saw in
the demo, I had the include

00:33:47.860 --> 00:33:49.790
historical entries function.

00:33:50.410 --> 00:33:54.070
This simply gives us the
loading functionality of old

00:33:54.070 --> 00:33:57.669
API Version 1 without having
to define two separate feed

00:33:57.669 --> 00:34:00.340
objects and two separate call
backs to handle those cases.

00:34:00.340 --> 00:34:03.700
What I can say is I don't want
my page to be blank when I

00:34:03.700 --> 00:34:08.090
first start, so I want to load
20 historical entries first.

00:34:08.210 --> 00:34:10.070
But I want them all to be
passed to the same call back

00:34:10.070 --> 00:34:15.139
that I want the real time
updates to be sent to later.

00:34:15.239 --> 00:34:16.719
That just makes it a
little bit simpler.

00:34:16.719 --> 00:34:20.299
You could very easily also do
this with Feed API Version 1,

00:34:20.299 --> 00:34:24.499
if you wanted to do something
different in the case of the

00:34:24.499 --> 00:34:27.549
initial load and in the case of
the streaming updates later,

00:34:27.549 --> 00:34:29.269
but this just makes it a little
simpler, if the call back

00:34:29.269 --> 00:34:30.169
is the same in both cases.

00:34:32.729 --> 00:34:35.029
Another thing you can do, is
you can subscribe to multiple

00:34:35.029 --> 00:34:36.969
feeds, as I showed
you in the demo.

00:34:36.969 --> 00:34:41.519
You simply create two
feeds of type push feeds.

00:34:41.519 --> 00:34:43.959
And in this case, one is
official Google blog and one

00:34:43.959 --> 00:34:46.009
is the Google Code Blog.

00:34:47.249 --> 00:34:49.299
One thing to note, in this
case, we're only going to

00:34:49.299 --> 00:34:51.109
keep one channel open.

00:34:51.109 --> 00:34:54.949
As you saw, there was a single
connection at any given time.

00:34:55.809 --> 00:34:58.329
We're going to multi-plex the
updates on that channel again.

00:34:58.329 --> 00:35:00.129
As you saw both, both of
the updates for both feeds

00:35:00.129 --> 00:35:01.698
were on the same channel.

00:35:07.429 --> 00:35:11.320
A little more advanced; if
you're interested in knowing

00:35:11.320 --> 00:35:13.910
when the channel is bound
and when it's unbound.

00:35:14.580 --> 00:35:19.519
This does not include the cases
where the channel is simply

00:35:19.519 --> 00:35:22.879
disconnected and reconnected
immediately, naturally, but in

00:35:22.879 --> 00:35:25.439
the case that say there's
network loss and its down for

00:35:25.439 --> 00:35:26.659
longer than anticipated.

00:35:26.659 --> 00:35:30.120
Maybe you picked up your laptop
and walked between WIFI hot

00:35:30.120 --> 00:35:34.799
spots, maybe the laptop was
closed for a while, then you

00:35:34.799 --> 00:35:38.819
popped it open again, and it's
trying to reconnect again.

00:35:38.819 --> 00:35:42.809
We have a couple of call backs
that you can use to identify

00:35:42.809 --> 00:35:45.489
when the channel has been
connected and disconnected.

00:35:45.489 --> 00:35:47.479
So, first, there's the on-bind
call back which will let you

00:35:47.479 --> 00:35:49.569
know when you've been bound,
and there is the on-unbound

00:35:49.569 --> 00:35:51.069
call back which will let you
know when you've been unbound.

00:35:52.140 --> 00:35:55.609
And, you'll notice these are
on the Google.feeds.push

00:35:55.609 --> 00:35:56.869
name space statically.

00:35:57.019 --> 00:36:00.729
They're not on any particular
feed object, because again, we

00:36:00.729 --> 00:36:03.180
share one single channel
between multiple feeds.

00:36:03.180 --> 00:36:07.520
So, these events would only
happen once if the channel

00:36:07.520 --> 00:36:10.189
disconnected for all feeds
that you've subscribe to.

00:36:10.619 --> 00:36:12.289
And then you just give
it a call back and that

00:36:12.289 --> 00:36:12.779
call back will happen.

00:36:12.779 --> 00:36:14.959
In this case, it would just
alert a dialog box saying

00:36:14.959 --> 00:36:19.959
what event changes happened.

00:36:19.959 --> 00:36:22.929
And, finally, you may have a
case where you want to

00:36:22.929 --> 00:36:24.989
subscribe your users to feed
for a while, and then they're

00:36:24.989 --> 00:36:26.539
not interested in that, maybe
they are interested in

00:36:26.539 --> 00:36:30.299
something else, so you want to
unsubscribe and not get updates

00:36:30.299 --> 00:36:32.530
for that any more, and you want
to subscribe to something else.

00:36:32.530 --> 00:36:35.900
We have a simple unsubscribe
function to stop

00:36:35.900 --> 00:36:38.599
receiving updates on that
particular feed.

00:36:38.599 --> 00:36:41.399
Eventually, also we currently
don't have this implemented,

00:36:41.399 --> 00:36:45.090
but probably if you're not
subscribed to anything, your

00:36:45.090 --> 00:36:47.650
unsubscribed from all the feeds
that you were subscribed to,

00:36:47.650 --> 00:36:50.400
we'll probably just eventually
cut off that channel because

00:36:50.400 --> 00:36:53.869
it's not needed anymore.

00:36:53.869 --> 00:36:55.209
All right, so that's really
all there is to it.

00:36:55.700 --> 00:36:58.380
If you want to get started,
we're opening it up right now

00:36:58.380 --> 00:37:00.060
just for white listed testers.

00:37:00.360 --> 00:37:04.499
You can go to
code.google.com/apis/feed/push

00:37:04.499 --> 00:37:07.639
to see the documentation and
also to sign up on a form if

00:37:07.639 --> 00:37:09.479
you're interested in using it.

00:37:10.150 --> 00:37:12.569
Eventually, we hope to open
this up to everybody but we're

00:37:12.569 --> 00:37:15.309
just taking steps to release
it out slowly and

00:37:15.309 --> 00:37:17.909
see how it works.

00:37:17.909 --> 00:37:19.979
You can also play around
with it a little bit at

00:37:19.979 --> 00:37:20.269
code.google.com/playground.

00:37:22.369 --> 00:37:26.820
Look under the Feeds
section and the push

00:37:26.820 --> 00:37:27.360
subsection of that.

00:37:27.360 --> 00:37:29.140
There's a couple of different
simple examples of

00:37:29.140 --> 00:37:30.379
that [INAUDIBLE]

00:37:30.379 --> 00:37:30.531
[?___[SECTION___
MISSING___DUE___

00:37:30.531 --> 00:37:36.039
TO___TECHNICAL___DIFFICULTIES]
?]

00:37:36.039 --> 00:37:36.209
AUDIENCE: Does

00:37:36.209 --> 00:37:38.279
this mean that App Engine
is going to support

00:37:38.279 --> 00:37:40.559
real time comet push?

00:37:40.559 --> 00:37:41.599
MOISHE LETTVIN:
BRETT BAVAR: Yes.

00:37:44.130 --> 00:37:45.959
BRETT BAVAR: OK any
other questions?

00:37:45.959 --> 00:37:46.859
We've got one here.

00:37:46.859 --> 00:37:49.720
AUDIENCE: I was wonder how
does your Javascript library

00:37:49.720 --> 00:37:52.739
compared to the Strophe?

00:37:52.739 --> 00:37:53.910
MOISHE LETTVIN: That's
a very good question.

00:37:53.910 --> 00:37:55.690
So, Strophe is the
Javascript XMPP library.

00:37:55.960 --> 00:37:57.519
Is that correct?

00:37:57.519 --> 00:38:02.389
So, we're not pushing full
XMPP down to the client.

00:38:02.389 --> 00:38:06.510
We're basically collapsing a
bunch of it on the server side

00:38:06.510 --> 00:38:11.213
and sending just a very
compressed JSON format down so

00:38:11.213 --> 00:38:16.539
it's much less chatty
then Strophe.

00:38:16.539 --> 00:38:20.889
AUDIENCE: Is there any hope
for near term support for

00:38:20.889 --> 00:38:26.559
GWT widgets support on the
client for the channel?

00:38:26.559 --> 00:38:27.099
GWT support on the client
side for the channel.

00:38:27.359 --> 00:38:31.079
MOISHE LETTVIN: Oh, yes, we're
working on that, absolutely.

00:38:31.079 --> 00:38:35.210
Good question.

00:38:35.210 --> 00:38:40.029
BRETT BAVAR: Anything else?

00:38:40.029 --> 00:38:40.319
OK.

00:38:40.319 --> 00:38:41.289
I think we're done.

00:38:41.289 --> 00:38:46.289
[APPLAUSE]

