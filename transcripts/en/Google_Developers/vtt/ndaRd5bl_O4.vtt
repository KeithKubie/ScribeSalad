WEBVTT
Kind: captions
Language: en

00:00:05.912 --> 00:00:07.370
MALE SPEAKER: I'd
like to introduce

00:00:07.370 --> 00:00:10.320
Mandy Waite, our cloud developer
advocate and general cloud

00:00:10.320 --> 00:00:13.700
miracle worker, who is
going to let you know what

00:00:13.700 --> 00:00:15.920
what developers would
like in the cloud.

00:00:15.920 --> 00:00:17.020
MANDY WAITE: Hey guys.

00:00:17.020 --> 00:00:18.205
Can you all hear me?

00:00:20.950 --> 00:00:21.946
All right.

00:00:21.946 --> 00:00:23.958
So this is one of the
world's longest stages,

00:00:23.958 --> 00:00:25.916
so I have to walk down
here every now and again

00:00:25.916 --> 00:00:27.786
to say hi to you lot as well.

00:00:27.786 --> 00:00:28.610
Hello.

00:00:28.610 --> 00:00:31.190
So I'll try to give you
all an equal amount of love

00:00:31.190 --> 00:00:33.739
by walking backwards
and forwards.

00:00:33.739 --> 00:00:36.030
We are going to talk about
what our game developers are

00:00:36.030 --> 00:00:37.860
looking for in the cloud.

00:00:37.860 --> 00:00:40.530
So how many people
here today are

00:00:40.530 --> 00:00:44.210
using the cloud for some part
of their application, back ends

00:00:44.210 --> 00:00:45.420
and such like?

00:00:45.420 --> 00:00:46.040
OK.

00:00:46.040 --> 00:00:48.470
So we're going to cover
everything, pretty much,

00:00:48.470 --> 00:00:51.910
the basics to what the Google
Cloud platform looks like.

00:00:51.910 --> 00:00:54.270
And we're going to
start off like this.

00:00:54.270 --> 00:00:57.260
So basically this is a
very quick introduction.

00:00:57.260 --> 00:00:58.382
This is where you are.

00:00:58.382 --> 00:00:59.590
You've developed you're game.

00:00:59.590 --> 00:01:00.548
You've built your game.

00:01:00.548 --> 00:01:04.290
You have, perhaps, versions of
your game for mobile platforms,

00:01:04.290 --> 00:01:06.054
maybe for desktop as well.

00:01:06.054 --> 00:01:07.220
You've done all of the work.

00:01:07.220 --> 00:01:09.670
You've had a designer
go over your work,

00:01:09.670 --> 00:01:11.895
make it really,
really attractive,

00:01:11.895 --> 00:01:14.730
make the graphics look
fantastic, provide the best

00:01:14.730 --> 00:01:18.260
user interaction experience
within the game itself.

00:01:18.260 --> 00:01:19.934
You've read about
all of the lessons

00:01:19.934 --> 00:01:21.850
that people have learned
when developing games

00:01:21.850 --> 00:01:23.340
over the years.

00:01:23.340 --> 00:01:26.400
You've build a beta version
and you've deployed it, maybe

00:01:26.400 --> 00:01:28.510
to the app store, maybe
to the Google Play store,

00:01:28.510 --> 00:01:30.880
maybe to the Chrome Web Store.

00:01:30.880 --> 00:01:33.560
You've had zero crashes, zero
hangs, so you're done right?

00:01:33.560 --> 00:01:34.244
That's it.

00:01:34.244 --> 00:01:35.452
You don't have to do anymore.

00:01:35.452 --> 00:01:37.743
But what if one of the key
features of your application

00:01:37.743 --> 00:01:39.480
was social interaction,
the ability

00:01:39.480 --> 00:01:42.890
to interact socially between
users of your application?

00:01:42.890 --> 00:01:44.510
What if it was a
multi-player game?

00:01:44.510 --> 00:01:46.710
What if you wanted it to
be a multi-player game?

00:01:46.710 --> 00:01:49.310
What if you wanted to gather
analytics from your game

00:01:49.310 --> 00:01:53.046
about the way people actually
interacted in your game?

00:01:53.046 --> 00:01:55.670
One of things you might want to
do is what they did in Ingress.

00:01:55.670 --> 00:01:58.220
How many people
have played Ingress?

00:01:58.220 --> 00:02:00.370
This one is amazing because
we think, at Google,

00:02:00.370 --> 00:02:02.001
that everybody plays Ingress.

00:02:02.001 --> 00:02:04.250
But whenever I ask this
question about how many people

00:02:04.250 --> 00:02:07.410
have played Ingress, I only
get about two hands come up.

00:02:07.410 --> 00:02:09.780
So how many people
know what Ingress is?

00:02:09.780 --> 00:02:10.280
Right.

00:02:10.280 --> 00:02:10.780
OK.

00:02:10.780 --> 00:02:13.190
So you don't play it, but
you know what it is, kind of.

00:02:13.190 --> 00:02:16.480
So Ingress is effectively
a multi-player game.

00:02:16.480 --> 00:02:19.960
It's more the social experience
in the game effectively.

00:02:19.960 --> 00:02:22.372
It uses Google Maps
to show you portals

00:02:22.372 --> 00:02:23.830
that you can go
around and capture.

00:02:23.830 --> 00:02:26.660
There's two sides, the
united and the resistance.

00:02:26.660 --> 00:02:30.065
You have to capture
portals or create portals.

00:02:30.065 --> 00:02:32.550
It has great social
interaction experience.

00:02:32.550 --> 00:02:34.857
You can talk to each
via the application.

00:02:34.857 --> 00:02:36.690
But one of the most
important features of it

00:02:36.690 --> 00:02:38.614
is that people get
together in groups.

00:02:38.614 --> 00:02:40.530
They get their phones
out and they walk around

00:02:40.530 --> 00:02:42.620
and capture portals, or
create portals together

00:02:42.620 --> 00:02:44.180
as social groups.

00:02:44.180 --> 00:02:47.040
This is social experience,
social interaction

00:02:47.040 --> 00:02:49.324
at the extreme.

00:02:49.324 --> 00:02:51.490
But obviously, how do you
build something like that?

00:02:51.490 --> 00:02:53.400
How do you build
an application that

00:02:53.400 --> 00:02:54.775
has those kind of services?

00:02:54.775 --> 00:02:56.400
You can't just build
this on the phone.

00:02:56.400 --> 00:02:58.330
There has to be some
back end component.

00:02:58.330 --> 00:02:59.871
So how do you get
started when you're

00:02:59.871 --> 00:03:02.465
building the back end for
a game in application?

00:03:02.465 --> 00:03:03.840
So the first thing
you could do--

00:03:03.840 --> 00:03:05.620
and this is what you
would have done years ago.

00:03:05.620 --> 00:03:07.440
Maybe for some of us
now it wouldn't even

00:03:07.440 --> 00:03:08.850
occur to us to do this.

00:03:08.850 --> 00:03:11.152
You could actually
just build a server.

00:03:11.152 --> 00:03:12.860
Buy a server, stick
it next to your desk.

00:03:12.860 --> 00:03:15.060
Stick it in your garage,
stick it in your office,

00:03:15.060 --> 00:03:17.560
and then you can run
your back end component

00:03:17.560 --> 00:03:19.600
of your application from there.

00:03:19.600 --> 00:03:22.140
But will it solve
all your problems?

00:03:26.358 --> 00:03:30.320
Who installs all of the
software on this machine?

00:03:30.320 --> 00:03:31.550
Who operates the hardware?

00:03:31.550 --> 00:03:34.180
Who fixes the hardware
when it breaks?

00:03:34.180 --> 00:03:37.201
What if the connection
fails to the internet?

00:03:37.201 --> 00:03:38.450
What if there's too much load?

00:03:38.450 --> 00:03:41.045
I'm going to talk about load
more in a couple of slides.

00:03:41.045 --> 00:03:42.670
So these are all of
the problems you're

00:03:42.670 --> 00:03:44.461
going to get when you're
building something

00:03:44.461 --> 00:03:46.310
like this on a
server that you own.

00:03:46.310 --> 00:03:48.090
And again, some of
us today probably

00:03:48.090 --> 00:03:49.990
wouldn't even consider
this is an option.

00:03:49.990 --> 00:03:53.070
But not so long ago, this was
pretty much the only option.

00:03:53.070 --> 00:03:54.910
But now today we have the cloud.

00:03:54.910 --> 00:03:56.190
This is kind of my idea.

00:03:56.190 --> 00:03:57.565
Somebody else
provided the slide,

00:03:57.565 --> 00:03:59.700
but this resonates
with me really well.

00:03:59.700 --> 00:04:02.670
This is what it looked like
to build applications back

00:04:02.670 --> 00:04:03.810
in the old days.

00:04:03.810 --> 00:04:05.920
We used to build machines,
configure machines.

00:04:05.920 --> 00:04:08.130
I first started with
some microsystems

00:04:08.130 --> 00:04:10.230
in codec, working on some
microsystems machines

00:04:10.230 --> 00:04:11.611
back in 1989.

00:04:11.611 --> 00:04:13.110
And we used to sit
there with tapes,

00:04:13.110 --> 00:04:14.800
loading taps into machines.

00:04:14.800 --> 00:04:17.173
It would take a whole day
to configure a system.

00:04:17.173 --> 00:04:18.339
We would build the hardware.

00:04:18.339 --> 00:04:19.797
We would build the
software system.

00:04:19.797 --> 00:04:22.860
We would build the software
stack, set up the database,

00:04:22.860 --> 00:04:26.720
configure uses, all that stuff
we would have to do ourselves.

00:04:26.720 --> 00:04:29.640
So you can build
all this yourself.

00:04:29.640 --> 00:04:31.490
What about
anticipating your load?

00:04:31.490 --> 00:04:32.940
What are you going
to build first?

00:04:32.940 --> 00:04:34.440
How many people are
you going to get

00:04:34.440 --> 00:04:36.202
using your
application initially?

00:04:36.202 --> 00:04:37.660
What happens if
you get TechCrunch?

00:04:37.660 --> 00:04:39.659
What happens if you get
slashdotted and suddenly

00:04:39.659 --> 00:04:43.970
your load on your application
increases rapidly,

00:04:43.970 --> 00:04:46.520
increases ridiculously
rapidly over night?

00:04:46.520 --> 00:04:49.210
How do you handle
these kinds of spikes?

00:04:49.210 --> 00:04:51.190
Does this have a pointer on it?

00:04:51.190 --> 00:04:51.822
I guess not.

00:04:51.822 --> 00:04:54.280
How do you handle traffic kind
of spikes, the kind of spike

00:04:54.280 --> 00:04:56.980
you see here on the left,
where traffic will suddenly

00:04:56.980 --> 00:05:00.820
increase very rapidly because
of some event that happened?

00:05:00.820 --> 00:05:06.200
Maybe your game was published
in an article on TechCrunch

00:05:06.200 --> 00:05:11.510
or on Slashdot or
some other key forum

00:05:11.510 --> 00:05:14.670
for promoting
gaming applications.

00:05:14.670 --> 00:05:16.574
What about periods
of inactivity?

00:05:16.574 --> 00:05:18.490
What happens if your
game is kind of seasonal,

00:05:18.490 --> 00:05:20.330
that people don't
play it all the time?

00:05:20.330 --> 00:05:24.220
What happens if you've
over provisioned your load,

00:05:24.220 --> 00:05:26.160
or for your load, you
have too many machines

00:05:26.160 --> 00:05:28.010
available at any given time?

00:05:28.010 --> 00:05:30.970
What happens when those
machines aren't being used?

00:05:30.970 --> 00:05:32.410
You're still paying for them.

00:05:32.410 --> 00:05:34.590
How do you handle linear scale?

00:05:34.590 --> 00:05:36.560
How do you handle
exponential scale?

00:05:36.560 --> 00:05:40.690
All these problems are things
you'd have to tackle yourself.

00:05:40.690 --> 00:05:43.270
When we look at the cloud,
we see something like this.

00:05:43.270 --> 00:05:45.210
We have these options--
infrastructure

00:05:45.210 --> 00:05:47.080
as a service,
platform as a service,

00:05:47.080 --> 00:05:48.379
and pretty much do it yourself.

00:05:48.379 --> 00:05:50.420
We also talk about software
as a service and back

00:05:50.420 --> 00:05:53.194
end as a service as well.

00:05:53.194 --> 00:05:54.860
When you do it yourself,
you pretty much

00:05:54.860 --> 00:05:55.700
have to do everything.

00:05:55.700 --> 00:05:57.825
And that goes back to the
slide we looked at before

00:05:57.825 --> 00:06:00.250
with the guy with the boxes,
building all the way up

00:06:00.250 --> 00:06:02.810
from the operating system
up to the application level.

00:06:02.810 --> 00:06:04.460
With infrastructure
as a service,

00:06:04.460 --> 00:06:06.212
you get all of the
virtualization there.

00:06:06.212 --> 00:06:07.670
You actually get
a machine provided

00:06:07.670 --> 00:06:09.290
for you, a virtual machine.

00:06:09.290 --> 00:06:12.370
On top of this, you install
an operating system,

00:06:12.370 --> 00:06:14.900
usually provided by
the cloud vendor,

00:06:14.900 --> 00:06:17.460
and on top of that can install
all the middleware, all

00:06:17.460 --> 00:06:22.410
of the run time, and your
application software as well.

00:06:22.410 --> 00:06:24.040
That's infrastructure
as a service.

00:06:24.040 --> 00:06:25.998
Platform as a service is
a little bit different

00:06:25.998 --> 00:06:28.610
because it provides the OS, the
middleware, and the run time.

00:06:28.610 --> 00:06:30.651
It effectively provides
you with a software stack

00:06:30.651 --> 00:06:33.220
on which you can run your
application and store data.

00:06:35.890 --> 00:06:37.940
So which would you
choose, do it yourself,

00:06:37.940 --> 00:06:40.320
infrastructure as a service,
or platform as a service?

00:06:40.320 --> 00:06:42.611
We're going to explore that
question a little bit more,

00:06:42.611 --> 00:06:43.730
shortly.

00:06:43.730 --> 00:06:45.390
There's also back
end as a service.

00:06:45.390 --> 00:06:46.930
Back end as a
service effectively

00:06:46.930 --> 00:06:50.860
provides you with services that
your application can consume

00:06:50.860 --> 00:06:56.640
directly, so things
like messaging, pub sub,

00:06:56.640 --> 00:06:59.420
social interaction
experience, analytics,

00:06:59.420 --> 00:07:00.790
those kinds of things.

00:07:00.790 --> 00:07:02.332
And also you can
use gaming services,

00:07:02.332 --> 00:07:04.498
which is what you're going
to hear about quite a lot

00:07:04.498 --> 00:07:05.830
today from people like Daniel.

00:07:05.830 --> 00:07:07.280
Daniel has probably already
introduced all of these

00:07:07.280 --> 00:07:08.160
already.

00:07:08.160 --> 00:07:09.980
So these gaming
services, you can just

00:07:09.980 --> 00:07:11.476
plug into them very quickly.

00:07:11.476 --> 00:07:12.850
You just write
your code to them.

00:07:12.850 --> 00:07:14.975
You don't actually have to
build anything yourself.

00:07:17.490 --> 00:07:18.930
So what do you choose?

00:07:18.930 --> 00:07:20.890
Infrastructure as
a service is great.

00:07:20.890 --> 00:07:24.380
It's particularly suited for
applications and games that

00:07:24.380 --> 00:07:27.030
are latency sensitive,
that have a requirement

00:07:27.030 --> 00:07:28.830
for very low latency.

00:07:28.830 --> 00:07:31.160
And this particularly
comes into play

00:07:31.160 --> 00:07:33.850
when you have games
like Jam with Chrome.

00:07:33.850 --> 00:07:36.950
Anybody see Jam with Chrome,
the Chrome experiment.

00:07:36.950 --> 00:07:39.070
So this effectively
allowed users

00:07:39.070 --> 00:07:40.445
to get together
in an application

00:07:40.445 --> 00:07:43.180
and play instruments,
together, interactivity,

00:07:43.180 --> 00:07:44.132
across the world.

00:07:44.132 --> 00:07:46.340
So one person would be
playing the drums in Australia

00:07:46.340 --> 00:07:49.920
while another guy was
playing the guitar in the US.

00:07:49.920 --> 00:07:51.960
And that requires
a very low latency.

00:07:51.960 --> 00:07:54.840
That requires something
like web sockets.

00:07:54.840 --> 00:07:56.680
So in that case,
infrastructure as a service

00:07:56.680 --> 00:07:59.450
is perfectly suited for that
particular kind of solution.

00:07:59.450 --> 00:08:00.660
It's also extremely flexible.

00:08:00.660 --> 00:08:02.210
It gives you the
most flexibility

00:08:02.210 --> 00:08:04.270
of all of the solutions
possible because you

00:08:04.270 --> 00:08:05.770
can build anything
you like with it.

00:08:05.770 --> 00:08:08.730
It's a virtual machine.

00:08:08.730 --> 00:08:12.000
You can also reuse all of that
code and database knowledge

00:08:12.000 --> 00:08:13.530
that you've built
up over the years.

00:08:13.530 --> 00:08:15.700
You don't have to worry
about abstractions.

00:08:15.700 --> 00:08:17.131
Anybody who's
working for you who

00:08:17.131 --> 00:08:19.380
knows how to program a
database, how to actually build

00:08:19.380 --> 00:08:22.180
a software stack, you can
reuse all of that knowledge.

00:08:22.180 --> 00:08:27.230
I-A-A-S-- IaaS-- is particularly
suited for complex games.

00:08:27.230 --> 00:08:29.470
You can pretty much run
anything you like on it.

00:08:29.470 --> 00:08:31.155
But if you have a
really complex game,

00:08:31.155 --> 00:08:33.260
it may be the other
offerings, the other solutions

00:08:33.260 --> 00:08:35.900
are not particularly
suitable for you.

00:08:35.900 --> 00:08:38.700
When it comes to
platform as a service,

00:08:38.700 --> 00:08:40.760
the sweet spot for
platform as a service,

00:08:40.760 --> 00:08:42.490
and we'll look at
App Engine shortly,

00:08:42.490 --> 00:08:45.165
is the handling of scale,
the ability to handle scale.

00:08:45.165 --> 00:08:46.540
Those kinds of
loads we looked at

00:08:46.540 --> 00:08:49.710
before where we have
huge spikes in traffic,

00:08:49.710 --> 00:08:51.670
we have levels where
we're not actually

00:08:51.670 --> 00:08:53.710
using any resources at all.

00:08:53.710 --> 00:08:57.740
We have exponential
growth, or linear growth.

00:08:57.740 --> 00:09:00.690
Platform as a service is also
great for providing services

00:09:00.690 --> 00:09:03.840
to allow for player
to player interaction.

00:09:03.840 --> 00:09:05.490
So again, this goes
back to Ingress.

00:09:05.490 --> 00:09:07.590
Ingress runs on a
platform as a service,

00:09:07.590 --> 00:09:09.780
and it offers all of
these features to you.

00:09:09.780 --> 00:09:12.650
It will make it very easy to
access other APIs and services

00:09:12.650 --> 00:09:15.050
to allow you to build
social interaction.

00:09:15.050 --> 00:09:18.540
Spiking use numbers
comes back to scale.

00:09:18.540 --> 00:09:21.030
This is pretty good for
casual types of games.

00:09:21.030 --> 00:09:23.360
Games like Ingress.

00:09:23.360 --> 00:09:25.070
Games like Ingress.

00:09:25.070 --> 00:09:26.880
Then you have these
gaming services.

00:09:26.880 --> 00:09:27.380
Flappy Bird.

00:09:27.380 --> 00:09:29.255
I'm not sure if I'm
allowed to use this icon,

00:09:29.255 --> 00:09:31.234
but it was on here
when I got the slide.

00:09:31.234 --> 00:09:32.900
How many people have
played Flappy bird.

00:09:36.400 --> 00:09:36.900
OK.

00:09:36.900 --> 00:09:38.980
You admit it at least.

00:09:38.980 --> 00:09:40.630
One of the key things
about Flappy Bird

00:09:40.630 --> 00:09:42.849
is not the game play.

00:09:42.849 --> 00:09:44.890
We must admit the game
play in Flappy Bird is not

00:09:44.890 --> 00:09:46.230
the best in the world.

00:09:46.230 --> 00:09:48.785
But it does have this
wonderful social interaction

00:09:48.785 --> 00:09:51.940
in that you can see your
friends' high scores.

00:09:51.940 --> 00:09:54.660
That service is very,
very simple to set up.

00:09:54.660 --> 00:09:56.080
Once you have your
high score, you

00:09:56.080 --> 00:09:57.557
can see your
friends high scores,

00:09:57.557 --> 00:09:59.390
and you can compare
your scores with theirs,

00:09:59.390 --> 00:10:00.514
and then try to beat it.

00:10:00.514 --> 00:10:02.722
And that's where you start
playing it over, and over,

00:10:02.722 --> 00:10:03.700
and over again.

00:10:03.700 --> 00:10:06.116
Until the point where are throw
your phone across the room

00:10:06.116 --> 00:10:08.732
because you keep hitting a pipe.

00:10:08.732 --> 00:10:11.190
It's very easy to get started
with these kinds of services,

00:10:11.190 --> 00:10:13.481
and it offers things like
high scores and achievements.

00:10:13.481 --> 00:10:17.040
It offers you the ability
to go back to your device

00:10:17.040 --> 00:10:20.990
and play the game, put the
device down, pick up a tablet,

00:10:20.990 --> 00:10:23.780
pick up some other offering
and play that game,

00:10:23.780 --> 00:10:26.190
picking up from where you
left off within the gaming

00:10:26.190 --> 00:10:28.130
environment as before.

00:10:28.130 --> 00:10:29.610
Sorry.

00:10:29.610 --> 00:10:31.352
This is very good for
very simple games.

00:10:31.352 --> 00:10:33.810
Although you can build quite
complex games with it as well.

00:10:36.470 --> 00:10:38.480
So this comes back to Ingress.

00:10:38.480 --> 00:10:41.430
Ingress was built on what's
known as App Engine, Google App

00:10:41.430 --> 00:10:43.622
Engine, this is part
of our cloud platform.

00:10:43.622 --> 00:10:45.330
The social experience
that Ingress offers

00:10:45.330 --> 00:10:47.270
is very, very important to it.

00:10:47.270 --> 00:10:49.010
Platform as a
service was key here.

00:10:49.010 --> 00:10:51.520
The ability to handle
the kind of scale

00:10:51.520 --> 00:10:55.470
that the game of Ingress'
size-- again although nobody

00:10:55.470 --> 00:10:56.650
seems to be playing it.

00:10:56.650 --> 00:10:58.441
It's quite hard to know
whether it actually

00:10:58.441 --> 00:11:02.430
needs to scale up
to huge levels.

00:11:02.430 --> 00:11:06.450
So Ingress is built on top
of platform as a service.

00:11:06.450 --> 00:11:07.670
Here's a quick quiz for you.

00:11:07.670 --> 00:11:11.970
Which company offers traditional
hosting, infrastructure

00:11:11.970 --> 00:11:14.280
as a service in
the cloud, platform

00:11:14.280 --> 00:11:17.840
as a service in the cloud,
and back end as a service,

00:11:17.840 --> 00:11:20.810
and mobile platform
as a service?

00:11:20.810 --> 00:11:21.660
That's us.

00:11:21.660 --> 00:11:24.280
We offer all of those services.

00:11:24.280 --> 00:11:28.420
Again, I think you're going to
go over all these today quite

00:11:28.420 --> 00:11:29.260
a number of times.

00:11:29.260 --> 00:11:30.926
You're going to see
this kind of circle.

00:11:30.926 --> 00:11:32.760
You're going to see
things like Admob

00:11:32.760 --> 00:11:34.300
The Android Play game services.

00:11:34.300 --> 00:11:36.070
Chrome Web Store.

00:11:36.070 --> 00:11:36.990
More Play Services.

00:11:36.990 --> 00:11:38.990
Admob double click exchange.

00:11:38.990 --> 00:11:40.775
Google Cloud platform analytics.

00:11:40.775 --> 00:11:42.650
These are all of the
things we offer in order

00:11:42.650 --> 00:11:45.280
to build up our
gaming experience.

00:11:45.280 --> 00:11:47.600
So let's talk about the
Google Cloud Platform.

00:11:47.600 --> 00:11:50.030
How many people here
have actually heard

00:11:50.030 --> 00:11:52.400
of the Google Cloud platform?

00:11:52.400 --> 00:11:54.780
How many people have
actually used it?

00:11:54.780 --> 00:11:55.280
OK.

00:11:55.280 --> 00:11:59.050
So the Google Cloud platform
is pretty much a new idea.

00:11:59.050 --> 00:12:01.550
We started off with App
Engine back in 2008.

00:12:01.550 --> 00:12:03.740
Since then we've made
available Compute Engine,

00:12:03.740 --> 00:12:06.350
another component of
our cloud platform.

00:12:06.350 --> 00:12:07.810
And we're booting
up other services

00:12:07.810 --> 00:12:10.540
on top of that to make a
comprehensive, integrated,

00:12:10.540 --> 00:12:12.900
complete cloud platform.

00:12:12.900 --> 00:12:14.900
Let's go over what that
actually looks like.

00:12:14.900 --> 00:12:17.500
Well first a bit of history.

00:12:17.500 --> 00:12:20.570
Software innovation happens
quite rapidly at Google.

00:12:20.570 --> 00:12:23.702
Back in 2002 we had a
requirement for a file system

00:12:23.702 --> 00:12:25.910
that was extremely fast,
extremely scalable, and very

00:12:25.910 --> 00:12:27.790
low maintenance for our
engineers, something

00:12:27.790 --> 00:12:29.450
they could just
throw data at and not

00:12:29.450 --> 00:12:31.070
have to worry about it too much.

00:12:31.070 --> 00:12:33.340
So we built this thing
called Google File System.

00:12:33.340 --> 00:12:34.990
On top of that we
built MapReduce.

00:12:34.990 --> 00:12:36.050
We published a paper.

00:12:36.050 --> 00:12:37.960
All of these are white papers.

00:12:37.960 --> 00:12:40.190
The MapReduce runs on top
of Google File System.

00:12:40.190 --> 00:12:45.340
It allows us to run analytics
across data fairly quickly.

00:12:45.340 --> 00:12:46.532
Then we had BigTable.

00:12:46.532 --> 00:12:48.240
BigTable is another
[INAUDIBLE] offering,

00:12:48.240 --> 00:12:50.500
which we built on top
of Google File System.

00:12:50.500 --> 00:12:54.030
And which is now available as
the Google Cloud data store.

00:12:54.030 --> 00:12:56.310
Effectively, this is what
App Engine, our platform

00:12:56.310 --> 00:12:59.290
as a service offering,
was built around.

00:12:59.290 --> 00:13:02.460
Then in 2008 we published a
white paper on an application

00:13:02.460 --> 00:13:05.150
called Dremel, which
we use internally.

00:13:05.150 --> 00:13:09.540
What this came about from
was the need of our product

00:13:09.540 --> 00:13:11.850
managers to be able to
ask questions of data

00:13:11.850 --> 00:13:15.275
very, very quickly, to get
answers back interactivity

00:13:15.275 --> 00:13:17.650
effectively, to be able to
answer questions interactively

00:13:17.650 --> 00:13:22.897
and get answers back in seconds,
instead of minutes or hours.

00:13:22.897 --> 00:13:24.730
Ultimately we wrote
this tool called Dremel,

00:13:24.730 --> 00:13:27.570
and we published it since then
as BigQuery, Google BigQuery.

00:13:27.570 --> 00:13:30.650
How many people have
heard of BigQuery?

00:13:30.650 --> 00:13:32.300
OK, so we should
have a conversation

00:13:32.300 --> 00:13:33.870
about what BigQuery
is because it's

00:13:33.870 --> 00:13:35.540
extremely important
for analytics

00:13:35.540 --> 00:13:38.960
and gaining insight into
what your data looks like.

00:13:38.960 --> 00:13:41.280
Beyond that, we came up
with Google File System

00:13:41.280 --> 00:13:43.040
two, which is called Colossus.

00:13:43.040 --> 00:13:46.586
And on top of that, Google
Cloud Storage was built on.

00:13:46.586 --> 00:13:48.210
Cloud storage we'll
talk about shortly,

00:13:48.210 --> 00:13:50.230
but that is our bucket store.

00:13:50.230 --> 00:13:53.341
It's an object store for large
amounts of unstructured data.

00:13:53.341 --> 00:13:55.840
We're talking about pretty much
any amount of data you like,

00:13:55.840 --> 00:13:58.980
up to five terabytes an object.

00:13:58.980 --> 00:14:01.940
Then we have Spanner/F1.

00:14:01.940 --> 00:14:03.043
F1 is it's internal name.

00:14:03.043 --> 00:14:05.690
It was published as a
white paper called Spanner.

00:14:05.690 --> 00:14:08.620
This should be
[INAUDIBLE] on the cloud.

00:14:08.620 --> 00:14:11.690
And then finally Omega,
which is a task orchestrator.

00:14:11.690 --> 00:14:13.730
So if anybody's ever
heard of Borg internally,

00:14:13.730 --> 00:14:16.370
at Google we use this term Borg.

00:14:16.370 --> 00:14:17.770
It's leaked out several times.

00:14:17.770 --> 00:14:20.956
But we have this thing called
Omega now, "Omeega," Omega.

00:14:20.956 --> 00:14:22.330
I'm not quite sure
how to say it.

00:14:22.330 --> 00:14:24.270
I've spent too much
time in the US.

00:14:24.270 --> 00:14:26.110
Omega, which is a
task orchestrator,

00:14:26.110 --> 00:14:28.900
a very, very advanced feature
that we've introduced recently

00:14:28.900 --> 00:14:33.650
and which has a white
paper backing it.

00:14:33.650 --> 00:14:35.270
Then the Google
Cloud Platform itself

00:14:35.270 --> 00:14:37.920
consists of three main areas.

00:14:37.920 --> 00:14:41.590
They are compute,
storage, and app services.

00:14:41.590 --> 00:14:45.130
On the compute side, we look
at these in more detail,

00:14:45.130 --> 00:14:47.770
we have App Engine,
and Compute Engine.

00:14:47.770 --> 00:14:50.007
Then on the storage side
we have Cloud Storage,

00:14:50.007 --> 00:14:51.090
which I've just mentioned.

00:14:51.090 --> 00:14:52.860
Which is built on
top of Colossus,

00:14:52.860 --> 00:14:57.200
and that again provides
a bucket storage service

00:14:57.200 --> 00:14:59.900
for storing unstructured data.

00:14:59.900 --> 00:15:03.370
Cloud SQL offers you MySQL
instances in the cloud.

00:15:03.370 --> 00:15:05.799
These are completely
fully managed instances.

00:15:05.799 --> 00:15:07.590
So you create your
database on an instance.

00:15:07.590 --> 00:15:09.410
You create your tables
within the database,

00:15:09.410 --> 00:15:11.160
but you don't have to
worry about managing

00:15:11.160 --> 00:15:12.285
the actual instance itself.

00:15:14.996 --> 00:15:16.370
Then we have the
Cloud Datastore,

00:15:16.370 --> 00:15:19.620
which is our massively
scalable, automatically

00:15:19.620 --> 00:15:22.600
scalable, NoSQL offering.

00:15:22.600 --> 00:15:25.380
This, again, used to be tied
completely to App Engine.

00:15:25.380 --> 00:15:28.140
App Engine was effectively built
around the Cloud Datastore,

00:15:28.140 --> 00:15:30.440
but now it's
available as an API.

00:15:30.440 --> 00:15:33.150
And this is perfect
for structured data,

00:15:33.150 --> 00:15:36.090
or semi-structured data, and
it doesn't require a schema.

00:15:36.090 --> 00:15:39.125
It effectively uses
buckets of properties.

00:15:39.125 --> 00:15:41.250
Then we have application
services such as BigQuery,

00:15:41.250 --> 00:15:43.370
and I mentioned BigQuery before.

00:15:43.370 --> 00:15:46.370
But imagine the need for
running analytics very quickly

00:15:46.370 --> 00:15:49.040
across your data, either
running interactively

00:15:49.040 --> 00:15:50.967
or through an API.

00:15:50.967 --> 00:15:52.550
BigQuery is effectively
an API, but it

00:15:52.550 --> 00:15:56.930
has a console that you can
use to interactively query

00:15:56.930 --> 00:15:58.870
your data.

00:15:58.870 --> 00:16:00.340
It runs very, very fast.

00:16:00.340 --> 00:16:02.430
It has an SQL like
syntax, and can

00:16:02.430 --> 00:16:04.850
run across terabytes
of data in seconds,

00:16:04.850 --> 00:16:06.864
billions of rows of data.

00:16:06.864 --> 00:16:08.280
Then we have Cloud
implants, which

00:16:08.280 --> 00:16:10.880
will expand on more, which
effectively allows you to build

00:16:10.880 --> 00:16:13.250
APIs, your interface
into the Cloud.

00:16:16.534 --> 00:16:18.200
So some of these Cloud
platform features

00:16:18.200 --> 00:16:20.320
that we feel are
important to call out here

00:16:20.320 --> 00:16:23.960
are the ability to scale,
you want your app to scale,

00:16:23.960 --> 00:16:26.010
you want it to scale
to Google scale,

00:16:26.010 --> 00:16:28.680
the ability to scale
very quickly on demand.

00:16:28.680 --> 00:16:31.069
And scaling here,
we're talking about

00:16:31.069 --> 00:16:32.610
not just the ability
to scale upwards

00:16:32.610 --> 00:16:37.110
to manage spikes in traffic,
but also to remove resources

00:16:37.110 --> 00:16:38.330
when they're not needed.

00:16:38.330 --> 00:16:39.900
So do you have what you
need when you need it,

00:16:39.900 --> 00:16:41.316
but you only pay
for what you use.

00:16:44.730 --> 00:16:46.700
Also, because of the
ability to auto scale,

00:16:46.700 --> 00:16:49.600
you don't actually have to
plan ahead for resources.

00:16:49.600 --> 00:16:53.190
When we use App Engine, we'll
look App Engine again shortly,

00:16:53.190 --> 00:16:55.300
App Engine will scale up
and speed up instances

00:16:55.300 --> 00:16:58.540
as required to meet the
demand from the traffic

00:16:58.540 --> 00:17:00.130
to your application.

00:17:00.130 --> 00:17:01.380
Also flexible charging.

00:17:01.380 --> 00:17:03.940
Again, we go back to
what we said before,

00:17:03.940 --> 00:17:05.710
pay for only what you use.

00:17:05.710 --> 00:17:07.470
And this is quite
important to anybody

00:17:07.470 --> 00:17:09.380
developing applications
in the Cloud.

00:17:09.380 --> 00:17:13.209
If you have resources sitting
around consuming cost,

00:17:13.209 --> 00:17:14.000
that's down to you.

00:17:14.000 --> 00:17:17.660
But if you're having to pay for
things that you're not using,

00:17:17.660 --> 00:17:22.450
say you use a virtual machine
for 10 minutes, 20 minutes,

00:17:22.450 --> 00:17:25.470
and you pay for an hour instead
of just those 20 minutes

00:17:25.470 --> 00:17:26.920
you're using the
virtual machine,

00:17:26.920 --> 00:17:29.260
then that's not very
efficient for you.

00:17:29.260 --> 00:17:30.784
Also no large scale investments.

00:17:30.784 --> 00:17:32.450
You don't actually
have to buy machines,

00:17:32.450 --> 00:17:34.865
you don't have to buy a big
cluster of machines or boxes,

00:17:34.865 --> 00:17:36.495
you don't have to
build a database.

00:17:36.495 --> 00:17:38.930
And we have these start up
programs that are available.

00:17:38.930 --> 00:17:39.839
Start up packs.

00:17:39.839 --> 00:17:41.130
A very simple start up program.

00:17:41.130 --> 00:17:44.160
Did you all get the little card?

00:17:44.160 --> 00:17:44.880
Yeah?

00:17:44.880 --> 00:17:46.600
I think Rupert is going
to talk more about later,

00:17:46.600 --> 00:17:48.516
but effectively that
gives you some credit you

00:17:48.516 --> 00:17:53.540
can use for the Google
Cloud platform itself.

00:17:53.540 --> 00:17:56.540
Then we have these RESTful APIs
and the ability to integrate

00:17:56.540 --> 00:18:01.380
with other Google services at
effectively what is very low

00:18:01.380 --> 00:18:06.320
latency interactions with Google
services such as YouTube, Maps,

00:18:06.320 --> 00:18:10.180
Google+ APIs, and other services
such as the Cloud data store,

00:18:10.180 --> 00:18:13.600
Cloud storage, all the other
services we looked at before.

00:18:13.600 --> 00:18:16.750
Also these APIs are supported
by many third party tools,

00:18:16.750 --> 00:18:19.540
and we provide tools as
well for building APIs.

00:18:19.540 --> 00:18:21.690
And these are very
consistent and standardized

00:18:21.690 --> 00:18:24.330
across all of our product range.

00:18:24.330 --> 00:18:26.770
When it comes to support, we
have free and paid support

00:18:26.770 --> 00:18:28.440
options.

00:18:28.440 --> 00:18:31.640
And our support team
has real engineers.

00:18:31.640 --> 00:18:34.130
So effectively what we have
are site reliability engineers,

00:18:34.130 --> 00:18:37.210
and I'll talk more
about those in a second.

00:18:37.210 --> 00:18:39.660
And we have a free nines
SLA for all of our products.

00:18:42.499 --> 00:18:43.790
So let's talk about App Engine.

00:18:43.790 --> 00:18:45.860
App Engine, again, the
ability to auto scale.

00:18:45.860 --> 00:18:48.890
We've covered this already so I
won't go into any more detail.

00:18:48.890 --> 00:18:51.430
It's very easy to get started
with Google App Engine.

00:18:51.430 --> 00:18:53.010
It's free to start.

00:18:53.010 --> 00:18:54.160
There's a free tier.

00:18:54.160 --> 00:18:55.743
You don't have to
put your credit card

00:18:55.743 --> 00:18:57.920
information or any
billing information in.

00:18:57.920 --> 00:19:01.040
Effectively, you get some
quotas you can use for a day.

00:19:01.040 --> 00:19:02.580
They get reset on a daily basis.

00:19:02.580 --> 00:19:05.055
And that's really good
to get started with.

00:19:05.055 --> 00:19:07.430
Also we provide you with a
local development environment,

00:19:07.430 --> 00:19:09.740
so you can do all of your
development interactively

00:19:09.740 --> 00:19:11.930
on your own workstation,
or on your laptop,

00:19:11.930 --> 00:19:14.550
before deploying new
applications to App Engine.

00:19:14.550 --> 00:19:16.990
It also offers the service
abstraction, abstractions

00:19:16.990 --> 00:19:20.170
to the Cloud
Datastore, to Memcache.

00:19:20.170 --> 00:19:21.980
They're very easy
to get started with.

00:19:21.980 --> 00:19:24.680
You don't actually have
to build Memcache service.

00:19:24.680 --> 00:19:27.020
Memcache is available
to you directly.

00:19:27.020 --> 00:19:29.700
We have abstractions that allow
you to access the data store

00:19:29.700 --> 00:19:33.030
very, very easily
within your code.

00:19:33.030 --> 00:19:35.950
It's also extremely
trivial to manage.

00:19:35.950 --> 00:19:38.470
So App Engine is fully managed.

00:19:38.470 --> 00:19:40.390
It provides software
stacks in the cloud.

00:19:40.390 --> 00:19:46.310
Currently we support
Python, Java, PHP, and Go.

00:19:46.310 --> 00:19:47.470
Low patches.

00:19:47.470 --> 00:19:49.830
You don't have to worry
about patching or upgrading

00:19:49.830 --> 00:19:51.700
these software run times.

00:19:51.700 --> 00:19:54.302
And they are
operated 24/7 by what

00:19:54.302 --> 00:19:55.760
we call site
reliability engineers.

00:19:55.760 --> 00:19:57.440
These are the guys
that wear the pagers.

00:19:57.440 --> 00:19:58.940
These are the guys
that get woken up

00:19:58.940 --> 00:20:02.500
at two AM in the morning to
fix issues with App Engine.

00:20:05.220 --> 00:20:06.100
Then cloud endpoints.

00:20:06.100 --> 00:20:08.750
I've mentioned Cloud
endpoints briefly already.

00:20:08.750 --> 00:20:11.460
Cloud endpoints allows you to
expose your application code

00:20:11.460 --> 00:20:12.822
as an API.

00:20:12.822 --> 00:20:14.780
What you do is you write
your application code,

00:20:14.780 --> 00:20:17.510
deploy it to App Engine, you
can then add some annotations

00:20:17.510 --> 00:20:20.180
to your code, or you can
build this all from scratch.

00:20:20.180 --> 00:20:23.350
Add some annotations to your
code, deploy it to App Engine

00:20:23.350 --> 00:20:25.150
again, and you will
effectively have

00:20:25.150 --> 00:20:29.450
APIs running on the Google
infrastructure, the Google API

00:20:29.450 --> 00:20:34.890
infrastructure that we use
for exposing our own APIs.

00:20:34.890 --> 00:20:37.360
These APIs are
completely discoverable.

00:20:37.360 --> 00:20:40.970
They're RESTful APIs, and
they're very, very easy to use.

00:20:40.970 --> 00:20:43.825
Once you have the API exposed,
you can use [INAUDIBLE].

00:20:43.825 --> 00:20:48.360
It's available from Android
studio Eclipse from the command

00:20:48.360 --> 00:20:50.805
line to build client
libraries, which can then

00:20:50.805 --> 00:20:52.860
be consumed by
your applications,

00:20:52.860 --> 00:20:57.370
either Android,
iOS, or JavaScript.

00:20:57.370 --> 00:20:59.650
All this comes with built-in
authentication support,

00:20:59.650 --> 00:21:01.275
so it's very, very
easy to use in terms

00:21:01.275 --> 00:21:02.330
of authenticating users.

00:21:05.570 --> 00:21:07.370
Cloud Endpoints look
something like this.

00:21:07.370 --> 00:21:09.250
It's very, very simple to use.

00:21:09.250 --> 00:21:10.100
You'll start off.

00:21:10.100 --> 00:21:12.410
This could be brand new code
or it could be something

00:21:12.410 --> 00:21:16.207
you've exposed already
to web based users,

00:21:16.207 --> 00:21:18.040
and now you want to
expose it as an API that

00:21:18.040 --> 00:21:21.800
can be consumed directly from
another application service.

00:21:21.800 --> 00:21:25.540
So in this case we have a
method called Submit answers,

00:21:25.540 --> 00:21:29.020
and we've annotated it with a
method called at API method.

00:21:29.020 --> 00:21:33.722
Here we're actually saying we
want to use HTTP method put.

00:21:33.722 --> 00:21:35.930
Some of these things can be
inferred by the run time.

00:21:35.930 --> 00:21:40.470
If we call this method insert
answer, or something like that,

00:21:40.470 --> 00:21:43.460
then we could infer that
that would be a put.

00:21:43.460 --> 00:21:47.190
So get answers would
also be inferred

00:21:47.190 --> 00:21:48.760
that would be a get method.

00:21:48.760 --> 00:21:52.130
But we can specifically
say is in the annotation.

00:21:52.130 --> 00:21:59.150
It has very, very standard
defaults that it works with.

00:21:59.150 --> 00:22:00.760
You can also specify the path.

00:22:00.760 --> 00:22:03.120
Again, that could also be
inferred by the class name,

00:22:03.120 --> 00:22:04.600
by the method name.

00:22:04.600 --> 00:22:06.797
In this case the
path is game/id,

00:22:06.797 --> 00:22:08.255
id is a parameter
which we're going

00:22:08.255 --> 00:22:10.530
to call out later,
slash answers.

00:22:10.530 --> 00:22:12.910
That will be the path
for our RESTful call.

00:22:12.910 --> 00:22:15.460
So submit answers
is our method, it

00:22:15.460 --> 00:22:19.350
takes a couple of parameters,
three in this case, a game id

00:22:19.350 --> 00:22:22.210
answers and a user
object called player.

00:22:22.210 --> 00:22:26.680
We've annotated the
game id with a name

00:22:26.680 --> 00:22:30.370
D id to give it a
name, effectively.

00:22:30.370 --> 00:22:33.230
And that's used in the-- I
wish this had a pointer on it.

00:22:33.230 --> 00:22:37.630
And that's used in the path
in the original API method

00:22:37.630 --> 00:22:39.910
declaration.

00:22:39.910 --> 00:22:43.320
The user object itself
is injected into the call

00:22:43.320 --> 00:22:44.865
by the run time.

00:22:44.865 --> 00:22:46.490
It's not something
you need to provide.

00:22:46.490 --> 00:22:49.250
So when this method is invoked
by a user that's already

00:22:49.250 --> 00:22:52.410
logged into Google,
the logged in user

00:22:52.410 --> 00:22:55.862
will be injected into that
call, into that API call.

00:22:55.862 --> 00:22:58.320
Then we can actually check to
see if the user is logged in.

00:22:58.320 --> 00:23:00.549
If the user recall is
no, we can throw out

00:23:00.549 --> 00:23:02.590
an unauthorized exception
saying this user is not

00:23:02.590 --> 00:23:04.290
authorized to use this method.

00:23:04.290 --> 00:23:07.960
Effectively it would require it
to be logged in at that point.

00:23:07.960 --> 00:23:09.900
Then we can call
gameservice.submitanswers,

00:23:09.900 --> 00:23:13.010
which is some other abstraction
we've built somewhere else.

00:23:13.010 --> 00:23:14.960
When it comes to actually
calling this method

00:23:14.960 --> 00:23:17.180
from within an
Android application,

00:23:17.180 --> 00:23:19.910
we would build a client
library from this code.

00:23:19.910 --> 00:23:21.260
It's very easy to do.

00:23:21.260 --> 00:23:23.420
There's [INAUDIBLE], as
I say, in Android Studio.

00:23:23.420 --> 00:23:26.500
You can just say build
Cloud Endpoints client

00:23:26.500 --> 00:23:31.680
library, same
thing with Eclipse.

00:23:31.680 --> 00:23:34.490
And once you have that, you
can build your application

00:23:34.490 --> 00:23:36.225
around that client library.

00:23:36.225 --> 00:23:37.860
And effectively,
what you would do

00:23:37.860 --> 00:23:40.369
is you would call
service.gameendpoint.

00:23:40.369 --> 00:23:42.410
That would give you give
you the endpoint itself,

00:23:42.410 --> 00:23:44.280
but you can consume
within the application,

00:23:44.280 --> 00:23:46.200
and then you'd call
submit answers on that.

00:23:46.200 --> 00:23:48.945
So service.gameendpoint
effectively represents

00:23:48.945 --> 00:23:51.910
the client library, the
[INAUDIBLE] client library

00:23:51.910 --> 00:23:55.470
which will make the
call to the API.

00:23:55.470 --> 00:23:58.259
And in terms of tooling, that
looks something like this.

00:23:58.259 --> 00:23:59.800
This is a little
bit out of date now,

00:23:59.800 --> 00:24:02.436
but we have tools
in the command line.

00:24:02.436 --> 00:24:03.810
We have this tool
called G Cloud,

00:24:03.810 --> 00:24:07.440
the cloud SDK that can call
out these methods for you.

00:24:07.440 --> 00:24:09.810
And here, on the top line,
we see the client library

00:24:09.810 --> 00:24:10.787
being generated.

00:24:10.787 --> 00:24:12.870
And you can also do the
same thing with an Eclipse

00:24:12.870 --> 00:24:16.677
and with an Android Studio.

00:24:16.677 --> 00:24:19.010
Compute Engine offers virtual
machines and block storage

00:24:19.010 --> 00:24:20.156
in the Cloud.

00:24:20.156 --> 00:24:22.030
It also offers low
balance in the networking.

00:24:22.030 --> 00:24:23.770
All of the compute
resources you need

00:24:23.770 --> 00:24:25.432
to build clusters in machines.

00:24:25.432 --> 00:24:27.640
And there's going to be some
announcements today that

00:24:27.640 --> 00:24:29.848
are actually going to put
a new spin on this as well.

00:24:29.848 --> 00:24:31.040
It's also cost effective.

00:24:31.040 --> 00:24:32.370
A sub hour billing.

00:24:32.370 --> 00:24:35.060
You only pay for--
You pay always

00:24:35.060 --> 00:24:37.227
for 10 minutes of your usage
of the virtual machine,

00:24:37.227 --> 00:24:39.268
but beyond 10 minutes you
only pay by the minute.

00:24:39.268 --> 00:24:41.320
So if you use a virtual
machine for 15 minutes,

00:24:41.320 --> 00:24:44.220
you'll pay for 15
minutes, not for an hour.

00:24:44.220 --> 00:24:46.710
That's extremely cost efficient.

00:24:46.710 --> 00:24:50.710
We also do not charge IOPS
charges for block storage.

00:24:50.710 --> 00:24:52.330
Every machine needs
block storage.

00:24:52.330 --> 00:24:54.420
Every virtual machine
needs block storage,

00:24:54.420 --> 00:24:59.380
and we do not charge for IOPS
to you block storage devices.

00:24:59.380 --> 00:25:02.620
So you effectively just
pay by the terabyte.

00:25:02.620 --> 00:25:05.330
And we don't need to
provide virtual machines

00:25:05.330 --> 00:25:06.247
for load balancing.

00:25:06.247 --> 00:25:08.080
Load balancing is
actually effectively built

00:25:08.080 --> 00:25:10.410
into our network infrastructure.

00:25:10.410 --> 00:25:11.970
It's also consistently fast.

00:25:11.970 --> 00:25:14.050
We have very fast
instance provisioning.

00:25:14.050 --> 00:25:17.226
We can bring up 1,000 virtual
machines in under two minutes.

00:25:17.226 --> 00:25:18.600
I was going to do
a demo of this,

00:25:18.600 --> 00:25:20.891
but decided not to because
we have this big event going

00:25:20.891 --> 00:25:24.990
on today, and if I did something
that inadvertently caused

00:25:24.990 --> 00:25:27.070
our cloud platform some
issues I would probably

00:25:27.070 --> 00:25:28.450
get it in the neck.

00:25:28.450 --> 00:25:30.060
So I'm not going to do the demo.

00:25:30.060 --> 00:25:33.450
Normally we do this demo that
shows 1,000 machines being spun

00:25:33.450 --> 00:25:38.780
up in about one minute 30
seconds, one minute 45 seconds.

00:25:38.780 --> 00:25:41.390
Consistent disk performance is
extremely important as well,

00:25:41.390 --> 00:25:43.660
because if you run an
application in the Cloud

00:25:43.660 --> 00:25:46.090
you want to avoid this
noisy neighbor problem.

00:25:46.090 --> 00:25:48.340
You want to avoid the
operations that somebody else is

00:25:48.340 --> 00:25:49.860
performing affecting yours.

00:25:49.860 --> 00:25:52.230
So we have very consistent
disk performance.

00:25:52.230 --> 00:25:57.011
Also our Cloud native load
balancing requires no warm ups.

00:25:57.011 --> 00:26:00.250
Most load balancing services
require a warm up period.

00:26:00.250 --> 00:26:01.260
Ours is instantly on.

00:26:01.260 --> 00:26:05.650
As soon as you start using it,
it will be available to you.

00:26:05.650 --> 00:26:09.145
A Google BigQuery, we talked
about that quite a bit

00:26:09.145 --> 00:26:12.967
already, but effectively
import data into BigQuery.

00:26:12.967 --> 00:26:14.800
Once you had the data
imported into BigQuery

00:26:14.800 --> 00:26:17.500
you can run queries
interactively

00:26:17.500 --> 00:26:19.904
or fire an API across that data.

00:26:19.904 --> 00:26:21.820
And that allows you to
ask important questions

00:26:21.820 --> 00:26:22.760
of the data.

00:26:22.760 --> 00:26:24.520
If it's gaming data
you're looking at,

00:26:24.520 --> 00:26:28.370
you could be interested in
things like daily active users.

00:26:28.370 --> 00:26:29.429
What is the user doing?

00:26:29.429 --> 00:26:31.470
How is the user interacting
with the application?

00:26:31.470 --> 00:26:32.395
What can I do?

00:26:32.395 --> 00:26:35.290
What actions can I take
in order to improve

00:26:35.290 --> 00:26:37.810
the experience for the
user, for the player?

00:26:37.810 --> 00:26:40.940
And what you would do
is you would constantly

00:26:40.940 --> 00:26:43.170
run these analytics
on a daily basis,

00:26:43.170 --> 00:26:46.690
getting graphs and
charts, automatic based

00:26:46.690 --> 00:26:49.530
analysis of these interactions.

00:26:49.530 --> 00:26:50.940
Sending them offers
and such like

00:26:50.940 --> 00:26:53.050
at certain points in
their user experience

00:26:53.050 --> 00:26:56.620
to try to get to
use the game more.

00:26:56.620 --> 00:26:58.390
It's extremely affordable.

00:26:58.390 --> 00:27:00.020
You'll see more
about this later.

00:27:00.020 --> 00:27:02.635
First 100 gigabytes
per month are free.

00:27:02.635 --> 00:27:04.295
We have a very
simple pricing model,

00:27:04.295 --> 00:27:06.980
and we have a validator that
tells you the size of a query

00:27:06.980 --> 00:27:08.770
when you run it,
so you can actually

00:27:08.770 --> 00:27:11.330
predict how much
a query will cost.

00:27:11.330 --> 00:27:14.590
It's extremely easy to use, it's
built for scaling performance.

00:27:14.590 --> 00:27:15.920
Very simple SQL queries.

00:27:15.920 --> 00:27:18.450
And it has open interfaces
for REST and JDBC.

00:27:21.110 --> 00:27:22.950
In terms of what we're
going to announce

00:27:22.950 --> 00:27:26.330
today, is something
called Manage vMs.

00:27:26.330 --> 00:27:29.480
This has been available in
[INAUDIBLE] for some time now.

00:27:29.480 --> 00:27:31.295
It used to be
called vM run times.

00:27:31.295 --> 00:27:32.920
What we're trying to
do here is to blur

00:27:32.920 --> 00:27:35.336
the lines between infrastructure
as a service and platform

00:27:35.336 --> 00:27:37.784
as a service, so it's no
longer a binary choice for you.

00:27:37.784 --> 00:27:39.200
So you don't
actually have to make

00:27:39.200 --> 00:27:42.110
a choice between infrastructure
or platform as a service.

00:27:42.110 --> 00:27:45.864
You can choose one and a
move towards the other.

00:27:45.864 --> 00:27:47.530
This is facilitated
by this thing called

00:27:47.530 --> 00:27:50.310
manage virtual machines,
which effectively allows

00:27:50.310 --> 00:27:52.770
you to use App Engine
as your front end

00:27:52.770 --> 00:27:56.130
but to use Compute Engine
virtual machines as back ends.

00:27:56.130 --> 00:27:58.490
Back end modules effectively
of your application

00:27:58.490 --> 00:28:00.472
that can run anything you like.

00:28:00.472 --> 00:28:02.180
So we talked about
platform as a service,

00:28:02.180 --> 00:28:06.510
App Engine we know to run
Go, Java, PHP, and Python.

00:28:06.510 --> 00:28:09.190
But what happens if you
want to run node.js.

00:28:09.190 --> 00:28:11.390
So you can run that on
infrastructure as a service,

00:28:11.390 --> 00:28:14.060
on Compute Engine, but
still have App Engine manage

00:28:14.060 --> 00:28:15.784
those virtual machines for you.

00:28:15.784 --> 00:28:18.200
So that's effectively blurring
the lines between platforms

00:28:18.200 --> 00:28:20.075
as a service and
infrastructure as a service.

00:28:22.456 --> 00:28:23.830
So again, going
into more details

00:28:23.830 --> 00:28:26.121
about how you would choose,
infrastructure as a service

00:28:26.121 --> 00:28:28.770
has its sweet spots,
compute workloads,

00:28:28.770 --> 00:28:32.180
or do MapReduces,
those kinds of things.

00:28:32.180 --> 00:28:34.560
Running simulations, running
Monte Carlo simulations,

00:28:34.560 --> 00:28:37.390
running complex workloads.

00:28:37.390 --> 00:28:39.840
Platform as a service is
great for game back ends,

00:28:39.840 --> 00:28:42.510
mobile back ends, web
type workloads, things

00:28:42.510 --> 00:28:46.570
where load is unpredictable
where you require auto scaling.

00:28:46.570 --> 00:28:48.904
Both of them work brilliantly
for background processing.

00:28:48.904 --> 00:28:51.403
You can do background processing
with platform as a service,

00:28:51.403 --> 00:28:53.010
or with infrastructure
as a service.

00:28:53.010 --> 00:28:57.385
But when it comes to things
like running node.js,

00:28:57.385 --> 00:28:59.670
you need V to access
your virtual machines.

00:28:59.670 --> 00:29:01.750
You have C++ libraries
you want to run,

00:29:01.750 --> 00:29:04.165
you want to run web sockets,
then you're going to need

00:29:04.165 --> 00:29:05.880
to move to infrastructure
as a service.

00:29:05.880 --> 00:29:09.787
So manage virtual machines
allows you to do both

00:29:09.787 --> 00:29:11.620
and fills in that gap
between infrastructure

00:29:11.620 --> 00:29:15.210
as a service and
platform as a service.

00:29:15.210 --> 00:29:18.191
So a complex app architecture
would look something like this.

00:29:18.191 --> 00:29:19.940
We have all these
services at the top here

00:29:19.940 --> 00:29:21.210
which are App Engine services.

00:29:21.210 --> 00:29:25.140
The Datastore, Memcache, we
have things like task queues,

00:29:25.140 --> 00:29:29.930
full search API, mail
service, Cloud storage API.

00:29:29.930 --> 00:29:31.070
Then we have modules.

00:29:31.070 --> 00:29:33.035
We have two App Engine modules.

00:29:33.035 --> 00:29:36.920
And App Engine is
completely modular now.

00:29:36.920 --> 00:29:39.600
We have two App Engine modules,
service and web traffic.

00:29:39.600 --> 00:29:41.190
These are auto scale modules.

00:29:41.190 --> 00:29:44.671
They have the ability to auto
scale to meet user demand.

00:29:44.671 --> 00:29:46.420
But over here we also
have another module,

00:29:46.420 --> 00:29:50.310
which is a vM based back end
module, a managed vM model

00:29:50.310 --> 00:29:54.100
that we built using the
infrastructure as a service

00:29:54.100 --> 00:29:55.390
virtual machines.

00:29:55.390 --> 00:29:57.560
That gives us full access
to the App Engine APIs,

00:29:57.560 --> 00:29:59.768
but it gives us full control
of the virtual machines.

00:30:02.582 --> 00:30:04.290
There's just one thing
I want to mention.

00:30:04.290 --> 00:30:05.831
I added this slide
at the last minute

00:30:05.831 --> 00:30:07.860
because I realized
I left it out.

00:30:07.860 --> 00:30:10.690
It's the ability to
do vM orchestration.

00:30:10.690 --> 00:30:14.190
So App Engine can manage
infrastructure as a service

00:30:14.190 --> 00:30:17.450
virtual machines
directly through an API.

00:30:17.450 --> 00:30:20.560
So Compute Engine
itself has its own API.

00:30:20.560 --> 00:30:25.100
We can use App Engine to spin
up new instances on demand,

00:30:25.100 --> 00:30:27.240
effectively to managing
auto scale for us.

00:30:27.240 --> 00:30:29.990
So if we have a game
that requires back

00:30:29.990 --> 00:30:34.780
end gaming service, we need
to provision more service

00:30:34.780 --> 00:30:36.340
as the load increases.

00:30:36.340 --> 00:30:38.710
Then we can use vM
orchestration on App Engine

00:30:38.710 --> 00:30:44.620
to actually fire up new servers,
new game servers, on demand.

00:30:44.620 --> 00:30:47.330
In this case, the example
shows a heartbeat process

00:30:47.330 --> 00:30:51.580
with DVM orchestration service
actually checking the heartbeat

00:30:51.580 --> 00:30:55.300
process, looking at how busy
that particular server is,

00:30:55.300 --> 00:30:57.690
and making decisions on
when to spin up new servers

00:30:57.690 --> 00:30:59.820
or when to bring servers down.

00:30:59.820 --> 00:31:01.960
This is a reasonably
complicated architecture,

00:31:01.960 --> 00:31:04.242
and it's one sample
application we

00:31:04.242 --> 00:31:05.700
have published on
cloud.google.com.

00:31:10.260 --> 00:31:11.760
Again, in terms
of gaming we have

00:31:11.760 --> 00:31:14.940
all of these amazing studios
using our cloud platform,

00:31:14.940 --> 00:31:20.375
including Rovio, Gamesys,
Chillingo, and also Song Pop.

00:31:20.375 --> 00:31:22.660
So Song Pop basically
built their game

00:31:22.660 --> 00:31:25.412
with just three or four
developers on a project.

00:31:25.412 --> 00:31:27.870
They didn't need to worry about
building an infrastructure.

00:31:27.870 --> 00:31:30.320
They're now up to one
million daily plays already.

00:31:30.320 --> 00:31:32.670
Well, they were up to 1
million daily players already

00:31:32.670 --> 00:31:34.960
at two weeks after launch.

00:31:34.960 --> 00:31:38.110
Now I think they're
at about 2.4 million.

00:31:38.110 --> 00:31:40.955
They serve effectively
about 18 terabytes a day

00:31:40.955 --> 00:31:45.160
to 80 million users.

00:31:45.160 --> 00:31:48.640
There was a talk, I/O
2013 talk, Google Air,

00:31:48.640 --> 00:31:51.460
called intense gaming that
went into this in more detail.

00:31:54.980 --> 00:31:57.890
In order to get started with
the Google Cloud Platform,

00:31:57.890 --> 00:32:01.280
it's completely free
for using App Engine.

00:32:01.280 --> 00:32:03.480
We can give you
credits for startups,

00:32:03.480 --> 00:32:06.340
if you're a startup we
can give you credit packs.

00:32:06.340 --> 00:32:08.320
Documentation and
tutorials are available

00:32:08.320 --> 00:32:09.680
on developers.google.com.

00:32:09.680 --> 00:32:12.302
In this case it's just
for App Engine itself.

00:32:12.302 --> 00:32:14.010
If you're interested
in the starter pack,

00:32:14.010 --> 00:32:15.435
you have the little cards.

00:32:15.435 --> 00:32:17.890
You can claim those credits
and use that code there,

00:32:17.890 --> 00:32:18.390
dsummit-con.

00:32:21.860 --> 00:32:22.360
That's it.

00:32:22.360 --> 00:32:24.151
So I think we're out
of time for questions.

00:32:24.151 --> 00:32:26.200
So if you want to
catch me at lunch time

00:32:26.200 --> 00:32:28.400
if you have any
questions-- yeah?

00:32:28.400 --> 00:32:29.290
You sure?

00:32:29.290 --> 00:32:29.790
OK.

00:32:29.790 --> 00:32:29.950
Yeah.

00:32:29.950 --> 00:32:30.900
So, any questions?

00:32:33.314 --> 00:32:35.480
AUDIENCE: Can we grab the
microphones for questions,

00:32:35.480 --> 00:32:37.640
because they're being
recorded as well.

00:32:37.640 --> 00:32:38.330
Thank you.

00:32:38.330 --> 00:32:39.746
AUDIENCE: Do you
have your service

00:32:39.746 --> 00:32:41.200
running in China as well?

00:32:41.200 --> 00:32:42.960
MANDY WAITE: Running in China?

00:32:42.960 --> 00:32:43.650
AUDIENCE: Yeah.

00:32:43.650 --> 00:32:46.500
MANDY WAITE: Well, I don't think
we have a data center in China.

00:32:46.500 --> 00:32:48.210
We have a data center in Taiwan.

00:32:50.930 --> 00:32:52.680
AUDIENCE: It might be
an opportunity then.

00:32:52.680 --> 00:32:54.640
MANDY WAITE: Is that something
you're interested in?

00:32:54.640 --> 00:32:55.223
AUDIENCE: Yes.

00:32:55.223 --> 00:33:00.827
MANDY WAITE: So you have
game users in China?

00:33:00.827 --> 00:33:01.410
AUDIENCE: Yes.

00:33:01.410 --> 00:33:01.520
MANDY WAITE: OK.

00:33:01.520 --> 00:33:02.020
Right.

00:33:02.020 --> 00:33:05.160
So what are you using currently?

00:33:05.160 --> 00:33:07.580
AUDIENCE: We're building
up our own infrastructure.

00:33:07.580 --> 00:33:09.510
MANDY WAITE: You're building
up your own infrastructure.

00:33:09.510 --> 00:33:10.760
AUDIENCE: Amazon has
said that they're

00:33:10.760 --> 00:33:12.230
doing something
in China as well,

00:33:12.230 --> 00:33:13.896
but they're working
with local services,

00:33:13.896 --> 00:33:17.300
so it's not the same as
what they do in the West.

00:33:17.300 --> 00:33:20.030
It's actually trying to find
out together with Chinese people

00:33:20.030 --> 00:33:24.430
and trying to mirror
what we have over here.

00:33:24.430 --> 00:33:27.250
It's a huge cost to build
up your own data center.

00:33:27.250 --> 00:33:30.240
It's a lot of work
we shouldn't be

00:33:30.240 --> 00:33:33.580
doing because we
need to create games.

00:33:33.580 --> 00:33:36.000
MANDY WAITE: So again, maybe
watch for announcements today

00:33:36.000 --> 00:33:38.410
at the live event to see
what we're going to announce,

00:33:38.410 --> 00:33:40.909
but we don't have any data
centers in China at the moment.

00:33:40.909 --> 00:33:41.450
You're right.

00:33:41.450 --> 00:33:42.580
It's a huge place,
and it would be

00:33:42.580 --> 00:33:43.950
great to have data
centers there,

00:33:43.950 --> 00:33:45.950
but maybe there are some
concerns about security

00:33:45.950 --> 00:33:47.715
and such like as well.

00:33:47.715 --> 00:33:48.340
AUDIENCE: Cool.

00:33:48.340 --> 00:33:48.720
Thanks.

00:33:48.720 --> 00:33:49.553
MANDY WAITE: Cheers.

00:33:49.553 --> 00:33:50.126
Thanks.

00:33:50.126 --> 00:33:51.000
Any more questions?

00:33:54.000 --> 00:33:54.610
OK.

00:33:54.610 --> 00:33:57.010
Right.

00:33:57.010 --> 00:33:57.540
One more.

00:34:03.806 --> 00:34:06.305
AUDIENCE: I was interested to
hear a bit more about the auto

00:34:06.305 --> 00:34:09.620
scaling that you
mentioned, which

00:34:09.620 --> 00:34:13.360
was about scaling
up and conversely

00:34:13.360 --> 00:34:17.190
scaling down on demand.

00:34:17.190 --> 00:34:19.710
Can you run through that
again, because that's

00:34:19.710 --> 00:34:21.414
what's most interesting to us.

00:34:21.414 --> 00:34:22.080
MANDY WAITE: OK.

00:34:22.080 --> 00:34:24.082
So when it comes to
App Engine, App Engine

00:34:24.082 --> 00:34:26.290
has this thing called auto
scale, the ability to auto

00:34:26.290 --> 00:34:29.610
scale, based on a very
complicated algorithm,

00:34:29.610 --> 00:34:31.310
effectively able
to monitor traffic.

00:34:31.310 --> 00:34:33.260
When a new request
comes in, it will say,

00:34:33.260 --> 00:34:36.489
do I have an instance available
to service that request?

00:34:36.489 --> 00:34:40.600
Do I have a parameter set in
called pending queue latency

00:34:40.600 --> 00:34:43.590
that will tell me how
long that request should

00:34:43.590 --> 00:34:44.987
sit in the queue?

00:34:44.987 --> 00:34:46.820
If it's going to sit
in the queue for longer

00:34:46.820 --> 00:34:49.320
than that time, based
on my algorithm,

00:34:49.320 --> 00:34:52.409
I can spin up a new instance
to service that request.

00:34:52.409 --> 00:34:54.022
But then maybe there's
an issue, maybe

00:34:54.022 --> 00:34:55.730
it takes too long to
spin up an instance.

00:34:55.730 --> 00:34:57.120
So you have these things
called idle instances

00:34:57.120 --> 00:34:58.600
as well that can
service requests

00:34:58.600 --> 00:35:00.990
that can't be serviced
by an instance currently.

00:35:00.990 --> 00:35:03.573
So effectively what we have is
the algorithm that will spin up

00:35:03.573 --> 00:35:06.030
instances on demand,
will queue requests

00:35:06.030 --> 00:35:08.640
for a given amount of time,
based on your parameters,

00:35:08.640 --> 00:35:10.240
and we have idle
instances that can

00:35:10.240 --> 00:35:12.323
be used to service requests
that can't be serviced

00:35:12.323 --> 00:35:15.050
by anything else very quickly.

00:35:15.050 --> 00:35:16.870
So that's effectively
how auto scale works.

00:35:16.870 --> 00:35:18.810
The instances come
up very quickly,

00:35:18.810 --> 00:35:20.790
and they scale down
very quickly as well.

00:35:20.790 --> 00:35:22.120
There's no timeout period.

00:35:22.120 --> 00:35:24.700
We look constantly on the
load, on the machines,

00:35:24.700 --> 00:35:26.660
on their pending queues
on each instance.

00:35:26.660 --> 00:35:29.110
And if we see that there's
no jobs queued for them,

00:35:29.110 --> 00:35:31.990
we'll tear them down once
the current job is finished.

00:35:31.990 --> 00:35:33.160
So it's very efficient.

00:35:33.160 --> 00:35:36.550
We have the ability to
scale up very quickly

00:35:36.550 --> 00:35:38.798
and to scale down
very quickly as well.

00:35:38.798 --> 00:35:39.740
Does that make sense?

00:35:39.740 --> 00:35:40.233
AUDIENCE: Yes.

00:35:40.233 --> 00:35:40.899
MANDY WAITE: OK.

00:35:40.899 --> 00:35:42.500
Cool.

00:35:42.500 --> 00:35:43.000
OK.

00:35:43.000 --> 00:35:44.074
So good.

00:35:44.074 --> 00:35:44.740
Thank you, Rich.

00:35:44.740 --> 00:35:45.573
Thanks for the time.

00:35:45.573 --> 00:35:47.170
MALE SPEAKER: Thanks
very much, Mandy.

