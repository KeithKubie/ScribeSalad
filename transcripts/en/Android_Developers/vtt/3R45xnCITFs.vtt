WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.959
[MUSIC PLAYING]

00:00:03.959 --> 00:00:05.000
CHET HAASE: Good morning.

00:00:05.000 --> 00:00:08.730
And welcome to Android
for Java Developers.

00:00:08.730 --> 00:00:13.470
This talk is a wrap around a
series of very long articles

00:00:13.470 --> 00:00:15.790
that I hope everyone
will read eventually,

00:00:15.790 --> 00:00:17.040
called Developing for Android.

00:00:17.040 --> 00:00:19.360
So if you go to medium.com
and search for that phrase,

00:00:19.360 --> 00:00:21.520
or if you just go to
the internet and search

00:00:21.520 --> 00:00:24.920
for that phrase, you'll wind up
on the series of 10 articles.

00:00:24.920 --> 00:00:28.340
These came out of an
incredibly long doc

00:00:28.340 --> 00:00:31.030
that we wrote
internally at Google,

00:00:31.030 --> 00:00:34.170
when we were faced with
a bunch of app developers

00:00:34.170 --> 00:00:36.300
we would meet with
on a regular basis.

00:00:36.300 --> 00:00:39.280
And someone said, so every time
we talk to the framework team,

00:00:39.280 --> 00:00:40.697
and we say we're
doing this thing,

00:00:40.697 --> 00:00:42.571
and then the framework
team says, no, no, no,

00:00:42.571 --> 00:00:45.040
don't do it that way, do
it this other way instead--

00:00:45.040 --> 00:00:46.460
and then they'd go away
and they'd do that.

00:00:46.460 --> 00:00:48.070
And they'd come back
with another question.

00:00:48.070 --> 00:00:50.360
And we would say, no, no,
no, you shouldn't do that.

00:00:50.360 --> 00:00:52.879
What you should actually do
is this other thing instead.

00:00:52.879 --> 00:00:55.420
And they said, OK, so where do
we go for the information that

00:00:55.420 --> 00:00:58.230
sort of collects all these tips,
and tricks, and techniques, so

00:00:58.230 --> 00:01:01.060
that we can stop getting
slapped by the platform

00:01:01.060 --> 00:01:03.660
team for the way that we're
approaching this stuff?

00:01:03.660 --> 00:01:05.470
So that was the
genesis of the article.

00:01:05.470 --> 00:01:07.810
We decided to actually take
a step back and say, OK,

00:01:07.810 --> 00:01:10.480
what are all the things
that we think are obvious,

00:01:10.480 --> 00:01:13.900
but typical Java
developers do not?

00:01:13.900 --> 00:01:17.780
And the problem is that a lot
of developers, most developers,

00:01:17.780 --> 00:01:21.600
writing Java code at Google come
from the server world, or even

00:01:21.600 --> 00:01:24.509
the desktop world, sort of
traditional Java platform.

00:01:24.509 --> 00:01:26.800
And then they say, OK, well,
this is the same language,

00:01:26.800 --> 00:01:28.970
so I'll carry over all
my patterns and practices

00:01:28.970 --> 00:01:32.800
from that other world into
this little, tiny mobile device

00:01:32.800 --> 00:01:38.100
with a constrained CPU, GPU,
memory, the limited memory,

00:01:38.100 --> 00:01:40.650
limited bandwidth, like very,
very different programming

00:01:40.650 --> 00:01:41.150
environment.

00:01:41.150 --> 00:01:43.450
Really, the only
thing that is the same

00:01:43.450 --> 00:01:46.020
is the programming
language itself.

00:01:46.020 --> 00:01:48.870
So the way that you use
that programming language

00:01:48.870 --> 00:01:51.581
is very important, in
terms of the performance

00:01:51.581 --> 00:01:53.080
and the experience
that you're going

00:01:53.080 --> 00:01:55.270
to get in the end result
of your application.

00:01:55.270 --> 00:01:57.010
So we wrote this huge article.

00:01:57.010 --> 00:01:58.210
We put it out internally.

00:01:58.210 --> 00:02:01.110
And then for the short
attention span public,

00:02:01.110 --> 00:02:04.900
we broke it into 10 still
very long articles on Medium.

00:02:04.900 --> 00:02:06.280
So please check those out.

00:02:06.280 --> 00:02:07.813
In the meantime,
I wanted to walk

00:02:07.813 --> 00:02:08.979
through some of those today.

00:02:08.979 --> 00:02:11.210
If I tried to go
through everything,

00:02:11.210 --> 00:02:13.200
this would be about
a three-hour talk.

00:02:13.200 --> 00:02:14.740
We tried this once.

00:02:14.740 --> 00:02:17.740
We gave a talk at a user
group in the Bay Area,

00:02:17.740 --> 00:02:20.900
and we put together a
version of this talk.

00:02:20.900 --> 00:02:22.830
And we made it about
a quarter of the way

00:02:22.830 --> 00:02:24.290
through in an hour
and 20 minutes.

00:02:24.290 --> 00:02:27.167
So yeah, actually, three hours
is an underestimate as well.

00:02:27.167 --> 00:02:29.750
Because each of the topics, like
they're little, tiny bullets,

00:02:29.750 --> 00:02:31.320
but they're kind
of deep crevices

00:02:31.320 --> 00:02:32.980
that you can go on
at length about.

00:02:32.980 --> 00:02:34.770
So I thought, instead
today, instead

00:02:34.770 --> 00:02:37.790
of trying and failing
to cover everything

00:02:37.790 --> 00:02:40.530
that those articles cover, I
wanted to talk about the memory

00:02:40.530 --> 00:02:42.370
situation, because a
lot of the performance

00:02:42.370 --> 00:02:45.610
concerns and a lot of the
problems that people hit

00:02:45.610 --> 00:02:48.420
are in the specific
area of memory.

00:02:48.420 --> 00:02:51.000
That's really where a lot
of the performance problems

00:02:51.000 --> 00:02:52.880
and bottlenecks
come from, partly

00:02:52.880 --> 00:02:54.900
because the runtime and
the garbage collector

00:02:54.900 --> 00:02:57.620
are vastly different than
what you might expect.

00:02:57.620 --> 00:02:59.560
So I wanted to start
out first by talking

00:02:59.560 --> 00:03:02.000
a little bit about how garbage
collection and allocation

00:03:02.000 --> 00:03:04.032
actually works on Android.

00:03:04.032 --> 00:03:06.240
And then we'll talk about
some of the tips and tricks

00:03:06.240 --> 00:03:07.320
about memory in particular.

00:03:07.320 --> 00:03:09.694
And then maybe we'll talk
about some other stuff as well.

00:03:09.694 --> 00:03:11.160
We'll see how far we get.

00:03:11.160 --> 00:03:12.690
So first of all, I
wanted to mention

00:03:12.690 --> 00:03:18.060
that one of the important things
that we see in terms of device

00:03:18.060 --> 00:03:22.550
usefulness or application
niceness is what we call,

00:03:22.550 --> 00:03:23.900
the Tragedy of the Commons.

00:03:23.900 --> 00:03:26.960
And this is an effect
where every application

00:03:26.960 --> 00:03:28.780
will work in its best interest.

00:03:28.780 --> 00:03:30.490
It will be necessarily greedy.

00:03:30.490 --> 00:03:33.020
Because obviously, if
someone has installed

00:03:33.020 --> 00:03:35.000
my video-playing
application, it's

00:03:35.000 --> 00:03:37.680
really important to
them for the user

00:03:37.680 --> 00:03:39.724
to actually watch the
videos in my application,

00:03:39.724 --> 00:03:41.140
so I'm going to
sync all the time.

00:03:41.140 --> 00:03:43.450
And I'm going to make sure they
get the most up-to-date data.

00:03:43.450 --> 00:03:45.490
And I'm going to allocate
tons and tons of memory

00:03:45.490 --> 00:03:46.335
so that I have all
the stuff cached

00:03:46.335 --> 00:03:48.250
and it's just ready
to go all the time.

00:03:48.250 --> 00:03:51.940
The fact is, the user has many,
many applications installed.

00:03:51.940 --> 00:03:53.740
Yours is one of them.

00:03:53.740 --> 00:03:55.620
And if it's too
greedy, yours will not

00:03:55.620 --> 00:03:57.660
be one of them for long, right?

00:03:57.660 --> 00:03:59.840
If every application
act in this way,

00:03:59.840 --> 00:04:02.020
and they do tend
to by default, then

00:04:02.020 --> 00:04:05.290
it makes the overall device
experience suck, right?

00:04:05.290 --> 00:04:07.700
If every application is
allocating too much memory,

00:04:07.700 --> 00:04:11.510
if it takes up too much heap,
if every process is huge,

00:04:11.510 --> 00:04:13.350
then the task manager
will continually

00:04:13.350 --> 00:04:16.079
be killing all of the
background applications

00:04:16.079 --> 00:04:17.870
in order to make the
foreground application

00:04:17.870 --> 00:04:19.800
have enough memory
to run itself.

00:04:19.800 --> 00:04:22.620
And then, when your rather
greedy and bloated application

00:04:22.620 --> 00:04:24.929
goes into the background,
and the task manager says,

00:04:24.929 --> 00:04:26.720
well, I'm running out
of memory, I'd better

00:04:26.720 --> 00:04:28.644
go look for some
large memory users,

00:04:28.644 --> 00:04:30.810
it's going to find yours,
and it's going to kill it.

00:04:30.810 --> 00:04:32.770
And the next time the
user goes back to it,

00:04:32.770 --> 00:04:35.870
it's going to have to
relaunch and do a cold start,

00:04:35.870 --> 00:04:37.460
because it was killed, right?

00:04:37.460 --> 00:04:40.010
Wouldn't it be nicer if
all the applications were

00:04:40.010 --> 00:04:43.510
more slim and trim, so that
whenever the user switches

00:04:43.510 --> 00:04:46.540
between them, they can do
so easily, because they just

00:04:46.540 --> 00:04:48.620
have to page them in,
instead of actually

00:04:48.620 --> 00:04:52.660
reloading and relaunching
everything from storage?

00:04:52.660 --> 00:04:54.700
So there's two
effects that we see.

00:04:54.700 --> 00:04:57.340
There's the tragedy
of the commons where

00:04:57.340 --> 00:04:59.080
everything is greedy,
and then there's

00:04:59.080 --> 00:05:00.520
the every device a village.

00:05:00.520 --> 00:05:03.220
So not only are all the
applications greedy,

00:05:03.220 --> 00:05:05.737
and they are suffering for it,
but then the overall device

00:05:05.737 --> 00:05:07.300
is suffering for it.

00:05:07.300 --> 00:05:09.960
Now, the user experience from
all these greedy applications

00:05:09.960 --> 00:05:12.210
on the device is that
they're constantly

00:05:12.210 --> 00:05:14.340
relaunching all of
the activities there,

00:05:14.340 --> 00:05:16.140
or some service running
in the background

00:05:16.140 --> 00:05:18.520
is syncing, causing
performance problems

00:05:18.520 --> 00:05:21.660
and the CPU to be doing things
for absolutely no reason

00:05:21.660 --> 00:05:22.380
whatsoever.

00:05:22.380 --> 00:05:24.520
I'm not using that
service right now.

00:05:24.520 --> 00:05:27.320
I haven't used that
e-reader for a month.

00:05:27.320 --> 00:05:29.440
Why is it actually
syncing in the background

00:05:29.440 --> 00:05:33.250
when I'm trying to use another
application in the foreground?

00:05:33.250 --> 00:05:35.690
So these two effects
are very interrelated

00:05:35.690 --> 00:05:38.330
and contribute to the overall
user experience of Android.

00:05:38.330 --> 00:05:42.020
So the goal of this article
and of these tips and practices

00:05:42.020 --> 00:05:44.930
in general is to help
application developers write

00:05:44.930 --> 00:05:47.930
better applications, so that we
can make the overall platform

00:05:47.930 --> 00:05:48.780
better.

00:05:48.780 --> 00:05:52.910
So let's go talk about memory.

00:05:52.910 --> 00:05:56.740
Three dynamics to be aware
of is that memory is limited.

00:05:56.740 --> 00:05:59.870
And this is far more limited
than you might realize.

00:05:59.870 --> 00:06:05.020
Living here with our less
constrained financial resources

00:06:05.020 --> 00:06:08.780
and more available technology,
we tend to think of one gig

00:06:08.780 --> 00:06:09.810
as being the low end.

00:06:09.810 --> 00:06:12.220
You know, there are devices
with two-gig or more

00:06:12.220 --> 00:06:13.190
readily available.

00:06:13.190 --> 00:06:16.100
So surely, this is what
people have in the real world.

00:06:16.100 --> 00:06:18.410
In the real world,
low-end devices

00:06:18.410 --> 00:06:20.650
are, A, still being
used, because they

00:06:20.650 --> 00:06:21.960
were sold several years ago.

00:06:21.960 --> 00:06:24.780
And people don't just
ditch devices for new ones,

00:06:24.780 --> 00:06:27.390
unless they're like the
people in this room.

00:06:27.390 --> 00:06:29.610
Maybe they don't actually
have enough money

00:06:29.610 --> 00:06:32.420
to go buy a new phone whenever
they're excited by it,

00:06:32.420 --> 00:06:34.200
so they may keep
that device around

00:06:34.200 --> 00:06:37.087
a lot longer than you, the
developer, want them to.

00:06:37.087 --> 00:06:38.920
So they're running with
a low memory device,

00:06:38.920 --> 00:06:40.378
because they bought
it a while ago.

00:06:40.378 --> 00:06:43.290
But the more
insidious dynamic is

00:06:43.290 --> 00:06:46.810
that there are still devices
being sold with low memory.

00:06:46.810 --> 00:06:50.840
In markets where money or
technology is not as readily

00:06:50.840 --> 00:06:54.530
available, they may be
selling these phones

00:06:54.530 --> 00:06:57.710
to people that are really
excited about getting

00:06:57.710 --> 00:07:00.960
this new device that only
has 512 on it, right?

00:07:00.960 --> 00:07:02.092
Not much memory.

00:07:02.092 --> 00:07:02.800
It's a new phone.

00:07:02.800 --> 00:07:04.620
What are they doing coming out
with that amount of memory?

00:07:04.620 --> 00:07:07.372
Well, this is the configuration
that made sense in that market.

00:07:07.372 --> 00:07:09.330
And there are a lot of
these phones still being

00:07:09.330 --> 00:07:10.360
sold out there.

00:07:10.360 --> 00:07:13.750
So even though you are running
a device that you don't consider

00:07:13.750 --> 00:07:16.244
high end and you think the
memory problems have gone away,

00:07:16.244 --> 00:07:17.160
they actually haven't.

00:07:17.160 --> 00:07:19.701
And they're going to be here
for a while because of those two

00:07:19.701 --> 00:07:20.400
dynamics.

00:07:20.400 --> 00:07:22.820
So it's very important
for you, the developer,

00:07:22.820 --> 00:07:25.240
to realize there are these
low memory situations

00:07:25.240 --> 00:07:27.680
and to make sure your
application behaves reasonably

00:07:27.680 --> 00:07:31.650
well when one of those
situations occurs for the user.

00:07:31.650 --> 00:07:33.920
The other issue, as
I alluded to before,

00:07:33.920 --> 00:07:35.620
is it that memory is shared.

00:07:35.620 --> 00:07:38.490
Everybody is swimming
in the same pool.

00:07:38.490 --> 00:07:41.150
I don't really
like that metaphor.

00:07:41.150 --> 00:07:45.690
So everybody has to behave, if
you want the overall experience

00:07:45.690 --> 00:07:46.220
to be good.

00:07:46.220 --> 00:07:48.890
If your application is greedy,
and every other application

00:07:48.890 --> 00:07:51.660
is greedy, the entire
experience of the device

00:07:51.660 --> 00:07:54.210
will be horrible, because
everybody is constantly

00:07:54.210 --> 00:07:57.420
going to be shoving
everybody out of CPU cycles,

00:07:57.420 --> 00:07:59.130
as well as memory.

00:07:59.130 --> 00:08:01.250
And then, finally, memory
equals performance.

00:08:01.250 --> 00:08:04.010
And this is the one I want to
spend a little bit of quality

00:08:04.010 --> 00:08:07.050
time on today and explain
what we mean by that.

00:08:07.050 --> 00:08:09.550
So first of all, let's
talk about memory.

00:08:09.550 --> 00:08:11.380
Let's talk about the
garbage collector

00:08:11.380 --> 00:08:13.620
and how it actually
works and why

00:08:13.620 --> 00:08:16.300
we see some of the
performance issues that we do.

00:08:16.300 --> 00:08:19.880
So there are three
things that cause memory

00:08:19.880 --> 00:08:24.170
to be expensive, in terms
of performance, on Android.

00:08:24.170 --> 00:08:25.850
One is the allocation,
the process

00:08:25.850 --> 00:08:29.370
of actually creating memory
for the new objects that

00:08:29.370 --> 00:08:30.740
are being allocated.

00:08:30.740 --> 00:08:32.846
The next is concurrent
collection, or just

00:08:32.846 --> 00:08:34.470
collection in general,
when we actually

00:08:34.470 --> 00:08:37.190
need to clear things out
so that we can make room

00:08:37.190 --> 00:08:39.464
for other allocations
that need to happen.

00:08:39.464 --> 00:08:41.880
And then the third tends to
be the most painful one, which

00:08:41.880 --> 00:08:43.505
is collection-for-allocation.

00:08:43.505 --> 00:08:45.005
If anybody's taken
a look at the log

00:08:45.005 --> 00:08:47.200
and looked at the GC
information in there,

00:08:47.200 --> 00:08:49.970
this is commonly referred
to as GC_FOR_ALLOC.

00:08:49.970 --> 00:08:52.520
It's a situation where you
go to allocate something,

00:08:52.520 --> 00:08:54.260
there is not a free
space in the heap.

00:08:54.260 --> 00:08:55.718
And then the garbage
collector need

00:08:55.718 --> 00:08:59.650
to run synchronously, right
then, to free up enough memory

00:08:59.650 --> 00:09:01.190
to store your object there.

00:09:01.190 --> 00:09:03.070
So let's go into some
of the details there.

00:09:03.070 --> 00:09:07.020
We can see the four phases
of normal allocations

00:09:07.020 --> 00:09:07.800
and collections.

00:09:07.800 --> 00:09:10.390
Here, you have this
new object on the left,

00:09:10.390 --> 00:09:12.290
next to the squiggles.

00:09:12.290 --> 00:09:13.810
And we need to find
space for that.

00:09:13.810 --> 00:09:15.684
Oh, fortunately, there's
a space right there.

00:09:15.684 --> 00:09:17.280
We'll pop it in at the top.

00:09:17.280 --> 00:09:18.940
This is an unusual
situation where

00:09:18.940 --> 00:09:20.760
it was really easy to do that.

00:09:20.760 --> 00:09:23.470
So once that's there, then
we enumerate all the objects

00:09:23.470 --> 00:09:25.740
to figure out what's still
refer to in the heap.

00:09:25.740 --> 00:09:28.031
You can see the red one
doesn't have a reference there.

00:09:28.031 --> 00:09:30.500
We mark all of
those, to make sure

00:09:30.500 --> 00:09:32.700
that we know what things
are still referred to

00:09:32.700 --> 00:09:34.450
and what things can
actually be collected.

00:09:34.450 --> 00:09:35.329
And then we collect.

00:09:35.329 --> 00:09:37.120
And you see the red
object goes away there,

00:09:37.120 --> 00:09:38.950
because there was
no reference to it.

00:09:38.950 --> 00:09:42.640
So we can collect that now
and free up space in the heap.

00:09:42.640 --> 00:09:45.600
So on Dalvik, there's
actually two pause times

00:09:45.600 --> 00:09:48.580
that occur in the
normal process of simply

00:09:48.580 --> 00:09:49.710
allocating and collecting.

00:09:49.710 --> 00:09:51.500
There's a pause
time to enumerate.

00:09:51.500 --> 00:09:54.050
So we basically stop
the world, the GC thread

00:09:54.050 --> 00:09:55.980
runs alone in the process.

00:09:55.980 --> 00:09:58.980
Everything else is paused,
while it figures out

00:09:58.980 --> 00:10:02.180
what the things are in the heap
during the enumeration phase.

00:10:02.180 --> 00:10:04.880
And then there's the mark
phase at the end of that.

00:10:04.880 --> 00:10:08.450
So it it'll mark all the
things, to figure out what

00:10:08.450 --> 00:10:10.210
doesn't have a reference there.

00:10:10.210 --> 00:10:12.830
And then it needs to run
one smaller mark phase

00:10:12.830 --> 00:10:14.980
at the end of that, in
case there were allocations

00:10:14.980 --> 00:10:17.677
while that concurrent
marking was going on.

00:10:17.677 --> 00:10:19.010
And there's another pause there.

00:10:19.010 --> 00:10:20.650
So there's a large
pause, potentially,

00:10:20.650 --> 00:10:22.000
in the enumeration phase.

00:10:22.000 --> 00:10:24.880
And then there's a smaller pause
at the end of the mark phase.

00:10:24.880 --> 00:10:26.338
And then it can
collect everything.

00:10:26.338 --> 00:10:28.880
And it does that concurrently.

00:10:28.880 --> 00:10:30.690
In ART, it's a
little bit different.

00:10:30.690 --> 00:10:33.830
We eliminated the first pause,
so there's no synchronous pause

00:10:33.830 --> 00:10:35.090
during the enumeration phase.

00:10:35.090 --> 00:10:36.370
It can do that concurrently.

00:10:36.370 --> 00:10:38.970
There is still a small pause
at the end of the mark phase.

00:10:38.970 --> 00:10:40.720
It's a little bit
smaller, because there's

00:10:40.720 --> 00:10:42.880
been a lot of
optimization work going

00:10:42.880 --> 00:10:44.350
into the collector in ART.

00:10:44.350 --> 00:10:47.070
So it's better in ART, but
we still have a pause there.

00:10:47.070 --> 00:10:49.496
And I should point out,
too, that even when

00:10:49.496 --> 00:10:50.870
there's not a
pause here, there's

00:10:50.870 --> 00:10:52.500
still stuff happening, right?

00:10:52.500 --> 00:10:56.760
So all of this is causing CPU
to do things in the background,

00:10:56.760 --> 00:10:59.760
whether it's-- I just turned
on the audio on my screen,

00:10:59.760 --> 00:11:05.970
so look out-- even if it
can happen concurrently,

00:11:05.970 --> 00:11:07.620
it still means it's
happening, right?

00:11:07.620 --> 00:11:09.760
You're still taking up
cycles to do these things.

00:11:09.760 --> 00:11:11.910
And in general, it's good
to not spend the cycles,

00:11:11.910 --> 00:11:13.270
if you don't have to.

00:11:13.270 --> 00:11:16.780
OK, so now, let's talk about
the one that's more problematic.

00:11:16.780 --> 00:11:19.590
This is the
GC_FOR_ALLOC situation

00:11:19.590 --> 00:11:22.427
where a new object comes in,
and we pop that onto the heap.

00:11:22.427 --> 00:11:24.760
And then another one comes
in, and we walk down the heap

00:11:24.760 --> 00:11:28.060
and we look for space in
there, and there is no space.

00:11:28.060 --> 00:11:30.810
And then we have to actually
run a GC synchronously.

00:11:30.810 --> 00:11:32.080
We stop the world.

00:11:32.080 --> 00:11:34.820
So we've got a huge
pause in the middle,

00:11:34.820 --> 00:11:36.890
while we actually go
and free up the stuff

00:11:36.890 --> 00:11:39.110
that we need to in order
to fit this into the heap.

00:11:39.110 --> 00:11:41.651
And then we can put it in there
and go on about our business.

00:11:41.651 --> 00:11:44.640
And the GC_FOR_ALLOC tends to be
painful both in terms of time--

00:11:44.640 --> 00:11:47.870
on Dalvik, this can take 10
to 20 milliseconds, which

00:11:47.870 --> 00:11:50.130
is easily more than a frame.

00:11:50.130 --> 00:11:52.190
So you're going to
potentially skip

00:11:52.190 --> 00:11:55.440
an animation frame in the
middle and cause a hiccup.

00:11:55.440 --> 00:11:59.910
And then they're-- I totally
lost my train of thought.

00:12:02.460 --> 00:12:03.470
Yeah.

00:12:03.470 --> 00:12:04.690
Just gone.

00:12:04.690 --> 00:12:07.260
It turns out you
should sleep at night.

00:12:07.260 --> 00:12:10.471
So it also means that
none of your other stuff

00:12:10.471 --> 00:12:11.220
is running, right?

00:12:11.220 --> 00:12:12.500
So it's just going to
pause in the middle.

00:12:12.500 --> 00:12:14.500
It's going to do all this
work, and nothing else

00:12:14.500 --> 00:12:15.930
can happen at the same time.

00:12:15.930 --> 00:12:18.760
So in general, that's a
good thing to try to avoid.

00:12:18.760 --> 00:12:20.250
ART makes this a
little bit better.

00:12:20.250 --> 00:12:22.360
No, a lot better, because
it has a separate heap

00:12:22.360 --> 00:12:23.520
for large objects.

00:12:23.520 --> 00:12:27.720
One of the causes of having
to do too many collections

00:12:27.720 --> 00:12:30.520
was that all of the objects
were stored together.

00:12:30.520 --> 00:12:33.140
So you'd have these little,
tiny temporary objects,

00:12:33.140 --> 00:12:36.364
new object, or float,
or integer, or whatever.

00:12:36.364 --> 00:12:38.780
And then you'd have this bitmap
taking up a massive amount

00:12:38.780 --> 00:12:40.290
of space in the middle.

00:12:40.290 --> 00:12:43.610
And it would cause the heap to
get really large-- the amount

00:12:43.610 --> 00:12:46.560
of space that would have to
be walked-- to be really big,

00:12:46.560 --> 00:12:51.250
and the fragmentation issues
to be much greater in the heap.

00:12:51.250 --> 00:12:53.897
And now, ART takes all the
large objects, all the bitmaps--

00:12:53.897 --> 00:12:56.230
and they live in a separate
piece of memory over there--

00:12:56.230 --> 00:12:57.660
so all the big
ones go out there.

00:12:57.660 --> 00:13:02.200
All the little, more temporary
objects go in the main heap.

00:13:02.200 --> 00:13:04.830
And it means that there
are far less pauses.

00:13:04.830 --> 00:13:07.770
It means also that the
pauses are much smaller.

00:13:07.770 --> 00:13:09.780
So whereas, the
previous Dalvik pauses

00:13:09.780 --> 00:13:12.370
may have been on the order
of 10 to 20 milliseconds,

00:13:12.370 --> 00:13:15.785
now we see pauses of
three to 5 milliseconds,

00:13:15.785 --> 00:13:16.660
which is much better.

00:13:16.660 --> 00:13:19.485
It's way under the frame
boundary limit, which is great.

00:13:19.485 --> 00:13:20.860
But it's still
significant enough

00:13:20.860 --> 00:13:23.640
that it can push you over the
frame boundary limit anyway,

00:13:23.640 --> 00:13:26.650
so it's still good
thing to avoid.

00:13:26.650 --> 00:13:28.870
Meanwhile, while
all this churning

00:13:28.870 --> 00:13:31.250
is going on of actually
allocating objects, needing

00:13:31.250 --> 00:13:34.110
to collect them to free
up the space for them,

00:13:34.110 --> 00:13:35.600
you're also growing your heaps.

00:13:35.600 --> 00:13:39.390
So the more allocations
you're asking for,

00:13:39.390 --> 00:13:43.014
the more you're causing
the heap to grow over time.

00:13:43.014 --> 00:13:44.930
So if you just allocate
more and more objects,

00:13:44.930 --> 00:13:46.960
eventually the heap is going
to say, well, I'm out of room.

00:13:46.960 --> 00:13:48.793
But you're not up to
your process limit yet,

00:13:48.793 --> 00:13:49.970
so I'll grow the heap there.

00:13:49.970 --> 00:13:53.395
And so it will go through, A,
the work to do that, and B,

00:13:53.395 --> 00:13:55.570
it'll take up more
memory on the device

00:13:55.570 --> 00:13:57.670
to allocate that larger heap.

00:13:57.670 --> 00:14:01.849
And larger heap means, now,
your task, your process,

00:14:01.849 --> 00:14:02.890
is taking up more memory.

00:14:02.890 --> 00:14:05.850
There's less available for
the rest of the system.

00:14:05.850 --> 00:14:09.570
And you're also
causing your app to be

00:14:09.570 --> 00:14:12.430
killed, because you're going
to be taking up more space.

00:14:12.430 --> 00:14:15.654
When the task manager is looking
for background apps to kill,

00:14:15.654 --> 00:14:17.070
it's going to look
for large ones,

00:14:17.070 --> 00:14:21.520
because that's a lot of memory
that it could take back.

00:14:21.520 --> 00:14:25.630
An important point to note about
this is that, under Dalvik,

00:14:25.630 --> 00:14:30.020
there was no compaction,
which means that when--

00:14:30.020 --> 00:14:33.334
this causes big problems with
fragmentation the heap where

00:14:33.334 --> 00:14:35.500
you would allocate these
temporary things over time,

00:14:35.500 --> 00:14:37.100
and then you would remove
the things that weren't there

00:14:37.100 --> 00:14:37.700
anymore.

00:14:37.700 --> 00:14:40.090
But the things that were
permanent, or long-lived,

00:14:40.090 --> 00:14:41.880
would still be in
the heap somewhere.

00:14:41.880 --> 00:14:45.130
And we could never actually
get back that memory.

00:14:45.130 --> 00:14:46.790
There is a certain
amount of trimming

00:14:46.790 --> 00:14:50.840
that happens under Dalvik
where, if we get rid of enough

00:14:50.840 --> 00:14:54.330
of the objects that occupy
an entire page, eventually,

00:14:54.330 --> 00:14:56.967
we can hand that
page back to memory.

00:14:56.967 --> 00:14:59.300
But in general, you're stuck
in this situation where you

00:14:59.300 --> 00:15:00.640
basically grow without bound.

00:15:00.640 --> 00:15:02.210
The heap gets larger.

00:15:02.210 --> 00:15:05.030
And we can never really
get back all of that space,

00:15:05.030 --> 00:15:08.820
even if you only grew it to a
large size very temporarily.

00:15:08.820 --> 00:15:13.220
Under ART, this improves,
because we do actually

00:15:13.220 --> 00:15:14.857
compact the heap eventually.

00:15:14.857 --> 00:15:16.690
When your app goes into
the background, when

00:15:16.690 --> 00:15:20.380
it senses that it's an idle time
that it can do this operation,

00:15:20.380 --> 00:15:22.359
then it'll take a look
at the heap and realize,

00:15:22.359 --> 00:15:24.150
well, there's a lot
objects that went away.

00:15:24.150 --> 00:15:26.030
In the meantime, we
can compact the heap.

00:15:26.030 --> 00:15:29.700
So it gets better under ART,
but it's still a problem,

00:15:29.700 --> 00:15:32.530
especially if you're just
the foreground application.

00:15:32.530 --> 00:15:35.610
We're not going to compact
the heap at that time.

00:15:35.610 --> 00:15:36.140
All right.

00:15:36.140 --> 00:15:40.770
So there's a few points
to come out of this.

00:15:40.770 --> 00:15:45.010
So when you have
fewer allocations,

00:15:45.010 --> 00:15:46.190
you get a smaller heap.

00:15:46.190 --> 00:15:48.930
You also get faster
allocation times,

00:15:48.930 --> 00:15:52.410
because there's simply less
work to do to figure out

00:15:52.410 --> 00:15:53.800
where the free space is.

00:15:53.800 --> 00:15:56.720
You get faster collection
times, because again,

00:15:56.720 --> 00:15:59.110
smaller heap, less
things to keep track of.

00:15:59.110 --> 00:16:03.480
You get fewer pauses, because
there's less to do over time.

00:16:03.480 --> 00:16:06.290
And there's less CPU
usage, because you're not

00:16:06.290 --> 00:16:08.440
causing the CPU to
actually continually do

00:16:08.440 --> 00:16:11.840
this mark, and sweep, and
collect in the background.

00:16:11.840 --> 00:16:14.100
And then, overall, you
get less jank, especially

00:16:14.100 --> 00:16:15.580
for the GC_FOR_ALLOC.

00:16:15.580 --> 00:16:17.550
If you're constantly
allocating things,

00:16:17.550 --> 00:16:19.110
and then you run
into a situation

00:16:19.110 --> 00:16:21.650
where there's not enough
free space for a new object,

00:16:21.650 --> 00:16:23.770
then you're going to cause
a GC_FOR_ALLOC, which,

00:16:23.770 --> 00:16:25.140
in general, will cause jank.

00:16:25.140 --> 00:16:28.530
It'll cause you to miss a
frame, particularly on Dalvik,

00:16:28.530 --> 00:16:30.530
but also on ART,
because you're basically

00:16:30.530 --> 00:16:32.500
causing a whole lot
of work to happen

00:16:32.500 --> 00:16:35.300
at a super inconvenient time.

00:16:35.300 --> 00:16:38.170
And then, all of this, in
general, I would posit,

00:16:38.170 --> 00:16:42.230
leads to happier
users and world peace.

00:16:42.230 --> 00:16:46.060
I leave the last item as
an exercise for the reader.

00:16:46.060 --> 00:16:49.530
OK, so let's talk about some of
the tips and tricks about using

00:16:49.530 --> 00:16:51.180
memory more effectively.

00:16:51.180 --> 00:16:56.980
We, meaning me and Romain
Guy gave a talk years

00:16:56.980 --> 00:17:00.250
ago at Devoxx-- and
it's up on parleys.com--

00:17:00.250 --> 00:17:02.220
that goes over a
lot of details here,

00:17:02.220 --> 00:17:05.538
like some of the sizes
and quantities involved.

00:17:05.538 --> 00:17:07.579
So I would encourage you
to check out that video.

00:17:07.579 --> 00:17:10.450
It has a lot of the details
behind some of these items.

00:17:10.450 --> 00:17:15.079
First of all, avoid
allocations when possible.

00:17:15.079 --> 00:17:16.800
One of the things
that we've seen--

00:17:16.800 --> 00:17:19.089
and there's actually a lint
check for this now-- is

00:17:19.089 --> 00:17:21.619
don't allocate in the
middle of your inner loop.

00:17:21.619 --> 00:17:24.680
In particular, if you're
in onDraw, and you realize,

00:17:24.680 --> 00:17:26.270
well, I need to
draw to this canvas,

00:17:26.270 --> 00:17:28.450
and I need a Paint object,
let's get a Paint object.

00:17:28.450 --> 00:17:30.820
So we'll create a new Paint
object, and we'll do this.

00:17:30.820 --> 00:17:32.040
Incredibly common.

00:17:32.040 --> 00:17:34.710
So there's like a lint check
for that specific pattern,

00:17:34.710 --> 00:17:36.630
just because so many
people are doing this.

00:17:36.630 --> 00:17:37.370
It seems dumb.

00:17:37.370 --> 00:17:39.330
You're like, how big can it be?

00:17:39.330 --> 00:17:42.990
There's only five letters
in the word, "paint," right?

00:17:42.990 --> 00:17:44.420
It turns out it's a problem.

00:17:44.420 --> 00:17:46.110
It's a problem for two reasons.

00:17:46.110 --> 00:17:51.330
One is not as obvious is
that the Java level object

00:17:51.330 --> 00:17:53.110
that we're allocating,
the Paint object,

00:17:53.110 --> 00:17:54.526
is kind of the tip
of the iceberg.

00:17:54.526 --> 00:17:56.890
We're also allocating stuff
at the native level, which

00:17:56.890 --> 00:17:59.130
then needs to be finalized
and collected later,

00:17:59.130 --> 00:18:01.770
which is kind of an arduous
process to go through as well.

00:18:01.770 --> 00:18:03.730
I'll talk about
finalizers later.

00:18:03.730 --> 00:18:06.680
So there's a lot of stuff that's
happening underneath Paint

00:18:06.680 --> 00:18:08.930
that you're causing to
happen, just by allocating

00:18:08.930 --> 00:18:10.460
a temporary Paint object.

00:18:10.460 --> 00:18:12.680
The other one is the churn
that I was talking about.

00:18:12.680 --> 00:18:14.710
If you are in onDraw,
and your onDraw

00:18:14.710 --> 00:18:17.330
is being called on every
frame of an animation,

00:18:17.330 --> 00:18:20.180
and on every frame you're
allocating a Paint object,

00:18:20.180 --> 00:18:23.700
well, at some point, that means
that your heap will fill up.

00:18:23.700 --> 00:18:26.655
Maybe not in that animation,
but maybe in a future animation,

00:18:26.655 --> 00:18:28.030
at some point,
you're going to go

00:18:28.030 --> 00:18:31.850
to allocate that Paint object,
and it won't find enough space.

00:18:31.850 --> 00:18:33.854
And then, it's going to
have to make the space.

00:18:33.854 --> 00:18:35.520
So you're in the
middle of an animation,

00:18:35.520 --> 00:18:38.727
you're in your Draw loop, you're
on the UI thread, and GC says,

00:18:38.727 --> 00:18:39.310
you know what?

00:18:39.310 --> 00:18:40.390
I'm going to have to
collect right now.

00:18:40.390 --> 00:18:42.880
Would you please hang on
for a few milliseconds?

00:18:42.880 --> 00:18:45.170
And that's what causes
jank for the user.

00:18:45.170 --> 00:18:48.080
So don't do that, when
you don't need to.

00:18:48.080 --> 00:18:50.960
One of the strategies that we
use internally in the framework

00:18:50.960 --> 00:18:53.040
that I would encourage
people to look into,

00:18:53.040 --> 00:18:55.780
in specific inner loop
situations like this,

00:18:55.780 --> 00:18:57.300
is caching objects.

00:18:57.300 --> 00:19:00.490
So one of the tricks--
if you ever look

00:19:00.490 --> 00:19:02.370
at the source code
of the framework,

00:19:02.370 --> 00:19:04.890
like view.java, or any
of the core classes

00:19:04.890 --> 00:19:07.520
there, we will keep around
either instance classes,

00:19:07.520 --> 00:19:11.360
or in some limited cases,
static objects, that only get

00:19:11.360 --> 00:19:13.800
allocated lazily.

00:19:13.800 --> 00:19:15.830
So when we see the
first time that, OK,

00:19:15.830 --> 00:19:18.230
we're going to need a
Paint object, or a Rect

00:19:18.230 --> 00:19:21.340
object, or a Point object,
for this particular call,

00:19:21.340 --> 00:19:23.640
if it's null we'll go
ahead and allocate it then.

00:19:23.640 --> 00:19:26.460
And then, thereafter, we'll
just use that shared object.

00:19:26.460 --> 00:19:27.340
In a lot of cases.

00:19:27.340 --> 00:19:29.710
So in the onDraw
situation, chances are,

00:19:29.710 --> 00:19:31.820
you don't need that
Paint object for anything

00:19:31.820 --> 00:19:33.090
else in that class.

00:19:33.090 --> 00:19:35.990
So you could have an instance
variable-- or a static,

00:19:35.990 --> 00:19:39.080
if you want to manage it
that way-- that only gets

00:19:39.080 --> 00:19:42.426
used when you're actually
in that onDraw method.

00:19:42.426 --> 00:19:43.550
So it seems a little silly.

00:19:43.550 --> 00:19:45.091
You might as well
have a local field.

00:19:45.091 --> 00:19:47.000
But because of the
memory concerns,

00:19:47.000 --> 00:19:48.860
you really want a
cached object instead.

00:19:48.860 --> 00:19:50.760
So allocate it lazily,
and then use it

00:19:50.760 --> 00:19:52.736
whenever you need to in
that specific method.

00:19:52.736 --> 00:19:54.110
You have to be
careful with this.

00:19:54.110 --> 00:19:57.230
Obviously, if you're actually
accessing that shared variable,

00:19:57.230 --> 00:19:59.680
either instance or static,
from multiple places,

00:19:59.680 --> 00:20:01.490
that can get a little tricky.

00:20:01.490 --> 00:20:02.991
So it's not a blanket pattern.

00:20:02.991 --> 00:20:04.740
Just like all of these
tips, these are not

00:20:04.740 --> 00:20:07.480
like hard and fast rules.

00:20:07.480 --> 00:20:09.030
But in general, it's
an approach that

00:20:09.030 --> 00:20:12.850
can avoid the kind of
expensive, insidiously

00:20:12.850 --> 00:20:18.330
expensive, allocations
that we see in inner loops.

00:20:18.330 --> 00:20:20.490
Pools-- so object
pools are something

00:20:20.490 --> 00:20:24.440
that traditional Java,
certainly server developers,

00:20:24.440 --> 00:20:26.210
walked away from years ago.

00:20:26.210 --> 00:20:30.420
You know, let the memory manager
manage your objects for you.

00:20:30.420 --> 00:20:31.220
You don't need to.

00:20:31.220 --> 00:20:32.920
But because of the
allocation concerns

00:20:32.920 --> 00:20:34.597
that we have on
Android, sometimes, it's

00:20:34.597 --> 00:20:35.930
a good idea to actually do this.

00:20:35.930 --> 00:20:39.764
If these are expensive
objects to allocate,

00:20:39.764 --> 00:20:41.180
maybe it's better
to actually have

00:20:41.180 --> 00:20:43.290
a small pool of these
things and keep them around,

00:20:43.290 --> 00:20:46.440
instead of having to reallocate
one every time you need it.

00:20:46.440 --> 00:20:48.110
This also can be tricky.

00:20:48.110 --> 00:20:51.260
If they're being accessed from
different places in the code,

00:20:51.260 --> 00:20:54.910
then there's a bit of management
overhead to go with this.

00:20:54.910 --> 00:20:57.543
This is not as easy a thing
as the cached approach

00:20:57.543 --> 00:20:58.830
I was talking about, easier.

00:20:58.830 --> 00:20:59.440
That's easy.

00:20:59.440 --> 00:21:01.250
There's just a single
field to manage.

00:21:01.250 --> 00:21:03.026
Object pools, there's
a bit more to it.

00:21:03.026 --> 00:21:04.650
There's things like
LRU caches that you

00:21:04.650 --> 00:21:06.680
can use to make this easier.

00:21:06.680 --> 00:21:10.640
But figure out the right
trade-off for your code.

00:21:10.640 --> 00:21:13.540
Arrays-- ArrayList
is pretty good.

00:21:13.540 --> 00:21:14.660
I tend to use it a lot.

00:21:14.660 --> 00:21:17.400
It's one of the nicer and
more streamlined collections

00:21:17.400 --> 00:21:18.720
for storing stuff there.

00:21:18.720 --> 00:21:20.090
You keep adding to it.

00:21:20.090 --> 00:21:22.470
It'll reallocate when necessary.

00:21:22.470 --> 00:21:26.910
But if you just have a
statically determined size

00:21:26.910 --> 00:21:29.720
collection that you
need, Array itself

00:21:29.720 --> 00:21:33.147
tends to be more optimal
than ArrayList, right?

00:21:33.147 --> 00:21:34.980
It doesn't need to
allocate things in there,

00:21:34.980 --> 00:21:38.260
it's just got the Array
itself, and then the objects

00:21:38.260 --> 00:21:39.600
that you put in it.

00:21:39.600 --> 00:21:40.810
So consider using arrays.

00:21:40.810 --> 00:21:43.670
They're just a bit more
streamlined and optimal,

00:21:43.670 --> 00:21:47.140
and don't do as much churn for
reallocation that collections

00:21:47.140 --> 00:21:49.300
would do automatically.

00:21:49.300 --> 00:21:51.770
Speaking of collections, I
would encourage you to check out

00:21:51.770 --> 00:21:53.270
the Android collections.

00:21:53.270 --> 00:21:56.580
So the traditional Java
programming language

00:21:56.580 --> 00:21:58.990
collections, they're all
very powerful and useful.

00:21:58.990 --> 00:22:01.290
And they're probably
still the right thing

00:22:01.290 --> 00:22:03.790
to use for large
collections, like HashMap.

00:22:03.790 --> 00:22:06.430
Awesome, if you have a
really large amount of data

00:22:06.430 --> 00:22:07.940
that you need to store.

00:22:07.940 --> 00:22:11.727
But check out ArrayMap,
instead, if you actually just

00:22:11.727 --> 00:22:12.810
have a smaller collection.

00:22:12.810 --> 00:22:19.310
It avoids a lot of the boxing,
as well as the allocations that

00:22:19.310 --> 00:22:22.500
are inherent in HashMap itself.

00:22:22.500 --> 00:22:24.670
So there's a bunch of
collections in Android.

00:22:24.670 --> 00:22:25.530
There's ArrayMap.

00:22:25.530 --> 00:22:28.870
In the support library,
there's SimpleArrayMap.

00:22:28.870 --> 00:22:31.080
Then there's SparseArray.

00:22:31.080 --> 00:22:34.350
There's actually a bunch of
sparse things, LongSparse,

00:22:34.350 --> 00:22:38.940
LongIntSparse, LongInts, lots
of different combinations.

00:22:38.940 --> 00:22:42.320
But they basically use
primitives as keys,

00:22:42.320 --> 00:22:47.990
instead of the auto-boxed Java
language versions of those,

00:22:47.990 --> 00:22:52.080
like not capital L, Long,
but instead a primitive long.

00:22:52.080 --> 00:22:54.200
Wouldn't that be nice?

00:22:54.200 --> 00:22:57.570
Methods that mutate-- this is
another pattern that I think

00:22:57.570 --> 00:23:00.590
traditional Java programmers
walked away from years

00:23:00.590 --> 00:23:03.930
ago, maybe holding their nose.

00:23:03.930 --> 00:23:07.620
In general, so let's say
you want to pass in an x,y,

00:23:07.620 --> 00:23:09.970
and you want to
get a point return,

00:23:09.970 --> 00:23:12.587
because you need that point
data structure to pass into some

00:23:12.587 --> 00:23:13.420
other method, right?

00:23:13.420 --> 00:23:14.836
So you have this
utility function.

00:23:14.836 --> 00:23:15.914
I'm going to pass in x,y.

00:23:15.914 --> 00:23:17.080
I'm going to get point back.

00:23:17.080 --> 00:23:18.074
Really stupid example.

00:23:18.074 --> 00:23:19.740
You could create your
point on your own.

00:23:19.740 --> 00:23:23.806
But to illustrate the point--

00:23:23.806 --> 00:23:26.076
[LAUGHTER]

00:23:26.076 --> 00:23:27.320
Ow.

00:23:27.320 --> 00:23:30.331
So traditionally, you
would pass in x, y,

00:23:30.331 --> 00:23:31.580
and it would allocate a point.

00:23:31.580 --> 00:23:32.470
And it would pass
it back to you.

00:23:32.470 --> 00:23:33.120
Not a big deal.

00:23:33.120 --> 00:23:34.750
It's just a temporary
object, right?

00:23:34.750 --> 00:23:36.640
Again, if you're
in your inner loop,

00:23:36.640 --> 00:23:38.165
allocating is, in general, bad.

00:23:38.165 --> 00:23:39.540
Wouldn't it be
nice if you didn't

00:23:39.540 --> 00:23:41.331
have to reallocate that
thing all the time?

00:23:41.331 --> 00:23:43.010
This is just a temporary object.

00:23:43.010 --> 00:23:45.870
So instead, what you can
do is keep a cached object

00:23:45.870 --> 00:23:51.421
in the caller, and then call a
mutating version of that method

00:23:51.421 --> 00:23:51.920
instead.

00:23:51.920 --> 00:23:55.310
So instead of passing in
x,y, maybe you pass in x,y

00:23:55.310 --> 00:23:56.980
and a point data structure.

00:23:56.980 --> 00:23:58.710
And then it fills in
the data structure.

00:23:58.710 --> 00:24:00.640
And then that gives
you the option

00:24:00.640 --> 00:24:03.410
to allocate it on-the-fly,
if you really want to,

00:24:03.410 --> 00:24:07.392
or to keep it and reuse
a cached object instead.

00:24:07.392 --> 00:24:09.350
So if you look through
the Android source code,

00:24:09.350 --> 00:24:10.808
especially in the
framework, you'll

00:24:10.808 --> 00:24:14.240
see a lot of instances of
this internally, where we'll

00:24:14.240 --> 00:24:19.240
pass in a Rect that gets filled
in during layouts or whatever.

00:24:19.240 --> 00:24:21.800
And this is specifically to
avoid the temporary allocations

00:24:21.800 --> 00:24:24.080
that are necessary
to pass back richer

00:24:24.080 --> 00:24:28.730
data than simply a single
primitive return value.

00:24:28.730 --> 00:24:31.070
And speaking of primitives,
we have primitive types.

00:24:31.070 --> 00:24:33.340
We really like them in Android.

00:24:33.340 --> 00:24:35.100
In general, if you
use primitive types,

00:24:35.100 --> 00:24:37.560
you're going to avoid
all the boxing that's

00:24:37.560 --> 00:24:39.770
inherent in using the
object equivalents.

00:24:39.770 --> 00:24:42.600
So if you write a method
that takes a capital F Float,

00:24:42.600 --> 00:24:45.700
and you're running an animation
or doing a calculation that

00:24:45.700 --> 00:24:47.820
has a primitive float,
when you call that method,

00:24:47.820 --> 00:24:49.153
it's automatically going to box.

00:24:49.153 --> 00:24:51.540
It's going to create a
capital F Float out of it.

00:24:51.540 --> 00:24:55.057
There's slightly more overhead
in getting the value of that.

00:24:55.057 --> 00:24:56.390
I'm not as concerned about that.

00:24:56.390 --> 00:24:58.890
I am concerned about
creating garbage, creating

00:24:58.890 --> 00:25:01.980
these small, temporary objects,
when you really didn't need to.

00:25:01.980 --> 00:25:04.920
So as much as you can,
stick to the primitives.

00:25:04.920 --> 00:25:07.930
The collection classes,
obviously, use the object types

00:25:07.930 --> 00:25:10.600
instead, so you can't
really get around it there.

00:25:10.600 --> 00:25:12.757
But for all of your
internal methods

00:25:12.757 --> 00:25:14.340
that aren't using
collections, there's

00:25:14.340 --> 00:25:16.460
no reason to not use
the primitives instead.

00:25:16.460 --> 00:25:18.490
They just tend to be
a lot more streamlined

00:25:18.490 --> 00:25:21.409
and avoid the memory situations
that we're talking about.

00:25:21.409 --> 00:25:23.700
There are a lot language
things that you can trip over,

00:25:23.700 --> 00:25:26.700
without really realizing why.

00:25:26.700 --> 00:25:29.360
Iterators is one of
my favorite examples.

00:25:29.360 --> 00:25:31.286
So I love the for-each syntax.

00:25:31.286 --> 00:25:33.910
I don't know why it's called the
for-each syntax, since there's

00:25:33.910 --> 00:25:36.180
no "each" in the language.

00:25:36.180 --> 00:25:38.840
Somehow, we adopted that
way of referring to it.

00:25:38.840 --> 00:25:41.740
And then you go looking for the
primitive, and it's not there.

00:25:41.740 --> 00:25:44.550
They should just
maybe call it a for.

00:25:44.550 --> 00:25:45.550
So it's very convenient.

00:25:45.550 --> 00:25:47.680
It came out in JDK 1.5.

00:25:47.680 --> 00:25:52.300
You say, for object
O in this thing.

00:25:52.300 --> 00:25:54.280
And then it iterates
through that collection.

00:25:54.280 --> 00:25:55.301
Very convenient.

00:25:55.301 --> 00:25:57.175
What's going on under
the hood, though-- this

00:25:57.175 --> 00:25:58.220
is syntactic sugar.

00:25:58.220 --> 00:26:00.719
It is creating an
iterator for you, right?

00:26:00.719 --> 00:26:02.010
So it's allocating that object.

00:26:02.010 --> 00:26:04.530
And then it's doing
the normal iteration,

00:26:04.530 --> 00:26:06.460
using that iterator object.

00:26:06.460 --> 00:26:10.520
The iterator approach was
kind of ugly and obtuse.

00:26:10.520 --> 00:26:12.320
I don't think people
enjoyed using that.

00:26:12.320 --> 00:26:14.254
The for-each works around that.

00:26:14.254 --> 00:26:15.670
It makes a nice
streamlined thing,

00:26:15.670 --> 00:26:17.980
but it's still doing the
same thing under the hood.

00:26:17.980 --> 00:26:21.100
In particular, if your
collection is empty,

00:26:21.100 --> 00:26:23.830
it's going to create
an iterator anyway.

00:26:23.830 --> 00:26:25.337
It does not know
that it's empty,

00:26:25.337 --> 00:26:26.920
until it creates the
iterator and then

00:26:26.920 --> 00:26:28.346
tries to get the first item.

00:26:28.346 --> 00:26:29.720
And then it says,
oh, your empty.

00:26:29.720 --> 00:26:30.553
You need to do this.

00:26:30.553 --> 00:26:34.070
So one of the optimizations
that we did along

00:26:34.070 --> 00:26:36.900
the way to creating the new
animation system in Honeycomb

00:26:36.900 --> 00:26:39.990
was to eliminate all
the allocations that

00:26:39.990 --> 00:26:41.610
were going on in every frame.

00:26:41.610 --> 00:26:43.350
So we have this new
animation system.

00:26:43.350 --> 00:26:46.064
We use this tool internally,
called Allocation Tracker.

00:26:46.064 --> 00:26:47.730
I would encourage
everybody to use this,

00:26:47.730 --> 00:26:49.104
to make sure that
you're actually

00:26:49.104 --> 00:26:50.780
using memory correctly.

00:26:50.780 --> 00:26:52.350
So I would start the animation.

00:26:52.350 --> 00:26:54.080
I would start
allocation tracking.

00:26:54.080 --> 00:26:55.729
I would collect the allocations.

00:26:55.729 --> 00:26:57.520
And then the animation
would finish, right?

00:26:57.520 --> 00:26:59.630
I don't care if we're allocating
at the beginning and the end.

00:26:59.630 --> 00:27:01.620
To some extent, that's
unavoidable, right?

00:27:01.620 --> 00:27:02.480
This is Java.

00:27:02.480 --> 00:27:04.585
It's a memory garbage
collecting language.

00:27:04.585 --> 00:27:05.960
You're going to
allocate objects.

00:27:05.960 --> 00:27:08.610
What you don't want to do is
allocate during the animation,

00:27:08.610 --> 00:27:10.260
like during the actual frames.

00:27:10.260 --> 00:27:12.840
And then I saw that,
on every single frame,

00:27:12.840 --> 00:27:15.470
we were allocating
objects for listeners.

00:27:15.470 --> 00:27:18.370
What was going on was we had
this View TreeObserver where

00:27:18.370 --> 00:27:20.500
you can listen to
various events going on,

00:27:20.500 --> 00:27:23.410
layouts, pre-draw,
draw, the things

00:27:23.410 --> 00:27:25.350
are happening in
the view hierarchy.

00:27:25.350 --> 00:27:27.150
And on every frame,
we would say,

00:27:27.150 --> 00:27:32.750
for-ViewTreeObserver, Listener,
whatever, in this collection.

00:27:32.750 --> 00:27:35.220
Then we would iterate through,
and we would do something.

00:27:35.220 --> 00:27:37.250
In general, nobody
actually added a listener.

00:27:37.250 --> 00:27:39.110
It's not typical to
have a listener there.

00:27:39.110 --> 00:27:41.520
But we would create an
iterator on every single frame

00:27:41.520 --> 00:27:44.690
anyway, because that's
what for-each did for us.

00:27:44.690 --> 00:27:46.547
So there's one
specific case where

00:27:46.547 --> 00:27:48.880
it doesn't do that, which is,
if it's a primitive array,

00:27:48.880 --> 00:27:51.570
it actually does the right
thing and will not create

00:27:51.570 --> 00:27:53.920
an iterator for you, so yay.

00:27:53.920 --> 00:27:56.250
But otherwise, it's
kind of a good thing

00:27:56.250 --> 00:28:00.250
to maybe avoid, if you're
not really sure whether it's

00:28:00.250 --> 00:28:01.700
going to create things.

00:28:01.700 --> 00:28:04.980
You can certainly go
back to the old approach

00:28:04.980 --> 00:28:07.410
of doing an actual
for loop instead,

00:28:07.410 --> 00:28:08.910
and just get the
items in the array.

00:28:08.910 --> 00:28:10.826
And then, it doesn't
advance to the first one,

00:28:10.826 --> 00:28:12.750
if it didn't need it.

00:28:12.750 --> 00:28:15.670
Or if you use it, just be
aware of when it's actually

00:28:15.670 --> 00:28:19.170
going to cause an allocation
when you don't want it to.

00:28:19.170 --> 00:28:20.090
Wait.

00:28:20.090 --> 00:28:20.680
Let's go back.

00:28:20.680 --> 00:28:22.140
Yeah, this one.

00:28:22.140 --> 00:28:25.400
So let's talk about
enums no more.

00:28:25.400 --> 00:28:28.150
I'm really tired of this
topic at this conference.

00:28:28.150 --> 00:28:29.560
Go to the article and read.

00:28:29.560 --> 00:28:30.980
There's nuances to using them.

00:28:30.980 --> 00:28:33.650
Please understand the
overhead inherent in enums

00:28:33.650 --> 00:28:35.400
and make the right
decision for your code.

00:28:35.400 --> 00:28:36.570
Moving on.

00:28:36.570 --> 00:28:37.560
Finalizers.

00:28:37.560 --> 00:28:39.900
[LAUGHTER]

00:28:39.900 --> 00:28:41.580
So one of the things
that's not obvious

00:28:41.580 --> 00:28:44.990
about finalizers is nuances
in the language spec

00:28:44.990 --> 00:28:47.890
mean that, to
finalize any object,

00:28:47.890 --> 00:28:50.560
we actually need
to do a GC twice.

00:28:50.560 --> 00:28:53.120
So whenever you have a finalizer
declared on your class,

00:28:53.120 --> 00:28:56.620
you're basically forcing
a future GC twice.

00:28:56.620 --> 00:28:58.800
And you kind of want to
avoid every single one, so

00:28:58.800 --> 00:29:00.880
why are you forcing
two on the system?

00:29:00.880 --> 00:29:03.890
There are particular situations
that really require finalizers.

00:29:03.890 --> 00:29:06.660
We do use them
internally, specifically,

00:29:06.660 --> 00:29:09.540
when we have native objects
that need to be cleared.

00:29:09.540 --> 00:29:12.040
So we need to know when
that thing went away,

00:29:12.040 --> 00:29:13.890
so that, on the
native side, we can

00:29:13.890 --> 00:29:16.610
go ahead and free the native
memory associated with it.

00:29:16.610 --> 00:29:18.260
So that's a valid
use case for it.

00:29:18.260 --> 00:29:21.310
But I would say, try to limit
the number of valid use cases.

00:29:21.310 --> 00:29:23.870
And definitely eliminate
finalizers when you

00:29:23.870 --> 00:29:25.910
don't need them in other cases.

00:29:25.910 --> 00:29:28.029
They may be convenient,
but there are better ways,

00:29:28.029 --> 00:29:29.570
certainly from the
memory standpoint,

00:29:29.570 --> 00:29:32.420
to do what you want to do.

00:29:32.420 --> 00:29:34.770
Static leaks, this is
one of my favorites.

00:29:34.770 --> 00:29:36.760
I may or may not
have caused leaks

00:29:36.760 --> 00:29:41.360
in activities in
some of my code.

00:29:41.360 --> 00:29:43.520
I should do a deep
dive into the way

00:29:43.520 --> 00:29:47.150
that HashMap or
WeakHashMap works.

00:29:47.150 --> 00:29:49.730
So there's a situation
where I needed

00:29:49.730 --> 00:29:53.790
to store information about
listeners associate with views.

00:29:53.790 --> 00:29:56.960
And I said, well, I
know that WeakHashMap

00:29:56.960 --> 00:29:58.510
uses a weak reference.

00:29:58.510 --> 00:30:01.230
So when that view
goes away-- which

00:30:01.230 --> 00:30:03.580
is what I was using
for my key-- then I

00:30:03.580 --> 00:30:05.487
know that everything
will be collected.

00:30:05.487 --> 00:30:06.570
Turns out that's not true.

00:30:06.570 --> 00:30:09.620
The way that WeakHashMap
works, it actually

00:30:09.620 --> 00:30:11.750
had a hard reference to the key.

00:30:11.750 --> 00:30:15.200
It had a weak reference to
the value, which kind of

00:30:15.200 --> 00:30:17.350
turns my head in knots.

00:30:17.350 --> 00:30:22.750
But the end result was
that the activity would

00:30:22.750 --> 00:30:24.190
undergo a configuration change.

00:30:24.190 --> 00:30:26.580
So the phone would rotate,
and it would tear down

00:30:26.580 --> 00:30:29.790
the activity, and it would
come up with a new activity.

00:30:29.790 --> 00:30:31.570
And all that old
stuff went away,

00:30:31.570 --> 00:30:34.740
except that I had a
static WeakHashMap which

00:30:34.740 --> 00:30:37.600
had a reference to the
view which implicitly has

00:30:37.600 --> 00:30:40.310
a reference to its activity.

00:30:40.310 --> 00:30:41.900
Bad thing, in general.

00:30:41.900 --> 00:30:44.630
So beware of static
leaks, in general.

00:30:44.630 --> 00:30:47.690
The real problem here--
besides my ineptitude

00:30:47.690 --> 00:30:49.710
and misunderstanding of
how a WeakHashMap worked

00:30:49.710 --> 00:30:53.900
at the time-- was that the
lifetime of the process

00:30:53.900 --> 00:30:56.050
is different than the
lifetime of your activity.

00:30:56.050 --> 00:30:58.300
This is something I've hit
again and again in Android.

00:30:58.300 --> 00:31:00.450
I tend to think of,
when a window comes up,

00:31:00.450 --> 00:31:03.380
when basically that
application object

00:31:03.380 --> 00:31:06.220
that I'm working with-- which
is, the activity in my mind

00:31:06.220 --> 00:31:08.770
is sort of synonymous
with application, that's

00:31:08.770 --> 00:31:13.410
the first problem-- when that
comes up, surely, that's where

00:31:13.410 --> 00:31:14.590
all my static objects live.

00:31:14.590 --> 00:31:15.089
They don't.

00:31:15.089 --> 00:31:16.880
They live in the process itself.

00:31:16.880 --> 00:31:18.429
And the process is long-lived.

00:31:18.429 --> 00:31:20.220
So when you undergo a
configuration change,

00:31:20.220 --> 00:31:22.830
we rip down the activity,
and we pop up another one.

00:31:22.830 --> 00:31:24.050
And it's in the same process.

00:31:24.050 --> 00:31:26.080
So if you have a
static object there--

00:31:26.080 --> 00:31:28.580
whether it's a WeakHashMap,
or something else that's

00:31:28.580 --> 00:31:31.320
holding on to something it
shouldn't in the old activity--

00:31:31.320 --> 00:31:33.450
it will continue
to hold onto it.

00:31:33.450 --> 00:31:37.170
So static can be the right
thing to use in some situations,

00:31:37.170 --> 00:31:39.062
but is really
dangerous because, just

00:31:39.062 --> 00:31:41.520
know that it's going to live
a lot longer than the activity

00:31:41.520 --> 00:31:44.810
that you think you're storing
things associated with.

00:31:44.810 --> 00:31:46.430
Static initialization
is a good thing

00:31:46.430 --> 00:31:50.660
to avoid, in general, especially
for expensive allocations

00:31:50.660 --> 00:31:52.560
or expensive operations.

00:31:52.560 --> 00:31:54.540
The problem that we
see is that, when

00:31:54.540 --> 00:31:57.750
a class gets loaded, and then
does a bunch of static work,

00:31:57.750 --> 00:32:00.400
it's going to do all
that stuff right now.

00:32:00.400 --> 00:32:02.630
This causes a problem,
for instance, when you

00:32:02.630 --> 00:32:03.835
launch your activity, right?

00:32:03.835 --> 00:32:04.710
So we're going to go.

00:32:04.710 --> 00:32:05.230
We're going to launch.

00:32:05.230 --> 00:32:06.730
We're going to try to
launch as fast as possible.

00:32:06.730 --> 00:32:09.229
And then it loads this class,
which does a whole lot of work

00:32:09.229 --> 00:32:10.520
that it really didn't need to.

00:32:10.520 --> 00:32:12.180
Why not do some of
that stuff lazily?

00:32:12.180 --> 00:32:15.600
If you didn't actually need
to initialize the database,

00:32:15.600 --> 00:32:17.770
whatever, at that
point, why don't you

00:32:17.770 --> 00:32:19.625
wait until a better
time, instead of forcing

00:32:19.625 --> 00:32:20.750
that to happen immediately?

00:32:23.660 --> 00:32:25.480
OK, so third-party code.

00:32:25.480 --> 00:32:27.730
We've seen this one a lot,
where again, something

00:32:27.730 --> 00:32:29.920
the traditional Java
developers will do

00:32:29.920 --> 00:32:32.990
is bring over their libraries
and their approaches

00:32:32.990 --> 00:32:34.970
from the old world.

00:32:34.970 --> 00:32:38.420
Oh, I really like this
dependency injection library.

00:32:38.420 --> 00:32:40.830
So a common one that
we've seen is Guice.

00:32:40.830 --> 00:32:41.650
Really powerful.

00:32:41.650 --> 00:32:42.350
Very flexible.

00:32:42.350 --> 00:32:43.404
People love to use this.

00:32:43.404 --> 00:32:44.820
And then they'll
start using that.

00:32:44.820 --> 00:32:46.940
It was not written
for mobile, right?

00:32:46.940 --> 00:32:48.470
It does a whole
lot of reflection.

00:32:48.470 --> 00:32:51.260
And I haven't really talked
about reflection yet.

00:32:51.260 --> 00:32:53.790
Big secret,
reflection sucks, OK?

00:32:53.790 --> 00:32:57.490
It has a lot overhead associated
with it, a lot of allocations,

00:32:57.490 --> 00:32:59.940
as well as just
performance overhead.

00:32:59.940 --> 00:33:01.770
So in general, we
tend to avoid it.

00:33:01.770 --> 00:33:03.270
Everybody kind of
knows that, right?

00:33:03.270 --> 00:33:05.424
You don't really do
reflection, unless you need to.

00:33:05.424 --> 00:33:07.590
But a lot of these libraries
that you're dragging in

00:33:07.590 --> 00:33:09.790
are doing it on your behalf.

00:33:09.790 --> 00:33:12.500
So the general tip here
is to not use a library

00:33:12.500 --> 00:33:14.390
or third-party code
in general, unless you

00:33:14.390 --> 00:33:16.480
know that it was actually
written for mobile.

00:33:16.480 --> 00:33:18.210
Because if it wasn't
written for mobile,

00:33:18.210 --> 00:33:20.210
it's probably using
a lot of the patterns

00:33:20.210 --> 00:33:22.330
that we're telling you
not to in your code.

00:33:22.330 --> 00:33:23.870
So why are you
using it indirectly

00:33:23.870 --> 00:33:25.770
in someone else's code?

00:33:25.770 --> 00:33:27.270
For dependency
injection, there have

00:33:27.270 --> 00:33:29.019
been a couple libraries
written since that

00:33:29.019 --> 00:33:30.342
are more tuned to Android.

00:33:30.342 --> 00:33:31.550
There was the Dagger library.

00:33:31.550 --> 00:33:34.087
And more recently, there's
the Dagger 2 library.

00:33:34.087 --> 00:33:36.170
I would suggest you check
those out, if you really

00:33:36.170 --> 00:33:37.840
want that functionality.

00:33:37.840 --> 00:33:40.020
And in general, just
look for libraries that--

00:33:40.020 --> 00:33:43.636
I wish we had a logo
saying, "Mobile-Friendly."

00:33:43.636 --> 00:33:44.760
You can look for that logo.

00:33:44.760 --> 00:33:46.426
It doesn't exist, but
look for the logo.

00:33:46.426 --> 00:33:48.970
Otherwise, just make sure
that you actually know

00:33:48.970 --> 00:33:50.749
what that library is doing.

00:33:50.749 --> 00:33:53.040
The other problem that we've
seen with third-party code

00:33:53.040 --> 00:33:56.312
is, if you're really using
a really large library,

00:33:56.312 --> 00:33:58.520
chances are there's a
dependency graph in there where

00:33:58.520 --> 00:34:00.170
you're dragging
in a lot of stuff

00:34:00.170 --> 00:34:02.120
that you don't necessarily need.

00:34:02.120 --> 00:34:05.560
Like, if you are using
library fu, because you really

00:34:05.560 --> 00:34:08.850
like that collection class for
managing this particular thing,

00:34:08.850 --> 00:34:11.860
and then, all of a sudden
it added 20,000 methods

00:34:11.860 --> 00:34:15.462
to your method count and
a whole lot of APK size,

00:34:15.462 --> 00:34:17.420
just so that you could
use that one collection,

00:34:17.420 --> 00:34:20.250
probably not what you
want in your application.

00:34:20.250 --> 00:34:23.150
So just be as concerned
about your library code

00:34:23.150 --> 00:34:26.730
as you are about your own code.

00:34:26.730 --> 00:34:31.350
So there are mechanisms that
Android provides to help you

00:34:31.350 --> 00:34:32.409
with memory concerns.

00:34:32.409 --> 00:34:34.670
One of them is trimming memory.

00:34:34.670 --> 00:34:37.290
So the system will tell you
when it's getting low on memory.

00:34:37.290 --> 00:34:39.040
And you should really
respond to that,

00:34:39.040 --> 00:34:41.790
because it's not just telling
you, like, oh, by the way,

00:34:41.790 --> 00:34:43.190
I'd really love some memory.

00:34:43.190 --> 00:34:45.330
It's not a casual conversation.

00:34:45.330 --> 00:34:47.820
It's saying I need memory now.

00:34:47.820 --> 00:34:49.040
Could you please free some?

00:34:49.040 --> 00:34:52.159
Because otherwise, bad
stuff is going to happen.

00:34:52.159 --> 00:34:56.199
So when it goes out, it reaches
out to the activities running

00:34:56.199 --> 00:34:58.250
on the system, the
processes, and says,

00:34:58.250 --> 00:34:59.447
we're running low on memory.

00:34:59.447 --> 00:35:00.780
Can you do something about this?

00:35:00.780 --> 00:35:02.740
And there's various
levels of it,

00:35:02.740 --> 00:35:06.070
so you can set your warning
and panic appropriately.

00:35:06.070 --> 00:35:09.320
But if you're keeping
cached thumbnails around,

00:35:09.320 --> 00:35:11.650
just in case the user
wanted to do a fling--

00:35:11.650 --> 00:35:13.650
but right now, you're
running in the background,

00:35:13.650 --> 00:35:15.566
you don't need those
anymore-- maybe it'd

00:35:15.566 --> 00:35:16.940
be a good time to
jettison those.

00:35:16.940 --> 00:35:19.544
Because if you can
make yourself smaller,

00:35:19.544 --> 00:35:20.960
then maybe the
system can get back

00:35:20.960 --> 00:35:23.543
the memory that it needs so that
it doesn't have to go killing

00:35:23.543 --> 00:35:25.620
activities, like yours.

00:35:25.620 --> 00:35:27.600
So pay attention to
the trim callbacks,

00:35:27.600 --> 00:35:29.040
and do something about them.

00:35:29.040 --> 00:35:34.060
isLowRamDevice() is
a method on, I think,

00:35:34.060 --> 00:35:38.580
Activity Manager that tells
you whether the system--

00:35:38.580 --> 00:35:42.710
at the moment, it means
this has 512 memory in it.

00:35:42.710 --> 00:35:45.940
So if you really
need more memory

00:35:45.940 --> 00:35:47.820
to have the best
user experience,

00:35:47.820 --> 00:35:52.340
but you also want to work
adequately on 512-meg devices,

00:35:52.340 --> 00:35:55.130
then you might call this
method and set the way

00:35:55.130 --> 00:35:58.970
that your application
behaves accordingly.

00:35:58.970 --> 00:36:00.250
Avoid large heaps.

00:36:00.250 --> 00:36:03.410
There is a way to ask the
system for more memory.

00:36:03.410 --> 00:36:05.150
And sometimes,
this is necessary.

00:36:05.150 --> 00:36:07.460
You know, you're a
video-playing application where

00:36:07.460 --> 00:36:09.770
the videos simply won't
fit into the standard heap,

00:36:09.770 --> 00:36:12.380
or you're doing
image manipulation

00:36:12.380 --> 00:36:14.570
with massive images,
whatever it is,

00:36:14.570 --> 00:36:16.860
there are some corner case
situations for which this

00:36:16.860 --> 00:36:17.980
was introduced.

00:36:17.980 --> 00:36:22.220
But it also tends to be a back
door for lazy developers who

00:36:22.220 --> 00:36:24.720
are like, well, I just--
but I want more memory.

00:36:24.720 --> 00:36:26.270
It's easier.

00:36:26.270 --> 00:36:27.110
Yes, it is easier.

00:36:27.110 --> 00:36:28.660
And it makes a
horrible experience,

00:36:28.660 --> 00:36:31.260
because the more you
allocate for your process,

00:36:31.260 --> 00:36:32.720
the less everybody else gets.

00:36:32.720 --> 00:36:34.553
And then it goes back
to the original point.

00:36:34.553 --> 00:36:37.410
So don't use it, unless you
actually really need it.

00:36:37.410 --> 00:36:38.510
Please?

00:36:38.510 --> 00:36:40.430
Don't keep your
services running.

00:36:40.430 --> 00:36:42.380
They can continue to
run in the background.

00:36:42.380 --> 00:36:45.190
But if they exist just
for a particular reason,

00:36:45.190 --> 00:36:49.207
then finish that purpose, and
then get out of them, right?

00:36:49.207 --> 00:36:51.290
Otherwise, they're just
sitting there doing stuff.

00:36:51.290 --> 00:36:53.910
If nothing else, they're taking
up memory in the background,

00:36:53.910 --> 00:36:55.951
meaning that there's less
available for everybody

00:36:55.951 --> 00:36:57.810
else on the system.

00:36:57.810 --> 00:37:00.260
And then, finally,
optimize for code size.

00:37:00.260 --> 00:37:02.170
So this comes in
in a lot of ways.

00:37:02.170 --> 00:37:07.060
But it makes your APK
download better, certainly,

00:37:07.060 --> 00:37:09.140
but it also decreases
the amount of stuff

00:37:09.140 --> 00:37:11.640
that you're loading into
memory for your system.

00:37:11.640 --> 00:37:16.009
So just be smart about how
much memory you're taking up.

00:37:16.009 --> 00:37:17.550
So I want to go over
some of the tips

00:37:17.550 --> 00:37:18.890
that we have in user interface.

00:37:18.890 --> 00:37:21.620
This is sort of a
grab bag of things.

00:37:21.620 --> 00:37:23.450
Don't overdraw.

00:37:23.450 --> 00:37:27.940
There's a tool on the device
called, Profile Overdraw?

00:37:27.940 --> 00:37:28.940
I don't know what it is.

00:37:28.940 --> 00:37:29.559
Colt?

00:37:29.559 --> 00:37:30.475
AUDIENCE: [INAUDIBLE].

00:37:30.475 --> 00:37:31.890
CHET HAASE: Profile-- what?

00:37:31.890 --> 00:37:33.900
AUDIENCE: GPU overdraw.

00:37:33.900 --> 00:37:35.790
CHET HAASE: Profile
GPU Overdraw,

00:37:35.790 --> 00:37:38.120
so you can see what the
overdraw is on the device.

00:37:38.120 --> 00:37:42.560
It paints in a lovely
pallet of pastel colors.

00:37:42.560 --> 00:37:46.560
It will indicate to you how
many times each of the pixels

00:37:46.560 --> 00:37:48.620
is being drawn on the screen.

00:37:48.620 --> 00:37:53.210
The problem is-- so Android uses
a common rendering technique,

00:37:53.210 --> 00:37:56.880
called painters fill algorithm--
I guess, because painters used

00:37:56.880 --> 00:37:58.350
a lot of rectangles
or something--

00:37:58.350 --> 00:38:00.970
where basically, we will paint
all the stuff that you tell us

00:38:00.970 --> 00:38:03.042
to in the order
of back to front,

00:38:03.042 --> 00:38:05.250
because that's going to
result in the correct display

00:38:05.250 --> 00:38:05.810
for the user.

00:38:05.810 --> 00:38:06.810
So you've got a
window background?

00:38:06.810 --> 00:38:07.000
Great.

00:38:07.000 --> 00:38:08.130
We'll paint the
window background.

00:38:08.130 --> 00:38:09.450
You have a container
covering the window?

00:38:09.450 --> 00:38:09.660
Great.

00:38:09.660 --> 00:38:11.800
We'll paint the container
with it's opaque background.

00:38:11.800 --> 00:38:13.176
Oh, you have another
container covering that?

00:38:13.176 --> 00:38:13.490
That's great.

00:38:13.490 --> 00:38:14.580
We'll paint that one too.

00:38:14.580 --> 00:38:16.060
You have a list view,
which has background?

00:38:16.060 --> 00:38:17.000
We're going to paint
the background.

00:38:17.000 --> 00:38:18.624
Oh, all of your items
have background--

00:38:18.624 --> 00:38:21.390
and all of a sudden, when you
finally get to, like, the text

00:38:21.390 --> 00:38:24.330
in a list view, you've
painted each of the pencils

00:38:24.330 --> 00:38:27.450
in those characters
five or six times.

00:38:27.450 --> 00:38:29.784
That's something that the GPU
doesn't really like to do,

00:38:29.784 --> 00:38:30.283
right?

00:38:30.283 --> 00:38:32.040
That was a lot of
wasted effort in there.

00:38:32.040 --> 00:38:33.748
So what you really
need to do is actually

00:38:33.748 --> 00:38:37.150
figure out what opaque
objects are completely

00:38:37.150 --> 00:38:40.060
covering what other opaque
objects and maybe eliminate

00:38:40.060 --> 00:38:41.301
some of that overhead there.

00:38:41.301 --> 00:38:42.800
So you've got the
window background?

00:38:42.800 --> 00:38:43.400
Great.

00:38:43.400 --> 00:38:44.180
Use it.

00:38:44.180 --> 00:38:46.370
Set it to the background color
that you want, and then don't

00:38:46.370 --> 00:38:48.680
have an opaque background
on the containers that

00:38:48.680 --> 00:38:50.020
are sitting on top of it.

00:38:50.020 --> 00:38:52.280
So take a look at your
nested hierarchy there.

00:38:52.280 --> 00:38:55.810
See what the organization
is of containers, as well

00:38:55.810 --> 00:38:58.392
as the opacity of the
backgrounds that they're using.

00:38:58.392 --> 00:38:59.850
And then, do the
right thing there,

00:38:59.850 --> 00:39:03.210
to make sure that we're drawing
as few times as possible

00:39:03.210 --> 00:39:04.530
on every pixel.

00:39:04.530 --> 00:39:05.460
So use the tool.

00:39:05.460 --> 00:39:07.090
See what your overdraw is like.

00:39:07.090 --> 00:39:07.900
Red is bad.

00:39:07.900 --> 00:39:09.940
I'll give you a little
tip, red is bad.

00:39:09.940 --> 00:39:12.260
And then, do something about it.

00:39:12.260 --> 00:39:14.270
Avoiding null window
backgrounds-- so one

00:39:14.270 --> 00:39:17.140
of the tricks to avoid overdraw
ends up in some artifacts

00:39:17.140 --> 00:39:18.750
that you should be aware of.

00:39:18.750 --> 00:39:20.935
So people will eliminate
the window background,

00:39:20.935 --> 00:39:22.310
because they're
like, great, then

00:39:22.310 --> 00:39:24.390
I don't have the overdraw
of painting the window,

00:39:24.390 --> 00:39:27.010
and then also painting the
first container on top of it.

00:39:27.010 --> 00:39:29.040
It'll just paint the container.

00:39:29.040 --> 00:39:30.260
That's true.

00:39:30.260 --> 00:39:32.710
On the other hand,
sometimes then,

00:39:32.710 --> 00:39:35.630
you have an artifact
where all we have to paint

00:39:35.630 --> 00:39:36.660
is the window itself.

00:39:36.660 --> 00:39:39.430
So like we're animating
in the keyboard,

00:39:39.430 --> 00:39:41.077
the IME is animating in.

00:39:41.077 --> 00:39:43.660
And the Window Manager is going
to handle painting the window.

00:39:43.660 --> 00:39:45.457
Or when we're launching
the window itself,

00:39:45.457 --> 00:39:47.040
the activity is not
running yet, we're

00:39:47.040 --> 00:39:49.310
going to be animating
in the starting window,

00:39:49.310 --> 00:39:50.740
and it's empty.

00:39:50.740 --> 00:39:51.304
There's null.

00:39:51.304 --> 00:39:52.970
The Window Manager
has nothing to paint.

00:39:52.970 --> 00:39:55.220
You're going to end up with
an artifact on the screen.

00:39:55.220 --> 00:39:57.366
Either it's going to draw
black, or on some GPUs,

00:39:57.366 --> 00:39:58.740
it may draw garbage
on the screen

00:39:58.740 --> 00:40:02.142
because there's undefined
contents in that buffer.

00:40:02.142 --> 00:40:04.100
So the window background
is there for a reason.

00:40:04.100 --> 00:40:06.290
It's there to tell the
Window Manager what

00:40:06.290 --> 00:40:09.220
to paint on the screen, when
it has no other information

00:40:09.220 --> 00:40:10.300
about the activity.

00:40:10.300 --> 00:40:12.040
So keep the window background.

00:40:12.040 --> 00:40:14.320
But to avoid the
overdraw issues,

00:40:14.320 --> 00:40:16.570
see how you can use
that window background

00:40:16.570 --> 00:40:19.450
to do the right thing,
instead of then having

00:40:19.450 --> 00:40:21.370
an opaque background
on the container that

00:40:21.370 --> 00:40:23.580
overlays the window.

00:40:23.580 --> 00:40:26.950
Also, avoiding disabling
the starting window--

00:40:26.950 --> 00:40:30.830
this is another situation
that results in some artifacts

00:40:30.830 --> 00:40:34.080
where people will disable
the starting window,

00:40:34.080 --> 00:40:36.360
because they didn't want
that blank window up

00:40:36.360 --> 00:40:37.830
before their activity launch.

00:40:37.830 --> 00:40:40.350
But again, the Window Manager
doesn't know what to paint,

00:40:40.350 --> 00:40:42.400
if we don't have
a starting window.

00:40:42.400 --> 00:40:44.680
I would say, instead, actually
use the starting window

00:40:44.680 --> 00:40:45.490
more effectively.

00:40:45.490 --> 00:40:47.270
You can brand your
application with this.

00:40:47.270 --> 00:40:49.350
We've seen particularly
ineffective approaches

00:40:49.350 --> 00:40:52.520
where someone wants a
splash screen before they

00:40:52.520 --> 00:40:53.610
get into their activity.

00:40:53.610 --> 00:40:57.030
Maybe that game took a couple
seconds to launch or whatever,

00:40:57.030 --> 00:41:00.030
so they're like, OK, well,
have a splash screen experience

00:41:00.030 --> 00:41:00.830
here.

00:41:00.830 --> 00:41:02.455
But then they get
this weird experience

00:41:02.455 --> 00:41:04.497
where Windows Manager
doesn't know what to paint,

00:41:04.497 --> 00:41:06.079
so it doesn't do
anything for a while,

00:41:06.079 --> 00:41:07.570
because there's no
starting window.

00:41:07.570 --> 00:41:10.370
And then a splash screen
starts after a second or so

00:41:10.370 --> 00:41:12.120
with this completely
different experience.

00:41:12.120 --> 00:41:15.150
And then the game starts with
a completely different look.

00:41:15.150 --> 00:41:16.140
Pretty awful.

00:41:16.140 --> 00:41:17.980
Or in some situations
it gets even worse

00:41:17.980 --> 00:41:19.710
where they kept the
starting window,

00:41:19.710 --> 00:41:21.950
because they didn't actually
understand what it was.

00:41:21.950 --> 00:41:23.700
They have a starting
window, and then they

00:41:23.700 --> 00:41:25.882
have a splash screen
that's completely separate,

00:41:25.882 --> 00:41:27.340
and then they have
the game screen.

00:41:27.340 --> 00:41:29.131
So then you have three
completely different

00:41:29.131 --> 00:41:31.850
experiences over
time, which is nice,

00:41:31.850 --> 00:41:34.390
if you want different
experiences, but kind of sucks.

00:41:34.390 --> 00:41:35.890
What they should
actually do instead

00:41:35.890 --> 00:41:38.357
is remove their splash
screen, and take their logo,

00:41:38.357 --> 00:41:39.940
take their branding
situation, and use

00:41:39.940 --> 00:41:42.060
that as a background on the
starting window instead.

00:41:42.060 --> 00:41:44.435
Then, they get the benefit of
having the starting window,

00:41:44.435 --> 00:41:46.990
so that the system knows what
to do before the activity is

00:41:46.990 --> 00:41:49.120
actually up and
running, and then

00:41:49.120 --> 00:41:50.770
they also get to
brand that as well

00:41:50.770 --> 00:41:52.311
and have the splash
screen experience

00:41:52.311 --> 00:41:54.660
before their application starts.

00:41:54.660 --> 00:41:56.590
There's some tips about
avoiding UI stalls.

00:41:56.590 --> 00:41:59.430
So the UI thread really
likes to run and keep

00:41:59.430 --> 00:42:00.930
running, otherwise,
the user's going

00:42:00.930 --> 00:42:05.470
to sit there looking at a frame
while it's actually busy doing

00:42:05.470 --> 00:42:06.930
something that it shouldn't be.

00:42:06.930 --> 00:42:09.810
So inflation tends
to be expensive,

00:42:09.810 --> 00:42:13.230
so try not to inflate
when you don't have, to

00:42:13.230 --> 00:42:15.840
or try to minimize the amount
of inflation happening.

00:42:15.840 --> 00:42:17.930
If you have a really
complex view hierarchy,

00:42:17.930 --> 00:42:20.530
maybe you didn't need
all of that all the time.

00:42:20.530 --> 00:42:22.560
Maybe you could actually
use view stubs in there

00:42:22.560 --> 00:42:25.510
and inflate other stuff
on-the-fly as necessary,

00:42:25.510 --> 00:42:29.750
instead of having like, I don't
know, Play Store-like hierarchy

00:42:29.750 --> 00:42:31.340
that gets inflated
on-the-fly whenever

00:42:31.340 --> 00:42:33.080
you launch your activity.

00:42:33.080 --> 00:42:35.410
That would be nice.

00:42:35.410 --> 00:42:36.385
Now, handling events.

00:42:39.200 --> 00:42:42.190
When you get an
event, it's nice to do

00:42:42.190 --> 00:42:43.824
less expensive operations.

00:42:43.824 --> 00:42:45.490
It's nice, when someone
clicks a button,

00:42:45.490 --> 00:42:47.740
if you don't actually make
a network call, in general,

00:42:47.740 --> 00:42:48.719
or go to the database.

00:42:48.719 --> 00:42:50.760
You kind of want to do
that stuff asynchronously,

00:42:50.760 --> 00:42:54.260
off the UI thread, because
those events are being processed

00:42:54.260 --> 00:42:56.900
in the same thread that's
handling your animation

00:42:56.900 --> 00:43:00.070
events, your input events,
as well as your rendering

00:43:00.070 --> 00:43:00.959
events and layout.

00:43:00.959 --> 00:43:03.000
All of that stuff has to
happen on the UI thread.

00:43:03.000 --> 00:43:04.700
So anything that
you're doing that's not

00:43:04.700 --> 00:43:08.320
visual, that's not UI-related
should really happen elsewhere.

00:43:08.320 --> 00:43:10.980
Even if it will
end up in data that

00:43:10.980 --> 00:43:13.189
does populate the UI,
which a lot of this

00:43:13.189 --> 00:43:14.730
does-- like they
click on the button,

00:43:14.730 --> 00:43:16.350
that means some
transaction where

00:43:16.350 --> 00:43:19.020
we need to re-populate the data
that the user is looking at.

00:43:19.020 --> 00:43:21.710
That's great, but you don't have
to do it synchronously, right?

00:43:21.710 --> 00:43:24.340
So you could spawn an
asynchronous task, AsyncTask,

00:43:24.340 --> 00:43:27.440
or loader, or whatever,
to go get that data.

00:43:27.440 --> 00:43:30.190
And then, when it's back,
then you can populate the UI.

00:43:30.190 --> 00:43:32.220
In the meantime, the
user was actually

00:43:32.220 --> 00:43:34.060
able to interact with
your application,

00:43:34.060 --> 00:43:36.550
and it didn't seem so janky.

00:43:36.550 --> 00:43:39.000
Measuring and layout
is quite expensive.

00:43:39.000 --> 00:43:42.790
It's good to avoid it,
particularly during animations.

00:43:42.790 --> 00:43:47.360
So if you wanted to, let's
say, animate an object

00:43:47.360 --> 00:43:49.734
to move from one
location to another,

00:43:49.734 --> 00:43:51.900
you could actually animate
the layout params, right?

00:43:51.900 --> 00:43:54.230
You could change
the layout params

00:43:54.230 --> 00:43:57.680
that were causing that thing
to be positioned in the window.

00:43:57.680 --> 00:43:58.180
You could.

00:43:58.180 --> 00:44:00.690
And that's kind of the
physically correct thing to do.

00:44:00.690 --> 00:44:02.220
Well, change the layout params.

00:44:02.220 --> 00:44:03.632
That forces a re-layout.

00:44:03.632 --> 00:44:05.840
And then, it'll figure out
where it's supposed to be.

00:44:05.840 --> 00:44:07.200
And then, it'll draw it
at the correct place.

00:44:07.200 --> 00:44:10.040
And in the meantime, it's going
to run a lot slower than you

00:44:10.040 --> 00:44:10.700
wanted it to.

00:44:10.700 --> 00:44:11.650
You're going to miss
frames in there,

00:44:11.650 --> 00:44:13.780
depending on the complexity
of your hierarchy.

00:44:13.780 --> 00:44:16.080
It's a lot better
to actually animate

00:44:16.080 --> 00:44:19.440
with post-layout values, like
translation x translation y.

00:44:19.440 --> 00:44:22.470
Don't change the layout
params, which force a layout.

00:44:22.470 --> 00:44:26.300
Instead, animate something
that makes it visually correct,

00:44:26.300 --> 00:44:28.050
and then fix up the
layout at the end.

00:44:28.050 --> 00:44:30.240
Or a typical technique
that we use in animations

00:44:30.240 --> 00:44:33.210
is figure out where
it's going to be

00:44:33.210 --> 00:44:35.060
at the end of the animation.

00:44:35.060 --> 00:44:36.786
So it'll run layout,
it'll figure out

00:44:36.786 --> 00:44:37.660
where it needs to be.

00:44:37.660 --> 00:44:40.125
And then, you've set an
onPreDrawListener on it.

00:44:40.125 --> 00:44:41.750
And then, in your on
onPreDrawListener,

00:44:41.750 --> 00:44:44.700
you say, OK, well, I know I want
to animate to this other spot

00:44:44.700 --> 00:44:45.200
down there.

00:44:45.200 --> 00:44:46.991
So I'm going to run an
animation, basically

00:44:46.991 --> 00:44:49.820
rewind to where it was
before, and then run forward

00:44:49.820 --> 00:44:52.150
to the new layout location.

00:44:52.150 --> 00:44:55.270
So basically, running
translation y from negative 100

00:44:55.270 --> 00:44:56.035
to zero.

00:44:56.035 --> 00:44:57.910
This is essentially the
approach that we used

00:44:57.910 --> 00:44:59.620
in the transitions package.

00:44:59.620 --> 00:45:01.730
We put an onPreDrawListener.

00:45:01.730 --> 00:45:02.855
We figure out where it was.

00:45:02.855 --> 00:45:03.780
We figure out where it's going.

00:45:03.780 --> 00:45:05.905
And then we set up the
animation to rewind and then

00:45:05.905 --> 00:45:07.760
play forward.

00:45:07.760 --> 00:45:11.660
Drawing-- in general, that's
related to the allocation

00:45:11.660 --> 00:45:14.150
concerns and the amount of
operations you're actually

00:45:14.150 --> 00:45:18.367
doing in the onDraw and then the
animation concerns, in general.

00:45:18.367 --> 00:45:20.950
Just be aware that, when you're
in the middle of an animation,

00:45:20.950 --> 00:45:23.270
every expensive
operation you're doing,

00:45:23.270 --> 00:45:25.850
or every memory allocation
could be contributing

00:45:25.850 --> 00:45:27.200
to missing a frame.

00:45:27.200 --> 00:45:28.770
It may not seem like
that big a deal.

00:45:28.770 --> 00:45:30.540
Like 30 frames a
second, 60 frames

00:45:30.540 --> 00:45:32.700
a second, it's still
moving on the screen.

00:45:32.700 --> 00:45:35.290
The real problem comes in
when it's inconsistent.

00:45:35.290 --> 00:45:38.090
So if you're typically able
to get 60 frames a second,

00:45:38.090 --> 00:45:40.560
but eventually a GC kicks in
because you were allocating

00:45:40.560 --> 00:45:43.680
a bunch of stuff in
onDraw or whatever,

00:45:43.680 --> 00:45:46.180
then there will be a
skipped frame in the middle.

00:45:46.180 --> 00:45:49.140
So yeah, 30 frames a second
is reasonably smooth,

00:45:49.140 --> 00:45:50.490
if it was consistent.

00:45:50.490 --> 00:45:53.840
But going from 60 down
to 30 and then back to 60

00:45:53.840 --> 00:45:56.100
causes a hiccup that's very
noticeable to the user.

00:45:56.100 --> 00:45:58.780
In the middle, it's going to
pause just slightly and then

00:45:58.780 --> 00:46:01.130
skip forward longer than
it would have if it had

00:46:01.130 --> 00:46:04.620
a smooth frame rate instead.

00:46:04.620 --> 00:46:07.222
Avoid complex view hierarchies--
I alluded to this before.

00:46:07.222 --> 00:46:08.930
Like don't have more
views than you need.

00:46:08.930 --> 00:46:11.370
Don't have deeper nested
layouts than you need.

00:46:11.370 --> 00:46:13.840
I pull out some applications
in Hierarchy Viewer--

00:46:13.840 --> 00:46:16.520
who's used Hierarchy Viewer?

00:46:16.520 --> 00:46:17.830
OK, good.

00:46:17.830 --> 00:46:18.500
Getting there.

00:46:18.500 --> 00:46:19.333
We're getting there.

00:46:19.333 --> 00:46:20.670
We'd like 100% someday.

00:46:20.670 --> 00:46:23.400
It's a really good way to
get a mental model of what

00:46:23.400 --> 00:46:25.360
your application looks
like on the inside, what

00:46:25.360 --> 00:46:29.560
the model and the container
hierarchy is like.

00:46:29.560 --> 00:46:31.790
I've seen some
applications that have

00:46:31.790 --> 00:46:34.675
this long tail of
containers where they've

00:46:34.675 --> 00:46:36.300
got a relative layout,
and then there's

00:46:36.300 --> 00:46:37.924
a linear layer inside
of that, and then

00:46:37.924 --> 00:46:38.990
there's a frame layout.

00:46:38.990 --> 00:46:40.630
Each one of these
things, it had a purpose.

00:46:40.630 --> 00:46:41.921
Somebody had a reason for that.

00:46:41.921 --> 00:46:43.974
Like, I want to have
this background here.

00:46:43.974 --> 00:46:45.390
And then there's
this other layout

00:46:45.390 --> 00:46:48.730
that's tuned to have the right
fringe effect on-- I don't

00:46:48.730 --> 00:46:50.170
know what their reasoning was.

00:46:50.170 --> 00:46:52.715
I'm sure there was a good
one, but not good enough.

00:46:52.715 --> 00:46:54.090
What you want to
do is figure out

00:46:54.090 --> 00:46:56.614
how to have the single
container that needed,

00:46:56.614 --> 00:46:58.530
instead of the long
nested thing that's simply

00:46:58.530 --> 00:47:02.100
going to cause more
overhead for inflation,

00:47:02.100 --> 00:47:05.210
for layouts traversal, for
rendering, all of this stuff.

00:47:05.210 --> 00:47:08.310
Every layer in a
hierarchy is just

00:47:08.310 --> 00:47:10.300
causing more work for
the framework every time

00:47:10.300 --> 00:47:12.370
we need to redraw you.

00:47:12.370 --> 00:47:14.550
Also, relative
layout is probably

00:47:14.550 --> 00:47:16.600
the most flexible layout.

00:47:16.600 --> 00:47:20.520
It allows you to do the
association with sibling views,

00:47:20.520 --> 00:47:22.816
and the stuff on
the side, and I want

00:47:22.816 --> 00:47:23.940
to align this next to that.

00:47:23.940 --> 00:47:27.500
So it's the most flexible,
which is why, unfortunately, it

00:47:27.500 --> 00:47:28.940
is the layout that
we use when you

00:47:28.940 --> 00:47:32.810
create a new project
in Android Studio.

00:47:32.810 --> 00:47:35.934
This is not something I'm
real happy about right now.

00:47:35.934 --> 00:47:37.600
We would like to
change this eventually.

00:47:37.600 --> 00:47:40.010
The problem is that
relative layout causes

00:47:40.010 --> 00:47:42.130
us to measure twice, right?

00:47:42.130 --> 00:47:45.030
So if you are associating
views with other views,

00:47:45.030 --> 00:47:48.050
that means we're going to ask
all the views how big they

00:47:48.050 --> 00:47:50.989
want to be and where
they want to be.

00:47:50.989 --> 00:47:53.030
Well, we're going to ask
how big they want to be,

00:47:53.030 --> 00:47:54.500
because we need to figure
out where to put them.

00:47:54.500 --> 00:47:56.040
So we're going to
ask all of them,

00:47:56.040 --> 00:47:57.440
and we're going to take
all this information

00:47:57.440 --> 00:47:58.690
and we'll crunch
on it a little bit.

00:47:58.690 --> 00:48:01.080
And we'll say, OK, we know
how big everyone wants to be.

00:48:01.080 --> 00:48:03.340
Now, we have more
information about all

00:48:03.340 --> 00:48:05.169
the relative locations
and sizes of things,

00:48:05.169 --> 00:48:06.710
we're going to ask
you one more time.

00:48:06.710 --> 00:48:10.130
So it's going to measure twice
before it actually lays out.

00:48:10.130 --> 00:48:13.160
So if you have a relative
layout at the top,

00:48:13.160 --> 00:48:16.270
basically, you're measuring
every view in the hierarchy

00:48:16.270 --> 00:48:17.190
twice.

00:48:17.190 --> 00:48:20.450
Or even worse, what we've seen
is nested relative layouts.

00:48:20.450 --> 00:48:22.950
And then you basically
double it for every layer

00:48:22.950 --> 00:48:23.730
in the hierarchy.

00:48:23.730 --> 00:48:26.300
So a relative layout sitting
beneath another relative

00:48:26.300 --> 00:48:28.160
layout, you're measuring
all the children

00:48:28.160 --> 00:48:30.060
of that nested one four times.

00:48:30.060 --> 00:48:31.730
Probably a bad idea.

00:48:31.730 --> 00:48:33.670
So if you don't need
a relative layout--

00:48:33.670 --> 00:48:35.430
we understand that,
in some situations,

00:48:35.430 --> 00:48:38.900
you need it, usually not at the
top level of your hierarchy.

00:48:38.900 --> 00:48:41.180
It's usually needed
at a container level

00:48:41.180 --> 00:48:43.590
where you actually need the
association of the siblings

00:48:43.590 --> 00:48:44.910
or whatever.

00:48:44.910 --> 00:48:47.090
So go ahead and use it
when you need it, but be

00:48:47.090 --> 00:48:48.960
aware of the overhead of it.

00:48:48.960 --> 00:48:51.600
And try not to put it
at a really high level.

00:48:51.600 --> 00:48:53.030
And certainly try
not to nest it.

00:48:53.030 --> 00:48:53.530
Yes?

00:48:53.530 --> 00:48:54.496
AUDIENCE: [INAUDIBLE]?

00:48:58.587 --> 00:49:00.670
CHET HAASE: Is it better
to have a relative layout

00:49:00.670 --> 00:49:01.750
with a lot of views?

00:49:01.750 --> 00:49:03.000
Or a nested linear layout?

00:49:03.000 --> 00:49:07.220
It probably depends on-- so the
answer is, always, it depends.

00:49:07.220 --> 00:49:10.920
It depends on how high up
in the hierarchy it is.

00:49:10.920 --> 00:49:13.242
So if it's sitting
at the top, then it's

00:49:13.242 --> 00:49:14.700
going to cause all
of that overhead

00:49:14.700 --> 00:49:16.199
to everything sitting
underneath it.

00:49:16.199 --> 00:49:18.302
If it's at the bottom
of your hierarchy,

00:49:18.302 --> 00:49:20.010
it's not going to
cause that much, right?

00:49:20.010 --> 00:49:21.801
You're going to be
measuring all the views,

00:49:21.801 --> 00:49:23.780
but you wanted to
do that anyway.

00:49:23.780 --> 00:49:25.650
Like you wanted those
sibling associations.

00:49:25.650 --> 00:49:26.750
That's probably fine.

00:49:26.750 --> 00:49:29.469
Nested linear layout
also has its own overhead

00:49:29.469 --> 00:49:30.260
associated with it.

00:49:30.260 --> 00:49:32.140
So it doesn't measure
twice, but you just

00:49:32.140 --> 00:49:34.220
added a bunch of
layers in there.

00:49:34.220 --> 00:49:36.991
It's also worth
considering custom layouts

00:49:36.991 --> 00:49:37.740
at some point too.

00:49:37.740 --> 00:49:40.130
If you find yourself
tying yourself in knots

00:49:40.130 --> 00:49:42.540
and adding more and more
nested linear layouts

00:49:42.540 --> 00:49:44.890
to get the particular
effect you wanted

00:49:44.890 --> 00:49:46.850
with all right padding
and associations

00:49:46.850 --> 00:49:49.440
between all the different
subviews and sub containment

00:49:49.440 --> 00:49:51.390
hierarchies, at some
point, it's much more

00:49:51.390 --> 00:49:54.040
optimal to simply
create a custom layout.

00:49:54.040 --> 00:49:57.170
So you subclass ViewGroup, or
you subclass some layout that

00:49:57.170 --> 00:49:58.580
does most of what you want.

00:49:58.580 --> 00:50:00.600
And then you do your own
measure in the layout.

00:50:00.600 --> 00:50:04.580
And that'll probably save
you time in the long run.

00:50:04.580 --> 00:50:06.930
Launch fast-- go ahead
and try to get the UI up

00:50:06.930 --> 00:50:08.074
as quickly as possible.

00:50:08.074 --> 00:50:09.490
This pertains to
some of the stuff

00:50:09.490 --> 00:50:11.470
I was talking about
before, like not doing

00:50:11.470 --> 00:50:14.690
too much in static
initializers, like not inflating

00:50:14.690 --> 00:50:17.640
all of the views that you might
possibly need in the future.

00:50:17.640 --> 00:50:20.210
Instead, just get up and
face the user with something

00:50:20.210 --> 00:50:20.970
quickly.

00:50:20.970 --> 00:50:22.440
Otherwise, they
click the button,

00:50:22.440 --> 00:50:24.529
they've seen the
starting window,

00:50:24.529 --> 00:50:26.820
and then four seconds later,
they see your application.

00:50:26.820 --> 00:50:27.944
Horrible experience, right?

00:50:27.944 --> 00:50:29.460
Wouldn't it be
better to be faced

00:50:29.460 --> 00:50:31.430
with a simple UI that
could then populate

00:50:31.430 --> 00:50:34.210
itself later as necessary?

00:50:34.210 --> 00:50:35.297
Defer the extra work.

00:50:35.297 --> 00:50:37.130
If you didn't need those
fields initialized,

00:50:37.130 --> 00:50:39.960
maybe you could actually
initialize them lazily instead.

00:50:39.960 --> 00:50:41.700
And also, measure cold starts.

00:50:41.700 --> 00:50:46.360
So when your
application starts, it's

00:50:46.360 --> 00:50:48.910
important to understand the
different dynamics of what

00:50:48.910 --> 00:50:50.360
state it was starting from.

00:50:50.360 --> 00:50:53.550
So when it started from the
first time after a reboot,

00:50:53.550 --> 00:50:55.660
that's what we refer
to as a cold start.

00:50:55.660 --> 00:50:57.160
This means it's all
the work that we

00:50:57.160 --> 00:50:58.850
had to do to actually
read in the APK,

00:50:58.850 --> 00:51:01.570
to load all the classes, to
initialize all the stuff,

00:51:01.570 --> 00:51:04.419
and then to do the first layout
and rendering of that thing.

00:51:04.419 --> 00:51:06.960
There's the window animation,
but let the Window Manager deal

00:51:06.960 --> 00:51:07.520
with that.

00:51:07.520 --> 00:51:09.280
It's all the stuff
they were doing inside

00:51:09.280 --> 00:51:12.540
of your application, to simply
get to the first frame that

00:51:12.540 --> 00:51:13.920
is displayed.

00:51:13.920 --> 00:51:16.897
So it's important to understand
how much time that takes

00:51:16.897 --> 00:51:18.230
and to measure it appropriately.

00:51:18.230 --> 00:51:19.725
So if you launch
your application,

00:51:19.725 --> 00:51:21.100
and then you hit
the Home button,

00:51:21.100 --> 00:51:23.500
and then you launch it
again, your application,

00:51:23.500 --> 00:51:26.150
depending on the amount of
memory available on the system,

00:51:26.150 --> 00:51:27.790
was probably still
resident in memory.

00:51:27.790 --> 00:51:30.010
So all we really needed to
do was display it again.

00:51:30.010 --> 00:51:31.100
We re-rendered it.

00:51:31.100 --> 00:51:31.711
Period.

00:51:31.711 --> 00:51:32.210
Right?

00:51:32.210 --> 00:51:34.399
We didn't reload it.

00:51:34.399 --> 00:51:36.690
In a lot of cases, we didn't
need to do another layout.

00:51:36.690 --> 00:51:39.330
We're basically just showing the
same thing that we had before.

00:51:39.330 --> 00:51:40.260
So you're like, this is great.

00:51:40.260 --> 00:51:41.740
I can start in 50 milliseconds.

00:51:41.740 --> 00:51:43.060
I'm super fast.

00:51:43.060 --> 00:51:45.890
And then the next time you
reboot, it takes four seconds.

00:51:45.890 --> 00:51:48.790
So what you want to do to really
get a better measurement is

00:51:48.790 --> 00:51:50.320
actually kill the task, right?

00:51:50.320 --> 00:51:52.530
So go into Recents and
swipe it out of the way.

00:51:52.530 --> 00:51:54.940
And that'll get you most of
the way toward the situation

00:51:54.940 --> 00:51:56.610
of a cold start from reboot.

00:51:56.610 --> 00:51:57.610
So get it out of memory.

00:51:57.610 --> 00:52:01.320
Make sure that we're actually
dragging in all of the stuff

00:52:01.320 --> 00:52:04.900
again, to really understand how
much time your application is

00:52:04.900 --> 00:52:05.799
taking to launch.

00:52:05.799 --> 00:52:07.590
I want to talk about
some of the tools that

00:52:07.590 --> 00:52:08.780
are important to use.

00:52:08.780 --> 00:52:11.240
Hopefully, everybody
uses most of these.

00:52:11.240 --> 00:52:14.140
Systrace, I talked about
a little bit yesterday.

00:52:14.140 --> 00:52:16.110
Colt talked about it as well.

00:52:16.110 --> 00:52:17.500
Super powerful tool.

00:52:17.500 --> 00:52:18.310
Super confusing.

00:52:18.310 --> 00:52:19.871
There's so much
information in there.

00:52:19.871 --> 00:52:20.870
There's so many options.

00:52:20.870 --> 00:52:23.180
You look at it, and you're
like, I see a lot of green.

00:52:23.180 --> 00:52:23.990
I see a lot of red.

00:52:23.990 --> 00:52:25.570
I don't know what
to do about it.

00:52:25.570 --> 00:52:29.340
We added to the tips, the little
circular bubbles in the middle.

00:52:29.340 --> 00:52:31.490
I would encourage you to
get the latest Systrace

00:52:31.490 --> 00:52:32.620
and play with that.

00:52:32.620 --> 00:52:34.270
Click on the tips and see
what it's trying to tell you.

00:52:34.270 --> 00:52:35.880
In general, the
problems that we've

00:52:35.880 --> 00:52:37.740
seen that we can do
some amount of analysis

00:52:37.740 --> 00:52:42.290
on in the tool now for you
tend to be common issues,

00:52:42.290 --> 00:52:45.080
like you're in the middle of an
animation, and you ran layout,

00:52:45.080 --> 00:52:48.450
or you're not reusing
the view when getView

00:52:48.450 --> 00:52:50.090
is called on your list view.

00:52:50.090 --> 00:52:52.469
So some simple things
that we noticed over,

00:52:52.469 --> 00:52:54.760
and over, and over again that
we now fed into the tool,

00:52:54.760 --> 00:52:56.650
so you can get for free.

00:52:56.650 --> 00:52:58.580
And then, once you start
using Systrace more,

00:52:58.580 --> 00:53:00.550
you start to understand,
OK, well, these

00:53:00.550 --> 00:53:02.310
are the VSYNC pulses.

00:53:02.310 --> 00:53:08.510
This is the amount of CPU usage
that was going on at the time.

00:53:08.510 --> 00:53:10.420
My thread is
sleeping, because it's

00:53:10.420 --> 00:53:12.360
tied to this other
event in surfaceflinger,

00:53:12.360 --> 00:53:14.077
which was processing the GL.

00:53:14.077 --> 00:53:15.660
There's a lot of
associations that you

00:53:15.660 --> 00:53:17.939
can get over time and
practice with using the tool.

00:53:17.939 --> 00:53:19.480
But it's really the
only tool that we

00:53:19.480 --> 00:53:23.420
have that gives you the big
picture of what was actually

00:53:23.420 --> 00:53:26.090
going on in the device that was
causing the jank that you see.

00:53:26.090 --> 00:53:28.430
And you can see the jank
in the output there.

00:53:28.430 --> 00:53:30.190
You can see, I've
got regular pulses.

00:53:30.190 --> 00:53:33.190
I'm doing my
performTraversals, which

00:53:33.190 --> 00:53:36.240
is the rendering loop in the UI
thread, on every single frame.

00:53:36.240 --> 00:53:37.620
And then I skip three frames.

00:53:37.620 --> 00:53:38.412
Why?

00:53:38.412 --> 00:53:39.870
That's what you
need to figure out,

00:53:39.870 --> 00:53:41.911
so that you can fix the
jank in your application.

00:53:41.911 --> 00:53:44.850
Allocation tracker, super
useful for all of the memory

00:53:44.850 --> 00:53:46.730
stuff that I was
talking about before.

00:53:46.730 --> 00:53:51.630
So obviously, we're
using a VM here,

00:53:51.630 --> 00:53:53.580
runtime that's going to
be allocating objects.

00:53:53.580 --> 00:53:54.800
You can't avoid allocations.

00:53:54.800 --> 00:53:56.250
What you should
try to do is avoid

00:53:56.250 --> 00:53:59.050
allocating during times when
you know it could cause jank

00:53:59.050 --> 00:53:59.880
for the user.

00:53:59.880 --> 00:54:03.020
So run that animation,
and then see

00:54:03.020 --> 00:54:04.989
what's being allocated
during the animation.

00:54:04.989 --> 00:54:06.530
And make sure that
all of the objects

00:54:06.530 --> 00:54:08.490
are not actually come
in from your code.

00:54:08.490 --> 00:54:10.140
Ideally, there would
be no allocations

00:54:10.140 --> 00:54:10.940
during the animation.

00:54:10.940 --> 00:54:12.540
But if you can't fix
that, you can at least

00:54:12.540 --> 00:54:14.540
fix the ones that are
coming from your code that

00:54:14.540 --> 00:54:17.700
don't actually need to
happen during the animation.

00:54:17.700 --> 00:54:19.700
Traceview, there's
two versions of it.

00:54:19.700 --> 00:54:24.590
There's a sampling, as well as
non-sampling-- instrumented?

00:54:24.590 --> 00:54:26.860
What's the other way
they refer to it?

00:54:26.860 --> 00:54:29.090
What do you-- sampling
means, OK, it's

00:54:29.090 --> 00:54:31.350
going to look occasionally
and see where it's at.

00:54:31.350 --> 00:54:33.220
This has very low
overhead, which

00:54:33.220 --> 00:54:35.740
means you're going to
get reasonable times back

00:54:35.740 --> 00:54:38.577
for how long these
various things are taking.

00:54:38.577 --> 00:54:40.410
But it's not going to
give you the full call

00:54:40.410 --> 00:54:43.002
stack for where the code
was at any point in time.

00:54:43.002 --> 00:54:45.210
So you want to use the
instrumented version, instead,

00:54:45.210 --> 00:54:46.835
if you're trying to
understand the code

00:54:46.835 --> 00:54:50.590
flow in how you actually got to
this at that particular time.

00:54:50.590 --> 00:54:54.000
However, that has a fair amount
of overhead associated with it

00:54:54.000 --> 00:54:56.200
just in each of
the method calls,

00:54:56.200 --> 00:54:59.710
so make sure that you're not
optimizing the wrong thing.

00:54:59.710 --> 00:55:01.410
Don't look at the
raw, absolute times

00:55:01.410 --> 00:55:02.710
you're getting out of
Traceview, if you're

00:55:02.710 --> 00:55:05.460
using the instrumented version,
because the times that it's

00:55:05.460 --> 00:55:07.710
reporting for method
calls is really

00:55:07.710 --> 00:55:08.940
out of whack with reality.

00:55:08.940 --> 00:55:12.470
I have optimized stuff before
and saved zero time in the end

00:55:12.470 --> 00:55:15.554
result, just because it
wasn't really giving me

00:55:15.554 --> 00:55:16.470
the right information.

00:55:16.470 --> 00:55:18.810
So it's useful for
understanding the flow

00:55:18.810 --> 00:55:21.750
and for relative times,
but don't take the numbers

00:55:21.750 --> 00:55:24.690
to seriously if you're using
the instrumented version.

00:55:24.690 --> 00:55:26.340
Hierarchy Viewer, we
talked about that.

00:55:26.340 --> 00:55:29.480
MAT, I would also call out
the new Memory Analysis

00:55:29.480 --> 00:55:31.830
Tool in Android Studio.

00:55:31.830 --> 00:55:34.302
Memory Monitor--
I think-- there's

00:55:34.302 --> 00:55:35.510
a couple of new memory tools.

00:55:35.510 --> 00:55:37.551
One of them is Memory
Monitor that just shows you

00:55:37.551 --> 00:55:38.970
the use of memory over time.

00:55:38.970 --> 00:55:42.550
The other one actually
analyzes leaks and dependencies

00:55:42.550 --> 00:55:43.780
in the graph.

00:55:43.780 --> 00:55:45.317
So check that one out.

00:55:45.317 --> 00:55:47.150
Should be a lot easier
to use and more tuned

00:55:47.150 --> 00:55:51.150
for Android dynamics than
MAT, which is an Eclipse tool.

00:55:51.150 --> 00:55:55.040
So basically, to use MAT,
you take a heap dump,

00:55:55.040 --> 00:55:56.790
and then you go into
MAT and you basically

00:55:56.790 --> 00:56:00.830
see what objects are still
alive that you didn't expect.

00:56:00.830 --> 00:56:04.330
So this is where you find out
things like activity leaks.

00:56:04.330 --> 00:56:07.110
But as I said, there's
possibly an easier tool

00:56:07.110 --> 00:56:09.190
to use in Android
Studio for that.

00:56:09.190 --> 00:56:12.180
There's also an external tool
put out by the folks at Square,

00:56:12.180 --> 00:56:15.740
called LeakCanary, that I would
suggest you check out as well.

00:56:15.740 --> 00:56:18.720
Memory Monitor, I just mentioned
that, for Android Studio.

00:56:18.720 --> 00:56:20.200
And then there's
on-device tools.

00:56:20.200 --> 00:56:22.270
So those were tools that
you run on the host,

00:56:22.270 --> 00:56:24.622
on your desktop machine.

00:56:24.622 --> 00:56:26.080
But then there's
device tools where

00:56:26.080 --> 00:56:28.330
you can see, in real time,
some of the information

00:56:28.330 --> 00:56:30.420
that you need to
tune performance.

00:56:30.420 --> 00:56:31.260
There's Strict mode.

00:56:31.260 --> 00:56:32.635
You can enable
that, and it'll do

00:56:32.635 --> 00:56:35.000
a red flash whenever your
code is doing something

00:56:35.000 --> 00:56:36.910
that it shouldn't
on the UI thread,

00:56:36.910 --> 00:56:40.300
like making a network access,
or disc access, or whatever.

00:56:40.300 --> 00:56:42.699
GPU profiling,
there's the overdraw

00:56:42.699 --> 00:56:43.740
set that we talked about.

00:56:43.740 --> 00:56:45.960
There's also the
raw performance.

00:56:45.960 --> 00:56:47.510
It'll put colored
bars on the screen

00:56:47.510 --> 00:56:49.200
to show you how much
time you're taking

00:56:49.200 --> 00:56:51.960
in each of the various
phases of rendering.

00:56:51.960 --> 00:56:53.847
So it'll show you
whether there's

00:56:53.847 --> 00:56:55.680
a spike at a particular
time, because you're

00:56:55.680 --> 00:56:59.200
getting inconsistent
results from this thing,

00:56:59.200 --> 00:57:01.310
or whether you're just
consistently taking

00:57:01.310 --> 00:57:04.350
too much time creating
all the rendering objects,

00:57:04.350 --> 00:57:06.380
or whatever it is.

00:57:06.380 --> 00:57:09.004
Duration scale, this is useful
if you want to just slow down

00:57:09.004 --> 00:57:10.920
your animations so you
can see what's actually

00:57:10.920 --> 00:57:12.200
going on on the screen.

00:57:12.200 --> 00:57:15.080
I actually find Screen Record
to be a much more useful tool

00:57:15.080 --> 00:57:18.064
for debugging animations,
because I really

00:57:18.064 --> 00:57:19.480
wanted to see it
run in real time,

00:57:19.480 --> 00:57:22.000
it's just that my eyes
don't work that fast.

00:57:22.000 --> 00:57:24.260
So I'll do a Screen
Record, and then

00:57:24.260 --> 00:57:27.170
upload the MP4 from the device.

00:57:27.170 --> 00:57:31.340
And then I can frame step it
in some animation tool, or just

00:57:31.340 --> 00:57:32.621
a movie player.

00:57:32.621 --> 00:57:34.870
And then I can see what
happened on every single frame

00:57:34.870 --> 00:57:37.936
to try to track the artifacts
or the problems there.

00:57:37.936 --> 00:57:39.310
Then Hardware
Layer Updates, this

00:57:39.310 --> 00:57:41.577
is another visual tool on
the device that shows you

00:57:41.577 --> 00:57:43.660
when you're updating
information that is currently

00:57:43.660 --> 00:57:46.590
cached in a layer, which
is generally a no-no.

00:57:46.590 --> 00:57:48.650
I would say that
there's time for Q&amp;A,

00:57:48.650 --> 00:57:52.160
except for the fact that the
timer is running out right now.

00:57:52.160 --> 00:57:53.570
So thanks, for coming.

00:57:53.570 --> 00:57:55.370
[APPLAUSE]

00:57:55.370 --> 00:57:56.920
[MUSIC PLAYING]

