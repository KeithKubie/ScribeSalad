WEBVTT
Kind: captions
Language: en

00:00:10.032 --> 00:00:12.240
RAUL: So I think that should
be our slogan for Google

00:00:12.240 --> 00:00:14.780
Analytics. "It's so easy to
use even a product manager can

00:00:14.780 --> 00:00:15.280
use it."

00:00:15.280 --> 00:00:15.665
What do you think?

00:00:15.665 --> 00:00:17.956
MALE SPEAKER: I Think we
should go all the way and say,

00:00:17.956 --> 00:00:19.750
so easy to use even
Raul can use it.

00:00:19.750 --> 00:00:22.250
RAUL: And that'll just be out
there for the entire internet.

00:00:22.250 --> 00:00:24.115
MALE SPEAKER: Companies around
the world will all look at Raul

00:00:24.115 --> 00:00:25.440
and they'll be like,
there you go, dude.

00:00:25.440 --> 00:00:26.230
RAUL: Yeah.

00:00:26.230 --> 00:00:28.680
MALE SPEAKER: You're
our new GA guy.

00:00:28.680 --> 00:00:31.820
So I think it's
clear to everybody

00:00:31.820 --> 00:00:34.699
that in this modern ecosystem
of game development,

00:00:34.699 --> 00:00:36.490
one of the most important
things you can do

00:00:36.490 --> 00:00:40.070
is ensure that your game runs
across tons of different form

00:00:40.070 --> 00:00:40.850
factors.

00:00:40.850 --> 00:00:42.310
Different screen resolutions.

00:00:42.310 --> 00:00:44.520
Different types of
memory profiles.

00:00:44.520 --> 00:00:47.969
GPU characteristics and whatnot.

00:00:47.969 --> 00:00:49.760
And this is a problem
for all of us, right?

00:00:49.760 --> 00:00:51.176
I mean, you have
to figure out how

00:00:51.176 --> 00:00:53.195
to write your code once,
but yet distribute it

00:00:53.195 --> 00:00:55.770
to hundreds or thousands
of different configurations

00:00:55.770 --> 00:00:56.570
of devices.

00:00:56.570 --> 00:00:58.519
And that gets really gnarly.

00:00:58.519 --> 00:00:59.810
Anyone had that problem before?

00:00:59.810 --> 00:01:01.020
Or is it just me?

00:01:01.020 --> 00:01:02.120
One dude.

00:01:02.120 --> 00:01:04.150
Someone find him a t-shirt.

00:01:04.150 --> 00:01:04.650
See?

00:01:04.650 --> 00:01:07.360
The rest of you wish
you'd raised your hands.

00:01:07.360 --> 00:01:09.490
Anyhow, up next to
describe a little bit more

00:01:09.490 --> 00:01:11.920
how to solve this
problem at its core level

00:01:11.920 --> 00:01:14.545
with some amazing technology
that you're going to love

00:01:14.545 --> 00:01:15.610
is Neil and Lukas.

00:01:15.610 --> 00:01:16.530
Big round of applause.

00:01:21.634 --> 00:01:23.500
LUKAS BERGSTROM: Hi everybody.

00:01:23.500 --> 00:01:25.550
Great to see so many
people here today.

00:01:25.550 --> 00:01:26.970
I'm Lukas Bergstrom.

00:01:26.970 --> 00:01:29.520
I'm the product manager
for Google Tag Manager.

00:01:29.520 --> 00:01:33.760
And we got Neil Rhodes here,
as well, who's the tech lead.

00:01:33.760 --> 00:01:37.620
And I think we've talked a
lot about measurement so far.

00:01:37.620 --> 00:01:39.232
We talked some
about advertising.

00:01:39.232 --> 00:01:40.690
We're going to talk
about something

00:01:40.690 --> 00:01:41.814
a little bit different now.

00:01:41.814 --> 00:01:45.720
So we're going to talk
about not just measuring

00:01:45.720 --> 00:01:46.570
what's happening.

00:01:46.570 --> 00:01:52.110
Or trying to advertise to get
people to incentivize behavior.

00:01:52.110 --> 00:01:54.630
Or tell people about things
you're interested in.

00:01:54.630 --> 00:01:57.610
But we're going to talk about
the core behavior of your app.

00:01:57.610 --> 00:01:59.190
How is your app configured?

00:01:59.190 --> 00:02:01.090
And how can you control that?

00:02:01.090 --> 00:02:05.380
So I think we're all familiar
with the app store model,

00:02:05.380 --> 00:02:06.750
right?

00:02:06.750 --> 00:02:08.630
You build an app.

00:02:08.630 --> 00:02:12.130
You hopefully get
it through review.

00:02:12.130 --> 00:02:13.600
You get it shipped
out to people.

00:02:13.600 --> 00:02:17.210
And with any luck, some
reasonable number of people

00:02:17.210 --> 00:02:19.640
will upgrade to
your newest version

00:02:19.640 --> 00:02:21.320
at some reasonable time.

00:02:21.320 --> 00:02:23.570
In the web world, we're used
to something a little bit

00:02:23.570 --> 00:02:24.350
different, right?

00:02:24.350 --> 00:02:26.340
We're used a rapid iteration.

00:02:26.340 --> 00:02:28.410
We're used to being
able to ship something.

00:02:28.410 --> 00:02:31.290
And then if we know is that
something isn't quite right,

00:02:31.290 --> 00:02:34.570
we can update things live.

00:02:34.570 --> 00:02:37.010
And people who are
visiting our site

00:02:37.010 --> 00:02:39.450
will instantly see
those new changes.

00:02:39.450 --> 00:02:41.460
And so that's why
people get addicted

00:02:41.460 --> 00:02:44.280
to things like
analytics on the web.

00:02:44.280 --> 00:02:48.050
Because they can tweak knobs
and dials to improve outcomes.

00:02:48.050 --> 00:02:50.990
And instantly see how
that gets reflected.

00:02:50.990 --> 00:02:53.380
And that has a lot of really
positive outcomes in the web

00:02:53.380 --> 00:02:54.930
world.

00:02:54.930 --> 00:02:59.850
And we're big believers
in using real time data

00:02:59.850 --> 00:03:04.980
to allow you to have a
really tight feedback loop.

00:03:04.980 --> 00:03:08.300
That's harder in the app world.

00:03:08.300 --> 00:03:10.760
Once you ship something,
you're stuck with that.

00:03:10.760 --> 00:03:14.790
Until you can convince people
to install a new binary.

00:03:14.790 --> 00:03:19.320
So pretty much, once something
is shipped out to the store,

00:03:19.320 --> 00:03:20.610
it's set in stone.

00:03:20.610 --> 00:03:27.070
And what you're measuring in
the app, the configuration

00:03:27.070 --> 00:03:30.340
of different values,
so maybe what

00:03:30.340 --> 00:03:33.640
the text of an in-app promotion
is, what the text of a button

00:03:33.640 --> 00:03:37.190
is, or the frequency
of in-app promotions.

00:03:37.190 --> 00:03:39.870
All that stuff is
locked in the code

00:03:39.870 --> 00:03:42.640
and shipped along with
the static binary.

00:03:42.640 --> 00:03:47.370
So how does this
work in practice?

00:03:47.370 --> 00:03:49.750
You'll notice that this leaves
out a very important part,

00:03:49.750 --> 00:03:52.590
which is the actual
development process of getting

00:03:52.590 --> 00:03:54.300
a new binary out the door.

00:03:54.300 --> 00:03:56.130
Let's assume that
your guys' development

00:03:56.130 --> 00:03:58.810
process is pretty much perfect.

00:03:58.810 --> 00:04:02.060
You're agile, you're
hyper-efficient,

00:04:02.060 --> 00:04:05.740
you always ship
stuff right on time.

00:04:05.740 --> 00:04:11.030
Despite that, however, in order
for you to get changes out,

00:04:11.030 --> 00:04:14.740
you need to get
the binary built.

00:04:14.740 --> 00:04:17.050
Get it approved
in the App Store.

00:04:17.050 --> 00:04:18.519
And then you need
to actually get

00:04:18.519 --> 00:04:21.579
people to install
that new version.

00:04:21.579 --> 00:04:23.660
And even if everything
goes perfectly,

00:04:23.660 --> 00:04:25.660
that means that your
feedback loop, your ability

00:04:25.660 --> 00:04:31.490
to make changes, is a lot longer
than you would like to be.

00:04:31.490 --> 00:04:33.180
And this affects
not just developers,

00:04:33.180 --> 00:04:35.312
but anybody who's work
ends up in the app.

00:04:35.312 --> 00:04:37.270
So let's say that you're
a marketer, a business

00:04:37.270 --> 00:04:41.817
analyst, who's putting
together promotions.

00:04:41.817 --> 00:04:43.400
And you're trying
to figure out what's

00:04:43.400 --> 00:04:48.750
the most effective frequency
of showing in-app promotions?

00:04:48.750 --> 00:04:53.410
What kind of wording is going to
get people to convert the best?

00:04:53.410 --> 00:04:57.940
You need to, basically, ship
that along with the new binary.

00:04:57.940 --> 00:05:02.370
And so your ability
to kind of tune stuff.

00:05:02.370 --> 00:05:04.170
Measure the effect of that.

00:05:04.170 --> 00:05:10.060
And then go back for another
iteration is severely limited.

00:05:10.060 --> 00:05:12.880
So the solution is
what we're calling

00:05:12.880 --> 00:05:15.170
Google Tag Manager
for Mobile Apps.

00:05:15.170 --> 00:05:18.880
And Google Tag Manager, the
name comes from the web version.

00:05:18.880 --> 00:05:22.170
The web and the mobile version
have one principle in common.

00:05:22.170 --> 00:05:26.680
Which is, separate out your
configuration from your code.

00:05:26.680 --> 00:05:29.770
So the code has to stay
static for app review,

00:05:29.770 --> 00:05:32.250
but the configuration
can be dynamic.

00:05:32.250 --> 00:05:35.740
That can be controlled
by Google Tag Manager.

00:05:35.740 --> 00:05:37.710
And that gives you
a couple benefits.

00:05:37.710 --> 00:05:41.550
It means by decoupling
configuration from code,

00:05:41.550 --> 00:05:45.510
you can make changes to things
like what am I measuring?

00:05:45.510 --> 00:05:47.280
What do I consider
most important?

00:05:47.280 --> 00:05:51.910
Or what is the placement
of my in-app promotions?

00:05:51.910 --> 00:05:53.910
Where do they appear
in my user flow?

00:05:53.910 --> 00:05:55.810
Where they appear on the screen?

00:05:55.810 --> 00:05:57.110
How often do they appear?

00:05:57.110 --> 00:05:58.750
What's the wording?

00:05:58.750 --> 00:06:00.500
All of that stuff
can be controlled

00:06:00.500 --> 00:06:02.340
without shipping
a new app version.

00:06:02.340 --> 00:06:05.440
Which means you can push
changes as often as you like.

00:06:05.440 --> 00:06:09.340
Just by clicking publish
in Google Tag Manager.

00:06:09.340 --> 00:06:11.380
And this affects not
just developers but,

00:06:11.380 --> 00:06:14.860
as I was saying, anybody
whose work ends up in the app.

00:06:14.860 --> 00:06:16.650
So your marketers
and business analysts

00:06:16.650 --> 00:06:20.450
who are trying to optimize stuff
that happens inside your app,

00:06:20.450 --> 00:06:23.260
using Google Tag Manager
and decoupling configuration

00:06:23.260 --> 00:06:26.500
from code lets those
marketers do all that stuff

00:06:26.500 --> 00:06:28.040
without bugging you.

00:06:28.040 --> 00:06:30.990
So suddenly they've got a
much tighter feedback loop.

00:06:30.990 --> 00:06:35.310
A much tighter and faster
iteration and improvement loop.

00:06:35.310 --> 00:06:37.810
And you're freed up to
actually work on feature work

00:06:37.810 --> 00:06:40.200
because they can to get
stuff done without you.

00:06:40.200 --> 00:06:43.230
So I'm going to ask Neil to come
up right now, and explain you

00:06:43.230 --> 00:06:46.490
how this actually works.

00:06:46.490 --> 00:06:49.670
NEIL RHODES: Thanks
very much, Lukas.

00:06:49.670 --> 00:06:51.700
So as Lukas described,
what we really want to do

00:06:51.700 --> 00:06:53.604
is separate the
configuration from the data.

00:06:53.604 --> 00:06:55.020
And one thing I
want to make clear

00:06:55.020 --> 00:06:56.790
is, Google Tag Manager
for mobile apps

00:06:56.790 --> 00:07:00.070
has been out since
mid-last year.

00:07:00.070 --> 00:07:03.090
Although, I am pleased to say
we have a brand new feature

00:07:03.090 --> 00:07:05.730
that we'll be talking
about shortly.

00:07:05.730 --> 00:07:08.120
So you can really configure
virtually anything.

00:07:08.120 --> 00:07:11.390
What you basically have
are key value pairs.

00:07:11.390 --> 00:07:13.240
What sorts of things
can configure?

00:07:13.240 --> 00:07:15.010
Anything really you can code.

00:07:15.010 --> 00:07:16.410
You can configure add settings.

00:07:16.410 --> 00:07:17.970
How often am I
going to show ads?

00:07:17.970 --> 00:07:20.050
How often am I going
to show purchases?

00:07:20.050 --> 00:07:21.350
Where do those ads appear?

00:07:21.350 --> 00:07:22.780
And so on.

00:07:22.780 --> 00:07:25.070
Any network communication
that you're doing.

00:07:25.070 --> 00:07:27.400
You might want to
configure that.

00:07:27.400 --> 00:07:29.370
What host names
are you talking to?

00:07:29.370 --> 00:07:30.990
What are their timeouts?

00:07:30.990 --> 00:07:34.430
Game-play values can actually
be configured, if you'd like.

00:07:34.430 --> 00:07:37.550
You can configure
content of any URLs

00:07:37.550 --> 00:07:39.860
you might use for
help, or so on.

00:07:39.860 --> 00:07:41.160
Any UI settings.

00:07:41.160 --> 00:07:43.520
Locations of
particular UI elements.

00:07:43.520 --> 00:07:44.590
Their colors.

00:07:44.590 --> 00:07:48.150
Even your localized text can
be done via configuration.

00:07:48.150 --> 00:07:49.700
And any new sort
of announcements

00:07:49.700 --> 00:07:52.820
you want to make to users.

00:07:52.820 --> 00:07:54.199
Here's the basic way I think it.

00:07:54.199 --> 00:07:55.990
Currently in your
application, you probably

00:07:55.990 --> 00:07:58.160
have a lot of constants.

00:07:58.160 --> 00:08:02.510
That hard-code how
your application works.

00:08:02.510 --> 00:08:05.360
So as software developers,
we don't actually

00:08:05.360 --> 00:08:06.570
hard-code values.

00:08:06.570 --> 00:08:09.370
And have twos, and threes,
and magic numbers in our code.

00:08:09.370 --> 00:08:10.650
We do have constants.

00:08:10.650 --> 00:08:12.670
The problem is to
change those values,

00:08:12.670 --> 00:08:15.780
you need to recompile
your app and redeploy.

00:08:15.780 --> 00:08:18.710
By moving from using
constants, to instead,

00:08:18.710 --> 00:08:24.130
using more dynamic key value
pairs, you get this dynamism.

00:08:24.130 --> 00:08:28.410
What we call highly
configurable application.

00:08:28.410 --> 00:08:30.868
So you use a Google
Tag Manager container.

00:08:30.868 --> 00:08:32.659
And once you've
initialized that container,

00:08:32.659 --> 00:08:38.419
you can get the current
value of a particular key.

00:08:38.419 --> 00:08:40.760
As an example, and this
is just a simple example.

00:08:40.760 --> 00:08:43.780
We have here, on the left,
a configuration where

00:08:43.780 --> 00:08:48.640
we're setting, using
JSON, three values--

00:08:48.640 --> 00:08:50.430
the text for the
Register button,

00:08:50.430 --> 00:08:52.560
the text for the
try button, and also

00:08:52.560 --> 00:08:55.400
whether the try button is
on the left or the right.

00:08:55.400 --> 00:08:57.456
And we can see as it's
configured on the left,

00:08:57.456 --> 00:08:58.830
we have a try on
the left, and it

00:08:58.830 --> 00:09:00.460
says "register" on the right.

00:09:00.460 --> 00:09:02.580
If we change that
configuration, it

00:09:02.580 --> 00:09:04.360
changes the values
of those buttons.

00:09:04.360 --> 00:09:07.820
And also the order
of those buttons.

00:09:07.820 --> 00:09:09.650
Now, did you have to
write code for this?

00:09:09.650 --> 00:09:10.150
Yes.

00:09:10.150 --> 00:09:12.930
You had actually write code
to go get those values.

00:09:12.930 --> 00:09:14.310
And apply them to the buttons.

00:09:14.310 --> 00:09:16.950
So change the text of
the buttons, or reorder.

00:09:16.950 --> 00:09:19.700
But once you've done that,
you have a highly configurable

00:09:19.700 --> 00:09:20.990
application.

00:09:20.990 --> 00:09:24.420
You can imagine, most
parts of your application,

00:09:24.420 --> 00:09:28.970
you suddenly make
dynamically configurable.

00:09:28.970 --> 00:09:31.450
This is actually
work in practice.

00:09:31.450 --> 00:09:33.220
What you do is,
first off course,

00:09:33.220 --> 00:09:35.530
you make that application
highly configurable.

00:09:35.530 --> 00:09:37.850
And then you publish
that application.

00:09:37.850 --> 00:09:41.480
Then, you go to
google.com/tagmanager,

00:09:41.480 --> 00:09:44.030
with your web browser, and
you edit the container.

00:09:44.030 --> 00:09:48.800
You basically provide new key
value pairs with this JSON.

00:09:48.800 --> 00:09:52.860
And that gets stored
within GTM in the cloud.

00:09:52.860 --> 00:09:57.430
Your application, as it's
deployed to the user,

00:09:57.430 --> 00:10:01.750
has been built using the
Google Tag Manager SDK.

00:10:01.750 --> 00:10:06.000
And it has many of these
calls to load the container.

00:10:06.000 --> 00:10:08.410
And it has calls to
get container values.

00:10:08.410 --> 00:10:13.220
So to get those key value pairs.

00:10:13.220 --> 00:10:16.370
What happens, is that
the SDK will periodically

00:10:16.370 --> 00:10:18.480
pull up to Google
Tag Manager, to get

00:10:18.480 --> 00:10:21.080
the latest version of container.

00:10:21.080 --> 00:10:23.270
That's, by default,
every 12 hours.

00:10:23.270 --> 00:10:24.430
But it's up to you.

00:10:24.430 --> 00:10:30.440
You can also make explicit
calls to refresh more often.

00:10:30.440 --> 00:10:32.460
That container, that
gets downloaded,

00:10:32.460 --> 00:10:35.780
gets then saved with
your application.

00:10:35.780 --> 00:10:37.380
And what's important
to realize, is

00:10:37.380 --> 00:10:40.750
that when you make a call to get
a value for a particular key,

00:10:40.750 --> 00:10:43.000
it's not doing something
weird, like going actually

00:10:43.000 --> 00:10:45.710
up to the network to
try and find that value.

00:10:45.710 --> 00:10:47.780
Instead, it's using
a cached version

00:10:47.780 --> 00:10:49.270
of this latest container.

00:10:49.270 --> 00:10:51.550
And then evaluating that value.

00:10:51.550 --> 00:10:54.350
Giving you that latest value.

00:10:54.350 --> 00:10:57.017
What happens when you first
start your application now?

00:10:57.017 --> 00:10:58.850
Let's say there's no
network connection when

00:10:58.850 --> 00:10:59.930
the user uses it.

00:10:59.930 --> 00:11:01.629
How do we get this container?

00:11:01.629 --> 00:11:03.420
The way we solve that,
is that you actually

00:11:03.420 --> 00:11:07.050
provide default container that
ships with your application.

00:11:07.050 --> 00:11:09.580
We can think of that as the
container of last resort.

00:11:09.580 --> 00:11:12.710
So that gives them the default
values for each of your keys.

00:11:12.710 --> 00:11:16.140
And then those can be overridden
by editing the container

00:11:16.140 --> 00:11:19.540
and publishing a new version.

00:11:19.540 --> 00:11:21.590
So what do you need
to use to get started?

00:11:21.590 --> 00:11:24.200
You go to Google Tag Manager
and create an account.

00:11:24.200 --> 00:11:25.740
You create a container.

00:11:25.740 --> 00:11:27.370
You download the SDKs.

00:11:27.370 --> 00:11:30.820
So this works for
both iOS and Android.

00:11:30.820 --> 00:11:35.420
Currently, there's a Google
Analytics services SDK,

00:11:35.420 --> 00:11:40.500
that combines both the Analytics
SDK and the Tag Manager SDK.

00:11:40.500 --> 00:11:44.050
And coming very soon, both
Analytics and Tag Manager

00:11:44.050 --> 00:11:47.390
are part of the Google
Play Services SDK.

00:11:47.390 --> 00:11:49.870
Which contains the
APIs for almost all

00:11:49.870 --> 00:11:53.170
of the Google products.

00:11:53.170 --> 00:11:56.790
Then you modify your
app to use the SDK.

00:11:56.790 --> 00:11:59.420
Let's look at what
that looks like.

00:11:59.420 --> 00:12:01.251
You initialize your container.

00:12:01.251 --> 00:12:02.750
When you initialize
a container, you

00:12:02.750 --> 00:12:06.060
provide two important
pieces of information.

00:12:06.060 --> 00:12:07.680
One is the container ID.

00:12:07.680 --> 00:12:10.010
And that's provided when
you create the container.

00:12:10.010 --> 00:12:13.920
And the second is the location
of your default container

00:12:13.920 --> 00:12:15.710
within your application.

00:12:15.710 --> 00:12:18.250
And that's used, again,
when we have not yet

00:12:18.250 --> 00:12:21.940
downloaded a container
from the network.

00:12:21.940 --> 00:12:23.840
This provides a
container holder.

00:12:23.840 --> 00:12:25.680
The container holder
is notified every time

00:12:25.680 --> 00:12:28.310
a new container gets
downloaded for the network.

00:12:28.310 --> 00:12:31.110
And then, in your code,
you call, get container.

00:12:31.110 --> 00:12:34.300
And that will return the
latest version the container.

00:12:34.300 --> 00:12:37.730
Once you have a container,
you can then call, get string,

00:12:37.730 --> 00:12:40.650
get Boolean, get
integer, get long,

00:12:40.650 --> 00:12:44.520
to get values
given a key string.

00:12:44.520 --> 00:12:48.460
And then, of course, you go
to work and actually utilize

00:12:48.460 --> 00:12:49.610
that value.

00:12:53.470 --> 00:12:56.350
There's more to it
than that, though.

00:12:56.350 --> 00:12:59.760
Although Tag Manager
can be used just

00:12:59.760 --> 00:13:02.610
to provide global
key value pairs,

00:13:02.610 --> 00:13:06.450
it can be also used, more
specifically, for targeting.

00:13:06.450 --> 00:13:08.420
You've heard discussions
about segments.

00:13:08.420 --> 00:13:12.660
We can identify segments, for
instance, of high spenders.

00:13:12.660 --> 00:13:14.260
Or potential spenders.

00:13:14.260 --> 00:13:16.110
Or people in
different languages.

00:13:16.110 --> 00:13:18.359
People using a particular
version of the OS.

00:13:18.359 --> 00:13:20.400
People using a particular
version of replication,

00:13:20.400 --> 00:13:21.290
and so on.

00:13:21.290 --> 00:13:24.290
And we can apply
custom key values

00:13:24.290 --> 00:13:28.460
to those using rules
from Google Tag Manager.

00:13:28.460 --> 00:13:31.000
Here, for instance,
I'm giving an example

00:13:31.000 --> 00:13:34.980
of doing translation using GTM.

00:13:34.980 --> 00:13:38.360
So what we've set up is,
again, these reg text

00:13:38.360 --> 00:13:43.790
and try text, which specify
what the button text should be.

00:13:43.790 --> 00:13:47.900
And I've set up here,
Chinese strings.

00:13:47.900 --> 00:13:49.570
And they're probably wrong.

00:13:49.570 --> 00:13:52.180
It's whatever Google Translate
said register translates to.

00:13:52.180 --> 00:13:52.800
OK.

00:13:52.800 --> 00:13:55.141
So I can't verify
their accuracy.

00:13:55.141 --> 00:13:56.640
But in any case,
we're saying, we're

00:13:56.640 --> 00:14:00.690
basically going to use for
strings.regTxt, this two

00:14:00.690 --> 00:14:02.320
character value.

00:14:02.320 --> 00:14:05.980
If Chinese is true,
and if we look down

00:14:05.980 --> 00:14:08.020
at the rule for
Chinese, Chinese says

00:14:08.020 --> 00:14:10.760
that the language
starts with a zh.

00:14:10.760 --> 00:14:13.070
And that I can
attest to is Chinese.

00:14:13.070 --> 00:14:15.580
So we have a set of
predefined macros,

00:14:15.580 --> 00:14:19.215
including the language, the
OS version, the SDK version,

00:14:19.215 --> 00:14:23.170
and which platform--
iOS or Android.

00:14:23.170 --> 00:14:25.630
You can use those, as
well as other custom

00:14:25.630 --> 00:14:28.210
macros where you provide values.

00:14:28.210 --> 00:14:31.480
So for instance, if you want
to be targeting big spenders,

00:14:31.480 --> 00:14:33.820
you know what spend is.

00:14:33.820 --> 00:14:37.940
And so what you do,
is write the user

00:14:37.940 --> 00:14:40.830
spend to the data
layer, which is

00:14:40.830 --> 00:14:43.690
like an in-memory white
board of information.

00:14:43.690 --> 00:14:45.580
Meta information about the user.

00:14:45.580 --> 00:14:46.600
You write in to that.

00:14:46.600 --> 00:14:49.240
And then you can write
rules based on that value.

00:14:49.240 --> 00:14:51.190
So if you write
interesting information

00:14:51.190 --> 00:14:53.440
to the data layer about the
user-- how much have they

00:14:53.440 --> 00:14:56.190
spent, how many times have
they run the application,

00:14:56.190 --> 00:14:58.620
what level are they
on, and so on-- you

00:14:58.620 --> 00:15:02.510
can then write powerful
rules for targeting.

00:15:02.510 --> 00:15:04.340
We have German set
up a similarly.

00:15:04.340 --> 00:15:06.460
And then finally,
we have default,

00:15:06.460 --> 00:15:07.990
which, of course, is English.

00:15:07.990 --> 00:15:11.470
And here, instead of explicitly
saying we're targeting English,

00:15:11.470 --> 00:15:13.320
we're basically
carving out everyone

00:15:13.320 --> 00:15:14.990
but Chinese and German.

00:15:14.990 --> 00:15:17.520
And the reason for
that, if the user

00:15:17.520 --> 00:15:20.560
has set up to their
system to be in Spanish,

00:15:20.560 --> 00:15:22.260
we want to have some values.

00:15:22.260 --> 00:15:25.240
And we're going to go ahead and
revert to the English values.

00:15:25.240 --> 00:15:26.810
But the nice thing
is, if we want

00:15:26.810 --> 00:15:29.550
to start supporting Spanish,
we don't redeploy our app.

00:15:29.550 --> 00:15:32.807
We just go to our container,
add a new role for Spanish.

00:15:32.807 --> 00:15:35.140
Within the next 12 hours, all
the users will be updated.

00:15:35.140 --> 00:15:35.765
And away we go.

00:15:39.950 --> 00:15:42.770
So we have this ability now.

00:15:42.770 --> 00:15:47.972
We can set values dynamically.

00:15:47.972 --> 00:15:49.596
So go up to the
website and change them

00:15:49.596 --> 00:15:50.465
if you want to change them.

00:15:50.465 --> 00:15:51.050
That's great.

00:15:51.050 --> 00:15:53.500
And we could do that
on a targeted basis.

00:15:53.500 --> 00:15:57.740
The question is, what's
the best setting to use?

00:15:57.740 --> 00:16:00.430
What's the best setting to
use for a particular register

00:16:00.430 --> 00:16:04.800
button in order to increase
the number registrations?

00:16:04.800 --> 00:16:08.570
What's the best setting, as far
as how often you should present

00:16:08.570 --> 00:16:12.910
offers to users in order
to maximize in-app revenue?

00:16:12.910 --> 00:16:15.020
What's the best wording
for those offers,

00:16:15.020 --> 00:16:16.750
to increase the revenue?

00:16:16.750 --> 00:16:19.450
How often can you show ads
without affecting engagement?

00:16:19.450 --> 00:16:22.080
If you show them too
often, people may give up.

00:16:22.080 --> 00:16:23.830
If you don't show
them often enough,

00:16:23.830 --> 00:16:26.250
you're leaving
money on the table.

00:16:26.250 --> 00:16:29.630
And the best way to do this,
really, one thing is just

00:16:29.630 --> 00:16:30.580
guess.

00:16:30.580 --> 00:16:33.560
Try one value in then
later try another value.

00:16:33.560 --> 00:16:35.310
That has two problems.

00:16:35.310 --> 00:16:38.800
One problem is, there might
be exogenous factors that

00:16:38.800 --> 00:16:40.560
are affecting things.

00:16:40.560 --> 00:16:42.650
So it might be
that this week, you

00:16:42.650 --> 00:16:44.850
have a higher in-app
revenue than last week.

00:16:44.850 --> 00:16:47.680
For some outside reason.

00:16:47.680 --> 00:16:50.190
And the fact you changed
the text of your offer

00:16:50.190 --> 00:16:52.520
didn't have anything
to do with that.

00:16:52.520 --> 00:16:56.410
Also, it's slow to be
making these serial changes.

00:16:56.410 --> 00:16:58.650
So what I'm really
excited to announce today,

00:16:58.650 --> 00:17:01.860
is experimentation for
mobile applications.

00:17:01.860 --> 00:17:03.520
For both Android and iOS.

00:17:06.423 --> 00:17:07.839
Just a little bit
of a background.

00:17:07.839 --> 00:17:10.359
So I came from
experimentation on the web

00:17:10.359 --> 00:17:11.530
for Google Analytics.

00:17:11.530 --> 00:17:14.869
And when we first started
this project of Google Tag

00:17:14.869 --> 00:17:18.030
Manager for mobile, this
was how can we actually get

00:17:18.030 --> 00:17:21.030
experimentation for
mobile applications?

00:17:21.030 --> 00:17:22.079
What can we provide?

00:17:22.079 --> 00:17:24.240
There's nothing like
redirecting, for instance,

00:17:24.240 --> 00:17:26.300
to another URL in apps.

00:17:26.300 --> 00:17:29.650
And so Google Tag
Manager for mobile Apps,

00:17:29.650 --> 00:17:32.700
really, in my mind, was a
way to get experimentation.

00:17:32.700 --> 00:17:35.570
It turns out, it allows
a lot more along the way.

00:17:35.570 --> 00:17:40.300
But this gets us to a
goal I've always wanted.

00:17:40.300 --> 00:17:41.970
You can run experiments.

00:17:41.970 --> 00:17:44.885
On either all of your users,
or a targeted subset of users,

00:17:44.885 --> 00:17:48.330
again, using these rules.

00:17:48.330 --> 00:17:52.420
When an experiment ends, you
can lock in a winning variation.

00:17:52.420 --> 00:17:54.610
You don't need to
change your application.

00:17:54.610 --> 00:17:57.060
So as long as you're
using Google Tag Manager,

00:17:57.060 --> 00:18:00.070
and your application
is highly configurable.

00:18:00.070 --> 00:18:02.210
In the way we've discussed.

00:18:02.210 --> 00:18:04.380
And also supports
Google Analytics.

00:18:04.380 --> 00:18:07.580
Then, experimentation
just works.

00:18:10.280 --> 00:18:13.265
Within analytics, once you
have run an experiment,

00:18:13.265 --> 00:18:14.790
or as you're
running experiments,

00:18:14.790 --> 00:18:16.310
you can actually
segment your users

00:18:16.310 --> 00:18:18.680
in the way Mike was
describing in the last talk.

00:18:18.680 --> 00:18:22.390
Except, another access of
segmentation you can now do,

00:18:22.390 --> 00:18:24.630
is by experimenting variation.

00:18:24.630 --> 00:18:29.030
How do people who got exposed to
one variation in an experiment,

00:18:29.030 --> 00:18:30.967
how did they differ
on whatever metrics

00:18:30.967 --> 00:18:32.300
you're interested in looking at?

00:18:32.300 --> 00:18:35.315
Versus users who are exposed
to different variation.

00:18:38.340 --> 00:18:42.150
And what I'd like to do
now, is show you a demo.

00:18:42.150 --> 00:18:43.980
So I have a game here.

00:18:43.980 --> 00:18:46.895
In this game-- well, it's
really not much of the game.

00:18:46.895 --> 00:18:49.020
Right now it just has the
try text and the register

00:18:49.020 --> 00:18:50.750
text in the way I showed before.

00:18:50.750 --> 00:18:54.380
But imagine it's a
really good game.

00:18:54.380 --> 00:18:56.060
Now what I'm
interested in doing,

00:18:56.060 --> 00:18:59.244
is modifying the register text.

00:18:59.244 --> 00:19:01.160
So we can see here there's
a value collection.

00:19:01.160 --> 00:19:04.900
A value collection, again, is a
collection of key value pairs.

00:19:04.900 --> 00:19:07.150
And I want to be
modifying the register

00:19:07.150 --> 00:19:11.740
text to try some
different values.

00:19:11.740 --> 00:19:15.220
So I can now create
an experiment macro

00:19:15.220 --> 00:19:16.830
from this collection.

00:19:16.830 --> 00:19:18.957
And let's look at
what I'm going to do.

00:19:18.957 --> 00:19:19.790
I'll give it a name.

00:19:19.790 --> 00:19:21.435
It'll be the
register experiment.

00:19:25.870 --> 00:19:30.090
In order for
experiments to work,

00:19:30.090 --> 00:19:32.220
you need to be using
Google Analytics.

00:19:32.220 --> 00:19:35.000
This completes a
round trip, where

00:19:35.000 --> 00:19:38.900
we provide a different
variation to each user.

00:19:38.900 --> 00:19:41.020
But somehow we have
to capture that.

00:19:41.020 --> 00:19:44.380
And then see how the behavior
is different in the future.

00:19:44.380 --> 00:19:45.980
And so we capture
that by reporting

00:19:45.980 --> 00:19:48.150
into Google Analytics.

00:19:48.150 --> 00:19:52.160
So you need to link a
particular container

00:19:52.160 --> 00:19:55.230
with a particular Google
Analytics property.

00:19:55.230 --> 00:20:00.230
We've already done that and set
up on the Acme game property.

00:20:00.230 --> 00:20:02.510
Properties in analytics
have one or more views.

00:20:02.510 --> 00:20:04.460
I'm selecting a view.

00:20:04.460 --> 00:20:05.860
And then here's the key here.

00:20:05.860 --> 00:20:07.490
When you're
experimenting, you're

00:20:07.490 --> 00:20:10.190
not just randomly
experimenting, like,

00:20:10.190 --> 00:20:12.200
what are all the things
that might change

00:20:12.200 --> 00:20:16.670
if I expose an user two
one version of something.

00:20:16.670 --> 00:20:18.520
Versus another
version of something.

00:20:18.520 --> 00:20:22.700
But really, you have a
particular objective in mind.

00:20:22.700 --> 00:20:25.175
And that, you specify
for the experiment.

00:20:28.760 --> 00:20:34.160
Neil talked about reporting your
transactions in in-app revenue.

00:20:34.160 --> 00:20:36.640
And here's one important
reason, so that you can actually

00:20:36.640 --> 00:20:40.660
optimize in-app revenue
using experimentation.

00:20:40.660 --> 00:20:43.890
So you can choose that you're
optimizing app revenue.

00:20:43.890 --> 00:20:46.060
And then we'll determine
which variation is better,

00:20:46.060 --> 00:20:49.970
depending on which is giving a
higher average in-app revenue.

00:20:49.970 --> 00:20:53.750
Having experiment on is
some form of engagement.

00:20:53.750 --> 00:20:55.450
How many screens
are they going to?

00:20:55.450 --> 00:20:59.460
How long are their durations?

00:20:59.460 --> 00:21:02.555
Crashes and exceptions--
so part of what GA provides

00:21:02.555 --> 00:21:05.530
is the ability to report
back crashes and exceptions.

00:21:05.530 --> 00:21:07.730
You may have a
hypothesis, for example,

00:21:07.730 --> 00:21:09.760
that on this particular
device, you're

00:21:09.760 --> 00:21:12.770
seeing a lot of exceptions.

00:21:12.770 --> 00:21:15.820
Let's say an OS version.

00:21:15.820 --> 00:21:19.520
Maybe the problem is that you
have a timeout for a network

00:21:19.520 --> 00:21:21.250
call you're making
that's too short.

00:21:21.250 --> 00:21:24.730
So your hypothesis is that
increasing that time out

00:21:24.730 --> 00:21:27.450
will reduce the
number of crashes.

00:21:27.450 --> 00:21:29.000
You make an experiment.

00:21:29.000 --> 00:21:32.570
You make its
objective be crashes.

00:21:32.570 --> 00:21:35.390
You'll be happy to know that
when your objective is crashes

00:21:35.390 --> 00:21:38.457
or exceptions, we actually
look to minimize that metric.

00:21:38.457 --> 00:21:40.790
Rather than the maximization
we do in the other metrics.

00:21:44.500 --> 00:21:46.760
As well as the
pre-existing metrics

00:21:46.760 --> 00:21:48.750
on which you can
optimize, we also

00:21:48.750 --> 00:21:51.210
allow you to optimize
on your own metrics.

00:21:51.210 --> 00:21:54.860
So these, in Google
Analytics, are called goals.

00:21:54.860 --> 00:21:57.540
For a particular view
in Google Analytics,

00:21:57.540 --> 00:21:58.950
you can set up a goal.

00:21:58.950 --> 00:22:01.820
And that goal can be one
of a variety of things.

00:22:01.820 --> 00:22:04.300
As was discussed in
the last session,

00:22:04.300 --> 00:22:07.690
you can provide events, which
include a category, an action,

00:22:07.690 --> 00:22:11.240
a label, and a value,
to Google Analytics.

00:22:11.240 --> 00:22:13.537
And then set up a
goal, based on any

00:22:13.537 --> 00:22:15.745
of the settings of those
categories, actions, labels,

00:22:15.745 --> 00:22:17.400
or values.

00:22:17.400 --> 00:22:22.720
I have already set up, for my
Google Analytics view, a goal,

00:22:22.720 --> 00:22:24.320
which is registered.

00:22:24.320 --> 00:22:27.010
So when the user registers
in my application,

00:22:27.010 --> 00:22:30.670
I go ahead and send an
event via analytics.

00:22:30.670 --> 00:22:32.640
That is what I'm
trying to optimize.

00:22:32.640 --> 00:22:34.870
So I'll clearly be
able to see, when

00:22:34.870 --> 00:22:36.790
I change the text of
the Register button,

00:22:36.790 --> 00:22:39.510
how does that affect how
often the users register.

00:22:42.940 --> 00:22:44.580
So I've got my original.

00:22:44.580 --> 00:22:48.220
And this is just the
name of the variations.

00:22:48.220 --> 00:22:50.270
I'm going to name
the original register

00:22:50.270 --> 00:22:51.721
and the variation register now.

00:22:51.721 --> 00:22:53.220
So then when I'm
looking at reports,

00:22:53.220 --> 00:22:56.660
I can more easily remember
what that actually was.

00:22:56.660 --> 00:23:00.040
And my original is going
to provide the register

00:23:00.040 --> 00:23:06.910
text that just says "register."

00:23:06.910 --> 00:23:09.330
And then my variation,
I'm going to modify that.

00:23:16.540 --> 00:23:18.200
This is my variation.

00:23:18.200 --> 00:23:19.220
This is my original.

00:23:19.220 --> 00:23:21.590
So let's make the
original say "register."

00:23:21.590 --> 00:23:24.230
And the variation
say "resister now."

00:23:24.230 --> 00:23:26.170
We're not limited
to one variation.

00:23:26.170 --> 00:23:28.230
We can add up to 10
variations that we want.

00:23:28.230 --> 00:23:30.280
I just going to limit it
to this for the moment.

00:23:32.850 --> 00:23:34.970
For an experiment, there
are some advanced options

00:23:34.970 --> 00:23:36.050
worth looking at.

00:23:36.050 --> 00:23:37.850
You can control what
percentage of users

00:23:37.850 --> 00:23:39.360
get included in the experiment.

00:23:39.360 --> 00:23:40.620
By default it's 100 percent.

00:23:40.620 --> 00:23:42.703
But you can reduce that
to just some small subset,

00:23:42.703 --> 00:23:43.710
if you'd like.

00:23:43.710 --> 00:23:47.620
A confidence threshold for
the statistical significance,

00:23:47.620 --> 00:23:49.870
when we declare a winner.

00:23:49.870 --> 00:23:52.850
How long the experiment runs.

00:23:52.850 --> 00:23:56.680
Often, users exhibits
some sort of behavior

00:23:56.680 --> 00:23:58.890
that differs from day
to day in the week.

00:23:58.890 --> 00:24:01.750
So for instance, weekend days
may be different from weekdays.

00:24:01.750 --> 00:24:05.172
We wouldn't run an experiment
for just two days if that

00:24:05.172 --> 00:24:06.880
happened to be over
the weekend, and then

00:24:06.880 --> 00:24:10.080
generalize that
across an entire week.

00:24:10.080 --> 00:24:11.680
So by default, we
run an experiment

00:24:11.680 --> 00:24:12.880
for at least two weeks.

00:24:12.880 --> 00:24:15.460
You can reduce that if you want.

00:24:15.460 --> 00:24:17.690
When the experiment
ends, we'll automatically

00:24:17.690 --> 00:24:19.290
serve the winning variation.

00:24:19.290 --> 00:24:21.295
So we'll lock in that
winning variation.

00:24:21.295 --> 00:24:23.670
Although if you want to just
revert back to the original,

00:24:23.670 --> 00:24:25.880
even if that's not as good
as your winning variation,

00:24:25.880 --> 00:24:27.800
you certainly can.

00:24:27.800 --> 00:24:30.060
And then finally, we'll
add an enabling rule.

00:24:30.060 --> 00:24:32.950
Remember, this was just for
non-Chinese and non-German.

00:24:32.950 --> 00:24:38.420
So we want to run always,
except in Chinese and German.

00:24:42.250 --> 00:24:42.750
OK.

00:24:42.750 --> 00:24:43.999
So we created this experiment.

00:24:43.999 --> 00:24:46.210
What do we need to do to
actually make it work?

00:24:46.210 --> 00:24:47.810
We create a version.

00:24:47.810 --> 00:24:49.860
And then we publish
that version.

00:24:49.860 --> 00:24:53.880
When you publish a version, it's
going to start an experiment,

00:24:53.880 --> 00:24:56.400
and so we go on and publish it.

00:24:56.400 --> 00:24:59.340
It starts.

00:24:59.340 --> 00:25:00.700
What's going to happen now?

00:25:00.700 --> 00:25:05.400
So once this publishes,
as devices check in

00:25:05.400 --> 00:25:07.480
to receive the latest
version of the container,

00:25:07.480 --> 00:25:09.090
they'll now receive
this container

00:25:09.090 --> 00:25:11.610
that has experiment
information in it.

00:25:11.610 --> 00:25:18.790
When the user sees the
buttons, your application

00:25:18.790 --> 00:25:21.570
will be retrieving the
strings.registerTxt.

00:25:21.570 --> 00:25:23.590
And as it retrieves
that, it'll actually

00:25:23.590 --> 00:25:25.170
to do a coin flip
to decide which

00:25:25.170 --> 00:25:26.890
variation they are going to see.

00:25:26.890 --> 00:25:28.260
They'll see that variation.

00:25:28.260 --> 00:25:31.000
We'll report that information
back to Google Analytics.

00:25:31.000 --> 00:25:34.480
Anything from then on that gets
reported to Google Analytics,

00:25:34.480 --> 00:25:35.790
that information be tagged.

00:25:35.790 --> 00:25:38.511
That this user
saw this variation

00:25:38.511 --> 00:25:39.760
of this particular experiment.

00:25:43.530 --> 00:25:46.400
And it's also important to know,
every time the user comes back,

00:25:46.400 --> 00:25:47.960
we're not going to
re-flip that coin.

00:25:47.960 --> 00:25:50.170
Once they're in an
experiment, and been exposed

00:25:50.170 --> 00:25:53.040
to a particular variation,
they stay with that variation.

00:25:53.040 --> 00:25:55.660
So they have a
consistent experience.

00:26:00.061 --> 00:26:00.560
All right.

00:26:00.560 --> 00:26:08.260
So let us look at this
experiment in Google Analytics.

00:26:12.830 --> 00:26:14.930
So the fact is, since we
just started it running,

00:26:14.930 --> 00:26:16.660
we actually don't
have any users that

00:26:16.660 --> 00:26:18.240
have been providing
information yet.

00:26:18.240 --> 00:26:22.170
So it's a boring
report at this point.

00:26:22.170 --> 00:26:23.770
But this is where
we would see how

00:26:23.770 --> 00:26:26.290
users are doing, what
their conversion rates are,

00:26:26.290 --> 00:26:27.220
and so on.

00:26:27.220 --> 00:26:30.560
Let me show you a report
from another application.

00:26:30.560 --> 00:26:34.190
So here, you can
see our original,

00:26:34.190 --> 00:26:35.680
our various variations.

00:26:35.680 --> 00:26:38.540
We see how many visits and
conversions for each one.

00:26:38.540 --> 00:26:40.100
The conversion rate.

00:26:40.100 --> 00:26:42.050
And then a comparison
to the original.

00:26:42.050 --> 00:26:44.290
Here, variation
one is doing great,

00:26:44.290 --> 00:26:45.760
compared to the original.

00:26:45.760 --> 00:26:47.670
So 234% better.

00:26:47.670 --> 00:26:49.820
Almost two and a
half times as good.

00:26:49.820 --> 00:26:51.380
It's probability
of out-performing

00:26:51.380 --> 00:26:54.290
the original, 100%.

00:26:54.290 --> 00:26:56.310
Why haven't we ended the
experiment yet, though?

00:26:56.310 --> 00:26:57.810
And declared that a winner?

00:26:57.810 --> 00:27:00.150
Because we've only actually
got two days of data.

00:27:00.150 --> 00:27:02.890
And we still have a chance
for, perhaps, another variation

00:27:02.890 --> 00:27:06.880
to do better, or if
during the week variation

00:27:06.880 --> 00:27:08.935
one does really poorly,
maybe even the original

00:27:08.935 --> 00:27:09.600
will catch up.

00:27:11.717 --> 00:27:13.800
At this point I'd like to
turn back over to Lukas.

00:27:16.836 --> 00:27:20.570
[APPLAUSE]

00:27:24.605 --> 00:27:26.480
LUKAS BERGSTROM: Those
teams did a great job.

00:27:26.480 --> 00:27:30.350
And it's a really powerful tool.

00:27:30.350 --> 00:27:33.600
If there are just three things
I could ask you to walk away

00:27:33.600 --> 00:27:36.310
remembering, though,
they are, well,

00:27:36.310 --> 00:27:38.760
not necessarily the bullet
points on this slide,

00:27:38.760 --> 00:27:41.360
but more or less.

00:27:41.360 --> 00:27:45.650
Separating configuration
from code is really powerful.

00:27:45.650 --> 00:27:48.920
So being able to push
new configuration to all

00:27:48.920 --> 00:27:53.500
of your users at anytime without
needing to ship a new binary,

00:27:53.500 --> 00:27:55.780
is a really powerful tool.

00:27:55.780 --> 00:27:57.260
And it can change
the way you think

00:27:57.260 --> 00:28:02.060
about how you can optimize
your app, and when.

00:28:02.060 --> 00:28:04.840
And what should be
static, versus what

00:28:04.840 --> 00:28:06.620
should be dynamically
configurable.

00:28:06.620 --> 00:28:08.890
And we give you a really
powerful rules engine

00:28:08.890 --> 00:28:12.460
to allow you to control
that configuration as well.

00:28:12.460 --> 00:28:18.080
Beyond that, we know we didn't
show a lot about the Google Tag

00:28:18.080 --> 00:28:20.320
Manager UI, but
we give you a lot

00:28:20.320 --> 00:28:23.280
of tools to help teams
collaborate safely.

00:28:23.280 --> 00:28:26.750
So that you could have
multiple people editing rules

00:28:26.750 --> 00:28:29.200
or configuration in your app.

00:28:29.200 --> 00:28:30.740
And then have control.

00:28:30.740 --> 00:28:33.250
Say, maybe this person
can edit things,

00:28:33.250 --> 00:28:35.700
but only I am allowed to
actually push changes out

00:28:35.700 --> 00:28:36.920
to my app.

00:28:36.920 --> 00:28:40.250
And what that does, is
it unlocks the team.

00:28:40.250 --> 00:28:42.800
It lets multiple
people collaborate.

00:28:42.800 --> 00:28:45.330
It lets people like marketers
and business analysts

00:28:45.330 --> 00:28:48.490
get their work done without
bothering developers.

00:28:48.490 --> 00:28:51.170
But it still does it
in a really safe way.

00:28:51.170 --> 00:28:54.120
That makes sure
that you can control

00:28:54.120 --> 00:28:56.950
who can make changes
within your app.

00:28:56.950 --> 00:29:01.070
And finally, being able to
create these experiments.

00:29:01.070 --> 00:29:02.290
Push them.

00:29:02.290 --> 00:29:03.860
Get results.

00:29:03.860 --> 00:29:06.180
And then a lock in
a winning variation.

00:29:06.180 --> 00:29:08.420
All without shipping
a new binary,

00:29:08.420 --> 00:29:11.400
is just an insanely
powerful tool.

00:29:11.400 --> 00:29:13.730
It's a really kind of
dizzying to think about.

00:29:13.730 --> 00:29:17.470
If you've done a good job
of instrumenting in your app

00:29:17.470 --> 00:29:19.240
about the stuff
that you care about.

00:29:19.240 --> 00:29:21.960
The stuff that you think
should be configurable.

00:29:21.960 --> 00:29:23.860
To think about, what
are the outcomes

00:29:23.860 --> 00:29:25.710
I want to optimize for?

00:29:25.710 --> 00:29:28.060
What are the variables
that might contribute

00:29:28.060 --> 00:29:31.750
to success or failure
against those outcomes?

00:29:31.750 --> 00:29:34.120
I'm just going to plug those
into the experimentation

00:29:34.120 --> 00:29:38.060
engine, and just let it figure
out what the right outcome is.

00:29:38.060 --> 00:29:41.320
So being able to just push
a new experiment like that

00:29:41.320 --> 00:29:44.470
at any time is just an
insanely powerful tool.

00:29:44.470 --> 00:29:47.470
And we're really excited
to see or people do with it

00:29:47.470 --> 00:29:50.190
in a mobile app context.

00:29:50.190 --> 00:29:55.040
So as no surprise, we're Google.

00:29:55.040 --> 00:29:56.860
We think more data is better.

00:29:56.860 --> 00:29:59.290
And testing beats guessing.

00:29:59.290 --> 00:30:02.430
And I think what we've
shown you is a tool that

00:30:02.430 --> 00:30:04.990
unlocks your ability to do that.

00:30:04.990 --> 00:30:07.300
Your ability to conduct
measurement configuration

00:30:07.300 --> 00:30:09.790
changes and experimentation.

00:30:09.790 --> 00:30:11.630
So we're super excited about it.

00:30:11.630 --> 00:30:14.320
Neil and I will be
outside, if anybody

00:30:14.320 --> 00:30:16.590
wants to talk to us
right after this talk.

00:30:16.590 --> 00:30:19.680
And we'll be on the
expo floor at our booth

00:30:19.680 --> 00:30:21.250
on Wednesday and Thursday.

00:30:21.250 --> 00:30:21.820
So thanks--

00:30:21.820 --> 00:30:23.920
NEIL RHODES: One more
thing, it is Google.

00:30:23.920 --> 00:30:24.480
It's free.

00:30:28.000 --> 00:30:29.740
LUKAS BERGSTROM:
Thanks, everybody.

