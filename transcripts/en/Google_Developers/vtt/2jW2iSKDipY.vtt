WEBVTT
Kind: captions
Language: en

00:00:01.334 --> 00:00:03.000
Ross: Good afternoon,
everybody.

00:00:03.000 --> 00:00:04.501
Thank you for coming.

00:00:04.501 --> 00:00:06.100
My name is Max Ross.

00:00:06.100 --> 00:00:10.367
I'm a software engineer on
the App Engine team at Google.

00:00:10.367 --> 00:00:14.767
I focus primarily on things
related to persistence.

00:00:14.767 --> 00:00:17.934
I work on the App Engine
Datastore,

00:00:17.934 --> 00:00:19.367
the common piece
of infrastructure

00:00:19.367 --> 00:00:21.234
that's behind persistence

00:00:21.234 --> 00:00:23.534
for both the Python and Java
run times.

00:00:23.534 --> 00:00:27.567
I also work on the Java
low-level Datastore API

00:00:27.567 --> 00:00:31.000
and I also work on the JDO/JPA
implementation

00:00:31.000 --> 00:00:34.234
that we provided for persistence
in Java.

00:00:34.234 --> 00:00:36.267
And today we're going
to be talking about

00:00:36.267 --> 00:00:38.901
the softer side of schemas.

00:00:38.901 --> 00:00:42.300
So before we jump in,
let me give you a brief overview

00:00:42.300 --> 00:00:44.634
of what you can expect
from today's talk.

00:00:44.634 --> 00:00:46.400
Just a quick show of hands,

00:00:46.400 --> 00:00:47.567
how many people here
have already built

00:00:47.567 --> 00:00:50.300
and deployed an application
on App Engine?

00:00:50.300 --> 00:00:51.734
All right, lots of hands.

00:00:51.734 --> 00:00:54.067
And how many have done Python?

00:00:54.067 --> 00:00:56.000
And how many have done Java?

00:00:56.000 --> 00:00:57.234
All right, I like to see
all those Java hands.

00:00:57.234 --> 00:00:58.367
That's great.

00:00:58.367 --> 00:00:59.667
Okay, so just to make sure

00:00:59.667 --> 00:01:02.501
that we all have
the same foundation,

00:01:02.501 --> 00:01:04.367
I'm gonna spend a couple
of minutes talking about

00:01:04.367 --> 00:01:06.767
some of the fundamentals
of the App Engine Datastore

00:01:06.767 --> 00:01:08.367
and then we're going to build
on top of that.

00:01:08.367 --> 00:01:11.000
From there we're going
to move to a discussion

00:01:11.000 --> 00:01:12.868
of soft schemas.

00:01:12.868 --> 00:01:15.033
And obviously I owe you
a definition of that term

00:01:15.033 --> 00:01:16.334
and I will provide one.

00:01:16.334 --> 00:01:18.200
But we're gonna talk about
soft schemas

00:01:18.200 --> 00:01:21.167
and how you can use existing
Java persistence standards,

00:01:21.167 --> 00:01:25.200
specifically JDO and JPA,
to implement a soft schema

00:01:25.200 --> 00:01:27.000
on top of the App Engine
Datastore.

00:01:27.000 --> 00:01:31.033
And then we're going
to go through some strategies

00:01:31.033 --> 00:01:36.567
for migrating existing
applications onto App Engine,

00:01:36.567 --> 00:01:40.400
and then some strategies for
moving App Engine applications

00:01:40.400 --> 00:01:43.767
off of App Engine--not that you
would ever want to do that.

00:01:43.767 --> 00:01:45.000
Actually we know that you would
want to do that

00:01:45.000 --> 00:01:46.334
and that's why we put
a lot of thought

00:01:46.334 --> 00:01:48.234
into making sure that
that's gonna work nicely.

00:01:48.234 --> 00:01:53.000
And then we'll finish up
with some questions.

00:01:53.000 --> 00:01:54.467
So, let's talk about

00:01:54.467 --> 00:01:57.133
the basics of the App Engine
Datastore.

00:01:57.133 --> 00:01:59.534
First and foremost,
it is transactional.

00:01:59.534 --> 00:02:02.000
It has the acid properties

00:02:02.000 --> 00:02:04.234
that we have rightly
come to expect

00:02:04.234 --> 00:02:06.634
from something
that does persistence.

00:02:06.634 --> 00:02:07.868
A little bit more
interestingly,

00:02:07.868 --> 00:02:09.934
it is natively partitioned.

00:02:09.934 --> 00:02:13.334
The App Engine Datastore
is a distributed system.

00:02:13.334 --> 00:02:15.834
Your data is split out
across a network of servers.

00:02:15.834 --> 00:02:22.033
And unlike an architecture
where you have

00:02:22.033 --> 00:02:23.701
horizontally partitioned
your data,

00:02:23.701 --> 00:02:25.901
and maybe it's the
responsibility of your code

00:02:25.901 --> 00:02:29.801
to decide at runtime
where data is gonna go,

00:02:29.801 --> 00:02:32.033
the App Engine Datastore
is natively partitioned.

00:02:32.033 --> 00:02:35.100
We're going to split
your data up for you.

00:02:35.100 --> 00:02:37.234
So just by building
your application

00:02:37.234 --> 00:02:39.968
on top of the Datastore,
this is going to happen.

00:02:39.968 --> 00:02:42.267
That's pretty cool.

00:02:42.267 --> 00:02:44.367
Another interesting aspect
of the Datastore

00:02:44.367 --> 00:02:45.634
is that it's hierarchical.

00:02:45.634 --> 00:02:49.868
Every entity that you store
in the Datastore

00:02:49.868 --> 00:02:54.100
can have a notion of its parent
or its grandparent

00:02:54.100 --> 00:02:55.267
or its great grandparent,

00:02:55.267 --> 00:02:56.734
or it can be one
of these entities

00:02:56.734 --> 00:02:58.834
that we like to call
a root entity

00:02:58.834 --> 00:03:00.267
where it doesn't have
a parent at all.

00:03:00.267 --> 00:03:02.968
But this is baked
into the Datastore itself.

00:03:02.968 --> 00:03:05.167
It's a native feature.

00:03:05.167 --> 00:03:08.434
Another interesting aspect,
it is schema-less.

00:03:08.434 --> 00:03:13.834
So the Datastore does not have
any notion

00:03:13.834 --> 00:03:16.801
of the structure of your data.

00:03:16.801 --> 00:03:19.033
And we're gonna talk
a lot more about this

00:03:19.033 --> 00:03:20.334
as we go forward.

00:03:20.334 --> 00:03:24.801
And then finally
it is based on Bigtable,

00:03:24.801 --> 00:03:27.467
which is a distributed
storage system

00:03:27.467 --> 00:03:30.067
that Google has developed
over the years

00:03:30.067 --> 00:03:31.400
that we run for you.

00:03:31.400 --> 00:03:33.100
A couple of things
that I want to point out

00:03:33.100 --> 00:03:35.000
that the Datastore isn't--

00:03:35.000 --> 00:03:36.467
It isn't
a relational database,

00:03:36.467 --> 00:03:38.801
and I really want to make
this point clear.

00:03:38.801 --> 00:03:40.701
The Datastore isn't
a relational database.

00:03:40.701 --> 00:03:42.067
It's not a SQL engine.

00:03:42.067 --> 00:03:45.901
In this talk we're gonna
be discussing how JDO and JPA,

00:03:45.901 --> 00:03:47.634
these Java persistence
standards--

00:03:47.634 --> 00:03:52.667
which are commonly used to talk
to a relational database--

00:03:52.667 --> 00:03:54.501
we're gonna talk about
how these persistence standards

00:03:54.501 --> 00:03:57.234
can also be used to talk
to the App Engine Datastore.

00:03:57.234 --> 00:03:59.501
But that does not mean
that the App Engine Datastore

00:03:59.501 --> 00:04:02.200
is a relational database.

00:04:02.200 --> 00:04:05.534
So, here's a quote
from my friend Z,

00:04:05.534 --> 00:04:08.334
who I sometimes ride
the Google bus with

00:04:08.334 --> 00:04:09.667
up to San Francisco.

00:04:09.667 --> 00:04:11.300
We were talking about App Engine
one day

00:04:11.300 --> 00:04:12.834
and I was describing
the Datastore to him

00:04:12.834 --> 00:04:15.000
and he said, "I don't want
a relational database

00:04:15.000 --> 00:04:18.300
for my application,
I just want persistence."

00:04:18.300 --> 00:04:21.334
Now I know not everybody
in this room

00:04:21.334 --> 00:04:23.067
is going to agree
with that sentiment.

00:04:23.067 --> 00:04:25.100
And it makes sense
that some people will agree

00:04:25.100 --> 00:04:26.467
and some people don't.

00:04:26.467 --> 00:04:29.834
But I want to say that for those
of you that agree with Z,

00:04:29.834 --> 00:04:31.968
you're gonna be really excited
about working

00:04:31.968 --> 00:04:35.901
with the Datastore because
it really does simplify things.

00:04:35.901 --> 00:04:38.834
One of our primary
design goals here

00:04:38.834 --> 00:04:40.467
is to simplify storage.

00:04:40.467 --> 00:04:42.901
We want to simplify
the development of applications

00:04:42.901 --> 00:04:45.167
that require storage
and we want to simplify

00:04:45.167 --> 00:04:49.434
the management of applications
that require storage.

00:04:49.434 --> 00:04:52.267
Now the reason our solution
looks the way it does

00:04:52.267 --> 00:04:57.334
is that throughout App Engine
as a whole,

00:04:57.334 --> 00:05:01.234
the entire product,
we sort of have a history

00:05:01.234 --> 00:05:04.567
of taking existing
infrastructure services

00:05:04.567 --> 00:05:06.734
that already exist
within Google--

00:05:06.734 --> 00:05:10.667
these are the types of services
that allow you to send mail,

00:05:10.667 --> 00:05:12.434
these are the types of services
that allow you

00:05:12.434 --> 00:05:15.667
to fetch the contents
of a URL on the Internet--

00:05:15.667 --> 00:05:18.534
we have a long history
of building these services

00:05:18.534 --> 00:05:20.834
in a way that scales
and in a way that we know how

00:05:20.834 --> 00:05:22.767
to manage them very efficiently

00:05:22.767 --> 00:05:24.467
so that the people
who consume these services

00:05:24.467 --> 00:05:30.267
don't have to worry
about managing them efficiently.

00:05:30.267 --> 00:05:31.801
Sorry, distracted by beeping.

00:05:31.801 --> 00:05:35.033
The Datastore
is no different.

00:05:35.033 --> 00:05:37.234
So why are we
exposing Bigtable?

00:05:37.234 --> 00:05:41.200
We're exposing Bigtable
because we're really good

00:05:41.200 --> 00:05:43.400
at running this service.

00:05:43.400 --> 00:05:46.200
And this is a big part
of simplifying the management

00:05:46.200 --> 00:05:49.534
of applications
that need storage.

00:05:49.534 --> 00:05:53.501
So for those of you
who might be thinking,

00:05:53.501 --> 00:05:55.767
"Well, I've heard that Bigtable
is a storage solution

00:05:55.767 --> 00:05:58.868
"for applications that need
to scale to Google scale,

00:05:58.868 --> 00:06:01.067
to the size of Gmail,
for example."

00:06:01.067 --> 00:06:04.567
I'd like to try
and make the point

00:06:04.567 --> 00:06:08.834
that no matter what type
of application you're building,

00:06:08.834 --> 00:06:12.133
scale always matters.

00:06:12.133 --> 00:06:15.033
It might not need to scale
to the size of Gmail,

00:06:15.033 --> 00:06:17.434
but you have some target scale
in mind.

00:06:17.434 --> 00:06:20.901
It might be 5 concurrent users
or 20 concurrent users

00:06:20.901 --> 00:06:23.267
or 100 or 1,000,
but every single one

00:06:23.267 --> 00:06:26.334
of those targets involves
certain design decisions

00:06:26.334 --> 00:06:28.834
that you need to think about.

00:06:28.834 --> 00:06:31.267
So it's not just that
App Engine

00:06:31.267 --> 00:06:35.267
is for building applications
that need to scale

00:06:35.267 --> 00:06:37.334
to the same size
as Google applications.

00:06:37.334 --> 00:06:39.601
It's for building applications
that are going to scale

00:06:39.601 --> 00:06:42.767
to whatever that scaling target
might be more easily.

00:06:42.767 --> 00:06:46.467
That's one of the things
we're trying to simplify here.

00:06:46.467 --> 00:06:48.634
So let's look
at the storage model.

00:06:48.634 --> 00:06:52.367
The basic thing
that we are persisting here

00:06:52.367 --> 00:06:53.667
is something called an Entity.

00:06:53.667 --> 00:06:56.534
And an Entity
has four components.

00:06:56.534 --> 00:06:58.801
There's a kind,
which for those of you coming

00:06:58.801 --> 00:07:00.501
from the relational database
world

00:07:00.501 --> 00:07:02.300
would probably think of this
as the table.

00:07:02.300 --> 00:07:05.100
It has a key, which you can
think of as the primary key.

00:07:05.100 --> 00:07:08.501
There is the Entity Group,

00:07:08.501 --> 00:07:11.834
which is part of every
single Entity.

00:07:11.834 --> 00:07:15.501
And this goes into determining
what partition

00:07:15.501 --> 00:07:17.300
your data's gonna live on.

00:07:17.300 --> 00:07:19.200
If you've done horizontal
partitioning before,

00:07:19.200 --> 00:07:20.934
or sharding as we like
to call it,

00:07:20.934 --> 00:07:22.701
this term will be familiar
to you.

00:07:22.701 --> 00:07:24.767
We use this to figure out
what data

00:07:24.767 --> 00:07:27.801
this Entity is co-located with.

00:07:27.801 --> 00:07:30.734
And then finally you have
some number of typed properties

00:07:30.734 --> 00:07:32.167
which you can think
of as columns.

00:07:32.167 --> 00:07:35.534
So here we have an example
where the person is a kind.

00:07:35.534 --> 00:07:37.033
And if you'll notice here

00:07:37.033 --> 00:07:38.701
the Entity Group and the key
are the same.

00:07:38.701 --> 00:07:40.501
Anytime you see an Entity
where the Entity Group

00:07:40.501 --> 00:07:41.767
and the key are the same,

00:07:41.767 --> 00:07:43.434
that means you're looking
at a root entity.

00:07:43.434 --> 00:07:45.167
It doesn't have a parent.

00:07:45.167 --> 00:07:47.767
We talked about the Datastore
being hierarchical before.

00:07:47.767 --> 00:07:49.868
If the Entity Group
and the key are the same,

00:07:49.868 --> 00:07:51.234
it doesn't have a parent.

00:07:51.234 --> 00:07:52.434
It's a root Entity.

00:07:52.434 --> 00:07:54.667
And then in this example
we have two properties.

00:07:54.667 --> 00:07:57.367
We can see that Ethel
is 30 years old

00:07:57.367 --> 00:07:59.734
and Ethel has a best friend
named Sally.

00:07:59.734 --> 00:08:02.100
This bottom column here,
the best friend,

00:08:02.100 --> 00:08:04.767
you can see that it's referring
to another key.

00:08:04.767 --> 00:08:06.968
You can think of that
if you're coming

00:08:06.968 --> 00:08:09.300
from the relational world
as a foreign key.

00:08:09.300 --> 00:08:11.234
The Datastore does support this.

00:08:11.234 --> 00:08:15.033
So let's talk about some
of the interesting features

00:08:15.033 --> 00:08:16.300
that you get
with the Datastore

00:08:16.300 --> 00:08:18.033
that you might not
be accustomed to.

00:08:18.033 --> 00:08:19.801
First and foremost,

00:08:19.801 --> 00:08:23.501
there is this hierarchical
nature of the Datastore.

00:08:23.501 --> 00:08:25.167
In the top right-hand corner
here

00:08:25.167 --> 00:08:26.834
we have the same person
as before.

00:08:26.834 --> 00:08:29.467
We have Ethel
whose best friend is Sally.

00:08:29.467 --> 00:08:33.167
But then on the bottom,
we have a person Entity

00:08:33.167 --> 00:08:34.934
that is a child of Ethel.

00:08:34.934 --> 00:08:37.968
And the way that we know
that this person Entity

00:08:37.968 --> 00:08:40.067
is a child of Ethel
is we can look at the key.

00:08:40.067 --> 00:08:42.834
And we can see that the key
consists of the parent Ent--

00:08:42.834 --> 00:08:44.434
the key of the parent Entity

00:08:44.434 --> 00:08:46.234
with the key of the child
appended to it.

00:08:46.234 --> 00:08:48.634
We have person Ethel,
person Jane.

00:08:48.634 --> 00:08:51.734
This uniquely identifies
this Entity and tells us

00:08:51.734 --> 00:08:53.000
that it's a child.

00:08:53.000 --> 00:08:54.400
And then if we look
at the Entity group,

00:08:54.400 --> 00:08:56.200
we can see that the Entity Group
and the key

00:08:56.200 --> 00:08:58.667
are not the same.

00:08:58.667 --> 00:09:00.200
This is therefore a child Entity

00:09:00.200 --> 00:09:03.667
residing in the same
Entity Group as Ethel.

00:09:03.667 --> 00:09:06.434
So that's how we see ancestors
sort of played out

00:09:06.434 --> 00:09:08.601
in the physical model.

00:09:08.601 --> 00:09:12.801
The Datastore also supports
heterogeneous property types.

00:09:12.801 --> 00:09:16.167
On the Ethel Entity we can see
that the type

00:09:16.167 --> 00:09:18.567
of the age property
is an Int64.

00:09:18.567 --> 00:09:19.901
Ethel is 30.

00:09:19.901 --> 00:09:22.267
But Jane here
is a little bit younger

00:09:22.267 --> 00:09:26.801
and maybe likes to describe
her age in terms of half years,

00:09:26.801 --> 00:09:28.767
so we can represent that
as a double.

00:09:28.767 --> 00:09:30.501
Because the Datastore
is schema-less,

00:09:30.501 --> 00:09:34.167
there's no problem representing
age as an Int in one record

00:09:34.167 --> 00:09:36.534
and age as a double
in another record.

00:09:36.534 --> 00:09:39.200
We also support
multi-value properties.

00:09:39.200 --> 00:09:44.234
Ethel, this 8 1/2-year-old,
has multiple best friends.

00:09:44.234 --> 00:09:47.367
We can store this in a very
natural way in the Datastore.

00:09:47.367 --> 00:09:50.501
If you've run
into this situation

00:09:50.501 --> 00:09:52.701
with a relational database
before,

00:09:52.701 --> 00:09:54.567
you usually have two choices.

00:09:54.567 --> 00:09:56.801
You can either sort of
break that multiplicity out

00:09:56.801 --> 00:09:59.801
into a separate table or--
and I'm guilty

00:09:59.801 --> 00:10:01.534
of having done this
in the past--

00:10:01.534 --> 00:10:03.234
you can put data
in sort of, like,

00:10:03.234 --> 00:10:04.834
you can have some logical
structure there

00:10:04.834 --> 00:10:06.467
where you can separate
the data with commas.

00:10:06.467 --> 00:10:07.801
And you can say, "Okay,
well, yeah,

00:10:07.801 --> 00:10:09.200
it's a multi-value property."

00:10:09.200 --> 00:10:11.200
I can't query for it
because the querying mechanism

00:10:11.200 --> 00:10:12.868
doesn't understand
the implicit structure

00:10:12.868 --> 00:10:14.234
that you've baked in there,

00:10:14.234 --> 00:10:16.100
but it is a way to sort of
fake multi-value properties.

00:10:16.100 --> 00:10:18.801
With the Datastore you can do
this in a really natural way.

00:10:18.801 --> 00:10:19.934
It works great.

00:10:19.934 --> 00:10:21.567
And then the final thing
I want to point out

00:10:21.567 --> 00:10:24.334
is that Jane,
this child record here,

00:10:24.334 --> 00:10:26.767
has a grade property.

00:10:26.767 --> 00:10:28.734
Jane's parent Ethel
doesn't have a grade property.

00:10:28.734 --> 00:10:31.133
So it's perfectly acceptable
for one Entity

00:10:31.133 --> 00:10:34.734
of kind person to have
a certain set of properties

00:10:34.734 --> 00:10:36.167
and another Entity
of kind person

00:10:36.167 --> 00:10:40.934
to have a different set
of properties.

00:10:40.934 --> 00:10:43.601
I want to talk about
transactions a little bit.

00:10:43.601 --> 00:10:46.501
This going to play
an important role

00:10:46.501 --> 00:10:48.267
in the discussion
of soft schemas

00:10:48.267 --> 00:10:51.467
and JDO/JPA persistence mapping
that's coming along.

00:10:51.467 --> 00:10:53.767
So I want to make sure everybody
has a good understanding

00:10:53.767 --> 00:10:56.400
of what Datastore transactions
are and how they work.

00:10:56.400 --> 00:10:59.767
I described the Entity Group
before

00:10:59.767 --> 00:11:01.801
as sort of a partition key.

00:11:01.801 --> 00:11:03.167
And one of the reasons
this is important

00:11:03.167 --> 00:11:07.234
is that you can only transact
on Entities

00:11:07.234 --> 00:11:09.000
that belong to the same
Entity Group.

00:11:09.000 --> 00:11:11.133
So if you look
at the example here,

00:11:11.133 --> 00:11:13.133
we can see that we have
Ethel and Jane belonging

00:11:13.133 --> 00:11:14.834
to the same Entity Group,

00:11:14.834 --> 00:11:18.567
but then person Max here belongs
to a different Entity Group.

00:11:18.567 --> 00:11:21.467
What this means is I can make
an update to Ethel

00:11:21.467 --> 00:11:22.868
and I can make an update
to Jane

00:11:22.868 --> 00:11:26.868
and I can have that update
succeed or fail atomically.

00:11:26.868 --> 00:11:29.968
But if I add an update
to Max into that mix

00:11:29.968 --> 00:11:31.434
and I try to commit
the transaction,

00:11:31.434 --> 00:11:32.834
I'm gonna get an exception back

00:11:32.834 --> 00:11:36.267
because I'm trying to perform
an atomic operation

00:11:36.267 --> 00:11:40.567
that spans Entity Groups.

00:11:40.567 --> 00:11:42.334
So soft schemas.

00:11:42.334 --> 00:11:43.901
Here's the definition.

00:11:43.901 --> 00:11:45.567
A soft schema is a schema
whose constraints

00:11:45.567 --> 00:11:49.133
are enforced purely
in the application layer.

00:11:49.133 --> 00:11:50.934
What do I mean by that?

00:11:50.934 --> 00:11:54.367
Well, this is a scenario
where your applications'

00:11:54.367 --> 00:11:58.033
expectations of the structure

00:11:58.033 --> 00:12:00.501
and the validation
that's been applied to the data,

00:12:00.501 --> 00:12:04.033
that is the schema itself.

00:12:04.033 --> 00:12:06.267
And when you're working
with a Datastore

00:12:06.267 --> 00:12:07.601
like the App Engine Datastore

00:12:07.601 --> 00:12:09.000
that does not have
a schema baked in,

00:12:09.000 --> 00:12:10.767
this can be really valuable

00:12:10.767 --> 00:12:13.767
because this takes you
from an area

00:12:13.767 --> 00:12:16.901
where perhaps you're used
to having the database

00:12:16.901 --> 00:12:18.367
do a lot of this validation

00:12:18.367 --> 00:12:19.868
and provide this structure
for you

00:12:19.868 --> 00:12:25.334
into an area that looks a little
bit more familiar, right?

00:12:25.334 --> 00:12:28.667
You have to give up
some of that structure

00:12:28.667 --> 00:12:30.534
when you move
to the App Engine Datastore.

00:12:30.534 --> 00:12:33.234
But if there's some way
to implement a soft schema

00:12:33.234 --> 00:12:35.968
on top of it,
then you're back in the area

00:12:35.968 --> 00:12:37.767
where things look maybe
a little bit more

00:12:37.767 --> 00:12:39.267
like what you're used to.

00:12:39.267 --> 00:12:43.334
So we actually get some nice
things out of a soft schema.

00:12:43.334 --> 00:12:46.000
First and foremost,

00:12:46.000 --> 00:12:49.968
well, when you don't have
a schema at all,

00:12:49.968 --> 00:12:52.901
if any of you have worked
with sort of the low-level API

00:12:52.901 --> 00:12:55.033
in the Datastore,
you've probably seen how easy

00:12:55.033 --> 00:12:57.234
it is to rapidly prototype
an application

00:12:57.234 --> 00:12:58.634
that requires persistence.

00:12:58.634 --> 00:13:00.000
And that's great.

00:13:00.000 --> 00:13:01.534
That rapid prototyping
is great.

00:13:01.534 --> 00:13:04.567
But I'm a Java guy
and I love type safety.

00:13:04.567 --> 00:13:06.400
So I would like to have
the ability

00:13:06.400 --> 00:13:08.868
to do that rapid iteration
and that rapid prototyping

00:13:08.868 --> 00:13:11.234
but do it in a typesafe way.

00:13:11.234 --> 00:13:15.701
So having a soft schema
where I actually have

00:13:15.701 --> 00:13:19.100
some structure to my data
encoded in the application,

00:13:19.100 --> 00:13:20.734
that's gonna give me
that type safety

00:13:20.734 --> 00:13:22.100
but still give me
the flexibility

00:13:22.100 --> 00:13:23.601
to do that rapid prototyping.

00:13:23.601 --> 00:13:27.067
The other argument I want
to make in favor of soft schemas

00:13:27.067 --> 00:13:30.901
has to do with sort
of consistency throughout

00:13:30.901 --> 00:13:32.801
your development process.

00:13:32.801 --> 00:13:36.501
I've been on projects before
where we're developing

00:13:36.501 --> 00:13:38.100
a web application in Java.

00:13:38.100 --> 00:13:39.567
We're using a relational
database

00:13:39.567 --> 00:13:42.334
as our storage solution.

00:13:42.334 --> 00:13:47.100
And we typically find ourselves
doing things two different ways.

00:13:47.100 --> 00:13:50.133
So what goes into developing
this application?

00:13:50.133 --> 00:13:51.367
Well, we need to write code.

00:13:51.367 --> 00:13:52.901
We want to have unit tests.

00:13:52.901 --> 00:13:58.334
We want to have different
deployment environments,

00:13:58.334 --> 00:14:00.701
development, QA, staging,

00:14:00.701 --> 00:14:02.400
integration, production
and so on.

00:14:02.400 --> 00:14:05.000
And we find ourselves
sort of replicating that process

00:14:05.000 --> 00:14:06.834
for Java and then we find
ourselves replicating

00:14:06.834 --> 00:14:09.834
that process for managing
the database.

00:14:09.834 --> 00:14:11.467
We have to manage our seed data.

00:14:11.467 --> 00:14:13.200
We have to manage our schema.

00:14:13.200 --> 00:14:15.634
And then we have to figure out
a way to unit test

00:14:15.634 --> 00:14:19.400
that migration code
that we've written.

00:14:19.400 --> 00:14:22.334
And so it's these parallel ways

00:14:22.334 --> 00:14:24.467
of accomplishing
the same thing.

00:14:24.467 --> 00:14:27.400
And I'm not saying
it's not possible

00:14:27.400 --> 00:14:29.667
to get to a point where
you can do that efficiently.

00:14:29.667 --> 00:14:31.801
What I am saying is that
it takes effort,

00:14:31.801 --> 00:14:34.501
and oftentimes you end up
maybe cutting corners

00:14:34.501 --> 00:14:35.634
on one of those sides.

00:14:35.634 --> 00:14:38.501
And it's usually
on the database side.

00:14:38.501 --> 00:14:43.667
If you are using a soft schema,
you have the opportunity--

00:14:43.667 --> 00:14:45.767
in a sense it's sort
of a forcing function.

00:14:45.767 --> 00:14:48.300
It forces you
to do everything related

00:14:48.300 --> 00:14:50.968
to managing the structure
and the content

00:14:50.968 --> 00:14:54.067
of your Datastore the same way.

00:14:54.067 --> 00:14:57.567
So you can write your code
in Java.

00:14:57.567 --> 00:14:59.133
You can write
your business logic in Java.

00:14:59.133 --> 00:15:00.501
If you're using GWT,

00:15:00.501 --> 00:15:02.067
you can write your front end
in Java.

00:15:02.067 --> 00:15:04.200
And now, of course
you could do this before,

00:15:04.200 --> 00:15:06.667
but now we're sort of
forcing you a little bit

00:15:06.667 --> 00:15:08.601
to manage your data in Java.

00:15:08.601 --> 00:15:10.100
The benefit you get from that

00:15:10.100 --> 00:15:12.601
is you're doing everything
the same way.

00:15:12.601 --> 00:15:14.901
And I think there's a lot
of benefit to consistency

00:15:14.901 --> 00:15:19.534
in a software development
life cycle.

00:15:19.534 --> 00:15:21.634
So how are we going
to implement

00:15:21.634 --> 00:15:24.334
a soft schema on top
of the Datastore?

00:15:24.334 --> 00:15:26.767
Well, it turns out
in the Java world

00:15:26.767 --> 00:15:29.234
we are fortunate enough
to have not just one

00:15:29.234 --> 00:15:32.067
but two persistence standards.

00:15:32.067 --> 00:15:34.467
We have JDO and JPA.

00:15:34.467 --> 00:15:35.834
And just a quick show of hands,

00:15:35.834 --> 00:15:39.167
who here is familiar
with either JDO or JPA?

00:15:39.167 --> 00:15:40.701
Okay, so a fair number of hands.

00:15:40.701 --> 00:15:42.167
Really quick definition

00:15:42.167 --> 00:15:44.567
or a really quick explanation
of JDO and JPA.

00:15:44.567 --> 00:15:47.701
These are transparent
persistence frameworks.

00:15:47.701 --> 00:15:50.601
The idea is that
you take your model object

00:15:50.601 --> 00:15:51.934
from your application--

00:15:51.934 --> 00:15:53.667
let's say it's
a bug-tracking system,

00:15:53.667 --> 00:15:55.634
so you might have a bug object,

00:15:55.634 --> 00:15:59.000
and you provide some meta-data
for that bug object

00:15:59.000 --> 00:16:01.601
that describes how that object

00:16:01.601 --> 00:16:03.033
is supposed to be persisted.

00:16:03.033 --> 00:16:04.934
And typically you provide
that meta-data

00:16:04.934 --> 00:16:07.234
either using annotations
or XML

00:16:07.234 --> 00:16:09.200
and then you have this framework
behind the scenes

00:16:09.200 --> 00:16:11.067
that knows how to interpret
that meta-data

00:16:11.067 --> 00:16:14.801
and take that object and persist
it in some sort of Datastore.

00:16:14.801 --> 00:16:17.901
So JDO and JPA are both
Java persistence standards

00:16:17.901 --> 00:16:21.801
for getting this type
of transparent persistence.

00:16:21.801 --> 00:16:24.033
Now what I'm gonna argue
is that JDO and JPA

00:16:24.033 --> 00:16:28.167
effectively give you
a soft schema definition.

00:16:28.167 --> 00:16:30.400
How do I know that they do it?

00:16:30.400 --> 00:16:33.567
Well, if you've used pretty much
any ORM out there--

00:16:33.567 --> 00:16:35.868
you've used Hibernate or TopLink
or DataNucleus--

00:16:35.868 --> 00:16:38.534
they all come with
these roundtrip tools, right?

00:16:38.534 --> 00:16:39.868
The can take your Java objects

00:16:39.868 --> 00:16:41.667
that you've provided
the meta-data for

00:16:41.667 --> 00:16:43.501
and spit out a relational
database schema

00:16:43.501 --> 00:16:46.534
based on that meta-data, right?

00:16:46.534 --> 00:16:49.067
So if those
round-trip tools exist,

00:16:49.067 --> 00:16:51.167
if there's enough information
encoded in the meta-data

00:16:51.167 --> 00:16:53.901
that you provided to generate
a relational database schema,

00:16:53.901 --> 00:16:58.067
there must be enough information
in that meta-data

00:16:58.067 --> 00:17:02.067
to define what the structure
and the constraints

00:17:02.067 --> 00:17:05.467
that your application expects.

00:17:05.467 --> 00:17:09.734
So JDO and JPA,
just by using them

00:17:09.734 --> 00:17:12.767
the way that you would normally
use them, are going

00:17:12.767 --> 00:17:15.634
to give you this additional
structure to your application,

00:17:15.634 --> 00:17:17.667
which is gonna turn
the Datastore

00:17:17.667 --> 00:17:19.634
from something that maybe looks
a little bit different

00:17:19.634 --> 00:17:21.200
because it doesn't have
a schema

00:17:21.200 --> 00:17:23.567
into something that looks
a lot more like

00:17:23.567 --> 00:17:24.934
what you're used to.

00:17:24.934 --> 00:17:27.634
Something that has--

00:17:27.634 --> 00:17:29.834
we can call them tables
and columns.

00:17:29.834 --> 00:17:32.667
We know from looking
at the physical model

00:17:32.667 --> 00:17:34.033
which we already went through

00:17:34.033 --> 00:17:35.434
that they're not actually
tables and columns,

00:17:35.434 --> 00:17:39.701
but you can draw
that connection there.

00:17:39.701 --> 00:17:41.968
The other great thing
that we get from this

00:17:41.968 --> 00:17:45.834
beyond the soft schema is we get
to write our persistence code

00:17:45.834 --> 00:17:48.200
using established Java APIs.

00:17:48.200 --> 00:17:50.200
And there's huge value in this.

00:17:50.200 --> 00:17:53.834
If you already know
how to use JDO and JPA,

00:17:53.834 --> 00:17:56.100
and you understand what
the interfaces are,

00:17:56.100 --> 00:17:57.667
that's one less thing
for you to learn

00:17:57.667 --> 00:18:00.200
when you're trying to build
an application on App Engine.

00:18:00.200 --> 00:18:01.901
That's hugely valuable.

00:18:01.901 --> 00:18:05.901
Another great thing is if
you've used JPA or JDO recently

00:18:05.901 --> 00:18:09.767
and you use an IDE,
there's built-in tooling

00:18:09.767 --> 00:18:11.501
for these things already.

00:18:11.501 --> 00:18:16.267
If you create an Entity
in Eclipse or Intelliday

00:18:16.267 --> 00:18:17.467
and you set it up incorrectly,

00:18:17.467 --> 00:18:18.567
you're gonna get
the little red squiggle

00:18:18.567 --> 00:18:19.968
that says, "Hey,
you're doing it wrong."

00:18:19.968 --> 00:18:21.634
It takes a long time.

00:18:21.634 --> 00:18:23.067
Doesn't take a long--

00:18:23.067 --> 00:18:24.834
depending on the technology,
it can sometimes take a while

00:18:24.834 --> 00:18:27.434
for sort of
the tooling ecosystem

00:18:27.434 --> 00:18:29.133
around a new technology
to get built up.

00:18:29.133 --> 00:18:30.868
But because we're using things
that have already

00:18:30.868 --> 00:18:33.968
been around for a while,
a lot of that tooling exists.

00:18:33.968 --> 00:18:36.701
That's, again,
hugely valuable.

00:18:36.701 --> 00:18:39.767
The reason that I'm happiest--

00:18:39.767 --> 00:18:41.567
the reason I'm most happy
about this, though,

00:18:41.567 --> 00:18:45.434
is when it comes to porting.

00:18:45.434 --> 00:18:48.601
It's really important to us
on the App Engine team

00:18:48.601 --> 00:18:51.534
that you have the flexibility

00:18:51.534 --> 00:18:53.734
to take your code
someplace else

00:18:53.734 --> 00:18:58.300
if App Engine
isn't meeting your needs.

00:18:58.300 --> 00:19:01.567
We obviously want you to take
existing code and bring it on.

00:19:01.567 --> 00:19:03.067
We want you to try it out.

00:19:03.067 --> 00:19:07.267
But it's important to us
that you not feel locked in

00:19:07.267 --> 00:19:08.767
once you're there.

00:19:08.767 --> 00:19:11.033
And using these existing
persistence standards

00:19:11.033 --> 00:19:14.200
really goes a long way
towards making it easier

00:19:14.200 --> 00:19:15.634
to take your code
someplace else.

00:19:15.634 --> 00:19:17.133
That really is
important to us,

00:19:17.133 --> 00:19:18.634
and we're gonna go through
some examples

00:19:18.634 --> 00:19:21.067
later on in the talk
for some strategies

00:19:21.067 --> 00:19:23.968
of how to do that.

00:19:23.968 --> 00:19:27.234
So it turns out--
we looked at JDO and JPA.

00:19:27.234 --> 00:19:28.400
We said, "Okay, this is great.

00:19:28.400 --> 00:19:29.834
"We can get a soft schema
from this.

00:19:29.834 --> 00:19:31.000
"This is gonna make
the Datastore look

00:19:31.000 --> 00:19:32.701
"a little bit more familiar
to people.

00:19:32.701 --> 00:19:34.267
"We're gonna get
the established APIs.

00:19:34.267 --> 00:19:35.634
"We're gonna get the tooling.

00:19:35.634 --> 00:19:38.434
It's gonna be easier to port,
but will it work?"

00:19:38.434 --> 00:19:40.467
There's these existing standards

00:19:40.467 --> 00:19:43.801
and they were not designed
with platform

00:19:43.801 --> 00:19:45.067
as a service in mind.

00:19:45.067 --> 00:19:46.968
The did not have
the App Engine Datastore

00:19:46.968 --> 00:19:48.968
in mind when they were designing
these specifications.

00:19:48.968 --> 00:19:51.100
So does it actually line up?

00:19:51.100 --> 00:19:54.534
And the answer is mostly yeah.

00:19:54.534 --> 00:19:56.267
It's a pretty good fit.

00:19:56.267 --> 00:19:59.400
Turns out the specifications
are mostly mappable

00:19:59.400 --> 00:20:02.067
to Datastore features and
that the Datastore features--

00:20:02.067 --> 00:20:05.868
some of these interesting
features that I described

00:20:05.868 --> 00:20:08.968
a few minutes ago--
those features are actually

00:20:08.968 --> 00:20:11.033
mostly mappable
to the specifications.

00:20:11.033 --> 00:20:12.834
So we're gonna go through
some examples of how

00:20:12.834 --> 00:20:15.968
to surface some of these
Datastore-specific features

00:20:15.968 --> 00:20:18.334
through Java persistence
standards.

00:20:18.334 --> 00:20:21.634
So here's an example of how

00:20:21.634 --> 00:20:26.634
we can do an ancestor query
using JPA.

00:20:26.634 --> 00:20:30.767
You'll notice we have--
so this is a JPA entity here.

00:20:30.767 --> 00:20:32.968
Here's an address,
and let's assume

00:20:32.968 --> 00:20:34.968
that an address is owned
by a person, right?

00:20:34.968 --> 00:20:37.200
So we have a
one-to-many relationship

00:20:37.200 --> 00:20:38.767
from person to address.

00:20:38.767 --> 00:20:40.868
And I haven't shown you
the entire class here

00:20:40.868 --> 00:20:42.601
because it would be
too much code to read.

00:20:42.601 --> 00:20:45.300
But we do have a key, right?

00:20:45.300 --> 00:20:47.801
This is an App Engine-specific
primary key class,

00:20:47.801 --> 00:20:48.968
which you can use.

00:20:48.968 --> 00:20:50.267
You don't have to use it,
but in this case

00:20:50.267 --> 00:20:51.667
just for clarity we're using it.

00:20:51.667 --> 00:20:53.534
Here is a key
that uniquely identifies

00:20:53.534 --> 00:20:56.934
the person
that owns the address.

00:20:56.934 --> 00:20:58.534
If you were modeling this

00:20:58.534 --> 00:21:00.834
in the relational database
world,

00:21:00.834 --> 00:21:02.968
you could think of this
as a composite primary key.

00:21:02.968 --> 00:21:05.167
By using this extension
annotation,

00:21:05.167 --> 00:21:08.300
which is not an App Engine
specific annotation--

00:21:08.300 --> 00:21:10.734
this is actually something
that DataNucleus understands.

00:21:10.734 --> 00:21:12.734
By using this annotation,

00:21:12.734 --> 00:21:16.400
we can tell the App Engine
JDO/JPA implementation,

00:21:16.400 --> 00:21:21.567
"Hey, this is a parent.
This is part of an ancestor."

00:21:21.567 --> 00:21:25.334
And when you query
based on this field,

00:21:25.334 --> 00:21:27.801
we can recognize that and say,

00:21:27.801 --> 00:21:29.534
"Oh, the field
that they're querying by

00:21:29.534 --> 00:21:31.901
"is a parent primary key.

00:21:31.901 --> 00:21:34.300
Let me execute
an ancestor query."

00:21:34.300 --> 00:21:36.567
And so you can see
that this query down here

00:21:36.567 --> 00:21:38.601
which is just standard
JPA query,

00:21:38.601 --> 00:21:41.200
there's nothing special
about it.

00:21:41.200 --> 00:21:42.901
But we're interpreting it
in a special way

00:21:42.901 --> 00:21:44.033
because of this annotation.

00:21:44.033 --> 00:21:47.801
Filtering by multi-value
properties.

00:21:47.801 --> 00:21:51.234
This is a really, really nice
and natural way

00:21:51.234 --> 00:21:52.567
to express a query.

00:21:52.567 --> 00:21:54.200
So now we're looking
at a JDO example

00:21:54.200 --> 00:21:55.701
where we have a person

00:21:55.701 --> 00:21:58.534
and a person has some number
of hobbies.

00:21:58.534 --> 00:22:01.567
And we can just say,
"Select from person

00:22:01.567 --> 00:22:02.968
where hobbies contains yoga."

00:22:02.968 --> 00:22:04.801
Give me everybody who considers
yoga a hobby.

00:22:04.801 --> 00:22:08.467
This works and this
is a really natural way

00:22:08.467 --> 00:22:12.133
to express one
of the nicest features

00:22:12.133 --> 00:22:13.834
that you get from running
on the Datastore.

00:22:13.834 --> 00:22:17.167
Transactions.

00:22:17.167 --> 00:22:20.100
This is a little bit trickier.

00:22:20.100 --> 00:22:24.167
The API for transactions
in JDO and JPA

00:22:24.167 --> 00:22:26.534
is a nice fit with the API
for transactions

00:22:26.534 --> 00:22:27.901
in the Datastore.

00:22:27.901 --> 00:22:30.133
It's basically begin,
commit, or roll back.

00:22:30.133 --> 00:22:32.701
So syntactically
we're in good shape,

00:22:32.701 --> 00:22:35.501
but semantically it gets
a little bit more difficult,

00:22:35.501 --> 00:22:38.167
and the reason is because
of the nature

00:22:38.167 --> 00:22:40.267
of transactions which
I described before.

00:22:40.267 --> 00:22:42.901
How with the Datastore
you can only transact

00:22:42.901 --> 00:22:46.133
within an Entity Group.

00:22:46.133 --> 00:22:48.000
If you're coming from
the relational database world,

00:22:48.000 --> 00:22:50.667
you're probably used
to global transactions,

00:22:50.667 --> 00:22:53.968
where you can update any record
in your database

00:22:53.968 --> 00:22:56.467
and you can say "commit"
and that's totally fine.

00:22:56.467 --> 00:23:01.734
So how do we bridge
this gap?

00:23:01.734 --> 00:23:04.467
Well, we're gonna look
at some strategies later on.

00:23:04.467 --> 00:23:06.701
I just want to sort
of point out that there

00:23:06.701 --> 00:23:08.167
is this difference here.

00:23:08.167 --> 00:23:09.934
But the other thing
that I want to point out

00:23:09.934 --> 00:23:12.300
is that the challenge
that we're facing right here

00:23:12.300 --> 00:23:16.934
is really no different
than the challenge we face

00:23:16.934 --> 00:23:18.901
when we are sharding our data
anyway.

00:23:18.901 --> 00:23:20.834
So if you are splitting
your data

00:23:20.834 --> 00:23:23.133
across multiple relational
databases,

00:23:23.133 --> 00:23:25.267
you are going to face
a similar challenge.

00:23:25.267 --> 00:23:27.234
You don't have global
transactions anymore

00:23:27.234 --> 00:23:29.067
because you have data
that lives on this server

00:23:29.067 --> 00:23:30.534
and you have data that lives
on this server.

00:23:30.534 --> 00:23:33.267
So you can't just do
one global transaction here

00:23:33.267 --> 00:23:34.501
and expect to be able

00:23:34.501 --> 00:23:36.300
to atomically update
something over there.

00:23:36.300 --> 00:23:37.634
What's the solution?

00:23:37.634 --> 00:23:39.434
It's two phase commit.

00:23:39.434 --> 00:23:41.634
And as some of you might
have seen

00:23:41.634 --> 00:23:43.901
in Dan Wilkerson's talk
yesterday,

00:23:43.901 --> 00:23:46.767
he has a working algorithm
for two phase commit

00:23:46.767 --> 00:23:47.934
on the App Engine Datastore.

00:23:47.934 --> 00:23:50.267
So the problem is similar
to what you get

00:23:50.267 --> 00:23:51.701
with horizontal partitioning.

00:23:51.701 --> 00:23:53.167
The solution is similar

00:23:53.167 --> 00:23:57.267
to what you get
with horizontal partitioning.

00:23:57.267 --> 00:24:01.100
Let's talk about
relationship management.

00:24:01.100 --> 00:24:02.767
And this is not
a self-help course.

00:24:02.767 --> 00:24:05.367
We're talking about
JDO and JPA here.

00:24:05.367 --> 00:24:09.634
This is some of the most
powerful stuff that--

00:24:09.634 --> 00:24:11.234
and I'm gonna use
the word ORM.

00:24:11.234 --> 00:24:14.634
JDO and JPA are essentially
standards for ORMs

00:24:14.634 --> 00:24:17.501
and the "R" in ORM
stands for relational.

00:24:17.501 --> 00:24:19.100
And that's confusing because
we're not actually talking

00:24:19.100 --> 00:24:20.434
about anything relational here.

00:24:20.434 --> 00:24:21.667
But it's a common term, so...

00:24:21.667 --> 00:24:25.267
JDO and JPA are standards
for ORM.

00:24:25.267 --> 00:24:29.667
And I've spoken
with a sizeable number

00:24:29.667 --> 00:24:31.868
of developers over the years
who say,

00:24:31.868 --> 00:24:33.300
"I don't like ORM.

00:24:33.300 --> 00:24:35.334
"I don't like giving up
the control

00:24:35.334 --> 00:24:38.701
over what gets fetched
and what gets updated."

00:24:38.701 --> 00:24:40.067
And I totally understand that.

00:24:40.067 --> 00:24:46.334
It is fairly easy to have
a lot of things going on

00:24:46.334 --> 00:24:48.667
under the hood with an ORM.

00:24:48.667 --> 00:24:52.767
And some people really want
to stay close to the metal.

00:24:52.767 --> 00:24:54.501
The point that I want
to try to make here

00:24:54.501 --> 00:25:00.000
is that JDO and JPA
have a lot of value

00:25:00.000 --> 00:25:04.100
beyond sort of all the magic
that it will do under the hood

00:25:04.100 --> 00:25:06.234
related to relationship
management.

00:25:06.234 --> 00:25:09.067
By relationship management,
I'm talking about the fact

00:25:09.067 --> 00:25:11.267
that you can declare
a one-to-many relationship

00:25:11.267 --> 00:25:14.000
and you can just sort of add
something to a collection,

00:25:14.000 --> 00:25:15.701
and because it's reachable
from something

00:25:15.701 --> 00:25:17.601
that's already persisted
it will automatically

00:25:17.601 --> 00:25:18.868
get written to the Datastore.

00:25:18.868 --> 00:25:20.834
The fact that you can touch
some object

00:25:20.834 --> 00:25:22.834
which hasn't been loaded
by the Datastore yet

00:25:22.834 --> 00:25:24.000
and the framework will say,

00:25:24.000 --> 00:25:25.234
"Oh, this thing hasn't
been loaded,"

00:25:25.234 --> 00:25:26.501
and it will pull it
into memory, right?

00:25:26.501 --> 00:25:27.801
That's
the kind of stuff

00:25:27.801 --> 00:25:31.300
that people can easily
get tangled up in.

00:25:31.300 --> 00:25:33.200
And the point that I want
to make

00:25:33.200 --> 00:25:35.267
is that you don't have
to take advantage

00:25:35.267 --> 00:25:38.868
of all of that stuff
to find JDO and JPA useful.

00:25:38.868 --> 00:25:41.834
The biggest benefit,
I think,

00:25:41.834 --> 00:25:43.100
that you get
from these technologies

00:25:43.100 --> 00:25:46.467
is the fact that you have
a centralized mapping

00:25:46.467 --> 00:25:50.801
for the meta-data
of your model objects, right?

00:25:50.801 --> 00:25:53.167
It's not scattered around
your application

00:25:53.167 --> 00:25:58.133
in a bunch of properties files
that have SQL statements

00:25:58.133 --> 00:26:01.801
or Java files that are doing--
that have JDVC code.

00:26:01.801 --> 00:26:03.267
It's centralized,

00:26:03.267 --> 00:26:06.868
either in XML meta-data or
in annotations on your object.

00:26:06.868 --> 00:26:11.334
That is a big
maintainability win.

00:26:11.334 --> 00:26:14.601
And just using that alone,
right, you get the soft schema.

00:26:14.601 --> 00:26:17.601
You get the familiar APIs.
You get the tooling.

00:26:17.601 --> 00:26:18.901
You get the portability.

00:26:18.901 --> 00:26:20.133
And you don't even have
to touch

00:26:20.133 --> 00:26:22.033
the relationship management
stuff.

00:26:22.033 --> 00:26:24.634
Now, that said, I also
want to encourage you

00:26:24.634 --> 00:26:26.133
to try and take advantage

00:26:26.133 --> 00:26:28.167
of the relationship management
stuff.

00:26:28.167 --> 00:26:32.033
And the reason is that
on the App Engine Datastore,

00:26:32.033 --> 00:26:36.400
this becomes more important.

00:26:36.400 --> 00:26:38.601
It becomes more important
than it might be

00:26:38.601 --> 00:26:40.367
if you were using
a relational database.

00:26:40.367 --> 00:26:42.634
The reason is that
relational databases

00:26:42.634 --> 00:26:44.734
have foreign key constraints.

00:26:44.734 --> 00:26:47.000
So when you have a one-to-many
relationship between,

00:26:47.000 --> 00:26:48.934
say, person and address,

00:26:48.934 --> 00:26:51.033
and you want to store
the primary key of the person

00:26:51.033 --> 00:26:53.067
that owns an address
on the address table,

00:26:53.067 --> 00:26:55.467
you have a foreign key there

00:26:55.467 --> 00:26:58.901
and if you add something
to that person ID column

00:26:58.901 --> 00:27:01.701
on the address table
that if you set it to null

00:27:01.701 --> 00:27:03.200
and it's not nullable,

00:27:03.200 --> 00:27:04.834
or you're referencing
a person ID that doesn't exist,

00:27:04.834 --> 00:27:08.000
the database is going to catch
that mistake and say "no."

00:27:08.000 --> 00:27:11.367
But the App Engine Datastore
is schema-less, right?

00:27:11.367 --> 00:27:13.200
We're gonna be more flexible
about things.

00:27:13.200 --> 00:27:17.167
But if you let JDO and JPA
take care

00:27:17.167 --> 00:27:19.367
of the relationship management,

00:27:19.367 --> 00:27:22.400
they're gonna make sure that
these things get set properly.

00:27:22.400 --> 00:27:24.167
Now you can write this code
yourself.

00:27:24.167 --> 00:27:27.934
And typically what happens
is you write it yourself once.

00:27:27.934 --> 00:27:29.868
You write it yourself
a second time.

00:27:29.868 --> 00:27:31.133
You write it yourself
a third time.

00:27:31.133 --> 00:27:33.534
All of these different
situations,

00:27:33.534 --> 00:27:35.501
you probably get them
mostly right.

00:27:35.501 --> 00:27:37.567
And then at the fourth time,
you say,

00:27:37.567 --> 00:27:39.000
"Man, I'm sick of writing
this code.

00:27:39.000 --> 00:27:40.267
"I'm gonna write
a small framework

00:27:40.267 --> 00:27:42.000
to take care of it for me."

00:27:42.000 --> 00:27:44.467
And the next thing you know
we have our 18th ORM

00:27:44.467 --> 00:27:48.667
that's available
on SourceForge.

00:27:48.667 --> 00:27:53.634
So letting the framework
manage relationships for you

00:27:53.634 --> 00:27:56.200
is particularly important
when you're using

00:27:56.200 --> 00:27:57.400
the App Engine Datastore
because

00:27:57.400 --> 00:28:00.701
there are no foreign key
constraints.

00:28:00.701 --> 00:28:06.734
The other big win, and for me
this is the killer feature--

00:28:06.734 --> 00:28:12.667
I'm gonna try to convince you
that this is cool and useful.

00:28:12.667 --> 00:28:13.934
The killer feature here

00:28:13.934 --> 00:28:15.501
is transparent Entity Group
management.

00:28:15.501 --> 00:28:19.100
Deciding what Entity Groups

00:28:19.100 --> 00:28:20.801
your objects
are going to reside in

00:28:20.801 --> 00:28:22.634
is one
of the most important

00:28:22.634 --> 00:28:24.167
design decisions
that you're going to make

00:28:24.167 --> 00:28:25.968
when you're building
an App Engine application.

00:28:25.968 --> 00:28:27.901
And there's some tension here,
right?

00:28:27.901 --> 00:28:30.300
It's tension between
write throughput

00:28:30.300 --> 00:28:33.567
and atomic updates.

00:28:33.567 --> 00:28:39.234
There is a limit on how often
you can update something

00:28:39.234 --> 00:28:41.567
that lives in an Entity Group.

00:28:41.567 --> 00:28:44.434
It's approximately 1 to 10
writes per second

00:28:44.434 --> 00:28:46.200
within a single Entity group.

00:28:46.200 --> 00:28:47.701
But on the other hand,

00:28:47.701 --> 00:28:50.701
the only way that you can update
multiple objects atomically

00:28:50.701 --> 00:28:52.300
is if they live in the same
Entity Group.

00:28:52.300 --> 00:28:54.067
All right, so you might say,

00:28:54.067 --> 00:28:56.534
"Okay, well I want to have
global transaction,

00:28:56.534 --> 00:28:58.100
"so let me put everything
in my application

00:28:58.100 --> 00:28:59.634
in the same Entity Group."

00:28:59.634 --> 00:29:03.300
Okay, but now you're limited
to 1 to 10 writes per second

00:29:03.300 --> 00:29:04.667
and you're gonna get lots

00:29:04.667 --> 00:29:06.234
of concurrent modification
exceptions.

00:29:06.234 --> 00:29:07.667
So there's a balancing act here

00:29:07.667 --> 00:29:10.801
and only you know what
the right balance is.

00:29:10.801 --> 00:29:13.667
Once you've decided
what that balance is

00:29:13.667 --> 00:29:15.901
it's up to you to implement
that in your application

00:29:15.901 --> 00:29:17.334
to make sure that these objects

00:29:17.334 --> 00:29:19.000
actually go into the correct
Entity Groups.

00:29:19.000 --> 00:29:20.868
However, if you use

00:29:20.868 --> 00:29:23.234
the relationship management
functionality

00:29:23.234 --> 00:29:25.968
that comes with JDO and JPA,

00:29:25.968 --> 00:29:29.167
we are going to be able
to assign objects

00:29:29.167 --> 00:29:33.200
to appropriate Entity Groups
on your behalf.

00:29:33.200 --> 00:29:34.934
So when we talk about
relationships,

00:29:34.934 --> 00:29:38.601
we typically refer to them
as either owned or unowned.

00:29:38.601 --> 00:29:42.601
And by owned I mean
the child object

00:29:42.601 --> 00:29:45.133
doesn't make sense
without its parent.

00:29:45.133 --> 00:29:47.467
As an example,
think of a book as a parent

00:29:47.467 --> 00:29:49.367
and a chapter as a child.

00:29:49.367 --> 00:29:53.334
It doesn't make sense to have
a chapter without a book.

00:29:53.334 --> 00:29:56.467
An unowned relationship,
on the other hand,

00:29:56.467 --> 00:29:58.701
is something
that can exist perfectly fine

00:29:58.701 --> 00:30:00.234
without an owner.

00:30:00.234 --> 00:30:02.167
You might have a person
and you have a car,

00:30:02.167 --> 00:30:03.734
and you might have
an association

00:30:03.734 --> 00:30:05.767
between a person and a car
at some point in time,

00:30:05.767 --> 00:30:08.334
but the person could go away
and the car still exists.

00:30:08.334 --> 00:30:10.334
It still makes sense and maybe
somebody else owns it

00:30:10.334 --> 00:30:11.767
or maybe nobody owns it.

00:30:11.767 --> 00:30:13.901
But we could describe that
as an unowned relationship.

00:30:13.901 --> 00:30:15.834
So the way that we make

00:30:15.834 --> 00:30:17.934
transparent Entity Group
management work

00:30:17.934 --> 00:30:24.000
is we let ownership imply
Entity Group co-location.

00:30:24.000 --> 00:30:28.767
So here's an example,
and this is a JPA snippet

00:30:28.767 --> 00:30:32.000
where we have a person Entity

00:30:32.000 --> 00:30:34.434
with a one-to-many relationship
to pet.

00:30:34.434 --> 00:30:36.834
And then down below,

00:30:36.834 --> 00:30:39.701
we show you what
the physical model looks like

00:30:39.701 --> 00:30:42.601
when you set up your model
this way.

00:30:42.601 --> 00:30:45.133
I want to point out that
this model,

00:30:45.133 --> 00:30:47.167
this is standard JPA code,
right?

00:30:47.167 --> 00:30:49.501
There's nothing about
Entity Groups in here.

00:30:49.501 --> 00:30:51.400
We've just said @Entity
@OneToMany.

00:30:51.400 --> 00:30:55.000
But since @OneToMany tells us
that this

00:30:55.000 --> 00:30:58.701
is an owned relationship,
we can use that information

00:30:58.701 --> 00:31:01.501
to automatically place pet

00:31:01.501 --> 00:31:03.801
in the same Entity Group
as person.

00:31:03.801 --> 00:31:08.934
So on the left here we have
person, which is the parent,

00:31:08.934 --> 00:31:11.901
and then on the right
we can see that this pet,

00:31:11.901 --> 00:31:15.534
pet number 18, its parent key
is this person.

00:31:15.534 --> 00:31:17.868
They're sitting there
in this same Entity Group.

00:31:17.868 --> 00:31:20.033
So this works great.

00:31:20.033 --> 00:31:24.901
This is a powerful way...

00:31:24.901 --> 00:31:28.767
to take one of...

00:31:28.767 --> 00:31:30.868
the newest...

00:31:30.868 --> 00:31:37.267
Entity Groups are a feature
of the Datastore

00:31:37.267 --> 00:31:40.701
that you need to understand
in order to be successful

00:31:40.701 --> 00:31:43.367
building your application.

00:31:43.367 --> 00:31:46.167
But this is a really nice way
for us

00:31:46.167 --> 00:31:48.734
to give you some sensible
default values for it

00:31:48.734 --> 00:31:52.234
so that you don't have to
contend with it quite as much.

00:31:52.234 --> 00:31:54.567
So again, this is along
the lines of taking something

00:31:54.567 --> 00:31:56.667
that's maybe
not quite so familiar

00:31:56.667 --> 00:31:59.934
and folding it into a concept
that you already understand

00:31:59.934 --> 00:32:01.767
to make it a little bit more
familiar.

00:32:01.767 --> 00:32:05.601
So why does it say
owned one-to-many today?

00:32:05.601 --> 00:32:07.467
Well, let me show you what
I want the future

00:32:07.467 --> 00:32:09.834
of owned one-to-many
to look like.

00:32:09.834 --> 00:32:12.834
You'll notice that there's
an additional property

00:32:12.834 --> 00:32:14.234
on that person Entity there

00:32:14.234 --> 00:32:17.501
where the parent actually
has a reference

00:32:17.501 --> 00:32:21.567
to the thing that it owns.

00:32:21.567 --> 00:32:24.434
Why is this important?

00:32:24.434 --> 00:32:27.067
Well, I can think
of two reasons.

00:32:27.067 --> 00:32:30.968
First off, if the parent
has a reference to its child,

00:32:30.968 --> 00:32:34.534
that opens the door
to a certain subset

00:32:34.534 --> 00:32:37.634
of join queries that you can't
otherwise express

00:32:37.634 --> 00:32:40.067
using the Datastore.

00:32:40.067 --> 00:32:43.501
This lets us issue a query
that says,

00:32:43.501 --> 00:32:46.100
"Give me all people--

00:32:46.100 --> 00:32:51.734
"Give me a person older than 30
that owns a particular pet."

00:32:51.734 --> 00:32:53.634
That is a type of join query

00:32:53.634 --> 00:32:56.133
that is otherwise difficult
to express.

00:32:56.133 --> 00:32:57.567
The other thing it does
is open the door

00:32:57.567 --> 00:32:58.968
to some optimizations.

00:32:58.968 --> 00:33:00.701
Wouldn't it be great
if you had a person object

00:33:00.701 --> 00:33:02.200
loaded in memory?

00:33:02.200 --> 00:33:05.801
You haven't loaded the pets
owned by this person yet

00:33:05.801 --> 00:33:10.567
and you can say, "Hey, person,
how many pets do you have?"

00:33:10.567 --> 00:33:13.868
If you have all of the pets
that the person owns

00:33:13.868 --> 00:33:16.467
as part of the person Entity,
you can answer that question

00:33:16.467 --> 00:33:18.934
without making another trip
to the Datastore

00:33:18.934 --> 00:33:21.033
issuing another query
to get that answer.

00:33:21.033 --> 00:33:23.267
If you don't have
that information,

00:33:23.267 --> 00:33:24.701
it's absolutely another trip
to the Datastore.

00:33:24.701 --> 00:33:26.334
So there's some nice
optimizations

00:33:26.334 --> 00:33:28.801
that this enables for us.

00:33:28.801 --> 00:33:30.567
So what's stopping us?

00:33:30.567 --> 00:33:34.067
Well...

00:33:34.067 --> 00:33:39.200
there is this interesting
constraint in the Datastore

00:33:39.200 --> 00:33:43.734
that you can only update
an Entity once in a transaction.

00:33:43.734 --> 00:33:48.734
And to be perfectly frank,
this is an implementation detail

00:33:48.734 --> 00:33:51.634
that has sort of found its way
out to you.

00:33:51.634 --> 00:33:54.033
But it's something that
we have to contend with.

00:33:54.033 --> 00:33:59.133
So let's think about
what would be involved

00:33:59.133 --> 00:34:01.033
in getting that child key
onto the parent.

00:34:01.033 --> 00:34:03.434
First let me explain

00:34:03.434 --> 00:34:05.400
the Datastore can do ID
generation for you.

00:34:05.400 --> 00:34:06.968
But the only way to get
the Datastore

00:34:06.968 --> 00:34:09.667
to generate that ID for you
is to actually save the object.

00:34:09.667 --> 00:34:11.801
It's sort of like an identity
column in MySQL

00:34:11.801 --> 00:34:15.367
where you insert the record
and when it comes back

00:34:15.367 --> 00:34:17.434
it has that value set.

00:34:17.434 --> 00:34:21.200
So we need to get the child key
on the parent, right?

00:34:21.200 --> 00:34:24.534
So in order to get that child
key we have to save the child.

00:34:24.534 --> 00:34:27.133
That's the only way we're
gonna get that ID generated.

00:34:27.133 --> 00:34:29.367
But we need to make sure
that the child resides

00:34:29.367 --> 00:34:31.167
in the same Entity Group
as its parent.

00:34:31.167 --> 00:34:33.400
And the only way to get a child

00:34:33.400 --> 00:34:35.501
into the same Entity Group
as its parent

00:34:35.501 --> 00:34:39.100
is to construct that key
using the key of the parent.

00:34:39.100 --> 00:34:41.467
So we need the key of the parent
before we can save the child.

00:34:41.467 --> 00:34:44.467
That means we need
to save the parent first.

00:34:44.467 --> 00:34:47.601
Okay, so we can save the person.

00:34:47.601 --> 00:34:49.000
We can get the person key back.

00:34:49.000 --> 00:34:51.834
We can use that person key
to construct the child key.

00:34:51.834 --> 00:34:55.033
We can then save the child,
get the child key,

00:34:55.033 --> 00:34:56.534
and then we can set it back
on the person

00:34:56.534 --> 00:34:57.968
and we can save it.

00:34:57.968 --> 00:35:01.067
Except that's the second update
to the person

00:35:01.067 --> 00:35:03.200
in the same transaction.

00:35:03.200 --> 00:35:04.634
So we can't do it.

00:35:04.634 --> 00:35:08.868
What we need is a get next idea
operation on the Datastore

00:35:08.868 --> 00:35:12.934
which fortunately we are
in a good position to add

00:35:12.934 --> 00:35:14.601
but it's not there yet.

00:35:14.601 --> 00:35:17.133
Once that operation
is available

00:35:17.133 --> 00:35:18.634
we can solve this problem,
right?

00:35:18.634 --> 00:35:20.667
We can ask the Datastore for,

00:35:20.667 --> 00:35:22.701
"Hey, give me the next ID
for a person.

00:35:22.701 --> 00:35:28.267
Hey, give me the next ID
for a pet."

00:35:28.267 --> 00:35:31.601
Now I can take that pet ID.
I can set it on the person.

00:35:31.601 --> 00:35:33.167
I can save the person.
I can save the child.

00:35:33.167 --> 00:35:34.701
And I've got what I want
by only updating

00:35:34.701 --> 00:35:37.767
the person once
in my transaction.

00:35:37.767 --> 00:35:39.334
That's great.

00:35:39.334 --> 00:35:43.200
The other thing that
it's important for us to solve--

00:35:43.200 --> 00:35:45.667
and I'll be honest,
I don't have as clear a picture

00:35:45.667 --> 00:35:48.267
of how we're gonna solve this as
I do for this other scenario--

00:35:48.267 --> 00:35:50.634
is unknown relationships.

00:35:50.634 --> 00:35:52.767
So we've talked about
how JDO and JPA,

00:35:52.767 --> 00:35:55.200
we can use ownership
to imply co-location

00:35:55.200 --> 00:35:56.601
within an Entity Group.

00:35:56.601 --> 00:35:59.000
Well, JDO and JPA also provide
a really nice way

00:35:59.000 --> 00:36:01.200
to express unknown relationship

00:36:01.200 --> 00:36:05.067
using the objects themselves,
right?

00:36:05.067 --> 00:36:07.634
Instead of just having a key,

00:36:07.634 --> 00:36:10.801
you get the object itself
as a member

00:36:10.801 --> 00:36:13.467
to model that association.

00:36:13.467 --> 00:36:17.801
So we can use an unknown
relationship as a queue

00:36:17.801 --> 00:36:20.534
to store these Entities
in separate Entity Groups.

00:36:20.534 --> 00:36:24.501
The issue here, though,
is again

00:36:24.501 --> 00:36:27.167
you can only transact across
Entities that live

00:36:27.167 --> 00:36:28.534
in the same Entity Group.

00:36:28.534 --> 00:36:31.934
So if you had a person
and you had a car

00:36:31.934 --> 00:36:33.200
and you had an unknown
relationship

00:36:33.200 --> 00:36:34.400
between person and car,

00:36:34.400 --> 00:36:36.834
but they live
in separate Entity groups,

00:36:36.834 --> 00:36:38.501
and you start a transaction,

00:36:38.501 --> 00:36:43.234
and you load the person,
and then you load the car,

00:36:43.234 --> 00:36:45.567
you get an exception
because you're trying

00:36:45.567 --> 00:36:49.234
to do something transactionally
across multiple Entity Groups.

00:36:49.234 --> 00:36:53.801
So there's a danger here
of exposing something

00:36:53.801 --> 00:36:57.000
that everyone expects to work
in JDO and JPA

00:36:57.000 --> 00:36:59.267
and it looks normal except
when you try to do something

00:36:59.267 --> 00:37:01.734
totally normal and obvious
with it, it doesn't work.

00:37:01.734 --> 00:37:03.367
That's dangerous.

00:37:03.367 --> 00:37:05.234
That's not something
that we want to do.

00:37:05.234 --> 00:37:07.033
So I don't know what
the right answer here is.

00:37:07.033 --> 00:37:09.267
We may need to come up
with something.

00:37:09.267 --> 00:37:11.367
The other thing that
it's important for us to do

00:37:11.367 --> 00:37:14.467
with the JDO and JPA
implementations

00:37:14.467 --> 00:37:20.400
is achieve feature parody
with the Python Datastore API.

00:37:20.400 --> 00:37:22.734
Those of you who are familiar
with both

00:37:22.734 --> 00:37:25.000
may have noticed
that with Python

00:37:25.000 --> 00:37:27.901
it is possible to do
a not equals query.

00:37:27.901 --> 00:37:30.167
Or it is possible to do
an in query.

00:37:30.167 --> 00:37:33.234
Select star from person where
favorite color

00:37:33.234 --> 00:37:37.100
is in blue, yellow, red.

00:37:37.100 --> 00:37:40.400
That imbalance
isn't just because, like,

00:37:40.400 --> 00:37:42.534
we need to flip some bit
on the Java side.

00:37:42.534 --> 00:37:45.701
The Datastore itself
does not natively satisfy

00:37:45.701 --> 00:37:47.000
those types of queries.

00:37:47.000 --> 00:37:49.133
What we did for Python
because we had a little bit

00:37:49.133 --> 00:37:51.968
of extra time
is we implemented those--

00:37:51.968 --> 00:37:53.300
we call it in user land.

00:37:53.300 --> 00:37:56.601
It's sort of part
of the API layer itself.

00:37:56.601 --> 00:37:59.601
There's no reason why
we can't do that for Java.

00:37:59.601 --> 00:38:01.434
We just haven't done it yet.

00:38:01.434 --> 00:38:02.601
But that's an important step.

00:38:02.601 --> 00:38:05.434
And then our JDO and JPA
implementations

00:38:05.434 --> 00:38:11.067
are gonna be
a lot more filled out.

00:38:11.067 --> 00:38:13.300
So let's talk about
some strategies

00:38:13.300 --> 00:38:19.334
for migrating existing code
to App Engine.

00:38:19.334 --> 00:38:21.767
And I know I hammered this point
home at the beginning,

00:38:21.767 --> 00:38:23.934
but I'm gonna say it again.

00:38:23.934 --> 00:38:25.734
The Datastore is not
a relational database.

00:38:25.734 --> 00:38:28.267
It is not a drop-in replacement
for a relational database.

00:38:28.267 --> 00:38:31.601
So even though we are talking
about Java persistence standards

00:38:31.601 --> 00:38:35.601
which are oftentimes used
to persist things

00:38:35.601 --> 00:38:37.100
in relational databases,

00:38:37.100 --> 00:38:39.901
that does not mean that
the App Engine Datastore

00:38:39.901 --> 00:38:41.634
is a relational database.

00:38:41.634 --> 00:38:44.367
When you want
to bring code over,

00:38:44.367 --> 00:38:45.901
you're going to need to do
a bunch of analysis

00:38:45.901 --> 00:38:47.467
of your application.

00:38:47.467 --> 00:38:51.133
You're gonna want to look
at your use of primary keys.

00:38:51.133 --> 00:38:53.667
You're gonna want to look
at your use of transactions,

00:38:53.667 --> 00:38:57.767
of queries, of vendor-specific
features.

00:38:57.767 --> 00:39:01.701
And you're gonna need
to come up with a plan.

00:39:01.701 --> 00:39:04.501
You're gonna need to think
about data migration as well.

00:39:04.501 --> 00:39:06.801
I really can't emphasize
this point enough.

00:39:06.801 --> 00:39:09.467
Data migration--
I don't think I've ever

00:39:09.467 --> 00:39:11.801
given an estimate
for data migration

00:39:11.801 --> 00:39:14.133
that was within 3x of what
it actually ended up being.

00:39:14.133 --> 00:39:16.767
It's just one of those things
that always ends up harder

00:39:16.767 --> 00:39:18.067
than you expect.

00:39:18.067 --> 00:39:19.667
So don't forget about
the data migration.

00:39:19.667 --> 00:39:21.634
You may notice that--

00:39:21.634 --> 00:39:23.534
and we're going to get into
some more specific advice.

00:39:23.534 --> 00:39:25.234
But the advice
that I'm giving so far,

00:39:25.234 --> 00:39:27.434
there's actually nothing
App Engine-specific about this.

00:39:27.434 --> 00:39:30.133
If you were switching between
any two databases,

00:39:30.133 --> 00:39:31.934
there's are exactly
the sorts of things

00:39:31.934 --> 00:39:34.334
that you would want to look at
and think about.

00:39:34.334 --> 00:39:37.901
So let's talk about
primary keys in particular.

00:39:37.901 --> 00:39:42.167
If you have single column
primary keys

00:39:42.167 --> 00:39:45.234
that are numbers or strings,
VARCHARs,

00:39:45.234 --> 00:39:47.534
that's gonna work pretty nicely.

00:39:47.534 --> 00:39:51.133
There's a very straightforward
way to map that on.

00:39:51.133 --> 00:39:55.167
Composite keys--
with the Datastore we just have

00:39:55.167 --> 00:39:56.734
a notion of a key.

00:39:56.734 --> 00:39:58.033
But it is sort
of a composite key

00:39:58.033 --> 00:39:59.934
because we do have
a notion of ancestor.

00:39:59.934 --> 00:40:04.834
So if your composite key
can be thought of

00:40:04.834 --> 00:40:06.300
as an ownership chain,

00:40:06.300 --> 00:40:08.834
like a single strand
ownership chain,

00:40:08.834 --> 00:40:10.734
then you can take
your composite key

00:40:10.734 --> 00:40:14.234
and you can map that
to ancestors and Entity Groups.

00:40:14.234 --> 00:40:15.567
That works pretty nicely.

00:40:15.567 --> 00:40:18.667
So we have an example here
of a pet object

00:40:18.667 --> 00:40:20.801
where we have a composite
primary key consisting

00:40:20.801 --> 00:40:23.300
of the pet ID and the person ID.

00:40:23.300 --> 00:40:24.834
And then over here on the right

00:40:24.834 --> 00:40:28.133
we can see that this maps
to an ancestor chain,

00:40:28.133 --> 00:40:33.067
where the top level element
is the person

00:40:33.067 --> 00:40:35.133
and the child element
is the pet.

00:40:35.133 --> 00:40:38.667
For mapping tables,

00:40:38.667 --> 00:40:40.501
you could think
of a mapping table--

00:40:40.501 --> 00:40:43.601
and in many cases,
actually, it is--

00:40:43.601 --> 00:40:45.601
it contains a composite
primary key

00:40:45.601 --> 00:40:48.267
where there isn't a single
chain of ownership, right?

00:40:48.267 --> 00:40:49.968
If it's a mapping table,

00:40:49.968 --> 00:40:52.267
chances are it's owned
by multiple things.

00:40:52.267 --> 00:40:55.601
So this fits really well
with multi-value properties.

00:40:55.601 --> 00:40:57.968
So in this example
we have a friendship table

00:40:57.968 --> 00:40:59.868
modeling
who is friends with who.

00:40:59.868 --> 00:41:01.367
And we can see that person 8

00:41:01.367 --> 00:41:03.901
is friends
with person 32 and 34.

00:41:03.901 --> 00:41:05.634
And we can translate this nicely

00:41:05.634 --> 00:41:08.000
to a multi-value property
called friends

00:41:08.000 --> 00:41:10.467
on a person entity.

00:41:10.467 --> 00:41:11.834
And it has multiple values.

00:41:11.834 --> 00:41:14.100
Person 8 is friends
with person 32 and 34.

00:41:14.100 --> 00:41:15.200
Now you may look at this
and say,

00:41:15.200 --> 00:41:16.501
"Wait a second.

00:41:16.501 --> 00:41:18.400
"That's only a unidirectional
relationship.

00:41:18.400 --> 00:41:20.534
"What if I want to model
the fact

00:41:20.534 --> 00:41:23.133
"that person 32
is friends with person 8

00:41:23.133 --> 00:41:24.767
and then person 34 is friends
with person 8?"

00:41:24.767 --> 00:41:27.801
You can do that.

00:41:27.801 --> 00:41:29.667
It will work okay
but there are some

00:41:29.667 --> 00:41:33.000
more complicated things that you
need to start thinking about,

00:41:33.000 --> 00:41:35.868
particularly related
to transactions, right?

00:41:35.868 --> 00:41:38.400
Person 8 and person 32 are
in separate Entity Groups.

00:41:38.400 --> 00:41:40.200
And let's say I want
to establish

00:41:40.200 --> 00:41:42.767
a bidirectional friendship
relationship between them.

00:41:42.767 --> 00:41:47.133
That means that I need
to update person 8

00:41:47.133 --> 00:41:49.234
in one Entity Group
and person 32

00:41:49.234 --> 00:41:50.734
in another Entity Group.

00:41:50.734 --> 00:41:52.901
And if I want that
to happen atomically

00:41:52.901 --> 00:41:55.567
now I'm in a tough spot because

00:41:55.567 --> 00:41:57.000
they're in different
Entity Groups.

00:41:57.000 --> 00:41:58.567
So now it's up to me
to decide, well,

00:41:58.567 --> 00:42:00.167
is it okay
if the first one succeeds

00:42:00.167 --> 00:42:01.901
and the second one fails?

00:42:01.901 --> 00:42:03.200
Do I want to roll
the first one back

00:42:03.200 --> 00:42:04.734
with a compensating transaction?

00:42:04.734 --> 00:42:06.167
Do I want to have something
sweep through

00:42:06.167 --> 00:42:08.434
and clean it up later?

00:42:08.434 --> 00:42:09.868
There's a little bit more
to it,

00:42:09.868 --> 00:42:13.634
which brings us nicely
to our next subject--

00:42:13.634 --> 00:42:17.033
what's involved in porting
on transactions.

00:42:17.033 --> 00:42:20.701
We talked about
the mismatch before.

00:42:20.701 --> 00:42:22.934
How at the Datastore
we have transactions

00:42:22.934 --> 00:42:25.367
across Entity Groups
and with relational databases.

00:42:25.367 --> 00:42:27.367
If we're not partitioning
our data,

00:42:27.367 --> 00:42:32.000
we're typically used to having
global transactions.

00:42:32.000 --> 00:42:35.300
So the strategy here
is you want to identify

00:42:35.300 --> 00:42:37.534
the roots in your data model.

00:42:37.534 --> 00:42:39.801
And if you're building
an online service,

00:42:39.801 --> 00:42:42.100
the first place I would
recommend looking is user.

00:42:42.100 --> 00:42:45.000
Can you hang all of the data
off of a user

00:42:45.000 --> 00:42:47.501
and get reasonable write
throughput?

00:42:47.501 --> 00:42:49.167
If that works,
you're in good shape.

00:42:49.167 --> 00:42:50.567
It's not gonna work
for everybody,

00:42:50.567 --> 00:42:52.067
but it's a good first place
to look.

00:42:52.067 --> 00:42:55.501
Once you've identified
the roots in your data model,

00:42:55.501 --> 00:42:57.234
you're gonna need to find
the operations

00:42:57.234 --> 00:43:00.000
in your application that
transact across multiple roots.

00:43:00.000 --> 00:43:04.300
Again, these are the scenarios
where the fact

00:43:04.300 --> 00:43:06.734
that transactions apply
to a single Entity Group--

00:43:06.734 --> 00:43:09.367
these are the scenarios
where that is going

00:43:09.367 --> 00:43:12.767
to force you to do something
a little bit different.

00:43:12.767 --> 00:43:14.167
Well, what's it going
to force you to do?

00:43:14.167 --> 00:43:17.267
Well, it really depends
on the specific situation.

00:43:17.267 --> 00:43:20.234
You need to look
at these scenarios

00:43:20.234 --> 00:43:23.834
and figure out what
partial success means.

00:43:23.834 --> 00:43:24.868
Is it acceptable?

00:43:24.868 --> 00:43:27.968
In the bank account transfer
example,

00:43:27.968 --> 00:43:29.467
probably not acceptable.

00:43:29.467 --> 00:43:31.968
Partial success is probably
not acceptable.

00:43:31.968 --> 00:43:34.701
So what do you do about it?

00:43:34.701 --> 00:43:37.334
Well, one option, and I wouldn't
expect anybody at all

00:43:37.334 --> 00:43:39.133
to be happy about this,
but one option

00:43:39.133 --> 00:43:40.701
is to say, "Well, I'm not
gonna support this anymore."

00:43:40.701 --> 00:43:42.234
You're gonna just change
the functionality

00:43:42.234 --> 00:43:43.434
of your application.

00:43:43.434 --> 00:43:47.300
Better examples,
if partial success is okay--

00:43:47.300 --> 00:43:50.234
the fact that
your first update succeeds

00:43:50.234 --> 00:43:51.667
and the second one fails
and maybe there's

00:43:51.667 --> 00:43:53.067
a little bit
of inconsistency there,

00:43:53.067 --> 00:43:54.634
that might be okay.

00:43:54.634 --> 00:43:56.234
In which case,
disable your transaction

00:43:56.234 --> 00:43:57.567
and move on to the next one.

00:43:57.567 --> 00:44:00.300
You're in okay shape.

00:44:00.300 --> 00:44:02.434
If that's not acceptable
then, again,

00:44:02.434 --> 00:44:06.834
your options are implement
a compensating transaction.

00:44:06.834 --> 00:44:09.501
First update.
Second update fails.

00:44:09.501 --> 00:44:11.000
Try to roll back
the first update.

00:44:11.000 --> 00:44:12.267
You can do that.

00:44:12.267 --> 00:44:13.567
Or again,
a background process.

00:44:13.567 --> 00:44:15.133
These are the options.

00:44:15.133 --> 00:44:20.133
These are the types of things
that you need to think about.

00:44:20.133 --> 00:44:25.567
For queries, again, you're gonna
need to analyze your usage.

00:44:25.567 --> 00:44:28.200
And the general guidance
that we give people

00:44:28.200 --> 00:44:30.234
when we talk to them
when they're coming

00:44:30.234 --> 00:44:32.033
to App Engine from
the relational world

00:44:32.033 --> 00:44:37.334
is shift processing
from your reads to your writes.

00:44:37.334 --> 00:44:41.133
So we don't support
join queries.

00:44:41.133 --> 00:44:45.167
But denormalization works great.

00:44:45.167 --> 00:44:47.634
It's another way
to get the data you want.

00:44:47.634 --> 00:44:51.400
So in this particular example,
we have a typical join.

00:44:51.400 --> 00:44:52.734
Select * from person A.

00:44:52.734 --> 00:44:54.834
We're gonna join
on the person column

00:44:54.834 --> 00:44:57.067
across person and A
and then we're going to filter

00:44:57.067 --> 00:44:59.534
some property of person
and some property of address.

00:44:59.534 --> 00:45:00.934
Typical join query.

00:45:00.934 --> 00:45:05.701
If we denormalize
storing information about

00:45:05.701 --> 00:45:07.701
the address
on the person itself,

00:45:07.701 --> 00:45:09.133
we're duplicating that data,

00:45:09.133 --> 00:45:11.133
then we can issue a much more
straightforward query.

00:45:11.133 --> 00:45:14.567
So we've shifted the processing
from writes,

00:45:14.567 --> 00:45:16.467
because now
when we write a person

00:45:16.467 --> 00:45:18.734
we also need to write
information about the address.

00:45:18.734 --> 00:45:19.934
And when we update the address

00:45:19.934 --> 00:45:21.300
we also need to update
the person.

00:45:21.300 --> 00:45:22.834
We've duplicated that data

00:45:22.834 --> 00:45:24.934
so we're pushing the processing
onto the writes.

00:45:24.934 --> 00:45:27.734
But that's going to allow us
to do a really efficient read.

00:45:27.734 --> 00:45:32.567
For other operations--things
like toUpper, for example--

00:45:32.567 --> 00:45:35.734
you want to do a query
and you want to match

00:45:35.734 --> 00:45:39.667
on the upper case version
of some column

00:45:39.667 --> 00:45:41.133
that's stored in the Datastore,

00:45:41.133 --> 00:45:42.968
some property that's stored
in the Datastore.

00:45:42.968 --> 00:45:46.300
Well, one solution there
is to store multiple versions

00:45:46.300 --> 00:45:47.567
of that string, right?

00:45:47.567 --> 00:45:48.801
You store it
in the natural form,

00:45:48.801 --> 00:45:50.067
the one that you
want to actually show

00:45:50.067 --> 00:45:52.300
to your users in your UI.

00:45:52.300 --> 00:45:54.667
And then you store it
in the upper case form,

00:45:54.667 --> 00:45:56.167
which is the one that's going
to support the query.

00:45:56.167 --> 00:45:57.734
Yes, it's duplication.

00:45:57.734 --> 00:46:00.767
But you're pushing
the processing onto the writes

00:46:00.767 --> 00:46:06.133
in order to execute
a more efficient read.

00:46:06.133 --> 00:46:09.667
Let's talk about
the easier direction.

00:46:09.667 --> 00:46:14.267
Migrating things off
of App Engine.

00:46:14.267 --> 00:46:16.367
Of course we're sad
to see anyone go

00:46:16.367 --> 00:46:17.834
but we know this is gonna happen

00:46:17.834 --> 00:46:20.267
and it really is
important to us

00:46:20.267 --> 00:46:23.534
that you feel like you can
take your code someplace else.

00:46:23.534 --> 00:46:30.200
So the reason that this
is the easier direction

00:46:30.200 --> 00:46:33.000
is that when it comes
to persistence,

00:46:33.000 --> 00:46:36.734
App Engine is generally
more restrictive

00:46:36.734 --> 00:46:39.868
than the environment
that you're probably porting to.

00:46:39.868 --> 00:46:41.634
And the environment
you're probably porting to

00:46:41.634 --> 00:46:43.000
is a relational database.

00:46:43.000 --> 00:46:45.100
So when it comes to queries,

00:46:45.100 --> 00:46:49.300
the App Engine Datastore
doesn't support joins.

00:46:49.300 --> 00:46:51.901
Relational databases
typically support joins.

00:46:51.901 --> 00:46:53.300
It's more restrictive.

00:46:53.300 --> 00:46:55.067
You're using a subset
of the query functionality

00:46:55.067 --> 00:46:56.267
of a relational database

00:46:56.267 --> 00:46:57.434
when you're building
on the Datastore.

00:46:57.434 --> 00:46:59.100
Similarly for transactions--

00:46:59.100 --> 00:47:01.267
Entity group transactions
are more restrictive

00:47:01.267 --> 00:47:02.834
than global transactions.

00:47:02.834 --> 00:47:04.801
Multiple updates.

00:47:04.801 --> 00:47:07.234
App Engine Datastore,
one update per Entity.

00:47:07.234 --> 00:47:09.234
In a relational database,
you can probably update

00:47:09.234 --> 00:47:10.467
an Entity as many times
as you like.

00:47:10.467 --> 00:47:12.000
So it's more restrictive.

00:47:12.000 --> 00:47:14.501
So the fact that you have
been developing against a subset

00:47:14.501 --> 00:47:17.434
means that when you take it
to this other place,

00:47:17.434 --> 00:47:19.567
more things are going to work.

00:47:19.567 --> 00:47:20.767
That's good.

00:47:20.767 --> 00:47:22.567
We're happy about that.

00:47:22.567 --> 00:47:27.434
The biggest thing that you're
going to need to decide

00:47:27.434 --> 00:47:31.133
when you're building
your application on App Engine

00:47:31.133 --> 00:47:33.968
is what portability
means to you.

00:47:33.968 --> 00:47:37.701
And once you've decided
what it means to you

00:47:37.701 --> 00:47:39.734
then you need to decide
how important it is to you.

00:47:39.734 --> 00:47:43.400
So there's multiple valid
definitions of portability.

00:47:43.400 --> 00:47:45.167
One definition could just be,

00:47:45.167 --> 00:47:50.033
"I want compile time
portability."

00:47:50.033 --> 00:47:52.767
"I don't want to have
any com Google App Engine

00:47:52.767 --> 00:47:55.067
import statements anywhere
in my code."

00:47:55.067 --> 00:47:58.634
That doesn't necessarily mean
that you can build it

00:47:58.634 --> 00:48:00.601
and just deploy it
into some other environment.

00:48:00.601 --> 00:48:04.000
But you don't have any compile
time dependencies on App Engine.

00:48:04.000 --> 00:48:06.300
That might be your definition
of portability.

00:48:06.300 --> 00:48:10.033
You might have a definition
that says,

00:48:10.033 --> 00:48:13.234
"Not only do I not want to have
compile time dependencies,

00:48:13.234 --> 00:48:15.701
"I want to be able
to just change

00:48:15.701 --> 00:48:18.601
"some configuration file
and be able to deploy that

00:48:18.601 --> 00:48:20.434
into some other environment."

00:48:20.434 --> 00:48:21.934
Again, that's a perfectly
reasonable definition

00:48:21.934 --> 00:48:23.267
for portability.

00:48:23.267 --> 00:48:26.434
It might be that you want
to have a single binary

00:48:26.434 --> 00:48:29.701
that you build it,
you deploy it to App Engine,

00:48:29.701 --> 00:48:30.767
you deploy it to WebSphere,

00:48:30.767 --> 00:48:32.834
and you do nothing to it.

00:48:32.834 --> 00:48:34.868
That's another definition
of portability.

00:48:34.868 --> 00:48:38.167
And depending on which one
of those you choose,

00:48:38.167 --> 00:48:39.601
or you may have some other
definition,

00:48:39.601 --> 00:48:41.767
that is going to have
a lot of impact

00:48:41.767 --> 00:48:44.267
on how you design things.

00:48:44.267 --> 00:48:48.434
The nice thing is that no matter
what your definition is,

00:48:48.434 --> 00:48:50.400
you've already sharded
your data model.

00:48:50.400 --> 00:48:52.200
And if you happen to be
an application

00:48:52.200 --> 00:48:53.801
that has lots and lots of data,

00:48:53.801 --> 00:48:58.300
and you would need
to be horizontally partitioned

00:48:58.300 --> 00:48:59.934
if you weren't running
on App Engine,

00:48:59.934 --> 00:49:02.868
then you've already done
the hard work.

00:49:02.868 --> 00:49:05.234
And that's great.

00:49:05.234 --> 00:49:08.200
So let's look at a portable
model object.

00:49:08.200 --> 00:49:09.601
Here's a root object.

00:49:09.601 --> 00:49:11.801
It doesn't have a parent.
This is a JPA Entity.

00:49:11.801 --> 00:49:14.367
It's a book.
There's a primary key.

00:49:14.367 --> 00:49:16.067
It has a title.

00:49:16.067 --> 00:49:18.234
And on the left we can see
what the physical model

00:49:18.234 --> 00:49:19.868
looks like in the Datastore.

00:49:19.868 --> 00:49:21.567
We've got our kind,
our Entity Group and key.

00:49:21.567 --> 00:49:23.133
Entity Group and key
are the same.

00:49:23.133 --> 00:49:24.601
That's how we know this
is a root Entity.

00:49:24.601 --> 00:49:26.300
And there's the title,
and then on the right

00:49:26.300 --> 00:49:27.701
we have our simple book table

00:49:27.701 --> 00:49:35.234
which has its primary key
and a title of Vineland.

00:49:35.234 --> 00:49:38.934
For child, yeah,
it looks a little bit uglier.

00:49:38.934 --> 00:49:42.334
But we do have compile time
portability here.

00:49:42.334 --> 00:49:47.934
We have added this
DataNucleus-specific extension.

00:49:47.934 --> 00:49:49.701
It's not an App Engine
extension.

00:49:49.701 --> 00:49:53.534
To use this extension--
this is actually something

00:49:53.534 --> 00:49:54.801
that DataNucleus gives you.

00:49:54.801 --> 00:50:00.934
We can say, "Hey,
store the base 64 encoded

00:50:00.934 --> 00:50:03.467
representation of the key
in this string object."

00:50:03.467 --> 00:50:06.467
The reason we need to do that
is because

00:50:06.467 --> 00:50:09.567
this one field needs
to uniquely identify a chapter.

00:50:09.567 --> 00:50:11.234
And a chapter is a child object.

00:50:11.234 --> 00:50:13.968
And for child objects
with App Engine,

00:50:13.968 --> 00:50:16.801
the parent primary key is part

00:50:16.801 --> 00:50:18.834
of the primary key
of the child.

00:50:18.834 --> 00:50:21.834
So we need to embed
additional information in there.

00:50:21.834 --> 00:50:24.167
So we're declaring it
as a string

00:50:24.167 --> 00:50:26.067
and we're telling DataNucleus,

00:50:26.067 --> 00:50:28.567
"Hey, I want additional stuff
in here."

00:50:28.567 --> 00:50:31.100
But then we're also declaring
this additional property

00:50:31.100 --> 00:50:33.968
a parent key.

00:50:33.968 --> 00:50:35.567
This is similar to the thing
that enables you

00:50:35.567 --> 00:50:36.801
to do ancestor queries.

00:50:36.801 --> 00:50:38.067
We've got
this additional property

00:50:38.067 --> 00:50:40.601
that says,
"Hey, I want to expose

00:50:40.601 --> 00:50:44.634
the primary key of my parent."

00:50:44.634 --> 00:50:50.067
When we translate this
to the physical model,

00:50:50.067 --> 00:50:51.868
on the left-hand side,

00:50:51.868 --> 00:50:54.100
again, we have a typical
child object here.

00:50:54.100 --> 00:50:56.934
The key contains the parent key
and the child key.

00:50:56.934 --> 00:50:58.767
And then our properties,
23 pages.

00:50:58.767 --> 00:51:00.300
And then here's
our chapter table

00:51:00.300 --> 00:51:02.868
with our composite primary key
consisting

00:51:02.868 --> 00:51:07.167
of the ID of the chapter
and the ID of its parent

00:51:07.167 --> 00:51:12.000
and then the columns.

00:51:12.000 --> 00:51:14.634
So the key things
that I want you to take away

00:51:14.634 --> 00:51:16.467
from this talk
as we're wrapping up--

00:51:16.467 --> 00:51:19.033
First and foremost,
the App Engine Datastore

00:51:19.033 --> 00:51:22.200
simplifies persistence.

00:51:22.200 --> 00:51:24.634
It simplifies the development
of your application.

00:51:24.634 --> 00:51:26.133
You get the rapid prototyping.

00:51:26.133 --> 00:51:29.300
You get the rapid
typesafe prototyping

00:51:29.300 --> 00:51:31.968
if you're using JDO and JPA
and implementing a soft schema.

00:51:31.968 --> 00:51:37.901
And it simplifies the management
of those applications.

00:51:37.901 --> 00:51:39.400
And yes, it simplifies
the management

00:51:39.400 --> 00:51:41.133
of scalable applications.

00:51:41.133 --> 00:51:45.300
But again, every application
needs to scale

00:51:45.300 --> 00:51:47.067
to a certain degree.

00:51:47.067 --> 00:51:48.434
It just depends on what
that target is.

00:51:48.434 --> 00:51:52.400
You can use JDO and JPA
to implement a soft schema.

00:51:52.400 --> 00:51:54.234
This is going to take something

00:51:54.234 --> 00:51:55.501
that looks a little bit
unfamiliar,

00:51:55.501 --> 00:51:58.734
a schema-less Datastore,
and establish the structure

00:51:58.734 --> 00:52:00.934
on top of it to make it look
a little bit more

00:52:00.934 --> 00:52:02.534
like what you're used to.

00:52:02.534 --> 00:52:06.234
When you're thinking about
moving applications

00:52:06.234 --> 00:52:08.534
onto App Engine,
denormalization

00:52:08.534 --> 00:52:09.934
is not a dirty word.

00:52:09.934 --> 00:52:12.400
Do not be afraid
to duplicate data.

00:52:12.400 --> 00:52:16.868
This is a great way
to be able to execute

00:52:16.868 --> 00:52:20.467
complicated, efficient queries
on App Engine.

00:52:20.467 --> 00:52:23.067
And finally, when you're going
the other direction,

00:52:23.067 --> 00:52:25.667
taking your code someplace else,
plan for portability.

00:52:25.667 --> 00:52:28.133
Decide what your definition
of portability is,

00:52:28.133 --> 00:52:32.567
and then stick to it
and you'll be in good shape.

00:52:32.567 --> 00:52:35.667
And with that I will be happy
to take questions.

00:52:35.667 --> 00:52:38.100
Here's a couple of links,
information,

00:52:38.100 --> 00:52:40.567
ways that you can get
more information on App Engine.

00:52:40.567 --> 00:52:43.200
And please, if you have feedback
for the talk,

00:52:43.200 --> 00:52:45.801
visit that link down there
at the bottom.

00:52:45.801 --> 00:52:46.868
Thank you very much.

00:52:46.868 --> 00:52:50.634
[applause]

00:52:52.667 --> 00:52:55.033
man: Hi.
Thank you for the talk.

00:52:55.033 --> 00:52:56.601
It was very informative.

00:52:56.601 --> 00:52:59.968
What I'm taking away from this
is most applications,

00:52:59.968 --> 00:53:02.434
you could build them
on a relational database

00:53:02.434 --> 00:53:04.300
or on App Engine if you
kind of think about it

00:53:04.300 --> 00:53:06.601
the right way
for the underlying platform.

00:53:06.601 --> 00:53:11.234
Could you identify
some kind of criteria

00:53:11.234 --> 00:53:13.501
where you'd say if A, B, and C
are true,

00:53:13.501 --> 00:53:15.033
then you're really
in this sweet spot

00:53:15.033 --> 00:53:18.501
for relational database and
models making your life easier--

00:53:18.501 --> 00:53:20.667
versus
if X, Y, and Z are true,

00:53:20.667 --> 00:53:23.267
you're in the zone
where the App Engine model

00:53:23.267 --> 00:53:25.367
is gonna make your life easier
and relational

00:53:25.367 --> 00:53:27.901
is pushing a stone uphill.

00:53:27.901 --> 00:53:29.701
Ross: Okay.

00:53:29.701 --> 00:53:35.601
So first and foremost,

00:53:35.601 --> 00:53:38.534
if you build on App Engine,
the whole management side,

00:53:38.534 --> 00:53:42.133
the operational side
of dealing with persistence,

00:53:42.133 --> 00:53:43.901
that's always gonna be better.

00:53:43.901 --> 00:53:46.934
If you can get there,
the management side

00:53:46.934 --> 00:53:49.234
is pretty much always
gonna be better.

00:53:49.234 --> 00:53:52.000
You don't have to manage
your database servers anymore.

00:53:52.000 --> 00:53:54.334
That alone is a big win.

00:53:54.334 --> 00:53:57.501
But your question is
when does it make sense

00:53:57.501 --> 00:54:02.267
to sort of work hard
to get to that point?

00:54:02.267 --> 00:54:06.133
I would say this process
of looking at your data model

00:54:06.133 --> 00:54:08.701
and identifying roots--

00:54:08.701 --> 00:54:12.501
If you look at your data model
and you can't find any roots,

00:54:12.501 --> 00:54:15.033
everything is just pointing
every which way,

00:54:15.033 --> 00:54:19.100
that is going
to be a challenging port.

00:54:19.100 --> 00:54:22.901
Because the transactional
functionality,

00:54:22.901 --> 00:54:25.200
and to a certain extent
the querying functionality,

00:54:25.200 --> 00:54:27.767
sort of assumes that
you can slice your data,

00:54:27.767 --> 00:54:29.267
that you can partition
your data.

00:54:29.267 --> 00:54:32.300
So if that part goes badly,

00:54:32.300 --> 00:54:34.968
then you may not be
in a good spot.

00:54:34.968 --> 00:54:36.834
If that part goes really well,

00:54:36.834 --> 00:54:39.367
then I would say, you know,
go forward.

00:54:39.367 --> 00:54:42.467
Wait until you hit
the next bump.

00:54:42.467 --> 00:54:45.234
I can't stand up here and say

00:54:45.234 --> 00:54:48.367
it's always gonna be
straightforward.

00:54:48.367 --> 00:54:50.033
It's always gonna be easy.

00:54:50.033 --> 00:54:52.334
What I'm hoping to do
is get the conversation started

00:54:52.334 --> 00:54:54.200
about what are the common
strategies,

00:54:54.200 --> 00:54:56.033
what are the common patterns.

00:54:56.033 --> 00:54:58.667
And the product's been out
I think eight weeks now,

00:54:58.667 --> 00:55:00.167
so we're still pretty young.

00:55:00.167 --> 00:55:01.734
But one of the things
that I'm really hopeful for

00:55:01.734 --> 00:55:04.367
is that we see the community,

00:55:04.367 --> 00:55:06.100
and I'm happy
to kick this off,

00:55:06.100 --> 00:55:08.234
but I'd like to see
the community

00:55:08.234 --> 00:55:11.434
start putting together
essentially a cookbook

00:55:11.434 --> 00:55:15.968
of what types of things
we should be looking for

00:55:15.968 --> 00:55:20.634
and how to move
those things over.

00:55:20.634 --> 00:55:21.901
Yes?

00:55:21.901 --> 00:55:23.601
man: Thank you for the talk.

00:55:23.601 --> 00:55:26.367
I saw another talk yesterday
on distributive transactions.

00:55:26.367 --> 00:55:27.667
Ross: Yes.

00:55:27.667 --> 00:55:28.934
man: And I was wondering
if you had any thoughts on that

00:55:28.934 --> 00:55:30.767
and how it applied to...

00:55:30.767 --> 00:55:32.667
Ross: It applies really nicely.

00:55:32.667 --> 00:55:36.367
So I saw Dan Wilkerson's talk
yesterday too.

00:55:36.367 --> 00:55:40.067
For those who didn't see it,
there is an existing algorithm

00:55:40.067 --> 00:55:41.501
for implementing distributive
transactions

00:55:41.501 --> 00:55:43.200
on top of the App Engine
Datastore.

00:55:43.200 --> 00:55:45.200
And it was done entirely
in user land.

00:55:45.200 --> 00:55:49.267
Like, above the low-level
Datastore APIs.

00:55:49.267 --> 00:55:50.434
Which is why Dan
was able to do it

00:55:50.434 --> 00:55:53.467
because he doesn't work
for Google.

00:55:53.467 --> 00:55:58.133
If you really need
global transactions,

00:55:58.133 --> 00:56:00.834
in theory, this will help.

00:56:00.834 --> 00:56:05.901
So I have not tried out
his implementation.

00:56:05.901 --> 00:56:08.667
So I cannot say either way

00:56:08.667 --> 00:56:12.534
sort of what the additional
storage cost is,

00:56:12.534 --> 00:56:14.334
what the additional
performance cost is.

00:56:14.334 --> 00:56:16.400
Based on what I know of it,

00:56:16.400 --> 00:56:18.734
there is definitely some
additional storage cost.

00:56:18.734 --> 00:56:21.434
There is definitely some
additional performance cost.

00:56:21.434 --> 00:56:23.367
But I can't say to what degree

00:56:23.367 --> 00:56:29.534
and how those things
are affected by data volume,

00:56:29.534 --> 00:56:31.367
by the size and shape
of your data.

00:56:31.367 --> 00:56:33.968
So we're gonna have to see.

00:56:33.968 --> 00:56:35.100
I'm really looking forward

00:56:35.100 --> 00:56:37.033
to that code
being made available

00:56:37.033 --> 00:56:38.434
and I hope people try it out.

00:56:38.434 --> 00:56:42.300
It may work really,
really great for some people.

00:56:42.300 --> 00:56:44.801
But yeah, keep an eye out
for it, definitely.

00:56:44.801 --> 00:56:47.400
Yeah?
man: Hi.

00:56:47.400 --> 00:56:50.767
To what extent have you guys
done work

00:56:50.767 --> 00:56:54.133
on kind of prefetched rules
and hints

00:56:54.133 --> 00:56:57.868
for the implementations
to be able to load

00:56:57.868 --> 00:57:00.267
kind of large graphs in one go

00:57:00.267 --> 00:57:02.868
rather than kind
of ripple loading?

00:57:02.868 --> 00:57:04.467
Ross: Yeah.

00:57:04.467 --> 00:57:08.667
Well, so "in one go"
means something different

00:57:08.667 --> 00:57:10.400
for the Datastore than it does
for a relational database.

00:57:10.400 --> 00:57:13.033
If you're using JPA and you say,

00:57:13.033 --> 00:57:14.767
"I want you to fetch
this relationship eagerly,"

00:57:14.767 --> 00:57:17.501
that typically translates
to a join, right?

00:57:17.501 --> 00:57:19.734
But the App Engine Datastore
doesn't support join,

00:57:19.734 --> 00:57:22.767
so even if you said,
"I want it eagerly,"

00:57:22.767 --> 00:57:24.567
that would just result
in multiple queries

00:57:24.567 --> 00:57:27.634
done up front versus
multiple queries spread out

00:57:27.634 --> 00:57:31.033
as the thing is used.

00:57:31.033 --> 00:57:32.767
I'm not...

00:57:32.767 --> 00:57:37.901
I'm not sure how much value
there would be

00:57:37.901 --> 00:57:41.000
in sort of executing
multiple queries up front

00:57:41.000 --> 00:57:44.934
versus executing multiple
queries as needed.

00:57:44.934 --> 00:57:48.601
man: What I was getting at
was not the API side

00:57:48.601 --> 00:57:51.167
but the back end side.

00:57:51.167 --> 00:57:53.033
I guess another way of asking

00:57:53.033 --> 00:57:54.634
are there any plans
in the road map

00:57:54.634 --> 00:57:59.400
for supporting a means
to be able

00:57:59.400 --> 00:58:03.267
to prefetch and do kind of
bulk operations like that?

00:58:03.267 --> 00:58:06.267
Whether you call it a joiner
or some other--

00:58:06.267 --> 00:58:08.501
Ross: We already support
batch gets.

00:58:08.501 --> 00:58:11.100
We already support batch
inserts.

00:58:11.100 --> 00:58:15.734
But for queries, we don't have
any immediate plans

00:58:15.734 --> 00:58:23.167
to allow you to issue
a query that will, uh...

00:58:23.167 --> 00:58:24.367
I don't know how else
to describe it

00:58:24.367 --> 00:58:25.667
other than a join query.

00:58:25.667 --> 00:58:27.467
That's typically what
you end up expressing.

00:58:27.467 --> 00:58:28.701
But for individual records

00:58:28.701 --> 00:58:30.567
there are batch operations
available already.

00:58:30.567 --> 00:58:33.300
We have not yet exposed
those batch--

00:58:33.300 --> 00:58:35.634
Actually, not true.

00:58:35.634 --> 00:58:37.868
Batch gets are exposed in JDO.

00:58:37.868 --> 00:58:42.501
In JPA, the batch puts
even though the interfaces--

00:58:42.501 --> 00:58:44.200
they have things like
make persistent to all

00:58:44.200 --> 00:58:45.734
or persist all--

00:58:45.734 --> 00:58:48.033
they do not yet take advantage
of those batch operations.

00:58:48.033 --> 00:58:50.567
But that's just because
we haven't implemented it yet.

00:58:50.567 --> 00:58:53.400
So we'll get better with those,

00:58:53.400 --> 00:58:56.334
but for the hard stuff
it's tough to say.

00:58:56.334 --> 00:58:57.534
man: Thanks.
Ross: Yeah.

00:58:57.534 --> 00:58:59.334
man: You talked about
the suggestion

00:58:59.334 --> 00:59:01.067
of making user your Entity root

00:59:01.067 --> 00:59:02.634
so that you could have
transactions

00:59:02.634 --> 00:59:04.334
among any of the children
underneath there.

00:59:04.334 --> 00:59:07.567
But that seems--there must be
performance implications

00:59:07.567 --> 00:59:09.200
if suddenly
I just have that up here

00:59:09.200 --> 00:59:10.901
and everything grows
underneath that as children,

00:59:10.901 --> 00:59:13.467
there need to be some downsides.

00:59:13.467 --> 00:59:15.834
So is that really that easy,

00:59:15.834 --> 00:59:16.901
or what are some
of the penalties,

00:59:16.901 --> 00:59:18.400
performance or space
or otherwise?

00:59:18.400 --> 00:59:20.200
Ross: So it depends
on the access patterns

00:59:20.200 --> 00:59:21.767
of the data, right?

00:59:21.767 --> 00:59:25.000
If this is email, typically
you are accessing your email.

00:59:25.000 --> 00:59:27.400
You are reading email.
You are writing email.

00:59:27.400 --> 00:59:29.968
And chances are other people
are not hopefully

00:59:29.968 --> 00:59:31.767
reading and writing your email.

00:59:31.767 --> 00:59:34.300
Which means that you don't
have to worry quite so much

00:59:34.300 --> 00:59:37.100
about concurrency
because it's you,

00:59:37.100 --> 00:59:39.334
so you could be on multiple
computers at the same time.

00:59:39.334 --> 00:59:40.868
But chances are it's just you.

00:59:40.868 --> 00:59:42.868
In that sort of model,

00:59:42.868 --> 00:59:44.367
then yeah,
user is a great choice.

00:59:44.367 --> 00:59:48.567
But if you have something
that really does require

00:59:48.567 --> 00:59:51.434
a lot of concurrent
modification,

00:59:51.434 --> 00:59:53.634
then that's when you need
to really think harder.

00:59:53.634 --> 00:59:56.801
The reason I say use user
if it works

00:59:56.801 --> 01:00:00.267
is because
it's part of a domain

01:00:00.267 --> 01:00:03.467
that is commonly there
and it might work out great.

01:00:03.467 --> 01:00:05.400
That's sort of like
a best case scenario for you.

01:00:05.400 --> 01:00:08.000
But it may not be
the average case.

01:00:08.000 --> 01:00:11.300
Yeah.
Question?

01:00:11.300 --> 01:00:12.834
man: Yeah,
it's a question again

01:00:12.834 --> 01:00:14.400
about distributive
transactions.

01:00:14.400 --> 01:00:15.734
Ross: Yeah.

01:00:15.734 --> 01:00:17.367
man: In the future,
do you plan

01:00:17.367 --> 01:00:20.834
on using distributive
transactions under the hood

01:00:20.834 --> 01:00:25.234
inside the JDO or JPA
so that you can support

01:00:25.234 --> 01:00:27.234
some of these other queries

01:00:27.234 --> 01:00:30.300
that you can't support--
support joins and so forth?

01:00:30.300 --> 01:00:33.200
So I don't have to worry
about distributive transactions.

01:00:33.200 --> 01:00:35.567
The library would do it for me.

01:00:35.567 --> 01:00:36.734
Ross: Right.

01:00:36.734 --> 01:00:39.701
So if...

01:00:39.701 --> 01:00:43.334
If we can get the--
excuse me.

01:00:43.334 --> 01:00:44.934
If we can get
the throughput we need

01:00:44.934 --> 01:00:46.534
from distributive transactions

01:00:46.534 --> 01:00:49.334
then I would absolutely want
to bake them in

01:00:49.334 --> 01:00:51.734
in a way that meant
you had to think about it

01:00:51.734 --> 01:00:54.167
as little as possible.

01:00:54.167 --> 01:00:58.000
But again, it starts
with what impact it has

01:00:58.000 --> 01:01:00.934
on how much data is stored

01:01:00.934 --> 01:01:02.801
and the performance
implications.

01:01:02.801 --> 01:01:06.000
And I'm in no position to guess.

01:01:06.000 --> 01:01:10.767
man: Yeah, I haven't used
your storage framework,

01:01:10.767 --> 01:01:13.901
but what kind of performance
can we get?

01:01:13.901 --> 01:01:16.801
How many writes on a given--

01:01:16.801 --> 01:01:19.200
is it what you call
Entity Group?

01:01:19.200 --> 01:01:21.501
Ross: On a given Entity Group
it's one--

01:01:21.501 --> 01:01:24.901
man: For a small object,
you know?

01:01:24.901 --> 01:01:28.968
Ross: So the rule of thumb
is you can expect 1 to 10--

01:01:28.968 --> 01:01:30.400
you can expect to be able

01:01:30.400 --> 01:01:35.434
to execute 1 to 10 writes
per second on an Entity Group.

01:01:35.434 --> 01:01:37.000
Next question.

01:01:37.000 --> 01:01:40.133
man: So I've been converting
a BADIs application

01:01:40.133 --> 01:01:41.367
in the last eight weeks,

01:01:41.367 --> 01:01:44.067
at least the down layer,
over to App Engine.

01:01:44.067 --> 01:01:49.367
And the existing data model
has a few unowned relationships

01:01:49.367 --> 01:01:51.400
and many-to-many relationships.

01:01:51.400 --> 01:01:53.367
And I've been trying to isolate
them and whatnot.

01:01:53.367 --> 01:01:57.200
I noticed today you said
you're not as of yet allowed

01:01:57.200 --> 01:01:59.968
to do in queries.

01:01:59.968 --> 01:02:01.801
So with a situation
like many-to-many,

01:02:01.801 --> 01:02:04.033
what kind of approach
would you take

01:02:04.033 --> 01:02:07.634
to get a collection
of something

01:02:07.634 --> 01:02:09.400
only given a collection?

01:02:09.400 --> 01:02:12.601
Ross: If I'm understanding
your question correctly,

01:02:12.601 --> 01:02:15.734
multi-value properties
can be really helpful here.

01:02:15.734 --> 01:02:17.000
If you have a many-to-many

01:02:17.000 --> 01:02:21.801
and you have the list of keys
on one side,

01:02:21.801 --> 01:02:23.367
or even on both sides,

01:02:23.367 --> 01:02:26.501
then if you think back
to that contains example

01:02:26.501 --> 01:02:28.601
that I showed where I said,
"Show me everybody

01:02:28.601 --> 01:02:31.801
who considers yoga
to be a hobby."

01:02:31.801 --> 01:02:34.701
That query will work great
for your scenario

01:02:34.701 --> 01:02:36.601
based on those keys.

01:02:36.601 --> 01:02:38.300
You can say, "Show me
all of the people

01:02:38.300 --> 01:02:39.901
who consider this person
a friend."

01:02:39.901 --> 01:02:42.033
That will basically give you
all of the people

01:02:42.033 --> 01:02:46.734
that have this particular key
in that collection.

01:02:46.734 --> 01:02:50.734
man: This is sort
of a bidirectional situation

01:02:50.734 --> 01:02:55.167
where you really don't have--
you can't really trust

01:02:55.167 --> 01:02:57.601
that you'll be able to write
both at any given time.

01:02:57.601 --> 01:02:59.934
Well, you can trust one side
but not the other.

01:02:59.934 --> 01:03:03.534
Is there a way of hashing
or caching

01:03:03.534 --> 01:03:08.701
or something like that
that you could...

01:03:08.701 --> 01:03:11.000
Ross: I'd have to think
about it more.

01:03:11.000 --> 01:03:13.968
man: Okay, thank you.

01:03:13.968 --> 01:03:16.067
Ross: If you post your question
on the message groups,

01:03:16.067 --> 01:03:17.434
I will think about it more

01:03:17.434 --> 01:03:19.100
and I'll try to get you
a better answer, yeah.

01:03:19.100 --> 01:03:20.767
man: This is kind
of a follow-up question

01:03:20.767 --> 01:03:22.167
to his question.

01:03:22.167 --> 01:03:24.467
For migrating something
like Hibernate or iBatis

01:03:24.467 --> 01:03:27.501
that has support for JPA
but also has

01:03:27.501 --> 01:03:30.400
its own proprietary annotation
and query language,

01:03:30.400 --> 01:03:32.434
if you were to move
to Google App Engine

01:03:32.434 --> 01:03:34.501
and migrate away
from the annotations

01:03:34.501 --> 01:03:37.067
of whatever ORM tool
you're using to JPA,

01:03:37.067 --> 01:03:39.868
is there any options
for a neutral query tool

01:03:39.868 --> 01:03:42.968
for building up
or is it part of JPA itself?

01:03:42.968 --> 01:03:46.267
Or, like, some good way
of having criteria query

01:03:46.267 --> 01:03:48.434
for Hibernate and something
on the App Engine side--

01:03:48.434 --> 01:03:49.701
if you can still use Hibernate,

01:03:49.701 --> 01:03:51.534
but if you wanted
to use something more neutral

01:03:51.534 --> 01:03:52.767
in case you wanted
to pull it out later

01:03:52.767 --> 01:03:56.767
and switch to something else?

01:03:56.767 --> 01:03:58.334
Ross: I'm not sure
I completely understand.

01:03:58.334 --> 01:03:59.801
So you want to leave your

01:03:59.801 --> 01:04:02.033
Hibernate-specific code
in place?

01:04:02.033 --> 01:04:03.868
man: You don't want to
but you kind of have to

01:04:03.868 --> 01:04:05.801
unless you want to migrate
to something else, or if--

01:04:05.801 --> 01:04:07.467
You're gonna want to get away
from conventions

01:04:07.467 --> 01:04:09.734
of Hibernate because it keeps
you thinking in Hibernate

01:04:09.734 --> 01:04:11.133
versus something more neutral.

01:04:11.133 --> 01:04:13.200
Ross: The migration path
I would recommend there

01:04:13.200 --> 01:04:14.367
is as you said, right?

01:04:14.367 --> 01:04:16.968
Hibernate is a JPA
in limitation.

01:04:16.968 --> 01:04:21.200
So I would migrate up
to JPA, still use Hibernate,

01:04:21.200 --> 01:04:24.267
get to that point,
and then move over.

01:04:24.267 --> 01:04:26.167
I think that's how
I would approach it.

01:04:26.167 --> 01:04:29.834
I can't think of--
I wouldn't recommend a shortcut.

01:04:29.834 --> 01:04:31.367
man: Okay.
Thank you.

01:04:31.367 --> 01:04:35.334
Ross: Sure.

01:04:35.334 --> 01:04:37.200
Okay, last two questions.

01:04:37.200 --> 01:04:39.567
And if there are people here
who have questions

01:04:39.567 --> 01:04:42.334
but you haven't stood up,
there's a fireside chat

01:04:42.334 --> 01:04:44.667
in the fireside chat room
with the App Engine team,

01:04:44.667 --> 01:04:46.267
like, right after this.

01:04:46.267 --> 01:04:47.601
So just come on over there
and you can ask more questions.

01:04:47.601 --> 01:04:48.834
Yes.

01:04:48.834 --> 01:04:52.501
man: In JDO or JPA
implementation,

01:04:52.501 --> 01:04:54.167
the DataNucleus implementation,

01:04:54.167 --> 01:04:56.133
does it do dirty field detection

01:04:56.133 --> 01:05:00.133
and only write the dirty fields
when you're doing an update

01:05:00.133 --> 01:05:02.467
or does it need to write
the whole Entity?

01:05:02.467 --> 01:05:06.567
Ross: So DataNucleus
does dirty field detection,

01:05:06.567 --> 01:05:10.334
and DataNucleus then tells
the App Engine plug-in,

01:05:10.334 --> 01:05:13.033
"Hey, write
just this one field,"

01:05:13.033 --> 01:05:14.934
and then we write
the entire Entity

01:05:14.934 --> 01:05:17.667
because the Datastore
does not support updates

01:05:17.667 --> 01:05:19.133
at that level of granularity.

01:05:19.133 --> 01:05:21.167
man: Okay, thanks.
Ross: Yep.

01:05:21.167 --> 01:05:22.634
man: Just to be
a bit more clear,

01:05:22.634 --> 01:05:25.834
you did talk in JDO/JPA
addressing the ownership.

01:05:25.834 --> 01:05:27.801
So a person owns
multiple pets,

01:05:27.801 --> 01:05:29.834
and a pet can only be owned
by one person.

01:05:29.834 --> 01:05:31.868
But how about a situation
where the Entity Group

01:05:31.868 --> 01:05:34.033
is actually like
an intelligence organization?

01:05:34.033 --> 01:05:37.634
Say you have an Entity Group
for KGB and one for FBI.

01:05:37.634 --> 01:05:41.801
And then you have James Bond,
Bruno, Borat--

01:05:41.801 --> 01:05:43.734
they're all spies.

01:05:43.734 --> 01:05:46.400
And then you have top secret
documents, maybe ten of them.

01:05:46.400 --> 01:05:49.834
Can you within a transaction
using JDO or JPA

01:05:49.834 --> 01:05:53.267
associate Bruno with the three
documents he just checked out

01:05:53.267 --> 01:05:56.634
and Bond with the two documents
he just returned,

01:05:56.634 --> 01:05:58.734
and do that all within JDO,

01:05:58.734 --> 01:06:00.501
do I have to go
to a lower level?

01:06:00.501 --> 01:06:04.834
Ross: You can do it
all through JDO,

01:06:04.834 --> 01:06:07.901
but you will have
to explicitly--

01:06:07.901 --> 01:06:12.267
you will have to explicitly
define your model objects

01:06:12.267 --> 01:06:16.234
containing keys of some
of these other objects

01:06:16.234 --> 01:06:18.367
as opposed to the type
of the object itself.

01:06:18.367 --> 01:06:20.667
man: So you're saying, like,
for example

01:06:20.667 --> 01:06:23.334
the documents can only
be checked out by one person.

01:06:23.334 --> 01:06:25.400
So I guess that'd be
a traditional foreign key

01:06:25.400 --> 01:06:26.734
and a database.

01:06:26.734 --> 01:06:30.133
But for the person
checking out the books,

01:06:30.133 --> 01:06:32.400
he'd have a multi-valued
property

01:06:32.400 --> 01:06:34.934
that's just a list of the things
they have.

01:06:34.934 --> 01:06:37.167
And JDO can handle that
out of the box.

01:06:37.167 --> 01:06:39.334
Ross: JDO can handle that fine.

01:06:39.334 --> 01:06:41.667
You just have to take care--

01:06:41.667 --> 01:06:44.934
So you've asked
an interesting question.

01:06:44.934 --> 01:06:49.167
So we use ownership
to imply Entity Groups.

01:06:49.167 --> 01:06:51.300
But that is not the only way

01:06:51.300 --> 01:06:53.267
to set up Entity Group
relationships.

01:06:53.267 --> 01:06:55.133
It's just
a nice default value.

01:06:55.133 --> 01:06:59.334
So it is possible
to have documents

01:06:59.334 --> 01:07:00.968
as part of an Entity Group

01:07:00.968 --> 01:07:03.367
and people as part
of the same Entity Group,

01:07:03.367 --> 01:07:05.267
and have an unowned relationship

01:07:05.267 --> 01:07:07.067
between those documents
and those people,

01:07:07.067 --> 01:07:09.567
and have those documents
and people still reside

01:07:09.567 --> 01:07:10.934
in the same Entity Group.

01:07:10.934 --> 01:07:14.033
man: And JDO can handle
establishing the relationships

01:07:14.033 --> 01:07:16.400
and de-establishing them
just fine.

01:07:16.400 --> 01:07:21.033
Well, I had kind of like
a zero-one in one way

01:07:21.033 --> 01:07:22.133
and then one-to-many
in the other.

01:07:22.133 --> 01:07:23.434
How about for many-to-many?

01:07:23.434 --> 01:07:25.167
Just like this spy's my friend,

01:07:25.167 --> 01:07:26.567
this spy's not my friend.

01:07:26.567 --> 01:07:28.634
Ross: So any time

01:07:28.634 --> 01:07:32.834
it is not an actual ownership
relationship,

01:07:32.834 --> 01:07:35.501
you don't need to dip down
to the low-level API.

01:07:35.501 --> 01:07:37.934
You can do all of this
using JDO.

01:07:37.934 --> 01:07:41.033
But again, you can't define
your model objects

01:07:41.033 --> 01:07:44.501
in terms of other--

01:07:44.501 --> 01:07:45.734
You can't define
the relationships

01:07:45.734 --> 01:07:47.133
in terms
of other model objects.

01:07:47.133 --> 01:07:48.934
You have to define
the relationships,

01:07:48.934 --> 01:07:52.701
these unowned relationships,
using their primary keys.

01:07:52.701 --> 01:07:55.000
man: So it would just be
you're storing streams

01:07:55.000 --> 01:07:56.767
or numbers instead of--

01:07:56.767 --> 01:07:58.567
Ross: You're storing unique IDs
for these things,

01:07:58.567 --> 01:07:59.734
for the relationships.

01:07:59.734 --> 01:08:02.734
And that is not
a limitation of JDO.

01:08:02.734 --> 01:08:07.567
That is a limitation
of our implementation thus far.

01:08:07.567 --> 01:08:09.968
So eventually we want
to get to the point

01:08:09.968 --> 01:08:12.567
where you can say,
"Yeah, this person has

01:08:12.567 --> 01:08:14.634
an association
with this document."

01:08:14.634 --> 01:08:17.634
As opposed to this person
has a field

01:08:17.634 --> 01:08:19.801
that happens to contain the
primary key of this document.

01:08:19.801 --> 01:08:20.834
We want to get to that point.

01:08:20.834 --> 01:08:23.067
We just haven't done it yet.

01:08:23.067 --> 01:08:25.234
man: And just to extend this
a little bit more

01:08:25.234 --> 01:08:27.167
on the limitation, let's say
we do have a social graph

01:08:27.167 --> 01:08:28.934
and this spy has many friends

01:08:28.934 --> 01:08:30.868
and these friends each have
their favorite restaurant.

01:08:30.868 --> 01:08:32.667
I want to find
all the candidate restaurants

01:08:32.667 --> 01:08:35.367
of all my friends
to decide where to go to lunch.

01:08:35.367 --> 01:08:38.000
So I have to in one step
get all my friends.

01:08:38.000 --> 01:08:39.667
And then I have to go query
each of them.

01:08:39.667 --> 01:08:41.400
Load each of them separately

01:08:41.400 --> 01:08:43.767
to get their set
of favorite restaurants

01:08:43.767 --> 01:08:45.701
and then form my unique set.

01:08:45.701 --> 01:08:48.634
Ross: There's probably room
for a batch get somewhere

01:08:48.634 --> 01:08:51.601
in there where you can
provide a bunch of IDs

01:08:51.601 --> 01:08:53.767
and pull back a bunch
of records in one shot.

01:08:53.767 --> 01:08:55.167
man: So I can get
all my friends

01:08:55.167 --> 01:08:57.868
and then specify all my friends
in the batch

01:08:57.868 --> 01:08:59.834
and get back all their objects.

01:08:59.834 --> 01:09:03.434
Ross: So it's not
a batch query.

01:09:03.434 --> 01:09:09.734
Like, get me people identified
by 23, 29, and 34.

01:09:09.734 --> 01:09:11.000
Get me all of those people.

01:09:11.000 --> 01:09:13.434
man: And the full Entity
they represent,

01:09:13.434 --> 01:09:16.100
then I can dive down and get
the specific things I want.

01:09:16.100 --> 01:09:19.434
Thanks a lot.
Ross: Yep.

01:09:19.434 --> 01:09:20.934
I think we're out of time.

01:09:20.934 --> 01:09:22.934
But if you want to come over
to the fireside chat,

01:09:22.934 --> 01:09:24.968
or we can just talk
as we walk over there.

01:09:24.968 --> 01:09:26.267
But I think we're done up here.

01:09:26.267 --> 01:09:28.300
Thank you.

01:09:28.300 --> 01:09:29.901
[applause]

