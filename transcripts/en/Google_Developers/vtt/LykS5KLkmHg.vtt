WEBVTT
Kind: captions
Language: en

00:53:21.121 --> 00:53:23.121
Image compression

00:53:25.263 --> 00:53:27.933
 for Android developers. 

00:53:37.424 --> 00:53:40.444
&gt;&gt; CHAIR:  I'm testing but it's 
not coming up now.  What the 

00:53:40.445 --> 00:53:42.445
heck. 
&gt;&gt; CHAIR: 

00:53:48.062 --> 00:53:50.062
 I'm. 
&gt;&gt; Now it's not connecting

00:53:57.855 --> 00:54:02.917
   Image compression     
      Compression for Android 

00:54:02.918 --> 00:54:04.918
developers

00:56:41.608 --> 00:56:43.608
      Developers.  

00:56:49.922 --> 00:56:59.774
 Yeah!  Google IO/0      I/0 0 
2016. 

00:56:59.945 --> 00:57:02.321
 How are you doing today?  Good?
  Staying out of the 

00:57:08.483 --> 00:57:14.141
sun? .  Fantastic              ?
  Fantastic.  I love Google I/O.

00:57:14.142 --> 00:57:18.875
  This is the one time during 
the whole year that the crazy 

00:57:18.876 --> 00:57:23.392
goal      Googlers can talk 
about the stuff we do all year. 

00:57:23.609 --> 00:57:26.312
 That is fantastic.  Today we're
 talking about something so near

00:57:26.313 --> 00:57:31.616
 and dear to my art, and that is
 data compression.  Art heart 

00:57:32.007 --> 00:57:37.473
                                            heart,
 and that is data compression. .

00:57:32.007 --> 00:57:33.276
  It's one of the most 
                       It's one 

00:57:33.277 --> 00:57:35.693
of the most obsessive things I 
get involved with.  All the 

00:57:35.694 --> 00:57:38.237
people standing outside, I'm 
sorry there is capacity issues. 

00:57:38.238 --> 00:57:41.312
 We will give them a T-shirt or 
something later.  Really quick, 

00:57:41.313 --> 00:57:43.313
before we begin, I got to tell

00:57:47.358 --> 00:57:49.879
 you we've only got 45 minutes 
today.  That's nifty 

00:57:50.095 --> 00:57:52.882
             That's just not 
enough time to go 

00:57:52.883 --> 00:57:54.912
through         through the 
crazy image compression we need 

00:57:54.913 --> 00:57:58.804
to get done.  I've been trying 
to diffuse some of these.  Has 

00:57:58.805 --> 00:58:03.303
anybody been reading these 
articles in medium.com page.  

00:58:03.304 --> 00:58:06.288
Round of applause if you've been
 reading the medium articles.  

00:58:06.289 --> 00:58:07.511
Yeah?
(Applause)  

00:58:07.512 --> 00:58:09.512
We're live, folks.  You got to 
make them hear

00:58:16.997 --> 00:58:19.705
 it.  Second off is the Android 
performance pattern videos.  

00:58:19.706 --> 00:58:24.112
Anybody watch these?
(Applause)  

00:58:24.113 --> 00:58:26.331
Thank you.  Thank you.  That's 
fantastic.  Now, if you've 

00:58:26.332 --> 00:58:28.538
ferrin        ever been 
interested in data compression, 

00:58:28.539 --> 00:58:31.448
ever tried to make an attempt to
 understand the algorithms, but 

00:58:31.449 --> 00:58:34.180
found that the math is really 
weird or it's too gnarly of 

00:58:34.181 --> 00:58:36.877
after concept or maybe it's not 
presented in the right way, then

00:58:37.094 --> 00:58:40.914
 good news for you, because Alex
 Hackey and I have gotten 

00:58:40.915 --> 00:58:43.432
together and written a data 
compression book.  We took a 

00:58:43.433 --> 00:58:48.122
different approach to it, we 
threw out all the math, you will

00:58:48.551 --> 00:58:54.289
 of that crazy, gnarly stuff, 
and we got rid of it and how 

00:58:54.290 --> 00:58:57.120
we're to be teaching data 
compression to modern developers

00:58:57.379 --> 00:58:59.702
 and engineers.  If you're 
interested in deep fundamental 

00:58:59.703 --> 00:59:02.443
understanding of how to make 
your apps smaller for users, 

00:59:02.634 --> 00:59:05.271
check out this book.  Deal?  
Deal?  All right.    

00:59:05.272 --> 00:59:08.481
Business is out of the way.    
When we talk about reducing the 

00:59:08.482 --> 00:59:12.068
data sizes of your applications 
for your users, there's 

00:59:12.069 --> 00:59:15.095
generally two buckets that I 
like to think of.  On one side 

00:59:15.096 --> 00:59:20.318
is your APK size.  This includes
 all the stuff like code sizes, 

00:59:20.558 --> 00:59:23.456
language information, image 
resources, layout data, config, 

00:59:23.457 --> 00:59:26.242
blah, blah, blah, blah, blah.  
All of the information that's 

00:59:26.243 --> 00:59:29.885
zipped up into a single APK file
 and downloaded when users 

00:59:30.213 --> 00:59:33.171
install your application.    
Now, on the other side of things

00:59:33.172 --> 00:59:37.596
 is all of the other stuff that 
your app downloads once it's 

00:59:37.597 --> 00:59:39.669
installed from the Internet.  So
 this could be many, many, many 

00:59:39.670 --> 00:59:44.254
things.  But it mostly boils 
down to images and ^ cereal ^ 

00:59:44.255 --> 00:59:49.097
serial                   ^ 
cereal ^ serialized   

00:59:49.654 --> 00:59:51.377
                  serialized 
data.  It's a crazy domain we're

00:59:51.378 --> 00:59:54.082
 not going to get into today.  
If you stay in your seats, the 

00:59:54.542 --> 00:59:57.382
next session will go very, very 
deep into that subject.  So make

00:59:57.552 --> 00:59:59.552
 sure you stick around for that

01:00:03.747 --> 01:00:06.778
of these categories.  That's why
 we're focusing on our images 

01:00:06.779 --> 01:00:10.152
today.  Quite frankly, images 
are awesome; right?  Round of 

01:00:10.153 --> 01:00:14.357
applause for images?  App      ?
(Applause)  

01:00:14.358 --> 01:00:18.124
Yeah?  I promise you, I will ask
 you to applaud weirder and 

01:00:18.125 --> 01:00:24.589
weirder stuff as the talk goes 
on.  Like who likes gum     

01:00:24.590 --> 01:00:28.737
gummy bears 
(Applause) we have to have an 

01:00:28.738 --> 01:00:30.738
understand    

01:00:30.969 --> 01:00:31.791
         . 
(Applause)  

01:00:31.792 --> 01:00:35.071
Images are fantastic.  We use 
them in our applications.  We 

01:00:35.072 --> 01:00:36.918
convey emotions and power and 
information and all this great 

01:00:36.919 --> 01:00:39.699
stuff, but images also have a 
problem, is that they're easy to

01:00:39.829 --> 01:00:43.391
 bloat.  They're easy to get too
 big and too many resolutions 

01:00:43.932 --> 01:00:46.602
and too many pixels.  That 
causes problems for your users, 

01:00:46.603 --> 01:00:49.616
because bigger images take long 
irrelevant to                   

01:00:50.333 --> 01:00:52.601
 longer to download, which means
 there are more bits on the 

01:00:52.851 --> 01:00:56.189
wire, costs your users more 
money to download them because 

01:00:56.190 --> 01:01:00.987
they are on metered plans and 
cellular is eating blare       

01:01:01.276 --> 01:01:03.572
their battery more.  All of 
these little things add up when 

01:01:03.573 --> 01:01:07.236
you start bringing these images 
down, which is why making sure 

01:01:07.237 --> 01:01:10.589
that your images are compressed 
is good and as small as 

01:01:11.547 --> 01:01:14.528
possible, it's super important 
to make sure your users are 

01:01:14.529 --> 01:01:17.253
having the best experience   
In general, there is a lot of 

01:01:17.652 --> 01:01:19.859
different things you could do 
with images, but as Android 

01:01:19.860 --> 01:01:22.522
developers there is only      
really only four data formats we

01:01:22.633 --> 01:01:29.627
 care about, PMG, vector, VPEG 
and WEBP.  The rest of the talk 

01:01:29.628 --> 01:01:32.932
is going to be opening up each 
one of these formats, taking a 

01:01:32.933 --> 01:01:36.497
look at how it looks internally 
and how you can squeeze out 

01:01:36.498 --> 01:01:39.571
every bit of tatted        data 
from these things possible.  

01:01:39.572 --> 01:01:41.572
Downed        Sound 

01:01:48.625 --> 01:01:49.375
good?
(Applause)  

01:01:49.376 --> 01:01:55.357
You'll get the hang of the 
applause.  GMGs       .  PMG 

01:01:56.101 --> 01:01:58.864
have to be one of the most 
amazing formats in determines 

01:01:59.088 --> 01:02:01.295
              in terms of 
Android format.  They provide 

01:02:01.296 --> 01:02:03.657
amazing quality and actually 
pretty good data compression.  

01:02:04.314 --> 01:02:06.421
So let's figure out what's    
    what's going on under the 

01:02:06.422 --> 01:02:10.647
hood.  Let's say we have an 
image.  The way PNG compression 

01:02:10.648 --> 01:02:14.635
works is we take every row of 
pixels in that image, one at a 

01:02:14.636 --> 01:02:17.300
time, process each row 
individually, and what we do is 

01:02:17.301 --> 01:02:19.730
we apply something called a 
filter to it.  Now, the filter 

01:02:20.383 --> 01:02:25.265
itself is basically a modified 
delta processor.  Basically it 

01:02:25.266 --> 01:02:28.173
will try to subtract the current
 pixel in the row from the 

01:02:28.174 --> 01:02:31.660
previous pixel, the one above 
it, and do all this weird math. 

01:02:31.900 --> 01:02:36.750
 The point of the filter is 
simple.  Produce the most number

01:02:36.751 --> 01:02:40.276
 of zeros and duplicate values 
as possible.  That's it.    

01:02:40.277 --> 01:02:44.347
The output of that is then Fed 
into a very common, super-

01:02:44.654 --> 01:02:50.945
everywhere encoding system 
called deflate.  Anybody 

01:02:50.946 --> 01:02:56.879
familiar with deflate?  
(One person applauding)   

01:02:56.880 --> 01:02:59.474
Get him a T-shirt.  We'll get to
 you later.  Did he plate

01:02:59.662 --> 01:03:03.911
           eflate is actually 
comprised two algorithms.  LZ77.

01:03:03.912 --> 01:03:08.476
  If you watch my compressor 
head video, you'll see that LZ77

01:03:08.477 --> 01:03:11.460
 is a dictionary algorithms    
        algorithm that tries to 

01:03:11.461 --> 01:03:14.081
match runs of duplicate 
characters multiple times in a 

01:03:14.082 --> 01:03:16.303
stream of data.    
The output of that is then 

01:03:16.304 --> 01:03:20.788
tossed to a Hu      a Huffman 
encoder, statistical encoder.  

01:03:20.789 --> 01:03:25.265
If you've been to CS101, you've 
dealt with Hu    Huffman.  A 

01:03:25.266 --> 01:03:27.880
single line and the output of 
deflate is kicked out to disk.  

01:03:30.257 --> 01:03:34.909
is very important.  In areas of 
your image where there's very 

01:03:34.910 --> 01:03:38.976
similar pixels or very -- a lot 
of duplicate pixels that     , 

01:03:39.194 --> 01:03:41.298
that filtering stage will 
produce a lot of zeros.  It will

01:03:41.442 --> 01:03:45.016
 produce a lot of duplicate 
symbols, which means the LZ77 

01:03:45.017 --> 01:03:47.642
and the deflate stage will come 
through and basically make that 

01:03:47.643 --> 01:03:51.814
stuff disappear.  So areas of 
similarity will get great 

01:03:51.815 --> 01:03:55.072
compression.  Areas of noise 
where there's not a lot of 

01:03:55.073 --> 01:03:57.757
similar pixels, different colors
 that may not be adjoined to 

01:03:57.758 --> 01:04:00.048
each other will actually have 
worse compression.  And that's 

01:04:00.049 --> 01:04:03.827
what you get with this tradeoff 
of the filtering stage with the 

01:04:03.828 --> 01:04:08.496
deflate stage.    
Now, with this in mind, we can 

01:04:08.497 --> 01:04:12.040
obviously see a couple places 
that PNGs can be        can be 

01:04:12.041 --> 01:04:14.861
optimized a little bit more.  
The first, of course, is less 

01:04:15.152 --> 01:04:18.262
input colors.  If we have let   
  less input colors coming into 

01:04:18.263 --> 01:04:20.794
the filtering stage, that means 
we'll have less unique colors 

01:04:21.139 --> 01:04:23.790
coming out, and we'll get better
 compression.    

01:04:23.791 --> 01:04:25.613
The other thing is actually 
smarter filtering.  I won't get 

01:04:25.614 --> 01:04:28.878
into it right now.  There's a 
different post on it, but 

01:04:29.824 --> 01:04:31.736
there's, like, five different 
filtering modes the encounter 

01:04:31.737 --> 01:04:35.318
can choose on, and there is a 
lot of math and accelerations 

01:04:35.319 --> 01:04:37.628
that go into finding that in a 
way that's not going to take ten

01:04:37.629 --> 01:04:40.385
 years to compute it.    
The other thing is a better 

01:04:40.605 --> 01:04:44.004
deplate algorithm.  Believe it 
or not, deflate isn't       

01:04:44.862 --> 01:04:48.522
isn't the best did he polite did
 he                           

01:04:48.973 --> 01:04:53.526
best did he polite              
      best, finally removing 

01:04:55.253 --> 01:04:57.966
chunks.    
You're saying wait a minute dep

01:04:58.510 --> 01:04:59.809
late deflate    

01:04:59.810 --> 01:05:04.076
    flate algorithm.  Believe it
 or not, deflate isn't the best,

01:04:59.810 --> 01:05:00.006
 finally removing chunks.  
You're saying wait a minute.  

01:05:00.007 --> 01:05:03.159
There       This should be 
happening for me.  This is this 

01:05:03.160 --> 01:05:07.584
cool called AAPT, anybody heard 
of that? 

01:05:07.585 --> 01:05:10.159
(Applause)              ?
(Applause)  

01:05:10.160 --> 01:05:11.689
In reality it should be      
        it should be crunching 

01:05:11.690 --> 01:05:15.096
them down as small as possible. 
 Anyone seen that hoop      

01:05:15.097 --> 01:05:17.097
happen?  Nobody?  Some people
             Some people?  

01:05:17.157 --> 01:05:20.114
Someone's  's asleep already.  
One applaud.  Get that guy a 

01:05:20.115 --> 01:05:23.397
T-shirt.  T-shirt for every clap
.  

01:05:23.398 --> 01:05:24.595
(Laughter)   
So I want to point out that 

01:05:24.596 --> 01:05:28.434
while the AAP tool is there to 
actually try to make your PNG 

01:05:28.599 --> 01:05:31.487
file smaller, it doesn't do 
everything it could. 

01:05:34.653 --> 01:05:37.782
 AAP tool does sphinx
      things specifically, 

01:05:37.783 --> 01:05:40.367
analyze your PNG files to see 
whether or not you're only using

01:05:42.005 --> 01:05:45.274
 gray scale colors.  For 
example, if you're red,  

01:05:45.565 --> 01:05:48.484
              if your red, 
green, blue channels are the 

01:05:48.485 --> 01:05:53.248
same color, it will make it into
 single eight bi          eight 

01:05:53.249 --> 01:05:56.168
bit alpha channel.    
The second thing it will look 

01:05:56.169 --> 01:05:58.700
for is whether you're using your
 transparency channel.  If 

01:05:59.005 --> 01:06:02.345
you've got a fully opaque image,
 it will actually get rid of 

01:06:02.346 --> 01:06:04.978
that entire channel and save it 
out to be smaller.    

01:06:04.979 --> 01:06:07.519
The final thing, and this is the
 one that's pretty awesome, it 

01:06:07.520 --> 01:06:10.121
will actually scan your entire 
image and determine whether or 

01:06:10.122 --> 01:06:16.680
not you're using 256     256 
unique colors.  If you're using 

01:06:16.681 --> 01:06:21.081
256     256 unique colors, it 
will save your image in a 

01:06:21.082 --> 01:06:25.567
palleted format, which basically
 decreases the size by some 

01:06:25.955 --> 01:06:31.355
insane amount.  Basically all of
 the 32 bit per pixel data gets 

01:06:31.356 --> 01:06:34.906
quantitized into a table called 
a pallet and replaced with an 

01:06:34.907 --> 01:06:37.891
eight bit pointer into that 
balance         pallet.  You're 

01:06:37.892 --> 01:06:41.242
now down to eight.    
Good savings.  So the question I

01:06:41.243 --> 01:06:44.207
 have is AAPT is really good, 
but how good is it?  And to 

01:06:44.208 --> 01:06:47.513
answer that, I had to open up an
 application and take a look at 

01:06:47.514 --> 01:06:51.682
how AAPT was impacting and 
affecting that application to 

01:06:51.683 --> 01:06:54.458
see whether or not it was doing 
a really good job or if there's 

01:06:54.459 --> 01:06:55.630
some improvements to be made.   

01:06:55.631 --> 01:06:59.113
So being IO, I felt make      
maybe we should do a call back 

01:06:59.114 --> 01:07:03.547
to last year's  's IO shed 
application and see how well

01:07:08.685 --> 01:07:12.551
 I felt maybe we should do a 
call back to last year's I/O 

01:07:08.685 --> 01:07:09.268
shed application and see how 
well anybody look through the 

01:07:09.269 --> 01:07:10.909
scheduler?
(Applause)  

01:07:10.910 --> 01:07:15.351
Did anyone find the hidden 
Easter egg in the source code?  

01:07:15.947 --> 01:07:17.897
Oh, no?  Then forget I said 
anything.    

01:07:17.898 --> 01:07:20.508
So when we open up this file, 
there is a lot of assets.  Now, 

01:07:20.509 --> 01:07:23.524
there is two things to compare 
here.  First is the source code 

01:07:23.525 --> 01:07:29.538
files in get hub and the A    
            it hub and the A so 

01:07:29.853 --> 01:07:33.511
I wanted to look between these 
two.  Because if AAPT is doing a

01:07:33.512 --> 01:07:37.084
 great job, I should see a great
 change between the two file 

01:07:37.085 --> 01:07:44.562
sizeses.     es  .  I looked at 
this random file, a 144 by 

01:07:44.953 --> 01:07:50.824
144PNG file.  That's 6K.  That's
 huge.        

01:07:51.046 --> 01:07:55.179
 hub and the A so I wanted to 
look between these two.  Because

01:07:51.046 --> 01:07:54.979
 if AAPT is doing a great job, I
 should see a great change 

01:07:51.046 --> 01:07:55.112
between the two file sizes.  I 
looked at this random file, a 

01:07:51.046 --> 01:07:53.046
144 by 144PNG file.  That's 6K. 
 That's huge.  This is in the 

01:07:53.697 --> 01:07:55.697
source code radio possess.  When
 I look at the

01:08:00.787 --> 01:08:04.954
  When I look at the APK, is 
better but still massively huge.

01:08:04.955 --> 01:08:08.429
  So I said, well, hold on, 
something's missing here.  

01:08:08.430 --> 01:08:12.274
Obviously we got some open Tim 
meization                      

01:08:13.309 --> 01:08:17.133
   some optimum         
optimization.  I saved it for 

01:08:17.134 --> 01:08:20.773
the Web.  It's a different 
between file saved and saved for

01:08:20.774 --> 01:08:24.372
 the web.  In that process I 
quantitized it to only use 256 

01:08:24.693 --> 01:08:27.759
colors.  You can see when I did 
that, we got about the same size

01:08:27.760 --> 01:08:32.056
 as was in the APK.  We can see 
that, hey, the AAPT did its job.

01:08:32.057 --> 01:08:36.306
  It probably quantitized this 
to an indexed image.  Here is 

01:08:36.307 --> 01:08:39.879
the problem:  Take a look at the
 image.  Does it look like it's 

01:08:39.880 --> 01:08:43.246
using 256 colors?  No.    
So let's crank it down a little 

01:08:43.247 --> 01:08:46.748
bit.  Here is what 64 colors 
looks like.  Anybody see a 

01:08:46.749 --> 01:08:50.168
change?  Let's go even more.  16
 colors.  Still don't       

01:08:50.169 --> 01:08:53.715
don't see a change.  Eight 
colors.  Still don't       don't

01:08:53.716 --> 01:08:57.504
 see a change.  Or if you do, 
your eyes are better than mine. 

01:08:58.918 --> 01:09:01.879
from 256     256 unique colors 
down to eight unique colors and 

01:09:02.311 --> 01:09:04.705
didn't see a change in visual 
perception.  The difference in 

01:09:04.706 --> 01:09:08.946
file size, though, was huge; 
right?  Because we were able to 

01:09:08.947 --> 01:09:12.409
find a smaller color size.    
So let's look at a different 

01:09:12.410 --> 01:09:17.110
example here.  So this is one of
 the big banners images that you

01:09:17.111 --> 01:09:20.201
 see inside of the application. 
 That's 49.            That's 

01:09:20.202 --> 01:09:26.126
49.5k k in the Git had you been 
repo and 32K inside the APK.  So

01:09:26.127 --> 01:09:30.630
 some smaller modifications 
going on here to the about      

01:09:30.917 --> 01:09:32.447
 you     

01:09:32.448 --> 01:09:36.714
                             been
 repo and 32K inside the APK.  

01:09:32.448 --> 01:09:33.599
So some smaller modifications 
going on here to the had 

01:09:33.600 --> 01:09:33.935
hub      
                                                                                          ub

01:09:33.936 --> 01:09:37.402
 been repo and 32K inside the 
APK.  So some smaller 

01:09:33.936 --> 01:09:36.204
modifications going on here to 
the.  Let's downgrade it 

01:09:36.205 --> 01:09:36.410
been       
                                                                                                        repo

01:09:36.411 --> 01:09:40.477
 and 32K inside the APK.  So 
some smaller modifications going

01:09:36.411 --> 01:09:38.079
 on here to the.  Let's 
downgrade it to 32 colors.  This

01:09:38.080 --> 01:09:40.380
 one isn't       isn't that good
.  You can see some banding in 

01:09:40.381 --> 01:09:42.254
the gradients there.  You can 
see that some of the colors just

01:09:42.255 --> 01:09:44.916
 aren't        aren't looking at
 true as you can.  So let's bump

01:09:44.917 --> 01:09:49.489
 that up to exactly 256 colors. 
 Here you can't actually see any

01:09:49.785 --> 01:09:52.483
 visual difference; right?  But 
notice the difference in the 

01:09:52.484 --> 01:09:56.516
file size.  This is only 18K 
instead of the 36    36K; right?

01:09:56.517 --> 01:10:00.636
  So this image actually only 
needed 256 colors, but maybe the

01:10:00.840 --> 01:10:03.027
 source image didn't have that. 
 And this is the problem 

01:10:06.109 --> 01:10:08.331
with the AAPT cool           
AAPT tool.  It does a great job 

01:10:08.568 --> 01:10:10.595
at those exact three things and 
no more than that.    

01:10:10.596 --> 01:10:12.677
In the first case we had an 
image that obviously needed less

01:10:12.678 --> 01:10:17.752
 colors, right, and could have 
been optimized           

01:10:17.753 --> 01:10:20.507
optimized more, and the second 
case had just over 256 colors 

01:10:20.679 --> 01:10:23.215
that if we set it to 256     256
 it still would have looked fine

01:10:27.427 --> 01:10:30.873
.  It means it's your job as a 
developer to step behalf        

01:10:30.874 --> 01:10:33.701
past that and do additional 
methods and reduce the files of 

01:10:33.702 --> 01:10:36.707
your PNG files.  Let's take a 
look, as I said before, how easy

01:10:37.160 --> 01:10:40.713
 said      it is to mess this 
up.  So you've actually just 

01:10:41.157 --> 01:10:43.157
take a 16 before this accident 
he will by                

01:10:44.394 --> 01:10:47.455
                      a 16 pixel
 by 16 pixel all red file save 

01:10:47.456 --> 01:10:53.604
as Photoshop is 2K.  That's 64 
pixels.  2K.  

01:10:53.605 --> 01:10:55.675
(Laughter)   
The funny thing right now is 

01:10:55.676 --> 01:10:58.481
everyone in the room is doing a 
gut check about whether or not 

01:10:58.482 --> 01:11:01.911
their designers are using file 
save as from Photoshop to save 

01:11:01.912 --> 01:11:06.868
their PNGs; right?  When you 
save it for web, you end autopsy

01:11:06.869 --> 01:11:11.291
 the                 end up at 
121 bites.  This is how it is 

01:11:11.606 --> 01:11:13.501
    easy it is to mess up this 
problem.    

01:11:13.502 --> 01:11:15.997
Now, the good news is you don't
           you don't have to go 

01:11:15.998 --> 01:11:18.614
into crazy town with trying to 
optimize all those things we 

01:11:18.969 --> 01:11:23.012
talked about before with the 
different thanks of PNGs.  PNGs 

01:11:23.013 --> 01:11:26.911
open at this me takings is 
                           open 

01:11:26.912 --> 01:11:28.007
at this me takings     
                timization is an

01:11:28.008 --> 01:11:33.500
 old problem.  Some of you were 
alive in the 90s; right?  What 

01:11:33.501 --> 01:11:37.456
wasn't alive in the 90s?  Okay. 
 All right.  Old people.  Nice. 

01:11:39.041 --> 01:11:43.449
I'm sorry, "Professional" 
people.  The truth is there is a

01:11:43.450 --> 01:11:46.961
 plethora of rules          of 
actually, out there solving the 

01:11:46.962 --> 01:11:49.318
problem for two decades.  You 
don't           You don't have 

01:11:49.319 --> 01:11:54.372
to do the heavy lifting.  Google
 it and do any one of these.  

01:11:54.516 --> 01:11:56.278
Different stuffs        stuff 
and different algorithms and 

01:11:56.279 --> 01:11:58.693
different settings.  But if you 
just add any one of these to 

01:11:58.694 --> 01:12:03.149
your existing as set        
asset chain, you'll get an 

01:12:03.150 --> 01:12:05.195
immediate improvement in file 
size.  That being said, there 

01:12:05.196 --> 01:12:08.394
are some things that you can do 
it tock            do it make it

01:12:08.395 --> 01:12:12.055
 even better in terms of file 
sizes.     these two things 

01:12:12.056 --> 01:12:15.920
because I'm seeing them a lot in
 applications that I'm opening 

01:12:15.921 --> 01:12:20.110
and taking a look at.  Aka, here
 is the things you're all doing 

01:12:20.111 --> 01:12:24.516
that you need to stop.  So, 
first off, if you can, in every 

01:12:24.517 --> 01:12:30.582
single way, try, try, try to 
make your image 256 colors or 

01:12:31.463 --> 01:12:34.907
less.  It's a pretty simple 
quantitization step.  You 

01:12:35.626 --> 01:12:39.826
staffed it and               
     You look at our main page 

01:12:39.827 --> 01:12:45.528
here, it came down 24 bits per 
pixel, wasn't indexed, as    at 

01:12:45.760 --> 01:12:51.145
197 per K.  When we indexed, 
only 73K.  Visual difference 

01:12:51.146 --> 01:12:53.851
here imperceptible.  The 
difference in file size was huge

01:12:54.111 --> 01:12:58.021
 just by trying to take into 
account hitting that index mark.

01:12:59.765 --> 01:13:02.319
actually pretty simple.  There's
 nothing crazy going on.  By the

01:13:02.320 --> 01:13:05.132
 way, that diamond down there on
 that white actually represents 

01:13:05.133 --> 01:13:08.697
the transparent pixel color for 
that.  You can actually do a 

01:13:08.698 --> 01:13:11.337
bunch of those.  Read the 
article.  There is more stuff on

01:13:11.338 --> 01:13:12.968
 that there   
Here is another one.  Can 

01:13:12.969 --> 01:13:17.249
anybody tell me why one of these
 images is 139     139 and one 

01:13:17.250 --> 01:13:23.509
of these is 214?  Alpha channel?
  Good.  What about the alpha 

01:13:23.510 --> 01:13:27.374
channel?  Wait, did you read the
 article?  Oh, wait, never mind.

01:13:27.375 --> 01:13:31.061
  Cheater.  No, I'm kidding.  
(Laughter)   

01:13:31.062 --> 01:13:33.425
So absolutely right.  Alpha 
channel.  So here is what's 

01:13:33.426 --> 01:13:36.390
happening.  I've seen this quite
 a bit in a lot of the files 

01:13:36.391 --> 01:13:39.805
I've opened.  So visually you 
can see that the last frame is 

01:13:39.806 --> 01:13:42.051
what the user sees here.  But 
when you open this thing up and 

01:13:42.398 --> 01:13:46.277
you take a look at the RGB 
channels and the eight channels 

01:13:46.278 --> 01:13:50.891
separately, RGB has a ton of 
data that gets mess      massed 

01:13:50.892 --> 01:13:54.446
out by the alpha value.  The 
same visual image to the user, 

01:13:54.447 --> 01:13:59.393
but to the compressor we still 
have to compress all of that RGB

01:13:59.559 --> 01:14:03.960
 data.  The filtering stage has 
to be run on it, the output to 

01:14:03.961 --> 01:14:08.646
deplate algorithm.              
        defluffed algorithm.  

01:14:08.983 --> 01:14:14.059
The                           
deflate algorithm.  If we try to

01:14:14.284 --> 01:14:17.536
 mask out the pixels that will 
never be seen, we end up with a 

01:14:17.537 --> 01:14:20.455
much smaller file size.  I've 
been seeing this in applications

01:14:20.456 --> 01:14:23.423
 popping up a lot more than I'd 
like to say.    

01:14:23.424 --> 01:14:27.964
Take a look at this.  
One of the final things I need 

01:14:27.965 --> 01:14:31.294
to point out, if you're going to
 go down this path and add in 

01:14:31.295 --> 01:14:34.686
some of these preprocessing 
tools to your chain and you'll 

01:14:34.687 --> 01:14:37.672
tell your designers to not do 
the things I just said and make 

01:14:37.673 --> 01:14:41.729
index files, you may run into a 
really weird issue.  Let's say 

01:14:41.730 --> 01:14:44.663
we have a 216K and run it 
through

01:14:48.285 --> 01:14:53.716
 Zoft PNG, an open source tool 
for PG        for PNG files.  We

01:14:53.885 --> 01:14:58.752
 get it down to 185K.  When you 
built       build it, it goes 

01:14:58.753 --> 01:15:00.753
through

01:15:02.302 --> 01:15:05.063
         through and it floats
      bloats.  The reason is the

01:15:05.064 --> 01:15:08.234
 tool doesn't know you've pre
processed your image.  Again, 

01:15:08.694 --> 01:15:10.941
it's only checking for those 
three things.  It will look at 

01:15:10.942 --> 01:15:14.695
your image and it will try to 
make it into A, B, or C format. 

01:15:14.844 --> 01:15:17.539
 Then it will just save it right
 to disk.  The problem with that

01:15:17.540 --> 01:15:19.858
 is you may have made 
modifications and obviously your

01:15:20.022 --> 01:15:22.583
 version is smaller, and their 
version may not be.    

01:15:22.584 --> 01:15:25.676
To get around this in your 
application, you need to specify

01:15:25.677 --> 01:15:33.796
 the option Gr radle, this will 
disable AABT optimization all 

01:15:33.797 --> 01:15:37.067
the PNG files coming through the
 pike.  Once you do this, it's 

01:15:37.068 --> 01:15:39.471
on you to make sure all your 
images are awesome at that 

01:15:39.472 --> 01:15:45.132
point, which you're all going to
 do             going to do?

01:15:45.133 --> 01:15:49.631
(Applause)  
Now the back row?

01:15:49.632 --> 01:15:51.869
(Applause)  
Let's try the front row again. 

01:15:51.870 --> 01:15:54.270
(Applause)  
That's good.  That's good.  I'm 

01:15:54.271 --> 01:15:57.077
sorry the front row is winning. 
 Back row, you want to try 

01:16:01.180 --> 01:16:01.679
again?
(Applause)  

01:16:01.680 --> 01:16:05.173
Oh, they added whistling.  Come 
on, front row.  We'll try again 

01:16:05.174 --> 01:16:10.573
later.  The live stream is 
getting antsy.    

01:16:10.574 --> 01:16:14.026
Set this configuration to make 
sure you don't           you 

01:16:14.027 --> 01:16:16.027
don't get bloating images that 
you've already taken the time to

01:16:16.312 --> 01:16:18.580
 compress.  Probably one of the 
biggest things that you can do, 

01:16:18.581 --> 01:16:21.830
though, in terms of file savings
 is actually consider replacing 

01:16:21.831 --> 01:16:28.760
your PNG all together with 
vector dr    drobbl        

01:16:28.761 --> 01:16:33.070
drobbles.  PNG are r   raster 
files and you kneeled multiple 

01:16:33.264 --> 01:16:36.897
of them to get your images.  We 
need one at in resolution and 

01:16:37.054 --> 01:16:40.221
one at this resolution, which 
means in our APK we're ending up

01:16:41.073 --> 01:16:45.749
 at 5K footprint to present the 
same image at different 

01:16:45.937 --> 01:16:48.259
resolutions.  There are some 
split and up sampling and all 

01:16:48.260 --> 01:16:50.710
this other stuff, but this is 
the gift  st of the problem.  

01:16:51.077 --> 01:16:53.527
There is another way to approach
 this issue, and the concept of 

01:16:53.528 --> 01:16:55.871
drawing your images with code.  
So that same picture, what if we

01:16:57.153 --> 01:17:02.317
 took a stab saying let's admit 
a bite code and another code 

01:17:02.318 --> 01:17:06.889
that draws a red circle.  If we 
could rate our custom DSL 

01:17:06.890 --> 01:17:11.525
language, we get this in one 
byte per instruction, and 15 

01:17:11.526 --> 01:17:14.490
bytes to represent the same 
thing.  The result of this is 

01:17:16.053 --> 01:17:16.287
bite byte 

01:17:16.288 --> 01:17:21.488
                                               yte
 code and another code that 

01:17:16.288 --> 01:17:20.488
draws a red circle.  If we could
 rate our custom DSL language, 

01:17:16.288 --> 01:17:20.088
we get this in one byte per 
instruction, and 15 bytes to 

01:17:16.288 --> 01:17:16.684
represent the same thing.  The 
result of this is we can 

01:17:16.685 --> 01:17:20.294
generate these same images using
 only 15 bytes of our scheme 

01:17:20.295 --> 01:17:23.393
instead of the 55k     55K we 
were using before.  This is the 

01:17:23.394 --> 01:17:26.698
concept of vector image formats.
  Right?  Basically we take some

01:17:26.889 --> 01:17:30.137
 sort of stream that represents 
how to draw primitives on a 

01:17:30.138 --> 01:17:34.811
screen.  We actually execute 
those, r   raster  eriz    e

01:17:36.280 --> 01:17:38.972
rizing in a bit map, and we end 
up drawing that to the screen.  

01:17:39.174 --> 01:17:42.587
The benefit you get here is much
 smaller file sizes.  The 

01:17:42.588 --> 01:17:47.621
downside is you actually trade 
off time.  It takes longer to 

01:17:47.622 --> 01:17:50.448
rasterizing these images and 
getting them into memory and use

01:17:50.449 --> 01:17:54.021
 the hardware decoder and decode
 a JPEG.  

01:17:54.022 --> 01:17:56.022
Theles the whole idea
                            .   

01:17:58.517 --> 01:18:04.271
and droid's  's vehicler dr    
drobbl        drobble format.  

01:18:04.551 --> 01:18:07.449
It's a stream of paths and 
colors and gradients so you can 

01:18:07.450 --> 01:18:11.997
draw these images at the sizes 
you need on demand.    

01:18:11.998 --> 01:18:16.392
The question is, okay, this is 
fine.  It's fancy.  I've got a 

01:18:16.393 --> 01:18:20.980
pipeline, my artists know how to
 make the PNG.  Come on, bald 

01:18:20.981 --> 01:18:23.899
guy, let's get to the point.  
What's        What's going on?  

01:18:23.900 --> 01:18:24.831
Don't       
Don't rare            

01:18:24.832 --> 01:18:29.389
Don't worry.  How much could 
vector drobbles save me as a 

01:18:29.390 --> 01:18:33.412
developer?  To figure this out, 
I needed to take the I/O shed 

01:18:33.413 --> 01:18:37.806
application and convert all my 
images to vector tribal        

01:18:37.807 --> 01:18:43.475
drobbles.  There is 270     270 
of these       these.  I don't 

01:18:43.476 --> 01:18:48.233
have time to hand-customized 
those images.  There is a great 

01:18:49.397 --> 01:18:51.757
tool called PO trace     Trace. 
 It's been around a long time.  

01:18:51.758 --> 01:18:55.998
It will take a bit map image, 
with one bit per pixel, and 

01:18:56.129 --> 01:19:02.781
actually turn it into a vector 
format raster image to vector 

01:19:03.001 --> 01:19:06.347
format.  I decided to run this 
on every aspect of the I/O 

01:19:06.348 --> 01:19:08.873
application.  The results were a
 lot better than I expected, to 

01:19:08.874 --> 01:19:11.575
be honest with you.    
So you can see the top row here 

01:19:11.576 --> 01:19:14.510
is the source.  The bottom row 
here is the result of the PO 

01:19:14.511 --> 01:19:17.181
trace application.  We're pretty
 close -- the first one looks 

01:19:17.591 --> 01:19:19.689
identical.  The second one you 
can see some rounding.  The 

01:19:19.690 --> 01:19:22.416
third one, pretty good.  The 
fourth one you can see we're 

01:19:22.417 --> 01:19:24.793
only dealing with shapes and we 
lose some color there.  The 

01:19:25.146 --> 01:19:28.353
hexagon is perfect.   S hexagon 
is a really cool example here, 

01:19:28.354 --> 01:19:33.665
because that hexagon actually 
absorbs #6    6K of our file 

01:19:33.810 --> 01:19:38.144
size.  The vector version was 
only 961 bytes.  So even just 

01:19:38.145 --> 01:19:41.404
running it through here, we saw 
some wins.    

01:19:41.405 --> 01:19:43.951
The downside, though, is this is
 an automated tool.  This is 

01:19:43.952 --> 01:19:46.515
only a test.  We're trying to 
figure how all this works 

01:19:46.516 --> 01:19:49.454
together.  Obviously there were 
some failures.  We missed some 

01:19:49.455 --> 01:19:55.394
enter            some inter 
      interspersion detail, and 

01:19:55.395 --> 01:19:57.284
it fell over and died on the 
algorithm   

01:19:57.285 --> 01:19:59.811
The result, though was a good 
test to figure out what you 

01:19:59.812 --> 01:20:03.197
could save.  So running things 
through PO trace     Trace we 

01:20:03.198 --> 01:20:06.919
actually ended up with only 153 
files.  We didn't have to have 

01:20:07.106 --> 01:20:09.958
one for each resolution.  And 
the result was actually 149     

01:20:09.959 --> 01:20:15.770
149K.  That's 84% reduction in 
asset side      sizes by moving 

01:20:15.771 --> 01:20:19.158
everything to be a vector 
drobble, which is a pretty good 

01:20:19.159 --> 01:20:21.195
size   avings.  Yes, let's lab

01:20:27.345 --> 01:20:31.065
.    
So 84 percent.  It's worth 

01:20:31.066 --> 01:20:34.992
noting, you can't run clap     
                                                        clap.

01:20:34.993 --> 01:20:38.537
noting, you can't run PO test 
and convert everything over.  By

01:20:38.670 --> 01:20:42.323
 the way, there is a chance you 
could optimize stuff further 

01:20:42.324 --> 01:20:46.211
instead of importing from SBG 
and did stuff from hand, you 

01:20:46.212 --> 01:20:49.663
could get smaller than that.  
You can get a lot of savings 

01:20:49.664 --> 01:20:52.495
here by moving to vector tribal 
     drobbles.  So make sure you

01:20:52.770 --> 01:20:54.770
 take a look at

01:21:00.186 --> 01:21:04.376
 it.  JPEGs.  Who loves JPEGs?
(Applause)

01:21:07.728 --> 01:21:09.728
back.  I love the

01:21:12.689 --> 01:21:15.714
 begrudging pause.  We're just 
here to stay out of the heat.  

01:21:15.839 --> 01:21:19.001
Pass me some water.  
(Laughter)   

01:21:19.002 --> 01:21:24.878
JPEG files.  I got to tell up 
JPEGs are crazy.  One of the 

01:21:25.399 --> 01:21:27.399
most impressive

01:21:29.128 --> 01:21:34.279
 algorithm systems I've ever 
encounters.  It's impressive the

01:21:34.280 --> 01:21:38.817
 math.  Not frustrate           
just from the algorithm, but 

01:21:38.818 --> 01:21:40.633
from the raw math of the 
situation.  When you encode a 

01:21:40.634 --> 01:21:42.971
JPEG, here is what's        
what's going O you take your 

01:21:43.616 --> 01:21:46.345
source RGP image.  The first 
thing that happens is we convert

01:21:46.845 --> 01:21:48.848
 it to a special color space.  
The reason for this is the human

01:21:49.277 --> 01:21:54.270
 eye, the psycho visual 
differences in the human eye are

01:21:54.271 --> 01:21:56.552
 less susceptible to the 

01:21:59.591 --> 01:22:02.733
YCBCR color someplace           
space.  The human eye is more 

01:22:02.734 --> 01:22:04.734
tuned to see differences

01:22:08.309 --> 01:22:11.953
 in RGBs.  The heck thing is 
reactually next 

01:22:12.281 --> 01:22:13.656
                            next
 thing is reactually reduce the 

01:22:13.657 --> 01:22:17.025
side of the chrome achannel.  
The human eye doesn't notice as 

01:22:17.026 --> 01:22:19.500
much changes in that spectrum so
 it doesn't worry about it.  

01:22:19.501 --> 01:22:22.421
After that we actually go 
through and block up our image 

01:22:22.422 --> 01:22:27.766
and apply the discreet cosigned 
transformed.  This is magical.  

01:22:27.767 --> 01:22:30.628
If you get a chance to check out
 the blog post on this, 

01:22:30.629 --> 01:22:34.518
basically the idea of the 
discreet cosign transform is 

01:22:34.519 --> 01:22:39.168
that any signal can be 
represented by a sum of cosigns.

01:22:43.299 --> 01:22:47.599
 What?  It's a thing.  These 
mathematicians sat down and 

01:22:47.600 --> 01:22:50.004
wrote it down on paper before 
computers.  It's one of the most

01:22:50.382 --> 01:22:53.094
 amazing things I've ever seen. 
 Basically they can represent 

01:22:53.710 --> 01:22:57.375
any eight by eight block of 
pixels by summing cosign 

01:22:57.376 --> 01:23:00.519
transforms across the space.  
That is awesome.    

01:23:00.520 --> 01:23:02.520
The output of that is then 
rammed into a quantitization 

01:23:02.521 --> 01:23:06.841
phase.  The quantitization phase
 takes the out put of the 

01:23:08.110 --> 01:23:11.074
coefficients and a subspace we 
can get coding mere      more, 

01:23:11.269 --> 01:23:14.694
which may be    be Hu       be 
Huffman or whatever your 

01:23:14.695 --> 01:23:16.951
particular flavor of the month 
is, and then finally, of course,

01:23:17.079 --> 01:23:20.558
 we egg to the output JPEG 
                          we go 

01:23:20.676 --> 01:23:23.923
to the output JPEG file.  This 
is awesome.  This is totally 

01:23:23.924 --> 01:23:29.117
crazy; right?  Way harder than 
PNG.  Then why, when you export 

01:23:29.118 --> 01:23:33.566
an image you're given one 
slider?  

01:23:33.567 --> 01:23:35.677
(Laughter)   
All of this chaos is hidden 

01:23:35.930 --> 01:23:39.397
by    behind one slider when you
 export an image.  That's 

01:23:39.398 --> 01:23:42.069
impressive on its own right.  
Now, the question is what should

01:23:42.351 --> 01:23:45.673
 this value be?  This is the 
JPEG quality.  When you export a

01:23:45.674 --> 01:23:49.787
 JPEG, we ask you what quality 
you want to output it at.  What 

01:23:49.788 --> 01:23:53.281
should this be?  Let's take a 
visual look at what Photoshop 

01:23:53.462 --> 01:23:58.618
would actually output as.  Here 
is PS12, 100   100 percent JPEG 

01:23:58.619 --> 01:24:05.052
quality, 263K.  Let's drop down 
to 11, 10, will to eight, you 

01:24:05.053 --> 01:24:07.053
can start seeing some will

01:24:07.089 --> 01:24:11.555
                                    to
 eight, you can start seeing 

01:24:07.089 --> 01:24:10.699
some blocking.  Look at the red 
parrot's  's head.  You can see 

01:24:10.700 --> 01:24:16.317
the artifacts, not as solid 
gradients there.  Go down to 

01:24:16.318 --> 01:24:18.678
four.  This is quality four.  
You see a lot more ringing 

01:24:18.679 --> 01:24:22.320
artifacts here.  You can see the
 quantitation     ization 

01:24:23.856 --> 01:24:26.343
artifacts and zero.  Obviously 
some color bleeding going on, 

01:24:26.576 --> 01:24:30.303
we're seeing some big stuff 
there.  So the question is what 

01:24:30.304 --> 01:24:32.304
value should I choose

01:24:38.069 --> 01:24:46.669
                                                                                           zation
 artifacts and zero.  Obviously 

01:24:38.069 --> 01:24:41.935
some color bleeding going on, 
we're seeing some big stuff 

01:24:38.069 --> 01:24:38.642
there.  So the question is what 
value should I choose.  There is

01:24:38.643 --> 01:24:41.375
 no way we can support that in 
any real pipeline.  The solution

01:24:41.540 --> 01:24:45.803
 is to not.  Automate the whole 
process.  For that, I'll get to 

01:24:45.804 --> 01:24:49.857
in another slide.    
The real solution here is to 

01:24:49.858 --> 01:24:52.269
automate this process and figure
 it out.  That's not what most 

01:24:52.270 --> 01:24:56.602
people are doing.  What peeved 
people are actually most    

01:24:56.896 --> 01:24:57.089
                           most 
people are actually are 

01:24:57.090 --> 01:25:01.723
exporting the images at that.  
The image men project downloaded

01:25:01.997 --> 01:25:05.075
 a bunch of images from all the 
social networks and figuring out

01:25:05.678 --> 01:25:07.764
 what the export quality was and
 put it together in a table.  

01:25:08.033 --> 01:25:10.375
You can actually see what 
everyone is exporting things at.

01:25:12.668 --> 01:25:14.668
actually really impressive, 
because it means they're trying 

01:25:15.063 --> 01:25:17.717
to actually find the right range
 of things.  The weird thing is 

01:25:17.718 --> 01:25:20.125
it's not as scalable as you 
would think; right?  If 

01:25:20.126 --> 01:25:22.640
something happens to be brighter
, it's given these values.  If 

01:25:22.641 --> 01:25:27.080
it's darker, it's these values. 
 A little more quantitized than 

01:25:27.081 --> 01:25:31.596
dynamic.  How do we figure this 
out algorithm I canny  

01:25:33.291 --> 01:25:40.292
                 algorithmicy   
This is by the compression team 

01:25:40.293 --> 01:25:44.419
inth -- so to make sure that you
 all can browns it, we'll

01:25:44.828 --> 01:25:46.828
                      can 
pronounce it.  This is gonna

01:25:49.704 --> 01:25:54.629
 be Boo teer             be Boo 
teere              be Boo teere 

01:25:54.630 --> 01:25:57.950
oggly 
&gt;&gt; In the native language it 

01:25:57.951 --> 01:26:02.950
means sweet bread to eat with 
coffee.  In the Git hub project 

01:26:02.951 --> 01:26:07.338
it's a way to compare the psycho
visual similarity between two 

01:26:07.339 --> 01:26:11.039
images.  It's a way to say let 
me take a sort image and 

01:26:11.040 --> 01:26:13.273
compress it and see how the 
human eye responds to the 

01:26:13.274 --> 01:26:16.101
differences between these two.  
How much error can we actually 

01:26:16.102 --> 01:26:20.132
notice?  You may have heard some
 other terms in the past, like 

01:26:20.133 --> 01:26:23.921
PSNR.  Anybody hear that one?  
SSIM?  Yeah, these are common.  

01:26:24.317 --> 01:26:28.219
Yeah, nice.  These are very 
common things.  Thing of him in 

01:26:28.220 --> 01:26:30.524
the same fashion as that.  The 
ability to measure two different

01:26:32.636 --> 01:26:35.789
 psycho changes as an image 
changes.   

01:26:35.790 --> 01:26:38.902
The really use of the intention 
that it was made for was to 

01:26:38.903 --> 01:26:42.956
actually figure out how much we 
can compress an image before the

01:26:42.957 --> 01:26:46.643
 human eye notices anything.  
Right?  How far can we go before

01:26:46.644 --> 01:26:50.350
 even the smallest perceived 
visual change occurs.  When you 

01:26:50.351 --> 01:26:53.433
actually use the library, you'll
 notice that occurs at the 

01:26:53.620 --> 01:26:57.228
1.0     1.0 level.  So when you 
export at 1.0     

01:27:04.434 --> 01:27:08.527
1.0, that is where.   
Anything below 1.0     1.0, you 

01:27:08.528 --> 01:27:11.922
can't decipher.  Your goal would
 be, hey, we have a lot of my   

01:27:12.682 --> 01:27:16.318
 high r        high res images, 
and we want to find the image 

01:27:16.687 --> 01:27:18.687
export, this will help you.  
Sometimes I don't want 

01:27:19.564 --> 01:27:21.564
perfection; right?  Sometimes I 
want a little bit of compression

01:27:23.371 --> 01:27:25.706
 artifacts in there.  Someone is
 loading something on a 2G 

01:27:25.707 --> 01:27:28.437
network or sitting in roaming 
and don't       don't have the 

01:27:28.736 --> 01:27:31.528
right detective in interestedia 
                in independentth

01:27:32.820 --> 01:27:36.432
                  in India.  
Maybe I'm okay going above 1.0

01:27:36.515 --> 01:27:39.690
     1.0.  So detective      
                                                            in

01:27:39.691 --> 01:27:40.881
 India.  Maybe I'm okay going 
above 1.0.  So how would we find

01:27:40.882 --> 01:27:43.693
 something like this, find the 
right level for some other 

01:27:43.694 --> 01:27:47.998
statistics            statistic?
  It's pretty easy.  If we take 

01:27:47.999 --> 01:27:51.962
a little python script and run 
image magic, we can convert 

01:27:51.963 --> 01:27:56.494
appointing          PNG at some 
JPEG quality.  We know we're 

01:27:56.495 --> 01:28:02.150
comparing apples to apples here.
  We run those two PNG files and

01:28:02.527 --> 01:28:05.944
 then through some random metric
 we have decided based upon 

01:28:05.945 --> 01:28:07.735
artificial intelligence and 
machine learning for this person

01:28:07.736 --> 01:28:10.676
 and     in this area on this 
device, let's just say it's 2.

01:28:10.920 --> 01:28:14.600
         it's 2.30 random    
              it's 2.0          

01:28:14.601 --> 01:28:16.647
it's 2.0 random        randomly,
 what does this look like?  I 

01:28:16.648 --> 01:28:20.262
ran it on the parrot images.  
You can see really quickly that 

01:28:20.263 --> 01:28:23.821
we can find about quality 60 we 
passed the 2.0     2.0 threshold

01:28:23.956 --> 01:28:26.340
           threshold.  It 
actually was able to dive in a 

01:28:26.341 --> 01:28:29.521
little bit more and get single 
step quantization, actually 

01:28:29.522 --> 01:28:33.446
found that at quality 62    62 
we broke the 2.0     2.0 

01:28:33.447 --> 01:28:35.501
threshold           threshold.  
Let's look at it side by side.  

01:28:37.423 --> 01:28:44.143
and the 2.0     2.0 score.  The 
difference is 60K.  But the 

01:28:44.144 --> 01:28:47.412
image metric is so nice that you
 can see very small changes in 

01:28:47.413 --> 01:28:51.768
the 2.0     2.0 version.  This 
is blown up on a screen and the 

01:28:51.769 --> 01:28:54.545
life stream                 the 
live stream.  But you don't 

01:28:55.178 --> 01:28:57.291
          you don't have to 
choose one image compression 

01:28:57.292 --> 01:28:59.838
quality for everything.  You can
 actually dynamically choose 

01:28:59.839 --> 01:29:01.839
this and move 

01:29:05.019 --> 01:29:06.083
on.  
Beyond that, there are a couple 

01:29:06.084 --> 01:29:11.682
things you could do by hand.  
JPEG has the same problem, file 

01:29:11.836 --> 01:29:18.152
save as from Photoshop, 11K for 
that 16 by 16 pixel block.  11K.

01:29:22.631 --> 01:29:24.344
  Oh, are you really sure your 
designers aren't        aren't 

01:29:24.345 --> 01:29:27.399
doing that?  Are you really 
sure?  Think about it.  Maybe 

01:29:27.400 --> 01:29:33.578
send a text real quick.  Yeah?  
Save as gets us to 1.1K.  Still,

01:29:35.265 --> 01:29:37.589
 that's a 16 pixel by 16 pixel 
image.  The funny thing is you 

01:29:37.590 --> 01:29:41.047
want to know what's        
what's going on here?  Extra 

01:29:41.048 --> 01:29:49.810
data, met     , metadata.  They 
have the ability to add block. 

01:29:52.953 --> 01:29:55.098
 When I take a picture of the 
gator, this is how my image 

01:29:55.747 --> 01:29:57.349
service knows where I'm 
standing.  They have this 

01:29:57.350 --> 01:30:00.585
location base     -based 
information.  That bloats your 

01:30:00.586 --> 01:30:02.919
image.  If you're not properly 
removing this stuff as an image 

01:30:02.920 --> 01:30:05.066
serving application, that means 
every other user who is 

01:30:05.067 --> 01:30:08.669
downloading it is grabbing this 
extra bloated data.  Obviously, 

01:30:08.670 --> 01:30:11.044
that's not a good idea.    
So let's talk about that's 

01:30:11.045 --> 01:30:14.357
obviously block removal.  But 
there are a bunch of other 

01:30:14.358 --> 01:30:19.505
places we can optimize.  We can 
change the down sampling, the 

01:30:19.506 --> 01:30:24.543
DCT coefficients are handles d, 
improve the way we quantize, 

01:30:24.544 --> 01:30:26.457
great news, folks, you don't 
have the                    you 

01:30:26.458 --> 01:30:29.693
don't got to worry about any of 
that, everybody's  's got it 

01:30:29.694 --> 01:30:32.814
solved.  Google brings you a 
pretty good handfuls of 

01:30:32.815 --> 01:30:35.561
algorithms and tools you can put
 right in your tool chain.    

01:30:35.562 --> 01:30:39.230
The first thing JPEG ^ minute I 
^ mini and      

01:30:40.333 --> 01:30:42.846
               mini and M   M az
      M az, they'll did he great

01:30:43.015 --> 01:30:46.147
 the image quality of your image
 to get you just a little bit 

01:30:46.148 --> 01:30:49.013
farther and a little bit more 
savings.  On the other two, JPEG

01:30:50.711 --> 01:30:55.873
 and pack JPEG are lossless.  
You'll see the coding stages so 

01:30:55.874 --> 01:30:58.935
you don't           you don't 
actually lose any bits.  Pack 

01:30:58.936 --> 01:31:03.029
JPEG works as a most        a 
post-format than anything, 

01:31:03.030 --> 01:31:05.545
encode it in its own format and 
getting         get it even 

01:31:05.879 --> 01:31:07.963
smaller than that.  You've got a
 lot of web solutions you can 

01:31:07.964 --> 01:31:11.155
find, too, where you up 
hoe        upload to some API or

01:31:11.398 --> 01:31:13.270
 some service and do everything 
on the back end and scented it 

01:31:13.271 --> 01:31:16.090
to you                       and
 send it to you.  I don't care 

01:31:16.341 --> 01:31:19.334
what you use.  Pick one.  
Don't       Don't let your 

01:31:19.335 --> 01:31:23.031
designers use save as from 
Photoshop.  Pick one, test it 

01:31:23.032 --> 01:31:25.520
out, send me a tweet and let me 
know how it happened.    

01:31:25.521 --> 01:31:27.949
One thing, though, I got to say 
this one is really tool to do

01:31:28.424 --> 01:31:30.920
       to do pie           to do
 by hound.  I'll try to go 

01:31:30.921 --> 01:31:31.760
through this fast.  Hand     
                                         and.

01:31:31.761 --> 01:31:33.527
  I'll try to go through this 
fast. .  Two images             

01:31:33.528 --> 01:31:36.472
 Two images 175, told           
175, cold           175, colt 

01:31:36.473 --> 01:31:41.462
modified, 82K.  The first thing 
JPEG does is split your image 

01:31:41.463 --> 01:31:44.464
into a different color spice, 
because the human eye is more 

01:31:44.465 --> 01:31:48.279
perspective to some         
            perceptible to some 

01:31:48.280 --> 01:31:51.812
loose than others.  We put it in
 lab color mode.  We check the 

01:31:51.813 --> 01:31:54.871
areas of high contrast inside of
 the AB channels, and we 

01:31:54.872 --> 01:31:58.366
actually just go file blur.  
What we're doing here is we're 

01:31:58.367 --> 01:32:02.083
actually reducing the number of 
unique colors, the amount of 

01:32:02.084 --> 01:32:07.878
noise in these chroma channels 
so that when the JPEG c   cod

01:32:08.069 --> 01:32:10.601
     codic       codic comes 
back through, there's 

01:32:10.602 --> 01:32:12.037
list              there's less 
information you have to find 

01:32:12.038 --> 01:32:14.328
unique and you'll get better 
compression as a result.  This 

01:32:14.329 --> 01:32:18.087
simple technique, going through 
hand optimizing this stuff can 

01:32:18.088 --> 01:32:22.293
save you 50% savings on a file. 
 That's -- if you're still 

01:32:22.294 --> 01:32:26.095
serving a million files a day, 
that's huge.    

01:32:26.096 --> 01:32:31.144
All right.  Let's get to the 
final one here.  WANs of web 

01:32:31.235 --> 01:32:35.016
             .  Fans of web P?
(Applause)  

01:32:35.017 --> 01:32:40.959
Web P, I got to say, is as 
impressive as JPEG is, web P is 

01:32:40.960 --> 01:32:42.960
in its 

01:32:46.925 --> 01:32:47.097
own league     

01:32:47.098 --> 01:32:47.298
                    WEBP?
(Applause)

01:32:47.299 --> 01:32:51.099
WEBP, I got to say, is as 
impressive as JPEG is, WEBP is 

01:32:47.299 --> 01:32:49.533
in its own league.  You've got a
 whole sweet of algorithms that 

01:32:49.534 --> 01:32:54.301
applies so it can keep up with 
the loss compression that JPEG 

01:32:54.302 --> 01:33:02.575
does.  It's got the whole sprays
 just like PNG.  It has some L

01:33:03.665 --> 01:33:06.364
C77 and dictionary encoding.  
The result is pretty simple.  

01:33:06.365 --> 01:33:08.595
Across the board all of these 
open at this me says     

01:33:09.338 --> 01:33:12.206
             timizations and 
technique make it competitive 

01:33:12.207 --> 01:33:15.050
with both appointing and JPEG 
everywhere, and it supports all 

01:33:15.260 --> 01:33:17.987
of these features as well.  In 
most of the time it's actually 

01:33:18.273 --> 01:33:23.873
winning, if you check that out. 
 You get more features in those 

01:33:23.991 --> 01:33:27.749
file sizes and supported 
natively on Android.  Round of 

01:33:27.750 --> 01:33:29.750
applause for that.

01:33:37.556 --> 01:33:39.556
Let's get real.  Round of 
applause for getting real

01:33:43.050 --> 01:33:46.688
?  Weird event applause request 
ever.  If there is one thing you

01:33:46.689 --> 01:33:50.739
 remember, some bald guy got on 
the stage at Google I/O, trying 

01:33:50.740 --> 01:33:53.970
to get out of the sun and he 
yelled at me for an hour, but I 

01:33:53.971 --> 01:33:56.761
remembered one thing.  One thing
.  This is all I'm asking you to

01:33:56.762 --> 01:34:01.836
 remember, that's it.  Nothing 
else.  Just this   

01:34:01.837 --> 01:34:04.381
When you're choosing what kind 
of image to make, the decision 

01:34:04.671 --> 01:34:06.303
on the format is super 
important.  The first thing you 

01:34:06.304 --> 01:34:10.144
have to ask yourself is can this
 image be a vector drobble.  If 

01:34:10.145 --> 01:34:13.830
yes, make it a vector tribal
        drobble.  Easy, go to 

01:34:13.831 --> 01:34:18.318
lunch.  Ask yourself do I 
support WEBP.  If yes, make it a

01:34:18.319 --> 01:34:22.939
 WEBP, go to lunch.  You're done
 for the day.  Goon      Bonus, 

01:34:23.067 --> 01:34:25.800
sweet.  If you don't           
you don't support WEBP, does it 

01:34:25.801 --> 01:34:28.995
need transparency.  If yes, you 
obviously got to use appointing 

01:34:28.996 --> 01:34:34.051
for that.  If               
               use PNG for that.

01:34:34.052 --> 01:34:37.726
  In areas of very self-similar 
pixels, the more photo realistic

01:34:38.269 --> 01:34:41.927
 an image, the worst PNG is 
gonna compress it.  The more 

01:34:42.444 --> 01:34:44.701
simple an image, the better it 
will compress it.  If it's 

01:34:44.702 --> 01:34:51.762
complexion, we'll go to temp 
   JPEG.  If we end up at pn, 

01:34:51.763 --> 01:34:57.668
run a tool on it, and hand 
optimize for hero assets.  For 

01:34:57.669 --> 01:35:00.969
JPEG, correct the tool, hand 
optimize where 

01:35:09.494 --> 01:35:12.725
you can.  You can get this later
.  Put your phones down, you're 

01:35:12.726 --> 01:35:18.371
good.  I'm flattered that you're
 taking a picture of me, but I 

01:35:18.372 --> 01:35:20.107
can pose.  Anyone want a picture
 with the pose?  Oh, some of 

01:35:20.108 --> 01:35:24.253
them.  
(Laughter)   

01:35:24.254 --> 01:35:28.499
Awesome.  You'd be over here?  
Okay.  We got to get back to the

01:35:29.189 --> 01:35:31.952
 AV people are getting mad at me
.  Most importantly, though, 

01:35:31.953 --> 01:35:36.769
this one simple thing.  Profile 
your code.  Profile your code.  

01:35:36.770 --> 01:35:39.304
Profile your code.  Before you 
make any decisions, before you 

01:35:39.545 --> 01:35:41.856
make any performance changes, 
before you change your format, 

01:35:41.857 --> 01:35:46.440
before you put bits on the wire 
that your users are going to 

01:35:46.441 --> 01:35:50.969
have to pay to download.  
Profile it.  Make a decision 

01:35:50.970 --> 01:35:55.052
based upon evidence and data and
 the best thing for your users. 

01:35:55.363 --> 01:35:58.745
 Do not go laysly into 
these                      go 

01:35:59.084 --> 01:36:01.771
lazy ily into these decisions, 
because the people that love you

01:36:01.948 --> 01:36:06.590
 and your applications.  Profile
 it.  In some cases, JPEG's  's 

01:36:06.591 --> 01:36:09.021
going to be better than PNG.  In
 some cases WebP will be the 

01:36:09.022 --> 01:36:11.466
best option.  In some cases it 
will load too slow and you'll 

01:36:11.467 --> 01:36:16.059
want to use a JPEG.  In every 
single situation, profile your 

01:36:16.060 --> 01:36:18.060
code.  Find

01:36:20.217 --> 01:36:22.217
 the sweet spot.  Optimize for 
your users in every case.    

01:36:22.295 --> 01:36:24.643
And thank you, thank you, thank 
you so much for coming to this 

01:36:24.644 --> 01:36:31.148
session.  My name is coal    
Coal McKinley.

01:37:09.039 --> 01:37:11.772
            le McKinley. 
        Anlis.  

01:37:09.039 --> 01:37:11.039
&gt;&gt;

01:37:23.918 --> 01:37:25.321
 Testify ^ did he have ^ 
definite purchase amphetamine a 

01:37:25.322 --> 01:37:27.052
definite P 
you                      

01:37:29.685 --> 01:37:31.685
  Purchase amphetamine a 
definite P are you in I in      

01:44:38.744 --> 01:44:47.388
 and fast    Fast:  Put your    
Your app   App on 

01:44:49.870 --> 01:44:51.870
a diet    Diet

01:47:05.101 --> 01:47:09.661
 Wojtek       .   
Wojtek Kalicinski

01:54:28.282 --> 01:54:33.175
&gt;&gt; Cosm                         

01:56:43.454 --> 01:56:44.540
. 
&gt;&gt; Hi, everyone.  Please settle 

01:56:44.541 --> 01:56:47.493
down.  Nice to see a full room. 
 I wonder if it's because of the

01:56:47.759 --> 01:56:51.057
 heat outside or are you -- do 
you care about application sizes

01:56:51.312 --> 01:56:54.932
?  Who cares about application 
sizes?  Raise your hands?

01:56:54.933 --> 01:56:57.837
(Applause)  
Anyone who doesn't care?  Yeah? 

01:56:58.067 --> 01:57:02.323
 Okay.  Great.  Well, I hope I'm
 going to assume that it's 

01:57:02.324 --> 01:57:05.912
really important to do       to 
do that.  And I also hope that 

01:57:05.913 --> 01:57:08.676
you especially will go to the 
session tomorrow that

01:57:12.634 --> 01:57:15.096
 I encourage you to all go and 
see others talk about billing 

01:57:15.097 --> 01:57:17.914
for billions.  They're going 
tell you all about billing apps 

01:57:17.915 --> 01:57:21.242
that will work great on all 
kinds of devices for all kinds 

01:57:21.836 --> 01:57:25.732
of markets.  But today we're 
going to concentrate on app size

01:57:26.306 --> 01:57:30.678
s.  You know, if you think why 
is it important anyway?  Why 

01:57:30.679 --> 01:57:34.519
should I care about app size?  
What is app size anyway?  

01:57:34.520 --> 01:57:39.898
First of all, think about this: 
 We're here in the U.S. where 

01:57:40.533 --> 01:57:44.873
there's wifi on every corner in 
every coffee shop.  We have all 

01:57:45.694 --> 01:57:47.936
those all you can eat data plans
.  We can down loathe 

01:57:48.095 --> 01:57:50.791
            download as much as 
we want.  I want you to remember

01:57:50.792 --> 01:57:55.552
 there are parts of the world 
where people don't              

01:57:55.553 --> 01:57:59.326
people actually pay for every 
megabyte they download.  It's 

01:57:59.327 --> 01:58:01.561
not easy to install apps and 
keep them updated.  It should 

01:58:01.722 --> 01:58:07.202
matter to you as developers that
 people install your apps, for 

01:58:07.203 --> 01:58:11.071
one, and keep them updated.  And
 the other important thing is 

01:58:11.818 --> 01:58:16.099
that people's phones not always 
have 16 gigs, 32 gigs of memory.

01:58:16.100 --> 01:58:23.111
  So they just kind can't keep 
all the apps they would want to 

01:58:23.112 --> 01:58:26.492
install that they would want.  
If you want users to actually 

01:58:26.493 --> 01:58:29.906
use your apps, maybe you will 
help them by keeping your app a 

01:58:29.907 --> 01:58:33.378
little bit smaller so they will 
be              they will be 

01:58:33.379 --> 01:58:35.379
encouraged to leave your 
appraisal loan and not uni

01:58:35.865 --> 01:58:39.538
nstall                      
            app alone and not 

01:58:39.706 --> 01:58:42.256
uninstall it.    
I talked with lots of developers

01:58:42.550 --> 01:58:46.131
.  I asked a simple question:  
How big is your app?  I wonder 

01:58:46.132 --> 01:58:49.325
if I ask you, just think in your
 head, how big is your app?  Can

01:58:49.326 --> 01:58:54.640
 you answer that in five seconds
?  And if you thought a number, 

01:58:54.641 --> 01:58:58.704
I'm pretty sure you thought of 
the raw APK size.  So this is 

01:58:58.705 --> 01:59:01.395
the file that is produced by 
Android studio      Studio.  How

01:59:01.396 --> 01:59:05.309
 many people thought about that?
  Yeah, lots of people.  And 

01:59:05.310 --> 01:59:09.173
that's correct.  It's a correct 
answer.  It's technically 

01:59:09.174 --> 01:59:11.959
correct.  The best kind of 
correct.  But application size 

01:59:12.802 --> 01:59:17.096
is not about the file on your 
computer.  The user doesn't 

01:59:17.097 --> 01:59:19.961
really interact with the file on
 your hard drive that Android 

01:59:19.962 --> 01:59:24.324
studio      Studio produces.  So
 the important -- the other 

01:59:24.325 --> 01:59:26.325
important sizes we can talk 
about is

01:59:29.298 --> 01:59:30.844
 the download size.  Again, if 
I'm on not a very good network 

01:59:30.845 --> 01:59:33.640
connection, if I have to pay for
 the data that I use, before 

01:59:33.641 --> 01:59:38.798
downloading an app I have to 
actually look and think, can I 

01:59:38.799 --> 01:59:42.889
afford downloading this app?  
Can I app           Can I afford

01:59:42.890 --> 01:59:46.509
 downloading this much megabytes
 to download it?  It's not the 

01:59:47.327 --> 01:59:49.844
same as APK size   
Then there is install size.  

01:59:49.845 --> 01:59:53.895
Like I mentioned, the other 
important metric is how much 

01:59:53.896 --> 01:59:58.519
space users actually have on 
their devices how much space 

01:59:58.520 --> 02:00:03.441
your apple actually             
   app will actually take off.  

02:00:03.442 --> 02:00:06.750
Not just the APK size nor the 
download size.  I'll tell you 

02:00:06.751 --> 02:00:09.395
why in a sec          in a sec. 

02:00:09.396 --> 02:00:14.605
Third of all, the up date     
    update size.  You may think 

02:00:14.606 --> 02:00:17.386
people download APK, they get a 
new APK, so it must be 

02:00:17.650 --> 02:00:20.171
           it must be the same 
as the download size only with 

02:00:20.172 --> 02:00:23.934
new APK.  That's also not true. 
 Then there is other metrics 

02:00:23.935 --> 02:00:27.433
which are really, really 
important, like ram footprint, 

02:00:27.434 --> 02:00:31.666
how many memory your app uses, 
how many methods are in your 

02:00:31.667 --> 02:00:34.570
app.  That's really important 
for, like, if you have to use  

02:00:36.926 --> 02:00:40.372
   use probably lots and lots of
 other metrics for app size.  

02:00:40.373 --> 02:00:42.748
We're not really going to 
take      talk about those.  

02:00:42.749 --> 02:00:46.178
We'll concentrate on APK size 
and the four metrics I mentioned

02:00:48.828 --> 02:00:50.863
 in the beginning.    
So before we start, before we 

02:00:51.058 --> 02:00:56.335
start talk about            
talking about how to optimize 

02:00:56.336 --> 02:00:58.404
for all those four scenarios, 
for APK size, download size, and

02:00:58.579 --> 02:01:02.640
 so on, just a quick -- let's 
look at the internal what's     

02:01:03.295 --> 02:01:07.194
   what's actually in an APK so 
that we can talk about what we 

02:01:07.195 --> 02:01:12.810
can do with it and what we 
cannot do.    

02:01:12.811 --> 02:01:15.603
And an APK is really just an 
archive.  You probably all know 

02:01:15.604 --> 02:01:19.708
that.  If you hand pack it to a 
folder or inspect it in an 

02:01:19.709 --> 02:01:22.998
archive viewer, first of all, 
you will find the application 

02:01:22.999 --> 02:01:30.092
code.  So there's byte code, the
 d   deck file, more if you're 

02:01:30.093 --> 02:01:34.724
using multidecks.  That's all 
your code or what you imported 

02:01:35.162 --> 02:01:38.295
and so on.  There is also native
 code.  So native library 

02:01:38.296 --> 02:01:44.468
compiled for specific CPU 
architecture or ABI that resides

02:01:45.619 --> 02:01:49.945
 in the libs folders.  If you 
need SO files and so on and so 

02:01:49.946 --> 02:01:56.888
on.    
Then resources, a resources are 

02:01:56.889 --> 02:02:00.346
really divided into two 
categories.  In the r   res 

02:02:00.347 --> 02:02:02.588
folder we have all kinds of 
resources like 

02:02:02.839 --> 02:02:06.912
tribal      drobbles, PNG, JPEG 
files, layouts and so on and so 

02:02:06.913 --> 02:02:12.662
on.  And there is also another 
file, resources. .ar rsc   rsc, 

02:02:12.663 --> 02:02:15.592
which contains most of these 
files, identifiers, and strings.

02:02:15.593 --> 02:02:18.946
  Also, this file can get pretty
 big.  So we'll talk about how 

02:02:18.947 --> 02:02:24.471
to reduce that side as well.  
There is all kinds of 

02:02:24.472 --> 02:02:28.369
miscellaneous stuff like other 
assets, like you put any file 

02:02:28.370 --> 02:02:31.982
that you use as a binary stream,
 anything that's not an droid 

02:02:31.983 --> 02:02:36.727
resource.  So if you want to 
have a thumb bundle with your 

02:02:36.728 --> 02:02:40.386
app or game data and textures, 
you put it in assets and you can

02:02:40.387 --> 02:02:44.907
 open it up later in your app   
Then there is the meta folder.  

02:02:44.908 --> 02:02:48.747
This contains the apps APK 
signature.  I'll talk about that

02:02:49.185 --> 02:02:53.035
 in the next slide.    
Then trece the Androidmanifest. 

02:02:53.647 --> 02:02:58.061
 When you work in Android Studio
 and actually compile your map, 

02:02:58.062 --> 02:03:00.120
Android Studio gets all the 
pieces of information from all 

02:03:00.121 --> 02:03:03.671
the libraries you use, from your
 own app, and it creates this 

02:03:03.672 --> 02:03:10.969
combined merged Androidmanifest 
XML that puts it in the APK    

02:03:11.588 --> 02:03:14.457
is if you actually do what I 
said and extract the APK and try

02:03:14.796 --> 02:03:18.607
 to inspect this file, you'll 
find that it's in another format

02:03:18.775 --> 02:03:23.824
, in a binary, compressed format
.  So you will not be able to 

02:03:24.715 --> 02:03:26.023
inspect it easily.  And I will 
talk about how to do       to do

02:03:26.024 --> 02:03:30.002
 that in a sec          in a 
sec.    

02:03:30.003 --> 02:03:35.937
So APK, there is a folder that 
contains the cryptographic 

02:03:36.520 --> 02:03:39.183
signature for your APK.  We all 
know that's important so that 

02:03:39.184 --> 02:03:41.945
Android can verify that the app 
was produced by you, comes from 

02:03:42.301 --> 02:03:48.398
you, it's gonna install it 
securely.  And how APK signing 

02:03:48.399 --> 02:03:53.709
in V1 works.  The important part
 to know here Android actually, 

02:03:53.957 --> 02:04:00.668
 went very fine.  It goes file 
by file, but on every file in 

02:04:00.669 --> 02:04:03.130
your archive, and actually 
decompresses the file, then goes

02:04:03.131 --> 02:04:06.338
 over the full file contents, 
checks it against the signature,

02:04:06.549 --> 02:04:11.150
 and if it matches, then the 
signature verifies it's correct.

02:04:13.939 --> 02:04:15.939
thing that we can do about this

02:04:18.375 --> 02:04:20.375
 changing compression 

02:04:22.609 --> 02:04:24.964
filed.  You can actually change 
compression on the file inside 

02:04:24.965 --> 02:04:29.762
the archive and that will not 
invalidate the signature.  

02:04:30.071 --> 02:04:31.895
Another thing that's        
that's useful to know is that 

02:04:31.896 --> 02:04:34.741
removing any files is not 
allowed.  So if you remove a 

02:04:34.742 --> 02:04:39.979
file, you will have to resign 
your app.  After making any 

02:04:39.980 --> 02:04:44.551
changes to the archive, to the 
APK, remember that you have to 

02:04:44.552 --> 02:04:49.257
run sip         run zip align 
after any change.  If you change

02:04:49.413 --> 02:04:54.830
 something, sign the image, sign
 the APK, then you have to run 

02:04:55.040 --> 02:04:59.658
the zip line.    
We have this new APK signing 

02:05:00.842 --> 02:05:04.749
versions 2 on Android M that 
changes things a little bit.  It

02:05:04.750 --> 02:05:08.723
 makes it a bit more difficult 
or let's say impossible to 

02:05:08.945 --> 02:05:14.575
actually change anything inside 
the archive.  It's more secure. 

02:05:15.347 --> 02:05:18.897
 His signature is am body      
putted over                   is

02:05:19.164 --> 02:05:23.041
 computed over all the contents 
of the APK.  It's dependent 

02:05:23.042 --> 02:05:25.669
towards the end of the zip 
archive.  Not exactly the end of

02:05:25.670 --> 02:05:29.036
 the file, but just before the 
zip archive central directory.  

02:05:30.451 --> 02:05:32.451
allowed

02:05:33.462 --> 02:05:35.618
.  And what's        what's more
 zip line has              zip 

02:05:35.619 --> 02:05:39.331
align has to be run before the 
V2 signing.  That complicates 

02:05:39.493 --> 02:05:45.153
things a little bit.  Potential 
           .  Fortunately, 

02:05:45.154 --> 02:05:46.378
Android Studio has made some 
improvements.  I'm going to tell

02:05:46.379 --> 02:05:48.379
 you why.

02:05:55.488 --> 02:06:00.688
                                         Zipalign
 has to be run before the V2 

02:05:55.488 --> 02:05:58.754
signing.  That complicates 
things a little bit.  

02:05:55.488 --> 02:05:59.554
Fortunately, Android Studio has 
made some improvements.  I'm 

02:05:55.488 --> 02:05:57.605
going to tell you why.  What can
 you do to make your APK smaller

02:05:58.409 --> 02:05:59.917
?  I think it's important to 
understand those things, to 

02:05:59.918 --> 02:06:02.855
understand the role of every 
file in this archive.  For 

02:06:02.856 --> 02:06:08.678
example, I said that resources 
get pretty big.  So lots of 

02:06:09.360 --> 02:06:11.786
developers noticed that.  They 
noticed that this file in their 

02:06:11.787 --> 02:06:16.642
app takes even ten megabytes, 15
 megabytes.  They also noticed 

02:06:17.275 --> 02:06:20.962
that it's uncompressed.  So if 
you create an APK in Android 

02:06:20.963 --> 02:06:23.183
Studio and you look at the 
compression level of all the 

02:06:23.184 --> 02:06:26.710
files, you will see that this 
file is actually uncompressed.  

02:06:26.711 --> 02:06:29.754
So why does it waste all this 
space?  I said it mostly 

02:06:29.755 --> 02:06:32.849
contains strings; right?  So 
text is compress I believe.   

02:06:33.091 --> 02:06:37.074
                    compressible
.  Many developers use this, 

02:06:37.075 --> 02:06:41.147
they go and compress this file, 
and problem fixed.  APK is 

02:06:41.148 --> 02:06:46.048
smaller.  But what I want you to
 understand from this talk, and 

02:06:46.049 --> 02:06:50.508
bring the take away there this 
talking is some optimizations 

02:06:50.509 --> 02:06:53.403
are counterintuitive.  Not 
always reducing          

02:06:53.404 --> 02:06:57.349
reducing APK size will help in 
the long run.  For example, in 

02:06:57.350 --> 02:07:00.046
this case compressing resources 
ARC is actually a very good idea

02:07:00.176 --> 02:07:04.982
.  You should leave it as is.  
It's optimized for run time for 

02:07:04.983 --> 02:07:09.570
running your app, the framework 
can actually memory map the file

02:07:09.678 --> 02:07:13.101
.  It doesn't have to decompress
 it when you launch your app.  

02:07:13.102 --> 02:07:17.177
Even worse, if the launcher has 
to read something from this file

02:07:17.405 --> 02:07:19.817
 from your app and the launcher 
has to read your application 

02:07:19.818 --> 02:07:23.574
name, if this file were compress
 the, then just to show your the

02:07:24.000 --> 02:07:26.000
                          just 
to show your app name the 

02:07:26.024 --> 02:07:26.715
                                   ,
 just to show your app name next

02:07:26.716 --> 02:07:30.036
 to your icon, it would have to 
be decompressed into memory.  

02:07:30.037 --> 02:07:31.322
That's one thing you shouldn't
           shouldn't do, even 

02:07:31.323 --> 02:07:35.074
though you can.    
And we're going to talk about 

02:07:35.075 --> 02:07:40.713
all these stages and what magic 
things happened that make it so 

02:07:40.714 --> 02:07:44.599
that download size is not always
 the same as raw APK size and so

02:07:44.752 --> 02:07:51.152
 on.  So, for example, a 
compressed version of your APK, 

02:07:51.672 --> 02:07:54.318
so in case of this example of 
the resources file, even though 

02:07:54.443 --> 02:07:57.991
we keep it uncompressed, when 
it's actually sent to user's  's

02:07:57.992 --> 02:08:02.090
 devices, it will compress the 
APK beforehand so we don't      

02:08:02.091 --> 02:08:05.128
 don't lose any bandwidth.  We 
don't       don't lose any bytes

02:08:05.129 --> 02:08:07.976
 over the network.  That's good.
  The only thing is when 

02:08:07.977 --> 02:08:12.988
installed on the device, the 
file will take up more space on 

02:08:12.989 --> 02:08:16.618
the drive.  Like I said, that's 
actually working as intended

02:08:22.948 --> 02:08:25.194
.    
Also around the install time, 

02:08:25.195 --> 02:08:28.782
first of all, remember how I was
 talking about the signatures 

02:08:28.783 --> 02:08:31.538
and so.  You can't change 
anything inside the archive.  

02:08:31.539 --> 02:08:35.893
And so because of that, whatever
 you install non     an app, the

02:08:36.458 --> 02:08:38.283
 first ask the most important 
part of what's        what's 

02:08:38.284 --> 02:08:41.617
taking up space on the device 
will be the raw APK itself.  We 

02:08:41.618 --> 02:08:44.591
cannot change it.  Even if it 
contains resources for other 

02:08:44.592 --> 02:08:48.828
devices for devices with 
different screen densities, 

02:08:48.829 --> 02:08:51.874
different CPU architecture, 
there is nothing we can do about

02:08:52.482 --> 02:08:55.188
 it on the device, because we 
have to keep the significant 

02:08:56.380 --> 02:08:58.545
intact.    
So a little bit of space wasted.

02:08:58.546 --> 02:09:06.014
  We can remedy that later.  
Then there was a thing that we 

02:09:06.015 --> 02:09:08.369
introduced in lollipop and that 
was the new run time called

02:09:11.570 --> 02:09:17.599
 -- it introduced head of time 
come spacing.  Whenever you 

02:09:17.600 --> 02:09:21.781
installed the APK, it would take
 the index byte code and compile

02:09:21.782 --> 02:09:25.261
 it down into native code and 
store that on your user petition

02:09:25.549 --> 02:09:31.876
.  Again, this takes up space.  
This is a derivative of how big 

02:09:31.877 --> 02:09:34.639
your code is.  The bigger your 
code is, the bigger the compiled

02:09:36.334 --> 02:09:38.285
 code will be.                 
code will be.  So another thing 

02:09:38.286 --> 02:09:43.983
to be mindful about, one note 
with M, we're getting rid of the

02:09:43.984 --> 02:09:49.718
 ahead of time compilation, so 
let's say not a concern as much 

02:09:49.978 --> 02:09:54.050
on end devices and going forward

02:09:54.051 --> 02:09:57.249
Finally, one curious thing.  If 
you have any native libraries in

02:09:57.250 --> 02:10:00.252
 your APK, they will actually 
get uncompressed.  Again, on the

02:10:00.253 --> 02:10:06.466
 user petition and will take up 
space on the user petition.  

02:10:06.467 --> 02:10:10.967
Android can actually load them, 
access them with better 

02:10:10.968 --> 02:10:16.818
performance.  Even though we 
uncompress the native libraries,

02:10:16.819 --> 02:10:20.155
 they take up more space.  We 
cannot remove them from the APK,

02:10:20.417 --> 02:10:23.262
 so that's space wasted.  
Fortunately, started with mash

02:10:23.468 --> 02:10:25.809
      marshmallow 
          Marshmallow and above,

02:10:25.992 --> 02:10:27.271
 we can remedy that.  That will 
be              That will be one

02:10:27.272 --> 02:10:29.888
 of the techniques we'll talk 
about later.    

02:10:29.889 --> 02:10:33.368
Then there's things that 
happened as well in runtime.  If

02:10:33.596 --> 02:10:38.248
 a user looks up the application
 size in settings and looks at 

02:10:38.249 --> 02:10:41.437
the how app size is not just the
 things I mentioned, it's also 

02:10:41.668 --> 02:10:46.465
everything you create during run
time.  Databases, cached images,

02:10:46.662 --> 02:10:50.170
 anything you download from the 
Internet or generate locally.  

02:10:50.171 --> 02:10:52.556
We're not going to cover that as
 much, but remember this is a 

02:10:52.557 --> 02:10:56.109
very important part to think 
about, too.    

02:10:56.110 --> 02:10:58.922
And finally, update size.  Why 
is the update size different 

02:10:58.923 --> 02:11:02.869
than the download size?  Well, I
 don't know if you're aware, but

02:11:02.870 --> 02:11:08.369
 for many years now play store
          Play Store          P

02:11:08.732 --> 02:11:09.759
lay Store has been done         
               Play Store has 

02:11:09.760 --> 02:11:12.497
been downloading patches.  How 
it works is, first of all, when 

02:11:12.498 --> 02:11:16.079
a developer up loads a new APK 
on the Play Store, Play Store 

02:11:16.080 --> 02:11:19.399
will compute the difference or 
the delta between the old APK 

02:11:19.709 --> 02:11:25.424
and the new APK.  Just basically
 a binary differences.  Uses an 

02:11:25.425 --> 02:11:30.390
algorithm to figure out which 
bytes are similar and only 

02:11:30.391 --> 02:11:33.238
certain bytes over the network. 
 Then the delta can be        

02:11:33.239 --> 02:11:35.239
can be additionally compressed

02:11:36.763 --> 02:11:39.524
.  Finally, the client downloads
 the difference, the delta file,

02:11:39.702 --> 02:11:44.208
 and reconstructs the new APK on
 the device.  The final result 

02:11:44.209 --> 02:11:48.415
is as if the user had the whole 
new APK, the new signature and 

02:11:48.416 --> 02:11:50.416
everything, but it's just 
reconstructed on the device from

02:11:50.679 --> 02:11:53.688
 this patch file.    
One thing we've been a little 

02:11:53.689 --> 02:11:58.582
bit vague about, like I said 
uses algorithm and can be       

02:11:58.583 --> 02:12:02.252
 can be compressed and so on.  
We're really telling you what 

02:12:02.253 --> 02:12:05.372
kind of algorithms play    Play 
uses for that.  There was a 

02:12:05.373 --> 02:12:08.155
reason for that.  So the Play 
Store team always wants to 

02:12:08.156 --> 02:12:10.741
improve on that.  They've been 
experience            

02:12:10.742 --> 02:12:13.126
experimenting a lot and it 
wouldn't make any sense to give 

02:12:13.127 --> 02:12:15.946
out this information and then it
 would change the next day.  

02:12:16.118 --> 02:12:20.607
But, actually, let me talk a 
little bit about the most recent

02:12:20.608 --> 02:12:25.068
 play    Play improvements on 
that field.  We have a new 

02:12:25.069 --> 02:12:27.069
algorithm.  We are using

02:12:29.655 --> 02:12:32.057
 VFDIF for the deltas.  We have 
seen major improvements for 

02:12:32.058 --> 02:12:36.617
reducing this delta size.  
For example, a major update to 

02:12:36.618 --> 02:12:41.622
chrome,         chrome camp    
         chrome      Chrome, 

02:12:41.623 --> 02:12:46.992
like from a certain version to 
newer one used to take 22 megs 

02:12:47.894 --> 02:12:49.923
or almost 23 megs on the 
previous algorithms.  With the 

02:12:50.346 --> 02:12:54.055
new one it's down to 13 megs    
megs.  With a minor update, the 

02:12:54.056 --> 02:12:58.047
difference is a little bit, 
again, from 15 megs to 3 megs.  

02:12:58.048 --> 02:13:04.244
Imagine instead of downloading a
 whole tens of megabytes, whole 

02:13:04.245 --> 02:13:06.894
package of Chrome, you download 
only three megs to have a new 

02:13:06.895 --> 02:13:10.052
version installed on your device
.    

02:13:10.053 --> 02:13:13.910
From other news, we've also 
introduced patching and 

02:13:13.911 --> 02:13:15.911
compression for the

02:13:19.189 --> 02:13:20.775
 APK compression files.  That's 
mostly used for games, but it's 

02:13:20.776 --> 02:13:23.710
super important.  That's because
 games usually have lots of at 

02:13:23.711 --> 02:13:25.660
the accident                 at 
the accident tours        

02:13:25.661 --> 02:13:29.361
                  of text you're
                of textures.  It

02:13:29.362 --> 02:13:32.492
 can be a gigabyte in size.  
From version to version you have

02:13:32.684 --> 02:13:36.447
 to download over and over and 
over a gig, a gig, a gig.  Lots 

02:13:36.448 --> 02:13:42.027
of bandwidth wasted.  We are now
 saying over a peta byte of debt

02:13:43.870 --> 02:13:48.531
         of data thanks to that 

02:13:48.532 --> 02:13:50.258
I can talk to the developers 
about that.  You will be        

02:13:50.259 --> 02:13:52.763
     You will be happy you have 
smaller update sizes, but what's

02:13:53.042 --> 02:13:54.993
        what's really important 
is to show the benefits to users

02:13:54.994 --> 02:13:56.994
. 

02:13:59.510 --> 02:14:03.125
 Play Store will show download 
size instead of APK size.  In 

02:14:03.126 --> 02:14:06.604
the case of an update, users 
will only see the update size.  

02:14:06.605 --> 02:14:08.851
Users will be more happy.  They 
will see the benefits of all 

02:14:08.852 --> 02:14:14.153
your hard work of all the work 
of the Play Store People     

02:14:17.327 --> 02:14:20.241
   people do.  It's great.    
Play Store is just one component

02:14:20.437 --> 02:14:24.531
.  They can only do so much on 
the server side, especially with

02:14:24.532 --> 02:14:28.952
 the signing that has to be left
 intact.  So we also have some 

02:14:28.953 --> 02:14:32.294
improvements in Android Studio 
2.    2.2, which is          , 

02:14:32.295 --> 02:14:35.344
which is out in preview now.  So
 they have been working on the 

02:14:35.345 --> 02:14:39.360
whole packaging subsystem and 
optimizing it to create APK 

02:14:39.361 --> 02:14:43.547
files that are actually better 
for computing those delta 

02:14:43.548 --> 02:14:47.233
updates.  First of all, they 
started searching files in the 

02:14:47.408 --> 02:14:49.006
archive so that things don't    
   don't move around a bit, 

02:14:49.007 --> 02:14:52.655
because then the algorithm -- 
the delta algorithms get 

02:14:52.656 --> 02:14:57.689
confused and can figure out the 
most app at this                

02:14:58.149 --> 02:15:02.650
  most optimal solutions.  They 
zero out timestamps and use less

02:15:02.820 --> 02:15:05.188
 space and comments and so on.  
Finally, they're introducing the

02:15:05.431 --> 02:15:10.943
 option to store uncompressed 
native codes.  So SO files.    

02:15:11.142 --> 02:15:13.676
I already told you about that.  
I will get to that later in the 

02:15:13.677 --> 02:15:15.677
presentation

02:15:17.592 --> 02:15:20.342
.    
So what you can do, if you want 

02:15:20.343 --> 02:15:25.584
to actually measure -- if your 
efforts of what Android Studio 

02:15:25.585 --> 02:15:29.499
is doing any good for your 
update size.  I'm happy to say 

02:15:29.500 --> 02:15:33.620
we finally released a tool that 
will help you estimate and let 

02:15:33.621 --> 02:15:38.164
me stress that estimate the 
update size.  Again, there may 

02:15:38.165 --> 02:15:40.634
be    be new algorithms.  There 
may be experiments that are 

02:15:40.635 --> 02:15:44.104
going on.  But this will give 
you a good estimate on the 

02:15:44.105 --> 02:15:48.435
current algorithms and how they 
work for your APK.  Basically 

02:15:48.436 --> 02:15:51.116
you're running against an old 
APK, new APK, you see the size 

02:15:51.239 --> 02:15:55.577
difference, and you can see if 
any changes you make make sense 

02:15:55.578 --> 02:15:57.578
for that

02:15:59.054 --> 02:16:00.790
.    
So now moving on to the second 

02:16:00.791 --> 02:16:05.935
section, which is kind of like a
 tips recipe how to make your 

02:16:05.936 --> 02:16:11.539
APK smaller.  Let's go through 
some of those things.  First of 

02:16:11.540 --> 02:16:16.889
all, how many of you had red my 
articles on medium on keeping 

02:16:16.890 --> 02:16:19.934
APK size low?  Some of you.  
Okay.  Let me first explain one 

02:16:19.935 --> 02:16:25.783
point of contention about using 
compression for the People APK. 

02:16:25.784 --> 02:16:28.420
 In the articled s I actually 
wrote people      

02:16:28.610 --> 02:16:33.876
                                              APK.
  In the articles I actually 

02:16:28.610 --> 02:16:32.387
wrote you can reduce the size of
 APK by using better compression

02:16:32.388 --> 02:16:36.949
 method, Zopply, completed    
    reated by Google engineers. 

02:16:37.886 --> 02:16:44.107
 It did -- Zopfli.  Nothing much
 changes for users.  They were 

02:16:44.108 --> 02:16:46.108
decompressed just as fast

02:16:50.132 --> 02:16:54.383
.  Currently we advise against 
using so fly      Zopfli for APK

02:16:54.683 --> 02:16:58.462
.  Some users wrote to me that 
certain versions of Android 

02:16:58.463 --> 02:17:00.463
might

02:17:01.705 --> 02:17:06.961
 have had a problem with Zopfli 
compressed APK, they threw an 

02:17:06.962 --> 02:17:08.522
exception.  That's one thing.   

02:17:08.523 --> 02:17:10.791
Another thing is they take an 
awful lot of time to compress on

02:17:11.196 --> 02:17:13.688
 your computer.  You 
don't           You don't make a

02:17:13.689 --> 02:17:16.496
 release every five minutes, so 
it's not that big of a deal, but

02:17:16.668 --> 02:17:19.608
 the next thing is really, 
really important.  So like I 

02:17:19.609 --> 02:17:22.924
said, the Play Store team likes 
experimenting with stuff.  

02:17:22.925 --> 02:17:28.406
Actually, using Zopfli, because 
it's so rehearse 

02:17:28.407 --> 02:17:30.853
inventive,                     
resource inventive, it might 

02:17:30.854 --> 02:17:36.268
actually in the future make new 
kinds of differential updates 

02:17:36.269 --> 02:17:40.157
impossible.    
So if you read my articles, if 

02:17:40.847 --> 02:17:43.168
you weren go              you 
were thinking of using Zopfli, 

02:17:43.169 --> 02:17:45.366
forget about it.  Just don't 
      don't.  Especially since 

02:17:45.591 --> 02:17:49.436
the new packaging system in 
Android Studio constitutional 

02:17:49.437 --> 02:17:52.582
experiments with come pretty    
         compressing files in 

02:17:52.583 --> 02:17:55.009
your archives, and the best use 
of the compression for the 

02:17:55.010 --> 02:18:01.070
files.  So that's also something
 you in Android Studio 2.    2.2

02:18:03.588 --> 02:18:06.730
have been to the session just 
before?  Cole's  's session just

02:18:06.731 --> 02:18:09.712
 before?    
So I'm just going to do a quick 

02:18:09.713 --> 02:18:13.753
recap.  Remember that you can 
always pre-op at this myself 

02:18:14.086 --> 02:18:18.573
your images                
                   preoptimize 

02:18:18.574 --> 02:18:22.306
your images.  In our build tools
 don't always do the best job of

02:18:22.415 --> 02:18:25.199
 figuring out the best 
compression for images, the best

02:18:25.751 --> 02:18:29.798
 optimization they can make.  
You are free to use external 

02:18:29.799 --> 02:18:34.496
tools to preprocess images in 
your drobble folders.  They 

02:18:34.497 --> 02:18:37.816
might be a lot more      more 
for that.  Just remember that 

02:18:37.817 --> 02:18:44.141
you used to have to add these 
lines to your bill patrol grade 

02:18:44.269 --> 02:18:51.827
                  bill.gr radle.
  It had its own optimizer that 

02:18:51.828 --> 02:18:53.828
if you preprocess an image

02:18:56.789 --> 02:18:59.348
 then they could actually make 
it a little bit bigger.  So

02:19:06.456 --> 02:19:16.122
                                                                                                            awable
 folders.  They might be a lot 

02:19:06.456 --> 02:19:10.389
more for that.  Just remember 
that you used to have to add 

02:19:06.456 --> 02:19:10.722
these lines to your bill.gradle.
  It had its own optimizer that 

02:19:06.456 --> 02:19:10.589
if you preprocess an image then 
they could actually make it a 

02:19:06.456 --> 02:19:11.179
little bit bigger.  So.    I'm 
happy to say I've talked to the 

02:19:11.180 --> 02:19:14.174
people at Android Studio.  They 
promised me this will be fixed 

02:19:14.175 --> 02:19:19.069
for Android 2.    2.2.  So you 
will -- the build tools will be 

02:19:19.070 --> 02:19:20.744
smart enough to figure that out 

02:19:20.745 --> 02:19:22.745
One very easy

02:19:28.488 --> 02:19:34.668
 win you can have is so fly    
       is so fly.  It's okay to 

02:19:34.669 --> 02:19:40.793
use images.  You can use it for 
files.  It's completely the same

02:19:40.940 --> 02:19:44.908
.  The images look the same.  
They work as fast and it's an 

02:19:44.909 --> 02:19:46.909
easy win for a file size

02:19:49.913 --> 02:19:53.527
.    
WebP is another image format 

02:19:53.528 --> 02:19:57.548
developed at Google, gives about
 30% more images        image 

02:19:57.549 --> 02:20:05.365
sizes than jngs.              
than JPEGs.  Support for WebP 

02:20:05.366 --> 02:20:13.399
was supported in Android 4.0    
 4.0, but only to replace JPEGs 

02:20:13.400 --> 02:20:16.935
for PNG images with no 
transparency.  Only Android 4.

02:20:17.359 --> 02:20:21.826
    4.2.      4.2.4.        
4.2.4.12 had new formats 

02:20:21.827 --> 02:20:23.750
including lossless and 
transparent.    

02:20:23.751 --> 02:20:27.497
Then you can replace all your 
PNGs.    

02:20:27.498 --> 02:20:30.475
Also, remember to use the server
 side.  This is really the 

02:20:30.476 --> 02:20:36.379
biggest win.  If you're 
uploading a lot of images, if 

02:20:36.380 --> 02:20:39.201
you know it's on Android, your 
server can generate WebP instead

02:20:39.642 --> 02:20:44.074
 of jng JPEG             of JPEG
s.  You will save a lot of space

02:20:44.424 --> 02:20:46.424
 on the device if you cache 
those images

02:20:49.641 --> 02:20:51.321
.    
If you can, on Android 5.0     

02:20:51.322 --> 02:20:55.304
5.0, of course           , of 
course, use vector drobbles.  

02:20:55.305 --> 02:20:58.980
Compresses very about       well
.  It's just amazing for icons

02:21:06.458 --> 02:21:09.667
 previous         .  Previous 
versions before 5.0     5.0, you

02:21:09.668 --> 02:21:13.849
 can use vector drobbles.  
Sometimes in an void            

02:21:13.850 --> 02:21:15.850
in Android Studio

02:21:21.138 --> 02:21:25.265
 and you add them to these 
studio, during your building APK

02:21:25.478 --> 02:21:29.059
, it will generate those PNGs 
for you, for those older devices

02:21:29.388 --> 02:21:36.876
 who kind of use vector draw 
some able     able              

02:21:36.877 --> 02:21:42.034
 drawable.    
After that we got vector 

02:21:42.035 --> 02:21:44.035
drawable

02:21:59.374 --> 02:22:10.307
                                                                                                                              awables.
  Sometimes in Android Studio 

02:21:59.374 --> 02:22:03.040
and you add them to these 
studio, during your building 

02:21:59.374 --> 02:22:03.240
APK, it will generate those PNGs
 for you, for those older 

02:21:59.374 --> 02:22:02.174
devices who kind of use vector 
drawable.  

02:21:59.374 --> 02:22:00.653
After that we got vector 
drawable.  There is more on to 

02:22:00.654 --> 02:22:04.885
it.  I suggest you go to Chris 
bang    Bang's

02:22:09.120 --> 02:22:13.321
  's seminar.    
Vector drawable are great.  You 

02:22:13.322 --> 02:22:18.525
can do lots of complex shapes in
 vehicler drawables           

02:22:18.685 --> 02:22:21.428
            in vector drawables,
 but they're not always

02:22:26.125 --> 02:22:28.343
 usable.  They're great for 
simple shapes like button back

02:22:28.514 --> 02:22:33.192
      backgrounds, borders, 
gradients, superoptimized.  If 

02:22:33.193 --> 02:22:37.052
you can use a shape drawable, 
please do.  

02:22:37.053 --> 02:22:41.969
This was a quick recap of what 
Cole was talking about an hour 

02:22:42.977 --> 02:22:46.227
ago here on the stage.  Since 
everything is recorded, I 

02:22:46.228 --> 02:22:48.893
encourage you who haven't been 
able to attend the session or 

02:22:48.894 --> 02:22:51.328
those of you watching online to 
go ahead and check out this 

02:22:51.329 --> 02:22:53.639
session on image compression.   

02:22:53.640 --> 02:22:59.335
So that's what we can do for the
 resources.  But what about 

02:22:59.336 --> 02:23:01.336
code?  Really, with your code,

02:23:05.918 --> 02:23:09.984
 with the size of your code, 
there's one thing I want to tell

02:23:05.918 --> 02:23:10.046
 you.  Use proceed guard.      
                Use pro guard.  

02:23:10.047 --> 02:23:14.716
You will hate it, but use it.  
It's very easy to add to your 

02:23:14.717 --> 02:23:16.717
build grade he will file and 
then things will break

02:23:21.057 --> 02:23:21.983
 file and then things will 
break.  There is a new way of 

02:23:21.984 --> 02:23:28.257
using the built-in ^ sling ^ 
shrink                shrinker, 

02:23:30.087 --> 02:23:33.484
it enables pro Garrod           
 pro guard and you can use pro 

02:23:33.485 --> 02:23:37.183
guard false, but it will do not 
all the things that pro guard 

02:23:37.184 --> 02:23:41.965
does, but it removes classes.  
It doesn't obfuscate, but anyway

02:23:42.432 --> 02:23:45.019
, whichever option you decide to
 use, you don't           you 

02:23:45.020 --> 02:23:47.802
don't have this notion of pro 
guard configuration files

02:23:54.903 --> 02:24:08.769
                                                                                                                                                                        Proguard
 and you can use Proguard false,

02:23:54.903 --> 02:23:58.836
 but it will do not all the 
things that Proguard does, but 

02:23:54.903 --> 02:23:59.169
it removes classes.  It doesn't 
obfuscate, but anyway, whichever

02:23:54.903 --> 02:23:58.703
 option you decide to use, you 
don't have this notion of 

02:23:54.903 --> 02:23:57.163
Proguard configuration files 
files.  In the Android app, for 

02:23:57.164 --> 02:24:00.049
example, the built in          
built in Proguard file already

02:24:03.146 --> 02:24:06.114
 has rules that keep all the 
setters and getters on your 

02:24:06.115 --> 02:24:09.601
views for the animation work.  
Otherwise they will be 

02:24:10.168 --> 02:24:12.545
             they will be 
optimized away and your apple 

02:24:12.546 --> 02:24:18.303
break.  If                      
 your apple break.             

02:24:19.243 --> 02:24:22.836
   app will break.  In your 
build folders in the Android 

02:24:22.837 --> 02:24:29.931
Studio there is an generated 
file by AAPT.  It looks at your 

02:24:30.452 --> 02:24:32.736
Androidmanifest.  It generates 
rules for your activities, for 

02:24:32.737 --> 02:24:35.093
your views that you are using in
 the layouts.  Again, by looking

02:24:35.485 --> 02:24:40.085
 at those and by looking at the 
default Proguard file you can 

02:24:40.086 --> 02:24:42.086
learn a lot and start writing 
your own

02:24:44.720 --> 02:24:46.957
.    
And there's also another easy 

02:24:46.958 --> 02:24:50.916
way.  If you know you're doing 
something in your code that will

02:24:50.917 --> 02:24:52.321
 People        be 
                  code that will

02:24:52.322 --> 02:24:56.364
 be optimized because you 
accessed it, reflection, use the

02:24:56.950 --> 02:25:00.698
 new build tools, Proguard will 
leave it as it is.  Will      It

02:25:00.699 --> 02:25:04.793
 will not be removed from your 
code.    

02:25:04.794 --> 02:25:07.886
If you're writing libraries,  
for other users or just 

02:25:07.887 --> 02:25:11.302
libraries that are components in
 your app, sometimes those 

02:25:11.303 --> 02:25:16.497
libraries just need their own 
proceed             own Proguard

02:25:16.950 --> 02:25:19.223
 rules so when someone uses them
 they don't       don't break 

02:25:19.224 --> 02:25:22.373
the app.  Be a good citizen.  If
 you're writing a library, if it

02:25:22.374 --> 02:25:26.094
 needs Proguard, you can put 
your own Proguard consideration 

02:25:26.095 --> 02:25:28.953
in your library, and anyone who 
imports it, it will just work. 

02:25:36.637 --> 02:25:38.522
can't always remove code because
 you don't           you don't 

02:25:38.523 --> 02:25:42.580
need it.  So sometimes you 
actually need the things you're 

02:25:42.581 --> 02:25:45.948
adding to your project, but it's
 not easy to keep track of all 

02:25:45.949 --> 02:25:48.713
the libraries that bring in 
other libraries and other 

02:25:48.714 --> 02:25:57.149
libraries and so on.  So we call
 these trance        transitive 

02:25:57.505 --> 02:26:01.668
dependencies.  If you bring one 
to your gradle file, it may 

02:26:01.669 --> 02:26:05.421
bring in lots of those 
transitive dependencies.  There 

02:26:05.422 --> 02:26:09.158
is a code command line for 
gradle that will let you see a 

02:26:09.159 --> 02:26:13.419
tree of all those dependencies 
you bring in.  Here the only 

02:26:13.420 --> 02:26:16.217
other devices, just be aware of 
what you're using and what kind 

02:26:16.218 --> 02:26:18.992
of libraries you're pulling in, 
and make the right decisions by 

02:26:18.993 --> 02:26:24.984
looking at this.    
And if you're still not sure if 

02:26:24.985 --> 02:26:28.537
what's        what's inside your
 APK, what kind of classes 

02:26:28.538 --> 02:26:31.895
finally make it through the 
Proguard, through the 

02:26:31.896 --> 02:26:34.510
optimizations, through pulling 
in other libraries, there is a 

02:26:34.511 --> 02:26:39.021
tool that we open sourced 
recently called classy      

02:26:39.435 --> 02:26:44.403
Classy shark     Shark.  It's 
basically an APK file.  It will 

02:26:44.404 --> 02:26:47.868
show you all the packages, it 
will do grade          do great 

02:26:47.869 --> 02:26:52.296
for debugging Proguard if you 
enable it for your app.  Let me 

02:26:52.297 --> 02:26:54.790
tell you.  I really encourage 
you to try it.    

02:26:54.791 --> 02:27:01.647
So we have Proguard for byte 
coat.  But if you go through 

02:27:01.648 --> 02:27:05.460
this pain of enabling Proguard, 
you actually get one more very 

02:27:05.461 --> 02:27:10.002
important thing.  And that's the
 resource shrinker.  Once you 

02:27:10.003 --> 02:27:13.397
have Proguard enabled you'll get
 another option called shinning

02:27:13.608 --> 02:27:16.283
          shrink resources and 
it will figure out which 

02:27:16.284 --> 02:27:20.796
resources in your app are 
actually elevens         

02:27:20.797 --> 02:27:25.153
referenced from the code that's 
left after Proguard runs its 

02:27:25.154 --> 02:27:32.410
course.  And it can remove any 
resource that is unused in your 

02:27:32.411 --> 02:27:36.946
code, which is pretty awesome.  
Again, it has a consideration

02:27:37.754 --> 02:27:39.393
                 a 
consideration, so you can add 

02:27:39.394 --> 02:27:44.005
this, really, on any resource 
file or any XML resource in your

02:27:44.006 --> 02:27:49.877
 resource folder.  Just add this
 tools keep or tools discard 

02:27:49.878 --> 02:27:54.012
attributes and you can make sure
 that if there are resources 

02:27:54.013 --> 02:27:58.175
that you want to have in your 
APK, or if you explicitly want 

02:27:58.176 --> 02:28:01.121
to remove something from your 
APK, that's where you 

02:28:04.623 --> 02:28:07.756
configure it.    
So a little bit like Proguard 

02:28:04.623 --> 02:28:08.468
rules only for resources.    
Then sometimes it happens that 

02:28:08.469 --> 02:28:12.641
if you pull in a library, even 
like Google play services

02:28:13.223 --> 02:28:13.698
             Play 
Services                    Google

02:28:13.699 --> 02:28:16.007
 Play Services, or support 
library, we offer 

02:28:19.773 --> 02:28:21.982
translation for many languages. 
 What if you just need for one 

02:28:21.983 --> 02:28:23.983
language or two languages.  If 
you know there will be   

02:28:24.315 --> 02:28:25.920
            there will be no 
users of your app or that you 

02:28:25.921 --> 02:28:28.978
don't           you don't manage
 translations for other 

02:28:28.979 --> 02:28:30.348
languages, then you don't
           you don't really need

02:28:30.349 --> 02:28:34.009
 all those resources from those 
other libraries, like the 

02:28:34.010 --> 02:28:36.010
support library for all those 
other languages that you

02:28:42.840 --> 02:28:44.079
 do not support.    
So just use r   res and put the 

02:28:44.080 --> 02:28:46.582
languages in the example that 
you want to make it into your 

02:28:46.583 --> 02:28:50.816
APK and the rest will be simply 
removed.  One side note here, 

02:28:50.817 --> 02:28:55.465
there's allotted of        
             there's a lot of 

02:28:55.466 --> 02:28:59.796
tips about using this for 
stripping resources for other 

02:28:59.797 --> 02:29:04.308
densities.  That was supported a
 long time ago in ancient versus

02:29:04.309 --> 02:29:07.922
 of our gradle plug-in.  You 
can't really specify many 

02:29:07.923 --> 02:29:10.204
densities here.  So don't       
don't use this for densities 

02:29:10.205 --> 02:29:12.205
unless you specify only

02:29:16.994 --> 02:29:18.636
 one.  
That he is very advance usage. 

02:29:23.485 --> 02:29:27.686
We have resources, but there is 
one very, very advance technique

02:29:27.687 --> 02:29:30.622
 that probably not many people 
are aware of.  That's the 

02:29:30.623 --> 02:29:33.933
problem of sparse resource could
 not figures    s   

02:29:34.095 --> 02:29:38.037
                      resource 
con figures                     

02:29:38.038 --> 02:29:41.405
 resource configs, if you know 
your resource is bloated and 

02:29:41.406 --> 02:29:43.496
very big, you don't           
you don't know why.  It's worth 

02:29:43.497 --> 02:29:47.136
trying to gig out if maybe that 
is your problem figure     

02:29:47.784 --> 02:29:52.584
                                       figure
 out if maybe that is your 

02:29:47.784 --> 02:29:50.890
problem.  It's not very simple. 
 So I'm not going to teach up 

02:29:50.891 --> 02:29:54.809
how resources file format works,
 but let me he will         tell

02:29:54.944 --> 02:29:58.995
 you this is a big over
simplification.  Hopefully it 

02:29:58.996 --> 02:30:02.358
will get the point across.  
Imagine you have an app that has

02:30:02.987 --> 02:30:05.857
 five strings.  The strings are 
in the spring        string 

02:30:05.858 --> 02:30:13.225
pool.  They take up some memory.
  You have your default config. 

02:30:20.992 --> 02:30:25.219
 you get a new string.  This new
 feature only works for version 

02:30:25.220 --> 02:30:29.580
21 and above.  So you have a 
config.  You create a new folder

02:30:30.173 --> 02:30:35.505
 under your resource with v   
v21.  You're just switching this

02:30:35.959 --> 02:30:39.586
 feature to new feature in that 
config.  Well, it shouldn't 

02:30:40.066 --> 02:30:41.782
             it should take up 
space for only one string; 

02:30:41.783 --> 02:30:45.502
right?  But it actually has to 
keep no industries on all the 

02:30:45.503 --> 02:30:48.225
positions for other strings that
 you're not using in this config

02:30:48.571 --> 02:30:51.911
.  So you lose a lot of space.  
It still takes up a lot of space

02:30:52.090 --> 02:30:57.789
, even highway you're just using
 though        

02:30:58.625 --> 02:31:08.491
                                                                                                                   ^
  in this config.  So you lose a

02:30:58.625 --> 02:31:02.758
 lot of space.  It still takes 
up a lot of space, even though 

02:30:58.625 --> 02:31:03.574
you're just.  These bytes, who 
cares about bytes, but if you 

02:31:03.575 --> 02:31:07.226
have an app that has 3,000 
strings, if you have 50 

02:31:07.227 --> 02:31:09.653
transformations and there is a 
lot of apps, like among the top 

02:31:09.654 --> 02:31:12.642
100 apps in the Play Store, I'm 
sure lots of them have even more

02:31:12.643 --> 02:31:18.454
 than that.    
The cost of adding a single 

02:31:18.455 --> 02:31:23.044
string for v       for v21, for 
example, that's translated for 

02:31:23.045 --> 02:31:26.082
50 languages would give you     
you 600     600 kill owe mites

02:31:26.823 --> 02:31:30.713
     bytes.  That's something we
 can work 

02:31:34.779 --> 02:31:35.447
with 
                                              o

02:31:35.448 --> 02:31:36.798
 bytes.  That's something we can
 work with.  You can shrink your

02:31:36.799 --> 02:31:39.636
 file a lot.  How do you know 
you're doing this?  It's not 

02:31:40.022 --> 02:31:43.698
very easy to guess which strings
 do I remove.  We recently open 

02:31:43.699 --> 02:31:49.296
sourced a tool called ARC blamer
      Blamer.  It's on Git hub. 

02:31:50.287 --> 02:31:54.097
 I'll post those later.  Don't
       Don't worry             

02:31:54.098 --> 02:31:56.257
Don't on the spaces for this 
talk.  It's a command line tool.

02:31:56.420 --> 02:32:01.808
  You run your APK through it 
and you get a CSV file.  You 

02:32:02.152 --> 02:32:07.677
upload to sheets or some other 
program for that.  It gives you 

02:32:07.678 --> 02:32:10.048
have this kind of nice overview 
of where the resources are in 

02:32:10.049 --> 02:32:16.704
your application.    
And if you sort that by the no 

02:32:16.705 --> 02:32:21.421
entries column, then you can 
find which configs are the most 

02:32:21.422 --> 02:32:26.474
sparse in your app.  Which 
configs waste the most space?  

02:32:26.475 --> 02:32:30.473
In this example, if you look at 
the rightmost column, I can 

02:32:30.474 --> 02:32:34.136
identify that the string that's 
called apps list, you know, it's

02:32:34.137 --> 02:32:42.363
 wasting almost 200 kilobytes in
 my app.  200 kilobytes is not a

02:32:42.364 --> 02:32:48.623
 lot, but if I remove this one, 
I'm saving one meg bite for this

02:32:49.190 --> 02:32:52.655
 file.                    yte 
for this file.  And you can 

02:32:52.656 --> 02:32:55.120
remove a lot of unneeded data 
from your resources

02:32:58.196 --> 02:33:00.140
.  Some of our apps remove two 
and a half megs by just removing

02:33:00.141 --> 02:33:05.657
 three strings.  So that's 
pretty big savings.    

02:33:05.658 --> 02:33:09.374
So there's that.  Let me just 
say that it really works for 

02:33:09.375 --> 02:33:12.647
only big apps.  If your app is 
not really huge with lots of 

02:33:12.648 --> 02:33:15.117
configurations and so on, then 
probably you won't get anything 

02:33:15.118 --> 02:33:18.405
from that.    
Finally, getting to the native 

02:33:18.406 --> 02:33:20.406
libraries that I mentioned so

02:33:22.503 --> 02:33:25.097
 many times already.  So since 
Android 6.0     6.0 

02:33:25.098 --> 02:33:27.195
marshmallow             
Marshmallow, we have this 

02:33:27.196 --> 02:33:29.531
attribute that you can add on 
the application tag

02:33:33.836 --> 02:33:36.776
 in your manifest.  Basically 
what it does

02:33:41.047 --> 02:33:41.681
, it instructs the package 
install the system, to not copy 

02:33:41.682 --> 02:33:44.827
out those SO files, the native 
libraries, at installation from 

02:33:45.593 --> 02:33:47.522
your APK.  And the other thing 
is things just work.  So if 

02:33:47.523 --> 02:33:49.905
you're us go system load library
, you don't           you don't 

02:33:49.906 --> 02:33:53.883
have to think about it.  The APK
 -- the SO files will just stay 

02:33:53.884 --> 02:33:57.710
inside the APK.  They will just 
work.  You don't           You 

02:33:57.711 --> 02:34:01.256
don't waste this space that's 
used for decompressing them 

02:34:01.257 --> 02:34:03.693
somewhere on the user partition.

02:34:03.694 --> 02:34:08.401
But there are conditions.  For 
this to work, the SO files have 

02:34:08.402 --> 02:34:11.358
to be uncompressed in your APK. 
 And the other thing is they 

02:34:11.359 --> 02:34:14.355
must be         must be 
correctly page aligned using 

02:34:15.010 --> 02:34:17.548
Zipalign.  So up until now there
 was no easy way to do       to 

02:34:17.549 --> 02:34:20.628
do that using Android Studio in 
our tools.  It was just not 

02:34:20.629 --> 02:34:23.772
supported.  You have to go in 
manually decome brews those 

02:34:23.773 --> 02:34:30.286
files                      c
ompress those files.  2.    2.2 

02:34:30.287 --> 02:34:33.022
does that automatically.  You 
can enable this option in the 

02:34:33.023 --> 02:34:36.187
Android manifest and see big 
gains.    

02:34:36.188 --> 02:34:39.582
If you're worried that having an
 uncompressed SO file will just 

02:34:39.583 --> 02:34:44.225
bloat your APK, will make it 
really big, that's true.  Raw 

02:34:44.226 --> 02:34:47.433
APK size will go up a lit       
a bit.  Remember Play Store 

02:34:47.434 --> 02:34:50.829
compresses data anyway.  The 
download size will not suffer.  

02:34:50.830 --> 02:34:56.045
The delta sizes will actually be
 smaller.  That's because the 

02:34:56.046 --> 02:35:01.301
algorithm will be able to figure
 out smaller algorithms for unc

02:35:02.147 --> 02:35:04.147
ompressed delta files.  We can 
live with that

02:35:06.768 --> 02:35:10.794
.    
Then I mentioned before that 

02:35:11.052 --> 02:35:14.047
there's not much we can do on 
the device with resources that 

02:35:14.048 --> 02:35:21.606
are not targeted at your, let's 
say, screen density.  If you 

02:35:21.607 --> 02:35:23.607
produce a fat APK, if the 
resources are

02:35:27.767 --> 02:35:28.164
 all there, there's not much we 
can do about that, unless you 

02:35:28.165 --> 02:35:32.998
actually split your APK into 
many small APKs targeted at 

02:35:33.649 --> 02:35:36.310
those devices.  Android Studio 
supports two kinds of -- 

02:35:36.311 --> 02:35:40.297
producing two kinds of split APK
s.  One of them is density based

02:35:40.778 --> 02:35:42.778
.  You can actually during your 
compilation

02:35:45.472 --> 02:35:48.651
 get smaller files with 
resources targeted at specific 

02:35:48.652 --> 02:35:51.303
screen densities.  Then you can 
then upload to Play Store and 

02:35:51.541 --> 02:35:55.532
use the multiAPK feature to 
serve them only to serve devices

02:35:56.301 --> 02:35:59.941
.    
And then there is the ABI-based 

02:35:59.942 --> 02:36:03.260
multi APK.  If you have native 
lines       libraries for all 

02:36:03.261 --> 02:36:06.049
kinds of CPU architecture, it 
will be            it will be 

02:36:06.050 --> 02:36:08.644
really big portion of your APK. 
 Second, you can split those.  

02:36:08.957 --> 02:36:12.621
You can have multiple APKs.  You
 can upload top Play Store,  

02:36:12.746 --> 02:36:15.283
                      upload to 
Play Store, and users with 

02:36:15.284 --> 02:36:20.087
devices and certain CPR will get
 only this file that's suited 

02:36:20.088 --> 02:36:23.332
for their device.    
The only thing you have to 

02:36:23.333 --> 02:36:26.400
remember is every APK has to 
have a different version code.  

02:36:26.401 --> 02:36:29.197
So there is some scripts that 
you need to add to your build 

02:36:29.198 --> 02:36:32.376
APK to make that work.  I 
real        I really encourage 

02:36:32.614 --> 02:36:34.881
you to go and see my articles on
 medium      Medium where I have

02:36:37.031 --> 02:36:40.574
 the message snippets.  There is
 no time today on this session 

02:36:40.575 --> 02:36:42.575
to go through all the code 
variance 

02:36:46.784 --> 02:36:49.023
for that.    
Example density split savings, I

02:36:49.024 --> 02:36:52.111
 took a toe peek a sample    
                        I took a

02:36:52.112 --> 02:36:56.240
 Topeka sample app.  It's heavy.
  The original fat APK was three

02:36:56.241 --> 02:37:00.346
 and a half megs.  If I split 
that to different densities, 

02:37:00.347 --> 02:37:02.347
it's almost two and a half meg 
savings for everyone

02:37:07.517 --> 02:37:09.830
.    
Then you can do custom APK.  You

02:37:09.831 --> 02:37:11.831
 can 

02:37:13.280 --> 02:37:16.839
split things by versions.  If 
you have some features that only

02:37:16.840 --> 02:37:18.233
 work for 21 and and a half,
                        for 21 

02:37:18.234 --> 02:37:22.188
and above, maybe it's time to 
start thinking about splitting 

02:37:22.189 --> 02:37:24.285
those up.  It's paralegal      
          It's pretty advanced 

02:37:24.286 --> 02:37:26.617
stuff.  Not even wants to do 
      to do that.  Then for 

02:37:26.618 --> 02:37:29.484
games, you split by texture 
formats.  You don't           

02:37:29.485 --> 02:37:31.452
You don't have to ship         
               You don't have to

02:37:31.453 --> 02:37:34.442
 shift all textures to every 
device.  You can recreate 

02:37:34.443 --> 02:37:40.600
density and API splits using 
variance in Android Studio and 

02:37:40.601 --> 02:37:44.399
customize it even more.  Then 
for games most people will use 

02:37:44.400 --> 02:37:48.335
APK expansion files to put all 
the stuff you can put in an APK 

02:37:48.336 --> 02:37:51.810
to separate file to download it 
from Android Studio.    

02:37:51.811 --> 02:37:53.673
They are            
Here senior an example of this 

02:37:53.674 --> 02:37:58.654
time, of a build gradle file 
that will recreates the splits 

02:37:58.655 --> 02:38:03.291
using APK.  Again, I encourage 
you to look at my mediumcal   

02:38:03.995 --> 02:38:08.291
      Medium articles.  This 
will be explained there better. 

02:38:10.881 --> 02:38:15.090
  Go through the tools that we 
have.  Since we have only three 

02:38:15.091 --> 02:38:17.598
minutes left, let meTest just.  
Testing. mention  Testing.  

02:38:17.599 --> 02:38:19.939
Testing that some of the tools 
YouTube that I mentioned during.

02:38:19.955 --> 02:38:24.144
   this talk, we are actually 
building those into Android 

02:38:24.145 --> 02:38:28.809
Studio.  So you might have heard
 the keynote.  There is a new 

02:38:28.810 --> 02:38:32.387
APK appealer in Android Studio. 
 I'm happy to say you will be

02:38:32.563 --> 02:38:34.563
             you will be able to
 download that now and

02:38:37.962 --> 02:38:39.962
 play with it.  What this actual
 does, it shows you

02:38:42.622 --> 02:38:45.950
 the compressed sizes of every 
resource inside craver APK    

02:38:46.045 --> 02:38:52.023
               inside your APK. 
 In your dex files, you can 

02:38:52.024 --> 02:38:55.234
browse and resources a little 
bit like 

02:38:59.645 --> 02:39:01.934
ARC blamer.  Then you can also 
look at Androidmanifest.xml as 

02:39:01.935 --> 02:39:05.547
it is in this form compressed in
 the APK.  So I keen        I 

02:39:05.548 --> 02:39:08.333
encourage you to try it.  It's 
an early preview.  If you have 

02:39:08.334 --> 02:39:12.589
any feedback, if you think you 
will find some feature that's 

02:39:12.590 --> 02:39:16.410
missing use physical         
     useful, please contact us 

02:39:16.411 --> 02:39:18.411
and I'm happy to

02:39:20.117 --> 02:39:20.291
 hear feedback.    
So thank you very much.  And I 

02:39:20.292 --> 02:39:22.981
will be           I will be open
 to questions.

02:45:02.546 --> 02:45:06.085
  May 18, 2016.

02:47:07.055 --> 02:47:13.420
PL9.
Raiders of the Lost App:  How to

02:50:54.530 --> 02:50:56.530
  (

02:51:10.098 --> 02:51:15.808
(Standing by for the session to 
begin)

02:51:45.225 --> 02:51:47.225
)

02:51:58.498 --> 02:52:00.719
..

02:55:14.239 --> 02:55:15.605
&gt;&gt; 
&gt;&gt; 

02:55:15.606 --> 02:55:16.799
&gt;&gt; 
&gt;&gt; 

02:55:16.800 --> 02:55:17.885
&gt;&gt; 
&gt;&gt; 

02:55:17.886 --> 02:55:19.202
&gt;&gt; 
&gt;&gt; 

02:55:19.203 --> 02:55:23.477
&gt;&gt; 
PL9.

02:55:23.524 --> 02:55:24.985
Raiders of the Lost App:  How to

02:55:24.986 --> 02:55:28.089
get discovered on Google Play.

02:56:29.096 --> 02:56:31.604
(Standing by for the sessions to

02:56:31.605 --> 02:56:33.612
begin)

02:56:39.369 --> 02:56:41.369
.
(music)

02:56:51.704 --> 02:56:54.114
.
&gt;&gt; Hi, everyone, I'm Kobi, a 

02:56:54.115 --> 02:56:57.805
product manager on Google Play.
&gt;&gt; And I'm Milena, an 

02:56:57.806 --> 02:57:01.621
engineering manager on Google 
Play.  We work on the apps 

02:57:01.622 --> 02:57:03.589
developer team in London.  Today

02:57:03.590 --> 02:57:05.971
we're here to tell you how you 
can set your app for success 

02:57:05.972 --> 02:57:08.252
using some of the tools we 
provide in Google Play Developer

02:57:11.403 --> 02:57:13.131
and tell you how some developers

02:57:13.132 --> 02:57:15.628
are using these services to have

02:57:15.629 --> 02:57:20.510
success on Play.
&gt;&gt; The vision of our team is to 

02:57:20.511 --> 02:57:23.350
build powerful publishing tools 
allowing you to launch and 

02:57:23.351 --> 02:57:26.712
iterate.  We believe that the 
experimentation is the key to 

02:57:26.713 --> 02:57:29.231
success.  Throughout this 
presentation, you'll see a lot 

02:57:29.232 --> 02:57:35.552
of developer feedback and we'll 
start with the feedback we have 

02:57:35.553 --> 02:57:43.720
from Michael Ritter about why 
they released are genius and 

02:57:43.721 --> 02:57:47.192
Gems first.  Quick publisher 
time on Google Play is the key. 

02:57:49.581 --> 02:57:52.850
at the time.  Rapid iteration 
and experimentation is the key 

02:57:52.851 --> 02:57:58.063
to success.  Our power users of 
tools like Beta test and go 

02:57:58.064 --> 02:57:59.283
store listing experiments, we'll

02:57:59.284 --> 02:58:01.994
show you how other developers 
are using these tools and share 

02:58:01.995 --> 02:58:08.882
some best practices.  SGN user 
tools and then they utilize 

02:58:08.883 --> 02:58:12.121
their finding across platforms, 
this leads to a much more 

02:58:12.122 --> 02:58:14.723
efficient soft launch process.  
Soft launching is a great way to

02:58:16.679 --> 02:58:19.853
deliver value to your users.  As

02:58:19.854 --> 02:58:22.224
a result, their worldwide launch

02:58:22.225 --> 02:58:25.715
was much more successful and 
this is exactly what we have in 

02:58:25.716 --> 02:58:28.760
mind when we're building these 
tools for you.  Our goal is to 

02:58:28.761 --> 02:58:33.042
help you experiment launch and 
iterate fast

02:58:36.728 --> 02:58:39.126
.
&gt;&gt; We got similar feedback from 

02:58:39.127 --> 02:58:43.588
creators of ball and challenge, 
they soft launch on Android 

02:58:43.593 --> 02:58:46.752
first because it allows them to 
iterate faster and launch to a 

02:58:46.753 --> 02:58:49.791
better way.  This is exactly 
music to our ears, exactly the 

02:58:49.792 --> 02:58:53.142
feedback we like to hear and a 
practice we would like to 

02:58:53.143 --> 02:58:55.438
encourage.
&gt;&gt; So what are we going to talk 

02:58:55.439 --> 02:58:57.390
about?
&gt;&gt; So we are going to start by 

02:58:57.391 --> 02:59:00.425
talking about Beta testing and 
some of the improvements we are 

02:59:00.426 --> 02:59:04.583
making to this service to make 
it even easier to run large Beta

02:59:06.102 --> 02:59:10.552
from your users.  Then we'll 
talk about the best way to roll 

02:59:10.553 --> 02:59:13.807
out these rapid changes in a 
safe and controlled fashion.  

02:59:13.808 --> 02:59:16.844
Then we'll go on to talk about 
how you can understand your 

02:59:16.845 --> 02:59:18.692
users using user position report

02:59:18.693 --> 02:59:22.073
and how you can optimize your 
user acquisition using store 

02:59:22.074 --> 02:59:25.202
listing experiments, we'll also 
talk about the importance of 

02:59:25.203 --> 02:59:27.818
experimentation if you're 
looking to go globally and 

02:59:27.819 --> 02:59:31.189
localize your app to all the 
global markets and finally we'll

02:59:34.118 --> 02:59:37.398
an eye on the performance of 
your app on the go using new 

02:59:37.399 --> 02:59:39.802
play console mobile app.  
Throughout this time, throughout

02:59:41.862 --> 02:59:44.703
features that we launched 
recently or the ones we're 

02:59:44.704 --> 02:59:48.824
launching told or very soon.
&gt;&gt; KOBI GLICK:  Okay.  So let's 

02:59:48.825 --> 02:59:52.180
start with Beta testing.  This 
is a great way to improve your 

02:59:52.181 --> 02:59:57.401
apps and games.  60% of the top 
1,000 gieps are running a Beta

03:00:05.172 --> 03:00:08.869
join Beta so we launched closed 
and open Betas.  With open Beta 

03:00:08.870 --> 03:00:11.587
it's as simple as clicking a URL
URL.

03:00:11.588 --> 03:00:11.805
&gt;&gt; MILENA NIKOLIC:  Did you know

03:00:11.806 --> 03:00:14.932
that there are many big apps 
that are running very large open

03:00:17.011 --> 03:00:20.809
Minecraft, Ub he is r, Google 
search app and many others.

03:00:20.810 --> 03:00:21.780
&gt;&gt; KOBI GLICK:  Nice.  Here is a

03:00:21.781 --> 03:00:24.298
great example of a developer 
that is using this platform very

03:00:25.275 --> 03:00:30.813
very, very correct way.  Hoppe 
helping travelers make better 

03:00:30.814 --> 03:00:34.067
decisions.  Run internal Alpha 
test and go much larger Beta 

03:00:34.068 --> 03:00:36.766
test.  You can see from their 
feedback it cuts their testing 

03:00:36.767 --> 03:00:38.599
and rollout time by half without

03:00:38.600 --> 03:00:41.542
adding any extra work for them 
or their testers.  This is 

03:00:41.543 --> 03:00:43.061
exactly what we had in mind when

03:00:43.062 --> 03:00:48.288
we built this model.  We're 
making it even easier for users 

03:00:48.289 --> 03:00:51.544
to discover and join Beta 
testing.  Very soon users will 

03:00:51.560 --> 03:00:55.764
be able to join Beta tests 
directly for your store listing 

03:00:55.765 --> 03:00:59.368
page on Google Play.  So if you 
run an open Beta, you can just 

03:00:59.369 --> 03:01:01.228
tell users go to our page, click

03:01:01.229 --> 03:01:06.659
it there, join our Beta, and 
give us feedback.  Feedback, 

03:01:06.660 --> 03:01:09.805
used to collect feedback from 
various sources and had to parse

03:01:11.298 --> 03:01:14.446
on, users that are part of your 
Beta test will be able to submit

03:01:18.905 --> 03:01:21.082
feedback is private, you can see

03:01:21.083 --> 03:01:23.798
it in the Google Play Developer 
Console, it doesn't show to 

03:01:23.799 --> 03:01:28.161
other users and it doesn't 
impact your app star rating.  

03:01:28.162 --> 03:01:30.976
Now, we believe that apps and 
games should be launched in open

03:01:36.682 --> 03:01:41.350
section on Google Play called 
Early Access, and in this 

03:01:41.351 --> 03:01:44.512
section we'll feature exciting 
apps and games that are still in

03:01:48.510 --> 03:01:53.316
allow developers, you guys, to 
access early on with early adopt

03:01:53.425 --> 03:01:54.837
adopters and influenceers giving

03:01:54.838 --> 03:01:57.789
you private feedback and making 
sure you can find product market

03:02:02.799 --> 03:02:06.486
collection we'll introduce 28 
apps and games, you can see them

03:02:09.098 --> 03:02:13.098
have, for example, read feed, 
it's an Android first online 

03:02:13.100 --> 03:02:17.195
book club or we have Eva, the 
founder who are parents and 

03:02:17.196 --> 03:02:20.126
sisters who are deaf created 
this app to help deaf people and

03:02:23.819 --> 03:02:25.752
conversations.  Then we have Leg

03:02:25.753 --> 03:02:29.041
ork, the kids and family power 
brand with their first ever 

03:02:29.042 --> 03:02:31.332
in-house mobile game.  It's a 3D

03:02:31.333 --> 03:02:34.682
Lego set you can touch, twist, 
just like the brick sets we all 

03:02:34.683 --> 03:02:36.419
grew up with.  Now, Early Access

03:02:36.420 --> 03:02:38.062
is not going to be just for free

03:02:38.063 --> 03:02:41.429
to play, never alone, a gorgeous

03:02:41.430 --> 03:02:45.755
game created by Ely Media 
researched together with the 

03:02:45.756 --> 03:02:47.955
Alaska natives natives coming to
 Google 

03:02:47.956 --> 03:02:50.671
Play on Early Access, they chose

03:02:50.672 --> 03:02:53.182
Early Access because it's a 
great way to make sure they get 

03:02:53.183 --> 03:02:56.115
feedback from their fans and 
making sure gaming ping 

03:02:56.116 --> 03:02:57.635
experience is a premium one.  We

03:02:57.636 --> 03:03:00.132
are sure those changes we are 
doing to Beta testing will help 

03:03:00.133 --> 03:03:03.166
you create larger Beta tests, 
making your apps and games even 

03:03:03.167 --> 03:03:06.423
more awesome.
&gt;&gt; MILENA NIKOLIC:  Quoa by 

03:03:06.424 --> 03:03:10.017
mentioned that users will be 
able to give private feedback on

03:03:16.206 --> 03:03:19.912
Recently we have launched a 
number of improvements to user 

03:03:19.913 --> 03:03:23.724
functionality on Google Play on 
the console, allowing you to, 

03:03:23.725 --> 03:03:25.022
for example, search your reviews

03:03:25.023 --> 03:03:29.474
by keyword or to see various 
breakdowns of rating aggregates 

03:03:29.475 --> 03:03:32.082
by a number of different 
dimensions, for example, device,

03:03:35.458 --> 03:03:40.049
possible to sign up for 
authentications, e-mail 

03:03:40.050 --> 03:03:44.831
authentications, when users 
change their review after your 

03:03:44.832 --> 03:03:49.961
reply.  I'm happy to announce 
that today we'll launch review 

03:03:49.962 --> 03:03:53.540
analysis.  These are further 
improvements to user reviews 

03:03:53.541 --> 03:03:56.811
functionality and Google Play 
Developer Console and they come 

03:03:56.812 --> 03:03:58.122
in several different tools.  One

03:03:58.123 --> 03:04:02.698
of them is benchmarks, across a 
number of fixed aspects.  For 

03:04:02.699 --> 03:04:05.844
example, design, stability or 
speed.  So it basically allows 

03:04:05.845 --> 03:04:08.992
you to compare how your app is 
doing compared to other similar 

03:04:08.993 --> 03:04:11.057
apps on these fixed aspects.  In

03:04:11.058 --> 03:04:14.506
addition to this, we also launch
launched unique topics, so 

03:04:14.507 --> 03:04:17.872
analyzing all of your user 
reviews and trying to extract 

03:04:17.873 --> 03:04:20.802
what are those specific topics 
that users are talking about 

03:04:20.803 --> 03:04:25.163
just for your app.  Okay.  Let's

03:04:25.164 --> 03:04:27.868
talk about release management 
tools.

03:04:27.869 --> 03:04:29.611
&gt;&gt; KOBI GLICK:  Sounds good.
&gt;&gt; MILENA NIKOLIC:  Cool.  So 

03:04:29.612 --> 03:04:32.654
you Beta test your app, address 
a bunch of user feedback and now

03:04:36.992 --> 03:04:41.228
give as much support as we can 
so you can roll out in a in a 

03:04:41.229 --> 03:04:42.433
very 
safe and controlled fashion.  

03:04:42.434 --> 03:04:45.384
One feature that I want to 
remind everyone of is stage roll

03:04:45.708 --> 03:04:50.048
rollouts.  Stage rollouts allow 
you to roll out gradually, 

03:04:50.049 --> 03:04:52.996
keeping an eye on the 
performance of your app so you 

03:04:52.997 --> 03:04:57.006
can halt in case of any issues, 
in case issues do happen and we 

03:04:57.007 --> 03:05:01.027
all than they torques you'll be 
able to -- and we all know that 

03:05:01.028 --> 03:05:04.513
they do, you'll be able to halt,

03:05:04.514 --> 03:05:08.312
and only specifically if you do 
that auction or upload a new set

03:05:11.476 --> 03:05:13.414
you start the stage rollouts, we

03:05:13.415 --> 03:05:16.125
select a random percentage of 
users who become eligible for 

03:05:16.126 --> 03:05:18.623
this new update.  If you 
increase the percentage, we add 

03:05:18.624 --> 03:05:23.290
more users to the randomly 
selected set.  If you start the 

03:05:23.291 --> 03:05:27.428
next stainch rollout, we use -- 
stage rollout, we use a 

03:05:27.429 --> 03:05:28.839
completely different seed, which

03:05:28.840 --> 03:05:32.332
means it's not always the same 
set of users getting less stable

03:05:33.621 --> 03:05:37.327
worry about that.  You can see 
how developers of FDX games use 

03:05:37.328 --> 03:05:40.568
stage rollouts to confidently 
and frequently roll out new 

03:05:40.569 --> 03:05:42.846
versions of their app.
&gt;&gt; KOBI GLICK:  Okay.  Since 

03:05:42.847 --> 03:05:46.117
we're talking about release 
management, I want to mention 

03:05:46.118 --> 03:05:49.905
another feature released recent
recently called time publishing.

03:05:52.960 --> 03:05:54.146
Google Play, but we wanted to do

03:05:54.147 --> 03:05:55.888
better, meaning giving you exact

03:05:55.889 --> 03:05:58.490
control on the moment your up
update goes live.  With time 

03:05:58.491 --> 03:06:00.011
publishing, you can make as many

03:06:00.012 --> 03:06:04.025
changes like APK changes, store 
list updairkts as you witch, we 

03:06:04.026 --> 03:06:06.630
batch all the changes and they 
don't go live until you click 

03:06:06.631 --> 03:06:08.148
the go live button in the Google

03:06:08.149 --> 03:06:11.199
Play Developer Console.  When 
you click it, the changes go 

03:06:11.200 --> 03:06:15.759
live within minutes.  You also 
have a changes log showing you 

03:06:15.760 --> 03:06:18.388
exactly what changes are about 
to go live, which is a great way

03:06:22.409 --> 03:06:25.991
here showing you how this 
feature is super-useful for them

03:06:26.642 --> 03:06:27.182
them.
&gt;&gt; MILENA NIKOLIC:  Now let's 

03:06:27.183 --> 03:06:31.258
talk about understanding visits 
to your store listing page in 

03:06:31.259 --> 03:06:33.972
Google Play.  It's very 
important to understand where 

03:06:33.973 --> 03:06:38.019
your users are coming from and 
sometime last year we launched 

03:06:38.020 --> 03:06:41.273
user acquisition funnel.  This 
funnel allows you to see how 

03:06:41.274 --> 03:06:44.098
many visitors to your store 
listing page are being converted

03:06:46.265 --> 03:06:51.256
those installers are then 
converting to become purchasers.

03:06:52.664 --> 03:06:56.027
further break down this report 
by, for example, user 

03:06:56.028 --> 03:06:58.600
acquisition source or channel, 
for example, seeing whether 

03:06:58.601 --> 03:07:02.724
users are coming from places 
organically or different channel

03:07:03.052 --> 03:07:06.504
channels like advertising.  I'm 
pretty sure that like truly ya, 

03:07:06.505 --> 03:07:11.064
so far you -- like Trulia, you 
found this report to be pretty 

03:07:11.065 --> 03:07:13.343
useful.  Since understanding 
where your users are coming from

03:07:15.515 --> 03:07:17.904
ago we launched another 
improvement to this panel which 

03:07:17.905 --> 03:07:21.365
allows you to break it down by 
country, which is very important

03:07:22.572 --> 03:07:25.716
localize your app in a more 
efficient way and to take it one

03:07:28.321 --> 03:07:29.884
announce that very soon we'll be

03:07:29.885 --> 03:07:32.821
launching conversion funnel 
benchmarks, which will allow you

03:07:37.709 --> 03:07:43.791
terms of how efficiently it's 
converting users from visitors 

03:07:43.792 --> 03:07:46.633
from store listing fiej 
installers.  Stay tuned.  This 

03:07:46.634 --> 03:07:52.054
is coming very soon.  And once 
you see who is visiting your 

03:07:52.055 --> 03:07:54.991
store leasing page, you'll want 
to optimize, right?

03:07:54.992 --> 03:07:55.968
&gt;&gt; KOBI GLICK:  Right.
&gt;&gt; MILENA NIKOLIC:  Right.  

03:07:55.969 --> 03:07:58.784
Let's talk about getting you 
some more users.  To do that, we

03:08:00.327 --> 03:08:03.480
store listing really shows off 
your app in the best possible 

03:08:03.481 --> 03:08:06.970
light, and in order to get to 
the best store listing, we need 

03:08:06.971 --> 03:08:09.341
to experiment.  This is where 
store listing experiments come 

03:08:09.342 --> 03:08:12.704
in.  This feature has been a 
very big success with developers

03:08:17.047 --> 03:08:20.732
the feature.  We often get 
feedback from developers, for 

03:08:20.733 --> 03:08:22.470
example, like this one from good

03:08:22.471 --> 03:08:25.722
games studios that drives 
significant uplift to their 

03:08:25.723 --> 03:08:28.888
conversion rate.
&gt;&gt; KOBI GLICK:  A big 

03:08:28.889 --> 03:08:30.085
opportunity to get more installs

03:08:30.086 --> 03:08:32.796
is optimize I go the top of the 
funnel, your store listing page.

03:08:34.642 --> 03:08:37.924
install decision regardless of 
whether they found the app from 

03:08:37.925 --> 03:08:41.725
search or via link.  Before we 
launch it, you had to use a 

03:08:41.726 --> 03:08:46.968
bunch of work around and see 
some budget, how they had to run

03:08:49.693 --> 03:08:51.302
can see soft launching on Google

03:08:51.303 --> 03:08:56.418
Play, it allows them to better 
understand their users.  Store 

03:08:56.419 --> 03:09:00.341
listing page experiments have 
been seeing great success in the

03:09:01.863 --> 03:09:03.831
Flaregames up here, 30% increase

03:09:03.832 --> 03:09:08.947
in installs.  Running exactly 
the way we thought about it as a

03:09:10.128 --> 03:09:12.516
experimentation tools.  Expedia,

03:09:12.517 --> 03:09:16.437
10% increase of installs 
globally, their most successful 

03:09:16.438 --> 03:09:20.946
test was reordererring 
screenshots.

03:09:20.947 --> 03:09:22.947
&gt;&gt; MILENA NIKOLIC:  Here are 
some best practices when running

03:09:25.289 --> 03:09:28.335
Create a hypothesis first, make 
sure you know what you're trying

03:09:31.157 --> 03:09:34.438
at a time.  Run your experiments

03:09:34.439 --> 03:09:37.818
until they have reached 
statistical significance.  We'll

03:09:39.228 --> 03:09:42.387
happened.  Minor tweaks often 
have minor impact.  Consider 

03:09:42.388 --> 03:09:45.089
bold changes, especially if 
you're early in your start-up's 

03:09:45.090 --> 03:09:48.673
life.  Finally, keep testing.  
The next major improvement may 

03:09:48.674 --> 03:09:50.732
be still to come.  Here are some

03:09:50.733 --> 03:09:55.952
great feedback we received from 
Jamie Berger, head of marketing 

03:09:55.953 --> 03:10:01.619
at Scobly, you can see how this 
cr has testing of new and bold 

03:10:01.620 --> 03:10:06.286
ideas.  We're happy to see they 
use this as thish go- -- as 

03:10:06.287 --> 03:10:08.798
their 
go-to tool for marketing and 

03:10:08.799 --> 03:10:12.263
optimisation.
&gt;&gt; KOBI GLICK:  Here is a great 

03:10:12.264 --> 03:10:15.113
example of best practices in 
action.  We've learned an app 

03:10:15.114 --> 03:10:18.808
description that shows you add 
value to users works better.  

03:10:18.809 --> 03:10:21.086
You can see control versus 
experiment, experiments is much 

03:10:21.087 --> 03:10:27.041
clearer, plus 14% in installs.  
Here is a bunch of great 

03:10:27.042 --> 03:10:30.084
examples from concrete software,

03:10:30.085 --> 03:10:34.438
sometimes you just get lucky.  
They run a contest for IHL, 

03:10:34.439 --> 03:10:38.113
hockey target smash, plus 70% 
installs.  Boom.  It's great, 

03:10:38.114 --> 03:10:40.626
right?  But sometimes you 
actually need to launch, iterate

03:10:43.230 --> 03:10:45.292
PBA Bowling Challenge they ran a

03:10:45.293 --> 03:10:48.203
series of experiments and every 
icon you see here represents a 

03:10:48.204 --> 03:10:52.143
complete series of spermingts. 
experiments.  

03:10:52.144 --> 03:10:54.749
They also iterated on their 
description, screen shots in 

03:10:54.750 --> 03:10:58.219
order, leading to a compound 
effect of 63%.  This is 

03:10:58.220 --> 03:11:03.759
incredible.  Now let's see an 
example from Mixi, a leading 

03:11:03.760 --> 03:11:07.896
game developer from Japan that, 
will show us how a leading game 

03:11:07.897 --> 03:11:09.957
developer thinks about 
localization and experiment 

03:11:09.958 --> 03:11:11.958
experimentation
experimentation.  Mixi wanted to

03:11:13.495 --> 03:11:16.966
Strike to the U.S., they ran 
spermtz, tested icon, screenshot

03:11:17.507 --> 03:11:20.344
screenshot, description and 
video.  In this chart you can 

03:11:20.345 --> 03:11:22.192
see how they run the experiments

03:11:22.193 --> 03:11:26.271
methodically and scientifically 
leading to a compound effect of 

03:11:26.272 --> 03:11:30.954
68% in installs.  Store listing 
experiment helped Mixi 

03:11:30.955 --> 03:11:33.580
understand the difference in 
taste and flavor between users 

03:11:33.581 --> 03:11:37.160
in the U.S. and users in Japan 
and helped them localize their 

03:11:37.163 --> 03:11:42.585
games much better.  Here is the 
feedback we got from their Xflag

03:11:45.300 --> 03:11:48.351
makes us really excited, as our 
mission is to help you test 

03:11:48.352 --> 03:11:50.627
directly on owsh platform. -- on

03:11:50.628 --> 03:11:53.345
our platform Mill medical we 
want you to experiment and 

03:11:53.346 --> 03:11:56.163
iterate and we want you to do 
this fast.  This is why I'm 

03:11:56.164 --> 03:11:57.692
happy to announce that last week

03:11:57.693 --> 03:12:01.481
we launched multiple concurrent 
localized store listing 

03:12:01.482 --> 03:12:06.511
experiments.  We want you to go 
globally faster and have better 

03:12:06.512 --> 03:12:09.517
toolings to test localized 
versions of your store listing. 

03:12:10.604 --> 03:12:13.477
experiments with different 
languages at the same time.

03:12:16.698 --> 03:12:18.698
&gt;&gt; KOBI GLICK:  You're talking 
about making things faster.  One

03:12:19.857 --> 03:12:23.112
making price changes in the 
developer console, this sucks 

03:12:23.113 --> 03:12:25.844
because lot of people have the 
same price poibtsz to many 

03:12:25.845 --> 03:12:29.650
products or paid apps.  What 
will we do about that?

03:12:29.651 --> 03:12:31.483
&gt;&gt; MILENA NIKOLIC:  I'm very 
glad you asked, Kobi.  We want 

03:12:31.484 --> 03:12:34.755
to make this faster as well, 
make pricing faster as well cht 

03:12:34.756 --> 03:12:37.495
I'm happy to announce that 
earlier this week we have launch

03:12:37.822 --> 03:12:41.404
launched pricing templates.  
With pricing templates, you can 

03:12:41.405 --> 03:12:45.423
define prices across all of the 
marketed Google Play supports.  

03:12:45.424 --> 03:12:49.868
Did you guys know there are 70 
such markets now?  Yeah.  Once 

03:12:49.869 --> 03:12:51.283
you create the template, you can

03:12:51.284 --> 03:12:55.746
link it to as many paid apps or 
products as you want.  If you 

03:12:55.747 --> 03:12:59.002
make a change to template, it 
gets propagateed to all of the 

03:12:59.003 --> 03:13:01.940
apps.  So for example, if you're

03:13:01.941 --> 03:13:06.600
like Boca games and selling 
multiple titles, at say 2.99, 

03:13:06.601 --> 03:13:08.218
you only need to make changes to

03:13:08.219 --> 03:13:11.160
your template once and it will 
be propagateed to all of your 

03:13:11.161 --> 03:13:14.738
app
apps.  If you're like Woga 

03:13:14.739 --> 03:13:17.905
selling products and multiple 
price points, for example, 1.99,

03:13:22.152 --> 03:13:24.866
maintain three templates, 
instead of manually making 

03:13:24.867 --> 03:13:27.800
changes to tens or hundreds of 
individual pricing points in 

03:13:27.801 --> 03:13:32.710
multiple different currencies.  
Liking this feedback we got, we 

03:13:32.711 --> 03:13:35.848
hope rising templates will help 
you move faster and get 

03:13:35.849 --> 03:13:37.707
successful.
&gt;&gt; KOBI GLICK:  Okay.  It's 

03:13:37.708 --> 03:13:40.415
important for us, you're also 
able to localize your price 

03:13:40.416 --> 03:13:44.325
better.  This is why we also 
launched round pricing.  With 

03:13:44.326 --> 03:13:46.618
round pricing, we're not like we

03:13:46.619 --> 03:13:50.201
used to do, just converting the 
price using today's exchange 

03:13:50.202 --> 03:13:54.003
rate, we also apply locally 
relevant country-specific 

03:13:54.004 --> 03:13:57.804
rounding rules, so a please like

03:13:57.805 --> 03:14:07.512
9.73 euros, becomes 9.99.  1.96 
Japanese yen becomes 200 

03:14:07.513 --> 03:14:13.178
Japanese yen.  We are sure that 
this change like the feedback 

03:14:13.179 --> 03:14:17.277
you seal here will help you 
streamline your pricing 

03:14:17.278 --> 03:14:20.955
structures and make your 
businesses even better.  Now 

03:14:20.956 --> 03:14:23.456
while we were helping you make 
price changes faster with 

03:14:23.457 --> 03:14:26.503
templates and more locally 
relevant with rounding, we're 

03:14:26.504 --> 03:14:29.977
keeping your ability to tweak 
the prices manually in the 

03:14:29.978 --> 03:14:31.064
Developer Console.  We know this

03:14:31.065 --> 03:14:33.883
is important for you when you 
round 

03:14:33.884 --> 03:14:37.577
run short time promotion or try 
new pricing strategies.  We are 

03:14:37.578 --> 03:14:38.768
sure that the new changes we are

03:14:38.769 --> 03:14:44.091
making to pricing will help you 
go globally faster.

03:14:44.092 --> 03:14:44.850
&gt;&gt; MILENA NIKOLIC:  Last but not

03:14:44.851 --> 03:14:48.214
least, finally we have a mobile 
app for Google Play Developer 

03:14:48.215 --> 03:14:52.690
Console.  We have to admit it 
tuks a while, it took us much 

03:14:52.691 --> 03:14:56.057
longer than it took all of you 
guys but we've made T we can 

03:14:56.058 --> 03:14:59.507
tell you this app is pretty 
sweet, we really like it now.  

03:14:59.508 --> 03:15:01.270
Our new app allows you to follow

03:15:01.271 --> 03:15:02.895
your app's performance on the go

03:15:02.896 --> 03:15:07.038
and to do time critical changes 
wherever you are.  When you are 

03:15:07.039 --> 03:15:10.203
rapidly iterating, you need a 
power tool in your pocket at all

03:15:12.713 --> 03:15:14.560
app exactly with those use cases

03:15:14.561 --> 03:15:17.925
in mind.  Whether you want to 
quickly reply to user review or 

03:15:17.926 --> 03:15:20.513
show on which performance of 
your app to a venture capitalist

03:15:21.070 --> 03:15:24.667
capitalist, Play console apps 
should be there to support you. 

03:15:25.968 --> 03:15:29.335
obviously you can see, you can 
track your installs and un

03:15:29.336 --> 03:15:32.703
uninstalls and break them down 
by a number of dimensions like 

03:15:32.704 --> 03:15:35.644
app, version, country, device, 
so on.  You can also track crash

03:15:38.697 --> 03:15:41.628
and stack traces.  You can also 
see ratings and user reviews and

03:15:44.451 --> 03:15:46.186
and also track the state of your

03:15:46.187 --> 03:15:48.151
Lee lease, for example, is it in

03:15:48.152 --> 03:15:51.625
in -- of your release, for 
example, is it in Beta testing, 

03:15:51.626 --> 03:15:56.497
stage rollout or prod.  You can 
also get awe thent indications. 

03:16:00.103 --> 03:16:02.692
example, when your updates go 
live.  If you haven't installed 

03:16:02.693 --> 03:16:05.516
the app yet, please do.  If 
you're still not quingsed, 

03:16:05.517 --> 03:16:08.431
please come to Play sandbox, we 
would love to convince you.  If 

03:16:08.432 --> 03:16:11.146
you have any feedback, send it 
to us.  We intend to listen and 

03:16:11.147 --> 03:16:15.496
add more functionality in the 
next couple of versions.

03:16:15.497 --> 03:16:18.329
&gt;&gt; KOBI GLICK:  Okay.  So today 
we spoke about launching, 

03:16:18.330 --> 03:16:20.815
experimenting and iterating on 
Google Play.  With the new 

03:16:20.816 --> 03:16:22.019
changes we're going to introduce

03:16:22.020 --> 03:16:24.962
to Beta test, it will become 
easier for users to discover and

03:16:26.469 --> 03:16:29.073
you to build bigger, larger Beta

03:16:29.074 --> 03:16:32.765
audiences and improve your apps 
and games.  Users will be able 

03:16:32.766 --> 03:16:35.915
to send you private feedback 
that only you can see in the 

03:16:35.916 --> 03:16:38.096
Developer Console.  The new 
Early Access section will 

03:16:38.097 --> 03:16:41.350
feature exciting apps and games 
that are still in development.  

03:16:41.351 --> 03:16:44.408
We also spoke about better 
understanding your users with 

03:16:44.409 --> 03:16:48.985
our new mobile apps that Milena 
just mentioned and a bunch of 

03:16:48.986 --> 03:16:53.116
enhancements such as bark 
benchmark 

03:16:53.117 --> 03:16:55.056
to the user acquisition report. 

03:16:55.057 --> 03:16:58.517
Finally we spoke about making 
things faster with multiple 

03:16:58.518 --> 03:17:00.810
listing store experiments and 
price templates as well as 

03:17:00.811 --> 03:17:05.066
making prices more locally 
relevant with rounding.  We are 

03:17:05.067 --> 03:17:07.901
really excited to getting 
developer feedback like the one 

03:17:07.902 --> 03:17:14.424
you see here from Scott Rubin, 
telling us how features like 

03:17:14.425 --> 03:17:17.569
store listing experiments 
encouraged him to launch their 

03:17:17.570 --> 03:17:21.263
next major update on Android 
first.  We hope that the tools 

03:17:21.264 --> 03:17:23.766
we're building will encourage 
you to continue to launching and

03:17:25.819 --> 03:17:28.862
We'll continue to help building 
more powerful publishing tools, 

03:17:28.863 --> 03:17:32.556
allowing you to experiment, 
iterate and make your apps and 

03:17:32.557 --> 03:17:35.604
games even more awesome.  Thank 
you.

03:17:35.682 --> 03:17:38.537
(applause).
&gt;&gt; MILENA NIKOLIC:  Thank you.  

03:17:38.538 --> 03:17:44.933
Now I would like to invite to 
the stage Larissa and Aaron.

03:17:44.934 --> 03:17:46.939
&gt;&gt; AARON ROTHMAN:  Thank you.

03:17:51.131 --> 03:17:53.203
&gt;&gt; LARISSA FONTAINE:  Thanks, 
Milena and Kobi, that was an a

03:17:53.313 --> 03:17:56.253
amayorsing overview of all of 
the cool stuff launching in the 

03:17:56.254 --> 03:17:58.316
Developer Console.  You can see 
that Aaron and I are really 

03:17:58.317 --> 03:18:01.793
excited about this talk today, 
so much so that we decided to 

03:18:01.794 --> 03:18:05.808
dress the part.  How are you 
doing there, Andy?  My name is 

03:18:05.809 --> 03:18:08.954
Larissa and I lead business 
development for the apps team at

03:18:12.552 --> 03:18:17.438
build great apps in successful 
businesses on the platform.

03:18:17.439 --> 03:18:18.414
&gt;&gt; AARON ROTHMAN:  I'm Aaron.  I

03:18:18.415 --> 03:18:21.231
lead search and discovery on 
Play.  My team is focused on 

03:18:21.232 --> 03:18:26.676
making sure users find great 
apps.

03:18:26.677 --> 03:18:28.423
&gt;&gt; LARISSA FONTAINE:  As much as

03:18:28.424 --> 03:18:32.001
I love shap court Round, I'll 
take the hat off so I can see 

03:18:32.002 --> 03:18:34.497
you guys.  I talk to developers 
all the time and understanding 

03:18:34.498 --> 03:18:38.425
how store discovery comes up 
always comes up as an important 

03:18:38.426 --> 03:18:41.576
topic.  We know it can feel 
difficult to break through the 

03:18:41.577 --> 03:18:45.586
noise and to help users find 
your app at exactly the right 

03:18:45.587 --> 03:18:48.753
time.  More apps are being up
uploaded to the store every day,

03:18:50.395 --> 03:18:51.790
through.  Studies show that more

03:18:51.791 --> 03:18:55.156
users are using the same set of 
apps over and over again instead

03:18:57.559 --> 03:19:02.553
theory is that app fatigue is 
driving this.  But what if it's 

03:19:02.554 --> 03:19:04.399
that users simply can't find all

03:19:04.400 --> 03:19:09.068
the great apps that are out 
there?  It's not only apps that 

03:19:09.069 --> 03:19:11.551
are growing.  The entire Android

03:19:11.552 --> 03:19:14.263
ecosystem is growing entirely 
fast.  You heard some of these 

03:19:14.264 --> 03:19:19.046
numbers this morning.  The one 
we'll talk about here is 

03:19:19.047 --> 03:19:21.870
1 billion monthly store users.  
Out of that huge audience, we 

03:19:21.871 --> 03:19:28.497
want to help you find the best 
users for your app.  That's why 

03:19:28.498 --> 03:19:32.093
you're all here.  Today, we'll 
walk through how we can work 

03:19:32.094 --> 03:19:35.023
together to improve app 
discovery in the Play Store.  

03:19:35.024 --> 03:19:37.742
There are a lot of important 
elements that contribute to 

03:19:37.743 --> 03:19:40.900
discovery, some of which you 
already heard about.  But we're 

03:19:40.901 --> 03:19:43.509
going to touch on a few of them 
again because they're that 

03:19:43.510 --> 03:19:45.510
important and because they 
directly contribute to discovery

03:19:46.879 --> 03:19:49.462
discovery.  We've narrowed them 
down to the most critical and 

03:19:49.463 --> 03:19:52.956
we'll go through each of them.  
Build something great, listen to

03:19:55.996 --> 03:20:00.571
presence, and expand your reach.

03:20:00.572 --> 03:20:02.976
Then we're going on share some 
insights about how the discovery

03:20:07.421 --> 03:20:12.765
shared before.
&gt;&gt; AARON ROTHMAN:  As Larissa 

03:20:12.766 --> 03:20:15.793
mentioned, it all starts with 
building something great.  We 

03:20:15.794 --> 03:20:17.851
want users to find the apps they

03:20:17.852 --> 03:20:23.859
will love.  So a quarter of 
installed apps are used only 

03:20:23.860 --> 03:20:28.878
once.  Wow.  That's scarier 
unanimous a pit of snakes.

03:20:28.879 --> 03:20:29.315
&gt;&gt; LARISSA FONTAINE:  All right,

03:20:29.316 --> 03:20:32.463
Aaron, let's tone it back.
&gt;&gt; AARON ROTHMAN:  Anyway, this 

03:20:32.464 --> 03:20:37.801
is why we want to start with 
building something great.  So 

03:20:37.802 --> 03:20:40.172
based on some internal analysis,

03:20:40.173 --> 03:20:45.412
we found that permissions, 
footprint -- excuse me.  We 

03:20:45.413 --> 03:20:49.213
found that permissions, 
footprint and design were all 

03:20:49.214 --> 03:20:50.731
key components when it came to a

03:20:50.732 --> 03:20:55.740
user's perception of a great app
app.  So starting with 

03:20:55.741 --> 03:20:58.884
permissions, excessive 
permissions can actually deal 

03:20:58.885 --> 03:21:01.924
ter a user from installing your 
app in the first place.  It's 

03:21:01.925 --> 03:21:06.921
important to remember if you 
don't need it, don't ask for it.

03:21:09.536 --> 03:21:10.839
apps where the permissions don't

03:21:10.840 --> 03:21:13.889
seem to align with the app 
functionality.  For example, why

03:21:16.388 --> 03:21:21.604
access my phone's call logs?  
Second is footprint.  Some users

03:21:23.337 --> 03:21:26.804
footprint of your app.  These 
users may be on poor internet 

03:21:26.805 --> 03:21:29.412
connections or have limited 
phone memory.  This is 

03:21:29.413 --> 03:21:33.043
especially true in emerging 
markets where there are both 

03:21:33.044 --> 03:21:38.269
phone and network limitations.  
So it's helpful to be mindful of

03:21:41.636 --> 03:21:44.021
memory usage.  Sometimes less is

03:21:44.022 --> 03:21:52.417
more.  Third is design.  So the 
user has installed your app.  

03:21:52.418 --> 03:21:55.896
Now you want to ensure a great 
experience, so remember to limit

03:21:58.937 --> 03:22:02.096
designed app is intuitive and 
consistent and does not require 

03:22:02.097 --> 03:22:06.872
a user to hunt, guess, remember 
or otherwise strain their brains

03:22:08.268 --> 03:22:11.554
interact with your app.  One 
tangible solution for making a 

03:22:11.555 --> 03:22:14.274
highly use I believe app simply 
meanting 

03:22:14.275 --> 03:22:18.738
meanting Google's design spec 
known as material design.  Here 

03:22:18.739 --> 03:22:22.314
are two examples of apps that 
invested more in quality by 

03:22:22.315 --> 03:22:26.564
adopting material design, which 
led to the benefit of more user 

03:22:26.565 --> 03:22:30.259
engagement.  It's pretty 
impressive, for example, that Tr

03:22:30.473 --> 03:22:35.044
Trello saw 41% increase in 
activity per session by 

03:22:35.045 --> 03:22:41.851
implementing material design.  
You can do your best to build a 

03:22:41.852 --> 03:22:46.445
great app, but how can you be 
sure it's actually great?  More 

03:22:46.446 --> 03:22:50.058
than half of poor user reviews 
are quality related, and a third

03:22:56.693 --> 03:22:59.839
iteration, so we recommend 
following the earlier advice of 

03:22:59.840 --> 03:23:04.072
Milena and Kobi and using are 
Beta testing and stageed roll

03:23:04.291 --> 03:23:06.238
outs 
to ensure that your app is great

03:23:11.791 --> 03:23:13.315
covered building and launching a

03:23:13.316 --> 03:23:16.391
great app.  Now just because 
your app is launched, it doesn't

03:23:18.581 --> 03:23:22.057
with your users.  Listen to go 
your users is important for 

03:23:22.058 --> 03:23:23.918
continued success, and I'm going

03:23:23.919 --> 03:23:29.681
to explain why.  You have a 
unique opportunity in Android to

03:23:31.762 --> 03:23:36.441
by replying to the reviews via 
the Developer Console and 

03:23:36.442 --> 03:23:44.505
building an even more loved app 
as a result.  One example is Ava

03:23:44.630 --> 03:23:48.763
Avary, who created a dialogue 
with their users by engaging 

03:23:48.764 --> 03:23:52.798
with feedback.  This 
responsiveness led to a 50% of 

03:23:52.799 --> 03:23:59.867
reviewers revising their score 
as higher.  Crazy.  A boost in 

03:23:59.868 --> 03:24:01.868
discovery opportunities and 
higher ratings.

03:24:05.205 --> 03:24:06.627
&gt;&gt; LARISSA FONTAINE:  After 
building a great app and 

03:24:06.628 --> 03:24:09.341
listening to your users, it's 
important 

03:24:09.342 --> 03:24:10.641
important to create a Play Store

03:24:10.642 --> 03:24:13.028
listing that quickly and 
accurately reflects what your 

03:24:13.029 --> 03:24:15.857
app is about.  You're all 
familiar with the different 

03:24:15.858 --> 03:24:20.100
elements of your listing.  This 
really requires some thoughtful 

03:24:20.101 --> 03:24:23.257
attention.  We've provided 
multiple ways for you to 

03:24:23.258 --> 03:24:26.200
communicate the value of your 
app and it's up to you to try to

03:24:28.043 --> 03:24:32.829
interesting information, and 
each of them from the title to 

03:24:32.830 --> 03:24:36.736
the description to the images 
provide metadata that help us 

03:24:36.737 --> 03:24:41.434
understand what your app does 
and who is most likely to use it

03:24:41.875 --> 03:24:46.439
it.  It sounds easy, but no one 
gets it right the first time.  

03:24:46.440 --> 03:24:49.703
This is why we created store 
listing experiments, to help you

03:24:51.785 --> 03:24:55.360
You already heard from Kobi and 
Milena about how these have 

03:24:55.361 --> 03:24:58.403
helped developers over the last 
year and the stat that 70% of 

03:24:58.404 --> 03:25:01.238
top developers are using 
experiments is really incredible

03:25:01.690 --> 03:25:07.197
incredible.  Developers of all 
sizes are seeing real impact.  

03:25:07.198 --> 03:25:10.637
An iteration is key for store 
listing experiments.  This 

03:25:10.638 --> 03:25:14.339
example from Rovio, they focus 
on the icon and finding which 

03:25:14.340 --> 03:25:17.397
one with most impact conversions
conversions.  Here 12 different 

03:25:17.398 --> 03:25:21.754
treatments they exploreed with 
various outcomes.  They kept 

03:25:21.755 --> 03:25:24.800
iterating.  This is what we see 
from developers who are finding 

03:25:24.801 --> 03:25:28.596
the most success.  They trn to 
continue 

03:25:28.597 --> 03:25:31.886
to test and refine and 
understand user preferences.  

03:25:31.887 --> 03:25:35.595
Ultimately Rovio saw suggest up
uplift as a result of their 

03:25:35.596 --> 03:25:39.629
experiments, and back to 
discovery.  Higher conversion 

03:25:39.630 --> 03:25:42.896
rates from listing to installs 
are an important install and 

03:25:42.897 --> 03:25:46.465
help us understand when a user 
is successfully gone from 

03:25:46.466 --> 03:25:49.730
searching for an app to finding 
one that they think they'll love

03:25:51.589 --> 03:25:54.977
love.  So now you've built a 
great app, you've implemented 

03:25:54.978 --> 03:25:57.919
important feedback and you have 
a strong Play Store presence.  

03:25:57.920 --> 03:26:00.984
What's next?  There are 
different opportunities to 

03:26:00.985 --> 03:26:03.699
expand your reach depending on 
the type of app you have and the

03:26:05.330 --> 03:26:10.973
users are looking for.  Going 
global and finding audiences in 

03:26:10.974 --> 03:26:14.338
new smarkts a strategy that's 
worked extremely well for many 

03:26:14.339 --> 03:26:17.063
developers, so we'll explore a 
few tips and tools that can help

03:26:22.170 --> 03:26:24.886
massive reach of Android.  We've

03:26:24.887 --> 03:26:27.054
actually looked at the growth 
rates of apps that are available

03:26:32.285 --> 03:26:36.864
Global apps grew 2.4 times 
faster than nonglobal apps.  Now

03:26:36.973 --> 03:26:39.789
Now, this makes intuitive sense.

03:26:39.790 --> 03:26:42.384
If you're in more market, you 
have a larger addressable awd 

03:26:42.385 --> 03:26:47.503
yerches, but the data really 
proves it out.  There are a few 

03:26:47.504 --> 03:26:48.909
specific things to consider when

03:26:48.910 --> 03:26:50.230
you're planning to localize your

03:26:50.231 --> 03:26:55.243
app.  First, you should use the 
dev console reports we talked 

03:26:55.244 --> 03:27:00.355
about to understand where new 
user bayses bays bases are 

03:27:00.356 --> 03:27:03.283
growing and 
prioritize those market.  Second

03:27:03.613 --> 03:27:06.757
Second, don't just translate, 
actually localize, meaning 

03:27:06.758 --> 03:27:08.806
ensure that you're culturally 
culturally 

03:27:08.807 --> 03:27:11.858
aware of local expectations and 
be ready to support your new 

03:27:11.859 --> 03:27:13.486
users.  Last, always be prepared

03:27:13.487 --> 03:27:19.256
to test and iterate.  New users 
means new feedback.  A developer

03:27:21.214 --> 03:27:24.346
this is One Password, they 
localized their store 

03:27:24.347 --> 03:27:26.072
description, their screen shots,

03:27:26.073 --> 03:27:29.223
content and messageing inside 
their app and we looked at those

03:27:30.951 --> 03:27:34.755
app was ready to be shown to 
local users.  For one password, 

03:27:34.756 --> 03:27:38.471
the investment really paid off. 

03:27:38.487 --> 03:27:43.360
After two weeks of work, they 
saw 100X install growth in Korea

03:27:43.806 --> 03:27:46.950
Korea.  This is really pretty 
incredible.  By focusing on 

03:27:46.951 --> 03:27:50.334
local market users, they made a 
real difference and in most 

03:27:50.335 --> 03:27:54.022
cases it's worth the effort if 
your plan is to grow through 

03:27:54.023 --> 03:27:57.916
market expansion.  And we have 
powerful tools to help, like the

03:27:59.668 --> 03:28:02.922
to translation services and the 
new pricing features that Kobi 

03:28:02.923 --> 03:28:08.163
shared.  So we've reviewed the 
most important ways that you can

03:28:09.936 --> 03:28:12.224
discoverability of your app and 
some key actions that you can 

03:28:12.225 --> 03:28:17.673
take right away.  For build 
something great, limit 

03:28:17.674 --> 03:28:20.069
permissions and focus on 
beautiful design.  Listen to 

03:28:20.070 --> 03:28:25.076
your users, feedback is a gift, 
use it to get better.  Optimize 

03:28:25.077 --> 03:28:28.900
your presence.  Experiment your 
way to improve conversions 

03:28:28.901 --> 03:28:31.758
conversions, and 
expand your reach.  Go global 

03:28:31.759 --> 03:28:36.205
and localize.  We've also 
mentioned that all of these 

03:28:36.206 --> 03:28:39.906
impact discovery within the 
store, so let's unpack how the 

03:28:39.907 --> 03:28:43.053
store actually works and why 
each of these elements actually 

03:28:43.054 --> 03:28:45.059
matter.

03:28:50.927 --> 03:28:51.802
&gt;&gt; AARON ROTHMAN:  There we go. 

03:28:51.803 --> 03:28:55.598
I'm back.  Great.  So how are 
users actually discovering apps 

03:28:55.599 --> 03:29:00.946
in Play and what matters to 
those discovery mechanisms?  

03:29:00.951 --> 03:29:04.406
Let's start with how users are 
actually finding apps today.  

03:29:04.407 --> 03:29:09.303
The top discovery channels are 
Play are, number one, play 

03:29:09.304 --> 03:29:18.230
search, two, recommendations, 
three, top charts.  So starting 

03:29:18.231 --> 03:29:22.378
with search, about half of 
searches are specifically for an

03:29:25.414 --> 03:29:28.563
especially important when name 
lg naming 

03:29:28.564 --> 03:29:31.929
your app to be unique, keep it 
short, and make sure that it is 

03:29:31.930 --> 03:29:36.075
not easily confused with a 
similarly named app.  A well-

03:29:36.293 --> 03:29:39.783
well-nameed app also has the 
benefit of appearing within 

03:29:39.784 --> 03:29:42.732
Google Play search suggest, 
which makes it even easier for 

03:29:42.733 --> 03:29:47.428
users to find your app, by using

03:29:47.429 --> 03:29:48.407
Google Play search suggest, they

03:29:48.408 --> 03:29:51.992
don't even need to type in the 
full name to find the app.  Half

03:29:56.342 --> 03:30:00.696
important to make sure you 
select the right app category.  

03:30:00.697 --> 03:30:04.173
Also when you're writing the 
description of your app, it's 

03:30:04.174 --> 03:30:07.313
great and important to be 
thorough and complete, making 

03:30:07.314 --> 03:30:13.623
sure to include key 
functionality and features.  You

03:30:14.849 --> 03:30:19.093
actually a third twhai an app 
can appear within irve given 

03:30:19.094 --> 03:30:21.590
search results and this is ads. 

03:30:21.591 --> 03:30:23.884
Play search ads are already part

03:30:23.885 --> 03:30:27.695
of AdWords appear install 
campaigns ask provide additional

03:30:30.748 --> 03:30:33.802
search.  
So recommendations.  Whether on 

03:30:33.803 --> 03:30:37.817
the homepage or right after a 
user installs an app, Google 

03:30:37.818 --> 03:30:41.157
Play recommends apps 
personalized for each user.  

03:30:41.158 --> 03:30:43.450
Although there are a lot of 
components that go into those 

03:30:43.451 --> 03:30:44.867
smarts, I just want to highlight

03:30:44.868 --> 03:30:49.990
a few for you today.  These 
include metadata, app quality, 

03:30:49.991 --> 03:30:53.950
user store activity and web 
knowledge.

03:30:57.064 --> 03:30:57.390
&gt;&gt; LARISSA FONTAINE:  The charts

03:30:57.391 --> 03:31:01.296
are a common way for both new 
and returning users to gain a 

03:31:01.297 --> 03:31:04.677
quick understanding of which 
apps are popular in the store 

03:31:04.678 --> 03:31:07.538
and which apps are on their way 
to becoming popular.  We'll 

03:31:07.539 --> 03:31:10.819
share insight into how these 
charts are put together with 

03:31:10.820 --> 03:31:12.820
specific details on key 
components.

03:31:15.880 --> 03:31:19.198
  Top free and top 
pay charts are primarily 

03:31:19.199 --> 03:31:23.338
determined by installs within 
the last 7 days.  We want the 

03:31:23.339 --> 03:31:27.896
charts to stay fresh and 
interesting week over week, so 

03:31:27.897 --> 03:31:31.926
we've kept it short.  Top new 
free and top new paid also look 

03:31:31.927 --> 03:31:34.992
at installs over the previous 7 
days but they're buy alpsed 

03:31:34.993 --> 03:31:38.569
towards new apps, those that 
have -- biased towards new apps,

03:31:40.183 --> 03:31:44.108
store in the previous 30 days.  
This is to ensure the charts 

03:31:44.109 --> 03:31:46.219
aren't established by 
established titles.  We want to 

03:31:46.220 --> 03:31:48.621
help users find new and 
interesting apps wherever they 

03:31:48.622 --> 03:31:52.238
look for them.  Trending, on the

03:31:52.239 --> 03:31:55.598
other hand, otherwise fast 
risers that have the potential 

03:31:55.599 --> 03:31:57.887
to make it onto the top charts. 

03:31:57.903 --> 03:32:01.143
Typically this means their 
installs have seen accelerateed 

03:32:01.144 --> 03:32:03.210
growth over the previous 30 days

03:32:03.211 --> 03:32:06.363
but their absolute installs 
might not be as large as those 

03:32:06.364 --> 03:32:13.129
on the other top charts.  
Finally, top grossing grossing 

03:32:13.130 --> 03:32:15.850
uses the 
same 7-day trailing approach but

03:32:21.494 --> 03:32:23.657
tuning our algorithms to produce

03:32:23.658 --> 03:32:25.937
the best user experience.  These

03:32:25.938 --> 03:32:28.434
are subject to change rs but 
hopefully you have a better 

03:32:28.435 --> 03:32:33.650
sense of what drives top 
placement in the charts and what

03:32:36.171 --> 03:32:39.083
Featuring.  Everybody loves 
featureing.  We define feature

03:32:39.411 --> 03:32:40.915
ing 
to mean the collections that 

03:32:40.916 --> 03:32:45.698
appear across the store, either 
manually cure rateed or 

03:32:45.699 --> 03:32:48.755
algorithmically generated.  
Quality is the key driver for 

03:32:48.756 --> 03:32:51.471
inclusion, that's why we spent 
the first half of this talk 

03:32:51.472 --> 03:32:54.950
focused on tools and strategies 
to help drive important quality 

03:32:54.951 --> 03:32:59.651
signals.  In addition to quality
quality, we also want to surface

03:33:01.934 --> 03:33:04.972
fresh and we definitely want 
users to find apps using the 

03:33:04.973 --> 03:33:09.219
latest Android features, things 
that truly make their experience

03:33:14.121 --> 03:33:16.510
your app is eligible for appear
appearing in certain collections

03:33:21.293 --> 03:33:25.903
where users have installed 
similar apps.  With an even 

03:33:25.904 --> 03:33:28.939
higher expectation of quality, 
we have collections showcaseing 

03:33:28.940 --> 03:33:32.845
new and updated apps, so users 
know they're getting great 

03:33:32.846 --> 03:33:34.709
experiences that are hot off the

03:33:34.710 --> 03:33:37.536
presses.  For seasonal 
collections and special 

03:33:37.537 --> 03:33:40.689
promotions, our BDM 
merchandising teams work 

03:33:40.690 --> 03:33:43.514
together to identify which apps 
to include and we also use a 

03:33:43.515 --> 03:33:44.592
healthy dose of machine learning

03:33:44.593 --> 03:33:48.819
to scale our efforts across 
categories and markets.  It's 

03:33:48.820 --> 03:33:52.120
important to note that within 
each of these collections, the 

03:33:52.121 --> 03:33:56.153
recommendations engine helps 
determine which users see which 

03:33:56.154 --> 03:33:59.503
apps.  The most important thing 
is not that millions of users 

03:33:59.504 --> 03:34:01.256
see your app, it's that millions

03:34:01.257 --> 03:34:03.096
of the right useers see your app

03:34:03.097 --> 03:34:10.837
and go on to install it.
&gt;&gt; AARON ROTHMAN:  Now that 

03:34:10.838 --> 03:34:13.027
we've revealed the holy grail of

03:34:13.028 --> 03:34:18.051
app discovery, we want to leave 
you with four recommendations 

03:34:18.052 --> 03:34:24.139
that you can do right now.  
Number one, for building a great

03:34:26.649 --> 03:34:31.081
Android's design principles.  
Does your app measure up?  Two, 

03:34:31.082 --> 03:34:35.118
for listening to your users, we 
recommend addressing user 

03:34:35.119 --> 03:34:38.702
feedback, especially when it 
comes to bugs.  Squash those 

03:34:38.703 --> 03:34:43.163
bugs.  Number three, for 
optimizeing your presence, why 

03:34:43.164 --> 03:34:46.328
not try a store listing 
experiment?  And finally, number

03:34:48.823 --> 03:34:51.874
we recommend reviewing the 
market report and the Developer 

03:34:51.875 --> 03:34:57.116
Console.  So that's our talk for

03:34:57.117 --> 03:35:00.478
today.  We are so excited to 
have you all here.  We know we 

03:35:00.479 --> 03:35:03.614
shared a lot of content with you
you, but the great news is that 

03:35:03.615 --> 03:35:04.927
you can find everything you need

03:35:04.928 --> 03:35:09.286
in our new app, Playbook by 
Google Play, it replaces the 

03:35:09.287 --> 03:35:12.432
business guide that some of you 
have seen called the Secrets to 

03:35:12.644 --> 03:35:15.496
App Success on Google Play.  
There are a ton of great 

03:35:15.497 --> 03:35:17.126
features, but it's brand new, so

03:35:17.127 --> 03:35:19.202
we would love your feedback.  If

03:35:19.203 --> 03:35:21.793
you get a moment, please hop 
over to the Google Play Store 

03:35:21.794 --> 03:35:24.509
and try it out.  And of course 
we want to leave you with a few 

03:35:24.510 --> 03:35:28.650
helpful links, and again, thank 
you so much for coming, from all

03:35:30.823 --> 03:35:32.823
&gt;&gt; LARISSA FONTAINE:  Thank you.
(applause)

03:35:41.426 --> 03:35:48.530
.
(The session ended at 4:39 p.m.)

03:47:01.685 --> 03:47:07.286
Test.  Test.
&gt;&gt; 

03:47:07.364 --> 03:47:08.348
&gt;&gt; 
&gt;&gt; 

03:47:08.349 --> 03:47:09.475
&gt;&gt; 
&gt;&gt; 

03:47:09.476 --> 03:47:10.449
&gt;&gt; 
&gt;&gt; 

03:47:10.450 --> 03:47:11.580
&gt;&gt; 
&gt;&gt; 

03:47:11.581 --> 03:47:13.581
&gt;&gt; 
&gt;&gt; 

03:47:15.603 --> 03:47:19.208
May 18, 2016.

03:49:10.006 --> 03:49:14.433
What the Fragment?

03:56:49.274 --> 03:56:58.081
&gt;&gt; All right.  Hello, everyone, 
and welcome to What the Fragment

03:56:58.511 --> 03:57:01.453
Fragment.  I'm Adam Powell, I'm 
a member of the Android fragment

03:57:02.967 --> 03:57:06.115
toolkit but I've spent a fair 
amount of time with fragments 

03:57:06.116 --> 03:57:09.273
over the years here and 
hopefully we can go over some 

03:57:09.274 --> 03:57:12.101
interesting information here.  
So the first thing that people 

03:57:12.102 --> 03:57:15.809
tend to ask is why fragments?  
There's a lot of information out

03:57:18.088 --> 03:57:19.938
the API, gotten kind of familiar

03:57:19.939 --> 03:57:21.900
with it and in some ways kind of

03:57:21.901 --> 03:57:25.048
gotten bitten by it.  There's a 
lot of complexity there.  In 

03:57:25.063 --> 03:57:27.655
fact, some members of the 
community have put together a 

03:57:27.656 --> 03:57:29.944
few diagrams of just how complex

03:57:29.945 --> 03:57:33.747
the fragment life cycle can be 
if you combine it with the full 

03:57:33.748 --> 03:57:38.965
activity life cycle as well.  
You can start up at the top here

03:57:45.304 --> 03:57:51.277
some more.  Whew, okay.  Well, 
we got to the end.  So the 

03:57:51.278 --> 03:57:53.673
blurriness that you're seeing 
here isn't just because it's a 

03:57:53.674 --> 03:57:57.273
low res version of the image, 
it's just your eyes glazeing 

03:57:57.274 --> 03:57:58.908
over 
as you try and take all of this 

03:57:58.909 --> 03:58:03.519
in.  This is kind of your 
reaction after reading over it.

03:58:08.918 --> 03:58:10.219
is 
kind of the reaction tharve has 

03:58:10.220 --> 03:58:13.270
had over the last few years out 
in the developer exphunt, why is

03:58:14.899 --> 03:58:17.623
community, why is it still 
something that we're pushing or 

03:58:17.624 --> 03:58:19.361
promoteing as a way to build 
your 

03:58:19.362 --> 03:58:22.432
applications?  To start with 
that, we'll go over a little bit

03:58:30.768 --> 03:58:33.494
Diane Hawthorne this past 
weekend where she went into some

03:58:35.445 --> 03:58:37.733
component model and how it's 
really not intended to I 

03:58:37.734 --> 03:58:41.443
remember to impose a 
lot of higher level architecture

03:58:43.388 --> 03:58:48.271
instead intended to be a series 
of entry points.  As a 

03:58:48.272 --> 03:58:50.456
traditional program you might 
have seen in classes, you start 

03:58:50.457 --> 03:58:51.874
from a main function, run to the

03:58:51.875 --> 03:58:55.995
end, you might start a message 
loop in the middle there and 

03:58:55.996 --> 03:58:58.716
what activities gives you is a 
smarter entry point, pay place 

03:58:58.717 --> 03:59:01.536
where the system can send you 
other messages about what's 

03:59:01.537 --> 03:59:02.947
going on to your application and

03:59:02.948 --> 03:59:07.633
these are just turned into call 
backs on an object instead.  So 

03:59:07.634 --> 03:59:08.845
there were some other goals kind

03:59:08.846 --> 03:59:12.215
of in the design of activities 
as well, which one of those is 

03:59:12.216 --> 03:59:15.280
that apps always stay in the 
state where you left them.  So 

03:59:15.281 --> 03:59:18.863
in order to do that, you have 
this well defined activity life 

03:59:18.864 --> 03:59:21.371
cycle and a compact state 
representation that you can use 

03:59:21.372 --> 03:59:24.509
so the process can die, come 
back later, restore from that 

03:59:24.510 --> 03:59:27.015
state.  All of this is stuff 
that you're probably familiar 

03:59:27.016 --> 03:59:31.811
with.  Also apps can call other 
apps to complete a task in the 

03:59:31.812 --> 03:59:34.965
form of activities called with 
intent and each one of those 

03:59:34.966 --> 03:59:37.682
flows is represented as one of 
these encapsulateed units in the

03:59:42.355 --> 03:59:47.226
over time activities just 
started getting big and complex 

03:59:47.227 --> 03:59:50.155
and basically the way you deal 
with complexity is that you 

03:59:50.156 --> 03:59:52.232
factor out smaller pieces so you

03:59:52.233 --> 03:59:58.988
can compose them.  Back in the 
pre-Android 3.0 days we had 

03:59:58.989 --> 04:00:02.584
these things called activity 
manager that could work in 

04:00:02.585 --> 04:00:07.054
concert with a co-host widget, 
so each one of these pieces and 

04:00:07.055 --> 04:00:08.359
each one of these tabs contained

04:00:08.360 --> 04:00:14.440
a full activity so that gave 
some weird pieces of the code 

04:00:14.441 --> 04:00:19.119
there in terms of how the code 
would interact.  There are ideas

04:00:20.652 --> 04:00:22.607
don't make sense of this kind of

04:00:22.608 --> 04:00:25.642
composed model.  Then this 
happened, and we're not going to

04:00:26.791 --> 04:00:28.791
(laughter)

04:00:30.551 --> 04:00:31.205
.
&gt;&gt; ADAM POWELL:  So larger 

04:00:31.206 --> 04:00:34.552
screens happened and larger 
screens mean larger problems.  

04:00:34.553 --> 04:00:37.275
So we have this idea of how do 
you want to present these 

04:00:37.276 --> 04:00:39.770
multiple small screens worth of 
UI that you may have already 

04:00:39.771 --> 04:00:41.189
built in an existing application

04:00:41.190 --> 04:00:44.354
and then sort of scale that out 
across other screens?  Is there 

04:00:44.355 --> 04:00:46.973
sort of a smaller unit of 
composition that you could use 

04:00:46.974 --> 04:00:50.991
for that?  And so that other 
unit of composition spoilers is 

04:00:50.992 --> 04:00:54.138
fragments.  So this was 
introduced around honeycomb to 

04:00:54.139 --> 04:00:57.603
try to solve some of these 
problems.  The first one of 

04:00:57.604 --> 04:01:00.542
these goals, though, was really 
just to break up these giant 

04:01:00.543 --> 04:01:02.822
activity classes and this is a 
problem that happens whether 

04:01:02.823 --> 04:01:05.215
you're dealing just with small 
phone screens or if you're 

04:01:05.216 --> 04:01:08.481
trying to scale across many 
different screen sizes, and it's

04:01:12.751 --> 04:01:15.772
complexity of these kind of big 
entry points that can kind of 

04:01:15.773 --> 04:01:20.460
grow to be these God objects if 
you're not careful.  We also 

04:01:20.461 --> 04:01:23.080
kind of wanted to fix some of 
these problems with local 

04:01:23.081 --> 04:01:24.825
activity manager for when you do

04:01:24.826 --> 04:01:28.098
compose them in these small 
constructs.  So you have lots of

04:01:30.164 --> 04:01:32.658
activity level that just don't 
work well when you start compose

04:01:32.753 --> 04:01:35.693
composing it this way.  These 
are usually things that aren't 

04:01:35.694 --> 04:01:38.431
quite as well covered as like 
the core activity state diagram 

04:01:38.432 --> 04:01:40.072
but they're all cases that still

04:01:40.073 --> 04:01:44.860
need to be handled in a general 
purpose solution.  One of the 

04:01:44.861 --> 04:01:48.237
other things that we wanted to 
do with frag mentz was to -- 

04:01:48.238 --> 04:01:52.065
fragments was to encapsulate 
navigation state.  So the state 

04:01:52.066 --> 04:01:56.201
of your fragments can represent 
the full state of your activity 

04:01:56.202 --> 04:02:01.745
in a way that can be preserveed 
through state save and restore 

04:02:01.746 --> 04:02:04.995
through a process step, so we 
have things like an activity 

04:02:04.996 --> 04:02:08.354
local back stack, which some 
people find useful and some 

04:02:08.355 --> 04:02:12.402
people don't, but manageed 
dialogues was one of the other 

04:02:12.403 --> 04:02:13.803
things that this really tried to

04:02:13.804 --> 04:02:17.498
address.  Dialogue fragment is 
go that a lot of people do use 

04:02:17.499 --> 04:02:20.438
at this point and it's because 
you basically get the state 

04:02:20.439 --> 04:02:25.461
restoration for free if you rho 
at a time screen or go through 

04:02:25.462 --> 04:02:29.394
configure changes.  This was 
provided by activities where you

04:02:32.019 --> 04:02:34.414
and there's this whole other 
creation process involved in 

04:02:34.415 --> 04:02:37.353
terms of yes I want to create 
the dialogue with this ID, we 

04:02:37.354 --> 04:02:39.206
would persist that ID and try to

04:02:39.207 --> 04:02:40.513
build everything up from scratch

04:02:40.514 --> 04:02:43.662
and that ended up being one-off 
and kind of awkward to work with

04:02:44.540 --> 04:02:47.149
with.  The final goal that was 
probably the most obvious in 

04:02:47.150 --> 04:02:50.405
terms of how we pitched the API 
when it was first released is 

04:02:50.406 --> 04:02:54.751
this idea of decomposing these 
master detail UI's.  So if you 

04:02:54.752 --> 04:02:56.392
have two screens that on a phone

04:02:56.393 --> 04:02:59.139
might look something like this 
where you have a list of 

04:02:59.140 --> 04:03:01.536
conversations as well as the 
actual conversation itself as 

04:03:01.537 --> 04:03:05.473
you drill down by tapping into 
it, use the back button to get 

04:03:05.474 --> 04:03:09.374
back to where you were before, 
in another configuration you 

04:03:09.375 --> 04:03:12.293
could take what's essentially 
the same code and have it look 

04:03:12.294 --> 04:03:17.206
like this, so this is something 
that you might be freshman with 

04:03:17.207 --> 04:03:19.479
familiar with 
from a lot of UI's that you've 

04:03:19.480 --> 04:03:22.645
seen.  Isn't then we've kept 
building on it.  So we had view 

04:03:22.646 --> 04:03:25.917
pager and the fragment pager 
adapter which a lot of people 

04:03:25.918 --> 04:03:28.638
still kind of think is the way 
to use a view pager just because

04:03:30.485 --> 04:03:33.862
for dealing with just bare views
views.  So we've got loaders, 

04:03:33.863 --> 04:03:37.251
which allow you to do similar 
things of persisting some sort 

04:03:37.252 --> 04:03:40.976
of a request across 
configuration changes, keep it 

04:03:40.977 --> 04:03:45.120
going, whether or not the life 
cycle might otherwise interrupt.

04:03:47.950 --> 04:03:50.567
medium about this that you 
should all read if you haven't 

04:03:50.568 --> 04:03:54.155
as well.  We also had this idea 
of child fragment.  If you can 

04:03:54.156 --> 04:03:57.520
Nest one legal deep in terms of 
putting fragments inside an 

04:03:57.521 --> 04:04:01.215
activity, why can't you put 
fragments inside a fragment that

04:04:02.855 --> 04:04:05.335
support in terms a lot of 
developers were requesting this 

04:04:05.336 --> 04:04:08.046
both within Google and external 
developers as well and it got 

04:04:08.047 --> 04:04:10.762
added I think sometime around 
the Jelly bean time frame

04:04:13.820 --> 04:04:15.990
.  So 
how did it work out?  I mean, 

04:04:15.991 --> 04:04:17.195
some of you kind of already know

04:04:17.196 --> 04:04:18.607
the answer to this question, but

04:04:18.608 --> 04:04:22.921
these are sort of what we took 
as stewards of the pa I, as some

04:04:27.051 --> 04:04:30.097
the first problem is that 
fragments are so general that 

04:04:30.098 --> 04:04:33.350
they become really difficult to 
explain to people.  So is it 

04:04:33.351 --> 04:04:38.134
just a pain of the UI, like in 
the Gmail example?  Is it 

04:04:38.135 --> 04:04:40.201
something like dialogue 
fragments and something meant to

04:04:42.376 --> 04:04:44.649
is it something different 
altogether like you can still 

04:04:44.650 --> 04:04:46.403
have headless fragments that can

04:04:46.404 --> 04:04:49.228
act completely independently of 
anything else?  We didn't give a

04:04:50.752 --> 04:04:54.772
of how to use these things 
because we kind of felt like we 

04:04:54.773 --> 04:04:57.266
didn't want to be too 
prescriptive about it and that 

04:04:57.267 --> 04:05:03.261
ended up really hurting us.  So 
of course the idea of even more 

04:05:03.263 --> 04:05:07.177
life cycle to manage was really 
kind of the killer here and the 

04:05:07.178 --> 04:05:10.320
bugs really didn't help.  This 
is really what killed a lot of 

04:05:10.321 --> 04:05:12.709
people.  Whenever I've talked to

04:05:12.724 --> 04:05:14.028
developers about what they would

04:05:14.029 --> 04:05:16.091
change about the fragment API or

04:05:16.092 --> 04:05:17.285
what problems they have in using

04:05:17.286 --> 04:05:19.662
the fragment API, a lot of times

04:05:19.663 --> 04:05:22.702
what happens is that you build 
up a fragment transaction, you 

04:05:22.703 --> 04:05:24.980
commit it, and then something 
works completely differently 

04:05:24.981 --> 04:05:29.325
from how you expect.  It's not 
particularly intuitive, some of 

04:05:29.326 --> 04:05:33.677
these things, and it might kind 
of remove the entire point of a 

04:05:33.678 --> 04:05:38.677
bunch of code that you just 
spent a lot of time writing.  So

04:05:39.869 --> 04:05:41.823
caused a lot of misconceptions. 

04:05:41.824 --> 04:05:45.214
I mean, fragments, they're just 
kind of like views, right?  You 

04:05:45.215 --> 04:05:48.795
can stick this fragment tags in 
one of your layout files, 

04:05:48.811 --> 04:05:51.507
inflate it, and you are get a 
fragment for free.  In hindsight

04:05:51.723 --> 04:05:55.533
hindsight, the fragment tag was 
this great piece of syntactic 

04:05:55.534 --> 04:05:58.471
sugar that really confused 
people more than it helped in 

04:05:58.472 --> 04:06:01.959
terms of general education.  So 
this immediately made people 

04:06:01.960 --> 04:06:05.015
think that fragment equals view 
and that this is on the same 

04:06:05.016 --> 04:06:12.322
level of abstraction.  So if we 
kind of know where things went 

04:06:12.323 --> 04:06:15.472
off the rails, then, you know, 
how might we start trying to use

04:06:17.325 --> 04:06:19.325
effectively?

04:06:21.035 --> 04:06:23.860
  Well, the first 
thing to keep in mind here is 

04:06:23.861 --> 04:06:26.688
that fragments are roughly 
equivalent to an activity in 

04:06:26.689 --> 04:06:29.408
terms of the level of 
abstraction that they act on.  

04:06:29.409 --> 04:06:33.196
They're come poseable entry 
points, and their life cycle and

04:06:35.581 --> 04:06:38.837
their surroundings.  They option
optionally manage a UI exprengs 

04:06:38.838 --> 04:06:41.764
they're really kind of -- 
presentation and they're really 

04:06:41.765 --> 04:06:45.255
kind of the whatever and model 
view whatever in terms of the 

04:06:45.256 --> 04:06:47.256
architectural patterns you may 
be using within your application

04:06:47.540 --> 04:06:50.247
application.  They're not views 
themselves, and they're really 

04:06:50.248 --> 04:06:54.162
not meant to be.  Seriously, 
they're not just fancy view 

04:06:54.163 --> 04:06:59.487
groups.  Fragments implement UI
UI's just by using views, they 

04:06:59.488 --> 04:07:01.875
compose views, they wire things 
up to views in order to do 

04:07:01.876 --> 04:07:05.458
something more interesting, and 
this really kind of comes down 

04:07:05.459 --> 04:07:08.832
to a core idea that isn't 
communicated 

04:07:08.848 --> 04:07:11.450
communicateed all that widely 
that we kind of keep this idea 

04:07:11.451 --> 04:07:15.571
of an abstraction hierarchy 
across the different packages 

04:07:15.572 --> 04:07:18.608
and the framework.  The higher 
level packages are things like 

04:07:18.609 --> 04:07:21.659
Android.app whereas the views 
and widgets are further down the

04:07:23.180 --> 04:07:25.886
practice in terms of the 
organization of code within the 

04:07:25.887 --> 04:07:29.569
Android framework is that 
anything at a higher level can 

04:07:29.570 --> 04:07:32.398
import anything from a lower 
level but not the other way 

04:07:32.399 --> 04:07:35.534
around, and if you go looking 
through AOSP, you'll probably 

04:07:35.535 --> 04:07:38.466
find a couple places where we 
messed this up, and yes, we know

04:07:38.684 --> 04:07:39.988
know, we're sorry.  But overall,

04:07:39.989 --> 04:07:41.392
it's managed to be a pretty good

04:07:41.393 --> 04:07:44.878
way of organizing some of this 
stuff and making sure that 

04:07:44.879 --> 04:07:48.131
things keep a level of 
responsibility that's kind of 

04:07:48.132 --> 04:07:52.734
appropriate for that type of 
component.  So an example of 

04:07:52.735 --> 04:07:59.163
this is that you might have a 
fragment that depends on a view 

04:07:59.164 --> 04:08:02.319
on click listener in order to 
implement that interface.  This 

04:08:02.320 --> 04:08:05.562
is an example of a fragment 
applying policy to a series of 

04:08:05.563 --> 04:08:08.436
views that it's using.

04:08:12.541 --> 04:08:14.934
  So while 
fragments can depend on views 

04:08:14.935 --> 04:08:18.734
and implement the interfaces 
exposed by those views, it's 

04:08:18.735 --> 04:08:20.921
important to remember that the 
views have no knowledge of 

04:08:20.922 --> 04:08:23.101
fragments, that fragments really

04:08:23.117 --> 04:08:28.125
kind of sit as the policy layer 
above whatever UI that you've 

04:08:28.130 --> 04:08:31.591
built visually and out of the 
structure that is used to 

04:08:31.607 --> 04:08:34.429
generate input events, so on and

04:08:34.430 --> 04:08:39.989
so forth.  So really they're 
kind of a glue component in this

04:08:43.479 --> 04:08:46.069
components or even of other 
components within your app.  

04:08:46.070 --> 04:08:50.089
They allow you to wire up the 
view event, the input eefnghts 

04:08:50.090 --> 04:08:51.731
that you may be generateing from

04:08:51.732 --> 04:08:55.721
those views and tell them 
something interesting to do, and

04:08:58.892 --> 04:09:02.161
life cycle.  What's going on 
outside the app?  What's going 

04:09:02.162 --> 04:09:07.643
on outside the context of that 
particular fragment or activity?

04:09:15.186 --> 04:09:18.892
fragment when just a composite 
custom view group or even just a

04:09:22.814 --> 04:09:25.323
include tag will do the job 
better.  A lot of people use 

04:09:25.324 --> 04:09:27.932
this as a point where they can 
pivot, where they can decide 

04:09:27.933 --> 04:09:30.100
what type of UI to show based on

04:09:30.101 --> 04:09:31.097
other conditions and between the

04:09:31.098 --> 04:09:33.811
rorgs system and custom view 
groups, you can solve that 

04:09:33.827 --> 04:09:39.149
problem without getting into 
life cycle constructs.  The real

04:09:40.795 --> 04:09:44.131
talking about using a custom 
view group or a fragment in 

04:09:44.132 --> 04:09:46.522
these cases is does it implement

04:09:46.523 --> 04:09:49.795
mechanism or does Tim pli meant 
policy?  Is it an isolateed 

04:09:49.810 --> 04:09:54.043
widget that generated its own 
input events?  These might be 

04:09:54.044 --> 04:09:56.861
really complex as well.  We've 
got some things in more recent 

04:09:56.862 --> 04:10:00.025
versions of the support library 
like coordinator layout that are

04:10:01.860 --> 04:10:04.902
behaviors on their child views, 
things that you can push and 

04:10:04.903 --> 04:10:09.238
pull and move around, stwiep 
dismiss, so -- swipe to dismiss,

04:10:11.084 --> 04:10:14.637
essentially the user acting on 
the UI.  You might be able to 

04:10:14.638 --> 04:10:18.761
swipe a snack bar apply, hit an 
ply button a snack bar and 

04:10:18.762 --> 04:10:21.879
coordinator layout or grks but 
what that actually means it the 

04:10:21.880 --> 04:10:23.740
application is policy imposeed 
by 

04:10:23.741 --> 04:10:25.257
some other component, and that's

04:10:25.258 --> 04:10:31.138
more where fragments sit in the 
layering.  So we also can't talk

04:10:34.523 --> 04:10:36.907
complexity without talking about

04:10:36.908 --> 04:10:39.073
safe state.  So the navigational

04:10:39.074 --> 04:10:42.765
state of your application is 
partially composed by the 

04:10:42.766 --> 04:10:46.889
fragments that are currently 
attached to it.  These may have 

04:10:46.890 --> 04:10:50.577
changed over time, con tengts 
may have shifted during flight, 

04:10:50.578 --> 04:10:53.501
so on and so forth wrrks if you 
have something like master 

04:10:53.517 --> 04:10:55.677
detail UI's, then you might have

04:10:55.678 --> 04:10:58.726
a very different fragment that 
usual showing, if you were 

04:10:58.727 --> 04:11:02.001
drilled into item A versus 
drilled into item B in that list

04:11:02.095 --> 04:11:04.496
list, and that's something that 
ideally you don't want to have 

04:11:04.500 --> 04:11:09.064
to track yourself in terms of 
other state as it gets restored 

04:11:09.065 --> 04:11:12.649
as your process dies, you come 
back into it, so on and so forth

04:11:12.894 --> 04:11:18.212
forth.  So that neens setup of 
fragments is conditional and 

04:11:18.213 --> 04:11:20.213
this is another one of those 
kind of weird things tharve sees

04:11:21.690 --> 04:11:24.718
with fragments.  Well, why am I 
doing this extra check here when

04:11:26.036 --> 04:11:27.345
state?  That's partially because

04:11:27.346 --> 04:11:32.350
the fragments are going to be re
restored as part of that on 

04:11:32.351 --> 04:11:35.343
create call.  Now, this has 
historically gotten a little bit

04:11:38.113 --> 04:11:42.452
with child frag mengts, when 
that -- fragments, when that re

04:11:42.666 --> 04:11:44.969
reinflation happens really 
wasn't consistent with the way 

04:11:44.970 --> 04:11:48.112
that fragments happen when 
attached to activities.  Now, 

04:11:48.113 --> 04:11:52.799
over the last several months, 
we've really kind of dived into 

04:11:52.800 --> 04:11:56.612
the fragment API's and tried to 
Klein a lot of these cases where

04:12:00.952 --> 04:12:03.650
are the things that really made 
people hate the API to start 

04:12:03.651 --> 04:12:07.016
with.  As of Android N and 
support library version 24, 

04:12:07.017 --> 04:12:10.704
which is available as part of 
the preview STK right now, child

04:12:12.334 --> 04:12:14.954
activity attached fragments, 
they're consistently reinflateed

04:12:21.926 --> 04:12:24.941
know those frag menltses that 
were restored from snanlt state 

04:12:24.946 --> 04:12:27.339
are -- end state are attached to

04:12:27.355 --> 04:12:29.289
your activity.  You won't end up

04:12:29.290 --> 04:12:31.786
with duplicates when you try to.
(applause).

04:12:31.833 --> 04:12:35.277
Deal with that case.  Thank you.

04:12:35.278 --> 04:12:38.406
So that alone makes things a 
whole lot easier to deal with it

04:12:38.624 --> 04:12:40.624
it.

04:12:44.302 --> 04:12:46.586
  The illegal state exception
exception?  Which one?  We'll 

04:12:46.587 --> 04:12:49.411
get to it in a minute.
(laughter).

04:12:49.458 --> 04:12:53.568
Okay.  So again, we keep coming 
back to this idea of fragment 

04:12:53.569 --> 04:12:55.732
states and that giant diagram of

04:12:55.733 --> 04:12:58.668
the so how do we just stop 
worrying and love the life cycle

04:13:00.299 --> 04:13:03.877
these stages of the life cycle 
really does represent a 

04:13:03.878 --> 04:13:06.910
significant event that can 
happen to your application, and 

04:13:06.911 --> 04:13:09.508
just because we have a lot of 
them there doesn't necessarily 

04:13:09.509 --> 04:13:10.691
mean that you have to care about

04:13:10.692 --> 04:13:12.543
all of them all the time.  A lot

04:13:12.544 --> 04:13:14.057
of fragments that you write will

04:13:14.058 --> 04:13:16.240
only implement a couple of these

04:13:16.241 --> 04:13:17.755
methods, but just having all the

04:13:17.756 --> 04:13:20.379
options there can really be 
overwhelming when you're just 

04:13:20.380 --> 04:13:24.186
looking at documentation.  So, 
you know, that big flow chart 

04:13:24.187 --> 04:13:26.682
accident like I couldn't tell 
you everything on that big flow 

04:13:26.683 --> 04:13:29.829
chart at once off the top of my 
head either, but the nice part 

04:13:29.830 --> 04:13:32.674
about this is that you really 
don't have to hold all of that 

04:13:32.675 --> 04:13:36.389
in your head at once because 
even though those interactions 

04:13:36.390 --> 04:13:39.653
look very complex, really the 
fragment life cycle is driven by

04:13:41.504 --> 04:13:45.212
integer value, so this is 
straight out of the frag 

04:13:45.213 --> 04:13:47.179
fragment 
source code where we have these 

04:13:47.180 --> 04:13:50.221
six states that fragments move 
between, and the nice thing 

04:13:50.222 --> 04:13:53.151
about these states is that this 
isn't like a completely connect

04:13:53.370 --> 04:13:54.794
connected graph of states.  This

04:13:54.795 --> 04:13:58.599
is linear.  So when fragments 
move from one state to another, 

04:13:58.600 --> 04:14:02.086
they move through all of the 
other states in turn, dispatch

04:14:02.211 --> 04:14:06.335
dispatching the appropriate 
methods to the fragment to deal 

04:14:06.336 --> 04:14:09.684
with those life cycle events.  
This leads to something really 

04:14:09.685 --> 04:14:12.181
kind of convenient, which is 
that all you need to think about

04:14:16.525 --> 04:14:19.337
can think your thinking very 
much constrained to each one of 

04:14:19.338 --> 04:14:21.937
these individual life cycle 
methods so that you don't have 

04:14:21.938 --> 04:14:24.968
to worry about the state of the 
entire application in aggregate 

04:14:24.969 --> 04:14:30.405
when you're dealing with this.  
More importantly, you can say 

04:14:30.406 --> 04:14:33.806
what minimum state will this 
component be in or what can I 

04:14:33.807 --> 04:14:37.298
count on?  Since again, the 
fragment states are linear, so 

04:14:37.299 --> 04:14:39.897
if you know that you're up all 
the way at the resumed state, 

04:14:39.898 --> 04:14:41.973
you know that you've been 
through all the other methods, 

04:14:41.974 --> 04:14:45.016
and this is one of those things 
that kind of seems obvious in 

04:14:45.017 --> 04:14:48.370
hindsight, but again, as you're 
looking through the smorgasbord 

04:14:48.371 --> 04:14:50.342
of methods that you can override

04:14:50.343 --> 04:14:54.466
on fragment itself, sometimes 
this kind of gets lost in the 

04:14:54.467 --> 04:15:01.348
noise.  So let's go ahead and 
talk about a few other things.  

04:15:01.349 --> 04:15:02.964
We talked about one bug fix that

04:15:02.965 --> 04:15:05.139
was pretty significant, which is

04:15:05.140 --> 04:15:08.511
that the child fragment manager 
state is guaranteed after the 

04:15:08.512 --> 04:15:12.095
super dot on create call.  Now, 
this is subtlely different from 

04:15:12.096 --> 04:15:14.914
what I said earlier about re
restoring fragments from instant

04:15:16.979 --> 04:15:20.550
really kind of fun bug that 
happens, so how many of you use 

04:15:20.551 --> 04:15:22.394
execute pending transactions for

04:15:22.395 --> 04:15:24.986
some part of your work with 
fragments or have tried in the 

04:15:24.987 --> 04:15:28.691
past?  Okay.  Keep your hand up 
if you ended up regretting doing

04:15:30.435 --> 04:15:33.583
later.  Okay.  Yeah, that's a 
pretty close match for some of 

04:15:33.584 --> 04:15:37.062
that.  So execute pending 
transactions is this really 

04:15:37.063 --> 04:15:40.210
handy method on the fragment 
manager that tells it, okay, all

04:15:44.213 --> 04:15:46.617
transaction.commit, do all of 
them right now, all of them that

04:15:49.016 --> 04:15:52.169
got a couple of kind of 
interesting issues with it that 

04:15:52.170 --> 04:15:55.428
we'll get into in a minute, but 
one of the interesting things 

04:15:55.429 --> 04:16:00.668
about that is that you have 
expectations after that call.  

04:16:00.669 --> 04:16:03.599
Specifically, if you've 
committed one or more fragment 

04:16:03.600 --> 04:16:06.855
transactions before that, then 
you expect those fragments that 

04:16:06.856 --> 04:16:09.462
you've committed in that 
transaction to be brought up to 

04:16:09.463 --> 04:16:12.721
a particular state in the life 
cycle, usually matching the 

04:16:12.722 --> 04:16:16.070
container.  Well, it turns out 
that that wasn't actually how 

04:16:16.071 --> 04:16:19.216
things worked.  Some of you 
probably found this out, and 

04:16:19.217 --> 04:16:23.014
this again came down to this 
idea of what happens with child 

04:16:23.015 --> 04:16:26.600
fragments.  You're probably 
noticing a bit of a theme here. 

04:16:29.425 --> 04:16:33.210
that the child fragment manager 
itself wouldn't be brought up to

04:16:37.827 --> 04:16:42.096
the parents on create returned, 
so all of these invariants that 

04:16:42.097 --> 04:16:45.145
should make it a lot more easy 
to reason about your program, 

04:16:45.146 --> 04:16:48.167
especially when you're saying 
that, hey, resolve everything 

04:16:48.168 --> 04:16:51.973
right now, execute pending 
transactions, all that just kind

04:16:54.360 --> 04:16:56.420
maid 
made things a lot more difficult

04:16:56.640 --> 04:16:59.123
difficult.  That's now fixed.  
So again you know that you don't

04:17:01.525 --> 04:17:04.872
the call on super.create.  
Executeing transactions had 

04:17:04.873 --> 04:17:06.282
another kind of problem as well,

04:17:06.283 --> 04:17:10.214
which was that it makes 
everything happen right now, and

04:17:11.743 --> 04:17:14.444
different parts of your program 
might be committing fragment 

04:17:14.445 --> 04:17:16.628
transactions at different times,

04:17:16.629 --> 04:17:19.556
so as soon as you say execute 
pending transaction in one piece

04:17:19.665 --> 04:17:23.042
piece, you may have just caused 
a side effect that affects some 

04:17:23.043 --> 04:17:26.625
other library that you imported 
that uses fragments and you 

04:17:26.626 --> 04:17:30.645
didn't even know about it.  So 
we went ahead and added a commit

04:17:32.595 --> 04:17:33.572
transaction which basically does

04:17:33.573 --> 04:17:36.923
the same thing but really kind 
of what you wanted instead, 

04:17:36.924 --> 04:17:40.288
which is just this transaction, 
commit this one right now.  This

04:17:43.333 --> 04:17:45.722
limitation, which is that you 
can't deal with fragments on the

04:17:48.007 --> 04:17:50.609
now, just because if you have 
other fragment transactions 

04:17:50.610 --> 04:17:53.977
pending, you don't kind of want 
to create inversion inside your 

04:17:53.978 --> 04:17:59.309
back stack in terms of when 
those really apply.  We also 

04:17:59.310 --> 04:18:03.638
added a fragment on attach 
fragment method to match the 

04:18:03.639 --> 04:18:06.881
fragment activity and activity 
on attach fragment method.  This

04:18:08.408 --> 04:18:11.336
to go ahead and configure a 
fragment as it's being attached 

04:18:11.337 --> 04:18:12.639
to its parent, if you want to do

04:18:12.640 --> 04:18:15.336
any sort of injection of 
dependencies or, if you want to 

04:18:15.337 --> 04:18:19.589
do any sort of wiring up much 
listeners within that local 

04:18:19.590 --> 04:18:22.417
activity for other events that 
it might publish, this is a 

04:18:22.418 --> 04:18:23.822
pretty good time to do it except

04:18:23.823 --> 04:18:25.566
there really wasn't a good place

04:18:25.567 --> 04:18:28.714
to do this with schield 
fragments before. -- with child 

04:18:28.715 --> 04:18:30.668
fragments before.  This was 
something that was entirely 

04:18:30.669 --> 04:18:33.490
skipped.  You couldn't even do 
it in the parent activity if you

04:18:35.464 --> 04:18:36.553
called on in the parent activity

04:18:36.554 --> 04:18:39.270
if and only if the fragment was 
attached directly to the 

04:18:39.271 --> 04:18:45.690
activity, not any of the 
children.  So a few other notes 

04:18:45.691 --> 04:18:48.714
that are kind of useful here.  
This is one that some developers

04:18:50.988 --> 04:18:55.763
fixed some other bugs around 
fragment transitions, which is 

04:18:55.764 --> 04:18:59.995
that to obtain the state of a 
fragment transition, we have to 

04:18:59.996 --> 04:19:02.801
interrogate the fragment, we 
have to call a method on the 

04:19:02.802 --> 04:19:05.844
fragment to get the transition 
values and what it should do, 

04:19:05.845 --> 04:19:08.752
but in order to make that make 
sense to that fragment, we have 

04:19:08.753 --> 04:19:11.792
to bring the fragment up to the 
created state before we ask it 

04:19:11.793 --> 04:19:16.238
about the transition.  So what 
that means, in effect, is that 

04:19:16.239 --> 04:19:19.285
we have to bring some fragments 
up to the createed state before 

04:19:19.286 --> 04:19:22.555
they become fully attached or 
before they replace whatever 

04:19:22.556 --> 04:19:24.835
fragment that they were 
replacing before.  So this is 

04:19:24.836 --> 04:19:28.086
one of those things that's good 
to be aware of.  Don't assume 

04:19:28.087 --> 04:19:30.705
that just because your fragment 
goes through the attach and 

04:19:30.706 --> 04:19:33.529
create steps that all of the 
other surrounding state about a 

04:19:33.530 --> 04:19:36.259
fragment transaction has 
necessarily happened yet.  Again

04:19:36.590 --> 04:19:38.868
Again, this is something that 
you want to make sure that you 

04:19:38.869 --> 04:19:42.214
keep your thinking within a 
fragment implementation scoped 

04:19:42.215 --> 04:19:45.472
just to that fragment.  Make 
sure that's not trying to take 

04:19:45.473 --> 04:19:50.900
on responsibilities outside of 
itself.  And again, they really 

04:19:50.901 --> 04:19:54.053
work best when they can behave 
as isolated from their 

04:19:54.054 --> 04:19:55.136
surroundings.  One of the things

04:19:55.137 --> 04:19:58.608
aI see people do a lot is that 
when a fragment becomes attached

04:19:58.936 --> 04:20:02.623
attached, and again, just 
because you have problems with 

04:20:02.624 --> 04:20:05.555
state restoration of more 
complex objects, it's pretty 

04:20:05.556 --> 04:20:08.920
common for people to say okay, 
when people get attached to my 

04:20:08.921 --> 04:20:12.957
fifth, I'm going to go ahead -- 
attached to my activity, I'm 

04:20:12.958 --> 04:20:15.978
going to go ahead, grab the 
activity and go phishing, see if

04:20:17.937 --> 04:20:19.996
fragments by tag, grab any other

04:20:19.997 --> 04:20:23.151
sort of associated information 
from that activity, downcast it 

04:20:23.154 --> 04:20:25.441
to a specific type, so on and so

04:20:25.442 --> 04:20:27.071
forth.  While this ends up being

04:20:27.072 --> 04:20:28.261
pretty convenient, it also means

04:20:28.262 --> 04:20:31.737
that those fragments suddenly 
become a whole lot less reusable

04:20:34.768 --> 04:20:37.508
outset, it is one of those 
things that tends to come back 

04:20:37.509 --> 04:20:40.538
and bite people later on, then 
they wonder why didn't we have 

04:20:40.539 --> 04:20:46.403
some other facility to do this, 
to do a cleaner injection of the

04:20:48.906 --> 04:20:50.314
forth
forth?  So that was a lot of 

04:20:50.315 --> 04:20:54.018
information really fast.  Some 
of it probably didn't answer a 

04:20:54.019 --> 04:20:56.083
lot of the core questions that 
you may have had coming in here,

04:20:57.822 --> 04:21:02.833
don't like this API that I've 
used, like change my mind, why 

04:21:02.834 --> 04:21:07.863
should I go back and give it 
another chance?  Really the core

04:21:09.905 --> 04:21:13.806
getting any smaller.  So when 
you start working especially 

04:21:13.807 --> 04:21:17.750
across large teams and across 
code bases that have lasted for 

04:21:17.751 --> 04:21:21.825
a very long time, architectural 
patterns don't end up being 

04:21:21.826 --> 04:21:25.301
universal, and this is part of 
what Diane was trying to get 

04:21:25.302 --> 04:21:28.682
into in her post over the week 
as well.  If you have a very 

04:21:28.683 --> 04:21:31.938
long-lived code base, then what 
was popular and the obvious way 

04:21:31.939 --> 04:21:33.569
that everyone should build their

04:21:33.570 --> 04:21:35.196
apps back when the code base was

04:21:35.197 --> 04:21:37.477
started isn't necessarily true 
when you're maintaining it years

04:21:43.338 --> 04:21:48.009
to that is to try to create 
standard, smarter components.  

04:21:48.010 --> 04:21:51.181
So how many of you have taken a 
look at integration steps for 

04:21:51.182 --> 04:21:52.694
some library for Android and you

04:21:52.695 --> 04:21:54.209
see something that looks kind of

04:21:54.210 --> 04:21:57.142
like what's on the slide here?  
Okay, go ahead and add this 

04:21:57.143 --> 04:22:01.925
snipt to your own create, this 
thing to your own start, this to

04:22:05.506 --> 04:22:09.309
libraries from Google have this 
as well, things you need to call

04:22:11.369 --> 04:22:13.415
cycle.  That make these types of

04:22:13.416 --> 04:22:16.144
integrations really kind of 
messy.  Soin stead of that, well

04:22:16.362 --> 04:22:19.078
well, we could just have add 
this fragment instead and we'll 

04:22:19.079 --> 04:22:22.462
go ahead and take care of those 
extra life cycle steps.  That 

04:22:22.463 --> 04:22:26.150
suddenly makes that a lot more 
reusable and a lot less error-

04:22:26.260 --> 04:22:30.386
error-prone.  The nice thing 
about this is really that, oh, 

04:22:30.387 --> 04:22:34.076
or even brert better, you can 
just use 

04:22:34.077 --> 04:22:36.788
one of these tags.  Even though 
we had issues around kind of 

04:22:36.789 --> 04:22:39.410
general education around 
fragments on what they could do,

04:22:41.038 --> 04:22:43.525
to say here is a piece of my UI,

04:22:43.526 --> 04:22:45.806
I just want to drop this 
completely self-contained 

04:22:45.807 --> 04:22:48.297
component here and then not 
think about it, to be able to 

04:22:48.300 --> 04:22:51.774
just configure it possibly from 
other XML attributes as 

04:22:51.775 --> 04:22:58.625
specified there and then just 
let that component do its thing.

04:23:00.452 --> 04:23:03.290
try and provide these single 
points of high-level integration

04:23:05.020 --> 04:23:06.759
last part is really key.  Again,

04:23:06.760 --> 04:23:09.579
not everyone is going to be 
using the same architectural 

04:23:09.580 --> 04:23:12.400
patterns that your app does and 
your own app may not use those 

04:23:12.401 --> 04:23:13.707
patterns the same wale over time

04:23:13.708 --> 04:23:16.973
either, but fragments are kind 
of uniquely positioned here, and

04:23:18.701 --> 04:23:21.535
closely mirror that activity 
life cycle.  There are a few 

04:23:21.536 --> 04:23:24.582
differences here and there, but 
by and large, like as you're 

04:23:24.583 --> 04:23:27.731
thinking about invariance to 
enforce within a fragment, they 

04:23:27.732 --> 04:23:30.231
really match what you do with 
activities as part of that core 

04:23:30.232 --> 04:23:33.802
entry point idea for Android 
components.  So that means that 

04:23:33.803 --> 04:23:38.242
essentially they can sit below 
that level abstraction of your 

04:23:38.243 --> 04:23:40.727
higher level architecture that 
you impose upon your application

04:23:42.895 --> 04:23:47.608
component in the same way that 
views are reusable to fragments.

04:23:50.266 --> 04:23:52.266
communicateing with the rest of 
the world, you really need to be

04:23:53.765 --> 04:23:54.833
configuration dependent siz that

04:23:54.834 --> 04:23:59.104
you I understand up creating 
dpaish dependencyies that you 

04:23:59.105 --> 04:24:01.164
end 
up creating.  Again, this comes 

04:24:01.165 --> 04:24:04.213
down to that issue of are you 
going phishing in your parent 

04:24:04.214 --> 04:24:07.570
activity or in your parent 
fragment for other dependencies 

04:24:07.571 --> 04:24:11.276
and is that fragment going on 
blow up in those things aren't 

04:24:11.277 --> 04:24:14.216
there?  Are those dependencies 
documented?  How is someone use 

04:24:14.217 --> 04:24:16.067
that go fragment necessarily 
going to know that's a 

04:24:16.068 --> 04:24:19.002
requirement?  In a code base 
within a particular team, again,

04:24:20.650 --> 04:24:26.668
as things grow over time, we 
tend to see a lot of these 

04:24:26.669 --> 04:24:30.049
patterns show up.  That means 
that you really do need to 

04:24:30.065 --> 04:24:32.119
consider your audience as you're

04:24:32.120 --> 04:24:33.991
building these things.  If 
you're building Lyle bone marrow

04:24:37.158 --> 04:24:40.204
building libraryies, the answer 
is going to be a lot different 

04:24:40.205 --> 04:24:43.376
than if just building a screen 
in your own application.  Your 

04:24:43.377 --> 04:24:46.853
own application, sure, go ahead 
and take a dependency on some 

04:24:46.854 --> 04:24:50.783
internal component.  It might 
help, but at the very least 

04:24:50.784 --> 04:24:54.489
you're not passing this out to 
the rest of the wider world.  

04:24:54.491 --> 04:24:58.256
Also if you are offering the 
ability to use fragments that 

04:24:58.257 --> 04:25:01.862
are these standalone drop-in 
components, the uninflate method

04:25:03.921 --> 04:25:06.971
these, so this lets you do the 
same thing that you do with 

04:25:06.972 --> 04:25:09.694
views:  Specify some 
configuration attributes.  It 

04:25:09.698 --> 04:25:13.156
might be something like an API 
key, it might be something like 

04:25:13.157 --> 04:25:16.415
any other sort of information 
that you need to pass to that 

04:25:16.416 --> 04:25:19.584
fragment as arguments but you 
can do it without having to muck

04:25:21.536 --> 04:25:23.601
necessarily during that initial 
start-up phase of your 

04:25:23.617 --> 04:25:27.421
application, because again, you 
want to try to have one 

04:25:27.422 --> 04:25:31.555
integration point with these 
things.  All right.  So this 

04:25:31.556 --> 04:25:34.490
talk wouldn't be complete if I 
didn't open myself up to the mic

04:25:36.662 --> 04:25:45.576
answers.  So come on up.  Sure.
&gt;&gt; Hi.  Two questions.  First of

04:25:50.032 --> 04:25:53.082
commit now, other stuff.
&gt;&gt; ADAM POWELL:  Yes, those are 

04:25:53.083 --> 04:25:55.677
coming into version 24 of the 
support library, you can use 

04:25:55.678 --> 04:25:58.627
that now in developer cr preview

04:25:58.628 --> 04:26:03.287
3.  The unattach fragments for 
parent fragments didn't make the

04:26:07.320 --> 04:26:08.587
3-RBGS but that will be in the 
next.

04:26:08.588 --> 04:26:14.412
&gt;&gt; What about the fragments, 
like if you're looking in the 

04:26:14.413 --> 04:26:17.898
source code, you find the show 
is using the old commit.

04:26:17.899 --> 04:26:20.514
&gt;&gt; ADAM POWELL:  Dialogue 
fragment.  Yes.  There are a 

04:26:20.515 --> 04:26:23.874
bunch of exoanltses in the core 
parts -- there are a bunch of 

04:26:23.875 --> 04:26:26.692
components in the core parts.  
Dialogue fragments, also the 

04:26:26.693 --> 04:26:28.546
fragment page dapter was another

04:26:28.547 --> 04:26:31.388
one of these things used to 
execute pending transactions and

04:26:32.895 --> 04:26:35.717
about that.  Those have been up
updated to use commit now where 

04:26:35.718 --> 04:26:38.203
it makes sense already.
&gt;&gt; Do you have any 

04:26:38.204 --> 04:26:41.469
recommendations on handling 
illegal state exceptions?

04:26:41.532 --> 04:26:43.532
(laughter)

04:26:44.858 --> 04:26:45.075
.
&gt;&gt; ADAM POWELL:  Any 

04:26:45.076 --> 04:26:46.481
recommendations on illegal state

04:26:46.482 --> 04:26:49.749
exceptions.  I assume what you 
mean is the wurch that comes up 

04:26:49.750 --> 04:26:51.377
when state -- the one that comes

04:26:51.378 --> 04:26:53.770
up when state has already been 
saved for the activity.  Is that

04:26:54.064 --> 04:26:56.160
&gt;&gt; Yeah.
&gt;&gt; ADAM POWELL:  Okay.  This is 

04:26:56.161 --> 04:26:58.551
really case by case and it's 
part of the reason why we have 

04:26:58.552 --> 04:27:02.997
this idea of commit versus 
commit allowing a state loss.  

04:27:02.998 --> 04:27:07.668
It's kind of up to your app in 
some of these cases, and 

04:27:07.669 --> 04:27:10.384
sometimes you can tolerate the 
state loss of if a fragment 

04:27:10.385 --> 04:27:13.320
transaction didn't happen, 
sometimes you really don't want 

04:27:13.321 --> 04:27:16.263
that to happen.  The biggest 
issue where it tends to come up 

04:27:16.264 --> 04:27:20.172
is when you're responding to a 
button click or some other sort 

04:27:20.173 --> 04:27:22.366
of asynchronous event.  It might

04:27:22.367 --> 04:27:25.731
happen as a result of a network 
request, so on and so forth.  A 

04:27:25.732 --> 04:27:29.753
lot of those you're just going 
to have to make the call of how 

04:27:29.754 --> 04:27:32.148
valid it is to kind of drop that

04:27:32.149 --> 04:27:34.540
on the floor in the worst case 
scenario where your process dies

04:27:36.937 --> 04:27:40.074
case by case.  If it's general 
navigation state, I would say 

04:27:40.075 --> 04:27:45.392
that commit allowing state loss 
isn't a huge deal.  The user 

04:27:45.393 --> 04:27:48.006
will be a little confused as 
they come back and they're at a 

04:27:48.007 --> 04:27:51.589
previous screen from maybe what 
they expected, but again, you 

04:27:51.590 --> 04:27:53.879
can use some other mechanisms in

04:27:53.880 --> 04:27:58.780
there as well, like since the 
fragments are going to know 

04:27:58.781 --> 04:28:00.189
about the listeners that they've

04:28:00.190 --> 04:28:03.130
attached to those buttons and 
sort of what to deal with or 

04:28:03.131 --> 04:28:07.251
your activity will know about 
that, then you can gauge that on

04:28:09.207 --> 04:28:12.351
stop state for that component, 
so forth, that's one way to deal

04:28:14.090 --> 04:28:16.276
listeners entirely when you 
become stopped, but overall it 

04:28:16.277 --> 04:28:18.778
really kind of depends on what 
it's doing.  If you're able to 

04:28:18.779 --> 04:28:21.058
let the state drop on the floor,

04:28:21.059 --> 04:28:24.429
then committing state loss can 
be just fine.

04:28:24.626 --> 04:28:30.421
&gt;&gt; This one is kind of a little 
more specific.  With certain 

04:28:30.422 --> 04:28:32.597
libraries that have used kind of

04:28:32.598 --> 04:28:34.554
fragments to encapsulate a bunch

04:28:34.555 --> 04:28:39.427
of action, more specifically 
like Android Pay.  Do you have 

04:28:39.428 --> 04:28:43.340
any advice with using those for 
things like recyclers where it's

04:28:44.859 --> 04:28:48.418
get something basically the 
Android Pay button is the best 

04:28:48.419 --> 04:28:51.569
example I have right now, just 
kind of to live in that life 

04:28:51.570 --> 04:28:54.506
cycle or anything like that or 
any advice for that or any best 

04:28:54.507 --> 04:28:56.783
practices we can look up?
&gt;&gt; ADAM POWELL:  Definitely stay

04:28:58.315 --> 04:29:01.146
something we're looking into 
pretty closely, the question 

04:29:01.147 --> 04:29:02.549
specifically being around adding

04:29:02.550 --> 04:29:05.586
fragments to recycling 
containers like a recycling view

04:29:05.820 --> 04:29:08.423
view.  List view will probably 
be a little more difficult but 

04:29:08.424 --> 04:29:09.830
it's definitely been on our mind

04:29:09.831 --> 04:29:12.330
through the development of re
recycler view that this is 

04:29:12.331 --> 04:29:13.308
something we're going to want to

04:29:13.309 --> 04:29:17.767
do.  So I think that it's still 
like some developers have kind 

04:29:17.768 --> 04:29:20.894
of dove into it and they've 
fowrched some effective -- found

04:29:22.725 --> 04:29:25.534
can definitely do it the way 
that view pager does in the 

04:29:25.535 --> 04:29:27.294
pager adapters, if you're really

04:29:27.295 --> 04:29:30.552
careful about when those things 
get committed.  Recycler view 

04:29:30.553 --> 04:29:36.436
and others have some pretty 
strict requirements over 

04:29:36.437 --> 04:29:37.632
basically just like when some of

04:29:37.633 --> 04:29:41.220
these things need to happen, 
like they need to know that this

04:29:42.520 --> 04:29:45.234
view holder, so on and so forth.

04:29:45.235 --> 04:29:48.170
I think that we need to put out 
some better documentation on 

04:29:48.171 --> 04:29:51.540
that at the very least and it 
may come along with a few other 

04:29:51.541 --> 04:29:55.574
API changes to recycler view.
&gt;&gt; Sounds great.  Thank you.

04:29:55.644 --> 04:30:00.026
&gt;&gt; My question touches upon the 
commit allowing state loss.  So 

04:30:00.027 --> 04:30:01.544
if you have a scenario where you

04:30:01.545 --> 04:30:06.219
have one fragment and that's 
talking to the server, then the 

04:30:06.220 --> 04:30:09.343
user backgrounds the app, the 
response comes back from the 

04:30:09.344 --> 04:30:13.164
server and that fragment needs 
to transition to some other 

04:30:13.165 --> 04:30:17.313
fragment.  At that point if we 
use commit allowing state loss, 

04:30:17.314 --> 04:30:18.711
what are the recommendations for

04:30:18.712 --> 04:30:23.043
doing that?  Is it okay to use 
it?  Is it not okay?

04:30:23.044 --> 04:30:24.888
&gt;&gt; ADAM POWELL:  What you might 
want to think about, and I'm 

04:30:24.889 --> 04:30:27.931
going to go ahead and plug in on

04:30:27.932 --> 04:30:33.477
loaders on this one is that a 
lot of these requests that are a

04:30:33.699 --> 04:30:37.398
async, you can use a loader to 
encapsulate that request.  Not 

04:30:37.399 --> 04:30:40.230
only will that give you 
stability across other configure

04:30:43.807 --> 04:30:47.154
deal with the load finished 
operation.  Basically you can 

04:30:47.155 --> 04:30:51.282
make sure that you will defer 
dealing with that until you've 

04:30:51.283 --> 04:30:54.315
become started again if the 
fragment has already become 

04:30:54.316 --> 04:30:58.677
stopped.  So I would say that's 
probably the most automated way 

04:30:58.678 --> 04:31:01.598
of dealing with that sort of 
thing, but you can re-create a 

04:31:01.599 --> 04:31:04.531
similar mechanism without 
loaders as well.

04:31:04.578 --> 04:31:10.124
&gt;&gt; I see.  So if there is no 
state to be saved, I mean, I'm 

04:31:10.125 --> 04:31:13.786
okay, I don't have any data to 
save in that state, then I'm 

04:31:13.787 --> 04:31:15.787
okay with committing

04:31:17.584 --> 04:31:19.561
 state loss, 
right?

04:31:19.562 --> 04:31:20.308
&gt;&gt; ADAM POWELL:  Definitely.  If

04:31:20.309 --> 04:31:24.755
the data you're representing 
doesn't represent a conditional,

04:31:26.824 --> 04:31:29.079
drops on the floor, it's okay 
for the user.

04:31:29.141 --> 04:31:32.365
&gt;&gt; Thank you.
&gt;&gt; One of the very difficult 

04:31:32.366 --> 04:31:34.861
problems that I have is whenever

04:31:34.862 --> 04:31:37.688
you want topped a fragment 
transaction, -- to do a fragment

04:31:45.171 --> 04:31:48.431
that?  Because then you'll deal 
with the state exception for 

04:31:48.432 --> 04:31:49.516
sure.
&gt;&gt; ADAM POWELL:  Yes, because 

04:31:49.517 --> 04:31:53.257
that ends up happening a little 
bit too early.

04:31:56.718 --> 04:32:00.186
&gt;&gt; Or are you looking at better 
aligning the activity methods 

04:32:00.187 --> 04:32:03.236
with the life cycle methods?
&gt;&gt; ADAM POWELL:  We did a bunch 

04:32:03.237 --> 04:32:05.521
of work on that.  The activity 
result issue in particular 

04:32:05.522 --> 04:32:08.121
around committing new fragment 
transactions I don't think we 

04:32:08.122 --> 04:32:11.597
got to.  Let me take a note on 
that and get a better answer for

04:32:11.770 --> 04:32:14.314
&gt;&gt; Okay on, cool.  Thanks.
&gt;&gt; ADAM POWELL:  You're welcome.

04:32:14.315 --> 04:32:18.664
&gt;&gt; I'm a little bit confused 
about implementing master 

04:32:18.665 --> 04:32:23.238
details now, when you said 
fragments should be isolateed.  

04:32:23.239 --> 04:32:25.239
I 
can't isolate the detail section

04:32:27.361 --> 04:32:31.056
master fragment, so that's one 
question.  The other question is

04:32:31.274 --> 04:32:36.376
is, when you look at a more 
complicated master detail like 

04:32:36.377 --> 04:32:37.461
five system navigation where you

04:32:37.462 --> 04:32:40.708
have a full blown tree, how does

04:32:40.709 --> 04:32:43.298
that work?  So what do you think

04:32:43.299 --> 04:32:48.632
I should avoid or how to fix my 
app in general?

04:32:48.633 --> 04:32:49.501
&gt;&gt; ADAM POWELL:  I would say try

04:32:49.502 --> 04:32:53.629
to keep a fairly tree-shaped 
model of ownership in terms of 

04:32:53.630 --> 04:32:56.667
those components and make sure 
that you have a single owner for

04:33:01.582 --> 04:33:04.950
item is this concept that is 
relevant to both the master and 

04:33:04.951 --> 04:33:07.982
detail views, then perhaps 
that's a piece of state that 

04:33:07.983 --> 04:33:10.801
belongs in a parent to both of 
those instead and that way that 

04:33:10.802 --> 04:33:14.511
parent is able to to go ahead 
and configure both of those 

04:33:14.512 --> 04:33:18.210
fragments and provide that imlu 
and wireup in the same way that 

04:33:18.211 --> 04:33:21.759
happens with other forms of nest
nesting.

04:33:21.821 --> 04:33:24.350
&gt;&gt; But then I'll have to do the 
phishing you talked about from 

04:33:24.351 --> 04:33:26.749
the fragment up.
&gt;&gt; ADAM POWELL:  Not necessarily

04:33:26.983 --> 04:33:30.436
necessarily.  If you set either 
the listeners or some other 

04:33:30.437 --> 04:33:32.295
similar construct, do dependency

04:33:32.296 --> 04:33:35.233
injection, anything like that 
from the parent to the fragments

04:33:35.670 --> 04:33:38.824
fragments, then the fragments 
themselves will already have 

04:33:38.825 --> 04:33:41.104
those resources when they need 
to have them available and 

04:33:41.105 --> 04:33:43.806
they'll go ahead and get events 
when those changes occur.

04:33:43.869 --> 04:33:47.834
&gt;&gt; So your advice is inversion 
of control?

04:33:47.835 --> 04:33:48.441
&gt;&gt; ADAM POWELL:  A little bit, 
yes.

04:33:48.442 --> 04:33:52.383
&gt;&gt; Awesome.  Thanks.
&gt;&gt; Hi.  Could you explain a 

04:33:52.398 --> 04:33:53.578
little more what you meant about

04:33:53.579 --> 04:33:56.527
the difference between policy 
and mechanism?

04:33:56.528 --> 04:34:00.422
&gt;&gt; ADAM POWELL:  Sure.  I mean, 
I guess in like Git terms, it's 

04:34:00.423 --> 04:34:03.357
a little bit like the porcelain 
versus the plumbing.  It's the 

04:34:03.358 --> 04:34:10.121
idea of what are you seeing at 
the top level at the interaction

04:34:12.832 --> 04:34:16.843
versus what are the elements 
that are being composeed to 

04:34:16.844 --> 04:34:19.559
create those interactions.  So 
for example, a button would be 

04:34:19.560 --> 04:34:24.915
just pure mechanism.  A button 
clicks, a button can be focused,

04:34:26.987 --> 04:34:29.607
it, so forth, but it doesn't 
really do anything in the 

04:34:29.608 --> 04:34:34.061
context of your app oits own.  
You have on its own.  

04:34:34.063 --> 04:34:37.638
You have to attach a listener 
and populate it with text, so 

04:34:37.639 --> 04:34:41.446
forth.  It's that that's really 
acting in that same role that I 

04:34:41.447 --> 04:34:46.675
meant in terms policy in that 
case.

04:34:46.737 --> 04:34:49.940
&gt;&gt; Another question sort of 
related to illegal state loss.  

04:34:49.941 --> 04:34:53.742
The answer may be the same to 
look at in like post end loaders

04:34:54.176 --> 04:34:58.312
loaders, but one specific 
instance that we have, we've 

04:34:58.313 --> 04:35:01.635
encountered a number of times is

04:35:01.636 --> 04:35:06.673
showing a progress dialogue and 
a dialogue fragment and since 

04:35:06.674 --> 04:35:10.255
it's saved in the state, it 
handles it across rotation, 

04:35:10.256 --> 04:35:14.719
which is great, but then if the 
user backgrounds the app, then 

04:35:14.720 --> 04:35:17.005
it finishes attempting to 
dismiss that dialogue

04:35:20.266 --> 04:35:22.000
 doesn't 
work because we can do a commit 

04:35:22.001 --> 04:35:27.990
allowing state loss but it 
wouldn't dismiss it because un

04:35:28.318 --> 04:35:30.160
unsaved state has already 
occurred.  What would your 

04:35:30.161 --> 04:35:32.759
recommendation be for dealing 
with that situation.

04:35:32.760 --> 04:35:34.490
&gt;&gt; ADAM POWELL:  I'm trying to 
understand a little better.  You

04:35:35.794 --> 04:35:39.266
representing some operation in 
flight.  First off, progress 

04:35:39.267 --> 04:35:41.534
dialogues are evil and from a UX

04:35:41.535 --> 04:35:44.467
perspective, but the same sort 
of thing shows up if you're 

04:35:44.468 --> 04:35:46.735
showing like a progress spinning

04:35:46.736 --> 04:35:50.554
line or something like that to 
begin with.  So you've got this 

04:35:50.555 --> 04:35:51.853
operation in flight and you want

04:35:51.854 --> 04:35:55.523
to swap that out for the real 
content afterwards, is that 

04:35:55.524 --> 04:35:59.780
correct?
&gt;&gt; Yeah, basically 

04:35:59.781 --> 04:36:06.366
uninterruptible action, so to 
speak, and then at some point 

04:36:06.367 --> 04:36:10.992
after that action is done, the 
progress dialogue goes away and 

04:36:10.993 --> 04:36:14.896
then something happens, but the 
goal, our goal would be to avoid

04:36:17.618 --> 04:36:20.667
there when the user comes back 
to the app even though the 

04:36:20.671 --> 04:36:22.671
action has already finished

04:36:24.592 --> 04:36:25.019
.
&gt;&gt; ADAM POWELL:  So you want to 

04:36:25.020 --> 04:36:28.616
have it go away entirely, 
regardless.  So that when you 

04:36:28.617 --> 04:36:31.445
bring the other window back to 
the front, then you're not 

04:36:31.446 --> 04:36:33.183
seeing the progress dialogue for

04:36:33.184 --> 04:36:36.438
that split second as you're 
dismissing it, or is it just 

04:36:36.439 --> 04:36:39.369
kind of the issue of what to do 
when you end up in that 

04:36:39.370 --> 04:36:41.435
inconsistent state?
&gt;&gt; Yes.  Since it was dismissed,

04:36:44.807 --> 04:36:47.423
post saved instant state, that 
it would be there still when you

04:36:49.161 --> 04:36:51.656
restoration.
&gt;&gt; Best way I've seen for 

04:36:51.657 --> 04:36:53.880
dealing with that

04:36:59.213 --> 04:37:00.624
 is that you 
have the operation in flight and

04:37:02.244 --> 04:37:03.982
flight when saved instance state

04:37:03.983 --> 04:37:06.262
occurs, you want to record that 
that operation was still in 

04:37:06.263 --> 04:37:08.871
flight somehow, then when you 
come back on the other side or 

04:37:08.872 --> 04:37:11.039
even just when you receive on 
start again, when you become 

04:37:11.040 --> 04:37:13.437
visible again, then you can 
perform the other cleanup at 

04:37:13.438 --> 04:37:17.682
that point rather than doing it 
immediately there.  As I was 

04:37:17.683 --> 04:37:20.077
aloud 
alluding to to start with, it 

04:37:20.078 --> 04:37:24.992
might provide a little bit of a 
visual jink there because you 

04:37:24.993 --> 04:37:27.368
might come back later and you 
see that progress dialogue for a

04:37:28.455 --> 04:37:31.057
disappears, so you could 
probably work with some kind of 

04:37:31.058 --> 04:37:35.603
hybrid solution there just to 
get rid of that visual jink, do 

04:37:35.604 --> 04:37:38.441
the committing state losses but 
still record that operation was 

04:37:38.442 --> 04:37:39.959
still in flight and wire that up

04:37:39.960 --> 04:37:42.568
on the other side.  This is the 
sort of thing that loaders are 

04:37:42.569 --> 04:37:44.296
really good at.
&gt;&gt; Thank you.

04:37:44.297 --> 04:37:48.662
&gt;&gt; ADAM POWELL:  Sure.
&gt;&gt; Can you explain more about un

04:37:48.880 --> 04:37:54.394
uninflate?  You said one uses 
more of them.

04:37:54.395 --> 04:37:56.364
&gt;&gt; ADAM POWELL:  I'm sorry.  I 
skimmed over that a little 

04:37:56.365 --> 04:38:00.057
quickly.  So fragments have an 
on inflate method that receives 

04:38:00.058 --> 04:38:03.552
the attribute set that was used 
to inflate during the layout 

04:38:03.553 --> 04:38:06.713
inflation process, so just as 
when you're inflateing a custom 

04:38:06.714 --> 04:38:08.441
view, you get that attribute set

04:38:08.442 --> 04:38:11.954
and you can read out a bunch of 
configure values and apply them.

04:38:18.644 --> 04:38:21.246
just specified in layout XML and

04:38:21.247 --> 04:38:24.722
apply those to the fragments 
arguments bundle or so forth.

04:38:24.723 --> 04:38:27.874
&gt;&gt; Oh, to pass information to 
the fragment basically?

04:38:27.875 --> 04:38:30.358
&gt;&gt; ADAM POWELL:  Yeah, and it's 
mostly configuration information

04:38:32.200 --> 04:38:34.970
place like that.
&gt;&gt; Thank you.

04:38:43.350 --> 04:38:48.668
&gt;&gt; Dprag meant apps I have a 
question.  So one of the things 

04:38:48.669 --> 04:38:53.114
that I see missing is a simple 
like on fragment visible user 

04:38:53.115 --> 04:38:57.137
and on fragment hidden from user
user.  That's a very common 

04:38:57.138 --> 04:39:04.219
scenario where you want to like 
fetch some fresh data for the 

04:39:04.220 --> 04:39:06.067
user to see?
&gt;&gt; ADAM POWELL:  This is 

04:39:06.068 --> 04:39:08.357
entirely a failure of our 
documentation because this is 

04:39:08.358 --> 04:39:10.425
there.  Fragments have a method 
method --

04:39:10.499 --> 04:39:15.329
&gt;&gt; Okay.  I know of the set use
usability method but there's no 

04:39:15.330 --> 04:39:18.477
life cycle method associated 
with that so you have to kind of

04:39:20.548 --> 04:39:21.305
&gt;&gt; ADAM POWELL:  What we did for

04:39:21.306 --> 04:39:24.478
that so far, you're right, it's 
not part of the life cycle in 

04:39:24.479 --> 04:39:28.155
that case, again, this kind of 
ties into the loader idea, is 

04:39:28.156 --> 04:39:31.412
that if the visible fragment, if

04:39:31.413 --> 04:39:33.034
you have invisible fragments but

04:39:33.035 --> 04:39:36.191
a visible fragment has loaders 
associated with it, then we'll 

04:39:36.192 --> 04:39:41.077
defer the start phase of the 
other fragments that rnlt are 

04:39:41.078 --> 04:39:42.916
not 
user visible until the loaders 

04:39:42.917 --> 04:39:45.628
in other start phase has 
completely occurred for the 

04:39:45.629 --> 04:39:48.444
visible fragment so we can 
prioritize a lot of those things

04:39:48.553 --> 04:39:50.616
things, but it sounds like 
you're probably asking for 

04:39:50.617 --> 04:39:51.585
something a little more detailed

04:39:51.586 --> 04:39:53.214
than that, like probably a phase

04:39:53.215 --> 04:39:57.582
where you can start and stop 
animations or something similar.

04:39:57.583 --> 04:40:00.092
&gt;&gt; Simple thing would be like 
I'm looking at my fantasy roster

04:40:02.465 --> 04:40:05.501
standings and I want to look at 
the lateest lateest settings or 

04:40:05.502 --> 04:40:07.395
something 
to my matchups and want to see 

04:40:07.396 --> 04:40:11.966
the latest match-up score 
because there's a game happening

04:40:12.184 --> 04:40:14.905
happening.  That's where you 
want to fetch some fresh data 

04:40:14.906 --> 04:40:17.722
when the user comes to that page
page?

04:40:17.723 --> 04:40:19.137
&gt;&gt; ADAM POWELL:  I see.  In that

04:40:19.138 --> 04:40:23.692
case you want something that's 
akin to that aim sort same sort 

04:40:23.693 --> 04:40:25.693
of 
transition edge call Belle

04:40:28.581 --> 04:40:29.996
back.
&gt;&gt; Yeah.

04:40:29.997 --> 04:40:32.171
&gt;&gt; ADAM POWELL:  That's a good 
idea.  We'll take a look at it.

04:40:32.172 --> 04:40:35.651
&gt;&gt; Thank you.
&gt;&gt; Hi.  What do you think of 

04:40:35.652 --> 04:40:38.366
activity on the module fragments

04:40:38.367 --> 04:40:41.841
while building an app?  Is this 
good or not?  And do you 

04:40:41.842 --> 04:40:46.747
recommend this pattern?
&gt;&gt; ADAM POWELL:  Okay.  So 

04:40:46.748 --> 04:40:49.362
you're saying just one activity 
with multiple fragments?

04:40:49.440 --> 04:40:51.206
&gt;&gt; Yeah.
&gt;&gt; ADAM POWELL:  Kind of the 

04:40:51.207 --> 04:40:54.140
equivalent of like a single page

04:40:54.141 --> 04:40:56.525
web app in a lot of ways.
&gt;&gt; Yeah.

04:40:56.526 --> 04:41:01.733
&gt;&gt; ADAM POWELL:  I would say it 
has the same merits as single 

04:41:01.734 --> 04:41:04.881
page apps on the web.  In the 
sphorm of that activity acting 

04:41:04.882 --> 04:41:07.693
as a container for those 
fragments, then by all means, 

04:41:07.694 --> 04:41:10.526
yeah, that can totally work.  
What you're trading off, though,

04:41:12.471 --> 04:41:14.526
points for your application.  So

04:41:14.527 --> 04:41:18.128
for example, if you have the 
ability to deep link into some 

04:41:18.129 --> 04:41:21.939
parts of your am caig from like 
another of your application from

04:41:23.245 --> 04:41:27.269
would open that one activity in 
line, then that case will get 

04:41:27.270 --> 04:41:29.765
more complicated because you'll 
want to have that entry point 

04:41:29.766 --> 04:41:32.912
for deep linking into your 
application with a specific 

04:41:32.913 --> 04:41:37.280
detail view that might be ash 
temporarily far down -- ash 

04:41:37.281 --> 04:41:45.755
temporarily far down -- tash 
arbitrary.  You can have a 

04:41:45.756 --> 04:41:49.353
container using only for those 
deep links and stick normal 

04:41:49.354 --> 04:41:53.052
detail fragments for viewing 
that content into that one 

04:41:53.053 --> 04:41:55.552
container, but then you have to 
deal with this idea of what task

04:41:57.164 --> 04:41:59.884
it lives in the context of the 
calling task, then things are 

04:41:59.885 --> 04:42:02.828
pretty easy, you hit back, 
activity finishes, user goes on 

04:42:02.829 --> 04:42:05.660
their way.  In most cases I 
would say that's probably the 

04:42:05.661 --> 04:42:08.152
way to go when dealing with 
those types of interactions, but

04:42:10.213 --> 04:42:14.235
trade-offs in terms of other 
entry points using a few more 

04:42:14.236 --> 04:42:19.194
activities can sometimes make 
things a little bit easier to 

04:42:19.195 --> 04:42:21.912
reason about in terms of those 
because you don't have as many 

04:42:21.913 --> 04:42:26.268
duplicated code paths.
&gt;&gt; Thank you.

04:42:26.269 --> 04:42:27.130
&gt;&gt; ADAM POWELL:  Do we have time

04:42:27.131 --> 04:42:31.680
for one more?  No.  Okay.  Meet 
right outside, and I would be 

04:42:31.681 --> 04:42:35.610
glad to take your question.  
Thank you all for coming.

04:42:35.657 --> 04:42:37.657
(The session concluded at

04:42:42.083 --> 04:42:44.083
 5:46 
5:46 p.m.

04:42:46.336 --> 04:42:48.336
)

04:49:42.368 --> 04:49:46.338
May 18, 2016.

04:49:54.043 --> 04:49:55.086
&gt;&gt; 
&gt;&gt; 

04:49:55.087 --> 04:49:56.064
&gt;&gt; 
&gt;&gt; 

04:49:56.065 --> 04:49:57.131
&gt;&gt; 
&gt;&gt; 

04:49:57.132 --> 04:49:59.157
&gt;&gt; 
&gt;&gt; 

04:49:59.219 --> 04:50:04.699
May 18, 2016.
LM1.

04:50:04.746 --> 04:50:06.746
Location and Proximity

04:50:10.460 --> 04:50:13.546
 Super
Superpours

04:50:35.366 --> 04:50:45.166
superarepoweraresuperSuper
Superpowers,

04:50:46.150 --> 04:50:48.162
 he had store

04:50:51.692 --> 04:50:57.295
powers, Eddystore and 
Google.

04:59:18.791 --> 04:59:20.791
.

05:01:34.202 --> 05:01:36.202
.

05:01:48.480 --> 05:01:52.187
&gt;&gt; PETER LEWIS:  All right.  
Hello.  Hello, everybody, and 

05:01:52.188 --> 05:01:58.668
welcome.  My name is Peter, and 
I am the product manager for 

05:01:58.669 --> 05:02:03.662
Eddystone and the Google Beacon 
platform, and I am uncomfortable

05:02:04.218 --> 05:02:06.510
ly 
excited today to be talking to 

05:02:06.511 --> 05:02:09.223
you about location and proximity

05:02:09.224 --> 05:02:12.806
Superpowers.  So we'll cover a 
whole bunch of stuff, and it's 

05:02:12.807 --> 05:02:19.104
going to be awesome.  So if my 
clicker works.  Oh, that was the

05:02:21.803 --> 05:02:24.750
get into some code, but before 
we do that, I want to introduce 

05:02:24.751 --> 05:02:31.496
you to my dog.  This is Oscar.  
Oscar is like my sidekick, I 

05:02:31.497 --> 05:02:34.878
suppose, if we're talking about 
Superpowers.  He is a four

05:02:34.879 --> 05:02:39.210
four-year-old Papion and one of 
my favorite things is taking him

05:02:42.358 --> 05:02:43.875
near where I live and taking him

05:02:43.876 --> 05:02:48.446
for a long walk amongst all the 
trees and the bushes, and while 

05:02:48.447 --> 05:02:51.825
I'm walking along are he's 
constantly sniffing, discovering

05:02:53.676 --> 05:02:57.042
is this an important bush?  Is 
this a stick I should be playing

05:03:00.406 --> 05:03:07.354
of all of the important places 
and objects that are around him 

05:03:07.355 --> 05:03:12.569
and this session is about to 
make your users' devices almost 

05:03:12.570 --> 05:03:19.478
as awesome as Oscar.
(laughter).

05:03:20.940 --> 05:03:22.907
  So today I want to talk to you

05:03:22.908 --> 05:03:25.859
a bit about a few sort of 
location-based experiences.  

05:03:25.860 --> 05:03:30.204
Here are a few examples from 
within Google apps.  In the 

05:03:30.205 --> 05:03:33.143
photos app I can search for 
photos I took when I was at 

05:03:33.144 --> 05:03:37.277
Google in New York, there's 
timeline for helping users to re

05:03:37.713 --> 05:03:41.382
rediscover places that they've 
been to and experiences they've 

05:03:41.383 --> 05:03:44.323
had out there, and then there's 
sort of popular times for one of

05:03:46.492 --> 05:03:48.339
London that reminds me it's been

05:03:48.340 --> 05:03:50.494
two months, I should probably go

05:03:50.495 --> 05:03:55.824
again.  And these kind of 
location-based experiences make 

05:03:55.825 --> 05:03:58.854
apps really compelling.  If you 
can provide services to your 

05:03:58.855 --> 05:04:02.435
users that take accounted of the

05:04:02.436 --> 05:04:04.172
important places -- take account

05:04:04.173 --> 05:04:06.669
of the important places and 
objects to them, then you can 

05:04:06.670 --> 05:04:12.106
build engagements and be much 
more successful.  So all of 

05:04:12.107 --> 05:04:16.682
these are powder by a 
complicated array of sense he is

05:04:19.063 --> 05:04:22.428
experience at the end of it is 
really simple.  They use WiFi, 

05:04:22.429 --> 05:04:26.664
cell tower location, GPS to 
produce this kind of thing.  But

05:04:30.472 --> 05:04:34.275
to develop your own apps and 
even in cases where you don't 

05:04:34.276 --> 05:04:41.042
have an app on top of this 
platform of the so today we will

05:04:43.759 --> 05:04:47.120
the open beacon format from 
Google, and we want to make it 

05:04:47.121 --> 05:04:50.599
so that the beacons you have on 
your desk actually become useful

05:04:56.038 --> 05:04:58.756
beacons with the Cloud so that 
you can think of them much more 

05:04:58.757 --> 05:05:01.677
like Cloud objects.  That, we're

05:05:01.678 --> 05:05:04.159
going to talk about attachments,

05:05:04.160 --> 05:05:08.007
subscriptions and nearby and 
sharing those beacons with 

05:05:08.008 --> 05:05:11.152
others so that this physical 
widget gets all of the power of 

05:05:11.153 --> 05:05:16.705
the Cloud.  Then last up, we're 
going to talk about something 

05:05:16.706 --> 05:05:21.599
new that was announced an hour 
ago in stage 1 I think, powering

05:05:23.230 --> 05:05:25.845
through Google.  So even in the 
case where you don't have your 

05:05:25.846 --> 05:05:28.991
app installed, how can you use 
beacons to bring awesome 

05:05:28.992 --> 05:05:33.006
experiences to your users?  So 
what is the technology we're 

05:05:33.007 --> 05:05:34.635
going to use?  Well, we're going

05:05:34.636 --> 05:05:42.360
to use beacons, and in fact, 
beacons are not new at all, if I

05:05:45.946 --> 05:05:49.312
Beacons are not new.  So here is

05:05:49.313 --> 05:05:53.333
an example of a beacon, a 
lighthouse, and all of the 

05:05:53.334 --> 05:05:56.592
components of the Google beacon 
platform are similar to a 

05:05:56.593 --> 05:06:00.175
lighthouse and a ship at sea.  
So you have the lighthouse 

05:06:00.176 --> 05:06:03.987
itself.  That's the Eddystone 
beacon.  It just sits there and 

05:06:03.988 --> 05:06:09.194
it broadcasts an identifier to 
the world.  Meanwhile, out at 

05:06:09.195 --> 05:06:11.382
sea, the captain of the ship has

05:06:11.383 --> 05:06:14.423
got their telescope.  They're 
looking out for all of the 

05:06:14.424 --> 05:06:17.476
beacons that are around the 
coastlines of countries.  That's

05:06:21.372 --> 05:06:27.664
and the Cocopod for iOS.  But 
just sighting the beacon is not 

05:06:27.665 --> 05:06:29.420
that useful.  You'll also need a

05:06:29.421 --> 05:06:35.275
chart with all of the beacons 
mapped out on it to look at 

05:06:35.276 --> 05:06:39.081
exactly where you are and that 
chart is provided by the 

05:06:39.082 --> 05:06:42.445
proximity beacon API which is 
the Cloud service you can use to

05:06:45.601 --> 05:06:48.746
So we'll go through each of 
those parts but with the Google 

05:06:48.747 --> 05:06:52.004
beacon platform rather than 
lighthouses and ships, and by 

05:06:52.005 --> 05:06:55.137
the end this session, you'll be 
able to build awesome beacon 

05:06:55.138 --> 05:06:58.288
powered experiences in your app 
and also we're going on give you

05:07:00.675 --> 05:07:04.585
beacons in the cases where your 
app is not yet on the user's 

05:07:04.586 --> 05:07:12.210
device.  So what is a BLE beacon
beacon?  Well, I have one just 

05:07:12.211 --> 05:07:16.575
here.  They're sort of simple 
typically battery-powered 

05:07:16.576 --> 05:07:18.750
devices that you can use to mark

05:07:18.751 --> 05:07:22.012
important places and objects in 
the world.  You stick them on 

05:07:22.013 --> 05:07:25.154
the object, and they just 
broadcast an identifier.  They 

05:07:25.155 --> 05:07:30.052
do exactly one thing.  The 
identifier that they broadcast 

05:07:30.053 --> 05:07:32.863
is only 31 bytes long and by the

05:07:32.864 --> 05:07:36.012
time you've got rid of all the 
headers, there's not really much

05:07:38.074 --> 05:07:42.209
placing an abstract identifier 
in your beacon that you mark, 

05:07:42.210 --> 05:07:44.164
you make deviceers that come 
near 

05:07:44.165 --> 05:07:48.513
it aware of that place.  Because

05:07:48.514 --> 05:07:51.794
beacons only accept connections 
from devices when they're being 

05:07:51.795 --> 05:07:55.268
configured, they're really good 
for deploying in public places. 

05:07:58.974 --> 05:08:02.121
Bluetooth things all the time.  
You just want your user's device

05:08:03.858 --> 05:08:09.305
important places and objects 
around it so beacons have been 

05:08:09.306 --> 05:08:12.335
around for a little while and 
Bluetooth beacons have as well, 

05:08:12.336 --> 05:08:16.998
and in the olden days, we sort 
of had this model that you would

05:08:18.841 --> 05:08:21.878
to a particular app, and it 
would probably power a 

05:08:21.879 --> 05:08:24.592
particular feature in that app. 

05:08:24.593 --> 05:08:27.511
We're taking a slightly 
different approach with 

05:08:27.512 --> 05:08:34.265
Eddystone and the Google beacon 
platform.  We're interested in 

05:08:34.266 --> 05:08:38.934
having one beacon or many 
beacons with many uses.  So you 

05:08:38.935 --> 05:08:42.510
deploy your infrastructure once 
and then you can reuse it 

05:08:42.511 --> 05:08:43.820
multiple times in different apps

05:08:43.821 --> 05:08:47.312
from different people all coming

05:08:47.313 --> 05:08:53.920
to your venue.  So what is step 
1?  Well, we've provided an app 

05:08:53.921 --> 05:08:57.377
for you to get started.  It's 
called beacon Teelz available on

05:09:04.895 --> 05:09:06.762
, available 
on the Play Store, download this

05:09:08.390 --> 05:09:12.515
to beacons, it's an app that 
allows you to register beacons 

05:09:12.516 --> 05:09:13.822
with the Google Cloud Platform. 

05:09:13.823 --> 05:09:17.728
So it sits between the beacon 
and proximity beacon API.  You 

05:09:17.743 --> 05:09:19.792
can register beacons that have a

05:09:19.793 --> 05:09:21.514
number of different frame types.

05:09:21.515 --> 05:09:25.547
This is the complete Eddystone 
specification.  There are four 

05:09:25.548 --> 05:09:29.886
frame types in Eddystone.  
There's Eddystone UID, which is 

05:09:29.887 --> 05:09:34.776
the abstract market for a 
particular place.  For cases 

05:09:34.777 --> 05:09:37.825
where you're interested in 
controlling who has access to 

05:09:37.826 --> 05:09:41.944
your beacon signal, there's 
Eddystone EID, and I'll talk 

05:09:41.945 --> 05:09:45.537
about that a bit in a minimum 
nut.  The third frame stiep a 

05:09:45.538 --> 05:09:48.894
telemetry frame.  This reports 
on the beacon's battery level, 

05:09:48.895 --> 05:09:50.740
which makes it easy to monitor a

05:09:50.741 --> 05:09:54.089
fleet of beacons once they're 
deployed in the wild.  Then 

05:09:54.090 --> 05:09:59.651
finally you can put a pretty 
tiny URL into the beacon frame 

05:09:59.652 --> 05:10:02.696
itself and Eddystone URL 
formingz the backbone of the 

05:10:02.697 --> 05:10:05.954
physical web. -- forms the 
backbone of the physical web cht

05:10:07.692 --> 05:10:11.595
Eddystone EID and you can see 
I've made a beacon with a pretty

05:10:13.212 --> 05:10:15.166
What that represents is that the

05:10:15.167 --> 05:10:18.761
beacon frame itself is 
continuously changing.  Soif a 

05:10:18.762 --> 05:10:22.564
beacon, it's broadcasting one 
frame, then a few nints later 

05:10:22.565 --> 05:10:25.273
it's broadcasting a different 
frame.  Your beacon general 

05:10:25.274 --> 05:10:28.639
ratings those frames based upon 
a cryptographic key that's 

05:10:28.640 --> 05:10:31.576
stored within the beacon itself.

05:10:31.577 --> 05:10:34.420
That key is also shared with 
another service, which is able 

05:10:34.421 --> 05:10:38.226
to resolve a siting of that 
particular beacon to a stable ID

05:10:39.856 --> 05:10:44.953
in your app.  It's particularly 
goold for cases where you want 

05:10:44.954 --> 05:10:47.123
to control who has access to the

05:10:47.124 --> 05:10:51.572
beacon signal that you're 
deploying.  The good news is 

05:10:51.573 --> 05:10:57.108
that all of our API's support UI
UID and EID transparently, so 

05:10:57.109 --> 05:11:00.058
you don't have to bother 
thinking about the EID.  You can

05:11:05.701 --> 05:11:11.914
them both through the same 
nearby API and Android.  So 

05:11:11.915 --> 05:11:17.136
that's Eddystone.  We've got 
static identifiers, which are 

05:11:17.137 --> 05:11:19.308
are in 
a sense the simplest way to get 

05:11:19.309 --> 05:11:21.483
started, and we've got ephemeral

05:11:21.484 --> 05:11:23.978
identifiers, these are the ones 
that are ideal for controlling 

05:11:23.979 --> 05:11:25.496
your beacon signal.  That's just

05:11:25.497 --> 05:11:30.053
the beacon itself.  The real 
power comes from the Cloud 

05:11:30.054 --> 05:11:35.793
service that you associate, 
where you put that beacon.  And 

05:11:35.794 --> 05:11:42.237
that is fronted by proximity 
beacon API.  Proximity beacon AP

05:11:42.268 --> 05:11:45.736
API fronts Google's beacon 
registry that allows you to 

05:11:45.737 --> 05:11:48.231
register beacons, associate 
information with them, and add 

05:11:48.233 --> 05:11:49.854
attachments which can be used by

05:11:49.855 --> 05:11:56.515
your own app.  So a beacon 
object looks a bit like this.  

05:11:56.516 --> 05:12:00.071
I've represented it as a box.  
Within the box we've got three 

05:12:00.072 --> 05:12:03.236
attachments represented by these

05:12:03.237 --> 05:12:07.797
three colors.  So let's have a 
look at the beacon registry 

05:12:07.798 --> 05:12:12.142
entry itself.  Here is the list 
of properties that you can 

05:12:12.143 --> 05:12:17.154
associate with a beacon.  First 
up you can assign the beacon a 

05:12:17.155 --> 05:12:18.570
description.  The description of

05:12:18.571 --> 05:12:21.934
the beacon is your human 
readable name for that 

05:12:21.935 --> 05:12:24.871
particular beacon, and we'll 
talk a bit about how you can 

05:12:24.874 --> 05:12:27.569
search for things like that 
later.  You can add properties 

05:12:27.570 --> 05:12:31.476
to a beacon, so it's sometimes 
useful to remember the transmit 

05:12:31.477 --> 05:12:32.970
power that you associateed with 
a 

05:12:32.971 --> 05:12:36.570
particular beacon or some other 
properties that are relevant to 

05:12:36.571 --> 05:12:40.969
your particular venue.  Then the

05:12:40.970 --> 05:12:45.094
next set of objects is to do 
with place and location.  When 

05:12:45.095 --> 05:12:48.028
you register a beacon with 
Google, you can associate a 

05:12:48.029 --> 05:12:50.511
place ID with it which goes into

05:12:50.512 --> 05:12:55.410
the heart of Google's location 
infrastructure.  So all of the 

05:12:55.411 --> 05:12:57.040
outer place functionality that I

05:12:57.041 --> 05:13:00.515
showed earlier just gets better 
when you have a beacon signal 

05:13:00.516 --> 05:13:06.487
registered with a place ID.  As 
well as that, beacons enable new

05:13:09.515 --> 05:13:10.721
in particular, you can associate

05:13:10.722 --> 05:13:13.752
within indoor level with a 
beacon, which makes it much 

05:13:13.753 --> 05:13:19.163
easier for your app to detect 
which level a user is on in a 

05:13:19.164 --> 05:13:22.092
building.  This last field, 
expected stability, allows you 

05:13:22.093 --> 05:13:25.335
to distinguish between beacons 
that you deploy in a static 

05:13:25.336 --> 05:13:26.964
place, sort of marking important

05:13:26.965 --> 05:13:30.435
places in a building, and those 
perhaps that are on a bus or a 

05:13:30.436 --> 05:13:37.081
food truck or poo move around.  
Finally we have the ephemeral ID

05:13:41.316 --> 05:13:46.308
support Eddystone EID.  So if 
you're using Eddystone EID bee 

05:13:46.309 --> 05:13:50.760
corngz you'll need to 
beacons, you'll need to talk to 

05:13:50.761 --> 05:13:53.797
this part of the API.  Finally, 
when you provision a beacon 

05:13:53.798 --> 05:13:55.972
using the Eddystone gap service,

05:13:55.973 --> 05:13:58.362
there is a key you can use to 
unlock that particular hardware 

05:13:58.363 --> 05:13:59.990
and we can store that for you to

05:13:59.991 --> 05:14:05.545
make beacon administration 
easier later on.  So what's next

05:14:05.872 --> 05:14:07.189
next?  We have a beacon, we have

05:14:07.190 --> 05:14:10.443
a Cloud service.  On a user's 
device in the middle we have the

05:14:13.268 --> 05:14:18.813
you on a sort of brief tour of 
the nearby API showing how you 

05:14:18.814 --> 05:14:22.820
can use it to fetch attachments 
back to your beacon, back to 

05:14:22.821 --> 05:14:28.525
your user's device.  So this is 
what you need to put in your 

05:14:28.526 --> 05:14:32.113
manifest.  It's important that 
you put your API key to talk to 

05:14:32.114 --> 05:14:38.084
the nearby mess saj's API.  You 
also need a service running in 

05:14:38.099 --> 05:14:43.616
the background if you want 
background beacon scanning, and 

05:14:43.617 --> 05:14:46.331
you can also put intent filters 
in your manifest as well.  

05:14:46.347 --> 05:14:48.720
That's something you should do 
because of a reason I'm going to

05:14:52.306 --> 05:14:55.809
you've connected to the API, 
once you've connected to Google 

05:14:55.812 --> 05:14:59.373
Play services and your Android 
activity, then this is the meat 

05:14:59.374 --> 05:15:01.668
of your sub subscription.  So 
this 

05:15:01.669 --> 05:15:03.824
is where you tell the nearby API

05:15:03.825 --> 05:15:06.860
that I'm interested in 
attachments for particular name 

05:15:06.861 --> 05:15:10.889
space and a particular type.  
It's that line on the set filter

05:15:12.900 --> 05:15:17.839
filter.  So what happens next?  
Well, the nearby API takes all 

05:15:17.840 --> 05:15:21.205
of the information that you've 
given it and it does beacon 

05:15:21.206 --> 05:15:25.332
scanning for you.  Notice that 
you don't have to care about the

05:15:27.924 --> 05:15:31.721
broadcasting.  You've created a 
subscription to a Cloud object, 

05:15:31.722 --> 05:15:34.642
nearby it's going on hide all 
the sophistication in the 

05:15:34.643 --> 05:15:40.931
background.  So nearby goes out 
looking for beacons and when it 

05:15:40.932 --> 05:15:42.904
does beacon scans, it shows them

05:15:42.905 --> 05:15:44.964
across all apps that have active

05:15:44.965 --> 05:15:48.093
subscriptions, as well as that 
when the Android platform does 

05:15:48.094 --> 05:15:51.696
scans, they're also shared to 
nearby, so you get a lot more 

05:15:51.697 --> 05:15:56.595
scans for a lot less battery use
use.  When nearby comes out and 

05:15:56.596 --> 05:16:01.699
finds a beacon, it will query 
the proximity beacon API to say,

05:16:03.885 --> 05:16:07.994
don't know what it means, and 
proximity beacon API will return

05:16:11.263 --> 05:16:15.815
that you had subscribed tovment 
let's take a to.  

05:16:15.816 --> 05:16:17.442
Let's look at what an attachment

05:16:17.443 --> 05:16:20.631
looks like.  They're pretty 
simple objects.  They have these

05:16:24.338 --> 05:16:29.224
the project.  The name space is 
owned by your project, so you 

05:16:29.225 --> 05:16:32.698
have a name space for your 
particular Developer Console 

05:16:32.699 --> 05:16:34.647
project.  After that you can put

05:16:34.648 --> 05:16:39.116
a type for each attachment.  
That could be platforms at a 

05:16:39.117 --> 05:16:40.622
station or it could be different

05:16:40.623 --> 05:16:44.731
types of vehicle.  It can be 
anything you want.  Then the 

05:16:44.732 --> 05:16:48.105
second field is the data that 
you associate with that beacon 

05:16:48.106 --> 05:16:53.002
under that name space type.  So 
this is where you put the 

05:16:53.003 --> 05:16:55.593
information that you actually 
want to get back in your app 

05:16:55.594 --> 05:16:59.424
when your user sights that 
particular beacon.  If you're 

05:16:59.425 --> 05:17:03.022
calling the API directly, 
remember to base 64 and code it,

05:17:04.759 --> 05:17:10.513
for you.  So nearby had the 
subscription to a particular 

05:17:10.514 --> 05:17:13.673
name space and type, proximity 
beacon API decided if there were

05:17:15.283 --> 05:17:20.730
that had been seen that 
correlate with your particular 

05:17:20.731 --> 05:17:23.239
subscription and then those 
attachments are returned to your

05:17:30.418 --> 05:17:32.358
morning, if you don't care about

05:17:32.359 --> 05:17:36.482
sort of integrateing with API's 
and so on, you can use the 

05:17:36.483 --> 05:17:38.981
beacon dashboard.  This is a web

05:17:38.982 --> 05:17:43.671
dashboard that actual uses the 
JavaScript client library to 

05:17:43.672 --> 05:17:47.472
proximity beacon API and allows 
you to visualize all of your 

05:17:47.473 --> 05:17:49.113
beacons and edit the information

05:17:49.114 --> 05:17:52.283
associateed with them.  So for a

05:17:52.284 --> 05:17:55.879
particular beacon object, 
registering a beacon just become

05:17:56.315 --> 05:18:01.753
becomes filling in a bunch of 
fields on here.  We think this 

05:18:01.769 --> 05:18:05.440
is really cool.  You can also 
add attachments.  Here is an 

05:18:05.441 --> 05:18:08.045
example an attachment that I 
added this morning.  And you can

05:18:09.758 --> 05:18:13.571
filling in two fields on a web 
dashboard.  You now have a 

05:18:13.572 --> 05:18:18.235
registered de deacon beacon and 
an 

05:18:18.236 --> 05:18:21.271
attachment associated with it.  
So where have we come?  Well, we

05:18:24.748 --> 05:18:27.789
provisioned it using Beacon 
Tools, which you can get from 

05:18:27.790 --> 05:18:32.686
the Play Store or the iOS app 
store, then we associateed that 

05:18:32.687 --> 05:18:35.836
beacon in the Cloud with 
proximity beacon API which allow

05:18:36.055 --> 05:18:37.698
allowed us to create this beacon

05:18:37.699 --> 05:18:42.364
object and add attachments to it
it.  If you didn't want to call 

05:18:42.365 --> 05:18:46.599
the API, we had the dashboard, 
and then down in the bottom 

05:18:46.600 --> 05:18:49.745
right we've got the model of 
what happens when a user's 

05:18:49.746 --> 05:18:53.016
device comes across a beacon, 
and as I said earlier, it 

05:18:53.031 --> 05:18:58.328
doesn't matter whether you're 
using Eddystone UID or EID, 

05:18:58.329 --> 05:19:01.347
nearby will behave exactly the 
same.  You just create a 

05:19:01.348 --> 05:19:03.970
subscription to the name space 
and type of attachment that 

05:19:03.986 --> 05:19:09.445
you're interested in.  So I 
mentioned earlier that there are

05:19:11.071 --> 05:19:16.159
registering beacons in the Cloud
Cloud, and one of those is that 

05:19:16.160 --> 05:19:20.059
you can create a beacon network 
and share it with many different

05:19:23.108 --> 05:19:27.996
recently, proximity beacon API 
is one of the first API's to use

05:19:30.070 --> 05:19:35.504
access management roles, giving 
fine grain location, fine grain 

05:19:35.505 --> 05:19:39.185
control over which developers 
can make use of your beacon 

05:19:39.186 --> 05:19:47.467
network.  So here we go.  Here 
is a picture of the Google Cloud

05:19:49.640 --> 05:19:52.182
under identity and access 
management you can add members 

05:19:52.183 --> 05:19:55.538
to your project, so these are 
adding developers who can sort 

05:19:55.539 --> 05:19:57.499
of do things with resources that

05:19:57.500 --> 05:19:59.674
are in your project, things like

05:19:59.675 --> 05:20:01.207
compute engine instances or data

05:20:01.208 --> 05:20:05.858
store and so on.  Proximity 
beacon API is one of these.  So 

05:20:05.859 --> 05:20:09.036
once you've enableed the API, 
you 

05:20:09.037 --> 05:20:14.650
can add a developer and choose 
from the roles that we have 

05:20:14.655 --> 05:20:17.039
available.  So these are the new

05:20:17.040 --> 05:20:20.073
roles, and I want to just go 
through them a bit and tell you 

05:20:20.074 --> 05:20:23.002
about what they allow develop 
erpz to do with your beacon 

05:20:23.003 --> 05:20:29.220
network.  So first up is beacon 
editor.  If you grant a 

05:20:29.221 --> 05:20:32.908
developer this role, then 
they're able to add beacons to 

05:20:32.909 --> 05:20:36.822
your project.  It's important if
if, for example, the person who 

05:20:36.823 --> 05:20:39.545
is writing the app is not the 
person who is going and sticking

05:20:42.045 --> 05:20:44.542
is going and sticking up the 
beacon, you want them to be able

05:20:46.173 --> 05:20:47.585
project, but you don't want them

05:20:47.586 --> 05:20:52.853
to be able to fiber off compute 
engine instances.  So compute 

05:20:52.854 --> 05:20:57.509
beacon awk sign to a user or a 
group to be able to enable them 

05:20:57.510 --> 05:20:59.029
to add beacons to your project. 

05:20:59.030 --> 05:21:02.396
It's important to note that 
beacon ID's are universally 

05:21:02.397 --> 05:21:05.445
unique in Google's beacon 
registry.  Once a beacon has 

05:21:05.446 --> 05:21:08.672
been registered, it can't be 
registered by a different 

05:21:08.673 --> 05:21:14.314
project.  Next up we have 
attachment editor.  I mentioned 

05:21:14.315 --> 05:21:18.118
earlier that attachments have 
name spaces associated with them

05:21:20.597 --> 05:21:23.509
your project.  Attachment editor

05:21:23.510 --> 05:21:27.561
allows you to say I want this 
developer to be able to add 

05:21:27.577 --> 05:21:32.568
attachments to my beacons in my 
name space.  So that means they 

05:21:32.569 --> 05:21:36.790
can add attachments that can 
interact with your app, and they

05:21:40.708 --> 05:21:43.215
beacon editor so they can 
register a beacon to your 

05:21:43.231 --> 05:21:45.495
project and they can add 
attachments to it as well 

05:21:45.511 --> 05:21:47.152
without all of the other 
permissions that come as a 

05:21:47.153 --> 05:21:53.991
result of being an owner of a 
project.  Finally is attachment 

05:21:53.992 --> 05:21:59.118
publisher.  What this allows, 
you can say that developer can 

05:21:59.119 --> 05:22:05.327
create attachments in their own 
name space on my beacons.  So I 

05:22:05.342 --> 05:22:10.867
have a beacon network and I can 
say my friend here, I want them 

05:22:10.868 --> 05:22:13.037
to be able to add attachments in

05:22:13.038 --> 05:22:17.163
their own name space that will 
talk to their own app on my 

05:22:17.164 --> 05:22:22.914
beacons.  And these roles and 
these new sharing paradigms 

05:22:22.930 --> 05:22:25.201
allow a bunch of useful things. 

05:22:25.202 --> 05:22:28.973
So here we have three different 
phones belonging to three 

05:22:28.988 --> 05:22:32.662
different users with three 
different active nearby 

05:22:32.678 --> 05:22:34.416
subscriptions all talking to the

05:22:34.417 --> 05:22:38.511
same beacon, and these 
attachments can be added by 

05:22:38.526 --> 05:22:43.206
different developers.  So 
there's a lot of flexibility in 

05:22:43.207 --> 05:22:47.982
the way that you can use a 
beacon network.  You don't any 

05:22:47.983 --> 05:22:52.976
longer just deploy one beacon 
for one app.  We have one beacon

05:22:58.621 --> 05:23:00.950
(applause).
Yeah, it's awesome.

05:23:01.045 --> 05:23:03.045
(applause)

05:23:06.957 --> 05:23:08.577
.
Right.  So interacting with 

05:23:08.578 --> 05:23:12.923
Google products.  Sometimes 
people come to me and they say, 

05:23:12.924 --> 05:23:18.355
Peter, PM for beacons.  This is 
fantastic, but my app has to be 

05:23:18.356 --> 05:23:19.862
everywhere in order for it to be

05:23:19.863 --> 05:23:24.883
useful.  This is not true.  So 
what I want to talk about now is

05:23:28.021 --> 05:23:31.956
and interact with Google 
products at the heart of Android

05:23:32.284 --> 05:23:37.720
Android, like nearby 
notifications.  So nearby 

05:23:37.721 --> 05:23:39.341
notifications was announced just

05:23:39.342 --> 05:23:44.333
an hour ago and is available in 
the next version of Google Play 

05:23:44.334 --> 05:23:47.466
services, but what I want to 
tell you today is how you can 

05:23:47.467 --> 05:23:51.376
register beacons today and add 
attachments that will interact 

05:23:51.377 --> 05:23:56.498
with nearby notifications.  Near

05:23:56.499 --> 05:24:02.135
by notifications allows you to 
prompt notifications in Android 

05:24:02.136 --> 05:24:05.281
in three different categories or

05:24:05.282 --> 05:24:10.085
cases.  You can associate web UR
URL's with your beacons, so 

05:24:10.086 --> 05:24:14.428
you've registered a beacon, you 
can associate a URL with it.  

05:24:14.429 --> 05:24:18.763
You can associate app intents.  
Sorm earlier I said make sure 

05:24:18.764 --> 05:24:21.598
that you've put intents in your 
Android manifest.  You can point

05:24:23.989 --> 05:24:26.371
attachment and if the user 
doesn't have your app installed,

05:24:30.824 --> 05:24:33.419
full.  So if I have your app 
installed, I come near the 

05:24:33.420 --> 05:24:36.249
beacon, it intends into your app
app.  If I don't have your app 

05:24:36.250 --> 05:24:40.048
installed, it says here is a 
website.  And then last up, 

05:24:40.049 --> 05:24:42.985
there's direct app installs.  So

05:24:42.986 --> 05:24:46.577
this is an early program and 
we're holding it behind a white 

05:24:46.578 --> 05:24:51.249
list at the moment.  So if you 
would like to apply to have your

05:24:54.291 --> 05:24:57.561
installs associated with beacons
beacons, then you can go to 

05:24:57.562 --> 05:24:59.562
developers

05:25:00.659 --> 05:25:06.071
 Google/near dem by/
by/notifications and it will 

05:25:06.072 --> 05:25:09.511
tell you how to get started.  
Let's look at what these look 

05:25:09.512 --> 05:25:13.240
like.  Here are three examples 
of nearby notifications.  Right 

05:25:13.241 --> 05:25:18.752
up at the Tom, we've got an app 
for a coffee shop and this 

05:25:18.753 --> 05:25:20.074
passioned our white list because

05:25:20.075 --> 05:25:25.514
of a particular reason and that 
was that a user could take an 

05:25:25.515 --> 05:25:30.291
action if they haded app they 
had they had the app 

05:25:30.292 --> 05:25:32.576
installed right at that place.  
It's very much about is the user

05:25:34.308 --> 05:25:37.131
then do something immediately 
with it.  That's a really good 

05:25:37.132 --> 05:25:40.493
candidate for nearby 
notifications.  In the second 

05:25:40.494 --> 05:25:46.579
case this is an example where 
it's Kim's Vitamins, a URL, a 

05:25:46.580 --> 05:25:51.363
web URL was associated with the 
beacon that pointed to a 

05:25:51.364 --> 05:25:55.390
particular website managed by 
that business.  And then at the 

05:25:55.391 --> 05:25:58.756
bottom we've got everybody's 
favorite example in San 

05:25:58.757 --> 05:26:01.051
Francisco apparently, paying for

05:26:01.052 --> 05:26:06.003
parking.  Finding an app where 
you can pay for parking and 

05:26:06.004 --> 05:26:08.593
actually use it right then to 
pay for the place where you've 

05:26:08.594 --> 05:26:13.599
just parked is another good 
canned datd for nearby 

05:26:13.600 --> 05:26:15.770
candidate for nearby 
notifications.  Let's go back to

05:26:17.414 --> 05:26:21.556
look at it.  We have three 
attachments on this beacon.  The

05:26:23.181 --> 05:26:26.765
you added.  So they're things 
that interact with your app.  

05:26:26.766 --> 05:26:30.253
Maybe you've got some kind of 
beacon functionality button.  

05:26:30.254 --> 05:26:33.495
But we wanted to focus on the 
top one just here and what 

05:26:33.496 --> 05:26:36.643
you'll notice about it is that 
the name space for this 

05:26:36.644 --> 05:26:41.322
particular attachment is not 
your project.  This is com.

05:26:41.323 --> 05:26:45.107
com.Google.nearby, a name space 
reserveed for nearby 

05:26:45.108 --> 05:26:50.439
notifications.  Any developer 
can write attachments in this 

05:26:50.440 --> 05:26:54.242
name space, but they can only 
attach those attachments to 

05:26:54.243 --> 05:26:58.908
their own beacons.  So if you 
register a beacon with Google 

05:26:58.909 --> 05:27:02.910
shes you can write into this 
name space.  If this other 

05:27:02.911 --> 05:27:06.062
person registers a beacon with 
Google, I cannot write into that

05:27:08.648 --> 05:27:13.105
you have to own a beacon in 
order to take part with nearby 

05:27:13.106 --> 05:27:19.013
notifications.  So let's have a 
look.  We have the nearby 

05:27:19.014 --> 05:27:24.558
attachment and you can see that 
it's in this com.Google.nearby 

05:27:24.559 --> 05:27:31.538
name space.  In the type field, 
we've put en, hyphen, debug.  En

05:27:32.938 --> 05:27:35.435
want to show your nearby 
notifications to users who have 

05:27:35.436 --> 05:27:38.399
set the default language on 
their device to the notification

05:27:41.563 --> 05:27:44.817
in the data we've got some 
nearby attachment data.  This is

05:27:47.203 --> 05:27:49.808
you would build if you were 
putting functionality in your 

05:27:49.809 --> 05:27:53.080
own app.  So what does this data

05:27:53.081 --> 05:27:58.834
look like?  Well, it's just with

05:27:58.835 --> 05:28:03.618
a title, a description and a 
description.  You can create 

05:28:03.619 --> 05:28:07.096
this that easy and the URL is 
the part that's interesting.  So

05:28:10.474 --> 05:28:16.109
carefully.  So here are the 
three different categories of 

05:28:16.110 --> 05:28:20.346
nearby notification that I 
mentioned before.  Up at the top

05:28:20.574 --> 05:28:24.157
top, this is the URL that we 
would associate with a direct 

05:28:24.158 --> 05:28:29.480
app install, you can see it 
points to a particular package 

05:28:29.481 --> 05:28:33.196
in the noid Play Store.  In the 
middle this is a URL that we 

05:28:33.197 --> 05:28:35.691
would associate with if the user

05:28:35.692 --> 05:28:38.950
hazy the app installed, intent 
into it, if they don't have the 

05:28:38.951 --> 05:28:42.315
app installed, then we'll fall 
back to a website.  And then at 

05:28:42.316 --> 05:28:48.082
the bottom, you've got the 
simple case, just a web URL.  

05:28:48.083 --> 05:28:51.666
The go hiech to with that 
someone you have -- the go-to 

05:28:51.667 --> 05:28:57.422
with that one is you have to 
remember it's https.  Http URL's

05:29:01.332 --> 05:29:06.137
is the end of the content for 
this talk.  I'm now going to do 

05:29:06.138 --> 05:29:11.678
a demo for your entertainment 
and amusement that is possibly 

05:29:11.679 --> 05:29:14.798
the most dangerous demo that's 
ever been dofnlt I'm going to 

05:29:14.799 --> 05:29:19.147
use two different kinds of radio
radio, I'm going to use an un

05:29:19.256 --> 05:29:21.978
unreleased product, I'm going to

05:29:21.979 --> 05:29:26.447
use a product that we launched 
this afternoon, and I'm going on

05:29:29.467 --> 05:29:36.983
before your very eyes, here is 
my beacon.  It's broadcasting, 

05:29:36.984 --> 05:29:38.950
and in Beacon Tools I can search

05:29:38.951 --> 05:29:43.727
for it just like this.  
Excellent.  It's shown up.  So I

05:29:47.420 --> 05:29:53.616
register it.  I'm glad that 
nobody got there before me.  If 

05:29:53.617 --> 05:29:56.007
somebody else had registered 
that beacon, this would not have

05:29:57.618 --> 05:30:00.990
(laughter).
Right.  So what I just did was I

05:30:03.269 --> 05:30:08.585
broadcasting at Eddystone UID 
and I registered registered it 

05:30:08.586 --> 05:30:10.538
with my 
product.  You can see that I 

05:30:10.539 --> 05:30:14.230
tested this, what, maybe seven 
times before I got in here, and 

05:30:14.231 --> 05:30:16.836
this is the beacon dashboard 
that I was talking about earlier

05:30:17.054 --> 05:30:22.483
earlier.  So if I refresh it, 
fingers crossed, here is my new 

05:30:22.484 --> 05:30:27.137
beacon that I just registered 
right now.  By the way, if this 

05:30:27.138 --> 05:30:30.160
all works, I want you guys to 
give ale cheer that is loud 

05:30:30.161 --> 05:30:37.603
enough to wake the engineers in 
London who made it.  So I can 

05:30:37.604 --> 05:30:42.741
associate some information with 
my beacon.  So the IO beacon.  

05:30:42.742 --> 05:30:44.897
This is the human readable label

05:30:44.898 --> 05:30:47.955
that I want to associate with 
the beacon so I can find it 

05:30:47.956 --> 05:30:55.328
later.  I can associate a place 
with it, so I can put it in 

05:30:55.329 --> 05:30:59.391
Amphitheater Parkway, and this 
will plug into the rest of 

05:30:59.392 --> 05:31:01.761
Google's location infrastructure
infrastructure, as I mentioned 

05:31:01.762 --> 05:31:03.190
before.  This particular beacon,

05:31:03.191 --> 05:31:05.685
this is not going on move around
around, so I'm going to make it 

05:31:05.686 --> 05:31:07.440
stable.  Now, here are some sort

05:31:07.441 --> 05:31:12.852
of useful administrative labels 
for me.  So I can add in things 

05:31:12.853 --> 05:31:16.865
like, I don't know, the tx power
power, the transmit power of 

05:31:16.866 --> 05:31:22.649
this particular beacon.  Maybe 
it's broadcasting at minus 20 DB

05:31:22.979 --> 05:31:27.313
20 DBM.  Great.  So I've now 
registered this beacon with 

05:31:27.314 --> 05:31:29.048
Google, I've added a description

05:31:29.049 --> 05:31:33.847
so that I can sort of find it 
again, and I put a place ID with

05:31:37.445 --> 05:31:41.249
attachments to it.  So here is 
the name space that's associate

05:31:41.472 --> 05:31:46.352
ed 
with my project, and it is very 

05:31:46.353 --> 05:31:52.443
easy to add an attachment.  
There we go.  I just press plus,

05:31:54.605 --> 05:31:55.792
registered with an attachment to

05:31:55.793 --> 05:31:58.727
it, so I can use nearby mess 
stooges get that attachment back

05:32:01.892 --> 05:32:05.136
you should go to the code labs 
tent and there is a code lab 

05:32:05.137 --> 05:32:08.177
specifically on nearby 
subscriptions from nearby 

05:32:08.178 --> 05:32:10.999
messages, so make sure you go 
there in order to get some of 

05:32:11.000 --> 05:32:14.701
these attachments back, and 
we've created a zoo of 

05:32:14.702 --> 05:32:18.054
attachments around IO.  So if 
you do it on your own phone, 

05:32:18.055 --> 05:32:19.574
you'll be able to collect all of

05:32:19.575 --> 05:32:24.951
those animals.  Finally is this 
category, nearby notifications. 

05:32:27.453 --> 05:32:32.333
this like Jason object that you 
can construct but what we decide

05:32:34.060 --> 05:32:37.028
than that.  We just have a web 
form that you can fill in.  I 

05:32:37.029 --> 05:32:41.915
can put a title in here, I can 
put a description for the 

05:32:41.916 --> 05:32:46.056
notification that I want to show
show.  Can somebody give me a 

05:32:46.057 --> 05:32:50.428
random word?
&gt;&gt; Bacon.

05:32:50.429 --> 05:32:52.601
&gt;&gt; PETER LEWIS:  Bacon.  Perfect
Perfect.  The bacon.  This is 

05:32:52.602 --> 05:32:55.852
going on prove that I am doing 
had live -- this says going on 

05:32:55.853 --> 05:32:57.918
prove that I am doing this live.

05:32:57.919 --> 05:33:02.558
I'm going on put it in English 
and how -- I'm going to put it 

05:33:02.559 --> 05:33:04.407
in English and how about we just

05:33:04.408 --> 05:33:07.248
point to Google.com.  Great.  So

05:33:07.249 --> 05:33:09.417
I can check all of the details I

05:33:09.418 --> 05:33:13.334
put and I can create the 
attachment like that.  So what 

05:33:13.335 --> 05:33:16.486
this has done is createed a 
nearby notifications attachment 

05:33:16.487 --> 05:33:18.264
on that beacon that I registered

05:33:18.265 --> 05:33:22.021
on the stage live in front of 
all of you.  Let's go back to 

05:33:22.022 --> 05:33:27.128
the device over here, and on 
this particular phone I have 

05:33:27.129 --> 05:33:34.314
nearby notifications running.  
So when I screen on and I pull 

05:33:34.315 --> 05:33:39.551
down the notification shade, and

05:33:39.567 --> 05:33:47.528
I screen on again, I am going to

05:33:47.529 --> 05:33:50.426
see a couple of websites that 
are not the ones that I was 

05:33:50.427 --> 05:33:57.651
thinking of.  Third time lucky. 

05:33:57.666 --> 05:34:04.288
It looks like it might not work.

05:34:04.289 --> 05:34:06.574
So what's happening is it does a

05:34:06.575 --> 05:34:09.506
beacon scan when the screen 
comes on.  I'm hoping it can see

05:34:11.444 --> 05:34:13.076
right next to it.  There we go. 

05:34:13.077 --> 05:34:16.986
The bacon.
(cheers and applause).

05:34:22.787 --> 05:34:28.018
I select that and Google Chrome 
appears.  So we registered the 

05:34:28.019 --> 05:34:31.061
beacon, we added a nearby 
notifications attachment to it, 

05:34:31.062 --> 05:34:35.729
and that took us straight to 
that link when the user's device

05:34:38.678 --> 05:34:42.705
beacon platform.  One beacon, 
many uses.  I will take some 

05:34:42.706 --> 05:34:44.706
questions.  Thank you.
(applause)

05:34:55.400 --> 05:34:57.805
.
&gt;&gt; Two questions.  One, do you 

05:34:57.806 --> 05:35:01.493
get range information as in how 
many meters approximately?  

05:35:01.509 --> 05:35:04.525
Second, how does this function 
offline?  If you've been there 

05:35:04.526 --> 05:35:07.476
before and you come back and 
don't have a connection, will it

05:35:10.757 --> 05:35:14.800
&gt;&gt; PETER LEWIS:  The answer of 
to your second question is as of

05:35:16.439 --> 05:35:19.157
services is yes.  The answer to 
your second question, as of the 

05:35:19.158 --> 05:35:22.753
next version of Google Play 
services, yes, but.  Using the 

05:35:22.754 --> 05:35:25.575
receive signal strength of a 
beacon to do precise distance is

05:35:28.185 --> 05:35:32.105
attempt.  So we've deliberately 
taken quite a discreet approach,

05:35:33.518 --> 05:35:37.084
beacon or you don't see the 
beacon, and that I think allows 

05:35:37.085 --> 05:35:42.437
them to sort of mark places 
precisely.  So yes.  They're not

05:35:50.380 --> 05:35:53.213
ilaterat I say on 
indoors.

05:35:53.291 --> 05:35:57.670
&gt;&gt; Will the beacon recognize 
that you had your device 

05:35:57.671 --> 05:35:59.408
notified before?  If you come in

05:35:59.409 --> 05:36:02.481
the same door three times, will 
you get that message every time?

05:36:03.011 --> 05:36:03.665
&gt;&gt; PETER LEWIS:  That's the kind

05:36:03.666 --> 05:36:06.927
of functionality that you can 
build in your app to sort of 

05:36:06.928 --> 05:36:09.854
count how many times a user has 
seen a particular beacon.  We 

05:36:09.855 --> 05:36:13.440
just tell you that that beacon 
has been seen and then you can 

05:36:13.441 --> 05:36:16.154
decide what you do with that 
information, whether I've seen 

05:36:16.155 --> 05:36:23.671
it twice before or whatever.
&gt;&gt; How long does the battery 

05:36:23.672 --> 05:36:26.397
last on one beacon?
&gt;&gt; PETER LEWIS:  How long does 

05:36:26.398 --> 05:36:29.225
the battery last?  That is a 
good question.  How long is a 

05:36:29.226 --> 05:36:31.289
piece of string?  It depends how

05:36:31.290 --> 05:36:35.204
big the battery you buy is.  
Typically we're now looking at 

05:36:35.205 --> 05:36:38.132
new-ish beacons that are a 
couple of years plus, and 

05:36:38.133 --> 05:36:42.589
particularly if you're buying 
beacons that have several double

05:36:46.870 --> 05:36:50.301
&gt;&gt; You mentioned when you 
register a beacon with a project

05:36:50.504 --> 05:36:51.975
project, it's registered sort of

05:36:51.976 --> 05:36:54.019
permanently.  Can you unregister

05:36:54.020 --> 05:36:57.405
them to reuse them for 
development purposes in other 

05:36:57.406 --> 05:36:59.788
projects or other people?
&gt;&gt; PETER LEWIS:  So you can 

05:36:59.789 --> 05:37:01.419
currently decommission a beacon,

05:37:01.420 --> 05:37:04.348
which sort of gets rid of it for

05:37:04.349 --> 05:37:08.488
eternity.  The best strategy is 
just to reprovision your beacon 

05:37:08.489 --> 05:37:13.478
and then register it again.
&gt;&gt; For the ephemeral frames, can

05:37:15.670 --> 05:37:19.036
public access to the ephemeral 
frame resolution, or does it 

05:37:19.037 --> 05:37:21.208
have to be one specific?
&gt;&gt; PETER LEWIS:  Yes, absolutely

05:37:21.639 --> 05:37:23.037
absolutely.  You can register an

05:37:23.038 --> 05:37:27.286
EID beacon, you can add an 
attachment to t then you can say

05:37:29.253 --> 05:37:31.207
publicly visible.  It's probably

05:37:31.208 --> 05:37:33.690
ale feature I should have 
mentioned during the talk.  So 

05:37:33.691 --> 05:37:36.507
you can make your name spaces 
publicly visible so any 

05:37:36.508 --> 05:37:39.675
developer can subscribe to it, 
and this allows you to create 

05:37:39.676 --> 05:37:41.287
public beacon networks, which is

05:37:41.288 --> 05:37:49.085
exactly what we've done here 
here at I/O.  So a developer 

05:37:49.086 --> 05:37:51.466
that sub subscribes to your name

05:37:51.467 --> 05:37:53.202
space will just get the 
information you associate with 

05:37:53.203 --> 05:37:54.236
the beacon.
&gt;&gt; Thank you.

05:37:54.237 --> 05:37:58.178
&gt;&gt; My plans for an API for 
registering beacons so we can 

05:37:58.179 --> 05:38:02.770
automate that process?
&gt;&gt; PETER LEWIS:  Yes, proximity 

05:38:02.771 --> 05:38:06.472
API is the proximity for 
registering beacons.

05:38:06.550 --> 05:38:08.970
&gt;&gt; Does scanning only occur 
while you have the screen lit?  

05:38:08.971 --> 05:38:11.469
Is there no way to get a 
notification while the phone is 

05:38:11.470 --> 05:38:13.203
in your pocket?
&gt;&gt; PETER LEWIS:  There is a way 

05:38:13.204 --> 05:38:15.816
to get notifications when the 
phone is in your pocket.  If you

05:38:18.728 --> 05:38:21.118
subscription and you can go to 
the code lab to find out how to 

05:38:21.119 --> 05:38:25.229
do that, then you will benefit 
from scans that happen when the 

05:38:25.230 --> 05:38:28.835
screen off.
&gt;&gt; But you have to pull down to 

05:38:28.836 --> 05:38:31.756
see them or is there a way to 
get --

05:38:31.757 --> 05:38:33.285
&gt;&gt; PETER LEWIS:  To interact 
with any notification, the 

05:38:33.286 --> 05:38:35.457
screen has to be on.  By default

05:38:35.458 --> 05:38:41.457
neer by forces a scan when the 
screen comes on.  It gets scans 

05:38:41.458 --> 05:38:44.076
tuneist cli when the screen is 
-- 

05:38:44.077 --> 05:38:48.087
opportunist cli when the screen 
off, and also you can have a 

05:38:48.088 --> 05:38:52.217
foreground that says I want to 
start scanning now and will tell

05:38:53.397 --> 05:38:55.502
&gt;&gt; Is it always a user pull to 
see the notification?

05:38:55.564 --> 05:38:56.919
&gt;&gt; 
&gt;&gt; PETER LEWIS:  It's always a 

05:38:56.920 --> 05:38:59.429
user pull.  If I've interacted 
with a particular notification 

05:38:59.430 --> 05:39:05.844
before, then they appear on my 
locked screen.  Yeah.

05:39:05.907 --> 05:39:07.475
&gt;&gt; First, is it available just? 

05:39:07.476 --> 05:39:10.393
Android or also other platforms?
&gt;&gt; PETER LEWIS:  Nearby 

05:39:10.394 --> 05:39:12.557
notifications is part of Google 
Play services, so it's on 

05:39:12.558 --> 05:39:14.402
Android.  Nearby messages, there

05:39:14.403 --> 05:39:20.153
is an API for Android also in 
Play Services and there is a Coc

05:39:20.480 --> 05:39:23.099
Cocopod for iOS.  If you've done

05:39:23.100 --> 05:39:28.646
beacon scanning yourself, you 
can hit proximity beacon API 

05:39:28.647 --> 05:39:30.054
directly and say I've found this

05:39:30.055 --> 05:39:32.909
ID, tell me about it.
&gt;&gt; Second question, today was 

05:39:32.910 --> 05:39:36.713
announced about Android and 
instant apps.  Are you actually 

05:39:36.714 --> 05:39:40.414
looking at maybe interact with 
that as well?

05:39:40.415 --> 05:39:42.108
&gt;&gt; PETER LEWIS:  Answer is yes.
&gt;&gt; Awesome.  Thank you.

05:39:42.109 --> 05:39:45.090
&gt;&gt; Once the beacon is registered

05:39:45.091 --> 05:39:48.571
with the proximity API, what 
happens when the device restarts

05:39:48.907 --> 05:39:53.016
restarts?  That reng straition 
still stays?  What happens when 

05:39:53.017 --> 05:39:55.840
the devices restarts?
&gt;&gt; PETER LEWIS:  The 

05:39:55.841 --> 05:40:00.177
registration stays with 
proximity beacon API, and in 

05:40:00.178 --> 05:40:04.419
your beacon is broadcasting the 
same ID after restart, then 

05:40:04.420 --> 05:40:10.732
you're okay.  With EID, we work 
with the clock to determine 

05:40:10.733 --> 05:40:13.454
which to broadcast.  If it's off

05:40:13.455 --> 05:40:16.390
for a short time, we'll cope 
with it.  Otherwise, we might 

05:40:16.391 --> 05:40:18.793
get lost.  Short time is like 
hours.

05:40:18.855 --> 05:40:24.016
&gt;&gt; So you have to finish the 
discovery or scanning, then you 

05:40:24.017 --> 05:40:27.934
register from your app?
&gt;&gt; PETER LEWIS:  Possibly.  

05:40:27.935 --> 05:40:30.414
Let's talk after.  I'll do one 
more question, then I'm going on

05:40:31.558 --> 05:40:35.838
&gt;&gt; As a user, is there a way to 
unsubscribe from an individual 

05:40:35.839 --> 05:40:38.973
beacon or from an app for from a

05:40:38.974 --> 05:40:42.345
complete project altogether?
&gt;&gt; PETER LEWIS:  Yes.  With an 

05:40:42.346 --> 05:40:47.020
app you can uninstall it or you 
should dpif your users options. 

05:40:49.081 --> 05:40:51.253
can dispense it and also dismiss

05:40:51.254 --> 05:40:52.279
notifications from a particular 
project.

05:40:52.280 --> 05:40:56.470
&gt;&gt; Can I do that per beacon?
&gt;&gt; PETER LEWIS:  Yes, although 

05:40:56.471 --> 05:40:59.403
you should try not to think per 
beacon.  These are like Cloud 

05:40:59.404 --> 05:41:02.011
objects now.  That's that.  
Anyway, I have to go.  Thank you

