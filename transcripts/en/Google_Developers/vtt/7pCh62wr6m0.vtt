WEBVTT
Kind: captions
Language: en

00:00:01.000 --> 00:00:02.067
Day:
Hello, everyone.

00:00:02.067 --> 00:00:03.067
Welcome to this
morning's session.

00:00:03.067 --> 00:00:04.234
My name is David.

00:00:04.234 --> 00:00:05.534
Raub:
I'm Susannah.

00:00:05.534 --> 00:00:08.067
Day: We're both engineers
working on the Maps API

00:00:08.067 --> 00:00:10.267
in the Sydney office,
and today we're going

00:00:10.267 --> 00:00:12.634
to be talking to you
about speedy maps.

00:00:12.634 --> 00:00:15.601
So in particular, we're
really going to be emphasizing

00:00:15.601 --> 00:00:18.567
how you can make your website
itself as quick as possible,

00:00:18.567 --> 00:00:20.534
and then once your website
is quick,

00:00:20.534 --> 00:00:22.367
how you can get
the map on that page

00:00:22.367 --> 00:00:25.501
to be super fast as well.

00:00:25.501 --> 00:00:27.167
Raub: So over the years
at Google,

00:00:27.167 --> 00:00:28.767
we've learned
a number of things,

00:00:28.767 --> 00:00:32.868
one of the most important being
that fast is better than slow.

00:00:32.868 --> 00:00:36.300
And this applies directly
to loading web pages fast

00:00:36.300 --> 00:00:38.534
and making them fast
once your users arrive

00:00:38.534 --> 00:00:41.534
at the web page.
Why is this important?

00:00:41.534 --> 00:00:43.901
The longer it takes
your web page to load,

00:00:43.901 --> 00:00:46.334
the more likely your user is
to go and find

00:00:46.334 --> 00:00:48.367
what they're looking for
somewhere else.

00:00:48.367 --> 00:00:51.167
And it's important that once
they arrive at your website,

00:00:51.167 --> 00:00:54.267
that it performs well
and interacts smoothly

00:00:54.267 --> 00:00:56.567
and seamlessly for them,
so that they forget

00:00:56.567 --> 00:00:58.667
that they're in this
two-dimensional web browser

00:00:58.667 --> 00:01:01.367
with this--what could be
static content

00:01:01.367 --> 00:01:03.100
and instead immerse them
in the world

00:01:03.100 --> 00:01:05.701
that you're
trying to deliver.

00:01:05.701 --> 00:01:10.167
So today, we'll talk about
how to make both of these parts

00:01:10.167 --> 00:01:11.834
of your page faster.

00:01:11.834 --> 00:01:14.968
On the Maps API Team, we work
really hard to do our part

00:01:14.968 --> 00:01:18.501
to make sure that what we're
delivering to you is fast,

00:01:18.501 --> 00:01:21.100
but it's important that you
also use these principles

00:01:21.100 --> 00:01:24.267
to make your page
and your map fast.

00:01:24.267 --> 00:01:28.234
So we'll talk about the--
when you load resources,

00:01:28.234 --> 00:01:31.701
how to optimize them
and make the resource loading

00:01:31.701 --> 00:01:34.067
as efficient as possible.

00:01:34.067 --> 00:01:35.968
We'll also talk about
some of the difficulties

00:01:35.968 --> 00:01:38.000
of developing
in the browser

00:01:38.000 --> 00:01:41.133
and how you can work
with and around it.

00:01:41.133 --> 00:01:45.100
Then we'll talk about how
to move some of the hard work

00:01:45.100 --> 00:01:49.000
out of the client and onto
your servers and our servers.

00:01:49.000 --> 00:01:51.300
And we'll cover some of
the tools and technologies

00:01:51.300 --> 00:01:55.133
that exist in the browser
to help you make these pages

00:01:55.133 --> 00:01:59.567
as fast as possible.

00:01:59.567 --> 00:02:03.968
So here we see a chart
that shows the amount of time

00:02:03.968 --> 00:02:07.667
it took to load various size
JavaScript files.

00:02:07.667 --> 00:02:10.601
Now, loading resources
is a combination of things.

00:02:10.601 --> 00:02:14.534
It takes time to do a DNS lookup
to make a return trip

00:02:14.534 --> 00:02:17.667
to the server to actually
fetch the data

00:02:17.667 --> 00:02:19.000
and then to parse the data

00:02:19.000 --> 00:02:21.667
and to execute it
in the browser.

00:02:21.667 --> 00:02:23.501
Now, these numbers
are pretty general.

00:02:23.501 --> 00:02:26.634
Because there are these
different components to loading,

00:02:26.634 --> 00:02:28.334
and every browser
is a little different,

00:02:28.334 --> 00:02:31.968
and every device is different,
there's no hard and fast rule

00:02:31.968 --> 00:02:34.701
as to how long it takes
to load a particular resource.

00:02:34.701 --> 00:02:37.033
Plus, that parsing and executing
can vary a lot

00:02:37.033 --> 00:02:40.033
by the complexity
of the resource loaded.

00:02:40.033 --> 00:02:42.100
But what we do know is
that the bigger the file is,

00:02:42.100 --> 00:02:43.300
the longer it takes.

00:02:43.300 --> 00:02:45.400
This chart is just emphasizing
that point.

00:02:45.400 --> 00:02:47.901
Bigger files,
longer time.

00:02:47.901 --> 00:02:50.400
Now, there are many ways
to reduce the size of the files

00:02:50.400 --> 00:02:53.601
that you download, but
the really core principle here

00:02:53.601 --> 00:02:58.167
is to load only the necessary
resources at any given time--

00:02:58.167 --> 00:03:00.534
that because it takes time
to load each resource

00:03:00.534 --> 00:03:03.767
and each big resource,
load as little as possible.

00:03:03.767 --> 00:03:07.167
We do this in the Maps API
by only loading up front

00:03:07.167 --> 00:03:09.400
what you need to
create your map,

00:03:09.400 --> 00:03:12.467
and we wait to load the rest
of the components later,

00:03:12.467 --> 00:03:17.000
until they're actually
required.

00:03:17.000 --> 00:03:19.267
Day: So one of the most
powerful ways

00:03:19.267 --> 00:03:22.067
you can reduce one of the heavy
components of your page,

00:03:22.067 --> 00:03:23.367
the JavaScript,

00:03:23.367 --> 00:03:26.868
is to send it through
a compiler or a minifier.

00:03:26.868 --> 00:03:29.334
So the job of a minifier
is basically to do

00:03:29.334 --> 00:03:33.501
some simple manipulation
of your JavaScript files.

00:03:33.501 --> 00:03:35.234
For example, it will
strip out comments.

00:03:35.234 --> 00:03:38.567
It will collapse white space,
so it's all normalized.

00:03:38.567 --> 00:03:41.200
And it can also do some
simple variable renaming,

00:03:41.200 --> 00:03:43.901
particularly the parameters
of functions.

00:03:43.901 --> 00:03:47.200
JavaScript compilation
really takes it that next step,

00:03:47.200 --> 00:03:49.534
because it can understand
the semantics of what

00:03:49.534 --> 00:03:51.033
your JavaScript is trying to do.

00:03:51.033 --> 00:03:52.334
And so it can do

00:03:52.334 --> 00:03:53.868
much more aggressive
optimizations,

00:03:53.868 --> 00:03:57.133
like renaming variables
that look like they're global,

00:03:57.133 --> 00:03:58.968
but only your program
is using them.

00:03:58.968 --> 00:04:00.834
And even doing things
like in-lining functions

00:04:00.834 --> 00:04:03.200
completely away.

00:04:03.200 --> 00:04:05.834
So in the top code
sample there,

00:04:05.834 --> 00:04:07.701
I've got a bit
of a toy piece of code

00:04:07.701 --> 00:04:10.701
which calculates
the nth Fibonacci number.

00:04:10.701 --> 00:04:11.934
And as you can see,

00:04:11.934 --> 00:04:14.701
I haven't taken any care
making that small.

00:04:14.701 --> 00:04:16.300
There's big
variable names.

00:04:16.300 --> 00:04:18.934
I've even made a bit
of a silly function,

00:04:18.934 --> 00:04:20.200
just to add two numbers
together,

00:04:20.200 --> 00:04:22.968
so you can see
it's a big waste of space.

00:04:22.968 --> 00:04:24.667
Now, when I ran
that piece of code

00:04:24.667 --> 00:04:28.267
through the open source
closure compiler,

00:04:28.267 --> 00:04:32.033
you can see the same functional
piece of code at the bottom.

00:04:32.033 --> 00:04:33.334
It's much, much more terse.

00:04:33.334 --> 00:04:36.901
It fits on a single line,
and you can even see

00:04:36.901 --> 00:04:39.234
that it's taken away some
of those extraneous function

00:04:39.234 --> 00:04:41.567
calls that I've made,
and it's really--

00:04:41.567 --> 00:04:45.868
I don't think you could write
that any more succinctly.

00:04:45.868 --> 00:04:48.667
So why would you
run your code

00:04:48.667 --> 00:04:51.267
through a compiler
or a minifier?

00:04:51.267 --> 00:04:53.934
Well, the obvious answer
is that it's smaller,

00:04:53.934 --> 00:04:55.200
as you just saw.

00:04:55.200 --> 00:04:57.801
Many lines of code
with large variable names,

00:04:57.801 --> 00:04:59.667
it became very small.

00:04:59.667 --> 00:05:03.100
So this really helps
in the download component,

00:05:03.100 --> 00:05:06.868
so the files themselves
are much smaller.

00:05:06.868 --> 00:05:09.934
The second advantage,
and this really applies more

00:05:09.934 --> 00:05:12.701
to the compiler
than to the minifier,

00:05:12.701 --> 00:05:15.167
is that it can make
your code itself simpler.

00:05:15.167 --> 00:05:18.367
It can, if you've got
a mathematical expression,

00:05:18.367 --> 00:05:20.267
it might be able to
pre-calculate that

00:05:20.267 --> 00:05:23.534
at compilation time, and it can
in-line functions away.

00:05:23.534 --> 00:05:25.667
So the code itself
can become simpler,

00:05:25.667 --> 00:05:30.334
which can speed up the pausing
and the execution on the page.

00:05:30.334 --> 00:05:32.234
And I think one of the most
important reasons

00:05:32.234 --> 00:05:33.868
that you'd want
to use a compiler

00:05:33.868 --> 00:05:37.167
is that it actually can make
your JavaScript maintainable.

00:05:37.167 --> 00:05:39.167
Because you're not worried
about the code

00:05:39.167 --> 00:05:42.200
you're actually writing is going
to be sent to the end user,

00:05:42.200 --> 00:05:45.868
you can be very,
very clear in your code.

00:05:45.868 --> 00:05:47.501
You can write
large comments.

00:05:47.501 --> 00:05:49.334
You can use very descriptive
variable names,

00:05:49.334 --> 00:05:51.133
and you don't have to worry
about all those little

00:05:51.133 --> 00:05:54.601
extra bytes that are being sent
down to the client every time.

00:05:54.601 --> 00:05:58.033
The closure compiler also has
another really powerful tool

00:05:58.033 --> 00:05:59.634
which helps keep
your JavaScript maintainable,

00:05:59.634 --> 00:06:03.200
and that's that it provides
typing to JavaScript.

00:06:03.200 --> 00:06:06.267
So you can do things
like define object types,

00:06:06.267 --> 00:06:07.767
define interfaces,

00:06:07.767 --> 00:06:10.067
and the compiler can catch
little errors you're making

00:06:10.067 --> 00:06:12.934
like typos or wrong
number of arguments

00:06:12.934 --> 00:06:15.400
to a function call
at the compilation time,

00:06:15.400 --> 00:06:17.834
so you get your answers
straight away,

00:06:17.834 --> 00:06:23.167
rather than after 20 minutes
of digging through stack traces.

00:06:23.167 --> 00:06:25.701
The open source closure compiler
actually forms the basis

00:06:25.701 --> 00:06:28.934
of how we, as the API team,
compile all our code,

00:06:28.934 --> 00:06:32.601
and there is an externs file
available in the SVN repository

00:06:32.601 --> 00:06:34.868
which lets you compile
your own web application

00:06:34.868 --> 00:06:38.634
against our API.

00:06:38.634 --> 00:06:41.133
Just to give you a little
feeling for how powerful

00:06:41.133 --> 00:06:43.033
these minifiers
and compilers are,

00:06:43.033 --> 00:06:45.300
here are two
real world examples.

00:06:45.300 --> 00:06:47.234
The JQuery library,
when you concatenate

00:06:47.234 --> 00:06:52.701
just the raw source files,
is about 233 KB.

00:06:52.701 --> 00:06:56.968
After minification,
that drops down to 94 KB.

00:06:56.968 --> 00:07:00.767
The Maps API itself weighs
in at a massive 2.4 MB

00:07:00.767 --> 00:07:03.133
before we do
any compilation of it.

00:07:03.133 --> 00:07:05.400
And you think that's
an amazing amount of code,

00:07:05.400 --> 00:07:07.901
but that also includes
a lot of commenting,

00:07:07.901 --> 00:07:10.868
a lot of documentation that we
have in our code directly there,

00:07:10.868 --> 00:07:13.901
because it makes it much more
easy for us to work with it.

00:07:13.901 --> 00:07:16.033
After we've run it
through a compiler,

00:07:16.033 --> 00:07:20.734
the whole API is reduced
down to 336 KB.

00:07:20.734 --> 00:07:26.734
That's in the order of 14%
of the original size.

00:07:26.734 --> 00:07:30.200
Raub: So though it's important
to make each of your files

00:07:30.200 --> 00:07:32.834
as small as possible,
it's also important to remember

00:07:32.834 --> 00:07:36.767
that each file counts
when you download it.

00:07:36.767 --> 00:07:40.367
This is a waterfall chart
from Firefox 3.0,

00:07:40.367 --> 00:07:44.334
where we're loading 13
different JavaScript files

00:07:44.334 --> 00:07:49.567
with a total of 730 KB of data,
and this took 4.5 seconds.

00:07:49.567 --> 00:07:51.834
Each of these is downloaded
in sequence.

00:07:51.834 --> 00:07:54.334
Now, many browsers
since Firefox 3.0

00:07:54.334 --> 00:07:56.934
can actually load files
in parallel,

00:07:56.934 --> 00:08:00.434
and this becomes much shorter
time and much better,

00:08:00.434 --> 00:08:03.367
but we're still dealing with
many old browsers out there

00:08:03.367 --> 00:08:10.834
and many mobile devices
that have low CPU, low RAM,

00:08:10.834 --> 00:08:15.868
and low bandwidth often,
and so the load time

00:08:15.868 --> 00:08:19.000
can't be as paralyzed
for these reasons.

00:08:19.000 --> 00:08:23.167
And so if we take those files
and instead bundle them

00:08:23.167 --> 00:08:25.701
into two separate downloads,

00:08:25.701 --> 00:08:28.934
where we're still loading
that same 730 KB,

00:08:28.934 --> 00:08:32.968
we can get the time
down to 1.8 seconds

00:08:32.968 --> 00:08:36.501
to load that same
amount of data.

00:08:36.501 --> 00:08:40.834
So where possible, use multiple
files for development,

00:08:40.834 --> 00:08:42.501
but then make sure
to concatenate them

00:08:42.501 --> 00:08:45.434
before you serve them
to your users

00:08:45.434 --> 00:08:48.834
so that those resources
load quicker.

00:08:48.834 --> 00:08:51.467
These same principles
apply to images.

00:08:51.467 --> 00:08:53.868
So with images,
we can concatenate images

00:08:53.868 --> 00:08:56.100
by using what we call
an image sprite.

00:08:56.100 --> 00:08:59.767
An image sprite is a collection
of multiple individual images

00:08:59.767 --> 00:09:02.133
in one larger image
that's loaded together,

00:09:02.133 --> 00:09:04.501
but then only
shown in portions.

00:09:04.501 --> 00:09:05.934
So here we have,
at the top,

00:09:05.934 --> 00:09:08.334
we see three different
Pegman images.

00:09:08.334 --> 00:09:09.934
But there's actually--
to show Pegman,

00:09:09.934 --> 00:09:11.634
because we show him
at so many different angles

00:09:11.634 --> 00:09:13.300
as you drag him
around the map--

00:09:13.300 --> 00:09:16.033
there are actually
about 30 Pegmans.

00:09:16.033 --> 00:09:18.868
But they're all concatenated
into one image

00:09:18.868 --> 00:09:22.968
because usually we need all of
these 30 Pegmans all together.

00:09:22.968 --> 00:09:26.534
So we load that one image,
and then using HTML and CSS

00:09:26.534 --> 00:09:28.968
can show only the relevant
Pegman.

00:09:28.968 --> 00:09:33.400
So here are some code snippets
for doing it purely in HTML

00:09:33.400 --> 00:09:36.634
and then another to show
a CSS block for it.

00:09:36.634 --> 00:09:41.400
So when doing it in HTML,
you specify a div

00:09:41.400 --> 00:09:43.267
that is the width
and height of the image

00:09:43.267 --> 00:09:45.100
you actually want to show--
so the actual,

00:09:45.100 --> 00:09:47.234
the size of the actual Pegman.

00:09:47.234 --> 00:09:48.868
You set its overflow
to be hidden

00:09:48.868 --> 00:09:50.901
so that anything
extending outside of that div

00:09:50.901 --> 00:09:52.801
is not shown.

00:09:52.801 --> 00:09:55.767
Then you put inside
the div an image tag,

00:09:55.767 --> 00:09:59.100
which the source
is the complete image sprite--

00:09:59.100 --> 00:10:02.067
so the full 30 Pegmans.

00:10:02.067 --> 00:10:04.000
Then offset
within that image,

00:10:04.000 --> 00:10:07.868
you set the left
and top positions

00:10:07.868 --> 00:10:11.701
so to be the point in the image
where that Pegman starts,

00:10:11.701 --> 00:10:13.968
the top left corner
of that Pegman.

00:10:13.968 --> 00:10:16.167
So because this particular
Pegman that I'm showing

00:10:16.167 --> 00:10:20.000
on the slide is 98 pixels
into the image,

00:10:20.000 --> 00:10:24.067
I set the left position
to be -98 pixels.

00:10:24.067 --> 00:10:27.167
The CSS is very similar,
except that you can use

00:10:27.167 --> 00:10:31.534
the background image property
and the background position.

00:10:31.534 --> 00:10:35.567
Now, the downfall
of using the div

00:10:35.567 --> 00:10:39.834
is it's harder to print images
that are in divs

00:10:39.834 --> 00:10:41.100
with background images.

00:10:41.100 --> 00:10:42.934
It depends on the browser,
whether you can do that;

00:10:42.934 --> 00:10:46.200
otherwise, it's a great way
to go for rendering

00:10:46.200 --> 00:10:48.601
your image sprites.

00:10:48.601 --> 00:10:51.667
Day: So another way you can
bundle your images together

00:10:51.667 --> 00:10:54.634
is to bundle them directly
into the HTML itself

00:10:54.634 --> 00:10:57.767
rather than alongside
other images.

00:10:57.767 --> 00:11:00.734
On this slide,
I've got two blue markers,

00:11:00.734 --> 00:11:02.968
but the way that those two
markers are being rendered

00:11:02.968 --> 00:11:04.567
by the browser, the way
they've been delivered

00:11:04.567 --> 00:11:07.801
to the browser
is completely different.

00:11:07.801 --> 00:11:10.901
The top one is very much
the traditional image

00:11:10.901 --> 00:11:12.901
that you probably
all know and love.

00:11:12.901 --> 00:11:16.067
It's just an image tag
which specifies

00:11:16.067 --> 00:11:17.734
where its source is.

00:11:17.734 --> 00:11:19.601
So when the browser
encounters this tag,

00:11:19.601 --> 00:11:23.868
it needs to make a HTTP request
to your server, go out,

00:11:23.868 --> 00:11:27.133
request the image
from your server,

00:11:27.133 --> 00:11:29.567
bring it back, download it,
decode it,

00:11:29.567 --> 00:11:32.400
and then display it
on the page.

00:11:32.400 --> 00:11:35.000
With the second marker,
I've actually included the data

00:11:35.000 --> 00:11:37.834
for the marker directly
in the page itself,

00:11:37.834 --> 00:11:40.434
so there's no extra connection
required.

00:11:40.434 --> 00:11:43.968
To do this, we use something
known as data URLs,

00:11:43.968 --> 00:11:46.567
and with a data URL,
you basically have to specify

00:11:46.567 --> 00:11:48.467
four different things.

00:11:48.467 --> 00:11:52.534
The first thing is that you
start the URL with data

00:11:52.534 --> 00:11:55.501
instead of HTTP,
like you usually would.

00:11:55.501 --> 00:11:57.734
The next thing you need to do
is tell the browser

00:11:57.734 --> 00:12:00.000
what MIME type it's supposed
to be expecting,

00:12:00.000 --> 00:12:02.801
so it knows how to decode
the data when it sees it.

00:12:02.801 --> 00:12:05.868
And in this case,
it's an image ping.

00:12:05.868 --> 00:12:08.100
The third thing you need to do
is tell the browser

00:12:08.100 --> 00:12:11.834
how you're going to
encode the data for it,

00:12:11.834 --> 00:12:14.334
and here we've down
Base64 encoding,

00:12:14.334 --> 00:12:18.734
which is what you'll do
99.99% of the time.

00:12:18.734 --> 00:12:23.234
And, lastly, you actually
include directly in the URL

00:12:23.234 --> 00:12:26.601
the data of that image
encoded in Base64,

00:12:26.601 --> 00:12:31.934
so the actual binary data
that describes that image.

00:12:31.934 --> 00:12:34.734
Using the same data
URL techniques,

00:12:34.734 --> 00:12:39.000
it's equivalent to embed
that image source directly

00:12:39.000 --> 00:12:41.501
into a JavaScript file
or into a CSS file.

00:12:41.501 --> 00:12:42.901
So wherever
it's most appropriate,

00:12:42.901 --> 00:12:46.100
you can use it.

00:12:46.100 --> 00:12:47.701
Now, why would you
want to use this,

00:12:47.701 --> 00:12:50.300
and why would you
want to avoid it?

00:12:50.300 --> 00:12:52.934
The obvious advantage,
as I already discussed,

00:12:52.934 --> 00:12:55.267
is that there's one less
HTTP connection.

00:12:55.267 --> 00:12:57.467
So if you have a page
with a small icon,

00:12:57.467 --> 00:13:00.234
the browser doesn't need to do
any extra network work

00:13:00.234 --> 00:13:03.267
to get that image
on the page for you.

00:13:03.267 --> 00:13:06.434
And also it can be conceptually
simpler than spriting.

00:13:06.434 --> 00:13:09.100
Because each image
contains the data

00:13:09.100 --> 00:13:11.968
for a single part of your image,
you don't have to worry about

00:13:11.968 --> 00:13:14.467
where your little image fits
in the context

00:13:14.467 --> 00:13:17.534
of the much larger sprite
and be worrying about offsets.

00:13:17.534 --> 00:13:20.467
You can deal with
one image at a time.

00:13:20.467 --> 00:13:22.767
On the other hand,
there is limited support

00:13:22.767 --> 00:13:25.300
for data URLs
in older browsers.

00:13:25.300 --> 00:13:28.634
For example, Internet Explorer 7
has no support at all,

00:13:28.634 --> 00:13:32.467
and IE 8 has limited support.

00:13:32.467 --> 00:13:34.501
On the other hand,
to this point,

00:13:34.501 --> 00:13:38.200
all modern mobile browsers
do support data URLs,

00:13:38.200 --> 00:13:41.100
so they're a really good
candidate for data URLs,

00:13:41.100 --> 00:13:45.300
because in these devices, you do
have really limited bandwidth.

00:13:45.300 --> 00:13:49.300
For example, in the Maps API,
we actually use data URLs

00:13:49.300 --> 00:13:53.100
to deliver all the images
required for our zoom controls,

00:13:53.100 --> 00:13:55.868
for example,
in mobile devices.

00:13:55.868 --> 00:13:57.667
The other thing that's worth
bearing in mind

00:13:57.667 --> 00:14:00.634
is that that Base64 encoding
of the binary data

00:14:00.634 --> 00:14:04.067
can swell the image
by about 1/3.

00:14:04.067 --> 00:14:06.801
Generally, if your server is set
up to handle GZipping correctly,

00:14:06.801 --> 00:14:11.467
though, that overhead pretty
much shrinks to nothing.

00:14:11.467 --> 00:14:13.234
And just briefly,
just to show you

00:14:13.234 --> 00:14:16.501
that it's not a very difficult
task to actually generate

00:14:16.501 --> 00:14:20.367
that Base64 data,
on the top code snippet,

00:14:20.367 --> 00:14:23.934
I've got three lines of Python
which open up any image file,

00:14:23.934 --> 00:14:25.300
or any file, really,

00:14:25.300 --> 00:14:29.567
and return what
that Base64 data looks like.

00:14:29.567 --> 00:14:33.133
The bottom line is actually
a little bit more advanced,

00:14:33.133 --> 00:14:36.334
I guess, in that it's a PHP
script which will generate

00:14:36.334 --> 00:14:40.434
the Base64 encoding at runtime
in the server.

00:14:40.434 --> 00:14:41.868
So you don't even
have to worry about storing

00:14:41.868 --> 00:14:46.934
that Base64 data anywhere.

00:14:46.934 --> 00:14:49.734
Now, the principles
we've talked about for images

00:14:49.734 --> 00:14:52.534
apply just as strongly
to JavaScript and CSS

00:14:52.534 --> 00:14:56.534
and really any resource
that you can use it with.

00:14:56.534 --> 00:14:58.534
So with JavaScript,
as Susannah mentioned,

00:14:58.534 --> 00:15:00.200
keep those files together.

00:15:00.200 --> 00:15:02.133
If you can use a compiler
to compile

00:15:02.133 --> 00:15:05.934
all these source codes together,
that's fantastic.

00:15:05.934 --> 00:15:08.267
And, also, only load
the bare essentials

00:15:08.267 --> 00:15:10.067
into the head tag itself,

00:15:10.067 --> 00:15:11.734
because anything
in that head tag

00:15:11.734 --> 00:15:13.934
can stop the body
from rendering properly

00:15:13.934 --> 00:15:17.167
until all your script is
downloaded, parsed, and run.

00:15:17.167 --> 00:15:18.801
So if you've got
heavy white things, like--

00:15:18.801 --> 00:15:22.267
things that deal with,
especially user interaction,

00:15:22.267 --> 00:15:25.834
try and load those later on
in the page's lifetime.

00:15:25.834 --> 00:15:28.501
It's also useful to try
and keep common scripts

00:15:28.501 --> 00:15:30.701
from infrequently used scripts.

00:15:30.701 --> 00:15:32.534
So if you use some parts
of your library

00:15:32.534 --> 00:15:34.501
on every single page
of your site,

00:15:34.501 --> 00:15:36.801
keep them in a separate file
to those that you're using

00:15:36.801 --> 00:15:38.901
only on one or two pages

00:15:38.901 --> 00:15:41.601
because, that way, the user
is always going to have

00:15:41.601 --> 00:15:43.767
that common page
in their cache

00:15:43.767 --> 00:15:45.968
and they won't have to
re-download it

00:15:45.968 --> 00:15:48.267
for every page they visit.

00:15:48.267 --> 00:15:51.667
Again, apply the--these concepts
to CSS as well.

00:15:51.667 --> 00:15:54.067
Bundle the fast together,
compile them, minify them

00:15:54.067 --> 00:15:57.133
if you can, and also,
at all costs,

00:15:57.133 --> 00:15:59.701
avoid the @import tag,
because what that means is

00:15:59.701 --> 00:16:01.467
the browser has to go out,

00:16:01.467 --> 00:16:03.801
read one CSS file
from your server,

00:16:03.801 --> 00:16:05.567
and only then does it know
that it needs to go

00:16:05.567 --> 00:16:07.167
and start downloading
a second one.

00:16:07.167 --> 00:16:08.901
So it can really
significantly delay

00:16:08.901 --> 00:16:11.934
how long it takes to start.

00:16:11.934 --> 00:16:13.868
Raub: Now, in developing
the Maps API,

00:16:13.868 --> 00:16:16.901
we use all of the techniques
that we've talked about so far:

00:16:16.901 --> 00:16:20.434
delay loading code,
compiling and minification,

00:16:20.434 --> 00:16:23.701
image spriting,
embedding data URLs,

00:16:23.701 --> 00:16:28.567
and concatenating JavaScript
to have fewer downloads.

00:16:28.567 --> 00:16:31.968
To walk you through exactly
how the Maps API loads this,

00:16:31.968 --> 00:16:35.033
you, the developer, start here
in the upper left hand corner

00:16:35.033 --> 00:16:39.734
by loading the Maps API
bootstrap, as we call it--

00:16:39.734 --> 00:16:41.968
so embedding the script tag
on your page.

00:16:41.968 --> 00:16:44.434
This then loads a file
that is the bare minimum

00:16:44.434 --> 00:16:46.234
it takes you to load,

00:16:46.234 --> 00:16:49.000
to start developing
your mapping application.

00:16:49.000 --> 00:16:52.767
So we load only the interfaces
and what we call main.js.

00:16:52.767 --> 00:16:55.701
This is all the classes
that you can instantiate.

00:16:55.701 --> 00:16:58.167
You, the developer,
then create a new map,

00:16:58.167 --> 00:17:01.267
giving it the center
of the zoom, its map type ID,

00:17:01.267 --> 00:17:02.601
at which point
we do actually have

00:17:02.601 --> 00:17:04.300
a little bit of implementation
in that first code

00:17:04.300 --> 00:17:05.934
just to make this part faster,

00:17:05.934 --> 00:17:08.701
just to load a static map
right away.

00:17:08.701 --> 00:17:11.901
At the same time,
we go and we delay load, the--

00:17:11.901 --> 00:17:14.434
all of the implementation
for the actual functionality

00:17:14.434 --> 00:17:15.868
of the map.

00:17:15.868 --> 00:17:18.567
But here, when we have to
load multiple files,

00:17:18.567 --> 00:17:20.634
we'll concatenate them.

00:17:20.634 --> 00:17:22.567
At that point,
we then load the map tiles.

00:17:22.567 --> 00:17:25.834
So we're loading things
as you need them,

00:17:25.834 --> 00:17:28.300
both compiled together
as small as possible

00:17:28.300 --> 00:17:30.534
but split out
where appropriate.

00:17:30.534 --> 00:17:32.400
Now, I'd like to talk
a little bit more

00:17:32.400 --> 00:17:34.434
to drive home this point
of how we do things,

00:17:34.434 --> 00:17:37.334
about the new Maps API
Libraries feature.

00:17:37.334 --> 00:17:40.834
So over time, that interface
file, that main.js,

00:17:40.834 --> 00:17:44.367
can grow and grow, as we add
more and more features.

00:17:44.367 --> 00:17:47.100
So to get around adding
these features to all developers

00:17:47.100 --> 00:17:50.367
who might not need these new
really specialized features,

00:17:50.367 --> 00:17:52.934
and all you want to do
is show a map with a marker

00:17:52.934 --> 00:17:55.501
and don't want all of our
fancy new features.

00:17:55.501 --> 00:17:57.234
So we've added
these libraries.

00:17:57.234 --> 00:18:00.133
So when you request
the bootstrap,

00:18:00.133 --> 00:18:03.400
you ask for the particular
libraries that you want.

00:18:03.400 --> 00:18:05.501
So in this example,
the AdSense library,

00:18:05.501 --> 00:18:08.200
which has a component
called the ad unit

00:18:08.200 --> 00:18:12.167
which can render ads
on your map.

00:18:12.167 --> 00:18:15.567
When this loads, that file--
that AdSense module

00:18:15.567 --> 00:18:18.701
or that AdSense library--
is then concatenated

00:18:18.701 --> 00:18:22.300
with the main interface library,
main.js.

00:18:22.300 --> 00:18:25.300
It then extends the google.maps
name space to include

00:18:25.300 --> 00:18:26.968
adsense.AdUnit.

00:18:26.968 --> 00:18:28.434
So it's all still
part of the same download,

00:18:28.434 --> 00:18:31.634
the same library,
but we have not created

00:18:31.634 --> 00:18:34.534
a single additional download,

00:18:34.534 --> 00:18:38.100
and any developer who's not
using this feature

00:18:38.100 --> 00:18:42.834
does not have
any extra bytes added.

00:18:42.834 --> 00:18:45.000
I'm going to switch gears now
a little bit and talk about,

00:18:45.000 --> 00:18:47.100
start talking about how
you can use servers,

00:18:47.100 --> 00:18:52.167
both yours and ours and those
around the world to help you.

00:18:52.167 --> 00:18:54.000
And we're going to talk
about caching here.

00:18:54.000 --> 00:18:58.100
So as just a little background
to caching here,

00:18:58.100 --> 00:19:00.400
if a user is sitting in front
of a web browser

00:19:00.400 --> 00:19:04.267
and asks for
a particular website,

00:19:04.267 --> 00:19:07.200
and it's not in a cache
anywhere,

00:19:07.200 --> 00:19:09.467
it will go all the way up
to the original server

00:19:09.467 --> 00:19:12.167
to fetch the resources--
say, maps.google.com,

00:19:12.167 --> 00:19:15.033
our cloud up at the top
of the image.

00:19:15.033 --> 00:19:16.234
But subsequent requests,

00:19:16.234 --> 00:19:17.868
if the cache headers
are set correctly,

00:19:17.868 --> 00:19:19.767
can be served
by the browser cache,

00:19:19.767 --> 00:19:22.133
making the request
almost instantaneous.

00:19:22.133 --> 00:19:24.067
That original request
can take a long time

00:19:24.067 --> 00:19:28.334
if that server is far away,
or slow, or lots of hops

00:19:28.334 --> 00:19:32.167
between the user
and that server.

00:19:32.167 --> 00:19:34.767
But if--there are all
these intermediary caches

00:19:34.767 --> 00:19:38.000
between the browser
and that end server.

00:19:38.000 --> 00:19:40.000
And so if a user is,
say, sitting next door,

00:19:40.000 --> 00:19:43.534
who's on the same ISP
as our first user,

00:19:43.534 --> 00:19:45.567
loads that same page,

00:19:45.567 --> 00:19:48.467
when that user goes
to request the page,

00:19:48.467 --> 00:19:50.400
it will go, say,
to the ISP cache

00:19:50.400 --> 00:19:52.901
because these people
are on the same ISP,

00:19:52.901 --> 00:19:55.100
and most ISPs will have
a cache sitting there

00:19:55.100 --> 00:19:57.701
that can serve these resources.

00:19:57.701 --> 00:19:59.067
And subsequent requests

00:19:59.067 --> 00:20:01.400
will also go to their own
browser cache.

00:20:01.400 --> 00:20:04.467
Now, a third person,
who also maybe lives nearby--

00:20:04.467 --> 00:20:06.033
let's say these people
are all in Australia.

00:20:06.033 --> 00:20:07.968
We're loading things
across the Pacific Ocean.

00:20:07.968 --> 00:20:09.567
It can be really slow,
and it's great

00:20:09.567 --> 00:20:13.133
when things are hosted
inside of Australia.

00:20:13.133 --> 00:20:14.834
This third user,
also in Australia

00:20:14.834 --> 00:20:18.300
but on a different ISP,
when they request this page,

00:20:18.300 --> 00:20:20.367
they hit a content
distribution network,

00:20:20.367 --> 00:20:21.701
something like Akamai,

00:20:21.701 --> 00:20:23.767
where these pages are--

00:20:23.767 --> 00:20:27.033
these resources are cached
within that resource.

00:20:27.033 --> 00:20:28.834
So that's within that server.

00:20:28.834 --> 00:20:30.667
So that's in Australia,

00:20:30.667 --> 00:20:32.601
instead of having to go all
the way back up to the server.

00:20:32.601 --> 00:20:36.133
So by setting cache headers
correctly,

00:20:36.133 --> 00:20:37.501
all users can benefit,

00:20:37.501 --> 00:20:40.968
not just the one who's loaded
the page already.

00:20:40.968 --> 00:20:42.300
But you have to be aware.

00:20:42.300 --> 00:20:46.033
Say I have--I collect photos
of my favorite animal.

00:20:46.033 --> 00:20:47.601
And my favorite animal
is a cow.

00:20:47.601 --> 00:20:49.033
And I'm going to use this cow

00:20:49.033 --> 00:20:53.234
to illustrate a point
of having multiple resources

00:20:53.234 --> 00:20:56.467
on a page that need to be
kept in sync.

00:20:56.467 --> 00:20:57.801
So I'm going to take my cow,

00:20:57.801 --> 00:20:59.367
and I'm actually going to
split him into two.

00:20:59.367 --> 00:21:01.801
And I'm going to call my photo
animal left and animal right

00:21:01.801 --> 00:21:05.968
because this is a page
dedicated to my favorite animal

00:21:05.968 --> 00:21:07.400
at the time.

00:21:07.400 --> 00:21:09.033
So I've got my cow,
and I've split him in half,

00:21:09.033 --> 00:21:10.434
into two parts.

00:21:10.434 --> 00:21:12.133
Now, I probably wouldn't
actually split my cow image

00:21:12.133 --> 00:21:13.467
in half.

00:21:13.467 --> 00:21:16.133
I'm just showing you
synchronized resources here.

00:21:16.133 --> 00:21:18.400
So it's important that
the left half of the animal

00:21:18.400 --> 00:21:21.234
and the right half of
the animal are always the cow.

00:21:21.234 --> 00:21:23.234
But then I take this trip
to Nepal,

00:21:23.234 --> 00:21:24.868
and I see
this really cool yak,

00:21:24.868 --> 00:21:26.701
and the yak is now
my favorite animal.

00:21:26.701 --> 00:21:32.934
So I've decided to take my page
and just change the file,

00:21:32.934 --> 00:21:34.968
the animal left
and animal right file,

00:21:34.968 --> 00:21:37.434
in order to show the yak now.

00:21:37.434 --> 00:21:40.601
But say that when my user
sits down,

00:21:40.601 --> 00:21:43.901
they go to load animal left
and animal right,

00:21:43.901 --> 00:21:47.200
and because you can only control
how long a cache is allowed

00:21:47.200 --> 00:21:49.467
to keep something
in its cache,

00:21:49.467 --> 00:21:54.334
you cannot control when it--
that it will keep it there.

00:21:54.334 --> 00:21:56.734
The cache is allowed to evict
anything from it

00:21:56.734 --> 00:21:58.934
whenever it wants.

00:21:58.934 --> 00:22:02.667
So when the user goes to load
the favorite animal page,

00:22:02.667 --> 00:22:05.000
when they load animal left,
it's hit the cache,

00:22:05.000 --> 00:22:06.868
and the cow
is still in cache.

00:22:06.868 --> 00:22:11.734
So animal left is the cow,
but animal right

00:22:11.734 --> 00:22:14.834
has been evicted from the cache,
and so the user's request

00:22:14.834 --> 00:22:16.701
goes all the way back up
to the end server,

00:22:16.701 --> 00:22:18.667
and they get a yak.

00:22:18.667 --> 00:22:22.567
So now they see half a yak
and half a cow--not so good.

00:22:22.567 --> 00:22:26.534
So when you want to keep
multiple resources in sync,

00:22:26.534 --> 00:22:29.200
it's important to use
some sort of versioning.

00:22:29.200 --> 00:22:31.667
So here, if I just--
instead of overriding

00:22:31.667 --> 00:22:33.300
the animal left
and animal right files,

00:22:33.300 --> 00:22:37.234
I'd rename them to yak left
and yak right.

00:22:37.234 --> 00:22:39.367
Then, when the page loads,

00:22:39.367 --> 00:22:42.400
when that HTML page loads
that has these embedded,

00:22:42.400 --> 00:22:45.701
it will--
you have to change that page

00:22:45.701 --> 00:22:46.901
to say yak left
and yak right.

00:22:46.901 --> 00:22:49.100
And then if that page
was in cache,

00:22:49.100 --> 00:22:50.467
the cow will still
be fetched.

00:22:50.467 --> 00:22:53.434
If the page was not in cache,
the yak will be fetched,

00:22:53.434 --> 00:22:57.000
and we never get
the yak-cow problem.

00:22:57.000 --> 00:22:59.367
So a good general rule
for how to set cache headers,

00:22:59.367 --> 00:23:02.167
which are set on the server--
so either your Apache server,

00:23:02.167 --> 00:23:06.000
your App Engine,
whatever your server is--

00:23:06.000 --> 00:23:09.834
a good general rule is things
like HTML don't cache them

00:23:09.834 --> 00:23:13.167
or set their cache expiry
to be however long of latency

00:23:13.167 --> 00:23:16.267
you want your pages
to upload or to refresh.

00:23:16.267 --> 00:23:19.834
So if it's okay for users to
see data an hour that's stale,

00:23:19.834 --> 00:23:21.701
let them be cached
for an hour.

00:23:21.701 --> 00:23:24.200
But generally
don't cache HTML.

00:23:24.200 --> 00:23:28.234
Do cache forever JavaScript
Images, CSS, all of that,

00:23:28.234 --> 00:23:30.334
and then use versioning
within your HTML

00:23:30.334 --> 00:23:32.634
to fetch the new resource,
and always get it

00:23:32.634 --> 00:23:35.067
from the server when
you want it to be refreshed.

00:23:35.067 --> 00:23:37.434
And so you set the cache
control headers to public,

00:23:37.434 --> 00:23:43.033
and with an expiry date
really far in the future.

00:23:43.033 --> 00:23:45.000
Now, I mentioned
that the proximity of servers

00:23:45.000 --> 00:23:47.367
makes a big difference
to the users.

00:23:47.367 --> 00:23:51.167
One way to help move things
closer to your users

00:23:51.167 --> 00:23:53.567
may be to use a content
distribution network

00:23:53.567 --> 00:23:56.334
such as the Google
Libraries API.

00:23:56.334 --> 00:23:58.434
The Google Libraries API
makes some common

00:23:58.434 --> 00:24:01.567
JavaScript libraries available
on Google servers,

00:24:01.567 --> 00:24:04.300
which are often going to be
closer to your user

00:24:04.300 --> 00:24:07.467
than your server,
just because Google has servers

00:24:07.467 --> 00:24:09.734
all over the world.

00:24:09.734 --> 00:24:13.734
So here in this image, we see
that the user is the red star.

00:24:13.734 --> 00:24:16.133
And instead of having to go all
the way to the yellow pentagon,

00:24:16.133 --> 00:24:17.734
which is your server,

00:24:17.734 --> 00:24:19.200
it only has to go to
Google's server,

00:24:19.200 --> 00:24:24.534
which is just a little hop
across that channel of water.

00:24:24.534 --> 00:24:26.167
Day: All right,
so now we've talked

00:24:26.167 --> 00:24:28.234
about some of the techniques
to get the page

00:24:28.234 --> 00:24:30.801
and everything on your page,
loading quickly.

00:24:30.801 --> 00:24:33.467
We now sort of want to change
pace a bit and talk about

00:24:33.467 --> 00:24:36.634
how to make the page itself,
once it's in the browser,

00:24:36.634 --> 00:24:38.267
seem performant.

00:24:38.267 --> 00:24:40.133
So I'm going to start with
a little bit of a walk

00:24:40.133 --> 00:24:43.868
down memory lane.

00:24:43.868 --> 00:24:49.100
In the beginning, back in 2005,
maps.google.com was born.

00:24:49.100 --> 00:24:52.834
And with it came what I think
is a pretty attractive marker

00:24:52.834 --> 00:24:57.033
the designers came up with
to really show locations

00:24:57.033 --> 00:24:59.300
on a map where restaurants are,
where pizza is,

00:24:59.300 --> 00:25:03.334
more importantly, to make it
really stand out on the map,

00:25:03.334 --> 00:25:05.734
make it feel like it was
actually standing on the map

00:25:05.734 --> 00:25:08.300
instead of part of it.

00:25:08.300 --> 00:25:11.934
They introduced the drop shadow,
which made it really, you know,

00:25:11.934 --> 00:25:15.400
feel like it was standing up,
almost three-dimensional.

00:25:15.400 --> 00:25:20.067
The problem was if a second
marker was placed close by,

00:25:20.067 --> 00:25:22.834
that shadow from the first
marker would obscure it.

00:25:22.834 --> 00:25:25.868
And you can see,
it just looks terrible.

00:25:25.868 --> 00:25:27.767
So to get around that,
what we needed to do

00:25:27.767 --> 00:25:30.868
was split the red marker image
from its shadow

00:25:30.868 --> 00:25:32.634
into two separate images

00:25:32.634 --> 00:25:35.567
so that we could
arrange them correctly,

00:25:35.567 --> 00:25:39.267
and now we don't have
that problem.

00:25:39.267 --> 00:25:40.834
Another problem
that we needed to solve

00:25:40.834 --> 00:25:43.968
was how do you display more
information about that point,

00:25:43.968 --> 00:25:47.667
when the user interacts with it?
So the info window was born.

00:25:47.667 --> 00:25:51.868
An info window really takes that
curved 3D look of the marker

00:25:51.868 --> 00:25:52.901
to the next level.

00:25:52.901 --> 00:25:54.467
It really pops out of the page,

00:25:54.467 --> 00:25:57.701
and it's got massive shadow
behind it

00:25:57.701 --> 00:26:00.501
to make it feel like, you know,
a giant speech bubble

00:26:00.501 --> 00:26:02.534
popping out of the earth.

00:26:02.534 --> 00:26:04.367
The problem with that shadow is,
though,

00:26:04.367 --> 00:26:07.601
it can obscure other things
like markers nearby.

00:26:07.601 --> 00:26:10.234
And so you, as a user,
you can see that marker,

00:26:10.234 --> 00:26:12.834
and you expect,
if I click that marker,

00:26:12.834 --> 00:26:15.567
its info window is going to
open up instead.

00:26:15.567 --> 00:26:17.968
But the browser has a completely
different interpretation

00:26:17.968 --> 00:26:19.267
of what's going on.

00:26:19.267 --> 00:26:22.968
It says that info window
and that shadow,

00:26:22.968 --> 00:26:25.634
they're in front
of that marker,

00:26:25.634 --> 00:26:29.167
and it only cares about what
order images or DOM elements

00:26:29.167 --> 00:26:31.734
are arranged in the document.

00:26:31.734 --> 00:26:33.634
And so when you click
the marker,

00:26:33.634 --> 00:26:36.067
it thinks you're actually
clicking the shadow.

00:26:36.067 --> 00:26:40.400
To get around this, we actually
had to add a third image--

00:26:40.400 --> 00:26:42.801
I mean, a third DOM element
onto the page,

00:26:42.801 --> 00:26:45.434
and that was just something
the user couldn't see,

00:26:45.434 --> 00:26:48.400
an invisible element
in front of the marker,

00:26:48.400 --> 00:26:49.801
so that when the user
did click it,

00:26:49.801 --> 00:26:51.868
that invisible element
caught the click

00:26:51.868 --> 00:26:57.100
and was able to redirect it
appropriately.

00:26:57.100 --> 00:27:00.200
All of that actually can lead
to some performance issues.

00:27:00.200 --> 00:27:02.234
So on this map,
I'm going to draw

00:27:02.234 --> 00:27:04.000
approximately 1,200 markers

00:27:04.000 --> 00:27:07.501
which represent the location
of Canadian airports.

00:27:07.501 --> 00:27:08.934
Susannah,
will you do the honors?

00:27:08.934 --> 00:27:10.033
Raub:
Yes.

00:27:10.033 --> 00:27:12.367
One Mississippi,
two Mississippi,

00:27:12.367 --> 00:27:15.334
three Mississippi, four.

00:27:15.334 --> 00:27:18.000
Day: Maybe 3 1/2
Mississippis?

00:27:18.000 --> 00:27:21.934
So it takes a long time
to render those on the map.

00:27:21.934 --> 00:27:25.133
But what's worse is,
even when they're on there,

00:27:25.133 --> 00:27:27.067
the performance
is pretty terrible.

00:27:27.067 --> 00:27:30.234
You can see
it's laggy when I zoom.

00:27:30.234 --> 00:27:32.801
It just feels messy.
It feels like

00:27:32.801 --> 00:27:34.501
I'm not interacting
with the map anymore.

00:27:34.501 --> 00:27:37.267
It's just a cludgy experience.

00:27:37.267 --> 00:27:41.267
So as an API team, we really
had to solve this problem,

00:27:41.267 --> 00:27:44.100
and there were two ways
we really could do it.

00:27:44.100 --> 00:27:47.501
One was to simplify,
to get rid of this marker,

00:27:47.501 --> 00:27:49.400
which we've all
come to know and love--

00:27:49.400 --> 00:27:52.901
try and simplify it, maybe
make it smaller and boxier,

00:27:52.901 --> 00:27:54.200
get rid of shadows,

00:27:54.200 --> 00:27:58.000
so we didn't have
any of these clicking problems,

00:27:58.000 --> 00:27:59.968
maybe simplify
the info window again,

00:27:59.968 --> 00:28:01.567
make it smaller and boxier,

00:28:01.567 --> 00:28:04.033
and then use just
normal DOM rendering.

00:28:04.033 --> 00:28:06.934
All we had to work out,
how do we solve this problem

00:28:06.934 --> 00:28:10.968
while keeping the aesthetics?

00:28:10.968 --> 00:28:12.434
And the lesson we came to--

00:28:12.434 --> 00:28:16.534
well, what we learned
was the DOM is slow.

00:28:16.534 --> 00:28:18.300
Every time your JavaScript
reaches out

00:28:18.300 --> 00:28:19.434
and talks to that page

00:28:19.434 --> 00:28:21.033
and tries to make it
do something,

00:28:21.033 --> 00:28:26.033
add an extra element,
you are incurring a real cost.

00:28:26.033 --> 00:28:28.901
So that's why we were really
excited when canvas

00:28:28.901 --> 00:28:30.834
came on the scene.

00:28:30.834 --> 00:28:33.667
Now, for those of you who
aren't familiar with canvas,

00:28:33.667 --> 00:28:37.501
it's considered one of
the HTML5 technologies.

00:28:37.501 --> 00:28:39.701
You basically can think
of canvas

00:28:39.701 --> 00:28:41.701
as your favorite
paint program.

00:28:41.701 --> 00:28:44.968
It's just a dumb pixel buffer
that sits on the page.

00:28:44.968 --> 00:28:48.534
You can draw points on it.
You can draw lines and circles.

00:28:48.534 --> 00:28:50.300
You can write text into it.

00:28:50.300 --> 00:28:52.801
You can even draw
other images into it.

00:28:52.801 --> 00:28:54.267
But once you've drawn
those things,

00:28:54.267 --> 00:28:56.400
the canvas doesn't care about
the content anymore.

00:28:56.400 --> 00:29:01.601
It just worries about the
pixels, so what it looks like.

00:29:01.601 --> 00:29:04.868
Just to give you an idea of how
quickly canvas performs

00:29:04.868 --> 00:29:09.567
compared to images, I'm going
to draw 10,000 images here

00:29:09.567 --> 00:29:13.100
on the left.

00:29:13.100 --> 00:29:15.767
You see, it's not quite
3 1/2 Mississippis here,

00:29:15.767 --> 00:29:18.267
but it's still,
seemed like noticeably slow.

00:29:18.267 --> 00:29:20.334
You can see the delay.

00:29:20.334 --> 00:29:23.400
If I do the same operation
in canvas,

00:29:23.400 --> 00:29:30.100
by the time I finish clicking,
the markers have all been drawn.

00:29:30.100 --> 00:29:32.300
Now, I'm just going to throw up
a couple of code snippets,

00:29:32.300 --> 00:29:34.467
and these are just to give you
an idea of what's involved

00:29:34.467 --> 00:29:35.968
in using canvas.

00:29:35.968 --> 00:29:38.167
It's probably not something
that you're going to use

00:29:38.167 --> 00:29:39.601
in every element
of your page.

00:29:39.601 --> 00:29:40.968
It's really something
where you're worried

00:29:40.968 --> 00:29:42.367
about performance.

00:29:42.367 --> 00:29:44.901
But here's what the code
would look like--

00:29:44.901 --> 00:29:46.901
well, did look like--
in that left hand side,

00:29:46.901 --> 00:29:48.801
where I was using
image elements.

00:29:48.801 --> 00:29:50.767
It basically consists
of two things.

00:29:50.767 --> 00:29:53.701
One is creating a DOM element,
which is the image,

00:29:53.701 --> 00:29:55.200
and setting its source
and its position

00:29:55.200 --> 00:29:57.634
so that it's in the right place
on the page and looks right,

00:29:57.634 --> 00:30:00.267
and then adding that to
a parent node,

00:30:00.267 --> 00:30:04.467
so that it's actually
added to the document.

00:30:04.467 --> 00:30:07.033
The equivalent piece of code
for canvas

00:30:07.033 --> 00:30:09.934
has a couple of extra
complications.

00:30:09.934 --> 00:30:11.834
One is, once we've got
the canvas download,

00:30:11.834 --> 00:30:14.000
we actually have to ask
the canvas

00:30:14.000 --> 00:30:15.334
for its drawing context.

00:30:15.334 --> 00:30:19.400
You can think of that
as that DOM pixel buffer.

00:30:19.400 --> 00:30:22.734
The other thing we have to do
is load the image onto the page

00:30:22.734 --> 00:30:24.501
and wait for the image
to have arrived

00:30:24.501 --> 00:30:27.300
before we try and draw
into the canvas.

00:30:27.300 --> 00:30:30.267
As I mentioned earlier, well,
I've mentioned a few times now,

00:30:30.267 --> 00:30:32.467
the canvas is just
a pixel buffer.

00:30:32.467 --> 00:30:35.167
So if you try and draw an image
that hasn't even arrived

00:30:35.167 --> 00:30:37.400
on the page yet, it's not
going to know what to do,

00:30:37.400 --> 00:30:39.601
and it's going to just
ignore it for you.

00:30:39.601 --> 00:30:41.400
Nothing is going to happen.

00:30:41.400 --> 00:30:43.033
So you do have to have
that complication of waiting

00:30:43.033 --> 00:30:45.734
for an image to load
before you can draw it.

00:30:45.734 --> 00:30:49.300
But you can see it's actually
not significantly more code,

00:30:49.300 --> 00:30:53.334
just a little bit
of a mind shift.

00:30:53.334 --> 00:30:55.834
So when we applied this and
a few other little techniques

00:30:55.834 --> 00:30:58.400
we had up our sleeves
to markers,

00:30:58.400 --> 00:31:00.067
you can see what difference
it made.

00:31:00.067 --> 00:31:02.167
Susannah?
Raub: Okay.

00:31:02.167 --> 00:31:04.701
One Mississ--
Day: Oh.

00:31:04.701 --> 00:31:06.534
It's less than
a Mississippi.

00:31:06.534 --> 00:31:10.167
It's probably a small creek
somewhere.

00:31:10.167 --> 00:31:14.901
But now, as well as drawing
quickly, look how that feels.

00:31:14.901 --> 00:31:17.434
It's panning smoothly.

00:31:17.434 --> 00:31:19.667
It's zooming smoothly.

00:31:19.667 --> 00:31:21.767
It actually feels like,
once again,

00:31:21.767 --> 00:31:23.534
I'm in the page
with the map.

00:31:23.534 --> 00:31:24.801
There's nothing between me
and the map,

00:31:24.801 --> 00:31:28.467
and we're interacting
directly.

00:31:28.467 --> 00:31:29.968
Raub: One thing that should
be noted, too,

00:31:29.968 --> 00:31:32.567
is this is actually a very
fast machine that we're on here,

00:31:32.567 --> 00:31:36.567
and if you were on a slower
machine, a smaller one,

00:31:36.567 --> 00:31:40.033
anything, that 3 1/2
Mississippis could be

00:31:40.033 --> 00:31:41.267
a lot more than that,

00:31:41.267 --> 00:31:44.133
and dragging would be
absolutely impossible.

00:31:44.133 --> 00:31:47.234
Now, there's another part to how
we made the markers

00:31:47.234 --> 00:31:51.834
as fast as we did with canvas,
and I need to back up

00:31:51.834 --> 00:31:54.634
a little bit to talk about
and explain how we did this.

00:31:54.634 --> 00:31:58.133
So one of the initial features
that set Google Maps apart

00:31:58.133 --> 00:32:02.367
from its predecessors,
originally, back in 2004-2005,

00:32:02.367 --> 00:32:04.767
was that it was
infinitely draggable.

00:32:04.767 --> 00:32:08.133
Previously, Maps had been loaded
with one static image

00:32:08.133 --> 00:32:10.968
that had to change
each time you wanted to pan

00:32:10.968 --> 00:32:14.100
to a new part of the map
and load a fresh image.

00:32:14.100 --> 00:32:17.167
This is partly because showing
at zoom level ten,

00:32:17.167 --> 00:32:21.934
which is half of the zoom levels
that we have on Google Maps,

00:32:21.934 --> 00:32:24.334
would take about
15 gigabytes of data

00:32:24.334 --> 00:32:26.934
to render that whole map
of the world.

00:32:26.934 --> 00:32:29.801
So if you wanted a draggable
map for the whole world

00:32:29.801 --> 00:32:31.000
at zoom level ten,

00:32:31.000 --> 00:32:34.234
your browser would have
been able to do that.

00:32:34.234 --> 00:32:36.133
Now, we've seen that the browser
can't even handle

00:32:36.133 --> 00:32:38.834
10,000 small marker elements.

00:32:38.834 --> 00:32:41.534
I'm sure 10,000 elements
is different than one big one,

00:32:41.534 --> 00:32:43.901
but really
it can't do either.

00:32:43.901 --> 00:32:47.000
So Google Maps,
what it originally did

00:32:47.000 --> 00:32:50.534
was take that world imagery
and cut it, pre-compute,

00:32:50.534 --> 00:32:55.834
cut it into slices,
256 X 256 pixel images

00:32:55.834 --> 00:32:58.067
that could then
be sent to the client

00:32:58.067 --> 00:33:01.601
and stitched together there,
which then when dragged,

00:33:01.601 --> 00:33:04.767
would load
as they're necessary

00:33:04.767 --> 00:33:06.434
and create
this infinite dragging.

00:33:06.434 --> 00:33:08.133
So here we see
in the center,

00:33:08.133 --> 00:33:10.701
that's the map
that the user actually sees,

00:33:10.701 --> 00:33:13.100
and what's behind it
is what we're not loading.

00:33:13.100 --> 00:33:15.200
Often, we load
a padding around it,

00:33:15.200 --> 00:33:17.734
but what's behind there would be
what you would have to load

00:33:17.734 --> 00:33:22.434
in order to have the same
functionality without tiles.

00:33:22.434 --> 00:33:30.234
So we apply this technique
to a number of different things

00:33:30.234 --> 00:33:31.434
that we do on the map,

00:33:31.434 --> 00:33:34.934
one of those being
those canvas markers.

00:33:34.934 --> 00:33:38.067
And so instead of just
rendering all of the markers

00:33:38.067 --> 00:33:39.434
in the canvas
all the time

00:33:39.434 --> 00:33:43.734
and having to have one
that's as big as the map,

00:33:43.734 --> 00:33:47.400
we split it into these tiles
and render them in parts.

00:33:47.400 --> 00:33:49.033
So when looking at
the Canadian airports,

00:33:49.033 --> 00:33:51.133
if you're zoomed in
on British Columbia,

00:33:51.133 --> 00:33:54.300
we will not show, we will not
render the canvas markers

00:33:54.300 --> 00:33:56.834
for all of the airports
in Nova Scotia, as well.

00:33:56.834 --> 00:33:59.133
We will only be rendering
those for British Columbia,

00:33:59.133 --> 00:34:01.067
doing as little work
as possible.

00:34:01.067 --> 00:34:04.234
Now, an alternative to using
canvas markers

00:34:04.234 --> 00:34:07.767
and doing that all on the client
is KML.

00:34:07.767 --> 00:34:15.000
KML is an open source format
for representing geographic data

00:34:15.000 --> 00:34:16.801
and presenting
geographic data.

00:34:16.801 --> 00:34:21.501
It's an XML format that allows
you to specify place marks,

00:34:21.501 --> 00:34:24.534
extended information
about place marks,

00:34:24.534 --> 00:34:27.200
polylines, polygons,
ground overlays,

00:34:27.200 --> 00:34:30.501
and other things to render
on the map.

00:34:30.501 --> 00:34:33.534
Now, we have in the Maps API
a KML layer,

00:34:33.534 --> 00:34:37.133
and when you specify a KML file
to that KML layer,

00:34:37.133 --> 00:34:38.901
it sends a request
to our server,

00:34:38.901 --> 00:34:41.434
which goes out and fetches
your KML file,

00:34:41.434 --> 00:34:44.067
so it must be hosted
on a publicly available server.

00:34:44.067 --> 00:34:47.868
It fetches that KML file,
comes back to the server,

00:34:47.868 --> 00:34:51.000
renders all of that,
parses that file

00:34:51.000 --> 00:34:53.501
and renders it all
into image tiles

00:34:53.501 --> 00:34:56.067
that are then requested
by the client.

00:34:56.067 --> 00:35:01.634
So each of these KML files
are split into tiles

00:35:01.634 --> 00:35:04.868
just like our marker rendering
for the canvas

00:35:04.868 --> 00:35:09.100
and just like our image tiles
for actually showing the map.

00:35:09.100 --> 00:35:13.300
This means that you can show
10,000 or so place marks

00:35:13.300 --> 00:35:16.033
in exactly the same amount
of time as one.

00:35:16.033 --> 00:35:19.534
There is no added cost
to showing more place marks

00:35:19.534 --> 00:35:22.033
when loading it from KML.

00:35:22.033 --> 00:35:24.934
But KML, as I said,
is this XML format,

00:35:24.934 --> 00:35:26.634
and each time you want
to change the data,

00:35:26.634 --> 00:35:28.634
you have to
regenerate the file.

00:35:28.634 --> 00:35:30.400
So if you're trying
to add more data,

00:35:30.400 --> 00:35:32.667
you have to regenerate
the file, re-upload it,

00:35:32.667 --> 00:35:37.734
and, of course,
version it because of caching.

00:35:37.734 --> 00:35:41.033
So an alternative of this
is to use Fusion Tables.

00:35:41.033 --> 00:35:46.300
Fusion Tables is Google's
online data store for any data,

00:35:46.300 --> 00:35:49.534
but it's particularly good
for location-based data.

00:35:49.534 --> 00:35:53.033
Fusion Tables allows you
to store in rows and columns

00:35:53.033 --> 00:35:57.000
any sort of structured data,
and then, to be queried

00:35:57.000 --> 00:36:01.167
by our Fusion Tables layer,
either as an entire table--

00:36:01.167 --> 00:36:05.200
so here we see, again,
the Canadian airports loaded.

00:36:05.200 --> 00:36:06.267
That's the entire table.

00:36:06.267 --> 00:36:08.667
It's all 1,200 airports.

00:36:08.667 --> 00:36:12.567
You can also specify a query
to only fetch part of the table.

00:36:12.567 --> 00:36:15.267
This is an SQL-like query,
and here Dave is showing

00:36:15.267 --> 00:36:18.901
if you specify, you ask
for only airports

00:36:18.901 --> 00:36:20.767
with a minimum elevation.

00:36:20.767 --> 00:36:22.234
And so dynamically

00:36:22.234 --> 00:36:24.601
we have changed this table,
and at each level,

00:36:24.601 --> 00:36:32.367
it has fetched new tiles
to show this airport data.

00:36:32.367 --> 00:36:34.701
So just like KML,
just like our markers,

00:36:34.701 --> 00:36:37.000
we render these things
into tiles

00:36:37.000 --> 00:36:40.868
so that many points to render
take the same amount of time

00:36:40.868 --> 00:36:43.901
as a few points to render.

00:36:43.901 --> 00:36:46.167
Now, the other thing that both
KML and Fusion Tables do--

00:36:46.167 --> 00:36:47.667
oh, and I should mention
there was a talk

00:36:47.667 --> 00:36:50.000
on Fusion Tables yesterday,
so if you're interested

00:36:50.000 --> 00:36:51.334
in learning more,
you should check out

00:36:51.334 --> 00:36:54.067
Katherine and James' talk
online.

00:36:54.067 --> 00:36:57.767
The other thing that KML
and Fusion Tables do

00:36:57.767 --> 00:37:01.300
is they wait until a user needs
that extended data

00:37:01.300 --> 00:37:03.100
before loading it
into the client.

00:37:03.100 --> 00:37:07.200
So if you were to render
all those Canadian airports

00:37:07.200 --> 00:37:09.567
by creating new markers
and having us render them,

00:37:09.567 --> 00:37:11.934
though it may be fast
and draggable,

00:37:11.934 --> 00:37:15.367
you would need to have data
at that time to

00:37:15.367 --> 00:37:16.901
show what you want in,
say, the info window,

00:37:16.901 --> 00:37:18.334
when you click on it.

00:37:18.334 --> 00:37:22.767
But with KML and Fusion Tables,
when Dave clicks on that marker,

00:37:22.767 --> 00:37:26.834
at that time, we go off
to the server

00:37:26.834 --> 00:37:31.400
and request the extended data
for that airport in Nunavut,

00:37:31.400 --> 00:37:34.167
and so no extra data
has been loaded into the client

00:37:34.167 --> 00:37:38.267
until it's required.

00:37:38.267 --> 00:37:39.701
Now, you can tile anything.

00:37:39.701 --> 00:37:41.968
You can do this yourself.

00:37:41.968 --> 00:37:45.601
At the time of the floods
in Brisbane in January,

00:37:45.601 --> 00:37:49.567
we put together a map,
and we had this great overlay

00:37:49.567 --> 00:37:55.534
that showed where the river
levels were predicted to go,

00:37:55.534 --> 00:37:57.467
but this image
was quite large,

00:37:57.467 --> 00:37:59.667
and loading it in
took some time.

00:37:59.667 --> 00:38:00.901
And, again,
this is a fast machine,

00:38:00.901 --> 00:38:02.868
so it didn't take
as long as it would have

00:38:02.868 --> 00:38:04.667
on many other machines.

00:38:04.667 --> 00:38:07.167
But dragging the map
became nearly impossible,

00:38:07.167 --> 00:38:10.434
and this file is--
Dave, how big is this file?

00:38:10.434 --> 00:38:12.067
Day:
Just over two megs.

00:38:12.067 --> 00:38:16.300
Raub: Two megs, and so
that makes it almost impossible

00:38:16.300 --> 00:38:18.667
for the browser to render,
and if we zoom in further,

00:38:18.667 --> 00:38:22.400
it will become worse
and worse.

00:38:22.400 --> 00:38:25.400
So instead,
we need to create tiles.

00:38:25.400 --> 00:38:27.567
Now, the image map type class
in the Maps API

00:38:27.567 --> 00:38:30.667
makes it very easy
to load tiles.

00:38:30.667 --> 00:38:33.167
You can use open source tools,
such as Map Tiler

00:38:33.167 --> 00:38:36.567
and a few others
to cut your large image

00:38:36.567 --> 00:38:39.100
into individual tiles.

00:38:39.100 --> 00:38:42.200
What this does is,
at each zoom level,

00:38:42.200 --> 00:38:46.701
creates tiles that specify
for each coordinate

00:38:46.701 --> 00:38:49.534
in whatever size images
you're telling it.

00:38:49.534 --> 00:38:53.133
So we often use
256 X 256 pixels.

00:38:53.133 --> 00:38:54.801
It works pretty well.

00:38:54.801 --> 00:38:58.734
So after cutting
the large image

00:38:58.734 --> 00:39:01.133
into these individual tiles,

00:39:01.133 --> 00:39:05.167
the image map type defines
the get tile URL function,

00:39:05.167 --> 00:39:08.968
which just returns a URL
to the image that you want.

00:39:08.968 --> 00:39:10.701
And so for our format,

00:39:10.701 --> 00:39:15.300
it's the path
where all the tiles are

00:39:15.300 --> 00:39:17.300
and then they're stored
in one directory

00:39:17.300 --> 00:39:19.767
for the zoom level
and then in each zoom level,

00:39:19.767 --> 00:39:21.534
one directory for each
X coordinate

00:39:21.534 --> 00:39:22.934
and then each
Y coordinate.

00:39:22.934 --> 00:39:26.067
You can have your format be
whatever you want for these,

00:39:26.067 --> 00:39:27.834
but all you need to do
in the image map type

00:39:27.834 --> 00:39:31.000
is return the URL for the image,
for the coordinate

00:39:31.000 --> 00:39:35.834
and zoom level that we've
passed in to get tile URL.

00:39:35.834 --> 00:39:39.567
So the result of that,
it loads a lot faster.

00:39:39.567 --> 00:39:42.200
It zoomed--or it pans,
it zooms,

00:39:42.200 --> 00:39:43.968
and we get the added benefit
that image map type

00:39:43.968 --> 00:39:45.300
supports opacity,

00:39:45.300 --> 00:39:48.767
so we no longer have an opaque
blue overlay on the map.

00:39:48.767 --> 00:39:50.734
We now have this semitransparent
blue,

00:39:50.734 --> 00:39:54.334
and you can still see
where the towns are

00:39:54.334 --> 00:39:57.667
that were to be flooded.

00:39:57.667 --> 00:40:01.334
You can tile anything,
not just images.

00:40:01.334 --> 00:40:05.501
The map type interface
in the API gives you

00:40:05.501 --> 00:40:09.334
a coordinate,
and you create a div,

00:40:09.334 --> 00:40:12.100
and you return the div
instead of a URL.

00:40:12.100 --> 00:40:14.601
So here I've created
this coordinate map type,

00:40:14.601 --> 00:40:17.968
which--so for each coordinate
and zoom level,

00:40:17.968 --> 00:40:19.934
it just prints out
the coordinates,

00:40:19.934 --> 00:40:21.734
which could be useful
maybe to use,

00:40:21.734 --> 00:40:27.968
while developing
your other tiled map types.

00:40:27.968 --> 00:40:30.267
So the map type interface
just requires you

00:40:30.267 --> 00:40:34.534
to specify a tile size
and to define get tile.

00:40:34.534 --> 00:40:37.300
And so get tile passes
in the coordinate,

00:40:37.300 --> 00:40:39.167
the zoom level,
and the document.

00:40:39.167 --> 00:40:40.534
We pass in the document,

00:40:40.534 --> 00:40:42.434
so that we don't have
any problems with i-frames,

00:40:42.434 --> 00:40:46.100
so that you're creating
the element

00:40:46.100 --> 00:40:47.601
with the correct document.

00:40:47.601 --> 00:40:48.834
So you take our document.

00:40:48.834 --> 00:40:51.801
You call create element on it,
make it a div.

00:40:51.801 --> 00:40:54.534
I guess you could give it
any node.

00:40:54.534 --> 00:40:57.667
We'll attach any DOM element
to the DOM for you,

00:40:57.667 --> 00:41:00.000
and then you can put whatever
you want in it,

00:41:00.000 --> 00:41:03.667
and we will position it
on the correct tile,

00:41:03.667 --> 00:41:08.267
because the world is split
into these fixed boundaries,

00:41:08.267 --> 00:41:10.334
where at zoom level zero,
there's one tile,

00:41:10.334 --> 00:41:12.534
and so the coordinate
is always 00.

00:41:12.534 --> 00:41:15.734
It's then at zoom level one,
divided into quadrants,

00:41:15.734 --> 00:41:18.968
and then at each tile
from there,

00:41:18.968 --> 00:41:23.734
it's divided again
into four.

00:41:23.734 --> 00:41:25.834
Day: So the other approach
you can take

00:41:25.834 --> 00:41:29.501
is simplifying the data before
you give it to the browser,

00:41:29.501 --> 00:41:31.300
because, as we saw,
everything you can give

00:41:31.300 --> 00:41:33.534
to the browser
incurs a cost.

00:41:33.534 --> 00:41:37.501
If you saw Jazz and Luke's talk
on User Experience yesterday,

00:41:37.501 --> 00:41:41.033
then you also realize
that often bombarding your users

00:41:41.033 --> 00:41:43.067
with information
can overwhelm them.

00:41:43.067 --> 00:41:44.701
It's the same
with the browser.

00:41:44.701 --> 00:41:47.300
So the principle
you should always apply

00:41:47.300 --> 00:41:51.467
is keep it simple,
Susannah.

00:41:51.467 --> 00:41:52.634
[laughter]
Thank you.

00:41:52.634 --> 00:41:55.601
I practiced that one earlier.
[laughter]

00:41:55.601 --> 00:41:58.467
Here, you can see we're using
the open source market cluster

00:41:58.467 --> 00:42:02.567
to again use those 1,200
Canadian airports on the map.

00:42:02.567 --> 00:42:04.601
But instead of rendering
1,200 markets,

00:42:04.601 --> 00:42:06.734
we're rendering
relatively few,

00:42:06.734 --> 00:42:10.501
which just gives you an overview
of where those airports are.

00:42:10.501 --> 00:42:14.067
So here, the heavy lifting
was done by the JavaScript

00:42:14.067 --> 00:42:16.133
before we started talking
to the DOM,

00:42:16.133 --> 00:42:18.234
and doing things
in pure JavaScript

00:42:18.234 --> 00:42:21.801
is generally really quick.

00:42:21.801 --> 00:42:26.501
Now, things like JavaScript
in canvas as we saw,

00:42:26.501 --> 00:42:28.868
can really start to take away
that heavy lifting

00:42:28.868 --> 00:42:31.501
from the browser,
but a new technology,

00:42:31.501 --> 00:42:33.934
which takes it one step further,
and actually asks

00:42:33.934 --> 00:42:36.968
your users' graphics card
to take away the heavy lifting

00:42:36.968 --> 00:42:39.133
is WebGL.

00:42:39.133 --> 00:42:42.467
WebGL is based on
the OpenGL ES Library,

00:42:42.467 --> 00:42:44.834
which is the same graphics
libraries used

00:42:44.834 --> 00:42:49.234
by all mobile devices to render
graphics in 3D context.

00:42:49.234 --> 00:42:51.667
So it is like a powerful
open standard

00:42:51.667 --> 00:42:54.801
to get 3D graphics
performance.

00:42:54.801 --> 00:42:57.968
To give you an example of
how powerful this can be,

00:42:57.968 --> 00:43:00.067
I've got two panoramas,
street view panoramas here,

00:43:00.067 --> 00:43:02.400
which I've rendered
in two different ways.

00:43:02.400 --> 00:43:05.033
On the left hand side,
I've rendered using just

00:43:05.033 --> 00:43:07.067
traditional canvas 2D,

00:43:07.067 --> 00:43:09.868
and we've carved up
the street view triangles

00:43:09.868 --> 00:43:12.467
to make it actually fit
together right,

00:43:12.467 --> 00:43:15.167
so you get
the right perspective.

00:43:15.167 --> 00:43:18.601
And you can see, as I pan,
it's a bit jumpy,

00:43:18.601 --> 00:43:24.701
it's a bit jarry.

00:43:24.701 --> 00:43:27.801
It's not terrible,
but, again, it's not great.

00:43:27.801 --> 00:43:30.367
And actually,
we had this performance,

00:43:30.367 --> 00:43:32.567
this same demo running
on my Mac,

00:43:32.567 --> 00:43:34.634
and it was absolutely unusable.

00:43:34.634 --> 00:43:37.367
You'd get a refresh maybe
once every second or so.

00:43:37.367 --> 00:43:39.467
It was--you couldn't
use this at all.

00:43:39.467 --> 00:43:42.701
So if you do, check out
our slides later online.

00:43:42.701 --> 00:43:43.934
Try it out
on your own machine,

00:43:43.934 --> 00:43:47.067
and see how canvas
is performing for you.

00:43:47.067 --> 00:43:49.367
On the right,
we've got the same imagery,

00:43:49.367 --> 00:43:51.133
but this time using WebGL,

00:43:51.133 --> 00:43:53.133
so we're using
the graphics card,

00:43:53.133 --> 00:43:56.234
and you can see
it's absolutely smooth.

00:43:56.234 --> 00:43:58.934
It's absolutely crisp,
and that's because

00:43:58.934 --> 00:44:01.100
now the browser
is not doing the work.

00:44:01.100 --> 00:44:02.601
It's the graphics card.

00:44:02.601 --> 00:44:04.234
And this is sort of
the exciting future

00:44:04.234 --> 00:44:06.434
that we're getting
towards in browsers,

00:44:06.434 --> 00:44:09.334
where we can rely on these tools
more and more to actually do

00:44:09.334 --> 00:44:10.734
some of this heavy lifting

00:44:10.734 --> 00:44:15.133
and get a much more compelling
experience for our users.

00:44:15.133 --> 00:44:17.667
All right, so...

00:44:17.667 --> 00:44:19.834
to get started,
here's some great resources.

00:44:19.834 --> 00:44:22.968
I recommend you go
and check out all three.

00:44:22.968 --> 00:44:24.801
The top one is really how
do you get your website

00:44:24.801 --> 00:44:28.167
and your server working well,
and the compiler is about

00:44:28.167 --> 00:44:30.200
that JavaScript compiler
I talked about earlier.

00:44:30.200 --> 00:44:32.334
And then, of course,
I really encourage you

00:44:32.334 --> 00:44:34.567
to go and check out
all our API documentation,

00:44:34.567 --> 00:44:37.000
which includes a lot of
guides, articles,

00:44:37.000 --> 00:44:38.901
and example code, as well.

00:44:38.901 --> 00:44:40.667
So thank you all
for your time,

00:44:40.667 --> 00:44:43.100
and we'd love to answer
any questions you've got,

00:44:43.100 --> 00:44:46.767
if you want to stand up
to the mic.

00:44:46.767 --> 00:44:51.434
Raub: Thank you.
[applause]

00:44:51.434 --> 00:44:52.734
man:
Hello, I've got two questions,

00:44:52.734 --> 00:44:54.601
if that's okay.
Day: Sure.

00:44:54.601 --> 00:44:57.567
man: The first one is when
you're rendering the KML tiles,

00:44:57.567 --> 00:44:59.701
and you're rendering things
from Fusion Tables,

00:44:59.701 --> 00:45:03.000
how much do you depend
on the pure raw power

00:45:03.000 --> 00:45:05.567
of the cloud to dynamically
render those tiles,

00:45:05.567 --> 00:45:07.934
and how much do you render
that kind of ahead of time?

00:45:07.934 --> 00:45:10.567
So if a user uploads data
to fusion tiles--

00:45:10.567 --> 00:45:11.834
or to the Fusion Tables--

00:45:11.834 --> 00:45:15.267
do you try and do
a couple of zoom levels?

00:45:15.267 --> 00:45:18.467
Because there's 23, you don't
want to try and do everything.

00:45:18.467 --> 00:45:22.100
Day: Actually, usually,
we rely on the pure raw power,

00:45:22.100 --> 00:45:25.701
especially with Fusion Tables,
where we don't know what query

00:45:25.701 --> 00:45:29.367
and what, you know, even what
the data might be in the table,

00:45:29.367 --> 00:45:31.567
until you ask for the tile.

00:45:31.567 --> 00:45:34.234
So you really have to do
all of that rendering

00:45:34.234 --> 00:45:35.467
right there and then.

00:45:35.467 --> 00:45:37.634
We do some smart things,
like try to index it,

00:45:37.634 --> 00:45:40.334
but it's mostly just power.
man: Okay.

00:45:40.334 --> 00:45:42.901
Raub: It's also--it has to make
a round-trip to the server

00:45:42.901 --> 00:45:44.901
to actually fetch the tile,
which is probably

00:45:44.901 --> 00:45:46.901
so much greater
than the amount of time

00:45:46.901 --> 00:45:50.334
we're spending on the server,
that it's so greatly outweighed

00:45:50.334 --> 00:45:52.767
by the network time.
man: Okay.

00:45:52.767 --> 00:45:54.801
And the other quick question
I had was

00:45:54.801 --> 00:45:57.467
a lot of this is great,
but there's a lot of customers--

00:45:57.467 --> 00:45:59.734
larger enterprise
or disconnected networks--

00:45:59.734 --> 00:46:02.667
that may want to use this
or don't want to be uploading

00:46:02.667 --> 00:46:05.067
their data to public
Google servers.

00:46:05.067 --> 00:46:07.534
Is there any way that this will
be integrated back with, like,

00:46:07.534 --> 00:46:08.868
the Google Earth
Enterprise Team,

00:46:08.868 --> 00:46:10.467
bring some of this capability
back that way,

00:46:10.467 --> 00:46:12.901
especially the KML rendering.

00:46:12.901 --> 00:46:15.200
Day: I'm not sure of any plans
on those regards.

00:46:15.200 --> 00:46:18.033
Definitely, all the stuff
we talked earlier,

00:46:18.033 --> 00:46:19.601
like the canvas,
you can use that

00:46:19.601 --> 00:46:21.901
without ever that data
coming to us.

00:46:21.901 --> 00:46:26.100
And there is also,
there is a premier offering

00:46:26.100 --> 00:46:27.300
for Fusion Tables.

00:46:27.300 --> 00:46:28.567
You do store the data
in the cloud,

00:46:28.567 --> 00:46:31.133
but it does help you keep it
much more private,

00:46:31.133 --> 00:46:33.000
when it comes to
map rendering.

00:46:33.000 --> 00:46:34.167
man: Okay.
Day: Yeah.

00:46:34.167 --> 00:46:35.534
Raub: This is also
a great time to pitch.

00:46:35.534 --> 00:46:39.734
At 12:45, I think it is,
we have the Geo Fireside Chat,

00:46:39.734 --> 00:46:41.834
where we'll have a number
of our product managers,

00:46:41.834 --> 00:46:44.767
who would be even better
to answer such questions.

00:46:44.767 --> 00:46:46.901
man:
Okay, thank you.

00:46:46.901 --> 00:46:48.968
man:
Regarding the using canvas

00:46:48.968 --> 00:46:51.534
for drawing the markers,
does it fall back

00:46:51.534 --> 00:46:55.033
to the old style
of rendering them

00:46:55.033 --> 00:46:56.400
if the browser
doesn't support it?

00:46:56.400 --> 00:46:59.133
Day: Yeah, we definitely,
we fall back

00:46:59.133 --> 00:47:01.567
whenever the browser
is not going to--

00:47:01.567 --> 00:47:02.801
whenever the browser is going
to use the old way better.

00:47:02.801 --> 00:47:04.467
And also for things
like draggable markers,

00:47:04.467 --> 00:47:07.033
it's more complicated
to do that in canvas

00:47:07.033 --> 00:47:08.968
than it is to have
a DOM element there.

00:47:08.968 --> 00:47:11.634
So there's a number of reasons
we fall back when we need to.

00:47:11.634 --> 00:47:12.734
man:
Okay, thank you.

00:47:12.734 --> 00:47:15.901
Raub: We also,
we used VML for IE,

00:47:15.901 --> 00:47:18.100
but it turned out VML
wasn't actually doing

00:47:18.100 --> 00:47:20.067
the same techniques
as canvas.

00:47:20.067 --> 00:47:23.834
Doing it in VML wasn't
actually such a win,

00:47:23.834 --> 00:47:26.200
so we're still rendering
DOM elements there,

00:47:26.200 --> 00:47:28.100
but doing some other
sort of trickery

00:47:28.100 --> 00:47:30.734
to get it to be
as fast as possible.

00:47:30.734 --> 00:47:33.701
So it's important to look at--
what you can do in canvas,

00:47:33.701 --> 00:47:36.000
you can normally do in VML,
but it's important to figure out

00:47:36.000 --> 00:47:38.133
are you actually winning
from doing it in VML?

00:47:38.133 --> 00:47:40.901
man: Yeah, maybe on that,
can you elaborate which browsers

00:47:40.901 --> 00:47:43.334
might not support canvas
or VML, if you know?

00:47:43.334 --> 00:47:46.234
Raub: Right.
So canvas is supported

00:47:46.234 --> 00:47:49.467
in all WebKit browsers.

00:47:49.467 --> 00:47:50.467
Day:
All Mozilla.

00:47:50.467 --> 00:47:52.000
Raub:
Yeah.

00:47:52.000 --> 00:47:53.901
Day:
And IE 9, I think.

00:47:53.901 --> 00:47:55.267
Is that right?
Raub: Yeah, I think so.

00:47:55.267 --> 00:47:56.834
Day:
Yeah.

00:47:56.834 --> 00:48:02.267
Raub: And we've found it to be
faster on all of those browsers.

00:48:02.267 --> 00:48:06.267
man: Any news on supporting
vector type of drawing,

00:48:06.267 --> 00:48:08.567
such as a SVG type of drawing,

00:48:08.567 --> 00:48:10.667
instead of just
a raster caching?

00:48:10.667 --> 00:48:12.801
Day: It's a really
exciting problem.

00:48:12.801 --> 00:48:14.934
We don't actually have
any concrete plans,

00:48:14.934 --> 00:48:18.167
mostly because still, like,
as we saw with WebGL,

00:48:18.167 --> 00:48:20.267
like, it's the browsers
that are catching up.

00:48:20.267 --> 00:48:22.367
Like, we could probably do
that all in native client,

00:48:22.367 --> 00:48:26.234
as you see in the Maps
client on Android,

00:48:26.234 --> 00:48:27.701
but then doing it
in the browsers--

00:48:27.701 --> 00:48:30.567
they're just one step behind.
man: All right. Thank you.

00:48:30.567 --> 00:48:31.567
Raub:
And you mentioned SVG.

00:48:31.567 --> 00:48:32.934
It's a good time to mention

00:48:32.934 --> 00:48:34.234
Android doesn't
actually support SVG.

00:48:34.234 --> 00:48:35.834
So if you're doing
something in SVG,

00:48:35.834 --> 00:48:38.234
make sure you have a canvas
implementation, as well.

00:48:38.234 --> 00:48:40.567
man:
Thanks.

00:48:40.567 --> 00:48:44.634
man: When you use the canvas
to draw the markers,

00:48:44.634 --> 00:48:48.033
you can't attach the click
handler directly to the marker.

00:48:48.033 --> 00:48:49.334
Day:
Right.

00:48:49.334 --> 00:48:50.767
man: So there's magic
done by Google Maps

00:48:50.767 --> 00:48:53.667
in the background to figure out
where it actually goes?

00:48:53.667 --> 00:48:55.634
Raub: Yes.
Day: Yeah, exactly.

00:48:55.634 --> 00:48:58.067
And we find that's not slow.

00:48:58.067 --> 00:49:00.100
Because you're only
clicking very rarely,

00:49:00.100 --> 00:49:03.300
you can spend a few tens
of milliseconds,

00:49:03.300 --> 00:49:05.634
then, going back and working out
which point corresponds

00:49:05.634 --> 00:49:08.000
to which marker,
and the user doesn't notice.

00:49:08.000 --> 00:49:11.434
man: But that just all happens
locally in JavaScript, right?

00:49:11.434 --> 00:49:12.501
Day: Yeah,
that's right, yeah.

00:49:12.501 --> 00:49:13.868
Raub: Something, though,
in canvas,

00:49:13.868 --> 00:49:16.534
any time that a resource is
loaded cross domain,

00:49:16.534 --> 00:49:19.067
you can't access that pixel data
any longer.

00:49:19.067 --> 00:49:21.200
So one way to hit detection
with canvas

00:49:21.200 --> 00:49:23.868
is to inspect the pixel data
of the canvas

00:49:23.868 --> 00:49:26.400
and see whether there's
something there or not.

00:49:26.400 --> 00:49:28.234
But if you've loaded
your image cross domain,

00:49:28.234 --> 00:49:31.033
you can no longer do that
for security reasons.

00:49:31.033 --> 00:49:33.334
So you need to have
another way.

00:49:33.334 --> 00:49:35.300
And so this is a problem
we faced,

00:49:35.300 --> 00:49:38.667
because all of our--the API is
always loaded on your domains

00:49:38.667 --> 00:49:41.067
and refreshing images
from our domain,

00:49:41.067 --> 00:49:44.634
and so we can't use
that sort of hit detection.

00:49:44.634 --> 00:49:47.634
We have to actually keep track
of where everything is

00:49:47.634 --> 00:49:49.701
that we've drawn,
if that makes sense.

00:49:49.701 --> 00:49:51.968
man: Any suggestions about
improving performance

00:49:51.968 --> 00:49:56.701
of multiple polygons in a map
with a large number of polygons?

00:49:56.701 --> 00:49:59.033
Raub: So we certainly have
spent a lot of time

00:49:59.033 --> 00:50:01.901
making a lot of
small polygons fast

00:50:01.901 --> 00:50:04.667
and few big polygons fast.

00:50:04.667 --> 00:50:06.968
I think there were
some recent improvements

00:50:06.968 --> 00:50:10.300
in the last month
for polygons.

00:50:10.300 --> 00:50:13.767
So if you have a site--I would
say the best thing to do,

00:50:13.767 --> 00:50:14.868
if you have a site
where you think your polygons

00:50:14.868 --> 00:50:17.467
are just too slow,
send it to us.

00:50:17.467 --> 00:50:19.968
Day: And try the most current
version first,

00:50:19.968 --> 00:50:21.968
because we have made a lot
of improvements recently.

00:50:21.968 --> 00:50:23.400
Raub: Yeah,
but that's something--

00:50:23.400 --> 00:50:25.968
one of the guys on our team
is really into getting polygons

00:50:25.968 --> 00:50:27.467
to be fast.

00:50:27.467 --> 00:50:29.334
So if you send him a demo that
shows that they're not fast,

00:50:29.334 --> 00:50:31.868
chances are he'll spend
next weekend improving it.

00:50:31.868 --> 00:50:33.801
man: And how do we send it
to you?

00:50:33.801 --> 00:50:35.834
Raub: The best thing to do is
actually probably send it--

00:50:35.834 --> 00:50:37.067
post it on the group.
man: Okay.

00:50:37.067 --> 00:50:38.567
Raub: Because other people
might be interested

00:50:38.567 --> 00:50:40.467
in seeing that as well.
man: Thank you.

00:50:40.467 --> 00:50:43.400
Raub: So do we need to tell you
where our group is?

00:50:43.400 --> 00:50:46.000
Search for Google Groups
Maps API V3--

00:50:46.000 --> 00:50:47.000
Day: If you go
to the documentation,

00:50:47.000 --> 00:50:49.968
it'll show a link
for there.

00:50:49.968 --> 00:50:53.033
man: Hi, you showed clustering
a few slides ago.

00:50:53.033 --> 00:50:54.067
Day:
Yep.

00:50:54.067 --> 00:50:55.801
man:
Is there any clustering done

00:50:55.801 --> 00:50:58.901
or can be done natively
on mobiles?

00:50:58.901 --> 00:51:02.367
Day: That clustering
was all done in JavaScript.

00:51:02.367 --> 00:51:03.634
man: Yeah, that was Fluster,
wasn't it?

00:51:03.634 --> 00:51:07.434
Day: No, it was the open
source V3 marker clusterer.

00:51:07.434 --> 00:51:08.634
man: Okay.

00:51:08.634 --> 00:51:11.367
Day: Which is linked to
from our documentation

00:51:11.367 --> 00:51:14.200
and the groups,
and it's all done--

00:51:14.200 --> 00:51:17.901
instead of giving
the marker to the map

00:51:17.901 --> 00:51:19.467
or the map to the marker
like you usually would,

00:51:19.467 --> 00:51:21.701
you instead
create the marker

00:51:21.701 --> 00:51:23.000
and give it to the clusterer,

00:51:23.000 --> 00:51:25.701
and then it worries
about putting them together

00:51:25.701 --> 00:51:29.567
and forming those clusters
all natively on the client.

00:51:29.567 --> 00:51:31.234
man: And does that handle
custom markers, as well?

00:51:31.234 --> 00:51:32.234
Day:
Yeah, custom.

00:51:32.234 --> 00:51:33.367
Raub: That was
a custom marker.

00:51:33.367 --> 00:51:34.634
Day: That had
custom markers.

00:51:34.634 --> 00:51:36.434
Raub: That little blue guy
was a custom marker,

00:51:36.434 --> 00:51:39.334
so you just pass--you create
markers the same way you would

00:51:39.334 --> 00:51:41.968
any time, so you pass it
a full marker options object,

00:51:41.968 --> 00:51:45.334
and then the one thing you
don't do is set the map on it,

00:51:45.334 --> 00:51:47.334
and you give it
to the marker cluster,

00:51:47.334 --> 00:51:49.934
and it will render them.

00:51:49.934 --> 00:51:53.033
man: For an Android
or an iPhone app,

00:51:53.033 --> 00:51:54.801
is it recommended
to use a web view

00:51:54.801 --> 00:51:58.467
and then render the map inside
the web view with a V3 API,

00:51:58.467 --> 00:52:01.067
or is it better
to use a native?

00:52:01.067 --> 00:52:03.033
Raub: So I'd say we're
partial to the browser,

00:52:03.033 --> 00:52:05.501
since that's what
we work on.

00:52:05.501 --> 00:52:09.167
But I'd say that the real
benefits of using the browser

00:52:09.167 --> 00:52:10.868
are that it's cross platform,
you write it once

00:52:10.868 --> 00:52:12.133
for iPhone and Android,

00:52:12.133 --> 00:52:15.901
and we actually also work
on BlackBerry and Bota,

00:52:15.901 --> 00:52:19.601
so you get four mobile OS's
for one.

00:52:19.601 --> 00:52:23.400
And then we have much
more active development

00:52:23.400 --> 00:52:26.000
with a lot more features,
so you get a lot more.

00:52:26.000 --> 00:52:28.534
man: Performance-wise,
they're getting very close,

00:52:28.534 --> 00:52:30.400
native versus web view?

00:52:30.400 --> 00:52:35.434
Raub:
We're still slower.

00:52:35.434 --> 00:52:38.834
Day: For what it's worth--
correct me if I'm wrong--

00:52:38.834 --> 00:52:41.267
but the map that you've got
in the I/O application

00:52:41.267 --> 00:52:42.734
on your Android
uses web view.

00:52:42.734 --> 00:52:44.167
man:
Okay.

00:52:44.167 --> 00:52:45.367
Day: Just to give you a feel
of what the performance is like.

00:52:45.367 --> 00:52:48.868
man: We have an app
in the market.

00:52:48.868 --> 00:52:52.100
The second part of the question
was using street view DOMs

00:52:52.100 --> 00:52:55.200
in our app, we tried to simulate
walking down the streets,

00:52:55.200 --> 00:52:57.400
and we pick great routes
around the world,

00:52:57.400 --> 00:52:59.834
and let people sample them.

00:52:59.834 --> 00:53:02.968
So to simulate that, we load
panoramas, one after the other,

00:53:02.968 --> 00:53:06.534
and using V3, we don't really
get that smooth nest

00:53:06.534 --> 00:53:10.467
that we see in a Flash-based
or any other browser-based.

00:53:10.467 --> 00:53:12.901
So are there any techniques
or trickery there

00:53:12.901 --> 00:53:15.534
to try to make it like
a seamless walk down the street,

00:53:15.534 --> 00:53:17.067
using street view?

00:53:17.067 --> 00:53:19.000
Raub: It's certainly something
we would like to provide for you

00:53:19.000 --> 00:53:20.334
in the future.

00:53:20.334 --> 00:53:23.200
We would like our implementation
to be just like Flash.

00:53:23.200 --> 00:53:27.701
It may or may not get there.

00:53:27.701 --> 00:53:28.934
No promises as to when.

00:53:28.934 --> 00:53:31.033
I don't know.

00:53:31.033 --> 00:53:33.534
Day: I think there is
active interest in it,

00:53:33.534 --> 00:53:35.200
in the Maps team,
generally.

00:53:35.200 --> 00:53:37.501
So I think you will see
a lot of improvements coming.

00:53:37.501 --> 00:53:38.801
man:
Okay, thank you.

00:53:38.801 --> 00:53:40.133
Raub: Yeah, I can't think
of some great techniques

00:53:40.133 --> 00:53:43.033
for you to do it
on your own locally.

00:53:43.033 --> 00:53:46.067
man:
Okay, thanks.

00:53:46.067 --> 00:53:50.868
man: Extending on the previous
question about the overlay

00:53:50.868 --> 00:53:55.133
of the click handler,
there's a nice example.

00:53:55.133 --> 00:53:58.634
You have a mouse pointer
which changes

00:53:58.634 --> 00:54:01.834
when you move over a point.

00:54:01.834 --> 00:54:03.868
If you have a canvas,
how do you do it

00:54:03.868 --> 00:54:07.167
if you have, for example,
10,000 points?

00:54:07.167 --> 00:54:09.968
Day: Again, we have to do it
all in JavaScript,

00:54:09.968 --> 00:54:12.801
wherever we can, so we know
where the points are,

00:54:12.801 --> 00:54:15.767
and we basically go
from this X coordinate.

00:54:15.767 --> 00:54:17.767
Does that correlate
to one of the markers,

00:54:17.767 --> 00:54:19.267
and should we change cursor?

00:54:19.267 --> 00:54:21.534
man:
So with the tile,

00:54:21.534 --> 00:54:24.334
you also send the data
to the client?

00:54:24.334 --> 00:54:25.400
Day: Oh, yes,
for these ones, yeah.

00:54:25.400 --> 00:54:26.801
We send a little bit of data,

00:54:26.801 --> 00:54:30.100
just enough to let the browser
know what is clickable.

00:54:30.100 --> 00:54:31.100
man:
Okay.

00:54:31.100 --> 00:54:32.267
Day: But not the entire
information

00:54:32.267 --> 00:54:34.267
about what each airport is,
for example.

00:54:34.267 --> 00:54:38.701
man: Okay.
Day: Yeah.

00:54:38.701 --> 00:54:41.467
man: Going along with
two questions ago,

00:54:41.467 --> 00:54:45.234
regarding the web view with map
inside versus native app.

00:54:45.234 --> 00:54:46.701
Day:
Yeah.

00:54:46.701 --> 00:54:48.234
man: One thing that I really
feel to be a limitation today

00:54:48.234 --> 00:54:50.100
is that the web view
doesn't pinch to zoom,

00:54:50.100 --> 00:54:53.634
and people feel like they're
entitled to this functionality,

00:54:53.634 --> 00:54:55.234
and it's not available
in web view.

00:54:55.234 --> 00:54:57.133
Is this going to
come sometime?

00:54:57.133 --> 00:54:58.467
Raub: So it's available
on the iPhone,

00:54:58.467 --> 00:55:00.667
and it's available
in Android 3.0.

00:55:00.667 --> 00:55:01.667
man:
Oh.

00:55:01.667 --> 00:55:02.901
Raub: So if you try
your tablet,

00:55:02.901 --> 00:55:04.200
it should work.
man: Cool, okay.

00:55:04.200 --> 00:55:06.167
Raub: And that was a limitation
that was not exposed

00:55:06.167 --> 00:55:07.601
in the browser by Android.
man: Okay.

00:55:07.601 --> 00:55:08.901
Raub:
So it would have worked.

00:55:08.901 --> 00:55:12.734
Our code works for it,
but Android didn't--

00:55:12.734 --> 00:55:14.701
though it used pinch to zoom,

00:55:14.701 --> 00:55:16.467
it did not expose
multitouch events.

00:55:16.467 --> 00:55:18.634
Every touch event still only
had one touch in it.

00:55:18.634 --> 00:55:19.734
man:
Great.

00:55:19.734 --> 00:55:21.701
Raub:
But Android 3.0 fixes that.

00:55:21.701 --> 00:55:23.567
And let us know if you have
problems with that,

00:55:23.567 --> 00:55:24.934
because we don't
have the tablet,

00:55:24.934 --> 00:55:26.701
so we haven't played with it
as much as you will.

00:55:26.701 --> 00:55:28.434
[laughter]

00:55:28.434 --> 00:55:30.000
Day: Hi.
man: Hi.

00:55:30.000 --> 00:55:33.400
For your canvas example
and your Fusion Table example,

00:55:33.400 --> 00:55:37.667
following the click event,
you create an info window,

00:55:37.667 --> 00:55:39.734
which the information
is populated by--

00:55:39.734 --> 00:55:42.167
it goes back to
the Google server.

00:55:42.167 --> 00:55:43.601
That includes
the extra round-trip time.

00:55:43.601 --> 00:55:45.267
I assume that's quick.
Day: Correct.

00:55:45.267 --> 00:55:46.934
man: But I was just wondering
what's your thoughts on that?

00:55:46.934 --> 00:55:49.968
Day: Yeah, it's sort of
weighing up the benefit

00:55:49.968 --> 00:55:53.400
of how much does it cost
to get the page actually loaded

00:55:53.400 --> 00:55:56.667
and functional versus
how much will the user wait?

00:55:56.667 --> 00:55:58.501
A lot of the time
you can do tricky things,

00:55:58.501 --> 00:56:00.701
like if you notice
the user hovering on it,

00:56:00.701 --> 00:56:03.734
then start, because even if
they don't end up clicking,

00:56:03.734 --> 00:56:07.167
you really haven't
wasted much.

00:56:07.167 --> 00:56:10.667
And, yeah, I think, also,
when you do know you have to

00:56:10.667 --> 00:56:12.801
go back to the server
and fetch something,

00:56:12.801 --> 00:56:14.968
just let the user know
that something's happening,

00:56:14.968 --> 00:56:17.767
because they'll get frustrated
and click it 17 times before--

00:56:17.767 --> 00:56:20.067
you know--so it's sort of
a combination

00:56:20.067 --> 00:56:21.968
of those two things,
trying to pre-guess

00:56:21.968 --> 00:56:23.801
and also letting them know
what's happening.

00:56:23.801 --> 00:56:25.234
Raub:
But that data is so simple,

00:56:25.234 --> 00:56:28.000
that it's so small
that it's okay.

00:56:28.000 --> 00:56:29.901
But if you knew
your user was--

00:56:29.901 --> 00:56:32.467
or you knew you were going
to show these info windows,

00:56:32.467 --> 00:56:35.834
then maybe don't load them
when you first load your page.

00:56:35.834 --> 00:56:37.667
Do it in some timeout,

00:56:37.667 --> 00:56:39.601
when you're done
rendering everything else,

00:56:39.601 --> 00:56:41.968
and then fetch as many
as you can together.

00:56:41.968 --> 00:56:42.968
man:
Okay.

00:56:42.968 --> 00:56:44.234
Raub:
Would be my tip for that.

00:56:44.234 --> 00:56:45.334
Day:
Last question?

00:56:45.334 --> 00:56:47.267
man: For the Fusion Table
example, again,

00:56:47.267 --> 00:56:49.901
with the click event,
if you had multiple markers

00:56:49.901 --> 00:56:51.701
stacked on top of each other,

00:56:51.701 --> 00:56:53.534
could you receive
all the information

00:56:53.534 --> 00:56:56.167
from all the markers
with the click event?

00:56:56.167 --> 00:56:58.033
Day: I think the implementation
at the moment

00:56:58.033 --> 00:57:01.601
just supports
getting one event.

00:57:01.601 --> 00:57:03.434
Raub: I mean, theoretically,
not with Fusion Tables,

00:57:03.434 --> 00:57:05.000
but if you were to
implement this, you could.

00:57:05.000 --> 00:57:06.801
You could pick
to have that feature,

00:57:06.801 --> 00:57:09.100
but that's not how
we've done it.

00:57:09.100 --> 00:57:10.234
man: Thank you.
Day: Okay.

00:57:10.234 --> 00:57:11.234
Thanks, everyone.

00:57:11.234 --> 00:57:12.334
And if you have
any more questions,

00:57:12.334 --> 00:57:13.501
we'll be outside
afterwards.

00:57:13.501 --> 00:57:15.734
Raub: And Fireside Chat
in an hour here.

00:57:15.734 --> 00:57:17.934
[applause]

