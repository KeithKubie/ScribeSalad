WEBVTT
Kind: captions
Language: en

00:00:09.880 --> 00:00:11.540
ALEX DANILO: Hello everybody.

00:00:11.540 --> 00:00:13.940
It's great to be here in
the smartphone capital

00:00:13.940 --> 00:00:14.810
of the world.

00:00:14.810 --> 00:00:15.980
[LAUGHTER]

00:00:15.980 --> 00:00:17.980
ALEX DANILO: Of course
it's a very exciting time

00:00:17.980 --> 00:00:20.021
for us with Chrome to come
and visit you and talk

00:00:20.021 --> 00:00:23.770
about HTML and web
technologies today.

00:00:23.770 --> 00:00:25.580
My name is Alex Danilo.

00:00:25.580 --> 00:00:29.140
My colleague Eiji couldn't
come here today, unfortunately.

00:00:29.140 --> 00:00:34.440
You can follow me on Google+ or
Twitter or anywhere on the web.

00:00:34.440 --> 00:00:38.540
Today I would like to talk
about the future of mobile HTML

00:00:38.540 --> 00:00:41.650
and web technologies.

00:00:41.650 --> 00:00:45.140
We're going to have a whole
lot of different slides.

00:00:45.140 --> 00:00:47.440
Each slide will cover
a different aspect

00:00:47.440 --> 00:00:51.030
of mobile APIs, and
there's a little guide here

00:00:51.030 --> 00:00:52.500
with a color-coding.

00:00:52.500 --> 00:00:56.610
This color-coding tells you
if the feature is ready,

00:00:56.610 --> 00:00:59.020
or if the feature
is coming soon,

00:00:59.020 --> 00:01:01.910
or if it's in the
long distance horizon.

00:01:01.910 --> 00:01:05.360
And we also have per-browser
color-coding, as well.

00:01:05.360 --> 00:01:08.370
Before I start with that, I'd
like to show you a website

00:01:08.370 --> 00:01:11.750
that you should all go to.

00:01:11.750 --> 00:01:13.880
This website is
chromestatus.com.

00:01:16.630 --> 00:01:20.585
Chromestatus.com covers
all of the new APIs that

00:01:20.585 --> 00:01:23.270
are on web browsers
and web technologies.

00:01:23.270 --> 00:01:27.070
So it's not just Chrome, but it
covers Chrome, Safari, Internet

00:01:27.070 --> 00:01:29.844
Explorer, Opera, et cetera.

00:01:29.844 --> 00:01:31.510
Now what you can see
here is a whole lot

00:01:31.510 --> 00:01:34.144
of different features,
and you can actually

00:01:34.144 --> 00:01:36.310
click on each of them and
have a look at the status,

00:01:36.310 --> 00:01:38.170
and there's color-coding.

00:01:38.170 --> 00:01:41.340
If you would like to understand
the guide to the color-coding

00:01:41.340 --> 00:01:45.500
and the browsers, just click
this little question mark.

00:01:45.500 --> 00:01:48.310
It brings you up a whole guide
of what the color-codings mean,

00:01:48.310 --> 00:01:51.660
the various browser
maturity levels, which

00:01:51.660 --> 00:01:53.300
browser support,
which API, et cetera,

00:01:53.300 --> 00:01:55.220
and this makes your
development life easier.

00:01:59.140 --> 00:02:01.422
What's interesting is
this entire dashboard here

00:02:01.422 --> 00:02:03.880
that you're seeing for Chrome
status is built with Polymer.

00:02:03.880 --> 00:02:07.240
Polymer is a fantastic
new UI toolkit

00:02:07.240 --> 00:02:10.509
being built for the web, and
the talk right after mine

00:02:10.509 --> 00:02:11.790
will talk all about Polymer.

00:02:11.790 --> 00:02:15.330
So keep that in mind when you
play with this and explore it.

00:02:19.480 --> 00:02:22.270
Today we're going to be covering
mature features and immature

00:02:22.270 --> 00:02:23.470
features.

00:02:23.470 --> 00:02:26.330
So I'd just like to
show you that if you

00:02:26.330 --> 00:02:28.800
have a phone-- a real
phone, like this phone

00:02:28.800 --> 00:02:33.127
here-- if you go to Chrome
and you type in-- well

00:02:33.127 --> 00:02:39.870
I can't quite read
that-- "chrome flags."

00:02:39.870 --> 00:02:43.930
In there you can see lots of
different experimental features

00:02:43.930 --> 00:02:46.530
you can enable in
Chrome for Android.

00:02:46.530 --> 00:02:49.880
So if you choose to use those
experimental features that

00:02:49.880 --> 00:02:53.710
aren't quite mature
yet, then all

00:02:53.710 --> 00:02:55.520
you do is turn on
Chrome flags, turn

00:02:55.520 --> 00:02:59.180
on the experimental feature,
try it out, build sites,

00:02:59.180 --> 00:03:00.350
prepare for the future.

00:03:04.240 --> 00:03:07.760
The difference between a
desktop web application

00:03:07.760 --> 00:03:10.860
and a mobile web application
is the size of the screen.

00:03:10.860 --> 00:03:13.280
That's the main
difference in criteria.

00:03:13.280 --> 00:03:16.560
This makes
development difficult.

00:03:16.560 --> 00:03:21.008
Who has difficulty developing
for mobile devices?

00:03:21.008 --> 00:03:22.270
A few people over here.

00:03:22.270 --> 00:03:25.010
I'm sure everybody does.

00:03:25.010 --> 00:03:26.800
I'd just like to cover
a few things that

00:03:26.800 --> 00:03:29.020
are very important when
developing mobile web

00:03:29.020 --> 00:03:30.780
applications.

00:03:30.780 --> 00:03:33.900
One is this viewport meta tag.

00:03:33.900 --> 00:03:37.210
Now when you're
developing a desktop site,

00:03:37.210 --> 00:03:41.850
normally you specify a
very wide content width.

00:03:41.850 --> 00:03:47.550
You may specify 1,000 pixels
is the width of your content.

00:03:47.550 --> 00:03:51.800
The browser on the phone doesn't
look any different to the web

00:03:51.800 --> 00:03:53.470
server.

00:03:53.470 --> 00:03:56.490
So when you serve the
content, it shrinks,

00:03:56.490 --> 00:03:58.260
and the text is
completely unreadable.

00:04:02.120 --> 00:04:06.585
If you use the meta tag
using the viewport attribute,

00:04:06.585 --> 00:04:09.380
the viewport meta
tag, you can actually

00:04:09.380 --> 00:04:13.670
define the size of the contents,
so that the mobile browser can

00:04:13.670 --> 00:04:16.110
make intelligent
decisions on how

00:04:16.110 --> 00:04:21.800
to scale the content so your
users can actually read it.

00:04:21.800 --> 00:04:24.050
I won't go into too much
detail about how to use this,

00:04:24.050 --> 00:04:26.000
but this is very mature.

00:04:26.000 --> 00:04:30.020
It's in all mobile browsers,
and there's a nice demonstration

00:04:30.020 --> 00:04:33.030
here at this URL at the
bottom that you can look at.

00:04:35.800 --> 00:04:40.150
OK, device adaptation--
this is coming very soon.

00:04:40.150 --> 00:04:46.310
What this does is leverage a CSS
to do the viewport adaptation.

00:04:46.310 --> 00:04:50.060
So the meta tag is
old-style, the new style

00:04:50.060 --> 00:04:52.910
will be controlled by CSS.

00:04:52.910 --> 00:04:55.640
This is much more versatile.

00:04:55.640 --> 00:04:58.290
And this is already in
Chrome and Internet Explorer

00:04:58.290 --> 00:05:00.650
mobile, so keep an eye
on this for the future.

00:05:04.270 --> 00:05:06.360
Today we already
have media queries.

00:05:06.360 --> 00:05:09.480
Has anybody in the room
used media queries?

00:05:09.480 --> 00:05:10.980
Put your hand up.

00:05:10.980 --> 00:05:14.950
Yes, people have used
media queries, excellent.

00:05:14.950 --> 00:05:16.970
Media queries are
a really great way

00:05:16.970 --> 00:05:19.910
to change the content
on your mobile site

00:05:19.910 --> 00:05:23.480
depending on the device
that is reading it.

00:05:23.480 --> 00:05:26.820
So it's very easy to
develop a desktop site that

00:05:26.820 --> 00:05:30.410
will look great on mobile
by leveraging media queries.

00:05:34.220 --> 00:05:36.780
Now, this is another
very nice media query.

00:05:36.780 --> 00:05:40.670
You can actually detect the
orientation of the device.

00:05:40.670 --> 00:05:43.940
As you can see here, when
we change the orientation

00:05:43.940 --> 00:05:48.960
of our phone, the content
actually rotates and changes

00:05:48.960 --> 00:05:53.020
in response to the orientation
we have of the phone.

00:05:53.020 --> 00:05:58.520
So when I grab my device,
if I grab it, and I flip it,

00:05:58.520 --> 00:06:00.935
you actually get a
different visual appearance.

00:06:04.170 --> 00:06:06.120
It's also in every
mobile browser,

00:06:06.120 --> 00:06:08.060
so you should be using
it if you need it.

00:06:11.570 --> 00:06:13.400
Another very
interesting new feature

00:06:13.400 --> 00:06:19.150
that is here in all browsers
on mobile are viewpoint units.

00:06:19.150 --> 00:06:21.520
People who are used
to positioning content

00:06:21.520 --> 00:06:25.280
on their screen using
percentages-- that's

00:06:25.280 --> 00:06:28.010
percentage of the
containing block

00:06:28.010 --> 00:06:30.340
or percentage of
the whole page--

00:06:30.340 --> 00:06:32.430
if you use viewpoint
units, these

00:06:32.430 --> 00:06:35.840
are percentages of your
actual screen real estate.

00:06:35.840 --> 00:06:41.240
So here, 30vh is 30% of
the height of the viewport.

00:06:41.240 --> 00:06:44.880
So you can choose the
height of the viewport,

00:06:44.880 --> 00:06:47.940
the width of the viewport,
the minimum dimension

00:06:47.940 --> 00:06:51.247
of the viewport or the maximum
dimension of the viewport.

00:06:54.520 --> 00:06:59.560
Another fantastic new
module in CSS3 is Flexbox.

00:06:59.560 --> 00:07:02.460
CSS3 Flexbox,
flexible box module

00:07:02.460 --> 00:07:07.880
lets you separate your
content from your layout.

00:07:07.880 --> 00:07:12.150
The beauty of this is
that your HTML content can

00:07:12.150 --> 00:07:16.470
be logical in order so
your story is semantically

00:07:16.470 --> 00:07:20.070
unchanged, but when you put
it on different devices,

00:07:20.070 --> 00:07:22.930
you can change the
layout completely.

00:07:22.930 --> 00:07:26.690
You can swap order,
swap location,

00:07:26.690 --> 00:07:30.080
independent of the
original HTML content.

00:07:30.080 --> 00:07:32.610
So this is a very, very
good way to change,

00:07:32.610 --> 00:07:36.020
if you have a desktop
site, for example.

00:07:36.020 --> 00:07:38.710
With navigation at
the top, content

00:07:38.710 --> 00:07:42.580
in the middle, extra
content at the bottom,

00:07:42.580 --> 00:07:45.650
when you shrink to
a smaller device,

00:07:45.650 --> 00:07:48.880
you can move the navigation
or move the stuff

00:07:48.880 --> 00:07:52.880
at the top down to the bottom
and have the center content

00:07:52.880 --> 00:07:55.175
as the first thing that
your mobile user reads.

00:08:01.150 --> 00:08:03.680
All right, now here is a
very interesting new feature

00:08:03.680 --> 00:08:05.350
which is coming now.

00:08:05.350 --> 00:08:08.430
It's already in
Chrome and Opera.

00:08:08.430 --> 00:08:10.570
This is position: sticky.

00:08:10.570 --> 00:08:14.900
Now when you do a CSS layout
with fixed positioning,

00:08:14.900 --> 00:08:18.245
you can anchor something to
the screen in a set location.

00:08:20.930 --> 00:08:23.780
This lets the user scroll
the content around and have

00:08:23.780 --> 00:08:27.740
something that is static,
but that's very limited.

00:08:27.740 --> 00:08:30.440
With the sticky positioning,
you can actually

00:08:30.440 --> 00:08:36.240
associate one piece of content
to another block of content.

00:08:36.240 --> 00:08:38.905
And as you see here,
the capital letters

00:08:38.905 --> 00:08:42.809
are anchored to the
content within them.

00:08:42.809 --> 00:08:47.080
So as we scroll, you can see
that the sticky content sticks

00:08:47.080 --> 00:08:49.595
to the top of the screen
and then scrolls off.

00:08:54.410 --> 00:08:57.820
This lets you build UIs that
are very similar to native UIs,

00:08:57.820 --> 00:08:59.250
just using web technologies.

00:08:59.250 --> 00:09:01.460
So this is a very
nice feature that's

00:09:01.460 --> 00:09:02.645
coming to mobile browsers.

00:09:07.460 --> 00:09:09.610
All right, this is a
great looking man here,

00:09:09.610 --> 00:09:12.950
who is featured in all of my
slides, who is showing you here

00:09:12.950 --> 00:09:14.150
the full screen API.

00:09:16.780 --> 00:09:21.430
If you're trying to build
immersive HTML5 games,

00:09:21.430 --> 00:09:23.610
you need to be able to
take over the entire screen

00:09:23.610 --> 00:09:26.750
real estate on the browser.

00:09:26.750 --> 00:09:31.330
This used to be done using
window.scroll 2.01, which

00:09:31.330 --> 00:09:33.850
was a bit of a hack.

00:09:33.850 --> 00:09:36.360
That is no longer the
correct way to do this.

00:09:36.360 --> 00:09:39.170
There is now a
proper JavaScript API

00:09:39.170 --> 00:09:42.920
which lets you do full screen.

00:09:42.920 --> 00:09:44.980
Now when full screen is
enabled, the only way

00:09:44.980 --> 00:09:48.130
to enable full screen
is by user interaction,

00:09:48.130 --> 00:09:52.912
so your user has to
tap or click or perform

00:09:52.912 --> 00:09:55.370
some kind of interaction to
actually create the full screen

00:09:55.370 --> 00:09:56.620
experience.

00:09:56.620 --> 00:10:00.200
So JavaScript can't suddenly
pop up and take over the screen

00:10:00.200 --> 00:10:03.390
and look like
another application.

00:10:03.390 --> 00:10:04.710
I'll demonstrate that shortly.

00:10:07.860 --> 00:10:10.320
So everybody's walking
around with phones.

00:10:10.320 --> 00:10:11.590
Who has a smartphone?

00:10:11.590 --> 00:10:13.620
[LAUGHTER]

00:10:13.620 --> 00:10:15.580
ALEX DANILO: Oh, come
on, this is Korea,

00:10:15.580 --> 00:10:17.516
everybody has a smartphone.

00:10:17.516 --> 00:10:19.937
All right, you're walking
around, so what can you do?

00:10:19.937 --> 00:10:22.270
How do you build a better
experience for your developers

00:10:22.270 --> 00:10:24.145
when you're walking
around with a smartphone?

00:10:24.145 --> 00:10:27.520
What you need is to take
advantage of the fact

00:10:27.520 --> 00:10:31.460
that the phone is
in your pocket.

00:10:31.460 --> 00:10:34.850
So the way you do that is
provide services and web

00:10:34.850 --> 00:10:40.890
applications that take advantage
of what the browser knows.

00:10:40.890 --> 00:10:42.920
Now the browser
knows where you are,

00:10:42.920 --> 00:10:45.520
and that's really,
really useful.

00:10:45.520 --> 00:10:47.800
For example, if you've
got a mapping application,

00:10:47.800 --> 00:10:50.837
you can actually use the
browser to say I am here

00:10:50.837 --> 00:10:52.920
and get the correct map
for where you're standing.

00:10:55.700 --> 00:10:58.880
Or if your application is
searching for restaurants,

00:10:58.880 --> 00:11:01.540
you can use the geolocation
to search restaurants

00:11:01.540 --> 00:11:02.690
within the local area.

00:11:05.610 --> 00:11:10.940
Now this is a very, very easy
API to use, as you can see.

00:11:10.940 --> 00:11:13.300
You can just get the
latitude and the longitude.

00:11:13.300 --> 00:11:15.560
In fact, you can set a listener.

00:11:15.560 --> 00:11:17.870
This bottom little
piece of code here

00:11:17.870 --> 00:11:21.600
lets you have a
JavaScript listener that

00:11:21.600 --> 00:11:24.880
listens to changes in position,
so you can dynamically

00:11:24.880 --> 00:11:27.670
update your location.

00:11:27.670 --> 00:11:31.640
So it's easy to build something
like a tracking application

00:11:31.640 --> 00:11:33.100
for when you're
riding a bicycle.

00:11:33.100 --> 00:11:35.610
It shows you where you
are, and as you ride,

00:11:35.610 --> 00:11:38.590
you move on the map.

00:11:38.590 --> 00:11:41.200
And this is in every
mobile browser today,

00:11:41.200 --> 00:11:42.240
so you should use this.

00:11:46.192 --> 00:11:48.150
Now here's another one
that's very interesting.

00:11:48.150 --> 00:11:55.200
Because these devices have
accelerometers and gyroscopes,

00:11:55.200 --> 00:11:58.120
when you move them
around, the browser

00:11:58.120 --> 00:12:00.560
can actually detect
that motion, and you

00:12:00.560 --> 00:12:05.080
can use device orientation to
build all sorts of experiences.

00:12:05.080 --> 00:12:06.705
So I'll just show
you a little example.

00:12:13.920 --> 00:12:15.800
So here is my Chrome browser.

00:12:19.040 --> 00:12:21.480
Now as I said before, we
have the full screen API,

00:12:21.480 --> 00:12:24.170
which takes care
of the full screen.

00:12:24.170 --> 00:12:25.340
We have device orientation.

00:12:25.340 --> 00:12:33.230
So if I tap the Start button,
it goes into full screen,

00:12:33.230 --> 00:12:35.252
and we have this
full-screen experience.

00:12:35.252 --> 00:12:37.210
And if you'll see, there's
a little Chrome ball

00:12:37.210 --> 00:12:43.950
that rolls around, and so this
is using device orientation

00:12:43.950 --> 00:12:46.450
to basically play
a little ball game.

00:12:46.450 --> 00:12:51.160
So we can roll around,
little Chrome rolls around.

00:12:51.160 --> 00:12:56.140
We actually have a full-screen
HTML5 game here using

00:12:56.140 --> 00:12:59.787
device orientation to
run the ball around

00:12:59.787 --> 00:13:01.120
and hopefully score more points.

00:13:05.520 --> 00:13:07.890
These are real APIs you
can use for HTML5 gaming.

00:13:07.890 --> 00:13:10.610
We have a session
later on in the day

00:13:10.610 --> 00:13:13.730
which does a deep dive
into HTML5 gaming.

00:13:13.730 --> 00:13:18.055
And the fact that we have
these device accesses,

00:13:18.055 --> 00:13:19.930
and we have the full-screen,
you can actually

00:13:19.930 --> 00:13:23.881
build powerful HTML5 games
in modern browsers on devices

00:13:23.881 --> 00:13:24.380
today.

00:13:26.900 --> 00:13:28.570
Another interesting
thing that you

00:13:28.570 --> 00:13:31.930
can have that is now in
browsers is the ability

00:13:31.930 --> 00:13:35.866
to detect if you're
connected to the network.

00:13:35.866 --> 00:13:38.720
There are JavaScript
events which tell you

00:13:38.720 --> 00:13:40.810
if you are connected
to the network

00:13:40.810 --> 00:13:43.360
or if you're
disconnected, so you

00:13:43.360 --> 00:13:45.710
can make intelligent
choices about what

00:13:45.710 --> 00:13:49.570
to do when the user is offline.

00:13:49.570 --> 00:13:54.370
So if you put your browser or
your phone into airplane mode,

00:13:54.370 --> 00:13:56.790
you know immediately that
you can't get the network

00:13:56.790 --> 00:13:59.280
so that you can make
smart choices about what

00:13:59.280 --> 00:14:01.920
you present to the user.

00:14:01.920 --> 00:14:06.289
So when you reconnect to the
network you will get an event.

00:14:06.289 --> 00:14:08.830
When that event hits, you could
do something like synchronize

00:14:08.830 --> 00:14:10.910
to your server or
things like that,

00:14:10.910 --> 00:14:13.120
so these are important
ones to know about.

00:14:13.120 --> 00:14:15.450
It is also important
to understand

00:14:15.450 --> 00:14:19.182
the online-offline status is
just connection to the network.

00:14:19.182 --> 00:14:21.140
It doesn't mean you can
get to your web server.

00:14:26.180 --> 00:14:29.940
Now storage APIs are a very
interesting picture today

00:14:29.940 --> 00:14:31.940
on mobile browsers.

00:14:31.940 --> 00:14:34.410
There's a lot of variation
between the browsers.

00:14:34.410 --> 00:14:36.760
We have local
storage everywhere,

00:14:36.760 --> 00:14:40.020
but local storage is restricted
to very simple storage,

00:14:40.020 --> 00:14:41.850
small amounts of data.

00:14:41.850 --> 00:14:43.900
There is no query
or lookup, so it's

00:14:43.900 --> 00:14:48.460
pretty stupid, or pretty
simple, I should say.

00:14:48.460 --> 00:14:50.460
We have these two
other storage mediums.

00:14:50.460 --> 00:14:52.960
We have WebSQL and IndexedDB.

00:14:55.710 --> 00:15:00.530
Now WebSQL was an old standard
that is now deprecated.

00:15:00.530 --> 00:15:03.810
So we encourage people
to give up on WebSQL

00:15:03.810 --> 00:15:05.240
because it's going away.

00:15:05.240 --> 00:15:07.970
It's no longer
being standardized,

00:15:07.970 --> 00:15:11.710
but it is in a lot of
mobile browsers today.

00:15:11.710 --> 00:15:14.890
IndexedDB is also in a number
of mobile browsers today.

00:15:14.890 --> 00:15:17.100
It is much more recent.

00:15:17.100 --> 00:15:21.006
It's also the standard that is
going to be used going forward,

00:15:21.006 --> 00:15:22.880
so we would recommend,
as a mobile developer,

00:15:22.880 --> 00:15:26.480
you look at IndexedDB,
learn the APIs.

00:15:26.480 --> 00:15:28.940
And of course, you can see
the feature table here,

00:15:28.940 --> 00:15:33.320
how IndexedDB is not supported
on the Android browser

00:15:33.320 --> 00:15:37.810
or on Safari for mobile, so
the simple solution to that

00:15:37.810 --> 00:15:39.900
is to use abstraction library.

00:15:39.900 --> 00:15:43.210
So here are three
abstraction libraries.

00:15:43.210 --> 00:15:45.890
They hide all the detail
of the implementation

00:15:45.890 --> 00:15:47.100
from the developer.

00:15:47.100 --> 00:15:50.680
So you as a developer,
you can just

00:15:50.680 --> 00:15:54.750
write, using one of these
abstraction libraries.

00:15:54.750 --> 00:15:56.770
If the browser
supports IndexedDB,

00:15:56.770 --> 00:15:59.930
it will work straight
to IndexedDB.

00:15:59.930 --> 00:16:03.760
if the browser doesn't support
IndexedDB and supports WebSQL,

00:16:03.760 --> 00:16:06.720
it would perform the
translation for you,

00:16:06.720 --> 00:16:10.245
so this is the easy way to
solve mass storage on the phone.

00:16:12.959 --> 00:16:14.750
All right, now here's
an interesting aspect

00:16:14.750 --> 00:16:18.480
of phones-- who here
has written a book?

00:16:18.480 --> 00:16:19.649
[LAUGHTER]

00:16:19.649 --> 00:16:22.190
ALEX DANILO: Ah, we have a few
book authors, here, excellent.

00:16:22.190 --> 00:16:23.830
At the back, excellent.

00:16:23.830 --> 00:16:25.770
How many of you wrote
that book on your phone?

00:16:25.770 --> 00:16:29.397
[LAUGHTER]

00:16:29.397 --> 00:16:30.230
ALEX DANILO: Nobody.

00:16:30.230 --> 00:16:33.390
That's funny, I always
write books on my phone.

00:16:33.390 --> 00:16:34.970
Nobody writes books on phones.

00:16:34.970 --> 00:16:38.440
In fact, it's a horrible
experience typing on a phone.

00:16:38.440 --> 00:16:44.290
It's slow, it's painful, and
the users of your applications

00:16:44.290 --> 00:16:46.710
don't like typing just
as much as you do.

00:16:49.280 --> 00:16:52.950
So when you design your web
applications and your websites,

00:16:52.950 --> 00:16:54.890
you should use
semantic input types.

00:16:54.890 --> 00:16:58.120
So here you can see, there
are many different input types

00:16:58.120 --> 00:16:59.675
that you can apply
to your content.

00:17:02.460 --> 00:17:04.970
So just take the first one,
for example-- input type

00:17:04.970 --> 00:17:07.240
equals email.

00:17:07.240 --> 00:17:10.540
When you specify type
equals email on your phone,

00:17:10.540 --> 00:17:14.040
the keyboard that's presented
to the user has the @ sign.

00:17:14.040 --> 00:17:17.060
If you see down the bottom
left, there's the symbol for @,

00:17:17.060 --> 00:17:21.270
so it's a keyboard tailored
to typing in email addresses.

00:17:21.270 --> 00:17:24.980
Same thing for search, you get
a nice little magnifying glass

00:17:24.980 --> 00:17:27.550
to search.

00:17:27.550 --> 00:17:31.140
Telephone numbers, brings
up the phone keyboard

00:17:31.140 --> 00:17:33.920
for phone number
entry, et cetera.

00:17:33.920 --> 00:17:38.330
So these semantic
types do one thing.

00:17:38.330 --> 00:17:42.430
And the one thing is
they save your user time.

00:17:42.430 --> 00:17:44.880
Your user doesn't have
to fumble around finding

00:17:44.880 --> 00:17:47.070
the right keyboard,
switching modes,

00:17:47.070 --> 00:17:49.970
the browser does
the work for you.

00:17:49.970 --> 00:17:53.550
So if you have a look
at the date types--

00:17:53.550 --> 00:17:55.690
the date types bring your
little spinning things

00:17:55.690 --> 00:17:56.670
for days and months.

00:17:56.670 --> 00:18:00.400
What do we have here-- we have
a search one with the magnifying

00:18:00.400 --> 00:18:01.112
glass.

00:18:01.112 --> 00:18:05.580
It's a beautiful video,
this-- the phone one.

00:18:05.580 --> 00:18:08.220
Now if we have a look at the
number one which is next,

00:18:08.220 --> 00:18:11.930
the interesting thing about this
is with the number input type,

00:18:11.930 --> 00:18:14.160
you can specify a number range.

00:18:14.160 --> 00:18:18.910
I can say, range
from 100 to 200,

00:18:18.910 --> 00:18:21.520
and the browser will do the
checking that it's valid.

00:18:24.060 --> 00:18:26.800
All right now here's another
very interesting feature

00:18:26.800 --> 00:18:29.250
of phones today-- all
phones are touch phones,

00:18:29.250 --> 00:18:32.250
or all phones that matter.

00:18:32.250 --> 00:18:34.700
The thing about touch
phones is that touch phones

00:18:34.700 --> 00:18:37.190
are fairly new.

00:18:37.190 --> 00:18:41.500
Browsers were developed in the
days of mouses and keyboards,

00:18:41.500 --> 00:18:45.030
and so the events
that come in for touch

00:18:45.030 --> 00:18:48.630
are really tailored
for an era beforehand,

00:18:48.630 --> 00:18:52.260
a long time ago when
everyone used a mouse.

00:18:52.260 --> 00:18:55.720
Because of that there is
a 300 millisecond delay

00:18:55.720 --> 00:19:00.000
if you tap on a link in the
browser before the actual link

00:19:00.000 --> 00:19:01.380
gets activated.

00:19:01.380 --> 00:19:03.600
Now that's a huge
problem with development,

00:19:03.600 --> 00:19:05.890
and later on in the
day we will show you

00:19:05.890 --> 00:19:09.970
how to fix that-- in fact,
Jake will, wherever Jake is.

00:19:09.970 --> 00:19:12.010
So keep that in mind.

00:19:12.010 --> 00:19:14.340
But there are a number
of demos with this,

00:19:14.340 --> 00:19:17.090
and the thing that's interesting
with the touch events

00:19:17.090 --> 00:19:21.110
is that you can detect
movement and touch,

00:19:21.110 --> 00:19:26.470
and you get a lot of events, and
they're very, very inaccurate.

00:19:26.470 --> 00:19:28.660
So when you touch,
it's much less accurate

00:19:28.660 --> 00:19:30.360
than using a mouse.

00:19:30.360 --> 00:19:34.230
In fact, quite often the
touch start and touch end

00:19:34.230 --> 00:19:37.060
will be at different positions
even though you haven't moved

00:19:37.060 --> 00:19:38.860
your finger, so
keep that in mind.

00:19:41.520 --> 00:19:46.000
Now everybody realizes that
touch events and mouse events,

00:19:46.000 --> 00:19:52.040
being from different
backgrounds have problems.

00:19:52.040 --> 00:19:55.420
So Microsoft made
a proposal to W3C

00:19:55.420 --> 00:19:57.800
for a thing called
pointer events.

00:20:01.110 --> 00:20:06.950
Pointer events unify mouse
events and touch events.

00:20:06.950 --> 00:20:10.390
So what they do is they
provide a common framework

00:20:10.390 --> 00:20:12.660
for both mouse and
touch, and it's

00:20:12.660 --> 00:20:20.150
a very, very nicely distilled
kind of a combination of both.

00:20:20.150 --> 00:20:22.200
Of course, the problem
with pointer events

00:20:22.200 --> 00:20:24.565
is only one browser
supports them.

00:20:27.220 --> 00:20:30.090
People have been
building JavaScript shims

00:20:30.090 --> 00:20:33.540
to actually simulate
pointer events,

00:20:33.540 --> 00:20:36.410
and there is a lot of activity
to bring pointer events

00:20:36.410 --> 00:20:37.750
to other browsers.

00:20:37.750 --> 00:20:39.885
But it is one to keep
in mind for the future.

00:20:43.340 --> 00:20:45.890
All right, so we'll
get on to what

00:20:45.890 --> 00:20:50.430
is different about a
phone and a computer.

00:20:50.430 --> 00:20:52.340
So what's nice about the phone?

00:20:52.340 --> 00:20:55.790
Can anybody suggest anything?

00:20:55.790 --> 00:20:56.960
All right, I'll suggest it.

00:20:56.960 --> 00:20:58.752
How about we have a camera?

00:20:58.752 --> 00:21:00.960
We've got a camera in the
phone so I can take photos.

00:21:04.140 --> 00:21:07.070
Now look at that.

00:21:07.070 --> 00:21:10.240
As we said before,
we have input types,

00:21:10.240 --> 00:21:12.590
and we have the
semantic types where

00:21:12.590 --> 00:21:17.002
we set telephone and
email search, et cetera.

00:21:17.002 --> 00:21:19.990
If we actually play with
the input type and tell it

00:21:19.990 --> 00:21:22.600
we want to take a
photo, the browser

00:21:22.600 --> 00:21:26.590
will detect the
camera in the phone,

00:21:26.590 --> 00:21:28.260
and when you
activate that input,

00:21:28.260 --> 00:21:32.630
it will actually go
directly to the camera.

00:21:32.630 --> 00:21:35.250
Now if I had no
camera in my phone,

00:21:35.250 --> 00:21:36.930
it would go to my
media gallery and let

00:21:36.930 --> 00:21:40.420
me browse a photo out
of my media gallery.

00:21:40.420 --> 00:21:42.680
So the media
capture in the phone

00:21:42.680 --> 00:21:46.755
lets you actually grab photos,
use the camera from your web

00:21:46.755 --> 00:21:47.255
application.

00:21:47.255 --> 00:21:50.350
This is a very,
very powerful thing.

00:21:50.350 --> 00:21:52.295
You could use it for
instagram-style sites,

00:21:52.295 --> 00:21:52.795
for example.

00:21:56.950 --> 00:22:02.650
Another feature, which is coming
along, is called Web Audio.

00:22:02.650 --> 00:22:07.460
Web Audio is a very powerful
audio signal generator.

00:22:07.460 --> 00:22:10.930
This lets you create
notes, synthesize things,

00:22:10.930 --> 00:22:14.420
do all sorts of fancy effects.

00:22:14.420 --> 00:22:15.190
It's very new.

00:22:15.190 --> 00:22:18.550
It's in Chrome,
Safari, and Opera.

00:22:18.550 --> 00:22:21.520
But it only runs on
high-end devices, so

00:22:21.520 --> 00:22:24.490
devices that support
the NEON ARM extension.

00:22:24.490 --> 00:22:29.470
So NEON is like a separate CPU
core specifically for signal

00:22:29.470 --> 00:22:32.470
processing, and all
modern smartphones

00:22:32.470 --> 00:22:33.610
have the NEON extensions.

00:22:33.610 --> 00:22:36.870
So this is coming, and it will
become really, really popular,

00:22:36.870 --> 00:22:37.745
especially for games.

00:22:41.430 --> 00:22:44.430
Now another interesting thing,
which is really, really good

00:22:44.430 --> 00:22:46.130
is getUserMedia.

00:22:46.130 --> 00:22:50.840
getUserMedia lets
you grab your camera

00:22:50.840 --> 00:22:54.550
and then use it on your
phone from JavaScript.

00:22:54.550 --> 00:22:59.080
So what this does is you place
a video element on your page,

00:22:59.080 --> 00:23:03.410
you say, "getUserMedia," which
gives you a JavaScript object,

00:23:03.410 --> 00:23:07.740
you attach the JavaScript
object to your video element,

00:23:07.740 --> 00:23:11.190
and that lets you play video
directly on your web page,

00:23:11.190 --> 00:23:13.470
coming from your camera.

00:23:13.470 --> 00:23:16.960
Now you can do all sorts of
things like grab still frames.

00:23:16.960 --> 00:23:19.460
So if you connect that
video to a canvas element,

00:23:19.460 --> 00:23:21.480
you can grab frames
out of the video.

00:23:21.480 --> 00:23:23.810
So you can do all
sorts of amazing things

00:23:23.810 --> 00:23:25.410
with getUserMedia.

00:23:25.410 --> 00:23:27.536
But of course, it will
ask the user permission

00:23:27.536 --> 00:23:28.660
for using the camera first.

00:23:31.240 --> 00:23:32.460
Now who's heard of WebRTC?

00:23:35.690 --> 00:23:36.750
A few people.

00:23:36.750 --> 00:23:40.390
Web real time communication--
this is possibly

00:23:40.390 --> 00:23:43.120
one of the biggest new
technologies in web

00:23:43.120 --> 00:23:47.490
and mobile web to
come in recent times.

00:23:47.490 --> 00:23:51.660
WebRTC allows true peer
to peer connection,

00:23:51.660 --> 00:23:56.330
so you can transmit audio
and video peer to peer.

00:23:56.330 --> 00:23:58.310
But one of the best
features of this,

00:23:58.310 --> 00:24:03.870
which is not well understood,
is the RTC data channel.

00:24:03.870 --> 00:24:09.190
Now you can send
video, audio, and data.

00:24:09.190 --> 00:24:15.970
So you can send game data or
files or anything you'd like.

00:24:15.970 --> 00:24:17.570
The beauty of the
data channel is

00:24:17.570 --> 00:24:19.715
it has very, very low latency.

00:24:19.715 --> 00:24:23.410
It has guaranteed 100
milliseconds latency.

00:24:23.410 --> 00:24:26.960
So for multi-player
gaming you can use WebRTC,

00:24:26.960 --> 00:24:31.840
use the data channel to have
fast update of your game play.

00:24:31.840 --> 00:24:35.060
There are many applications,
and we probably can't even

00:24:35.060 --> 00:24:37.390
imagine most of the
applications for this.

00:24:37.390 --> 00:24:39.489
But there are a number
of examples of it,

00:24:39.489 --> 00:24:40.530
and so you should try it.

00:24:40.530 --> 00:24:41.940
It's in Chrome.

00:24:41.940 --> 00:24:42.990
It's in Firefox.

00:24:42.990 --> 00:24:44.270
It's in Opera.

00:24:44.270 --> 00:24:46.000
And so combined with
all those browsers,

00:24:46.000 --> 00:24:49.850
there are probably over a
billion WebRTC-enabled clients

00:24:49.850 --> 00:24:55.130
out in the world today, so
keep an eye on this one.

00:24:55.130 --> 00:24:56.970
Of course, we all love games.

00:24:56.970 --> 00:25:00.530
And who can't love WebGL.

00:25:00.530 --> 00:25:04.650
WebGL is available
from Chrome 30 onwards.

00:25:04.650 --> 00:25:05.480
It's out there.

00:25:05.480 --> 00:25:10.570
It's limited on mobile, but it
is there, and it does perform.

00:25:10.570 --> 00:25:13.570
So here's a random
example that Paul

00:25:13.570 --> 00:25:15.290
found somewhere
of somebody doing

00:25:15.290 --> 00:25:17.240
an interesting thing in WebGL.

00:25:17.240 --> 00:25:21.550
WebGL lets you access the GPU
on the phone, on the device,

00:25:21.550 --> 00:25:26.200
and do high-speed fully
accelerated graphics, something

00:25:26.200 --> 00:25:28.960
you should definitely experiment
with if you like playing games

00:25:28.960 --> 00:25:30.310
or you like fancy 3D.

00:25:33.120 --> 00:25:36.710
This is a new feature--
Add to Homescreen.

00:25:36.710 --> 00:25:40.020
Who runs web applications as
an icon on their phone today?

00:25:42.560 --> 00:25:43.830
Not too many people.

00:25:43.830 --> 00:25:46.720
Now the reason for that is it's
always been a bit difficult.

00:25:49.960 --> 00:25:52.820
I'll just give you another
quick little demo, here.

00:25:52.820 --> 00:25:56.115
So here we have Chrome again.

00:25:59.530 --> 00:26:00.980
I found this nice web page.

00:26:00.980 --> 00:26:04.410
This is a really cool web page.

00:26:04.410 --> 00:26:06.100
It tells me what
the forecast is.

00:26:06.100 --> 00:26:07.420
It tells me the forecast here.

00:26:07.420 --> 00:26:11.340
It uses geolocation,
so it knows where I am.

00:26:11.340 --> 00:26:13.320
It pulls up the
current forecast,

00:26:13.320 --> 00:26:16.200
and I really would like
to use that every day.

00:26:16.200 --> 00:26:20.070
So if I just select my menu
and press Enter Homescreen down

00:26:20.070 --> 00:26:28.440
here and give it a
name, then lo and behold

00:26:28.440 --> 00:26:29.670
it appears on my homescreen.

00:26:29.670 --> 00:26:31.450
Look at that.

00:26:31.450 --> 00:26:35.700
So now we have an icon that
is an actual web application.

00:26:35.700 --> 00:26:41.010
If I find try and start it,
it starts as a full-screen web

00:26:41.010 --> 00:26:43.290
application.

00:26:43.290 --> 00:26:46.340
So now we have fully
installable web apps

00:26:46.340 --> 00:26:49.655
as first class citizens
on Android through Chrome.

00:26:52.990 --> 00:26:54.725
Add to homescreen is very new.

00:26:54.725 --> 00:26:55.490
It's in Chrome 30.

00:26:58.420 --> 00:27:02.190
It will be in Chrome stable very
soon, but the beauty of this

00:27:02.190 --> 00:27:04.400
is that the application
will start full screen,

00:27:04.400 --> 00:27:07.700
so they look like a
native application.

00:27:07.700 --> 00:27:09.080
They have an icon.

00:27:09.080 --> 00:27:13.690
You can select the icon, and it
means if you're an HTML5 game

00:27:13.690 --> 00:27:17.850
developer, for example, you can
build a full-screen application

00:27:17.850 --> 00:27:21.870
that uses the device,
uses the camera,

00:27:21.870 --> 00:27:24.360
looks like a complete
native application

00:27:24.360 --> 00:27:25.520
and runs beautifully.

00:27:25.520 --> 00:27:28.165
You can even leverage WebGL
if you need high performance

00:27:28.165 --> 00:27:28.665
graphics.

00:27:32.730 --> 00:27:34.660
Another feature
of mobile browsers

00:27:34.660 --> 00:27:37.520
that most people
wouldn't know about

00:27:37.520 --> 00:27:40.430
is the use of Android Intents.

00:27:40.430 --> 00:27:43.820
So when you have URLs,
you can specify the target

00:27:43.820 --> 00:27:45.320
that you're trying to hit.

00:27:45.320 --> 00:27:47.735
So normally you
jump to a website

00:27:47.735 --> 00:27:49.880
or you jump to something
else, but you can actually

00:27:49.880 --> 00:27:50.960
specify intent.

00:27:50.960 --> 00:27:57.300
So you see here, we have set an
intent of a bar code scanner.

00:28:00.600 --> 00:28:04.100
So that markup in your
web page tells the browser

00:28:04.100 --> 00:28:09.070
I actually want to use whatever
application scans bar codes.

00:28:09.070 --> 00:28:11.930
So in this case, we've
actually set up the intent

00:28:11.930 --> 00:28:13.790
to say, scan, et
cetera-- you can

00:28:13.790 --> 00:28:17.420
look at the example
at home-- but it

00:28:17.420 --> 00:28:20.240
tells Android to go off and
find the proper application

00:28:20.240 --> 00:28:23.100
to handle my request.

00:28:23.100 --> 00:28:25.045
This is all done
through the intent URL.

00:28:28.400 --> 00:28:31.530
And this is available
today, of course.

00:28:31.530 --> 00:28:34.530
Now this is going to be the
subject of a number of talks

00:28:34.530 --> 00:28:37.570
today-- performance matters.

00:28:37.570 --> 00:28:39.400
Everything is slower.

00:28:39.400 --> 00:28:43.490
When we look at this-- I'll just
talk about this in a moment--

00:28:43.490 --> 00:28:47.800
the speed of a mobile phone
today is approximately 1/10

00:28:47.800 --> 00:28:49.260
of your desktop machine.

00:28:51.970 --> 00:28:53.650
The speed is not just the CPU.

00:28:53.650 --> 00:28:58.460
The speed is memory
bandwidth, the CPU,

00:28:58.460 --> 00:29:00.510
the high resolution
screens we have today.

00:29:00.510 --> 00:29:04.680
We have full HD
mobile phones today.

00:29:04.680 --> 00:29:10.190
But the network is probably
one of the biggest pain points.

00:29:10.190 --> 00:29:13.540
Network connectivity
into 2G and 3G networks

00:29:13.540 --> 00:29:17.290
has very, very high latency.

00:29:17.290 --> 00:29:23.210
Once 4G becomes common, then
that will be greatly improved,

00:29:23.210 --> 00:29:27.840
but for now the network is
one of the slowest components

00:29:27.840 --> 00:29:32.870
in getting a web page from
your server to your client.

00:29:32.870 --> 00:29:36.260
Now today we have this
navigation-timing API.

00:29:36.260 --> 00:29:39.340
If you have a look at the
typical loading of a web page,

00:29:39.340 --> 00:29:42.840
if you choose a URL and
wait for it to show,

00:29:42.840 --> 00:29:44.080
there are all these times.

00:29:44.080 --> 00:29:46.670
There's the network
time, there's

00:29:46.670 --> 00:29:49.080
the load time from
the server, then

00:29:49.080 --> 00:29:52.690
there's processing
before I see anything.

00:29:52.690 --> 00:29:56.430
Now this is a big black
box-- very, very hard

00:29:56.430 --> 00:29:59.790
to understand what is happening.

00:29:59.790 --> 00:30:03.550
So now we have this
navigation-timing API.

00:30:03.550 --> 00:30:06.660
This API breaks
down all the steps

00:30:06.660 --> 00:30:09.940
in the loading of your web page.

00:30:09.940 --> 00:30:12.510
You can see your DNS lookup.

00:30:12.510 --> 00:30:15.600
You can see your cache loading.

00:30:15.600 --> 00:30:19.680
You can see establishment
of a TCP connection.

00:30:19.680 --> 00:30:22.820
You can see all the
other content loading.

00:30:22.820 --> 00:30:25.290
You can see the
events happening.

00:30:25.290 --> 00:30:27.590
This breaks down
your website loading,

00:30:27.590 --> 00:30:31.390
so that you can understand
where you need to improve it.

00:30:31.390 --> 00:30:34.090
So if all the time is
spent in server delay,

00:30:34.090 --> 00:30:37.890
you will see it using this API.

00:30:37.890 --> 00:30:41.690
Of course, when you
load a modern web page,

00:30:41.690 --> 00:30:45.670
there's a lot more content
than just the one web page.

00:30:45.670 --> 00:30:50.930
You have images, CSS
files, JavaScript files.

00:30:50.930 --> 00:30:54.060
To understand the loading
of all the resources

00:30:54.060 --> 00:30:56.300
that make your web
application work,

00:30:56.300 --> 00:31:00.230
you can use the
Resource Timing API.

00:31:00.230 --> 00:31:01.900
The Resource Timing
API will actually

00:31:01.900 --> 00:31:05.240
show you detail for all of
the resources you're loading.

00:31:05.240 --> 00:31:10.690
So if for example, a CSS file
is blocking the load of your web

00:31:10.690 --> 00:31:16.270
application, you can identify it
using the Resources Timing API.

00:31:16.270 --> 00:31:17.969
It's very, very
useful information,

00:31:17.969 --> 00:31:18.885
especially for mobile.

00:31:22.770 --> 00:31:25.150
The new mobile web that
we've all been developing for

00:31:25.150 --> 00:31:27.210
is pretty awesome.

00:31:27.210 --> 00:31:29.135
It's very exciting
to be part of this,

00:31:29.135 --> 00:31:30.760
especially in South
Korea, because this

00:31:30.760 --> 00:31:34.040
is the powerhouse
of smartphones.

00:31:34.040 --> 00:31:36.040
But the thing is, what
we can do now on a phone,

00:31:36.040 --> 00:31:40.070
which we couldn't do before--
we can adapt to screen sizes.

00:31:40.070 --> 00:31:42.920
We can use viewport,
media queries.

00:31:42.920 --> 00:31:47.050
We can change our content
depending on the device,

00:31:47.050 --> 00:31:50.570
depending on the
orientation, very useful.

00:31:50.570 --> 00:31:54.670
We can also handle
people on the move.

00:31:54.670 --> 00:31:56.730
So we can use geolocation.

00:31:56.730 --> 00:31:58.140
We can use device motion.

00:31:58.140 --> 00:32:01.270
We can actually make the
web applications smarter,

00:32:01.270 --> 00:32:03.250
respond to what
we're actually doing,

00:32:03.250 --> 00:32:05.360
because we're not
sitting at a desk.

00:32:08.980 --> 00:32:11.360
We can really speed our input.

00:32:11.360 --> 00:32:14.420
The semantic types
for input make

00:32:14.420 --> 00:32:16.710
your lives much, much simpler.

00:32:16.710 --> 00:32:20.110
The users will love you if you
use the right semantic input

00:32:20.110 --> 00:32:22.770
types, because it
means less typing.

00:32:22.770 --> 00:32:25.030
The faster they get
input, the faster they

00:32:25.030 --> 00:32:29.810
buy things from your website
or the happier they are.

00:32:29.810 --> 00:32:31.730
The other thing that
I'm just showing you

00:32:31.730 --> 00:32:34.520
that is really,
really amazing is

00:32:34.520 --> 00:32:37.820
integration with
features on the device.

00:32:37.820 --> 00:32:38.900
You have the camera.

00:32:38.900 --> 00:32:40.770
You have accelerometers.

00:32:40.770 --> 00:32:42.450
You can grab the microphone.

00:32:42.450 --> 00:32:44.525
You can do all
sorts of things that

00:32:44.525 --> 00:32:47.127
are like native
applications but work

00:32:47.127 --> 00:32:48.710
straight out of your
browser, straight

00:32:48.710 --> 00:32:52.090
from your web application.

00:32:52.090 --> 00:32:54.410
The other thing that is
really important to do

00:32:54.410 --> 00:32:57.390
is to measure performance
across all devices,

00:32:57.390 --> 00:32:59.550
and we have a number of
methods of doing that.

00:32:59.550 --> 00:33:03.610
We have new navigation APIs,
and the Resource Timing APIs,

00:33:03.610 --> 00:33:06.280
which give you more information.

00:33:06.280 --> 00:33:08.740
Later on today there will
be a number of deep dives

00:33:08.740 --> 00:33:11.040
into how you can measure
graphics performance,

00:33:11.040 --> 00:33:13.050
et cetera, which
all help you build

00:33:13.050 --> 00:33:15.610
a beautiful site
that users will love.

00:33:15.610 --> 00:33:18.250
And all this means
is more users.

00:33:18.250 --> 00:33:20.650
Of course very, very
soon you should really

00:33:20.650 --> 00:33:21.970
look at all these new features.

00:33:21.970 --> 00:33:26.560
WebRTC, I highly recommend
people explore WebRTC.

00:33:26.560 --> 00:33:29.370
It will be a huge,
huge thing on the Web.

00:33:29.370 --> 00:33:31.180
Web Audio, especially
if you want

00:33:31.180 --> 00:33:33.510
to do gaming or any
sound applications.

00:33:33.510 --> 00:33:35.170
It's a fantastic API.

00:33:35.170 --> 00:33:37.970
And of course, WebGL, which is
very exciting that it's finally

00:33:37.970 --> 00:33:40.850
getting mobile browsers.

00:33:40.850 --> 00:33:44.320
So that's pretty much a
very, very quick overview

00:33:44.320 --> 00:33:47.540
of all the new APIs that are
in mobile browsers today.

00:33:47.540 --> 00:33:50.245
Feel free to come and ask
questions whenever you like.

00:33:50.245 --> 00:33:51.620
I'll be around
all day, so if you

00:33:51.620 --> 00:33:56.502
have any specific questions,
please come and ask.

00:33:56.502 --> 00:33:57.460
We have a question now.

00:33:57.460 --> 00:33:59.570
Yes?

00:33:59.570 --> 00:34:00.487
Yes, you.

00:34:00.487 --> 00:34:08.936
AUDIENCE: So you have said that
current schedule [INAUDIBLE]

00:34:08.936 --> 00:34:13.409
what example that you said
is about the [INAUDIBLE].

00:34:13.409 --> 00:34:17.385
My question simply
is that for example,

00:34:17.385 --> 00:34:21.361
in Android, the case of
[INAUDIBLE] having the Google

00:34:21.361 --> 00:34:22.355
I/Os.

00:34:22.355 --> 00:34:26.828
Google already has announced
[INAUDIBLE] the location,

00:34:26.828 --> 00:34:28.319
and they take pictures.

00:34:28.319 --> 00:34:31.301
So what is the difference
about the Chrome approach

00:34:31.301 --> 00:34:32.792
and in the Google Android?

00:34:32.792 --> 00:34:36.271
Is the Google Android's
make use of API approach?

00:34:36.271 --> 00:34:38.756
Maybe Chrome,
itself, has supported

00:34:38.756 --> 00:34:43.229
some of the same features that
is announced in the Google I/O

00:34:43.229 --> 00:34:45.714
2000 TCUs?

00:34:45.714 --> 00:34:47.702
They're reputedly
very fantastic,

00:34:47.702 --> 00:34:51.678
but I'm wondering about
the Chrome assembly,

00:34:51.678 --> 00:34:55.500
if it was supported [INAUDIBLE].

00:34:55.500 --> 00:34:58.720
ALEX DANILO: The question
was that this year's I/O

00:34:58.720 --> 00:35:01.160
Android-announced
enhanced location features

00:35:01.160 --> 00:35:05.690
for finding the location on
the phone from an application

00:35:05.690 --> 00:35:08.300
and whether or not the
browsers support that

00:35:08.300 --> 00:35:12.020
and what the difference is.

00:35:12.020 --> 00:35:14.700
What was announced was actually
the Google Play services

00:35:14.700 --> 00:35:17.860
has an enhanced
location capability.

00:35:17.860 --> 00:35:21.820
And what it does is it leverages
the accelerometers and motion

00:35:21.820 --> 00:35:24.880
sensors in the
phone on top of GPS.

00:35:24.880 --> 00:35:30.970
So traditionally the location
has been derived from GPS data,

00:35:30.970 --> 00:35:34.890
the enhanced Android
location uses motion,

00:35:34.890 --> 00:35:38.600
uses the device motion
sensors and accelerometers

00:35:38.600 --> 00:35:41.530
to get a more accurate picture
of the motion of the user.

00:35:41.530 --> 00:35:47.430
So it supplements GPS so it
creates additional accuracy

00:35:47.430 --> 00:35:50.910
by virtue of the
phone's sensors.

00:35:50.910 --> 00:35:53.370
Those APIs are used
by Chrome internally,

00:35:53.370 --> 00:35:55.880
so the Android
platform improvements

00:35:55.880 --> 00:35:57.920
filter down into the browser.

00:35:57.920 --> 00:36:02.400
So when you use
geolocation in Chrome,

00:36:02.400 --> 00:36:05.130
it is going through
the Android API.

00:36:05.130 --> 00:36:06.767
Improvements to the
Android platform

00:36:06.767 --> 00:36:08.475
automatically filter
down to the browser.

00:36:11.248 --> 00:36:11.748
OK.

00:36:15.234 --> 00:36:17.226
Oh, sorry?

00:36:17.226 --> 00:36:21.464
AUDIENCE: According
to your presentation,

00:36:21.464 --> 00:36:25.400
you provide [INAUDIBLE]
features normally,

00:36:25.400 --> 00:36:28.024
[INAUDIBLE] return
to Chrome, not

00:36:28.024 --> 00:36:31.304
in the Android previous
[INAUDIBLE] browsers.

00:36:31.304 --> 00:36:37.722
So the Google [INAUDIBLE] not
on the Android, but [INAUDIBLE].

00:36:40.067 --> 00:36:42.400
ALEX DANILO: Why don't we
take that question afterwards.

00:36:42.400 --> 00:36:43.370
Why don't you come
and talk to me

00:36:43.370 --> 00:36:45.630
after the talk, because it's
a little bit too detailed

00:36:45.630 --> 00:36:50.286
for this high level-- All
right, another question, yes?

00:36:50.286 --> 00:36:54.230
AUDIENCE: You explained several
ways to adapt to a screen size

00:36:54.230 --> 00:36:57.681
at the web application
or web page level,

00:36:57.681 --> 00:37:01.625
but another way that you
can adapt to the screen size

00:37:01.625 --> 00:37:05.076
is at the http server.

00:37:05.076 --> 00:37:10.940
You use the user agent string
and serve mobile version

00:37:10.940 --> 00:37:12.434
or desktop version or whatever.

00:37:12.434 --> 00:37:14.924
So what do you think
about this approach?

00:37:14.924 --> 00:37:18.410
Do you think that this approach
should be wrong in the future

00:37:18.410 --> 00:37:21.910
or should be improved or--

00:37:21.910 --> 00:37:24.450
ALEX DANILO: OK, the
question is about detecting

00:37:24.450 --> 00:37:26.450
different screen
sizes and adapting

00:37:26.450 --> 00:37:30.310
content to the different
screen sizes versus desktop,

00:37:30.310 --> 00:37:32.210
whether or not to
use the features

00:37:32.210 --> 00:37:35.100
in the browser versus
using the user agent

00:37:35.100 --> 00:37:37.150
string from the server side.

00:37:37.150 --> 00:37:38.960
We would now highly
recommend you

00:37:38.960 --> 00:37:41.160
don't look at the
user agent string

00:37:41.160 --> 00:37:44.080
and do all the content
authoring responsive,

00:37:44.080 --> 00:37:46.240
so that you adapt
to screen sizes

00:37:46.240 --> 00:37:48.800
inside the browser
inside your content.

00:37:48.800 --> 00:37:51.970
The reason is that the user
agent string is incredibly

00:37:51.970 --> 00:37:56.100
unreliable, and it's
very easy for a user

00:37:56.100 --> 00:37:59.370
to change the user agent string
so that you don't actually

00:37:59.370 --> 00:38:01.230
know the browser properly.

00:38:01.230 --> 00:38:06.650
So it's a very, very unreliable
way to detect the user agent.

00:38:06.650 --> 00:38:11.040
So media queries and all of
the other adaptive designs

00:38:11.040 --> 00:38:14.160
is really what we'd
recommend today.

00:38:14.160 --> 00:38:18.030
OK, all right on that
I'll say thank you.

00:38:18.030 --> 00:38:21.434
Anybody want to come-- oh,
one last question, yes?

00:38:21.434 --> 00:38:23.990
AUDIENCE: Thank you.

00:38:23.990 --> 00:38:27.645
My question is concerning
to your homescreen feature.

00:38:27.645 --> 00:38:31.259
So Apple already
supports Apple meta tag.

00:38:31.259 --> 00:38:34.133
I think that the homescreen
feature of Chrome

00:38:34.133 --> 00:38:37.490
is very similar with that,
so using the meta tag anyway.

00:38:37.490 --> 00:38:41.132
But I think that anyway that
could be a fragmentation

00:38:41.132 --> 00:38:44.540
because there are no
standard code aps yet, right?

00:38:44.540 --> 00:38:47.820
So as far as I know, in the
[INAUDIBLE] or web application

00:38:47.820 --> 00:38:51.920
tools, they tried to
make many faster formats

00:38:51.920 --> 00:38:58.500
for web applications that
is added by a [INAUDIBLE],

00:38:58.500 --> 00:39:01.820
so my question is that
Chrome [INAUDIBLE]

00:39:01.820 --> 00:39:05.060
has a plan to support that
kind of standard features

00:39:05.060 --> 00:39:08.120
for installation of
web applications.

00:39:08.120 --> 00:39:11.070
ALEX DANILO: OK, The question is
about the install to homescreen

00:39:11.070 --> 00:39:13.950
feature, because
at the moment it's

00:39:13.950 --> 00:39:17.990
a meta tag that's Apple-specific
and whether or not

00:39:17.990 --> 00:39:19.756
this is being
standardized and we're

00:39:19.756 --> 00:39:21.130
going on with the
standardization

00:39:21.130 --> 00:39:22.860
of this feature.

00:39:22.860 --> 00:39:26.150
Well now in Chrome we
support the meta tags

00:39:26.150 --> 00:39:29.070
that indicate to an Apple
device that we recognize

00:39:29.070 --> 00:39:32.610
the Apple-specific meta
tags to enable an install

00:39:32.610 --> 00:39:35.650
to homescreen for
backward compatibility.

00:39:35.650 --> 00:39:40.070
We intend to go forward with
the standardization process.

00:39:40.070 --> 00:39:45.050
We actually mention Mozilla as
far as install to homescreen.

00:39:45.050 --> 00:39:47.620
The Co-chair of the
web apps working group

00:39:47.620 --> 00:39:51.590
who used to work for Mozilla
now works for Google in Sydney

00:39:51.590 --> 00:39:53.430
as of about two weeks ago.

00:39:53.430 --> 00:39:56.810
So we are very active in making
sure that we push forward

00:39:56.810 --> 00:39:58.620
through standardization,
because we really

00:39:58.620 --> 00:40:01.660
believe in open standards
and W3C and all that.

00:40:01.660 --> 00:40:04.494
So we will definitely
be following that path

00:40:04.494 --> 00:40:05.285
to standardization.

00:40:09.029 --> 00:40:11.320
OK, all right everybody,
thanks very much for listening

00:40:11.320 --> 00:40:13.120
and enjoy the rest of the day.

00:40:13.120 --> 00:40:25.950
[APPLAUSE]

