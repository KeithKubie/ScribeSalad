WEBVTT
Kind: captions
Language: en

00:09:39.193 --> 00:09:41.193
Autonomous and customized 
pre-launch 

00:09:42.403 --> 00:09:44.403
testing in the

00:09:58.186 --> 00:10:00.186
Google Play

00:10:04.927 --> 00:10:06.927
Console  

00:23:05.567 --> 00:23:07.567
&gt;&gt; RICHARD GAYWOOD:  Hello.

00:23:11.732 --> 00:23:13.732
I'm here to to talk about 
pre-launch report.  

00:23:14.165 --> 00:23:16.165
&gt;&gt; JUSTIN BROUGHTON:  I'm 
Justin.

00:23:17.812 --> 00:23:20.054
Manager of the Firebase Test 
Lab.  Thank you for those that 

00:23:20.055 --> 00:23:22.055
made it at 

00:23:23.470 --> 00:23:25.645
this rather unGodunGodlyarea.

00:23:28.706 --> 00:23:30.706
I'm sure that wordy title didn't
help.

00:23:35.960 --> 00:23:38.208
Did we really use the word 
autonomous? 

00:23:39.839 --> 00:23:41.839
Today we here to talk about 
intelligence 

00:23:44.374 --> 00:23:46.838
app and game testing that 
requires mercifully little work 

00:23:46.839 --> 00:23:48.839
on your part, and 

00:23:51.100 --> 00:23:53.343
it's available on both the play 
console and in Firebase Test 

00:23:53.344 --> 00:23:57.686
Lab.  Both products have massive
increased their offering, and 

00:23:57.687 --> 00:23:59.750
we're here to tell you about 
what's in one, what's in the 

00:24:00.160 --> 00:24:02.160
other, and what's in both.

00:24:03.449 --> 00:24:11.608
We'll tell you our story in the 
context of an app.   

00:24:14.049 --> 00:24:16.049
Testing is a pain, but as you've

00:24:17.098 --> 00:24:19.146
probably heard multiple times 
this week, it's really 

00:24:19.147 --> 00:24:21.147
important.

00:24:23.638 --> 00:24:25.667
So as much as possible, we want 
to take Google's expertise and 

00:24:25.668 --> 00:24:27.668
resources 

00:24:29.954 --> 00:24:32.210
and make it our pain and not 
yours.  

00:24:33.284 --> 00:24:34.101
&gt;&gt; JUSTIN BROUGHTON:  Let's 
start with the pre-launch 

00:24:34.102 --> 00:24:38.399
report.  This is an automated 
scan of your app that aims an 

00:24:38.400 --> 00:24:39.825
early warning of quality problem
before your users see them.  

00:24:44.086 --> 00:24:46.086
It's a free service, and it 
aapplies 

00:24:48.157 --> 00:24:50.196
automatically to every alpha or 
beta tracks or the new open and 

00:24:50.197 --> 00:24:52.466
closed testing tracks.  

00:24:56.166 --> 00:24:58.602
We take APKs that you pass to 
Google Play and install them on 

00:24:58.603 --> 00:25:02.484
about ten devices.  These 
devices span a range.  There are

00:25:02.485 --> 00:25:04.485
high-end devices like the 

00:25:07.984 --> 00:25:10.247
pixel 2 and down to low-end 
devices like the Samsung Galaxy.

00:25:13.537 --> 00:25:15.537
One it's installed we start the 
special robocrawler process.

00:25:20.902 --> 00:25:23.767
It exs  explores your app like a
user would.  This takes MRAPS on

00:25:23.768 --> 00:25:28.244
physical infrastructure, which 
is part of a larger farm with 

00:25:28.245 --> 00:25:30.245
thousands of different 

00:25:32.524 --> 00:25:33.750
dozens and a large diversity of 
hardware and operating systems. 

00:25:36.819 --> 00:25:38.262
Your fellow developers have told
us they take pre-launch report 

00:25:38.263 --> 00:25:40.263
very seriously.

00:25:42.147 --> 00:25:44.807
In a recent survey, 86% said 
that they consider pre-launch 

00:25:44.808 --> 00:25:47.248
report results to be important 
or very important when they 

00:25:49.286 --> 00:25:50.504
consider whether it's time to 
launch a new app into 

00:25:50.505 --> 00:25:52.505
production.  

00:25:54.188 --> 00:25:56.188
When developers have ignored or 
recommendations and launched in 

00:25:57.849 --> 00:25:59.481
something we found problems, our
data says about 75% of the time 

00:25:59.482 --> 00:26:04.169
the problems that we found in 
pre-launch report were later 

00:26:04.170 --> 00:26:08.229
seen by real users.  Those users
got a poor experience.  They may

00:26:08.230 --> 00:26:12.310
have left bad reviews.  They may
have left bad ratings.  They 

00:26:12.311 --> 00:26:14.583
have maze have chose not to 
spend money in the app and maybe

00:26:14.584 --> 00:26:18.246
uninstalled the app.  
Furthermore, pre-launch report 

00:26:18.247 --> 00:26:20.702
test results are used internally
within play 

00:26:24.823 --> 00:26:27.267
with a factor when decides how 
to feature it rank in the app 

00:26:27.268 --> 00:26:30.118
store.  We have looked at a 
million appears 

00:26:34.175 --> 00:26:35.920
and if we're not crawling yours,
we'd really like to be doing 

00:26:35.921 --> 00:26:37.967
that.  
As you probably guessed what 

00:26:37.968 --> 00:26:39.223
from what I guessed, pre-launch 
report is good at finding 

00:26:39.224 --> 00:26:43.738
crashes.  When we find a crash 
in your app while we test it, we

00:26:43.739 --> 00:26:45.988
give you a lot of information, 
stack traces, log caps and 

00:26:46.599 --> 00:26:50.265
things like that.  Everything to
debug the crash and fix it.  We 

00:26:50.266 --> 00:26:53.115
don't just do crashes.  
We also take screenshots and 

00:26:53.116 --> 00:26:57.222
capture a video of the crawl on 
each device so that you can look

00:26:57.223 --> 00:27:01.500
for UX issues in different 
languages.  In October we added 

00:27:01.501 --> 00:27:05.968
performance data.  This is 
network, memory and CPU metrics 

00:27:05.969 --> 00:27:07.642
so that you can look for 
performance issues in your app. 

00:27:07.643 --> 00:27:12.520
So that's what my team does, the
play relaunch report.  What 

00:27:12.521 --> 00:27:14.521
about your team, Justin?  

00:27:16.610 --> 00:27:17.438
&gt;&gt; JUSTIN BROUGHTON:  So my 
teamworks on Firebase Test Lab. 

00:27:20.953 --> 00:27:23.816
So Firebase Test Lab is a 
separate solution that is part 

00:27:23.817 --> 00:27:25.817
of the suite of products under 
the Firebase umbrella.

00:27:29.138 --> 00:27:31.584
It uses the same technology as 
the pre-launch report including 

00:27:31.585 --> 00:27:33.585
the larger device farm that 
Richard mentioned.

00:27:37.745 --> 00:27:39.745
It offers many of the same 
features.

00:27:41.221 --> 00:27:43.221
It also integrates with a number
of 

00:27:45.332 --> 00:27:48.299
different tools like Android 
studio, FastLane, G cloud SDK 

00:27:48.300 --> 00:27:50.300
and the Firebase 

00:27:52.010 --> 00:27:54.010
console allowing developers to 
test 

00:27:56.069 --> 00:27:58.930
their apps and games at all 
stages of the application life 

00:27:58.931 --> 00:28:00.931
cycle across a 

00:28:03.205 --> 00:28:05.435
wider array of devices giving 
you more comprehensive test 

00:28:05.436 --> 00:28:10.715
results.  
So let's talk about an app.  

00:28:10.716 --> 00:28:12.716
This is fitness bud.

00:28:17.888 --> 00:28:20.167
Now, while fitness bud is not a 
real application, it does 

00:28:20.168 --> 00:28:23.241
illustrate real-world problems. 
Problems we know that you all 

00:28:23.242 --> 00:28:25.242
have.  

00:28:27.977 --> 00:28:30.465
Fitness bud is a social fitness 
tracking application built by, 

00:28:30.466 --> 00:28:32.949
let's say, a small company FB 
Solutions.

00:28:36.430 --> 00:28:38.677
Fitness Bud allows you to log in
with a Google account or custom 

00:28:38.678 --> 00:28:40.678
account, 

00:28:42.932 --> 00:28:45.597
create an online fitness avatar,
invite fitness buddies with whom

00:28:45.598 --> 00:28:48.440
to train, and even join a local 
gym.

00:28:51.709 --> 00:28:54.365
Richard and I are going to take 
you through how FB Solutions 

00:28:54.366 --> 00:28:56.366
makes use of 

00:28:58.636 --> 00:29:00.636
the many new tools at their 
disposal to 

00:29:02.296 --> 00:29:04.296
develop, test and release their 

00:29:05.359 --> 00:29:07.359
soon-to-be wildly successful 
application.  

00:29:07.804 --> 00:29:09.804
&gt;&gt; RICHARD GAYWOOD:  Thanks, 
Justin.

00:29:10.844 --> 00:29:13.742
Like my wife reminds me, my body
shape is best described as a 

00:29:13.743 --> 00:29:15.743
potato on legs, 

00:29:18.030 --> 00:29:19.451
so I need fitness bud to be 
very, very good.  

00:29:19.452 --> 00:29:21.452
&gt;&gt; JUSTIN BROUGHTON:  How many 
have spouses like -- no.  Sorry.

00:29:21.888 --> 00:29:26.594
How many of you have way more 
time than you know what to do 

00:29:26.595 --> 00:29:32.502
with and can fix every last 
problem in your app?  Nobody?  

00:29:32.503 --> 00:29:35.955
&gt;&gt; RICHARD GAYWOOD:  Neither do 
we.  With all the signals 

00:29:35.956 --> 00:29:37.991
pre-launch report makes 
available to you, it can be hard

00:29:40.430 --> 00:29:41.642
to prioritize to SDIEZ which 
issue is the most urge the to 

00:29:41.643 --> 00:29:45.984
fix.  Starting this week, we 
launched a new page which 

00:29:45.985 --> 00:29:47.985
digests all of the issues we 
found into a single launch 

00:29:48.827 --> 00:29:51.710
recommendation as you can see 
here.  This shows up the at the 

00:29:51.711 --> 00:29:53.711
top of our new overview tab.  

00:29:56.401 --> 00:29:58.401
The overview tab displays all 
the issues 

00:29:59.454 --> 00:30:01.454
that pre-launch report found 
prioritized by severity.

00:30:03.518 --> 00:30:05.518
It makes it easy forfeitness bud
to 

00:30:07.622 --> 00:30:09.622
see at a glance if this new ADK 
is ready 

00:30:10.680 --> 00:30:13.550
for users or not.  
&gt;&gt; JUSTIN BROUGHTON:  Test lab's

00:30:15.793 --> 00:30:17.793
intelligent crawler does a great
job of 

00:30:18.844 --> 00:30:20.844
crawling the Android framework 
part of fitness bud.  

00:30:25.151 --> 00:30:27.574
Fitness bud uses OpenGL for an 
online fitness avatar creation 

00:30:27.575 --> 00:30:29.575
part.

00:30:30.895 --> 00:30:32.895
Previously the pre-launch report

00:30:34.592 --> 00:30:39.046
couldn't Tess  tests and appears
in OpenGL, but no it can.  If 

00:30:39.047 --> 00:30:41.528
you're a game developer, you can
write what are called demo 

00:30:41.529 --> 00:30:43.529
loops.  

00:30:46.658 --> 00:30:50.146
Demo loops are an automated 
journey through your app.  They 

00:30:50.147 --> 00:30:52.147
can focus on a particular level 

00:30:53.818 --> 00:30:55.818
or a particular game character. 

00:30:59.326 --> 00:31:01.326
Demo loops are a great way -- 

00:31:02.379 --> 00:31:03.616
they are an intent filter that 
is declared in your manifest.  

00:31:07.280 --> 00:31:09.326
They're not normally crawled as 
part of the normal running of 

00:31:09.327 --> 00:31:14.263
the application, but our test 
infrastructure will detect them 

00:31:14.264 --> 00:31:16.264
and run them.

00:31:19.167 --> 00:31:20.989
Demo loop's launch year in 
Firebase Test Lab.  

00:31:20.990 --> 00:31:23.031
&gt;&gt; RICHARD GAYWOOD:  Starting 
this week, demo loops are 

00:31:23.032 --> 00:31:25.266
available in pre-launch report 
as well.  If you choose to add a

00:31:25.267 --> 00:31:30.345
demo loop to your app, when we 
take your app through pre-launch

00:31:30.346 --> 00:31:32.346
report, rather than the usual 

00:31:34.419 --> 00:31:36.871
robocrawler, we run the demo 
loop and output.  We look for 

00:31:36.872 --> 00:31:38.872
crashes and most importantly 
give you performance traces 

00:31:41.558 --> 00:31:42.981
so you can use demo loops for 
accurate benchmarking on our 

00:31:42.982 --> 00:31:44.982
range of devices.

00:31:46.432 --> 00:31:48.465
If you don't use a demo loop, we
have another new feature called 

00:31:48.466 --> 00:31:50.466
monkey actions.

00:31:51.519 --> 00:31:53.958
When we defect an OpenGL part of
the app, we fall to random input

00:31:53.959 --> 00:31:56.196
so we get some crawling for you.

00:31:59.805 --> 00:32:02.966
Fitness bud really cares about 
keeping data safe and secure, so

00:32:02.967 --> 00:32:05.837
fitness bud requires customer 
log in or log in with Google.  

00:32:05.838 --> 00:32:10.307
&gt;&gt; JUSTIN BROUGHTON:  And if you
use Firebase or both of these 

00:32:10.308 --> 00:32:12.380
are supported.  
&gt;&gt; RICHARD GAYWOOD:  As I said 

00:32:12.381 --> 00:32:14.381
before I was so rudely 
interrupted by a message 

00:32:17.464 --> 00:32:20.441
from our sponsors, pre-launch 
report uses an auto log in 

00:32:20.442 --> 00:32:24.215
feature.  As we test an app, 
when we see a sign in with 

00:32:24.216 --> 00:32:26.236
Google button, we will use it 
and we automatically have a 

00:32:26.237 --> 00:32:29.333
Google account on the device 
ready to be signed in.  

00:32:31.584 --> 00:32:33.198
Applications that don't use log 
in with Google can choose to 

00:32:33.199 --> 00:32:36.470
configure pre-launch report with
a user name or e-mail address 

00:32:36.471 --> 00:32:39.315
and a password that we will 
again use to get past the log in

00:32:40.945 --> 00:32:42.945
screen when we see it.  

00:32:45.227 --> 00:32:47.865
Next, let's talk about deep 
links.  Deep links are way to 

00:32:47.866 --> 00:32:51.122
invoke functionality WRN your 
app that bypasses the normal 

00:32:51.123 --> 00:32:55.814
entry flow.  For example, a user
might start off searching the 

00:32:55.815 --> 00:32:58.660
web but should be shown those 
search results within the app.

00:33:03.132 --> 00:33:05.167
Two 
&gt;&gt; JUSTIN BROUGHTON:  How many 

00:33:05.168 --> 00:33:09.267
have deep links in your apps?  
Wow.  Yeah.  How many test those

00:33:09.268 --> 00:33:13.759
deep links at every release of 
the app?  One, two?  Nice.  

00:33:15.177 --> 00:33:16.821
&gt;&gt; RICHARD GAYWOOD:  We salute 
you.  So fitness bud had this 

00:33:16.822 --> 00:33:20.891
problem.  They used deep links 
to encourage users to sign up to

00:33:20.892 --> 00:33:22.892
local gyms.

00:33:25.376 --> 00:33:27.602
The user receives a Firebase 
notification alerting them to a 

00:33:27.603 --> 00:33:29.603
special offer.

00:33:30.662 --> 00:33:32.662
They click the link and are 
taken 

00:33:34.383 --> 00:33:36.376
straight to fitness bud's gym 
signup screen.  This is an 

00:33:36.377 --> 00:33:38.628
important flow for them, because
money changes hands.  

00:33:40.906 --> 00:33:43.577
Launching this week, pre-launch 
report will test up to three 

00:33:43.578 --> 00:33:47.449
deep links.  You can configure 
it and add the deep links.  We 

00:33:47.450 --> 00:33:49.280
crawl for the five minutes, and 
at the end of the crawl we close

00:33:49.281 --> 00:33:54.369
the app and visit each deep link
in turn.  As we visit each deep 

00:33:54.370 --> 00:33:57.829
link, we crawl for a further 30 
seconds.  

00:33:59.253 --> 00:34:01.727
&gt;&gt; JUSTIN BROUGHTON:  So fitness
bud and you can make sure that 

00:34:01.728 --> 00:34:03.728
users who follow deep links can 
have the same great experience.

00:34:11.531 --> 00:34:13.531
So as we have seen from the 
million-plus 

00:34:15.209 --> 00:34:17.455
apps that the crawler has 
tested, sometimes crucial parts 

00:34:17.456 --> 00:34:19.501
of an application are only 
reached through 

00:34:24.377 --> 00:34:26.377
some complicated flow like 
fitness bud's gym signup form.

00:34:28.669 --> 00:34:30.669
It turns out that automated 
crawlers 

00:34:32.129 --> 00:34:34.129
and even some humans aren't that
good at 

00:34:37.031 --> 00:34:39.031
entering the correct text to 
bypass this form.  

00:34:40.280 --> 00:34:43.149
&gt;&gt; RICHARD GAYWOOD:  This is 
where roboscripts come in.  It 

00:34:43.150 --> 00:34:45.001
provides guidance to the crawler
to get past a complicated part 

00:34:45.002 --> 00:34:47.002
of the app.

00:34:48.296 --> 00:34:50.296
They take the form of a short, 

00:34:51.784 --> 00:34:53.784
scripted sequence of actions 
recorded as a Json file.

00:34:56.261 --> 00:34:58.261
You can record it using a tool 
with 

00:34:59.709 --> 00:35:01.752
Android studio with the app 
running locally you record taps 

00:35:01.753 --> 00:35:06.836
and swipes.  You up load this to
pre-launch report or Firebase 

00:35:06.837 --> 00:35:08.837
script lab.

00:35:09.906 --> 00:35:11.524
The it guides of early part of 
the call to get the app into 

00:35:11.525 --> 00:35:14.177
some state that you think is 
interesting to test.  

00:35:16.667 --> 00:35:19.321
Once it's completed, the 
roboscript starts to crawl 

00:35:19.322 --> 00:35:21.161
normally.  
&gt;&gt; JUSTIN BROUGHTON:  Row Bo 

00:35:21.162 --> 00:35:23.219
Bowe scripts are useful for 
crawling forms.

00:35:26.906 --> 00:35:28.906
They can also be used to guide 
the 

00:35:29.972 --> 00:35:32.433
crawler past any part that it 
finds tricky to navigate.  

00:35:33.640 --> 00:35:34.694
&gt;&gt; RICHARD GAYWOOD:  Usability 
and accessibility are really 

00:35:34.695 --> 00:35:37.336
important to your app.  If you 
make your touch targets too 

00:35:40.184 --> 00:35:42.184
small, you might have a result 
like this.

00:35:46.727 --> 00:35:48.727
Not one of your better days at 
the gym, Justin? 

00:35:49.432 --> 00:35:51.670
Does that happen to a lot?  
&gt;&gt; JUSTIN BROUGHTON:  Actually, 

00:35:51.671 --> 00:35:53.671
no, but 

00:35:54.920 --> 00:35:57.384
I have a persistent fear of 
treadmills.  I haven't been on 

00:35:57.385 --> 00:35:57.776
one since -- 
&gt;&gt; RICHARD GAYWOOD:  I think 

00:35:57.777 --> 00:36:01.664
that's probably why.  In the 
next few weeks we add an 

00:36:03.945 --> 00:36:06.394
intelligent crawler to help 
uncover usability issues like 

00:36:06.395 --> 00:36:11.503
that tiny button Justin was 
trying to click there.  All 

00:36:11.504 --> 00:36:13.349
jokes aside, though, small touch
targets are a problem for a wide

00:36:13.350 --> 00:36:15.384
range of users including users 
using your app 

00:36:18.850 --> 00:36:22.385
on the go when handed or users 
with dexterity impairments.  

00:36:22.386 --> 00:36:25.059
Legible text is extremely 
important, so we will warn you 

00:36:25.060 --> 00:36:27.548
when text is too small or we 
will warn you when the contrast 

00:36:27.549 --> 00:36:30.829
is too low.  
Some visually impaired used rely

00:36:30.830 --> 00:36:32.830
heavily 

00:36:34.481 --> 00:36:36.142
on talk back, so we will also 
tell you when talk back 

00:36:36.143 --> 00:36:39.293
voice-over annotations are 
missing or confusing.  

00:36:40.510 --> 00:36:43.172
&gt;&gt; JUSTIN BROUGHTON:  And as you
can tell that infamous button 

00:36:43.173 --> 00:36:45.655
was trying to click is included 
in the usability 

00:36:49.367 --> 00:36:51.367
results, and it's got a big red 
box around it.

00:36:54.922 --> 00:36:56.922
Thankfully it's marked as should
fix.  

00:36:57.154 --> 00:36:59.154
&gt;&gt; RICHARD GAYWOOD:  So after a 
full 

00:37:01.097 --> 00:37:03.097
sprint of bug fixing, fitness 
bud 

00:37:04.575 --> 00:37:06.607
uploads a fresh ADK to the 
console.  As you can see here, 

00:37:06.608 --> 00:37:12.149
there are no longer any serious 
issues detected.  They can now 

00:37:12.150 --> 00:37:13.565
push this APK into the 
production channel confident the

00:37:13.566 --> 00:37:16.820
users receive a good experience.
&gt;&gt; JUSTIN BROUGHTON:  So we hope

00:37:16.821 --> 00:37:21.754
that you, too, can adopt the 
pre-launch report as part of 

00:37:21.755 --> 00:37:23.755
your decision to launch.

00:37:26.465 --> 00:37:30.549
&gt;&gt; RICHARD GAYWOOD:  That's what
you get in pre-launch report 

00:37:30.550 --> 00:37:32.550
available for free 

00:37:34.838 --> 00:37:37.071
to everyone who publishes AKPs 
to the alpha or bait take 

00:37:37.072 --> 00:37:39.933
channels but now call open and 
closed tests tracks.  You can 

00:37:39.934 --> 00:37:41.970
find it in the Google Play 
Console Google Play Console and 

00:37:41.971 --> 00:37:45.051
managed releases.  
&gt;&gt; JUSTIN BROUGHTON:  Thank you,

00:37:45.052 --> 00:37:46.267
Richard.  
&gt;&gt; RICHARD GAYWOOD:  You're 

00:37:46.268 --> 00:37:47.295
welcome.  
&gt;&gt; JUSTIN BROUGHTON:  As 

00:37:47.296 --> 00:37:51.584
developers we know that the 
earlier we catch problems, the 

00:37:51.585 --> 00:37:53.585
easier they are to fix.

00:37:54.855 --> 00:37:56.855
So if you're a conscientious 
developer 

00:37:58.301 --> 00:38:00.740
or like to save money, you want 
to catch problems as quickly as 

00:38:00.741 --> 00:38:02.741
possible.

00:38:04.225 --> 00:38:06.225
This is where Firebase Test Lab 
comes in.  

00:38:10.163 --> 00:38:12.163
Now, many of us, myself 
included, have 

00:38:14.052 --> 00:38:16.052
discussed ad nauseam about the 

00:38:17.108 --> 00:38:19.108
importance of creating automated
tests 

00:38:20.770 --> 00:38:23.609
for every part of your 
application and to run those 

00:38:23.610 --> 00:38:28.948
tests continuously to prevent 
regressions.  This is honestly 

00:38:28.949 --> 00:38:34.043
the most important thing you can
do to improve the quality of 

00:38:34.044 --> 00:38:41.020
your applications.  
Writing tests is hard.  That's 

00:38:41.021 --> 00:38:43.021
why when I ask in gatherings 

00:38:45.077 --> 00:38:47.077
like this how many of you have 
automated 

00:38:48.332 --> 00:38:50.979
tests that cover every part of 
your application, way too few of

00:38:50.980 --> 00:38:52.980
you put up your hands.

00:38:55.045 --> 00:38:57.045
So I gave up nagging a while 
ago, and 

00:38:58.740 --> 00:39:00.740
we at Google have put a lot of 
focus 

00:39:03.250 --> 00:39:05.292
into creating -- creating tests 
for apps and games without 

00:39:05.293 --> 00:39:08.980
actually having to write those 
tests.  

00:39:12.455 --> 00:39:14.532
Earlier we saw the automated 
crawler, which is part of 

00:39:14.533 --> 00:39:16.533
Firebase Test Lab as 

00:39:17.785 --> 00:39:22.259
what we call a robotest.  We can
do much more.  

00:39:25.507 --> 00:39:27.345
Let's look at how we can create 
tests for all the different 

00:39:27.346 --> 00:39:30.343
parts of fitness bud.  

00:39:33.897 --> 00:39:35.897
So one of the first things that 
I as a 

00:39:36.969 --> 00:39:39.811
user of fitness bud wants to do 
is create my fitness avatar, 

00:39:39.812 --> 00:39:41.812
which 

00:39:42.874 --> 00:39:44.905
involving uploading my photo and
from that photo -- 

00:39:46.535 --> 00:39:49.979
there it is -- the app actually 
creates a caricature of me.  

00:39:53.964 --> 00:39:56.463
That seems to have emphasized 
all my worst flaws.   

00:40:01.088 --> 00:40:03.088
It then allows me to choose a 
focused activity.

00:40:04.356 --> 00:40:06.188
Weight training.  
&gt;&gt; RICHARD GAYWOOD:  Is that 

00:40:06.189 --> 00:40:11.469
really you up there, Justin?  
&gt;&gt; JUSTIN BROUGHTON:  It appears

00:40:11.470 --> 00:40:14.319
that my ears are not my worst 
flaw.  Vanity is.  

00:40:17.583 --> 00:40:19.824
Then I get to guide my 
excessively buffed avatar around

00:40:19.825 --> 00:40:21.825
the various gym 

00:40:23.100 --> 00:40:25.100
activities with all my equally 
unrealistic fitness buddies.

00:40:27.926 --> 00:40:29.926
Now all this avatar stuff is 
written 

00:40:31.205 --> 00:40:35.524
in OpenGL.  For a more immersive
and fun experience for the user.

00:40:36.335 --> 00:40:38.775
Previouslily it's been hard to 
test apps 

00:40:42.461 --> 00:40:44.305
and games which use OpenGL, but 
over the last year, we at Google

00:40:44.306 --> 00:40:46.306
have introduced 

00:40:47.768 --> 00:40:51.015
a couple of ways in which you 
can now do this more easily.  

00:40:51.016 --> 00:40:55.300
&gt;&gt; RICHARD GAYWOOD:  We 
introduced at I/O last year the 

00:40:55.301 --> 00:40:57.301
concept of demo loops that we 
discussed earlier, and 

00:40:58.565 --> 00:41:01.005
pre-launch report now runs demo 
loops in your apps and games if 

00:41:01.006 --> 00:41:03.648
you choose to include them.  
&gt;&gt; JUSTIN BROUGHTON:  Fitness 

00:41:03.649 --> 00:41:09.174
bud can construct demo loops for
all this avatar stuff by simply 

00:41:09.175 --> 00:41:11.175
recording and replaying their 
OpenGL commands.

00:41:15.124 --> 00:41:17.124
And then during testing they can

00:41:18.173 --> 00:41:20.173
verify that they don't see 
crashes or performance issues.

00:41:24.494 --> 00:41:26.494
Now, fitness bud can run these 
demo 

00:41:27.544 --> 00:41:29.999
loops locally on their devices 
using an app we created that's 

00:41:30.000 --> 00:41:32.655
freely available, but more 
importantly, they can run those 

00:41:35.702 --> 00:41:37.702
demo loops in Firebase Test Lab 
across a 

00:41:38.756 --> 00:41:40.991
wide array of devices. 

00:41:44.034 --> 00:41:45.928
Secondly, we announced at the 
games developer conference 

00:41:45.929 --> 00:41:47.929
earlier on this 

00:41:50.418 --> 00:41:52.418
year a collaboration with net 
ease to 

00:41:57.182 --> 00:42:00.366
create tests for games that run 
in Firebase Test Lab.  Net ease 

00:42:00.367 --> 00:42:02.367
is one of the largest games 

00:42:07.130 --> 00:42:09.130
development companies in China, 
and as 

00:42:11.169 --> 00:42:13.924
part of this collaboration, they
OpenSourced their test 

00:42:13.925 --> 00:42:15.925
environment, air test, along 
with a couple of frameworks 

00:42:19.494 --> 00:42:21.275
that they use internally for 
developing testing for their own

00:42:21.276 --> 00:42:22.910
games.  
You can download this testing 

00:42:22.911 --> 00:42:25.548
framework.  There is a link at 
the end.  

00:42:30.448 --> 00:42:33.078
With it you can create tests 
that add actions and assertions 

00:42:33.079 --> 00:42:35.079
that refer to game elements.

00:42:37.604 --> 00:42:39.604
So let's see how that works.

00:42:42.092 --> 00:42:44.322
So here's air test, and I'm just
going to select game elements 

00:42:44.323 --> 00:42:47.171
and add an action to touch a 
game element.

00:42:50.837 --> 00:42:53.491
I can wait for a game element to
exist, or I can assert that the 

00:42:53.492 --> 00:42:57.165
game element is visible.  It's 
that simple.  

00:43:02.045 --> 00:43:04.045
Like demo loops, these tests can
be run locally.  

00:43:05.111 --> 00:43:07.111
They can also be run in Firebase
Test 

00:43:08.974 --> 00:43:10.974
Lab across a wide array of 
devices.

00:43:14.757 --> 00:43:17.414
Now, here's the goal creation 
screen of fitness bud.  

00:43:19.650 --> 00:43:21.650
Now, my fitness goals are pretty
modest as you saw earlier.

00:43:24.534 --> 00:43:26.534
It's a good day if I don't fall 
off a treadmill.

00:43:30.057 --> 00:43:32.924
With this screen users get to 
create fitness goals and share 

00:43:32.925 --> 00:43:35.575
them with all of their fitness 
buddies.

00:43:40.897 --> 00:43:42.897
Now, obviously, fitness bud 
wants to 

00:43:45.771 --> 00:43:47.771
create tests that cover this 
part of the app as well.

00:43:51.489 --> 00:43:53.511
Now, typically this involves 
laboriously writing tests in one

00:43:53.512 --> 00:43:55.512
of the 

00:44:00.638 --> 00:44:02.692
many testing frameworks, such as
expresso or UI automater, and 

00:44:02.693 --> 00:44:04.693
then 

00:44:06.559 --> 00:44:08.559
keeping the tests updated as the
UI evolves.

00:44:08.998 --> 00:44:10.998
&gt;&gt; RICHARD GAYWOOD:  Let me 
quickly ask, 

00:44:12.251 --> 00:44:13.882
how many have had to rewrite 
dozens or hundreds of tests 

00:44:13.883 --> 00:44:15.930
because you made a small change 
in your app?  Right.  

00:44:17.345 --> 00:44:20.012
It's really painful, right?  
This happens to me, too.  This 

00:44:20.013 --> 00:44:23.263
is a really painful situation.  
&gt;&gt; JUSTIN BROUGHTON:  This is 

00:44:23.264 --> 00:44:25.264
the exact 

00:44:29.429 --> 00:44:31.429
reason why we built Espresso 
test recorder.

00:44:33.342 --> 00:44:35.398
He is express Seo test recorder 
is part of Android studio, and 

00:44:35.399 --> 00:44:40.496
with it you can quickly record 
he is express Seo tests by 

00:44:40.497 --> 00:44:42.497
simply interacting with your 

00:44:46.801 --> 00:44:48.801
device running your app locally.

00:44:50.500 --> 00:44:52.500
With it we create lots of tests 
that 

00:44:54.394 --> 00:44:56.394
cover the non-OpenGL parts of 
fitness bud.

00:44:57.866 --> 00:44:59.866
You can create them in JV or (?

00:45:02.559 --> 00:45:04.589
) But if your UI does change, 
you can go in and re-record the 

00:45:04.590 --> 00:45:08.104
tests.  Let's see how this 
works.  

00:45:09.527 --> 00:45:11.527
This is Android studio here.  

00:45:15.932 --> 00:45:17.196
I'm going to choose to record an
Espresso test.  I pick my local 

00:45:17.197 --> 00:45:19.197
pixel 2, which is running.

00:45:21.011 --> 00:45:21.612
Then compiles and installs my 
app and brings up this event 

00:45:21.613 --> 00:45:23.613
window.

00:45:25.271 --> 00:45:27.271
At this point I get to enter my 
name, 

00:45:29.539 --> 00:45:32.424
click on an avatar, and it 
records the events all there in 

00:45:32.425 --> 00:45:34.425
that window.  

00:45:37.342 --> 00:45:39.342
Next, I want to add an 
assertion.

00:45:42.086 --> 00:45:44.086
So adding an assertion involves 

00:45:48.742 --> 00:45:51.492
pulling a screenshot from the 
device so that I can select 

00:45:51.493 --> 00:45:54.134
elements in that screenshot on 
which I want to assert.

00:45:57.418 --> 00:45:58.858
I'll do that, click on an 
element, and then I'm going to 

00:45:58.859 --> 00:46:00.859
click okay.

00:46:05.208 --> 00:46:07.208
I get to choose JV  Java or 
Kotlin.

00:46:08.864 --> 00:46:11.316
I choose Kotlin and click okay, 
and there's any Kotlin test 

00:46:11.317 --> 00:46:13.559
class.  It's that simple.  

00:46:16.605 --> 00:46:18.240
With Espresso test recorder, you
can modularize your testing.  

00:46:18.241 --> 00:46:22.513
You can create test snippets for
the commonly used functions in 

00:46:22.514 --> 00:46:24.514
all your 

00:46:26.006 --> 00:46:28.006
tests, such as logging in or 
filling out a search form.

00:46:30.101 --> 00:46:32.101
So with all that free time, all 
those 

00:46:35.210 --> 00:46:37.210
excuses for not going to the gym
simply evaporate.

00:46:39.334 --> 00:46:41.334
So now fitness bud has a battery
of 

00:46:46.462 --> 00:46:50.662
tests, and all they have to do 
is add them to their continuous 

00:46:46.462 --> 00:46:48.462
integration system.

00:46:49.551 --> 00:46:51.593
Now every time they make a 
change they can be much more 

00:46:51.594 --> 00:46:56.911
confident -- this is the beauty 
-- that it did not break the app

00:46:56.912 --> 00:46:58.541
in some obscure way.  
&gt;&gt; RICHARD GAYWOOD:  Speaking as

00:46:58.542 --> 00:47:00.581
a developer myself, peace of 
mind like that is honestly 

00:47:00.582 --> 00:47:07.532
priceless.   
&gt;&gt; JUSTIN BROUGHTON:  But 

00:47:07.533 --> 00:47:12.850
fitness bud has to run on the 
myriad of devices that people 

00:47:12.851 --> 00:47:14.851
drag to the gym.

00:47:15.919 --> 00:47:18.563
How do they make sure that the 
app runs well on all those 

00:47:18.564 --> 00:47:22.459
devices?  
Well, they could buy a whole 

00:47:22.460 --> 00:47:27.427
bunch of devices, hook them up 
to a workstation, and stick them

00:47:27.428 --> 00:47:29.428
in a closet somewhere.

00:47:32.348 --> 00:47:34.348
Fitness bud's closet is full of 
gym 

00:47:37.448 --> 00:47:39.448
bags because they practice what 
they preach.

00:47:41.776 --> 00:47:43.597
Maintaining a device closet is a
really hard activity.  Trust me 

00:47:43.598 --> 00:47:47.048
on this.  
Not only do you have to keep the

00:47:47.049 --> 00:47:49.049
devices 

00:47:50.107 --> 00:47:52.107
online and updated, but you also
have to 

00:47:55.428 --> 00:47:57.457
procure new ones as the old ones
die or explode, and fresh ones 

00:47:57.458 --> 00:48:02.378
come out onto the market.  
Fitness bud would much rather be

00:48:02.379 --> 00:48:04.379
cussing 

00:48:08.087 --> 00:48:09.697
code or pumping iron, so what's 
the alternative?  

00:48:09.698 --> 00:48:12.369
&gt;&gt; RICHARD GAYWOOD:  Justin and 
I described how pre-launch 

00:48:12.370 --> 00:48:14.425
report offers free crawler 
testing on about ten 

00:48:18.715 --> 00:48:20.963
devices to every APK that 
fitness bud uploads.  You can go

00:48:20.964 --> 00:48:23.834
much further with the Firebase 
Test Lab using a broad array of 

00:48:27.103 --> 00:48:29.103
devices covering screen sizes, 
Android 

00:48:30.565 --> 00:48:32.565
API versions and different OEMs 
and chip sets.  

00:48:32.999 --> 00:48:35.643
&gt;&gt; RICHARD GAYWOOD:  To 
illustrate this we recently 

00:48:35.644 --> 00:48:39.944
added prerelease P devices that 
you can now all test on.  What 

00:48:39.945 --> 00:48:41.945
I'm most excited today to 

00:48:43.202 --> 00:48:45.202
announce -- wait for it -- is 
our new support for iOS.

00:48:48.100 --> 00:48:50.125
It was already up there.  You 
already knew.  

00:48:52.160 --> 00:48:55.214
So you can sign up for a beta 
through the Firebase console.  

00:48:55.215 --> 00:49:02.136
There's a link at the end.  
Fightness bud is a global 

00:49:02.137 --> 00:49:04.137
application.

00:49:06.407 --> 00:49:08.407
As such, it needs to be tested 
on a 

00:49:09.651 --> 00:49:11.651
whole bunch of different 
languages.

00:49:14.979 --> 00:49:17.257
Both FirebaseFirebase Test Lab 
and the play console allow you 

00:49:17.258 --> 00:49:19.258
to do just that 

00:49:22.544 --> 00:49:24.544
with Firebase Test Lab, you can 
run your 

00:49:27.810 --> 00:49:29.499
tests on any locale you wish, 
and pre-launch report recommends

00:49:29.500 --> 00:49:31.500
the most 

00:49:33.576 --> 00:49:35.576
popular languages amongst your 
users.  

00:49:40.514 --> 00:49:42.339
So now there should be no reason
for fitness bud to waste all 

00:49:42.340 --> 00:49:44.340
that time and 

00:49:45.807 --> 00:49:47.640
energy maintaining a device 
closet which gives them even 

00:49:47.641 --> 00:49:49.641
more time to spend at the gym.

00:49:51.119 --> 00:49:53.119
It's kind of a wonder they get 
any coding done, actually.  

00:49:57.915 --> 00:49:59.351
HRZ like  Like in the pre-launch
report, Firebase Test Lab also 

00:49:59.352 --> 00:50:03.616
gives you comprehensive test 
results like crashes and A and 

00:50:03.617 --> 00:50:05.617
Rs.

00:50:06.695 --> 00:50:08.695
Video and screenshots, logs, 

00:50:10.401 --> 00:50:13.095
performance metrics, and a map 
of the activities the crawler 

00:50:13.096 --> 00:50:15.096
found.  

00:50:17.579 --> 00:50:19.579
The video and screenshots are 
especially 

00:50:21.476 --> 00:50:23.476
important to help fitness bud 
verify 

00:50:25.136 --> 00:50:27.136
that their app looks good and 
runs well 

00:50:28.206 --> 00:50:30.206
across all those screen sizes.

00:50:33.294 --> 00:50:37.227
Fitness Bud verify that their 
app looks good and runs well 

00:50:33.294 --> 00:50:35.294
across all those screen sizes.  

00:50:38.400 --> 00:50:40.400
Let's look at how easy it is to 
quickly 

00:50:42.327 --> 00:50:44.327
run a test in the Firebase 
console.  

00:50:44.979 --> 00:50:46.819
Firstly, I want to quickly point
on your iOS support, there it 

00:50:46.820 --> 00:50:50.318
is.  You can't dismiss that 
coach mark, but it's there.  

00:50:50.319 --> 00:50:55.051
We're going to run a robotest.  
Robotest is the simplest of 

00:50:55.052 --> 00:51:00.349
tests.  All it requires is that 
you give us your app.  Now, I'm 

00:51:00.350 --> 00:51:02.601
going to quickly choose an app 
at random from my hard disk 

00:51:02.602 --> 00:51:04.675
there and upload it.  

00:51:07.761 --> 00:51:10.634
While it's uploading, you'll 
note we can also upload a 

00:51:10.635 --> 00:51:13.897
roboscript, which we won't do 
here.  Now I choose any devices 

00:51:13.898 --> 00:51:16.750
from the many devices.  Some are
deprecated, which means they 

00:51:19.200 --> 00:51:21.200
exploded and we can no longer 
procure them.

00:51:22.464 --> 00:51:24.496
I'm going to go with the default
two devices, but I want to add 

00:51:24.497 --> 00:51:26.497
some locales. 

00:51:28.358 --> 00:51:30.358
I'm going to add Chinese.

00:51:32.883 --> 00:51:34.883
I'm going to add Arabic when I 
get there.

00:51:38.229 --> 00:51:40.229
And then lastly I'm going to add
Spanish.  

00:51:43.002 --> 00:51:44.843
Then I'm going to fix the 
locales because I really only 

00:51:44.844 --> 00:51:46.844
care about 

00:51:48.549 --> 00:51:49.758
portrait mode, and then fix the 
locales, please.  

00:51:49.759 --> 00:51:51.759
There we go.  There we start a 
test.

00:51:58.126 --> 00:52:00.126
An eight test because it's two 
devices against four locales.

00:52:04.653 --> 00:52:06.515
In the background it willal  -- 
allocate eight devices and 

00:52:06.516 --> 00:52:08.516
figure those 

00:52:09.601 --> 00:52:11.601
devices setting the locale, the 
orientation.

00:52:14.478 --> 00:52:16.478
It will then install my app on 
all 

00:52:18.782 --> 00:52:21.011
those devices, and then it will 
run a five-minute robotest, 

00:52:21.012 --> 00:52:23.012
which will take five minutes.

00:52:27.609 --> 00:52:29.609
So -- oh.  Thank God it's done. 

00:52:31.498 --> 00:52:35.298
All right.  There we go.  I'm 
going to pick the first of 

00:52:31.498 --> 00:52:33.498
these.  You see we have logs.  
We have screenshots.

00:52:36.450 --> 00:52:38.340
We have an activity map, which 
is a map of the activities we 

00:52:38.341 --> 00:52:40.341
visited.  You have performance 
information, 

00:52:41.430 --> 00:52:42.657
which is tied to the video, so 
you can see what's happening in 

00:52:42.658 --> 00:52:47.295
your app at the time of the CPU 
spikes or the frames per second 

00:52:47.296 --> 00:52:49.296
drops.

00:52:57.282 --> 00:52:59.282
You can find instructions on the
webs 

00:53:00.552 --> 00:53:03.464
and documentation site for how 
to hook test lab up to many 

00:53:03.465 --> 00:53:08.788
common, continuous integration 
systems like Jenkins or circle 

00:53:08.789 --> 00:53:12.052
CI or team city.  
We have a number of customers 

00:53:12.053 --> 00:53:14.084
who are doing exactly this.  

00:53:18.634 --> 00:53:20.634
Testing their app multiple times
a day.

00:53:23.128 --> 00:53:25.128
Test lab is helping them find 
problems 

00:53:26.989 --> 00:53:28.989
way before they end up affecting
their users.  

00:53:31.524 --> 00:53:37.288
And best of all, you can get 
started for free!  With our 

00:53:37.289 --> 00:53:39.289
spark billing tier.

00:53:41.007 --> 00:53:44.274
So it's really that simple.  
&gt;&gt; RICHARD GAYWOOD:  Justin and 

00:53:44.275 --> 00:53:47.328
I hope our talk today gives you 
renewed inspiration for your 

00:53:47.329 --> 00:53:50.812
testing strategy.  It doesn't 
have to be difficult to test 

00:53:50.813 --> 00:53:52.813
comprehensively.

00:53:53.874 --> 00:53:54.693
Let the pre-launch report and 
the Google Play Console Google 

00:53:54.694 --> 00:53:56.694
Play Console 

00:53:59.376 --> 00:54:00.447
help you discover crashes, 
performance issues, security 

00:54:00.448 --> 00:54:02.448
vulnerabilities and 

00:54:04.507 --> 00:54:06.131
soon accessibility warnings with
SFWLER configuration required 

00:54:06.132 --> 00:54:08.132
from you.

00:54:09.617 --> 00:54:11.617
Publish an APD to the open and 
closed 

00:54:13.899 --> 00:54:15.914
testing tracks, and the report 
will be generated for you.  You 

00:54:15.915 --> 00:54:17.753
can go further to the auto 
generated reports with custom 

00:54:17.754 --> 00:54:20.223
log in credentials, roboscripts,
deep linking 

00:54:23.283 --> 00:54:25.283
and demo loops to help us test 
your app better.  

00:54:25.528 --> 00:54:26.966
&gt;&gt; JUSTIN BROUGHTON:  If you 
want to test maybe more often 

00:54:26.967 --> 00:54:30.418
and comprehensively, look at 
Firebase Test Lab, which in 

00:54:30.419 --> 00:54:32.419
addition to the features 

00:54:33.675 --> 00:54:35.926
Richard just mentioned, also 
allows you to create and run 

00:54:35.927 --> 00:54:37.927
your own tests.

00:54:40.000 --> 00:54:42.468
So take a picture of this if you
wish.  You have a couple of 

00:54:42.469 --> 00:54:44.303
seconds to do that.
I think most people have already

00:54:44.304 --> 00:54:46.774
done that.  
&gt;&gt; RICHARD GAYWOOD:  We'd really

00:54:46.775 --> 00:54:51.082
love to hear more for you, so if
you have XHEPTs or suggests use 

00:54:51.083 --> 00:54:53.113
the link in the I/O app or come 
and find us in person after the 

00:54:53.114 --> 00:54:55.371
talk.  

00:54:58.585 --> 00:55:01.055
( Applause )  
&gt;&gt; JUSTIN BROUGHTON:  Of course,

00:55:01.056 --> 00:55:05.177
we really want to thank all of 
you're users, both big and 

00:55:05.178 --> 00:55:06.813
small.  
&gt;&gt; RICHARD GAYWOOD:  And also to

00:55:06.814 --> 00:55:08.814
all of 

00:55:10.325 --> 00:55:12.783
you, many thanks for joining us 
at this punishing early hour.  

00:55:12.784 --> 00:55:14.416
We really understand, obviously,
that the big party was last 

00:55:14.417 --> 00:55:18.969
night.  We have a few minutes 
left if anyone has questions or 

00:55:18.970 --> 00:55:23.255
we can take them privately as 
well afterwards.   Okay.  Thank 

00:55:23.256 --> 00:55:24.879
you very much.  
&gt;&gt; JUSTIN BROUGHTON:  Thank you.

00:55:27.889 --> 00:55:29.889
( Applause ) 

00:55:34.459 --> 00:55:41.821
( Session concluded ) 
 .  .  .   

00:55:41.822 --> 00:55:44.017
.  
.  

00:55:44.465 --> 00:55:46.514
: 
&gt;&gt; Thank you for joining this 

00:55:46.515 --> 00:55:48.515
session.

00:55:49.569 --> 00:55:51.849
Grand Am bass DORs will assist 
with directing you through the 

00:55:51.850 --> 00:55:53.850
designated exits.  
We will make room for those that

00:55:54.527 --> 00:55:56.768
registered for the next session.
If you registered for the next 

00:55:56.769 --> 00:56:01.656
session in this room, please 
clear the room and return via 

00:56:01.657 --> 00:56:03.657
the registration line outside.  
Thank you.

00:56:19.485 --> 00:56:22.127
.  
.  

00:56:22.549 --> 00:56:23.594
: 
.  

00:56:23.595 --> 00:56:25.595
.  

01:05:32.645 --> 01:05:34.645
.  

01:05:42.855 --> 01:05:45.533
Build reactive mobile apps with 
Flutter  

01:23:17.180 --> 01:23:19.623
&gt;&gt; FILIP HRACEK:  Morning and 
welcome to 

01:23:26.505 --> 01:23:28.505
the build react apps with

01:23:30.081 --> 01:23:33.136
Flutter.  
&gt;&gt; &gt;&gt; MATT SULLIVAN:  Flutter 

01:23:33.137 --> 01:23:35.137
lets you build beautiful apps.  

01:23:38.242 --> 01:23:40.490
It gives you the ability to 
create fluid and customized 

01:23:40.491 --> 01:23:42.491
sophisticated UIs.

01:23:43.568 --> 01:23:45.568
There's a few examples to show 
you the 

01:23:46.671 --> 01:23:48.780
different range and types of 
apps to build with Flutter.

01:23:51.811 --> 01:23:54.927
At the heart of Flutter's UI is 
a powerful reactive model.  I'll

01:23:54.928 --> 01:23:56.928
give you the 30-second summary 

01:23:59.024 --> 01:24:01.024
how it works and then we deep 
dive into things.

01:24:02.073 --> 01:24:03.695
In Flutter all UI components are
widget.  

01:24:03.696 --> 01:24:05.696
We have a widget that's a 
button.

01:24:08.609 --> 01:24:10.609
Secondly, you take these widgets
and 

01:24:12.489 --> 01:24:14.489
compose them together to create 
complex UIs. 

01:24:17.324 --> 01:24:19.324
We refer to the

01:24:24.565 --> 01:24:27.009
widgetary and they also rebuild 
it when the state changes can it

01:24:27.010 --> 01:24:29.010
relieves you of doing the task.

01:24:30.732 --> 01:24:32.732
When we call set state on the 
greeting 

01:24:34.866 --> 01:24:35.696
widget, it's going to 
automatically redraw itself.  

01:24:35.697 --> 01:24:39.761
That's great and wonderful, but 
building complex apps is never 

01:24:39.762 --> 01:24:43.412
easy.  Apps typically have 
thousands of UI components, but 

01:24:43.413 --> 01:24:45.413
they have very 

01:24:47.083 --> 01:24:49.948
complicated and potentially 
sophisticated state reacting 

01:24:49.949 --> 01:24:51.949
with UI 

01:24:53.396 --> 01:24:56.863
components at various different 
times in the app.  The good news

01:24:56.864 --> 01:24:58.864
that Flutter provides 

01:25:00.974 --> 01:25:02.974
all the tools necessary not only
to 

01:25:04.651 --> 01:25:07.302
build UI but handle complex 
Dataflow and stay in your app 

01:25:07.303 --> 01:25:09.303
that fits in elegantly 

01:25:10.813 --> 01:25:12.813
well with Flutter's reactive 
model for buildings UIs.  

01:25:14.702 --> 01:25:17.044
Flutter's UI patterns are 
well-known and well documented, 

01:25:17.045 --> 01:25:19.716
but the reactive strategies to 
handle state not so well-known. 

01:25:24.784 --> 01:25:27.039
So we're going to focus the talk
on how to do that.  We take you 

01:25:27.040 --> 01:25:29.040
on a journey.  

01:25:31.953 --> 01:25:34.226
We look at the foundations of 
Flutter and State so show you 

01:25:34.227 --> 01:25:36.227
the basis of how it works.

01:25:39.311 --> 01:25:40.535
We explore how State and the 
weed jetary can be married 

01:25:40.536 --> 01:25:44.439
today.  
How you can use Flutter streams 

01:25:44.440 --> 01:25:46.440
to elegantly manage State in 
your app.

01:25:49.367 --> 01:25:50.591
In each we do live coding and 
clearly nothing is good or 

01:25:50.592 --> 01:25:55.677
wrong.  We do some live coding, 
and these examples will be 

01:25:55.678 --> 01:25:57.678
relatively simple, but 

01:25:58.732 --> 01:26:00.732
we want you to keep in MIENDZ 
how 

01:26:01.995 --> 01:26:04.247
they're scaled out to larger 
apps and importantly the 

01:26:04.248 --> 01:26:06.293
examples here have been derived 
from production apps built with 

01:26:11.054 --> 01:26:13.054
Flutter both by Google and by 
other partparties.  

01:26:14.926 --> 01:26:17.799
So let's dive in and look at 
managing State in the simply app

01:26:17.800 --> 01:26:22.074
we can think is, which is the 
incrementer app, which is what 

01:26:22.075 --> 01:26:24.546
you get out of the box when you 
do Flutter create.  The reactive

01:26:24.547 --> 01:26:27.022
model is straightforward for UI 
and State, but it's a little 

01:26:29.070 --> 01:26:30.292
different to how things are 
handled with Android and iOS.  

01:26:30.293 --> 01:26:32.526
We're going to dive in by 
looking at 

01:26:36.018 --> 01:26:38.268
this app, and we look at a 
common pitfall that typically 

01:26:38.269 --> 01:26:40.323
catches peel out when they 
initially start to think about 

01:26:42.568 --> 01:26:44.568
reactive systems in general.

01:26:47.070 --> 01:26:48.916
Filip.  
&gt;&gt; FILIP HRACEK:  This is an 

01:26:48.917 --> 01:26:53.213
exciting moment because I break 
an app on stage at I/O.  That's 

01:26:53.214 --> 01:26:55.903
exactly the opposite of what you
normally want to do on stage.  

01:26:55.904 --> 01:27:01.493
This is in the name of learning 
and science.  So it's okay.

01:27:04.126 --> 01:27:06.001
So if you're not familiar with 
this app, this app is very 

01:27:06.002 --> 01:27:08.002
exciting.

01:27:10.288 --> 01:27:12.322
It shows you a number, and it 
lets you increment that number.

01:27:18.276 --> 01:27:21.182
The important parts are there's 
the (?) And there's the built 

01:27:21.183 --> 01:27:25.873
method that creates the UI.  
Here's the widget that shows 

01:27:25.874 --> 01:27:30.395
that number, number 4 right now,
and here's the floating action 

01:27:30.396 --> 01:27:33.876
bottom, which is this guy over 
here, which lets you change that

01:27:33.877 --> 01:27:37.590
variable.  
Now, imagine that this was a 

01:27:37.591 --> 01:27:42.329
much bigger app, and we wanted 
to put them all a little more 

01:27:42.330 --> 01:27:44.330
structured to it.

01:27:46.416 --> 01:27:48.416
We would do that often by 
extracting 

01:27:55.425 --> 01:27:57.425
parts of the built method into 
its own widget, right?

01:28:01.432 --> 01:28:03.432
So I'm going to do just that.

01:28:07.453 --> 01:28:09.453
I'm going to take this out, 
create a 

01:28:10.569 --> 01:28:12.649
new widget called incrementer, 
and I'm just going to paste the 

01:28:12.650 --> 01:28:13.661
code over here, right?  
So we're not done.  As you can 

01:28:13.662 --> 01:28:14.492
see, there's red, squiggly lines
over there, which means we have 

01:28:14.493 --> 01:28:16.493
a problem.

01:28:17.758 --> 01:28:19.410
The problem is that we cannot 
actually access the 

01:28:19.411 --> 01:28:21.411
countervariable from here, 

01:28:23.077 --> 01:28:24.287
because we're in this class 
while the countervariable is in 

01:28:24.288 --> 01:28:26.288
this class.  
All right?

01:28:28.970 --> 01:28:30.992
There are many ways to solve 
this problem, but I have 

01:28:30.993 --> 01:28:32.993
something very special in mind.

01:28:37.961 --> 01:28:39.961
I'm just going to make the 
variable global, because I can.

01:28:42.444 --> 01:28:45.925
So there you have it, folks.  
&gt;&gt; MATT SULLIVAN:  To handle 

01:28:45.926 --> 01:28:49.806
State and Flutter, you make it 
global, right?  

01:28:50.223 --> 01:28:54.291
&gt;&gt; FILIP HRACEK:  No.  We try to
make the point here and try and 

01:28:54.292 --> 01:28:55.925
break this app, so please don't 
make your variables global.  

01:28:59.411 --> 01:29:01.039
We're going to fix this in two 
minutes.  You know, stay with 

01:29:01.040 --> 01:29:03.040
us.  

01:29:06.197 --> 01:29:08.640
So we have -- we fix the 
squiggly lines, so let's see if 

01:29:08.641 --> 01:29:10.641
this app actually works now.  It
doesn't.

01:29:13.561 --> 01:29:15.561
Now, why is that?

01:29:19.526 --> 01:29:20.967
We can add a thing here to see 
if the countervariable has 

01:29:20.968 --> 01:29:22.968
actually changed, and we see 
that it is. 

01:29:23.397 --> 01:29:25.397
It's now at 12.

01:29:26.831 --> 01:29:29.938
The user doesn't see it.  Why is
that?  

01:29:33.416 --> 01:29:35.416
The reason is we call said state
in the wrong widget.

01:29:37.915 --> 01:29:39.945
We break the contract of set 
state, which is that you call 

01:29:39.946 --> 01:29:44.443
set state when you're changing 
the state of the widget.  We're 

01:29:44.444 --> 01:29:47.709
want changing the state of the 
floating action button here.  

01:29:47.710 --> 01:29:50.761
We're changing the state of the 
widget above it, all right?  

01:29:53.838 --> 01:29:55.883
And that way Flutter doesn't 
know -- Flutter tries to rebuild

01:29:55.884 --> 01:29:59.160
that floating action button, but
that doesn't do anything with 

01:29:59.161 --> 01:30:04.464
our text over here, is I'm going
to fix it now.  

01:30:06.306 --> 01:30:07.323
&gt;&gt; MATT SULLIVAN:  We need to 
move set state in the 

01:30:07.324 --> 01:30:08.938
appropriate widget where we want
to show the change or the 

01:30:08.939 --> 01:30:10.939
mutation of the state.

01:30:14.693 --> 01:30:17.579
So Filip will move it back into 
the home page widget, and 

01:30:17.580 --> 01:30:19.628
thankfully we tonight have 
global state any longer.  

01:30:19.629 --> 01:30:22.718
Wonderful.  
So what we're going to do then 

01:30:22.719 --> 01:30:25.371
is what we need to do.  We need 
to pass down a reference to 

01:30:29.499 --> 01:30:31.499
that function so it can be 
called by the child widget.

01:30:33.985 --> 01:30:36.020
We update the incrementer widget
and past through the function 

01:30:36.021 --> 01:30:38.021
through the constructor.

01:30:39.722 --> 01:30:41.765
This gives us a classic 
call-back method of being able 

01:30:41.766 --> 01:30:45.642
to call the function in the 
parent widget, and that should 

01:30:45.643 --> 01:30:47.643
probably just work.

01:30:49.139 --> 01:30:53.223
&gt;&gt; FILIP HRACEK:  It works!  
Awesome.  Back to the slides, 

01:30:53.224 --> 01:30:55.281
please.  
So that was great and it was 

01:30:55.282 --> 01:30:57.943
pretty easy to fix, but you can 
imagine that if you 

01:31:01.399 --> 01:31:02.838
have a much larger app with a 
lot more widgets, this could be 

01:31:02.839 --> 01:31:04.839
a problem.

01:31:07.310 --> 01:31:09.789
Let's imagine that you have -- 
you need state over here and you

01:31:09.790 --> 01:31:11.790
have state 

01:31:13.277 --> 01:31:15.920
somewhere over here, and now 
what you need to do if you 

01:31:15.921 --> 01:31:17.973
follow that pattern I just 
showed you, you need to pass 

01:31:17.974 --> 01:31:22.469
down the State down the widget 
tree.  That means that all the 

01:31:22.470 --> 01:31:27.777
widgets that are in the path 
need to know about this state, 

01:31:27.778 --> 01:31:29.778
even though they don't really 
care.

01:31:31.050 --> 01:31:33.083
And that breaks re-use and 
breaks separation of concerns, 

01:31:33.084 --> 01:31:35.567
and it also potentially makes 
the app rebuild much 

01:31:38.628 --> 01:31:40.628
larger portions of this state or
of the UI that you would want.

01:31:44.974 --> 01:31:46.974
You only want the leaf notes to 
be rebuilt.  

01:31:50.314 --> 01:31:52.314
So I've hopefully highlighted 
two 

01:31:54.947 --> 01:31:57.292
problems here or two challenges 
here.  First, how do I access 

01:31:57.293 --> 01:31:59.276
state that doesn't necessarily 
live in the widget where I need 

01:31:59.277 --> 01:32:01.277
it?

01:32:02.963 --> 01:32:04.995
Second, how do I notify other 
widgets that they should 

01:32:04.996 --> 01:32:07.251
rebuild?  I'm going to --

01:32:10.743 --> 01:32:13.192
again, I'm going to score this 
pattern that I just showed you 

01:32:13.193 --> 01:32:18.536
with a thumbs-down on both 
accounts, because while it is 

01:32:18.537 --> 01:32:20.537
easy in a simple app, in a 

01:32:22.236 --> 01:32:24.236
big app it gets more 
complicated.  

01:32:26.112 --> 01:32:27.329
I think we have a better option 
here.  

01:32:27.330 --> 01:32:29.655
&gt;&gt; MATT SULLIVAN:  Okay.  So 
let's look at how we can handle 

01:32:32.308 --> 01:32:34.141
state and the concept of passing
State up and down the widget 

01:32:34.142 --> 01:32:38.862
tree without having to expose it
to all the widgets in between 

01:32:38.863 --> 01:32:41.711
that don't need to use it.  So 
Flutter has out of the box what 

01:32:41.712 --> 01:32:43.712
is 

01:32:46.011 --> 01:32:48.865
called an inherited widget, and 
what an inherited widget does is

01:32:48.866 --> 01:32:50.866
holds state and 

01:32:52.992 --> 01:32:54.869
it allows you to propagate that 
state efficiently down the 

01:32:54.870 --> 01:32:56.870
widget tree.

01:32:58.136 --> 01:33:00.020
It will rebuild that widget tree
when that state -- when that 

01:33:00.021 --> 01:33:02.479
state is mute at a timed or that
state changes.  That sounds 

01:33:02.480 --> 01:33:03.917
promising.
They might help to solve this.  

01:33:03.918 --> 01:33:08.223
What does this look like?  You 
have an inherited widget.  We 

01:33:08.224 --> 01:33:12.501
put it in here.  As opposed to 
having the passed down REFRNTSs 

01:33:12.502 --> 01:33:14.502
to, we can use the build 

01:33:15.581 --> 01:33:18.227
context in any of the build 
methods to get an access to the 

01:33:18.228 --> 01:33:20.228
instance of ha state and use it 
directly Warren Jeffs 

01:33:24.478 --> 01:33:26.478
the -- within the widgets 
themselves.

01:33:28.346 --> 01:33:30.346
Here I have my cleverly named my
inherited widgets which extends.

01:33:32.615 --> 01:33:34.851
In here you see I have placed 
some state.  Perfect.  How do I 

01:33:34.852 --> 01:33:36.852
access that?

01:33:38.724 --> 01:33:41.372
Well, I can access it by firstly
placing my inherited widget into

01:33:41.373 --> 01:33:43.373
my 

01:33:45.513 --> 01:33:47.966
tree, gives it some state, and 
then building the widget tree 

01:33:47.967 --> 01:33:49.967
beneath that.

01:33:51.250 --> 01:33:53.507
After that I access it by using 
the build context to get a 

01:33:53.508 --> 01:33:57.008
reference to that widget and 
access the state.  That sounds 

01:33:57.009 --> 01:34:00.890
promising.  That's good.  Sure 
now I can access the state 

01:34:03.987 --> 01:34:08.072
anywhere in the tree and keep 
the rest of the code dry.  My 

01:34:08.073 --> 01:34:10.339
tree rebuilds the state changes,
so that's okay.  As you notice, 

01:34:10.340 --> 01:34:14.430
my state was final.  That's not 
very helpful if you actually 

01:34:14.431 --> 01:34:17.280
want to mutate your state.  
Now, it's not hard to layer in 

01:34:17.281 --> 01:34:20.557
mutation with inherited widget. 
It's a bit of boiler plate.  

01:34:24.063 --> 01:34:26.936
What we do is look at a library 
called scope model, and it's an 

01:34:26.937 --> 01:34:31.851
external package built on top of
inherited widget and it gives us

01:34:31.852 --> 01:34:33.852
access and more fine-grained way
of rebuilding parts of 

01:34:37.171 --> 01:34:39.171
our tree, and it allows us to 
mutate state as well.

01:34:42.275 --> 01:34:45.154
So lacking looking at code real 
quick, scope model equates to 

01:34:45.155 --> 01:34:47.155
the inherited 

01:34:49.679 --> 01:34:50.692
widget and it has a descend DANT
that gives us access to the 

01:34:50.693 --> 01:34:53.595
state.  
I want to show it in real code 

01:34:53.596 --> 01:34:55.638
to show it working, but I don't 
want to show it 

01:34:58.682 --> 01:35:00.682
in the incrementer app, because 
that's pretty simple.

01:35:02.515 --> 01:35:05.207
Filip and I knocked up a 
shopping cart example.  It has 

01:35:05.208 --> 01:35:07.920
three areas where you need to 
handle your state.  We got a 

01:35:07.921 --> 01:35:09.921
cart page, which shows the list 
of items.  

01:35:10.973 --> 01:35:12.598
We have a cart button, which 
shows the number of items in the

01:35:12.599 --> 01:35:15.274
cart and we have a grid of 
products where each product is 

01:35:17.704 --> 01:35:19.704
tapable and should add something
to the cart.  

01:35:21.802 --> 01:35:23.802
So let's jump over to my laptop.

01:35:29.980 --> 01:35:34.301
Let's take a look at this.  
Perfect.  Okay.  Here we have 

01:35:34.302 --> 01:35:36.755
the app, which is already 
running.  You can see I have a 

01:35:36.756 --> 01:35:40.067
grid of products, and at the 
moment it's showing a snack bar 

01:35:40.068 --> 01:35:44.543
at the bottom.  We have my cart 
button, which is hard-coated to 

01:35:44.544 --> 01:35:46.223
show zero, and we have a cart 
page which currently is showing 

01:35:46.224 --> 01:35:49.693
empty.  There is no state 
anywhere in here at the moment. 

01:35:49.694 --> 01:35:53.748
These are all stateless widgets 
and just looks pretty if you 

01:35:53.749 --> 01:35:55.749
consider this to be pretty.  

01:35:57.226 --> 01:35:58.633
We're not designers, but there 
you go.  

01:35:58.634 --> 01:36:00.634
What do we need to do?

01:36:01.736 --> 01:36:03.375
First, we need to define our 
model.  So I have created a cart

01:36:03.376 --> 01:36:05.376
model.

01:36:08.264 --> 01:36:09.485
It extepid the model and it has 
a cart object holding our state.

01:36:09.486 --> 01:36:13.587
We have three different ways to 
interact with this.  We have a 

01:36:13.588 --> 01:36:15.832
getter to pull down the list of 
cart items and we have item 

01:36:15.833 --> 01:36:20.970
count, which gives us the number
of items in the cart, and 

01:36:20.971 --> 01:36:22.971
strangely enough we have 

01:36:24.054 --> 01:36:25.882
an add method or function that 
allows us to place a product in 

01:36:25.883 --> 01:36:27.883
the cart.  

01:36:29.377 --> 01:36:31.040
Notice here when I mutate or 
change the state, I call 

01:36:31.041 --> 01:36:33.120
notified listeners.  The way 
scope model works is when you 

01:36:38.268 --> 01:36:40.306
have a decent dent widget, they 
observe your state and listen 

01:36:40.307 --> 01:36:44.995
for changes.  When it changes we
call notify listeners and all of

01:36:44.996 --> 01:36:47.440
those widgets are notified that 
stages change and they will 

01:36:47.441 --> 01:36:51.700
rebuild.  So the whole tree is 
not being rebuilt, only those 

01:36:51.701 --> 01:36:54.404
widgets that are listening to it
and the things below them will 

01:36:54.405 --> 01:36:56.405
be rebuilt.  Perfect.  

01:36:58.713 --> 01:37:00.127
So let's see how I can use that 
model to inject some state to my

01:37:00.128 --> 01:37:04.632
app.  So what I'm going to do is
I'm simply going to place my 

01:37:04.633 --> 01:37:08.703
state at the top-most level of 
app to begin with.  What I do is

01:37:08.704 --> 01:37:10.704
I'm going to wrap this in 

01:37:11.963 --> 01:37:13.963
a new widget, and it is going to
be a scope model.

01:37:16.035 --> 01:37:18.035
As we can see here, it takes a 
model 

01:37:19.522 --> 01:37:21.812
and a child, so we can keep this
sub tree as a child, and I can 

01:37:21.813 --> 01:37:23.813
place a model.

01:37:27.131 --> 01:37:29.999
I create a new instance of cat 
-- no cart model.  Now I have 

01:37:30.000 --> 01:37:32.000
state existing at the top of the
tree.

01:37:32.847 --> 01:37:35.083
I need to access that state.  
How do I do it?  

01:37:35.694 --> 01:37:38.201
Look at the button.  You see at 
the moment it's hard coded to 

01:37:38.202 --> 01:37:42.878
show zero.  What I do is I'm 
going to follow the same type of

01:37:42.879 --> 01:37:44.879
pattern and wrap this in a 

01:37:46.959 --> 01:37:49.625
new widget, and this time I'm 
going to use a descendant 

01:37:49.626 --> 01:37:53.893
widget.  I type it so IT what 
type of model to look for, and 

01:37:53.894 --> 01:37:56.132
this doesn't take a child.  It 
takes a builder, which will 

01:37:56.133 --> 01:37:59.040
provide me with the model.  So 
I'm going to change my child to 

01:38:01.281 --> 01:38:03.944
builder, and this is a function.
I need the build context because

01:38:03.945 --> 01:38:05.945
that's 

01:38:10.746 --> 01:38:14.010
how inherited widget finds the 
-- or gets a reference to it.  

01:38:14.011 --> 01:38:15.053
We have an optional child, which
I don't use, and we have a 

01:38:15.054 --> 01:38:17.495
model.  Great what can I do now?

01:38:21.154 --> 01:38:24.067
I should be able to simply do 
model.item count.  Perfect.  We 

01:38:24.068 --> 01:38:27.316
have to do one more thing to get
it to work.  We have to add 

01:38:27.317 --> 01:38:31.206
products.  I'm going to do it 
super quick.  Here we have the 

01:38:31.207 --> 01:38:33.207
grid and individual products, 
and again, I follow the same 

01:38:37.365 --> 01:38:38.596
pattern and wrap this in a 
descendant widget.  I'm going to

01:38:38.597 --> 01:38:42.662
type it.  I'm going to do that 
properly.  Then, again, I'm 

01:38:42.663 --> 01:38:44.663
going to change this 

01:38:46.969 --> 01:38:48.969
to a builder, make this a 
function, take 

01:38:50.787 --> 01:38:54.151
my context and my model.  
So now what we can do in here is

01:38:54.152 --> 01:38:56.589
we have all of this snack bar 
code, which I can 

01:39:00.662 --> 01:39:02.662
get rid of, and I should be able
to do model.

01:39:07.839 --> 01:39:10.282
add and we have a product.
Okay.  So this is all hot 

01:39:10.283 --> 01:39:12.511
reloaded.  I placed state in 
there and don't have 

01:39:15.781 --> 01:39:17.205
to restart my app, and we'll see
if this works.  There we go.  

01:39:20.873 --> 01:39:22.295
So we went from stateless to 
stateful.  I haven't changed the

01:39:22.296 --> 01:39:24.296
structure of my app.

01:39:26.315 --> 01:39:26.948
All I did is layered in a few 
extra widgets, and with the way 

01:39:26.949 --> 01:39:30.645
that this half is built, this 
has worked nicely.  

01:39:32.275 --> 01:39:34.719
&gt;&gt; FILIP HRACEK:  This is nice, 
Matt.  Didn't you say when you 

01:39:34.720 --> 01:39:36.720
modify the centers, you rebuild 
the things below 

01:39:39.964 --> 01:39:44.540
the decent he notes that means 
we're rebuilding the products 

01:39:44.541 --> 01:39:46.541
every time?  

01:39:48.439 --> 01:39:50.071
&gt;&gt; MATT SULLIVAN:  As we pointed
out before, we're rebuilding 

01:39:50.072 --> 01:39:52.109
this button but also rebuilding 
all of these products, which is 

01:39:52.110 --> 01:39:57.663
bad.  Not great.  Why don't we 
fix that real quick, because 

01:39:57.664 --> 01:39:59.664
scope model descendant has a 

01:40:01.607 --> 01:40:04.056
rebuilt on changeded  flag, and 
I can set that to false.  So you

01:40:04.057 --> 01:40:06.057
shouldn't see any difference 
here.  

01:40:09.562 --> 01:40:11.427
What's happening now is these 
product squares are not being 

01:40:11.428 --> 01:40:13.428
rebuilt.

01:40:15.298 --> 01:40:16.917
I already implemented descendant
for the cart page because you 

01:40:16.918 --> 01:40:20.388
don't need to see my type this a
third time, but it's exactly the

01:40:20.389 --> 01:40:23.644
same model there.  
Perfect.  So let's jump back to 

01:40:23.645 --> 01:40:25.645
the slides.  Thank you.

01:40:27.161 --> 01:40:29.634
Great.  So what does that get 
us?  Accessing state.

01:40:33.093 --> 01:40:35.730
We can access state arbitrarily 
down the tree without having to 

01:40:35.731 --> 01:40:39.627
mess with intermediate widgets. 
Perfect.  We have a reasonably 

01:40:39.628 --> 01:40:41.628
elegant means to 

01:40:42.899 --> 01:40:45.156
notify the widgets by the 
descendant observing for state 

01:40:45.157 --> 01:40:47.157
change and rebuilding when it 
changes.  

01:40:49.468 --> 01:40:52.122
Minimal rebuild I give a 
thumbs-down because I had to be 

01:40:52.123 --> 01:40:54.123
reminded by Filip 

01:40:55.824 --> 01:40:58.667
because I constantly forgot 
every time we rehearsed to do 

01:40:58.668 --> 01:41:00.668
that we had to not rebuild at 
that part.  

01:41:02.353 --> 01:41:04.353
There's a cognitive load at that
point for the developers.  

01:41:06.707 --> 01:41:07.312
Should is this rebuild or not 
rebuild?  What will happen?  

01:41:07.313 --> 01:41:11.439
When you evolve the app, you 
have an additional level of 

01:41:11.440 --> 01:41:13.440
needing to worry about this.  I 
don't think this is great, and I

01:41:15.302 --> 01:41:18.213
think we probably need a better 
solution to that.  

01:41:20.458 --> 01:41:23.327
Funny enough, we look at Flutter
support for Streams.  How 

01:41:23.328 --> 01:41:25.564
Streams can be built to fit in 
with the reactive model and how 

01:41:25.565 --> 01:41:28.004
they can solve this very 
problem.

01:41:31.877 --> 01:41:33.877
&gt;&gt; FILIP HRACEK:  Thank you.  
Let's talk about Streams.

01:41:38.463 --> 01:41:40.093
If you're more FOM with the term
Observables, they are very 

01:41:40.094 --> 01:41:45.203
closely related, and for the 
purposes of our talk, they are 

01:41:45.204 --> 01:41:47.204
basically interchangeable.

01:41:48.250 --> 01:41:49.486
So if you think about 
application development, Streams

01:41:49.487 --> 01:41:51.487
are everywhere.

01:41:53.114 --> 01:41:55.427
Every user input is a stream of 
a synchronous event, and every 

01:41:55.428 --> 01:42:00.114
interaction with the underlying 
system is a stream of a 

01:42:00.115 --> 01:42:02.814
synchronous event.  Every 
interaction, obviously, with the

01:42:05.676 --> 01:42:07.531
outside world through network is
a stream of synchronous events, 

01:42:07.532 --> 01:42:09.532
and crucially if you think about
it, all 

01:42:12.265 --> 01:42:14.089
your updates to the UI is a 
stream of a synchronous event.  

01:42:14.090 --> 01:42:19.622
So people who are familiar with 
reactive X and reactive 

01:42:19.623 --> 01:42:21.623
programming in general probably 
know where I'm going with this, 

01:42:23.144 --> 01:42:25.144
but suffice it to say, it makes 
sense to 

01:42:26.419 --> 01:42:28.652
think about UI programming as 
managing stream of synchronous 

01:42:28.653 --> 01:42:30.653
events.

01:42:34.873 --> 01:42:36.873
The good news is they have a 
good for 

01:42:38.123 --> 01:42:39.745
streams and has had that for a 
long time.  The streams have all

01:42:39.746 --> 01:42:41.746
the usual bells 

01:42:43.634 --> 01:42:45.634
and whistles you expect like 
stream 

01:42:47.530 --> 01:42:49.530
transforming, mapping, folding, 
and so on.  

01:42:52.936 --> 01:42:55.007
Dart even has language level for
streams like asynchronous 

01:42:55.008 --> 01:42:57.008
generators, the yield keyword or
a wait for.

01:43:00.967 --> 01:43:03.204
So we have this concept of 
streams in Dart, and it is used 

01:43:03.205 --> 01:43:05.871
throughout the Dart eco-system. 

01:43:09.183 --> 01:43:10.800
Then we have this, you know, 
concept of reactive extensions 

01:43:10.801 --> 01:43:12.801
and reactive programming.

01:43:14.258 --> 01:43:16.258
On top of that, there's a 
package 

01:43:17.743 --> 01:43:19.743
called Rx Start, which builds 
the 

01:43:21.050 --> 01:43:23.920
reactive extensions on top of 
the inherent streams in Dart.

01:43:24.744 --> 01:43:29.452
So this is really great.  How 
that fits into Flutter?

01:43:32.542 --> 01:43:35.363
Well, Flutter has this widget 
called stream builder, which is 

01:43:35.364 --> 01:43:37.364
a exactly what you would think 
it is.

01:43:42.483 --> 01:43:44.483
It is a widget that takes

01:43:47.671 --> 01:43:48.889
it as an input and rebuilds 
every time there's a value in 

01:43:48.890 --> 01:43:50.949
the stream.  Anytime you have a 
stream when you 

01:43:55.273 --> 01:43:57.273
describe to a Firebase database,
you can 

01:44:01.167 --> 01:44:02.177
use stream builder to rebuild 
your UI.  That's pretty cool.  

01:44:05.455 --> 01:44:07.712
Wouldn't it be more awesome to 
have an architectural pattern to

01:44:07.713 --> 01:44:10.778
build our apps?  
Imagine that you have a big app,

01:44:10.779 --> 01:44:15.523
and it has some widgets that 
take user input.  Therefore, 

01:44:15.524 --> 01:44:17.149
they have streams of a 
synchronous event coming from 

01:44:17.150 --> 01:44:22.516
the user, and then you have 
other widgets that can be 

01:44:22.517 --> 01:44:24.517
anywhere else in the widget 
stream 

01:44:25.786 --> 01:44:27.786
that try to update whenever 
there's a state change.

01:44:29.663 --> 01:44:31.088
Now, you cannot just simply, you
know, link those two together.  

01:44:31.089 --> 01:44:33.739
You need something in between.  

01:44:36.797 --> 01:44:38.797
We'll call that business logic 
for now.  

01:44:40.673 --> 01:44:42.673
So you need to stream the events
from 

01:44:43.773 --> 01:44:46.247
the widgets that have buttons 
and inputs to the business 

01:44:46.248 --> 01:44:48.522
logic.  Then magic happens, and 
the business 

01:44:52.376 --> 01:44:54.376
logic publishes streams of data 
changes 

01:44:55.456 --> 01:44:57.512
to widgets that are interested 
in it, right?  These can then 

01:44:57.513 --> 01:44:59.513
rebuild.  

01:45:02.409 --> 01:45:04.445
Crucially, your publishing 
separate streams, so the other 

01:45:04.446 --> 01:45:06.446
widget could be interested in a 
completely different 

01:45:09.157 --> 01:45:11.157
aspect of data and it will just 
subscribe to that stream.

01:45:13.221 --> 01:45:14.892
So it won't rebuild anytime 
there's any change to your 

01:45:14.893 --> 01:45:16.893
model.

01:45:19.138 --> 01:45:20.370
It will only rebuild when 
there's a change to that 

01:45:20.371 --> 01:45:25.871
specific aspect of the model.  
So let's have a closer look.  We

01:45:25.872 --> 01:45:27.289
have streams as inputs and 
outputs.  How would that look 

01:45:27.290 --> 01:45:29.290
like in Dart?

01:45:31.076 --> 01:45:33.076
We would have an object that has
syncs of events as inputs.

01:45:36.635 --> 01:45:40.489
Syncs is the input of a stream. 
You put things into it.  Then 

01:45:40.490 --> 01:45:42.490
you can listen to it on the 
other end.  

01:45:43.806 --> 01:45:47.893
And then there's the stream of 
data that's output, right?  So 

01:45:47.894 --> 01:45:49.894
pretty simple.

01:45:52.631 --> 01:45:54.631
Now, in our example with a 
shopping 

01:45:56.508 --> 01:45:58.747
app, the simplest possible cart 
would be to have a sync of 

01:45:58.748 --> 01:46:01.804
product called addition to which
you would just shove your 

01:46:01.805 --> 01:46:03.805
products into.  

01:46:07.570 --> 01:46:09.402
And then it would have a stream 
of enter  integers called item 

01:46:09.403 --> 01:46:11.403
count which would 

01:46:12.893 --> 01:46:15.725
update every time the item count
changes.  So internally at 

01:46:15.726 --> 01:46:17.726
Google we call these 

01:46:20.450 --> 01:46:23.514
business logic components, so 
that is block for short.  

01:46:27.421 --> 01:46:29.666
Let's switch the computer and 
implement it real quick.

01:46:33.371 --> 01:46:36.034
This is my computer.  I have the
same app.  It doesn't change or 

01:46:36.035 --> 01:46:38.035
currently work, 

01:46:40.109 --> 01:46:42.109
and we need to implement this 
pattern.

01:46:43.171 --> 01:46:45.171
So I already have a cart 
provider that 

01:46:46.679 --> 01:46:48.926
uses inherited widget, so that I
can access the cart -- 

01:46:52.173 --> 01:46:54.173
this object from anywhere in my 
tree.

01:46:55.635 --> 01:46:58.076
And as you can see, I'm creating
this object here, and then I'm 

01:46:58.077 --> 01:47:00.077
accessing it 

01:47:01.938 --> 01:47:02.952
in different parts of my app but
not doing anything with it yet. 

01:47:06.236 --> 01:47:08.249
Also, if you look at the object 
now or the component now, it is 

01:47:08.250 --> 01:47:10.250
pretty empty.

01:47:11.517 --> 01:47:13.517
It only has the underlying 
model.  

01:47:16.245 --> 01:47:17.667
So what I'm going to do is I'm 
going to first implement the 

01:47:17.668 --> 01:47:20.314
sync of products, the input, the
streaming input, right?  

01:47:22.197 --> 01:47:24.688
I'm going to very quickly code 
it up, and then I'm going to 

01:47:24.689 --> 01:47:26.689
tell you what it does.

01:47:28.550 --> 01:47:30.550
So it's going to be a sync of 
product called addition.

01:47:35.703 --> 01:47:37.703
This is that input stream that 
you can 

01:47:39.575 --> 01:47:41.575
access externally, and then this
is 

01:47:42.852 --> 01:47:44.852
backed by a stream controller 
called 

01:47:46.861 --> 01:47:49.503
addition controller, which is a 
stream controller is a basic 

01:47:49.504 --> 01:47:51.504
class in the 

01:47:53.184 --> 01:47:55.030
stream library in Dart, called a
library.  So that helps us, you 

01:47:55.031 --> 01:47:57.684
know, listen to the stream of 
things that are coming from 

01:47:57.685 --> 01:48:00.122
outside.  
Now, how would you use it in 

01:48:00.123 --> 01:48:02.123
your app?

01:48:04.197 --> 01:48:06.197
You would just go to the product

01:48:07.243 --> 01:48:09.897
squares and wherever you are 
trying to, you know, add to the 

01:48:09.898 --> 01:48:11.898
streams of events, 

01:48:14.652 --> 01:48:16.900
it would just say, hard block, 
the sync, and then we want to 

01:48:16.901 --> 01:48:19.939
add to the sync and in this case
we want to add to the products. 

01:48:19.940 --> 01:48:21.940
Right?  

01:48:24.027 --> 01:48:26.027
Coming back, we want to also 
code the 

01:48:27.550 --> 01:48:30.190
output, which is a stream of 
item count.  So again, let me 

01:48:30.191 --> 01:48:32.191
quickly do that.

01:48:35.878 --> 01:48:37.878
Item count is a stream of  (?

01:48:42.274 --> 01:48:43.923
) And it's backed by a behavior 
subject.  Behavior subject is 

01:48:43.924 --> 01:48:49.017
coming from reactive X, and it 
is a different kind of stream 

01:48:49.018 --> 01:48:51.018
controller that has memory of 
its latest value.

01:48:54.143 --> 01:48:55.986
So whenever you listen to it, it
will give you the lightest 

01:48:55.987 --> 01:48:59.879
value.  This is in contrast to 
normal stream controllers or 

01:48:59.880 --> 01:49:02.539
Veeams where when you listen to 
it, you have to wait until the 

01:49:03.143 --> 01:49:05.587
value changes.  
That could be, you know, 

01:49:05.588 --> 01:49:09.278
sometime in the future.  
In our case we want to have 

01:49:09.279 --> 01:49:11.113
always the latest value -- the 
moment that we listen to a 

01:49:11.114 --> 01:49:13.114
stream.

01:49:15.175 --> 01:49:17.175
Now, how would we use that?

01:49:18.860 --> 01:49:20.860
Well, now we get to use the 
stream 

01:49:23.095 --> 01:49:25.503
builder class, so we have the 
cardboard on here.  We had it to

01:49:25.504 --> 01:49:27.504
Lynn to changes to the 

01:49:31.832 --> 01:49:33.660
item count, so I'm going to wrap
it with a stream builder of 

01:49:33.661 --> 01:49:35.661
integers.

01:49:37.523 --> 01:49:39.523
It will Lynn to the item count 
stream.

01:49:46.361 --> 01:49:48.361
And in here I access the 
snapshot the 

01:49:50.677 --> 01:49:52.307
datasesdatases, which is the 
latest item KOUN.  So we have 

01:49:52.308 --> 01:49:55.351
this.  
Now all we need to do is merge 

01:49:55.352 --> 01:49:58.821
the streams together.  So that's
what I'm going to do just now.  

01:50:02.717 --> 01:50:03.768
So this is where Filip will make
the 

01:50:03.769 --> 01:50:06.453
&gt;&gt; MATT SULLIVAN:  This is where
Filip will make the magic happen

01:50:06.454 --> 01:50:08.454
behind the scenes.

01:50:09.917 --> 01:50:11.342
We need to listen for changes on
that, because we're not 

01:50:11.343 --> 01:50:13.343
capturing it at the moment.

01:50:15.216 --> 01:50:17.685
We need to add those products to
the cart itself.  What Filip is 

01:50:17.686 --> 01:50:19.736
doing now is getting access to 
the stream and Lynning to it, 

01:50:21.394 --> 01:50:23.437
and then the product will be the
event coming in and all we need 

01:50:23.438 --> 01:50:27.724
to do at this point, then, is 
add that product to the cart.  

01:50:27.725 --> 01:50:31.823
Great.  
Now we have state managed.  We 

01:50:31.824 --> 01:50:34.079
need to make sure that item 
count is always updated when 

01:50:34.080 --> 01:50:36.316
products are added, and we just 
need to do what we 

01:50:39.424 --> 01:50:41.424
did in the opposite direction, 
to add 

01:50:43.533 --> 01:50:46.203
the item count to the item count
stream and we're done?  

01:50:46.603 --> 01:50:49.471
&gt;&gt; FILIP HRACEK:  We're done.  
Back to the slides, please.

01:50:55.383 --> 01:50:56.840
As you can see, we were able to 
implement this business logic 

01:50:56.841 --> 01:50:59.486
component pretty quickly.  It's 
a little more complicated, but 

01:50:59.487 --> 01:51:01.487
it 

01:51:02.553 --> 01:51:08.310
gives you a lot of cool stuff.  
First of all it's just streams 

01:51:08.311 --> 01:51:10.146
in and streams out.  
Whatever happens in the 

01:51:10.147 --> 01:51:19.466
component you don't care about. 
As a Flutter UI.  Then we could 

01:51:19.467 --> 01:51:21.467
add more things to this block, 
right?

01:51:24.435 --> 01:51:27.291
We could add a stream of total 
costs, so whenever the costs of 

01:51:27.292 --> 01:51:29.292
the cart changes, you probably 
want to update 

01:51:32.662 --> 01:51:35.128
your user to give it that.  Then
you have a stream of lists of 

01:51:37.162 --> 01:51:39.468
cart items, which is the items 
that you want to always update 

01:51:39.469 --> 01:51:41.469
whenever you add 

01:51:42.555 --> 01:51:44.555
something to the cart or remove 
from it.

01:51:46.030 --> 01:51:47.472
So that is, cool, and again 
these are different aspects of 

01:51:47.473 --> 01:51:51.578
our model that we want to show. 
Now, I have a problem with one 

01:51:51.579 --> 01:51:53.579
part of this, and that is this 
part.

01:51:57.496 --> 01:51:59.496
We're streaming the total cost 
as integers.

01:52:02.004 --> 01:52:04.004
That makes sense internally in 
the 

01:52:05.070 --> 01:52:07.070
component, and it is a numerical
value after all.

01:52:10.358 --> 01:52:12.358
What it leads to is code in your
views like this.

01:52:14.837 --> 01:52:17.081
You have to somehow convert or 
format the numerical value to 

01:52:17.082 --> 01:52:20.142
some kind of string, right?  
Which is if you think about it, 

01:52:20.143 --> 01:52:25.273
this is business logic.  This 
shouldn't be in views.  So you 

01:52:25.274 --> 01:52:27.274
can go back to your cart block 

01:52:29.149 --> 01:52:30.383
and just change this to a stream
of stream that is already 

01:52:30.384 --> 01:52:32.384
formatted.

01:52:33.452 --> 01:52:35.452
Whenever you want to show your 
total 

01:52:37.518 --> 01:52:39.518
cast, you just stream the 
formatted one.  

01:52:40.360 --> 01:52:42.422
If you just re-use that same 
business logic that's inside the

01:52:42.423 --> 01:52:44.660
component now.  That gives you 
another cool thing, and 

01:52:48.336 --> 01:52:50.203
that is that if you add a new 
sync or new input to the model 

01:52:50.204 --> 01:52:52.204
-- sorry.

01:52:54.292 --> 01:52:57.179
To the component, for example, 
sync of locale, so users now can

01:52:57.180 --> 01:53:01.263
change anywhere in your app they
can change from a U.S. shop to a

01:53:01.264 --> 01:53:03.264
EU shop.

01:53:07.437 --> 01:53:09.437
Now, you can pipe this change as
a 

01:53:11.700 --> 01:53:14.142
stream to the total costs, so 
internally in the block you will

01:53:14.143 --> 01:53:16.143
update the total cost stream.

01:53:18.895 --> 01:53:21.358
Even though it was the numerical
value is still the same.  That 

01:53:21.359 --> 01:53:23.187
means that anywhere in the app 
that user changes this, you 

01:53:23.188 --> 01:53:28.111
don't need to think about it as 
a developer.  It will always 

01:53:28.112 --> 01:53:30.112
update anywhere else the total 
costs.

01:53:32.594 --> 01:53:37.828
This would be a real pain to 
implement any other way. 

01:53:43.602 --> 01:53:45.602
We have this nice flow of data 
and events.

01:53:46.952 --> 01:53:49.198
We have widgets that only Lynn 
to what we need to know, and 

01:53:49.199 --> 01:53:51.199
we're using good 

01:53:52.448 --> 01:53:53.864
old stream builders to make that
work.  

01:53:53.865 --> 01:53:55.865
&gt;&gt; MATT SULLIVAN:  Look what we 
have now.

01:53:56.912 --> 01:53:58.912
Accessing state in Filip's 
example was 

01:54:00.181 --> 01:54:02.019
solved by using the inherit the 
widget pattern to pass access to

01:54:02.020 --> 01:54:04.020
the block down the tree.

01:54:05.493 --> 01:54:07.113
We now have very fine updating 
on change, because we have 

01:54:07.114 --> 01:54:09.114
different aspect 

01:54:10.771 --> 01:54:13.409
'of our data represented by 
different streams.  Those 

01:54:13.410 --> 01:54:15.656
widgets subscribing to those 
streams only rebuild when those 

01:54:15.657 --> 01:54:19.362
aspects of data changes.  
Finally, we now have the 

01:54:19.363 --> 01:54:21.626
converse.  We have mutating 
state by pumping data 

01:54:26.728 --> 01:54:28.150
or requests to mutate state into
the business logic where we 

01:54:28.151 --> 01:54:30.186
observe for change and we can 
update it now.  

01:54:32.828 --> 01:54:34.828
There's a nice pattern of 
pushing data 

01:54:36.093 --> 01:54:37.309
in via streams and updating via 
streams, which we think is very 

01:54:37.310 --> 01:54:40.200
elGAPT.  This is great, but you 
all have options.

01:54:42.435 --> 01:54:44.435
Set state works fine if you have
a 

01:54:46.935 --> 01:54:48.944
shallow tree and your app is 
fairly simple.  

01:54:53.942 --> 01:54:54.925
Scope model is a fantastic way 
for a model which is relatively 

01:54:54.926 --> 01:54:56.161
straightforward passed up and 
down and change on a tree of 

01:54:56.162 --> 01:54:58.162
arbitrary depth.  For those that
like the Redux pattern, 

01:55:03.634 --> 01:55:06.294
there is an excellent Redux 
package built for the community 

01:55:06.295 --> 01:55:08.751
for Dart and Flutter, which will
give you that pattern and you 

01:55:08.752 --> 01:55:10.752
can use that as well.  If 
there's one thing that we'd like

01:55:15.102 --> 01:55:17.102
you to take away from this, it's
that 

01:55:18.603 --> 01:55:20.603
Flutter's widgets in combination
with 

01:55:21.678 --> 01:55:23.912
Streams gives you a reactive way
to not only handle the UI but 

01:55:23.913 --> 01:55:28.189
the flow of data through your 
app and handle the updating of 

01:55:28.190 --> 01:55:30.190
your UI when that data changes.

01:55:31.442 --> 01:55:33.442
So we highly recommend you go 
and 

01:55:36.576 --> 01:55:38.575
check out Dart Streams and the 
RX Dart package as an option for

01:55:38.576 --> 01:55:41.694
building state in your apps.  
We'd love to hear from you.  

01:55:41.695 --> 01:55:45.161
Please go to the site and give 
us some feedback.  

01:55:49.079 --> 01:55:49.763
All of the code you've seen 
today is in Filip's GitHub 

01:55:49.764 --> 01:55:51.764
account.

01:55:54.446 --> 01:55:57.437
I did some, and he didn't write 
everything.  We showed you the 

01:55:57.438 --> 01:55:58.453
code we showed, but we have a 
Redux implementation and a 

01:55:58.454 --> 01:56:00.480
couple others to check out.  A 
shout-out to the cookbook that 

01:56:00.481 --> 01:56:02.911
us and the community have been 
working on.  There's some 

01:56:02.912 --> 01:56:04.912
wonderful patterns in there from
everything from widget 

01:56:08.685 --> 01:56:11.329
creation to networking to JSON 
and it's grate place to go.  Two

01:56:11.330 --> 01:56:13.330
other talks happened prior to 
this.  

01:56:13.780 --> 01:56:15.780
Fortunately, we have a time 
machine 

01:56:17.457 --> 01:56:19.457
called YouTube so you can go 
back in time.

01:56:20.524 --> 01:56:22.756
If you want to learn about 
building apps, check them out.  

01:56:22.757 --> 01:56:24.757
They're good talks.  I would 
like to say thank you for your 

01:56:25.256 --> 01:56:28.109
time.  
&gt;&gt; FILIP HRACEK:  Thank you.  

01:56:31.119 --> 01:56:33.119
( Applause ) 

01:56:48.003 --> 01:56:50.836
. 
&gt;&gt; Thank you for joining this 

01:56:50.837 --> 01:56:52.837
session.

01:56:54.523 --> 01:56:56.964
Grand Am bass DORs will assist 
to get through the exits.  We 

01:56:56.965 --> 01:56:58.965
will make room for those that 
registered for the next session.

01:57:00.487 --> 01:57:02.542
If you registered for the next 
session in this room, please 

01:57:02.543 --> 01:57:03.999
clear the room and return via 
the registration line outside.  

01:57:04.000 --> 01:57:08.078
Thank you.   

01:57:11.688 --> 01:57:13.688
( Session ended ) 

01:58:19.556 --> 01:58:20.578
.   
.  

01:58:20.579 --> 01:58:21.590
.  
.  

01:58:21.591 --> 01:58:22.209
.  
.  

02:15:32.247 --> 02:15:34.247
Effective ProGuard

02:15:37.249 --> 02:15:39.249
keep rules for smaller 
applications 

02:23:01.591 --> 02:23:05.046
&gt;&gt; STEPHAN HERHUT:  Hello.  A 
Stephan and I'm a staff engineer

02:23:05.047 --> 02:23:07.047
at Google where we work on 
compilers and 

02:23:11.063 --> 02:23:13.938
runtime systems and most 
recently I'm working on R8 which

02:23:13.939 --> 02:23:15.939
is the SNU shrinker.  

02:23:18.650 --> 02:23:20.079
If you attended yesterday's sec 
on Android studio and you heard 

02:23:20.080 --> 02:23:22.924
about how to use it.  I don't 
want to talk too much about it. 

02:23:25.980 --> 02:23:30.475
I want to focus more on key 
rules.  So what are keep rules? 

02:23:34.142 --> 02:23:36.400
It's the language that ProGuard 
uses to specify what you need to

02:23:36.401 --> 02:23:39.268
keep in the application.  When 
we built R8 we wanted to use the

02:23:41.522 --> 02:23:43.522
same language because we want to
a 

02:23:44.790 --> 02:23:47.035
drop-in replacement for 
ProGuard.  You can resues the 

02:23:47.036 --> 02:23:50.495
existing rules and try it 
easily.  I mentioned building 

02:23:50.496 --> 02:23:54.777
something that is compatible to 
that degree required us to quite

02:23:54.778 --> 02:23:58.225
deeply understand what ProGuard 
key rules actually mean.  Today 

02:23:58.226 --> 02:24:00.296
I want to use this opportunity 
to share some of that knowledge 

02:24:00.297 --> 02:24:05.854
with you.  I also want to take 
you on a journey to understand 

02:24:05.855 --> 02:24:07.855
what it takes to give an 

02:24:08.905 --> 02:24:10.538
application to come up with 
effective rules to shrink it to 

02:24:10.539 --> 02:24:13.215
the minimum.  Before we go 
there, let me ask you the 

02:24:13.422 --> 02:24:16.889
questions.  Who has used 
ProGuard before in some way or 

02:24:16.890 --> 02:24:19.537
shape?  Wow, that's a lot of 
people.

02:24:23.846 --> 02:24:25.846
So who of you is using ProGuard 
today 

02:24:27.320 --> 02:24:30.185
in the released production app 
on the Play Store?  That's a 

02:24:30.186 --> 02:24:32.007
little less, but you're a great 
crowd.  Thank you for doing 

02:24:32.008 --> 02:24:34.258
that.  
Our estimates show that only 

02:24:34.259 --> 02:24:36.910
about a quarter of applications 
on the Play 

02:24:39.999 --> 02:24:42.261
Store actually use the rules.  
There's a big room for 

02:24:42.262 --> 02:24:45.741
improvement.  Why it actually 
matters to shrink application 

02:24:45.742 --> 02:24:48.672
size.  Of course, for me it 
matters because I 

02:24:52.986 --> 02:24:54.986
help to build the shrinker and 
want somebody to use it.

02:24:56.663 --> 02:24:58.506
There's a lot of talk about next
building users and Android 

02:24:58.507 --> 02:25:00.507
deviceses and how to make the 
user experience better.

02:25:04.651 --> 02:25:06.935
What makes an entry level user 
Android device, so one thing is 

02:25:06.936 --> 02:25:08.936
it's really resource limited.

02:25:11.020 --> 02:25:13.904
If you think of these devices, 
they typically have 512 

02:25:13.905 --> 02:25:15.905
megabytes of ram and 

02:25:17.008 --> 02:25:18.631
only have four gigabytes of 
storage and quite often people 

02:25:18.632 --> 02:25:20.632
that use the devices 

02:25:22.535 --> 02:25:24.535
on areas where they have very 
limited connectivity.

02:25:25.624 --> 02:25:26.644
So for these users, size 
actually makes a daily 

02:25:26.645 --> 02:25:30.739
difference.  When they decide of
all the apps they actually want 

02:25:30.740 --> 02:25:32.740
to use, which ones they 

02:25:34.807 --> 02:25:36.861
can afford to install, there 
might be a small subset, and 

02:25:36.862 --> 02:25:40.582
it's bad for them because it's a
bad user experience but it's bad

02:25:40.583 --> 02:25:42.449
for you as application 
developers because it might be 

02:25:42.450 --> 02:25:45.932
your app that doesn't make the 
cut.  It might be your app that 

02:25:45.933 --> 02:25:49.593
they want to use but they can't 
use because they don't have the 

02:25:49.594 --> 02:25:51.900
space.  
Now, you might say, okay, that's

02:25:51.901 --> 02:25:57.020
not really my audience.  Next 
building users entry level is 

02:25:57.021 --> 02:26:01.299
not where I see my application. 
Even if your target really 

02:26:01.300 --> 02:26:03.347
high-end devices, the 
fundamental truth is that 

02:26:03.556 --> 02:26:05.801
smaller is always faster.   

02:26:11.736 --> 02:26:13.736
That's quite obvious, because, 
A, they 

02:26:16.031 --> 02:26:17.048
crown download fast and install 
faster because there's less code

02:26:17.049 --> 02:26:19.505
to compile.  That takes the time
to install.  

02:26:21.131 --> 02:26:23.586
Lastly and what users see every 
day, they also start up much 

02:26:23.587 --> 02:26:26.270
faster because there's less code
to load.  

02:26:27.509 --> 02:26:30.353
So whenever I talk to people 
about this and say, okay, you 

02:26:30.354 --> 02:26:32.354
have to care and make 

02:26:35.084 --> 02:26:38.759
them smaller, an answer I get on
is, hardware will fix this.  

02:26:38.760 --> 02:26:39.812
Devices are faster and more 
storage and connectivity is 

02:26:39.813 --> 02:26:41.813
better.

02:26:42.942 --> 02:26:44.145
That might be true, but it's not
a solution.  I have GRAF for 

02:26:44.146 --> 02:26:46.381
you. 
So this shows the average size 

02:26:46.382 --> 02:26:48.382
of 

02:26:49.457 --> 02:26:51.457
installed apps on people's 
devices.

02:26:52.521 --> 02:26:53.960
As you can see, this has been 
growing steadily, so in the 

02:26:53.961 --> 02:26:56.866
early days of Android we started
at about a megabyte 

02:27:01.570 --> 02:27:03.227
per APK, and by now we're at 32 
megabytes on average for 

02:27:03.228 --> 02:27:05.667
installed applications.  So 
clearly, hardware is not going 

02:27:05.668 --> 02:27:07.503
to fix this.  
We have to do something about 

02:27:07.504 --> 02:27:09.504
it.  We have to make apps 
smaller.

02:27:12.290 --> 02:27:14.585
So let's look at this.
Where does this growth come from

02:27:14.586 --> 02:27:16.586
and why are apps so big?

02:27:19.685 --> 02:27:21.685
To give you an idea, I gave an 
example here.

02:27:23.222 --> 02:27:25.057
I built this app I called simple
weather, and the stress is 

02:27:25.058 --> 02:27:27.058
really on simple.

02:27:28.519 --> 02:27:30.519
All this app does is takes 
predefined 

02:27:32.826 --> 02:27:35.302
weather data and RENDs it as a 
dynamic graph.  If you churn the

02:27:35.303 --> 02:27:37.303
app, it will render in a 
different size or install on a 

02:27:39.231 --> 02:27:41.231
different device, it will adapt 
to resolution.

02:27:42.300 --> 02:27:44.300
So the graph is truly dynamic 
and the data isn't.

02:27:45.985 --> 02:27:48.227
This is a really, really simple 
app.  

02:27:50.255 --> 02:27:52.496
There's two things I found 
surprising.  It took me all but 

02:27:52.497 --> 02:27:56.582
30 minutes.  
 Went on the Internet and looked

02:27:56.583 --> 02:27:59.061
or the graph library and typed 
in hundreds of lines of code.  

02:27:59.062 --> 02:28:02.958
There it is, my simple, little 
weather app.  There was also a 

02:28:02.959 --> 02:28:05.600
negative surprise, and that was 
the size.  I thought I built 

02:28:05.601 --> 02:28:07.601
something simple and small 
because it makes it small, but 

02:28:07.863 --> 02:28:09.863
that's not true.

02:28:12.802 --> 02:28:14.252
This app was two megabytes of an
APK.  Two megabytes to render a 

02:28:14.253 --> 02:28:16.253
graph.  

02:28:17.728 --> 02:28:19.728
Even when I installed this, it 
turns 

02:28:21.234 --> 02:28:23.234
into a 4 megabyte blob of code 
uncompressed.

02:28:24.829 --> 02:28:27.675
Again you might say 4 megabytes 
is not much.  The device has 

02:28:27.676 --> 02:28:30.427
lots of space.  
Let's put this in perspective.  

02:28:33.885 --> 02:28:35.885
In the '60s we flew to the moon 
with 60K of code.

02:28:37.573 --> 02:28:38.988
That's a 60th of the application
size I had for my simple weather

02:28:38.989 --> 02:28:43.108
here.  No matter how you turn 
this, it's more complicated to 

02:28:43.109 --> 02:28:45.109
fly to the moon than rendering a
graph.

02:28:46.602 --> 02:28:48.602
So what has happened here?

02:28:50.089 --> 02:28:52.555
Why did we go from 60K flying 
from the moon to 4 megabytes 

02:28:52.556 --> 02:28:54.556
rendering GRAF?

02:28:55.853 --> 02:28:57.913
I think the reason is that we 
fundamentally changed how we do 

02:28:57.914 --> 02:29:00.175
software.  
So back then when they did the 

02:29:00.176 --> 02:29:02.176
software 

02:29:03.247 --> 02:29:05.489
for apolo, it was a dedicated 
team that wrote this code line 

02:29:05.490 --> 02:29:10.240
by line.  Everything was on 
purpose and hand-crafted, so it 

02:29:10.241 --> 02:29:12.241
was meticulously 

02:29:13.748 --> 02:29:16.640
crafted to fit into the 60K and 
do exactly one thing, fly to the

02:29:16.641 --> 02:29:19.085
moon.  Fast forward to today, I 
build my app with components.

02:29:22.177 --> 02:29:23.396
I just went to the web and 
downloaded components and 

02:29:23.397 --> 02:29:26.851
stitched it together.  I had my 
app.  There's a great advantage 

02:29:26.852 --> 02:29:30.554
to this, right?  It took me 30 
minutes.  It was really easy and

02:29:30.555 --> 02:29:32.555
super 

02:29:35.053 --> 02:29:37.314
productive, but there's a big, 
big DAU drawback.  My 

02:29:37.315 --> 02:29:39.592
application was really big.  
Let's look in the details.  

02:29:42.843 --> 02:29:44.843
Which components did I actually 
use?

02:29:47.164 --> 02:29:49.164
I brought youmy file and this is
the 

02:29:50.885 --> 02:29:52.885
default file Android Studio will
KRET for you.

02:29:54.985 --> 02:29:56.985
I highlighted the components to 
so it's easier to see.

02:30:02.018 --> 02:30:04.018
The first is GUAVAA, and they 
had a lot of convenient classes.

02:30:05.280 --> 02:30:07.280
I wanted a mutable collections, 

02:30:08.351 --> 02:30:10.351
because I thought my static 
weather data 

02:30:12.535 --> 02:30:14.965
is static so it should be in a 
mutable collection, right?  The 

02:30:14.966 --> 02:30:16.816
other thing I used is Android 
plot.  That's just a library of 

02:30:16.817 --> 02:30:20.917
I found on the Internet.  
There's probably lots more 

02:30:20.918 --> 02:30:23.957
plotting libraries but I spotted
this one first.  

02:30:26.002 --> 02:30:28.247
It's really great and has a lot 
of support for bar graphs and 

02:30:28.248 --> 02:30:31.761
charts, but they needed a line 
graph and that's all I cared 

02:30:31.762 --> 02:30:33.762
about.

02:30:35.035 --> 02:30:36.904
So let's look at what this means
for size.  How did these 

02:30:36.905 --> 02:30:38.930
components impact the size of my
application?  

02:30:42.179 --> 02:30:44.036
To get an idea, I went to the 
APK analyzer.  If you haven't 

02:30:44.037 --> 02:30:47.095
seen this tool before, it's 
really great.  It's part of 

02:30:47.096 --> 02:30:50.975
Android Studio.  You will find 
documentation on developers at 

02:30:50.976 --> 02:30:52.976
Android.com.

02:30:54.230 --> 02:30:56.862
It gives you deep insight into 
what contributes to the size of 

02:30:56.863 --> 02:31:01.550
the APK.  They can do resources 
and all kinds of thing, but I'm 

02:31:01.551 --> 02:31:03.551
only interested in the actual 
code.

02:31:05.684 --> 02:31:07.684
I highlighted the bottom there 
for you.

02:31:08.984 --> 02:31:11.242
There's this Google package with
4.1 megabytes and that's GAUF 

02:31:11.243 --> 02:31:13.243
YA.

02:31:14.308 --> 02:31:16.308
I pay 1.

02:31:17.787 --> 02:31:19.860
4 megabytes for the example.  
There's something nor realistic,

02:31:19.861 --> 02:31:23.779
which is Android plot.  That's 
the second thing you see, and 

02:31:25.009 --> 02:31:27.009
that's 180K.  

02:31:29.103 --> 02:31:30.751
My plotting library takes 180K 
of APK size.  Now, there will be

02:31:30.752 --> 02:31:33.600
something in there that I don't 
need, because my actual 

02:31:35.431 --> 02:31:39.954
application that's the EU part 
down there is only 35K.  That's 

02:31:39.955 --> 02:31:44.050
the code I wrote.  You might 
think 35K for 100 lines of code 

02:31:44.051 --> 02:31:46.051
is a bit much.

02:31:47.126 --> 02:31:48.155
It is, because there's the auto 
generator code, most of which I 

02:31:48.156 --> 02:31:50.156
don't need.

02:31:52.455 --> 02:31:54.455
So this brings us to the 
question, 

02:31:55.517 --> 02:31:57.517
how did it get from this where 
you can 

02:31:59.541 --> 02:32:03.336
clearly see that Guava and 
Android plot take the size and 

02:32:03.337 --> 02:32:04.746
the application is really small 
to something more tailored more 

02:32:04.747 --> 02:32:06.747
like the 

02:32:08.635 --> 02:32:10.672
thing that they did for Apollo. 
We won't get to something as 

02:32:10.673 --> 02:32:12.673
crafted 

02:32:13.757 --> 02:32:16.626
as that without dog  doing all 
the investment, but there must 

02:32:16.627 --> 02:32:18.627
be a middle ground.  

02:32:19.722 --> 02:32:21.722
That really is where a tool like
ProGuard NRA comes in.

02:32:24.047 --> 02:32:26.047
It takes the application and 
removes 

02:32:27.524 --> 02:32:29.779
all the unused DMOENTs, so the 
goal is to take a 

02:32:29.780 --> 02:32:31.780
componentialized build you make 
to something as tailored as 

02:32:34.114 --> 02:32:36.114
possible and remove all dead 
code.

02:32:37.155 --> 02:32:39.427
Now, when I asked you all said 
you used this, so you know it's 

02:32:39.428 --> 02:32:41.921
easy to enable because all you 
have to do is you 

02:32:46.454 --> 02:32:48.284
have to head back to your build 
file and flip this one flag.  

02:32:51.394 --> 02:32:54.047
If Android Studio generated this
for you, it will say enabled 

02:32:54.048 --> 02:32:56.922
false, you just flip that to 
true, and tah-dah, you have a 

02:32:56.923 --> 02:32:58.923
small app.

02:33:00.202 --> 02:33:01.268
I see some people shaking their 
heads already here because 

02:33:01.269 --> 02:33:03.920
that's not really the truth.  So
I did this for my application.

02:33:07.161 --> 02:33:09.161
I flipped the flag, and there it
was.

02:33:10.454 --> 02:33:12.454
More than 200 build time errors.
Hooray.  

02:33:14.965 --> 02:33:16.810
So I looked at these errors and 
thought, what are they trying to

02:33:16.811 --> 02:33:20.348
tell me?  There's classes 
missing and classes I haven't 

02:33:20.349 --> 02:33:25.230
even heard of.  What do I do?  
How do I fix this?  Well, the 

02:33:25.231 --> 02:33:26.865
first solution, you search on 
the Internet.  

02:33:26.866 --> 02:33:28.866
So I did.

02:33:29.948 --> 02:33:31.948
I found this great piece of 
advice, 

02:33:35.052 --> 02:33:36.490
which says, just put don'twarn 
star into the ProGuard 

02:33:36.491 --> 02:33:38.491
configuration, and everything 
will be fine.

02:33:43.230 --> 02:33:46.128
Now, technically this is 
correct, you put this in there, 

02:33:46.129 --> 02:33:48.129
and it will compile.  There's a 
problem.  

02:33:51.286 --> 02:33:52.306
What this tells it, no matter 
what happens, don't tell me 

02:33:52.307 --> 02:33:54.307
about it.  

02:33:56.988 --> 02:33:58.397
That means it will mask these 
benign errors and really mask 

02:33:58.398 --> 02:34:01.074
all the errors you really care 
about where something went 

02:34:01.075 --> 02:34:03.747
wrong.  So how can we improve on
this?

02:34:07.217 --> 02:34:09.891
To do that, we have to actually 
deep dive a bit into how R8 

02:34:09.892 --> 02:34:14.582
works.  Now, I will talk about 
R8 here, because that's the tool

02:34:14.583 --> 02:34:18.498
I helped build, but most of this
applies to ProGuard because it 

02:34:18.499 --> 02:34:22.592
solving the same problem.  
What does R8 do?  It does two 

02:34:22.593 --> 02:34:26.266
things.  It does magnification. 
Magnification is the process 

02:34:26.267 --> 02:34:28.267
where you 

02:34:29.350 --> 02:34:31.206
take very long class names and 
replace them with short names 

02:34:31.207 --> 02:34:33.207
instead.

02:34:34.475 --> 02:34:36.105
Some call this object fuss 
indication, but it doesn't 

02:34:36.106 --> 02:34:38.106
obfuscate your code. 

02:34:39.813 --> 02:34:41.254
It makes it a little less hard 
to read, but it's nowhere safe 

02:34:41.255 --> 02:34:43.525
for U.S. engineering.

02:34:48.022 --> 02:34:50.022
Let's call it that.

02:34:51.734 --> 02:34:54.586
The other thing it does is 
shrinking.  Its a great name 

02:34:54.587 --> 02:34:57.436
from a developer's perspective 
because it takes your app SP 

02:34:59.675 --> 02:35:02.116
shrinks it into a smaller app.  
If you want to understand what 

02:35:02.117 --> 02:35:06.418
happens under the hood, it works
the other way around.  What 

02:35:06.419 --> 02:35:08.657
we're doing is doing tree 
growing, which takes the entry 

02:35:08.658 --> 02:35:10.658
point of the application and 
grows that until 

02:35:13.586 --> 02:35:15.629
we've seen everything that will 
be executed at runtime.

02:35:19.345 --> 02:35:21.345
Let's look at the example here.

02:35:23.250 --> 02:35:25.106
So I found these graphics and a 
box is a class that is all you 

02:35:25.107 --> 02:35:28.361
have to care about for now.  
There's code in the boxes, but 

02:35:28.362 --> 02:35:31.208
don't read it just yet.  Another
thing on these graphs is that 

02:35:34.055 --> 02:35:36.092
everything on your right is 
library classes.  That's part of

02:35:36.093 --> 02:35:38.093
the Android system.  

02:35:39.996 --> 02:35:42.920
Everything on the left is your 
application code.  The first 

02:35:42.921 --> 02:35:44.921
thing to realize here is 

02:35:46.820 --> 02:35:48.820
that library classes are always 
live.

02:35:48.844 --> 02:35:50.844
There's a very practical reason 
for this.

02:35:52.748 --> 02:35:54.748
It's because we can't shrink 
them away anyway.  

02:35:54.785 --> 02:35:56.831
They're on the phone and part of
the system.  There's a technical

02:35:56.832 --> 02:36:01.566
reason also.  For a static 
analysis tool, we don't know 

02:36:01.567 --> 02:36:03.616
what this library class actually
does.  That is because the 

02:36:03.617 --> 02:36:05.617
runtime might call 

02:36:06.705 --> 02:36:08.553
to them at any point, and 
there's very many different 

02:36:08.554 --> 02:36:10.554
libraries like different Android
versions and they might change 

02:36:11.826 --> 02:36:13.892
in the future.
From an analysis standpoint, we 

02:36:13.893 --> 02:36:17.580
have to assume that the library 
classes are always live.  

02:36:20.678 --> 02:36:23.527
So let's assume we start our app
by calling the run method in the

02:36:23.528 --> 02:36:25.528
app class.  So the first thing 
we will have to do 

02:36:28.450 --> 02:36:30.492
to actually do this is we have 
to extent wait this app class, 

02:36:30.493 --> 02:36:32.493
which means we create an 
instance of the class app and 

02:36:35.402 --> 02:36:38.288
we also call the constructor.  
That leads to both of them being

02:36:38.289 --> 02:36:40.289
live.

02:36:41.976 --> 02:36:45.215
That means we cannot strip away 
the class and constructor.  So 

02:36:45.216 --> 02:36:49.322
far so good.  Next we have to 
actually look at the code of the

02:36:49.323 --> 02:36:51.547
KRUKTor to see what it will do 
at runtime, and if you look at 

02:36:51.548 --> 02:36:56.279
the code, you will see it 
you'lly creates a new instance 

02:36:56.280 --> 02:36:58.280
of class A.

02:36:59.973 --> 02:37:01.842
Again, this makes class A become
alive.  We can no longer remove 

02:37:01.843 --> 02:37:04.283
it.  
Note that class A doesn't 

02:37:04.284 --> 02:37:06.284
actually have 

02:37:08.020 --> 02:37:10.020
a constructor, so there's no 
code to look it.

02:37:12.717 --> 02:37:15.965
It only has a default that does 
nothing interesting here.  It 

02:37:15.966 --> 02:37:17.625
writes the created instance to 
this field and other field.  

02:37:17.626 --> 02:37:19.626
It's interesting to note here 
that it 

02:37:23.352 --> 02:37:25.381
doesn't actually make other 
fields live, because writing to 

02:37:25.382 --> 02:37:27.659
a field isn't observable.  You 
have to read the field to know 

02:37:28.886 --> 02:37:32.362
that the field exists.  
So now we have created the 

02:37:32.363 --> 02:37:35.853
instance of this class and 
executed a constructor we want 

02:37:35.854 --> 02:37:37.854
to call the run method.

02:37:41.782 --> 02:37:43.782
Again calling this run method 
calls it live.

02:37:44.841 --> 02:37:47.437
With every other live method we 
have to look at it and see what 

02:37:47.438 --> 02:37:51.570
it does.  If you look at run it 
first reading the other fields 

02:37:51.571 --> 02:37:54.827
to retrieve the instance, and 
this is the moment where this 

02:37:54.828 --> 02:37:58.917
field becomes live.  
Next we call A method on the 

02:37:58.918 --> 02:38:03.212
retrieved instance and that's 
where A method and class A 

02:38:03.213 --> 02:38:07.290
becomes live.  Now we would like
at the code of A med and see 

02:38:07.291 --> 02:38:09.291
what that does and mark all 
those effects.

02:38:10.984 --> 02:38:12.984
So this is how the basic 
analysis flow works.  

02:38:15.722 --> 02:38:17.416
Whenever you think about keep 
rules,  you have to keep in mind

02:38:17.417 --> 02:38:21.286
that's what it does.  How does 
this relate to Android?  How do 

02:38:21.287 --> 02:38:24.129
we actually know the entry point
of an Android application?  

02:38:26.782 --> 02:38:29.464
Well, that comes from your 
manifest file.  So this is a 

02:38:29.465 --> 02:38:31.465
very simplified manifest file.  

02:38:33.531 --> 02:38:35.531
One thing it does, it tells you 
that the 

02:38:37.013 --> 02:38:39.013
activity has the class and the 
graph as its implementation.

02:38:41.528 --> 02:38:43.528
Now, neither R8 nor ProGuard do 

02:38:44.833 --> 02:38:46.466
understand manifest files, and 
they shouldn't.  There's a 

02:38:46.467 --> 02:38:49.150
little tool that helps us to 
understand them, and that's 

02:38:49.151 --> 02:38:51.151
called APT.  

02:38:53.940 --> 02:38:56.071
APT during a build will 
preprocess all your resources, 

02:38:56.072 --> 02:38:58.745
and it creates corresponding key
rules for you.  Let's look at 

02:38:58.746 --> 02:39:01.195
this keep rule, and this is the 
first keep rule so we'll talk 

02:39:03.643 --> 02:39:07.134
about it in detail.  
So what it basically does is 

02:39:07.135 --> 02:39:10.195
says keep.  That's the simplest 
form.  Everything I mentioned 

02:39:10.196 --> 02:39:12.196
now you have to keep.

02:39:13.689 --> 02:39:15.735
Don't touch it or shrink it or 
rename it.  We want to keep a 

02:39:15.736 --> 02:39:18.651
class, and then we have a fully 
qualified class name, which 

02:39:21.690 --> 02:39:23.128
is my main class that came from 
this manifest.  There's 

02:39:23.129 --> 02:39:26.006
something more here.  Just the 
class name would only keep the 

02:39:26.007 --> 02:39:28.007
class.  It wouldn't actually 
tell the system 

02:39:31.611 --> 02:39:32.413
that this class is also 
substantiated, which is a big 

02:39:32.414 --> 02:39:34.414
difference.

02:39:35.498 --> 02:39:37.570
To tell it about that, we have 
to keep the constructors, and 

02:39:37.571 --> 02:39:39.571
that's what this in it line 
does.

02:39:42.239 --> 02:39:44.889
So this tells R8, we also need 
the constructors and we will 

02:39:44.890 --> 02:39:46.890
extent YAT this at runtime.

02:39:48.755 --> 02:39:49.965
Now R8 knows this is live and it
will look at the code.  Let's go

02:39:49.966 --> 02:39:51.966
there.

02:39:54.257 --> 02:39:56.301
This is the graph class and if 
I've removed all the function 

02:39:56.302 --> 02:39:58.302
bodies and everything that's not
important.  

02:40:00.641 --> 02:40:01.684
What you will see here is it 
actually doesn't have a 

02:40:01.685 --> 02:40:03.685
constructor.

02:40:04.971 --> 02:40:05.785
So that means our analysis ends 
right here.  We've seen the 

02:40:05.786 --> 02:40:07.786
class.

02:40:08.847 --> 02:40:11.090
There's no constructor, nothing 
to do.  

02:40:15.474 --> 02:40:17.474
Everyone one of that wrote an 
Android 

02:40:19.470 --> 02:40:20.453
app knows it happens in the on 
create method.  That's where the

02:40:20.454 --> 02:40:22.900
actual configuration happens.  
How does R8 know?  The keep rule

02:40:22.901 --> 02:40:24.901
never tooled it to look at 
uncreate.  

02:40:29.642 --> 02:40:31.642
Well, the trick here is that the
graph 

02:40:33.052 --> 02:40:36.872
extends this (?) Class, and if 
you follow this you will see 

02:40:36.873 --> 02:40:38.873
that eventually that extends 
activity.

02:40:41.408 --> 02:40:43.651
Now, activity is a library 
class, and as I said before, all

02:40:43.652 --> 02:40:45.713
library classes are always live.

02:40:50.040 --> 02:40:52.076
Hence, this on create method is 
also live.  As this uncreate in 

02:40:52.077 --> 02:40:54.077
the library 

02:40:55.126 --> 02:40:57.126
classes is live, all this 
overrides in 

02:40:58.327 --> 02:41:01.919
life subclasses look live.  You 
have to keep that alive to 

02:41:03.544 --> 02:41:05.448
understand how it actually 
works.  This is what marks on 

02:41:05.449 --> 02:41:07.449
create live.  
Let's take a look.

02:41:10.182 --> 02:41:12.623
This is my on create method, and
it looks like a standard on 

02:41:12.624 --> 02:41:15.695
create method.  It first does a 
setup and delegates to the 

02:41:15.696 --> 02:41:17.957
superclass.
I want to highlight two things 

02:41:17.958 --> 02:41:23.556
here.  The first is this find 
view by I.D.  This calls the 

02:41:23.557 --> 02:41:25.557
library method, and 

02:41:27.033 --> 02:41:28.888
what it does, at run dime it 
dynamically returns an object 

02:41:28.889 --> 02:41:30.961
somewhere from your view based 
on YUR layout.  

02:41:34.064 --> 02:41:36.064
Again, R8 cannot really 
understand this.  

02:41:36.096 --> 02:41:38.096
Because this I.D.

02:41:39.615 --> 02:41:41.893
is, again, defined in an XML 
file somewhere.  This is my 

02:41:41.894 --> 02:41:43.894
layout.  

02:41:47.645 --> 02:41:50.310
You can see it says this XY 
class is in my constraint layout

02:41:50.311 --> 02:41:53.162
and has this ID plot.  How do 
with figure this out in R8?  

02:41:53.163 --> 02:41:58.572
Again, APT comes to the rescue. 
This might look similar, but it 

02:41:58.573 --> 02:42:00.573
tells R8 

02:42:02.462 --> 02:42:04.281
that your lay outuses this XY 
class, and it will extent YAT it

02:42:04.282 --> 02:42:09.251
at runtime.  It's always the 
same principle.  

02:42:11.284 --> 02:42:13.284
Another thing I want to 
highlight here 

02:42:15.416 --> 02:42:17.416
is that during this at plot 
series where 

02:42:21.973 --> 02:42:23.973
you set up the plots, you use 
another R 

02:42:25.995 --> 02:42:29.727
identifier, which is are this 
R.XML.  They're different.  You 

02:42:29.728 --> 02:42:31.728
put them in your XML directory 
in your resources.

02:42:33.453 --> 02:42:34.476
There's no requirements so APT 
can't actually understand them. 

02:42:34.477 --> 02:42:39.964
When you use this somewhere, you
are responsible for all the keep

02:42:39.965 --> 02:42:44.087
rules that it may require.  Just
keep this in mind.  We'll come 

02:42:44.088 --> 02:42:48.223
back to that later.  So this is 
the basic analysis flow.  This 

02:42:48.224 --> 02:42:50.224
is how this basically works.  

02:42:53.369 --> 02:42:54.596
Now you might ask, okay, 200 
error messages, how does that 

02:42:54.597 --> 02:42:58.102
relate?  What went wrong there? 
This analysis looks reasonable. 

02:42:58.103 --> 02:43:00.103
Why does it fail?  

02:43:03.649 --> 02:43:06.117
The reason is that the NALZ 
analysis that we do is different

02:43:06.118 --> 02:43:10.820
from what the VM does, and one 
different in annotations.  The 

02:43:10.821 --> 02:43:14.882
Android VM doesn't really care 
about annotations at all.  They 

02:43:14.883 --> 02:43:16.945
have no meaning at runtime, 
unless you use protection.

02:43:21.251 --> 02:43:23.689
So if an annotation class is 
missing, the Android VM executes

02:43:23.690 --> 02:43:27.401
the code because it doesn't even
look at them.  In comparison R8 

02:43:27.402 --> 02:43:29.402
has to understand annotation 
classes because they might be 

02:43:30.867 --> 02:43:32.867
part of a keep rule, so R8 has 
to find 

02:43:34.327 --> 02:43:36.327
these classes and understand the
hierarchy.  

02:43:38.452 --> 02:43:40.433
If R8 can't, it will warn you 
about it.  That's a very common 

02:43:40.434 --> 02:43:42.434
source about these warnings, is 
missing annotation classes.

02:43:46.287 --> 02:43:48.340
The other thing is code R8 just 
can't understand.  Here's an 

02:43:48.341 --> 02:43:50.341
example, which is class value.  

02:43:51.386 --> 02:43:53.840
So class value is a concept from
Java 7, but it's not available 

02:43:53.841 --> 02:43:56.477
on the Android platform.  So 
this code will actually fail at 

02:43:56.478 --> 02:43:58.478
runtime.

02:43:59.533 --> 02:44:01.803
When the VM tries to execute it,
it will tell you this class is 

02:44:01.804 --> 02:44:03.804
missing.  Why does this still 
work?

02:44:07.550 --> 02:44:10.218
Because the creators of guava 
used this nifty trick to hide 

02:44:10.219 --> 02:44:12.219
the missing class.

02:44:13.505 --> 02:44:15.826
They load the class via 
reflection, and if that fails 

02:44:15.827 --> 02:44:17.827
they fall back to an alternative
implementation.  

02:44:19.901 --> 02:44:22.129
Now, want Android VM will 
understand this at runtime.  It 

02:44:22.130 --> 02:44:25.053
will throw in an exception and 
it gets caught and the 

02:44:25.054 --> 02:44:27.076
alternative is executed.  R8 
cannot understand this code.  

02:44:30.371 --> 02:44:33.036
It's just too complicated to it 
statically.  To if I can these 

02:44:33.037 --> 02:44:35.730
errors, you really have to look 
at all the examples and find 

02:44:35.731 --> 02:44:40.045
where they came from.  
Ultimately, that goes to these 

02:44:40.046 --> 02:44:42.505
five warning rules that you have
to add.  

02:44:45.966 --> 02:44:47.802
Now, the first three, they just 
disable warnings about certain 

02:44:47.803 --> 02:44:49.803
annotations from 

02:44:52.783 --> 02:44:54.783
the checker framework and those 
are 

02:44:56.081 --> 02:44:59.360
static NAMSZ frames not used at 
runtime at all.  The bottom two 

02:44:59.361 --> 02:45:01.361
are two classes not readily 
available on the Internet 

02:45:04.271 --> 02:45:06.906
platform, and they are typically
used by reflective records to 

02:45:06.907 --> 02:45:09.353
make it work at runtime.  Adding
these five rules, we get our 

02:45:11.226 --> 02:45:15.317
application to compile.  
That wasn't bad, right?  So we 

02:45:15.318 --> 02:45:17.318
looked at it and added five 

02:45:18.807 --> 02:45:20.638
rules and tah-dah, we have a 
small application.  

02:45:20.639 --> 02:45:22.639
Unfortunately, the runtime 
behavior of 

02:45:24.123 --> 02:45:24.531
my application has changed just 
ever so slightly because now it 

02:45:24.532 --> 02:45:26.532
crashes.

02:45:27.788 --> 02:45:31.468
That's the other problem you 
typically see.  

02:45:32.502 --> 02:45:35.389
Again, what happened here, 
right?  I explained to you how 

02:45:35.390 --> 02:45:37.390
the analysis works.  That looked
all fine and reasonable.

02:45:42.347 --> 02:45:44.347
The typical problem is 
reflection.  

02:45:44.783 --> 02:45:47.439
Because by its mere nature, 
reflection is about using a 

02:45:47.440 --> 02:45:52.579
dynamic runtime value to load a 
method or a class.  In static 

02:45:52.580 --> 02:45:54.580
analysis, they can't understand 
this.

02:45:56.656 --> 02:45:58.656
Dynamic values are the enemy of 
static analysis.  

02:45:59.101 --> 02:46:01.101
So how do we fix this?

02:46:02.260 --> 02:46:04.260
Well, we have to somehow figure 
out 

02:46:05.965 --> 02:46:08.228
how to tell R8 about these cases
of reflection and make R8 

02:46:08.229 --> 02:46:10.892
understand them.  That's really 
what key rules do.  What did I 

02:46:10.893 --> 02:46:14.796
do?  I we want to the Internet. 

02:46:18.068 --> 02:46:20.068
Unfortunately, the developers of
Android 

02:46:21.182 --> 02:46:23.182
plot put up this rule that says 
keep classes.

02:46:24.428 --> 02:46:26.428
Keep some classes and star, 
star.  

02:46:30.159 --> 02:46:32.836
What that means is it turns R8 
to tell it not to touch Android 

02:46:32.837 --> 02:46:36.967
plot at all.  It will fix the 
problem and run again, but it 

02:46:36.968 --> 02:46:38.968
will no longer shrink.

02:46:41.486 --> 02:46:43.486
So this cannot be the point in 
using R8.

02:46:46.785 --> 02:46:48.785
How can we improve on this?

02:46:51.554 --> 02:46:53.185
We can't unless we go on a 
forensic investigation.  Where 

02:46:53.186 --> 02:46:55.186
is all this reflection happening

02:46:56.278 --> 02:46:59.176
and what we have to add towards 
the configuration to make R8 

02:46:59.177 --> 02:47:01.438
understand it?  
Where do you find evidence?

02:47:05.112 --> 02:47:07.763
The first place to look is the 
the ADB log.  So I've 

02:47:07.764 --> 02:47:09.764
preprocessed this a bit here 

02:47:11.850 --> 02:47:13.307
so it's easier to read, but if 
go in Android Studio, you can 

02:47:13.308 --> 02:47:15.308
filter by 

02:47:17.468 --> 02:47:19.468
process ID, and this is what you
will see.

02:47:20.954 --> 02:47:22.595
So there is this lock statement 
saying that file definition not 

02:47:22.596 --> 02:47:25.916
found for A.  As such, this is 
not really helpful because I 

02:47:25.917 --> 02:47:27.757
don't understand what this is 
trying to tell me, but it's 

02:47:27.758 --> 02:47:30.644
really great because it gives me
a place to look and the source 

02:47:30.645 --> 02:47:32.645
code.

02:47:34.105 --> 02:47:36.344
So this is a big piece of 
advice.  If you write these kind

02:47:36.345 --> 02:47:39.186
of libraries and do a 
reflection, put in log in 

02:47:39.187 --> 02:47:41.499
statements.  It's not so 
important people understand the 

02:47:41.500 --> 02:47:45.799
message.  It's much more 
important people will find where

02:47:45.800 --> 02:47:47.853
the statement was generated.  
Because I have this log in 

02:47:47.854 --> 02:47:52.443
statement here, I can look at 
the code and see what it's 

02:47:52.444 --> 02:47:54.444
doing.

02:47:55.913 --> 02:47:58.374
Here's plot Java, and you can 
see down there it says (?) Not 

02:47:58.375 --> 02:48:01.251
found.  So what is going wrong 
here?

02:48:04.516 --> 02:48:06.578
As you can see, this does 
reflection.  There's this class 

02:48:06.579 --> 02:48:08.579
and get field and 

02:48:10.039 --> 02:48:12.491
styleable class is a class 
object.  Get field will get a 

02:48:12.492 --> 02:48:14.520
field from that class given the 
name.

02:48:17.585 --> 02:48:21.521
So this is an example of 
reflection on a class.  

02:48:24.967 --> 02:48:25.461
How is styleable name defined?  
That's where it went wrong.  

02:48:25.462 --> 02:48:29.121
It's tried to find a field code 
A that seems a strange field 

02:48:29.122 --> 02:48:31.122
name.  This is how it's defined.

02:48:34.670 --> 02:48:36.954
It's defined by means of get 
class and get name.  We have to 

02:48:36.955 --> 02:48:41.700
understand what this does.  La 
does get class do?  It's a 

02:48:41.701 --> 02:48:46.234
reflective invocation.  It will 
return in the current class.  If

02:48:46.235 --> 02:48:48.912
you're in this plot file and in 
the plot class, the current 

02:48:48.913 --> 02:48:53.798
class is the plot class itself 
but it can also be any of its 

02:48:53.799 --> 02:48:55.234
subclasses because at runtime 
this method might run a 

02:48:55.235 --> 02:48:57.235
different 

02:48:59.385 --> 02:49:01.200
context depending on how the 
virtual work.  

02:49:01.201 --> 02:49:03.201
Now let me get the name of this 
class, 

02:49:04.732 --> 02:49:06.732
and this seems to return A.

02:49:10.527 --> 02:49:13.590
Why did they name the class A?  
They didn't.  The problem is mag

02:49:13.591 --> 02:49:15.591
Knicks.

02:49:17.673 --> 02:49:19.673
R8 went ahead and say the class 

02:49:21.121 --> 02:49:23.806
thought plot is a long name and 
call it A.  We have to prevent 

02:49:23.807 --> 02:49:25.807
R8 from naming this 

02:49:28.292 --> 02:49:30.292
class or any of its sub  
classes.

02:49:33.248 --> 02:49:35.482
This is the corresponding keep 
rule.  It says keep Android 

02:49:35.483 --> 02:49:37.940
plot.plot and that means R8 
should keep the 

02:49:41.208 --> 02:49:43.469
class, not rename it, not 
optimize it.  We also have to 

02:49:43.470 --> 02:49:45.755
keep all the sub classes, so we 
have to say keep class 

02:49:50.455 --> 02:49:52.455
star extends come Android 
plot.plot. 

02:49:53.506 --> 02:49:55.993
This will keep all subclasses of
plots and the plot class itself,

02:49:55.994 --> 02:49:57.994
but is this actually what we 
want?  

02:50:00.295 --> 02:50:02.295
If you think again about what 
get class 

02:50:03.607 --> 02:50:05.607
does, it at runtime returns the 
class of the current object.

02:50:08.112 --> 02:50:10.617
Now, you can't only be the 
current class if you have been 

02:50:10.618 --> 02:50:12.618
extent YATed.

02:50:14.076 --> 02:50:16.548
If a class is never created, 
there's no way to get it via get

02:50:16.549 --> 02:50:22.325
class.  So our keep rules don't 
have to keep extra classes.  All

02:50:22.326 --> 02:50:24.326
we want is we want to prevent 
them 

02:50:25.599 --> 02:50:28.451
from being renamed, and that's 
where modifyrs come in.  This is

02:50:28.452 --> 02:50:31.722
a modifier for you.  This still 
says keep, but it says allow 

02:50:31.723 --> 02:50:33.723
shrinking.

02:50:35.196 --> 02:50:37.196
So it tells R8, if you see this 
plot 

02:50:39.127 --> 02:50:42.615
class, you're allowed to remove 
it if nobody uses it.  If you 

02:50:42.616 --> 02:50:45.044
keep it, don't rename it or 
optimize it.  This will fix the 

02:50:45.045 --> 02:50:48.011
problem, because now the plot 
class at runtime is called 

02:50:52.932 --> 02:50:54.057
plot, as will be all the 
subclasses.  

02:50:54.058 --> 02:50:56.139
So that was not too bad, right? 
You look at the code and come up

02:50:56.140 --> 02:50:58.175
with two key rules and the 
application will run or not.

02:51:01.629 --> 02:51:05.391
So it's still not working.  We 
have to do more forensics work. 

02:51:05.392 --> 02:51:07.392
What do we do?

02:51:08.660 --> 02:51:10.892
Go back to the ABD log, and the 
message has changed.  We see a 

02:51:10.893 --> 02:51:12.937
different exception.  Again, 
it's not really clear what this 

02:51:15.610 --> 02:51:17.610
is trying to tell me, but I have
an exception to look for.

02:51:22.159 --> 02:51:24.408
This says error while parsing 
key line paint that it's broke 

02:51:24.409 --> 02:51:27.466
with.
Why does this happen?  How do we

02:51:27.467 --> 02:51:30.121
find out?  We look at the code. 

02:51:34.025 --> 02:51:36.712
Here's the corresponding method.
We take a class and get all the 

02:51:36.713 --> 02:51:38.713
methods, 

02:51:40.201 --> 02:51:42.851
and next we compare the name of 
this method against some given 

02:51:42.852 --> 02:51:44.852
name we're 

02:51:46.259 --> 02:51:51.246
looking for two things can go 
wrong here.  We get a set of old

02:51:51.247 --> 02:51:55.153
methods so we might have removed
too many methods.  We get the 

02:51:55.154 --> 02:51:58.653
name of the methods so we might 
have renamed them.  These are 

02:51:58.654 --> 02:52:00.877
the two errors conditions to 
check, what you remove and 

02:52:00.878 --> 02:52:02.709
rename that you shouldn't?  I 
have to admit it's hard to 

02:52:02.710 --> 02:52:06.003
figure out what this code really
does unless you're the library 

02:52:06.004 --> 02:52:10.303
developer.  So the person who 
wrote this code initially knows 

02:52:10.304 --> 02:52:12.567
perfectly clearly ha this is 
doing, and at that point it 

02:52:14.430 --> 02:52:17.921
would have been really easy to 
write these keep rules.  So what

02:52:17.922 --> 02:52:19.922
does this do?

02:52:25.060 --> 02:52:28.558
Do you remember these?  We 
configure what there's supposed 

02:52:28.559 --> 02:52:30.559
to look like.

02:52:32.674 --> 02:52:35.344
Android plot can configure the 
graph based on some XML file, 

02:52:35.345 --> 02:52:38.836
and this is what the file looks 
like.  As you can see in there, 

02:52:38.837 --> 02:52:43.355
you will finds this line paint 
that's broke with.  What this 

02:52:43.356 --> 02:52:45.356
library will do, it will 

02:52:47.229 --> 02:52:49.229
take this XML file and it goes 
through 

02:52:51.711 --> 02:52:53.711
all the attributes in that and 
it will 

02:52:54.979 --> 02:52:56.613
call corresponding setters and 
getters on what it trying to 

02:52:56.614 --> 02:53:01.747
configure.  You call it the get 
line paint getter and set the 

02:53:01.748 --> 02:53:04.190
stroke with property.  This is a
very standard pattern of 

02:53:05.431 --> 02:53:07.707
configuring something at runtime
and it's a really great feature.

02:53:07.708 --> 02:53:12.217
If R8 sees this, it cannot 
understand this.  They cannot 

02:53:12.218 --> 02:53:15.267
make the connection between the 
XML file and actual classes.  

02:53:15.268 --> 02:53:19.345
Also, this is free form XML, we 
don't have APT to help us.  

02:53:22.431 --> 02:53:24.462
Instead, we have to do this 
ourselves.  This is the 

02:53:24.463 --> 02:53:26.509
corresponding keep rule.  What 
do we need to do?

02:53:29.772 --> 02:53:31.626
We don't want to keep any extra 
classes because what we try to 

02:53:31.627 --> 02:53:35.125
do here is take an object at 
runtime that already exists and 

02:53:35.126 --> 02:53:38.402
then we try to configure it by 
calling getters and setters.  

02:53:42.588 --> 02:53:42.990
So that's why we use keep class 
members.  That doesn't keep any 

02:53:42.991 --> 02:53:44.991
extra classes, 

02:53:50.247 --> 02:53:52.554
but it tells R8 if you keep a 
class in the Android plot 

02:53:52.555 --> 02:53:55.460
classes, keep these members and 
don't rename them.  

02:53:55.840 --> 02:53:57.840
What members do we want to keep?

02:53:58.845 --> 02:54:00.666
We keep getters, and what do 
they look like?  They return 

02:54:00.667 --> 02:54:02.792
some result, the three stars and
they start with get and 

02:54:04.251 --> 02:54:06.883
typically have no arguments.  So
that first line in there will 

02:54:06.884 --> 02:54:12.016
keep your getters.  Similarly, 
we can keep setters.  They don't

02:54:12.017 --> 02:54:14.247
return anything, but they start 
with set and they take a single 

02:54:16.529 --> 02:54:18.529
argument of some time.

02:54:22.891 --> 02:54:25.350
This rule will keep getters and 
setters so at runtime it just 

02:54:25.351 --> 02:54:29.063
happens.  
So one more keep rule.  Do you 

02:54:29.064 --> 02:54:32.560
think it will work now?  Let's 
take a look.  And yes, we made 

02:54:32.561 --> 02:54:34.561
it.

02:54:36.231 --> 02:54:37.459
So we edit a keep of keep rules 
and our application is Rupping 

02:54:37.460 --> 02:54:40.116
again.  Was it worth it?
This was a bit of an investment,

02:54:40.117 --> 02:54:43.396
right?  We had to look at the 
code and figure out what it 

02:54:43.397 --> 02:54:45.397
does.  Was this SKRUR knee 
worthwhile?

02:54:48.967 --> 02:54:50.967
Let's go back to the APK 
analyzer.

02:54:52.027 --> 02:54:54.027
Here you see the results.

02:54:56.918 --> 02:55:01.584
If you look at guava, that went 
from 1.3 megabytes to just 8K.  

02:55:01.585 --> 02:55:03.585
I know that's very TREEJSly 
because I 

02:55:04.913 --> 02:55:06.913
use a couple of couple few 
classes in 

02:55:08.579 --> 02:55:10.579
this huge collection, but for 
Android 

02:55:15.182 --> 02:55:17.466
plot it went from 180K to 100K. 
If you look at the app, it went 

02:55:17.467 --> 02:55:19.467
from 35K to 2K.

02:55:22.387 --> 02:55:25.265
2K is a lot closer to the 100 
lines of code I actually wrote 

02:55:25.266 --> 02:55:27.498
pause we removed all the 
unneeded parts that the build 

02:55:29.949 --> 02:55:32.595
system has created for us.  
&gt;&gt; Again, I've created this 

02:55:32.596 --> 02:55:35.247
graphic for you to make this a 
bit more visual.

02:55:38.732 --> 02:55:40.732
As you can see guava nearly 
disappeared.  

02:55:44.472 --> 02:55:47.454
Android plot halved and me app 
turned into this little SLIFer 

02:55:47.455 --> 02:55:50.668
there.  So it was a bit of a 
journey, but it really, really 

02:55:50.669 --> 02:55:55.557
paid off.  What's the take-away 
lessons here?  I hope I was able

02:55:55.558 --> 02:55:57.817
to convince you it actually 
makes sense to look into size.  

02:55:57.818 --> 02:56:00.267
If you build an app, no matter 
what your 

02:56:03.555 --> 02:56:06.022
target audience is, please 
invest into size and keep rules 

02:56:06.023 --> 02:56:10.701
and use ProGuard or R8 to shrink
your app.  But also, I hope I've

02:56:10.702 --> 02:56:15.621
shown you some ideas of how to 
make this easier.  And the first

02:56:15.622 --> 02:56:17.622
thing to really take 

02:56:19.093 --> 02:56:21.093
away here is you should consider
size 

02:56:22.194 --> 02:56:24.642
early on, because while you're 
writing your code, it's really, 

02:56:24.643 --> 02:56:27.722
really easy to also write your 
keep rules because you still 

02:56:27.723 --> 02:56:30.191
understand what that code is 
actually doing.  

02:56:32.284 --> 02:56:33.703
All the code examples we looked 
at, if you had just written 

02:56:33.704 --> 02:56:35.704
them, it would be easy to 
understand why this goes wrong.

02:56:38.032 --> 02:56:42.113
Also, you should add structure 
to your code to ease describing 

02:56:42.114 --> 02:56:47.284
reflective use.  You remember 
this getters and setters example

02:56:47.285 --> 02:56:49.285
I had where I said, okay, all 

02:56:50.385 --> 02:56:54.297
classes in Android plot keep the
getters and setters?  These are 

02:56:54.298 --> 02:56:56.298
simpler with interface that 
allows to tighten these up.

02:56:58.638 --> 02:57:00.880
If you had an interface, say, 
runtime configure object, you 

02:57:00.881 --> 02:57:04.979
could say in the keep rule every
object that extends runtime 

02:57:04.980 --> 02:57:07.423
configured, keep these getters 
and SERTZ.   Setters.

02:57:11.324 --> 02:57:12.762
It's independent of the actual 
application to be part of the 

02:57:12.763 --> 02:57:14.763
library.  

02:57:17.882 --> 02:57:19.882
Lastly this sounds obvious but 
it's important.

02:57:20.955 --> 02:57:23.419
You should test the optimize 
build.  The earlier you find 

02:57:23.420 --> 02:57:26.532
regressions, the easier to fix 
them.  You will still remember 

02:57:26.533 --> 02:57:28.341
what they changed and it will 
make it easy to come up with 

02:57:28.342 --> 02:57:30.342
keep rules.

02:57:34.749 --> 02:57:36.749
If you are a library developer, 
you 

02:57:37.807 --> 02:57:40.267
should really, really carefully 
provide keep rules because 

02:57:40.268 --> 02:57:42.268
there's this multiplymultiplier.

02:57:43.367 --> 02:57:46.053
If you make precise keep rules, 
all the users of your library 

02:57:46.054 --> 02:57:48.054
benefit from it, and a lot of 
apps will become smaller.

02:57:51.563 --> 02:57:53.412
Don't make this an afterthought.
Invest into keep rules while you

02:57:53.413 --> 02:57:58.086
build the library, while you 
design the library.  Publish 

02:57:58.087 --> 02:58:00.127
them where where people can find
them, bought that's what we all 

02:58:00.128 --> 02:58:02.198
do.  
We will search the Internet for 

02:58:02.199 --> 02:58:07.160
rules to use.  So put them on 
your home page, put them in the 

02:58:07.161 --> 02:58:11.542
read me file, make it visible.  
Lastly, consider using consumer 

02:58:11.543 --> 02:58:13.543
ProGuard 

02:58:15.048 --> 02:58:17.080
files when you're shipping via 
the IAR system, because it makes

02:58:17.081 --> 02:58:19.081
it completely transparent to 
library users.  

02:58:21.190 --> 02:58:21.592
When they enable ProGuard, they 
will automatically get your keep

02:58:21.593 --> 02:58:23.593
rules.

02:58:25.863 --> 02:58:31.373
Lastly, please give us feedback.
So we've built R8, and we've 

02:58:31.374 --> 02:58:35.296
tested it, and we believe it's a
drop-in replacement, but only 

02:58:35.297 --> 02:58:37.297
you can find that out.

02:58:38.988 --> 02:58:40.458
If you use ProGuard today, give 
R8 a try and tell us how it 

02:58:40.459 --> 02:58:42.459
worked for you.

02:58:45.198 --> 02:58:47.198
If you're not yet using ProGuard
try 

02:58:49.313 --> 02:58:50.961
out R8 and see how got the 
diagnostics this.  We have a 

02:58:50.962 --> 02:58:52.962
really responsive team and care 
about your feedback.

02:58:55.446 --> 02:58:57.897
Lastly, after this talk, you can
also see me at the sandbox or 

02:58:57.898 --> 02:58:59.898
find me outside if you want to 
have a chat.  

02:59:02.805 --> 02:59:04.805
More immediately, you can also 
find 

02:59:07.936 --> 02:59:09.936
feedback about this session 
going to Google.

02:59:10.938 --> 02:59:12.938
com

02:59:15.076 --> 02:59:17.146
IO/schedule. 
Thank you very much for your 

02:59:17.147 --> 02:59:19.147
attention.

02:59:20.342 --> 02:59:22.342
( Applause ) 

02:59:39.417 --> 02:59:41.865
&gt;&gt; Thank you for joining this 
satisfaction.

02:59:47.559 --> 02:59:50.275
Grand ambassadors will assist 
with going to the designated 

02:59:50.276 --> 02:59:53.752
exits.   
( Session ended ) 

04:21:52.637 --> 04:21:54.637
Test 

04:22:58.277 --> 04:23:00.277
Everyone.

04:23:05.458 --> 04:23:09.152
provisioning and authentication 
with drinkings.I work on 

04:23:09.153 --> 04:23:11.193
security for Android Things.    
&gt;&gt; WAYNE PIEKARSKI:  I'm a 

04:23:13.829 --> 04:23:17.705
Things in IoT.  Thanks for 
coming to our talk.going to talk

04:23:17.706 --> 04:23:19.706
to you about the 

04:23:23.233 --> 04:23:25.875
devices connected to the internt
and to else.  We'll go through 

04:23:25.876 --> 04:23:27.876
the whole process end 

04:23:32.165 --> 04:23:34.165
talk about how Google software 
platforms 

04:23:37.280 --> 04:23:39.280
IoT core help this make it 
easier to do.

04:23:41.997 --> 04:23:44.422
and you're here today is that 
IoT is anything we've seen 

04:23:44.423 --> 04:23:46.423
before.

04:23:51.587 --> 04:23:54.433
order in magnitude are larger 
than PCs IoT larger than them.

04:23:59.533 --> 04:24:01.533
devices on a daid basis.

04:24:04.651 --> 04:24:06.651
tens of hundreds of them doing 
interesting things.

04:24:08.916 --> 04:24:10.916
give you some hints on how to 
best build 

04:24:12.796 --> 04:24:14.796
how to connect them, secure 
them, and so forth.

04:24:16.488 --> 04:24:18.488
So firstly, let's discuss the 
basics of Android Things.

04:24:20.787 --> 04:24:23.638
Hopefully you've seen the intro 
talk.that cover what Android 

04:24:23.639 --> 04:24:25.639
Things is.

04:24:28.105 --> 04:24:30.961
Things is that it's based on a 
system on little small board.

04:24:34.455 --> 04:24:37.125
So the SOM contains the CPU, the
memory and supported by what we 

04:24:37.126 --> 04:24:39.126
call a board support package.

04:24:41.630 --> 04:24:43.630
And this provides the drivers, 
the 

04:24:48.158 --> 04:24:50.158
and everythings and updates and 
security from Google.

04:24:52.049 --> 04:24:54.049
it easier for developers to 
build IoT 

04:24:55.941 --> 04:24:57.941
that they're secure and kept up 
to date 

04:24:59.251 --> 04:25:02.914
kind of things that consumers 
need now with their devices.    

04:25:02.915 --> 04:25:04.915
One other thing that makes 
Android 

04:25:07.587 --> 04:25:11.249
supports really powerful types 
of professing on device.don't 

04:25:11.250 --> 04:25:13.250
have to do things in the Cloud 
but 

04:25:14.322 --> 04:25:16.322
processing and Machine Learning.

04:25:21.477 --> 04:25:23.477
device because we have phone 
level on the SOMs.

04:25:25.339 --> 04:25:27.339
Android so you can use the 
familiar 

04:25:29.003 --> 04:25:31.003
Android Studio and the existing 
code you 

04:25:32.472 --> 04:25:37.360
developer.  If you're using 
Android Things if Android 

04:25:37.361 --> 04:25:39.361
development before.

04:25:40.621 --> 04:25:42.455
can learn more about that.     
What we're going to focus on 

04:25:42.456 --> 04:25:47.964
today advantage of all these 
things that come make your IoT 

04:25:47.965 --> 04:25:51.071
devices easier and better for 
you.     So with that in mind, 

04:25:51.072 --> 04:25:54.741
let's get going to use 
throughout this talk to about.

04:25:57.820 --> 04:26:01.885
We're going to build and IoT 
washing not?  Everyone's excited

04:26:01.886 --> 04:26:03.886
about using Machine 

04:26:07.995 --> 04:26:09.995
therefore we should be using a 
washing 

04:26:14.905 --> 04:26:16.905
that looks at your launder and 
it 

04:26:19.603 --> 04:26:22.048
allow you to see how your 
laundry's watt work.

04:26:25.517 --> 04:26:27.517
We could could call our new 
product TensorWash.

04:26:28.990 --> 04:26:30.990
When we built this TensorWash 
washing 

04:26:32.685 --> 04:26:36.557
a control panel on the front 
because you it manually.  

04:26:36.558 --> 04:26:38.558
Because Android Things supports 

04:26:39.818 --> 04:26:41.818
you could have a screen on the 
front, 

04:26:43.297 --> 04:26:48.032
audio playing.  That's one 
option that you could build the 

04:26:48.033 --> 04:26:50.474
deluxe model of the machine.    
However, if you want to make a 

04:26:53.929 --> 04:26:57.011
then you probably want to get 
rid of the display.going to 

04:26:57.012 --> 04:26:59.012
leave that out for this example.

04:27:01.284 --> 04:27:04.179
enabled and a few buttons on the
front everything is going to be 

04:27:04.180 --> 04:27:08.899
controlled by about in a bit.   
The real magic of a machine like

04:27:11.338 --> 04:27:13.338
connected to the Internet.

04:27:16.040 --> 04:27:18.040
remotely, view what the camera 
sees, you 

04:27:19.311 --> 04:27:22.792
cycle when you're at work or 
driving home, whatever.user is 

04:27:22.793 --> 04:27:24.793
not in the house and potentially
anywhere in the world.

04:27:27.704 --> 04:27:29.530
We don't want to restrict it 
from being close by in the 

04:27:29.531 --> 04:27:31.531
house.

04:27:34.819 --> 04:27:36.819
connection with a Cloud solution
behind that.

04:27:41.948 --> 04:27:43.948
features so it can have points 
for not wasting water too much.

04:27:45.206 --> 04:27:47.206
It could report faults to a 
service department.

04:27:48.468 --> 04:27:50.468
support all this, the machine 
needs Wi-Fi.

04:27:53.609 --> 04:27:55.872
cheat by plugging an Ethernet 
cable into it.     We have this 

04:27:55.873 --> 04:28:00.552
washing machine.Cloud.  We need 
to share state with the Cloud 

04:28:02.582 --> 04:28:05.249
can control the device.  There 
are many possible Cloud 

04:28:05.250 --> 04:28:07.250
services.We'll talk about a few 
today.

04:28:11.202 --> 04:28:13.202
kind of thing work, we need to 
firstly network.

04:28:16.124 --> 04:28:18.124
Many devices these days are 
Wi-Fi-based.

04:28:21.259 --> 04:28:23.259
requires an SSID and a 
passphrase to join the network.

04:28:26.762 --> 04:28:28.762
devices don't have a keyboard or
display be handled by the phone.

04:28:34.342 --> 04:28:36.342
needs to spin up a Wi-Fi access 
point of its own.

04:28:37.834 --> 04:28:39.834
connects to it and sends the 
log-in details over.

04:28:42.105 --> 04:28:44.976
reconnects to the network and 
uses that information.anything 

04:28:44.977 --> 04:28:50.518
goes wrong for any reason, the 
knowing what happened.  It can 

04:28:50.519 --> 04:28:53.760
be problematic for some phones 
Wi-Fi networks.  Many developers

04:28:53.761 --> 04:28:56.622
find this challenging this 
right.  We'll go through some 

04:28:56.623 --> 04:28:58.623
hints on how to better.

04:29:02.327 --> 04:29:06.244
And next, the device needs to 
know device are.  So you want to

04:29:06.245 --> 04:29:08.245
make sure that the 

04:29:09.907 --> 04:29:13.992
and controlled only by the owner
of the that they trust.  So we 

04:29:13.993 --> 04:29:16.424
need some kind of authentication
that needs to be issued by a 

04:29:16.425 --> 04:29:21.093
server that control this token. 
We put it on the device and then

04:29:23.964 --> 04:29:25.964
what the device uses to contact 
the 

04:29:27.834 --> 04:29:30.698
If the user factory resets the 
forget this token and everything

04:29:30.699 --> 04:29:32.699
else.

04:29:34.347 --> 04:29:37.227
should reset itself so that a 
different machine and none of 

04:29:37.228 --> 04:29:39.228
the previous history is 
preserved.

04:29:41.728 --> 04:29:45.800
So now, our TensorWash is all 
connected and ready to go.So 

04:29:45.801 --> 04:29:47.801
when the phone device and Cloud 
all 

04:29:51.938 --> 04:29:53.938
over a TLS connection such as 
HGDPS so secure in that way.

04:29:58.639 --> 04:30:01.707
We don't want to -- Google 
services HTTPS.  We're starting 

04:30:01.708 --> 04:30:03.708
to enforce this by default.

04:30:07.239 --> 04:30:08.456
it hard now for you to use 
unencrypted the security 

04:30:08.457 --> 04:30:10.457
implications.

04:30:13.025 --> 04:30:15.025
devices like this that everybody
does security properly.

04:30:18.522 --> 04:30:20.522
tiny IoT companies making simple
toys 

04:30:22.241 --> 04:30:24.241
their device won't be the 
problem and 

04:30:26.120 --> 04:30:28.966
unexpected impacts in ways you 
didn't your device is out in the

04:30:28.967 --> 04:30:34.269
world.     That's it.  That's 
the key concepts of what you a 

04:30:34.270 --> 04:30:37.763
washing machine that we're 
building to the Cloud.  So we 

04:30:37.764 --> 04:30:42.049
need to set up Wi-Fi.the 
credentials.  We need to connect

04:30:42.050 --> 04:30:46.548
with encryption.lot more to it. 
I'm going to let Darren do a 

04:30:46.549 --> 04:30:48.549
deep dive 

04:30:49.601 --> 04:30:53.305
of the key concepts here and a 
bit more what's going on.     &gt;&gt;

04:30:53.306 --> 04:30:55.306
DARREN KRAHN:  Cool.

04:30:57.365 --> 04:31:00.229
talk about a few of these key 
concepts relationships between 

04:31:00.230 --> 04:31:02.909
devices which is doing when we 
provision devices.

04:31:07.439 --> 04:31:09.439
These concepts are distinct but 
intertwined.

04:31:11.517 --> 04:31:13.517
talk about authentication, 
authorization and attestation.

04:31:17.443 --> 04:31:19.443
auction, to aukt something is to
prove 

04:31:21.726 --> 04:31:23.726
that it's authentic.

04:31:25.375 --> 04:31:27.375
We aukt official documents and 
signatures.

04:31:29.044 --> 04:31:31.287
We aukt each others by face 
recognition.  It's intuitive.

04:31:34.947 --> 04:31:36.947
Computers aukt us by using 
passwords.

04:31:39.479 --> 04:31:41.479
time in our daily lives without 
even thinking about it.

04:31:43.370 --> 04:31:45.370
What about when one computing 

04:31:48.248 --> 04:31:53.157
another computing device?  This 
is less intuitive.involves 

04:31:53.158 --> 04:31:55.158
secret data.

04:31:58.913 --> 04:32:00.913
secret data and all other 
computers don't.

04:32:02.841 --> 04:32:04.841
that I the want talk to about.

04:32:06.918 --> 04:32:09.359
bearer tokens.  These are very 
common and will relate 

04:32:10.797 --> 04:32:12.797
TensorWash example.

04:32:18.574 --> 04:32:20.574
So cryptographic keys and 

04:32:24.508 --> 04:32:27.162
.  This is how your computer 
uses hchts server.

04:32:30.657 --> 04:32:32.657
It verifies verifying 
certificate and 

04:32:33.723 --> 04:32:35.723
you already test or that you 
expect.

04:32:39.225 --> 04:32:41.225
authored that authenticated is 
something you trust.

04:32:42.499 --> 04:32:46.354
needproof of a key.  It's not 
transferred over the network the

04:32:46.355 --> 04:32:48.355
private part of the key.

04:32:50.088 --> 04:32:52.088
computer has possession of it 
and it gives us proof of that.

04:32:55.207 --> 04:32:57.207
So doing this right in practice 
can 

04:32:58.684 --> 04:33:01.739
building these protocols can be 
really hard.recommend you don't 

04:33:01.740 --> 04:33:05.865
build this yourself.that does 
it.  If you use Android Things, 

04:33:05.866 --> 04:33:07.866
we have 

04:33:10.764 --> 04:33:15.659
HTTPS and TLS built in so you 
deposit have to implement this. 

04:33:15.660 --> 04:33:18.518
I like to compare this to an 
airport passport check.take your

04:33:18.519 --> 04:33:20.583
passport and you come up to the 
check.

04:33:23.653 --> 04:33:24.675
there is going to validate 
specific information on the 

04:33:24.676 --> 04:33:30.836
passport.They're going to verify
that it's from trust.  And then 

04:33:30.837 --> 04:33:32.837
they're going to do a proof 

04:33:34.303 --> 04:33:36.759
which in the case of the 
passport is a the face of the 

04:33:36.760 --> 04:33:38.760
person standing in front of 
them.

04:33:42.864 --> 04:33:45.310
I also want to talk about bearer
tokens.little bit differently.

04:33:49.601 --> 04:33:51.601
another in order to verify them.

04:33:53.718 --> 04:33:55.972
computer that sends it but 
meaningful to verifies it.

04:34:00.462 --> 04:34:02.462
The token is implied by the 
token and 

04:34:03.522 --> 04:34:06.570
decision as to whether it's an 
authentic token or not.like to 

04:34:06.571 --> 04:34:08.571
compare this to the example of a
movie ticket.

04:34:10.028 --> 04:34:12.909
to the ticket stand and buy a 
movie your bearer token.

04:34:16.004 --> 04:34:19.266
You present that token and it 
you're in.  You pass it to your 

04:34:19.267 --> 04:34:22.526
friend and now that token and 
they can get into the movie.

04:34:28.857 --> 04:34:30.857
used to auction than in the 
past.

04:34:32.946 --> 04:34:34.946
with the user name and password.

04:34:37.439 --> 04:34:39.439
your password on every page on 
that site.

04:34:45.878 --> 04:34:47.878
issue your browser a bearer 
token and it 

04:34:48.984 --> 04:34:50.984
amount of time and have access 
to your means on that website.

04:34:54.712 --> 04:34:56.772
So you don't have to keep 
entering time.

04:35:01.909 --> 04:35:03.909
You can authenticate it once and
you 

04:35:06.625 --> 04:35:08.625
authentication mechanism from 
that point forward.

04:35:09.889 --> 04:35:11.726
So let's think about 
authentication in the context of

04:35:11.727 --> 04:35:14.798
IoT.There's a few aspects that 
are worth calling out.

04:35:17.891 --> 04:35:19.891
the authentication needs to go 
both ways.

04:35:21.160 --> 04:35:23.160
services and other guyses around
the 

04:35:25.441 --> 04:35:27.441
that device and that device 
needs to 

04:35:30.300 --> 04:35:32.300
services and other devices 
around it.

04:35:35.029 --> 04:35:37.029
would authenticate a web service
the 

04:35:41.333 --> 04:35:44.794
would authenticate a web service
such as HTTPS or TLS.     

04:35:44.795 --> 04:35:46.826
Authentication does not 
necessarily identity.

04:35:50.091 --> 04:35:51.509
Often we think of it that way, 
but it necessarily have to be 

04:35:51.510 --> 04:35:53.510
that way.

04:35:54.981 --> 04:35:56.981
restricted web service.

04:35:59.704 --> 04:36:01.704
connect to that web service.

04:36:03.993 --> 04:36:06.660
clients are actually instances 
of that web service.authenticate

04:36:06.661 --> 04:36:08.661
that it's one of your which one.

04:36:13.938 --> 04:36:19.160
You can actually do anthat case.
We need to bind it to meaningful

04:36:19.563 --> 04:36:21.994
expectations.can make sure we're
authenticating, what 

04:36:23.423 --> 04:36:26.067
authenticate.     Let me give 
you a couple examples.

04:36:29.371 --> 04:36:31.371
front of you and you want to 

04:36:34.723 --> 04:36:36.723
something physical on the 
device.

04:36:38.594 --> 04:36:41.055
display a code both on your 
phone and that's a physical 

04:36:41.056 --> 04:36:43.056
binding of that authentication.

04:36:44.703 --> 04:36:49.118
common experience when you do a 
like that.     But you can also 

04:36:49.119 --> 04:36:52.829
use a sticker on the device or a
bar code.We'll talk about that a

04:36:52.830 --> 04:36:54.830
little bit more.

04:36:57.509 --> 04:36:59.509
an encrypted channel in order to

04:37:00.596 --> 04:37:02.596
your authentication to that 
channel.

04:37:05.515 --> 04:37:08.504
standard protocol like TLS or 
HTTPS, you.  You don't have to 

04:37:08.505 --> 04:37:10.505
worry about it.

04:37:12.699 --> 04:37:14.699
something between two devices, 
for 

04:37:15.987 --> 04:37:17.987
support that kind of protocol, 
you need to think about this.

04:37:21.488 --> 04:37:23.949
So let's go back to our 
TensorWash at the authentication

04:37:23.950 --> 04:37:26.973
that needs to happen.completely 
unprovisioned state.

04:37:30.432 --> 04:37:32.432
machine out of the box.

04:37:34.301 --> 04:37:36.301
Let's assume our smart phones 
are set up.

04:37:38.597 --> 04:37:40.597
authenticate web service 
services using 

04:37:43.966 --> 04:37:45.966
case we have a Google account 
we've 

04:37:47.038 --> 04:37:50.283
those web services are able to 
authenticate the phone.a two-way

04:37:50.284 --> 04:37:53.563
authenticated relationship 
there.     The first thing we 

04:37:53.564 --> 04:37:55.564
need to do is we this new 
device.

04:37:58.276 --> 04:38:01.553
We want to send it credentials 
which valuable.  Wi-Fi 

04:38:01.554 --> 04:38:03.554
passwords, access to Cloud 
services.

04:38:05.237 --> 04:38:07.237
to make sure we're sending it to
the it over.

04:38:11.182 --> 04:38:13.182
Once we've provisioned that, we 

04:38:14.683 --> 04:38:16.720
where we have two-way 
authenticated TensorWash machine

04:38:16.721 --> 04:38:18.721
and Cloud services.

04:38:21.665 --> 04:38:23.665
here, Firebase and Cloud IoT 
Core that 

04:38:27.203 --> 04:38:29.649
For both of these we want a 
two-way Again, authenticating 

04:38:29.650 --> 04:38:31.650
web services.

04:38:36.151 --> 04:38:38.151
HTTPS and we'll use different 
forms 

04:38:40.229 --> 04:38:43.105
more later to authenticate the 
device be provisioned during 

04:38:43.106 --> 04:38:45.106
this process from the phone.

04:38:48.815 --> 04:38:50.815
So you may have noticed that 

04:38:52.068 --> 04:38:57.219
that didn't go both ways.  What 
about this one in yellow.it okay

04:38:57.220 --> 04:38:59.258
for the TensorWash to come out 
authenticate the phone that's 

04:38:59.259 --> 04:39:01.259
going to set it up?

04:39:03.968 --> 04:39:05.968
this way because this is really 
common with consumer devices.

04:39:07.685 --> 04:39:10.935
When they come out of the box, 
there's a clear state.don't have

04:39:10.936 --> 04:39:15.010
any notion of who their owner is
or who they trust.They're just 

04:39:15.011 --> 04:39:17.011
available to be set up.

04:39:19.599 --> 04:39:21.599
this case.  Mostly that's okay.

04:39:24.679 --> 04:39:26.679
with credentials it's going to 
give out.

04:39:27.940 --> 04:39:29.940
credentials so it's less 
important.

04:39:31.610 --> 04:39:34.063
that needs to authenticate the 
TensorWash device.     But there

04:39:34.064 --> 04:39:36.064
are cases, for example, 

04:39:38.967 --> 04:39:41.845
mass rollout scenarios where you
want set up.

04:39:46.455 --> 04:39:48.455
It comes out of the box with a 
notion 

04:39:49.921 --> 04:39:51.921
This can be as simple as taking 
the 

04:39:54.031 --> 04:39:56.031
on the device so when it wakes 
up and 

04:39:58.766 --> 04:40:01.612
server that fill it in with the 
rest of information that it 

04:40:01.613 --> 04:40:03.613
needs to get configured.

04:40:05.704 --> 04:40:07.704
bit out for our talk.

04:40:09.654 --> 04:40:11.720
in a clear state.     So we've 
talked about 

04:40:15.796 --> 04:40:18.657
whether something is authentic.
authorization which is checking 

04:40:18.658 --> 04:40:20.658
if 

04:40:21.958 --> 04:40:27.284
what it's trying to do.check.  
You arrive at the airport with a

04:40:27.285 --> 04:40:31.863
valid doesn't mean you're going 
to pass the check.they're going 

04:40:31.864 --> 04:40:33.864
to see if you're scheduled for a
flight that day.

04:40:36.554 --> 04:40:38.554
Just because your passport is an

04:40:39.825 --> 04:40:44.557
you can pass.  Similarly with a 
movie ticket head to the theater

04:40:44.558 --> 04:40:46.778
with a movie ticket not get into
your movie.

04:40:50.659 --> 04:40:52.945
different showing.  And there's 
an authorization that 

04:40:56.412 --> 04:40:58.412
even though your movie ticket is
perfectly authentic.

04:41:06.336 --> 04:41:08.336
So I want to use the example of 
OAuth 2.0 for the web.

04:41:11.439 --> 04:41:13.439
may or may not work for a given 
IoT use case.

04:41:15.124 --> 04:41:17.124
example and I want to pull in a 
few concepts that are important.

04:41:18.380 --> 04:41:20.399
Even if you don't use it, you 
need to concepts.

04:41:25.079 --> 04:41:28.132
The biggest is token scope and 
token lifetime.can the bearer of

04:41:28.133 --> 04:41:30.133
this token get access to?

04:41:33.328 --> 04:41:35.328
describes when the token 
expires.

04:41:36.898 --> 04:41:38.898
There's this notion of refresh 

04:41:41.125 --> 04:41:42.150
ngsorness which accesses the 
resource you're trying to get 

04:41:42.151 --> 04:41:44.151
to.

04:41:45.410 --> 04:41:46.970
These tokens are short lived 
narrowly scoped and 

04:41:46.971 --> 04:41:48.971
self-contained.

04:41:50.644 --> 04:41:56.001
The resource server can be 
optimized.back end lookup.  It 

04:41:56.002 --> 04:41:57.627
looks at the token it received 
and decision with the 

04:41:57.628 --> 04:42:00.488
information there.     Refresh 
tokens, on the other hand, 

04:42:05.467 --> 04:42:07.945
access tokens when the old 
access token expires.lived and 

04:42:07.946 --> 04:42:09.946
more widely scoped.

04:42:12.428 --> 04:42:15.082
for a variety of different 
scopes.specifically.

04:42:18.533 --> 04:42:20.533
What this enables, this enables 
the 

04:42:22.395 --> 04:42:24.395
that's making the decision on 
whether it 

04:42:25.666 --> 04:42:28.541
refresh token, it can decide if 
there's authorization.  That's 

04:42:28.542 --> 04:42:30.542
what you want to have with IoT 
as well.

04:42:32.661 --> 04:42:35.312
You want to have that passive 
sxrartion.  Soexpiration.  So if

04:42:35.313 --> 04:42:37.313
it's revoked.

04:42:38.782 --> 04:42:42.633
Once the access tokens expire, 
there's access oh token.  You 

04:42:42.634 --> 04:42:44.634
don't want to be in a situation 

04:42:46.126 --> 04:42:48.126
have to pull an unused IoT 
device out of 

04:42:51.086 --> 04:42:53.116
does a factory reset to 
deauthorize it.passively.

04:42:58.852 --> 04:43:03.355
This is a snippet from the spec 
flow.  You can see in the middle

04:43:03.356 --> 04:43:05.356
the access 

04:43:07.633 --> 04:43:09.633
access a protected resource 
server in 

04:43:12.563 --> 04:43:14.563
the access tokens expire and an 
error back.

04:43:19.113 --> 04:43:21.983
refresh token get another access
token.you visual identities that

04:43:21.984 --> 04:43:27.701
a little bit better.     Let's 
think about authorization in an 

04:43:27.702 --> 04:43:29.702
IoT device.  We talked about 
authentication needs 

04:43:33.064 --> 04:43:35.064
ways, authorization needs to go 
both 

04:43:37.369 --> 04:43:39.369
think about it in both 
directions.

04:43:42.686 --> 04:43:47.159
access to the device, who can 
send so forth.  What does the 

04:43:47.160 --> 04:43:49.160
device have access to?

04:43:51.675 --> 04:43:55.818
does it have when it connects to
a web service, for example?     

04:43:55.819 --> 04:43:58.914
We want to use the principle of 
least privilege.want to give 

04:43:58.915 --> 04:44:02.163
more privilege than necessary.
common problem with IoT.

04:44:07.087 --> 04:44:09.087
just give the device total 
authorization 

04:44:12.395 --> 04:44:13.613
connecting to because you won't 
have any and everything will 

04:44:13.614 --> 04:44:15.614
just work.

04:44:19.758 --> 04:44:21.758
only using 10% of that 
authorization, if 

04:44:24.257 --> 04:44:26.291
hacked, now the attacker has 
access to weren't using it.

04:44:29.981 --> 04:44:35.057
You also want the expire -- I 
ex-operation.  You want to be 

04:44:35.058 --> 04:44:38.543
careful when passing your 
tokens.Tokens are made to be 

04:44:38.544 --> 04:44:40.544
passed for verification, for 
example.

04:44:43.662 --> 04:44:45.662
authenticated the recipient 
before you send your token.

04:44:49.576 --> 04:44:51.576
you're sending it to a web 
service for it's over HTTPS.

04:44:56.107 --> 04:44:58.107
provisioning a new device like 
our 

04:45:01.236 --> 04:45:03.236
it before you send over the new 
token.

04:45:04.438 --> 04:45:06.438
As you'll see in a

04:45:10.828 --> 04:45:15.347
manage tokens for you don't have
to management, which is great.  

04:45:15.348 --> 04:45:17.348
Let's go back and look at 
scenario specifically.

04:45:20.438 --> 04:45:23.095
We started on this state where 
we the phone is authorized to 

04:45:23.096 --> 04:45:25.096
set up devices with Cloud 
services.

04:45:27.565 --> 04:45:32.429
The phone is authorized to set 
it up policies about that.     

04:45:32.430 --> 04:45:35.073
Where we want to be after we 
two-way authorization with 

04:45:35.074 --> 04:45:37.074
Firebase.

04:45:38.979 --> 04:45:40.979
Firebase realtime database.

04:45:43.878 --> 04:45:48.163
sync data up to the Cloud.the 
device.  There's an 

04:45:48.164 --> 04:45:50.801
authorization where authorized 
to give commands to the 

04:45:55.947 --> 04:45:57.947
authorized to push data back 
into Firebase.

04:46:00.459 --> 04:46:02.459
With Cloud IoT Core, we put the 

04:46:03.751 --> 04:46:05.751
because we're going to use it 
for metrics.

04:46:08.647 --> 04:46:10.647
out into the Cloud IoT Core 
project.

04:46:12.980 --> 04:46:14.826
push into that project.     
We'll show you the details how 

04:46:14.827 --> 04:46:16.827
you set this up.

04:46:19.762 --> 04:46:21.762
talk about one more key concept 
and that is attestation.

04:46:25.663 --> 04:46:27.663
Attestation is really proving 
the 

04:46:30.358 --> 04:46:34.036
device with state, including the
current device.  It's a special 

04:46:34.037 --> 04:46:36.037
kind of authentication.

04:46:37.280 --> 04:46:39.280
this to be possible, the device 
needs to 

04:46:40.802 --> 04:46:42.802
of credential that can use to 
prove itself.

04:46:44.688 --> 04:46:46.688
the factory so when it comes out
of the 

04:46:49.164 --> 04:46:52.023
genuine instance of that 
particular product.     It's 

04:46:52.024 --> 04:46:57.134
worth mentioning that 
cryptographic key.  Instead of 

04:46:57.135 --> 04:46:59.135
the attestation assertion 

04:47:00.424 --> 04:47:02.424
the device saying I'm a genuine 
device 

04:47:05.145 --> 04:47:07.145
it's a bit more like, this 
particular 

04:47:09.038 --> 04:47:11.038
secure lil held by a device 
running in a secure mode.

04:47:12.518 --> 04:47:14.518
useful because it allows us to 
bind the 

04:47:15.779 --> 04:47:17.779
else that uses the key, some 
other kind instance.

04:47:19.864 --> 04:47:21.864
Le' see in the example later we 
use 

04:47:23.342 --> 04:47:25.342
connect to Cloud IoT Core.

04:47:28.443 --> 04:47:30.443
So in Android Things 
specifically 

04:47:32.460 --> 04:47:34.460
you can attestproperties.

04:47:40.488 --> 04:47:45.602
twice device.  You can verify 
device state like I was about.  

04:47:45.603 --> 04:47:47.603
The important one and the ones 
we pull 

04:47:49.503 --> 04:47:51.503
verified boot state where this 
device is 

04:47:54.194 --> 04:47:56.833
approved software for that 
device.attributes of the 

04:47:56.834 --> 04:47:58.834
cryptographic key.today.

04:48:01.716 --> 04:48:06.373
So this is what a certificate 
chain looks like.levels deep.  

04:48:06.374 --> 04:48:08.621
At the top we have the Android 
Things managed by Google.

04:48:12.093 --> 04:48:14.093
Things attestation certificates.

04:48:16.584 --> 04:48:18.584
the product specific CA.

04:48:21.744 --> 04:48:26.029
context of the Android Things 
developer with.  Every time you 

04:48:26.030 --> 04:48:28.030
create a product on 

04:48:30.308 --> 04:48:32.308
will be an intermediate CA 
assigned to 

04:48:33.770 --> 04:48:37.033
So the next level we have the 
device specific CA.to each 

04:48:37.034 --> 04:48:39.034
device in the factory.  This is 
unique per device.

04:48:43.834 --> 04:48:45.834
contains an ID for that device.

04:48:47.518 --> 04:48:49.518
that box, this is the one that 
it has.

04:48:50.579 --> 04:48:52.579
application key and 
certificates.

04:48:54.866 --> 04:48:56.866
application and the certificate 
is 

04:49:00.797 --> 04:49:02.857
device specifics A which is by 
the on that device.

04:49:07.385 --> 04:49:09.385
So back in our TensorWash 
example, 

04:49:11.263 --> 04:49:13.263
with the TensorWash device up to
the phone.

04:49:14.574 --> 04:49:17.217
verification, remember the phone
is authenticate the device.

04:49:20.487 --> 04:49:22.515
That's where we're using 
attestation.     So quick 

04:49:22.516 --> 04:49:26.811
review.  We talked about 
authentication, that something 

04:49:26.812 --> 04:49:28.812
is genuine or valid.

04:49:32.568 --> 04:49:34.568
that it is allowed it's doing 
what it's 

04:49:36.261 --> 04:49:38.261
attestation that it's using a 
computing device specifically.

04:49:39.931 --> 04:49:40.951
Wane will show us how to do 
these things with Android 

04:49:40.952 --> 04:49:42.952
Things.     &gt;&gt; WAYNE PIEKARSKI: 
Okay.

04:49:46.476 --> 04:49:48.721
something like this using the 
various Android Things and from 

04:49:48.722 --> 04:49:51.995
other services that Google 
provides.     The first step is 

04:49:51.996 --> 04:49:54.459
we can use connections.

04:49:57.944 --> 04:49:59.944
So Nearby connections is great 
that 

04:50:02.184 --> 04:50:04.184
nearby devices and it 
establishes an channel.

04:50:06.673 --> 04:50:08.673
Under the hood it uses 
Bluetooth, BLE, 

04:50:10.340 --> 04:50:12.340
spots, it uses whatever is 
available to it at the time.

04:50:14.841 --> 04:50:16.841
other nice thing is it provides 
a short 

04:50:18.538 --> 04:50:20.538
both sides that you can display 
on screens.

04:50:21.813 --> 04:50:24.044
used devices where it shows a 
little that's great in most 

04:50:24.045 --> 04:50:26.045
cases.

04:50:27.724 --> 04:50:30.589
washing machine doesn't have a 
screen on it.     So we don't 

04:50:30.590 --> 04:50:34.254
have quite enough we're going to
talk about how to address that 

04:50:34.255 --> 04:50:37.516
in a minute.Nearby connections 
is the first building use.

04:50:40.581 --> 04:50:42.581
If we look at code snippets, 
these are 

04:50:43.886 --> 04:50:45.886
version of a nearby connection 
sample.

04:50:47.971 --> 04:50:49.971
nearby connections client at the
top.options.

04:50:53.266 --> 04:50:55.266
We use the default value of 
P2P_Cluster.

04:50:56.315 --> 04:50:58.315
matter so much what we use here.

04:50:59.771 --> 04:51:01.771
process, we need to have a 
service ID.

04:51:03.634 --> 04:51:05.634
TensorWash.  That's our 
product's ID.

04:51:08.568 --> 04:51:10.568
apple or Android.  They call it 
a service ID.

04:51:13.489 --> 04:51:15.489
what your device is, whatever 
you want to call it.

04:51:18.008 --> 04:51:20.008
endpoint discovery callback.

04:51:23.711 --> 04:51:25.711
code whenever a new device is 
discovered.

04:51:29.476 --> 04:51:31.476
view and UI that updates showing
we want 

04:51:32.960 --> 04:51:36.014
more than one device being 
available at a time.selects the 

04:51:36.015 --> 04:51:38.457
one they want, they can pick it.
establish a connection.

04:51:41.918 --> 04:51:43.918
On the device side Nearby 
supports 

04:51:45.799 --> 04:51:49.444
method where you basically 
provide a device.  Then you put 

04:51:49.445 --> 04:51:51.445
the same service ID in 

04:51:52.956 --> 04:51:54.956
some callbacks that will be 
called established.

04:51:58.441 --> 04:52:00.441
So when the user has selected 
the 

04:52:03.958 --> 04:52:06.408
it on the screen, now we need to
use the method which will 

04:52:06.409 --> 04:52:08.409
establish the 

04:52:09.668 --> 04:52:12.526
that's parsed in.  There are 
callbacks there on 

04:52:15.653 --> 04:52:17.653
initiated is used when the 
connection is 

04:52:20.345 --> 04:52:22.189
and it fills in an 
authentication token we 

04:52:22.190 --> 04:52:24.190
mentioned.

04:52:25.842 --> 04:52:29.715
So Nearby connections gives you 
a value.  Once again, we don't 

04:52:29.716 --> 04:52:33.989
have a display.that in a minute.
The code is simple to work with 

04:52:33.990 --> 04:52:35.990
in 

04:52:37.267 --> 04:52:40.127
connections and it gets us going
quite quickly.about attestation 

04:52:40.128 --> 04:52:42.976
and verifying the device.sure 
that the device in front of us 

04:52:42.977 --> 04:52:48.693
is connecting to.  What we do on
the phone is we actually what's 

04:52:48.694 --> 04:52:50.694
called a random challenge.

04:52:52.375 --> 04:52:54.375
unique just for this connection.
device.

04:52:57.894 --> 04:52:59.894
Appeared we use this to prevent 
replay attacks.

04:53:02.376 --> 04:53:04.376
takes the challenge and combines
with 

04:53:05.647 --> 04:53:07.647
and brings them together and 
uses this 

04:53:09.720 --> 04:53:12.973
the Android Keystore with the 
attestation certificate chain.  

04:53:12.974 --> 04:53:14.974
This certificate chain is then 
sent 

04:53:16.028 --> 04:53:17.645
the phone can then check it 
which we'll talk about in a 

04:53:17.646 --> 04:53:19.724
minute.Even though we're using a
random 

04:53:24.424 --> 04:53:27.061
Nearby is important because it 
binds it channel we're using 

04:53:27.062 --> 04:53:29.062
right now.

04:53:30.340 --> 04:53:32.340
limit failed connections.

04:53:36.692 --> 04:53:38.692
constantly trying random codes 
and generate some keys.

04:53:40.962 --> 04:53:43.414
to limit that to prevent people 
from attacking your device.Here 

04:53:43.415 --> 04:53:47.472
is some of the code.  Don't 
worry about it too much.want to 

04:53:47.473 --> 04:53:49.473
show you bits and pieces of what
there is.

04:53:51.349 --> 04:53:51.765
device we have the 
authentication token from 

04:53:51.766 --> 04:53:55.618
Nearby.the random challenge we 
had earlier.  We combine it 

04:53:55.619 --> 04:53:58.473
together.We use this code to 
generate the sign-in key here.

04:54:00.900 --> 04:54:02.900
interesting part about when you 
generate 

04:54:05.595 --> 04:54:07.595
Keystore is it's done in a 
trusted execution environment.

04:54:08.689 --> 04:54:13.409
don't actually keep the key in 
our app execution environment.  

04:54:13.410 --> 04:54:15.410
And this is nice because it 
means 

04:54:17.297 --> 04:54:19.297
our app, they don't have the 
ability to 

04:54:20.961 --> 04:54:25.455
That adds extra security to what
we're doing.this stuff.  The 

04:54:25.456 --> 04:54:27.922
purple values are standard 
constants.worry about capturing 

04:54:27.923 --> 04:54:32.621
this exactly.has all of this in 
it.  But I want to walk you 

04:54:32.622 --> 04:54:34.622
through a bit it.

04:54:37.749 --> 04:54:41.859
But at the end you end up with 
-- you certificate chain.  And 

04:54:41.860 --> 04:54:44.295
that is what you then pass back 
to phone for it to check it and 

04:54:44.296 --> 04:54:47.143
do whatever it's going to do.   
So Darren mentioned earlier the 

04:54:49.621 --> 04:54:51.621
certificate chain.

04:54:52.889 --> 04:54:55.135
So the factory provisioned 
attest agdz also comes with a 

04:54:55.136 --> 04:54:57.136
certificate chain from 

04:54:58.215 --> 04:55:00.215
back to the Android Things root 
certificate.

04:55:07.169 --> 04:55:11.054
full chain -- right at the boor.
TensorWash is now generated it's

04:55:13.698 --> 04:55:16.978
attestation key and sent the 
chain back to the phone.needs to

04:55:16.979 --> 04:55:20.441
verify that this is a untampered
with and also the one in front 

04:55:20.442 --> 04:55:22.442
of us.

04:55:24.939 --> 04:55:26.770
It has a number of steps and 
something in a library in the 

04:55:26.771 --> 04:55:28.771
future.

04:55:31.079 --> 04:55:33.940
verify that the certificate 
chain is verify that the root is

04:55:33.941 --> 04:55:37.222
the trusted root from Android 
Things.You need to verify that 

04:55:37.223 --> 04:55:39.223
it's your product ID.

04:55:43.116 --> 04:55:45.116
128-bit UI ID for the device.

04:55:47.484 --> 04:55:50.349
you can take and print on the 
box with a can verify that 

04:55:50.350 --> 04:55:53.616
they've matched it up of them.  
You can verify the boot status, 

04:55:58.505 --> 04:56:02.370
it's sent over with a flag 
indicating in tampered with.  

04:56:02.371 --> 04:56:05.407
You verify the attest identities
challenge.end up with a public 

04:56:05.408 --> 04:56:07.408
key that you can 

04:56:09.526 --> 04:56:09.936
handy when we want to 
authenticate with Cloud IoT 

04:56:09.937 --> 04:56:13.794
later on.     On the phone side 
we need to verify challenge is 

04:56:13.795 --> 04:56:15.795
correct.

04:56:19.699 --> 04:56:21.699
certificate and then we create a
hash of 

04:56:27.437 --> 04:56:30.382
token from near and the random 
challengehash and checks that it

04:56:30.383 --> 04:56:32.383
matches what came from the 
device.

04:56:35.068 --> 04:56:37.699
verifies that this whole loop is
secure.we never actually sent 

04:56:37.700 --> 04:56:40.351
the   It was done by Nearby.

04:56:44.850 --> 04:56:48.510
is done right and no man in the 
middle the way.     So now we 

04:56:48.511 --> 04:56:50.511
know that the device is ours.

04:56:52.431 --> 04:56:56.723
that helps to sort of deal with 
all identified.  So now the 

04:56:56.724 --> 04:56:59.174
phone has verified it can 
TensorWash.  Now we need to 

04:56:59.175 --> 04:57:03.448
authorize the device on network.
The quickest way is to pop up an

04:57:08.334 --> 04:57:10.334
phone and say what's the Wi-Fi 
SSID and passphrase.

04:57:13.225 --> 04:57:15.225
user friendly and requires the 
to put 

04:57:17.097 --> 04:57:19.097
what's being sent over to the 
device is seen through the app.

04:57:20.187 --> 04:57:22.187
The next thing you do is on the 
device 

04:57:24.236 --> 04:57:26.236
the WiFiManager to set the SSID 
and passphrase.

04:57:29.158 --> 04:57:31.158
a little code snippet that does 
it.

04:57:32.412 --> 04:57:34.412
more complicated.

04:57:35.885 --> 04:57:38.526
the WiFiManager.  This is 
something we want to make that 

04:57:42.027 --> 04:57:46.088
use a small code library you can
use so that kind of code.  We 

04:57:46.089 --> 04:57:48.089
have more good news in that we 
have 

04:57:49.976 --> 04:57:51.976
API called Nearby setup that's 
coming to Google Play Services.

04:57:53.425 --> 04:57:55.425
The great thing about Nearby 
setup which 

04:57:57.087 --> 04:57:59.087
has the ability to take the 
Wi-Fi 

04:58:00.755 --> 04:58:02.794
phone and pass them to another 
device's Google Play Services.So

04:58:02.795 --> 04:58:04.795
Android Things supports Google 
Play Services.

04:58:06.074 --> 04:58:08.731
the credentials over without 
having to yourself, the user 

04:58:08.732 --> 04:58:13.239
doesn't need to type them.for 
user convenience.  This is 

04:58:13.240 --> 04:58:15.240
coming soon and the details 

04:58:17.101 --> 04:58:19.742
going to be on developers 
Google.com/Nearby when that's 

04:58:19.743 --> 04:58:22.813
later.We have Internet access on
our device and a key.

04:58:26.913 --> 04:58:30.580
about how we're going to get 
Cloud device.  We're going to 

04:58:30.581 --> 04:58:32.821
talk about Firebase and Cloud 
IoT.     The first thing we need

04:58:32.822 --> 04:58:39.135
to do on set up Firebase.  It's 
great because it works on and 

04:58:39.136 --> 04:58:41.136
with web.

04:58:43.444 --> 04:58:46.302
It can be on many different 
devices.to use that on both the 

04:58:46.303 --> 04:58:48.303
phone and the device.

04:58:50.006 --> 04:58:52.006
user to authenticate what with 
their user name and password.

04:58:55.308 --> 04:58:57.308
Pop up a dialogue box and we get
a token 

04:58:58.566 --> 04:59:00.796
encrypted pipe.  We can see at 
the top we're doing the 

04:59:01.210 --> 04:59:05.679
requests.     It's interesting 
because we're only the email ID.

04:59:07.949 --> 04:59:09.949
We don't want to have full 
Google 

04:59:11.006 --> 04:59:14.049
access to their files or email 
or something like that.just 

04:59:14.050 --> 04:59:16.050
asking for their identification 
details.

04:59:17.296 --> 04:59:19.296
trying to limit scope like what 
Darren talked about earlier.

04:59:22.638 --> 04:59:24.638
end up getting a JSON web token 
which we 

04:59:27.347 --> 04:59:29.347
which allows our device to 
interact with Firebase as well.

04:59:31.639 --> 04:59:33.639
ship that token, the previous 
token off 

04:59:35.110 --> 04:59:37.110
log in to Firebase and do things
with that.

04:59:38.808 --> 04:59:41.655
So on the other side we take the
Firebase and authenticate with 

04:59:41.656 --> 04:59:43.656
that.

04:59:48.373 --> 04:59:50.373
access to the Firebase realtime 
database.

04:59:52.241 --> 04:59:54.241
looks very similar on the device
as well.

04:59:55.544 --> 04:59:57.987
Things device is regular 
Android, we use we do on the 

04:59:57.988 --> 04:59:59.988
phone.

05:00:02.081 --> 05:00:05.968
We get a credential, pass it in 
to auth.  We have a 

05:00:05.969 --> 05:00:07.969
bidirectional authentication 

05:00:09.084 --> 05:00:11.923
can fully participate with the 
Firebase realtime database.     

05:00:11.924 --> 05:00:14.576
Let's switch gears to finish up.
IoT Core.

05:00:17.849 --> 05:00:19.849
Imagine you're running a lawned 
malt 

05:00:21.097 --> 05:00:23.097
machines in thawses of 
locations.

05:00:28.052 --> 05:00:30.702
these devices to Cloud IoT for 
analysis.register the devices.

05:00:34.174 --> 05:00:36.238
You have an app with 
credentials.take that public 

05:00:36.239 --> 05:00:38.239
certificate that we 

05:00:40.531 --> 05:00:42.531
to Cloud IoT so it knows the 
device and can trust it.

05:00:44.797 --> 05:00:46.797
then MQTT to send requests to 
Cloud IoT 

05:00:48.501 --> 05:00:50.501
signed with our key.

05:00:52.766 --> 05:00:54.800
legitimate by verifying this key
and received earlier.

05:00:58.066 --> 05:01:00.066
Then we send the MQTT request 
using 

05:01:01.324 --> 05:01:06.027
we use TLS so that our device 
knows it sending data to.  

05:01:06.028 --> 05:01:09.291
Remember, both sides need to 
check the other side.     Here's

05:01:09.292 --> 05:01:11.292
a quick snippet that shows 

05:01:12.353 --> 05:01:14.353
project IDs and things like 
that.

05:01:19.514 --> 05:01:21.514
soon that introduces how to do 
Cloud IoT Core.

05:01:26.048 --> 05:01:28.293
bottom takes any binary blob you
want worry about generating any 

05:01:28.294 --> 05:01:36.263
of the mentals.about Cloud IoT 
and Firebase.can do?     We also

05:01:36.264 --> 05:01:38.264
have Smart Home which is a 

05:01:43.058 --> 05:01:45.058
you have light bulbs you can say
dim the 

05:01:47.367 --> 05:01:49.367
If you implement Smart Home you 
can say 

05:01:52.887 --> 05:01:54.887
machine, it will kick it off 
with Google Assistant.

05:01:57.584 --> 05:01:59.584
device can be enabled with the 
Google Assistant.

05:02:03.964 --> 05:02:05.964
can enable the stk into your 
device 

05:02:07.221 --> 05:02:09.110
the washing machine and give it 
direct directly which is kind of

05:02:09.111 --> 05:02:12.571
cool.     So what's next?  We 
have a factory key provisioning 

05:02:16.037 --> 05:02:18.929
coming soon where basically a 
hardware you add keys to Android

05:02:18.930 --> 05:02:21.569
Things devices.yourself or when 
they're being produced.

05:02:24.821 --> 05:02:26.821
is going to get on to the 
device.

05:02:28.498 --> 05:02:31.378
you won't be able to test the 
key won't have an official key 

05:02:31.379 --> 05:02:34.711
from Android Things.to be 
releasing the tools to be able 

05:02:34.712 --> 05:02:36.712
to do this soon.

05:02:39.376 --> 05:02:41.376
Nearby setup API is going to be 
coming soon as well.

05:02:44.114 --> 05:02:46.114
make provisioning these things 
really easy.

05:02:49.206 --> 05:02:51.206
In summary go vision us on 
Google.com.

05:02:53.680 --> 05:02:55.680
community where you can find out
more 

05:02:57.202 --> 05:03:01.312
site where you can keep track of
what's us on social media.  If 

05:03:01.313 --> 05:03:03.313
you haven't had a chance, get 

05:03:04.372 --> 05:03:08.885
one of the IMX7 developer kits 
that I/O.  Make sure you get one

05:03:08.886 --> 05:03:10.886
of those so you Things yourself.

05:03:15.409 --> 05:03:19.321
making production devices.  
That's it for us.for coming and 

05:03:19.322 --> 05:03:21.322
we'll see you at the conference.
Thank you.

05:03:24.355 --> 05:03:26.355
(Applause)

05:03:46.332 --> 05:03:48.332
session.

05:03:51.067 --> 05:03:53.067
will assist through designated 
exits.

05:03:54.924 --> 05:03:56.924
those registered for the next 
room.

05:03:59.397 --> 05:04:01.241
clear the room and return via 
the registration line outside.

05:04:01.242 --> 05:04:03.242
Thank you.

05:19:18.267 --> 05:19:20.267
*** 

05:20:07.185 --> 05:20:09.185
*** 

05:23:11.233 --> 05:23:13.454
&gt;&gt; KRISTIN GRAY:  Hi, and 
welcome products with Android 

05:23:13.455 --> 05:23:15.455
Things.  I'm Kristin.

05:23:17.963 --> 05:23:19.963
Android things.

05:23:24.692 --> 05:23:26.692
I'm the for -- you can think of 
it 

05:23:27.798 --> 05:23:29.798
design 101 for those who are not
skiners.

05:23:32.282 --> 05:23:34.282
designer, we've got you covered.

05:23:37.844 --> 05:23:40.290
In this talk we'll cover how you
can the product creation process

05:23:40.291 --> 05:23:42.291
using Android Things.

05:23:43.963 --> 05:23:45.963
about design framework that you 
can use 

05:23:47.816 --> 05:23:49.816
you think about who your users 
are and 

05:23:51.898 --> 05:23:53.898
prominent role in crafting the 
products that you're creating.

05:23:56.033 --> 05:23:58.033
We'll also talk about a concept 
project 

05:24:00.293 --> 05:24:02.293
demonstrate how we've applied 
the design 

05:24:03.739 --> 05:24:05.162
Android Things to create better 
products.     &gt;&gt; KRISTIN GRAY:  

05:24:05.163 --> 05:24:07.163
Thanks, Michael.

05:24:09.873 --> 05:24:11.873
hardware design is a long and 
difficult process.

05:24:14.392 --> 05:24:17.468
anywhere from 2 to 5 years to 
bring a product.  You start with

05:24:17.469 --> 05:24:21.538
ideation.prototype phase.  Then 
you choose your hardware.

05:24:24.857 --> 05:24:26.857
design your software and get 
that coded to a factory.

05:24:29.540 --> 05:24:31.617
You finally get it on a store 
shelf have to cycle back and go 

05:24:31.618 --> 05:24:33.618
through updates.

05:24:35.953 --> 05:24:37.987
that's rapidly changing and 
technology of your production 

05:24:37.988 --> 05:24:40.221
process.  How can the design 
process keep up?

05:24:43.887 --> 05:24:45.887
That's one of the main reasons 
we've created Android Things.

05:24:46.968 --> 05:24:48.968
enables people to be part of the

05:24:51.051 --> 05:24:53.051
all the way through maintenance.

05:24:55.150 --> 05:24:57.150
So at the heart of Android 
Things 

05:25:01.036 --> 05:25:03.036
a SOM or a system on-on-module.

05:25:06.280 --> 05:25:08.280
The SOM can be used for 
prototyping 

05:25:09.342 --> 05:25:11.342
also be placed on a custom 
board.

05:25:16.512 --> 05:25:18.512
use it on your own custom PCB 
board, 

05:25:20.502 --> 05:25:22.502
everything that surrounds it is 
an accessory.

05:25:24.961 --> 05:25:26.961
Ethernet to power to the head 
phone jack 

05:25:28.212 --> 05:25:30.212
powerful tool for prototyping 
because 

05:25:32.033 --> 05:25:34.033
the tools you need to get 
connected.

05:25:35.126 --> 05:25:37.614
different peripheral, you can 
connect it breadboard and 

05:25:37.615 --> 05:25:39.615
resisters.

05:25:43.566 --> 05:25:45.566
&gt;&gt; MICHAEL DELGAUDIO:  So 
Android 

05:25:48.665 --> 05:25:50.665
tools for you to get started 
easily.

05:25:53.591 --> 05:25:55.591
IMX7 board, a touch screen, and 
a stand.

05:25:58.082 --> 05:26:00.082
have gotten your kit or been to 
the 

05:26:02.456 --> 05:26:04.456
acceptableses into a stand that 
you can prototype on your desk.

05:26:05.512 --> 05:26:07.512
In addition to the kit we offer 
the 

05:26:10.220 --> 05:26:12.220
that gets you on Wi-Fi easily.

05:26:14.131 --> 05:26:17.011
Android con for example was 
provisioning Wi-Fi network was 

05:26:17.012 --> 05:26:19.012
difficult.

05:26:21.387 --> 05:26:23.387
it on to Wi-Fi in a breeze.

05:26:25.293 --> 05:26:27.293
process of making sure that your

05:26:36.882 --> 05:26:38.882
can upload to see what the 
Android 

05:26:41.547 --> 05:26:43.547
the TensorFlow demonstrations 
before you 

05:26:45.460 --> 05:26:47.460
In addition to the tool kit app 
and 

05:26:49.763 --> 05:26:51.763
we also recently updated the 
Android 

05:26:55.301 --> 05:26:57.128
Now we offer code snippets, 
samples, projects from the 

05:26:57.129 --> 05:26:59.129
community.

05:27:02.055 --> 05:27:04.055
you can submit it and we'll 
feature it on the site the.

05:27:09.783 --> 05:27:12.477
We update the site so if you 
make a to use, we can have that 

05:27:12.478 --> 05:27:14.478
on the site as well.

05:27:17.725 --> 05:27:20.541
gotten your kit, head over to 
the I/O      &gt;&gt; KRISTIN GRAY:  

05:27:20.542 --> 05:27:22.542
Thanks.

05:27:24.290 --> 05:27:26.290
end to end solution.

05:27:28.776 --> 05:27:30.776
production like Michael 
mentioned.

05:27:33.259 --> 05:27:35.259
selection easier so you can use 
the same you do production.

05:27:38.144 --> 05:27:40.144
For prototyping, the kit offers 

05:27:41.891 --> 05:27:43.891
such as displays, a rainbow hat 
and 

05:27:45.750 --> 05:27:47.750
antenna to connect the device to
Wi-Fi.

05:27:49.452 --> 05:27:51.452
An app also makes this easier to
assemble your hardware.

05:27:53.720 --> 05:27:57.388
It helps you get familiar with 
your connect to Wi-Fi.  Finally 

05:27:57.389 --> 05:27:59.389
when you're ready for 

05:28:01.288 --> 05:28:03.288
developer console can help you 
create 

05:28:05.001 --> 05:28:07.001
firm aware and release those 
builds to devices.

05:28:08.656 --> 05:28:10.656
&gt;&gt; MICHAEL DELGAUDIO:  Great.

05:28:12.138 --> 05:28:14.138
a concept called Lantern.

05:28:17.047 --> 05:28:19.047
to help you understand how we 
were able 

05:28:21.350 --> 05:28:23.350
bring products to life.

05:28:24.647 --> 05:28:26.647
So Lantern is not a Google 
product 

05:28:30.348 --> 05:28:32.417
we worked on with the Nord group
that anywhere around you.

05:28:36.749 --> 05:28:38.749
You can see this as an easy to 

05:28:43.949 --> 05:28:45.995
example of how we were exploring
creativity through prototyping

05:29:00.628 --> 05:29:02.651
It's created using off the shelf
parts.that was really important 

05:29:02.652 --> 05:29:04.652
because we 

05:29:06.120 --> 05:29:07.948
a recipe that you could 
potentially build one on your 

05:29:07.949 --> 05:29:15.308
own.     So what is augmented 
reality?term, AR.  There's the 

05:29:15.309 --> 05:29:17.309
AR kit.

05:29:18.366 --> 05:29:21.242
of augmented reality using 
Android Things?     So using 

05:29:21.243 --> 05:29:23.243
Lantern and Android 

05:29:25.733 --> 05:29:27.733
on to everyday objects 
interesting 

05:29:29.233 --> 05:29:31.233
content that may be trapped 
inside the 

05:29:32.475 --> 05:29:34.475
that may enhance the world 
around us.

05:29:38.386 --> 05:29:42.859
here the currently playing Cast 
song speaker.  None of this was 

05:29:42.860 --> 05:29:44.860
done using after effectings.

05:29:46.992 --> 05:29:48.992
all using the projection system 
in the prototype we created.

05:29:50.388 --> 05:29:52.388
Another example of how we're 
augmented 

05:29:54.103 --> 05:29:56.103
this example a clock.

05:30:00.443 --> 05:30:03.290
clock with Lantern to project 
the the clock.  Again, this is 

05:30:03.291 --> 05:30:05.291
all real.

05:30:07.370 --> 05:30:09.370
using the Lantern.

05:30:12.473 --> 05:30:14.473
As an exploration, we felt it 

05:30:18.800 --> 05:30:23.278
because it was on this nice 
round curved ticker tape look.  

05:30:23.279 --> 05:30:25.279
We're excited about theses.

05:30:26.735 --> 05:30:28.735
share with you to demonstrate 
not only 

05:30:29.808 --> 05:30:31.808
we'll get into but to give it to
the 

05:30:32.902 --> 05:30:35.208
guys may want to create with it.
So what is Lantern made of?

05:30:41.538 --> 05:30:43.538
created using off the shelf.

05:30:46.641 --> 05:30:48.641
Pi running are Android Things.

05:30:52.981 --> 05:30:54.981
there are two pieces of hardware
-- two Things runs on.

05:31:00.706 --> 05:31:02.706
the IMX boards that are in the 
kit.

05:31:05.392 --> 05:31:07.392
little more prevalent at this 
point in the maker community.

05:31:12.752 --> 05:31:14.800
felt with the HTMI output 
because we can the laser 

05:31:14.801 --> 05:31:20.305
projector.  Once it's assembled,
it looks like this.You may have 

05:31:20.306 --> 05:31:25.404
seen it at the IoT dome.there as
an example.     We really 

05:31:25.405 --> 05:31:27.405
believe that this is only 

05:31:30.298 --> 05:31:32.298
the democratization of design 
hardware 

05:31:33.361 --> 05:31:35.361
access to these kinds of tools 
we're talking about today.

05:31:39.080 --> 05:31:41.080
was really difficult in the past
say to 

05:31:43.763 --> 05:31:45.763
this and acceptable it into a 
hardware 

05:31:48.459 --> 05:31:50.459
was expensive and tools like 
Android 

05:31:52.753 --> 05:31:54.798
readily available for you to 
access to prototypes.

05:31:58.481 --> 05:32:02.551
So Lantern can also be assigned 
context.  So it's aware of its 

05:32:02.552 --> 05:32:04.552
orientation.

05:32:07.856 --> 05:32:09.856
accelerometer in Lantern we can 
change 

05:32:11.703 --> 05:32:13.703
project different content on to 
different surfaces.

05:32:15.835 --> 05:32:17.835
wanted a star chart on the 
ceiling or in 

05:32:19.920 --> 05:32:20.735
you could see the calendar 
information projected to the 

05:32:20.736 --> 05:32:22.736
wall.

05:32:24.015 --> 05:32:26.015
This code is available today at 
GitHub.

05:32:27.073 --> 05:32:31.541
Lantern.  If you want to 
download the source own.

05:32:34.998 --> 05:32:39.904
So we didn't set out to create 
Lantern.Lantern come from?  You 

05:32:39.905 --> 05:32:41.905
can see a number of sketches 
that created.

05:32:44.406 --> 05:32:46.406
If you're designers, you may be 

05:32:52.194 --> 05:32:54.194
sketching we started prototyping
using Android Things.

05:32:56.080 --> 05:32:58.080
design to turn our idea into a 
real 

05:32:59.148 --> 05:33:01.148
share with you the process that 
we went 

05:33:02.421 --> 05:33:04.421
frameworks that we used to 
create too.

05:33:07.367 --> 05:33:09.367
&gt;&gt; KRISTIN GRAY:  Thank you.

05:33:14.301 --> 05:33:16.301
design helps create better 
products.

05:33:18.374 --> 05:33:22.498
raise of hand have created 
something person?  Go ahead and 

05:33:22.499 --> 05:33:26.159
raise your hands.  That's 
awesome.when we design things, 

05:33:26.160 --> 05:33:29.036
you might know principles to 
ground our work.

05:33:34.156 --> 05:33:36.156
design can be carried over from 
software 

05:33:37.856 --> 05:33:39.926
banking company, for instance, 
to a instance.

05:33:43.229 --> 05:33:45.229
So we use these processes and 

05:33:47.496 --> 05:33:49.496
work, but then we use the design
process 

05:33:50.554 --> 05:33:52.554
And then we continue iterating.

05:33:54.435 --> 05:33:56.879
we're taking some of the 
software UI applying them to 

05:33:56.880 --> 05:33:58.880
hardware.

05:34:01.470 --> 05:34:03.470
So what is design?

05:34:06.789 --> 05:34:10.324
people in a context to help them
achieve a goal.are familiar with

05:34:10.325 --> 05:34:12.952
the development to a user story.

05:34:16.232 --> 05:34:19.166
So, for example, as a dog owner,
I connect a dog feeder so I can 

05:34:19.167 --> 05:34:21.167
feed my 

05:34:24.101 --> 05:34:26.101
person who orders pizza -- I 
order pizza 

05:34:28.582 --> 05:34:31.031
visibility into the delivery 
route so I arrive.

05:34:34.714 --> 05:34:37.792
Such as a simple as a knight I 
want a I can defeat .dragon.

05:34:40.842 --> 05:34:43.293
stronger sword.  This is the 
tool that the sword uses 

05:34:47.215 --> 05:34:52.300
goal to achieve in defeating the
dragon.interface.  People think 

05:34:52.301 --> 05:34:54.301
of a user interface as a 

05:34:55.559 --> 05:34:57.789
or a mobile phone or a tablet 
because and things happen, 

05:34:57.790 --> 05:35:01.707
right?  It's magic.     While 
this is true, user interface 

05:35:03.558 --> 05:35:07.026
that.  In the example before, 
the user interface is the sword.

05:35:09.497 --> 05:35:11.497
But we can see here from this 
slide that 

05:35:14.806 --> 05:35:16.806
build upon an interface to 
create a joy 

05:35:19.529 --> 05:35:22.987
to create a game that shoots 
down aliens from the sky.there 

05:35:22.988 --> 05:35:25.887
could be feedback on top of that
heeds inside of a breadboard 

05:35:25.888 --> 05:35:29.956
that light button.  So all of 
these are an example of a user 

05:35:29.957 --> 05:35:32.813
interface.One of the most simple
user interfaces 

05:35:37.306 --> 05:35:39.306
things is simple as a piece of 
paper and a pen.

05:35:45.243 --> 05:35:47.243
And admittedly a design is 
iterative.

05:35:49.316 --> 05:35:53.595
like the ma'am ster in the 
wheel.done.  Teams need to learn

05:35:53.596 --> 05:35:57.724
through the and iteration.  That
being said, Android Things 

05:36:01.186 --> 05:36:03.186
iterate faster by allowing you 
to work 

05:36:04.850 --> 05:36:06.850
issues by using the design kit 
as a base 

05:36:09.823 --> 05:36:11.823
phase and allowing for early 
Over the 

05:36:12.873 --> 05:36:15.123
developer console.     &gt;&gt; 
MICHAEL DELGAUDIO:  So design is

05:36:18.573 --> 05:36:20.573
used to create better products 
for everyone.

05:36:22.670 --> 05:36:24.670
design is agnostic of medium, 
time, 

05:36:26.141 --> 05:36:29.003
We believe it's important to 
think process that's agnostic of

05:36:29.004 --> 05:36:31.004
these things 

05:36:33.285 --> 05:36:35.285
changes, you have the right 
tools to 

05:36:36.982 --> 05:36:38.982
whatever problem you're working 
on.

05:36:40.126 --> 05:36:42.126
So we talked about design being 
in 

05:36:43.846 --> 05:36:46.489
people in the context of goals.
look like?

05:36:51.386 --> 05:36:53.386
So each milestone owled here, 

05:37:02.908 --> 05:37:04.768
make less mistakes, produce 
better production process along 

05:37:04.769 --> 05:37:06.769
the way.

05:37:09.087 --> 05:37:11.743
product needs to take shape as 
it's evolving.you make decisions

05:37:11.744 --> 05:37:13.744
sooner.

05:37:14.823 --> 05:37:16.823
So thinking about planning.

05:37:20.714 --> 05:37:23.572
First we aim to create baseline 
that may exist for our users.

05:37:30.115 --> 05:37:32.115
about pain points from other 
people or ourselves.

05:37:33.806 --> 05:37:35.806
at competitive products to see 
how 

05:37:37.880 --> 05:37:39.880
how we might want to do it 
differently.

05:37:42.212 --> 05:37:44.212
software systems, you may be 
familiar 

05:37:47.963 --> 05:37:49.963
personas and gain empathy into 
the mind 

05:37:50.991 --> 05:37:52.991
product.  We create things like 
wire frames, 

05:37:56.007 --> 05:37:58.007
the story how we've seen the 
product use unfolding over time.

05:37:59.513 --> 05:38:01.513
We then create something.

05:38:03.991 --> 05:38:05.991
hypothesis of how something 
should work, 

05:38:10.115 --> 05:38:12.115
medium fidelity designs so we 
saw those preliminary skechls.

05:38:12.963 --> 05:38:14.963
may create something like a 
video 

05:38:16.048 --> 05:38:18.048
it might look and feeltches.how 
it might look and feel before it

05:38:20.887 --> 05:38:23.172
actually worksmake something on 
a breadboard to get an 

05:38:27.702 --> 05:38:29.702
do or what some pft key 
characters of 

05:38:31.593 --> 05:38:33.593
look like.

05:38:34.662 --> 05:38:37.112
It's important to get feedback 
in this we need to understand 

05:38:37.113 --> 05:38:39.113
how people are actually using 
things.

05:38:40.826 --> 05:38:42.826
equal active feedback and 
understanding 

05:38:44.695 --> 05:38:46.695
how they feel about a particular
feature 

05:38:47.988 --> 05:38:53.275
proposing.  Quantitative to 
understand how being used or not

05:38:53.276 --> 05:38:55.276
used.

05:38:57.548 --> 05:39:02.040
sharing projects with each other
other people.  It's really 

05:39:02.041 --> 05:39:06.801
helpful to get an something so 
that that person can point may 

05:39:06.802 --> 05:39:08.802
not have seen.

05:39:11.492 --> 05:39:13.492
Guerilla research, I'm shog your

05:39:14.557 --> 05:39:17.439
familiar with the project can 
give you because then you can 

05:39:17.440 --> 05:39:19.440
have an objective 

05:39:20.926 --> 05:39:22.971
you may be creating from 
somebody who the project before.

05:39:26.485 --> 05:39:28.485
Finally, in later stages you may

05:39:30.172 --> 05:39:32.172
lab story to ask participants to
use 

05:39:34.889 --> 05:39:38.995
a controlled environment side by
side may be like.     And we're 

05:39:38.996 --> 05:39:40.996
not saying that you need 

05:39:42.463 --> 05:39:44.463
things along the way.

05:39:47.792 --> 05:39:50.631
storyboard which translates into
a click internal feedback and 

05:39:50.632 --> 05:39:52.632
iterate on that cycle.

05:39:54.510 --> 05:39:56.510
we may do a bit of competitive 
analysis 

05:39:59.211 --> 05:40:01.211
requirements and create a looks 
like 

05:40:04.924 --> 05:40:06.924
perform some Guerilla research 
for 

05:40:09.215 --> 05:40:11.258
with the product we're creating.
&gt;&gt; KRISTIN GRAY:  Something else

05:40:11.259 --> 05:40:13.259
to 

05:40:14.554 --> 05:40:17.218
hardware isn't hard bullet it's 
different.what parts you need to

05:40:17.219 --> 05:40:19.219
make what you want.

05:40:20.926 --> 05:40:22.926
think about designing a system 
possibly 

05:40:26.521 --> 05:40:28.521
Sometimes it's like Jenga, one 
another.

05:40:30.652 --> 05:40:32.652
You need to think about 
futureproofing.

05:40:34.850 --> 05:40:37.328
space do you need to allocate 
for user you're designing a 

05:40:37.329 --> 05:40:39.329
camera?

05:40:40.456 --> 05:40:42.497
This might be importantly for 
users.You need to think about 

05:40:42.498 --> 05:40:44.498
form factor.

05:40:46.969 --> 05:40:49.448
want to fit into your design fit
into a delightful for your 

05:40:49.449 --> 05:40:51.449
users?

05:40:52.932 --> 05:40:54.932
One other thing to consider is 
your interaction design.

05:40:56.275 --> 05:40:58.275
when you connect the product to 
the 

05:40:59.743 --> 05:41:01.743
companion app for that?

05:41:03.012 --> 05:41:06.517
notifications can be seen from a
reasonable view?make it 

05:41:06.518 --> 05:41:08.518
accessible?

05:41:11.516 --> 05:41:13.516
Do you tell the user at 8:00 
a.m.

05:41:14.582 --> 05:41:16.582
actually using your product or 
do you wait until 2:00 a.m.

05:41:17.846 --> 05:41:19.490
people might not be using your 
product and they might be 

05:41:19.491 --> 05:41:24.475
asleep.     Also, what if 
there's no screen?consider for 

05:41:24.476 --> 05:41:26.476
the land of IoT.

05:41:28.805 --> 05:41:30.805
process using Android Things to 
help us 

05:41:33.158 --> 05:41:35.158
back -- get that feedback 
sooner, make 

05:41:36.413 --> 05:41:38.456
for these questions and also 
ultimately products.

05:41:42.985 --> 05:41:45.861
And one thing to note, if you're
a something that you're really 

05:41:45.862 --> 05:41:47.862
familiar with is the undo 
button.

05:41:50.782 --> 05:41:52.782
In hardware, you don't have an 
undo button.

05:41:56.072 --> 05:41:58.072
roll back a release when you're 
a software engineer as well.

05:42:00.025 --> 05:42:02.025
When you're designing for 
hardware, it's more permanent.

05:42:02.461 --> 05:42:04.461
need a strong iteration cycle.

05:42:05.941 --> 05:42:07.941
forward in your design cycle, 
the more 

05:42:08.987 --> 05:42:10.987
backwards.

05:42:13.680 --> 05:42:16.378
For example, in 1966 NASA's 
budget was over 4% of the U.S.

05:42:19.245 --> 05:42:21.245
spending and the undertaking was
mammoth.

05:42:23.332 --> 05:42:25.332
can shoot 3D printers into 
space, 

05:42:26.797 --> 05:42:29.673
there, update it from your 
laptop and fraction of the 

05:42:29.674 --> 05:42:31.674
price.

05:42:34.233 --> 05:42:36.233
because it's fun and because we 
can.

05:42:38.508 --> 05:42:40.508
One other thing to note here is 
+th design process.

05:42:44.822 --> 05:42:48.905
with the mercury, Gemini and 
Apollo get us to the moon.  

05:42:48.906 --> 05:42:50.906
Mercury put a man into space.

05:42:53.239 --> 05:42:55.899
extend the capsule stay from 
hours to us to the moon.

05:42:59.603 --> 05:43:01.629
These were some pretty big 
iteration you know they were 

05:43:01.630 --> 05:43:03.630
really on to something.

05:43:05.519 --> 05:43:09.600
You may notice even today some a
water fall process.  It requires

05:43:09.601 --> 05:43:11.601
everything to be perfect 

05:43:13.069 --> 05:43:15.069
is expensive in end-to end 
cycles.

05:43:16.752 --> 05:43:18.752
the requirements and hand those 
off once 

05:43:20.483 --> 05:43:22.943
designers who finish the designs
and engineers for 

05:43:22.944 --> 05:43:24.944
implementation.

05:43:29.094 --> 05:43:31.749
off, then they hand it off to 
the QA back through a 

05:43:31.750 --> 05:43:35.007
maintenance cycle and you again.
If you make a mistake or decide 

05:43:35.008 --> 05:43:37.008
you 

05:43:38.271 --> 05:43:40.271
you're late in the process, you 
have to 

05:43:41.332 --> 05:43:42.960
to the requirements section.    
On the right you'll see 

05:43:42.961 --> 05:43:44.961
something 

05:43:46.619 --> 05:43:48.619
like the process that Mike was 
talking about.

05:43:50.082 --> 05:43:52.082
more milestones sprinkled in 
there.

05:43:53.138 --> 05:43:55.983
iteration cycle.  You plan, 
prototype, feedback, and 

05:43:56.606 --> 05:43:59.685
iterate.You keep doing that 
throughout your process.

05:44:03.172 --> 05:44:05.216
flexible and helps keep costs 
contained in the process.

05:44:10.508 --> 05:44:12.508
In the past there were also very

05:44:13.565 --> 05:44:15.565
contribute to the creation of a 
project engineers.

05:44:19.914 --> 05:44:23.779
Now with access to tools like on
demand 3D printing.Anyone can 

05:44:23.780 --> 05:44:25.780
print 3D parts.

05:44:29.326 --> 05:44:31.326
now with the ease of prototyping
tools.

05:44:33.410 --> 05:44:36.698
their skills to hardware and 
Android do so.     Specifically 

05:44:36.699 --> 05:44:38.699
dealing with software, 

05:44:41.330 --> 05:44:43.330
labor intensive to create and 
release a build.

05:44:44.827 --> 05:44:46.827
to set up testing environments 
for those devices as well.

05:44:48.110 --> 05:44:50.110
Android Things we've introduced 
the 

05:44:54.324 --> 05:44:56.324
open up the dev console and 
create a 

05:44:57.448 --> 05:44:59.901
a few easy steps.     &gt;&gt; MICHAEL
DELGAUDIO:  Now that he 

05:45:03.165 --> 05:45:05.165
little bit about design and 
process, we 

05:45:06.273 --> 05:45:09.327
to the Lantern project I 
mentioned earlier.use the 

05:45:09.328 --> 05:45:11.328
process of planning, 

05:45:14.000 --> 05:45:16.000
iterating to help us improve 
this concept?

05:45:18.100 --> 05:45:20.749
think about people, context and 
goals idea.

05:45:26.409 --> 05:45:28.409
As a designer I like to bring my

05:45:31.432 --> 05:45:33.432
plontionor projection.happened 
next?

05:45:36.332 --> 05:45:38.332
We began to create a looks like 
feels prototype.

05:45:40.025 --> 05:45:42.025
Before we were even acceptabling

05:45:43.982 --> 05:45:45.982
together the housing, we started
to 

05:45:47.428 --> 05:45:49.428
time rendering look like as a 
projects 

05:45:50.712 --> 05:45:55.029
me.  What would I want to 
project on the I was typing?

05:45:58.474 --> 05:46:00.474
Would it be some bit coin 
information 

05:46:01.982 --> 05:46:03.982
of something else or how I'm 
doing in a certain game?

05:46:07.832 --> 05:46:09.832
like feels like prototype helps 
you 

05:46:11.885 --> 05:46:13.885
exists in its end state without 
actually 

05:46:15.133 --> 05:46:17.399
through the full creation 
process.     Again, we went back

05:46:17.400 --> 05:46:20.240
to sketching to housing may come
together.

05:46:23.928 --> 05:46:25.928
thinking about the parts that 
needed to 

05:46:28.254 --> 05:46:30.254
earlier, we need the Raspberry 
Pi board, 

05:46:32.379 --> 05:46:35.880
and start to fit inside of this 
specific shape.     This was one

05:46:35.881 --> 05:46:37.881
of the first 

05:46:39.361 --> 05:46:41.361
foam core and some of the parts.

05:46:43.482 --> 05:46:45.482
needed, we began to put them 
together 

05:46:48.562 --> 05:46:50.562
into a #3d print right away but 
using 

05:46:52.490 --> 05:46:55.369
cutting them out and making the 
form so into the lamp.

05:46:58.845 --> 05:47:00.845
Before we put everything 
together, 

05:47:04.585 --> 05:47:06.585
simulations may look like 
functionally.

05:47:09.327 --> 05:47:11.413
seeing is Ancell rorment test 
showing content based on 

05:47:11.414 --> 05:47:13.414
orientation.  It's really 
simple.

05:47:16.546 --> 05:47:21.292
projector, the Raspberry Pi 
connected to Android Things.  We

05:47:21.293 --> 05:47:23.551
just said, can we show you the 
show us the direction of which 

05:47:23.552 --> 05:47:25.552
way the object is pointing.

05:47:29.263 --> 05:47:31.731
it know if it's pointing up, 
down, or sideways.right-hand 

05:47:31.732 --> 05:47:33.732
side these are initial tests 

05:47:36.012 --> 05:47:38.012
could get the currently playing 
song off 

05:47:41.922 --> 05:47:43.922
projecting it on to note pad to 
see if 

05:47:44.965 --> 05:47:47.652
using the hardware we think we 
want to use.     In looking at 

05:47:47.653 --> 05:47:49.653
physical prototyping, 

05:47:52.926 --> 05:47:54.926
first

05:47:56.042 --> 05:47:58.088
assembled changing the content 
based on the physical prototype.

05:48:00.942 --> 05:48:02.942
Here he flips up at the ceiling.

05:48:05.149 --> 05:48:07.149
can see the content starts to 
come to life.

05:48:10.050 --> 05:48:12.674
together into their final form. 
So one tool that I wanted to 

05:48:16.357 --> 05:48:18.357
highly beneficial in creating 
this project was processing.

05:48:21.316 --> 05:48:23.316
if you're a designer, you may 
already be 

05:48:24.980 --> 05:48:27.016
processing as a light wait IDE 
that create visual sedations.

05:48:33.377 --> 05:48:35.377
because I can create visual 
sedations 

05:48:37.075 --> 05:48:39.075
a nice library that was released
from 

05:48:41.568 --> 05:48:43.568
called processing for Android.

05:48:45.542 --> 05:48:47.542
processing and test that on 
Android device.

05:48:48.831 --> 05:48:50.831
your phone and your wear device.

05:48:51.882 --> 05:48:53.882
Things which is really nice 
because you 

05:48:59.531 --> 05:49:01.979
visualualization and load that 
on your You can work with the 

05:49:01.980 --> 05:49:03.980
visual sedations 

05:49:06.876 --> 05:49:08.876
and then integrate them into the
hardware.

05:49:12.579 --> 05:49:14.579
from processing, you can export 
Android 

05:49:19.981 --> 05:49:21.981
you'll need to upgrade the SDK.

05:49:23.485 --> 05:49:26.129
slightly Android build number.  
Once you do that, you'll be able

05:49:26.130 --> 05:49:28.130
to 

05:49:30.634 --> 05:49:32.634
visual wall sedations to 
manipulate them 

05:49:35.753 --> 05:49:37.753
GPIO inputs.

05:49:40.493 --> 05:49:42.493
So thinking about our iterative 

05:49:43.782 --> 05:49:45.782
about getting feedback on 
Lantern.

05:49:47.302 --> 05:49:49.302
members around us to use it.

05:49:51.285 --> 05:49:53.285
because this was a private thing
we were working on.

05:49:56.536 --> 05:49:58.536
the project.

05:50:01.512 --> 05:50:03.512
Things thought it was 
interesting.

05:50:06.245 --> 05:50:08.245
from was the idea of integrating

05:50:11.174 --> 05:50:13.174
our first iteration of the 
project.

05:50:15.499 --> 05:50:17.499
adverse incorporating 
interactivity 

05:50:19.807 --> 05:50:21.807
we could project content in 
darve fer different ways.

05:50:24.336 --> 05:50:26.336
Interactivity added another 
layer of complexity.

05:50:28.238 --> 05:50:32.312
basic form so we could prove the
working.  However, when we 

05:50:32.313 --> 05:50:34.313
shared the prototype 

05:50:36.621 --> 05:50:38.621
they were keen on integrating a 
camera.

05:50:39.678 --> 05:50:41.678
So because we were working with 

05:50:45.167 --> 05:50:48.831
with 3D printings, we were able 
to make the camera.  The Nord 

05:50:48.832 --> 05:50:50.832
team happened to be working in 
London.

05:50:53.953 --> 05:50:55.953
And the Mountain View team was 
over here.

05:50:57.484 --> 05:50:59.484
story how this evolved because, 
again, 

05:51:02.198 --> 05:51:05.670
access to tools like this like 
3D printing from the web.were 

05:51:05.671 --> 05:51:07.671
able to actually build 
prototypes 

05:51:10.150 --> 05:51:14.312
collaborate them and build them 
up really cool.  Android Things 

05:51:14.313 --> 05:51:17.151
made it really easy to new 
hardware like this and connect 

05:51:17.152 --> 05:51:19.152
it to 

05:51:21.454 --> 05:51:24.155
pieces in a snap.  With the 
camera in place we had a 

05:51:27.472 --> 05:51:29.472
range of interactivity and 
interactive 

05:51:32.386 --> 05:51:34.386
kwau Quick, Draw.

05:51:35.855 --> 05:51:38.104
You may have seen kwaub which is
a labs project from Google that 

05:51:38.105 --> 05:51:40.105
prompts you with a word.

05:51:42.183 --> 05:51:44.183
draw it on the tablet on the web
or on 

05:51:45.282 --> 05:51:47.282
guess what you're drawing.

05:51:49.646 --> 05:51:51.646
in a physical world now we had 
this projected AR system.

05:51:55.172 --> 05:51:57.172
So what we did is we did just 
that.

05:51:59.502 --> 05:52:01.502
limited to screen-based inputs.

05:52:04.801 --> 05:52:06.801
cool if we could just use a pen,
paper, 

05:52:08.688 --> 05:52:10.688
that into the Quick, Draw engine
and 

05:52:13.037 --> 05:52:15.037
that you could use in rt 
physical world.

05:52:18.448 --> 05:52:20.448
the demonstration that we had 
set up over in the IoT dome.

05:52:21.527 --> 05:52:26.003
you haven't visited the dome, 
you can out for yourself.  We 

05:52:26.004 --> 05:52:28.004
have a Lantern set up and it 
works great.

05:52:29.696 --> 05:52:31.696
You're prompted with a word and 
as 

05:52:33.576 --> 05:52:35.576
the pen and paper, it starts to 
guess on in front of you.

05:52:38.462 --> 05:52:40.462
Think of this as a mixed reality
surface.

05:52:43.360 --> 05:52:45.360
There you go.

05:52:48.450 --> 05:52:50.450
So now we've gone one -- through
one cycle, right?

05:52:54.411 --> 05:52:58.903
planned, we've prototyped and we
have some improvements.     &gt;&gt; 

05:52:58.904 --> 05:53:01.747
KRISTIN GRAY:  No, no, no.
product yet.

05:53:10.537 --> 05:53:12.537
So what we're going to do is 
start the 

05:53:14.145 --> 05:53:16.145
process

05:53:17.665 --> 05:53:19.665
maybe mass producing something 
like Lantern.

05:53:21.962 --> 05:53:25.678
So Android Things has many 
started.  After you've completed

05:53:25.679 --> 05:53:28.349
your proof of initial 
prototypes, everything is 

05:53:33.448 --> 05:53:35.906
want to look like and move over 
to awes because of the SOM, like

05:53:35.907 --> 05:53:37.907
I mentioned before.

05:53:39.364 --> 05:53:41.364
to re-do all the work you did in
the 

05:53:43.849 --> 05:53:48.823
because you're using the same 
products.     Say I want to mass

05:53:48.824 --> 05:53:50.824
produce Lantern, right.

05:53:53.139 --> 05:53:55.139
feedback process I wanted to 
learn more 

05:53:58.108 --> 05:54:00.108
and processes, so I visited a 
few factories in China.

05:54:01.969 --> 05:54:04.844
turns out, they have a process 
too and product design process.

05:54:09.378 --> 05:54:11.378
factory will build out a line 
with stations.

05:54:13.526 --> 05:54:15.526
stacked with people who put 
together the product.

05:54:18.228 --> 05:54:20.228
millions of Lantern,the factory 
might 

05:54:25.045 --> 05:54:27.045
make cool robots and automate 
things.

05:54:30.566 --> 05:54:32.566
product designer to continue 
iterating 

05:54:34.672 --> 05:54:36.720
probably leaning more towards 
software changes and I'll show 

05:54:36.721 --> 05:54:38.721
you why.

05:54:40.205 --> 05:54:44.732
( So you've created ten units 
phase, right.  Then you send 

05:54:44.733 --> 05:54:47.392
those off to the factory.they're
going to run everything through 

05:54:49.460 --> 05:54:51.460
validation test.

05:54:54.349 --> 05:54:56.349
And you start out with 
engineering 

05:54:57.476 --> 05:55:02.595
You send your prototypes to the 
back maybe a hundred units.sure 

05:55:02.596 --> 05:55:06.277
that everything works with the 
the.  They're probably going to 

05:55:06.278 --> 05:55:08.278
be using 

05:55:09.948 --> 05:55:14.470
hard tools in this stage to 
create all industrial design.   

05:55:14.471 --> 05:55:16.471
And then after that, after 
you've 

05:55:17.539 --> 05:55:19.539
you send any feedback back to 
the factory.

05:55:21.612 --> 05:55:26.513
design validation tests.tooling.
All. Stations are set up and 

05:55:26.514 --> 05:55:29.782
stacked with people.this point 
the product design team 

05:55:33.853 --> 05:55:35.853
Things Console to update 
software and 

05:55:37.521 --> 05:55:41.841
chance s chabls s channels to 
help your better.  In the 

05:55:41.842 --> 05:55:45.971
meantime you should be user 
these phases.  Once you have 

05:55:45.972 --> 05:55:47.972
feedback from the 

05:55:49.039 --> 05:55:51.482
send things back, then you move 
into the      This phase makes 

05:55:51.483 --> 05:55:56.057
sure that possible.  This is 
more for the factory than you.

05:56:00.355 --> 05:56:02.355
you back about a thousand units.

05:56:05.111 --> 05:56:07.111
test metrics and then for mass 

05:56:11.477 --> 05:56:13.477
the developer console to send 
updates if 

05:56:14.731 --> 05:56:17.179
metrics on these devices.     As
you can see here, as you move 

05:56:21.105 --> 05:56:23.105
should be sending devices back 
to youle 

05:56:25.420 --> 05:56:29.485
should be testing those and 
giving feedback through QA.move 

05:56:29.486 --> 05:56:31.486
forward through this framework 
your 

05:56:34.991 --> 05:56:36.991
get more creative, more 
MacGyvery and 

05:56:39.287 --> 05:56:41.731
because it might be too 
expensive to again in you're 

05:56:41.732 --> 05:56:43.732
working with a product team.    
Some of the tools you can use to

05:56:47.881 --> 05:56:49.881
smoother is the developer 
console.

05:56:52.610 --> 05:56:54.610
library which allows you to -- 
it allows 

05:56:56.919 --> 05:56:58.919
app library and use them on 
multiple projects.

05:57:01.415 --> 05:57:03.415
multiple Lanterns you can write 
one APK 

05:57:04.955 --> 05:57:06.955
each of your different products.

05:57:09.471 --> 05:57:11.471
When you're ready to test Over 
the 

05:57:13.121 --> 05:57:15.121
create releases and channels.

05:57:19.996 --> 05:57:21.996
can actually go through and use 
the -- 

05:57:23.297 --> 05:57:25.297
settings and create a build 
individually 

05:57:27.167 --> 05:57:29.167
the steps to set each of the 
firm aware 

05:57:30.872 --> 05:57:32.872
device and create a build very 
seamlessly.

05:57:34.791 --> 05:57:37.244
When you're ready to test Over 
the create releases and 

05:57:37.245 --> 05:57:39.245
channels.

05:57:41.138 --> 05:57:43.262
channels so you can test your 
softwares detailed testing.

05:57:48.748 --> 05:57:50.748
channel and an update and push 
these 

05:57:52.084 --> 05:57:54.084
devices wirelessly.

05:57:56.666 --> 05:57:58.666
Finally, after your release, you

05:58:02.218 --> 05:58:04.218
you gather equal active data on 
your 

05:58:05.302 --> 05:58:07.302
better decisions on what to do 
next.

05:58:08.367 --> 05:58:11.237
version 0.1 maybe you have a set
of features you 

05:58:14.314 --> 05:58:16.314
you want to move and add Quick, 
Draw you 

05:58:18.411 --> 05:58:20.411
by using the build tool and 
check in doing better.

05:58:23.535 --> 05:58:28.066
Once your device is on the 
market, stop there.  You should 

05:58:28.067 --> 05:58:30.716
be gathering feedback doing and 
checking everything as your 

05:58:30.717 --> 05:58:32.717
device 

05:58:35.636 --> 05:58:37.636
any updates you've created, 
continue 

05:58:39.295 --> 05:58:41.295
gorilla testing and anything in 
that 

05:58:43.003 --> 05:58:45.003
continue to do to help create 
updates 

05:58:47.346 --> 05:58:49.346
you define the next iteration 
cycles through your thing.

05:58:52.491 --> 05:58:54.491
So we've taken you through 

05:58:56.018 --> 05:58:58.018
Android Things kits, making 
final 

05:59:01.136 --> 05:59:03.136
builds and hardware bringup, the
factory 

05:59:05.040 --> 05:59:07.040
the end product with maintenance
and 

05:59:09.152 --> 05:59:10.798
iterations each step of the way.
&gt;&gt; MICHAEL DELGAUDIO:  Thanks, 

05:59:10.799 --> 05:59:12.799
Kristin.

05:59:15.295 --> 05:59:17.348
about today how design is people
in context with goals.it's a 

05:59:17.349 --> 05:59:19.349
process.

05:59:20.428 --> 05:59:22.656
We can plan, prototype, 
feedback, and on that process in

05:59:22.657 --> 05:59:24.657
order to help those 

05:59:26.592 --> 05:59:30.288
achieve those goals.  Now it's 
easier than ever to in the 

05:59:30.289 --> 05:59:34.648
creation of physical products 
before.  Android Things offers 

05:59:34.649 --> 05:59:39.611
tools to help prototyping 
process that you can use ideas.

05:59:43.106 --> 05:59:45.106
Processing enables the fast 

05:59:46.553 --> 05:59:48.588
graphics and combined with 
hardware powerful experiences.

05:59:52.708 --> 05:59:54.708
make better connected products 
for 

06:00:00.980 --> 06:00:05.176
You can get started today at 
experiments.with Google.with 

06:00:05.177 --> 06:00:09.240
Lantern.  You can check out the 
samples at with Google.com.

06:00:12.308 --> 06:00:14.961
If you picked up a kit today 
there's sample code there for 

06:00:14.962 --> 06:00:16.962
you to try out.

06:00:19.674 --> 06:00:21.674
kit you can get one over at the 
IoT dome.

06:00:27.689 --> 06:00:29.689
the Nord group, Ben, Joe, Mike 
and the 

06:00:33.247 --> 06:00:35.247
interconstant neantle 
prototyping for this.

06:00:37.318 --> 06:00:39.979
yes and making the ML magic come
to life.  Come check it out.We 

06:00:39.980 --> 06:00:41.398
would love to see you over 
there.  Thank you guys for 

06:00:41.399 --> 06:00:44.676
coming.If you have feedback, we 
do want to hear from you.

06:00:48.985 --> 06:00:50.985
(Applause).

06:01:04.478 --> 06:01:07.938
&gt;&gt; Thank you for joining this 
session.will assist with 

06:01:07.939 --> 06:01:09.939
directing you through the 
designated exits.

06:01:12.999 --> 06:01:14.999
We'll be making room for those 
who 

06:01:19.312 --> 06:01:20.939
room, we ask that you clear the 
room and registration line 

06:01:20.940 --> 06:01:25.166
outside.  Thank you. 

06:23:07.067 --> 06:23:11.345
Android Things.  Glad you're 
still with us.manager here.

06:23:14.420 --> 06:23:17.070
&gt;&gt; AMY JANG:  I'm Amy and I lead
on Console.     &gt;&gt; ADAM 

06:23:17.071 --> 06:23:19.071
RODRIGUEZ:  We're going to 

06:23:21.145 --> 06:23:23.145
our devices in the field.

06:23:25.007 --> 06:23:27.007
platform for building you some 
IoT.

06:23:29.102 --> 06:23:31.553
more than one of something, how 
do you its lifetime.

06:23:36.077 --> 06:23:38.117
How do you protect those 
devices?we're here to talk about

06:23:38.118 --> 06:23:40.118
today.

06:23:43.006 --> 06:23:45.006
is Android Things and why you 
might want it?

06:23:48.112 --> 06:23:50.112
of Android developed with the 
same tools you know and love.

06:23:51.775 --> 06:23:54.656
This is Android after all so 
it's easy.prototype to 

06:23:54.657 --> 06:23:56.657
production.

06:23:58.559 --> 06:24:01.438
engineer to do this.  We have 
full so many as.

06:24:06.955 --> 06:24:08.985
you need to use Android Things 
SOMMings.for the platform.

06:24:12.302 --> 06:24:15.178
You need the right Android code.
need low level firm aware to 

06:24:15.179 --> 06:24:17.179
drive that hardware.

06:24:19.057 --> 06:24:21.057
updates security it built in.

06:24:22.522 --> 06:24:24.522
security of your device.

06:24:26.211 --> 06:24:29.464
fixes that you can implement 
throughout product.     Our goal

06:24:29.465 --> 06:24:31.465
with Android Things is to 

06:24:32.961 --> 06:24:34.961
you, easy, managed, and secure.

06:24:36.442 --> 06:24:38.442
why is IoT so hard?

06:24:40.353 --> 06:24:42.353
Think about what it would take 
for you 

06:24:45.422 --> 06:24:47.422
managed secure IoT devices.

06:24:49.291 --> 06:24:51.291
building the devices, designing 
the 

06:24:53.490 --> 06:24:56.270
It's hard but it's also the 
special your device unique.

06:25:00.339 --> 06:25:03.205
Beyond that, there's a ton of 
other you have to do.  If you 

06:25:03.206 --> 06:25:05.206
want your devices to be secure, 

06:25:06.257 --> 06:25:08.257
to keep up to date with latest 
security 

06:25:09.510 --> 06:25:11.962
found those patches, you have to
build a patches.

06:25:15.426 --> 06:25:17.956
If the update goes bad, how do I
make break your customer's 

06:25:17.957 --> 06:25:19.957
devices?

06:25:23.475 --> 06:25:25.475
upday-to-days A/B, partitions, 
channel management.

06:25:27.550 --> 06:25:30.193
you need for successful IoT but 
massive job.

06:25:33.243 --> 06:25:36.704
Our goal is to make it easier 
for you with Android Things.The 

06:25:36.705 --> 06:25:41.220
hardware and software design is 
should be.  We make it easier 

06:25:41.221 --> 06:25:43.221
because you can use 

06:25:44.889 --> 06:25:46.889
tools such as Android Studio to 
do it.

06:25:49.006 --> 06:25:51.006
with firm aware code because of 
the SOM model.

06:25:53.543 --> 06:25:55.543
comes to security updates, you 
get to 

06:25:56.813 --> 06:25:58.813
here to find and fix security 
holings.

06:26:01.697 --> 06:26:04.578
you get security patches with 
literally you years after you 

06:26:04.579 --> 06:26:06.579
ship your last device.

06:26:10.915 --> 06:26:12.915
leveraging the same technology 
used to devices every day.

06:26:16.543 --> 06:26:18.543
differentiates your product, the

06:26:22.892 --> 06:26:24.892
&gt;&gt; AMY JANG:  Let's walk through
an example.

06:26:26.545 --> 06:26:28.545
Adam and I are building a 
laundry folding robot.

06:26:30.821 --> 06:26:32.821
folding socks, right?

06:26:38.574 --> 06:26:41.423
Learning which is a perfect use 
case for Android Things.I take 

06:26:41.424 --> 06:26:43.659
it from a prototype that I built
available for everyone?

06:26:46.730 --> 06:26:48.730
comes in.

06:26:55.071 --> 06:26:57.985
market.  You can use the console
to take care of all your needs.

06:27:02.057 --> 06:27:04.308
First in configure, you define a
called products.

06:27:08.809 --> 06:27:10.809
Uploading apps like editor in 
studio, 

06:27:12.476 --> 06:27:14.476
manage your apps using library 
and console.

06:27:19.210 --> 06:27:21.210
you can secure images with apps 
you just wrote.

06:27:25.352 --> 06:27:27.805
seamless updates to your devices
and use your device went out 

06:27:27.806 --> 06:27:29.806
smoothly.

06:27:30.859 --> 06:27:32.859
works.     &gt;&gt; ADAM RODRIGUEZ:  
The first step 

06:27:36.218 --> 06:27:38.218
the console about the product 
you plan to build.

06:27:39.879 --> 06:27:41.879
configure our laundry robot.

06:27:43.470 --> 06:27:45.470
create models.

06:27:47.569 --> 06:27:51.628
Maybe we have a UK skew and a US
skew.are in different versions. 

06:27:51.629 --> 06:27:54.077
You want to pick your SOM type.
Pick a SOM on the features you 

06:27:54.078 --> 06:27:57.556
need and to hit.  Picking a SOM 
is important because it 

06:28:01.203 --> 06:28:03.203
about the mij you want to 
create.

06:28:06.297 --> 06:28:08.297
to change it, it's really easy 
without 

06:28:11.590 --> 06:28:13.590
I really love that about the 
manage SOM model.

06:28:15.470 --> 06:28:17.470
downgrade when you want to cut 
costs at 

06:28:20.138 --> 06:28:24.203
something really cheap and then 
you can powerful SOM.     Set up

06:28:24.204 --> 06:28:26.204
product sharing too.

06:28:29.303 --> 06:28:31.303
together, we build it through 
the 

06:28:33.795 --> 06:28:36.035
create apps and builds.  The 
next step is to write apps.

06:28:38.482 --> 06:28:41.335
Android Things is no exception.
functionality inside of Android 

06:28:41.336 --> 06:28:43.336
Things.

06:28:50.216 --> 06:28:52.216
feature of socks she wrote in 
SoCs APK.

06:28:54.491 --> 06:28:56.491
Play Services, Firebase, it 
always works 

06:28:58.375 --> 06:29:00.375
Android after all.

06:29:02.686 --> 06:29:04.686
can add them into builds.

06:29:07.956 --> 06:29:09.956
break out our laundry robot's 
functionality.

06:29:12.466 --> 06:29:15.110
When you have a new version of 
the takes care to show you the 

06:29:15.111 --> 06:29:18.787
most recent one.     One piece I
really love about this is app 

06:29:18.788 --> 06:29:25.950
sharing.like you can share a 
product with a clob apps too.  

06:29:25.951 --> 06:29:27.951
Android is about building apps 
that 

06:29:29.845 --> 06:29:31.845
and Android Things is no 
exception here either.

06:29:34.733 --> 06:29:36.733
with your team or other people 
building similar products.

06:29:38.188 --> 06:29:40.188
You'll probably only use apps 
you built yourself.

06:29:43.668 --> 06:29:45.903
you're using with other 
utilities and common features.  

06:29:45.904 --> 06:29:47.904
&gt;&gt; AMY JANG:  Now it's time to 

06:29:49.208 --> 06:29:51.208
apps you just built.

06:29:56.142 --> 06:29:58.142
functionality.

06:30:01.467 --> 06:30:03.467
Adam uploaded in the app console
and me.

06:30:07.161 --> 06:30:09.161
It's time to pick it up on a to 
build devices.

06:30:13.473 --> 06:30:15.473
Build everything comes together,
apps, 

06:30:16.543 --> 06:30:18.543
configurations you want to add.

06:30:23.955 --> 06:30:25.955
are called build configurations 
which 

06:30:28.976 --> 06:30:30.976
rules and configuration that 
specify the 

06:30:32.959 --> 06:30:34.959
By device image I mean the 
images to 

06:30:37.005 --> 06:30:39.261
devices an images to create Over
the Air update.     In this 

06:30:39.262 --> 06:30:41.262
build step you can create 

06:30:42.504 --> 06:30:44.769
configurations and manage them. 
For most of you you have just 

06:30:47.834 --> 06:30:49.834
I/O the developer kit.

06:30:52.348 --> 06:30:54.348
starter kit settings.

06:30:55.668 --> 06:30:58.119
prepopulated for you.  For this 
example, let's walk through 

06:31:00.978 --> 06:31:03.234
example from starting from 
scratch.     First, one of the 

06:31:03.235 --> 06:31:05.235
most important 

06:31:06.308 --> 06:31:08.308
Android Things version.

06:31:11.210 --> 06:31:13.652
comfortable with because those 
will have and security ups.

06:31:17.137 --> 06:31:19.394
You're not forced to use the 
latest it's recommended for this

06:31:19.395 --> 06:31:21.823
reason.     Next step in this 
step you will see 

06:31:25.132 --> 06:31:27.422
you have uploaded in the app lib
riff.to include in your build.

06:31:32.147 --> 06:31:35.404
provided by Google like Google 
Play Services.want Google Play 

06:31:35.405 --> 06:31:37.405
Services?

06:31:44.481 --> 06:31:46.481
advantage of the latest Google 
API such 

06:31:47.572 --> 06:31:49.572
Firebase, including the new ML 
kit 

06:31:50.757 --> 06:31:52.986
Simply click on the checkbox you
saw dialogue and it will be 

06:31:52.987 --> 06:31:56.260
included in your build.     &gt;&gt; 
ADAM RODRIGUEZ:  Back to the 

06:31:56.699 --> 06:31:58.699
build.

06:31:59.755 --> 06:32:01.755
your apps, take a look at the 

06:32:03.009 --> 06:32:05.009
requesting and make sure you are
okay with them.

06:32:08.338 --> 06:32:13.050
users can opt with security 
themselves for them.  If you're 

06:32:13.051 --> 06:32:15.532
only using apps, there surprises
but if you're using from 

06:32:18.981 --> 06:32:20.981
This is helpful from preventing 
the 

06:32:22.028 --> 06:32:26.293
something wrong you weren't 
expecting measure.  It won't be 

06:32:26.294 --> 06:32:28.294
surprising to see other 

06:32:31.007 --> 06:32:34.446
other IoT with shared apps so 
looking at important.     The 

06:32:34.447 --> 06:32:36.447
next step is about adding your 
build.

06:32:39.360 --> 06:32:41.360
If your device has a display, 
you can 

06:32:42.443 --> 06:32:44.443
like here.

06:32:45.497 --> 06:32:48.337
You can add your own custom 
animation.if you want to choose 

06:32:48.338 --> 06:32:50.338
fonts.

06:32:52.198 --> 06:32:54.198
displays we don't want to burden
them with fonts.

06:32:56.126 --> 06:33:00.001
about radio reducing the image 
size with products.     Now your

06:33:00.002 --> 06:33:04.516
Android Things device if it was 
just the SOM.  Hardware 

06:33:04.517 --> 06:33:07.387
configuration is where you 
peripherals and control our 

06:33:07.388 --> 06:33:09.388
feed.

06:33:11.461 --> 06:33:14.115
hard kwar config.configurations 
differently.

06:33:17.174 --> 06:33:20.018
it.     While this tool is 
currently 

06:33:26.543 --> 06:33:28.543
This is where you configure all 
your 

06:33:29.604 --> 06:33:34.073
such as cameras, displays and 
speakers.over our I/O.  You can 

06:33:34.074 --> 06:33:36.762
do pinmuxing and determine 
attached to which functions.

06:33:40.627 --> 06:33:42.649
more updates soon.     &gt;&gt; AMY 
JANG:  Here you are in your 

06:33:43.053 --> 06:33:45.960
final build step.You'll see that
the configurations you 

06:33:51.054 --> 06:33:53.054
their total estimated sizes 
under OEM partition.

06:33:54.529 --> 06:33:59.620
estimated size in summary and 
set the partition as you like.  

06:33:59.621 --> 06:34:01.621
You may wonder what are these 

06:34:03.886 --> 06:34:06.741
a developer change and which 
partitions the Air update?

06:34:13.320 --> 06:34:15.320
On the left is a sample 
partition 

06:34:18.867 --> 06:34:20.867
the one you got in the developer
kit.

06:34:23.554 --> 06:34:25.554
differences between the SoC 
vendors and 

06:34:27.809 --> 06:34:29.670
through the partitions used by 
core and the same across all 

06:34:29.671 --> 06:34:31.671
SOMs.  Starting with system.

06:34:33.791 --> 06:34:35.791
boot are read-only partitions.

06:34:37.675 --> 06:34:39.675
Android Things platform.

06:34:41.943 --> 06:34:43.943
Boot is for kernel and system is
where 

06:34:49.113 --> 06:34:51.788
Vbmeta is a read-only partition 
and mechanism.

06:34:55.275 --> 06:34:57.948
As the name suggests this is 
where written too.

06:35:01.220 --> 06:35:03.220
It's a hash written by Google 
using a 

06:35:04.682 --> 06:35:05.701
system and vendor and signed 
with a secure key stored in 

06:35:05.702 --> 06:35:07.702
Google.

06:35:09.190 --> 06:35:11.190
For every boot sequence of a 
device 

06:35:13.697 --> 06:35:15.963
code is authentic and no known 
security using this information.

06:35:19.629 --> 06:35:22.071
has been found.  So you don't 
want to mess around with 

06:35:22.687 --> 06:35:25.540
partition.     Vendor is a 
read-only partition as well.

06:35:30.222 --> 06:35:32.222
the binary image from SoC 
vendors are 

06:35:34.288 --> 06:35:36.288
driver libraries specific to SoC
are usually put in here.

06:35:39.869 --> 06:35:42.120
OEM and OEM bootloader are 
developers and that's you.

06:35:47.260 --> 06:35:49.917
it's been generated, it cannot 
be like I just talked about.

06:35:54.429 --> 06:35:56.859
contents of the build 
configuration that console is 

06:35:56.860 --> 06:35:58.860
written to.

06:36:03.394 --> 06:36:05.394
Android Things developers 
through a console.

06:36:08.284 --> 06:36:10.284
is also generating new when 
you're 

06:36:13.755 --> 06:36:16.543
configuration for the OTA OEM 
bootloader is where the 

06:36:19.599 --> 06:36:21.599
configuration you have schosen 
that build is written too.

06:36:23.057 --> 06:36:25.813
If you're Android developer, you
this partition, user data.

06:36:29.266 --> 06:36:31.266
write their user data at run 
time.

06:36:35.602 --> 06:36:37.602
you install through APK install 
or the 

06:36:40.284 --> 06:36:42.284
Studio are also written into 
this partition.

06:36:43.534 --> 06:36:45.534
question.

06:36:47.824 --> 06:36:49.824
Add package name a unique Ofer 
of the app.

06:36:52.740 --> 06:36:54.740
exists in both user data and OEM
how 

06:36:56.401 --> 06:36:58.401
manager know which app to be 
used?

06:37:02.096 --> 06:37:06.357
been generated so the APKs 
already is.  When you're 

06:37:06.358 --> 06:37:08.358
developing and you're most 

06:37:11.251 --> 06:37:13.251
changing your APKs via ATP 
install.

06:37:19.469 --> 06:37:21.469
flow, the APKs in user data is 
always 

06:37:28.464 --> 06:37:29.478
So what this means is if you 
have OEM, you want the APK 

06:37:29.479 --> 06:37:31.479
loaded in OEM to 

06:37:35.668 --> 06:37:37.668
Misc is another read-only 
partition used by platform.

06:37:39.748 --> 06:37:42.416
for miscellaneous needs like 
bootloader functionalities.

06:37:46.355 --> 06:37:48.355
Factory and its bootloader 

06:37:52.269 --> 06:37:54.269
per device configurations like 
serial 

06:37:56.740 --> 06:37:59.168
factor factory.  This partition 
is writable by 

06:38:03.263 --> 06:38:05.263
factory and going oh be 
read-only offer it's shipped.

06:38:08.157 --> 06:38:09.995
to this partition requires 
special tools will provide for 

06:38:09.996 --> 06:38:12.672
you.     So up to now we've gone
over all 

06:38:16.740 --> 06:38:18.740
Android Things that core 
architecture uses.

06:38:22.253 --> 06:38:25.091
noticed the partitions in this 
table are sections A and B.

06:38:28.759 --> 06:38:30.759
This is where the OTA, Over the 
Air comes in.

06:38:32.635 --> 06:38:34.635
It works by A/B partition 
mechanism 

06:38:36.789 --> 06:38:38.789
exists in two duplicate memory 
spaces.

06:38:41.886 --> 06:38:43.886
use to users where devices can 
still be 

06:38:46.570 --> 06:38:49.419
partition where the updates are 
being in the inactive partitions

06:38:49.420 --> 06:38:51.420
A/B.

06:38:54.305 --> 06:38:56.305
the rebooting with the secure 
boot 

06:38:58.607 --> 06:39:00.607
up to the partition where the 
update has been installed on to.

06:39:04.106 --> 06:39:06.106
It's also important to note that

06:39:07.585 --> 06:39:09.585
Things partitions is fixed at a 
certain size.

06:39:11.446 --> 06:39:13.446
board memory is also fixed.

06:39:16.123 --> 06:39:18.123
remaining fixered memory to be 
split 

06:39:19.648 --> 06:39:21.648
user data partition.

06:39:22.949 --> 06:39:25.191
between the two.     So let's 
walk through an example.

06:39:31.704 --> 06:39:33.704
LTS OS a couple apps, Google 
Play 

06:39:34.779 --> 06:39:36.779
hardware configuration.

06:39:41.124 --> 06:39:43.773
final build step, with he took 
away the that we've seen so far.

06:39:45.816 --> 06:39:47.249
If you haven't been paying 
attention last slides, it's 

06:39:47.250 --> 06:39:49.250
okay.  All you need to know is 
that the 

06:39:53.178 --> 06:39:55.178
partition is fixed size so that 
the OEM 

06:39:57.276 --> 06:39:59.276
ask you to input is going to be 
a size 

06:40:01.989 --> 06:40:03.989
So what this means is when you 

06:40:06.297 --> 06:40:09.274
partition by 100, the user data 
200.

06:40:13.158 --> 06:40:15.158
So here's the most important 

06:40:16.648 --> 06:40:18.648
you should take away interest 
this talk.

06:40:20.920 --> 06:40:22.920
partition size is important when
you're 

06:40:25.392 --> 06:40:27.392
When devices are baked with the 
chosen 

06:40:29.514 --> 06:40:31.514
fixed in the size layout until 
they are reflashed.

06:40:34.622 --> 06:40:36.622
because of the nature of A/B and
the OTA talked about.

06:40:39.747 --> 06:40:42.189
So these devices only receive 
OTA build with the same 

06:40:42.190 --> 06:40:44.190
partition size.

06:40:47.078 --> 06:40:49.078
when setting the size is to 
leave some growth.

06:40:52.186 --> 06:40:54.186
You may want to add more 
functionality to your APK.

06:40:56.067 --> 06:40:58.067
You may want to add new cool 
boot more memory.

06:41:01.149 --> 06:41:03.149
So plan for future and estimate 
how 

06:41:05.066 --> 06:41:07.066
want between apps growth versus 
the data growth.

06:41:09.703 --> 06:41:11.703
Again, you don't have to panic 
yet.

06:41:13.110 --> 06:41:15.110
prototyping and development 
phase, you 

06:41:16.768 --> 06:41:18.768
fining the right size because 
you can reflash the device.

06:41:21.702 --> 06:41:23.702
need to estimate and finalize 
when images.

06:41:26.647 --> 06:41:29.706
You now you've chosen the right 
size build.  You can choose 

06:41:29.707 --> 06:41:31.707
between two image and 
production.

06:41:37.382 --> 06:41:39.382
capabilities like ADB and 
production 

06:41:41.463 --> 06:41:45.961
used by end users.  It doesn't 
provide the bugging.devices are 

06:41:45.962 --> 06:41:47.962
flashed with production 

06:41:52.271 --> 06:41:55.093
tampered for security reason so 
it needs order to make it 

06:41:55.094 --> 06:41:57.094
debugable.

06:41:59.413 --> 06:42:01.413
image will be generated and the 
download browser.

06:42:03.894 --> 06:42:05.894
Now you have download the image 
file.

06:42:07.804 --> 06:42:09.804
from the file to my devices, 
right?

06:42:12.267 --> 06:42:14.267
tool to make it super simple and
easy for you.

06:42:17.378 --> 06:42:19.024
to the tool section and download
the instruction no, sir the 

06:42:19.025 --> 06:42:21.025
script.

06:42:22.563 --> 06:42:24.563
straightforward and your devices
will be ready to go.

06:42:27.646 --> 06:42:29.646
use fastboot mode instead of the
script if you so wish.

06:42:32.012 --> 06:42:35.694
that we're finished building, 
Android Things device.     &gt;&gt; 

06:42:35.695 --> 06:42:37.695
ADAM RODRIGUEZ:  Up until this 

06:42:39.178 --> 06:42:41.616
building functionality into your
Android Things device.Android 

06:42:41.617 --> 06:42:43.617
Things makes development easy, 

06:42:44.677 --> 06:42:47.919
done the same thing with a bunch
of there.  Release is where 

06:42:47.920 --> 06:42:49.920
things get really different.

06:42:51.790 --> 06:42:53.790
supporting, pushing new 
features, not to 

06:43:02.003 --> 06:43:04.003
Things starts to shine.

06:43:11.962 --> 06:43:13.962
with it and you're familiar with
it or 

06:43:27.860 --> 06:43:31.106
First off, use channels to break
up population.  You have a few 

06:43:31.107 --> 06:43:33.107
owned by testers and 

06:43:34.372 --> 06:43:36.372
them all getting the same 
builds.

06:43:37.826 --> 06:43:39.826
segment them logically.

06:43:43.159 --> 06:43:45.159
for people who like blue to 
further divide things.

06:43:46.460 --> 06:43:48.460
channels you can do what you 
want, if 

06:43:51.980 --> 06:43:53.980
is a reference to the Canary in 
the coal mine Id yom.

06:43:55.847 --> 06:43:57.847
there's anything wrong with the 
new 

06:43:59.709 --> 06:44:01.709
will tell you about it first.

06:44:04.629 --> 06:44:07.481
plenty of bugs.  Beta is for 
your teb testers.

06:44:11.768 --> 06:44:14.232
who are okay with new 
functionality and related 

06:44:14.233 --> 06:44:16.233
software.

06:44:18.519 --> 06:44:20.519
everything should work.

06:44:21.782 --> 06:44:24.426
it to be.  In developer previews
we got lots of 

06:44:28.109 --> 06:44:30.109
people wanted lots of channels 
to divide in different ways.

06:44:30.993 --> 06:44:33.428
created custom channels for 
them.     All right.  Now that 

06:44:33.429 --> 06:44:36.063
you have these channels, how get
your devices on to the channels 

06:44:36.064 --> 06:44:39.129
in the first place?default to 
the stable channel.

06:44:43.256 --> 06:44:45.256
channel, you can set it via the 
API or 

06:44:47.203 --> 06:44:49.203
through ADB as shown up here.

06:44:51.886 --> 06:44:53.886
remember how Amy talked about 
release versus develop images.

06:44:56.173 --> 06:44:58.173
You can flash a device to a new 
channel 

06:44:59.616 --> 06:45:01.657
develop image.  You can't change
the channel either.

06:45:05.752 --> 06:45:09.200
to prevent unwanted malicious 
code on your devices.     Okay. 

06:45:09.201 --> 06:45:12.877
Now that you've assigned the 
channels updates to them.  You 

06:45:12.878 --> 06:45:14.929
take the builds we created 
earlier.Create updates from them

06:45:14.930 --> 06:45:19.036
and get them devices.  Updates 
are basically builds with new 

06:45:20.668 --> 06:45:22.668
fixes or changes.

06:45:26.192 --> 06:45:28.192
or an Over the Air update.

06:45:29.443 --> 06:45:31.443
into the B partition.

06:45:33.124 --> 06:45:37.829
partition.  However if there's a
problem, it A partition.  I love

06:45:37.830 --> 06:45:39.830
this.

06:45:42.549 --> 06:45:44.549
instant and fault tolerant too.

06:45:47.260 --> 06:45:49.260
Things takes advantage of this.

06:45:50.310 --> 06:45:52.310
Rather than pushing an update up
to 

06:45:56.007 --> 06:45:58.007
you can role it on gradually 
you're not the same time.

06:46:01.330 --> 06:46:04.210
We recommend it to derisk your 
updates.all of this technology 

06:46:04.211 --> 06:46:06.211
is using the same 

06:46:07.488 --> 06:46:09.488
every day to update millions of 
devices 

06:46:11.348 --> 06:46:13.348
updates, fractional updates.

06:46:17.060 --> 06:46:20.311
but crucially important if you 
want updates world-wide.     &gt;&gt; 

06:46:20.312 --> 06:46:22.312
AMY JANG:  Android Things 

06:46:24.171 --> 06:46:28.447
architecture that Google uses.
work.  You might be wondering 

06:46:28.448 --> 06:46:35.801
how does the the hood?  When you
specify through Android update 

06:46:35.802 --> 06:46:37.802
the OTA server to hold 

06:46:39.049 --> 06:46:41.049
your update channel.

06:46:42.507 --> 06:46:44.507
The devices will report to the 
OTA 

06:46:45.565 --> 06:46:47.565
information every five hour 
interval.

06:46:50.266 --> 06:46:52.266
let the devices know that you 
have an update to pick it up.

06:46:54.970 --> 06:46:56.970
Devices download and install the

06:46:58.652 --> 06:47:00.652
inactive A/B partition that we 
talked about.

06:47:02.741 --> 06:47:04.741
be able to use the devices while
this -- during this process.

06:47:08.022 --> 06:47:10.022
Using Update Manager API, you 
have full 

06:47:11.710 --> 06:47:13.710
policies such as hauven do you 
want your 

06:47:17.363 --> 06:47:20.084
update check and customize 
update behavior by link to 

06:47:20.488 --> 06:47:22.488
events.

06:47:23.946 --> 06:47:25.946
Let's go through a set of events

06:47:27.607 --> 06:47:29.663
device and the following updates
posted to that app listener.

06:47:32.321 --> 06:47:34.321
Update engine will check OTA to 
the 

06:47:36.596 --> 06:47:38.596
will let the client know there's
a new update to pick it up.

06:47:41.631 --> 06:47:44.530
will start the downloading the 
update.flow diagram, the 

06:47:44.531 --> 06:47:46.531
corresponding update 

06:47:47.794 --> 06:47:49.794
listener and that's your app.

06:47:52.738 --> 06:47:57.012
set, your app can trigger reboot
of the it's appropriate.  When 

06:47:57.013 --> 06:47:59.667
the device boots up, it will the
new partition where the update 

06:47:59.668 --> 06:48:01.668
is written to.

06:48:04.992 --> 06:48:06.992
Upon reboot it checks for update

06:48:12.179 --> 06:48:14.210
already updated it sits back at 
the idle update check happens.

06:48:16.451 --> 06:48:20.371
policy.  You can grap the Update
Manager policy you like.

06:48:24.688 --> 06:48:26.688
Using apply only policy Update 
Manager 

06:48:27.732 --> 06:48:32.420
download and install the update 
whenever available.  You can the

06:48:32.421 --> 06:48:35.308
change the update API say two 
days for example.

06:48:38.348 --> 06:48:40.348
But say you want to control the 
whole flow.

06:48:42.672 --> 06:48:44.672
use the check only policy to 
listen to 

06:48:46.156 --> 06:48:48.156
control the whole update 
process.

06:48:50.031 --> 06:48:52.031
available status, you can decide
whether 

06:48:53.500 --> 06:48:55.500
start the download and install 
and when 

06:48:57.974 --> 06:48:59.974
time, you can trigger the 
perform update it.

06:49:02.908 --> 06:49:04.908
When complete, you will get the 

06:49:06.630 --> 06:49:11.741
and also when you think it's a 
good devices to reboot.  It's 

06:49:11.742 --> 06:49:16.444
all again under your control.   
It's very possible that your day

06:49:16.445 --> 06:49:18.445
update.

06:49:20.138 --> 06:49:22.138
When a customer buys a product 
after 

06:49:23.614 --> 06:49:27.888
time, you might have already 
upgraded next coolest thing.  

06:49:27.889 --> 06:49:30.968
You want them to start with 
that, right?You don't want users

06:49:30.969 --> 06:49:32.969
to download a 

06:49:35.445 --> 06:49:37.445
software before they can start 
using your product.

06:49:40.528 --> 06:49:42.528
updates mean this pay load 
update is as small as possible.

06:49:46.968 --> 06:49:48.968
Basically based on your factory 
image 

06:49:53.020 --> 06:49:55.020
OTA pushes Android Things 
Console will 

06:50:02.191 --> 06:50:05.654
between their current build and 
your new coolest thing.that your

06:50:05.655 --> 06:50:07.655
friend was unwrapping a 

06:50:09.712 --> 06:50:11.712
have to wait 20 minutes to 
download the latest version?

06:50:11.771 --> 06:50:13.771
terrible experience, right?

06:50:15.285 --> 06:50:19.759
better.     &gt;&gt; ADAM RODRIGUEZ:  
At this point bit of time 

06:50:19.760 --> 06:50:21.760
talking about security.

06:50:25.688 --> 06:50:27.688
simply build a secure device.

06:50:32.549 --> 06:50:34.549
and updating and looking for 

06:50:51.027 --> 06:50:53.027
but maybe we get different jobs 
and then what?

06:50:55.510 --> 06:50:57.510
about a new vulnerability do we 
research kernel library fixes?

06:50:59.499 --> 06:51:01.560
Maybe we get with the engineers 
and push it to our users?  No.

06:51:02.362 --> 06:51:04.362
That's not what happens.

06:51:09.360 --> 06:51:11.360
live on connected to the internt
perhaps 

06:51:12.420 --> 06:51:14.420
vulnerable.

06:51:16.094 --> 06:51:18.094
Thankly we have a solution to 
this.

06:51:19.390 --> 06:51:21.390
SOM strategy Google can 
confidently push 

06:51:24.694 --> 06:51:29.371
IoT devices running that SOM be 
it a web cam.  Flip this flag on

06:51:29.372 --> 06:51:31.372
your channel and all 

06:51:32.682 --> 06:51:34.682
get regular updates from Google 
with zero involvement from you.

06:51:35.962 --> 06:51:37.962
It's important to note you're 
not required to flip this flag.

06:51:40.842 --> 06:51:42.842
If you don't enable auto updates
you can 

06:51:44.298 --> 06:51:49.883
want to manage them.yourself.   
Let's talk about how Android 

06:51:49.884 --> 06:51:56.829
Things works.  Major versions on
Android Things releases in 

06:51:56.830 --> 06:51:58.830
normal Android.

06:52:01.558 --> 06:52:03.558
over the long term and represent
Android API framework changes.

06:52:05.472 --> 06:52:08.120
The auto update flag on their 
channel major versions.

06:52:11.388 --> 06:52:13.388
If you start on major version 1 
even 

06:52:15.251 --> 06:52:17.686
version 2 is released, you get 
security 1 if you so choose.

06:52:20.935 --> 06:52:23.397
The minor version are low risk 
updates.They don't have 

06:52:23.398 --> 06:52:25.651
framework changes but API 
additions.

06:52:29.140 --> 06:52:31.140
If you flip the auto update 
flag, you 

06:52:32.587 --> 06:52:34.587
to get updates on major versions
if you start at 1.

06:52:39.516 --> 06:52:43.206
next minor version rolls out you
will migrate to 1.3.see these 

06:52:43.207 --> 06:52:45.207
approximately every month.

06:52:50.557 --> 06:52:52.557
and these updates auto update 
with the auto update.

06:52:55.257 --> 06:52:57.257
updates through Google we expect
you to 

06:52:58.925 --> 06:53:00.996
across every minor version and 
security patch.up to you.

06:53:04.685 --> 06:53:08.540
You can flip the auto update 
flag or yourself.  It's our goal

06:53:08.541 --> 06:53:12.406
to make it the easiest there.  
Over the lifetime of your 

06:53:12.407 --> 06:53:14.407
product.

06:53:16.682 --> 06:53:19.338
work across SOMs and major 
versions and years?     Each SOM

06:53:19.339 --> 06:53:21.993
is supported by Google for years
from the time it was first made 

06:53:24.301 --> 06:53:26.301
available major version.

06:53:30.411 --> 06:53:32.411
and start building on major 
version 1 

06:53:34.471 --> 06:53:36.471
the next three years while 
remaining on version 1.

06:53:38.568 --> 06:53:40.568
have to update to major version 
2 to get the full support time.

06:53:44.482 --> 06:53:46.482
Of course devices will need much
longer than three years.

06:53:48.566 --> 06:53:50.566
can update to the next version 
and get a longer support window.

06:53:52.868 --> 06:53:56.545
You can push your own updates 
your your lifetime.  Finally if 

06:53:56.546 --> 06:53:58.546
you're looking for longer 

06:54:00.042 --> 06:54:01.265
talk to us for options for 
extended support.     &gt;&gt; AMY 

06:54:01.266 --> 06:54:05.402
JANG:  All right.  We've pushed 
our updates.robots can now fold 

06:54:05.403 --> 06:54:07.403
sockings.

06:54:09.941 --> 06:54:11.941
back and monitor how our robots 
are doing in the field.

06:54:14.507 --> 06:54:16.507
might want to check how many 
users are 

06:54:19.002 --> 06:54:23.070
getting the updates I just 
pushed or how is my U.S.compared

06:54:23.071 --> 06:54:25.071
to those in Korea.

06:54:28.192 --> 06:54:30.192
solution all the way to device 
analytics.

06:54:32.675 --> 06:54:34.675
you can monitor how your devices
are doing across your product.

06:54:36.744 --> 06:54:38.744
You can use time rates and 
filter to do a deeper analysis.

06:54:42.261 --> 06:54:44.261
can filter devices by IP 
countryings and on.

06:54:47.809 --> 06:54:49.809
Within an hour after you push 
OTA 

06:54:51.889 --> 06:54:53.889
come to this monitor screen to 
see how 

06:54:55.963 --> 06:54:57.963
if there are any errors and what
stage are your devices at?

06:55:02.483 --> 06:55:04.483
the granularity that we provide 
is up to every minute.

06:55:06.558 --> 06:55:08.558
monitor update checks, various 
download 

06:55:10.301 --> 06:55:14.976
finally the reboot event which 
tells the the new partition.  

06:55:14.977 --> 06:55:17.440
These events that you see here 
map to status events you saw in 

06:55:17.441 --> 06:55:19.441
the Update Manager API earlier.

06:55:22.742 --> 06:55:24.742
If there were any errors with 
the 

06:55:30.449 --> 06:55:32.449
the update error graph and

06:55:36.022 --> 06:55:38.022
push my OTA I can watch this 
graph to 

06:55:39.902 --> 06:55:42.766
doing well, if the release that 
I pushed went out smoothly.     

06:55:42.767 --> 06:55:44.767
&gt;&gt; ADAM RODRIGUEZ:  Okay.

06:55:45.818 --> 06:55:47.818
update your production devices 
in the 

06:55:52.458 --> 06:55:54.458
quickly about why you should 
care.

06:56:04.053 --> 06:56:06.053
that matters, the hardware ander

06:56:07.535 --> 06:56:09.535
differentiate your product and 
lean on

06:56:12.062 --> 06:56:14.062
regular Android developers and 
use Kotlin and Android Studio.

06:56:15.715 --> 06:56:17.715
You get to take advantage of the
same 

06:56:19.196 --> 06:56:21.196
update millions of devices in 
the field every day.

06:56:23.512 --> 06:56:24.127
fractional updates A/B 
partitions and enhanced 

06:56:24.128 --> 06:56:27.587
monitoring.you imagine building 
all of this yourself.  I'm sure 

06:56:27.588 --> 06:56:29.588
you could.

06:56:30.668 --> 06:56:32.668
But something tells me you would
much 

06:56:36.605 --> 06:56:39.248
functions than updating a 
structure.     There are 

06:56:39.249 --> 06:56:41.249
security updates from 

06:56:43.328 --> 06:56:45.562
make sure your product stays 
secure from you for years down 

06:56:45.563 --> 06:56:47.563
the road.

06:56:50.237 --> 06:56:52.237
make it easy to build secure 
updatable 

06:56:53.339 --> 06:56:55.339
there's so much opportunity for 
new 

06:56:57.283 --> 06:57:00.137
&gt;&gt; AMY JANG:  With that we want 
to attending our talk on how to 

06:57:00.138 --> 06:57:02.192
update field with Android Things
Console.

06:57:06.670 --> 06:57:11.418
are many options out there for 
IoT which choose.  If you're 

06:57:11.419 --> 06:57:13.419
comfortable with writing 

06:57:14.465 --> 06:57:16.465
Android Things makes it super 
easy for you to get started.

06:57:20.589 --> 06:57:22.589
you plan to build and if you 
care about 

06:57:24.668 --> 06:57:26.499
and you want easy management of 
your Things will be a great 

06:57:26.500 --> 06:57:28.500
solution for you.  Thank you.

06:57:31.585 --> 06:57:33.585
(Applause)

