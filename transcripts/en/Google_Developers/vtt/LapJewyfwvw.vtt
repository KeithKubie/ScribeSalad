WEBVTT
Kind: captions
Language: en

00:00:00.730 --> 00:00:02.230
GAVIN DOUGHTIE: I
am Gavin Doughtie.

00:00:02.230 --> 00:00:04.330
I am an engineer on the
AdWords mobile team.

00:00:04.330 --> 00:00:05.560
We're using Flutter.

00:00:05.560 --> 00:00:07.360
And you're lying
about your state,

00:00:07.360 --> 00:00:10.540
but I hope only to yourselves.

00:00:10.540 --> 00:00:13.760
So since we're at a
cutting-edge tech conference,

00:00:13.760 --> 00:00:17.110
I'm going to go all
the way back to 1981

00:00:17.110 --> 00:00:20.290
and the introduction
of the Xerox Star

00:00:20.290 --> 00:00:22.150
personal workstation.

00:00:22.150 --> 00:00:24.970
Now, this computer is
famed in computer history

00:00:24.970 --> 00:00:27.040
for introducing things
like the graphical user

00:00:27.040 --> 00:00:30.280
interface and the mouse
and a bunch of other stuff

00:00:30.280 --> 00:00:35.150
that Steve Jobs might have
seen once upon a time.

00:00:35.150 --> 00:00:37.900
But it also included this, which
is the Smalltalk programming

00:00:37.900 --> 00:00:38.810
language.

00:00:38.810 --> 00:00:40.990
Now, this was actually one
of the major innovations

00:00:40.990 --> 00:00:42.830
of this computer.

00:00:42.830 --> 00:00:45.230
Smalltalk was a deeply
object-oriented language.

00:00:45.230 --> 00:00:48.040
And it heavily influenced all
the languages that came after,

00:00:48.040 --> 00:00:50.380
including Objective-C and Java.

00:00:50.380 --> 00:00:52.766
And of course, Dart.

00:00:52.766 --> 00:00:55.390
But one thing that it did that's
different from those languages

00:00:55.390 --> 00:01:01.494
is it exposed an integrated
graphical user environment that

00:01:01.494 --> 00:01:03.160
encouraged you to
think about the system

00:01:03.160 --> 00:01:04.989
not as a bunch of
source code files,

00:01:04.989 --> 00:01:07.390
but as a bunch of
live objects that you

00:01:07.390 --> 00:01:12.140
could inspect and change
and add more classes to.

00:01:12.140 --> 00:01:15.130
And not just the objects that
might be in your application,

00:01:15.130 --> 00:01:17.900
but objects in the runtime
environment as well.

00:01:17.900 --> 00:01:20.410
For example, the
CEO at the startup

00:01:20.410 --> 00:01:23.510
where I was using Smalltalk
was not an engineer.

00:01:23.510 --> 00:01:26.295
And when they saw the red
debugger window pop up,

00:01:26.295 --> 00:01:27.670
she was like, oh,
these engineers

00:01:27.670 --> 00:01:28.450
are not doing their jobs.

00:01:28.450 --> 00:01:29.491
They shouldn't have bugs.

00:01:29.491 --> 00:01:32.021
So we were able to change
the background color to blue.

00:01:32.021 --> 00:01:34.430
[LAUGHTER]

00:01:34.430 --> 00:01:36.310
So another thing
that Smalltalk did

00:01:36.310 --> 00:01:39.580
was it promoted the idea
of a model view controller

00:01:39.580 --> 00:01:41.501
architecture.

00:01:41.501 --> 00:01:43.000
And we're not going
to go into this,

00:01:43.000 --> 00:01:45.370
but I'm sure you guys
have read a lot about it.

00:01:45.370 --> 00:01:48.060
And this was very
innovative at the time.

00:01:48.060 --> 00:01:51.490
You could have things like
your model encapsulating logic

00:01:51.490 --> 00:01:53.691
as well as the
data that operate--

00:01:53.691 --> 00:01:55.690
as well as the data that
that logic operated on.

00:01:55.690 --> 00:01:58.490
And it gave you a nice
separation of concerns.

00:01:58.490 --> 00:02:02.200
But this was a while
ago, and the Xerox Star,

00:02:02.200 --> 00:02:05.100
and many of the other computers
that came along afterwards,

00:02:05.100 --> 00:02:07.840
were kind of designed
around the assumption

00:02:07.840 --> 00:02:09.340
that you had a
single user sitting

00:02:09.340 --> 00:02:12.700
at a single machine using
a single object model that

00:02:12.700 --> 00:02:15.640
was sitting in memory and was
very sporadically updated.

00:02:15.640 --> 00:02:18.250
It tended to be like slurp it
off disk, show it in memory,

00:02:18.250 --> 00:02:22.480
and splat it back down at the
end when you saved your files.

00:02:22.480 --> 00:02:27.560
And this model is really old
and not really relevant anymore.

00:02:27.560 --> 00:02:30.550
So the way that data works
in your applications today

00:02:30.550 --> 00:02:33.830
is more like this, where
you've got multiple users.

00:02:33.830 --> 00:02:35.380
You've got multiple sensors.

00:02:35.380 --> 00:02:40.094
You've got data being
updated in real time, right?

00:02:40.094 --> 00:02:42.760
Or you have something like this,
where you have-- you might even

00:02:42.760 --> 00:02:44.350
have the same user
using two devices,

00:02:44.350 --> 00:02:46.392
like, oh, I'm going to do
some stuff on my phone,

00:02:46.392 --> 00:02:48.224
and now I'm going to
jump over to my desktop

00:02:48.224 --> 00:02:49.190
and make some edits.

00:02:49.190 --> 00:02:53.907
And five other people doing the
same thing at the same time.

00:02:53.907 --> 00:02:55.990
And the idea that I want
you to take away with you

00:02:55.990 --> 00:02:58.150
is that of live data.

00:02:58.150 --> 00:03:01.780
And really, I think
all data is live data.

00:03:01.780 --> 00:03:04.610
All data is going
to change over time.

00:03:04.610 --> 00:03:06.700
And it may not change
on the schedule

00:03:06.700 --> 00:03:10.839
that you are thinking
about right now.

00:03:10.839 --> 00:03:12.130
But we have tools for this now.

00:03:12.130 --> 00:03:14.440
We also have this idea
of functional reactive

00:03:14.440 --> 00:03:16.510
programming, where you
can think of things less

00:03:16.510 --> 00:03:20.391
as I'm going to call functions
on an object and change that

00:03:20.391 --> 00:03:20.890
object.

00:03:20.890 --> 00:03:23.260
You can think of it
more as information

00:03:23.260 --> 00:03:25.000
flowing through your
system, and you're

00:03:25.000 --> 00:03:27.416
kind of like-- you're having
the components of your system

00:03:27.416 --> 00:03:30.430
grab the data and look at it
and produce different data that

00:03:30.430 --> 00:03:33.690
goes out the other end.

00:03:33.690 --> 00:03:36.720
You can think of this
as data streaming around

00:03:36.720 --> 00:03:39.120
in your application.

00:03:39.120 --> 00:03:43.700
So Dart and Flutter make
it really easy to do this.

00:03:43.700 --> 00:03:47.200
You've got a great Streams
API, the Dart Streams API.

00:03:47.200 --> 00:03:49.120
It's full of rich operators.

00:03:49.120 --> 00:03:52.900
If you want a formalism for
creating snapshots of data

00:03:52.900 --> 00:03:55.030
as it changes,
you can use Redux.

00:03:55.030 --> 00:03:57.210
Brian Egan's got a talk
about that tomorrow.

00:03:57.210 --> 00:04:01.270
The next Lightning Talk
also is partly about Redux.

00:04:01.270 --> 00:04:03.550
And if you want an even
richer set of operators,

00:04:03.550 --> 00:04:06.790
you can use observables
with the Rx Dart library.

00:04:06.790 --> 00:04:10.530
The author of that is
here at the conference.

00:04:10.530 --> 00:04:13.369
And once you have
a stream of data,

00:04:13.369 --> 00:04:14.910
you can use the
Flutter StreamBuilder

00:04:14.910 --> 00:04:19.621
widget to render that data in
a pretty straightforward way.

00:04:19.621 --> 00:04:21.329
I'm not going to go
over all the details,

00:04:21.329 --> 00:04:24.870
but the main thing is
you can pass it a stream,

00:04:24.870 --> 00:04:26.430
and the StreamBuilder
widget will

00:04:26.430 --> 00:04:29.550
take snapshots of the data
coming out of that stream

00:04:29.550 --> 00:04:31.890
periodically, whenever
the data changes,

00:04:31.890 --> 00:04:33.864
and pass it to your
supplied build function.

00:04:33.864 --> 00:04:35.280
So you can build
a widget from it.

00:04:35.280 --> 00:04:38.070
So you don't have to like keep
state inside of your Stateful

00:04:38.070 --> 00:04:38.570
widget.

00:04:38.570 --> 00:04:40.111
You can just assume
that you're being

00:04:40.111 --> 00:04:43.270
handed the next state that
your widget needs to render.

00:04:43.270 --> 00:04:45.060
So don't lie to yourself.

00:04:45.060 --> 00:04:47.140
The truth will set you free.

00:04:47.140 --> 00:04:48.090
Oh, wait.

00:04:48.090 --> 00:04:48.600
It's not.

00:04:48.600 --> 00:04:49.470
I've got one slide.

00:04:49.470 --> 00:04:50.640
OK.

00:04:50.640 --> 00:04:51.630
Here's the real truth.

00:04:51.630 --> 00:04:54.090
Smalltalk, even though
the user model was

00:04:54.090 --> 00:04:56.310
you are operating
on objects, what

00:04:56.310 --> 00:04:58.440
they were doing as you
made these changes is

00:04:58.440 --> 00:05:01.139
they were writing these
changes down to a log file.

00:05:01.139 --> 00:05:03.180
So you could take the base
image in this log file

00:05:03.180 --> 00:05:04.750
and reconstitute your state.

00:05:04.750 --> 00:05:06.870
So even if you go all
the way back to 1981,

00:05:06.870 --> 00:05:09.120
there was still this
concept of a stream of data,

00:05:09.120 --> 00:05:11.810
and the stream
was authoritative.

00:05:11.810 --> 00:05:12.420
That's it.

00:05:12.420 --> 00:05:13.860
Thank you.

00:05:13.860 --> 00:05:15.710
[APPLAUSE]

