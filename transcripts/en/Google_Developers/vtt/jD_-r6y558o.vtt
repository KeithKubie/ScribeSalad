WEBVTT
Kind: captions
Language: en

00:00:03.670 --> 00:00:04.660
RYAN FIORAVANTI: I'm going
to get started now.

00:00:04.660 --> 00:00:06.550
Welcome everyone.

00:00:06.550 --> 00:00:08.039
My name is Ryan Fioravanti.

00:00:08.039 --> 00:00:10.350
I'm here today from the Gmail
team to talk about building

00:00:10.350 --> 00:00:12.250
fast mobile web apps.

00:00:12.250 --> 00:00:14.510
And if you'd like to follow
along on your laptop or

00:00:14.510 --> 00:00:16.020
device, the URL is up here.

00:00:16.020 --> 00:00:17.730
You can see the slides at

00:00:17.730 --> 00:00:26.390
rjf-io2012.appspot.com OK.

00:00:26.390 --> 00:00:29.370
Everyone loves fast stuff,
especially users.

00:00:29.370 --> 00:00:32.439
And developers like building
fast things.

00:00:32.439 --> 00:00:34.470
Unfortunately, on the mobile
web, it's really

00:00:34.470 --> 00:00:36.390
difficult to do.

00:00:36.390 --> 00:00:38.790
Today I'm going to try and
present a few things that I

00:00:38.790 --> 00:00:42.550
hope you can use to help
build faster mobile web

00:00:42.550 --> 00:00:45.120
applications.

00:00:45.120 --> 00:00:47.840
When I start looking at
performance work, I like to

00:00:47.840 --> 00:00:51.080
approach things in a very
structured manner.

00:00:51.080 --> 00:00:53.760
What that means for me is before
I start working on some

00:00:53.760 --> 00:00:57.180
improvements, I like to measure
first to prove myself

00:00:57.180 --> 00:00:58.400
that there's actually
a problem that

00:00:58.400 --> 00:01:00.360
I'm trying to solve.

00:01:00.360 --> 00:01:03.150
As I start working on the
problem, I then remeasure

00:01:03.150 --> 00:01:06.920
throughout the process to make
sure that I'm making progress

00:01:06.920 --> 00:01:08.605
in a way that I'm happy with.

00:01:08.605 --> 00:01:12.190
And finally, when I think I'm
done, I'll measure again to

00:01:12.190 --> 00:01:14.840
see that I actually had impact
I thought I would.

00:01:14.840 --> 00:01:16.620
And if I didn't find an
improvement, I think it's

00:01:16.620 --> 00:01:19.380
really important in those
cases to investigate and

00:01:19.380 --> 00:01:22.040
figure out why the work that I
did didn't have the impact

00:01:22.040 --> 00:01:24.040
that I thought it would.

00:01:24.040 --> 00:01:26.370
I seen a lot of people spend a
lot of time trying to make

00:01:26.370 --> 00:01:30.350
performance optimizations based
off hunches they have or

00:01:30.350 --> 00:01:32.740
ideas, and they spend
a lot of time.

00:01:32.740 --> 00:01:34.710
When they're done, it
ends up having no

00:01:34.710 --> 00:01:35.980
impact for the users.

00:01:35.980 --> 00:01:38.190
And there's no benefit.

00:01:38.190 --> 00:01:41.080
So we want to avoid these
kinds of situations.

00:01:41.080 --> 00:01:43.550
With this kind of thinking in
mind, this kind of approach, I

00:01:43.550 --> 00:01:47.850
decided to structure this
presentation today around a

00:01:47.850 --> 00:01:49.600
live website.

00:01:49.600 --> 00:01:51.500
So I decided to pick on

00:01:51.500 --> 00:01:54.040
html5rocks.com, the mobile version.

00:01:54.040 --> 00:01:56.160
And what we're going to do
is do a little bit of

00:01:56.160 --> 00:01:58.740
exploration, a little bit of
measurements, to try to

00:01:58.740 --> 00:02:02.440
identify what kind of problems
it has, and what kind of fixes

00:02:02.440 --> 00:02:06.810
we can make and how much
we can improve this.

00:02:06.810 --> 00:02:09.770
So before we start working on
improvements, we first have to

00:02:09.770 --> 00:02:12.320
measure to figure out what's
actually wrong.

00:02:12.320 --> 00:02:16.350
The best way to do that is by
using a device to do all these

00:02:16.350 --> 00:02:18.230
measurements for us.

00:02:18.230 --> 00:02:20.920
Now that you all have Chrome on
an Android device, this is

00:02:20.920 --> 00:02:22.310
really easy for you to do.

00:02:22.310 --> 00:02:24.730
And Chrome on Android comes
with a really neat feature

00:02:24.730 --> 00:02:27.560
where you can use the remote
debugger to do profiling on

00:02:27.560 --> 00:02:29.150
the device itself.

00:02:29.150 --> 00:02:31.640
And this is really useful,
because profiling on your

00:02:31.640 --> 00:02:35.950
local desktop browser, for
example, is not at all the

00:02:35.950 --> 00:02:38.170
same as profiling on
your mobile device.

00:02:38.170 --> 00:02:39.230
The hardware's very different.

00:02:39.230 --> 00:02:40.940
The performance is
really different.

00:02:40.940 --> 00:02:42.230
And so we really need
to do all this

00:02:42.230 --> 00:02:44.600
profiling on a mobile device.

00:02:44.600 --> 00:02:47.760
We're also going to install the
PageSpeed extension, and

00:02:47.760 --> 00:02:50.090
this is going to help us run
a bunch of automated

00:02:50.090 --> 00:02:52.020
analysis on the page.

00:02:52.020 --> 00:02:54.300
And hopefully we can get some
quick wins based on its

00:02:54.300 --> 00:02:55.550
recommendations.

00:02:59.290 --> 00:03:01.560
OK, before we get started out
with PageSpeed or anything

00:03:01.560 --> 00:03:05.410
else, we need to define
our success criteria.

00:03:05.410 --> 00:03:08.160
So to do that, we need an
accurate way to make some

00:03:08.160 --> 00:03:09.690
measurements and figure
out if we're

00:03:09.690 --> 00:03:12.320
actually improving anything.

00:03:12.320 --> 00:03:14.060
Typically this has been
done in a couple

00:03:14.060 --> 00:03:15.830
of ways in the past.

00:03:15.830 --> 00:03:17.977
One of the most common ways that
developers would profile

00:03:17.977 --> 00:03:21.140
their application or do
measurements for performance

00:03:21.140 --> 00:03:25.180
timings, was to add timings in
script blocks for the page.

00:03:25.180 --> 00:03:27.850
So it was really common to see
people add a script block at

00:03:27.850 --> 00:03:30.480
the top of the document where
they would take a time.

00:03:30.480 --> 00:03:31.630
And that would be time zero.

00:03:31.630 --> 00:03:33.830
And then they would have timing
throughout the page,

00:03:33.830 --> 00:03:36.240
which they could then use the
deltas of to decide how long

00:03:36.240 --> 00:03:39.840
certain parts of the page took
for the browser to render.

00:03:42.540 --> 00:03:44.570
There's a couple of
problems with this

00:03:44.570 --> 00:03:45.550
that we want to avoid.

00:03:45.550 --> 00:03:47.930
Number one, just by adding these
measurements to your

00:03:47.930 --> 00:03:50.350
page, you can actually have
a negative impact on the

00:03:50.350 --> 00:03:51.380
browser's performance.

00:03:51.380 --> 00:03:53.730
So just by measuring and looking
at it, you're changing

00:03:53.730 --> 00:03:54.950
the situation.

00:03:54.950 --> 00:03:56.650
So we want to avoid that.

00:03:56.650 --> 00:03:58.920
But also, using this technique,
we were only able

00:03:58.920 --> 00:04:02.320
to measure things that were
happening in the browser after

00:04:02.320 --> 00:04:04.850
the browser has received
the page content.

00:04:04.850 --> 00:04:07.170
We didn't have access to things
like, how long did a

00:04:07.170 --> 00:04:07.870
redirect take?

00:04:07.870 --> 00:04:09.320
How long did the DNS
lookups take?

00:04:09.320 --> 00:04:13.720
How long did the page take to
download from first byte to

00:04:13.720 --> 00:04:16.209
the last byte being
sent to the page?

00:04:16.209 --> 00:04:18.050
Using this
window.performance.timing

00:04:18.050 --> 00:04:20.200
object, we're able to
capture all that

00:04:20.200 --> 00:04:21.920
information really easily.

00:04:21.920 --> 00:04:24.290
This is an object that's
injected by the browser on

00:04:24.290 --> 00:04:27.050
every page load, and it contains
a lot of different

00:04:27.050 --> 00:04:29.340
attributes that we can
use to analyze the

00:04:29.340 --> 00:04:31.920
full pageload sequence.

00:04:31.920 --> 00:04:32.800
So this is really cool.

00:04:32.800 --> 00:04:35.240
And we're going to use this in
a bunch of experiments that

00:04:35.240 --> 00:04:38.280
we're going to do throughout
this presentation.

00:04:38.280 --> 00:04:41.100
The ones I found particularly
interesting from the

00:04:41.100 --> 00:04:44.020
experiments I was running
were these four.

00:04:44.020 --> 00:04:45.940
So first of all, the most
important one is

00:04:45.940 --> 00:04:47.880
navigationStart timing.

00:04:47.880 --> 00:04:50.410
This is the exact time that
the user requested for the

00:04:50.410 --> 00:04:51.380
page to be loaded.

00:04:51.380 --> 00:04:55.290
So this is them clicking a link
to go to your page, or

00:04:55.290 --> 00:04:58.610
typing in the URL, or
opening a bookmark.

00:04:58.610 --> 00:05:01.060
From the user's perspective,
this is time zero, and

00:05:01.060 --> 00:05:03.410
everything after this time is
them sitting there staring at

00:05:03.410 --> 00:05:07.530
a white screen, waiting for
your content to appear.

00:05:07.530 --> 00:05:10.790
The responseStart event was
the second one that was

00:05:10.790 --> 00:05:11.660
interesting to me.

00:05:11.660 --> 00:05:15.570
This one is when the browser has
started receiving content.

00:05:15.570 --> 00:05:17.790
So this is important because
this tells me when the browser

00:05:17.790 --> 00:05:19.160
is able to actually
start doing work.

00:05:19.160 --> 00:05:21.640
It's not waiting for the page
to load over the network.

00:05:21.640 --> 00:05:23.670
It can start processing
a document, executing

00:05:23.670 --> 00:05:27.990
JavaScript, and evaluating
CSS.

00:05:27.990 --> 00:05:32.060
The next one is this
domContentLoadedEventStart.

00:05:32.060 --> 00:05:34.740
This is basically the
DOMContentReady event.

00:05:34.740 --> 00:05:36.630
And this one is important
because this is when your

00:05:36.630 --> 00:05:40.450
document becomes interactive and
can start handling events.

00:05:40.450 --> 00:05:43.410
And this is our best
approximation for when the

00:05:43.410 --> 00:05:46.390
user actually sees something
on the page.

00:05:46.390 --> 00:05:50.200
And this is important, because
this is the time that for the

00:05:50.200 --> 00:05:52.530
start of this that I'm going to
be optimizing for, for when

00:05:52.530 --> 00:05:54.940
the browser gets the page to
when the user sees something.

00:05:54.940 --> 00:05:57.680
We want the user to see
something as soon as possible,

00:05:57.680 --> 00:05:59.220
because until that point,
they're just staring at a

00:05:59.220 --> 00:06:00.170
white screen.

00:06:00.170 --> 00:06:02.990
So DOMContentReady means the
user is no longer staring at a

00:06:02.990 --> 00:06:04.230
white screen.

00:06:04.230 --> 00:06:08.240
The load event is the
window load event.

00:06:08.240 --> 00:06:10.790
And this is when the browser's
finished downloading all the

00:06:10.790 --> 00:06:13.320
resources on a page, including
the images.

00:06:13.320 --> 00:06:15.320
So this is like the final
finish point.

00:06:18.530 --> 00:06:18.790
OK.

00:06:18.790 --> 00:06:21.260
So we had to set up a baseline
for the experiments before we

00:06:21.260 --> 00:06:23.060
start making any performance
improvements.

00:06:23.060 --> 00:06:25.220
And this is what
I came up with.

00:06:25.220 --> 00:06:28.280
So the way that I set up my
experiments here is, I created

00:06:28.280 --> 00:06:30.950
a local copy of html5rocks.com,
the mobile

00:06:30.950 --> 00:06:33.950
version, and I set up an
experiment where the browser

00:06:33.950 --> 00:06:36.950
would reload the page 50 times
and capture the time from

00:06:36.950 --> 00:06:39.920
response start to the
DOMContentReady event.

00:06:39.920 --> 00:06:41.960
So what I wanted to optimize
for was just the in-page

00:06:41.960 --> 00:06:44.100
rendering, none of the
network stuff.

00:06:44.100 --> 00:06:47.390
Just optimizing how fast we
can show the user their

00:06:47.390 --> 00:06:50.450
content and stop staring
at the white screen.

00:06:50.450 --> 00:06:54.060
And for this experiment, all
the resources are cache,

00:06:54.060 --> 00:06:59.810
running on Nexus S hardware,
and using window.reload to

00:06:59.810 --> 00:07:02.340
execute the page reloads.

00:07:02.340 --> 00:07:04.950
So our baseline here is
1,200 milliseconds.

00:07:04.950 --> 00:07:08.100
So 1,200 milliseconds from the
browser getting the first byte

00:07:08.100 --> 00:07:10.570
of the document to showing
the user something.

00:07:10.570 --> 00:07:12.450
And so that's what we're trying
to improve on now.

00:07:12.450 --> 00:07:15.420
And also, 812 kilobytes
transferred for the page.

00:07:18.040 --> 00:07:20.270
So the first thing I tried
was PageSpeed.

00:07:20.270 --> 00:07:24.670
So you can just open your Chrome
debugger on the Android

00:07:24.670 --> 00:07:28.760
device and open up PageSpeed,
and you can run an analysis.

00:07:28.760 --> 00:07:31.330
So what it told me right away is
hey, you've got some images

00:07:31.330 --> 00:07:33.610
that aren't scaled properly.

00:07:33.610 --> 00:07:34.960
So this is a pretty easy fix.

00:07:34.960 --> 00:07:36.460
We just have to scale
the images.

00:07:36.460 --> 00:07:39.110
So I just modified the local
version to serve up images of

00:07:39.110 --> 00:07:40.400
the right size.

00:07:40.400 --> 00:07:43.050
The images we were serving were
actually way too big.

00:07:43.050 --> 00:07:47.850
They were 369x369 as
opposed to 75x75.

00:07:47.850 --> 00:07:49.690
So a lot of wasted
space there.

00:07:49.690 --> 00:07:53.830
And also, these were avatar
images, people's photographs,

00:07:53.830 --> 00:07:55.080
served up as PNGs.

00:07:58.130 --> 00:08:00.840
So I fixed that issue, reran all
my experiments, and these

00:08:00.840 --> 00:08:02.280
were the results that I saw.

00:08:02.280 --> 00:08:06.740
We had a 2% improvement in
rendering time of the

00:08:06.740 --> 00:08:09.990
responseStart event to the DOM
ContentReady, and we saved

00:08:09.990 --> 00:08:12.030
about 67 kilobytes.

00:08:12.030 --> 00:08:14.070
So this isn't actually the
kind of improvement I was

00:08:14.070 --> 00:08:14.570
hoping for.

00:08:14.570 --> 00:08:16.110
I thought we were going to be
able to do much better here.

00:08:16.110 --> 00:08:19.210
Because we're serving up much
smaller images, and I just

00:08:19.210 --> 00:08:21.740
assumed that the browser would
be able to render the page

00:08:21.740 --> 00:08:22.450
much more quickly.

00:08:22.450 --> 00:08:23.710
But that wasn't actually
the case.

00:08:23.710 --> 00:08:25.370
But we did save some
bytes, so that's

00:08:25.370 --> 00:08:27.820
good for users' bandwidth.

00:08:27.820 --> 00:08:29.480
So at least we have that.

00:08:29.480 --> 00:08:31.440
The next thing I realized is,
hey, these are avatars.

00:08:31.440 --> 00:08:32.960
We shouldn't be serving
them up as PNGs.

00:08:32.960 --> 00:08:34.380
We should be using JPEG.

00:08:34.380 --> 00:08:37.100
And with JPEG, we can get much
better compression as well.

00:08:37.100 --> 00:08:42.159
So I change the JPEGs and
I remeasured everything.

00:08:42.159 --> 00:08:44.910
Here we have another 2%
improvement in rendering time.

00:08:44.910 --> 00:08:48.260
We're still talking only about
tens of milliseconds saved.

00:08:48.260 --> 00:08:50.690
So this isn't really anything
to get excited about yet.

00:08:50.690 --> 00:08:55.100
But we did save another large
chunk of the payload size.

00:08:55.100 --> 00:08:58.590
We saved over 300 milliseconds
here, which is a 44%

00:08:58.590 --> 00:09:00.840
improvement in the
download size.

00:09:00.840 --> 00:09:03.870
So when the resources aren't
cached, the page is going to

00:09:03.870 --> 00:09:05.750
load faster, and we're going
to be using less

00:09:05.750 --> 00:09:07.030
bandwidth for the users.

00:09:07.030 --> 00:09:10.490
So again, no big improvement in
rendering time, but still a

00:09:10.490 --> 00:09:12.140
really useful optimization
for us to have made.

00:09:15.340 --> 00:09:16.180
Back to PageSpeed.

00:09:16.180 --> 00:09:17.600
It's now happy with
the scaled images.

00:09:17.600 --> 00:09:20.020
And it's telling us, now you've
got to minify some

00:09:20.020 --> 00:09:21.860
JavaScript.

00:09:21.860 --> 00:09:24.400
So that's also a pretty
easy fix.

00:09:24.400 --> 00:09:26.390
I opened up the network trace,
just to kind of see what

00:09:26.390 --> 00:09:29.370
resources it was loading, and
I found that the page was

00:09:29.370 --> 00:09:31.990
including the full version
of jQuery.

00:09:31.990 --> 00:09:34.070
So that's an easy fix.

00:09:34.070 --> 00:09:36.480
I just opened it up, saw that
it's actually the full

00:09:36.480 --> 00:09:40.430
version, and then we can just
swap that out with a minified

00:09:40.430 --> 00:09:43.510
version, save a bunch
of bytes.

00:09:43.510 --> 00:09:45.240
The page functionality
remains the same.

00:09:45.240 --> 00:09:47.910
This is a really easy fix to
make because it won't actually

00:09:47.910 --> 00:09:49.870
change anything.

00:09:49.870 --> 00:09:51.610
And then we can remeasure.

00:09:51.610 --> 00:09:54.930
This is the one that surprised
me the most, because here, we

00:09:54.930 --> 00:09:57.240
significantly reduced the amount
of JavaScript, but we

00:09:57.240 --> 00:10:00.050
didn't actually improve the
rendering time at all.

00:10:00.050 --> 00:10:02.580
The rendering time remained
constant from the last set of

00:10:02.580 --> 00:10:04.200
experiments.

00:10:04.200 --> 00:10:05.160
So that's not good.

00:10:05.160 --> 00:10:07.240
But again, we saved some bytes,
so we should do this.

00:10:07.240 --> 00:10:08.090
It's the right thing to do.

00:10:08.090 --> 00:10:10.820
It'll be faster when the
resources aren't cached, and

00:10:10.820 --> 00:10:12.440
that's good.

00:10:12.440 --> 00:10:15.350
So I said that we should always
measure before and

00:10:15.350 --> 00:10:16.790
after, so that's what
I did here.

00:10:16.790 --> 00:10:19.860
And if it doesn't match the
results that you expected, we

00:10:19.860 --> 00:10:21.100
should figure out why.

00:10:21.100 --> 00:10:23.730
So this is one that really
surprised me.

00:10:23.730 --> 00:10:27.350
And I figured out the answer,
and I'm going to show you that

00:10:27.350 --> 00:10:29.750
a bit later.

00:10:29.750 --> 00:10:32.540
So when you need to minify, this
is something you should

00:10:32.540 --> 00:10:35.380
definitely do to save
bytes over the wire.

00:10:35.380 --> 00:10:37.330
If you're using a third-party
library, just make sure you're

00:10:37.330 --> 00:10:39.940
pulling in the right version
for your production

00:10:39.940 --> 00:10:40.960
environment.

00:10:40.960 --> 00:10:43.770
So you usually want to include
the [? dead ?] version in your

00:10:43.770 --> 00:10:45.520
local setup.

00:10:45.520 --> 00:10:49.080
But when you deploy to
production, you should have

00:10:49.080 --> 00:10:50.780
some kind of build phase where
you swap it out with the

00:10:50.780 --> 00:10:51.920
minified version.

00:10:51.920 --> 00:10:53.080
And that's easy to do.

00:10:53.080 --> 00:10:54.860
If you're writing a lot of
your own JavaScript, then

00:10:54.860 --> 00:10:57.370
you're going to have to do
your own minification.

00:10:57.370 --> 00:10:58.850
This is something that
you can also set up

00:10:58.850 --> 00:11:00.030
into your build phase.

00:11:00.030 --> 00:11:03.410
There's a couple of tools you
can download as command-line

00:11:03.410 --> 00:11:05.720
tools that you can run
on your files.

00:11:05.720 --> 00:11:07.310
You run this tool, and
it spits out the

00:11:07.310 --> 00:11:08.810
minified version for you.

00:11:08.810 --> 00:11:10.750
Or if you just want to quickly
minify some stuff and you

00:11:10.750 --> 00:11:12.780
don't want to download anything
to get this set up,

00:11:12.780 --> 00:11:14.435
there's an online version as
well that you can try.

00:11:14.435 --> 00:11:17.650
You just drop some JavaScript
into a text area, click a

00:11:17.650 --> 00:11:22.100
button, and then you'll get
the minified version.

00:11:22.100 --> 00:11:22.260
OK.

00:11:22.260 --> 00:11:24.150
So the next thing that
I wanted to try--

00:11:24.150 --> 00:11:25.480
we're done with PageSpeed now.

00:11:25.480 --> 00:11:27.880
We've satisfied all of
its recommendations.

00:11:27.880 --> 00:11:29.990
The next thing that I
wanted to try is to

00:11:29.990 --> 00:11:32.330
run some CSS profiling.

00:11:32.330 --> 00:11:35.660
So using this, I can take a look
at exactly how expensive

00:11:35.660 --> 00:11:39.360
my CSS rendering is for the
browser to execute.

00:11:39.360 --> 00:11:42.160
So to do this, open up your
developer tools on the Android

00:11:42.160 --> 00:11:46.730
device, go over to the Profiles
tab, select the CSS

00:11:46.730 --> 00:11:49.240
Selector profile,
and click Start.

00:11:49.240 --> 00:11:51.930
And this will start a recording
of how expensive

00:11:51.930 --> 00:11:53.290
your CSS is.

00:11:53.290 --> 00:11:54.890
So what I did here
is I did that.

00:11:54.890 --> 00:11:57.010
I clicked start, started
recording, and then reload the

00:11:57.010 --> 00:11:59.610
page, and then I stopped
the recording.

00:11:59.610 --> 00:12:02.630
And this tells me how expensive
the CSS is during

00:12:02.630 --> 00:12:04.620
the pageload.

00:12:04.620 --> 00:12:06.090
And here's the results.

00:12:06.090 --> 00:12:09.160
So here we get a breakdown of
exactly how expensive every

00:12:09.160 --> 00:12:13.620
single CSS rule is in my style
sheets during a pageload.

00:12:13.620 --> 00:12:15.580
So it's telling me here,
this rule at the top--

00:12:15.580 --> 00:12:18.540
I've sorted by the total time
taken for each rule--

00:12:18.540 --> 00:12:21.800
the rule at the top is taking
over 50 milliseconds for the

00:12:21.800 --> 00:12:25.140
browser to evaluate while
the page is loading.

00:12:25.140 --> 00:12:27.530
This is rendering time that the
browser is spending before

00:12:27.530 --> 00:12:29.440
showing the user any content.

00:12:29.440 --> 00:12:33.220
So it's telling me, just by
fixing this rule, I can save

00:12:33.220 --> 00:12:35.370
the user 50 milliseconds
in wait time.

00:12:35.370 --> 00:12:36.800
So that's pretty cool.

00:12:36.800 --> 00:12:39.260
And there's also a bunch more
rules here that are over 20

00:12:39.260 --> 00:12:40.920
and 30 milliseconds.

00:12:40.920 --> 00:12:43.760
So if I fixed all of those, I'd
be looking at hundreds of

00:12:43.760 --> 00:12:45.570
milliseconds in savings.

00:12:45.570 --> 00:12:48.100
So that's something I'm
interested in, so I dug a

00:12:48.100 --> 00:12:49.900
little further.

00:12:49.900 --> 00:12:53.430
Before I show exactly what was
wrong, I'll talk a little bit

00:12:53.430 --> 00:12:58.180
about what can make CSS
expensive on mobile.

00:12:58.180 --> 00:13:01.730
Mainly, it all boils down to how
many elements is your CSS

00:13:01.730 --> 00:13:02.980
selector matching?

00:13:02.980 --> 00:13:05.170
So if you're matching all
elements in your document,

00:13:05.170 --> 00:13:06.530
that's going to be really
expensive for the

00:13:06.530 --> 00:13:09.110
browser to work with.

00:13:09.110 --> 00:13:12.000
This is why the universal
selector is so bad on mobile,

00:13:12.000 --> 00:13:15.470
because the browser has to apply
that to every element in

00:13:15.470 --> 00:13:17.450
your document.

00:13:17.450 --> 00:13:19.260
Also, ancestor rules are
pretty expensive.

00:13:19.260 --> 00:13:22.770
Because when it finds a match
for the right-most element in

00:13:22.770 --> 00:13:24.970
the selector, it has to search
the ancestor tree of that

00:13:24.970 --> 00:13:30.710
element, further qualifying to
find a match for that rule.

00:13:30.710 --> 00:13:34.590
So what I've got here, this body
* rule-- this is about

00:13:34.590 --> 00:13:37.450
the worst CSS rule you
could possibly write.

00:13:37.450 --> 00:13:39.060
This is the universal
selector matching

00:13:39.060 --> 00:13:40.020
everything in the document--

00:13:40.020 --> 00:13:41.920
which we already know we
shouldn't do on mobile-- but

00:13:41.920 --> 00:13:44.910
also with an ancestor selector
of the body.

00:13:44.910 --> 00:13:47.360
So the browser has to enumerate
every single element

00:13:47.360 --> 00:13:49.490
in the document, and then search
the ancestor tree of

00:13:49.490 --> 00:13:54.260
that element to ensure that it
has an ancestor of type body.

00:13:54.260 --> 00:13:56.250
So this is really expensive,
and it's also wasteful,

00:13:56.250 --> 00:13:58.590
because of course every
element's in the body.

00:13:58.590 --> 00:14:01.130
We really don't need to
qualify for this.

00:14:04.760 --> 00:14:08.500
Here's some examples of ways you
can change your CSS from

00:14:08.500 --> 00:14:11.510
bad to good for these
different cases.

00:14:11.510 --> 00:14:12.830
So first of all, we know
we want to avoid

00:14:12.830 --> 00:14:15.040
the universal selector.

00:14:15.040 --> 00:14:17.750
The way to avoid this is to
just realize that most the

00:14:17.750 --> 00:14:19.730
time, you don't actually
need it.

00:14:19.730 --> 00:14:21.970
Say, for example, you want to
apply a consistent font to

00:14:21.970 --> 00:14:22.670
your entire document.

00:14:22.670 --> 00:14:24.890
You don't need to use the
universal selector to do that

00:14:24.890 --> 00:14:28.920
because CSS has this
cascading nature.

00:14:28.920 --> 00:14:31.250
You just apply the font rule
to your body, and then your

00:14:31.250 --> 00:14:34.250
entire document will naturally
inherit that rule.

00:14:34.250 --> 00:14:35.500
So that's an easy fix.

00:14:38.280 --> 00:14:40.130
For [? considered ?]

00:14:40.130 --> 00:14:43.230
rules, these are pretty standard
rules, the ul li.

00:14:43.230 --> 00:14:46.020
If you want to color all of your
list items blue, that's a

00:14:46.020 --> 00:14:49.650
pretty standard way to do
it, when we learn CSS.

00:14:49.650 --> 00:14:53.070
But if you swap that out with
a specific class name called

00:14:53.070 --> 00:14:56.010
unordered-list-item that you
manually apply to all of your

00:14:56.010 --> 00:14:58.280
li elements in the document
that are children of ul

00:14:58.280 --> 00:15:01.230
elements, this will
execute much

00:15:01.230 --> 00:15:03.000
faster on mobile hardware.

00:15:03.000 --> 00:15:05.100
And you will see a difference.

00:15:05.100 --> 00:15:08.900
Lastly, don't include CSS rules
that set things that are

00:15:08.900 --> 00:15:10.330
default values.

00:15:10.330 --> 00:15:13.430
Like here, I've got div
set to display block.

00:15:13.430 --> 00:15:15.600
Just let the browser
figure that out.

00:15:15.600 --> 00:15:19.260
If you're trying to save some
rare user agents that might

00:15:19.260 --> 00:15:22.365
have screwed this up, then I
would say, just let most of

00:15:22.365 --> 00:15:23.760
your browsers be fast
and let broken

00:15:23.760 --> 00:15:25.055
browsers be broken browsers.

00:15:28.080 --> 00:15:30.660
So back to the example,
html5rocks.com, we had that

00:15:30.660 --> 00:15:33.810
50-millisecond timing
on one rule.

00:15:33.810 --> 00:15:37.420
It turns out that it was
specifying a default CSS

00:15:37.420 --> 00:15:39.710
property, setting the
box sizing of every

00:15:39.710 --> 00:15:41.160
element in the document.

00:15:41.160 --> 00:15:42.600
So this one is really easy.

00:15:42.600 --> 00:15:43.920
Because it's a default
property, we

00:15:43.920 --> 00:15:44.570
can just remove it.

00:15:44.570 --> 00:15:46.310
The page will have the
same behavior.

00:15:46.310 --> 00:15:50.400
And we can figure out what
kind of impact it had.

00:15:50.400 --> 00:15:52.250
So here we go.

00:15:52.250 --> 00:15:54.510
Approximately 50 milliseconds
saved in rendering time.

00:15:54.510 --> 00:15:57.700
That's just about exactly
what we expected.

00:15:57.700 --> 00:15:59.700
That was nice to see.

00:15:59.700 --> 00:16:02.740
I was comforted by this, because
the profiler told me,

00:16:02.740 --> 00:16:06.080
when I measured before, that I
would save 50 milliseconds if

00:16:06.080 --> 00:16:07.660
I fixed this rule.

00:16:07.660 --> 00:16:09.570
And then when I measured after,
that was confirmed.

00:16:09.570 --> 00:16:11.850
So what this means is that the
profiler is doing an accurate

00:16:11.850 --> 00:16:15.600
job of predicting exactly how
much my users will save in

00:16:15.600 --> 00:16:18.370
time if I fix those rules.

00:16:18.370 --> 00:16:19.060
So that's good to know.

00:16:19.060 --> 00:16:22.010
So if you are planning on
setting out for a couple of

00:16:22.010 --> 00:16:25.950
days or a week to optimize the
CSS on your page, you can be

00:16:25.950 --> 00:16:28.600
sure that you should definitely
open up your CSS

00:16:28.600 --> 00:16:31.110
profiler and check, are there
actually any problems?

00:16:31.110 --> 00:16:33.050
And if not, then you can just
skip that whole process.

00:16:37.540 --> 00:16:37.740
OK.

00:16:37.740 --> 00:16:40.700
So what's next?

00:16:40.700 --> 00:16:42.780
Remember what we're
trying to do here.

00:16:42.780 --> 00:16:46.400
We want to optimize the time for
which the user is sitting

00:16:46.400 --> 00:16:49.200
there waiting, looking
at a white screen.

00:16:49.200 --> 00:16:52.730
From the time the browser gets
the page to the time they want

00:16:52.730 --> 00:16:55.450
to see content, we want to get
rid of everything on that

00:16:55.450 --> 00:16:57.260
critical path.

00:16:57.260 --> 00:17:01.450
So if we look at the network
trace in your developer tools,

00:17:01.450 --> 00:17:05.210
you can see exactly when that
DomReady event is firing.

00:17:05.210 --> 00:17:07.230
That's the blue line.

00:17:07.230 --> 00:17:08.849
So this is our approximation
for when the

00:17:08.849 --> 00:17:10.890
user is seeing content.

00:17:10.890 --> 00:17:13.839
Everything on the left of this
is just getting in the way.

00:17:13.839 --> 00:17:15.740
So we need to make sure that
everything over here is

00:17:15.740 --> 00:17:19.450
something that's critical to
showing our user content.

00:17:19.450 --> 00:17:21.270
So here's the first resource.

00:17:21.270 --> 00:17:22.260
Obviously this is critical.

00:17:22.260 --> 00:17:24.599
This is the main markup
of the page.

00:17:24.599 --> 00:17:25.880
Our CSS is pretty critical.

00:17:25.880 --> 00:17:29.560
We don't want to show people
just plain HTML.

00:17:29.560 --> 00:17:31.742
But then the rest of these are
all JavaScript files that are

00:17:31.742 --> 00:17:36.380
loading over the network and
taking time to execute.

00:17:36.380 --> 00:17:39.730
So on html5rocks.com, this
is just a plain website.

00:17:39.730 --> 00:17:42.860
We don't need to include all
these scripts before we show

00:17:42.860 --> 00:17:44.840
the user something.

00:17:44.840 --> 00:17:48.280
And the problem with these is
just the presence of the

00:17:48.280 --> 00:17:50.540
scripts on the page that's
slowing down the

00:17:50.540 --> 00:17:52.200
DOMContentReady event.

00:17:52.200 --> 00:17:54.680
When you include a script on
your page, the browser doesn't

00:17:54.680 --> 00:17:58.030
actually know when it should
do something with it.

00:17:58.030 --> 00:18:00.860
It doesn't know if you need that
script immediately, or if

00:18:00.860 --> 00:18:02.920
you just need it 10
seconds from now.

00:18:02.920 --> 00:18:05.810
So what it does is it downloads
it immediately,

00:18:05.810 --> 00:18:07.910
before doing anything else,
before it proceeds with the

00:18:07.910 --> 00:18:09.880
rest of your document,
and then executes

00:18:09.880 --> 00:18:12.080
it right away, too.

00:18:12.080 --> 00:18:15.400
So in this case, we don't need
that kind of behavior.

00:18:15.400 --> 00:18:18.110
We can defer this JavaScript
until later.

00:18:18.110 --> 00:18:22.920
So we can do something here in
order to get rid of that.

00:18:25.570 --> 00:18:27.800
So what we need is a way to
defer this JavaScript in a

00:18:27.800 --> 00:18:29.880
reliable manner.

00:18:29.880 --> 00:18:32.670
I looked at a couple
of ways to do this.

00:18:32.670 --> 00:18:34.670
First, I tried the
defer attribute.

00:18:34.670 --> 00:18:35.680
This didn't work well for me.

00:18:35.680 --> 00:18:39.530
I tried it and it worked, but
when I reran my experiments,

00:18:39.530 --> 00:18:41.920
it didn't actually
help anything.

00:18:41.920 --> 00:18:43.870
When I investigated a little
deeper to find out what was

00:18:43.870 --> 00:18:47.350
happening, I found a lot of
resources suggesting that the

00:18:47.350 --> 00:18:50.540
defer attribute is more like a
suggestion to the browser.

00:18:50.540 --> 00:18:52.830
So it can defer it if it thinks
that's a good idea, or

00:18:52.830 --> 00:18:56.380
it'll execute in parallel
to those idle cycles.

00:18:56.380 --> 00:18:58.570
I also found a bunch of stuff
that it's not good

00:18:58.570 --> 00:19:00.720
cross-browser, and
all this stuff.

00:19:00.720 --> 00:19:02.930
But the point is, it just
didn't really work well.

00:19:02.930 --> 00:19:06.780
It didn't speed up the
page-rendering time.

00:19:06.780 --> 00:19:09.260
I then looked at async
attribute, and this had some

00:19:09.260 --> 00:19:12.930
different behavior, where
it would defer the

00:19:12.930 --> 00:19:14.200
loading of the scripts.

00:19:14.200 --> 00:19:16.810
But they would load in at any
order, not necessarily the

00:19:16.810 --> 00:19:18.530
order that you included
them on the page.

00:19:18.530 --> 00:19:22.710
So this can lead to some race
conditions where you get

00:19:22.710 --> 00:19:24.490
JavaScript errors.

00:19:24.490 --> 00:19:26.890
Say, you have some inline
script running jQuery

00:19:26.890 --> 00:19:30.280
functions before the jQuery
file gets loaded.

00:19:30.280 --> 00:19:31.770
Then that's not going
to work properly.

00:19:34.420 --> 00:19:37.910
So what I did is, I cooked up
a way you can include a

00:19:37.910 --> 00:19:40.290
special type on your script
attribute that tricks the

00:19:40.290 --> 00:19:42.480
browser into thinking that
this isn't actually

00:19:42.480 --> 00:19:43.710
JavaScript.

00:19:43.710 --> 00:19:45.860
So what we have here, is I've
just stamped all these script

00:19:45.860 --> 00:19:48.780
elements with a special
type called notJs.

00:19:48.780 --> 00:19:50.740
And so now these scripts will
actually download over the

00:19:50.740 --> 00:19:53.770
network, but the browser will
just pass over these and not

00:19:53.770 --> 00:19:55.640
do anything with it, because
it doesn't know what it is.

00:19:58.350 --> 00:20:00.010
And then when you want to load
these scripts, you can just

00:20:00.010 --> 00:20:02.230
include this simple bit
of script here.

00:20:02.230 --> 00:20:04.355
What this does is it loads all
the scripts in the document,

00:20:04.355 --> 00:20:05.950
and loops through them.

00:20:05.950 --> 00:20:08.820
If the type is notJs, then
it sets the type back to

00:20:08.820 --> 00:20:12.670
text/javascript and then it
re-adds it to the document.

00:20:12.670 --> 00:20:16.180
When you do this, the document
reevaluates it, parses it

00:20:16.180 --> 00:20:18.740
right away because now it sees
that it's JavaScript, and

00:20:18.740 --> 00:20:22.070
executes it just as
we would expect.

00:20:22.070 --> 00:20:24.390
So what I've done is, I modified
the experiments.

00:20:24.390 --> 00:20:25.670
I created this function.

00:20:25.670 --> 00:20:28.180
I added notJs to all the
scripts on the page.

00:20:28.180 --> 00:20:29.650
And then I set this
function to be the

00:20:29.650 --> 00:20:32.120
window.onload function.

00:20:32.120 --> 00:20:33.942
Here's the results.

00:20:33.942 --> 00:20:35.192
Oooh.

00:20:37.420 --> 00:20:40.050
So our page running time
just got a lot faster.

00:20:40.050 --> 00:20:42.910
We have a 33% improvement in
running time, and this is

00:20:42.910 --> 00:20:45.515
hundreds of milliseconds.

00:20:45.515 --> 00:20:49.540
But remember, all these
resources are cached.

00:20:49.540 --> 00:20:51.480
That's how we're running
these experiments.

00:20:51.480 --> 00:20:52.850
So why does this take so long?

00:20:56.210 --> 00:20:59.520
It takes so long because it
takes one millisecond to parse

00:20:59.520 --> 00:21:03.930
every kilobyte of JavaScript
on modern mobile hardware.

00:21:03.930 --> 00:21:04.920
And this is really important.

00:21:04.920 --> 00:21:08.450
What I mean by parse is, when
the browser encounters a

00:21:08.450 --> 00:21:12.110
script block, this is the time
that it takes to read all the

00:21:12.110 --> 00:21:15.900
text in that script block and
figure out what it means in

00:21:15.900 --> 00:21:18.910
terms of JavaScript, and then
execute on the top-level lines

00:21:18.910 --> 00:21:22.230
of JavaScript in that
script function.

00:21:22.230 --> 00:21:25.320
And this is much more expensive
to do on mobile than

00:21:25.320 --> 00:21:28.420
it is on desktop.

00:21:28.420 --> 00:21:29.870
Here's a more detailed breakdown
of some of the

00:21:29.870 --> 00:21:33.430
experiments that my team has run
to investigate what kind

00:21:33.430 --> 00:21:36.200
of parse times we see
across devices.

00:21:36.200 --> 00:21:39.730
So you can see here, for Nexus
S hardware, it takes 300

00:21:39.730 --> 00:21:42.960
milliseconds to parse 300
kilobytes of JavaScript.

00:21:42.960 --> 00:21:44.820
And that's where we get our
one millisecond to one

00:21:44.820 --> 00:21:46.480
kilobyte rule.

00:21:46.480 --> 00:21:49.850
And 300K is a pretty average
amount of JavaScript to

00:21:49.850 --> 00:21:52.690
include on a page, especially
for pages that have kind of

00:21:52.690 --> 00:21:55.970
been ported over from desktop,
where we just include lots of

00:21:55.970 --> 00:21:59.430
JavaScript all the time and
it doesn't really matter.

00:21:59.430 --> 00:22:02.170
And 300 milliseconds is a long
time for a user to wait,

00:22:02.170 --> 00:22:04.380
sitting and staring at a white
screen, seeing nothing,

00:22:04.380 --> 00:22:06.150
waiting for your page to load.

00:22:06.150 --> 00:22:07.920
Now what's really interesting
is looking back a few

00:22:07.920 --> 00:22:09.690
generations in phone hardware.

00:22:09.690 --> 00:22:13.730
And we see that iPhone 2G would
take over three seconds

00:22:13.730 --> 00:22:16.900
to parse the same amount
of JavaScript.

00:22:16.900 --> 00:22:19.800
And that's a 10x improvement in
just a few generations of

00:22:19.800 --> 00:22:21.310
phone hardware.

00:22:21.310 --> 00:22:25.160
So what we're seeing is a trend
where phone hardware is

00:22:25.160 --> 00:22:28.610
improving drastically,
very quickly.

00:22:28.610 --> 00:22:30.650
And so this should play--

00:22:30.650 --> 00:22:31.680
you should keep this in mind.

00:22:31.680 --> 00:22:34.260
It should play a pretty big role
in how you think about

00:22:34.260 --> 00:22:36.850
performance optimizations.

00:22:36.850 --> 00:22:37.840
Now let's think back--

00:22:37.840 --> 00:22:39.730
our jQuery example.

00:22:39.730 --> 00:22:43.130
We minified jQuery, and we saved
over 100 kilobytes in

00:22:43.130 --> 00:22:46.180
JavaScript, but we saw no
improvement in rendering time.

00:22:46.180 --> 00:22:48.050
So why was that?

00:22:48.050 --> 00:22:51.250
So in this table, you'll see--

00:22:51.250 --> 00:22:52.420
or maybe you won't see--

00:22:52.420 --> 00:22:56.400
these are for minified
JavaScript sizes.

00:22:56.400 --> 00:23:00.750
So when we minified our jQuery
file from 240 kilobytes to 90

00:23:00.750 --> 00:23:04.220
kilobytes, we didn't actually
make it any less complex for

00:23:04.220 --> 00:23:05.180
the browser to parse.

00:23:05.180 --> 00:23:07.010
It's still the same
JavaScript.

00:23:07.010 --> 00:23:09.960
It still has the same level of
complexity, the same amount of

00:23:09.960 --> 00:23:11.910
stuff to execute, and the same
amount of stuff for the

00:23:11.910 --> 00:23:13.460
browser to figure out.

00:23:13.460 --> 00:23:16.200
So just by minifying it, we
didn't actually save anything

00:23:16.200 --> 00:23:17.060
in parse time.

00:23:17.060 --> 00:23:19.360
So that makes sense.

00:23:19.360 --> 00:23:21.590
What this also means is that you
shouldn't just minify your

00:23:21.590 --> 00:23:22.160
JavaScript.

00:23:22.160 --> 00:23:23.910
You should compile it.

00:23:23.910 --> 00:23:27.530
Using tools like Closure
Compiler, you can run phases

00:23:27.530 --> 00:23:32.030
like the dead code removal in
order to get rid of all the

00:23:32.030 --> 00:23:34.870
JavaScript on your page that's
not actually being used.

00:23:34.870 --> 00:23:37.080
So when you're pulling in
libraries like jQuery and

00:23:37.080 --> 00:23:40.410
using only a small fraction of
it, you can use compilers to

00:23:40.410 --> 00:23:42.370
remove all the stuff that you're
not actually using.

00:23:42.370 --> 00:23:43.950
And when you do that, that's
when you're going to see

00:23:43.950 --> 00:23:45.200
improvements in parse time.

00:23:49.360 --> 00:23:50.940
OK, so how much faster
can we go now?

00:23:50.940 --> 00:23:54.730
We have optimized images,
optimized CSS, and no

00:23:54.730 --> 00:23:58.240
JavaScript getting in the way
of our content rendering.

00:23:58.240 --> 00:24:01.040
The only thing we could do now
is get rid of styles, which we

00:24:01.040 --> 00:24:06.460
probably don't want to do, or
send down a smaller DOM.

00:24:06.460 --> 00:24:08.480
So we could just say to our
designers, hey, your

00:24:08.480 --> 00:24:09.430
document's too big.

00:24:09.430 --> 00:24:10.525
I don't want to show
this much content.

00:24:10.525 --> 00:24:12.120
It's really expensive
on mobile.

00:24:12.120 --> 00:24:13.400
And maybe that's acceptable.

00:24:13.400 --> 00:24:14.740
But say it's not.

00:24:14.740 --> 00:24:16.370
There's still something
that you can do.

00:24:19.600 --> 00:24:20.610
Here's a little trick.

00:24:20.610 --> 00:24:23.330
We're going to lazy load a
bunch of the document.

00:24:23.330 --> 00:24:27.910
So we can send down large
portions of the document and

00:24:27.910 --> 00:24:31.000
only show a little bit
when we're first

00:24:31.000 --> 00:24:33.820
rendering the page.

00:24:33.820 --> 00:24:37.350
The html5rocks.com main
page, it's got a lot

00:24:37.350 --> 00:24:38.450
of scrollable content.

00:24:38.450 --> 00:24:41.240
So there's a lot of stuff when
the user loads the page that's

00:24:41.240 --> 00:24:43.020
there, but they can't
actually see.

00:24:43.020 --> 00:24:44.910
So there's no reason for us to
actually demand that the

00:24:44.910 --> 00:24:47.550
browser try and render
that right away.

00:24:47.550 --> 00:24:50.170
So what I've done here is I took
a couple of the top-level

00:24:50.170 --> 00:24:53.430
elements on the web page and
set them to display:none,

00:24:53.430 --> 00:24:56.880
which just takes it out of the
rendering process completely.

00:24:56.880 --> 00:25:00.120
Then on the pageload, we can
just set these back to

00:25:00.120 --> 00:25:02.460
display:visible and they'll
show up right away.

00:25:02.460 --> 00:25:05.030
So they'll be there by the time
the user scrolls down to

00:25:05.030 --> 00:25:07.060
try and use those parts
of the page.

00:25:07.060 --> 00:25:09.660
And by doing this, we've made
the page significantly simpler

00:25:09.660 --> 00:25:12.350
for the browser to render, and
now we've saved another couple

00:25:12.350 --> 00:25:16.140
hundred milliseconds
in rendering time.

00:25:16.140 --> 00:25:19.630
So now we're sitting at 600
milliseconds of render time.

00:25:19.630 --> 00:25:22.340
So remember, that's time from
the browser getting the page

00:25:22.340 --> 00:25:24.550
to showing user content.

00:25:24.550 --> 00:25:27.850
And that's just about a 2x
improvement since we started

00:25:27.850 --> 00:25:29.690
these optimizations.

00:25:29.690 --> 00:25:32.380
So at this point I'm
pretty happy.

00:25:32.380 --> 00:25:35.030
And I don't know that there's
much more we can do on just

00:25:35.030 --> 00:25:36.390
the rendering, other
than waiting

00:25:36.390 --> 00:25:39.340
for newer phone hardware.

00:25:39.340 --> 00:25:42.480
We could maybe squeeze out
another 50 or 100 milliseconds

00:25:42.480 --> 00:25:45.910
in this rendering time by really
digging into the CSS or

00:25:45.910 --> 00:25:49.140
simplifying the DOM a little bit
more, and stuff like that.

00:25:49.140 --> 00:25:53.050
But at this point, our effort
is probably better spent

00:25:53.050 --> 00:25:55.210
optimizing other things.

00:25:55.210 --> 00:25:57.700
So, so far we've only been
looking at the rendering

00:25:57.700 --> 00:26:00.815
performance, but there's
actually a lot more variables

00:26:00.815 --> 00:26:04.270
that the user waits on, other
than just the rendering.

00:26:04.270 --> 00:26:06.375
We need to consider things like
the network load time and

00:26:06.375 --> 00:26:08.480
redirects and all this
kind of stuff.

00:26:08.480 --> 00:26:11.100
And optimizing for these is
really hard to do on your

00:26:11.100 --> 00:26:13.260
local development environments,
because the

00:26:13.260 --> 00:26:15.320
environment is completely
different from the production

00:26:15.320 --> 00:26:17.230
environment.

00:26:17.230 --> 00:26:19.780
So to figure out what real
users in the wild are

00:26:19.780 --> 00:26:21.430
experiencing, there's this
cool website called

00:26:21.430 --> 00:26:25.040
webpagetest.org, where you can
go and they've got a browser

00:26:25.040 --> 00:26:27.240
farm, and you can type
in any website URL.

00:26:27.240 --> 00:26:30.630
It will load the page and tell
you exactly what kind of load

00:26:30.630 --> 00:26:33.240
sequence your page has.

00:26:33.240 --> 00:26:36.310
So these are results for
html5rocks.com using one of

00:26:36.310 --> 00:26:40.100
their Android browsers in
the mobile browser farm.

00:26:40.100 --> 00:26:42.380
So here we can see exactly
what's happening on pageload.

00:26:42.380 --> 00:26:46.160
We've got two redirects here,
and then here's the main

00:26:46.160 --> 00:26:49.280
pageload, and then all these
resources loading.

00:26:49.280 --> 00:26:51.810
And here's the rest of
the waterfall chart.

00:26:51.810 --> 00:26:54.390
So right away, we can see
exactly how much time we could

00:26:54.390 --> 00:26:56.470
save the users by optimizing
different

00:26:56.470 --> 00:26:58.140
parts of this process.

00:26:58.140 --> 00:26:59.830
For example, why do we
need two redirects?

00:26:59.830 --> 00:27:02.930
We can just get rid of one of
these redirects, and we would

00:27:02.930 --> 00:27:07.330
automatically save 100
milliseconds right there.

00:27:07.330 --> 00:27:09.710
But it looks like the biggest
performance improvements we

00:27:09.710 --> 00:27:11.740
could make here are
on this pageload.

00:27:11.740 --> 00:27:16.550
It's taking over 1.7 seconds
to download this page.

00:27:16.550 --> 00:27:19.640
That's pretty terrible.

00:27:19.640 --> 00:27:23.730
Also, interestingly, is that
these browsers and the browser

00:27:23.730 --> 00:27:25.930
farm are all on a strong
Wi-Fi connection.

00:27:25.930 --> 00:27:27.930
So it's not like this is
downloading over an Edge

00:27:27.930 --> 00:27:30.670
network and taking
a long time.

00:27:30.670 --> 00:27:34.160
This is probably taking over
a second just in server

00:27:34.160 --> 00:27:35.970
processing time.

00:27:35.970 --> 00:27:38.760
So if we really want to make a
difference for our users, we

00:27:38.760 --> 00:27:42.650
would look at this information
and dig into our server

00:27:42.650 --> 00:27:45.310
infrastructure and figure out
why it's taking over a second

00:27:45.310 --> 00:27:47.790
to process requests and
start sending the

00:27:47.790 --> 00:27:49.040
first byte to the browser.

00:27:52.610 --> 00:27:54.220
And here's the green line--
this is the load event.

00:27:54.220 --> 00:27:55.580
And you can see there's
a bunch of

00:27:55.580 --> 00:27:57.330
JavaScript files loading.

00:27:57.330 --> 00:27:59.910
This is what we've pushed over
onto the other side of the

00:27:59.910 --> 00:28:01.380
Ready event.

00:28:01.380 --> 00:28:06.030
And remember that we saved 600
milliseconds, which is maybe

00:28:06.030 --> 00:28:09.450
about like this much.

00:28:09.450 --> 00:28:12.150
And we said that the only
further improvements we can

00:28:12.150 --> 00:28:14.110
make there are pretty
marginal.

00:28:14.110 --> 00:28:17.330
So definitely, looking at this
huge chunk here, this is what

00:28:17.330 --> 00:28:22.270
we would want to focus on if we
want to help our users out.

00:28:22.270 --> 00:28:22.490
OK.

00:28:22.490 --> 00:28:25.120
So what if we decide improving
the server is hard?

00:28:25.120 --> 00:28:26.850
I want to do this
from the client.

00:28:26.850 --> 00:28:29.260
We actually can do that
by using AppCache.

00:28:29.260 --> 00:28:31.810
And using AppCache, we can
entirely get rid of the

00:28:31.810 --> 00:28:34.060
network time and bring that
to zero, because all the

00:28:34.060 --> 00:28:35.920
resources will be
cached locally,

00:28:35.920 --> 00:28:38.460
including the HTML file.

00:28:38.460 --> 00:28:41.360
To set this up, you just need to
create a manifest file and

00:28:41.360 --> 00:28:45.230
link it to your HTML
attribute here.

00:28:45.230 --> 00:28:48.020
You host this manifest file
on your web server.

00:28:48.020 --> 00:28:50.520
And in this manifest file, you
describe all the resources

00:28:50.520 --> 00:28:51.770
that you want to be cached.

00:28:55.110 --> 00:28:57.080
So when we add that to the
page and rerun the

00:28:57.080 --> 00:28:59.640
experiments, we see that
we've actually

00:28:59.640 --> 00:29:01.820
taken a rendering hit.

00:29:01.820 --> 00:29:04.050
And so this was important
and a little bit of

00:29:04.050 --> 00:29:05.690
a surprise to me.

00:29:05.690 --> 00:29:09.180
Upon investigation, I realized
that what was happening was,

00:29:09.180 --> 00:29:11.860
the manifest file was
downloading every pageload.

00:29:11.860 --> 00:29:14.960
Even if all the resources are
cached, the browser has to

00:29:14.960 --> 00:29:18.560
re-download this manifest file
every time it opens the page,

00:29:18.560 --> 00:29:21.480
and that's because the manifest
serves as the

00:29:21.480 --> 00:29:24.640
indication to the browser as to
when it needs to update the

00:29:24.640 --> 00:29:27.240
resources because the
application's out of date.

00:29:27.240 --> 00:29:29.570
So when the developer changes
the manifest file, that means

00:29:29.570 --> 00:29:31.250
the app needs to be updated and

00:29:31.250 --> 00:29:33.280
re-download all the resources.

00:29:33.280 --> 00:29:36.290
But what it means for a normal
pageload sequence is that

00:29:36.290 --> 00:29:38.810
we've downloaded the page and
the first thing the browser

00:29:38.810 --> 00:29:41.340
processes is the HTML node.

00:29:41.340 --> 00:29:43.510
And it sees the manifest
attribute, and then right then

00:29:43.510 --> 00:29:44.750
and there, it starts
downloading

00:29:44.750 --> 00:29:46.330
this AppCache file.

00:29:46.330 --> 00:29:48.920
So that means while you're on
the critical path of trying to

00:29:48.920 --> 00:29:52.370
render your content, you've
initiated a new download

00:29:52.370 --> 00:29:53.550
happening in parallel.

00:29:53.550 --> 00:29:55.440
So you're creating resource
contention, and that's why we

00:29:55.440 --> 00:29:56.690
see the rendering hit.

00:29:56.690 --> 00:29:58.920
However, this is pretty
acceptable, given that we're

00:29:58.920 --> 00:30:03.730
saving, as we saw, almost two
seconds in network load time.

00:30:03.730 --> 00:30:06.710
So that pretty far offsets the
tens of milliseconds that

00:30:06.710 --> 00:30:09.850
we're losing here.

00:30:09.850 --> 00:30:11.570
So AppCache sounds
pretty easy.

00:30:11.570 --> 00:30:13.870
I'm making it sound like a
silver bullet to improving

00:30:13.870 --> 00:30:15.140
your network time.

00:30:15.140 --> 00:30:17.550
But that's not actually
the case.

00:30:17.550 --> 00:30:18.500
It can be a real challenge.

00:30:18.500 --> 00:30:20.500
It can be a real nuisance, and
there's lots of things that

00:30:20.500 --> 00:30:23.000
can go wrong.

00:30:23.000 --> 00:30:24.050
Let's talk about why.

00:30:24.050 --> 00:30:26.970
And it requires a little bit
deeper understanding of how

00:30:26.970 --> 00:30:28.240
AppCache works.

00:30:28.240 --> 00:30:30.930
So what we're doing here is
looking at the Resources tab.

00:30:30.930 --> 00:30:33.670
This is showing us the AppCache
entry for the site on

00:30:33.670 --> 00:30:35.860
the local version that
I've created.

00:30:35.860 --> 00:30:38.000
These are all the files that
have been added to this

00:30:38.000 --> 00:30:40.100
AppCache entry.

00:30:40.100 --> 00:30:44.510
The manifest file is the key to
the AppCache entry the maps

00:30:44.510 --> 00:30:47.810
all the resources that are
cached in this entry.

00:30:47.810 --> 00:30:51.400
So all the resources that you
list in the manifest file--

00:30:51.400 --> 00:30:52.630
you can find them all here.

00:30:52.630 --> 00:30:55.000
These are the explicit
entries here.

00:30:55.000 --> 00:30:59.590
All of the HTML files that point
to this manifest file

00:30:59.590 --> 00:31:01.880
end up in here as
master entries.

00:31:01.880 --> 00:31:04.190
So if you have 10 pages on your
site, all pointing to the

00:31:04.190 --> 00:31:07.150
same manifest file, they'll
all appear here as master

00:31:07.150 --> 00:31:10.820
entries in your AppCache
entry.

00:31:10.820 --> 00:31:13.400
And then remember, when the
manifest file changes, that's

00:31:13.400 --> 00:31:16.800
the signal to the browser to
re-download the resources

00:31:16.800 --> 00:31:19.590
because the developer has
published an update to this

00:31:19.590 --> 00:31:22.240
application.

00:31:22.240 --> 00:31:26.360
So when that happens, you can
see how the browser behaves by

00:31:26.360 --> 00:31:29.390
looking at the developer
console when you're

00:31:29.390 --> 00:31:31.230
refreshing the page.

00:31:31.230 --> 00:31:35.340
So what happens is the browser
sees the manifest file has

00:31:35.340 --> 00:31:38.140
changed and then initiates
an AppCache update and

00:31:38.140 --> 00:31:40.840
re-downloads all these
resources.

00:31:40.840 --> 00:31:42.480
And what we see here is that
it's downloading these two

00:31:42.480 --> 00:31:46.360
HTML files at the same time.

00:31:46.360 --> 00:31:49.270
Let's look at an example of
why this can be so bad.

00:31:49.270 --> 00:31:51.820
Number one, user opens
a single page with

00:31:51.820 --> 00:31:53.320
five external resources.

00:31:53.320 --> 00:31:56.970
Let's say that totals 350
kilobytes of downloaded stuff.

00:31:56.970 --> 00:31:59.720
That goes into the
AppCache entry.

00:31:59.720 --> 00:32:02.850
The user then opens 10 more
pages on the site.

00:32:02.850 --> 00:32:04.430
Each of them are
200 kilobytes.

00:32:04.430 --> 00:32:07.920
All of these go into
the AppCache entry.

00:32:07.920 --> 00:32:10.850
Now we've published an update to
the web app by changing the

00:32:10.850 --> 00:32:12.570
manifest file.

00:32:12.570 --> 00:32:15.960
The user visits just one
of these 11 pages.

00:32:15.960 --> 00:32:18.480
The browser checks the manifest
file, sees a change,

00:32:18.480 --> 00:32:21.590
and initiates an AppCache
update.

00:32:21.590 --> 00:32:23.570
Now, what happens is the browser
downloads over 2

00:32:23.570 --> 00:32:27.880
megabytes of data in the
background, just by navigating

00:32:27.880 --> 00:32:30.010
to this one page.

00:32:30.010 --> 00:32:32.500
Say you had 10,000
users that day.

00:32:32.500 --> 00:32:35.830
You're serving up over 20
gigabytes of data versus what

00:32:35.830 --> 00:32:38.010
should have been only 20
megabytes of data if they were

00:32:38.010 --> 00:32:40.380
just loading those HTML
files by themselves.

00:32:40.380 --> 00:32:41.930
So not only could this be really
expensive for your

00:32:41.930 --> 00:32:45.700
users, but it can be really
expensive to you, depending on

00:32:45.700 --> 00:32:46.950
your server infrastructure.

00:32:49.700 --> 00:32:49.860
OK.

00:32:49.860 --> 00:32:50.940
So how can we get around this?

00:32:50.940 --> 00:32:53.660
The obvious solution seems to
be, let's include one manifest

00:32:53.660 --> 00:32:56.060
file per HTML page.

00:32:56.060 --> 00:32:58.090
So for every page we're serving
up, it's going to have

00:32:58.090 --> 00:33:01.430
its own manifest file, it'll
have its own AppCache entry,

00:33:01.430 --> 00:33:03.060
and everything will be good.

00:33:03.060 --> 00:33:05.690
That's not actually
the case either.

00:33:05.690 --> 00:33:09.320
When you create several AppCache
entries, you can use

00:33:09.320 --> 00:33:12.830
Chrome, go into AppCache
Internals, and see how you're

00:33:12.830 --> 00:33:14.950
kind of affecting the
various AppCache

00:33:14.950 --> 00:33:17.280
entries in the system.

00:33:17.280 --> 00:33:19.570
So what I've done is I've
modified the local version to

00:33:19.570 --> 00:33:22.400
have several AppCache files for
those two HTML files that

00:33:22.400 --> 00:33:25.130
we were previously loading
in a single entry.

00:33:25.130 --> 00:33:28.610
What we see here is this one
here is over 350 kilobytes in

00:33:28.610 --> 00:33:32.885
size, and this one is also
very large, over 260.

00:33:32.885 --> 00:33:35.260
And what's happening is that all
of the external resources

00:33:35.260 --> 00:33:38.660
that our manifest files are
pointing to are being cached

00:33:38.660 --> 00:33:40.630
in both of these AppCache
entries.

00:33:40.630 --> 00:33:44.280
So the AppCache entries can't
share external resources

00:33:44.280 --> 00:33:45.630
amongst themselves.

00:33:45.630 --> 00:33:46.680
They need to cache
all the files

00:33:46.680 --> 00:33:48.480
explicitly in each entry.

00:33:48.480 --> 00:33:51.330
And so the sizes of these
are adding up quickly.

00:33:51.330 --> 00:33:53.680
And the reason that's a problem
is because the browser

00:33:53.680 --> 00:33:57.860
has a hard limit of 5 megabytes
per domain quota for

00:33:57.860 --> 00:34:00.650
your AppCache space.

00:34:00.650 --> 00:34:03.470
So just based on the pace that
we're going here, for

00:34:03.470 --> 00:34:09.949
html5rocks.com, by only adding
10 pages to this AppCache

00:34:09.949 --> 00:34:13.000
setup, we would exceed
that limit already.

00:34:13.000 --> 00:34:14.909
And what happens when you
exceed the limit is, the

00:34:14.909 --> 00:34:18.080
browser tries to download the
updates, and when it gets the

00:34:18.080 --> 00:34:20.449
update it tries to push
it into the cache.

00:34:20.449 --> 00:34:22.120
But when you've exceeded
your quota, that

00:34:22.120 --> 00:34:23.520
push will just fail.

00:34:23.520 --> 00:34:25.070
And there's nothing that you
can really do about it

00:34:25.070 --> 00:34:27.860
programmatically
in JavaScript.

00:34:27.860 --> 00:34:29.840
If your users get into this
situation, they can actually

00:34:29.840 --> 00:34:32.310
get stuck on a really stale
version of their site, because

00:34:32.310 --> 00:34:34.420
they can't actually update
to the new version.

00:34:34.420 --> 00:34:37.030
So this is a pretty big
problem that you

00:34:37.030 --> 00:34:37.790
should try to avoid.

00:34:37.790 --> 00:34:39.080
And if you get into this
problem, you're kind of

00:34:39.080 --> 00:34:41.389
screwed, because you can't
fix it after the fact.

00:34:41.389 --> 00:34:44.980
The only thing that you can do
is serve 404s on your AppCache

00:34:44.980 --> 00:34:48.380
requests, and this invalidates
the AppCache in the browser.

00:34:52.060 --> 00:34:53.210
So it used to seem
really easy.

00:34:53.210 --> 00:34:54.100
Now it seems really hard.

00:34:54.100 --> 00:34:55.420
How can we actually
make this work?

00:34:55.420 --> 00:34:57.370
You have three options,
basically.

00:34:57.370 --> 00:35:00.560
You can decide to only include
a manifest file on

00:35:00.560 --> 00:35:01.530
a select few pages.

00:35:01.530 --> 00:35:04.300
So this means, maybe, your home
page or just a few really

00:35:04.300 --> 00:35:06.680
important pages include
a manifest

00:35:06.680 --> 00:35:08.270
file and use AppCache.

00:35:08.270 --> 00:35:11.240
So this is acceptable, maybe,
depending on your product

00:35:11.240 --> 00:35:12.280
requirements.

00:35:12.280 --> 00:35:15.130
But what this does is basically
limit the scope on

00:35:15.130 --> 00:35:17.890
how big your AppCache
entry can get.

00:35:17.890 --> 00:35:20.260
The next thing that you can
try is to implement your

00:35:20.260 --> 00:35:23.330
entire site as a single page.

00:35:23.330 --> 00:35:27.920
So this is more what those like,
webapps apps do, where

00:35:27.920 --> 00:35:32.590
it's just a single
HTML/JavaScript/CSS bundle

00:35:32.590 --> 00:35:34.100
sent to the client.

00:35:34.100 --> 00:35:37.180
Gmail and Twitter are both good
examples of single-page

00:35:37.180 --> 00:35:39.310
sites that use AppCache.

00:35:39.310 --> 00:35:41.390
And when you're doing this, you
don't run into the problem

00:35:41.390 --> 00:35:44.510
of many pages, because you
only have one page.

00:35:44.510 --> 00:35:49.410
And the other option is to just
not use AppCache at all.

00:35:49.410 --> 00:35:53.720
Google Search uses a really cool
technique where they want

00:35:53.720 --> 00:35:56.410
to cache lots of resources,
but they want those to be

00:35:56.410 --> 00:35:58.670
cached across all their URLs,
because when you do a search,

00:35:58.670 --> 00:36:02.430
it modifies the URL so that's
shareable and things.

00:36:02.430 --> 00:36:05.650
And so they're saving a lot of
stuff in localStorage and

00:36:05.650 --> 00:36:07.410
caching their resources that
way, such that they're

00:36:07.410 --> 00:36:08.870
available across all pages.

00:36:12.660 --> 00:36:13.900
OK, so let's change
gears a bit.

00:36:13.900 --> 00:36:17.520
So far we've only talked,
really, about page load and

00:36:17.520 --> 00:36:18.882
rendering time.

00:36:18.882 --> 00:36:22.120
The next really important
thing on mobile is event

00:36:22.120 --> 00:36:23.520
handling time.

00:36:23.520 --> 00:36:25.850
Basically, everything that
happens after your page is

00:36:25.850 --> 00:36:29.070
loaded is an event handler
of some sort.

00:36:29.070 --> 00:36:31.600
And so what I really want to
focus on here is the user does

00:36:31.600 --> 00:36:34.470
some kind of interaction on the
page, and then we execute

00:36:34.470 --> 00:36:38.230
some JavaScript and publish an
update to the applications and

00:36:38.230 --> 00:36:40.730
we change the DOM so the user
sees something happen.

00:36:44.740 --> 00:36:46.750
So there's a couple of
high-level guidelines here.

00:36:46.750 --> 00:36:50.250
First of all, everything on the
DOM is slow, so touch it

00:36:50.250 --> 00:36:52.120
as little as possible.

00:36:52.120 --> 00:36:55.350
And when you do touch it, we
want to batch all of the DOM

00:36:55.350 --> 00:36:56.510
changes together.

00:36:56.510 --> 00:36:58.570
If you were at the Jank
Busting talk that just

00:36:58.570 --> 00:37:02.560
happened an hour ago, they
showed a couple of really cool

00:37:02.560 --> 00:37:05.610
ways that you could debug
these kind of issues.

00:37:05.610 --> 00:37:06.980
And this is a little
bit of the same

00:37:06.980 --> 00:37:10.130
thing, but kind of different.

00:37:10.130 --> 00:37:14.110
So here's an example of a really
bad event handler.

00:37:14.110 --> 00:37:16.820
And this is how you can debug
it and see what's going on.

00:37:16.820 --> 00:37:19.950
So using the Events timeline,
we see, here

00:37:19.950 --> 00:37:21.040
is the event handler.

00:37:21.040 --> 00:37:22.780
And I've expanded this, and
now we can see what's

00:37:22.780 --> 00:37:24.450
happening in this
event handler.

00:37:24.450 --> 00:37:25.950
And what we see here--

00:37:25.950 --> 00:37:30.630
these are Recalculate
Style events.

00:37:30.630 --> 00:37:34.120
What we see here is we executed
some JavaScript and

00:37:34.120 --> 00:37:35.265
then we have a style
recalculation.

00:37:35.265 --> 00:37:38.450
Then we execute some more, and
we have a style recalculation.

00:37:38.450 --> 00:37:40.660
And every time there's a style
recalculation, this is what's

00:37:40.660 --> 00:37:43.080
really expensive, especially
on mobile.

00:37:43.080 --> 00:37:44.910
This is where the browser
says hey, wait, I

00:37:44.910 --> 00:37:46.240
gotta update stuff.

00:37:46.240 --> 00:37:50.480
And it basically does a reflow
of the entire document to

00:37:50.480 --> 00:37:54.140
calculate how large all the
blocks on the page are.

00:37:54.140 --> 00:37:56.120
And that's why we see this
big time gap here.

00:37:56.120 --> 00:37:58.760
This time here is the browser
just taking time to

00:37:58.760 --> 00:38:00.670
lay itself out again.

00:38:00.670 --> 00:38:03.000
And then we have another reflow
here, and another one.

00:38:03.000 --> 00:38:06.670
And then here's the
Paint event here.

00:38:06.670 --> 00:38:09.320
And this is the real goal of
the event handler, is to

00:38:09.320 --> 00:38:12.120
respond to the user's event and
Paint as soon as possible.

00:38:15.310 --> 00:38:18.930
Here's the code that is the
implementation of this really

00:38:18.930 --> 00:38:20.610
bad event handler.

00:38:20.610 --> 00:38:24.410
So what we have here is a
bunch of DOM mutations

00:38:24.410 --> 00:38:25.790
sprinkled throughout
the event handler.

00:38:25.790 --> 00:38:28.460
And this is exactly what
we want to avoid.

00:38:28.460 --> 00:38:32.540
And then what we have is, we're
looking at offsetWidth

00:38:32.540 --> 00:38:34.160
on one of these divs.

00:38:34.160 --> 00:38:37.950
And using offsetWidth is
something that requires the

00:38:37.950 --> 00:38:40.540
browser to know how large
things are on the page.

00:38:40.540 --> 00:38:42.860
So it needs to do a style
recalculation.

00:38:42.860 --> 00:38:47.430
So each one of these offsetWidth
statements here is

00:38:47.430 --> 00:38:49.600
what causes the style
recalculation and is what's

00:38:49.600 --> 00:38:53.170
making this event
handler so slow.

00:38:53.170 --> 00:38:55.800
Here's a reimplementation just
simply rearranging this

00:38:55.800 --> 00:38:58.950
function so that it performs
significantly better.

00:38:58.950 --> 00:39:01.700
All of the DOM mutations
are batched together.

00:39:01.700 --> 00:39:03.690
And then based on these
statements here, we'll only

00:39:03.690 --> 00:39:06.250
end up with one style
recalculation.

00:39:06.250 --> 00:39:08.610
So here's what it
looks like now.

00:39:08.610 --> 00:39:12.320
The event handler fires, we
execute a bunch of JavaScript,

00:39:12.320 --> 00:39:14.320
we have one style recalculation,
and

00:39:14.320 --> 00:39:15.880
then we do our Paint.

00:39:15.880 --> 00:39:19.880
And so this is significantly
faster and will end up being

00:39:19.880 --> 00:39:22.390
much more responsive feedback to
our user, because the Paint

00:39:22.390 --> 00:39:24.570
happened so much closer
as to when they

00:39:24.570 --> 00:39:25.820
interacted with the page.

00:39:29.340 --> 00:39:31.530
Here's the performance impact
this can actually have.

00:39:31.530 --> 00:39:35.500
So I ran just this simple bad
code snippet on desktop Chrome

00:39:35.500 --> 00:39:37.150
1,000 times.

00:39:37.150 --> 00:39:41.150
And it took nine seconds for the
bad case and 2.5 seconds

00:39:41.150 --> 00:39:42.800
for the good implementation.

00:39:42.800 --> 00:39:46.580
This is a 72% improvement in
the processing time of this

00:39:46.580 --> 00:39:47.150
event handler.

00:39:47.150 --> 00:39:48.160
So that's really significant.

00:39:48.160 --> 00:39:50.810
And then on mobile, I ran it
100 times on Chrome for

00:39:50.810 --> 00:39:54.220
Android, and similarly, I saw
66% improvement in the

00:39:54.220 --> 00:39:55.840
handling time.

00:39:55.840 --> 00:39:58.430
So this is really
important to do.

00:39:58.430 --> 00:40:02.260
For any time that your user on
your touch-based mobile web

00:40:02.260 --> 00:40:02.930
application--

00:40:02.930 --> 00:40:05.180
when they touch something, they
want to see an update as

00:40:05.180 --> 00:40:05.880
soon as possible.

00:40:05.880 --> 00:40:10.530
Because they a), want things to
be fast, but b), when they

00:40:10.530 --> 00:40:14.280
touch it, they need that kind
of tactile feedback in order

00:40:14.280 --> 00:40:17.460
to feel like the application is
really performing properly.

00:40:21.150 --> 00:40:23.580
So the next thing that can
really hurt your interaction

00:40:23.580 --> 00:40:27.780
speed is the 300 millisecond
problem.

00:40:27.780 --> 00:40:30.290
This is the problem where all
click events on mobile

00:40:30.290 --> 00:40:33.900
browsers come 300 milliseconds
after the user actually taps

00:40:33.900 --> 00:40:35.420
the screen.

00:40:35.420 --> 00:40:37.190
And the reason that browsers
do this is because they're

00:40:37.190 --> 00:40:40.170
waiting to see if the user taps
the screen again, which

00:40:40.170 --> 00:40:42.120
would indicate a double-tap.

00:40:42.120 --> 00:40:44.650
And so a double-tap on mobile
browsers will perform a

00:40:44.650 --> 00:40:47.420
zoom-in operation, and so that's
why they introduced

00:40:47.420 --> 00:40:50.370
this delay.

00:40:50.370 --> 00:40:54.030
For us, if we're creating an app
and we have a button, we

00:40:54.030 --> 00:40:55.970
don't really want to have
to support the user

00:40:55.970 --> 00:40:57.170
zooming in on a button.

00:40:57.170 --> 00:40:59.880
We just want that button to
respond as fast as possible.

00:40:59.880 --> 00:41:02.430
And by the time 300 milliseconds
executes, we're

00:41:02.430 --> 00:41:03.730
way too late already.

00:41:03.730 --> 00:41:04.610
There's nothing we can do.

00:41:04.610 --> 00:41:07.370
No matter how efficient our
event handler is, it's going

00:41:07.370 --> 00:41:08.620
to be too slow.

00:41:10.770 --> 00:41:14.210
So the way we fix this is
actually really hackey.

00:41:14.210 --> 00:41:16.980
I've got a code snippet here
that kind of illustrates how

00:41:16.980 --> 00:41:18.320
we can do this.

00:41:18.320 --> 00:41:21.220
This overrides the default
functionality of the click

00:41:21.220 --> 00:41:25.440
event, sets up touchend event
listeners on the button, and

00:41:25.440 --> 00:41:28.790
then on the touchend we'll do
whatever click behavior we

00:41:28.790 --> 00:41:31.320
wanted the button to do
in the first place.

00:41:31.320 --> 00:41:34.920
And then you can get a handle on
your buttons throughout the

00:41:34.920 --> 00:41:36.950
application in JavaScript
and decorate

00:41:36.950 --> 00:41:39.200
them with this behavior.

00:41:39.200 --> 00:41:40.240
And all of a sudden,
your buttons will

00:41:40.240 --> 00:41:42.630
be magically fast.

00:41:42.630 --> 00:41:46.210
So I make this code seem really
simple, but there's

00:41:46.210 --> 00:41:49.480
actually a lot of problems and
glitches that it introduces,

00:41:49.480 --> 00:41:50.910
and considerations.

00:41:50.910 --> 00:41:53.440
So for more details, check out
this article that I wrote a

00:41:53.440 --> 00:41:56.380
while ago on creating fast
buttons for mobile web

00:41:56.380 --> 00:41:57.100
applications.

00:41:57.100 --> 00:42:00.750
It explains all of the things
that you need to keep in mind

00:42:00.750 --> 00:42:02.890
while you're working
with this approach.

00:42:02.890 --> 00:42:05.300
And if you don't want to have
to write code yourself,

00:42:05.300 --> 00:42:09.170
because developers are lazy,
which is good, you can pull up

00:42:09.170 --> 00:42:13.340
this implementation here on
html5boilerplate.com/mobile

00:42:13.340 --> 00:42:15.010
and you can just drop
this into your app

00:42:15.010 --> 00:42:16.260
and start using it.

00:42:18.680 --> 00:42:18.910
OK.

00:42:18.910 --> 00:42:22.890
So the next thing that we want
to be able to do when we're

00:42:22.890 --> 00:42:25.950
providing user with DOM updates
is to make sure, if

00:42:25.950 --> 00:42:28.570
we're doing animations and
things like that, that they're

00:42:28.570 --> 00:42:30.110
as smooth as possible.

00:42:30.110 --> 00:42:32.920
Which will make the user
happy, hopefully.

00:42:32.920 --> 00:42:34.970
And so the way that we need to
do that is make sure that all

00:42:34.970 --> 00:42:38.180
of our animations and
document updates are

00:42:38.180 --> 00:42:41.930
hardware-accelerated
when necessary.

00:42:41.930 --> 00:42:46.200
So hardware-accelerated means
that you're going to take an

00:42:46.200 --> 00:42:48.470
element, and it's going to be
turned into a layer that will

00:42:48.470 --> 00:42:51.070
be uploaded to the GPU
for processing

00:42:51.070 --> 00:42:52.360
off the main thread.

00:42:52.360 --> 00:42:53.650
And this is what allows
it to be really

00:42:53.650 --> 00:42:56.260
smooth and really fast.

00:42:56.260 --> 00:42:58.310
Making something
hardware-accelerated in your

00:42:58.310 --> 00:43:01.090
document is kind of
magical today.

00:43:01.090 --> 00:43:06.070
You just have to do something to
put it into some 3D space,

00:43:06.070 --> 00:43:09.470
and that will hopefully make
it hardware-accelerated.

00:43:09.470 --> 00:43:12.640
So you can create a class
like this in your CSS

00:43:12.640 --> 00:43:14.550
rules called .hwaccel.

00:43:14.550 --> 00:43:17.210
Webkit-transform is the
identity transform.

00:43:17.210 --> 00:43:18.570
And you can apply this
to elements.

00:43:18.570 --> 00:43:21.460
It won't move it anywhere on the
page, but now updates to

00:43:21.460 --> 00:43:25.130
this element will be
hardware-accelerated.

00:43:25.130 --> 00:43:26.910
Now if you're moving
elements, you can

00:43:26.910 --> 00:43:29.040
create a different class.

00:43:29.040 --> 00:43:32.480
You can move elements using the
positioning attributes,

00:43:32.480 --> 00:43:33.910
like left or top.

00:43:33.910 --> 00:43:36.540
But it's actually much faster to
use the transform property

00:43:36.540 --> 00:43:38.090
to move elements.

00:43:38.090 --> 00:43:40.050
So this will ensure
the best hardware

00:43:40.050 --> 00:43:41.660
acceleration possible.

00:43:41.660 --> 00:43:44.340
So what we have here is a
little CSS rule to make

00:43:44.340 --> 00:43:45.770
something transitionable.

00:43:45.770 --> 00:43:48.460
We've applied transition,
which will be on

00:43:48.460 --> 00:43:49.870
the transform property.

00:43:49.870 --> 00:43:52.520
This transition will take 200
milliseconds to execute and

00:43:52.520 --> 00:43:53.770
we'll use an easing function.

00:43:56.460 --> 00:43:56.690
OK.

00:43:56.690 --> 00:43:59.890
So we're going to put these
three ideas together now.

00:43:59.890 --> 00:44:03.740
The three ideas were efficient
event handling, solving the

00:44:03.740 --> 00:44:08.780
300-millisecond problem, and
smooth updating of elements

00:44:08.780 --> 00:44:10.290
using hardware acceleration.

00:44:10.290 --> 00:44:11.870
So consider a scenario.

00:44:11.870 --> 00:44:14.320
In your mobile web app, you've
got a button, and when the

00:44:14.320 --> 00:44:16.930
user taps that button, you
want to do a view slide

00:44:16.930 --> 00:44:18.950
transition to the next page.

00:44:18.950 --> 00:44:21.160
And you want this to happen
as fast as possible.

00:44:21.160 --> 00:44:22.720
The next page isn't
rendered yet.

00:44:22.720 --> 00:44:25.970
So we need to render it when
the user taps this.

00:44:25.970 --> 00:44:28.290
And the next page needs to
become interactive as well.

00:44:28.290 --> 00:44:30.360
So not only do we need to render
it, but we need to add

00:44:30.360 --> 00:44:33.460
a bunch of event listeners to
it, and maybe load in some

00:44:33.460 --> 00:44:36.090
images, and stuff like that.

00:44:36.090 --> 00:44:37.570
So here's a nice approach
we can take.

00:44:37.570 --> 00:44:40.450
First of all, we'll set up a
couple of CSS rules for our

00:44:40.450 --> 00:44:44.790
two pages that will make
them transitionable.

00:44:44.790 --> 00:44:48.270
Next we'll take our button and
make it a fast button to avoid

00:44:48.270 --> 00:44:50.770
the 300 millisecond problem.

00:44:50.770 --> 00:44:55.050
Now when the tap event occurs,
we'll get a handle on the

00:44:55.050 --> 00:44:56.920
current page and
the next page.

00:44:56.920 --> 00:44:58.900
We'll render the next page,
but we're going to be very

00:44:58.900 --> 00:45:02.360
careful to only do a minimal
amount of rendering possible.

00:45:02.360 --> 00:45:04.310
So we don't want to render
everything, because that will

00:45:04.310 --> 00:45:04.810
take too long.

00:45:04.810 --> 00:45:09.010
We want to start this animation
as soon as possible.

00:45:09.010 --> 00:45:11.070
We then apply our transform
properties, because using

00:45:11.070 --> 00:45:15.240
transforms is the better way
to reposition an element.

00:45:15.240 --> 00:45:18.080
And we're going to do it such
that the current page animates

00:45:18.080 --> 00:45:23.070
off the screen and the next page
animates onto the screen.

00:45:23.070 --> 00:45:25.200
Remember, we want to make the
next page interactive.

00:45:25.200 --> 00:45:27.000
As soon as we apply these
transforms, the

00:45:27.000 --> 00:45:29.660
animation will start.

00:45:29.660 --> 00:45:31.300
But we still have to do
additional work on the next

00:45:31.300 --> 00:45:34.960
page to load in those extra
resources, images, maybe, and

00:45:34.960 --> 00:45:36.660
add event listeners to it.

00:45:36.660 --> 00:45:39.580
So we can add an event listener
which will fire as

00:45:39.580 --> 00:45:41.240
soon as the transition ends.

00:45:41.240 --> 00:45:44.480
And when it does, now this is
the appropriate time to do all

00:45:44.480 --> 00:45:47.610
that additional rendering
and event setup.

00:45:47.610 --> 00:45:50.480
So what we have here
is probably

00:45:50.480 --> 00:45:51.990
the ideal event handler.

00:45:51.990 --> 00:45:53.040
It's a fast button.

00:45:53.040 --> 00:45:55.070
We do a minimal amount
of DOM changes.

00:45:55.070 --> 00:45:57.390
And all of our DOM changes
are batched together.

00:45:57.390 --> 00:46:00.150
And then we defer all of the
expensive work until after the

00:46:00.150 --> 00:46:01.070
animation starts.

00:46:01.070 --> 00:46:02.600
And our animation is
hardware-accelerated.

00:46:06.700 --> 00:46:09.820
So that's all I have
for you today.

00:46:09.820 --> 00:46:11.400
Here's a summary of the various

00:46:11.400 --> 00:46:13.520
optimizations that we did.

00:46:13.520 --> 00:46:16.810
And some of them were a little
bit surprising, so again,

00:46:16.810 --> 00:46:18.900
that's why it's really good
that we measure things.

00:46:18.900 --> 00:46:20.880
So we don't just assume what's
going to happen.

00:46:20.880 --> 00:46:24.320
We confirm that it behaves
as expected.

00:46:24.320 --> 00:46:25.780
And these are some of the
tools that we looked at.

00:46:25.780 --> 00:46:27.610
Chrome dev tools, PageSpeed,
and webpagetest.org.

00:46:30.540 --> 00:46:32.100
And if you're going to remember
anything, please

00:46:32.100 --> 00:46:33.520
remember, don't waste
your time.

00:46:33.520 --> 00:46:35.750
Always measure before
and after.

00:46:35.750 --> 00:46:37.740
Verify all of your
assumptions.

00:46:37.740 --> 00:46:40.160
And optimize what will make a
difference, not just what's

00:46:40.160 --> 00:46:42.798
interesting to work on.

00:46:42.798 --> 00:46:43.260
OK.

00:46:43.260 --> 00:46:45.150
Thank you very much.

00:46:45.150 --> 00:46:47.341
I'll happily take some questions
if people want.

00:46:47.341 --> 00:46:53.000
[APPLAUSE]

00:46:53.000 --> 00:46:54.180
AUDIENCE: Hey there.

00:46:54.180 --> 00:46:55.960
RYAN FIORAVANTI: I can also
stick around for a bit after,

00:46:55.960 --> 00:46:57.750
if people would like
to talk in person.

00:46:57.750 --> 00:46:59.430
But if you want to ask a
question in front of everyone,

00:46:59.430 --> 00:47:01.250
just step up to the mic.

00:47:01.250 --> 00:47:05.340
AUDIENCE: I was wondering if you
know if jQuery mobile uses

00:47:05.340 --> 00:47:10.310
most of the optimizations that
you were just showing.

00:47:10.310 --> 00:47:11.860
RYAN FIORAVANTI: jQuery
mobile, I know--

00:47:11.860 --> 00:47:15.200
I'm pretty sure they have the
tab functionality, like making

00:47:15.200 --> 00:47:16.970
buttons fast.

00:47:16.970 --> 00:47:18.750
I've also seen that they've
worked a lot on view

00:47:18.750 --> 00:47:21.440
transitions and things.

00:47:21.440 --> 00:47:24.620
When you're using these
frameworks, they can try and

00:47:24.620 --> 00:47:25.590
do a lot of stuff for you.

00:47:25.590 --> 00:47:27.730
But based on all of your
integration points, it's

00:47:27.730 --> 00:47:30.170
really easy to introduce
slow points.

00:47:30.170 --> 00:47:32.120
So it's really important, even
if you're using all these

00:47:32.120 --> 00:47:34.770
libraries, that you really dig
and understand what can make

00:47:34.770 --> 00:47:35.750
your app slow.

00:47:35.750 --> 00:47:37.730
And look at if it's
being slow.

00:47:37.730 --> 00:47:40.240
Maybe jQuery mobile does do
all of this stuff, but you

00:47:40.240 --> 00:47:42.110
have to confirm that you're
using it properly.

00:47:42.110 --> 00:47:45.490
Because there's so much you
can do to screw it up.

00:47:45.490 --> 00:47:46.740
So yeah.

00:47:48.840 --> 00:47:48.986
AUDIENCE: Yeah.

00:47:48.986 --> 00:47:51.460
I have a question about your
really interesting technique

00:47:51.460 --> 00:47:54.320
for making the JavaScript
load later by making

00:47:54.320 --> 00:47:55.320
it a different type.

00:47:55.320 --> 00:47:57.280
I've seen a lot of people do the
technique where they put

00:47:57.280 --> 00:47:58.740
the JavaScript at the
bottom of the page

00:47:58.740 --> 00:48:00.650
instead of in the head.

00:48:00.650 --> 00:48:02.550
How does that play into
the decision?

00:48:02.550 --> 00:48:04.770
RYAN FIORAVANTI: Yeah, so I
tried moving the JavaScript to

00:48:04.770 --> 00:48:06.020
the bottom of page.

00:48:09.020 --> 00:48:13.580
When it's at the bottom of the
page, the browser has just

00:48:13.580 --> 00:48:15.750
finished receiving the
entire document.

00:48:15.750 --> 00:48:19.680
And so it's not clear whether
it's being painted or not.

00:48:19.680 --> 00:48:22.130
And it then encounters the
JavaScript, which may or may

00:48:22.130 --> 00:48:23.230
not be mutating the DOM.

00:48:23.230 --> 00:48:25.220
So it then executes
all of that.

00:48:25.220 --> 00:48:27.230
So when I did that, it didn't
actually have an impact on my

00:48:27.230 --> 00:48:29.440
experiments at all.

00:48:29.440 --> 00:48:31.150
And it kind of makes sense.

00:48:31.150 --> 00:48:34.060
Like if your script at the
bottom is going to change

00:48:34.060 --> 00:48:36.550
everything in the document, then
the browser should wait

00:48:36.550 --> 00:48:42.220
for that so that you can show
the user the proper content.

00:48:42.220 --> 00:48:43.370
Does that answer your question?

00:48:43.370 --> 00:48:45.470
Yeah.

00:48:45.470 --> 00:48:48.560
AUDIENCE: What tool
did you use to get

00:48:48.560 --> 00:48:51.960
the repeated pageloads?

00:48:51.960 --> 00:48:53.630
RYAN FIORAVANTI: So at first--

00:48:53.630 --> 00:48:54.300
I'll be honest--

00:48:54.300 --> 00:48:56.950
I was actually just refreshing
the page and looking at some

00:48:56.950 --> 00:48:58.980
of the timing output
in the dev console.

00:48:58.980 --> 00:49:05.070
But then I got much smarter and
I created a loop, kind of,

00:49:05.070 --> 00:49:07.620
where the page would load and
then it would take my timing.

00:49:07.620 --> 00:49:10.380
I would save that in
localStorage and then I would

00:49:10.380 --> 00:49:12.690
call window.location.reload.

00:49:12.690 --> 00:49:15.550
And also in localStorage, I
would save the number of times

00:49:15.550 --> 00:49:16.840
I ran this.

00:49:16.840 --> 00:49:20.340
So when that counter
got to 50--

00:49:20.340 --> 00:49:22.260
because I was running
50 samples--

00:49:22.260 --> 00:49:24.410
then I would stop calling
reload, and I would just stop,

00:49:24.410 --> 00:49:26.460
and I would alert the
average of all the

00:49:26.460 --> 00:49:27.710
times that I was tracking.

00:49:30.210 --> 00:49:30.770
So, no tool.

00:49:30.770 --> 00:49:31.910
I just wrote something
that used

00:49:31.910 --> 00:49:33.160
localStorage pretty quickly.

00:49:38.451 --> 00:49:38.950
OK.

00:49:38.950 --> 00:49:40.200
Thanks everybody.

