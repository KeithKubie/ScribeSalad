WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:05.750
[MUSIC PLAYING]

00:00:05.750 --> 00:00:08.240
BILL BILODEAU: Today, I'm going
to be talking about Android

00:00:08.240 --> 00:00:12.230
memory, and specifically
Android memory and games,

00:00:12.230 --> 00:00:15.440
from a games perspective.

00:00:15.440 --> 00:00:19.130
My name is Bill Bilodeau, and
I work with game developers.

00:00:19.130 --> 00:00:20.960
I'm a developer advocate.

00:00:20.960 --> 00:00:24.590
And working with
game developers,

00:00:24.590 --> 00:00:28.340
oftentimes I hear
things about memory--

00:00:28.340 --> 00:00:32.070
problems that they have
running out of memory.

00:00:32.070 --> 00:00:35.180
So I want to talk about
some of the things

00:00:35.180 --> 00:00:37.850
about memory and Android.

00:00:37.850 --> 00:00:39.800
But specific about
one of the things

00:00:39.800 --> 00:00:42.810
that I first want to mention,
before I go into that,

00:00:42.810 --> 00:00:47.450
is there have been
some improvements in Q,

00:00:47.450 --> 00:00:49.220
with respect to memory.

00:00:49.220 --> 00:00:55.100
So during my slides, I'm going
to be showing this Q logo,

00:00:55.100 --> 00:00:59.330
and that'll kind of help you
remember that this is something

00:00:59.330 --> 00:01:02.360
new in Q. All right.

00:01:02.360 --> 00:01:06.200
So what are some of the
problems that developers

00:01:06.200 --> 00:01:09.740
face with memory?

00:01:09.740 --> 00:01:12.620
The biggest problem is, of
course, running out of memory

00:01:12.620 --> 00:01:15.550
and having your game just crash.

00:01:15.550 --> 00:01:19.520
Now, Android is different
than other platforms.

00:01:19.520 --> 00:01:23.870
If you take, for
example, consoles,

00:01:23.870 --> 00:01:25.700
you have a fixed
amount of memory.

00:01:25.700 --> 00:01:30.680
And it's much easier to predict
how much memory you can use

00:01:30.680 --> 00:01:33.940
and how much memory
to budget for.

00:01:33.940 --> 00:01:38.100
In the case of the PC, you
have a lot of swap space.

00:01:38.100 --> 00:01:42.470
So if you start running low on
memory, a lot of that memory

00:01:42.470 --> 00:01:45.090
can be swapped to disk.

00:01:45.090 --> 00:01:49.550
However, in the case of Android,
when it runs low on memory,

00:01:49.550 --> 00:01:51.770
about the only thing
that can happen

00:01:51.770 --> 00:01:57.200
to you, that it can do about
it, is your game gets killed.

00:01:57.200 --> 00:01:59.310
So it's not good.

00:01:59.310 --> 00:02:01.770
So you want to avoid
that situation.

00:02:01.770 --> 00:02:04.050
And I'm going to be
talking about that today--

00:02:04.050 --> 00:02:05.990
how to avoid that.

00:02:05.990 --> 00:02:10.820
Now, ideally, game
developers would like

00:02:10.820 --> 00:02:13.670
to have fixed memory budgets.

00:02:13.670 --> 00:02:16.570
It makes it much easier when
you're developing the game.

00:02:16.570 --> 00:02:18.860
You tell your artists,
I have a certain amount

00:02:18.860 --> 00:02:21.830
for textures, geometry.

00:02:21.830 --> 00:02:25.100
You can set aside a
certain amount for code.

00:02:25.100 --> 00:02:27.410
But in order to
do this, you need

00:02:27.410 --> 00:02:31.500
to know how big
that whole pie is.

00:02:31.500 --> 00:02:37.140
And that's the hard thing to
do, because in order to do this,

00:02:37.140 --> 00:02:41.270
you need to know
the size of memory--

00:02:41.270 --> 00:02:43.620
how much memory is available.

00:02:43.620 --> 00:02:48.110
So in the case of
Android, you can set--

00:02:48.110 --> 00:02:52.400
one answer to this question
is, as much as possible.

00:02:52.400 --> 00:02:55.700
But that's still kind
of vague, because it

00:02:55.700 --> 00:02:57.380
depends a lot on the system.

00:03:00.200 --> 00:03:03.140
The system can't be
taken out of memory.

00:03:03.140 --> 00:03:06.680
It still has to be
there, so your game

00:03:06.680 --> 00:03:12.860
has to share that
memory with the system.

00:03:12.860 --> 00:03:14.860
So what this means
is there's really

00:03:14.860 --> 00:03:19.480
no definite fixed size on how
much available memory you have.

00:03:22.530 --> 00:03:26.790
I'm hoping that by
seeing this talk,

00:03:26.790 --> 00:03:29.760
and learning more
about Android memory,

00:03:29.760 --> 00:03:32.640
and understanding how
it works, that you'll

00:03:32.640 --> 00:03:35.970
be able to prevent the
bad things from happening,

00:03:35.970 --> 00:03:38.880
like crashes.

00:03:38.880 --> 00:03:43.260
Now before I go on, I
did this memory test.

00:03:43.260 --> 00:03:47.430
I put together this little
app that allocates memory.

00:03:47.430 --> 00:03:49.410
And every time you press
on this red button,

00:03:49.410 --> 00:03:52.020
it allocates 100 megabytes.

00:03:52.020 --> 00:03:58.170
And I was able to allocate
4.1 gigabytes on a device that

00:03:58.170 --> 00:04:01.080
only has 4 gigabytes of RAM.

00:04:01.080 --> 00:04:03.100
How is that possible?

00:04:03.100 --> 00:04:07.080
So first of all, I don't
recommend that games do this.

00:04:07.080 --> 00:04:09.000
You're going to run
into other problems

00:04:09.000 --> 00:04:11.190
if you try to allocate
that much memory.

00:04:11.190 --> 00:04:13.740
But I want you to
think about that,

00:04:13.740 --> 00:04:16.140
and we'll come
back to that later.

00:04:18.908 --> 00:04:20.450
So here are some of
the things that I

00:04:20.450 --> 00:04:25.710
think game developers should
know about Android memory.

00:04:25.710 --> 00:04:28.760
First of all, the Android
memory philosophy.

00:04:28.760 --> 00:04:35.750
It's similar to Linux, because
Android is based on Linux.

00:04:35.750 --> 00:04:38.420
It wants to use all of RAM.

00:04:38.420 --> 00:04:41.240
If you think about
it, free RAM is really

00:04:41.240 --> 00:04:43.040
doing no one any good.

00:04:43.040 --> 00:04:46.170
It's just sitting
there, doing nothing.

00:04:46.170 --> 00:04:50.540
So the way Android
uses all of this RAM

00:04:50.540 --> 00:04:54.440
is to keep apps in memory.

00:04:54.440 --> 00:04:56.960
The result of this
is you never really

00:04:56.960 --> 00:04:59.600
have a lot of free memory
on Android devices.

00:05:02.340 --> 00:05:04.680
So why do you keep all
of these apps in memory?

00:05:04.680 --> 00:05:07.580
It's so you can do things
like fast apps switching.

00:05:07.580 --> 00:05:10.010
If you have an app that
you started, and you put it

00:05:10.010 --> 00:05:12.440
in the background, and
you go to another app,

00:05:12.440 --> 00:05:14.360
you're able to switch
to different apps,

00:05:14.360 --> 00:05:16.370
because they stay
resident in memory.

00:05:19.010 --> 00:05:22.370
Now, the nice thing about
Q, a new improvement in Q,

00:05:22.370 --> 00:05:27.170
is that we're doing very active
compaction of these background

00:05:27.170 --> 00:05:31.100
apps, so that if you have a
very large app, like your game,

00:05:31.100 --> 00:05:33.800
for example, you
can actually put

00:05:33.800 --> 00:05:35.360
your game into the background.

00:05:35.360 --> 00:05:37.910
Users can put your
game to the background,

00:05:37.910 --> 00:05:41.120
and it'll still be resonant
and running when it comes back.

00:05:45.570 --> 00:05:50.510
So let's look at some of the
specifics about device memory.

00:05:50.510 --> 00:05:52.130
There's different
types of memory.

00:05:52.130 --> 00:05:54.890
We can categorize
them by size, and also

00:05:54.890 --> 00:05:58.290
by how fast that memory is.

00:05:58.290 --> 00:06:01.280
So for example, RAM
is the fast memory.

00:06:01.280 --> 00:06:02.540
It's limited in size.

00:06:02.540 --> 00:06:05.420
It's smaller than
other types of memory.

00:06:05.420 --> 00:06:08.150
One thing to
consider about RAM is

00:06:08.150 --> 00:06:11.870
that it's shared between
the CPU and the GPU.

00:06:11.870 --> 00:06:16.370
So they both are
using that memory.

00:06:16.370 --> 00:06:19.520
Android devices also
have secondary storage.

00:06:19.520 --> 00:06:21.620
This is where your
apps are stored

00:06:21.620 --> 00:06:24.420
when they're not being used.

00:06:24.420 --> 00:06:26.360
This is non-volatile RAM.

00:06:26.360 --> 00:06:30.920
It's slower than RAM, but
you have a lot more of it.

00:06:30.920 --> 00:06:35.270
So this diagram
really isn't to scale.

00:06:35.270 --> 00:06:37.370
Another type of RAM
that I want to mention,

00:06:37.370 --> 00:06:41.090
or memory that I want
to mention, is zRAM.

00:06:41.090 --> 00:06:46.670
And this is compressed memory
that the system sets aside

00:06:46.670 --> 00:06:47.390
for swapping.

00:06:50.160 --> 00:06:52.710
So, go into a little
bit more detail here.

00:06:52.710 --> 00:06:55.740
What are the different
types of memory?

00:06:55.740 --> 00:07:00.190
Obviously, we have free
memory, free memory pages.

00:07:00.190 --> 00:07:03.390
We also have pages
that are storage back.

00:07:03.390 --> 00:07:07.380
So these are pages
that are stored

00:07:07.380 --> 00:07:11.310
on that storage, that
secondary storage device,

00:07:11.310 --> 00:07:14.370
and also are in memory.

00:07:14.370 --> 00:07:16.860
Note, I just want to point
out, when I say memory,

00:07:16.860 --> 00:07:18.630
I'm usually referring to RAM.

00:07:18.630 --> 00:07:21.300
So I'm using those
terms interchangeably.

00:07:21.300 --> 00:07:23.153
When I talk about
storage memory,

00:07:23.153 --> 00:07:24.945
I'll usually try to
refer to it as storage.

00:07:27.890 --> 00:07:29.390
Now, there's also clean pages.

00:07:29.390 --> 00:07:32.510
Clean pages are pages
that are storage back,

00:07:32.510 --> 00:07:34.430
but have not been modified.

00:07:34.430 --> 00:07:36.630
And you also have
dirty pages, which are

00:07:36.630 --> 00:07:37.880
pages that have been modified.

00:07:40.580 --> 00:07:43.170
Anonymous memory, you might
have heard about that.

00:07:43.170 --> 00:07:45.520
That's memory that you're
allocating-- that you

00:07:45.520 --> 00:07:46.520
allocate through malloc.

00:07:49.990 --> 00:07:55.170
So what happens when you run
low on memory on Android?

00:07:55.170 --> 00:07:59.520
First of all, there is something
in a kernel called kernel swap

00:07:59.520 --> 00:08:03.150
daemon, or kswapd.

00:08:03.150 --> 00:08:06.360
And this is responsible
for reclaiming memory.

00:08:06.360 --> 00:08:12.040
So it turns pages that
are used into free memory.

00:08:12.040 --> 00:08:14.850
It does this by swapping
pages, or, in some cases,

00:08:14.850 --> 00:08:17.280
deleting the pages.

00:08:17.280 --> 00:08:22.920
The interesting thing is it runs
asynchronously from your game.

00:08:22.920 --> 00:08:27.120
So here's an example where
we've got a storage back page.

00:08:27.120 --> 00:08:28.110
It's clean.

00:08:28.110 --> 00:08:30.270
We'll say it's
clean, not modified.

00:08:30.270 --> 00:08:33.700
And as this pink rectangle here.

00:08:33.700 --> 00:08:35.919
And let's say we want
to reclaim this memory.

00:08:35.919 --> 00:08:40.289
So what kswapd does is it just
deletes the page, because it

00:08:40.289 --> 00:08:41.460
hasn't been modified.

00:08:41.460 --> 00:08:45.660
If it needs it again, it'll
just read it in from storage.

00:08:45.660 --> 00:08:48.490
Suppose you have
modified memory,

00:08:48.490 --> 00:08:51.000
and even if it was
storage back, you

00:08:51.000 --> 00:08:57.430
couldn't just delete it, because
those changes would be lost.

00:08:57.430 --> 00:09:00.480
So what Android
can do is swap it

00:09:00.480 --> 00:09:03.870
into zRAM, so that
partition of memory that's

00:09:03.870 --> 00:09:06.570
used for compressed memory.

00:09:06.570 --> 00:09:08.370
Now, because it's
compressed, it's

00:09:08.370 --> 00:09:10.270
going to take up less space.

00:09:10.270 --> 00:09:15.060
So this is a good thing.

00:09:15.060 --> 00:09:19.530
Android track of certain memory
thresholds, both low memory

00:09:19.530 --> 00:09:22.560
thresholds and high
memory thresholds.

00:09:22.560 --> 00:09:25.680
And it uses these thresholds
as triggers on when to do

00:09:25.680 --> 00:09:27.450
reclaims.

00:09:27.450 --> 00:09:32.500
Here's an example of how
kswapd reclaims memory.

00:09:32.500 --> 00:09:34.710
Say your application
is allocating memory,

00:09:34.710 --> 00:09:37.890
and this blue line here is
the amount of free memory

00:09:37.890 --> 00:09:39.220
that you have.

00:09:39.220 --> 00:09:41.940
So as you keep allocating
memory over time,

00:09:41.940 --> 00:09:44.220
that blue line goes
down, until it eventually

00:09:44.220 --> 00:09:46.890
hits the low memory threshold.

00:09:46.890 --> 00:09:51.330
At that point, kswapd kicks in
and starts reclaiming pages.

00:09:51.330 --> 00:09:55.200
So your memory, your free
memory, goes back up.

00:09:55.200 --> 00:09:58.150
But you don't want to
keep reclaiming pages,

00:09:58.150 --> 00:10:00.600
because some of those pages
you want to keep in memory,

00:10:00.600 --> 00:10:03.090
because your game
might need them.

00:10:03.090 --> 00:10:08.790
So it stops reclaiming memory,
and then if your game keeps--

00:10:08.790 --> 00:10:10.740
if your game keeps
allocating memory,

00:10:10.740 --> 00:10:12.930
this whole process is
going to repeat itself.

00:10:16.200 --> 00:10:19.460
I also want to introduce this
concept here of available RAM

00:10:19.460 --> 00:10:21.650
versus free RAM.

00:10:21.650 --> 00:10:24.470
So I consider
available RAM to be

00:10:24.470 --> 00:10:28.550
the free RAM, plus
any kind of RAM that

00:10:28.550 --> 00:10:30.030
can be reclaimed by kswapd.

00:10:34.140 --> 00:10:37.410
So another part of the kernel
that helps to free up memory

00:10:37.410 --> 00:10:39.870
is something called
low memory killer.

00:10:39.870 --> 00:10:42.630
It's also called
LMK, abbreviated LMK.

00:10:45.170 --> 00:10:50.480
And for each process, it keeps
track of an out of memory

00:10:50.480 --> 00:10:51.830
adjust score.

00:10:51.830 --> 00:10:56.120
And the score ranges from
minus 1,000 to 1,000.

00:10:56.120 --> 00:10:59.640
The higher the score, the
more likely to get killed.

00:10:59.640 --> 00:11:03.650
So those with a score of
1,000 get killed first.

00:11:03.650 --> 00:11:07.490
The ones at the bottom, at minus
1,000, have a very low score,

00:11:07.490 --> 00:11:11.310
and are highly
unlikely to get killed.

00:11:11.310 --> 00:11:14.630
So the background apps
have these high scores.

00:11:14.630 --> 00:11:15.830
So they're more likely--

00:11:15.830 --> 00:11:18.950
they're the first
ones to get killed.

00:11:18.950 --> 00:11:21.080
Your foreground
app is going to get

00:11:21.080 --> 00:11:24.560
killed if it has to get killed,
after all of the background

00:11:24.560 --> 00:11:26.180
apps.

00:11:26.180 --> 00:11:29.490
And the system is almost
never going to get killed.

00:11:29.490 --> 00:11:33.018
So all of these
system processes,

00:11:33.018 --> 00:11:35.060
they're not going to get
killed before your game.

00:11:38.220 --> 00:11:40.370
One thing to
consider is that OEMs

00:11:40.370 --> 00:11:44.280
can modify the behavior
of low memory killer.

00:11:44.280 --> 00:11:48.360
So it can vary from
different devices.

00:11:48.360 --> 00:11:51.150
Here's an example
of how low memory

00:11:51.150 --> 00:11:53.490
killer works with a game.

00:11:53.490 --> 00:11:56.310
So you have your game here
running in the foreground,

00:11:56.310 --> 00:11:59.580
and it has out of memory
adjust score of 0.

00:11:59.580 --> 00:12:03.330
And you have these other
two apps in the background.

00:12:03.330 --> 00:12:08.640
And they have out of memory
are very score of 905 and 900.

00:12:08.640 --> 00:12:11.070
On the right here--
or, yes-- on the right

00:12:11.070 --> 00:12:16.180
here is a little chart
showing the available memory.

00:12:16.180 --> 00:12:19.860
And we'll see what happens
when your game starts

00:12:19.860 --> 00:12:21.180
allocating memory.

00:12:21.180 --> 00:12:21.680
OK.

00:12:21.680 --> 00:12:27.570
So you've allocated memory
below this 905 threshold.

00:12:27.570 --> 00:12:30.750
It's a memory
threshold corresponding

00:12:30.750 --> 00:12:32.640
to the out of
memory adjust score.

00:12:32.640 --> 00:12:35.310
At that point, low
memory killer knows

00:12:35.310 --> 00:12:38.560
that it can kill that process.

00:12:38.560 --> 00:12:40.510
And because of that,
it frees up memory.

00:12:40.510 --> 00:12:41.010
OK.

00:12:41.010 --> 00:12:42.090
This is great.

00:12:42.090 --> 00:12:45.653
So your app just keeps
on allocating memory.

00:12:45.653 --> 00:12:47.070
Eventually, it'll
get to the point

00:12:47.070 --> 00:12:49.900
where it hits this threshold.

00:12:49.900 --> 00:12:52.140
And now the Chrome
app in the background

00:12:52.140 --> 00:12:55.080
will get killed by
low memory killer.

00:12:55.080 --> 00:12:58.590
If your game keeps
allocating, it will eventually

00:12:58.590 --> 00:13:00.220
get to the point where it--

00:13:00.220 --> 00:13:00.810
well, sorry.

00:13:00.810 --> 00:13:03.090
It gets more memory back,
because it killed Chrome.

00:13:03.090 --> 00:13:04.715
But it will eventually
get to the point

00:13:04.715 --> 00:13:09.580
where it gets below
that zero threshold.

00:13:09.580 --> 00:13:11.640
And at that point,
low memory killer

00:13:11.640 --> 00:13:15.130
will come in and kill your game.

00:13:15.130 --> 00:13:20.130
So that's how games get killed,
because they run low on memory.

00:13:20.130 --> 00:13:22.410
Android knows that it has
to keep a certain amount

00:13:22.410 --> 00:13:24.090
of free memory around.

00:13:24.090 --> 00:13:27.420
And it'll even kill
your game to make sure

00:13:27.420 --> 00:13:30.030
that that amount of free
memory is available.

00:13:32.730 --> 00:13:38.130
Fortunately, Android does have
something called onTrimMemory.

00:13:38.130 --> 00:13:42.520
onTrimMemory is a
Warning about low memory,

00:13:42.520 --> 00:13:45.330
that the system is
running low on memory.

00:13:45.330 --> 00:13:50.690
And it's a callback to your
game to tell it to do something.

00:13:50.690 --> 00:13:54.530
Now, in Android P,
and earlier versions,

00:13:54.530 --> 00:13:57.620
it wasn't that reliable.

00:13:57.620 --> 00:14:02.480
There were problems
where it was not

00:14:02.480 --> 00:14:04.400
signaling this
onTrimMemory, even

00:14:04.400 --> 00:14:06.020
though you're in
a critical stage

00:14:06.020 --> 00:14:08.950
where you're going
to get killed.

00:14:08.950 --> 00:14:13.760
So games, or apps, may not have
been paying attention to this.

00:14:13.760 --> 00:14:18.740
Now, this has been
improved in Q.

00:14:18.740 --> 00:14:24.800
It's using a new trigger, now,
to let the onTrimMemory know

00:14:24.800 --> 00:14:27.530
when to send this call,
when to the system

00:14:27.530 --> 00:14:29.870
to send this onTrimMemory call.

00:14:29.870 --> 00:14:32.920
It's called pressure
stall information.

00:14:32.920 --> 00:14:36.710
Pressure stall information was
something introduced in Linux,

00:14:36.710 --> 00:14:43.760
and it was modified by
Android to measure the time it

00:14:43.760 --> 00:14:47.730
takes to obtain memory.

00:14:47.730 --> 00:14:51.680
So if you remember, I was
talking about kswapd and low

00:14:51.680 --> 00:14:52.850
memory killer.

00:14:52.850 --> 00:14:54.510
These things take time.

00:14:54.510 --> 00:14:57.920
And so, as the system
runs low on memory,

00:14:57.920 --> 00:15:02.720
these take more time to reclaim
memory, and give the app more

00:15:02.720 --> 00:15:04.410
memory.

00:15:04.410 --> 00:15:07.420
So pressure stall
information measures that.

00:15:07.420 --> 00:15:10.520
And the longer it takes, when
it gets to a certain point,

00:15:10.520 --> 00:15:13.340
it will say, OK, now I'm going
to warn the app that we're

00:15:13.340 --> 00:15:16.340
really running low on memory.

00:15:16.340 --> 00:15:20.580
And that's where an
onTrimMemory gets called.

00:15:20.580 --> 00:15:23.090
So I just want to kind
of summarize here.

00:15:23.090 --> 00:15:25.850
You've got low memory
killer, kswapd,

00:15:25.850 --> 00:15:28.460
and then you have your game.

00:15:28.460 --> 00:15:31.400
And these are running
asynchronously.

00:15:31.400 --> 00:15:34.100
And the problem
with that is things

00:15:34.100 --> 00:15:38.190
tend to happen unexpected.

00:15:38.190 --> 00:15:42.270
Fortunately, changes in Q, like
pressure stall information,

00:15:42.270 --> 00:15:43.230
should help with this.

00:15:46.040 --> 00:15:48.190
So what things
should your game do

00:15:48.190 --> 00:15:52.460
to avoid low memory situations?

00:15:52.460 --> 00:15:55.970
The first thing is
respond to onTrimMemory.

00:15:55.970 --> 00:15:58.660
Now, we feel that
this is more reliable.

00:15:58.660 --> 00:16:00.550
It provides reliable signals.

00:16:00.550 --> 00:16:03.520
So it's something you
really should respond to,

00:16:03.520 --> 00:16:06.290
because it's probably the only
warning you're going to get.

00:16:09.190 --> 00:16:12.480
Now, onTrimMemory
still has high latency,

00:16:12.480 --> 00:16:16.650
so you could be running
into a critical situation.

00:16:16.650 --> 00:16:18.870
And it may take some
time for onTrimMemory

00:16:18.870 --> 00:16:21.580
to notify your game.

00:16:21.580 --> 00:16:25.740
So when you do get it, you want
to make sure you take action.

00:16:25.740 --> 00:16:27.780
And I mean doing
things like trying

00:16:27.780 --> 00:16:32.070
to reduce the allocations,
slow down your allocations.

00:16:32.070 --> 00:16:35.940
Try to remove things
from memory, if possible.

00:16:35.940 --> 00:16:39.420
Maybe if you've got a lot of
shaders resonant in memory,

00:16:39.420 --> 00:16:41.550
you want to evict
some of those shaders.

00:16:41.550 --> 00:16:46.890
Maybe you want to use lower
rez textures, things like that.

00:16:46.890 --> 00:16:51.960
And also, because you're running
in a low memory situation,

00:16:51.960 --> 00:16:55.767
you have a greater probability
that the game might get killed.

00:16:55.767 --> 00:16:57.600
So at this point, you
might want to consider

00:16:57.600 --> 00:16:59.860
saving the state of the game.

00:16:59.860 --> 00:17:04.103
So if it does get killed,
at least the players

00:17:04.103 --> 00:17:05.520
who were playing
this game are not

00:17:05.520 --> 00:17:08.670
going to be so frustrated when
the game gets launched again.

00:17:08.670 --> 00:17:11.640
And they haven't lost much.

00:17:14.310 --> 00:17:17.150
So here's some Java
code that shows

00:17:17.150 --> 00:17:20.040
how you can use onTrimMemory.

00:17:20.040 --> 00:17:23.300
So in a main activity,
what you can do

00:17:23.300 --> 00:17:30.020
is make sure you implement
ComponentsCallback2.

00:17:30.020 --> 00:17:34.130
And then you just implement
this onTrimMemory call.

00:17:34.130 --> 00:17:39.320
And notice that onTrimMemory
gets passed a level.

00:17:39.320 --> 00:17:42.020
And this level corresponds
to the severity

00:17:42.020 --> 00:17:44.090
of the memory situation.

00:17:44.090 --> 00:17:48.080
So it can be either
moderate, or low,

00:17:48.080 --> 00:17:52.280
and critical, which
is the last one.

00:17:52.280 --> 00:17:53.960
There are a few other
levels, but these

00:17:53.960 --> 00:17:56.930
are the ones I think are
important, ones I've looked at.

00:17:56.930 --> 00:17:59.630
And in my case, the only
thing I did was here

00:17:59.630 --> 00:18:03.808
is pop up a message showing
what the memory level is.

00:18:03.808 --> 00:18:05.600
But in your case, what
you would want to do

00:18:05.600 --> 00:18:09.800
is actually take action, and
try to reduce the memory.

00:18:09.800 --> 00:18:16.470
So for Unity developers, here's
an example of a C# script.

00:18:16.470 --> 00:18:20.330
And there's something called
application low memory

00:18:20.330 --> 00:18:24.020
events in Unity,
and these correspond

00:18:24.020 --> 00:18:27.030
to onTrimMemory calls.

00:18:27.030 --> 00:18:29.600
So you want to
subscribe to this event,

00:18:29.600 --> 00:18:31.550
and then have a
callback that gets

00:18:31.550 --> 00:18:34.980
called when this event happens.

00:18:34.980 --> 00:18:38.950
So Unity does have this resource
unload call which you can make.

00:18:38.950 --> 00:18:41.930
That's one possible
thing you can do

00:18:41.930 --> 00:18:44.250
to reduce the memory pressure.

00:18:46.980 --> 00:18:50.390
So another thing that
games should do--

00:18:50.390 --> 00:18:53.070
and most games do
this, typically--

00:18:53.070 --> 00:18:57.550
is just to be conservative
about their memory budgets.

00:18:57.550 --> 00:18:59.580
What things should you consider?

00:18:59.580 --> 00:19:04.500
Well, you should take into
account the physical RAM size.

00:19:04.500 --> 00:19:07.770
And also, you want to look
at how much, typically,

00:19:07.770 --> 00:19:11.430
does the operating system
and system processes use.

00:19:11.430 --> 00:19:14.250
In this case, it's about
one and half gigabytes,

00:19:14.250 --> 00:19:17.880
and it's on a four
gigabyte device.

00:19:17.880 --> 00:19:19.570
These can vary over time.

00:19:19.570 --> 00:19:22.350
So remember, I was
saying, you don't have

00:19:22.350 --> 00:19:23.650
definite amounts for these.

00:19:23.650 --> 00:19:27.380
So that's where you
want to be conservative.

00:19:27.380 --> 00:19:31.510
And you also want to look at
the maximum amount of zRAM size.

00:19:31.510 --> 00:19:34.830
So as I mentioned,
zRAM is something--

00:19:34.830 --> 00:19:36.780
it's used as
compressed memory, it's

00:19:36.780 --> 00:19:39.270
used for swapping
when memory gets low.

00:19:39.270 --> 00:19:42.397
So the more zRAM
that you can have,

00:19:42.397 --> 00:19:44.730
the better your device will
be able to handle low memory

00:19:44.730 --> 00:19:46.150
situations.

00:19:46.150 --> 00:19:48.630
How do you tell how
much zRAM you have?

00:19:48.630 --> 00:19:52.960
Well if you look in
the proc meminfo file,

00:19:52.960 --> 00:19:56.250
you can see the swap
total is shown here,

00:19:56.250 --> 00:20:00.190
and that's the max amount of
zRAM your device can have.

00:20:00.190 --> 00:20:04.660
So in this case, it's
about a gigabyte.

00:20:04.660 --> 00:20:06.330
If we look at some
typical games--

00:20:06.330 --> 00:20:09.720
this is kind of a random
sampling of games--

00:20:09.720 --> 00:20:13.680
on a four gigabyte
device, the most

00:20:13.680 --> 00:20:16.290
that these games allocate--

00:20:16.290 --> 00:20:18.540
these are peak memory usage--

00:20:18.540 --> 00:20:21.460
is only about 1.23 gigabytes.

00:20:21.460 --> 00:20:26.300
So they're really not pushing
the amount of physical memory

00:20:26.300 --> 00:20:28.260
up to the limit of
physical memory very much.

00:20:31.100 --> 00:20:34.150
Now if you can't be
really conservative,

00:20:34.150 --> 00:20:37.510
the other thing is you
should be flexible.

00:20:37.510 --> 00:20:40.870
So this means you need to be
more dynamic with the memory,

00:20:40.870 --> 00:20:42.773
instead of fixed.

00:20:42.773 --> 00:20:44.190
Of course, this
means you're going

00:20:44.190 --> 00:20:48.990
to need to respond to
those onTrimMemory calls.

00:20:48.990 --> 00:20:53.160
And because you're now taking
into account low memory

00:20:53.160 --> 00:20:57.070
situations, and hitting
up against that limit,

00:20:57.070 --> 00:20:59.490
you need to do more
game memory management,

00:20:59.490 --> 00:21:01.830
and really design
your game to have

00:21:01.830 --> 00:21:03.230
a variable amount of memory.

00:21:06.640 --> 00:21:09.030
Now, crashing when
you run out of memory

00:21:09.030 --> 00:21:10.810
isn't the only thing
that can happen.

00:21:10.810 --> 00:21:13.830
So at some point, when
you have lots of memory

00:21:13.830 --> 00:21:16.440
and everything's working
fine, and the point when

00:21:16.440 --> 00:21:19.230
you crash because you've
run out of memory,

00:21:19.230 --> 00:21:21.090
you could hit thrashing.

00:21:21.090 --> 00:21:26.340
And thrashing is when you
have just continuous swapping.

00:21:26.340 --> 00:21:29.940
The main symptom of it is
you have very long delays.

00:21:29.940 --> 00:21:32.920
Frames could take
seconds to execute.

00:21:32.920 --> 00:21:36.180
And then, basically, the only
thing you can do about that

00:21:36.180 --> 00:21:39.120
is reduce the working
set of your game,

00:21:39.120 --> 00:21:40.960
reduce the memory
footprint of it.

00:21:43.960 --> 00:21:48.720
So here is an example of
how to look for thrashing.

00:21:48.720 --> 00:21:51.640
We have this tool
called Systrace.

00:21:51.640 --> 00:21:54.930
Hopefully you've used it
and have seen it before.

00:21:54.930 --> 00:21:57.780
It's part of the Android SDK.

00:21:57.780 --> 00:22:02.610
And if you notice here,
it shows processes being

00:22:02.610 --> 00:22:04.680
executed on the CPU cores.

00:22:04.680 --> 00:22:08.640
And you notice this one core
is just continuously using--

00:22:08.640 --> 00:22:10.380
executing kswapd.

00:22:10.380 --> 00:22:13.170
Kswapd, remember, is the
one that does the swapping.

00:22:13.170 --> 00:22:15.610
It reclaims memory.

00:22:15.610 --> 00:22:19.890
So when you see it active that
much, you should be suspicious.

00:22:19.890 --> 00:22:23.973
The other thing to look
for is your processes

00:22:23.973 --> 00:22:25.890
are getting into a state
where they're blocked

00:22:25.890 --> 00:22:29.040
on I/O, because these pages--

00:22:29.040 --> 00:22:30.270
remember, these memory back--

00:22:30.270 --> 00:22:33.310
storage back pages
have been deleted.

00:22:33.310 --> 00:22:35.610
So it needs to-- they
need to read them back

00:22:35.610 --> 00:22:39.900
into memory when executing.

00:22:39.900 --> 00:22:40.450
All right.

00:22:40.450 --> 00:22:47.140
Another tip-- don't
allocate too much too fast.

00:22:47.140 --> 00:22:49.750
So the speed of
allocations can actually

00:22:49.750 --> 00:22:52.660
matter when you get into
really sensitive low memory

00:22:52.660 --> 00:22:55.550
situations.

00:22:55.550 --> 00:22:57.640
As I mentioned, reclaiming
memory takes time.

00:22:57.640 --> 00:22:59.680
So you don't want
your allocations

00:22:59.680 --> 00:23:04.340
to outpace how fast
you can reclaim memory.

00:23:04.340 --> 00:23:07.130
And the result of this,
the game gets killed--

00:23:07.130 --> 00:23:09.470
gets killed, potentially,
sooner than it really

00:23:09.470 --> 00:23:10.350
needs to get killed.

00:23:13.770 --> 00:23:17.130
Now I'm going to talk
about some of the tools

00:23:17.130 --> 00:23:24.000
that we have for debugging and
for profiling native memory.

00:23:24.000 --> 00:23:26.880
And I use the term native
here, of course, because we're

00:23:26.880 --> 00:23:28.380
talking about games.

00:23:28.380 --> 00:23:31.710
And this is memory
that's allocated by C++,

00:23:31.710 --> 00:23:35.210
as opposed to like
the Java heap.

00:23:35.210 --> 00:23:39.560
So one of the tools you can use
is a kind of a class of tools--

00:23:39.560 --> 00:23:40.480
Meminfo.

00:23:40.480 --> 00:23:43.570
And these are just
memory statistics.

00:23:43.570 --> 00:23:48.550
So they include things like
adb shell dumpsys meminfo.

00:23:48.550 --> 00:23:52.660
And that gives you some
statistics on memory.

00:23:52.660 --> 00:23:54.970
And similarly, there's
something called

00:23:54.970 --> 00:23:57.610
Debug.Memoryinfo,
which gives you

00:23:57.610 --> 00:24:01.030
basically the same information.

00:24:01.030 --> 00:24:03.640
Problem is, it's slow.

00:24:03.640 --> 00:24:05.320
And the reason why
is it's collecting

00:24:05.320 --> 00:24:09.490
what's called PSS storage.

00:24:09.490 --> 00:24:14.500
And another problem is
it's not always consistent.

00:24:14.500 --> 00:24:19.040
It gathers information,
say, of graphics memory.

00:24:19.040 --> 00:24:23.580
And graphics memory is
collected by the GPU driver,

00:24:23.580 --> 00:24:25.040
which is something
Android really

00:24:25.040 --> 00:24:26.720
doesn't have control over.

00:24:26.720 --> 00:24:31.790
And it differs-- it's different
with different GPU vendors.

00:24:31.790 --> 00:24:35.120
They may be reporting memory
differently than another vendor

00:24:35.120 --> 00:24:38.090
does, or they may even be
reporting a different depending

00:24:38.090 --> 00:24:39.400
on the version of the driver.

00:24:42.340 --> 00:24:46.810
So here's an example of what you
would see with dumpsys meminfo.

00:24:46.810 --> 00:24:48.310
Obviously, it shows
the Java heap,

00:24:48.310 --> 00:24:51.550
which usually isn't
a big part of a game,

00:24:51.550 --> 00:24:53.560
because it uses native memory.

00:24:53.560 --> 00:24:55.300
The native heap
is probably where

00:24:55.300 --> 00:24:58.490
most of your memory allocations
are going to be coming from.

00:24:58.490 --> 00:25:01.180
And also, the graphics
memory, because games

00:25:01.180 --> 00:25:04.600
do a lot of graphics.

00:25:04.600 --> 00:25:06.490
And it gives you the total here.

00:25:06.490 --> 00:25:11.980
And I mentioned before, it's
slow because it's using PSS.

00:25:11.980 --> 00:25:16.060
The other type of
memory is called RSS.

00:25:16.060 --> 00:25:20.200
So what's the difference
between PSS and RSS?

00:25:20.200 --> 00:25:23.870
So PSS is Proportional Set Size.

00:25:23.870 --> 00:25:28.330
So it includes the private
memory that your game is using,

00:25:28.330 --> 00:25:31.370
and it also includes
the shared memory.

00:25:31.370 --> 00:25:35.050
So if different processes are
sharing some of that memory

00:25:35.050 --> 00:25:37.300
that you're using,
it'll include that.

00:25:37.300 --> 00:25:40.030
But it'll measure
it proportionally,

00:25:40.030 --> 00:25:44.440
based on how many processes
are sharing that memory.

00:25:44.440 --> 00:25:46.450
RSS is much simpler.

00:25:46.450 --> 00:25:51.820
It's just the total pages
that your game is using.

00:25:51.820 --> 00:25:55.810
We think that RSS is probably
more useful for games.

00:25:55.810 --> 00:25:57.640
One of the reasons
is it's much easier

00:25:57.640 --> 00:25:59.080
to collect that information.

00:25:59.080 --> 00:26:00.970
It's faster.

00:26:00.970 --> 00:26:02.590
The other reason is
it just gives you

00:26:02.590 --> 00:26:05.770
all of the memory
that you're using.

00:26:05.770 --> 00:26:09.610
Here's an example of how
those get calculated.

00:26:09.610 --> 00:26:13.210
This game here has five pages.

00:26:13.210 --> 00:26:15.880
Three of them are
private, just to the game,

00:26:15.880 --> 00:26:18.190
and then to the
pages in yellow here

00:26:18.190 --> 00:26:20.900
are shared with other processes.

00:26:20.900 --> 00:26:24.220
So if we wanted
to calculate PSS,

00:26:24.220 --> 00:26:27.130
we would take the
private pages, our three,

00:26:27.130 --> 00:26:30.620
and then we have one page
shared between two processes.

00:26:30.620 --> 00:26:32.110
So that's one half.

00:26:32.110 --> 00:26:34.150
And then one process
that's shared--

00:26:34.150 --> 00:26:37.510
sorry, one page that's shared
between three processes.

00:26:37.510 --> 00:26:39.730
So that's one third.

00:26:39.730 --> 00:26:41.740
Then you multiply it
all times the page size,

00:26:41.740 --> 00:26:44.260
and that gives you the
total amount of PSS.

00:26:44.260 --> 00:26:46.540
Now RSS, as I
said, much simpler.

00:26:46.540 --> 00:26:49.060
We have five pages, and
then just multiply times

00:26:49.060 --> 00:26:49.880
the page size.

00:26:52.940 --> 00:26:55.270
Now one of the new
things we've added in Q--

00:26:55.270 --> 00:26:56.840
this is, I think,
really going to be

00:26:56.840 --> 00:26:59.930
useful for people who want
to trace memory, or track

00:26:59.930 --> 00:27:01.970
their memory--

00:27:01.970 --> 00:27:03.890
is RSS trace points.

00:27:03.890 --> 00:27:06.830
And I mentioned
RSS is much faster

00:27:06.830 --> 00:27:10.880
to collect than PSS memory, so
you don't have these delays.

00:27:10.880 --> 00:27:13.080
And because you don't
have these delays,

00:27:13.080 --> 00:27:17.090
you're not going to miss those
peaks where the memory might

00:27:17.090 --> 00:27:18.655
reach a peak and then go down.

00:27:18.655 --> 00:27:20.030
But you might miss
it, because it

00:27:20.030 --> 00:27:24.410
takes so long to collect
that PSS information.

00:27:24.410 --> 00:27:29.240
And it's great for this
new tool called Perfetto.

00:27:29.240 --> 00:27:30.770
What is Perfetto?

00:27:30.770 --> 00:27:33.590
Well, if you haven't
heard of Perfetto,

00:27:33.590 --> 00:27:38.450
it's a new tool that actually
resides on the device.

00:27:38.450 --> 00:27:40.680
And it collects
information on the device.

00:27:40.680 --> 00:27:42.690
It can do things
like heap profiling,

00:27:42.690 --> 00:27:44.120
which I'll show later.

00:27:44.120 --> 00:27:46.730
And the really, really
interesting thing,

00:27:46.730 --> 00:27:51.350
I think, for games particularly,
is it can collect arbitrarily

00:27:51.350 --> 00:27:53.280
long traces.

00:27:53.280 --> 00:27:56.330
So this means that
you can run your game

00:27:56.330 --> 00:27:59.330
through an entire
level and be collecting

00:27:59.330 --> 00:28:01.400
all of this trace information.

00:28:01.400 --> 00:28:04.960
You can see how
your memory changes

00:28:04.960 --> 00:28:10.810
with very high detail over the
entire length of that session

00:28:10.810 --> 00:28:13.070
that you're collecting.

00:28:13.070 --> 00:28:15.560
Some of the other things
it can do, it has offline.

00:28:15.560 --> 00:28:20.120
You can do offline processing,
because it has an SQL query

00:28:20.120 --> 00:28:22.370
that you can do on the data.

00:28:22.370 --> 00:28:24.380
And you can collect an
information yourself,

00:28:24.380 --> 00:28:26.630
and do your own analysis of it.

00:28:26.630 --> 00:28:30.500
Also, it has a new UI,
similar to Systrace,

00:28:30.500 --> 00:28:32.510
called Perfetto UI.

00:28:32.510 --> 00:28:35.900
So to enable it on your device
in the developer settings,

00:28:35.900 --> 00:28:41.240
go to System Tracing, and make
sure you enable Perfetto here.

00:28:41.240 --> 00:28:44.450
You also want to
enable long traces,

00:28:44.450 --> 00:28:47.330
and also trace
debugable applications.

00:28:47.330 --> 00:28:54.050
Then go to the categories
section and make sure memory

00:28:54.050 --> 00:28:56.720
is checked, because if
you're collecting memory,

00:28:56.720 --> 00:28:59.930
you want to make
sure that's checked.

00:28:59.930 --> 00:29:04.510
Then you just hit record
trace, and it starts tracing.

00:29:04.510 --> 00:29:07.120
And you'll get
this notification.

00:29:07.120 --> 00:29:11.710
And when you're done tracing,
just tap the notification.

00:29:11.710 --> 00:29:18.070
Here's an example of Perfetto
UI for tracing memory.

00:29:18.070 --> 00:29:21.850
And you can see how it collects
this memory information

00:29:21.850 --> 00:29:25.600
about anonymous memory and
various types of RSS memory

00:29:25.600 --> 00:29:26.535
over time.

00:29:26.535 --> 00:29:28.660
So you can see how the
memory is growing over time.

00:29:34.290 --> 00:29:38.630
So now that we have
these tools to collect

00:29:38.630 --> 00:29:41.930
all of this information, I
want you to remember back

00:29:41.930 --> 00:29:45.050
when I talked about
this test app,

00:29:45.050 --> 00:29:50.570
and why does it-- why is it
able to allocate 4.1 gigabytes?

00:29:50.570 --> 00:29:55.040
So let's look at
it with Perfetto.

00:29:55.040 --> 00:29:57.960
If you look at the
memory over time--

00:29:57.960 --> 00:30:02.480
and this is more towards
the end of the allocations--

00:30:02.480 --> 00:30:06.740
we can see how the anonymous
memory, the malloc memory,

00:30:06.740 --> 00:30:07.820
starts to flatten out.

00:30:07.820 --> 00:30:10.380
That's the part on the top here.

00:30:10.380 --> 00:30:15.680
However, the swap memory
continues to go up.

00:30:15.680 --> 00:30:18.380
Now remember, swap
is stored in zRAM,

00:30:18.380 --> 00:30:21.050
and zRAM is compressed memory.

00:30:21.050 --> 00:30:23.430
So all of this
memory is compressed.

00:30:23.430 --> 00:30:25.910
So even though it
says 4.2 gigabytes,

00:30:25.910 --> 00:30:28.110
that 1.7 is all
compressed memory.

00:30:28.110 --> 00:30:29.480
So it takes up less space.

00:30:33.710 --> 00:30:36.310
So here's this app running.

00:30:36.310 --> 00:30:38.560
You can see as I'm tapping
here in the bottom,

00:30:38.560 --> 00:30:40.500
the memory keeps going up.

00:30:40.500 --> 00:30:44.290
And I want you to notice here as
we get around to two gigabytes,

00:30:44.290 --> 00:30:46.240
we get our first
onTrimMemory warning.

00:30:46.240 --> 00:30:48.580
It says it's running low.

00:30:48.580 --> 00:30:52.000
We keep allocating memory,
and at three gigabytes,

00:30:52.000 --> 00:30:53.440
it gets critical.

00:30:53.440 --> 00:30:56.110
I start to slow
down on the tapping

00:30:56.110 --> 00:31:01.120
to allocate slower, and notice
now we can hit 4.1 gigabytes.

00:31:01.120 --> 00:31:03.460
So it really does work.

00:31:03.460 --> 00:31:06.400
Once again, I don't recommend
allocating that much memory.

00:31:06.400 --> 00:31:07.900
More than likely,
you're going start

00:31:07.900 --> 00:31:12.320
thrashing when you get
to that much memory.

00:31:12.320 --> 00:31:15.070
So the other tool I wanted to
mention here-- another tool

00:31:15.070 --> 00:31:19.360
is Heapprofd, and this
is also part of Perfetto.

00:31:19.360 --> 00:31:22.000
It's used for memory
tracking, memory debugging,

00:31:22.000 --> 00:31:23.950
finding memory leaks.

00:31:23.950 --> 00:31:26.380
It's much easier to
use than Malloc Debug.

00:31:26.380 --> 00:31:28.040
You basically just run a script.

00:31:28.040 --> 00:31:32.440
You don't have to instrument
your game, so very easy to use.

00:31:32.440 --> 00:31:35.960
And the other nice feature about
it, it has very low overhead.

00:31:35.960 --> 00:31:38.140
So you can run your
game much faster.

00:31:38.140 --> 00:31:41.425
It doesn't get slowed down
like it does with Malloc Debug.

00:31:44.320 --> 00:31:48.340
Here's an example of some
output from Heapprofd.

00:31:48.340 --> 00:31:51.820
If I zoom in here,
hopefully you can see this.

00:31:51.820 --> 00:31:57.370
Every line here is an allocation
that hasn't been freed yet.

00:31:57.370 --> 00:31:59.710
And it shows the
function associated

00:31:59.710 --> 00:32:02.850
with that memory allocation.

00:32:02.850 --> 00:32:06.290
So if you see some memory
here that's still allocated,

00:32:06.290 --> 00:32:08.440
that's not free,
where you expected

00:32:08.440 --> 00:32:11.400
it to be free, that would be
an indication of a memory leak.

00:32:14.520 --> 00:32:18.000
Another tool that's
often overall overlooked

00:32:18.000 --> 00:32:19.920
is Bugreport.

00:32:19.920 --> 00:32:24.690
Now, when I say Bugreport,
I don't mean making a report

00:32:24.690 --> 00:32:26.920
and sending it to us as a bug.

00:32:26.920 --> 00:32:29.430
What I'm talking
about is the tool

00:32:29.430 --> 00:32:32.880
that collects log information.

00:32:32.880 --> 00:32:35.250
It's similar to something
like adb logcat,

00:32:35.250 --> 00:32:37.860
only it's much more detailed.

00:32:37.860 --> 00:32:39.360
And the really
good thing about it

00:32:39.360 --> 00:32:43.740
is it shows low memory
killer activity.

00:32:43.740 --> 00:32:45.150
The other nice thing about it--

00:32:45.150 --> 00:32:48.360
it can be captured
after a crash happens.

00:32:48.360 --> 00:32:51.600
So you don't need to
instrument your game

00:32:51.600 --> 00:32:55.050
and expect when a crash
is going to happen.

00:32:55.050 --> 00:32:57.510
If a crash happens, and
you just noticed it,

00:32:57.510 --> 00:33:01.005
you then just take a bug report.

00:33:01.005 --> 00:33:02.880
So to capture a bug
report, you'll once again

00:33:02.880 --> 00:33:04.500
go into the developer options.

00:33:04.500 --> 00:33:07.930
And you tap on this
Take Bug Report.

00:33:07.930 --> 00:33:10.950
And in a couple of
minutes, this notification

00:33:10.950 --> 00:33:14.220
will come up telling you that
a bug report has been captured.

00:33:14.220 --> 00:33:17.610
And you can tap on it and
then share it with yourself.

00:33:17.610 --> 00:33:20.370
Another way to do
this is to just call--

00:33:20.370 --> 00:33:22.800
or just run adb bugreport.

00:33:22.800 --> 00:33:27.220
And you can get the
information that way.

00:33:27.220 --> 00:33:32.440
Here's an example of
a bug report log file.

00:33:32.440 --> 00:33:36.360
And if we're looking
for memory killing,

00:33:36.360 --> 00:33:40.110
we can search for this low
memory killer kill, and then

00:33:40.110 --> 00:33:43.890
your package name, to see
if your game was killed.

00:33:43.890 --> 00:33:46.410
And if you can see this,
there's a whole bunch

00:33:46.410 --> 00:33:49.290
of low memory killer
activity going on here,

00:33:49.290 --> 00:33:51.150
because we're running
low on memory,

00:33:51.150 --> 00:33:53.040
and it's killing
those processes that

00:33:53.040 --> 00:33:55.850
aren't needed so it can free
up memory for your game.

00:34:00.600 --> 00:34:04.280
So in this instance,
yes, the game, the app,

00:34:04.280 --> 00:34:06.560
was killed by low memory killer.

00:34:06.560 --> 00:34:10.909
So in case your game is crashing
for some unknown reason,

00:34:10.909 --> 00:34:13.460
this will let you
know it was killed

00:34:13.460 --> 00:34:14.750
because it ran low on memory.

00:34:17.940 --> 00:34:21.710
So just to summarize
here, some things I think

00:34:21.710 --> 00:34:23.780
are good to remember.

00:34:23.780 --> 00:34:27.199
Android, unfortunately,
has no guarantees

00:34:27.199 --> 00:34:31.929
for the amount of available
memory that you have.

00:34:31.929 --> 00:34:35.600
The things to look out for
are, obviously, crashing.

00:34:35.600 --> 00:34:36.830
That's the really bad one.

00:34:36.830 --> 00:34:39.210
And then, also,
thrashing can happen.

00:34:39.210 --> 00:34:44.060
And that really is
bad for performance.

00:34:44.060 --> 00:34:47.420
And I have mentioned some
of the new tools in Q.

00:34:47.420 --> 00:34:51.949
And hopefully you can use them
to find out what's going on,

00:34:51.949 --> 00:34:55.909
and prevent these bad things
from happening in low memory

00:34:55.909 --> 00:34:58.590
situations.

00:34:58.590 --> 00:35:03.170
And finally, I'm hoping
that now that you understand

00:35:03.170 --> 00:35:04.880
how Android memory
works, you can

00:35:04.880 --> 00:35:07.870
put this to use in your game.

00:35:10.640 --> 00:35:13.380
Also, I want to remind people
that we're doing game reviews.

00:35:13.380 --> 00:35:17.150
So if you have a game
you'd like us to review,

00:35:17.150 --> 00:35:19.820
you can go back here
in the garage section

00:35:19.820 --> 00:35:23.760
to have us look at your game.

00:35:23.760 --> 00:35:24.620
And that's it.

00:35:24.620 --> 00:35:27.600
And I have some links here.

00:35:27.600 --> 00:35:30.020
In particular, you might be
interested in the Perfetto

00:35:30.020 --> 00:35:30.590
link.

00:35:30.590 --> 00:35:33.500
It's just perfetto.dev.

00:35:33.500 --> 00:35:35.460
Pretty easy link here.

00:35:35.460 --> 00:35:38.210
And also, in that
Perfetto documentation

00:35:38.210 --> 00:35:42.380
is some description
of Heapprofd.

00:35:42.380 --> 00:35:44.060
So that's it.

00:35:44.060 --> 00:35:44.570
Thank you.

00:35:44.570 --> 00:35:46.970
[APPLAUSE]

00:35:46.970 --> 00:35:54.220
[MUSIC PLAYING]

