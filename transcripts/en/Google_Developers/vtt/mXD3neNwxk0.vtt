WEBVTT
Kind: captions
Language: en

00:00:08.262 --> 00:00:09.520
ROBERT PUFKY: I'm Robert.

00:00:09.520 --> 00:00:11.800
And today I have with
me Zach and James.

00:00:11.800 --> 00:00:14.390
And today we're going to talk
about cloud support and how we

00:00:14.390 --> 00:00:18.530
moved our internal support
stack into the cloud.

00:00:18.530 --> 00:00:20.760
Now I actually want to talk to
you guys first and say, how

00:00:20.760 --> 00:00:22.770
many of you guys have run
traditional IT stacks in the

00:00:22.770 --> 00:00:24.380
past or are running
them currently?

00:00:24.380 --> 00:00:26.330
Just a show of hands.

00:00:26.330 --> 00:00:27.510
Wow, OK, a lot of people.

00:00:27.510 --> 00:00:32.070
So our experience in moving our
stack to the cloud should

00:00:32.070 --> 00:00:33.410
be pretty relative to you.

00:00:33.410 --> 00:00:35.490
And for you guys that are
already running on App Engine

00:00:35.490 --> 00:00:38.130
or are already running on cloud,
maybe you'll get some

00:00:38.130 --> 00:00:41.710
good tips and tricks about
developing on App Engine.

00:00:41.710 --> 00:00:44.020
So before we talk about this,
I want to talk a little bit

00:00:44.020 --> 00:00:46.390
about the background of support
at Google and kind of

00:00:46.390 --> 00:00:48.430
talk about how we do things.

00:00:48.430 --> 00:00:51.770
So we can talk about the problem
analysis of where we

00:00:51.770 --> 00:00:54.950
were before, the applications
that we developed, and where

00:00:54.950 --> 00:00:57.570
we ended up.

00:00:57.570 --> 00:00:59.970
So the first thing I'm going
to talk about is Techstops.

00:00:59.970 --> 00:01:02.830
And Techstops are really a
central point at Google in a

00:01:02.830 --> 00:01:05.800
lot of the offices where anyone
can go at any time for

00:01:05.800 --> 00:01:07.340
help with any kind of problem.

00:01:07.340 --> 00:01:08.470
It could be a technical issue.

00:01:08.470 --> 00:01:09.360
It could be software.

00:01:09.360 --> 00:01:10.660
It could be hardware issues.

00:01:10.660 --> 00:01:12.240
It could really be anything.

00:01:12.240 --> 00:01:14.960
And what you expect to find here
is you come in, and you

00:01:14.960 --> 00:01:19.940
have fun and friendly techs that
can answer your questions

00:01:19.940 --> 00:01:21.940
quickly and get you on your
way and make you be more

00:01:21.940 --> 00:01:23.100
productive.

00:01:23.100 --> 00:01:24.940
These techs are actually
called field techs.

00:01:24.940 --> 00:01:30.070
And in smaller offices, they
equate to something like an IT

00:01:30.070 --> 00:01:32.480
site director or something like
that because they also do

00:01:32.480 --> 00:01:35.030
a lot of the site work
at smaller offices.

00:01:38.050 --> 00:01:40.450
We also have a program called
the ITR program, or the

00:01:40.450 --> 00:01:43.490
Internal Technology Residency
program, which is a two year

00:01:43.490 --> 00:01:47.090
program where we pull students
from colleges that have just

00:01:47.090 --> 00:01:48.410
recently graduated.

00:01:48.410 --> 00:01:50.910
We put them through a two-year
process where we show them how

00:01:50.910 --> 00:01:52.440
Google does IT.

00:01:52.440 --> 00:01:56.270
And we put them on
an ops rotation.

00:01:56.270 --> 00:01:58.240
An ops rotation is like a
three-month rotation with an

00:01:58.240 --> 00:02:01.220
operations team where they
can go and learn what

00:02:01.220 --> 00:02:03.270
operations teams do.

00:02:03.270 --> 00:02:05.740
My team is the Support
Engineering Development team.

00:02:05.740 --> 00:02:08.590
And both Zach and James did
ops rotations with me.

00:02:08.590 --> 00:02:11.080
Additionally, they do office
rotations, where they go and

00:02:11.080 --> 00:02:13.500
work for three months in another
office and get an idea

00:02:13.500 --> 00:02:16.680
of what all our offices
are like.

00:02:16.680 --> 00:02:20.550
Now to get back to the support
at Google, really, our core

00:02:20.550 --> 00:02:24.660
goal in Google in support is
to make sure that users'

00:02:24.660 --> 00:02:27.600
problem are fixed the first
time, they're fixed quickly,

00:02:27.600 --> 00:02:29.280
and they're happy
and productive.

00:02:29.280 --> 00:02:30.270
And this is really key.

00:02:30.270 --> 00:02:33.240
It leads to a lot of really
high customer

00:02:33.240 --> 00:02:34.140
satisfaction scores.

00:02:34.140 --> 00:02:35.410
But that's not really what
we're focusing on.

00:02:35.410 --> 00:02:41.010
We're focusing on users being
really productive. .

00:02:41.010 --> 00:02:43.600
And that's where we get into
this conversation we're going

00:02:43.600 --> 00:02:44.570
to talk about today.

00:02:44.570 --> 00:02:46.990
And it's our frustration with
the traditional IT stacks that

00:02:46.990 --> 00:02:48.290
we were running before.

00:02:48.290 --> 00:02:49.840
And these are great, actually.

00:02:49.840 --> 00:02:52.070
A lot of IT professionals
come in.

00:02:52.070 --> 00:02:54.560
They've written applications
on these stacks before.

00:02:54.560 --> 00:02:57.510
They write quick applications
here and there, even build up

00:02:57.510 --> 00:02:59.855
some large-scale applications.

00:02:59.855 --> 00:03:01.820
And that's great.

00:03:01.820 --> 00:03:05.210
But we've found some
problems with it.

00:03:05.210 --> 00:03:08.730
We actually experienced a lot
of application development,

00:03:08.730 --> 00:03:11.300
and then we had to scale
it to meet our demands.

00:03:11.300 --> 00:03:14.620
We have offices all over the
world, on every continent

00:03:14.620 --> 00:03:16.050
except for Antarctica.

00:03:16.050 --> 00:03:18.070
So when we launched an
application, we literally had

00:03:18.070 --> 00:03:20.960
to make sure that everyone in
the world could use it when we

00:03:20.960 --> 00:03:21.870
launched it.

00:03:21.870 --> 00:03:24.180
And with traditional IT stacks,
we really got to focus

00:03:24.180 --> 00:03:27.450
on not only the application
development but how we can

00:03:27.450 --> 00:03:29.750
scale that to the world.

00:03:29.750 --> 00:03:30.920
And this was a really
big problem.

00:03:30.920 --> 00:03:34.290
Because our team is generally
small, we didn't have DBAs and

00:03:34.290 --> 00:03:35.500
sysops and SREs.

00:03:35.500 --> 00:03:38.140
SREs are Site Reliability
Engineers, essentially keep

00:03:38.140 --> 00:03:39.580
stuff up and running.

00:03:39.580 --> 00:03:44.360
And we came to an injunction
where we wanted to say, should

00:03:44.360 --> 00:03:47.400
we actually go and hire these
people to help scale this

00:03:47.400 --> 00:03:48.250
infrastructure for us?

00:03:48.250 --> 00:03:51.170
Or should we actually take a
look at the core problems in

00:03:51.170 --> 00:03:53.660
the group and see if we can come
up with a different way,

00:03:53.660 --> 00:03:55.150
a better way to solve
these issues?

00:03:57.690 --> 00:04:00.240
So what we did is we went in,
and we did a problem analysis

00:04:00.240 --> 00:04:00.610
on our group.

00:04:00.610 --> 00:04:03.290
And we tried to figure out
what was wrong in our

00:04:03.290 --> 00:04:05.290
development group as well as
what was wrong in the support

00:04:05.290 --> 00:04:08.910
organization and how
we could fix this.

00:04:08.910 --> 00:04:11.710
So we pondered on these
issues a little bit.

00:04:11.710 --> 00:04:13.980
And we found the first thing,
and probably the biggest

00:04:13.980 --> 00:04:17.120
thing, is that we found that
maintenance versus innovation

00:04:17.120 --> 00:04:18.110
was a huge issue.

00:04:18.110 --> 00:04:20.640
We were spending a lot of
our time scaling our

00:04:20.640 --> 00:04:22.690
infrastructure, keeping
it up and running.

00:04:22.690 --> 00:04:26.130
Spending a lot of time just
making sure it was running as

00:04:26.130 --> 00:04:28.570
opposed to innovating in our
space and really fixing the

00:04:28.570 --> 00:04:33.700
core issues that our team
was there to solve.

00:04:33.700 --> 00:04:37.130
We also found that a lack
of tech information, or

00:04:37.130 --> 00:04:41.200
information presented to techs
in the Techstops, led to a lot

00:04:41.200 --> 00:04:43.250
more escalations in
pages and bugs.

00:04:43.250 --> 00:04:46.900
And what that really meant is
that the end user was not

00:04:46.900 --> 00:04:49.580
getting their problem fixed
as fast as possible.

00:04:49.580 --> 00:04:51.290
So we wanted to make sure that
our techs were getting the

00:04:51.290 --> 00:04:53.800
information that they needed so
they could be empowered to

00:04:53.800 --> 00:04:55.270
make the right decisions
and get people

00:04:55.270 --> 00:04:56.520
on their way faster.

00:04:59.260 --> 00:05:00.690
We also looked at the approvals

00:05:00.690 --> 00:05:02.430
and how we did approvals.

00:05:02.430 --> 00:05:06.630
We found that if a tech is
fixing a user's computer, and

00:05:06.630 --> 00:05:10.090
their hardware is busted, why
should they wait for a manager

00:05:10.090 --> 00:05:12.430
two levels away to approve
a hardware swap?

00:05:12.430 --> 00:05:15.150
Why can't the tech just make
the determination that the

00:05:15.150 --> 00:05:17.760
hardware's busted
and swap it out?

00:05:17.760 --> 00:05:20.370
What if the tech is working at
a Techstop, and the location

00:05:20.370 --> 00:05:22.220
has changed, or the phone
number has changed?

00:05:22.220 --> 00:05:25.210
Why should they go through an
approval mechanism to get

00:05:25.210 --> 00:05:26.390
those changes made?

00:05:26.390 --> 00:05:27.780
Why can't they just go and
make these changes

00:05:27.780 --> 00:05:29.030
immediately?

00:05:30.820 --> 00:05:34.300
We also looked at the automation
for our group.

00:05:34.300 --> 00:05:36.510
And what we really wanted to get
done here is to remove a

00:05:36.510 --> 00:05:39.740
lot of the mundane task work
from the Techstops so they can

00:05:39.740 --> 00:05:42.670
focus on interesting problems.

00:05:42.670 --> 00:05:46.820
We did a little bit of this with
traditional IT stacks.

00:05:46.820 --> 00:05:49.080
But we really wanted to do this
automation work and then

00:05:49.080 --> 00:05:50.620
not have to think about
it and keep it up and

00:05:50.620 --> 00:05:53.990
running later on.

00:05:53.990 --> 00:05:56.500
We also looked in the
self-service.

00:05:56.500 --> 00:05:59.700
Now if a Googler takes an
average of 5 to 10 minutes to

00:05:59.700 --> 00:06:02.550
walk to a Techstops, that means
that there's 10 to 20

00:06:02.550 --> 00:06:06.230
minutes of that Googler's day
just lost just walking to the

00:06:06.230 --> 00:06:08.660
Techstop without actually even
getting their problem fixed.

00:06:08.660 --> 00:06:11.920
So what we wanted to take a look
at is if we could provide

00:06:11.920 --> 00:06:14.210
information to our end users
so they can fix their own

00:06:14.210 --> 00:06:17.050
problems, maybe in two or three
minutes, as opposed to

00:06:17.050 --> 00:06:19.980
spending all that time walking
to and from the Techstop.

00:06:19.980 --> 00:06:22.800
And again, this is something
that we need to do at a global

00:06:22.800 --> 00:06:25.390
scale so that when we launch
an application or a

00:06:25.390 --> 00:06:29.990
self-service application,
everyone can use it.

00:06:29.990 --> 00:06:31.175
The last thing was slow
applications.

00:06:31.175 --> 00:06:33.360
And again, we've, touched on
this before, so I'm not going

00:06:33.360 --> 00:06:34.460
to hammer away at this.

00:06:34.460 --> 00:06:37.890
But this is really scaling
applications and making sure

00:06:37.890 --> 00:06:40.920
they're fast and responsive to
people that are using them.

00:06:43.910 --> 00:06:47.530
The last thing we looked at, and
I'll give you a minute to

00:06:47.530 --> 00:06:51.880
look at this graph, is our
application history and what

00:06:51.880 --> 00:06:53.440
it was like from inception
'til death.

00:06:58.480 --> 00:07:00.000
And what you'll see here
is a histogram.

00:07:00.000 --> 00:07:02.590
And this is basically a
histogram of the applications

00:07:02.590 --> 00:07:04.930
that we developed over time.

00:07:04.930 --> 00:07:07.230
And what we did was we put a
trend line over this data.

00:07:07.230 --> 00:07:09.850
And we found that there's
actually a really nice normal

00:07:09.850 --> 00:07:13.060
or bell curve about the average
lifespan of our

00:07:13.060 --> 00:07:14.770
applications that we
were developing.

00:07:14.770 --> 00:07:17.670
And this was a key insight to
our problem because we were

00:07:17.670 --> 00:07:19.240
fundamentally different
designing our

00:07:19.240 --> 00:07:21.230
applications wrong.

00:07:21.230 --> 00:07:23.140
We were originally aiming to
build them to be 10- to

00:07:23.140 --> 00:07:25.910
15-year applications, to
be self-healing, to be

00:07:25.910 --> 00:07:29.380
self-replicating, to fail over
to other DCs, et cetera, et

00:07:29.380 --> 00:07:32.810
cetera, DCs being
Data Centers.

00:07:32.810 --> 00:07:36.490
And it really turned out that
our application lifespan was

00:07:36.490 --> 00:07:38.120
only two to four years.

00:07:38.120 --> 00:07:41.830
So we only really wanted
to focus on getting an

00:07:41.830 --> 00:07:44.910
application out, making sure
it scaled to the world.

00:07:44.910 --> 00:07:46.230
It did what it needed to do.

00:07:46.230 --> 00:07:48.240
We could add features when we
needed to, and we could turn

00:07:48.240 --> 00:07:50.570
it down without actually needing
to work on all the

00:07:50.570 --> 00:07:53.260
maintenance stuff.

00:07:53.260 --> 00:07:55.800
We looked into why applications
were lasting only

00:07:55.800 --> 00:07:58.560
two to four years, and we came
up with a couple interesting

00:07:58.560 --> 00:08:00.030
points as well.

00:08:00.030 --> 00:08:01.950
First was technology changes.

00:08:01.950 --> 00:08:05.200
Some of our systems interacted
with tech stacks, and these

00:08:05.200 --> 00:08:06.930
tech stacks got deprecated.

00:08:06.930 --> 00:08:08.660
So therefore there was no
point in having those

00:08:08.660 --> 00:08:10.710
applications.

00:08:10.710 --> 00:08:14.530
Second, we looked at internal
process changes.

00:08:14.530 --> 00:08:16.610
We're constantly evolving,
and our internal

00:08:16.610 --> 00:08:18.880
processes change a lot.

00:08:18.880 --> 00:08:23.430
So some applications were
deprecated by processes.

00:08:23.430 --> 00:08:26.390
And the third and probably the
most important was security

00:08:26.390 --> 00:08:28.010
and scaling issues that
we were having these

00:08:28.010 --> 00:08:29.460
applications.

00:08:29.460 --> 00:08:33.360
Again, our team was just a
small team of developers.

00:08:33.360 --> 00:08:35.850
And we were having a lot
of issues scaling our

00:08:35.850 --> 00:08:37.890
applications because we needed
to get dedicated

00:08:37.890 --> 00:08:40.140
resources to do it.

00:08:40.140 --> 00:08:43.580
We also looked in the security
aspect and really found out

00:08:43.580 --> 00:08:46.260
that in traditional stacks,
you have to worry about OS

00:08:46.260 --> 00:08:49.560
security, how many users have
access to the system, the

00:08:49.560 --> 00:08:51.680
security of your serving
sack as well as the

00:08:51.680 --> 00:08:53.450
security of your code.

00:08:53.450 --> 00:08:55.483
And then what happens when a
data center fails, and you

00:08:55.483 --> 00:08:57.110
need to fail over to another
data center?

00:08:57.110 --> 00:08:59.460
We really wanted to remove all
of that from the equation and

00:08:59.460 --> 00:09:04.810
really focus on writing the
application itself.

00:09:04.810 --> 00:09:08.610
So with these problems
identified, we set forth to

00:09:08.610 --> 00:09:11.080
migrate a lot of our
applications

00:09:11.080 --> 00:09:12.605
to something better.

00:09:12.605 --> 00:09:14.990
And I'm going to introduce Zach,
who's going to talk a

00:09:14.990 --> 00:09:17.330
little bit about Techstop
information, which is one of

00:09:17.330 --> 00:09:20.560
these applications that we
developed using these problems

00:09:20.560 --> 00:09:23.890
that we identified
and helped solve.

00:09:23.890 --> 00:09:25.140
Zach?

00:09:29.430 --> 00:09:31.000
ZACH SZAFRAN: My name's
Zach Szafran.

00:09:31.000 --> 00:09:33.990
I'm an IT resident, and I work
in those Techstops that Bob

00:09:33.990 --> 00:09:35.490
was just telling you about.

00:09:35.490 --> 00:09:38.325
So recently, I had the chance
to work with Bob and some of

00:09:38.325 --> 00:09:42.080
his support engineers on their
cloud-based applications.

00:09:42.080 --> 00:09:44.950
Techstop Info is one of those
projects I got to work on.

00:09:44.950 --> 00:09:47.350
In the next couple slides, I'm
going to talk about it and how

00:09:47.350 --> 00:09:48.990
we implemented some
of its features.

00:09:51.700 --> 00:09:55.020
So originally, we had this
version-controlled YAML file.

00:09:55.020 --> 00:09:57.760
This was the authoritative
source for all of our Techstop

00:09:57.760 --> 00:09:59.480
information.

00:09:59.480 --> 00:10:01.820
Any application that needed
this type of Techstop info

00:10:01.820 --> 00:10:03.530
would actually have to sync
down their own copy

00:10:03.530 --> 00:10:05.750
of this YAML file.

00:10:05.750 --> 00:10:09.010
So if you take a minute and just
look over this example

00:10:09.010 --> 00:10:13.040
that we have here, you might
see some human errors that

00:10:13.040 --> 00:10:14.510
we've included.

00:10:14.510 --> 00:10:15.990
These are actual human
errors that you could

00:10:15.990 --> 00:10:17.780
find in our YAML file.

00:10:17.780 --> 00:10:20.950
So maybe by show of hands, does
anyone see any obvious

00:10:20.950 --> 00:10:24.150
problems with this?

00:10:24.150 --> 00:10:25.870
It's kind of hard to tell.

00:10:25.870 --> 00:10:29.240
So the first, less obvious
problem is the fact our

00:10:29.240 --> 00:10:30.880
indentation is incorrect.

00:10:30.880 --> 00:10:33.485
If we ran strict parsing across
this YAML file, it

00:10:33.485 --> 00:10:35.450
would fail.

00:10:35.450 --> 00:10:37.430
The more obvious issue
is the fact our

00:10:37.430 --> 00:10:40.350
phone number was incorrect.

00:10:40.350 --> 00:10:43.110
And things like this did make
it into our YAML file.

00:10:43.110 --> 00:10:46.250
So let's say a technician found
this phone number in our

00:10:46.250 --> 00:10:48.240
YAML file, and he wanted
to actually fix it.

00:10:48.240 --> 00:10:50.240
What kind of process would
they have to go

00:10:50.240 --> 00:10:51.490
through to get this done?

00:10:53.730 --> 00:10:56.250
So in order to make this change,
they'd have to go to

00:10:56.250 --> 00:10:58.310
our repo, find the file,
and sync it down

00:10:58.310 --> 00:11:00.150
to the local machine.

00:11:00.150 --> 00:11:02.690
Once they have the file, they
would make their change, fix

00:11:02.690 --> 00:11:04.100
the phone number, whatever
they need to do.

00:11:04.100 --> 00:11:06.136
And then they would save it.

00:11:06.136 --> 00:11:08.290
At which point, they would
submit it for review, where it

00:11:08.290 --> 00:11:10.900
would be checked for spelling
errors, syntax,

00:11:10.900 --> 00:11:12.660
style guide, et cetera.

00:11:12.660 --> 00:11:15.630
And then the reviewer would
give the approval and say,

00:11:15.630 --> 00:11:18.620
looks good to me.

00:11:18.620 --> 00:11:21.250
After this, it's up to the
technician to submit this file

00:11:21.250 --> 00:11:24.260
back up to the repository, where
any application that

00:11:24.260 --> 00:11:27.090
depends on the YAML format would
have to sync it down.

00:11:27.090 --> 00:11:29.100
At which point, they could
use it or display it

00:11:29.100 --> 00:11:30.350
however they want.

00:11:34.360 --> 00:11:39.100
So in order to crowdsource this
a little easier and avoid

00:11:39.100 --> 00:11:42.190
that tedious process for making
small changes, we set

00:11:42.190 --> 00:11:44.880
up this App Engine-based
replacement.

00:11:44.880 --> 00:11:47.940
We provided a UI for making
all these changes.

00:11:47.940 --> 00:11:50.970
And in addition to that, we
include audit logs for all the

00:11:50.970 --> 00:11:52.220
changes that are made.

00:11:57.720 --> 00:12:00.920
So now I'm going to demo
Techstop Info a little bit,

00:12:00.920 --> 00:12:03.895
just so you have an idea of what
it's about and what some

00:12:03.895 --> 00:12:06.700
of its features are.

00:12:06.700 --> 00:12:09.810
So here, a technician could
come to our website.

00:12:09.810 --> 00:12:13.630
And they're immediately
presented a list of Techstops.

00:12:13.630 --> 00:12:16.120
So let's say the technician
coming here actually wanted to

00:12:16.120 --> 00:12:17.070
fix a phone number.

00:12:17.070 --> 00:12:19.790
And they know the Techstops
managed by Bob.

00:12:19.790 --> 00:12:22.380
Using a Gmail-like search query,
we can kind of filter

00:12:22.380 --> 00:12:23.630
this down a little bit.

00:12:25.890 --> 00:12:27.910
But that wasn't really
specific enough.

00:12:27.910 --> 00:12:31.190
So let's say we also know the
Techstop that Bob manages is

00:12:31.190 --> 00:12:33.230
on floor two.

00:12:33.230 --> 00:12:34.930
And since that's the only result
of our query, we're

00:12:34.930 --> 00:12:38.150
taken directly into the
Techstop, where phone numbers

00:12:38.150 --> 00:12:41.230
could be changed or updated.

00:12:41.230 --> 00:12:44.110
Also, an important note would
be the audit log that

00:12:44.110 --> 00:12:45.540
we have down here.

00:12:45.540 --> 00:12:48.890
This basically says James was
the last person to edit this

00:12:48.890 --> 00:12:50.112
Techstop info.

00:12:50.112 --> 00:12:52.900
And if we wanted to dig down a
little deeper into this, we

00:12:52.900 --> 00:12:55.490
could get a full audit trail
and actually see all the

00:12:55.490 --> 00:12:58.290
changes that were made to this
Techstop, who made them, and

00:12:58.290 --> 00:12:59.540
what the changes were.

00:13:04.120 --> 00:13:06.680
So now that I've shown you
Techstop Info and the

00:13:06.680 --> 00:13:08.800
Gmail-like search querying, I'm
going to explain a little

00:13:08.800 --> 00:13:11.850
bit about how we implemented
that.

00:13:11.850 --> 00:13:14.420
Really, all we ended up doing
is filtering based off the

00:13:14.420 --> 00:13:18.070
models, our datastore's
model attributes.

00:13:18.070 --> 00:13:21.960
So to do this, we set up this
GetTechstopList method.

00:13:21.960 --> 00:13:24.710
And really, all it does is it
takes a query from the UI and

00:13:24.710 --> 00:13:27.090
decides what to do with it.

00:13:27.090 --> 00:13:29.580
So the first check we do is
for a colon in the query.

00:13:29.580 --> 00:13:31.790
And that says it is a
Gmail-like query.

00:13:31.790 --> 00:13:34.300
So we pass it along to the
GetListByAttributeQuery

00:13:34.300 --> 00:13:38.830
method, which I'll talk about
in the next slide.

00:13:38.830 --> 00:13:41.550
And then if it isn't a
Gmail-like query, we just take

00:13:41.550 --> 00:13:44.250
what was entered in the UI, and
we use it as a standard

00:13:44.250 --> 00:13:48.260
term for a Datastore search.

00:13:48.260 --> 00:13:51.190
So the GetListByAttributeQuery
method is what actually parses

00:13:51.190 --> 00:13:53.030
a Gmail-like query.

00:13:53.030 --> 00:13:56.530
Really, all it does is take this
query, split it up into

00:13:56.530 --> 00:13:58.880
attribute names and values,
and then we start looping

00:13:58.880 --> 00:14:01.020
through them all.

00:14:01.020 --> 00:14:03.440
So we check our Techstop
model to ensure

00:14:03.440 --> 00:14:04.370
that it has this attribute.

00:14:04.370 --> 00:14:06.620
And if it doesn't, we
inform the user that

00:14:06.620 --> 00:14:08.720
their query was invalid.

00:14:08.720 --> 00:14:11.710
But if it does have it, what
we'll do is we'll take our

00:14:11.710 --> 00:14:14.130
current list of Techstops, and
we'll start pruning out the

00:14:14.130 --> 00:14:17.550
ones that don't have that
attribute or value.

00:14:17.550 --> 00:14:19.330
What we're left with at the
end of this is a list of

00:14:19.330 --> 00:14:21.970
Techstops that match the entire
query, meaning every

00:14:21.970 --> 00:14:24.260
attribute and value, and
then we return them.

00:14:27.540 --> 00:14:29.270
So the
IntersectResultsWithAttribute

00:14:29.270 --> 00:14:31.530
method does pretty much
what it says.

00:14:31.530 --> 00:14:34.590
It takes our current list of
tech stops, and it prunes the

00:14:34.590 --> 00:14:38.320
ones that don't have this
attribute or value.

00:14:38.320 --> 00:14:41.080
So originally, when we run this
method, we don't have a

00:14:41.080 --> 00:14:43.340
current results that
no Techstops.

00:14:43.340 --> 00:14:45.530
So what we do is just a standard
Datastore search with

00:14:45.530 --> 00:14:46.780
a little bit of filtering
involved.

00:14:49.860 --> 00:14:52.270
Once we get those current
results up, it actually will

00:14:52.270 --> 00:14:53.660
start passing it in to here.

00:14:53.660 --> 00:14:55.940
And we'll start looping through
each of the Techstops

00:14:55.940 --> 00:14:57.250
in that result set.

00:14:57.250 --> 00:14:59.230
What we're doing is checking
to make sure that they have

00:14:59.230 --> 00:15:00.400
that attribute or value.

00:15:00.400 --> 00:15:02.900
And if they don't, we just
don't include it

00:15:02.900 --> 00:15:05.680
in our return results.

00:15:05.680 --> 00:15:07.930
These three functions here are
really what allow us to

00:15:07.930 --> 00:15:09.460
implement the search querying.

00:15:09.460 --> 00:15:13.250
And it allows our application
to quickly provide relevant

00:15:13.250 --> 00:15:15.860
information to the techs that
are visiting our website.

00:15:18.550 --> 00:15:21.380
I mentioned a little earlier in
the demo that we have these

00:15:21.380 --> 00:15:23.900
audit logs for keeping track of
all the changes that happen

00:15:23.900 --> 00:15:26.200
to this Techstop info.

00:15:26.200 --> 00:15:28.790
We use the SaveTechstop method
here for actually writing the

00:15:28.790 --> 00:15:31.440
Techstops to the Datastore.

00:15:31.440 --> 00:15:34.050
So inside, we have this private
transaction method.

00:15:34.050 --> 00:15:35.890
And you can see that it's
actually putting the Techstop

00:15:35.890 --> 00:15:37.260
in the Datastore.

00:15:37.260 --> 00:15:41.150
In return, we get a Techstop
key, which we can then use to

00:15:41.150 --> 00:15:43.120
build this audit entry with.

00:15:43.120 --> 00:15:46.640
The audit entry says who made
the change, what attributes

00:15:46.640 --> 00:15:48.790
were changed, and what
their new values are.

00:15:48.790 --> 00:15:51.710
And then we write to
the Datastore too.

00:15:51.710 --> 00:15:53.800
We take that private transaction
method, and we run

00:15:53.800 --> 00:15:56.460
it in the db.run_in_transaction.

00:15:56.460 --> 00:15:59.180
And that ensures that both the
Techstop entity and our audit

00:15:59.180 --> 00:16:00.430
entity get written
to the Datastore.

00:16:04.310 --> 00:16:08.780
I also mentioned that we have
a corporate database.

00:16:08.780 --> 00:16:11.070
What we're doing is we're taking
our Datastore with all

00:16:11.070 --> 00:16:14.180
of its Techstop information,
and we're syncing it out to

00:16:14.180 --> 00:16:15.800
this corporate database.

00:16:15.800 --> 00:16:18.180
Really, the database is meant
for storing all this

00:16:18.180 --> 00:16:21.570
org-related information, so
applications that depend on

00:16:21.570 --> 00:16:24.630
that can easily access it.

00:16:24.630 --> 00:16:29.280
With all of our Techstop info
in here, all the website has

00:16:29.280 --> 00:16:31.770
to do is authenticate to the
corporate database, and all

00:16:31.770 --> 00:16:33.930
this information's made
available to them.

00:16:33.930 --> 00:16:37.510
We don't have to administrate
an API access or give direct

00:16:37.510 --> 00:16:39.360
App Engine access to
our application.

00:16:42.060 --> 00:16:44.605
A really good example of the
types of services that consume

00:16:44.605 --> 00:16:47.410
our Techstop info from the
corporate database would be an

00:16:47.410 --> 00:16:50.290
internal overlay we have
for Google Maps.

00:16:50.290 --> 00:16:52.120
This displays all of our
corporate locations.

00:16:52.120 --> 00:16:55.250
And that just happens to include
all of our Techstops.

00:16:55.250 --> 00:16:58.380
So at this point, a technician
can come to our new

00:16:58.380 --> 00:17:01.430
application we have set up, make
some changes to Techstop,

00:17:01.430 --> 00:17:04.624
like the name, phone number,
or GPS coordinates.

00:17:04.624 --> 00:17:07.450
And then upon saving that, it's
automatically updated in

00:17:07.450 --> 00:17:10.260
this Maps overlay.

00:17:10.260 --> 00:17:12.009
And another pretty good example
is the fact that all

00:17:12.009 --> 00:17:14.849
of our end user documentation,
as well as call centers, have

00:17:14.849 --> 00:17:16.780
access to our new application.

00:17:16.780 --> 00:17:19.819
So they really don't have to
worry about a phone number

00:17:19.819 --> 00:17:22.690
being wrong or a room
number being old.

00:17:22.690 --> 00:17:25.099
As long as it's updated in our
application, it's made

00:17:25.099 --> 00:17:26.940
immediately accessible
to them.

00:17:30.230 --> 00:17:32.060
So if you take a minute
and just look

00:17:32.060 --> 00:17:33.310
over this graph here.

00:17:37.020 --> 00:17:40.490
What we're showing are all the
edits to all Techstop data

00:17:40.490 --> 00:17:42.790
that have ever happened.

00:17:42.790 --> 00:17:45.660
In the blue, we have all the
edits to our YAML file.

00:17:45.660 --> 00:17:47.860
And in the red, we have all the
audit logs currently in

00:17:47.860 --> 00:17:48.960
our data store.

00:17:48.960 --> 00:17:51.840
I'm going to switch this to a
log scale, just to make it a

00:17:51.840 --> 00:17:54.500
little easier to see.

00:17:54.500 --> 00:17:56.750
So again in the blue,
our YAML edits.

00:17:56.750 --> 00:18:00.200
And what this is displaying is
about 107 edits over the

00:18:00.200 --> 00:18:02.850
period of three years.

00:18:02.850 --> 00:18:04.420
In the red, again, are
the audit logs.

00:18:04.420 --> 00:18:08.295
And what those are displaying
are about 1,072 audit logs in

00:18:08.295 --> 00:18:10.450
the period of five months.

00:18:10.450 --> 00:18:13.610
That's about a 72-fold increase
in overall edits to

00:18:13.610 --> 00:18:14.640
our Techstop data.

00:18:14.640 --> 00:18:17.770
And this should paint a pretty
clear picture about what can

00:18:17.770 --> 00:18:20.930
happen when you give complete
control over the data to the

00:18:20.930 --> 00:18:24.830
people that use it and depend
on it the most.

00:18:24.830 --> 00:18:26.700
There's a couple spikes
in this graph that I'd

00:18:26.700 --> 00:18:29.450
like to point out.

00:18:29.450 --> 00:18:32.680
This very last blue spike was
actually caused by us.

00:18:32.680 --> 00:18:36.520
Those human errors I talked
about earlier needed corrected

00:18:36.520 --> 00:18:39.580
in order to import all this data
into our new application.

00:18:39.580 --> 00:18:43.050
So we had to go through and
manually correct all this, and

00:18:43.050 --> 00:18:45.980
that's what caused that
very last spike there.

00:18:45.980 --> 00:18:47.860
But after doing that and
importing all this into our

00:18:47.860 --> 00:18:50.470
application, we were
able to release it.

00:18:50.470 --> 00:18:52.240
At which point, all of our
technicians kind of flooded to

00:18:52.240 --> 00:18:53.650
the site to check it out.

00:18:53.650 --> 00:18:57.610
And they actually corrected any
old, invalid, or missing

00:18:57.610 --> 00:18:58.740
data for our Techstops.

00:18:58.740 --> 00:19:02.810
And that's what caused
this spike here.

00:19:02.810 --> 00:19:06.200
And then this last spike was
actually caused by us again.

00:19:06.200 --> 00:19:09.680
But unlike the YAML spike that
I talked about, we didn't

00:19:09.680 --> 00:19:12.580
actually have to manually
make all these edits.

00:19:12.580 --> 00:19:14.970
We were able to send out
an email to all of our

00:19:14.970 --> 00:19:18.110
technicians saying, we're
making a global change,

00:19:18.110 --> 00:19:19.480
informing them of this.

00:19:19.480 --> 00:19:22.790
And they were actually able to
make this change for us.

00:19:22.790 --> 00:19:25.390
We essentially were able
to crowdsource a global

00:19:25.390 --> 00:19:30.240
modification without us having
to do very much.

00:19:30.240 --> 00:19:32.870
So now that I've talked about
Techstop Info and some of its

00:19:32.870 --> 00:19:34.960
features, I'm going to pass this
off to James, who's going

00:19:34.960 --> 00:19:37.770
to talk about another support
application called Unified

00:19:37.770 --> 00:19:39.020
Travel Manager.

00:19:41.170 --> 00:19:41.850
JAMES MEADOR: Thanks, Zach.

00:19:41.850 --> 00:19:42.710
Hi, everyone.

00:19:42.710 --> 00:19:44.000
My name is James Meador.

00:19:44.000 --> 00:19:47.020
And I'm also an IT resident
at Google in the Internal

00:19:47.020 --> 00:19:49.140
Technology Residency program.

00:19:49.140 --> 00:19:52.010
For my operations rotation in
this program, I was fortunate

00:19:52.010 --> 00:19:54.400
enough to get to spend some time
with Bob and the Support

00:19:54.400 --> 00:19:56.600
Engineering team
that he leads.

00:19:56.600 --> 00:19:59.620
The majority of my time spent
on rotation was spent

00:19:59.620 --> 00:20:02.530
designing and developing this
application called Unified

00:20:02.530 --> 00:20:04.010
Travel Manager.

00:20:04.010 --> 00:20:06.560
Now the design requirements for
this application called

00:20:06.560 --> 00:20:10.700
for an application that had a
modular framework and not only

00:20:10.700 --> 00:20:14.430
eased future development, but
encouraged it as well.

00:20:14.430 --> 00:20:16.570
Before we get into some of the
technical details about

00:20:16.570 --> 00:20:19.910
Unified Travel Manager, or UTM,
as we frequently call it,

00:20:19.910 --> 00:20:21.930
I want to give you a little
background information about

00:20:21.930 --> 00:20:24.430
how we handle travel
at Google.

00:20:24.430 --> 00:20:27.970
Now in a typical IT support
organization, if a technician

00:20:27.970 --> 00:20:31.400
decides to take vacation or gets
sick or takes leave, the

00:20:31.400 --> 00:20:33.740
responsibilities will be
offloaded to another member of

00:20:33.740 --> 00:20:36.450
their team or another
team entirely.

00:20:36.450 --> 00:20:38.970
This can be a particularly large
problem for a smaller

00:20:38.970 --> 00:20:42.180
office that's run by one
or two technicians.

00:20:42.180 --> 00:20:45.190
At Google, we try to mitigate
the effects of this by using

00:20:45.190 --> 00:20:47.390
what we call travel requests.

00:20:47.390 --> 00:20:49.660
Now, a travel request is
something that a technician

00:20:49.660 --> 00:20:52.570
can open if they have
a planned absence.

00:20:52.570 --> 00:20:56.430
And then another technician can
fill that travel request.

00:20:56.430 --> 00:20:58.670
The same concept kind of
applies for events.

00:20:58.670 --> 00:21:00.580
So like Google I/O,
we have a need for

00:21:00.580 --> 00:21:02.120
technical support here.

00:21:02.120 --> 00:21:04.370
And what we can do is we can
open a travel request, and

00:21:04.370 --> 00:21:08.060
then multiple technicians can
fill that travel request.

00:21:08.060 --> 00:21:09.680
This can pose some
concerns, though.

00:21:09.680 --> 00:21:12.310
What if more than one Googler
or technician wants to fill

00:21:12.310 --> 00:21:14.150
one of these travel requests?

00:21:14.150 --> 00:21:16.290
What if a manager thinks that
a different technician is

00:21:16.290 --> 00:21:19.130
better suited to handle a
higher-profile event, like

00:21:19.130 --> 00:21:20.700
Google I/O?

00:21:20.700 --> 00:21:22.840
This is where we got the idea
for the first iteration of

00:21:22.840 --> 00:21:24.830
Unified Travel Manager.

00:21:24.830 --> 00:21:27.505
The first version was focused on
the application process to

00:21:27.505 --> 00:21:28.870
a travel request.

00:21:28.870 --> 00:21:32.120
So if Bob knew he was headed to
the Bahamas for a week, he

00:21:32.120 --> 00:21:34.400
could open a travel application
that both Zach and

00:21:34.400 --> 00:21:36.350
myself could apply to.

00:21:36.350 --> 00:21:38.960
Bob or his manager would then be
able to select which one of

00:21:38.960 --> 00:21:42.740
us was going to be lucky enough
to cover his position.

00:21:42.740 --> 00:21:45.280
Now the first version
of UTM was great.

00:21:45.280 --> 00:21:48.110
But after the problem analysis
that Bob talked about, we

00:21:48.110 --> 00:21:49.960
wanted to move this
application to a

00:21:49.960 --> 00:21:51.750
no-maintenance cloud solution.

00:21:51.750 --> 00:21:54.200
And we really feel that Google
App Engine was the best fit

00:21:54.200 --> 00:21:56.270
for this application.

00:21:56.270 --> 00:21:58.450
The three things in UTM that we
want to talk to you about

00:21:58.450 --> 00:22:01.770
are the modular framework and
design, a distinction between

00:22:01.770 --> 00:22:04.870
application administrators and
application developers, and

00:22:04.870 --> 00:22:07.220
some of the caching strategies
that we used, along with an

00:22:07.220 --> 00:22:10.760
implementation of what we call
NDB, or Next Database, which

00:22:10.760 --> 00:22:13.030
is a new Datastore API.

00:22:13.030 --> 00:22:15.280
Before we do that, however, I
want to give you a quick demo

00:22:15.280 --> 00:22:17.962
of UTM so you can kind of see
what it looks like it and how

00:22:17.962 --> 00:22:19.212
the modules work.

00:22:22.200 --> 00:22:25.210
Now what you can see here is
the admin panel for UTM.

00:22:25.210 --> 00:22:27.270
On the left, we've got
a manager module

00:22:27.270 --> 00:22:28.940
and a travel module.

00:22:28.940 --> 00:22:30.780
In the middle, we've got
read access groups and

00:22:30.780 --> 00:22:31.900
write access groups.

00:22:31.900 --> 00:22:33.650
And you can see that technicians
and support

00:22:33.650 --> 00:22:35.830
engineering are two groups that
have read access to the

00:22:35.830 --> 00:22:37.420
travel module.

00:22:37.420 --> 00:22:40.300
On the right, we've got two
on/off switches here.

00:22:40.300 --> 00:22:42.310
And these allow us to enable
or disable these

00:22:42.310 --> 00:22:44.310
modules on the fly.

00:22:44.310 --> 00:22:48.810
I'm going to go ahead and open
the travel travel module here.

00:22:48.810 --> 00:22:50.240
So what you can see
here is a list of

00:22:50.240 --> 00:22:51.820
the open travel requests.

00:22:51.820 --> 00:22:53.440
Now I'm going to go ahead
and create a new one.

00:22:59.640 --> 00:23:01.700
Now I'll go ahead and set the
destination here to the

00:23:01.700 --> 00:23:05.680
Moscone Center and set the start
date and end date to the

00:23:05.680 --> 00:23:10.060
duration of Google I/O. I'll
set the priority too high

00:23:10.060 --> 00:23:12.740
because this is kind
of important.

00:23:12.740 --> 00:23:16.260
I'll also change the needed
bodies to three because we

00:23:16.260 --> 00:23:17.300
need three technicians.

00:23:17.300 --> 00:23:21.990
And I'll specify that this is
for Google I/O. I'll go ahead

00:23:21.990 --> 00:23:24.020
and save this travel
request and head

00:23:24.020 --> 00:23:26.820
back out to the overview.

00:23:26.820 --> 00:23:29.210
Now if we refresh the page, you
can kind of see that it's

00:23:29.210 --> 00:23:31.120
not showing up right now.

00:23:31.120 --> 00:23:34.100
But what we can do is we head
back into the admin panel and

00:23:34.100 --> 00:23:36.470
flip this module on and off.

00:23:36.470 --> 00:23:40.030
Go ahead and turn the module
off, refresh the page.

00:23:40.030 --> 00:23:41.890
It disappears from
the nav bar.

00:23:41.890 --> 00:23:43.810
I'll go ahead and turn
the module back on.

00:23:47.890 --> 00:23:49.710
The other thing we were going
to show you in this

00:23:49.710 --> 00:23:52.790
application is the manager
module that you saw in the

00:23:52.790 --> 00:23:54.660
module list.

00:23:54.660 --> 00:23:57.250
Now at Google, we handle travel
differently, like we

00:23:57.250 --> 00:23:59.690
talked about.

00:23:59.690 --> 00:24:02.600
And part of this is we have what
we call travel managers.

00:24:02.600 --> 00:24:04.930
Now a travel manager is somebody
that's responsible

00:24:04.930 --> 00:24:07.410
for the travel coming in
and going out of a

00:24:07.410 --> 00:24:09.260
certain site or region.

00:24:09.260 --> 00:24:11.820
And these travel managers have
access to what we call the

00:24:11.820 --> 00:24:14.840
manager module in
our application.

00:24:14.840 --> 00:24:17.420
The manager module allows
these travel managers to

00:24:17.420 --> 00:24:19.730
specify who they manage
the travel for.

00:24:19.730 --> 00:24:22.820
So in the UI, they can type in
the name of a user and then

00:24:22.820 --> 00:24:26.460
drag that user to one of the
different groups on the site.

00:24:26.460 --> 00:24:31.240
They can also specify a group
or team, like technicians or

00:24:31.240 --> 00:24:33.250
support engineering that
we showed you.

00:24:33.250 --> 00:24:36.080
And then that'll send off an
Ajax request to the back end,

00:24:36.080 --> 00:24:37.750
which will then return
a list of all the

00:24:37.750 --> 00:24:40.040
users in that group.

00:24:40.040 --> 00:24:41.960
So now that we've shown you
about half of our demo of the

00:24:41.960 --> 00:24:45.160
application, we want to go
through some of the modular

00:24:45.160 --> 00:24:48.370
design of UTM.

00:24:48.370 --> 00:24:50.990
Now this is our class structure
for the modular

00:24:50.990 --> 00:24:52.700
overview of the application.

00:24:52.700 --> 00:24:54.990
On the left, we've got
webappRequestHandler.

00:24:54.990 --> 00:24:57.150
And in the middle, we've got
ParentRequestHandler.

00:24:57.150 --> 00:24:59.620
And on the right, you can see
ModuleRequestHandler.

00:24:59.620 --> 00:25:01.460
Now each of these are subclasses
of each other.

00:25:01.460 --> 00:25:03.960
So Parent Request Handler
is a subclass of the

00:25:03.960 --> 00:25:05.030
webapp Request Handler.

00:25:05.030 --> 00:25:07.520
And the Module Request Handler
is then, again, a subclass of

00:25:07.520 --> 00:25:09.440
that Parent Request Handler.

00:25:09.440 --> 00:25:11.470
We think of our relationship
between the Parent Request

00:25:11.470 --> 00:25:13.890
Handler and the Module Request
Handler a lot like the

00:25:13.890 --> 00:25:15.740
relationship between
a motherboard and

00:25:15.740 --> 00:25:17.410
an expansion card.

00:25:17.410 --> 00:25:19.830
The motherboard, or our Parent
Request Handler, is

00:25:19.830 --> 00:25:23.400
responsible for most of the
basic routing and other

00:25:23.400 --> 00:25:26.330
remedial tasks and utilities
that are associated with

00:25:26.330 --> 00:25:28.390
running the application.

00:25:28.390 --> 00:25:31.600
The Module Request Handler, or
the expansion card, is focused

00:25:31.600 --> 00:25:34.160
on adding features and
functionality, the bells and

00:25:34.160 --> 00:25:36.250
whistles kinds of things.

00:25:36.250 --> 00:25:38.910
Now on top of the class
structure, what you see is the

00:25:38.910 --> 00:25:42.190
path that an HTTP request will
take through the application.

00:25:42.190 --> 00:25:44.130
We'll go into more detail about
this in a little bit.

00:25:44.130 --> 00:25:47.450
But the general gist is that an
HTTP request flows all the

00:25:47.450 --> 00:25:49.880
way from the webapp Request
Handler down to the Module

00:25:49.880 --> 00:25:52.170
Request Handler, and then back
out to the user through the

00:25:52.170 --> 00:25:54.430
webapp Request Handler.

00:25:54.430 --> 00:25:57.050
Now to do that, however, we have
to know which modules are

00:25:57.050 --> 00:26:00.040
responsible for processing
which requests.

00:26:00.040 --> 00:26:03.450
Now this mapping of URLs to
methods happens in the

00:26:03.450 --> 00:26:06.170
constructors for the Parent
Request Handler and the Module

00:26:06.170 --> 00:26:07.370
Request Handler.

00:26:07.370 --> 00:26:10.050
Let's take a look at what
these look like.

00:26:10.050 --> 00:26:11.380
Now I really like tacos.

00:26:11.380 --> 00:26:14.460
So we're going to take and
build an application here

00:26:14.460 --> 00:26:16.100
called IOLunchHandler.

00:26:16.100 --> 00:26:19.280
This is going to take care of
the ordering of lunch for

00:26:19.280 --> 00:26:20.580
Google I/O.

00:26:20.580 --> 00:26:22.160
Now this is our Parent
Request Handler.

00:26:22.160 --> 00:26:23.420
And it's inheriting from
webapp.RequestHandler.

00:26:26.000 --> 00:26:28.900
This is the constructor
for IO Lunch Handler.

00:26:28.900 --> 00:26:32.360
Now we'll go ahead and call the
constructor for the super.

00:26:32.360 --> 00:26:34.360
And we'll initialize two
dictionaries, method and

00:26:34.360 --> 00:26:35.800
template mappings.

00:26:35.800 --> 00:26:37.480
We'll then call InitSubHandler.

00:26:37.480 --> 00:26:39.670
We don't want all of our
modules to override the

00:26:39.670 --> 00:26:41.740
constructor of the Parent
Request Handler because in our

00:26:41.740 --> 00:26:44.430
live application, we've got some
additional functionality

00:26:44.430 --> 00:26:47.690
and processing that
happens here.

00:26:47.690 --> 00:26:50.020
So this is a module called
TacoHandler.

00:26:50.020 --> 00:26:53.000
It's inheriting from
IO Lunch Handler.

00:26:53.000 --> 00:26:55.460
And what we'll do is we'll
define this Init Sub Handler

00:26:55.460 --> 00:26:57.740
method that we just called.

00:26:57.740 --> 00:27:01.280
In this case, we'll call a
method MapURLToMethod.

00:27:01.280 --> 00:27:03.640
Now what this does is it tells
the Parent Request Handler

00:27:03.640 --> 00:27:07.670
that we're going to process all
requests to /tacos with

00:27:07.670 --> 00:27:09.420
the DisplayTacos method.

00:27:09.420 --> 00:27:11.710
Now remember the Display Tacos
name because we're going to

00:27:11.710 --> 00:27:14.040
talk about that in
a little bit.

00:27:14.040 --> 00:27:17.860
Let's look at what the Map URL
To Method function looks like.

00:27:17.860 --> 00:27:20.080
This method lives on the
Parent Request Handler.

00:27:20.080 --> 00:27:21.800
And here's the definition
of it.

00:27:21.800 --> 00:27:24.600
We'll use the URL as the key in
these two dictionaries that

00:27:24.600 --> 00:27:26.560
we created in the constructor.

00:27:26.560 --> 00:27:28.720
And we'll assign a definition
of the method in the method

00:27:28.720 --> 00:27:29.820
mappings dictionary.

00:27:29.820 --> 00:27:32.980
And the template's file name
is a string in the template

00:27:32.980 --> 00:27:35.260
mappings dictionary.

00:27:35.260 --> 00:27:38.090
If we have a lot of modules in
our application, they can be a

00:27:38.090 --> 00:27:39.520
little difficult
to keep track.

00:27:39.520 --> 00:27:41.890
So we put together a class
called ModuleManager that's

00:27:41.890 --> 00:27:43.630
going to help with this.

00:27:43.630 --> 00:27:46.480
Module Manager functions a lot
like a dictionary in Python,

00:27:46.480 --> 00:27:48.730
but with some additional
functionality.

00:27:48.730 --> 00:27:52.400
We'll use this handler's
dictionary here to keep track.

00:27:52.400 --> 00:27:54.580
One of the utility methods
on the Module Manager is

00:27:54.580 --> 00:27:55.900
something called AddHandler.

00:27:55.900 --> 00:27:58.130
Now what this is going to do
is it's going to take the

00:27:58.130 --> 00:27:59.920
definition of a handler.

00:27:59.920 --> 00:28:02.230
And it's going to use the
handler's name as the key in

00:28:02.230 --> 00:28:04.100
that handler's dictionary.

00:28:04.100 --> 00:28:07.620
We'll also create an instance of
the handler here and store

00:28:07.620 --> 00:28:09.600
that as the value in
the dictionary.

00:28:09.600 --> 00:28:12.030
The reason we're creating an
instance is because we want to

00:28:12.030 --> 00:28:14.890
make sure that the Init Sub
Handler method is called so

00:28:14.890 --> 00:28:18.750
that all of the URL to method
mapping can take place.

00:28:18.750 --> 00:28:21.420
Another utility method on the
Module Manager is called

00:28:21.420 --> 00:28:22.740
GetURLMappings.

00:28:22.740 --> 00:28:24.960
Now what this does is it
iterates through the

00:28:24.960 --> 00:28:26.770
dictionary's keys.

00:28:26.770 --> 00:28:28.580
And it creates a list
of [? tuples ?]

00:28:28.580 --> 00:28:31.550
based on the URL in the handler
that's responsible for

00:28:31.550 --> 00:28:35.560
processing requests destined
for that URL.

00:28:35.560 --> 00:28:38.160
Now that we have this class
defined, this is how we go

00:28:38.160 --> 00:28:40.210
about using it.

00:28:40.210 --> 00:28:41.570
We'll go ahead and create
an instance of the

00:28:41.570 --> 00:28:42.830
Module Manager class.

00:28:42.830 --> 00:28:45.960
And then we'll add the Taco
Handler to the class.

00:28:45.960 --> 00:28:48.540
Now that we've got some data in
that dictionary, we can use

00:28:48.540 --> 00:28:53.200
the Get URL Mappings method here
and pass the results of

00:28:53.200 --> 00:28:55.830
that to webapp.WSGIApplication.

00:28:55.830 --> 00:28:59.680
This is what tells App Engine
what URLs are responsible for

00:28:59.680 --> 00:29:02.010
processing which request
and what handlers those

00:29:02.010 --> 00:29:03.260
will get routed to.

00:29:05.640 --> 00:29:08.230
The next thing we want to do
is talk about how an HTTP

00:29:08.230 --> 00:29:10.180
request goes through
our application.

00:29:10.180 --> 00:29:13.000
Now that we know which handlers
and which modules are

00:29:13.000 --> 00:29:14.860
responsible for processing
which

00:29:14.860 --> 00:29:17.140
requests, we can do this.

00:29:17.140 --> 00:29:20.510
Now whenever App Engine sees an
HTTP Get request come into

00:29:20.510 --> 00:29:23.540
your application, it's going to
fire off the Get method on

00:29:23.540 --> 00:29:26.020
the subclass of webapp
Request Handler.

00:29:26.020 --> 00:29:28.380
In our case, that's going to
be the Get method on the

00:29:28.380 --> 00:29:29.570
Parent Request Handler.

00:29:29.570 --> 00:29:32.790
So let's take a look at
what that looks like.

00:29:32.790 --> 00:29:34.560
This is the I/O Lunch
Handler again, our

00:29:34.560 --> 00:29:35.710
Parent Request Handler.

00:29:35.710 --> 00:29:38.940
And the definition of the Get
method is right here.

00:29:38.940 --> 00:29:40.290
Now we'll use those
dictionaries

00:29:40.290 --> 00:29:41.800
that we just populated.

00:29:41.800 --> 00:29:44.960
And we'll get the path
for the HTTP request

00:29:44.960 --> 00:29:46.990
from the request object.

00:29:46.990 --> 00:29:49.910
We'll then look up the Get
method that's responsible for

00:29:49.910 --> 00:29:53.470
processing this HTTP request
and store that here.

00:29:53.470 --> 00:29:57.600
We'll do the same for the
template's file name.

00:29:57.600 --> 00:29:59.370
Now we'll call that
Get method.

00:29:59.370 --> 00:30:01.440
We'll store the results
of this Get method in

00:30:01.440 --> 00:30:03.050
template_params.

00:30:03.050 --> 00:30:05.510
So we're going to jump out of
the Parent Request Handler and

00:30:05.510 --> 00:30:07.830
into the Module Request
Handler while we

00:30:07.830 --> 00:30:09.650
run this Get method.

00:30:09.650 --> 00:30:12.120
So we just left the Parent
Request Handler's call module

00:30:12.120 --> 00:30:14.320
method portion, and we're headed
into the module method

00:30:14.320 --> 00:30:18.770
portion of the Module
Request Handler.

00:30:18.770 --> 00:30:21.030
So here's the Taco Handler
module we showed you a little

00:30:21.030 --> 00:30:24.250
earlier and the Display Tacos
method that I mentioned.

00:30:24.250 --> 00:30:27.120
Now we'll create a dictionary
here with some pretty basic

00:30:27.120 --> 00:30:30.270
taco types in it, chicken and
beef, for this example.

00:30:30.270 --> 00:30:32.480
And we'll return that dictionary
back to the Parent

00:30:32.480 --> 00:30:34.940
Request Handler for
processing.

00:30:34.940 --> 00:30:37.060
We're then stepping out of the
module and back into the

00:30:37.060 --> 00:30:39.940
Parent Request Handler for
some template rendering.

00:30:39.940 --> 00:30:42.610
Let's take a look at what
this looks like.

00:30:42.610 --> 00:30:44.810
This is still happening
in that Get method.

00:30:44.810 --> 00:30:47.960
So what we'll do is we'll call
App Engine's template.render.

00:30:47.960 --> 00:30:51.350
We'll pass in the file name and
the dictionary with the

00:30:51.350 --> 00:30:53.920
parameters to render
to that template.

00:30:53.920 --> 00:30:58.260
And then we'll render that
response to the output stream.

00:30:58.260 --> 00:31:00.680
Now this design lets us do
some interesting things.

00:31:00.680 --> 00:31:03.660
The first that we're going to
talk about is the ability to

00:31:03.660 --> 00:31:05.780
administratively disable
modules.

00:31:05.780 --> 00:31:07.940
Now we showed you briefly in
the demo how we had those

00:31:07.940 --> 00:31:10.200
on/off switches that allow
us to toggle on

00:31:10.200 --> 00:31:12.080
or off these modules.

00:31:12.080 --> 00:31:14.490
A lot of this processing and
validation happens in the

00:31:14.490 --> 00:31:17.810
constructor for the Parent
Request Handler.

00:31:17.810 --> 00:31:20.120
So here's the Taco Handler
module again.

00:31:20.120 --> 00:31:23.640
And we're going to assign a
module ID of "tacos." we use

00:31:23.640 --> 00:31:27.240
this ID whenever we store some
basic data about our modules

00:31:27.240 --> 00:31:29.940
in Datastore.

00:31:29.940 --> 00:31:32.560
Next, what you see is a method
called ValidateSubHandler.

00:31:32.560 --> 00:31:34.870
Now this method is on the
Parent Request Handler.

00:31:34.870 --> 00:31:37.100
And it's responsible for making
sure that all of the

00:31:37.100 --> 00:31:40.130
modules are implementing the
module design correctly.

00:31:40.130 --> 00:31:41.830
The first thing we'll do is
we'll make sure that the

00:31:41.830 --> 00:31:43.660
module has defined an ID.

00:31:43.660 --> 00:31:47.020
If it hasn't, then we'll raise
an attribute error.

00:31:47.020 --> 00:31:50.790
If we do have a module ID, then
we'll fetch our module

00:31:50.790 --> 00:31:54.910
entity from Datastore based
on that module ID.

00:31:54.910 --> 00:31:57.860
If Datastore doesn't return
anything, or it does return a

00:31:57.860 --> 00:32:00.590
module, but the module's
disabled, then we'll raise a

00:32:00.590 --> 00:32:02.240
NotConfiguredError.

00:32:02.240 --> 00:32:04.510
This is just a custom error in
our application that lets us

00:32:04.510 --> 00:32:05.980
know whenever a module's
accessed when it

00:32:05.980 --> 00:32:09.130
shouldn't have been.

00:32:09.130 --> 00:32:11.380
Another thing we can do with
this design is implement

00:32:11.380 --> 00:32:14.810
granular access control
at the module level.

00:32:14.810 --> 00:32:17.210
Now App Engine provides you
with 10 application

00:32:17.210 --> 00:32:20.890
administrators and application
developers in the console that

00:32:20.890 --> 00:32:22.240
you can configure.

00:32:22.240 --> 00:32:23.610
But we wanted to
expand on that.

00:32:23.610 --> 00:32:25.280
We were already implementing
our own user

00:32:25.280 --> 00:32:26.340
authentication model.

00:32:26.340 --> 00:32:28.390
So this was actually
kind of simple.

00:32:28.390 --> 00:32:31.070
Let's show you what we did.

00:32:31.070 --> 00:32:34.920
Now what you can see here is
a user in module model.

00:32:34.920 --> 00:32:38.530
Now the user model has a list of
groups because the user can

00:32:38.530 --> 00:32:39.760
be a member of multiple
groups.

00:32:39.760 --> 00:32:42.920
For instance, Zach is a member
of both technicians and

00:32:42.920 --> 00:32:44.740
support engineering.

00:32:44.740 --> 00:32:47.190
And a module has an
ACL right here.

00:32:47.190 --> 00:32:49.700
You can see read groups, write
groups, and admi groups.

00:32:49.700 --> 00:32:54.080
Now if a technician needed
access to a specific module,

00:32:54.080 --> 00:32:58.230
then the technicians group would
be on one of these ACLs,

00:32:58.230 --> 00:33:01.060
let's say, for instance,
the admin group.

00:33:01.060 --> 00:33:03.920
But how do we intersect the
user's groups with the

00:33:03.920 --> 00:33:05.610
module's ACL?

00:33:05.610 --> 00:33:07.140
Well, we use a decorator.

00:33:07.140 --> 00:33:11.150
So in our decorators.py file,
we have a decorator called

00:33:11.150 --> 00:33:13.030
RequiresModuleAdmin.

00:33:13.030 --> 00:33:15.110
Now the method that we're
decorating that's passed in is

00:33:15.110 --> 00:33:19.970
the handler_method argument
of this method.

00:33:19.970 --> 00:33:21.630
The IsModuleAdmin
is the closure

00:33:21.630 --> 00:33:23.370
method inside this decorator.

00:33:23.370 --> 00:33:25.850
Now what it's going to do is
it's going to use App Engine's

00:33:25.850 --> 00:33:27.990
users API to fetch the
currently logged

00:33:27.990 --> 00:33:30.760
in user's user name.

00:33:30.760 --> 00:33:32.670
We'll then take that user
name and fetch our

00:33:32.670 --> 00:33:35.070
user entity from Datastore.

00:33:35.070 --> 00:33:36.710
We'll also get a list
of the admin groups

00:33:36.710 --> 00:33:38.980
for the current module.

00:33:38.980 --> 00:33:41.240
If we have a user entity in
our Datastore for the

00:33:41.240 --> 00:33:43.850
currently logged in user, then
we'll intersect that user's

00:33:43.850 --> 00:33:47.320
groups with the admin groups
for the module.

00:33:47.320 --> 00:33:49.830
If there is an intersection
there, then we'll go ahead and

00:33:49.830 --> 00:33:51.910
call the handler method that
we're decorating with the

00:33:51.910 --> 00:33:53.830
arguments that were passed in.

00:33:53.830 --> 00:33:56.165
If there's no intersection, then
we'll simply error out

00:33:56.165 --> 00:33:58.290
with a 403.

00:33:58.290 --> 00:34:01.000
Now putting this functionality
in a decorator makes it really

00:34:01.000 --> 00:34:04.550
simple to use an implement
throughout all of our modules.

00:34:04.550 --> 00:34:06.810
What we can do is any method
that requires the currently

00:34:06.810 --> 00:34:09.600
logged in user to have module
admin rights, we can just put

00:34:09.600 --> 00:34:13.120
the decorator on top of
the method definition.

00:34:13.120 --> 00:34:17.310
In this situation, it's just
a ChangeLunchItems method.

00:34:17.310 --> 00:34:19.530
So now that we've talked about
the modular overview and

00:34:19.530 --> 00:34:22.449
design of UTM and a distinction
between

00:34:22.449 --> 00:34:26.170
application administrators and
developers, we want to talk a

00:34:26.170 --> 00:34:28.480
little bit about our caching
strategies that we used in

00:34:28.480 --> 00:34:29.489
this application.

00:34:29.489 --> 00:34:34.520
Now who here likes
a slow website?

00:34:34.520 --> 00:34:37.110
That's unfortunate.

00:34:37.110 --> 00:34:42.120
So slow websites waste
people's time.

00:34:42.120 --> 00:34:44.310
If you load a page, and it takes
more than five seconds

00:34:44.310 --> 00:34:45.679
to load, you've probably
already moved on

00:34:45.679 --> 00:34:47.159
to something else.

00:34:47.159 --> 00:34:51.810
Now this was one of the main
reasons we moved our

00:34:51.810 --> 00:34:52.909
application into the cloud.

00:34:52.909 --> 00:34:55.080
We wanted to make sure that page
load times were quick.

00:34:55.080 --> 00:34:57.680
We wanted to make sure that
users didn't have to wait

00:34:57.680 --> 00:34:59.830
forever whenever they were
trying to access the data that

00:34:59.830 --> 00:35:01.450
they needed.

00:35:01.450 --> 00:35:04.080
And one of the things that we
did was we implemented a

00:35:04.080 --> 00:35:06.930
memcache to store the results
of all of our

00:35:06.930 --> 00:35:08.850
expensive method calls.

00:35:08.850 --> 00:35:10.990
We also did this through
a decorator.

00:35:10.990 --> 00:35:13.340
You'll see the definition of
a cache decorator here with

00:35:13.340 --> 00:35:16.230
function passed in
as the argument.

00:35:16.230 --> 00:35:19.580
Now CachedFunction is the method
here that's going to do

00:35:19.580 --> 00:35:21.320
most of our heavy lifting.

00:35:21.320 --> 00:35:23.590
We'll build a key based on the
function's name that we're

00:35:23.590 --> 00:35:27.270
decorating and a list of the
ordered arguments and keyword

00:35:27.270 --> 00:35:30.190
arguments that were passed
in to the method.

00:35:30.190 --> 00:35:32.480
Once we have this key,
we'll try to fetch

00:35:32.480 --> 00:35:34.250
a value from memcache.

00:35:34.250 --> 00:35:36.570
If memcache has anything stored,
then we'll simply

00:35:36.570 --> 00:35:38.150
return that back out
to the caller.

00:35:38.150 --> 00:35:41.430
But if we don't have anything
in memcache, we'll need to

00:35:41.430 --> 00:35:43.500
call the method that we're
decorating, store those

00:35:43.500 --> 00:35:45.820
results in memcache,
and then return

00:35:45.820 --> 00:35:48.340
that back to the caller.

00:35:48.340 --> 00:35:50.250
Another thing that we did was
we implemented something

00:35:50.250 --> 00:35:51.780
called Next Database.

00:35:51.780 --> 00:35:54.690
I mentioned earlier that this
is a new API on top of App

00:35:54.690 --> 00:35:56.330
Engine's Datastore.

00:35:56.330 --> 00:35:58.790
Now one of the features that
NDB provides is something

00:35:58.790 --> 00:36:00.880
called structured properties.

00:36:00.880 --> 00:36:03.510
Structured properties allow
you to retain some of the

00:36:03.510 --> 00:36:08.250
organizational benefits that a
normalized database gives you,

00:36:08.250 --> 00:36:10.020
but in a non-relational
database like

00:36:10.020 --> 00:36:12.030
App Engine's Datastore.

00:36:12.030 --> 00:36:14.030
Let's take a look
at what we did.

00:36:14.030 --> 00:36:17.150
So what you can see here is
a travel application model

00:36:17.150 --> 00:36:20.680
that's based on ndb.Model
instead of DB.

00:36:20.680 --> 00:36:22.340
We'll create a user property
here just for the

00:36:22.340 --> 00:36:24.515
sake of this example.

00:36:24.515 --> 00:36:27.550
We'll also define a travel
request model here.

00:36:27.550 --> 00:36:30.530
Now we talked about how UTM is
focused on the application

00:36:30.530 --> 00:36:33.110
process for these
travel requests.

00:36:33.110 --> 00:36:36.030
This is actually an abbreviated
example of exactly

00:36:36.030 --> 00:36:38.440
what we do in our application.

00:36:38.440 --> 00:36:40.560
So we have an
approved_applications property

00:36:40.560 --> 00:36:42.900
on the travel request itself.

00:36:42.900 --> 00:36:45.740
We'll define this is as an
ndb.StructuredProperty that's

00:36:45.740 --> 00:36:48.070
based on the travel
application.

00:36:48.070 --> 00:36:50.980
We'll tell NDB that this is a
repeated argument by setting

00:36:50.980 --> 00:36:53.770
this to true.

00:36:53.770 --> 00:36:57.130
Now what this does is it allows
us to store data about

00:36:57.130 --> 00:37:00.510
the application on the
request object.

00:37:00.510 --> 00:37:02.810
This is how we'd go about
putting one of these requests

00:37:02.810 --> 00:37:04.500
and applications in Datastore.

00:37:04.500 --> 00:37:07.310
We'll create a travel
application with the user

00:37:07.310 --> 00:37:09.990
property set to the currently
logged in user.

00:37:09.990 --> 00:37:12.690
We'll then create an empty
travel request.

00:37:12.690 --> 00:37:14.920
We'll set the approved
applications property on this

00:37:14.920 --> 00:37:17.750
travel request to a list
of length one with the

00:37:17.750 --> 00:37:19.755
application in that list.

00:37:19.755 --> 00:37:23.170
We'll then put the travel
request into Datastore.

00:37:23.170 --> 00:37:25.790
You'll note, however, that we
never actually store the

00:37:25.790 --> 00:37:27.970
travel application itself.

00:37:27.970 --> 00:37:31.950
It's an ndb.Model, but we never
called the .put method.

00:37:31.950 --> 00:37:35.050
The reason for this is the
travel application is stored

00:37:35.050 --> 00:37:37.580
on the travel request itself.

00:37:37.580 --> 00:37:40.850
Whenever you put a travel
request into Datastore, it's

00:37:40.850 --> 00:37:42.470
going to store the travel
application

00:37:42.470 --> 00:37:44.510
information with it.

00:37:44.510 --> 00:37:47.810
Whenever you fetch the travel
request from Datastore, NDB's

00:37:47.810 --> 00:37:49.810
going to reconstruct that
travel application

00:37:49.810 --> 00:37:51.710
model on the fly.

00:37:51.710 --> 00:37:55.150
So if you were to have any
utility methods defined on the

00:37:55.150 --> 00:37:58.180
NDB model, in this case, travel
application, all those

00:37:58.180 --> 00:37:59.480
methods would just work.

00:37:59.480 --> 00:38:03.260
There wouldn't be any problem
with getting those methods to

00:38:03.260 --> 00:38:04.510
map correctly.

00:38:06.380 --> 00:38:08.690
Now this is a method called
GetTravelRequests.

00:38:08.690 --> 00:38:11.340
This is a method that's in our
application that fetches all

00:38:11.340 --> 00:38:13.600
of the travel requests
from Datastore.

00:38:13.600 --> 00:38:16.090
It performs some processing
on those requests.

00:38:16.090 --> 00:38:18.710
And then it returns the results
of that processing

00:38:18.710 --> 00:38:20.320
back to the caller.

00:38:20.320 --> 00:38:22.530
This is one of the methods that
does a lot of processing

00:38:22.530 --> 00:38:25.760
and Datastore operations, so we
wanted to use the caching

00:38:25.760 --> 00:38:27.850
decorator on this method.

00:38:27.850 --> 00:38:30.170
Every time we hit the method,
we don't want it to run.

00:38:30.170 --> 00:38:32.640
So we'll check memcache
to see if we have

00:38:32.640 --> 00:38:34.140
something stored for it.

00:38:34.140 --> 00:38:36.010
If memcache has anything, we'll
just return that back to

00:38:36.010 --> 00:38:36.900
the caller.

00:38:36.900 --> 00:38:39.330
But if it doesn't, we'll have to
go through this processing

00:38:39.330 --> 00:38:41.920
the next time we call
the function.

00:38:41.920 --> 00:38:45.210
The other thing I want to show
you is a feature called hooks

00:38:45.210 --> 00:38:46.330
that NDB provides.

00:38:46.330 --> 00:38:49.130
These aren't available
in Datastore, in

00:38:49.130 --> 00:38:50.660
the original DB API.

00:38:50.660 --> 00:38:52.940
But NDB provides
these for you.

00:38:52.940 --> 00:38:54.890
Now this is a travel
request model.

00:38:54.890 --> 00:38:58.730
And we're going to define what
we call a pre_put_hook.

00:38:58.730 --> 00:39:02.150
Now NDB's going to fire off this
method before you perform

00:39:02.150 --> 00:39:06.470
any Datastore Puts on a travel
request in this situation.

00:39:06.470 --> 00:39:10.200
For this example, we'll just
call memcache.flush_all, but

00:39:10.200 --> 00:39:11.790
we could really do anything
we want here.

00:39:11.790 --> 00:39:15.700
Zach showed you how we used
audit trails in Techstop Info.

00:39:15.700 --> 00:39:19.400
We could actually use that
same logic here.

00:39:19.400 --> 00:39:21.510
Now these hooks are available
for all of your Datastore

00:39:21.510 --> 00:39:24.620
operations, your Puts, your
Gets, and your Deletes.

00:39:24.620 --> 00:39:27.200
And you can specify the hook to
run before or after those

00:39:27.200 --> 00:39:29.060
operations.

00:39:29.060 --> 00:39:32.090
Now implementing all of these
caching strategies led to some

00:39:32.090 --> 00:39:33.340
pretty astounding results.

00:39:38.060 --> 00:39:42.360
Now what you can see here is
worst case cold cache load

00:39:42.360 --> 00:39:46.290
times for a reporting page
in our application.

00:39:46.290 --> 00:39:48.740
Now this reporting page fetched
a lot of travel

00:39:48.740 --> 00:39:50.170
requests from Datastore.

00:39:50.170 --> 00:39:53.280
So it did some processing on
this as well, which is why the

00:39:53.280 --> 00:39:56.880
DB load time is at 21 seconds.

00:39:56.880 --> 00:40:00.570
Now after implementing NDB
structured properties, we got

00:40:00.570 --> 00:40:02.910
this down to about 1
and 1/2 seconds.

00:40:02.910 --> 00:40:07.170
The reason for this is all of
the travel requests in NDB now

00:40:07.170 --> 00:40:10.080
store all of the travel
applications on the travel

00:40:10.080 --> 00:40:12.060
request object itself.

00:40:12.060 --> 00:40:15.430
So with DB implementation, the
relationship between travel

00:40:15.430 --> 00:40:18.120
requests and travel applications
was that of a

00:40:18.120 --> 00:40:19.790
parent/child relationship.

00:40:19.790 --> 00:40:22.370
So any time we'd fetch a travel
request from Datastore,

00:40:22.370 --> 00:40:25.430
we'd have to go and fetch the
travel applications as well.

00:40:25.430 --> 00:40:28.460
With the NDB implementation,
this was a lot quicker, thanks

00:40:28.460 --> 00:40:30.870
to structured properties.

00:40:30.870 --> 00:40:33.910
Now we will note that if you
were to switch directly from

00:40:33.910 --> 00:40:36.140
DB to using NDB without
implementing things like

00:40:36.140 --> 00:40:38.450
structured properties or any
other caching, you might

00:40:38.450 --> 00:40:43.240
notice a slight performance
decrease simply because NDB

00:40:43.240 --> 00:40:45.170
has a little bit more
overhead for the new

00:40:45.170 --> 00:40:47.190
features that it adds.

00:40:47.190 --> 00:40:49.010
Now that we've talked about some
of the caching strategies

00:40:49.010 --> 00:40:52.070
for UTM, and we've talked about
the modular design of

00:40:52.070 --> 00:40:54.640
the application, I'm going to
pass it back off to Bob for

00:40:54.640 --> 00:40:55.890
some results and conclusions.

00:41:00.630 --> 00:41:01.330
ROBERT PUFKY: Thanks, James.

00:41:01.330 --> 00:41:04.350
You know, they say live demos
never work, and I think we

00:41:04.350 --> 00:41:07.250
just proved that.

00:41:07.250 --> 00:41:11.600
So I want to just wrap this up
and talk about the results we

00:41:11.600 --> 00:41:15.540
got from moving our application
stack to the cloud

00:41:15.540 --> 00:41:17.940
and the benefits that our team
got from it, as well as our

00:41:17.940 --> 00:41:19.472
organization.

00:41:19.472 --> 00:41:22.130
And the first thing that I want
to talk about is Platform

00:41:22.130 --> 00:41:25.690
as a Service, and how it
actually really works for us.

00:41:25.690 --> 00:41:28.500
It's really a paradigm shift in
application development for

00:41:28.500 --> 00:41:31.380
us in the sense that we're
focused on actually developing

00:41:31.380 --> 00:41:34.600
and solving fundamental issues
and innovating in our space,

00:41:34.600 --> 00:41:38.470
as opposed to developing and
maintaining stuff at the same

00:41:38.470 --> 00:41:40.380
time,

00:41:40.380 --> 00:41:43.690
We're focusing on the people at
hand and the problems and

00:41:43.690 --> 00:41:46.590
not focusing on keeping
stuff up and running.

00:41:49.240 --> 00:41:53.680
It's also no longer part of your
core tasks to keep these

00:41:53.680 --> 00:41:55.960
services running.

00:41:55.960 --> 00:41:58.990
You don't have to worry about
stuff going down.

00:42:01.850 --> 00:42:05.230
We also found out as we started
moving more and more

00:42:05.230 --> 00:42:08.430
to the cloud that we had a lot
of really intrinsic benefits

00:42:08.430 --> 00:42:09.920
to this as well.

00:42:09.920 --> 00:42:14.270
There was a definite hump when
we got about partway through

00:42:14.270 --> 00:42:18.980
our cloud migration that we
spent a lot less time late

00:42:18.980 --> 00:42:21.280
nights and weekends at work.

00:42:21.280 --> 00:42:24.910
And this was obviously
maintenance, putting out fires

00:42:24.910 --> 00:42:26.340
like we were doing
in the past.

00:42:26.340 --> 00:42:27.160
All that was gone.

00:42:27.160 --> 00:42:29.240
So we actually had a
really large morale

00:42:29.240 --> 00:42:31.020
increase on our team.

00:42:31.020 --> 00:42:34.180
As well as it was just a better
work-life balance.

00:42:34.180 --> 00:42:36.020
People would come in, and they'd
know they would work

00:42:36.020 --> 00:42:37.610
Monday through Friday,
nine to five.

00:42:37.610 --> 00:42:39.260
And they could go camping on
the weekend and not worry

00:42:39.260 --> 00:42:41.130
about carrying a pager or worry
about something going

00:42:41.130 --> 00:42:43.900
down, they needed a failover.

00:42:43.900 --> 00:42:47.080
And this was pretty huge.

00:42:47.080 --> 00:42:49.560
And really, at the end of the
day, guys, it was about our

00:42:49.560 --> 00:42:51.950
end users and making sure that
they were up and running and

00:42:51.950 --> 00:42:55.320
being productive as possible.

00:42:55.320 --> 00:42:59.110
And the cloud platform, App
Engine, allowed us to do this

00:42:59.110 --> 00:43:02.585
via Developers by allowing us
to focus on the problems at

00:43:02.585 --> 00:43:06.310
hand, allowing us to instantly
scale to the world, as well as

00:43:06.310 --> 00:43:09.610
allowing our techs and enabling
our techs to have the

00:43:09.610 --> 00:43:11.930
information at hand to make
empowered decisions to get

00:43:11.930 --> 00:43:14.420
people out of the Techstop
faster and being more

00:43:14.420 --> 00:43:15.860
productive.

00:43:15.860 --> 00:43:18.150
Additionally, our users,
Googlers, are happier as well

00:43:18.150 --> 00:43:19.670
because they can actually
get their work done.

00:43:19.670 --> 00:43:22.580
They don't need to wait for
problems to be solved or

00:43:22.580 --> 00:43:23.830
information to be had.

00:43:26.340 --> 00:43:28.990
So that's it with the
presentation.

00:43:28.990 --> 00:43:33.030
We have about a minute 30 left,
I think, before we're

00:43:33.030 --> 00:43:35.760
switching sessions.

00:43:35.760 --> 00:43:38.210
So thank you guys very
much for attending.

00:43:38.210 --> 00:43:39.310
I really appreciate it.

00:43:39.310 --> 00:43:40.240
And--

00:43:40.240 --> 00:43:45.640
[APPLAUSE]

00:43:45.640 --> 00:43:48.090
ROBERT PUFKY: If you have any
questions that we can't answer

00:43:48.090 --> 00:43:51.200
during the Q and A, since it's
going to be so short, just

00:43:51.200 --> 00:43:52.960
come and find me, and we
can talk about it.

