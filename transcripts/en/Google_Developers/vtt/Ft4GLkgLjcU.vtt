WEBVTT
Kind: captions
Language: en

00:00:01.270 --> 00:00:05.069
&gt;&gt; SACHS: Okay, thanks for coming and not
running off to get in line for your new toy.

00:00:05.069 --> 00:00:10.299
My name is Eric Sachs. I'm a product manager
at Google. Currently I'm a product manager

00:00:10.299 --> 00:00:14.869
for two different teams, the Google Security
team as well as I'm actually the product manager

00:00:14.869 --> 00:00:20.290
counterpart for Google's CIO, which is an
interesting pair of responsibilities, but

00:00:20.290 --> 00:00:25.220
we're actually doing a lot of work in the
security area to offer our CIO, sort of our

00:00:25.220 --> 00:00:30.630
internal enterprise teams some new options
to use cloud computing. I'm going to spend

00:00:30.630 --> 00:00:35.000
some time talking about that today. I have
actually been at Google now almost six years

00:00:35.000 --> 00:00:39.390
and, prior to that, about ten years in the
corporate e-mail host environment, so, I've

00:00:39.390 --> 00:00:45.310
been on both the enterprise and the consumer
side for a long time. And what we're going

00:00:45.310 --> 00:00:51.260
to focus on today is sort of the mish-mash
of different standards in the security space,

00:00:51.260 --> 00:00:56.630
especially the ones that are used in more
of our cloud computing web services environment.

00:00:56.630 --> 00:01:00.820
And, in particular, I'm not trying to make
all of you security experts. What I see as

00:01:00.820 --> 00:01:06.319
my goal as a product manager is to make people
aware of, you know, new solutions to problems

00:01:06.319 --> 00:01:12.340
in the past that just seemed unsolvable. And
so, you know, I get this from a lot of people

00:01:12.340 --> 00:01:16.240
who would, you know, talk about themselves
as being security experts that handle security

00:01:16.240 --> 00:01:20.740
expert in, you know, area one and two, but,
you know, trying to keep all the rest, you

00:01:20.740 --> 00:01:25.490
know, I just can't. And, in particular, you
know, I wouldn't even suggest trying. You

00:01:25.490 --> 00:01:30.469
know, learn the areas that you care about
and then, you know, keep an eye on those.

00:01:30.469 --> 00:01:34.849
No one can keep track of all of this stuff.
And, in particular, one of the themes we're

00:01:34.849 --> 00:01:39.509
going to talk about today is that a lot of
technology has been developed in the consumer

00:01:39.509 --> 00:01:45.490
space the last few years for security purposes
and is actually being really heavily adopted

00:01:45.490 --> 00:01:49.959
on the enterprise side. And, in fact, the
consumer can produce who, you know, created

00:01:49.959 --> 00:01:53.599
some of this stuff. They weren't pushing for
the use of it in enterprises. The enterprises

00:01:53.599 --> 00:02:00.329
grabbed it and have run with it. To be honest,
we're catching up as much as anything else.

00:02:00.329 --> 00:02:05.669
So, I'm going to go through two primary sections
today in my presentation and then at the end--apparently,

00:02:05.669 --> 00:02:11.040
now we should have a good 20 minutes for Q&amp;A,
so, we've got mic set up at the end for people

00:02:11.040 --> 00:02:14.450
who want to ask questions. And we are videoing
this, so, we're going to try to ask people

00:02:14.450 --> 00:02:20.920
to come up to the mic when do they have questions.
Two sections that I'm going to go in today,

00:02:20.920 --> 00:02:26.140
the first, Federated Login, something, probably
a lot of you are familiar with. However, historically,

00:02:26.140 --> 00:02:30.670
this has been more about large enterprise
type of thing. What I want to talk to the

00:02:30.670 --> 00:02:34.400
audience today about is, you know, what if
you're a small or a medium size business or

00:02:34.400 --> 00:02:39.110
what if you're a software-as-a-service vendor.
There's a lot of interesting evolution in

00:02:39.110 --> 00:02:44.650
this space that is worth knowing about. And
then about two-thirds of the session today,

00:02:44.650 --> 00:02:50.650
I'm going to be talking about web service
authentication. I don't mean a web service

00:02:50.650 --> 00:02:55.350
authenticating an end-user, you know, logging
in. What I mean is web service A making a

00:02:55.350 --> 00:03:00.580
call to web service B, say, to make a request
to change someone's salary. And we're going

00:03:00.580 --> 00:03:06.710
to talk about how the receiving web bot application
identifies the calling web application and

00:03:06.710 --> 00:03:13.540
a whole bunch of scenarios where this gets
interesting. So, let me jump into this first

00:03:13.540 --> 00:03:18.710
part, sort of this federated login. So, many
of you have probably, you know, experienced

00:03:18.710 --> 00:03:25.010
this yourself working either at a large enterprise
where they've deployed a single sign-on system

00:03:25.010 --> 00:03:29.010
across a bunch of corporate applications or
maybe you experienced this as a corporate

00:03:29.010 --> 00:03:33.390
user of, say, Google or Yahoo where you logged
in once and all of a sudden, you logged in

00:03:33.390 --> 00:03:38.450
to a bunch of services from those providers
without being logged in. So, traditionally,

00:03:38.450 --> 00:03:44.390
this has been more of a gain for large enterprises,
large consumer websites. And most of them

00:03:44.390 --> 00:03:49.380
purchased packaged software products, you
know, for this. And the standard in this space

00:03:49.380 --> 00:03:54.270
pretty well evolves really solid. However,
if you're going to run this, you know, you

00:03:54.270 --> 00:03:59.180
have to be prepared to make sure that this
system is up and running all the time. So,

00:03:59.180 --> 00:04:03.200
you know, we're talking about service in multiple
data-centers, multiple, you know, servers

00:04:03.200 --> 00:04:08.490
even in the same data-centers to keep it up
and running. And things start to get a little

00:04:08.490 --> 00:04:13.770
bit more complicated especially in the large
enterprise scenario if you then want to enable

00:04:13.770 --> 00:04:20.459
some of your employees to log in to some software-as-a-service
applications, Salesforce, Google Apps being

00:04:20.459 --> 00:04:25.740
examples, and you want your employees to log
in to them without having to enter their password

00:04:25.740 --> 00:04:31.580
again. So, that's sort of the traditional
example. But let's talk about some of the

00:04:31.580 --> 00:04:36.310
stuff that's happened the last year or so,
which is that a lot of small and medium businesses

00:04:36.310 --> 00:04:41.840
said, "This sounds great. I'm going to go
buy one these single sign-on software packages.

00:04:41.840 --> 00:04:45.939
I'm going to deploy it on my Windows active
directory server sitting on the desk over

00:04:45.939 --> 00:04:51.729
there." And they've got sort of a term for
this. SSO was sort of the abbreviation of

00:04:51.729 --> 00:04:56.259
Single Sign-On. Well, within small and medium
businesses, they'd like to make a joke out

00:04:56.259 --> 00:05:02.340
of it. Now, it's a Single Source Of failure.
And what they mean by that is a lot of companies

00:05:02.340 --> 00:05:06.659
have the experience of they deployed one of
these systems sitting under someone's desk,

00:05:06.659 --> 00:05:12.469
10 o'clock at night, that server dies and
their CEO is in India and is trying to log

00:05:12.469 --> 00:05:16.449
in to one of the applications like their e-mail
system. And even though the e-mail system

00:05:16.449 --> 00:05:21.689
is up and running, their login system is down.
So, you know, if you're a small-medium business

00:05:21.689 --> 00:05:25.930
running this, you know, on a single server
in a single office applying a single internet

00:05:25.930 --> 00:05:31.129
connection, don't do it. It's not worth the
pain they're going to cause. So, seeing this,

00:05:31.129 --> 00:05:38.069
a number of vendors in this space, Ping, simplified
some others, realized, wait, here's an opportunity.

00:05:38.069 --> 00:05:43.259
Instead of providing this as software to these
smaller companies, let's provide a service

00:05:43.259 --> 00:05:48.409
to them. Just as companies can outsource their
e-mail or their calendars or their 41K, now

00:05:48.409 --> 00:05:53.309
they can outsource running one these identity
provider services. Like I say, you can do

00:05:53.309 --> 00:05:58.430
this today with a couple of companies like
Ping supplied and then a lot of the e-mail

00:05:58.430 --> 00:06:03.409
hosting providers, Microsoft, Lotus, Google,
Yahoo, et cetera are working on clarifying

00:06:03.409 --> 00:06:08.069
the standard so that we can offer this same
functionality as well, and, so, you know,

00:06:08.069 --> 00:06:12.599
the goal is that, you know, that CEO traveling
in India, you know, if he wants to log in

00:06:12.599 --> 00:06:18.800
to any application, when it's a highly reliable
web service that is taking his password, figuring

00:06:18.800 --> 00:06:23.460
out who he is and then handling the job of
getting him logged in to the different application

00:06:23.460 --> 00:06:31.159
he wants to hit. So let me give an example
of how this might work. So, this example of

00:06:31.159 --> 00:06:36.469
a company called Appirio was really heavily
focused on using cloud computing, software-as-a-service

00:06:36.469 --> 00:06:42.219
offering. They tried to have really minimal
desktop, laptops for their employees and use

00:06:42.219 --> 00:06:48.599
services like Google Apps for mail and calendar
or Salesforce for their CRM application. And,

00:06:48.599 --> 00:06:52.689
you know, what they would have liked to have
done in the past is they would like for their

00:06:52.689 --> 00:06:58.270
employees to log in on one webpage and then
be able to go to Salesforce or Google or Plaxo

00:06:58.270 --> 00:07:03.240
or some other enterprise app and just be signed
in again magically speaking. However, they

00:07:03.240 --> 00:07:07.110
haven't been able to do this historically.
Well, one of the things that we've been working

00:07:07.110 --> 00:07:13.240
on with PingConnect and the OpenId's standards
community is a way of actually making this

00:07:13.240 --> 00:07:19.029
work. So, Ping is a company who had sort of--the
red box on the right--they're really experts

00:07:19.029 --> 00:07:23.050
at a lot of this federated login technology.
And they've realized how to make stuff talk

00:07:23.050 --> 00:07:28.240
to us in Salesforce using a whole bunch of
protocols, other SaaS vendors, business to

00:07:28.240 --> 00:07:33.569
business partners, even sort of--down in the
bottom, left-hand corner--hooking back into

00:07:33.569 --> 00:07:38.300
applications you might run on premise. They're
good at that, but, you know, still somebody

00:07:38.300 --> 00:07:42.409
has to be responsible for asking the user
for their password. So, in this case, what

00:07:42.409 --> 00:07:47.969
we did is we said, "You know what? Tom at
Appirio, he's already used to going and logging

00:07:47.969 --> 00:07:52.839
in to his mail service operated by Google.
So, Google knows how to authenticate him."

00:07:52.839 --> 00:07:58.229
So we used OpenId--which is another federated
login technology as sort of a glue between

00:07:58.229 --> 00:08:04.229
Google and Ping, and we said, you know, "Hey,
let's have Tom go and log in to his mail.

00:08:04.229 --> 00:08:10.689
He's all set." Now, if Tom goes and types
salesforce.appirio.com in his browser, he's

00:08:10.689 --> 00:08:15.099
going to be redirected to Salesforce with
a request to access Appirio's information.

00:08:15.099 --> 00:08:20.699
Salesforce will say, "Oh, okay well, that
domain's logins are handed by PingConnect."

00:08:20.699 --> 00:08:25.050
They'll route from there. PingConnect will
say, "Oh, okay, well, now I need to check

00:08:25.050 --> 00:08:29.909
who from Appirio is logged in," bounces the
user back to Google, and Google says, "Okay,

00:08:29.909 --> 00:08:34.210
well, it's Tom," you know, tells PingConnect,
"It's Tom," and PingConnect knows how to,

00:08:34.210 --> 00:08:38.640
you know, talk to a variant of federated login
that Salesforce uses and tells them that Tom's

00:08:38.640 --> 00:08:43.479
logged in. And the same thing applies to a
bunch of others. They think it could make

00:08:43.479 --> 00:08:47.570
this work like I say to these business to
business partners, to these enterprise apps,

00:08:47.570 --> 00:08:52.700
et cetera. And so we actually have this live
and running with them now, you know, and,

00:08:52.700 --> 00:08:57.750
hopefully, once we finalized some of the OpenId
community standards, it makes this more generally

00:08:57.750 --> 00:09:02.350
available. Some of the--one of the other things
to note is there's another purple box in the

00:09:02.350 --> 00:09:07.600
middle labeled "Plaxo," which points out that
as these standards do coalesce and really

00:09:07.600 --> 00:09:11.070
become not, you know, standards with some
variance but some standard with very little

00:09:11.070 --> 00:09:14.720
variance. It's even possible that some of
these e-mail hosting providers, whether it's

00:09:14.720 --> 00:09:21.220
a Google, a Yahoo or Microsoft, any of us
can act as a federated login provider, you

00:09:21.220 --> 00:09:26.000
know, directly to an application. So, Plaxo
is one who, for example, already does this

00:09:26.000 --> 00:09:31.390
with Google today for our Gmail users. So,
you know, Tom, all of these stuff is invisible

00:09:31.390 --> 00:09:35.850
to him. He enters his password once, goes
to any web app he needs from the enterprise,

00:09:35.850 --> 00:09:40.300
he's logged in. For a small and medium business,
you know, they are already used to using their

00:09:40.300 --> 00:09:44.910
e-mail outsourcer. Ping just become, you know,
one more box in the picture that handles a

00:09:44.910 --> 00:09:49.030
lot of the complexity for them, and usually
it's just a bunch of check boxes to get set

00:09:49.030 --> 00:09:56.260
up. So, we have a couple of different audiences
here. So, some very specific feedback, but,

00:09:56.260 --> 00:09:59.770
first, those of you who deal with small and
medium businesses, then we are going to talk

00:09:59.770 --> 00:10:04.770
about those of you running software-as-a-service
opportunities and then those of you who are

00:10:04.770 --> 00:10:09.800
geeks like me. So, first, you know, small
and medium businesses, like I said before,

00:10:09.800 --> 00:10:14.400
"Don't try to run your own login system, you
know, under someone's desk that's going to

00:10:14.400 --> 00:10:17.590
die when your executive is traveling. You're
just asking to get yelled at." You know, either

00:10:17.590 --> 00:10:23.180
just don't, either just require your employees
to log in to all these applications independently--which

00:10:23.180 --> 00:10:27.770
is annoying but not the end of the world,
you know--or look at one of these service

00:10:27.770 --> 00:10:33.130
space offering that can provide this in a
more highly reliable way. And another thing

00:10:33.130 --> 00:10:37.530
to keep an eye on is, you know, this type
of glue that's happening, you know, it's--I

00:10:37.530 --> 00:10:41.640
was just showing you the previous diagram--this
is evolving quickly. These service providers

00:10:41.640 --> 00:10:46.270
are offering a lot of other options, integration
with these different protocols, integration

00:10:46.270 --> 00:10:50.620
with some stronger authentication mechanism.
If that's really important you, that will--it

00:10:50.620 --> 00:10:56.980
has its own usability challenges. And, lastly,
a lot of enterprises are really pushing vendors

00:10:56.980 --> 00:11:02.450
like Ping, like Google to make better standards
for how to provision new users across a bunch

00:11:02.450 --> 00:11:06.510
of apps or use group membership across all
of them. These are things where standards

00:11:06.510 --> 00:11:10.750
are evolving. If you got a lot of time and
want to monitor them, great. If not, you know,

00:11:10.750 --> 00:11:17.090
let one of these experts deal with it for
you. So, that's some guidance if you're a

00:11:17.090 --> 00:11:21.910
small and medium business. Well, some of you
in the room run software-as-a-service offerings,

00:11:21.910 --> 00:11:27.220
so, whether it's for targeted small businesses,
medium businesses, large businesses, it doesn't

00:11:27.220 --> 00:11:32.300
really matter, you're almost certainly going
to get pressure from your enterprise customers

00:11:32.300 --> 00:11:37.050
to support this type of federated login. Your
security guys, you know, hate it when they

00:11:37.050 --> 00:11:41.430
have to take their employee passwords and
send it to a bunch of different vendors. Historically,

00:11:41.430 --> 00:11:46.740
most of this pressure came from larger enterprises
who could run these system. But we've--what

00:11:46.740 --> 00:11:51.360
we've seen over the last year is that there's
a lot of medium size and even smaller businesses,

00:11:51.360 --> 00:11:56.130
are deploying these service based and, their
being providers, they're now putting pressure

00:11:56.130 --> 00:11:59.560
on their SaaS when they're saying, you know,
"Hey, I've finally got one of these things.

00:11:59.560 --> 00:12:04.910
I want to use it. You know, I don't want my
employees have to log in yet again." So, if

00:12:04.910 --> 00:12:10.860
you as a SaaS vendor start feeling this pressure,
you have three choices. One is, well, these

00:12:10.860 --> 00:12:14.920
are standards, you can read them, you can
roll your own, and I can pretty much guarantee

00:12:14.920 --> 00:12:19.110
you, you're going to make a security mistake
'cause even, you know, experts like Google

00:12:19.110 --> 00:12:22.510
and Microsoft and Yahoo and Ping do. And,
you know, this is, you know, hardcoded stuff

00:12:22.510 --> 00:12:28.060
to get all the crypto right, so, a more traditional
option is just to purchase one of these software

00:12:28.060 --> 00:12:34.730
packages from a vendor in the space. There
are plenty, CAI, IBM, Oracle, Ping as well.

00:12:34.730 --> 00:12:40.280
And then one of the more recent trends is--we're
just talking about the fact that a small business

00:12:40.280 --> 00:12:47.060
can subscribe to a service that runs on identifier
when the reverse is true. Some companies like

00:12:47.060 --> 00:12:53.390
JanRain who offers a service they call "Rpx,"
as well as Ping are going to SaaS vendors

00:12:53.390 --> 00:12:57.390
and saying, "Hey, you don't want to run all
this complicated software in your site? Fine.

00:12:57.390 --> 00:13:02.240
We'll run it for you as a service on the internet
and we'll just need a small sort of last mile

00:13:02.240 --> 00:13:07.480
connection from the relying party they run
on behalf of your company to your company's

00:13:07.480 --> 00:13:14.780
website." So, the last audience--and I'm hoping
that there's some of you in this room or actually

00:13:14.780 --> 00:13:19.290
do I--oh, okay--one more annoying thing for
those of you who are software-as-a-service

00:13:19.290 --> 00:13:25.280
vendors. If you want to run off and do these
today, two warnings that we've learned from

00:13:25.280 --> 00:13:29.730
talking with other SaaS vendors who've done
this. The first is to take a look at whether

00:13:29.730 --> 00:13:36.060
you offer any desktop software that integrates
with your applications. If you do, you're

00:13:36.060 --> 00:13:40.280
probably going to be really annoyed when you
realized that you've hardcoded it to ask users

00:13:40.280 --> 00:13:45.070
for their e-mail address and password. Google
has done this, Salesforce has done this. But

00:13:45.070 --> 00:13:49.070
then, you know, Facebook fortunately avoided
it, but most of us made this mistake that

00:13:49.070 --> 00:13:53.880
our desktop absolutely just hardcoded to ask
for e-mail address and password. If you this

00:13:53.880 --> 00:13:56.750
federated login thing, all of a sudden you
don't have passwords for some of your users,

00:13:56.750 --> 00:14:02.050
so, you're in trouble. I'm not going to spend
a lot of time on this. If you want to see

00:14:02.050 --> 00:14:06.900
about most--best practices for solving that,
there's a technology called "OAuth" that does

00:14:06.900 --> 00:14:12.280
it. Down at the bottom there's sort of a web
link. You can search for "goog oauth" and

00:14:12.280 --> 00:14:16.130
there's some more detail there. Just look
for the information about desktop apps. The

00:14:16.130 --> 00:14:19.590
other challenge for software-as-a-service
providers is they'll have to decide what their

00:14:19.590 --> 00:14:23.850
login box looks like. Most of them, if they
have a login box, it's the traditional one--ask

00:14:23.850 --> 00:14:27.740
for e-mail address and ask for password. And
if all of a sudden some of your users don't

00:14:27.740 --> 00:14:33.030
have a password, you've to decide what should
it look like instead, different options, depending

00:14:33.030 --> 00:14:37.870
of what type of vendor you are. One of the
more common ones is just to take away that

00:14:37.870 --> 00:14:42.990
password field, ask the user for their e-mail
address and then, you know, look it up and

00:14:42.990 --> 00:14:46.540
decide, "Oh, is this someone where I have
a password for them or this someone where

00:14:46.540 --> 00:14:53.910
I'm using one of these federated login technologies?"
But, you know, the last thing I wanted to

00:14:53.910 --> 00:14:59.220
mention, I like to say--oh, did you--if you
have a question, do you want to come up or...?

00:14:59.220 --> 00:15:01.950
Or I can repeat it.
&gt;&gt; [INDISTINCT]

00:15:01.950 --> 00:15:08.500
&gt;&gt; SACHS: The slides actually, if you do this
search for "goog oauth" right now and go to

00:15:08.500 --> 00:15:12.330
the first website link to the search for Google
I/O, the slides are already there. And the

00:15:12.330 --> 00:15:18.760
video of this is supposed to be up I think
June 1st, if I remember correctly. Right,

00:15:18.760 --> 00:15:23.510
so, like I said, this is a pretty technical
audience. There's some unsolved challenges

00:15:23.510 --> 00:15:27.670
left here. A lot of great work is being done
not just by, you know, big companies, Microsoft,

00:15:27.670 --> 00:15:33.190
Yahoo, Google, AOL, et cetera, but some really
innovative stuff are coming from, you know,

00:15:33.190 --> 00:15:36.960
smaller companies, in particular, ones who
are just willing to, you know, just throw

00:15:36.960 --> 00:15:41.400
out past assumptions and try something new.
So, if you want to get involved in this space,

00:15:41.400 --> 00:15:44.880
they are couple of standards of steps here:
OpenID, OAuth, SAML. The OAuth mailing list,

00:15:44.880 --> 00:15:49.910
you can monitor them, see what's going on
in the space. And there's some, you know,

00:15:49.910 --> 00:15:55.070
challenges that we're dealing with. By far,
the number one is about usability. I have

00:15:55.070 --> 00:15:59.210
to admit this is an area that's very interesting
for us in the security community. We normally

00:15:59.210 --> 00:16:03.840
hide in the corners and, you know, try to
kill the bad demons. Now, we're actually spending

00:16:03.840 --> 00:16:08.500
a very large portion of our time learning
from usability experts about how to make this

00:16:08.500 --> 00:16:14.130
security technology helpful as opposed to
annoying. We're very good at making it annoying.

00:16:14.130 --> 00:16:18.970
That we know don't want to do. And, like I
say, you know, a couple other things, you

00:16:18.970 --> 00:16:24.000
know, easier set up for administrators, improving
the security whenever possible, and then the

00:16:24.000 --> 00:16:29.700
provisioning and group membership stuff that
I talked about. So, you know, that's the first

00:16:29.700 --> 00:16:34.279
section. Like to say, good vendors in the
space, take a look at them. You know, if you're

00:16:34.279 --> 00:16:38.029
a SaaS vendor, realize you're probably going
to get some pressure to become a relying party

00:16:38.029 --> 00:16:43.290
over the next year. Hopefully, this has some
good pointers. Let me dive into now the next

00:16:43.290 --> 00:16:47.130
section topic, a little bit more complicated,
and we're going to spend about two-thirds

00:16:47.130 --> 00:16:54.130
of the time here. So, I mentioned that I have
two jobs, the security job and product manager

00:16:54.130 --> 00:16:59.850
with our CIO. So, I spend a lot of time with
industry CIOs, government CIOs, and one of

00:16:59.850 --> 00:17:02.860
the things that's been really fascinating
with spending time with them is these guys

00:17:02.860 --> 00:17:07.589
are really looking at cloud computing technology
as a way to reducing their operating cost.

00:17:07.589 --> 00:17:11.959
You know, they want to use things like Azure
or Amazon, Salesforce, Google App Engine,

00:17:11.959 --> 00:17:17.890
et cetera. And they're interested in not just
for services like e-mail and CRM, but for

00:17:17.890 --> 00:17:24.530
these "platform as a service" offerings where
they can run entire apps on Amazon web services

00:17:24.530 --> 00:17:30.059
or in Google App Engine. However, as soon
as they start playing with these, the common

00:17:30.059 --> 00:17:36.630
refrain I hear from the CIOs is, "Okay, you
know, if I have app A running on, you know,

00:17:36.630 --> 00:17:41.830
one cloud computing vendor and app B running
behind my firewall or another cloud computing

00:17:41.830 --> 00:17:46.070
vendor, how are those two going to authenticate
to each other?" So, you know, forget about

00:17:46.070 --> 00:17:52.480
end-users. And so here are some very specific
used cases that I'm going to walk through

00:17:52.480 --> 00:17:57.330
today that are probably the most common--they
are the most common ones that I've been asked.

00:17:57.330 --> 00:18:01.950
So, the first is, you know, a more simple
one: "Great," you know, "I'm just trying to

00:18:01.950 --> 00:18:06.910
deal with cross platform connectivity. I build
my front end as a window server. I got backend

00:18:06.910 --> 00:18:11.700
running on Linux and I want that, you know,
Windows server to make, you know, application

00:18:11.700 --> 00:18:16.809
calls, RPCs to the backend. Well, how does
the backend know the requests are actually

00:18:16.809 --> 00:18:21.140
coming from that Windows server and not some
other rogue server in their environment?"

00:18:21.140 --> 00:18:25.720
Multiple ways to deal with this. We are going
to talk about one that can also help with

00:18:25.720 --> 00:18:30.130
scenarios two and three, which is the next
common scenario. There are a lot of companies

00:18:30.130 --> 00:18:34.330
that have said, "Oh, well, there's stuff I
can do at Amazon web services. What they're

00:18:34.330 --> 00:18:38.250
offering really meets my needs, and then there
is other functionality that I can more easily

00:18:38.250 --> 00:18:43.490
do at App Engine. But how do I combine the
two? How do I have my administrative console,

00:18:43.490 --> 00:18:48.860
an App Engine making, you know, function request
to my application running on Amazon to tell

00:18:48.860 --> 00:18:54.390
it to say, 'Restart,' or create more instances
of itself?" These are powerful operations.

00:18:54.390 --> 00:18:58.500
You want to make sure that the app running
on Amazon wants to make sure it's getting

00:18:58.500 --> 00:19:04.030
these requests from the proper source. And
then, you know, the most complicated one,

00:19:04.030 --> 00:19:09.970
and especially for enterprises that almost
guarantee that some of their data is going

00:19:09.970 --> 00:19:13.400
to be behind the firewall, they're got to
have some software running on premise. So,

00:19:13.400 --> 00:19:19.320
how do you integrate or mash up an application
running on the cloud and an application running

00:19:19.320 --> 00:19:23.250
on premise behind the firewall? So, we're
going to talk about each of these three used

00:19:23.250 --> 00:19:29.440
cases in turn. And, in particular, we're going
to talk about one technology standard called

00:19:29.440 --> 00:19:33.880
OAuth that can help in a lot of these areas.
I'm not going to tell you OAuth is exactly

00:19:33.880 --> 00:19:39.010
what you should use in all of these cases,
in particular, the first example of Window

00:19:39.010 --> 00:19:43.830
server targeting a Linux server--a bunch of
different options to do that. However, if

00:19:43.830 --> 00:19:48.830
those two applications are separated and can
only communicate through a firewall with an

00:19:48.830 --> 00:19:53.510
issue to be proxy, which is, you know, a common
thing, like Google App Engine Apps can only

00:19:53.510 --> 00:19:59.460
make outbound calls, you know, via HTTP and
a lot of enterprises only allowing inbound

00:19:59.460 --> 00:20:05.620
requests through HTTP. Well, if you got that
limitation, a lot of web developers, even

00:20:05.620 --> 00:20:12.960
before they get to your part, make a decision
to use a REST-style APIs. And if you're not

00:20:12.960 --> 00:20:15.710
familiar with that, I want to give an example.
But these are APIs that are designed to look

00:20:15.710 --> 00:20:21.330
like request to load a webpage, so they flow
through standard HTTP proxies, firewalls,

00:20:21.330 --> 00:20:26.760
et cetera. Of the--all the advantages of OAuth,
though, the biggest one it has is right now

00:20:26.760 --> 00:20:31.280
it's really simple. It's only a couple of
pages spec and, in fact, in the enterprise

00:20:31.280 --> 00:20:37.840
used cases, you can usually ignore all but
the first page of the spec. So, that simplicity

00:20:37.840 --> 00:20:42.690
really attracts an audience because, in general,
in the security space, the more complex something

00:20:42.690 --> 00:20:47.590
is, the more likely you are to get it wrong.
And then, did I see, at least, probably a

00:20:47.590 --> 00:20:50.679
need here, so I'm going to--one of the other
things I'm going to note is--well, I have

00:20:50.679 --> 00:20:55.420
some time at the end to answer some questions.
We're actually running a helpdesk that is

00:20:55.420 --> 00:21:00.050
on this floor. Okay, there's a helpdesk right
on this floor. Brian can stand up now and

00:21:00.050 --> 00:21:04.490
everyone can look at him. Brian is one of
our OAuth experts at Google. And we have another

00:21:04.490 --> 00:21:10.880
one there as well who you can dive down deeper
and some of the stuff if you're interested

00:21:10.880 --> 00:21:17.440
afterwards. Okay, so, we can talk about some
very specific examples. The top thing right

00:21:17.440 --> 00:21:21.670
there is--ignoring all the security stuff--what
does a REST API call look like? I'm guessing

00:21:21.670 --> 00:21:28.360
90 percent of you all do, but just in case,
it's an RPC, Remote Procedure Call, that looks

00:21:28.360 --> 00:21:33.000
like the type of thing you would type into
your web browser's URL. So, the top request

00:21:33.000 --> 00:21:39.880
is actually a request to change Sara's salary
to $90,000. You know, and in this case, it's

00:21:39.880 --> 00:21:44.730
running at this, you know, salary endpoint
on acme.com. And if they chose to, they could

00:21:44.730 --> 00:21:49.070
put this up as a web server that anyone could
type that URL in their browser and change

00:21:49.070 --> 00:21:54.740
Sara's salary. Now, they probably want to
add some security to that, I hope. So, let's

00:21:54.740 --> 00:21:59.250
talk about some ways they can do that. In
particular, the example I want to focus on,

00:21:59.250 --> 00:22:04.570
though, is if they have exposed this type
of REST API interface and they expect a front-end

00:22:04.570 --> 00:22:09.220
application to make calls to it, so it's not
two-tier user having the endpoint directly.

00:22:09.220 --> 00:22:13.580
It's user having some front-end app, and the
front-end app then wants to change Sara's

00:22:13.580 --> 00:22:18.440
salary. How is the front-end app going to
make that request and, you know, verify where

00:22:18.440 --> 00:22:23.220
it came from? So, what OAuth does, the very
simple version is it says, "You know what,

00:22:23.220 --> 00:22:28.840
take that URL that was created for the API
call and just add two things to it. One is

00:22:28.840 --> 00:22:32.990
the user URL parameter, which has the claimed
name of the calling application, and you get

00:22:32.990 --> 00:22:39.200
to decide what this is." Best practices do
something that looks like a domain name, but

00:22:39.200 --> 00:22:42.220
to be honest, it can be anything, any string
that's unique. And then the trickier part

00:22:42.220 --> 00:22:47.200
is this last parameter--this OAuth signature
parameter--and what this is designed to do

00:22:47.200 --> 00:22:53.150
is to prove that the request actually came
from a specific source. And so this is where

00:22:53.150 --> 00:22:59.070
the hard part happens. And so I'm going to
have to give you guys a little bit of the

00:22:59.070 --> 00:23:04.250
hard part here, the crypto part, and then
I'm going to talk about, hopefully, over time

00:23:04.250 --> 00:23:08.740
how you can stop thinking about those things
because, like I say, the end-goal, to make

00:23:08.740 --> 00:23:13.640
securities simple or possible. However, if
this is something that you're really interested

00:23:13.640 --> 00:23:18.920
in, you want to jump off and start using this
OAuth-type style, it is an open standard.

00:23:18.920 --> 00:23:23.520
There are good open source libraries, you
know, for it that you can take a look at on

00:23:23.520 --> 00:23:32.570
oauth.net. So, crypto 101, or called maybe,
you know, crypto 50--it's really a short version,

00:23:32.570 --> 00:23:36.640
if you start playing with this stuff, you
will find that the calling application and

00:23:36.640 --> 00:23:39.880
the receiving application are going to have
to agree on some secure way to communicate

00:23:39.880 --> 00:23:44.740
with each other. The first choice that usually
I have to make is between two of the more

00:23:44.740 --> 00:23:50.320
common crypto algorithms. You'll hear the
words HMAC and symmetric as sort of the simpler

00:23:50.320 --> 00:23:57.450
one. It appears to be more common in the enterprise
scenarios. RSA, a little bit more complicated

00:23:57.450 --> 00:24:01.900
to set off. If you really want to understand
it, grab some box, it's not immediately obvious.

00:24:01.900 --> 00:24:07.890
It does some have security advantages to it.
So, their calling app and the receiving app

00:24:07.890 --> 00:24:12.380
have to pick one of these two and once they've
picked it, they then have to either exchange

00:24:12.380 --> 00:24:17.650
with each other or share a sort of password,
which in this case, they call it secret, or

00:24:17.650 --> 00:24:22.480
in the RSA scenario, they're sort of a pair
of secrets. And each guy knows, roughly speaking,

00:24:22.480 --> 00:24:29.950
one of the two. So, let's assume that's done.
Let me go back to one of the first examples

00:24:29.950 --> 00:24:34.960
I gave that I get asked about. I see it was
the "how do I have a front-end Windows server

00:24:34.960 --> 00:24:40.120
talking to a back-end Linux app, you know,
a cross platform from each other?" The first

00:24:40.120 --> 00:24:44.920
two-part, pretty standard, you know, create
an API endpoint on the Linux server, call

00:24:44.920 --> 00:24:50.260
that from the Windows server. Nothing particularly
tricky there. The third part, not too hard.

00:24:50.260 --> 00:24:55.630
The Window server adds one more URL parameter
with the name of the calling application.

00:24:55.630 --> 00:24:58.880
And, by the way, I see a lot people standing
at the back. There are a bunch of seats up

00:24:58.880 --> 00:25:06.160
front, if you'll all want to come up. It's
where, you know, four and five start to get

00:25:06.160 --> 00:25:09.799
a little bit trickier. You know, step four
is where, okay, these two people, the administrator,

00:25:09.799 --> 00:25:13.080
it's the Linux, and Windows server, do have
to talk with each other, agree on the crypto

00:25:13.080 --> 00:25:18.440
mechanism to use, exchange one of these secrets
with each other. And once they've done that,

00:25:18.440 --> 00:25:22.630
they can openly grab one of these open source
libraries for Windows to sign the request

00:25:22.630 --> 00:25:29.179
and for Linux to verify the request. Step
seven, by the way, is an important one that's

00:25:29.179 --> 00:25:35.720
sadly left out a lot of times, which is--let's
say that Linux server is willing to accept

00:25:35.720 --> 00:25:39.580
request from a couple of different Windows
front-ends, but, you know, with different

00:25:39.580 --> 00:25:43.429
privileges. One of the Windows front-ends
is allowed to say change salaries and the

00:25:43.429 --> 00:25:48.410
other one is only allowed to read information
out of the system. Also, it's not enough for

00:25:48.410 --> 00:25:53.210
the Linux server to just verify the request
as properly signed and then ask to look at,

00:25:53.210 --> 00:25:58.280
oh, okay, and who did it come from and what
operation are they allowed to perform, which,

00:25:58.280 --> 00:26:03.440
obviously, a lot of cases where that step
gets skipped and people assume just verifying

00:26:03.440 --> 00:26:11.020
the signature is enough. So, some of you have
laptops or, you know, phones probably, and,

00:26:11.020 --> 00:26:15.340
hopefully, have started Googling OAuth to
learn a little bit more about it. One morning,

00:26:15.340 --> 00:26:20.190
if you do, I mentioned before, this is a technology
that started in the consumer space and now

00:26:20.190 --> 00:26:24.230
has evolved into the enterprise space. If
you start reading about it, you'll see a lot

00:26:24.230 --> 00:26:29.760
of references to, you know, consumer brands--Yahoo,
AOL, Google, Flickr, a bunch of others--who

00:26:29.760 --> 00:26:34.130
created this. One nice thing to know is they
created this not from scratch, they all had

00:26:34.130 --> 00:26:38.520
sort of proprietary variants over ahead of
time. They tried to merge their best practices,

00:26:38.520 --> 00:26:43.020
come up with a common standard and the security
guides on all these companies keep on banging

00:26:43.020 --> 00:26:48.140
on it and looking for ways to improve it so
you got to leverage all that experience. However,

00:26:48.140 --> 00:26:52.200
if you read about the OAuth standard, you'll
see a lot of description of flows where an

00:26:52.200 --> 00:26:58.520
end-user has to approved application A and
application B talking to each other about

00:26:58.520 --> 00:27:04.299
that user. Consumer scenarios, that makes
sense. You want user consent. In the enterprise

00:27:04.299 --> 00:27:09.059
scenarios or, you know, web-app to web-app
by itself, usually don't need this. It's overly

00:27:09.059 --> 00:27:14.080
complicated. So, if you read about OAuth and
see anything about tokens, just, like, skip

00:27:14.080 --> 00:27:17.840
to the next section. If you see the word token,
just skip to the next section. If you do that,

00:27:17.840 --> 00:27:22.460
you end up throwing out about 2/3 of the OAuth
spec and you're left with something that's

00:27:22.460 --> 00:27:29.340
pretty simple. Pretty simple, but we always
want to try to make it simpler. Like I say,

00:27:29.340 --> 00:27:34.090
you get to the point where security is just
this invisible glue down at the bottom. And

00:27:34.090 --> 00:27:38.260
so let me talk about another standard. We've
talked about OpenID in the sample at the beginning.

00:27:38.260 --> 00:27:43.160
We just talk about OAuth. I'm going to throw
in one more for you, which is OpenSocial.

00:27:43.160 --> 00:27:48.140
So, another consumer-developed standard, however,
one of the things that the OpenSocial community

00:27:48.140 --> 00:27:54.580
realizes, you know what, in the cloud computing
environment, a lot of times the applications

00:27:54.580 --> 00:27:59.809
are run in a container, and the container
knows the identity of the application and

00:27:59.809 --> 00:28:04.760
can provide some services to it to help with
things like identity management. Google and,

00:28:04.760 --> 00:28:11.179
you know, app engines, Salesforce, for example,
provide a lot of features in their containers,

00:28:11.179 --> 00:28:16.480
you know, so do the OpenSocial containers.
And what they realize is, hey, the container

00:28:16.480 --> 00:28:21.700
can provide a function call to the app to
handle all this OAuth signature stuff on the

00:28:21.700 --> 00:28:27.360
application's behalf. So if the app wants
to make this REST call to change Sara's salary,

00:28:27.360 --> 00:28:33.110
it just goes to the container, looks up the
container's specific function to proxy one

00:28:33.110 --> 00:28:37.390
of these URLs and says, "Hey, container, I
want to call this URL and, please, can you

00:28:37.390 --> 00:28:41.960
handle all the signature stuff for me?" And
this is, like I say, already live and open

00:28:41.960 --> 00:28:46.760
search containers, and what the community
right now is trying to do in the OAuth community

00:28:46.760 --> 00:28:51.620
is standardize this working for other containers,
whether it's other Google containers, Salesforce,

00:28:51.620 --> 00:28:59.330
as well as Yahoo, et cetera. So, you know,
let's assume that you do take this type of

00:28:59.330 --> 00:29:03.410
approach and, you know, and your container
can sign the request. Well, the recipient

00:29:03.410 --> 00:29:08.590
is going to get something that looks like,
you know, the request at the top. And one

00:29:08.590 --> 00:29:13.669
of the things that, hopefully, you'll notice
from here is there are now three special parameters

00:29:13.669 --> 00:29:18.250
out instead of two. You know, before there
was the signature and there was this consumer

00:29:18.250 --> 00:29:23.549
key. Now, the OpenSocial guys came with this
idea, "Well, let's you know, throw in, you

00:29:23.549 --> 00:29:27.309
know, a claim as to the source of the calling
application." You know, Microsoft loves to

00:29:27.309 --> 00:29:32.679
talk about claims based [INDISTINCT] management.
In this case, you know, the container, you

00:29:32.679 --> 00:29:38.770
know, appspot.com, is making the claim that
it is sign your request on behalf of a particular

00:29:38.770 --> 00:29:46.809
app like hrtool.appspot.com. So, you know,
to do this, it takes all of the signing work

00:29:46.809 --> 00:29:53.210
off the application. And there's another advantage
to it, which is that the containers can and,

00:29:53.210 --> 00:29:58.169
certainly do in the OpenSocial, they can document
how they're going to do the signing, how they're

00:29:58.169 --> 00:30:03.200
going to do the crypto. They'll give, you
know, very good sample code as to how to verify

00:30:03.200 --> 00:30:08.290
these requests. So, it really offloads a lot
of the complexity for the developer, especially

00:30:08.290 --> 00:30:15.669
developer creating the front-end application.
So, let me give an example now of, you know,

00:30:15.669 --> 00:30:19.980
how this could work, you know, with--once
we've finalized standards for how a container

00:30:19.980 --> 00:30:24.250
like App Engine can do this request. So, if
you want to play with it, just look at how

00:30:24.250 --> 00:30:31.860
OpenSocial containers do it, you know, with
95 percent finalized stuff. So, the first

00:30:31.860 --> 00:30:36.160
thing is, okay, the Amazon app, the one, you
know, not running in the container, still

00:30:36.160 --> 00:30:42.630
needs to expose an API endpoint and the calling
apps still needs to make a request, you know,

00:30:42.630 --> 00:30:47.220
with one of these REST API formats that looks
like URL. Now, though, the only thing that's

00:30:47.220 --> 00:30:51.950
left is, you know, nothing more for the calling
app to do. The Amazon app just needs to look

00:30:51.950 --> 00:30:55.910
at the documentation of the container, find
out what format it used, how it's handling

00:30:55.910 --> 00:31:00.970
digital signatures, hopefully even grab some
sample code, verify the request came from

00:31:00.970 --> 00:31:06.950
this app, and, like I mentioned before, also
check that application has the ability to

00:31:06.950 --> 00:31:13.039
perform this operation. Even more dangerous,
number four, and so I want to [INDISTINCT]

00:31:13.039 --> 00:31:18.289
calling apps again, if the code for verifying
request from a container is consistent, that

00:31:18.289 --> 00:31:23.700
means in this case that the Amazon server
could--will be able to verify a sign request

00:31:23.700 --> 00:31:28.919
from any application running on that container.
So, if all you do is verify the request came

00:31:28.919 --> 00:31:33.380
from that container and then allow it to say
"change Sara's salary," you're in trouble.

00:31:33.380 --> 00:31:40.020
You need to take the extra step of looking
at that previous parameter, this app URL and

00:31:40.020 --> 00:31:47.130
making sure that it is the trusted source
for making the request. So, if you want to

00:31:47.130 --> 00:31:51.780
play with this, now, like say, you can do
this today. You don't have to wait for us

00:31:51.780 --> 00:31:55.830
to, you know, finalized the mechanism for
the container to do the signing. Do the search

00:31:55.830 --> 00:32:00.280
for OAuth Google App Engine, there are software,
for example, out there that do this today,

00:32:00.280 --> 00:32:04.470
not to--or like I say, a bunch of enterprises
are already using them. Again, assuming you're

00:32:04.470 --> 00:32:08.410
comfortable with that, you know, if you want,
you know, wait a little bit longer or start

00:32:08.410 --> 00:32:18.190
out with just a gadget functionality, which
already does the signing. As soon as the industry

00:32:18.190 --> 00:32:21.250
standard community signs off on it, this is
sort of the nice thing, all right, you don't

00:32:21.250 --> 00:32:25.480
want individual companies deciding the final
standards on this 'cause then you'd just have

00:32:25.480 --> 00:32:30.110
to do with [INDISTINCT]. So, we want to make
sure that, you know, and a bunch of us have

00:32:30.110 --> 00:32:33.970
agreed, "Okay, we're all going to do it the
same way." He's asking what it was about.

00:32:33.970 --> 00:32:37.919
I'm going to--and I was saying when the community
as a whole has, you know, agreed with standards

00:32:37.919 --> 00:32:43.559
on it. Google is not trying to this on their
own. Okay, let's make it a little bit more

00:32:43.559 --> 00:32:47.059
complicated. We've talked about, you know,
Window server having Linux server. We talked

00:32:47.059 --> 00:32:51.429
about App Engine app, talking to Amazon. Well,
let's say you're trying to break your way

00:32:51.429 --> 00:32:56.090
through a firewall. You have an application
running on, you know, App Engine, or to be

00:32:56.090 --> 00:33:01.179
honest, on Salesforce, on AdSure, et cetera,
and Amazon and you want to connect to, say,

00:33:01.179 --> 00:33:06.289
you know, some APIs exposed with your ERP
system. Well, now it gets a little bit more

00:33:06.289 --> 00:33:10.270
complicated. There are three things you need
to do. The first is you're going to have to

00:33:10.270 --> 00:33:16.190
find some way to tunnel through that enterprise
firewall to the ERP system. Different softwares--I'm

00:33:16.190 --> 00:33:20.460
sorry, different cloud computing vendors offer
different ways to do this. Google has an offer

00:33:20.460 --> 00:33:24.280
called the Secure Data Connector that's designed
to help with this. There are sessions about

00:33:24.280 --> 00:33:29.510
that later today. Other cloud computing vendors,
you know, suggests using more standard point

00:33:29.510 --> 00:33:35.140
to point VPN tunnels. You know, the standards
there are pretty well established. So, that's,

00:33:35.140 --> 00:33:39.070
you know, the first thing you need to do.
The second thing you need to do is, you know,

00:33:39.070 --> 00:33:44.110
this OAuth-style interaction to verify the
source of the request. However, then there's

00:33:44.110 --> 00:33:49.520
one last thing, which is in most enterprises
situations, if you don't care just about what

00:33:49.520 --> 00:33:54.809
front-end app is making the request, you care
about what user is logged into that front-end

00:33:54.809 --> 00:34:00.480
request. So, you know, who is it that wants
to change Sara's salary tends to be an important

00:34:00.480 --> 00:34:06.830
question when dealing with like an ERP application.
And this is again the case where the OpenSocial

00:34:06.830 --> 00:34:11.480
community saw the same problem and, you know,
came up with a way to address it that a lot

00:34:11.480 --> 00:34:17.080
of enterprises are adopting, which is they
said, "Okay, well, we just need to pass another

00:34:17.080 --> 00:34:23.629
claim as to the identity of the user." And
so, the application, you know, can pass along

00:34:23.629 --> 00:34:29.060
that claim. And it's really up to the back-end
to decide does it trust it. You know, maybe

00:34:29.060 --> 00:34:35.190
some applications it trusts to, you know,
identify or subset abusers. You know, are

00:34:35.190 --> 00:34:40.550
they applications to trust to identify a whole
set? But, in any case, you know, the calling

00:34:40.550 --> 00:34:45.500
application is just going to pass along another
URL parameter with the claimed name of the

00:34:45.500 --> 00:34:51.450
user who's logged in. You could make this
URL parameter named anything you want. However,

00:34:51.450 --> 00:34:55.300
there's a lot of value to being, you know,
having standards about this, to answer your

00:34:55.300 --> 00:34:59.720
earlier questions. You know, a little bit
of variance can be annoying. In the OpenSocial

00:34:59.720 --> 00:35:04.990
community, they have chosen the parameter
OpenSocial viewer e-mail as a common one in

00:35:04.990 --> 00:35:09.160
this scenario. And let me give you an example
of why it might be helpful to follow that

00:35:09.160 --> 00:35:14.820
standard. I'm going to, you know, reverse
this now. In the previous example, it's, okay,

00:35:14.820 --> 00:35:20.720
you know, an app engine trying to make a call
back through the enterprise. What if it's

00:35:20.720 --> 00:35:25.530
the reverse? What if an enterprise is using
some software as service vendor, Salesforce

00:35:25.530 --> 00:35:30.820
or Google Apps, for example, and it wants
to make a call into that SaaS vendor? So a

00:35:30.820 --> 00:35:36.330
common example Google gets is we host a lot
of companies, e-mail and calendar offerings.

00:35:36.330 --> 00:35:40.470
And we actually offer a feature right now,
or what administrator can do is go to Google

00:35:40.470 --> 00:35:45.040
and say, "You know what, I'd like to turn
on this sort of two-legged OAuth interaction

00:35:45.040 --> 00:35:50.520
for my domain. I want one of these OAuth consumer
keys and secrets." And once they have that

00:35:50.520 --> 00:35:54.700
in their hands, they can actually write an
application themselves, run it wherever they

00:35:54.700 --> 00:36:00.780
want, and it can make this two-legged OAuth
calls back to Google, and Google will say,

00:36:00.780 --> 00:36:05.820
"Oh, I just got a request to, in this case,
you know, return the, you know, calendar for

00:36:05.820 --> 00:36:11.280
Tom in a certain domain." Well, one of the
things to note is if the consumer key and

00:36:11.280 --> 00:36:15.730
consumer secret, if all it does is identify
the domain, and the domain wants a particular

00:36:15.730 --> 00:36:20.520
users data, it's going to have to tell us
what user's data it wants. So, we, as Google,

00:36:20.520 --> 00:36:26.550
have to decide what URL parameter we require,
you know, for this information we passed in.

00:36:26.550 --> 00:36:30.849
To be honest, we use a couple a different
ones because, you know, the community is still

00:36:30.849 --> 00:36:34.180
trying to finalize some of the standards on
this, though it's really just standards of

00:36:34.180 --> 00:36:38.670
picking, you know, names to make things as
simple as possible. So, OpenSocial viewer

00:36:38.670 --> 00:36:44.750
e-mail, like I say, is an example of such
a name. This is another topic all in itself.

00:36:44.750 --> 00:36:49.170
If you are a company who has outsourced Google,
if you are interested in learning more about

00:36:49.170 --> 00:36:54.000
how to build your own apps to access these
APIs, there's another session--Building Enterprise

00:36:54.000 --> 00:36:58.660
Applications in the Cloud--that's worth going
to. Common example of using this is maybe

00:36:58.660 --> 00:37:03.300
you want to upload a bunch of data about your
users into the system 'cause you're migrating

00:37:03.300 --> 00:37:10.290
or you want to scan the data to a SaaS vendor
for legal complaint searches, that type of

00:37:10.290 --> 00:37:15.950
thing. Again, though, I want to get back to
my theme of how simple can we make this. So,

00:37:15.950 --> 00:37:20.200
you know, we talked about before that the
OpenSocial community have this idea of, hey,

00:37:20.200 --> 00:37:25.640
allow the container to sign the request on
behalf of the app. In the OpenSocial, what

00:37:25.640 --> 00:37:31.030
they actually do is the container in many
cases knows not only the identity of the application,

00:37:31.030 --> 00:37:36.210
it also knows the identity of the user who's
currently logged in to that application. And

00:37:36.210 --> 00:37:41.800
so what the container will do when you add
this signed parameter is it will actually

00:37:41.800 --> 00:37:46.440
add that viewer's e-mail to the assertion.
It does this by default. In fact, I'm not

00:37:46.440 --> 00:37:52.280
even sure how you'd turn it off. So, now the,
you know, if the container is passing to the

00:37:52.280 --> 00:37:57.290
claim that Tom is logged in and the claim
that it's this particular application that's

00:37:57.290 --> 00:38:02.830
making the request and just to sort of, you
know, steal some, you know, Microsoft's terminology,

00:38:02.830 --> 00:38:07.099
these, you know, claims are all a matter of
trust. Does the back-end application trust

00:38:07.099 --> 00:38:11.900
these claims? And one of the things it has
to decide is does it trust the calling application

00:38:11.900 --> 00:38:16.280
to get the crypto right, to do all that digital
signatures right? And in many cases, you know,

00:38:16.280 --> 00:38:20.680
you're nervous about, you know, your average
software engineer doing this, right? However,

00:38:20.680 --> 00:38:25.330
if the container is run by, you know, an Amazon
or Saleforce, Google, Yahoo, you can be pretty

00:38:25.330 --> 00:38:29.080
sure that they've gotten this right as we
know how and they will evolve it over time

00:38:29.080 --> 00:38:35.070
if need be. So in many cases, these claims
are even more trustworthy than if the application

00:38:35.070 --> 00:38:40.390
sent them. And to give--an even more specific
example is, you know, right now the container

00:38:40.390 --> 00:38:44.530
is asserting that Tom has logged in. Well,
that's an interesting piece of information

00:38:44.530 --> 00:38:49.880
that not only is the action being performed
on behalf of Tom, but he's currently logged

00:38:49.880 --> 00:38:55.430
in to that application. That's not an easy
claim for a standard loan application to make

00:38:55.430 --> 00:39:01.430
and for something else to trust. So, you know,
the app can claim that Tom's logged in, but

00:39:01.430 --> 00:39:06.849
for the container to make that claim in many
cases, it's more trustworthy. Again, you know,

00:39:06.849 --> 00:39:10.380
claims and trust, you know, it's really a
matter for you to make, you know, your decisions,

00:39:10.380 --> 00:39:16.720
but this one of the advantages of containers.
&gt;&gt; [INDISTINCT]

00:39:16.720 --> 00:39:22.300
&gt;&gt; SACHS: So, we're just asking, you know,
more generally, you know, how does the container

00:39:22.300 --> 00:39:27.410
keep track of, you know, [INDISTINCT] other
mechanisms to identify who Tom is? There are

00:39:27.410 --> 00:39:32.170
a lot of various containers, the way that
gadgets do authentication of users is actually

00:39:32.170 --> 00:39:37.430
pretty complex because you have multiple individual
applications running on the page on the user's

00:39:37.430 --> 00:39:42.010
browser, so, there, you know, you have to
deal with complication. It's not just code

00:39:42.010 --> 00:39:47.480
running on the server side, so, significant
complexly there. For things like saleforce.com,

00:39:47.480 --> 00:39:52.810
App Engine, et cetera, if you look at them,
they already provide the applications a way

00:39:52.810 --> 00:39:58.230
for the application running on those platforms
to tell who has logged in. And so the same

00:39:58.230 --> 00:40:01.790
way they do that, they're just adding that
to these assertion information. So, it tends

00:40:01.790 --> 00:40:07.630
to be proprietary to that, you know, platform
as opposed to standard and that--in this case,

00:40:07.630 --> 00:40:11.580
that's fine. But our key goal is to be--have
a standard for how we assert that information.

00:40:11.580 --> 00:40:19.420
Does that a help? We can drill down to it
more after this one. Okay, so, we spent a

00:40:19.420 --> 00:40:25.150
lot of time talking about how to make it easier
to sign these outbound requests and, you know,

00:40:25.150 --> 00:40:29.280
things the industry is doing to, hopefully,
over time, make this even simpler. However,

00:40:29.280 --> 00:40:34.920
there's still the reverse. The calling application
still has to verify the signatures. Fortunately,

00:40:34.920 --> 00:40:39.050
this is much simpler. I mentioned before that,
you know, if the signature is coming from

00:40:39.050 --> 00:40:42.760
a container, a lot of these containers have
really good docs on how to do a really good

00:40:42.760 --> 00:40:47.950
sample code, however, there still is a chance
for mistake. So, one of the things that we're

00:40:47.950 --> 00:40:53.220
trying to figure out is how could we probably
do sort of the reverse of the signing feature

00:40:53.220 --> 00:40:57.849
and instead just verify that one of these
request came in. So, you know, for example,

00:40:57.849 --> 00:41:02.339
a container, you know, an app entered the
Salesforce, Amazon could provide a service

00:41:02.339 --> 00:41:07.050
to verify these request, and you know, if
you want to make a call into it, then you

00:41:07.050 --> 00:41:11.780
would go to Google or Yahoo and say, okay,
how do I get one of these consumer keys, consumer

00:41:11.780 --> 00:41:18.230
secrets, so I can make an inbound sign request.
If you want to play with this today, like

00:41:18.230 --> 00:41:22.510
I said, there's already a software available
to do this for the app engine [INDISTINCT]

00:41:22.510 --> 00:41:27.700
for a couple of examples. But in this software,
you have to bring it in, if it gets updated

00:41:27.700 --> 00:41:31.390
you have to, you know, keep track of that.
So, that's what we want to make simpler over

00:41:31.390 --> 00:41:37.570
time. So, we're actually getting near the
end, so you'd start thinking about your questions.

00:41:37.570 --> 00:41:42.940
We need to take this up, two more levels,
you know, to make a key point at the end.

00:41:42.940 --> 00:41:47.480
Let's talk about how simple, you know, we're
trying to make this, which is--let's use the

00:41:47.480 --> 00:41:52.369
example of two GAE applications. What if you
decide you want to write the front-end of

00:41:52.369 --> 00:41:56.020
your application on the Python version of
Google App Engine and you want to write the

00:41:56.020 --> 00:42:01.680
back-end in, say, the Java version of, you
know, Google App Engine, but you need a way

00:42:01.680 --> 00:42:05.800
for the two to securely communicate with each
other and your backend wants to make sure

00:42:05.800 --> 00:42:10.609
the requests really are in fact coming from
that font-end and out? This is possible today,

00:42:10.609 --> 00:42:14.520
plenty of developers have already done it,
and many of them use these OAuth software

00:42:14.520 --> 00:42:19.609
mechanisms to do it. However, our goal is
to get to the point where that first application

00:42:19.609 --> 00:42:26.200
just makes a sign request fall into this OpenSocial-style
standard and the receiving system gets the

00:42:26.200 --> 00:42:32.220
URL listed under GAE app 2. You know, a request
to change Sara's salary where it sees it comes

00:42:32.220 --> 00:42:39.740
from Tom, sees the calling GAE application
and all it does now is verify the signature

00:42:39.740 --> 00:42:44.970
is accurate first. Second thing, like I say,
very, very important, don't forget this, make

00:42:44.970 --> 00:42:50.730
sure that the app who made the request is
actually allowed to perform the operation.

00:42:50.730 --> 00:42:55.570
Verifying the signature by itself is not sufficient.
And now I can look at the value of Tom and

00:42:55.570 --> 00:42:59.080
Sara and see, "Hey, is Tom allowed to change
Sara's salary? Is he her boss or, you know,

00:42:59.080 --> 00:43:05.710
an HR Manager?" So, you know, physical, you
know, replace this software for URL verify

00:43:05.710 --> 00:43:10.750
and the software for URL fetch, you know,
with services that can do this in our app

00:43:10.750 --> 00:43:16.180
so that the applications just need to perform
this access control checks. That's between

00:43:16.180 --> 00:43:21.250
two GAE apps though. The reason for trying
to do this as a standard is, like I say, you

00:43:21.250 --> 00:43:24.760
can already do that, that's not the most interesting
thing in the world. What the OAuth community

00:43:24.760 --> 00:43:29.420
and what other companies are trying to do
is how do you do these mashups across cloud

00:43:29.420 --> 00:43:33.430
computing platform? How do you have an app
on Azure to make a call to an app on Amazon

00:43:33.430 --> 00:43:39.680
or an app on Salesforce make a call to Google
App Engine and, you know, for the containers

00:43:39.680 --> 00:43:44.050
to establish standards on how to do all these
crypto to each other so that you don't even

00:43:44.050 --> 00:43:48.349
think about it? You just say, "I want to make
a request. Here is the URL at that point I'm

00:43:48.349 --> 00:43:52.250
trying to hit. I want it signed". If you are
the receiving system, you get the request.

00:43:52.250 --> 00:43:57.849
You say I want to verify it, "Oh great, it
came from another container that interrupts

00:43:57.849 --> 00:44:01.970
with the container I'm hosting." You know,
this is where the community is trying to get,

00:44:01.970 --> 00:44:06.510
it's to use OAuth as a way to do these types
of screen mashups across different cloud computing

00:44:06.510 --> 00:44:12.660
platforms. And so, like I say, for those of
you who want to do stuff like this today,

00:44:12.660 --> 00:44:18.650
the software does exist, plenty of enterprises
use it for some pretty high value transactions.

00:44:18.650 --> 00:44:24.200
Look at some of the websites or web searchers
have reference to get more detail. But, in

00:44:24.200 --> 00:44:27.790
particular, I'm hoping this is a very tight,
highly sophisticated audience, we just like

00:44:27.790 --> 00:44:31.980
in the federated login space, we are looking
for more people to help us, you know, flush

00:44:31.980 --> 00:44:36.010
out all of these stands. We have great people
from all these different companies, Microsoft,

00:44:36.010 --> 00:44:41.770
Amazons, Salesforce and Google. It represents
a good mix up in this space, but we'd like

00:44:41.770 --> 00:44:45.880
to hear more. In particular, many of us are
a little bit more focused on the consumers'

00:44:45.880 --> 00:44:49.460
space. We need a bit more enterprise prospective.
To be honest, sometimes we need to be banged

00:44:49.460 --> 00:44:54.080
up the side of the head to remember that the
enterprise segment is a little bit different.

00:44:54.080 --> 00:44:58.770
And so, if you want to get involved in this,
OAuth mail list is a public one. There are

00:44:58.770 --> 00:45:02.339
other great industry conferences like the
Internet Identity Workshop that just happened

00:45:02.339 --> 00:45:07.260
last week where there was a lot of good discussions
to finalize this stuff in the next few weeks,

00:45:07.260 --> 00:45:11.780
and, so, I'd hope you would come to that in
the future. So, you know, I'm going to stay

00:45:11.780 --> 00:45:15.720
around for questions for people who want to
go up the mics. I'll also be around after,

00:45:15.720 --> 00:45:20.080
so if people want to catch me in the hall,
if you want to learn even more about OAuth

00:45:20.080 --> 00:45:24.540
while you're here at the conference, stop
by the OAuth helpdesk. And if you want to

00:45:24.540 --> 00:45:28.700
get more details about pretty much anything
I'd talked about, let's say, do a Google search

00:45:28.700 --> 00:45:34.030
for OAuth Goog, the first website there has
a ton of information about all of the things

00:45:34.030 --> 00:45:38.500
we talked about today. And what you'll see
is it's not just information from Google.

00:45:38.500 --> 00:45:44.180
There's a great usability research links from
Yahoo, Facebook, Plaxo, et cetera. A lot of

00:45:44.180 --> 00:45:49.560
different people play in this space and, like
I say, we're looking for other people to play

00:45:49.560 --> 00:45:58.260
in the space to help us at OAuth. Thank you
very much for y'all's time. And like I say,

00:45:58.260 --> 00:46:01.380
if people just want to go up to the mic and
ask questions, I'll do my best to answer as

00:46:01.380 --> 00:46:04.660
much as can now and stay after for people
who want more detailed information.

00:46:04.660 --> 00:46:09.540
&gt;&gt; A lot of us have Legacy applications that
have their own layering of authentication,

00:46:09.540 --> 00:46:19.680
authorization, and somehow we are trying to
connect with cloud deployed. And so we're

00:46:19.680 --> 00:46:25.070
looking both for authentication as well as
authorization, not just authentication alone

00:46:25.070 --> 00:46:32.460
with--minding that the ID is different as
well as the password maybe different in different

00:46:32.460 --> 00:46:35.330
Legacy systems.
&gt;&gt; SACHS: Right. And, so, there are a couple

00:46:35.330 --> 00:46:39.020
of different piece app, one of things he's
asking is, "Hey, what if we have a Legacy

00:46:39.020 --> 00:46:40.599
system, what is it designed to do with all
these OAuth and REST API from the beginning?

00:46:40.599 --> 00:46:48.440
What if it was designed to deal with more
like a WS-Trust or something else?" This is

00:46:48.440 --> 00:46:52.070
where, you know, again, community stuff is
really helpful. A lot of the companies that

00:46:52.070 --> 00:46:55.990
have been more in the enterprise space, you
know, Microsoft, IBM, CA, et cetera, are coming

00:46:55.990 --> 00:47:00.619
and saying exactly it's, you know, hey, there
is this API endpoint in the enterprise. All

00:47:00.619 --> 00:47:06.369
it knows and how to do is to get a blob in
this HTTP header and then to either statically

00:47:06.369 --> 00:47:12.260
validate it in a certain way or send it over
to this internal token server to verify it.

00:47:12.260 --> 00:47:17.430
So, one of the things that we're working to
try to standardize OAuth is how can a calling

00:47:17.430 --> 00:47:21.410
application make a request to the enterprise
and go there like a central sort of enterprise

00:47:21.410 --> 00:47:24.730
and go to [INDISTINCT] enterprise and say,
"Hey, I want to talk to your ERP application.

00:47:24.730 --> 00:47:29.530
Can you be a little bit more sophisticated,
can you talk OAuth, so I can prove who I am

00:47:29.530 --> 00:47:34.260
and give me back a token that maybe only lasts
for five minutes, that I can then send to

00:47:34.260 --> 00:47:38.810
a more Legacy application that, you know,
only it deals with a token and a proprietary

00:47:38.810 --> 00:47:43.339
format?" So, how do you use OAuth as a way
to bootstrap, grabbing one of this piece of

00:47:43.339 --> 00:47:47.510
information? So that, you know, that's part
of it. Another part is, okay, a lot of those

00:47:47.510 --> 00:47:53.579
applications are looking for assertions in
that blob as to say, you know, the membership

00:47:53.579 --> 00:47:58.460
of that group, like, you know, is he in the
auditors, you know, team for example. And,

00:47:58.460 --> 00:48:04.380
again, these central identity services, token
service, whatever you want to call it, they

00:48:04.380 --> 00:48:08.710
can use OAuth as a way to bootstrap, you know,
get information about, say, you know, Tom

00:48:08.710 --> 00:48:13.500
in my example or the application URL, and
then swap it with, say, this proprietary blob

00:48:13.500 --> 00:48:18.310
that still has Tom's name and maybe even [INDISTINCT]
company and looked up and said, "Is Tom an

00:48:18.310 --> 00:48:23.490
HR person?" and then stick that in the blob
that, you know, it sent along. And so Ping,

00:48:23.490 --> 00:48:29.079
IBM, CA, et cetera, they already provide these
types of token servers that run in an enterprise

00:48:29.079 --> 00:48:34.329
and deal with things WS-Trust, WS-Fed, SAML,
et cetera, and OAuth is just another, you

00:48:34.329 --> 00:48:38.930
know, combination in the alphabets soup mix
that they're looking to see can they act as

00:48:38.930 --> 00:48:44.030
a bridge, you know, to these central applications,
just as in one of your early examples I showed,

00:48:44.030 --> 00:48:48.640
how PingConnect can be sort of a broker bridge
to a lot of federated login offenders. These

00:48:48.640 --> 00:48:53.890
guys are trying to write software to be that
sort of last half-mile bridge. And, hopefully,

00:48:53.890 --> 00:49:00.230
that's helpful. We can talk more if you want
to... Yeah?

00:49:00.230 --> 00:49:03.990
&gt;&gt; So, there's--there has been a lot of focus.
I use Amazon Interview quite a bit and now

00:49:03.990 --> 00:49:10.400
I'm kind of trying to link a couple of things
between Amazon and the Google App Engine,

00:49:10.400 --> 00:49:15.720
the security, there's been a lot of focus
to use GET as opposed to POST, and a lot of

00:49:15.720 --> 00:49:19.520
times if we have data that we're actually
trying to send over and I understand the purpose

00:49:19.520 --> 00:49:25.900
of using, you know, the signatures, if you're
adding--I mean you're limiting the size of

00:49:25.900 --> 00:49:30.109
this URL and we're limited by that and, ultimately,
I mean, we have to do something about this.

00:49:30.109 --> 00:49:33.050
And if somebody--and also if somebody wants
to just mess with the system for the sake

00:49:33.050 --> 00:49:34.270
of messing with it and just choose 200 lines
with their names for the username...

00:49:34.270 --> 00:49:36.180
&gt;&gt; SACHS: Yup.
&gt;&gt; ...this thing breaks.

00:49:36.180 --> 00:49:40.490
&gt;&gt; SACHS: Right.
&gt;&gt; So, what's your solution to that?

00:49:40.490 --> 00:49:45.430
&gt;&gt; SACHS: So, you might want to catch Bryan
and he'll help us afterwards for more detail.

00:49:45.430 --> 00:49:49.710
There is a mix for, you know, body signing
as opposed to just signing the head. We're

00:49:49.710 --> 00:49:53.500
not seeing it getting used as much as we would
have anticipated. Like, we felt we were going

00:49:53.500 --> 00:49:58.030
to run into that URL problem, like, six, nine
months ago. We proposed some standards for

00:49:58.030 --> 00:50:01.810
how to deal with it. I'm not sure if they've
been finalized. Like, I think they're, like,

00:50:01.810 --> 00:50:06.950
they're posted, some people used them. But
they haven't just been used enough for people

00:50:06.950 --> 00:50:10.630
to say it absolutely works, you know. We have
data that that function works, enough individuals,

00:50:10.630 --> 00:50:14.780
but we'd like to see heavier user Java to
sort of, you know, formally ratify, yes, this

00:50:14.780 --> 00:50:19.180
is the correct way to do it. The other challenge
that we have, again, for those who want to

00:50:19.180 --> 00:50:23.890
get more deeper in the crypto aspect is creating
these signatures is complicated. A lot of

00:50:23.890 --> 00:50:28.800
people find that signing something that's
in a URL format has a lot of complexity to

00:50:28.800 --> 00:50:33.920
it. Signing just a blob that's, you know,
in the body, is in many case actually easier.

00:50:33.920 --> 00:50:40.190
So not only does it avoid the length problems,
but in many case it's just easier. So, I think

00:50:40.190 --> 00:50:44.220
search for OAuth body signing, Bryan is that...
Yeah, so, if you do a Google search for all

00:50:44.220 --> 00:50:47.560
that body signing, you'll see a spec for how
people are doing for some of that today.

00:50:47.560 --> 00:50:54.800
&gt;&gt; [INDISTINCT]
&gt;&gt; SACHS: So, for those of you here, if you--Bryan

00:50:54.800 --> 00:50:58.450
is saying, if you got a lot of data, you have
to use POST. You really don't have another

00:50:58.450 --> 00:51:05.470
option for you. Cool. Great. Anyone else who
want to volunteer and stand up for the mic?

00:51:05.470 --> 00:51:10.980
If not, like I say, I'm going to hang around
and answer questions individually.

00:51:10.980 --> 00:51:16.329
&gt;&gt; I also have a question in regards to the
container authenticating to multiple applications

00:51:16.329 --> 00:51:25.339
and potentially having a cookie for each application.
How does the web browser secure the--or attempt

00:51:25.339 --> 00:51:31.329
to secure those cookies so they cannot be
stolen by some other application running inside

00:51:31.329 --> 00:51:37.940
the web browser so that they're in a secured
container that can only be accessed by one

00:51:37.940 --> 00:51:43.380
of the member applications within that container?
&gt;&gt; SACHS: All right. The dumb version is use

00:51:43.380 --> 00:51:48.300
one sub-domain for app if you're able to do
that, which they, you know, like Google App

00:51:48.300 --> 00:51:53.680
Engine can. If, however, your apps ran a single
domain like they do with gadgets, this becomes

00:51:53.680 --> 00:51:57.810
a much more with complex story. In fact, like
it's so complex that that's why OpenSocial

00:51:57.810 --> 00:52:01.560
had to be a standard. So, it could be pushed
out there and other people could look at the

00:52:01.560 --> 00:52:05.829
code and see that, "Oh, yes, they did find
a way to do that." It's very tricky. It took

00:52:05.829 --> 00:52:10.650
a while to get it right, probably nine months,
and most of it was Bryan [INDISTINCT] over

00:52:10.650 --> 00:52:14.400
there, by the way, if you're asking for more
details. But, like I say, people weren't sure

00:52:14.400 --> 00:52:18.210
was it even going to be possible, so we had
to make, you know, open source [INDISTINCT]

00:52:18.210 --> 00:52:22.710
so people could review and say, "Oh, yeah,
actually, you know, those mechanisms do work."

00:52:22.710 --> 00:52:28.970
And, usually, it involves still running each
gadget and its own sub-domain actually with

00:52:28.970 --> 00:52:35.030
a--unique to that sub-domain token that identifies
the user to the user's web--you know, to the

00:52:35.030 --> 00:52:39.720
end-user, it looks like they're all running
within one URL, one domain, but, you know,

00:52:39.720 --> 00:52:45.210
there are hidden iFrames to independent sub-domains.
Okay? Sure.

00:52:45.210 --> 00:52:51.290
&gt;&gt; And my next question was, I don't know
if you have mentioned the secure mashups of

00:52:51.290 --> 00:52:53.190
framework...
&gt;&gt; SACHS: Right.

00:52:53.190 --> 00:52:55.740
&gt;&gt; ...and the availability of those secured
channels between two, for instance, two widgets

00:52:55.740 --> 00:52:58.130
or two gadgets running within your browser
where they can encrypt the communication,

00:52:58.130 --> 00:53:05.410
they can, if you will, authenticate each other
and exchange data within the browser itself.

00:53:05.410 --> 00:53:10.750
&gt;&gt; SACHS: Yeah, so if you're--so, put yourself
around, if you do have a multiple gadgets,

00:53:10.750 --> 00:53:14.930
say, running on a page and they want to communicate
with each other, they can communicate through

00:53:14.930 --> 00:53:19.339
the server side channel. It tends to be slow,
you know, a lot of latency. There are a lot

00:53:19.339 --> 00:53:23.900
of tricks, and then the various web browsers,
how they can communicate within the page,

00:53:23.900 --> 00:53:28.250
however, the variance across the different
web browsers is pretty high. So, actually

00:53:28.250 --> 00:53:34.420
there is, I think it's called IFPC, is an
open source set of code within OpenSocial

00:53:34.420 --> 00:53:38.310
that actually has, like, eight different ways
of doing this and auto detects, you know,

00:53:38.310 --> 00:53:43.220
what browser is used and what, you know, browser,
you know, version is used and then it tries

00:53:43.220 --> 00:53:52.160
to use the fastest one. So, some of that code
is actually available and you can grab it

00:53:52.160 --> 00:53:54.050
if you want to use it.
&gt;&gt; Thank you.

00:53:54.050 --> 00:53:55.530
&gt;&gt; SACHS: Sure.
&gt;&gt; Yeah, hi. I have a question. I really like

00:53:55.530 --> 00:54:00.670
REST APIs, et cetera, really awesome. But
is there any thoughts within OAuth to support

00:54:00.670 --> 00:54:06.040
other RPC protocols like XML-RPC or JSON-RPC
which steal around over HTTP?

00:54:06.040 --> 00:54:11.349
&gt;&gt; SACHS: Sure. So, there actually are a lot
of enterprises who use it for basically SOAP

00:54:11.349 --> 00:54:16.349
request. What they end up doing, like SOAP,
you know, short version is SOAP generally

00:54:16.349 --> 00:54:21.220
suggests putting the identity of the calling
app and even the calling user within the payload

00:54:21.220 --> 00:54:25.030
of the application. And what we're seeing
a lot of enterprise doing is saying, "You

00:54:25.030 --> 00:54:29.410
know what, just take those two parameters
and pass them in the URL and use OAuth to

00:54:29.410 --> 00:54:34.430
sign them and have the SOAP endpoint get everything
it needs other than those two parameters from

00:54:34.430 --> 00:54:39.730
the requests." So, we see that one. The other
variant we see slightly more complicated is

00:54:39.730 --> 00:54:44.119
that if the enterprise does have one of these
on-site sort of tokens server things that

00:54:44.119 --> 00:54:48.940
were mentioned before, you--you're, you know,
calling application can make your call to

00:54:48.940 --> 00:54:54.050
that one that's just OAuth and get back a
blob and then stick that blob in the SOAP

00:54:54.050 --> 00:54:58.310
parameter that it makes, you know, to a final
Legacy endpoint. So, those are two different

00:54:58.310 --> 00:55:08.970
models that we're seeing now. It's not obvious
if one is better than the other or if it really

00:55:08.970 --> 00:55:16.030
just depends on the used case.
&gt;&gt; One issue that you didn't really deal with,

00:55:16.030 --> 00:55:19.579
and I don't know if this the appropriate form,
but really handling the different secrets

00:55:19.579 --> 00:55:23.780
and keys and so forth because...
&gt;&gt; SACHS: Yes, "crypto high G" as we call

00:55:23.780 --> 00:55:27.859
it. That's probably the number one reason
we'd like to change this from being a software-based

00:55:27.859 --> 00:55:32.020
solution to a service-based offering. Like
I say, you know, if the application is running

00:55:32.020 --> 00:55:35.859
on two different containers and, you know,
Google on one side and Yahoo on the other

00:55:35.859 --> 00:55:39.599
side are doing all the crypto underneath,
I'm going to trust them to get the crypto

00:55:39.599 --> 00:55:44.079
right to rotate the secrets frequently, you
know, use RSA to bootstrap each track and

00:55:44.079 --> 00:55:50.390
all these, you know, tricky things. So, yes,
right now, it is very common for, sadly, enterprise

00:55:50.390 --> 00:55:54.970
at some point and stuff, "not have a good
crypto hygiene." For those of you who are,

00:55:54.970 --> 00:55:59.060
you know, too involved in this, the most common
example is an administrator, an access to

00:55:59.060 --> 00:56:03.130
one of these powerful secrets and he leaves
the company or he's fired and you don't change

00:56:03.130 --> 00:56:07.500
it and he still has it and he can make, you
know, request and impersonate one of your

00:56:07.500 --> 00:56:12.359
applications. So, getting the crypto hygiene
is good. While containers are trying to getting

00:56:12.359 --> 00:56:16.619
into this, like I said, PingConnect is offerings
some early versions of an OAuth platform to

00:56:16.619 --> 00:56:22.210
also deal with the stuff, however, the standards
for that type of crypto hygiene doing it automatically

00:56:22.210 --> 00:56:27.369
are still only in just propose stages. We
haven't seen solid use of them yet to decide

00:56:27.369 --> 00:56:36.420
what's the best approach. Okay. I think we're
at a good stopping point. So I appreciate

00:56:36.420 --> 00:56:39.900
all of you who all came by and didn't run
off to get your new toys. Thanks.

