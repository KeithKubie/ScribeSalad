WEBVTT
Kind: captions
Language: en

00:25:33.106 --> 00:25:35.106
&gt;&gt; Welcome to Google I/O 2018.

00:25:37.395 --> 00:25:38.598
We're happy you joined us to 
celebrate platform improvements 

00:25:38.599 --> 00:25:41.479
at Google.  Right now you 
checked into registration to see

00:25:41.480 --> 00:25:43.480
your badge.

00:25:44.932 --> 00:25:46.932
It must be visibly warn at all 
times 

00:25:47.998 --> 00:25:50.861
and you'll need it to enter the 
I/O shuttles and enter the 

00:25:50.862 --> 00:25:52.862
end-of-day activities one and 
two

00:25:55.592 --> 00:25:57.592
Make sure to visit Google.
com/I/O.

00:26:00.492 --> 00:26:02.492
Or download the Google app for 
the 

00:26:03.678 --> 00:26:05.317
most up-to-date information
     Chat with any staff member 

00:26:05.318 --> 00:26:07.369
wearing a yellow badge.

00:26:12.321 --> 00:26:13.963
Sessions will take place in the 
aphitheater as well as the eight

00:26:13.964 --> 00:26:16.840
stages throughout the venue.  If
you haven't already reserve a 

00:26:16.841 --> 00:26:18.841
seat 

00:26:21.512 --> 00:26:23.950
for your favorite session on the
app.  If you miss a session, 

00:26:23.951 --> 00:26:25.785
don't worry recordings will be 
available shortly after they 

00:26:25.786 --> 00:26:27.786
end.

00:26:32.693 --> 00:26:34.758
Be sure to visit the codelabs 
codelabs Google staff will be 

00:26:34.759 --> 00:26:36.400
online for helpful advice and 
provide direction if you need 

00:26:36.401 --> 00:26:38.401
support

00:26:40.089 --> 00:26:42.766
Make some time to visit the 
office hours to meet one-on-one 

00:26:42.767 --> 00:26:45.647
with Googlers and ask your 
questions and get feedback on 

00:26:45.648 --> 00:26:49.912
your projects.  If you're 
looking to network with Googlers

00:26:49.913 --> 00:26:51.913
and fellow developers, join one 

00:26:52.961 --> 00:26:54.961
of the several meetups hosted in
the lounge

00:26:55.934 --> 00:26:58.575
Finally visit the sandbox domes 
where you can explore, learn, 

00:26:58.576 --> 00:27:00.576
and play 

00:27:02.054 --> 00:27:04.082
with the latest demos, physical 
installations and more.  After 

00:27:04.083 --> 00:27:06.721
sessions are done for the day, 
stick around for foods, drinks, 

00:27:06.722 --> 00:27:09.975
music and fun and be prepared 
for some surprises along the 

00:27:09.976 --> 00:27:13.221
way.  We would like to take this
opportunity to remind you that 

00:27:13.222 --> 00:27:15.222
we are  dedicating to providing 
an inclusive event experience 

00:27:18.345 --> 00:27:20.365
for everyone, and that by 
attending Google I/O you agree 

00:27:20.366 --> 00:27:22.366
to our code of conduct posted 
throughout the venue

00:27:23.656 --> 00:27:25.895
Your opinion is valuable to us. 
After the event, look out for a 

00:27:27.715 --> 00:27:29.141
feedback form to share your 
experience.  Thanks for 

00:27:29.142 --> 00:27:31.142
attending and have a 

00:27:32.611 --> 00:27:34.611
wonderful time exploring Google 
I/O.

00:27:45.422 --> 00:27:48.153
(music)
     &gt;&gt; At this time, please 

00:27:48.154 --> 00:27:52.849
find your seat.  Our session 
will begin soon.

00:27:56.466 --> 00:27:58.466
(music)

00:30:25.913 --> 00:30:28.772
     &gt;&gt; Come on up, guys.

00:30:36.858 --> 00:30:38.858
(Applause)

00:30:40.608 --> 00:30:42.608
     &gt;&gt; Hello everyone.

00:30:47.462 --> 00:30:49.564
Good morning and welcome to 
fragment in an architecture 

00:30:49.565 --> 00:30:53.273
components world.  In the case 
of architecture components a lot

00:30:53.274 --> 00:30:55.122
of people have been asking 
questions, like how do all of 

00:30:55.123 --> 00:30:57.949
these things fit together.  
Hopefully we'll able to answer 

00:30:57.950 --> 00:31:00.000
some of those questions today.
     First, just a little bit of

00:31:00.001 --> 00:31:02.001
history.

00:31:04.095 --> 00:31:05.313
The Fragment APIs go back to 
2010 is when they were first 

00:31:05.314 --> 00:31:07.314
initially written 

00:31:08.972 --> 00:31:10.972
and 2011 when there was a little
more 

00:31:12.241 --> 00:31:14.241
widespread availability.  At the
very beginning everybody just 

00:31:15.707 --> 00:31:19.571
started with the activity when 
you were writing a Android app. 

00:31:19.572 --> 00:31:21.623
The the main method with the 
lifecycle.  The entry point to 

00:31:21.624 --> 00:31:24.464
the application.  The launcher 
launches activity, you 

00:31:27.533 --> 00:31:29.764
get the create, start, resume, 
et cetera, events that you all 

00:31:29.765 --> 00:31:31.988
know and love
     It will create views for 

00:31:31.989 --> 00:31:36.867
you, it creates the window, 
gives you a place to view your 

00:31:36.868 --> 00:31:41.382
view hierarchy where you do most
of the UI work.  It binds the 

00:31:41.383 --> 00:31:43.437
consent from the app state, or 
at least this is where people 

00:31:44.454 --> 00:31:48.717
tended to do it.  Keep in mind 
this was fairly early in the 

00:31:48.718 --> 00:31:50.771
Android public lifecycle.  
Everybody had a habit of piling 

00:31:52.795 --> 00:31:54.238
everything into one activity 
because apps were a lot more 

00:31:54.239 --> 00:31:56.461
simple than they are today
     Of course, you listen to UI

00:31:56.462 --> 00:32:00.769
events and update that app state
from there as well.  So there 

00:32:00.770 --> 00:32:02.396
are so many incoming events, it 
really kind of became this 

00:32:02.397 --> 00:32:04.626
plumbing exercise to try to 
break it up yourself, 

00:32:09.308 --> 00:32:11.308
and so people ended up with 
these very

00:32:13.817 --> 00:32:15.817
monolithic activities.  And 
Android tablets became a thing, 

00:32:17.678 --> 00:32:19.922
and we thought how do you make a
tablet UI?  You take one phone 

00:32:19.923 --> 00:32:23.596
UI, you take another phone UI 
and smack them together and you 

00:32:23.597 --> 00:32:25.597
have a tablet UI, right.  What 
could go wrong?

00:32:26.654 --> 00:32:28.717
So we needed to answer the 
question of how to stick two 

00:32:28.718 --> 00:32:32.832
phone UIs together and make sure
it still works on a phone.  And 

00:32:32.833 --> 00:32:36.311
fragments were kind of our 
answer to this question.

00:32:38.578 --> 00:32:40.001
So as an example here, this 
approach actually worked pretty 

00:32:40.002 --> 00:32:42.002
well for some applications.

00:32:44.480 --> 00:32:46.106
Gmail is a great example.  If 
you take a look you have the 

00:32:46.107 --> 00:32:50.160
list of conversations to your 
current conversation that you're

00:32:50.161 --> 00:32:53.242
taking a look at, and there is 
not a whole lot of difference 

00:32:53.243 --> 00:32:55.243
here between the phone version 
that you drill into versus 

00:32:57.338 --> 00:32:59.338
something that you can show side
by side 

00:33:03.037 --> 00:33:05.037
in a two  two-pane UI.

00:33:11.042 --> 00:33:13.479
fragments were allowed to split 
up the two UI classes.  We were 

00:33:13.480 --> 00:33:15.311
seeing the pain developers were 
feeling and activity classes 

00:33:15.312 --> 00:33:18.568
were getting really big and hard
to  manage, so we wanted to see,

00:33:18.569 --> 00:33:20.569
could we allow for you to 
decouple some of the various 

00:33:22.058 --> 00:33:23.870
things that your activity 
classes are doing to sort of 

00:33:23.871 --> 00:33:25.871
relieve a little bit of that 
pressure.

00:33:27.556 --> 00:33:29.994
So that means that anything a 
fragment can do, or anything an 

00:33:29.995 --> 00:33:34.106
activity can do, a fragment had 
to be able to do too, and that 

00:33:34.107 --> 00:33:35.537
guided a whole lot of the API 
design from the beginning, so 

00:33:35.538 --> 00:33:39.596
that meant that you needed to 
have  lifecycle events, and that

00:33:39.597 --> 00:33:42.051
meant that you needed to be able
to manage a view hierarchy

00:33:43.473 --> 00:33:45.701
It meant that you needed to be 
able to deal with a saved 

00:33:45.702 --> 00:33:47.702
instance state, so 

00:33:49.171 --> 00:33:50.798
packaging everything up into a 
bundle or parcellables so if 

00:33:50.799 --> 00:33:54.752
your application got killed in 
the background you could restore

00:33:54.753 --> 00:33:56.986
from that in a clean way.  And 
other things as well like 

00:33:58.413 --> 00:34:00.413
nonconfiguration instance object

00:34:02.634 --> 00:34:04.634
passing, and that's always kind 
of a

00:34:10.244 --> 00:34:12.244
a mouthful but it allows you to 
pass 

00:34:14.153 --> 00:34:16.153
across that doesn't kill the 
idea

00:34:17.209 --> 00:34:19.034
If you were navigating between a
single opportunity we want to 

00:34:19.035 --> 00:34:24.118
make sure you preserve the same 
backstack activity from just 

00:34:24.119 --> 00:34:26.119
calling activity from screen to 
screen

00:34:26.578 --> 00:34:28.411
So, along the way we asked the 
question, can we fix some other 

00:34:28.412 --> 00:34:30.412
APIs that were really kind of a 
pain in the 

00:34:33.307 --> 00:34:35.307
neck in Android to use?

00:34:36.827 --> 00:34:39.093
Unretained, nonconfiguration 
instance, again kind of a 

00:34:39.094 --> 00:34:42.632
mouthful.  This had some 
problems because you only got 

00:34:42.633 --> 00:34:44.476
one object that you could pass 
from activity instance to 

00:34:44.477 --> 00:34:46.305
activity instance
     We didn't give you any easy

00:34:46.306 --> 00:34:50.790
or standardized way to multiplex
different objects together so 

00:34:50.791 --> 00:34:52.791
for example if you were 
composing multiple libraries, we

00:34:53.243 --> 00:34:55.690
didn't give you a whole lot of 
help.  This was all boilerplate 

00:34:55.691 --> 00:34:57.691
that you had to write yourself.

00:35:00.201 --> 00:35:03.877
Activityshowdialogue.  Anybody 
remember this?  A few people.  

00:35:03.878 --> 00:35:06.115
Okay.
     &gt;&gt; IAN LAKE:  Please forget

00:35:06.116 --> 00:35:09.788
it immediately.
     &gt;&gt; ADAM POWELL:  Yeah, 

00:35:09.789 --> 00:35:11.846
please forget it.  This was 
essentially a way to get the 

00:35:13.458 --> 00:35:14.894
activity to do something that we
knew was missing and kind of a 

00:35:14.895 --> 00:35:17.969
pain in the neck.  In allowed 
you to make the activity on 

00:35:21.242 --> 00:35:22.655
the other side after a 
configuration change, the new 

00:35:22.656 --> 00:35:26.718
instance of your activity reshow
what is semantically the same 

00:35:26.719 --> 00:35:29.375
dialogue.
     We also had this thing, 

00:35:29.376 --> 00:35:32.856
local activity manager, tab 
host, does anybody remember this

00:35:32.857 --> 00:35:36.926
one?  Wow!  That is a lot more 
hands than I thought I would 

00:35:36.927 --> 00:35:39.569
see.
     So some of you might 

00:35:39.570 --> 00:35:42.854
remember this from say the 
example of the original dialer 

00:35:42.855 --> 00:35:47.186
and contacts app back in kind of
the Android 2.0 days.  And as 

00:35:47.187 --> 00:35:49.014
you've swopped between tabs, 
between the normal number pad 

00:35:49.015 --> 00:35:52.665
and your contact list or call 
log, et cetera, those were 

00:35:52.666 --> 00:35:55.113
actually separate activities 
showing within a smaller window 

00:35:55.114 --> 00:35:58.973
within an activity, this idea of
nesting activities was something

00:35:58.974 --> 00:36:01.221
that we started offering very 
early.  It had a lot of other 

00:36:01.222 --> 00:36:05.486
issues though.  Activities made 
a whole lot of promises that 

00:36:05.487 --> 00:36:08.144
local activity manager had a lot
of trouble trying to uphold so 

00:36:08.145 --> 00:36:12.468
we tried to tighten that 
interface a little better for 

00:36:12.469 --> 00:36:14.099
something composable like 
fragments that would be able to 

00:36:14.100 --> 00:36:16.150
do the same thing but with a 
little more  expected behavior.

00:36:17.586 --> 00:36:21.242
     &gt;&gt; IAN LAKE:  Right, so 
this whole idea of being able to

00:36:21.243 --> 00:36:25.568
break up your activity and make 
it into kind of composable 

00:36:25.569 --> 00:36:27.569
pieces, you know, we have 

00:36:29.690 --> 00:36:32.337
this giant monolith of activity 
and other methods of factoring 

00:36:32.338 --> 00:36:34.338
it out into 

00:36:36.604 --> 00:36:39.243
different piece, but for 
fragments our approach was to 

00:36:39.244 --> 00:36:41.244
move the loosely associated 
code, the view and all of the 

00:36:42.732 --> 00:36:44.732
state around that view, into a 
separate fragment.

00:36:44.773 --> 00:36:47.205
And you basically just keep 
doing this until you've kind of 

00:36:47.206 --> 00:36:50.912
segmented out your activity into
something that looks slightly 

00:36:50.913 --> 00:36:52.913
more reasonable, right.  You may
have a couple of fragments in 

00:36:55.994 --> 00:36:58.025
here that kind of have their own
specific requirements and their 

00:36:58.026 --> 00:37:02.718
own specific UI, and your 
activity just becomes more of a 

00:37:02.719 --> 00:37:05.780
shell for this.
     But soon after we started 

00:37:05.781 --> 00:37:07.781
getting 

00:37:09.889 --> 00:37:11.916
into this and when it came up to
around Jelly Bean, people were 

00:37:11.917 --> 00:37:14.783
like but this isn't enough.  
What if one of my fragments has 

00:37:14.784 --> 00:37:20.081
a view pager in it that also has
fragments as each one of its 

00:37:20.082 --> 00:37:22.344
pages, so we get into this, all 
right, well now let's break up 

00:37:24.978 --> 00:37:27.636
the fragments into smaller 
piece, and so of course, you 

00:37:27.637 --> 00:37:29.673
know, the only way if fragments 
aren't enough, then you just 

00:37:34.181 --> 00:37:34.784
add more fragments, in this case
child fragments became a  thing.

00:37:34.785 --> 00:37:38.848
     And so now each one of 
these fragments could then be 

00:37:38.849 --> 00:37:41.515
broken up into smaller pieces, 
so this led us to kind 

00:37:44.561 --> 00:37:46.206
of again kind of decouple things
and we built a lot of code 

00:37:46.207 --> 00:37:48.207
around trying to 

00:37:50.473 --> 00:37:52.473
make this nested state work 
really well.

00:37:53.531 --> 00:37:55.157
Two varying levels of degree of 
success, but it's gotten a lot 

00:37:55.158 --> 00:37:57.158
better over time.

00:38:00.441 --> 00:38:02.280
So, with these things in mind, 
every one of those fragments, 

00:38:02.281 --> 00:38:04.281
whether 

00:38:05.376 --> 00:38:07.376
it's a small thing just managing
a view 

00:38:09.077 --> 00:38:11.505
or if it's a retained instance 
fragment, every single one of 

00:38:11.506 --> 00:38:13.959
these fragments give you 
lifecycle hooks, every single 

00:38:13.960 --> 00:38:18.687
one of them has back stack 
management associated with them,

00:38:18.688 --> 00:38:24.431
every single one of them has a 
retained object that it can do 

00:38:24.432 --> 00:38:27.321
across configuration changes, 
and all of them are stored 

00:38:27.322 --> 00:38:29.322
statefuly in your fragment 
manager.

00:38:31.429 --> 00:38:33.049
That means that the existence of
that fragment is actually part 

00:38:33.050 --> 00:38:35.050
of the state 

00:38:36.122 --> 00:38:38.122
of your app, so when your app 
dies and 

00:38:40.453 --> 00:38:42.285
comes back, that existence in 
the Fragment Manager is actually

00:38:42.286 --> 00:38:45.157
a really important part, at 
least from fragments 

00:38:46.370 --> 00:38:49.022
perspective, that we're going to
do on your behalf, and of 

00:38:49.023 --> 00:38:53.092
course, they all have their own 
ability to have a view subtree 

00:38:53.093 --> 00:38:55.755
so that piece of your UI that 
they manage themselves.

00:38:57.376 --> 00:38:59.407
And of course, we also allow 
things like fragments being 

00:38:59.408 --> 00:39:01.408
inflatable and put 

00:39:04.303 --> 00:39:06.730
right into your XML files and be
able to reuse them across 

00:39:06.731 --> 00:39:08.731
multiple layout, and again this 
is also kind of hooking into 

00:39:12.219 --> 00:39:14.219
these same processes, but the 
biggest 

00:39:18.745 --> 00:39:20.745
issue we found is that all these

00:39:22.813 --> 00:39:25.678
fragments do all of these things
at once whether you want them to

00:39:25.679 --> 00:39:29.959
or not.  And most of the time 
you're only actually using one 

00:39:29.960 --> 00:39:32.803
or two of these things and not 
the full 16 things that 

00:39:35.261 --> 00:39:38.099
fragments do that you get as 
kind of a bundle of deal.

00:39:41.164 --> 00:39:43.618
So that means that some of these
things like the stateful 

00:39:43.619 --> 00:39:46.684
restoration means you have a lot
of patterns that look like this 

00:39:46.685 --> 00:39:48.685
where you have to make 

00:39:50.933 --> 00:39:52.933
sure that the

00:39:54.063 --> 00:39:56.122
Fragment Manager is in the right
state.  In this case we're 

00:39:56.123 --> 00:39:58.123
actually checking, there no 
saved instance state?

00:40:00.815 --> 00:40:03.239
Ie, are we in a fresh run of 
this activity, and oh, now I 

00:40:03.240 --> 00:40:05.895
need to add my fragments to my 
layout.  If you've ever gotten 

00:40:05.896 --> 00:40:09.753
this approach, where you have 
one fragment over another one, 

00:40:09.754 --> 00:40:11.754
yeah that is this kind of 
stateful 

00:40:13.417 --> 00:40:15.417
restoration actually doing 
something 

00:40:16.498 --> 00:40:18.348
that was a useful bit but at the
same  point, like maybe not 

00:40:18.349 --> 00:40:22.221
exactly what you were expecting 
or something that you even 

00:40:22.222 --> 00:40:24.664
wanted in some cases.  But for 
fragment, you kind of got all 

00:40:28.536 --> 00:40:30.536
of them together in a package 
deal.

00:40:32.397 --> 00:40:34.397
But last year, we kind of took a

00:40:36.216 --> 00:40:38.216
more holistic approach

00:40:41.557 --> 00:40:43.183
holistic approach on how we do 
API, and so all of the 

00:40:43.184 --> 00:40:44.834
architecture components have 
really tried to focus in on 

00:40:44.835 --> 00:40:47.684
doing one thing well rather than
being kind of 

00:40:50.756 --> 00:40:52.756
the kitchen sink kind of 
approach.

00:40:53.647 --> 00:40:56.303
So for example, lifecycle 
observers, the ability to have 

00:40:56.304 --> 00:40:58.304
lifecycle 

00:41:00.174 --> 00:41:02.174
and that unresume, unstart as 
kind of a 

00:41:03.229 --> 00:41:04.849
piece that is completely 
independent from other things, 

00:41:04.850 --> 00:41:07.110
something you can register just 
if you care about  lifecycle.

00:41:07.111 --> 00:41:11.841
     Similarly, for view model, 
we created a new  primitive, a 

00:41:11.842 --> 00:41:17.489
new object specifically for that
kind of retained instance state 

00:41:17.490 --> 00:41:20.378
across configuration changes, 
and of course this year, just 

00:41:22.816 --> 00:41:24.816
yesterday, we announced a new 
navigation 

00:41:25.872 --> 00:41:28.109
architecture component, kind of 
working at the much higher level

00:41:28.110 --> 00:41:31.396
architecture on how you build 
your UI and put these things 

00:41:31.397 --> 00:41:33.397
together and really trying to 

00:41:35.439 --> 00:41:36.040
tackle just these specific 
problems of how do you move from

00:41:36.041 --> 00:41:38.689
one screen to the next screen.
     All of these things were 

00:41:38.690 --> 00:41:40.690
really 

00:41:41.936 --> 00:41:43.966
kind of focused on doing one 
thing well, and we're trying to 

00:41:43.967 --> 00:41:46.196
bring a lot of that to 
fragments, but that means that, 

00:41:46.197 --> 00:41:50.333
you know, we kind of have a lot 
of legacy to go along with them.

00:41:51.360 --> 00:41:54.620
     &gt;&gt; ADAM POWELL:  That's 
right.  So part of this is that 

00:41:54.621 --> 00:41:56.869
fragments were really designed 
around this idea of very 

00:41:59.876 --> 00:42:01.876
lose

00:42:04.224 --> 00:42:05.650
about loose dependencies and 
activities that go around behind

00:42:05.651 --> 00:42:09.757
them.  Question for the 
audience, how many know the 

00:42:09.758 --> 00:42:12.242
question, does a child uncreate 
method run before or after the 

00:42:12.243 --> 00:42:14.497
parents uncreate method?  How 
many of you are confident you 

00:42:14.498 --> 00:42:16.975
know the answer?  Not a whole 
lot.

00:42:18.609 --> 00:42:21.514
How many of you --
     &gt;&gt; IAN LAKE:  No idea?  Is 

00:42:21.515 --> 00:42:22.522
that an option?
     &gt;&gt; ADAM POWELL:  How many 

00:42:22.523 --> 00:42:25.777
of you thought you knew the 
answer before I asked the 

00:42:25.778 --> 00:42:29.331
question and then you started 
questioning yourself?  Yeah.  

00:42:29.332 --> 00:42:33.840
Okay.  I'll fully admit that 
sometimes I have to doublecheck 

00:42:33.841 --> 00:42:35.841
this as well because the 

00:42:38.731 --> 00:42:41.161
answer really kind of of on 
whether the parent is a activity

00:42:41.162 --> 00:42:43.162
or fragment.

00:42:44.830 --> 00:42:48.325
Android.app fragments or support
fragments?  The answer is 

00:42:48.326 --> 00:42:50.595
different all the time.  We 
changed this around.  If you 

00:42:50.596 --> 00:42:52.596
were trying to design a 

00:42:54.298 --> 00:42:55.930
fragment that  worked across all
versions of Android dealing with

00:42:55.931 --> 00:42:59.192
the fragment, you had to deal 
with these rules changing under 

00:42:59.193 --> 00:43:01.193
you a bit.  You couldn't count 
on anything.

00:43:02.888 --> 00:43:04.094
So one of the things we allowed 
for lifecycle  observers is that

00:43:04.095 --> 00:43:07.565
we really wanted to give a very 
strict ordering of the 

00:43:07.566 --> 00:43:12.656
callbacks.  You have a strict 
last in and first out callback 

00:43:12.657 --> 00:43:14.312
ordering for all lifecycle 
observers in any given 

00:43:14.313 --> 00:43:17.982
lifecycle.  This is important 
because it means you can set up 

00:43:17.983 --> 00:43:20.223
dependencies between lifecycle 
observers and use lifecycle 

00:43:21.678 --> 00:43:23.303
observers as the implementation 
details of a particular activity

00:43:23.304 --> 00:43:25.304
instance or fragment instance as
the case may be.

00:43:26.975 --> 00:43:28.806
You can make sure to maintain 
guarantees between certain 

00:43:28.807 --> 00:43:33.480
lifecycle events so that any 
other lifecycle observers or 

00:43:33.481 --> 00:43:35.528
other libraries that you may be 
using can take advantage of 

00:43:35.529 --> 00:43:37.529
those 

00:43:39.029 --> 00:43:41.029
guarantees that you've 
configured.

00:43:41.478 --> 00:43:42.510
Lifecycle observers are created 
by you.  We don't try to 

00:43:42.511 --> 00:43:44.756
recreate them via reflection, 
which means that you can use 

00:43:47.830 --> 00:43:50.076
any sort of creation pattern 
that you may find useful within 

00:43:50.077 --> 00:43:51.900
your app.
     So this seems like a really

00:43:51.901 --> 00:43:54.965
small thing, but it was a big 
piece of feedback that we got 

00:43:54.966 --> 00:43:57.407
with fragments.  The implication
of that though is that 

00:44:00.862 --> 00:44:03.506
you no longer get  stateful 
restoration by the system.  In 

00:44:03.507 --> 00:44:05.742
some cases this is exactly what 
you want.  You want to make sure

00:44:05.743 --> 00:44:09.410
that you have a single control 
flow path as you're configuring 

00:44:09.411 --> 00:44:12.121
what your lifecycle observers.  
You don't want to be checking, 

00:44:12.122 --> 00:44:14.369
hey, is my instance state going 
to bring this back for me?

00:44:17.426 --> 00:44:19.666
I don't want to end up with two 
of these things and so on and so

00:44:19.667 --> 00:44:21.717
forth.
     &gt;&gt; IAN LAKE:  Right.  One 

00:44:21.718 --> 00:44:23.747
of the really common patterns we
saw a lot of app developers 

00:44:23.748 --> 00:44:26.396
using is a headless fragment, a 
fragment without a UI.

00:44:29.717 --> 00:44:32.170
That was used basically only to 
receive on start, on stop 

00:44:32.171 --> 00:44:34.171
lifecycle 

00:44:35.632 --> 00:44:37.866
events and so for a lot of these
kind of approach, lifecycle 

00:44:37.867 --> 00:44:39.891
observers are going to give you 
the same kind of API service 

00:44:43.769 --> 00:44:46.620
but with a lot smaller kind of 
API that you don't actually need

00:44:46.621 --> 00:44:49.878
all of the things of fragment.
     So what does this actually 

00:44:49.879 --> 00:44:51.879
look like?

00:44:55.176 --> 00:44:57.620
You might have just a simple 
lifecycle observer that does 

00:44:57.621 --> 00:45:00.268
analytics calls and your 
analytics library might want 

00:45:02.099 --> 00:45:04.099
on-start, on-stop of a 
particular lifecycle.

00:45:07.177 --> 00:45:09.236
So the thing here is that this 
is an independent piece from 

00:45:09.237 --> 00:45:11.237
fragments, 

00:45:12.523 --> 00:45:17.611
from activities.  That has a 
couple of super important things

00:45:17.612 --> 00:45:19.243
in that one, you can test it 
independently, you don't have to

00:45:19.244 --> 00:45:22.305
spin off the whole world just to
test this piece.  You can test 

00:45:22.306 --> 00:45:25.343
it in isolation.
     Also, because you can 

00:45:25.344 --> 00:45:27.592
create this observer, you can 
use whatever methods 

00:45:30.641 --> 00:45:32.680
you want if you want to use a 
dependency injection kind of 

00:45:32.681 --> 00:45:35.309
model and inject in your 
dependencies, like that is 

00:45:35.310 --> 00:45:41.034
really easy to do in this model 
rather than trying to do it in 

00:45:41.035 --> 00:45:43.703
the scope of an activity or 
fragment or doing that kind of 

00:45:43.704 --> 00:45:45.704
thing.

00:45:46.971 --> 00:45:48.971
So this gives you a lot more 
power 

00:45:50.426 --> 00:45:51.844
to kind of split out this into a
composable piece, so if you're 

00:45:51.845 --> 00:45:53.845
building 

00:45:55.903 --> 00:45:57.903
a library, you can just use this
same 

00:45:58.965 --> 00:46:00.984
lifecycle observer across all of
your fragments or all of your 

00:46:00.985 --> 00:46:02.985
activities and not have to 
duplicate that data or worry 

00:46:05.910 --> 00:46:09.194
about, like okay, what state is 
my instance state in.  You can 

00:46:09.195 --> 00:46:11.837
always say, add the observer, 
and we're done.  There is no 

00:46:11.838 --> 00:46:13.838
more work you need to do here, 
so this offers a lot simpler 

00:46:16.970 --> 00:46:18.970
alternative for this specific 
use case.

00:46:20.646 --> 00:46:23.119
     &gt;&gt; ADAM POWELL:  Okay.  
We've got some glowing  slides 

00:46:23.120 --> 00:46:25.120
to get through.  Okay.

00:46:30.060 --> 00:46:31.908
So re retained instance 
fragments were designed to 

00:46:31.909 --> 00:46:36.218
outlive an activity.  These were
basically just a setter on a 

00:46:36.219 --> 00:46:38.219
fragment to say, hey, retain my 

00:46:39.279 --> 00:46:41.122
instance state across 
configuration changes.

00:46:41.123 --> 00:46:43.807
So it's a pretty useful thing 
because it meant that you could 

00:46:43.808 --> 00:46:47.725
safe handles to expensive data 
or expensive operations.  If you

00:46:47.726 --> 00:46:49.956
start some sort of query that 
might take a bit to complete, 

00:46:49.957 --> 00:46:53.611
you don't want to restart 
because something rotated the 

00:46:53.612 --> 00:46:56.097
screen or something got resized.
It meant that you could 

00:46:56.098 --> 00:46:58.098
reconnect to these same 
operations after that 

00:47:01.433 --> 00:47:05.703
configuration change, but really
please don't do UI during this. 

00:47:05.704 --> 00:47:08.002
This was another one of those 
kind of  headache pain points 

00:47:08.003 --> 00:47:10.003
sort of things, fragments do 
everything all at once, but 

00:47:11.262 --> 00:47:12.682
these were two things that just 
really did not taste great 

00:47:12.683 --> 00:47:16.563
together.  The reasoning for 
this is, of course, that views 

00:47:16.564 --> 00:47:19.820
hold on to the context that 
created them.  Well, what 

00:47:19.821 --> 00:47:22.095
context do you use to create  
views most of the time?  It ends

00:47:22.096 --> 00:47:24.096
up being the activity.  You 
don't want to hold on to a 

00:47:26.178 --> 00:47:27.807
reference after an old activity 
after a configuration change and

00:47:27.808 --> 00:47:30.045
end up using the same views.
     Technically it's possible 

00:47:30.046 --> 00:47:33.716
to do this right and drop all of
your references on destroy view,

00:47:33.717 --> 00:47:35.717
recreate the 

00:47:36.802 --> 00:47:38.833
view after you come around the 
other side, but this was way too

00:47:38.834 --> 00:47:43.109
difficult to get right all the 
time, just because  references 

00:47:43.110 --> 00:47:45.110
to the views end up leaking out 
and getting everywhere no matter

00:47:47.181 --> 00:47:49.624
what you try to do, so this was 
something that was really just 

00:47:49.625 --> 00:47:52.470
kind of a foot gun waiting to 
hurt people.

00:47:55.519 --> 00:47:58.363
     &gt;&gt; IAN LAKE:  But of course
in the architecture component 

00:47:58.364 --> 00:48:00.364
world, there is a different 
solution for this retained 

00:48:01.812 --> 00:48:03.812
instance pattern, and that comes
in the 

00:48:05.435 --> 00:48:07.435
model of

00:48:10.577 --> 00:48:12.612
ViewModels, and this is a new 
class, and to be honest it 

00:48:12.613 --> 00:48:14.442
doesn't really do a whole lot.  
It's how to connects to the 

00:48:14.443 --> 00:48:17.082
overall system.  Instead of 
being, again, part of the 

00:48:20.129 --> 00:48:21.966
Fragment APIs, this is a more 
general purpose thing, something

00:48:21.967 --> 00:48:24.821
that you can attach to any 
activity or any fragment 

00:48:28.336 --> 00:48:30.772
or any Viewmodel store owner if 
you build in your own framework.

00:48:30.773 --> 00:48:32.773
     The main thing that's 
different 

00:48:35.665 --> 00:48:37.665
here, just kind of like the 
lifecycle 

00:48:39.544 --> 00:48:41.990
observers, is that we are not 
the owner of creating those 

00:48:41.991 --> 00:48:43.991
object, so by default we provide
a factory that just creates a 

00:48:46.090 --> 00:48:48.320
new instance or creates a new 
instance and attaches your 

00:48:48.321 --> 00:48:50.321
application context to 

00:48:51.810 --> 00:48:53.241
it, but the same point, this is 
a super powerful hook for again 

00:48:53.242 --> 00:48:57.522
kind of adding in those extra 
dependencies, so if you're using

00:48:57.523 --> 00:49:00.369
dependency injection, like again
you have kind of the hooks you 

00:49:05.867 --> 00:49:07.867
need to hook into the Viewmodel 
creation 

00:49:08.939 --> 00:49:10.971
and pass them in as a 
construction parameter, there 

00:49:10.972 --> 00:49:12.600
doesn't need to be a more 
complicated structure than that.

00:49:12.601 --> 00:49:16.056
     So but you get into the 
same problem of like, okay, well

00:49:16.057 --> 00:49:19.948
how do I connect my UI?  And the
other piece of the puzzle here 

00:49:21.989 --> 00:49:23.989
is a different architecture 
component 

00:49:26.256 --> 00:49:28.256
called  Live Data and Live Data 
is all 

00:49:29.520 --> 00:49:30.723
about kind of a lifecycle aware 
observer, so in this model, in 

00:49:30.724 --> 00:49:32.724
this 

00:49:34.232 --> 00:49:36.232
world, your  Viewmodel is the 
one who is 

00:49:40.342 --> 00:49:41.760
storing the data, right, and 
it's the LiveData that it has 

00:49:41.761 --> 00:49:44.195
that it can pass to the activity
or fragment as they get 

00:49:47.256 --> 00:49:49.256
created and recreated, and that 
fragment 

00:49:51.933 --> 00:49:53.933
or activity can just observe the

00:49:56.004 --> 00:49:57.661
LiveData that the ViewModel own,
and so this separates it out so 

00:49:57.662 --> 00:50:02.994
instead of being the ViewModel 
that needs to hold on to a 

00:50:02.995 --> 00:50:05.443
reference to view, the activity 
can then pull the information 

00:50:05.444 --> 00:50:10.359
out of the ViewModel.
     So I think for a lot of use

00:50:10.360 --> 00:50:15.076
cases, where you're using a 
restained instance state 

00:50:15.077 --> 00:50:17.077
specifically to kind of store 
this 

00:50:18.967 --> 00:50:20.967
expensive data and do that kind 
of work, 

00:50:22.444 --> 00:50:25.103
ViewModels offer really good 
alternative to retained instance

00:50:25.104 --> 00:50:27.330
fragments, and so what's a a 
super simple one look like?

00:50:28.753 --> 00:50:30.753
Well, in this case we're going 
to 

00:50:32.226 --> 00:50:33.848
use an Android  ViewModel so 
here we get a reference to your 

00:50:33.849 --> 00:50:35.889
application, your application 
context, so this is really 

00:50:37.716 --> 00:50:40.559
useful if you're doing things 
like a service locater kind of 

00:50:40.560 --> 00:50:42.560
pattern, but the 

00:50:43.832 --> 00:50:45.832
important thing here is that the

00:50:48.100 --> 00:50:50.100
ViewModel stores an instance of 
a 

00:50:51.799 --> 00:50:54.249
LiveData in this case a LiveData
has a list of our fancy named 

00:50:54.250 --> 00:50:58.930
expensive data class.  Normally 
you put this in line, but slides

00:50:58.931 --> 00:51:00.931
are hard so here we're using it 

00:51:02.597 --> 00:51:05.246
and we're getting our data from 
a room database, a simple RM 

00:51:05.247 --> 00:51:07.909
database.
     But you can really get this

00:51:07.910 --> 00:51:10.801
data from anywhere or set up 
kind of the 

00:51:13.859 --> 00:51:15.859
correct lifecycle events here so
that 

00:51:17.109 --> 00:51:20.572
your  LiveData can kind of get 
into the right state.  But that 

00:51:20.573 --> 00:51:25.679
means that your actual fragments
or activities don't need to know

00:51:25.680 --> 00:51:27.680
where this data came from, 
right.

00:51:30.599 --> 00:51:32.033
Its encapsulated in the 
ViewModel and again we're in the

00:51:32.034 --> 00:51:36.734
same thing where we can now test
this ViewModel in isolation and 

00:51:36.735 --> 00:51:38.767
we don't need to create 
activity, we don't need to 

00:51:38.768 --> 00:51:41.548
create fragments to get to this 
same view model.  We can just 

00:51:41.549 --> 00:51:44.016
use them in isolation and make 
sure that all of the work we 

00:51:44.017 --> 00:51:47.895
need here to get our expensive 
data and make sure that it's in 

00:51:47.896 --> 00:51:49.896
the right state can 

00:51:50.949 --> 00:51:52.949
all be done kind of separate 
from the 

00:51:54.205 --> 00:51:56.205
actual UI pieces of the 
framework.

00:51:56.667 --> 00:51:58.721
&gt;&gt; ADAM POWELL:  All right.  So 
everybody's favorite topic when 

00:51:58.722 --> 00:52:00.722
it 

00:52:02.183 --> 00:52:04.183
comes to the Fragment API is 
fragment 

00:52:05.850 --> 00:52:07.850
transactions because this is a 
statement 

00:52:08.963 --> 00:52:10.963
that is said by pretty much no 
one ever.

00:52:11.442 --> 00:52:13.442
(laughter).

00:52:15.296 --> 00:52:18.954
Fragment transactions are 
asynchronous by default.  If you

00:52:18.955 --> 00:52:21.396
call it it gets posted for later
and it will occur on kind of the

00:52:23.833 --> 00:52:26.539
next handler post on the main 
thread, or if another lifecycle 

00:52:26.540 --> 00:52:29.979
event is coming up we'll execute
the  pending transactions, bring

00:52:29.980 --> 00:52:31.980
it to a consistent state before 
we move to the next state.

00:52:33.061 --> 00:52:35.061
Now, this actually has a few 

00:52:36.119 --> 00:52:38.552
benefits to it, believe it or 
not, for as much as everybody 

00:52:38.553 --> 00:52:40.583
gets kind of frustrated about it
and the biggest 

00:52:43.829 --> 00:52:45.654
wasn't is there is no re-enter 
ree fragment operation, if you 

00:52:45.655 --> 00:52:50.329
manipulate fragments within say 
the on-create of another 

00:52:50.330 --> 00:52:52.330
fragment you don't start getting

00:52:53.391 --> 00:52:54.639
into a state where you have a 
half-initiallyized frackment 

00:52:54.640 --> 00:52:56.260
while you're waiting for bring 
another fragment up to  speed.

00:52:56.261 --> 00:53:00.337
     This is a source of 
countless bugs are and I think 

00:53:00.338 --> 00:53:03.186
it was earlier this week or last
week that we were helping 

00:53:06.046 --> 00:53:08.046
developers troubleshoot some 
other 

00:53:09.970 --> 00:53:10.572
re-enterrant behavior bugs 
coming from view callbacks, for 

00:53:10.573 --> 00:53:13.018
example.  This is the sort of 
thing that can be really subtle.

00:53:16.871 --> 00:53:17.892
The asynchronous things sidestep
all of it and that was kind of 

00:53:17.893 --> 00:53:19.893
convenient.

00:53:20.935 --> 00:53:22.573
The drawbacks are, of course, 
that the observed state at any 

00:53:22.574 --> 00:53:25.421
given point in time doesn't 
actually reflect any of the 

00:53:27.472 --> 00:53:29.919
queued transactions, and so this
is a huge problem.  This 

00:53:29.920 --> 00:53:32.003
basically means that if one 
piece of your code submits a 

00:53:32.004 --> 00:53:36.712
fragment transaction, another 
piece of your code tries to read

00:53:36.713 --> 00:53:38.713
something out of state that that
fragment would have set up for 

00:53:40.404 --> 00:53:42.404
you, whether that's another view
hierarchy that would have gotten

00:53:44.705 --> 00:53:47.147
attached to a subhierarchy of 
the UI, or whether it's just 

00:53:47.148 --> 00:53:49.397
some data about pending 
operation for one of the 

00:53:51.256 --> 00:53:53.256
restained instance operations, 
this 

00:53:54.924 --> 00:53:55.747
means you can't trust anything 
about the current state of the 

00:53:55.748 --> 00:54:00.664
app.  It means you can have 
various data races within the 

00:54:00.665 --> 00:54:02.665
main part of your application.

00:54:05.955 --> 00:54:07.174
We've even seen people run into 
layered parts on top of each 

00:54:07.175 --> 00:54:09.213
other because of this issue.  
They were checking the fragment 

00:54:12.050 --> 00:54:13.064
manager to see what is my 
current UI pane for example 

00:54:13.065 --> 00:54:15.126
that's currently there.  It said
oh, look nothing, I don't have 

00:54:16.745 --> 00:54:18.745
anything to do, let me make a 
new 

00:54:20.666 --> 00:54:22.493
fragment transaction and sick 
stick something there, but this 

00:54:22.494 --> 00:54:27.363
was already in flight.  This was
a pain in the neck and everybody

00:54:27.364 --> 00:54:29.413
loved the commit-now API was 
added because it lets you do 

00:54:29.414 --> 00:54:32.272
something immediately as long as
you promise not to do anything 

00:54:32.273 --> 00:54:33.749
with the current fragment 
manager as part of that 

00:54:33.750 --> 00:54:38.017
transaction.
     &gt;&gt; IAN LAKE:  But we kind 

00:54:38.018 --> 00:54:42.368
of get to this point  where, 
okay, now we have all of these 

00:54:42.369 --> 00:54:44.810
fragment transaction codes in 
your app and very subtle changes

00:54:44.811 --> 00:54:46.811
that 

00:54:48.142 --> 00:54:49.634
you may not pick up in a simple 
CL are all of a sudden changing 

00:54:49.635 --> 00:54:52.504
the whole behavior of your app.
     And we really took a look 

00:54:52.505 --> 00:54:57.009
at this and we said, well, like 
should you really have to be 

00:54:57.010 --> 00:54:59.010
writing all of these fragment 
transactions by hand?

00:55:01.332 --> 00:55:03.390
Like, for so many of the use 
cases we can do a little bit 

00:55:03.391 --> 00:55:07.683
better here.  We can do a lot 
better here, especially for the 

00:55:07.684 --> 00:55:09.684
really common cases.

00:55:10.930 --> 00:55:12.598
So we had built navigation, a 
brand new architecture component

00:55:12.599 --> 00:55:15.467
that's really kind of focused on
the  screen-to-screen 

00:55:18.766 --> 00:55:20.587
transitions between fragments or
other UI pieces because we 

00:55:20.588 --> 00:55:24.134
really wanted to make it work 
well with fragments.  Fragments 

00:55:24.135 --> 00:55:26.135
are a really great way of 

00:55:27.817 --> 00:55:30.045
getting access to Livecycle 
observers and view models and 

00:55:30.046 --> 00:55:32.046
also, you know, 

00:55:33.530 --> 00:55:35.168
being an owner of a view and 
those are really kind of the 

00:55:35.169 --> 00:55:37.169
main pieces you need 

00:55:38.433 --> 00:55:41.088
when you're trying to build a 
good Android app.

00:55:43.335 --> 00:55:45.370
At the same point, we realize 
there are a lot of things that 

00:55:45.371 --> 00:55:48.066
fragments do that we don't 
really want you to have to 

00:55:51.316 --> 00:55:53.146
deal with yourself, so one of 
the things with navigation that 

00:55:53.147 --> 00:55:55.147
we really focused 

00:55:56.627 --> 00:55:59.269
on was actually being able to 
take ownership of the back stack

00:55:59.270 --> 00:56:01.925
and make sure that the 
navigation component can 

00:56:04.797 --> 00:56:06.797
actually handle that back stack 
for you, 

00:56:08.204 --> 00:56:10.204
whether you're using fragments 
or something else, the 

00:56:13.435 --> 00:56:15.462
ownership with that back stack 
goes with navigation, and that 

00:56:15.463 --> 00:56:19.125
gives us a lot more flexibility 
and a little more ability to be 

00:56:19.126 --> 00:56:21.126
a little more prescriptive and 

00:56:22.986 --> 00:56:25.011
opinionated on what is a good 
thing to do and what is a not so

00:56:25.012 --> 00:56:28.886
great thing to do and kind of 
give you a lot of the same power

00:56:28.887 --> 00:56:30.887
of fragment transactions without
actually having to touch one 

00:56:34.031 --> 00:56:36.031
with your bare hands.  Because 
again, we're trying to make 

00:56:37.925 --> 00:56:39.925
things so that, you know, you 
have all 

00:56:45.038 --> 00:56:46.479
of the power without necessarily
the headache and the problems 

00:56:46.480 --> 00:56:49.748
that run across some of the 
things that Adam pointed out.

00:56:49.749 --> 00:56:53.649
     So we're going to be 
talking in detail about 

00:56:53.650 --> 00:56:56.516
navigation tomorrow morning at 
8:30.  I know you're all early 

00:56:56.517 --> 00:57:00.178
risers, but I wanted to give you
a little bit of a preview of 

00:57:00.179 --> 00:57:02.620
kind of how simple this could 
be, so we actually offer a 

00:57:02.621 --> 00:57:04.839
helper method where if you want 
to click a button and 

00:57:07.895 --> 00:57:09.895
do a full screen transition to 
another 

00:57:11.829 --> 00:57:13.867
fragment, we have a create 
navigate on click listener that 

00:57:13.868 --> 00:57:17.156
literally does just that.  All 
you need to do is pass in the 

00:57:17.157 --> 00:57:21.246
IED of one of those destinations
that you've set up in 

00:57:21.247 --> 00:57:23.074
Navigation.
     Now, this looks a little 

00:57:23.075 --> 00:57:27.177
bit magical, and so what is this
actually doing under the covers?

00:57:29.208 --> 00:57:31.208
Well, really what it's doing is 
using 

00:57:32.217 --> 00:57:36.117
this Navcontroler object.  And 
one of the things that I find 

00:57:38.594 --> 00:57:41.046
super useful about Navigation is
you can find the Navcontroler 

00:57:41.047 --> 00:57:43.047
from any view or any fragment 
that's been created by 

00:57:45.498 --> 00:57:48.400
Navigation, so here we're using 
a column extension which makes 

00:57:48.401 --> 00:57:50.401
this a lot easier.

00:57:51.673 --> 00:57:54.512
If you're in a Java land it's 
just a static method, but here 

00:57:54.513 --> 00:57:59.612
we can find from any view, we 
can just say find Navcontroler 

00:57:59.613 --> 00:58:01.234
and get an instance of the 
Navcontroler and then just call 

00:58:01.235 --> 00:58:03.895
Navigate.  And this Navigate 
call knows how to do 

00:58:07.182 --> 00:58:09.213
fragment transactions so our 
Navcontroler in this case is set

00:58:09.214 --> 00:58:11.214
up with 

00:58:12.677 --> 00:58:14.094
a fragment navigator, our own 
class that knows all about the 

00:58:14.095 --> 00:58:16.535
correct behavior of doing 
fragment transactions and how to

00:58:20.006 --> 00:58:22.257
do all of that work for you so 
that from your codes 

00:58:22.258 --> 00:58:24.700
perspective, you can just call 
Navigate and we'll do the right 

00:58:25.105 --> 00:58:27.344
thing for you.
     So obviously there is a lot

00:58:27.345 --> 00:58:29.345
more 

00:58:30.797 --> 00:58:32.231
here, like if you want to pass 
arguments, like you can do a 

00:58:32.232 --> 00:58:35.324
bundle approach and we also have
a lot more things around that 

00:58:35.325 --> 00:58:38.163
specific case that we'll be 
talking about tomorrow as well, 

00:58:40.012 --> 00:58:42.058
as well as setting things like 
separate animations and other  

00:58:42.059 --> 00:58:44.059
objects in here.

00:58:45.119 --> 00:58:46.943
So you have a lot of the same 
power, but you can also make it 

00:58:46.944 --> 00:58:51.671
really easy to use and move a 
lot of the code that used to be 

00:58:51.672 --> 00:58:54.508
a fragment transaction that 
you'd have to make really sure 

00:58:54.509 --> 00:58:56.963
that you got right into 
something that Navigation can 

00:58:59.015 --> 00:59:01.015
understand and help with.

00:59:06.018 --> 00:59:08.645
So Adam, we've talked about a 
lot of things like why not 

00:59:08.646 --> 00:59:10.905
fragment, but this is kind of a 
fragment talk, right?

00:59:11.717 --> 00:59:13.717
&gt;&gt; ADAM POWELL:  I think that's 
why everyone is  here.

00:59:14.202 --> 00:59:17.022
&gt;&gt; IAN LAKE:  Yeah, so why 
fragments?  It's 2018.

00:59:17.023 --> 00:59:19.048
&gt;&gt; ADAM POWELL:  It is 2018.  So
what are fragments still good 

00:59:19.049 --> 00:59:23.057
for after we've sort of carved 
off some of these extension 

00:59:23.058 --> 00:59:24.077
points?
     To before we talk about 

00:59:24.078 --> 00:59:28.176
that, I think it's kind of more 
than to go into a little bit of 

00:59:28.177 --> 00:59:31.047
the package layering involved in
the Android framework, 

00:59:31.838 --> 00:59:35.122
specifically  Android.widget 
versus Android.app.  Now 

00:59:35.123 --> 00:59:38.580
Android.widget is really kind of
designed to hold the mechanism 

00:59:38.581 --> 00:59:43.073
for your UI.  That means that 
this is all the stuff that shows

00:59:43.074 --> 00:59:45.735
state to the user and things 
that reports user interaction 

00:59:45.736 --> 00:59:49.031
events back to other higher 
level portions of your app.  

00:59:49.032 --> 00:59:52.507
Really, that's it.  Everything 
that's in the widget package is 

00:59:52.508 --> 00:59:57.266
really meant to only do these 
two things, whereas  Android.app

00:59:57.267 --> 00:59:59.124
where fragments live, activities
live, so on and so forth, that's

00:59:59.125 --> 01:00:03.204
where your policy goes.  This is
what defines what state to bind 

01:00:03.205 --> 01:00:06.910
to widgets.  This is what  
defines how you should respond 

01:00:06.911 --> 01:00:08.713
to those user interaction events
and how to issue changes to your

01:00:08.714 --> 01:00:12.999
data model, anything kind of at 
that layer or above, no matter 

01:00:13.000 --> 01:00:16.692
how you may factor it, this is 
kind of how it breaks down.

01:00:19.544 --> 01:00:21.164
So this also brings us to the 
idea of inflatable components 

01:00:21.165 --> 01:00:24.455
which is something that comes up
quite a bit.  Since you can 

01:00:24.456 --> 01:00:26.456
inflate a fragment from a 
layout, people found out really 

01:00:28.735 --> 01:00:30.806
quickly that you can use a 
fragment to compose some of your

01:00:30.807 --> 01:00:33.069
views together and create, 
basically like a custom view but

01:00:34.725 --> 01:00:36.351
with a fragment.
     And really some of this 

01:00:36.352 --> 01:00:40.465
kind of comes in because people 
start asking, you know, just if 

01:00:40.466 --> 01:00:44.816
this view had a  lifecycle I 
could....something.  But really 

01:00:44.817 --> 01:00:46.817
you want to kind of use that as 
a stopping point and just kind 

01:00:48.747 --> 01:00:51.187
of ask yourself, like what is it
about in particular view?

01:00:54.252 --> 01:00:56.252
Remember, mechanism only, what 
is it 

01:00:59.370 --> 01:01:01.370
about this particular view about
the lifecycle.

01:01:03.860 --> 01:01:06.347
It should be only seeing or 
publishing user action if the 

01:01:06.348 --> 01:01:11.062
user clicks or performs anything
themselves.  None of these need 

01:01:11.063 --> 01:01:14.336
lifecycle events to accomplish 
that goal.  So you should watch 

01:01:14.337 --> 01:01:15.971
out and see if you need some 
policy layer that sits above 

01:01:15.972 --> 01:01:17.819
that.
     This is where fragments are

01:01:17.820 --> 01:01:21.083
really useful because you can 
compose them of higher-level 

01:01:21.084 --> 01:01:25.587
controls.  It means that they 
can be self-sufficient, they 

01:01:25.588 --> 01:01:27.588
have their own lifecycle, they 
know how to hook into 

01:01:30.822 --> 01:01:33.096
some of these things.  It means 
that inflated attributes can 

01:01:35.034 --> 01:01:37.297
actually become fragment 
arguments so you can make these 

01:01:37.298 --> 01:01:40.368
things super self-sufficient and
implement cross-cutting UI 

01:01:40.369 --> 01:01:42.849
policies that you don't have to 
worry about in terms of like the

01:01:45.489 --> 01:01:47.512
over arching top-level parent 
context.  This ends up being 

01:01:47.513 --> 01:01:51.393
really useful for things like, I
mean even just something as 

01:01:51.394 --> 01:01:53.020
simple as ads, something where 
you really do need to control 

01:01:53.021 --> 01:01:56.061
for a lifecycle about when a 
user comes and goes, perform a 

01:01:56.062 --> 01:01:58.097
request out to the network to 
fetch the don't that you're 

01:01:59.728 --> 01:02:01.163
going to show, but really you 
don't want that code getting all

01:02:01.164 --> 01:02:03.841
over throughout the rest of your
application logic.

01:02:06.119 --> 01:02:08.793
Can you use this for other sorts
of like independent info cards, 

01:02:08.794 --> 01:02:13.065
things that are, again, fully 
self-contained.  The parent 

01:02:13.066 --> 01:02:14.713
doesn't actually need to be 
involved in any of the data 

01:02:14.714 --> 01:02:18.583
routing from your central 
repository or whatever other 

01:02:18.584 --> 01:02:20.632
sort of model you're using under
the hood in order to get that on

01:02:20.633 --> 01:02:22.633
screen 

01:02:23.713 --> 01:02:25.713
and get the user interacting 
with it.

01:02:26.566 --> 01:02:27.996
So one example of using the 
fragment arguments for this is 

01:02:27.997 --> 01:02:31.488
on the screen here.  This is the
sort of thing we can probably 

01:02:31.489 --> 01:02:33.489
benefit from some extensions or 

01:02:34.552 --> 01:02:37.252
helpers, but overall it's not 
too bad if you define a stylable

01:02:37.253 --> 01:02:40.920
to go ahead and inflate some of 
those argument, just assign the 

01:02:40.921 --> 01:02:42.148
values to the bundle, set it 
there, and then you can route 

01:02:42.149 --> 01:02:46.820
all of this logic through your 
normal fragment argument 

01:02:46.821 --> 01:02:48.463
handling that appears throughout
the rest of your fragment 

01:02:48.464 --> 01:02:51.957
implementation.
     &gt;&gt; IAN LAKE:  So one of the

01:02:51.958 --> 01:02:55.219
other use cases we found really 
useful for using fragments is 

01:02:55.220 --> 01:03:00.142
this kind of app screen kind of 
model, so where a fragment is 

01:03:00.143 --> 01:03:02.143
taking the vast majority of the 
screen.

01:03:03.811 --> 01:03:05.811
It's really the main content of 
your 

01:03:07.077 --> 01:03:08.525
app, and this is really kind of 
where Navigation comes in and 

01:03:08.526 --> 01:03:13.027
really kind of takes away a lot 
of the rough edges of fragments 

01:03:13.028 --> 01:03:15.879
so you're just left with the 
architecture component hooks and

01:03:15.880 --> 01:03:17.880
a view.

01:03:19.813 --> 01:03:21.813
So in this model, it's a lot 
easier 

01:03:23.302 --> 01:03:26.170
to move towards a single 
activity app.  If you listen to 

01:03:26.171 --> 01:03:30.031
Chet yesterday, this is kind of 
our recommendation going forward

01:03:30.032 --> 01:03:32.061
to kind of use activities just 
as an entry point into your app,

01:03:32.062 --> 01:03:34.062
and then your content, the 
actual things 

01:03:38.611 --> 01:03:41.271
that the UI -- the pieces that 
user actually work with, are the

01:03:41.272 --> 01:03:44.973
fragments of your  app, right, 
the actual content is in 

01:03:44.974 --> 01:03:46.974
fragments.

01:03:48.263 --> 01:03:50.300
So with this model, the only 
thing the activity needs to do 

01:03:50.301 --> 01:03:52.301
is handle kind 

01:03:53.392 --> 01:03:55.392
of common app chrome.  So if 
you're using an action bar still

01:03:58.878 --> 01:04:00.694
or if you're using like bottom  
Nav or side Nav, these would be 

01:04:00.695 --> 01:04:05.385
guide things that the activity 
can manage, but the rest of it 

01:04:05.386 --> 01:04:09.896
could be decoupled destination, 
decoupled screens, all of these 

01:04:09.897 --> 01:04:11.720
fragments can be much more 
independent from each other 

01:04:11.721 --> 01:04:13.721
rather than being tightly 
coupled together.

01:04:16.215 --> 01:04:17.255
So this allows us to kind of 
move a lot of the things that 

01:04:17.256 --> 01:04:19.256
normally you 

01:04:20.502 --> 01:04:22.736
would have to deal with manually
into a system that we can help 

01:04:22.737 --> 01:04:24.737
you out a lot 

01:04:26.027 --> 01:04:28.865
more on, so for navigation, for 
example, we're going to give you

01:04:28.866 --> 01:04:30.866
the hooks that 

01:04:32.176 --> 01:04:34.020
you need to set up the 
transitions and animations 

01:04:34.021 --> 01:04:36.021
needed to transition between 

01:04:37.041 --> 01:04:41.158
these screens, and it's 
something that can be done in 

01:04:41.159 --> 01:04:43.159
Navigation rather than something
you have to do by hand.

01:04:44.466 --> 01:04:46.466
Of course, like these aren't 
neutrally exclusive, right.

01:04:49.563 --> 01:04:51.256
You can still add a fragment to 
your layout or have nested 

01:04:51.257 --> 01:04:55.351
fragments underneath these 
things, so it's not an all or 

01:04:55.352 --> 01:04:57.352
nothing kind of approach.

01:04:58.859 --> 01:05:00.859
It's just one method  that, yes,
this 

01:05:02.121 --> 01:05:03.952
larger kind of content-based 
fragment is still a really good 

01:05:03.953 --> 01:05:05.953
way of kind of bridging the gap 
between the Android.

01:05:09.520 --> 01:05:12.650
app world and the widget world.
     Another use case that is 

01:05:12.651 --> 01:05:14.651
still 

01:05:16.525 --> 01:05:18.538
super useful is around dialogue 
fragment.  Again, we talked 

01:05:18.539 --> 01:05:20.539
about kind of the 

01:05:21.800 --> 01:05:23.857
activity of showdialogue.  I 
hope everyone forgot that now 

01:05:23.858 --> 01:05:27.398
like I said, but dialogue 
fragment is really kind of the 

01:05:27.399 --> 01:05:29.399
same approach where instead 

01:05:31.700 --> 01:05:33.793
of it being something that you 
need to manage and make sure is 

01:05:33.794 --> 01:05:35.794
visible or not 

01:05:37.700 --> 01:05:40.137
visible, it really kind of helps
encapsulate the interaction 

01:05:40.138 --> 01:05:42.138
between a 

01:05:43.637 --> 01:05:45.682
floating UI, like you have a 
really important question to ask

01:05:45.683 --> 01:05:49.153
the user, a dialogue is probably
a useful case in some manner, 

01:05:49.154 --> 01:05:51.626
but it's also something that 
we've started to see a lot more.

01:05:55.144 --> 01:05:57.803
In Android P, for instance, the 
biometric prompt for fingerprint

01:05:57.804 --> 01:06:02.120
is now something that is in a 
dialogue kind of model, so this 

01:06:02.121 --> 01:06:04.121
is actually something 

01:06:06.016 --> 01:06:07.854
that we've found really useful. 
And part of it is that we can 

01:06:07.855 --> 01:06:11.733
leverage some of that instance 
state restoration that you get 

01:06:11.734 --> 01:06:15.605
for free as part of fragments 
with your dialogue.  This means 

01:06:15.606 --> 01:06:17.440
that you've asked a really 
important question, otherwise 

01:06:17.441 --> 01:06:19.441
why would 

01:06:21.332 --> 01:06:24.256
you show a dialogue and 
interrupt the user?  But you 

01:06:24.257 --> 01:06:26.257
really don't want that to 

01:06:27.332 --> 01:06:29.332
disappear when you resize your 
screen on 

01:06:31.752 --> 01:06:35.080
a pixel book orrotate your 
device on the phone.  It's an 

01:06:35.081 --> 01:06:37.305
important question and we want 
to make sure we do some of the 

01:06:40.007 --> 01:06:42.039
restoration state for you.
     At the same point, 

01:06:42.040 --> 01:06:44.040
dialogues aren't just a floating
UI.  Right.

01:06:46.928 --> 01:06:48.928
There are also bottom sheets and
bottom sheet dialogue fragment 

01:06:50.407 --> 01:06:52.645
specifically built around having
different kinds of floating UIs,

01:06:52.646 --> 01:06:54.646
UIs 

01:06:55.912 --> 01:06:58.352
that live above your main don't 
without necessarily being just 

01:06:58.353 --> 01:07:00.353
the like dimmed 

01:07:01.648 --> 01:07:03.921
background kind of traditional 
dialogue of it.

01:07:05.340 --> 01:07:08.184
So we're really trying to get to
this point where, yes, uses a 

01:07:08.185 --> 01:07:13.302
dialogue fragment is great if 
you have this UI that you really

01:07:13.303 --> 01:07:15.350
don't want to lose.  It's really
important for the user, 

01:07:17.585 --> 01:07:19.585
obviously for things that the 
user could 

01:07:21.091 --> 01:07:22.779
use or could lose, but it's 
probably not a dialogue you want

01:07:22.780 --> 01:07:24.780
to use, it's probably a snack 
bar or another approach here.

01:07:24.815 --> 01:07:26.815
     This is my favorite part 
about 

01:07:29.716 --> 01:07:30.530
dialogue fragments, there is 
literally nothing more you need 

01:07:30.531 --> 01:07:32.531
to do.

01:07:35.007 --> 01:07:37.493
You call show or shownow for the
synchronous method and that's 

01:07:37.494 --> 01:07:41.354
it.  It's very much this kind of
model where we're going to do 

01:07:41.355 --> 01:07:44.809
the fragment transactions for 
you.  Again, like we don't want 

01:07:44.810 --> 01:07:46.810
to be in a 

01:07:48.095 --> 01:07:50.095
model where you have to do a lot
of 

01:07:51.182 --> 01:07:52.812
complicated work yourself.
     For a dialogue fragment you

01:07:52.813 --> 01:07:56.540
can literally just call show and
it will do the right thing and 

01:07:56.541 --> 01:08:00.651
get you back into the right 
state.

01:08:01.477 --> 01:08:02.488
&gt;&gt; ADAM POWELL:  All right.  So 
one of the other things that 

01:08:02.489 --> 01:08:04.489
people 

01:08:06.140 --> 01:08:08.140
tend to use fragments for quite 
a bit is 

01:08:10.039 --> 01:08:12.112
managing options menus and 
specifically merging menus into 

01:08:12.113 --> 01:08:14.113
a common toolbar or action bar 
that's global to the activity.

01:08:17.625 --> 01:08:18.642
So fragment support options 
menus because activities support

01:08:18.643 --> 01:08:20.881
them.  This goes back to the 
design  goal, 

01:08:25.278 --> 01:08:28.109
where fragments had to do 
anything the activity could do. 

01:08:28.110 --> 01:08:30.361
The most common way is set 
support action bar for your 

01:08:30.362 --> 01:08:32.362
toolbar which kind 

01:08:33.627 --> 01:08:35.627
of binds whatever your current 
context 

01:08:37.903 --> 01:08:39.903
is to a particular toolbar 
within your UI.

01:08:39.960 --> 01:08:42.399
This is create if you have a 
fixed common chrome.  In the 

01:08:42.400 --> 01:08:44.024
navigation world, if your 
toolbar never changes between 

01:08:44.025 --> 01:08:47.926
screen, then this is really 
handy because this means that 

01:08:47.927 --> 01:08:49.563
you can populate that with 
whatever actions are relevant 

01:08:49.564 --> 01:08:53.627
for what's in your main don't.
     Fragment pager adapter is 

01:08:53.628 --> 01:08:55.628
another really great one that 
people use this for quite a bit.

01:08:57.746 --> 01:08:59.813
If the actions change across 
pages, then all of this is just 

01:08:59.814 --> 01:09:01.814
kind of handled for you, the 
system takes care of it.

01:09:04.287 --> 01:09:05.918
Now, the alternative to this is 
that you can go ahead and 

01:09:05.919 --> 01:09:07.919
directly 

01:09:10.237 --> 01:09:12.287
manage the menus as Toolbar View
Data.  Most of the time today 

01:09:12.288 --> 01:09:16.780
your UIs are such that the 
toolbar or other sort of menu 

01:09:16.781 --> 01:09:19.457
management is really kind of 
part of the content.  I mean, 

01:09:19.458 --> 01:09:21.513
this was something that you saw 
back in a lot of hollow UIs 

01:09:21.514 --> 01:09:25.262
where the action bar was always 
fixed common chrome, but now you

01:09:25.263 --> 01:09:27.263
have the collapsing app bar 
layouts and things that are much

01:09:28.922 --> 01:09:30.758
more sophisticated to the point 
we're doing the global wire app 

01:09:30.759 --> 01:09:33.605
is almost jumping through hoops 
that you don't really need, so 

01:09:33.606 --> 01:09:36.857
don't make it more complicated 
than it needs to be.  If you 

01:09:36.858 --> 01:09:38.858
don't have common chrome for 

01:09:41.755 --> 01:09:43.994
this, then directly managing 
some of the toolbar menus as 

01:09:43.995 --> 01:09:48.081
View Data is as simple of this. 
It's a couple lines of code.  

01:09:48.082 --> 01:09:50.332
There is not a whole lot to it. 
You inflate the menu, attach a 

01:09:52.564 --> 01:09:53.792
listener, and keep it more 
self-contained rather than 

01:09:53.793 --> 01:09:58.300
leaking out into the whole 
options menu at that point.

01:10:00.159 --> 01:10:02.455
One of the other things we get 
asked a lot is about testing 

01:10:02.456 --> 01:10:06.722
fragments.  Testing fragments is
a whole lot easier than testing 

01:10:06.723 --> 01:10:10.596
activities.  You don't have to 
spin up the entirety of the 

01:10:10.597 --> 01:10:12.597
world, entire new activity with 
sort of the back and forth in an

01:10:13.660 --> 01:10:15.690
instrumentation test to the 
activity manager to make this 

01:10:15.691 --> 01:10:18.147
work.  The nice part about this 
is that from 

01:10:21.208 --> 01:10:22.640
quite a few years ago, we've had
this glass fragment controller 

01:10:22.641 --> 01:10:26.712
that is able to drive the 
lifecycle, so you can go ahead 

01:10:26.713 --> 01:10:28.713
and create just a test fragment 

01:10:29.770 --> 01:10:31.813
manager or test fragment 
controller that can test those 

01:10:31.814 --> 01:10:34.690
larger fragment components in 
isolation away from everything 

01:10:34.691 --> 01:10:36.691
else that might be happening in 
the activity manager.

01:10:38.402 --> 01:10:40.235
We use this pretty extensively 
for the existing support library

01:10:40.236 --> 01:10:45.152
tests ourselves.  Now, we make 
this possible but truth be told,

01:10:45.153 --> 01:10:49.229
this is really not the best 
interface for doing it.  It ends

01:10:49.230 --> 01:10:51.080
up looking a little bit like 
this or you could go through 

01:10:51.081 --> 01:10:53.081
some of the 

01:10:54.352 --> 01:10:55.775
support library tests in AOSP 
and see kind of the example of 

01:10:55.776 --> 01:10:59.055
some of the utility methods that
we've set up for this.

01:11:00.693 --> 01:11:06.010
We should really probably wrap 
this in some some type of move 

01:11:06.011 --> 01:11:08.035
to state type of method.  This 
is a case where we fell into a 

01:11:09.271 --> 01:11:10.694
trap ourself, something is 
possible, it's maybe not great, 

01:11:10.695 --> 01:11:14.592
the rest is kind of left as an 
exercise to the reader and we 

01:11:14.593 --> 01:11:17.669
just kind of need to do better 
on this part.

01:11:18.678 --> 01:11:20.727
&gt;&gt; IAN LAKE:  Yeah, so one of 
the other pieces that kind of 

01:11:20.728 --> 01:11:24.229
came along side of fragments 
more from a convenience method 

01:11:24.230 --> 01:11:27.714
than anything else were loaders.
A kind of precursor to a lot of 

01:11:27.715 --> 01:11:32.207
what we've done in architecture 
components on doing retained 

01:11:32.208 --> 01:11:34.471
instance states, and one of the 
things we've done recently is 

01:11:37.159 --> 01:11:39.159
actually tried to decouple them 
from fragments.

01:11:40.025 --> 01:11:42.280
So how do we actually do this?  
Well, instead of being their own

01:11:44.555 --> 01:11:47.189
special thing, we actually 
rebuilt them on a lot of the 

01:11:47.190 --> 01:11:49.190
architecture components 

01:11:51.529 --> 01:11:53.529
using these new primitives we 
have of 

01:11:54.545 --> 01:11:56.475
LiveData and ViewModel to make 
these a totally independent 

01:11:56.476 --> 01:11:58.476
thing.  Now you can actually use
loaders in 

01:12:00.579 --> 01:12:03.228
any lifecycle owner or view 
store owner class, activity, 

01:12:03.229 --> 01:12:06.885
fragment, if you're building 
your own kind of thing, it works

01:12:06.886 --> 01:12:07.710
equally well in all of those 
cases.

01:12:07.711 --> 01:12:09.711
What does this mean?  It really 
just means that you have the 

01:12:11.227 --> 01:12:13.227
same loader you always do, but 
instead 

01:12:14.446 --> 01:12:16.446
of calling

01:12:18.403 --> 01:12:21.885
getsupportloader Manager, can 
you just call getinstance.  

01:12:21.886 --> 01:12:23.929
We'll do all the hookup for you.
We know you're in a  lifecycle 

01:12:25.998 --> 01:12:28.033
observer and so we know how to 
hook all that stuff up for you, 

01:12:28.034 --> 01:12:30.034
and we really were able to kind 
of cut out a lot of 

01:12:32.536 --> 01:12:34.194
the stuff -- cut out a lot of 
the custom behavior here so 

01:12:34.195 --> 01:12:36.448
that, you know, we can kind of 
rely on these new things to give

01:12:39.802 --> 01:12:41.802
you stronger guarantees around 
lifecycle.

01:12:42.678 --> 01:12:44.969
So we've talked a lot about 
fragments and we've talked a lot

01:12:44.970 --> 01:12:46.970
about fragments in the past and 
we've talked 

01:12:50.081 --> 01:12:52.916
about fragments in 2018, but 
there is another question.  

01:12:52.917 --> 01:12:54.964
Where are we going with 
fragments?  What do we still 

01:12:54.965 --> 01:12:56.965
have to do?

01:12:58.046 --> 01:12:59.871
So some of this is just coming 
down to building in those 

01:12:59.872 --> 01:13:03.981
stronger guarantees, trying to 
separate the desired behavior, 

01:13:03.982 --> 01:13:05.982
things that we 

01:13:07.648 --> 01:13:09.694
specifically set out to put in 
versus incidental behavior, more

01:13:09.695 --> 01:13:11.695
behavior that 

01:13:13.016 --> 01:13:15.016
has just been around for six 
years and 

01:13:18.741 --> 01:13:21.178
is not necessarily something 
that is a codified standard.  

01:13:21.179 --> 01:13:23.457
We're trying to move more toward
a model where you can be very 

01:13:23.458 --> 01:13:26.104
confident in exactly what's 
going to happen when you're 

01:13:26.105 --> 01:13:27.953
using fragments.
     Another case is trying to 

01:13:27.954 --> 01:13:29.954
do the 

01:13:31.672 --> 01:13:34.526
same thing that we did with 
Loader Manager in reimplementing

01:13:34.527 --> 01:13:36.800
some of these existing APIs on 
top of these new primitives.

01:13:39.855 --> 01:13:41.894
For example, like being able to 
rewrite a lot of the internals 

01:13:41.895 --> 01:13:45.364
of fragments so they're actually
using lifecycle observers under 

01:13:45.365 --> 01:13:47.596
the covers, right.  So these 
kind of things allow us to 

01:13:51.099 --> 01:13:53.140
kind of make sure that all of 
our components are on the same 

01:13:53.141 --> 01:13:55.990
page and really doing the same 
thing.

01:13:58.850 --> 01:14:00.850
So a few other things.

01:14:02.119 --> 01:14:04.119
Again, trying to move towards a 
world 

01:14:05.797 --> 01:14:08.644
where we have the correct set of
signals and activity callbacks 

01:14:08.645 --> 01:14:10.645
so that any 

01:14:12.341 --> 01:14:14.392
interested component can be it. 
That means that fragments are 

01:14:14.393 --> 01:14:18.064
not a special snowflake anymore 
and they're just another 

01:14:18.065 --> 01:14:20.065
component, another tool in 

01:14:21.134 --> 01:14:22.790
your toolbox using the same 
composable hooks that you always

01:14:22.791 --> 01:14:27.480
have.  So really trying to play 
well with other components so 

01:14:27.481 --> 01:14:31.990
that it's not an either/or and 
it's a both.  We can work 

01:14:31.991 --> 01:14:33.991
together, that you can use 

01:14:35.811 --> 01:14:37.811
fragments a I long

01:14:40.814 --> 01:14:42.033
long side other components and 
it works.

01:14:42.034 --> 01:14:43.266
&gt;&gt; ADAM POWELL:  So options are 
of course one other thing that 

01:14:43.267 --> 01:14:46.756
we still don't have a great 
answer for this in terms of how 

01:14:46.757 --> 01:14:49.375
we want to decouple this.  In in
a lot of ways I would like 

01:14:54.214 --> 01:14:56.214
options menus as a concept to be

01:14:57.381 --> 01:14:59.197
depricated but we have to make 
sure you have them for when 

01:14:59.198 --> 01:15:03.484
you're using common chrome or 
paging through some don't.

01:15:04.725 --> 01:15:12.090
Next one?  Maybe?  There we go. 
Android.app.fragment manager.

01:15:16.199 --> 01:15:18.199
It's deprecated.

01:15:19.256 --> 01:15:21.077
This works a lot better in the 
Android packages and support 

01:15:21.078 --> 01:15:23.933
before it because this means you
no longer have to wore bee all 

01:15:23.934 --> 01:15:26.173
the bugs that were fixed over 
time and allows us to make 

01:15:26.174 --> 01:15:29.640
larger changes to the behave in 
API.  Send us your wish list for

01:15:29.641 --> 01:15:34.165
the things you would like to see
us do for some of this too.  We 

01:15:34.166 --> 01:15:36.216
are going to be in the sandbox 
area after this so please come 

01:15:36.217 --> 01:15:38.853
and say hello and tell us what 
you would like to see next.  

01:15:38.854 --> 01:15:40.854
Thank you very much for coming.
     (Applause).

01:15:50.838 --> 01:15:52.838
(music)

01:15:59.517 --> 01:16:01.517
.

01:16:06.435 --> 01:16:08.501
     &gt;&gt; Thank you for joining 
the session.

01:16:12.373 --> 01:16:14.006
Ambassadors will assist with 
letting you through the 

01:16:14.007 --> 01:16:16.884
designated exits.  We'll be 
making room for those that 

01:16:17.904 --> 01:16:20.359
registered for the next session.
If you registered for the next 

01:16:22.598 --> 01:16:24.598
session, we ask that you please 
leave 

01:16:28.653 --> 01:16:31.208
the room and return via the line
outside.  Thank you.

01:21:10.624 --> 01:21:12.624
May 9, 2018

01:21:15.671 --> 01:21:17.671
9:30 a.m.

01:21:22.035 --> 01:21:24.035
PT

01:21:29.368 --> 01:21:31.368
What's New in Android Things?

01:25:29.385 --> 01:25:32.230
     &gt;&gt; Welcome.  Please fill in
the seats near the front of the 

01:25:32.231 --> 01:25:34.231
room.  Thank you.

01:28:31.004 --> 01:28:36.457
     &gt;&gt; At this time, please 
find your seat.  Our session 

01:28:36.458 --> 01:28:38.458
will begin soon.

01:30:34.430 --> 01:30:38.326
     &gt;&gt; Good morning and welcome
to the second day of Google I/O.

01:30:40.156 --> 01:30:42.418
Thank you all who made it here 
bright and early and a big hello

01:30:42.419 --> 01:30:45.255
to folks on the live stream.  
This session is about Android 

01:30:45.256 --> 01:30:47.256
Things, 

01:30:48.717 --> 01:30:51.606
the version of Android that was 
specifically designed for IoT 

01:30:51.607 --> 01:30:55.158
products.  My name is Vince and 
I lead product management for 

01:30:55.159 --> 01:30:58.080
Android Things.  Yesterday you 
heard about incredible momentum 

01:30:58.081 --> 01:31:01.165
on Android.  Over the years we 
have extended Android to many 

01:31:01.166 --> 01:31:03.166
different types of devices 
beyond phones and tablets, 

01:31:06.560 --> 01:31:08.199
wearables, TVs, auto, and last 
year we announce add new version

01:31:08.200 --> 01:31:10.200
of Android called Android 
Things, specifically 

01:31:15.493 --> 01:31:17.493
designed for embedded devices in
IoT products.

01:31:17.503 --> 01:31:19.503
I know many of you have been 

01:31:24.602 --> 01:31:25.539
tracking our regular developer 
previews and are already 

01:31:25.540 --> 01:31:29.740
building great things.  I love 
reading about the project, it's 

01:31:25.540 --> 01:31:27.540
so awesome.

01:31:29.559 --> 01:31:33.359
For some of you, this is 
entirely new you're just getting

01:31:29.559 --> 01:31:31.555
started and want to know what 
Android Things can do for  you, 

01:31:31.556 --> 01:31:33.814
so let me just get started with 
some of the obvious questions.  

01:31:33.815 --> 01:31:35.815
What is Android Things for?

01:31:37.353 --> 01:31:39.210
What problems does it solve?
     People have been making 

01:31:39.211 --> 01:31:42.564
connected devices for many 
years.  What's different now is 

01:31:42.565 --> 01:31:46.723
the profound revolution in 
Machine Learning.  Powerful 

01:31:46.724 --> 01:31:51.593
models and tools are available 
for all developers and there is 

01:31:51.594 --> 01:31:53.594
ever increasing demand for 
smarter devices

01:31:54.661 --> 01:31:56.085
Traditionally, your only option 
when building smarter devices 

01:31:56.086 --> 01:31:59.958
was to delegate some of the 
serious processing to the Cloud.

01:32:02.627 --> 01:32:04.627
Now, it's possible to run much 
of it 

01:32:05.717 --> 01:32:08.552
on device which is useful if you
need low latency or handling 

01:32:08.553 --> 01:32:12.212
sensitive don't and so on.  And 
this growing area is exactly 

01:32:12.213 --> 01:32:14.213
where Android Things is 
targeted.

01:32:16.495 --> 01:32:18.495
It is for  devices that need 
powerful on-device intelligence.

01:32:19.557 --> 01:32:23.056
     When we look around the 
devices that populate your  

01:32:23.057 --> 01:32:27.765
homes and businesses, IoTs, of 
course, are very broad and 

01:32:27.766 --> 01:32:28.791
diverse, so in a sense the 
product categories are all 

01:32:28.792 --> 01:32:32.267
familiar.  We all know these.  
It's just the user expectations 

01:32:32.268 --> 01:32:36.772
have gone up, way up.  Let me 
just pick on two use cases

01:32:39.457 --> 01:32:41.704
At home, we increasingly expect 
to be able to talk to our 

01:32:41.705 --> 01:32:43.939
devices and they'll know who we 
are.

01:32:47.224 --> 01:32:49.266
Another one is  Smart Building 
devices such as cameras that can

01:32:49.267 --> 01:32:52.524
now detect how many people are 
in a room and do something 

01:32:52.525 --> 01:32:56.613
useful with that, for example 
talk to the HVAC system.  We 

01:32:56.614 --> 01:32:58.858
know users want these kind of 
devices and we know we could 

01:32:58.859 --> 01:33:01.091
build them, but of course 
building these devices is 

01:33:03.556 --> 01:33:05.556
actually very hard, especially 
maintaining them over time.

01:33:08.676 --> 01:33:10.503
It's actually very expensive to 
do this.  We know this at Google

01:33:10.504 --> 01:33:13.147
because we've been shipping 
these kinds of products.

01:33:14.388 --> 01:33:16.853
What's so hard?  Well first off,
we're talking about an 

01:33:20.945 --> 01:33:22.945
entire device, so a whole 
physical 

01:33:24.224 --> 01:33:26.713
product so responsible for the 
entire software stack from the 

01:33:26.714 --> 01:33:28.373
bottom up to the product 
experience.  Now of course the 

01:33:28.374 --> 01:33:32.063
product experience is where you 
ideally want to spend most of 

01:33:32.064 --> 01:33:34.064
your time because that's where 
users 

01:33:35.397 --> 01:33:37.628
are spending and interacting 
with it.  Below the product 

01:33:37.629 --> 01:33:39.629
experience, IoT 

01:33:40.701 --> 01:33:43.342
devices are currently built 
using many different flavors of 

01:33:43.343 --> 01:33:45.343
roll your own Linux 

01:33:47.239 --> 01:33:49.239
or Android, and every d device 
is different.

01:33:53.521 --> 01:33:55.521
It's hard to expect consistent 
and 

01:33:57.512 --> 01:33:59.512
reliable APIs.  When you go from
project to project 

01:34:03.486 --> 01:34:07.352
you want to reuse what you 
built, you want to get support 

01:34:03.486 --> 01:34:05.540
from a large community.
     At the same time, we're 

01:34:05.541 --> 01:34:07.541
talking about richer  
experiences with these 

01:34:10.508 --> 01:34:14.708
devices, so obviously you need 
to get your app working, chances

01:34:10.508 --> 01:34:12.478
are you need to get  third-party
apps and services working.  Each

01:34:12.479 --> 01:34:14.479
time you need to figure out 
basic 

01:34:15.485 --> 01:34:15.741
building blocks like a reliable 
setup flow from a smart phone 

01:34:15.742 --> 01:34:18.209
for instance.  You could do it 
all yourself, but it just feels 

01:34:18.210 --> 01:34:21.099
like extra time and effort.
     Second, when you get down 

01:34:21.100 --> 01:34:23.100
to the 

01:34:27.262 --> 01:34:28.923
hardware, building prototypes 
with microprocessor SoCs have 

01:34:28.924 --> 01:34:31.355
gotten easier over time.  People
use all sorts of prototyping 

01:34:33.028 --> 01:34:35.266
tools to get that done, but 
those don't get you through to 

01:34:35.267 --> 01:34:37.267
production, let alone commercial
launch.

01:34:38.729 --> 01:34:40.969
We're talking about PCP design 
and layout involving high speed,

01:34:40.970 --> 01:34:45.263
highly integrate the components,
SoC vendor relationships for 

01:34:45.264 --> 01:34:49.353
general support and bring up 
component supplychain, access to

01:34:49.354 --> 01:34:51.378
parts in low volume, and so on. 
These are all very different 

01:34:51.379 --> 01:34:53.418
skillsets that you need to hire 
for your team.

01:34:55.073 --> 01:34:57.906
Again, prototyping solutions get
you off the ground, but that's 

01:34:57.907 --> 01:34:59.907
it.

01:35:01.417 --> 01:35:04.118
Finally, while it's amazing how 
much these devices can do on our

01:35:04.119 --> 01:35:08.593
behalf these days, the flip 
side, of course, is that they 

01:35:08.594 --> 01:35:11.238
have the keys to our home, our 
businesses, our banking systems.

01:35:14.110 --> 01:35:16.790
Clearly there is more to gain 
from attacking IoT devices.  

01:35:16.791 --> 01:35:18.831
Perhaps less obvious is why it's
hard to provide the security

01:35:21.280 --> 01:35:23.280
Well, it turns out it's 
incredibly 

01:35:24.287 --> 01:35:28.661
expensive to provide on products
out of the gate and keep them 

01:35:28.662 --> 01:35:30.662
updated over  time.

01:35:32.135 --> 01:35:32.946
It involves a lot of backend 
infrastructure to do this, and 

01:35:32.947 --> 01:35:35.682
with he know this at Google 
because we've been doing this 

01:35:35.683 --> 01:35:38.536
for many products.
     Meanwhile there is immense 

01:35:38.537 --> 01:35:40.537
cost pressure from end 
consumers, of course, 

01:35:43.397 --> 01:35:45.397
and it's hard

01:35:46.817 --> 01:35:48.817
toamortize costs without large 
volume.

01:35:50.084 --> 01:35:51.505
So those are the issues that our
engineering teams and business 

01:35:51.506 --> 01:35:53.550
teams focused on when we built 
Android Things.

01:35:57.294 --> 01:36:00.154
The thinking was we could take 
care of all the challenges that 

01:36:00.155 --> 01:36:03.201
make development expensive, we 
provide Android Things free of 

01:36:03.202 --> 01:36:05.874
charge and you have less to 
worry about.  Our goal is to 

01:36:05.875 --> 01:36:07.875
reduce the barrier to building 
powerful, intelligent edge 

01:36:09.400 --> 01:36:11.400
devices and make it more 
accessible to everyone.

01:36:14.713 --> 01:36:17.162
Now, let's take a look deeper.  
About building on reliable and 

01:36:19.201 --> 01:36:21.250
consistent APIs, Android Things 
is Android.  As you would 

01:36:21.251 --> 01:36:23.251
expect, you can rely on 

01:36:24.523 --> 01:36:27.022
the same Android APIs and Google
services as when you build for 

01:36:27.023 --> 01:36:29.063
phones.  Familiar tools such as 
Android Studio 

01:36:32.119 --> 01:36:34.119
and the Android SDK are 
available.

01:36:38.073 --> 01:36:40.073
You can build on Google Play 
services, 

01:36:41.499 --> 01:36:43.515
Google Cloud Platform, Firebase 
and the MLkit that you heard 

01:36:43.516 --> 01:36:44.940
about yesterday and more
     Of course, you're building 

01:36:44.941 --> 01:36:48.853
hardware and so it's also about 
component providers, SoC vendors

01:36:48.854 --> 01:36:52.940
and so on.  As a device maker, 
usually you spend a lot of time 

01:36:52.941 --> 01:36:56.819
interacting directly to get to a
working image.  With Android 

01:36:56.820 --> 01:37:00.913
Things, we've already done the 
hard work for you and that means

01:37:00.914 --> 01:37:02.935
you have access to hardware 
reference designs, it means the 

01:37:02.936 --> 01:37:04.936
build support package comes from
Google, and 

01:37:07.467 --> 01:37:09.467
you get a working image right 
away.

01:37:10.593 --> 01:37:12.442
You can scale to production 
because we've signed agreements 

01:37:12.443 --> 01:37:15.999
with the SoC vendors to 
guarantee support over the long 

01:37:16.000 --> 01:37:20.911
term.  Literally, our goal is if
you know how to build an Android

01:37:20.912 --> 01:37:23.558
app you can now prototype IoT 
products and take them all the 

01:37:23.559 --> 01:37:25.559
way to production.  You don't 
have to be a hardware 

01:37:28.443 --> 01:37:30.443
engineer or firmware engineer to
do this.

01:37:30.700 --> 01:37:32.742
Finally, on security, our 
strategy is to have security 

01:37:32.743 --> 01:37:34.743
features built into the 
platform.

01:37:37.837 --> 01:37:39.672
Os hardening is on by default 
and you don't have to spend time

01:37:39.673 --> 01:37:45.443
figuring it out yourself.  What 
about fixes over time?  Regular 

01:37:45.444 --> 01:37:49.304
security patches come regularly 
from Google.  Google provides 

01:37:49.305 --> 01:37:51.305
all the backend infrastructure 
for you to be in control, 

01:37:53.142 --> 01:37:55.142
and you can decide when those go
out.

01:37:55.390 --> 01:37:57.390
Now, let's go a bit deeper.  How
do all the pieces that I just 

01:37:58.669 --> 01:38:01.388
talked about fit together?  
Developers often ask me, how is 

01:38:02.817 --> 01:38:04.817
Android Things different from 
Android?

01:38:06.286 --> 01:38:09.559
How is it different from AOSP?
     I found that the best way 

01:38:09.560 --> 01:38:11.560
to describe Android Things is 
that it's a 

01:38:16.729 --> 01:38:18.729
fully managed solution beyond an
AOSP model.

01:38:20.410 --> 01:38:21.824
At the lowest level we define 
turnkey hardware in partnership 

01:38:21.825 --> 01:38:23.825
with the silicon providers, this
is on a form of system 

01:38:27.120 --> 01:38:28.132
module architecture and I'll 
talk about more on that in a bit

01:38:28.133 --> 01:38:30.133
     The way it works though is 
we work 

01:38:33.836 --> 01:38:36.957
closely with SoCs to land code 
in the Google tree.  Google is 

01:38:36.958 --> 01:38:40.223
hosting the BSPs.  In fact, we 
have the system in our test labs

01:38:40.224 --> 01:38:42.224
looked up for continuous 
integration.

01:38:43.108 --> 01:38:45.974
Moving up to Android in the 
framework layers, Android Things

01:38:45.975 --> 01:38:48.668
is Android.  What we've done is 
we took Android and 

01:38:51.753 --> 01:38:53.753
we shrunk it down to around 50% 
of the 

01:38:55.858 --> 01:38:57.110
footprint of AOSP, it can run 
with lower compute and storage 

01:38:57.111 --> 01:38:58.925
requirements.
     Security features are built

01:38:58.926 --> 01:39:02.819
in, meaning they're done for you
and they're on by default.

01:39:06.087 --> 01:39:08.087
Up at the top is the app layer.

01:39:09.192 --> 01:39:10.207
We formalized a boundary so all 
the  product-specific code lives

01:39:10.208 --> 01:39:14.545
there.  We make sure the Google 
services you might want to work 

01:39:14.546 --> 01:39:16.546
with work well out of 

01:39:17.824 --> 01:39:19.824
the box so your apps can rely on
Google 

01:39:22.749 --> 01:39:24.576
Play Services,  Firebase, Cloud 
Platform, Assistant, and more

01:39:24.577 --> 01:39:26.577
     Finally, what's pictured on
the 

01:39:31.693 --> 01:39:33.693
left side is the management 
console.

01:39:35.190 --> 01:39:36.037
It shows everything from bottom 
to top because it's where you 

01:39:36.038 --> 01:39:40.549
control everything that goes 
into your device, where you get 

01:39:40.550 --> 01:39:42.550
access to the BSP that Google 
and SoC vendors are supporting, 

01:39:44.429 --> 01:39:47.071
it's where you create full 
product builds with all your 

01:39:47.072 --> 01:39:51.966
apps and services included, it's
where you manage releases and 

01:39:51.967 --> 01:39:54.857
update channels over time.
     As you can see, that's why 

01:39:54.858 --> 01:39:58.310
I described Android Things as a 
fully managed solution.  It 

01:39:58.311 --> 01:40:00.782
gives you portfolio of reference
hardware to choose from, it 

01:40:00.783 --> 01:40:03.456
gives you Android with security,
and key services working on top.

01:40:06.511 --> 01:40:07.931
It gives you console to 
configure what exactly goes into

01:40:07.932 --> 01:40:09.932
your  devices.  It's all of the 
ingredients necessary 

01:40:23.096 --> 01:40:25.096
to prototype and scale to 
production.

01:40:29.129 --> 01:40:33.129
     On behalf of the entire 
Android Things team, I'm super 

01:40:29.129 --> 01:40:30.597
excited to share that we are now
generally available.  Version 

01:40:30.598 --> 01:40:32.598
170 is the first long-term 

01:40:33.996 --> 01:40:38.129
supported release.  Came out two
days ago on Monday, fresh off 

01:40:33.996 --> 01:40:39.161
the suppress.  Many of you have 
helped us along the way.  We've 

01:40:39.162 --> 01:40:41.421
seen more than 100,000 downloads
of the Android Things SDK.

01:40:45.534 --> 01:40:47.394
We've received feedback from 
more than 10,000 developers and 

01:40:47.395 --> 01:40:48.833
it's all critical to get us to 
this point.  Thank you so much.

01:40:48.834 --> 01:40:55.151
     Now, what does Version 1.0 
mean for you?  Most importantly,

01:40:55.152 --> 01:40:57.411
it means Android Things is a 
stable base for you to build 

01:40:59.245 --> 01:41:03.123
commercial products.  In fact, 
we've worked with a few partners

01:41:03.124 --> 01:41:05.124
to put Android Things through 

01:41:06.185 --> 01:41:06.794
its paces and vet whether we 
could power real shipping 

01:41:06.795 --> 01:41:09.463
products.
     Let me show you a few.

01:41:12.970 --> 01:41:14.638
What you see here is our first 
shipping product and it really 

01:41:14.639 --> 01:41:17.693
put our program to the test.  
This is a smart speaker by LG 

01:41:17.694 --> 01:41:20.363
and it landed on shelfs last 
month.

01:41:23.684 --> 01:41:25.923
So the story is LG wanted to 
build a smart speaker with 

01:41:25.924 --> 01:41:28.403
high-end audio and go to market 
quickly and they felt we would 

01:41:29.440 --> 01:41:31.085
be a good fit.
     One of the first things was

01:41:31.086 --> 01:41:37.111
to determine a good hardware 
reference design.  The system 

01:41:37.112 --> 01:41:39.757
module architecture that we 
talked about before is in all 

01:41:39.758 --> 01:41:41.758
the shipping  products.

01:41:43.653 --> 01:41:45.087
From your point of view, it is 
all done so you can just pick it

01:41:45.088 --> 01:41:48.169
up, it will be an officially 
supported platform and you're 

01:41:48.170 --> 01:41:50.170
good to go.

01:41:52.017 --> 01:41:52.852
Well, LG was also concerned 
about ongoing security  fixes 

01:41:52.853 --> 01:41:54.853
and 

01:41:57.427 --> 01:42:01.901
infrastructure to send over the 
air updates.  Bottom line these 

01:42:01.902 --> 01:42:03.902
guys want to work on 

01:42:05.165 --> 01:42:07.014
amazing audio and not staff up a
team to do security and do OS 

01:42:07.015 --> 01:42:09.161
bringup.  This is smart speaker 
so it's 

01:42:13.244 --> 01:42:14.468
nontrivial audio processing and 
audiocrafting for Google 

01:42:14.469 --> 01:42:16.954
assistant, we make sure they 
work well and they're part of 

01:42:16.955 --> 01:42:19.395
the full solution as well
     There is more OEMs working 

01:42:19.396 --> 01:42:24.950
on smart speakers and they'll be
coming out in retail soon.

01:42:29.943 --> 01:42:32.019
Soon after, partner chose us for
a new category called Smart 

01:42:32.020 --> 01:42:34.020
Displays, the 

01:42:36.494 --> 01:42:38.734
idea is a visual Google 
assistant, deep integration with

01:42:38.735 --> 01:42:40.735
photos, maps, video calling, 
YouTube, and so on.

01:42:44.043 --> 01:42:46.693
What you see are devices from 
Lenovo, JBL and LG.  All of 

01:42:46.694 --> 01:42:49.340
these guys wanted to move 
quickly and they felt that we 

01:42:49.341 --> 01:42:52.620
could help them do that.
     at the time, we were 

01:42:52.621 --> 01:42:54.621
already 

01:42:56.312 --> 01:42:58.757
working with SoC vendors, 
expanding our portfolio and we 

01:42:58.758 --> 01:43:00.184
were locked in a common system 
module for all of these 

01:43:00.185 --> 01:43:02.185
products.  In other words, if 
you looked under 

01:43:05.924 --> 01:43:07.754
the hood, all of them are using 
the same system-on module which 

01:43:07.755 --> 01:43:12.065
is quite cool.  Again, when you 
work on your project, you can 

01:43:12.066 --> 01:43:13.713
just skip all of that upfront 
SoC work and just pick up the 

01:43:13.714 --> 01:43:15.714
supported design.

01:43:18.389 --> 01:43:19.397
The OEMs were also concerned 
about ongoing updates especially

01:43:19.398 --> 01:43:23.875
because this is a new product 
category.  They're expecting 

01:43:23.876 --> 01:43:25.876
frequent updates and during 
development, they wanted to 

01:43:29.104 --> 01:43:29.912
partition folks into different 
groups and test the user 

01:43:29.913 --> 01:43:31.913
experience.

01:43:33.164 --> 01:43:35.164
This is where our console was 
put to 

01:43:36.246 --> 01:43:37.875
the test to manage all the 
builds, release channels, and 

01:43:37.876 --> 01:43:40.540
frequent updates
     Of course, IoT is broad and

01:43:40.541 --> 01:43:44.841
diverse.  What's the most 
exciting for me is see being 

01:43:44.842 --> 01:43:46.842
what everyone has been building 
based on our developer previews.

01:43:48.311 --> 01:43:50.360
Here are two examples.
     The product on the right is

01:43:50.361 --> 01:43:52.361
made by 

01:43:57.128 --> 01:43:58.157
a company called byteflies, a 
wearable startup based in 

01:43:58.158 --> 01:44:00.158
Belgium.

01:44:01.834 --> 01:44:03.483
The hand is holding a sensor 
that monitors vital signs and it

01:44:03.484 --> 01:44:05.484
sends the data back to the 
Cloud.

01:44:07.965 --> 01:44:09.996
They let us know Android Things 
helped turn the docking station 

01:44:09.997 --> 01:44:12.434
into a secure hub.  They don't 
have to worry about ongoing 

01:44:14.082 --> 01:44:15.701
fixes and how to update the 
device

01:44:15.702 --> 01:44:17.702
The product on the left is made 
by 

01:44:21.839 --> 01:44:23.839
a couple called Mirego based in 
Montreal.

01:44:25.312 --> 01:44:27.312
Built a network of public things
and 

01:44:29.247 --> 01:44:31.079
connected to a photobooth in 
downtown Montreal that sounds 

01:44:31.080 --> 01:44:34.950
really fun.  They wanted a 
solution to help them move 

01:44:34.951 --> 01:44:36.780
quickly and Android could help 
them do that.  If you're 

01:44:36.781 --> 01:44:38.781
building a new product by 

01:44:39.823 --> 01:44:41.823
Android Things, we want to work 
with you too.

01:44:41.851 --> 01:44:43.074
We introduced a special limited 
program to partner with the 

01:44:43.075 --> 01:44:45.075
Android 

01:44:47.161 --> 01:44:48.583
Things team for technical 
guidance and support.  If your 

01:44:48.584 --> 01:44:50.226
company is interested in 
learning more, please let us 

01:44:50.227 --> 01:44:55.539
know at the link.
     So now that I've shown you 

01:44:55.540 --> 01:45:00.461
some real products, let's switch
gears and go back to how all the

01:45:00.462 --> 01:45:03.754
pieces fit together starting 
from the bottom.  We talked 

01:45:03.755 --> 01:45:05.597
about the hardware reference 
designs, we talked about the 

01:45:05.598 --> 01:45:07.598
system 

01:45:09.028 --> 01:45:11.110
modules, you might be wondering,
what do they actually look like?

01:45:14.366 --> 01:45:17.602
So on the right here is a 
system-on-module.  SoM for 

01:45:17.603 --> 01:45:19.603
short.

01:45:22.510 --> 01:45:25.013
It's the NXP, IMX7D.  All of the
complicated components are in 

01:45:25.014 --> 01:45:27.543
the SoM.  The key component such
as the SoC, 

01:45:31.860 --> 01:45:33.085
memory, flash, WiFi, Bluetooth, 
the baseboard is what you see on

01:45:33.086 --> 01:45:37.572
the left.  This one shown here 
is actually one of our 

01:45:37.573 --> 01:45:39.573
development baseboards, but you 
can 

01:45:40.838 --> 01:45:42.258
imagine  designing 
product-specific baseboards with

01:45:42.259 --> 01:45:44.259
just the right set of 

01:45:45.537 --> 01:45:47.537
connectors and plugging the SoM 
on top.

01:45:48.179 --> 01:45:50.845
The SoM is complicated and quite
costly to design if you were to 

01:45:50.846 --> 01:45:56.359
do it yourself, and we've done 
the hard work for you.  It would

01:45:56.360 --> 01:45:58.180
also be very expensive at low 
volume, but the SoMs are what 

01:45:58.181 --> 01:46:01.306
everyone will be using and that 
helps drive up volume for 

01:46:01.307 --> 01:46:03.344
everyone.
     The baseboards are much 

01:46:03.345 --> 01:46:09.326
less expensive to produce, even 
at lower quantities.  The 

01:46:09.327 --> 01:46:11.327
electronics are much lower speed
and less dense.

01:46:12.390 --> 01:46:14.055
What I've shown here is also 
referred to as a physical SoM 

01:46:14.056 --> 01:46:16.955
because the SoM is on its own 
board.

01:46:20.046 --> 01:46:22.097
You can also imagine designing 
it in so it's all on one single 

01:46:22.098 --> 01:46:24.098
board and we call that the 
virtual SoM.

01:46:25.984 --> 01:46:27.984
This would allow you to save on 

01:46:29.183 --> 01:46:30.629
costs at high volume or to 
better match XY dimensions for 

01:46:30.630 --> 01:46:34.517
your product.  Going back to the
three Smart Displays I showed 

01:46:34.518 --> 01:46:37.150
earlier, they all use different 
tactics, some use physical SoMs 

01:46:37.151 --> 01:46:40.208
and some design it in virtually.

01:46:46.728 --> 01:46:48.568
For each SoM, Google hosts the 
board support package,  BSP for 

01:46:48.569 --> 01:46:51.464
short.  In other words, you 
don't have to interact with the 

01:46:51.465 --> 01:46:55.520
SoC vendors.  There is a stable 
layer of separation with the BSP

01:46:55.521 --> 01:46:58.030
that makes the code portable.  
You could imagine starting 

01:46:58.031 --> 01:47:01.299
development on one SoM and then 
swopping to another at later 

01:47:01.300 --> 01:47:02.937
stages of production if your 
design changes without having to

01:47:02.938 --> 01:47:08.893
change your code.
     Now, part of making the SoM

01:47:12.830 --> 01:47:15.301
architecture viable is 
guaranteed support.  Behind the 

01:47:15.302 --> 01:47:17.148
scenes we've been working really
hard with the SoC vendors to 

01:47:17.149 --> 01:47:19.149
work out the collaboration so 
you don't have 

01:47:22.015 --> 01:47:24.015
to talk directly to them.  We 
are announcing SoMs that are 

01:47:25.693 --> 01:47:28.132
certified for production.  The 
list includes hardware from 

01:47:31.222 --> 01:47:33.675
Mediatek, NXP and Qualcomm.
     More specifically, SoMs on 

01:47:33.676 --> 01:47:38.364
this list have guaranteed 
long-term support and all 

01:47:38.365 --> 01:47:40.365
security features built in, 

01:47:41.443 --> 01:47:43.681
making it possible to bring 
prototypes and go all the way to

01:47:43.682 --> 01:47:45.682
production.

01:47:46.841 --> 01:47:47.655
Hardware and reference designs 
for these SoMs will be available

01:47:47.656 --> 01:47:50.888
in the coming months, so stay 
tuned.

01:47:55.452 --> 01:47:57.452
SoMs supported for development 
is already available  now.

01:47:59.973 --> 01:48:01.824
Hardware from RaspberryPi and 
NXP.  Development hardware have 

01:48:01.825 --> 01:48:03.825
a large community of support and
are readily 

01:48:08.701 --> 01:48:10.701
available in retail even at unit

01:48:13.666 --> 01:48:15.284
equal tees, usually for cheap.  
The beautiful thing about the 

01:48:15.285 --> 01:48:19.170
Android model is you can swop 
over to SoMs and certified for 

01:48:19.171 --> 01:48:21.689
production once you're ready
     Everyone has been 

01:48:21.690 --> 01:48:23.690
wondering, for the list of SoMs 
that are certified for 

01:48:25.768 --> 01:48:27.397
production, the ones on the 
left, how long is the support 

01:48:27.398 --> 01:48:29.398
and how much does it cost?

01:48:33.320 --> 01:48:34.746
Each SoM certified for 
production is supported by 

01:48:34.747 --> 01:48:37.640
Google for a minimum of three 
years from the time it was first

01:48:38.657 --> 01:48:42.526
made available.  What this means
is you will get regular security

01:48:42.527 --> 01:48:46.223
patches and stability fixes from
Google for you to push to your 

01:48:46.224 --> 01:48:50.726
devices.  You can even set your 
devices to auto-update and not 

01:48:50.727 --> 01:48:53.183
worry about it.
     In other words, you get to 

01:48:53.184 --> 01:48:58.137
fully harness the power of the 
Android Security Team.  Of 

01:48:58.138 --> 01:49:00.439
course, you can push your own 
updates to your devices any time

01:49:00.440 --> 01:49:02.957
you want for the entire product 
lifetime.

01:49:04.394 --> 01:49:06.929
What about fees?  There are no 
charges to using Android Things.

01:49:09.360 --> 01:49:11.817
There are no license fees for 
the OS or the management 

01:49:11.818 --> 01:49:13.818
console.

01:49:16.338 --> 01:49:17.741
The API surface is stable, 
meaning the length of support is

01:49:17.742 --> 01:49:22.894
provided for each major version.
This is why we refer to 1.0 as 

01:49:22.895 --> 01:49:24.934
long-term support.  We know  
moving to a new major version 

01:49:26.578 --> 01:49:29.015
can be disruptive and it may not
make sense for many IoT product,

01:49:29.016 --> 01:49:32.282
so there is no need to do that.
     Let me show you in a bit 

01:49:32.283 --> 01:49:39.306
more detail.  Each line on this 
chart represents a major version

01:49:39.307 --> 01:49:42.578
of Android Things, and of course
2.0, 3.0 in the future.

01:49:49.498 --> 01:49:49.513
As I said, every measured 
version will have long-term 

01:49:49.514 --> 01:49:51.546
support, the minimum three years
we talked about.  These major 

01:49:51.547 --> 01:49:54.391
versions do map to underlying 
Android deserts and will pick 

01:49:56.025 --> 01:49:58.025
the right  points to intersect 
over time

01:49:58.079 --> 01:50:02.770
The important point is when 2.0 
comes out, 1.0 and 2.0 are 

01:50:02.771 --> 01:50:04.771
supported in parallel.

01:50:06.012 --> 01:50:08.484
The security patches and 
stability fixes come regularly 

01:50:08.485 --> 01:50:10.485
and that's what 

01:50:12.369 --> 01:50:14.237
each white dot in the lines 
represent, and we'll also have 

01:50:14.238 --> 01:50:17.913
minor feature updates on the 
latest major version, so this is

01:50:17.914 --> 01:50:19.944
so we continue to address 
community feedback in a timely 

01:50:19.945 --> 01:50:23.809
manner.  So we won't wait for 
the next major version to push 

01:50:23.810 --> 01:50:26.453
these out.
     In fact, in the coming 

01:50:26.454 --> 01:50:28.454
months, 1.

01:50:29.866 --> 01:50:31.866
1 will come out with 
improvements for you.

01:50:34.541 --> 01:50:35.965
One last note on SoMs.  
Obviously the work we do behind 

01:50:35.966 --> 01:50:39.632
the scenes with the SoM vendors 
is never ending.  It's an 

01:50:39.633 --> 01:50:44.792
ongoing process.  We'll continue
to expand the SoM portfolio.  

01:50:44.793 --> 01:50:46.633
You saw the vendors that already
have something listed 

01:50:46.634 --> 01:50:48.634
officially, and we're 

01:50:49.972 --> 01:50:51.972
deeply engaged with others too 
like Rockship.

01:50:52.411 --> 01:50:54.265
The point is once we put a SoM 
up as certified for production, 

01:50:54.266 --> 01:50:59.769
it's a commitment.  The ones you
saw all support 1.0 and when we 

01:50:59.770 --> 01:51:02.230
eventually add 2.0, we'll be 
explicit about which SoMs 

01:51:03.863 --> 01:51:05.863
support it.

01:51:09.202 --> 01:51:11.233
Now, we've been talkings about 
the next layer up already since 

01:51:11.234 --> 01:51:14.543
Google supports the support 
package for every SoM, but what 

01:51:14.544 --> 01:51:16.544
does it actually look like.

01:51:18.432 --> 01:51:20.432
Let's go into that in a little 
bit more detail

01:51:20.893 --> 01:51:23.548
What you see here is a 
simplified software stack for a 

01:51:23.549 --> 01:51:27.195
traditional Android Mobile 
Device.  Going from bottom to 

01:51:27.196 --> 01:51:31.325
top, the kernel up to the HAL 
layers is primarily focused on 

01:51:31.326 --> 01:51:33.986
enabling hardware support.  The 
Android framework provides a 

01:51:33.987 --> 01:51:35.987
rich 

01:51:38.492 --> 01:51:40.342
set of experiences for apps and 
the applications provide useful 

01:51:40.343 --> 01:51:42.806
features, right.
     In IoT devices you can 

01:51:42.807 --> 01:51:44.807
imagine many 

01:51:45.911 --> 01:51:48.558
of the included components not 
making sense.  Well, you know, 

01:51:48.559 --> 01:51:50.800
embedded devices are usually 
single purpose, they may not 

01:51:53.882 --> 01:51:55.882
have a screen, users are not 
installing apps, and so on.

01:51:58.592 --> 01:52:00.592
So first Android Things removed 

01:52:02.475 --> 01:52:04.475
most of the user-facing 
applications and 

01:52:05.682 --> 01:52:07.555
visual of course framework 
components that don't make 

01:52:07.556 --> 01:52:12.263
sense.  There is no use for a 
messaging app.  This removes 

01:52:12.264 --> 01:52:14.118
unnecessary complexity and 
reduces the footprint of the 

01:52:14.119 --> 01:52:15.969
distribution.
     If you build a device with 

01:52:15.970 --> 01:52:20.484
a display, you have full 
control.  There is no system UI 

01:52:20.485 --> 01:52:22.485
to get in the way.

01:52:23.783 --> 01:52:25.994
Now with or without a display, 
the UI toolkit portions of the 

01:52:25.995 --> 01:52:29.636
framework remain available to 
the apps.  Activities are still 

01:52:29.637 --> 01:52:34.136
the primary component of an 
Android app.  The  framework 

01:52:34.137 --> 01:52:38.007
delivers all input events to the
foreground activity which has 

01:52:38.008 --> 01:52:41.072
focus.
     Next, we formalized the 

01:52:41.073 --> 01:52:44.368
boundary between the system and 
a product-specific code 

01:52:44.369 --> 01:52:46.369
necessary for the device.

01:52:49.053 --> 01:52:51.939
Product specific code is above 
the line in the app layer.  

01:52:51.940 --> 01:52:54.792
Everything below the line is 
provided by Google and our SoC 

01:52:54.793 --> 01:52:59.372
partners.  This way you don't 
have to figure out how to put 

01:52:59.373 --> 01:53:01.618
together a working image.  
Google can sign the full image 

01:53:01.619 --> 01:53:03.619
and 

01:53:06.044 --> 01:53:08.825
guarantee automatic security 
over the support timeframe

01:53:11.290 --> 01:53:14.175
You might be wondering how can 
this work in practice?  Well, 

01:53:14.176 --> 01:53:19.733
one crucial piece is the Android
Things Support  Library.  I'll 

01:53:19.734 --> 01:53:23.021
touch upon the API surface 
briefly.  For example, you may 

01:53:23.022 --> 01:53:25.022
be wondering how to control 
hardware.

01:53:28.269 --> 01:53:30.580
The peripheral I/O API allows 
apps to interface with 

01:53:34.069 --> 01:53:38.986
low level peripherals using 
industry protocols like GPIO.  

01:53:38.987 --> 01:53:41.850
It allows apps to inject 
hardware events into the Android

01:53:41.851 --> 01:53:44.088
framework.
     You might be wondering how 

01:53:44.089 --> 01:53:47.139
to call APIs that usually 
involve a dialogue or view to 

01:53:47.140 --> 01:53:50.587
the user.  These don't make 
sense when displays are 

01:53:50.588 --> 01:53:55.297
optional.  So we've added APIs 
to control settings, control 

01:53:55.298 --> 01:53:58.167
device updates, and configure 
local area connectivity 

01:54:02.293 --> 01:54:03.910
including Bluetooth and LoWPAN
     I'd like to show you the 

01:54:03.911 --> 01:54:07.837
complete picture.  We've already
talked about the portfolio of 

01:54:07.838 --> 01:54:10.725
SoMs you can select from and 
these come in at the bottom.  

01:54:10.726 --> 01:54:13.166
There are actually two more 
building blocks.  The first is 

01:54:13.167 --> 01:54:15.621
device configuration and the 
second is security.

01:54:16.863 --> 01:54:20.751
Let's start with device 
configuration.  It's the other 

01:54:20.752 --> 01:54:22.752
crucial piece along 

01:54:27.343 --> 01:54:29.806
with the Android Things Support 
Library that helps maintain the 

01:54:29.807 --> 01:54:31.885
formal like we talked about.  
SoMs can support a wide variety 

01:54:31.886 --> 01:54:33.886
of 

01:54:35.768 --> 01:54:38.009
hardware and so in many cases 
the OS has to know which is 

01:54:38.010 --> 01:54:40.010
connected in order to properly 
connect those interfaces.

01:54:41.467 --> 01:54:43.467
For instance, which audio 
devices 

01:54:44.529 --> 01:54:46.529
are connected where and their 
formats?

01:54:47.578 --> 01:54:50.243
We provide a configuration 
system so  OEMs can is divide 

01:54:50.244 --> 01:54:54.797
the connected hardware in the 
console which will correspond 

01:54:54.798 --> 01:54:56.039
the image at build time
     Cool, let's talk a little 

01:54:56.040 --> 01:54:58.040
bit about security.

01:55:02.860 --> 01:55:04.896
First off, the OS hardening that
we do on Android is enabled to 

01:55:04.897 --> 01:55:09.614
Android Things so these are 
things like permissions, the 

01:55:09.615 --> 01:55:11.615
application sandbox, mandatory 

01:55:13.287 --> 01:55:15.287
access control with SELinux.

01:55:16.497 --> 01:55:21.247
Kernel Cisco filtering and so 
on.  Images of sign, you don't 

01:55:21.248 --> 01:55:23.063
need to run any signing 
infrastructure yourself.  Google

01:55:23.064 --> 01:55:26.750
provides the infrastructure to 
build the full image for you.  

01:55:26.751 --> 01:55:30.427
These partitions are signed for 
security.  Verified boot, which 

01:55:30.428 --> 01:55:34.172
is full he'd implemented for 
SoMs certified for production, 

01:55:34.173 --> 01:55:36.173
make sure you're running a valid
image at all times

01:55:37.643 --> 01:55:39.104
There is lots of interesting 
scenarios that are handled for 

01:55:39.105 --> 01:55:45.205
you, and I always get a kick of 
thinking about them.  For 

01:55:45.206 --> 01:55:48.057
example, what about running an 
older image with a vulnerability

01:55:48.058 --> 01:55:51.937
that's since been fixed?  Robot 
protection makes sure this 

01:55:52.955 --> 01:55:54.955
doesn't happen.

01:55:56.443 --> 01:55:59.515
Another one is product  key, so 
images only run where intended. 

01:55:59.516 --> 01:56:01.516
You can ensure only your product

01:56:04.794 --> 01:56:07.098
images run on your devices
     Finally you don't need to 

01:56:07.099 --> 01:56:09.566
run update infrastructure.  
Google takes care of building 

01:56:09.567 --> 01:56:11.567
and serving updates, the same 
infrastructure 

01:56:13.986 --> 01:56:18.034
we use for our own products
     All right.  Now we're 

01:56:18.035 --> 01:56:20.043
moving on to the app layer where
all of the product-specific code

01:56:20.044 --> 01:56:22.085
lives.  What does building an 
app on Android 

01:56:25.137 --> 01:56:27.137
Things look like?

01:56:29.246 --> 01:56:31.931
To get started, we want access 
to the Android thing  Support 

01:56:31.932 --> 01:56:34.210
Library we talked about.  Built 
into the shared devices as a 

01:56:34.872 --> 01:56:36.872
shared library.

01:56:37.943 --> 01:56:39.943
We're showing code snippets from
two files here.

01:56:42.041 --> 01:56:44.290
At the top is a snippet from the
file.  Declare the SDK 

01:56:44.291 --> 01:56:47.966
dependency there and it will get
pulled in.  The bottom is a 

01:56:47.967 --> 01:56:50.440
snippet of the Android manifest 
file, and you notice we use the 

01:56:53.086 --> 01:56:54.918
user's library tag so the app 
can access the device's shared 

01:56:54.919 --> 01:56:56.919
library.  Below that is 
supplying the HOME 

01:56:59.849 --> 01:57:01.269
category to one of your 
activities.  What this does is 

01:57:01.270 --> 01:57:05.769
the system will launch the 
activity automatically on boot 

01:57:05.770 --> 01:57:08.036
and relaunch it if the app  
terminates.  This is of course 

01:57:08.037 --> 01:57:10.263
exactly the behavior you would 
expect for embedded devices.

01:57:11.933 --> 01:57:16.637
Now that we have this set up, 
let's do something  useful.  The

01:57:16.638 --> 01:57:18.905
example here is very simple.  It
detects a button press, but it's

01:57:18.906 --> 01:57:23.793
a good demonstration of how to 
interface directly with 

01:57:23.794 --> 01:57:25.794
peripherals using the 

01:57:27.089 --> 01:57:29.941
peripheral I/O API.  The code at
the top is the Android manifest 

01:57:29.942 --> 01:57:34.308
file.  This is where we declare 
the required permissions to use 

01:57:34.309 --> 01:57:39.619
peripheral I/O.  The code 
snippet below is the activity.  

01:57:39.620 --> 01:57:41.620
There we use the peripheral I/O 
API to 

01:57:42.706 --> 01:57:45.126
open a connection to a GPO pin 
which is where the button is 

01:57:45.127 --> 01:57:49.484
connected, and we configure the 
GPIO pin as an input and attach 

01:57:49.485 --> 01:57:52.138
a callback and that's pretty 
much it.  Good to go.

01:57:54.182 --> 01:57:56.182
A similar workflow is used for 
all 

01:57:57.263 --> 01:57:59.304
of the peripheral I/O interfaces
so you can imagine adding a few 

01:57:59.305 --> 01:58:01.305
lines and you can light up an 
LED.

01:58:04.604 --> 01:58:06.850
Of course, it's not just about 
simple stuff.  There is a wide 

01:58:06.851 --> 01:58:10.327
variety of peripherals out 
there.  Your app can interact 

01:58:10.328 --> 01:58:12.328
with all kinds 

01:58:14.422 --> 01:58:16.422
of sensors, actuators and so on 
this way.

01:58:18.326 --> 01:58:21.807
we've expanded our community hub
this week as part of the 1.0 

01:58:21.808 --> 01:58:23.808
announcement.

01:58:26.941 --> 01:58:29.022
The site is  
Androidthings.withgoogle.com.  

01:58:29.023 --> 01:58:30.812
It brings together all of the 
information in one place, 

01:58:30.813 --> 01:58:34.273
samples, documents, forum.  
Also, as you probably guess, 

01:58:34.274 --> 01:58:38.302
much of the code we showed 
before about driving hardware 

01:58:38.303 --> 01:58:41.218
peripherals isn't exactly 
product specific.  You can get 

01:58:41.219 --> 01:58:43.219
up and running quickly 

01:58:44.269 --> 01:58:46.269
with prebuilt drivers from my 
peripheral driver library.

01:58:48.815 --> 01:58:50.080
These drivers extract a low 
level communication details 

01:58:50.081 --> 01:58:54.801
associated with many common 
hardware peripherals, you can 

01:58:54.802 --> 01:58:57.076
browse the driver library at the
community hub, and we're also 

01:58:57.077 --> 01:59:00.734
now expecting -- accepting 
community contributions as well,

01:59:00.735 --> 01:59:05.021
so let's all make this better 
together.  Be sure to check that

01:59:05.022 --> 01:59:10.426
out.
     Where do you go from here? 

01:59:10.427 --> 01:59:13.090
You have full access to the 
Android SDK and NDK when 

01:59:13.091 --> 01:59:17.841
building apps.  You can use 
Android Studio, develop your 

01:59:17.842 --> 01:59:19.665
apps, leverage standard 
developer tools and third-party 

01:59:19.666 --> 01:59:21.666
libraries.

01:59:25.535 --> 01:59:28.486
Many projects find Google Play 
Services, Firebase, Google Cloud

01:59:30.141 --> 01:59:32.566
Platform, et cetera, very 
useful.  In fact, you can create

01:59:32.567 --> 01:59:35.015
an  end-to-end demo very 
quickly.  For instance, if 

01:59:35.016 --> 01:59:37.702
you're collecting sensor data, 
you can use Cloud IoT Core 

01:59:41.208 --> 01:59:42.006
to help youingest data and do 
something with it in the Cloud

01:59:42.007 --> 01:59:45.906
     If you're taking photo, the
Cloud Vision API, for example, 

01:59:45.907 --> 01:59:48.349
can help you with object 
detection.  Of course, there is 

01:59:48.350 --> 01:59:50.448
a lot more it.  We'll have many 
samples in the 

01:59:53.540 --> 01:59:55.540
community site for you to check 
out.

01:59:56.829 --> 01:59:59.674
Let's say a bit more about 
Google Play Services because 

01:59:59.675 --> 02:00:01.675
we've created an optimized 
lighter weight version of that 

02:00:04.334 --> 02:00:06.422
for Android Things.  It's 
optional so it doesn't take up 

02:00:07.028 --> 02:00:09.497
space if you don't need it.  
Many developers do find it very 

02:00:09.498 --> 02:00:11.498
useful though.

02:00:13.065 --> 02:00:15.486
You can literally take a 
checkbox and add it to your 

02:00:15.487 --> 02:00:17.487
build from the console.

02:00:18.556 --> 02:00:21.410
You can find a Firebase APIs in 
there which are used in many of 

02:00:21.411 --> 02:00:25.157
our  samples.  For example, the 
realtime database is very useful

02:00:25.158 --> 02:00:27.158
when you sync device data.

02:00:28.410 --> 02:00:30.445
You can also use the new MLkit 
to integrate Google's Machine 

02:00:30.446 --> 02:00:32.897
Learning technology into your 
app.

02:00:34.531 --> 02:00:36.531
There is of course a lot more in

02:00:38.630 --> 02:00:40.630
Play Services, a few location 
APIs, 

02:00:42.303 --> 02:00:44.303
nearby for setup, maps, and 
more.

02:00:45.990 --> 02:00:47.631
The final piece to Android 
Things is a console for managing

02:00:47.632 --> 02:00:50.483
what's running on your devices. 
It's shown vertically cutting 

02:00:50.484 --> 02:00:54.991
across everything from bottom to
top because that's where you 

02:00:54.992 --> 02:00:57.838
manage all the builds and 
releases for your entire device 

02:01:01.720 --> 02:01:03.720
fleet at every stage of the 
product development process.

02:01:04.464 --> 02:01:08.520
Let me explain.  Here is a very 
simplified view of the product 

02:01:08.521 --> 02:01:11.561
development flow.  Every product
goes through the prototyping 

02:01:11.562 --> 02:01:14.241
phase where you just want to get
something working, then a series

02:01:14.242 --> 02:01:18.782
of hardware validation 
manufacturing stages, and 

02:01:18.783 --> 02:01:22.035
finally commercial launch.
     At the beginning, you're 

02:01:22.036 --> 02:01:25.528
going to pick up one of the 
development SoMs because that's 

02:01:25.529 --> 02:01:27.782
the easiest thing to do, and 
then later swop to one of the 

02:01:27.783 --> 02:01:32.492
SoMs certified for production.  
After you get the hardware, you 

02:01:32.493 --> 02:01:34.493
might 

02:01:36.368 --> 02:01:39.039
be wondering well, how do I 
assemble an image and push it to

02:01:39.040 --> 02:01:41.040
the device?

02:01:42.148 --> 02:01:44.016
In the prototyping phase, you 
probably just want quick access 

02:01:44.017 --> 02:01:46.081
to a generic image to get you 
going.

02:01:49.223 --> 02:01:51.050
You might only care about one 
device, so you go to the console

02:01:51.051 --> 02:01:53.697
and tell it which SoM you've 
chosen and that's pretty much 

02:01:53.698 --> 02:01:55.698
it.

02:01:58.599 --> 02:02:00.599
You can then flash the image and
siloed apps to your device

02:02:01.724 --> 02:02:04.372
As your product evolves you come
back to the console to customize

02:02:04.373 --> 02:02:06.527
a lot more.  For instance, you 
may want to change 

02:02:09.580 --> 02:02:12.338
the partition sizes, you may 
want to include Google Play  

02:02:12.339 --> 02:02:14.339
Services because your apps need 
it, you may want to 

02:02:18.604 --> 02:02:20.661
modify the de device 
configuration build time based 

02:02:20.662 --> 02:02:22.907
on the  peripherals, you may 
start caring about a lot more 

02:02:22.908 --> 02:02:25.186
devices.
     For the Smart Displays and 

02:02:25.187 --> 02:02:29.695
smart speaker devices that we 
showed earlier, the OEMs use the

02:02:29.696 --> 02:02:31.696
console to split the 

02:02:33.783 --> 02:02:34.805
devices into groups, so 
developers, QA, early beta 

02:02:34.806 --> 02:02:37.081
testers, they're all in 
different groups, they all have 

02:02:39.132 --> 02:02:41.196
different builds, and on 
different update channels.

02:02:42.866 --> 02:02:45.467
All of this is configured from 
the console.  When you go to 

02:02:45.468 --> 02:02:47.468
production, you 

02:02:49.021 --> 02:02:52.887
obviously need to assemble -- 
I'm sorry.  Previous slide.  

02:02:52.888 --> 02:02:54.888
When you go to production, you 

02:02:55.969 --> 02:02:57.604
obviously need to assemble the 
entire factor image that 

02:02:57.605 --> 02:02:59.694
includes apps and services.  You
want to update your app over the

02:03:01.483 --> 02:03:03.483
lifetime of the device.  It's 
important to have control over 

02:03:03.545 --> 02:03:05.545
rollout.

02:03:08.744 --> 02:03:12.097
For example, roll back if 
something goes wrong.  Gradual 

02:03:12.098 --> 02:03:13.539
percentage rollup so you can go 
slow and check that things are 

02:03:13.540 --> 02:03:16.779
going well.  Access to metrics 
so you can see that things are 

02:03:16.780 --> 02:03:18.780
going in the right direction.

02:03:20.072 --> 02:03:21.942
All of this is why the console 
exists.  The underlying  backend

02:03:21.943 --> 02:03:25.655
infrastructure is the same as 
what Google uses for our own 

02:03:25.656 --> 02:03:27.734
products.

02:03:31.401 --> 02:03:33.917
So I just finished explaining 
how Android Things is a fully 

02:03:33.918 --> 02:03:35.918
managed solution.

02:03:36.972 --> 02:03:39.828
We have a lot more to show you 
at I/O.  Come and see us at our 

02:03:39.829 --> 02:03:42.670
sandbox dome, it's the giant 
bright orange one, it's hard to 

02:03:42.671 --> 02:03:49.181
miss.  The entire dome is filled
with Android Things demos.  You 

02:03:49.182 --> 02:03:50.638
can see how real commercial 
products evolve from prototype 

02:03:50.639 --> 02:03:53.921
to production, Smart Display, 
you can see them all there.

02:03:56.405 --> 02:03:58.265
We talked about devices getting 
increasingly smarter, we have 

02:03:58.266 --> 02:04:02.542
demos showing Machine Learning, 
ingesting realtime video so it 

02:04:02.543 --> 02:04:05.423
can recognize emotion, faces, 
handwriting and so on.

02:04:08.685 --> 02:04:11.544
By the way, you notice Android 
Things powering devices outside 

02:04:11.545 --> 02:04:14.613
of the dome as well.  It's 
powering the survey boxes all 

02:04:16.886 --> 02:04:18.886
around I/O for instant feedback.

02:04:20.759 --> 02:04:23.011
There is a five-foot tall robot 
roaming around somewhere, hard 

02:04:23.012 --> 02:04:26.984
to miss that one, Android Things
in there.  If you like to code, 

02:04:26.985 --> 02:04:30.557
come to our codelabs and get 
hands on.  We have one showing 

02:04:30.558 --> 02:04:33.018
how to work with TensorFlow, 
Cloud IoT, how we make the 

02:04:34.858 --> 02:04:36.536
survey box and more.
     There is eight more 

02:04:36.537 --> 02:04:39.974
sessions coming up today and 
tomorrow that go deeper into 

02:04:39.975 --> 02:04:44.683
specific topics.  For example, 
the session at 11:30 today talks

02:04:44.684 --> 02:04:46.924
about how we built the Smart 
Display product, the journey all

02:04:46.925 --> 02:04:51.465
the way from prototype to 
production.  The last session we

02:04:51.466 --> 02:04:53.466
have tomorrow talks about the 
console in detail and 

02:04:57.077 --> 02:05:00.021
how to manage your devices at 
different stages of the 

02:05:00.022 --> 02:05:03.036
development process.
     Finally, let's all have 

02:05:03.037 --> 02:05:05.037
some fun at 

02:05:08.181 --> 02:05:10.038
I/O, join our scavenger hunt at 
the link.  You might have seen 

02:05:10.039 --> 02:05:13.923
this already.  There is very 
cool Machine Learning enhanced 

02:05:13.924 --> 02:05:15.943
flowers that you'll notice, 
solve the puzzles and you get a 

02:05:15.944 --> 02:05:21.539
free hardware developer kit.
     With that, let's all go 

02:05:21.540 --> 02:05:24.214
build some hardware.  If you 
know thousand build an Android 

02:05:28.168 --> 02:05:30.653
app, you now have a new 
superpower.  You can prototype 

02:05:30.654 --> 02:05:33.297
IoT products and bring them all 
the way to production with 

02:05:33.298 --> 02:05:37.840
Android Things.  You don't have 
to be a hardware engineer or 

02:05:37.841 --> 02:05:39.841
firmware engineer to do this.

02:05:42.390 --> 02:05:44.417
Pick up a kit from the scavenger
hunt and head to Android Things.

02:05:46.288 --> 02:05:49.579
withgoogle.com to get started.  
This concludes the talk.  My 

02:05:49.580 --> 02:05:51.580
name is Vince.  Thank you and 
good luck.

02:05:52.419 --> 02:05:55.301
(Applause)

02:05:58.604 --> 02:06:00.604
this session.

02:06:02.067 --> 02:06:03.491
Grand ambassadors will assist 
with directing you through the 

02:06:03.492 --> 02:06:06.352
designated exits.  We'll be 
making room for those who have 

02:06:06.353 --> 02:06:08.184
registered for the next session.
If you've registered for the 

02:06:08.185 --> 02:06:12.068
next session in this room, we 
ask that you please clear the 

02:06:12.069 --> 02:06:15.339
room and return via the 
registration line outside.  

02:06:15.340 --> 02:06:17.384
Thank you.

02:19:16.325 --> 02:19:19.069
May 9, 2018

02:19:23.548 --> 02:19:25.548
10:30 a.m.

02:19:26.555 --> 02:19:28.555
PT

02:19:44.336 --> 02:19:46.336
A Fresh Look at Advanced cop 
topics 

02:19:47.352 --> 02:19:49.352
for

02:19:56.402 --> 02:19:58.402
advanced Topics for Android 
Experts

02:25:39.872 --> 02:25:45.021
     &gt;&gt; Welcome.  Please fill in
the seats near the front of the 

02:25:45.022 --> 02:25:47.022
room.  Thank you.

02:28:26.623 --> 02:28:29.696
&gt;&gt; At this time, please find 
your seat.  Our session will 

02:28:29.697 --> 02:28:31.697
begin soon.

02:30:33.430 --> 02:30:37.375
     &gt;&gt; RETO MEIER:  Wow.
     (Applause).

02:30:41.450 --> 02:30:43.450
     &gt;&gt; RETO MEIER:  Good 
morning, everyone.

02:30:45.559 --> 02:30:46.587
My name is Reto Meier, the 
Developer Advocate here at 

02:30:46.588 --> 02:30:48.588
Google.

02:30:51.295 --> 02:30:53.295
Technically, I'm a DA on the 
Google 

02:30:54.988 --> 02:30:57.645
Cloud dev rel team.  So if any 
of you bump into my boss or 

02:31:00.342 --> 02:31:02.367
anyone from the Google Cloud 
Team and they ask how the 

02:31:02.368 --> 02:31:04.368
presentation went, if you could 
tell them that I presented how 

02:31:08.485 --> 02:31:09.538
to build a Cloud  backend mobile
app, that would really help me 

02:31:09.539 --> 02:31:11.539
out.
     What I am present something

02:31:14.860 --> 02:31:16.860
hopefully what everyone is here 
to see, 

02:31:18.011 --> 02:31:20.266
Android Protips, a fresh look at
expert advice for advanced 

02:31:20.267 --> 02:31:23.139
Android developers.
     As the title suggestions, 

02:31:23.140 --> 02:31:29.079
this is a lot of technical talk.
There will be a lot of code.  If

02:31:29.080 --> 02:31:31.080
you're not  comfortable with 
code 

02:31:32.973 --> 02:31:34.805
and you came to see the Grateful
Dead, you're in the wrong place 

02:31:34.806 --> 02:31:36.660
and also about 20 years late.
     To make sure we have the 

02:31:36.661 --> 02:31:40.135
right people in the  audience, 
how many of you are developing 

02:31:40.136 --> 02:31:43.620
for Android right now?  Not now,
now, but at home and at work?  

02:31:43.621 --> 02:31:45.621
Most of you, not everyone.  
That's cool, like there are some

02:31:48.835 --> 02:31:50.093
Android curious folks here, some
Dead Heads in the wrong place 

02:31:50.094 --> 02:31:53.351
and time.  Some folks on the 
bank working on their tan, and 

02:31:53.352 --> 02:31:55.999
that's cool, too.  Everyone is 
welcome.  Thank you for coming.

02:31:56.219 --> 02:31:59.512
     Now, this is actually a 
pretty special year for Android.

02:32:02.778 --> 02:32:04.225
This marks the 10-year 
anniversary of Android 

02:32:04.226 --> 02:32:05.674
development, which is super 
exciting.  Obviously not 

02:32:05.675 --> 02:32:07.675
everyone has been 

02:32:08.940 --> 02:32:10.367
developing an Android quite that
long.  How many of you have been

02:32:10.368 --> 02:32:12.799
developing for more than two 
years?  Yeah?  Wow.  Five years?

02:32:13.842 --> 02:32:17.387
A few hands down.  What about 10
years?  Do we have any 10-year 

02:32:17.388 --> 02:32:22.767
veterans?  A few.  Nice!  
Congratulations!  Yeah, a round 

02:32:22.768 --> 02:32:24.768
of applause for the 10 years.
     (Applause).

02:32:27.074 --> 02:32:28.506
I too have that honor, that 
privilege of having been 

02:32:28.507 --> 02:32:33.380
developing for Android for 10 
years, I even brought receipts. 

02:32:33.381 --> 02:32:35.381
This is my very first question 
on 

02:32:37.711 --> 02:32:39.711
stack  overflow, asking about 
the maps API for the .

02:32:44.147 --> 02:32:45.785
9 beat-it SDK so the 10-year 
veterans will remember and 

02:32:45.786 --> 02:32:48.254
hopefully not remember, this is 
not my first Googler, 

02:32:51.560 --> 02:32:53.794
and not my first  Protip 
section.  This will be the last 

02:32:53.795 --> 02:32:57.059
question I ask for a little 
while.  How many have been to a 

02:32:57.060 --> 02:33:02.192
previous I/O and seen one of my 
previous Protips sections.  A 

02:33:02.193 --> 02:33:05.052
descent  handful.  All right.  
And you still came to this!

02:33:06.475 --> 02:33:08.103
(laughter).
     That's reassuring, so thank

02:33:08.104 --> 02:33:12.783
you for that.  I actually spend 
a fair bit of time over the last

02:33:12.784 --> 02:33:14.825
couple of months looking back 
over these session, and at first

02:33:14.826 --> 02:33:18.125
it was because I wanted to gain 
some inspiration, you know, like

02:33:18.126 --> 02:33:21.453
what are the cool things we used
to talk about, gain some of the 

02:33:21.454 --> 02:33:23.454
excitement from the early days 
of Android.

02:33:26.156 --> 02:33:27.785
But I quickly realized that not 
everything that I had said in 

02:33:27.786 --> 02:33:29.786
those 

02:33:33.691 --> 02:33:35.691
early days has held up all that 
well.

02:33:36.962 --> 02:33:38.411
So as a result, what I'm 
actually going to be presenting 

02:33:38.412 --> 02:33:41.896
this year is looking at all the 
things that we've said in 

02:33:41.897 --> 02:33:45.356
previous years and giving it a 
bit of an update.  So the real, 

02:33:45.357 --> 02:33:47.357
real title slide for 

02:33:50.286 --> 02:33:52.286
today's session is actually, 
Android Protips Fixed.

02:33:53.356 --> 02:33:57.480
(laughter).
     I'm sorry.  So the goal 

02:33:57.481 --> 02:34:00.729
here is to provide you with all 
the tip, tricks, best practices,

02:34:00.730 --> 02:34:02.581
and good advice that's going to 
help us develop great apps for 

02:34:02.582 --> 02:34:07.140
the next decade of Android 
development, and in order to do 

02:34:07.141 --> 02:34:11.246
that effectively, I want to you 
take the same journey as me.  So

02:34:11.247 --> 02:34:14.917
we're going to start by going 
back in time.  We're going to go

02:34:14.918 --> 02:34:16.918
back through 

02:34:20.103 --> 02:34:21.734
previous Google I/Os, previous 
Protips sessions, all the way 

02:34:21.735 --> 02:34:23.735
back to the very, very 
beginning.

02:34:26.211 --> 02:34:28.734
(laughter).
     We may have gone too far 

02:34:28.735 --> 02:34:30.735
back.

02:34:34.119 --> 02:34:36.153
This is me in kindergarten, a 
happy child.  I don't know what 

02:34:36.154 --> 02:34:38.154
a fragment is and I've never 
heard of a content provider.

02:34:39.001 --> 02:34:41.251
(laughter).
     That will change.  Also, a 

02:34:41.252 --> 02:34:43.252
side note.

02:34:45.135 --> 02:34:47.160
I didn't know I was presenting 
in the amphtheater and there 

02:34:47.161 --> 02:34:50.659
would be a  400-foot screen, and
if I had known that I may have  

02:34:50.660 --> 02:34:52.692
included fewer pictures of 
myself.  Take note if you're 

02:34:52.693 --> 02:34:55.803
ever in this situation.
     Clearly we're too far back 

02:34:55.804 --> 02:34:59.945
so let's just pump it a few 
years forward, I think I can do 

02:34:59.946 --> 02:35:03.819
that with one of these button, 
let's have a look.  Yes.  Yeah. 

02:35:03.820 --> 02:35:07.560
This is more like it.  Don't I 
look young?  This is 2008 and I 

02:35:07.561 --> 02:35:10.836
remember this because this is 
actually the cover photo for my 

02:35:10.837 --> 02:35:12.677
first Android book and we took 
this photo just after I had 

02:35:12.678 --> 02:35:14.707
gotten the first round of editor
notes back from 

02:35:18.193 --> 02:35:22.563
the first draft, and the next 
day Android release the the 1.0 

02:35:22.564 --> 02:35:26.226
SDK and up until then I was 
writing based on the .9 beta.  I

02:35:26.227 --> 02:35:27.658
knew it was coming, the clue is 
in the name, but I figured how 

02:35:27.659 --> 02:35:35.109
much is going to change.  1.0 
from .9.  .8 to .9 was minor, so

02:35:35.110 --> 02:35:38.170
it should just be a couple 
little things.  Turns out a lot 

02:35:38.171 --> 02:35:42.856
can change.  Like really a lot.
     (laughter).

02:35:44.525 --> 02:35:46.525
I had actually written an entire

02:35:49.556 --> 02:35:52.711
chapter on the GTalk data API.  
It was pretty cool but didn't 

02:35:52.712 --> 02:35:55.799
exist in the 1.0 SDK.  30 pages 
of hard work.  I didn't remove 

02:35:55.800 --> 02:36:00.896
it.  I ended up leaving it in 
the book because by the time it 

02:36:00.897 --> 02:36:06.481
came out, who knows, right.  
Android moves quickly.  It's 

02:36:06.482 --> 02:36:08.529
been 10 years.  It never got put
back in and 

02:36:11.795 --> 02:36:12.192
eventually I removed it it from 
future revisions of the book.

02:36:12.193 --> 02:36:15.251
     The reason I mention this 
is because I spent most of the 

02:36:15.252 --> 02:36:19.164
past 10 years going around 
talking about Android, giving 

02:36:19.165 --> 02:36:21.399
advice on the best way of doing 
things, the latest and greatest 

02:36:23.307 --> 02:36:25.307
APIs that you can take advantage
of to build great apps.

02:36:26.763 --> 02:36:28.763
And I do this with the knowledge

02:36:30.017 --> 02:36:32.297
that sometimes within months and
even weeks, and these things are

02:36:32.298 --> 02:36:35.612
going to change.  They're going 
to be replaced with something 

02:36:35.613 --> 02:36:37.645
more efficient, more 
comprehensive, and in fact weeks

02:36:37.646 --> 02:36:42.180
and months is a best case 
scenario.  I remember one 

02:36:42.181 --> 02:36:44.181
particular incident.  I had just
finished a keynote.

02:36:50.426 --> 02:36:52.680
Very exciting, a developer day 
in Prauge I think it was, what's

02:36:52.681 --> 02:36:56.988
new in  cupcake.  I've been 
doing this for a while.  I 

02:36:56.989 --> 02:36:59.626
stepped off stage and as my foot
hit the ground we released 

02:36:59.627 --> 02:37:03.785
doughnut, and in that instance I
had 3 nanoseconds of being 

02:37:03.786 --> 02:37:05.786
current before everything I said
was effectively outdated.

02:37:07.317 --> 02:37:09.374
Now despite how all of that may 
sound, this is actually a really

02:37:09.375 --> 02:37:13.066
good thing.  Well for you and 
not so much for me.  For you 

02:37:13.067 --> 02:37:15.374
it's a good thing.  It 
demonstrates how quickly Android

02:37:15.375 --> 02:37:17.375
is 

02:37:18.650 --> 02:37:20.650
evolving to take advantage or to
give 

02:37:22.134 --> 02:37:23.573
users and developers the things 
they need to be able to be 

02:37:23.574 --> 02:37:26.269
successful.
     There has always been a 

02:37:26.270 --> 02:37:30.192
tradeoff and I know you all have
felt this pain.  New platform 

02:37:30.193 --> 02:37:32.193
comes out, also new API, great 
new functionality to take 

02:37:32.838 --> 02:37:35.076
advantage of, but you know it's 
going to take a while before 

02:37:35.077 --> 02:37:37.077
lots of users are on 

02:37:38.595 --> 02:37:40.022
that platform, and at the same 
time you know all the platforms 

02:37:40.023 --> 02:37:43.487
are going to take a few years 
before they go away, so you have

02:37:43.488 --> 02:37:45.578
to do this tradeoff.  Is it 
worth putting in the time and 

02:37:47.406 --> 02:37:49.631
effort to take advantage of the 
new API, the new functionality, 

02:37:49.632 --> 02:37:53.939
knowing that it's going to have 
to be backwards compatible and 

02:37:53.940 --> 02:37:55.362
you'll have to maintain that 
code, potentially for years, so 

02:37:55.363 --> 02:37:57.363
when do you do that?

02:38:03.346 --> 02:38:06.038
Well, the thing is, what makes 
us really excited is now we have

02:38:06.039 --> 02:38:08.275
Jetpack which incorporates all 
of the Android  

02:38:11.557 --> 02:38:13.204
Support Library, Android 
Architecture components and if 

02:38:13.205 --> 02:38:15.652
you take Jetpack and combine 
with Google Play Services we end

02:38:18.111 --> 02:38:20.561
up with a increasing surface 
area of APIs which don't rely on

02:38:20.562 --> 02:38:22.562
having the latest platform 
version, so you can take 

02:38:23.020 --> 02:38:24.452
advantage of the new 
functionality that's available 

02:38:24.453 --> 02:38:26.453
and we'll take care of writing 
all of the boilerplate code to 

02:38:28.532 --> 02:38:30.419
make it backwards compatible for
you.

02:38:30.420 --> 02:38:32.721
Right, so this is a nice 
advantage, right.  Suddenly that

02:38:32.722 --> 02:38:34.722
tradeoff isn't quite as 
expensive.

02:38:36.401 --> 02:38:38.434
Now, it's still one of the big 
pluses of this as well is we're 

02:38:38.435 --> 02:38:41.713
no longer tied to the framework,
right.  So we can continue to 

02:38:41.714 --> 02:38:43.714
launch new 

02:38:46.429 --> 02:38:48.429
features, fix bug, encapsulate 
more best 

02:38:50.565 --> 02:38:52.412
practices, take care of 
education and do all of this 

02:38:52.413 --> 02:38:55.512
between releases.  It's great 
for developers, not so great for

02:38:55.513 --> 02:38:57.751
those of us trying to talk about
it, things change more rapidly.

02:38:57.752 --> 02:39:00.433
     There is a price, if you 
want to take advantage of this 

02:39:00.434 --> 02:39:03.268
cool new stuff, you have to 
reconsider some of the 

02:39:05.523 --> 02:39:07.389
fundamental architectural 
changes in how we build our app,

02:39:07.390 --> 02:39:09.390
so I'm going to talk today a 
little bit about why I think is 

02:39:10.307 --> 02:39:12.962
the right time to do that.
     If we bring it down to the 

02:39:12.963 --> 02:39:15.013
real fundamentals, what we're 
trying to do is 

02:39:20.816 --> 02:39:22.816
keep our app looking fresh,  
lightweight, full of potential.

02:39:26.136 --> 02:39:28.136
If not, we quickly risk becoming

02:39:30.669 --> 02:39:32.504
visibly older, outdated, a 
little bloated maybe, harder to 

02:39:32.505 --> 02:39:34.505
maintain, 

02:39:36.032 --> 02:39:37.654
harder to manage, and there is 
an analogy for high cholesterol 

02:39:37.655 --> 02:39:41.954
but I couldn't figure it out.  
You get the idea, right.

02:39:43.995 --> 02:39:46.476
So before we sort of dive into 
some of the tips, which we do 

02:39:46.477 --> 02:39:51.009
need to update.  I did want to 
spend just a little bit of time 

02:39:51.010 --> 02:39:53.097
highlighting a handful of 
protips which have stood the 

02:39:53.098 --> 02:39:55.098
test of 

02:39:56.425 --> 02:39:58.469
time, that like a fine wine or 
sharp cheddar, actually age 

02:39:58.470 --> 02:40:02.577
pretty well.
     There is probably more than

02:40:02.578 --> 02:40:06.550
just the ones on this list, but 
this is the highlight, and what 

02:40:06.551 --> 02:40:08.551
you'll notice about 

02:40:09.807 --> 02:40:10.629
these particular protips is 
they're not really specific to 

02:40:10.630 --> 02:40:12.880
Android.  They're not even 
really specific to mobile 

02:40:12.881 --> 02:40:17.977
development.  This is just good 
best practice that you should 

02:40:17.978 --> 02:40:19.421
always be keeping in mind when 
building any engineering app.

02:40:22.560 --> 02:40:23.984
So let's not dwell too much on 
the things that we know are 

02:40:23.985 --> 02:40:27.077
still good ideas.  Let's take a 
look at some of the things which

02:40:27.078 --> 02:40:29.976
have changed, which have perhaps
not aged quite as well.

02:40:31.819 --> 02:40:33.819
Now, everything on this list you

02:40:35.076 --> 02:40:36.906
can pretty much still do, but 
it's all been replaced with 

02:40:36.907 --> 02:40:38.907
newer APIs that are more 
efficient, that encapsulate a 

02:40:41.316 --> 02:40:43.316
bigger amount of functionality.

02:40:44.618 --> 02:40:47.497
Sometimes the underlying 
hardware is  changed or the UI 

02:40:47.498 --> 02:40:49.498
paradigm has changed, but a lot 
of it you can still do.

02:40:50.797 --> 02:40:52.700
That's actually kind of a theme 
for a lot of the things that 

02:40:52.701 --> 02:40:55.611
we're going to be looking at.  
There has always been ways of 

02:40:57.460 --> 02:40:59.359
achieving certain things, but 
there is now significantly 

02:40:59.360 --> 02:41:01.360
better way, simpler 

02:41:02.650 --> 02:41:05.324
ways which involve less work, 
less hackie workarounds and 

02:41:05.325 --> 02:41:08.438
making it more  predictable and 
easier for you to manage and 

02:41:08.439 --> 02:41:10.284
maintain your code bases going 
forward.

02:41:10.285 --> 02:41:12.560
So we know things have changed. 
I've said that a few times, but 

02:41:12.561 --> 02:41:15.007
there are certain things we've 
always been able to rely on, 

02:41:15.008 --> 02:41:17.491
right.  You write your Android 
code in Java 

02:41:20.579 --> 02:41:22.669
language syntax, and all of the 
application components are 

02:41:22.670 --> 02:41:24.670
basically the same.

02:41:26.626 --> 02:41:28.062
We use the same core components,
they interact the same way, they

02:41:28.063 --> 02:41:31.729
achieve the same end results.  
That's something we've been able

02:41:31.730 --> 02:41:34.594
to rely on until, basically, 
until now.

02:41:39.137 --> 02:41:42.212
Last year or so, things have 
fundamentally changed.  Android 

02:41:42.213 --> 02:41:44.213
Studio 3 introduced Column as a 
first-class language for Android

02:41:45.106 --> 02:41:46.733
development and that's actually 
what we're encouraging people to

02:41:46.734 --> 02:41:48.974
use as their primary developing 
language for Android.

02:41:51.425 --> 02:41:53.011
We saw the introduction of 
Android Architecture components 

02:41:53.012 --> 02:41:57.129
which introduced view models, 
live data and the room database 

02:41:57.130 --> 02:41:59.584
to significantly simplify the 
way we manage data and have it 

02:41:59.585 --> 02:42:01.871
interact properly with the 
activity  lifecycle.

02:42:05.552 --> 02:42:06.987
We also have the job scheduling,
which almost entirely eliminates

02:42:06.988 --> 02:42:13.967
the need to create your own 
custom background services.  And

02:42:13.968 --> 02:42:15.678
the intent receive is that we 
sometimes set up to monitor 

02:42:15.679 --> 02:42:17.906
device state to control when our
services are run, 

02:42:21.371 --> 02:42:23.371
which is a good thing, because 
in 

02:42:24.793 --> 02:42:29.147
Android we depricated to have 
long-running services when your 

02:42:29.148 --> 02:42:32.465
app is in the background as 
well.  And most of the intent 

02:42:32.466 --> 02:42:34.466
used to monitor 

02:42:37.395 --> 02:42:39.395
device state have also largely 
been depricated.

02:42:43.578 --> 02:42:44.837
Job scheduler, already 
depracated as of yesterday 

02:42:44.838 --> 02:42:46.260
morning, so now we have work 
manager, which is nice because 

02:42:46.261 --> 02:42:48.261
it 

02:42:50.037 --> 02:42:52.702
does the same stuff as job 
scheduler but backwards 

02:42:52.703 --> 02:42:53.957
compatible, right, so you're 
starting to see some of the 

02:42:53.958 --> 02:42:55.958
trends of what we're trying to 
achieve here.

02:42:56.800 --> 02:42:59.480
We should dig into some of this 
stuff in a little more detail.  

02:42:59.481 --> 02:43:01.481
Something of which I've talked 
about 

02:43:02.551 --> 02:43:03.989
at most of the protip session, 
the first thing I talked about 

02:43:03.990 --> 02:43:06.675
and it comes up every year.  I 
like to focus on what's 

02:43:06.676 --> 02:43:11.389
happening in the background.
     (laughter).

02:43:13.627 --> 02:43:15.627
Sometimes it's easy to miss 
until you really focus on it.

02:43:20.382 --> 02:43:22.005
So the first protip I gave back 
in 2010, the first session, the 

02:43:22.006 --> 02:43:25.155
first Android session, the first
real session on a big stage.  It

02:43:25.156 --> 02:43:28.212
was very exciting.  And this is 
the first protip so I thought 

02:43:28.213 --> 02:43:30.213
let's have a look at what I said
and see how well it holds up.

02:43:33.302 --> 02:43:34.945
This is the first thing I ever 
advised.

02:43:34.946 --> 02:43:36.744
&gt;&gt; So it's important that you 
move anything which can in any 

02:43:36.745 --> 02:43:38.745
way take 

02:43:40.042 --> 02:43:42.919
longer than just a fraction of a
second and interrupt the UI flow

02:43:42.920 --> 02:43:45.840
and move it into the backend.  
The most simple and 

02:43:45.841 --> 02:43:47.841
straightforward is 

02:43:48.911 --> 02:43:51.172
to use Java threading.
     What we've created in 

02:43:51.173 --> 02:43:53.173
Android is a 

02:43:55.678 --> 02:43:57.313
class called  asynctask.
     (Applause).

02:43:57.314 --> 02:44:01.611
     &gt;&gt; RETO MEIER:  You know 
what they say, the giant screen 

02:44:01.612 --> 02:44:04.725
actually removes 20 pounds.
     (laughter).

02:44:06.777 --> 02:44:09.231
So it's kind of true, right.  
Like kind of, like we don't want

02:44:09.232 --> 02:44:12.723
to block the UI thread but the 
context around what I was 

02:44:12.724 --> 02:44:16.847
talking about is trying to 
eliminate these application not 

02:44:16.848 --> 02:44:18.474
responding dialogues which have 
evolved over the years, they 

02:44:18.475 --> 02:44:21.528
look a little bit different now.
They used to be very common 

02:44:21.529 --> 02:44:23.529
because it 

02:44:24.659 --> 02:44:26.283
was easy to block the foreground
thread.  Right, if you tried to 

02:44:26.284 --> 02:44:30.418
do a data transfer, for example,
it would block and that would be

02:44:30.419 --> 02:44:33.686
a bad experience and so with the
Android 3.0 we introduced a 

02:44:33.687 --> 02:44:35.687
runtime exception so if you 
tried to access the Internet 

02:44:37.767 --> 02:44:40.205
through our runtime exception 
the app would crash.  Strong 

02:44:40.206 --> 02:44:42.258
encouragement for developers not
to do that.  More recently we've

02:44:42.259 --> 02:44:44.913
done similar things with file 
system access and with database 

02:44:44.914 --> 02:44:47.173
access as well.
     Now in Android P this is no

02:44:47.174 --> 02:44:49.174
longer 

02:44:50.657 --> 02:44:53.328
a problem because we don't show 
dialogue, we just crash the app,

02:44:53.329 --> 02:44:56.802
so that's not a better outcome 
for your users, but it's a much 

02:44:56.803 --> 02:44:58.853
stronger signal to us as 
developers that we need to make 

02:45:00.287 --> 02:45:02.287
sure that we're taking care of 
this particular problem.

02:45:03.357 --> 02:45:05.357
Now, I did mention one solution 
and 

02:45:08.471 --> 02:45:10.471
it got some love, the old 
asynctask.

02:45:11.774 --> 02:45:14.434
It's a reasonable solution to 
the  stated problem.  We need to

02:45:14.435 --> 02:45:17.062
move everything back off the 
foreground on to a background 

02:45:17.063 --> 02:45:19.162
thread and that's what  
asynctask does.

02:45:22.631 --> 02:45:25.094
It creates a background threat 
and has handles marshal back to 

02:45:25.095 --> 02:45:28.017
the UI thread so you can update 
when you have progress or final 

02:45:28.018 --> 02:45:29.443
result to display.
     I would like to tell you 

02:45:29.444 --> 02:45:31.475
that the only thing missing from
that is that now 

02:45:36.361 --> 02:45:38.361
you have to write it in

02:45:40.322 --> 02:45:42.562
kartlin, it's better, it looks 
nicer, it's more concise, but 

02:45:42.563 --> 02:45:44.563
you still have the same 
fundamental problems where if 

02:45:49.070 --> 02:45:51.542
you're doing this stuff in an 
activity, if the user rotates 

02:45:51.543 --> 02:45:53.543
the phone, your 

02:45:55.215 --> 02:45:57.215
thread is killed, your 
asynctask, you 

02:45:59.731 --> 02:46:00.746
may leak  context, try to update
a UI element that doesn't exist,

02:46:00.747 --> 02:46:02.747
in the 

02:46:04.849 --> 02:46:06.849
process of getting killed and 
back, it's problematic.

02:46:07.092 --> 02:46:08.328
Back in the first I/O session I 
had a solution for this, it was 

02:46:08.329 --> 02:46:10.329
a great solution.

02:46:11.682 --> 02:46:13.682
The advice was you should move 
it to a 

02:46:16.210 --> 02:46:18.210
service, which it's fair to say 
this 

02:46:22.242 --> 02:46:24.072
advice has not aged aged 
spectacularly well.  It's the 

02:46:24.073 --> 02:46:26.550
same principle, you have 
something long running.  You're 

02:46:26.551 --> 02:46:28.988
in the activity, you use an 
intend to start a service, 

02:46:28.989 --> 02:46:32.051
probably an intent service and 
that goes and does the time 

02:46:32.052 --> 02:46:33.672
consuming work, maybe it's 
pulling something down from a 

02:46:33.673 --> 02:46:36.737
server or interacting with a 
database or performing some 

02:46:36.738 --> 02:46:38.738
complex calculation, and 

02:46:39.787 --> 02:46:41.846
when it's finished it sends 
intent back to the activity and 

02:46:41.847 --> 02:46:45.320
it then updates the UI 
accordingly.  Basic stuff, and 

02:46:45.321 --> 02:46:47.321
it's a reasonable approach, but 
it does introduce some new 

02:46:47.567 --> 02:46:50.896
challenges.
     Services are heavy-weight 

02:46:51.494 --> 02:46:55.185
components, right.  We don't 
really want to create, then we 

02:46:55.186 --> 02:46:57.053
want to kill them as quickly as 
possible to gain back some of 

02:46:57.054 --> 02:47:00.527
the system resources, and they 
keep running even when your 

02:47:00.528 --> 02:47:02.570
activity isn't, which is kind of
the point but now you have to 

02:47:02.571 --> 02:47:04.571
keep in 

02:47:05.668 --> 02:47:07.668
mind your activity lifecycle, 
what's it 

02:47:09.583 --> 02:47:11.443
doing, have you actually exited 
the app, have you transitioned 

02:47:11.444 --> 02:47:14.128
to a new activity, should the 
service keep running, should it 

02:47:14.129 --> 02:47:17.626
be canceled?  All of this stuff 
you have to keep in mind and 

02:47:17.627 --> 02:47:19.627
it's doable but a lot of work to
get right.

02:47:21.089 --> 02:47:23.089
Of course, because services are 

02:47:24.361 --> 02:47:26.361
part of the high priority it 
prevents 

02:47:27.633 --> 02:47:29.855
the system from killing your app
if it needs to and there is no 

02:47:29.856 --> 02:47:32.927
guarantee the app will keep 
running if the app is force 

02:47:32.928 --> 02:47:34.759
quit.
     So there is another problem

02:47:34.760 --> 02:47:37.215
in Android 0 you can't guarantee
your background services will be

02:47:37.216 --> 02:47:40.904
running when you want them to.  
You can't start a background 

02:47:40.905 --> 02:47:45.686
service when your app is in the 
background from a broadcast 

02:47:45.687 --> 02:47:48.541
receiver and they'll be killed 
after a few minutes after 

02:47:48.542 --> 02:47:50.402
they're initiated while the 
activity was in the foreground.

02:47:50.403 --> 02:47:54.061
     Now, for really time 
consuming things, which you need

02:47:54.062 --> 02:47:58.129
to have run, this is still a 
reasonable approach.  You have 

02:47:58.130 --> 02:48:00.992
an activity, it uses a service 
to then download data from a 

02:48:04.045 --> 02:48:05.678
server, say, it's a nice time 
consuming operation, and then 

02:48:05.679 --> 02:48:09.185
that saves it to a database and 
then your activity just monitors

02:48:09.186 --> 02:48:11.635
the database, so it's kind of a 
one-way flow, which is nice.  

02:48:11.636 --> 02:48:16.560
There is a catch.  There is 
always a catch.  And the catch 

02:48:16.561 --> 02:48:18.561
is that this is not an 

02:48:19.600 --> 02:48:21.600
efficient way to use the cell 
radio, and 

02:48:23.209 --> 02:48:25.209
back in 20

02:48:27.768 --> 02:48:30.216
2012, and I'm not going to go 
into detail of how it work, when

02:48:30.217 --> 02:48:34.904
you transition it stands in 
standby andry do you says more 

02:48:34.905 --> 02:48:37.149
power and the goal is it reduces
latency for future transfers, 

02:48:38.577 --> 02:48:39.831
and that's all great, and the 
reason it's important for us to 

02:48:39.832 --> 02:48:43.510
know, is if you're doing lots of
transfers you can keep the radio

02:48:43.511 --> 02:48:45.511
turned on, it's going to draw 
power more quickly.

02:48:45.956 --> 02:48:47.956
So we have some specific advice 
for 

02:48:49.224 --> 02:48:51.468
this, which was you should deal 
with that.  You know how it 

02:48:51.469 --> 02:48:53.469
works now.

02:48:54.964 --> 02:48:57.420
Efficiency is important so fix 
it.  I had this whole metaphor 

02:48:57.421 --> 02:49:01.984
to help.  It was about cookie, I
have a friend who is an artist, 

02:49:01.985 --> 02:49:03.985
it was a excuse to get him to 
draw things, and the idea here 

02:49:05.640 --> 02:49:07.289
was to use the big cookie model 
where you're minimizing the 

02:49:07.290 --> 02:49:10.958
total number of transfers that 
you're using across the app 

02:49:10.959 --> 02:49:12.796
lifecycle, so if you have 
something that's not time 

02:49:12.797 --> 02:49:14.797
sensitive like 

02:49:15.799 --> 02:49:20.962
analytics, you Youku that up and
wait, and when there is an user 

02:49:20.963 --> 02:49:25.647
initiated refresh, you send the 
queue and looking into the 

02:49:25.648 --> 02:49:28.498
future is there anything 
scheduled to happen in a few 

02:49:28.499 --> 02:49:30.536
minutes and let's just do that 
first, so it was a way to 

02:49:30.537 --> 02:49:34.202
manually batch and bundle all of
the transfers so they happen at 

02:49:34.203 --> 02:49:36.253
the same time and you get some 
increased efficiency.

02:49:41.042 --> 02:49:42.259
Now, as I'm sure you can 
believe, doing all of this and 

02:49:42.260 --> 02:49:44.260
understanding how to do it right
was complicated in you 

02:49:47.401 --> 02:49:49.401
have that a room full of 
engineers, much 

02:49:52.079 --> 02:49:53.777
like yourselves, back at 
musconi, believe this is was a 

02:49:53.778 --> 02:49:57.086
legitimate equation you needed 
to solve in order to figure out 

02:49:57.087 --> 02:49:59.124
how to do this right.  It's not.
This is just made up.

02:50:01.971 --> 02:50:03.994
By 2012 we had a solution, a 
solution which was the sync 

02:50:03.995 --> 02:50:05.995
adapter and the sync adapter we 
claimed was pretty 

02:50:07.503 --> 02:50:09.503
straightforward.

02:50:11.396 --> 02:50:13.826
Which is fair to say was a lie.
     (laughter).

02:50:15.488 --> 02:50:19.392
Now, it's still better than 
doing it all yourself.  Once you

02:50:19.393 --> 02:50:22.453
set it up, it's not that 
complicated, right.  You're able

02:50:22.454 --> 02:50:24.454
to trigger a one off for a 

02:50:25.562 --> 02:50:27.224
periodic transfer and a 
syncadapter will handle all of 

02:50:27.225 --> 02:50:29.225
the background work, doing the 
batching and time shifting for 

02:50:30.913 --> 02:50:32.541
multiple of your requests that 
happen within a sort of time 

02:50:32.542 --> 02:50:34.542
window, so you don't have to 
think about when you 

02:50:37.663 --> 02:50:39.109
trigger it, you just do and 
trust the syncadapter to handle 

02:50:39.110 --> 02:50:40.728
the timing for you.
     Unfortunately, to make this

02:50:40.729 --> 02:50:42.729
all 

02:50:44.203 --> 02:50:47.852
work, you needed to have a 
syncadapter, fair enough.  

02:50:47.853 --> 02:50:50.543
Syncadapter runs within its own 
service.  Of course, you also 

02:50:50.544 --> 02:50:52.544
need to have an account manager,
which isn't used but 

02:50:55.846 --> 02:50:57.688
it's part of the API, and the 
account authenticator also needs

02:50:57.689 --> 02:51:01.027
its own service to run in.  
Okay, I'm seeing a trend.  You 

02:51:01.028 --> 02:51:03.063
also need to have a content 
provider, again, doesn't need to

02:51:03.064 --> 02:51:05.064
be used but needs to exist.

02:51:07.394 --> 02:51:09.394
You do all of this, write it all
in a 

02:51:12.722 --> 02:51:15.384
Java, and then maybe a dozen XMH
files you need to right and then

02:51:15.385 --> 02:51:18.872
you're good to go, the 
syncadapter works.  It's fair to

02:51:18.873 --> 02:51:20.873
say that a lot of people trying 
to make this work found it to be

02:51:25.223 --> 02:51:28.082
kind of frustrating, and of 
course it only batched and 

02:51:28.083 --> 02:51:30.083
bundled your transfers 

02:51:31.766 --> 02:51:33.766
within your own app, which is 
why  2013, 

02:51:35.426 --> 02:51:38.065
great year Android 5 we 
introduced the job scheduler API

02:51:38.066 --> 02:51:40.324
which has now been replaced.  
Job scheduler works at the 

02:51:40.325 --> 02:51:43.541
platform level and does the 
batching and bundling for all of

02:51:43.542 --> 02:51:45.706
the apps at the same time to be 
able to take advantage, not just

02:51:45.707 --> 02:51:47.707
of 

02:51:49.159 --> 02:51:51.410
cell radio battery improvement, 
but all of the resource 

02:51:51.411 --> 02:51:53.411
improvements that we're 

02:51:55.291 --> 02:51:56.316
trying to do, things like 
standby and dose mode and all of

02:51:56.317 --> 02:52:00.441
this.
     So within your app you 

02:52:00.442 --> 02:52:05.187
create a new job service that 
does the asynchronous background

02:52:05.188 --> 02:52:07.188
updates, in this case we're 

02:52:08.659 --> 02:52:10.301
using the asynctask which we can
use now because we don't have 

02:52:10.302 --> 02:52:13.577
the same memory leak problem, 
and then within your specific 

02:52:13.578 --> 02:52:15.681
activity you just define the 
criteria you need in order for 

02:52:15.682 --> 02:52:19.397
that job to be successfully 
executed.  If it needs to be on 

02:52:19.398 --> 02:52:22.872
the Internet, it needs to be 
charging, et cetera, how urgent,

02:52:22.873 --> 02:52:24.952
what is the preferred timing, is
it periodic, all of that sort of

02:52:24.953 --> 02:52:28.678
stuff.  The job scheduler will 
then handle all of the 

02:52:28.679 --> 02:52:30.679
background work for you in the 
most efficient way possible.

02:52:31.954 --> 02:52:34.004
The only thing which would be 
better than the job scheduler is

02:52:34.005 --> 02:52:36.005
if it 

02:52:37.109 --> 02:52:39.109
worked in a backwards compatible
way, 

02:52:41.380 --> 02:52:43.380
which is way we launched Work 
Manager, part of Jetpack.

02:52:45.046 --> 02:52:47.308
To use Work Manager it works 
basically the same way.  You 

02:52:47.309 --> 02:52:48.524
create a new worker and that is 
where you're defining the 

02:52:48.525 --> 02:52:51.830
background work that needs to be
done, and then within your 

02:52:51.831 --> 02:52:54.267
activity you do the same thing 
and you specify the constraints 

02:52:55.908 --> 02:52:57.738
that need to be met before this 
work can be accomplished, and 

02:52:57.739 --> 02:52:59.782
then work manager will handle 
all of this for you in the 

02:53:02.016 --> 02:53:04.016
background, same as job 
scheduler, but 

02:53:05.317 --> 02:53:07.768
it now also encapsulates the 
best practice solution for  

02:53:07.769 --> 02:53:11.032
earlier platform releases.  I 
think it goes back to 4.4, so it

02:53:11.033 --> 02:53:13.033
will use the latest and greatest
job scheduler if you're running 

02:53:15.158 --> 02:53:17.602
on the latest platform, all the 
way back to probably alarm 

02:53:17.603 --> 02:53:20.438
manager for some of the earlier 
platform releases.  Again, you 

02:53:20.439 --> 02:53:22.883
don't need to write any of that 
boilerplate code for backwards 

02:53:23.488 --> 02:53:27.362
compatibility.  We do all of 
that for you, so you don't have 

02:53:27.363 --> 02:53:29.432
to maintain it, find the bugs, 
find the education, you can rely

02:53:30.854 --> 02:53:31.898
on work manager to take care of 
that, and of course this is 

02:53:31.899 --> 02:53:34.620
going to continue to improve in 
future releases so as job 

02:53:36.036 --> 02:53:37.268
scheduler continues to improve 
on the platform, work manager is

02:53:37.269 --> 02:53:39.509
going to be able to evolve to 
take advantage of some of those 

02:53:39.510 --> 02:53:42.993
changes.
     You can learn all about 

02:53:42.994 --> 02:53:44.994
Work 

02:53:46.469 --> 02:53:48.469
Manager in Stage 2 today at 
5:30.  I recommend going along.

02:53:50.980 --> 02:53:52.980
It's really a cool new API.

02:53:54.253 --> 02:53:56.081
So Work Manager, it's great if 
it's something which is 

02:53:56.082 --> 02:53:58.129
genuinely time consuming and 
needs to be initiated on the 

02:53:58.130 --> 02:54:02.018
client side.  Now, one of the 
things which we've always said 

02:54:02.019 --> 02:54:04.019
and which really hasn't changed 
is that wherever possible, you 

02:54:05.506 --> 02:54:07.506
should eliminate periodic 
refreshes and 

02:54:08.792 --> 02:54:10.432
any updates that need to happen 
based on changes of the service 

02:54:10.433 --> 02:54:12.433
side should be initiated by the 
server, preferably 

02:54:17.372 --> 02:54:19.372
using Google Cloud Messaging, by
which 

02:54:20.858 --> 02:54:23.295
of course I mean Firebase 
because GCM was depricated in 

02:54:23.296 --> 02:54:27.028
April.  Things move quickly.
     Firebase Cloud Messaging 

02:54:27.029 --> 02:54:30.319
takes advantage of the same 
scalable reliable GCM 

02:54:30.320 --> 02:54:32.553
infrastructure that we've been 
using in the past, but also 

02:54:32.554 --> 02:54:37.099
improves delivery reporting and 
reliability.  It also adds a web

02:54:37.100 --> 02:54:39.546
console so you can send 
notifications to your apps 

02:54:39.547 --> 02:54:41.547
without 

02:54:43.023 --> 02:54:45.023
having to have your own server 
instance.

02:54:48.142 --> 02:54:49.433
Now, the transfer this gives us 
a pretty good solution, but 

02:54:49.434 --> 02:54:52.283
there is really no way this is a
viable solution for being able 

02:54:52.284 --> 02:54:54.337
to maintain a small amount of 
data whenever the phone 

02:54:59.640 --> 02:55:01.897
rotates, and for that matter, 
using  singlton ar overwriting 

02:55:01.898 --> 02:55:07.218
the application class, which I 
may or may not said in previous 

02:55:07.219 --> 02:55:09.219
years, is similarly considered 
somewhat distasteful.

02:55:12.311 --> 02:55:14.311
So which is why in Android 3.

02:55:18.037 --> 02:55:19.661
0, we introduced  headless 
fragments and loaders.  I assume

02:55:19.662 --> 02:55:21.662
everyone is familiar with these.

02:55:24.570 --> 02:55:27.425
Fragments were designed to break
your UI up into chunks that were

02:55:27.426 --> 02:55:31.734
independent, reusable, and 
interchangeable.  The key here 

02:55:31.735 --> 02:55:34.224
was they were also aware of the 
parent activity lifecycle.

02:55:37.093 --> 02:55:38.729
Now, the trick with headless 
fragments was that they didn't 

02:55:38.730 --> 02:55:40.730
have a UI, so you could 
configure them to be 

02:55:43.970 --> 02:55:46.429
retained across an activity 
restack based on a configuration

02:55:46.430 --> 02:55:48.430
change and this was really nice 
because it meant now we 

02:55:51.929 --> 02:55:53.558
have somewhere to store our data
model Indiana PendingIntent of 

02:55:53.559 --> 02:55:55.838
the activity being recreated 
every time the configuration 

02:55:55.839 --> 02:55:58.882
changes.  (independent).
     Managing fragments was 

02:55:58.883 --> 02:56:02.973
tricky.  If you attended the 
first Android session here this 

02:56:02.974 --> 02:56:06.032
morning, you see just how tricky
it was.  You can add and remove 

02:56:06.033 --> 02:56:09.961
fragments from any activity, 
have multiple instances of the 

02:56:09.962 --> 02:56:12.020
same fragment within the same 
activity, the fragment 

02:56:12.021 --> 02:56:14.511
transactions are all done 
asynchronously so you can't 

02:56:15.929 --> 02:56:18.000
guarantee when something is 
there, and it's got its own 

02:56:18.001 --> 02:56:19.620
lifecycle to manage.
     Now, none of this was 

02:56:19.621 --> 02:56:23.915
great.  Right.  You were able to
achieve what you wanted, but it 

02:56:23.916 --> 02:56:25.916
was complicated to make this all
work.

02:56:29.200 --> 02:56:31.200
Now, loading, loading was 
better.

02:56:32.479 --> 02:56:34.115
Loading has made it easier to 
asynchronously load data within 

02:56:34.116 --> 02:56:36.781
your fragments and activities, 
and then you 

02:56:40.442 --> 02:56:42.308
can observe and react to changes
in the activity based on 

02:56:42.309 --> 02:56:45.572
whenever the underlying data 
changed, and in most cases you 

02:56:45.573 --> 02:56:47.396
had to handle all of that 
plumbing yourself, which meant 

02:56:47.397 --> 02:56:51.275
you  needed to load the data 
from wherever it was stored, you

02:56:51.276 --> 02:56:53.276
needed to then observe changes 
within that underlying data and 

02:56:54.798 --> 02:56:56.236
bubble it back up through the 
loader to have the simple code 

02:56:56.237 --> 02:56:58.237
in your activity.

02:57:05.180 --> 02:57:07.180
Which was unless you used ku

02:57:08.189 --> 02:57:10.211
curserloader, it did most of the
work for you.  You initial 

02:57:10.212 --> 02:57:12.212
liesed at creation time and then
you filled in a number of 

02:57:13.487 --> 02:57:16.124
callbacks to create a new curser
and then to receive the results 

02:57:16.125 --> 02:57:18.125
so that you can update the UI 
accordingly.

02:57:21.198 --> 02:57:23.198
Initial

02:57:26.209 --> 02:57:27.265
Initiallyizeing the curserloader
-- you use the SQL statement 

02:57:27.266 --> 02:57:30.977
that you want to use to get back
your results and all of it gets 

02:57:30.978 --> 02:57:32.418
passed into a content resolver, 
first your content provider and 

02:57:32.419 --> 02:57:35.139
gets you back a curser which you
can then use to update your UI.

02:57:35.548 --> 02:57:39.210
     But by definition that 
meant that you needed to make 

02:57:39.211 --> 02:57:41.211
your data available 

02:57:42.510 --> 02:57:45.370
via a content provider, and 
content providers are -- 

02:57:45.371 --> 02:57:47.371
actually, you know what?  I'm 
going to come back to content 

02:57:48.422 --> 02:57:50.422
providers, I'm going to leave it
in there for a moment.

02:57:52.330 --> 02:57:55.276
So okay, so take a step back.  
We've got headless fragments and

02:57:56.712 --> 02:57:57.730
loaders and technically that 
enables us to do everything we 

02:57:57.731 --> 02:58:01.882
need to do.  There is a problem 
though, it's really hard to get 

02:58:01.883 --> 02:58:03.326
them to work together, 
understand how to make them work

02:58:03.327 --> 02:58:07.590
across multiple activities and 
fragments in the various 

02:58:07.591 --> 02:58:10.057
different implementations of 
both.  In fact, getting it all 

02:58:10.058 --> 02:58:16.207
to work reliably and well was, 
again, it was frustrating.  

02:58:16.208 --> 02:58:18.272
Which is why we're all so 
excited to see Android 

02:58:18.273 --> 02:58:20.933
architecture components.  
Android architecture components 

02:58:25.253 --> 02:58:28.092
introduced viewmodels, livedata 
and the room database.  It 

02:58:28.093 --> 02:58:29.766
practical replaces fragments and
loaders as a simple way to 

02:58:29.767 --> 02:58:32.642
separate your UI and your UI 
data.

02:58:34.690 --> 02:58:37.138
The viewmodel itself is really 
simple to create.  You start 

02:58:37.139 --> 02:58:39.139
with a property that stores the 
data that you want to expose, in

02:58:42.067 --> 02:58:44.107
this case a mutable livedata 
because livedata is cool, and 

02:58:44.108 --> 02:58:46.108
then you expose a method which 
is going to return that 

02:58:46.387 --> 02:58:49.032
property, and so the first time 
it's going to populate that 

02:58:49.033 --> 02:58:50.873
property and then from then on 
it will return that cached 

02:58:50.874 --> 02:58:52.874
version.

02:58:56.597 --> 02:58:58.597
Then you have a method which 
does 

02:58:59.664 --> 02:59:01.903
that population, and again this 
is done asynchronously.  In this

02:59:01.904 --> 02:59:03.934
case again, we're using our old 
friend the asynchronous task.

02:59:03.935 --> 02:59:08.050
     Then whenever the value of 
your mutable livedata changes, 

02:59:08.051 --> 02:59:10.493
that is going to trigger any 
observerses that you have 

02:59:12.942 --> 02:59:14.397
attached to it, so backing your 
activity, all you need to do is 

02:59:14.398 --> 02:59:16.398
request 

02:59:17.452 --> 02:59:18.673
the viewmodels, ask for the 
specific  viewmodel class that 

02:59:18.674 --> 02:59:24.003
you've just created, and then 
call that viewmodels data access

02:59:24.004 --> 02:59:26.650
method, which will either then 
populate the data and return it,

02:59:29.291 --> 02:59:30.750
but either way you add an 
observer to that and then your 

02:59:30.751 --> 02:59:34.015
observed trigger is going to get
called both the first time you 

02:59:34.016 --> 02:59:36.016
attach the observer and then any

02:59:37.120 --> 02:59:39.120
time the underlying livedata 
changes.

02:59:41.172 --> 02:59:43.218
Now, the beauty of viewmodels is
they survive activity restarts 

02:59:43.219 --> 02:59:47.384
so we don't have to deal with 
that particular scenario, and 

02:59:47.385 --> 02:59:49.618
beauty of livedata is that it 
understands the activity 

02:59:49.619 --> 02:59:51.619
lifecycle, 

02:59:53.297 --> 02:59:55.952
and so the first time the app is
run your viewmodel gets created,

02:59:55.953 --> 02:59:57.953
populates 

02:59:59.213 --> 03:00:01.213
the livedata from the underlying
data 

03:00:02.296 --> 03:00:04.128
source, sends the results back 
by the observed handler within 

03:00:04.129 --> 03:00:09.258
your activity, and then if 
someone rotates their phone, the

03:00:09.259 --> 03:00:10.879
activity gets  destroyed, gets 
recreated, but the existing view

03:00:10.880 --> 03:00:13.768
model is returned.  The existing
live data is returned via 

03:00:16.820 --> 03:00:18.260
the observe handler and it's 
triggered with the latest 

03:00:18.261 --> 03:00:20.261
version of the data whether it's
updated or not in the interim.

03:00:20.304 --> 03:00:22.765
     In fact, livedata is really
smart 

03:00:27.240 --> 03:00:28.887
because it only sends updates 
via the observe handler when the

03:00:28.888 --> 03:00:32.369
activity is active because you 
don't need to update the 

03:00:32.370 --> 03:00:34.370
activity if the UI isn't 
actually 

03:00:35.435 --> 03:00:37.497
visible, and if there is new -- 
so if there is new data, it will

03:00:37.498 --> 03:00:40.554
wait and transfer it once the 
activity becomes active.

03:00:44.018 --> 03:00:46.326
There is a total result and what
we do is feel less like this and

03:00:46.327 --> 03:00:49.025
much more like this, which is 
always our  goal.

03:00:52.687 --> 03:00:54.687
Content providers, I promised 
I'd come 

03:00:57.585 --> 03:00:59.026
back to don't providers, and 
just some context.  This is what

03:00:59.027 --> 03:01:01.027
happens, this is the number of 
students enrolled in each of 

03:01:06.402 --> 03:01:09.273
the lessons of awr our Android 
class, and the highlighted 

03:01:09.274 --> 03:01:13.564
columns when we get to providers
and loaders.  You get the 

03:01:13.565 --> 03:01:17.448
impression this is something 
that is a little frustrating.  

03:01:17.449 --> 03:01:19.524
We improved it since then and 
it's not so grim now.  And some 

03:01:19.525 --> 03:01:21.525
of what we're going to talk 

03:01:22.535 --> 03:01:24.535
about now actually explains some
of those improvements.

03:01:24.788 --> 03:01:26.788
Why is it so frustrating?  This 
is the boilerplate code for 

03:01:28.073 --> 03:01:29.494
creating a simple content 
provider, I'm sure many of you 

03:01:29.495 --> 03:01:31.583
have built something like this. 
In truth, it's really just the 

03:01:31.584 --> 03:01:34.464
first couple of methods.  It 
goes on for a little while, and 

03:01:36.552 --> 03:01:37.352
keep in mind that this isn't 
doing anything particularly 

03:01:37.353 --> 03:01:40.040
special.  It's just passing 
content resolve 

03:01:43.081 --> 03:01:44.920
requests straight through to a 
SQL-like database.  Obviously, 

03:01:44.921 --> 03:01:46.921
that's just the content provider
and then you need to create a 

03:01:48.995 --> 03:01:50.820
contract that defines the column
names that you want to use to be

03:01:50.821 --> 03:01:54.743
able to interact with it, and 
then of course you need to 

03:01:54.744 --> 03:01:56.401
create your own SQL at  
openhelper which is how you 

03:01:56.402 --> 03:01:58.402
create, update, and access the 
underlying database.

03:02:00.888 --> 03:02:02.310
Now, all of there operates on 
cursers which is probably not 

03:02:02.311 --> 03:02:04.311
what 

03:02:05.425 --> 03:02:07.656
you're using in your UI so 
you'll need to create a class to

03:02:07.657 --> 03:02:09.657
represent the records in the 
database, which is nice.

03:02:14.202 --> 03:02:16.202
It's actually quite simple in 
kotlin, 

03:02:19.114 --> 03:02:21.114
but you also need code between 
the 

03:02:22.360 --> 03:02:24.400
observes and add rows to the 
tables and convert cursers and 

03:02:24.401 --> 03:02:26.649
lists of class objects.  
Somewhere align the line you 

03:02:26.650 --> 03:02:30.318
need a list of observers so if 
the database changes, your list 

03:02:30.319 --> 03:02:32.353
of objects also gets  updated.  
It's a lot of code for something

03:02:32.354 --> 03:02:34.583
which should be relatively 
straightforward.

03:02:36.453 --> 03:02:38.453
Quick one, there anyone here who
gets paid per line of code?

03:02:39.936 --> 03:02:43.999
(laughter).
     No.  Okay.  So if there is 

03:02:44.000 --> 03:02:48.700
and you were just too shy, that 
old method actually works really

03:02:48.701 --> 03:02:50.752
well, stick with  that.
     For the rest of us, this is

03:02:50.753 --> 03:02:53.618
where the room database really 
comes into its own.

03:02:56.663 --> 03:02:58.525
So it's part of an Android  
Architecture components, now 

03:02:58.526 --> 03:03:02.626
part of Jetpack, and all you 
need to do is start with the 

03:03:02.627 --> 03:03:04.450
class definition, defines the 
columns that you want within 

03:03:04.451 --> 03:03:06.451
your class, 

03:03:08.722 --> 03:03:11.385
and you just add an annotation 
to say this is an entity I want 

03:03:11.386 --> 03:03:15.056
to use in a database and this is
the primary key for this table. 

03:03:15.057 --> 03:03:17.503
Then you create a new room 
database, which includes each of

03:03:17.504 --> 03:03:22.190
the tables that you want to have
within that database and you 

03:03:22.191 --> 03:03:24.851
return an instance of the data 
access object, and that is the 

03:03:24.852 --> 03:03:26.932
class where you specify all of 
your database 

03:03:30.820 --> 03:03:33.070
interactions, inserts, updates, 
and query, as many as you want 

03:03:33.071 --> 03:03:35.071
and as many different styles as 
you want.

03:03:36.317 --> 03:03:37.750
Now, you notice the queries here
return livedata and that's 

03:03:37.751 --> 03:03:39.751
really cool 

03:03:41.841 --> 03:03:43.896
because if you're storing your 
UI data in the UI model 

03:03:43.897 --> 03:03:45.897
obviously you are because that's
the right way to do 

03:03:49.009 --> 03:03:52.040
things now, it simplifies the 
viewmodel significantly.  You 

03:03:52.041 --> 03:03:54.041
request access to the room 

03:03:55.065 --> 03:03:57.049
databases access object, execute
the query, which returns 

03:03:57.050 --> 03:03:59.050
livedata itself and then you 
just pass that livedata right 

03:03:59.969 --> 03:04:02.272
back through to any activity or 
fragment which requests it.  

03:04:02.273 --> 03:04:04.712
Back in the activity, it works 
the same way.  You've got the 

03:04:04.713 --> 03:04:06.713
same observe handler, 

03:04:07.764 --> 03:04:10.033
getting the same livedata 
representing a collection of 

03:04:10.034 --> 03:04:12.706
objects, and you can use that to
update the UI whenever the 

03:04:13.305 --> 03:04:15.146
underlying database changes.
     So you've got the same 

03:04:15.147 --> 03:04:19.854
outcome that you did before, but
10 times less boilerplate code, 

03:04:19.855 --> 03:04:22.913
10 times less code that you have
to maintain, and also if you 

03:04:22.914 --> 03:04:25.004
change a column name beforehand,
it was a lot of places that 

03:04:25.005 --> 03:04:28.041
could go wrong.  Now you just 
modify the class.

03:04:30.695 --> 03:04:32.736
Now, if you combine that with 
the work manager, you actually 

03:04:32.737 --> 03:04:34.737
get a really 

03:04:36.202 --> 03:04:38.202
clean solution to this whole 
process, right.

03:04:39.887 --> 03:04:41.952
The work manager downloads data 
from a server, updates the room 

03:04:41.953 --> 03:04:46.457
database accordingly, which then
sends the livedata to the 

03:04:46.458 --> 03:04:48.530
viewmodel within the activity 
and fragment, all fragment you 

03:04:51.425 --> 03:04:52.667
want to use, which then by the 
observe handler updates the UI.

03:04:52.668 --> 03:04:56.347
     So if you're not one of the
lucky folks still getting paid 

03:04:56.348 --> 03:04:58.787
by line of code, this is 
probably a better solution, 

03:04:58.788 --> 03:05:01.830
right.
     So speaking of better 

03:05:01.831 --> 03:05:05.713
solutions, what else have we 
got?  I wanted to talk a little 

03:05:05.714 --> 03:05:08.556
bit about Android location 
services because this is again a

03:05:08.557 --> 03:05:10.800
topic that I've spent a lot of 
time talking about.

03:05:14.262 --> 03:05:16.500
Being able to find the current 
position and put it on a map 

03:05:16.501 --> 03:05:21.458
somewhere is something that's 
been part of Android since the 

03:05:21.459 --> 03:05:23.459
very first beta SDK.

03:05:25.556 --> 03:05:27.631
So by 2011, I had actually 
managed to amass quite a 

03:05:27.632 --> 03:05:29.632
selection of pro tips for how to
take advantage of the location 

03:05:30.930 --> 03:05:33.982
manager in the most efficient 
and effective way possible.  It 

03:05:33.983 --> 03:05:35.983
was a big topic in a couple of 
my 

03:05:37.160 --> 03:05:38.572
Android pro tip's talks.
     So I went to the location 

03:05:38.573 --> 03:05:42.640
team and I said I've built a 
project which encapsulates all 

03:05:42.641 --> 03:05:44.641
of our best practices, all of 
the things which we tell people 

03:05:46.120 --> 03:05:51.072
to do, and it's fair to say that
they were impressed.  By which I

03:05:51.073 --> 03:05:54.521
mean it really left an 
impression.  They then went away

03:05:54.522 --> 03:05:58.202
and did what they do which is 
fixed everything, and so where 

03:05:58.203 --> 03:06:01.053
beforehand I had all of these 
classes and interfaces, they 

03:06:01.054 --> 03:06:03.054
went away 

03:06:06.227 --> 03:06:07.853
and gave me an API as part of 
the fused location provider, 

03:06:07.854 --> 03:06:09.854
which does all of the 

03:06:11.537 --> 03:06:12.968
magic for you, and encapsulates 
all of those best practices 

03:06:12.969 --> 03:06:14.969
within a small number of simple 
APIs.

03:06:16.268 --> 03:06:17.922
All you need to do here is tell 
it what's more important, 

03:06:17.923 --> 03:06:22.217
battery life or accuracy?  How 
often do you want to get 

03:06:22.218 --> 03:06:26.493
results, and the fuse location 
provider goes and does all of 

03:06:26.494 --> 03:06:29.133
the hard work for you.
     Now that said, things have 

03:06:29.134 --> 03:06:31.987
changed a little bit n. our area
we made some changes, new 

03:06:33.819 --> 03:06:35.819
restrictions about how you can 
receive 

03:06:37.903 --> 03:06:39.755
location updates while the app 
is in the background in order to

03:06:39.756 --> 03:06:41.599
save battery life.  
Specifically, that means if 

03:06:41.600 --> 03:06:43.600
you're in the background you 
only receive updates 

03:06:47.894 --> 03:06:52.982
from location manager or a few 
times an hour.  A few ways to 

03:06:52.983 --> 03:06:55.081
deal with it, make a foreground 
service, another approach is 

03:06:58.608 --> 03:07:00.866
to use geofence, so for those of
you who remember the very first 

03:07:00.867 --> 03:07:05.789
version of geofencing on Android
were proximity alerts and 

03:07:05.790 --> 03:07:07.790
proximity alerts were  bad.

03:07:09.097 --> 03:07:11.097
Easy enough to set up and 
specify a 

03:07:12.392 --> 03:07:14.832
lat, long radius around a point 
and they would reliably figure 

03:07:14.833 --> 03:07:16.833
if you went across the boundary.

03:07:18.715 --> 03:07:20.715
The thing the way it achieved it
is by 

03:07:23.185 --> 03:07:25.185
turning turning on and leaving 
on your 

03:07:27.726 --> 03:07:30.172
GPS, if you had a proximity 
alerm set GPS would run 

03:07:30.173 --> 03:07:31.800
constantly, it's not what the 
documentation said but it is 

03:07:31.801 --> 03:07:33.848
what happens.
     Now the fused location 

03:07:33.849 --> 03:07:39.357
provider also gave us a real  
geofencing API that had all the 

03:07:39.358 --> 03:07:41.583
functionality that was claimed 
from -- that was claimed to be 

03:07:45.487 --> 03:07:47.487
done with proximity alerts but 
also gave 

03:07:49.505 --> 03:07:51.347
you a few additional 
improvements.  Most important of

03:07:51.348 --> 03:07:54.855
which is that it didn't keep the
GPS  locked permanently on.

03:07:58.688 --> 03:08:00.688
We it take

03:08:04.461 --> 03:08:06.523
our geoto the next level which 
allows us to make more 

03:08:06.524 --> 03:08:08.524
complicated fences, we can add 
date and time, proximity to 

03:08:11.409 --> 03:08:12.633
beacon, user activity, walking, 
cycling, driving, and device 

03:08:12.634 --> 03:08:15.537
state.  You can combine all of 
these conditions together, such 

03:08:15.538 --> 03:08:19.274
as in this example, we have one 
fence which is triggered if you 

03:08:19.275 --> 03:08:21.751
drive within 1,000 meters of a 
given location between 10 and 6.

03:08:21.970 --> 03:08:26.474
     We have a little bit of 
time left.  One thing I  learned

03:08:26.475 --> 03:08:30.766
in 2018 is that there is a new 
way to -- I'm sorry.  That 

03:08:30.767 --> 03:08:33.212
should be there is a new way to 
control media.  Right.

03:08:35.310 --> 03:08:37.752
Now, back in the day, 
controlling media playback was 

03:08:37.753 --> 03:08:39.787
done with the media player.  I'm
going to buzz through this 

03:08:39.788 --> 03:08:43.679
pretty quickly.  Mainly it meant
that you had to listen to media 

03:08:43.680 --> 03:08:46.554
buttons getting clicked.  Now, 
of course, you can control media

03:08:48.576 --> 03:08:50.576
a bunch of different ways so we 
have a 

03:08:51.668 --> 03:08:53.698
better solution which is 
exoplayer that effectively 

03:08:53.699 --> 03:08:56.582
replaces the framework, media 
player is easy to customize and 

03:08:56.799 --> 03:09:00.904
extend.  I'm not going to go 
through the detailts, but I had 

03:09:00.905 --> 03:09:05.025
been speaking so slowly, so I 
recommend you go to Mark and 

03:09:05.026 --> 03:09:06.640
Andrew's talk tomorrow morning 
at 10:30 and get all of the 

03:09:06.641 --> 03:09:08.323
details.
     Now, not all of the changes

03:09:08.324 --> 03:09:11.229
in Android have been in code.  
Some of the biggest changes are 

03:09:14.688 --> 03:09:18.172
actually in the  availability of
Android expertise.  Back when we

03:09:18.173 --> 03:09:20.429
started we didn't have soip 
slack or Google developer 

03:09:20.430 --> 03:09:22.430
experts or stack overflew.

03:09:25.133 --> 03:09:27.392
We had IRC, Google developer 
groups, Dev rel people that 

03:09:27.393 --> 03:09:29.393
spoke at conference, and that 
still kind of happens.

03:09:31.314 --> 03:09:33.314
The big change now is that we're
just voices within a much larger

03:09:34.001 --> 03:09:36.001
developer ecosystem.  There are 
now lots and lots of people 

03:09:37.041 --> 03:09:39.041
around the world who help each 
other.

03:09:42.716 --> 03:09:44.716
This is just a small selection 
of the

03:09:47.201 --> 03:09:48.619
90 Googler experts  specialing 
in kotlin around the world, a 

03:09:48.620 --> 03:09:52.100
small selection of the 
engineering team that we have 

03:09:52.101 --> 03:09:53.520
helping the community.  
Similarly we have Android 

03:09:53.521 --> 03:09:55.763
conferences all around the 
world.  This is a small 

03:09:55.764 --> 03:09:59.217
selection of some of the Android
events that people pointed out 

03:09:59.218 --> 03:10:00.893
to me on Twitter a couple of 
weeks ago when I asked what the 

03:10:00.894 --> 03:10:04.963
best conferences to go to were 
because really the biggest tip 

03:10:04.964 --> 03:10:09.306
that I can give you is that much
more than changes in the tooling

03:10:09.307 --> 03:10:11.307
or the frameworks or the APIs or

03:10:12.358 --> 03:10:15.005
Jetpack or anything else, much 
more than that the biggest thing

03:10:15.006 --> 03:10:17.228
driving Android development 
forward is the community, it's 

03:10:17.229 --> 03:10:18.680
the people around you, the 
people online who are all 

03:10:18.681 --> 03:10:20.681
helping each other 

03:10:22.552 --> 03:10:24.372
with Android, and it's important
because we know the up with 

03:10:24.373 --> 03:10:26.373
thing that doesn't change is 
that things are going to change.

03:10:27.252 --> 03:10:28.482
So take advantage of things like
Jetpack to make things simpler, 

03:10:28.483 --> 03:10:32.590
work with the people around you,
and hopefully your apps will 

03:10:32.591 --> 03:10:36.250
survive much longer than my pro 
tips.  Thank you.

03:10:37.716 --> 03:10:39.716
(Applause).

03:10:53.311 --> 03:10:55.311
     &gt;&gt; Thank you for joining 
this session.

03:10:58.143 --> 03:11:00.143
Grand

03:11:01.301 --> 03:11:03.301
Ambassadors will assist with 
directing you through the exits.

03:11:04.156 --> 03:11:05.567
We'll be making room for people 
in the next session.  If you 

03:11:05.568 --> 03:11:07.409
registered for the next session 
in this room, we ask that you 

03:11:07.410 --> 03:11:10.284
please clear the room and return
via the registration line 

03:11:10.285 --> 03:11:12.285
outside.  Thank you.

03:14:13.840 --> 03:14:16.689
May 9, 2018
     11:30 a.m.

03:14:21.324 --> 03:14:23.324
PT

03:22:58.837 --> 03:23:00.837
What's New in 

03:23:06.620 --> 03:23:08.620
Architecture Components

03:25:29.382 --> 03:25:34.925
     &gt;&gt; Welcome to Google I/O 
2018.  We're happy you're  

03:25:34.926 --> 03:25:38.834
joining us as we celebrate 
platform innovations at Google. 

03:25:38.835 --> 03:25:39.847
Right now you checked into 
registration to receive your 

03:25:39.848 --> 03:25:41.848
badge.

03:25:42.916 --> 03:25:44.916
It must be visibly warn at all 
times, 

03:25:46.977 --> 03:25:48.809
and don't forget you need it to 
ride the shuttles and enter the 

03:25:48.810 --> 03:25:53.304
end of the day activities on 
days one and two.  Throughout 

03:25:53.305 --> 03:25:56.811
the event visit Google.com/I/O. 
Or download the app for the most

03:25:59.139 --> 03:26:00.755
up-to-date schedules and 
conference map.  For  questions 

03:26:00.756 --> 03:26:02.756
or assistance stop by the 
information desk  located across

03:26:06.448 --> 03:26:08.509
from the Codelabs building or 
chat with any staff member 

03:26:08.510 --> 03:26:10.510
wearing a yellow badge.

03:26:12.955 --> 03:26:14.285
Sessions will take place in the 
aphitheatere as well as eight 

03:26:14.286 --> 03:26:16.286
stages throughout the venue.

03:26:19.475 --> 03:26:22.134
If you haven't received a seat 
for your favorite session, or if

03:26:22.135 --> 03:26:26.434
you miss a session, don't worry 
recordings will be available 

03:26:26.435 --> 03:26:28.435
shortly after the sessions end.

03:26:30.098 --> 03:26:32.735
Be sure to visit the Codelabs 
with  red-to-code kiosks and 

03:26:32.736 --> 03:26:35.614
Google staff will be available 
for helpful advice and provide 

03:26:35.615 --> 03:26:37.646
direction if you need support
     Make some time to visit the

03:26:37.647 --> 03:26:42.573
office hours and app  reviews 
tent to meet one-on-one with 

03:26:42.574 --> 03:26:44.574
Googlers and ask your technical 
questions and get feedback on 

03:26:46.057 --> 03:26:50.541
your ploj projects.  If you're 
looking to network join one of 

03:26:50.542 --> 03:26:52.793
the several  meetups hosted in 
the community lounge.  Finally, 

03:26:52.794 --> 03:26:54.662
we would like to invite to you 
visit the sandbox domes where 

03:26:54.663 --> 03:26:58.752
you can explore, learn, and play
with our latest products and 

03:26:58.753 --> 03:27:01.644
platforms, interactive demo, 
physical installations, and 

03:27:01.645 --> 03:27:06.318
more.  After sessions are done 
for the day, stick around for 

03:27:06.319 --> 03:27:08.583
food, drinks, music, and fun.  
Be prepared for some surprises 

03:27:08.584 --> 03:27:11.885
along the way.  We'd like to 
take this opportunity to remind 

03:27:11.886 --> 03:27:14.145
you that we are dedicated to  
providing an inclusive event 

03:27:14.146 --> 03:27:16.824
experience for everyone, and 
that by attending 

03:27:20.078 --> 03:27:22.107
Google I/O you agree to our Code
of  Conduct posted throughout 

03:27:22.108 --> 03:27:23.557
the venue
     Your opinion is valuable to

03:27:23.558 --> 03:27:27.212
us.  After the event, look out 
for a feedback form to share 

03:27:27.213 --> 03:27:32.102
your experience.  Thanks for 
attending and have a wonderful 

03:27:32.103 --> 03:27:34.103
time exploring Google I/O.

03:28:01.576 --> 03:28:06.065
May 9, 2018
     11:30 a.m. PT

03:28:12.396 --> 03:28:14.015
What's New in Architecture 
Components

03:30:35.267 --> 03:30:37.716
     &gt;&gt; Good morning.
     (Applause)

03:30:43.285 --> 03:30:45.738
     &gt;&gt; LUKAS BERGSTROM:  It's 
great to see everybody here.

03:30:48.994 --> 03:30:50.994
I'm Lukas berg strom.  Product 
manager.

03:30:55.940 --> 03:30:56.978
How many were here last year 
when we addressed architecture 

03:30:56.979 --> 03:31:00.683
components for the first time.  
Awesome.  This is a much bigger 

03:31:00.684 --> 03:31:04.337
venue so that's actually a 
descent percentage.  When we did

03:31:04.338 --> 03:31:06.585
launch architecture components 
last year we were doing 

03:31:08.221 --> 03:31:10.515
something sort of different for 
us.  For the first time we were 

03:31:10.516 --> 03:31:12.516
offering 

03:31:13.557 --> 03:31:15.587
explicit guidance in how to 
architect your app and giving 

03:31:15.588 --> 03:31:17.588
you components letting you do 
that.

03:31:19.875 --> 03:31:21.875
And frankly for us, it was a 
little 

03:31:25.323 --> 03:31:27.062
bit of a journey into the 
unknown, so 1 12 months in let's

03:31:27.063 --> 03:31:30.566
check in on how we're doing.  
We've shipped 26 releases since 

03:31:30.567 --> 03:31:34.633
May of last year, so we've been 
constantly iterating and 

03:31:34.634 --> 03:31:39.322
improving the core set of 
architecture components.  The 

03:31:39.323 --> 03:31:40.969
sign of any healthy Open Source 
project, we have a very active 

03:31:40.970 --> 03:31:44.877
issue tracker and I'd like to 
thank everybody that's taken 

03:31:44.878 --> 03:31:46.878
time to file a feature 

03:31:49.153 --> 03:31:51.153
request or even a bug and we've 
closed a lot of those.

03:31:52.847 --> 03:31:54.079
We launched a major new library 
Paging, which is now stable and 

03:31:54.080 --> 03:31:59.384
we'll talk a little bit more 
about it today.  And I'm pleased

03:31:59.385 --> 03:32:04.493
to say based on our survey data,
over half of you are using or 

03:32:04.494 --> 03:32:06.522
planning to use architecture  
components, and this survey was 

03:32:06.523 --> 03:32:08.523
done 

03:32:09.588 --> 03:32:11.521
only a few months after we went 
stable, so this data is pretty 

03:32:11.522 --> 03:32:14.582
out of date by now, but I'm 
pretty proud of the fact that 

03:32:14.583 --> 03:32:16.583
only a few months after 
launching 

03:32:18.044 --> 03:32:19.481
to stable, over half of the 
Android developers we talked to 

03:32:19.482 --> 03:32:21.518
were planning to use this stuff.

03:32:24.791 --> 03:32:26.791
But more importantly than any of

03:32:27.868 --> 03:32:30.122
this, you've told us that 
architecture components actually

03:32:30.123 --> 03:32:35.102
make it easier for you to build 
robust apps, that having a clear

03:32:35.103 --> 03:32:36.539
path on how to architect your 
app and components that help you

03:32:36.540 --> 03:32:39.824
realize that has actually made a
difference in the real world in 

03:32:39.825 --> 03:32:43.511
how you build your apps.  And 
we've heard that not just once 

03:32:43.512 --> 03:32:48.034
but we've heard that over and 
over from a lot of developers 

03:32:48.035 --> 03:32:52.915
that have taken time to speak to
us.

03:32:55.768 --> 03:32:57.569
So architecture components has 
grown and we're going to 

03:32:57.570 --> 03:32:59.570
continue to invest here.

03:33:02.663 --> 03:33:05.309
This is foundational, we  think,
for Android apps going forward.

03:33:08.579 --> 03:33:10.198
But not just are we investing in
architecture components but this

03:33:10.199 --> 03:33:13.886
year with Jetpack, we're going 
to take that same approach that 

03:33:13.887 --> 03:33:16.358
we took with Architecture 
Components, a blank sheet 

03:33:21.308 --> 03:33:22.327
of paper approach to how Android
developer experience should be 

03:33:22.328 --> 03:33:24.994
and how we can improve things 
for you.  Jetpack is going to 

03:33:24.995 --> 03:33:27.222
take that and apply that to the 
rest of the developer 

03:33:30.743 --> 03:33:32.743
API service that we offer.

03:33:37.200 --> 03:33:39.698
So now I'm going to turn it over
to Yigit to talk about what's 

03:33:39.699 --> 03:33:43.170
new in Architecture Components.
     (Applause).

03:33:48.857 --> 03:33:50.479
&gt;&gt; YIGIT BOYAR:  Thanks, Lukas. 
So we'll talk about what we've 

03:33:50.480 --> 03:33:54.157
been doing in the last one year.
We'll look at exiting libraries,

03:33:54.158 --> 03:33:56.189
talk about improvement, and also
look at the 

03:33:59.676 --> 03:34:01.149
new shiny stuff, paging, 
navigation, and work manager.

03:34:01.150 --> 03:34:03.824
     Let's start with 
lifecycles, so we 

03:34:07.107 --> 03:34:08.946
have shipped  lifecycles in the 
last I/O but to better 

03:34:08.947 --> 03:34:10.947
understand why we have 

03:34:13.249 --> 03:34:15.918
created this component, let's go
to two years before.  In 2016, 

03:34:15.919 --> 03:34:17.962
we did a bunch of surveys and 
asked developers, what is the 

03:34:17.963 --> 03:34:19.963
hardest part of the Android 
development?

03:34:23.271 --> 03:34:25.271
And by far in the list, big 
surprise, 

03:34:26.749 --> 03:34:29.610
was lifecycle  managements.  We 
were wondering what can be hard 

03:34:32.517 --> 03:34:33.953
about a phone rotating or users 
reaching applications, this 

03:34:33.954 --> 03:34:36.830
appears all the time on Android,
Android is built for this.  But 

03:34:36.831 --> 03:34:39.270
if you look at the problem in 
detail, if you want to handle 

03:34:39.271 --> 03:34:41.310
them properly in your 
application, you need 

03:34:46.207 --> 03:34:48.483
to understand these graphs very 
well and when these two are 

03:34:48.484 --> 03:34:51.385
interlinked it becomes very 
confusing, so we we have 

03:34:54.444 --> 03:34:55.883
created lifecycles component to 
get at these problems, and it 

03:34:55.884 --> 03:34:57.884
seems to be 

03:35:01.648 --> 03:35:03.648
working because many developers,
you ask 

03:35:05.904 --> 03:35:07.621
testimonials, a group of 
problems just disappeared from 

03:35:07.622 --> 03:35:10.058
their application when is they 
started using these libraries.

03:35:10.467 --> 03:35:13.563
     Another important change of
lifecycles is one year ago we 

03:35:13.564 --> 03:35:18.081
introduced them as a optional 
library, but now they're a 

03:35:18.082 --> 03:35:20.321
fundamental part of Android 
development.  You don't need to 

03:35:20.322 --> 03:35:22.781
do any additional libraries to 
start using them.

03:35:28.433 --> 03:35:30.433
Now both app

03:35:31.774 --> 03:35:33.584
compatactivity and both include 
lifecycle.

03:35:33.585 --> 03:35:35.832
Another interesting thing that 
happens is the community 

03:35:35.833 --> 03:35:38.087
adoption, so we ourself create 
new APIs that  works with 

03:35:40.337 --> 03:35:42.792
lifecycles but we do other 
people doing the same in their 

03:35:42.793 --> 03:35:44.793
libraries and this is 

03:35:46.857 --> 03:35:48.502
so much easier because already 
app compat has the dependencies 

03:35:48.503 --> 03:35:51.162
so you can easily depend on them
in your libraries.

03:35:53.628 --> 03:35:56.310
One great example is auto 
dispose library from Uber, so if

03:35:56.311 --> 03:35:58.311
you're using Java but you want 
the automatic  

03:36:02.000 --> 03:36:04.000
lifecycle planning management, 
you can 

03:36:05.259 --> 03:36:06.886
just add this to the stream, 
give it to lifecycle and it will

03:36:06.887 --> 03:36:08.887
manage the subscription for you 
for free.

03:36:12.422 --> 03:36:14.665
Now, working on these things 
we've also covered more problems

03:36:14.666 --> 03:36:16.666
we have.

03:36:17.954 --> 03:36:20.649
One of them is the fragments of 
lifecycle.  Now fragments has a 

03:36:20.650 --> 03:36:25.121
very complicated lifecycle.  
Let's look at an example.  So if

03:36:25.122 --> 03:36:27.122
you have a fragment that when 

03:36:29.396 --> 03:36:30.635
it's created observing the 
livedata.  It goes through the 

03:36:30.636 --> 03:36:33.050
creation, we create a view for 
it, and it goes to the resume 

03:36:33.051 --> 03:36:35.051
state.

03:36:37.960 --> 03:36:39.596
At this point if you're losing 
your  livedata, the UI will 

03:36:39.597 --> 03:36:42.669
start displaying them and 
everything works fine.  Later on

03:36:42.670 --> 03:36:44.297
the user hits a button, so you 
want to detect this fragment 

03:36:44.298 --> 03:36:48.582
because they're going to another
fragment, and you're going to 

03:36:48.583 --> 03:36:51.234
stop that fragment but once the 
fragment is stopped, we don't 

03:36:52.443 --> 03:36:56.345
need the view for it.  We would 
like to reclaim those resource, 

03:36:56.346 --> 03:36:58.346
so we destroy the view.

03:36:59.612 --> 03:37:01.612
Later on user hits the back 
button, 

03:37:04.296 --> 03:37:05.752
you go back to the previous 
button, you reattach, and 

03:37:05.753 --> 03:37:07.814
because we have destroyed the 
wheel we create a new one, we go

03:37:09.858 --> 03:37:12.579
ahead and do it but it's a brand
new wheel, and it goes through 

03:37:12.580 --> 03:37:14.580
the regular 

03:37:15.603 --> 03:37:16.823
creation cycle and now we have a
bar.  This new wheel will never 

03:37:16.824 --> 03:37:20.366
resume the state of that live 
data because you're using the 

03:37:20.367 --> 03:37:23.213
fragments lifecycle to observe 
it so we don't have any reason 

03:37:23.214 --> 03:37:26.453
to redispatch the same value.
     Of course, if livedata 

03:37:26.454 --> 03:37:31.332
receives any value, the UI will 
be updated but it's kind of too 

03:37:31.333 --> 03:37:33.333
late because on recreate your UI
has a bad state.

03:37:37.707 --> 03:37:40.158
Now, this left you with two 
options, you either subscribe 

03:37:40.159 --> 03:37:45.635
oncreate, it looks very clean 
and one-time setup, but it will 

03:37:45.636 --> 03:37:48.518
fail if you recreate the wheel 
so you need to manually recreate

03:37:49.119 --> 03:37:51.119
the wheel.

03:37:53.006 --> 03:37:55.006
And onconcreteview handles the 
recreation but you have double 

03:37:56.727 --> 03:37:57.971
registrations you need to use 
and lose automatic lifecycle 

03:37:57.972 --> 03:38:00.001
managements.
     So the problem here is 

03:38:00.002 --> 03:38:02.055
fragments have not one but two 
lifecycles and we 

03:38:05.300 --> 03:38:07.379
have decided to embrace it and 
give the fragment view its own 

03:38:07.380 --> 03:38:09.380
lifecycle.

03:38:13.486 --> 03:38:15.731
So now starting a separate 
library 28 or Android  text, 1.

03:38:18.782 --> 03:38:21.678
2, while observing livedata you 
can specify the viewlifecycle, 

03:38:21.679 --> 03:38:24.542
so while you're observing if 
it's about the wheel, you use 

03:38:24.543 --> 03:38:26.543
the wheel lifecycle, otherwise 
you use the fragment lifecycle 

03:38:28.818 --> 03:38:30.818
and we manage the subscription 
for you for free.

03:38:31.069 --> 03:38:35.619
Okay.  Data binding, so when we 
started to look at our offerings

03:38:35.620 --> 03:38:37.620
as part of Jetpack 

03:38:39.101 --> 03:38:40.329
we decided to move data binding 
as part of architecture 

03:38:40.330 --> 03:38:42.330
competence.

03:38:43.584 --> 03:38:45.584
If you're not already using data

03:38:47.546 --> 03:38:49.593
binding it's our solution for  
boilerplate UIs.  If you have 

03:38:49.594 --> 03:38:51.840
this like this in your 
application, binding layouts you

03:38:51.841 --> 03:38:56.327
can reference your object and we
take care of updating the UI for

03:38:56.328 --> 03:38:58.372
you.
     In data binding 3.

03:39:02.816 --> 03:39:05.098
1 we have added native support 
for livedata.

03:39:08.550 --> 03:39:10.550
So if you have a view for live 
user 

03:39:13.648 --> 03:39:16.102
and pass for binding, you can 
use the livedata as regular 

03:39:16.103 --> 03:39:18.103
field,  databinding will 
understand it's live data and 

03:39:18.791 --> 03:39:20.243
generate the correct codes.
     Unfortunately this is not 

03:39:20.244 --> 03:39:24.576
enough for it to observe it 
because data binding doesn't 

03:39:24.577 --> 03:39:26.611
have a lifecycle.  To fix that 
when you get your binding 

03:39:28.238 --> 03:39:29.905
instance, you just tell it which
lifecycle it should use and it 

03:39:29.906 --> 03:39:33.762
will start observing the live 
data, keep itself up to date, 

03:39:33.763 --> 03:39:38.199
you don't need to write any code
for this.

03:39:41.527 --> 03:39:43.581
We have also part of the data 
binding compiler to be more 

03:39:43.582 --> 03:39:45.582
incremental.

03:39:47.028 --> 03:39:48.477
If you have a project with 
multiple modules it's going to 

03:39:48.478 --> 03:39:52.363
compile a lot faster, and we're 
also working on making the 

03:39:52.364 --> 03:39:54.364
compilation more incremental but
they're not finished yet.

03:39:56.073 --> 03:39:58.313
This new compiler also gave us 
the ability to support instant 

03:39:58.314 --> 03:40:03.040
apps and now you can use data 
binding in the future modules of

03:40:03.041 --> 03:40:05.041
your instant tabs.
     Okay.

03:40:07.541 --> 03:40:10.607
Room, my favorite architecture 
competence.  So  Room was our 

03:40:10.608 --> 03:40:12.608
solution for object 

03:40:15.923 --> 03:40:17.923
mapping that binds the gap 
between the SQLete or Java code.

03:40:20.244 --> 03:40:22.515
One important change in  Room 1.
1 is the support for better 

03:40:22.726 --> 03:40:28.015
multithreading.  So if you are 
using Room 1.0 and if you have 

03:40:28.016 --> 03:40:30.016
one thread trying to 

03:40:32.511 --> 03:40:34.353
exsetter exert a lot of database
into the database and another 

03:40:34.354 --> 03:40:37.604
thread trying to read the data, 
while your write is  executing 

03:40:37.605 --> 03:40:39.642
your read will be blocked and it
can only execute after the write

03:40:39.643 --> 03:40:42.118
is complete.
     In Room 1.

03:40:46.224 --> 03:40:48.224
1 they can run in parallel, and 
another 

03:40:49.464 --> 03:40:51.464
nice feature of this is your 
writes run 

03:40:54.053 --> 03:40:56.053
a lot faster than before.  Best 
part of this change, you don't 

03:40:56.691 --> 03:40:58.691
need to do anything for take 
advantage of this.

03:41:01.892 --> 03:41:03.557
If the device is running, Jelly 
Bean or influencer and not a 

03:41:03.558 --> 03:41:06.209
low-memory device we're going to
enable it for free.

03:41:07.014 --> 03:41:09.014
Okay.

03:41:10.883 --> 03:41:12.883
Another important addition to 
Room was 

03:41:14.555 --> 03:41:16.595
the support for @RawQuery, but 
to understand why we needed 

03:41:16.596 --> 03:41:18.623
@RawQuery let's talk about the 
query annotation.

03:41:25.118 --> 03:41:27.118
While using Room you can specify

03:41:28.497 --> 03:41:30.337
and use the main parameters and 
put as regular function elements

03:41:30.338 --> 03:41:32.779
and tell the Room what to 
return.  The best part of this 

03:41:32.780 --> 03:41:37.501
setup is that Room is going to 
validate all of the set compiled

03:41:37.502 --> 03:41:39.956
time so if there is a mistake in
your query, if your parameters 

03:41:41.381 --> 03:41:43.259
doesn't measure, what you try to
return doesn't make sense, it's 

03:41:43.260 --> 03:41:45.092
going to file the compilation 
and let you know whether a is 

03:41:45.093 --> 03:41:47.942
wrong.
     Now, this is all cool 

03:41:47.943 --> 03:41:49.943
except what 

03:41:51.208 --> 03:41:54.073
if you don't know the query at 
compiled time?  What if you're 

03:41:54.074 --> 03:41:56.790
writing a real estate 
application, my user can't 

03:41:56.791 --> 03:42:01.694
search houses with the price, 
maybe they want to specify 

03:42:01.695 --> 03:42:05.581
number of bedrooms,  bathroom, 
whether it has a yard.  If you 

03:42:05.582 --> 03:42:07.211
needed a query and it mattered 
for each variation of this that 

03:42:07.212 --> 03:42:09.212
would be impossible to maintain.

03:42:12.136 --> 03:42:14.136
So what you do in this case is 
you 

03:42:17.478 --> 03:42:19.318
create at runtime with the 
options provided for the user 

03:42:19.319 --> 03:42:22.370
and you provide the arguments 
for that query.  You obtain a 

03:42:22.371 --> 03:42:24.371
instance of the  Room 

03:42:26.020 --> 03:42:27.643
database and use this query 
method to get the result.

03:42:27.644 --> 03:42:29.644
So far so good.

03:42:30.718 --> 03:42:33.574
The problem with this approach 
is that it returns a curser.  

03:42:33.575 --> 03:42:35.609
Who wants a curser in you're 
trying to get the list of 

03:42:35.610 --> 03:42:37.610
houses, so this looks 

03:42:40.282 --> 03:42:41.712
like a failure of the library, 
hence we decided to introduce 

03:42:41.713 --> 03:42:47.459
@RawQuery.  It looks very 
similar to Query, except instead

03:42:47.460 --> 03:42:49.931
of specifying the query in the 
annotation, you pass it as a 

03:42:49.932 --> 03:42:53.450
parameter to the function and 
then you tell us what you want 

03:42:53.451 --> 03:42:55.451
us to return.

03:42:57.111 --> 03:42:59.170
Now here Room cannot validate 
the query anymore so it's kind 

03:42:59.171 --> 03:43:02.453
of like you promise us to send 
the right query and it will take

03:43:02.454 --> 03:43:06.779
care of it.  Once you have that,
if you go back to our previous 

03:43:06.780 --> 03:43:08.780
example, we can get an 

03:43:10.088 --> 03:43:12.150
instance of our Dao, and we need
to merger with parameters and 

03:43:12.151 --> 03:43:14.151
the query in 

03:43:16.054 --> 03:43:18.054
the simple of the which is a 
basic data 

03:43:19.540 --> 03:43:22.177
holder and then you compress it 
to the Dao and get the list of 

03:43:22.178 --> 03:43:25.227
houses, no more cursers and no 
more boilerplate code.

03:43:25.655 --> 03:43:28.493
Okay.  Paging, so Paging is our 
solution for 

03:43:32.768 --> 03:43:34.640
lazy loading in RecyclerView, 
but to better understand why we 

03:43:34.641 --> 03:43:36.907
drew up this competence, I want 
to go to an example.

03:43:38.538 --> 03:43:40.179
So you have a list like this, 
it's very common and every 

03:43:40.180 --> 03:43:42.180
single application 

03:43:43.654 --> 03:43:45.654
has it, user can scroll, but you
know it 

03:43:47.299 --> 03:43:49.299
takes a much larger list than 
what's on the screen.

03:43:50.545 --> 03:43:53.411
If you're in a application, it 
could be a very, very long list 

03:43:53.412 --> 03:43:57.502
so you probably cannot use the 
memory and very inefficient to 

03:43:57.503 --> 03:43:59.766
load all of it, so what you 
would do is keep some of it in 

03:44:01.403 --> 03:44:03.846
memory, the rest of it in 
database, and you also have your

03:44:03.847 --> 03:44:05.847
server competent where you pull 
this data from.

03:44:08.142 --> 03:44:09.569
This is actually hard to 
implement properly, and that's 

03:44:09.570 --> 03:44:11.570
why we have created 

03:44:13.635 --> 03:44:15.277
the Paging library to make this 
common flow very easily and 

03:44:15.278 --> 03:44:17.278
efficient to implement.

03:44:20.830 --> 03:44:22.830
Paging library comes with a 
paged 

03:44:24.104 --> 03:44:25.534
list, an actual Java list 
implementation but it works with

03:44:25.535 --> 03:44:27.535
a data source.  Every time you 
access the items in the 

03:44:32.311 --> 03:44:34.311
page list it pulls data from the
data 

03:44:37.237 --> 03:44:39.237
source lazily, it just brings in
more data.

03:44:40.099 --> 03:44:42.742
How can we get an instance of 
these?  It's actually super easy

03:44:42.743 --> 03:44:46.437
if you're using Room.  So Room 
knows thousand create the data 

03:44:48.305 --> 03:44:49.949
source, so it's a great example 
of how the architecture 

03:44:49.950 --> 03:44:52.819
components work very well 
together.  You can just tell 

03:44:52.820 --> 03:44:56.285
Room to return your data source 
or a data source factory, and in

03:44:56.286 --> 03:44:59.161
this case I'm using a data 
source factory because data is 

03:44:59.162 --> 03:45:03.621
something that changes and each 
data source represents a 

03:45:03.622 --> 03:45:05.622
snapshot so we need a factory so
that 

03:45:08.996 --> 03:45:10.996
we can create new data sources 
when data changes.

03:45:13.085 --> 03:45:15.085
Once you have this you can use 
the 

03:45:16.568 --> 03:45:19.425
live page builder and build on 
it, it's going to give you a 

03:45:19.426 --> 03:45:22.276
livedata paged list of users and
almost the same as livedata list

03:45:22.277 --> 03:45:24.317
of  users.
     Now in your activity or 

03:45:24.318 --> 03:45:29.406
fragment, you would use this 
page list adapter which is a 

03:45:29.407 --> 03:45:32.067
cycle review adapter that  works
with page list.  You would 

03:45:32.068 --> 03:45:34.118
observe the line data any time 
we have a new page list, give it

03:45:34.119 --> 03:45:36.119
to 

03:45:37.801 --> 03:45:40.464
the adapter, and then the 
adapter can just call this and 

03:45:40.465 --> 03:45:45.983
getitem function typed in the 
user object.  It's a super 

03:45:45.984 --> 03:45:47.997
simple code to write and we take
care of all the hard work of 

03:45:50.151 --> 03:45:51.569
paging it lazily for you.
     Even though I have shown 

03:45:51.570 --> 03:45:54.449
all of those examples with 
livedata, paging 

03:45:57.925 --> 03:45:59.925
supports Rxjava out of the box, 
if you 

03:46:01.004 --> 03:46:02.862
are using that and you want a 
level of pages, you can just get

03:46:02.863 --> 03:46:05.297
the same factory that the room 
generates and but instead 

03:46:10.202 --> 03:46:12.202
use the RxPageed Builder to 
build.

03:46:13.070 --> 03:46:15.514
Paging features from the 
database have been shown here 

03:46:15.515 --> 03:46:18.606
but also it supports paging from
the network or you can combine 

03:46:18.607 --> 03:46:21.082
both database and the network 
for the best user experience.

03:46:24.779 --> 03:46:27.212
To learn more about it, please 
join tomorrow at 2:30 in the 

03:46:27.213 --> 03:46:29.213
Paging session.
     All right.

03:46:32.665 --> 03:46:36.214
Now --
     &gt;&gt; LUKAS BERGSTROM:  

03:46:36.215 --> 03:46:40.519
Possibly some of the expense of 
what Fu is gone new but when you

03:46:40.520 --> 03:46:42.358
think about sort of core 
problems that almost every app 

03:46:42.359 --> 03:46:46.434
has to deal with, in-app 
navigation has to be close to 

03:46:46.435 --> 03:46:48.874
the top of the list there.
     Right now the framework 

03:46:48.875 --> 03:46:50.875
doesn't 

03:46:52.336 --> 03:46:54.773
really offer anything for you to
do -- anything for you to use 

03:46:54.774 --> 03:46:56.774
there other than 

03:46:58.457 --> 03:46:59.671
start activity, which for 
various reasons is not the best 

03:46:59.672 --> 03:47:01.719
option.
     So that means that for 

03:47:01.720 --> 03:47:04.972
navigation there are a bunch of 
things that you have to figure 

03:47:04.973 --> 03:47:06.973
out on your own, and that 

03:47:09.152 --> 03:47:11.152
ranges from executing a fragment
transaction without  throwing an

03:47:12.617 --> 03:47:14.617
exception, hopefully, passing 
arguments 

03:47:16.507 --> 03:47:18.528
from place to place, possibly 
even with type safety if you can

03:47:18.529 --> 03:47:21.588
figure that out.  Testing the 
navigation is working and that 

03:47:21.589 --> 03:47:23.589
the right things are happening 
when 

03:47:25.691 --> 03:47:27.940
you navigate from place to 
place, making sure the up and 

03:47:27.941 --> 03:47:29.941
back buttons work correctly and 
take the user where 

03:47:33.019 --> 03:47:34.451
they're supposed to go, mapping 
deep links to destinations in 

03:47:34.452 --> 03:47:38.970
your app and having that work, 
and by the time you've solved 

03:47:38.971 --> 03:47:41.207
all of these problems, you've 
typically gone one of two 

03:47:41.208 --> 03:47:45.768
directions, you've either 
written 60% of a navigation 

03:47:45.769 --> 03:47:47.769
framework just for your app 

03:47:49.834 --> 03:47:51.669
or you've got a lot of 
errorprone boilerplate and so 

03:47:51.670 --> 03:47:53.670
everywhere navigation needs to 
happen you have a bunch of 

03:47:54.756 --> 03:47:56.593
parallel lines of code that need
to be changed, and any time the 

03:47:56.594 --> 03:48:01.093
navigational structure or the 
app changes, and this is all 

03:48:01.094 --> 03:48:03.364
pretty brittle and can end up 
being a headache.

03:48:06.822 --> 03:48:09.472
Individually these problems are 
pretty tractable but when you 

03:48:09.473 --> 03:48:15.198
compose them into a realworld 
example, so say I have a item 

03:48:15.199 --> 03:48:17.055
screen in my app, maybe a 
product screen, and that screen 

03:48:17.056 --> 03:48:19.056
is 

03:48:21.345 --> 03:48:23.603
accessible via Deeplink, but 
actually there are other pages 

03:48:23.604 --> 03:48:27.303
that, you know, if the user had 
navigated here by opening the 

03:48:27.304 --> 03:48:29.304
app from the home screen, they 
would 

03:48:30.557 --> 03:48:33.006
have come via the home screen, 
the category screen, and I want 

03:48:33.007 --> 03:48:39.509
the up but the button to take 
them through the screens rather 

03:48:39.510 --> 03:48:41.752
than exiting the app, right.  
That means if somebody  

03:48:41.753 --> 03:48:45.426
deeplinks into the app, I need 
to synthesize these screens and 

03:48:45.427 --> 03:48:47.892
add them to the back stack but 
only on a deeplink, and talking 

03:48:47.893 --> 03:48:51.774
to a third party developer, he 
said, you know, it's when you're

03:48:51.775 --> 03:48:56.690
in the middle of writing code to
do this, you know, on any 

03:48:56.691 --> 03:48:58.691
deeplink into my app and 
synthesize 

03:49:00.169 --> 03:49:02.821
the back stack correctly, you 
start to feel maybe this is a 

03:49:02.822 --> 03:49:05.055
failure of the framework, so 
that's why we're really 

03:49:08.313 --> 03:49:10.313
happy to be launching Navigation
which 

03:49:12.805 --> 03:49:14.027
is a, both a runtime component 
that performs navigation for you

03:49:14.028 --> 03:49:16.028
and a visual 

03:49:18.112 --> 03:49:20.162
tool that works with XML to 
define the navigational 

03:49:20.163 --> 03:49:22.163
structure of your app and then, 
you know, allows you to just 

03:49:24.013 --> 03:49:26.463
navigate at  runtime with a 
single navigate call.

03:49:28.509 --> 03:49:30.761
And so the kinds of things that 
you're going to get for free, 

03:49:30.762 --> 03:49:35.087
right, that you simply need to 
define an XML and then the 

03:49:35.088 --> 03:49:37.088
navigation framework will 

03:49:39.820 --> 03:49:41.820
handle it runtime for you, are 

03:49:43.282 --> 03:49:45.098
animations, passing arguments in
a type safe way from place to 

03:49:45.099 --> 03:49:47.099
place, making 

03:49:49.831 --> 03:49:51.253
sure that up and back work 
correctly, and mapping deep 

03:49:51.254 --> 03:49:56.170
links to various screens in your
app.  And last but not least, no

03:49:56.171 --> 03:49:59.451
more fragment transaction ever.
     (Applause).

03:50:08.008 --> 03:50:10.008
So I'll show a couple of demos 
of this in action.

03:50:11.909 --> 03:50:14.568
The first one is just to kind of
give you an idea of what this 

03:50:14.569 --> 03:50:19.647
all is, so we're looking at a 
set of fragment destinations in 

03:50:19.648 --> 03:50:22.564
my app, and I'm adding a new 
one, and now I'm creating an 

03:50:22.565 --> 03:50:26.836
action and this action is the 
thing that I'm actually going to

03:50:26.837 --> 03:50:28.837
call at runtime to go 

03:50:29.921 --> 03:50:31.343
from place to place.
     You can see that there are 

03:50:31.344 --> 03:50:35.837
a bunch of other options that 
we'll get into more in the 

03:50:35.838 --> 03:50:37.261
navigation talk, but the one 
thing I do quantity to show you 

03:50:37.262 --> 03:50:39.262
in more 

03:50:40.605 --> 03:50:44.467
detail right now is the example 
we went through before.  So this

03:50:44.468 --> 03:50:46.916
is a simplified version of that 
where there isn't a category 

03:50:48.335 --> 03:50:50.335
screen, we just have the home 
screen and 

03:50:52.259 --> 03:50:54.259
then the item screen, but I'm 
going to 

03:50:56.741 --> 03:50:58.769
right now configure this to both
have a deep link pointing at the

03:50:58.770 --> 03:51:02.458
item screen and make sure that 
if somebody deep links into the 

03:51:02.459 --> 03:51:04.459
app that they go to the 

03:51:06.109 --> 03:51:08.964
home screen first when they hit 
Up or Back rather than just 

03:51:08.965 --> 03:51:11.194
exiting the app right away.
     So first I'm just going to 

03:51:14.674 --> 03:51:16.879
configure a deep link on this 
screen, and the curly brackets 

03:51:16.880 --> 03:51:18.880
that I'm going to 

03:51:19.948 --> 03:51:21.978
put around Item ID indicate that
I want to extract a variable 

03:51:21.979 --> 03:51:25.671
there and pass it as an argument
into the item screen.  Okay.  

03:51:25.672 --> 03:51:27.736
Now that's ready to go.  If I 
compile and run my  app, that 

03:51:29.367 --> 03:51:31.367
will just work and navigate to 
the right destination.

03:51:32.875 --> 03:51:34.920
Now I just set the home screen 
to the start destination, and 

03:51:34.921 --> 03:51:40.229
that means that it's the 
hierarchical parent of all the 

03:51:40.230 --> 03:51:42.292
other screens in the graph, so 
when someone deep links into the

03:51:42.293 --> 03:51:44.952
item screen and then hits Up, 
they're going to go 

03:51:48.449 --> 03:51:50.444
directly to that home screen, so
now I've just solved in 30 

03:51:50.445 --> 03:51:52.709
seconds what would have been a 
really terrible and 

03:51:55.773 --> 03:51:58.631
time consuming task in Java or 
Kotlin back in the old world.

03:52:03.448 --> 03:52:05.448
So now I'm going to pass it 
eefer

03:52:10.651 --> 03:52:11.465
off to Yigit to talk about Work 
Manager.

03:52:11.466 --> 03:52:13.466
&gt;&gt; YIGIT BOYAR:  After using 
demos 

03:52:14.936 --> 03:52:17.605
for the past couple weeks it 
feels like magic, I hope you all

03:52:17.606 --> 03:52:19.606
like it.

03:52:20.846 --> 03:52:22.846
Work Manager is our example of 
deferrable guaranteed execution.

03:52:23.294 --> 03:52:25.312
Whether a do I mean by this?  
You're out of executions on 

03:52:25.313 --> 03:52:27.560
Android that you really, really 
want to do if user does 

03:52:27.561 --> 03:52:32.233
something.  If user tries to 
send a tweet, you want to send 

03:52:32.234 --> 03:52:34.458
it now, but if there is no 
network connection you want to 

03:52:34.459 --> 03:52:38.368
send it as soon as device is 
connected to the Internet.

03:52:40.634 --> 03:52:42.883
There are things like uploading 
logs you may want to do if the 

03:52:42.884 --> 03:52:46.748
device is charging or you may 
want to periodically sync your 

03:52:46.749 --> 03:52:49.213
data with your backup.  Now, we 
know this is not a new problem 

03:52:49.820 --> 03:52:51.856
on Android.  We had some  
solutions for this.

03:52:56.780 --> 03:52:58.780
We have introduced Job Scheduler
in  

03:53:01.107 --> 03:53:02.962
Lollipop and the functionality 
into devices that has Google  

03:53:02.963 --> 03:53:04.963
Play Services 

03:53:06.448 --> 03:53:09.132
and we also have manager for 
exact timing.  And now each of 

03:53:09.133 --> 03:53:11.133
these has different behaviors 
and different APIs, it becomes 

03:53:12.599 --> 03:53:15.249
very hard to implement.  Hence 
we have built Work Manager that 

03:53:18.727 --> 03:53:20.727
sits on top of them and provides
them 

03:53:21.818 --> 03:53:25.279
much cleaner API with new 
functionalities.  Work  Manager 

03:53:25.280 --> 03:53:27.944
has two simple concepts, you 
have the workers that execute 

03:53:27.945 --> 03:53:29.945
these 

03:53:31.839 --> 03:53:34.270
actions and you have the work 
requests which trigger these 

03:53:34.271 --> 03:53:37.328
workers.
     Now, if you want to look at

03:53:37.329 --> 03:53:39.569
the sample worker, this is 
basically all you do.

03:53:43.267 --> 03:53:44.688
Your worker clause, you 
implement one function that says

03:53:44.689 --> 03:53:47.335
do the work, and that function 
just needs to return us what 

03:53:49.770 --> 03:53:51.666
happened as a result of that 
work, so you can do whatever you

03:53:51.667 --> 03:53:53.667
do and you return the result.

03:53:55.944 --> 03:53:56.743
There is no services, no 
intents, no bundles, nothing 

03:53:56.744 --> 03:53:59.397
like that.
     Once we have the worker, we

03:53:59.398 --> 03:54:01.398
need to 

03:54:02.864 --> 03:54:05.704
create a work request so you can
use this one-time work builder 

03:54:05.705 --> 03:54:09.587
or there is a periodic version 
of this one and you can specify 

03:54:09.588 --> 03:54:11.588
the worker clause.

03:54:13.810 --> 03:54:16.932
But now you can also 
constraints.  You can tell it if

03:54:16.933 --> 03:54:18.933
there is network 

03:54:20.223 --> 03:54:22.223
connection, if the device is 
charnging, 

03:54:23.487 --> 03:54:26.350
or back off criteria, so if the 
work is failing, how should we 

03:54:26.351 --> 03:54:28.351
retry it, you can also pass 
input parameters to these 

03:54:28.382 --> 03:54:30.405
workers.  Once you build that 
work request, you 

03:54:36.529 --> 03:54:38.529
can get an instance of work 
manager and 

03:54:39.582 --> 03:54:40.808
enque it and now work manager 
will take care of executing it.

03:54:40.809 --> 03:54:42.809
     One of the important 
distinctions 

03:54:45.336 --> 03:54:46.949
of Work Manager is it has input 
and output semantics so the 

03:54:46.950 --> 03:54:52.250
workers can receive input but 
they can also output some data. 

03:54:52.251 --> 03:54:54.279
You can obvious this data 
through Work Manager, but it's 

03:54:54.280 --> 03:54:56.959
actually very useful to train 
your workers.

03:55:00.400 --> 03:55:02.703
So imagine you have an 
application where a user picks 

03:55:02.704 --> 03:55:05.061
an image from their device and 
you want to route some image 

03:55:06.481 --> 03:55:08.940
processing on that picture, and 
then once it's done you want to 

03:55:08.941 --> 03:55:12.259
upload it to your server.  Now, 
these are two different units of

03:55:12.679 --> 03:55:16.353
work.  Like you can process the 
image, maybe you want to do it 

03:55:16.354 --> 03:55:18.394
when the device is idol or you 
can do it any time, but to 

03:55:20.444 --> 03:55:23.133
upload it to server you need 
Internet connection, but you 

03:55:23.134 --> 03:55:25.134
don't want to wait the  
processing for the Internet 

03:55:26.178 --> 03:55:28.178
connection because it doesn't 
need it.

03:55:29.431 --> 03:55:33.089
This is super easy to implement 
in Work Manager.  So have two 

03:55:33.090 --> 03:55:35.129
different workers, they'll have 
single functionality, one of 

03:55:35.130 --> 03:55:39.864
them does the image processing 
and the other one does the 

03:55:39.865 --> 03:55:44.795
upload to server.  Okay, the 
helper function that receives an

03:55:44.796 --> 03:55:46.672
image file and creates the 
process image work request, 

03:55:46.673 --> 03:55:51.361
prepares the input, uses the 
same builder to produce the 

03:55:51.362 --> 03:55:53.362
request.

03:55:54.447 --> 03:55:56.056
Now we get that and we want our 
network upload to wait for the 

03:55:56.057 --> 03:55:58.057
Internet 

03:56:01.102 --> 03:56:03.409
connection, so we set a con 
constraint, and we say wait for 

03:56:04.710 --> 03:56:06.344
Internet connection before 
trying to run this work request,

03:56:06.345 --> 03:56:08.345
and then create the 

03:56:10.603 --> 03:56:12.330
upload image work using that  
constraint.

03:56:12.331 --> 03:56:14.359
Once we have them you can tell 
work manager and say okay, begin

03:56:14.360 --> 03:56:19.446
with the process image work, and
once you're done then run the 

03:56:19.447 --> 03:56:21.447
upload to server work, and 

03:56:23.144 --> 03:56:25.235
in you enqueue both of these as 
a automatic operation to the 

03:56:25.236 --> 03:56:28.880
Work Manager.  And your device 
start and anything can happen in

03:56:28.881 --> 03:56:30.881
between, and we will take care 
of running the two.

03:56:33.635 --> 03:56:35.311
You can also use this API 
extensively and run image 

03:56:35.312 --> 03:56:39.582
processing in parallel the same 
way, so if user picks multiple 

03:56:39.583 --> 03:56:41.612
photos and you want to process 
all of them but upload it to 

03:56:41.613 --> 03:56:45.290
server while some of them are 
done, can you easily do that 

03:56:45.291 --> 03:56:47.291
with Work Manager.

03:56:49.364 --> 03:56:50.984
We'll just use the save 
function, create three work 

03:56:50.985 --> 03:56:55.872
requests for each of the images 
the user picked, we create the 

03:56:55.873 --> 03:56:57.873
upload work image in the same 
way we 

03:56:58.955 --> 03:57:01.803
did before, and now we say okay,
begin with all of these three 

03:57:01.804 --> 03:57:04.668
work items and once all of them 
are done then upload 

03:57:09.143 --> 03:57:10.368
work and then you enqueue that 
as automatic operation and that 

03:57:10.369 --> 03:57:13.622
takes care of running it.
     Another important future of

03:57:13.623 --> 03:57:15.623
Work 

03:57:18.503 --> 03:57:21.176
Manager is it's not just for job
scheduler, (?), it's executed 

03:57:21.177 --> 03:57:24.460
itself.  So this is why 
opportunistic execution is 

03:57:24.461 --> 03:57:26.461
important.

03:57:28.570 --> 03:57:31.231
So if you have an application 
the user can send an email and 

03:57:31.232 --> 03:57:33.232
they hit a send 

03:57:34.698 --> 03:57:36.316
button, you send the job info to
the job scheduler or Firebase 

03:57:36.317 --> 03:57:38.592
and it will eventually call you 
to execute it back.

03:57:40.616 --> 03:57:45.717
The problem here is that I don't
know how long it will take.  

03:57:45.718 --> 03:57:47.746
Even if your device currently 
has network connection it may 

03:57:47.747 --> 03:57:50.807
take only a couple of minutes 
for job scheduler to call you 

03:57:50.808 --> 03:57:55.314
back and you have no control 
over it, you just don't know.  

03:57:55.315 --> 03:57:57.781
And it results in a bad user 
experience to work around that, 

03:57:57.782 --> 03:58:02.077
and what you usually do is you 
also have your own thread pool 

03:58:02.078 --> 03:58:04.127
whenever user hits send, you try
to run the same thing there as 

03:58:04.128 --> 03:58:09.029
well, and you take care of the 
duplicating when the job 

03:58:09.030 --> 03:58:11.525
scheduling calls you back.
     If you are using Work 

03:58:11.526 --> 03:58:14.891
Manager you don't need to think 
about it.  Because when you send

03:58:14.892 --> 03:58:20.114
the work request for the  Work 
Manager it puts it into its own 

03:58:20.115 --> 03:58:24.655
database.  It tells job 
scheduler or whichever scheduler

03:58:24.656 --> 03:58:26.656
it has on the device, okay, I 
need to be invoked when these 

03:58:28.606 --> 03:58:30.606
constraints are met, but it also
checks 

03:58:31.977 --> 03:58:33.977
those constraints itself.

03:58:37.148 --> 03:58:40.848
If they are ready it will 
instantly execute the job.  

03:58:40.849 --> 03:58:43.145
Laitser on if job sceld iewler 
asks to execute, Work Manager 

03:58:43.146 --> 03:58:46.082
knows whether it executed or not
and handles the request 

03:58:46.282 --> 03:58:51.899
properly.  To learn more about 
Work Manager please join us 

03:58:51.900 --> 03:58:54.400
today at 5:30 in the  Work 
Manager session.

03:58:54.606 --> 03:58:59.538
&gt;&gt; LUKAS BERGSTROM:  All right. 
What's next?  Okay.  So I think 

03:58:59.539 --> 03:59:03.453
it's been a pretty great year in
Android App  Development.  

03:59:03.454 --> 03:59:05.454
Hopefully you agree.  We 
launched a set of great new 

03:59:06.754 --> 03:59:08.202
components last year and we kept
working on those and iterating 

03:59:08.203 --> 03:59:10.871
on those.  We've launched three 
new major 

03:59:14.275 --> 03:59:15.715
components, Work Manager, 
Navigation, and Paging since  

03:59:15.716 --> 03:59:21.225
then.  So does that mean we're 
done?  Obviously, not.  We have 

03:59:21.226 --> 03:59:23.727
a lot more to do an the first 
thing we want to do is make 

03:59:23.728 --> 03:59:28.315
Architecture Components the 
default way that people build 

03:59:28.316 --> 03:59:30.316
Android apps and that doesn't 
mean 

03:59:33.427 --> 03:59:34.897
that it's going to be required, 
by but it does mean that we want

03:59:34.898 --> 03:59:39.741
to make sure that as many people
as possible get Architecture 

03:59:39.742 --> 03:59:41.491
Components regardless of how 
they get into Android 

03:59:41.492 --> 03:59:44.811
development, so that means not 
only are we going to be building

03:59:44.812 --> 03:59:46.812
more tools like the 

03:59:47.918 --> 03:59:50.633
Navigation Editor in Android 
Studio that are sort of 

03:59:50.634 --> 03:59:52.634
Architecture Components aware, 
but we'll also be adding more 

03:59:57.510 --> 03:59:59.241
templates that include things 
like ViewModels so that people 

03:59:59.242 --> 04:00:01.242
starting a new 

04:00:03.431 --> 04:00:04.918
project have the easiest 
possible  onramp into Android 

04:00:04.919 --> 04:00:07.278
development.
     In terms of libraries, not 

04:00:07.279 --> 04:00:10.858
only are we going to be building
more architecture components and

04:00:10.859 --> 04:00:15.020
not only are we going to be 
building in more of the kind of 

04:00:15.021 --> 04:00:17.722
core architecture components 
goodness like lifecycle 

04:00:17.723 --> 04:00:19.723
awareness into 

04:00:21.596 --> 04:00:23.086
Jetpack, but we want to look at 
other Google APIs as well and 

04:00:23.087 --> 04:00:25.087
see, you know, 

04:00:28.816 --> 04:00:30.816
how we can make those sort of a

04:00:32.278 --> 04:00:34.579
architecture components a ware 
where if you call another Google

04:00:34.580 --> 04:00:36.662
API that's asynchronous it 
already has that built  

04:00:40.231 --> 04:00:41.251
in, you're getting architecture 
components whether you know 

04:00:41.252 --> 04:00:43.136
you're using it or not.
     Finally, we've heard from 

04:00:43.137 --> 04:00:46.740
everybody that you want us to 
speak with a single voice, you 

04:00:46.741 --> 04:00:47.957
want us to give clear and 
consistent guidance, so that 

04:00:47.958 --> 04:00:53.309
means that in terms of 
education, and that means not 

04:00:53.310 --> 04:00:55.310
just documentation, but it also 

04:00:58.277 --> 04:01:00.277
means sample apps, Codelabs, 
that all of 

04:01:02.925 --> 04:01:04.925
this stuff is going to be 
refract

04:01:06.747 --> 04:01:08.407
refactored to built on a tech 
xur components so whether you 

04:01:08.408 --> 04:01:10.647
start with guide app 
architecture or download a 

04:01:12.746 --> 04:01:13.985
simple media player app and 
start customizing it, that you 

04:01:13.986 --> 04:01:15.986
kind of 

04:01:17.087 --> 04:01:18.552
regardless of when you're onramp
in Android  development is, that

04:01:18.553 --> 04:01:20.553
we get to you the best possible 
place.

04:01:21.687 --> 04:01:24.413
We know that we still have some 
areas left to address in the 

04:01:24.414 --> 04:01:26.414
core and 

04:01:28.821 --> 04:01:30.495
you can see some of those here, 
so this is just to say we're 

04:01:30.496 --> 04:01:34.883
definitely not going to stop 
investing in the original set of

04:01:34.884 --> 04:01:37.165
architecture components, and 
there is some not just 

04:01:37.166 --> 04:01:39.166
problem-solving here but some 
exciting stuff that we can 

04:01:44.103 --> 04:01:46.103
do around how to make 
architecture 

04:01:48.048 --> 04:01:50.309
components as fun for people to 
use for people using Kotlin.  

04:01:50.310 --> 04:01:52.399
There is a lot to be done and 
still I think the core set of 

04:01:52.400 --> 04:01:56.347
app architecture and lifecycle 
problem areas, so we'll keep 

04:01:56.348 --> 04:01:59.239
working there.
     But beyond that I think 

04:01:59.240 --> 04:02:01.240
you'll see something interesting
about your 

04:02:05.049 --> 04:02:06.068
trajectory if we look at all the
components we've launched to 

04:02:06.069 --> 04:02:10.799
date.  Last year this kind of 
set of architecture components 

04:02:10.800 --> 04:02:14.078
was, these are relatively small 
pieces, relatively small APIs 

04:02:14.079 --> 04:02:16.330
that are designed to be used in 
a lot of different places in 

04:02:16.331 --> 04:02:18.331
your 

04:02:20.558 --> 04:02:22.558
app, and then if you look at 
room 

04:02:23.796 --> 04:02:25.666
navigation, work manager, these 
are much larger and richer APIs 

04:02:25.667 --> 04:02:27.667
but they're still 

04:02:29.614 --> 04:02:32.138
sort of relatively sort of 
self-contained.  They solve a 

04:02:32.139 --> 04:02:34.139
single problem and do it really 
well.

04:02:35.441 --> 04:02:37.341
Paging also solves a single 
problem and solves it well, but 

04:02:37.342 --> 04:02:39.615
in this case we took a very 
specific use case, right, so 

04:02:43.974 --> 04:02:45.418
lazy loading for recyclerview, 
and we're actually in this case 

04:02:45.419 --> 04:02:47.419
orchestrating multiple 
architecture components and 

04:02:49.983 --> 04:02:52.093
pieces of Jetpack to solve that 
problem, so Paging is a little 

04:02:52.094 --> 04:02:57.463
bit higher level, and it's not 
just sort of here is your object

04:02:57.464 --> 04:02:59.464
mapping layer, right, it 
actually 

04:03:00.571 --> 04:03:02.886
takes a very specific, I know I 
have or recycling view with more

04:03:02.887 --> 04:03:06.401
data that I can fit in memory, 
and it uses multiple pieces of 

04:03:06.402 --> 04:03:08.402
architecture components to make 
that as easy as possible.

04:03:10.849 --> 04:03:13.089
And we want to continue to, you 
know, build more stuff like that

04:03:13.090 --> 04:03:16.417
so not just -- we're not just 
going to keep investing in the 

04:03:16.418 --> 04:03:22.077
core areas of app architecture 
and lifecycle, but we want to 

04:03:22.078 --> 04:03:23.527
start solving higher-level 
problems and make more and more 

04:03:23.528 --> 04:03:28.000
as easy as possible.
     But I can't leave today 

04:03:28.001 --> 04:03:31.478
without thanking everybody that 
helped us get here.  The reason 

04:03:31.479 --> 04:03:33.479
that we were able to have a 

04:03:34.607 --> 04:03:36.474
really high quality bar for 
architecture components was 

04:03:36.475 --> 04:03:38.570
because a lot of people, many of
whom are here today, were 

04:03:41.092 --> 04:03:42.793
reallying generous with their 
time and that includes not just 

04:03:42.794 --> 04:03:45.479
filing issues on the issue 
tracker but also, you know, 

04:03:48.025 --> 04:03:50.025
testing pre-release components, 
having 

04:03:51.511 --> 04:03:54.423
one-on-one conversations with us
to tell us what your biggest 

04:03:54.424 --> 04:03:57.176
problem areas with Android app 
development were.  This has been

04:03:57.177 --> 04:03:59.177
critical to us in making 

04:04:00.271 --> 04:04:01.537
sure that we're kind of focusing
on the right problems and 

04:04:01.538 --> 04:04:03.538
delivering solutions that are 
going to work for you, so I 

04:04:04.890 --> 04:04:07.354
really have to thank everybody 
in the community that's been so 

04:04:07.355 --> 04:04:08.796
helpful.
     &gt;&gt; YIGIT BOYAR:  Thank you.

04:04:08.797 --> 04:04:10.797
     (Applause).

04:04:15.813 --> 04:04:18.679
     &gt;&gt; LUKAS BERGSTROM:  And 
there is a lot more.  We had to 

04:04:18.680 --> 04:04:20.680
fly over a lot of don't today, 
but you'll be able to go into a 

04:04:21.948 --> 04:04:24.711
lot more depth in the talks on 
Navigation, Work  Manager, and 

04:04:24.712 --> 04:04:28.457
Paging.  So thanks a lot, and I 
hope to see you there.

04:04:29.065 --> 04:04:31.065
&gt;&gt; YIGIT BOYAR:  Thank you.
     (Applause).

04:06:51.419 --> 04:06:53.419
May 9, 2018

04:06:54.890 --> 04:06:57.889
12:30 p.m. PT

04:07:06.046 --> 04:07:08.163
TensorFlowT

04:07:13.417 --> 04:07:15.417
TensorFlow for JavaScript

04:12:40.790 --> 04:12:42.790
lts

04:25:23.627 --> 04:25:27.063
     &gt;&gt; Welcome.  Please fill in
the seats near the front of the 

04:25:27.064 --> 04:25:29.064
room.  Thank you.

04:28:29.739 --> 04:28:33.253
&gt;&gt; At this time please find your
seat.  Our session will begin 

04:28:33.254 --> 04:28:35.254
soon.

04:30:42.974 --> 04:30:45.967
     (Applause)

04:30:49.488 --> 04:30:51.924
     &gt;&gt; Hi, everyone.  Thanks 
for coming today to see our 

04:30:52.549 --> 04:30:56.776
talk.  My name is Daniel
     &gt;&gt; NIKHIL THORAT:  My name 

04:30:56.777 --> 04:31:00.915
is Nikhil,.
     &gt;&gt; NICK KREEGER:  And I'm 

04:31:00.916 --> 04:31:01.115
Nick.
     &gt;&gt; DANIEL SMILKOV:  Today 

04:31:01.116 --> 04:31:04.777
we're very happy to talk about 
JavaScript.  If you're in the 

04:31:04.778 --> 04:31:07.833
world of Machine Learning, doing
a training model or anything 

04:31:07.834 --> 04:31:09.834
about Machine Learning, you're 

04:31:12.872 --> 04:31:14.872
most certainly dealing with

04:31:17.324 --> 04:31:19.324
piet

04:31:23.351 --> 04:31:26.622
Python, it's been one of the 
mainstream for the last decade. 

04:31:26.623 --> 04:31:29.697
It has a lot of tools.  It 
doesn't have to be that way.  

04:31:29.698 --> 04:31:32.582
Today we're here to convince you
that the browser and JavaScript 

04:31:32.583 --> 04:31:37.469
have a lot to offer to the world
of Machine Learning, and 

04:31:37.470 --> 04:31:40.723
TensorFlow Playground is a great
example of that.  How many 

04:31:40.724 --> 04:31:44.639
people here have seen this 
visualization?  Quite a few.  

04:31:44.640 --> 04:31:47.078
I'm glad.
     For those of you that 

04:31:47.079 --> 04:31:49.079
haven't seen 

04:31:56.001 --> 04:31:58.728
it, TensorFlow  Playground is 
in-browser neural network 

04:31:58.729 --> 04:32:00.729
visualization and shows 

04:32:01.809 --> 04:32:03.237
you what is happening inside the
neuralnetwork as the network is 

04:32:03.238 --> 04:32:07.329
training.  When we released 
this, this was kind of a fun 

04:32:07.330 --> 04:32:09.330
small project, and when we 

04:32:10.809 --> 04:32:12.436
released this it had tremendous 
success, especially in the 

04:32:12.437 --> 04:32:14.437
educational domain, and even 
today we get emails from high 

04:32:16.102 --> 04:32:18.133
schools and universities around 
the world thanking us for 

04:32:18.134 --> 04:32:21.606
building this and they're using 
it to teach students, beginners 

04:32:21.607 --> 04:32:23.607
about Machine Learning.

04:32:24.663 --> 04:32:26.663
When we saw the success of 
TensorFlow Playground we started

04:32:28.364 --> 04:32:30.390
wondering, why is it so 
successful?  We think the 

04:32:30.391 --> 04:32:34.876
browser and JavaScript have a 
lot to do with it.  For one 

04:32:34.877 --> 04:32:36.877
thing that's very special 

04:32:37.928 --> 04:32:39.928
about the browser, it has no 
drivers and no installations.

04:32:42.153 --> 04:32:45.060
You can share your app with 
anyone and all they have to do 

04:32:45.061 --> 04:32:47.270
is click on a link and see your 
application.

04:32:48.490 --> 04:32:49.698
Another important thing about 
the browser is it's highly 

04:32:49.699 --> 04:32:52.164
interactive.  In the playground 
app, we have all 

04:32:56.030 --> 04:32:58.062
these controls, drop-down 
controls that you can change and

04:32:58.063 --> 04:33:00.063
quickly run different 
experiments.

04:33:00.717 --> 04:33:03.352
Another nice thing about the 
browser is it runs on laptops, 

04:33:03.353 --> 04:33:08.260
it runs on mobile devices, and 
these devices have sensors like 

04:33:08.261 --> 04:33:10.261
the microphone and the 

04:33:12.585 --> 04:33:14.407
camera and the accelorometer and
they're all behind standardized 

04:33:14.408 --> 04:33:19.110
web APIs that you can easily 
access in your web app.  We 

04:33:19.111 --> 04:33:21.551
didn't take advantage of this in
the playground, but we'll show 

04:33:21.552 --> 04:33:24.021
you some demos later.
     Most importantly, when 

04:33:24.022 --> 04:33:26.022
you're 

04:33:27.686 --> 04:33:29.686
building web apps, these apps 
run client 

04:33:31.332 --> 04:33:32.772
side which makes it easy to have
the data stay on the client and 

04:33:32.773 --> 04:33:36.671
never have to send it back to a 
server.  You can do processing 

04:33:36.672 --> 04:33:40.385
on device, and this is important
for privacy.

04:33:44.048 --> 04:33:45.681
Now to come back to the play 
playground example, the library 

04:33:45.682 --> 04:33:47.682
that 

04:33:50.558 --> 04:33:53.112
powers the visualization is not 
TensorFlow.

04:33:57.339 --> 04:33:59.339
It's a small necker

04:34:00.998 --> 04:34:02.998
necker

04:34:06.635 --> 04:34:08.466
small neuralnetwork and it 
became clear when this was so 

04:34:08.467 --> 04:34:10.467
successful and popular that we 
should go on and build such a 

04:34:14.063 --> 04:34:16.764
library, and we went and built 
deeplearn.js that was released 

04:34:16.765 --> 04:34:18.765
in August of 2017.  We figured 
out a way how to make it 

04:34:22.438 --> 04:34:24.438
fast and scale by utilizing the 
GPU of 

04:34:25.679 --> 04:34:27.506
laptops and cell phones through 
WebGL.  For those of you that 

04:34:27.507 --> 04:34:29.507
are not familiar, WebGL is a 
technology 

04:34:31.999 --> 04:34:34.840
originally meant for  rendering 
3-D graphics, and the library 

04:34:34.841 --> 04:34:38.294
that we built  allows for both 
inference and training entirely 

04:34:38.295 --> 04:34:41.187
in the browser.
     When we released deeplearn.

04:34:43.214 --> 04:34:45.653
js we had an incredible 
momentum.  The community went 

04:34:45.654 --> 04:34:47.654
instantly with it 

04:34:50.343 --> 04:34:51.367
and took pre-trained models from
Python and put it in the 

04:34:51.368 --> 04:34:55.929
browser.  One example I want to 
show you of that is the style 

04:34:55.930 --> 04:35:00.197
transfer demo.  Someone went and
took the pre-trained model and 

04:35:00.198 --> 04:35:02.247
this demo has a image, a source 
image on the left and an artist 

04:35:04.506 --> 04:35:06.117
on the right, and then it can 
mash them together and they made

04:35:06.118 --> 04:35:08.118
this in a creative, interesting 
application.

04:35:10.817 --> 04:35:12.817
Another demo is people will take

04:35:13.926 --> 04:35:16.175
models that read a lot of text 
and then they can generate new 

04:35:16.176 --> 04:35:20.663
sentences and then they port it 
in the browser and explore the 

04:35:20.664 --> 04:35:23.302
novel interface, how you can 
explore all the different 

04:35:23.303 --> 04:35:26.372
endings of a sentence.
     In the educational domain, 

04:35:26.373 --> 04:35:28.373
people 

04:35:31.428 --> 04:35:33.596
took the standard convolutional 
neuralnets and built a fun 

04:35:33.597 --> 04:35:38.301
little game where you can train 
your own image recognition model

04:35:38.302 --> 04:35:41.161
just by using the webcam and 
this was very popular.

04:35:44.042 --> 04:35:46.505
And lastly, researchers took 
another example, they took a 

04:35:46.506 --> 04:35:48.506
font 

04:35:49.613 --> 04:35:51.242
generation model that can 
generate new fonts, previously 

04:35:51.243 --> 04:35:53.478
was trained on a lot of font 
styles, and then they built at 

04:35:55.096 --> 04:35:57.353
that novel interface in the 
browser, highly interactive, 

04:35:57.354 --> 04:35:59.381
where you can explore different 
types of  fonts.

04:36:01.002 --> 04:36:03.650
Now building on that incredible 
momentum we have with deeplearn.

04:36:06.496 --> 04:36:08.964
js about a month ago at the 
TensorFlow dev  summit, we 

04:36:08.965 --> 04:36:10.965
announced we're joining 

04:36:12.455 --> 04:36:14.903
the TensorFlow family and with 
that we introduced a new 

04:36:14.904 --> 04:36:16.904
ecosystem of tools and libraries
aren't JavaScript and Machine 

04:36:18.391 --> 04:36:21.085
Learning called TensorFlow.js.
     Now before we dive into the

04:36:23.330 --> 04:36:25.361
detailts, I want to go over 
three main use cases of what you

04:36:25.362 --> 04:36:27.847
can do with TensorFlow.js today.
You can write models directly in

04:36:27.848 --> 04:36:30.088
the browser.  We have sets of 
APIs for that.

04:36:33.823 --> 04:36:36.733
You can also take pretrained 
models that were trained in 

04:36:36.734 --> 04:36:38.781
Python or other languages and 
then port them for inference in 

04:36:38.782 --> 04:36:41.012
the browser.  You can also take 
these existing 

04:36:44.681 --> 04:36:47.369
pretrained models and retrain 
them, do transfer learning right

04:36:47.370 --> 04:36:49.370
there on device.

04:36:50.871 --> 04:36:53.305
To give you a schematic view of 
the library, we have the browser

04:36:53.306 --> 04:36:58.997
that does all the computation 
using WebGL.  TensorFlow.js has 

04:36:58.998 --> 04:37:01.457
two sets of APIs that sit on top
of this, a core API which gives 

04:37:01.458 --> 04:37:03.458
you a 

04:37:04.556 --> 04:37:06.556
low-level building blocks, 
linear 

04:37:07.642 --> 04:37:09.642
algebra operations like multiply
and 

04:37:10.726 --> 04:37:12.367
add, and on top of it we have 
layers API which gives you 

04:37:12.368 --> 04:37:14.368
high-level building 

04:37:15.847 --> 04:37:17.478
blocks and best practices to 
build neuralnets.

04:37:17.479 --> 04:37:19.739
And on top of that because there
are so many models written in 

04:37:19.740 --> 04:37:22.028
Python today, we offer tools to 
take an 

04:37:26.899 --> 04:37:28.899
existing model, a

04:37:30.863 --> 04:37:33.580
keras model and these tools will
convert that model to run in the

04:37:33.581 --> 04:37:37.856
browser.
     Now, to give you an example

04:37:37.857 --> 04:37:41.598
of our core API, I'm going to 
show you how we're going to go 

04:37:41.599 --> 04:37:44.479
over code that  tries to train a
model that fits a polynomial 

04:37:46.497 --> 04:37:48.143
curve and we have to learn the 
three coefficients, A, B, and C.

04:37:48.144 --> 04:37:51.420
     Now this example is pretty 
simple, but the code walks you 

04:37:51.421 --> 04:37:55.746
through all the steps of how you
would train such a model, and 

04:37:55.747 --> 04:37:57.774
these steps generalize across 
different models.

04:38:01.856 --> 04:38:06.151
So we import TensorFlow for 
TensorFlow/TensorFlow.js, and 

04:38:06.152 --> 04:38:08.152
for those of you not familiar 

04:38:11.591 --> 04:38:12.543
this is standard EF6 modern 
JavaScript.  We have our three 

04:38:12.544 --> 04:38:16.023
variables that we're trying to 
learn, A, B, and C.  We mark 

04:38:16.024 --> 04:38:18.024
them as variables which means 

04:38:19.483 --> 04:38:21.483
that the optimizer of the 
machine, it's 

04:38:23.337 --> 04:38:24.554
machinery that runs and trains 
our neuralnetwork can change the

04:38:24.555 --> 04:38:26.555
variables for us.

04:38:28.825 --> 04:38:30.874
We have our function, F of X, 
given some data it will compute 

04:38:30.875 --> 04:38:32.875
the output and 

04:38:34.151 --> 04:38:36.151
this is just a polynomial 
function, quadratic function.

04:38:41.771 --> 04:38:44.244
On top of the standard API like 
tf add and tf multiply.

04:38:47.537 --> 04:38:49.537
We have a chaining, and that's 
been 

04:38:50.622 --> 04:38:52.857
popular in the world, you can 
call these mathematical methods 

04:38:52.858 --> 04:38:55.522
on it itself and this reads 
better closer to how we read 

04:38:55.523 --> 04:38:59.233
math.
     That's our model.  To train

04:38:59.234 --> 04:39:00.659
it we need a last function and 
in this case we're just 

04:39:00.660 --> 04:39:02.660
measuring the distance between 
the prediction of 

04:39:05.556 --> 04:39:08.024
the model and the label, the 
ground truth data.  We need an 

04:39:08.025 --> 04:39:10.475
optimizer, and this is the 
machinery that can optimize and 

04:39:10.476 --> 04:39:12.476
find 

04:39:13.798 --> 04:39:15.034
those coefficients, we specify a
learning grade there, and for 

04:39:15.035 --> 04:39:17.035
some 

04:39:20.147 --> 04:39:22.147
number of  epochs passes over 
your data we call optimizer.

04:39:26.726 --> 04:39:27.953
minimize with our loss and f of 
X and Ys.

04:39:27.954 --> 04:39:29.954
So that's our model.

04:39:31.220 --> 04:39:32.671
Now, this is clearly notes how 
everyone writes Machine Learning

04:39:32.672 --> 04:39:36.331
models today.  Over the years we
have developed best practices 

04:39:36.332 --> 04:39:38.332
and high-level building blocks 

04:39:40.616 --> 04:39:43.057
and new APIs amerged like TF 
Layers and  Keras that makes it 

04:39:43.058 --> 04:39:45.335
much easier to write these 
models, and for that I want to 

04:39:48.183 --> 04:39:50.183
walk over our Layers API to show
you how easy it is.

04:39:52.711 --> 04:39:54.759
We're going to go through a 
simple neuralnetwork that sums 

04:39:54.760 --> 04:39:56.998
two numbers, but what's special 
about this network is 

04:40:01.128 --> 04:40:03.774
that the input comes as a string
character by character, so 09 + 

04:40:03.775 --> 04:40:05.775
10 is 

04:40:06.849 --> 04:40:08.686
the input to this network being 
fed as a string and the network 

04:40:08.687 --> 04:40:11.740
has an internal memory where it 
encodes this information, it has

04:40:11.741 --> 04:40:13.741
to save it, and then 

04:40:16.242 --> 04:40:18.892
on the other end the neural 
network has to output the sum, 

04:40:18.893 --> 04:40:20.893
100, again character by 
character.

04:40:21.753 --> 04:40:23.753
Now, you might wonder why go 

04:40:25.456 --> 04:40:27.508
through such a trouble to train 
this neural network like this, 

04:40:27.509 --> 04:40:30.562
but this example forms the basis
of modern machine translation 

04:40:30.563 --> 04:40:32.563
and that's why we're going over 
this.

04:40:34.657 --> 04:40:36.657
To show you the code, we import 
TensorFlow from TensorFlow.

04:40:39.965 --> 04:40:41.604
js and we have our model and we 
say  tf.sequential which means 

04:40:41.605 --> 04:40:45.273
it's just a linear stack of 
layers.  The first two layers 

04:40:45.274 --> 04:40:47.514
I'm not going to go into 
details, but those two are 

04:40:48.960 --> 04:40:50.960
building blocks that can take 
the 

04:40:52.244 --> 04:40:54.244
strings into a memory, into an 
internal presentation.

04:40:55.724 --> 04:40:57.980
And the last three layerses take
this internal presentation and 

04:40:57.981 --> 04:41:00.462
turn it into numbers, and that's
our model.

04:41:02.083 --> 04:41:04.083
To train it we need to compile 
it 

04:41:08.624 --> 04:41:10.624
with a loss and optimizer, and 
metric we 

04:41:11.702 --> 04:41:13.338
want to monitor we call accuracy
and we call model.fit with our 

04:41:13.339 --> 04:41:17.444
data.  One thing I want to point
out with model.fit, training can

04:41:17.445 --> 04:41:19.565
take for this example, it can 
take 30 or 40 seconds in the 

04:41:21.406 --> 04:41:23.453
browser, and while that's 
running we don't want to blog 

04:41:23.454 --> 04:41:26.745
the main UI thread.  We want our
app to be responsive, so this is

04:41:26.746 --> 04:41:28.746
why model.

04:41:31.023 --> 04:41:32.468
fit is an asynchronous call and 
we get a callback once it's done

04:41:32.469 --> 04:41:37.009
with the history object which 
has our accuracy as it evolved 

04:41:37.010 --> 04:41:39.010
over time.

04:41:40.734 --> 04:41:42.734
Now, I went through examples of 
how 

04:41:44.287 --> 04:41:46.091
you write these models in the 
browser, but there is also a lot

04:41:46.092 --> 04:41:48.092
of models that 

04:41:49.150 --> 04:41:51.150
have already been written in 
Python and 

04:41:53.035 --> 04:41:54.459
for that we have tools that 
allow you to import them 

04:41:54.460 --> 04:41:56.083
automatically.
     Before we dive into the 

04:41:56.084 --> 04:41:58.084
details, I 

04:41:59.354 --> 04:42:02.223
want to go through and show you 
a fun little game that our 

04:42:02.224 --> 04:42:04.224
friends at Google 

04:42:06.457 --> 04:42:07.743
brand studio built called emoji 
scavenger hunt and it takes 

04:42:07.744 --> 04:42:09.744
advantage of 

04:42:13.124 --> 04:42:14.954
a pretrained model convolutional
neural network that can detect 

04:42:14.955 --> 04:42:16.955
400 items.

04:42:18.014 --> 04:42:20.014
I'm going to walk over to a 
pixel 

04:42:21.015 --> 04:42:26.359
phone and open up a browser just
to show you the TensorFlow.js 

04:42:26.360 --> 04:42:28.184
can also run in a browser 
because we're using standard 

04:42:28.185 --> 04:42:30.185
WebGL.

04:42:33.535 --> 04:42:35.798
And I'm going to ask here, 
Nikhil on my right, to help me 

04:42:35.799 --> 04:42:40.548
out here because I'm going to 
need some help.  To give you 

04:42:40.549 --> 04:42:42.549
some little details about the 
game, it shows you an emoji, and

04:42:43.619 --> 04:42:45.649
then you have to go with your 
camera, run around your house 

04:42:45.650 --> 04:42:47.650
and find the real 

04:42:49.544 --> 04:42:51.544
version item of that emoji 
before time 

04:42:52.589 --> 04:42:54.238
runs out and there is a neural 
network that has to detect that.

04:42:54.239 --> 04:42:58.186
All right.  Shall we start?  Let
me see.  We're going to play it 

04:42:58.187 --> 04:43:02.065
here live.  All right.  We have 
to find a watch, 20 seconds.

04:43:03.716 --> 04:43:05.360
&gt;&gt; NIKHIL THORAT:  A watch.
     &gt;&gt; DANIEL SMILKOV:  That's 

04:43:05.361 --> 04:43:09.238
great.  Woo hoo!  All right.  
Let me see what's next.

04:43:12.928 --> 04:43:14.928
We need a shoe.
     &gt;&gt; NIKHIL THORAT:  Shoe.

04:43:15.412 --> 04:43:20.709
     &gt;&gt; DANIEL SMILKOV:  Thanks,
buddy.  Yay!  Let's see what the

04:43:20.710 --> 04:43:24.375
next item is.  Banana.  We have 
30 seconds to find a banana.

04:43:25.413 --> 04:43:27.849
&gt;&gt; NIKHIL THORAT:  Anyone have a
banana?  Anyone?  Oh, awesome.

04:43:31.120 --> 04:43:32.149
We got a banana over here.
     &gt;&gt; DANIEL SMILKOV:  Thanks,

04:43:32.150 --> 04:43:33.574
man.
     &gt;&gt; NIKHIL THORAT:  Here we 

04:43:33.575 --> 04:43:35.006
go.
     &gt;&gt; DANIEL SMILKOV:  All 

04:43:35.007 --> 04:43:37.007
right.  Our high score is going 
up.

04:43:39.507 --> 04:43:41.507
Let's see what our next item is.
Beer.

04:43:42.395 --> 04:43:44.395
(laughter).
     &gt;&gt; NIKHIL THORAT:  Beer?

04:43:46.318 --> 04:43:48.594
Daniel it's 12:30 in the middle 
of I/O, let's get back to the 

04:43:48.595 --> 04:43:51.128
talk man.
     &gt;&gt; DANIEL SMILKOV:  All 

04:43:48.595 --> 04:43:50.595
right.  (Laughing).

04:43:54.902 --> 04:43:56.974
     &gt;&gt; NIKHIL THORAT:  All 
right.  So let's talk a little 

04:43:56.975 --> 04:44:00.447
bit about how we actually built 
that game.  Let's switch back to

04:44:00.448 --> 04:44:02.448
the slides here.  Okay.

04:44:04.585 --> 04:44:06.585
So what we did was we trained a 
model 

04:44:08.248 --> 04:44:09.499
in Python to predict from images
400 different classes that would

04:44:09.500 --> 04:44:13.814
be good for an emoji scavenger 
hunt game.  These are things 

04:44:13.815 --> 04:44:16.467
like a banana, watch, and  shoe.
     The way we did this was we 

04:44:16.468 --> 04:44:20.762
took a pretrained model called 
MobileNet and if you don't know 

04:44:20.763 --> 04:44:22.809
what MobileNet is, it's a state 
of the art computer vision model

04:44:25.055 --> 04:44:26.273
that's designed for Edge 
devices, designed for mobile 

04:44:26.274 --> 04:44:28.137
phones.
     So what we did is took that

04:44:28.138 --> 04:44:32.812
model and we reused the features
that are learned there and we 

04:44:32.813 --> 04:44:36.326
either transfer learning task to
our 400 class classifier.

04:44:38.786 --> 04:44:41.698
So then once we do that we have 
an object detector, so this 

04:44:41.699 --> 04:44:45.997
object detector lives entirely 
in the Python world, so the next

04:44:45.998 --> 04:44:48.860
step of this process is to 
actually take that and convert 

04:44:48.861 --> 04:44:53.601
it into a format that will be 
able to ingest in the web and 

04:44:53.602 --> 04:44:55.162
then we'll skin the game and add
sound effects and that kind of 

04:44:55.163 --> 04:44:57.027
thing.
     So let's talk a little bit 

04:44:57.028 --> 04:45:00.559
about the details of actually 
going through that process.

04:45:04.878 --> 04:45:06.878
So in Python when we're actually

04:45:07.925 --> 04:45:10.014
checkpointing and train training
our model we have to train it to

04:45:10.015 --> 04:45:12.883
disk.  There is a couple ways to
do this, the common way with 

04:45:12.884 --> 04:45:15.322
TensorFlow is to use what's 
called a saved model.  Details 

04:45:15.323 --> 04:45:17.357
are not important for this talk 
here, but the idea here is that 

04:45:19.006 --> 04:45:21.006
there are files on disk that you
need to write.

04:45:22.872 --> 04:45:24.872
Daniel also mentioned that we 

04:45:27.159 --> 04:45:29.812
support importing from Keras, 
that's a high-level library that

04:45:29.813 --> 04:45:33.696
lives on top of TensorFlow and 
that gives you a sort of higher 

04:45:33.697 --> 04:45:36.401
level API to use these things.  
Details are unimportant but 

04:45:36.402 --> 04:45:39.042
there are also files on disk 
that it uses to checkpoint.

04:45:41.075 --> 04:45:43.129
All right, so we have a set of 
files and now next up is to 

04:45:43.130 --> 04:45:46.681
actually convert them to a 
format that we can ingest in a 

04:45:46.682 --> 04:45:48.682
web page.

04:45:50.779 --> 04:45:53.014
So we have released a tool on 
PIP called TensorFlow.js and 

04:45:53.015 --> 04:45:56.886
inside of that tool we have some
conversion scripts.  All you do 

04:45:56.887 --> 04:45:58.887
is run the script, you point it 
to those saved files that you 

04:46:02.205 --> 04:46:04.469
had on disk, and you point it to
an output directory and you will

04:46:04.470 --> 04:46:07.517
get a set of static build 
artifacts that we'll be able to 

04:46:07.518 --> 04:46:09.518
use on the  web.

04:46:10.775 --> 04:46:12.775
The same flow holds for Keras 

04:46:14.247 --> 04:46:16.247
models you point for the input H
file 

04:46:18.066 --> 04:46:21.185
and out pops a factory of static
build artifacts.  So you take 

04:46:21.186 --> 04:46:22.858
the static build artifacts and 
host them on the website, the 

04:46:22.859 --> 04:46:24.859
same 

04:46:27.547 --> 04:46:29.547
way you host TFGs or anything of
that sort.

04:46:30.409 --> 04:46:33.261
Once you do that we provide APIs
in TensorFlow.js to load the 

04:46:33.262 --> 04:46:35.262
static build artifacts, so it 
looks something like this.

04:46:39.193 --> 04:46:40.448
For TensorFlow Save Model we 
load the model up and get an 

04:46:40.449 --> 04:46:43.960
object back.  That model object 
can actually make predictions 

04:46:43.961 --> 04:46:46.395
with TensorFlow.js tensors right
in the  browser.

04:46:49.268 --> 04:46:51.506
The same flow holds for Keras 
models, we point to the static 

04:46:51.507 --> 04:46:53.817
build artifacts and we have a 
model that we can make 

04:46:53.818 --> 04:46:57.094
predictions on.  Okay.  So under
the covers there is actually a 

04:46:57.095 --> 04:47:01.176
lot going on.  When we convert 
these files to a format that we 

04:47:01.177 --> 04:47:03.839
can ingest in the web, we 
actually are  pruning nodes off 

04:47:03.840 --> 04:47:05.840
of that 

04:47:06.937 --> 04:47:08.609
graph that aren't needed to make
that prediction, and this makes 

04:47:08.610 --> 04:47:12.274
the network transfer much 
smaller and our predictions much

04:47:12.275 --> 04:47:14.275
faster.

04:47:17.983 --> 04:47:20.635
We're also taking those weights 
and sharding and  packing them 

04:47:20.636 --> 04:47:23.280
into 4 megabyte chunks and that 
means the next 

04:47:26.937 --> 04:47:29.007
time the browser loads the page 
it will be cached so it's super 

04:47:29.008 --> 04:47:31.880
snappy.
     We support also about 90 of

04:47:31.881 --> 04:47:36.178
the most commonly used 
TensorFlow ops today and are 

04:47:36.179 --> 04:47:38.179
working hard to continually 

04:47:39.266 --> 04:47:41.266
support more n on the Keras side
we 

04:47:43.371 --> 04:47:45.821
support 32 of the most commonly 
used Keras layers during the 

04:47:45.822 --> 04:47:47.822
supporting phase and also 
computing and training of the 

04:47:48.874 --> 04:47:50.499
models so computing accuracy 
once you get them in, and of 

04:47:50.500 --> 04:47:52.500
course you can also make 
predictions as well.

04:47:53.397 --> 04:47:56.885
All right.  So I want to show 
you a demo before I  bore you 

04:47:56.886 --> 04:47:58.886
anymore.

04:48:00.155 --> 04:48:03.708
This demo is built by our 
friends at  Creative Lab.  As a 

04:48:03.709 --> 04:48:05.709
collaboration between them and a

04:48:07.077 --> 04:48:08.550
few researchers on Google Brand,
so I'm going to go back over 

04:48:08.551 --> 04:48:10.551
here to this laptop.

04:48:18.373 --> 04:48:20.814
Okay, so the idea of this model 
is it takes a 2D image of a 

04:48:20.815 --> 04:48:24.889
human being and it estimates a 
set of keypoints that relate to 

04:48:24.890 --> 04:48:27.122
their skeleton, so things like 
your wrist point, the centers of

04:48:27.123 --> 04:48:29.123
your 

04:48:31.069 --> 04:48:32.993
eyes, your shoulders, and that 
kind of thing.  So I'm just 

04:48:32.994 --> 04:48:35.487
going to turn a demo on here.  
When I do that the webcam will 

04:48:35.488 --> 04:48:38.785
turn on and start predicting 
some key points for me.  I'm 

04:48:38.786 --> 04:48:41.633
going to step back here so you 
can actually see the full thing,

04:48:41.634 --> 04:48:43.634
and as you move around you'll 
see the skeleton 

04:48:46.712 --> 04:48:47.771
change and make some predictions
about me.

04:48:47.772 --> 04:48:50.411
All right.  So there is 
obviously a lot you can do with 

04:48:50.412 --> 04:48:53.055
this.  We were really excited to
show you a fun little demo.

04:48:57.161 --> 04:48:59.392
It's very thin, and what's going
to happen is when I click this 

04:48:59.393 --> 04:49:02.479
slider we're going to move to a 
separate mode where it's going 

04:49:02.480 --> 04:49:05.191
to look for another image on the
Internet that has a person with 

04:49:05.192 --> 04:49:07.451
the same pose as me.  Okay?

04:49:10.777 --> 04:49:13.000
Let's try that.  Is it going to 
work here?

04:49:19.158 --> 04:49:20.985
Of course it's not working now. 
Okay.  We have a physical 

04:49:20.986 --> 04:49:23.222
installation of this which you 
can go check out at the 

04:49:26.078 --> 04:49:28.309
experiments tent on H and it's 
really fun, it's a full screen 

04:49:28.310 --> 04:49:31.100
version of that where you can 
see another version of you.

04:49:35.400 --> 04:49:37.263
We have released this model on 
NPM so you can use this and you 

04:49:37.264 --> 04:49:40.755
need no Machine Learning 
experience to do it.  The API 

04:49:40.756 --> 04:49:42.595
lets you point to an image and 
out pops an array of key points,

04:49:42.596 --> 04:49:46.481
it's that easy, so we're really 
excited to see what you do with 

04:49:46.482 --> 04:49:48.482
that.

04:49:56.587 --> 04:50:00.674
     Okay.  So there is a lot 
that you can do with just 

04:50:00.675 --> 04:50:03.148
porting the models to the 
browser for inference.  Since 

04:50:03.149 --> 04:50:07.455
the beginning of deeplearning.js
and TensorFlow.js we've made it 

04:50:07.456 --> 04:50:09.456
a high priority to actually 
train directly in the  browser 

04:50:11.372 --> 04:50:13.644
and this opens up the door for 
education,  interactivity as 

04:50:13.645 --> 04:50:16.092
well as retraining with data 
that never leaves the client.

04:50:16.296 --> 04:50:19.814
     So I'm going to actually 
show you another demo of that 

04:50:19.815 --> 04:50:21.815
back on the laptop over here.

04:50:27.082 --> 04:50:32.165
Okay.  Daniel, do you want to 
come help me?  Here we go.  

04:50:32.166 --> 04:50:35.014
Cool.
     So the game is in three 

04:50:35.015 --> 04:50:37.015
phases.

04:50:38.163 --> 04:50:40.807
In phase one we're going to 
actually collect frames from the

04:50:40.808 --> 04:50:43.098
webcam and what we're going to 
do is use those frames to 

04:50:45.915 --> 04:50:47.915
actually play a game of Packman.
So Daniel, why don't you start 

04:50:49.029 --> 04:50:51.481
collecting frames and what he's 
going to do is going to collect 

04:50:51.482 --> 04:50:55.542
frames to up, down, left, and 
right, and those are going to be

04:50:55.543 --> 04:50:57.975
associated with the poses with 
the four controls for the  

04:50:57.976 --> 04:51:02.329
Packman game itself.
     So as he's collecting those

04:51:02.330 --> 04:51:05.977
we're saving some of the images 
locally and we're not actually 

04:51:05.978 --> 04:51:08.229
training them all  yet.  So once
he's done actually collecting 

04:51:10.303 --> 04:51:12.584
those frames, we're going to 
train the model and again, this 

04:51:12.585 --> 04:51:16.490
is going to be trained entirely 
in the browser with no request 

04:51:16.491 --> 04:51:19.355
to a server anywhere.
     Okay.  So when we actually 

04:51:19.356 --> 04:51:21.356
train that model, what's going 
to happen is we're actually 

04:51:23.672 --> 04:51:25.136
going to take a  pre-trained 
MobileNet model that's actually 

04:51:25.137 --> 04:51:29.408
in the page right now and we're 
going to do a little retraining 

04:51:29.409 --> 04:51:32.868
phase with data that's he's just
collected.  So why don't you 

04:51:32.869 --> 04:51:37.650
press that train model.
     Awesome.  Our loss value is

04:51:37.651 --> 04:51:41.510
going down and it looks like 
we've learned something.  Okay. 

04:51:41.511 --> 04:51:43.537
So the phase three of this game 
is to actually play, and so when

04:51:43.538 --> 04:51:46.595
he presses that button, what's 
going to happen is we're going 

04:51:46.596 --> 04:51:48.596
to take  frames from that webcam
and we're going to make 

04:51:50.045 --> 04:51:52.045
predictions given that model 
that we just trained.

04:51:54.902 --> 04:51:57.375
Why don't you press that play 
button and we'll see how it 

04:51:57.376 --> 04:52:02.086
goes.  If you look at the bottom
right of the screen we see the 

04:52:02.087 --> 04:52:04.549
predictions happening.  It's 
highlighting the control that it

04:52:06.173 --> 04:52:08.216
thinks it is and you'll see him 
actually playing the Packman 

04:52:08.217 --> 04:52:10.251
game now.
     So obviously this is just a

04:52:10.252 --> 04:52:13.899
game, but we're really excited 
about opportunities for 

04:52:13.900 --> 04:52:15.900
accessibility, you can imagine 
the chrome extension that lets 

04:52:17.564 --> 04:52:19.564
you train a model that lets you 
scroll the page and click.

04:52:20.661 --> 04:52:23.331
Now all of this code is online 
and available for you to go in 

04:52:23.332 --> 04:52:26.612
and build your own applications 
with and we're really excited to

04:52:26.613 --> 04:52:29.097
see what you do with it.  All 
right, man, back to the talk.

04:52:29.498 --> 04:52:31.498
     &gt;&gt; DANIEL SMILKOV:  All 
right.

04:52:32.151 --> 04:52:34.151
(Applause).

04:52:36.834 --> 04:52:40.127
     &gt;&gt; NIKHIL THORAT:  Okay, so
let's chat a little bit about 

04:52:40.128 --> 04:52:44.412
performance.  What we're looking
at here is a  benchmark of 

04:52:44.413 --> 04:52:49.544
MobileNet 1.0 running with 
TensorFlow Python, this is 

04:52:49.545 --> 04:52:51.971
classic TensorFlow, not running 
with TensorFlow.js.  We're 

04:52:51.972 --> 04:52:54.445
thinking about this in the 
context of a batch size of one 

04:52:54.446 --> 04:52:57.939
and the reason that we want to 
think like that is because we're

04:52:57.940 --> 04:53:01.606
thinking of an interactive 
application like  Packman where 

04:53:01.607 --> 04:53:03.675
you can only read one sensor 
frame at a time so you can't 

04:53:03.676 --> 04:53:07.952
really batch that data.
     On the first reel we're 

04:53:07.953 --> 04:53:09.953
looking at 

04:53:13.297 --> 04:53:15.969
TensorFlow running with CUDA on 
a 1080 GTX, a beefy machine and 

04:53:15.970 --> 04:53:17.970
3 milliseconds 

04:53:19.255 --> 04:53:20.490
per frame, and I want to mention
the smaller the bar the faster 

04:53:20.491 --> 04:53:22.947
it is.
     The second row is 

04:53:22.948 --> 04:53:24.948
TensorFlow CPU 

04:53:27.826 --> 04:53:29.826
running with AVX2 instructions 
on one of 

04:53:31.924 --> 04:53:33.941
these Mac Book Pro here.  We're 
getting about 60 seconds a 

04:53:33.942 --> 04:53:37.209
frame.  Where does GTX fit in?  
Well it depends.

04:53:40.473 --> 04:53:42.496
So running on the 1080GTX, that 
beefy machine, we're getting 

04:53:42.497 --> 04:53:44.497
about 11 milliseconds per frame.
On TensorFlow.

04:53:49.120 --> 04:53:51.154
js running on integrated 
graphics we're getting about 100

04:53:51.155 --> 04:53:53.221
milliseconds per frame.  I want 
to point out that 100 

04:53:55.868 --> 04:53:57.512
milliseconds is not so bad, that
Packman game was running with 

04:53:57.513 --> 04:53:59.339
this model and you can really 
build something interactive with

04:53:59.340 --> 04:54:01.170
that.
     The web is only going to 

04:54:01.171 --> 04:54:03.171
get faster and faster.

04:54:06.884 --> 04:54:08.884
There are a new set of standards
like 

04:54:09.955 --> 04:54:12.841
WebGL compute shaders and web 
GPU that gives you much closer 

04:54:12.842 --> 04:54:16.561
access to the GPU, but the web 
has its limitation, you live in 

04:54:16.562 --> 04:54:18.399
a sandbox environment and you 
can only really get access to 

04:54:18.400 --> 04:54:22.333
the GPU through these APIs.  So 
how do we scale beyond those 

04:54:22.536 --> 04:54:24.584
limitations?
     With that I'm going to hand

04:54:24.585 --> 04:54:28.693
it off to Nick who is going to 
talk about how we'll scale.

04:54:31.154 --> 04:54:33.813
&gt;&gt; NICK KREEGER:  Thanks, 
Nikhil.  Today we're launching 

04:54:33.814 --> 04:54:35.814
TensorFlow 

04:54:38.513 --> 04:54:40.349
support for Node.js.
     (Applause).

04:54:40.350 --> 04:54:45.301
     We're really excited to 
bring a easy to use high 

04:54:45.302 --> 04:54:47.302
performance machine 

04:54:48.397 --> 04:54:51.243
library to JavaScript 
developers.  The Open Source 

04:54:51.244 --> 04:54:53.901
community around Node.js and NPM
is really awesome, there is 

04:54:55.950 --> 04:54:57.950
incredible movement in the 
space, a ton 

04:54:58.998 --> 04:55:01.653
of libraries and packages for 
developers to use today and now 

04:55:01.654 --> 04:55:05.170
we're bringing ML to this front.
     The engine that runs Node.

04:55:07.218 --> 04:55:09.064
js V8 is super fast, it's had 
tons of resources put into it by

04:55:09.065 --> 04:55:11.065
companies like Google, and we've
seen the interpreter 

04:55:14.141 --> 04:55:16.176
be up to 10 times as fast as 
Python.  Lots of room for 

04:55:16.177 --> 04:55:20.467
performance improvements.
     Also, using TensorFlow 

04:55:20.468 --> 04:55:22.468
gives us 

04:55:23.524 --> 04:55:26.171
access to really high end 
Machine Learning hardware like 

04:55:26.172 --> 04:55:28.172
GPU devices and TPUs in the 
Cloud.

04:55:30.462 --> 04:55:33.323
Look for support for that soon.
     Let's step back and look at

04:55:33.324 --> 04:55:35.324
the architecture we highlighted 
earlier.

04:55:38.209 --> 04:55:40.209
We have a Layers API and at a 
little 

04:55:41.286 --> 04:55:43.775
bit lower level Core API that 
has our Ops.  This whole  

04:55:43.776 --> 04:55:45.776
runtime is powered by 

04:55:47.855 --> 04:55:49.470
WebGL in the browser, but today 
through NPM we're shipping a 

04:55:49.471 --> 04:55:51.312
package that gives you 
TensorFlow that gives you access

04:55:51.313 --> 04:55:54.197
to those TPUs, the GPU and CPU.

04:55:57.726 --> 04:55:59.726
All of this is through our MPM 
package.

04:56:00.810 --> 04:56:02.810
To show you how easy it is to 
use 

04:56:04.098 --> 04:56:05.921
our Node bindings I want to show
you a code snippet.  This 

04:56:05.922 --> 04:56:07.922
application function right here 

04:56:09.372 --> 04:56:10.579
is a very common server side 
request response handler for an 

04:56:10.580 --> 04:56:15.270
endpoint.  Those who have worked
with express framer know exactly

04:56:15.271 --> 04:56:17.271
what's going on here.

04:56:18.560 --> 04:56:20.392
Our endpoint listens for slash 
model and takes input as a 

04:56:20.393 --> 04:56:24.851
request, which we pass into a 
TensorFlow.js model and that 

04:56:24.852 --> 04:56:26.852
output is pushed out into the 
response.

04:56:31.373 --> 04:56:33.011
Now, to turn on high-performance
sensor flow code we only need 

04:56:33.012 --> 04:56:37.990
two lines of code, an import 
that loads our binding, and then

04:56:37.991 --> 04:56:40.236
an  existing API called the 
setup back in the TensorFlow, 

04:56:41.863 --> 04:56:43.689
and now this model is running 
with the performance of 

04:56:43.690 --> 04:56:46.574
TensorFlow.
     Whether a works today out 

04:56:46.575 --> 04:56:52.253
of the box?  So we can take 
pre-existing Python models and 

04:56:52.254 --> 04:56:54.284
run those natively in  Node.js. 
The models we've kind of showed 

04:56:54.285 --> 04:56:56.285
off 

04:56:57.339 --> 04:57:00.387
today, all of those were run in 
our Node runtime.  There is no 

04:57:00.388 --> 04:57:02.447
need to bring a Python stack to 
your Node infrastructure, just 

04:57:04.716 --> 04:57:06.716
run it in JavaScript.

04:57:10.644 --> 04:57:12.644
Our NPM package today ships a 

04:57:14.540 --> 04:57:17.054
off-the-shelf CPU  build, no 
driver, just install the package

04:57:17.055 --> 04:57:20.211
and you're up and running.
     Our whole API that we ship 

04:57:20.212 --> 04:57:25.296
in TensorFlow.js will work with 
our Node runtime.  Every API 

04:57:25.297 --> 04:57:28.341
that we've showcased will work 
today out of the box.

04:57:32.043 --> 04:57:34.043
Now, we've built a little demo 

04:57:36.525 --> 04:57:38.181
using Major League  Baseball 
data in Node.js to show what can

04:57:38.182 --> 04:57:41.444
you do with Machine Learning, 
Node.js and JavaScript.

04:57:45.324 --> 04:57:47.363
We've used Major  League 
Baseball advanced media pitch 

04:57:47.364 --> 04:57:49.364
effects dataset to do some 
Machine Learning.

04:57:52.272 --> 04:57:53.941
The pitch effects dataset is a 
large library of sensor data 

04:57:53.942 --> 04:57:57.195
about pitches that baseball 
players have thrown in actual 

04:57:57.196 --> 04:57:59.196
baseball games.
     For those that aren't super

04:58:01.077 --> 04:58:04.750
familiar with baseball, we've 
given a little context here.  A 

04:58:04.751 --> 04:58:06.178
pitcher will throw a different 
type of pitch to fool the player

04:58:06.179 --> 04:58:10.251
who is trying to hit this ball. 
There is pitches that have 

04:58:10.252 --> 04:58:14.747
higher  velocities, pitches that
are a little slower but have 

04:58:14.748 --> 04:58:16.401
more movement, and in this 
example we've sort of 

04:58:16.402 --> 04:58:20.673
highlighted the fast ball, the 
changeup, and the curve ball, 

04:58:20.674 --> 04:58:22.674
those are all types of pitches 
much don't get too hung up about

04:58:24.125 --> 04:58:25.763
the details of baseball, but 
what we're really trying to 

04:58:25.764 --> 04:58:27.764
solve here is a very classic 
Machine Learning problem of 

04:58:28.798 --> 04:58:30.856
taking sensor information and 
drawing a classification to 

04:58:30.857 --> 04:58:34.320
that.
     So for that I'm going to 

04:58:34.321 --> 04:58:36.354
actually showcase this demo.

04:58:44.120 --> 04:58:46.120
All right.

04:58:47.166 --> 04:58:49.616
So on one side of my screen I 
have a terminal that I'm going 

04:58:49.617 --> 04:58:52.085
to start my Node application 
with, and on the left I have a 

04:58:52.086 --> 04:58:56.965
web browser.  We built this with
a very simple UI that listens to

04:58:56.966 --> 04:58:59.201
what our server is doing over 
sockets, and those who have used

04:59:02.855 --> 04:59:04.273
the socket I/O library in  Node 
know what this interaction is 

04:59:04.274 --> 04:59:06.274
doing.

04:59:08.358 --> 04:59:10.462
I'm just going to type Node, 
start my server, and now all 

04:59:10.463 --> 04:59:14.606
through Node my model is up and 
running and training.  Every 

04:59:14.607 --> 04:59:16.222
time we take a pass through our 
dataset we report that over the 

04:59:16.223 --> 04:59:19.677
socket to our client and can you
see the blue bar is moving a 

04:59:19.678 --> 04:59:22.155
little bit closer to 100%.  
That's our model understanding 

04:59:22.156 --> 04:59:24.586
how to tell the difference 
between a curveball 

04:59:28.799 --> 04:59:32.932
or fastball, and as you can kind
of see, every step it moves a 

04:59:28.799 --> 04:59:33.648
little bit differently.  And our
model is having a little bit of 

04:59:33.649 --> 04:59:35.649
trouble at the moment with the 

04:59:37.744 --> 04:59:40.607
fastball sinker but only looked 
at data for a few passes.  The 

04:59:40.608 --> 04:59:42.608
more the server run the better 
it gets at training.

04:59:42.872 --> 04:59:44.872
So all of this training data 
we've 

04:59:45.920 --> 04:59:50.604
shown is historical baseball 
data from 2015 to 2017.  I'm 

04:59:50.605 --> 04:59:52.605
going to hit this test live 
button 

04:59:54.871 --> 04:59:56.871
and this is going to use the 
Node 

04:59:59.044 --> 05:00:01.916
framework to go out to Major 
League baseball, pull in some 

05:00:01.917 --> 05:00:04.963
newer live data and run the 
evaluation.

05:00:06.394 --> 05:00:08.430
Once this data comes in, we're 
going to see the orange bars, 

05:00:08.431 --> 05:00:12.091
and the orange bars show us how 
much better we are at predicting

05:00:12.092 --> 05:00:15.154
data that our model has never 
seen  before.  These are live 

05:00:15.155 --> 05:00:17.155
pitches, and we're really good 
at identifying the curveball 

05:00:21.605 --> 05:00:23.605
and not so create at that  
fastball sinker still.

05:00:26.053 --> 05:00:28.053
Let's jump back and continue to 
look at our next slide.

05:00:31.232 --> 05:00:33.907
     This is the architecture of
what we were doing in that demo.

05:00:35.941 --> 05:00:38.385
We've built a very simple Node 
server that  hosts our 

05:00:38.386 --> 05:00:40.415
JavaScript models, and when we 
hit that live button, it reaches

05:00:43.908 --> 05:00:45.716
out to Major League Baseball, 
pulls in the live data and runs 

05:00:45.717 --> 05:00:50.263
inference on the new pitches.  
We continue to report that to 

05:00:50.264 --> 05:00:52.264
any connected clients through 
the browser.

05:00:54.327 --> 05:00:56.176
What is the stack up and 
performance?  So in that 

05:00:56.177 --> 05:00:58.220
training set we were looking at 
7,000 pitches and we were 

05:01:01.683 --> 05:01:03.505
training every couple seconds 
7,000 pitches, so that's an 

05:01:03.506 --> 05:01:05.506
interesting benchmark but let's 
actually classify 

05:01:08.652 --> 05:01:09.441
that with the MobileNet 
benchmark we showcased earlier.

05:01:14.097 --> 05:01:16.851
So these are the numbers for 
Python TensorFlow, the  GPU and 

05:01:16.852 --> 05:01:19.499
CPU inference time.  We're just 
getting started, we just 

05:01:21.748 --> 05:01:23.370
launched an MPM package, we have
a lot of ways to go, but we have

05:01:23.371 --> 05:01:26.211
some promising early numbers to 
showcase.

05:01:33.060 --> 05:01:36.001
TensorFlow with Node.js is 
exactly as past as Python 

05:01:37.223 --> 05:01:39.223
TensorFlow, and so with that I'm
going 

05:01:41.918 --> 05:01:42.739
to hand it off to Nikhil to wrap
up.

05:01:42.740 --> 05:01:44.883
&gt;&gt; NIKHIL THORAT:  Thanks, Nick.
Exciting stuff.

05:01:47.943 --> 05:01:50.199
Okay, so let's recap some of the
APIs and libraries and tools 

05:01:50.200 --> 05:01:55.615
that we have supported today 
with TensorFlow.js.  We have a 

05:01:55.616 --> 05:01:58.052
low-level API called the Core 
API which is a set of 

05:01:58.053 --> 05:02:00.053
accelerated 

05:02:02.171 --> 05:02:03.385
linear algebra kernels and a 
layer for automatic 

05:02:03.386 --> 05:02:05.437
differentiation, we saw an 
example of with that with the 

05:02:05.438 --> 05:02:07.438
polynomial regression demo.

05:02:09.579 --> 05:02:12.371
We also have a high-level Layers
API that encodes Machine 

05:02:12.372 --> 05:02:14.372
Learning best 

05:02:15.579 --> 05:02:17.593
practices into an API that's 
much more easy to use, and we 

05:02:17.594 --> 05:02:21.604
saw an example of that with the 
addition of RNN translation 

05:02:21.605 --> 05:02:22.825
demo.
     We also have showed you a 

05:02:22.826 --> 05:02:25.461
couple of ways that you can take
pretrained models 

05:02:30.187 --> 05:02:32.021
from Python via saved model or 
via Keras models and import to 

05:02:32.022 --> 05:02:35.089
the browser for inference or 
doing retraining or computing 

05:02:35.090 --> 05:02:37.538
accuracy.
     And of course, we also 

05:02:37.539 --> 05:02:40.022
showed you the new Node.js 
support for TensorFlow.

05:02:43.074 --> 05:02:45.074
js today, and we're really 
excited about that.

05:02:46.384 --> 05:02:50.243
Okay.  So this project, 
TensorFlow.js was not just the 

05:02:50.244 --> 05:02:52.944
three of us on the stage here.  
It was a cross-team 

05:02:52.945 --> 05:02:54.945
collaboration 

05:02:56.002 --> 05:02:58.586
between many amazing people at 
Google, and we also have some 

05:02:58.587 --> 05:03:00.669
amazing Open Source contributors
that I want to send a shout out 

05:03:00.670 --> 05:03:05.161
to.  This project literally 
would not have been possible 

05:03:05.162 --> 05:03:06.781
without them, so thank you.
     All of the things that we 

05:03:06.782 --> 05:03:08.782
talked 

05:03:10.244 --> 05:03:12.244
about here today, the demos, all
of the 

05:03:13.946 --> 05:03:16.811
code is Open Sourced on our 
website  js.tensorFlow.org and 

05:03:16.812 --> 05:03:18.812
all of the code is also Open 

05:03:22.333 --> 05:03:24.361
Sourced on 
GitHub/TensorFlow/tfjs.  We also

05:03:24.362 --> 05:03:26.362
have a community  mailing list, 
a place where people can go and 

05:03:27.773 --> 05:03:29.773
ask  questions, post their demos
and that kind of thing.

05:03:31.430 --> 05:03:33.058
We have some office hours today 
at 3:30 and we have some office 

05:03:33.059 --> 05:03:35.059
hours 

05:03:36.065 --> 05:03:38.086
tomorrow at 9:30, which I invite
you to come and talk to us in 

05:03:38.087 --> 05:03:43.020
person, and we also have some 
tents, we have the Experiments 

05:03:43.021 --> 05:03:45.717
Tent at H, that's where that 
Move  Mirror Demo the full 

05:03:45.718 --> 05:03:50.017
screen version of that will be, 
and we'll also be at the AI Tent

05:03:50.018 --> 05:03:52.292
as well.
     So we are really excited to

05:03:52.293 --> 05:03:55.780
build the next chapter of 
Machine Learning and JavaScript 

05:03:55.781 --> 05:03:58.672
with you.  Thank you.
     (Applause).

05:04:04.375 --> 05:04:06.375
     &gt;&gt; Thank you for joining 
this session.

05:04:10.672 --> 05:04:12.672
Grand ambassadors will assist 
with directing you through the 

05:04:14.023 --> 05:04:17.805
designated exits.

