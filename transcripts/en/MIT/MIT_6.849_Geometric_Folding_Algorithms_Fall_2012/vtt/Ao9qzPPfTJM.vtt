WEBVTT
Kind: captions
Language: en

00:00:03.520 --> 00:00:08.390
PROFESSOR: So today's class we
talked about vertex unfolding,

00:00:08.390 --> 00:00:12.435
unfolding orthogonal
polyhedra, and something else

00:00:12.435 --> 00:00:13.810
which there weren't
any questions

00:00:13.810 --> 00:00:19.160
about-- got them already--
Cauchey's rigidity theorem.

00:00:19.160 --> 00:00:21.980
So we will go through
those in turn.

00:00:21.980 --> 00:00:24.250
A bunch of small
questions and two

00:00:24.250 --> 00:00:28.230
cool new things, new updates.

00:00:28.230 --> 00:00:30.840
So first question is
about vertex unfolding.

00:00:30.840 --> 00:00:33.090
Why do we fold things
in a chain and kind

00:00:33.090 --> 00:00:36.140
of a line, linear style?

00:00:36.140 --> 00:00:38.550
Would you get any
benefit out of a tree?

00:00:38.550 --> 00:00:43.220
The answer is chains are
easy to avoid intersection.

00:00:43.220 --> 00:00:46.000
That's the reason we use them
on these kinds of unfoldings.

00:00:46.000 --> 00:00:49.170
We could dedicate a different
slab for every piece

00:00:49.170 --> 00:00:49.920
and this is great.

00:00:49.920 --> 00:00:52.350
And incidentally-- I didn't
mention this in lecture,

00:00:52.350 --> 00:00:55.550
but it's obvious once you think
about it for five minutes.

00:00:55.550 --> 00:00:58.560
If you want general cuts-- if
you're allowed to cut anywhere

00:00:58.560 --> 00:01:00.990
on the surface and you want
a vertex unfolding-- then

00:01:00.990 --> 00:01:04.480
anything is possible because
you could take any surface

00:01:04.480 --> 00:01:07.080
and chainify it in the same
way we do with the [INAUDIBLE]

00:01:07.080 --> 00:01:07.720
sections.

00:01:07.720 --> 00:01:09.660
You subdivide.

00:01:09.660 --> 00:01:11.059
First, you triangulate.

00:01:11.059 --> 00:01:13.100
You subdivide each triangle
into three triangles.

00:01:13.100 --> 00:01:15.680
Then you can hinge it
together in a chain.

00:01:15.680 --> 00:01:17.630
And then you can just
lay it out like this.

00:01:17.630 --> 00:01:22.927
So general vertex unfolding
is trivial for this reason.

00:01:22.927 --> 00:01:24.760
When you're only allowed
to cut along edges,

00:01:24.760 --> 00:01:27.440
things get much harder.

00:01:27.440 --> 00:01:30.230
The only technique we have right
now is facet path unfolding.

00:01:30.230 --> 00:01:33.830
But of course, vertex
unfolding convex polyhedra

00:01:33.830 --> 00:01:37.030
is an easier version of edge
unfolding context polyhedra,

00:01:37.030 --> 00:01:39.980
but we have no idea
how to do that.

00:01:39.980 --> 00:01:43.190
So maybe it's possible.

00:01:43.190 --> 00:01:45.131
We already know it's not
possible with chains.

00:01:45.131 --> 00:01:47.380
So if it's possible, it's
somehow possible with trees,

00:01:47.380 --> 00:01:48.940
I guess.

00:01:48.940 --> 00:01:51.400
We know tree style
unfoldings can

00:01:51.400 --> 00:01:52.880
be helpful with
general cuttings,

00:01:52.880 --> 00:01:55.720
but this is not directly
relevant to vertex unfolding.

00:01:55.720 --> 00:01:59.010
But this is the source unfolding
and the star unfolding again.

00:01:59.010 --> 00:02:00.740
So yeah, who knows?

00:02:00.740 --> 00:02:04.520
But so far, chains are just
a useful proof technique.

00:02:04.520 --> 00:02:07.020
All right, next question.

00:02:07.020 --> 00:02:09.350
This is vertex
unfolding summarized

00:02:09.350 --> 00:02:12.830
in the lecture notes
on the right side.

00:02:12.830 --> 00:02:14.930
So we end up with a
nice Eulerian graph.

00:02:14.930 --> 00:02:17.230
In this case, every vertex
happens to have even degree.

00:02:17.230 --> 00:02:19.120
In general, two of them
might have odd degree

00:02:19.120 --> 00:02:21.340
and we just get a path.

00:02:21.340 --> 00:02:23.750
But the observation in
this question-- maybe

00:02:23.750 --> 00:02:26.510
I'll go to the other side
so you can read both--

00:02:26.510 --> 00:02:30.180
is that we visit the same
vertex multiple times,

00:02:30.180 --> 00:02:32.460
like we attach these two
triangles at this vertex.

00:02:32.460 --> 00:02:36.660
We also attach these two
triangles at that vertex.

00:02:36.660 --> 00:02:37.720
Is that OK?

00:02:37.720 --> 00:02:39.230
Yes, we define it to be OK.

00:02:39.230 --> 00:02:42.560
I think I briefly mentioned
it's defined to be OK.

00:02:42.560 --> 00:02:44.570
Why?

00:02:44.570 --> 00:02:45.250
I don't know.

00:02:45.250 --> 00:02:47.270
It's hard to imagine
little dots of paper there,

00:02:47.270 --> 00:02:50.750
but somehow you imagine that
they can stay connected.

00:02:50.750 --> 00:02:52.580
In particular, it's
the natural definition

00:02:52.580 --> 00:02:53.590
of a hinge dissection.

00:02:53.590 --> 00:02:57.070
You could add hinges
at those two places.

00:02:57.070 --> 00:03:00.470
But also it's
impossible otherwise.

00:03:00.470 --> 00:03:03.120
This was a fun little
puzzle to think about.

00:03:03.120 --> 00:03:06.080
But if you take-- I actually
have a slide for it.

00:03:06.080 --> 00:03:07.480
I don't have to draw.

00:03:07.480 --> 00:03:09.000
It's hard to draw
an icosahedron.

00:03:09.000 --> 00:03:14.180
If you take an icosahedron,
it has 20 faces.

00:03:14.180 --> 00:03:20.200
And the dual is a dodecahedron
so it has 12 vertices.

00:03:20.200 --> 00:03:23.210
So there aren't
enough to go around,

00:03:23.210 --> 00:03:25.130
at least if you wanted
a chain unfolding.

00:03:25.130 --> 00:03:27.400
Well, actually any
tree unfolding,

00:03:27.400 --> 00:03:29.230
if you have 20
triangles, you're going

00:03:29.230 --> 00:03:33.190
to need 19 vertices to
connect them together.

00:03:33.190 --> 00:03:35.930
And there's only 12
vertices so you can't do it.

00:03:40.410 --> 00:03:41.430
Is that literally true?

00:03:41.430 --> 00:03:44.530
I guess you could imagine,
in a general tree unfolding,

00:03:44.530 --> 00:03:48.970
you could use one point
to connect together

00:03:48.970 --> 00:03:49.930
many triangles.

00:03:49.930 --> 00:03:51.710
But I'm pretty sure
it's not possible

00:03:51.710 --> 00:03:54.280
if you're allowed
to reuse vertices.

00:03:54.280 --> 00:03:56.499
So that's why we allow it.

00:03:56.499 --> 00:03:58.040
We get a more
interesting result when

00:03:58.040 --> 00:04:03.040
we allow revisiting vertices.

00:04:03.040 --> 00:04:05.670
Could be still an
interesting question like,

00:04:05.670 --> 00:04:08.660
which polyhedron have
vertex unfolding if we only

00:04:08.660 --> 00:04:10.990
get to use the vertex once?

00:04:10.990 --> 00:04:13.930
But I don't know
any results on it.

00:04:13.930 --> 00:04:16.410
Next question is, any
progress on vertex unfolding?

00:04:16.410 --> 00:04:19.269
And there's one new result.

00:04:19.269 --> 00:04:22.940
Before I showed you, I think,
one example of a vertex

00:04:22.940 --> 00:04:31.480
ununfoldable polyhedron--
this guy, box on a box.

00:04:31.480 --> 00:04:33.980
Initially, we said oh,
this is edge ununfoldable,

00:04:33.980 --> 00:04:36.400
but it's also vertex
ununfoldable because this face

00:04:36.400 --> 00:04:42.520
here is a donut and the
five sides of that cube

00:04:42.520 --> 00:04:46.770
have to fit in here, and there's
not enough area for them.

00:04:46.770 --> 00:04:49.130
And that's true also if
you're vertex unfolding.

00:04:49.130 --> 00:04:52.000
No matter how this stays
attached to the donut face,

00:04:52.000 --> 00:04:56.370
it's got a line here,
that's not possible.

00:04:56.370 --> 00:04:58.010
But this is an
unsatisfying example

00:04:58.010 --> 00:05:00.310
because you have a face
that is not a disk.

00:05:00.310 --> 00:05:02.345
And in general, you're
not topologically convex.

00:05:05.027 --> 00:05:07.610
you can't just move the vertices
around and make this a convex

00:05:07.610 --> 00:05:11.090
polyhedron, not
strictly convex anyway.

00:05:11.090 --> 00:05:16.145
So here is a new
example with Zach Abel.

00:05:20.040 --> 00:05:22.120
He took this class
two years ago,

00:05:22.120 --> 00:05:25.330
or five years ago, I guess.

00:05:25.330 --> 00:05:27.490
This is a topologically
convex polyhedron,

00:05:27.490 --> 00:05:30.770
so you could move the
vertices to make this convex.

00:05:30.770 --> 00:05:32.990
That's not so obvious.

00:05:32.990 --> 00:05:36.970
And it is vertex ununfoldable,
which we will prove.

00:05:36.970 --> 00:05:41.200
This is one of the
two results for today.

00:05:41.200 --> 00:05:46.760
The example is a dark prism
here, a triangular prism,

00:05:46.760 --> 00:05:51.790
and a light triangular
prism just at right angles

00:05:51.790 --> 00:05:52.660
to each other.

00:05:52.660 --> 00:05:55.000
Then you take the
union of that solid,

00:05:55.000 --> 00:05:57.320
and then you take the boundary.

00:05:57.320 --> 00:06:01.660
So first, you can check
all the faces are disks.

00:06:01.660 --> 00:06:04.330
And for topological
convexity, you

00:06:04.330 --> 00:06:06.380
want to check that if
you look at any two faces

00:06:06.380 --> 00:06:10.260
like this light S1
and this dark one,

00:06:10.260 --> 00:06:12.610
they should only share
one edge at most.

00:06:12.610 --> 00:06:15.020
They should share nothing,
a vertex, or an edge.

00:06:15.020 --> 00:06:17.290
That's topological
convexity because that's

00:06:17.290 --> 00:06:22.520
how things work in convex
if the polygons were convex.

00:06:22.520 --> 00:06:25.830
So like here, they
share just that edge.

00:06:25.830 --> 00:06:27.570
So it is topologically convex.

00:06:27.570 --> 00:06:30.557
Let's prove that it is
vertex ununfoldable.

00:06:30.557 --> 00:06:32.890
So in some sense, this is a
strengthening of the witch's

00:06:32.890 --> 00:06:37.470
hats and stuff because this
is also edge ununfoldable.

00:06:37.470 --> 00:06:38.520
But it's even cooler.

00:06:38.520 --> 00:06:39.561
It's vertex ununfoldable.

00:06:41.364 --> 00:06:42.780
Let's just look
at the connections

00:06:42.780 --> 00:06:44.530
between the dark and the light.

00:06:47.060 --> 00:06:52.000
There are one, two, three,
four vertices on this side

00:06:52.000 --> 00:06:54.260
and four vertices
on the backside that

00:06:54.260 --> 00:06:57.280
connect dark to light.

00:06:57.280 --> 00:07:01.570
I should make some Star
Wars reference I suppose.

00:07:01.570 --> 00:07:03.230
All those vertices
are symmetric,

00:07:03.230 --> 00:07:05.340
so we can just look
at any of them.

00:07:05.340 --> 00:07:08.540
Somewhere, the light side has
to be attached to the dark side.

00:07:08.540 --> 00:07:09.460
Where could that be?

00:07:09.460 --> 00:07:12.475
Let's say vertex A because
it's got to be somewhere,

00:07:12.475 --> 00:07:13.980
and it's symmetric.

00:07:13.980 --> 00:07:16.480
So vertex A has three
angles incident to it.

00:07:16.480 --> 00:07:20.820
There's alpha-- that's
this angle-- which is big.

00:07:20.820 --> 00:07:21.940
It reflects.

00:07:21.940 --> 00:07:25.040
There's this beta and
there's this gamma.

00:07:25.040 --> 00:07:29.910
Beta is 90 degrees
here because this

00:07:29.910 --> 00:07:31.915
is supposed to be a rectangle.

00:07:34.950 --> 00:07:41.509
Gamma is well, let me state
what I want from these angles.

00:07:41.509 --> 00:07:43.300
There's some parameters
in the construction

00:07:43.300 --> 00:07:44.830
I haven't yet told you.

00:07:44.830 --> 00:07:51.160
So we want alpha to
be bigger than 270.

00:07:51.160 --> 00:07:54.630
Theta equals 92.

00:07:54.630 --> 00:08:03.610
And we want alpha plus
gamma equal to 360.

00:08:03.610 --> 00:08:09.110
So this is possible if you
angle these guys correctly,

00:08:09.110 --> 00:08:11.490
is the short version.

00:08:11.490 --> 00:08:13.240
I guess the most
interesting is this alpha

00:08:13.240 --> 00:08:20.850
plus gamma equals 360.

00:08:20.850 --> 00:08:21.560
Is that obvious?

00:08:24.440 --> 00:08:28.025
Not especially, but I'm claiming
it's true in this picture.

00:08:28.025 --> 00:08:29.650
We'll see it in an
unfolding, actually,

00:08:29.650 --> 00:08:32.844
on the very next slide.

00:08:32.844 --> 00:08:34.360
Yeah, let's go there.

00:08:34.360 --> 00:08:37.010
Still have the same picture.

00:08:37.010 --> 00:08:42.190
But when unfolded, it's
supposed to look like this.

00:08:42.190 --> 00:08:43.164
So what happens at A?

00:08:43.164 --> 00:08:45.330
If you want to connect the
light side which is alpha

00:08:45.330 --> 00:08:48.920
that's forced, you can
attach by a vertex unfolding

00:08:48.920 --> 00:08:50.455
to beta or gamma.

00:08:50.455 --> 00:08:55.320
Well, beta is impossible
because 90 plus greater than 270

00:08:55.320 --> 00:08:57.410
is greater than 360.

00:08:57.410 --> 00:09:00.300
So you would get overlap
locally at this vertex

00:09:00.300 --> 00:09:02.680
if you attach these even
if you're vertex unfolding.

00:09:02.680 --> 00:09:04.830
So you've got to
attach the gamma.

00:09:04.830 --> 00:09:08.110
Alpha plus gamma is
supposed to be exactly 360.

00:09:08.110 --> 00:09:11.540
And so vertex unfolding
doesn't buy you anything.

00:09:11.540 --> 00:09:13.240
In order to not
locally overlap here,

00:09:13.240 --> 00:09:16.869
they must fit right like that.

00:09:16.869 --> 00:09:18.410
Then the only other
condition we need

00:09:18.410 --> 00:09:21.250
is that these prisms
are long enough

00:09:21.250 --> 00:09:23.100
so that you get
overlap over here.

00:09:23.100 --> 00:09:24.650
So it's not a purely
local overlap,

00:09:24.650 --> 00:09:25.870
but it's very close by.

00:09:25.870 --> 00:09:27.750
It's the same two faces overlap.

00:09:27.750 --> 00:09:30.720
Here, they happen to
overlap here and here.

00:09:30.720 --> 00:09:33.760
If this were shorter, if
this were like this short--

00:09:33.760 --> 00:09:35.760
this is the length
of the prism here--

00:09:35.760 --> 00:09:36.850
then you'd avoid overlap.

00:09:36.850 --> 00:09:38.770
And that's this picture.

00:09:38.770 --> 00:09:42.659
So this is an unfolding of
one of the two prism halves.

00:09:42.659 --> 00:09:43.950
This is unfolding of the other.

00:09:43.950 --> 00:09:47.540
If you attach them, these
vertices as is necessary,

00:09:47.540 --> 00:09:49.150
you get overlap.

00:09:49.150 --> 00:09:50.760
Unless the prism
were short, then you

00:09:50.760 --> 00:09:54.170
would get this
kind of unfolding.

00:09:54.170 --> 00:09:55.740
So that's the proof.

00:09:55.740 --> 00:09:59.430
You can actually make the proof
even simpler, kind of nifty.

00:09:59.430 --> 00:10:02.706
Although it's less obvious
that this example exists.

00:10:02.706 --> 00:10:05.080
You can give the coordinates
and you can check it exactly

00:10:05.080 --> 00:10:07.720
and it has all the
properties you want.

00:10:07.720 --> 00:10:10.440
Each prism has been
bent a little bit.

00:10:10.440 --> 00:10:12.650
More or less the
same example, but now

00:10:12.650 --> 00:10:14.980
it has the feature that
alpha plus beta prime is

00:10:14.980 --> 00:10:17.730
greater than 360, and
alpha plus gamma prime

00:10:17.730 --> 00:10:19.830
is greater than 360.

00:10:19.830 --> 00:10:22.620
So you just can't
attach anything.

00:10:22.620 --> 00:10:25.870
Even locally, you
get pure overlap.

00:10:25.870 --> 00:10:27.960
So easy to check if
you're a computer.

00:10:27.960 --> 00:10:32.770
Easier to check and proof and
verify if you're a computer.

00:10:32.770 --> 00:10:35.840
Less easy visually.

00:10:35.840 --> 00:10:37.010
So that's what's known.

00:10:37.010 --> 00:10:39.910
Open problem-- which I
should probably write down--

00:10:39.910 --> 00:10:43.810
is if your faces
are convex polygons,

00:10:43.810 --> 00:10:46.247
is there a vertex
ununfoldable polyhedron?

00:10:46.247 --> 00:10:47.330
That, we still don't know.

00:10:47.330 --> 00:10:50.460
So the witch's hat, all
the faces are triangles.

00:10:50.460 --> 00:10:54.367
There's no edge unfolding,
but it has a vertex unfolding.

00:10:54.367 --> 00:10:55.200
These guys are nice.

00:10:55.200 --> 00:10:57.160
They're topologically
convex, but the faces

00:10:57.160 --> 00:10:58.960
are still very nonconvex.

00:10:58.960 --> 00:11:02.890
And we use that because we want
a giant angle, a reflex angle

00:11:02.890 --> 00:11:05.140
together with something to
add up to more than 360.

00:11:05.140 --> 00:11:07.015
If you're always adding
up two convex angles,

00:11:07.015 --> 00:11:08.600
you don't get that.

00:11:08.600 --> 00:11:11.690
But maybe you could combine
it with a polyhedron that's

00:11:11.690 --> 00:11:15.400
not Hamiltonian, so you have
to have three things joining it

00:11:15.400 --> 00:11:18.290
together and then you
could get more than 360?

00:11:18.290 --> 00:11:18.960
I don't know.

00:11:18.960 --> 00:11:22.660
It could be an interesting
problem to work on.

00:11:22.660 --> 00:11:24.770
But so far, it is open.

00:11:24.770 --> 00:11:26.990
So that is vertex unfolding.

00:11:29.910 --> 00:11:35.510
Next question is about
general unfolding

00:11:35.510 --> 00:11:36.920
of nonconvex polyhedra.

00:11:36.920 --> 00:11:39.670
Still it's open whether
every polyhedron, say

00:11:39.670 --> 00:11:42.270
without boundary, has
a general unfolding.

00:11:42.270 --> 00:11:44.175
Still we know that all
orthogonal polyhedra

00:11:44.175 --> 00:11:46.870
of genus zero have an unfolding.

00:11:46.870 --> 00:11:48.760
That remains the
state of the art.

00:11:48.760 --> 00:11:51.230
But we have a
better way to unfold

00:11:51.230 --> 00:11:53.910
orthogonal polyhedra
of genus zero.

00:11:53.910 --> 00:11:56.420
And this is a new paper.

00:11:56.420 --> 00:11:58.390
It's not yet online
but it will be shortly.

00:11:58.390 --> 00:12:01.140
The final version just
went to the journal.

00:12:01.140 --> 00:12:05.860
"Unfolding Orthogonal Polyhedra
with Quadratic Refinement."

00:12:05.860 --> 00:12:09.040
So two of the same authors--
Mirela Damian and Robin

00:12:09.040 --> 00:12:11.440
Flatland from the
exponential unfolding.

00:12:14.750 --> 00:12:17.610
You may recall, we saw
a solution in lecture

00:12:17.610 --> 00:12:19.250
that has exponential refinement.

00:12:19.250 --> 00:12:22.120
The number of cuts in particular
can be exponential in n

00:12:22.120 --> 00:12:23.210
in the worst case.

00:12:23.210 --> 00:12:24.980
This requires you take the grid.

00:12:24.980 --> 00:12:28.260
You refine it, at most,
quadratic number of times

00:12:28.260 --> 00:12:30.840
in each dimension.

00:12:30.840 --> 00:12:33.520
So the number of
cuts is polynomial,

00:12:33.520 --> 00:12:37.420
I guess at most, and to
the seventh if you've got

00:12:37.420 --> 00:12:40.460
n squared by n squared
by n squared by n.

00:12:40.460 --> 00:12:42.210
I think it's actually
much less than that.

00:12:42.210 --> 00:12:46.120
Probably more like n squared,
but I need to be careful.

00:12:46.120 --> 00:12:49.070
So I want to cover
this solution.

00:12:49.070 --> 00:12:52.262
It's a simple variation
actually on the previous one,

00:12:52.262 --> 00:12:53.970
but also there's some
questions about how

00:12:53.970 --> 00:12:55.210
the exponential one works.

00:12:55.210 --> 00:12:57.159
I want to go through
that one more time.

00:12:57.159 --> 00:12:58.950
We have new figures
for it from this paper.

00:12:58.950 --> 00:13:02.370
So it looks a little different,
maybe a little bit clearer.

00:13:02.370 --> 00:13:04.130
That was our girl.

00:13:04.130 --> 00:13:05.320
I need my hands.

00:13:10.660 --> 00:13:14.155
Remember, the general idea
was to slice your polyhedron

00:13:14.155 --> 00:13:17.280
in one direction so you end
up with these bands, strips.

00:13:17.280 --> 00:13:21.260
And then you visit the
strips in a treelike fashion.

00:13:21.260 --> 00:13:23.380
And in particular,
at the leaves,

00:13:23.380 --> 00:13:27.160
like the closest to
you, you've got a band

00:13:27.160 --> 00:13:28.950
and then you've
got a front face.

00:13:28.950 --> 00:13:32.900
And so that would look
something like this little box.

00:13:32.900 --> 00:13:39.570
So you've got a band that
goes around-- which way is it?

00:13:39.570 --> 00:13:42.390
Band is this way it.

00:13:42.390 --> 00:13:45.180
Should be an x and z.

00:13:45.180 --> 00:13:46.840
And then there's
the front face which

00:13:46.840 --> 00:13:49.090
here is drawn on the back.

00:13:49.090 --> 00:13:53.350
Those are the five out
of six faces of the box

00:13:53.350 --> 00:13:54.660
that are actually present.

00:13:54.660 --> 00:13:57.450
This face that's closest
to us is actually

00:13:57.450 --> 00:13:59.790
attached to another band.

00:13:59.790 --> 00:14:03.480
You could have leaves on
this side or that side.

00:14:03.480 --> 00:14:04.990
So what do we do?

00:14:04.990 --> 00:14:09.290
We enter at S and
we exit at T. And we

00:14:09.290 --> 00:14:12.680
are told that the first
turn you make from S

00:14:12.680 --> 00:14:14.090
should be a right turn.

00:14:14.090 --> 00:14:18.210
And the last turn before
T should be a left turn.

00:14:18.210 --> 00:14:20.910
And you start in
the unfolding, you

00:14:20.910 --> 00:14:22.566
will start going
vertical on S, that's

00:14:22.566 --> 00:14:24.316
why you should turn
right because we never

00:14:24.316 --> 00:14:25.570
want to turn left.

00:14:25.570 --> 00:14:29.580
We never want to go left in
the unfolding, which is here.

00:14:29.580 --> 00:14:32.090
And we also want to end in
the vertical state for T

00:14:32.090 --> 00:14:35.020
so that we can chain
these together.

00:14:35.020 --> 00:14:40.270
So we started S. We're told to
turn right, which we do here.

00:14:40.270 --> 00:14:41.930
Then we're basically
going to zigzag.

00:14:41.930 --> 00:14:45.470
And if you check along this
surface, we turn right.

00:14:45.470 --> 00:14:47.800
We go here, up there.

00:14:47.800 --> 00:14:51.820
And then we turn
left, and then right.

00:14:51.820 --> 00:14:54.440
And then this is a
left because we're

00:14:54.440 --> 00:14:57.040
supposed to be
doing it from below.

00:14:57.040 --> 00:15:02.080
And then a right with that
red thing, then a left, right,

00:15:02.080 --> 00:15:06.460
down here, and a
left, and we're done.

00:15:06.460 --> 00:15:09.235
And the number balances
out, so we start vertical,

00:15:09.235 --> 00:15:10.610
we end vertical.

00:15:10.610 --> 00:15:16.054
And then when we're done with
all these things, we thicken.

00:15:16.054 --> 00:15:18.220
It's not drawn here, but
these strips get thickened.

00:15:18.220 --> 00:15:20.680
And you end up attaching
these fatter versions,

00:15:20.680 --> 00:15:22.680
but basically you're
following the same path.

00:15:22.680 --> 00:15:23.840
We don't thicken
it at the beginning

00:15:23.840 --> 00:15:25.256
because we're
actually going to do

00:15:25.256 --> 00:15:27.730
this many times
on the same cell.

00:15:27.730 --> 00:15:30.150
And then we abstract
that picture

00:15:30.150 --> 00:15:34.240
to this iconography which says--
this I didn't talk about much

00:15:34.240 --> 00:15:35.660
in lecture, which
says, you should

00:15:35.660 --> 00:15:38.790
start by turning right
in S, and then you

00:15:38.790 --> 00:15:42.170
should end by turning
left and then visiting T.

00:15:42.170 --> 00:15:44.640
So that's one picture.

00:15:44.640 --> 00:15:49.100
But it depends
where you're going.

00:15:49.100 --> 00:15:51.770
There are actually eight
different versions.

00:15:51.770 --> 00:15:53.780
I showed you this one.

00:15:53.780 --> 00:15:55.930
But all those combinations
have to happen.

00:15:55.930 --> 00:16:00.600
And the top ones are when
you're all the way forward.

00:16:00.600 --> 00:16:02.950
The bottom ones are where
you're all the way back

00:16:02.950 --> 00:16:07.420
in these slabs, so that's
slightly different.

00:16:07.420 --> 00:16:11.390
And then there's whether S is on
the left or S is on the right,

00:16:11.390 --> 00:16:13.840
relative to T. And then
there's whether you

00:16:13.840 --> 00:16:17.790
start by turning to
the right from S or end

00:16:17.790 --> 00:16:19.320
by turning to the left.

00:16:19.320 --> 00:16:21.170
T is always the opposite.

00:16:21.170 --> 00:16:24.010
But those are the
eight possibilities

00:16:24.010 --> 00:16:25.520
from three different choices.

00:16:25.520 --> 00:16:26.790
Are you far forward?

00:16:26.790 --> 00:16:28.380
Are you far back?

00:16:28.380 --> 00:16:31.550
Do you turn right from
S or do you turn left?

00:16:31.550 --> 00:16:33.720
And is S to the left
or is S to the right?

00:16:33.720 --> 00:16:35.780
That's why you have
eight combinations.

00:16:35.780 --> 00:16:38.280
They all look
basically the same,

00:16:38.280 --> 00:16:39.675
but those are your base cases.

00:16:42.190 --> 00:16:46.670
So this is still all
review of the old version.

00:16:46.670 --> 00:16:51.240
And then the last part of
the old method is non-leaves.

00:16:51.240 --> 00:16:53.960
So in general, you
have a band which

00:16:53.960 --> 00:16:55.980
is here drawn as
two separate pieces,

00:16:55.980 --> 00:16:58.162
but really this is one band.

00:16:58.162 --> 00:16:59.370
The bands are easy to unfold.

00:16:59.370 --> 00:17:01.450
They go straight.

00:17:01.450 --> 00:17:03.400
But then you have
all these children.

00:17:03.400 --> 00:17:05.500
So you have your parent
which is the S and T part.

00:17:05.500 --> 00:17:07.990
You have to start
here and end here.

00:17:07.990 --> 00:17:10.460
Recursively, you want to
visit this whole subtree.

00:17:10.460 --> 00:17:14.114
So you might have children that
are on the front side, children

00:17:14.114 --> 00:17:15.155
that are on the backside.

00:17:19.119 --> 00:17:21.990
And again, we're told we
should initially turn right.

00:17:21.990 --> 00:17:25.310
So if we turn right, we
visit the first thing.

00:17:25.310 --> 00:17:28.180
We tell this leaf or
this child, actually--

00:17:28.180 --> 00:17:29.850
this is not necessarily a leaf.

00:17:29.850 --> 00:17:32.050
We tell this child that the
next thing we want to do

00:17:32.050 --> 00:17:34.930
is turn to the left because
we just turned right.

00:17:34.930 --> 00:17:37.290
Actually, we just
turned right twice,

00:17:37.290 --> 00:17:40.412
so we've just gone right, right.

00:17:40.412 --> 00:17:42.120
We'll actually be
unfolding initially up,

00:17:42.120 --> 00:17:43.510
so we turn right twice.

00:17:43.510 --> 00:17:45.610
Now, we better
turn left and then

00:17:45.610 --> 00:17:51.730
we will end up pointing
I believe down,

00:17:51.730 --> 00:17:53.597
because initially this
was pointing down.

00:17:53.597 --> 00:17:56.180
After you do this construction,
you'll be pointing down again.

00:17:56.180 --> 00:17:58.210
And that's why you
want to turn left here.

00:17:58.210 --> 00:17:59.660
So you unroll this thing.

00:17:59.660 --> 00:18:03.670
You can verify you are
actually just zigzagging.

00:18:03.670 --> 00:18:05.950
And so you go back and
forth through these.

00:18:05.950 --> 00:18:08.110
Verify this always
proceeds to the right.

00:18:08.110 --> 00:18:11.060
But we're using different
iconography here.

00:18:11.060 --> 00:18:14.370
This is an S on the left
that initially turns left.

00:18:14.370 --> 00:18:17.420
This is an S on the right
that initially turns right.

00:18:17.420 --> 00:18:22.250
That's why we need the different
forms of the recursive call.

00:18:22.250 --> 00:18:24.430
This is a picture where
initially we turn right on S

00:18:24.430 --> 00:18:26.721
and S is to the right, but
there are different versions

00:18:26.721 --> 00:18:29.324
of this picture just
like in the base cases

00:18:29.324 --> 00:18:31.240
where S is to the left
and where you initially

00:18:31.240 --> 00:18:32.860
have to turn left.

00:18:32.860 --> 00:18:33.860
But they look the same.

00:18:33.860 --> 00:18:36.450
You just visit them back
and forth like this.

00:18:36.450 --> 00:18:39.180
At some point, you finish
the front children.

00:18:39.180 --> 00:18:40.512
Then you go up.

00:18:40.512 --> 00:18:41.970
And here, it's a
little bit shifted

00:18:41.970 --> 00:18:45.020
but these would
normally be aligned.

00:18:45.020 --> 00:18:46.840
Then you have to visit
the top children.

00:18:46.840 --> 00:18:50.910
You do that by visiting
and going back and forth.

00:18:50.910 --> 00:18:54.190
Then, of course, when
you're done here,

00:18:54.190 --> 00:18:57.370
you have to unwind
everything you did.

00:18:57.370 --> 00:18:58.800
Then we go over here.

00:18:58.800 --> 00:19:00.940
We visit that guy,
back and forth.

00:19:00.940 --> 00:19:03.390
Eventually, we will end
up on the inside here,

00:19:03.390 --> 00:19:07.400
and having doubled everything,
we come back out to T.

00:19:07.400 --> 00:19:10.940
And all the time, we're
unfolding to the right.

00:19:10.940 --> 00:19:13.480
Now, what can we say about this?

00:19:13.480 --> 00:19:19.410
Well, what sucks is all of these
children get visited twice.

00:19:19.410 --> 00:19:22.210
And that's why you're doubling
at every recursive level.

00:19:22.210 --> 00:19:33.114
And so if your recursion tree
looks like a long binary tree,

00:19:33.114 --> 00:19:34.155
then you get exponential.

00:19:40.380 --> 00:19:41.220
Not quite.

00:19:41.220 --> 00:19:43.440
We'll come back to that.

00:19:43.440 --> 00:19:45.252
Here's an example of
it being exponential

00:19:45.252 --> 00:19:46.210
with this kind of tree.

00:19:46.210 --> 00:19:48.310
It's a little hard to
draw too many levels deep.

00:19:48.310 --> 00:19:53.440
So we have one level deep
and then another level deep.

00:19:53.440 --> 00:19:56.700
But you'll notice
that it's not uniform.

00:19:56.700 --> 00:20:00.030
This leaf gets visited
exponentially many times,

00:20:00.030 --> 00:20:02.650
but this one still
only got visited once.

00:20:02.650 --> 00:20:04.552
Of course, it's shallower.

00:20:04.552 --> 00:20:06.510
But even these two leaves
are at the same level

00:20:06.510 --> 00:20:08.760
and they did not get visited
the same number of times.

00:20:08.760 --> 00:20:10.450
So there's some hope
of improving things

00:20:10.450 --> 00:20:11.325
as you might imagine.

00:20:14.270 --> 00:20:17.340
So this is where we go.

00:20:17.340 --> 00:20:22.050
There's two observations
here, two ideas.

00:20:22.050 --> 00:20:26.020
Maybe I'll tell you
where we started.

00:20:26.020 --> 00:20:30.750
I was I think-- I can
never remember years.

00:20:30.750 --> 00:20:34.890
I was teaching this class
either two or five years ago

00:20:34.890 --> 00:20:38.269
and I had idea number one.

00:20:38.269 --> 00:20:40.310
And we worked on it in
the open problems session,

00:20:40.310 --> 00:20:41.230
but it was not enough.

00:20:41.230 --> 00:20:44.210
Idea number one is
just part of the story.

00:20:44.210 --> 00:20:46.850
And it's an idea that comes
from the other graduate

00:20:46.850 --> 00:20:49.660
class I teach which is
heavy-light decomposition

00:20:49.660 --> 00:20:51.100
and advanced data structures.

00:20:51.100 --> 00:20:53.030
So this is a very
common technique

00:20:53.030 --> 00:20:54.960
in advanced data structures.

00:20:54.960 --> 00:20:57.562
It goes back to
Sleator and Tarjan,

00:20:57.562 --> 00:21:01.570
if you've ever heard of splay
trees or link-cut trees.

00:21:01.570 --> 00:21:06.830
It's that era which was
the '80s, I believe, '83.

00:21:06.830 --> 00:21:07.830
It's a very useful tool.

00:21:07.830 --> 00:21:10.630
Whenever you have
general tree structure

00:21:10.630 --> 00:21:12.439
and you want to
make it balanced,

00:21:12.439 --> 00:21:14.230
you should think
heavy-light decomposition.

00:21:14.230 --> 00:21:16.900
There are actually a few
ways to balance a tree,

00:21:16.900 --> 00:21:19.960
but heavy-light decomposition
is usually the most powerful.

00:21:19.960 --> 00:21:27.390
So essentially
what it does is say

00:21:27.390 --> 00:21:30.780
if I could just treat
this thing, this path

00:21:30.780 --> 00:21:35.320
as a single node, and then treat
these guys as separate nodes,

00:21:35.320 --> 00:21:36.740
then I'd kind of be balanced.

00:21:36.740 --> 00:21:39.950
It would be like one super node
and then a bunch of children

00:21:39.950 --> 00:21:41.550
hanging off of it.

00:21:41.550 --> 00:21:44.370
One, two, three, four.

00:21:44.370 --> 00:21:47.140
So that's the picture
I'd like to make.

00:21:47.140 --> 00:21:50.759
I'm going to contract paths,
only paths of my tree.

00:21:50.759 --> 00:21:52.300
And it turns out
there's always a way

00:21:52.300 --> 00:21:54.730
to take paths, contract
them into single nodes,

00:21:54.730 --> 00:22:01.330
so that the resulting thing
has height at most log n,

00:22:01.330 --> 00:22:03.060
no matter what tree
you start with.

00:22:03.060 --> 00:22:05.520
And heavy-light decomposition
is a way to do this.

00:22:05.520 --> 00:22:07.810
It's very simple to define.

00:22:07.810 --> 00:22:15.435
For every node, you define
the idea of a heavy child.

00:22:19.890 --> 00:22:31.150
This is a child with more
than half the weight.

00:22:31.150 --> 00:22:39.706
The weight of a subtree is the
number of descendant nodes,

00:22:39.706 --> 00:22:41.330
so the number of
nodes in that subtree.

00:22:44.490 --> 00:22:47.700
So if we look at this
picture, you've got this node.

00:22:47.700 --> 00:22:50.760
It has one, two, three, four,
five, six, seven, eight,

00:22:50.760 --> 00:22:53.490
nine nodes below it.

00:22:53.490 --> 00:22:57.400
This subtree only has one,
so this subtree has seven.

00:22:57.400 --> 00:23:00.400
Seven is bigger
than half of nine.

00:23:00.400 --> 00:23:02.640
Most of the weight
is to the left.

00:23:02.640 --> 00:23:06.120
So we call this edge heavy.

00:23:06.120 --> 00:23:10.720
Similarly, this edge is
heavy because this is five.

00:23:10.720 --> 00:23:12.770
Five is more than half of seven.

00:23:12.770 --> 00:23:16.100
This one's only
three nodes below it.

00:23:16.100 --> 00:23:21.230
That is still more than half
because half of this is 2.5.

00:23:21.230 --> 00:23:23.760
So this edge is heavy.

00:23:23.760 --> 00:23:25.400
This one is not heavy.

00:23:25.400 --> 00:23:30.110
So actually, in
the real picture,

00:23:30.110 --> 00:23:31.960
it would look like this.

00:23:31.960 --> 00:23:35.259
This is a heavy path and
this guy's all by itself,

00:23:35.259 --> 00:23:36.300
so there's one more node.

00:23:36.300 --> 00:23:40.660
But it has the same effect
of balancing the tree.

00:23:40.660 --> 00:23:43.602
So what's the point?

00:23:43.602 --> 00:23:44.810
In general, I have some tree.

00:23:44.810 --> 00:23:46.930
In general, I might
have many children.

00:23:46.930 --> 00:23:49.950
No idea how many
children are out there.

00:23:49.950 --> 00:23:52.580
So every node can
have many children

00:23:52.580 --> 00:23:55.350
and these correspond to
the various bands that

00:23:55.350 --> 00:23:58.555
are attached to my parent band.

00:24:02.140 --> 00:24:04.080
So that's heavy child.

00:24:04.080 --> 00:24:12.630
In general though, every node
has at most one heavy child

00:24:12.630 --> 00:24:16.110
because you can't have
more than two halves.

00:24:16.110 --> 00:24:18.520
If I have more than half
of the weight in one child,

00:24:18.520 --> 00:24:21.860
I can't have more than half of
the weight in another child.

00:24:21.860 --> 00:24:24.930
So every node has at
most one heavy child.

00:24:24.930 --> 00:24:28.600
These edges connecting nodes
and their heavy children

00:24:28.600 --> 00:24:30.040
we call heavy edges.

00:24:34.080 --> 00:24:35.950
And whenever we
have a node, there's

00:24:35.950 --> 00:24:38.640
at most one heavy edge
going down from it,

00:24:38.640 --> 00:24:41.420
so heavy edges form heavy paths.

00:24:41.420 --> 00:24:42.170
That's the point.

00:24:42.170 --> 00:24:45.915
So this red thing is
called a heavy path.

00:24:50.470 --> 00:24:51.730
Cool.

00:24:51.730 --> 00:24:55.460
So what do we know
about heavy paths?

00:24:55.460 --> 00:24:59.200
The other edges, I
should say, these guys,

00:24:59.200 --> 00:25:01.260
we call light edges.

00:25:01.260 --> 00:25:02.890
This is the heavy-light
decomposition,

00:25:02.890 --> 00:25:05.370
so every edge is
either heavy or light.

00:25:05.370 --> 00:25:07.370
It could be a node
only has light children

00:25:07.370 --> 00:25:08.620
because it's well-distributed.

00:25:08.620 --> 00:25:11.120
In the worst case, it
has one heavy child,

00:25:11.120 --> 00:25:13.400
one heavy edge coming out of it.

00:25:13.400 --> 00:25:16.880
So we get heavy paths.

00:25:16.880 --> 00:25:19.835
I guess I'll say heavy
edges form paths.

00:25:25.350 --> 00:25:27.300
And if we look at
what I normally

00:25:27.300 --> 00:25:35.730
call the light depth
of a node, this

00:25:35.730 --> 00:25:38.600
is if I look at a
node in this tree

00:25:38.600 --> 00:25:40.770
and I measure how
many light edges do

00:25:40.770 --> 00:25:43.890
I have to traverse in order to
get from the root of the tree

00:25:43.890 --> 00:25:46.455
to that node, here it's
only one light edge.

00:25:46.455 --> 00:25:52.990
The number of light edges follow
on any path is at most log n,

00:25:52.990 --> 00:25:58.120
log base 2 of n, because every
time I follow a light edge,

00:25:58.120 --> 00:26:00.700
I know that I started
with say end nodes.

00:26:00.700 --> 00:26:01.720
I follow a light edge.

00:26:01.720 --> 00:26:06.110
I know that I have at most half
n nodes because my weight goes

00:26:06.110 --> 00:26:07.210
down by half.

00:26:07.210 --> 00:26:11.160
If I start with n, I can only
reduce by a factor of 2 log n

00:26:11.160 --> 00:26:12.730
times before I run out of nodes.

00:26:12.730 --> 00:26:16.340
Then I'm in a leaf when I get
down to the weight of one.

00:26:16.340 --> 00:26:19.030
So light depth of any
node is at most log n

00:26:19.030 --> 00:26:30.020
because weight halves every
step, every light step.

00:26:33.980 --> 00:26:37.230
So this is why, if you
contract the heavy paths

00:26:37.230 --> 00:26:41.955
to single nodes, the depth
of the remaining tree

00:26:41.955 --> 00:26:43.560
is only log n.

00:26:43.560 --> 00:26:44.820
So what does this tell us?

00:26:44.820 --> 00:26:47.630
If I could somehow
deal with paths

00:26:47.630 --> 00:26:52.350
efficiently and not
feel the recursive pain

00:26:52.350 --> 00:26:54.790
that we're getting here
from doubling everything

00:26:54.790 --> 00:26:59.210
along a path, then I
can chain them together

00:26:59.210 --> 00:27:01.000
in the usual bad recursive way.

00:27:01.000 --> 00:27:03.960
I can afford to double
on a balance tree.

00:27:03.960 --> 00:27:06.890
So if I could somehow treat
these paths as single things,

00:27:06.890 --> 00:27:07.630
we'd be all set.

00:27:07.630 --> 00:27:10.540
That was idea number one
and that sat for years.

00:27:10.540 --> 00:27:13.080
I knew this should be possible.

00:27:13.080 --> 00:27:18.110
But what we were missing
was idea number two.

00:27:18.110 --> 00:27:19.240
It's funny.

00:27:19.240 --> 00:27:21.060
If you stare at this
picture long enough,

00:27:21.060 --> 00:27:22.830
it's actually kind of obvious.

00:27:22.830 --> 00:27:26.840
It requires more
work after the idea.

00:27:26.840 --> 00:27:29.830
So here, the same
picture as before.

00:27:29.830 --> 00:27:32.880
I spread it out a little bit.

00:27:32.880 --> 00:27:35.910
So we end up visiting
this guy last.

00:27:35.910 --> 00:27:38.210
And then we end up
recursively visiting this one

00:27:38.210 --> 00:27:41.150
a second time, then
this one a second time,

00:27:41.150 --> 00:27:42.500
then this one a second time.

00:27:42.500 --> 00:27:43.920
We go down here.

00:27:43.920 --> 00:27:46.410
We go around here.

00:27:46.410 --> 00:27:48.210
Visit this one a second time.

00:27:48.210 --> 00:27:49.930
Unwind.

00:27:49.930 --> 00:27:53.120
Visit this one a second
time, this one a second time,

00:27:53.120 --> 00:27:55.372
this one a second
time, and we're up.

00:27:55.372 --> 00:27:56.830
Did I visit them
all a second time?

00:28:03.680 --> 00:28:06.190
No.

00:28:06.190 --> 00:28:08.820
There's one that I didn't
visit a second time, which

00:28:08.820 --> 00:28:11.940
is the last child.

00:28:11.940 --> 00:28:14.480
I only visited that one once.

00:28:14.480 --> 00:28:19.400
And that's all we need is
one child because I only

00:28:19.400 --> 00:28:21.550
need to do a path efficiently.

00:28:21.550 --> 00:28:24.800
So I'm recursively visiting
most of the children here.

00:28:24.800 --> 00:28:26.830
Those are going to
be my light children.

00:28:26.830 --> 00:28:28.630
The one heavy
child, I want to aim

00:28:28.630 --> 00:28:32.480
to visit that one last because
that one's only visited once

00:28:32.480 --> 00:28:35.597
so it doesn't get recursively
doubled at this level.

00:28:35.597 --> 00:28:37.930
Of course, the higher up the
level, it will get doubled.

00:28:37.930 --> 00:28:40.310
But there's only log n levels
we're going to get doubled,

00:28:40.310 --> 00:28:43.590
so we'll only add a factor of n.

00:28:43.590 --> 00:28:55.080
Idea number two is that the
last child gets visited only one

00:28:55.080 --> 00:28:56.120
at this recursive level.

00:29:03.564 --> 00:29:05.230
And if you've taken
an algorithms class,

00:29:05.230 --> 00:29:06.729
you know recursively
visiting things

00:29:06.729 --> 00:29:09.390
once versus twice
makes a big difference.

00:29:09.390 --> 00:29:13.960
Here it's a matter of doubling
or just staying the same.

00:29:13.960 --> 00:29:17.360
If we can rearrange to visit
these children first, then do

00:29:17.360 --> 00:29:19.890
this one last, then visit
this child first, then do

00:29:19.890 --> 00:29:22.196
this one last, then visit
this child first, then do

00:29:22.196 --> 00:29:26.300
this one last, and then do all
the children in whatever order,

00:29:26.300 --> 00:29:29.890
then we'll guarantee that this
path doesn't get recursively

00:29:29.890 --> 00:29:31.870
refined at this
level so it's really

00:29:31.870 --> 00:29:34.400
being treated as a
single node basically.

00:29:34.400 --> 00:29:36.520
And that lets you tie
together these unfoldings

00:29:36.520 --> 00:29:38.090
in an efficient way.

00:29:38.090 --> 00:29:41.350
The only issue is I need to be
able-- this construction isn't

00:29:41.350 --> 00:29:46.220
enough because this construction
basically forced this one

00:29:46.220 --> 00:29:49.030
to be the last child
to get visited.

00:29:49.030 --> 00:29:52.210
I need to be able to
control which child is last

00:29:52.210 --> 00:29:54.380
visited because the
heavy property is

00:29:54.380 --> 00:29:55.600
a property of the tree.

00:29:55.600 --> 00:29:57.830
One of these guys,
maybe this one is heavy.

00:29:57.830 --> 00:29:59.020
Maybe that one's heavy.

00:29:59.020 --> 00:30:02.260
We've got to be
able to end on that.

00:30:02.260 --> 00:30:04.180
So there are two cases.

00:30:04.180 --> 00:30:08.290
First case is that we always
start from the bottom here.

00:30:08.290 --> 00:30:13.770
And first case is
that on the top side

00:30:13.770 --> 00:30:18.190
is where the heavy child is.

00:30:18.190 --> 00:30:21.190
So this is the easy case because
the bottom, we don't care.

00:30:21.190 --> 00:30:23.910
We just visit the children
in whatever order's natural.

00:30:23.910 --> 00:30:25.190
Then we come up.

00:30:25.190 --> 00:30:28.464
And basically, we have the
freedom to spin around here.

00:30:28.464 --> 00:30:29.880
We have to turn
left, but we could

00:30:29.880 --> 00:30:33.680
either choose to immediately
go up here or keep going

00:30:33.680 --> 00:30:35.830
and go up here, or keep
going and go up here.

00:30:35.830 --> 00:30:37.680
That would visit
that one too early.

00:30:37.680 --> 00:30:38.650
Or go here.

00:30:38.650 --> 00:30:41.000
Turns out this is
the right choice.

00:30:41.000 --> 00:30:43.320
But we had freedom to just
spin around and choose

00:30:43.320 --> 00:30:44.650
when to go up.

00:30:44.650 --> 00:30:45.490
Just try them all.

00:30:45.490 --> 00:30:48.544
One of them will
end up being last.

00:30:48.544 --> 00:30:49.960
Basically, you
want this guy to be

00:30:49.960 --> 00:30:52.540
in the middle between
where you start

00:30:52.540 --> 00:30:55.620
and the one just to the
left here because you're

00:30:55.620 --> 00:30:58.280
kind of rainbowing
back and forth,

00:30:58.280 --> 00:31:00.900
zeroing in on the last guy.

00:31:00.900 --> 00:31:05.760
And just by pigeonholing, I
suppose, one of these choices

00:31:05.760 --> 00:31:10.530
will work because there's
k choices you could make

00:31:10.530 --> 00:31:13.030
on when to turn up that each
result in a different guy being

00:31:13.030 --> 00:31:13.850
last.

00:31:13.850 --> 00:31:15.990
And so one of them corresponds
to the correct one.

00:31:15.990 --> 00:31:18.330
That's easy to figure
out which one it is.

00:31:18.330 --> 00:31:20.260
So if it's on the top
side, it's really easy.

00:31:20.260 --> 00:31:22.817
You just pick it.

00:31:22.817 --> 00:31:23.650
This would be great.

00:31:23.650 --> 00:31:25.524
This would actually give
us linear refinement

00:31:25.524 --> 00:31:27.400
if we only had this case.

00:31:27.400 --> 00:31:34.920
The other case is when the
guy we want to make last,

00:31:34.920 --> 00:31:38.820
the heavy child, is
on the bottom side.

00:31:38.820 --> 00:31:40.661
In this case, we
need to do more work.

00:31:40.661 --> 00:31:42.410
So this is basically
the old construction.

00:31:42.410 --> 00:31:44.900
Here we don't really
have freedom from S.

00:31:44.900 --> 00:31:47.890
We can't just bypass this
guy because it will actually

00:31:47.890 --> 00:31:49.490
be hard to get him later.

00:31:49.490 --> 00:31:53.070
So we've got to visit
him and back and forth.

00:31:53.070 --> 00:31:55.690
But the one thing we could
do is just omit a child,

00:31:55.690 --> 00:31:58.270
just forget about
it for a while.

00:31:58.270 --> 00:31:59.355
Don't visit it.

00:31:59.355 --> 00:32:00.980
Visit everything else
in whatever order

00:32:00.980 --> 00:32:01.950
feels natural to you.

00:32:04.500 --> 00:32:07.790
And then we're going
to splice this guy in.

00:32:07.790 --> 00:32:10.770
So we'll see where
does the path go.

00:32:10.770 --> 00:32:15.850
At some point, it will go
above this proposed last guy.

00:32:15.850 --> 00:32:20.440
And what we're going to do,
which is on the next slide,

00:32:20.440 --> 00:32:26.140
is on the return trip-- so
remember we have this picture.

00:32:26.140 --> 00:32:28.590
We come out here.

00:32:28.590 --> 00:32:30.540
Then we recursively
double everything.

00:32:30.540 --> 00:32:34.290
So at some point, we are
coming here, doubling.

00:32:34.290 --> 00:32:36.730
And at that point, we turn in.

00:32:39.570 --> 00:32:44.390
But if S and T are
aligned like this,

00:32:44.390 --> 00:32:45.640
we are pointing the wrong way.

00:32:45.640 --> 00:32:48.390
We want it to get here,
but it doesn't even

00:32:48.390 --> 00:32:49.810
look like we're
in the same side.

00:32:49.810 --> 00:32:51.290
But we are.

00:32:51.290 --> 00:32:56.040
We just have to recursively
double everything again.

00:32:56.040 --> 00:32:59.040
In the end, when you recursively
double everything again,

00:32:59.040 --> 00:33:01.670
you will be here.

00:33:01.670 --> 00:33:03.860
And we haven't
finished doubling here.

00:33:03.860 --> 00:33:07.600
But in the end, you will
come out here and exit at T.

00:33:07.600 --> 00:33:10.360
So overall, these guys which
haven't been visited yet,

00:33:10.360 --> 00:33:13.000
they'll end up being
doubled from this procedure.

00:33:13.000 --> 00:33:15.640
These guys will end
up being quadrupled.

00:33:15.640 --> 00:33:20.156
So we're doing four recursive
calls for most of the children.

00:33:20.156 --> 00:33:22.030
Some of them might get
lucky and only double.

00:33:22.030 --> 00:33:27.290
But all we care about is if
this guy only gets visited once.

00:33:27.290 --> 00:33:29.710
That's the key.

00:33:29.710 --> 00:33:32.440
Because this will
be recursively here.

00:33:32.440 --> 00:33:33.440
It's hard to unwind.

00:33:33.440 --> 00:33:35.890
But then you'll end up on
the inside of this channel.

00:33:35.890 --> 00:33:37.730
Then you'll end up
visiting this guy.

00:33:37.730 --> 00:33:39.480
Then you'll end up
visiting this guy.

00:33:39.480 --> 00:33:40.580
And then you get out at T.

00:33:40.580 --> 00:33:42.490
So you won't come back to here.

00:33:42.490 --> 00:33:44.590
That's the key.

00:33:44.590 --> 00:33:46.234
That's all we need.

00:33:46.234 --> 00:33:48.150
You can write down a
recurrence at this point.

00:33:55.280 --> 00:33:57.460
If you look at the
level of refinement

00:33:57.460 --> 00:34:01.380
for an n vertex polyhedron
or an n slab polyhedron,

00:34:01.380 --> 00:34:04.990
it would be-- n, we'll
say is the number of nodes

00:34:04.990 --> 00:34:07.720
in the tree of
slabs, this picture.

00:34:07.720 --> 00:34:09.980
In general, that is
proportional to the number

00:34:09.980 --> 00:34:12.960
of vertices in the polyhedron.

00:34:12.960 --> 00:34:20.000
In the worst case, it's going
to be the max of two things-- R

00:34:20.000 --> 00:34:25.199
n minus 1, and 4
times R of n over 2.

00:34:28.469 --> 00:34:33.920
Well, I should say
n sub i, max over i.

00:34:33.920 --> 00:34:41.250
So what I mean to say here--
this is also technically an sub

00:34:41.250 --> 00:34:42.889
i.

00:34:42.889 --> 00:34:46.469
This is an upper
bound certainly.

00:34:46.469 --> 00:34:51.860
So if we look at the recursion,
how much refinement we need,

00:34:51.860 --> 00:34:53.790
the worst refinement
over the whole tree

00:34:53.790 --> 00:34:56.050
is the max of all
of its subtrees.

00:34:56.050 --> 00:34:59.390
So there's a [INAUDIBLE] here, a
[INAUDIBLE] here, and then also

00:34:59.390 --> 00:35:02.720
of course, what we need
to do within the node.

00:35:02.720 --> 00:35:05.770
And on the one hand,
there's the heavy situation,

00:35:05.770 --> 00:35:07.240
the heavy edge.

00:35:07.240 --> 00:35:10.230
That only decreases the
size of the tree by 1.

00:35:10.230 --> 00:35:12.320
But it only gets
recursively visited

00:35:12.320 --> 00:35:15.870
one time, 1 times
R of n minus 1.

00:35:15.870 --> 00:35:17.470
There's the other
light children.

00:35:17.470 --> 00:35:20.710
These are all light children.

00:35:20.710 --> 00:35:23.370
n sub i represents the number
of nodes in that child.

00:35:23.370 --> 00:35:27.752
We know that this
is at most n over 2

00:35:27.752 --> 00:35:29.710
because we know that at
most half of the weight

00:35:29.710 --> 00:35:31.770
lives in the light child.

00:35:31.770 --> 00:35:34.940
Now these get recursively
visited at most four times,

00:35:34.940 --> 00:35:35.730
up to four times.

00:35:35.730 --> 00:35:37.730
Worst case, it
will be four times.

00:35:40.580 --> 00:35:43.680
In this recurrence, this
first term doesn't matter.

00:35:43.680 --> 00:35:45.590
R of n is at most
R of n minus 1.

00:35:45.590 --> 00:35:47.250
Yeah, big deal.

00:35:47.250 --> 00:35:49.850
That's just saying R
of n increases with n.

00:35:49.850 --> 00:35:54.330
So really, this is going to be--
and then the max disappears.

00:35:54.330 --> 00:35:59.720
All we need is this is at
most 4 times R of n over 2.

00:35:59.720 --> 00:36:00.830
And this is a recurrence.

00:36:00.830 --> 00:36:06.560
If you read CLRS, this
follows the master theorem

00:36:06.560 --> 00:36:11.424
and you know immediately
this is order n squared.

00:36:11.424 --> 00:36:13.590
It'd be theta n squared,
but this is an upper bound.

00:36:13.590 --> 00:36:15.881
In the worst case, it will
actually be theta n squared.

00:36:15.881 --> 00:36:20.060
So the amount of refinement
is at most n squared.

00:36:20.060 --> 00:36:21.960
If this is not obvious
to you, an easy way

00:36:21.960 --> 00:36:28.630
to imagine it is you start
with something of size n,

00:36:28.630 --> 00:36:34.590
you're visiting four times
something of size n over 2.

00:36:34.590 --> 00:36:37.480
This is called a recurrence
tree, recursion tree.

00:36:37.480 --> 00:36:39.890
Each of these visits four
times something of size

00:36:39.890 --> 00:36:45.480
n over 4 and so on.

00:36:45.480 --> 00:36:49.520
Obviously, log n levels here.

00:36:49.520 --> 00:36:52.770
And at the bottom, you're
going to have a bunch of ones.

00:36:52.770 --> 00:36:54.730
That's when you stop recursing.

00:36:54.730 --> 00:36:56.530
And if you add up
everything level

00:36:56.530 --> 00:37:03.120
by level, how much
work am I doing here

00:37:03.120 --> 00:37:05.830
and how much work
am I doing here?

00:37:05.830 --> 00:37:07.840
2n.

00:37:07.840 --> 00:37:09.600
How much work am I doing here?

00:37:09.600 --> 00:37:13.160
It gets harder to add,
but there are 4 squared,

00:37:13.160 --> 00:37:16.070
16 things, each n over 4.

00:37:16.070 --> 00:37:17.070
So it's 4n.

00:37:17.070 --> 00:37:20.080
In general, it goes up by
a factor of 2 every time

00:37:20.080 --> 00:37:25.270
which means you're
dominated by the last layer.

00:37:25.270 --> 00:37:30.030
And if you count, it's
going to be n squared

00:37:30.030 --> 00:37:35.590
because this is 2 to the
0, 2 to the 1, 2 to the 2.

00:37:35.590 --> 00:37:41.610
After you get to log n,
it's 2 to the log n times n,

00:37:41.610 --> 00:37:43.759
so that is n squared.

00:37:43.759 --> 00:37:45.300
And this is a
geometric series if you

00:37:45.300 --> 00:37:46.710
want to add all
these numbers up.

00:37:46.710 --> 00:37:50.510
And so it's 2 times n squared.

00:37:50.510 --> 00:37:53.650
So that's the
proof of this bound

00:37:53.650 --> 00:37:56.680
and that's how you get
quadratic refinement.

00:37:56.680 --> 00:38:00.470
So either idea is kind
of easy, but the two

00:38:00.470 --> 00:38:03.920
together, pretty powerful.

00:38:03.920 --> 00:38:05.110
Questions about unfolding?

00:38:05.110 --> 00:38:07.560
I think this algorithm
should be pretty clear.

00:38:07.560 --> 00:38:09.750
One of the questions
was, are they practical?

00:38:09.750 --> 00:38:11.890
I think the answer is no.

00:38:11.890 --> 00:38:14.485
It has the same issue of
strip folding from origami.

00:38:14.485 --> 00:38:16.360
But I think they would
make great animations.

00:38:16.360 --> 00:38:19.380
This is still a cool
project to see virtually.

00:38:19.380 --> 00:38:23.060
But to do it physically
is probably crazy.

00:38:23.060 --> 00:38:26.240
No one has tried
as far as I know.

00:38:26.240 --> 00:38:26.990
Another idea.

00:38:26.990 --> 00:38:29.040
This is an open problem.

00:38:29.040 --> 00:38:30.995
So orthogonal was great.

00:38:30.995 --> 00:38:32.370
It has all these
nice properties.

00:38:32.370 --> 00:38:34.670
Can you generalize it, not
to arbitrary polyhedra,

00:38:34.670 --> 00:38:36.320
but to some other
kind of orthogonal,

00:38:36.320 --> 00:38:41.240
such as this is a
hexagonal lattice in 3D?

00:38:41.240 --> 00:38:43.460
I mean, it's just
extruded in one dimension,

00:38:43.460 --> 00:38:45.720
but then you have hex
grid in another dimension.

00:38:45.720 --> 00:38:47.260
You could try to do that.

00:38:47.260 --> 00:38:48.970
And my guess is if
you set up the bands

00:38:48.970 --> 00:38:54.410
to be in hex dimensions, it
just works, but I haven't tried.

00:38:54.410 --> 00:38:57.760
There's potentially some
low-hanging fruit here.

00:38:57.760 --> 00:39:00.030
There should be other 3D
structures that might work.

00:39:00.030 --> 00:39:01.655
A typical one in
computational geometry

00:39:01.655 --> 00:39:04.890
is called c-oriented
polyhedra where here we

00:39:04.890 --> 00:39:06.270
have three oriented polyhedra.

00:39:06.270 --> 00:39:07.686
There's three
different directions

00:39:07.686 --> 00:39:11.280
that the faces can
be perpendicular to.

00:39:11.280 --> 00:39:13.870
Take 10 of them, can you
apply the same technique?

00:39:13.870 --> 00:39:15.750
That gets dicier.

00:39:15.750 --> 00:39:18.640
But something like this I
feel like may be possible.

00:39:18.640 --> 00:39:21.010
You should try it out.

00:39:21.010 --> 00:39:24.710
But as far as I know,
this is all open.

00:39:24.710 --> 00:39:27.800
Last question is
Cauchy's rigidity theorem

00:39:27.800 --> 00:39:30.620
seems intuitively obvious.

00:39:30.620 --> 00:39:33.550
Or as I wrote it in the notes,
is Cauchey's rigidity theorem

00:39:33.550 --> 00:39:34.050
obvious?

00:39:34.050 --> 00:39:37.970
And my answer is no,
not obvious to me.

00:39:37.970 --> 00:39:39.890
I have two reasons
why it's not obvious.

00:39:39.890 --> 00:39:44.820
One is it's not true
in two dimensions.

00:39:44.820 --> 00:39:46.190
That's kind of a weak statement.

00:39:46.190 --> 00:39:52.230
But if I take a convex
polyhedron in 2D--

00:39:52.230 --> 00:39:53.610
so these are rigid faces.

00:39:53.610 --> 00:39:56.450
This is the equivalent
of a triangle.

00:39:56.450 --> 00:39:58.030
This is not rigid, of course.

00:40:01.770 --> 00:40:02.930
So that's one statement.

00:40:02.930 --> 00:40:05.180
And then the other thing
is convexity is necessary.

00:40:05.180 --> 00:40:08.150
There's this thing,
Steffen's polyhedron.

00:40:08.150 --> 00:40:10.620
Actually, originally, there
was a Connelly polyhedron.

00:40:10.620 --> 00:40:12.810
We've seen some
results by Connelly.

00:40:12.810 --> 00:40:14.990
He's a rigidity expert.

00:40:14.990 --> 00:40:17.470
And then this was
simplified by this guy Klaus

00:40:17.470 --> 00:40:20.740
Steffen in the '70s.

00:40:20.740 --> 00:40:24.970
This is a drawing
of it flexing in 3D.

00:40:24.970 --> 00:40:27.429
Nonconvex polyhedra
can be flexible.

00:40:27.429 --> 00:40:29.512
They happen to preserve
their volume as they flex.

00:40:35.060 --> 00:40:37.120
It's hard to say why a
theorem is not obvious.

00:40:37.120 --> 00:40:38.300
To me, it's not obvious.

00:40:38.300 --> 00:40:40.174
Of course, if you play
with convex polyhedra,

00:40:40.174 --> 00:40:42.790
they are rigid, so maybe
it's obvious from that.

00:40:42.790 --> 00:40:47.090
But you've got to prove
experimental evidence

00:40:47.090 --> 00:40:48.959
mathematically.

00:40:48.959 --> 00:40:49.625
Other questions?

00:40:55.280 --> 00:40:57.630
Then I have some fun
videos to show you.

00:40:57.630 --> 00:41:01.174
The first one is the making
of this origami piece which

00:41:01.174 --> 00:41:02.840
I've probably shown
a picture of before.

00:41:02.840 --> 00:41:04.640
It's by Brian Chan.

00:41:04.640 --> 00:41:06.650
It's one square paper, no cuts.

00:41:06.650 --> 00:41:10.675
Mens et Manus with a little
crane instead of-- what's

00:41:10.675 --> 00:41:13.460
it normally?

00:41:13.460 --> 00:41:14.220
Who knows?

00:41:14.220 --> 00:41:15.940
And then he also
made this nice box.

00:41:15.940 --> 00:41:17.930
And then the glass is
etched by Peter Houk

00:41:17.930 --> 00:41:21.260
who runs the glass lab at MIT.

