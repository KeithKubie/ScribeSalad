WEBVTT
Kind: captions
Language: en

00:00:00.500 --> 00:00:02.970
[MUSIC  PLAYING]

00:00:05.420 --> 00:00:07.420
HANS DOCKTER: I had a
funny incident last night.

00:00:07.420 --> 00:00:12.949
I went back to the hotel,
and then went to my room,

00:00:12.949 --> 00:00:14.740
put in the room card,
and nothing happened.

00:00:14.740 --> 00:00:16.390
I said, did I forget
my room number?

00:00:16.390 --> 00:00:19.290
I tried out a few other rooms
and it was completely weird.

00:00:19.290 --> 00:00:21.310
What is going on?

00:00:21.310 --> 00:00:24.060
So I went down to the
reception and said,

00:00:24.060 --> 00:00:26.860
either the card is broken
or I forgot my room number.

00:00:26.860 --> 00:00:28.510
She said, let me see your card.

00:00:28.510 --> 00:00:30.480
No, you're in the wrong hotel.

00:00:30.480 --> 00:00:32.268
[LAUGHTER]

00:00:34.060 --> 00:00:35.727
Go down, your one
is down the street.

00:00:35.727 --> 00:00:36.810
It's the one further down.

00:00:36.810 --> 00:00:37.890
I said, OK.

00:00:37.890 --> 00:00:40.610
So it's not to even
finished, the story.

00:00:40.610 --> 00:00:42.925
Then I went to the other hotel.

00:00:42.925 --> 00:00:45.360
I said, well, it
looks really similar.

00:00:45.360 --> 00:00:47.330
And I met a friend
of mine I haven't

00:00:47.330 --> 00:00:49.160
seen for while-- I
just told her the story

00:00:49.160 --> 00:00:50.840
you know what happened to me?

00:00:50.840 --> 00:00:54.500
So we went up to the second
floor and we said goodbye,

00:00:54.500 --> 00:00:58.320
and then she went to her room,
well, she went to my room

00:00:58.320 --> 00:01:01.830
and put her room
card on my room door.

00:01:01.830 --> 00:01:05.431
I said-- and then she
was in the wrong hotel.

00:01:05.431 --> 00:01:06.724
[LAUGHTER]

00:01:07.590 --> 00:01:09.150
And she was in the
one I was before.

00:01:09.150 --> 00:01:10.934
So that's the Hampton
and the Holiday Inn.

00:01:10.934 --> 00:01:11.850
That was really funny.

00:01:18.950 --> 00:01:20.970
Deep dive into the
Gradle-based Android

00:01:20.970 --> 00:01:22.830
build system-- I'm Hans Dockter.

00:01:22.830 --> 00:01:27.840
I'm the founder of Gradle
and the CEO of Gradle Inc.

00:01:27.840 --> 00:01:31.260
And I want to talk about
Android build system,

00:01:31.260 --> 00:01:34.370
the deep concepts behind
the Android Build System,

00:01:34.370 --> 00:01:37.900
and why it is created that way.

00:01:37.900 --> 00:01:39.060
Let's start.

00:01:39.060 --> 00:01:42.200
So what are the goals of
the Gradle Android-based

00:01:42.200 --> 00:01:43.160
build system?

00:01:43.160 --> 00:01:46.760
I think it is very
important to understand,

00:01:46.760 --> 00:01:50.966
as an educated Android
developer, what

00:01:50.966 --> 00:01:52.840
are the qualities, what
are the deeper design

00:01:52.840 --> 00:01:55.010
goals of that build system.

00:01:55.010 --> 00:01:57.810
Even if you use it
from Android Studio,

00:01:57.810 --> 00:01:59.980
still it's, I think,
important to understand

00:01:59.980 --> 00:02:03.060
and also when you compare
it with other platforms.

00:02:03.060 --> 00:02:05.860
And it's also interesting
to see how we are actually

00:02:05.860 --> 00:02:09.530
doing in reality in
regard to our lofty goals,

00:02:09.530 --> 00:02:10.229
or not so lofty.

00:02:10.229 --> 00:02:11.510
We'll see.

00:02:11.510 --> 00:02:16.150
So the first thing
to understand,

00:02:16.150 --> 00:02:22.160
Android is a complex platform,
not quite as complex as C, C++,

00:02:22.160 --> 00:02:24.640
but way more complex than Java.

00:02:24.640 --> 00:02:31.060
So when you look
at this diagram,

00:02:31.060 --> 00:02:34.442
even if you can't
read what is in there,

00:02:34.442 --> 00:02:36.650
this is the workflow building
an Android application.

00:02:39.530 --> 00:02:41.620
And you all know that you
have complex, resource,

00:02:41.620 --> 00:02:42.980
and code generation.

00:02:42.980 --> 00:02:44.430
You don't have that in Java.

00:02:44.430 --> 00:02:46.800
You have multiple
different languages.

00:02:46.800 --> 00:02:47.750
You have the NDK.

00:02:47.750 --> 00:02:48.700
You have Java.

00:02:48.700 --> 00:02:50.840
You have the interface
definition languages.

00:02:50.840 --> 00:02:54.440
And so there's lots going on.

00:02:54.440 --> 00:02:55.430
You have to sign in.

00:02:55.430 --> 00:02:57.930
You have the dexing
plus the compiling,

00:02:57.930 --> 00:03:00.712
and so on, and so on.

00:03:00.712 --> 00:03:03.480
So the original
Java tools that were

00:03:03.480 --> 00:03:06.175
used to build the
Android apps are not

00:03:06.175 --> 00:03:07.610
made for that complexity.

00:03:07.610 --> 00:03:10.810
There was Ant,
there was Eclipse,

00:03:10.810 --> 00:03:13.700
and there was, for quite
a few people, Maven.

00:03:13.700 --> 00:03:16.712
So they're already hitting
their limit in Java land

00:03:16.712 --> 00:03:18.170
and they were not
made for Android.

00:03:21.580 --> 00:03:26.040
And I talked about it, ran the
script, and the native code

00:03:26.040 --> 00:03:26.540
and whatnot.

00:03:26.540 --> 00:03:30.740
But there's another
challenge in Android land.

00:03:30.740 --> 00:03:32.610
I call it platform diversity.

00:03:32.610 --> 00:03:35.760
Others call it fragmentation.

00:03:35.760 --> 00:03:38.040
And this has been one of
the biggest pain points

00:03:38.040 --> 00:03:39.330
for developers to deal with.

00:03:39.330 --> 00:03:41.210
I just want to have
a little variation

00:03:41.210 --> 00:03:43.620
of my app for that platform.

00:03:43.620 --> 00:03:47.210
And it was very hard to
implement with the build system

00:03:47.210 --> 00:03:49.060
at that time.

00:03:49.060 --> 00:03:52.020
So how to make this diversity
approachable from a developer

00:03:52.020 --> 00:03:54.870
tooling perspective was a key
goal for the new build system.

00:03:58.820 --> 00:04:00.910
I forgot my transitions.

00:04:00.910 --> 00:04:02.410
OK, here we go.

00:04:02.410 --> 00:04:05.770
So what makes Gradle
unique and what

00:04:05.770 --> 00:04:08.630
is harnessed by the
Gradle Android plugin

00:04:08.630 --> 00:04:11.850
is that you have
the expressiveness

00:04:11.850 --> 00:04:15.600
to model the
complexity, that you

00:04:15.600 --> 00:04:17.500
have really concise
descriptions of your

00:04:17.500 --> 00:04:20.890
build, that something
may even was doing

00:04:20.890 --> 00:04:22.140
a reasonable job in Java land.

00:04:22.140 --> 00:04:24.040
So that is a strength of Gradle.

00:04:24.040 --> 00:04:28.620
At the same time, Maven is
concise for simple use cases,

00:04:28.620 --> 00:04:30.290
but can't go beyond that.

00:04:30.290 --> 00:04:36.660
Ant, or other similar design
systems like a Facebook Buck

00:04:36.660 --> 00:04:39.030
or whatnot, they
are very flexible,

00:04:39.030 --> 00:04:41.730
but they expose a level of
complexity to developers

00:04:41.730 --> 00:04:44.850
and build master that
is, at one point,

00:04:44.850 --> 00:04:48.530
very expensive to manage.

00:04:48.530 --> 00:04:51.800
And Gradle tries to
combine the conciseness

00:04:51.800 --> 00:04:55.250
of a declarative good
language like Maven

00:04:55.250 --> 00:04:58.520
without sacrificing the
power and the flexibility

00:04:58.520 --> 00:05:03.060
and the extensibility that
you have with Ant and Ivy.

00:05:03.060 --> 00:05:05.770
In fact, done right,
if you combine it,

00:05:05.770 --> 00:05:07.710
you get even better
extensibility.

00:05:07.710 --> 00:05:10.320
Now, we'll talk
about that later.

00:05:10.320 --> 00:05:14.170
OK, so to give you an example
of what I mean with conciseness,

00:05:14.170 --> 00:05:18.110
look at this very simple build
definition for a standalone

00:05:18.110 --> 00:05:20.360
Android app-- a
few lines of code.

00:05:20.360 --> 00:05:24.430
You have two product
flavors-- two dimensions.

00:05:24.430 --> 00:05:27.534
And for each dimensions,
you have two flavors.

00:05:27.534 --> 00:05:29.700
For the version, you have
a free and a paid version.

00:05:29.700 --> 00:05:32.270
For the ABI, you
have arm and x86.

00:05:36.800 --> 00:05:39.050
And you could now do
certain definitions.

00:05:39.050 --> 00:05:41.600
What you can already do when
you have such a definition,

00:05:41.600 --> 00:05:44.530
you can put code in Source
Free or test in Source Free

00:05:44.530 --> 00:05:48.226
or in Source Page or in
Source ARM or Source 86.

00:05:48.226 --> 00:05:50.100
And Android knows
exactly-- the Android build

00:05:50.100 --> 00:05:51.700
system, what to do with that.

00:05:51.700 --> 00:05:55.400
It runs the free test only
when you build the free APK.

00:05:55.400 --> 00:05:59.875
So that is a reasonably
simple problem.

00:05:59.875 --> 00:06:03.310
And this is how it is expressed.

00:06:03.310 --> 00:06:07.060
So can you read that
in the last row?

00:06:07.060 --> 00:06:09.420
No, I'm joking.

00:06:09.420 --> 00:06:13.820
So when you do, for this
little build script,

00:06:13.820 --> 00:06:18.950
when you do Gradle tasks--
so all of the tasks

00:06:18.950 --> 00:06:26.060
that Gradle creates
to build this,

00:06:26.060 --> 00:06:28.660
you have more than 300 tasks.

00:06:28.660 --> 00:06:34.730
So imagine how the Ant
build would look like.

00:06:34.730 --> 00:06:39.802
It would be 1,000 lines of XML.

00:06:39.802 --> 00:06:41.260
With Maven, on the
other hand, it's

00:06:41.260 --> 00:06:44.321
completely impossible to
model this within one project.

00:06:44.321 --> 00:06:45.820
Maven would tell
you, well, you need

00:06:45.820 --> 00:06:51.450
to separate sub-project per
flavor, per test per flavor.

00:06:51.450 --> 00:06:54.725
You would end up
with a sub-project,

00:06:54.725 --> 00:06:56.930
30 multi-module Maven
build or something

00:06:56.930 --> 00:07:00.520
like that, which is
also kind of, hey,

00:07:00.520 --> 00:07:01.680
I'm an Android developer.

00:07:01.680 --> 00:07:03.710
I have a little requirement--
certain variance

00:07:03.710 --> 00:07:05.980
I want to express around
my simple Android app.

00:07:05.980 --> 00:07:09.160
And now I end up with a 20,
30 sub-module Maven build.

00:07:09.160 --> 00:07:11.862
That's not what you
want to be challenged

00:07:11.862 --> 00:07:13.070
with as an Android developer.

00:07:13.070 --> 00:07:18.850
So that gives you kind of an
idea what has been a shift.

00:07:18.850 --> 00:07:21.500
So the key mission
is accomplished.

00:07:21.500 --> 00:07:23.410
There is now a
powerful Android build

00:07:23.410 --> 00:07:26.740
system with which you can
elegantly describe many

00:07:26.740 --> 00:07:28.820
of the typical requirements.

00:07:28.820 --> 00:07:31.570
You have one building Android
applications, including

00:07:31.570 --> 00:07:35.130
kick ass dependency management.

00:07:35.130 --> 00:07:38.790
It has the right mixture between
flexibility and structure.

00:07:38.790 --> 00:07:41.119
When you just have
flexibility, you

00:07:41.119 --> 00:07:42.660
might have a lower
complexity to deal

00:07:42.660 --> 00:07:43.868
with as an Android developer.

00:07:43.868 --> 00:07:46.394
But if you have just
structure and no flexibility,

00:07:46.394 --> 00:07:47.560
you can't extend the things.

00:07:47.560 --> 00:07:49.980
So this is a really
nice mixture.

00:07:49.980 --> 00:07:52.160
And it's a true achievement
by the Google Android

00:07:52.160 --> 00:07:56.770
team, who is maintaining and
creating the Gradle Android

00:07:56.770 --> 00:08:00.160
plugin, to have modelled the
functional domain of building

00:08:00.160 --> 00:08:04.370
Android so well, based, of
course, on the capabilities

00:08:04.370 --> 00:08:05.690
of Gradle.

00:08:05.690 --> 00:08:07.420
And there's more to come.

00:08:07.420 --> 00:08:09.906
So the foundation is rock solid.

00:08:09.906 --> 00:08:11.280
And the feedback
we're getting is

00:08:11.280 --> 00:08:15.600
that people are very
happy with that aspect.

00:08:15.600 --> 00:08:18.490
And I haven't talked
about performance yet.

00:08:18.490 --> 00:08:22.920
And I want to talk about
something else first.

00:08:22.920 --> 00:08:28.210
So some other goals that
are behind the system.

00:08:28.210 --> 00:08:30.910
It is not good enough for most
Android developers to just

00:08:30.910 --> 00:08:32.440
have a good Android build.

00:08:32.440 --> 00:08:38.380
You have back end services
written in Java, C++, Ruby.

00:08:38.380 --> 00:08:42.500
You have other
libraries to deal with

00:08:42.500 --> 00:08:46.280
and potentially written
other languages.

00:08:46.280 --> 00:08:48.830
And you want to be able to
integrate deeply with those

00:08:48.830 --> 00:08:51.010
during development cycles.

00:08:51.010 --> 00:08:52.960
You don't want to be
the isolated Android

00:08:52.960 --> 00:08:57.182
team like it is still today
in so many organizations.

00:08:57.182 --> 00:08:59.640
The Android teams are isolated
from the continuous delivery

00:08:59.640 --> 00:09:02.820
process of the rest of the
team, and that is not good.

00:09:02.820 --> 00:09:04.940
The people writing
the back end services

00:09:04.940 --> 00:09:06.620
should be able to
ask the question,

00:09:06.620 --> 00:09:09.690
is this change breaking
the Android app?

00:09:09.690 --> 00:09:12.110
And that is often not possible,
but with Gradle, you now

00:09:12.110 --> 00:09:15.550
have the tool to have a really
unified build experience.

00:09:15.550 --> 00:09:22.870
And Gradle is a powerful,
polyglot build system with

00:09:22.870 --> 00:09:26.420
strong support for
C, C++, and Java,

00:09:26.420 --> 00:09:32.070
also for Python and interesting
wrapping around the JavaScript

00:09:32.070 --> 00:09:33.410
ecosystem.

00:09:33.410 --> 00:09:35.590
So Linked In is a very
good example for that.

00:09:35.590 --> 00:09:37.650
LinkedIn has an
armada of languages.

00:09:37.650 --> 00:09:40.310
It all builds with Gradle
in one or the other way

00:09:40.310 --> 00:09:42.330
with 40-plus languages.

00:09:42.330 --> 00:09:45.840
Some are very exotic,
all built with Gradle,

00:09:45.840 --> 00:09:49.660
either with a direct
implementation, or with Gradle

00:09:49.660 --> 00:09:51.870
like with Python adding
some functionality

00:09:51.870 --> 00:09:56.220
on top of the existing
Python food chain.

00:09:56.220 --> 00:09:59.140
They've also integrate a Hadoop
developer tooling around it.

00:09:59.140 --> 00:10:04.610
So that is a big benefit you
get if you work in a team.

00:10:04.610 --> 00:10:06.370
If you're not just
writing Android,

00:10:06.370 --> 00:10:08.190
you have now a build
system that can

00:10:08.190 --> 00:10:12.490
integrate all the different
pieces much better.

00:10:12.490 --> 00:10:15.920
To give you an idea of
the scope, how Gradle

00:10:15.920 --> 00:10:19.920
is used in some
organizations, at LinkedIn,

00:10:19.920 --> 00:10:24.710
it is used by 2,000 engineers,
and they have 300,000 Gradle

00:10:24.710 --> 00:10:27.450
build executions per week.

00:10:27.450 --> 00:10:32.370
So the biggest Gradle build
has 3,800 sub-modules.

00:10:32.370 --> 00:10:34.930
And one other thing that is
interesting with LinkedIn--

00:10:34.930 --> 00:10:37.100
like more and more
organizations,

00:10:37.100 --> 00:10:41.250
they switched from teams
that have been created

00:10:41.250 --> 00:10:45.850
around technology-- the
Android team, the iOS team--

00:10:45.850 --> 00:10:48.890
to functional teams--
so teams that share

00:10:48.890 --> 00:10:50.490
the back end and
the different UIs

00:10:50.490 --> 00:10:52.660
and apps that are
developed around a set

00:10:52.660 --> 00:10:53.620
of functionalities.

00:10:53.620 --> 00:10:56.040
So now for them, it's
even much more important

00:10:56.040 --> 00:10:57.730
to have a build
system that wraps

00:10:57.730 --> 00:10:59.731
around the whole
functional team,

00:10:59.731 --> 00:11:01.855
even though they're using
very different languages.

00:11:06.030 --> 00:11:10.270
For a talk about
performance, extensibility.

00:11:10.270 --> 00:11:13.750
It is not just good
enough to solve

00:11:13.750 --> 00:11:16.820
the standard requirements,
even in a polyglot setting.

00:11:16.820 --> 00:11:18.820
So you've got a lot of
out-of-the-box stuff from

00:11:18.820 --> 00:11:25.860
Gradle, and so the
example projects all work.

00:11:25.860 --> 00:11:30.210
But people that are ambitious
about developer productivity

00:11:30.210 --> 00:11:35.630
and automation and/or work
in a more complex environment

00:11:35.630 --> 00:11:39.590
desperately need extensibility.

00:11:39.590 --> 00:11:40.980
So with the new
build system, you

00:11:40.980 --> 00:11:43.930
are able to inject
custom steps anywhere.

00:11:43.930 --> 00:11:47.090
You have deep APIs with
listener frameworks

00:11:47.090 --> 00:11:49.510
to get into the guts of
the system if needed.

00:11:49.510 --> 00:11:51.070
Even in the test
execution, you can

00:11:51.070 --> 00:11:52.361
hook in a listener with Gradle.

00:11:52.361 --> 00:11:54.290
Hey, send me an
event after you've

00:11:54.290 --> 00:11:55.420
executed the test method.

00:11:55.420 --> 00:11:58.129
I want to do something with
it, whatever that may be.

00:11:58.129 --> 00:12:00.420
Maybe you have a fragile test
you want to do deal with.

00:12:00.420 --> 00:12:02.440
And you say, oh, this
test I need to run again

00:12:02.440 --> 00:12:04.439
to make sure that it has
really failed, whatnot,

00:12:04.439 --> 00:12:09.857
whatever pathologies you need
to embrace as part of your work.

00:12:09.857 --> 00:12:11.690
And their are powerful
features to integrate

00:12:11.690 --> 00:12:13.981
deeply any other technology
tool chain into your build.

00:12:16.710 --> 00:12:18.320
And it's not just extensible.

00:12:18.320 --> 00:12:24.340
You can extend it in a way
that your build stays concise.

00:12:24.340 --> 00:12:26.680
You can extend to create
a declarative language

00:12:26.680 --> 00:12:28.570
with your own declarative
language element

00:12:28.570 --> 00:12:32.490
to make it very easy for
your developers to work

00:12:32.490 --> 00:12:34.440
with your custom requirements.

00:12:34.440 --> 00:12:36.310
And even if you say,
oh, extensibility

00:12:36.310 --> 00:12:41.040
is not important for me,
well, in an indirect way,

00:12:41.040 --> 00:12:43.560
it is because you
will benefit from it

00:12:43.560 --> 00:12:45.930
by a very powerful
plugin ecosystem that

00:12:45.930 --> 00:12:48.082
depends on this extensibility.

00:12:48.082 --> 00:12:50.540
And there are really interesting
Android plugins out there.

00:12:50.540 --> 00:12:52.180
If you create a
run so extensible,

00:12:52.180 --> 00:12:53.680
the plugins wouldn't
be so powerful.

00:12:53.680 --> 00:12:55.600
So even if you
don't extend it, you

00:12:55.600 --> 00:12:57.840
have a more powerful
plugin ecosystem

00:12:57.840 --> 00:12:59.970
out there of greater
plugins that you can use.

00:13:03.729 --> 00:13:05.020
I always forget my transitions.

00:13:08.490 --> 00:13:14.690
OK, so Gradle is a very strong
foundation for the Android

00:13:14.690 --> 00:13:16.430
build system.

00:13:16.430 --> 00:13:19.480
It is a built platform
with massive traction.

00:13:19.480 --> 00:13:21.880
We had just crossed the
one million downloads

00:13:21.880 --> 00:13:23.740
per month line in September.

00:13:23.740 --> 00:13:25.010
It's evolving very fast.

00:13:25.010 --> 00:13:29.350
We have 19 feature releases
in the last three years,

00:13:29.350 --> 00:13:32.050
and we get a large amount of
contributions from individuals

00:13:32.050 --> 00:13:35.010
and organizations like LinkedIn,
Netflix, Google, Android, Unity

00:13:35.010 --> 00:13:37.540
Technologies, and many more.

00:13:37.540 --> 00:13:39.510
So a lot of innovation
is happening,

00:13:39.510 --> 00:13:42.280
and Gradle is a generic
automation platform.

00:13:42.280 --> 00:13:46.360
For whatever you want to
automate, you can use it.

00:13:46.360 --> 00:13:49.260
Because as a developer,
you're not just creating APKs.

00:13:49.260 --> 00:13:52.450
You are shipping software
with a group of people,

00:13:52.450 --> 00:13:54.290
which is a much larger scope.

00:13:54.290 --> 00:13:56.400
You might want to have
auto-provisioned def

00:13:56.400 --> 00:13:57.060
environments.

00:13:57.060 --> 00:14:00.290
You might want to generate
documentation for client API

00:14:00.290 --> 00:14:02.835
that you are shipping where all
code snippets are integration

00:14:02.835 --> 00:14:03.510
tested.

00:14:03.510 --> 00:14:05.620
That's how we ship
our documentation.

00:14:05.620 --> 00:14:10.229
Every snippet in the Gradle
user guide is life tested.

00:14:10.229 --> 00:14:11.770
While we are creating
the user guide,

00:14:11.770 --> 00:14:13.240
we run the integration
test, right,

00:14:13.240 --> 00:14:14.510
against the snippet in there.

00:14:14.510 --> 00:14:16.670
Then we extract the output
of the integration test

00:14:16.670 --> 00:14:18.280
and insert it into
the user guide

00:14:18.280 --> 00:14:22.980
to make sure that we don't have
the money for an editorial team

00:14:22.980 --> 00:14:24.510
or don't want to
spend it on that

00:14:24.510 --> 00:14:27.090
and still want to give you a
high-quality documentation.

00:14:27.090 --> 00:14:30.520
So when you really think
about shipping software,

00:14:30.520 --> 00:14:33.120
there's so many tasks
you can automate.

00:14:33.120 --> 00:14:38.380
And once you have a system
that allows you to do that,

00:14:38.380 --> 00:14:39.930
you can get really creative.

00:14:39.930 --> 00:14:42.360
You want to have a fully
automated release process.

00:14:42.360 --> 00:14:44.940
You might want to have
central version strategies

00:14:44.940 --> 00:14:47.180
for the libraries
you're consuming,

00:14:47.180 --> 00:14:50.730
automated database migrations,
container integration

00:14:50.730 --> 00:14:52.640
for certain integration tests.

00:14:55.230 --> 00:14:58.740
How to deal with fragile
tests-- a big problem

00:14:58.740 --> 00:15:00.275
we see in many organizations.

00:15:00.275 --> 00:15:01.900
When you have a build
system that says,

00:15:01.900 --> 00:15:05.370
well, you can only have
one group of tests,

00:15:05.370 --> 00:15:07.790
and when some of them
are fragile tests,

00:15:07.790 --> 00:15:10.090
it usually means
people start ignoring

00:15:10.090 --> 00:15:11.470
if this test suite fails.

00:15:11.470 --> 00:15:15.240
It says, ah, yeah, OK, it might
be interesting that it fails.

00:15:15.240 --> 00:15:16.200
It might be not.

00:15:16.200 --> 00:15:18.410
So with Gradle, you
could easily isolate

00:15:18.410 --> 00:15:20.530
and say, OK, there
are non-fragile tests

00:15:20.530 --> 00:15:22.120
are put in that group.

00:15:22.120 --> 00:15:25.150
And they are really part of my
continuous delivery pipeline.

00:15:25.150 --> 00:15:29.080
If the CI is failing here,
everyone stops work and fix it.

00:15:29.080 --> 00:15:32.060
And then there is the other
group of tests, fragile,

00:15:32.060 --> 00:15:34.380
the menu will test
us-- might still use

00:15:34.380 --> 00:15:35.870
them to get some indications.

00:15:35.870 --> 00:15:39.600
But I don't want to rely on
them for my automated pipeline--

00:15:39.600 --> 00:15:40.390
stuff like this.

00:15:40.390 --> 00:15:45.170
Or you have very time-consuming
pseudo-integration tests

00:15:45.170 --> 00:15:47.710
where you want to
maybe separate them

00:15:47.710 --> 00:15:50.827
into DP integration tests,
UI integration tests

00:15:50.827 --> 00:15:52.160
so that you get faster feedback.

00:15:52.160 --> 00:15:54.520
People that work
on a database only

00:15:54.520 --> 00:15:56.459
want to execute the
DB integration tests

00:15:56.459 --> 00:15:58.000
before they commit
because they don't

00:15:58.000 --> 00:16:00.520
want to wait another hour.

00:16:00.520 --> 00:16:04.212
So there's a lot of
interesting stuff in the domain

00:16:04.212 --> 00:16:05.170
of continuous delivery.

00:16:05.170 --> 00:16:06.400
It's a complex domain.

00:16:06.400 --> 00:16:08.130
Gradle is your friend.

00:16:08.130 --> 00:16:12.575
So be ambitious about automating
your whole shipping process.

00:16:16.590 --> 00:16:18.640
So let's look at
an example of some

00:16:18.640 --> 00:16:22.590
of the nice features of
how Gradle can help you

00:16:22.590 --> 00:16:26.120
in getting better into
the flow and achieving

00:16:26.120 --> 00:16:27.870
a high degree of automation.

00:16:27.870 --> 00:16:40.910
So what we have here is, oops,
is an Asciidoctor project.

00:16:40.910 --> 00:16:41.840
So let's look at this.

00:16:41.840 --> 00:16:44.010
So it's built with Gradle.

00:16:44.010 --> 00:16:45.390
Who of you knows Asciidoctor?

00:16:45.390 --> 00:16:49.450
Asciidoctor is a markup language
more complex than Markdown.

00:16:49.450 --> 00:16:52.310
It's kind of
replacing the DocBooks

00:16:52.310 --> 00:16:53.880
and the LaTex of the world.

00:16:53.880 --> 00:16:58.710
So O'Reilly is using Asciidoctor
only since a couple of years,

00:16:58.710 --> 00:17:00.320
I think, for their books.

00:17:00.320 --> 00:17:05.520
And so there's a Gradle
Asciidoctor plugin out there.

00:17:05.520 --> 00:17:06.849
Let's look at the project.

00:17:06.849 --> 00:17:11.410
We have a source
main Java directory

00:17:11.410 --> 00:17:12.770
so it's a Java project.

00:17:12.770 --> 00:17:17.440
And with Asciidoctor, we
create a manual for that.

00:17:17.440 --> 00:17:19.940
Can you see that, by the way?

00:17:19.940 --> 00:17:23.450
We create a manual
for this Java library.

00:17:23.450 --> 00:17:29.950
And example-manual is the
source file for the manual.

00:17:29.950 --> 00:17:32.750
So let's look at
the source file.

00:17:46.500 --> 00:17:51.260
So here you see the Asciidoctor
annotate or markup language.

00:17:53.840 --> 00:18:02.240
And we can now tell Gradle,
hey, turn this into a HTML page.

00:18:02.240 --> 00:18:04.290
So we did that.

00:18:04.290 --> 00:18:09.480
Now we open the
HTML page, and you

00:18:09.480 --> 00:18:12.350
see this Asciidoctor document
now rendered in HTML.

00:18:16.680 --> 00:18:21.320
So let's change the source
file, the Asciidoctor file.

00:18:21.320 --> 00:18:24.582
Let's do something exciting.

00:18:24.582 --> 00:18:26.040
Let me go back to
the command line.

00:18:28.570 --> 00:18:29.570
We build it again.

00:18:33.660 --> 00:18:34.175
We refresh.

00:18:37.890 --> 00:18:39.470
I don't expect you
to be excited yet.

00:18:43.840 --> 00:18:46.150
So now we do something exciting.

00:18:46.150 --> 00:18:50.750
We run the Asciidoctor task
in the Gradle continuous mode,

00:18:50.750 --> 00:18:52.546
--continuous.

00:18:52.546 --> 00:18:54.420
And what you can see
now, now Gradle listens.

00:19:00.870 --> 00:19:05.570
Now, Gradle listens
to any changes.

00:19:05.570 --> 00:19:14.010
So if we now go back
to the document, that's

00:19:14.010 --> 00:19:17.110
something really
exciting, and we save it,

00:19:17.110 --> 00:19:18.230
we don't need to rebuild.

00:19:18.230 --> 00:19:21.150
We just do a refresh,
and it's updated.

00:19:24.640 --> 00:19:27.700
And, of course, we can continue
to do that, continuous mode

00:19:27.700 --> 00:19:32.480
introduced with Gradle 2.5.

00:19:32.480 --> 00:19:34.920
And we are super
excited about that.

00:19:34.920 --> 00:19:36.710
So we save it again.

00:19:36.710 --> 00:19:38.710
We do a refresh, and here we go.

00:19:42.650 --> 00:19:46.250
And yeah, and you can now see
the changes were detected,

00:19:46.250 --> 00:19:48.300
so the builds were executed.

00:19:48.300 --> 00:19:53.080
And the interesting
thing, I mean,

00:19:53.080 --> 00:19:55.230
it's not the first
time that there is

00:19:55.230 --> 00:19:58.820
a watch solution on the market.

00:19:58.820 --> 00:20:01.440
For people doing
Ruby, they had that.

00:20:01.440 --> 00:20:05.250
The special thing here is you
don't need to specify anything.

00:20:05.250 --> 00:20:08.060
Usually all the
watch solutions you

00:20:08.060 --> 00:20:11.740
need to specify some glob
patterns, where to look for,

00:20:11.740 --> 00:20:13.990
and what to do if
that pattern changes.

00:20:13.990 --> 00:20:14.980
Gradle knows all that.

00:20:14.980 --> 00:20:16.410
We have a rich
input-output model.

00:20:16.410 --> 00:20:19.710
You just say run this
task in continuous mode,

00:20:19.710 --> 00:20:21.465
and Gradle knows
exactly for what

00:20:21.465 --> 00:20:23.946
changes to look because the
input and outputs are defined

00:20:23.946 --> 00:20:25.570
in a Gradle build,
if that makes sense.

00:20:25.570 --> 00:20:27.520
So for the developer,
it's super easy.

00:20:27.520 --> 00:20:29.320
You can do this with
any Gradle task.

00:20:29.320 --> 00:20:31.950
They don't need to
configure anything for this.

00:20:31.950 --> 00:20:36.140
And so we use that in
many places internally.

00:20:36.140 --> 00:20:37.840
Documentation is a place.

00:20:37.840 --> 00:20:41.310
Another place is for our
upcoming gradle.com offering.

00:20:44.910 --> 00:20:47.800
Our whole back end app is
using the continuous mode.

00:20:47.800 --> 00:20:50.100
We start in continuous
mode, and then

00:20:50.100 --> 00:20:53.730
whatever we change in the app
is automatically picked up.

00:20:53.730 --> 00:20:57.820
The app is redeployed, and it's
a wonderful, rapid application

00:20:57.820 --> 00:20:58.970
development mode.

00:20:58.970 --> 00:21:03.350
And think about what that means
from a deeper point of view.

00:21:03.350 --> 00:21:08.560
So we had a chat with LinkedIn.

00:21:08.560 --> 00:21:12.720
Yes, their goal for next
year is that developers never

00:21:12.720 --> 00:21:15.260
need to directly call
the build system.

00:21:15.260 --> 00:21:18.390
That is the goal for 2016.

00:21:18.390 --> 00:21:20.570
So how are we going
to achieve that?

00:21:20.570 --> 00:21:22.860
That is key tool for that.

00:21:22.860 --> 00:21:26.630
So they basically will bundle a
preconfigured, continuous mode

00:21:26.630 --> 00:21:29.906
settings with the IDE.

00:21:29.906 --> 00:21:31.530
So when the developers
fire up the IDE,

00:21:31.530 --> 00:21:35.090
they do not just fire up
the JetBrain, IntelliJ.

00:21:35.090 --> 00:21:37.540
They fire up a
whole set of rules

00:21:37.540 --> 00:21:41.390
that Gradle gets instructed
with what to watch for.

00:21:41.390 --> 00:21:44.310
So when you have
some source code

00:21:44.310 --> 00:21:47.720
generation, some specific
one, you just fire up the IDE.

00:21:47.720 --> 00:21:49.830
It starts the continuous
mode, and your developers

00:21:49.830 --> 00:21:54.570
do some changes in, let's say,
the XML configuration file,

00:21:54.570 --> 00:21:57.150
and boom, Gradle will
automatically rebuild it.

00:21:57.150 --> 00:21:58.441
The developers don't even know.

00:21:58.441 --> 00:21:59.880
Is that the IDE doing this?

00:21:59.880 --> 00:22:01.840
Is that the build
system doing that?

00:22:01.840 --> 00:22:04.570
And the whole thing is the IDE.

00:22:04.570 --> 00:22:05.610
It's the whole thing.

00:22:05.610 --> 00:22:11.100
And so I'm super excited
about how continuous mode can

00:22:11.100 --> 00:22:14.480
basically extend the
capabilities of a classic IDE

00:22:14.480 --> 00:22:19.080
because, finally, your IDE
becomes extendable with Gradle.

00:22:19.080 --> 00:22:22.320
Which of you has ever written
an Eclipse nature or an Eclipse

00:22:22.320 --> 00:22:22.820
builder?

00:22:22.820 --> 00:22:25.820
Who wants to do that, right?

00:22:25.820 --> 00:22:28.060
And IntelliJ is the same thing.

00:22:28.060 --> 00:22:30.160
Build systems are made
for this kind of stuff.

00:22:30.160 --> 00:22:33.665
So continuous mode is a super,
super exciting capability.

00:22:36.220 --> 00:22:38.777
And I'm sure we will find
interesting opportunities

00:22:38.777 --> 00:22:40.360
to integrate that
with Android Studio.

00:22:40.360 --> 00:22:42.193
So we already have had
a chat with the guys,

00:22:42.193 --> 00:22:44.310
and we will see what
comes out of that.

00:22:48.990 --> 00:22:53.910
Talking about Android Studio,
one of the most important goals

00:22:53.910 --> 00:22:55.750
of the new Android
developer tool chain

00:22:55.750 --> 00:22:59.650
was a true Android IDE
that natively understands

00:22:59.650 --> 00:23:04.470
Android projects in
contrast to, let's say,

00:23:04.470 --> 00:23:09.070
the Eclipse ADT project,
And the other key goal was

00:23:09.070 --> 00:23:13.040
the IDE should build the same
way as the command line NCI,

00:23:13.040 --> 00:23:15.600
that you have consistency
and coherent quality

00:23:15.600 --> 00:23:17.540
of service of the def tooling.

00:23:17.540 --> 00:23:21.390
If you remember, Eclipse ADT
had a separate build system.

00:23:21.390 --> 00:23:24.190
You had an Ant build
or a Maven build--

00:23:24.190 --> 00:23:26.450
whatever you have chosen.

00:23:26.450 --> 00:23:28.570
But when you were
working in Eclipse ADT,

00:23:28.570 --> 00:23:31.930
it came with its own tool chain,
own merging, own everything.

00:23:31.930 --> 00:23:33.810
That's how you had to do it.

00:23:33.810 --> 00:23:35.590
There was no way to
deeply integrate it.

00:23:35.590 --> 00:23:37.690
So the goal of
Android Studio was

00:23:37.690 --> 00:23:41.980
the IDE is not doing any
actions themselves anymore.

00:23:41.980 --> 00:23:45.530
Every action execute task
generate resources and is

00:23:45.530 --> 00:23:47.900
delegated to the
underlying greater build so

00:23:47.900 --> 00:23:50.417
that whether you execute your
build from the command line

00:23:50.417 --> 00:23:52.750
or whether you're just working
Android Studio is exactly

00:23:52.750 --> 00:23:53.500
the same behavior.

00:23:59.440 --> 00:24:03.010
And so unified
build system, and I

00:24:03.010 --> 00:24:08.750
talked about with Gradle you can
now extend your build system.

00:24:08.750 --> 00:24:11.080
Let's say you're
working in Android

00:24:11.080 --> 00:24:15.545
Studio on some widget that
shows you a quote of the day.

00:24:20.040 --> 00:24:22.700
So you could now--
let's say, if it's just

00:24:22.700 --> 00:24:24.120
for fun for you developers.

00:24:24.120 --> 00:24:28.480
You just use it for the debug,
for the debug build type.

00:24:28.480 --> 00:24:31.150
You could now
easily tell Gradle,

00:24:31.150 --> 00:24:33.980
hey, I want to hook
in another task

00:24:33.980 --> 00:24:36.510
while you are generating
the resources,

00:24:36.510 --> 00:24:40.140
and I want you to retrieve
the quote of the day

00:24:40.140 --> 00:24:44.270
from some server and edit
to the resources files.

00:24:44.270 --> 00:24:46.670
So you just add that task
to your build script.

00:24:46.670 --> 00:24:49.280
And if you are working
in Android Studio

00:24:49.280 --> 00:24:52.850
because Android Studio instructs
Gradle to create the resources,

00:24:52.850 --> 00:24:55.850
you will now have in your
visual design widget,

00:24:55.850 --> 00:24:58.860
you will have always a
changing quote of the day.

00:24:58.860 --> 00:25:00.505
So you get the point.

00:25:00.505 --> 00:25:02.380
It's not fully integrated
with Android Studio

00:25:02.380 --> 00:25:05.430
because Android Studios, they're
getting everything to Gradle.

00:25:05.430 --> 00:25:10.330
So you can now really
powerfully extend your IDE.

00:25:10.330 --> 00:25:13.070
With Eclipse ADT, it would have
been completely impossible--

00:25:13.070 --> 00:25:14.820
separate worlds-- what
you do in the build

00:25:14.820 --> 00:25:17.153
and what you do in your IDE,
and your IDE is usually not

00:25:17.153 --> 00:25:18.850
extendable.

00:25:18.850 --> 00:25:24.030
So and the other part
besides being extension aware

00:25:24.030 --> 00:25:28.446
is as the Android domain is
deeply modeled in Gradle,

00:25:28.446 --> 00:25:31.520
it is easy for Android Studio
to derive rich information

00:25:31.520 --> 00:25:33.690
from the build spec.

00:25:33.690 --> 00:25:39.150
So if you look at an example,
here we have Android Studio.

00:25:39.150 --> 00:25:43.235
So we have two product
flavors, free and paid.

00:25:43.235 --> 00:25:44.860
They use different
for whatever reason.

00:25:44.860 --> 00:25:45.880
They use different
version codes.

00:25:45.880 --> 00:25:47.270
They could use
different dependencies.

00:25:47.270 --> 00:25:48.936
But that's not what
I want to show here.

00:25:54.850 --> 00:25:58.460
And so now we go into
the visual mode, right,

00:25:58.460 --> 00:26:02.640
and we can now
change-- I will have

00:26:02.640 --> 00:26:04.958
a stiff neck after this talk.

00:26:04.958 --> 00:26:11.160
You can now change, because I
don't see that on my screen,

00:26:11.160 --> 00:26:13.310
the build variant.

00:26:13.310 --> 00:26:20.890
So we choose free release,
and if we switch to pay debug,

00:26:20.890 --> 00:26:22.930
that is deep IDE integration.

00:26:22.930 --> 00:26:23.480
That's fun.

00:26:23.480 --> 00:26:24.480
That's how it should be.

00:26:40.760 --> 00:26:42.030
What do I want to show here?

00:26:50.210 --> 00:26:53.110
Yeah, I skipped the
whole tooling API topic.

00:26:55.660 --> 00:26:59.840
So we have a special library
that we create so that IDEs

00:26:59.840 --> 00:27:04.180
can interact with Gradle,
be it Android Studio,

00:27:04.180 --> 00:27:08.920
plain IntelliJ, or Eclipse, but
don't need to go into detail.

00:27:08.920 --> 00:27:10.560
The only thing that
is interesting--

00:27:10.560 --> 00:27:18.510
that's the only thing I would
like to mention-- we ourselves

00:27:18.510 --> 00:27:21.705
create the Gradle
plugin for Eclipse

00:27:21.705 --> 00:27:24.630
or I should say the Gradle
plugin for the Eclipse plugin

00:27:24.630 --> 00:27:30.160
ecosystem to be very clear,
and we only do that for Java.

00:27:30.160 --> 00:27:32.980
We are not working on
Android support for Eclipse.

00:27:32.980 --> 00:27:35.400
And one thing we have
added that is really nice,

00:27:35.400 --> 00:27:39.280
I talked about what a
deep API Gradle has.

00:27:39.280 --> 00:27:44.860
What you can now do from Eclipse
is when you go to your package

00:27:44.860 --> 00:27:47.460
or to any test class and
you can right click it

00:27:47.460 --> 00:27:52.290
and you say execute, you know
all the visual few you then

00:27:52.290 --> 00:27:57.700
get that shows you the test
execution, the execution

00:27:57.700 --> 00:28:00.360
windows for testing with in IDE.

00:28:00.360 --> 00:28:04.050
Classically, the IDEs come
with their own test runners.

00:28:04.050 --> 00:28:07.120
So now with Buildship,
you have now

00:28:07.120 --> 00:28:10.210
the same visual representation,
a really nice runner that

00:28:10.210 --> 00:28:13.200
runs the test, gives you
a green or red button.

00:28:13.200 --> 00:28:16.180
But, actually, all the tests
are executed by Gradle,

00:28:16.180 --> 00:28:17.660
and with the
tooling API, we hook

00:28:17.660 --> 00:28:21.790
into the eventing system of
Gradle and a really nice, rich

00:28:21.790 --> 00:28:22.570
representation.

00:28:22.570 --> 00:28:25.330
At the same time, it's
no longer that Eclipse

00:28:25.330 --> 00:28:27.881
has a separate test
execution than Gradle.

00:28:27.881 --> 00:28:30.130
And think about what that
means for integration tests.

00:28:30.130 --> 00:28:32.670
I have been in many
organizations that

00:28:32.670 --> 00:28:34.960
told the developers if you
want to execute integration

00:28:34.960 --> 00:28:38.760
tests from your IDE, you
have to go to the build wiki.

00:28:38.760 --> 00:28:40.780
And before you integrate
your integration tests,

00:28:40.780 --> 00:28:42.740
you have to go to
the command line

00:28:42.740 --> 00:28:47.395
and execute with your Gradle
and Maven build, fire up

00:28:47.395 --> 00:28:50.970
the database, create test
data, some manual step,

00:28:50.970 --> 00:28:53.770
and then you can run the
integration test from Eclipse

00:28:53.770 --> 00:28:55.440
because you couldn't
extend Eclipse

00:28:55.440 --> 00:28:56.790
to do this kind of stuff.

00:28:56.790 --> 00:28:59.050
Now with Gradle, all
these test features set up

00:28:59.050 --> 00:29:00.480
is implemented in Gradle.

00:29:00.480 --> 00:29:04.330
So if you now can
run, your tests

00:29:04.330 --> 00:29:06.282
executed by Gradle
from an IDE, you

00:29:06.282 --> 00:29:07.740
don't need to go
to any build wiki.

00:29:07.740 --> 00:29:08.910
The developers don't care.

00:29:08.910 --> 00:29:11.672
They just say run my test
and Gradle makes sure

00:29:11.672 --> 00:29:13.380
that all your tests
features are properly

00:29:13.380 --> 00:29:14.950
set up because it's extensible.

00:29:20.440 --> 00:29:24.654
So to wrap this up, I
want to look a little bit

00:29:24.654 --> 00:29:26.320
under the hood of
certain core concepts.

00:29:36.650 --> 00:29:41.025
So this is the plugin that tells
Gradle, hey, this is an Android

00:29:41.025 --> 00:29:41.525
application.

00:29:44.070 --> 00:29:46.970
And we call that a
declarative element.

00:29:46.970 --> 00:29:50.020
I will talk about that in a
second, what we mean by that.

00:29:50.020 --> 00:29:54.240
So first of all, it constitutes
certain conventions.

00:29:54.240 --> 00:29:57.100
If you tell Gradle these
are Android applications,

00:29:57.100 --> 00:30:02.470
we say if you then put certain
things in certain places

00:30:02.470 --> 00:30:06.050
like the source
code and the tests

00:30:06.050 --> 00:30:07.640
as defined by the
conventions, you

00:30:07.640 --> 00:30:10.840
don't need to specify anything.

00:30:10.840 --> 00:30:15.300
And just by those few
lines of code and sticking

00:30:15.300 --> 00:30:18.800
to the conventions,
Gradle will provide you

00:30:18.800 --> 00:30:22.270
all the tasks that are necessary
to deal with this application.

00:30:22.270 --> 00:30:25.627
So that's what we define
as a declarative element

00:30:25.627 --> 00:30:26.460
in the build script.

00:30:26.460 --> 00:30:28.330
The declarative element
in the build script

00:30:28.330 --> 00:30:30.179
is something that
specifies the what.

00:30:30.179 --> 00:30:31.470
This is an Android application.

00:30:31.470 --> 00:30:36.990
The how is automatically
figured out for you by Gradle.

00:30:36.990 --> 00:30:42.070
We call this the
executional units that every

00:30:42.070 --> 00:30:43.120
build system has.

00:30:43.120 --> 00:30:45.070
You don't need to
specify the [INAUDIBLE].

00:30:45.070 --> 00:30:47.120
And it's fully imperative.

00:30:47.120 --> 00:30:50.940
You, as a build
author, or as someone

00:30:50.940 --> 00:30:52.480
that specifies the
build-- with Ant,

00:30:52.480 --> 00:30:55.030
you have to do all the
specifications directly

00:30:55.030 --> 00:30:57.770
via the executional
units by the targets.

00:30:57.770 --> 00:31:00.130
With Gradle, you have
declarative elements,

00:31:00.130 --> 00:31:02.030
and the executional
units are derived.

00:31:04.550 --> 00:31:08.720
So then you can run the
sample debug and whatnot.

00:31:08.720 --> 00:31:10.520
So the interesting
thing-- and this

00:31:10.520 --> 00:31:12.790
is where Gradle goes way
beyond other declarative

00:31:12.790 --> 00:31:15.610
build systems-- you have
very fine grained declarative

00:31:15.610 --> 00:31:20.380
elements-- so build types,
you can specify release type,

00:31:20.380 --> 00:31:24.270
or we have the product
flavors where you can specify

00:31:24.270 --> 00:31:25.580
free and paid product flavors.

00:31:25.580 --> 00:31:27.560
And those are not simple.

00:31:27.560 --> 00:31:30.460
This is not like simple
configuration actions

00:31:30.460 --> 00:31:31.280
what you're doing.

00:31:31.280 --> 00:31:35.450
You are really using new
declarative elements.

00:31:35.450 --> 00:31:36.750
What do I mean with that?

00:31:36.750 --> 00:31:39.850
When you specify I have
a free product flavor,

00:31:39.850 --> 00:31:44.160
you trigger a whole
little mini framework.

00:31:44.160 --> 00:31:46.370
When you specify
the free flavor,

00:31:46.370 --> 00:31:51.170
Gradle will automatically
create a number of tasks

00:31:51.170 --> 00:31:55.610
to deal with this free
flavor-- assemble the free APK

00:31:55.610 --> 00:31:57.870
or the resource
generation, the test task

00:31:57.870 --> 00:32:01.740
that only executes the
test for the free flavor.

00:32:01.740 --> 00:32:04.070
You have a certain set
of conventions in place.

00:32:04.070 --> 00:32:07.292
If you now put code
in source free,

00:32:07.292 --> 00:32:08.750
it will be
automatically picked up.

00:32:08.750 --> 00:32:11.100
So this is a very
powerful element.

00:32:11.100 --> 00:32:17.180
And after adding the fact
that you have a free flavor,

00:32:17.180 --> 00:32:19.610
you can see all the tasks
that are automatically

00:32:19.610 --> 00:32:23.210
created as part of that.

00:32:23.210 --> 00:32:27.820
So for us, declarative elements
are a very important concept

00:32:27.820 --> 00:32:32.590
to give you the right
mixture between flexibility

00:32:32.590 --> 00:32:34.240
and structure,
high-level declarative

00:32:34.240 --> 00:32:36.545
elements that you
can pick and choose

00:32:36.545 --> 00:32:37.795
to describe your requirements.

00:32:40.440 --> 00:32:44.560
And what is a key goal for us
is that you can describe it

00:32:44.560 --> 00:32:46.180
with your domain language.

00:32:46.180 --> 00:32:48.920
We don't make you think
like a build system.

00:32:48.920 --> 00:32:51.020
You can think like an
Android developer specifying

00:32:51.020 --> 00:32:53.920
what you need, and we translate
it into build system concepts,

00:32:53.920 --> 00:32:56.150
if you need to do some
really deep customization.

00:32:56.150 --> 00:32:59.070
Yes, you need to understand
the build system,

00:32:59.070 --> 00:33:01.610
but not for your normal work.

00:33:01.610 --> 00:33:04.430
OK, finally, performance.

00:33:04.430 --> 00:33:09.341
So let's talk about the
Gradle core performance,

00:33:09.341 --> 00:33:11.590
unrelated to Android, just
the Gradle performance as a

00:33:11.590 --> 00:33:13.120
build system.

00:33:13.120 --> 00:33:19.470
Gradle is a very
fast build system.

00:33:19.470 --> 00:33:22.850
So if you look at
Java and you execute,

00:33:22.850 --> 00:33:27.045
let's say, a 25
sub-module Java build,

00:33:27.045 --> 00:33:30.880
you just say, hey, clean and
create me all the JARs of that.

00:33:33.437 --> 00:33:35.270
And I think with the
latest Gradle versions,

00:33:35.270 --> 00:33:36.870
it will be under two seconds.

00:33:36.870 --> 00:33:38.412
You can do it in parallel.

00:33:38.412 --> 00:33:39.870
So with the latest
Gradle versions,

00:33:39.870 --> 00:33:41.350
it will be under one second.

00:33:41.350 --> 00:33:46.920
And if you do incremental
mode, you know what I mean.

00:33:50.030 --> 00:33:53.490
And we always continue
to work on that.

00:33:53.490 --> 00:33:58.760
This is now a 200
sub-module build.

00:33:58.760 --> 00:34:02.900
And even that, if you
do a full, clean build,

00:34:02.900 --> 00:34:04.610
it's not strictly slow.

00:34:07.390 --> 00:34:09.190
And again, we have
improved that even

00:34:09.190 --> 00:34:11.610
since I did the recordings.

00:34:11.610 --> 00:34:14.550
So seven seconds for
a 200 sub-module build

00:34:14.550 --> 00:34:17.469
with a lot of code is fine.

00:34:22.270 --> 00:34:24.639
We are working with some
very large software stacks.

00:34:24.639 --> 00:34:27.230
And they have extraordinary
performance requirements,

00:34:27.230 --> 00:34:29.569
and our goal is
to be the fastest

00:34:29.569 --> 00:34:30.840
build system in the world.

00:34:30.840 --> 00:34:33.790
And especially for
those large teams,

00:34:33.790 --> 00:34:37.860
to bring them finally
into the agile land.

00:34:37.860 --> 00:34:40.560
When you have to wait for one
hour until your build finishes,

00:34:40.560 --> 00:34:42.030
you can't do agile development.

00:34:42.030 --> 00:34:44.600
And the LinkedIn
build time got down

00:34:44.600 --> 00:34:46.929
when we're creating from Ant
to Gradle from five hours

00:34:46.929 --> 00:34:48.727
to 30 to 40 minutes.

00:34:48.727 --> 00:34:49.560
It's still too long.

00:34:49.560 --> 00:34:51.156
We want to get it
down under a minute.

00:34:51.156 --> 00:34:52.989
We want to get there
with distributed builds

00:34:52.989 --> 00:34:55.210
and stuff like that.

00:34:55.210 --> 00:34:57.220
There's a lot of
stuff we want to do.

00:34:57.220 --> 00:35:00.330
We want to be insanely fast,
even for very large projects.

00:35:00.330 --> 00:35:03.430
But the key message
here is-- but even

00:35:03.430 --> 00:35:07.500
if we had all those
capabilities already in Gradle,

00:35:07.500 --> 00:35:10.990
that wouldn't remove the
major bottlenecks with Android

00:35:10.990 --> 00:35:14.190
build performance that
you're facing nowadays.

00:35:14.190 --> 00:35:16.760
So let's look at the
Android tool check.

00:35:16.760 --> 00:35:20.940
Oh, I will show that later.

00:35:20.940 --> 00:35:23.460
So you have Android.

00:35:23.460 --> 00:35:25.230
It's good to be aware
of those layouts.

00:35:25.230 --> 00:35:27.870
You have the Gradle
Java performance.

00:35:27.870 --> 00:35:30.980
It's very different from the
Gradle Android performance.

00:35:30.980 --> 00:35:33.045
One reason is that
the Java compiler

00:35:33.045 --> 00:35:36.570
is very fast, whereas the
dexing is not quite as fast.

00:35:36.570 --> 00:35:38.520
If the Java compiler
were 10 times faster

00:35:38.520 --> 00:35:42.732
and the Gradle builds were
10 times faster than Java,

00:35:42.732 --> 00:35:43.920
you shouldn't praise us.

00:35:43.920 --> 00:35:47.240
You should praise Oracle,
Java C Team right?

00:35:47.240 --> 00:35:50.490
So we integrate with
low-level tool chains

00:35:50.490 --> 00:35:54.320
as is also the
case with Android.

00:35:54.320 --> 00:35:58.530
So if you have bottlenecks in
Android tooling, it's nothing.

00:35:58.530 --> 00:35:59.950
We don't maintain those tools.

00:35:59.950 --> 00:36:01.682
We can just use them.

00:36:01.682 --> 00:36:03.140
At the end of the
day, I understand

00:36:03.140 --> 00:36:04.681
that you want fast
builds, and that's

00:36:04.681 --> 00:36:07.190
what we will achieve
more and more.

00:36:07.190 --> 00:36:09.080
But it's still important
to understand that.

00:36:16.724 --> 00:36:18.473
So you have the Android
tooling maintained

00:36:18.473 --> 00:36:19.681
by the Android Platform Team.

00:36:19.681 --> 00:36:21.756
You have the Gradle
platform maintained by us.

00:36:21.756 --> 00:36:23.630
You have the Gradle
Android plugin maintained

00:36:23.630 --> 00:36:25.130
by the Android
Tooling Team, and you

00:36:25.130 --> 00:36:27.220
have Android Studio
IDE, also maintained

00:36:27.220 --> 00:36:28.790
by the Android Tooling Team.

00:36:28.790 --> 00:36:32.300
Android Studio is usually never
the source for any bottlenecks.

00:36:32.300 --> 00:36:37.409
It's the three layers
below Android Studio that

00:36:37.409 --> 00:36:38.950
have been improved
a lot, but we will

00:36:38.950 --> 00:36:41.550
continue to improve
that you will

00:36:41.550 --> 00:36:42.890
have a very fast experience.

00:36:42.890 --> 00:36:45.294
But still, it's interesting
to understand that there

00:36:45.294 --> 00:36:46.210
are different layouts.

00:36:51.260 --> 00:36:57.100
So all of those teams, they
are working closely together

00:36:57.100 --> 00:37:00.666
to achieve that goal, and they
are all doing a great job,

00:37:00.666 --> 00:37:02.540
and it's just that you
can't solve everything

00:37:02.540 --> 00:37:03.860
at the same time.

00:37:03.860 --> 00:37:06.420
It was a lot of work to
introduce the new system.

00:37:06.420 --> 00:37:08.720
It's a massive--
including a new IDE.

00:37:11.550 --> 00:37:14.170
So certain optimizations
will follow up later,

00:37:14.170 --> 00:37:16.880
and they are now all
a work in progress.

00:37:16.880 --> 00:37:22.100
So let's talk about the
Gradle, and by the way,

00:37:22.100 --> 00:37:26.857
this was just a tweet today
from Gradle 2.4 to 2.8.

00:37:26.857 --> 00:37:28.690
Incremental builds went
down from 10 seconds

00:37:28.690 --> 00:37:30.760
to 5 seconds on one
project and 20 seconds

00:37:30.760 --> 00:37:32.570
to 11 seconds on another.

00:37:32.570 --> 00:37:36.699
So always remember to upgrade
to the latest Gradle versions.

00:37:36.699 --> 00:37:38.740
We did a lot of improvements
at the moment coming

00:37:38.740 --> 00:37:40.156
with every release,
and we release

00:37:40.156 --> 00:37:42.320
every four to six weeks.

00:37:42.320 --> 00:37:43.969
And use the Gradle
demon if you are

00:37:43.969 --> 00:37:45.260
building from the command line.

00:37:58.874 --> 00:38:01.330
OK, let's not talk about that.

00:38:01.330 --> 00:38:06.210
So let's look at some numbers--
how things have improved.

00:38:06.210 --> 00:38:10.010
So let's ignore 1.2/2.2.1.

00:38:10.010 --> 00:38:13.250
So you see the big improvements
we have for let's say a 10

00:38:13.250 --> 00:38:16.510
Android-- pretty big Android
build-- 10 sub-projects, 10

00:38:16.510 --> 00:38:18.175
variants per sub-project.

00:38:18.175 --> 00:38:22.570
s We got the build time
down significantly.

00:38:22.570 --> 00:38:24.280
This is now pretty extreme.

00:38:24.280 --> 00:38:27.980
One Android project
with 400 variants.

00:38:27.980 --> 00:38:30.160
So if you're not
on Gradle 2.4, that

00:38:30.160 --> 00:38:32.450
is the minimum you
should be at because that

00:38:32.450 --> 00:38:35.390
had dramatic performance
improvements.

00:38:35.390 --> 00:38:39.770
So let's talk about the
existing bottlenecks.

00:38:39.770 --> 00:38:45.210
So what I use as my Guinea
pig is the Google IO Android

00:38:45.210 --> 00:38:47.530
app from 2014.

00:38:47.530 --> 00:38:48.280
It's on GitHub.

00:38:48.280 --> 00:38:49.010
It's open source.

00:38:49.010 --> 00:38:51.960
So it's a nice Guinea pig.

00:38:51.960 --> 00:38:53.220
It is pretty representative.

00:38:53.220 --> 00:38:55.480
It has a bunch of open
source libraries it's using

00:38:55.480 --> 00:38:57.730
and whatnot.

00:38:57.730 --> 00:38:59.660
So when you look where
the time is going,

00:38:59.660 --> 00:39:04.010
if you do a clean install-- at
the end of the day, what you're

00:39:04.010 --> 00:39:07.580
interested in is as the
developer, you do some changes,

00:39:07.580 --> 00:39:09.290
and then you want
to see the changes.

00:39:09.290 --> 00:39:12.250
Either you want to run your
instrument tests, which

00:39:12.250 --> 00:39:15.580
require an install,
or you want to work

00:39:15.580 --> 00:39:20.720
with the deployed application
on your virtual device.

00:39:20.720 --> 00:39:28.830
So you see the big
bottlenecks are

00:39:28.830 --> 00:39:32.330
dexing and pre-dexing
and installation.

00:39:32.330 --> 00:39:35.100
That is where, I don't
know, 90% of the time

00:39:35.100 --> 00:39:37.859
is going-- when you do a
clean install-- when you move

00:39:37.859 --> 00:39:39.150
everything and you build again.

00:39:42.600 --> 00:39:44.850
So I want to talk a little
bit about the pre-dexing.

00:39:44.850 --> 00:39:48.290
So the libraries your Android
project depends on also

00:39:48.290 --> 00:39:51.020
need to be dexed, not just
your compiled source code.

00:39:51.020 --> 00:39:55.250
And this is done during
the pre-dex step.

00:39:55.250 --> 00:39:59.365
And the Google Android plugin
caches the dex libraries

00:39:59.365 --> 00:40:01.340
so that the next time
you run the build, dexing

00:40:01.340 --> 00:40:03.560
will be much faster.

00:40:03.560 --> 00:40:07.500
But if you do a clean build,
this cache is always deleted,

00:40:07.500 --> 00:40:11.310
and all the libraries you depend
on needs to be pre-dexed again.

00:40:11.310 --> 00:40:14.770
And if you look at
this, pre-dexing

00:40:14.770 --> 00:40:17.230
takes the longest time.

00:40:17.230 --> 00:40:20.390
So clean builds are
heavily penalized,

00:40:20.390 --> 00:40:23.349
if you like, or first
builds because pre-dexing,

00:40:23.349 --> 00:40:25.640
all the libraries you are
using takes such a long time.

00:40:32.410 --> 00:40:37.380
What we want to do over the
next three to six months

00:40:37.380 --> 00:40:39.140
is a couple of things.

00:40:39.140 --> 00:40:41.750
First of all, the
pre-dexing of your libraries

00:40:41.750 --> 00:40:43.600
is not happening in parallel.

00:40:43.600 --> 00:40:47.300
So when you have 15 libraries,
one is dexed after the other.

00:40:47.300 --> 00:40:52.290
The other thing that is
something we want to improve.

00:40:52.290 --> 00:40:55.390
We want to put your pre-dexed
libraries into a cache that

00:40:55.390 --> 00:40:57.115
survives a clean.

00:40:57.115 --> 00:40:58.490
Sometimes you need
to do a clean,

00:40:58.490 --> 00:41:00.698
and then when you always
have to have the pre-dexing,

00:41:00.698 --> 00:41:02.760
it's a pain in the neck.

00:41:02.760 --> 00:41:05.460
So we want to basically
put the pre-dexed libraries

00:41:05.460 --> 00:41:08.470
into our library cache that
will survive the clean.

00:41:08.470 --> 00:41:13.350
So this kind of cache that
is much more long-lived,

00:41:13.350 --> 00:41:15.680
we want to use for those
pre-dexed libraries.

00:41:15.680 --> 00:41:19.620
Of course, we have to store
the version of the dexing tool

00:41:19.620 --> 00:41:22.500
chain so that if you upgrade
to new dexed version,

00:41:22.500 --> 00:41:24.690
we don't want to use
this cached version.

00:41:24.690 --> 00:41:28.167
So we need to have a
reliability in there.

00:41:28.167 --> 00:41:29.750
But that is something
we will work on.

00:41:29.750 --> 00:41:33.680
So that means the
pre-dexing will

00:41:33.680 --> 00:41:35.784
become faster because
we'll paralyze it,

00:41:35.784 --> 00:41:36.950
and it will survive a clean.

00:41:36.950 --> 00:41:39.340
So you will have to
do it much less often.

00:41:39.340 --> 00:41:42.450
So pre-dexing-- that is how
it is going to be addressed.

00:41:49.500 --> 00:41:54.970
And what we also are going
to start working on next year

00:41:54.970 --> 00:41:56.950
is a distributed cache.

00:41:56.950 --> 00:42:02.095
This means I talked about that
we put the pre-dexed libraries

00:42:02.095 --> 00:42:04.470
into a cache on your local
machine that survives a clean.

00:42:04.470 --> 00:42:07.800
The next step is to put it
in a cache that can be shared

00:42:07.800 --> 00:42:09.100
with all your developers.

00:42:09.100 --> 00:42:12.010
So if one developer has
already pre-dexed the library,

00:42:12.010 --> 00:42:13.920
then get it.

00:42:13.920 --> 00:42:14.800
Don't do it again.

00:42:14.800 --> 00:42:17.820
Or you see iBuild has
already done that, get it.

00:42:17.820 --> 00:42:20.360
All those sources will
feed the distributed cache

00:42:20.360 --> 00:42:21.880
with build output.

00:42:21.880 --> 00:42:25.630
And then other members of the
team don't need to rebuild it,

00:42:25.630 --> 00:42:29.580
which means if you are not
just a one person team,

00:42:29.580 --> 00:42:32.950
if you have 10, 50 people,
or let's say even 10 people,

00:42:32.950 --> 00:42:36.140
in the CI server it means
you will hardly ever

00:42:36.140 --> 00:42:41.170
have to wait for pre-dexing
once this is implemented.

00:42:41.170 --> 00:42:47.230
So caching, pre-dex
libraries across clean builds

00:42:47.230 --> 00:42:49.789
and paralyzing
pre-dexing will cut

00:42:49.789 --> 00:42:51.830
the amount developers need
to wait for pre-dexing

00:42:51.830 --> 00:42:53.900
by an order of magnitude.

00:42:53.900 --> 00:42:57.310
So that's good news.

00:42:57.310 --> 00:42:59.000
Those are the things
we want to do.

00:42:59.000 --> 00:43:01.360
So this is now the
most common cycle.

00:43:01.360 --> 00:43:02.667
You don't do a clean build.

00:43:02.667 --> 00:43:03.750
You are in Android Studio.

00:43:03.750 --> 00:43:06.470
You say, hey, I
did some changes.

00:43:06.470 --> 00:43:08.000
Now, reinstall to my device.

00:43:08.000 --> 00:43:13.860
Now the situation is like--
and you only, let's say,

00:43:13.860 --> 00:43:16.860
changed a single class.

00:43:16.860 --> 00:43:19.760
Still, you have now
no pre-dexing anymore.

00:43:19.760 --> 00:43:24.260
So it's twice as fast,
but still 33 seconds.

00:43:24.260 --> 00:43:26.460
It's not paradise.

00:43:26.460 --> 00:43:28.965
So most of the time is
spent now on dexing.

00:43:31.680 --> 00:43:34.630
And then the other
big chunk is install.

00:43:38.840 --> 00:43:42.410
And we will continue to work
on making the other bits

00:43:42.410 --> 00:43:44.340
before dexing-- all
the stuff Gradle

00:43:44.340 --> 00:43:46.660
needs to do before dexing--
configuration time.

00:43:46.660 --> 00:43:49.590
This will get faster and
faster, but obviously,

00:43:49.590 --> 00:43:52.710
even if we get all the
other stuff down to zero,

00:43:52.710 --> 00:43:56.650
75% is still there.

00:43:56.650 --> 00:43:59.490
That needs to be addressed.

00:43:59.490 --> 00:44:05.650
So not requiring to do a pre-dex
cuts the build time in half.

00:44:05.650 --> 00:44:10.710
So as said, it's not
dominated by dexing.

00:44:10.710 --> 00:44:14.750
And the problem we have at the
moment is a couple of things.

00:44:14.750 --> 00:44:21.360
So first of all,
dexing takes long.

00:44:21.360 --> 00:44:27.250
And it's also not
proportional to the numbers

00:44:27.250 --> 00:44:29.030
of changes you did.

00:44:29.030 --> 00:44:31.970
Whether you change
one file or 100 files,

00:44:31.970 --> 00:44:35.350
everything will always be
re-dexed-- your whole code.

00:44:35.350 --> 00:44:40.030
So you have a non-incremental,
slow dexing right now.

00:44:44.640 --> 00:44:50.580
There's stuff on the
way to improve that.

00:44:50.580 --> 00:44:52.550
There's not much Gradle
can do, nothing at

00:44:52.550 --> 00:44:54.000
all to make dexing faster.

00:44:57.240 --> 00:44:59.360
So the Google
Android platform team

00:44:59.360 --> 00:45:01.770
is working on a new indexing
compiler called Jack.

00:45:01.770 --> 00:45:04.390
Who has heard about Jack?

00:45:04.390 --> 00:45:07.820
So I don't have any deep
knowledge about Jack.

00:45:07.820 --> 00:45:12.110
I can only have a look at the
website what they're doing.

00:45:12.110 --> 00:45:14.845
The idea is that it consolidates
the source group compilation

00:45:14.845 --> 00:45:17.280
and dexing into one step.

00:45:17.280 --> 00:45:23.220
So no longer source bytecodes--
Dalvik bytecode-- but directly

00:45:23.220 --> 00:45:25.900
from source to Dalvik bytecode.

00:45:25.900 --> 00:45:29.670
And Jack has already an
experimental incremental option

00:45:29.670 --> 00:45:31.160
that you can use.

00:45:31.160 --> 00:45:34.450
So there's serious
efforts happening.

00:45:34.450 --> 00:45:37.830
And incremental dexing
plus faster pre-dexing

00:45:37.830 --> 00:45:39.690
will lead to
dramatic improvements

00:45:39.690 --> 00:45:41.170
of development time.

00:45:41.170 --> 00:45:44.750
So I think with a little
bit more patience,

00:45:44.750 --> 00:45:47.680
I think things
with significantly

00:45:47.680 --> 00:45:52.890
improve when it comes to the
performance of your development

00:45:52.890 --> 00:45:55.110
cycles.

00:45:55.110 --> 00:45:57.320
What else will the future bring?

00:45:57.320 --> 00:45:59.360
I talked about
performance in detail.

00:45:59.360 --> 00:46:06.590
For us, this is at the moment,
one of our major R&amp;D efforts.

00:46:06.590 --> 00:46:12.110
And so every Gradle
release will be faster.

00:46:12.110 --> 00:46:13.640
And with the other
changes I talked

00:46:13.640 --> 00:46:15.390
about-- the specific
Android bottlenecks--

00:46:15.390 --> 00:46:18.590
when they are gone, you will
have extremely fast Android

00:46:18.590 --> 00:46:19.090
builds.

00:46:19.090 --> 00:46:22.030
So that day will come.

00:46:22.030 --> 00:46:25.240
There is already the new
experimental Gradle Android

00:46:25.240 --> 00:46:26.930
plugin out there.

00:46:26.930 --> 00:46:29.800
It is based on what we call
the new Gradle model, which

00:46:29.800 --> 00:46:31.510
is much, much
faster configuration

00:46:31.510 --> 00:46:36.140
time, which will eventually give
you parallel task execution.

00:46:36.140 --> 00:46:38.890
So it's still very experimental,
but it's out there.

00:46:38.890 --> 00:46:39.740
It's open source.

00:46:39.740 --> 00:46:43.530
You can use it to see what
the future will give you,

00:46:43.530 --> 00:46:46.280
and the benefits you have
already in this new plugin

00:46:46.280 --> 00:46:48.050
are significant
performance-wise.

00:46:52.550 --> 00:46:59.340
So the new Android plugin,
just the configuration time

00:46:59.340 --> 00:47:02.590
for an Android project
with 10 variants--

00:47:02.590 --> 00:47:04.550
with the next generation
Android plugin,

00:47:04.550 --> 00:47:06.991
it's already cut down by
a factor of three and more

00:47:06.991 --> 00:47:07.490
to come.

00:47:11.390 --> 00:47:14.319
OK, extensibility is
already the very strength

00:47:14.319 --> 00:47:15.235
of the build platform.

00:47:19.200 --> 00:47:22.160
But especially Android is
pushing our extensibility

00:47:22.160 --> 00:47:23.030
to a certain degree.

00:47:23.030 --> 00:47:25.200
We have the Gradle platform.

00:47:25.200 --> 00:47:27.010
We have the Gradle
Android plugin.

00:47:27.010 --> 00:47:30.740
We have some Gradle plugin by
some virtual testing provider

00:47:30.740 --> 00:47:32.570
in the cloud like Testdroid.

00:47:32.570 --> 00:47:36.780
And then we have organizations
that do their own extension.

00:47:36.780 --> 00:47:41.950
So when you have this kind
of extension hierarchy,

00:47:41.950 --> 00:47:44.410
we now put you
sometimes in a situation

00:47:44.410 --> 00:47:46.300
that you need to do
some workarounds to get

00:47:46.300 --> 00:47:48.930
the configuration order
right and stuff like that.

00:47:48.930 --> 00:47:52.590
So we want even in this very
complex extension scenarios,

00:47:52.590 --> 00:47:56.590
we want to provide you a
more solid extension model.

00:47:56.590 --> 00:47:58.120
That's something
we are working on.

00:47:58.120 --> 00:47:59.840
And even if you don't
use it directly,

00:47:59.840 --> 00:48:03.800
you will benefit
from-- the ecosystem

00:48:03.800 --> 00:48:05.100
can work better for you.

00:48:09.180 --> 00:48:12.010
The other big area we're working
on is dependency management.

00:48:12.010 --> 00:48:14.890
So we want to support
fully variant or variant

00:48:14.890 --> 00:48:17.590
dependency management so
that you can basically

00:48:17.590 --> 00:48:21.430
have Android libraries
and Java libraries that

00:48:21.430 --> 00:48:23.950
are aware not just
about their version

00:48:23.950 --> 00:48:31.344
but also this debug or
release-type library for NDK.

00:48:31.344 --> 00:48:31.885
Is it 64-bit?

00:48:31.885 --> 00:48:33.280
Is it 32-bit?

00:48:33.280 --> 00:48:36.030
And to make that a
first class citizen when

00:48:36.030 --> 00:48:38.070
you do dependency resolution.

00:48:38.070 --> 00:48:41.990
That is exciting work.

00:48:41.990 --> 00:48:44.860
C, C++ is a very
important platform for us.

00:48:44.860 --> 00:48:48.590
We are partnering, for
example, with Unity Technology,

00:48:48.590 --> 00:48:52.180
who are migrating the whole
native stack towards Gradle.

00:48:52.180 --> 00:48:56.280
And the NDK support, in the new
experimental Android plugin,

00:48:56.280 --> 00:48:59.740
will no longer be based on Make,
but on a Gradle C, C++ plugin.

00:48:59.740 --> 00:49:01.910
We're very excited about that.

00:49:01.910 --> 00:49:05.329
So you will have a similar
rich declarative language

00:49:05.329 --> 00:49:07.120
to describe your native
build requirements.

00:49:07.120 --> 00:49:10.320
Who of you is
doing any NDK work?

00:49:10.320 --> 00:49:14.970
So that should be really nice.

00:49:14.970 --> 00:49:21.200
OK so last but not least, we
are releasing a SaaS offering

00:49:21.200 --> 00:49:25.070
very soon that allows you
to connect your local or CI

00:49:25.070 --> 00:49:28.280
builds, all your Gradle
builds in your organization,

00:49:28.280 --> 00:49:29.360
with our SaaS offering.

00:49:29.360 --> 00:49:33.300
And this service will help
you with understanding

00:49:33.300 --> 00:49:36.450
why something is wrong
with your build or help

00:49:36.450 --> 00:49:39.450
a developer to
understand why the build

00:49:39.450 --> 00:49:44.890
is not happy with the code--
why the tests are failing

00:49:44.890 --> 00:49:45.820
and things like that.

00:49:45.820 --> 00:49:47.760
So why is it working locally?

00:49:47.760 --> 00:49:48.760
And why is CI failing?

00:49:48.760 --> 00:49:50.160
And those kind of questions.

00:49:50.160 --> 00:49:53.770
So I'm very excited about that.

00:49:53.770 --> 00:49:56.270
If you're interested, please
sign up for the beta wait list.

00:49:59.660 --> 00:50:03.620
Hopefully in November, we can
have a full GA of that product.

00:50:07.902 --> 00:50:09.360
If you want to
learn more about how

00:50:09.360 --> 00:50:10.943
to work with Gradle
for Android, there

00:50:10.943 --> 00:50:15.720
is now an excellent
Udacity class online.

00:50:15.720 --> 00:50:18.030
It's a Udacity class we
have created together

00:50:18.030 --> 00:50:19.340
with Google and Udacity.

00:50:19.340 --> 00:50:22.220
It's free if you don't take
it as part of the Android Nano

00:50:22.220 --> 00:50:23.640
degree.

00:50:23.640 --> 00:50:26.051
I think it's now over 10,000
people that have already

00:50:26.051 --> 00:50:26.550
signed up.

00:50:26.550 --> 00:50:28.030
It's an old screenshot.

00:50:28.030 --> 00:50:29.550
And Udacity is amazing.

00:50:29.550 --> 00:50:32.240
Who have you has ever
taken a Udacity class?

00:50:32.240 --> 00:50:38.070
I think it's the best online
class experience I ever had.

00:50:38.070 --> 00:50:40.930
And this class is
really, really good.

00:50:40.930 --> 00:50:42.720
So it might be
interesting for you.

00:50:42.720 --> 00:50:44.886
It might be interesting for
some of your colleagues.

00:50:44.886 --> 00:50:48.280
It's really good-- perfect
start into Gradle land.

00:50:48.280 --> 00:50:49.910
We offer our own trainings.

00:50:49.910 --> 00:50:51.975
If you want to get
deeper into Gradle,

00:50:51.975 --> 00:50:54.180
we have introductory and
intermediate classes,

00:50:54.180 --> 00:50:57.180
but also very advanced classes,
all delivered by Gradle core

00:50:57.180 --> 00:50:59.800
engineers, by people that
deeply understand the platform.

00:51:03.550 --> 00:51:05.160
OK, that's it.

00:51:05.160 --> 00:51:05.660
Thank you.

00:51:05.660 --> 00:51:06.243
Any questions?

00:51:09.100 --> 00:51:11.068
[APPLAUSE]

00:51:21.280 --> 00:51:21.780
Questions?

00:51:21.780 --> 00:51:23.222
Yes, please.

00:51:23.222 --> 00:51:25.030
AUDIENCE: The classes--
are they free?

00:51:25.030 --> 00:51:27.301
HANS DOCKTER: No, our
classes are not free.

00:51:27.301 --> 00:51:28.050
We are not Google.

00:51:30.700 --> 00:51:35.470
So the difference is
they are instructor-led.

00:51:35.470 --> 00:51:42.117
So the Udacity class is--
so you can ask questions.

00:51:42.117 --> 00:51:43.700
So you get a good
teaching experience,

00:51:43.700 --> 00:51:46.550
but you can also ask the
Gradle questions you always

00:51:46.550 --> 00:51:49.030
wanted to ask.

00:51:49.030 --> 00:51:49.610
Yes, please.

00:51:49.610 --> 00:51:51.610
AUDIENCE: So I noticed
from the pie chart, about

00:51:51.610 --> 00:51:53.764
30% of the cost--

00:51:53.764 --> 00:51:55.680
HANS DOCKTER: So please,
can you say it again?

00:51:55.680 --> 00:51:59.376
AUDIENCE: So I noticed from the
pie chart about 30% of the cost

00:51:59.376 --> 00:52:01.404
is doing the installation
on the handset.

00:52:01.404 --> 00:52:03.320
And that's basically
just copying

00:52:03.320 --> 00:52:08.165
over files for USB from your
computer over to the handset.

00:52:08.165 --> 00:52:13.500
Is there any plan to basically
if your resources don't change,

00:52:13.500 --> 00:52:17.056
then just leave them on the
handset and [INAUDIBLE] version

00:52:17.056 --> 00:52:18.350
on the handsets.

00:52:18.350 --> 00:52:21.300
Because most of our
apps [INAUDIBLE]--

00:52:21.300 --> 00:52:23.407
most of the
resources and assets.

00:52:23.407 --> 00:52:24.740
HANS DOCKTER: It's a good point.

00:52:24.740 --> 00:52:25.620
I understand it.

00:52:25.620 --> 00:52:29.220
It's something you would need
to ask the Android Tooling Team.

00:52:29.220 --> 00:52:31.160
It's beyond-- it's a good point.

00:52:34.034 --> 00:52:35.450
I would ask it on
Android def list

00:52:35.450 --> 00:52:36.866
or something like
that, what their

00:52:36.866 --> 00:52:39.470
plan-- if there are any plans.

00:52:39.470 --> 00:52:40.774
Yes, please.

00:52:40.774 --> 00:52:43.603
AUDIENCE: I know this is a
read the manual question.

00:52:43.603 --> 00:52:44.760
But since you're here--

00:52:44.760 --> 00:52:47.232
HANS DOCKTER: Yeah, fair enough.

00:52:47.232 --> 00:52:49.998
AUDIENCE: So you were saying,
hey, for the convention,

00:52:49.998 --> 00:52:51.761
you know, you had
the sources folder

00:52:51.761 --> 00:52:53.427
and you had this and
this because you're

00:52:53.427 --> 00:52:54.590
in the Android plugin.

00:52:54.590 --> 00:52:56.027
You just know that.

00:52:56.027 --> 00:52:58.110
You know ' that's just the
way it is all the time.

00:52:58.110 --> 00:52:58.860
HANS DOCKTER: Yes.

00:52:58.860 --> 00:53:01.365
AUDIENCE: Is there a command
line thing where you can say,

00:53:01.365 --> 00:53:04.510
oh, I'm using this Gradle
file, and I run this thing,

00:53:04.510 --> 00:53:07.052
and it will tell me here's where
the source folder should be.

00:53:07.052 --> 00:53:08.384
Here's what this folder or that.

00:53:08.384 --> 00:53:09.590
It'll print that out for me?

00:53:09.590 --> 00:53:10.506
HANS DOCKTER: Not yet.

00:53:10.506 --> 00:53:12.220
But it will be coming.

00:53:12.220 --> 00:53:13.820
So it's a very good point.

00:53:13.820 --> 00:53:16.640
So just to understand
you-- and the consumers

00:53:16.640 --> 00:53:20.840
for that would be new developers
you hire into your team.

00:53:20.840 --> 00:53:23.024
AUDIENCE: Yeah, new
developers and also even me,

00:53:23.024 --> 00:53:25.760
I'm sitting here,
I'm like, ah, man.

00:53:25.760 --> 00:53:29.160
The resource is not RES,
but Android uses RES.

00:53:29.160 --> 00:53:32.140
Java uses resources
folder in that area.

00:53:32.140 --> 00:53:34.990
HANS DOCKTER: Yes,
it's a good point.

00:53:34.990 --> 00:53:36.620
Yes, we understand
that use case,

00:53:36.620 --> 00:53:40.300
and we will provide something.

00:53:40.300 --> 00:53:41.199
But it's nothing.

00:53:41.199 --> 00:53:43.490
Don't read the manual, or
you won't find anything in it

00:53:43.490 --> 00:53:46.470
right now.

00:53:46.470 --> 00:53:49.740
You find other interesting
stuff in there.

00:53:49.740 --> 00:53:53.200
I mean, strictly speaking,
because it's such a rich model,

00:53:53.200 --> 00:53:55.700
I'm just saying,
we should do that.

00:53:55.700 --> 00:53:57.090
But strictly
speaking, I think it

00:53:57.090 --> 00:54:01.110
would take you or someone that
knows a little bit about Gradle

00:54:01.110 --> 00:54:04.840
one hour to create a
plugin that would print out

00:54:04.840 --> 00:54:06.620
that information on the console.

00:54:06.620 --> 00:54:10.530
So at least you could
something about it, right?

00:54:10.530 --> 00:54:11.970
Not that we shouldn't do it.

00:54:11.970 --> 00:54:13.220
So don't misunderstand that.

00:54:13.220 --> 00:54:16.070
But Gradle is so
open and so rich

00:54:16.070 --> 00:54:18.950
that you don't need to
create secret master

00:54:18.950 --> 00:54:20.010
knowledge to do that.

00:54:20.010 --> 00:54:24.274
You could do that in a pretty
straightforward way, actually.

00:54:24.274 --> 00:54:26.690
AUDIENCE: Yeah, well, I was
thinking also the plugin says,

00:54:26.690 --> 00:54:28.736
oh, this might be called source.

00:54:28.736 --> 00:54:32.610
OK, everyone knows
that's a source for Java.

00:54:32.610 --> 00:54:34.594
It might be another
folder called RES,

00:54:34.594 --> 00:54:35.840
but what's RES used for?

00:54:35.840 --> 00:54:37.510
HANS DOCKTER: Yes,
so what you could do,

00:54:37.510 --> 00:54:40.450
that is a nice thing
with the rich model.

00:54:40.450 --> 00:54:42.200
You could ask the
Gradle Android build

00:54:42.200 --> 00:54:49.674
with a Gradle plugin,
hey, what are you--

00:54:49.674 --> 00:54:52.530
all those sources are
represented by rich objects.

00:54:52.530 --> 00:54:57.930
You can say, hey, main
sources object, please

00:54:57.930 --> 00:55:01.950
tell me what is the
path to the Java files?

00:55:01.950 --> 00:55:04.320
What is the path to
the resources files?

00:55:04.320 --> 00:55:06.010
Because it's all in there.

00:55:06.010 --> 00:55:08.180
And then you can print
it out because it's all

00:55:08.180 --> 00:55:08.820
richly modeled.

00:55:08.820 --> 00:55:11.160
And then, oh, hey,
variant container,

00:55:11.160 --> 00:55:12.266
do you have some variants?

00:55:12.266 --> 00:55:13.640
Yeah, give me the
variant object.

00:55:13.640 --> 00:55:17.305
Hey, free variant, tell
me where are the sources

00:55:17.305 --> 00:55:18.180
for the free variant.

00:55:18.180 --> 00:55:19.280
Where are the resources.

00:55:19.280 --> 00:55:20.613
Where are the integration tests.

00:55:20.613 --> 00:55:22.160
So I'm not even exaggerating.

00:55:22.160 --> 00:55:25.610
It would be one hour, and
it would be on the console

00:55:25.610 --> 00:55:28.110
because it's richly
modeled with them.

00:55:28.110 --> 00:55:30.200
It's no magic properties.

00:55:30.200 --> 00:55:31.320
That's what we hate.

00:55:31.320 --> 00:55:34.075
We hate something, oh,
it just somehow made up,

00:55:34.075 --> 00:55:36.700
and there's some magic property
hard-coded in the build script.

00:55:36.700 --> 00:55:39.257
No, it's all changeable
and accessible.

00:55:39.257 --> 00:55:41.340
But yeah, we should come
with this out of the box.

00:55:41.340 --> 00:55:43.300
AUDIENCE: Are we going to do
that at the library today?

00:55:43.300 --> 00:55:44.175
HANS DOCKTER: Pardon?

00:55:44.175 --> 00:55:46.592
AUDIENCE: Are we going to
do that in code shop today?

00:55:46.592 --> 00:55:48.300
HANS DOCKTER: I mean,
my flight is going.

00:55:48.300 --> 00:55:50.240
No, I'm seriously
thinking about it.

00:55:50.240 --> 00:55:51.890
I'm just thinking
about my schedule.

00:55:51.890 --> 00:55:54.065
I might not because I
need to go to the airport.

00:55:57.780 --> 00:55:58.531
Maybe.

00:55:58.531 --> 00:55:59.030
Let's see.

00:55:59.030 --> 00:56:02.194
Maybe I hack it up on
the way back in the plane

00:56:02.194 --> 00:56:03.360
and will send you something.

00:56:03.360 --> 00:56:04.260
Seriously, we'll see.

00:56:04.260 --> 00:56:05.843
AUDIENCE: I would
say that would help.

00:56:05.843 --> 00:56:07.090
HANS DOCKTER: Yeah, cool.

00:56:07.090 --> 00:56:08.165
Yes, please.

00:56:08.165 --> 00:56:10.498
AUDIENCE: So you mentioned
that we should always upgrade

00:56:10.498 --> 00:56:11.887
to the latest Gradle plugin.

00:56:11.887 --> 00:56:13.690
I know there's been
compatibility issues

00:56:13.690 --> 00:56:17.812
in the past with Android plugin.

00:56:17.812 --> 00:56:21.890
You suggested that we use 2.8
right now, which just came out.

00:56:21.890 --> 00:56:25.450
HANS DOCKTER: Yes, so I
mean, the big compatibility

00:56:25.450 --> 00:56:28.590
issues we had in the
past, and to be fair,

00:56:28.590 --> 00:56:32.340
was when the Gradle Android
plugin was 0.something.

00:56:32.340 --> 00:56:37.550
So they were deliberately--
they were by design-- I mean,

00:56:37.550 --> 00:56:39.449
it was a long period
until we got to 1.0

00:56:39.449 --> 00:56:40.740
with the Gradle Android plugin.

00:56:40.740 --> 00:56:45.930
But in terms of the
contract, it was OK to break.

00:56:45.930 --> 00:56:50.680
But since 1.0 is out, I think
it's extremely compatible

00:56:50.680 --> 00:56:53.800
because we are extremely
backwards compatible.

00:56:57.360 --> 00:56:59.990
So what they were
doing before 1.0,

00:56:59.990 --> 00:57:03.010
they were always-- because
we work closely together,

00:57:03.010 --> 00:57:04.910
I just said, oh, to
make this really good,

00:57:04.910 --> 00:57:08.160
we need a feature that is
only in Gradle 2.0 or only

00:57:08.160 --> 00:57:09.510
in Gradle 2.1.

00:57:09.510 --> 00:57:11.447
And so therefore,
it didn't work.

00:57:11.447 --> 00:57:13.030
The next version of
the Android plugin

00:57:13.030 --> 00:57:14.821
didn't work with an
older version of Gradle

00:57:14.821 --> 00:57:18.510
until they have reached 1.0
where they now invest more

00:57:18.510 --> 00:57:20.740
into backwards compatibility.

00:57:20.740 --> 00:57:22.140
But that was the reason.

00:57:22.140 --> 00:57:24.140
Gradle itself is extremely
backwards compatible.

00:57:24.140 --> 00:57:26.660
We have a massive test
suite-- 16,000 tests.

00:57:26.660 --> 00:57:29.760
And we run it every night
against all different Java

00:57:29.760 --> 00:57:37.260
versions and against cross
versions of Gradle testing.

00:57:37.260 --> 00:57:40.970
So that's something that people
are usually very happy with.

00:57:40.970 --> 00:57:43.810
That is the only reason why
we can't release so often.

00:57:47.430 --> 00:57:49.950
Imagine a team like LinkedIn
with 2,000 engineers.

00:57:49.950 --> 00:57:51.910
If you break them two
times a year to say,

00:57:51.910 --> 00:57:59.092
well, thank you very much,
then they would stop upgrading.

00:57:59.092 --> 00:58:00.800
So we can only have
that speed if we have

00:58:00.800 --> 00:58:02.140
the quality in that respect.

00:58:02.140 --> 00:58:02.640
Yeah.

00:58:05.180 --> 00:58:06.680
OK, enjoy the show.

00:58:06.680 --> 00:58:07.180
Thank you.

00:58:07.180 --> 00:58:08.480
[APPLAUSE]

00:58:08.980 --> 00:58:12.030
[MUSIC PLAYING]

