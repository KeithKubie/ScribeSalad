WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:01.482
[MUSIC PLAYING]

00:00:07.936 --> 00:00:09.310
SUMIR KATARIA:
Thanks for coming.

00:00:09.310 --> 00:00:11.560
Welcome to Working with
WorkManager session.

00:00:11.560 --> 00:00:13.020
My name is Sumir Kataria.

00:00:13.020 --> 00:00:14.587
I'm a software
engineer at Google.

00:00:14.587 --> 00:00:15.420
RAHUL RAVIKUMAR: Hi.

00:00:15.420 --> 00:00:17.130
My name is Rahul
Ravikumar, and I'm also

00:00:17.130 --> 00:00:18.600
a software engineer at Google.

00:00:18.600 --> 00:00:20.891
SUMIR KATARIA: And we both
work on Android architecture

00:00:20.891 --> 00:00:24.150
components, particularly
WorkManager.

00:00:24.150 --> 00:00:25.050
Let me grab my--

00:00:27.620 --> 00:00:28.140
All right.

00:00:28.140 --> 00:00:29.700
So what are we going
to talk about today?

00:00:29.700 --> 00:00:32.324
We're going to give you a State
of the Union about WorkManager.

00:00:32.324 --> 00:00:34.920
It was released at
Google I/O. I want

00:00:34.920 --> 00:00:37.370
to give you an abbreviated
guide to WorkManager.

00:00:37.370 --> 00:00:39.840
So for those of you who haven't
used WorkManager before,

00:00:39.840 --> 00:00:42.840
we want to go over
some of the basic APIs.

00:00:42.840 --> 00:00:47.010
And we're going to spend most
of the time talking about

00:00:47.010 --> 00:00:49.010
WorkManager, the
questions you've asked,

00:00:49.010 --> 00:00:51.540
the things that have been
frequently misunderstood,

00:00:51.540 --> 00:00:56.185
and also, the new changes
that we've made since I/O.

00:00:56.185 --> 00:00:58.941
So let's start with
the State of the Union.

00:00:58.941 --> 00:01:04.019
There have been 11 releases of
WorkManager since Google I/O,

00:01:04.019 --> 00:01:05.670
and these are alpha releases.

00:01:05.670 --> 00:01:10.020
Today was the 11th one.

00:01:10.020 --> 00:01:11.680
And beta's coming soon.

00:01:11.680 --> 00:01:14.160
So those of you who watched
the keynote yesterday

00:01:14.160 --> 00:01:16.770
may have heard that
beta's coming this month.

00:01:16.770 --> 00:01:18.156
This was news to us, too.

00:01:18.156 --> 00:01:19.280
But it's coming this month.

00:01:19.280 --> 00:01:20.527
[LAUGHTER]

00:01:20.527 --> 00:01:23.110
We were very close, but I guess
we're doing it this month now.

00:01:23.110 --> 00:01:25.209
[LAUGHTER]

00:01:25.209 --> 00:01:27.000
So we want to give you
an abbreviated guide

00:01:27.000 --> 00:01:28.836
to WorkManager.

00:01:28.836 --> 00:01:31.320
And what is it, for
those of you who are just

00:01:31.320 --> 00:01:32.490
completely new to this?

00:01:32.490 --> 00:01:35.670
It's a library for managing
deferrable background work.

00:01:35.670 --> 00:01:38.730
It wraps JobScheduler,
and AlarmManager,

00:01:38.730 --> 00:01:39.810
BroadcastReceivers.

00:01:39.810 --> 00:01:42.242
It's backwards
compatible to API 14.

00:01:42.242 --> 00:01:43.950
And those of you who've
used JobScheduler

00:01:43.950 --> 00:01:47.790
will find many of the
concepts very familiar.

00:01:47.790 --> 00:01:49.860
So let's talk about work.

00:01:49.860 --> 00:01:51.555
You've got a unit
of background work--

00:01:51.555 --> 00:01:54.180
and we'll talk a little bit more
about how we create it and how

00:01:54.180 --> 00:01:55.810
we enqueue it later--

00:01:55.810 --> 00:01:59.500
but you've got it, and how does
WorkManager execute this work?

00:01:59.500 --> 00:02:01.950
This is a graph
that might help you.

00:02:01.950 --> 00:02:04.240
While your process
is up and running,

00:02:04.240 --> 00:02:06.030
we'll feed it to
this executor that we

00:02:06.030 --> 00:02:07.227
have that does the work.

00:02:07.227 --> 00:02:08.310
It could be a thread pull.

00:02:08.310 --> 00:02:10.380
You can customize this thing.

00:02:10.380 --> 00:02:12.240
But your process may be killed.

00:02:12.240 --> 00:02:16.230
And WorkManager is
guaranteed to do work.

00:02:16.230 --> 00:02:18.330
It may defer it, but
it will do that work

00:02:18.330 --> 00:02:20.670
when the constraints
for that work are met.

00:02:20.670 --> 00:02:23.080
So we also enqueue
it in the background.

00:02:23.080 --> 00:02:26.650
So if you're API 23+,
we use JobScheduler.

00:02:26.650 --> 00:02:29.010
And before that, we
use an AlarmManager

00:02:29.010 --> 00:02:30.660
and BroadcastReceiver
implementation.

00:02:30.660 --> 00:02:33.000
So whenever the
signals are met--

00:02:33.000 --> 00:02:35.820
let's say that you've put in
some work for a two-hour time

00:02:35.820 --> 00:02:38.250
delay when you have network--

00:02:38.250 --> 00:02:40.940
When all of those
conditions are met,

00:02:40.940 --> 00:02:45.410
it'll still go to
the same executor.

00:02:45.410 --> 00:02:46.102
All right.

00:02:46.102 --> 00:02:48.560
RAHUL RAVIKUMAR: Let's do a
quick API walkthrough for those

00:02:48.560 --> 00:02:51.000
who have not seen the API.

00:02:51.000 --> 00:02:55.380
So the fundamental unit of work
in WorkManager is a Worker.

00:02:55.380 --> 00:02:58.540
Here I'm defining a
calculation Worker.

00:02:58.540 --> 00:02:59.920
It extends to Worker type.

00:02:59.920 --> 00:03:02.010
So now, the only
thing that you need

00:03:02.010 --> 00:03:05.380
to do when you define a new
Worker is to extend doWork.

00:03:05.380 --> 00:03:09.590
And doWork returns a result.
Here I'm returning a success.

00:03:09.590 --> 00:03:12.260
You can also return
a retry or a fail.

00:03:12.260 --> 00:03:13.884
I'm doing some
expensive calculation

00:03:13.884 --> 00:03:14.800
on background threads.

00:03:14.800 --> 00:03:16.230
So you don't have to worry
about threading here,

00:03:16.230 --> 00:03:17.820
because WorkManager
is guaranteed

00:03:17.820 --> 00:03:20.270
to schedule your work
on a background thread.

00:03:20.270 --> 00:03:23.730
And here I am returning a
result of success synchronously.

00:03:23.730 --> 00:03:24.760
So that's it.

00:03:24.760 --> 00:03:26.780
I'm pretty much good to go.

00:03:26.780 --> 00:03:28.380
So now, you've defined a Worker.

00:03:28.380 --> 00:03:31.380
How do you actually
make that work run?

00:03:31.380 --> 00:03:33.790
So for that you need to
enqueue a work request.

00:03:33.790 --> 00:03:36.390
So there are two types of work
requests-- one is a OneTime,

00:03:36.390 --> 00:03:38.340
and the other one is a
PeriodicWork request.

00:03:38.340 --> 00:03:42.300
Here I am using a OneTime
work request builder.

00:03:42.300 --> 00:03:46.050
And I'm building it with
the calculation Worker

00:03:46.050 --> 00:03:48.340
that I just defined
in the previous slide.

00:03:48.340 --> 00:03:50.100
So I'm setting an initial delay.

00:03:50.100 --> 00:03:52.080
And this is a
timing-based constraint.

00:03:52.080 --> 00:03:55.980
And this tells
WorkManager to only run

00:03:55.980 --> 00:03:57.930
the work after two
hours have passed

00:03:57.930 --> 00:03:59.340
since the point of enqueue.

00:03:59.340 --> 00:04:01.440
And I'm also setting
another constraint, which

00:04:01.440 --> 00:04:03.180
is the charging constraint.

00:04:03.180 --> 00:04:05.100
This tells WorkManager
that this work is only

00:04:05.100 --> 00:04:09.000
eligible to run when the device
is actually connected to--

00:04:09.000 --> 00:04:11.130
when the device is
actually charging.

00:04:11.130 --> 00:04:12.030
I add a tag.

00:04:12.030 --> 00:04:14.460
I'll talk about
tags in more detail.

00:04:14.460 --> 00:04:17.470
And I'm finally
calling dot build.

00:04:17.470 --> 00:04:20.450
Now, all I need to do is to
call getInstance and enqueue

00:04:20.450 --> 00:04:20.950
the work.

00:04:20.950 --> 00:04:21.940
And that's it.

00:04:21.940 --> 00:04:24.270
Now the work is scheduled.

00:04:24.270 --> 00:04:26.070
So now you've
schedule your work.

00:04:26.070 --> 00:04:27.780
You've defined a
bunch of constraints.

00:04:27.780 --> 00:04:29.541
And it's hard to keep track.

00:04:29.541 --> 00:04:32.040
And if you want to keep track
of what state your work is in,

00:04:32.040 --> 00:04:36.050
then you want to call
getWorkInfo by real live data.

00:04:36.050 --> 00:04:41.210
And this returns live
data of workInfo.

00:04:41.210 --> 00:04:43.620
And so workInfo is the
type that determines

00:04:43.620 --> 00:04:45.000
the state of your work.

00:04:45.000 --> 00:04:48.330
And live data here is a life
cycle of our observable.

00:04:48.330 --> 00:04:51.000
So once you attach it
to a life cycle owner

00:04:51.000 --> 00:04:52.937
and you define an
observer, you can

00:04:52.937 --> 00:04:55.020
observe the state transitions
of the work request.

00:04:55.020 --> 00:04:57.730
So it'll go something like--

00:04:57.730 --> 00:05:00.360
once you enqueue the work,
it'll go into enqueue.

00:05:00.360 --> 00:05:03.150
Once the constraints are
met, it'll go into a running.

00:05:03.150 --> 00:05:05.680
And then finally, because
you return success,

00:05:05.680 --> 00:05:07.140
it is going to succeed at state.

00:05:07.140 --> 00:05:11.160
So remember that tag that we
added when we built the OneTime

00:05:11.160 --> 00:05:12.370
work request?

00:05:12.370 --> 00:05:15.840
You can also get work
infos by tag, live data.

00:05:15.840 --> 00:05:20.160
And tag is something that you
associate with a work request.

00:05:20.160 --> 00:05:21.400
And there can be one to many.

00:05:21.400 --> 00:05:24.300
So we can associate the same
tag to multiple work requests.

00:05:24.300 --> 00:05:28.320
And here I'm calling it
workInfos by tag live data,

00:05:28.320 --> 00:05:30.250
which runs a live data again.

00:05:30.250 --> 00:05:32.010
Notice how it returns
a list of workInfo

00:05:32.010 --> 00:05:33.820
and not a single workInfo.

00:05:33.820 --> 00:05:35.610
And again, I can
do the same things

00:05:35.610 --> 00:05:37.390
that I did in the
previous slide.

00:05:37.390 --> 00:05:40.500
So one of the coolest
features of WorkManager

00:05:40.500 --> 00:05:42.150
is the ability to chain work.

00:05:42.150 --> 00:05:45.780
So that helps you define
an acyclic graph of work.

00:05:45.780 --> 00:05:49.830
And here I'm asking WorkManager
to begin with a, b, and c.

00:05:49.830 --> 00:05:53.230
And here, a, b, and
c are work requests.

00:05:53.230 --> 00:05:55.380
And I'm seeing that
d and e are only

00:05:55.380 --> 00:05:58.680
eligible to run once all
a, b, and c are done.

00:05:58.680 --> 00:06:01.600
And when I used
to begin with API,

00:06:01.600 --> 00:06:04.380
I'm asking WorkManager to
run a, b, and c potentially

00:06:04.380 --> 00:06:05.430
in parallel.

00:06:05.430 --> 00:06:08.370
Whether they actually
run in parallel

00:06:08.370 --> 00:06:10.920
is determined by the
capabilities of the device

00:06:10.920 --> 00:06:13.060
and the size of
your thread pull.

00:06:13.060 --> 00:06:16.290
And finally, I'm calling
[INAUDIBLE] on f, g, and h

00:06:16.290 --> 00:06:17.160
again.

00:06:17.160 --> 00:06:20.730
Now, f, g, and h will only run
once all the preceding works

00:06:20.730 --> 00:06:21.547
are done.

00:06:21.547 --> 00:06:23.130
Finally, don't forget
to call enqueue.

00:06:23.130 --> 00:06:26.910
That's when all
the magic happens.

00:06:26.910 --> 00:06:29.010
So now you called enqueue.

00:06:29.010 --> 00:06:32.870
Now, you might be wondering
what begin with returns.

00:06:32.870 --> 00:06:35.250
So begin with actually
returns an instance

00:06:35.250 --> 00:06:36.660
of work continuation.

00:06:36.660 --> 00:06:39.900
And a work continuation is a
node in your [INAUDIBLE] graph.

00:06:39.900 --> 00:06:42.234
And this lends to
a very fluent API.

00:06:42.234 --> 00:06:43.650
So every time you
call begin with,

00:06:43.650 --> 00:06:45.252
it returns a new continuation.

00:06:45.252 --> 00:06:46.710
And every time you
call dot den, it

00:06:46.710 --> 00:06:49.380
returns a new instance
of another continuation.

00:06:49.380 --> 00:06:51.400
Finally, don't forget
to call enqueue.

00:06:51.400 --> 00:06:53.640
The one important thing
that you need to remember

00:06:53.640 --> 00:06:58.080
is, when you chain work, the
outputs of the parent work

00:06:58.080 --> 00:07:00.870
request become inputs
to your descending work

00:07:00.870 --> 00:07:02.550
request, or your children.

00:07:02.550 --> 00:07:06.810
This helps you manage state and
send states from parent work

00:07:06.810 --> 00:07:09.680
to the descendant work.

00:07:09.680 --> 00:07:13.400
Now, finally,
WorkManager also exposes

00:07:13.400 --> 00:07:15.420
the APIs to cancel work.

00:07:15.420 --> 00:07:17.780
So for some reason if
you want to do that,

00:07:17.780 --> 00:07:19.550
you can cancel work by ID.

00:07:19.550 --> 00:07:21.810
And every work request
has a unique ID.

00:07:21.810 --> 00:07:24.140
So here we are canceling
work by that ID.

00:07:24.140 --> 00:07:26.480
And we can also cancel
all work by tag.

00:07:26.480 --> 00:07:28.490
So those are the two APIs.

00:07:28.490 --> 00:07:29.330
And that's it.

00:07:32.177 --> 00:07:33.760
SUMIR KATARIA: And
I want to point out

00:07:33.760 --> 00:07:38.020
that all the APIs as we've
been showing are for alpha 11,

00:07:38.020 --> 00:07:40.120
so you may notice
some slight changes,

00:07:40.120 --> 00:07:43.060
for those of you who have
been using this API before.

00:07:43.060 --> 00:07:45.349
But everything is live today.

00:07:45.349 --> 00:07:47.890
So let's talk a little bit about
how you can get the most out

00:07:47.890 --> 00:07:48.515
of WorkManager.

00:07:48.515 --> 00:07:52.030
Manager And these also include
questions like, how do I

00:07:52.030 --> 00:07:54.410
do a certain type of task?

00:07:54.410 --> 00:07:57.190
Why does this work
a certain way?

00:07:57.190 --> 00:08:00.250
And the biggest one that we get
a question about is threading.

00:08:00.250 --> 00:08:02.930
How does threading
work in WorkManager?

00:08:02.930 --> 00:08:04.750
So we talked about
a work request.

00:08:04.750 --> 00:08:06.355
Rahul just mentioned that.

00:08:06.355 --> 00:08:07.690
And you enqueue it.

00:08:07.690 --> 00:08:09.190
What happens to it then?

00:08:09.190 --> 00:08:12.220
So we have an internal
task executor.

00:08:12.220 --> 00:08:15.220
You can think of it as a
single-threaded executor.

00:08:15.220 --> 00:08:18.230
And the enqueue
goes to that, which

00:08:18.230 --> 00:08:20.010
stores it in a local database.

00:08:20.010 --> 00:08:22.010
So every app that
uses WorkManager

00:08:22.010 --> 00:08:23.460
has a WorkManager database.

00:08:23.460 --> 00:08:24.750
This is the source of truth.

00:08:24.750 --> 00:08:27.140
This is where we keep track
of the state of your work--

00:08:27.140 --> 00:08:30.560
your inputs and
outputs, everything

00:08:30.560 --> 00:08:31.880
with the dependency chains.

00:08:31.880 --> 00:08:34.015
Everything goes
in this database.

00:08:34.015 --> 00:08:37.140
So after it's been enqueued,
sometime later your constraints

00:08:37.140 --> 00:08:37.980
are met.

00:08:37.980 --> 00:08:39.690
And the OS tells you that.

00:08:39.690 --> 00:08:42.480
If you have no constraints,
it's eligible to run right away.

00:08:42.480 --> 00:08:44.880
If there are constraints,
the OS will tell you, oh.

00:08:44.880 --> 00:08:46.050
You have network.

00:08:46.050 --> 00:08:47.850
You are charging right now.

00:08:47.850 --> 00:08:49.080
Whatever it is.

00:08:49.080 --> 00:08:52.680
Same task executor--
uses a WorkerFactory

00:08:52.680 --> 00:08:53.650
to create a Worker.

00:08:53.650 --> 00:08:55.950
WorkerFactory is
exactly what it is.

00:08:55.950 --> 00:08:57.380
It's a factory for Workers.

00:08:57.380 --> 00:08:58.810
And you can make your own.

00:08:58.810 --> 00:09:00.750
You can customize and
do things with that.

00:09:00.750 --> 00:09:03.500
We'll talk more
about that later.

00:09:03.500 --> 00:09:07.370
After the Worker's been created,
we execute it on an executor.

00:09:07.370 --> 00:09:10.790
And this is also a thing that
you can actually customize.

00:09:10.790 --> 00:09:13.890
We'll talk more about
that later as well.

00:09:13.890 --> 00:09:16.220
But what if you don't
want to execute something

00:09:16.220 --> 00:09:17.060
on that executor?

00:09:17.060 --> 00:09:18.500
We give you a default one.

00:09:18.500 --> 00:09:20.330
You can specify
your own, but what

00:09:20.330 --> 00:09:21.590
if you're using our Ex.java?

00:09:21.590 --> 00:09:23.700
What if you're
using code routines?

00:09:23.700 --> 00:09:25.700
What if you have your
own bespoke solution

00:09:25.700 --> 00:09:29.146
that you want to use to run
things in the background?

00:09:29.146 --> 00:09:31.140
This was a request that
came up quite a lot

00:09:31.140 --> 00:09:33.514
when we first
released WorkManager.

00:09:33.514 --> 00:09:36.760
So to do this, we
want to provide you

00:09:36.760 --> 00:09:41.050
an API to let you
do work on your own

00:09:41.050 --> 00:09:43.050
and just tell us when it's done.

00:09:43.050 --> 00:09:45.700
So you want to signal async
work completion to us.

00:09:45.700 --> 00:09:48.550
And for that, we use a class
called ListenableFuture.

00:09:48.550 --> 00:09:51.940
Those of you who use Guava will
be very familiar with this.

00:09:51.940 --> 00:09:53.359
But we split it out--

00:09:53.359 --> 00:09:55.150
And the Guava team has
helped us with this,

00:09:55.150 --> 00:09:56.989
so everybody's
collaboratively worked

00:09:56.989 --> 00:09:59.280
on splitting this out to its
own lightweight artifacts.

00:09:59.280 --> 00:10:02.080
So you don't need a full
Guava dependency for this.

00:10:02.080 --> 00:10:05.880
It's literally one
or two classes now.

00:10:05.880 --> 00:10:08.620
And it's a future that can
have one or more listeners,

00:10:08.620 --> 00:10:10.510
and those listeners
can be invoked

00:10:10.510 --> 00:10:11.672
on a specified executor.

00:10:11.672 --> 00:10:12.380
That's all it is.

00:10:12.380 --> 00:10:14.240
It's very simple.

00:10:14.240 --> 00:10:16.080
So using this
ListenableFuture, we

00:10:16.080 --> 00:10:17.884
made a class called
ListenableWorker,

00:10:17.884 --> 00:10:20.050
which only has one method
that you need to override.

00:10:20.050 --> 00:10:21.370
It's called startWork.

00:10:21.370 --> 00:10:24.290
We'll call startWork on
the main thread for you.

00:10:24.290 --> 00:10:26.670
You give us back a
ListenableFuture.

00:10:26.670 --> 00:10:29.500
You do whatever work you want
on whatever thread you want,

00:10:29.500 --> 00:10:32.650
and when you're done, just
set the result on the future.

00:10:32.650 --> 00:10:34.420
And we'll be able
to listen for it,

00:10:34.420 --> 00:10:37.340
and we'll be able
to react to it.

00:10:37.340 --> 00:10:39.510
So the actual threading
model in WorkManager

00:10:39.510 --> 00:10:41.190
is, after your
constraints are met,

00:10:41.190 --> 00:10:43.620
it goes to the task
executor, which

00:10:43.620 --> 00:10:47.376
uses the WorkerFactory to
create a ListenableWorker.

00:10:47.376 --> 00:10:51.800
We call startWork on it and
we also attach a listener.

00:10:51.800 --> 00:10:55.700
So we can listen to
whenever you're done.

00:10:55.700 --> 00:10:57.170
What this means
is that the Worker

00:10:57.170 --> 00:11:00.590
class, which is still around,
is a simple ListenableWorker.

00:11:00.590 --> 00:11:04.336
So we've got the doWork
method that we talked about.

00:11:04.336 --> 00:11:06.180
We override the
startWork for you.

00:11:06.180 --> 00:11:08.042
We create a future.

00:11:08.042 --> 00:11:09.604
On that background
executor that I

00:11:09.604 --> 00:11:11.520
talked about-- the one
we provide by default--

00:11:11.520 --> 00:11:13.672
we execute the work.

00:11:13.672 --> 00:11:15.350
And we, of course,
return the future.

00:11:18.170 --> 00:11:20.050
So now, we have two classes--

00:11:20.050 --> 00:11:21.830
Worker and ListenableWorker.

00:11:21.830 --> 00:11:23.620
What's the differences
between them?

00:11:23.620 --> 00:11:26.960
Workers, we consider
those a simple class.

00:11:26.960 --> 00:11:29.710
For most use cases, we
think that's sufficient,

00:11:29.710 --> 00:11:32.230
is a class that
runs synchronously

00:11:32.230 --> 00:11:35.305
and on a pre-specified
background thread.

00:11:35.305 --> 00:11:37.670
ListenableWorker
runs asynchronously

00:11:37.670 --> 00:11:39.660
on an unspecified
background thread.

00:11:39.660 --> 00:11:43.140
So Worker dot doWork
is a synchronous API.

00:11:43.140 --> 00:11:46.580
You're expected to finish
what you're doing there.

00:11:46.580 --> 00:11:48.860
If you're trying to
create a ListenableWorker,

00:11:48.860 --> 00:11:51.230
you may need to return a
ListenableFuture, which

00:11:51.230 --> 00:11:52.640
is an interface.

00:11:52.640 --> 00:11:55.100
If you have access to
Guava, you have access

00:11:55.100 --> 00:11:57.144
to many kinds of
ListenableFutures.

00:11:57.144 --> 00:11:58.560
If you don't have
access to Guava,

00:11:58.560 --> 00:12:00.620
or don't want to
add the dependency,

00:12:00.620 --> 00:12:03.170
ResolvableFuture is a
lightweight implementation

00:12:03.170 --> 00:12:06.800
that we provide in Android X
concurrent concurrent futures.

00:12:06.800 --> 00:12:08.600
So you can use that.

00:12:08.600 --> 00:12:10.290
So let's look at an example.

00:12:10.290 --> 00:12:12.230
One of the things
that a lot of people

00:12:12.230 --> 00:12:15.440
are trying and doing
incorrectly with Workers

00:12:15.440 --> 00:12:17.540
is that they're trying
to get locations.

00:12:17.540 --> 00:12:20.350
And we're going to specifically
use the Fused Location provider

00:12:20.350 --> 00:12:20.870
client.

00:12:20.870 --> 00:12:23.720
So if you listen to the Kotlin
Suspenders talk yesterday,

00:12:23.720 --> 00:12:25.210
they also used this.

00:12:25.210 --> 00:12:28.280
It's a JMS core API
to asynchronously get

00:12:28.280 --> 00:12:31.050
your location.

00:12:31.050 --> 00:12:33.600
Remember that a Worker
class is synchronous.

00:12:33.600 --> 00:12:36.630
So if you attach a callback and
later get informed about it,

00:12:36.630 --> 00:12:40.690
but return success, your
work is already completed.

00:12:40.690 --> 00:12:43.222
It's not going to work
the way you think it is.

00:12:43.222 --> 00:12:46.160
So first thing we do here-- we
are using a ListenableWorker--

00:12:46.160 --> 00:12:47.790
is we create a ResolvableFuture.

00:12:47.790 --> 00:12:49.790
So this is the future
that we'll return and do

00:12:49.790 --> 00:12:51.265
all our bookkeeping on.

00:12:51.265 --> 00:12:53.040
In the startWork
method we'll check

00:12:53.040 --> 00:12:54.290
to see if we have permissions.

00:12:54.290 --> 00:12:59.600
If we don't, we'll set
a failure on the future.

00:12:59.600 --> 00:13:01.570
Otherwise, what
we'll do is, we'll

00:13:01.570 --> 00:13:04.120
get that Fused Location
provider's last location.

00:13:04.120 --> 00:13:07.560
This is kind of like
a future in JMS core--

00:13:07.560 --> 00:13:11.029
or Google Play services world.

00:13:11.029 --> 00:13:13.320
We'll call this getLocation
method, which I'll go into.

00:13:13.320 --> 00:13:14.770
And then we return to future.

00:13:14.770 --> 00:13:17.714
So that's the
high-level startWork.

00:13:17.714 --> 00:13:23.880
In the getLocation method,
we'll use that task

00:13:23.880 --> 00:13:25.950
and we'll add a listener to it.

00:13:25.950 --> 00:13:28.980
If the task is successful,
we'll pass that location back

00:13:28.980 --> 00:13:30.480
with a success status.

00:13:30.480 --> 00:13:33.389
Otherwise, we'll set an
exception on the future.

00:13:33.389 --> 00:13:33.930
So that's it.

00:13:33.930 --> 00:13:36.960
We've basically
addressed the three cases

00:13:36.960 --> 00:13:39.060
where we want to
have a successful

00:13:39.060 --> 00:13:41.460
or an unsuccessful task, or
if we don't have permissions.

00:13:41.460 --> 00:13:45.330
And WorkManager will
attach that listener.

00:13:45.330 --> 00:13:47.490
It'll listen to the success
or failure of your task

00:13:47.490 --> 00:13:50.940
and do the bookkeeping
as necessary.

00:13:50.940 --> 00:13:51.635
All right.

00:13:51.635 --> 00:13:53.510
RAHUL RAVIKUMAR: Let's
talk about operations.

00:13:53.510 --> 00:13:56.630
Now, remember, Sumir
mentioned that WorkManager

00:13:56.630 --> 00:13:58.850
uses the database as
a source of truth.

00:13:58.850 --> 00:14:01.647
So any time you enqueue
or you cancel work,

00:14:01.647 --> 00:14:03.230
we have to do some
bookkeeping, and we

00:14:03.230 --> 00:14:06.630
have to make sure we keep track
of what your intentions were.

00:14:06.630 --> 00:14:09.150
So these involve
rights to a database,

00:14:09.150 --> 00:14:11.570
and because there are
rights to a database,

00:14:11.570 --> 00:14:13.490
we have to do them on
a background thread.

00:14:13.490 --> 00:14:16.670
So as a result,
they're asynchronous.

00:14:16.670 --> 00:14:18.560
What if you actually
wanted to do something

00:14:18.560 --> 00:14:21.560
after the enqueue happened,
or the cancel happened?

00:14:21.560 --> 00:14:24.050
So you want to make sure that
those operations completed

00:14:24.050 --> 00:14:26.720
before you want to
do some more stuff.

00:14:26.720 --> 00:14:30.230
So for that, you've
introduced a new API.

00:14:30.230 --> 00:14:31.780
So now, enqueue and cancel--

00:14:31.780 --> 00:14:34.550
actually return a new
type called operation.

00:14:34.550 --> 00:14:36.710
Operation is a very
simple interface.

00:14:36.710 --> 00:14:38.210
It has two methods--

00:14:38.210 --> 00:14:41.660
so it has a getState API,
which returns a live data

00:14:41.660 --> 00:14:43.490
of an operation dot state.

00:14:43.490 --> 00:14:45.500
If you attach an observer
to this live data,

00:14:45.500 --> 00:14:49.280
you will see that the operation
transitions from an in progress

00:14:49.280 --> 00:14:51.530
to a successful or a failure.

00:14:51.530 --> 00:14:53.770
You can also call
getResult, and this

00:14:53.770 --> 00:14:56.030
returns the familiar
ListenableFuture type.

00:14:56.030 --> 00:14:59.900
And remember that this API
will only return the terminal

00:14:59.900 --> 00:15:00.972
state of the operation.

00:15:00.972 --> 00:15:02.680
It won't give you the
intermediate state.

00:15:02.680 --> 00:15:04.790
So if you're
attaching a listener,

00:15:04.790 --> 00:15:07.600
you'll only ever get a
success or a failure.

00:15:07.600 --> 00:15:09.129
And with the exception--

00:15:09.129 --> 00:15:10.670
telling you why the
failure happened.

00:15:14.598 --> 00:15:16.770
SUMIR KATARIA: Another
question a lot of people have

00:15:16.770 --> 00:15:19.290
is, when is work stopped?

00:15:19.290 --> 00:15:23.412
What happens when you stop
work on behalf of WorkManager?

00:15:26.190 --> 00:15:26.930
All right.

00:15:26.930 --> 00:15:29.810
So there's three cases
when work is stopped.

00:15:29.810 --> 00:15:32.420
The first is very simple-- your
constraints are no longer met.

00:15:32.420 --> 00:15:34.100
So you said, for
example, that I need

00:15:34.100 --> 00:15:36.140
a network to do
this upload task,

00:15:36.140 --> 00:15:37.640
but your network got lost.

00:15:37.640 --> 00:15:40.180
So we both stop your
work at that point.

00:15:40.180 --> 00:15:41.690
A second case is
that they always

00:15:41.690 --> 00:15:43.839
preempted your work for
some reason-- for example,

00:15:43.839 --> 00:15:45.380
you exceeded the
10-minute time limit

00:15:45.380 --> 00:15:47.090
that the OS gives
you to do your work.

00:15:47.090 --> 00:15:52.310
Or the device decided to go into
doze mode for battery savings,

00:15:52.310 --> 00:15:54.417
or something like that.

00:15:54.417 --> 00:15:56.750
And the third reason is that
you just canceled your work

00:15:56.750 --> 00:15:59.860
somewhere else in your app.

00:15:59.860 --> 00:16:01.380
How do we stop work?

00:16:01.380 --> 00:16:04.330
There is a method
ListenableWorkeronStopped.

00:16:04.330 --> 00:16:06.264
We call this method
when we stop.

00:16:06.264 --> 00:16:07.180
So just override this.

00:16:07.180 --> 00:16:09.659
Then you get your stop
signal right there.

00:16:09.659 --> 00:16:11.950
We also cancel [INAUDIBLE]
future that we talked about.

00:16:11.950 --> 00:16:15.961
So you can also just add your
own listener and look for that.

00:16:15.961 --> 00:16:18.199
So this is when one
of these two things

00:16:18.199 --> 00:16:20.240
happens for you, whichever
one you're looking at.

00:16:20.240 --> 00:16:23.692
This is your signal to be a
good citizen and clean up.

00:16:23.692 --> 00:16:25.400
Because after this is
called, the process

00:16:25.400 --> 00:16:27.180
may be killed by the OS.

00:16:27.180 --> 00:16:32.580
So if the OS woke up your app's
process just to run this work,

00:16:32.580 --> 00:16:35.130
it could actually kill
it when it decides

00:16:35.130 --> 00:16:36.894
that the work should stop.

00:16:36.894 --> 00:16:42.380
And if you happen to return
something after this signal--

00:16:42.380 --> 00:16:45.372
say you return a success--
we ignore it, because as far

00:16:45.372 --> 00:16:47.330
as we're concerned, your
work has been stopped.

00:16:47.330 --> 00:16:51.286
Whatever you are doing is no
longer necessary to be done.

00:16:51.286 --> 00:16:53.930
You can also pull for
stoppages in your Worker.

00:16:53.930 --> 00:16:56.110
So you can also call
the isStopped method.

00:16:56.110 --> 00:16:58.550
And that will tell
you whether you've

00:16:58.550 --> 00:17:00.200
been signaled for stopping.

00:17:00.200 --> 00:17:04.140
So let's look at how you can
be a good citizen and clean up.

00:17:04.140 --> 00:17:06.470
So let's say in
this example we're

00:17:06.470 --> 00:17:07.880
parsing a file asynchronously.

00:17:07.880 --> 00:17:10.380
Let's say it's a huge file, so
you're doing it in a Worker.

00:17:10.380 --> 00:17:13.730
And you've got that familiar
ResolvableFuture thing

00:17:13.730 --> 00:17:14.930
that I showed you earlier.

00:17:14.930 --> 00:17:16.410
You've also got
this input stream,

00:17:16.410 --> 00:17:18.079
so you're reading
the file, right?

00:17:18.079 --> 00:17:20.280
So in startWork
you say, parseFile.

00:17:20.280 --> 00:17:22.790
This is doing something
asynchronously,

00:17:22.790 --> 00:17:24.926
and you return to future.

00:17:24.926 --> 00:17:26.410
Here's parseFile.

00:17:26.410 --> 00:17:30.289
So you've got some executor
or whatever-- a coroutine,

00:17:30.289 --> 00:17:31.080
it doesn't matter--

00:17:31.080 --> 00:17:35.012
You're asynchronously doing
that runable that follows.

00:17:35.012 --> 00:17:37.130
So the first thing
you might be doing

00:17:37.130 --> 00:17:38.810
is, you're opening the file.

00:17:38.810 --> 00:17:40.730
You're reading each
bite out of the file,

00:17:40.730 --> 00:17:42.380
doing something with that bite--

00:17:42.380 --> 00:17:44.300
and then when you're
done, you set a success

00:17:44.300 --> 00:17:45.726
because you're done.

00:17:45.726 --> 00:17:49.550
And then you have the necessary
try catch, finally, after that,

00:17:49.550 --> 00:17:52.400
so that you can clean
up after yourself.

00:17:52.400 --> 00:17:55.650
So how do we handle when
your work gets stopped

00:17:55.650 --> 00:17:57.882
while this is executing?

00:17:57.882 --> 00:18:00.650
So like I said, we override
the onStopped method.

00:18:00.650 --> 00:18:04.670
Let's say that we want to
just finish what we're doing.

00:18:04.670 --> 00:18:08.461
We could easily just close
that input's file stream.

00:18:08.461 --> 00:18:08.960
OK.

00:18:08.960 --> 00:18:11.250
So what happens now
you've done that?

00:18:11.250 --> 00:18:12.710
Let's go back to the code.

00:18:12.710 --> 00:18:17.064
Well, if you're in the
middle of that read loop

00:18:17.064 --> 00:18:19.230
and you close a file, it
throws an exception, right?

00:18:19.230 --> 00:18:21.530
Next time you try to read
something-- well, fortunately,

00:18:21.530 --> 00:18:23.655
you're already handling
that exception right there.

00:18:23.655 --> 00:18:26.040
So it looks like
you're good, right?

00:18:26.040 --> 00:18:27.962
You're done.

00:18:27.962 --> 00:18:28.619
Or are you?

00:18:28.619 --> 00:18:30.160
There's one more
case that you forgot

00:18:30.160 --> 00:18:33.910
about here, which is that,
what if the onStopped happens

00:18:33.910 --> 00:18:35.780
before you even open the file?

00:18:35.780 --> 00:18:38.262
So now you're no longer
looking for that stopped

00:18:38.262 --> 00:18:39.970
thing, because you
never got that signal.

00:18:39.970 --> 00:18:42.100
You'll read that file
because it opened

00:18:42.100 --> 00:18:44.800
after you tried to close it,
which it didn't do anything

00:18:44.800 --> 00:18:45.640
for.

00:18:45.640 --> 00:18:47.080
So you'll do all of this work.

00:18:47.080 --> 00:18:49.960
And how you fix it is,
use that isStopped method.

00:18:49.960 --> 00:18:52.630
So basically, while
you're in that loop,

00:18:52.630 --> 00:18:54.339
you can always just
make sure that you're

00:18:54.339 --> 00:18:55.254
looking for stoppages.

00:18:55.254 --> 00:18:56.770
So this is a good
example of how you

00:18:56.770 --> 00:19:00.940
would honor the OS's signal to
you, or WorkManager's signal

00:19:00.940 --> 00:19:04.186
to you, that you should
stop and be a good citizen.

00:19:04.186 --> 00:19:06.050
All right.

00:19:06.050 --> 00:19:08.540
RAHUL RAVIKUMAR: So every
time you enqueue a method--

00:19:08.540 --> 00:19:10.617
or every time you
enqueue a work request--

00:19:10.617 --> 00:19:12.950
the work request goes through
several state transitions.

00:19:12.950 --> 00:19:15.360
And I'll talk about
how they look.

00:19:15.360 --> 00:19:18.480
So let's look at the life
of a OneTime work request.

00:19:18.480 --> 00:19:20.660
So when you enqueue
a new work request,

00:19:20.660 --> 00:19:23.270
it can end up in one of two
states-- it can be blocked,

00:19:23.270 --> 00:19:25.340
if it's blocked on
another work request,

00:19:25.340 --> 00:19:26.780
given it's a chain work--

00:19:26.780 --> 00:19:28.720
or it can be enqueued.

00:19:28.720 --> 00:19:31.800
Once the constraints are
met, it goes into running.

00:19:31.800 --> 00:19:34.280
And this is the point
at which the Worker's

00:19:34.280 --> 00:19:37.140
being actively executed.

00:19:37.140 --> 00:19:39.330
Depending on the result
that you return on

00:19:39.330 --> 00:19:41.010
how you signal work
completion, we'll

00:19:41.010 --> 00:19:42.593
take it to one of
the terminal states.

00:19:42.593 --> 00:19:45.750
So if the Worker
returns success,

00:19:45.750 --> 00:19:50.760
then we'll terminate it
with a succeeded state.

00:19:50.760 --> 00:19:53.610
If the Worker returns
a failure, then we'll

00:19:53.610 --> 00:19:54.570
mark it as a failure.

00:19:54.570 --> 00:19:56.910
And that also is
a terminal state.

00:19:56.910 --> 00:20:00.240
At any point in time while the
Worker was in a non-terminating

00:20:00.240 --> 00:20:02.160
state if you call cancel, then--

00:20:02.160 --> 00:20:02.790
sorry.

00:20:02.790 --> 00:20:04.980
If you actually
retry, then we'll

00:20:04.980 --> 00:20:07.270
apply the back-off policy,
and then we'll retry.

00:20:07.270 --> 00:20:09.840
So the Worker will go back
to the enqueued state.

00:20:09.840 --> 00:20:13.260
At any point in time if you
have a non-terminating state

00:20:13.260 --> 00:20:15.670
and you call cancel,
it'll end up in canceled.

00:20:15.670 --> 00:20:18.510
So this is what a life
of a OneTime work request

00:20:18.510 --> 00:20:19.800
looks like.

00:20:19.800 --> 00:20:22.350
Let's look at PeriodicWork.

00:20:22.350 --> 00:20:24.820
PeriodicWork is almost the same.

00:20:24.820 --> 00:20:27.460
Because periodic work
can't be chained,

00:20:27.460 --> 00:20:28.630
there is no blocked state.

00:20:28.630 --> 00:20:30.930
So it all ends up in
the enqueued state.

00:20:30.930 --> 00:20:34.770
Once the constraints are
met, it will go into running.

00:20:34.770 --> 00:20:37.077
So whether you
succeed or you retry,

00:20:37.077 --> 00:20:38.660
it will go back to
the enqueued state.

00:20:38.660 --> 00:20:40.460
Now, this might seem confusing.

00:20:40.460 --> 00:20:42.950
If you succeed, then the
work really isn't done,

00:20:42.950 --> 00:20:44.370
because it's a PeriodicWork.

00:20:44.370 --> 00:20:46.580
We'll just wait for
the next interval.

00:20:46.580 --> 00:20:49.069
If you fail and you
ask us to retry,

00:20:49.069 --> 00:20:51.110
then we'll apply the
appropriate back-off policy,

00:20:51.110 --> 00:20:53.510
and then we'll increment
the run attempt count.

00:20:53.510 --> 00:20:55.447
So we'll tell you that
this is the second time

00:20:55.447 --> 00:20:57.530
that you're trying to run
it for that last period.

00:21:01.050 --> 00:21:03.396
If you mark your work
as failed, then we'll

00:21:03.396 --> 00:21:04.770
transition into
the failed state.

00:21:04.770 --> 00:21:07.740
At that point, your
PeriodicWork won't run again.

00:21:07.740 --> 00:21:11.220
And again, any time your work
is in a non-terminal state,

00:21:11.220 --> 00:21:14.770
and if you ask us to cancel
it, we'll mark it canceled.

00:21:14.770 --> 00:21:18.550
So let's apply those rules to
how life of a chain of work

00:21:18.550 --> 00:21:19.640
looks like.

00:21:19.640 --> 00:21:22.490
So here is the parent
of all Workers.

00:21:22.490 --> 00:21:25.530
So when you enqueue
this chain of work,

00:21:25.530 --> 00:21:28.600
only a is in the enqueued
state, and all descendants of a

00:21:28.600 --> 00:21:30.250
are actually blocked now.

00:21:30.250 --> 00:21:31.270
Right?

00:21:31.270 --> 00:21:33.080
So let's assume a's
constraints are met

00:21:33.080 --> 00:21:35.290
and it goes into
[INAUDIBLE] running state.

00:21:35.290 --> 00:21:38.680
Once it's done-- let's
assume it succeeded--

00:21:38.680 --> 00:21:40.240
So it unblocks b and c now.

00:21:40.240 --> 00:21:44.560
So b and c, now, become unqueued
and then they go into running.

00:21:44.560 --> 00:21:45.940
And for the sake
of the argument,

00:21:45.940 --> 00:21:48.400
let's assume that b
succeeds and c fails.

00:21:48.400 --> 00:21:50.230
What happens now?

00:21:50.230 --> 00:21:52.750
Because b succeeded,
it unblocks d.

00:21:52.750 --> 00:21:56.500
So d goes into the
enqueued state.

00:21:56.500 --> 00:21:59.050
But notice what happened
to e, f, and g--

00:21:59.050 --> 00:22:00.640
They all failed.

00:22:00.640 --> 00:22:04.760
So the key takeaway is that,
if a unit of work fails,

00:22:04.760 --> 00:22:07.720
then all descendant is
also marked as failed.

00:22:07.720 --> 00:22:10.420
If a unit of work is canceled,
then all of its descendants

00:22:10.420 --> 00:22:11.470
are also marked canceled.

00:22:15.910 --> 00:22:17.910
SUMIR KATARIA: So I want
to talk about something

00:22:17.910 --> 00:22:18.960
called unique work.

00:22:18.960 --> 00:22:22.230
And let's start with a
little question here--

00:22:22.230 --> 00:22:23.430
what's wrong with this code?

00:22:23.430 --> 00:22:26.870
So you've got an application
object in the onCreate.

00:22:26.870 --> 00:22:29.256
You're enqueuing
some PeriodicWork.

00:22:29.256 --> 00:22:31.840
The problem here-- and I've
seen this in a few bugs--

00:22:31.840 --> 00:22:34.600
is that this enqueues
PeriodicWork every time

00:22:34.600 --> 00:22:36.219
your app process starts.

00:22:36.219 --> 00:22:38.260
And that's probably not
what you're trying to do.

00:22:38.260 --> 00:22:40.660
You're trying to
set up a sync here.

00:22:40.660 --> 00:22:43.930
Let's say it's syncing
your data every day.

00:22:43.930 --> 00:22:47.770
If you call this code
every time the app starts--

00:22:47.770 --> 00:22:49.540
every time you've
got another thing

00:22:49.540 --> 00:22:52.940
that's syncing your code-- you
really only want one of them.

00:22:52.940 --> 00:22:55.430
So unique work,
basically, is something

00:22:55.430 --> 00:22:58.880
that lets you specify conflict
policies for a database insert.

00:22:58.880 --> 00:22:59.930
Think of it like that.

00:22:59.930 --> 00:23:02.705
If you insert the same
key into a database again,

00:23:02.705 --> 00:23:03.830
what do you want to happen?

00:23:03.830 --> 00:23:05.871
Do you want to overwrite
what's already in there?

00:23:05.871 --> 00:23:08.010
You want to ignore what
you're trying to do?

00:23:08.010 --> 00:23:09.320
That's what unique work does.

00:23:09.320 --> 00:23:13.010
It basically is a conflict
policy for WorkManager.

00:23:13.010 --> 00:23:14.240
And here's the syntax for it.

00:23:14.240 --> 00:23:15.031
It's pretty simple.

00:23:15.031 --> 00:23:16.400
UniqueName is that key.

00:23:16.400 --> 00:23:18.620
It's that something
that uniquely

00:23:18.620 --> 00:23:22.330
identifies that chain of work.

00:23:22.330 --> 00:23:25.580
Policy is the existing
work policy, or what

00:23:25.580 --> 00:23:28.520
we call the conflict policies.

00:23:28.520 --> 00:23:31.234
And then you obviously
have your requests.

00:23:31.234 --> 00:23:34.410
So the existing work policies
are the interesting things.

00:23:34.410 --> 00:23:36.020
There's three of them.

00:23:36.020 --> 00:23:38.220
The first one is keep,
which is, it keeps

00:23:38.220 --> 00:23:39.720
the existing unfinished work.

00:23:39.720 --> 00:23:42.480
So if you have things that
are in blocked, running,

00:23:42.480 --> 00:23:45.510
or enqueued, it will keep them.

00:23:45.510 --> 00:23:48.750
And if the work is
already finished

00:23:48.750 --> 00:23:50.340
or it's not there
to begin with, it

00:23:50.340 --> 00:23:53.850
will enqueue whatever you just
sent along with that call.

00:23:53.850 --> 00:23:55.440
The next one is replace.

00:23:55.440 --> 00:23:58.740
It always replaces the work
requests in the database.

00:23:58.740 --> 00:24:00.390
If your work is
running, it'll get

00:24:00.390 --> 00:24:03.660
stopped, as I described
a few minutes earlier.

00:24:03.660 --> 00:24:05.400
It cancels the old
work and it stops it.

00:24:05.400 --> 00:24:07.500
That's what it does.

00:24:07.500 --> 00:24:09.530
Append is a special one.

00:24:09.530 --> 00:24:11.960
It basically appends
to that chain of work.

00:24:11.960 --> 00:24:13.630
So for example, this
is useful if you

00:24:13.630 --> 00:24:16.220
are trying to do something
in order-- for example,

00:24:16.220 --> 00:24:18.500
you're trying to
build a messaging app,

00:24:18.500 --> 00:24:20.360
and you're sending
messages in order.

00:24:20.360 --> 00:24:24.950
So you may have a unique chain
of work for sending messages,

00:24:24.950 --> 00:24:27.821
and you want to append new
messages to the end of it.

00:24:27.821 --> 00:24:29.570
So it's basically
creating a tree for you.

00:24:32.492 --> 00:24:33.380
All right.

00:24:33.380 --> 00:24:35.630
RAHUL RAVIKUMAR: Remember,
Sumir mentioned that in one

00:24:35.630 --> 00:24:37.700
of his previous slides
on [INAUDIBLE] how

00:24:37.700 --> 00:24:39.810
one can customize WorkManager.

00:24:39.810 --> 00:24:42.900
So let's look at all the
things that you can do.

00:24:42.900 --> 00:24:46.700
So you can actually
specify a WorkerFactory

00:24:46.700 --> 00:24:48.740
that can be used to
instantiate your Workers

00:24:48.740 --> 00:24:50.090
and ListenableWorkers.

00:24:50.090 --> 00:24:52.010
And this is especially
useful in the context

00:24:52.010 --> 00:24:53.105
of dependency injection.

00:24:53.105 --> 00:24:56.030
So if you're using Dagger and
you want to inject something

00:24:56.030 --> 00:24:58.490
into your Worker before
the Worker starts,

00:24:58.490 --> 00:25:00.230
this is a good place to do that.

00:25:00.230 --> 00:25:02.540
You can also specify
the default executor

00:25:02.540 --> 00:25:05.510
that you want all
Workers to use.

00:25:05.510 --> 00:25:07.640
You can specify the
logging verbosity

00:25:07.640 --> 00:25:09.805
if you want to distinguish
between a build

00:25:09.805 --> 00:25:11.180
and a release
build, and you want

00:25:11.180 --> 00:25:13.880
to make sure you
log more information

00:25:13.880 --> 00:25:15.380
to diagnose your problems.

00:25:15.380 --> 00:25:18.200
And then you also specify
various other JobScheduler

00:25:18.200 --> 00:25:20.900
parameters, like
number of jobs that you

00:25:20.900 --> 00:25:23.157
want us to send to
JobScheduler, the ideas of jobs

00:25:23.157 --> 00:25:24.740
that you want us to
use in case you're

00:25:24.740 --> 00:25:27.650
already using
JobScheduler before.

00:25:27.650 --> 00:25:30.230
So if you want to
customize WorkManager,

00:25:30.230 --> 00:25:33.090
then you have to disable the
default WorkManager Initializer

00:25:33.090 --> 00:25:33.650
first.

00:25:33.650 --> 00:25:36.950
So for that, you have to add
this entry to your Manifest.

00:25:36.950 --> 00:25:39.710
And note the tools node remove.

00:25:39.710 --> 00:25:41.520
That means you
are removing this.

00:25:41.520 --> 00:25:43.722
You don't want this
entry to get merged.

00:25:43.722 --> 00:25:45.930
So now that you have disabled
the default WorkManager

00:25:45.930 --> 00:25:46.490
Initializer.

00:25:46.490 --> 00:25:48.950
The next step is to, actually,
create a new instance

00:25:48.950 --> 00:25:49.800
of configuration.

00:25:49.800 --> 00:25:52.370
So here I am using the
configuration builder,

00:25:52.370 --> 00:25:56.512
and I'm overriding it to
specify my own custom executor.

00:25:56.512 --> 00:25:58.095
So now that I've
done that, I can just

00:25:58.095 --> 00:26:00.274
call a WorkManager.Initialize.

00:26:00.274 --> 00:26:02.690
I specified the application
context and the configuration,

00:26:02.690 --> 00:26:03.960
and I'm done.

00:26:03.960 --> 00:26:06.350
So make sure you do this in
your Application#onCreate

00:26:06.350 --> 00:26:08.300
or ContentProvider#onCreate.

00:26:08.300 --> 00:26:12.650
Because the operating system
can actually invoke job services

00:26:12.650 --> 00:26:13.620
on your behalf.

00:26:13.620 --> 00:26:17.130
And when job services
are being invoked,

00:26:17.130 --> 00:26:18.927
WorkManager needs
to be initialized.

00:26:22.517 --> 00:26:24.100
SUMIR KATARIA:
Finally, the last thing

00:26:24.100 --> 00:26:25.910
we want to talk about
before we wrap up

00:26:25.910 --> 00:26:29.330
is some tips for all the
library developers out there.

00:26:29.330 --> 00:26:31.870
If you're using WorkManager
in your library,

00:26:31.870 --> 00:26:34.850
you have some special use cases
that we want to think about.

00:26:34.850 --> 00:26:37.360
So the general advice we
give for library developers

00:26:37.360 --> 00:26:39.340
is, because WorkManager
is a singleton

00:26:39.340 --> 00:26:43.350
and the application initializes
it, as Rahul just showed you,

00:26:43.350 --> 00:26:46.150
you are not really in
control of what's there.

00:26:46.150 --> 00:26:47.680
Rely on the defaults.

00:26:47.680 --> 00:26:49.060
So use a default WorkerFactory.

00:26:49.060 --> 00:26:52.250
The default WorkerFactory
that we provide

00:26:52.250 --> 00:26:54.700
creates Workers and
ListenableWorkers

00:26:54.700 --> 00:26:56.131
using reflection.

00:26:56.131 --> 00:26:58.630
Rely on that, because you don't
know what else is happening.

00:26:58.630 --> 00:27:01.090
If you need some particular
dependency injection

00:27:01.090 --> 00:27:03.460
or anything else of
that sort, you'll

00:27:03.460 --> 00:27:06.014
have to have a
contract with the app.

00:27:06.014 --> 00:27:08.140
Silo your work with tags.

00:27:08.140 --> 00:27:11.330
So Rahul also showed you
how to tag your work.

00:27:11.330 --> 00:27:15.670
If you silo all your work--
meaning you put your prefix,

00:27:15.670 --> 00:27:20.020
or your package name, or your
library name in your tags--

00:27:20.020 --> 00:27:22.180
you can easily identify
all the work that's yours.

00:27:22.180 --> 00:27:26.214
You don't have to worry
about other people's work.

00:27:26.214 --> 00:27:27.880
You don't have to
deal with any of that.

00:27:27.880 --> 00:27:30.190
You can just get your work
and operate on just that,

00:27:30.190 --> 00:27:32.680
if you don't know the IDs.

00:27:32.680 --> 00:27:34.990
Finally, we do provide
the ability for apps

00:27:34.990 --> 00:27:36.550
to wipe away all work.

00:27:36.550 --> 00:27:39.160
And this is generally
for privacy reasons.

00:27:39.160 --> 00:27:41.050
This is not something
we expect to be called,

00:27:41.050 --> 00:27:43.660
but it's for that
critical use case

00:27:43.660 --> 00:27:47.320
where you have to wipe
user data for some reason.

00:27:47.320 --> 00:27:48.910
So as a library
developer, how do you

00:27:48.910 --> 00:27:52.210
find out if your work's been
wiped or gone from under you?

00:27:52.210 --> 00:27:58.280
You should look at
getLastCancelAllTimeMillis.

00:27:58.280 --> 00:28:02.000
It's a very confusing name.

00:28:02.000 --> 00:28:02.500
OK.

00:28:02.500 --> 00:28:03.790
Next steps.

00:28:03.790 --> 00:28:06.220
So get WorkManager if
you haven't already.

00:28:06.220 --> 00:28:08.380
And for those of you who
have, thank you very much.

00:28:08.380 --> 00:28:10.720
Your feedback's been invaluable.

00:28:10.720 --> 00:28:13.930
We're up to alpha 11, so
there's three general categories

00:28:13.930 --> 00:28:14.740
of artifacts here.

00:28:14.740 --> 00:28:16.160
There's the runtime.

00:28:16.160 --> 00:28:19.630
There's the KTX stuff, which
includes a quarantines Worker

00:28:19.630 --> 00:28:20.770
that we just put in.

00:28:20.770 --> 00:28:22.730
So you don't have
to write your own.

00:28:22.730 --> 00:28:25.960
And then there's
testing support as well.

00:28:25.960 --> 00:28:27.840
These are some helpful links.

00:28:27.840 --> 00:28:30.910
Schedule tasks with WorkManager
is the developer.android.com

00:28:30.910 --> 00:28:35.770
section for WorkManager.

00:28:35.770 --> 00:28:37.660
On YouTube, there's
the Google I/O 2018

00:28:37.660 --> 00:28:40.420
talk, which talks about all the
basics in much greater length.

00:28:40.420 --> 00:28:42.890
Some of those APIs have
changed a little bit,

00:28:42.890 --> 00:28:48.880
but it's still broadly a good
thing to read or to listen to.

00:28:48.880 --> 00:28:53.498
Also, please file your feedback
at our public issue tracker.

00:28:53.498 --> 00:28:54.660
Beta is coming.

00:28:54.660 --> 00:28:56.460
We were told that this morning--

00:28:56.460 --> 00:28:57.550
or last morning as well--

00:28:57.550 --> 00:28:58.330
So we're kind of--

00:28:58.330 --> 00:28:59.170
[LAUGHTER]

00:28:59.170 --> 00:29:01.766
We have to get
back to work, but--

00:29:01.766 --> 00:29:03.220
[LAUGHTER]

00:29:03.720 --> 00:29:05.057
Thanks a lot.

00:29:05.057 --> 00:29:07.140
Please visit all the Jetpack
libraries on the web,

00:29:07.140 --> 00:29:09.730
and we'll be outside for any
questions that you might have.

00:29:09.730 --> 00:29:10.040
Thanks.

00:29:10.040 --> 00:29:11.040
RAHUL RAVIKUMAR: Thanks.

00:29:11.040 --> 00:29:12.490
[MUSIC PLAYING]

