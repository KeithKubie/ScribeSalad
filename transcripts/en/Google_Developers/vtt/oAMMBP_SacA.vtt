WEBVTT
Kind: captions
Language: en

00:00:02.300 --> 00:00:04.501
Levi: Hi, everyone.

00:00:04.501 --> 00:00:06.167
My name is Alon Levi.

00:00:06.167 --> 00:00:08.801
I'm a software engineer
on the Google App Engine team

00:00:08.801 --> 00:00:11.767
and this talk is called
"From Spark Plug to Drive Train:

00:00:11.767 --> 00:00:14.868
Life of an App Engine Request."

00:00:14.868 --> 00:00:16.634
Throughout the course
of this talk,

00:00:16.634 --> 00:00:19.067
you can go and use
Google Moderator,

00:00:19.067 --> 00:00:21.767
which is an application
built on App Engine,

00:00:21.767 --> 00:00:23.868
to submit and vote
on questions,

00:00:23.868 --> 00:00:25.834
which I'll then answer
at the end.

00:00:25.834 --> 00:00:27.000
If you're interested,
go to

00:00:27.000 --> 00:00:31.467
code.google.
com/events/io/questions,

00:00:31.467 --> 00:00:33.601
click on the App Engine track
in the middle,

00:00:33.601 --> 00:00:35.067
and then the title
of this talk

00:00:35.067 --> 00:00:37.400
should be
on the left-hand side.

00:00:37.400 --> 00:00:38.601
Yeah.

00:00:38.601 --> 00:00:40.801
So this talk is called,

00:00:40.801 --> 00:00:42.334
"From spark plug
to drive train,"

00:00:42.334 --> 00:00:43.968
and what I want
to do is take a look

00:00:43.968 --> 00:00:46.267
under the hood of App Engine
with you guys

00:00:46.267 --> 00:00:49.834
and see how App Engine works.

00:00:49.834 --> 00:00:51.701
See how the App Engine
infrastructure works.

00:00:51.701 --> 00:00:54.234
This is not a talk about how to
build App Engine applications.

00:00:54.234 --> 00:00:56.167
There are a number
of other talks

00:00:56.167 --> 00:00:57.167
throughout the course
of the conference

00:00:57.167 --> 00:00:59.033
that are gonna cover that.

00:00:59.033 --> 00:01:01.400
But as a software engineer,
I find that

00:01:01.400 --> 00:01:03.801
when I understand how things
work under the hood,

00:01:03.801 --> 00:01:05.234
it makes me a little more
confident

00:01:05.234 --> 00:01:06.767
and a little more comfortable
working with the system,

00:01:06.767 --> 00:01:09.934
so with that,
I want to get started.

00:01:09.934 --> 00:01:12.501
So the first thing
I want to talk about

00:01:12.501 --> 00:01:15.033
is designing for scale
and reliability.

00:01:15.033 --> 00:01:17.067
Not necessarily
App Engine centric.

00:01:17.067 --> 00:01:20.634
We're just talking about what
makes a web app--

00:01:20.634 --> 00:01:22.834
a web app stack scale.

00:01:22.834 --> 00:01:24.767
And we'll take a look
at the LAMP stack

00:01:24.767 --> 00:01:26.601
and look at some of the
principles there,

00:01:26.601 --> 00:01:29.601
although they apply to other
web infrastructure as well.

00:01:29.601 --> 00:01:31.701
Then I want to take
a look and talk about

00:01:31.701 --> 00:01:34.100
some of the lessons learned
from sort of

00:01:34.100 --> 00:01:36.534
the progression
of that LAMP stack

00:01:36.534 --> 00:01:38.734
and see the lessons
that we applied

00:01:38.734 --> 00:01:40.100
while building App Engine.

00:01:40.100 --> 00:01:41.701
And then we'll take
a look at some of the--

00:01:41.701 --> 00:01:43.334
some different kinds
of requests and how--

00:01:43.334 --> 00:01:46.434
as they pass through
App Engine infrastructure

00:01:46.434 --> 00:01:49.701
and how that affects the way
you design your application

00:01:49.701 --> 00:01:51.868
and the way your application
actually runs.

00:01:51.868 --> 00:01:54.334
Then I'm gonna go back over
the design motivations

00:01:54.334 --> 00:01:55.968
and take a look
at that in more detail.

00:01:55.968 --> 00:01:57.901
And then I'm gonna
go over some numbers

00:01:57.901 --> 00:01:59.300
regarding App Engine.

00:01:59.300 --> 00:02:03.033
So, first off, let's talk
about web stacks.

00:02:03.033 --> 00:02:05.167
So this is a very
high-level overview

00:02:05.167 --> 00:02:07.167
of the Google App Engine stack.

00:02:07.167 --> 00:02:08.801
It's really exciting because
this is something

00:02:08.801 --> 00:02:11.334
we haven't shared
publicly before.

00:02:11.334 --> 00:02:13.200
You can kind of see
that it's a standard,

00:02:13.200 --> 00:02:14.634
three-tiered web topology.

00:02:14.634 --> 00:02:17.968
You've got your front-ends
or routing on the left side.

00:02:17.968 --> 00:02:19.634
Your application layer
down the middle.

00:02:19.634 --> 00:02:21.601
And on the right side,
we've got our persistence layer

00:02:21.601 --> 00:02:24.334
and other APIs.

00:02:24.334 --> 00:02:26.601
To draw to something similar
that you guys may have seen,

00:02:26.601 --> 00:02:29.634
this is a slide from
a talk Brad Fitzpatrick gave

00:02:29.634 --> 00:02:31.534
about LiveJournal in 2007.

00:02:31.534 --> 00:02:33.167
Talking about how they--

00:02:33.167 --> 00:02:35.300
their progression
through the LAMP stack

00:02:35.300 --> 00:02:37.133
and how they
made it work for them.

00:02:37.133 --> 00:02:39.434
So as you can see,
it's sort of similar

00:02:39.434 --> 00:02:41.234
to what we have going on
with App Engine.

00:02:41.234 --> 00:02:43.901
You've got their Perlbal
reverse proxies,

00:02:43.901 --> 00:02:45.934
which are their front-ends
in blue,

00:02:45.934 --> 00:02:48.801
application servers
application layer in green,

00:02:48.801 --> 00:02:51.734
and then APIs
and persistence in red.

00:02:51.734 --> 00:02:54.167
So before we talk more
about App Engine,

00:02:54.167 --> 00:02:56.000
I want to take a step back--
or way back--

00:02:56.000 --> 00:03:01.267
and talk about web
infrastructure in general

00:03:01.267 --> 00:03:03.434
starting with the very
basic LAMP stack.

00:03:03.434 --> 00:03:05.467
So as many of you know,
LAMP stack

00:03:05.467 --> 00:03:10.000
is Linux, Apache, MySQL,
and originally Perl,

00:03:10.000 --> 00:03:12.501
but it could be any
programming language.

00:03:12.501 --> 00:03:13.968
In this, the very basic
LAMP stack,

00:03:13.968 --> 00:03:16.167
you've got one machine running
an Apache web server

00:03:16.167 --> 00:03:19.367
with Perl and a MySQL
database

00:03:19.367 --> 00:03:20.767
all in one machine.

00:03:20.767 --> 00:03:23.000
So when a request comes
in from the network,

00:03:23.000 --> 00:03:26.200
it hits this one box,
Apache serves the web request,

00:03:26.200 --> 00:03:29.467
turns up Perl instance,
which may or may not

00:03:29.467 --> 00:03:31.467
make calls to MySQL
and returns the response.

00:03:31.467 --> 00:03:33.167
This is a great start
and a nice way

00:03:33.167 --> 00:03:34.667
to start building
web applications,

00:03:34.667 --> 00:03:37.100
but it's not very scalable.

00:03:37.100 --> 00:03:38.634
You have a shared machine
for your database

00:03:38.634 --> 00:03:41.601
and your web server
and very soon

00:03:41.601 --> 00:03:44.667
you'll realize
that your databases

00:03:44.667 --> 00:03:46.667
consume the resources
which your web server

00:03:46.667 --> 00:03:49.234
could be using
to serve live traffic.

00:03:49.234 --> 00:03:51.701
Additionally,
this is one single machine.

00:03:51.701 --> 00:03:54.567
If you have to do any upgrades
or if there are any failures,

00:03:54.567 --> 00:03:56.367
you're basically out of luck.

00:03:56.367 --> 00:03:59.367
The next step is
to take your database

00:03:59.367 --> 00:04:00.634
and move it onto
a different machine.

00:04:00.634 --> 00:04:05.200
This frees up some resources
for your web server.

00:04:05.200 --> 00:04:06.467
Pretty much the same.

00:04:06.467 --> 00:04:09.033
It requires a little bit
of management

00:04:09.033 --> 00:04:11.501
and configuration for MySQL,
but not too much.

00:04:11.501 --> 00:04:13.133
It's fairly straightforward.

00:04:13.133 --> 00:04:16.200
And it gives you--

00:04:16.200 --> 00:04:17.834
It frees up part
of your web server

00:04:17.834 --> 00:04:19.067
to serve more traffic.

00:04:19.067 --> 00:04:20.934
So this is sort of
the next progressive step

00:04:20.934 --> 00:04:23.267
in building your applica--
in your web stack.

00:04:23.267 --> 00:04:26.100
So this scales
up to the amount

00:04:26.100 --> 00:04:28.434
that your one Apache server
can handle in web traffic.

00:04:28.434 --> 00:04:31.033
But you've now got two single
points of failure.

00:04:31.033 --> 00:04:33.968
If either your database
or your web server goes down,

00:04:33.968 --> 00:04:35.801
you're not able
to serve traffic.

00:04:35.801 --> 00:04:39.834
So the next step,
which you'll probably run into

00:04:39.834 --> 00:04:41.667
because you have exceeded
the amount of traffic

00:04:41.667 --> 00:04:43.667
that one web app server--
or sorry--

00:04:43.667 --> 00:04:45.701
one web server can handle
is that you'll take

00:04:45.701 --> 00:04:47.801
your web server and split it
onto multiple machines.

00:04:47.801 --> 00:04:49.801
This allows you
to serve more traffic

00:04:49.801 --> 00:04:51.767
than one machine
is able to.

00:04:51.767 --> 00:04:53.234
Obviously you have
to get a little more--

00:04:53.234 --> 00:04:54.567
you have to get
some more machines.

00:04:54.567 --> 00:04:56.868
But additionally, you have
to set up load balancing.

00:04:56.868 --> 00:04:58.267
'Cause you have
to get the requests

00:04:58.267 --> 00:05:01.968
to a different application
or different web servers.

00:05:01.968 --> 00:05:03.667
One way to do this
that many people use

00:05:03.667 --> 00:05:05.834
is what's called
DNS round robin.

00:05:05.834 --> 00:05:08.467
What you do is you register
a list of IPs

00:05:08.467 --> 00:05:09.934
with the domain name server,

00:05:09.934 --> 00:05:11.868
so when your host name
is looked up,

00:05:11.868 --> 00:05:14.501
one of the set
of IPs is returned.

00:05:14.501 --> 00:05:17.267
And the domain name server
routes the request--

00:05:17.267 --> 00:05:19.033
or tells the client
to route the request

00:05:19.033 --> 00:05:21.167
to one of your front-ends.

00:05:21.167 --> 00:05:23.033
This is a sort of statistical
load balancing.

00:05:23.033 --> 00:05:25.334
It's not dependent
on the behavior application.

00:05:25.334 --> 00:05:29.868
It's just spreading requests
evenly across them.

00:05:29.868 --> 00:05:32.067
So one other thing that you do
when you set this up

00:05:32.067 --> 00:05:36.133
is that when you register your
record with DNS,

00:05:36.133 --> 00:05:38.567
you give it a time to live,
or a cache time.

00:05:38.567 --> 00:05:40.601
This is great for DNS,
because it allows

00:05:40.601 --> 00:05:42.200
them to hold on
to your configuration

00:05:42.200 --> 00:05:45.100
for a while before having
to check to see if it's changed.

00:05:45.100 --> 00:05:47.100
But the bad news is that
a lot of name servers

00:05:47.100 --> 00:05:49.067
won't respect
your configuration.

00:05:49.067 --> 00:05:51.167
And what this means
is if your--

00:05:51.167 --> 00:05:52.767
whenever your web server
goes down,

00:05:52.767 --> 00:05:54.801
now you have to wait for DNS
changes to propagate

00:05:54.801 --> 00:05:58.133
and that may take a long time
to reach all the name servers.

00:05:58.133 --> 00:06:00.467
So is it scalable?

00:06:00.467 --> 00:06:01.801
Yeah, it's pretty good.

00:06:01.801 --> 00:06:04.634
You can turn up as many
web servers as necessary

00:06:04.634 --> 00:06:07.033
and as long as your
configuration isn't changing,

00:06:07.033 --> 00:06:09.133
you're good to go.

00:06:09.133 --> 00:06:12.801
But you're still I/O bound
on one database.

00:06:12.801 --> 00:06:15.133
Additionally,
like I said before,

00:06:15.133 --> 00:06:17.868
because of DNS round robin and
how long it takes

00:06:17.868 --> 00:06:20.901
to update your configuration,

00:06:20.901 --> 00:06:22.300
you can't redirect
your traffic quickly

00:06:22.300 --> 00:06:23.968
and of course,
your database is still

00:06:23.968 --> 00:06:26.901
a single point of failure.

00:06:26.901 --> 00:06:31.334
The next step is to add what's
known as a reverse proxy.

00:06:31.334 --> 00:06:32.801
What this will do
is it will take requests

00:06:32.801 --> 00:06:36.567
from the network and then
do routing and load balancing

00:06:36.567 --> 00:06:41.801
inside your network or inside
your application's stack.

00:06:41.801 --> 00:06:43.133
This is a machine
that you control

00:06:43.133 --> 00:06:45.167
that runs in your network.

00:06:45.167 --> 00:06:46.767
It allows you
to do custom routing

00:06:46.767 --> 00:06:50.934
and additionally it allows you
to do specialized back-ends,

00:06:50.934 --> 00:06:53.234
because this reverse proxy
can be aware

00:06:53.234 --> 00:06:55.000
of the configuration
that you're running

00:06:55.000 --> 00:06:57.133
and can route different
requests to different back-ends.

00:06:57.133 --> 00:07:00.033
So here, for example,
we see a request coming in,

00:07:00.033 --> 00:07:02.801
hitting the reverse proxy,
and then based on whether

00:07:02.801 --> 00:07:05.501
it's a request that
requires static content,

00:07:05.501 --> 00:07:08.434
it's routed to the
static content server

00:07:08.434 --> 00:07:09.901
there on the bottom
or it's routed

00:07:09.901 --> 00:07:11.734
back to
the Apache web servers

00:07:11.734 --> 00:07:14.133
for serving other kinds
of content.

00:07:14.133 --> 00:07:15.200
This also allows you
to do

00:07:15.200 --> 00:07:16.968
application-level
load balancing,

00:07:16.968 --> 00:07:20.434
because your reverse proxy--
for example,

00:07:20.434 --> 00:07:22.567
in the LiveJournal site
I showed earlier,

00:07:22.567 --> 00:07:25.200
they were using Perlbal--
can be aware

00:07:25.200 --> 00:07:27.734
of the load characteristics
of your web servers

00:07:27.734 --> 00:07:30.133
and route--do sort of
a least-loaded

00:07:30.133 --> 00:07:35.100
type load balancing policy
instead of round robin.

00:07:35.100 --> 00:07:36.834
Requirements
for setting this up?

00:07:36.834 --> 00:07:38.801
You're gonna need
more machines.

00:07:38.801 --> 00:07:40.801
And you're gonna need
to do some configuration

00:07:40.801 --> 00:07:42.100
and maybe write some
custom routing code

00:07:42.100 --> 00:07:44.367
for your reverse proxy.

00:07:44.367 --> 00:07:46.033
This works really well.

00:07:46.033 --> 00:07:49.033
Perlbal and many other
reverse proxies are very robust.

00:07:49.033 --> 00:07:50.734
They allow you
to do specialization,

00:07:50.734 --> 00:07:53.767
which is great because
specialized back-ends

00:07:53.767 --> 00:07:56.434
are generally more reliable
and since they have to do

00:07:56.434 --> 00:07:59.868
a smaller breadth of work, they
do it a lot more effectively.

00:07:59.868 --> 00:08:01.634
You're still bound
by the routing capacity

00:08:01.634 --> 00:08:03.267
of one reverse proxy.

00:08:03.267 --> 00:08:05.367
You can add more but then
you get into the same issues

00:08:05.367 --> 00:08:07.434
we saw before
with DNS round robin

00:08:07.434 --> 00:08:10.400
and not being able to change
your routing policy quickly.

00:08:10.400 --> 00:08:13.934
You can get around that with
fancy network routing hardware

00:08:13.934 --> 00:08:15.300
like a hardware load balancer.

00:08:15.300 --> 00:08:17.701
But those things
are very expensive

00:08:17.701 --> 00:08:21.634
and out of the reach
of most basic web developers.

00:08:21.634 --> 00:08:24.300
Reliability-wise, you get agile
application-level routing.

00:08:24.300 --> 00:08:26.400
You can move
application servers,

00:08:26.400 --> 00:08:27.601
turn them up,
turn them down,

00:08:27.601 --> 00:08:28.968
move your load around very,
very quickly,

00:08:28.968 --> 00:08:31.767
because you control
the routing infrastructure.

00:08:31.767 --> 00:08:33.767
You get to use
specialized components

00:08:33.767 --> 00:08:36.200
like the static content server
we saw in the previous slide,

00:08:36.200 --> 00:08:40.334
which allows you to have more
robust back-ends.

00:08:40.334 --> 00:08:41.734
And again, we still
haven't addressed

00:08:41.734 --> 00:08:42.868
the issue of the database,
which is still

00:08:42.868 --> 00:08:44.334
a single point of failure.

00:08:44.334 --> 00:08:47.367
So let's talk about that.

00:08:47.367 --> 00:08:50.901
The next step, you would take
your one MySQL database

00:08:50.901 --> 00:08:52.701
running on one machine
and spread it out

00:08:52.701 --> 00:08:55.334
over two multiple machines
into what's known

00:08:55.334 --> 00:08:57.667
as a master-slave
configuration.

00:08:57.667 --> 00:08:59.968
This gets you better
read throughput

00:08:59.968 --> 00:09:01.868
and it's invisible
to your application.

00:09:01.868 --> 00:09:03.167
Rather, you don't have
to change

00:09:03.167 --> 00:09:04.901
the way your
application functions

00:09:04.901 --> 00:09:07.234
or accesses the database
in order to make use of this.

00:09:07.234 --> 00:09:11.567
It's pretty much transparent.

00:09:11.567 --> 00:09:13.267
Requirements, obviously,
you have to get more machines

00:09:13.267 --> 00:09:14.968
and you have
to reconfigure MySQL.

00:09:14.968 --> 00:09:18.634
But in general,
it's pretty straightforward.

00:09:18.634 --> 00:09:20.334
Is it scalable?

00:09:20.334 --> 00:09:22.734
Well, master-slave MySQL
or master-slave 

00:09:22.734 --> 00:09:26.367
for most databases,
a scale with a number of reads--

00:09:26.367 --> 00:09:27.634
Sorry.

00:09:27.634 --> 00:09:29.067
Scales the read rate
with the number of servers,

00:09:29.067 --> 00:09:30.367
but not the right rate.

00:09:30.367 --> 00:09:32.067
So here we can see--

00:09:32.067 --> 00:09:33.934
Uh, oops.

00:09:33.934 --> 00:09:37.133
This is...weird.

00:09:37.133 --> 00:09:38.834
Okay, well,
I'm missing a slide.

00:09:38.834 --> 00:09:44.334
But if, for example,
you had 400 reads per second--

00:09:44.334 --> 00:09:46.300
400 writes per sec--
or, sorry.

00:09:46.300 --> 00:09:48.701
If you had 200 writes per second
and 500 reads per second

00:09:48.701 --> 00:09:50.033
on one machine
and you spread it over

00:09:50.033 --> 00:09:52.467
to a master-slave MySQL,

00:09:52.467 --> 00:09:54.701
your reads will be able
to hit any of the back-ends,

00:09:54.701 --> 00:09:57.100
so you can spread them across
different machines,

00:09:57.100 --> 00:09:59.100
but your writes
will hit the--

00:09:59.100 --> 00:10:00.467
They all have to go
through the master

00:10:00.467 --> 00:10:01.834
and then
be replicated through

00:10:01.834 --> 00:10:03.167
to the other database servers.

00:10:03.167 --> 00:10:06.734
So this is great, um...

00:10:06.734 --> 00:10:10.734
for scaling up your reads,
but as your application

00:10:10.734 --> 00:10:13.367
gets bigger and the net
throughput of writes

00:10:13.367 --> 00:10:15.534
that you're doing also
increases proportionately,

00:10:15.534 --> 00:10:19.000
you're going to soon exceed
the capacity

00:10:19.000 --> 00:10:20.634
of one database server.

00:10:20.634 --> 00:10:22.400
And at that point,
you're sort of out of luck

00:10:22.400 --> 00:10:26.067
and you'll have to move
to a different configuration.

00:10:26.067 --> 00:10:28.601
Regarding reliability,
the master is a single point

00:10:28.601 --> 00:10:30.000
of failure for writes.

00:10:30.000 --> 00:10:31.734
If it goes down,
you're no longer able

00:10:31.734 --> 00:10:33.934
to write to your database.

00:10:33.934 --> 00:10:37.033
And additionally, the master
may die before replication.

00:10:37.033 --> 00:10:39.601
So as I said,
when you issue a write

00:10:39.601 --> 00:10:43.634
to your database,
it hits the master server first

00:10:43.634 --> 00:10:46.267
and then is replicated out
to the slaves.

00:10:46.267 --> 00:10:48.567
If the master goes down
after writing

00:10:48.567 --> 00:10:50.067
and before replication,
you may lose

00:10:50.067 --> 00:10:52.801
a small window of data,
which is unfortunate.

00:10:52.801 --> 00:10:55.467
The next step in scaling up
your database

00:10:55.467 --> 00:10:57.501
is to use what's called
a partitioned database.

00:10:57.501 --> 00:11:00.934
Effectively what this is
is you take your

00:11:00.934 --> 00:11:04.067
master-slave MySQL database
or master-master

00:11:04.067 --> 00:11:07.300
or any variety of configurations
and split it up

00:11:07.300 --> 00:11:11.467
into different
database clusters.

00:11:11.467 --> 00:11:14.234
This is done by a variety
of different

00:11:14.234 --> 00:11:15.501
enterprise-level databases.

00:11:15.501 --> 00:11:16.968
This is the way
that BigTable

00:11:16.968 --> 00:11:18.501
and the App Engine
datastore work.

00:11:18.501 --> 00:11:22.267
And additionally Oracle
clustered and db2 federated

00:11:22.267 --> 00:11:24.167
work this way.

00:11:24.167 --> 00:11:26.234
It gives you an increase
in both read

00:11:26.234 --> 00:11:29.067
and write throughput,
which is great.

00:11:29.067 --> 00:11:32.300
But the downside is that
it's a lot of work.

00:11:32.300 --> 00:11:33.934
You need a lot more machines.

00:11:33.934 --> 00:11:36.033
It requires a lot more
management, obviously.

00:11:36.033 --> 00:11:37.467
But more importantly,
you're going to have

00:11:37.467 --> 00:11:40.701
to re-architect your data model
to be partitioned.

00:11:40.701 --> 00:11:42.767
The inherent assumptions
that you have

00:11:42.767 --> 00:11:44.901
that all the data
is stored on one machine

00:11:44.901 --> 00:11:46.767
or locally in one cluster
and you can do things

00:11:46.767 --> 00:11:49.534
like joins
or in-memory operations,

00:11:49.534 --> 00:11:51.267
that doesn't exist anymore.

00:11:51.267 --> 00:11:52.667
So you may have
to rewrite your queries

00:11:52.667 --> 00:11:55.434
in order to take advantage
of this.

00:11:55.434 --> 00:11:59.901
So this brings us back
to the App Engine stack.

00:11:59.901 --> 00:12:03.434
So again, we have the front-ends
on the left side.

00:12:03.434 --> 00:12:05.968
They're basically App Engine's
reverse proxies.

00:12:05.968 --> 00:12:09.334
They do application-level
routing and load balancing.

00:12:09.334 --> 00:12:10.868
In the middle,
we have our app servers

00:12:10.868 --> 00:12:13.767
and our static file
serving infrastructure,

00:12:13.767 --> 00:12:16.868
which are responsible for
serving those respective parts

00:12:16.868 --> 00:12:18.400
of an application.

00:12:18.400 --> 00:12:20.067
And on the right side,
we have our datastore

00:12:20.067 --> 00:12:22.901
built on BigTable,
memcache,

00:12:22.901 --> 00:12:25.033
which is something many
of you may be familiar with.

00:12:25.033 --> 00:12:26.934
And on the bottom we have
some other APIs

00:12:26.934 --> 00:12:29.534
that your application
may make use of.

00:12:29.534 --> 00:12:31.334
So now I want to talk about--

00:12:31.334 --> 00:12:35.334
Given the progression of
infrastructure we saw before

00:12:35.334 --> 00:12:36.767
to scale up a LAMP stack,

00:12:36.767 --> 00:12:39.367
I want to talk about some
of the motivations

00:12:39.367 --> 00:12:42.434
and design decisions that we
took into consideration

00:12:42.434 --> 00:12:44.501
when designing App Engine.

00:12:44.501 --> 00:12:47.701
The first was to build on
existing Google technology.

00:12:47.701 --> 00:12:50.167
We didn't want to
re-invent any wheels

00:12:50.167 --> 00:12:53.801
and Google spent
a lot of time building

00:12:53.801 --> 00:12:56.767
and designing scalable
web infrastructure

00:12:56.767 --> 00:13:00.234
and applications and we
wanted to use that experience

00:13:00.234 --> 00:13:02.567
and use that infrastructure
and make it available

00:13:02.567 --> 00:13:04.234
to all developers.

00:13:04.234 --> 00:13:05.701
Additionally, we wanted
to provide

00:13:05.701 --> 00:13:06.868
an integrated environment.

00:13:06.868 --> 00:13:08.968
We wanted you
to be able to manage

00:13:08.968 --> 00:13:12.367
the entirety of your
application in one place.

00:13:12.367 --> 00:13:14.934
We wanted to encourage small
per-request footprints

00:13:14.934 --> 00:13:17.067
and additionally,
fast requests,

00:13:17.067 --> 00:13:21.534
so that we have high turnover
of requests

00:13:21.534 --> 00:13:22.968
and not have to keep
too much stuff memory.

00:13:22.968 --> 00:13:25.834
That allows us to do
the serving of applications

00:13:25.834 --> 00:13:27.434
without using virtualization.

00:13:27.434 --> 00:13:31.868
It's all on what's more similar
to a standard web server

00:13:31.868 --> 00:13:34.968
than a giant,
clustered virtualization

00:13:34.968 --> 00:13:37.467
or a pool of virtual instances.

00:13:37.467 --> 00:13:39.801
We wanted to maintain isolation
between applications

00:13:39.801 --> 00:13:42.267
and between applications
and Google.

00:13:42.267 --> 00:13:45.367
So you can be assured that your
application is safe

00:13:45.367 --> 00:13:47.567
from other applications,
both security-wise

00:13:47.567 --> 00:13:49.801
and performance
characteristics.

00:13:49.801 --> 00:13:52.801
If another application is
burning tons of CPU

00:13:52.801 --> 00:13:54.701
or doing things like that,
it won't affect the way

00:13:54.701 --> 00:13:57.133
that your application
performs.

00:13:57.133 --> 00:13:59.334
We wanted to encourage you
to write applications

00:13:59.334 --> 00:14:02.100
with statelessness and
specialization in mind.

00:14:02.100 --> 00:14:05.400
Like I said before,
using specialized back-ends

00:14:05.400 --> 00:14:09.234
gives you huge advantages
and having stateless requests

00:14:09.234 --> 00:14:12.534
means that we can do
load balancing

00:14:12.534 --> 00:14:16.434
and application routing
on a much more efficient scale.

00:14:16.434 --> 00:14:17.601
Additionally,
you want to require

00:14:17.601 --> 00:14:19.133
a partitioned data model.

00:14:19.133 --> 00:14:23.133
I spoke before earlier about
how it's a very difficult step

00:14:23.133 --> 00:14:26.267
to go from the sort of
regular database

00:14:26.267 --> 00:14:28.567
or master-slave
or master-master MySQL

00:14:28.567 --> 00:14:31.067
to a partitioned paradigm.

00:14:31.067 --> 00:14:34.267
So we sort of make you write
for the App Engine datastore

00:14:34.267 --> 00:14:36.200
from the beginning
and in that way,

00:14:36.200 --> 00:14:37.667
you don't have
to re-architecture your data

00:14:37.667 --> 00:14:39.000
when you get to that stage.

00:14:39.000 --> 00:14:42.133
So now let's look
at the life of some requests

00:14:42.133 --> 00:14:44.734
and see how they interact
with the different parts

00:14:44.734 --> 00:14:48.234
of App Engine
and what goes on there.

00:14:48.234 --> 00:14:51.067
So requests for static content.

00:14:51.067 --> 00:14:53.467
The first thing that happens
in a request for static content

00:14:53.467 --> 00:14:55.267
or any request
is that it's routed

00:14:55.267 --> 00:14:56.834
to the nearest Google
datacenter

00:14:56.834 --> 00:14:58.701
over the internet
and from there,

00:14:58.701 --> 00:15:00.267
travels over Google's
network

00:15:00.267 --> 00:15:02.601
to reach our
App Engine front-ends.

00:15:02.601 --> 00:15:04.234
This is a huge advantage.

00:15:04.234 --> 00:15:06.534
Basically, your application
is running

00:15:06.534 --> 00:15:09.601
on the same network
and gets the same advantages

00:15:09.601 --> 00:15:12.300
as all the other Google products
such as web search,

00:15:12.300 --> 00:15:14.067
Gmail, and everything else.

00:15:14.067 --> 00:15:16.901
You may notice decreased
latencies for this reason 

00:15:16.901 --> 00:15:19.868
and other
good characteristics.

00:15:19.868 --> 00:15:21.501
Basically, you get lots
of advantages

00:15:21.501 --> 00:15:24.000
just by being on this network.

00:15:24.000 --> 00:15:25.834
The next thing that happens
once your request

00:15:25.834 --> 00:15:27.701
reaches the
App Engine front-end,

00:15:27.701 --> 00:15:31.067
is the front-end does
load balancing and routing.

00:15:31.067 --> 00:15:34.834
In this case, since it's
a request for static content,

00:15:34.834 --> 00:15:36.234
that request
will get routed

00:15:36.234 --> 00:15:39.734
to the static content
back-ends.

00:15:39.734 --> 00:15:42.701
And so this is a specialized
piece of infrastructure

00:15:42.701 --> 00:15:45.567
that is wholly designed
to serve static content 

00:15:45.567 --> 00:15:47.601
and do it very effectively
and very efficiently.

00:15:47.601 --> 00:15:51.067
And more importantly,
as you can see in this diagram,

00:15:51.067 --> 00:15:53.467
your request has not touched
the App servers

00:15:53.467 --> 00:15:55.367
or the other parts
of your application that can

00:15:55.367 --> 00:15:58.501
be serving other
traffic independently.

00:15:58.501 --> 00:16:00.901
So static content
servers built

00:16:00.901 --> 00:16:02.100
on shared Google
infrastructure.

00:16:02.100 --> 00:16:04.501
This is a entire service
inside Google,

00:16:04.501 --> 00:16:06.834
of which App Engine
is not the only customer

00:16:06.834 --> 00:16:09.567
and you can be assured
that it's very reliable,

00:16:09.567 --> 00:16:13.367
very robust,
very large-scaled system.

00:16:13.367 --> 00:16:16.367
This also means since
your request did not hit

00:16:16.367 --> 00:16:18.934
your application servers
or any of the other

00:16:18.934 --> 00:16:24.000
components that I talked
about earlier...

00:16:24.000 --> 00:16:26.801
the files that are
on the static content serving

00:16:26.801 --> 00:16:30.367
are actually physically
separate from the other files

00:16:30.367 --> 00:16:32.367
that you deploy
with your application.

00:16:32.367 --> 00:16:35.067
What this means and something
that some people observe

00:16:35.067 --> 00:16:37.133
when using App Engine
is that when they deploy

00:16:37.133 --> 00:16:39.334
their application
and then try to access files

00:16:39.334 --> 00:16:41.767
which they've marked "static,"
they're unable to do so

00:16:41.767 --> 00:16:43.434
on our App servers
because those files

00:16:43.434 --> 00:16:45.701
are not actually
deployed to them.

00:16:45.701 --> 00:16:49.667
So that begs the question,
"Which content is static?"

00:16:49.667 --> 00:16:52.734
Well, you tell us
in your configuration

00:16:52.734 --> 00:16:55.467
which you upload along
with your application.

00:16:55.467 --> 00:16:57.434
For Java or
for the Java Runtime,

00:16:57.434 --> 00:17:02.300
the appengine-web.xml file,
anything inside those static

00:17:02.300 --> 00:17:07.133
XML tags is uploaded
to our static content servers.

00:17:07.133 --> 00:17:09.033
And in App Engine--sorry.

00:17:09.033 --> 00:17:12.234
In Python's app.yaml,
anything marked

00:17:12.234 --> 00:17:13.801
"static directory"
or "static files"

00:17:13.801 --> 00:17:15.534
matching those
regular expressions

00:17:15.534 --> 00:17:18.133
will be served off
static content serving.

00:17:18.133 --> 00:17:21.534
So afterwards,
the responses return

00:17:21.534 --> 00:17:23.367
from the static content server
to the front-end

00:17:23.367 --> 00:17:24.734
and then back out
to the user.

00:17:24.734 --> 00:17:26.467
Again, we haven't touched any
of the other

00:17:26.467 --> 00:17:27.901
infrastructure here,
which is really great

00:17:27.901 --> 00:17:29.300
for scalability.

00:17:29.300 --> 00:17:31.033
So the next request
I want to talk about

00:17:31.033 --> 00:17:34.567
is a request
for dynamic content.

00:17:34.567 --> 00:17:36.567
So to do that,
I need to talk about

00:17:36.567 --> 00:17:39.634
a few different components that
I haven't brought up before.

00:17:39.634 --> 00:17:42.100
One of which
is the App Engine App server

00:17:42.100 --> 00:17:44.167
and the App Engine App master.

00:17:44.167 --> 00:17:47.701
So the App server
is basically our web server.

00:17:47.701 --> 00:17:50.934
It's job is to serve
dynamic requests.

00:17:50.934 --> 00:17:53.868
When you do computation
or do API calls

00:17:53.868 --> 00:17:55.467
or do anything
in your application

00:17:55.467 --> 00:17:57.834
outside of the scope
of a static request,

00:17:57.834 --> 00:17:59.901
it ends up at the App server
and the App server

00:17:59.901 --> 00:18:02.300
is responsible
for managing those requests.

00:18:02.300 --> 00:18:04.400
The App master
is another piece

00:18:04.400 --> 00:18:06.467
which is a little bit different
from what we saw before

00:18:06.467 --> 00:18:09.934
in the standard scaled-up
version of the LAMP stack.

00:18:09.934 --> 00:18:13.567
Its job is to manage and
schedule applications

00:18:13.567 --> 00:18:15.033
on App servers.

00:18:15.033 --> 00:18:18.267
Additionally, it informs
the front-ends of where those--

00:18:18.267 --> 00:18:19.868
what applications
are scheduled

00:18:19.868 --> 00:18:22.367
on which app server
so they can be routed.

00:18:22.367 --> 00:18:25.133
So requests can be routed.

00:18:25.133 --> 00:18:27.834
So a little more detail
on the app server.

00:18:27.834 --> 00:18:31.267
App servers serve
many applications--

00:18:31.267 --> 00:18:32.901
many, many applications--

00:18:32.901 --> 00:18:35.868
and they also serve
many concurrent requests.

00:18:35.868 --> 00:18:38.501
So harking back
to what I said about

00:18:38.501 --> 00:18:39.968
some of our
design motivations,

00:18:39.968 --> 00:18:42.434
smaller app footprints
in terms of memory and CPU,

00:18:42.434 --> 00:18:44.300
plus faster requests,
allows us to serve

00:18:44.300 --> 00:18:46.067
more applications
more effectively

00:18:46.067 --> 00:18:49.167
and make better use
of resources.

00:18:49.167 --> 00:18:50.934
The app server
is also responsible

00:18:50.934 --> 00:18:53.501
for enforcing isolation
between applications

00:18:53.501 --> 00:18:55.534
and between applications
and Google.

00:18:55.534 --> 00:18:58.834
This keeps apps safe
from each other

00:18:58.834 --> 00:19:03.934
and additionally,
it keeps us safe from apps.

00:19:03.934 --> 00:19:05.801
So it also enforces
statelessness,

00:19:05.801 --> 00:19:10.601
which is really important
because since we don't know

00:19:10.601 --> 00:19:12.567
what your application
is doing or what state

00:19:12.567 --> 00:19:15.968
it needs to maintain,
if an app server goes down

00:19:15.968 --> 00:19:17.100
or if there's some
other issue and we need

00:19:17.100 --> 00:19:19.834
to reroute requests
for traffic,

00:19:19.834 --> 00:19:21.868
we don't have
to transfer any state.

00:19:21.868 --> 00:19:24.467
You use your APIs
to maintain state

00:19:24.467 --> 00:19:25.934
and they're stored
on a different

00:19:25.934 --> 00:19:27.968
piece of
infrastructure entirely

00:19:27.968 --> 00:19:31.033
so applications
can be rescheduled

00:19:31.033 --> 00:19:33.834
or traffic can be rerouted
across app servers

00:19:33.834 --> 00:19:36.400
without having to worry
about moving state around.

00:19:36.400 --> 00:19:39.434
And then of course,
the app servers

00:19:39.434 --> 00:19:43.901
also service API requests
for your application.

00:19:43.901 --> 00:19:47.300
So the first step in routing
a dynamic content request

00:19:47.300 --> 00:19:49.167
is at the front-end.

00:19:49.167 --> 00:19:51.000
Any requests that don't match
static requests

00:19:51.000 --> 00:19:53.067
and match one of the other
regular expressions

00:19:53.067 --> 00:19:56.334
in your configuration,
get routed to the app servers.

00:19:56.334 --> 00:19:59.133
The app server checks to see if
there's a runtime in the cache

00:19:59.133 --> 00:20:01.033
and I'll talk about it
a little more in a second.

00:20:01.033 --> 00:20:02.968
If that exists, it uses it.

00:20:02.968 --> 00:20:06.634
Otherwise, it turns up on your
runtime for your application.

00:20:06.634 --> 00:20:09.067
Executes the request
and then holds on

00:20:09.067 --> 00:20:10.601
to that runtime in memory.

00:20:10.601 --> 00:20:13.234
This is a really important
part of App Engine,

00:20:13.234 --> 00:20:16.801
because it means two things.

00:20:16.801 --> 00:20:21.234
First of all, your first request
to an App Engine app server

00:20:21.234 --> 00:20:23.100
may be slow.

00:20:23.100 --> 00:20:24.934
We may have to do
a little more overhead

00:20:24.934 --> 00:20:27.934
to get your application
up and running the first time.

00:20:27.934 --> 00:20:30.701
But then subsequent requests are
likely to hit that cache.

00:20:30.701 --> 00:20:32.801
The front-ends are designed
to maximize

00:20:32.801 --> 00:20:35.501
this sort of caching.

00:20:35.501 --> 00:20:38.133
But the second and more
important benefit for you all

00:20:38.133 --> 00:20:40.734
is that because this request--

00:20:40.734 --> 00:20:42.634
because the runtime
hangs around in memory,

00:20:42.634 --> 00:20:45.601
you're able to use
that memory across requests.

00:20:45.601 --> 00:20:47.267
There are no guarantees
it will still be there.

00:20:47.267 --> 00:20:49.534
The cache may be evicted
at any time.

00:20:49.534 --> 00:20:52.734
But you can optimistically
cache either

00:20:52.734 --> 00:20:54.667
things that are
expensive to initialize

00:20:54.667 --> 00:20:57.868
or compute or import
or anything like that

00:20:57.868 --> 00:21:00.234
in your runtime
and it may be there

00:21:00.234 --> 00:21:04.901
when your next request comes in,
which is really nice.

00:21:04.901 --> 00:21:08.868
So the next type of request
is a request accessing an API.

00:21:08.868 --> 00:21:12.167
This is inside the scope
of a dynamic request,

00:21:12.167 --> 00:21:17.400
but if your request decides
to make an API call,

00:21:17.400 --> 00:21:20.033
it requests permission
from the app server

00:21:20.033 --> 00:21:22.868
and then the app server
will block the runtime

00:21:22.868 --> 00:21:25.267
of your request,
issue the API call,

00:21:25.267 --> 00:21:29.400
and then wake up the runtime
again with the response.

00:21:29.400 --> 00:21:31.167
This is really cool because
it means you don't

00:21:31.167 --> 00:21:34.167
have to manage concurrency
and threading on your own.

00:21:34.167 --> 00:21:36.234
It's managed in
the app server for your app.

00:21:36.234 --> 00:21:38.534
And because your application
is stateless,

00:21:38.534 --> 00:21:40.767
we don't have worry
too much about

00:21:40.767 --> 00:21:43.167
what your application needs
when it wakes up.

00:21:43.167 --> 00:21:47.067
We just hand back the response
and you're good to go.

00:21:47.067 --> 00:21:49.501
You're, uh--

00:21:49.501 --> 00:21:51.567
You can use APIs
to do things

00:21:51.567 --> 00:21:54.901
that you wouldn't normally
want to either do

00:21:54.901 --> 00:21:57.667
in the app server because
you have limited resources

00:21:57.667 --> 00:22:01.000
or because you don't want
to rewrite them for yourself.

00:22:01.000 --> 00:22:03.501
We have a lot of APIs that do
a lot of specialized tasks

00:22:03.501 --> 00:22:05.367
and now I want
to go through and--

00:22:05.367 --> 00:22:07.701
Well, here's a few of them.

00:22:07.701 --> 00:22:11.501
So memcache and the datastore we
have talked about a lot.

00:22:11.501 --> 00:22:16.234
URLfetch is our API for fetching
our content from the web.

00:22:16.234 --> 00:22:18.200
There's the mail API.

00:22:18.200 --> 00:22:20.501
And then two new ones
that we haven't

00:22:20.501 --> 00:22:22.901
really talked about before are
the XMPP API,

00:22:22.901 --> 00:22:24.200
which is on our road map.

00:22:24.200 --> 00:22:26.067
Kevin talked
about it this morning.

00:22:26.067 --> 00:22:28.234
And then the task queue API,

00:22:28.234 --> 00:22:30.100
which is for
offline computation,

00:22:30.100 --> 00:22:32.567
which is something we're
really excited about

00:22:32.567 --> 00:22:34.767
and there's a talk later
in the conference

00:22:34.767 --> 00:22:37.868
about a look ahead
at offline processing

00:22:37.868 --> 00:22:40.367
for App Engine, which
I encourage you all to go to.

00:22:40.367 --> 00:22:43.868
Additionally,
we have images and users.

00:22:43.868 --> 00:22:47.367
So first API I want
to talk about is memcache

00:22:47.367 --> 00:22:51.100
or our flavor of memcache,
memcacheg.

00:22:51.100 --> 00:22:53.968
So memcache is a distributed
in-memory cache

00:22:53.968 --> 00:22:58.000
that's used across
the industry fairly heavily.

00:22:58.000 --> 00:23:00.067
Many of you work
with LAMP stacks

00:23:00.067 --> 00:23:02.167
and things like that
may be familiar with it.

00:23:02.167 --> 00:23:04.901
The more common variant
of memcache

00:23:04.901 --> 00:23:07.400
is called memcached
and it was written

00:23:07.400 --> 00:23:10.767
for LiveJournal by Brad
and the folks there

00:23:10.767 --> 00:23:15.734
to get better performance out
of their in-memory cache.

00:23:15.734 --> 00:23:18.367
So memcacheg,
which is the version we use,

00:23:18.367 --> 00:23:22.000
was also written
by Brad and adds a couple

00:23:22.000 --> 00:23:24.434
of extra API calls that you may
not find in memcached,

00:23:24.434 --> 00:23:26.968
which are batch API calls,
such as

00:23:26.968 --> 00:23:28.968
set_multi, get_multi,
and add_multi,

00:23:28.968 --> 00:23:30.934
which allow you
to incur the overhead

00:23:30.934 --> 00:23:33.501
of doing RPC less often.

00:23:33.501 --> 00:23:38.234
Basically, you can use memcache
to optimistically cache

00:23:38.234 --> 00:23:42.701
data in-memory on a set
of sharded servers

00:23:42.701 --> 00:23:45.334
for optimization.

00:23:45.334 --> 00:23:47.300
Things you might want
to cache in memcache are

00:23:47.300 --> 00:23:49.868
the results
of database queries,

00:23:49.868 --> 00:23:51.767
the results
of an expensive call

00:23:51.767 --> 00:23:53.501
to fetch something
from the internet,

00:23:53.501 --> 00:23:55.634
or something that just requires
a lot of computation

00:23:55.634 --> 00:23:56.734
on your application.

00:23:56.734 --> 00:23:57.901
You may want to hold
on to it

00:23:57.901 --> 00:24:00.534
and not have to do it
on every request.

00:24:00.534 --> 00:24:03.200
Memcache is a very
specialized back-end.

00:24:03.200 --> 00:24:05.467
It's just an in-memory cache.

00:24:05.467 --> 00:24:07.234
And that means
that it can be---

00:24:07.234 --> 00:24:09.934
It's very stable
and very robust.

00:24:09.934 --> 00:24:11.367
Things in memcache
may hang around longer

00:24:11.367 --> 00:24:13.501
than you would
necessarily expect.

00:24:13.501 --> 00:24:15.767
BigTable is the next--

00:24:15.767 --> 00:24:17.968
Or rather the App Engine
datastore which is built

00:24:17.968 --> 00:24:20.400
on BigTable is the next API
I want to talk about.

00:24:20.400 --> 00:24:22.801
And it's our API for doing
persistent storage.

00:24:22.801 --> 00:24:26.100
Like I said,
we don't want you to--

00:24:26.100 --> 00:24:27.934
We want to maintain
stateless requests

00:24:27.934 --> 00:24:30.133
and stateless applications
at the app server,

00:24:30.133 --> 00:24:32.467
so you need somewhere to put
your persistent state

00:24:32.467 --> 00:24:33.801
where you'll be sure
it'll be there

00:24:33.801 --> 00:24:35.400
when your next request
comes in.

00:24:35.400 --> 00:24:38.634
And for us, that's
the App Engine datastore.

00:24:38.634 --> 00:24:41.968
I spoke a little bit before
about partitioned datastores

00:24:41.968 --> 00:24:44.334
and the advantages
that those give you

00:24:44.334 --> 00:24:47.601
with regard to read
and write throughput.

00:24:47.601 --> 00:24:49.634
We don't want to make
you jump through the hoops

00:24:49.634 --> 00:24:51.834
of partitioning your data
once your application

00:24:51.834 --> 00:24:53.167
gets to a certain scale.

00:24:53.167 --> 00:24:57.067
So--and because we wanted
to use BigTable,

00:24:57.067 --> 00:25:00.200
we make you design
for this type

00:25:00.200 --> 00:25:02.734
of database
from the beginning.

00:25:02.734 --> 00:25:05.734
You can use entity groups
in your application

00:25:05.734 --> 00:25:08.467
to control your partitions.

00:25:08.467 --> 00:25:11.200
You may also have to define
explicit indexes

00:25:11.200 --> 00:25:16.601
for your datastore entities
so that reads are instantaneous.

00:25:16.601 --> 00:25:19.267
We don't want to do a lot
of computation on reads,

00:25:19.267 --> 00:25:22.100
so everything has to be a quick
read from the database

00:25:22.100 --> 00:25:26.100
with no complicated
in-memory calculation.

00:25:26.100 --> 00:25:28.601
Additionally, we have
to update those indexes

00:25:28.601 --> 00:25:32.400
when a request--
when a write comes through.

00:25:32.400 --> 00:25:36.100
So you might see that writes
will be a bit slower.

00:25:36.100 --> 00:25:37.501
Because we're built
on BigTable,

00:25:37.501 --> 00:25:39.167
you get a high degree
of replication

00:25:39.167 --> 00:25:40.734
and fault tolerance.

00:25:40.734 --> 00:25:42.601
As soon as your--

00:25:42.601 --> 00:25:46.300
As soon as your mutation
on your datastore--

00:25:46.300 --> 00:25:47.901
your datastore
mutation commits,

00:25:47.901 --> 00:25:51.467
you're guaranteed by the time
that API call returns

00:25:51.467 --> 00:25:54.100
your data's been replicated
to at least three machines.

00:25:54.100 --> 00:25:56.133
And this is without you having
to do any extra work.

00:25:56.133 --> 00:25:59.467
The reason for this is that the
datastore is built on BigTable

00:25:59.467 --> 00:26:01.834
and BigTable's built on GFS.

00:26:01.834 --> 00:26:04.968
Both BigTable and GFS
have white papers

00:26:04.968 --> 00:26:07.634
on research.google.com,
which you are more

00:26:07.634 --> 00:26:10.501
than welcome to check out,
which explain exactly

00:26:10.501 --> 00:26:12.701
the mechanics
of how all of this work.

00:26:12.701 --> 00:26:14.567
But that's a topic itself.

00:26:14.567 --> 00:26:18.901
And then the other bonus
you get from using the datastore

00:26:18.901 --> 00:26:21.334
is that you get to keep
globally unique I.D.s

00:26:21.334 --> 00:26:23.300
across partitions.

00:26:23.300 --> 00:26:26.601
Each of your entities
is uniquely identified.

00:26:26.601 --> 00:26:28.734
And you don't have to do any
work to set this up.

00:26:28.734 --> 00:26:30.501
This is something
that you could do

00:26:30.501 --> 00:26:32.300
with a regular
partition database,

00:26:32.300 --> 00:26:35.334
but it requires some more work
to set up the servers

00:26:35.334 --> 00:26:39.968
and to set up a back-end
to assign these unique I.D.s,

00:26:39.968 --> 00:26:41.801
which is already
built in for you

00:26:41.801 --> 00:26:43.734
with the App Engine datastore.

00:26:43.734 --> 00:26:46.601
Some other APIs
that I want to talk about

00:26:46.601 --> 00:26:49.300
are the mail API,
which uses the same

00:26:49.300 --> 00:26:52.834
routing infrastructure
as Gmail,

00:26:52.834 --> 00:26:54.634
the user's API,
which gives you seamless

00:26:54.634 --> 00:26:56.267
accounts integration.

00:26:56.267 --> 00:26:58.701
Images API,
which does image manipulation

00:26:58.701 --> 00:27:02.534
and resizing,
is used by Picasaweb

00:27:02.534 --> 00:27:04.934
to do some of their image
manipulation and resizing.

00:27:04.934 --> 00:27:08.234
URLfetch, which fetches
content from the web,

00:27:08.234 --> 00:27:09.868
it's used by the Gadget API.

00:27:09.868 --> 00:27:12.901
And then the task queue
and XMPP.

00:27:12.901 --> 00:27:17.200
XMPP is gonna use the same XMPP
server as Google Talk.

00:27:17.200 --> 00:27:20.334
So the really,
really important thing to--

00:27:20.334 --> 00:27:22.367
The really important takeaway
from all of this

00:27:22.367 --> 00:27:26.300
is that the majority of these
APIs are backed by servers.

00:27:26.300 --> 00:27:29.167
They're used across Google
by products

00:27:29.167 --> 00:27:30.968
much, much bigger
than App Engine.

00:27:30.968 --> 00:27:33.868
So there are entire teams
devoted to maintaining

00:27:33.868 --> 00:27:37.367
and supporting and upgrading
these services.

00:27:37.367 --> 00:27:39.033
And you get all
these advantages

00:27:39.033 --> 00:27:41.701
just by using App Engine
and making simple API calls.

00:27:41.701 --> 00:27:43.000
You don't have to go through
the overhead

00:27:43.000 --> 00:27:45.567
of writing the code
or figuring out

00:27:45.567 --> 00:27:47.501
the corner cases
and things like that

00:27:47.501 --> 00:27:49.300
for your application.

00:27:49.300 --> 00:27:51.100
So with that,
I want to talk about--

00:27:51.100 --> 00:27:53.234
I want to go back
to the design motivations

00:27:53.234 --> 00:27:57.200
I spoke about before and discuss
in a little more detail,

00:27:57.200 --> 00:27:59.534
now that we've taken a look
at the infrastructure,

00:27:59.534 --> 00:28:02.667
how your application
is affected by them,

00:28:02.667 --> 00:28:04.534
why we made
those decisions,

00:28:04.534 --> 00:28:08.367
and what it means for you
as an app developer.

00:28:08.367 --> 00:28:11.467
So our first design motivation
was to build

00:28:11.467 --> 00:28:13.000
on existing Google technology.

00:28:13.000 --> 00:28:14.701
Google spends--

00:28:14.701 --> 00:28:17.133
Google spent years
and lots of time

00:28:17.133 --> 00:28:20.534
and lots of money working
on our infrastructure,

00:28:20.534 --> 00:28:22.901
building our data centers,
and also learning

00:28:22.901 --> 00:28:27.434
how to make web apps scale
and infrastructure reliable.

00:28:27.434 --> 00:28:30.667
We wanted to make use of all
of this in our APIs

00:28:30.667 --> 00:28:33.067
and with App Engine
serving stack in general

00:28:33.067 --> 00:28:36.100
to give you all
those benefits.

00:28:36.100 --> 00:28:39.133
You don't have to know what's
happening behind the scenes

00:28:39.133 --> 00:28:40.601
with regards to all
of the scaling.

00:28:40.601 --> 00:28:42.667
It just works.

00:28:42.667 --> 00:28:45.534
And so, related to that,
we wanted to provide

00:28:45.534 --> 00:28:47.467
an integrated environment so
that it would truly

00:28:47.467 --> 00:28:50.200
be simple to develop
on App Engine.

00:28:50.200 --> 00:28:52.067
For us, our motivation
was based on

00:28:52.067 --> 00:28:54.167
managing all
applications together.

00:28:54.167 --> 00:28:56.200
We wanted to provide
one service

00:28:56.200 --> 00:29:00.167
and let you control
how your application is--

00:29:00.167 --> 00:29:02.234
Or give you a platform
by which you can control

00:29:02.234 --> 00:29:05.501
how you application is served
and how your application runs.

00:29:05.501 --> 00:29:06.767
What it means for you
is that you may

00:29:06.767 --> 00:29:08.634
have to follow some
of our best practices.

00:29:08.634 --> 00:29:10.501
Because you're working
in an integrated environment,

00:29:10.501 --> 00:29:13.133
things may be different
than what you may expect

00:29:13.133 --> 00:29:16.567
on one box running
a LAMP stack.

00:29:16.567 --> 00:29:17.968
You may encounter
some restrictions

00:29:17.968 --> 00:29:21.234
because
of the specialization

00:29:21.234 --> 00:29:24.434
and isolation that
I talked about earlier.

00:29:24.434 --> 00:29:27.267
Our tools?

00:29:27.267 --> 00:29:29.000
You may have to use interact
with our system.

00:29:29.000 --> 00:29:32.267
However, we try to make them
as open as possible.

00:29:32.267 --> 00:29:34.534
But additionally, we think
that they're pretty great.

00:29:34.534 --> 00:29:36.834
For example,
our development environment,

00:29:36.834 --> 00:29:39.534
as mentioned in the keynote,
is a three-megabyte download

00:29:39.534 --> 00:29:43.868
that allows you to mimic the
App Engine serving environment

00:29:43.868 --> 00:29:46.434
on your local machine
to allow you to do development

00:29:46.434 --> 00:29:48.300
locally and then integrate
very quickly

00:29:48.300 --> 00:29:49.901
in developing applications.

00:29:49.901 --> 00:29:51.701
Once your application
is deployed,

00:29:51.701 --> 00:29:55.567
you can use our admin console
at appengine.google.com

00:29:55.567 --> 00:29:58.434
to manage your application
from one place.

00:29:58.434 --> 00:30:00.400
You get ben--

00:30:00.400 --> 00:30:02.000
Because of that,
you get benefits such as having

00:30:02.000 --> 00:30:04.601
your logs integrated
and in one place.

00:30:04.601 --> 00:30:06.267
I don't know how many
of you ever tried

00:30:06.267 --> 00:30:08.634
to correlate your
web server logs

00:30:08.634 --> 00:30:10.067
with your application
server logs

00:30:10.067 --> 00:30:12.734
and figure out which
application logs correspond

00:30:12.734 --> 00:30:14.234
to which web requests.

00:30:14.234 --> 00:30:15.767
But it's not always
so straightforward.

00:30:15.767 --> 00:30:17.667
With the admin console,
that's all done for you

00:30:17.667 --> 00:30:22.300
and it's there online and
searchable all the time.

00:30:22.300 --> 00:30:24.133
Additionally,
you don't have to manage

00:30:24.133 --> 00:30:25.434
or configure any machines.

00:30:25.434 --> 00:30:26.868
You don't know how many
app servers

00:30:26.868 --> 00:30:28.100
your application's running on.

00:30:28.100 --> 00:30:30.701
That's all managed
transparently for you.

00:30:30.701 --> 00:30:32.367
And all of these
give you the benefit

00:30:32.367 --> 00:30:34.834
of ease of deployment
and fast iterative development,

00:30:34.834 --> 00:30:36.767
which allows you
to be a more efficient

00:30:36.767 --> 00:30:39.634
and effective
software developer.

00:30:39.634 --> 00:30:42.300
So the second motivation was
to encourage

00:30:42.300 --> 00:30:45.067
per-request footprints.

00:30:45.067 --> 00:30:48.934
Like I said, many
applications and my requests

00:30:48.934 --> 00:30:51.300
concurrently run
on the same infrastructure,

00:30:51.300 --> 00:30:53.400
the same app servers
and we wanted to make

00:30:53.400 --> 00:30:55.234
good use of our app servers
and make sure

00:30:55.234 --> 00:30:58.567
that applications are fair
in that the way--

00:30:58.567 --> 00:31:01.067
we're fair in the way
that we distribute resources

00:31:01.067 --> 00:31:02.467
across these applications.

00:31:02.467 --> 00:31:04.334
What it means
for your application?

00:31:04.334 --> 00:31:05.801
Well, you may get
less memory usage than

00:31:05.801 --> 00:31:08.834
you're used to running
on a machine that you control.

00:31:08.834 --> 00:31:11.200
And additionally, less CPU.

00:31:11.200 --> 00:31:13.534
However, we think that this
is a good thing in many ways,

00:31:13.534 --> 00:31:15.601
because it encourages you make
better use of resources

00:31:15.601 --> 00:31:18.501
and allows you to use
our APIs to do some of the more

00:31:18.501 --> 00:31:20.267
intensive tasks
and not have to do them

00:31:20.267 --> 00:31:22.767
on your own machine.

00:31:22.767 --> 00:31:24.067
We want to encourage
fast requests

00:31:24.067 --> 00:31:26.567
to make better use
of our app servers.

00:31:26.567 --> 00:31:28.000
Again, better fairness--

00:31:28.000 --> 00:31:29.501
or more fairness
between applications.

00:31:29.501 --> 00:31:31.467
Sort of very similar
to the last slide.

00:31:31.467 --> 00:31:33.934
But a fast request also
give us the added benefit

00:31:33.934 --> 00:31:38.267
of being able to do agile
routing and scheduling.

00:31:38.267 --> 00:31:40.667
If a request is quick
and they're--

00:31:40.667 --> 00:31:42.167
If a request is quick
for an application,

00:31:42.167 --> 00:31:43.601
we're able to move
that application 

00:31:43.601 --> 00:31:45.534
or redistribute
the load very quickly.

00:31:45.534 --> 00:31:47.634
We don't have to wait for your
requests that are in-flight

00:31:47.634 --> 00:31:50.634
to complete before
we can move it.

00:31:50.634 --> 00:31:52.767
It also means,
like I said before,

00:31:52.767 --> 00:31:57.767
because applications
are run quickly

00:31:57.767 --> 00:31:59.667
and are able to share
the same runtimes,

00:31:59.667 --> 00:32:02.000
you get to make use of better
runtime caching

00:32:02.000 --> 00:32:05.734
and you may run into things that
just request deadlines.

00:32:05.734 --> 00:32:07.033
Benefits to your application?

00:32:07.033 --> 00:32:08.434
Well, because
of runtime caching,

00:32:08.434 --> 00:32:10.601
you're able
to optimistically share state

00:32:10.601 --> 00:32:13.934
between your requests.

00:32:13.934 --> 00:32:16.901
You're gonna see more throughput
or better throughput

00:32:16.901 --> 00:32:17.968
and better performance
in general

00:32:17.968 --> 00:32:19.200
if your requests are fast.

00:32:19.200 --> 00:32:22.100
For the same number
of live serving runtimes,

00:32:22.100 --> 00:32:23.767
you're able to serve
a lot more traffic

00:32:23.767 --> 00:32:25.801
if your requests are faster.

00:32:25.801 --> 00:32:28.033
You also get better
fault tolerance.

00:32:28.033 --> 00:32:30.200
If you have less
requests in-flight

00:32:30.200 --> 00:32:33.033
at any given moment and there
is some kind of failure,

00:32:33.033 --> 00:32:36.300
less of your requests
will be canceled because of it.

00:32:36.300 --> 00:32:39.634
Also, additionally,
better use of resources.

00:32:39.634 --> 00:32:42.167
The less you consume
of your App Engine resources,

00:32:42.167 --> 00:32:44.100
the less--
the more you have

00:32:44.100 --> 00:32:48.501
to use later of our free quotas
and additionally paid quotas.

00:32:48.501 --> 00:32:50.467
The next thing we wanted
to do was maintain

00:32:50.467 --> 00:32:52.234
isolation between applications.

00:32:52.234 --> 00:32:54.133
So this is for
two main reasons.

00:32:54.133 --> 00:32:55.601
Safety.

00:32:55.601 --> 00:32:58.067
We want applications
to not have to worry

00:32:58.067 --> 00:33:00.067
about the other
applications running

00:33:00.067 --> 00:33:01.267
additionally
on our infrastructure.

00:33:01.267 --> 00:33:02.734
And predictability.

00:33:02.734 --> 00:33:04.200
We don't want one application's
performance

00:33:04.200 --> 00:33:07.200
to impact another application's
performance.

00:33:07.200 --> 00:33:09.033
This means your
application may see

00:33:09.033 --> 00:33:11.033
that certain system calls
are unavailable.

00:33:11.033 --> 00:33:12.868
You don't have
raw network access.

00:33:12.868 --> 00:33:15.434
You may not get some
of the extensions.

00:33:15.434 --> 00:33:17.801
The C extensions on Python
that you're used to using.

00:33:17.801 --> 00:33:19.701
The benefits are
you can be assured

00:33:19.701 --> 00:33:23.167
that your application
is secure in the sense

00:33:23.167 --> 00:33:24.667
that no applications
can touch it.

00:33:24.667 --> 00:33:27.834
Additionally, no one can SSH
into your machine.

00:33:27.834 --> 00:33:30.234
You're not running on a machine
that's out there in the wild.

00:33:30.234 --> 00:33:32.234
You're running behind
a lot of other stuff

00:33:32.234 --> 00:33:33.901
that gives you a--

00:33:33.901 --> 00:33:35.734
that can give you
a sense of security.

00:33:35.734 --> 00:33:38.734
Additionally, you're gonna
get better performance

00:33:38.734 --> 00:33:40.667
because you're not running
on the same--

00:33:40.667 --> 00:33:42.734
you're not affected
by other applications'

00:33:42.734 --> 00:33:45.567
serving characteristics.

00:33:45.567 --> 00:33:48.868
So I also want to talk
about statelessness

00:33:48.868 --> 00:33:50.234
and specialization.

00:33:50.234 --> 00:33:53.000
This is something that
I mentioned a couple of times.

00:33:53.000 --> 00:33:55.000
And it's really
important for us

00:33:55.000 --> 00:33:56.901
in order to be able to serve
so many applications

00:33:56.901 --> 00:33:59.367
in this manner.

00:33:59.367 --> 00:34:02.834
For us, it allows us to have
better app server performance,

00:34:02.834 --> 00:34:05.334
because we don't have to manage
and maintain state.

00:34:05.334 --> 00:34:07.167
It allows us to do better
load balancing

00:34:07.167 --> 00:34:08.767
for the reasons
I mentioned earlier.

00:34:08.767 --> 00:34:11.734
Our App Engine front-ends
can move applications

00:34:11.734 --> 00:34:13.467
across web servers
very quickly

00:34:13.467 --> 00:34:16.467
and manage your
load dynamically,

00:34:16.467 --> 00:34:18.300
because they don't have
to move any state around.

00:34:18.300 --> 00:34:19.667
And additionally,
because you don't have

00:34:19.667 --> 00:34:20.934
any state to maintain,
you don't have

00:34:20.934 --> 00:34:22.767
any state to lose,
so your application

00:34:22.767 --> 00:34:26.033
will be very fault tolerant,
because the APIs are what are--

00:34:26.033 --> 00:34:27.968
The systems behind the APIs
are what are

00:34:27.968 --> 00:34:31.100
holding on to that state.

00:34:31.100 --> 00:34:33.701
And then this means your
application

00:34:33.701 --> 00:34:35.667
should use API calls
to do things that are

00:34:35.667 --> 00:34:37.667
provided for you.

00:34:37.667 --> 00:34:39.434
This is really great because
you get the advantage

00:34:39.434 --> 00:34:42.667
of automatic load
balancing because

00:34:42.667 --> 00:34:47.334
of the better scheduling that we
can do and fault tolerance.

00:34:47.334 --> 00:34:49.601
And additionally,
it's less code for you to write.

00:34:49.601 --> 00:34:51.000
If you want
to manipulate images

00:34:51.000 --> 00:34:56.367
or if you want to send mail
or have a user accounts,

00:34:56.367 --> 00:34:58.400
you don't have to write
all that code yourself.

00:34:58.400 --> 00:35:00.601
You can use our back-ends
that are specialized,

00:35:00.601 --> 00:35:03.434
dedicated systems that are
only--

00:35:03.434 --> 00:35:07.067
Their only job is to do these
types of jobs for you.

00:35:07.067 --> 00:35:09.534
And then finally,
we wanted to require

00:35:09.534 --> 00:35:12.100
a partitioned data model.

00:35:12.100 --> 00:35:13.968
The main reason for
this is that we wanted

00:35:13.968 --> 00:35:17.234
to be able to give you BigTable
and the datastore.

00:35:17.234 --> 00:35:20.834
We want people to learn
that it's not so hard

00:35:20.834 --> 00:35:22.467
to write applications
with this data model

00:35:22.467 --> 00:35:24.133
and you get a lot
of advantages.

00:35:24.133 --> 00:35:26.767
What it means
for your application

00:35:26.767 --> 00:35:28.434
is that it may have to--

00:35:28.434 --> 00:35:30.167
You may have to design
your data model differently

00:35:30.167 --> 00:35:31.667
than you would
if you were using

00:35:31.667 --> 00:35:34.634
a MySQL database running
on one machine.

00:35:34.634 --> 00:35:37.501
You will have to define indexes
for all queries.

00:35:37.501 --> 00:35:39.434
But you'll see
that your writes

00:35:39.434 --> 00:35:40.601
are very, very fast.

00:35:40.601 --> 00:35:41.667
Your--I'm sorry.

00:35:41.667 --> 00:35:42.667
Your reads are very,
very fast.

00:35:42.667 --> 00:35:43.868
Your writes may be
a bit slower,

00:35:43.868 --> 00:35:45.100
but you don't have
to go through the pain

00:35:45.100 --> 00:35:47.467
of designing your schema
or redesigning your schema

00:35:47.467 --> 00:35:49.734
or re-architecting
your application.

00:35:49.734 --> 00:35:52.200
And the hardest time
for an application 

00:35:52.200 --> 00:35:54.000
is when your application load
starts to grow.

00:35:54.000 --> 00:35:56.367
You've already done it,
so you're already ready.

00:35:56.367 --> 00:35:58.200
Additionally,
you get more efficient use

00:35:58.200 --> 00:36:01.434
of CPU memory because you
pre-compute things

00:36:01.434 --> 00:36:05.200
at write time and then when you
read them it's very fast

00:36:05.200 --> 00:36:07.634
and in-memory.

00:36:07.634 --> 00:36:10.133
This--

00:36:10.133 --> 00:36:11.701
So this sort of shapes--

00:36:11.701 --> 00:36:14.534
This sort of elucidates
the kind of applications

00:36:14.534 --> 00:36:15.834
that are great
for running an App Engine,

00:36:15.834 --> 00:36:18.367
applications
that are read intensive.

00:36:18.367 --> 00:36:19.901
Most web applications
fit this mold,

00:36:19.901 --> 00:36:21.901
so we think
it's a really good fit.

00:36:21.901 --> 00:36:24.868
So now I want to talk
a little bit about

00:36:24.868 --> 00:36:28.067
App Engine numbers
and talk about some data

00:36:28.067 --> 00:36:30.133
that we haven't
shared previously.

00:36:30.133 --> 00:36:35.067
So some of this was...

00:36:35.067 --> 00:36:36.267
set up
at keynote this morning,

00:36:36.267 --> 00:36:37.834
but currently on App Engine,

00:36:37.834 --> 00:36:40.367
we have over
80,000 applications.

00:36:40.367 --> 00:36:42.067
And those applications
are serving

00:36:42.067 --> 00:36:46.434
over 140 million
page views per day,

00:36:46.434 --> 00:36:47.734
which is a lot
of traffic.

00:36:47.734 --> 00:36:50.200
And then we have
over 200,000 developers,

00:36:50.200 --> 00:36:52.133
which is something we're really
excited about.

00:36:52.133 --> 00:36:54.634
We're really excited
that so many people

00:36:54.634 --> 00:36:57.567
have given App Engine a try and
found that it works for them

00:36:57.567 --> 00:37:00.334
and have all these
applications running.

00:37:00.334 --> 00:37:03.601
And then to dig
in a little bit deeper

00:37:03.601 --> 00:37:06.701
and talk about one application
that was also

00:37:06.701 --> 00:37:09.501
mentioned a bit earlier,
the White House

00:37:09.501 --> 00:37:11.434
had an "open for questions"
application.

00:37:11.434 --> 00:37:13.601
Sort of a case study
in how well applications

00:37:13.601 --> 00:37:16.267
can scale in App Engine.

00:37:16.267 --> 00:37:18.567
Basically, what
"open for questions" was

00:37:18.567 --> 00:37:21.801
was it's an instance
of Google Moderator

00:37:21.801 --> 00:37:24.267
that was running on
the White House's website.

00:37:24.267 --> 00:37:28.300
And what they did was they
solicited questions

00:37:28.300 --> 00:37:31.868
from everyday Americans
and votes on those questions

00:37:31.868 --> 00:37:34.167
to sort of crowd source
the best questions

00:37:34.167 --> 00:37:36.367
about different
policy issues

00:37:36.367 --> 00:37:38.534
that were affecting
the Obama administration

00:37:38.534 --> 00:37:42.501
and in the course
of over 48 hours,

00:37:42.501 --> 00:37:44.801
the application
accepted 100,000 questions

00:37:44.801 --> 00:37:50.267
and 3.6 million votes,
which is huge in just 48 hours.

00:37:50.267 --> 00:37:52.734
The application went
from serving zero traffic

00:37:52.734 --> 00:37:55.968
to having 3.6 million votes
and 100,000 applications

00:37:55.968 --> 00:37:58.434
in just under 48 hours.

00:37:58.434 --> 00:37:59.968
And then at the end
of all of this,

00:37:59.968 --> 00:38:02.367
President Obama,
in a live televised

00:38:02.367 --> 00:38:05.167
press conference, answered
the highest-rated questions

00:38:05.167 --> 00:38:08.167
from some of those topics.

00:38:08.167 --> 00:38:10.400
This was really exciting
for us

00:38:10.400 --> 00:38:12.234
and really exciting
as App Engine developers

00:38:12.234 --> 00:38:14.033
and as Americans in general
to get that kind

00:38:14.033 --> 00:38:16.968
of interactivity between us
and our government.

00:38:16.968 --> 00:38:20.367
So you can take
a look at the graph.

00:38:20.367 --> 00:38:24.634
You'll see that White House
kickoff blog posts--

00:38:24.634 --> 00:38:26.734
WhiteHouse.gov got
a little bit of traffic.

00:38:26.734 --> 00:38:27.801
A little bit.

00:38:27.801 --> 00:38:29.567
100 QPS of traffic
is actually

00:38:29.567 --> 00:38:30.801
kind of a lot of traffic.

00:38:30.801 --> 00:38:34.734
And then in the afternoon,
we got a mention on NPR,

00:38:34.734 --> 00:38:37.267
New York Times coverage,
and CNN coverage.

00:38:37.267 --> 00:38:39.601
And then at 5:00,
there was a link

00:38:39.601 --> 00:38:42.334
on the Google homepage
for the White House application.

00:38:42.334 --> 00:38:46.400
And then before submission,
this application

00:38:46.400 --> 00:38:48.968
peaked at a load of about 700
queries per second,

00:38:48.968 --> 00:38:52.133
which is a very,
very high amount of load.

00:38:52.133 --> 00:38:55.701
And then they cut off voting
and the traffic

00:38:55.701 --> 00:38:58.601
came down really quickly.

00:38:58.601 --> 00:39:03.067
And so with that,
I'll open it up to questions.

00:39:03.067 --> 00:39:04.667
I'll pull up
the Moderator page

00:39:04.667 --> 00:39:06.234
and if you want
to ask live questions,

00:39:06.234 --> 00:39:09.467
you can walk up
to the microphones as well.

00:39:09.467 --> 00:39:10.767
Thank you.

00:39:10.767 --> 00:39:15.434
[applause]

00:39:15.434 --> 00:39:18.767
That's weird.

00:39:18.767 --> 00:39:20.467
All right.

00:39:20.467 --> 00:39:22.734
man: I'm curious what you
were just saying

00:39:22.734 --> 00:39:24.501
about Google Moderator.

00:39:24.501 --> 00:39:26.767
If you guys developed
that in-house

00:39:26.767 --> 00:39:29.234
and deployed it on behalf
of whitehouse.gov

00:39:29.234 --> 00:39:30.901
or if it's
an open source project

00:39:30.901 --> 00:39:34.400
that you had previously built
that their developers

00:39:34.400 --> 00:39:37.434
deployed without
any sort of changes

00:39:37.434 --> 00:39:38.701
that you would have
had to make

00:39:38.701 --> 00:39:40.100
to scale
to that size?

00:39:40.100 --> 00:39:42.667
Levi: So Moderator
is an open source project

00:39:42.667 --> 00:39:44.868
that is available
for anyone to deploy.

00:39:44.868 --> 00:39:46.701
The White House made
a few changes

00:39:46.701 --> 00:39:48.400
for a variety
of different reasons.

00:39:48.400 --> 00:39:50.000
Privacy and
increasing performance.

00:39:50.000 --> 00:39:54.367
They wanted to really get that
tuned as best as possible.

00:39:54.367 --> 00:39:57.200
But they deployed
the application

00:39:57.200 --> 00:39:59.000
and it's there for anybody
to download

00:39:59.000 --> 00:40:00.200
and deploy their own.

00:40:00.200 --> 00:40:01.901
man: Did that take much work
from you guys

00:40:01.901 --> 00:40:04.234
for them to be able to get it
to scale to that level?

00:40:04.234 --> 00:40:05.300
Levi: We were there
to support them.

00:40:05.300 --> 00:40:06.868
But, um, yeah.

00:40:06.868 --> 00:40:08.934
I mean, it was really
important for us

00:40:08.934 --> 00:40:10.501
and we kept a close eye
on it to make sure

00:40:10.501 --> 00:40:12.834
that it went well,
but, yeah,

00:40:12.834 --> 00:40:14.033
it was a really
big success.

00:40:14.033 --> 00:40:15.067
And additionally,
it didn't impact

00:40:15.067 --> 00:40:16.334
any other
applications serving

00:40:16.334 --> 00:40:18.901
on App Engine,
which is huge.

00:40:18.901 --> 00:40:20.467
man: Hi.

00:40:20.467 --> 00:40:22.067
Levi: Yes.

00:40:22.067 --> 00:40:24.601
man: You talked about some
of these Google applications

00:40:24.601 --> 00:40:26.534
that we can use as part
of the App Engine.

00:40:26.534 --> 00:40:30.601
You know, like, mail and chat
and those kinds of things.

00:40:30.601 --> 00:40:32.234
Is there a plan
to give something

00:40:32.234 --> 00:40:34.601
like a search itself
as an application?

00:40:34.601 --> 00:40:36.834
Levi: Search itself as an API?

00:40:36.834 --> 00:40:38.334
man: As an API.

00:40:38.334 --> 00:40:41.334
Levi: So we would very much
like to have

00:40:41.334 --> 00:40:43.300
full text search
in our datastore.

00:40:43.300 --> 00:40:45.400
Because we sort of are

00:40:45.400 --> 00:40:48.267
rethinking the way
that we do certain things

00:40:48.267 --> 00:40:50.334
in order to make it available
to lots of applications.

00:40:50.334 --> 00:40:52.868
And on a request-based model,
we've had to sort of

00:40:52.868 --> 00:40:55.634
redesign some of the things
that you sort of take

00:40:55.634 --> 00:40:58.801
for granted that Google's good
at, like search.

00:40:58.801 --> 00:41:00.300
All I can say is that we're
working on it

00:41:00.300 --> 00:41:01.634
and we'd very much
like to have

00:41:01.634 --> 00:41:02.734
a search in our datastore.

00:41:02.734 --> 00:41:03.801
man: Right, thank you.

00:41:03.801 --> 00:41:05.000
Levi: Yeah, you're welcome.

00:41:05.000 --> 00:41:08.434
And then I'll take some
of these questions here.

00:41:08.434 --> 00:41:10.901
I'll take one question
up here first.

00:41:10.901 --> 00:41:13.701
This looks like--
yes.

00:41:13.701 --> 00:41:15.734
"Is there a way to pre-load
big libraries

00:41:15.734 --> 00:41:19.567
"such as Django 1.x rather
than delaying requests

00:41:19.567 --> 00:41:22.834
for several seconds while
zipserve loads it?"

00:41:22.834 --> 00:41:25.067
So like I said,
you can take those libraries

00:41:25.067 --> 00:41:27.634
and use your runtime caching.

00:41:27.634 --> 00:41:30.234
If you use a main method
in your Python,

00:41:30.234 --> 00:41:33.300
we will cache everything
in your global space

00:41:33.300 --> 00:41:35.367
for the next request
on the same app server.

00:41:35.367 --> 00:41:38.200
So while I don't
know if there's a way

00:41:38.200 --> 00:41:40.968
to pre-load big libraries
so that your first request 

00:41:40.968 --> 00:41:42.234
has them already in there.

00:41:42.234 --> 00:41:45.133
Already, like,
hot and on the app server.

00:41:45.133 --> 00:41:49.801
Subsequent requests should see
an increase to performance.

00:41:49.801 --> 00:41:52.000
man: So it seems like
from this morning's demo,

00:41:52.000 --> 00:41:54.801
you're making a big effort
to integrate GWT,

00:41:54.801 --> 00:41:57.100
particularly the Eclipse plug-in
and all that stuff

00:41:57.100 --> 00:41:58.801
with App Engine,
which is awesome.

00:41:58.801 --> 00:42:00.400
But it makes me wonder whether
that's not gonna

00:42:00.400 --> 00:42:02.267
leave the Python runtime
behind.

00:42:02.267 --> 00:42:03.767
Is there any plans
on the road map

00:42:03.767 --> 00:42:06.701
to do the same kind of one-click
magic stuff in Eclipse

00:42:06.701 --> 00:42:08.133
that we saw this morning?

00:42:08.133 --> 00:42:10.133
Levi: That's a really good
question.

00:42:10.133 --> 00:42:13.133
I don't know exactly
what is in the plan.

00:42:13.133 --> 00:42:15.434
I'm sure we'd like
to do things like that.

00:42:15.434 --> 00:42:18.467
But there's nothing
on the road map at this time.

00:42:18.467 --> 00:42:21.667
I'll take another one
from here.

00:42:21.667 --> 00:42:23.968
"In order to take advantage
of application caching,

00:42:23.968 --> 00:42:26.834
"should you avoid inline
"imports" in your Python code?

00:42:26.834 --> 00:42:30.868
How do you ensure your code
is cached optimally?"

00:42:30.868 --> 00:42:32.300
That's a really good question.

00:42:32.300 --> 00:42:34.200
So it's sort of
a trade-off, right?

00:42:34.200 --> 00:42:37.200
If you put all your imports
at the top of your Python code,

00:42:37.200 --> 00:42:39.334
all of your imports
are gonna get imported

00:42:39.334 --> 00:42:41.767
on your first request
and they're gonna hang around

00:42:41.767 --> 00:42:44.534
on the app server cache
for your runtime

00:42:44.534 --> 00:42:45.968
and be available
to the next request.

00:42:45.968 --> 00:42:48.767
However, that's gonna make your
first request much slower.

00:42:48.767 --> 00:42:50.667
If you break up
your imports into only

00:42:50.667 --> 00:42:52.100
the code paths
that need them,

00:42:52.100 --> 00:42:54.667
you'll be doing less
than a per-request basis.

00:42:54.667 --> 00:42:56.367
So that's more of, like--

00:42:56.367 --> 00:42:58.167
more of something you need
to figure out for application,

00:42:58.167 --> 00:43:03.267
and see what works best.

00:43:03.267 --> 00:43:04.767
man: So you've done
some work to avoid

00:43:04.767 --> 00:43:06.300
hitting the App Engine
all the time

00:43:06.300 --> 00:43:10.100
so, like, serving static files
or doing the image access.

00:43:10.100 --> 00:43:12.567
There's pricing for, like, Gmail
sending mail

00:43:12.567 --> 00:43:14.834
through that API,
but how do you price

00:43:14.834 --> 00:43:16.767
serving static pages?

00:43:16.767 --> 00:43:19.501
Is that just free or does
that count as compute cycles?

00:43:19.501 --> 00:43:22.334
Or how do you kind of calculate
all the API usage

00:43:22.334 --> 00:43:23.567
and static usage?

00:43:23.567 --> 00:43:25.434
Levi: So we still charge
for bandwidth

00:43:25.434 --> 00:43:28.767
in most cases, but you
don't consume any CPU cycles,

00:43:28.767 --> 00:43:31.601
which is the most expensive
resource that there is

00:43:31.601 --> 00:43:34.534
that we have, yeah.

00:43:34.534 --> 00:43:37.033
man: Could you talk a bit
about data portability

00:43:37.033 --> 00:43:41.868
and moving data in and out
of the BigTable datastore?

00:43:41.868 --> 00:43:43.100
Levi: Sure.

00:43:43.100 --> 00:43:46.100
I can mention it briefly.

00:43:46.100 --> 00:43:49.567
We have some libraries,
our bulk uploader

00:43:49.567 --> 00:43:51.934
and bulk downloader
that will get data in and out

00:43:51.934 --> 00:43:55.133
in a common format.

00:43:55.133 --> 00:43:56.567
I don't know.

00:43:56.567 --> 00:43:58.534
And those are available
on the website

00:43:58.534 --> 00:44:01.267
for you to use to get your
data in and out, yeah.

00:44:01.267 --> 00:44:03.634
Is there anything
more specific or?

00:44:03.634 --> 00:44:06.434
man: Not in particular,
but if you have

00:44:06.434 --> 00:44:09.968
maybe an example of a company
that has, like,

00:44:09.968 --> 00:44:14.267
multiple systems maybe partially
built on App Engine

00:44:14.267 --> 00:44:16.968
and then they have maybe
something on Amazon systems.

00:44:16.968 --> 00:44:19.067
Do you have experience
with that?

00:44:19.067 --> 00:44:20.567
Levi: Hmm.

00:44:20.567 --> 00:44:22.501
Mike?

00:44:22.501 --> 00:44:24.033
Do we know
of any such companies

00:44:24.033 --> 00:44:26.901
that have data on App Engine
and port their data

00:44:26.901 --> 00:44:30.133
between EC2 and App Engine?

00:44:30.133 --> 00:44:34.067
[man speaking indistinctly]

00:44:42.634 --> 00:44:43.968
Levi: Yeah, so then it's on.

00:44:43.968 --> 00:44:46.100
[man speaking indistinctly]

00:44:46.100 --> 00:44:47.567
Levi: "App Engine Nitty Gritty"
is the talk

00:44:47.567 --> 00:44:48.934
that's gonna be
on later today.

00:44:48.934 --> 00:44:51.734
Yeah, welcome.

00:44:51.734 --> 00:44:54.767
Take one more from Moderator.

00:44:54.767 --> 00:44:56.467
"I see datastore timeouts
seemingly without

00:44:56.467 --> 00:44:59.133
"any difference in my deployed
code or usage patterns.

00:44:59.133 --> 00:45:01.634
"Is there a way
to get more information

00:45:01.634 --> 00:45:04.133
about why the datastore
is timing out?"

00:45:04.133 --> 00:45:06.033
So you can take a look
a little bit--

00:45:06.033 --> 00:45:07.501
Your logs will give you
some indication

00:45:07.501 --> 00:45:08.934
of when your datastore
is timing out

00:45:08.934 --> 00:45:10.534
and some
of the reasons based on--

00:45:10.534 --> 00:45:12.901
If there's contention,
that'll show up in the logs.

00:45:12.901 --> 00:45:16.667
And there may be some
other reasons.

00:45:16.667 --> 00:45:18.868
I encourage you to go
to Ryan Barrett's talk 

00:45:18.868 --> 00:45:21.067
on the App Engine datastore
and ask him

00:45:21.067 --> 00:45:22.167
these types of questions,
'cause he's

00:45:22.167 --> 00:45:24.267
really the expert on it.

00:45:24.267 --> 00:45:25.901
Uh, please.

00:45:25.901 --> 00:45:26.968
man: Hi.

00:45:26.968 --> 00:45:28.868
Ert Dredge from
Universal Metaphor.

00:45:28.868 --> 00:45:30.601
Can you outline if there's
any significant differences

00:45:30.601 --> 00:45:34.033
between the Python and Java
flavors that you have,

00:45:34.033 --> 00:45:35.834
either right now or
in the road maps,

00:45:35.834 --> 00:45:37.067
or are they--

00:45:37.067 --> 00:45:38.868
as far as the restrictions
you get for App Engine,

00:45:38.868 --> 00:45:41.801
are they pretty close
to the same capabilities?

00:45:41.801 --> 00:45:44.133
Levi: Well, we want to try
to keep both of them

00:45:44.133 --> 00:45:46.567
in line as far as their
capabilities

00:45:46.567 --> 00:45:50.300
and we continue to update
and maintain

00:45:50.300 --> 00:45:54.767
API-level equivalence
between the two.

00:45:54.767 --> 00:45:56.767
I don't know specifically.

00:45:56.767 --> 00:45:58.834
Is there anything specific
that you were--

00:45:58.834 --> 00:46:02.133
man: I'm right now agnostic
and actually looking

00:46:02.133 --> 00:46:03.501
and choosing one
versus the other.

00:46:03.501 --> 00:46:04.667
And I was wondering
if there was, 

00:46:04.667 --> 00:46:06.367
well, yes, we plan on having
this capability

00:46:06.367 --> 00:46:08.734
on one side,
or Java hasn't yet caught up

00:46:08.734 --> 00:46:09.968
to that capability?

00:46:09.968 --> 00:46:11.968
If there's any major
differences you know of.

00:46:11.968 --> 00:46:14.133
Levi: I think that we're
committed to maintaining

00:46:14.133 --> 00:46:16.701
the same capabilities across
both runtimes, yeah.

00:46:16.701 --> 00:46:18.934
man: Thanks.

00:46:18.934 --> 00:46:20.467
Levi: Yes?

00:46:20.467 --> 00:46:23.434
man: This is another
zip import

00:46:23.434 --> 00:46:27.133
kind of app
or module caching question.

00:46:27.133 --> 00:46:31.267
But you mentioned that
the App Engine will cache

00:46:31.267 --> 00:46:35.567
the module for that application
on the same app server.

00:46:35.567 --> 00:46:38.133
And many people
have kind of found out

00:46:38.133 --> 00:46:40.734
that those modules are cached
for a number of seconds,

00:46:40.734 --> 00:46:43.534
but after a few seconds
of not having a request,

00:46:43.534 --> 00:46:45.868
that module will get
kind of dropped.

00:46:45.868 --> 00:46:50.334
And so also, if, like,
the application--or if

00:46:50.334 --> 00:46:52.334
it's cached for that
app server and you have

00:46:52.334 --> 00:46:55.100
multiple app servers in the
App Engine infrastructure...

00:46:55.100 --> 00:46:56.434
Levi: Sure.

00:46:56.434 --> 00:46:58.767
man: how many requests
per second, basically,

00:46:58.767 --> 00:47:01.868
would you need to have before,
like, you would,

00:47:01.868 --> 00:47:06.000
basically not have to input
the modules every single time,

00:47:06.000 --> 00:47:11.534
or not expect to, like, have
users getting slow requests?

00:47:11.534 --> 00:47:13.167
Levi: Um, right.
That's a good question.

00:47:13.167 --> 00:47:15.634
So, basically,
what kind of sustained

00:47:15.634 --> 00:47:16.934
requests-per-second
would you need

00:47:16.934 --> 00:47:19.701
to keep your runtime
in the cache?

00:47:19.701 --> 00:47:21.701
I don't know what--

00:47:21.701 --> 00:47:23.667
I don't know if there's really
a specific answer to that,

00:47:23.667 --> 00:47:25.000
because it sort
of changes dynamically,

00:47:25.000 --> 00:47:27.000
both with the amount
of traffic

00:47:27.000 --> 00:47:29.000
that we're seeing across all
of App Engine,

00:47:29.000 --> 00:47:32.133
because caches
will get cycled out

00:47:32.133 --> 00:47:33.734
as more requests
come in

00:47:33.734 --> 00:47:35.968
and they're handled
sort of in a first--

00:47:35.968 --> 00:47:38.300
They're handled--

00:47:38.300 --> 00:47:42.067
We handle them equivalently,
so I don't know

00:47:42.067 --> 00:47:43.567
if there is
a specific answer

00:47:43.567 --> 00:47:46.334
in terms of, like, a number
I can give you regarding that.

00:47:46.334 --> 00:47:48.501
man: Okay.

00:47:48.501 --> 00:47:49.901
Levi: Excuse me?

00:47:49.901 --> 00:47:52.167
[man speaking indistinctly]

00:47:52.167 --> 00:47:54.234
Um.

00:47:54.234 --> 00:47:56.100
Yeah, I really don't know.

00:47:56.100 --> 00:47:57.534
It sort of depends
on your application load too,

00:47:57.534 --> 00:47:59.801
'cause once you start
seeing more traffic,

00:47:59.801 --> 00:48:01.434
you may get scheduled
on more app servers,

00:48:01.434 --> 00:48:03.400
which means that you'll
have more caches

00:48:03.400 --> 00:48:05.200
to maintain hot and it's--

00:48:05.200 --> 00:48:06.501
Yeah, I really don't--

00:48:06.501 --> 00:48:08.434
I really can't answer
that question.

00:48:08.434 --> 00:48:10.968
We'll take one
from Moderator again.

00:48:10.968 --> 00:48:13.067
"With the App Engine datastore,
can I control

00:48:13.067 --> 00:48:15.133
"where my data is replicated
in BigTable?

00:48:15.133 --> 00:48:17.934
"For example,
if I don't want my data

00:48:17.934 --> 00:48:19.400
"to be replicated outside
of the U.S.

00:48:19.400 --> 00:48:21.000
"or, conversely,
into the U.S.,

00:48:21.000 --> 00:48:23.834
can I 'pin' the data
to a specific geolocation?"

00:48:23.834 --> 00:48:29.067
So in general regarding
data replication,

00:48:29.067 --> 00:48:31.033
your data is replicated

00:48:31.033 --> 00:48:33.767
and currently
I don't think--

00:48:33.767 --> 00:48:36.267
We would like
to give developers control

00:48:36.267 --> 00:48:38.334
over where their data is
or where their application

00:48:38.334 --> 00:48:40.200
serves from and we're
working on that,

00:48:40.200 --> 00:48:43.100
but we don't have that
capability right now.

00:48:43.100 --> 00:48:47.133
[man speaking indistinctly]

00:48:47.133 --> 00:48:48.968
In--so--

00:48:48.968 --> 00:48:51.968
[man speaking indistinctly]

00:48:51.968 --> 00:48:53.868
So E requires data
to stay within you.

00:48:53.868 --> 00:48:58.467
I'm sure that we abide
by the various laws.

00:48:58.467 --> 00:49:00.567
[laughter]

00:49:00.567 --> 00:49:04.100
But I don't know the specifics
regarding that though.

00:49:04.100 --> 00:49:06.601
Um, so--
So yeah.

00:49:06.601 --> 00:49:07.868
Let's take another question.

00:49:07.868 --> 00:49:09.901
man: Michael [indistinct]
of Dynamics Software.

00:49:09.901 --> 00:49:11.901
You addressed a great deal
of scalability shifts.

00:49:11.901 --> 00:49:13.300
Thank you.

00:49:13.300 --> 00:49:15.133
What about complexity
of the application?

00:49:15.133 --> 00:49:16.567
How complex the app would be?

00:49:16.567 --> 00:49:17.901
That's question number one.

00:49:17.901 --> 00:49:19.200
Question number two:

00:49:19.200 --> 00:49:22.901
What about background
housekeeping kind of thing?

00:49:22.901 --> 00:49:24.300
Is it possible at all?

00:49:24.300 --> 00:49:26.033
Because the more complex
the application,

00:49:26.033 --> 00:49:27.300
you definitely need it.

00:49:27.300 --> 00:49:28.968
Levi: Great.
Both great questions.

00:49:28.968 --> 00:49:33.067
So in terms of complexity,
because you're using APIs,

00:49:33.067 --> 00:49:36.133
which take some
of the complexity out

00:49:36.133 --> 00:49:38.300
of the scope of your application
and push it back

00:49:38.300 --> 00:49:41.968
to dedicated services.

00:49:41.968 --> 00:49:43.601
Your application or the code
that you deploy

00:49:43.601 --> 00:49:45.868
can be much less complex,
because you don't

00:49:45.868 --> 00:49:47.934
have to do that work yourself.

00:49:47.934 --> 00:49:52.667
And then secondly, in terms
of background processing

00:49:52.667 --> 00:49:56.501
or offline processing,
we have it on our roadmap

00:49:56.501 --> 00:49:57.801
and we're giving a talk.

00:49:57.801 --> 00:50:00.300
I think it's tomorrow
is Brett's talk

00:50:00.300 --> 00:50:03.534
on offline processing,
a look ahead.

00:50:03.534 --> 00:50:05.968
And he'll give you
a look into the different

00:50:05.968 --> 00:50:07.534
kinds of things
you can do offline.

00:50:07.534 --> 00:50:10.367
Actually, although right now
we do have Kron support.

00:50:10.367 --> 00:50:12.234
So you can use that
to do that sort of outside

00:50:12.234 --> 00:50:14.801
of the scope
of the requests processing.

00:50:14.801 --> 00:50:17.400
man: David Ellsworth,
Ogopogo web pages.

00:50:17.400 --> 00:50:20.334
Do you have equipment
operating in China?

00:50:20.334 --> 00:50:21.968
Levi: Um, I don't--

00:50:21.968 --> 00:50:23.934
In general, we don't discuss
the location

00:50:23.934 --> 00:50:27.701
or any details regarding
the data centers.

00:50:27.701 --> 00:50:31.300
So I'm not gonna be able
to answer that.

00:50:31.300 --> 00:50:33.234
man: When I want
to implement App Engine

00:50:33.234 --> 00:50:35.067
for an enterprise
and it has a brand,

00:50:35.067 --> 00:50:39.601
if I want to disable the apps
portal, is it possible?

00:50:39.601 --> 00:50:42.033
You know, to hide the
implementation of, like--

00:50:42.033 --> 00:50:44.033
Let's say I created
an application

00:50:44.033 --> 00:50:47.434
called
brandstore@mydomainname.com,

00:50:47.434 --> 00:50:49.834
and I don't want
that brand located,

00:50:49.834 --> 00:50:53.634
or whatever the name
which I use as an app I.D.,

00:50:53.634 --> 00:50:55.801
that I can access
basically using

00:50:55.801 --> 00:50:57.868
application I.D.
dot app support dot com.

00:50:57.868 --> 00:50:59.334
Which, if I want to hide it--

00:50:59.334 --> 00:51:01.434
Levi: So do you want
to hide that that exists

00:51:01.434 --> 00:51:04.834
or do you want to hide the
content that's on the site?

00:51:04.834 --> 00:51:07.334
man: I want to hide
the app support URL

00:51:07.334 --> 00:51:09.868
and just--I want to just use
mybrandname--

00:51:09.868 --> 00:51:12.567
mydomainname.com/someapplication
name.

00:51:12.567 --> 00:51:17.300
Levi: I see.

00:51:17.300 --> 00:51:19.334
I don't know exactly
what you can do for that.

00:51:19.334 --> 00:51:21.934
If you're concerned about
revealing your web site

00:51:21.934 --> 00:51:23.400
before it's ready,
you can deploy

00:51:23.400 --> 00:51:26.367
a second major version
and then have

00:51:26.367 --> 00:51:29.334
the default version display some
sort of static content

00:51:29.334 --> 00:51:31.501
or some sort of placeholder
until you're ready

00:51:31.501 --> 00:51:32.968
to switch it over.

00:51:32.968 --> 00:51:35.801
But I don't know offhand

00:51:35.801 --> 00:51:38.868
how you would go about disabling
App Spot. 

00:51:38.868 --> 00:51:40.634
Yes?

00:51:40.634 --> 00:51:46.567
[man speaking indistinctly]

00:51:51.267 --> 00:51:53.968
man: For example, like,
I have an application

00:51:53.968 --> 00:51:56.167
that says, like,
let's say

00:51:56.167 --> 00:51:59.701
applicationname.mydomain.com.

00:51:59.701 --> 00:52:01.634
So when I create
that application I.D.,

00:52:01.634 --> 00:52:03.234
you and I can access
the same application

00:52:03.234 --> 00:52:05.067
using applicationid.appspot.com.

00:52:05.067 --> 00:52:07.734
[man speaking indistinctly]

00:52:07.734 --> 00:52:09.300
man: Okay, yeah.
Think so.

00:52:09.300 --> 00:52:10.501
Levi: Yeah.

00:52:10.501 --> 00:52:13.000
Then I'll take one more
over here.

00:52:13.000 --> 00:52:15.534
Well, I'll take two,
'cause pretty straightforward.

00:52:15.534 --> 00:52:18.834
The first is are we planning
to provide a way

00:52:18.834 --> 00:52:20.868
for deleting an application?

00:52:20.868 --> 00:52:22.267
We would very much like
to provide a way

00:52:22.267 --> 00:52:25.033
to delete an application,
but it's on a long list

00:52:25.033 --> 00:52:26.501
of other things
we'd like to do

00:52:26.501 --> 00:52:30.133
and it's just not the top
of the priorities right now.

00:52:30.133 --> 00:52:31.667
So, yeah.

00:52:31.667 --> 00:52:33.467
At present, no, you can't delete
an application,

00:52:33.467 --> 00:52:35.300
but it's definitely something
we'd like to provide.

00:52:35.300 --> 00:52:37.200
And will this presentation
be available online?

00:52:37.200 --> 00:52:39.868
Yes, it will be.

00:52:39.868 --> 00:52:41.467
I think it'll be on YouTube,
but I don't

00:52:41.467 --> 00:52:43.000
know specifics
on all this stuff.

00:52:43.000 --> 00:52:45.200
I'm sure it'll be
in the conference material.

00:52:45.200 --> 00:52:47.567
man: Are there any plans
for being able

00:52:47.567 --> 00:52:49.300
to establish
a trust relationship

00:52:49.300 --> 00:52:51.567
between a couple datastores
so you can make requests

00:52:51.567 --> 00:52:54.000
across those or is it
always going forward,

00:52:54.000 --> 00:52:58.133
gonna be distinct, you can't
from a security perspective?

00:52:58.133 --> 00:52:59.767
Levi: That's definitely
something we've talked about

00:52:59.767 --> 00:53:03.033
and I think it's something
that is really valuable.

00:53:03.033 --> 00:53:06.267
I don't think that we have any
plans to do that now,

00:53:06.267 --> 00:53:07.701
but we're definitely
thinking about it.

00:53:07.701 --> 00:53:10.200
And again, if you want
to talk to Ryan after,

00:53:10.200 --> 00:53:13.868
he may be able to give you
more insight into that stuff.

00:53:13.868 --> 00:53:16.200
man: Hi, my name
is Scott Lahey.

00:53:16.200 --> 00:53:18.801
Thanks for taking
my question.

00:53:18.801 --> 00:53:22.934
My question is around
the economics of App Engine.

00:53:22.934 --> 00:53:25.367
As an example,
how much would it have cost

00:53:25.367 --> 00:53:29.634
to run that White House
application for a developer

00:53:29.634 --> 00:53:31.601
and is there, like,
a cutoff point

00:53:31.601 --> 00:53:34.567
where, you know,
that Google's thinking about

00:53:34.567 --> 00:53:36.534
or that is kind
of the de facto where you say,

00:53:36.534 --> 00:53:38.567
"Hey, once you, you know,
kind of hit this level,

00:53:38.567 --> 00:53:41.200
"economically it makes
more sense to sort of move

00:53:41.200 --> 00:53:44.334
off the platform on
to your own thing"?

00:53:44.334 --> 00:53:45.801
Levi: Right.

00:53:45.801 --> 00:53:47.334
So I don't know specifics
about how much

00:53:47.334 --> 00:53:49.133
it would have cost
or how much

00:53:49.133 --> 00:53:53.501
it would cost to run the open
for questions White House app.

00:53:53.501 --> 00:53:56.701
In general, I think we have
about 5 million page views

00:53:56.701 --> 00:53:59.133
is what we shoot for--
obviously it depends

00:53:59.133 --> 00:54:00.567
on how you write
your application--

00:54:00.567 --> 00:54:03.367
for the free quota,
which is absolutely free.

00:54:03.367 --> 00:54:04.434
And then--

00:54:04.434 --> 00:54:06.033
[man speaking indistinctly]

00:54:06.033 --> 00:54:07.100
Oh, sorry.

00:54:07.100 --> 00:54:08.300
5 million page views
per month?

00:54:08.300 --> 00:54:09.400
Is that right?
Yeah.

00:54:09.400 --> 00:54:10.968
5 million pages per month.

00:54:10.968 --> 00:54:14.167
And then, secondly, to the
second part of your question,

00:54:14.167 --> 00:54:19.300
which was regarding how high an
application can get--

00:54:19.300 --> 00:54:23.067
So there are some limits
in place that are safety limits

00:54:23.067 --> 00:54:24.734
that an application--

00:54:24.734 --> 00:54:27.267
So that the peak of an
application can serve right now.

00:54:27.267 --> 00:54:29.601
But if you want to exceed
past those limits,

00:54:29.601 --> 00:54:32.000
feel free to contact someone
on the App Engine team

00:54:32.000 --> 00:54:33.934
and we can definitely
talk about those.

00:54:33.934 --> 00:54:36.267
Those are just in place sort
of as a safety measure

00:54:36.267 --> 00:54:39.601
and can be removed
on a case-by-case basis.

00:54:39.601 --> 00:54:41.701
man: Thank you.

00:54:41.701 --> 00:54:42.968
man: I'm curious.

00:54:42.968 --> 00:54:44.467
I know that when you had
problems serving

00:54:44.467 --> 00:54:46.234
a couple of months ago,
they were saying

00:54:46.234 --> 00:54:48.133
that applications
with a certain profile,

00:54:48.133 --> 00:54:49.834
if they're more dynamic
or static,

00:54:49.834 --> 00:54:53.033
would hit limitations when
others would serve just fine.

00:54:53.033 --> 00:54:55.601
Are there certain best practices
that you should maintain

00:54:55.601 --> 00:54:58.701
in the event of an outage
or something

00:54:58.701 --> 00:55:01.234
where you could have
static fallback content

00:55:01.234 --> 00:55:02.334
or something like that?

00:55:02.334 --> 00:55:03.868
Levi: Sure, yeah, definitely.

00:55:03.868 --> 00:55:06.133
Static fallback content
is great.

00:55:06.133 --> 00:55:10.334
We have certain APIs may throw
capability exceptions,

00:55:10.334 --> 00:55:12.534
which you can catch
and then handle.

00:55:12.534 --> 00:55:15.234
So, for example,
if during certain periods,

00:55:15.234 --> 00:55:18.267
we may go into read-only mode
for the datastore

00:55:18.267 --> 00:55:22.501
or your memcache may
be unavailable for some reason

00:55:22.501 --> 00:55:24.067
or something like that,
but those APIs 

00:55:24.067 --> 00:55:26.567
will throw specific exceptions
for those cases

00:55:26.567 --> 00:55:29.534
which you can then catch and
then handle appropriately.

00:55:29.534 --> 00:55:31.367
man: What about something
like letting Python

00:55:31.367 --> 00:55:33.100
manage your URLs?

00:55:33.100 --> 00:55:35.634
If the Python app server
goes down,

00:55:35.634 --> 00:55:37.567
then your entire app
goes down.

00:55:37.567 --> 00:55:39.601
Or if that were an app.yaml,
I don't know

00:55:39.601 --> 00:55:41.534
if that would reroute
to static or if there's--

00:55:41.534 --> 00:55:44.167
Levi: So the app server going
down entirely

00:55:44.167 --> 00:55:46.901
isn't really something
that we are--

00:55:46.901 --> 00:55:48.667
So that's not really,
like, the big concern.

00:55:48.667 --> 00:55:50.067
It's more--

00:55:50.067 --> 00:55:51.501
I think the cases
that you're talking about

00:55:51.501 --> 00:55:53.534
were very specific
to maybe a set of APIs back-ends

00:55:53.534 --> 00:55:55.067
that were available.

00:55:55.067 --> 00:55:57.634
And so just using those
in a robust way

00:55:57.634 --> 00:55:59.667
and following some
of the best practices

00:55:59.667 --> 00:56:00.868
that I think--

00:56:00.868 --> 00:56:03.167
For in terms
of scalability also,

00:56:03.167 --> 00:56:05.200
which I think are
gonna be covered in a talk later

00:56:05.200 --> 00:56:08.033
about best practices
for building scaled apps.

00:56:08.033 --> 00:56:09.901
man: Cool. Thank you.

00:56:09.901 --> 00:56:12.501
Levi: Um, so...

00:56:12.501 --> 00:56:14.701
"I've seen a Google application
run very--

00:56:14.701 --> 00:56:16.400
"a Google App Engine app
run very slowly.

00:56:16.400 --> 00:56:17.868
"This is an application
that worked quickly

00:56:17.868 --> 00:56:19.067
"and has very few users.

00:56:19.067 --> 00:56:20.400
"Can you describe
what causes this

00:56:20.400 --> 00:56:21.601
"and what we can do?

00:56:21.601 --> 00:56:22.834
"Is it because
of a big bandwidth user

00:56:22.834 --> 00:56:24.601
such as whitehouse.gov?"

00:56:24.601 --> 00:56:26.834
So, first off, it's not because
of a big bandwidth user

00:56:26.834 --> 00:56:30.400
such as whitehouse.gov.

00:56:30.400 --> 00:56:32.701
Because of the isolation
that I talked about before,

00:56:32.701 --> 00:56:34.267
applications don't really
affect the way

00:56:34.267 --> 00:56:37.367
that the other ones serve.

00:56:37.367 --> 00:56:40.300
So specifically,
it's very difficult to say

00:56:40.300 --> 00:56:42.200
from this much information.

00:56:42.200 --> 00:56:43.634
It could be a variety
of different reasons

00:56:43.634 --> 00:56:45.100
why your application
may run slowly

00:56:45.100 --> 00:56:48.200
even though are
a few number of users.

00:56:48.200 --> 00:56:49.601
If you follow
our best practices,

00:56:49.601 --> 00:56:51.000
hopefully you can get
around that.

00:56:51.000 --> 00:56:53.901
And there's at least
one talk today--

00:56:53.901 --> 00:56:55.634
Today or tomorrow,
I'm not sure--

00:56:55.634 --> 00:56:57.167
about how to
do that effectively.

00:56:57.167 --> 00:56:58.534
Yeah?

00:56:58.534 --> 00:57:02.100
man: Yeah, I was interested
in if there was any plans

00:57:02.100 --> 00:57:05.033
for parallel URL fetch.

00:57:05.033 --> 00:57:07.033
Basically if being able
to request--

00:57:07.033 --> 00:57:08.934
If you only have 30 seconds
to run

00:57:08.934 --> 00:57:10.634
and you spend half
of that blocking--

00:57:10.634 --> 00:57:13.834
If there are any plans?

00:57:13.834 --> 00:57:15.200
Levi: So that's
definitely something

00:57:15.200 --> 00:57:16.567
we are--
Are we?

00:57:16.567 --> 00:57:19.801
Yeah, that's definitely
something that we want to do.

00:57:19.801 --> 00:57:22.334
I think that it's available.
Is it?

00:57:22.334 --> 00:57:24.367
I don't really know.

00:57:24.367 --> 00:57:26.767
Soon.
Yes, soon.

00:57:26.767 --> 00:57:30.834
If not now.
[laughter]

00:57:30.834 --> 00:57:33.501
man: Yeah, one thing that we've
observed occasionally

00:57:33.501 --> 00:57:36.167
is the very front-end
of the App Engine

00:57:36.167 --> 00:57:39.667
kind of goes haywire
and you get, you know, errors

00:57:39.667 --> 00:57:42.767
that basically don't
then occur in the--

00:57:42.767 --> 00:57:45.701
You don't see in the App Engine
logs, basically,

00:57:45.701 --> 00:57:48.467
because it's at that
first level of the tier

00:57:48.467 --> 00:57:50.434
that's erroring out.

00:57:50.434 --> 00:57:56.067
Is there any plans
or thoughts about--

00:57:56.067 --> 00:57:57.567
And I don't think
that those generate

00:57:57.567 --> 00:57:59.601
the same kind of, like,
alerts that you might get.

00:57:59.601 --> 00:58:01.033
Levi: Right.

00:58:01.033 --> 00:58:05.667
So...that definitely does happen
from time to time

00:58:05.667 --> 00:58:07.701
and there are a variety
of reasons why that may happen

00:58:07.701 --> 00:58:09.634
and there are factors
that contribute to it

00:58:09.634 --> 00:58:11.968
based on whether you're
serving off of App Spot

00:58:11.968 --> 00:58:14.901
or you're serving off
of a custom domain,

00:58:14.901 --> 00:58:17.634
because those different requests
will take different paths

00:58:17.634 --> 00:58:19.234
getting to App Engine.

00:58:19.234 --> 00:58:22.467
And so I can't speak
to specific cases.

00:58:22.467 --> 00:58:24.067
But there are some factors,
some of which

00:58:24.067 --> 00:58:25.901
are in our control
and some which are not,

00:58:25.901 --> 00:58:27.200
since we're customers
of a lot of services

00:58:27.200 --> 00:58:29.901
inside Google also.

00:58:29.901 --> 00:58:34.734
Let's see.

00:58:34.734 --> 00:58:36.267
Um...

00:58:36.267 --> 00:58:38.601
So I'll answer one more from
here and then--

00:58:38.601 --> 00:58:41.801
Uh, and then--
Wait, which one?

00:58:41.801 --> 00:58:43.767
"New applications
with a low number of requests

00:58:43.767 --> 00:58:45.634
"really suffer from a lack
of application caching.

00:58:45.634 --> 00:58:47.934
"Do you have suggestions
to improve app spin-up time

00:58:47.934 --> 00:58:50.534
"and/or can app caching
be adjusted

00:58:50.534 --> 00:58:52.100
for these low traffic apps?"

00:58:52.100 --> 00:58:54.000
So for those
low traffic apps,

00:58:54.000 --> 00:58:56.334
one of the things
you can do is not

00:58:56.334 --> 00:58:57.767
do all of your importing
and initialization

00:58:57.767 --> 00:59:00.200
at the top of your function
or at the top

00:59:00.200 --> 00:59:03.934
of your request script
and do it only

00:59:03.934 --> 00:59:06.033
for those paths which
the request will follow.

00:59:06.033 --> 00:59:09.834
So doing in-line imports
and things like that may help.

00:59:09.834 --> 00:59:13.000
[man speaking indistinctly]

00:59:13.000 --> 00:59:15.601
So I don't know what the best
practices are for Java.

00:59:15.601 --> 00:59:18.534
I think there's a talk
that's Java-specific

00:59:18.534 --> 00:59:21.067
going on for App Engine
a little bit later today.

00:59:21.067 --> 00:59:22.868
man: I think it's
the next talk.

00:59:22.868 --> 00:59:24.267
Levi: Oh, great.

00:59:24.267 --> 00:59:25.767
Next talk, that would
be the right place

00:59:25.767 --> 00:59:28.868
to ask that question
for Java.

00:59:28.868 --> 00:59:30.667
man: When you
were mentioning

00:59:30.667 --> 00:59:33.501
that hot apps keep
the memory around,

00:59:33.501 --> 00:59:36.467
specifically, how do you
take advantage of that?

00:59:36.467 --> 00:59:39.834
I would assume memcache
is one way.

00:59:39.834 --> 00:59:41.767
Imports are probably hot.

00:59:41.767 --> 00:59:44.801
But does that
actually apply

00:59:44.801 --> 00:59:48.234
to variables within
Python instances?

00:59:48.234 --> 00:59:49.634
It does?
Levi: Yeah.

00:59:49.634 --> 00:59:52.534
man: So that seems like
it changes

00:59:52.534 --> 00:59:55.601
the programming model
a little bit.

00:59:55.601 --> 00:59:58.400
How would you best take
advantage of those

00:59:58.400 --> 01:00:03.467
instance data that
is actually around for you?

01:00:03.467 --> 01:00:05.400
Levi: So for Python
specifically or--

01:00:05.400 --> 01:00:07.167
Matthew's got--

01:00:07.167 --> 01:00:13.100
[man speaking indistinctly]

01:00:14.501 --> 01:00:17.133
Yeah, so we can talk more
about that specifically.

01:00:17.133 --> 01:00:21.234
Oh, we're gonna be holding
office hours across the way

01:00:21.234 --> 01:00:22.767
and you can come to us
with specific questions.

01:00:22.767 --> 01:00:24.133
But I've got to wrap
it up anyway,

01:00:24.133 --> 01:00:25.667
so thank you all
for coming.

01:00:25.667 --> 01:00:26.601
[applause]

