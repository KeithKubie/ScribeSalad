WEBVTT
Kind: captions
Language: en

00:00:07.000 --> 00:00:10.420
We're going to talk about
shortest paths,

00:00:10.420 --> 00:00:14.951
and we're going to talk about
shortest paths for three

00:00:14.951 --> 00:00:17.602
lectures.
So, this is a trilogy.

00:00:17.602 --> 00:00:20.338
Today will be Shortest Paths
One.

00:00:20.338 --> 00:00:25.211
I've been watching far too many
versions of Star Wars this

00:00:25.211 --> 00:00:28.289
weekend.
I saw the musical yesterday,

00:00:28.289 --> 00:00:31.930
matinee.
That was an MIT musical.

00:00:31.930 --> 00:00:35.228
That was fun,
of all three movies in about

00:00:35.228 --> 00:00:38.526
four hours.
That was a bit long and then I

00:00:38.526 --> 00:00:42.467
saw the one-man show on Friday.
One-man Star Wars:

00:00:42.467 --> 00:00:45.443
the original three movies in
one hour.

00:00:45.443 --> 00:00:48.097
That was the opposite of too
long.

00:00:48.097 --> 00:00:51.154
Both were fun.
So I get my trilogy fix.

00:00:51.154 --> 00:00:54.693
All episodes,
first we're going to start with

00:00:54.693 --> 00:00:58.071
The New Hope,
and we're going to talk about

00:00:58.071 --> 00:01:02.978
the shortest paths problem and
solve one particular problem of

00:01:02.978 --> 00:01:09.142
it, a very interesting version.
And then we're going to look at

00:01:09.142 --> 00:01:12.322
increasingly more general
versions as we go on.

00:01:12.322 --> 00:01:15.847
Shortest paths are sort of an
application of dynamic

00:01:15.847 --> 00:01:19.857
programming, which we saw last
week, and greedy algorithms,

00:01:19.857 --> 00:01:23.728
which we also saw last week.
So, were going to build that

00:01:23.728 --> 00:01:27.737
and get some pretty interesting
algorithms for an important

00:01:27.737 --> 00:01:30.778
problem, which is how to get
from Alderon to,

00:01:30.778 --> 00:01:33.267
I don't know,
Cambridge as quickly as

00:01:33.267 --> 00:01:37.000
possible, OK,
when you live in a graph.

00:01:37.000 --> 00:01:41.384
So, there's geometric shortest
paths which is a little bit

00:01:41.384 --> 00:01:44.230
harder.
Here, we're just going to look

00:01:44.230 --> 00:01:48.461
at shortest paths in graphs.
Now, hopefully you all know

00:01:48.461 --> 00:01:52.692
what a path in a graph is.
But, so, very quick review in

00:01:52.692 --> 00:01:56.923
particular because we're going
to be looking at weighted

00:01:56.923 --> 00:01:59.000
graphs.
So, the usual setup:

00:01:59.000 --> 00:02:03.076
suppose we have directed graph,
G, have some vertices,

00:02:03.076 --> 00:02:07.968
some edges.
We have edge weights,

00:02:07.968 --> 00:02:12.633
make it a little more
interesting.

00:02:12.633 --> 00:02:18.712
So, this is just a real number
on each edge.

00:02:18.712 --> 00:02:25.214
So, edge weights are usually
given by function,

00:02:25.214 --> 00:02:27.617
w.
For every edge,

00:02:27.617 --> 00:02:32.000
you get a real number.

00:02:40.000 --> 00:02:43.285
And then, if we look at the
paths in the graph,

00:02:43.285 --> 00:02:47.428
so we're going to use some
simple notation for paths called

00:02:47.428 --> 00:02:51.142
a path, p, starts at some
vertex, and it goes to some

00:02:51.142 --> 00:02:52.785
other vertex,
and so on.

00:02:52.785 --> 00:02:56.785
Say the last vertex is v_k,
and each of these should be a

00:02:56.785 --> 00:03:00.857
directed edge in the digraph.
So, this is a directed path.

00:03:00.857 --> 00:03:04.000
It has to respect edges in
here.

00:03:04.000 --> 00:03:10.033
And, we'll say that the weight
of such a path is just the sum

00:03:10.033 --> 00:03:14.256
of the weights of the edges
along the path.

00:03:14.256 --> 00:03:18.078
And, we'll call that w(p).
This is sum,

00:03:18.078 --> 00:03:23.608
i equals one to k minus one of
w(v_i, v_(i+1)) plus one.

00:03:23.608 --> 00:03:27.932
OK, so just to rub it in,
and in particular,

00:03:27.932 --> 00:03:32.156
how general this can be,
we have some path,

00:03:32.156 --> 00:03:37.787
it starts at some vertex,
there's some edge weights along

00:03:37.787 --> 00:03:42.608
the way.
This is some arbitrary path in

00:03:42.608 --> 00:03:46.000
the graph, in some hypothetical
graph.

00:03:58.000 --> 00:04:01.807
OK, this is mainly to point out
that some of the edge weights

00:04:01.807 --> 00:04:04.663
could be negative.
Some of them could be zero.

00:04:04.663 --> 00:04:08.280
This sum here is minus two.
So, the weight of this path is

00:04:08.280 --> 00:04:09.930
minus two.
And, presumably,

00:04:09.930 --> 00:04:12.088
the graph is much bigger than
this.

00:04:12.088 --> 00:04:14.246
This is just one path in the
graph.

00:04:14.246 --> 00:04:18.053
We're usually thinking about
simple paths that can't repeat a

00:04:18.053 --> 00:04:20.338
vertex.
But, sometimes we allow that.

00:04:20.338 --> 00:04:23.448
And then, what we care about is
the shortest path,

00:04:23.448 --> 00:04:26.557
or a shortest path.
Again, this may not be unique,

00:04:26.557 --> 00:04:31.000
but we'll still usually call it
the shortest path.

00:04:31.000 --> 00:04:36.084
So, we want the shortest path
from some A to some B.

00:04:36.084 --> 00:04:39.574
Or, we'll call the vertices u
and v.

00:04:39.574 --> 00:04:45.456
And we want this to be some
path of minimum possible weight,

00:04:45.456 --> 00:04:49.444
subject to starting at u,
and going to v.

00:04:49.444 --> 00:04:53.033
OK, so that's what we're
looking for.

00:04:53.033 --> 00:04:58.117
In general, give you a vertex,
u, give you a vertex,

00:04:58.117 --> 00:05:04.000
v, find a shortest path as
quickly as possible.

00:05:04.000 --> 00:05:06.801
What's a good algorithm for
that?

00:05:06.801 --> 00:05:10.653
That's the topic for the next
three lectures.

00:05:10.653 --> 00:05:15.205
We'll usually think about a
slightly simpler problem,

00:05:15.205 --> 00:05:19.319
which is just computing the
weight of that path,

00:05:19.319 --> 00:05:24.134
which is essentially computing
the distance from A to B.

00:05:24.134 --> 00:05:28.774
So, we'll call this the
shortest path weight from u to

00:05:28.774 --> 00:05:33.124
v.
And, we'll denote it by delta

00:05:33.124 --> 00:05:38.188
of (u,v), delta .
So, I mean, it's the weight of

00:05:38.188 --> 00:05:43.252
the shortest path,
or a weight of every shortest

00:05:43.252 --> 00:05:45.838
path.
Or, in other words,

00:05:45.838 --> 00:05:51.548
it's the Min over the weight of
each path from u to v.

00:05:51.548 --> 00:05:56.505
So, p here is a path.
OK, so you just consider,

00:05:56.505 --> 00:06:02.000
there could be a lot of
different paths.

00:06:02.000 --> 00:06:04.656
There could,
in principle,

00:06:04.656 --> 00:06:09.543
be infinitely many,
if you're allowed to repeat

00:06:09.543 --> 00:06:13.368
vertices.
You look at all those paths

00:06:13.368 --> 00:06:17.937
hypothetically.
You take the minimum weight.

00:06:17.937 --> 00:06:19.425
Question?
Good.

00:06:19.425 --> 00:06:25.693
My next question was going to
be, when do shortest paths not

00:06:25.693 --> 00:06:28.774
exist?
And you've hit upon one

00:06:28.774 --> 00:06:36.000
version, which is when you have
negative edge weights.

00:06:36.000 --> 00:06:40.136
So, in principle,
when you have negative edge

00:06:40.136 --> 00:06:45.683
weights, some shortest paths may
not exist in the sense that

00:06:45.683 --> 00:06:50.854
there is no shortest paths.
There are no shortest paths.

00:06:50.854 --> 00:06:54.333
There is no shortest path from
u to v.

00:06:54.333 --> 00:06:58.188
OK, in particular,
if I have two vertices,

00:06:58.188 --> 00:07:02.888
u and v, and I want the
shortest path between them,

00:07:02.888 --> 00:07:06.461
and I have negative edge
weights, well,

00:07:06.461 --> 00:07:12.548
this is fine.
I mean, I can still compute the

00:07:12.548 --> 00:07:17.355
weight of a path that has
negative weights.

00:07:17.355 --> 00:07:24.337
But when specifically won't I
have a single shortest path from

00:07:24.337 --> 00:07:26.626
u to v?
So, go ahead.

00:07:26.626 --> 00:07:29.862
Good.
So, if I can find the cycle

00:07:29.862 --> 00:07:34.206
somewhere along here whose total
weight, say, the sum of all the

00:07:34.206 --> 00:07:37.862
weights of these images is
negative, then I get there,

00:07:37.862 --> 00:07:40.275
I go around as many times as I
want.

00:07:40.275 --> 00:07:44.344
I keep decreasing the weight
because the weight is negative.

00:07:44.344 --> 00:07:48.344
I decrease it by some fixed
amount, and then I can go to v.

00:07:48.344 --> 00:07:52.275
So, as long as there is a
negative weights cycle reachable

00:07:52.275 --> 00:07:56.275
from u that can also reach v,
then there's no shortest path

00:07:56.275 --> 00:08:00.551
because if I take any particular
path, I can make it shorter by

00:08:00.551 --> 00:08:04.000
going around a couple more
times.

00:08:04.000 --> 00:08:07.219
So, in some sense,
this is not really a minimum.

00:08:07.219 --> 00:08:11.054
It's more like an infimum for
those who like to get fancy

00:08:11.054 --> 00:08:14.273
about such things.
But we'll just say that delta

00:08:14.273 --> 00:08:16.945
of (u,v) is minus infinity in
this case.

00:08:16.945 --> 00:08:19.958
There's a negative weights
cycle from u to v.

00:08:19.958 --> 00:08:23.794
So, that's one case we have to
worry about in some sense.

00:08:23.794 --> 00:08:27.287
But, as long as there are no
negative weight cycles,

00:08:27.287 --> 00:08:30.643
delta of (u,v) will be
something bigger than minus

00:08:30.643 --> 00:08:34.821
infinity, bounded below by some
finite value even if you could

00:08:34.821 --> 00:08:38.315
have negative weights,
but still no negative weights

00:08:38.315 --> 00:08:41.534
cycle for example,
there might not be any cycles

00:08:41.534 --> 00:08:45.964
in your graph.
So that's still interesting.

00:08:45.964 --> 00:08:50.035
And, I guess it's useful to
note that you can get from A to

00:08:50.035 --> 00:08:53.192
B in negative infinite time.
It's time travel,

00:08:53.192 --> 00:08:56.350
if the weights happen that
correspond to time.

00:08:56.350 --> 00:09:00.000
But when else might shortest
paths not exist?

00:09:00.000 --> 00:09:04.392
So, this is one case,
but there's another,

00:09:04.392 --> 00:09:07.821
simpler case.
It's not connected.

00:09:07.821 --> 00:09:12.000
There might not be any path
from u to v.

00:09:12.000 --> 00:09:17.892
This path might be empty.
There may be no path from u to

00:09:17.892 --> 00:09:21.000
v.
Here we have to define what

00:09:21.000 --> 00:09:25.714
happens, and here,
we'll say it's infinity if

00:09:25.714 --> 00:09:32.129
there's no path from u to v.
So, there are these exceptional

00:09:32.129 --> 00:09:35.908
cases plus infinity and minus
infinity, which are pretty

00:09:35.908 --> 00:09:39.893
intuitive because it takes a
really long time to get from u

00:09:39.893 --> 00:09:44.015
to v if there's no path there.
You can't get there from here.

00:09:44.015 --> 00:09:47.244
OK, but that's the definition.
Most of the time,

00:09:47.244 --> 00:09:50.061
this is the case we care about,
of course.

00:09:50.061 --> 00:09:53.633
Usually this is a finite set.
OK, good, so that's the

00:09:53.633 --> 00:09:56.450
definition.
We're going to get a few basic

00:09:56.450 --> 00:10:00.366
structural properties about
shortest paths that will allow

00:10:00.366 --> 00:10:04.282
us to obtain good algorithms
finding these paths when they

00:10:04.282 --> 00:10:07.357
exist.
And, in particular,

00:10:07.357 --> 00:10:10.571
we want to use ideas from
dynamic programming.

00:10:10.571 --> 00:10:14.642
So, if I want to use dynamic
programming to solve shortest

00:10:14.642 --> 00:10:17.071
paths, what do I need to
establish?

00:10:17.071 --> 00:10:19.714
What's the first thing I should
check?

00:10:19.714 --> 00:10:23.214
You've all implemented dynamic
programming by now,

00:10:23.214 --> 00:10:27.428
so should make complete sense
hopefully, at least more sense

00:10:27.428 --> 00:10:30.571
than it did a couple of weeks
ago, last week,

00:10:30.571 --> 00:10:34.813
when we learned it.
Dynamic programming is

00:10:34.813 --> 00:10:39.678
something that grows on you.
Every year I think I understand

00:10:39.678 --> 00:10:42.317
it better than the previous
year.

00:10:42.317 --> 00:10:45.862
But, in particular,
when you learned dynamic

00:10:45.862 --> 00:10:50.562
programming in this class,
there is this nice key property

00:10:50.562 --> 00:10:52.788
that you should check.
Yeah?

00:10:52.788 --> 00:10:54.932
Optimal substructure:
good.

00:10:54.932 --> 00:10:58.395
This is the phrase you should
keep in mind.

00:10:58.395 --> 00:11:03.177
It's not really enough for
dynamic programming to be useful

00:11:03.177 --> 00:11:07.300
in an efficient way,
but it at least tells you that

00:11:07.300 --> 00:11:12.000
you should be able to try to
apply it.

00:11:12.000 --> 00:11:15.866
That's a pretty weak statement,
but it's something that you

00:11:15.866 --> 00:11:18.666
should check.
It's definitely pretty much a

00:11:18.666 --> 00:11:22.466
necessary condition for dynamic
programming to make sense.

00:11:22.466 --> 00:11:26.466
And so, optimal some structure
here means that if I take some

00:11:26.466 --> 00:11:29.466
shortest path,
and I look at a subpath of that

00:11:29.466 --> 00:11:32.133
shortest path,
I claimed that it too is a

00:11:32.133 --> 00:11:34.600
shortest path,
OK, with its respective

00:11:34.600 --> 00:11:39.000
endpoints; obviously not between
the same endpoints.

00:11:39.000 --> 00:11:43.549
But if I have some shortest
path between two endpoints,

00:11:43.549 --> 00:11:47.930
I take any subpath and that's
also the shortest path.

00:11:47.930 --> 00:11:51.553
This is one version of optimal
substructure.

00:11:51.553 --> 00:11:55.260
This one turns out to be true
for this setup.

00:11:55.260 --> 00:11:59.978
And, how should I prove an
optimal substructure property?

00:11:59.978 --> 00:12:04.052
Cut and paste.
Yep, that works here too.

00:12:04.052 --> 00:12:09.143
I mean, this isn't always true.
But it's a good technique here.

00:12:09.143 --> 00:12:14.234
So, we're going to think about,
and I'll do essentially a proof

00:12:14.234 --> 00:12:17.601
by picture here.
So, suppose you have some

00:12:17.601 --> 00:12:22.527
subpath of some shortest path.
So, let's say the subpath is x

00:12:22.527 --> 00:12:25.483
to y.
And, the path goes from u to v.

00:12:25.483 --> 00:12:30.000
So, we assume that (u,v) is a
shortest path.

00:12:30.000 --> 00:12:33.480
We want to prove that (x,y) is
a shortest path.

00:12:33.480 --> 00:12:36.582
Well, suppose (x,y) isn't a
shortest path.

00:12:36.582 --> 00:12:40.593
Then there is some shorter path
that goes from x to y.

00:12:40.593 --> 00:12:45.132
But, if you have some shorter
path from x to y than this one.

00:12:45.132 --> 00:12:49.748
Then I should just erase this
part of the shortest path from u

00:12:49.748 --> 00:12:52.926
to v, and replace it with this
shorter one.

00:12:52.926 --> 00:12:56.104
So, this is some hypothetical
shorter path.

00:12:56.104 --> 00:12:59.206
So, suppose this existed.
If that existed,

00:12:59.206 --> 00:13:02.762
then I should just cut the old
path from x to y,

00:13:02.762 --> 00:13:07.000
and paste in this new one from
x to y.

00:13:07.000 --> 00:13:10.585
It's strictly shorter.
Therefore, I get a strictly

00:13:10.585 --> 00:13:14.317
shorter path from u to v.
But I assumed u to v was a

00:13:14.317 --> 00:13:16.365
shortest path:
contradiction.

00:13:16.365 --> 00:13:18.634
OK, so there is no shorter
path.

00:13:18.634 --> 00:13:21.780
And that proves the lemma that
we have this:

00:13:21.780 --> 00:13:25.073
subpaths of shortest paths are
shortest paths.

00:13:25.073 --> 00:13:29.170
OK, this should now be a pretty
familiar proof technique.

00:13:29.170 --> 00:13:34.000
But, there is yet another
instance of cut and paste.

00:13:34.000 --> 00:13:36.793
OK, so that's a good sign for
computing shortest paths.

00:13:36.793 --> 00:13:39.534
I mean, in terms of dynamic
programming, we won't look

00:13:39.534 --> 00:13:42.793
directly at dynamic programming
here because we are going to aim

00:13:42.793 --> 00:13:44.551
for greedy, which is even
stronger.

00:13:44.551 --> 00:13:47.758
But, next Monday we'll see some
dynamic programming approaches.

00:13:47.758 --> 00:13:49.879
Intuitively,
there are some pretty natural

00:13:49.879 --> 00:13:52.155
sub-problems here.
I mean, going from u to v,

00:13:52.155 --> 00:13:55.000
if I want to find what is the
shortest path from u to v,

00:13:55.000 --> 00:13:56.706
well, that's a particular
problem.

00:13:56.706 --> 00:13:59.603
Maybe it involves computing
shortest paths from u to some

00:13:59.603 --> 00:14:01.827
intermediate point,
x, and then from x to u,

00:14:01.827 --> 00:14:05.521
something like that.
That feels good.

00:14:05.521 --> 00:14:07.993
That's like,
quadratically,

00:14:07.993 --> 00:14:11.607
many subproblems.
And, V^2 subproblems,

00:14:11.607 --> 00:14:16.457
it sounds like that would lead
to a dynamic program.

00:14:16.457 --> 00:14:21.782
You can make it work out;
it's just a little bit trickier

00:14:21.782 --> 00:14:25.300
than that.
We'll see that next Monday.

00:14:25.300 --> 00:14:29.865
But thinking about this
intermediate point we get

00:14:29.865 --> 00:14:35.000
something called the triangle
inequality.

00:14:35.000 --> 00:14:40.174
So, you've probably heard some
form of the triangle inequality

00:14:40.174 --> 00:14:42.804
before.
It holds in all sorts of

00:14:42.804 --> 00:14:46.791
geometric spaces,
but it also holds for shortest

00:14:46.791 --> 00:14:51.372
paths, which is slightly less
obvious, or more obvious,

00:14:51.372 --> 00:14:54.596
I guess, depending on your
inclination.

00:14:54.596 --> 00:14:59.771
So, if you have any triple of
vertices, the shortest path from

00:14:59.771 --> 00:15:03.843
u to v is, at most,
the shortest path from u to x

00:15:03.843 --> 00:15:08.000
plus the shortest path from x to
v.

00:15:08.000 --> 00:15:10.842
Of course, here I need a
shortest path weight from u to

00:15:10.842 --> 00:15:12.894
x, and shortest path weight from
x to v.

00:15:12.894 --> 00:15:15.894
So, this should be pretty
natural just from the statement,

00:15:15.894 --> 00:15:18.052
even more natural if you draw
the picture.

00:15:18.052 --> 00:15:19.421
So, we have some vertex,
u.

00:15:19.421 --> 00:15:22.421
I'm using wiggly lines to
denote potentially long paths as

00:15:22.421 --> 00:15:24.631
opposed to edges.
We have some intermediate

00:15:24.631 --> 00:15:27.105
point, x, and we have some
target, v, and we are

00:15:27.105 --> 00:15:30.000
considering these three shortest
paths.

00:15:30.000 --> 00:15:35.198
This is the shortest path from
u to v, or this is its weights.

00:15:35.198 --> 00:15:38.352
This is the shortest path from
u to x.

00:15:38.352 --> 00:15:42.869
And here's its weight,
and the shortest path from x to

00:15:42.869 --> 00:15:44.914
v.
And here's its weight.

00:15:44.914 --> 00:15:48.750
And, the point is,
this should be the shortest

00:15:48.750 --> 00:15:51.732
path or a shortest path from u
to v.

00:15:51.732 --> 00:15:55.909
And, in particular,
one such path is you go from u

00:15:55.909 --> 00:16:00.000
to x, and then you go from x to
v.

00:16:00.000 --> 00:16:04.277
So, I mean, this sum is just
measuring the length of this

00:16:04.277 --> 00:16:07.638
particular path.
Take the shortest path here;

00:16:07.638 --> 00:16:12.145
take the shortest path here.
And, this is supposed to be the

00:16:12.145 --> 00:16:15.277
Min over all paths.
So, certainly this is,

00:16:15.277 --> 00:16:19.708
at most, this particular path,
the sum of these two values,

00:16:19.708 --> 00:16:22.381
OK, another proof by picture.
Clear?

00:16:22.381 --> 00:16:26.277
OK, this stuff is easy.
I assume we'll get into some

00:16:26.277 --> 00:16:31.090
more set exciting algorithms in
particular, which is always more

00:16:31.090 --> 00:16:36.361
exciting.
Today, we're going to look at a

00:16:36.361 --> 00:16:41.024
particular version of shortest
paths called,

00:16:41.024 --> 00:16:46.771
or the shortest paths problem
called the single source

00:16:46.771 --> 00:16:51.975
shortest path problem.
OK, it's a little bit more

00:16:51.975 --> 00:16:56.638
general than go from A to B.
The problem is,

00:16:56.638 --> 00:17:03.144
you're given a source vertex,
and you want to know how to get

00:17:03.144 --> 00:17:09.000
from that source vertex to
everywhere else.

00:17:09.000 --> 00:17:12.310
So, we'll call this source
vertex s.

00:17:12.310 --> 00:17:15.810
And from that source,
we want to find,

00:17:15.810 --> 00:17:21.013
let's say, the shortest path
weights from s to everyone.

00:17:21.013 --> 00:17:24.797
In particular,
we'd also like to know the

00:17:24.797 --> 00:17:30.000
shortest paths,
but that isn't too much harder.

00:17:30.000 --> 00:17:33.231
So, that's delta of s,
v for all vertices,

00:17:33.231 --> 00:17:35.359
v.
OK, so this is actually a

00:17:35.359 --> 00:17:39.379
little bit harder than the
problem we started with a

00:17:39.379 --> 00:17:41.980
getting from Alderon to
Cambridge.

00:17:41.980 --> 00:17:46.315
Now, we want to get from
Alderon to the entire universe.

00:17:46.315 --> 00:17:50.098
OK, it turns out,
this is one of the weird things

00:17:50.098 --> 00:17:53.014
about shortest paths,
according to the

00:17:53.014 --> 00:17:57.586
state-of-the-art we know today,
it seems like the following

00:17:57.586 --> 00:18:02.000
statement will remain true for
all time.

00:18:02.000 --> 00:18:05.516
But we don't know.
The best algorithms for solving

00:18:05.516 --> 00:18:08.100
the A to B problem,
given s, given t,

00:18:08.100 --> 00:18:11.401
go from s to t,
is no easier than this problem.

00:18:11.401 --> 00:18:15.851
It's the best ways we know how
to solve going from A to B is to

00:18:15.851 --> 00:18:18.794
solve how to go from A to
everywhere else.

00:18:18.794 --> 00:18:22.598
So, we sort of can't help
ourselves, but to solve this

00:18:22.598 --> 00:18:26.330
problem it turns out.
Today, we're going to look at a

00:18:26.330 --> 00:18:30.349
further restriction on this
problem because this is a bit

00:18:30.349 --> 00:18:34.226
tricky.
Will solve it next class.

00:18:34.226 --> 00:18:39.657
But, today we're going to get
rid of the negative weight cycle

00:18:39.657 --> 00:18:42.863
issue by forbidding negative
weights.

00:18:42.863 --> 00:18:47.938
So, we're going to assume that
all of the edge weights are

00:18:47.938 --> 00:18:50.876
nonnegative, so,
for all vertices,

00:18:50.876 --> 00:18:53.191
u and v.
So, in particular,

00:18:53.191 --> 00:18:58.000
shortest paths exist,
provided paths exist.

00:19:12.000 --> 00:19:15.371
And, we don't have to worry
about these minus infinities.

00:19:15.371 --> 00:19:18.441
Delta of (u,v) is always bigger
than minus infinity.

00:19:18.441 --> 00:19:21.511
It still might be plus infinity
if there is no path,

00:19:21.511 --> 00:19:23.678
but this will make life a lot
easier.

00:19:23.678 --> 00:19:26.989
And the algorithm we'll cover
today really requires this

00:19:26.989 --> 00:19:30.000
property.
You can't get away without it.

00:19:30.000 --> 00:19:36.599
Next class, we'll get away
without it with a fancier and

00:19:36.599 --> 00:19:40.920
slower algorithm.
So, as I hinted at,

00:19:40.920 --> 00:19:47.880
the main idea we're going to
use for the algorithm today is

00:19:47.880 --> 00:19:54.359
greedy, which should be faster
than dynamic programming

00:19:54.359 --> 00:19:58.920
generally.
And, the tricky part will be

00:19:58.920 --> 00:20:06.000
proving that the greedy
algorithm actually works.

00:20:06.000 --> 00:20:11.119
So, I think there's pretty much
only one natural way to go

00:20:11.119 --> 00:20:16.329
about, well, there's one way
that works to go about greedy,

00:20:16.329 --> 00:20:19.652
let's say.
This may be not the obvious

00:20:19.652 --> 00:20:22.526
one.
So, let me give you a little

00:20:22.526 --> 00:20:26.299
bit of setup.
The invariant we are going to

00:20:26.299 --> 00:20:31.149
maintain is that at all times,
we have estimates on the

00:20:31.149 --> 00:20:36.000
distances from the source to
every vertex.

00:20:36.000 --> 00:20:39.414
When I say distance,
I mean shortest path weight.

00:20:39.414 --> 00:20:43.397
I'm going to use weight and
distance interchangeably here

00:20:43.397 --> 00:20:46.100
for more intuition.
And, in particular,

00:20:46.100 --> 00:20:50.297
I want to maintain the set of
vertices where those estimates

00:20:50.297 --> 00:20:53.000
are actually the right answer.

00:21:10.000 --> 00:21:13.127
OK, this is little s.
This is big S.

00:21:13.127 --> 00:21:18.578
So, the big S will be the set
of all vertices where I know the

00:21:18.578 --> 00:21:21.438
answer.
What is the shortest path

00:21:21.438 --> 00:21:25.548
distance from little S to that
vertex in big S?

00:21:25.548 --> 00:21:29.302
So, for starters,
which distance do I know?

00:21:29.302 --> 00:21:31.000
Sorry?
s.

00:21:31.000 --> 00:21:34.482
I know the shortest path
distance from s to s because if

00:21:34.482 --> 00:21:37.458
I assume that all of my weights
are nonnegative,

00:21:37.458 --> 00:21:40.941
I really can't get from s to s
any faster than not doing

00:21:40.941 --> 00:21:43.410
anything.
OK, if I had a negative weight

00:21:43.410 --> 00:21:46.893
cycle, maybe the distance from s
to s is minus infinity.

00:21:46.893 --> 00:21:50.692
OK, but I can't have negative
weights so there's no way I can

00:21:50.692 --> 00:21:53.288
get from s to s any faster than
zero time.

00:21:53.288 --> 00:21:56.644
There might be a longer path
that still has zero cost,

00:21:56.644 --> 00:22:00.000
but it can't be any better than
zero.

00:22:00.000 --> 00:22:02.448
So, in particular,
I know that.

00:22:02.448 --> 00:22:05.224
So, initially,
S is certainly an s.

00:22:05.224 --> 00:22:09.959
OK, and the idea is we're going
to accumulate more and more

00:22:09.959 --> 00:22:14.122
vertices that we know.
So, at some point we know the

00:22:14.122 --> 00:22:16.979
distances from some of the
vertices.

00:22:16.979 --> 00:22:21.061
So, we have some cloud here.
This is S, and this is

00:22:21.061 --> 00:22:23.836
everything else.
This is the graph,

00:22:23.836 --> 00:22:26.040
G.
This is the subset of the

00:22:26.040 --> 00:22:29.306
vertices.
And, there's some edges that go

00:22:29.306 --> 00:22:33.694
out from there.
And, so we have estimates on

00:22:33.694 --> 00:22:36.235
how to get to these vertices.
Some of them,

00:22:36.235 --> 00:22:39.744
we may not have even seen yet.
They may not be connected to

00:22:39.744 --> 00:22:42.104
this portion of S.
I mean: not directly.

00:22:42.104 --> 00:22:44.705
They might be connected by some
longer path.

00:22:44.705 --> 00:22:48.275
They might be in a completely
different connected component.

00:22:48.275 --> 00:22:50.151
We don't know yet.
Some of them,

00:22:50.151 --> 00:22:53.660
we have estimates for because
we've sort of seen how to get

00:22:53.660 --> 00:22:55.415
there from S.
And the idea is,

00:22:55.415 --> 00:22:58.319
among all of these nodes where
we have estimates,

00:22:58.319 --> 00:23:01.768
and on to get from little S,
which is some vertex in here,

00:23:01.768 --> 00:23:04.732
to these vertices,
we're going to take the one for

00:23:04.732 --> 00:23:10.666
which the estimate is smallest.
That's the greedy choice.

00:23:10.666 --> 00:23:15.466
And, we're just going to add
that vertex to S.

00:23:15.466 --> 00:23:18.773
So, S grows one vertex per
step.

00:23:18.773 --> 00:23:23.680
Each step, we're going to add
to S, the vertex.

00:23:23.680 --> 00:23:27.733
Of course, again,
this is not a unique,

00:23:27.733 --> 00:23:32.000
it's a vertex,
v, in V minus S.

00:23:32.000 --> 00:23:39.981
So, it's something we haven't
yet computed yet whose estimated

00:23:39.981 --> 00:23:47.570
distance from S is minimum.
So, we look at all the vertices

00:23:47.570 --> 00:23:55.028
we haven't yet added to S.
Just take the one where we have

00:23:55.028 --> 00:24:01.320
the estimated smallest distance.
The intuition is that that

00:24:01.320 --> 00:24:03.961
should be a good choice.
So, if I pick the one that's

00:24:03.961 --> 00:24:06.653
closest to little s among all
the ones that I've seen,

00:24:06.653 --> 00:24:09.752
among all the paths that I've
seen, I sort of have to buy into

00:24:09.752 --> 00:24:11.682
that those are good paths.
But, I mean,

00:24:11.682 --> 00:24:13.511
maybe there's some path I
didn't see.

00:24:13.511 --> 00:24:16.558
Maybe you go out to here and
then you take some other path to

00:24:16.558 --> 00:24:18.438
some vertex, which we've already
seen.

00:24:18.438 --> 00:24:20.774
OK, the worry is,
well, I'd better not say that

00:24:20.774 --> 00:24:23.923
that's the shortest path because
there may have been some other

00:24:23.923 --> 00:24:25.955
way to get there.
Right, as soon as I add

00:24:25.955 --> 00:24:27.987
something to S,
I declare I've solved the

00:24:27.987 --> 00:24:32.000
problem for that vertex.
I can't change my answer later.

00:24:32.000 --> 00:24:35.857
OK, the estimates can change
until they get added to S.

00:24:35.857 --> 00:24:39.928
So, I don't want to add this
vertex to S because I haven't

00:24:39.928 --> 00:24:43.357
considered this path.
Well, if all my weights are

00:24:43.357 --> 00:24:47.000
nonnegative, and I take the
vertex here that has the

00:24:47.000 --> 00:24:50.785
shortest estimate from S,
so let's suppose this one is

00:24:50.785 --> 00:24:54.000
the shortest one,
then this can't be a shorter

00:24:54.000 --> 00:24:57.142
path because the distance
estimate, at least,

00:24:57.142 --> 00:25:02.000
from S to that vertex is larger
from S to that vertex.

00:25:02.000 --> 00:25:05.427
So, no way can I make the path
longer and decrease the

00:25:05.427 --> 00:25:07.367
distance.
That's the intuition.

00:25:07.367 --> 00:25:10.988
OK, it's a little bit fuzzy
here because I don't have any

00:25:10.988 --> 00:25:14.803
induction hypotheses set up,
and it's going to be a lot more

00:25:14.803 --> 00:25:17.842
work to prove that.
But that's the intuition why

00:25:17.842 --> 00:25:21.787
this is the right thing to do.
OK, you have to prove something

00:25:21.787 --> 00:25:25.085
about the distance estimates for
that to be a proof.

00:25:25.085 --> 00:25:27.090
But, intuitively,
it feels good.

00:25:27.090 --> 00:25:32.081
It was a good starting point.
OK, and then presumably we have

00:25:32.081 --> 00:25:34.499
to maintain these distance
estimates.

00:25:34.499 --> 00:25:38.595
So, the heart of the algorithm
is updating distance estimates,

00:25:38.595 --> 00:25:41.549
I mean, choosing the best
vertex to add to S,

00:25:41.549 --> 00:25:44.437
that's one step.
Then, updating the distance

00:25:44.437 --> 00:25:46.989
estimates is sort of where the
work is.

00:25:46.989 --> 00:25:50.413
And, it turns out we'll only
need to update distance

00:25:50.413 --> 00:25:53.838
estimates of some of the
vertices, the ones that are

00:25:53.838 --> 00:25:56.793
adjacent to v.
v was the vertex we just added

00:25:56.793 --> 00:25:59.143
to S.
So, once we add somebody to S,

00:25:59.143 --> 00:26:02.903
so we grow S by a little bit,
then we look at all the new

00:26:02.903 --> 00:26:07.000
edges that go out of S from that
vertex.

00:26:07.000 --> 00:26:14.200
We update something.
That's the idea.

00:26:14.200 --> 00:26:24.799
So, that's the idea for how
we're going to use greedy.

00:26:24.799 --> 00:26:32.000
Now I'll give you the
algorithm.

00:26:32.000 --> 00:26:40.136
So, this is called Dijkstra's
algorithm.

00:26:40.136 --> 00:26:47.438
Dijkstra is a famous,
recently late,

00:26:47.438 --> 00:26:57.244
if that makes sense,
computer scientist from the

00:26:57.244 --> 00:27:04.680
Netherlands.
And, this is probably the

00:27:04.680 --> 00:27:12.923
algorithm he is most famous for.
So, the beginning of the

00:27:12.923 --> 00:27:18.370
algorithm is just some
initialization,

00:27:18.370 --> 00:27:24.994
not too exciting.
OK, but let me tell you what

00:27:24.994 --> 00:27:34.586
some of the variables mean.
OK, so d is some array indexed

00:27:34.586 --> 00:27:42.995
by vertices, and the idea is
that d of x is the distance

00:27:42.995 --> 00:27:47.735
estimate for x,
so, from S to x.

00:27:47.735 --> 00:27:54.615
so in particular,
it's going to equal the real

00:27:54.615 --> 00:28:03.942
shortest path weight from S to x
when we've added x to our set

00:28:03.942 --> 00:28:07.793
capital, S.
OK, so this is,

00:28:07.793 --> 00:28:10.067
in particular,
going to be the output to the

00:28:10.067 --> 00:28:11.865
algorithm.
Did you have a question?

00:28:11.865 --> 00:28:13.610
Or were you just stretching?
Good.

00:28:13.610 --> 00:28:15.250
So, in d of x,
when we are done,

00:28:15.250 --> 00:28:17.259
d of x is the output.
For every vertex,

00:28:17.259 --> 00:28:20.168
it's going to give us the
shortest path weight from S to

00:28:20.168 --> 00:28:21.543
that vertex.
Along the way,

00:28:21.543 --> 00:28:24.822
it's going to be some estimated
distance from S to that vertex.

00:28:24.822 --> 00:28:26.937
And, we're going to improve it
over time.

00:28:26.937 --> 00:28:29.735
This is an infinity.
So initially,

00:28:29.735 --> 00:28:32.903
we know that the distance,
we know the distance from S to

00:28:32.903 --> 00:28:35.166
S is zero.
So, we're going to set that to

00:28:35.166 --> 00:28:37.541
be our estimate.
It's going to be accurate.

00:28:37.541 --> 00:28:40.992
Everything else we're going to
just set to infinity because we

00:28:40.992 --> 00:28:43.255
may not be connected.
From the beginning,

00:28:43.255 --> 00:28:45.065
we don't know much.
S, initially,

00:28:45.065 --> 00:28:47.102
is going to be infinity.
Immediately,

00:28:47.102 --> 00:28:49.138
we're going to add little s to
big S.

00:28:49.138 --> 00:28:52.419
And then, the interesting part
here is Q, which is going to

00:28:52.419 --> 00:28:55.304
consist of, initially all the
vertices in the graph.

00:28:55.304 --> 00:29:00.000
And, it's going to not just be
a queue as the letter suggests.

00:29:00.000 --> 00:29:03.299
It's going to be a priority
queue.

00:29:03.299 --> 00:29:07.400
So, it's going to maintain,
in particular,

00:29:07.400 --> 00:29:12.400
the vertex that has the
smallest distance estimate.

00:29:12.400 --> 00:29:17.900
So, this is a priority queue.
This is really an abuse of

00:29:17.900 --> 00:29:23.900
notation for a data structure.
OK, so this could be a heap or

00:29:23.900 --> 00:29:27.599
whatever.
The vertices are keyed on d,

00:29:27.599 --> 00:29:32.314
our distance estimate.
So, in particular,

00:29:32.314 --> 00:29:35.748
S will have the,
this is going to be a Min heap.

00:29:35.748 --> 00:29:38.450
S will be the guy who has the
minimum.

00:29:38.450 --> 00:29:41.372
Everyone else has the same key
initially.

00:29:41.372 --> 00:29:45.901
And, we're going to repeatedly
extract the minimum element from

00:29:45.901 --> 00:29:50.357
this queue and do other things.
OK, so this is initialization.

00:29:50.357 --> 00:29:53.352
OK, I'm going to call that
initialization.

00:29:53.352 --> 00:29:57.224
It's a pretty simple thing.
It just takes linear time,

00:29:57.224 --> 00:30:02.686
nothing fancy going on.
The heart of the algorithm is

00:30:02.686 --> 00:30:06.856
all in six lines.
And, so this is not really a

00:30:06.856 --> 00:30:09.821
step.
The first step here that we

00:30:09.821 --> 00:30:15.194
need to do is we take the vertex
whose distance estimate is

00:30:15.194 --> 00:30:17.974
minimum.
So that, among all the

00:30:17.974 --> 00:30:21.958
vertices, not yet,
and that's currently S is

00:30:21.958 --> 00:30:23.904
empty.
Q has everyone.

00:30:23.904 --> 00:30:29.000
In general, Q will have
everyone except S.

00:30:29.000 --> 00:30:33.754
So, we'll take the vertex,
u, that has the minimum key in

00:30:33.754 --> 00:30:38.000
that priority queue.
So, extract the Min from Q.

00:30:48.000 --> 00:31:02.645
OK.
We're going to add a little u

00:31:02.645 --> 00:31:07.753
to S, claim that that is now,
I mean, that's exactly what

00:31:07.753 --> 00:31:11.949
we're saying here.
We add to S that vertex that

00:31:11.949 --> 00:31:17.422
has minimum distance estimate.
And now, we need to update the

00:31:17.422 --> 00:31:21.162
distances.
So, we're going to look at each

00:31:21.162 --> 00:31:27.000
adjacent vertex for each v in
the adjacency list for u.

00:31:27.000 --> 00:31:30.000
We look at a few distances.

00:31:47.000 --> 00:31:49.812
So that's the algorithm or more
or less.

00:31:49.812 --> 00:31:53.201
This is the key.
I should define it a little bit

00:31:53.201 --> 00:31:56.302
what's going on here.
We talked mainly about

00:31:56.302 --> 00:32:00.125
undirected graph last time.
Here, we're thinking about

00:32:00.125 --> 00:32:03.819
undirected graphs.
And, the adjacency list for u

00:32:03.819 --> 00:32:07.269
here is just going to mean,
give me all the vertices for

00:32:07.269 --> 00:32:09.402
which there is an edge from u to
v.

00:32:09.402 --> 00:32:11.848
So, this is the outgoing
adjacency list,

00:32:11.848 --> 00:32:13.793
not the incoming adjacency
list.

00:32:13.793 --> 00:32:16.177
Undirected graphs:
you list everything.

00:32:16.177 --> 00:32:19.062
Directed graphs:
here, we're only going to care

00:32:19.062 --> 00:32:21.321
about those ones.
So, for every edge,

00:32:21.321 --> 00:32:24.896
(u,v), is what this is saying,
we are going to compare the

00:32:24.896 --> 00:32:28.095
current estimate for v,
and this candidate estimate,

00:32:28.095 --> 00:32:30.730
which intuitively means you go
from s to u.

00:32:30.730 --> 00:32:34.118
That's d of u because we now
know that that's the right

00:32:34.118 --> 00:32:37.002
answer.
This, in fact,

00:32:37.002 --> 00:32:39.938
equals, we hope,
assuming the algorithm is

00:32:39.938 --> 00:32:44.163
correct, this should be the
shortest path weight from s to u

00:32:44.163 --> 00:32:48.317
because we just added u to S.
And whenever we add something

00:32:48.317 --> 00:32:50.895
to S, it should have the right
value.

00:32:50.895 --> 00:32:54.046
So, we could say,
well, you take the shortest

00:32:54.046 --> 00:32:57.340
path from S to u,
and then you follow this edge

00:32:57.340 --> 00:32:59.345
from u to v.
That has weight,

00:32:59.345 --> 00:33:02.424
w, of (u,v).
That's one possible path from S

00:33:02.424 --> 00:33:05.979
to v.
And, if that's a shorter path

00:33:05.979 --> 00:33:09.118
than the one we currently have
in our estimate,

00:33:09.118 --> 00:33:12.803
if this is smaller than that,
then we should update the

00:33:12.803 --> 00:33:16.351
estimate to be that sum because
that's a better path,

00:33:16.351 --> 00:33:19.627
so, add it to our database of
paths, so to speak:

00:33:19.627 --> 00:33:23.653
OK, very intuitive operation;
clearly should not do anything

00:33:23.653 --> 00:33:25.905
bad.
I mean, these should be paths

00:33:25.905 --> 00:33:30.000
that makes sense.
We'll prove that in a moment.

00:33:30.000 --> 00:33:33.909
That's the first part of
correctness, that this never

00:33:33.909 --> 00:33:36.992
screws up.
And then, the tricky part is to

00:33:36.992 --> 00:33:40.827
show that it finds all the paths
that we care about.

00:33:40.827 --> 00:33:43.609
This step is called a
relaxation step.

00:33:43.609 --> 00:33:47.593
Relaxation is always a
difficult technique to teach to

00:33:47.593 --> 00:33:50.902
MIT students.
It doesn't come very naturally.

00:33:50.902 --> 00:33:55.187
But it's very simple operation.
It comes from optimization

00:33:55.187 --> 00:34:00.000
terminology, programming
terminology, so to speak.

00:34:00.000 --> 00:34:04.188
And, does this inequality look
familiar at all especially when

00:34:04.188 --> 00:34:08.376
you start writing it this way?
You say, the shortest path from

00:34:08.376 --> 00:34:12.427
S to v and the shortest path
from S to u in some edge from u

00:34:12.427 --> 00:34:15.517
to v, does that look like
anything we've seen?

00:34:15.517 --> 00:34:18.950
In fact, it was on this board
but I just erased it.

00:34:18.950 --> 00:34:20.667
Triangle inequality,
yeah.

00:34:20.667 --> 00:34:24.443
So, this is trying to make the
triangle inequality true.

00:34:24.443 --> 00:34:28.494
Certainly, the shortest path
from S to v should be less than

00:34:28.494 --> 00:34:32.614
or equal to, not greater than.
The shortest path from S to u,

00:34:32.614 --> 00:34:36.665
plus whatever path from u to v,
the shortest path should be,

00:34:36.665 --> 00:34:40.574
at most, that.
So, this is sort of a somewhat

00:34:40.574 --> 00:34:42.255
more general triangle
inequality.

00:34:42.255 --> 00:34:44.565
And, we want to,
certainly it should be true.

00:34:44.565 --> 00:34:46.192
So, if it's not true,
we fix it.

00:34:46.192 --> 00:34:48.187
If it's greater than,
we make it equal.

00:34:48.187 --> 00:34:51.127
But we don't want to make it
less than because that's not

00:34:51.127 --> 00:34:52.702
always true.
OK, but certainly,

00:34:52.702 --> 00:34:54.487
it should be less than or equal
to.

00:34:54.487 --> 00:34:56.692
So, this is fixing the triangle
inequality.

00:34:56.692 --> 00:35:00.000
It's trying to make that
constraint more true.

00:35:00.000 --> 00:35:03.490
In optimization,
that's called relaxing the

00:35:03.490 --> 00:35:06.814
constraint.
OK, so we're sort of relaxing

00:35:06.814 --> 00:35:11.717
the triangle inequality here.
In the end, we should have all

00:35:11.717 --> 00:35:14.542
the shortest paths.
That's a claim.

00:35:14.542 --> 00:35:19.196
So: a very simple algorithm.
Let's try it out on a graph,

00:35:19.196 --> 00:35:23.767
and that should make it more
intuitive why it's working,

00:35:23.767 --> 00:35:28.337
and that the rest of the
lecture will be proving that it

00:35:28.337 --> 00:35:32.269
works.
Yeah, this is enough room.

00:35:32.269 --> 00:35:36.197
So, oh, I should mention one
other thing here.

00:35:36.197 --> 00:35:38.990
Sorry.
Whenever we change d of v,

00:35:38.990 --> 00:35:43.441
this is changing the key of v
in the priority queue.

00:35:43.441 --> 00:35:48.241
So, implicitly what's happening
here in this assignment,

00:35:48.241 --> 00:35:53.216
this is getting a bit messy,
is a decreased key operation,

00:35:53.216 --> 00:35:58.279
OK, which we talked briefly
about last class in the context

00:35:58.279 --> 00:36:05.000
of minimum spanning trees where
we were also decreasing the key.

00:36:05.000 --> 00:36:08.496
The point is we were changing
the key of one element industry

00:36:08.496 --> 00:36:11.759
like station step in the
priority queue so that if it now

00:36:11.759 --> 00:36:14.265
becomes the minimum,
we should extract here.

00:36:14.265 --> 00:36:17.237
And, we are only ever
decreasing keys because we are

00:36:17.237 --> 00:36:20.151
always replacing larger values
with smaller values.

00:36:20.151 --> 00:36:23.181
So, we'll come back to that
later when we analyze the

00:36:23.181 --> 00:36:25.279
running time.
But, there is some data

00:36:25.279 --> 00:36:28.717
structure work going on here.
Again, we are abusing notation

00:36:28.717 --> 00:36:33.951
a bit.
OK, so here is a graph with

00:36:33.951 --> 00:36:36.000
edge weights.

00:37:06.000 --> 00:37:10.148
OK, and I want my priority
queue over here.

00:37:10.148 --> 00:37:14.098
And, I'm also going to draw my
estimates.

00:37:14.098 --> 00:37:19.629
OK, now I don't want to cheat.
So, we're going to run the

00:37:19.629 --> 00:37:23.185
algorithm on this graph.
s will be A,

00:37:23.185 --> 00:37:30.000
and I want to know the shortest
path from A to everyone else.

00:37:30.000 --> 00:37:32.094
So, you can check,
OK, paths exist.

00:37:32.094 --> 00:37:35.727
So, hopefully everything should
end up a finite value by the

00:37:35.727 --> 00:37:37.144
end.
All the weights are

00:37:37.144 --> 00:37:39.730
nonnegative, so this algorithm
should work.

00:37:39.730 --> 00:37:42.440
The algorithm doesn't even need
connectivity,

00:37:42.440 --> 00:37:45.705
but it does mean that all the
weights are nonnegative.

00:37:45.705 --> 00:37:48.661
So, we run the algorithm.
For the initialization,

00:37:48.661 --> 00:37:51.925
we set the distance estimate
for our source to be zero

00:37:51.925 --> 00:37:54.881
because, in fact,
there's only one path from A to

00:37:54.881 --> 00:37:57.406
A, and that to do nothing,
the empty path.

00:37:57.406 --> 00:38:00.239
So, I'm going to put the key of
zero over here.

00:38:00.239 --> 00:38:03.072
And, for everyone else,
we're just going to put

00:38:03.072 --> 00:38:08.000
infinity because we don't know
any better at this point.

00:38:08.000 --> 00:38:11.251
So, I'll put keys of infinity
for everyone else.

00:38:11.251 --> 00:38:15.402
OK, so now you can see what the
algorithm does is extract the

00:38:15.402 --> 00:38:18.446
minimum from the queue.
And, given our setup,

00:38:18.446 --> 00:38:21.352
we'll definitely choose s,
or in this case,

00:38:21.352 --> 00:38:23.427
A.
So, it has a weight of zero.

00:38:23.427 --> 00:38:26.402
Everyone else has quite a bit
larger weight.

00:38:26.402 --> 00:38:30.000
OK, so we look at s,
or I'll use A here.

00:38:30.000 --> 00:38:32.030
So, we look at A.
We add A to our set,

00:38:32.030 --> 00:38:33.732
S.
So, it's now removed from the

00:38:33.732 --> 00:38:35.379
queue.
It will never go back in

00:38:35.379 --> 00:38:38.727
because we never add anything to
the queue, start with all the

00:38:38.727 --> 00:38:40.922
vertices, and extract,
and decrease keys.

00:38:40.922 --> 00:38:42.789
But we never insert.
So, A is gone.

00:38:42.789 --> 00:38:45.862
OK, and now I want to update
the keys of all of the other

00:38:45.862 --> 00:38:48.058
vertices.
And the claim is I only need to

00:38:48.058 --> 00:38:50.418
look at the vertices that have
edges from A.

00:38:50.418 --> 00:38:53.492
So, there's an edge from A to
B, and that has weight ten.

00:38:53.492 --> 00:38:56.072
And so, I compare:
well, is it a good idea to go

00:38:56.072 --> 00:38:58.981
from A to A, which costs
nothing, and then to go along

00:38:58.981 --> 00:39:02.000
this edge, AB,
which costs ten?

00:39:02.000 --> 00:39:06.143
Well, it seems like a pretty
good idea because that has a

00:39:06.143 --> 00:39:09.324
total weight of zero plus ten,
which is ten,

00:39:09.324 --> 00:39:11.914
which is much smaller than
infinity.

00:39:11.914 --> 00:39:15.391
So, I'm going to erase this
infinity; write ten,

00:39:15.391 --> 00:39:19.386
and over in the queue as well.
That's the decreased key

00:39:19.386 --> 00:39:22.420
operation.
So now, I know a path from A to

00:39:22.420 --> 00:39:22.937
B.
Good.

00:39:22.937 --> 00:39:27.229
A to C is the only other edge.
Zero plus three is less than

00:39:27.229 --> 00:39:28.560
infinity, so,
cool.

00:39:28.560 --> 00:39:33.000
I'll put three here for C,
and C is there.

00:39:33.000 --> 00:39:35.113
OK, the other vertices I don't
touch.

00:39:35.113 --> 00:39:38.694
I'm going to rewrite them here,
but the algorithm doesn't have

00:39:38.694 --> 00:39:41.219
to copy them.
Those keys were already there.

00:39:41.219 --> 00:39:44.506
It's just touching these two.
OK, that was pretty boring.

00:39:44.506 --> 00:39:47.500
Now we look at our queue,
and we extract the minimum

00:39:47.500 --> 00:39:49.614
element.
So, A is no longer in there,

00:39:49.614 --> 00:39:51.493
so the minimum key here is
three.

00:39:51.493 --> 00:39:54.135
So, the claim is that this is a
shortest path;

00:39:54.135 --> 00:39:56.600
from A to C,
here is the shortest path from

00:39:56.600 --> 00:39:58.714
A to C.
There's no other shorter way.

00:39:58.714 --> 00:40:03.000
You could check that,
and we'll prove it in a moment.

00:40:03.000 --> 00:40:05.240
Cool, so we'll remove C from
the list.

00:40:05.240 --> 00:40:07.419
It's gone.
Then we look at all of the

00:40:07.419 --> 00:40:10.628
outgoing edges from C.
So, there's one that goes up to

00:40:10.628 --> 00:40:13.111
B, which has weight four,
four plus three,

00:40:13.111 --> 00:40:15.835
which is the shortest path
weight from A to C.

00:40:15.835 --> 00:40:18.863
So, going from A to C,
and C to B should cost three

00:40:18.863 --> 00:40:21.830
plus four, which is seven,
which is less than ten.

00:40:21.830 --> 00:40:24.494
So, we found an even better
path to get to B.

00:40:24.494 --> 00:40:27.763
It's better to go like this
than it is to go like that.

00:40:27.763 --> 00:40:30.972
So, we write seven for B,
and there's an outgoing edge

00:40:30.972 --> 00:40:35.611
from C to d which costs eight.
Three plus eight is 11.

00:40:35.611 --> 00:40:38.693
11 is less than infinity last
time I checked.

00:40:38.693 --> 00:40:41.495
So, we write 11 for d.
Then we look at E.

00:40:41.495 --> 00:40:45.628
We have three plus two is five,
which is less than infinity.

00:40:45.628 --> 00:40:48.359
So, we write five for the new
key for E.

00:40:48.359 --> 00:40:51.371
At this point,
we have finite shortest paths

00:40:51.371 --> 00:40:54.314
to everywhere,
but they may not be the best

00:40:54.314 --> 00:40:56.625
ones.
So, we have to keep looking.

00:40:56.625 --> 00:40:59.847
OK, next round of the
algorithm, we extract the

00:40:59.847 --> 00:41:04.030
minimum key among all these.
OK, it's not B,

00:41:04.030 --> 00:41:07.535
which we've seen though
probably know the answer to.

00:41:07.535 --> 00:41:09.872
But it's E.
E has the smallest key.

00:41:09.872 --> 00:41:12.964
So, we now declare this to be a
shortest path.

00:41:12.964 --> 00:41:16.194
The way we got to E was along
this path: A to C,

00:41:16.194 --> 00:41:18.599
C to E, declare that to be
shortest.

00:41:18.599 --> 00:41:22.379
We claim we're done with E.
But we still have to update.

00:41:22.379 --> 00:41:25.127
What about all the outgoing
edges from E?

00:41:25.127 --> 00:41:28.289
There's only one here.
It costs five plus nine,

00:41:28.289 --> 00:41:32.000
which is 14,
which is bigger than 11.

00:41:32.000 --> 00:41:34.851
So, no go.
That's not an interesting path.

00:41:34.851 --> 00:41:38.189
Our previous path,
which went like this at a cost

00:41:38.189 --> 00:41:42.083
of the 11, is better than the
one we are considering now.

00:41:42.083 --> 00:41:45.700
I'm drawing the whole path,
but the algorithm is only

00:41:45.700 --> 00:41:48.064
adding these two numbers.
OK, good.

00:41:48.064 --> 00:41:52.167
So, I don't change anything.
Seven, 11, and five is removed,

00:41:52.167 --> 00:41:55.366
or E is removed.
Our new keys are seven and 11.

00:41:55.366 --> 00:41:57.592
So, we take the key,
seven, here,

00:41:57.592 --> 00:42:01.000
which is for element B,
vertex B.

00:42:01.000 --> 00:42:04.316
We declare the path we
currently have in our hands from

00:42:04.316 --> 00:42:06.527
A to B, which happens to be this
one.

00:42:06.527 --> 00:42:09.352
Algorithm can't actually tell
this, by the way,

00:42:09.352 --> 00:42:11.870
but we're drawing it anyway.
This path, A,

00:42:11.870 --> 00:42:14.081
C, B, is the candidate shortest
path.

00:42:14.081 --> 00:42:16.170
The claim is it is indeed
shortest.

00:42:16.170 --> 00:42:18.503
Now, we look at all the
outgoing edges.

00:42:18.503 --> 00:42:22.127
There's one that goes back to C
at a cost of seven plus one,

00:42:22.127 --> 00:42:24.707
which is eight,
which is bigger than three,

00:42:24.707 --> 00:42:27.225
which is good.
We already declared C to be

00:42:27.225 --> 00:42:29.313
done.
But the algorithm checks this

00:42:29.313 --> 00:42:31.462
path and says,
oh, that's no better.

00:42:31.462 --> 00:42:34.349
And then we look at this other
edge from B to d.

00:42:34.349 --> 00:42:36.806
That costs seven plus two,
which is nine,

00:42:36.806 --> 00:42:41.359
which is better than 11.
So, we, in fact,

00:42:41.359 --> 00:42:46.115
found an even shorter path.
So, the shortest path weight,

00:42:46.115 --> 00:42:51.042
now, for d, is nine because
there is this path that goes A,

00:42:51.042 --> 00:42:55.629
C, B, d for a total cost of
three plus four plus two is

00:42:55.629 --> 00:42:58.262
nine.
Cool, now there's only one

00:42:58.262 --> 00:43:02.000
element in the queue.
We remove it.

00:43:02.000 --> 00:43:04.059
d: we look at the outgoing
edges.

00:43:04.059 --> 00:43:07.278
There's one going here which
costs nine plus seven,

00:43:07.278 --> 00:43:09.981
which is 16,
which is way bigger than five.

00:43:09.981 --> 00:43:12.105
So, we're done.
Don't do anything.

00:43:12.105 --> 00:43:14.229
At this point,
the queue is empty.

00:43:14.229 --> 00:43:18.156
And the claim is that all these
numbers that are written here,

00:43:18.156 --> 00:43:21.117
the final values are the
shortest path weights.

00:43:21.117 --> 00:43:24.335
This looks an awful lot like a
five, but it's an s.

00:43:24.335 --> 00:43:27.875
It has a weight of zero.
I've also drawn in here all the

00:43:27.875 --> 00:43:31.562
shortest paths.
And, this is not hard to do.

00:43:31.562 --> 00:43:34.631
We're not going to talk about
it too much in this class,

00:43:34.631 --> 00:43:37.924
but it's mentioned in a little
bit more detail at the end of

00:43:37.924 --> 00:43:40.267
the textbook.
And it's something called the

00:43:40.267 --> 00:43:42.834
shortest path tree.
It's just something good to

00:43:42.834 --> 00:43:46.015
know about if you actually want
to compute shortest paths.

00:43:46.015 --> 00:43:48.191
In this class,
we mainly worry about the

00:43:48.191 --> 00:43:50.926
weights because it's pretty much
the same problem.

00:43:50.926 --> 00:43:55.000
The shortest path tree is the
union of all shortest paths.

00:43:55.000 --> 00:43:58.944
And in particular,
if you look at each vertex in

00:43:58.944 --> 00:44:04.148
your graph, if you consider the
last edge into that vertex that

00:44:04.148 --> 00:44:08.848
was relaxed among all vertices,
u, you look at the edges,

00:44:08.848 --> 00:44:12.038
(u,v), say, was that last one
to relax?

00:44:12.038 --> 00:44:15.983
So, just look at the last edges
we relaxed here.

00:44:15.983 --> 00:44:20.599
You put them all together:
that's called a shortest path

00:44:20.599 --> 00:44:23.453
tree.
And, it has the property that

00:44:23.453 --> 00:44:28.237
from S to everywhere else,
there is a unique path down the

00:44:28.237 --> 00:44:31.735
tree.
And it's the shortest path.

00:44:31.735 --> 00:44:34.048
It's the shortest path that we
found.

00:44:34.048 --> 00:44:37.197
OK, so you actually get
shortest paths out of this

00:44:37.197 --> 00:44:40.475
algorithm even though it's not
explicitly described.

00:44:40.475 --> 00:44:44.395
All we are mainly talking about
are the shortest path weights.

00:44:44.395 --> 00:44:48.316
Algorithm clear at this point?
Feels like it's doing the right

00:44:48.316 --> 00:44:50.694
thing?
You can check all those numbers

00:44:50.694 --> 00:44:53.714
are the best paths.
And now we're going to prove

00:44:53.714 --> 00:44:55.000
that.

00:45:12.000 --> 00:45:15.000
So: correctness.

00:45:25.000 --> 00:45:31.035
So the first thing I want to
prove is that relaxation never

00:45:31.035 --> 00:45:35.614
makes a mistake.
If it ever sets d of v to be

00:45:35.614 --> 00:45:42.065
something, I want to prove that
d of v is always an upper bound

00:45:42.065 --> 00:45:45.604
on delta.
So, we have this variant.

00:45:45.604 --> 00:45:51.119
It's greater than or equal to
delta of s, v for all v.

00:45:51.119 --> 00:45:55.073
And, this invariant holds at
all times.

00:45:55.073 --> 00:45:59.964
So, after initialization,
it doesn't hold before

00:45:59.964 --> 00:46:06.000
initialization because d isn't
defined then.

00:46:06.000 --> 00:46:09.977
But if you do this
initialization where you set S

00:46:09.977 --> 00:46:14.535
to zero, and everyone else to
infinity, and you take any

00:46:14.535 --> 00:46:19.176
sequence of relaxation steps,
then this variant will hold

00:46:19.176 --> 00:46:22.160
after each relaxation step you
apply.

00:46:22.160 --> 00:46:25.226
This is actually a very general
lemma.

00:46:25.226 --> 00:46:29.535
It's also pretty easy to prove.
It holds not only for

00:46:29.535 --> 00:46:33.099
Dijkstra's algorithm,
but for a lot of other

00:46:33.099 --> 00:46:38.416
algorithms we'll see.
Pretty much every algorithm we

00:46:38.416 --> 00:46:43.008
see will involve relaxation.
And, this is saying no matter

00:46:43.008 --> 00:46:47.197
what relaxations you do,
you always have a reasonable

00:46:47.197 --> 00:46:51.949
estimate in the sense that it's
greater than or equal to the

00:46:51.949 --> 00:46:56.219
true shortest path weight.
So, it should be converging

00:46:56.219 --> 00:46:58.797
from above.
So, that's the lemma.

00:46:58.797 --> 00:47:02.019
Let's prove it.
Any suggestions on how we

00:47:02.019 --> 00:47:07.340
should prove this lemma?
What technique might we use?

00:47:07.340 --> 00:47:09.513
What's that?
Cut and paste?

00:47:09.513 --> 00:47:12.941
It would be good for optimal
substructure.

00:47:12.941 --> 00:47:16.535
Cut and paste:
maybe sort of what's going on

00:47:16.535 --> 00:47:20.213
here but not exactly.
Something a little more

00:47:20.213 --> 00:47:22.972
general.
It's just intuition here;

00:47:22.972 --> 00:47:26.148
it doesn't have to be the right
answer.

00:47:26.148 --> 00:47:32.000
In fact, many answers are
correct, have plausible proofs.

00:47:32.000 --> 00:47:34.328
Induction, yeah.
So, I'm not going to write

00:47:34.328 --> 00:47:36.712
induction here,
but effectively we are using

00:47:36.712 --> 00:47:38.542
induction.
That's the answer I was

00:47:38.542 --> 00:47:40.371
expecting.
So, there is sort of an

00:47:40.371 --> 00:47:42.533
induction already in time going
on here.

00:47:42.533 --> 00:47:45.028
We say after initialization it
should be true.

00:47:45.028 --> 00:47:47.800
That's our base case.
And then, every relaxation we

00:47:47.800 --> 00:47:50.905
do, it should still be true.
So, we're going to assume by

00:47:50.905 --> 00:47:53.677
induction that all the previous
relaxations worked,

00:47:53.677 --> 00:47:56.671
and then we're going to prove
that the last relaxation,

00:47:56.671 --> 00:47:59.000
whatever it is,
works.

00:47:59.000 --> 00:48:01.828
So, first let's do the base
case.

00:48:01.828 --> 00:48:04.922
So, this is after an
initialization,

00:48:04.922 --> 00:48:09.254
let's say, initially.
So, initially we have d of s

00:48:09.254 --> 00:48:12.878
equal to zero.
And we have d of v equal to

00:48:12.878 --> 00:48:17.209
infinity for all other vertices,
for all vertices,

00:48:17.209 --> 00:48:21.983
v, not equal to little s.
OK, now we have to check that

00:48:21.983 --> 00:48:26.138
this inequality holds.
Well, we have delta of s,

00:48:26.138 --> 00:48:28.524
s.
We've already argued that

00:48:28.524 --> 00:48:33.117
that's zero.
You can't get negative when

00:48:33.117 --> 00:48:36.176
there are only nonnegative edge
weights.

00:48:36.176 --> 00:48:40.019
So, that's the best.
So, certainly zero is greater

00:48:40.019 --> 00:48:44.019
than or equal to zero.
And, we have everything else,

00:48:44.019 --> 00:48:47.470
well, I mean,
delta of S, v is certainly less

00:48:47.470 --> 00:48:50.607
than or equal to infinity.
So this holds.

00:48:50.607 --> 00:48:54.058
Everything is less than or
equal to infinity.

00:48:54.058 --> 00:48:59.000
So: base case is done.
So, now we do an induction.

00:48:59.000 --> 00:49:06.456
And, I'm going to write it as a
proof by contradiction.

00:49:06.456 --> 00:49:12.669
So, let's say,
suppose that this fails to hold

00:49:12.669 --> 00:49:18.606
at some point.
So, suppose for contradiction

00:49:18.606 --> 00:49:26.200
that the invariant is violated.
So, we'd like to sue the

00:49:26.200 --> 00:49:32.000
violator and find a
contradiction.

00:49:32.000 --> 00:49:36.374
So, it's going to be violated.
So, let's look at the first

00:49:36.374 --> 00:49:39.367
violation, the first time it's
violated.

00:49:39.367 --> 00:49:41.209
So, this is,
essentially,

00:49:41.209 --> 00:49:45.353
again, a proof by induction.
So, let's say we have some

00:49:45.353 --> 00:49:48.730
violation, d of v is less than
delta of s, v.

00:49:48.730 --> 00:49:53.565
That would be bad if we somehow
got an estimate smaller than the

00:49:53.565 --> 00:49:56.481
shortest path.
Well, then I think about

00:49:56.481 --> 00:50:01.162
looking at the first violation
is we know sort of by induction

00:50:01.162 --> 00:50:05.000
that all other values are
correct.

00:50:05.000 --> 00:50:09.208
OK, d of v is the first one
where we've screwed up.

00:50:09.208 --> 00:50:12.491
So, the invariant holds
everywhere else.

00:50:12.491 --> 00:50:17.626
Well, what caused this to fail,
this invariant to be violated,

00:50:17.626 --> 00:50:20.404
is some relaxation,
OK, on d of v.

00:50:20.404 --> 00:50:24.696
So, we had some d of v,
and we replaced it with some

00:50:24.696 --> 00:50:30.000
other d of u plus the weight of
the edge from u to v.

00:50:30.000 --> 00:50:34.389
And somehow,
this made it invalid.

00:50:34.389 --> 00:50:39.178
So, d of v is somehow less than
that.

00:50:39.178 --> 00:50:46.229
We just set d of v to this.
So, this must be less than

00:50:46.229 --> 00:50:51.816
delta of s, v.
The claim is that that's not

00:50:51.816 --> 00:50:59.000
possible because,
let me rewrite a little bit.

00:50:59.000 --> 00:51:07.668
We have d of u plus w of (u,v).
And, we have our induction

00:51:07.668 --> 00:51:15.576
hypothesis, which holds on u,
u of some other vertex.

00:51:15.576 --> 00:51:22.419
We know that d of u is at least
delta of s, u.

00:51:22.419 --> 00:51:30.479
So, this has to be at least
delta of s, u plus w of u,

00:51:30.479 --> 00:51:34.568
v.
Now, what about this w of u,

00:51:34.568 --> 00:51:37.412
v?
Well, that's some path from u

00:51:37.412 --> 00:51:40.623
to v.
So, it's got to be bigger than

00:51:40.623 --> 00:51:44.293
the shortest path or equal.
So certainly,

00:51:44.293 --> 00:51:48.238
this is greater than or equal
to delta of u,

00:51:48.238 --> 00:51:50.715
v.
OK, it could be larger if

00:51:50.715 --> 00:51:56.311
there's some multi-edged path
that has a smaller total weight,

00:51:56.311 --> 00:52:00.440
but it's certainly no smaller
than delta of u,

00:52:00.440 --> 00:52:04.403
v.
And, this looks like a good

00:52:04.403 --> 00:52:08.942
summation, delta of S to u,
and u to v is a triangle

00:52:08.942 --> 00:52:11.523
inequality, yeah.
So, that is,

00:52:11.523 --> 00:52:15.261
it's upside down here.
But, the triangle S,

00:52:15.261 --> 00:52:19.267
u, u to v, so this is only
longer than S to v.

00:52:19.267 --> 00:52:24.340
OK, so we have this thing,
which is simultaneously greater

00:52:24.340 --> 00:52:29.057
than or equal to the shortest
path weight from S to v,

00:52:29.057 --> 00:52:34.486
and also strictly less than the
shortest path weight from S to

00:52:34.486 --> 00:52:37.719
v.
So, that's a contradiction.

00:52:37.719 --> 00:52:41.476
Maybe contradiction is the most
intuitive way isn't the most

00:52:41.476 --> 00:52:43.959
intuitive way to proceed.
The intuition,

00:52:43.959 --> 00:52:47.780
here, is whatever you assign d
of v, you have a path in mind.

00:52:47.780 --> 00:52:50.200
You inductively had a path from
s to u.

00:52:50.200 --> 00:52:53.384
Then you added this edge.
So, that was a real path.

00:52:53.384 --> 00:52:57.332
We always know that every path
has weight greater than or equal

00:52:57.332 --> 00:53:00.070
to the shortest path.
So, it should be true,

00:53:00.070 --> 00:53:06.934
and here's the inductive proof.
All right, moving right along,

00:53:06.934 --> 00:53:14.409
so this was an easy warm-up.
We have greater than or equal

00:53:14.409 --> 00:53:18.737
to.
Now we have to prove less than

00:53:18.737 --> 00:53:23.852
or equal to at the end of the
algorithm.

00:53:23.852 --> 00:53:31.327
This is true all the time;
less than or equal to will only

00:53:31.327 --> 00:53:37.080
be true at the end.
So, we are not going to prove

00:53:37.080 --> 00:53:41.385
less than or equal to quite yet.
We're going to prove another

00:53:41.385 --> 00:53:44.686
lemma, which again,
so both of these lemmas are

00:53:44.686 --> 00:53:46.982
useful for other algorithms,
too.

00:53:46.982 --> 00:53:51.502
So, we're sort of building some
shortest path theory that we can

00:53:51.502 --> 00:53:54.300
apply later.
This one will give you some

00:53:54.300 --> 00:53:58.174
intuition about why relaxation,
not only is it not bad,

00:53:58.174 --> 00:54:01.618
it's actually good.
Not only does it not screw up

00:54:01.618 --> 00:54:07.000
anything, but it also makes
progress in the following sense.

00:54:07.000 --> 00:54:12.631
So, suppose you knew the
shortest path from s to some

00:54:12.631 --> 00:54:16.422
vertex.
OK, so you go from s to some

00:54:16.422 --> 00:54:19.888
other vertices.
Then you go to u.

00:54:19.888 --> 00:54:25.086
Then you go to v.
Suppose that is a shortest path

00:54:25.086 --> 00:54:29.418
from s to v.
OK, and also suppose that we

00:54:29.418 --> 00:54:35.483
already know in d of u the
shortest path weight from s to

00:54:35.483 --> 00:54:39.400
u.
So, suppose we have this

00:54:39.400 --> 00:54:43.400
equality.
We now know that we always have

00:54:43.400 --> 00:54:49.000
a greater than or equal to.
Suppose they are equal for u,

00:54:49.000 --> 00:54:53.900
OK, the vertex just before v in
the shortest path.

00:54:53.900 --> 00:54:58.400
OK, and suppose we relax that
edge, (u,v), OK,

00:54:58.400 --> 00:55:05.133
which is exactly this step.
This is relaxing the edge,

00:55:05.133 --> 00:55:08.508
(u,v).
But we'll just call it

00:55:08.508 --> 00:55:13.089
relaxation here.
After that relaxation,

00:55:13.089 --> 00:55:19.598
d of v equals delta of (s,v).
So, if we had the correct

00:55:19.598 --> 00:55:23.455
answer for u,
and we relax (u,v),

00:55:23.455 --> 00:55:29.000
then we get the correct answer
for v.

00:55:29.000 --> 00:55:32.495
OK, this is good news.
It means, if inductively we can

00:55:32.495 --> 00:55:36.519
somehow get the right answer for
u, now we know how to get the

00:55:36.519 --> 00:55:38.893
right answer for v.
In the algorithm,

00:55:38.893 --> 00:55:42.719
we don't actually know what the
vertex just before v in the

00:55:42.719 --> 00:55:45.555
shortest path is,
but in the analysis we can

00:55:45.555 --> 00:55:48.655
pretty much know that.
So, we have to prove this

00:55:48.655 --> 00:55:50.897
lemma.
This is actually even easier

00:55:50.897 --> 00:55:53.997
than the previous one:
don't even need induction

00:55:53.997 --> 00:55:57.889
because you just work through
what's going on in relaxation,

00:55:57.889 --> 00:56:01.167
and it's true.
So, here we go.

00:56:01.167 --> 00:56:04.982
So, we're interested in this
value, delta of Ss v.

00:56:04.982 --> 00:56:07.863
And we know what the shortest
path is.

00:56:07.863 --> 00:56:12.145
So, the shortest path weight is
the weight of this path.

00:56:12.145 --> 00:56:15.493
OK, so we can write down some
equality here.

00:56:15.493 --> 00:56:20.009
Well, I'm going to split out
the first part of the path and

00:56:20.009 --> 00:56:22.968
the last part of the path.
So, we have,

00:56:22.968 --> 00:56:27.484
I'll say, the weight from s,
so, this part of the path from

00:56:27.484 --> 00:56:32.000
s to u, plus the weight of this
edge, u, v.

00:56:32.000 --> 00:56:40.309
Remember, we could write w of a
path, and that was the total

00:56:40.309 --> 00:56:46.366
weight of all those edges.
So, what is this,

00:56:46.366 --> 00:56:51.295
the weight of this path from S
to u?

00:56:51.295 --> 00:56:59.605
Or, what property should I use
to figure out what that value

00:56:59.605 --> 00:57:02.000
is?
Yeah?

00:57:02.000 --> 00:57:05.344
s to v is the shortest path,
right?

00:57:05.344 --> 00:57:11.049
So, by optimal substructure,
from s to u is also a shortest

00:57:11.049 --> 00:57:13.803
path.
So, this is delta of s,

00:57:13.803 --> 00:57:14.491
u.
Cool.

00:57:14.491 --> 00:57:19.606
We'll hold on for now.
That's all we're going to say.

00:57:19.606 --> 00:57:24.131
On the other hand,
we know from this lemma that

00:57:24.131 --> 00:57:28.950
matter what we do,
d of v is greater than or equal

00:57:28.950 --> 00:57:32.000
to delta of s,
v.

00:57:32.000 --> 00:57:36.086
So, let's write that down.
So, there's a few cases,

00:57:36.086 --> 00:57:39.437
and this will eliminate some of
the cases.

00:57:39.437 --> 00:57:44.341
By that lemma correctness one,
we know that d of v is greater

00:57:44.341 --> 00:57:46.793
than or equal to delta of s,
v.

00:57:46.793 --> 00:57:50.879
So, it's either equal or
greater than at all times.

00:57:50.879 --> 00:57:55.701
So, I'm thinking about the time
before we do the relaxation,

00:57:55.701 --> 00:57:58.072
this (u,v).
So, at that point,

00:57:58.072 --> 00:58:02.485
this is certainly true.
So, either they're equal before

00:58:02.485 --> 00:58:06.000
relaxation or it's greater.

00:58:16.000 --> 00:58:19.760
OK, if they are equal before
relaxation, we're happy because

00:58:19.760 --> 00:58:23.011
relaxation only decreases values
by correctness one.

00:58:23.011 --> 00:58:26.645
It can't get any smaller than
this, so after relaxation it

00:58:26.645 --> 00:58:29.832
will also be equal.
OK, so in this case we're done.

00:58:29.832 --> 00:58:35.543
So, that's a trivial case.
So let's now suppose that d of

00:58:35.543 --> 00:58:41.330
v is greater than delta of s,
v before relaxation.

00:58:41.330 --> 00:58:46.881
That's perfectly valid.
Hopefully now we fix it.

00:58:46.881 --> 00:58:51.960
OK, well the point is,
we know this delta s,

00:58:51.960 --> 00:58:53.968
v.
It is this sum.

00:58:53.968 --> 00:58:58.338
OK, we also know this.
So, delta of s,

00:58:58.338 --> 00:59:03.342
u we know is d of u.
And, we have this w u,

00:59:03.342 --> 00:59:04.379
v.
So, delta of s,

00:59:04.379 --> 00:59:07.917
v is d of u plus w of (u,v)
because we are assuming we have

00:59:07.917 --> 00:59:11.150
this shortest path structure
where you go from s to u,

00:59:11.150 --> 00:59:13.285
and then you follow the edge,
(u,v).

00:59:13.285 --> 00:59:16.091
So, we know this.
So, we know d of v is greater

00:59:16.091 --> 00:59:19.690
than d of u plus w of (u,v).
By golly, that's this condition

00:59:19.690 --> 00:59:22.008
in relaxation.
So, we're just checking,

00:59:22.008 --> 00:59:24.387
relaxation actually does
something here.

00:59:24.387 --> 00:59:26.949
OK, if you had the wrong
distance estimate,

00:59:26.949 --> 00:59:33.119
this if condition is satisfied.
Therefore, we do this.

00:59:33.119 --> 00:59:36.805
So, in this case,
we relax.

00:59:36.805 --> 00:59:44.037
So, I'm just relaxing.
Then, we set d of v to d of u

00:59:44.037 --> 00:59:52.828
plus WUV, which is what we want.
OK, so we set d of v to d of u

00:59:52.828 --> 00:59:57.507
plus w of (u,v).
And, this equals,

00:59:57.507 --> 01:00:01.761
as we said here,
delta of S, v,

01:00:01.761 --> 01:00:08.000
which is what we wanted to
prove.

01:00:08.000 --> 01:00:12.662
Done.
OK, I'm getting more and more

01:00:12.662 --> 01:00:18.834
excited as we get into the meat
of this proof.

01:00:18.834 --> 01:00:22.400
Any questions so far?
Good.

01:00:22.400 --> 01:00:28.982
Now comes the hard part.
These are both very easy

01:00:28.982 --> 01:00:35.935
lemmas, right?
I'll use these two boards.

01:00:35.935 --> 01:00:41.081
We don't need these proofs
anymore.

01:00:41.081 --> 01:00:48.043
We just need these statements:
correctness one,

01:00:48.043 --> 01:00:52.583
correctness lemma;
great names.

01:00:52.583 --> 01:01:00.000
So, now finally we get to
correctness two.

01:01:00.000 --> 01:01:03.771
So, we had one and one and a
half.

01:01:03.771 --> 01:01:09.485
So, I guess correctness is,
itself, a mini-trilogy,

01:01:09.485 --> 01:01:14.400
the mini-series.
OK, so correctness two says

01:01:14.400 --> 01:01:20.342
when the algorithm is done,
we have the right answer.

01:01:20.342 --> 01:01:26.514
This is really correctness.
But, it's going to build on

01:01:26.514 --> 01:01:32.000
correctness one and correctness
lemma.

01:01:32.000 --> 01:01:35.699
So, we want d of v to equal
delta of s, v for all vertices,

01:01:35.699 --> 01:01:39.207
v at the end of the algorithm.
That is clearly our goal.

01:01:39.207 --> 01:01:42.779
Now, this theorem is assuming
that all of the weights are

01:01:42.779 --> 01:01:46.223
nonnegative, just to repeat.
It doesn't assume anything

01:01:46.223 --> 01:01:48.136
else.
So, it's going to get the

01:01:48.136 --> 01:01:50.687
infinities right.
But, if there are minus

01:01:50.687 --> 01:01:54.004
infinities, all bets are off.
OK, even if there's any

01:01:54.004 --> 01:01:57.831
negative weight edge anywhere,
it's not going to do the right

01:01:57.831 --> 01:02:02.573
thing necessarily.
But, assuming all the weights

01:02:02.573 --> 01:02:06.656
are nonnegative,
which is reasonable if they're

01:02:06.656 --> 01:02:10.207
measuring time.
Usually it costs money to

01:02:10.207 --> 01:02:14.378
travel along edges.
They don't pay you to do it.

01:02:14.378 --> 01:02:18.106
But who knows?
So, I need just to say a few

01:02:18.106 --> 01:02:20.769
things.
One of the things we've

01:02:20.769 --> 01:02:26.094
mentioned somewhere along the
way is when you add a vertex to

01:02:26.094 --> 01:02:32.363
S, you never change its weight.
OK, that actually requires

01:02:32.363 --> 01:02:35.272
proof.
I'm just going to state it

01:02:35.272 --> 01:02:37.636
here.
It's not hard to see.

01:02:37.636 --> 01:02:42.000
d of v doesn't change.
OK, this is essentially an

01:02:42.000 --> 01:02:47.636
induction once v is added to S.
OK, this will actually followed

01:02:47.636 --> 01:02:50.727
by something we'll say in a
moment.

01:02:50.727 --> 01:02:56.272
OK, so all I really care about
is when a vertex is added to S,

01:02:56.272 --> 01:03:01.000
we better have the right
estimate because after that,

01:03:01.000 --> 01:03:06.000
we're not going to change it,
let's say.

01:03:06.000 --> 01:03:10.097
OK, we could define the
algorithm that way.

01:03:10.097 --> 01:03:15.365
We are not, but we could.
I'll say more about this in a

01:03:15.365 --> 01:03:18.390
second.
So, all we care about is

01:03:18.390 --> 01:03:21.804
whether d of v equals delta of
s, v.

01:03:21.804 --> 01:03:26.780
That's what we want to prove.
So, it's clearly that.

01:03:26.780 --> 01:03:32.536
It should be true at the end.
But, it suffices to prove that

01:03:32.536 --> 01:03:38.000
it holds when v is added to S,
to capital S.

01:03:38.000 --> 01:03:40.327
OK, this actually implies the
first statement.

01:03:40.327 --> 01:03:42.086
It has sort of a funny
implication.

01:03:42.086 --> 01:03:44.982
But, if we can prove this,
that d of v equals delta of s,

01:03:44.982 --> 01:03:47.258
v, when you add to S,
we know relaxation only

01:03:47.258 --> 01:03:49.586
decreases value.
So, it can't get any smaller.

01:03:49.586 --> 01:03:51.241
It would be from correctness
one.

01:03:51.241 --> 01:03:54.137
Correctness one says we can't
get any smaller than delta.

01:03:54.137 --> 01:03:57.396
So, if we get a quality at that
point, we'll have a quality from

01:03:57.396 --> 01:03:59.362
then on.
So, that actually implies d of

01:03:59.362 --> 01:04:02.000
v never changes after that
point.

01:04:02.000 --> 01:04:06.085
OK, so we're going to prove
this.

01:04:06.085 --> 01:04:10.297
Good.
Well, suppose it isn't true.

01:04:10.297 --> 01:04:15.787
So this would be a proof by a
contradiction.

01:04:15.787 --> 01:04:22.042
Suppose for contradiction that
this fails to hold.

01:04:22.042 --> 01:04:26.638
And, let's look at the first
failure.

01:04:26.638 --> 01:04:32.000
Suppose u is the first vertex
--

01:04:41.000 --> 01:04:45.053
-- that's about to be added to
S.

01:04:45.053 --> 01:04:52.146
I want to consider the time
right before it's added to S,

01:04:52.146 --> 01:04:56.706
for which we don't have what we
want.

01:04:56.706 --> 01:05:04.166
These are not equal.
d of u does not equal delta of

01:05:04.166 --> 01:05:08.611
s, u.
Well, if they're not equal,

01:05:08.611 --> 01:05:16.805
we know from correctness one
that d of E is strictly greater

01:05:16.805 --> 01:05:20.972
than delta of s,
u, so, d of u.

01:05:20.972 --> 01:05:28.472
So, we have d of u is strictly
greater than delta of s,

01:05:28.472 --> 01:05:32.852
u.
OK, that's the beginning of the

01:05:32.852 --> 01:05:37.453
proof, nothing too exciting yet,
just some warm-up.

01:05:37.453 --> 01:05:41.319
OK, but this,
used already correctness one.

01:05:41.319 --> 01:05:46.564
I think that's the only time
that we use it in this proof.

01:05:46.564 --> 01:05:52.177
OK, so I sort of just want to
draw picture of what's going on.

01:05:52.177 --> 01:05:55.674
But I need a little bit of
description.

01:05:55.674 --> 01:06:00.000
So, let's look at the shortest
path.

01:06:00.000 --> 01:06:04.176
Somehow, d of u is greater than
the shortest path.

01:06:04.176 --> 01:06:08.352
So, consider the shortest path
or a shortest path.

01:06:08.352 --> 01:06:12.784
Let p be a shortest path,
not just any shortest path,

01:06:12.784 --> 01:06:15.596
but the shortest path from s to
u.

01:06:15.596 --> 01:06:20.028
OK, so that means that the
weight of this path is the

01:06:20.028 --> 01:06:24.375
shortest path weight.
So, we have some equations for

01:06:24.375 --> 01:06:28.636
what's going on here.
So, we care about delta of s,

01:06:28.636 --> 01:06:32.791
u.
Here's a path with that weight.

01:06:32.791 --> 01:06:37.473
It's got to be one because
shortest paths exist here;

01:06:37.473 --> 01:06:41.796
slight exceptional cases if
it's a plus infinity,

01:06:41.796 --> 01:06:45.127
but I'm not going to worry
about that.

01:06:45.127 --> 01:06:49.000
So, let me draw a picture
somewhere.

01:07:03.000 --> 01:07:06.283
So, we have s.
We have u.

01:07:06.283 --> 01:07:11.344
Here is the shortest path from
s to u.

01:07:11.344 --> 01:07:16.542
That's p.
No idea what it looks like so

01:07:16.542 --> 01:07:21.056
far.
Now, what we also have is the

01:07:21.056 --> 01:07:27.759
notion of capital S.
So, I'm going to draw capital

01:07:27.759 --> 01:07:32.000
S.
So, this is big S.

01:07:32.000 --> 01:07:34.600
We know that little s is in big
S.

01:07:34.600 --> 01:07:37.279
We know that u is not yet in
big S.

01:07:37.279 --> 01:07:40.195
So, I haven't screwed up
anything yet,

01:07:40.195 --> 01:07:42.638
right?
This path starts in S and

01:07:42.638 --> 01:07:47.445
leaves it at some point because
until we are about to add u to

01:07:47.445 --> 01:07:51.070
S, so it hasn't happened yet,
so u is not in S.

01:07:51.070 --> 01:07:53.671
Fine.
What I want to do is look at

01:07:53.671 --> 01:07:57.375
the first place here where the
path, p, exits S.

01:07:57.375 --> 01:08:02.526
So, there is some vertex here.
Let's call it x.

01:08:02.526 --> 01:08:06.436
There's some vertex here.
We'll call it y.

01:08:06.436 --> 01:08:10.632
OK, possibly x equals S.
Possibly y equals u.

01:08:10.632 --> 01:08:16.260
But it's got to exit somewhere,
because it starts inside and

01:08:16.260 --> 01:08:19.979
ends up outside.
And it's a finite path.

01:08:19.979 --> 01:08:25.893
OK, so consider the first time
it happens; not the second time,

01:08:25.893 --> 01:08:29.803
the first.
OK, so consider the first edge,

01:08:29.803 --> 01:08:37.140
(x,y), where p exits capital S.
The shortest path from s to u

01:08:37.140 --> 01:08:42.014
exits capital S.
It's got to happen somewhere.

01:08:42.014 --> 01:08:46.779
Cool, now, what do we know?
Little x is in S.

01:08:46.779 --> 01:08:53.061
So, it has the right answer
because u, we were about to add

01:08:53.061 --> 01:08:59.776
u to S, and that was the first
violation of something in S that

01:08:59.776 --> 01:09:06.206
has the wrong d of x estimate.
So, d of x equals delta of s,

01:09:06.206 --> 01:09:08.565
x.
Because we are looking at the

01:09:08.565 --> 01:09:11.989
first violation,
x is something that got added

01:09:11.989 --> 01:09:14.423
before.
So, by induction on time,

01:09:14.423 --> 01:09:18.608
or because we had the first
violation, d of x equals the

01:09:18.608 --> 01:09:21.043
shortest path weight from S to
x.

01:09:21.043 --> 01:09:25.000
So, that's good news.
Now we are trying to apply this

01:09:25.000 --> 01:09:27.815
lemma.
It's the only thing left to do.

01:09:27.815 --> 01:09:32.000
We haven't used this lemma for
anything.

01:09:32.000 --> 01:09:35.358
So, we have the setup.
If we already know that one of

01:09:35.358 --> 01:09:38.974
the d values is the right
answer, and we relaxed the edge

01:09:38.974 --> 01:09:42.009
that goes out from it,
then we get another right

01:09:42.009 --> 01:09:44.399
answer.
So that's what I want to argue

01:09:44.399 --> 01:09:46.982
over here.
We know that the d of x equals

01:09:46.982 --> 01:09:50.017
this weight because,
again, subpaths of shortest

01:09:50.017 --> 01:09:53.504
paths are shortest paths.
We have optimal substructure,

01:09:53.504 --> 01:09:56.023
so this is a shortest path,
from S to x.

01:09:56.023 --> 01:09:58.800
It might not be the only one,
but it is one.

01:09:58.800 --> 01:10:02.029
So we know that matches.
Now, I want to think about

01:10:02.029 --> 01:10:05.000
relaxing this edge,
(x,y).

01:10:05.000 --> 01:10:08.536
Well, x is in capital S.
And, the algorithm says,

01:10:08.536 --> 01:10:11.778
whenever you add a vertex,
u, to the big set,

01:10:11.778 --> 01:10:15.389
S, you relax all the edges that
go out from there.

01:10:15.389 --> 01:10:19.368
OK, so when we added x to S,
and we now look far in the

01:10:19.368 --> 01:10:22.610
future, we're about to add some
other vertex.

01:10:22.610 --> 01:10:26.073
Right after we added x to S,
we relax this edge,

01:10:26.073 --> 01:10:30.273
(x,y), because we relaxed every
edge that goes out from x,

01:10:30.273 --> 01:10:36.443
OK, whatever they were.
Some of them went into S.

01:10:36.443 --> 01:10:42.091
Some of them went out.
Here's one of them.

01:10:42.091 --> 01:10:46.913
So, when we added x to S,
we got XS.

01:10:46.913 --> 01:10:52.561
When we added x to S,
we relaxed the edge,

01:10:52.561 --> 01:10:57.382
(x,y).
OK, so now we're going to use

01:10:57.382 --> 01:11:04.000
the lemma.
So, by the correctness lemma --

01:11:15.000 --> 01:11:18.863
What do you get?
Well, we add this correct

01:11:18.863 --> 01:11:23.387
shortest path weight to x now.
We relax the edge,

01:11:23.387 --> 01:11:26.403
(x,y).
So, now we should have the

01:11:26.403 --> 01:11:29.607
correct shortest path weight for
y.

01:11:29.607 --> 01:11:33.000
d of y equals delta of s,
y.

01:11:33.000 --> 01:11:35.509
OK, this is sometime in the
past.

01:11:35.509 --> 01:11:38.803
In particular,
now, it should still be true

01:11:38.803 --> 01:11:43.588
because once you get down to the
right answer you never change

01:11:43.588 --> 01:11:45.549
it.
OK, we should be done.

01:11:45.549 --> 01:11:49.156
OK, why are we done?
Well, what else do we know

01:11:49.156 --> 01:11:51.431
here?
We assumed something for

01:11:51.431 --> 01:11:54.803
contradiction,
so we better contradict that.

01:11:54.803 --> 01:11:58.647
We assume somehow,
d of u is strictly greater than

01:11:58.647 --> 01:12:03.142
delta of s, u.
So, d of u here is strictly

01:12:03.142 --> 01:12:06.476
greater than the length of this
whole path.

01:12:06.476 --> 01:12:10.047
Well, we don't really know
whether u equals y.

01:12:10.047 --> 01:12:14.015
It could, could not.
And, but what do we know about

01:12:14.015 --> 01:12:18.857
this shortest path from S to y?
Well, it could only be shorter

01:12:18.857 --> 01:12:21.952
than from S to u because it's a
subpath.

01:12:21.952 --> 01:12:26.476
And it's the shortest path
because it's the subpath of the

01:12:26.476 --> 01:12:29.888
shortest path.
The shortest path from S to y

01:12:29.888 --> 01:12:36.000
has to be less than or equal to
the shortest path from S to u.

01:12:36.000 --> 01:12:44.627
OK, S to y: less than or equal
to s, u, OK, just because the

01:12:44.627 --> 01:12:47.405
subpath.
I'm closer.

01:12:47.405 --> 01:12:51.207
I've got delta of s,
u now.

01:12:51.207 --> 01:12:56.033
Somehow, I want to involve d of
u.

01:12:56.033 --> 01:13:01.443
So, I want to relate d of y to
d of u.

01:13:01.443 --> 01:13:07.389
What do I know about d of u?
Yeah?

01:13:07.389 --> 01:13:10.814
d of u is smaller because we
have a Min heap,

01:13:10.814 --> 01:13:12.449
yeah.
We always chose,

01:13:12.449 --> 01:13:14.862
let's erase,
it's way down here.

01:13:14.862 --> 01:13:17.664
We chose u.
This is the middle of the

01:13:17.664 --> 01:13:20.778
algorithm.
It's the reason I kept this to

01:13:20.778 --> 01:13:23.736
be the minimum key.
This is keyed on d.

01:13:23.736 --> 01:13:28.095
So, we know that at this
moment, when we're trying to add

01:13:28.095 --> 01:13:30.275
u to S, right,
y is not in S,

01:13:30.275 --> 01:13:35.412
and u is not in S.
They might actually be the same

01:13:35.412 --> 01:13:38.057
vertex.
But both of these vertices,

01:13:38.057 --> 01:13:40.080
same or not,
are outside S.

01:13:40.080 --> 01:13:44.204
We chose u because d of u has
the smallest d estimate.

01:13:44.204 --> 01:13:48.250
So, d of y has to be greater
than or equal to d of u.

01:13:48.250 --> 01:13:51.674
It might be equal if they're
the same vertex,

01:13:51.674 --> 01:13:55.020
but it's got to be greater than
or equal to.

01:13:55.020 --> 01:14:00.000
So, d of y here is greater than
or equal to d of u.

01:14:00.000 --> 01:14:03.791
So, here we're using the fact
that we actually made a greedy

01:14:03.791 --> 01:14:06.168
choice.
It's the one place we're using

01:14:06.168 --> 01:14:09.317
the greedy choice.
Better use it somewhere because

01:14:09.317 --> 01:14:13.108
you can't just take an arbitrary
vertex and declare it to be

01:14:13.108 --> 01:14:15.293
done.
You've got to take the greedy

01:14:15.293 --> 01:14:17.477
one.
OK, now we have d of u is less

01:14:17.477 --> 01:14:20.947
than or equal to delta of s,
u, which contradicts this.

01:14:20.947 --> 01:14:24.096
OK, sort of magical that that
all just worked out.

01:14:24.096 --> 01:14:27.566
But sort of like the previous
proofs, you just see what

01:14:27.566 --> 01:14:32.000
happens and it works.
OK, that's the approximation.

01:14:32.000 --> 01:14:35.005
The only real idea here is to
look at this edge.

01:14:35.005 --> 01:14:37.563
In fact, you could look at this
edge too.

01:14:37.563 --> 01:14:41.209
But let's look at some edge
that comes from S and goes out

01:14:41.209 --> 01:14:44.151
of S, and argue that while x has
to be correct,

01:14:44.151 --> 01:14:47.156
and what we made x correct,
y had to be correct,

01:14:47.156 --> 01:14:49.779
and now, why the hell are we
looking at u?

01:14:49.779 --> 01:14:52.337
y is the thing you should have
looked at.

01:14:52.337 --> 01:14:55.598
And, there you get a
contradiction because y had the

01:14:55.598 --> 01:14:57.325
right answer.
If u equals y,

01:14:57.325 --> 01:14:59.755
that's fine,
or if u and y were sort of

01:14:59.755 --> 01:15:02.441
equally good,
that's also fine if all these

01:15:02.441 --> 01:15:07.604
weights were zero.
So, the picture might actually

01:15:07.604 --> 01:15:10.469
look like this.
But, in that case,

01:15:10.469 --> 01:15:14.376
d of u is the correct answer.
It was delta SU.

01:15:14.376 --> 01:15:19.064
We assumed that it wasn't.
That's where we're getting a

01:15:19.064 --> 01:15:21.408
contradiction.
Pretty clear?

01:15:21.408 --> 01:15:25.054
Go over this proof.
It's a bit complicated,

01:15:25.054 --> 01:15:28.440
naturally.
OK, we have a little bit more

01:15:28.440 --> 01:15:34.168
to cover, some easier stuff.
OK, the first thing is what's

01:15:34.168 --> 01:15:36.710
the running time of this
algorithm?

01:15:36.710 --> 01:15:41.196
I'll do this very quick because
we're actually seen this many

01:15:41.196 --> 01:15:45.233
times before last class.
There was some initialization.

01:15:45.233 --> 01:15:48.448
The initialization,
which is no longer here,

01:15:48.448 --> 01:15:50.467
is linear time.
No big deal.

01:15:50.467 --> 01:15:53.308
OK, extract Min.
Well, that's some data

01:15:53.308 --> 01:15:56.373
structure.
So, we have something like size

01:15:56.373 --> 01:15:59.065
of V.
Every vertex we extract the Min

01:15:59.065 --> 01:16:01.607
once, and that's it.
So, size of V,

01:16:01.607 --> 01:16:06.634
extract mins.
OK, so that's pretty simple.

01:16:06.634 --> 01:16:12.466
OK, then we had this main loop.
This is a completely conceptual

01:16:12.466 --> 01:16:16.135
operation.
S is not actually used in the

01:16:16.135 --> 01:16:19.240
algorithm.
It's just for thinking.

01:16:19.240 --> 01:16:23.285
OK, so this takes zero time.
Got to love it.

01:16:23.285 --> 01:16:28.742
OK, and now the heart is here.
So, how many times does this

01:16:28.742 --> 01:16:33.324
loop iterate?
That's the degree of u.

01:16:33.324 --> 01:16:38.780
So, what is the total number of
times that we execute a

01:16:38.780 --> 01:16:43.428
relaxation step?
It doesn't necessarily mean we

01:16:43.428 --> 01:16:47.672
do this, but we at least execute
this body.

01:16:47.672 --> 01:16:53.128
Over the whole algorithm,
how many times do we do this?

01:16:53.128 --> 01:16:57.170
Every vertex,
we look at all the outgoing

01:16:57.170 --> 01:17:02.000
edges from there.
So, the total would be?

01:17:11.000 --> 01:17:12.615
Number of edges,
yeah.

01:17:12.615 --> 01:17:15.307
So, this number of edges
iterations.

01:17:15.307 --> 01:17:19.615
OK, this is essentially the
handshaking lemma we saw last

01:17:19.615 --> 01:17:24.230
time, but for directed graphs.
And we are only looking at the

01:17:24.230 --> 01:17:27.538
outgoing edges.
So, it's not a factor of two

01:17:27.538 --> 01:17:32.000
here because you're only
outgoing from one side.

01:17:32.000 --> 01:17:36.573
So, we have number of
reiterations.

01:17:36.573 --> 01:17:42.358
In the worst case,
we do a decreased key for

01:17:42.358 --> 01:17:45.183
everyone.
So, at most:

01:17:45.183 --> 01:17:50.026
E decreased keys.
OK, so the time is,

01:17:50.026 --> 01:17:57.695
well, we have v extract Mins,
so the time to do an extract

01:17:57.695 --> 01:18:05.771
Min, whatever that is.
And we have E decreased keys,

01:18:05.771 --> 01:18:12.013
whatever that is,
and this is exactly the running

01:18:12.013 --> 01:18:20.336
time we had for Prim's algorithm
for a minimum spanning tree last

01:18:20.336 --> 01:18:24.237
time.
And, it depends what data

01:18:24.237 --> 01:18:31.000
structure you use,
what running time you get.

01:18:31.000 --> 01:18:34.688
So, I'm going to skip the whole
table here.

01:18:34.688 --> 01:18:39.518
But, if you use an array,
the final running time will be

01:18:39.518 --> 01:18:44.436
V^2 because you have order of v
extract Min, and you have

01:18:44.436 --> 01:18:49.090
constant time decreased key.
If you use a binary heap,

01:18:49.090 --> 01:18:53.569
which we know and love,
then we have order log v for

01:18:53.569 --> 01:18:57.609
each operation.
And so, this is V plus E log V.

01:18:57.609 --> 01:19:02.000
And, so that's what we know how
to do.

01:19:02.000 --> 01:19:06.830
And, if you use this fancy data
structure called a Fibonacci

01:19:06.830 --> 01:19:11.005
heap, you get constant time
decreased key amortized.

01:19:11.005 --> 01:19:16.000
And, you get an E plus v log v
worst case bound on the running

01:19:16.000 --> 01:19:18.701
time.
So, this is the best we know

01:19:18.701 --> 01:19:23.368
how to solve shortest paths
without any extra assumptions,

01:19:23.368 --> 01:19:28.116
single source shortest paths
with non-negative edge weights

01:19:28.116 --> 01:19:32.040
in general.
OK, this is almost as good and

01:19:32.040 --> 01:19:34.353
this is sometimes better than
that.

01:19:34.353 --> 01:19:38.163
But these are essentially
irrelevant except that you know

01:19:38.163 --> 01:19:41.020
how to do these.
You don't know how to do a

01:19:41.020 --> 01:19:45.238
Fibonacci heap unless you read
that in the chapter of the book.

01:19:45.238 --> 01:19:48.435
That's why we mention the top
two running times.

01:19:48.435 --> 01:19:51.632
OK, I want to talk briefly
about a simpler case,

01:19:51.632 --> 01:19:55.510
which you may have seen before.
And so it's sort of fun to

01:19:55.510 --> 01:20:00.000
connect this up to breadth first
search in a graph.

01:20:00.000 --> 01:20:03.302
So, I mean that ends Dijkstra,
so to speak.

01:20:03.302 --> 01:20:08.176
But now I want to think about a
special case where the graph is

01:20:08.176 --> 01:20:12.737
unweighted, meaning w of (u,v)
equals one for all vertices,

01:20:12.737 --> 01:20:15.174
u and v.
OK, suppose we had that

01:20:15.174 --> 01:20:17.847
property.
Can we do any better than

01:20:17.847 --> 01:20:20.599
Dijkstra?
Can we do better than this

01:20:20.599 --> 01:20:23.980
running time?
Well, we probably have to look

01:20:23.980 --> 01:20:26.889
at all the edges and all the
vertices.

01:20:26.889 --> 01:20:32.000
So, the only thing I'm
questioning is this log v.

01:20:32.000 --> 01:20:36.067
Can I avoid that?
I gave away the answer a little

01:20:36.067 --> 01:20:38.779
bit.
The answer is called breadth

01:20:38.779 --> 01:20:42.508
first search,
or BFS, which you have probably

01:20:42.508 --> 01:20:45.813
seen before.
Next to depth first search,

01:20:45.813 --> 01:20:50.050
it's one of the standard ways
to look at the graph.

01:20:50.050 --> 01:20:54.627
But we can say a little bit
more than you may have seen

01:20:54.627 --> 01:20:57.762
before.
Breadth for search is actually

01:20:57.762 --> 01:21:02.000
Dijkstra's algorithm:
kind of nifty.

01:21:02.000 --> 01:21:08.607
There are two changes.
First change is that breadth

01:21:08.607 --> 01:21:13.894
for search does not use a
priority queue.

01:21:13.894 --> 01:21:19.048
I'll just tell you what it uses
instead.

01:21:19.048 --> 01:21:26.449
You can use a queue first in
first out honest-to-goodness

01:21:26.449 --> 01:21:32.000
queue instead of a priority
queue.

01:21:32.000 --> 01:21:36.728
OK, it turns out that works.
Instead of doing extract Min,

01:21:36.728 --> 01:21:40.295
you just take the first thing
off the queue.

01:21:40.295 --> 01:21:44.692
Instead of doing decreased key,
OK, here's a subtlety.

01:21:44.692 --> 01:21:48.260
But, this if statement changes
a little bit.

01:21:48.260 --> 01:21:50.831
So, here is the relaxation
step.

01:21:50.831 --> 01:21:54.730
So, in order to relax,
you say this much simpler

01:21:54.730 --> 01:21:57.551
thing.
If we haven't visited v yet,

01:21:57.551 --> 01:22:01.782
then we declare it to have the
shortest path weight,

01:22:01.782 --> 01:22:06.511
say, d of v is d of u plus one,
which is the weight of the

01:22:06.511 --> 01:22:12.423
edge, (u,v).
And we add v to the end of the

01:22:12.423 --> 01:22:16.076
queue.
So, now, we start with the

01:22:16.076 --> 01:22:20.869
queue empty.
Actually, it will just contain

01:22:20.869 --> 01:22:25.777
the vertex, S,
because that's the only thing

01:22:25.777 --> 01:22:31.347
we know the shortest path for.
So, the queue is just for,

01:22:31.347 --> 01:22:33.316
I know the shortest path of
this thing.

01:22:33.316 --> 01:22:36.217
Just deal with it when you
can't look at all the outgoing

01:22:36.217 --> 01:22:38.652
edges when you can.
So, initially that's just S.

01:22:38.652 --> 01:22:40.777
You say, well,
for all the outgoing edges,

01:22:40.777 --> 01:22:42.746
S has zero.
All the outgoing edges from

01:22:42.746 --> 01:22:45.388
there have weight one.
The shortest path weight from

01:22:45.388 --> 01:22:47.668
the source is one.
You certainly can't do any

01:22:47.668 --> 01:22:49.896
better than that if all the
weights are one.

01:22:49.896 --> 01:22:52.435
OK, so we add all those
vertices to the end of the

01:22:52.435 --> 01:22:54.093
queue.
Then, we process things in

01:22:54.093 --> 01:22:55.958
order, and we just keep
incrementing,

01:22:55.958 --> 01:22:57.979
if their value is d of u,
add one to it.

01:22:57.979 --> 01:23:02.543
That's d of v.
And then we are going to add v

01:23:02.543 --> 01:23:05.510
to S what we get to it in the
queue.

01:23:05.510 --> 01:23:09.156
OK, that is breadth for search,
very simple.

01:23:09.156 --> 01:23:13.989
And, you can look at the text
for the algorithm and for an

01:23:13.989 --> 01:23:17.973
example because I don't have
time to cover that.

01:23:17.973 --> 01:23:21.704
But the key thing is that the
time is faster.

01:23:21.704 --> 01:23:25.434
The time is order V plus E
because as before,

01:23:25.434 --> 01:23:30.267
we only look at each edge once
we look at all the outgoing

01:23:30.267 --> 01:23:34.930
edges from all the vertices.
As soon as we set d of v to

01:23:34.930 --> 01:23:40.079
something, it will remain that.
We never touch it.

01:23:40.079 --> 01:23:43.136
We are going to add it to S.
That only happens once.

01:23:43.136 --> 01:23:46.193
So, this if statement,
and so on, in the in-queuing,

01:23:46.193 --> 01:23:48.711
is done order E times,
or actually E times,

01:23:48.711 --> 01:23:50.689
exactly.
An in-queuing to a queue,

01:23:50.689 --> 01:23:54.106
and de-queuing from a queue,
that's what we use instead of

01:23:54.106 --> 01:23:57.583
extract Min, take constant time,
so the total running time,

01:23:57.583 --> 01:24:01.000
number of vertices plus the
number of edges.

01:24:01.000 --> 01:24:04.580
OK, not so obvious that this
works, but you can prove that it

01:24:04.580 --> 01:24:06.550
works using the Dijkstra
analysis.

01:24:06.550 --> 01:24:09.891
All you have to do is prove
that the FIFO priority queue.

01:24:09.891 --> 01:24:12.816
Once you know that,
by the correctness of Dijkstra

01:24:12.816 --> 01:24:15.501
you get the correctness of
breadth for search.

01:24:15.501 --> 01:24:19.022
So, not only is breadth for
search finding all the vertices,

01:24:19.022 --> 01:24:21.588
which is maybe what you
normally use it for,

01:24:21.588 --> 01:24:25.109
but it finds the shortest path
weights from S to every other

01:24:25.109 --> 01:24:27.198
vertex when the weights are all
one.

01:24:27.198 --> 01:24:30.003
So, there we go:
introduction to shortest paths.

01:24:30.003 --> 01:24:32.803
Next time we'll deal with
negative weights.

