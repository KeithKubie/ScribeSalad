WEBVTT
Kind: captions
Language: en

00:00:01.890 --> 00:00:09.330
&gt;&gt;David Springer: Hi, everybody. My name is
Dave Springer. This is the "Beyond JavaScript"

00:00:09.330 --> 00:00:16.680
session. We're going to talk about how to
bring your client code to the web.

00:00:16.680 --> 00:00:22.929
So wouldn't it be awesome if you could take
client apps and serve them on the web as a

00:00:22.929 --> 00:00:27.019
Web app? And that's what we're going to talk
about today. How we can do that.

00:00:27.019 --> 00:00:32.791
A quick show of hands. How many people here
are client programmers versus web programmers?

00:00:32.791 --> 00:00:38.970
So client programmers?
We've got -- that's -- okay. And then web

00:00:38.970 --> 00:00:39.970
programmers, pretty much everybody else? So
that's about half and half.

00:00:39.970 --> 00:00:44.219
Awesome. Good. So I got a little something
for everybody.

00:00:44.219 --> 00:00:53.160
I am the tech lead of the Native Client SDK
group out in Boulder, Colorado, and we are

00:00:53.160 --> 00:00:56.789
building the SDK on top of the Native Client
technology.

00:00:56.789 --> 00:01:05.100
Today, we'll talk about the technology itself,
a quick overview. I'm not going to get -- do

00:01:05.100 --> 00:01:10.290
like a really super deep dive into that. It's
just more of a, "Hey, this is what we can

00:01:10.290 --> 00:01:16.920
do with it," this idea that we can merge these
two worlds of web programming and client programming,

00:01:16.920 --> 00:01:20.611
and talk about how we can bring that native
code into the web.

00:01:20.611 --> 00:01:28.970
I'm going to go through a couple use cases,
what Native Client is really good at. There's

00:01:28.970 --> 00:01:33.930
this idea of a 90/10 application, which is
90% of your app is in web programming, 10%

00:01:33.930 --> 00:01:41.290
of it in native code, versus the 10/90, which
is nearly all of it is in the native code.

00:01:41.290 --> 00:01:45.350
You know, 10% is in the web and 90% is in
the native code.

00:01:45.350 --> 00:01:52.780
And we're going to build an app right here
live on stage. Write code and compile it and

00:01:52.780 --> 00:01:58.470
run it.
Okay. And then we'll go through Q&amp;A.

00:01:58.470 --> 00:02:06.970
So what is NaCl? We abbreviate everything,
you know, so Native Client is shortened to

00:02:06.970 --> 00:02:15.040
"NaCl." This gives way to all kinds of bad
puns on salt and pepper and -- right? N-a-C-l?

00:02:15.040 --> 00:02:18.160
Okay? Everybody got that?
[Laughter]

00:02:18.160 --> 00:02:28.190
Good. All right. Good to keep up.
It is a sandboxing technology for the safe

00:02:28.190 --> 00:02:31.709
execution data code. That means it's as safe
a JavaScript.

00:02:31.709 --> 00:02:36.920
So today you're running your JavaScript in
a sandbox. We're providing another sandbox,

00:02:36.920 --> 00:02:42.200
in addition to that one, to actually run your
native code. It is real CPU instructions.

00:02:42.200 --> 00:02:49.550
It's machine code running on the native CPU.
It's not an interpreter.

00:02:49.550 --> 00:02:55.800
You can do things in it, so we provide a kind
of a POSIX-like API, and I'll talk a little

00:02:55.800 --> 00:03:03.500
bit more about that in a second. And we also
provide this pepper API. It goes with salt.

00:03:03.500 --> 00:03:09.959
So it's the way that you talk to the browser.
And again, we'll get into that a little bit

00:03:09.959 --> 00:03:13.090
more later.
It's a technology that helps you merge all

00:03:13.090 --> 00:03:17.690
the benefits of web programming, so this -- you
know, when you program in the web, you write

00:03:17.690 --> 00:03:21.330
it once and it runs everywhere. Doesn't matter
what platform it's running on. As long as

00:03:21.330 --> 00:03:29.370
it has a browser, you can run a Web app. So
we merge that delivery promise with native

00:03:29.370 --> 00:03:32.080
code.
So it's this idea that you write your native

00:03:32.080 --> 00:03:36.680
code once, you build it, and serve it as a
Web app, and it runs on all platforms that

00:03:36.680 --> 00:03:43.629
have a browser.
There are restrictions, okay? So the idea

00:03:43.629 --> 00:03:50.090
is, we want everything to be as secure as
JavaScript, so if you were here in other sessions

00:03:50.090 --> 00:03:53.459
-- for example, the Fireside Chat just before
this one -- we talked a lot about security.

00:03:53.459 --> 00:04:00.090
So we're pretty uptight about it and we want
things to be safe, even though you're running

00:04:00.090 --> 00:04:05.569
native code, which can potentially be quite
dangerous.

00:04:05.569 --> 00:04:14.260
So how does this all work?
First of all, you take your source code, which

00:04:14.260 --> 00:04:18.800
might be, say, C or C++, and you have to compile
it.

00:04:18.800 --> 00:04:24.250
So we've provided specialized tool chains.
They're based on GCC. And we've modified them

00:04:24.250 --> 00:04:29.040
slightly.
And what happens is you build for specific

00:04:29.040 --> 00:04:33.880
CPU architectures. Obviously you are running
machine instructions, so that means you have

00:04:33.880 --> 00:04:43.720
to compile for specific architectures. X86_32
versus X86_64 versus ARM, for example.

00:04:43.720 --> 00:04:50.560
Once you've built and linked an executable
from your source code, then we do a static

00:04:50.560 --> 00:04:56.140
analysis on it to make sure that your code
isn't doing something naughty. You know, so

00:04:56.140 --> 00:04:59.390
we look at the -- we'll get into an example
of that in a second.

00:04:59.390 --> 00:05:05.170
And that's a static analysis phase.
So if the code passes the static analysis

00:05:05.170 --> 00:05:10.860
phase and it's okay, then it goes inside of
our sandbox to be run. And the sandbox actually

00:05:10.860 --> 00:05:14.690
lives inside the browser.
Today we live inside Chrome.

00:05:14.690 --> 00:05:25.360
So again, not an interpreter, but the sandbox
-- there are -- if you try to do nasty things

00:05:25.360 --> 00:05:33.000
at run time, then the sandbox has to catch
those and halt the malicious code. So we don't

00:05:33.000 --> 00:05:38.800
actually prevent malicious code from getting
into your browser, but we do our best to stop

00:05:38.800 --> 00:05:44.410
it if it gets there and tries to do naughty
stuff.

00:05:44.410 --> 00:05:48.660
So these are some of the restrictions that
I alluded to earlier.

00:05:48.660 --> 00:05:55.460
You can't directly touch the file system of
the client computer. You can't do open, stat,

00:05:55.460 --> 00:05:59.930
things like that.
You cannot fork off a process, obviously.

00:05:59.930 --> 00:06:02.770
That would be bad.
You can't kill things.

00:06:02.770 --> 00:06:11.470
If you -- there -- you can get a complete
list of all the disallowed system calls from

00:06:11.470 --> 00:06:17.000
libnosis.a. That all comes from SDK if you
download it and at the end you'll see a link

00:06:17.000 --> 00:06:20.910
of where to get that.
So how does it work?

00:06:20.910 --> 00:06:26.780
You start with the browser, of course, which
has its own sandbox, and this is executing

00:06:26.780 --> 00:06:30.561
your markup, your CSS, your JavaScript, et
cetera.

00:06:30.561 --> 00:06:39.030
There is a bridge, the pepper API, and this
is how the browser -- the JavaScript in the

00:06:39.030 --> 00:06:43.211
browser talks to the native code in the NaCl
sandbox.

00:06:43.211 --> 00:06:47.990
And then there's the NaCl sandbox, which is
this run time that's actually running your

00:06:47.990 --> 00:06:53.120
native code.
Okay. And as we go through all the examples,

00:06:53.120 --> 00:06:57.250
you'll see this graphic and it will show when
I'm in the browser, when I'm on the pepper

00:06:57.250 --> 00:07:04.210
bridge, when I'm in the NaCl code, and that
will make sense when you see that.

00:07:04.210 --> 00:07:07.940
So how do we do things with our special tool
chain and validator?

00:07:07.940 --> 00:07:14.460
So who can spot the evil code here? Hint:
There's at least four instructions in here

00:07:14.460 --> 00:07:22.690
that are bad.
So for example, every memory access and control

00:07:22.690 --> 00:07:30.090
transfer is potentially unsafe.
I mean, so things like this jump has to go

00:07:30.090 --> 00:07:37.460
to a valid address. So this is all things
we can find out in -- during static analysis.

00:07:37.460 --> 00:07:47.730
And this call, x86, for example, has a variable
length instruction word. So that means this

00:07:47.730 --> 00:07:51.580
call can jump back into the middle of an instruction
and start executing bad stuff, right? So we

00:07:51.580 --> 00:07:54.510
don't want to do that.
We don't allow that.

00:07:54.510 --> 00:08:03.430
So what we do is, in this case of the call,
we say that we require a 32-byte aligned jump.

00:08:03.430 --> 00:08:07.780
We also do things like we give you a fixed
amount of memory space to work in. You have

00:08:07.780 --> 00:08:18.240
4 gigs, and you can't go outside of that.
You can make system calls, and we have this

00:08:18.240 --> 00:08:24.110
idea of a trampoline.
So you're in your Native Client code that's

00:08:24.110 --> 00:08:29.840
built with a special tool chain. It's all
validated. Let's say you want to call MMAP.

00:08:29.840 --> 00:08:35.300
So the first thing that happens is that gets
bundled up with its parameters and pushed

00:08:35.300 --> 00:08:42.950
through a trampoline into what we call the
trusted code, which is our sandbox, our NaCl

00:08:42.950 --> 00:08:48.270
run time, that's built into the browser.
This goes through a dispatcher which looks

00:08:48.270 --> 00:08:54.690
at all the parameters and makes sure that,
for example, you're MMAPing a legal amount

00:08:54.690 --> 00:09:00.070
of memory and that your addresses that you're
trying to MMAP are okay, that they're within

00:09:00.070 --> 00:09:07.400
range; that the descriptor you're trying to
map to is a valid descriptor that you got

00:09:07.400 --> 00:09:13.010
from the untrusted libraries and so on.
Then if that's all okay, we turn that into

00:09:13.010 --> 00:09:18.500
the actual real sys call that calls to the
operating system and does the MMAP.

00:09:18.500 --> 00:09:24.620
That gets a return value which then goes into
the springboard, back to your untrusted code,

00:09:24.620 --> 00:09:29.510
and off you go.
So if at any time during that chain of events

00:09:29.510 --> 00:09:35.810
something goes wrong or it looks bad, your
code is halted.

00:09:35.810 --> 00:09:42.110
And a halt, by the way, looks like a snap,
right? I mean, the thing just -- it just stops.

00:09:42.110 --> 00:09:47.580
So we call this security model "defense in
depth." It's kind of akin to let's say you

00:09:47.580 --> 00:09:53.020
bought something really valuable. You might
take that valuable thing and put it in a really

00:09:53.020 --> 00:09:57.570
big safe, but you probably wouldn't take that
safe and just leave it in a vacant lot in

00:09:57.570 --> 00:10:00.170
the Tenderloin.
What you would probably do is put the safe

00:10:00.170 --> 00:10:04.520
in your basement, behind a locked door, which
has got an alarm system, and your front door

00:10:04.520 --> 00:10:07.800
has a lock, maybe a big dog, and things like
that, right?

00:10:07.800 --> 00:10:13.830
So that's the kind of approach we're taking
is: Let's try and get as many layers -- defensible

00:10:13.830 --> 00:10:19.090
layers -- as we can get between the native
code and the OS.

00:10:19.090 --> 00:10:25.820
And we do this by we have our own sandbox
that runs native code. It runs alongside of

00:10:25.820 --> 00:10:32.930
the Chrome sandbox. So actually, malicious
code has to get out of two sandboxes in order

00:10:32.930 --> 00:10:37.030
to try and do anything. That's pretty hard
to do. We do things like implement CORS, so

00:10:37.030 --> 00:10:43.860
we -- our URL downloading/HTP request stuff
all works with that. We can blacklist CPUs.

00:10:43.860 --> 00:10:48.390
Certain CPUs have instruction sets that are
known to be buggy, so we can -- it's pretty

00:10:48.390 --> 00:10:55.200
rare nowadays, but you can do that.
You can blacklist NaCl modules. So this is

00:10:55.200 --> 00:10:59.680
the same thing as blacklisting an URL, right?
Because it just -- as we'll see later, this

00:10:59.680 --> 00:11:05.580
is just a Web app, so it's a URL and you can
blacklist those.

00:11:05.580 --> 00:11:15.210
Native Client is an open source project, so
it's pretty -- we do security audits, we have

00:11:15.210 --> 00:11:21.190
contests, we have public review of the code,
we have peer reviews. We're really, really

00:11:21.190 --> 00:11:29.750
sensitive to the security issues and are trying
to get the attack surface as small as possible.

00:11:29.750 --> 00:11:36.670
Okay. So why would you use Native Client?
First of all, choice of language is a big

00:11:36.670 --> 00:11:42.710
deal, right? Let's say that you have a fairly
large investment in C++ or C, one of these

00:11:42.710 --> 00:11:48.030
compiled languages for client code.
And we hear a lot of people saying they would

00:11:48.030 --> 00:11:51.990
rather not translate all of that into JavaScript.
Especially if you have many hundreds of thousands

00:11:51.990 --> 00:11:58.611
of lines of code. That can be quite a burden.
So now you can compile it with our tool chain

00:11:58.611 --> 00:12:05.860
and with a -- what turns out often the case
is a fairly unchallenging porting effort you

00:12:05.860 --> 00:12:14.150
can run the whole thing inside of Native Client.
Maybe you have some performance considerations

00:12:14.150 --> 00:12:18.380
to think about.
Native Client does give you direct access

00:12:18.380 --> 00:12:24.140
to the CPU and GPU.
You can take advantage of SIMD instructions,

00:12:24.140 --> 00:12:29.990
so for example, if you have SSE3 in your app,
then you can hand-code that kind of assembly

00:12:29.990 --> 00:12:36.590
language, as long as it is within our validator
rules, and most of them are.

00:12:36.590 --> 00:12:41.760
You can take advantage of multi-core CPUs.
We implement the pthreads library, so you

00:12:41.760 --> 00:12:46.380
can run multiple threads.
And actually in my example, I'll show what

00:12:46.380 --> 00:12:50.150
happens when you do that and the kind of performance
improvement you can get by getting off the

00:12:50.150 --> 00:12:56.090
main browser thread.
And again, if you're writing in a language

00:12:56.090 --> 00:13:02.670
such as C or C++ where you can do things like
de-reference pointers and that's important

00:13:02.670 --> 00:13:07.070
and it gives you the speed, then you can lay
out your data and you can do that. That's

00:13:07.070 --> 00:13:13.010
not something that's very easy to do within
JavaScript.

00:13:13.010 --> 00:13:20.850
And finally, this gives your client code the
browser as the delivery platform.

00:13:20.850 --> 00:13:33.850
So it's no more that you have to opt into
a download or hard media. Basically, there

00:13:33.850 --> 00:13:38.600
is a frictionless install. It's as if there's
no user install.

00:13:38.600 --> 00:13:43.570
There's no opting into trusted code and -- you
know, and do you trust this site and so on

00:13:43.570 --> 00:13:48.640
and so forth. There's none of that. You just
simply serve the NaCl module as part of your

00:13:48.640 --> 00:13:57.360
website. That's it.
So it's the end of this stuff, right?

00:13:57.360 --> 00:14:03.390
Plus, because it's a website, you're also
in the Chrome Web Store, which is a plus.

00:14:03.390 --> 00:14:06.140
So let's talk a little bit about the 90/10
versus 10/90 style applications.

00:14:06.140 --> 00:14:15.830
The 90/10 application, again, is just 90%
of your app is in web code, what we call -- it's

00:14:15.830 --> 00:14:22.200
a Web app, in other words. It's markup, it's
CSS, JavaScript. 10% is Native Client.

00:14:22.200 --> 00:14:26.250
Versus the other way around, which is that
very, very little of the code is actually

00:14:26.250 --> 00:14:29.529
in the web and most of it is in the native
code.

00:14:29.529 --> 00:14:35.790
So a 90/10 application, you know, is a web-centric
app and it needs some kind of an engine that

00:14:35.790 --> 00:14:43.020
wants to take advantage of things like data
layout, multithreading, and so on and so forth.

00:14:43.020 --> 00:14:49.720
It's kind of the situation where you want
to have a very low latency local server. You

00:14:49.720 --> 00:14:55.050
can think of it that way.
An example might be crypto, right?

00:14:55.050 --> 00:15:02.240
So you want to implement a DRM solution using
your specific crypto IP. And you can do this

00:15:02.240 --> 00:15:08.170
now with Native Client because your crypto
technology, you can just down- -- you can

00:15:08.170 --> 00:15:14.720
just literally stick it in the browser as
part of the web experience and ship your encrypted

00:15:14.720 --> 00:15:19.190
data back and forth across the wire.
Another example might be a physics engine.

00:15:19.190 --> 00:15:28.930
So you've got most of your game programmed
as a Web app, but you want to run a physics

00:15:28.930 --> 00:15:36.280
engine and actually look at data in a certain
way. Again, a great example of this is a 90/10

00:15:36.280 --> 00:15:40.560
use of NaCl.
A 10/90 application might be where you have

00:15:40.560 --> 00:15:46.140
a very big investment already in C and C++
code, let's say, and you've implemented the

00:15:46.140 --> 00:15:50.430
whole UI in the game experience, for example,
in that language.

00:15:50.430 --> 00:15:58.570
So this is where you just need a very thin
shim, basically just the thinnest possible

00:15:58.570 --> 00:16:06.260
delivery platform to connect into the browser,
but then actually deliver your entire game

00:16:06.260 --> 00:16:12.960
as if it was one big client app. So that's
also possible to do. Great application of

00:16:12.960 --> 00:16:23.110
Native Client.
Okay. Let's get down to building an app now.

00:16:23.110 --> 00:16:30.110
We're going to build the Game of Life. It's
Conway's life simulation.

00:16:30.110 --> 00:16:36.550
And we'll go through this in four stages.
So the first stage, we'll get started. And

00:16:36.550 --> 00:16:40.410
for you client programmers out there, what
we're doing is building a website. We're not

00:16:40.410 --> 00:16:45.149
building client apps anymore, as such. We're
building websites now.

00:16:45.149 --> 00:16:50.080
So I'm going to go through kind of, you know,
those steps, because it's a little bit different,

00:16:50.080 --> 00:16:53.230
it's a little bit different delivery mechanism
than perhaps what you're used to if you're

00:16:53.230 --> 00:17:00.390
a client programmer. It's no more just, you
know, a dot exe that somebody runs. It's now

00:17:00.390 --> 00:17:06.350
you have to go to a website and there's resources
that you serve.

00:17:06.350 --> 00:17:11.520
And then we'll talk about how to integrate
with the browser. So this is getting the JavaScript

00:17:11.520 --> 00:17:16.459
to talk to the native code.
And that gets a little tricky because the

00:17:16.459 --> 00:17:21.530
interfaces are all asynchronous. If you're
used to the kind of programming where you

00:17:21.530 --> 00:17:25.300
make a function call and then you get a return
value, that doesn't exist anymore.

00:17:25.300 --> 00:17:37.580
So I'm going to get into that a little bit,
because it could -- it can be new to some.

00:17:37.580 --> 00:17:45.710
Then we'll optimize by using multiple threads
and I'll show you how easy that is to do.

00:17:45.710 --> 00:17:50.400
It's one of these things where I just make
some changes in the back-end code and everything

00:17:50.400 --> 00:17:55.510
gets faster.
And then to wrap up, just show a couple of

00:17:55.510 --> 00:18:02.179
the other interfaces that we have implemented.
Audio, HTP requests, things like that, and

00:18:02.179 --> 00:18:05.831
we'll add, you know, sound files to this game.
It's a little gratuitous but, you know, it's

00:18:05.831 --> 00:18:12.640
fun.
Okay. First stage, this is where we're going

00:18:12.640 --> 00:18:19.850
to lay out the project. Again, we're building
a website, so there's more involved than just

00:18:19.850 --> 00:18:22.120
build scripts and cc files for you client
programmers.

00:18:22.120 --> 00:18:28.000
For you web programmers, this is going to
look absolutely boring and normal, except

00:18:28.000 --> 00:18:34.120
for the fact that there are also dot cc files
and stuff that has to be run through the compiler,

00:18:34.120 --> 00:18:37.550
so that's a little bit different. It's kind
of this merging of these two worlds.

00:18:37.550 --> 00:18:44.930
Part of the SDK that we've built, we give
you some scripts to help you lay out these

00:18:44.930 --> 00:18:51.990
projects, so it just kind of lays out some
simple files that get you started.

00:18:51.990 --> 00:18:56.530
It gives you a build script that will run
the special tool chains. It gets you started

00:18:56.530 --> 00:19:05.980
with a simple kind of dot cc file that has
the hooks to connect to the browser. And then

00:19:05.980 --> 00:19:10.380
what we'll do is we'll --
Well, why don't I just do it. I'll just run

00:19:10.380 --> 00:19:17.510
the script and make a simple project and you
can see what goes on, okay?

00:19:17.510 --> 00:19:32.130
So here I am in the SDK, and if I go into
project templates, I can say initproject.py.

00:19:32.130 --> 00:19:41.040
So I'll give it name. It is life2011.
Whoa. Okay.

00:19:41.040 --> 00:19:56.420
And then directory equals examples.
Okay. So it just laid everything out for me.

00:19:56.420 --> 00:20:08.640
Now, if I go up into here, exampleslife2011,
there's my simple template files.

00:20:08.640 --> 00:20:13.120
We use scons for our build system because
it's kind of common among -- all you need

00:20:13.120 --> 00:20:16.461
is Python. It doesn't require things like
segment on windows and so on and so forth,

00:20:16.461 --> 00:20:22.331
so it just works.
So if I say "scons" right now and just build

00:20:22.331 --> 00:20:29.120
it, here it is running the tool chain, and
it's generated some -- an inf file, which

00:20:29.120 --> 00:20:36.840
I'll get into the details of that in a second.
It's produced the NaCl modules, a 32-bit one

00:20:36.840 --> 00:20:45.640
here and a 64-bit one, for me, so now I have
my whole Native Client website. It's there.

00:20:45.640 --> 00:20:54.020
It doesn't really do very much, but it's workable.
So what I'll do is run a little local Python

00:20:54.020 --> 00:21:03.980
HTTP server and we're seal what that Web site
does right now. So, if I run that, and then

00:21:03.980 --> 00:21:12.370
whip over to Chrome -- this is, by the way,
Chrome M11 stable. And Native Client is behind

00:21:12.370 --> 00:21:22.090
a flag. So we can go into about flags and
see that Native Client is here. So it's something

00:21:22.090 --> 00:21:33.100
you have to actively enable. Because it's
experimental still. So let me go to local

00:21:33.100 --> 00:21:41.240
host. 5103/life2011. You can see I've done
this before. Okay. So there it is. I just

00:21:41.240 --> 00:21:49.070
loaded my 90 module. And it's running. Promise.
It really is. It's not really doing anything,

00:21:49.070 --> 00:21:55.930
but there it is. Done. So that was it. You
can see here the server was outputting that

00:21:55.930 --> 00:21:58.500
it did some get requests and so on and so
forth.

00:21:58.500 --> 00:22:10.540
So okay. So that was it. And, to go through
the kind of files, again, there's an HTML

00:22:10.540 --> 00:22:15.830
template. There's a MFS is a manifest file.
We'll talk more about that. That's how you

00:22:15.830 --> 00:22:22.060
actually glue the architecture specific nexes
into the browser. And that's how the Native

00:22:22.060 --> 00:22:28.520
Client runtime knows which architecture to
pull in and run. Okay? And it makes the nexe

00:22:28.520 --> 00:22:34.390
files and other stuff in there, some CSS I
have on an image.

00:22:34.390 --> 00:22:39.150
So let's look at this actual code. I'm in
the browser now. You can see I've highlighted

00:22:39.150 --> 00:22:47.210
the browser piece of the graphic there.
This is how we do it. Embed tag. It's that

00:22:47.210 --> 00:22:56.730
simple. And we give it -- the source of the
file, this is JSON. That's the thing, the

00:22:56.730 --> 00:23:02.570
NMF file is the thing that actually ties the
NaCl modules you built from native code into

00:23:02.570 --> 00:23:12.900
the Native Client runtime. We tell it its
mime type is subtype NaCl. And this is just

00:23:12.900 --> 00:23:21.540
some JavaScripty stuff that I have that makes
the embed tag expand to fill its tab. So kind

00:23:21.540 --> 00:23:30.080
of faking out of full tab game.
Okay.

00:23:30.080 --> 00:23:38.850
This is the nmf file. A piece of JSON. And
it says I want to map x86-64 architecture

00:23:38.850 --> 00:23:47.140
to the specific nexe, x86 and so on. This
goes into the runtime. The runtime knows how

00:23:47.140 --> 00:23:52.490
to figure out what kind of CPU architecture
you're actually running on. And it goes and

00:23:52.490 --> 00:24:01.900
makes a request for the specific nexe it needs
to run on. You need to build a nexe for each

00:24:01.900 --> 00:24:07.870
architecture you need to run on today, but
we do our best to make that all invisible

00:24:07.870 --> 00:24:14.080
to the user. So in the life example we're
going to do some 2D graphics. This is akin

00:24:14.080 --> 00:24:23.169
to using the tag. And this is on the pepper
bridge now. This isn't CSS code in the pepper

00:24:23.169 --> 00:24:30.460
bridge. As an HTML5, you would use a canvas
tag. In pepper we say I want to make a new

00:24:30.460 --> 00:24:40.121
2D context. And then I have a paint API, and
I can flush it. So it's fairly straightforward.

00:24:40.121 --> 00:24:53.150
All right. Let's see what that looks like.
I have here a prebaked version of that Web

00:24:53.150 --> 00:25:01.220
site. So here it is running. And that's Conway's
life simulation. And I can go and say enter

00:25:01.220 --> 00:25:10.679
full screen mode. So that's that little piece
of JavaScript. All I did was tell the -- basically,

00:25:10.679 --> 00:25:17.020
the 2D graphics context to expand itself to
fill the whole screen.

00:25:17.020 --> 00:25:25.280
Okay. So that's pretty simple. Right?
I mean, it didn't really do anything except

00:25:25.280 --> 00:25:30.751
just run the simulation. What's actually going
on under the hood there is the simulation

00:25:30.751 --> 00:25:37.760
itself was all completely programmed in native
code. So that was all, basically, C++ code

00:25:37.760 --> 00:25:46.100
running the simulation making a little automaton.
And the toolbar, the area where it was running

00:25:46.100 --> 00:25:51.549
in, the thing along the bottom was all web
programming. That was all JavaScript and markup.

00:25:51.549 --> 00:25:56.510
So let's get a little more interesting.
We're going to turn this into an actual web

00:25:56.510 --> 00:26:02.130
application, kind of a little more of a game.
And what we'll do, for example, we'll go back

00:26:02.130 --> 00:26:07.730
into the browser again now and start writing
in markup and JavaScript and do things like

00:26:07.730 --> 00:26:13.030
write a little stamp editor. So those of you
familiar with Conway's life, you can give

00:26:13.030 --> 00:26:18.340
it initial values to do things like lighter
guns and puffer trains and, you know, fish

00:26:18.340 --> 00:26:25.090
and things like that.
So we can add a bunch of JavaScript to implement

00:26:25.090 --> 00:26:30.410
this panel.
We'll add some buttons. So we can run it in,

00:26:30.410 --> 00:26:34.760
you know, that random mode where it just gives
you a bunch of initial values randomly versus

00:26:34.760 --> 00:26:39.750
actually stamping them down.
And then we can also change the automaton

00:26:39.750 --> 00:26:47.320
rules.
Okay. So this is kind of, you know, for you

00:26:47.320 --> 00:26:53.280
web programmers out there, this is just absolutely
everyday markup. Right?

00:26:53.280 --> 00:26:59.730
Nothing special here. A bunch of JavaScript
to implement the panel. By the way, I -- in

00:26:59.730 --> 00:27:05.650
this example, I'm using a lot of Google closure.
That's not necessary. I work for Google, so

00:27:05.650 --> 00:27:13.419
it's easy. But Jquery, prototype. There's
many, many JavaScript libraries out there,

00:27:13.419 --> 00:27:18.410
as you know.
So one of the things I want to do is actually

00:27:18.410 --> 00:27:21.710
be able to click these stamps down and then
drag them along, right?

00:27:21.710 --> 00:27:27.600
So I'm going to add that and process drag
events. I'm going to use closure for that,

00:27:27.600 --> 00:27:35.650
because it's really simple. And we'll talk
about how to connect the fact that I've made

00:27:35.650 --> 00:27:42.070
a mouse down to add a stamp, connect that
from the JavaScript through the C++. I'm going

00:27:42.070 --> 00:27:47.360
to kind of get into that in a little detail.
Because that's asynchronous and maybe not

00:27:47.360 --> 00:27:51.650
familiar to everybody.
We'll look at the pepper interface and the

00:27:51.650 --> 00:27:58.120
post message style JavaScript interface that
we use. And then we'll actually work through

00:27:58.120 --> 00:28:04.840
an example and add a clear button.
Okay. So, first of all, in the browser, I

00:28:04.840 --> 00:28:15.160
want to add dragger. Simple. Goog.fx.dragger.
Done. It does the usual thing of look for

00:28:15.160 --> 00:28:25.131
mouse move, mouse up, and turns them into
drag events. I have -- in my view controller

00:28:25.131 --> 00:28:33.460
code, I have a listener that I took up to
those events and give it handlers. And in

00:28:33.460 --> 00:28:40.210
the handler, all I do is I say, okay, I'm
going to handle the event. Stop propagating

00:28:40.210 --> 00:28:51.039
it. And then I'm going to invoke the put stamp
it point method on my Native Client module.

00:28:51.039 --> 00:28:55.140
And this is where we're going to get into
the bridging. So a little bit about how this

00:28:55.140 --> 00:29:01.580
app is set up. The embed tag that you saw
earlier is actually represented by a JavaScript

00:29:01.580 --> 00:29:06.951
object that I call a view controller. And
it owns the DOM element, which is the Native

00:29:06.951 --> 00:29:13.830
Client module. So it appears to the browser
kind of like a JavaScript object that implements

00:29:13.830 --> 00:29:22.510
certain things such as post message.
Okay. So here is the implementation of my

00:29:22.510 --> 00:29:28.679
invoke method. Now this -- you can make this
as arbitrarily complex as you want. I just

00:29:28.679 --> 00:29:37.630
build a simple colon separated string. You
could use JSON stringify for this. But then,

00:29:37.630 --> 00:29:41.500
of course, you would have JSON going into
your C++ code. So, on the C++ side, you'll

00:29:41.500 --> 00:29:45.940
see that later you would have to unroll all
the JSON. This is really, really simple for

00:29:45.940 --> 00:29:53.200
me to go do. And how I get it in the NaCl
module is I call it on a DOM module. There's

00:29:53.200 --> 00:29:59.520
a DOM element that modulates the NaCl module,
and off I go. Here's where the asynchronous

00:29:59.520 --> 00:30:06.840
stuff happens, because this post message returns
immediately. There's no waiting. It just pushes

00:30:06.840 --> 00:30:13.030
the message out to the NaCl module and returns
it and hopes it gets there. There is a way

00:30:13.030 --> 00:30:19.130
to do closures and close that loop. I don't
have it in this example, but you can post

00:30:19.130 --> 00:30:26.580
message back from the C++ to the browser.
So, if I had a closure here that did something

00:30:26.580 --> 00:30:33.690
when it got to the C++ and got processed,
I could do that. This example doesn't have

00:30:33.690 --> 00:30:40.220
it. A little quick word on how this works.
This is for the client guys who are used to

00:30:40.220 --> 00:30:44.660
saying well, I call a method and it does something
and then returns. That doesn't happen any

00:30:44.660 --> 00:30:50.770
more. What goes on now is that I say post
message from JavaScript. That puts that post

00:30:50.770 --> 00:30:56.330
message command with its parameter and copies
it by value. So the entire contents of the

00:30:56.330 --> 00:31:03.010
post message call get copied. So you can return
and start modifying it. But that copy is now

00:31:03.010 --> 00:31:10.460
on the pepper queue, waiting to be processed
by the NaCl module. Then, later on, the NaCl

00:31:10.460 --> 00:31:16.490
sandbox, which is running, picks that post
message up with its data and calls handle

00:31:16.490 --> 00:31:22.730
message inside the pepper API. So the pepper
API is something that I have to implement.

00:31:22.730 --> 00:31:31.780
It's a bunch of known call points inside my
C++ code. And I then am responsible for implementing

00:31:31.780 --> 00:31:36.590
handle message, picking up that string and
parsing it and do whatever. We'll see how

00:31:36.590 --> 00:31:40.080
that works.
So here I am on the pepper bridge implementing

00:31:40.080 --> 00:31:44.980
handle message. So this is the other end of
the post message. So post message happened.

00:31:44.980 --> 00:31:49.970
And the browser did copy the data. It put
it on the pepper queue and returned. The browser

00:31:49.970 --> 00:31:55.470
is off and running again.
Now here I am in the NaCl module in the pepper

00:31:55.470 --> 00:32:03.980
bridge, and I get a -- it's a variant. And
I say, well, if it's a string, then I'm going

00:32:03.980 --> 00:32:13.289
to do the mirror in the C++ of invoke method.
So I just pull the string value off and call

00:32:13.289 --> 00:32:19.789
my scripting bridge -- and this is something
that, actually, I wrote in the NaCl code.

00:32:19.789 --> 00:32:26.370
So this is my own thing, again. It's the inverse
of what I did in the JavaScript. In the JavaScript

00:32:26.370 --> 00:32:33.450
I built up a string of colon separated parameters.
This is C++ that takes the string apart and

00:32:33.450 --> 00:32:41.280
builds, basically, a dictionary of the values.
And then here I just simply invoke a callback

00:32:41.280 --> 00:32:51.470
in C++ with that parameter dictionary.
Okay. So we'll add a clear button. We'll kind

00:32:51.470 --> 00:32:56.020
of go through this whole process. And this
is where I'm going to really write code and

00:32:56.020 --> 00:33:01.490
compile it and stuff. It's often worked.
[ Laughter ]

00:33:01.490 --> 00:33:07.590
Okay. So we'll add a clear button. The first
thing we'll do is, actually, add the clear

00:33:07.590 --> 00:33:11.060
button in the markup. Right?
You web programmers, totally easy. Button

00:33:11.060 --> 00:33:18.610
inside of a form. Not hard. Then we'll wire
up the onclick event on that button using

00:33:18.610 --> 00:33:24.860
JavaScript. And that will bubble through into
the view controller, which owns the NaCl module

00:33:24.860 --> 00:33:30.710
DOM element and, actually, finally do the
post message of the clear method. And then

00:33:30.710 --> 00:33:37.840
we'll add a handler in C++ for that. So you
see the whole process start to finish. Okay.

00:33:37.840 --> 00:33:46.630
So let's start with here is what we've got.
So here's this whole browser stamp editor,

00:33:46.630 --> 00:33:52.100
right?
It's arbitrary whatever. So I can make these

00:33:52.100 --> 00:34:01.870
stamps. I can run the simulation. And it's,
you know, doing that kind of thing. So I did

00:34:01.870 --> 00:34:05.655
all the drag events. I can change the automaton
rules. I don't know if you can see it in the

00:34:05.655 --> 00:34:12.829
back, but it's way at the bottom of the screen.
I can change the automaton rules. And this

00:34:12.829 --> 00:34:21.470
is a huge mess. And I can't clear this at
all. So that's why I want to add the clear

00:34:21.470 --> 00:34:29.489
button. Let's do that right now.
So what I do is go into my favorite text editor,

00:34:29.489 --> 00:34:35.819
and I have these little handy hooks here for
me.

00:34:35.819 --> 00:34:41.069
First thing I'm going to do is add the clear
button. So, if everybody can see that, this

00:34:41.069 --> 00:34:53.019
is just absolutely straightforward. Whoops.
HTML. And, again, this is totally live. So

00:34:53.019 --> 00:34:55.539
all bets are off.
All right. So I just put a clear button in

00:34:55.539 --> 00:35:02.450
there. It's a button that says clear. It's
not exciting. Then what I want to do is go

00:35:02.450 --> 00:35:11.779
and wire up the onclick event. So I'm going
to do that. Let me get this a little bit bigger,

00:35:11.779 --> 00:35:23.150
so we can see the code. There we go. Okay.
So I go into my JavaScript. And here I'm going

00:35:23.150 --> 00:35:30.739
to say, you know, get the DOM element and
add an event listener to it. And I want to

00:35:30.739 --> 00:35:39.249
call the clear event handler, so I better
add an implementation for that so that it

00:35:39.249 --> 00:35:46.099
works.
Let me put that there. Okay. So here's my

00:35:46.099 --> 00:35:51.890
clear event handler. Again, those of you who
used web programming, this is totally normal.

00:35:51.890 --> 00:35:55.859
I just simply say stop propagating the event,
because I'm going to handle it. And I'm going

00:35:55.859 --> 00:36:00.539
to call the clear method on my view controller
object. The view controller is not the NaCl

00:36:00.539 --> 00:36:07.059
module yet. The view controller owns the NaCl
module. I have to, obviously, implement this

00:36:07.059 --> 00:36:18.619
clear method in my view controller.
So I'm going to copy that and paste it into

00:36:18.619 --> 00:36:25.599
the view controller here. Okay. And you can
see here it's calling invoke method of clear.

00:36:25.599 --> 00:36:32.910
Okay? So now I've done all the browser stuff.
So let's see what that looks like. So, if

00:36:32.910 --> 00:36:44.180
I go into my shell here and I'm handily in
my life stage 2, I just say scons install.

00:36:44.180 --> 00:36:50.160
What that does is, you see, it's taken my
HTML file that I edited, my JavaScript that

00:36:50.160 --> 00:36:55.880
I edited, and put it into my sites directory.
By the way, on this Mac, I'm running a little

00:36:55.880 --> 00:37:02.460
Apache server. So I'm not using that simple
HTTP server. It doesn't matter what your server

00:37:02.460 --> 00:37:10.369
is. You just have to have one. That's all.
Okay. So let's see what happens there. So

00:37:10.369 --> 00:37:22.210
you remember the -- what it looked like before.
Oh, so that was a caching thing. Let me open

00:37:22.210 --> 00:37:29.789
this in an incognito window. And here's my
clear button. Okay? So let me just run this

00:37:29.789 --> 00:37:37.940
in the random mode. Now I should be able to
hit that button. Of course, it's not working.

00:37:37.940 --> 00:37:45.089
So why?
Well, of course, I know why. But let's take

00:37:45.089 --> 00:37:53.009
a look at -- in -- I can whip up developer
tools here and look in my JavaScript code.

00:37:53.009 --> 00:38:02.259
Let me get rid of this, pull that down here.
I want to make sure that I'm actually getting

00:38:02.259 --> 00:38:10.589
the event handled correctly, right?
So, if I scroll down here to my implementation

00:38:10.589 --> 00:38:20.891
of clear, I got a whole bunch of stuff. I'll
put a break point there on my clear button

00:38:20.891 --> 00:38:27.950
and, again, run the simulation and hit the
clear button. And, sure enough, it is hitting

00:38:27.950 --> 00:38:35.469
it. So let me step over that and make sure
it's indeed going into invoke method and step

00:38:35.469 --> 00:38:44.489
into that. And it seems to be wanting to call
post message with the clear method okay. So

00:38:44.489 --> 00:38:50.089
the -- what hasn't happened yet, of course,
is the C++ isn't there yet. So there's nothing

00:38:50.089 --> 00:38:55.579
on the other end to actually handle this clear.
So let's go ahead and add that. Whoops. Okay.

00:38:55.579 --> 00:39:05.849
I got to keep running. Hah-hah. That's why
it wasn't working.

00:39:05.849 --> 00:39:12.230
There is a fascinating little debugger demo.
Now, so let's go ahead and add C++. If this

00:39:12.230 --> 00:39:24.880
is all set up right, I 

00:39:24.880 --> 00:39:31.299
can paste it in there.
What's happening here is I have an implementation

00:39:31.299 --> 00:39:37.259
in the C++ code that will clear the buffers.
It is this, the clear method. Here's what

00:39:37.259 --> 00:39:44.359
that looks like, where it's simply getting
the pixel buffer that I've been painting in

00:39:44.359 --> 00:39:51.029
and it clears it. And it clears the simulation
buffers, too, right? So that's all it's doing.

00:39:51.029 --> 00:39:58.569
And that piece of code that I pasted in there
wires it up to the clear method so that earlier

00:39:58.569 --> 00:40:03.640
C++ code you saw that unravels all the parameter
names so on and so forth, that's going to

00:40:03.640 --> 00:40:11.219
then call this.
So let me save that. And now if I go in here

00:40:11.219 --> 00:40:16.430
and say scons install, you will see it is
actually running the compiler now because

00:40:16.430 --> 00:40:21.700
it has to build C++ code. It has made new
nexes and loaded them into my site.

00:40:21.700 --> 00:40:27.509
So let's take a look at what that looks like,
if I remember to do in an incognito window

00:40:27.509 --> 00:40:34.800
again, let me run the simulation. Let's throw
a couple little glider guns in there. And

00:40:34.800 --> 00:40:43.779
if I hit "clear," it indeed clears. So let's
go into stamp mode, clear, and then I can

00:40:43.779 --> 00:40:49.921
make a couple of glider guns in here like
this and stop the sim and clear and it works.

00:40:49.921 --> 00:41:01.660
[ Applause ]
Okay. So that was kind of a deep dive into

00:41:01.660 --> 00:41:11.309
the whole JavaScript to C++. Okay. So we can
-- we've connected those two things. Now let's

00:41:11.309 --> 00:41:16.160
make this go faster, okay? So what I'm going
to do is take -- because I have the entire

00:41:16.160 --> 00:41:22.180
simulation programmed in C++, it's fairly
straightforward to just simply take that implementation

00:41:22.180 --> 00:41:27.339
and run it on its own pthread.
The pthread is running inside of Native Client

00:41:27.339 --> 00:41:33.660
code. And what that helps me do is get out
of the browser's UI thread.

00:41:33.660 --> 00:41:38.609
So normally what's going on over the pepper
bridge is as you make these postMessage calls

00:41:38.609 --> 00:41:44.410
and so on and so forth, it is all on one single
browser thread. So it puts it on the pepper

00:41:44.410 --> 00:41:55.109
queue. But then the runtime as it wants to
paint things onto the 2D canvas that's shared

00:41:55.109 --> 00:41:59.250
with the browser, it has to do that on the
browser's thread. So it has to actually stop

00:41:59.250 --> 00:42:02.950
the browser momentarily while it paints and
come back, okay?

00:42:02.950 --> 00:42:08.200
So what we're going to do is actually separate
those two out on to separate threads and see

00:42:08.200 --> 00:42:12.819
what happens. And this is -- so the promise
is that if you get this kind of UI snappiness,

00:42:12.819 --> 00:42:16.119
right, in your application, that's what you
want.

00:42:16.119 --> 00:42:20.500
So I'm going to be working entirely in the
Native Client code. There is going to be -- no

00:42:20.500 --> 00:42:25.130
front-end programming is required for this
because all the wiring has already been done.

00:42:25.130 --> 00:42:31.751
And all I need to do now is just have a separate
thread that runs the simulation.

00:42:31.751 --> 00:42:38.670
Here, this is what I do some pthread create.
So client programmers, normal, right? Stuff

00:42:38.670 --> 00:42:42.910
you're used to.
Here is where I'm shutting the module down.

00:42:42.910 --> 00:42:48.990
I just simply join the thread and we have
mutices. And because it is just the full pthread

00:42:48.990 --> 00:42:56.539
API and I'm programming in C code, I'm free
to do things like make condition locks, right?

00:42:56.539 --> 00:42:59.680
So these are the kinds of things that are
not generally available in worker threads

00:42:59.680 --> 00:43:05.529
in JavaScript. This is the full threading
with mutices, with locks, with all that kind

00:43:05.529 --> 00:43:10.009
of stuff so you can program points of synchronization
in while the thread is running. It is not

00:43:10.009 --> 00:43:16.709
just start up and, well, it does what it does
and you don't hear from it again.

00:43:16.709 --> 00:43:24.930
This is -- You can do the full synchronization.
I did a little kind of seat-of-the-pants measuring.

00:43:24.930 --> 00:43:31.519
I'm getting about 6x performance improvement
just by having one more thread. So it is quite

00:43:31.519 --> 00:43:36.930
remarkable.
Okay. So let's see what that looks like. Actually,

00:43:36.930 --> 00:43:46.140
what I should be able to do is -- Let me go
here. And if I reload -- Okay.

00:43:46.140 --> 00:43:54.849
I'm going to put these side by side. Let me
see if that will work. I like to live on the

00:43:54.849 --> 00:43:59.241
edge.
Okay. So here we have the old one. This is

00:43:59.241 --> 00:44:09.549
the single-threaded version, and here is the
multi-threaded version. So single-threaded,

00:44:09.549 --> 00:44:16.029
multi-threaded.
So really -- I mean, it is a remarkable difference.

00:44:16.029 --> 00:44:25.140
And that, again, is entirely via C++ code.
There was no -- Oops! Ha, ha, ha.

00:44:25.140 --> 00:44:33.309
[ Laughter ]
Yeah. Did I mention that this was live?

00:44:33.309 --> 00:44:42.119
Okay. Let's go through the fourth stage which
is we are just going to add some multi-media

00:44:42.119 --> 00:44:47.400
and go through what that's like. We're going
to program on the pepper bridge in C++.

00:44:47.400 --> 00:44:55.849
So adding audio is kind of like using the
audio tag in HTML except not at all. So because

00:44:55.849 --> 00:45:00.849
we're -- where with the audio tag you say
audio given in URL and the browser figures

00:45:00.849 --> 00:45:04.489
out what kind of sound file you have and it
does all the decoding and all of that kind

00:45:04.489 --> 00:45:09.200
of nice stuff, you have to do that yourself
in pepper. So that may seem daunting.

00:45:09.200 --> 00:45:14.130
And if you all really want to do is simply
play a sound, then using the audio tag is

00:45:14.130 --> 00:45:19.460
probably your best bet.
However, if you want to do more with it, for

00:45:19.460 --> 00:45:26.339
example, do some processing to look at the
sound and pull speech phonoms out and then

00:45:26.339 --> 00:45:30.950
give them time stamps so you can do lip syncing
and do that kind of processing, then this

00:45:30.950 --> 00:45:38.479
is absolutely perfect for that.
How we do it is as an HTML5 you have an audio

00:45:38.479 --> 00:45:43.690
tag. Here you say, We are going to have an
audio context. The way it works, it wants

00:45:43.690 --> 00:45:51.229
a callback that is going to fill buffers.
In the C code, I have to implement -- this

00:45:51.229 --> 00:45:56.319
is where you would do your audio processing.
This example is just simply filling buffers.

00:45:56.319 --> 00:46:04.690
It is not doing anything fancy. And then there's
a play API that we invented that just says,

00:46:04.690 --> 00:46:12.069
you know, run it. That's all it does. So this
really is the simple version of sound. It's,

00:46:12.069 --> 00:46:16.459
you know, very straightforward.
What's interesting about this, though, is

00:46:16.459 --> 00:46:25.200
that we want to decode wav files. And there's
open source code out on the Internet that

00:46:25.200 --> 00:46:31.050
does that. So because this is Native Client
and because it's in a Sandbox and because

00:46:31.050 --> 00:46:35.099
we have this special toolchain that does all
the security features and the validating and

00:46:35.099 --> 00:46:42.150
everything else, I can just go and get code
from the Internet and compile it and run it.

00:46:42.150 --> 00:46:45.920
It's not -- it doesn't have to be subject
to endless security reviews and things like

00:46:45.920 --> 00:46:53.289
that because if the code from the Internet
is malicious, it is not going to run, right?

00:46:53.289 --> 00:46:59.359
It will either won't pass a validator or it
will halt in the execution stage or something.

00:46:59.359 --> 00:47:03.869
So I feel pretty confident in just getting
random code off the Internet, which is normally

00:47:03.869 --> 00:47:11.319
an extremely unsavory thing to do. But in
this case, not a problem. Of course, I'm going

00:47:11.319 --> 00:47:17.630
to Stanford and I'm hoping that Stanford is
kind of a respectable institution and they

00:47:17.630 --> 00:47:19.619
produce code that's not going to do something
nasty.

00:47:19.619 --> 00:47:25.799
But, you know, so here it is. This is all
just C code. It is very, very straightforward,

00:47:25.799 --> 00:47:32.309
decode wav files.
The other thing I have to do is actually get

00:47:32.309 --> 00:47:38.130
the sound resourced, right? So this is a HTTP
request, and we have pepper API to do that,

00:47:38.130 --> 00:47:45.539
too. So I just simply say, I want to open
a request and I set it up as a Get request.

00:47:45.539 --> 00:47:51.199
I want to follow redirects. In here, I can
also give it hints about cores and things

00:47:51.199 --> 00:47:56.829
like that.
And then as the data comes in, I read the

00:47:56.829 --> 00:48:02.959
response body and fill a buffer and that buffer
goes into the previous audio playback thing

00:48:02.959 --> 00:48:08.489
you saw earlier. Just simply copies it into
the sound buffer and plays it. So it's that

00:48:08.489 --> 00:48:14.170
straightforward.
Let's see what that looks like. Open it in

00:48:14.170 --> 00:48:25.220
an incognito window. Let's go into stamp mode.
And if my sound is playing.

00:48:25.220 --> 00:48:34.400
[ Beeping ]
So now -- and I cleverly got some other -- (doorbell

00:48:34.400 --> 00:48:43.940
ringing) -- sounds in here, too. Okay. So
there it is, the fourth stage of life. All

00:48:43.940 --> 00:48:45.920
together you can get a pretty good feel of
what we can do.

00:48:45.920 --> 00:48:50.769
Coming attraction we are doing an interactive
debugger and integrating it with your favorite

00:48:50.769 --> 00:48:57.049
IDE. We are starting with Visual Studio. Eventually,
we will get to other IDEs, X code, Eclipse,

00:48:57.049 --> 00:49:01.240
et cetera, et cetera, quids, integration,
that kind of thing. But we're starting with

00:49:01.240 --> 00:49:04.989
Visual Studio because a lot of client programmers
are already there.

00:49:04.989 --> 00:49:09.349
We are doing things like garbage collection,
JIT support. We have a port of mono that runs

00:49:09.349 --> 00:49:16.499
C sharp, and we are adding dynamic library
support as well. So this will reduce the size

00:49:16.499 --> 00:49:24.079
of the binaries that you build, right?
We're doing PNaCL, which is a portable library

00:49:24.079 --> 00:49:30.430
resource, LLVM bit code format on the wire.
That means that you only have to build one

00:49:30.430 --> 00:49:36.259
NaCl module. The promise being that ten years
from now someone is going to invent new CPU

00:49:36.259 --> 00:49:41.519
architecture. And we want to be able to take
nexes that exist on the Web and run them on

00:49:41.519 --> 00:49:46.890
those two.
What's required is a translation -- kind of

00:49:46.890 --> 00:49:52.040
the final translation stage to actual machine
code from the big code.

00:49:52.040 --> 00:50:00.509
We're adding more HTML5 support. So, generally
speaking, we track HTML5. We're going out

00:50:00.509 --> 00:50:04.339
the door with the 2D and the sound and some
event handling and things like that. Then

00:50:04.339 --> 00:50:10.099
quickly followed by 3D and then peer-to-peer
and file I/O. As the HTML5 specs start to

00:50:10.099 --> 00:50:17.859
mature and grow, we will track it.
Some attributions, of course, Conway's Game

00:50:17.859 --> 00:50:24.069
of Life basic algorithm. Greg Wirt in the
Boulder office helped me with the graphics

00:50:24.069 --> 00:50:29.829
and UI design. Wav format comes from Stanford.
The doorbell is from Sound Bible. Other from

00:50:29.829 --> 00:50:35.839
wavsource, et cetera.
And where to go from here, we have a doc set.

00:50:35.839 --> 00:50:46.400
So you can visit code.google.com/chrome/nativclient.
That gives you a full introduction to how

00:50:46.400 --> 00:50:55.549
to program this stuff, link to get the SDK.
There is an SDK. And a reference for pepper

00:50:55.549 --> 00:50:59.400
and there is all kinds of stuff in there,
some examples.

00:50:59.400 --> 00:51:05.569
This life example is actually in an open source
repo right now. It is called NaCl ports. NaCl

00:51:05.569 --> 00:51:11.729
ports contains a bunch of libraries that have
been ported to Native Client libz, tiny XML

00:51:11.729 --> 00:51:14.690
just to name a couple. There is a bunch in
there.

00:51:14.690 --> 00:51:23.869
Image Magic. SDL has been ported. So if you
have an SDL game, there is a NaCl port for

00:51:23.869 --> 00:51:26.549
that.
Visit us in the Chrome Sandbox. We've got

00:51:26.549 --> 00:51:35.529
some demos running. And if there's any feedback
for this, there's the tiny URL.

00:51:35.529 --> 00:51:44.559
[ Applause ]
&gt;&gt;&gt; Hi. Can you tell us what Google is using

00:51:44.559 --> 00:51:49.930
this for internally, or is it in products
that we're already using?

00:51:49.930 --> 00:51:54.109
&gt;&gt;David Springer: It's experimental. It is
actually -- it is an open source project.

00:51:54.109 --> 00:52:12.779
What can I say about it? 
Scientific community one, yeah, that's -- David

00:52:12.779 --> 00:52:23.069
Kernig's thing? It runs on app? No.
We have a scientific computing project going

00:52:23.069 --> 00:52:28.359
on within Google. That's about the only one
I know of internally.

00:52:28.359 --> 00:52:35.969
There is a bunch of external ones. There's
-- TCL port was done. And Unity, of course,

00:52:35.969 --> 00:52:44.630
runs on it. Yeah. SDL port was done.
&gt;&gt;&gt; One of the reasons to use NaCl is efficient

00:52:44.630 --> 00:52:55.039
usage for SMID instructions. I noticed that
in your manifest, there are only CPU architecture

00:52:55.039 --> 00:53:00.410
and each of those features several set of
SMID. So how do you handle this?

00:53:00.410 --> 00:53:08.700
&gt;&gt;David Springer: That manifest file didn't
have absolutely every switch in it. And we're

00:53:08.700 --> 00:53:13.369
still kind of working out some of those issues.
Yeah. But that's an excellent point.

00:53:13.369 --> 00:53:18.190
Let me take one from the back.
&gt;&gt;&gt; When you were talking about GPU access,

00:53:18.190 --> 00:53:23.229
were you talking about actual access to hardware
restorizers?

00:53:23.229 --> 00:53:26.779
&gt;&gt;David Springer: No, it is more open GLES2.
&gt;&gt;&gt; No, I mean like a hardware card as opposed

00:53:26.779 --> 00:53:28.309
to software restorizer.
&gt;&gt;David Springer: Yes, absolutely, yes.

00:53:28.309 --> 00:53:32.660
&gt;&gt;&gt; So historically, typically we have an
elevated group privilege for direct rendering

00:53:32.660 --> 00:53:38.199
simply because somebody will find out some
way to either gain knowledge they shouldn't

00:53:38.199 --> 00:53:44.890
have of the system or to make some kind of
attack using the hardware. And especially

00:53:44.890 --> 00:53:56.359
in closed source drivers, it has been a very
big problem.

00:53:56.359 --> 00:54:02.039
So what precautions are you taking to try
and mitigate this in NaCl?

00:54:02.039 --> 00:54:08.980
&gt;&gt;David Springer: We're tracking exactly what
WebGL does to solve the same problem.

00:54:08.980 --> 00:54:14.380
&gt;&gt;&gt; I should warn you that that's not enough
to keep people from potentially gaining information

00:54:14.380 --> 00:54:18.339
about other processes that are also direct
rendering to the same GPU.

00:54:18.339 --> 00:54:22.179
&gt;&gt;David Springer: Please get on our discussion
list and make your opinions known.

00:54:22.179 --> 00:54:28.749
&gt;&gt;&gt; Get on ours. Mesadev and dridevel@freedesktop.org.
&gt;&gt;David Springer: Thanks.

00:54:28.749 --> 00:54:35.509
&gt;&gt;&gt; Thank you.
&gt;&gt;&gt; Are there any performance hits when running

00:54:35.509 --> 00:54:38.430
your native code through the Sandbox that
you've noticed?

00:54:38.430 --> 00:54:48.029
&gt;&gt;David Springer: Yes, there are. We are generally
running between 5 and 10% hit. That's a very

00:54:48.029 --> 00:54:54.479
broad brush. There are cases -- there's degenerate
cases where it actually goes faster.

00:54:54.479 --> 00:54:56.920
But, you know, yes, there is a performance
hit.

00:54:56.920 --> 00:54:59.599
Back?
&gt;&gt;&gt; So you mentioned that in the Sandbox environment,

00:54:59.599 --> 00:55:03.789
of course, you can't access the FileSystem
directly. Java virtual machines with signed

00:55:03.789 --> 00:55:10.489
applets are able to do this still today. And
there certainly are some use cases where this

00:55:10.489 --> 00:55:15.099
is beneficial. For example, developing a Web-based
video editor, some sort of video manipulation,

00:55:15.099 --> 00:55:19.230
you don't want to transfer all of that data
up to a server and then back down again.

00:55:19.230 --> 00:55:25.719
Is there any kind of strategy that be used
for Native Client that you are aware of to

00:55:25.719 --> 00:55:29.819
sort accomplish that goal of accessing that
local resource without having to transfer

00:55:29.819 --> 00:55:33.609
it up to the server?
&gt;&gt;David Springer: We will track the HTML5

00:55:33.609 --> 00:55:41.750
file I/O APIs and implement that within pepper.
So the level of access that gives you is a

00:55:41.750 --> 00:55:44.700
level of access we'll give you in Native Client.
&gt;&gt;&gt; Thank you.

00:55:44.700 --> 00:55:48.849
&gt;&gt;David Springer: Okay. Front.
&gt;&gt;&gt; So from the JavaScript side, that 2D canvas

00:55:48.849 --> 00:55:53.469
you were drawing on from NaCl, is that data
readable, writable from JavaScript like we

00:55:53.469 --> 00:56:00.739
can do with a 2D canvas? Like getting the
raw bites and reading and writing them as

00:56:00.739 --> 00:56:03.159
well from JavaScript?
&gt;&gt;David Springer: We're working on that.

00:56:03.159 --> 00:56:06.420
&gt;&gt;&gt; So it would be like actually another communication
channel kind of between the NaCl side and

00:56:06.420 --> 00:56:07.900
the JavaScript side, reading, writing data
in bitmap, mmap, bitmap?

00:56:07.900 --> 00:56:08.900
&gt;&gt;David Springer: Correct.
&gt;&gt;&gt; Okay, cool.

00:56:08.900 --> 00:56:16.410
&gt;&gt;David Springer: Next?
&gt;&gt;&gt; So is the idea to move everything eventually

00:56:16.410 --> 00:56:24.690
to portable NaCl? And when you do that, what
sort of performance hit will you take additionally

00:56:24.690 --> 00:56:28.319
if you move to the portable version?
&gt;&gt;David Springer: I don't have an answer for

00:56:28.319 --> 00:56:29.809
that.
&gt;&gt;&gt; Okay.

00:56:29.809 --> 00:56:38.019
&gt;&gt;David Springer: Yeah. Sorry. Next?
&gt;&gt;&gt; Is there support for Native Sockets?

00:56:38.019 --> 00:56:43.829
&gt;&gt;David Springer: No, we will support the
same level as WebSockets support in terms

00:56:43.829 --> 00:56:47.999
of actually opening Sockets.
&gt;&gt;&gt; Okay, so, basically, not for traffic.

00:56:47.999 --> 00:56:51.119
We have to go through the Web layer, not through
the native code.

00:56:51.119 --> 00:56:58.200
&gt;&gt;David Springer: Right.
&gt;&gt;&gt; Thank you.

00:56:58.200 --> 00:57:22.619
&gt;&gt;David Springer: Okay.
&gt;&gt;&gt; It might be a silly question, I'm just

00:57:22.619 --> 00:57:24.809
wondering, you say it is an open source project.
Obviously, it will be in Chrome. Can we -- has

00:57:24.809 --> 00:57:26.420
there been any interest from other projects
like Mozilla to actually get this into other

00:57:26.420 --> 00:57:27.680
browsers? Is that something that's going to
potentially happen?

00:57:27.680 --> 00:57:28.680
Or as an app dev, I'm wondering if I'm only
going to be able to target Chrome users, basically.

00:57:28.680 --> 00:57:29.680
&gt;&gt;David Springer: I -- you know, we haven't
really heard anything. They're absolutely

00:57:29.680 --> 00:57:34.299
welcome to pick up the code base and make
a runtime that works in those browsers. I

00:57:34.299 --> 00:57:41.519
can't speak for Mozilla and those people.
&gt;&gt;&gt; All right. Thank you.

00:57:41.519 --> 00:57:46.160
&gt;&gt;David Springer: Sure.
All right. Thank you all for coming.

00:57:46.160 --> 00:57:46.299
[ Applause ]

