WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.500
[MUSIC PLAYING]

00:00:05.500 --> 00:00:08.109
CHET HAASE: Hi, welcome to
the animation talk on Friday

00:00:08.109 --> 00:00:09.160
afternoon.

00:00:09.160 --> 00:00:11.140
We are opposite a
[? Colin ?] talk,

00:00:11.140 --> 00:00:13.210
so I think that means that
everybody in this room

00:00:13.210 --> 00:00:15.820
didn't want to hear about
[? Colin. ?] Which is perfect,

00:00:15.820 --> 00:00:18.640
because we don't have any
[? Colin ?] on our slides.

00:00:18.640 --> 00:00:22.780
So, welcome, to the
not [? Colin ?] talk.

00:00:22.780 --> 00:00:23.680
I am Chet Haase.

00:00:23.680 --> 00:00:25.949
I'm from the Android
UI Toolkit team.

00:00:25.949 --> 00:00:26.990
DORIS LIU: I'm Doris Liu.

00:00:26.990 --> 00:00:28.780
I'm also on the Android
UI Toolkit team.

00:00:28.780 --> 00:00:31.030
CHET HAASE: And we're going
to tell you a little bit--

00:00:31.030 --> 00:00:32.446
actually, a lot--
about animation.

00:00:32.446 --> 00:00:34.600
We're going to talk
about small changes that

00:00:34.600 --> 00:00:36.550
were made to the existing
animator's stuff.

00:00:36.550 --> 00:00:39.820
Small, but very important, and
deceptively tricky to implement

00:00:39.820 --> 00:00:40.750
features.

00:00:40.750 --> 00:00:42.370
But, more importantly,
Doris is going

00:00:42.370 --> 00:00:46.060
to tell you all about a new
physics-based animation system,

00:00:46.060 --> 00:00:49.369
starting right about, now.

00:00:49.369 --> 00:00:50.160
DORIS LIU: Clicker.

00:00:54.260 --> 00:00:56.750
All right, so today,
I'm going to talk

00:00:56.750 --> 00:00:59.060
about physics-based animation.

00:00:59.060 --> 00:01:00.740
You might be
asking, why would we

00:01:00.740 --> 00:01:03.740
need a physics-based
animation library?

00:01:03.740 --> 00:01:06.770
A few years ago, before I
joined Android Firmware team,

00:01:06.770 --> 00:01:10.790
I was an app developer,
just like some of you.

00:01:10.790 --> 00:01:13.490
I wanted to create a swipe
animation for the Google camera

00:01:13.490 --> 00:01:17.810
app, and I had the camera menu
moving in a beautiful waveform,

00:01:17.810 --> 00:01:19.970
along with a gesture.

00:01:19.970 --> 00:01:23.450
I'd also track the velocity of
the gesture up until the moment

00:01:23.450 --> 00:01:25.370
of finger release.

00:01:25.370 --> 00:01:26.860
Then, I thought to myself--

00:01:26.860 --> 00:01:30.080
all right, now the only
thing that's missing in this

00:01:30.080 --> 00:01:32.660
is getting the camera
menu to continue

00:01:32.660 --> 00:01:36.990
the momentum of the gesture
once the finger is released.

00:01:36.990 --> 00:01:41.450
So I looked into the
Android animation framework

00:01:41.450 --> 00:01:43.610
for an API that
can take velocity

00:01:43.610 --> 00:01:46.190
as one of the
starting conditions,

00:01:46.190 --> 00:01:48.080
and close the gap for me.

00:01:48.080 --> 00:01:53.270
I looked, and looked, and
there was no such API.

00:01:53.270 --> 00:01:55.530
If you've had a similar
experience building animations

00:01:55.530 --> 00:01:57.692
in your app, you're in luck.

00:01:57.692 --> 00:01:59.150
Because, today,
we're going to talk

00:01:59.150 --> 00:02:01.371
about the new physics-based
animation library

00:02:01.371 --> 00:02:02.495
that we have just released.

00:02:05.330 --> 00:02:09.350
You might be asking, how is
this new physics-based animation

00:02:09.350 --> 00:02:13.030
library any different than
the existing animation API?

00:02:13.030 --> 00:02:15.770
Well, if you're familiar with
the existing animation API,

00:02:15.770 --> 00:02:18.800
you know in order to
create an animation,

00:02:18.800 --> 00:02:23.920
you need to provide a start
value, an end value, duration,

00:02:23.920 --> 00:02:25.980
and an interpolator.

00:02:25.980 --> 00:02:29.270
Velocity-- that's
just an afterthought.

00:02:29.270 --> 00:02:32.270
Once such an
animation is created,

00:02:32.270 --> 00:02:34.880
velocity has to be derived
from other properties

00:02:34.880 --> 00:02:37.010
of the animation.

00:02:37.010 --> 00:02:39.560
Given that, it's
extremely difficult

00:02:39.560 --> 00:02:41.750
to create an animation
that can continue

00:02:41.750 --> 00:02:48.170
the momentum of the gesture
once that's leading up

00:02:48.170 --> 00:02:50.060
to the animation.

00:02:50.060 --> 00:02:53.660
But with physics-based
animation,

00:02:53.660 --> 00:02:56.420
it can handle the
different gestures

00:02:56.420 --> 00:02:59.930
with the different
velocities much easier.

00:02:59.930 --> 00:03:04.340
Different gestures from small
swipe to a really fast fling.

00:03:04.340 --> 00:03:07.790
Also because the movements of
the animation in the new system

00:03:07.790 --> 00:03:10.730
are governed by
real-world physics,

00:03:10.730 --> 00:03:15.000
they look more
natural and lifelike.

00:03:15.000 --> 00:03:19.440
And the new system can also
respond to updated user input,

00:03:19.440 --> 00:03:22.560
and dynamically change the
target value of the animation

00:03:22.560 --> 00:03:23.842
during the animation.

00:03:24.990 --> 00:03:26.700
Now let's take a
look at how different

00:03:26.700 --> 00:03:28.910
animation systems
handle this target value

00:03:28.910 --> 00:03:31.470
change during the animation.

00:03:31.470 --> 00:03:34.600
Here, we're using
an object animator.

00:03:34.600 --> 00:03:37.950
I think some of you might
be familiar with this.

00:03:37.950 --> 00:03:41.040
And, the target
value is indicated

00:03:41.040 --> 00:03:43.610
by the position of the
green ring on the bottom.

00:03:43.610 --> 00:03:47.040
As you can see, the ring had
moved before the animation

00:03:47.040 --> 00:03:48.120
is finished.

00:03:48.120 --> 00:03:51.780
And usually, the way we
handle this is we would stop--

00:03:51.780 --> 00:03:54.420
we would cancel the
ongoing animation,

00:03:54.420 --> 00:03:58.460
and then reconfigure the
animation using the new end

00:03:58.460 --> 00:04:00.900
value, and then
starting it again.

00:04:00.900 --> 00:04:04.080
But, the problem with
that is, as you can see,

00:04:04.080 --> 00:04:10.000
it leads to a really sudden and
abrupt change in the movement.

00:04:10.000 --> 00:04:15.060
And if we look at the velocity
chart for this animation,

00:04:15.060 --> 00:04:20.610
the blue and red curves in here
represent the velocity x and y.

00:04:20.610 --> 00:04:23.100
At the moment of
target value change,

00:04:23.100 --> 00:04:27.250
the velocities are dropped
immediately back down to 0.

00:04:27.250 --> 00:04:32.009
And that's because we have
canceled the ongoing animation.

00:04:32.009 --> 00:04:34.050
And then the velocities
will start changing again

00:04:34.050 --> 00:04:36.030
once the new animation starts.

00:04:36.030 --> 00:04:39.030
But this discontinuity
in velocity

00:04:39.030 --> 00:04:41.460
can create a really jarring
experience for the user.

00:04:44.250 --> 00:04:48.990
In contrast, here's
physics-based animation.

00:04:48.990 --> 00:04:52.080
When the target value is changed
in physics-based animation,

00:04:52.080 --> 00:04:56.010
we interpret that as a
change in the physics force.

00:04:56.010 --> 00:04:57.990
And then the new
force will continue

00:04:57.990 --> 00:05:01.770
to act upon the existing
velocity of the object, which

00:05:01.770 --> 00:05:06.300
is why we won't see a
velocity discontinuity.

00:05:06.300 --> 00:05:11.580
And in this example we can see
the transition to a new target

00:05:11.580 --> 00:05:15.070
position is really smooth.

00:05:15.070 --> 00:05:18.070
And, similarly, let's look
at the velocity chart--

00:05:18.070 --> 00:05:21.930
we're no longer seeing any
discontinuity in the velocity,

00:05:21.930 --> 00:05:26.090
and that is the key
to a smooth animation.

00:05:26.090 --> 00:05:28.580
At this point, you
might be asking,

00:05:28.580 --> 00:05:32.580
so what exactly is this
physics-based animation?

00:05:32.580 --> 00:05:35.220
The way we define it
is it's an animation

00:05:35.220 --> 00:05:36.990
that's driven by force.

00:05:36.990 --> 00:05:39.450
And based on the force we can
calculate the acceleration

00:05:39.450 --> 00:05:41.640
or deceleration,
which we can then

00:05:41.640 --> 00:05:45.390
use to calculate and
update the velocities

00:05:45.390 --> 00:05:48.630
and values for the
animation, until finally,

00:05:48.630 --> 00:05:51.540
when the force reaches
equilibrium, that's our signal

00:05:51.540 --> 00:05:53.013
to stop the animation.

00:05:56.640 --> 00:05:59.382
First, let's take a
look at Fling Animation.

00:05:59.382 --> 00:06:02.850
Fling Animation starts
with the initial velocity--

00:06:02.850 --> 00:06:06.150
and usually that's the
velocity of your gesture--

00:06:06.150 --> 00:06:08.260
and then it would
continue that momentum,

00:06:08.260 --> 00:06:11.140
and then gradually
comes to a stop.

00:06:11.140 --> 00:06:14.970
The force behind Fling
Animation is a friction force,

00:06:14.970 --> 00:06:18.090
which is proportional
to the velocity.

00:06:18.090 --> 00:06:19.800
What that means
is, velocity will

00:06:19.800 --> 00:06:24.560
undergo an exponential decay in
the duration of the animation,

00:06:24.560 --> 00:06:29.590
and that will produce a very
graceful end to the animation.

00:06:29.590 --> 00:06:31.830
And, by the way,
this Fling Animation

00:06:31.830 --> 00:06:33.930
is exactly the API
that I was looking for,

00:06:33.930 --> 00:06:36.627
years ago, when I was building
the animation for the camera

00:06:36.627 --> 00:06:37.127
app.

00:06:39.750 --> 00:06:42.884
Now let's see an example
for the Fling Animation.

00:06:45.550 --> 00:06:49.820
Here as you can see, I'm fling
this list from left to right,

00:06:49.820 --> 00:06:54.100
and the orange dot is indicating
the position of my finger.

00:06:54.100 --> 00:06:58.180
And the list just took off at
the same velocity of my gesture

00:06:58.180 --> 00:07:00.340
and then gradually
come to a rest.

00:07:03.320 --> 00:07:05.360
Now let's see how
this is achieved.

00:07:05.360 --> 00:07:09.830
In order to get notified
when a fling gesture occurs,

00:07:09.830 --> 00:07:12.740
we need to create
a gesture listener.

00:07:12.740 --> 00:07:16.760
And once the fling
gesture is detected,

00:07:16.760 --> 00:07:18.920
we receive this
onFling callback,

00:07:18.920 --> 00:07:22.070
with a down event, an up
event, and a velocity,

00:07:22.070 --> 00:07:25.510
both x- and y-axis.

00:07:25.510 --> 00:07:26.630
Now, we'll be using--

00:07:26.630 --> 00:07:29.960
and they'll be in the unit
pixels per second, which

00:07:29.960 --> 00:07:32.720
is also the unit that we'll
be using for the velocities

00:07:32.720 --> 00:07:36.540
in the new animation system.

00:07:36.540 --> 00:07:40.220
And now we're ready to
create a Fling Animation.

00:07:40.220 --> 00:07:42.120
To the constructor of
the Fling Animation,

00:07:42.120 --> 00:07:45.290
we need to provide the
object we want to animate.

00:07:45.290 --> 00:07:48.680
In this case, it's that
list of bearded androids.

00:07:48.680 --> 00:07:50.780
And the property that
we want to animate,

00:07:50.780 --> 00:07:52.410
in this case, that
is the square x,

00:07:52.410 --> 00:07:57.170
since we want to fling
this list horizontally.

00:07:57.170 --> 00:08:00.320
And now, we're going to
set the start velocity.

00:08:00.320 --> 00:08:02.990
Here you can see I
have [? inversed ?]

00:08:02.990 --> 00:08:06.500
the velocity of the gesture,
and that's because here we're

00:08:06.500 --> 00:08:09.480
animating the scroll property.

00:08:09.480 --> 00:08:11.640
The scroll property
is sort of special,

00:08:11.640 --> 00:08:15.410
in that a positive change
in the scroll value

00:08:15.410 --> 00:08:18.740
would actually move the list
in the opposite direction

00:08:18.740 --> 00:08:22.855
as a positive velocity would.

00:08:22.855 --> 00:08:24.980
And then, we're also going
to set min value and max

00:08:24.980 --> 00:08:28.220
value to define the
range for this animation.

00:08:28.220 --> 00:08:30.260
Fling Animation
will end immediately

00:08:30.260 --> 00:08:34.640
once it reaches either its
min value or max value.

00:08:34.640 --> 00:08:37.220
And I would encourage
you to set a good value

00:08:37.220 --> 00:08:39.440
range for your animation,
so that as soon

00:08:39.440 --> 00:08:41.840
as the animation
goes off screen,

00:08:41.840 --> 00:08:44.690
it should stop right away.

00:08:44.690 --> 00:08:46.190
Otherwise, the
animation might go on

00:08:46.190 --> 00:08:48.860
for too long without making
any change on screen,

00:08:48.860 --> 00:08:51.680
while it would
request for redraws

00:08:51.680 --> 00:08:55.820
and consume a lot of battery.

00:08:55.820 --> 00:08:57.710
And finally, we're
setting friction

00:08:57.710 --> 00:09:01.250
to control the rate
of deceleration.

00:09:01.250 --> 00:09:02.630
Now we're ready to start.

00:09:02.630 --> 00:09:08.010
So this is all it takes to
create a Fling Animation.

00:09:08.010 --> 00:09:10.680
Now let's take a closer
look at the fling friction.

00:09:10.680 --> 00:09:13.860
Here, I'm going to create
an animation for the view's

00:09:13.860 --> 00:09:16.170
SCROLL_Y property,
with a starting

00:09:16.170 --> 00:09:20.662
velocity of 5,000 pixels per
second, and a friction of 1.1.

00:09:20.662 --> 00:09:22.620
And then, I'm going to
create another animation

00:09:22.620 --> 00:09:24.730
with the exact same
setup, except we're

00:09:24.730 --> 00:09:27.660
going to double the friction.

00:09:27.660 --> 00:09:30.190
And if we run these two
animations side by side,

00:09:30.190 --> 00:09:32.580
we can see how the
friction affects

00:09:32.580 --> 00:09:34.342
the look of the animation.

00:09:37.180 --> 00:09:42.100
As you can see, here, with
a smaller value of friction,

00:09:42.100 --> 00:09:45.550
the animation would go on
for much longer, whereas when

00:09:45.550 --> 00:09:47.760
the friction is
higher, naturally,

00:09:47.760 --> 00:09:50.440
it decelerates the
movement a lot faster,

00:09:50.440 --> 00:09:53.250
causing the animation
to stop a lot sooner.

00:09:53.250 --> 00:09:58.660
You can configure the friction
to whatever positive value that

00:09:58.660 --> 00:10:00.412
looks good for your animation.

00:10:04.999 --> 00:10:06.540
In addition to Fling
Animation, we've

00:10:06.540 --> 00:10:10.740
also introduced Spring Animation
in our new animation system.

00:10:13.620 --> 00:10:16.360
Now first let's create
a Spring Animation.

00:10:16.360 --> 00:10:18.360
Here to the constructor
of the Spring Animation,

00:10:18.360 --> 00:10:22.050
we're going to supply the
object we want to animate.

00:10:22.050 --> 00:10:23.730
In this case, it's a view.

00:10:23.730 --> 00:10:25.590
But, it doesn't
have to be a view.

00:10:25.590 --> 00:10:27.529
It can be any object.

00:10:27.529 --> 00:10:29.820
And then the property we want
to animate, in this case,

00:10:29.820 --> 00:10:32.650
is a TRANSLATION_Y of the view.

00:10:32.650 --> 00:10:36.300
And then finally, the resting
position of the Spring.

00:10:36.300 --> 00:10:37.560
Now we're ready to start.

00:10:37.560 --> 00:10:41.000
So this animation
with the animated--

00:10:41.000 --> 00:10:45.060
the view from
whatever translation

00:10:45.060 --> 00:10:49.460
that he had at the start of
the animation to-- back to 0.

00:10:49.460 --> 00:10:50.710
Now here's what it looks like.

00:10:50.710 --> 00:10:54.660
As you can see, as I'm pulling
this little android down,

00:10:54.660 --> 00:10:58.140
his moving is TRANSLATION_Y,
while stretching the spring,

00:10:58.140 --> 00:10:59.227
as it goes.

00:10:59.227 --> 00:11:01.560
And then once I let go, that's
when the spring animation

00:11:01.560 --> 00:11:03.060
would start.

00:11:03.060 --> 00:11:04.730
And then, the
TRANSLATION_Y would

00:11:04.730 --> 00:11:09.110
start from where I
released it back to 0.

00:11:09.110 --> 00:11:12.210
You can see, it bounces back
up and oscillates a little bit

00:11:12.210 --> 00:11:17.310
before he rests at a
TRANSLATION_Y of 0.

00:11:17.310 --> 00:11:19.530
And if you feel
adventurous, you can also

00:11:19.530 --> 00:11:21.600
change the bounciness
of the spring

00:11:21.600 --> 00:11:23.497
by simply setting
the damping ratio.

00:11:23.497 --> 00:11:25.205
Here we're going to
set the damping ratio

00:11:25.205 --> 00:11:27.810
to not bouncy at all.

00:11:27.810 --> 00:11:30.127
And that's what we
see in the animation.

00:11:30.127 --> 00:11:31.710
If you look at this
animation, and you

00:11:31.710 --> 00:11:33.600
feel like, this
doesn't really match

00:11:33.600 --> 00:11:36.840
your taste for
Spring Animations,

00:11:36.840 --> 00:11:37.860
we have an easy fix.

00:11:37.860 --> 00:11:41.550
You can simply change the
damping ratio to high bouncy,

00:11:41.550 --> 00:11:43.740
and then you will have
a very bouncy animation,

00:11:43.740 --> 00:11:47.880
with a lot of oscillation
before it finally settles.

00:11:47.880 --> 00:11:50.490
In addition to
damping ratio, you

00:11:50.490 --> 00:11:53.220
can also change the stiffness
for the spring, which

00:11:53.220 --> 00:11:56.040
will control how quickly
the object returns

00:11:56.040 --> 00:11:58.620
to his resting position.

00:11:58.620 --> 00:12:01.420
And we'll take a look
at that in a moment.

00:12:01.420 --> 00:12:03.700
Now, before we
start the animation,

00:12:03.700 --> 00:12:07.530
we can also set some starting
conditions for the animation.

00:12:07.530 --> 00:12:11.160
For example, if we set
the start value to 200,

00:12:11.160 --> 00:12:17.130
this animation will go from the
TRANSLATION_Y of 200 back to 0.

00:12:17.130 --> 00:12:19.950
And also we can set
the start velocity

00:12:19.950 --> 00:12:23.310
to match the existing
movement of the object,

00:12:23.310 --> 00:12:26.100
creating a continuous motion.

00:12:26.100 --> 00:12:28.970
We can also set the min
value and max value,

00:12:28.970 --> 00:12:32.100
like we did for Fling
Animation, and define

00:12:32.100 --> 00:12:35.340
the range for the animation.

00:12:35.340 --> 00:12:36.390
Now we're ready to start.

00:12:38.940 --> 00:12:42.900
Let's take a look at the
stiffness, from low to high.

00:12:42.900 --> 00:12:46.130
Here we have-- if you
look on the very left,

00:12:46.130 --> 00:12:49.350
when the stiffness is
very low, the spring

00:12:49.350 --> 00:12:52.320
compresses rather slowly
after it is stretched out

00:12:52.320 --> 00:12:54.750
of its resting position.

00:12:54.750 --> 00:12:59.070
So when the stiffness gets
higher, towards the right,

00:12:59.070 --> 00:13:02.190
it bounces back up much faster.

00:13:02.190 --> 00:13:04.840
And these are the
force, spring, stiffness

00:13:04.840 --> 00:13:08.970
constants that we have
already defined in our system,

00:13:08.970 --> 00:13:13.320
because they each provide
a somewhat unique look.

00:13:13.320 --> 00:13:17.190
You can use one of these
already-defined constants,

00:13:17.190 --> 00:13:21.370
or you can use any positive
float value for the spring

00:13:21.370 --> 00:13:23.057
stiffness in your animation.

00:13:26.040 --> 00:13:29.290
Now that we've seen how
we can animate translation

00:13:29.290 --> 00:13:32.590
using Spring
Animation, let's see

00:13:32.590 --> 00:13:35.620
what we can do when we
combine the rotation

00:13:35.620 --> 00:13:39.534
and translation together
in the Spring Animations.

00:13:42.500 --> 00:13:44.900
Here we have an example of that.

00:13:44.900 --> 00:13:48.020
As you can see, as
this list flies in,

00:13:48.020 --> 00:13:50.450
each individual head
sort of shakes around

00:13:50.450 --> 00:13:53.660
as if they were hanging
on to a clothesline

00:13:53.660 --> 00:13:55.970
they were pulling in.

00:13:55.970 --> 00:13:59.390
To achieve this, we need to
apply a rotational spring force

00:13:59.390 --> 00:14:03.800
on each individual head, along
with a translation animation

00:14:03.800 --> 00:14:05.150
to slide this whole list in.

00:14:08.310 --> 00:14:11.780
First, we need to rotate
each individual head.

00:14:11.780 --> 00:14:14.390
We need to go through all
the items on the list,

00:14:14.390 --> 00:14:19.880
and for each item we will need
to create a Spring Animation

00:14:19.880 --> 00:14:22.410
on his rotation property.

00:14:22.410 --> 00:14:25.340
And you may have noticed, here,
I'm using a different Spring

00:14:25.340 --> 00:14:28.100
Animation constructor,
as we did before.

00:14:28.100 --> 00:14:30.050
And this constructor
doesn't require

00:14:30.050 --> 00:14:34.970
a third parameter, which is the
resting position of the spring.

00:14:34.970 --> 00:14:37.280
When using this constructor,
the spring animation

00:14:37.280 --> 00:14:42.220
won't create built-in
spring force.

00:14:42.220 --> 00:14:45.890
And it will instead expect
a custom spring force

00:14:45.890 --> 00:14:47.414
to be passed in.

00:14:47.414 --> 00:14:48.830
And that's what
we're going to do.

00:14:48.830 --> 00:14:50.380
We're going to create
a custom spring

00:14:50.380 --> 00:14:53.510
force of a resting
position of 0,

00:14:53.510 --> 00:14:55.640
and a damping ratio
and stiffness,

00:14:55.640 --> 00:14:58.220
that looks good for this
particular animation,

00:14:58.220 --> 00:15:02.100
arrived at through
careful experimentation.

00:15:02.100 --> 00:15:04.010
And you might ask,
why do we want

00:15:04.010 --> 00:15:07.150
to use a custom spring force,
instead of the built-in spring

00:15:07.150 --> 00:15:08.480
force?

00:15:08.480 --> 00:15:11.820
And the answer is, by creating
a custom spring force,

00:15:11.820 --> 00:15:15.290
we can then share this spring
force across all the spring

00:15:15.290 --> 00:15:17.720
animations for the children.

00:15:17.720 --> 00:15:22.820
Note this is only viable when
all the spring animations here

00:15:22.820 --> 00:15:26.350
expect the same spring constants
and the same resting position.

00:15:29.600 --> 00:15:33.170
And finally, we can set the
start value of the rotation

00:15:33.170 --> 00:15:36.020
animation to minus 25,
so that each head would

00:15:36.020 --> 00:15:38.270
rotate from a minus
25 degree angle,

00:15:38.270 --> 00:15:40.830
and then oscillate
around 0 degree

00:15:40.830 --> 00:15:42.080
and eventually come to a stop.

00:15:47.810 --> 00:15:49.730
Now that we've rotated
each individual head,

00:15:49.730 --> 00:15:52.480
we still need to slide
this whole list in.

00:15:52.480 --> 00:15:57.050
We can do that by creating a
Spring Animation for the list

00:15:57.050 --> 00:15:58.500
on his translation x property.

00:16:01.240 --> 00:16:02.860
And similar to the
rotation animation,

00:16:02.860 --> 00:16:05.214
we are going to configure
the spring constants.

00:16:05.214 --> 00:16:06.880
Here, we're going to
use the same spring

00:16:06.880 --> 00:16:09.181
constants as we did before.

00:16:09.181 --> 00:16:11.180
And finally, we're going
to set the start value,

00:16:11.180 --> 00:16:15.010
so that the TRANSLATION_Y
will start from 400

00:16:15.010 --> 00:16:16.750
and then slide back into place.

00:16:21.000 --> 00:16:24.460
So we've seen Spring
Animations on rotation

00:16:24.460 --> 00:16:26.810
and with translation.

00:16:26.810 --> 00:16:28.510
What if you want to
animate something

00:16:28.510 --> 00:16:30.700
that's not a view property?

00:16:30.700 --> 00:16:33.430
Well, good news is, Physics
Animation supports that.

00:16:37.670 --> 00:16:39.940
Here's an example of that.

00:16:39.940 --> 00:16:44.860
As you can see, when I tap
on the little mustache icon,

00:16:44.860 --> 00:16:48.460
all the items just pop in,
blow up beyond its normal size,

00:16:48.460 --> 00:16:49.930
and then shrink
back down, making

00:16:49.930 --> 00:16:53.150
a very dramatic entrance.

00:16:53.150 --> 00:16:56.530
And we could achieve
this by creating not one,

00:16:56.530 --> 00:17:00.890
but two spring animations
for each individual child--

00:17:00.890 --> 00:17:03.100
one on his SCALE_X
property, the other one

00:17:03.100 --> 00:17:05.280
on his SCALE_Y property.

00:17:05.280 --> 00:17:08.470
So the each
individual head would

00:17:08.470 --> 00:17:13.630
be able to scale along both
x- and y-axis, uniformly.

00:17:13.630 --> 00:17:15.609
But, that's a lot of work.

00:17:15.609 --> 00:17:18.099
Now let me show you a
different way to do this.

00:17:18.099 --> 00:17:22.440
Imagine, what if view
group had this property--

00:17:22.440 --> 00:17:24.400
let's call it child scale--

00:17:24.400 --> 00:17:27.250
and whenever child
scale changes,

00:17:27.250 --> 00:17:29.710
the view group would
propagate down that change

00:17:29.710 --> 00:17:33.910
to all its children, in both
the SCALE_X property and SCALE_Y

00:17:33.910 --> 00:17:35.330
property.

00:17:35.330 --> 00:17:37.570
And in that case, we can
just animate this one child

00:17:37.570 --> 00:17:41.740
scale for the viewer
group, and then we're done.

00:17:41.740 --> 00:17:44.440
Even though view group doesn't
really have this property,

00:17:44.440 --> 00:17:46.110
we can create one for it.

00:17:46.110 --> 00:17:48.850
Here, we're going to create
a custom property using

00:17:48.850 --> 00:17:51.580
float property compat.

00:17:51.580 --> 00:17:53.800
And we're going to have
to override the set value

00:17:53.800 --> 00:17:54.470
and get value.

00:17:58.050 --> 00:17:59.890
Whenever the child
scale changes,

00:17:59.890 --> 00:18:02.659
we will receive this
set value call back.

00:18:02.659 --> 00:18:04.200
And in that, like
we mentioned, we're

00:18:04.200 --> 00:18:06.960
going to pass down the
change to all the children,

00:18:06.960 --> 00:18:09.215
and then change their
SCALE_X and SCALE_Y

00:18:09.215 --> 00:18:10.490
property, uniformly.

00:18:13.180 --> 00:18:16.190
And, in the get value--

00:18:16.190 --> 00:18:18.230
since we're assuming
all the children

00:18:18.230 --> 00:18:19.940
to have the same
scale, we can just

00:18:19.940 --> 00:18:22.190
return the scale of any child.

00:18:22.190 --> 00:18:26.240
In this case, we'll just
return the first child.

00:18:26.240 --> 00:18:28.610
Now that we've created
this custom property,

00:18:28.610 --> 00:18:30.680
we can put it in an animation.

00:18:30.680 --> 00:18:34.100
So, we're going to create an
animation on the child scale

00:18:34.100 --> 00:18:38.180
property for the list of beards.

00:18:38.180 --> 00:18:40.880
And again, we're going
to set the stiffness.

00:18:40.880 --> 00:18:44.690
If you remember, stiffness
changes how quickly the object

00:18:44.690 --> 00:18:46.490
return to its resting position.

00:18:46.490 --> 00:18:50.480
Here, because we want the scale
change to be more graceful,

00:18:50.480 --> 00:18:52.910
we want to use a low stiffness.

00:18:52.910 --> 00:18:56.600
And finally, we're going to
set the minimum visible change.

00:18:56.600 --> 00:18:59.360
And this is a method that
we haven't seen before.

00:18:59.360 --> 00:19:01.940
What it does is it provides
the animation system

00:19:01.940 --> 00:19:05.822
a hint as to when it would
be a good time to stop,

00:19:05.822 --> 00:19:07.280
so that the animation
doesn't go on

00:19:07.280 --> 00:19:12.060
for too long without making
any visible change on screen.

00:19:12.060 --> 00:19:15.080
And the reason we haven't
seen this method before,

00:19:15.080 --> 00:19:17.150
in all these
previous examples, is

00:19:17.150 --> 00:19:19.160
because up until
this example, we

00:19:19.160 --> 00:19:22.840
had it animated only the
built-in view properties.

00:19:22.840 --> 00:19:25.280
And when we use-- when
we animate built-in view

00:19:25.280 --> 00:19:29.540
properties, the animation system
can derive such a value from--

00:19:29.540 --> 00:19:33.340
based on which property
is being animated.

00:19:37.320 --> 00:19:39.800
If you create a
custom property, you

00:19:39.800 --> 00:19:43.130
will need to provide the
smallest change in your custom

00:19:43.130 --> 00:19:47.750
property that can make a
visible difference on screen.

00:19:47.750 --> 00:19:49.910
In our case, we're
animating childScale,

00:19:49.910 --> 00:19:53.160
which is essentially
a scale property,

00:19:53.160 --> 00:19:57.330
so we're going to use the
already defined constant--

00:19:57.330 --> 00:20:00.800
min visible change scale.

00:20:00.800 --> 00:20:04.255
And then, we can set
the start value to 0.5,

00:20:04.255 --> 00:20:07.060
so that the scale animation
starts from a half scale

00:20:07.060 --> 00:20:09.360
and then blow up.

00:20:09.360 --> 00:20:11.620
And then, eventually,
it will settle

00:20:11.620 --> 00:20:15.900
at scale of 1, its normal size.

00:20:15.900 --> 00:20:18.240
So we've talked about
Fling Animation.

00:20:18.240 --> 00:20:20.220
We've also seen
some cool effects

00:20:20.220 --> 00:20:23.130
from the Spring Animations.

00:20:23.130 --> 00:20:25.830
Let's see what we can create
by combining these two.

00:20:29.600 --> 00:20:32.780
Here, we're going to use
the same example as we did--

00:20:32.780 --> 00:20:36.500
our same list as we did
for the Fling Animation.

00:20:36.500 --> 00:20:39.620
As you can see, I'm flinging
this list back and forth.

00:20:39.620 --> 00:20:42.560
But, as the Fling Animation
gets to the end of the list,

00:20:42.560 --> 00:20:43.970
there's still some
velocity left.

00:20:43.970 --> 00:20:47.000
There's still some
remaining energy.

00:20:47.000 --> 00:20:50.090
And that's when the list
starts to stretch out

00:20:50.090 --> 00:20:52.260
and snap back,
like a rubber band.

00:20:54.780 --> 00:20:57.120
This is a very playful way for--

00:20:57.120 --> 00:20:58.770
to dissipate the
remaining energy

00:20:58.770 --> 00:21:01.327
when arriving at
the end of the list.

00:21:01.327 --> 00:21:02.910
And I think that
you'll agree with me,

00:21:02.910 --> 00:21:05.820
this is a much better
experience than harshly stopping

00:21:05.820 --> 00:21:09.780
the motion and losing
all the momentum.

00:21:09.780 --> 00:21:13.120
In order to achieve this, we
first need a Fling Animation,

00:21:13.120 --> 00:21:15.420
and we're going to just use
the same Fling Animation,

00:21:15.420 --> 00:21:18.280
as we did before.

00:21:18.280 --> 00:21:21.060
Except, this time, I'm going
to call out the setMinValue

00:21:21.060 --> 00:21:22.890
and setMaxValue.

00:21:22.890 --> 00:21:25.710
These defined the
range of the animation,

00:21:25.710 --> 00:21:27.240
like we mentioned before.

00:21:27.240 --> 00:21:29.880
But this range ensures
that the Fling Animation

00:21:29.880 --> 00:21:32.520
would end immediately
upon reaching

00:21:32.520 --> 00:21:35.070
either end of the list.

00:21:35.070 --> 00:21:38.370
And that's when we can start the
Spring Animation to then take

00:21:38.370 --> 00:21:43.620
over whatever momentum
that it has left.

00:21:43.620 --> 00:21:46.260
So in order to start a Spring
Animation right after the Fling

00:21:46.260 --> 00:21:49.650
Animation, here we're going
to use an onAnimation update

00:21:49.650 --> 00:21:50.920
listener.

00:21:50.920 --> 00:21:52.680
Once the Fling
Animation finishes,

00:21:52.680 --> 00:21:56.160
we'll receive this all
animation callback with a Fling

00:21:56.160 --> 00:21:58.380
animation, whether
or not it's canceled,

00:21:58.380 --> 00:22:01.357
and then the scrolling value
and the scrolling velocity.

00:22:05.470 --> 00:22:08.030
If the velocity is
high enough, then we're

00:22:08.030 --> 00:22:10.460
going to create the
Spring Animation

00:22:10.460 --> 00:22:13.284
for the stretching effect.

00:22:13.284 --> 00:22:15.200
And we're going to create
the Spring Animation

00:22:15.200 --> 00:22:18.500
for this whole list on
his SCALE_X property,

00:22:18.500 --> 00:22:21.230
so he can stretch horizontally.

00:22:21.230 --> 00:22:24.560
And, as always, we're
changing the spring constants

00:22:24.560 --> 00:22:29.550
to make the animation look
good, for this particular case.

00:22:29.550 --> 00:22:31.760
And finally, we're going
to set the start velocity.

00:22:31.760 --> 00:22:35.540
Here, you might notice, I'm
not using the velocity that I

00:22:35.540 --> 00:22:37.700
received from this
callback, because that's

00:22:37.700 --> 00:22:40.580
the scrolling velocity,
which is a pixel-based.

00:22:40.580 --> 00:22:43.490
And for our scale
animation, we want something

00:22:43.490 --> 00:22:47.540
that's in terms of scale.

00:22:47.540 --> 00:22:51.740
We can do that conversion by
simply dividing the velocity

00:22:51.740 --> 00:22:52.850
by the size of the menu.

00:23:01.084 --> 00:23:02.500
Now before we
start, we still need

00:23:02.500 --> 00:23:06.550
to configure one last thing,
which is the pivot point.

00:23:06.550 --> 00:23:10.150
And that's for the scaling.

00:23:10.150 --> 00:23:12.670
As you can see, I'm
really flinging this list

00:23:12.670 --> 00:23:16.460
back and forth, and depending
on which way I'm flinging it,

00:23:16.460 --> 00:23:19.540
I want the stretching to go
the same way as the scrolling

00:23:19.540 --> 00:23:21.040
direction.

00:23:21.040 --> 00:23:23.700
So when the velocity
is negative,

00:23:23.700 --> 00:23:26.060
the list is scrolling
to the right,

00:23:26.060 --> 00:23:29.830
and I want the stretching to
go towards the right, as well.

00:23:29.830 --> 00:23:33.800
That requires us to pin
the list on his left side,

00:23:33.800 --> 00:23:37.210
and we can do so by
setting the pivot x to 0.

00:23:37.210 --> 00:23:40.560
Similarly, when the list
is scrolling to the left,

00:23:40.560 --> 00:23:42.530
we want to pin the
list on his right side.

00:23:42.530 --> 00:23:45.310
And we can do so by
setting the pivot point

00:23:45.310 --> 00:23:47.890
to the right side
of the list, which

00:23:47.890 --> 00:23:49.990
is the width of this list.

00:23:55.110 --> 00:23:58.290
What we've seen, each
individual animations,

00:23:58.290 --> 00:24:03.430
each individual Spring
Animations in the past slides--

00:24:03.430 --> 00:24:06.250
I think we can create something
that's more advanced, and more

00:24:06.250 --> 00:24:10.390
complex, if we build on top of
that, such as Chained Springs.

00:24:13.470 --> 00:24:16.890
Here we have three views
that are chained together

00:24:16.890 --> 00:24:19.200
via spring force.

00:24:19.200 --> 00:24:22.050
And you can see, I'm
dragging the top view around,

00:24:22.050 --> 00:24:26.700
and the white circle
indicates the drag point.

00:24:26.700 --> 00:24:29.820
The other two views would
follow as the top view is moving

00:24:29.820 --> 00:24:32.880
around as if the three of them
were attached to each other

00:24:32.880 --> 00:24:35.560
by a bungee cord.

00:24:35.560 --> 00:24:38.850
Now let's take a look at
how we can achieve this.

00:24:38.850 --> 00:24:43.300
Let's name these three
views Lead, A, and B

00:24:43.300 --> 00:24:45.750
for easier reference.

00:24:45.750 --> 00:24:48.670
So our goal is to have
A follow the lead,

00:24:48.670 --> 00:24:52.870
as Lead is being dragged
around, and B follow A.

00:24:52.870 --> 00:24:57.240
And we're going to achieve this
by using Spring Animations.

00:24:57.240 --> 00:25:01.410
Let's first take a look at how
we can have A follow the lead.

00:25:01.410 --> 00:25:03.135
So first we're going
to create animations

00:25:03.135 --> 00:25:09.780
for a, on its TRANSLATION_X
and TRANSLATION_Y properties.

00:25:09.780 --> 00:25:11.280
And [INAUDIBLE]
touch listener where

00:25:11.280 --> 00:25:13.590
we're going to process
the touch events

00:25:13.590 --> 00:25:17.700
and move the lead view around.

00:25:17.700 --> 00:25:19.470
We're going to first--

00:25:19.470 --> 00:25:22.890
for each move event, we're
going to compare this event

00:25:22.890 --> 00:25:25.520
against the last event
in terms of position.

00:25:25.520 --> 00:25:27.300
And then if we
calculate the delta,

00:25:27.300 --> 00:25:28.920
and this delta
would be the amount

00:25:28.920 --> 00:25:31.530
of movement of the finger.

00:25:31.530 --> 00:25:34.180
And then we're going to apply
the delta to the lead view's

00:25:34.180 --> 00:25:37.260
position, so that the
lead view would be moving

00:25:37.260 --> 00:25:40.270
the same amount as the finger.

00:25:40.270 --> 00:25:42.240
Once the lead view's
position is updated,

00:25:42.240 --> 00:25:44.450
we want to update
the position of--

00:25:44.450 --> 00:25:48.325
or the animation for
A, so it appears like A

00:25:48.325 --> 00:25:49.485
is following the lead.

00:25:49.485 --> 00:25:52.110
And, here, we're going
to use a method called

00:25:52.110 --> 00:25:53.540
animateToFinalPosition.

00:25:53.540 --> 00:25:55.540
And we haven't seen
this method before.

00:25:55.540 --> 00:25:58.720
It acts one of two ways.

00:25:58.720 --> 00:26:01.890
If the animation
has not yet started,

00:26:01.890 --> 00:26:05.130
this method would set the final
position for the animation,

00:26:05.130 --> 00:26:07.040
and start the animation.

00:26:07.040 --> 00:26:09.170
If the animation is
already started--

00:26:09.170 --> 00:26:11.850
is already running--
then this method

00:26:11.850 --> 00:26:16.830
would just update the final
position for the animation.

00:26:16.830 --> 00:26:21.630
And what this means is, every
time we receive a move event,

00:26:21.630 --> 00:26:24.060
we're going to
move the lead view.

00:26:24.060 --> 00:26:27.540
And then, if A is
at resting position,

00:26:27.540 --> 00:26:29.180
we're going to start
animation to move

00:26:29.180 --> 00:26:30.950
a towards the lead view.

00:26:30.950 --> 00:26:33.210
If the A is already
animating, then we're

00:26:33.210 --> 00:26:35.300
going to update
A's final position.

00:26:35.300 --> 00:26:40.080
So that, if you remember, in
one of the earlier slides,

00:26:40.080 --> 00:26:45.400
the way physics-based animation
handled target value change,

00:26:45.400 --> 00:26:48.120
A would, eventually-- after
some course correction--

00:26:48.120 --> 00:26:51.090
it would, eventually, head
towards the lead view.

00:26:51.090 --> 00:26:56.170
And this is how we achieve
having A follow the lead.

00:26:56.170 --> 00:26:58.560
And finally, we're going
to update the last position

00:26:58.560 --> 00:26:59.730
for the motion event--

00:26:59.730 --> 00:27:01.563
for the delta calculation.

00:27:03.980 --> 00:27:09.590
Now let's take a look at how we
can have B follow A. Similarly,

00:27:09.590 --> 00:27:13.940
we're going to create
animations for B.

00:27:13.940 --> 00:27:17.780
And, in order to get notified
whenever A's position is

00:27:17.780 --> 00:27:20.840
changed, we need this
onAnimationUpdate listener,

00:27:20.840 --> 00:27:26.650
and we're going to add the
listener to A's animation.

00:27:26.650 --> 00:27:29.720
You need onAnimationUpdate
callback.

00:27:29.720 --> 00:27:33.030
We're going to receive A's
animation and then A's position

00:27:33.030 --> 00:27:34.595
and A's velocity.

00:27:34.595 --> 00:27:35.970
We're going to do
the same trick.

00:27:35.970 --> 00:27:39.720
Here, we're going to call
animateToFinalPosition.

00:27:39.720 --> 00:27:45.300
So if B is not
moving at the moment,

00:27:45.300 --> 00:27:47.170
then we would set the
final position for it,

00:27:47.170 --> 00:27:50.740
and then start the animation
to move it towards A.

00:27:50.740 --> 00:27:52.447
Or if B is already
moving, we're going

00:27:52.447 --> 00:27:54.530
to update its final position
so it will eventually

00:27:54.530 --> 00:27:56.622
head towards A.

00:28:01.270 --> 00:28:05.610
So the physics-based
animation is available, now.

00:28:05.610 --> 00:28:10.240
It is [INAUDIBLE] 26 Beta
1, and you can use it

00:28:10.240 --> 00:28:13.510
by adding this dependency
to your Gradle file,

00:28:13.510 --> 00:28:16.347
and it is backward-compatible
to API 16.

00:28:16.347 --> 00:28:18.832
[CLAPPING]

00:28:24.810 --> 00:28:27.520
And I'm very excited to see
what you guys can come up

00:28:27.520 --> 00:28:28.630
with using this library.

00:28:32.752 --> 00:28:34.696
[CLAPPING]

00:28:40.077 --> 00:28:40.910
CHET HAASE: Awesome.

00:28:40.910 --> 00:28:43.850
So that was the cool, new
stuff, but what if you're still

00:28:43.850 --> 00:28:46.260
using the cool, old stuff?

00:28:46.260 --> 00:28:48.980
So, that's what I'm here for.

00:28:48.980 --> 00:28:52.400
So animator set-- there was
long requested functionality,

00:28:52.400 --> 00:28:55.190
in terms of being able to
seek within an animation,

00:28:55.190 --> 00:28:56.150
as well as reverse.

00:28:56.150 --> 00:28:58.400
We have this in the
Value Animator API,

00:28:58.400 --> 00:29:02.900
but not in AnimatorSet,
because it was difficult to do.

00:29:02.900 --> 00:29:04.490
So, now we have
these capabilities,

00:29:04.490 --> 00:29:07.610
and I'll show a simple
demo and some code that's

00:29:07.610 --> 00:29:11.487
not written in [? Colin, ?]
and you can see how to do that.

00:29:11.487 --> 00:29:13.070
So there's a famous
quote that I think

00:29:13.070 --> 00:29:15.195
everybody probably knows--
seek and you shall find.

00:29:15.195 --> 00:29:18.350
It turns out, that this
was taken out of context.

00:29:18.350 --> 00:29:20.630
The full quote goes
something like this, seek

00:29:20.630 --> 00:29:25.010
and you shall find that there
is no seek API on AnimatorSet.

00:29:25.010 --> 00:29:25.940
Right?

00:29:25.940 --> 00:29:29.270
Nobody knew that, but I'm
here to tell you that.

00:29:29.270 --> 00:29:33.030
Also, it turns out that
there's no way to reverse it.

00:29:33.030 --> 00:29:35.600
But, we did some
things about that,

00:29:35.600 --> 00:29:38.280
and I'm going to show you how
you can use that functionality.

00:29:38.280 --> 00:29:41.780
So here we have a really
simple, rather lame demo.

00:29:41.780 --> 00:29:43.010
What I want to do--

00:29:43.010 --> 00:29:45.170
given this amazingly
complex UI--

00:29:45.170 --> 00:29:46.730
is move those three
buttons around

00:29:46.730 --> 00:29:49.490
on the screen when the user
clicks on the various controls

00:29:49.490 --> 00:29:50.060
there.

00:29:50.060 --> 00:29:52.070
So, in particular, when
you play the animation,

00:29:52.070 --> 00:29:53.986
I want the button on top
to move to the right,

00:29:53.986 --> 00:29:56.730
the button in the middle
should move down to the right,

00:29:56.730 --> 00:29:59.160
and the button on the bottom
should move straight down.

00:29:59.160 --> 00:30:00.740
So, the button when
it moves to the right,

00:30:00.740 --> 00:30:03.031
you create an object animator--
fairly straightforward.

00:30:03.031 --> 00:30:04.649
We're going to
animate TRANSLATION_X

00:30:04.649 --> 00:30:06.440
and we're going to move
it all the way over

00:30:06.440 --> 00:30:09.346
until it's positioned all
the way over on the right.

00:30:09.346 --> 00:30:10.970
The bottom-- the
button in the middle--

00:30:10.970 --> 00:30:12.720
we're going to move
it to the lower right.

00:30:12.720 --> 00:30:14.475
Similarly, we create
an object animator--

00:30:14.475 --> 00:30:16.850
we can use property values
holders so that we can animate

00:30:16.850 --> 00:30:20.390
x and y at the same time,
inside the same single object

00:30:20.390 --> 00:30:20.900
animator.

00:30:20.900 --> 00:30:24.429
So we're doing TRANSLATION_X
and TRANSLATION_Y in parallel.

00:30:24.429 --> 00:30:25.970
And finally, the
button on the bottom

00:30:25.970 --> 00:30:28.430
is going to move all the way
to the bottom of the screen.

00:30:28.430 --> 00:30:30.740
Similarly to the
one at the top, it's

00:30:30.740 --> 00:30:33.680
going to animate TRANSLATION_Y
all the way down to the bottom.

00:30:33.680 --> 00:30:36.440
So we create these
things, and then we

00:30:36.440 --> 00:30:38.630
create the AnimatorSet
that contains these child

00:30:38.630 --> 00:30:39.271
animations.

00:30:39.271 --> 00:30:40.770
We're going to run
them in sequence.

00:30:40.770 --> 00:30:42.570
So it's going to go--
top, middle, bottom.

00:30:42.570 --> 00:30:44.150
So we'll play
those sequentially,

00:30:44.150 --> 00:30:46.160
and then we start
the animation, which

00:30:46.160 --> 00:30:48.957
looks something like this.

00:30:48.957 --> 00:30:51.290
I bet you couldn't guess what
was going to happen there.

00:30:51.290 --> 00:30:52.670
So you press the Play button--

00:30:52.670 --> 00:30:53.720
animation plays.

00:30:53.720 --> 00:30:54.840
Fairly straightforward.

00:30:54.840 --> 00:30:57.540
That's what you
could do already.

00:30:57.540 --> 00:30:59.390
But, what happens
if we actually want

00:30:59.390 --> 00:31:00.610
to seek within the animation?

00:31:00.610 --> 00:31:02.690
Well, now we call
this new method

00:31:02.690 --> 00:31:04.640
called setCurrentPlayTime.

00:31:04.640 --> 00:31:08.850
So we've hooked this up to
the seek bar at the top.

00:31:08.850 --> 00:31:11.840
So when we get a callback into
the onProgressChange method,

00:31:11.840 --> 00:31:18.380
we can see where the seek bar
is in that track that it's in,

00:31:18.380 --> 00:31:21.200
and interpret that as a
percentage of movement,

00:31:21.200 --> 00:31:24.320
and then apply that to
the AnimatorSet animation.

00:31:24.320 --> 00:31:27.680
So, setCurrentPlayTime using
that percentage, multiplied

00:31:27.680 --> 00:31:31.670
times the total duration
that the animation has.

00:31:31.670 --> 00:31:34.850
So we have this getTotalDuration
method on AnimatorSet--

00:31:34.850 --> 00:31:38.480
we get that, multiply it times
a percentage, and away we go.

00:31:38.480 --> 00:31:40.440
So we drag it around
on the screen,

00:31:40.440 --> 00:31:42.392
buttons move, all
the child animations

00:31:42.392 --> 00:31:43.850
are moving
independently, depending

00:31:43.850 --> 00:31:48.320
on where we've seeked in the
AnimatorSet animation itself.

00:31:48.320 --> 00:31:48.830
All right.

00:31:48.830 --> 00:31:50.380
And then, finally--

00:31:50.380 --> 00:31:53.182
I bet you couldn't guess
how this is going to work.

00:31:53.182 --> 00:31:54.890
What if we want to
reverse the animation,

00:31:54.890 --> 00:31:56.990
so the user clicks on
the reverse button,

00:31:56.990 --> 00:32:00.400
and everything moves in reverse?

00:32:00.400 --> 00:32:02.000
Very straightforward.

00:32:02.000 --> 00:32:05.210
It turns out that the
entire quote is now amended,

00:32:05.210 --> 00:32:06.590
and it's now--

00:32:06.590 --> 00:32:07.940
until now.

00:32:07.940 --> 00:32:10.180
So, please use reverse and seek.

00:32:10.180 --> 00:32:12.036
[CLAPPING]

00:32:16.220 --> 00:32:18.320
And get the capabilities
that you want.

00:32:18.320 --> 00:32:20.370
A couple of notes on that.

00:32:20.370 --> 00:32:23.570
One is that it will specifically
seek within child animations

00:32:23.570 --> 00:32:25.130
that are a value animator.

00:32:25.130 --> 00:32:29.450
Because if it's not a value
animator, or an AnimatorSet,

00:32:29.450 --> 00:32:33.720
we're not sure how to
reverse or seek that thing.

00:32:33.720 --> 00:32:35.794
So if your child animation
is just an animator--

00:32:35.794 --> 00:32:38.210
it's this opaque thing that
you've implemented-- we're not

00:32:38.210 --> 00:32:39.060
sure what to do about it.

00:32:39.060 --> 00:32:40.570
That will get
dropped on the floor.

00:32:40.570 --> 00:32:42.980
Or you can implement
that functionality.

00:32:42.980 --> 00:32:45.410
But, it's really, specifically,
for the common case

00:32:45.410 --> 00:32:49.160
of value animators and object
animators subclass of that.

00:32:49.160 --> 00:32:51.200
Another thing to
note is there is

00:32:51.200 --> 00:32:55.220
new onAnimationStart and
onAnimationEnd callbacks

00:32:55.220 --> 00:32:56.660
in the interface--
default methods

00:32:56.660 --> 00:33:00.660
that we implemented that will
then provide you the direction.

00:33:00.660 --> 00:33:04.070
So in addition to knowing when
you're starting and ending,

00:33:04.070 --> 00:33:05.870
it's useful if you
know what direction

00:33:05.870 --> 00:33:08.810
you're running in, given the new
capabilities that AnimatorSet

00:33:08.810 --> 00:33:09.710
has.

00:33:09.710 --> 00:33:12.560
So you can access
those, as well.

00:33:12.560 --> 00:33:16.760
And that is the talk,
and we do have--

00:33:16.760 --> 00:33:17.660
sure.

00:33:17.660 --> 00:33:19.160
[CLAPPING]

00:33:21.260 --> 00:33:24.310
[MUSIC PLAYING]

