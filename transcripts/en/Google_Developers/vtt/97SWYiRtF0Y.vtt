WEBVTT
Kind: captions
Language: en

00:00:01.720 --> 00:00:05.670
CHET HAASE: Good afternoon and
welcome to Material Witness.

00:00:05.670 --> 00:00:08.600
We thought it would be good
to write some actual code,

00:00:08.600 --> 00:00:11.160
using some of the new
Material Design APIs

00:00:11.160 --> 00:00:13.592
and talk about how
we did it, and also

00:00:13.592 --> 00:00:15.300
more interestingly,
how some of the stuff

00:00:15.300 --> 00:00:16.789
works under the covers.

00:00:16.789 --> 00:00:19.080
ROMAIN GUY: Yeah, so just
one little caveat-- Chet just

00:00:19.080 --> 00:00:20.590
mentioned writing code.

00:00:20.590 --> 00:00:22.200
And since we're
both managers now,

00:00:22.200 --> 00:00:24.900
we don't really write
code anymore for a living.

00:00:24.900 --> 00:00:26.820
So forgive us if
the code is weird.

00:00:26.820 --> 00:00:29.940
CHET HAASE: We should have
people to write this for us.

00:00:29.940 --> 00:00:32.580
So I don't know if
you know who we are.

00:00:32.580 --> 00:00:33.480
I'm Chet Haase.

00:00:33.480 --> 00:00:35.449
I'm on the Android
UI Toolkit team.

00:00:35.449 --> 00:00:36.490
I don't know who this is.

00:00:36.490 --> 00:00:37.380
ROMAIN GUY: I'm Romain Guy.

00:00:37.380 --> 00:00:39.440
I used to be on the
Android UI Toolkit team,

00:00:39.440 --> 00:00:44.180
until-- [CHEERING] Thank you.

00:00:44.180 --> 00:00:46.521
--until Chet decided
he wanted my job.

00:00:46.521 --> 00:00:47.895
And so now I'm
working on robots.

00:00:47.895 --> 00:00:49.440
CHET HAASE: Are they
clapping because you

00:00:49.440 --> 00:00:50.390
used to be on the team?

00:00:50.390 --> 00:00:51.180
ROMAIN GUY: I think so.

00:00:51.180 --> 00:00:52.065
CHET HAASE: Or
because you're gone?

00:00:52.065 --> 00:00:53.690
ROMAIN GUY: Gee,
he's finally gone.

00:00:53.690 --> 00:00:56.475
AUDIENCE: [INAUDIBLE]

00:00:56.475 --> 00:01:02.617
CHET HAASE: Moving on-- oh,
those awkward protesters.

00:01:02.617 --> 00:01:04.700
All right, let's take a
look at a couple of demos.

00:01:04.700 --> 00:01:07.302
So I had an idea for
a demo application

00:01:07.302 --> 00:01:08.510
we were going to do together.

00:01:08.510 --> 00:01:09.885
It was going to
go out to Flickr.

00:01:09.885 --> 00:01:12.090
It was going to fetch
these images, by Romain.

00:01:12.090 --> 00:01:14.800
We'd get these beautiful images
downloading in the background.

00:01:14.800 --> 00:01:16.500
And then we'd install
them in wallpaper,

00:01:16.500 --> 00:01:18.090
and it would be all lovely.

00:01:18.090 --> 00:01:20.410
And Romain is like, I
don't have time to do all.

00:01:20.410 --> 00:01:21.910
How about if we
just hack some demos

00:01:21.910 --> 00:01:23.740
to show the pieces that
we actually care about?

00:01:23.740 --> 00:01:24.656
So that's what we did.

00:01:24.656 --> 00:01:26.160
ROMAIN GUY: So we
have two demos.

00:01:26.160 --> 00:01:28.000
We will pretend that
we have two demos,

00:01:28.000 --> 00:01:30.389
to keep each demo simple, so
that the code will be easier

00:01:30.389 --> 00:01:32.680
to understand, which we did
because we didn't have time

00:01:32.680 --> 00:01:33.912
to merge the two demos.

00:01:33.912 --> 00:01:36.760
CHET HAASE: So I have a
very simple demo showing off

00:01:36.760 --> 00:01:39.050
some of the things we're
going to talk about today.

00:01:39.050 --> 00:01:41.660
I tend to look at my
demos as simple things

00:01:41.660 --> 00:01:45.390
that I can write code for that
clearly explain the simple bits

00:01:45.390 --> 00:01:47.950
that I want to help
people understand.

00:01:47.950 --> 00:01:49.630
And then Romain writes
something similar

00:01:49.630 --> 00:01:52.880
and actually makes it look good,
which is really embarrassing.

00:01:52.880 --> 00:01:54.160
So here's my simple demo.

00:01:54.160 --> 00:01:55.910
This is showing some
of the elements we're

00:01:55.910 --> 00:01:58.487
going to talk about, in
terms of animations and cards

00:01:58.487 --> 00:02:00.570
and some interactivity,
as you touch these things,

00:02:00.570 --> 00:02:01.730
some ripples.

00:02:01.730 --> 00:02:03.660
So we can sort of see
some of this in action.

00:02:03.660 --> 00:02:06.160
Then this stuff is going to be
demonstrated in videos as we

00:02:06.160 --> 00:02:07.785
go, so we can look
a little bit closer.

00:02:07.785 --> 00:02:09.160
So we see a transition.

00:02:09.160 --> 00:02:11.560
We're sharing a hero element
between these activities.

00:02:11.560 --> 00:02:13.615
We can change and
customize the transition

00:02:13.615 --> 00:02:15.620
and make the
elements explode out

00:02:15.620 --> 00:02:18.360
and move out to the top and
bottom in a staggered way

00:02:18.360 --> 00:02:18.970
instead.

00:02:18.970 --> 00:02:21.990
OK, so that's my simple demo.

00:02:21.990 --> 00:02:23.390
And this is the second demo.

00:02:23.390 --> 00:02:25.790
It's a similar
idea, with images.

00:02:25.790 --> 00:02:31.090
So we're going to see
transitions, reveals,

00:02:31.090 --> 00:02:32.796
with live MapView.

00:02:32.796 --> 00:02:34.670
This has nothing to do
with my actual design.

00:02:34.670 --> 00:02:36.340
It just looks cool.

00:02:36.340 --> 00:02:40.270
[AUDIENCE LAUGHING] And if we
have time, we'll talk about it.

00:02:40.270 --> 00:02:42.420
If you look at the
colors of the UI,

00:02:42.420 --> 00:02:44.690
you're going to notice that
the colors are actually

00:02:44.690 --> 00:02:46.700
coming from the
images themselves.

00:02:46.700 --> 00:02:50.207
So this is dynamic thinning
of the app, basically, based

00:02:50.207 --> 00:02:51.540
on colors with different images.

00:02:51.540 --> 00:02:54.516
And again, we're going to
look at the APIs to do this.

00:02:54.516 --> 00:02:56.070
CHET HAASE: So if
we can switch back

00:02:56.070 --> 00:03:04.027
to the slides-- so
first of all, let's

00:03:04.027 --> 00:03:05.860
talk about cards, one
of the simple elements

00:03:05.860 --> 00:03:09.060
that you saw in
both of those demos.

00:03:09.060 --> 00:03:11.249
And the cards are
the idea-- you see it

00:03:11.249 --> 00:03:13.040
in a lot of the mocks
from the design team,

00:03:13.040 --> 00:03:14.940
as they're talking
about material design,

00:03:14.940 --> 00:03:17.620
setting apart the content
into these items that are then

00:03:17.620 --> 00:03:20.620
sitting on top of these cards,
this paper representation,

00:03:20.620 --> 00:03:22.680
elevated a bit off the
view hierarchy plane.

00:03:22.680 --> 00:03:24.020
So they're casting a
little bit of shadow.

00:03:24.020 --> 00:03:26.186
There's padding around the
edges, sort of a nice way

00:03:26.186 --> 00:03:27.700
to segregate,
separate the content

00:03:27.700 --> 00:03:29.560
with some nice white
space in there.

00:03:29.560 --> 00:03:30.670
So we implemented that.

00:03:30.670 --> 00:03:33.350
In my demo, I did
it very manually.

00:03:33.350 --> 00:03:35.450
I just have a
group to sort of do

00:03:35.450 --> 00:03:37.930
all the little bits and
pieces that need to be done.

00:03:37.930 --> 00:03:40.660
You can also use CardView
in the support library,

00:03:40.660 --> 00:03:43.570
to do this a little
more automatically.

00:03:43.570 --> 00:03:45.320
So in the case of
my demo, there's

00:03:45.320 --> 00:03:48.062
a round-rect ShapeDrawable
that I used as a background.

00:03:48.062 --> 00:03:49.520
And then I clipped
to that outline.

00:03:49.520 --> 00:03:52.750
And this is one of the new
APIs and capabilities exposed

00:03:52.750 --> 00:03:53.969
in the L Release.

00:03:53.969 --> 00:03:56.260
So you can clip and get the
nice, rounded corner there.

00:03:56.260 --> 00:04:00.040
This is also the shape that is
used by the shadow that is then

00:04:00.040 --> 00:04:01.970
cast onto the View
Hierarchy plane.

00:04:01.970 --> 00:04:04.300
So as you elevate
this view, then we

00:04:04.300 --> 00:04:07.110
cast a shadow using the outline
that you've told us your View

00:04:07.110 --> 00:04:07.720
has.

00:04:07.720 --> 00:04:10.251
So we get the nice
rounded, soft shadow effect

00:04:10.251 --> 00:04:11.500
around the edges of the cards.

00:04:11.500 --> 00:04:14.041
ROMAIN GUY: And we're going to
talk in more details about how

00:04:14.041 --> 00:04:16.430
elevation works,
in a few minutes.

00:04:16.430 --> 00:04:21.050
CHET HAASE: So here's how I
happen to do it in my codes.

00:04:21.050 --> 00:04:24.684
In general, Drawables
know what shape they are.

00:04:24.684 --> 00:04:26.100
So if you have a
ShapeDrawable, it

00:04:26.100 --> 00:04:27.707
knows what outline it exposes.

00:04:27.707 --> 00:04:29.790
And it can propagate that
information to the View.

00:04:29.790 --> 00:04:32.160
So in general, Views
should know what shadow

00:04:32.160 --> 00:04:35.560
the shape should be drawn with,
or potentially clipped to.

00:04:35.560 --> 00:04:37.820
Some of that stuff is not
yet enabled in the preview L

00:04:37.820 --> 00:04:40.980
Release, so I'm doing
it more manually here.

00:04:40.980 --> 00:04:43.840
The outlines are specified
in the coordinate system

00:04:43.840 --> 00:04:45.044
of the views themselves.

00:04:45.044 --> 00:04:46.460
So when the View
changes size, you

00:04:46.460 --> 00:04:49.590
need to then update the size
of the outline appropriately.

00:04:49.590 --> 00:04:51.770
So here, we override
on Size Changed.

00:04:51.770 --> 00:04:52.979
We get the size of the View.

00:04:52.979 --> 00:04:54.020
We create the Round-Rect.

00:04:54.020 --> 00:04:56.549
We set the outline to
the shape, and then we

00:04:56.549 --> 00:04:58.340
tell it to also clip
to that shape as well.

00:04:58.340 --> 00:05:00.048
ROMAIN GUY: And in
particular, this trick

00:05:00.048 --> 00:05:01.790
of creating the outline
programmatically

00:05:01.790 --> 00:05:03.690
on the onSizeChanged
is very important,

00:05:03.690 --> 00:05:05.940
if your background is a Bitmap.

00:05:05.940 --> 00:05:07.580
Because given the
way shadows work,

00:05:07.580 --> 00:05:09.455
right now, this thing
is not able to generate

00:05:09.455 --> 00:05:10.650
shadows for Bitmap.

00:05:10.650 --> 00:05:12.330
So if your Bitmap
contains a circle,

00:05:12.330 --> 00:05:13.590
the system doesn't
know there's a circle.

00:05:13.590 --> 00:05:15.060
So you have to tell
the framework that's

00:05:15.060 --> 00:05:16.470
you want a circle
for the shadow.

00:05:16.470 --> 00:05:17.990
CHET HAASE: A lot of
the canonical cases

00:05:17.990 --> 00:05:19.040
are going to be solved for you.

00:05:19.040 --> 00:05:20.780
If you have a shape,
it's going to know

00:05:20.780 --> 00:05:23.000
what shape to draw
that shadow at.

00:05:23.000 --> 00:05:25.561
But not necessarily
all the cases, so it's

00:05:25.561 --> 00:05:28.060
good to know how to actually
do it programmatically as well.

00:05:28.060 --> 00:05:30.060
And then finally, we set
a shadow on the card,

00:05:30.060 --> 00:05:32.210
simply by boosting
it up to some value.

00:05:32.210 --> 00:05:34.176
So we've set an elevation
value of 5 here.

00:05:34.176 --> 00:05:35.800
And as Romain said,
we're going to talk

00:05:35.800 --> 00:05:38.760
more about shadows
and elevation later.

00:05:38.760 --> 00:05:41.180
So you could also
just use CardView.

00:05:41.180 --> 00:05:43.570
I didn't happen to, frankly
because it wasn't online

00:05:43.570 --> 00:05:46.270
when I was writing some of
the bits of the demo here.

00:05:46.270 --> 00:05:48.540
But you can use
CardView to do this.

00:05:48.540 --> 00:05:50.150
What I did is actually
really simple.

00:05:50.150 --> 00:05:52.440
The advantage of using
CardView is twofold.

00:05:52.440 --> 00:05:54.349
One is that it's
standardizes your cards

00:05:54.349 --> 00:05:56.640
with other people that happen
to be using that element,

00:05:56.640 --> 00:05:58.265
so things look a
little more consistent

00:05:58.265 --> 00:05:59.970
across the platform in general.

00:05:59.970 --> 00:06:02.720
But also, in the
CardView widget,

00:06:02.720 --> 00:06:05.259
which is in the support
library, when you're

00:06:05.259 --> 00:06:06.800
sitting on top of
the L Release, it's

00:06:06.800 --> 00:06:07.780
going to do the correct thing.

00:06:07.780 --> 00:06:09.238
It's going to give
it an elevation.

00:06:09.238 --> 00:06:11.200
It's going to clip to the edges.

00:06:11.200 --> 00:06:12.950
It's going to do all
the L-correct things.

00:06:12.950 --> 00:06:14.500
When it's on a
previous release, it

00:06:14.500 --> 00:06:17.400
generates images that
look pretty much the same.

00:06:17.400 --> 00:06:19.420
It's a very good
and consistent look.

00:06:19.420 --> 00:06:21.642
But it's not necessarily
using-- it's certainly not

00:06:21.642 --> 00:06:24.100
using the same capabilities,
because we didn't have shadows

00:06:24.100 --> 00:06:25.530
prior to this release.

00:06:25.530 --> 00:06:28.487
But it at least
uses these elements

00:06:28.487 --> 00:06:30.070
of the different
releases, to give you

00:06:30.070 --> 00:06:33.074
a consistent look for your
application across releases.

00:06:33.074 --> 00:06:35.615
And you can see here, there are
examples of CardView previous

00:06:35.615 --> 00:06:37.172
to L and in the L release.

00:06:37.172 --> 00:06:38.380
And they look pretty similar.

00:06:38.380 --> 00:06:41.000
And that's a good thing.

00:06:41.000 --> 00:06:43.221
So how it works is,
basically, if you're

00:06:43.221 --> 00:06:44.970
running on one of these
previous releases,

00:06:44.970 --> 00:06:47.580
it generates a PNG file
with the shadow baked in,

00:06:47.580 --> 00:06:49.860
just as you probably
would with your assets,

00:06:49.860 --> 00:06:52.750
if you were trying to do
something on your own.

00:06:52.750 --> 00:06:56.240
You can use Path Clipping if
you want to actually clip shapes

00:06:56.240 --> 00:06:57.160
to a path.

00:06:57.160 --> 00:06:59.550
It tends to be very expensive,
so we don't recommend it

00:06:59.550 --> 00:07:00.940
as a general solution.

00:07:00.940 --> 00:07:03.010
If we're actually
redrawing your views that

00:07:03.010 --> 00:07:04.780
are path clipped
all the time, you're

00:07:04.780 --> 00:07:08.990
wasting a lot of performance
that you would probably rather

00:07:08.990 --> 00:07:11.510
be spending on other things
in the system as well.

00:07:11.510 --> 00:07:13.390
There are also
approaches where you

00:07:13.390 --> 00:07:17.440
can use BitmapShader to draw
and get a similar result.

00:07:17.440 --> 00:07:21.689
This is the effect used in,
I think, Search in KitKat.

00:07:21.689 --> 00:07:23.230
When they did a
circular reveal, they

00:07:23.230 --> 00:07:25.310
were using a BitmapShader
to get that effect.

00:07:25.310 --> 00:07:26.890
Again, kind of
expensive-- you don't

00:07:26.890 --> 00:07:29.100
want it running
full-time in the system.

00:07:29.100 --> 00:07:31.300
But it's OK for a
transient effect.

00:07:31.300 --> 00:07:32.572
In L, it's much simpler.

00:07:32.572 --> 00:07:34.030
We can actually
tell it the outline

00:07:34.030 --> 00:07:36.620
to clip to and the
outline to shadow to.

00:07:36.620 --> 00:07:40.170
And we can set the elevation
to shadow appropriately.

00:07:40.170 --> 00:07:43.160
I didn't want to put the
actual APIs for outlines

00:07:43.160 --> 00:07:45.760
on here, because this is
one of the areas is probably

00:07:45.760 --> 00:07:48.717
going to be tweaked a little
bit, in the final release of L.

00:07:48.717 --> 00:07:51.050
There's a simple way of dealing
with outlines right now.

00:07:51.050 --> 00:07:52.717
That simple way of
dealing with outlines

00:07:52.717 --> 00:07:55.383
is probably going to change to a
different simple way of dealing

00:07:55.383 --> 00:07:56.280
with outlines.

00:07:56.280 --> 00:07:58.060
So don't get too hung
up on the details,

00:07:58.060 --> 00:07:59.950
since it's a preview release.

00:07:59.950 --> 00:08:02.990
But the general ideas
will be the same.

00:08:02.990 --> 00:08:04.240
Now, let's talk about Ripples.

00:08:04.240 --> 00:08:05.224
This is touch feedback.

00:08:05.224 --> 00:08:06.640
One of the important
elements-- we

00:08:06.640 --> 00:08:08.250
talked about this
in earlier talks--

00:08:08.250 --> 00:08:10.750
was to give the user
immediate feedback

00:08:10.750 --> 00:08:12.190
of what's going
on in the system.

00:08:12.190 --> 00:08:14.580
So we have Touch Feedback
on all the standard widgets,

00:08:14.580 --> 00:08:17.260
so that the user knows what they
pressed and where they pressed.

00:08:17.260 --> 00:08:19.922
And we animate the
state change over time.

00:08:19.922 --> 00:08:22.380
And actually, you probably went
to the earlier talk anyway.

00:08:22.380 --> 00:08:24.180
So I'm going to blow
through some of that stuff

00:08:24.180 --> 00:08:26.763
and get to the more interesting
bits of how the stuff actually

00:08:26.763 --> 00:08:27.850
works.

00:08:27.850 --> 00:08:29.730
So RippleDrawable,
it's the new class.

00:08:29.730 --> 00:08:30.850
You can use it directly.

00:08:30.850 --> 00:08:33.141
There's other ways that you
can opt into this behavior.

00:08:33.141 --> 00:08:35.200
And the standard widgets
have it built in.

00:08:35.200 --> 00:08:36.940
So you can see the
Ripple behavior here.

00:08:36.940 --> 00:08:38.440
Is that coming
across on the screen?

00:08:38.440 --> 00:08:39.309
I think so.

00:08:39.309 --> 00:08:40.975
And then if you stare
at it long enough,

00:08:40.975 --> 00:08:42.530
maybe you'll have a seizure.

00:08:42.530 --> 00:08:44.940
And here's some of the code
to enable some of the stuff.

00:08:44.940 --> 00:08:48.060
So from XML, you can
create this RippleDrawable.

00:08:48.060 --> 00:08:52.380
So you can optionally set
a color for your ripple.

00:08:52.380 --> 00:08:56.300
And it basically uses
that optional color

00:08:56.300 --> 00:08:59.360
and reveals the content that
the ripple is actually wrapping.

00:08:59.360 --> 00:09:01.000
So in this case,
we have a Drawable

00:09:01.000 --> 00:09:02.840
that's simply a ColorDrawable.

00:09:02.840 --> 00:09:05.530
And that's going to
be revealed over time,

00:09:05.530 --> 00:09:07.730
with the Ripple that's
then wrapping that item.

00:09:07.730 --> 00:09:10.610
Or similarly, from code, you
create the RippleDrawable

00:09:10.610 --> 00:09:12.920
class, optionally
set a color on it.

00:09:12.920 --> 00:09:15.140
Or the easiest way to
do is actually just

00:09:15.140 --> 00:09:17.910
to set a
selectableItemBackground.

00:09:17.910 --> 00:09:20.142
And that means, when the
user presses on that,

00:09:20.142 --> 00:09:21.600
puts it in its
selected state, then

00:09:21.600 --> 00:09:23.308
it's automatically
going to run a Ripple.

00:09:23.308 --> 00:09:25.320
The Ripple that we saw
in the seizure slide,

00:09:25.320 --> 00:09:27.670
in the previous slide,
uses that approach.

00:09:27.670 --> 00:09:30.420
It says, I want my foreground
to be this RippleDrawable.

00:09:30.420 --> 00:09:32.040
So then, as the
item is selected,

00:09:32.040 --> 00:09:35.725
it automatically emanates
that Ripple on top of it.

00:09:35.725 --> 00:09:37.640
ROMAIN GUY: And this is
the same exact effect

00:09:37.640 --> 00:09:38.380
in the second demo.

00:09:38.380 --> 00:09:39.754
We just wanted to
show it to you,

00:09:39.754 --> 00:09:43.620
because here, the ripple
is pinkish, purple.

00:09:43.620 --> 00:09:45.000
The color comes from the scene.

00:09:45.000 --> 00:09:47.396
So if you use the foreground
technique that Chet just

00:09:47.396 --> 00:09:48.770
showed you on the
previous slide,

00:09:48.770 --> 00:09:50.740
you're automatically
going to get the Ripples

00:09:50.740 --> 00:09:52.323
with the right color
from [INAUDIBLE].

00:09:55.112 --> 00:09:57.460
CHET HAASE: So how
they work in general--

00:09:57.460 --> 00:09:58.512
they wrap the content.

00:09:58.512 --> 00:09:59.970
So you can think
of it as a wrapper

00:09:59.970 --> 00:10:02.260
around the actual content
that you're going to reveal.

00:10:02.260 --> 00:10:04.950
And it's going to reveal that
by emanating the Ripple out

00:10:04.950 --> 00:10:07.630
from what we call the
Hotspot, the center

00:10:07.630 --> 00:10:09.180
point of the interaction.

00:10:09.180 --> 00:10:11.740
If you use
selectableItemBackground,

00:10:11.740 --> 00:10:14.050
we automatically know
where that Hotspot is.

00:10:14.050 --> 00:10:16.350
We know where the
user's finger pressed.

00:10:16.350 --> 00:10:18.100
And we can emanate
from that center point.

00:10:18.100 --> 00:10:19.550
If you're doing it
more programmatically,

00:10:19.550 --> 00:10:20.740
you can set the Hotspot.

00:10:20.740 --> 00:10:23.940
You can set the x,y location
in the local coordinate system

00:10:23.940 --> 00:10:24.630
of the View.

00:10:24.630 --> 00:10:26.940
And that's where the
Ripple will emanate from.

00:10:26.940 --> 00:10:29.402
The other interesting detail
is about the Render threads.

00:10:29.402 --> 00:10:30.860
This came up in
one of the sessions

00:10:30.860 --> 00:10:34.210
yesterday, that this is a
performance optimization

00:10:34.210 --> 00:10:36.462
that we've enabled in
this preview release

00:10:36.462 --> 00:10:37.920
and we'll be
continuing to work on,

00:10:37.920 --> 00:10:43.420
where the drawing system usually
consists of-- or has always

00:10:43.420 --> 00:10:45.840
consisted of-- in the
Hardware Accelerated Model.

00:10:45.840 --> 00:10:48.240
We create display lists on
the UI Toolkit thread it,

00:10:48.240 --> 00:10:50.880
and then we issue or
executive the display lists,

00:10:50.880 --> 00:10:52.429
also on the UI Toolkit thread.

00:10:52.429 --> 00:10:54.220
And that's when we
actually talk to the GPU

00:10:54.220 --> 00:10:55.550
and send down OpenGL commands.

00:10:55.550 --> 00:10:58.830
What we've done is broken those
out into two separate threads,

00:10:58.830 --> 00:11:01.500
so that we create the display
list on the UI Toolkit thread.

00:11:01.500 --> 00:11:04.955
And then the Render thread
actually talks to the GPU.

00:11:04.955 --> 00:11:06.580
If that's all we did,
it doesn't really

00:11:06.580 --> 00:11:07.954
buy us anything,
because we still

00:11:07.954 --> 00:11:09.980
have to create it
before we execute it.

00:11:09.980 --> 00:11:11.970
But now that we've been
able to break this out

00:11:11.970 --> 00:11:13.511
into separate spreads,
what we can do

00:11:13.511 --> 00:11:16.390
is start sending over
animations as atomic objects

00:11:16.390 --> 00:11:18.979
to be executed wholly
on that other thread.

00:11:18.979 --> 00:11:21.020
And the first one of those
that were working with

00:11:21.020 --> 00:11:21.603
is the Ripple.

00:11:21.603 --> 00:11:23.440
So you'll notice, if
you press on a button,

00:11:23.440 --> 00:11:26.480
it launches some activity.

00:11:26.480 --> 00:11:28.780
What you would have seen
in previous releases is,

00:11:28.780 --> 00:11:31.430
the Ripple would stop emanating,
as soon as you started

00:11:31.430 --> 00:11:34.850
the new activity, because the
same Toolkit thread is being

00:11:34.850 --> 00:11:36.740
used to inflate
the new activity,

00:11:36.740 --> 00:11:38.547
as is being used to
animate the Ripple.

00:11:38.547 --> 00:11:40.880
So what's happening now is,
we're sending in information

00:11:40.880 --> 00:11:43.890
about the Ripple animation
down to the Render thread.

00:11:43.890 --> 00:11:46.450
And that is able to continue
running while the Toolkit

00:11:46.450 --> 00:11:48.990
thread is busy inflating
the new activity.

00:11:48.990 --> 00:11:52.660
So that's the main thing that's
executing on the Render thread

00:11:52.660 --> 00:11:53.160
right now.

00:11:53.160 --> 00:11:56.194
Expect more over time,
as we're able to do this.

00:11:56.194 --> 00:11:57.610
There's some really
tricky details

00:11:57.610 --> 00:12:00.320
about what we can
run on either thread

00:12:00.320 --> 00:12:03.340
and what the contract with
some of the animation APIs are.

00:12:03.340 --> 00:12:05.570
But we'll do we can
to take advantage

00:12:05.570 --> 00:12:08.246
of this new performance
optimization.

00:12:08.246 --> 00:12:10.020
Now let's talk about Shadows.

00:12:10.020 --> 00:12:10.940
I'm going on and on.

00:12:10.940 --> 00:12:15.290
But trust me, he's going to
talk for a lot, after I'm done.

00:12:15.290 --> 00:12:18.810
Shadows are the idea of
boosting views in 3D,

00:12:18.810 --> 00:12:22.100
raising them above what is
essentially the Z=0 plane

00:12:22.100 --> 00:12:23.950
of the View Hierarchy.

00:12:23.950 --> 00:12:25.660
One important detail
here is that we're

00:12:25.660 --> 00:12:27.550
using orthographic projection.

00:12:27.550 --> 00:12:32.020
So typically, if we had a
full-on perspective camera

00:12:32.020 --> 00:12:35.319
world, then as you raised things
up, they would also scale up.

00:12:35.319 --> 00:12:37.110
Because you get
perspective foreshortening.

00:12:37.110 --> 00:12:39.469
They would get larger, as
they came closer to the View.

00:12:39.469 --> 00:12:41.260
That's not the projection
system that we're

00:12:41.260 --> 00:12:44.310
using right now, due to some of
the details about how we want

00:12:44.310 --> 00:12:46.190
the UIs to actually
interact right now.

00:12:46.190 --> 00:12:48.890
So as Views raise up,
they are raising in Z,

00:12:48.890 --> 00:12:50.140
and the shadows are expanding.

00:12:50.140 --> 00:12:51.820
But they're not
actually scaling.

00:12:51.820 --> 00:12:53.570
Sometimes, you actually
do want the effect

00:12:53.570 --> 00:12:55.770
of scaling, in which
case you should actually

00:12:55.770 --> 00:12:58.730
animate the scaleX and scaleY
properties of the View,

00:12:58.730 --> 00:13:02.400
at the same time, to get that
effect that you're looking for.

00:13:02.400 --> 00:13:04.720
We also added APIs,
not just to View,

00:13:04.720 --> 00:13:07.040
for the properties
around Elevation,

00:13:07.040 --> 00:13:08.970
but also to view
property animators,

00:13:08.970 --> 00:13:12.710
so that you can easily
animate these properties.

00:13:12.710 --> 00:13:15.316
This question came up a couple
of times in a previous session.

00:13:15.316 --> 00:13:16.690
There's a little
bit of confusion

00:13:16.690 --> 00:13:18.190
about what's an
Elevation and what's

00:13:18.190 --> 00:13:20.000
TranslationZ and what Z is.

00:13:20.000 --> 00:13:23.550
These map exactly to the
existing layout and post layout

00:13:23.550 --> 00:13:25.170
properties for X and Y.

00:13:25.170 --> 00:13:27.810
So if you imagine,
there's the left property,

00:13:27.810 --> 00:13:29.230
which is the Layout
property that

00:13:29.230 --> 00:13:31.930
says where you're going to
position this thing in X,

00:13:31.930 --> 00:13:33.050
when Layout runs.

00:13:33.050 --> 00:13:34.900
And then there's
TranslationX, which

00:13:34.900 --> 00:13:37.850
is a post-layout property, which
you usually use for animations,

00:13:37.850 --> 00:13:40.990
which is additive on top
of that left property.

00:13:40.990 --> 00:13:44.400
And then there is an X property,
which is the sum of those.

00:13:44.400 --> 00:13:47.610
So it's exactly the same thing
in Z. Elevation is basically

00:13:47.610 --> 00:13:50.440
the permanent location that
you want that thing to live at.

00:13:50.440 --> 00:13:55.330
TranslationZ is kind of a
post-layout, if you will,

00:13:55.330 --> 00:13:58.004
property but that is then
additive on top of that.

00:13:58.004 --> 00:13:59.670
This is going to be
used for animations.

00:13:59.670 --> 00:14:02.016
Like if you go into a
press state and out of it,

00:14:02.016 --> 00:14:03.890
then you would probably
animate TranslationZ,

00:14:03.890 --> 00:14:06.320
which is going to be on top
of the Elevation parameter.

00:14:06.320 --> 00:14:09.300
Or you can simply use Z
directly, which is additive.

00:14:09.300 --> 00:14:12.055
It's the combination of
Elevation plus TranslationZ.

00:14:15.010 --> 00:14:18.290
So here's a simple bit of
code that I have in my demo.

00:14:18.290 --> 00:14:20.520
When I pressed on one of
those thumbnail images,

00:14:20.520 --> 00:14:22.330
it raised up under my finger.

00:14:22.330 --> 00:14:25.309
And then it went back down and
then launched the new activity,

00:14:25.309 --> 00:14:27.350
when it was back down on
the View Hiearchy plane.

00:14:27.350 --> 00:14:30.204
The way I did that was simply
through an easy Touch Listener.

00:14:30.204 --> 00:14:31.620
When I pressed
down on it, I would

00:14:31.620 --> 00:14:33.650
start an animation
that scaled in X and Y,

00:14:33.650 --> 00:14:36.030
because I did one kind
of a perspective scaling

00:14:36.030 --> 00:14:36.990
effect on that.

00:14:36.990 --> 00:14:39.580
And then I would also
animate TranslationZ .

00:14:39.580 --> 00:14:41.800
I let go, I get a
Cancel or an Up.

00:14:41.800 --> 00:14:45.150
Then it would simply
animate back down to Z=0

00:14:45.150 --> 00:14:48.292
or Elevation=0, or in
this case, TranslatioZ=0.

00:14:48.292 --> 00:14:50.500
And then it would launch
the new activity from there,

00:14:50.500 --> 00:14:51.340
fairly straightforward.

00:14:51.340 --> 00:14:52.490
There are other
ways to accomplish

00:14:52.490 --> 00:14:54.454
this, which we'll see
later in other code.

00:14:54.454 --> 00:14:56.870
ROMAIN GUY: And now, I want
to talk a little bit about how

00:14:56.870 --> 00:14:58.411
the shadows are
actually implemented.

00:14:58.411 --> 00:15:02.790
So this is what the UI designers
wanted us to implement.

00:15:02.790 --> 00:15:05.400
So this is an image are
rendered in Blender.

00:15:05.400 --> 00:15:08.490
And it took 10
minutes on my laptop.

00:15:08.490 --> 00:15:12.770
CHET HAASE: 10 minutes--
10 times 60 seconds

00:15:12.770 --> 00:15:15.220
times 60 frames a second, yeah.

00:15:15.220 --> 00:15:18.780
ROMAIN GUY: So not possible on
a phone, but I tried anyway.

00:15:18.780 --> 00:15:20.210
You'll see.

00:15:20.210 --> 00:15:22.139
So let's see what we have here.

00:15:22.139 --> 00:15:23.180
So there's an Area Light.

00:15:23.180 --> 00:15:25.096
And Chet mention that
in the previous session,

00:15:25.096 --> 00:15:27.646
the Area Light is what gives
us these nice, soft shadows

00:15:27.646 --> 00:15:28.770
that you see at the bottom.

00:15:28.770 --> 00:15:31.290
So your Occluder is the
view, and the Area Light

00:15:31.290 --> 00:15:33.710
will cast those
nice, soft shadows.

00:15:33.710 --> 00:15:36.760
Now, if we implement
shadows in a naive way,

00:15:36.760 --> 00:15:39.690
you would get something
like this, where the umbra--

00:15:39.690 --> 00:15:43.385
So the umbra is the part of the
shadow from which you cannot

00:15:43.385 --> 00:15:44.260
see the light at all.

00:15:44.260 --> 00:15:45.840
So it's fully in the shadows.

00:15:45.840 --> 00:15:47.100
And then there's the penumbra.

00:15:47.100 --> 00:15:48.100
This is the soft edges.

00:15:48.100 --> 00:15:50.470
So when we talk
about soft shadows,

00:15:50.470 --> 00:15:52.767
it's just shadows that have
an umbra and a penumbra.

00:15:52.767 --> 00:15:55.350
The problem here is, you can see
that the shadow is completely

00:15:55.350 --> 00:15:56.306
dark.

00:15:56.306 --> 00:15:58.180
And in real life, this
doesn't really happen,

00:15:58.180 --> 00:15:59.250
because what
happens in real life

00:15:59.250 --> 00:16:00.630
is that the light
bounces around.

00:16:00.630 --> 00:16:04.150
If you lock yourself in a
room and you close the door,

00:16:04.150 --> 00:16:06.590
after a few minutes, you'll
be able to see things.

00:16:06.590 --> 00:16:10.770
And the reason is, light will go
through small holes in the door

00:16:10.770 --> 00:16:13.840
and just bounce around
until it hits your eyes.

00:16:13.840 --> 00:16:18.270
So really the effect that the
UI designer wanted was this.

00:16:18.270 --> 00:16:20.690
And this phenomenon is
called global illumination.

00:16:20.690 --> 00:16:22.510
So if you look here, you can
see that the shadow is not

00:16:22.510 --> 00:16:23.280
completely dark.

00:16:23.280 --> 00:16:24.810
It's a little hard
to see on screen.

00:16:24.810 --> 00:16:29.720
But the color of the view
itself, the Occluder, the red,

00:16:29.720 --> 00:16:31.010
is reflected onto the ground.

00:16:31.010 --> 00:16:34.390
So part of the ground
is a little bit red.

00:16:34.390 --> 00:16:36.620
And the ground itself is light.

00:16:36.620 --> 00:16:39.230
So to implement this, just
before I left the Android team,

00:16:39.230 --> 00:16:41.820
I wrote the first
prototype of soft shadows.

00:16:41.820 --> 00:16:43.190
And this is what I came up with.

00:16:43.190 --> 00:16:45.200
It was using
ray-tracing on the GPU.

00:16:45.200 --> 00:16:46.260
It looks pretty good.

00:16:46.260 --> 00:16:49.010
There's global
illumination approximation.

00:16:49.010 --> 00:16:50.500
This looks fairly
similar to what

00:16:50.500 --> 00:16:54.260
you get in Blender or any
the expensive 3-D rendering

00:16:54.260 --> 00:16:55.240
package.

00:16:55.240 --> 00:16:58.740
The only default, the only
issue with that approach

00:16:58.740 --> 00:17:02.100
is that, it was running
so much code on the GPU,

00:17:02.100 --> 00:17:04.339
that after a few
seconds, like 30 seconds,

00:17:04.339 --> 00:17:07.458
the Nexus 4 would
overheat and reboot.

00:17:07.458 --> 00:17:09.869
It was just trying to not melt.

00:17:09.869 --> 00:17:11.310
CHET HAASE: So we fired him.

00:17:11.310 --> 00:17:14.589
ROMAIN GUY: So I got
fired. [AUDIENCE LAUGHING]

00:17:14.589 --> 00:17:18.400
So we decided that maybe this
was not the right way to do it.

00:17:18.400 --> 00:17:21.550
So smarter people than me
found a different approach.

00:17:21.550 --> 00:17:24.410
So basically what
happens is, the system

00:17:24.410 --> 00:17:26.589
will calculate geometry.

00:17:26.589 --> 00:17:28.720
It will generate a
bunch of triangles

00:17:28.720 --> 00:17:31.810
to send to the GPU that
will represent the shadow.

00:17:31.810 --> 00:17:33.900
And there are actually two
shadows in that system.

00:17:33.900 --> 00:17:35.358
There's the shadow
that's generated

00:17:35.358 --> 00:17:36.610
by the Area Light itself.

00:17:36.610 --> 00:17:38.620
So it just projects
the Area Light

00:17:38.620 --> 00:17:42.890
through the shape of your
View, through the outline.

00:17:42.890 --> 00:17:45.780
And if you just did that, you'd
get that really dark shadow

00:17:45.780 --> 00:17:46.800
that we saw before.

00:17:46.800 --> 00:17:50.000
So the first trick is to make
that shadow semi-translucent.

00:17:50.000 --> 00:17:52.941
So that's simulates global
illumination a little bit.

00:17:52.941 --> 00:17:54.440
The second trick--
and it's actually

00:17:54.440 --> 00:17:56.885
a a really nice trick-- is
to have a second shadow.

00:17:56.885 --> 00:18:00.085
The idea is that because the
light is bouncing around,

00:18:00.085 --> 00:18:02.460
really, the world around you
is acting as a light source.

00:18:02.460 --> 00:18:04.020
So we're casting
a second shadows,

00:18:04.020 --> 00:18:07.820
as if the entire world around
your device was a light source.

00:18:07.820 --> 00:18:09.512
This is called the
Ambient Shadow.

00:18:09.512 --> 00:18:10.970
And it's done a
little differently.

00:18:10.970 --> 00:18:14.490
It just projects your View
straight onto the ground,

00:18:14.490 --> 00:18:15.910
as a secondary
translucent shadow.

00:18:15.910 --> 00:18:17.365
The effect is really subtle.

00:18:17.365 --> 00:18:20.470
But when it's missing, it
doesn't look nearly as good.

00:18:20.470 --> 00:18:22.950
So this is not
grounded in reality.

00:18:22.950 --> 00:18:25.070
This is not how light
works in real life.

00:18:25.070 --> 00:18:27.120
But as always with
graphics, what matters

00:18:27.120 --> 00:18:28.660
is that it looks good.

00:18:28.660 --> 00:18:32.150
How it's done doesn't
really matter.

00:18:32.150 --> 00:18:34.220
So like I said, the
system computes geometry.

00:18:34.220 --> 00:18:36.230
So every time you move
the View in X, Y, or Z,

00:18:36.230 --> 00:18:39.560
so if you change the elevation,
because the light source itself

00:18:39.560 --> 00:18:43.030
has a fixed position, the
geometry has to be recomputed.

00:18:43.030 --> 00:18:46.060
The nice thing is, most of
the work is done by the GPU.

00:18:46.060 --> 00:18:48.376
We just interpolate colors.

00:18:48.376 --> 00:18:50.500
So this will show you what
the geometry looks like.

00:18:50.500 --> 00:18:53.730
So this screenshot is taken from
another prototype that actually

00:18:53.730 --> 00:18:57.290
runs on desktops, that
was implemented just

00:18:57.290 --> 00:18:59.030
to play with
different algorithms.

00:18:59.030 --> 00:19:00.488
So you have your
nice, soft shadow.

00:19:00.488 --> 00:19:03.417
You have your view that's
tilted in 3D space.

00:19:03.417 --> 00:19:06.000
And this is the kind of geometry
that the system will actually

00:19:06.000 --> 00:19:07.670
generate to draw the shadow.

00:19:07.670 --> 00:19:11.150
So here, you're seeing only one
of the two shadows I mentioned.

00:19:11.150 --> 00:19:13.091
And the geometry
that's being used

00:19:13.091 --> 00:19:14.590
is not necessarily
the same geometry

00:19:14.590 --> 00:19:16.280
that's used on
the device or that

00:19:16.280 --> 00:19:18.350
will be used on
the final release.

00:19:18.350 --> 00:19:21.900
But this gives you an
idea of how it works.

00:19:21.900 --> 00:19:25.590
Just one tip, when you use
those shadows-- by default,

00:19:25.590 --> 00:19:28.310
Views have a pivot
point in the center

00:19:28.310 --> 00:19:30.270
that's used to apply rotations.

00:19:30.270 --> 00:19:34.520
So if you rotate your View
on the x-axis or the y-axis

00:19:34.520 --> 00:19:36.710
and you leave the
default pivot points,

00:19:36.710 --> 00:19:38.770
your View will intersect
with the ground.

00:19:38.770 --> 00:19:42.330
So visually, on screen, because
it's not a real 3D system,

00:19:42.330 --> 00:19:45.340
you won't see your view
being clipped by the ground.

00:19:45.340 --> 00:19:48.150
There's actually no
real ground at Z=0.

00:19:48.150 --> 00:19:50.030
But the shadow system
will think the ground

00:19:50.030 --> 00:19:51.355
is intersecting with your View.

00:19:51.355 --> 00:19:53.350
And you're going to get
a bunch of artifacts.

00:19:53.350 --> 00:19:56.220
So if you want to apply
3D rotations to your View,

00:19:56.220 --> 00:19:58.660
make sure that you set an
elevation that's high enough,

00:19:58.660 --> 00:20:00.920
that when you rotate the
View it doesn't intersect.

00:20:00.920 --> 00:20:03.620
It doesn't collide with
the View Hierarchy plane.

00:20:03.620 --> 00:20:04.990
You can compute it.

00:20:04.990 --> 00:20:06.202
It's simple trigonometry.

00:20:06.202 --> 00:20:08.410
Or you can just play with
values until it looks good.

00:20:08.410 --> 00:20:10.090
CHET HAASE: This is
an important point.

00:20:10.090 --> 00:20:12.700
It's easy to misconstrue
what we've done as, hey, now

00:20:12.700 --> 00:20:14.770
we have a full-on
3D modeling system.

00:20:14.770 --> 00:20:17.760
No, what we've done
is used a Z value

00:20:17.760 --> 00:20:20.890
to get physically correct
information about the View

00:20:20.890 --> 00:20:23.670
system and shadows, as we
boost these things into Z.

00:20:23.670 --> 00:20:24.880
But we don't have a Z buffer.

00:20:24.880 --> 00:20:26.004
It's not a modeling system.

00:20:26.004 --> 00:20:28.300
You can't use this as
a full-on 3D system

00:20:28.300 --> 00:20:31.060
for doing games, where objects
can be self-intersecting,

00:20:31.060 --> 00:20:33.250
and you actually get the
correct visual results.

00:20:33.250 --> 00:20:35.500
It's still a fast
2D rendering system

00:20:35.500 --> 00:20:37.397
that we've added some Z to.

00:20:37.397 --> 00:20:38.980
But if you're doing
things like these,

00:20:38.980 --> 00:20:41.140
you're going to run into
the edges of that system

00:20:41.140 --> 00:20:41.520
pretty quickly.

00:20:41.520 --> 00:20:42.370
ROMAIN GUY: Something
else that you

00:20:42.370 --> 00:20:45.440
should be aware of-- if you
have some Views that are stacked

00:20:45.440 --> 00:20:47.360
on top of each other
and some of these Views

00:20:47.360 --> 00:20:50.450
are rotated in 3D space
where you use or an X or Y

00:20:50.450 --> 00:20:53.600
rotation, the shadows that
are projected by the Views

00:20:53.600 --> 00:20:57.370
above will not be
projected on those Views.

00:20:57.370 --> 00:20:59.850
So the projection of
the shadow is always

00:20:59.850 --> 00:21:01.470
meant for the ground plane.

00:21:01.470 --> 00:21:03.810
So the shadows will
draw on top of it

00:21:03.810 --> 00:21:06.010
the various cards in your stack.

00:21:06.010 --> 00:21:08.750
But they won't be
applied to the Transform

00:21:08.750 --> 00:21:10.660
planes of those different Views.

00:21:10.660 --> 00:21:12.780
So don't hesitate to play
with the 3D Rotations.

00:21:12.780 --> 00:21:14.238
You can create
really nice effects.

00:21:14.238 --> 00:21:16.817
And Chet, in the previous
session today, this morning,

00:21:16.817 --> 00:21:19.150
showed a little tilt animation,
when you drive your car.

00:21:19.150 --> 00:21:20.770
It looks fantastic.

00:21:20.770 --> 00:21:24.220
Just be aware of these
very small limitations.

00:21:29.060 --> 00:21:33.099
So the shadows, so far, we've
show them mostly static.

00:21:33.099 --> 00:21:35.140
and in Chet's demo, I
don't know if you noticed--

00:21:35.140 --> 00:21:37.430
we're going to get back to it.

00:21:37.430 --> 00:21:39.070
the shadows are
actually animated.

00:21:39.070 --> 00:21:40.900
And there are various
ways of doing it.

00:21:40.900 --> 00:21:44.070
It's very useful when you
want to create a Press

00:21:44.070 --> 00:21:45.610
State, like an
animated Press State.

00:21:45.610 --> 00:21:47.026
So you press on
the button, and it

00:21:47.026 --> 00:21:49.710
feels like the button
is raising in 3D space.

00:21:49.710 --> 00:21:52.720
And there are a couple
ways of doing that.

00:21:52.720 --> 00:21:53.765
So you can see here.

00:21:53.765 --> 00:21:55.390
It might be difficult
to see on screen.

00:21:55.390 --> 00:21:57.800
But if you look at the
button on the right,

00:21:57.800 --> 00:21:59.280
when the finger
presses the button,

00:21:59.280 --> 00:22:02.204
you'll see the shadow
grows a little bit.

00:22:02.204 --> 00:22:04.370
It's actually even harder
to see on your own device,

00:22:04.370 --> 00:22:05.869
because your finger
is on top of it.

00:22:05.869 --> 00:22:08.620
But it still looks pretty cool.

00:22:08.620 --> 00:22:09.970
And this is how it's done.

00:22:09.970 --> 00:22:12.410
So you can use a simple
stateListAnimator.

00:22:12.410 --> 00:22:15.780
So the button that we
just saw in the video

00:22:15.780 --> 00:22:17.230
is a simple Image button.

00:22:17.230 --> 00:22:18.880
You specify a stateListAnimator.

00:22:18.880 --> 00:22:22.000
It's a resource that lives
in the Anim directory.

00:22:22.000 --> 00:22:23.950
And that resource
looks like this.

00:22:23.950 --> 00:22:26.330
If you used
SelectDrawable before,

00:22:26.330 --> 00:22:28.880
if you've created custom
drawables for buttons,

00:22:28.880 --> 00:22:30.330
this looks very familiar.

00:22:30.330 --> 00:22:33.790
The difference is, that inside
the Items of the selector,

00:22:33.790 --> 00:22:36.800
instead of putting drawables,
you just put Object Animators.

00:22:36.800 --> 00:22:38.950
So here, what we're
doing-- in the first item,

00:22:38.950 --> 00:22:41.640
we say, when the
state is pressed,

00:22:41.640 --> 00:22:44.990
I want you to animate
from a certain Elevation

00:22:44.990 --> 00:22:46.390
to another Elevation.

00:22:46.390 --> 00:22:48.670
And when, at the bottom,
the state is not pressed,

00:22:48.670 --> 00:22:50.330
I want to animate the other way.

00:22:50.330 --> 00:22:51.580
And that's all you have to do.

00:22:51.580 --> 00:22:53.560
It's a very, very
easy way to create

00:22:53.560 --> 00:22:55.890
those nice secondary
animations in your UI.

00:22:55.890 --> 00:22:59.000
And of course, you could
inmate any property.

00:22:59.000 --> 00:23:01.100
The only trick is,
that from XML, you

00:23:01.100 --> 00:23:04.060
have to tell the system the type
of propert you want to animate.

00:23:04.060 --> 00:23:07.710
You won't be able to figure
out that the TranslationZ here

00:23:07.710 --> 00:23:08.250
is a float.

00:23:11.300 --> 00:23:14.480
So this is how you would use the
StateListAnimators from code.

00:23:14.480 --> 00:23:16.080
It's easier to do it from XML.

00:23:16.080 --> 00:23:18.320
But if you want to dynamically
do those animations.

00:23:18.320 --> 00:23:23.262
This is a better one that
you're probably familiar with.

00:23:23.262 --> 00:23:26.884
CHET HAASE: So one of the big,
new animation capabilities

00:23:26.884 --> 00:23:29.050
that we enabled in platform
is Activity Transitions,

00:23:29.050 --> 00:23:32.210
in particular the
ability to share elements

00:23:32.210 --> 00:23:35.230
between separate activities,
which before, you could do.

00:23:35.230 --> 00:23:38.340
But it's a little tricky
to figure out how it works.

00:23:38.340 --> 00:23:40.500
We created a DevByte
showing how you can do it.

00:23:40.500 --> 00:23:43.041
So you can certainly take that
approach in previous releases.

00:23:43.041 --> 00:23:44.840
But now, we've taken
the new transition

00:23:44.840 --> 00:23:46.255
API that was new in KitKat.

00:23:46.255 --> 00:23:48.350
And we've basically baked
that into the ability

00:23:48.350 --> 00:23:51.140
to have much more rich
animations between activities.

00:23:51.140 --> 00:23:53.720
So now, you can think of
these three separate phases

00:23:53.720 --> 00:23:55.220
of these activity
transitions, where

00:23:55.220 --> 00:23:57.030
we have an animation
that's happening

00:23:57.030 --> 00:23:58.840
in the activity
that's going away,

00:23:58.840 --> 00:24:00.990
where we can animate
the items out.

00:24:00.990 --> 00:24:03.235
And we have items
in the new activity

00:24:03.235 --> 00:24:04.781
that are going to
be animating in.

00:24:04.781 --> 00:24:06.530
In the meantime, we're
passing information

00:24:06.530 --> 00:24:08.900
about a shared element
between these activities.

00:24:08.900 --> 00:24:10.620
So that we can then
animate that item

00:24:10.620 --> 00:24:13.060
to some state in the
Launching Activity

00:24:13.060 --> 00:24:14.600
and then animate
it from that state

00:24:14.600 --> 00:24:17.060
into its final position
in the launched activity--

00:24:17.060 --> 00:24:19.580
so sort of all these different
separate bits, all of which

00:24:19.580 --> 00:24:23.085
can be customized, to
whatever extent you want.

00:24:23.085 --> 00:24:25.830
And the information that we
pass about that shared element

00:24:25.830 --> 00:24:29.500
is the position of that element,
the size of that element,

00:24:29.500 --> 00:24:33.250
and a Bitmap that represents
that element, as well

00:24:33.250 --> 00:24:33.880
as the name.

00:24:33.880 --> 00:24:36.577
And then, if the Launched
Activity knows something

00:24:36.577 --> 00:24:38.410
associated with that--
so if you're in music

00:24:38.410 --> 00:24:39.990
app and you see
a list of albums.

00:24:39.990 --> 00:24:42.040
And then you go into
a detailed view,

00:24:42.040 --> 00:24:44.705
and you pass over a shared
element with the name Album.

00:24:44.705 --> 00:24:46.330
Then the Launched
Activity can say, oh,

00:24:46.330 --> 00:24:47.920
I know where to put an
album on this screen.

00:24:47.920 --> 00:24:49.277
Sure, I'll take that element.

00:24:49.277 --> 00:24:50.860
Then it's in control
of the transition

00:24:50.860 --> 00:24:52.980
and can animate
it appropriately.

00:24:52.980 --> 00:24:55.900
There's also the ability to
customize these transitions.

00:24:55.900 --> 00:24:58.651
And that's customization in
terms of the actual transitions

00:24:58.651 --> 00:24:59.150
you run.

00:24:59.150 --> 00:25:01.000
So you can have different
kinds of effects.

00:25:01.000 --> 00:25:03.810
Right here, we see two
different transitions happening.

00:25:03.810 --> 00:25:04.910
This one is an Explode.

00:25:04.910 --> 00:25:08.520
You can see the items animating
out to the top and the bottom.

00:25:08.520 --> 00:25:11.010
And then we toggle
that Check Box on top.

00:25:11.010 --> 00:25:14.310
And we get a Cross Fade, the
default Cross Fade transition

00:25:14.310 --> 00:25:14.810
instead.

00:25:14.810 --> 00:25:17.810
So you can customize things
with either the transitions

00:25:17.810 --> 00:25:20.160
that we ship with the
platform or transitions

00:25:20.160 --> 00:25:21.910
that you write on your own.

00:25:21.910 --> 00:25:23.390
You can also
customize it, in terms

00:25:23.390 --> 00:25:26.950
of which transitions target
which items in the UI.

00:25:26.950 --> 00:25:30.000
So you can say, I want Fades
to happen on these targets.

00:25:30.000 --> 00:25:33.250
I want Explodes to happen
on these other items.

00:25:33.250 --> 00:25:35.420
And you get a much more
choreographed experience,

00:25:35.420 --> 00:25:37.060
as you go from
activity to activity.

00:25:39.950 --> 00:25:41.460
So here's some of
the code you would

00:25:41.460 --> 00:25:44.030
need to use in
enabling the basics.

00:25:44.030 --> 00:25:45.710
There's a lot more
code, a lot more APIs

00:25:45.710 --> 00:25:47.690
that I won't go
into the details of.

00:25:47.690 --> 00:25:49.680
First of all,
right now, you need

00:25:49.680 --> 00:25:53.250
to be using the Material
Theme on the preview release.

00:25:53.250 --> 00:25:54.997
That requirement may go away.

00:25:54.997 --> 00:25:57.330
It seems like we should just
enable activity transitions

00:25:57.330 --> 00:25:58.970
in general, if you want them.

00:25:58.970 --> 00:26:01.030
But right now, you enable
the Material Theme.

00:26:01.030 --> 00:26:03.240
And then you would say, I
want to use Window Content

00:26:03.240 --> 00:26:03.790
Transitions.

00:26:03.790 --> 00:26:07.170
You can either do this
in your theme itself.

00:26:07.170 --> 00:26:09.450
Or you can specify this
in code, by calling

00:26:09.450 --> 00:26:11.360
their requestFeature method.

00:26:11.360 --> 00:26:13.660
And then you can set
some optional behaviors.

00:26:13.660 --> 00:26:15.262
So once you enable
Transitions, you're

00:26:15.262 --> 00:26:16.720
going to get some
default behavior.

00:26:16.720 --> 00:26:18.970
It's just going to cross
fade between your activities,

00:26:18.970 --> 00:26:22.540
by fading the items in and out,
as you go between activities.

00:26:22.540 --> 00:26:25.240
But you can set up
custom animations here.

00:26:25.240 --> 00:26:27.450
We're going to use an Explode
on the Exit Transition.

00:26:27.450 --> 00:26:29.510
So as I leave my
activity, items are

00:26:29.510 --> 00:26:32.550
going to stagger and animate
out to the top and the bottom.

00:26:32.550 --> 00:26:34.710
You can also specify
the Overlap behavior.

00:26:34.710 --> 00:26:36.880
By default, we're
going to overlap

00:26:36.880 --> 00:26:39.500
the animations of the enter
and exit at the same time,

00:26:39.500 --> 00:26:42.250
or as overlapped as
they can be, depending

00:26:42.250 --> 00:26:45.420
on how long it takes the
Launched Activity to actually

00:26:45.420 --> 00:26:47.800
inflate and get ready to go.

00:26:47.800 --> 00:26:50.140
Or if you want to choreograph
it more carefully and say,

00:26:50.140 --> 00:26:52.360
no, I want this animation
to finish first.

00:26:52.360 --> 00:26:56.032
Then you can set the Overlap
property to be false instead.

00:26:56.032 --> 00:26:57.490
And then you can
set up information

00:26:57.490 --> 00:26:58.680
about shared elements.

00:26:58.680 --> 00:27:00.990
This one sets up
a single element

00:27:00.990 --> 00:27:02.290
and assigns a name to it.

00:27:02.290 --> 00:27:04.470
You can also have
a set of elements.

00:27:04.470 --> 00:27:06.870
You're basically passing
this map down and saying,

00:27:06.870 --> 00:27:08.760
this item is going to
be used with this name.

00:27:08.760 --> 00:27:11.581
And then the Launched Activity
gets all that information

00:27:11.581 --> 00:27:12.330
on the other side.

00:27:12.330 --> 00:27:14.660
And then you start the
activity with that information,

00:27:14.660 --> 00:27:17.600
and away it goes.

00:27:17.600 --> 00:27:20.800
So how they work is basically
building on the Transition

00:27:20.800 --> 00:27:22.320
capability that
we had in KitKat.

00:27:22.320 --> 00:27:24.270
The big idea with
transitions is,

00:27:24.270 --> 00:27:26.327
I want to know where
things are at now.

00:27:26.327 --> 00:27:28.160
And then I want to run
Layout and figure out

00:27:28.160 --> 00:27:29.620
where things are at afterwards.

00:27:29.620 --> 00:27:31.390
And then I want to
start the animation,

00:27:31.390 --> 00:27:32.870
based on where
things were and then

00:27:32.870 --> 00:27:34.350
animate them to where they are.

00:27:34.350 --> 00:27:37.290
It's the same idea, except
that was in a single View

00:27:37.290 --> 00:27:38.860
Hierarchy in an activity.

00:27:38.860 --> 00:27:41.587
But this is applied
across activities instead.

00:27:41.587 --> 00:27:43.170
And it's applied in
the following way.

00:27:43.170 --> 00:27:46.600
We know what's happening to the
items in the Launched Activity.

00:27:46.600 --> 00:27:49.787
So in the Explodes
case, for a transition,

00:27:49.787 --> 00:27:51.370
we're going to move
all the items out.

00:27:51.370 --> 00:27:53.940
So we're going to say, OK, I
know where everything is now.

00:27:53.940 --> 00:27:56.190
And I know where everything
is when it's animated out.

00:27:56.190 --> 00:27:57.630
We're going to run
that animation.

00:27:57.630 --> 00:28:00.140
And same thing for the
Launched Activity--

00:28:00.140 --> 00:28:01.700
we know where things
are off screen.

00:28:01.700 --> 00:28:04.420
We can animate them on
screen, all using Transitions.

00:28:04.420 --> 00:28:06.480
And then the final element
is the Hero Element.

00:28:06.480 --> 00:28:08.750
So once the Launched
Activity gets the information

00:28:08.750 --> 00:28:11.260
about the elements
that you want to share,

00:28:11.260 --> 00:28:13.980
it says, oh, I know where to
put the album on the screen.

00:28:13.980 --> 00:28:16.050
And I know what size
I wanted it to have.

00:28:16.050 --> 00:28:17.460
And I know what
size and position

00:28:17.460 --> 00:28:19.181
it had where it started.

00:28:19.181 --> 00:28:21.680
So I'm going to run a transition
that automatically animates

00:28:21.680 --> 00:28:24.476
those changes over time as well.

00:28:24.476 --> 00:28:28.480
ROMAIN GUY: So sometimes the
default automated transitions

00:28:28.480 --> 00:28:32.490
are not enough for
some types of effects.

00:28:32.490 --> 00:28:34.710
When you use one of those
automated transitions,

00:28:34.710 --> 00:28:38.070
the framework will look at some
specific properties of Views,

00:28:38.070 --> 00:28:40.487
like Size, Position, Alpha.

00:28:40.487 --> 00:28:42.320
But it doesn't know
about all the properties

00:28:42.320 --> 00:28:43.778
that you can use
in the UI Toolkit.

00:28:43.778 --> 00:28:44.660
So here's an example.

00:28:44.660 --> 00:28:46.770
In the list of
thumbnails, you can

00:28:46.770 --> 00:28:48.820
see that the thumbnails
are darkened.

00:28:48.820 --> 00:28:51.560
So I use the Color
filter on the Image Views

00:28:51.560 --> 00:28:52.560
to darken the thumbnail.

00:28:52.560 --> 00:28:55.350
So what I want to do is, when we
transition to the new activity,

00:28:55.350 --> 00:29:00.294
I want to animate that color
filter from dark to clear.

00:29:00.294 --> 00:29:02.460
And because the Automated
Transition system does not

00:29:02.460 --> 00:29:05.740
know how to do that, we need to
synchronize with that system,

00:29:05.740 --> 00:29:07.962
to run the Normal
View animations when

00:29:07.962 --> 00:29:08.920
the transition is done.

00:29:08.920 --> 00:29:11.260
This is actually
fairly easy to do.

00:29:11.260 --> 00:29:14.410
So to run an animation
after a transition,

00:29:14.410 --> 00:29:16.500
you can just get the
entire transition

00:29:16.500 --> 00:29:18.610
from your onCreate
method in your activity.

00:29:18.610 --> 00:29:20.040
You can add the listener.

00:29:20.040 --> 00:29:22.450
And we just listen
for onTransitionEnd.

00:29:22.450 --> 00:29:24.720
So at the end of the
transition, I just

00:29:24.720 --> 00:29:26.260
run my custom animations.

00:29:26.260 --> 00:29:29.420
So in this case, I just
do the color filter

00:29:29.420 --> 00:29:30.860
that I'm not
showing in the code,

00:29:30.860 --> 00:29:32.485
because it's a little
more complicated.

00:29:32.485 --> 00:29:34.400
I also fade in a
couple of buttons.

00:29:34.400 --> 00:29:36.520
It's also important to
remove the listener,

00:29:36.520 --> 00:29:38.970
when you're done using it.

00:29:38.970 --> 00:29:41.680
You also want-- if we go back
to the video, you can see,

00:29:41.680 --> 00:29:44.390
that when we go back to
the list of thumbnails,

00:29:44.390 --> 00:29:49.251
we will want to-- if the video
plays-- OK, when we go back

00:29:49.251 --> 00:29:51.625
to the list of thumbnails, we
want to redarken the image.

00:29:51.625 --> 00:29:53.166
And of course, it's
not in the video.

00:29:53.166 --> 00:29:54.380
Sorry about that.

00:29:54.380 --> 00:29:56.070
So you want to be
able to run custom

00:29:56.070 --> 00:29:57.800
animations before
the transition.

00:29:57.800 --> 00:30:00.650
And an easy way to do this
is to override onBackPressed.

00:30:00.650 --> 00:30:02.260
You run your normal
View Animations.

00:30:02.260 --> 00:30:04.160
You listen for the end
of those animations.

00:30:04.160 --> 00:30:06.640
And at the end, you just call
this finishAfterTransition

00:30:06.640 --> 00:30:08.735
method.

00:30:08.735 --> 00:30:09.787
You used to call Finish.

00:30:09.787 --> 00:30:11.370
But if you call
finishAfterTransition,

00:30:11.370 --> 00:30:13.360
we're going to run
the transitions

00:30:13.360 --> 00:30:14.930
and then finish the activity.

00:30:14.930 --> 00:30:18.600
Just be careful if you
implement those techniques.

00:30:18.600 --> 00:30:20.350
The code is a little
bit more complicated,

00:30:20.350 --> 00:30:22.950
if you want to deal with the
screen rotation correctly,

00:30:22.950 --> 00:30:24.410
because if you rely on
those [? listeners, ?]

00:30:24.410 --> 00:30:26.770
when you rotate the screen,
there won't be a transition.

00:30:26.770 --> 00:30:28.420
And so your
animations won't run.

00:30:28.420 --> 00:30:29.520
So it's important
to set something

00:30:29.520 --> 00:30:30.936
in your bundle and
your safe state

00:30:30.936 --> 00:30:33.810
and take a different
action based on that.

00:30:33.810 --> 00:30:35.830
I mentioned animating
a color filter.

00:30:35.830 --> 00:30:38.660
That's a technique we've shown
in presentations in the past.

00:30:38.660 --> 00:30:42.029
It was a little painful
before, because on every frame,

00:30:42.029 --> 00:30:43.820
you would have to create
a new color filter

00:30:43.820 --> 00:30:45.400
instance to create
your animation.

00:30:45.400 --> 00:30:46.640
That was generating garbage.

00:30:46.640 --> 00:30:49.071
That was causing
[? DC ?] pauses.

00:30:49.071 --> 00:30:51.320
So sometimes you would get
a stutter in the animation,

00:30:51.320 --> 00:30:53.960
just because of the extra
garbage that was generated.

00:30:53.960 --> 00:30:57.340
So as of the L Preview, you
can animate color filters,

00:30:57.340 --> 00:30:59.840
without recreating
on every frame.

00:30:59.840 --> 00:31:01.570
There's a new setColor method.

00:31:01.570 --> 00:31:03.360
So here, we use an
Object Animator,

00:31:03.360 --> 00:31:06.080
and we animate the color
property of the filter

00:31:06.080 --> 00:31:07.610
directly.

00:31:07.610 --> 00:31:10.670
The only trick here is that
a color filter knows nothing

00:31:10.670 --> 00:31:12.550
about the view it's
associated with.

00:31:12.550 --> 00:31:15.780
So just changing the
properties of the color filter

00:31:15.780 --> 00:31:17.880
will not change what's
drawn on screen.

00:31:17.880 --> 00:31:20.920
You need to trigger
a redraw of the View

00:31:20.920 --> 00:31:22.180
that uses the color filter.

00:31:22.180 --> 00:31:24.520
So an easy way to do
that, you can see here,

00:31:24.520 --> 00:31:25.940
is to add an UpdateListener.

00:31:25.940 --> 00:31:28.900
And on every frame, you
set the color filter again,

00:31:28.900 --> 00:31:31.440
on the Drawable of the View
that you want to animate.

00:31:31.440 --> 00:31:33.148
And then everything
will redraw properly.

00:31:36.344 --> 00:31:38.760
CHET HAASE: One of the new
elements in the Preview Release

00:31:38.760 --> 00:31:41.810
is reliance on and
more flexibility

00:31:41.810 --> 00:31:43.490
with colors in general.

00:31:43.490 --> 00:31:46.390
The assets that we have by
default are all gray scale.

00:31:46.390 --> 00:31:49.940
And this is done on purpose, so
it's easier to then tint those,

00:31:49.940 --> 00:31:53.200
as required by your application
or by different states

00:31:53.200 --> 00:31:56.100
of your application or by
different activities within it.

00:31:56.100 --> 00:31:59.560
So it's easier to brand
your application the way

00:31:59.560 --> 00:32:02.210
that you want and also
to produce less assets.

00:32:02.210 --> 00:32:04.870
So previously, if you wanted
to colorize your application,

00:32:04.870 --> 00:32:07.060
you could certainly do
that, by creating images

00:32:07.060 --> 00:32:08.280
with that color.

00:32:08.280 --> 00:32:10.650
What we'd like you to do
instead is actually use

00:32:10.650 --> 00:32:13.260
these neutral colors
and then tint them

00:32:13.260 --> 00:32:16.790
as appropriate, to whatever
that situation is--

00:32:16.790 --> 00:32:19.760
so much easier, much more
powerful, much more flexible.

00:32:19.760 --> 00:32:22.120
And one of the elements that's
going to make that easier

00:32:22.120 --> 00:32:24.730
is a new utility in the
support library, which

00:32:24.730 --> 00:32:27.760
is the Palate utility, which
allows you to then go out.

00:32:27.760 --> 00:32:30.900
There's another reliance
on images as well.

00:32:30.900 --> 00:32:33.620
You've seen a lot of images in
a lot of the material design

00:32:33.620 --> 00:32:34.532
content so far.

00:32:34.532 --> 00:32:36.240
Wouldn't it be nice
if you could actually

00:32:36.240 --> 00:32:39.260
figure out color information
about those images

00:32:39.260 --> 00:32:42.390
and then use that information
to then colorized your UI,

00:32:42.390 --> 00:32:45.620
as we saw in
Romain's demo so far?

00:32:45.620 --> 00:32:47.572
So actually, I already
explained this.

00:32:47.572 --> 00:32:49.280
So I'm going to just
go on to your stuff.

00:32:49.280 --> 00:32:50.090
It's more interesting.

00:32:50.090 --> 00:32:51.631
ROMAIN GUY: So first,
I will show you

00:32:51.631 --> 00:32:54.130
how to change the colors
of the Static Theme.

00:32:54.130 --> 00:32:56.920
So that was the first activity
in the demo I showed you.

00:32:56.920 --> 00:32:59.920
So it uses pink for the
Action Bar, the Status Bar,

00:32:59.920 --> 00:33:01.030
and the Nav Bar.

00:33:01.030 --> 00:33:03.640
So it was also using
purple for the ripples.

00:33:03.640 --> 00:33:05.040
And this is how it's done.

00:33:05.040 --> 00:33:06.370
So you create a new theme.

00:33:06.370 --> 00:33:10.907
You inherit from Theme.Material
or Theme.Material.Light.

00:33:10.907 --> 00:33:11.990
And there are five colors.

00:33:11.990 --> 00:33:12.710
You can override.

00:33:12.710 --> 00:33:13.790
You see them here.

00:33:13.790 --> 00:33:16.280
We have colorPrimary,
colorPrimaryDark,

00:33:16.280 --> 00:33:19.550
colorBackground, colorAccent,
and colorControlHighlight.

00:33:19.550 --> 00:33:23.750
And the system will, by
default, use those properties

00:33:23.750 --> 00:33:25.000
to colorize the Theme.

00:33:25.000 --> 00:33:27.630
So I colorized the
different values,

00:33:27.630 --> 00:33:30.090
based on the actual RGB values.

00:33:30.090 --> 00:33:32.080
You can see, for
instance, the colorAccent

00:33:32.080 --> 00:33:34.389
and colorControlHighlights
are purple.

00:33:34.389 --> 00:33:36.180
And that's where the
purple and the ripples

00:33:36.180 --> 00:33:39.110
were coming from, so
entirely from the Theme.

00:33:39.110 --> 00:33:41.650
You can see next that I've
also colorized the Navigation

00:33:41.650 --> 00:33:43.900
Bar, the Nav Bar at the
bottom, and the Status Bar.

00:33:43.900 --> 00:33:46.950
So I just use references to
reuse the primary dark color

00:33:46.950 --> 00:33:47.610
from my Theme.

00:33:47.610 --> 00:33:49.490
And I've also changed
the background color

00:33:49.490 --> 00:33:51.030
to one of the colors
from my Theme.

00:33:51.030 --> 00:33:53.380
So it's very easy,
very simple to do

00:33:53.380 --> 00:33:57.370
and certainly beats creating
dozens or hundreds of assets,

00:33:57.370 --> 00:34:00.400
just to change the
default color to green.

00:34:00.400 --> 00:34:02.940
Now, to generate those
different secondary activities,

00:34:02.940 --> 00:34:06.740
that all the colors
are coming from images,

00:34:06.740 --> 00:34:08.610
things are a little
bit more difficult.

00:34:08.610 --> 00:34:11.360
There's a new API that Chet
mention called Palette.

00:34:11.360 --> 00:34:13.659
It comes with the
new support library.

00:34:13.659 --> 00:34:15.800
So the draw file is
android-support-v7-palette.

00:34:18.429 --> 00:34:20.179
And what it does is,
you give it a Bitmap.

00:34:20.179 --> 00:34:22.512
And it will generate a series
of color from that Bitmap.

00:34:22.512 --> 00:34:25.139
So by default, it will
try to generate 16 colors.

00:34:25.139 --> 00:34:27.110
You can specify how
many colors you want.

00:34:27.110 --> 00:34:29.870
It will also try to give
you six Named Colors.

00:34:29.870 --> 00:34:31.757
And you'll see what I
mean by Named Colors.

00:34:31.757 --> 00:34:34.215
You just have to be careful,
because those Named Colors can

00:34:34.215 --> 00:34:35.000
be null.

00:34:35.000 --> 00:34:37.550
So it you pass the
Palette API an image

00:34:37.550 --> 00:34:39.270
that only contains
blue, it won't

00:34:39.270 --> 00:34:41.145
be able to generate
those six colors for you.

00:34:41.145 --> 00:34:44.520
So you might have to
use fall-back colors

00:34:44.520 --> 00:34:46.110
in your application.

00:34:46.110 --> 00:34:49.190
So this is an example of
the output of Palette.

00:34:49.190 --> 00:34:52.980
So given that image on the left,
you can see the Named Colors.

00:34:52.980 --> 00:34:56.255
So they are called Dark muted,
Dark vibrant, Muted, Vibrant,

00:34:56.255 --> 00:34:58.540
Light muted, and Light vibrant.

00:34:58.540 --> 00:35:01.390
And on the right, you
can see the full palette.

00:35:01.390 --> 00:35:03.640
So I think it generates
something like-- I don't know.

00:35:03.640 --> 00:35:07.140
Do the math-- 15 colors or
something, from that image.

00:35:07.140 --> 00:35:08.350
CHET HAASE: 14.

00:35:08.350 --> 00:35:08.855
that's 14.

00:35:08.855 --> 00:35:09.602
ROMAIN GUY: OK.

00:35:09.602 --> 00:35:11.060
CHET HAASE: I've
got a Math degree.

00:35:11.060 --> 00:35:13.910
ROMAIN GUY: That
why I was fired.

00:35:13.910 --> 00:35:15.850
This is how to use
that Palette API.

00:35:15.850 --> 00:35:16.690
It's super simple.

00:35:16.690 --> 00:35:17.773
You call Palette.generate.

00:35:17.773 --> 00:35:18.770
You give it a Bitmap.

00:35:18.770 --> 00:35:21.170
Optionally, you could use the
number of colors you want.

00:35:21.170 --> 00:35:23.540
There's an asynchronous
version of Palette.

00:35:23.540 --> 00:35:26.010
So if you give it
large images, it's

00:35:26.010 --> 00:35:27.500
going to take a
fair amount of time

00:35:27.500 --> 00:35:28.958
to generate the
Palette, because it

00:35:28.958 --> 00:35:31.040
has to look at all the
pixels in the image.

00:35:31.040 --> 00:35:32.529
So there's a
call-back system, so

00:35:32.529 --> 00:35:34.320
that you can do something
else while you're

00:35:34.320 --> 00:35:36.234
waiting for the
Palette to come back.

00:35:36.234 --> 00:35:37.650
And this is just
an example of how

00:35:37.650 --> 00:35:40.370
you would apply programatically
the color to your UI.

00:35:40.370 --> 00:35:43.090
So for instance, I change
here the background Drawable.

00:35:43.090 --> 00:35:44.950
I use the dark muted color.

00:35:44.950 --> 00:35:46.639
So notice, that on
the Palette, when

00:35:46.639 --> 00:35:48.680
you get a color, you
actually get a Palette item.

00:35:48.680 --> 00:35:50.340
You don't get a color directly.

00:35:50.340 --> 00:35:51.970
So that object can be No.

00:35:51.970 --> 00:35:53.720
And if it's not
No, you can getRGB,

00:35:53.720 --> 00:35:55.870
to get the RGB
color for that item.

00:35:58.760 --> 00:36:00.520
This is a slightly
more involved example.

00:36:00.520 --> 00:36:04.520
So here, all my
buttons used ripples.

00:36:04.520 --> 00:36:06.360
And the ripples
in the background

00:36:06.360 --> 00:36:11.289
of the buttons, the colors
come from the Palette as well.

00:36:11.289 --> 00:36:12.330
And here's how you do it.

00:36:12.330 --> 00:36:16.470
So this is the RippleDrawable
that I was using from XML.

00:36:16.470 --> 00:36:19.440
So a RippleDrawable is
basically a layered drawable.

00:36:19.440 --> 00:36:21.850
So you can contain a
number of other drawables.

00:36:21.850 --> 00:36:23.670
So here, I only have
a circle inside,

00:36:23.670 --> 00:36:25.570
so that gives me that
nice, round background.

00:36:25.570 --> 00:36:26.736
And don't look at the color.

00:36:26.736 --> 00:36:29.785
The colors are here just so
that the XML can be compiled.

00:36:29.785 --> 00:36:31.840
I override those
colors from code.

00:36:31.840 --> 00:36:34.062
And this is how they
were overridden.

00:36:34.062 --> 00:36:36.020
So I have a background
color and the tint color

00:36:36.020 --> 00:36:38.080
that come from my Palette.

00:36:38.080 --> 00:36:40.180
You can call setColor
on the RippleDrawable,

00:36:40.180 --> 00:36:42.457
to change the color of
the ripples themselves.

00:36:42.457 --> 00:36:44.540
But if you want to change
the color of the circle,

00:36:44.540 --> 00:36:47.310
the actual background
of the button,

00:36:47.310 --> 00:36:49.780
since that background is a
layer in the RippleDrawable,

00:36:49.780 --> 00:36:51.540
you first have to
call getDrawable0,

00:36:51.540 --> 00:36:53.650
because I only have
one item on that list.

00:36:53.650 --> 00:36:59.160
And then I can set my tint
color on that second Drawable.

00:36:59.160 --> 00:37:02.682
Reveal-- you've seen
that animation earlier.

00:37:02.682 --> 00:37:03.890
We're going to show it again.

00:37:03.890 --> 00:37:05.200
So this is a new
animation that you're

00:37:05.200 --> 00:37:07.116
going to probably see
in a lot of applications

00:37:07.116 --> 00:37:08.671
that implement the
Material Theme.

00:37:08.671 --> 00:37:10.170
It's just a circular
shape animation

00:37:10.170 --> 00:37:12.400
that's used to reveal
any kind of content.

00:37:12.400 --> 00:37:14.520
So in L, it's super easy.

00:37:14.520 --> 00:37:16.811
You just call
 ViewAnimationUtils.createCircularReveal.

00:37:18.080 --> 00:37:20.280
And if you want to animate
that, in prior releases,

00:37:20.280 --> 00:37:21.770
there are techniques.

00:37:21.770 --> 00:37:24.800
So it's mostly using textured
shapes and BitmapShader.

00:37:24.800 --> 00:37:28.360
I wrote an article on my blog
that explains how to do it.

00:37:28.360 --> 00:37:29.240
It's fairly easy.

00:37:29.240 --> 00:37:32.130
But that means the View
itself cannot be dynamic.

00:37:32.130 --> 00:37:35.602
You cannot change the content of
the View during the animation.

00:37:35.602 --> 00:37:37.560
So this is what the
Circular Reveal looks like.

00:37:37.560 --> 00:37:39.820
When we press the Reveal
button in the bottom right,

00:37:39.820 --> 00:37:40.920
we just reveal MapView.

00:37:40.920 --> 00:37:43.380
So this is a fully dynamic
MapView that's not an image.

00:37:43.380 --> 00:37:47.210
It's the actual MapView running
open GIS and can be tilted

00:37:47.210 --> 00:37:49.000
and 3D rotated and moved.

00:37:51.960 --> 00:37:54.960
So the good news about
the implementation

00:37:54.960 --> 00:37:57.700
in L for Circular Reveal
is because the framework

00:37:57.700 --> 00:37:59.930
is aware of these animations.

00:37:59.930 --> 00:38:02.830
It's using a new implementation
that's Shader-based.

00:38:02.830 --> 00:38:04.710
So it's much more
efficient, compared

00:38:04.710 --> 00:38:06.950
to the way you could do
it in previous releases.

00:38:06.950 --> 00:38:09.449
So Chet mentioned that's,
again, in a previous session.

00:38:09.449 --> 00:38:11.490
So you could use the
stencil buffer from the GPU.

00:38:11.490 --> 00:38:13.747
If you clipped with a path
that's extremely expensive,

00:38:13.747 --> 00:38:14.580
you shouldn't do it.

00:38:14.580 --> 00:38:15.920
It's also using more memory.

00:38:15.920 --> 00:38:17.640
It was not anti-aliased.

00:38:17.640 --> 00:38:20.470
The new solution is I
still a little bit slower,

00:38:20.470 --> 00:38:23.000
than from not using a clipper
or from not using a Circular

00:38:23.000 --> 00:38:23.670
Reveal.

00:38:23.670 --> 00:38:25.465
But it's fairly efficient.

00:38:25.465 --> 00:38:27.930
And it doesn't
use memory at all.

00:38:27.930 --> 00:38:30.490
Just know that there's a slight
limitation in the L Preview.

00:38:30.490 --> 00:38:34.110
The Circular Reveal is not
anti-aliased at the moment.

00:38:34.110 --> 00:38:37.610
And it should be fixed
for the final release.

00:38:37.610 --> 00:38:39.510
This is what the
code looks like.

00:38:39.510 --> 00:38:42.977
So we call createCircularReveal
to reveal our MapView.

00:38:42.977 --> 00:38:44.560
And you have to pass
four parameters--

00:38:44.560 --> 00:38:47.880
the center of the origin
of the Reveal of the circle

00:38:47.880 --> 00:38:51.970
animation, the Start Radius,
and the Final Radius.

00:38:51.970 --> 00:38:54.150
So here, it's pretty easy
to do, because my button

00:38:54.150 --> 00:38:55.740
was sitting on top
of the MapView.

00:38:55.740 --> 00:38:57.860
So I can just get the
coordinates of the button

00:38:57.860 --> 00:39:00.640
and use that as the
center of the reveal.

00:39:00.640 --> 00:39:06.520
If the view from which the
reveal is originating from

00:39:06.520 --> 00:39:08.580
is not the child of the
view you're revealing,

00:39:08.580 --> 00:39:09.680
you might have to
do a bit of math

00:39:09.680 --> 00:39:11.096
to convert the
coordinate systems.

00:39:11.096 --> 00:39:12.170
But it's fairly simple.

00:39:12.170 --> 00:39:15.210
And similarly, when you
want to hide the MapView,

00:39:15.210 --> 00:39:16.720
you just swipe the radius.

00:39:16.720 --> 00:39:19.380
So you go from the
full circle down to 0.

00:39:19.380 --> 00:39:22.360
And it's going to do
the animation correctly.

00:39:22.360 --> 00:39:23.405
And we have five minutes.

00:39:23.405 --> 00:39:24.780
So we're going to
take questions,

00:39:24.780 --> 00:39:26.510
instead of finishing
the presentation.

00:39:26.510 --> 00:39:29.790
So again, that has nothing
to do with an actual design.

00:39:29.790 --> 00:39:31.880
This is just a cool
effect that you

00:39:31.880 --> 00:39:35.860
can implement all the
way back to API Level 1.

00:39:35.860 --> 00:39:38.390
So this is what it looks like.

00:39:38.390 --> 00:39:40.700
I wrote a full article online,
using a different demo.

00:39:40.700 --> 00:39:42.450
So if you want to know
how to do that kind

00:39:42.450 --> 00:39:46.000
of a cool visual effects,
you can go read it.

00:39:46.000 --> 00:39:49.590
And we're going to switch
to Q&amp;A. Blah, blah, Q&amp;A.

00:39:49.590 --> 00:39:51.210
CHET HAASE: Q&amp;A, and that's it.

00:39:58.482 --> 00:39:59.940
ROMAIN GUY: If you
have a question,

00:39:59.940 --> 00:40:00.940
please walk to the mics.

00:40:03.780 --> 00:40:04.440
No questions.

00:40:04.440 --> 00:40:05.030
CHET HAASE: No running.

00:40:05.030 --> 00:40:06.610
ROMAIN GUY: Man, we
are so good that they

00:40:06.610 --> 00:40:07.490
understand everything.

00:40:07.490 --> 00:40:08.406
CHET HAASE: All right.

00:40:08.406 --> 00:40:10.610
Yeah, it's all straight
forward, very easy, great.

00:40:10.610 --> 00:40:11.109
Yes.

00:40:11.109 --> 00:40:13.750
AUDIENCE: Memory-- how
does it deal with memory?

00:40:13.750 --> 00:40:17.060
I mean, dealing
with images, we're

00:40:17.060 --> 00:40:21.421
already running into memory
constraints all over the place.

00:40:21.421 --> 00:40:22.820
CHET HAASE: Which
element are you

00:40:22.820 --> 00:40:23.986
talking about in particular?

00:40:23.986 --> 00:40:27.480
AUDIENCE: All these animations
and so on-- I mean, shadows.

00:40:27.480 --> 00:40:32.110
CHET HAASE: Shadows, so the
stuff that we're showing

00:40:32.110 --> 00:40:34.540
doesn't really put any
memory constraints on.

00:40:34.540 --> 00:40:37.630
We are certainly creating a mesh
for the geometry for shadows.

00:40:37.630 --> 00:40:41.700
But this is trivial, in terms of
the amount taken up by Bitmaps.

00:40:41.700 --> 00:40:43.545
That's basically just
a bunch of vertices

00:40:43.545 --> 00:40:45.940
that we're going to send down
to the GPU and then Shader

00:40:45.940 --> 00:40:47.210
commands.

00:40:47.210 --> 00:40:49.567
The image effect that
we're showing-- obviously,

00:40:49.567 --> 00:40:51.025
if you're using
more images, you're

00:40:51.025 --> 00:40:52.611
using more memory
for those images.

00:40:52.611 --> 00:40:54.110
But the actual
animations that we're

00:40:54.110 --> 00:40:55.250
talking about, not so much.

00:40:55.250 --> 00:41:00.540
They're kind of data
structures, not really an issue.

00:41:00.540 --> 00:41:02.170
In the back--

00:41:02.170 --> 00:41:04.630
AUDIENCE: I have a
question regarding

00:41:04.630 --> 00:41:06.400
the selectors with
the object animators.

00:41:06.400 --> 00:41:07.220
CHET HAASE: Yes.

00:41:07.220 --> 00:41:10.370
AUDIENCE: So you specify
a Start and an End value.

00:41:10.370 --> 00:41:14.425
Is there a way you can say that
the the Start value of-- let's

00:41:14.425 --> 00:41:16.550
say, you have Press State
and then a Normal State--

00:41:16.550 --> 00:41:19.820
that the animation
to return to normal

00:41:19.820 --> 00:41:22.860
can use to the current value.

00:41:22.860 --> 00:41:23.550
CHET HAASE: Yes.

00:41:23.550 --> 00:41:25.716
In fact, that is the way
that it's supposed to work.

00:41:25.716 --> 00:41:28.140
There is a bug in the preview
release, where that is not

00:41:28.140 --> 00:41:29.632
the way it actually works.

00:41:29.632 --> 00:41:31.340
And so currently, in
the preview release,

00:41:31.340 --> 00:41:33.414
you have to give
it a start value.

00:41:33.414 --> 00:41:35.330
That bug should be fixed
in the final release.

00:41:35.330 --> 00:41:37.252
AUDIENCE: OK, thank you.

00:41:37.252 --> 00:41:39.560
AUDIENCE: Somewhat related
to that-- just as far

00:41:39.560 --> 00:41:42.970
as overlapping
reveal transitions,

00:41:42.970 --> 00:41:45.080
does one stop and
another take over?

00:41:45.080 --> 00:41:48.030
Or are they able to
run at the same time?

00:41:48.030 --> 00:41:51.503
ROMAIN GUY: So I do not
know the answer to that.

00:41:51.503 --> 00:41:52.627
AUDIENCE: Thank you.

00:41:52.627 --> 00:41:53.710
ROMAIN GUY: Chet, tell us.

00:41:53.710 --> 00:41:57.010
I'm thinking, if it's
on the same View,

00:41:57.010 --> 00:41:58.220
there might be a conflict.

00:41:58.220 --> 00:42:00.200
There's nothing to
stop you from running

00:42:00.200 --> 00:42:03.690
different Reveals
on different Views.

00:42:03.690 --> 00:42:08.630
But yeah, the same View, I'd
have to think about that.

00:42:08.630 --> 00:42:10.880
Let us know what happens.

00:42:10.880 --> 00:42:13.870
In the back, there's
nobody, so go.

00:42:13.870 --> 00:42:16.740
AUDIENCE: For the
colorizing, is there

00:42:16.740 --> 00:42:21.888
going to be a non-XML
programmatic solution for that?

00:42:21.888 --> 00:42:23.545
ROMAIN GUY: Yes,
Chet, what about it?

00:42:23.545 --> 00:42:24.920
CHET HAASE:
Programmatic access--

00:42:24.920 --> 00:42:25.878
CHET HAASE: I say, yes.

00:42:25.878 --> 00:42:28.570
CHET HAASE: To Theme
attributes-- the person

00:42:28.570 --> 00:42:31.110
that is working on
that is nodding.

00:42:31.110 --> 00:42:34.424
So either yes, or
he's falling asleep.

00:42:34.424 --> 00:42:36.372
AUDIENCE: Or having a seizure.

00:42:36.372 --> 00:42:38.680
CHET HAASE: Or it
was a slow nod.

00:42:38.680 --> 00:42:40.490
It was not a seizure nod.

00:42:40.490 --> 00:42:42.670
AUDIENCE: So you
mentioned, that when

00:42:42.670 --> 00:42:45.225
you run Palette on large
images, that it's slow.

00:42:45.225 --> 00:42:47.090
ROMAIN GUY: Well, it's
not that it's slow.

00:42:47.090 --> 00:42:47.820
AUDIENCE: It's slower.

00:42:47.820 --> 00:42:49.170
ROMAIN GUY: The larder
the image, the slower.

00:42:49.170 --> 00:42:49.960
AUDIENCE: Is there a sweet spot?

00:42:49.960 --> 00:42:51.520
It seems to me you
could shrink the image

00:42:51.520 --> 00:42:52.655
and still get the same colors.

00:42:52.655 --> 00:42:53.460
CHET HAASE: I was
thinking the same thing,

00:42:53.460 --> 00:42:54.376
as he was saying that.

00:42:54.376 --> 00:42:57.590
AUDIENCE: OK, if there's some
sweet spot, we can shrink it

00:42:57.590 --> 00:42:59.400
and-- it probably
depends on the image.

00:42:59.400 --> 00:43:02.270
ROMAIN GUY: The problem is that,
it really depends on the image.

00:43:02.270 --> 00:43:05.720
And by default, I looked at the
source code of the Palette API.

00:43:05.720 --> 00:43:09.195
And I don't remember it
doing any scaling whatsoever.

00:43:09.195 --> 00:43:11.070
But that's kind of a
good thing, because that

00:43:11.070 --> 00:43:13.380
means you can do it, if you
know the content of your images.

00:43:13.380 --> 00:43:14.270
I mean, if they
are low frequency,

00:43:14.270 --> 00:43:15.830
you can certainly
scale them down.

00:43:15.830 --> 00:43:17.597
But for your high
frequency images,

00:43:17.597 --> 00:43:19.430
you might lose some of
the important colors.

00:43:19.430 --> 00:43:21.845
AUDIENCE: Cool.

00:43:21.845 --> 00:43:26.280
AUDIENCE: So this questions is
about the activity transitions.

00:43:26.280 --> 00:43:28.830
So when we're transitioning
between activities

00:43:28.830 --> 00:43:31.740
and we're sharing a View--
the View in the destination

00:43:31.740 --> 00:43:36.100
activity, I guess-- what happens
if it's like a heavier View,

00:43:36.100 --> 00:43:38.440
like a MapView?

00:43:38.440 --> 00:43:40.230
If it's not able to
initialize in the time

00:43:40.230 --> 00:43:41.938
that the animation is
happening, is there

00:43:41.938 --> 00:43:42.970
a way to deal with that?

00:43:42.970 --> 00:43:45.011
CHET HAASE: There are
definitely some tricky bits

00:43:45.011 --> 00:43:46.430
to this interaction.

00:43:46.430 --> 00:43:51.020
So it's best to view activity
transitions as being these

00:43:51.020 --> 00:43:55.010
bookend animations, where you
cannot get a seamless animation

00:43:55.010 --> 00:43:59.500
from one to the other, because
we really don't know how long

00:43:59.500 --> 00:44:01.800
the launched activity is
going to take to inflate.

00:44:01.800 --> 00:44:03.680
If it's a really
expensive View Hierarchy,

00:44:03.680 --> 00:44:07.090
if it's getting resources from
the network, whatever-- if it

00:44:07.090 --> 00:44:10.370
takes three seconds to start
up, obviously, a seamless

00:44:10.370 --> 00:44:12.410
transition is not
going to occur, right.

00:44:12.410 --> 00:44:15.400
So you'll have to factor
that into whatever behavior

00:44:15.400 --> 00:44:17.310
you want for your animation.

00:44:17.310 --> 00:44:19.310
But having said that,
then you figure out

00:44:19.310 --> 00:44:21.145
what the choreography should be.

00:44:21.145 --> 00:44:23.020
In general, you probably
want to do something

00:44:23.020 --> 00:44:28.830
like animate the items out and
then animate your hero elements

00:44:28.830 --> 00:44:34.860
in the old activity to some
sort of standing pattern.

00:44:34.860 --> 00:44:36.620
Just animate it up
and have it sit there

00:44:36.620 --> 00:44:39.350
and wait until it can go
in the launched activity.

00:44:39.350 --> 00:44:43.490
ROMAIN GUY: We have time for
one last question in the back.

00:44:43.490 --> 00:44:45.790
AUDIENCE: I was wondering.

00:44:45.790 --> 00:44:48.510
Since we're going to have a
first-class support for path

00:44:48.510 --> 00:44:51.180
animation, is there going
to be any kind of support

00:44:51.180 --> 00:44:55.850
for decoding SVGs or
similar vector formats?

00:44:55.850 --> 00:44:57.530
CHET HAASE: Let's
be really clear.

00:44:57.530 --> 00:45:00.730
His path animation
demo was not part

00:45:00.730 --> 00:45:03.740
of what we were
trying to do today.

00:45:03.740 --> 00:45:09.570
So I'm not sure where
you got the message from.

00:45:09.570 --> 00:45:12.860
But that was basically a way
to animate paths using Android.

00:45:12.860 --> 00:45:16.530
That wasn't like first-class
support in L APIs or anything.

00:45:16.530 --> 00:45:18.030
So if you've go to
his blog, you can

00:45:18.030 --> 00:45:20.830
see how he's doing that on
current releases of Android.

00:45:20.830 --> 00:45:22.950
ROMAIN GUY: I used the
[INAUDIBLE] library

00:45:22.950 --> 00:45:24.330
to load the SVG files.

00:45:24.330 --> 00:45:26.020
CHET HAASE: Yeah,
so you can certainly

00:45:26.020 --> 00:45:28.070
consume SVG and do
stuff with it already.

00:45:28.070 --> 00:45:30.145
We have the very full
and robust path API.

00:45:30.145 --> 00:45:31.770
All of that stuff is
usable, and that's

00:45:31.770 --> 00:45:32.890
what he was using in his demo.

00:45:32.890 --> 00:45:33.610
ROMAIN GUY: And we're done.

00:45:33.610 --> 00:45:34.443
Thank you very much.

00:45:34.443 --> 00:45:36.570
CHET HAASE: All
right, thank you.

