WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.510
PROFESSOR: All right.

00:00:03.510 --> 00:00:07.780
So Lecture 7 was
about many things--

00:00:07.780 --> 00:00:11.970
universal foldings by box
pleating, maze folding,

00:00:11.970 --> 00:00:14.420
and then lots of
NP hardness stuff.

00:00:14.420 --> 00:00:17.460
So we're going to go through
things in that order.

00:00:17.460 --> 00:00:21.620
I thought I'd start by showing
some old history of box

00:00:21.620 --> 00:00:23.410
pleating, where it comes from.

00:00:23.410 --> 00:00:28.240
The first design is by this guy
Raymond McLain, 1967, design

00:00:28.240 --> 00:00:30.340
called the Mooser's train.

00:00:30.340 --> 00:00:32.810
And you can see all the creases
are horizontal, vertical,

00:00:32.810 --> 00:00:34.746
and diagonal, 45 degrees.

00:00:34.746 --> 00:00:36.370
This is the original
handwritten thing,

00:00:36.370 --> 00:00:39.920
and this is apparently before
the time of origami books,

00:00:39.920 --> 00:00:40.810
for the most part.

00:00:40.810 --> 00:00:42.960
So people would
just photocopy this,

00:00:42.960 --> 00:00:45.110
and hand it around, just
kind distribute it out

00:00:45.110 --> 00:00:47.490
through the origami community.

00:00:47.490 --> 00:00:51.170
And kind of spawned a
revolution origami design,

00:00:51.170 --> 00:00:54.230
because it was the
first model to make

00:00:54.230 --> 00:00:58.070
sort of a very complicated
multi-object piece out

00:00:58.070 --> 00:00:59.680
of one piece of paper.

00:00:59.680 --> 00:01:01.460
Happened to be a
rectangle of paper,

00:01:01.460 --> 00:01:03.200
but a pretty cool design .

00:01:03.200 --> 00:01:06.080
And it really got
people thinking about.

00:01:06.080 --> 00:01:08.410
And the basic, original
principal in box pleating

00:01:08.410 --> 00:01:11.400
was to make boxes, and then find
ways to attach them together.

00:01:11.400 --> 00:01:13.580
And it's fairly
powerful and believed

00:01:13.580 --> 00:01:16.086
to be universal by
origamists for a long time.

00:01:16.086 --> 00:01:17.710
And we proved it with
that cube gadget.

00:01:17.710 --> 00:01:19.751
Now, the designs that come
out of the cube gadget

00:01:19.751 --> 00:01:21.824
are not especially efficient.

00:01:21.824 --> 00:01:23.740
I've got some ways to
optimize it, as you saw,

00:01:23.740 --> 00:01:27.525
but at least it proves
everything is possible

00:01:27.525 --> 00:01:28.900
that you could
make out of cubes,

00:01:28.900 --> 00:01:32.510
you can make out
of box pleating.

00:01:32.510 --> 00:01:34.350
Another kind of
influential design

00:01:34.350 --> 00:01:36.680
is this black
force cuckoo clock.

00:01:36.680 --> 00:01:39.360
For a long time, one of the most
complicated origamis out there.

00:01:39.360 --> 00:01:41.860
It was designed by
Robert Lang in the '80s,

00:01:41.860 --> 00:01:44.300
and there's a few of
them in existence.

00:01:44.300 --> 00:01:48.140
It has lot of detail-- it
has a clock, that's correct

00:01:48.140 --> 00:01:53.460
twice a day, and it's he
modeled it after a real cuckoo

00:01:53.460 --> 00:01:55.140
clock he saw in
the Black Forest.

00:01:55.140 --> 00:01:56.840
It's got a zillion
creases, especially

00:01:56.840 --> 00:01:58.600
in this long rectangle of paper.

00:01:58.600 --> 00:02:02.020
And there's diagrams for it
in Origami Design Secrets,

00:02:02.020 --> 00:02:03.900
if you want to make your own.

00:02:03.900 --> 00:02:06.517
And it's also based on
this box pleating idea,

00:02:06.517 --> 00:02:11.350
and sort of in the early days
of the tree theory, and so on.

00:02:11.350 --> 00:02:13.890
So really, before that kicked
off, box pleating was around.

00:02:13.890 --> 00:02:15.430
And people still do
basic box pleating,

00:02:15.430 --> 00:02:16.950
although now there's
the fusion of the tree

00:02:16.950 --> 00:02:17.670
method with box pleating.

00:02:17.670 --> 00:02:20.020
There's a lot of designs
based on that, because they're

00:02:20.020 --> 00:02:23.110
easy to fold from
angular perspective,

00:02:23.110 --> 00:02:25.310
easy to find where the
creases are, anyway,

00:02:25.310 --> 00:02:28.070
that's box pleating.

00:02:28.070 --> 00:02:32.010
So next, we go on to-- I
think it's an open problem.

00:02:32.010 --> 00:02:33.834
Yeah, this is a
cool open problem.

00:02:33.834 --> 00:02:35.500
For some reason, never
thought about it.

00:02:35.500 --> 00:02:39.201
I'm sure briefly thought about
it, but never worked on it.

00:02:39.201 --> 00:02:41.200
In the same way we get
universal hinge patterns,

00:02:41.200 --> 00:02:44.720
box pleating can make any poly
cube, what if you want to make,

00:02:44.720 --> 00:02:48.450
out of the simple cube gadget,
can we design an analogous cube

00:02:48.450 --> 00:02:50.840
gadget for
tetrahedra, octahedra,

00:02:50.840 --> 00:02:55.080
might be nice, regular octahedra
tile space, out of something

00:02:55.080 --> 00:02:59.240
like a triangular grid,
maybe with 30 degree lines.

00:02:59.240 --> 00:03:01.174
That's a natural
question-- open.

00:03:01.174 --> 00:03:03.590
Maybe we'll work on it sometime,
but I think it'd be neat.

00:03:03.590 --> 00:03:05.810
You just need a nice
gadget, and then we

00:03:05.810 --> 00:03:08.770
know how to compose them by
induction just like in lecture

00:03:08.770 --> 00:03:09.300
seven.

00:03:09.300 --> 00:03:14.890
So it could be a
fun thing to attack.

00:03:14.890 --> 00:03:20.320
Next, we go to maze folding.

00:03:20.320 --> 00:03:23.580
So I thought I'd
show-- we've seen

00:03:23.580 --> 00:03:26.900
this maze fold-- the 6.849.

00:03:26.900 --> 00:03:29.440
So this is folded
by Jenny and Eli

00:03:29.440 --> 00:03:33.600
based on the algorithm that
you saw, and you might play

00:03:33.600 --> 00:03:36.290
with it on your
problem set three.

00:03:36.290 --> 00:03:37.590
Design your own maze.

00:03:37.590 --> 00:03:39.390
You can click any
pattern you want.

00:03:39.390 --> 00:03:44.000
Make whatever letters you want,
or any other cool orthogonal

00:03:44.000 --> 00:03:46.970
pattern.

00:03:46.970 --> 00:03:50.120
Marty and I have made a
bunch of different print

00:03:50.120 --> 00:03:53.660
designs based around this idea
of taking not just the crease

00:03:53.660 --> 00:03:55.580
pattern you get for
folding-- here we're

00:03:55.580 --> 00:03:59.280
folding the word yes
in three dimensions--

00:03:59.280 --> 00:04:03.730
but we've shaded the original
piece of paper in this pattern.

00:04:03.730 --> 00:04:06.440
So that it looks like nothing
on here, but when you fold it,

00:04:06.440 --> 00:04:08.240
the shading comes
together to spell no.

00:04:08.240 --> 00:04:11.300
So it's kind of ambiguity, or
the shadow of the yes is no,

00:04:11.300 --> 00:04:12.700
and so on.

00:04:12.700 --> 00:04:17.390
And Jenny and Eli folded
that as well, and here it is.

00:04:17.390 --> 00:04:18.464
The first folding.

00:04:21.410 --> 00:04:23.730
But our idea is not
necessarily to fold them.

00:04:23.730 --> 00:04:25.690
I mean, it's cool that
they can be folded.

00:04:25.690 --> 00:04:28.120
That's neat
conceptually, but we also

00:04:28.120 --> 00:04:31.240
like to design ones that
really should not be folded.

00:04:31.240 --> 00:04:34.360
Next one here is
science and art,

00:04:34.360 --> 00:04:36.350
so you fold the science
in three dimensions

00:04:36.350 --> 00:04:40.030
and the art is in the
background lurking there.

00:04:40.030 --> 00:04:42.955
I imagine this will
never be folded.

00:04:42.955 --> 00:04:45.390
It'd be rather painful.

00:04:45.390 --> 00:04:46.890
Here's another very
complicated one.

00:04:46.890 --> 00:04:50.950
Here we're playing around with
putting little shaded regions

00:04:50.950 --> 00:04:51.737
in these squares.

00:04:51.737 --> 00:04:53.320
These are just the
squares that end up

00:04:53.320 --> 00:04:55.850
mapping to the flat
parts over here.

00:04:55.850 --> 00:04:57.560
And so you get--
we took an image

00:04:57.560 --> 00:05:00.740
and spliced it up into
thousands of pieces.

00:05:00.740 --> 00:05:02.960
So you get-- this is a
photograph of Martin Gardner,

00:05:02.960 --> 00:05:07.870
who died a couple
years ago sadly.

00:05:07.870 --> 00:05:10.210
We never met him,
but he was the father

00:05:10.210 --> 00:05:12.420
of recreational mathematics
among other things.

00:05:12.420 --> 00:05:15.750
Also magician--
lots of cool things.

00:05:15.750 --> 00:05:18.550
So this is in tribute to him.

00:05:18.550 --> 00:05:20.426
And this is our latest
design in this spirit.

00:05:20.426 --> 00:05:22.133
We're trying to be a
little more artistic

00:05:22.133 --> 00:05:24.420
and just be about the crease
pattern, not necessarily

00:05:24.420 --> 00:05:25.350
the folding.

00:05:25.350 --> 00:05:29.360
So the 3-D thing that this
folds into is not shown here,

00:05:29.360 --> 00:05:32.420
and in theory all these
lines go off to infinity.

00:05:32.420 --> 00:05:34.955
But this spells the word glass.

00:05:34.955 --> 00:05:37.870
We made it when we were at
the Pilchuck Glass School

00:05:37.870 --> 00:05:40.190
this summer.

00:05:40.190 --> 00:05:43.819
And it's now on t-shirts of many
glass blowers around the world.

00:05:43.819 --> 00:05:45.860
How many of them know
exactly what it folds into,

00:05:45.860 --> 00:05:47.066
I don't know.

00:05:47.066 --> 00:05:48.550
But that's pretty cool.

00:05:48.550 --> 00:05:50.210
So we were working
on glass folding,

00:05:50.210 --> 00:05:52.940
so that seemed like a
natural thing to do.

00:05:52.940 --> 00:05:57.720
So that is maze folding
and see some designs.

00:05:57.720 --> 00:06:00.990
How you can use it
for cool things.

00:06:00.990 --> 00:06:04.440
The next topic is
NP-hardness, and that

00:06:04.440 --> 00:06:08.130
will be what we spend
most of today on.

00:06:08.130 --> 00:06:10.080
And so, first kind
of general question

00:06:10.080 --> 00:06:13.620
is what does it all mean?

00:06:13.620 --> 00:06:16.280
What does NP-hardness
really tell you?

00:06:16.280 --> 00:06:19.610
Can you give me like a
specific instance that's hard,

00:06:19.610 --> 00:06:22.820
and-- this is more for people
who haven't seen MP-hardness

00:06:22.820 --> 00:06:25.190
before-- the answer is no.

00:06:25.190 --> 00:06:28.560
NP-hardness is kind of a
conceptual, philosophical

00:06:28.560 --> 00:06:29.060
thing.

00:06:29.060 --> 00:06:31.640
No specific problem
is ever NP-hard.

00:06:31.640 --> 00:06:34.860
It's all about whole families
of problems being hard.

00:06:34.860 --> 00:06:38.020
And really it's about
measuring the growth of problem

00:06:38.020 --> 00:06:40.470
complexity with problem size.

00:06:40.470 --> 00:06:43.000
So in this case, it's
how much running time

00:06:43.000 --> 00:06:45.990
do you need to
solve your problem

00:06:45.990 --> 00:06:47.780
as a function of
the problem size.

00:06:47.780 --> 00:06:50.500
And we're interested in whether
that grows only polynomially

00:06:50.500 --> 00:06:53.490
or it grows exponentially,
and NP-hardness probably

00:06:53.490 --> 00:06:56.230
implies exponential growth.

00:06:56.230 --> 00:06:58.190
A nice example of this is chess.

00:06:58.190 --> 00:06:59.990
So eight-by-eight
chess-- people have

00:06:59.990 --> 00:07:04.200
spent many years trying to
solve it and do it perfectly,

00:07:04.200 --> 00:07:05.480
and to be the best player.

00:07:05.480 --> 00:07:07.740
But from a theoretical,
computer science perspective,

00:07:07.740 --> 00:07:10.350
chess in its original
form, is trivial

00:07:10.350 --> 00:07:13.370
because it just has a
constant number of states.

00:07:13.370 --> 00:07:16.120
You could just enumerate
them all in constant time.

00:07:16.120 --> 00:07:20.070
You know who wins in
chess-- probably white.

00:07:20.070 --> 00:07:24.030
But it's not very satisfying,
but the more interesting thing

00:07:24.030 --> 00:07:26.930
to say is to study
chess as it grows,

00:07:26.930 --> 00:07:29.477
and the natural way to make it
grow is with an n-by-n board.

00:07:29.477 --> 00:07:31.060
So with an n-by-n
board, if I give you

00:07:31.060 --> 00:07:32.559
an arrangement of
chess pieces and I

00:07:32.559 --> 00:07:34.720
want to know who wins,
that you can prove

00:07:34.720 --> 00:07:39.046
is something even stronger than
NP-hardness called X-hardness.

00:07:39.046 --> 00:07:41.420
So there you can actually
prove you need exponential time

00:07:41.420 --> 00:07:42.990
to solve n-by-n chess.

00:07:42.990 --> 00:07:45.911
And that gives you a sense
the chess really is hard.

00:07:45.911 --> 00:07:48.410
There's not going to be a good
algorithm that magically will

00:07:48.410 --> 00:07:51.740
solve it for eight-by-eight,
because in general as board

00:07:51.740 --> 00:07:53.990
size increases, you know it
has to grow exponentially,

00:07:53.990 --> 00:07:56.800
and probably eight-by-eight
is big enough.

00:07:56.800 --> 00:07:59.164
That there's no good
algorithm to do it.

00:07:59.164 --> 00:08:01.080
You can't prove that
there's no good algorithm

00:08:01.080 --> 00:08:02.455
to do eight-by-eight,
but you can

00:08:02.455 --> 00:08:04.420
prove there's no good
algorithms to do n-by-n.

00:08:04.420 --> 00:08:07.520
So that's the limitation of
theoretical computer science

00:08:07.520 --> 00:08:08.530
and of NP-hardness.

00:08:08.530 --> 00:08:10.340
So you take any
particular crease pattern.

00:08:10.340 --> 00:08:12.130
You want to know
whether it folds flat.

00:08:12.130 --> 00:08:14.540
You might be able to do
that by exhaustive search

00:08:14.540 --> 00:08:16.589
and exponential
time might be OK,

00:08:16.589 --> 00:08:18.630
but you know that as the
crease patterns get big,

00:08:18.630 --> 00:08:21.880
you're totally screwed.

00:08:21.880 --> 00:08:27.599
So, next question about
hardness is can we

00:08:27.599 --> 00:08:29.140
do it with a little
less hand waving?

00:08:29.140 --> 00:08:30.848
So in a little bit
more detail, because I

00:08:30.848 --> 00:08:31.961
covered a lot of proofs.

00:08:31.961 --> 00:08:33.460
So I'm going to
look at two of them.

00:08:33.460 --> 00:08:37.510
The simple full hardness--
which is from partition--

00:08:37.510 --> 00:08:41.324
and the crease pattern
flat foldability which

00:08:41.324 --> 00:08:46.200
is from not all equal
SAT-- 3SAT-- and I'll

00:08:46.200 --> 00:08:49.270
give some more details.

00:08:49.270 --> 00:08:52.805
So let's start by going
through this proof.

00:08:52.805 --> 00:08:54.930
Remember, in general with
an NP-hardness reduction,

00:08:54.930 --> 00:08:56.870
we want to take some
known hard problem

00:08:56.870 --> 00:08:59.500
and convert it into our
problem, because that proves

00:08:59.500 --> 00:09:02.880
that our problem is at least
as hard as the original one.

00:09:02.880 --> 00:09:06.860
So in this case, the known
hard problem is I give you n

00:09:06.860 --> 00:09:10.110
integers-- a1, a2, up to an.

00:09:10.110 --> 00:09:12.790
And I want to know, can I
split them into two groups

00:09:12.790 --> 00:09:16.250
so that the two
groups have equal sum?

00:09:16.250 --> 00:09:20.369
And here we're mapping that into
the simple fold problem, which

00:09:20.369 --> 00:09:22.160
was given a crease
pattern can you fold it.

00:09:22.160 --> 00:09:25.710
Can you follow all the
creases flat by simple folds?

00:09:25.710 --> 00:09:28.290
We're mapping it
into these lengths--

00:09:28.290 --> 00:09:31.940
these lengths are the AIs
between the different legs

00:09:31.940 --> 00:09:33.120
of the staircase.

00:09:33.120 --> 00:09:35.260
And then there's
this extra stuff.

00:09:35.260 --> 00:09:37.810
This is a super long
length-- length l--

00:09:37.810 --> 00:09:41.790
and this is a doubly
super long length-- 2l.

00:09:41.790 --> 00:09:44.800
And then there's this
frame, which has height 2l,

00:09:44.800 --> 00:09:48.630
and this part is aligned
right at the midway.

00:09:48.630 --> 00:09:53.960
And so the idea was if there's
a partition-- if there's

00:09:53.960 --> 00:09:57.740
a partition of the AIs
into two groups-- call them

00:09:57.740 --> 00:10:01.740
Group A and Group
B-- then I'm going

00:10:01.740 --> 00:10:05.010
to fold some of the creases.

00:10:05.010 --> 00:10:11.990
The ones between any two
guys of different groups.

00:10:11.990 --> 00:10:15.430
Because folding here corresponds
to switching directions.

00:10:15.430 --> 00:10:18.520
So whenever I fold, I'm kind of
switching which group I'm in,

00:10:18.520 --> 00:10:21.450
and then Group A will
be all the up directions

00:10:21.450 --> 00:10:23.430
and Group B will be all
the down directions.

00:10:23.430 --> 00:10:25.440
So maybe both of these
guys are in Group B

00:10:25.440 --> 00:10:28.530
so they both go down, and this
is a Group A guy, so we go up,

00:10:28.530 --> 00:10:29.800
and then down, and then up.

00:10:29.800 --> 00:10:32.460
And if we get them-- A and
B to be balanced-- then

00:10:32.460 --> 00:10:34.810
we'll end up right
where we started.

00:10:34.810 --> 00:10:39.630
So we'll end up right at
the middle point here.

00:10:39.630 --> 00:10:42.610
And, in that case, there's
these two more folds--

00:10:42.610 --> 00:10:45.720
this vertical fold and
that vertical fold.

00:10:45.720 --> 00:10:49.090
And then if you-- sorry.

00:10:49.090 --> 00:10:50.740
Yeah, I don't have
it drawn here.

00:10:50.740 --> 00:10:54.730
When you do one more fold here,
this will fall into the frame,

00:10:54.730 --> 00:10:59.640
and if you got this to stay--
if you got this point basically

00:10:59.640 --> 00:11:02.150
to be aligned with
here, then going up L,

00:11:02.150 --> 00:11:05.420
and then back down to L will
not collide with this box.

00:11:05.420 --> 00:11:09.730
It just barely fits,
and so you fold that in.

00:11:09.730 --> 00:11:14.060
Then you fold this vertical
line and you fold it back out.

00:11:14.060 --> 00:11:16.630
So the goal was just to
get these two folds made.

00:11:16.630 --> 00:11:18.620
Once they're made and
it's back out here,

00:11:18.620 --> 00:11:22.421
you can finish all folds
that you didn't fold before.

00:11:22.421 --> 00:11:24.920
And what we're checking here
is that during all this motion,

00:11:24.920 --> 00:11:27.630
you don't get collision
because simple folds are not

00:11:27.630 --> 00:11:30.220
allowed to collide
during the motion.

00:11:30.220 --> 00:11:33.940
So if this, for example, went
too far down or too far up

00:11:33.940 --> 00:11:36.080
and it collided with
the frame, then you

00:11:36.080 --> 00:11:38.330
wouldn't be able to make the
second vertical fold here

00:11:38.330 --> 00:11:40.288
because you'd have to
bring the frame with you,

00:11:40.288 --> 00:11:42.870
and the frame's not
supposed to move.

00:11:42.870 --> 00:11:45.900
So in particular,
there's this question.

00:11:45.900 --> 00:11:47.650
Seems like we're not
making all the folds,

00:11:47.650 --> 00:11:49.620
and that's because I
didn't say the last part.

00:11:49.620 --> 00:11:51.660
After you fold it in
here and avoid collision,

00:11:51.660 --> 00:11:54.784
you fold it back out with the
second of these two folds.

00:11:54.784 --> 00:11:56.200
Then you can finish
all the folds.

00:11:56.200 --> 00:11:58.740
Indeed the goal is
to fold everything,

00:11:58.740 --> 00:12:01.570
but in order to avoid
collision, when I fold this,

00:12:01.570 --> 00:12:04.710
this thing has to be nice and
compact and fit within this 2L

00:12:04.710 --> 00:12:06.040
boundary.

00:12:06.040 --> 00:12:09.580
Then it goes through.

00:12:09.580 --> 00:12:11.690
So what we really
need to show though

00:12:11.690 --> 00:12:16.400
at the top level is
given any set of AIs,

00:12:16.400 --> 00:12:19.659
we can convert it into an
equivalent simple fold problem.

00:12:19.659 --> 00:12:22.200
There's actually two things we
need to check for equivalence.

00:12:22.200 --> 00:12:24.530
We need to check that
if there's a partition,

00:12:24.530 --> 00:12:25.780
then there's a way to fold it.

00:12:25.780 --> 00:12:27.446
We also need to check
the reverse, which

00:12:27.446 --> 00:12:30.700
is if there's a way to fold
it, then there's a partition.

00:12:30.700 --> 00:12:33.750
But both of these kind of
follow from this argument.

00:12:33.750 --> 00:12:36.820
In order to-- when
we make this fold,

00:12:36.820 --> 00:12:39.220
this guy's got to-- or
whichever of these two is first.

00:12:39.220 --> 00:12:41.720
They're kind of equivalent.

00:12:41.720 --> 00:12:44.545
If we collide, we won't be
able to finish the folding.

00:12:44.545 --> 00:12:46.697
That's the claim.

00:12:46.697 --> 00:12:48.530
You might have done all
the folds over here,

00:12:48.530 --> 00:12:51.040
but they'll be the
second of these two,

00:12:51.040 --> 00:12:53.249
and so when you do the first,
you'll either get stuck

00:12:53.249 --> 00:12:54.456
or you'll be able to proceed.

00:12:54.456 --> 00:12:56.370
If you were able to
proceed, you can read off

00:12:56.370 --> 00:12:58.760
from the ups and downs here
what the partition was.

00:12:58.760 --> 00:13:03.786
So you can convert in either
direction using this reduction.

00:13:03.786 --> 00:13:07.660
Any more questions about
the simple folds one?

00:13:07.660 --> 00:13:10.950
So, of course, one of the easier
proofs, the crease pattern

00:13:10.950 --> 00:13:14.340
flatfold ability is definitely
on the more complicated side,

00:13:14.340 --> 00:13:16.850
and this was the
overview of the proof.

00:13:16.850 --> 00:13:20.700
Basically there were lots
of little local gadgets.

00:13:20.700 --> 00:13:24.000
There's the wire,
which communicates

00:13:24.000 --> 00:13:27.490
truthiness or falsity
as we like to say.

00:13:27.490 --> 00:13:32.000
Or things like-- the
main gadget is the one

00:13:32.000 --> 00:13:33.710
at the top and not
all equal clause,

00:13:33.710 --> 00:13:37.950
which forces among the
three wires coming in.

00:13:37.950 --> 00:13:40.092
They can't all have
the same value.

00:13:40.092 --> 00:13:41.720
So there could be
two true, one false.

00:13:41.720 --> 00:13:44.560
Or two false, one true.

00:13:44.560 --> 00:13:47.172
But not all true
and not all false.

00:13:47.172 --> 00:13:48.880
And then we needed
some auxiliary gadgets

00:13:48.880 --> 00:13:52.110
for turning, duplicating,
and crossing over.

00:13:52.110 --> 00:13:55.290
Those were fairly
straightforward.

00:13:55.290 --> 00:13:58.870
The heart is a wire, and
a not all equal clause.

00:13:58.870 --> 00:14:02.590
And so the idea was we were
given a formula-- in this case,

00:14:02.590 --> 00:14:05.440
it's a bunch of triples,
and each of the triples

00:14:05.440 --> 00:14:07.200
should be not all equal.

00:14:07.200 --> 00:14:09.350
And there's like n
variables-- there's

00:14:09.350 --> 00:14:11.410
a lot of different clauses
on those variables.

00:14:11.410 --> 00:14:14.100
A lot of not all equal
constraints on those clauses.

00:14:14.100 --> 00:14:16.170
We want to represent that
by the flatfold ability

00:14:16.170 --> 00:14:17.086
of the crease pattern.

00:14:21.910 --> 00:14:24.270
So we basically make
all the variables

00:14:24.270 --> 00:14:26.170
off the left edge
of the paper here.

00:14:26.170 --> 00:14:28.990
We make lots of copies
of them by zigzagging,

00:14:28.990 --> 00:14:33.640
and then we make lots of clauses
at the top-- only drawn two

00:14:33.640 --> 00:14:37.496
up there-- and then in our input
we're given a bunch of triples

00:14:37.496 --> 00:14:39.620
of variables that should
belong to a common clause,

00:14:39.620 --> 00:14:43.260
and we just route these
signals to go to that clause.

00:14:43.260 --> 00:14:46.540
And then the clauses constrain
the values of those variables

00:14:46.540 --> 00:14:50.490
to be not all equal in
the appropriate triples.

00:14:50.490 --> 00:14:53.620
And the splitters
down here enforce

00:14:53.620 --> 00:14:57.130
all the different copies of
that variable to be the same.

00:14:57.130 --> 00:15:00.100
And so any flat
folding will require

00:15:00.100 --> 00:15:03.690
these guys are consistently
assigned one truth

00:15:03.690 --> 00:15:05.800
value throughout
the construction,

00:15:05.800 --> 00:15:08.190
and those clauses will
force not all equal things

00:15:08.190 --> 00:15:09.559
to be seen in pairs.

00:15:09.559 --> 00:15:11.100
So if there's a flat
folding of this,

00:15:11.100 --> 00:15:13.250
you can read off on the
mountain valley assignment

00:15:13.250 --> 00:15:16.190
here which one based
on whether it's

00:15:16.190 --> 00:15:19.687
left valley, right mountain,
or left mountain, right valley.

00:15:19.687 --> 00:15:21.520
You can read of what
the truth assignment is

00:15:21.520 --> 00:15:23.280
that satisfies all the clauses.

00:15:23.280 --> 00:15:26.320
That was one direction
from flat foldability

00:15:26.320 --> 00:15:34.219
to satisfiability of the
not all equal triples

00:15:34.219 --> 00:15:35.260
in the reverse direction.

00:15:35.260 --> 00:15:38.840
If there's a not all equal
assignment of triples,

00:15:38.840 --> 00:15:43.040
you need to verify that this
thing actually does fold flat.

00:15:43.040 --> 00:15:45.170
I didn't detail
that, but basically

00:15:45.170 --> 00:15:47.460
to do that, you have to prove
that each of the gadgets

00:15:47.460 --> 00:15:49.140
works exactly as desired.

00:15:49.140 --> 00:15:52.710
So you could really fold it
flat if these have equal value,

00:15:52.710 --> 00:15:54.880
for example, and this
has a negated value.

00:15:54.880 --> 00:15:57.190
You could actually always
fold the not all equal cause

00:15:57.190 --> 00:15:58.910
when it's satisfied.

00:15:58.910 --> 00:16:01.720
And then once you know that
each of these gadgets--

00:16:01.720 --> 00:16:04.010
because the gadgets are
very small-- once you know

00:16:04.010 --> 00:16:05.850
that each of them
folds correctly,

00:16:05.850 --> 00:16:07.750
and they have a sort
of comparable interface

00:16:07.750 --> 00:16:10.210
because these things are
just extending through,

00:16:10.210 --> 00:16:12.600
you could basically paste
glue together all of those

00:16:12.600 --> 00:16:14.020
folded states.

00:16:14.020 --> 00:16:16.024
So as long as you
verify the gadgets work,

00:16:16.024 --> 00:16:17.440
the whole thing
will work provided

00:16:17.440 --> 00:16:19.810
there is a satisfying
assignment.

00:16:19.810 --> 00:16:21.394
So that's-- yeah, question?

00:16:21.394 --> 00:16:23.560
AUDIENCE: Can you actually
go in the other direction

00:16:23.560 --> 00:16:25.030
properly in the same cell?

00:16:25.030 --> 00:16:28.810
Can you map any flat
foldability [INAUDIBLE]?

00:16:28.810 --> 00:16:30.810
PROFESSOR: OK, can you
map any flat foldability

00:16:30.810 --> 00:16:32.960
of a crease pattern
problem to SAT?

00:16:32.960 --> 00:16:34.460
That doesn't follow
from this proof,

00:16:34.460 --> 00:16:37.580
but I think it should be true.

00:16:37.580 --> 00:16:50.934
Uh, let's see-- I think so.

00:16:50.934 --> 00:16:52.350
So if I give you
a crease pattern,

00:16:52.350 --> 00:16:54.230
I want to know
whether it folds flat.

00:16:54.230 --> 00:16:56.760
As mentioned in lecture,
you can determine

00:16:56.760 --> 00:16:59.770
where all the facets lie in 2D.

00:16:59.770 --> 00:17:02.120
And challenges the
stacking order,

00:17:02.120 --> 00:17:04.135
which implies the mountain
valley assignment.

00:17:04.135 --> 00:17:06.010
So I think you could
make a variable in a SAT

00:17:06.010 --> 00:17:10.369
problem for this piece--
this little polygon lives

00:17:10.369 --> 00:17:12.354
in the stacking level.

00:17:12.354 --> 00:17:14.979
You have to figure out how many
levels you need, but at most 10

00:17:14.979 --> 00:17:16.339
of them, I guess.

00:17:16.339 --> 00:17:18.430
And then write down
the constraints

00:17:18.430 --> 00:17:23.276
between different polygons
if there are no crossings.

00:17:23.276 --> 00:17:24.650
There's a paper
by Jacques Justin

00:17:24.650 --> 00:17:25.733
that does that explicitly.

00:17:28.650 --> 00:17:31.430
So that should give you a way to
reduce to SAT, which gives you

00:17:31.430 --> 00:17:34.814
an algorithm-- an exponential
time algorithm to solve it.

00:17:34.814 --> 00:17:36.480
In general, I'm pretty
sure this problem

00:17:36.480 --> 00:17:40.150
is in NP, which implies there's
at least an algorithm for it.

00:17:40.150 --> 00:17:44.390
But I think in particular,
you can reduce it to SAT.

00:17:44.390 --> 00:17:46.350
So that's a good question.

00:17:46.350 --> 00:17:48.250
So pretty much
every problem we'll

00:17:48.250 --> 00:17:51.950
talk about at least with
origami has a finite algorithm

00:17:51.950 --> 00:17:54.869
to solve it, but it's a very
slow algorithm in general.

00:17:54.869 --> 00:17:57.160
Of course, there's a lot of
good SAT solvers out there,

00:17:57.160 --> 00:18:00.770
and I don't know if people
have actually tried to do that.

00:18:00.770 --> 00:18:06.090
I know there are some-- there's
a software called ORIPA, which

00:18:06.090 --> 00:18:09.160
in Japan some
versions try to find

00:18:09.160 --> 00:18:12.320
a valid folding-- a
valid folded state

00:18:12.320 --> 00:18:14.190
by some kind of careful,
exhaustive search.

00:18:14.190 --> 00:18:15.940
I don't think they use
SAT solvers though.

00:18:15.940 --> 00:18:19.080
You might get more mileage
out of SAT solvers.

00:18:19.080 --> 00:18:20.780
Other questions
about this proof?

00:18:23.560 --> 00:18:26.580
There's one explicit question
about the reflector gadget.

00:18:26.580 --> 00:18:29.310
This probably worth talking
about because these arrows

00:18:29.310 --> 00:18:32.830
are maybe not so
obvious what they mean.

00:18:32.830 --> 00:18:36.890
So the question is what
is true and what is false.

00:18:36.890 --> 00:18:40.450
It's kind of philosophy,
but in this case

00:18:40.450 --> 00:18:44.057
these arrows are explicitly
drawn on this diagram.

00:18:44.057 --> 00:18:46.640
If you look closely, there's an
arrow this way, then this way,

00:18:46.640 --> 00:18:47.610
then this way.

00:18:47.610 --> 00:18:51.110
And that's defining what we mean
by the orientation of a wire,

00:18:51.110 --> 00:18:54.350
and then if it's a valley
on the left relative

00:18:54.350 --> 00:18:55.910
to the arrow, that's true.

00:18:55.910 --> 00:18:58.910
If it's mountain on the
left relative to the arrow,

00:18:58.910 --> 00:18:59.760
that's false.

00:18:59.760 --> 00:19:02.000
And that's why this
is drawn this way

00:19:02.000 --> 00:19:03.706
assuming I got it right.

00:19:03.706 --> 00:19:05.830
Here it's valley on the
left relative to the arrow.

00:19:05.830 --> 00:19:09.070
Here it's mountain on the
left relative to the arrow.

00:19:09.070 --> 00:19:11.422
So notice these are pointing
in different directions.

00:19:11.422 --> 00:19:12.880
So that can get a
little confusing,

00:19:12.880 --> 00:19:16.310
but it's kind of what
we want in that proof

00:19:16.310 --> 00:19:19.400
because we really want to route
that thing in this direction.

00:19:19.400 --> 00:19:21.330
We don't care about
what things look

00:19:21.330 --> 00:19:24.050
like relative to
the center here.

00:19:24.050 --> 00:19:27.230
Because the center-- the
gadget we are looking at

00:19:27.230 --> 00:19:28.630
keeps changing.

00:19:28.630 --> 00:19:30.410
So we want to route
this as a single wire.

00:19:32.821 --> 00:19:34.320
And this one I
already talked about.

00:19:34.320 --> 00:19:35.980
You need to prove
both directions--

00:19:35.980 --> 00:19:38.964
that flat foldability implies
not all equal satisfiability,

00:19:38.964 --> 00:19:39.630
and the reverse.

00:19:43.674 --> 00:19:48.110
OK, we move on.

00:19:55.090 --> 00:19:58.030
So now we get to
some new material.

00:19:58.030 --> 00:20:00.920
So I mentioned in the
lecture that there

00:20:00.920 --> 00:20:02.352
are two hardness proofs.

00:20:02.352 --> 00:20:04.810
The one we've been talking
about is given a crease pattern,

00:20:04.810 --> 00:20:06.120
does it fold flat?

00:20:06.120 --> 00:20:07.760
That's strongly NP-hard.

00:20:07.760 --> 00:20:12.092
And the other is if I
give you something--

00:20:12.092 --> 00:20:13.800
I might even tell you
it's flat foldable.

00:20:13.800 --> 00:20:15.610
That's kind of not too relevant.

00:20:15.610 --> 00:20:17.830
But I give you
mountains and valleys,

00:20:17.830 --> 00:20:20.930
and I want to know--
I want to find

00:20:20.930 --> 00:20:23.370
a valid folded
state of that, or I

00:20:23.370 --> 00:20:25.120
want to decide whether
the mountain valley

00:20:25.120 --> 00:20:26.900
pattern is valid.

00:20:26.900 --> 00:20:30.420
These are strongly NP-hard hard,
and this is a different proof.

00:20:30.420 --> 00:20:33.010
It uses completely
different gadgets.

00:20:33.010 --> 00:20:37.040
So I thought I'd show you
some of those gadgets.

00:20:37.040 --> 00:20:38.690
Sort of the key ones.

00:20:38.690 --> 00:20:41.990
So the first part
is the wire, and I

00:20:41.990 --> 00:20:43.880
think I made one of these.

00:20:43.880 --> 00:20:46.650
Maybe I didn't.

00:20:46.650 --> 00:20:48.910
No wire.

00:20:48.910 --> 00:20:50.950
Well, this is the end
of a wire-- er, no,

00:20:50.950 --> 00:20:52.402
that's not the end of a wire.

00:20:55.570 --> 00:20:57.050
Here's an end of a wire.

00:20:57.050 --> 00:21:01.510
So the idea here is we've
got a fixed mountain valley

00:21:01.510 --> 00:21:04.480
pattern now because that's
no longer free for the folder

00:21:04.480 --> 00:21:06.016
to choose.

00:21:06.016 --> 00:21:07.390
And you've got
two tabs, and they

00:21:07.390 --> 00:21:09.120
could stack one
way or the other.

00:21:09.120 --> 00:21:12.040
In this case, they
can stacked like this,

00:21:12.040 --> 00:21:14.520
or they can stack like that.

00:21:14.520 --> 00:21:17.410
So I've got a
choice in stacking.

00:21:17.410 --> 00:21:19.320
That changes the folded state.

00:21:19.320 --> 00:21:21.630
That's the choice that the
folder is going to make,

00:21:21.630 --> 00:21:25.620
but in either case the mountain
valley assignment is the same.

00:21:25.620 --> 00:21:28.570
So that's how we're going to
communicate true and false,

00:21:28.570 --> 00:21:30.155
and I haven't
provided orientation.

00:21:30.155 --> 00:21:31.530
Should have drawn
an arrow there.

00:21:34.190 --> 00:21:37.700
Next gadget is this tab
gadget, and this is just

00:21:37.700 --> 00:21:40.454
a tool for building
weird shapes,

00:21:40.454 --> 00:21:42.370
and it's kind of similar
to some of the things

00:21:42.370 --> 00:21:44.770
you've seen in the
checkerboard folding.

00:21:44.770 --> 00:21:52.290
So our crease pattern looks
like this, and fold it flat.

00:21:52.290 --> 00:21:56.954
And there's two ways to fold it.

00:21:56.954 --> 00:21:58.620
Actually, a few
different folded states.

00:21:58.620 --> 00:22:00.270
But in particular,
there's a state

00:22:00.270 --> 00:22:05.830
like this where there's this
individually manipulatable tab,

00:22:05.830 --> 00:22:07.460
but there's no crease here.

00:22:07.460 --> 00:22:08.520
So it can't go backwards.

00:22:08.520 --> 00:22:10.030
The crease is in here.

00:22:10.030 --> 00:22:13.410
So it's got a fall
down like that.

00:22:13.410 --> 00:22:17.950
OK, so what this reduction
does is, ahead of time

00:22:17.950 --> 00:22:20.820
basically, force a
lot of these foldings.

00:22:20.820 --> 00:22:22.320
And so we start
with a square paper.

00:22:22.320 --> 00:22:25.150
We end up with a smaller square
paper with tabs sticking out

00:22:25.150 --> 00:22:27.470
in various directions
of various places.

00:22:27.470 --> 00:22:29.500
So this is much messier
and it'd be harder

00:22:29.500 --> 00:22:31.960
to draw the whole diagram of
what your crease pattern looks

00:22:31.960 --> 00:22:34.190
like, but in theory
you can do this.

00:22:34.190 --> 00:22:36.090
That's also kind of
like the box pleading

00:22:36.090 --> 00:22:38.650
method where you just
make a cube ahead of time,

00:22:38.650 --> 00:22:40.400
and it's like you had
a square originally.

00:22:40.400 --> 00:22:42.340
There just happens to
be a cube sitting here,

00:22:42.340 --> 00:22:44.610
and then you do other folding.

00:22:44.610 --> 00:22:47.290
And the angles in this
crease pattern-- these

00:22:47.290 --> 00:22:48.400
are not 45 degrees.

00:22:48.400 --> 00:22:50.450
They're at a bit
of a weird angle

00:22:50.450 --> 00:22:52.222
to basically force
this to happen first.

00:22:52.222 --> 00:22:54.180
It can't interact with
any of the other gadgets

00:22:54.180 --> 00:22:56.400
that I show you.

00:22:56.400 --> 00:22:59.040
Because you've got to get rid of
those angles in the beginning.

00:22:59.040 --> 00:23:03.010
Then, the main gadget here
is the not all equal clause,

00:23:03.010 --> 00:23:05.130
and that's what I
have folded here.

00:23:05.130 --> 00:23:08.160
So it's a little crazy,
but basically you've

00:23:08.160 --> 00:23:11.650
got three pleats-- three of
these double pleats coming

00:23:11.650 --> 00:23:12.630
together.

00:23:12.630 --> 00:23:16.300
These guys could stack-- this
one on top, this one on top.

00:23:16.300 --> 00:23:18.710
Now we're the same
for all three of them,

00:23:18.710 --> 00:23:22.376
and then you've got this little
twist like thing in the center,

00:23:22.376 --> 00:23:23.750
and it's really
hard to draw what

00:23:23.750 --> 00:23:24.916
the folded state looks like.

00:23:24.916 --> 00:23:27.730
This is what it looks
like within shadow pattern

00:23:27.730 --> 00:23:29.630
with transparency.

00:23:29.630 --> 00:23:31.090
Here's the real thing.

00:23:31.090 --> 00:23:34.450
And also, there's
these yellow tabs

00:23:34.450 --> 00:23:38.160
attached at very
specific locations.

00:23:38.160 --> 00:23:41.576
And this is a little
hard to imagine.

00:23:41.576 --> 00:23:43.450
I encourage you to fold
one of these in order

00:23:43.450 --> 00:23:47.190
to really see what's going on.

00:23:47.190 --> 00:23:49.780
But as I said before, you've
got-- each of these guys

00:23:49.780 --> 00:23:52.760
can be independently stacked
one way or the other.

00:23:52.760 --> 00:23:58.300
There's that one or this one
can stack this way or that way

00:23:58.300 --> 00:24:01.070
for all three, but we want
to forbid the case where

00:24:01.070 --> 00:24:02.720
they're all stacked
the same way.

00:24:02.720 --> 00:24:05.150
And the arrows here are all
pointing towards the gadget.

00:24:05.150 --> 00:24:06.900
So we want to forbid
the case when they're

00:24:06.900 --> 00:24:09.885
all-- when it's
rotationally symmetric.

00:24:09.885 --> 00:24:11.260
Gadget is rotationally
symmetric,

00:24:11.260 --> 00:24:13.635
but if you choose the layer
order rotationally symmetric,

00:24:13.635 --> 00:24:14.720
you're in trouble.

00:24:14.720 --> 00:24:18.055
So let me make it
rotationally symmetric.

00:24:18.055 --> 00:24:20.660
That would be like this.

00:24:20.660 --> 00:24:22.160
So when it's
rotationally symmetric,

00:24:22.160 --> 00:24:24.600
you see-- basically
all the panels

00:24:24.600 --> 00:24:28.010
you see-- there's three panels.

00:24:28.010 --> 00:24:29.530
This one, this
one, and this one.

00:24:29.530 --> 00:24:31.740
Each of them has a
tab sticking out,

00:24:31.740 --> 00:24:37.700
and basically these tabs have
to also be cyclically ordered,

00:24:37.700 --> 00:24:40.910
but it's not possible--
this is hard to do.

00:24:40.910 --> 00:24:42.750
It's like this.

00:24:42.750 --> 00:24:45.300
You see they're kind
of colliding here.

00:24:45.300 --> 00:24:48.190
Because if you look at each
of the tabs in projection,

00:24:48.190 --> 00:24:51.560
it collides with where
the tab is attached.

00:24:51.560 --> 00:24:57.430
So you basically-- if you went--
so someone has to be the lowest

00:24:57.430 --> 00:25:03.100
tab, and that tab will intersect
the other two tabs actually

00:25:03.100 --> 00:25:05.140
where that tab is attached.

00:25:05.140 --> 00:25:07.110
So it'll penetrate
and you can see

00:25:07.110 --> 00:25:10.290
they're not very
happy to stack here.

00:25:10.290 --> 00:25:14.630
But if I change the
layer order in any way,

00:25:14.630 --> 00:25:18.460
our lowest tab is actually
happy to go behind other layers,

00:25:18.460 --> 00:25:23.401
and then you can just stack
them, and they barely fit.

00:25:23.401 --> 00:25:25.900
So it's a little tricky to get
all the details here to work,

00:25:25.900 --> 00:25:29.000
but I think this particular
geometry-- and the reason

00:25:29.000 --> 00:25:32.500
I drew this in this exact way
is to make sure yeah, everything

00:25:32.500 --> 00:25:33.150
works.

00:25:33.150 --> 00:25:35.640
You do not penetrate here,
which would be a problem.

00:25:35.640 --> 00:25:37.749
You do not penetrate
this crease,

00:25:37.749 --> 00:25:38.790
which would be a problem.

00:25:38.790 --> 00:25:42.030
So the tab just fits in
between here and here,

00:25:42.030 --> 00:25:44.280
but it does cross.

00:25:44.280 --> 00:25:47.760
If you look at this tab,
it's attached along this edge

00:25:47.760 --> 00:25:49.830
as drawn up there.

00:25:49.830 --> 00:25:53.870
And this tab here will penetrate
this part of that edge,

00:25:53.870 --> 00:25:56.160
and it will penetrate this
part of this edge which

00:25:56.160 --> 00:25:57.440
is where this tab is attached.

00:25:57.440 --> 00:26:01.880
So they cause trouble in
this cyclic situation,

00:26:01.880 --> 00:26:05.480
but when it's a cyclic
like in this picture,

00:26:05.480 --> 00:26:09.420
you can put that
bottom tab way down

00:26:09.420 --> 00:26:12.170
here and avoid any collision.

00:26:12.170 --> 00:26:15.630
Then you can basically
break the cyclic condition,

00:26:15.630 --> 00:26:19.110
and you get to stack them
in some linear order.

00:26:19.110 --> 00:26:22.444
So it's a little hard to
see without physically

00:26:22.444 --> 00:26:23.110
manipulating it.

00:26:23.110 --> 00:26:26.749
Feel free to come and
play with that after.

00:26:26.749 --> 00:26:27.540
That's their proof.

00:26:27.540 --> 00:26:33.200
Now there's also splitters, and
turn gadgets, and crossovers,

00:26:33.200 --> 00:26:36.260
but I'll leave it at that.

00:26:36.260 --> 00:26:37.960
Those are more similar.

00:26:37.960 --> 00:26:41.370
This is the heart of what's
going on in this proof.

00:26:41.370 --> 00:26:43.520
So it's a completely
separate proof from the one

00:26:43.520 --> 00:26:46.254
that we saw before.

00:26:46.254 --> 00:26:47.650
Any questions about that?

00:26:51.481 --> 00:26:51.980
All right--

00:26:51.980 --> 00:26:52.911
AUDIENCE: Here.

00:26:52.911 --> 00:26:53.577
PROFESSOR: Yeah?

00:26:53.577 --> 00:26:55.535
AUDIENCE: I don't understand
why the tabs fold.

00:26:57.507 --> 00:26:58.840
PROFESSOR: How do the tabs fold?

00:26:58.840 --> 00:27:01.090
AUDIENCE: No, why do we need
tabs if everything folds?

00:27:03.210 --> 00:27:07.770
PROFESSOR: So the tabs
are being used as a device

00:27:07.770 --> 00:27:09.490
to build gadgets.

00:27:09.490 --> 00:27:11.540
So the tabs serve no
purpose by themselves.

00:27:11.540 --> 00:27:17.270
But this gadget involves
first folding three tabs here,

00:27:17.270 --> 00:27:19.860
which are actually
pointing-- they're

00:27:19.860 --> 00:27:22.800
pointing in that
direction, I believe.

00:27:22.800 --> 00:27:26.840
Then you add this crease
pattern afterwards.

00:27:26.840 --> 00:27:28.520
So originally there
are tabs here,

00:27:28.520 --> 00:27:30.500
which means there's a
bunch of creases here.

00:27:30.500 --> 00:27:34.000
After you fold them, then you
lay on this crease pattern.

00:27:34.000 --> 00:27:36.396
So if you unfolded it, you
get some much more complicated

00:27:36.396 --> 00:27:37.020
crease pattern.

00:27:37.020 --> 00:27:39.320
Which is when I made that,
I just taped the tabs on.

00:27:39.320 --> 00:27:43.020
But in reality, first you fold
the tabs so they exist there,

00:27:43.020 --> 00:27:45.400
then you fold this on top.

00:27:45.400 --> 00:27:48.290
So the fold crease pattern
would be quite complicated.

00:27:48.290 --> 00:27:50.510
It's going to have
tabs here, tabs here,

00:27:50.510 --> 00:27:55.650
tabs there, and then this
reflected a few times.

00:27:55.650 --> 00:27:58.000
And so then when you
fold it-- the fold gadget

00:27:58.000 --> 00:28:00.250
is this thing with the tabs.

00:28:00.250 --> 00:28:01.880
The tabs are just
like a stepping stone

00:28:01.880 --> 00:28:03.630
toward making this gadget.

00:28:03.630 --> 00:28:06.770
The other gadgets use more tabs.

00:28:06.770 --> 00:28:09.847
Obvious open problem here is
to make a simpler reduction.

00:28:09.847 --> 00:28:11.430
Shouldn't have to
be this complicated,

00:28:11.430 --> 00:28:13.721
and I've heard Tom Hall talk
about different approaches

00:28:13.721 --> 00:28:16.820
for making simpler
NP-hardness proofs,

00:28:16.820 --> 00:28:17.820
but we're not there yet.

00:28:20.610 --> 00:28:23.402
Other questions?

00:28:23.402 --> 00:28:25.354
AUDIENCE: So these proofs
don't imply anything

00:28:25.354 --> 00:28:27.306
about the [INAUDIBLE]?

00:28:27.306 --> 00:28:29.258
They can all be very
easily [INAUDIBLE].

00:28:33.670 --> 00:28:36.250
PROFESSOR: So this proof
implies these kinds

00:28:36.250 --> 00:28:39.960
of tessellation style crease
patterns are hard to fold,

00:28:39.960 --> 00:28:41.460
which implies that
in general crease

00:28:41.460 --> 00:28:43.037
patterns are hard to fold.

00:28:43.037 --> 00:28:45.120
But you could look at some
other specific pattern.

00:28:45.120 --> 00:28:47.310
For example, it's
the next topic.

00:28:47.310 --> 00:28:53.150
You could look at
map folding where

00:28:53.150 --> 00:28:55.980
you have horizontal
and vertical creases

00:28:55.980 --> 00:28:57.920
in a rectangular sheet of paper.

00:28:57.920 --> 00:29:00.550
Maybe each of these squares
is-- or each of these cells

00:29:00.550 --> 00:29:02.764
is a unit square, let's say.

00:29:02.764 --> 00:29:04.930
And I give you a mountain
valley assignment on that.

00:29:04.930 --> 00:29:08.030
Some of these are mountains.

00:29:08.030 --> 00:29:09.095
Some of them are valleys.

00:29:12.380 --> 00:29:13.070
Whatever.

00:29:13.070 --> 00:29:15.180
And I want to know
does this fold flat?

00:29:15.180 --> 00:29:17.250
That we don't know
the complexity of.

00:29:17.250 --> 00:29:20.690
Could be solvable by
polynomial time algorithm.

00:29:20.690 --> 00:29:22.050
Could be NP-hard.

00:29:22.050 --> 00:29:28.030
And this is actually mentioned
in lecture two notes,

00:29:28.030 --> 00:29:30.160
but not actually orally.

00:29:30.160 --> 00:29:32.750
And so I wanted to
get back to this.

00:29:32.750 --> 00:29:34.860
This is from lecture two notes.

00:29:34.860 --> 00:29:38.507
2D map folding, Jack
Edmonds poses this problem,

00:29:38.507 --> 00:29:40.590
can you characterize flat
foldable mountain valley

00:29:40.590 --> 00:29:41.090
pattern.

00:29:41.090 --> 00:29:43.430
Is there an algorithm
or is it NP-hard?

00:29:43.430 --> 00:29:46.530
And even the 2-by-n
problem was open

00:29:46.530 --> 00:29:48.220
when I wrote these
notes in 2010,

00:29:48.220 --> 00:29:50.440
but it has since been solved.

00:29:50.440 --> 00:29:54.390
So I thought I'd tell you a
little bit about that solution.

00:29:54.390 --> 00:29:56.932
So yeah, there can be special
cases of crease patterns

00:29:56.932 --> 00:29:57.890
that are easy to solve.

00:29:57.890 --> 00:30:01.990
We just know in
general they are hard.

00:30:01.990 --> 00:30:06.810
So 2-by-n is this
kind of picture.

00:30:06.810 --> 00:30:10.650
So this is what I call
2, counting cells.

00:30:16.370 --> 00:30:23.510
This is based on a class
project in this class

00:30:23.510 --> 00:30:28.220
from two years ago by
Eric Lew and Tom Morgan,

00:30:28.220 --> 00:30:33.840
but the paper got
finished this year.

00:30:33.840 --> 00:30:38.390
So it's based on a
series of reductions.

00:30:38.390 --> 00:30:41.280
On the one hand, we're going to
start with something called--

00:30:41.280 --> 00:30:46.030
OK, so we have map
holding on the left.

00:30:46.030 --> 00:30:47.870
We're going to
convert map folding

00:30:47.870 --> 00:30:51.950
into a different presentation,
which is NEWS labeling.

00:30:54.710 --> 00:30:57.520
We're going to convert that
into something called a top edge

00:30:57.520 --> 00:30:58.020
view.

00:31:01.630 --> 00:31:03.950
We're going to convert
that into a ray diagram.

00:31:07.660 --> 00:31:10.710
And the last part, which I
won't talk too much about,

00:31:10.710 --> 00:31:13.080
is we convert that into
something called a hidden tree

00:31:13.080 --> 00:31:13.580
problem.

00:31:16.214 --> 00:31:18.130
Each of these steps is
fairly straightforward,

00:31:18.130 --> 00:31:19.713
but there are obviously
a lot of them.

00:31:22.030 --> 00:31:24.680
But in the end, you get a
polynomial time algorithm

00:31:24.680 --> 00:31:27.270
to solve this, which implies
you get a polynomial time

00:31:27.270 --> 00:31:29.110
algorithm to solve this.

00:31:29.110 --> 00:31:31.310
And I'll talk mostly
about these reductions.

00:31:31.310 --> 00:31:32.860
It's the same idea
in NP-hardness.

00:31:32.860 --> 00:31:35.900
We use reductions from a
hard problem to our problem.

00:31:35.900 --> 00:31:38.730
In this case, we're
doing the reverse.

00:31:38.730 --> 00:31:41.250
We're reducing our problem
to an easier problem,

00:31:41.250 --> 00:31:43.000
so that by the end we
get something that's

00:31:43.000 --> 00:31:44.380
so easy we know how to solve it.

00:31:44.380 --> 00:31:46.505
The reductions are useful
both for positive results

00:31:46.505 --> 00:31:48.220
and negative results.

00:31:48.220 --> 00:31:51.191
So let me show you
visually some--

00:31:51.191 --> 00:31:53.280
oh, before we get
to the proof, I

00:31:53.280 --> 00:31:55.620
wanted to mention this
puzzle which you probably

00:31:55.620 --> 00:31:59.770
folded in problem set one.

00:31:59.770 --> 00:32:01.680
It's a map folding problem.

00:32:01.680 --> 00:32:04.480
It's a 3-by-3 map,
and so we didn't

00:32:04.480 --> 00:32:06.440
have any good algorithms
to solve them.

00:32:06.440 --> 00:32:08.400
So we used a not
so good algorithm--

00:32:08.400 --> 00:32:09.850
namely exhaustive enumeration.

00:32:09.850 --> 00:32:14.230
We enumerated all possible
folded states of a 3-by-3 map.

00:32:14.230 --> 00:32:16.370
We drew them out graphically.

00:32:16.370 --> 00:32:18.720
There's a scroll bar here,
so you don't see them all.

00:32:18.720 --> 00:32:21.360
But we put them in
a giant-- I forget,

00:32:21.360 --> 00:32:25.020
there's 1,000
folded states or so,

00:32:25.020 --> 00:32:30.500
so it's like 100-by--
whatever-- 10 array.

00:32:30.500 --> 00:32:32.240
And for each of
them-- so here's where

00:32:32.240 --> 00:32:33.660
you're designing your pattern.

00:32:33.660 --> 00:32:36.000
So you could make holes.

00:32:36.000 --> 00:32:37.170
You could put in patterns.

00:32:37.170 --> 00:32:40.000
This is sort of an early design
where it would spell MIT.

00:32:40.000 --> 00:32:42.060
The hole would show
the I on another side,

00:32:42.060 --> 00:32:46.460
so it's equivalent to
the puzzle you solve.

00:32:46.460 --> 00:32:48.120
And this is what
the top looks like.

00:32:48.120 --> 00:32:49.578
This is what the
bottom looks like.

00:32:49.578 --> 00:32:52.870
So you can hover over these
and change the letters that

00:32:52.870 --> 00:32:54.424
appeared, and then
it would show you

00:32:54.424 --> 00:32:56.090
what every single
state would look like,

00:32:56.090 --> 00:32:58.625
and it would color it in yellow
if one side looked like MIT,

00:32:58.625 --> 00:33:02.060
and it would color it in red
if both sides look like MIT.

00:33:02.060 --> 00:33:03.815
And the point was
to verify there

00:33:03.815 --> 00:33:06.550
was exactly one solution
for that puzzle.

00:33:06.550 --> 00:33:09.080
And so we kept-- we
would fold things

00:33:09.080 --> 00:33:10.960
to make it a tricky fold.

00:33:10.960 --> 00:33:13.600
Then we put into the
software and label things

00:33:13.600 --> 00:33:15.510
accordingly, then
put into the software

00:33:15.510 --> 00:33:16.880
and see is there unique folding?

00:33:16.880 --> 00:33:22.560
And then we could add in
extra misleading clues here,

00:33:22.560 --> 00:33:25.400
and see did they accidentally
make an extra solution?

00:33:25.400 --> 00:33:28.080
So we could add in
extra stuff to pack in.

00:33:28.080 --> 00:33:32.090
As much irrelevant stuff as we
could, and still make it unique

00:33:32.090 --> 00:33:33.550
so it's more challenging.

00:33:33.550 --> 00:33:38.552
That's a nice use of exponential
algorithms to design puzzles.

00:33:38.552 --> 00:33:41.120
All right, but
back to this proof.

00:33:43.790 --> 00:33:48.880
So I have here a much
simpler map than this one.

00:33:48.880 --> 00:33:52.780
This is what we
call the NEW map.

00:33:52.780 --> 00:33:54.030
N-E-W.

00:33:54.030 --> 00:33:55.950
So the labeling
here is very simple.

00:33:55.950 --> 00:33:59.760
If you look at this crease
pattern, by [INAUDIBLE],

00:33:59.760 --> 00:34:03.740
there's got to be three of one
type and one of the other type.

00:34:03.740 --> 00:34:07.690
So just label each vertex
by which way is unique.

00:34:07.690 --> 00:34:09.199
So from here, the
North direction

00:34:09.199 --> 00:34:13.600
is the uniquely label-- it's the
mountain among three valleys.

00:34:13.600 --> 00:34:15.421
And then this vertex--
the East label--

00:34:15.421 --> 00:34:16.920
is the mountain
among three valleys,

00:34:16.920 --> 00:34:20.791
and then the next one is the
West label among three valleys.

00:34:20.791 --> 00:34:22.540
Of course it doesn't
have to be like that.

00:34:22.540 --> 00:34:24.500
It could, for
example, you can have

00:34:24.500 --> 00:34:28.110
three mountains at a vertex,
but then the label of this guy's

00:34:28.110 --> 00:34:30.110
going to be W. It's going
to be the one that's

00:34:30.110 --> 00:34:33.620
unique among the other three.

00:34:33.620 --> 00:34:37.030
So if you fold this
map, it looks like this.

00:34:37.030 --> 00:34:40.489
I have one here, but it's
a little hard to see.

00:34:40.489 --> 00:34:44.550
We've got lots of back
and forth on the top edge.

00:34:44.550 --> 00:34:48.760
Some orienting it so that
the-- we've got 2 by n maps.

00:34:48.760 --> 00:34:50.570
So there's two
critical features.

00:34:50.570 --> 00:34:52.219
There's the center line.

00:34:52.219 --> 00:34:54.219
I'll call that the
spine of the map.

00:34:54.219 --> 00:34:57.300
There's the top side
and the bottom side.

00:34:57.300 --> 00:34:59.500
When you fold
that-- this is just

00:34:59.500 --> 00:35:02.910
a sequence of simple folds.

00:35:02.910 --> 00:35:06.100
You see at this last fold, the
top side and the bottom side

00:35:06.100 --> 00:35:11.500
come together, and the
spine is-- stays together.

00:35:11.500 --> 00:35:14.730
So when I orient it like
this as in the picture,

00:35:14.730 --> 00:35:19.350
the top side is where originally
the top and the bottom

00:35:19.350 --> 00:35:23.230
of the map all come to here
because of that spine fold,

00:35:23.230 --> 00:35:27.020
and the spine folds
are all down here.

00:35:27.020 --> 00:35:29.086
You can't see them
here, but there's

00:35:29.086 --> 00:35:30.860
you can see them at
the bottom there.

00:35:30.860 --> 00:35:33.880
There's some kind of
connections on the bottom,

00:35:33.880 --> 00:35:37.350
but there's this nice relatively
one-dimensional picture

00:35:37.350 --> 00:35:38.340
up here.

00:35:38.340 --> 00:35:42.340
So we're going to draw that.

00:35:42.340 --> 00:35:45.499
This is the top edge view.

00:35:45.499 --> 00:35:47.040
Got clipped a little
bit, but there's

00:35:47.040 --> 00:35:48.960
one more segment at the top.

00:35:48.960 --> 00:35:50.565
So that is just this.

00:35:53.440 --> 00:35:55.400
See it?

00:35:55.400 --> 00:35:56.920
Now there's also
these blue lines.

00:35:56.920 --> 00:36:00.420
The blue lines correspond to
what's going on at the bottom

00:36:00.420 --> 00:36:03.420
from the spine.

00:36:03.420 --> 00:36:06.520
Because if you think
about it, you've

00:36:06.520 --> 00:36:09.230
got the-- in a
2-by-n map-- you've

00:36:09.230 --> 00:36:12.622
got the top panels and these
edges making the top edge.

00:36:12.622 --> 00:36:14.830
And you've also got the
bottom panels and these edges

00:36:14.830 --> 00:36:15.788
making the bottom edge.

00:36:15.788 --> 00:36:16.770
They come in pairs.

00:36:16.770 --> 00:36:17.811
These guys are paired up.

00:36:17.811 --> 00:36:20.360
These guys are paired up,
and so on down the line

00:36:20.360 --> 00:36:23.630
because they are
joined by a spine edge.

00:36:23.630 --> 00:36:25.730
Those spine edges
correspond to the things

00:36:25.730 --> 00:36:29.560
on the bottom of the
folding, and they

00:36:29.560 --> 00:36:32.100
need to not cross each other.

00:36:32.100 --> 00:36:34.360
And that's what's illustrated
by the blue connections.

00:36:34.360 --> 00:36:39.130
So the very top edge is paired
with the very bottom edge.

00:36:39.130 --> 00:36:42.300
These two-- this panel
here and the back panel

00:36:42.300 --> 00:36:44.370
here-- are connected
on the bottom.

00:36:44.370 --> 00:36:47.520
And that-- I'm sorry,
that's not true.

00:36:47.520 --> 00:36:50.360
This one is paired
with this one.

00:36:50.360 --> 00:36:52.670
The top one is paired
with the second one.

00:36:52.670 --> 00:36:55.130
So it's actually these two
are connected on the bottom.

00:36:55.130 --> 00:37:00.220
That's this little connection
here, and then these guys--

00:37:00.220 --> 00:37:02.856
this wraps around everything.

00:37:02.856 --> 00:37:04.809
That's that connection.

00:37:04.809 --> 00:37:06.600
But what you can't see
it in this folding--

00:37:06.600 --> 00:37:09.702
because it's hidden inside--
is that within this connection

00:37:09.702 --> 00:37:11.910
on the bottom, there's this
connection on the bottom.

00:37:11.910 --> 00:37:14.370
And within that one,
there's this connection.

00:37:14.370 --> 00:37:15.219
Now this is OK.

00:37:15.219 --> 00:37:17.760
Might look like they're crossing
because they're overlapping.

00:37:17.760 --> 00:37:20.690
But as long as they
are nested-- as long

00:37:20.690 --> 00:37:24.190
as you don't start from
inside here and go to outside.

00:37:24.190 --> 00:37:25.410
That would be a crossing.

00:37:25.410 --> 00:37:27.730
You start inside,
you should end inside

00:37:27.730 --> 00:37:29.460
like in all these pictures.

00:37:29.460 --> 00:37:31.970
If you start outside,
you should end outside.

00:37:31.970 --> 00:37:35.030
So that's why-- these guys
are disjoint, so that's OK.

00:37:35.030 --> 00:37:37.360
This is nested in
that, so it's OK.

00:37:37.360 --> 00:37:39.914
Kind of like
balance parentheses.

00:37:39.914 --> 00:37:41.080
And so that's what it makes.

00:37:41.080 --> 00:37:42.830
A top valid top edge view.

00:37:42.830 --> 00:37:45.570
What's nice about this is it's
a one-dimensional diagram.

00:37:45.570 --> 00:37:48.111
What's not nice is it has all
these crossings because there's

00:37:48.111 --> 00:37:49.940
the blue stuff on top
of the black stuff.

00:37:49.940 --> 00:37:53.459
So it's a little
hard to find-- we're

00:37:53.459 --> 00:37:55.000
trying to find a
valid folding state.

00:37:55.000 --> 00:37:56.416
We're trying to
find one of these.

00:37:59.610 --> 00:38:02.840
We're not restricting ourselves
to simple folds here yet.

00:38:02.840 --> 00:38:05.810
Simple map folding we already
solved in lecture two.

00:38:05.810 --> 00:38:08.315
So this is all-- I should've
said non-simple folds.

00:38:13.380 --> 00:38:15.370
That's what makes
it hard, and that's

00:38:15.370 --> 00:38:17.830
what's still open
for 3-by-n maps

00:38:17.830 --> 00:38:19.460
if you don't know how to do it.

00:38:19.460 --> 00:38:22.870
But for 2-by-n maps,
we've made two steps here.

00:38:22.870 --> 00:38:25.450
We have another view,
which is the ray diagram,

00:38:25.450 --> 00:38:27.710
and this is really
specific to 2-by-n.

00:38:27.710 --> 00:38:30.290
And it lets us reduce
to a tree problem.

00:38:30.290 --> 00:38:34.540
So before we get there,
let's talk in general

00:38:34.540 --> 00:38:35.590
about the top edge view.

00:38:35.590 --> 00:38:39.710
You can actually convert from
the North, East, West, South

00:38:39.710 --> 00:38:44.750
labeling to a top edge
view in the following way.

00:38:44.750 --> 00:38:46.900
Whenever-- and you can kind
of see what's going on.

00:38:46.900 --> 00:38:48.530
So first we have an n.

00:38:48.530 --> 00:38:49.970
So we've got these
two guys, which

00:38:49.970 --> 00:38:51.344
are just paired
together happily.

00:38:51.344 --> 00:38:53.000
That's the beginning of the map.

00:38:53.000 --> 00:38:59.004
Then we turn left, and we've got
this guy paired with this guy.

00:38:59.004 --> 00:39:00.920
And so, in general,
whenever you have a North,

00:39:00.920 --> 00:39:04.202
you turn left with
your two guys.

00:39:04.202 --> 00:39:05.160
So that's what happens.

00:39:05.160 --> 00:39:08.420
Then we hit an East in
the map, and what happens

00:39:08.420 --> 00:39:11.910
here is this guy turns right,
but this one turns left.

00:39:11.910 --> 00:39:14.120
This is what you might
call an inside turn.

00:39:14.120 --> 00:39:16.220
It's like an inside
reverse fold in origami.

00:39:16.220 --> 00:39:17.970
And in general, whenever
you have an East,

00:39:17.970 --> 00:39:19.840
you turn inside like that.

00:39:19.840 --> 00:39:22.190
So this guy's paired
with that one,

00:39:22.190 --> 00:39:23.990
and now this guy's
paired with that one.

00:39:23.990 --> 00:39:26.200
They both turn in.

00:39:26.200 --> 00:39:28.070
And then it's symmetric.

00:39:28.070 --> 00:39:30.370
Next one is a w, which is
the opposite of an e, which

00:39:30.370 --> 00:39:32.730
means you turn out here.

00:39:32.730 --> 00:39:36.900
And in general, whenever you
have a West, you turn out.

00:39:36.900 --> 00:39:38.119
And a South, you turn right.

00:39:38.119 --> 00:39:39.660
So those are the
four possible things

00:39:39.660 --> 00:39:42.510
you could imagine when you
have a pair of things turning,

00:39:42.510 --> 00:39:45.860
and those exactly correspond
to N, E, W, and S.

00:39:45.860 --> 00:39:49.780
So it's clear what you need
to do in this situation,

00:39:49.780 --> 00:39:52.490
but there's flexibility, right?

00:39:52.490 --> 00:39:55.980
For example, this guy--
when you turn out-- here

00:39:55.980 --> 00:39:57.480
I turned out to the
very next layer,

00:39:57.480 --> 00:40:00.300
but this could have
turned out to go up here.

00:40:00.300 --> 00:40:02.540
Would that be OK?

00:40:02.540 --> 00:40:06.240
Ah, no.

00:40:06.240 --> 00:40:09.020
If this one turned
out to go up here,

00:40:09.020 --> 00:40:12.880
that edge up there would be
paired with this one down here.

00:40:12.880 --> 00:40:14.890
So there'd be a blue
line going like that,

00:40:14.890 --> 00:40:16.990
and that would be a
crossing situation

00:40:16.990 --> 00:40:19.295
because that blue line
would cross this one.

00:40:19.295 --> 00:40:22.330
Because it starts inside
and it goes to outside.

00:40:22.330 --> 00:40:23.660
So it's a little tricky.

00:40:23.660 --> 00:40:26.570
This definitely gives you
some of the layer constraints,

00:40:26.570 --> 00:40:28.600
but it doesn't
check for crossings.

00:40:28.600 --> 00:40:31.720
Which is the big
challenge in this problem.

00:40:31.720 --> 00:40:33.990
So we're going to
simplify this diagram.

00:40:33.990 --> 00:40:35.770
So just think about
top edge views.

00:40:35.770 --> 00:40:36.990
Forget about map folding now.

00:40:36.990 --> 00:40:39.760
You can forget about
the previous layers,

00:40:39.760 --> 00:40:44.370
and we are now focusing
on this reduction.

00:40:44.370 --> 00:40:47.900
So we've got top edge view
converting to ray diagrams.

00:40:47.900 --> 00:40:49.220
You can see it's much simpler.

00:40:49.220 --> 00:40:51.564
This is the ray diagram
of that picture.

00:40:51.564 --> 00:40:52.980
And essentially--
there's two ways

00:40:52.980 --> 00:40:54.313
to think about what we're doing.

00:40:54.313 --> 00:40:57.180
Instead of having two edges,
and we track two edges turning,

00:40:57.180 --> 00:40:58.992
we just want one edge.

00:40:58.992 --> 00:41:00.200
That's one thing we're doing.

00:41:00.200 --> 00:41:04.860
You can think of that as
tracking the spine instead

00:41:04.860 --> 00:41:08.110
of the top and the bottom sides.

00:41:08.110 --> 00:41:10.795
But it's a little-- ray diagrams
are going to get confusing.

00:41:10.795 --> 00:41:14.400
I'll just tell you
that right now.

00:41:14.400 --> 00:41:16.040
Every time I look
at it, I understand

00:41:16.040 --> 00:41:17.570
it a little bit
more, but it's not

00:41:17.570 --> 00:41:19.850
going to be obviously that
this is equivalent to this.

00:41:19.850 --> 00:41:21.880
I'll just tell you--
here's an alternate way

00:41:21.880 --> 00:41:23.810
to think about it.

00:41:23.810 --> 00:41:26.260
Basically, the vertical--
the y direction

00:41:26.260 --> 00:41:29.080
here is going to
be nesting depth.

00:41:29.080 --> 00:41:32.920
So whenever we go in
like this, we go deeper.

00:41:35.480 --> 00:41:38.540
So for whatever reason,
I flipped the labeling,

00:41:38.540 --> 00:41:39.960
but it is indeed East.

00:41:39.960 --> 00:41:43.237
When you go in, you go down.

00:41:43.237 --> 00:41:45.820
I should have just moved these
two figures so they correspond,

00:41:45.820 --> 00:41:51.150
but when you go East you go
down a layer because you're

00:41:51.150 --> 00:41:52.740
nesting deeper.

00:41:52.740 --> 00:41:54.630
And when you go West,
you're going out,

00:41:54.630 --> 00:41:58.860
so you go up a layer in this
new weird ray diagram view.

00:41:58.860 --> 00:42:03.720
And North and South turn out
to not turnaround in this view.

00:42:03.720 --> 00:42:05.775
We're just going to
fire a ray downward,

00:42:05.775 --> 00:42:07.650
and there's either a
North ray-- a blue one--

00:42:07.650 --> 00:42:08.900
or a South ray-- a red one.

00:42:12.390 --> 00:42:15.470
And so if you follow
this diagram, it's N-E-W.

00:42:15.470 --> 00:42:18.950
So first we have an N, which
means we shoot a ray down.

00:42:18.950 --> 00:42:23.110
Then we have an E, which
means we turn downwards.

00:42:23.110 --> 00:42:26.642
And then we have a W, which
means we turn to go up a layer.

00:42:26.642 --> 00:42:28.850
And I haven't told you what
the constraints are here,

00:42:28.850 --> 00:42:32.920
but I claim this is a valid
folding just like that one.

00:42:32.920 --> 00:42:35.250
And it's obviously a
lot easier to draw.

00:42:35.250 --> 00:42:37.840
It's a much slower complexity.

00:42:37.840 --> 00:42:39.380
But the cool thing
is you no longer

00:42:39.380 --> 00:42:41.230
have these crossing parts.

00:42:41.230 --> 00:42:44.140
So let me show you--
first, let me tell you

00:42:44.140 --> 00:42:45.560
what the constraints are.

00:42:45.560 --> 00:42:48.390
So in general, you're going
to have lots of downward rays.

00:42:48.390 --> 00:42:49.070
This is a North.

00:42:49.070 --> 00:42:49.850
This is a South.

00:42:49.850 --> 00:42:51.080
A North, a South.

00:42:51.080 --> 00:42:53.344
So if you had like N, S,
N, S, in your pattern,

00:42:53.344 --> 00:42:55.010
it's just going to
be a straight segment

00:42:55.010 --> 00:42:57.950
with downward rays
of different colors.

00:42:57.950 --> 00:43:01.830
First constraint is whenever you
have a an N ray-- a North ray--

00:43:01.830 --> 00:43:05.190
it has to hit another North
ray or just go off to infinity.

00:43:05.190 --> 00:43:07.400
And the same-- South rays
can only hit South rays

00:43:07.400 --> 00:43:09.010
or go off to infinity.

00:43:09.010 --> 00:43:11.090
So they line up in
this way, but you

00:43:11.090 --> 00:43:15.210
can stretch the x-coordinate
to do whatever you want.

00:43:15.210 --> 00:43:17.850
This corresponds to basically
jumping over a bunch of layers.

00:43:17.850 --> 00:43:20.620
When you turn in
your folded state,

00:43:20.620 --> 00:43:22.850
you can skip a bunch of
layers and just go up here.

00:43:22.850 --> 00:43:28.209
So that corresponds to jumping
over a bunch of folds here.

00:43:28.209 --> 00:43:29.750
But in particular
we get these things

00:43:29.750 --> 00:43:31.140
called constrained segments.

00:43:31.140 --> 00:43:33.080
Constrained segments
are portions

00:43:33.080 --> 00:43:39.870
of this black spine between
two rays that below it only

00:43:39.870 --> 00:43:42.080
see black.

00:43:42.080 --> 00:43:44.080
OK, so for example, this
one is unconstrained,

00:43:44.080 --> 00:43:46.240
because below it, you
can see off to infinity.

00:43:46.240 --> 00:43:47.430
So that's unconstrained.

00:43:47.430 --> 00:43:48.684
We don't care about that one.

00:43:48.684 --> 00:43:50.100
But among unconstrained
segments--

00:43:50.100 --> 00:43:51.780
these are two
constrained segments--

00:43:51.780 --> 00:43:54.780
we want that all of the rays
that they see below them--

00:43:54.780 --> 00:43:57.450
so here I see one red
ray, one blue ray-- I want

00:43:57.450 --> 00:43:59.740
the number of reds
and blues to be equal.

00:43:59.740 --> 00:44:03.080
So this is valid because
there's one red, one blue.

00:44:03.080 --> 00:44:07.240
This one is invalid because
there's two blue and one red.

00:44:07.240 --> 00:44:09.060
This turns out to be
the right constraint.

00:44:09.060 --> 00:44:11.830
Essentially this is saying
however much you spiral,

00:44:11.830 --> 00:44:13.750
you should spiral.

00:44:13.750 --> 00:44:15.500
That's the intuition.

00:44:15.500 --> 00:44:17.960
So here you're spiraling
twice, unspiraling once.

00:44:17.960 --> 00:44:21.920
So you're trapped inside, and
so these folds cannot actually

00:44:21.920 --> 00:44:23.160
come together.

00:44:23.160 --> 00:44:24.840
The rays coming
together correspond

00:44:24.840 --> 00:44:30.780
to a nice nesting
between two North folds.

00:44:30.780 --> 00:44:32.740
So it's not obvious,
but this turns out

00:44:32.740 --> 00:44:34.870
to be the only
constraints you have.

00:44:34.870 --> 00:44:36.540
The black should
not cross itself.

00:44:36.540 --> 00:44:38.970
Constraint segments should
be valid in this way,

00:44:38.970 --> 00:44:42.410
and blue should hit blue
and red should hit red.

00:44:42.410 --> 00:44:45.140
So that's not obvious,
but it's true,

00:44:45.140 --> 00:44:48.370
and then you can take very
complicated diagrams like this

00:44:48.370 --> 00:44:50.640
and simplify them into
these nice pictures.

00:44:53.560 --> 00:44:56.310
So these are two
different foldings

00:44:56.310 --> 00:44:59.170
of the same pattern,
which I guess

00:44:59.170 --> 00:45:05.160
is N-E-N-- I can see
that easily here.

00:45:05.160 --> 00:45:08.120
You could have also
extracted it from here.

00:45:08.120 --> 00:45:10.410
There's two foldings
because these two layers

00:45:10.410 --> 00:45:11.880
could go here in the middle.

00:45:11.880 --> 00:45:14.690
Or they could be pushed
up to fit in here,

00:45:14.690 --> 00:45:17.215
and then we get this picture.

00:45:17.215 --> 00:45:19.860
And in the ray diagram--
you can see this

00:45:19.860 --> 00:45:23.120
pretty easily-- either you have
these n rays just both go off

00:45:23.120 --> 00:45:26.300
to infinity, and this is an
unconstrained segment so we

00:45:26.300 --> 00:45:30.390
don't care about that there's
only one North ray below.

00:45:30.390 --> 00:45:32.180
Or, you can extend
the x, because I

00:45:32.180 --> 00:45:33.560
can stretch the
x parts however I

00:45:33.560 --> 00:45:37.339
want and make these blue
segments align with each other.

00:45:37.339 --> 00:45:38.880
And that corresponds
to this folding.

00:45:38.880 --> 00:45:41.140
So really, all folded
states of the original thing

00:45:41.140 --> 00:45:44.170
are represented by
the ray diagram.

00:45:44.170 --> 00:45:46.800
Of course, if I had any
W, this would be valid,

00:45:46.800 --> 00:45:49.350
but this would not be that.

00:45:49.350 --> 00:45:52.920
N-E-S-- blast from the past.

00:45:52.920 --> 00:45:57.866
If I had N-E-S, then this would
be blue, this would be red,

00:45:57.866 --> 00:45:58.990
and so this would be valid.

00:45:58.990 --> 00:46:01.680
But this would be
invalid, and so on.

00:46:01.680 --> 00:46:04.000
So it's obviously a lot
easier conceptually,

00:46:04.000 --> 00:46:06.490
but you can also-- and here's
a more complicated algorithm.

00:46:06.490 --> 00:46:08.320
You take a really crazy map.

00:46:08.320 --> 00:46:10.770
This notation, by the
way, was introduced

00:46:10.770 --> 00:46:13.810
by Jacques Justin
like late 1980s.

00:46:13.810 --> 00:46:17.840
You may remember his name
from Kawasaki-Justin theorem.

00:46:17.840 --> 00:46:20.010
So at the same time he
was looking at map folding

00:46:20.010 --> 00:46:21.700
and he came up
with this notation,

00:46:21.700 --> 00:46:24.840
the ray diagram was introduced
in the open problem session

00:46:24.840 --> 00:46:28.550
in this class two years ago--
or actually five years ago

00:46:28.550 --> 00:46:34.020
if I recall correctly-- by
David Charlton and Yoyo Zhou.

00:46:34.020 --> 00:46:36.020
And then it was picked
up again two years ago,

00:46:36.020 --> 00:46:38.051
and finally we took
this ray diagram

00:46:38.051 --> 00:46:39.300
and came up with an algorithm.

00:46:39.300 --> 00:46:41.530
So how does the algorithm work?

00:46:41.530 --> 00:46:43.100
Here's a ray
diagram-- the black,

00:46:43.100 --> 00:46:45.750
and the red, and the blue.

00:46:45.750 --> 00:46:51.800
We observe that the blank
space here between the spine

00:46:51.800 --> 00:46:57.040
stuff-- between all the black--
is kind of a tree structure.

00:46:57.040 --> 00:46:58.840
You've got-- and
that's what's drawn

00:46:58.840 --> 00:47:00.810
in cyan with the red dots.

00:47:00.810 --> 00:47:06.160
So if you draw a node every time
you turn around on the outside.

00:47:06.160 --> 00:47:09.600
Then you say, well, I can get
from this node to this one,

00:47:09.600 --> 00:47:11.184
so I'm going to draw
a segment there.

00:47:11.184 --> 00:47:12.850
And I can get from
this node to this one

00:47:12.850 --> 00:47:16.090
without crossing any black,
so I'll draw a segment there.

00:47:16.090 --> 00:47:18.139
That's sort of it on that side.

00:47:18.139 --> 00:47:19.430
There's nothing else down here.

00:47:19.430 --> 00:47:21.404
That sort of doesn't count.

00:47:21.404 --> 00:47:22.945
But here's there's
another dot, and I

00:47:22.945 --> 00:47:24.920
can get from this one
to there by going out

00:47:24.920 --> 00:47:26.450
here without crossing black.

00:47:26.450 --> 00:47:30.470
Here to here, here to over
here without crossing black,

00:47:30.470 --> 00:47:31.070
and so on.

00:47:31.070 --> 00:47:35.490
So that cyan structure is
a tree-- has no cycles.

00:47:35.490 --> 00:47:37.920
Which in general is good
news for algorithms.

00:47:37.920 --> 00:47:40.570
Trees are relatively
easy to find algorithms

00:47:40.570 --> 00:47:43.045
for using dynamic programming.

00:47:43.045 --> 00:47:44.920
If you've seen dynamic
programming for trees,

00:47:44.920 --> 00:47:46.370
this is not like that.

00:47:46.370 --> 00:47:49.290
It's a little different because
we don't know what the tree is.

00:47:49.290 --> 00:47:51.270
We have to figure
out what the tree is.

00:47:51.270 --> 00:47:54.450
But basically, we can
guess the tree recursively.

00:47:54.450 --> 00:47:56.650
So there's some first
node-- I don't know,

00:47:56.650 --> 00:47:59.880
maybe it's this one--
just guess that.

00:47:59.880 --> 00:48:03.200
Not randomly, but guess
means try all the options.

00:48:03.200 --> 00:48:05.780
So you guess some node, and
then OK, we've got-- maybe

00:48:05.780 --> 00:48:06.970
we've got two subtrees.

00:48:06.970 --> 00:48:09.290
Maybe we've got three.

00:48:09.290 --> 00:48:12.400
I think that's about
all there could be.

00:48:12.400 --> 00:48:16.024
And so, just guessed that,
and then so recursively guess

00:48:16.024 --> 00:48:17.440
a subtree here and
a subtree here.

00:48:17.440 --> 00:48:18.981
And each of the sub
trees corresponds

00:48:18.981 --> 00:48:24.820
to a sub segment of this--
of the original map.

00:48:24.820 --> 00:48:26.910
The spine, roughly speaking.

00:48:26.910 --> 00:48:30.530
And roughly speaking,
these portions

00:48:30.530 --> 00:48:32.190
do not interact with each other.

00:48:32.190 --> 00:48:34.154
There's this issue of
how the rays align,

00:48:34.154 --> 00:48:36.570
and that's sort of the challenge
in getting this algorithm

00:48:36.570 --> 00:48:37.480
to work.

00:48:37.480 --> 00:48:39.380
But you can essentially
locally check

00:48:39.380 --> 00:48:41.310
whether a subtree
is good enough.

00:48:41.310 --> 00:48:43.590
That it will interact OK
with a different subtree,

00:48:43.590 --> 00:48:45.405
and just split this
problem up recursively

00:48:45.405 --> 00:48:46.280
guessing all the way.

00:48:46.280 --> 00:48:49.370
Effectively trying all
trees, but in polynomial time

00:48:49.370 --> 00:48:50.750
instead of exponential time.

00:48:50.750 --> 00:48:53.630
Forget the running time is
something like n to the 10

00:48:53.630 --> 00:48:57.000
or some really big constant,
but at least finally we

00:48:57.000 --> 00:48:59.835
know 2-by-n maps can be
solved in polynomial time.

00:48:59.835 --> 00:49:01.460
We give the mountain
valley assignment.

00:49:01.460 --> 00:49:04.820
We still don't
know about 3-by-n.

00:49:04.820 --> 00:49:07.940
That's the open question, and
these techniques unfortunately

00:49:07.940 --> 00:49:08.800
don't seem to apply.

00:49:08.800 --> 00:49:10.894
You definitely don't
get a tree anymore.

00:49:10.894 --> 00:49:12.560
You might get some
nice structure that's

00:49:12.560 --> 00:49:15.930
kind of vaguely tree
like, but this was already

00:49:15.930 --> 00:49:18.020
super complicated.

00:49:18.020 --> 00:49:20.120
So we've gotten stuck here.

00:49:20.120 --> 00:49:20.845
Any questions?

00:49:23.655 --> 00:49:24.640
All right.

00:49:24.640 --> 00:49:26.410
That's it.

