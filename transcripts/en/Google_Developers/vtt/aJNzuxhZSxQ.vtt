WEBVTT
Kind: captions
Language: en

00:00:07.176 --> 00:00:09.300
FRENCESCO NERIERI: So I
bumped into this commercial

00:00:09.300 --> 00:00:13.640
the other day from 1979.

00:00:13.640 --> 00:00:16.270
Dumb terminals were
really popular back then.

00:00:16.270 --> 00:00:19.280
Are you all familiar
with dumb terminals?

00:00:19.280 --> 00:00:22.010
It was just a keyboard
and a monitor connected

00:00:22.010 --> 00:00:27.710
to a central intelligence,
like a mainframe or a server.

00:00:27.710 --> 00:00:31.440
And 1979 is also when
Sony introduced Walkman,

00:00:31.440 --> 00:00:34.766
the portable cassette
music player.

00:00:34.766 --> 00:00:37.440
I really love these
old commercials.

00:00:37.440 --> 00:00:41.100
Now, 35 years later
today, we are literally

00:00:41.100 --> 00:00:46.740
surrounded by smart gadgets--
smart watches, smart TVs,

00:00:46.740 --> 00:00:49.960
smartphones, and apparently
music playing smart toilets.

00:00:52.580 --> 00:00:54.930
And these gadgets are
indeed really smart.

00:00:54.930 --> 00:00:57.910
Let's pick just the Nexus 5.

00:00:57.910 --> 00:01:01.720
It has a quad-core
2.3 gigahertz.

00:01:01.720 --> 00:01:03.980
I mean, I don't know what
was your first computer when

00:01:03.980 --> 00:01:05.810
you were in college,
but back then

00:01:05.810 --> 00:01:09.550
when I over clocked my Pentium
II Deschutes to something

00:01:09.550 --> 00:01:15.550
like 450 megahertz, I thought
I was driving a Ferrari.

00:01:15.550 --> 00:01:18.970
That was a tower this tall.

00:01:18.970 --> 00:01:21.230
But these gadgets,
they share something

00:01:21.230 --> 00:01:24.610
in common with those
dumb terminals.

00:01:24.610 --> 00:01:27.260
I'm so used to being always
online, always connected

00:01:27.260 --> 00:01:30.170
that I don't even download my
music or my movies anymore.

00:01:30.170 --> 00:01:32.820
I use Google Play
musical access,

00:01:32.820 --> 00:01:36.870
or Netflix, or Pandora, Spotify.

00:01:36.870 --> 00:01:40.620
So for these gadgets to
perform smart operations,

00:01:40.620 --> 00:01:43.380
they have to be connected
to an intelligence.

00:01:43.380 --> 00:01:47.350
And this intelligence
is the cloud.

00:01:47.350 --> 00:01:50.900
In fact, those times that
I find myself offline,

00:01:50.900 --> 00:01:52.390
it feels like
something is missing.

00:01:52.390 --> 00:01:55.360
And maybe I'm playing a
game like Flappy Bird.

00:01:55.360 --> 00:01:59.310
It's a game that can be
really frustrating real fast.

00:01:59.310 --> 00:02:04.200
My name is Francesco, and
thanks for joining my session.

00:02:04.200 --> 00:02:06.980
Today, I'm introducing
a few Google services

00:02:06.980 --> 00:02:11.130
that will let you build
applications that can perform

00:02:11.130 --> 00:02:12.900
really smart tasks
and communicate

00:02:12.900 --> 00:02:15.960
across all these gadgets
with a minimal effort spent

00:02:15.960 --> 00:02:19.540
on developing on the cloud.

00:02:19.540 --> 00:02:22.990
And communication is the key,
communication across devices.

00:02:22.990 --> 00:02:26.230
For my watch to buzz me that
it's time to jump on stage,

00:02:26.230 --> 00:02:28.700
it needs to communicate
with my phone, which

00:02:28.700 --> 00:02:31.440
needs to communicate
with the cloud,

00:02:31.440 --> 00:02:33.650
and communication among us.

00:02:33.650 --> 00:02:36.870
We live in a social
application era.

00:02:36.870 --> 00:02:41.860
Twitter, WhatsApp,
Google+, Facebook, Yelp.

00:02:41.860 --> 00:02:44.040
We communicate through
these applications

00:02:44.040 --> 00:02:47.930
that interoperate by the cloud.

00:02:47.930 --> 00:02:50.210
And in Google, we have
a very popular service

00:02:50.210 --> 00:02:53.230
that lets your
application interoperate

00:02:53.230 --> 00:02:54.780
across these devices.

00:02:54.780 --> 00:02:59.080
And it's one of my favorite
products-- Google Cloud

00:02:59.080 --> 00:03:01.290
Messaging.

00:03:01.290 --> 00:03:02.790
Now, Google Cloud
Messaging is still

00:03:02.790 --> 00:03:04.790
experiencing a fantastic growth.

00:03:04.790 --> 00:03:08.600
Just from last year, we are
processing now three times

00:03:08.600 --> 00:03:11.100
the number of requests.

00:03:11.100 --> 00:03:16.430
And this is like 700,000
queries per second,

00:03:16.430 --> 00:03:21.440
which is over 60 billion
requests every single day.

00:03:21.440 --> 00:03:25.280
And actually now, because
we're in time of a World Cup,

00:03:25.280 --> 00:03:28.110
I've seen spikes over a few
million queries per second.

00:03:31.010 --> 00:03:34.870
The other day I was checking
the graphs of the GCM requests.

00:03:34.870 --> 00:03:36.290
And it was really
funny to see how

00:03:36.290 --> 00:03:41.310
you can match one to one the
spikes with the goals scored

00:03:41.310 --> 00:03:42.610
by the various teams.

00:03:42.610 --> 00:03:47.120
So for example, this is the
unfortunately only good match

00:03:47.120 --> 00:03:50.060
for Italy versus England.

00:03:50.060 --> 00:03:51.480
And you can see
at 3:00 PM when it

00:03:51.480 --> 00:03:55.540
starts, there's a little
buzz, a little chatting.

00:03:55.540 --> 00:03:57.350
And then there's a
huge spike, which

00:03:57.350 --> 00:04:00.600
is when Italy scores and
England scores right after.

00:04:00.600 --> 00:04:03.230
And then finally the
winning goal for Italy.

00:04:03.230 --> 00:04:05.930
And at the end, there's a lot of
texting when the match is over.

00:04:08.650 --> 00:04:11.310
Today we have over
100,000 applications

00:04:11.310 --> 00:04:15.440
that already register with GCM.

00:04:15.440 --> 00:04:19.630
But this growth is not destined
to go any slower, because we

00:04:19.630 --> 00:04:22.120
just announced a new
member to the Google Cloud

00:04:22.120 --> 00:04:25.110
messaging family.

00:04:25.110 --> 00:04:27.700
So today, you can send
messages to your application

00:04:27.700 --> 00:04:31.530
on every single Android device,
but now you can do more.

00:04:31.530 --> 00:04:34.130
Let me introduce GCM for Chrome.

00:04:38.630 --> 00:04:44.480
You have the very same APIs--
multi-casting, messages

00:04:44.480 --> 00:04:47.310
with payload, send
to sync, all the APIs

00:04:47.310 --> 00:04:48.650
that you enjoy in Android.

00:04:48.650 --> 00:04:50.650
And you have the
same performance

00:04:50.650 --> 00:04:54.750
and you also cap
the very same price.

00:04:54.750 --> 00:04:56.790
So to see how this
works in details,

00:04:56.790 --> 00:04:59.640
let's imagine that we built
a World Cup application.

00:05:05.830 --> 00:05:10.860
The basic idea behind GCM
is that our World Cup server

00:05:10.860 --> 00:05:15.440
can send a message to GCM to our
World Cup application via GCM.

00:05:15.440 --> 00:05:17.900
And we can reach every single
Android device out there.

00:05:17.900 --> 00:05:20.610
And now we can also reach
our World Cup publication

00:05:20.610 --> 00:05:24.687
on any single Chrome browser
or Chrome OS machine.

00:05:24.687 --> 00:05:26.520
And this is really
important, because now we

00:05:26.520 --> 00:05:30.420
can reach the user on the
screen where he's looking at.

00:05:30.420 --> 00:05:32.530
So for example, when I
was preparing this deck,

00:05:32.530 --> 00:05:34.860
I was sitting on my
couch on my laptop.

00:05:34.860 --> 00:05:38.280
If we had the World Cup
application on Chrome,

00:05:38.280 --> 00:05:40.530
I could've been notified
that Italy scored right there

00:05:40.530 --> 00:05:41.863
in the monitor I was looking at.

00:05:44.830 --> 00:05:47.370
To have the Chrome
application work with GCM,

00:05:47.370 --> 00:05:50.880
we need to do the same steps
that we do for Android.

00:05:50.880 --> 00:05:54.460
So we need first to
register with the service.

00:05:54.460 --> 00:05:58.500
So we ask for registration
ID, and we get it from GCM.

00:05:58.500 --> 00:06:00.940
And the registration
ID is the address

00:06:00.940 --> 00:06:03.980
of the Chrome application
on a given browser.

00:06:03.980 --> 00:06:06.480
Just like for Android,
it's the address

00:06:06.480 --> 00:06:10.590
of an Android application
on a given Android device.

00:06:10.590 --> 00:06:12.870
So now the Chrome application
sends the registration

00:06:12.870 --> 00:06:15.940
ID to the World Cup
server, which can now

00:06:15.940 --> 00:06:18.070
send a message back
to the application

00:06:18.070 --> 00:06:23.130
by addressing it to
the registration ID.

00:06:23.130 --> 00:06:26.020
And these registrations
are the same for Android

00:06:26.020 --> 00:06:26.705
and for Chrome.

00:06:26.705 --> 00:06:28.080
The World Cup
server doesn't even

00:06:28.080 --> 00:06:30.680
need to know which one is which.

00:06:30.680 --> 00:06:33.760
And because we are living in
this world of multiscreens,

00:06:33.760 --> 00:06:36.760
it becomes more and more
important and useful

00:06:36.760 --> 00:06:39.140
for us to be able to
target the user rather

00:06:39.140 --> 00:06:41.650
than every single device.

00:06:41.650 --> 00:06:44.560
So it would be very useful
if you could tell, hey GCM,

00:06:44.560 --> 00:06:48.760
we send this message to this
user and now go figure it out.

00:06:48.760 --> 00:06:50.480
And today, you can't do that.

00:06:50.480 --> 00:06:52.535
Because we are
launching for everybody

00:06:52.535 --> 00:06:55.730
the new API user notifications.

00:06:58.515 --> 00:07:00.265
And the way this API
works is very simple.

00:07:02.800 --> 00:07:06.510
As you have seen, every single
device, every application

00:07:06.510 --> 00:07:09.410
on every single device,
sends the registration ID up

00:07:09.410 --> 00:07:11.650
to the World Cup
server, which now

00:07:11.650 --> 00:07:15.070
has the map in between
the user account, the user

00:07:15.070 --> 00:07:17.830
that we signed in in our
World Cup application,

00:07:17.830 --> 00:07:19.620
and the registration IDs.

00:07:19.620 --> 00:07:24.020
And all we need to do is to
give them mapping to GCM.

00:07:24.020 --> 00:07:27.751
And say hey, create this mapping
for a user and my World Cup

00:07:27.751 --> 00:07:28.250
app.

00:07:28.250 --> 00:07:30.480
And these are all its devices.

00:07:30.480 --> 00:07:32.450
So GCM creates a
notification key,

00:07:32.450 --> 00:07:35.760
which is the identity of
the user for the World Cup

00:07:35.760 --> 00:07:38.440
application.

00:07:38.440 --> 00:07:41.080
And now just like before,
we can send a message

00:07:41.080 --> 00:07:43.690
and target it to the
notification key to the user

00:07:43.690 --> 00:07:44.930
itself.

00:07:44.930 --> 00:07:48.319
And GCM delivers it to all of
these devices and endpoints

00:07:48.319 --> 00:07:49.360
as they become available.

00:07:51.940 --> 00:07:55.500
So now you can send a message
and target me if you say,

00:07:55.500 --> 00:07:57.320
Italy scored a goal.

00:07:57.320 --> 00:08:00.120
And we pop the notification
on all of my devices,

00:08:00.120 --> 00:08:01.564
on all of my screens.

00:08:01.564 --> 00:08:03.980
But because now we're seeing
this notification everywhere,

00:08:03.980 --> 00:08:06.440
it becomes more important
that we synchronize

00:08:06.440 --> 00:08:08.550
the dismissal of
this notification.

00:08:08.550 --> 00:08:10.600
If I see that Italy
scored on my watch,

00:08:10.600 --> 00:08:12.280
as much as I like
that notification,

00:08:12.280 --> 00:08:15.680
I don't want to see
it again on my tablet.

00:08:15.680 --> 00:08:17.750
So when we act on
the notification,

00:08:17.750 --> 00:08:21.300
we need a way to dismiss
it everywhere else.

00:08:21.300 --> 00:08:22.800
And today we can
do that, because we

00:08:22.800 --> 00:08:26.005
are launching for everyone--
Upstream Messaging.

00:08:28.820 --> 00:08:32.789
Now, let's deep dive on an
example to see how this works.

00:08:32.789 --> 00:08:35.260
Let's assume that we
have a tablet and a phone

00:08:35.260 --> 00:08:38.110
and our World Cup
application on both.

00:08:38.110 --> 00:08:40.830
So first, we receive a
message which Italy scored.

00:08:40.830 --> 00:08:46.070
And we put the notification on
the system tray of our devices.

00:08:46.070 --> 00:08:47.340
And this is the code.

00:08:47.340 --> 00:08:50.210
On the broadcast receiver,
we get the message.

00:08:50.210 --> 00:08:51.530
We look inside the message.

00:08:51.530 --> 00:08:54.640
We see the text, Italy
one, England zero.

00:08:54.640 --> 00:08:56.970
And we get the identifier,
which is unique.

00:08:56.970 --> 00:09:00.120
So we built a notification
with the notification manager.

00:09:00.120 --> 00:09:04.900
And we pop it on the
notification tray.

00:09:04.900 --> 00:09:08.000
Now I'm closer to my phone,
and I look at the notification

00:09:08.000 --> 00:09:08.910
right there.

00:09:08.910 --> 00:09:11.030
So what I do, I act on it.

00:09:11.030 --> 00:09:13.370
And what we need to do is
send an upstream message

00:09:13.370 --> 00:09:16.850
to dismiss the notification.

00:09:16.850 --> 00:09:19.720
Here we are building a message.

00:09:19.720 --> 00:09:21.980
We grab the notification ID.

00:09:21.980 --> 00:09:24.520
We set the action
to be dismissal.

00:09:24.520 --> 00:09:27.420
And we address it to the
user, to the notification key,

00:09:27.420 --> 00:09:29.880
which is the identity of
the user for our World Cup

00:09:29.880 --> 00:09:31.620
application.

00:09:31.620 --> 00:09:33.930
The GCM does the rest.

00:09:33.930 --> 00:09:36.060
It gets the message and
delivers it to the tablet.

00:09:39.150 --> 00:09:41.930
And now just like before, the
tablet receives the message

00:09:41.930 --> 00:09:45.639
from the broadcast receiver,
sees the notification ID,

00:09:45.639 --> 00:09:47.305
and just call
NotifcationManager.Cancel.

00:09:50.390 --> 00:09:55.046
It is really simple,
and yet very powerful.

00:09:55.046 --> 00:09:58.260
But upstream messaging,
just as the name suggests,

00:09:58.260 --> 00:10:00.070
lets us do more.

00:10:00.070 --> 00:10:03.970
We can send messages
back out to our server

00:10:03.970 --> 00:10:06.780
by using the GCM infrastructure.

00:10:06.780 --> 00:10:08.460
For example, we
could say, hey, we

00:10:08.460 --> 00:10:12.730
want to follow the next
match, USA versus Portugal.

00:10:12.730 --> 00:10:14.500
And upstream messaging
is very useful

00:10:14.500 --> 00:10:17.150
because it persists
the message for us.

00:10:17.150 --> 00:10:20.590
Once we give it to GCM,
even if there is no network,

00:10:20.590 --> 00:10:23.090
even if the phone reboots,
the GCM stores it locally.

00:10:23.090 --> 00:10:27.200
So as soon as it has a chance
to send it, it will do that.

00:10:27.200 --> 00:10:29.180
But for this to work,
the World Cup server

00:10:29.180 --> 00:10:33.140
needs to be connected to GCM.

00:10:33.140 --> 00:10:35.350
And today, we are going
to launch for everybody

00:10:35.350 --> 00:10:40.460
a new service, which is the
Cloud Connection Service.

00:10:40.460 --> 00:10:42.620
With this service, we
allow you to open up

00:10:42.620 --> 00:10:46.220
to 100 parallel persisting
connections with the XMPP

00:10:46.220 --> 00:10:47.570
protocol to GCM.

00:10:47.570 --> 00:10:50.890
And you can stream messages
through these 100 connections

00:10:50.890 --> 00:10:51.820
as fast as you can.

00:10:54.910 --> 00:10:59.200
So the World Cup server opens
this XMPP connection to GCM.

00:10:59.200 --> 00:11:02.290
And it authenticates with a
classic PROJECT_ID and API_Key.

00:11:04.820 --> 00:11:08.270
Now, if our Chrome
applications want

00:11:08.270 --> 00:11:11.020
to send the message back
to the World Cup server

00:11:11.020 --> 00:11:16.380
saying we want to follow the
match between Portugal and US,

00:11:16.380 --> 00:11:18.640
then all we need to do
is to pack a message

00:11:18.640 --> 00:11:21.030
and address it to
the PROJECT_ID, which

00:11:21.030 --> 00:11:24.169
is the user that the
World Cup server used

00:11:24.169 --> 00:11:25.460
to authenticate the connection.

00:11:29.790 --> 00:11:32.780
And that's all you
need to do, because GCM

00:11:32.780 --> 00:11:35.000
will look through the pool
of healthy connections

00:11:35.000 --> 00:11:37.980
from our World Cup server and
will pick one randomly and send

00:11:37.980 --> 00:11:41.490
a message to that server.

00:11:41.490 --> 00:11:43.640
Now sometimes, we might
need to drain a connection.

00:11:43.640 --> 00:11:45.770
And we want to do that
in a graceful way.

00:11:45.770 --> 00:11:49.080
So if you receive
such a message,

00:11:49.080 --> 00:11:51.280
connection draining,
then all you need to do

00:11:51.280 --> 00:11:54.760
is to stop sending new messages,
let the in flight messages

00:11:54.760 --> 00:11:57.960
complete, then close the
connection and open a new one.

00:12:01.320 --> 00:12:03.580
So now you can stream
all these messages

00:12:03.580 --> 00:12:05.270
over these 100 connections.

00:12:05.270 --> 00:12:08.160
And GCM eventually is
going to deliver them.

00:12:08.160 --> 00:12:10.540
And I'm saying eventually
because as you all know,

00:12:10.540 --> 00:12:13.920
devices go online and
offline at all times.

00:12:13.920 --> 00:12:17.370
In fact, it will be really
useful to know sometimes

00:12:17.370 --> 00:12:20.640
for some use cases
when actually GCM

00:12:20.640 --> 00:12:25.090
sent a message to
a specific device.

00:12:25.090 --> 00:12:26.695
So let me introduce
a brand new API

00:12:26.695 --> 00:12:28.700
that we launched
for everybody today

00:12:28.700 --> 00:12:31.410
which is GCM Delivery Receipt.

00:12:35.690 --> 00:12:38.100
What this API does for you
is that when the World Cup

00:12:38.100 --> 00:12:41.230
server sends a
message to GCM, let's

00:12:41.230 --> 00:12:43.540
assume that our browser
is disconnected for now.

00:12:43.540 --> 00:12:45.750
As soon as the World Cup
application in Chrome

00:12:45.750 --> 00:12:48.930
connects to GCM, then
we deliver the message.

00:12:48.930 --> 00:12:52.980
And then we send the receipt
back to the World Cup server.

00:12:52.980 --> 00:12:56.700
And the way you activate
this API is very simple.

00:12:56.700 --> 00:12:58.270
When you send a
message, you just

00:12:58.270 --> 00:13:02.135
specify that you want
to have a receipt.

00:13:02.135 --> 00:13:05.140
And if you do so, the
receipt message you get back

00:13:05.140 --> 00:13:06.970
looks like this one.

00:13:06.970 --> 00:13:10.710
We tell you which device
we sent the message to,

00:13:10.710 --> 00:13:13.390
specify by the registration
ID, and the timestamp

00:13:13.390 --> 00:13:16.870
when we sent the message.

00:13:16.870 --> 00:13:20.120
And because we really care
about this multiscreen world,

00:13:20.120 --> 00:13:21.850
we want to make this
delivery receipt

00:13:21.850 --> 00:13:26.150
work with a user
notification API as well.

00:13:26.150 --> 00:13:29.680
So in the example before,
if you send a message to me,

00:13:29.680 --> 00:13:36.520
to the user, now GCM will send
a receipt back for every message

00:13:36.520 --> 00:13:39.190
and for every device we
deliver this message to.

00:13:39.190 --> 00:13:41.670
So if Chrome connects
first, we send a receipt

00:13:41.670 --> 00:13:44.285
with a registration ID of
the Chrome application.

00:13:44.285 --> 00:13:47.464
As soon as Android connects,
we do the same for my phone

00:13:47.464 --> 00:13:48.630
and then for the TV as well.

00:13:52.250 --> 00:13:55.330
It is important to note
the delivery receipt,

00:13:55.330 --> 00:13:58.260
it works at the
GCM protocol level.

00:13:58.260 --> 00:14:01.380
So in an example could be I
want to send a private message

00:14:01.380 --> 00:14:03.700
to my friend in London
that Italy scored.

00:14:03.700 --> 00:14:06.560
And he will be notified when the
message is sent to his device.

00:14:06.560 --> 00:14:10.140
I want to make sure he is
actually watching the game.

00:14:10.140 --> 00:14:12.610
For that, this is the best API.

00:14:12.610 --> 00:14:17.110
But then we also want to know
if my friend read the message.

00:14:17.110 --> 00:14:20.390
And that's a delivery receipt
at the application level.

00:14:20.390 --> 00:14:25.240
And for that, the best API
is, again, upstream messaging.

00:14:25.240 --> 00:14:28.580
In fact, upstream
messaging is a great API

00:14:28.580 --> 00:14:30.720
for all sorts of
ephemeral messages,

00:14:30.720 --> 00:14:33.710
like the user presence
in a conversation

00:14:33.710 --> 00:14:36.920
leaves for an instant
messaging application.

00:14:36.920 --> 00:14:40.980
And not only because we do
persistency for the messages,

00:14:40.980 --> 00:14:43.680
not only because we take away
the network troubles for you,

00:14:43.680 --> 00:14:47.230
but also we give GCM a
chance to batch messages

00:14:47.230 --> 00:14:50.010
together and save battery life.

00:14:50.010 --> 00:14:53.270
If many applications sends
messages upstream using GCM,

00:14:53.270 --> 00:14:55.680
then GCM can collect
them together.

00:14:55.680 --> 00:14:58.600
And mind that every time
we wake up the radio,

00:14:58.600 --> 00:15:01.550
we consume battery life.

00:15:01.550 --> 00:15:05.620
In fact, there are other
sorts of network calls,

00:15:05.620 --> 00:15:08.820
all the background
network calls that are

00:15:08.820 --> 00:15:10.870
great to be able
to batch together.

00:15:10.870 --> 00:15:12.250
For example, if
your application,

00:15:12.250 --> 00:15:15.010
if our World Cup application
wants to upload logs

00:15:15.010 --> 00:15:19.200
and statistics, we don't
need to do that in real time.

00:15:19.200 --> 00:15:21.260
We can say something
like, schedule

00:15:21.260 --> 00:15:25.080
me to run in the next
hour and upload my logs.

00:15:25.080 --> 00:15:28.430
So these kind of calls are
perfect to be collected

00:15:28.430 --> 00:15:32.010
and batched together so that we
can wake up the radio only one

00:15:32.010 --> 00:15:35.380
times instead of multiple times.

00:15:35.380 --> 00:15:37.940
So today, let me
introduce a new service

00:15:37.940 --> 00:15:40.290
that will let us
do exactly this.

00:15:40.290 --> 00:15:44.930
That's Google Cloud
Messaging Network Manager.

00:15:44.930 --> 00:15:47.260
And the APIs for this new
service are really simple.

00:15:47.260 --> 00:15:49.390
There are two main APIs.

00:15:49.390 --> 00:15:52.180
The first, you can
schedule a task

00:15:52.180 --> 00:15:54.450
and you specify a time window.

00:15:54.450 --> 00:15:58.080
For example, the example
before, I ran my upload

00:15:58.080 --> 00:16:00.730
in the next hour,
whenever you want to.

00:16:00.730 --> 00:16:02.650
And then you can
schedule periodic tasks.

00:16:02.650 --> 00:16:06.750
You can say, hey, run my stats
upload every three hours,

00:16:06.750 --> 00:16:10.100
but run me only in the first 20
minutes of each of those three

00:16:10.100 --> 00:16:12.770
hours period.

00:16:12.770 --> 00:16:16.500
And this is a code example
for exactly this use case.

00:16:16.500 --> 00:16:18.800
And so now we have
those 20 minutes

00:16:18.800 --> 00:16:21.980
to be able to batch
things together.

00:16:21.980 --> 00:16:24.620
For example, we are
receiving different tasks

00:16:24.620 --> 00:16:26.724
from different applications.

00:16:26.724 --> 00:16:28.140
But Network Manager
does something

00:16:28.140 --> 00:16:31.330
even smarter-- it
listens to other signals.

00:16:31.330 --> 00:16:36.590
So in this case, even if we
have five more minutes to wait,

00:16:36.590 --> 00:16:40.842
GCM sends a message that Italy
scored and wakes up the radio.

00:16:40.842 --> 00:16:42.300
So the Network
Manager might decide

00:16:42.300 --> 00:16:45.870
this is the right time
to run all those tasks.

00:16:45.870 --> 00:16:48.230
And instead of waking
up the radio five times,

00:16:48.230 --> 00:16:49.390
now we did it only once.

00:16:49.390 --> 00:16:52.596
But piggybacking on the
message from the cloud.

00:16:55.320 --> 00:16:57.850
And in fact, to maximize the
chances for Network Manager

00:16:57.850 --> 00:17:01.100
to do the best it can
to save battery life,

00:17:01.100 --> 00:17:04.000
in the previous example the
best would have been to say,

00:17:04.000 --> 00:17:07.099
schedule me to run every
three hours whenever

00:17:07.099 --> 00:17:08.960
you want during that
three hours period.

00:17:11.650 --> 00:17:15.790
So Network Manager is great
because it persists our tasks.

00:17:15.790 --> 00:17:18.530
If our application gets killed,
we wake up the application

00:17:18.530 --> 00:17:21.030
when we need to run your task.

00:17:21.030 --> 00:17:23.375
And same goes if device reboots.

00:17:23.375 --> 00:17:26.210
It also takes care of
network issues for us.

00:17:26.210 --> 00:17:28.369
It does retries in
case of flakiness.

00:17:28.369 --> 00:17:30.630
If the job fails, it
will retry for us.

00:17:30.630 --> 00:17:35.300
If the server is busy, it will
do exponential back off for us.

00:17:35.300 --> 00:17:38.070
And plus, it will try to
do the smart things to save

00:17:38.070 --> 00:17:39.580
as much battery life as you can.

00:17:43.270 --> 00:17:45.860
So let's check what
we have seen so far.

00:17:45.860 --> 00:17:48.670
We first introduced
GCM for Chrome.

00:17:48.670 --> 00:17:50.920
Now we can target
our application

00:17:50.920 --> 00:17:53.950
on any Android device and on
any Chrome browser and Chrome OS

00:17:53.950 --> 00:17:55.580
machine.

00:17:55.580 --> 00:18:00.980
And you can read more at
developer.chrome.com/apps/gcm.

00:18:00.980 --> 00:18:03.430
And there is also an I/O
Bytes recording on YouTube

00:18:03.430 --> 00:18:05.990
from Phillip, one of
the engineers behind GCM

00:18:05.990 --> 00:18:08.550
for Chrome.

00:18:08.550 --> 00:18:13.110
Then we introduced
four new APIs.

00:18:13.110 --> 00:18:14.990
The User Notification
that lets you

00:18:14.990 --> 00:18:17.960
target the user so that
GCM sends the message

00:18:17.960 --> 00:18:19.480
to all of its devices.

00:18:19.480 --> 00:18:21.890
The upstream
messaging that lets us

00:18:21.890 --> 00:18:25.020
synchronize
notification dismissal.

00:18:25.020 --> 00:18:27.035
The Cloud Connection
Server that let us

00:18:27.035 --> 00:18:31.480
stream messages up to
100 parallel connections.

00:18:31.480 --> 00:18:34.840
And delivery receipt that inform
our server when we actually

00:18:34.840 --> 00:18:36.380
send a message to
a given device.

00:18:39.290 --> 00:18:41.590
And finally, we introduced
the Network Manager.

00:18:41.590 --> 00:18:43.540
We peaked a little
bit in the future.

00:18:43.540 --> 00:18:47.370
Because even if this service
is not rolled out yet,

00:18:47.370 --> 00:18:49.220
it's part of the
Play Services API.

00:18:49.220 --> 00:18:51.330
So as soon as we're
going to roll it out,

00:18:51.330 --> 00:18:54.260
it'll be present on any
device that is GCM capable.

00:18:57.850 --> 00:18:59.570
So communications.

00:18:59.570 --> 00:19:03.790
Communication across users and
communication across devices.

00:19:03.790 --> 00:19:06.290
You've seen how we
can target the user

00:19:06.290 --> 00:19:08.810
and reach it on all of the
screens for our World Cup

00:19:08.810 --> 00:19:12.490
application by just giving
the mapping between a user

00:19:12.490 --> 00:19:17.570
account and all the
registration IDs to GCM.

00:19:17.570 --> 00:19:20.080
And GCM creates the
notification key,

00:19:20.080 --> 00:19:22.831
which is the identity of
the user for our World Cup

00:19:22.831 --> 00:19:23.330
application.

00:19:26.470 --> 00:19:29.340
An identity is a
great concept and let

00:19:29.340 --> 00:19:31.500
us do really cool stuff.

00:19:31.500 --> 00:19:34.790
For example, if we address
a message to an identity,

00:19:34.790 --> 00:19:37.420
to a user, to me
right now, it's great

00:19:37.420 --> 00:19:40.330
if you can send this message to
my watch, my phone, and maybe

00:19:40.330 --> 00:19:42.697
my Chrome tablet here.

00:19:42.697 --> 00:19:44.280
But you should leave
my tablet at home

00:19:44.280 --> 00:19:47.614
alone because there's no need
to waste its battery over there,

00:19:47.614 --> 00:19:50.280
because there's no chance for me
to read the message right there

00:19:50.280 --> 00:19:51.360
right now.

00:19:51.360 --> 00:19:53.730
And identity let us
do even cooler stuff.

00:19:53.730 --> 00:19:55.720
We have seen on the
keynote in other sessions

00:19:55.720 --> 00:19:58.430
that by having
the watch with me,

00:19:58.430 --> 00:20:00.890
I can keep my phone unlocked.

00:20:00.890 --> 00:20:04.200
And by having my phone
unlocked in my pocket,

00:20:04.200 --> 00:20:06.410
it can tell the surrounding
devices with my account

00:20:06.410 --> 00:20:07.720
that it's me.

00:20:07.720 --> 00:20:10.410
So if I walk towards
my Chrome machine,

00:20:10.410 --> 00:20:12.230
it can keep my Chrome
machine unlocked

00:20:12.230 --> 00:20:13.729
as long as we have
the same account.

00:20:16.380 --> 00:20:19.090
And Google provides us
with a very simple way

00:20:19.090 --> 00:20:22.630
to log in our users in
our World Cup application

00:20:22.630 --> 00:20:25.390
with a Google account.

00:20:25.390 --> 00:20:28.210
And this is not just
great because we

00:20:28.210 --> 00:20:30.340
don't have to invent or
implement the whole account

00:20:30.340 --> 00:20:34.670
system, but also because
the majority of users

00:20:34.670 --> 00:20:38.280
that have Android devices
that are capable of GCM

00:20:38.280 --> 00:20:41.090
already have a
Google account in it.

00:20:41.090 --> 00:20:45.440
So when our user click on
our World Cup application,

00:20:45.440 --> 00:20:47.820
then we can automatically
log the user in.

00:20:47.820 --> 00:20:51.460
No speed bumps for
sign ups, no passwords.

00:20:51.460 --> 00:20:54.830
And then we can bring the login
information back to our servers

00:20:54.830 --> 00:20:59.780
if we want to by just
creating an identity token.

00:20:59.780 --> 00:21:01.451
We call the
GoogleAuthUtil.getToken.

00:21:01.451 --> 00:21:02.450
We pass the accountName.

00:21:02.450 --> 00:21:04.450
And the account name is
exactly the same account

00:21:04.450 --> 00:21:09.750
we just used to sign
the Google user in.

00:21:09.750 --> 00:21:15.450
And identity's a key concept
behind synchronization as well.

00:21:15.450 --> 00:21:17.990
Let's imagine that we want
to add this functionality

00:21:17.990 --> 00:21:19.430
to our World Cup application.

00:21:19.430 --> 00:21:22.580
We want to let our
user specify which

00:21:22.580 --> 00:21:25.760
is their favorite team, which
is their favorite player,

00:21:25.760 --> 00:21:27.480
and also set some reminders.

00:21:27.480 --> 00:21:30.490
For example, the next
match I'm interested in

00:21:30.490 --> 00:21:31.630
is about to start.

00:21:31.630 --> 00:21:35.550
So remind me that I
need to buy some beer.

00:21:35.550 --> 00:21:37.920
To build this, let
me introduce the all

00:21:37.920 --> 00:21:40.590
new Google Cloud Save APIs.

00:21:43.430 --> 00:21:46.490
Google Cloud Save let us
store data in the cloud

00:21:46.490 --> 00:21:48.690
and synchronize it
across all the users end

00:21:48.690 --> 00:21:52.600
points as they go
online and offline.

00:21:52.600 --> 00:21:54.940
And the data you store
is owned by you, just

00:21:54.940 --> 00:21:58.320
like if you store it
in your own server.

00:21:58.320 --> 00:22:02.180
The synchronization
is powered by GCM,

00:22:02.180 --> 00:22:04.120
and it has full offline support.

00:22:04.120 --> 00:22:06.470
So we don't need to
take care of the radio.

00:22:06.470 --> 00:22:10.370
And APIs are really,
really simple.

00:22:10.370 --> 00:22:14.110
You can save, delete, and
query the data of your users.

00:22:14.110 --> 00:22:18.550
And if you need to, you
can also force the sync.

00:22:18.550 --> 00:22:21.590
And the way you use this is
just by telling the Google API

00:22:21.590 --> 00:22:23.930
client that you want
to add a new API, which

00:22:23.930 --> 00:22:26.100
is the Cloud Save Manager API.

00:22:26.100 --> 00:22:28.750
And here you pass the
account that we just

00:22:28.750 --> 00:22:31.009
used to sign our user
in, the Google account.

00:22:35.500 --> 00:22:40.150
The main storage concept behind
Google Cloud Save is an entity.

00:22:40.150 --> 00:22:43.226
And an entity is comprised
of a kind and of a name.

00:22:43.226 --> 00:22:46.220
And you can think of a kind
as the table in your database

00:22:46.220 --> 00:22:48.790
and the name as the
value of a primary care.

00:22:48.790 --> 00:22:51.390
And now it gets really powerful,
because you can dynamically

00:22:51.390 --> 00:22:57.430
add column to each table in
the form of key value pairs.

00:22:57.430 --> 00:23:00.250
So back to our
example, if you want

00:23:00.250 --> 00:23:02.826
to let a user specify
what's their favorite team

00:23:02.826 --> 00:23:04.200
and what's their
favorite player,

00:23:04.200 --> 00:23:07.150
we create an entity
whose kind is Preference.

00:23:07.150 --> 00:23:08.090
The name is team.

00:23:08.090 --> 00:23:09.850
And now we add the properties.

00:23:09.850 --> 00:23:11.920
Country Italy and the
goal keeper is Buffon.

00:23:14.980 --> 00:23:17.729
There is an in depth session
tomorrow about the simplicity

00:23:17.729 --> 00:23:19.520
and the power of the
cloud save APIs, which

00:23:19.520 --> 00:23:22.700
I suggest you to attend from
[? Justin ?] and Manfred.

00:23:22.700 --> 00:23:25.900
But for now, let's
see what we have.

00:23:25.900 --> 00:23:29.220
Now, we build an application
that can log in a user

00:23:29.220 --> 00:23:31.750
it with the Google identity.

00:23:31.750 --> 00:23:34.720
They can store some
data in the cloud.

00:23:34.720 --> 00:23:37.990
They can synchronize this
data across our devices.

00:23:37.990 --> 00:23:39.880
For example, if
we're on a tablet.

00:23:39.880 --> 00:23:43.197
And it can remind us that
it's time to buy some beer.

00:23:43.197 --> 00:23:45.280
And we can do all this
without spending or writing

00:23:45.280 --> 00:23:49.140
a single line of
code up in the cloud.

00:23:49.140 --> 00:23:52.830
As you can see, we have,
again, multiple notifications

00:23:52.830 --> 00:23:54.830
and we want to dismiss them.

00:23:54.830 --> 00:23:57.540
And because we are using
the Google identity,

00:23:57.540 --> 00:24:01.380
even dismissal of
notification gets simpler.

00:24:01.380 --> 00:24:05.390
Now, we don't need a server to
dismiss these notifications,

00:24:05.390 --> 00:24:08.860
because we can use the user
notification API in combination

00:24:08.860 --> 00:24:10.592
with a Google identity.

00:24:10.592 --> 00:24:14.060
And here is how it works.

00:24:14.060 --> 00:24:17.780
When we first install our
application on a phone

00:24:17.780 --> 00:24:21.515
and our World Cup application
tells GCM, hey, add this user,

00:24:21.515 --> 00:24:24.380
this Google account,
this Google identity

00:24:24.380 --> 00:24:28.550
to the notification key and
this is my registration ID.

00:24:28.550 --> 00:24:31.170
But GCM doesn't have a
notification key yet.

00:24:31.170 --> 00:24:34.160
So it creates one for
this Google account

00:24:34.160 --> 00:24:36.990
and adds the registration ID
for our World Cup application

00:24:36.990 --> 00:24:38.890
on that form.

00:24:38.890 --> 00:24:42.000
Now as the user installs the
application on more devices,

00:24:42.000 --> 00:24:45.640
for example the tablet, the
tablet does the same thing.

00:24:45.640 --> 00:24:48.590
Say hey, add this Google
account to the notification key

00:24:48.590 --> 00:24:51.130
and this is my registration ID.

00:24:51.130 --> 00:24:52.960
Now GCM has the
notification key.

00:24:52.960 --> 00:24:58.770
It just simply adds the
device to the group.

00:24:58.770 --> 00:25:00.310
So back to your
application now, we

00:25:00.310 --> 00:25:03.650
can simply dismiss
the beer reminder,

00:25:03.650 --> 00:25:05.400
just as we've seen in
the previous slides.

00:25:09.280 --> 00:25:14.040
So with a Google identity,
Cloud Save, and the user

00:25:14.040 --> 00:25:18.030
notifications API, we have built
a really powerful application

00:25:18.030 --> 00:25:21.800
that let us specify user
preferences, reminders,

00:25:21.800 --> 00:25:23.570
synchronize the
data across devices,

00:25:23.570 --> 00:25:25.560
and synchronize this
missile, and we still

00:25:25.560 --> 00:25:30.450
haven't written a single
line of code in the cloud.

00:25:30.450 --> 00:25:34.960
And all this because Cloud
Save generates a server for us.

00:25:34.960 --> 00:25:36.746
It generates it on
the Google Cloud.

00:25:36.746 --> 00:25:41.040
It generates an App
Engine server for us.

00:25:41.040 --> 00:25:44.130
So now we can stop here, or
we can log in in the cloud

00:25:44.130 --> 00:25:46.950
and do really wonderful things.

00:25:46.950 --> 00:25:50.050
We can go up there, unleash
the power of big data,

00:25:50.050 --> 00:25:52.600
unleash the power of App
Engine, add some code,

00:25:52.600 --> 00:25:55.810
and run analysis and
statistics on our user's data,

00:25:55.810 --> 00:25:57.000
because we own the data.

00:25:57.000 --> 00:25:59.720
We, the developer,
do own the data.

00:25:59.720 --> 00:26:02.860
And because we have a
server now, we can add APIs.

00:26:02.860 --> 00:26:05.480
So our Chrome Web
application that

00:26:05.480 --> 00:26:08.350
logs our user in with
the same identity

00:26:08.350 --> 00:26:10.160
can act on the cloud save data.

00:26:12.704 --> 00:26:14.620
And now we can add the
original functionality.

00:26:14.620 --> 00:26:18.040
We want to tell the user
when his favorite team

00:26:18.040 --> 00:26:20.330
during the game is scoring.

00:26:20.330 --> 00:26:25.630
So we can use GCM and send the
message to the individual end

00:26:25.630 --> 00:26:33.690
points or use GCM and target
the identity of the user

00:26:33.690 --> 00:26:35.780
so we can reach
him on the screens

00:26:35.780 --> 00:26:38.990
where it matters the most.

00:26:38.990 --> 00:26:42.480
And this is the power of
the Google Mobile Cloud.

00:26:45.110 --> 00:26:46.100
Thank you.

00:26:46.100 --> 00:26:48.962
[APPLAUSE]

00:26:54.329 --> 00:26:56.245
If you have questions,
we can take on the mic.

00:27:12.767 --> 00:27:13.600
AUDIENCE: Thank you.

00:27:13.600 --> 00:27:16.190
So [INAUDIBLE] the
offline message.

00:27:16.190 --> 00:27:18.660
So if your
application's not online

00:27:18.660 --> 00:27:21.550
and you send a notification,
will this message

00:27:21.550 --> 00:27:25.250
get delivered when
the user gets online?

00:27:25.250 --> 00:27:30.120
FRENCESCO NERIERI: So in
GCM, if the device where

00:27:30.120 --> 00:27:31.630
the application is is offline?

00:27:31.630 --> 00:27:32.020
AUDIENCE: Right.

00:27:32.020 --> 00:27:33.144
So you have multiple users.

00:27:33.144 --> 00:27:37.710
And one user
distributed the message.

00:27:37.710 --> 00:27:41.660
But you have one
device not online.

00:27:41.660 --> 00:27:45.290
Maybe like when you send out a
notification, it's not online.

00:27:45.290 --> 00:27:47.610
But later on, it gets
online, will this message

00:27:47.610 --> 00:27:49.924
become an offline message?

00:27:49.924 --> 00:27:51.840
FRENCESCO NERIERI: So
if you have two devices.

00:27:51.840 --> 00:27:53.214
One is online and
one is offline.

00:27:53.214 --> 00:27:56.510
And you target the user,
so GCM sends to both.

00:27:56.510 --> 00:27:58.840
You send the message
to the online device.

00:27:58.840 --> 00:28:01.170
As soon as the second
device gets online, then

00:28:01.170 --> 00:28:02.940
we deliver the
message there as well.

00:28:02.940 --> 00:28:05.072
AUDIENCE: So you cache
the message on server?

00:28:05.072 --> 00:28:06.780
FRENCESCO NERIERI:
Yes, unless-- so there

00:28:06.780 --> 00:28:10.100
is a feature on GCM that
is called Time to Live.

00:28:10.100 --> 00:28:13.300
You can specify an amount of
time before a message expires.

00:28:13.300 --> 00:28:16.500
And if you set the
time to live to zero,

00:28:16.500 --> 00:28:19.301
when we receive the message
if the device is offline,

00:28:19.301 --> 00:28:20.550
then we just drop the message.

00:28:20.550 --> 00:28:22.270
We'll never see it.

00:28:22.270 --> 00:28:24.130
Otherwise, we store
it in the cloud

00:28:24.130 --> 00:28:25.925
until the device comes online.

00:28:25.925 --> 00:28:26.910
AUDIENCE: OK.

00:28:26.910 --> 00:28:27.410
Thanks.

00:28:35.040 --> 00:28:37.730
AUDIENCE: The Cloud Save seems
like a really simple function

00:28:37.730 --> 00:28:40.310
to add.

00:28:40.310 --> 00:28:43.080
Say I incorporate
that into my app.

00:28:43.080 --> 00:28:46.720
Much later, can I access
that data in the cloud

00:28:46.720 --> 00:28:49.230
with an app running in the
cloud with functionality running

00:28:49.230 --> 00:28:51.232
in the cloud to do new
things to that data?

00:28:51.232 --> 00:28:52.190
FRENCESCO NERIERI: Yes.

00:28:52.190 --> 00:28:55.570
So Cloud Save has the
account counterpart

00:28:55.570 --> 00:28:56.850
that has its own APIs.

00:28:56.850 --> 00:28:59.990
Not only you can access
it through the App Engine

00:28:59.990 --> 00:29:03.270
as you log in up there, but
you can, as I was saying,

00:29:03.270 --> 00:29:07.290
you can expose APIs so that
your own server can also

00:29:07.290 --> 00:29:08.374
access the data.

00:29:11.100 --> 00:29:13.330
AUDIENCE: A question
on Cloud Save as well.

00:29:13.330 --> 00:29:18.570
It looks like it's simply a
simplified API for data store.

00:29:18.570 --> 00:29:22.650
So to what level does it expose
the data store functionality?

00:29:22.650 --> 00:29:24.680
And for example, can
I do a transaction?

00:29:24.680 --> 00:29:27.840
Can I implement the
fact even in my app

00:29:27.840 --> 00:29:31.825
I give a token to someone else?

00:29:31.825 --> 00:29:33.200
FRENCESCO NERIERI:
So in Android,

00:29:33.200 --> 00:29:36.860
we try to simplify the APIs as
much as possible to abstract

00:29:36.860 --> 00:29:39.540
the cloud, the
part of the cloud.

00:29:39.540 --> 00:29:43.520
But yes, the API
that we've exposed

00:29:43.520 --> 00:29:46.610
can get more complicated and can
actually do all those things.

00:29:46.610 --> 00:29:48.569
I suggest you do follow
the session tomorrow,

00:29:48.569 --> 00:29:50.110
go in details on
all of these things.

00:29:53.730 --> 00:29:55.610
AUDIENCE: So it sounded
like Cloud Save does

00:29:55.610 --> 00:29:58.345
stuff where it would
sync if it was offline,

00:29:58.345 --> 00:30:00.220
and then when it comes
online, it would sync.

00:30:00.220 --> 00:30:01.730
How do you deal with
conflicts, like if you

00:30:01.730 --> 00:30:03.620
had saved the same thing
on two different devices?

00:30:03.620 --> 00:30:05.078
FRENCESCO NERIERI:
So we have a way

00:30:05.078 --> 00:30:07.680
to deal with conflict
resolution, which

00:30:07.680 --> 00:30:09.010
is a simple way.

00:30:09.010 --> 00:30:11.010
We give you back
the basic entity--

00:30:11.010 --> 00:30:13.800
the remote and the local entity.

00:30:13.800 --> 00:30:16.164
And then you'll
extend the function.

00:30:16.164 --> 00:30:17.830
And then you just
deal with the conflict

00:30:17.830 --> 00:30:19.610
and give us back the
results so we just

00:30:19.610 --> 00:30:21.980
synchronize with the cloud.

00:30:21.980 --> 00:30:25.780
AUDIENCE: Is Google Cloud
Save free to use like the GCM?

00:30:30.200 --> 00:30:32.780
FRENCESCO NERIERI: The terms on
this are still to be decided.

00:30:32.780 --> 00:30:33.321
AUDIENCE: OK.

00:30:35.834 --> 00:30:38.000
FRENCESCO NERIERI: I can't
speculate on that, sorry.

00:30:40.940 --> 00:30:43.400
AUDIENCE: Is the concept of
users tied to Google accounts,

00:30:43.400 --> 00:30:46.360
or can it be local users as
well in your application?

00:30:46.360 --> 00:30:50.556
Like outside of using-- so is it
tied to Google accounts, or is

00:30:50.556 --> 00:30:52.060
it can be separate?

00:30:52.060 --> 00:30:53.900
FRENCESCO NERIERI:
For Cloud Save?

00:30:53.900 --> 00:30:56.334
AUDIENCE: No, not the Cloud
Save, but for user messaging.

00:30:56.334 --> 00:30:58.750
FRENCESCO NERIERI: Yeah, so
the user notification actually

00:30:58.750 --> 00:31:00.230
allows you to do both.

00:31:00.230 --> 00:31:03.144
You can use the Google
identity or your own account.

00:31:03.144 --> 00:31:03.894
AUDIENCE: Perfect.

00:31:03.894 --> 00:31:04.394
Thank you.

00:31:08.832 --> 00:31:10.040
FRENCESCO NERIERI: Thank you.

00:31:10.040 --> 00:31:13.970
I'll be at the Android booth if
you guys have more questions.

00:31:13.970 --> 00:31:15.520
[APPLAUSE]

