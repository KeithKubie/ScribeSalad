WEBVTT
Kind: captions
Language: en

00:00:01.996 --> 00:00:43.912
[MUSIC PLAYING]

00:00:51.940 --> 00:00:52.925
STEVE BAZYL: Hi everyone.

00:00:52.925 --> 00:00:55.740
Thanks for joining today's
Google Developers Live.

00:00:55.740 --> 00:00:59.150
Today we have two special
guests, Brian and Cheryl from

00:00:59.150 --> 00:01:02.900
the Drive SDK engineering team
from Boulder, Colorado.

00:01:02.900 --> 00:01:05.950
And today we're going to talk
about the Real Time API that

00:01:05.950 --> 00:01:08.370
we've released just a
couple of weeks ago.

00:01:08.370 --> 00:01:11.950
And I got a bunch of questions
from the Google Drive

00:01:11.950 --> 00:01:13.970
developers community
about the API.

00:01:13.970 --> 00:01:17.730
And today is when those
questions will get answered.

00:01:17.730 --> 00:01:20.900
So Brian and Cheryl, can you
just give yourself a quick

00:01:20.900 --> 00:01:21.510
introduction?

00:01:21.510 --> 00:01:24.670
Let people know about
what you've been

00:01:24.670 --> 00:01:27.910
working here on at Google.

00:01:27.910 --> 00:01:29.450
BRIAN CAIRNS: Hi, I'm Brian.

00:01:29.450 --> 00:01:31.610
I'm an engineer on
Drive Real Time.

00:01:31.610 --> 00:01:35.730
And I've been working on Drive
Real Time for actually almost

00:01:35.730 --> 00:01:37.100
18 months now.

00:01:37.100 --> 00:01:40.005
Pretty much since I joined
Google about two years ago.

00:01:40.005 --> 00:01:41.750
CHERYL SIMON: Hi, I'm Cheryl.

00:01:41.750 --> 00:01:44.910
I've been working on the Drive
Real Time for a shorter amount

00:01:44.910 --> 00:01:48.410
of time, since about the
beginning of the year.

00:01:48.410 --> 00:01:51.336
Just helping get it released
to you guys.

00:01:51.336 --> 00:01:52.855
STEVE BAZYL: OK, cool.

00:01:52.855 --> 00:01:55.502
And for those who aren't that
familiar with the API, can you

00:01:55.502 --> 00:02:01.260
just give the 30 second pitch
as to what this API is, why

00:02:01.260 --> 00:02:04.160
did we actually release
this API.

00:02:04.160 --> 00:02:06.080
BRIAN CAIRNS: So I like to
phrase it in terms of two

00:02:06.080 --> 00:02:08.620
things that this
API gives you.

00:02:08.620 --> 00:02:11.430
The two big things are storage
and collaboration.

00:02:11.430 --> 00:02:13.840
We all know when you're writing
a web application that

00:02:13.840 --> 00:02:17.340
dealing with the network and
dealing with having to store

00:02:17.340 --> 00:02:20.580
your state persistently, that's
a complex problem.

00:02:20.580 --> 00:02:22.230
And we solved that for you.

00:02:22.230 --> 00:02:25.400
And then we also give you the
ability to have real-time

00:02:25.400 --> 00:02:29.860
collaboration that works just
like it does in all the other

00:02:29.860 --> 00:02:33.250
Google Docs editors, Doc
Sheets and Slides.

00:02:33.250 --> 00:02:37.180
So if those are things that
interest you, either one, then

00:02:37.180 --> 00:02:39.870
this might be the API for you.

00:02:39.870 --> 00:02:40.560
STEVE BAZYL: Cool.

00:02:40.560 --> 00:02:43.980
And the API as it is now
is a JavaScript API.

00:02:43.980 --> 00:02:48.260
So it's primarily targeted
for web applications.

00:02:48.260 --> 00:02:51.580
We received a lot of interest
from people asking about

00:02:51.580 --> 00:02:55.970
support for other API, other
languages, other platforms,

00:02:55.970 --> 00:02:58.440
such as Dart, Android,
and iOS.

00:02:58.440 --> 00:03:01.250
Are there any tips or advice
for people who want to use

00:03:01.250 --> 00:03:06.170
Bricks I'll say on mobile for
example, or the Realtime API.

00:03:06.170 --> 00:03:11.424
Bricks is internal name for
people who are out there.

00:03:11.424 --> 00:03:13.360
CHERYL SIMON: Yeah, so right
now it's primary

00:03:13.360 --> 00:03:14.920
a JavaScript API.

00:03:14.920 --> 00:03:17.780
But we're hoping in the future
to be able to expand it to

00:03:17.780 --> 00:03:21.505
other languages like Java, which
would allow you to do it

00:03:21.505 --> 00:03:22.111
in Android and iOS.

00:03:22.111 --> 00:03:24.600
That's sort of the
future plan.

00:03:24.600 --> 00:03:27.230
BRIAN CAIRNS: Yeah so are
goals is to have native

00:03:27.230 --> 00:03:29.730
support for Java.

00:03:29.730 --> 00:03:32.460
I can't give any sort of
real timetable on that.

00:03:32.460 --> 00:03:34.670
But it's certainly something
we're working on.

00:03:34.670 --> 00:03:37.180
And then we also a plans
to do a [INAUDIBLE]

00:03:37.180 --> 00:03:38.670
C API.

00:03:38.670 --> 00:03:41.670
Beyond that we don't have
any specific plans.

00:03:41.670 --> 00:03:46.460
But we certainly are happy to
look into any new language if

00:03:46.460 --> 00:03:48.170
there's enough demand.

00:03:48.170 --> 00:03:51.360
One thing you can do right now,
and this is something

00:03:51.360 --> 00:03:54.870
that a number of developers
actually talked about doing,

00:03:54.870 --> 00:03:57.860
is if you have a platform where
you can run a JavaScript

00:03:57.860 --> 00:04:01.650
engine, it may be possible to
embed the API using the

00:04:01.650 --> 00:04:02.840
JavaScript Edge.

00:04:02.840 --> 00:04:06.310
On Android and iOS you
have web views.

00:04:06.310 --> 00:04:08.590
And we know that there are a
number of developers who are

00:04:08.590 --> 00:04:14.460
trying to sort of combine native
UI with the data stored

00:04:14.460 --> 00:04:17.810
in this web view to get that
kind of capability.

00:04:17.810 --> 00:04:19.670
STEVE BAZYL: That would be an
actually really interesting

00:04:19.670 --> 00:04:23.585
thing to see if people can get
that working really well.

00:04:23.585 --> 00:04:26.120
I suppose you could even do
similar things on the server

00:04:26.120 --> 00:04:28.900
side with the Node
JS for example.

00:04:28.900 --> 00:04:31.160
BRIAN CAIRNS: Yeah, Node is
definitely a good option.

00:04:31.160 --> 00:04:33.930
Our JavaScript API
is not really--

00:04:33.930 --> 00:04:36.250
it doesn't do really any
DOM manipulation.

00:04:36.250 --> 00:04:39.660
So if you have a framework like
Node or something like

00:04:39.660 --> 00:04:43.210
that, as long as it supports
external HTTP requests and

00:04:43.210 --> 00:04:46.720
some fairly standard JavaScript
constructs, there's

00:04:46.720 --> 00:04:48.710
a pretty good chance that
the API will work.

00:04:48.710 --> 00:04:51.350
I mean we don't promise support
outside of browsers

00:04:51.350 --> 00:04:54.440
but we'd certainly like to see
all kinds of interesting

00:04:54.440 --> 00:04:57.100
places to use the API.

00:04:57.100 --> 00:04:59.570
STEVE BAZYL: Yeah, I'm sure
there'll be somebody out there

00:04:59.570 --> 00:05:02.080
who is going to try that
experiment probably not too

00:05:02.080 --> 00:05:03.330
long from now.

00:05:05.280 --> 00:05:07.000
BRIAN CAIRNS: I should add,
sorry, we also have a

00:05:07.000 --> 00:05:15.260
developer who used Dart.

00:05:15.260 --> 00:05:15.990
STEVE BAZYL: I think
this question

00:05:15.990 --> 00:05:16.770
actually came from him.

00:05:16.770 --> 00:05:20.425
This was Adam Singer, who's been
a pretty active member of

00:05:20.425 --> 00:05:23.560
the community, and I know
does a lot with Dart.

00:05:23.560 --> 00:05:27.490
He did a really cool demo of
Dart and the Realtime API.

00:05:27.490 --> 00:05:29.430
BRIAN CAIRNS: So if you're
writing Dart or Type Script,

00:05:29.430 --> 00:05:33.160
or another one of those
languages, even Git, that

00:05:33.160 --> 00:05:38.590
compiles JavaScript, we'd love
to see independent libraries

00:05:38.590 --> 00:05:39.840
if you have something great.

00:05:42.860 --> 00:05:47.780
STEVE BAZYL: So related to this,
I think Adam had also

00:05:47.780 --> 00:05:51.790
asked about whether or not this
API is built on the same

00:05:51.790 --> 00:05:56.080
infrastructure as the Drive API
for example where we have

00:05:56.080 --> 00:05:58.140
discovery documents.

00:05:58.140 --> 00:06:00.430
I think a lot of this was
motivated by could they

00:06:00.430 --> 00:06:03.970
generate their own libraries
for this if they wanted to

00:06:03.970 --> 00:06:07.470
based on discovery?

00:06:07.470 --> 00:06:10.510
CHERYL SIMON: So you can build
on top of the existing API,

00:06:10.510 --> 00:06:14.190
but the way that the
collaboration works, the

00:06:14.190 --> 00:06:17.370
client side logic is a little
more heavyweight than in your

00:06:17.370 --> 00:06:20.580
typical API.

00:06:20.580 --> 00:06:24.290
So you really need to build it
on top of the existing code

00:06:24.290 --> 00:06:25.930
that we provide.

00:06:25.930 --> 00:06:28.070
It would be fairly challenging
to go generate

00:06:28.070 --> 00:06:30.190
your own from scratch.

00:06:30.190 --> 00:06:32.735
BRIAN CAIRNS: Yeah, kind of one
of the requirements in the

00:06:32.735 --> 00:06:38.750
API, and this is really what
precludes just making it a

00:06:38.750 --> 00:06:44.010
rest type API, is that
operations on the data model

00:06:44.010 --> 00:06:46.350
have to be done more or
less synchronously.

00:06:46.350 --> 00:06:50.410
Because there's a whole process,
there's a whole

00:06:50.410 --> 00:06:53.160
transformation process and other
machinery that has to

00:06:53.160 --> 00:06:55.940
work so that your document
doesn't get out of sync.

00:06:55.940 --> 00:07:00.540
And we could build a restful
API, but then your application

00:07:00.540 --> 00:07:04.570
would have to be written kind
in a kind of synchronous,

00:07:04.570 --> 00:07:08.990
serialized way, which of course
no one really wants.

00:07:08.990 --> 00:07:10.240
STEVE BAZYL: Makes
a lot of sense.

00:07:14.490 --> 00:07:18.810
So a little bit different topic,
some of the developers

00:07:18.810 --> 00:07:20.920
have asked about testing.

00:07:20.920 --> 00:07:23.020
How do they--

00:07:23.020 --> 00:07:25.010
especially things like automated
test, integration

00:07:25.010 --> 00:07:26.140
unit tests.

00:07:26.140 --> 00:07:28.420
Are there any tips or strategies
that you would

00:07:28.420 --> 00:07:31.260
suggest to people who are
starting to build apps but

00:07:31.260 --> 00:07:36.160
want to practice good
coding practices?

00:07:36.160 --> 00:07:38.670
BRIAN CAIRNS: Well I know in
the past we've had actually

00:07:38.670 --> 00:07:43.950
internal developers here at
Google builds fake versions of

00:07:43.950 --> 00:07:48.160
the data model that just store
their data in memory.

00:07:48.160 --> 00:07:51.320
And one of the nice things
about the way that the

00:07:51.320 --> 00:07:55.310
Realtime API works is because
these objects look and feel as

00:07:55.310 --> 00:07:59.620
if they are local, it's not
unreasonable to build

00:07:59.620 --> 00:08:02.180
something like that and
sort of swap it out.

00:08:02.180 --> 00:08:05.420
And the dynamic nature of
JavaScript helps a lot with

00:08:05.420 --> 00:08:06.670
something like that.

00:08:09.350 --> 00:08:12.095
If there's a lot of demand for
that, we'd certainly would

00:08:12.095 --> 00:08:14.250
like to see either a third
party library or if there

00:08:14.250 --> 00:08:18.230
isn't a third party library,
certainly suggest it.

00:08:18.230 --> 00:08:21.980
And we'll look at maybe doing
something first party.

00:08:21.980 --> 00:08:23.330
STEVE BAZYL: That'd
be very cool.

00:08:23.330 --> 00:08:23.910
I think you're right.

00:08:23.910 --> 00:08:27.520
This is definitely something
that the community probably

00:08:27.520 --> 00:08:31.090
could build pretty easily given
the API has a fairly

00:08:31.090 --> 00:08:33.306
small footprint.

00:08:33.306 --> 00:08:38.780
So Cheryl, a couple days ago
there was a thread in the

00:08:38.780 --> 00:08:39.970
Google Plus community.

00:08:39.970 --> 00:08:43.530
Somebody was asking about some
list operations and doing

00:08:43.530 --> 00:08:44.720
things like re-ordering.

00:08:44.720 --> 00:08:48.480
And you had given a pretty good
answer there about some

00:08:48.480 --> 00:08:51.510
of the complexities of working
with things like Lists and

00:08:51.510 --> 00:08:58.310
Maps in an eventually consistent
model like what the

00:08:58.310 --> 00:08:59.150
Realtime API gives you.

00:08:59.150 --> 00:09:04.115
You could just give you an
overview of kind of why some

00:09:04.115 --> 00:09:07.990
things that you might take for
granted in a local model just

00:09:07.990 --> 00:09:11.630
aren't quite as easy or might
be a little bit unexpected

00:09:11.630 --> 00:09:15.920
behaviors in a collaborative
environment?

00:09:15.920 --> 00:09:16.120
CHERYL SIMON: Sure.

00:09:16.120 --> 00:09:18.930
So the way that the
collaboration--

00:09:18.930 --> 00:09:20.970
so there are sort of two pieces
to this collaboration.

00:09:20.970 --> 00:09:23.640
One is the fact that for
the user that their

00:09:23.640 --> 00:09:24.960
changes appear instantly.

00:09:24.960 --> 00:09:27.640
So they don't even necessarily
realize that there's a lot of

00:09:27.640 --> 00:09:29.090
network things going on.

00:09:29.090 --> 00:09:32.390
And then we also guarantee
eventual consistency.

00:09:32.390 --> 00:09:35.260
So any changes that happen
locally will eventually make

00:09:35.260 --> 00:09:37.960
it to the server and to all
the other collaborators.

00:09:37.960 --> 00:09:41.060
So those two pieces together,
the way that that's

00:09:41.060 --> 00:09:46.150
accomplished means that some
sort of your standard

00:09:46.150 --> 00:09:50.590
techniques for dealing with
locking or synchronicity don't

00:09:50.590 --> 00:09:53.180
necessarily work in
this environment.

00:09:53.180 --> 00:09:57.170
So it helps to have a little
bit different mindset when

00:09:57.170 --> 00:09:59.870
you're thinking about the data
model and how you make changes

00:09:59.870 --> 00:10:03.300
to guarantee consistency
in your state.

00:10:03.300 --> 00:10:08.210
So the example was if you want
to reorder a list, which ends

00:10:08.210 --> 00:10:11.220
up being sort of an insert
and delete at

00:10:11.220 --> 00:10:12.800
sort of the same time.

00:10:12.800 --> 00:10:16.840
But the problem is that if two
collaborators simultaneously

00:10:16.840 --> 00:10:20.120
try to move where something is
in the list, it's possible

00:10:20.120 --> 00:10:22.870
that things, that you would end
up with duplications in

00:10:22.870 --> 00:10:26.500
your list, or things wouldn't
turn out exactly how you

00:10:26.500 --> 00:10:28.010
expect it to.

00:10:28.010 --> 00:10:30.510
So when you're building this
kind of model, you really need

00:10:30.510 --> 00:10:31.320
to think about--

00:10:31.320 --> 00:10:33.060
there's a lot of trade
offs to be made.

00:10:33.060 --> 00:10:36.560
And you need to think about your
particular use case and

00:10:36.560 --> 00:10:39.520
how you want to trade it off.

00:10:39.520 --> 00:10:42.565
So maybe it's OK if something
ends up in the list twice.

00:10:45.565 --> 00:10:49.650
So one technique to sort of
guarantee that things arrive

00:10:49.650 --> 00:10:53.060
together is to use a
compound operation.

00:10:53.060 --> 00:10:56.090
So within the compound
operation, you do the add and

00:10:56.090 --> 00:10:57.310
you do the remove.

00:10:57.310 --> 00:11:00.570
So then you know that nobody
would ever receive the add and

00:11:00.570 --> 00:11:02.860
then receive the remove
much later.

00:11:02.860 --> 00:11:05.930
But that doesn't guarantee that
you couldn't have two

00:11:05.930 --> 00:11:07.830
adds and removes that
would still end up

00:11:07.830 --> 00:11:08.800
causing some problems.

00:11:08.800 --> 00:11:10.730
So the alternative is
to sort of flip

00:11:10.730 --> 00:11:12.430
your data model around.

00:11:12.430 --> 00:11:17.210
And things that you want to
guarantee happen together you

00:11:17.210 --> 00:11:19.720
have to do in a more
atomic operation.

00:11:19.720 --> 00:11:24.140
So for example setting a value
on a map, everything in the

00:11:24.140 --> 00:11:27.340
value, as long as it's just like
a JSON type, is going to

00:11:27.340 --> 00:11:28.410
be set autonomically.

00:11:28.410 --> 00:11:30.820
So if anybody else set
something, it's going to

00:11:30.820 --> 00:11:32.210
completely override.

00:11:32.210 --> 00:11:34.890
So you can use that in
sort of clever ways

00:11:34.890 --> 00:11:38.060
to guarantee state.

00:11:38.060 --> 00:11:41.670
So in this example, if rather
than having a list, you have a

00:11:41.670 --> 00:11:45.710
map from object to its location,
you can guarantee

00:11:45.710 --> 00:11:49.000
that every object only has
a single location.

00:11:49.000 --> 00:11:52.440
BRIAN CAIRNS: Yet another
option, and I think Cheryl

00:11:52.440 --> 00:11:53.560
sort of addressed
both of these.

00:11:53.560 --> 00:11:56.020
The two that we usually look
at is either you can be

00:11:56.020 --> 00:11:58.950
tolerant of these sort
of degenerate cases.

00:11:58.950 --> 00:12:02.200
And a good example might be you
want to restrict the list

00:12:02.200 --> 00:12:05.600
to only having three
items or less.

00:12:05.600 --> 00:12:08.440
We don't give you the ability
to say, this list must only

00:12:08.440 --> 00:12:10.260
have three items or less.

00:12:10.260 --> 00:12:13.080
And if you try to write that
logic, what ends up happening

00:12:13.080 --> 00:12:18.040
is you'd write something like
block the insert if there are

00:12:18.040 --> 00:12:19.640
three items on the
list already.

00:12:19.640 --> 00:12:22.320
Well if two people try to
insert into the list and

00:12:22.320 --> 00:12:23.640
there's already two items,
you're going

00:12:23.640 --> 00:12:25.650
to end up with four.

00:12:25.650 --> 00:12:28.940
And so this sort of tolerant
model would be, just ignore

00:12:28.940 --> 00:12:32.360
the last item in the list
if you end up with four.

00:12:32.360 --> 00:12:36.020
The other option, and I should
say this sort of tolerant

00:12:36.020 --> 00:12:41.580
option can also be used for
things like, I want a list,

00:12:41.580 --> 00:12:43.650
but I want it to be sorted.

00:12:43.650 --> 00:12:46.420
You can't enforce that a list
has to stay sorted.

00:12:46.420 --> 00:12:49.240
But what you can do is present
a sorted view of

00:12:49.240 --> 00:12:51.130
the list to the user.

00:12:51.130 --> 00:12:55.855
And another option is sort of
this decrease the granularity

00:12:55.855 --> 00:12:57.080
of mutations.

00:12:57.080 --> 00:13:00.020
And JSON values are one
great way to do that.

00:13:00.020 --> 00:13:02.910
Another great way to do that
would be just create a new

00:13:02.910 --> 00:13:07.530
collaborative list and insert
the items that you want into

00:13:07.530 --> 00:13:12.230
that, and then switch out
the list you have

00:13:12.230 --> 00:13:13.730
in the parent element.

00:13:13.730 --> 00:13:17.010
So that guarantees that you
get either one list or the

00:13:17.010 --> 00:13:21.480
other, but never some
combination of the two.

00:13:21.480 --> 00:13:24.990
STEVE BAZYL: That was actually
really helpful information for

00:13:24.990 --> 00:13:28.455
a lot of developers who are
starting to learn this model

00:13:28.455 --> 00:13:29.755
of building applications.

00:13:33.110 --> 00:13:34.600
I'm going to skip over
a couple questions.

00:13:37.270 --> 00:13:42.080
So one question was someone was
wondering about how this

00:13:42.080 --> 00:13:44.720
relates to Wave, whether or
not there's no federation

00:13:44.720 --> 00:13:49.870
models that we're deploying
behind the firewall?

00:13:49.870 --> 00:13:55.270
And a related question around
whether or not this is client

00:13:55.270 --> 00:13:58.120
to client, or client
to server.

00:13:58.120 --> 00:13:59.630
And I was just wondering
if you could

00:13:59.630 --> 00:14:01.175
kind of just address--

00:14:01.175 --> 00:14:02.750
I think we've already touched
on this mostly.

00:14:02.750 --> 00:14:05.820
But if you could just kind of
address some of the basic

00:14:05.820 --> 00:14:12.850
architecture and also just
history around Wave and so on?

00:14:12.850 --> 00:14:14.350
BRIAN CAIRNS: So Wave
of course--

00:14:14.350 --> 00:14:17.400
Wave was the first operational
transformation based product

00:14:17.400 --> 00:14:22.720
we released at Google and was
the first API certainly of an

00:14:22.720 --> 00:14:23.880
operational transformation
based

00:14:23.880 --> 00:14:25.610
product that we released.

00:14:25.610 --> 00:14:29.190
So the real-time collaboration
feature in Wave do share a lot

00:14:29.190 --> 00:14:33.270
of heritage with what we have
in the Realtime API.

00:14:33.270 --> 00:14:36.750
It's unfair to say that
we're built on Wave.

00:14:36.750 --> 00:14:39.890
Because Wave was very different
in many respects.

00:14:39.890 --> 00:14:44.730
It had a lot of more email like
features and embedding

00:14:44.730 --> 00:14:47.930
and things like that
that we don't have.

00:14:47.930 --> 00:14:52.530
So our infrastructure looks
a lot more like what Doc,

00:14:52.530 --> 00:14:55.870
Sheets, and Slides looks like.

00:14:55.870 --> 00:14:57.760
When we say they we're
bringing you the same

00:14:57.760 --> 00:15:00.100
collaborative technology as
Docs, Sheets, and Slides, we

00:15:00.100 --> 00:15:01.750
really do mean that.

00:15:01.750 --> 00:15:05.760
This is very much the same
sort of server and other

00:15:05.760 --> 00:15:07.180
infrastructure that
we use internally

00:15:07.180 --> 00:15:08.980
to build these products.

00:15:08.980 --> 00:15:16.010
And one of the things about this
infrastructure is it's

00:15:16.010 --> 00:15:21.770
sort of focused on client server
interactions on the web

00:15:21.770 --> 00:15:25.380
and even when you're on non
web enabled devices.

00:15:25.380 --> 00:15:29.440
We all know about NAT and
firewalls and all this other

00:15:29.440 --> 00:15:30.550
[INAUDIBLE].

00:15:30.550 --> 00:15:33.560
And so developing a peer to
peer product that works

00:15:33.560 --> 00:15:36.600
consistently and reliably
is really a challenge.

00:15:36.600 --> 00:15:38.900
And so as a result we--

00:15:38.900 --> 00:15:42.380
and because you want persistent
storage--

00:15:42.380 --> 00:15:47.010
we send all of the changes
through our servers and then

00:15:47.010 --> 00:15:51.140
broadcast them out to the
different people who are

00:15:51.140 --> 00:15:54.060
collaborating on the document.

00:15:54.060 --> 00:15:59.350
We'd love to see some
sort of federation.

00:15:59.350 --> 00:16:02.030
Right now there's not really a
standard for how that would

00:16:02.030 --> 00:16:04.500
look or how we would do it.

00:16:04.500 --> 00:16:09.020
And I know that with Wave there
was a lot of work on

00:16:09.020 --> 00:16:14.060
getting federation that I would
say didn't really yield

00:16:14.060 --> 00:16:18.230
the kind of broad acceptance
that we would have

00:16:18.230 --> 00:16:20.980
liked to have seen.

00:16:20.980 --> 00:16:23.900
So if there's a desire for this,
this is something we can

00:16:23.900 --> 00:16:24.500
work on it.

00:16:24.500 --> 00:16:33.030
But right now for better or
worse this is a product that

00:16:33.030 --> 00:16:36.540
is offered as a service and
offered as something that

00:16:36.540 --> 00:16:39.530
Google provides, and not
something that you would host

00:16:39.530 --> 00:16:41.480
on your own servers.

00:16:41.480 --> 00:16:43.850
STEVE BAZYL: Thanks.

00:16:43.850 --> 00:16:47.330
So somebody was asking what are
some good strategies for

00:16:47.330 --> 00:16:49.070
porting an existing app.

00:16:49.070 --> 00:16:51.120
If you already have a JavaScript
application, what

00:16:51.120 --> 00:16:56.490
are things that you
should focus on.

00:16:56.490 --> 00:16:57.753
CHERYL SIMON: The exact sort
of process depends a lot on

00:16:57.753 --> 00:16:58.700
what your applications is.

00:16:58.700 --> 00:17:02.590
But so basically the important
piece that you need to sort of

00:17:02.590 --> 00:17:04.040
inter operate with
the Realtime API

00:17:04.040 --> 00:17:04.920
is your data model.

00:17:04.920 --> 00:17:08.380
And if you already have an
existing data model that is

00:17:08.380 --> 00:17:12.710
built up of JSON objects or
things like that, one way to

00:17:12.710 --> 00:17:14.609
sort of make the switch
over is to make use

00:17:14.609 --> 00:17:16.510
of the custom objects.

00:17:16.510 --> 00:17:20.440
Which allows you to basically
take an existing JavaScript

00:17:20.440 --> 00:17:24.490
object and tie it to the
Realtime data model by just

00:17:24.490 --> 00:17:28.339
registering your type and
marking which fields you want

00:17:28.339 --> 00:17:29.589
to be collaborative.

00:17:32.300 --> 00:17:36.430
Other things we've seen are
people just making use of sort

00:17:36.430 --> 00:17:41.320
of JSON value types and putting
those into the model.

00:17:41.320 --> 00:17:43.970
BRIAN CAIRNS: We should be clear
to distinguish between

00:17:43.970 --> 00:17:45.170
custom types.

00:17:45.170 --> 00:17:47.540
In a custom type, collaboration
is on the

00:17:47.540 --> 00:17:49.040
property level.

00:17:49.040 --> 00:17:52.320
So if you make a custom type and
it has property a, b, and

00:17:52.320 --> 00:17:57.450
c, modifying b and modifying
a, those get processed

00:17:57.450 --> 00:18:01.200
separately and merged together
potentially at the same time.

00:18:01.200 --> 00:18:05.130
With these JSON values, the
entire JSON value is one

00:18:05.130 --> 00:18:06.410
immutable value.

00:18:06.410 --> 00:18:10.250
So if user a changes it and then
user b changes it, you

00:18:10.250 --> 00:18:13.550
see either user a's result or
user b's result, but never a

00:18:13.550 --> 00:18:15.380
merge of the two.

00:18:15.380 --> 00:18:18.570
So that's sort of up to you
to decide which is more

00:18:18.570 --> 00:18:21.410
appropriate for your app.

00:18:21.410 --> 00:18:25.060
STEVE BAZYL: And how important
is just having good

00:18:25.060 --> 00:18:26.080
application architecture.

00:18:26.080 --> 00:18:30.830
I know in our docs, we certainly
stress following any

00:18:30.830 --> 00:18:34.650
of the model view patterns
that are out there.

00:18:37.690 --> 00:18:40.020
How important is it that
developers stick to

00:18:40.020 --> 00:18:42.800
established frameworks or
at least good hygiene?

00:18:42.800 --> 00:18:45.470
CHERYL SIMON: If your model is
cleanly separated from the

00:18:45.470 --> 00:18:47.620
view in the presentation layer,
it's going to make it a

00:18:47.620 --> 00:18:50.060
lot easier for you
to integrate.

00:18:50.060 --> 00:18:52.740
Because it's just such
an independent piece.

00:18:52.740 --> 00:18:56.810
If things are mixed up together,
it can make it a

00:18:56.810 --> 00:18:59.130
little bit more challenging.

00:18:59.130 --> 00:19:01.690
BRIAN CAIRNS: We should add, if
you have a clean separation

00:19:01.690 --> 00:19:08.560
of the model from your
presentation layer, it really

00:19:08.560 --> 00:19:11.990
is a benefit if you want to do
the Drive Realtime API plus

00:19:11.990 --> 00:19:13.920
some other form of storage.

00:19:13.920 --> 00:19:18.160
If you want to support local
storage or you want to have

00:19:18.160 --> 00:19:20.370
the option of storing data on
your own servers or something

00:19:20.370 --> 00:19:26.650
like that, it's certainly
possible to use to Drive

00:19:26.650 --> 00:19:30.230
Realtime API just as your model
layer, and then share

00:19:30.230 --> 00:19:31.870
presentation code across.

00:19:31.870 --> 00:19:35.980
And we have developers who
are already doing that.

00:19:35.980 --> 00:19:39.740
I should say one other thing
that some developers have

00:19:39.740 --> 00:19:43.490
tried with differing results.

00:19:43.490 --> 00:19:49.200
A lot of apps have XML as their
data format and there's

00:19:49.200 --> 00:19:52.150
multiple ways you can
try to do this.

00:19:52.150 --> 00:19:54.420
One thing that the developers
have done with pretty good

00:19:54.420 --> 00:19:57.700
success is sort of break up the
XML into elements and then

00:19:57.700 --> 00:20:01.060
store those elements in
a tree like structure

00:20:01.060 --> 00:20:01.920
in the Drive API.

00:20:01.920 --> 00:20:04.200
And that will work
pretty well.

00:20:04.200 --> 00:20:08.110
One thing that appears to work
well but may not work as well

00:20:08.110 --> 00:20:10.890
as you think it does is just
sticking the XML on a

00:20:10.890 --> 00:20:13.600
collaborative string.

00:20:13.600 --> 00:20:17.520
You get reasonable results as
long as no one collaborates on

00:20:17.520 --> 00:20:20.220
things that are close
together.

00:20:20.220 --> 00:20:23.920
And once you start collaborating
on things close

00:20:23.920 --> 00:20:26.970
together, you can end up with
things like mismatched tags

00:20:26.970 --> 00:20:32.130
and tags that don't have closing
or angular brackets

00:20:32.130 --> 00:20:33.320
and things like that.

00:20:33.320 --> 00:20:36.490
So if that is your model, you
probably have to add some sort

00:20:36.490 --> 00:20:40.530
of validation logic and do extra
work on top of that.

00:20:40.530 --> 00:20:44.510
So if you are XML based, we
definitely recommend you split

00:20:44.510 --> 00:20:49.880
up your XML into a tree
type approach.

00:20:49.880 --> 00:20:52.070
STEVE BAZYL: Great.

00:20:52.070 --> 00:20:54.740
So related to this was somebody
who was asking--

00:20:54.740 --> 00:20:57.020
I think that somebody
was Ali--

00:20:57.020 --> 00:21:01.220
does the Realtime API play well
with existing JavaScript

00:21:01.220 --> 00:21:04.370
frameworks like Angular JS?

00:21:04.370 --> 00:21:06.480
I'll actually answer this one
myself since I've been playing

00:21:06.480 --> 00:21:08.230
a lot with Angular.

00:21:08.230 --> 00:21:12.490
And actually it works really
well together.

00:21:12.490 --> 00:21:14.580
I actually just answered
somebody's question on stack

00:21:14.580 --> 00:21:17.610
overflow yesterday this with
a couple highlights.

00:21:17.610 --> 00:21:20.090
But the one thing I actually
really like about doing it

00:21:20.090 --> 00:21:22.160
with Angular is you don't really
have to worry about any

00:21:22.160 --> 00:21:25.200
of the remote events.

00:21:25.200 --> 00:21:27.340
Basically just having one object
change listener at the

00:21:27.340 --> 00:21:30.600
root of the model and just
telling Angular to go figure

00:21:30.600 --> 00:21:35.300
out what change, what needs to
be re-drawn just makes getting

00:21:35.300 --> 00:21:38.630
all those real-time behaviors
really nice.

00:21:38.630 --> 00:21:40.420
There are some issues like with
collaborative strings are

00:21:40.420 --> 00:21:41.780
a little bit difficult
to work with.

00:21:41.780 --> 00:21:47.640
But actually I'm probably going
to release in a reusable

00:21:47.640 --> 00:21:50.710
snippets or things like findings
and everything to

00:21:50.710 --> 00:21:54.230
make that really easy
for developers.

00:21:54.230 --> 00:22:00.540
Yeah actually I found that it's
very easy to get all the

00:22:00.540 --> 00:22:03.130
cool user features of the
real-time collaboration

00:22:03.130 --> 00:22:06.590
building with Angular, because
of the way it does events and

00:22:06.590 --> 00:22:11.700
the way it does dirty checking
of models and so on.

00:22:11.700 --> 00:22:16.130
Do you guys have any particular
tools or frameworks

00:22:16.130 --> 00:22:17.530
for building any of the samples
that you've been

00:22:17.530 --> 00:22:19.115
working on or do you just
kind of stick--

00:22:19.115 --> 00:22:19.905
[INTERPOSING VOICES]

00:22:19.905 --> 00:22:20.950
BRIAN CAIRNS: I know I've
patched some things together

00:22:20.950 --> 00:22:25.302
with jQuery, which has
worked really nicely.

00:22:25.302 --> 00:22:28.320
You know It's really up
to you what you like.

00:22:28.320 --> 00:22:29.340
We're very careful.

00:22:29.340 --> 00:22:33.550
We don't pollute your name space
with a bunch of junk.

00:22:33.550 --> 00:22:40.260
And because we don't
have UI, there's

00:22:40.260 --> 00:22:43.830
not a lot of direction.

00:22:43.830 --> 00:22:46.030
We're not going to
say you should do

00:22:46.030 --> 00:22:48.350
things x way or y way.

00:22:48.350 --> 00:22:52.640
If you want to use a different
UI framework, or you want to

00:22:52.640 --> 00:22:57.840
use a different JavaScript
framework, that's great.

00:22:57.840 --> 00:23:02.010
We have worked pretty hard to
try to stay close to standard

00:23:02.010 --> 00:23:04.070
JavaScript as you can get.

00:23:04.070 --> 00:23:06.543
CHERYL SIMON: Yeah, I mean our
goal with the API is for it to

00:23:06.543 --> 00:23:09.780
be as lightweight as possible
while still providing the sort

00:23:09.780 --> 00:23:13.590
of the things that the API
is supposed to provide.

00:23:13.590 --> 00:23:16.640
So just as much as possible make
it look like you're just

00:23:16.640 --> 00:23:20.040
working with JavaScript data
objects and events.

00:23:20.040 --> 00:23:23.050
So it should easily tie into
basically any framework that

00:23:23.050 --> 00:23:23.760
you're interested in.

00:23:23.760 --> 00:23:25.590
And I think that people playing
around with it have

00:23:25.590 --> 00:23:27.945
found success so
far doing that.

00:23:27.945 --> 00:23:31.140
BRIAN CAIRNS: And some examples
of where this

00:23:31.140 --> 00:23:35.570
actually shows in the product,
for example our Maps look very

00:23:35.570 --> 00:23:39.200
much like the ECMAscript
6 Harmony Map proposal.

00:23:41.850 --> 00:23:45.110
We worked pretty hard on Lists
to make them work similarly to

00:23:45.110 --> 00:23:46.930
how Arrays work.

00:23:46.930 --> 00:23:50.990
And there's a chance depending
on how tightly you want your

00:23:50.990 --> 00:23:53.230
framework integration to
be, that some of this

00:23:53.230 --> 00:23:54.340
stuff will just work.

00:23:54.340 --> 00:23:56.630
The Event system is
also like this.

00:23:56.630 --> 00:23:58.620
It's very similar to how
DOM Events work.

00:24:02.600 --> 00:24:03.320
STEVE BAZYL: I think we
have only a couple

00:24:03.320 --> 00:24:04.570
more questions left.

00:24:07.250 --> 00:24:11.120
This goes back to an earlier
question about support for

00:24:11.120 --> 00:24:12.640
different languages in API.

00:24:12.640 --> 00:24:14.580
Somebody was asking about
Python and CURL.

00:24:14.580 --> 00:24:17.990
But just kind of a follow up to
that is what about things

00:24:17.990 --> 00:24:19.780
like snapshotting the model.

00:24:19.780 --> 00:24:23.660
So if you just want it on a
server to get a here's the

00:24:23.660 --> 00:24:25.160
current state of what
the model is.

00:24:25.160 --> 00:24:29.580
Is there easy ways to do that
with the Drive API?

00:24:29.580 --> 00:24:33.210
BRIAN CAIRNS: So right now
export is client side only,

00:24:33.210 --> 00:24:35.910
unless you were to get very,
very clever and start doing

00:24:35.910 --> 00:24:39.160
URL hacking.

00:24:39.160 --> 00:24:41.590
We're working on integration
with the Drive API.

00:24:41.590 --> 00:24:44.610
So that you'll be able to
import and export JSide

00:24:44.610 --> 00:24:49.160
versions of the data model
without having to have

00:24:49.160 --> 00:24:50.725
JavaScript or the client
libraries or

00:24:50.725 --> 00:24:52.330
anything like that.

00:24:52.330 --> 00:24:54.730
I should know this is not
really the full API.

00:24:54.730 --> 00:24:59.160
This just a grab a snapshot or
replace everything that's

00:24:59.160 --> 00:25:00.650
there with a snapshot.

00:25:00.650 --> 00:25:06.990
But it works well in I want to
write a mobile application and

00:25:06.990 --> 00:25:10.880
all I really care about being
able to view and make simple

00:25:10.880 --> 00:25:12.280
changes to the data model.

00:25:12.280 --> 00:25:18.110
It also works pretty well for
a backup kind of scenario or

00:25:18.110 --> 00:25:21.960
if you wanted to convert the
data model into some binary

00:25:21.960 --> 00:25:24.910
format or something like that.

00:25:24.910 --> 00:25:28.640
STEVE BAZYL: Actually speaking
of binary formats, there's a

00:25:28.640 --> 00:25:35.750
question about what's some of
the strategies for serializing

00:25:35.750 --> 00:25:37.080
to binary files.

00:25:37.080 --> 00:25:39.790
I know in documentation and I
know a couple of the apps that

00:25:39.790 --> 00:25:44.590
were part of the launch do this
where they sync between

00:25:44.590 --> 00:25:46.570
files that are in Drive and the

00:25:46.570 --> 00:25:48.850
real-time versions of them.

00:25:48.850 --> 00:25:52.200
What are some of the strategies
for when people

00:25:52.200 --> 00:25:53.500
should do those operations?

00:25:53.500 --> 00:25:57.030
How do they make sure that
multiple collaborators aren't

00:25:57.030 --> 00:25:58.940
both trying to write files
at the same time,

00:25:58.940 --> 00:26:01.080
and things like that?

00:26:01.080 --> 00:26:03.200
CHERYL SIMON: So there's two
different ways that you can

00:26:03.200 --> 00:26:07.680
configure your real
time model.

00:26:07.680 --> 00:26:11.440
So if you have a binary format
that a sort of the basis of

00:26:11.440 --> 00:26:13.710
what's being output like say
an image or something like

00:26:13.710 --> 00:26:18.820
that, you could write your
applications so that it's

00:26:18.820 --> 00:26:20.280
built on top of this image.

00:26:20.280 --> 00:26:22.370
Where you have the binary image
and then you have your

00:26:22.370 --> 00:26:25.240
real time model attached to
the image that's separate.

00:26:25.240 --> 00:26:28.310
And in this sort of set up, the
real time model is a more

00:26:28.310 --> 00:26:29.940
transient sort of thing.

00:26:29.940 --> 00:26:31.980
So when you have collaborators
working on it--

00:26:34.600 --> 00:26:37.970
when they start working on it
you can read in information

00:26:37.970 --> 00:26:42.600
from the binary data model, and
sort of populate your real

00:26:42.600 --> 00:26:44.790
time model based on whatever
the current state of the

00:26:44.790 --> 00:26:46.592
binary file is.

00:26:46.592 --> 00:26:49.150
And then what we suggest is that
collaborators are working

00:26:49.150 --> 00:26:52.240
on it, you don't really want
to be saving back super

00:26:52.240 --> 00:26:54.020
continuously.

00:26:54.020 --> 00:26:56.700
Because the real time model is
going to be saving the changes

00:26:56.700 --> 00:26:57.770
as you go along.

00:26:57.770 --> 00:27:01.470
But then when the users sort
of hit a snap shot point or

00:27:01.470 --> 00:27:04.500
request a save or something
like that, then you can

00:27:04.500 --> 00:27:08.930
serialize the model and turn
it back into binary format.

00:27:08.930 --> 00:27:10.920
BRIAN CAIRNS: I think Cheryl
addressed this partially but.

00:27:13.730 --> 00:27:17.740
So there's really two ways to
think about binary data and

00:27:17.740 --> 00:27:19.940
the data model.

00:27:19.940 --> 00:27:23.300
One way to think about it is
that the model is a full

00:27:23.300 --> 00:27:26.200
representation of what's
in the binary file.

00:27:26.200 --> 00:27:29.700
And this is good for things like
text files or XML formats

00:27:29.700 --> 00:27:33.270
and things that are
fairly compact.

00:27:33.270 --> 00:27:35.260
There are some size limitations
on how much data

00:27:35.260 --> 00:27:37.320
you can put in the data model.

00:27:37.320 --> 00:27:41.560
And you really don't want to
do things like take a five

00:27:41.560 --> 00:27:44.300
megabyte JPEG image and try to
put it into the data model.

00:27:44.300 --> 00:27:46.340
Because you're not going to
be satisfied with the

00:27:46.340 --> 00:27:48.360
performance for that.

00:27:48.360 --> 00:27:50.710
And if you're building an
application like usually you

00:27:50.710 --> 00:27:55.060
would use the collaborative
data model as a series of

00:27:55.060 --> 00:27:58.400
transformations to the
original binary file.

00:27:58.400 --> 00:28:00.450
And what we would suggest if
you're doing something like

00:28:00.450 --> 00:28:06.420
that is keep track of the
revision number of the binary

00:28:06.420 --> 00:28:07.860
when you opened it.

00:28:07.860 --> 00:28:10.010
And you can do this with
the Drive API.

00:28:10.010 --> 00:28:13.540
And it may be even helpful to
pin that revision, again using

00:28:13.540 --> 00:28:14.240
the Drive API.

00:28:14.240 --> 00:28:17.100
So you can be sure that it
doesn't get garbage collected

00:28:17.100 --> 00:28:19.590
and go way.

00:28:19.590 --> 00:28:22.730
And by doing that you can always
load in the original

00:28:22.730 --> 00:28:27.010
binary data and then apply the
changes in your model to that.

00:28:27.010 --> 00:28:31.550
And then when the user goes to
save or otherwise update the

00:28:31.550 --> 00:28:35.380
binary data, and you can choose
how to do that, you

00:28:35.380 --> 00:28:38.900
would sort of flatten your
representation back down into

00:28:38.900 --> 00:28:44.050
this binary format and clean out
what's in the data model.

00:28:44.050 --> 00:28:45.320
That's one option.

00:28:45.320 --> 00:28:49.910
Another option is if you have
a full fidelity way to

00:28:49.910 --> 00:28:54.480
represent what's in the binary
data in your real time model,

00:28:54.480 --> 00:28:58.080
you could just copy the binary
data effectively and do some

00:28:58.080 --> 00:28:59.970
transformation on it, and
then write that into

00:28:59.970 --> 00:29:01.540
the real time model.

00:29:01.540 --> 00:29:05.670
And then you don't have to
track the binary file.

00:29:05.670 --> 00:29:09.250
You can just keep the real time
model around basically

00:29:09.250 --> 00:29:15.750
forever and save back to the
binary file at whatever

00:29:15.750 --> 00:29:18.050
interval you feel is appropriate
if you're doing it

00:29:18.050 --> 00:29:22.710
on an interval or by having
the user manually save.

00:29:22.710 --> 00:29:26.930
One thing we would suggest is
use the capabilities that are

00:29:26.930 --> 00:29:31.380
in the Drive API, like e-tags,
to make sure that you're not

00:29:31.380 --> 00:29:33.780
clobbering someone
else's changes.

00:29:33.780 --> 00:29:39.420
Remember we have the desktop and
mobile clients as well for

00:29:39.420 --> 00:29:41.850
Drive plus the web interface.

00:29:41.850 --> 00:29:43.690
And of course we have all
these other third party

00:29:43.690 --> 00:29:44.920
applications.

00:29:44.920 --> 00:29:47.640
So if you are working on
something that's shared, or

00:29:47.640 --> 00:29:49.610
even if you're working on
something that's just a single

00:29:49.610 --> 00:29:53.400
user's file, there's a definite
possibility that that

00:29:53.400 --> 00:29:56.840
could get overwritten while
you're working on it.

00:29:56.840 --> 00:29:59.520
And that's something you
want to watch out for.

00:29:59.520 --> 00:30:03.830
And we have a document and some
descriptions of exactly

00:30:03.830 --> 00:30:07.970
how we handle these sorts
of conflict cases in the

00:30:07.970 --> 00:30:09.740
documentation.

00:30:09.740 --> 00:30:12.610
But the gist of it is basically
if someone writes to

00:30:12.610 --> 00:30:16.700
the binary file while you're
editing on it, your editing

00:30:16.700 --> 00:30:19.270
session doesn't get
interrupted.

00:30:19.270 --> 00:30:25.590
But future people who join the
same binary file may see

00:30:25.590 --> 00:30:28.800
something based on the
new file contents.

00:30:28.800 --> 00:30:33.610
And it could be a little bit
tricky to handle this.

00:30:33.610 --> 00:30:35.680
And it's sort of an unfortunate
consequence of the

00:30:35.680 --> 00:30:39.030
fact that we're not
collaborating directly on the

00:30:39.030 --> 00:30:40.150
binary data.

00:30:40.150 --> 00:30:44.660
But with some reasonable
practices, you can develop an

00:30:44.660 --> 00:30:48.460
application that's predictable
and will give your users a

00:30:48.460 --> 00:30:52.300
good user experience
with this.

00:30:52.300 --> 00:30:54.940
STEVE BAZYL: So the talk about
revisions is a good segue to

00:30:54.940 --> 00:30:58.450
the second to last question,
which is are

00:30:58.450 --> 00:30:59.830
these versioned files?

00:30:59.830 --> 00:31:03.000
Do we support undo and redo?

00:31:03.000 --> 00:31:05.820
How do they reflect in the
revision history in

00:31:05.820 --> 00:31:08.240
Drive and so on?

00:31:08.240 --> 00:31:11.440
CHERYL SIMON: So we have the
entire history of all the

00:31:11.440 --> 00:31:13.300
changes that were made
available to us.

00:31:13.300 --> 00:31:14.930
It's not exposed yet.

00:31:14.930 --> 00:31:19.480
We hopefully have some new
features coming soon that will

00:31:19.480 --> 00:31:20.870
expose some of this
a little bit more.

00:31:24.010 --> 00:31:24.910
STEVE BAZYL: Go ahead Brian.

00:31:24.910 --> 00:31:26.600
BRIAN CAIRNS: I should note, we
don't affect the revision

00:31:26.600 --> 00:31:29.160
history in Drive, the simple
answer to that.

00:31:29.160 --> 00:31:32.520
The revision history you seen in
Drive is only related to a

00:31:32.520 --> 00:31:34.150
binary file.

00:31:34.150 --> 00:31:37.880
And so if you're doing a binary
application then every

00:31:37.880 --> 00:31:40.900
time you save that would
create a new revision.

00:31:40.900 --> 00:31:43.060
And this is by the way one
reason why you might not want

00:31:43.060 --> 00:31:46.390
to do auto save every
minute or something.

00:31:46.390 --> 00:31:48.647
Because you end up creating
hundreds of revisions, which

00:31:48.647 --> 00:31:52.960
is not very useful from
a user's perspective.

00:31:52.960 --> 00:31:55.930
But yeah, changes to
the real time model

00:31:55.930 --> 00:31:57.080
don't show up in Drive.

00:31:57.080 --> 00:32:01.570
I mean, they don't show up in
the revision history in Drive.

00:32:01.570 --> 00:32:04.600
STEVE BAZYL: Last question, and
this one is just from me.

00:32:04.600 --> 00:32:07.620
What are you most looking
forward to over the next few

00:32:07.620 --> 00:32:10.630
months in terms of applications
from the

00:32:10.630 --> 00:32:11.260
communities?

00:32:11.260 --> 00:32:13.350
Or anything in particular
you'd really like to see

00:32:13.350 --> 00:32:14.990
somebody build?

00:32:14.990 --> 00:32:18.870
Any apps that you think are
really good candidates for

00:32:18.870 --> 00:32:20.120
this type of collaboration
feature?

00:32:23.100 --> 00:32:24.570
CHERYL SIMON: I don't know
if there's anything in

00:32:24.570 --> 00:32:25.300
particular.

00:32:25.300 --> 00:32:27.720
Mostly we're excited to see
what people come up with.

00:32:27.720 --> 00:32:31.070
Because we've had a lot of toy
apps developed internally and

00:32:31.070 --> 00:32:34.490
seen a lot of different things
that people play around with.

00:32:34.490 --> 00:32:38.650
And we've already seen a few
cool examples of sort of demos

00:32:38.650 --> 00:32:40.270
from people in the community.

00:32:40.270 --> 00:32:43.590
But we're mostly just interested
in seeing what

00:32:43.590 --> 00:32:45.615
people come up with.

00:32:45.615 --> 00:32:46.430
BRIAN CAIRNS: Yeah, I agree.

00:32:46.430 --> 00:32:51.820
I think there's a lot of
opportunity for applications

00:32:51.820 --> 00:32:56.040
that are specific to a kind of
niche, something that maybe

00:32:56.040 --> 00:33:01.070
you wouldn't have seen if you
had to develop the entire

00:33:01.070 --> 00:33:05.060
infrastructure and the
synchronization framework and

00:33:05.060 --> 00:33:07.090
all of that.

00:33:07.090 --> 00:33:08.790
So I hope to see
a lot of those.

00:33:08.790 --> 00:33:14.790
I would also like to see
something that is really a

00:33:14.790 --> 00:33:19.110
fully featured powerful
application along the same

00:33:19.110 --> 00:33:21.900
lines as Docs, Sheets, and
Slides, not something that's

00:33:21.900 --> 00:33:25.030
necessarily in one of
those categories.

00:33:25.030 --> 00:33:29.800
And we've seen some of that
already with apps like Gantter

00:33:29.800 --> 00:33:34.060
and draw.io and of
course Neutron is

00:33:34.060 --> 00:33:36.140
getting really powerful.

00:33:36.140 --> 00:33:39.040
But I want to see something
that's really rivaling what

00:33:39.040 --> 00:33:42.640
you can do in a traditional
application, but of course

00:33:42.640 --> 00:33:46.320
enabled with all this real
time collaboration.

00:33:46.320 --> 00:33:49.360
STEVE BAZYL: Well thank you
both of you for your time.

00:33:49.360 --> 00:33:51.435
I know you're busy over there.

00:33:51.435 --> 00:33:53.785
I really appreciate the
time to do this.

00:33:53.785 --> 00:33:55.800
But that's the end
of the questions.

00:33:55.800 --> 00:33:58.690
I hope everyone out there either
if you're watching live

00:33:58.690 --> 00:34:01.330
or watching later enjoy this.

00:34:01.330 --> 00:34:04.640
And again you can always ask
more questions in the Google

00:34:04.640 --> 00:34:05.950
Drive Developers community.

00:34:05.950 --> 00:34:08.409
And we'll be happy to help.

00:34:08.409 --> 00:34:11.750
And you can also find us
on Stack Overflow.

00:34:11.750 --> 00:34:14.860
So until next week, that's
all for today.

00:34:14.860 --> 00:34:16.110
Thank you.

00:34:22.920 --> 00:34:28.620
[MUSIC PLAYING]

