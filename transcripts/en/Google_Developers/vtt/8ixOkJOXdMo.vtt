WEBVTT
Kind: captions
Language: en

00:00:03.000 --> 00:00:04.560
FERHAT BUYUKKOTKTEN:
Hi, everyone.

00:00:04.560 --> 00:00:05.890
I'm Ferhat.

00:00:05.890 --> 00:00:11.270
Matan and I are leading the
Angular Dart effort at Google.

00:00:11.270 --> 00:00:15.030
And we're very happy
to be with you today

00:00:15.030 --> 00:00:20.850
to share what we've been
working on inside Angular Dart.

00:00:20.850 --> 00:00:26.460
And we're going to introduce
today some new tools

00:00:26.460 --> 00:00:30.390
to help you build
great web applications.

00:00:30.390 --> 00:00:37.900
And Angular Dart-- these
are the three big pillars

00:00:37.900 --> 00:00:42.150
that we think of when we're
working on Angular Dart.

00:00:42.150 --> 00:00:44.780
Basically, any new
feature we add,

00:00:44.780 --> 00:00:50.550
or when we make
changes in the APIs,

00:00:50.550 --> 00:00:53.850
we try to make sure we
have a perfect balance

00:00:53.850 --> 00:00:56.810
between these three items.

00:00:56.810 --> 00:01:00.640
So on the productivity
side, we started

00:01:00.640 --> 00:01:02.500
doing surveys inside Google.

00:01:02.500 --> 00:01:06.330
Now our customer base or
the number of developers

00:01:06.330 --> 00:01:10.060
are substantial enough, so
we're getting a lot of data

00:01:10.060 --> 00:01:12.880
on productivity inside Google.

00:01:12.880 --> 00:01:16.180
Performance wise,
we have now hundreds

00:01:16.180 --> 00:01:21.220
of benchmarks on the
components and actual apps

00:01:21.220 --> 00:01:23.920
running in production.

00:01:23.920 --> 00:01:30.110
So if that material
button gets just 5%

00:01:30.110 --> 00:01:32.014
slower somehow, because
we made the change--

00:01:32.014 --> 00:01:33.430
MATAN LUREY: We
don't get emailed.

00:01:33.430 --> 00:01:35.960
FERHAT BUYUKKOTKTEN: Yeah,
we immediately get an alert.

00:01:35.960 --> 00:01:38.100
Basically it will
say, this exact

00:01:38.100 --> 00:01:43.450
change-- you affected these
benchmarks across the stack.

00:01:43.450 --> 00:01:49.700
And then we either roll back or
look at the issue and fix it.

00:01:49.700 --> 00:01:56.460
So this allows our teams to
have a predictable and stable

00:01:56.460 --> 00:01:59.560
framework under them,
because we want to make sure

00:01:59.560 --> 00:02:01.620
once they ship these
into production,

00:02:01.620 --> 00:02:05.810
the apps stay
stable and they keep

00:02:05.810 --> 00:02:08.910
on running at high performance.

00:02:08.910 --> 00:02:13.450
So about stability--
since last summer

00:02:13.450 --> 00:02:17.350
we've been working with
these large Google teams

00:02:17.350 --> 00:02:20.100
to get Angular Dart
into production.

00:02:20.100 --> 00:02:25.280
And at this point,
we have monitored,

00:02:25.280 --> 00:02:28.580
talked to a lot of
these teams, and looked

00:02:28.580 --> 00:02:32.950
at the problems they were
having in terms of productivity,

00:02:32.950 --> 00:02:36.470
worked through some of the
APIs, made them better.

00:02:36.470 --> 00:02:41.060
And as Dan mentioned,
basically we

00:02:41.060 --> 00:02:44.930
think we're ready for you
to start building production

00:02:44.930 --> 00:02:45.880
apps today.

00:02:45.880 --> 00:02:48.890
So we're happy to
release it today.

00:02:48.890 --> 00:02:53.610
This morning we published
the new package.

00:02:53.610 --> 00:02:58.980
So you can update your pubspec,
remove that beta from it,

00:02:58.980 --> 00:03:01.643
and starts using it today.

00:03:04.549 --> 00:03:06.840
MATAN LUREY: So how many
people here have written a web

00:03:06.840 --> 00:03:08.230
application before in Dart?

00:03:08.230 --> 00:03:10.620
Can I get a show of hands?

00:03:10.620 --> 00:03:13.540
How many written
an Angular Dart?

00:03:13.540 --> 00:03:15.170
Pretty good, actually.

00:03:15.170 --> 00:03:17.427
This currently is our
workflow for Angular Dart.

00:03:17.427 --> 00:03:20.010
I think it's actually one of the
best workflows for a web app.

00:03:20.010 --> 00:03:21.593
This is how easy it
is to get started.

00:03:21.593 --> 00:03:23.580
You get WebStorm with
your favorite IDE.

00:03:23.580 --> 00:03:24.970
You write a little bit of code.

00:03:24.970 --> 00:03:26.670
You hit Pub Serve,
and you Refresh.

00:03:26.670 --> 00:03:28.950
There is no other set up,
no other dependencies,

00:03:28.950 --> 00:03:29.630
nothing else.

00:03:29.630 --> 00:03:31.040
It's actually really this easy.

00:03:31.040 --> 00:03:33.080
You can do it in
five seconds, and I

00:03:33.080 --> 00:03:35.600
think this is an awesome
experience for Angular Dart.

00:03:38.640 --> 00:03:40.860
FERHAT BUYUKKOTKTEN:
So for those of you

00:03:40.860 --> 00:03:45.300
who are new to
Angular, people love

00:03:45.300 --> 00:03:49.340
Angular for its ease of
use and productivity.

00:03:49.340 --> 00:03:53.720
Basically your HTML and
CSS is front and center.

00:03:53.720 --> 00:03:57.050
So you just simply
edit an HTML file,

00:03:57.050 --> 00:04:00.940
and then you write a Dart class,
which becomes your component.

00:04:00.940 --> 00:04:04.850
And then you wire
up your template.

00:04:04.850 --> 00:04:09.550
So it's a very easy model
to get started with.

00:04:09.550 --> 00:04:12.100
And this is a typical Dart app.

00:04:12.100 --> 00:04:16.420
Basically, you just
import the library, set up

00:04:16.420 --> 00:04:20.240
your component-- in this
case, I have a single property

00:04:20.240 --> 00:04:23.080
I'm binding to-- and then
you bootstrap your app,

00:04:23.080 --> 00:04:24.990
and you're up and running.

00:04:24.990 --> 00:04:29.340
So people love how easy it is
to get started in Angular Dart

00:04:29.340 --> 00:04:32.900
and start building
web applications.

00:04:32.900 --> 00:04:35.920
So Angular Dart
is also very deep.

00:04:35.920 --> 00:04:40.090
So once your application
starts growing,

00:04:40.090 --> 00:04:42.740
to give it better
structure, Angular Dart

00:04:42.740 --> 00:04:44.820
provides dependency injection.

00:04:44.820 --> 00:04:48.410
So you can start moving some of
the services, some of the data

00:04:48.410 --> 00:04:52.070
layers, out of your views.

00:04:52.070 --> 00:04:57.780
And you can simply inject these
services into your components.

00:04:57.780 --> 00:05:00.910
And so that's on
the component side.

00:05:00.910 --> 00:05:03.510
And on the template
side, it provides

00:05:03.510 --> 00:05:06.790
a system called Directives
where you can basically

00:05:06.790 --> 00:05:08.120
define behaviors.

00:05:08.120 --> 00:05:12.300
You can extend the
language of the templates.

00:05:12.300 --> 00:05:16.690
So you can create new
elements that expand the DSL

00:05:16.690 --> 00:05:21.670
and allow you to build really
powerful libraries that you

00:05:21.670 --> 00:05:25.120
can reuse across your app.

00:05:25.120 --> 00:05:28.440
And injection is real easy.

00:05:28.440 --> 00:05:31.690
You just create a Dart class,
MyService, put Add Injectable

00:05:31.690 --> 00:05:34.050
on it, and it's ready for use.

00:05:34.050 --> 00:05:37.000
Now I can take that
MyService and just

00:05:37.000 --> 00:05:42.320
inject it in my constructor
on the main component.

00:05:42.320 --> 00:05:45.090
This makes it very
easy to build tests.

00:05:45.090 --> 00:05:47.830
Matan, later on,
will be showing you

00:05:47.830 --> 00:05:52.820
how much nicer it is now to
test Angular Dart applications.

00:05:52.820 --> 00:05:57.150
And for directives, essentially
you define a selector.

00:05:57.150 --> 00:05:59.530
In this case, it
could be auto focus.

00:05:59.530 --> 00:06:04.870
So whenever your
view gets created,

00:06:04.870 --> 00:06:08.050
it will focus on the element
we have this directive on.

00:06:11.200 --> 00:06:13.850
MATAN LUREY: So a big part of
why we actually like Angular

00:06:13.850 --> 00:06:16.790
and why Angular likes
Dart, we are really

00:06:16.790 --> 00:06:18.790
trying to use all of
those great core library

00:06:18.790 --> 00:06:20.510
features that Dan and
Cathy talked about.

00:06:20.510 --> 00:06:23.330
So Angular Dart is
all about streams,

00:06:23.330 --> 00:06:26.039
zones, futures, the
collection library.

00:06:26.039 --> 00:06:27.330
We're not inventing new things.

00:06:27.330 --> 00:06:31.600
If you're comfortable writing
frameworks or apps in Dart

00:06:31.600 --> 00:06:33.730
HTML-- and we saw last
night that a lot of people

00:06:33.730 --> 00:06:35.530
wrote their own frameworks
with Dart HTML--

00:06:35.530 --> 00:06:37.210
we're using the
exact same thing.

00:06:37.210 --> 00:06:38.259
So it's streams.

00:06:38.259 --> 00:06:38.800
It's futures.

00:06:38.800 --> 00:06:40.100
It's all these core libraries.

00:06:40.100 --> 00:06:41.210
You can open the code.

00:06:41.210 --> 00:06:42.440
It's not something special.

00:06:42.440 --> 00:06:45.680
So it's really exciting.

00:06:45.680 --> 00:06:48.870
FERHAT BUYUKKOTKTEN: And the
big change in Angular 2.0

00:06:48.870 --> 00:06:52.460
is that we're compiling
templates now.

00:06:52.460 --> 00:06:56.420
And compiling templates
has very good properties.

00:06:56.420 --> 00:07:00.680
So the first one is
faster DOM construction.

00:07:00.680 --> 00:07:06.620
So traditionally, the way we
constructed DOM in Angular 1

00:07:06.620 --> 00:07:10.380
and before is we would
essentially take the template

00:07:10.380 --> 00:07:13.210
and then build it
inside the DOM.

00:07:13.210 --> 00:07:19.790
And then we would clone that
tree of DOM nodes at runtime.

00:07:19.790 --> 00:07:22.600
But of course, since we
have bindings and attributes

00:07:22.600 --> 00:07:24.710
on those DOM nodes,
we would have

00:07:24.710 --> 00:07:28.450
to go back, get the references
of each of those DOM elements,

00:07:28.450 --> 00:07:31.310
and then update the attributes.

00:07:31.310 --> 00:07:34.180
What compiled
templates lets us do

00:07:34.180 --> 00:07:38.560
is we can actually write
code as if a human wrote it.

00:07:38.560 --> 00:07:41.790
So we made some of these
changes over the past two,

00:07:41.790 --> 00:07:43.290
three months.

00:07:43.290 --> 00:07:46.100
If you look at the generated
template, that Dart code,

00:07:46.100 --> 00:07:49.830
you'll see it writing
document dot create element,

00:07:49.830 --> 00:07:52.180
and it will put the
tag name in there.

00:07:52.180 --> 00:07:54.360
So it's very
readable now the way

00:07:54.360 --> 00:07:57.810
we are generating
these templates.

00:07:57.810 --> 00:08:02.360
And it is powered by the
Dart HTML library underneath.

00:08:02.360 --> 00:08:04.020
So it's very familiar.

00:08:04.020 --> 00:08:05.980
Whenever you want to
debug a component,

00:08:05.980 --> 00:08:07.930
you can simply go into
the template Dart file,

00:08:07.930 --> 00:08:09.510
and you can put a break point.

00:08:09.510 --> 00:08:14.060
And it will look
familiar to you.

00:08:14.060 --> 00:08:18.940
The other property compiled
templates have is we

00:08:18.940 --> 00:08:22.640
started typing the members
we have in those template

00:08:22.640 --> 00:08:23.800
dot Dart files.

00:08:23.800 --> 00:08:27.020
If you open it up today, if
you use an input element,

00:08:27.020 --> 00:08:29.160
and you have a value
property on it,

00:08:29.160 --> 00:08:31.550
the input element is
now completely typed

00:08:31.550 --> 00:08:32.980
in the Dart version.

00:08:32.980 --> 00:08:36.270
So if you have value property,
it'll just set the value.

00:08:36.270 --> 00:08:39.450
If you try to use it on a
development, at compile time,

00:08:39.450 --> 00:08:42.039
it will say the
development class doesn't

00:08:42.039 --> 00:08:44.530
contain the property value.

00:08:44.530 --> 00:08:47.110
So at compile time, we
can do these tricks.

00:08:47.110 --> 00:08:48.900
The same thing with
your expressions--

00:08:48.900 --> 00:08:52.750
if you use a binding
expression and recompile it

00:08:52.750 --> 00:08:57.980
into Dart code, at compile time,
you're going to get errors.

00:08:57.980 --> 00:09:00.650
So the other cool
thing about compiling

00:09:00.650 --> 00:09:03.630
is we get zero
cost abstractions.

00:09:03.630 --> 00:09:08.070
So traditionally, Angular
had done all these things

00:09:08.070 --> 00:09:09.380
at runtime.

00:09:09.380 --> 00:09:11.470
For example, at
runtime, it would check,

00:09:11.470 --> 00:09:13.510
am I running in debug mode?

00:09:13.510 --> 00:09:15.430
Or am I running in release mode?

00:09:15.430 --> 00:09:18.470
And it would select
debug or release

00:09:18.470 --> 00:09:22.270
versions of those classes,
dynamically at runtime.

00:09:22.270 --> 00:09:22.770
Of course--

00:09:22.770 --> 00:09:24.840
MATAN LUREY: Imagine
hundreds of "if" statements.

00:09:24.840 --> 00:09:27.300
Every single part of the code,
if debug this-- everywhere

00:09:27.300 --> 00:09:28.547
throughout your code.

00:09:28.547 --> 00:09:29.630
FERHAT BUYUKKOTKTEN: Yeah.

00:09:29.630 --> 00:09:31.610
And what we're
able to do is we're

00:09:31.610 --> 00:09:36.665
able to essentially now
target the exact release mode

00:09:36.665 --> 00:09:39.850
or debug and generate
different code.

00:09:39.850 --> 00:09:43.340
If you go to your pub spec
and change [INAUDIBLE] mode

00:09:43.340 --> 00:09:46.650
to release or debug and
look at the template again,

00:09:46.650 --> 00:09:49.980
you'll see how much smaller
the release versions are.

00:09:49.980 --> 00:09:51.540
And then the debug
versions, it's

00:09:51.540 --> 00:09:53.470
adding more debug info for you.

00:09:53.470 --> 00:09:55.330
So if anything goes
wrong in your code,

00:09:55.330 --> 00:09:57.970
you get better [INAUDIBLE].

00:09:57.970 --> 00:10:02.050
Another good example for
this is because we're

00:10:02.050 --> 00:10:04.160
compiling, at
compile time, we know

00:10:04.160 --> 00:10:07.380
that a template reference
or an element reference

00:10:07.380 --> 00:10:11.190
is actually just a
field on the view.

00:10:11.190 --> 00:10:13.940
So we can directly pass
it into the constructor.

00:10:13.940 --> 00:10:17.390
At runtime, we don't have to
look up-- in the injector--

00:10:17.390 --> 00:10:21.210
look up in a map and
get these references.

00:10:21.210 --> 00:10:24.610
So we can make injection
faster, because at compile time,

00:10:24.610 --> 00:10:28.800
we already know about
these abstractions.

00:10:28.800 --> 00:10:33.290
So a lesser known attribute
of compiled templates

00:10:33.290 --> 00:10:35.060
is actually security.

00:10:35.060 --> 00:10:40.210
So we're not doing any
evals anymore at runtime.

00:10:40.210 --> 00:10:44.410
So we take your expressions,
we compile them into Dart code,

00:10:44.410 --> 00:10:47.180
and now you can't inject
another function in there

00:10:47.180 --> 00:10:51.520
or try to attack
the applications.

00:10:51.520 --> 00:10:53.640
So this is very good
security properties.

00:10:53.640 --> 00:10:59.170
Our security team at
Google loves that we're now

00:10:59.170 --> 00:11:02.200
compiling these templates.

00:11:02.200 --> 00:11:05.830
So of course, compiled
templates come at a cost.

00:11:05.830 --> 00:11:08.000
And the cost is code size.

00:11:08.000 --> 00:11:10.270
We're generating more code.

00:11:10.270 --> 00:11:14.810
The traditional take
an HTML snippet,

00:11:14.810 --> 00:11:17.940
that string actually
compresses really, really well.

00:11:17.940 --> 00:11:19.970
But now we're
generating Dart code.

00:11:19.970 --> 00:11:26.260
So we've started working
hard on this code size issue.

00:11:26.260 --> 00:11:31.840
And this is a graph from one
of our code size benchmarks.

00:11:31.840 --> 00:11:39.570
And this one dropped from 1.56
megabytes to under a meg now.

00:11:39.570 --> 00:11:44.680
So we got 40% less
Dart code generated now

00:11:44.680 --> 00:11:47.350
without changing
anything in Angular.

00:11:47.350 --> 00:11:48.620
And we're not done yet.

00:11:48.620 --> 00:11:51.490
There are some big
gains to be made still

00:11:51.490 --> 00:11:54.890
on the code size side.

00:11:54.890 --> 00:11:56.030
So how did we do it?

00:11:56.030 --> 00:11:58.420
How did we drop 40%?

00:11:58.420 --> 00:12:02.470
Well, first of all, as
you know, Angular Dart

00:12:02.470 --> 00:12:06.110
is a separate repo now from
the TypeScript version.

00:12:06.110 --> 00:12:10.780
So we started using
idiomatic Dart code when

00:12:10.780 --> 00:12:15.220
we generate this compiled code.

00:12:15.220 --> 00:12:19.560
So one of the examples
are we removed this dot

00:12:19.560 --> 00:12:21.610
from all of the code generation.

00:12:21.610 --> 00:12:23.870
And that gave us 8%.

00:12:23.870 --> 00:12:27.490
So that means when you're
writing code today,

00:12:27.490 --> 00:12:30.710
you're typing 8%
less code because you

00:12:30.710 --> 00:12:33.060
don't have to do this
dot everywhere in Dart.

00:12:33.060 --> 00:12:34.230
It's wonderful.

00:12:34.230 --> 00:12:37.620
And all the other properties
that we love about

00:12:37.620 --> 00:12:42.200
Dart-- the terseness of it,
as Dan mentioned in his talk--

00:12:42.200 --> 00:12:45.070
we started using them
in the templates itself.

00:12:45.070 --> 00:12:48.560
So that reduced the cost.

00:12:48.560 --> 00:12:52.570
And we also started removing
all the dynamic calls.

00:12:52.570 --> 00:12:55.760
So when Dart to JS
compiles it to JavaScript,

00:12:55.760 --> 00:12:58.120
it doesn't have to check
the classes at runtime.

00:12:58.120 --> 00:13:00.810
It generates much, much
tighter and more efficient

00:13:00.810 --> 00:13:03.140
JavaScript code.

00:13:03.140 --> 00:13:06.100
And as I mentioned
before, we started

00:13:06.100 --> 00:13:08.190
removing abstraction layers.

00:13:08.190 --> 00:13:11.850
So to us, Angular Dart
is perfect for the web.

00:13:11.850 --> 00:13:15.490
And our main focus is
actually web development.

00:13:15.490 --> 00:13:17.760
So we don't have to
have extra layers

00:13:17.760 --> 00:13:21.610
for mobile native bindings
and things like that.

00:13:21.610 --> 00:13:27.730
So tomorrow's talk is going
to show you a great framework

00:13:27.730 --> 00:13:29.520
to do mobile development.

00:13:29.520 --> 00:13:32.580
So in Angular Dart, we're
now able to take out

00:13:32.580 --> 00:13:37.050
a lot of layers that
were in between to turn

00:13:37.050 --> 00:13:39.350
Angular more into a platform.

00:13:39.350 --> 00:13:41.880
We are concentrated
completely on the web

00:13:41.880 --> 00:13:47.460
to create a great desktop
and mobile web applications.

00:13:47.460 --> 00:13:50.400
Another change we did is
whitespace compression.

00:13:50.400 --> 00:13:54.480
Some of you might be
familiar with the HTML spec

00:13:54.480 --> 00:13:56.620
where if you have
two inline blocks,

00:13:56.620 --> 00:13:59.530
it actually matters whether
you have space in between them

00:13:59.530 --> 00:14:00.530
or not.

00:14:00.530 --> 00:14:04.810
The browser is going
to basically layout

00:14:04.810 --> 00:14:07.050
your HTML slightly differently.

00:14:07.050 --> 00:14:12.020
But very few people
use this property.

00:14:12.020 --> 00:14:14.800
And it's one of the reasons
other frameworks haven't

00:14:14.800 --> 00:14:16.470
done whitespace compression.

00:14:16.470 --> 00:14:19.620
Otherwise, we'd have
a tool already that

00:14:19.620 --> 00:14:22.310
would be compressing your HTML.

00:14:22.310 --> 00:14:27.710
But you can't tell this at
compile time, because it's CSS.

00:14:27.710 --> 00:14:30.280
You don't know which
CSS is going to apply.

00:14:30.280 --> 00:14:34.120
So when you're compressing
the whitespace,

00:14:34.120 --> 00:14:35.480
you can't really tell.

00:14:35.480 --> 00:14:39.200
But with the latest
release, we're

00:14:39.200 --> 00:14:42.360
giving you a new
component property.

00:14:42.360 --> 00:14:43.990
It's called Preserve Whitespace.

00:14:43.990 --> 00:14:46.390
If you turn this to
false, it will basically

00:14:46.390 --> 00:14:50.510
remove all new lines, all
spaces inside your templates.

00:14:50.510 --> 00:14:53.010
And it's quite amazing
how much you can save.

00:14:53.010 --> 00:14:57.760
On our material input component,
we went from 40 DOM nodes

00:14:57.760 --> 00:14:59.420
down to 17.

00:14:59.420 --> 00:15:00.929
There was so much
whitespace in it.

00:15:00.929 --> 00:15:02.470
Basically every
single line, you have

00:15:02.470 --> 00:15:04.460
that slash new line at the end.

00:15:04.460 --> 00:15:06.770
Believe it or not,
that actually generates

00:15:06.770 --> 00:15:11.090
a text node behind the scenes.

00:15:11.090 --> 00:15:12.885
So that's code size.

00:15:12.885 --> 00:15:15.160
And going forward
for performance,

00:15:15.160 --> 00:15:17.960
we're primarily
concentrating on two things.

00:15:17.960 --> 00:15:21.950
One, strongly typing
everything across Angular--

00:15:21.950 --> 00:15:27.650
so a lot of the compiled
code has started using this.

00:15:27.650 --> 00:15:30.970
And the nice thing is we don't
have to change the public APIs.

00:15:30.970 --> 00:15:33.260
So most of this work
is under the hood.

00:15:33.260 --> 00:15:37.720
We're now making Angular
faster and smaller

00:15:37.720 --> 00:15:40.609
without affecting
the public APIs.

00:15:40.609 --> 00:15:41.900
MATAN LUREY: And leave happier.

00:15:41.900 --> 00:15:43.749
FERHAT BUYUKKOTKTEN: Yes.

00:15:43.749 --> 00:15:46.290
SPEAKER 1: Very important.

00:15:46.290 --> 00:15:49.960
FERHAT BUYUKKOTKTEN: So
the second big change,

00:15:49.960 --> 00:15:52.710
which is our surprise
for you today,

00:15:52.710 --> 00:15:58.780
is we're introducing a
new way of doing change

00:15:58.780 --> 00:16:01.660
detection in Angular today.

00:16:01.660 --> 00:16:04.090
So instead of dirty
checking, we're

00:16:04.090 --> 00:16:08.020
introducing a mixing class
called component state.

00:16:08.020 --> 00:16:11.360
So traditionally, this is
what goes on behind the scenes

00:16:11.360 --> 00:16:13.600
if you create a template today.

00:16:13.600 --> 00:16:15.180
You have a binding.

00:16:15.180 --> 00:16:19.860
And we create this code that
basically checks the new value

00:16:19.860 --> 00:16:21.460
against the old value.

00:16:21.460 --> 00:16:24.860
And if there was a change,
it updates your template.

00:16:24.860 --> 00:16:27.940
However, all the Angular
components by default

00:16:27.940 --> 00:16:30.410
are marked as Check Me Always.

00:16:30.410 --> 00:16:32.930
So if any event
happens in the system,

00:16:32.930 --> 00:16:34.950
it will check all
your components.

00:16:34.950 --> 00:16:39.020
And if there is a change, it
will mark the children dirty

00:16:39.020 --> 00:16:41.060
if they have property changes.

00:16:41.060 --> 00:16:45.110
So there is a lot going
on behind the scenes

00:16:45.110 --> 00:16:50.290
to make the zone turn
actually update the templates.

00:16:50.290 --> 00:16:58.690
So I have a demo here that shows
you how this works in practice.

00:16:58.690 --> 00:17:00.860
So I have a material
table that's

00:17:00.860 --> 00:17:03.570
using default change detection.

00:17:03.570 --> 00:17:07.020
And as you see, the
table's scrolling.

00:17:07.020 --> 00:17:10.849
As it's scrolling, we're
generating new rows on the fly,

00:17:10.849 --> 00:17:14.490
as the user is
scrolling on demand.

00:17:14.490 --> 00:17:17.920
And if you watch
the frame rate, it's

00:17:17.920 --> 00:17:25.170
started dropping from 60
FPS and keeps on dropping.

00:17:25.170 --> 00:17:28.620
So this is a real
production table.

00:17:28.620 --> 00:17:34.520
So probably 90% of this
code-- one of the architects

00:17:34.520 --> 00:17:38.160
is back there that
works on the table.

00:17:38.160 --> 00:17:41.270
So this is the actual
production table we use.

00:17:41.270 --> 00:17:44.400
And to support all these
future teams inside Google,

00:17:44.400 --> 00:17:47.030
we have to build a
really powerful table.

00:17:47.030 --> 00:17:50.390
Every single cell here is
actually an Angular component,

00:17:50.390 --> 00:17:55.160
because inside apps, you don't
have a fixed set of columns.

00:17:55.160 --> 00:17:56.610
The order isn't determined.

00:17:56.610 --> 00:17:59.320
Depending on who logs
on to your application,

00:17:59.320 --> 00:18:01.706
you might want to show a
completely different table.

00:18:05.090 --> 00:18:10.840
So here what we're doing is
the table is completely built.

00:18:10.840 --> 00:18:13.350
So when I scroll around,
I expect actually

00:18:13.350 --> 00:18:14.420
nothing to happen.

00:18:14.420 --> 00:18:17.190
MATAN LUREY:
[INAUDIBLE] changes.

00:18:17.190 --> 00:18:19.800
FERHAT BUYUKKOTKTEN: But
if you look at the CPU,

00:18:19.800 --> 00:18:23.310
it's maxed out to 100%.

00:18:23.310 --> 00:18:25.910
And if you look at one
of these timelines,

00:18:25.910 --> 00:18:30.270
it should be very familiar to
you who built very large apps.

00:18:30.270 --> 00:18:32.420
So it's basically
doing change detection.

00:18:32.420 --> 00:18:34.530
It's going through
the whole tree

00:18:34.530 --> 00:18:36.800
and doing change detection,
although the table

00:18:36.800 --> 00:18:38.210
at this point is doing nothing.

00:18:38.210 --> 00:18:40.080
It's not mutating DOM.

00:18:40.080 --> 00:18:41.970
We're just handling
a scroll event.

00:18:45.870 --> 00:18:51.790
So what we're introducing today
is basically an easier way

00:18:51.790 --> 00:18:54.160
to do OnPush change detection.

00:18:54.160 --> 00:18:58.290
So one of the original
designers, Victor Savkin,

00:18:58.290 --> 00:19:06.100
designed OnPush And over
the past three months,

00:19:06.100 --> 00:19:09.100
we've been working on a way
to make this much, much easier

00:19:09.100 --> 00:19:09.960
for you.

00:19:09.960 --> 00:19:14.520
So basically you have a
component state mixin,

00:19:14.520 --> 00:19:18.520
and you say, as a component,
I know when my state changes.

00:19:18.520 --> 00:19:21.260
So Angular, please don't
keep on calling me.

00:19:21.260 --> 00:19:24.530
I'm going to let you know when
I want my template updated.

00:19:24.530 --> 00:19:27.790
So what you do is you
do a setState call,

00:19:27.790 --> 00:19:31.570
and you pass a closure that
actually mutates the state.

00:19:31.570 --> 00:19:35.360
And as soon as you
tell Angular setState,

00:19:35.360 --> 00:19:39.580
it will come back
and basically change

00:19:39.580 --> 00:19:42.340
detect just that component--
that single component

00:19:42.340 --> 00:19:45.650
that changed-- and then it
will update your templates.

00:19:45.650 --> 00:19:47.500
And if you have
something asynchronous,

00:19:47.500 --> 00:19:50.340
like your RPC completing,
you can do the same thing.

00:19:50.340 --> 00:19:53.980
You can just say setState
and update model.

00:19:53.980 --> 00:20:02.390
So I took the exact same table,
changed about four classes,

00:20:02.390 --> 00:20:06.410
and mixed in component state.

00:20:06.410 --> 00:20:09.540
And on each input, I
put a setState in there.

00:20:09.540 --> 00:20:13.250
And this is the
result. Basically we're

00:20:13.250 --> 00:20:19.090
generating about, let's
say, 10 columns, 1,000 rows.

00:20:19.090 --> 00:20:21.760
Each cell has actually
two components

00:20:21.760 --> 00:20:23.980
to stress it a little bit.

00:20:23.980 --> 00:20:26.340
So we have about 20,000
Angular components

00:20:26.340 --> 00:20:27.680
being created right now.

00:20:27.680 --> 00:20:32.748
And we get consistently 60 FPS.

00:20:32.748 --> 00:20:36.620
[APPLAUSE]

00:20:40.020 --> 00:20:46.310
So what's even nicer is now
if I go and capture a timeline

00:20:46.310 --> 00:20:50.840
and scroll the table
around, it runs some code

00:20:50.840 --> 00:20:53.180
and RequestAnimationFrame.

00:20:53.180 --> 00:20:55.940
If you have any
sticky headers on top,

00:20:55.940 --> 00:20:58.140
it will actually align them.

00:20:58.140 --> 00:21:00.560
As you see, the CPU
is totally idle.

00:21:00.560 --> 00:21:02.370
This is the type of
timeline you want.

00:21:02.370 --> 00:21:08.370
It's these thin hair
lines-- 16.7 milliseconds--

00:21:08.370 --> 00:21:12.190
most of that is
completely idle and empty.

00:21:12.190 --> 00:21:16.085
So you've got plenty of
space there to run your code.

00:21:19.660 --> 00:21:26.650
And we're just getting started
on making Angular Dart faster.

00:21:26.650 --> 00:21:29.080
The nice thing is
now that we have

00:21:29.080 --> 00:21:32.220
stable APIs and all
these changes in,

00:21:32.220 --> 00:21:34.420
we can keep on improving it.

00:21:34.420 --> 00:21:38.250
And with that,
I'll turn to Matan.

00:21:38.250 --> 00:21:42.192
And he'll talk about how we
do testing with Angular Dart.

00:21:42.192 --> 00:21:43.150
MATAN LUREY: All right.

00:21:43.150 --> 00:21:44.350
So we have a fast table.

00:21:44.350 --> 00:21:46.242
We have all the other fun stuff.

00:21:46.242 --> 00:21:48.200
One of the things that
we developed internally,

00:21:48.200 --> 00:21:49.940
and we never had in
external version,

00:21:49.940 --> 00:21:52.100
was an Angular
Dart specific test

00:21:52.100 --> 00:21:54.530
bed for testing
Angular Dart components

00:21:54.530 --> 00:21:55.500
for big applications.

00:21:55.500 --> 00:21:56.910
There was some testing code.

00:21:56.910 --> 00:21:57.960
It worked for some cases.

00:21:57.960 --> 00:22:00.520
But it was doing a lot of
fake things behind the scenes.

00:22:00.520 --> 00:22:01.980
It was creating fake views.

00:22:01.980 --> 00:22:04.120
And you had to hook
everything up together.

00:22:04.120 --> 00:22:06.060
So we're using a new model.

00:22:06.060 --> 00:22:07.290
We call it NgTestBed.

00:22:07.290 --> 00:22:09.560
We're power open
sourcing it today.

00:22:09.560 --> 00:22:11.790
And writing a test
with NgTestBed

00:22:11.790 --> 00:22:13.925
is actually just right
like writing a Dart test.

00:22:13.925 --> 00:22:15.820
It's using package test.

00:22:15.820 --> 00:22:17.820
And you're creating a
strongly typed component

00:22:17.820 --> 00:22:21.680
called NgTestBed, which is of
type, in this case, Markdown

00:22:21.680 --> 00:22:22.180
Component.

00:22:22.180 --> 00:22:24.430
You're actually going to
test your Markdown Component.

00:22:24.430 --> 00:22:25.495
Again, this is all typed.

00:22:25.495 --> 00:22:26.870
You're going to
create a fixture.

00:22:26.870 --> 00:22:29.210
A fixture is a running
Angular application.

00:22:29.210 --> 00:22:31.140
And when that
component is created,

00:22:31.140 --> 00:22:33.800
we're going to call
the text setter-- this

00:22:33.800 --> 00:22:38.390
is like a property-- and
assign it this Markdown value.

00:22:38.390 --> 00:22:40.510
Next line, we're
just going to expect

00:22:40.510 --> 00:22:42.040
that the inner HTML
of the template

00:22:42.040 --> 00:22:44.710
has a bolded Hello World.

00:22:44.710 --> 00:22:46.990
There's no special
code behind the scenes.

00:22:46.990 --> 00:22:49.150
This reads just like
normal Dart code.

00:22:49.150 --> 00:22:51.890
And on top of it, this is
entirely using generated code.

00:22:51.890 --> 00:22:53.520
This is a AOT test.

00:22:53.520 --> 00:22:57.650
We no longer need to
use interpretive tests.

00:22:57.650 --> 00:23:02.090
This is all using the same
production code paths.

00:23:02.090 --> 00:23:04.230
That's pretty easy
for a simple test.

00:23:04.230 --> 00:23:06.170
But when you write
more complicated views,

00:23:06.170 --> 00:23:07.670
you don't want to
keep checking, oh,

00:23:07.670 --> 00:23:10.150
did the HTML change a little
bit in this way, or what not.

00:23:10.150 --> 00:23:11.570
So we have something
we use internally

00:23:11.570 --> 00:23:13.361
at Google called Page
Loader, which is also

00:23:13.361 --> 00:23:15.350
open source, where
you can actually model

00:23:15.350 --> 00:23:17.050
your templates as Dart classes.

00:23:17.050 --> 00:23:18.550
It's kind of like
going the inverse.

00:23:18.550 --> 00:23:20.830
Angular, you create pub
components to create HTML.

00:23:20.830 --> 00:23:23.370
Now we're going to
go the other way.

00:23:23.370 --> 00:23:26.030
So this is running
a page object.

00:23:26.030 --> 00:23:29.910
There's a code lab actually now
uploaded in Angular 2 examples

00:23:29.910 --> 00:23:31.840
showing this exact code.

00:23:31.840 --> 00:23:35.240
But in this case, you're
having a selection box.

00:23:35.240 --> 00:23:38.772
You might have a selected name
up here and a Confirm button

00:23:38.772 --> 00:23:40.230
that when you click
on it, you want

00:23:40.230 --> 00:23:41.480
to confirm this is the person.

00:23:41.480 --> 00:23:43.640
Maybe this is a
reservation system.

00:23:43.640 --> 00:23:45.670
And on the right side
is our Dart class.

00:23:45.670 --> 00:23:48.230
So again, it's a pretty
plain Dart class.

00:23:48.230 --> 00:23:49.640
It's annotated a little bit.

00:23:49.640 --> 00:23:51.250
It's saying that
we have a selection

00:23:51.250 --> 00:23:52.970
class called Selection.

00:23:52.970 --> 00:23:55.880
And we have a tag called Button,
which is the Confirm button.

00:23:55.880 --> 00:23:58.780
And we have two publicly
part of the API, which

00:23:58.780 --> 00:24:02.030
is our selected
name and the ability

00:24:02.030 --> 00:24:03.720
to click the Confirm button.

00:24:03.720 --> 00:24:04.660
So this is your API.

00:24:04.660 --> 00:24:06.300
If somebody else
uses your component,

00:24:06.300 --> 00:24:08.350
they can actually use
this test infrastructure.

00:24:08.350 --> 00:24:11.290
They don't have to
write their own.

00:24:11.290 --> 00:24:13.500
And then using a page
object, again, you

00:24:13.500 --> 00:24:14.736
use the same NgTestBed.

00:24:14.736 --> 00:24:16.610
I have a little bit of
boilerplate at the top

00:24:16.610 --> 00:24:18.151
just to show more
about how it works.

00:24:18.151 --> 00:24:19.860
But we could hide this for sure.

00:24:19.860 --> 00:24:23.200
And we're creating what's
called a new HTML Page Loader.

00:24:23.200 --> 00:24:25.920
We're wrapping it around
our test bed fixture.

00:24:25.920 --> 00:24:28.109
And then we're adding a
little bit of code to say,

00:24:28.109 --> 00:24:29.650
when something
asynchronous happens--

00:24:29.650 --> 00:24:32.630
like you click on something,
you type into an input box--

00:24:32.630 --> 00:24:35.520
how do we wait for Angular
to say, everything is done.

00:24:35.520 --> 00:24:37.540
Now run the next
line of your test.

00:24:37.540 --> 00:24:38.830
So it works exactly the same.

00:24:38.830 --> 00:24:41.360
You could load an instance
of your page object--

00:24:41.360 --> 00:24:43.157
not the component,
but the page object.

00:24:43.157 --> 00:24:44.990
And you actually interact
with the component

00:24:44.990 --> 00:24:47.240
the same way a user
would, through the DOM.

00:24:47.240 --> 00:24:50.190
So here we're going to wait
that the selection was Joe User.

00:24:50.190 --> 00:24:53.530
And then we're going to
click the Confirm button.

00:24:53.530 --> 00:24:55.179
I have a demo.

00:24:55.179 --> 00:24:56.720
We're going to flip
over, and we hope

00:24:56.720 --> 00:24:58.900
everything actually works,
because demos always

00:24:58.900 --> 00:25:00.560
work at code labs.

00:25:00.560 --> 00:25:01.060
Let's see.

00:25:03.780 --> 00:25:07.640
I'm using the community
contributed Visual Studio Code

00:25:07.640 --> 00:25:08.850
plugin for Dart.

00:25:08.850 --> 00:25:10.150
Thank you so much.

00:25:10.150 --> 00:25:12.470
And we actually
have here two tests.

00:25:12.470 --> 00:25:16.715
We have a test of your
Markdown component--

00:25:16.715 --> 00:25:18.840
kind of what you saw before--
a very similar thing.

00:25:18.840 --> 00:25:20.360
FERHAT BUYUKKOTKTEN:
Are you able to see?

00:25:20.360 --> 00:25:20.540
MATAN LUREY: Do a zoom in?

00:25:20.540 --> 00:25:22.332
FERHAT BUYUKKOTKTEN:
Maybe zoom in a little.

00:25:22.332 --> 00:25:23.140
MATAN LUREY: Is that better?

00:25:23.140 --> 00:25:23.660
FERHAT BUYUKKOTKTEN: Good.

00:25:23.660 --> 00:25:24.310
MATAN LUREY: OK.

00:25:24.310 --> 00:25:25.960
So we're going to test
our Markdown component.

00:25:25.960 --> 00:25:28.418
And we're going to say, when
we decide that Hello World, we

00:25:28.418 --> 00:25:29.932
want to see Hello World.

00:25:29.932 --> 00:25:31.640
I'm going to go ahead
and pub serve this.

00:25:39.190 --> 00:25:41.210
So this is actually my app.

00:25:41.210 --> 00:25:43.270
I wrote a little GitHub
viewer for Angular Dart,

00:25:43.270 --> 00:25:45.820
just to be able to demo this.

00:25:45.820 --> 00:25:48.410
And it uses the GitHub
[INAUDIBLE] API,

00:25:48.410 --> 00:25:51.040
and it shows all of the
open issues on Angular Dart.

00:25:51.040 --> 00:25:52.710
And it looks like a
couple were added.

00:25:52.710 --> 00:25:53.210
Whoops.

00:25:53.210 --> 00:25:54.960
FERHAT BUYUKKOTKTEN: Last night.

00:25:54.960 --> 00:25:56.930
MATAN LUREY: And you
can click around here.

00:25:56.930 --> 00:26:01.030
And you can see the Markdown
rendered of the issues.

00:26:01.030 --> 00:26:02.280
And you can go around.

00:26:05.280 --> 00:26:07.720
So this is a simple
GitHub viewer.

00:26:07.720 --> 00:26:09.740
How do you test this,
is the real question.

00:26:09.740 --> 00:26:11.010
This is a pretty
complicated application.

00:26:11.010 --> 00:26:12.426
It makes network
calls and renders

00:26:12.426 --> 00:26:14.010
with lots of components.

00:26:14.010 --> 00:26:16.160
This is actually the
same way I showed before.

00:26:16.160 --> 00:26:17.600
So we're going to go over here.

00:26:17.600 --> 00:26:21.540
This is my, again, pub serve.

00:26:21.540 --> 00:26:23.100
And this isn't super exciting.

00:26:23.100 --> 00:26:25.308
But you see the words, Hello
World, and they're bold.

00:26:25.308 --> 00:26:28.040
You actually see the result
of your test in NgTestBed.

00:26:28.040 --> 00:26:31.610
You can add break points and
see incremental work done.

00:26:31.610 --> 00:26:33.040
If you open the
console right now,

00:26:33.040 --> 00:26:35.090
you'll see that all tests pass.

00:26:35.090 --> 00:26:36.530
This is using package test.

00:26:36.530 --> 00:26:39.360
Let's do a more fun one.

00:26:39.360 --> 00:26:42.280
This is actually an end-to-end
test of the entire app.

00:26:42.280 --> 00:26:44.759
This loads with a
fake GitHub service

00:26:44.759 --> 00:26:46.300
and actually clicks
around the screen

00:26:46.300 --> 00:26:48.466
is doing assertions that
everything actually worked.

00:26:48.466 --> 00:26:51.450
I'll do it one more time
because it's fast-- too fast.

00:26:51.450 --> 00:26:52.700
Sorry, Rod.

00:26:52.700 --> 00:26:53.910
So we're clicking around.

00:26:56.420 --> 00:27:00.764
And if you open your console
again, all tests pass.

00:27:00.764 --> 00:27:03.180
And I'm running a search to
make sure that none of my code

00:27:03.180 --> 00:27:07.800
breaks maybe the GitHub API
chain-- something like that.

00:27:07.800 --> 00:27:11.440
You can also run this with
Pub Run Test on travis,

00:27:11.440 --> 00:27:12.550
for example.

00:27:12.550 --> 00:27:14.730
So we're going to pub
serve just the test folder.

00:27:14.730 --> 00:27:17.780
FERHAT BUYUKKOTKTEN: So
what's awesome is typically

00:27:17.780 --> 00:27:20.130
when we try to make a
change in Angular Dart,

00:27:20.130 --> 00:27:23.680
we're running about
70,000 targets right now.

00:27:23.680 --> 00:27:28.400
So each of those targets
have one, two, 10 tests.

00:27:28.400 --> 00:27:32.040
So we have a huge
number of these in use

00:27:32.040 --> 00:27:33.880
now inside Google 3.

00:27:33.880 --> 00:27:36.700
So that helps a lot
with our stability.

00:27:36.700 --> 00:27:39.280
When we make a change,
we're very confident that it

00:27:39.280 --> 00:27:41.370
won't break your code,
and it won't break

00:27:41.370 --> 00:27:43.542
any of our own production apps.

00:27:43.542 --> 00:27:45.250
MATAN LUREY: So we
just passed two tests.

00:27:45.250 --> 00:27:46.950
These again are using
the code gen mode.

00:27:46.950 --> 00:27:49.241
This is using pub serve to
actually do code generation.

00:27:49.241 --> 00:27:50.220
This runs on travis.

00:27:50.220 --> 00:27:51.919
You can now validate
that your tests

00:27:51.919 --> 00:27:53.960
keep running the same way
they run in production.

00:27:53.960 --> 00:27:56.320
You don't have to write really
complicated web driver test,

00:27:56.320 --> 00:27:56.840
but you can.

00:28:00.390 --> 00:28:01.450
Please.

00:28:01.450 --> 00:28:05.830
FERHAT BUYUKKOTKTEN:
So Dart for web--

00:28:05.830 --> 00:28:09.680
we think Angular Dart
is a great solution.

00:28:09.680 --> 00:28:11.260
Please check it out.

00:28:11.260 --> 00:28:15.620
Give us feedback on how
we can further improve it.

00:28:15.620 --> 00:28:20.300
And we're looking forward to
seeing what you build with it.

00:28:20.300 --> 00:28:22.930
If you have any questions
on Angular Dart,

00:28:22.930 --> 00:28:25.420
we'll be around for
the next two days.

00:28:25.420 --> 00:28:27.690
Please, come and talk to us.

00:28:27.690 --> 00:28:28.190
Thank you.

00:28:28.190 --> 00:28:29.148
MATAN LUREY: Thank you.

00:28:29.148 --> 00:28:32.030
[APPLAUSE]

