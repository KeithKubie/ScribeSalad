WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.898
[MUSIC PLAYING]

00:00:07.730 --> 00:00:08.784
ADAM POWELL: So I'm Adam.

00:00:08.784 --> 00:00:09.700
CHRIS BANES: I'm Chris

00:00:09.700 --> 00:00:11.320
ADAM POWELL: And this
is Android Suspenders.

00:00:11.320 --> 00:00:12.430
Today we're going
to talk a little bit

00:00:12.430 --> 00:00:13.840
about Kotlin coroutines.

00:00:13.840 --> 00:00:16.690
But to get started, a little
bit of background-- many of you

00:00:16.690 --> 00:00:18.490
are probably familiar
with this already--

00:00:18.490 --> 00:00:20.380
is the idea of
Android's main thread.

00:00:20.380 --> 00:00:23.740
And just like almost every
other UI tool kit out there,

00:00:23.740 --> 00:00:27.100
Android exposes a
single UI or main thread

00:00:27.100 --> 00:00:29.711
for doing updates
to parts of your UI.

00:00:29.711 --> 00:00:31.210
So some of the
things that you might

00:00:31.210 --> 00:00:34.630
find yourself doing on the
main thread, inflating views.

00:00:34.630 --> 00:00:36.910
You could be doing measure
and layout operations

00:00:36.910 --> 00:00:39.830
to change the shape of
your view hierarchy.

00:00:39.830 --> 00:00:40.990
You could be drawing.

00:00:40.990 --> 00:00:42.700
Or many other
things really, like

00:00:42.700 --> 00:00:46.270
processing input events,
and so on and so forth.

00:00:46.270 --> 00:00:48.950
So today, you're
probably familiar with

00:00:48.950 --> 00:00:51.470
this 16-millisecond time limit.

00:00:51.470 --> 00:00:53.180
The vast majority
of devices out there

00:00:53.180 --> 00:00:55.130
have a refresh rate
of 60 hertz, which

00:00:55.130 --> 00:00:57.170
means that you have just
over 16 milliseconds

00:00:57.170 --> 00:00:59.270
to do all of the work
necessary in order

00:00:59.270 --> 00:01:01.440
to deliver a smooth frame rate.

00:01:01.440 --> 00:01:03.980
So what happens when that
display rate goes up?

00:01:03.980 --> 00:01:06.370
So 90 hertz means you
have 12 milliseconds.

00:01:06.370 --> 00:01:09.410
120 hertz means you
have eight milliseconds.

00:01:09.410 --> 00:01:12.060
And you have less and less time
to get some of this work done.

00:01:12.060 --> 00:01:13.730
If you take a look
at a CIS trace,

00:01:13.730 --> 00:01:15.530
you'll usually find
that the things that

00:01:15.530 --> 00:01:17.720
cause you to miss
a frame and thereby

00:01:17.720 --> 00:01:19.640
have kind of jank
in your application,

00:01:19.640 --> 00:01:21.430
is really app code.

00:01:21.430 --> 00:01:23.330
If you're binding items
to a recycler view

00:01:23.330 --> 00:01:25.650
or reading from a data
store, so on and so forth--

00:01:25.650 --> 00:01:28.100
These are all bits of work
that it would be really great

00:01:28.100 --> 00:01:29.840
if we could keep this
off of that main thread

00:01:29.840 --> 00:01:31.090
and out of this critical path.

00:01:31.090 --> 00:01:32.700
So how do we fix it?

00:01:32.700 --> 00:01:34.980
Well, this talk isn't
about achieving eight

00:01:34.980 --> 00:01:36.350
millisecond refresh boundaries.

00:01:36.350 --> 00:01:40.460
This is about making use of the
resources we have available.

00:01:40.460 --> 00:01:44.100
And all the phones that we have
multiple cores in them today.

00:01:44.100 --> 00:01:47.951
So how do we actually
make use of that?

00:01:47.951 --> 00:01:50.520
Well, some of you probably
remember this thing.

00:01:50.520 --> 00:01:53.740
It's been around for quite some
time and has a lot of issues.

00:01:53.740 --> 00:01:56.250
It composes a little
bit badly, has some

00:01:56.250 --> 00:01:57.450
issues around rotation.

00:01:57.450 --> 00:01:59.430
It's really easy to get wrong.

00:01:59.430 --> 00:02:01.230
There's executors,
which most Java

00:02:01.230 --> 00:02:03.090
developers are familiar with.

00:02:03.090 --> 00:02:05.010
And this kind of lets
you share some thread

00:02:05.010 --> 00:02:06.510
pools, which is nice.

00:02:06.510 --> 00:02:08.357
But it's otherwise kind
of a really raw API.

00:02:08.357 --> 00:02:10.440
You can build things out
of it but it's not really

00:02:10.440 --> 00:02:12.970
convenient to use on its own.

00:02:12.970 --> 00:02:15.540
Loaders-- loaders
are a thing that

00:02:15.540 --> 00:02:17.940
were certainly out there
that solved a few problems.

00:02:17.940 --> 00:02:19.740
But it was pretty
narrowly scoped.

00:02:19.740 --> 00:02:21.340
It's really now deprecated.

00:02:21.340 --> 00:02:24.680
So there's not a
whole lot there.

00:02:24.680 --> 00:02:26.049
We can use futures.

00:02:26.049 --> 00:02:28.340
There's listenable future,
which has started showing up

00:02:28.340 --> 00:02:30.140
in more AndroidX APIs.

00:02:30.140 --> 00:02:32.090
But you may not want
to pull in all of guava

00:02:32.090 --> 00:02:34.430
and all of the
infrastructure that really

00:02:34.430 --> 00:02:37.160
helps you leverage some of the
things that you can do with it.

00:02:37.160 --> 00:02:39.650
And unless you're
working on min SDK 24,

00:02:39.650 --> 00:02:41.659
you can't use
CompletableFuture either.

00:02:41.659 --> 00:02:43.700
And really there's a whole
bunch of other reasons

00:02:43.700 --> 00:02:47.100
why you might not want to
use that to begin with.

00:02:47.100 --> 00:02:49.100
So there are a lot of
other libraries out there.

00:02:49.100 --> 00:02:49.900
I mentioned guava.

00:02:49.900 --> 00:02:52.191
Guava is certainly one that
you can pull into your app.

00:02:52.191 --> 00:02:53.540
RxJava is super-popular.

00:02:53.540 --> 00:02:55.030
It's a great library.

00:02:55.030 --> 00:02:57.380
Does a lot of things well.

00:02:57.380 --> 00:02:59.800
But if you're sitting
here in this talk today,

00:02:59.800 --> 00:03:02.110
you're probably here to
talk about coroutines, which

00:03:02.110 --> 00:03:05.530
is a new feature that went
fully stable in Kotlin 1.3

00:03:05.530 --> 00:03:07.390
just this fall.

00:03:07.390 --> 00:03:10.630
So why should we use them?

00:03:10.630 --> 00:03:12.147
CHRIS BANES: Great.

00:03:12.147 --> 00:03:14.480
So when I think about this
question, I'm thinking about,

00:03:14.480 --> 00:03:16.194
what does your
typical mobile app do?

00:03:16.194 --> 00:03:17.610
And I think for
the most part, you

00:03:17.610 --> 00:03:19.220
can describe them as
kind of CRUD apps.

00:03:19.220 --> 00:03:20.720
And I don't mean
the American slang.

00:03:20.720 --> 00:03:23.250
I mean the fact that they
create, they read, they update,

00:03:23.250 --> 00:03:24.522
and they delete data.

00:03:24.522 --> 00:03:25.980
Usually its some
kind of local data

00:03:25.980 --> 00:03:28.209
source like a database
or whatever it be.

00:03:28.209 --> 00:03:30.000
And then going a bit
further, a lot of apps

00:03:30.000 --> 00:03:31.775
will also have
some kind of sync.

00:03:31.775 --> 00:03:34.050
So they'll upload data
and pull data back

00:03:34.050 --> 00:03:35.680
from some kind of web service.

00:03:35.680 --> 00:03:38.880
Now, apps are actually pretty
simple, computationally.

00:03:38.880 --> 00:03:41.490
You're not really taxing
the CPU that much, really.

00:03:41.490 --> 00:03:43.750
Yes, the logic can be
quite tricky to get right.

00:03:43.750 --> 00:03:45.730
But actually they're
pretty simple.

00:03:45.730 --> 00:03:48.380
And of course, Android, we
put a lot stuff in your way.

00:03:48.380 --> 00:03:50.131
Like, we make your life harder.

00:03:50.131 --> 00:03:51.630
But actually, your
apps are actually

00:03:51.630 --> 00:03:54.710
pretty simple from a
logic point of view.

00:03:54.710 --> 00:03:55.890
So why coroutines?

00:03:55.890 --> 00:03:57.750
Well how will they
actually fix that?

00:03:57.750 --> 00:03:59.820
Well I think that great
for I/O tasks, especially

00:03:59.820 --> 00:04:02.130
for a resource-constrained
system,

00:04:02.130 --> 00:04:05.210
like the phones and tablets
that you're using today.

00:04:05.210 --> 00:04:07.860
Now, you can't create a thread
for every network request

00:04:07.860 --> 00:04:10.020
you ever use
because threads take

00:04:10.020 --> 00:04:12.780
in the space of about a
megabyte to two megabytes of RAM

00:04:12.780 --> 00:04:14.220
every time you create one.

00:04:14.220 --> 00:04:18.371
That's why thread pulls
actually cache threads for you.

00:04:18.371 --> 00:04:19.829
Now, coroutines,
on the other hand,

00:04:19.829 --> 00:04:22.920
take in the sort of realm
of 10's of kilobytes

00:04:22.920 --> 00:04:24.250
in terms of coroutines.

00:04:24.250 --> 00:04:26.166
They use threads underneath,
but they use them

00:04:26.166 --> 00:04:28.416
in a much smarter way.

00:04:28.416 --> 00:04:31.190
Also in my mind anyway, they
have an easier development

00:04:31.190 --> 00:04:31.940
model.

00:04:31.940 --> 00:04:38.180
It's a lot easier for developers
to come into a new code source

00:04:38.180 --> 00:04:42.200
and see an imperative
line-by-line coroutine

00:04:42.200 --> 00:04:44.127
over something like
an RxJava chain.

00:04:44.127 --> 00:04:45.960
To fail to understand
what's happening there

00:04:45.960 --> 00:04:48.110
is in my mind anyway, easier.

00:04:48.110 --> 00:04:50.272
And same thing for callbacks.

00:04:50.272 --> 00:04:51.730
Everyone knows
about callback hell.

00:04:51.730 --> 00:04:54.590
And I'm to go line-by-line and
see where you've been called

00:04:54.590 --> 00:04:55.310
and stuff.

00:04:55.310 --> 00:04:59.630
And so coroutines help,
hopefully anyway, fix that.

00:04:59.630 --> 00:05:02.344
So a lot of this talk
was written in mind

00:05:02.344 --> 00:05:04.010
with a sample app
that I've been writing

00:05:04.010 --> 00:05:06.550
for the last months on Tivi.

00:05:06.550 --> 00:05:09.320
It was originally-- I
went all in on RxJava.

00:05:09.320 --> 00:05:11.120
It was RxJava from
top to bottom.

00:05:11.120 --> 00:05:13.850
And I've kind of slowly
brought coroutines into it.

00:05:13.850 --> 00:05:16.370
It's now about 50%
coroutines, 50% RxJava.

00:05:16.370 --> 00:05:17.510
So it still uses both.

00:05:17.510 --> 00:05:20.560
And I think they both have a
place in Android development.

00:05:20.560 --> 00:05:21.440
And so yeah.

00:05:21.440 --> 00:05:24.865
Go to use both.

00:05:24.865 --> 00:05:26.840
Now, as Android
developers, we have

00:05:26.840 --> 00:05:30.050
to care about APK size
and method counts.

00:05:30.050 --> 00:05:32.150
Now, in Kotlin, in
my app anyway, I'm

00:05:32.150 --> 00:05:35.780
using free libraries from the
Kotlin coroutines kind of,

00:05:35.780 --> 00:05:36.495
tree.

00:05:36.495 --> 00:05:38.300
The core, which
contains the majority

00:05:38.300 --> 00:05:39.650
of what you'll actually use.

00:05:39.650 --> 00:05:42.020
Android, which adds support
for the Android main thread,

00:05:42.020 --> 00:05:43.400
amongst other small things.

00:05:43.400 --> 00:05:46.704
And then Rx2, which allows
you to interact with Rx Java.

00:05:46.704 --> 00:05:48.870
So you're not using RxJava,
you won't need that one.

00:05:48.870 --> 00:05:50.920
It's pretty small anyway.

00:05:50.920 --> 00:05:53.190
Now, if you actually pull
down those jar files just

00:05:53.190 --> 00:05:55.280
from Maven Central,
or wherever, they

00:05:55.280 --> 00:05:57.750
would come to about
724 kilobytes.

00:05:57.750 --> 00:05:58.730
So that's quite big.

00:05:58.730 --> 00:05:59.690
And there should be--

00:05:59.690 --> 00:06:01.200
alarm bells are ringing.

00:06:01.200 --> 00:06:03.460
But once you actually
put that in your APK,

00:06:03.460 --> 00:06:05.460
it actually shrinks down
because it's packed in.

00:06:05.460 --> 00:06:07.380
And it comes down to
about 500 kilobytes.

00:06:07.380 --> 00:06:09.380
But that method references
are still quite high.

00:06:09.380 --> 00:06:13.020
That's 5% of your 64k.

00:06:13.020 --> 00:06:15.595
As soon as you turn on
Minify, and now this

00:06:15.595 --> 00:06:16.470
is just tree-shaking.

00:06:16.470 --> 00:06:19.200
So there's no optimization
turned on here.

00:06:19.200 --> 00:06:21.640
Or ProGuard, they both
have similar results.

00:06:21.640 --> 00:06:23.610
You're looking about 113K.

00:06:23.610 --> 00:06:24.850
So a lot less.

00:06:24.850 --> 00:06:27.070
And again, the method
reference is dropped.

00:06:27.070 --> 00:06:28.945
But as soon as you
turn on optimization,

00:06:28.945 --> 00:06:30.570
and then you go
through all this trying

00:06:30.570 --> 00:06:31.970
to fix all the ProGuard rules.

00:06:31.970 --> 00:06:33.780
You're coming down
that magic value which

00:06:33.780 --> 00:06:35.200
is less than 100 kilobytes.

00:06:35.200 --> 00:06:37.950
And again, your method
reference is now 834.

00:06:37.950 --> 00:06:42.830
It's less than 1% or
1% of your references.

00:06:42.830 --> 00:06:45.380
Now, one thing to note when
you're using ProGuard or R8

00:06:45.380 --> 00:06:47.080
is that you need
to use this rule.

00:06:47.080 --> 00:06:49.040
It's not currently
bundled with the jars,

00:06:49.040 --> 00:06:51.480
but hopefully it'll
be added soon.

00:06:51.480 --> 00:06:53.620
But it's a pretty
simple rule to add.

00:06:53.620 --> 00:06:54.578
ADAM POWELL: All right.

00:06:57.220 --> 00:06:59.350
So hopefully by
now you're thinking

00:06:59.350 --> 00:07:01.730
about how you might use
coroutines in your app.

00:07:01.730 --> 00:07:03.355
So let's go ahead
and talk a little bit

00:07:03.355 --> 00:07:04.820
about actually writing them.

00:07:04.820 --> 00:07:08.110
So anything that you can do with
a one-shot callback or future,

00:07:08.110 --> 00:07:09.779
you can do with a
suspend function.

00:07:09.779 --> 00:07:11.320
Everything with
coroutines is kind of

00:07:11.320 --> 00:07:14.050
based around this idea
of suspending function

00:07:14.050 --> 00:07:15.939
as a basis for creating APIs.

00:07:15.939 --> 00:07:17.980
Suspend functions can stop
and yield their thread

00:07:17.980 --> 00:07:18.790
without blocking.

00:07:18.790 --> 00:07:21.190
And they can be resumed
later like a callback.

00:07:21.190 --> 00:07:23.860
And they can only be called
from another suspend function.

00:07:23.860 --> 00:07:26.536
So just to setup all the
machinery involved in that.

00:07:26.536 --> 00:07:28.660
But the core thing here is
that all of this kind of

00:07:28.660 --> 00:07:29.569
fits on one slide.

00:07:29.569 --> 00:07:30.610
There's less to remember.

00:07:30.610 --> 00:07:32.410
The rest of the language
still works the same

00:07:32.410 --> 00:07:33.970
in the presence of
suspend functions.

00:07:33.970 --> 00:07:37.630
And we'll spend the rest of
the talk talking about that.

00:07:37.630 --> 00:07:40.200
So here's a suspending
method from Chris's app.

00:07:40.200 --> 00:07:42.631
Actually, this is a data
repository for TV shows.

00:07:42.631 --> 00:07:44.880
So you go ahead and you call
this update show function

00:07:44.880 --> 00:07:46.200
with an ID.

00:07:46.200 --> 00:07:49.245
We get some shows.

00:07:49.245 --> 00:07:53.030
And we get a little bit more
data from a remote source.

00:07:53.030 --> 00:07:55.880
And a little bit more
data from a second source.

00:07:55.880 --> 00:08:00.740
Finally, we merge all that
together and we save that data.

00:08:00.740 --> 00:08:03.730
So these three main tasks where
we spend the bulk of the time,

00:08:03.730 --> 00:08:05.195
these are done sequentially.

00:08:05.195 --> 00:08:07.570
But none of these tasks have
a dependency on one another.

00:08:07.570 --> 00:08:10.650
So wouldn't it be nice if we
could do this concurrently?

00:08:10.650 --> 00:08:14.012
So with the async
builder, we can do this.

00:08:14.012 --> 00:08:15.970
So we're going to start
from the very top here.

00:08:15.970 --> 00:08:17.524
We start by opening
coroutine scope.

00:08:17.524 --> 00:08:18.940
And this is important
because this

00:08:18.940 --> 00:08:21.610
allows us to perform this
parallel decomposition using

00:08:21.610 --> 00:08:22.680
the async builder.

00:08:22.680 --> 00:08:25.120
It brings a coroutine
scope receiver

00:08:25.120 --> 00:08:28.620
in the scope for this
lambda block that we have.

00:08:28.620 --> 00:08:31.330
So first we build
the async operation.

00:08:31.330 --> 00:08:32.380
And the second.

00:08:32.380 --> 00:08:34.280
And the third.

00:08:34.280 --> 00:08:36.909
And then we await the
result of each one, in turn.

00:08:36.909 --> 00:08:38.559
So the nice thing
here is that we've

00:08:38.559 --> 00:08:40.030
launched all of
these things, let

00:08:40.030 --> 00:08:42.429
them run kind of
independently, and then we

00:08:42.429 --> 00:08:44.510
bring them back together again.

00:08:44.510 --> 00:08:48.190
So since all of these things
can be now done in parallel,

00:08:48.190 --> 00:08:49.780
things should complete faster.

00:08:49.780 --> 00:08:51.852
So trying to do this
with raw threads by hand

00:08:51.852 --> 00:08:53.560
would be a lot more
code, which you would

00:08:53.560 --> 00:08:55.632
need to maintain along the way.

00:08:55.632 --> 00:08:57.840
So the async builder
is for when we

00:08:57.840 --> 00:08:59.755
want to run something
and then later await

00:08:59.755 --> 00:09:02.130
the result after giving it a
chance to finish while we're

00:09:02.130 --> 00:09:03.300
doing something else.

00:09:03.300 --> 00:09:07.266
It's very similar to C#
or promises in JavaScript.

00:09:07.266 --> 00:09:09.890
So what about when you just want
to launch something and forget

00:09:09.890 --> 00:09:10.370
about it, though?

00:09:10.370 --> 00:09:11.810
Well, there's
something for that too.

00:09:11.810 --> 00:09:12.830
It's just called launch.

00:09:12.830 --> 00:09:16.010
It works pretty
much the same way.

00:09:16.010 --> 00:09:19.030
So in this case, it
is a lot more similar

00:09:19.030 --> 00:09:22.137
to executors and just
sort of submitting a task,

00:09:22.137 --> 00:09:24.470
submitting something to an
Android Handler, for example.

00:09:24.470 --> 00:09:27.650
When we just want to fire and
forget and deal with it later.

00:09:27.650 --> 00:09:30.960
So that's a little bit about
the basics of running coroutines

00:09:30.960 --> 00:09:31.890
in isolation.

00:09:31.890 --> 00:09:34.200
How do you run them
on Android, though?

00:09:34.200 --> 00:09:37.367
So in this case, you might have
an arch components ViewModel.

00:09:37.367 --> 00:09:39.450
And wouldn't be nice if
we had kind of an easy way

00:09:39.450 --> 00:09:41.707
to put all this stuff
together automatically?

00:09:41.707 --> 00:09:43.290
We need it to be
able to open a scope.

00:09:43.290 --> 00:09:45.240
So where do you get
one of those things

00:09:45.240 --> 00:09:47.850
to begin with that you
can launch things into?

00:09:47.850 --> 00:09:49.470
Well, in this
case, our ViewModel

00:09:49.470 --> 00:09:52.060
has a show repository,
which is our data layer.

00:09:52.060 --> 00:09:54.870
And we have a view state that
the viewer activity or fragment

00:09:54.870 --> 00:09:56.060
can observe.

00:09:56.060 --> 00:09:58.420
We can refresh on construction.

00:09:58.420 --> 00:10:00.210
And when we actually
go to refresh,

00:10:00.210 --> 00:10:02.970
we launch into this new
ViewModel scope extension

00:10:02.970 --> 00:10:03.621
property.

00:10:03.621 --> 00:10:05.745
This is coming very soon
to the AndroidX libraries.

00:10:05.745 --> 00:10:07.410
So those of you
who like to watch

00:10:07.410 --> 00:10:10.500
commits in AOSP might have
seen this going already.

00:10:10.500 --> 00:10:12.440
So the refresh function
launches a coroutine,

00:10:12.440 --> 00:10:14.640
uses the launch builder,
which then calls the update

00:10:14.640 --> 00:10:16.170
function on the repository.

00:10:16.170 --> 00:10:18.420
And our coroutine resumes
back on the main thread

00:10:18.420 --> 00:10:20.145
after update show returns.

00:10:20.145 --> 00:10:22.770
So we can safely manipulate our
view hierarchy with the results

00:10:22.770 --> 00:10:24.030
just on the next line of code.

00:10:24.030 --> 00:10:26.250
We have this nice, clean,
sequential ordering

00:10:26.250 --> 00:10:27.990
of operations.

00:10:27.990 --> 00:10:30.240
So those of you who
want to go check

00:10:30.240 --> 00:10:33.540
out this thing that's upcoming,
you can go to this link.

00:10:33.540 --> 00:10:35.850
Take a look at the
change so far in advance

00:10:35.850 --> 00:10:36.780
of the actual release.

00:10:36.780 --> 00:10:40.050
This is coming in an upcoming
release of our KTX libraries.

00:10:40.050 --> 00:10:42.330
So let's ahead and
demystify how some of this

00:10:42.330 --> 00:10:43.150
works a little bit.

00:10:43.150 --> 00:10:44.922
But before we can
go too, too deep,

00:10:44.922 --> 00:10:46.380
we need to start
talking about some

00:10:46.380 --> 00:10:49.159
of the other primitives that
are at work under the hood here.

00:10:49.159 --> 00:10:49.950
CHRIS BANES: Great.

00:10:49.950 --> 00:10:52.116
And so we are going to talk
about jobs a little bit.

00:10:52.116 --> 00:10:54.002
So what is a job?

00:10:54.002 --> 00:10:56.460
Here, when you actually look
at this code snippet-- the one

00:10:56.460 --> 00:10:58.520
we just looked at from Adam.

00:10:58.520 --> 00:11:00.270
You're actually using
the launch method.

00:11:00.270 --> 00:11:02.520
Now, when you actually
run that launch method,

00:11:02.520 --> 00:11:04.050
it returns what we call a job.

00:11:04.050 --> 00:11:07.170
A job allows us to
keep a reference

00:11:07.170 --> 00:11:08.725
of that ongoing piece of work.

00:11:08.725 --> 00:11:10.300
And it has really
one method on it.

00:11:10.300 --> 00:11:12.080
And it's called cancel.

00:11:12.080 --> 00:11:13.470
Now obviously in
this example, we

00:11:13.470 --> 00:11:14.730
wouldn't just call
cancel straightaway

00:11:14.730 --> 00:11:16.021
after we've launched something.

00:11:16.021 --> 00:11:18.160
That would be ridiculous.

00:11:18.160 --> 00:11:20.610
But what it does allow us
to do is handle something

00:11:20.610 --> 00:11:22.010
like double-refreshes.

00:11:22.010 --> 00:11:23.760
If you have something
like pull-to-refresh

00:11:23.760 --> 00:11:25.480
in your app and an
automatic refresh,

00:11:25.480 --> 00:11:27.480
you don't want them both
to happen at same time.

00:11:27.480 --> 00:11:30.485
And then you have two things
happen at the same time.

00:11:30.485 --> 00:11:32.610
So here this code snippet,
you can keep a reference

00:11:32.610 --> 00:11:34.496
to the one that's
currently running.

00:11:34.496 --> 00:11:36.870
And if it happens again-- like
a refresh is called-- then

00:11:36.870 --> 00:11:38.320
you can cancel the first one.

00:11:38.320 --> 00:11:40.690
And so that's kind
of how job works.

00:11:40.690 --> 00:11:42.282
It's a very simple
object that allows

00:11:42.282 --> 00:11:44.490
you to keep a reference of
the ongoing piece of work.

00:11:47.390 --> 00:11:49.720
So you may have seen
that little scope thing

00:11:49.720 --> 00:11:50.797
and wondered what it is.

00:11:50.797 --> 00:11:51.880
Adam explained it earlier.

00:11:51.880 --> 00:11:55.540
And you can have a scope
and it provides you

00:11:55.540 --> 00:11:59.500
with all the context you need
to run a launch or an async.

00:11:59.500 --> 00:12:02.550
So let's take a look at how
they actually work underneath.

00:12:02.550 --> 00:12:04.740
So coroutine scope
is an interface

00:12:04.740 --> 00:12:09.240
that allows objects to provide
a scope for coroutines.

00:12:09.240 --> 00:12:12.050
Think things like
things with a lifecycle.

00:12:12.050 --> 00:12:14.640
So fragments, activities,
view model even.

00:12:14.640 --> 00:12:17.310
And they can provide a lifecycle
for the coroutine itself.

00:12:17.310 --> 00:12:19.930
And start and stop
it as it needs.

00:12:19.930 --> 00:12:23.610
Async and launch used to be
the sort of global methods.

00:12:23.610 --> 00:12:27.720
And now a recent refactor
brought them as instant methods

00:12:27.720 --> 00:12:30.660
on the coroutine scope.

00:12:30.660 --> 00:12:32.370
What it means is,
mentally anyway,

00:12:32.370 --> 00:12:34.440
is that instead of just
launching something,

00:12:34.440 --> 00:12:37.350
you're launching
a coroutine on x.

00:12:37.350 --> 00:12:39.740
So I'm launching a
coroutine on the activity.

00:12:39.740 --> 00:12:41.600
You just change that
mentally in your head

00:12:41.600 --> 00:12:44.059
in that it's tied to the
lifecycle of something else.

00:12:44.059 --> 00:12:44.850
ADAM POWELL: Right.

00:12:44.850 --> 00:12:47.640
If you're used to working
with the lifecycle owner

00:12:47.640 --> 00:12:49.200
in arch components,
so far, you know

00:12:49.200 --> 00:12:52.200
the lifecycle owner has a
lifecycle that you can then

00:12:52.200 --> 00:12:53.430
observe and attach things to.

00:12:53.430 --> 00:12:56.272
Similarly, a coroutine scope
has a coroutine context

00:12:56.272 --> 00:12:58.230
that carries along
everything necessary to know

00:12:58.230 --> 00:12:59.640
how to launch a coroutine.

00:12:59.640 --> 00:13:01.140
CHRIS BANES: Some
of the stuff we're

00:13:01.140 --> 00:13:02.470
going to talk about in a bit.

00:13:02.470 --> 00:13:05.762
And similarly, coroutine scopes
provide a default context.

00:13:05.762 --> 00:13:08.220
So you can provide a default
context for all the coroutines

00:13:08.220 --> 00:13:09.420
that were ever run on it.

00:13:09.420 --> 00:13:11.169
So I think things like
what kind of thread

00:13:11.169 --> 00:13:13.800
pull or dispatch it
runs on, the job--

00:13:13.800 --> 00:13:16.110
the parent job-- that allows
you to cancel it later.

00:13:16.110 --> 00:13:17.818
And other things which
you can add to it.

00:13:17.818 --> 00:13:20.629
It's basically a
map for context.

00:13:20.629 --> 00:13:21.920
ADAM POWELL: And it's on again.

00:13:21.920 --> 00:13:23.480
CHRIS BANES: --again.

00:13:23.480 --> 00:13:25.670
It's a good day for slides.

00:13:25.670 --> 00:13:26.420
Oh, we're back?

00:13:26.420 --> 00:13:27.300
OK, cool.

00:13:27.300 --> 00:13:29.279
So let's take a look
at another example.

00:13:29.279 --> 00:13:31.070
This time we're not
going to use view model

00:13:31.070 --> 00:13:33.260
scope, the automated thing
we've added to AndroidX.

00:13:33.260 --> 00:13:35.150
We're going to write
it out ourselves.

00:13:35.150 --> 00:13:37.672
And so here you can see
that we've created a job.

00:13:37.672 --> 00:13:39.380
And now it's just a
simple instantiation.

00:13:39.380 --> 00:13:41.090
We're going to keep
a reference to it.

00:13:41.090 --> 00:13:45.680
And then we're going to create
a coroutine scope using our job.

00:13:45.680 --> 00:13:47.900
And that means that
anything that runs on it

00:13:47.900 --> 00:13:51.020
allows us to track back
using that job object.

00:13:51.020 --> 00:13:53.390
We're also going to give
it a default dispatcher.

00:13:53.390 --> 00:13:55.140
We're going to talk
more about that later.

00:13:55.140 --> 00:13:56.973
But basically what it
means is that anything

00:13:56.973 --> 00:13:59.600
that is launched on that scope
will be automatically run

00:13:59.600 --> 00:14:04.670
on the main thread-- the Android
main thread in this example.

00:14:04.670 --> 00:14:07.530
So once we've done that, we
have our refresh method again.

00:14:07.530 --> 00:14:09.000
And this time, instead of
that view model scope--

00:14:09.000 --> 00:14:10.375
the automated
thing-- we're going

00:14:10.375 --> 00:14:11.650
to use our own created scope.

00:14:11.650 --> 00:14:13.233
And again, it's
exactly the same code.

00:14:13.233 --> 00:14:15.730
But it's just using a different
type of scope this time.

00:14:15.730 --> 00:14:18.740
But this time the launch
will be scoped to the job

00:14:18.740 --> 00:14:21.327
object we created
earlier, which means

00:14:21.327 --> 00:14:23.160
that in our uncleared,
which is the callback

00:14:23.160 --> 00:14:24.909
we have in ViewModel,
to actually not when

00:14:24.909 --> 00:14:25.899
it's been torn down.

00:14:25.899 --> 00:14:27.690
We can actually just
call job got canceled.

00:14:27.690 --> 00:14:29.280
And that means that any
coroutines which are currently

00:14:29.280 --> 00:14:30.840
running when the
ViewModel goes down

00:14:30.840 --> 00:14:32.290
will be canceled
at the same time.

00:14:32.290 --> 00:14:34.890
It reduces memory leaks
or whatever it is.

00:14:34.890 --> 00:14:38.205
It just allows it to tidy up.

00:14:38.205 --> 00:14:41.527
So if you actually have a look
at how things are run now,

00:14:41.527 --> 00:14:42.860
so we've launched our coroutine.

00:14:42.860 --> 00:14:46.140
And now we're going to go into
our update sharing method.

00:14:46.140 --> 00:14:48.117
So here we are in our coroutine.

00:14:48.117 --> 00:14:50.200
So our launch, which is
modeled by that blue thing

00:14:50.200 --> 00:14:51.480
going around.

00:14:51.480 --> 00:14:53.180
Now, here in the
updateShow method,

00:14:53.180 --> 00:14:55.445
which is denoted by the
yellow arrow-- so we're going

00:14:55.445 --> 00:14:56.820
go past that first
piece of code,

00:14:56.820 --> 00:14:58.310
which is the async builder.

00:14:58.310 --> 00:15:00.830
At this point, we have a
first coroutine running,

00:15:00.830 --> 00:15:01.550
which now racing.

00:15:01.550 --> 00:15:03.383
And that's doing the
local show still stuff.

00:15:03.383 --> 00:15:06.510
So it's running nicely
and it's doing its thing.

00:15:06.510 --> 00:15:08.510
Now the outer coroutine
is going to go past that

00:15:08.510 --> 00:15:11.290
and go past the second
async which is the remote.

00:15:11.290 --> 00:15:14.485
Here, again, so we now have
two coroutines running.

00:15:14.485 --> 00:15:16.110
Well, we have three
coroutines running.

00:15:16.110 --> 00:15:19.270
But two inner ones,
two child coroutines.

00:15:19.270 --> 00:15:22.130
So once they launch and they
are running and going along,

00:15:22.130 --> 00:15:24.597
we fall onto the first to wait.

00:15:24.597 --> 00:15:26.930
Now, at this point, we're
waiting for that first async--

00:15:26.930 --> 00:15:27.740
the local--

00:15:27.740 --> 00:15:29.120
to actually finish itself off.

00:15:29.120 --> 00:15:32.720
And then return a result, which
is what await will return.

00:15:32.720 --> 00:15:36.440
But at this point, because we're
waiting on that first async,

00:15:36.440 --> 00:15:38.480
the outer coroutine is
what we call suspended.

00:15:38.480 --> 00:15:41.394
It's just sat there
doing nothing.

00:15:41.394 --> 00:15:43.992
But during that time, that
view model has been torn down.

00:15:43.992 --> 00:15:45.700
I don't know, the
activity has gone away.

00:15:45.700 --> 00:15:47.486
Or whatever it will be.

00:15:47.486 --> 00:15:49.360
And we called job.cancel.

00:15:49.360 --> 00:15:51.850
Now, this point, the outer
coroutine, is canceled.

00:15:51.850 --> 00:15:54.220
And then the inner
two are also canceled.

00:15:54.220 --> 00:15:56.770
And now some of that
coroutine scope gives us--

00:15:56.770 --> 00:15:58.790
and scoping in general
gives us for free.

00:15:58.790 --> 00:16:00.414
And that child
coroutines automatically

00:16:00.414 --> 00:16:02.080
inherit from its
parent coroutine.

00:16:02.080 --> 00:16:04.030
So if the parent coroutine
has been canceled,

00:16:04.030 --> 00:16:05.360
anything below it will also be.

00:16:05.360 --> 00:16:08.909
That some of the nice stuff
that has been added recently.

00:16:08.909 --> 00:16:10.950
But what if you're not
actually using ViewModels?

00:16:10.950 --> 00:16:12.783
You know, a lot of us
might not be using it.

00:16:12.783 --> 00:16:15.180
And then we have
other APIs which later

00:16:15.180 --> 00:16:16.824
do similar type of things.

00:16:16.824 --> 00:16:18.990
So it's part of the Android
architecture components.

00:16:18.990 --> 00:16:22.360
We added a list of
functionality for life cycles.

00:16:22.360 --> 00:16:25.260
So here's a very quick example
of how you use them generally.

00:16:25.260 --> 00:16:26.660
You create a lifecycle observer.

00:16:26.660 --> 00:16:29.095
And in this example,
we're using default.

00:16:29.095 --> 00:16:30.992
And when you create--
it has methods

00:16:30.992 --> 00:16:32.950
for each of the different
lifecycle events-- so

00:16:32.950 --> 00:16:35.842
on create, destroyed, stop,
start, whatever it be.

00:16:35.842 --> 00:16:38.040
And to actually use it
on like an activity,

00:16:38.040 --> 00:16:40.665
or whatever it be, you create an
instance and you add observer.

00:16:40.665 --> 00:16:44.040
Hopefully, you've
seen this API before.

00:16:44.040 --> 00:16:47.770
So this builds a kind of scope
where lifecycle observer which

00:16:47.770 --> 00:16:51.760
allows us to scope coroutines
to an actual lifecycle instance.

00:16:51.760 --> 00:16:53.200
The primary API
we'll use here is

00:16:53.200 --> 00:16:54.580
that we're passing the lambda.

00:16:54.580 --> 00:16:57.734
And that's the thing that we
run once we've been started.

00:16:57.734 --> 00:16:59.400
Which is kind of what
you want, usually.

00:16:59.400 --> 00:17:01.630
Most of the time.

00:17:01.630 --> 00:17:04.567
So we'll now look
at implementation.

00:17:04.567 --> 00:17:06.400
So the first thing we
want to do is on stop.

00:17:06.400 --> 00:17:09.380
So that's when we'll start
running that piece of code.

00:17:09.380 --> 00:17:11.560
So we'll create a coroutine
scope using a job.

00:17:11.560 --> 00:17:13.599
And then we're going to run
it on the dispatches domain.

00:17:13.599 --> 00:17:14.900
You can choose
what that will be.

00:17:14.900 --> 00:17:16.720
And then we'll call
script.launch, and then

00:17:16.720 --> 00:17:17.710
just call our lambda.

00:17:17.710 --> 00:17:19.760
Pretty simple, really.

00:17:19.760 --> 00:17:22.089
And then finally, a
nonstop, which seems

00:17:22.089 --> 00:17:25.780
like a good lifecycle to use,
that we'll call in that code,

00:17:25.780 --> 00:17:27.550
but will eventually
cancel the job.

00:17:27.550 --> 00:17:28.966
And that will mean
that coroutine,

00:17:28.966 --> 00:17:31.226
if it's still running at
that point will be canceled.

00:17:31.226 --> 00:17:34.091
So you can see that code
isn't actually that complex.

00:17:34.091 --> 00:17:36.190
It's AndroidX, so
it's not nice to use.

00:17:36.190 --> 00:17:38.680
But actually, if you look
at the deep down of it,

00:17:38.680 --> 00:17:41.140
it's actually pretty simple.

00:17:41.140 --> 00:17:42.810
And then to actually
finish it all off,

00:17:42.810 --> 00:17:44.380
we'll provide a
nice build function.

00:17:44.380 --> 00:17:46.504
And you pass it a lambda,
and it will automatically

00:17:46.504 --> 00:17:48.536
add the Observer for you.

00:17:48.536 --> 00:17:51.410
And what it allows us to
do is stuff like this.

00:17:51.410 --> 00:17:53.245
So here, we have
a DetailsFragment

00:17:53.245 --> 00:17:54.730
and onViewCreated.

00:17:54.730 --> 00:17:57.130
We will use our liveScope
extension function

00:17:57.130 --> 00:17:58.620
and then just run something.

00:17:58.620 --> 00:18:01.390
And that will automatically
start it when we get to--

00:18:01.390 --> 00:18:03.890
well, it will be started when
we go start a new fragment.

00:18:03.890 --> 00:18:09.984
And it will be closed or
ended when we get on stop.

00:18:09.984 --> 00:18:11.650
All right, brings us
on to cancellation.

00:18:11.650 --> 00:18:12.190
ADAM POWELL: Right.

00:18:12.190 --> 00:18:14.731
We've talked a lot about this
idea of cancelling a coroutine.

00:18:14.731 --> 00:18:17.084
But what actually happens
when this thing cancels?

00:18:17.084 --> 00:18:19.750
I mean, if you just have kind of
a block of code that's running,

00:18:19.750 --> 00:18:20.920
what gets torn down?

00:18:20.920 --> 00:18:23.610
What do you need
to do to clean up?

00:18:23.610 --> 00:18:26.440
So when a routine
is canceled, if it's

00:18:26.440 --> 00:18:28.420
canceled while
it's suspended-- so

00:18:28.420 --> 00:18:30.370
it's waiting on
something else to happen.

00:18:30.370 --> 00:18:33.880
In callback terms, the callback
just hasn't been invoked yet.

00:18:33.880 --> 00:18:35.770
It will throw a
cancellation exception,

00:18:35.770 --> 00:18:38.260
or rather, the coroutine
will resume from the point

00:18:38.260 --> 00:18:42.139
that it was suspended with
a cancellation exception.

00:18:42.139 --> 00:18:43.680
So what does that
actually look like?

00:18:43.680 --> 00:18:45.040
Here's our example from before.

00:18:45.040 --> 00:18:47.040
So what happens if we
need to clean something up

00:18:47.040 --> 00:18:49.230
if this is canceled in the
middle of that updateShow

00:18:49.230 --> 00:18:50.790
function?

00:18:50.790 --> 00:18:53.800
Well, because it throws
a cancellation exception.

00:18:53.800 --> 00:18:56.310
This is something that we kind
of know how to do already.

00:18:56.310 --> 00:18:58.239
Plain old finally
blocks runs expected.

00:18:58.239 --> 00:19:00.780
We didn't have to add any new
concepts beyond what we already

00:19:00.780 --> 00:19:03.470
know from the rest of Kotlin.

00:19:03.470 --> 00:19:05.820
But if blocking code is
running, cancellation

00:19:05.820 --> 00:19:07.920
requires some explicit
cooperation in order

00:19:07.920 --> 00:19:09.876
to stop what it's doing.

00:19:09.876 --> 00:19:11.920
So we can check for
that cancellation

00:19:11.920 --> 00:19:14.610
explicitly in a couple of ways.

00:19:14.610 --> 00:19:16.240
Generally, this
means checking to see

00:19:16.240 --> 00:19:18.620
if your coroutine is currently
active in one way, shape,

00:19:18.620 --> 00:19:19.120
or form.

00:19:19.120 --> 00:19:21.970
And there are a couple of
useful patterns for doing this.

00:19:21.970 --> 00:19:23.950
So one of those
patterns is that if you

00:19:23.950 --> 00:19:25.960
know that your job
is already canceled,

00:19:25.960 --> 00:19:27.490
you can call any
one of the stock

00:19:27.490 --> 00:19:31.000
suspending methods, such as
yield used is the example here,

00:19:31.000 --> 00:19:32.950
to force a cancellation
exception be thrown,

00:19:32.950 --> 00:19:35.491
relying on that standards and
implementation that I mentioned

00:19:35.491 --> 00:19:39.424
before, that if you're canceled
when you're trying to suspend,

00:19:39.424 --> 00:19:41.590
then you'll resume with
that cancellation exception.

00:19:41.590 --> 00:19:43.390
So we know that this
will immediately throw

00:19:43.390 --> 00:19:45.910
if we happen to be canceled.

00:19:45.910 --> 00:19:47.350
But if you're in
a tight loop, you

00:19:47.350 --> 00:19:49.540
can also just
check this isActive

00:19:49.540 --> 00:19:52.750
that's available from
any suspending scope.

00:19:52.750 --> 00:19:54.790
And you can just simply
stop what you're doing.

00:19:54.790 --> 00:19:57.050
There's no reason to really
involve an exception here

00:19:57.050 --> 00:19:59.716
if all you're doing is some sort
of tight inner computation loop

00:19:59.716 --> 00:20:02.346
that you need to break out of.

00:20:02.346 --> 00:20:05.180
Which kind of leads nicely up
into how exceptions are handled

00:20:05.180 --> 00:20:06.306
with coroutines in general.

00:20:06.306 --> 00:20:08.888
And there are a few things that
are really worth pointing out,

00:20:08.888 --> 00:20:11.390
especially if you followed
some of the kotlinx.coroutines

00:20:11.390 --> 00:20:12.770
development leading
up to release

00:20:12.770 --> 00:20:15.061
because there were some really
significant changes that

00:20:15.061 --> 00:20:16.250
happened.

00:20:16.250 --> 00:20:20.150
The first is that launch will
rethrow unhandled exceptions

00:20:20.150 --> 00:20:21.200
as they happen.

00:20:21.200 --> 00:20:23.270
So more precisely,
it fails the parent.

00:20:23.270 --> 00:20:25.550
It cancels its parent job.

00:20:25.550 --> 00:20:27.470
The parent sees a
cancellation exception

00:20:27.470 --> 00:20:30.560
with the original exception
as the cause in the exception

00:20:30.560 --> 00:20:31.970
object itself.

00:20:31.970 --> 00:20:34.460
So similar to a thread, they
get dispatched to the default

00:20:34.460 --> 00:20:36.410
exception handler at
the root of a job tree

00:20:36.410 --> 00:20:39.020
if nothing else
manages to handle that.

00:20:39.020 --> 00:20:42.470
But your coroutine context also
gets a chance to intercept.

00:20:42.470 --> 00:20:45.710
You can attach a special element
to the coroutine context itself

00:20:45.710 --> 00:20:49.625
that you can use to handle
unhandled exceptions.

00:20:49.625 --> 00:20:52.116
So let's go ahead and
see how that works.

00:20:52.116 --> 00:20:53.740
Here's, again, our
example from before.

00:20:53.740 --> 00:20:57.460
And say that saveShow throws a
very domain-specific exception

00:20:57.460 --> 00:20:58.954
in this case.

00:20:58.954 --> 00:21:01.050
So in this case,
this will treated

00:21:01.050 --> 00:21:02.790
like an uncaught
exception at runtime

00:21:02.790 --> 00:21:05.610
just like anything else that
throws an uncaught exception

00:21:05.610 --> 00:21:07.930
on your main thread.

00:21:07.930 --> 00:21:10.830
So async is a little
bit different.

00:21:10.830 --> 00:21:12.650
If an exception's
thrown while something

00:21:12.650 --> 00:21:14.270
that you launch with
async is running,

00:21:14.270 --> 00:21:16.170
it'll hold onto that
exception and only throw

00:21:16.170 --> 00:21:18.650
when the caller calls await.

00:21:18.650 --> 00:21:21.730
So coming back to our
example from before again,

00:21:21.730 --> 00:21:24.190
let's go ahead and
use what we know.

00:21:24.190 --> 00:21:28.090
We throw our exception from
one of these async jobs.

00:21:28.090 --> 00:21:30.980
But that gets thrown from
this call to await itself.

00:21:30.980 --> 00:21:33.500
So we know exactly where
we need to try and catch

00:21:33.500 --> 00:21:35.570
that exception just kind
of in the normal way

00:21:35.570 --> 00:21:37.820
and handle that error.

00:21:37.820 --> 00:21:39.060
But there's a gotcha here.

00:21:39.060 --> 00:21:41.280
And that's that async
works the same way

00:21:41.280 --> 00:21:44.820
as launch in terms of how this
nested job tree is handled.

00:21:44.820 --> 00:21:46.740
The deferred object
that it returns

00:21:46.740 --> 00:21:48.360
is just another kind of job.

00:21:48.360 --> 00:21:50.130
And so it'll cancel
the parent if it

00:21:50.130 --> 00:21:51.900
fails with an
unhandled exception,

00:21:51.900 --> 00:21:53.350
just like launch does.

00:21:53.350 --> 00:21:56.350
And it'll do this even if we
did it an await and called it.

00:21:56.350 --> 00:21:59.202
Now this is kind of important
because if something throws

00:21:59.202 --> 00:22:00.660
an exception, it's
really important

00:22:00.660 --> 00:22:01.826
that your app know about it.

00:22:01.826 --> 00:22:03.827
Like it shouldn't just
disappear into the ether.

00:22:03.827 --> 00:22:05.451
But at the same time
it kind of defeats

00:22:05.451 --> 00:22:07.350
the purpose of the code
in this sample here.

00:22:07.350 --> 00:22:08.070
We caught it.

00:22:08.070 --> 00:22:10.430
What are we supposed to do here?

00:22:10.430 --> 00:22:12.810
Well, in this case, instead
of using coroutine scope

00:22:12.810 --> 00:22:15.510
at the top to open up this
parallel decomposition,

00:22:15.510 --> 00:22:17.070
we can use supervisorScope.

00:22:17.070 --> 00:22:18.900
It works exactly
like coroutineScope,

00:22:18.900 --> 00:22:20.730
except with a
supervisor job, which

00:22:20.730 --> 00:22:22.200
is a special kind
of job that won't

00:22:22.200 --> 00:22:25.754
be canceled if a child fails
with an unhandled exception.

00:22:28.360 --> 00:22:29.980
One more spot-- yep.

00:22:29.980 --> 00:22:33.084
It will only be thrown from
this await method here.

00:22:33.084 --> 00:22:34.470
CHRIS BANES: Cool.

00:22:34.470 --> 00:22:36.720
So earlier, we mentioned
that we can actually

00:22:36.720 --> 00:22:39.240
decide where coroutine run
and what kind of thread

00:22:39.240 --> 00:22:39.970
they run on.

00:22:39.970 --> 00:22:42.060
Because actually on
the JVM and on Android,

00:22:42.060 --> 00:22:43.680
we actually still
run on threads.

00:22:43.680 --> 00:22:45.711
It still uses a thread
pool underneath.

00:22:45.711 --> 00:22:47.460
So we still can decide
where that actually

00:22:47.460 --> 00:22:50.040
gets dispatched on.

00:22:50.040 --> 00:22:50.999
Now let's have a look.

00:22:50.999 --> 00:22:53.040
So here we have our launch,
a very simple launch,

00:22:53.040 --> 00:22:54.081
which is missing a scope.

00:22:54.081 --> 00:22:55.930
But just look at the example.

00:22:55.930 --> 00:22:58.620
Now, default actually
is that the context

00:22:58.620 --> 00:23:00.954
will be used in what we
call a Dispatchers.Default.

00:23:00.954 --> 00:23:02.370
That's a default
dispatcher that's

00:23:02.370 --> 00:23:04.245
kind of given for you for free.

00:23:04.245 --> 00:23:06.870
And it's supposed to be sort of
default for everything, really.

00:23:06.870 --> 00:23:09.090
ADAM POWELL: It's essentially
a computation thread pool,

00:23:09.090 --> 00:23:10.964
if you're used to using
that from our RxJava.

00:23:10.964 --> 00:23:12.990
CHRIS BANES: So what is
a coroutine dispatcher?

00:23:12.990 --> 00:23:14.647
Which is what it basically is.

00:23:14.647 --> 00:23:16.980
Well, it's the thing which
runs and schedules coroutine,

00:23:16.980 --> 00:23:17.938
as I mentioned earlier.

00:23:17.938 --> 00:23:20.450
It schedules coroutines
to run on something,

00:23:20.450 --> 00:23:23.360
on a thread in our case.

00:23:23.360 --> 00:23:27.000
Now, Dispatchers.Default, which
is the default which you get,

00:23:27.000 --> 00:23:29.520
is that it uses
cpuCount threads.

00:23:29.520 --> 00:23:32.100
So your device has
four CPUs in it.

00:23:32.100 --> 00:23:34.530
You will get a
thread pool of four,

00:23:34.530 --> 00:23:36.390
which isn't so great
for things like I/O. So

00:23:36.390 --> 00:23:38.430
most apps will be doing
a lot of network or disk

00:23:38.430 --> 00:23:39.180
or whatever it be.

00:23:39.180 --> 00:23:40.950
So it's not so great for that.

00:23:40.950 --> 00:23:45.390
So yeah, it's mostly more like
a computational type dispatcher.

00:23:45.390 --> 00:23:48.032
But it's also an elastic
thread executor, which

00:23:48.032 --> 00:23:49.240
we'll talk about in a minute.

00:23:49.240 --> 00:23:52.020
But it's the
default. There's also

00:23:52.020 --> 00:23:54.770
Dispatchers.IO, which was
added fairly recently.

00:23:54.770 --> 00:23:57.720
And it was designed specifically
for blocking I/O tasks, so

00:23:57.720 --> 00:23:59.520
things that we
really care about--

00:23:59.520 --> 00:24:02.860
network, image loading, reading
disk, database, blah, blah,

00:24:02.860 --> 00:24:04.080
blah.

00:24:04.080 --> 00:24:07.336
It uses a minimum of 64
parallelism, which basically

00:24:07.336 --> 00:24:09.960
means that you can have up to 64
tasks running at a time, which

00:24:09.960 --> 00:24:11.970
is great for what we need.

00:24:11.970 --> 00:24:14.646
So yeah, you can
launch it like that.

00:24:14.646 --> 00:24:16.770
But the really great thing
about the I/O dispatcher

00:24:16.770 --> 00:24:21.210
is that it shares thread pools
with the default dispatcher.

00:24:21.210 --> 00:24:23.250
And the point where it
becomes great is this.

00:24:23.250 --> 00:24:26.640
So here have an example where
we have an async, which is

00:24:26.640 --> 00:24:28.490
using the default dispatcher.

00:24:28.490 --> 00:24:31.290
And then we're going to load
an image on the I/O dispatcher.

00:24:31.290 --> 00:24:34.130
So we can do some disk reading,
some kind of load image,

00:24:34.130 --> 00:24:35.065
whatever it be.

00:24:35.065 --> 00:24:36.870
And then we're going
to use that result

00:24:36.870 --> 00:24:38.520
and then process it somehow.

00:24:38.520 --> 00:24:41.070
It's a computational task.

00:24:41.070 --> 00:24:44.460
Now, because this is running
on the default dispatcher,

00:24:44.460 --> 00:24:47.670
there is no actual
thread switch in there

00:24:47.670 --> 00:24:50.090
because we're using those
shared thread pools.

00:24:50.090 --> 00:24:52.141
I/O and default
uses shared threads.

00:24:52.141 --> 00:24:54.140
Therefore there's no
actual thread switch, which

00:24:54.140 --> 00:24:55.348
makes it a whole lot quicker.

00:24:57.515 --> 00:24:59.140
And then we also have
Dispatchers.Main,

00:24:59.140 --> 00:25:01.056
which we've spoken about
a little bit already.

00:25:01.056 --> 00:25:04.220
It allows running coroutines
on the UI main thread.

00:25:04.220 --> 00:25:07.680
A nuance with that is that
in later releases anyway,

00:25:07.680 --> 00:25:11.760
it uses service loader
to load the dispatcher

00:25:11.760 --> 00:25:13.511
in your code, which
is kind of tricky when

00:25:13.511 --> 00:25:14.718
we have things like ProGuard.

00:25:14.718 --> 00:25:16.350
So you have to be
careful with this.

00:25:16.350 --> 00:25:17.775
But yeah, just be careful.

00:25:17.775 --> 00:25:19.150
And the thing you
need to know is

00:25:19.150 --> 00:25:21.233
that you need to add the
Android dependency, which

00:25:21.233 --> 00:25:23.780
we spoke about earlier anyway.

00:25:23.780 --> 00:25:25.500
And then to use it as we said.

00:25:25.500 --> 00:25:29.680
Just launch in the
Dispatchers.Main.

00:25:29.680 --> 00:25:32.880
So that brings us a little
bit onto reactivity.

00:25:32.880 --> 00:25:35.660
So how many blog posts, that
you've seen recently anyway,

00:25:35.660 --> 00:25:38.861
can be summarized as this slide?

00:25:38.861 --> 00:25:40.900
[LAUGHTER]

00:25:40.900 --> 00:25:42.960
And I, myself, have
been guilty of this.

00:25:42.960 --> 00:25:44.880
[LAUGHTER]

00:25:45.460 --> 00:25:48.480
Now I'm going to make the
premise and the statement

00:25:48.480 --> 00:25:50.580
that most devs use
RxJava just because it

00:25:50.580 --> 00:25:52.027
makes threading easy.

00:25:52.027 --> 00:25:53.610
So the fact that you
have schedule on,

00:25:53.610 --> 00:25:57.580
and you can easily switch afraid
on-- switch multiple threads.

00:25:57.580 --> 00:25:59.180
And that's why most RxJava--

00:25:59.180 --> 00:26:00.079
its use is.

00:26:00.079 --> 00:26:01.620
Now, of course,
there are going to be

00:26:01.620 --> 00:26:04.010
people who go tell, not
top to bottom with chains

00:26:04.010 --> 00:26:05.885
and reactivity.

00:26:05.885 --> 00:26:09.020
But I think for
the 80% of cases,

00:26:09.020 --> 00:26:10.350
it's just a switcher thread.

00:26:10.350 --> 00:26:12.389
And that's because the
APIs that we have, and we

00:26:12.389 --> 00:26:14.430
spoke about them earlier,
aren't so great to use.

00:26:17.220 --> 00:26:18.930
And because of that,
most people end up

00:26:18.930 --> 00:26:21.180
using things like Single,
Maybe, and Completable

00:26:21.180 --> 00:26:22.930
because that's
specifically what they are.

00:26:22.930 --> 00:26:24.480
They're single, one-shot things.

00:26:24.480 --> 00:26:27.217
Single allows you to
always have a type.

00:26:27.217 --> 00:26:28.050
Maybe it's nullable.

00:26:28.050 --> 00:26:30.330
And Completable doesn't
have a return type.

00:26:30.330 --> 00:26:32.270
So they're all pretty similar.

00:26:32.270 --> 00:26:35.940
But in fact, they only actually
exist on RxJava, RxScala,

00:26:35.940 --> 00:26:36.710
and RxGroovy.

00:26:36.710 --> 00:26:38.880
They don't actually exist
in any other platform.

00:26:38.880 --> 00:26:42.300
So as I said earlier, maybe it's
more of a reflection of the API

00:26:42.300 --> 00:26:44.160
that we have are at
disposal rather than

00:26:44.160 --> 00:26:46.584
the fact that they're needed.

00:26:46.584 --> 00:26:48.819
So coroutines can actually
quite easily replace

00:26:48.819 --> 00:26:50.110
Single, Maybe, and Completable.

00:26:50.110 --> 00:26:51.520
They do exactly what you think.

00:26:51.520 --> 00:26:53.380
We said earlier about
replacing callbacks.

00:26:53.380 --> 00:26:56.450
They also replace
these quite nicely.

00:26:56.450 --> 00:26:57.590
So here's an example.

00:26:57.590 --> 00:27:00.980
So we have a Retrofit
interface, which has a GET.

00:27:00.980 --> 00:27:05.240
And it turns a Single, which it
just returns a list of Shows.

00:27:05.240 --> 00:27:08.450
And the way you'd use that in
RxJava is you do this chaining.

00:27:08.450 --> 00:27:10.804
So you'd switch the
scheduler using scheduleOn.

00:27:10.804 --> 00:27:12.970
And here we're going to use
the I/O scheduler, which

00:27:12.970 --> 00:27:14.320
is provided for you.

00:27:14.320 --> 00:27:18.510
And then we're going to do some
calls, too, when it's finished.

00:27:18.510 --> 00:27:21.670
Now, the nice thing about
the Rx2 interrupt library

00:27:21.670 --> 00:27:26.080
of coroutines is that you can
actually use that exact Single

00:27:26.080 --> 00:27:27.010
as an await.

00:27:27.010 --> 00:27:30.840
So you can actually use it
as a suspend and deferred.

00:27:30.840 --> 00:27:33.040
So it's really handy for
when you're kind of slowly

00:27:33.040 --> 00:27:34.900
migrating towards
coroutine and you

00:27:34.900 --> 00:27:38.250
do want to change
everything from day one.

00:27:38.250 --> 00:27:41.210
You can actually keep those
interfaces, all those server

00:27:41.210 --> 00:27:41.890
pools.

00:27:41.890 --> 00:27:43.990
And you can actually
just call await on them.

00:27:43.990 --> 00:27:46.300
Receive inside can
be using coroutines.

00:27:46.300 --> 00:27:48.160
So it's quite a handy
way to slowly migrate.

00:27:50.855 --> 00:27:52.480
Wouldn't it be great
if we can actually

00:27:52.480 --> 00:27:56.110
made that Retrofit call
just a suspending function

00:27:56.110 --> 00:27:58.951
and just remove the
whole Rx from the start?

00:27:58.951 --> 00:28:00.137
Well, we can.

00:28:00.137 --> 00:28:01.970
And that is actually
going to Retrofit soon.

00:28:01.970 --> 00:28:04.500
Jake has a PR, which
is pending review.

00:28:04.500 --> 00:28:07.955
But he tells me it's soon.

00:28:07.955 --> 00:28:11.390
So yeah, it's coming soon.

00:28:11.390 --> 00:28:13.447
And then, if you look
at consuming code,

00:28:13.447 --> 00:28:14.530
it's pretty much the same.

00:28:14.530 --> 00:28:16.390
It's just we can now
get rid of that await.

00:28:16.390 --> 00:28:18.140
And it's just a normal
suspending function

00:28:18.140 --> 00:28:22.410
that we've called, and it's
just a normal coroutine

00:28:22.410 --> 00:28:24.690
And that brings us on to
our final section, which

00:28:24.690 --> 00:28:27.600
is kind of bringing it all
back together and trying

00:28:27.600 --> 00:28:29.430
to think of two scenarios
where we show you

00:28:29.430 --> 00:28:32.880
how to use coroutines to make
your lives easier on Android.

00:28:32.880 --> 00:28:34.855
Both the examples are
all about location.

00:28:34.855 --> 00:28:36.480
The first one is
about actually getting

00:28:36.480 --> 00:28:39.240
the last known location,
which you can kind of think

00:28:39.240 --> 00:28:41.661
is a one-shot callback.

00:28:41.661 --> 00:28:45.120
So here we're going to use the
FusedLocationProviderClient,

00:28:45.120 --> 00:28:48.120
which is from the Google
Play Services API.

00:28:48.120 --> 00:28:50.220
It's actually kind of
cool because it combines

00:28:50.220 --> 00:28:53.640
all different providers we have,
like Wi-Fi and GPS and mobile

00:28:53.640 --> 00:28:55.035
and whatever it is, Bluetooth.

00:28:55.035 --> 00:28:58.100
It provides all those providers
for you into one single API.

00:28:58.100 --> 00:29:00.400
So it's actually a
really nice API to use.

00:29:00.400 --> 00:29:03.580
And it returns a Task, which is
a kind of future-y type thing

00:29:03.580 --> 00:29:06.060
that Play Services library has.

00:29:06.060 --> 00:29:08.310
And yeah, so you call
client.getLastLocation.

00:29:08.310 --> 00:29:09.830
And it returns a Task.

00:29:09.830 --> 00:29:11.680
And from the task,
you can add what

00:29:11.680 --> 00:29:13.230
we call a complete listener.

00:29:13.230 --> 00:29:15.329
And then you'll get the
result back eventually.

00:29:15.329 --> 00:29:16.370
So it's completely async.

00:29:18.747 --> 00:29:20.580
So when you think about
it, what we're doing

00:29:20.580 --> 00:29:23.350
is converting a callback API
into a suspended function.

00:29:23.350 --> 00:29:26.034
That's pretty much
what we want to do.

00:29:26.034 --> 00:29:27.450
And luckily, the
coroutine library

00:29:27.450 --> 00:29:31.730
has two builders that
do exactly what we want.

00:29:31.730 --> 00:29:33.768
The first is suspendCoroutine.

00:29:36.396 --> 00:29:39.292
And what you do-- you pass
a lambda, which allows

00:29:39.292 --> 00:29:40.500
you to set up your callbacks.

00:29:40.500 --> 00:29:43.260
So basically what we'll do
here is call Play Services

00:29:43.260 --> 00:29:45.870
and go, get me
the last location.

00:29:45.870 --> 00:29:48.150
At that point, the
coroutine immediately

00:29:48.150 --> 00:29:50.430
suspends waiting for
the result to come back.

00:29:50.430 --> 00:29:52.840
And then the callback can
wait you back up, basically.

00:29:52.840 --> 00:29:55.356
So we'll go through
an example now.

00:29:55.356 --> 00:29:57.480
Yeah, you're giving a
continuation to later resume.

00:29:57.480 --> 00:29:58.986
That's how we do.

00:29:58.986 --> 00:30:01.370
And that's how you
pass the result on.

00:30:01.370 --> 00:30:04.891
Analyze the calls
and cancel the call.

00:30:04.891 --> 00:30:06.140
So actually, that's different.

00:30:06.140 --> 00:30:06.639
Hold on.

00:30:06.639 --> 00:30:08.150
So there is a newer
version-- sorry.

00:30:08.150 --> 00:30:09.150
Didn't mean to skip that.

00:30:09.150 --> 00:30:11.608
There's a newer version called
suspendCancellableCoroutine.

00:30:11.608 --> 00:30:13.150
It's like a little
add-on on top.

00:30:13.150 --> 00:30:15.890
And it allows you
to cancel the call.

00:30:15.890 --> 00:30:17.330
So say your
coroutine's canceled.

00:30:17.330 --> 00:30:19.880
You can then tell
the underlying API,

00:30:19.880 --> 00:30:24.270
in this case Play Services,
to cancel its call.

00:30:24.270 --> 00:30:25.354
So let's build a function.

00:30:25.354 --> 00:30:27.644
So here we're going to have
a suspended function called

00:30:27.644 --> 00:30:28.330
getLastLocation.

00:30:28.330 --> 00:30:29.780
And it returns an
actual location.

00:30:29.780 --> 00:30:31.821
It doesn't return a future
or anything like that.

00:30:31.821 --> 00:30:34.785
It's just a straight location.

00:30:34.785 --> 00:30:36.910
So I'm going to use our
suspendCancellableCoroutine

00:30:36.910 --> 00:30:37.890
builder.

00:30:37.890 --> 00:30:39.723
And then we're going
to have a continuation.

00:30:39.723 --> 00:30:42.720
That's our kind of
callback-y type thing.

00:30:42.720 --> 00:30:44.906
And then we're going to set up.

00:30:44.906 --> 00:30:47.280
So we're going to call location
client, which is the Play

00:30:47.280 --> 00:30:49.965
Services API, last location.

00:30:49.965 --> 00:30:51.840
And then we're going
to-- we get a Task back.

00:30:51.840 --> 00:30:54.210
And then we're going to
add our onCompleteListener.

00:30:54.210 --> 00:30:57.540
At that point, we are going
to wake up our coroutine.

00:30:57.540 --> 00:31:00.480
So that is how we pass back
to the suspended coroutine

00:31:00.480 --> 00:31:02.080
the result. And
it then wakes up.

00:31:02.080 --> 00:31:05.470
And the suspended function
basically wakes back up,

00:31:05.470 --> 00:31:05.970
resumes.

00:31:09.050 --> 00:31:11.630
Now, because this
is a cancellable--

00:31:11.630 --> 00:31:13.360
I'm actually backing
up a little bit.

00:31:13.360 --> 00:31:17.210
Because we are using Task, we're
not using the success listener.

00:31:17.210 --> 00:31:18.680
We're using the
complete listener,

00:31:18.680 --> 00:31:21.580
which means that the Task
itself can throw an exception.

00:31:21.580 --> 00:31:23.060
It can fail for whatever reason.

00:31:23.060 --> 00:31:26.970
So you don't have location
permission or whatever it be.

00:31:26.970 --> 00:31:29.020
Now it will raise
an exception on you,

00:31:29.020 --> 00:31:30.400
which means that
you can populate

00:31:30.400 --> 00:31:32.650
that backup to
the call, which is

00:31:32.650 --> 00:31:36.890
done with a resume
of exception method.

00:31:36.890 --> 00:31:40.430
And finally, because we're using
suspendCancellableCoroutine,

00:31:40.430 --> 00:31:44.040
we need to tell the Play Servers
API that we've been canceled.

00:31:44.040 --> 00:31:45.670
So therefore it should cancel.

00:31:45.670 --> 00:31:49.400
So we did that with a callback,
which is invokeOnCompletion.

00:31:49.400 --> 00:31:51.722
At that point, assume you
know that the coroutine's

00:31:51.722 --> 00:31:53.180
been canceled,
which means that you

00:31:53.180 --> 00:31:54.424
need to start Play Services.

00:31:54.424 --> 00:31:56.840
Now, this API doesn't actually
exist because Play Services

00:31:56.840 --> 00:31:58.280
doesn't have a cancel method.

00:31:58.280 --> 00:32:00.926
But imagine it just exists.

00:32:00.926 --> 00:32:03.135
Now Adam's going to
talk about observing.

00:32:03.135 --> 00:32:04.414
ADAM POWELL: Sure.

00:32:04.414 --> 00:32:06.080
So what happens when
you want to observe

00:32:06.080 --> 00:32:07.730
a sequence of events over time?

00:32:07.730 --> 00:32:10.850
Now this is the thing that
Rx is really, really good at.

00:32:10.850 --> 00:32:13.660
If you're using Rx for
anything, it should be for this.

00:32:13.660 --> 00:32:17.120
And people tend to compare
RxJava and coroutine

00:32:17.120 --> 00:32:19.764
quite a bit in blogs
and so on and so forth.

00:32:19.764 --> 00:32:21.680
So what does that actually
look like if we try

00:32:21.680 --> 00:32:24.610
and emulate this using
coroutine as a primitive?

00:32:24.610 --> 00:32:28.070
So Play Services' location API,
in addition to letting you get

00:32:28.070 --> 00:32:30.590
just kind of a "one-shot,
what's my current location,"

00:32:30.590 --> 00:32:33.020
it lets you request location
updates using a callback

00:32:33.020 --> 00:32:34.624
that's invoked multiple times.

00:32:34.624 --> 00:32:37.040
So normally this is a prime
candidate to be an observable.

00:32:37.040 --> 00:32:39.420
You register a callback
at subscribe time.

00:32:39.420 --> 00:32:42.080
And unregister when that
subscription's disposed.

00:32:42.080 --> 00:32:44.990
We get this composable
control over shutting down

00:32:44.990 --> 00:32:46.370
the updates really cleanly.

00:32:46.370 --> 00:32:48.050
So Rx is a great library.

00:32:48.050 --> 00:32:50.870
It offers a ton of functionality
to build things like this.

00:32:50.870 --> 00:32:52.820
So how many similar
benefits can we

00:32:52.820 --> 00:32:56.270
get if we base this off
of suspending functions?

00:32:56.270 --> 00:32:58.940
So let's, again, start just
writing a simple function,

00:32:58.940 --> 00:33:00.760
or at least it's going
to start out simple.

00:33:00.760 --> 00:33:02.135
Suspending functions
don't return

00:33:02.135 --> 00:33:03.410
until their work is all done.

00:33:03.410 --> 00:33:06.130
So there's no disposable
or closeable return by it

00:33:06.130 --> 00:33:08.230
since the calling scope
itself is cancellable.

00:33:08.230 --> 00:33:10.120
We just don't return
until we're done.

00:33:10.120 --> 00:33:12.190
So our observer in
this case can just

00:33:12.190 --> 00:33:14.646
be a simple lambda that
accepts a location result.

00:33:14.646 --> 00:33:17.020
And we'll go ahead and call
it whenever a new location is

00:33:17.020 --> 00:33:18.597
reported without
actually returning

00:33:18.597 --> 00:33:19.555
from observed location.

00:33:22.200 --> 00:33:25.046
So if you take in this giant
pile of code here, some of you

00:33:25.046 --> 00:33:26.670
might notice that it
looks an awful lot

00:33:26.670 --> 00:33:29.100
like an observable.createCall
from Rx.

00:33:29.100 --> 00:33:31.975
So let's go ahead and take
it apart piece by piece.

00:33:31.975 --> 00:33:33.350
And we'll go ahead
and start off.

00:33:33.350 --> 00:33:34.970
And we'll just create
this done signal

00:33:34.970 --> 00:33:37.011
that we can await on later
to know when to finish

00:33:37.011 --> 00:33:38.030
normally and clean up.

00:33:38.030 --> 00:33:39.832
So this is like our
observable completion.

00:33:39.832 --> 00:33:42.290
In the case where you have a
stream with a well-defined end

00:33:42.290 --> 00:33:45.217
signal, you can complete this to
let the observer function clean

00:33:45.217 --> 00:33:45.800
up and return.

00:33:45.800 --> 00:33:48.394
And we'll see that
in a little bit.

00:33:48.394 --> 00:33:49.810
So the next piece
here where we're

00:33:49.810 --> 00:33:51.302
creating a location
callback, this

00:33:51.302 --> 00:33:52.510
should really be no surprise.

00:33:52.510 --> 00:33:55.180
We need one to receive updates
from the location provider.

00:33:55.180 --> 00:33:56.770
But what's interesting
here is that we

00:33:56.770 --> 00:33:59.440
use launch to call the observer
function on the same coroutine

00:33:59.440 --> 00:34:01.750
dispatcher that observe
location was called on.

00:34:01.750 --> 00:34:05.080
Remember, the coroutine
scope that we opened here

00:34:05.080 --> 00:34:07.050
carries along the
dispatcher with it

00:34:07.050 --> 00:34:08.050
that it was called with.

00:34:08.050 --> 00:34:09.460
So we always know
that we're going

00:34:09.460 --> 00:34:11.043
to call the observer
in the same place

00:34:11.043 --> 00:34:13.530
that the caller wanted
the information reported.

00:34:13.530 --> 00:34:16.297
So we cancel the old job from
before and start a new one.

00:34:16.297 --> 00:34:18.380
We make sure that we call
the observer while we're

00:34:18.380 --> 00:34:19.746
holding the suspending mutex.

00:34:19.746 --> 00:34:21.620
And this keeps things
serialized to make sure

00:34:21.620 --> 00:34:24.510
that we don't have two calls
to an observer active at once.

00:34:24.510 --> 00:34:27.230
We assume that onLocationResult
won't have multiple calls

00:34:27.230 --> 00:34:28.320
active at once either.

00:34:28.320 --> 00:34:30.445
So this is kind of an
example of some of the things

00:34:30.445 --> 00:34:32.860
that if you're building one
of these things yourself,

00:34:32.860 --> 00:34:35.179
this is one of those
comparison things of--

00:34:35.179 --> 00:34:38.260
RxJava kind of does a lot
of these things for you.

00:34:38.260 --> 00:34:41.170
But with coroutine, we have
all the primitives to build it.

00:34:41.170 --> 00:34:42.919
We just need to do a
little bit more of it

00:34:42.919 --> 00:34:46.219
by hand if we're putting one
of these things together.

00:34:46.219 --> 00:34:47.800
So we register our callback.

00:34:47.800 --> 00:34:49.600
And then we await
on our done signal.

00:34:49.600 --> 00:34:51.130
And since we never
complete it, I

00:34:51.130 --> 00:34:53.965
mean, when does the location
stream really complete anyway?

00:34:53.965 --> 00:34:56.590
This will go ahead and wait for
the calling job to be canceled.

00:34:56.590 --> 00:34:58.810
So we remove the callback
in the finally block.

00:34:58.810 --> 00:35:00.700
So it'll happen on cancellation.

00:35:00.700 --> 00:35:03.472
And then request
location updates normally

00:35:03.472 --> 00:35:04.930
takes a looper
instead of something

00:35:04.930 --> 00:35:06.965
like an executer, which
is kind of unfortunate

00:35:06.965 --> 00:35:08.590
because this pattern
really shines when

00:35:08.590 --> 00:35:10.060
you can avoid an extra hop.

00:35:10.060 --> 00:35:12.010
So if you use a direct
executer that'll

00:35:12.010 --> 00:35:14.140
just go ahead and
run the observer

00:35:14.140 --> 00:35:16.690
wherever the update happens
on the incoming binder thread

00:35:16.690 --> 00:35:18.466
or whatever it is.

00:35:18.466 --> 00:35:21.260
It really kind of shines when
you can avoid those extra hops.

00:35:21.260 --> 00:35:24.490
But you get the idea.

00:35:24.490 --> 00:35:26.602
So here's what it
looks like in use.

00:35:26.602 --> 00:35:28.560
And if you take a look,
this looks an awful lot

00:35:28.560 --> 00:35:30.510
like just a for-each
call on a collection.

00:35:30.510 --> 00:35:32.950
And it behaves
exactly the same way.

00:35:32.950 --> 00:35:34.890
So since we use launch
to call the observer

00:35:34.890 --> 00:35:37.170
block in the first place,
if the inner block throws

00:35:37.170 --> 00:35:39.630
an exception, that means
that the observed location

00:35:39.630 --> 00:35:41.460
call itself will
throw an exception

00:35:41.460 --> 00:35:42.539
into that outer scope.

00:35:42.539 --> 00:35:44.580
We can just wrap this
whole thing in a try-catch.

00:35:44.580 --> 00:35:47.250
And that's all of our error
handling that we need to do.

00:35:47.250 --> 00:35:48.720
So it's a child job.

00:35:48.720 --> 00:35:50.880
So it'll cancel the parent
scope with the exception

00:35:50.880 --> 00:35:53.520
as well, the same scope that
wraps the whole of the observed

00:35:53.520 --> 00:35:54.594
location function body.

00:35:54.594 --> 00:35:56.760
So it'll resume from the
await with the cancellation

00:35:56.760 --> 00:35:59.124
exception, unregister
the location callback

00:35:59.124 --> 00:36:00.540
from the finally
block from above.

00:36:00.540 --> 00:36:02.010
And all of this just composes.

00:36:02.010 --> 00:36:05.310
So you, again, can lean
on all of these constructs

00:36:05.310 --> 00:36:07.800
of the language that you
already know by just adding some

00:36:07.800 --> 00:36:11.390
of these suspending primitives.

00:36:11.390 --> 00:36:12.740
CHRIS BANES: Cool.

00:36:12.740 --> 00:36:13.990
So let's wrap up a little bit.

00:36:13.990 --> 00:36:14.980
So what's next?

00:36:14.980 --> 00:36:17.000
What are some action
items for you to do?

00:36:17.000 --> 00:36:19.750
Well, the first is that, as you
saw in the key note earlier,

00:36:19.750 --> 00:36:22.125
we actually have a code lab
specifically for coroutine.

00:36:22.125 --> 00:36:24.344
And that was released about
three weeks ago, which

00:36:24.344 --> 00:36:25.510
is really good introduction.

00:36:25.510 --> 00:36:27.801
It's coroutines and how to
actually use it in your app.

00:36:27.801 --> 00:36:30.084
And secondly, read the manual.

00:36:30.084 --> 00:36:32.500
I don't like to do that usually,
but the docs are actually

00:36:32.500 --> 00:36:33.795
really, really good.

00:36:33.795 --> 00:36:34.565
They're on Github.

00:36:34.565 --> 00:36:35.440
You can look at them.

00:36:35.440 --> 00:36:37.210
You can even edit
them if you want to.

00:36:37.210 --> 00:36:38.440
But they're all
very use-case based.

00:36:38.440 --> 00:36:39.610
They're all, I need to do x.

00:36:39.610 --> 00:36:40.610
How do I do it?

00:36:40.610 --> 00:36:44.100
So make sure to go and check it
out if you are using coroutine.

00:36:44.100 --> 00:36:45.680
And that is it.

00:36:45.680 --> 00:36:46.900
Thank you very much.

00:36:46.900 --> 00:36:50.250
[MUSIC PLAYING]

