WEBVTT
Kind: captions
Language: en

00:00:00.792 --> 00:00:01.770
KUNAL SONI: All right.

00:00:01.770 --> 00:00:02.440
Hi, everyone.

00:00:02.440 --> 00:00:03.850
Good afternoon or
I should rather

00:00:03.850 --> 00:00:06.340
say a very sunny good afternoon.

00:00:06.340 --> 00:00:09.280
Welcome to Building for
Billions on Android.

00:00:09.280 --> 00:00:11.730
I'm Kunal, and I look
after business development

00:00:11.730 --> 00:00:15.520
for Google Play in Southeast
Asia, India, and Australia.

00:00:15.520 --> 00:00:17.830
And I've got with
me my colleagues

00:00:17.830 --> 00:00:22.340
Ankur Kotwal and Neto Marin from
the developer advocate team.

00:00:22.340 --> 00:00:24.340
Together, we're going to
be talking to you today

00:00:24.340 --> 00:00:28.730
about building high quality
apps that look effectively,

00:00:28.730 --> 00:00:31.140
not just for
smartphone users today

00:00:31.140 --> 00:00:32.860
but also for the
next billion users

00:00:32.860 --> 00:00:37.430
as they get connected for the
first time in the coming years.

00:00:37.430 --> 00:00:40.190
We are seeing amazing
momentum in emerging markets

00:00:40.190 --> 00:00:41.560
all over the world.

00:00:41.560 --> 00:00:44.480
They're expected to
account for more than 80%

00:00:44.480 --> 00:00:49.330
of smartphone growth
globally until 2019.

00:00:49.330 --> 00:00:52.910
As more and more users in these
markets get access to devices

00:00:52.910 --> 00:00:54.930
and get connected
for the first time,

00:00:54.930 --> 00:00:58.110
they will increasingly
rely on their smartphones

00:00:58.110 --> 00:01:00.910
to shop, to transact,
to communicate,

00:01:00.910 --> 00:01:04.510
to look for information, or to
simply entertain themselves.

00:01:04.510 --> 00:01:07.710
And that means incredibly
exciting new opportunities

00:01:07.710 --> 00:01:10.430
for everybody here.

00:01:10.430 --> 00:01:13.720
In order to be relevant and
successful in these markets,

00:01:13.720 --> 00:01:17.230
it's important for us to think
about the important challenges

00:01:17.230 --> 00:01:21.060
that users face and design
the right app experience aimed

00:01:21.060 --> 00:01:23.316
at solving these challenges.

00:01:23.316 --> 00:01:25.440
Let's take a quick look at
some of these challenges

00:01:25.440 --> 00:01:28.900
before we get into details.

00:01:28.900 --> 00:01:31.230
Challenge number
1, while we're all

00:01:31.230 --> 00:01:34.210
excited about the growth of
fast network technologies

00:01:34.210 --> 00:01:37.860
like 3G, 4G, and LTE
the across the world,

00:01:37.860 --> 00:01:41.050
the fact is that it's
expected by the end of 2020

00:01:41.050 --> 00:01:45.510
we'll still have almost one
billion mobile internet users,

00:01:45.510 --> 00:01:49.230
or almost 30% of total
mobile internet connections

00:01:49.230 --> 00:01:52.200
to be operating on 2G.

00:01:52.200 --> 00:01:54.800
That's a sizable and
large segment for you

00:01:54.800 --> 00:01:56.315
to think about and solve for.

00:01:59.000 --> 00:02:03.000
Secondly, we see a wide
variation in the quality

00:02:03.000 --> 00:02:06.460
and speeds of mobile leader
networks all over the world.

00:02:06.460 --> 00:02:10.620
For example, in markets like
India, Vietnam, and Argentina,

00:02:10.620 --> 00:02:14.150
the average mobile data
speed is less than one tenth

00:02:14.150 --> 00:02:17.110
of what you see in the UK.

00:02:17.110 --> 00:02:20.670
To top it all, broadband
quality and adoption is low.

00:02:20.670 --> 00:02:22.570
Again, going back to
some of these markets--

00:02:22.570 --> 00:02:26.860
Brazil, India-- you see less
than one fifth or less than 20%

00:02:26.860 --> 00:02:29.550
of total broadband
connections in these markets

00:02:29.550 --> 00:02:34.460
operate at speeds
higher than 4 Mbps.

00:02:34.460 --> 00:02:36.380
Clearly, these pose
challenges in terms

00:02:36.380 --> 00:02:38.260
of the overall
experience that users

00:02:38.260 --> 00:02:39.800
will have within the apps.

00:02:42.920 --> 00:02:47.310
Finally, data is expensive
relative to income levels

00:02:47.310 --> 00:02:53.240
in several markets, making users
highly sensitive to data cost.

00:02:53.240 --> 00:02:56.770
For example, if you look at the
markets like Nigeria and Brazil

00:02:56.770 --> 00:03:00.630
the average per
capita data cost is

00:03:00.630 --> 00:03:02.970
greater than 10x or
more than 10 times

00:03:02.970 --> 00:03:05.250
of what you see in the UK.

00:03:05.250 --> 00:03:09.260
So clearly, being able to help
users manage their data cost

00:03:09.260 --> 00:03:11.530
needs to be an
important priority if we

00:03:11.530 --> 00:03:12.760
have to win in these markets.

00:03:15.570 --> 00:03:18.440
In order to help you
tackle these challenges

00:03:18.440 --> 00:03:20.930
and support your growth
in these markets,

00:03:20.930 --> 00:03:24.220
we've identified a set of
tools and best practices

00:03:24.220 --> 00:03:26.120
that we believe can help.

00:03:26.120 --> 00:03:27.810
This is what we
call the "Building

00:03:27.810 --> 00:03:30.490
for Billions Framework."

00:03:30.490 --> 00:03:32.480
The goal here is to
talk to you a little bit

00:03:32.480 --> 00:03:36.210
about some guidelines
in six important areas--

00:03:36.210 --> 00:03:42.820
connectivity, device capability,
data cost, battery consumption,

00:03:42.820 --> 00:03:46.040
content, and commerce.

00:03:46.040 --> 00:03:48.965
The goal is to equip you with
actionable recommendations

00:03:48.965 --> 00:03:52.460
that you can implement
to make your apps perform

00:03:52.460 --> 00:03:56.366
more effectively and
efficiently in these markets.

00:03:56.366 --> 00:03:58.490
So what we're going to do
over the next few minutes

00:03:58.490 --> 00:04:01.040
we're actually going to deep
dive into all of these areas.

00:04:01.040 --> 00:04:03.760
But before we do that,
let's take a look

00:04:03.760 --> 00:04:06.220
at a developer who's
already embracing

00:04:06.220 --> 00:04:08.880
some of these guidelines
and have integrated these

00:04:08.880 --> 00:04:10.840
into the overall app
experience that they

00:04:10.840 --> 00:04:13.204
are driving with their users.

00:04:13.204 --> 00:04:15.370
I'm going to talking to you
about a developer called

00:04:15.370 --> 00:04:16.490
"Culture Alley."

00:04:16.490 --> 00:04:18.850
They operate an app
called "Hello English."

00:04:18.850 --> 00:04:21.459
Now Hello English is a
language learning app

00:04:21.459 --> 00:04:23.470
helping millions of
users as in India

00:04:23.470 --> 00:04:26.715
and outside helping learn
English-- as simple as that.

00:04:26.715 --> 00:04:28.340
All right, let's take
a look at a video

00:04:28.340 --> 00:04:29.465
and see what they're doing.

00:04:29.465 --> 00:04:31.105
[VIDEO PLAYBACK]

00:04:31.605 --> 00:04:35.014
[MUSIC PLAYING]

00:04:35.877 --> 00:04:36.960
-My name is Nishant Patni.

00:04:36.960 --> 00:04:39.080
I'm the founder and
CEO of Hello English.

00:04:39.080 --> 00:04:41.470
It's an app that helps
millions of Indians

00:04:41.470 --> 00:04:43.780
learn English in a
fun and engaging way

00:04:43.780 --> 00:04:45.990
using gamification.

00:04:45.990 --> 00:04:48.250
India is a wonderfully
diverse country

00:04:48.250 --> 00:04:51.025
with 22 languages recognized
by the government.

00:04:51.025 --> 00:04:53.410
But English is the
preferred business language

00:04:53.410 --> 00:04:56.862
all large businesses
prefer to use English.

00:04:56.862 --> 00:05:01.510
-Hello English supports over 15
Indian languages, 12 of which

00:05:01.510 --> 00:05:04.180
have native font
support on Android.

00:05:04.180 --> 00:05:06.940
Our users face certain
typical issues quite early

00:05:06.940 --> 00:05:11.070
on-- poor internet connectivity,
devices with low storage

00:05:11.070 --> 00:05:13.210
capacity, low processing power.

00:05:13.210 --> 00:05:15.820
We decided to focus
our efforts entirely

00:05:15.820 --> 00:05:17.845
on optimizing our
app for these issues.

00:05:17.845 --> 00:05:21.070
We discovered that Google has a
bunch of tools that can really

00:05:21.070 --> 00:05:24.380
help developers to optimize
their apps for emerging

00:05:24.380 --> 00:05:25.710
markets like India.

00:05:25.710 --> 00:05:28.346
We reduce the app
size from 16 Mb

00:05:28.346 --> 00:05:31.090
to 9 Mb, which
immediately reduced

00:05:31.090 --> 00:05:33.830
our uninstall rate by 15%.

00:05:33.830 --> 00:05:36.570
Also the majority of
the features of the app

00:05:36.570 --> 00:05:38.255
can actually work
without any internet.

00:05:41.150 --> 00:05:43.570
-Today, we have more
than 13 million people

00:05:43.570 --> 00:05:46.370
who are learning English on
Hello English from not just

00:05:46.370 --> 00:05:48.449
India but around the world.

00:05:48.449 --> 00:05:50.865
-More than anything else, we
are encouraged by the stories

00:05:50.865 --> 00:05:54.310
that we hear from our learners
and how our efforts are

00:05:54.310 --> 00:05:55.810
transforming their lives.

00:05:55.810 --> 00:05:58.196
[END PLAYBACK]

00:05:58.696 --> 00:06:02.076
KUNAL SONI: Inspiring story.

00:06:02.076 --> 00:06:04.450
What we're going to now do is
get into six of these areas

00:06:04.450 --> 00:06:06.190
and talk about specific
things that you

00:06:06.190 --> 00:06:09.240
can start implementing to
drive and boost performance

00:06:09.240 --> 00:06:11.320
of your apps in these markets.

00:06:11.320 --> 00:06:13.610
And by the way, what
we're covering here

00:06:13.610 --> 00:06:16.750
is by no means limited
to emerging markets.

00:06:16.750 --> 00:06:19.580
These are good principles
to apply equally everywhere

00:06:19.580 --> 00:06:21.120
globally.

00:06:21.120 --> 00:06:23.470
Let's start with connectivity.

00:06:23.470 --> 00:06:26.540
In order to optimize performance
for poor or intermittent

00:06:26.540 --> 00:06:28.360
connectivity, it's
very important

00:06:28.360 --> 00:06:31.590
that your app prioritizes
bandwidth requests

00:06:31.590 --> 00:06:33.960
in order to ensure
that users have access

00:06:33.960 --> 00:06:37.320
to the most useful and
relevant information

00:06:37.320 --> 00:06:39.480
as soon as possible
without having

00:06:39.480 --> 00:06:43.230
to wait on slow
networks, ensuring

00:06:43.230 --> 00:06:47.810
that text is prioritized before
rich media and images helps

00:06:47.810 --> 00:06:49.790
you accomplish that.

00:06:49.790 --> 00:06:51.850
Let's take a look at an example.

00:06:51.850 --> 00:06:55.750
In this demo, you will see
that the text loads way

00:06:55.750 --> 00:06:57.770
before the images so that
the user can actually

00:06:57.770 --> 00:07:00.001
start engaging with
the app despite being

00:07:00.001 --> 00:07:00.750
on a slow network.

00:07:04.575 --> 00:07:06.450
The second thing that
I'm going to talk about

00:07:06.450 --> 00:07:09.640
is something which is often
overlooked by developers.

00:07:09.640 --> 00:07:12.402
You should not duplicate
your data requests.

00:07:12.402 --> 00:07:13.860
Once you fetch
something you should

00:07:13.860 --> 00:07:16.780
be able to store it and then
resurface locally whenever

00:07:16.780 --> 00:07:20.640
it's requested the next time.

00:07:20.640 --> 00:07:23.855
Network connections and
overall quality is not static.

00:07:23.855 --> 00:07:27.610
They change with changes in
location, network traffic,

00:07:27.610 --> 00:07:30.000
as well as the local
population density.

00:07:30.000 --> 00:07:32.306
And your apps should be
able to pick that up.

00:07:32.306 --> 00:07:33.680
And by the way,
like I said, this

00:07:33.680 --> 00:07:36.190
is a problem not just
confined to emerging markets.

00:07:36.190 --> 00:07:38.970
This could to happen very
easily in the underground subway

00:07:38.970 --> 00:07:40.890
in New York or a
crowded football stadium

00:07:40.890 --> 00:07:42.570
the UK as well.

00:07:42.570 --> 00:07:45.020
Using tools like the
connectivity manager

00:07:45.020 --> 00:07:47.210
and telephony manager,
your apps can actually

00:07:47.210 --> 00:07:49.940
detect change in bandwidth,
change in networks

00:07:49.940 --> 00:07:52.069
and then adjust
bandwidth accordingly.

00:07:52.069 --> 00:07:54.360
So we highly recommend that
you take these into account

00:07:54.360 --> 00:07:56.575
as you think about
optimizing for poor networks.

00:07:59.570 --> 00:08:00.570
Let's talk about images.

00:08:00.570 --> 00:08:04.330
I'm sure all of us have images
or lots of images in our apps.

00:08:04.330 --> 00:08:06.120
Images need special
attention as you

00:08:06.120 --> 00:08:09.760
think about optimizing
for connectivity.

00:08:09.760 --> 00:08:13.862
As a best practice,
serve WebP images.

00:08:13.862 --> 00:08:16.600
WebP is a format which
has been fully supported

00:08:16.600 --> 00:08:19.310
by Android since 4.2.

00:08:19.310 --> 00:08:21.400
And regardless of what
the name suggests,

00:08:21.400 --> 00:08:24.600
WebP is not just
restricted to the web.

00:08:24.600 --> 00:08:27.490
WebP helps you
improve load times,

00:08:27.490 --> 00:08:31.510
save network bandwidth, and
very in many cases often

00:08:31.510 --> 00:08:36.684
results in smaller picture sizes
compared to formats like jpeg

00:08:36.684 --> 00:08:40.150
and png while maintaining
the image quality.

00:08:40.150 --> 00:08:44.120
So it's highly
recommended practice.

00:08:44.120 --> 00:08:46.402
Your user experience
can degrade very quickly

00:08:46.402 --> 00:08:47.860
if they're waiting
for a long times

00:08:47.860 --> 00:08:49.420
to actually download images.

00:08:49.420 --> 00:08:51.640
I'm sure everybody
would agree with that.

00:08:51.640 --> 00:08:54.000
One way to counter
that problem is

00:08:54.000 --> 00:08:56.610
to ensure that you use
the appropriate sizes

00:08:56.610 --> 00:08:57.690
of your images.

00:08:57.690 --> 00:09:02.140
So consider prioritizing
image requests

00:09:02.140 --> 00:09:06.180
based on network
type or quality.

00:09:06.180 --> 00:09:08.730
This helps you not only
save network bandwidth

00:09:08.730 --> 00:09:12.170
but also helps optimize for
the memory that each image will

00:09:12.170 --> 00:09:13.320
require on the device.

00:09:19.470 --> 00:09:22.410
Offline-- I think creating a
great offline experience is

00:09:22.410 --> 00:09:25.480
a wonderful way of ensuring
that your users will

00:09:25.480 --> 00:09:27.990
be able to engage
with your app content

00:09:27.990 --> 00:09:30.180
irrespective of what
the connectivity is like

00:09:30.180 --> 00:09:32.840
or whether it
doesn't exist at all,

00:09:32.840 --> 00:09:36.030
ensuring that users have a great
offline experience by making

00:09:36.030 --> 00:09:39.260
sure that you're able to
cache data, store it locally,

00:09:39.260 --> 00:09:42.097
and also queuing outbound
requests for whenever

00:09:42.097 --> 00:09:43.305
the connectivity is restored.

00:09:46.430 --> 00:09:49.080
Your app should not be
required to actually fetch

00:09:49.080 --> 00:09:50.950
any image more than once.

00:09:50.950 --> 00:09:54.090
So image loading libraries
like Glide and Picasso

00:09:54.090 --> 00:09:55.630
actually help you
fetch the image,

00:09:55.630 --> 00:09:58.810
cache it, and then plug
into the place holder views

00:09:58.810 --> 00:10:02.280
that your app has without
needing to download them

00:10:02.280 --> 00:10:03.570
again and again.

00:10:03.570 --> 00:10:06.040
This can overall help you
boosting the overall user

00:10:06.040 --> 00:10:07.850
experience and
overall performance

00:10:07.850 --> 00:10:11.320
that users have within the app.

00:10:11.320 --> 00:10:14.320
In this case, you will see
that while the app is offline

00:10:14.320 --> 00:10:16.410
or the user is
offline, they do still

00:10:16.410 --> 00:10:18.040
have a very
meaningful experience

00:10:18.040 --> 00:10:20.649
within the app with
the information

00:10:20.649 --> 00:10:22.315
and the data that's
already been cached.

00:10:27.620 --> 00:10:30.820
One simple way of checking
how your app performs

00:10:30.820 --> 00:10:34.030
in the offline state
is by simply switching

00:10:34.030 --> 00:10:37.220
on the airplane mode on your
phone and checking it out.

00:10:37.220 --> 00:10:39.800
That gives you a very, very good
example, a very good insight

00:10:39.800 --> 00:10:43.060
into what kind of performance,
what kind of functionality

00:10:43.060 --> 00:10:45.830
is working well when the
app is actually offline.

00:10:45.830 --> 00:10:47.270
So go ahead and try it out.

00:10:47.270 --> 00:10:49.880
And if it's not, then do think
about some of the other things

00:10:49.880 --> 00:10:52.505
that we've spoken about
to improve performance

00:10:52.505 --> 00:10:54.910
in poor networks
or offline states.

00:10:58.060 --> 00:11:01.800
With that, we come to the end
of the first section on the six

00:11:01.800 --> 00:11:03.780
C-framework as we
like to call it.

00:11:03.780 --> 00:11:05.680
I'd like to now
invite Ankur to talk

00:11:05.680 --> 00:11:08.030
about the rest of the Building
for Billions Framework.

00:11:08.030 --> 00:11:08.595
Thanks.

00:11:08.595 --> 00:11:09.230
Ankur?

00:11:09.230 --> 00:11:10.521
ANKUR KOTWAL: Thank you, Kunal.

00:11:10.521 --> 00:11:13.111
[APPLAUSE]

00:11:14.500 --> 00:11:16.490
Hi, everyone.

00:11:16.490 --> 00:11:18.370
So Kunal has giving
us some great context

00:11:18.370 --> 00:11:20.050
around connectivity,
and I'm going

00:11:20.050 --> 00:11:22.820
to start talking about
device capability.

00:11:22.820 --> 00:11:26.510
As the next billion users
come online-- and actually,

00:11:26.510 --> 00:11:29.460
this is true even of
the current 1.4 billion

00:11:29.460 --> 00:11:32.990
Android users-- there is
a diversity in the type

00:11:32.990 --> 00:11:35.190
of devices that users have.

00:11:35.190 --> 00:11:37.590
Some uses like
small light devices.

00:11:37.590 --> 00:11:40.580
Others like big screens
with high definition full HD

00:11:40.580 --> 00:11:43.050
or even 4K resolutions.

00:11:43.050 --> 00:11:46.550
Some uses like expandable
storage whilst others prefer

00:11:46.550 --> 00:11:49.900
a really big rich camera.

00:11:49.900 --> 00:11:51.470
And while this is
great for users,

00:11:51.470 --> 00:11:55.110
it poses some interesting
challenges for developers.

00:11:55.110 --> 00:11:58.290
So let's look at some things
that we can do-- best practices

00:11:58.290 --> 00:12:01.610
developers can use-- to
support all of these device

00:12:01.610 --> 00:12:02.847
capabilities.

00:12:02.847 --> 00:12:04.430
And let's start off
with screen sizes.

00:12:07.070 --> 00:12:09.020
The majority of
devices that will

00:12:09.020 --> 00:12:12.500
be bought by next billion
users are actually

00:12:12.500 --> 00:12:15.090
going to be low-cost devices.

00:12:15.090 --> 00:12:17.250
And of course with
low cost devices,

00:12:17.250 --> 00:12:20.050
you tend to find that their
hardware specifications tend

00:12:20.050 --> 00:12:22.510
to be a little bit lower.

00:12:22.510 --> 00:12:25.570
You want to start to
look at your layouts

00:12:25.570 --> 00:12:28.180
and stop optimizing
for small screens.

00:12:28.180 --> 00:12:30.620
Small screens will be
popular, but actually

00:12:30.620 --> 00:12:33.950
moderate-sized screens
with lower density

00:12:33.950 --> 00:12:37.090
will also be hugely popular.

00:12:37.090 --> 00:12:39.160
And those are really
important distinctions.

00:12:39.160 --> 00:12:43.390
With small screens, you
want to reduce the amount UI

00:12:43.390 --> 00:12:46.470
that you have for
navigation, for actions

00:12:46.470 --> 00:12:51.460
because you want to let
the content shine, right?

00:12:51.460 --> 00:12:55.100
When it comes to density
however-- low density screens,

00:12:55.100 --> 00:12:56.930
medium density
screens-- you want

00:12:56.930 --> 00:12:59.840
to make sure that the same
content that you're displaying

00:12:59.840 --> 00:13:03.210
is easy to consume, that
the text is easy to read,

00:13:03.210 --> 00:13:05.260
that the images look sharp.

00:13:05.260 --> 00:13:07.790
And particularly where
you're using graphical assets

00:13:07.790 --> 00:13:10.674
in your icons or
action icons, you

00:13:10.674 --> 00:13:12.090
want to make sure
you're not using

00:13:12.090 --> 00:13:14.760
thin edges on those icons.

00:13:14.760 --> 00:13:17.360
Because on the lower density
screen those thin edges--

00:13:17.360 --> 00:13:19.820
they'll disappear.

00:13:19.820 --> 00:13:22.170
And of course, you
can test this out.

00:13:22.170 --> 00:13:25.110
Android Studio has
been running hard

00:13:25.110 --> 00:13:26.730
with productivity improvements.

00:13:26.730 --> 00:13:28.810
And one of the things
that they've focused on

00:13:28.810 --> 00:13:31.490
is improving the
emulator performance.

00:13:31.490 --> 00:13:34.610
So what you should be doing
from a screen size point of view

00:13:34.610 --> 00:13:37.780
is setting up multiple
emulator configurations

00:13:37.780 --> 00:13:40.430
and then deploying your app
to these smallest screen

00:13:40.430 --> 00:13:43.230
sizes or lower
densities and testing

00:13:43.230 --> 00:13:45.870
how it looks on those screens.

00:13:45.870 --> 00:13:48.140
And you can make rapid
changes in the Layout Editor

00:13:48.140 --> 00:13:50.980
now because Android
Studio has Instant Run.

00:13:50.980 --> 00:13:53.360
So when you make a change
and deploy it on the emulator

00:13:53.360 --> 00:13:57.100
again it's not repackaging your
whole app and distributing it.

00:13:57.100 --> 00:13:59.920
It's just sending the changes
across to your running app,

00:13:59.920 --> 00:14:02.210
so the turnaround
time is much faster.

00:14:02.210 --> 00:14:06.800
So we can actually make
these changes rapidly.

00:14:06.800 --> 00:14:11.050
Of course, next is memory
usage because low cost devices

00:14:11.050 --> 00:14:12.580
will have less RAM.

00:14:12.580 --> 00:14:15.060
And I just want to clarify
when we talk about memory here

00:14:15.060 --> 00:14:16.870
we mean RAM, not storage.

00:14:16.870 --> 00:14:19.590
We'll get to
storage in a minute.

00:14:19.590 --> 00:14:22.090
You want to adjust your behavior
by the amount of RAM that's

00:14:22.090 --> 00:14:23.320
on the device.

00:14:23.320 --> 00:14:27.150
And there's one API that will
raise lots of warning signs,

00:14:27.150 --> 00:14:29.400
and you should be
using it today.

00:14:29.400 --> 00:14:32.980
And that API is isLowRamDevice.

00:14:32.980 --> 00:14:35.660
If that API returns
true to you at runtime,

00:14:35.660 --> 00:14:38.570
you know that in
your app you need

00:14:38.570 --> 00:14:41.770
to be aggressive about
keeping your footprint down

00:14:41.770 --> 00:14:43.890
because this is a very
constrained environment

00:14:43.890 --> 00:14:47.290
that your app will
be running in.

00:14:47.290 --> 00:14:49.980
The other API you can
use is getMemoryClass.

00:14:49.980 --> 00:14:52.350
And that helps you understand
how much memory budget

00:14:52.350 --> 00:14:54.560
you have in your app.

00:14:54.560 --> 00:14:57.390
Now strategies that you can
use to lower the memory usage

00:14:57.390 --> 00:15:00.960
are things like holding
on to things in memory

00:15:00.960 --> 00:15:02.620
for a little amount
of time, being

00:15:02.620 --> 00:15:07.160
more aggressive about releasing
it not keeping it in memory.

00:15:07.160 --> 00:15:09.670
Images also consume
a lot of memory.

00:15:09.670 --> 00:15:11.494
So when you have
a low Ram device

00:15:11.494 --> 00:15:12.910
or when you have
a device that you

00:15:12.910 --> 00:15:16.320
know you've got low memory
budget on just use a lower

00:15:16.320 --> 00:15:19.450
resolution, even if it's
slightly lower resolution

00:15:19.450 --> 00:15:21.710
than what the device
will be rendering at.

00:15:21.710 --> 00:15:23.780
Because then you'll
still be able to let

00:15:23.780 --> 00:15:27.180
that user use your app and
have a decent experience.

00:15:29.860 --> 00:15:33.110
And we all love to build apps
that do background processing,

00:15:33.110 --> 00:15:33.790
right?

00:15:33.790 --> 00:15:36.410
Many of us build apps
that have services.

00:15:36.410 --> 00:15:38.220
That's OK.

00:15:38.220 --> 00:15:40.840
But what's really bad is
when you have a service that

00:15:40.840 --> 00:15:44.860
hangs around, that stops up
and sits there consuming memory

00:15:44.860 --> 00:15:47.910
but refuses to go
away, all right?

00:15:47.910 --> 00:15:51.030
Because if every app on the
system does things like that,

00:15:51.030 --> 00:15:54.530
that means there's less free
memory available for foreground

00:15:54.530 --> 00:15:56.810
apps, for the apps that
your users are actually

00:15:56.810 --> 00:15:58.440
interacting with.

00:15:58.440 --> 00:16:01.870
So as developers, we should
start up, do our work,

00:16:01.870 --> 00:16:05.100
and then shut down and
wait to be woken up again.

00:16:05.100 --> 00:16:07.570
And we can schedule
those wake-ups

00:16:07.570 --> 00:16:10.170
with an API called
gcmNetworkManager.

00:16:10.170 --> 00:16:14.050
I'm going to talk about that
API in a few more slides.

00:16:14.050 --> 00:16:18.250
But it's really important thing
to stop long running processes.

00:16:18.250 --> 00:16:22.500
Let's switch gears now--
in a minute, actually.

00:16:22.500 --> 00:16:25.330
I want to show you a
screenshot here for comparison,

00:16:25.330 --> 00:16:28.059
and this is actually the
Android Studio Memory Monitor.

00:16:28.059 --> 00:16:30.600
We've added a number of tools
in Android Studio that help you

00:16:30.600 --> 00:16:32.800
benchmark how your app runs.

00:16:32.800 --> 00:16:34.830
And so you'll see
these two graphs.

00:16:34.830 --> 00:16:38.160
On the left-hand side we have
a device with 512 megs of Ram,

00:16:38.160 --> 00:16:40.060
on the right-hand
side, one gig of RAM.

00:16:40.060 --> 00:16:42.450
And you look at the graphs
and the shapes kind of look

00:16:42.450 --> 00:16:43.269
the same.

00:16:43.269 --> 00:16:45.560
It's because it's the same
app running across those two

00:16:45.560 --> 00:16:47.000
configurations.

00:16:47.000 --> 00:16:49.520
But what's important is
those figures in red.

00:16:49.520 --> 00:16:51.435
You'll see on the
512 meg Ram device

00:16:51.435 --> 00:16:54.470
we're using about 12 and
1/2 megabytes of RAM.

00:16:54.470 --> 00:16:58.960
And on the 1 gig RAM,
we're using 36 megabytes.

00:16:58.960 --> 00:16:59.750
It's the same app.

00:16:59.750 --> 00:17:02.550
It's actually adjusting at
runtime to its memory usage.

00:17:02.550 --> 00:17:04.990
That's why the shape of
the graph looks the same.

00:17:04.990 --> 00:17:06.700
Those requests are
the same, but we're

00:17:06.700 --> 00:17:09.160
being smart about how
much memory we're using.

00:17:09.160 --> 00:17:10.930
And that's what you
should be testing.

00:17:10.930 --> 00:17:13.450
Again, use Studio's
Memory Monitor

00:17:13.450 --> 00:17:15.930
and the emulators or
even physical devices

00:17:15.930 --> 00:17:18.119
to see how your app performs.

00:17:18.119 --> 00:17:20.174
Now let's switch
to smart storage.

00:17:20.174 --> 00:17:23.089
Kunal gave us some
fantastic advice.

00:17:23.089 --> 00:17:25.637
You do not duplicate
network requests.

00:17:25.637 --> 00:17:26.720
You should hold onto them.

00:17:26.720 --> 00:17:28.089
You should cache them.

00:17:28.089 --> 00:17:30.760
But that doesn't mean
you cache things forever.

00:17:30.760 --> 00:17:36.110
The size of your app in storage
should not grow infinitely.

00:17:36.110 --> 00:17:37.610
And that's why I
recommend you bound

00:17:37.610 --> 00:17:41.620
you'll caches by using things
like the disk LRU cache,

00:17:41.620 --> 00:17:42.950
or Least Recently Used.

00:17:42.950 --> 00:17:45.400
And what that will do
is actually only hold

00:17:45.400 --> 00:17:47.580
onto the things that
are being used regularly

00:17:47.580 --> 00:17:50.030
and old things-- it will
expire them and remove them

00:17:50.030 --> 00:17:51.496
from the cache.

00:17:51.496 --> 00:17:53.420
Now if you think about
the user's experience

00:17:53.420 --> 00:17:56.300
when they run out of storage--
low cost devices, by the way,

00:17:56.300 --> 00:17:58.750
don't have a lot of free
storage to start with.

00:17:58.750 --> 00:18:01.460
But when a user runs out
of space what happens

00:18:01.460 --> 00:18:04.530
is that they get a
notification on their device.

00:18:04.530 --> 00:18:06.960
The Android system says
you're out of disk space.

00:18:06.960 --> 00:18:08.970
You should go and
uninstall some apps.

00:18:08.970 --> 00:18:12.341
When you tap that notification
it takes you to a list of app,

00:18:12.341 --> 00:18:12.840
right?

00:18:12.840 --> 00:18:16.089
And their sorted by how
much space they take up.

00:18:16.089 --> 00:18:16.880
Now think about it.

00:18:16.880 --> 00:18:18.490
The user as going
to uninstall those

00:18:18.490 --> 00:18:20.239
apps that are towards
the top of the list.

00:18:20.239 --> 00:18:23.056
Because uninstalling one or
two apps they can move on.

00:18:23.056 --> 00:18:24.430
They get rid of
the notification.

00:18:24.430 --> 00:18:25.220
They get updates.

00:18:25.220 --> 00:18:27.140
They can interact
with other apps.

00:18:27.140 --> 00:18:30.090
You don't want your
app to be on that list.

00:18:30.090 --> 00:18:32.290
So here's a tip for you.

00:18:32.290 --> 00:18:36.690
When you're caching your
data use this API getCacheDir

00:18:36.690 --> 00:18:40.460
and store your cache
in that directory.

00:18:40.460 --> 00:18:43.600
What that will do is that when
the system detects that it's

00:18:43.600 --> 00:18:46.300
running out of storage
it will clear out

00:18:46.300 --> 00:18:51.460
the system cache-- that cache--
before it lets the user know,

00:18:51.460 --> 00:18:51.960
right?

00:18:51.960 --> 00:18:56.190
So you get a chance to not
end up on that naughty list.

00:18:56.190 --> 00:18:57.780
And actually, often
what will happen

00:18:57.780 --> 00:18:59.740
is when the system
does this you'll

00:18:59.740 --> 00:19:02.610
find that the system
actually frees up

00:19:02.610 --> 00:19:04.630
enough space on the
device that it doesn't

00:19:04.630 --> 00:19:06.400
need to warn the user anyway.

00:19:06.400 --> 00:19:09.260
So 1, you're being a good
citizen on their device.

00:19:09.260 --> 00:19:13.810
2, you're keeping your app
out of the naughty list

00:19:13.810 --> 00:19:16.340
of system apps.

00:19:16.340 --> 00:19:18.590
Now many users--
you'll find that they

00:19:18.590 --> 00:19:21.000
use expandable storage
because the main device

00:19:21.000 --> 00:19:23.050
comes with only a little
amount of storage.

00:19:23.050 --> 00:19:25.450
And so what you want to
do is enable your app

00:19:25.450 --> 00:19:27.210
to be installed to the SD card.

00:19:27.210 --> 00:19:29.645
And that's just the one line
change in your manifest.

00:19:29.645 --> 00:19:31.770
You don't want to make
certain assumptions, though.

00:19:31.770 --> 00:19:34.020
But it's really important
that you allow this

00:19:34.020 --> 00:19:37.900
so that the users
can have more apps.

00:19:37.900 --> 00:19:40.020
And last of all, if you
look at the screen shot,

00:19:40.020 --> 00:19:42.390
that's just the
system settings app.

00:19:42.390 --> 00:19:44.500
And we're just looking
at our app in particular.

00:19:44.500 --> 00:19:46.060
This is an app that
I wrote, and you

00:19:46.060 --> 00:19:48.120
can see exactly how much
storage you're using.

00:19:48.120 --> 00:19:50.610
So you should periodically
do that for your apps that

00:19:50.610 --> 00:19:53.710
are in development-- see how
much caches are growing to

00:19:53.710 --> 00:19:54.710
on various devices.

00:19:57.580 --> 00:20:00.610
This image actually
took me awhile to find.

00:20:00.610 --> 00:20:02.880
It's really, really important
that we are backwards

00:20:02.880 --> 00:20:05.690
compatible for our users.

00:20:05.690 --> 00:20:08.010
Especially in low
cost markets, what

00:20:08.010 --> 00:20:09.750
you'll find traditional
user behaviors

00:20:09.750 --> 00:20:14.080
are is that either they are so
price sensitive to the devices

00:20:14.080 --> 00:20:17.410
that they buy that they'll
buy a secondhand device, which

00:20:17.410 --> 00:20:18.780
is older.

00:20:18.780 --> 00:20:22.470
Or when they go to buy a new
device-- their existing device?

00:20:22.470 --> 00:20:26.100
They will pass it on to a
family member or a friend.

00:20:26.100 --> 00:20:31.060
And so what we see is a longer
tail on device life cycles.

00:20:31.060 --> 00:20:33.790
So it's really important
that you make your app

00:20:33.790 --> 00:20:36.280
available to all those users.

00:20:36.280 --> 00:20:40.720
You should target you'll minimum
SDK to be API 14, Ice Cream

00:20:40.720 --> 00:20:41.790
Sandwich.

00:20:41.790 --> 00:20:44.800
Because you'll reach
most of your users there.

00:20:44.800 --> 00:20:50.720
But you should also set your
target SDK version to 23.

00:20:50.720 --> 00:20:54.740
23 is currently the latest
API, which is Marshmallow.

00:20:54.740 --> 00:20:57.320
And in a few months,
it will be Android M--

00:20:57.320 --> 00:20:59.830
whatever the name tends to be.

00:20:59.830 --> 00:21:02.140
And it could be
API 24 or higher.

00:21:02.140 --> 00:21:04.470
But you always want to
target the latest API

00:21:04.470 --> 00:21:06.870
because that makes
sure that your app

00:21:06.870 --> 00:21:10.310
benefits from the platform
features that come

00:21:10.310 --> 00:21:12.320
on Android with newer releases.

00:21:12.320 --> 00:21:16.700
Minimum SDK of 14 will make
sure that Android Studio will

00:21:16.700 --> 00:21:19.700
warn you if you're using those
features without checking

00:21:19.700 --> 00:21:21.810
for those API versions.

00:21:21.810 --> 00:21:25.340
So having this combination gives
you this fantastic position

00:21:25.340 --> 00:21:27.950
where you can have the latest
and greatest features on newer

00:21:27.950 --> 00:21:33.192
devices but be able to support
your older users nicely.

00:21:33.192 --> 00:21:35.650
And of course, we make this
easier with the Android Support

00:21:35.650 --> 00:21:36.720
Libraries.

00:21:36.720 --> 00:21:39.740
Everyone should be using Android
Support Libraries because they

00:21:39.740 --> 00:21:43.630
provide backward compatible
components for you integrate

00:21:43.630 --> 00:21:45.260
into your apps.

00:21:45.260 --> 00:21:47.560
And in fact, one of them,
which I'll talk about later,

00:21:47.560 --> 00:21:50.490
is the Design Support Library
that makes your app still

00:21:50.490 --> 00:21:52.910
stay modern.

00:21:52.910 --> 00:21:54.590
Google Play Services
is a library

00:21:54.590 --> 00:21:57.600
that we distribute automatically
to all devices with Google

00:21:57.600 --> 00:21:58.320
Play.

00:21:58.320 --> 00:22:01.690
And it brings the best
of Google's APIs there.

00:22:01.690 --> 00:22:05.960
And the nice thing is you can
use Google Play Services APIs

00:22:05.960 --> 00:22:08.050
and know that your
users will have them.

00:22:08.050 --> 00:22:10.600
So please do use
Google Play Services

00:22:10.600 --> 00:22:13.160
where you can because your
users will continue to get

00:22:13.160 --> 00:22:16.390
the benefits of those updates.

00:22:16.390 --> 00:22:18.920
All right, device
capability was a big one

00:22:18.920 --> 00:22:20.765
but a very important one.

00:22:20.765 --> 00:22:25.770
Kunal mentioned that data
can cost up to about 10%

00:22:25.770 --> 00:22:27.610
of an individual income.

00:22:27.610 --> 00:22:30.990
So it's really important
that we respect that when

00:22:30.990 --> 00:22:33.330
we use our users data.

00:22:33.330 --> 00:22:36.400
And the first one that we need
to think about-- the first cost

00:22:36.400 --> 00:22:40.970
that our user incurs-- is just
installing your app, all right?

00:22:40.970 --> 00:22:43.460
We need to keep our
APK sizes small.

00:22:43.460 --> 00:22:45.740
And there was a great talk
called "Putting Your APK

00:22:45.740 --> 00:22:47.980
on a Diet" at I/O this year.

00:22:47.980 --> 00:22:50.170
So if you didn't catch
it already yesterday,

00:22:50.170 --> 00:22:53.275
you can catch it on YouTube now.

00:22:53.275 --> 00:22:54.650
But what I want
to share with you

00:22:54.650 --> 00:22:57.790
is that images are really
the biggest offenders.

00:22:57.790 --> 00:22:59.640
Kunal mentioned it
earlier for data

00:22:59.640 --> 00:23:02.180
that we were transferring
over the network, all right?

00:23:02.180 --> 00:23:03.880
Use smaller file sizes.

00:23:03.880 --> 00:23:07.370
When it comes to APK you
definitely should use WebP,

00:23:07.370 --> 00:23:10.980
but you should also consider
using SVG, Scalable Vector

00:23:10.980 --> 00:23:12.270
Graphics.

00:23:12.270 --> 00:23:15.600
Because Scalable Vector
Graphic images, or SVG images,

00:23:15.600 --> 00:23:18.180
tend to be these
tiny text files.

00:23:18.180 --> 00:23:20.980
But the cool thing about them
is because they're vectors,

00:23:20.980 --> 00:23:23.160
they render to any resolution.

00:23:23.160 --> 00:23:26.050
And so they're perfect
for your graphical assets

00:23:26.050 --> 00:23:29.930
like your icons in your
navigation bars and so on.

00:23:29.930 --> 00:23:32.680
And it also means
a single SVG is all

00:23:32.680 --> 00:23:34.130
you need to put in you're APK.

00:23:34.130 --> 00:23:36.800
You don't need to render
an LDPI version, an HDPI

00:23:36.800 --> 00:23:39.310
version, an XHDP version.

00:23:39.310 --> 00:23:41.170
It's a tiny file to
start with, and it

00:23:41.170 --> 00:23:43.180
supports all the densities.

00:23:43.180 --> 00:23:44.992
You also want to
keep your code small,

00:23:44.992 --> 00:23:46.450
and ProGuard is
the way to do that.

00:23:46.450 --> 00:23:50.380
Because ProGuard strips
out any code from your APK

00:23:50.380 --> 00:23:52.350
that you're not using.

00:23:52.350 --> 00:23:55.920
Often our code bloats over time
and ProGuard is there to help.

00:23:55.920 --> 00:24:00.900
So minifyEnable=true and
shrinkResources=true will also

00:24:00.900 --> 00:24:05.682
strip out any resources
or code you're not using.

00:24:05.682 --> 00:24:07.390
Now many of us use
third party libraries.

00:24:07.390 --> 00:24:09.056
I just suggested some
libraries earlier.

00:24:09.056 --> 00:24:11.460
I suggested the Android
Support Library.

00:24:11.460 --> 00:24:13.290
That's built for Android.

00:24:13.290 --> 00:24:16.700
When you're selecting any
libraries for your own apps

00:24:16.700 --> 00:24:19.620
be very careful that those
libraries are designed

00:24:19.620 --> 00:24:21.680
to be run on a mobile
platform, that they're not

00:24:21.680 --> 00:24:24.450
these gigantic libraries
that pull in lots of code

00:24:24.450 --> 00:24:26.470
and bloat your APK.

00:24:26.470 --> 00:24:28.780
Typically, libraries
that work best on Android

00:24:28.780 --> 00:24:32.560
are the ones that are purposed
built. And if after all this

00:24:32.560 --> 00:24:34.940
you're still finding that
you're APK is too big--

00:24:34.940 --> 00:24:38.975
and by big, by the way, you're
target should be 10 megabytes.

00:24:38.975 --> 00:24:41.910
That's what we find to
be the sweet spot in many

00:24:41.910 --> 00:24:44.550
of these next
billion user markets.

00:24:44.550 --> 00:24:47.590
If you're finding you
still are very far off it,

00:24:47.590 --> 00:24:49.480
multi-APK is a great option.

00:24:49.480 --> 00:24:52.670
Because when you enable it
and you do a build, rather

00:24:52.670 --> 00:24:56.580
than ending up with a single
monolithic APK, you can split

00:24:56.580 --> 00:24:58.750
you're APK by density sizes.

00:24:58.750 --> 00:25:02.070
So when a user with an LDPI
device installed your app

00:25:02.070 --> 00:25:05.790
they only get LDPI assets
because that's all they need.

00:25:05.790 --> 00:25:08.920
They're not burdened by
these high resolution files.

00:25:08.920 --> 00:25:10.310
And the reverse is also true.

00:25:10.310 --> 00:25:14.310
People on high resolution
devices or high density devices

00:25:14.310 --> 00:25:17.595
don't get these low density
assets that are unused.

00:25:17.595 --> 00:25:18.970
There's a little
overhead for you

00:25:18.970 --> 00:25:21.482
when you go to upload
to the Play Store.

00:25:21.482 --> 00:25:22.940
You have to upload
a few more APKs,

00:25:22.940 --> 00:25:24.230
but it's totally worth it.

00:25:27.090 --> 00:25:29.780
Data use is really,
really important

00:25:29.780 --> 00:25:32.237
when we're talking
about data in transit.

00:25:32.237 --> 00:25:33.820
And so what I'm going
to show you here

00:25:33.820 --> 00:25:35.945
is that same app that we
looked at earlier-- Europe

00:25:35.945 --> 00:25:39.490
the one that we built. And
here what I want you look at

00:25:39.490 --> 00:25:41.660
is the three peaks that
we start with here.

00:25:41.660 --> 00:25:44.180
These are the text requests.

00:25:44.180 --> 00:25:47.450
And almost immediately, you
see them becoming really small

00:25:47.450 --> 00:25:49.726
and practically down to zero.

00:25:49.726 --> 00:25:51.850
And the reason for that is
because after requesting

00:25:51.850 --> 00:25:55.360
those text that we were
displaying to the user,

00:25:55.360 --> 00:25:57.250
we request images.

00:25:57.250 --> 00:25:59.250
This is an example of
that prioritization

00:25:59.250 --> 00:26:02.710
that Kunal talked about, where
we requested the text first,

00:26:02.710 --> 00:26:05.340
provided meaningful useful
information to the user,

00:26:05.340 --> 00:26:07.400
and then started
getting the heavy work.

00:26:07.400 --> 00:26:10.140
Please run your apps through
the network Memory Monitor

00:26:10.140 --> 00:26:11.650
and see what your
behavior is like,

00:26:11.650 --> 00:26:14.080
see what your
experience is like.

00:26:14.080 --> 00:26:18.140
And ask your users,
during the warm welcome,

00:26:18.140 --> 00:26:21.940
as to what kind of usage
you want from your app.

00:26:21.940 --> 00:26:25.360
Do they want you to prefetch
information ahead of time?

00:26:25.360 --> 00:26:27.340
You don't have to make
that decision for them.

00:26:27.340 --> 00:26:29.480
Because we have a
diverse range of uses,

00:26:29.480 --> 00:26:32.940
it's always hard to find a
one-size that fits all of them.

00:26:32.940 --> 00:26:36.130
It's OK to ask them in a
nice way that makes sense.

00:26:38.870 --> 00:26:41.440
Everybody loves
their smartphones.

00:26:41.440 --> 00:26:43.400
Everybody hates
their smartphones

00:26:43.400 --> 00:26:45.900
when they die because
they've run out of battery.

00:26:45.900 --> 00:26:50.070
And apps are usually
the contributor to that.

00:26:50.070 --> 00:26:52.666
Now when we talk about
low-cost devices, of course,

00:26:52.666 --> 00:26:55.040
it means that they're going
to come with smaller capacity

00:26:55.040 --> 00:26:56.480
batteries.

00:26:56.480 --> 00:26:59.060
So it's important
for us to focus

00:26:59.060 --> 00:27:02.180
on optimizing our battery use.

00:27:02.180 --> 00:27:05.730
The first thing we should do is
ensure that the device is not

00:27:05.730 --> 00:27:08.130
being kept awake unnecessarily.

00:27:08.130 --> 00:27:10.340
So go ahead and look for
wake locks in your code

00:27:10.340 --> 00:27:14.280
and remove them, all of them if
you can, but certainly as many

00:27:14.280 --> 00:27:16.720
of them as you are able to.

00:27:16.720 --> 00:27:19.220
Because holding onto
a wake lock tells

00:27:19.220 --> 00:27:22.819
the device that you can't
go into a low power state,

00:27:22.819 --> 00:27:24.110
that you can't go into standby.

00:27:24.110 --> 00:27:28.740
So even though the screen is
off, the CPU is fully spun up.

00:27:28.740 --> 00:27:29.650
And that's bad.

00:27:29.650 --> 00:27:31.886
That destroys battery life.

00:27:31.886 --> 00:27:34.850
What we should be doing is
firing up our component,

00:27:34.850 --> 00:27:37.320
waking up when we need
to, doing our work,

00:27:37.320 --> 00:27:39.800
and shutting down-- not
holding on to wake locks,

00:27:39.800 --> 00:27:43.130
not leaving these long running
processes like I said earlier.

00:27:43.130 --> 00:27:45.130
And the way that we can
do that is with this API

00:27:45.130 --> 00:27:47.145
gcmNetworkManager.

00:27:47.145 --> 00:27:49.790
Yeah, I know it
says GCM in there,

00:27:49.790 --> 00:27:53.250
but it's actually not
specifically about Google Cloud

00:27:53.250 --> 00:27:54.400
Messaging.

00:27:54.400 --> 00:27:56.850
The API is named what
it is but trust me

00:27:56.850 --> 00:28:00.300
when I say what you use it
for is to schedule tasks.

00:28:00.300 --> 00:28:03.442
And it uses the job scheduler
on Android versions that support

00:28:03.442 --> 00:28:07.010
it or falls back gracefully
on versions that don't.

00:28:07.010 --> 00:28:09.410
So you have a single API that
supports all your Android

00:28:09.410 --> 00:28:10.650
users.

00:28:10.650 --> 00:28:12.480
And the great
thing about this is

00:28:12.480 --> 00:28:15.450
that it can wake up
your app with conditions

00:28:15.450 --> 00:28:16.260
that you define.

00:28:16.260 --> 00:28:18.140
So not just at this
particular time,

00:28:18.140 --> 00:28:22.530
but you can say things like when
the device is charging, when

00:28:22.530 --> 00:28:25.270
the device connected to Wi-Fi.

00:28:25.270 --> 00:28:28.370
And if you think about those
two conditions, they're-- ahem,

00:28:28.370 --> 00:28:31.650
excuse me-- they're very
relevant to these billions

00:28:31.650 --> 00:28:32.700
of uses.

00:28:32.700 --> 00:28:36.790
Because you want them to be able
to consume this data when it's

00:28:36.790 --> 00:28:41.710
not costing them a lot of money,
not on their cellular networks.

00:28:41.710 --> 00:28:44.040
You want to do it at a
time where you're not

00:28:44.040 --> 00:28:46.920
chewing up extra battery, i.e.

00:28:46.920 --> 00:28:48.100
when it's charging.

00:28:48.100 --> 00:28:51.310
So use gcmNetworkManager for
all your scheduling needs.

00:28:51.310 --> 00:28:53.670
If you're using
allow manager today,

00:28:53.670 --> 00:28:57.120
that's something that you should
look at changing immediately.

00:28:57.120 --> 00:28:59.290
Because gcmNeworkManager
is magic.

00:28:59.290 --> 00:29:00.890
It's fantastic.

00:29:00.890 --> 00:29:02.390
And of course,
when your app does

00:29:02.390 --> 00:29:05.820
wake up don't have it do
something really tiny,

00:29:05.820 --> 00:29:07.901
shut down, and then
wake up repeatedly.

00:29:07.901 --> 00:29:09.650
It's better to batch
our network requests.

00:29:09.650 --> 00:29:12.356
If we've got three things
that we need to do,

00:29:12.356 --> 00:29:14.870
do them together
and then shut down.

00:29:14.870 --> 00:29:17.580
Because then the device is able
to stay in that low power state

00:29:17.580 --> 00:29:18.554
for longer.

00:29:18.554 --> 00:29:19.470
Batching is important.

00:29:23.730 --> 00:29:26.770
We've talked about lots and lots
of different technical details.

00:29:26.770 --> 00:29:30.220
But of course, how we present
our information to our user

00:29:30.220 --> 00:29:32.859
is the thing that you
must solve, right?

00:29:32.859 --> 00:29:33.900
So let's look at content.

00:29:37.460 --> 00:29:38.930
Touch ripples are
really, really,

00:29:38.930 --> 00:29:40.790
really, really, important.

00:29:40.790 --> 00:29:42.520
I can't stress this enough.

00:29:42.520 --> 00:29:45.970
Because when we think
about our devices,

00:29:45.970 --> 00:29:49.100
when we touch the screen,
we need immediate feedback

00:29:49.100 --> 00:29:50.590
from our apps.

00:29:50.590 --> 00:29:53.420
And touch ripples are one
way that we do that feedback.

00:29:53.420 --> 00:29:55.080
We provide it.

00:29:55.080 --> 00:29:58.850
And often I find apps where I
will have an index of content.

00:29:58.850 --> 00:30:02.120
I will hit that content not only
will it not give me any touch

00:30:02.120 --> 00:30:05.510
feedback, but it will be
unresponsive until it pulls out

00:30:05.510 --> 00:30:06.795
the details page.

00:30:06.795 --> 00:30:08.440
And that's bad.

00:30:08.440 --> 00:30:11.580
If you're fetching any data
locally or over a network,

00:30:11.580 --> 00:30:14.350
you'll app should
always stay interactive.

00:30:14.350 --> 00:30:17.290
Provide some sort of
visual feedback to the user

00:30:17.290 --> 00:30:19.750
that you're busy
doing something.

00:30:19.750 --> 00:30:22.700
On the lower spec devices,
this is even more important

00:30:22.700 --> 00:30:25.420
because it takes them
longer to do all of this.

00:30:25.420 --> 00:30:28.050
On a lower connectivity,
it's really important

00:30:28.050 --> 00:30:30.645
because it takes longer for
them to fetch that data.

00:30:30.645 --> 00:30:34.160
Now Android devices render their
screen at 60 frames per second,

00:30:34.160 --> 00:30:35.940
and you should
always target that.

00:30:35.940 --> 00:30:38.060
We have tools in
the system setting

00:30:38.060 --> 00:30:40.840
that allow you to
see how often you're

00:30:40.840 --> 00:30:43.300
able to update your screen.

00:30:43.300 --> 00:30:46.390
So have a look at the overdraw
settings in developer options

00:30:46.390 --> 00:30:49.300
and see how your app
is performing there.

00:30:49.300 --> 00:30:54.120
And finally, when we launch
our app for the first time

00:30:54.120 --> 00:30:56.980
sometimes it can take
a while to set up.

00:30:56.980 --> 00:30:58.396
Again, you want
to show your user

00:30:58.396 --> 00:30:59.520
that something's happening.

00:30:59.520 --> 00:31:01.970
So consider using what we
call a launch screen, which

00:31:01.970 --> 00:31:04.720
is typically a big
activity that's

00:31:04.720 --> 00:31:07.520
a single color and
the light image.

00:31:07.520 --> 00:31:10.480
What that does is it says to
the user, "Yes, I'm loading.

00:31:10.480 --> 00:31:12.544
I'm telling you it's coming."

00:31:12.544 --> 00:31:14.210
And that's setting
the right expectation

00:31:14.210 --> 00:31:16.760
that it might be taking
a while, but I'm here

00:31:16.760 --> 00:31:19.890
and stay responsive.

00:31:19.890 --> 00:31:21.690
Material design makes
it easier to build

00:31:21.690 --> 00:31:25.230
for devices that are small,
as well as big-- screens that

00:31:25.230 --> 00:31:28.380
are tiny 2 inch screens,
screen in our cars,

00:31:28.380 --> 00:31:31.050
projected screens
that are 40 inches.

00:31:31.050 --> 00:31:34.450
This is probably more like 100.

00:31:34.450 --> 00:31:36.270
And so please adhere
to those guidelines.

00:31:36.270 --> 00:31:39.970
It also means that when
a new user uses your app

00:31:39.970 --> 00:31:41.900
they're already
familiar with how

00:31:41.900 --> 00:31:43.505
to use your app,
how to navigate,

00:31:43.505 --> 00:31:46.470
how to go back, right?

00:31:46.470 --> 00:31:48.500
They're used to
that consistency.

00:31:48.500 --> 00:31:51.360
And the Design Support Library,
which I mentioned earlier,

00:31:51.360 --> 00:31:53.780
is part of the Android
Support Library.

00:31:53.780 --> 00:31:57.680
We provide backward compatible
material design components

00:31:57.680 --> 00:32:00.210
that look great on the modern
versions of the Android

00:32:00.210 --> 00:32:03.940
operating system, as well as on
older versions of the operating

00:32:03.940 --> 00:32:04.629
system.

00:32:04.629 --> 00:32:06.295
You get that full
backward compatibility

00:32:06.295 --> 00:32:08.519
that I talked about earlier.

00:32:08.519 --> 00:32:10.060
So the Design Library
is really where

00:32:10.060 --> 00:32:12.960
you want to go to get your
material design components.

00:32:12.960 --> 00:32:16.790
There are also some
great community-- sorry.

00:32:16.790 --> 00:32:18.690
There are some great
community libraries

00:32:18.690 --> 00:32:20.862
that you should look at as well.

00:32:20.862 --> 00:32:22.320
Material design is
something that's

00:32:22.320 --> 00:32:25.260
interpretable by lots
and lots of developers.

00:32:25.260 --> 00:32:27.590
So we provide some great
stuff in the Design Library,

00:32:27.590 --> 00:32:31.527
but the developer community is
always moving ahead as well.

00:32:31.527 --> 00:32:34.110
And there's no point in trying
to build an app for an audience

00:32:34.110 --> 00:32:37.240
if you don't speak the
same language as them.

00:32:37.240 --> 00:32:39.320
So consider their locale.

00:32:39.320 --> 00:32:41.710
Consider which audiences
you are reaching.

00:32:41.710 --> 00:32:44.730
You may need to change
what language you support,

00:32:44.730 --> 00:32:47.707
how those layouts look and
feel on various languages.

00:32:47.707 --> 00:32:49.040
Because sometimes their smaller.

00:32:49.040 --> 00:32:50.040
Sometimes their bigger.

00:32:50.040 --> 00:32:53.400
And you want to make sure that
the text is really easy to read

00:32:53.400 --> 00:32:56.520
so choose an appropriate
font, particularly when we

00:32:56.520 --> 00:32:58.710
talk about low density screens.

00:32:58.710 --> 00:33:03.290
If that font looks
blurry at size 14 or 16,

00:33:03.290 --> 00:33:07.170
you've lost your user
because they can't read it.

00:33:07.170 --> 00:33:08.280
We support Noto.

00:33:08.280 --> 00:33:10.510
We've provided this
open source font that

00:33:10.510 --> 00:33:13.430
supports many languages, and
you'll see some Indic languages

00:33:13.430 --> 00:33:15.080
here in the screenshot.

00:33:15.080 --> 00:33:17.130
But try and identify
the right one.

00:33:17.130 --> 00:33:19.190
But remember there is
a balance in shipping

00:33:19.190 --> 00:33:22.330
your own font in your APK,
or using a system font.

00:33:22.330 --> 00:33:25.710
Because if you ship your own
font, it adds to your APK size.

00:33:25.710 --> 00:33:29.200
So just take that
into consideration.

00:33:29.200 --> 00:33:32.070
So we've talked about a
lot of technical things.

00:33:32.070 --> 00:33:36.100
But at the end of the day,
we're all part of a business.

00:33:36.100 --> 00:33:38.320
We want to be
commercially successful.

00:33:38.320 --> 00:33:41.040
And in order to do that, I'd
like to introduce Neto back

00:33:41.040 --> 00:33:42.138
on the stage.

00:33:42.138 --> 00:33:43.542
NETO MARIN: Cool, thank you.

00:33:47.286 --> 00:33:48.680
Hey, thank you.

00:33:48.680 --> 00:33:52.185
Well, as you can see, we
have many considerations

00:33:52.185 --> 00:33:54.780
when we are talking
about how to develop apps

00:33:54.780 --> 00:33:56.080
for these countries, right?

00:33:56.080 --> 00:33:59.460
And when it comes to
monetization there are also

00:33:59.460 --> 00:34:01.455
unique facets to consider.

00:34:01.455 --> 00:34:06.680
So in these kinds of markets,
the next billion user

00:34:06.680 --> 00:34:10.239
markets as Kunal and
Ankur already mentioned,

00:34:10.239 --> 00:34:12.790
the users are
sensitive to price,

00:34:12.790 --> 00:34:15.489
more so than the other
countries, right?

00:34:15.489 --> 00:34:19.030
And therefore, it's important
for you to keep it in mind

00:34:19.030 --> 00:34:22.630
when localizing prices
to these markets.

00:34:22.630 --> 00:34:24.860
So for example,
let's take a look

00:34:24.860 --> 00:34:27.639
at ways for monetizing in
such a diverse environment.

00:34:27.639 --> 00:34:31.949
Pick classic methods you
can use to monetize your app

00:34:31.949 --> 00:34:34.010
could be advertisement.

00:34:34.010 --> 00:34:36.739
So please, use that
more for example.

00:34:36.739 --> 00:34:40.480
We have in-app purchase
to sell virtual goods

00:34:40.480 --> 00:34:43.730
or implement a premium model
if you want to do that.

00:34:43.730 --> 00:34:47.810
Also you can use subscriptions
to offer a recurring billing

00:34:47.810 --> 00:34:49.940
for app or your service.

00:34:49.940 --> 00:34:55.960
And of course, we can charge
for our app as a paid app, OK?

00:34:55.960 --> 00:35:00.270
But in order to give you more
flexibility to set prices,

00:35:00.270 --> 00:35:06.420
we've announced new pricing
levels in 18 markets-- yes,

00:35:06.420 --> 00:35:11.400
18 countries where you can price
your app or your in-app item

00:35:11.400 --> 00:35:13.890
well below $1.00.

00:35:13.890 --> 00:35:17.890
So for example in Brazil, you
can price as low as one real--

00:35:17.890 --> 00:35:21.655
it's the currency in Brazil--
and in India, 10 rupees.

00:35:21.655 --> 00:35:23.730
And as you can see here
in this screenshot,

00:35:23.730 --> 00:35:26.270
we have many developers
that already embrace

00:35:26.270 --> 00:35:27.710
this sub-dollar feature.

00:35:27.710 --> 00:35:30.595
And it would be great if you
can think about how to localize

00:35:30.595 --> 00:35:33.730
your price to these markets.

00:35:33.730 --> 00:35:34.960
Here's another example.

00:35:34.960 --> 00:35:40.620
It's a famous paid
game-- Kingdom Rush.

00:35:40.620 --> 00:35:44.180
They saw tremendous success
after adopting the local price

00:35:44.180 --> 00:35:45.210
feature.

00:35:45.210 --> 00:35:50.050
They are reaching
200% more revenue,

00:35:50.050 --> 00:35:51.780
even with a lower price.

00:35:51.780 --> 00:35:54.040
And how is this
possible-- a lower price?

00:35:54.040 --> 00:35:56.250
Yes, because now
they're more relevant.

00:35:56.250 --> 00:36:01.540
They can reach many more users
with this local price, OK?

00:36:01.540 --> 00:36:04.740
So today we covered
the challenge

00:36:04.740 --> 00:36:07.160
that developers face
when building apps

00:36:07.160 --> 00:36:09.210
for billions of Android users.

00:36:09.210 --> 00:36:12.080
And to address these
challenge, we've

00:36:12.080 --> 00:36:15.760
introduced to the Building
for Billions Framework.

00:36:15.760 --> 00:36:20.560
Using this framework will result
in a great user experience

00:36:20.560 --> 00:36:26.130
for the both 1.4 billion Android
users and the next billion

00:36:26.130 --> 00:36:28.890
as they come online, OK?

00:36:28.890 --> 00:36:33.099
And also check these
links for more details

00:36:33.099 --> 00:36:35.140
of all the Building for
Billions Framework-- they

00:36:35.140 --> 00:36:38.920
have both Android and web
framework information.

00:36:38.920 --> 00:36:41.690
And also we've
published a playbook

00:36:41.690 --> 00:36:44.670
that captures the best
practices for Building

00:36:44.670 --> 00:36:46.820
for Billions on Android and web.

00:36:46.820 --> 00:36:49.490
And you can get one
now on Google Play.

00:36:49.490 --> 00:36:52.630
And also you can get one copy of
our book right on your way out,

00:36:52.630 --> 00:36:53.219
OK?

00:36:53.219 --> 00:36:54.260
Thank you for being here.

00:36:54.260 --> 00:36:54.850
Bye.

00:36:54.850 --> 00:36:56.950
[APPLAUSE]

00:36:58.450 --> 00:37:01.800
[MUSIC PLAYING]

