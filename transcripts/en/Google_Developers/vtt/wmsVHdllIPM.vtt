WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:01.560
SETH LIND: And your
every move.

00:00:01.560 --> 00:00:04.200
JOSH BLOCH: Naw, I wouldn't
go so far as to say that.

00:00:04.200 --> 00:00:05.360
SETH LIND: So welcome,
everyone.

00:00:05.360 --> 00:00:07.790
This is Dartisans,
episode three.

00:00:07.790 --> 00:00:11.130
This is a Dart hang out with
Chrome developer relations

00:00:11.130 --> 00:00:13.230
team and the Dart team.

00:00:13.230 --> 00:00:15.730
Episode three, we're going to
focus on the Dart libraries

00:00:15.730 --> 00:00:17.350
with our special guest,
Josh Bloch.

00:00:17.350 --> 00:00:18.100
Hi, Josh.

00:00:18.100 --> 00:00:18.920
JOSH BLOCH: Hello.

00:00:18.920 --> 00:00:21.390
SETH LIND: Thanks, everyone,
for joining us.

00:00:21.390 --> 00:00:24.930
Please do ask your questions in
our Google Moderator, which

00:00:24.930 --> 00:00:29.140
is linked from the original
post. And later in the show,

00:00:29.140 --> 00:00:32.130
we'll take questions from the
moderator and your live

00:00:32.130 --> 00:00:33.560
questions in the hang out.

00:00:33.560 --> 00:00:36.200
So please join us there
or add your questions.

00:00:36.200 --> 00:00:39.700
Vote up or down what you'd
like to know about Dart

00:00:39.700 --> 00:00:43.280
libraries and what Josh and
his team are up to.

00:00:43.280 --> 00:00:45.640
So with that, we're going
to dive into it.

00:00:45.640 --> 00:00:47.470
Thanks again for spending
time with us, Josh.

00:00:47.470 --> 00:00:48.300
JOSH BLOCH: It's my pleasure.

00:00:48.300 --> 00:00:49.360
SETH LIND: This is
really exciting.

00:00:49.360 --> 00:00:51.230
One thing I really like working
with the Dart team is

00:00:51.230 --> 00:00:53.870
everyone's really open and
sharing of what they're doing.

00:00:53.870 --> 00:00:55.610
And I think that really
helps, especially

00:00:55.610 --> 00:00:57.130
in this early stage.

00:00:57.130 --> 00:00:59.710
As the technology preview, it's
good, I think, to pull

00:00:59.710 --> 00:01:02.710
back the curtains and show
everyone what we're thinking

00:01:02.710 --> 00:01:04.260
and what direction
we're going.

00:01:04.260 --> 00:01:06.000
So I really appreciate
it, thanks.

00:01:06.000 --> 00:01:08.092
JOSH BLOCH: I love it, too,
because basically we can still

00:01:08.092 --> 00:01:08.490
change things.

00:01:08.490 --> 00:01:10.915
And it's good to get feedback
when you can

00:01:10.915 --> 00:01:13.330
still change things.

00:01:13.330 --> 00:01:13.456
SETH LIND: Yeah.

00:01:13.456 --> 00:01:15.810
And this is why these kind of
hangouts and moderating links

00:01:15.810 --> 00:01:17.570
are so important.

00:01:17.570 --> 00:01:19.990
So you've been working with
libraries and library design

00:01:19.990 --> 00:01:23.950
for quite some time now as
author of Effective Java,

00:01:23.950 --> 00:01:26.710
which-- by the way, even if
you're not a Java developer, I

00:01:26.710 --> 00:01:30.010
learned a ton of great just
general programming advice

00:01:30.010 --> 00:01:30.950
from Effective Java.

00:01:30.950 --> 00:01:33.650
So I highly recommend
the book.

00:01:33.650 --> 00:01:36.100
And Puzzlers in Java
as well, which is a

00:01:36.100 --> 00:01:37.340
really interesting read.

00:01:37.340 --> 00:01:39.830
And we'll touch a little bit
more on the puzzlers later.

00:01:39.830 --> 00:01:42.820
But tell us a little bit about
your background and your

00:01:42.820 --> 00:01:44.480
experience designing and
building libraries.

00:01:44.480 --> 00:01:45.970
JOSH BLOCH: Well,
that's funny.

00:01:45.970 --> 00:01:49.200
When I think about, I've really
been doing that as long

00:01:49.200 --> 00:01:52.210
as I've been in computer
science.

00:01:52.210 --> 00:01:56.360
I was a [UNINTELLIGIBLE] student
interning at IBM

00:01:56.360 --> 00:01:59.320
Yorktown Heights in like 1982.

00:01:59.320 --> 00:02:02.645
The first thing I did was took
some functionality they had on

00:02:02.645 --> 00:02:05.950
an experimental parallel
processing IBM 370, and said,

00:02:05.950 --> 00:02:09.130
wow, this is unusable, and
wrapped it in a nice library

00:02:09.130 --> 00:02:11.680
so everyone could use it.

00:02:11.680 --> 00:02:14.190
And I didn't realize it, that
would be a pattern for my

00:02:14.190 --> 00:02:15.550
career from then on out.

00:02:15.550 --> 00:02:16.640
But it was.

00:02:16.640 --> 00:02:18.300
So basically I've been designing
and building

00:02:18.300 --> 00:02:21.675
libraries continuously for
the past 30 years or so.

00:02:21.675 --> 00:02:24.590
SETH LIND: So when people think
designing libraries, in

00:02:24.590 --> 00:02:27.300
some sense, everyone
writes libraries.

00:02:27.300 --> 00:02:29.490
But I think you're thinking of
that slightly different.

00:02:29.490 --> 00:02:32.195
What's the difference between
designing the library surface

00:02:32.195 --> 00:02:34.800
area I think that you're mostly
talking about versus

00:02:34.800 --> 00:02:36.240
just coding a program.

00:02:36.240 --> 00:02:36.875
Is there a difference there?

00:02:36.875 --> 00:02:38.570
JOSH BLOCH: There is a
difference, although I think

00:02:38.570 --> 00:02:41.590
they're closer than most people
give them credit for.

00:02:41.590 --> 00:02:46.685
To wit, APIs are incredibly
important as anyone who has

00:02:46.685 --> 00:02:49.486
seen my API design talk knows
how I feel about this.

00:02:49.486 --> 00:02:54.740
But a well-written API provides
building blocks that

00:02:54.740 --> 00:02:59.880
lets programmers build programs
easily and up the

00:02:59.880 --> 00:03:03.170
odds that their programs will
be correct and readable.

00:03:03.170 --> 00:03:06.730
So thinking hard about your
APIs has always been very,

00:03:06.730 --> 00:03:08.900
very important to me.

00:03:08.900 --> 00:03:13.400
And I feel like to some degree
I proselytize the importance

00:03:13.400 --> 00:03:13.800
of good APIs.

00:03:13.800 --> 00:03:15.650
I want more people to
think about it.

00:03:15.650 --> 00:03:19.870
And especially if your APIs
going to be used widely by a

00:03:19.870 --> 00:03:23.620
larger audience over a long time
period, anything you do

00:03:23.620 --> 00:03:26.710
right will pay for itself 1,000
times over as people

00:03:26.710 --> 00:03:28.090
take advantage of
your library.

00:03:28.090 --> 00:03:31.655
And anything you've done wrong
will cause bugs and will cause

00:03:31.655 --> 00:03:34.080
people to tear their hair
out 1,000 times over.

00:03:34.080 --> 00:03:39.220
So in that sense, designing
libraries is perhaps more

00:03:39.220 --> 00:03:41.305
important than ordinary
programming.

00:03:41.305 --> 00:03:43.890
But when you're doing ordinary
programing at

00:03:43.890 --> 00:03:46.380
scale, you have modules.

00:03:46.380 --> 00:03:48.870
And modules talk to each other
through intermodule

00:03:48.870 --> 00:03:49.810
boundaries.

00:03:49.810 --> 00:03:52.410
And if you apply those same
techniques in designing those

00:03:52.410 --> 00:03:57.470
intermodular APIs that
I design to my widely

00:03:57.470 --> 00:04:02.270
distributed APIs, you'll find
that your large programs are

00:04:02.270 --> 00:04:06.220
easier to maintain, easier to
read, more likely to be bug

00:04:06.220 --> 00:04:08.590
free, and just generally
make you happier.

00:04:08.590 --> 00:04:11.470
SETH LIND: I often think that's
with API design-- which

00:04:11.470 --> 00:04:12.210
I think you're right.

00:04:12.210 --> 00:04:14.394
That's a better term
than just library.

00:04:14.394 --> 00:04:17.590
That your client, your customer
is other developers.

00:04:17.590 --> 00:04:18.320
JOSH BLOCH: Yup.

00:04:18.320 --> 00:04:18.679
SETH LIND: Right?

00:04:18.679 --> 00:04:22.300
And whenever I think of when I'm
designing the surface area

00:04:22.300 --> 00:04:25.670
for my interfaces or the API,
I just think, how would

00:04:25.670 --> 00:04:26.450
someone else be using this?

00:04:26.450 --> 00:04:27.420
It's not just for me.

00:04:27.420 --> 00:04:29.390
I know what's going on
behind the curtain.

00:04:29.390 --> 00:04:30.720
How are other people
going to use this?

00:04:30.720 --> 00:04:32.390
Because that really
affects my design.

00:04:32.390 --> 00:04:33.230
JOSH BLOCH: Yes.

00:04:33.230 --> 00:04:39.360
Basically, you want to provide
as much power as they need

00:04:39.360 --> 00:04:43.410
with the minimal surface area,
maximal consistency.

00:04:43.410 --> 00:04:46.830
This is a very short summary
of this much longer talk.

00:04:46.830 --> 00:04:49.360
But that's what it's
all about.

00:04:49.360 --> 00:04:53.055
It's really a lot like designing
GUIs, except that it

00:04:53.055 --> 00:04:53.870
isn't a GUI.

00:04:53.870 --> 00:04:56.270
It's a programmatic API
with many of the

00:04:56.270 --> 00:04:58.640
same principles hold.

00:04:58.640 --> 00:05:01.960
You want things to
be consistent.

00:05:01.960 --> 00:05:03.530
You don't want to violate
the principle of least

00:05:03.530 --> 00:05:04.400
astonishment.

00:05:04.400 --> 00:05:08.030
And you want to make it easy
for people to do what they

00:05:08.030 --> 00:05:08.910
want to do.

00:05:08.910 --> 00:05:11.340
The hardest thing in both cases
about what he said, just

00:05:11.340 --> 00:05:13.310
think what people will
actually want to

00:05:13.310 --> 00:05:14.710
do with your interface.

00:05:14.710 --> 00:05:16.858
You can't write an interface if
you don't know what people

00:05:16.858 --> 00:05:17.820
are going to want to do.

00:05:17.820 --> 00:05:20.810
And you can try your best
to figure out what

00:05:20.810 --> 00:05:21.630
they'll want to do.

00:05:21.630 --> 00:05:22.910
But some people will
surprise you.

00:05:22.910 --> 00:05:26.630
They'll use your APIs in ways
that you've never imagined.

00:05:26.630 --> 00:05:29.671
And you'll have to grow them.

00:05:29.671 --> 00:05:31.960
SETH LIND: Well, I think that's
already happening now

00:05:31.960 --> 00:05:33.530
as technology preview in Dart.

00:05:33.530 --> 00:05:36.560
And we're getting all this
great feedback as we have

00:05:36.560 --> 00:05:38.010
certain use cases that
we built for.

00:05:38.010 --> 00:05:40.700
But then, we see our public
using it as well.

00:05:40.700 --> 00:05:42.240
And I love it because
they send us these

00:05:42.240 --> 00:05:43.310
feedback, and bugs.

00:05:43.310 --> 00:05:46.110
And the open request is always
standing that if you have

00:05:46.110 --> 00:05:48.490
feedback for this team, we have
mailing lists and issue

00:05:48.490 --> 00:05:50.470
trackers, dartbug.com.

00:05:50.470 --> 00:05:52.850
Please let us know what you're
doing with these libraries.

00:05:52.850 --> 00:05:54.510
This really affects
the design.

00:05:54.510 --> 00:05:56.640
In fact, I see it right now
with our I/O libraries.

00:05:56.640 --> 00:05:58.655
People are telling us what
they're trying to do with

00:05:58.655 --> 00:06:02.310
them, and we see CLs or patches
in direct response.

00:06:02.310 --> 00:06:03.250
And so this is great.

00:06:03.250 --> 00:06:05.130
Let us know what you're doing.

00:06:05.130 --> 00:06:07.730
JOSH BLOCH: Basically, the
term I use is fail your

00:06:07.730 --> 00:06:09.200
imagination.

00:06:09.200 --> 00:06:13.160
No matter how hard I think, I
cannot imagine what all people

00:06:13.160 --> 00:06:14.706
might try to do with my API.

00:06:14.706 --> 00:06:17.780
So I give it my best shot and
I still need your help.

00:06:17.780 --> 00:06:19.370
SETH LIND: Mm-hm.

00:06:19.370 --> 00:06:21.860
So before Google, you
were working at Sun.

00:06:21.860 --> 00:06:22.550
JOSH BLOCH: Yes.

00:06:22.550 --> 00:06:24.730
SETH LIND: And you worked
on some Java libraries.

00:06:24.730 --> 00:06:26.040
What were some of the libraries
that you worked on?

00:06:26.040 --> 00:06:27.740
JOSH BLOCH: Well, most famously,
collections.

00:06:27.740 --> 00:06:29.990
I did the collections
framework in Java.

00:06:29.990 --> 00:06:33.450
And by the way, I'm going to
be taking a serious pass of

00:06:33.450 --> 00:06:37.380
the entire collection's
framework in Dart shortly.

00:06:37.380 --> 00:06:40.220
That's the first big thing that
I'm going to be doing to

00:06:40.220 --> 00:06:43.530
these libraries, use the
knowledge that I've gained.

00:06:43.530 --> 00:06:45.070
I've written several collections
frameworks.

00:06:45.070 --> 00:06:47.290
I actually wrote one
before Java at a

00:06:47.290 --> 00:06:48.640
company called Transarc.

00:06:48.640 --> 00:06:52.930
It was in C. And it actually
was generic.

00:06:52.930 --> 00:06:56.416
It did all the things that the
Java one did, but it was in C,

00:06:56.416 --> 00:06:58.840
through massive abuse of the
[INAUDIBLE] processor.

00:06:58.840 --> 00:07:00.540
Anyway, I digress.

00:07:00.540 --> 00:07:02.620
So I did collections.

00:07:02.620 --> 00:07:06.870
I did some multi-threading
stuff like timers.

00:07:06.870 --> 00:07:11.460
The first thing I did in 1996
and 1997 was Java math,

00:07:11.460 --> 00:07:14.050
multi-precision arithmetic.

00:07:14.050 --> 00:07:18.590
I think it was the first widely
distributed language.

00:07:18.590 --> 00:07:20.900
All those people that
complained, this is widely

00:07:20.900 --> 00:07:21.580
distributed!

00:07:21.580 --> 00:07:23.340
But anyway, I think it was the
first widely distributed

00:07:23.340 --> 00:07:25.866
language that had
multi-precision arithmetic,

00:07:25.866 --> 00:07:28.665
and that was great because
high school students who

00:07:28.665 --> 00:07:31.300
wanted to see what 100 factorial
actually looked like

00:07:31.300 --> 00:07:33.960
could just do it with
one line of code.

00:07:33.960 --> 00:07:35.650
So that was the first
thing I did.

00:07:35.650 --> 00:07:38.280
And there were a bunch of other
things I helped with.

00:07:38.280 --> 00:07:41.220
My friend, [? Mike McCauskey ?],
did the

00:07:41.220 --> 00:07:42.530
regular expression library.

00:07:42.530 --> 00:07:44.270
I helped him design that.

00:07:44.270 --> 00:07:45.010
I don't know.

00:07:45.010 --> 00:07:47.405
You lose track, but bits and
pieces-- oh, and language

00:07:47.405 --> 00:07:48.900
stuff, too.

00:07:48.900 --> 00:07:52.320
Actually, as recently as Java
7, I was still actively

00:07:52.320 --> 00:07:53.336
involved in [INAUDIBLE].

00:07:53.336 --> 00:07:55.420
If you know about the automatic
resource management

00:07:55.420 --> 00:07:58.570
blocks, ARM blocks in Java 7--

00:07:58.570 --> 00:08:01.540
I guess that name was changed
in trial [INAUDIBLE],

00:08:01.540 --> 00:08:02.100
something like that.

00:08:02.100 --> 00:08:04.730
But anyway, that
was my biggie.

00:08:04.730 --> 00:08:09.450
There's some good ideas in that
that I'm hoping to use in

00:08:09.450 --> 00:08:11.186
Dart, for example.

00:08:11.186 --> 00:08:14.860
In fact, if you have an
exception ending and another

00:08:14.860 --> 00:08:17.600
exception is thrown, it
shouldn't just blow away the

00:08:17.600 --> 00:08:19.000
first exception.

00:08:19.000 --> 00:08:20.360
I mentioned that--

00:08:20.360 --> 00:08:22.060
SETH LIND: Do they get
chained, then?

00:08:22.060 --> 00:08:24.240
JOSH BLOCH: Yeah, it isn't
exactly chained.

00:08:24.240 --> 00:08:25.480
There's two chains.

00:08:25.480 --> 00:08:27.767
The idea is you have
the basic chain.

00:08:27.767 --> 00:08:30.900
I also put in my own--
this is Java 1.4--

00:08:30.900 --> 00:08:31.960
this causal chain.

00:08:31.960 --> 00:08:35.929
This exception was caused by
this exception, which was

00:08:35.929 --> 00:08:37.190
caused by that exception.

00:08:37.190 --> 00:08:39.220
So that was put in in 1.4.

00:08:39.220 --> 00:08:42.740
But then, the thing that
was put in in Java 7 is

00:08:42.740 --> 00:08:44.440
suppression.

00:08:44.440 --> 00:08:47.860
And incidentally, I suppressed
this exception in order to

00:08:47.860 --> 00:08:49.450
bring that exception because
I think that

00:08:49.450 --> 00:08:52.460
exception is more important.

00:08:52.460 --> 00:08:56.420
And I mentioned those ideas to
[? Lars Hawk ?], and he liked

00:08:56.420 --> 00:08:57.330
those ideas.

00:08:57.330 --> 00:09:00.480
So we might see some of those
ideas reappearing in Dart.

00:09:00.480 --> 00:09:02.250
SETH LIND: Go back to the
questions libraries, because I

00:09:02.250 --> 00:09:03.530
think that's the first--

00:09:03.530 --> 00:09:07.730
at least, when I first
approached Java, I was

00:09:07.730 --> 00:09:11.090
appreciative that it brought you
a lot of these libraries

00:09:11.090 --> 00:09:11.815
just out of the box.

00:09:11.815 --> 00:09:13.200
And so I think that's
a great selling

00:09:13.200 --> 00:09:13.990
point of Dart, as well.

00:09:13.990 --> 00:09:15.000
It's not just the language.

00:09:15.000 --> 00:09:17.080
It's a lot of its libraries
and virtual machines.

00:09:17.080 --> 00:09:19.470
The whole batteries-included
environment.

00:09:19.470 --> 00:09:21.910
So for collections, I'm sure
that there's a bunch of

00:09:21.910 --> 00:09:25.920
lessons that you learned from
the initial take at with Java.

00:09:25.920 --> 00:09:28.120
What are some of the things that
you might do differently

00:09:28.120 --> 00:09:30.456
now in Dart with their
collection libraries?

00:09:30.456 --> 00:09:32.570
JOSH BLOCH: So I will answer
your question.

00:09:32.570 --> 00:09:38.655
But I will first say that the
biggest thing that I learned

00:09:38.655 --> 00:09:40.550
is what you just said.

00:09:40.550 --> 00:09:45.745
Back before then, you didn't
get much in the libraries.

00:09:45.745 --> 00:09:48.112
If you look at the C libraries,
and even C++ prior

00:09:48.112 --> 00:09:51.550
to STL, you had to
roll your own.

00:09:51.550 --> 00:09:55.040
And I was in an environment in
the 1990s where everyone--

00:09:55.040 --> 00:09:58.245
if you had a large project,
there'd be 50, 60 hash tables.

00:09:58.245 --> 00:10:01.145
And the first thing I did
was say this was crazy.

00:10:01.145 --> 00:10:02.473
It's hard to write a
good hash table.

00:10:02.473 --> 00:10:07.190
And I wrote one generic,
reusable hash table.

00:10:07.190 --> 00:10:11.930
So the first thing that I
learned then that I think--

00:10:11.930 --> 00:10:13.480
lesson to take away from this.

00:10:13.480 --> 00:10:16.310
And at this point, the lesson
is so widely held to be true

00:10:16.310 --> 00:10:19.462
that I'm saying it only because
people wouldn't

00:10:19.462 --> 00:10:21.920
realize that it might
be a lesson.

00:10:21.920 --> 00:10:25.740
Because making as much useful
functionality available to

00:10:25.740 --> 00:10:29.570
people in the libraries as
possible so that they can

00:10:29.570 --> 00:10:30.620
write applications quickly.

00:10:30.620 --> 00:10:33.630
So they don't have to just write
their own versions of

00:10:33.630 --> 00:10:34.270
all these things.

00:10:34.270 --> 00:10:38.650
But I learned many detailed
lessons, both positive and

00:10:38.650 --> 00:10:40.740
negative, in collections.

00:10:40.740 --> 00:10:44.930
You can see things I did wrong
by looking at, for example,

00:10:44.930 --> 00:10:49.340
navigable set and now and
sorting set and now.

00:10:49.340 --> 00:10:51.470
Why are there these
two pairs of APIs?

00:10:51.470 --> 00:10:53.360
Frankly, because
I forgot stuff.

00:10:53.360 --> 00:10:56.120
I didn't realize that it would
be necessary in the first set

00:10:56.120 --> 00:10:57.040
of interfaces.

00:10:57.040 --> 00:10:59.660
So we needed to extend them
with the second set of

00:10:59.660 --> 00:11:01.240
interfaces.

00:11:01.240 --> 00:11:04.220
And you can bet that I won't
forget the same things again.

00:11:04.220 --> 00:11:05.550
I'll forget something else.

00:11:05.550 --> 00:11:13.910
But there were various
things that I didn't

00:11:13.910 --> 00:11:15.930
realize would be necessary.

00:11:15.930 --> 00:11:19.700
And these things chill
as warps in the APIs.

00:11:19.700 --> 00:11:22.190
SETH LIND: We were talking
something like allowing

00:11:22.190 --> 00:11:25.406
people, developers to
extend our list

00:11:25.406 --> 00:11:26.820
implementation classes.

00:11:26.820 --> 00:11:28.930
That seems like something
we may not do again.

00:11:28.930 --> 00:11:30.780
JOSH BLOCH: Yeah, it's an
interesting question.

00:11:30.780 --> 00:11:34.110
This is actually a very
controversial area.

00:11:34.110 --> 00:11:38.140
There's one school of thought,
and it comes from small

00:11:38.140 --> 00:11:40.670
[UNINTELLIGIBLE] lists, which
is, hey, it's all just code.

00:11:40.670 --> 00:11:43.620
Extend anything you want.

00:11:43.620 --> 00:11:45.570
JavaScript as well,
by the way.

00:11:45.570 --> 00:11:46.850
And then, another--

00:11:46.850 --> 00:11:52.010
which I certainly espouse, as
I did in Effective Java--

00:11:52.010 --> 00:11:54.690
which is hide as much
as possible.

00:11:54.690 --> 00:11:56.980
Keep the conceptual surface
area small.

00:11:56.980 --> 00:12:00.300
Make these interfaces,
lists, set, map.

00:12:00.300 --> 00:12:02.930
Give them the notations, but
don't necessarily allow people

00:12:02.930 --> 00:12:05.980
to actually extend the
implementation classes because

00:12:05.980 --> 00:12:08.450
there's what's called the
fragile base class problem.

00:12:08.450 --> 00:12:10.768
And if you extend them, what you
have is-- if they happen

00:12:10.768 --> 00:12:13.070
to be fragile, if I change the
base class that you've

00:12:13.070 --> 00:12:17.700
extended, I might break your
extension class because of the

00:12:17.700 --> 00:12:20.910
fact that you may be dependent
on self-use patterns.

00:12:20.910 --> 00:12:23.480
One method calls a second
method, and you've overwritten

00:12:23.480 --> 00:12:26.520
the second method, changing the
behavior of both methods.

00:12:26.520 --> 00:12:29.420
What if my next version of the
superclass doesn't have that

00:12:29.420 --> 00:12:31.740
same relationship between
the two methods?

00:12:31.740 --> 00:12:35.300
All of a sudden, you're subclass
behaves different.

00:12:35.300 --> 00:12:40.830
So you actually get more robust
programs if you don't

00:12:40.830 --> 00:12:43.620
extend classes across
libraries.

00:12:43.620 --> 00:12:46.700
This is very controversial
because some people think the

00:12:46.700 --> 00:12:50.250
essence of object oriented
programming is inheritance.

00:12:50.250 --> 00:12:53.050
I think that inheritance within
libraries is great.

00:12:53.050 --> 00:12:56.307
Across libraries is similarly
questionable, unless the

00:12:56.307 --> 00:12:59.820
library classes were designed
and documented for

00:12:59.820 --> 00:13:00.320
inheritance.

00:13:00.320 --> 00:13:04.000
So if you have things like the
skeletal list set and map

00:13:04.000 --> 00:13:07.960
implementation in Java called
abstract set, abstract list,

00:13:07.960 --> 00:13:10.170
abstract map, those are fine.

00:13:10.170 --> 00:13:14.030
But I've documented them so
thoroughly that I cannot

00:13:14.030 --> 00:13:17.950
change those self-use patterns
and still obey the

00:13:17.950 --> 00:13:19.710
specifications.

00:13:19.710 --> 00:13:23.240
Anyway, right now the
Dart collections are

00:13:23.240 --> 00:13:26.160
a little bit jumbled.

00:13:26.160 --> 00:13:28.080
These aren't quite consistent.

00:13:28.080 --> 00:13:29.920
And generally speaking,
they are all

00:13:29.920 --> 00:13:31.040
available for extension.

00:13:31.040 --> 00:13:31.950
But they're not documented.

00:13:31.950 --> 00:13:33.760
They're sitting in this thing
called Dart core invoke.

00:13:33.760 --> 00:13:37.770
And when you look at Dart core
invoked, it isn't clear which

00:13:37.770 --> 00:13:42.050
of those classes were
intentionally published for

00:13:42.050 --> 00:13:42.980
your use, and which ones--

00:13:42.980 --> 00:13:43.640
SETH LIND: Exactly.

00:13:43.640 --> 00:13:45.790
When I see that symbol, I think,
well, that stuff, I

00:13:45.790 --> 00:13:46.590
shouldn't-- should
I be touching?

00:13:46.590 --> 00:13:47.410
JOSH BLOCH: Yeah, it's
implementation.

00:13:47.410 --> 00:13:48.530
SETH LIND: Yeah, it's
details, yeah.

00:13:48.530 --> 00:13:50.800
JOSH BLOCH: So basically, I'm
going to take a long, hard

00:13:50.800 --> 00:13:52.900
look at everything in there.

00:13:52.900 --> 00:13:54.580
And yes, some of it
will disappear.

00:13:54.580 --> 00:13:57.201
And I know I'll get
some hate mail.

00:13:57.201 --> 00:14:00.682
But I think it's all for
the better in the end.

00:14:00.682 --> 00:14:03.940
And yeah, I want to take a
principled approach to the

00:14:03.940 --> 00:14:06.330
whole thing, which means we have
to solve these questions

00:14:06.330 --> 00:14:10.580
of should the implementation
classes generally be available

00:14:10.580 --> 00:14:13.650
as classes for you
to extend or not?

00:14:13.650 --> 00:14:15.240
Java, generally they were.

00:14:15.240 --> 00:14:19.770
And generally speaking, people
didn't do much useful actually

00:14:19.770 --> 00:14:22.090
extending the hash
map or whatever.

00:14:22.090 --> 00:14:24.800
If I had it to do again,
maybe I wouldn't.

00:14:24.800 --> 00:14:27.430
If you look at the later
collections, some of them are

00:14:27.430 --> 00:14:29.540
not extendable in
that fashion.

00:14:29.540 --> 00:14:36.310
So if you look at, let's say,
the enum set, an enum map.

00:14:36.310 --> 00:14:40.700
Now, enum only named set.

00:14:40.700 --> 00:14:43.610
Enum set, there was an abstract
class in the public

00:14:43.610 --> 00:14:44.530
constructors.

00:14:44.530 --> 00:14:46.460
So you literally cannot
extend it.

00:14:46.460 --> 00:14:48.410
And you don't even know the
implementation classes are.

00:14:48.410 --> 00:14:50.030
Turns out there are
two of them.

00:14:50.030 --> 00:14:51.780
Internally, they're called
regular and imset,

00:14:51.780 --> 00:14:53.300
and jumbo and imset.

00:14:53.300 --> 00:14:55.660
One of them is if the underlying
enum has fewer than

00:14:55.660 --> 00:14:59.230
64 elements, the whole thing
is represented as a single

00:14:59.230 --> 00:15:02.900
long, whereas if it has more
elements, it's represented as

00:15:02.900 --> 00:15:03.600
an array of longs.

00:15:03.600 --> 00:15:04.510
But you don't have to
worry about that.

00:15:04.510 --> 00:15:05.610
It's an implementation detail.

00:15:05.610 --> 00:15:08.270
And generally speaking, I'm
a huge believer in hiding

00:15:08.270 --> 00:15:10.003
implementation details.

00:15:10.003 --> 00:15:13.260
SETH LIND: I agree, I agree.

00:15:13.260 --> 00:15:16.710
So Dart is targeted to
modern web apps.

00:15:16.710 --> 00:15:18.380
I think that's pretty fair.

00:15:18.380 --> 00:15:20.430
And certainly end-to-end web
apps, Dart running on the

00:15:20.430 --> 00:15:22.996
server, Dart compiling the
JavaScript or running on the

00:15:22.996 --> 00:15:24.720
Dart virtual machine
on the client.

00:15:24.720 --> 00:15:27.395
But definitely these modern
clients like web apps, how do

00:15:27.395 --> 00:15:28.850
you think that this affects our

00:15:28.850 --> 00:15:30.150
language of library designs?

00:15:30.150 --> 00:15:34.410
Does it change the way you
look at this with such an

00:15:34.410 --> 00:15:36.490
initial target deployment?

00:15:36.490 --> 00:15:37.495
JOSH BLOCH: It does.

00:15:37.495 --> 00:15:40.040
And by the way, sometimes I'm
going to have to learn more

00:15:40.040 --> 00:15:41.040
about this stuff.

00:15:41.040 --> 00:15:43.360
And I've done a lot of yet.

00:15:43.360 --> 00:15:47.220
But it certainly means that
it's very important that

00:15:47.220 --> 00:15:52.107
things be scalable, and in
particular that it be very

00:15:52.107 --> 00:15:57.370
easy to just bang out something
that works even if

00:15:57.370 --> 00:16:00.370
you won't be able to grow
that particular app.

00:16:00.370 --> 00:16:02.380
You may have to re-write it.

00:16:02.380 --> 00:16:03.490
You don't want to have to--

00:16:03.490 --> 00:16:04.620
I think there's a--

00:16:04.620 --> 00:16:07.830
Java, you couldn't write a Java
program without saying

00:16:07.830 --> 00:16:09.680
public, static, final.

00:16:09.680 --> 00:16:11.360
And I'm probably saying
this wrong.

00:16:11.360 --> 00:16:13.450
I have a cold, and my
brain's running.

00:16:13.450 --> 00:16:14.300
It has to be today.

00:16:14.300 --> 00:16:19.770
But anyway, the point is that
there's a verbosity that was

00:16:19.770 --> 00:16:21.020
there for a reason.

00:16:23.600 --> 00:16:28.390
The whole goal was making as
certain as possible that your

00:16:28.390 --> 00:16:31.955
program was going to run
without bugs once

00:16:31.955 --> 00:16:33.530
it compiled at all.

00:16:33.530 --> 00:16:34.790
And that's OK.

00:16:34.790 --> 00:16:36.206
But that's not the
Dart philosophy.

00:16:36.206 --> 00:16:39.025
The Dart philosophy is
you should be able

00:16:39.025 --> 00:16:39.500
to script with it.

00:16:39.500 --> 00:16:43.380
You should be able to write
something really quickly that

00:16:43.380 --> 00:16:45.560
you should be able to run
by clicking the button.

00:16:45.560 --> 00:16:47.740
You should be able
to iterate on it.

00:16:47.740 --> 00:16:50.070
And yes, that does affect
the libraries.

00:16:50.070 --> 00:16:53.320
It means that you want to
ensure that they're

00:16:53.320 --> 00:16:56.010
lightweight to you, not
factories of factories, that

00:16:56.010 --> 00:16:57.460
kind of thing.

00:16:57.460 --> 00:17:00.580
So yeah, I'm sure it's going to
affect the library design.

00:17:00.580 --> 00:17:02.380
SETH LIND: That's great.

00:17:02.380 --> 00:17:04.720
Let's talk about puzzlers
for a minute.

00:17:04.720 --> 00:17:10.690
So Java Puzzlers is a fun look
at the dark corners of the

00:17:10.690 --> 00:17:11.700
Java language.

00:17:11.700 --> 00:17:14.460
And if you've been programming
Java a lot, you've run into

00:17:14.460 --> 00:17:15.390
these corners.

00:17:15.390 --> 00:17:19.930
So Josh and his authors
put together--

00:17:19.930 --> 00:17:21.890
pulled back the curtains a
little bit and said, are you

00:17:21.890 --> 00:17:23.959
aware of these dark corners
if you haven't

00:17:23.959 --> 00:17:24.980
gone down them before?

00:17:24.980 --> 00:17:28.089
And it's a really good look
at Java the language.

00:17:28.089 --> 00:17:30.900
We've been going through the
Puzzler book and translating

00:17:30.900 --> 00:17:31.590
it to Dart.

00:17:31.590 --> 00:17:33.160
And you can see the beginnings
of this on

00:17:33.160 --> 00:17:35.010
dartlang.org, our website.

00:17:35.010 --> 00:17:36.800
What are some of the things that
you've found after this

00:17:36.800 --> 00:17:39.130
initial pass through
Java Puzzlers and

00:17:39.130 --> 00:17:40.386
applying it to Dart?

00:17:40.386 --> 00:17:42.760
JOSH BLOCH: First, I should say
that the original book was

00:17:42.760 --> 00:17:46.116
co-authored by Neal Gafter, so
credit where credit is due.

00:17:46.116 --> 00:17:48.545
He and I both have a hobby of
collecting these puzzlers and

00:17:48.545 --> 00:17:51.680
turned it into a series of talks
and then into the book.

00:17:51.680 --> 00:17:55.660
And yeah, basically one of the
things that we envisioned the

00:17:55.660 --> 00:17:59.200
being used for when we wrote
it was designers of new

00:17:59.200 --> 00:18:02.022
languages could use the puzzlers
to ensure they

00:18:02.022 --> 00:18:04.080
weren't making the same mistakes
that were made in the

00:18:04.080 --> 00:18:06.410
Java language and libraries.

00:18:06.410 --> 00:18:07.680
It's a fairly straightforward
process.

00:18:07.680 --> 00:18:11.380
You just take all these programs
and translate them

00:18:11.380 --> 00:18:12.930
into the new language.

00:18:12.930 --> 00:18:15.310
And you see how many of
the puzzlers remain.

00:18:15.310 --> 00:18:18.770
Now, if those puzzlers are gone,
it does not mean the

00:18:18.770 --> 00:18:19.620
language is without puzzlers.

00:18:19.620 --> 00:18:21.102
It may have different
puzzlers that you

00:18:21.102 --> 00:18:21.956
haven't discovered yet.

00:18:21.956 --> 00:18:23.380
And If you look at--

00:18:23.380 --> 00:18:26.630
there was one chapter of Dart
Puzzlers up, and there'll be a

00:18:26.630 --> 00:18:28.430
second one sometime
today, I believe.

00:18:28.430 --> 00:18:29.355
SETH LIND: Mm-hm.

00:18:29.355 --> 00:18:33.210
JOSH BLOCH: You'll see that, in
fact, Dart has a very good

00:18:33.210 --> 00:18:36.430
record of solving the
Java puzzlers,

00:18:36.430 --> 00:18:39.030
something like 90% of the--

00:18:39.030 --> 00:18:39.820
roughly speaking--

00:18:39.820 --> 00:18:43.312
of the Java puzzlers so far
have been eliminated.

00:18:43.312 --> 00:18:46.140
I've only done a couple chapters
in there, like maybe

00:18:46.140 --> 00:18:47.680
eight chapters in the book.

00:18:47.680 --> 00:18:49.980
So we'll see if we
keep that record.

00:18:49.980 --> 00:18:52.375
But on the hand, I've already
found some new puzzlers that

00:18:52.375 --> 00:18:55.540
are particular to Dart that
don't exist in Java.

00:18:55.540 --> 00:18:59.790
And clearly, you want to
exterminate puzzlers as soon

00:18:59.790 --> 00:19:00.740
as you find them.

00:19:00.740 --> 00:19:02.850
Puzzlers are fun, but they're
not a good thing.

00:19:02.850 --> 00:19:06.150
Ideally, a language would
have no puzzlers.

00:19:06.150 --> 00:19:07.430
That may be unrealistic.

00:19:07.430 --> 00:19:09.860
But a puzzler typically--

00:19:09.860 --> 00:19:13.940
the way we got a lot of the
puzzlers was people would

00:19:13.940 --> 00:19:18.630
write trial bugs against the
language of core libraries,

00:19:18.630 --> 00:19:21.220
and the bug would get
closed as not a bug.

00:19:21.220 --> 00:19:22.930
That was a puzzler pattern.

00:19:22.930 --> 00:19:25.735
We would just do searches
through the bug database for

00:19:25.735 --> 00:19:28.710
bugs that were closed
as not a bug.

00:19:28.710 --> 00:19:31.830
Because if they were closed as
not a bug, that means, hey,

00:19:31.830 --> 00:19:33.800
their behavior was surprising
enough that people thought

00:19:33.800 --> 00:19:34.440
they were bugs.

00:19:34.440 --> 00:19:37.550
But, in fact, the system was
operating according to spec.

00:19:37.550 --> 00:19:40.560
So that was not a fail safe
prescription, but a reasonable

00:19:40.560 --> 00:19:43.470
prescription for finding
puzzlers.

00:19:43.470 --> 00:19:50.740
And we will do our best to
eliminate puzzlers from Dart.

00:19:50.740 --> 00:19:53.010
Realistically, we
won't succeed.

00:19:53.010 --> 00:19:54.730
And some, you leave
in intentionally.

00:19:57.540 --> 00:20:00.480
Engineering is the art of
managing constraints.

00:20:00.480 --> 00:20:02.040
Everything's over-constrained.

00:20:02.040 --> 00:20:06.310
And often, you have to balance
one bad thing against another

00:20:06.310 --> 00:20:08.130
and decide which is least bad.

00:20:08.130 --> 00:20:11.390
So I'm not going to sit here and
tell you that there will

00:20:11.390 --> 00:20:12.620
be no puzzlers in Dart.

00:20:12.620 --> 00:20:14.440
That's impossible.

00:20:14.440 --> 00:20:16.545
SETH LIND: Well, for those who
want to see what the progress

00:20:16.545 --> 00:20:19.525
is of our exploration of
puzzlers as applied to Dart,

00:20:19.525 --> 00:20:21.120
go to dartlang.org.

00:20:21.120 --> 00:20:24.630
And the first chapter is up
today, and the second one will

00:20:24.630 --> 00:20:26.190
be up later today.

00:20:26.190 --> 00:20:28.110
For everyone that's just joining
us, this is Dartisans,

00:20:28.110 --> 00:20:31.870
episode three, a live broadcast
hang out with the

00:20:31.870 --> 00:20:34.740
Dart team and our special guest,
Josh Bloch, who is

00:20:34.740 --> 00:20:37.230
talking about the Dart
libraries, what he's learned

00:20:37.230 --> 00:20:40.440
through his work on other
libraries [UNINTELLIGIBLE],

00:20:40.440 --> 00:20:42.430
and how that applies to Dart.

00:20:42.430 --> 00:20:44.940
I encourage you to join the hang
out to ask some questions

00:20:44.940 --> 00:20:48.620
in a few minutes, or use our
moderator link to vote up and

00:20:48.620 --> 00:20:50.540
down the questions you'd like to
hear answered a little bit

00:20:50.540 --> 00:20:53.210
later in the show.

00:20:53.210 --> 00:20:55.570
So let's take an example
of a language features

00:20:55.570 --> 00:20:56.920
that came in and--

00:20:56.920 --> 00:20:58.900
again, Dart is very early.

00:20:58.900 --> 00:21:01.280
It's a very technology preview
platform right now.

00:21:01.280 --> 00:21:04.130
Things are still going through
changes as we explore how

00:21:04.130 --> 00:21:06.410
people's apply this and look
back at the lessons we learned

00:21:06.410 --> 00:21:09.560
in other platforms. So one
example I like to talk about--

00:21:09.560 --> 00:21:11.720
and maybe you can pull back the
curtain a little bit for

00:21:11.720 --> 00:21:17.480
us-- is we recently decided to
remove the plus concatenation

00:21:17.480 --> 00:21:19.450
operator from strings.

00:21:19.450 --> 00:21:20.890
This is something that a lot
of the languages do.

00:21:20.890 --> 00:21:23.750
You can concatenate two
strings with plus.

00:21:23.750 --> 00:21:25.490
But we recently decided
to take that out.

00:21:25.490 --> 00:21:27.655
Can you tell us a little bit
about that thought process?

00:21:27.655 --> 00:21:29.410
JOSH BLOCH: Sure.

00:21:29.410 --> 00:21:34.840
So plus was responsible for
a bunch of Java puzzlers.

00:21:34.840 --> 00:21:41.420
For example, if you wrote
system.out.println quote, 2+2=

00:21:41.420 --> 00:21:43.660
end quote, and then 2+2.

00:21:43.660 --> 00:21:46.595
You might expect it to print
2+2=4, but it doesn't.

00:21:46.595 --> 00:21:49.330
It prints out 2+2=22.

00:21:49.330 --> 00:21:50.810
Gee, It's wrong.

00:21:50.810 --> 00:21:52.240
So why does it do that?

00:21:52.240 --> 00:21:55.250
Well, basically because
of the fact that the

00:21:55.250 --> 00:21:57.520
plus operator is--

00:21:57.520 --> 00:21:59.380
I guess it's right
associative.

00:21:59.380 --> 00:22:07.780
So you get the string and
the next operand is 2.

00:22:07.780 --> 00:22:10.030
So right away, you can merge
these things into the string,

00:22:10.030 --> 00:22:12.080
2+2=2 you're going to
repeat the process,

00:22:12.080 --> 00:22:13.470
and it'll be 2+2=22.

00:22:13.470 --> 00:22:15.770
So it violates the principle
of least

00:22:15.770 --> 00:22:17.070
astonishment in that way.

00:22:17.070 --> 00:22:19.360
And it gets worse.

00:22:19.360 --> 00:22:25.590
There are also operator
precedence issues.

00:22:25.590 --> 00:22:29.490
Plus was designed to
be numerical plus.

00:22:29.490 --> 00:22:33.580
But then, it was overloaded
to be concatenation.

00:22:33.580 --> 00:22:35.480
But the precedence relations
were designed

00:22:35.480 --> 00:22:36.430
for numerical plus.

00:22:36.430 --> 00:22:39.420
So the precedence relations
can confuse you.

00:22:39.420 --> 00:22:43.070
And you can end up-- once again,
if you use it in print

00:22:43.070 --> 00:22:46.830
statements, getting what looks
like utter garbage because the

00:22:46.830 --> 00:22:47.350
precedence is wrong.

00:22:47.350 --> 00:22:51.887
If you want details, look at
the second chapter of Java

00:22:51.887 --> 00:22:52.930
Puzzlers-- one of the
two chapters.

00:22:52.930 --> 00:22:54.530
SETH LIND: I think second
is strings, yeah.

00:22:54.530 --> 00:22:55.610
JOSH BLOCH: Yeah, it's probably

00:22:55.610 --> 00:22:56.420
in the second chapter.

00:22:56.420 --> 00:22:57.175
I don't know.

00:22:57.175 --> 00:23:00.890
But anyway, whichever chapter
it's in, you can look at it,

00:23:00.890 --> 00:23:02.330
and you'll find it.

00:23:02.330 --> 00:23:03.080
Look for Animal Farm.

00:23:03.080 --> 00:23:04.820
That's the name of
the puzzler.

00:23:04.820 --> 00:23:08.130
Another thing about the string
concatenation operator is that

00:23:08.130 --> 00:23:12.720
historically it's caused
performance problems because

00:23:12.720 --> 00:23:14.500
we're continuously
concatentating strings.

00:23:14.500 --> 00:23:16.910
For examples, let's
say you wanted to

00:23:16.910 --> 00:23:19.730
do a monthly statement.

00:23:19.730 --> 00:23:21.920
And you did it by repeatedly
using the string concatenation

00:23:21.920 --> 00:23:25.205
operator to concatenate
each transaction.

00:23:25.205 --> 00:23:28.290
Turns out that that's quadratic
in the number of

00:23:28.290 --> 00:23:31.832
strings because you need one
string of length 80, one of

00:23:31.832 --> 00:23:35.600
length 160, one of length
240, and so forth.

00:23:35.600 --> 00:23:38.810
And if you add these together,
you get 80 times 1 plus 2 plus

00:23:38.810 --> 00:23:41.660
3, dot, dot, dot, n, which is
n squared plus n over 2.

00:23:41.660 --> 00:23:43.980
Well, n squared,
quadratic, bad.

00:23:43.980 --> 00:23:47.320
So there are both clarity
problems and performance

00:23:47.320 --> 00:23:48.180
problems with it.

00:23:48.180 --> 00:23:49.840
And Dart has something better.

00:23:49.840 --> 00:23:53.760
Dart already had something
called string interpolation

00:23:53.760 --> 00:23:55.040
during the project.

00:23:55.040 --> 00:23:58.640
And I took one look at it and
said, hey, it's just as easy

00:23:58.640 --> 00:24:01.850
to do your concatenation using
interpolation as it is that

00:24:01.850 --> 00:24:02.630
plus operator.

00:24:02.630 --> 00:24:05.780
But plus operator has proven
itself unworthy in Java.

00:24:05.780 --> 00:24:07.260
We might as well just kill it.

00:24:07.260 --> 00:24:09.290
Killing it, by the way, turns
out to be incredibly easy.

00:24:09.290 --> 00:24:10.580
You don't even have to
change the language.

00:24:10.580 --> 00:24:14.070
You simply have remove the
override of the plus operator

00:24:14.070 --> 00:24:14.590
from string.

00:24:14.590 --> 00:24:17.460
But then, you have to go through
all of the existing

00:24:17.460 --> 00:24:19.260
Dart code at Google--

00:24:19.260 --> 00:24:22.140
there's already a certain
amount of that--

00:24:22.140 --> 00:24:24.620
and remove all uses of plus.

00:24:24.620 --> 00:24:25.150
That's the hard part.

00:24:25.150 --> 00:24:26.540
SETH LIND: Yeah.

00:24:26.540 --> 00:24:29.180
We should also say that-- this
is a good example of getting

00:24:29.180 --> 00:24:31.970
feedback early from these
early design decisions.

00:24:31.970 --> 00:24:34.070
So we said, let's remove the
plus for all the reasons Josh

00:24:34.070 --> 00:24:35.100
just talked about.

00:24:35.100 --> 00:24:37.136
And then, immediately the
feedback came in, well, how do

00:24:37.136 --> 00:24:39.900
I deal with really long
multi-line strings?

00:24:39.900 --> 00:24:43.270
And as you may know, Dart
has the triple quotes

00:24:43.270 --> 00:24:44.670
which allows you to--

00:24:44.670 --> 00:24:48.400
which is pretty nice most cases,
multi-line strings--

00:24:48.400 --> 00:24:51.230
but those are indentation
specific.

00:24:51.230 --> 00:24:51.570
They--

00:24:51.570 --> 00:24:52.370
JOSH BLOCH: Preserve.

00:24:52.370 --> 00:24:53.720
SETH LIND: --preserve
the pre-existing

00:24:53.720 --> 00:24:55.950
white space, exactly.

00:24:55.950 --> 00:24:59.290
So the proposal came in to
basically allow stream

00:24:59.290 --> 00:25:00.426
literals to be
auto-concatenateed?

00:25:00.426 --> 00:25:06.390
JOSH BLOCH: Yes, as they are
in C99, nCC, and C ++.

00:25:06.390 --> 00:25:07.760
And it's a fine proposal.

00:25:07.760 --> 00:25:09.670
Love it.

00:25:09.670 --> 00:25:10.840
So that's what we're
going to do.

00:25:10.840 --> 00:25:11.360
SETH LIND: Great.

00:25:11.360 --> 00:25:12.030
JOSH BLOCH: Yup.

00:25:12.030 --> 00:25:15.430
SETH LIND: So for those of you
just joining us, this is

00:25:15.430 --> 00:25:18.520
Dartisans, episode three, and
we're in a live broadcast hang

00:25:18.520 --> 00:25:21.990
out with Josh Bloch from the
Dart team, talking about Dart

00:25:21.990 --> 00:25:24.350
libraries and what's about
to happen there with the

00:25:24.350 --> 00:25:26.960
libraries, and collections,
APIs, and all the good stuff

00:25:26.960 --> 00:25:29.210
happening in on the
Dart library side.

00:25:29.210 --> 00:25:32.130
We are about to take questions,
so please do vote

00:25:32.130 --> 00:25:34.450
up and down the questions in the
moderate link, which you

00:25:34.450 --> 00:25:37.340
can find in the original
post. And please do

00:25:37.340 --> 00:25:37.880
join the hang out.

00:25:37.880 --> 00:25:39.750
Ask your questions live.

00:25:39.750 --> 00:25:40.910
So let's dive into it.

00:25:40.910 --> 00:25:42.125
One here looks pretty
interesting.

00:25:42.125 --> 00:25:46.317
Lars from Denmark writes, what
plans do you have for modern

00:25:46.317 --> 00:25:50.652
date API, like one
provided in Ruby?

00:25:50.652 --> 00:25:52.820
JOSH BLOCH: Honestly,
I haven't thought

00:25:52.820 --> 00:25:54.590
really hard about it.

00:25:54.590 --> 00:25:59.380
And also, I have not been
involved in relevant efforts

00:25:59.380 --> 00:26:00.895
even in the Java space.

00:26:00.895 --> 00:26:05.400
This is [INAUDIBLE] time
API, and so forth.

00:26:05.400 --> 00:26:08.110
And I'll look at that
eventually.

00:26:08.110 --> 00:26:10.180
But it's not first
on my plate.

00:26:10.180 --> 00:26:11.780
First on my plate is
collections, and then things

00:26:11.780 --> 00:26:14.010
like random number generator.

00:26:14.010 --> 00:26:18.120
The current random number
generator API in Dart was

00:26:18.120 --> 00:26:19.400
clearly just a stand-in.

00:26:19.400 --> 00:26:22.250
All you have is a single
method called random.

00:26:22.250 --> 00:26:26.850
It returns a random number,
and you can't even see it.

00:26:26.850 --> 00:26:29.790
And it turns out that at least
you-- if there are two

00:26:29.790 --> 00:26:30.010
versions running.

00:26:30.010 --> 00:26:33.470
If you're running on top of
JavaScript, it is seeded in

00:26:33.470 --> 00:26:35.080
some reasonable way.

00:26:35.080 --> 00:26:37.240
So you don't always get
the same answers.

00:26:37.240 --> 00:26:42.080
But if you're running in the
VM, you can write a program

00:26:42.080 --> 00:26:46.460
that flips a coin, and it'll
always print heads.

00:26:46.460 --> 00:26:51.380
So basically, I'm going to deal
with these things first.

00:26:51.380 --> 00:26:56.110
But yes, date and time are
certainly also in the queue.

00:26:56.110 --> 00:26:57.970
SETH LIND: Mm-hm, OK.

00:26:57.970 --> 00:27:00.556
And can we take questions
from the hang out?

00:27:00.556 --> 00:27:02.350
Anyone, if you have a question
for the hang out, please

00:27:02.350 --> 00:27:03.690
un-mute and go ahead and ask.

00:27:10.370 --> 00:27:13.600
AUDIENCE: OK, I'll ask.

00:27:13.600 --> 00:27:18.630
A difference between a library
and a framework for you?

00:27:18.630 --> 00:27:25.420
JOSH BLOCH: Honestly, for me,
I would say a library is a

00:27:25.420 --> 00:27:28.140
subclass of frameworks.

00:27:28.140 --> 00:27:30.360
Nah, I wouldn't even say that.

00:27:30.360 --> 00:27:32.000
Some libraries are frameworks.

00:27:32.000 --> 00:27:35.420
I call the collections a
framework because it's a

00:27:35.420 --> 00:27:37.880
broad, extensible library.

00:27:37.880 --> 00:27:39.817
It's a library with some
significant architecture to

00:27:39.817 --> 00:27:42.080
it, as opposed to, let's
say, Java.math,

00:27:42.080 --> 00:27:42.840
which is not a framework.

00:27:42.840 --> 00:27:45.820
It's just a couple classes,
one to do multi-precision

00:27:45.820 --> 00:27:50.310
integer arithmetic, and one to
do multi-precision scale

00:27:50.310 --> 00:27:52.520
decimal arithmetic, and
eventually floating decimal

00:27:52.520 --> 00:27:53.120
arithmetic.

00:27:53.120 --> 00:27:57.530
So I think it's more a
question of scope.

00:27:57.530 --> 00:28:00.355
However, frameworks can go
beyond libraries if you get

00:28:00.355 --> 00:28:01.440
something like Juice
or something.

00:28:01.440 --> 00:28:03.080
It isn't just a library.

00:28:03.080 --> 00:28:05.490
It's also a collection
of tools.

00:28:05.490 --> 00:28:10.200
And traditionally, I guess
framework was used for GUI

00:28:10.200 --> 00:28:12.290
application construction
frameworks.

00:28:12.290 --> 00:28:16.640
So I would say there's an
intersection relationship.

00:28:16.640 --> 00:28:19.070
There are libraries which are
frameworks, but there are

00:28:19.070 --> 00:28:20.785
frameworks that aren't libraries
and libraries which

00:28:20.785 --> 00:28:22.610
aren't frameworks.

00:28:22.610 --> 00:28:23.870
All four possibilities.

00:28:23.870 --> 00:28:25.652
SETH LIND: Excellent question.

00:28:25.652 --> 00:28:27.200
We'll go back to the
moderator here.

00:28:27.200 --> 00:28:29.210
There's a lot about the
Dart collection--

00:28:29.210 --> 00:28:29.480
oh, sorry?

00:28:29.480 --> 00:28:30.160
JOSH BLOCH: No.

00:28:30.160 --> 00:28:32.780
SETH LIND: OK-- a lot about
the Dart collection.

00:28:32.780 --> 00:28:35.770
We talked a little bit about
that in the beginning.

00:28:35.770 --> 00:28:38.850
But maybe we can think of one
upcoming change you might add,

00:28:38.850 --> 00:28:40.550
and I think that will answer
a lot of these questions.

00:28:40.550 --> 00:28:44.150
I think people are really
curious what's maybe the first

00:28:44.150 --> 00:28:45.140
thing you might do with
Dart collections.

00:28:45.140 --> 00:28:51.040
JOSH BLOCH: So the first thing
I want to do is I want to

00:28:51.040 --> 00:28:54.980
carefully look at the interfaces
and re-factor them

00:28:54.980 --> 00:28:57.160
in some principled fashion.

00:28:57.160 --> 00:28:59.805
Right now, to give you an
example of a place where I got

00:28:59.805 --> 00:29:03.410
burnt recently, one of the
things that I did the other

00:29:03.410 --> 00:29:06.110
day-- and Seth, thank you,
logged it for me--

00:29:06.110 --> 00:29:08.665
I was--

00:29:08.665 --> 00:29:10.460
as you'll see if you look
at the Puzzler chapter--

00:29:10.460 --> 00:29:12.776
I was a little frustrated to
find out when I printed out a

00:29:12.776 --> 00:29:16.050
list in Dart, it didn't print
the contents of this.

00:29:16.050 --> 00:29:18.740
I said, well, when you print
any kind of collection-- a

00:29:18.740 --> 00:29:20.880
list, a map-- it should
print the contents.

00:29:20.880 --> 00:29:24.460
And moreover, it should be able
to deal with things like

00:29:24.460 --> 00:29:25.365
circularities.

00:29:25.365 --> 00:29:27.000
It'll just print out
dot, dot, dot.

00:29:27.000 --> 00:29:28.430
So I did this.

00:29:28.430 --> 00:29:31.580
And in order to test it, I
wrote a [UNINTELLIGIBLE]

00:29:31.580 --> 00:29:34.200
framework where you pass
arbitrary collections in and

00:29:34.200 --> 00:29:36.530
populated them.

00:29:36.530 --> 00:29:39.485
And, of course, I used the
interface collection loop, as

00:29:39.485 --> 00:29:42.600
in collection, and
it adds elements.

00:29:42.600 --> 00:29:45.735
I was surprised to find out
that the Dart collection

00:29:45.735 --> 00:29:48.440
interface doesn't have
an add method.

00:29:48.440 --> 00:29:52.960
List, set, and key, they
all have add methods.

00:29:52.960 --> 00:29:55.500
But there is no super
interface.

00:29:55.500 --> 00:30:01.170
There is no single pipe that
is responsible for this

00:30:01.170 --> 00:30:01.340
commonalities.

00:30:01.340 --> 00:30:04.370
This is what I call a gained
orthogonal attribute, which is

00:30:04.370 --> 00:30:09.840
a bad smell in API design where
basically the top-level

00:30:09.840 --> 00:30:12.128
framework is--

00:30:12.128 --> 00:30:13.850
maybe you could put
[INAUDIBLE].

00:30:13.850 --> 00:30:15.400
It may not have mutation
operator.

00:30:15.400 --> 00:30:16.150
It certainly doesn't have add.

00:30:16.150 --> 00:30:17.075
It may have remove.

00:30:17.075 --> 00:30:18.030
I forget.

00:30:18.030 --> 00:30:21.990
But anyway, this filtering
collection--

00:30:21.990 --> 00:30:22.320
SETH LIND: Filter as in?

00:30:22.320 --> 00:30:23.875
JOSH BLOCH: So it's
very strange.

00:30:23.875 --> 00:30:25.720
It's mutable, but it
doesn't have add.

00:30:25.720 --> 00:30:30.430
To me, it's clear that no one
had the time to just sit down

00:30:30.430 --> 00:30:31.850
and think this thing through.

00:30:31.850 --> 00:30:34.890
So honestly, I'm going to sit
down, think it through, and

00:30:34.890 --> 00:30:38.140
re-factor the whole thing.

00:30:38.140 --> 00:30:40.410
I hope that we end up
with something--

00:30:40.410 --> 00:30:43.920
there's something which I did
in Java which was considered

00:30:43.920 --> 00:30:45.275
sacrilege at the time.

00:30:45.275 --> 00:30:49.040
And that was to add this
[UNINTELLIGIBLE] operation

00:30:49.040 --> 00:30:52.640
exception where instead of
having a different variety of

00:30:52.640 --> 00:30:54.780
collection, different interface
for every different

00:30:54.780 --> 00:30:57.020
set of operations you might
have, whether it's an

00:30:57.020 --> 00:30:59.715
append-only list, or a list that
you can remove from and

00:30:59.715 --> 00:31:02.450
not add to, all I had was
list. It's a list.

00:31:02.450 --> 00:31:04.462
But if you can't support some
operation, you throw an

00:31:04.462 --> 00:31:06.060
unsupported operation
exception.

00:31:06.060 --> 00:31:08.200
In a strongly typed language
like Java that was

00:31:08.200 --> 00:31:09.690
considered--

00:31:09.690 --> 00:31:10.530
early on, anyway--

00:31:10.530 --> 00:31:11.410
to be sacrilege.

00:31:11.410 --> 00:31:13.330
However, I think that was
a very good decision.

00:31:13.330 --> 00:31:16.826
And I think that it proved
itself over the years as being

00:31:16.826 --> 00:31:17.970
a great way to go.

00:31:17.970 --> 00:31:21.900
And to me, it's a no-brainer
in a language like Dart

00:31:21.900 --> 00:31:25.985
because Dart is dynamically
typed anyway.

00:31:25.985 --> 00:31:29.500
At run time, you pass the
message to the object.

00:31:29.500 --> 00:31:31.200
And if it knows how to
deal with it, great.

00:31:31.200 --> 00:31:32.525
And if not, it throws
an exception.

00:31:32.525 --> 00:31:35.320
And given, that's the way
the type system works.

00:31:35.320 --> 00:31:36.550
It's a no-brainer that's
the way the

00:31:36.550 --> 00:31:37.655
collections framework should--

00:31:37.655 --> 00:31:39.430
SETH LIND: But when you're
in that editor and code

00:31:39.430 --> 00:31:41.880
completion is so key and one
of the main selling points

00:31:41.880 --> 00:31:43.200
about this.

00:31:43.200 --> 00:31:46.210
For instance, you might do
Command-Space and see the

00:31:46.210 --> 00:31:47.050
methods you can call.

00:31:47.050 --> 00:31:49.006
One of them or many
of them may not be

00:31:49.006 --> 00:31:50.120
able to actually run.

00:31:50.120 --> 00:31:52.240
Is there something we
can do to indicate?

00:31:52.240 --> 00:31:54.880
That's the only thing that
always trips me up, is you

00:31:54.880 --> 00:31:56.610
think that you can call
all these things.

00:31:56.610 --> 00:31:57.940
But some of them are going
to throw back exceptions.

00:31:57.940 --> 00:31:59.970
JOSH BLOCH: It's a good
question, a very good

00:31:59.970 --> 00:32:01.440
question, actually.

00:32:01.440 --> 00:32:05.870
And the problem is--

00:32:05.870 --> 00:32:10.070
one thing you can do is you can
take a very rough cut at

00:32:10.070 --> 00:32:11.520
the distinction.

00:32:11.520 --> 00:32:15.930
I believe that in the--

00:32:15.930 --> 00:32:18.340
the next step APIs did this--

00:32:18.340 --> 00:32:21.310
where you had mutable and
immutable collections, and

00:32:21.310 --> 00:32:22.980
that was the rough cut
that they took.

00:32:22.980 --> 00:32:25.040
Even that one turns out to be a
little bit expensive because

00:32:25.040 --> 00:32:28.325
all of these axillary classes,
like iterators and so forth,

00:32:28.325 --> 00:32:32.230
need both mutable and
immutable version.

00:32:32.230 --> 00:32:35.200
But at any rate, that's
one thing we could do.

00:32:35.200 --> 00:32:39.330
The other thing is when you're
programming, I would say you

00:32:39.330 --> 00:32:43.022
generally know if a collection
is mutable or immutable, and

00:32:43.022 --> 00:32:48.570
you're probably unlikely to
call an add method on a

00:32:48.570 --> 00:32:51.850
collection where it's
going to fail.

00:32:51.850 --> 00:32:52.970
In truth, I've done it.

00:32:52.970 --> 00:32:54.050
And I'll tell you where.

00:32:54.050 --> 00:32:56.770
It isn't even mutable
versus immutable.

00:32:56.770 --> 00:32:59.473
You're passing around
something that is

00:32:59.473 --> 00:33:00.980
in essence an array.

00:33:00.980 --> 00:33:03.340
That is a list whose size
cannot be changed.

00:33:03.340 --> 00:33:05.890
You delete something from it
or you add something to it,

00:33:05.890 --> 00:33:08.285
forgetting that all you can
do is change values.

00:33:08.285 --> 00:33:09.775
And it blows up at run
time, and that can

00:33:09.775 --> 00:33:12.140
happen even in Java.

00:33:12.140 --> 00:33:14.110
So I'm not sure.

00:33:14.110 --> 00:33:16.880
Once again, we're talking about
engineering compromises.

00:33:16.880 --> 00:33:22.490
I think this may be a place
where the best we can do is to

00:33:22.490 --> 00:33:23.680
have the tools be
really smart.

00:33:23.680 --> 00:33:25.460
And maybe the tools
can know more than

00:33:25.460 --> 00:33:26.566
the type system does.

00:33:26.566 --> 00:33:27.830
SETH LIND: Yeah, that'd
be interesting.

00:33:27.830 --> 00:33:28.780
And I can think of--

00:33:28.780 --> 00:33:29.640
because this is a bit new.

00:33:29.640 --> 00:33:33.070
When you first ran into Dart's
fixed-sized list, where you

00:33:33.070 --> 00:33:35.985
might generate a method whose
signature takes a list. But

00:33:35.985 --> 00:33:38.515
there's no way to convey to the
consumers of that method

00:33:38.515 --> 00:33:40.400
that hey, by the way, I'm going
to add stuff to this.

00:33:40.400 --> 00:33:42.120
And so I created a
fixed-length--

00:33:42.120 --> 00:33:43.863
again, not really knowing what
happens when I say list

00:33:43.863 --> 00:33:46.870
parenthesis three, but
we'll fix that--

00:33:46.870 --> 00:33:49.260
and then I pass it in to my
other method, and later, that

00:33:49.260 --> 00:33:49.850
added stuff.

00:33:49.850 --> 00:33:51.570
But that's not apparent
because that's an

00:33:51.570 --> 00:33:53.820
implementation detail
of the algorithm.

00:33:53.820 --> 00:33:57.020
But I couldn't express that
I want a mutable list.

00:33:57.020 --> 00:33:58.410
[INTERPOSING VOICES]

00:33:58.410 --> 00:33:59.380
JOSH BLOCH: It's funny,
by the way.

00:33:59.380 --> 00:34:04.380
Dart does something which I
initially found shocking, but

00:34:04.380 --> 00:34:08.980
not in a way that breaks your
programs. If you make a list

00:34:08.980 --> 00:34:13.032
literal, open bracket, 1, 2,
3, close bracket, that's a

00:34:13.032 --> 00:34:16.252
mutable list. And everyone
guessed it.

00:34:16.252 --> 00:34:20.650
SETH LIND: Unless it's in a
construct which becomes

00:34:20.650 --> 00:34:24.659
[UNINTELLIGIBLE] when you have
the default values and not the

00:34:24.659 --> 00:34:25.909
parameters.

00:34:27.400 --> 00:34:30.270
So Frank from New York writes,
what's the plans for

00:34:30.270 --> 00:34:33.405
concurrency libraries in the
context of the JavaScript Ish

00:34:33.405 --> 00:34:34.719
VM on the client.

00:34:34.719 --> 00:34:37.280
I think he means the
Dart VM here.

00:34:37.280 --> 00:34:39.860
And possible JVM implementation
on the server

00:34:39.860 --> 00:34:40.920
both running Dart.

00:34:40.920 --> 00:34:43.830
So I think swap JavaScript and
Java with Dart, and I think

00:34:43.830 --> 00:34:46.260
what he's really asking is
concurrency libraries for the

00:34:46.260 --> 00:34:49.260
Dart VM, and is there going
to be a server side

00:34:49.260 --> 00:34:50.490
implementation of Dart VM?

00:34:50.490 --> 00:34:52.905
And sorry, Frank, if I didn't
get that question right.

00:34:52.905 --> 00:34:54.980
JOSH BLOCH: Yeah, so it's
got two questions.

00:34:54.980 --> 00:34:58.520
One is concurrency, and the
answer is very, very different

00:34:58.520 --> 00:34:59.490
from what we're used to.

00:34:59.490 --> 00:35:02.200
This is a fundamental design
decision that had been long

00:35:02.200 --> 00:35:04.190
before I got on board.

00:35:04.190 --> 00:35:08.990
Dart does not have shared memory
multi-processing a la

00:35:08.990 --> 00:35:11.620
Java, C, C ++.

00:35:11.620 --> 00:35:13.930
Instead, it has isolates.

00:35:13.930 --> 00:35:17.655
So in a sense, it's more like
Erlang, let's say, where all

00:35:17.655 --> 00:35:20.955
you can do, you have these very
light-weight things that

00:35:20.955 --> 00:35:23.290
are halfway between threads
and processes.

00:35:23.290 --> 00:35:25.600
And you have to communicate
explicitly

00:35:25.600 --> 00:35:26.640
between these isolates.

00:35:26.640 --> 00:35:30.427
You do not actually share
objects in memory, which frees

00:35:30.427 --> 00:35:35.360
you from all the locking
and that sort of stuff.

00:35:35.360 --> 00:35:38.875
It also places limits on the
performance that you're going

00:35:38.875 --> 00:35:40.840
to get out of the thing
eventually.

00:35:40.840 --> 00:35:41.420
[INAUDIBLE]

00:35:41.420 --> 00:35:43.800
that Dart is unlikely to ever
become a system programming

00:35:43.800 --> 00:35:46.810
language, let us say.

00:35:46.810 --> 00:35:52.180
But that's the general feel of
the concurrency libraries.

00:35:52.180 --> 00:35:53.120
I haven't read them yet.

00:35:53.120 --> 00:35:54.355
I don't know about them yet.

00:35:54.355 --> 00:35:55.630
I'm going to be doing that.

00:35:55.630 --> 00:35:58.075
But those isolate libraries are
out there on the web, and

00:35:58.075 --> 00:36:00.790
you can look at them.

00:36:00.790 --> 00:36:03.770
And then, the question about
VMs is almost, I think, an

00:36:03.770 --> 00:36:04.840
orthogonal question.

00:36:04.840 --> 00:36:08.780
And I don't know what has and
hasn't been announced.

00:36:08.780 --> 00:36:11.980
But there is a Dart VM.

00:36:11.980 --> 00:36:14.883
There's this Dartium
preview where you--

00:36:14.883 --> 00:36:15.870
SETH LIND: That's right.

00:36:15.870 --> 00:36:18.000
And the Dart VM runs
on the command line

00:36:18.000 --> 00:36:19.380
like any other program.

00:36:19.380 --> 00:36:23.070
And we have included the I/O
libraries in the SDK.

00:36:23.070 --> 00:36:25.450
And so you can run Dart programs
on the server.

00:36:25.450 --> 00:36:28.500
And in fact, you can open up
files, read directories,

00:36:28.500 --> 00:36:30.960
actually open up sockets,
respond to sockets.

00:36:30.960 --> 00:36:33.147
And the HTTP libraries
themselves are

00:36:33.147 --> 00:36:34.620
now landing as well.

00:36:34.620 --> 00:36:37.510
And so yes, we have this vision
of end-to-end Dart

00:36:37.510 --> 00:36:39.870
running on the server
and the client.

00:36:39.870 --> 00:36:42.275
And I think as the JavaScript
community knows very well,

00:36:42.275 --> 00:36:44.780
with no JS a lot of interesting
things begin to

00:36:44.780 --> 00:36:47.410
open up when you have-- you can
co-chair between these two

00:36:47.410 --> 00:36:47.700
environments.

00:36:47.700 --> 00:36:49.900
And that's a vision we totally
get for Dart as well.

00:36:49.900 --> 00:36:51.800
And nothing we're doing, I
think, in the language or

00:36:51.800 --> 00:36:54.570
library paints us in any kind of
corner that, oh, this only

00:36:54.570 --> 00:36:56.470
running on the clients
by any means.

00:36:56.470 --> 00:36:58.870
I think this is a more general
purpose language where the

00:36:58.870 --> 00:37:01.080
virtual machine can be deployed
on server and client.

00:37:01.080 --> 00:37:03.630
JOSH BLOCH: Yeah, and you've
got certain libraries that

00:37:03.630 --> 00:37:06.100
you'll use on one side
or the other.

00:37:06.100 --> 00:37:08.680
If you have a library that's
all about the browser

00:37:08.680 --> 00:37:11.055
[? welts, ?] it's probably
running on the client side.

00:37:11.055 --> 00:37:13.280
And if you have one that is
accessing the file system

00:37:13.280 --> 00:37:15.600
directly, it's more likely to be
running on the server side.

00:37:15.600 --> 00:37:17.360
SETH LIND: Bingo.

00:37:17.360 --> 00:37:19.650
And we talked briefly
about isolates which

00:37:19.650 --> 00:37:22.400
is the memory model.

00:37:22.400 --> 00:37:26.040
Isolated memory also leads
you to concurrency.

00:37:26.040 --> 00:37:28.910
But that leads me to a next
question that Paul from Zurich

00:37:28.910 --> 00:37:29.950
actually writes.

00:37:29.950 --> 00:37:31.810
And this is something
I took away from

00:37:31.810 --> 00:37:33.090
Effective Java very well.

00:37:33.090 --> 00:37:35.550
It's a message that I
got loud and clear.

00:37:35.550 --> 00:37:38.620
Paul writes, immutable data
structures tend to facilitate

00:37:38.620 --> 00:37:40.980
parallel programming, concurrent
programming, and

00:37:40.980 --> 00:37:43.620
more generally, reasoning
about programs. Are you

00:37:43.620 --> 00:37:45.990
planning on giving immutability
a prominent place

00:37:45.990 --> 00:37:46.933
in the library design?

00:37:46.933 --> 00:37:48.630
JOSH BLOCH: Interesting
question.

00:37:48.630 --> 00:37:52.520
Yes, but realistically, it's not
actually as important in a

00:37:52.520 --> 00:37:54.100
language that doesn't support
shared memory

00:37:54.100 --> 00:37:55.530
multi-processing.

00:37:55.530 --> 00:37:57.060
One of the things about
immutability--

00:37:57.060 --> 00:37:59.060
one of those things I say
in Effective Java--

00:37:59.060 --> 00:38:03.825
is what hurts you, obviously,
is shared, mutable data

00:38:03.825 --> 00:38:04.520
structures.

00:38:04.520 --> 00:38:08.350
Because if they're not shared
or mutable, you're OK.

00:38:08.350 --> 00:38:10.420
Well, in Dart, it's
not shared.

00:38:10.420 --> 00:38:13.260
There simple is no way to share
a data structure among

00:38:13.260 --> 00:38:16.200
threads because the language
doesn't support threads.

00:38:16.200 --> 00:38:20.570
So in that sense, mutability is
less important in Dart than

00:38:20.570 --> 00:38:24.460
it was in Java, or in
C, C++, whatever.

00:38:24.460 --> 00:38:29.450
That said, I think many people
in this project have a long

00:38:29.450 --> 00:38:33.190
history in the functional
programming community.

00:38:33.190 --> 00:38:39.320
And they understand how much
easier it is to reason about

00:38:39.320 --> 00:38:41.690
immutable data structures.

00:38:41.690 --> 00:38:46.435
And many of the core data
structures in Dart, like for

00:38:46.435 --> 00:38:48.430
example strings,
are immutable.

00:38:48.430 --> 00:38:49.210
It's funny.

00:38:49.210 --> 00:38:53.855
If you've only been in this
business for a mere 15 years,

00:38:53.855 --> 00:38:56.220
you might say, well, of course
strings are immutable.

00:38:56.220 --> 00:38:59.880
But that was a new thing back 15
years ago if you look back

00:38:59.880 --> 00:39:03.330
to the C and C++ days,
FORTRAN, whatever.

00:39:03.330 --> 00:39:05.855
Everything was mutable,
including strings.

00:39:05.855 --> 00:39:07.940
SETH LIND: One thing that I
started doing after Effective

00:39:07.940 --> 00:39:13.220
Java was make dates immutable,
either creating a copy of it

00:39:13.220 --> 00:39:15.210
before I pass it in, or
as soon as I get,

00:39:15.210 --> 00:39:16.230
make a copy of it.

00:39:16.230 --> 00:39:19.330
And it really did affect the way
I wanted to pass data not

00:39:19.330 --> 00:39:22.290
just between my threads or
[UNINTELLIGIBLE], but really

00:39:22.290 --> 00:39:23.660
between my functions.

00:39:23.660 --> 00:39:25.530
And I think that's
what he's also--

00:39:25.530 --> 00:39:26.450
JOSH BLOCH: Right, this is like

00:39:26.450 --> 00:39:27.415
ownership types basically.

00:39:27.415 --> 00:39:28.150
SETH LIND: Exactly.

00:39:28.150 --> 00:39:28.610
JOSH BLOCH: Yeah.

00:39:28.610 --> 00:39:32.440
The idea is that if you pass a
mutable object to a function

00:39:32.440 --> 00:39:34.920
and the function may destroy
it, you have to be very

00:39:34.920 --> 00:39:37.780
careful about saying, hey,
this is yours now.

00:39:37.780 --> 00:39:40.640
It's no longer mine, and you can
do what you want with it.

00:39:40.640 --> 00:39:44.155
So sometimes immutable, not only
can you share it among

00:39:44.155 --> 00:39:47.490
multiple threads, but you can
share it among multiple

00:39:47.490 --> 00:39:50.650
independent libraries that
happen to have a reference to

00:39:50.650 --> 00:39:53.590
the same object without worrying
about who's going to

00:39:53.590 --> 00:39:54.440
do what to it.

00:39:54.440 --> 00:39:59.908
So yeah, I stand by my claim
that it's more important in a

00:39:59.908 --> 00:40:03.810
system with shared memory
multi-processing than without.

00:40:03.810 --> 00:40:05.375
But that said, it's
still great.

00:40:05.375 --> 00:40:06.350
We believe in it.

00:40:06.350 --> 00:40:09.296
And in fact, already in the
short time that I've been in

00:40:09.296 --> 00:40:11.750
this [UNINTELLIGIBLE], I've seen
things that were mutable

00:40:11.750 --> 00:40:13.430
be made immutable.

00:40:13.430 --> 00:40:15.480
I believe one of the times
zones, or dates, or something

00:40:15.480 --> 00:40:17.750
like that was made immutable
fairly recently.

00:40:17.750 --> 00:40:22.550
And I strongly believe that
small value objects should

00:40:22.550 --> 00:40:24.190
always be immutable.

00:40:24.190 --> 00:40:25.240
It was certainly a gaffe.

00:40:25.240 --> 00:40:34.020
We had a big design gaffe in
Java that dates were mutable.

00:40:34.020 --> 00:40:36.765
And I don't think we'll be
making those mistakes again.

00:40:36.765 --> 00:40:38.342
SETH LIND: OK, that's good.

00:40:38.342 --> 00:40:40.647
Good to hear it.

00:40:40.647 --> 00:40:44.210
MALE SPEAKER: This is
actual stuff code.

00:40:44.210 --> 00:40:45.170
JOSH BLOCH: Sorry.

00:40:45.170 --> 00:40:45.910
[INAUDIBLE]

00:40:45.910 --> 00:40:46.357
plugged in.

00:40:46.357 --> 00:40:47.698
MALE SPEAKER: I'll
plug it in after.

00:40:47.698 --> 00:40:49.486
JOSH BLOCH: OK.

00:40:49.486 --> 00:40:50.900
SETH LIND: So for everyone
just joining

00:40:50.900 --> 00:40:51.790
us, sorry about that.

00:40:51.790 --> 00:40:55.560
This is Dartisan, episode three,
a live broadcast hang

00:40:55.560 --> 00:40:58.240
out with the Dart team and Josh
Bloch, our special guest.

00:40:58.240 --> 00:40:59.915
JOSH BLOCH: Excuse me, I think
they deserve to know what that

00:40:59.915 --> 00:41:00.110
was all about.

00:41:00.110 --> 00:41:00.830
SETH LIND: Oh, OK.

00:41:00.830 --> 00:41:01.475
Sure, yeah.

00:41:01.475 --> 00:41:06.040
So we are in a small side room
here at the Googleplex which

00:41:06.040 --> 00:41:08.330
we use for very more important
things such

00:41:08.330 --> 00:41:11.270
as cooling the kegerator.

00:41:11.270 --> 00:41:13.410
So they were concerned that the
kegerator was unplugged,

00:41:13.410 --> 00:41:15.560
which I assure everyone we
will plug in immediately.

00:41:15.560 --> 00:41:17.580
JOSH BLOCH: Yes, as soon
as this is over.

00:41:17.580 --> 00:41:18.675
But if it were on
now, it would be

00:41:18.675 --> 00:41:19.220
making horrible noises.

00:41:19.220 --> 00:41:20.080
SETH LIND: Yes, thank you.

00:41:20.080 --> 00:41:20.960
JOSH BLOCH: There you go.

00:41:20.960 --> 00:41:22.800
SETH LIND: Good point.

00:41:22.800 --> 00:41:27.400
If you're on the hang out,
please do ask questions and

00:41:27.400 --> 00:41:28.490
let us know what you're
thinking.

00:41:28.490 --> 00:41:31.240
Let's go back to the questions
in the moderator.

00:41:37.488 --> 00:41:38.470
That's a good one.

00:41:38.470 --> 00:41:39.720
We're going to--

00:41:43.390 --> 00:41:50.190
well, let's go back to that
scalable programming language.

00:41:50.190 --> 00:41:51.010
I've seen a question.

00:41:51.010 --> 00:41:54.055
We talked about it earlier in
the broadcast. We always talk

00:41:54.055 --> 00:41:55.940
about Dart as being
very scalable.

00:41:55.940 --> 00:41:57.420
Can you elaborate a little
bit more on what

00:41:57.420 --> 00:42:00.325
scalable means to you?

00:42:00.325 --> 00:42:02.490
JOSH BLOCH: I use the word
to mean different things

00:42:02.490 --> 00:42:04.330
depending on what I'm
talking about.

00:42:04.330 --> 00:42:08.080
But in this instance, I guess
what we mean is that it's an

00:42:08.080 --> 00:42:13.190
appropriate language for dashing
out quickly small

00:42:13.190 --> 00:42:16.630
prototypes running in
your web browser.

00:42:16.630 --> 00:42:20.170
But it is not limited to that.

00:42:20.170 --> 00:42:23.590
I think one of the reasons the
project was undertaken was

00:42:23.590 --> 00:42:30.610
that as web apps grew more
complex, JavaScript's

00:42:30.610 --> 00:42:35.330
limitations in scaling
started to show.

00:42:35.330 --> 00:42:39.170
And so we're trying to get
various things right with Dart

00:42:39.170 --> 00:42:45.370
in terms of multiple name
spaces, and libraries, and so

00:42:45.370 --> 00:42:50.440
forth which were not built into
JavaScript from day one

00:42:50.440 --> 00:42:55.330
and are still being added
15 years later.

00:42:55.330 --> 00:42:58.750
So I guess that's what I
mean by scalable here.

00:42:58.750 --> 00:43:00.600
SETH LIND: I saw a great
question in the moderator.

00:43:00.600 --> 00:43:01.630
And I hope I pronounce
the name.

00:43:01.630 --> 00:43:04.580
Ladislav asks, what is
the general approach

00:43:04.580 --> 00:43:05.650
for Dart core libraries?

00:43:05.650 --> 00:43:07.850
And I know this is something
we talked about.

00:43:07.850 --> 00:43:12.320
So he goes on to say, number
one, a lot of rather small

00:43:12.320 --> 00:43:15.435
libraries versus a handful
of larger libraries?

00:43:15.435 --> 00:43:18.290
Or just the core stuff versus
everything included?

00:43:18.290 --> 00:43:23.120
I think he's trying to get a
handle on, are we going to

00:43:23.120 --> 00:43:26.380
create lots of little libraries
like Dart core, and

00:43:26.380 --> 00:43:31.080
Dart JSON, and Dart isolate, or
do you see all this rolling

00:43:31.080 --> 00:43:32.150
up under one library.

00:43:32.150 --> 00:43:34.340
Where do you define
the line there?

00:43:34.340 --> 00:43:39.460
JOSH BLOCH: Yeah, I think that
you want to produce things

00:43:39.460 --> 00:43:43.180
that are largely independent
of one another so you can

00:43:43.180 --> 00:43:44.470
learn them nicely.

00:43:44.470 --> 00:43:48.510
They aren't too big to learn
reasonably quickly.

00:43:48.510 --> 00:43:51.020
So we're talking about
API design and

00:43:51.020 --> 00:43:53.190
conceptual surface area.

00:43:53.190 --> 00:43:54.990
And that's what we want to do.

00:43:54.990 --> 00:43:58.850
Realistically, the early
Dart library

00:43:58.850 --> 00:44:01.860
development has been organic.

00:44:01.860 --> 00:44:06.070
So you won't see that sort
of consistency there yet.

00:44:06.070 --> 00:44:09.860
But I think that's what
we're moving towards.

00:44:09.860 --> 00:44:13.245
I think that Dart core is going
to be roughly speaking

00:44:13.245 --> 00:44:17.010
the equivalent of Java
lang, but with some

00:44:17.010 --> 00:44:19.150
things that were mistakes.

00:44:19.150 --> 00:44:23.100
I think the fact that
collections were added to Java

00:44:23.100 --> 00:44:27.320
late and were part of util
rather than lang's probably

00:44:27.320 --> 00:44:28.940
not a good thing.

00:44:28.940 --> 00:44:31.600
So the collections are in Dart
core, which is I think where

00:44:31.600 --> 00:44:33.450
they should be.

00:44:33.450 --> 00:44:37.730
That said, I think that things
aren't terribly-- you don't

00:44:37.730 --> 00:44:39.960
want libraries to be
dumping grounds.

00:44:39.960 --> 00:44:42.830
And in fact, if you look at core
[UNINTELLIGIBLE] now, it

00:44:42.830 --> 00:44:44.060
feels a little bit like
a dumping ground.

00:44:44.060 --> 00:44:46.185
Then, on another kind
of scale, you want

00:44:46.185 --> 00:44:47.800
this growth over time.

00:44:47.800 --> 00:44:50.320
I've seen what happened
to the Java libraries.

00:44:50.320 --> 00:44:53.160
It's actually shocking to look
at how they grew from release,

00:44:53.160 --> 00:44:54.440
to release, to release.

00:44:54.440 --> 00:45:00.290
And you want to make sure to
establish a framework that

00:45:00.290 --> 00:45:05.250
will grow with time and not end
up keeling over under its

00:45:05.250 --> 00:45:06.350
own weight.

00:45:06.350 --> 00:45:10.050
So I think that's an important
thing for us to do early on,

00:45:10.050 --> 00:45:15.050
is to break things up in ways
you do not end up adding so

00:45:15.050 --> 00:45:16.660
many things to an individual
library

00:45:16.660 --> 00:45:18.590
that it becomes unusable.

00:45:18.590 --> 00:45:20.480
It's particularly important--

00:45:20.480 --> 00:45:22.920
Dart has an interesting feature
called top-level

00:45:22.920 --> 00:45:27.600
functions where you can put
functions in Dart files.

00:45:27.600 --> 00:45:30.695
And they're usable without
pre-pending

00:45:30.695 --> 00:45:31.700
them with any class.

00:45:31.700 --> 00:45:33.370
They're not part of any class.

00:45:33.370 --> 00:45:36.080
And all of the functions
in a given library

00:45:36.080 --> 00:45:38.560
share a name space.

00:45:38.560 --> 00:45:41.210
I'm not even sure that
libraries should have

00:45:41.210 --> 00:45:43.960
top-level functions in
them because of that.

00:45:43.960 --> 00:45:46.880
I think that name space is
likely to get very crowded

00:45:46.880 --> 00:45:47.870
very quickly.

00:45:47.870 --> 00:45:49.850
But I'm still learning
my way around the

00:45:49.850 --> 00:45:51.810
language, so I have to--

00:45:51.810 --> 00:45:53.510
that's a weak [UNINTELLIGIBLE].

00:45:53.510 --> 00:45:55.802
I think I believe,
but I'm not sure.

00:45:55.802 --> 00:45:57.340
SETH LIND: So we're about--
we're going to

00:45:57.340 --> 00:45:58.100
wrap up pretty soon.

00:45:58.100 --> 00:46:00.480
We'll get another good
question in here.

00:46:00.480 --> 00:46:03.590
And we talked about isolates
before, which is the memory

00:46:03.590 --> 00:46:05.880
isolation model, least
[UNINTELLIGIBLE] currency.

00:46:05.880 --> 00:46:10.140
And so Dart ships with this
native support for isolates.

00:46:10.140 --> 00:46:13.250
And Adam from San Francisco
would like to know, do you see

00:46:13.250 --> 00:46:15.450
any possible roles that isolates
play in the design

00:46:15.450 --> 00:46:17.260
and implementation of
the Dart libraries?

00:46:17.260 --> 00:46:20.141
JOSH BLOCH: Yeah, absolutely.

00:46:20.141 --> 00:46:26.380
The idea is that we have
multi-processors around

00:46:26.380 --> 00:46:30.492
everywhere, and you want to be
able to make use of them.

00:46:30.492 --> 00:46:33.310
And that's the only
way to do it.

00:46:33.310 --> 00:46:37.580
So I definitely think
that the libraries--

00:46:37.580 --> 00:46:44.250
in much the same way that
java.util.concurrent provides

00:46:44.250 --> 00:46:49.465
easy use of threads to
the working program--

00:46:49.465 --> 00:46:51.820
I think we'll need
libraries that

00:46:51.820 --> 00:46:54.610
provide easy use of isolates.

00:46:54.610 --> 00:46:57.650
SETH LIND: Now, do you think
that the fact that isolates

00:46:57.650 --> 00:47:00.540
exist, does that affect
the library design?

00:47:00.540 --> 00:47:03.175
Do you foresee that our
libraries and implementations

00:47:03.175 --> 00:47:05.395
will actually take advantage
of these isolates?

00:47:05.395 --> 00:47:08.890
JOSH BLOCH: Yeah, I do, in the
same way that the executor

00:47:08.890 --> 00:47:13.300
framework and executors
influence the design of more

00:47:13.300 --> 00:47:15.080
recent Java libraries.

00:47:15.080 --> 00:47:18.950
I do believe that isolates,
especially when it comes to

00:47:18.950 --> 00:47:21.963
processing large quantities of
data and things where you

00:47:21.963 --> 00:47:30.475
really do want to make use of
real parallelism, I think it

00:47:30.475 --> 00:47:32.600
will influence the design
of the libraries.

00:47:32.600 --> 00:47:34.405
I can't tell you exactly how.

00:47:34.405 --> 00:47:36.600
I haven't thought about
it in detail.

00:47:36.600 --> 00:47:40.850
So I'm not going to try to
do this one on my feet.

00:47:40.850 --> 00:47:43.205
But yes, I suspect it
will impact the

00:47:43.205 --> 00:47:44.810
design of the libraries.

00:47:44.810 --> 00:47:46.890
SETH LIND: So with everyone
watching, this is going to go

00:47:46.890 --> 00:47:48.995
up on YouTube as well,
and the moderator and

00:47:48.995 --> 00:47:51.400
all that great stuff.

00:47:51.400 --> 00:47:53.660
What are the things you want
to know from the community?

00:47:53.660 --> 00:47:57.030
What kind of feedback can the
community give you as they

00:47:57.030 --> 00:47:58.530
approach Dart and use
the libraries?

00:47:58.530 --> 00:47:59.735
Anything specific?

00:47:59.735 --> 00:48:02.810
JOSH BLOCH: Sure.

00:48:02.810 --> 00:48:12.970
So one thing we were discussing
earlier is do

00:48:12.970 --> 00:48:16.560
people want to extend
implementation classes?

00:48:16.560 --> 00:48:19.160
Or would they rather be
insulated from them?

00:48:19.160 --> 00:48:22.180
Would they rather have small,
easy to learn libraries that

00:48:22.180 --> 00:48:27.030
don't actually let you
do subclassing of

00:48:27.030 --> 00:48:29.230
implementation classes?

00:48:29.230 --> 00:48:30.400
That's one.

00:48:30.400 --> 00:48:34.730
Another one is that-- and I look
at the list interface.

00:48:34.730 --> 00:48:37.230
One thing it doesn't have right
now that's Java's did

00:48:37.230 --> 00:48:39.695
was sublist. And sublist
was controversial.

00:48:39.695 --> 00:48:42.645
It's very powerful because you
can do anything that you can

00:48:42.645 --> 00:48:45.370
do to a list, whether it's
shuffling, or sorting, or

00:48:45.370 --> 00:48:48.700
rotating, or reflecting, or what
have you, you can do to

00:48:48.700 --> 00:48:53.330
an arbitrary sublist of that
list. But the downside is that

00:48:53.330 --> 00:48:57.206
you get aliasing [INAUDIBLE]
problems that that leads to.

00:48:57.206 --> 00:49:01.535
So, should Dart have a sublist
operation on list or not?

00:49:05.990 --> 00:49:07.330
I don't know.

00:49:07.330 --> 00:49:08.590
Ah, let's see.

00:49:08.590 --> 00:49:14.740
And a language one is--

00:49:14.740 --> 00:49:21.160
we've been thinking about
the pace, the switch

00:49:21.160 --> 00:49:23.400
statement in Dart.

00:49:23.400 --> 00:49:28.533
And as you probably know, switch
statement in C in the

00:49:28.533 --> 00:49:30.840
1970s allowed fallthrough.

00:49:30.840 --> 00:49:32.960
It's very unstructured.

00:49:32.960 --> 00:49:38.420
In every other control structure
in C, you have

00:49:38.420 --> 00:49:39.730
condition, statement.

00:49:39.730 --> 00:49:42.010
And it's a block structured
language, so you either have

00:49:42.010 --> 00:49:43.770
one statement or a block
containing multiple

00:49:43.770 --> 00:49:44.100
statements.

00:49:44.100 --> 00:49:47.312
But in a switch, you just have
multiple statements, and these

00:49:47.312 --> 00:49:49.790
labels, and things
fall through.

00:49:49.790 --> 00:49:51.270
And that's been copied
in basically

00:49:51.270 --> 00:49:53.850
every language to date.

00:49:53.850 --> 00:49:57.730
And I feel like it's probably
time for that to die.

00:49:57.730 --> 00:50:01.130
It's still there in Dart, but it
doesn't necessarily have to

00:50:01.130 --> 00:50:01.290
stay there.

00:50:01.290 --> 00:50:05.500
The question is, right
now Dart does

00:50:05.500 --> 00:50:06.990
not allow fall through.

00:50:06.990 --> 00:50:13.705
But it does this by throwing
an exception at runtime if

00:50:13.705 --> 00:50:14.820
there's a fall through.

00:50:14.820 --> 00:50:17.880
I would prefer this
to be syntactic.

00:50:17.880 --> 00:50:21.540
So the question is, would anyone
miss it if the syntax

00:50:21.540 --> 00:50:25.960
of Dart didn't allow for
a fall through anymore?

00:50:25.960 --> 00:50:28.630
I'm talking in the case of the
switch statement, if it were

00:50:28.630 --> 00:50:33.740
more structured, if after each
case label, you had precisely

00:50:33.740 --> 00:50:37.210
one statement, which could
be a block if you wish.

00:50:37.210 --> 00:50:40.450
To me, that's seems a reasonable
way to design a

00:50:40.450 --> 00:50:44.240
switch statement in the
new millennium.

00:50:44.240 --> 00:50:46.412
So agree or disagree?

00:50:46.412 --> 00:50:49.020
SETH LIND: And you can agree
or disagree on our mailing

00:50:49.020 --> 00:50:52.110
list, which you can find at
dartlang.org, or by going to

00:50:52.110 --> 00:50:55.690
dartbug.com, which links you
straight to our issue tracker.

00:50:55.690 --> 00:50:58.490
Dart is an open source project,
and all this does

00:50:58.490 --> 00:50:59.500
happen out there.

00:50:59.500 --> 00:51:00.900
And we listen to
your feedback.

00:51:00.900 --> 00:51:04.260
And so we're very sincere when
we say, let us know which of

00:51:04.260 --> 00:51:06.065
these things resonates
with you via

00:51:06.065 --> 00:51:08.770
these different channels.

00:51:08.770 --> 00:51:12.250
We do make these changes,
so we appreciate it.

00:51:12.250 --> 00:51:15.280
For everyone watching at home,
I want to thank you for

00:51:15.280 --> 00:51:18.120
joining us at Dartisans, episode
three, talking about

00:51:18.120 --> 00:51:20.456
the Dart libraries
with Josh Bloch.

00:51:20.456 --> 00:51:23.550
If you could do us a favor and
+1 this post, let us know if

00:51:23.550 --> 00:51:25.380
this format worked for you.

00:51:25.380 --> 00:51:30.020
And let us know in the comments
what other topics

00:51:30.020 --> 00:51:32.440
you'd like to see or
hear covered in

00:51:32.440 --> 00:51:34.420
future episodes of Dartisans.

00:51:34.420 --> 00:51:38.590
We are always listening, and
we're on Twitter, and Google+,

00:51:38.590 --> 00:51:39.620
and YouTube.

00:51:39.620 --> 00:51:42.100
this video will be posted to
YouTube, so you can catch up

00:51:42.100 --> 00:51:44.510
with the whole interview
later.

00:51:44.510 --> 00:51:47.030
So with that, I want to thank
everyone for their questions

00:51:47.030 --> 00:51:49.420
and their time, and especially
Josh and the Dart team for

00:51:49.420 --> 00:51:53.210
being so open and pulling back
the curtain a little bit and

00:51:53.210 --> 00:51:54.900
let us watch as this
new language and

00:51:54.900 --> 00:51:56.110
platform is being born.

00:51:56.110 --> 00:51:58.780
So with that, thank you very
much for your time, Josh.

00:51:58.780 --> 00:52:00.600
JOSH BLOCH: Thank you
for inviting me.

00:52:00.600 --> 00:52:05.370
As you said, the hour went
quickly, and I hope to come

00:52:05.370 --> 00:52:07.560
back again some day when I have
something new to report,

00:52:07.560 --> 00:52:10.910
like collections framework
changes or whatever.

00:52:10.910 --> 00:52:11.800
SETH LIND: Awesome, well,
we'll be very

00:52:11.800 --> 00:52:12.830
happy to see you again.

00:52:12.830 --> 00:52:13.315
JOSH BLOCH: Great.

00:52:13.315 --> 00:52:14.040
SETH LIND: Thanks, everyone.

00:52:14.040 --> 00:52:15.290
We'll see you next time
on Dartisans.

