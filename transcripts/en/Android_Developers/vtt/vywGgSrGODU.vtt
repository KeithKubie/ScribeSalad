WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.353
[MUSIC PLAYING]

00:00:06.369 --> 00:00:08.160
FRANK VAN DIGGELEN:
We're going to show you

00:00:08.160 --> 00:00:11.100
how recent changes in
hardware and standards

00:00:11.100 --> 00:00:14.280
make one meter-location
accuracy possible,

00:00:14.280 --> 00:00:17.070
in some cases, as
soon as this year.

00:00:17.070 --> 00:00:19.140
I'll give you a
short overview now.

00:00:19.140 --> 00:00:21.720
Then Roy will introduce
Wi-Fi Round Trip Time

00:00:21.720 --> 00:00:24.930
technology and standards
and show you a live demo.

00:00:24.930 --> 00:00:28.160
Then Wei will explain
the Wi-Fi APIs.

00:00:28.160 --> 00:00:33.180
Then I'll return and talk about
new GPS technology and APIs.

00:00:33.180 --> 00:00:35.810
At the end, they'll be loading
up for the next session.

00:00:35.810 --> 00:00:38.220
So we'll take questions
right outside that door.

00:00:38.220 --> 00:00:44.470
And we'll be available at
office hours at 1:30 PM today.

00:00:44.470 --> 00:00:47.610
So it's a great time for
location applications

00:00:47.610 --> 00:00:52.320
because technology, hardware,
standards, and Android API

00:00:52.320 --> 00:00:55.230
is all evolving
simultaneously to enable

00:00:55.230 --> 00:01:00.240
accuracy that has not been
possible previously in phones.

00:01:00.240 --> 00:01:04.349
So eventually this means
high accuracy for everyone.

00:01:04.349 --> 00:01:08.310
But today we want to take you
under the hood of location

00:01:08.310 --> 00:01:10.980
because we want to give you
the opportunity to get a head

00:01:10.980 --> 00:01:13.050
start on the future.

00:01:13.050 --> 00:01:15.660
We also want to highlight the
need to protect and respect

00:01:15.660 --> 00:01:16.630
the user.

00:01:16.630 --> 00:01:19.970
The more people who use
location, the more careful

00:01:19.970 --> 00:01:22.140
we and you have to be.

00:01:22.140 --> 00:01:25.560
We'll highlight where you
must get user permissions,

00:01:25.560 --> 00:01:27.060
and we'll close
with some guidelines

00:01:27.060 --> 00:01:30.130
for making great location apps.

00:01:30.130 --> 00:01:33.930
So where are we today with
indoor location accuracy?

00:01:33.930 --> 00:01:36.900
If you think you've noticed
that your phone seems

00:01:36.900 --> 00:01:39.720
to be more accurate when
you're inside shopping malls

00:01:39.720 --> 00:01:43.290
and office blocks than
it was a few years ago,

00:01:43.290 --> 00:01:44.700
you're not imagining it.

00:01:44.700 --> 00:01:47.580
With each release of the
Fused Location Provider,

00:01:47.580 --> 00:01:50.340
we've had steady improvement
of the Android algorithms

00:01:50.340 --> 00:01:53.070
and machine learning
for Wi-Fi locations.

00:01:53.070 --> 00:01:54.790
There continues
to be improvement.

00:01:54.790 --> 00:01:58.740
And you'll see indoor accuracy
of better than 10 meters.

00:01:58.740 --> 00:02:01.770
But Round Trip Time
is the technology

00:02:01.770 --> 00:02:05.040
that will take us to
the one-meter level.

00:02:05.040 --> 00:02:07.110
Meanwhile, what about GPS?

00:02:07.110 --> 00:02:10.860
Well, in terms of GPS
accuracy in the open sky,

00:02:10.860 --> 00:02:13.270
there has been not much
change in the last few years.

00:02:13.270 --> 00:02:16.080
If you're out in the open
sky, your GPS accuracy

00:02:16.080 --> 00:02:19.890
from your phone is five meters,
and that's been constant.

00:02:19.890 --> 00:02:23.760
But raw measurements, raw GNSS
measurements from the phones,

00:02:23.760 --> 00:02:25.140
you can now improve on this.

00:02:25.140 --> 00:02:28.310
And with changes in satellite
and receiver hardware,

00:02:28.310 --> 00:02:32.130
the improvements
can become dramatic.

00:02:32.130 --> 00:02:34.800
Now, everyone's familiar
with the blue dot.

00:02:34.800 --> 00:02:38.190
But to get the blue dot, you
need the location provider,

00:02:38.190 --> 00:02:38.850
of course.

00:02:38.850 --> 00:02:42.300
And to get location, you need
measurements, specifically

00:02:42.300 --> 00:02:45.120
range measurements from
Wi-Fi access points

00:02:45.120 --> 00:02:47.220
or from GPS satellites.

00:02:47.220 --> 00:02:50.100
Today we'll show you how
one-meter measurement accuracy

00:02:50.100 --> 00:02:51.960
is available in phones.

00:02:51.960 --> 00:02:55.260
The key technologies are
Wi-Fi Round Trip Time,

00:02:55.260 --> 00:02:59.070
GPS dual frequency and
carrier phase measurements.

00:02:59.070 --> 00:03:01.650
And we'll show you how to
use accurate measurements

00:03:01.650 --> 00:03:03.895
to create accurate location.

00:03:03.895 --> 00:03:06.210
Now, if you just want
to wait a year or two,

00:03:06.210 --> 00:03:09.390
this will all find its way
into the worldwide ecosystem

00:03:09.390 --> 00:03:11.590
and the Fused Location Provider.

00:03:11.590 --> 00:03:14.910
But we want to give you a chance
for a one-to-two-year lead

00:03:14.910 --> 00:03:18.840
by taking accurate measurements
and turning them into accurate

00:03:18.840 --> 00:03:19.830
location.

00:03:19.830 --> 00:03:21.630
We want to work with
you to accelerate

00:03:21.630 --> 00:03:26.410
the future, to take it and
bring it closer to the present.

00:03:26.410 --> 00:03:28.840
So you might wonder, well,
why do I need better location

00:03:28.840 --> 00:03:30.100
accuracy anyway?

00:03:30.100 --> 00:03:32.710
Well, let's just
look at two instances

00:03:32.710 --> 00:03:35.780
where existing apps could use
much better location accuracy.

00:03:35.780 --> 00:03:38.050
So for indoor
routing or navigation

00:03:38.050 --> 00:03:40.360
of the kind that you're
used to in your cars,

00:03:40.360 --> 00:03:42.670
you need much better accuracy
than you have outdoors.

00:03:42.670 --> 00:03:46.120
You need one-meter accuracy,
because indoor features,

00:03:46.120 --> 00:03:48.645
like the distance
between cubes or aisles,

00:03:48.645 --> 00:03:50.950
are only a few meters.

00:03:50.950 --> 00:03:54.160
And even for the most
loved outdoor applications,

00:03:54.160 --> 00:03:57.520
such as directions and
especially directions

00:03:57.520 --> 00:04:00.950
in traffic, we could use higher
accuracy than we have now.

00:04:00.950 --> 00:04:03.580
For example, when you came
here this morning in a car,

00:04:03.580 --> 00:04:06.490
you probably had
the time estimated

00:04:06.490 --> 00:04:08.530
by the average traffic speed.

00:04:08.530 --> 00:04:11.339
What you really want is the
traffic speed in the lane

00:04:11.339 --> 00:04:12.880
that you're in so
that you could ask,

00:04:12.880 --> 00:04:16.500
how fast would it be if I
could take the carpool lane?

00:04:16.500 --> 00:04:18.640
There are, of course,
many other use cases,

00:04:18.640 --> 00:04:20.769
and I'll mention a
few before we finish.

00:04:20.769 --> 00:04:22.630
But the important
thing is that we

00:04:22.630 --> 00:04:26.620
are sure that you will have
many more ideas than we have,

00:04:26.620 --> 00:04:30.090
and that's the beauty of
the Open Android ecosystem.

00:04:30.090 --> 00:04:34.770
So now here's Roy to tell you
about Wi-Fi Round Trip Time.

00:04:34.770 --> 00:04:35.993
ROY WANT: Thanks, Frank.

00:04:35.993 --> 00:04:39.780
[APPLAUSE]

00:04:39.780 --> 00:04:41.520
And I'm very excited
to be here today

00:04:41.520 --> 00:04:43.080
to tell you about
a new positioning

00:04:43.080 --> 00:04:48.090
technology in Android P we call
Wi-Fi Round Trip Time, or RTT.

00:04:48.090 --> 00:04:50.310
You'll hear me say
that acronym a lot,

00:04:50.310 --> 00:04:54.000
which is basically measuring the
time of flight of RF signals.

00:04:54.000 --> 00:04:57.300
It has the potential to
estimate your indoor position

00:04:57.300 --> 00:05:01.061
to an accuracy of
one to two meters.

00:05:01.061 --> 00:05:03.060
Now, we're going to hit
the ground running today

00:05:03.060 --> 00:05:06.060
before I tell you about
the details of RTT.

00:05:06.060 --> 00:05:10.410
And we're going to show you
a video of indoor navigation

00:05:10.410 --> 00:05:11.784
powered by RTT.

00:05:11.784 --> 00:05:13.200
I want to emphasize,
first of all,

00:05:13.200 --> 00:05:16.650
that this is not a product,
but an internal prototype

00:05:16.650 --> 00:05:18.780
to explore the power
of the technology

00:05:18.780 --> 00:05:20.720
and how it can also
be used to support

00:05:20.720 --> 00:05:22.980
a other context-aware
applications.

00:05:22.980 --> 00:05:26.550
This prototype also
showcases some of the magic

00:05:26.550 --> 00:05:29.440
that Google could offer
to its employees today.

00:05:29.440 --> 00:05:31.710
So we're going to
roll the video.

00:05:31.710 --> 00:05:33.810
And what you should
keep in mind is

00:05:33.810 --> 00:05:38.490
that this is a bit like car GPS
except we're working indoors.

00:05:38.490 --> 00:05:40.680
So in a moment, you'll see
there's an application.

00:05:40.680 --> 00:05:41.805
It's a mapping application.

00:05:41.805 --> 00:05:44.070
And we're searching
for a conference room.

00:05:44.070 --> 00:05:45.420
We found that conference room.

00:05:45.420 --> 00:05:46.550
It's plotted the route.

00:05:46.550 --> 00:05:48.090
That's the shortest route.

00:05:48.090 --> 00:05:49.110
And now we're off.

00:05:49.110 --> 00:05:50.550
We're following the route.

00:05:50.550 --> 00:05:53.730
And as we make progress, you can
see the route is turning gray.

00:05:53.730 --> 00:05:55.885
My position from
RTT is the big dot.

00:05:55.885 --> 00:05:58.420
And I'm deliberately
making an error here.

00:05:58.420 --> 00:06:01.860
So the system is rerouting,
and it's rerouting again.

00:06:01.860 --> 00:06:05.880
If I get about 20 feet away, it
starts the rerouting process.

00:06:05.880 --> 00:06:08.550
And I'm following the route.

00:06:08.550 --> 00:06:10.620
And you can see the
corridor flying by.

00:06:10.620 --> 00:06:13.440
And there I'm
coming in, and I've

00:06:13.440 --> 00:06:17.640
arrived at my destination,
conference room Tepu.

00:06:17.640 --> 00:06:19.560
So that is the power of RTT.

00:06:19.560 --> 00:06:21.450
And the thing to think about--

00:06:21.450 --> 00:06:22.260
[APPLAUSE]

00:06:22.260 --> 00:06:23.100
Thank you.

00:06:27.100 --> 00:06:30.160
The thing to think about here
is that if you didn't have

00:06:30.160 --> 00:06:34.870
one-to-two-meter accuracy,
then when that system rerouted,

00:06:34.870 --> 00:06:37.270
it would jump potentially
between aisles that were

00:06:37.270 --> 00:06:37.960
surrounding me.

00:06:37.960 --> 00:06:39.980
And it would be a
terrible user experience.

00:06:39.980 --> 00:06:44.490
So that's why it's so important
to have this kind of accuracy.

00:06:44.490 --> 00:06:48.360
So before I get into the
details of Wi-Fi RTT,

00:06:48.360 --> 00:06:52.080
I want tell you about how we
calculate location indoors now.

00:06:52.080 --> 00:06:57.330
We use Wi-Fi RSSI, which stands
for Received Signal Strength

00:06:57.330 --> 00:06:58.320
Indication.

00:06:58.320 --> 00:07:00.600
And basically we can
calculate distance

00:07:00.600 --> 00:07:02.700
as a function of
signal strength.

00:07:02.700 --> 00:07:05.790
Now, the figure that you see
on the left-hand side here,

00:07:05.790 --> 00:07:07.920
the access point,
which is in the center,

00:07:07.920 --> 00:07:10.750
has a heat map of
signal strength.

00:07:10.750 --> 00:07:13.230
The green is the
strongest, and the red

00:07:13.230 --> 00:07:14.950
is the weakest at the edges.

00:07:14.950 --> 00:07:17.720
And I've placed two
phones on this diagram

00:07:17.720 --> 00:07:21.420
at the transition between
the weak and the strong.

00:07:21.420 --> 00:07:23.730
Notice that the
phone on the right

00:07:23.730 --> 00:07:25.380
is further away from
the access point

00:07:25.380 --> 00:07:28.560
than the phone on the
left, so same signal

00:07:28.560 --> 00:07:30.050
strength, different distance.

00:07:30.050 --> 00:07:32.890
And it's this variability in
distance for signal strength

00:07:32.890 --> 00:07:38.280
that unfortunately makes it very
hard to get accurate readings

00:07:38.280 --> 00:07:39.969
from RSSI on a regular basis.

00:07:39.969 --> 00:07:41.760
But there are lots of
algorithms and tricks

00:07:41.760 --> 00:07:44.100
that we can pull
to improve this,

00:07:44.100 --> 00:07:45.580
but it can be improved further.

00:07:45.580 --> 00:07:49.860
And that's where Wi-Fi
RTT comes into place.

00:07:49.860 --> 00:07:53.070
So Wi-Fi RTT,
Round Trip Time, it

00:07:53.070 --> 00:07:55.575
uses time of flight
instead of signal strength.

00:07:55.575 --> 00:07:59.790
It measures the time it takes
to send a packet, a Wi-Fi RF

00:07:59.790 --> 00:08:03.725
packet, from an access point
to a phone and back again.

00:08:03.725 --> 00:08:06.960
And because radio signals
travel at the same speed

00:08:06.960 --> 00:08:10.980
as visible light, if we
multiply the total time

00:08:10.980 --> 00:08:13.920
by the speed of light
and we divide by 2,

00:08:13.920 --> 00:08:16.680
we get distance, round
trip time divided by 2.

00:08:16.680 --> 00:08:19.220
And we get the range from the
phone to the access point.

00:08:19.220 --> 00:08:22.054
So that's the basic principle.

00:08:22.054 --> 00:08:25.180
Now, if you want to
calculate position,

00:08:25.180 --> 00:08:27.610
we have to use a process called
multilateration, and more

00:08:27.610 --> 00:08:28.760
on that in a minute.

00:08:28.760 --> 00:08:30.385
Well, the key thing
to think about here

00:08:30.385 --> 00:08:32.860
is the more ranges you have,
the more constraints you get,

00:08:32.860 --> 00:08:35.539
and the more accurate
position you can achieve.

00:08:35.539 --> 00:08:37.870
And if you can use
at least four ranges,

00:08:37.870 --> 00:08:40.570
then we think you can get
typically an accuracy of one

00:08:40.570 --> 00:08:44.020
or two meters in most buildings.

00:08:44.020 --> 00:08:46.480
So why am I telling you
about Wi-Fi RTT today?

00:08:46.480 --> 00:08:49.120
Why not last year or before?

00:08:49.120 --> 00:08:51.010
Well, what I want
you to take away

00:08:51.010 --> 00:08:56.950
is that 2018 is the year
of Wi-Fi RTT in Android.

00:08:56.950 --> 00:09:01.870
Your takeaways are that we
are releasing a public API

00:09:01.870 --> 00:09:07.030
in Android P based on the
IEEE 802.11mc protocol.

00:09:07.030 --> 00:09:09.340
And furthermore,
we're also integrating

00:09:09.340 --> 00:09:13.160
aspects of this protocol into
the Fused Location Provider,

00:09:13.160 --> 00:09:15.670
which is the main
location API that people

00:09:15.670 --> 00:09:18.250
use to put a location on a map.

00:09:18.250 --> 00:09:22.690
And any time they're on RTT
access points in the vicinity,

00:09:22.690 --> 00:09:26.215
the accuracy of that
position will be greater.

00:09:26.215 --> 00:09:29.140
Now, a little bit of
history, the 802.11 standard

00:09:29.140 --> 00:09:32.780
was ratified in
2016, the end of it.

00:09:32.780 --> 00:09:36.040
And in early 2017,
the Wi-Fi Alliance

00:09:36.040 --> 00:09:38.410
started doing interop
between silicon vendors

00:09:38.410 --> 00:09:40.480
to make sure the chips
followed the protocol.

00:09:40.480 --> 00:09:42.880
And that's when we started
doing a lot of work

00:09:42.880 --> 00:09:45.880
to validate how it could
be integrated into Android.

00:09:45.880 --> 00:09:48.790
And by the fall of
this year, of course,

00:09:48.790 --> 00:09:50.710
we will release the
API so that all of you

00:09:50.710 --> 00:09:53.140
can now have access and
build your own applications

00:09:53.140 --> 00:09:56.140
around that technology.

00:09:56.140 --> 00:09:58.180
So now diving into
the principles

00:09:58.180 --> 00:10:01.330
of how Wi-Fi RTT works.

00:10:01.330 --> 00:10:05.080
So the ranging process starts
with a standard Wi-Fi scan.

00:10:05.080 --> 00:10:07.480
The phone discovers the access
points which are around.

00:10:07.480 --> 00:10:09.310
And based on certain
bits which are

00:10:09.310 --> 00:10:12.910
set inside the beacons
and the probe responses,

00:10:12.910 --> 00:10:17.260
we can figure out which of those
access points are RTT capable.

00:10:17.260 --> 00:10:19.360
And the phone chooses one
of those to range too,

00:10:19.360 --> 00:10:22.480
and it starts by making a
request to the access point.

00:10:22.480 --> 00:10:24.520
And as a result,
the access point

00:10:24.520 --> 00:10:26.890
will start a ping-pong
protocol back.

00:10:26.890 --> 00:10:28.570
The ping that's
sent to the phone

00:10:28.570 --> 00:10:32.410
is called an FTM, or Fine
Timing Measurement packet.

00:10:32.410 --> 00:10:35.740
And the pong that's sent
back to the access point

00:10:35.740 --> 00:10:37.780
is an acknowledgment
of that packet.

00:10:37.780 --> 00:10:40.240
The timestamps are
recorded at each end.

00:10:40.240 --> 00:10:41.970
Each device records them.

00:10:41.970 --> 00:10:44.530
But for the phone to calculate
the total round trip time,

00:10:44.530 --> 00:10:46.900
it needs to have all
of those timestamps.

00:10:46.900 --> 00:10:50.530
So the access point sends one
more packet, a third message,

00:10:50.530 --> 00:10:52.720
which contains the missing two.

00:10:52.720 --> 00:10:55.420
The phone, then, simply
calculates the round trip time

00:10:55.420 --> 00:10:58.210
by subtracting the
timestamps from the AP

00:10:58.210 --> 00:11:03.020
and its own turnaround time
which are the timestamps

00:11:03.020 --> 00:11:04.180
that it recorded.

00:11:04.180 --> 00:11:05.940
So that leaves the
time of flight.

00:11:05.940 --> 00:11:08.425
We multiply by the speed
of light to get distance.

00:11:08.425 --> 00:11:09.460
We divided by 2.

00:11:09.460 --> 00:11:12.710
And we get the range
that we care about.

00:11:12.710 --> 00:11:16.330
Now, it turns out, if you do
this process multiple times,

00:11:16.330 --> 00:11:18.429
you will, in fact,
get more accuracy.

00:11:18.429 --> 00:11:20.220
And so that's what the
protocol allows for.

00:11:20.220 --> 00:11:21.670
It allows for a burst.

00:11:21.670 --> 00:11:25.060
In Android, we're typically
during a burst of about eight

00:11:25.060 --> 00:11:26.440
of these events.

00:11:26.440 --> 00:11:28.930
And as a consequence,
the system can

00:11:28.930 --> 00:11:31.810
calculate statistics,
so the mean

00:11:31.810 --> 00:11:35.380
and the variance, which allows
us to more accurately plot

00:11:35.380 --> 00:11:37.060
a position on a map.

00:11:37.060 --> 00:11:40.200
And knowing the accuracy also
allows us to calculate a path

00:11:40.200 --> 00:11:43.510
more accurately as well.

00:11:43.510 --> 00:11:45.550
So now you have ranges.

00:11:45.550 --> 00:11:47.530
How do you get a position?

00:11:47.530 --> 00:11:49.340
So I just want to give
you a feel for how

00:11:49.340 --> 00:11:50.340
you go about doing this.

00:11:50.340 --> 00:11:53.219
Now, there's lots of different
mathematical approaches.

00:11:53.219 --> 00:11:54.760
And I'm just picking
one because it's

00:11:54.760 --> 00:11:56.320
relatively easy to explain.

00:11:56.320 --> 00:11:58.420
But this is where the
power of developers

00:11:58.420 --> 00:12:01.610
comes in for you to figure
out your own way to do it.

00:12:01.610 --> 00:12:04.840
So if you know a phone is at
a certain range from an access

00:12:04.840 --> 00:12:07.390
point, that tells you
that it can be anywhere

00:12:07.390 --> 00:12:10.950
on the circumference of a circle
of that radius, the radius r.

00:12:10.950 --> 00:12:14.050
And I've written
the circle equation

00:12:14.050 --> 00:12:16.570
for that circumference
on the right-hand side

00:12:16.570 --> 00:12:19.090
at center, x1 y1.

00:12:19.090 --> 00:12:21.010
Now, if you want
to find a position,

00:12:21.010 --> 00:12:22.180
you've got to constrain it.

00:12:22.180 --> 00:12:25.360
So if you take four ranges, the
four separate access points,

00:12:25.360 --> 00:12:28.540
as shown on the diagram
on the right-hand side,

00:12:28.540 --> 00:12:31.120
you then can see that if
those ranges were accurate,

00:12:31.120 --> 00:12:34.030
those circles would
intersect at a single point.

00:12:34.030 --> 00:12:35.881
How do you find that
point programattically?

00:12:35.881 --> 00:12:38.380
Well, if you write those four
equations out on the left-hand

00:12:38.380 --> 00:12:39.350
side--

00:12:39.350 --> 00:12:42.040
you see the nasty
circle equations,

00:12:42.040 --> 00:12:44.300
which may be difficult,
but, in fact, it's

00:12:44.300 --> 00:12:45.550
actually very straightforward.

00:12:45.550 --> 00:12:46.930
You pick one of them.

00:12:46.930 --> 00:12:48.430
You subtract it
from all the others.

00:12:48.430 --> 00:12:50.263
And you end up with a
set of line equations.

00:12:50.263 --> 00:12:52.390
The squared terms disappear.

00:12:52.390 --> 00:12:55.130
And those lines are, in fact,
drawn on this diagram as well.

00:12:55.130 --> 00:12:58.630
And then it's very easy to find
out where two lines intersect.

00:12:58.630 --> 00:13:01.390
Now, there's one problem
with what I've just told you.

00:13:01.390 --> 00:13:03.700
And the problem is
that we're assuming

00:13:03.700 --> 00:13:05.680
the measurements are perfect.

00:13:05.680 --> 00:13:08.080
In reality, no
measurements are perfect.

00:13:08.080 --> 00:13:09.820
Everything has error.

00:13:09.820 --> 00:13:14.000
And there will be no exact
solution to that equation.

00:13:14.000 --> 00:13:16.370
So let me give you a
more realistic example.

00:13:16.370 --> 00:13:20.170
So here we have several access
points which we've ranged to.

00:13:20.170 --> 00:13:22.480
And I've exaggerated
the problem here.

00:13:22.480 --> 00:13:25.944
And you can see, some of
those circles don't intersect.

00:13:25.944 --> 00:13:26.860
How do you solve that?

00:13:26.860 --> 00:13:28.720
Well, in, fact, you do the
same thing as you did before.

00:13:28.720 --> 00:13:29.800
You subtract the circles.

00:13:29.800 --> 00:13:30.670
You get the lines.

00:13:30.670 --> 00:13:32.710
But this time they don't
intersect in a point.

00:13:32.710 --> 00:13:34.240
They intersect in a polygon.

00:13:34.240 --> 00:13:36.400
In this case, it's a triangle.

00:13:36.400 --> 00:13:40.120
And your phone lies probably
somewhere, maximum likelihood

00:13:40.120 --> 00:13:42.520
in center of that triangle.

00:13:42.520 --> 00:13:44.320
And then we can
apply some college

00:13:44.320 --> 00:13:47.810
math, least squares solution,
and get a maximum likelihood.

00:13:47.810 --> 00:13:52.270
You can find standard packages
which do this on the net.

00:13:52.270 --> 00:13:54.400
You can then also refine
this position further

00:13:54.400 --> 00:13:56.470
by repeating this
process, particularly

00:13:56.470 --> 00:13:58.850
as the phone moves, and then
you can calculate trajectory

00:13:58.850 --> 00:14:00.850
and use filtering techniques
like common filters

00:14:00.850 --> 00:14:02.000
and other things.

00:14:02.000 --> 00:14:05.170
So that's the basic principles.

00:14:05.170 --> 00:14:08.300
Now, like any new technology,
there are challenges,

00:14:08.300 --> 00:14:10.300
and so we've experienced
some of these early on.

00:14:10.300 --> 00:14:12.880
A little robot, which you can
see on the right-hand side,

00:14:12.880 --> 00:14:15.850
is used by us to measure the
range from the phone which it's

00:14:15.850 --> 00:14:17.680
carrying to an access point.

00:14:17.680 --> 00:14:20.300
And it validates that
range against the marks,

00:14:20.300 --> 00:14:23.320
which are on the floor, which
provide us with ground truth.

00:14:23.320 --> 00:14:25.000
What we find is that
sometimes there's

00:14:25.000 --> 00:14:28.060
a constant range calibration
offset, maybe as much as a half

00:14:28.060 --> 00:14:29.170
a meter.

00:14:29.170 --> 00:14:31.510
And sometimes also you
see multi-path effects,

00:14:31.510 --> 00:14:34.990
where the known line-of-sight
path from the access

00:14:34.990 --> 00:14:37.870
point to the phone is
actually received rather

00:14:37.870 --> 00:14:39.940
than the line-of-sight path.

00:14:39.940 --> 00:14:42.520
That one can be solved by
the vendor using something

00:14:42.520 --> 00:14:44.170
called antenna diversity.

00:14:44.170 --> 00:14:46.060
But all of these things
are algorithms which

00:14:46.060 --> 00:14:47.440
the vendors are improving.

00:14:47.440 --> 00:14:49.398
And basically we need to
go through a, sort of,

00:14:49.398 --> 00:14:51.490
teething process of
getting rid of these bugs.

00:14:51.490 --> 00:14:53.620
And Google can help
in this process

00:14:53.620 --> 00:14:58.360
by providing reference platforms
and reference applications so

00:14:58.360 --> 00:15:01.450
that vendors can calibrate
their own platforms before you

00:15:01.450 --> 00:15:05.590
guys even get to use them, which
would be the ideal situation.

00:15:05.590 --> 00:15:09.490
Now, I've assumed that you want
to start as an early adopter

00:15:09.490 --> 00:15:11.710
and start using this API.

00:15:11.710 --> 00:15:14.930
But as we move into the
relatively near future,

00:15:14.930 --> 00:15:17.712
we expect you to just use
the Fused Location Provider

00:15:17.712 --> 00:15:19.420
because we're going
to be putting the RTT

00:15:19.420 --> 00:15:21.070
capability into it.

00:15:21.070 --> 00:15:22.810
So at the moment,
Fused Location Provider

00:15:22.810 --> 00:15:27.970
uses GPS when it's available,
cell, signal strength, Wi-Fi,

00:15:27.970 --> 00:15:31.850
RSSI, and also fuses
with the on-board sensors

00:15:31.850 --> 00:15:35.080
inertia navigation from
accelerometer and gyro.

00:15:35.080 --> 00:15:38.110
Now we're adding Wi-Fi
RTT into that mix.

00:15:38.110 --> 00:15:39.940
And it will increase
the accuracy

00:15:39.940 --> 00:15:44.620
whenever RTT cable access
points are available.

00:15:44.620 --> 00:15:46.180
So the one other
thing to remember

00:15:46.180 --> 00:15:48.010
is that when you were
doing it yourself,

00:15:48.010 --> 00:15:50.746
you had to know the position
of the access points.

00:15:50.746 --> 00:15:52.120
With the Fused
Location Provider,

00:15:52.120 --> 00:15:54.670
we will know those positions
automatically for you.

00:15:54.670 --> 00:15:56.340
We'll crowdsource
those positions,

00:15:56.340 --> 00:15:58.090
and so you won't have
to worry about that.

00:15:58.090 --> 00:16:01.150
And that would make
life a lot easier

00:16:01.150 --> 00:16:04.150
for you to write applications.

00:16:04.150 --> 00:16:06.250
So now we're going
to take it up a notch

00:16:06.250 --> 00:16:09.710
and we're going to give you a
live RTT demo in collaboration

00:16:09.710 --> 00:16:12.910
with some of our
colleagues in Geo.

00:16:12.910 --> 00:16:20.717
What I have over here on
the podium is a phone--

00:16:20.717 --> 00:16:21.550
let's bring it back.

00:16:21.550 --> 00:16:24.450
OK, there we go--

00:16:24.450 --> 00:16:28.920
which is running an RTT
system in combination

00:16:28.920 --> 00:16:31.110
with Google Mobile Maps.

00:16:31.110 --> 00:16:34.212
And what we're
doing is we're using

00:16:34.212 --> 00:16:36.420
a number of access points,
which are around the room.

00:16:36.420 --> 00:16:39.904
So a moment ago you saw the blue
boxes which are on the slide.

00:16:39.904 --> 00:16:41.820
So these were provided
by one of our partners.

00:16:41.820 --> 00:16:44.340
And you can see them around
the room towards the back,

00:16:44.340 --> 00:16:47.390
on the side, and also a couple
in the center over here.

00:16:47.390 --> 00:16:50.730
Now, the thing to bear in
mind is that you would--

00:16:50.730 --> 00:16:52.470
this phone, because
we're just in a tent,

00:16:52.470 --> 00:16:54.400
would normally
receive GPS signals.

00:16:54.400 --> 00:16:55.840
So we've disabled GPS.

00:16:55.840 --> 00:16:59.230
You're only using
RTT with this phone.

00:16:59.230 --> 00:17:01.917
And what I'm going
to do is I'm going

00:17:01.917 --> 00:17:03.000
to walk around the aisles.

00:17:03.000 --> 00:17:05.069
And you can see on this
cast that I've already

00:17:05.069 --> 00:17:07.900
got a plot of where
I'm going to go.

00:17:07.900 --> 00:17:09.660
So I'm going to
start moving now.

00:17:09.660 --> 00:17:12.089
I'm going to start going
towards the corner of the stage.

00:17:12.089 --> 00:17:16.890
And you should see the
blue dot with my little man

00:17:16.890 --> 00:17:18.810
inside following me.

00:17:18.810 --> 00:17:23.177
And of course, we expect an
accuracy of one to two meters.

00:17:23.177 --> 00:17:24.510
And so I'm walking on the aisle.

00:17:24.510 --> 00:17:27.150
The aisle here is about--

00:17:27.150 --> 00:17:30.030
it's about two meters
across, thereabouts.

00:17:30.030 --> 00:17:35.452
And you can see it's very nicely
following within that accuracy.

00:17:35.452 --> 00:17:41.210
I think the demo environment
has been very good to us so far.

00:17:41.210 --> 00:17:42.530
So we're going along.

00:17:42.530 --> 00:17:47.400
And there's a little bit of lag.

00:17:47.400 --> 00:17:49.705
It's going around the back here.

00:17:49.705 --> 00:17:54.520
And we're approaching a
turnaround point, where

00:17:54.520 --> 00:17:57.880
I'm going to walk up the aisle.

00:17:57.880 --> 00:18:00.850
And we're rerouting
as I come back

00:18:00.850 --> 00:18:03.544
to make my path a
little bit shorter.

00:18:03.544 --> 00:18:05.210
And you can see we're
going very nicely.

00:18:05.210 --> 00:18:08.570
It's still well within
the one to two meters.

00:18:08.570 --> 00:18:12.190
And if you had GPS
shown here as well,

00:18:12.190 --> 00:18:14.930
I mean, typically you would be
expecting to see five meters.

00:18:14.930 --> 00:18:16.480
But that's, of course, outdoors.

00:18:16.480 --> 00:18:19.150
And indoors in a
typical building,

00:18:19.150 --> 00:18:22.046
you're only going to
have indoor location

00:18:22.046 --> 00:18:23.045
technology such as this.

00:18:23.045 --> 00:18:27.280
So now I'm approaching
the corner of the stage.

00:18:27.280 --> 00:18:32.717
And at this point, I'll
hand back over to Wei.

00:18:32.717 --> 00:18:33.550
Thank you very much.

00:18:33.550 --> 00:18:35.478
[APPLAUSE]

00:18:41.270 --> 00:18:43.020
Thank you.

00:18:43.020 --> 00:18:46.840
To Wei, he's going to tell you
about the details of the API.

00:18:46.840 --> 00:18:49.310
WEI WANG: Hey,
thanks a lot, Roy.

00:18:49.310 --> 00:18:51.080
What a great demo.

00:18:51.080 --> 00:18:54.530
So now you must be very eager
to try Round Trip Time ranging

00:18:54.530 --> 00:18:55.700
yourself.

00:18:55.700 --> 00:18:58.880
Let me walk you through
the RTT API in P

00:18:58.880 --> 00:19:04.370
to see how you can add RTT
in your own application.

00:19:04.370 --> 00:19:08.600
So as Roy mentioned, RTT
measures the round-trip time

00:19:08.600 --> 00:19:10.880
between two Wi-Fi devices.

00:19:10.880 --> 00:19:14.030
So both your mobile phone and
your the access points need

00:19:14.030 --> 00:19:17.910
to support 802.11mc protocol.

00:19:17.910 --> 00:19:21.950
And as you saw, RTT can give
you a very fine location,

00:19:21.950 --> 00:19:23.960
down to one meter-accuracy.

00:19:23.960 --> 00:19:26.630
So your application
needs to declare access

00:19:26.630 --> 00:19:28.520
find location permission.

00:19:28.520 --> 00:19:31.640
And of course, both
location and a Wi-Fi scan

00:19:31.640 --> 00:19:33.575
need to be enabled
on a mobile device.

00:19:36.480 --> 00:19:37.300
OK.

00:19:37.300 --> 00:19:40.850
So how do you know whether
your mobile phone supports RTT

00:19:40.850 --> 00:19:45.400
In P, we added a new system
feature called Feature Wi-Fi

00:19:45.400 --> 00:19:46.620
RTT.

00:19:46.620 --> 00:19:49.000
So you can simply check
whether this returns

00:19:49.000 --> 00:19:51.240
true on your mobile device.

00:19:51.240 --> 00:19:54.220
All Pixel Phones
running P [? DB2 ?]

00:19:54.220 --> 00:19:57.910
and above will support RTT.

00:19:57.910 --> 00:20:01.590
So how do you know whether
you access points support RTT?

00:20:01.590 --> 00:20:04.530
As normal, you will
need to do a Wi-Fi scan

00:20:04.530 --> 00:20:07.225
and get a list of
Wi-Fi scan results.

00:20:07.225 --> 00:20:10.780
[INAUDIBLE] run through this
list of Wi-Fi scan results

00:20:10.780 --> 00:20:14.840
and check whether this method
is 802.11mc [INAUDIBLE] return

00:20:14.840 --> 00:20:15.640
true.

00:20:15.640 --> 00:20:18.650
This will tell you whether
the access points support RTT.

00:20:21.820 --> 00:20:25.380
So after you get a list
of RTT-enabled IPs,

00:20:25.380 --> 00:20:28.380
simply add them to a
scan request builder

00:20:28.380 --> 00:20:31.140
to build a scan request.

00:20:31.140 --> 00:20:35.430
RTT is done by Wi-Fi RTT
Manager, which you can simply

00:20:35.430 --> 00:20:38.570
get by getting the
system service Wi-Fi

00:20:38.570 --> 00:20:41.820
RTT ranging service.

00:20:41.820 --> 00:20:45.880
OK, now we're ready
to start RTT ranging.

00:20:45.880 --> 00:20:49.650
By sending the RT request
to the RTT Manager

00:20:49.650 --> 00:20:53.290
with a ranging result
callback, RTT will start.

00:20:53.290 --> 00:20:57.220
Usually, RTT takes no more
than hundreds of milliseconds.

00:20:57.220 --> 00:21:01.910
And when it finishes, you would
get a list of the information,

00:21:01.910 --> 00:21:05.540
including the status,
RTT [INAUDIBLE],,

00:21:05.540 --> 00:21:08.860
the MAC address, which
IP you have just ranged

00:21:08.860 --> 00:21:11.920
and also, most
importantly, the distance

00:21:11.920 --> 00:21:14.470
between the mobile phone
and the access point.

00:21:17.900 --> 00:21:20.450
So here is the list of
the information you can

00:21:20.450 --> 00:21:22.610
get from RTT Ranging Results.

00:21:22.610 --> 00:21:23.920
You can get the distance.

00:21:23.920 --> 00:21:25.290
You can also get the
distance [INAUDIBLE],,

00:21:25.290 --> 00:21:27.915
deviation which is a [INAUDIBLE]
deviation from multiple ranges

00:21:27.915 --> 00:21:30.850
and multiple FTMs.

00:21:30.850 --> 00:21:34.610
And you also get a number of
attempted FTM measurements

00:21:34.610 --> 00:21:36.800
and number of
successful measurements.

00:21:36.800 --> 00:21:38.920
So the ratio of
successful measurements

00:21:38.920 --> 00:21:41.430
over attempted
measurements would give you

00:21:41.430 --> 00:21:45.300
an idea of how good the Wi-Fi
environment is for RTT ranging.

00:21:47.970 --> 00:21:48.550
OK.

00:21:48.550 --> 00:21:52.630
So I mentioned all Pixel
devices will support RTT.

00:21:52.630 --> 00:21:53.950
How about access points?

00:21:53.950 --> 00:21:56.260
We're beginning to
[INAUDIBLE] access points

00:21:56.260 --> 00:21:59.320
supporting 11mc
protocol in production.

00:21:59.320 --> 00:22:03.130
And we are very excited to let
you know Google Wi-Fi will soon

00:22:03.130 --> 00:22:04.300
support 11mc protocol.

00:22:06.900 --> 00:22:07.400
Thank you.

00:22:07.400 --> 00:22:09.212
[APPLAUSE]

00:22:11.030 --> 00:22:12.940
By the end of this
year, off the shelf,

00:22:12.940 --> 00:22:18.090
Google Wi-Fi will have
RTT enabled by default.

00:22:18.090 --> 00:22:19.920
And worldwide,
we're also beginning

00:22:19.920 --> 00:22:22.810
to send the
deployment of RTT IPs.

00:22:22.810 --> 00:22:28.200
South Korea is actually leading
the deployment of RTT IPs.

00:22:28.200 --> 00:22:31.150
And, of course, this is just the
beginning of the long journey.

00:22:31.150 --> 00:22:33.580
We're very eager to see
a larger penetration rate

00:22:33.580 --> 00:22:36.940
of RTT IPs in upcoming years.

00:22:36.940 --> 00:22:39.280
With that, I'm going
to hand over to Frank

00:22:39.280 --> 00:22:40.844
to talk about one meter GPS.

00:22:40.844 --> 00:22:42.094
FRANK VAN DIGGELEN: Thank you.

00:22:42.094 --> 00:22:43.570
[APPLAUSE]

00:22:49.480 --> 00:22:54.010
OK, so let's move to the great
outdoors and speak about GPS.

00:22:54.010 --> 00:22:56.440
I'm going to show you
some basics of GPS,

00:22:56.440 --> 00:22:59.950
just enough to explain
what's new to the satellites

00:22:59.950 --> 00:23:03.340
and what's new in the phones
and how you can exploit

00:23:03.340 --> 00:23:07.420
these changes to get better
location accuracy from GPS when

00:23:07.420 --> 00:23:11.140
you're outdoors under open sky.

00:23:11.140 --> 00:23:13.690
So GPS works like this.

00:23:13.690 --> 00:23:16.240
It sends a code
from a satellite,

00:23:16.240 --> 00:23:19.580
and the code encodes the
time at the satellite.

00:23:19.580 --> 00:23:23.260
Then that travels to you through
space and arrives at you.

00:23:23.260 --> 00:23:25.870
And your GPS receiver
will compare that time

00:23:25.870 --> 00:23:27.160
with the time in its clock.

00:23:27.160 --> 00:23:30.550
The difference between those two
tells you how far you are away.

00:23:30.550 --> 00:23:33.100
It's kind of like you
have a tape measure, where

00:23:33.100 --> 00:23:35.214
one end's at the satellite.

00:23:37.820 --> 00:23:39.530
And you're holding the spool.

00:23:39.530 --> 00:23:41.270
At any moment, you
can look down and read

00:23:41.270 --> 00:23:43.478
a number, which is the
difference in these two times.

00:23:43.478 --> 00:23:46.920
If you move further away,
you read a bigger number.

00:23:46.920 --> 00:23:51.200
If you move a little bit closer,
you read a smaller number.

00:23:51.200 --> 00:23:54.060
But now the actual GPS tape
measure's kind of special.

00:23:54.060 --> 00:23:56.420
First of all, it's really long.

00:23:56.420 --> 00:24:02.120
Secondly, the tick marks
occur only every 300 meters

00:24:02.120 --> 00:24:05.150
because these bits
of the code occur

00:24:05.150 --> 00:24:06.680
at a rate of one microsecond.

00:24:06.680 --> 00:24:10.650
So 1 microsecond times the speed
of light is about 300 meters.

00:24:10.650 --> 00:24:12.920
So this is like a
tape measure where

00:24:12.920 --> 00:24:14.750
instead of having all
these inches on here,

00:24:14.750 --> 00:24:17.930
you only have a mark
every 300 meters.

00:24:17.930 --> 00:24:20.490
And your GPS
receiver essentially

00:24:20.490 --> 00:24:22.370
interpolates
between those marks,

00:24:22.370 --> 00:24:25.680
and there's your
five-meter accuracy.

00:24:25.680 --> 00:24:26.600
OK.

00:24:26.600 --> 00:24:28.160
But there's more
to it than that,

00:24:28.160 --> 00:24:31.250
because how does that
code get through space

00:24:31.250 --> 00:24:32.130
in the first place?

00:24:32.130 --> 00:24:36.680
Well, it's carried on a
carrier wave, a radio wave,

00:24:36.680 --> 00:24:38.870
which for GPS has
a wavelength that

00:24:38.870 --> 00:24:41.960
is less than 20 centimeters.

00:24:41.960 --> 00:24:44.780
And your GPS
receiver can measure

00:24:44.780 --> 00:24:46.250
where you are on this wave.

00:24:46.250 --> 00:24:47.750
And as long as it
keeps tracking it,

00:24:47.750 --> 00:24:53.420
it can measure relative
motion with great precision.

00:24:53.420 --> 00:24:56.690
And this is because the
receiver will measure the phase,

00:24:56.690 --> 00:24:59.420
and then as you move,
that phase will change.

00:24:59.420 --> 00:25:02.330
But now what about getting
your absolute location?

00:25:02.330 --> 00:25:06.320
The trouble with the carrier
phase ruler, if you like,

00:25:06.320 --> 00:25:08.840
is that it's kind
of like a ruler

00:25:08.840 --> 00:25:11.330
with very precise markings
on it but no numbers

00:25:11.330 --> 00:25:14.840
at all, because one wavelength
looks just like the next.

00:25:14.840 --> 00:25:16.940
So your receiver can
tell you the phase

00:25:16.940 --> 00:25:18.770
of the wave you're on,
but it doesn't know

00:25:18.770 --> 00:25:21.450
are you green dot
or the red dot?

00:25:21.450 --> 00:25:22.860
So how do you
solve that problem?

00:25:22.860 --> 00:25:26.210
Well, for that, you need to
introduce a new concept, which

00:25:26.210 --> 00:25:28.880
is GPS reference stations.

00:25:28.880 --> 00:25:32.690
So these are GPS receivers
at fixed sites measuring

00:25:32.690 --> 00:25:35.030
the same thing at the same time.

00:25:35.030 --> 00:25:37.310
They communicate
that data to you.

00:25:37.310 --> 00:25:40.310
With well-known algorithms,
you can combine this data.

00:25:40.310 --> 00:25:41.990
And over some
period of time, you

00:25:41.990 --> 00:25:45.230
can work out where you are
relative to the reference

00:25:45.230 --> 00:25:47.900
station with great precision,
with this carrier phase

00:25:47.900 --> 00:25:48.587
precision.

00:25:48.587 --> 00:25:50.420
Now you know where the
reference station is.

00:25:50.420 --> 00:25:53.870
So now you know where you
are with great precision.

00:25:53.870 --> 00:25:55.800
So this concept is not new.

00:25:55.800 --> 00:25:58.580
This has been in
commercial GPS receivers

00:25:58.580 --> 00:26:01.340
since the 1980s for surveying.

00:26:01.340 --> 00:26:05.660
Hence our little surveyor
there holding the GPS antenna

00:26:05.660 --> 00:26:06.800
on the stick.

00:26:06.800 --> 00:26:09.890
What is new is the availability
of these carrier phase

00:26:09.890 --> 00:26:15.890
measurements from phones and
dual-frequency measurements

00:26:15.890 --> 00:26:17.120
in phones.

00:26:17.120 --> 00:26:19.580
Right now all of
your smartphones,

00:26:19.580 --> 00:26:23.060
all smartphones everywhere,
have GPS or GNSS

00:26:23.060 --> 00:26:25.190
on one frequency band only.

00:26:25.190 --> 00:26:26.600
It's known as L1.

00:26:26.600 --> 00:26:28.910
But there's a new
frequency in town.

00:26:28.910 --> 00:26:30.290
It's called L5.

00:26:30.290 --> 00:26:33.890
And it's supported by all these
GNSS systems, GPS, Galileo,

00:26:33.890 --> 00:26:37.160
BeiDou, QZSS, and IRNSS.

00:26:37.160 --> 00:26:39.920
And the availability
of a second frequency

00:26:39.920 --> 00:26:43.640
means that you get much faster
convergence to carrier phase

00:26:43.640 --> 00:26:46.730
accuracy if you're doing
this kind of procedure.

00:26:46.730 --> 00:26:47.640
And why?

00:26:47.640 --> 00:26:49.760
Well, we just went
through the ambiguity

00:26:49.760 --> 00:26:51.810
that you have on a single wave.

00:26:51.810 --> 00:26:54.350
Well, now look what happens
if you introduce a second wave

00:26:54.350 --> 00:26:56.270
at a different frequency.

00:26:56.270 --> 00:26:59.900
Immediately you can disambiguate
because you could not

00:26:59.900 --> 00:27:04.425
have the same phase on
that second wave on both

00:27:04.425 --> 00:27:05.300
of those wavelengths.

00:27:05.300 --> 00:27:07.091
You could not be on
the red dot if you were

00:27:07.091 --> 00:27:10.070
at the peak of the red wave.

00:27:10.070 --> 00:27:12.050
And so you can
disambiguate and get

00:27:12.050 --> 00:27:15.470
much faster convergence
to the very high accuracy

00:27:15.470 --> 00:27:17.120
that you want.

00:27:17.120 --> 00:27:18.870
All right, so what
about hardware?

00:27:18.870 --> 00:27:21.320
Well, in the last few
months, several companies

00:27:21.320 --> 00:27:26.510
that produce consumer GPS chips
have announced the availability

00:27:26.510 --> 00:27:29.810
of dual-frequency
L1, L5 GPS chips,

00:27:29.810 --> 00:27:32.810
both for the automobile market
and for the phone market.

00:27:32.810 --> 00:27:39.270
And these chips are now being
designed into cars and phones.

00:27:39.270 --> 00:27:41.430
Now let's talk about the
measurements themselves

00:27:41.430 --> 00:27:42.860
and the APIs.

00:27:42.860 --> 00:27:47.880
The phone must support
the GNSS Measurements API.

00:27:47.880 --> 00:27:52.080
And your app is going to need
access find location permission

00:27:52.080 --> 00:27:53.580
and location needs to be on.

00:27:53.580 --> 00:27:56.760
So these are the
basic requirements.

00:27:56.760 --> 00:27:59.670
So how do you know if a
particular phone supports

00:27:59.670 --> 00:28:00.520
these measurements?

00:28:00.520 --> 00:28:02.978
Well, at a high level, you can
just go to a website that we

00:28:02.978 --> 00:28:05.830
maintain, g.co/gnsstools.

00:28:05.830 --> 00:28:08.460
It's part of the
Android Developers site.

00:28:08.460 --> 00:28:11.580
And there's just
a table there that

00:28:11.580 --> 00:28:14.430
lists phones that support
the GNSS measurements

00:28:14.430 --> 00:28:16.830
and also which
characteristics they support.

00:28:16.830 --> 00:28:19.080
So it'll tell you which phone
support the measurements

00:28:19.080 --> 00:28:22.560
and which of those support the
carrier phase measurements.

00:28:22.560 --> 00:28:25.080
Programmatically, you
do this as follows.

00:28:25.080 --> 00:28:27.330
You need a method
onStatusChanged.

00:28:27.330 --> 00:28:30.570
And it will return an
integer that tells you

00:28:30.570 --> 00:28:33.600
the capability of the phone,
either if the phone just

00:28:33.600 --> 00:28:35.670
does not support the
measurements at all,

00:28:35.670 --> 00:28:38.010
or if they support it,
but location is off,

00:28:38.010 --> 00:28:40.280
or if they support it,
and location is on.

00:28:40.280 --> 00:28:43.360
In that last case,
you're good to go.

00:28:43.360 --> 00:28:47.310
So now let's get into
some details of the APIs.

00:28:47.310 --> 00:28:50.130
The most relevant methods for
what we're talking about here

00:28:50.130 --> 00:28:51.170
are the following three.

00:28:51.170 --> 00:28:53.580
There's getConstellationType,
which tells you

00:28:53.580 --> 00:28:56.640
which of the different
GNSS constellations

00:28:56.640 --> 00:28:59.010
a particular
satellite belongs to.

00:28:59.010 --> 00:29:01.410
There's
getCarrierFrequencyHertz,

00:29:01.410 --> 00:29:04.380
which tells you whether you're
on the L1 or the L5 band

00:29:04.380 --> 00:29:05.880
for a particular signal.

00:29:05.880 --> 00:29:07.560
And then most
importantly, there's

00:29:07.560 --> 00:29:09.870
getAccumulatedDeltaRangeMeters,
which

00:29:09.870 --> 00:29:15.000
is how far along that wave
the receiver has tracked you

00:29:15.000 --> 00:29:17.869
since it began
tracking the signal.

00:29:17.869 --> 00:29:20.160
And then there's something
else that I need to explain,

00:29:20.160 --> 00:29:21.990
which is duty cycling.

00:29:21.990 --> 00:29:25.230
So right now, when you're
navigating with your phone

00:29:25.230 --> 00:29:27.210
and you see the blue
dot moving along,

00:29:27.210 --> 00:29:30.390
for example, maybe when you
navigated here this morning,

00:29:30.390 --> 00:29:33.270
you might think that the
GPS is on continuously.

00:29:33.270 --> 00:29:34.860
And it's actually not.

00:29:34.860 --> 00:29:39.570
What's happening in the phone
is that GPS will, by default, be

00:29:39.570 --> 00:29:42.630
on for a fraction of a second
and then off for the remaining

00:29:42.630 --> 00:29:44.790
fraction of a second
and then repeat.

00:29:44.790 --> 00:29:46.716
And this is to save battery.

00:29:46.716 --> 00:29:48.840
And so you perceive that
the GPS is on all the time

00:29:48.840 --> 00:29:51.280
because the blue dot will
move along continually.

00:29:51.280 --> 00:29:53.400
But actually, it's duty
cycling internally.

00:29:53.400 --> 00:29:55.110
Now, for this carrier
phase processing,

00:29:55.110 --> 00:29:57.630
you have to continually
track the carrier wave

00:29:57.630 --> 00:30:00.030
because, remember, the
carrier wave is the ruler

00:30:00.030 --> 00:30:01.180
with no numbers on it.

00:30:01.180 --> 00:30:04.270
So if the GPS was on and your
receiver measured your phase

00:30:04.270 --> 00:30:06.270
and you get the data from
the reference station,

00:30:06.270 --> 00:30:07.800
you'd start processing.

00:30:07.800 --> 00:30:10.540
If the GPS then goes off
for a fraction of a second,

00:30:10.540 --> 00:30:12.300
well, now you've
lost where you were.

00:30:12.300 --> 00:30:13.080
It'll start again.

00:30:13.080 --> 00:30:13.980
You're re-acquire.

00:30:13.980 --> 00:30:16.260
You'll be a different
phase on the reacquisition.

00:30:16.260 --> 00:30:17.350
You'll start again.

00:30:17.350 --> 00:30:19.800
Well, you'll never solve the
problem, [INAUDIBLE],, right?

00:30:19.800 --> 00:30:21.801
You need the tape
measure to stay out,

00:30:21.801 --> 00:30:22.800
and you need to process.

00:30:22.800 --> 00:30:25.050
And to do that, you need
to disable duty cycling.

00:30:25.050 --> 00:30:27.937
And you can do that in Android
P with a developer option, which

00:30:27.937 --> 00:30:29.520
I'll talk about some
more in a minute.

00:30:32.630 --> 00:30:35.180
So now some details of the API.

00:30:35.180 --> 00:30:36.650
What I've shown
here on the right

00:30:36.650 --> 00:30:40.130
is a screenshot of an
application that we've put out.

00:30:40.130 --> 00:30:42.020
It's called GNSS Logger.

00:30:42.020 --> 00:30:45.080
And this is enables you to
log the raw measurements

00:30:45.080 --> 00:30:46.610
in the phone.

00:30:46.610 --> 00:30:49.180
Now, the nice thing about this
app, it's a reference app.

00:30:49.180 --> 00:30:53.660
The code is open source and
available to you on GitHub.

00:30:53.660 --> 00:30:55.700
So when you build
your app, please,

00:30:55.700 --> 00:30:58.050
you could make use of our code.

00:30:58.050 --> 00:31:00.980
And when you do build an app
that needs raw measurement,

00:31:00.980 --> 00:31:04.100
you will need the Android
Location Manager API

00:31:04.100 --> 00:31:07.970
with the method registerGNSSMeas
urementsCallback.

00:31:07.970 --> 00:31:11.570
And this method requires you to
pass a GNSS measurements event

00:31:11.570 --> 00:31:14.530
callback, shown here.

00:31:14.530 --> 00:31:16.580
You construct this
callback and then override

00:31:16.580 --> 00:31:20.030
the method onStatusChanged.

00:31:20.030 --> 00:31:22.040
And that will give
you the integer status

00:31:22.040 --> 00:31:25.010
that we discussed to tell you
if measurements are supported.

00:31:25.010 --> 00:31:28.790
If they are, you then
override the method

00:31:28.790 --> 00:31:31.190
onGNSSMeasurementsReceived.

00:31:31.190 --> 00:31:34.490
And this allows you to
receive a GNSS measurement

00:31:34.490 --> 00:31:37.790
event every epoch, for
example, every second.

00:31:37.790 --> 00:31:41.090
And this event
gives you the values

00:31:41.090 --> 00:31:43.250
we've been talking about,
constellation type,

00:31:43.250 --> 00:31:48.610
carrier frequency, and
accumulated delta range.

00:31:48.610 --> 00:31:50.930
Now for duty cycling,
that's a developer option,

00:31:50.930 --> 00:31:54.550
so you access that through the
Developer Page on your phone,

00:31:54.550 --> 00:31:59.200
as you see there on
P. And this allows you

00:31:59.200 --> 00:32:01.070
to disable the duty cycling.

00:32:01.070 --> 00:32:03.880
Now, keep in mind, this
introduces a trade-off

00:32:03.880 --> 00:32:06.730
between getting the continuous
measurements and battery life.

00:32:06.730 --> 00:32:08.560
There will be an
impact on battery life.

00:32:08.560 --> 00:32:09.290
How much?

00:32:09.290 --> 00:32:12.180
Well, even when GPS
is on continually,

00:32:12.180 --> 00:32:16.120
it'll use less than 20% of
the power that screen on uses.

00:32:16.120 --> 00:32:19.060
So that gives you a
feel for the magnitude.

00:32:19.060 --> 00:32:21.280
Now, this is a developer
option precisely

00:32:21.280 --> 00:32:24.970
because it's a trade-off
in battery life.

00:32:24.970 --> 00:32:28.240
And we're very concerned
about maximizing battery life.

00:32:28.240 --> 00:32:30.670
But if you and we
together can prove

00:32:30.670 --> 00:32:32.890
that there's value in this
option and people want it,

00:32:32.890 --> 00:32:36.370
then it will be upgraded
to a fully supported API

00:32:36.370 --> 00:32:38.720
in the future.

00:32:38.720 --> 00:32:42.580
So here's a block diagram that
shows the basic architecture

00:32:42.580 --> 00:32:45.395
that we expect if you implement
an app for high accuracy.

00:32:45.395 --> 00:32:48.310
Down on the bottom of the
block diagram on the left,

00:32:48.310 --> 00:32:51.210
you've got the GPS, GNSS chip.

00:32:51.210 --> 00:32:53.340
The GNSS measurements
come up through the APIs,

00:32:53.340 --> 00:32:54.340
as we've just described.

00:32:54.340 --> 00:32:58.870
And then your app lives at the
top in the application layer.

00:32:58.870 --> 00:33:01.600
You're going to need access
to a reference network

00:33:01.600 --> 00:33:05.110
to get the data that the
reference stations are

00:33:05.110 --> 00:33:06.010
tracking.

00:33:06.010 --> 00:33:08.590
There are publicly available
reference networks.

00:33:08.590 --> 00:33:11.860
I've listed one down at the
bottom, the International GNSS

00:33:11.860 --> 00:33:14.260
Service, igs.org.

00:33:14.260 --> 00:33:16.420
And you can get
data from them free.

00:33:16.420 --> 00:33:19.240
Then you need to process that
data in some kind of position

00:33:19.240 --> 00:33:20.040
library.

00:33:20.040 --> 00:33:23.230
And that does all this
carrier phase processing.

00:33:23.230 --> 00:33:25.660
And that too is available
as open source code.

00:33:25.660 --> 00:33:27.340
There's another
example down there.

00:33:27.340 --> 00:33:31.540
Rtklib.org has an
open source package

00:33:31.540 --> 00:33:33.430
for precise positioning.

00:33:33.430 --> 00:33:35.840
And then you're good to go.

00:33:35.840 --> 00:33:38.360
Now, I mentioned that
dual frequency gives you

00:33:38.360 --> 00:33:40.960
a much faster convergence
to the high accuracy.

00:33:40.960 --> 00:33:43.210
But you don't have to wait
until the dual frequency

00:33:43.210 --> 00:33:43.876
phones come out.

00:33:43.876 --> 00:33:46.176
You can start doing this
with single-frequency phones.

00:33:46.176 --> 00:33:48.550
And here's an example of
someone who's already done that.

00:33:48.550 --> 00:33:52.390
This is an app created by
the French Space Agency.

00:33:52.390 --> 00:33:55.930
And they're doing exactly
what we show on the block

00:33:55.930 --> 00:33:56.860
diagram on the left.

00:33:56.860 --> 00:33:59.800
And they're achieving
sub-meter to accuracy

00:33:59.800 --> 00:34:04.350
after a few minutes
of convergence.

00:34:04.350 --> 00:34:06.920
Here's some more
external analysis that's

00:34:06.920 --> 00:34:08.280
been done in a similar way.

00:34:08.280 --> 00:34:10.429
This is from a paper
called "Positioning

00:34:10.429 --> 00:34:12.350
With Android GNSS."

00:34:12.350 --> 00:34:14.360
This is using one of
those chips that I

00:34:14.360 --> 00:34:17.270
showed you, the chip that
goes in cell phones that

00:34:17.270 --> 00:34:18.980
does dual frequency.

00:34:18.980 --> 00:34:22.100
And what's been shown here
is the cumulative results

00:34:22.100 --> 00:34:24.060
over many different
starts of the GPS.

00:34:24.060 --> 00:34:26.210
And what you see is
that most of the time

00:34:26.210 --> 00:34:28.730
the accuracy is
better than a meter.

00:34:28.730 --> 00:34:31.520
You see that on the vertical
axis, which is 0 to 1 meters.

00:34:31.520 --> 00:34:34.610
And accuracy gets to better than
a meter in less than one minute

00:34:34.610 --> 00:34:37.460
and then continues to converge
as long as the phone continues

00:34:37.460 --> 00:34:41.750
to track that carrier
phase continuously.

00:34:41.750 --> 00:34:44.730
Here's another similar
but different paper.

00:34:44.730 --> 00:34:47.639
This is using one of the
chips that's meant for cars.

00:34:47.639 --> 00:34:50.351
And so it was tested in a
car, driving around that track

00:34:50.351 --> 00:34:50.850
there.

00:34:50.850 --> 00:34:52.469
And what the plot
here is showing

00:34:52.469 --> 00:34:55.350
is the accuracy after
the initial convergence

00:34:55.350 --> 00:34:56.489
while the car was driving.

00:34:56.489 --> 00:35:01.350
So you see with GNSS alone,
the accuracy is 1 to 2 meters.

00:35:01.350 --> 00:35:03.750
And with this carrier
phase processing,

00:35:03.750 --> 00:35:07.900
it's at a couple of decimeters.

00:35:07.900 --> 00:35:11.360
So for you to build this,
what are you going to need?

00:35:11.360 --> 00:35:14.320
Well, of course you need the
device location to be enabled,

00:35:14.320 --> 00:35:16.270
and your app has to have
location permission.

00:35:16.270 --> 00:35:18.370
So that's going to
come from the user.

00:35:18.370 --> 00:35:21.100
You need the basic
GNSS measurements.

00:35:21.100 --> 00:35:23.699
That's been available
since Android N.

00:35:23.699 --> 00:35:25.240
You also need this
continuous carrier

00:35:25.240 --> 00:35:28.030
phase I've been talking about,
and that's available in P

00:35:28.030 --> 00:35:30.190
with the developer option.

00:35:30.190 --> 00:35:33.070
It would be nice to have dual
frequency for fast convergence,

00:35:33.070 --> 00:35:34.510
and that's coming soon.

00:35:34.510 --> 00:35:36.850
You need a reference network,
such as the one I already

00:35:36.850 --> 00:35:37.590
mentioned.

00:35:37.590 --> 00:35:40.120
There are also commercial
reference networks

00:35:40.120 --> 00:35:42.280
out there and commercially
available software

00:35:42.280 --> 00:35:43.360
to do the same thing.

00:35:43.360 --> 00:35:45.234
But I recommend you
start with the free stuff

00:35:45.234 --> 00:35:46.250
and go from there.

00:35:46.250 --> 00:35:48.090
And then finally,
there's the app from you.

00:35:50.620 --> 00:35:54.520
So in summary, everything
we've been showing you here,

00:35:54.520 --> 00:35:57.160
we have indoor and
outdoor technology that's

00:35:57.160 --> 00:35:59.719
been evolving kind of in
parallel, in each case,

00:35:59.719 --> 00:36:00.760
we have a new technology.

00:36:00.760 --> 00:36:02.800
And Android P gives you
something to access it.

00:36:02.800 --> 00:36:04.480
Let's talk about indoors again.

00:36:04.480 --> 00:36:08.650
The new technology is Wi-Fi
Round Trip Time and Round Trip

00:36:08.650 --> 00:36:10.960
Time enabled access point.

00:36:10.960 --> 00:36:14.900
We give you the public API
to access these measurements.

00:36:14.900 --> 00:36:17.610
But you need access
point infrastructure.

00:36:17.610 --> 00:36:20.830
Now, this is where some of
you can do this this year.

00:36:20.830 --> 00:36:25.060
Because if you have a customer
who owns or controls a venue,

00:36:25.060 --> 00:36:27.270
they can upgrade their
access point, sometimes just

00:36:27.270 --> 00:36:28.480
a firmware upgrade.

00:36:28.480 --> 00:36:30.400
And then you have
the infrastructure.

00:36:30.400 --> 00:36:32.500
Android P comes out
later this year.

00:36:32.500 --> 00:36:35.380
And you can implement
something like what Roy just

00:36:35.380 --> 00:36:39.580
demoed and have indoor
navigation or many other apps.

00:36:39.580 --> 00:36:41.710
For example, someone
goes in a store.

00:36:41.710 --> 00:36:42.890
Where's the milk?

00:36:42.890 --> 00:36:46.000
You can make the world a
better place for all of us

00:36:46.000 --> 00:36:49.420
by saving us from the tyranny
of having to ask directions

00:36:49.420 --> 00:36:50.080
from strangers.

00:36:50.080 --> 00:36:51.460
[APPLAUSE]

00:36:51.460 --> 00:36:51.960
OK.

00:36:57.020 --> 00:37:01.190
And if you're not one of those
people who has access to this

00:37:01.190 --> 00:37:04.760
now, in a few years the
infrastructure will naturally

00:37:04.760 --> 00:37:07.460
evolve as access points
upgrade to Round Trip Time,

00:37:07.460 --> 00:37:10.250
and this will be available
from Fused Location Provider,

00:37:10.250 --> 00:37:11.600
as Roy said.

00:37:11.600 --> 00:37:14.640
Now, outdoors, OK, for
this carrier phase process,

00:37:14.640 --> 00:37:17.810
it's not just outdoors,
but outdoors with open sky.

00:37:17.810 --> 00:37:18.770
And what do you need?

00:37:18.770 --> 00:37:20.810
Dual frequency and
continuous carrier phase.

00:37:20.810 --> 00:37:22.970
And we give you the API
and the developer option

00:37:22.970 --> 00:37:24.470
to make use of that.

00:37:24.470 --> 00:37:27.330
You will need reference
station access, as I mentioned.

00:37:27.330 --> 00:37:28.910
And then applica--
well, what can you

00:37:28.910 --> 00:37:30.280
do outdoors with open sky?

00:37:30.280 --> 00:37:32.810
Well, we already mentioned
the traffic example.

00:37:32.810 --> 00:37:34.670
And there's many
other examples that

00:37:34.670 --> 00:37:37.681
readily come to mind where
existing GPS accuracy doesn't

00:37:37.681 --> 00:37:38.180
cut it.

00:37:38.180 --> 00:37:40.685
For example, geocaching, where
people go look for treasures,

00:37:40.685 --> 00:37:43.860
it would be nice to
have one-meter accuracy.

00:37:43.860 --> 00:37:46.340
Precision sports monitoring--
imagine a snowboarder

00:37:46.340 --> 00:37:49.100
who wants to measure her tracks
very precisely after the fact.

00:37:49.100 --> 00:37:50.460
Five meter's not good enough.

00:37:50.460 --> 00:37:51.740
One meter would be great.

00:37:51.740 --> 00:37:53.540
Speaking of sports,
there are more and more

00:37:53.540 --> 00:37:56.510
drone apps where you can follow
me, and a drone will fly along

00:37:56.510 --> 00:37:57.320
and video you.

00:37:57.320 --> 00:37:59.278
Well, it would be nice
if it videos you and not

00:37:59.278 --> 00:38:00.680
the person next door to you.

00:38:00.680 --> 00:38:03.290
And I'm sure there
are hundreds of apps,

00:38:03.290 --> 00:38:05.280
and you're probably
thinking of some right now,

00:38:05.280 --> 00:38:06.404
and that's the whole point.

00:38:06.404 --> 00:38:09.170
We want you to do that
and you and us together

00:38:09.170 --> 00:38:13.220
bend the arc of technology
history closer to the present.

00:38:13.220 --> 00:38:15.830
And I'm really looking forward
to next year to see some of you

00:38:15.830 --> 00:38:18.317
back here and see
what you've created.

00:38:18.317 --> 00:38:20.900
And so finally, I want to leave
you with a couple of pointers.

00:38:20.900 --> 00:38:23.960
When you build location apps,
please build great location

00:38:23.960 --> 00:38:24.860
apps.

00:38:24.860 --> 00:38:26.330
You must have user trust.

00:38:26.330 --> 00:38:29.720
Please provide the user with
transparency and control.

00:38:29.720 --> 00:38:32.690
You're going to have to ask for
location permissions for this.

00:38:32.690 --> 00:38:36.740
Explain to them what you're
doing, how it benefits them.

00:38:36.740 --> 00:38:39.800
When things go wrong, make
your app recover gracefully.

00:38:39.800 --> 00:38:42.500
If these measurements are
unavailable for some moment

00:38:42.500 --> 00:38:45.440
or something goes wrong, you
can fall back to Fused Location

00:38:45.440 --> 00:38:46.580
Provider location.

00:38:46.580 --> 00:38:48.000
So think about that.

00:38:48.000 --> 00:38:50.420
And finally, respect the
battery life trade-offs

00:38:50.420 --> 00:38:52.640
that we discussed.

00:38:52.640 --> 00:38:55.340
So I must remind you to
fill out your surveys,

00:38:55.340 --> 00:38:58.430
please, at that site.

00:38:58.430 --> 00:39:01.340
And as I mentioned, we'll be
available outside the door

00:39:01.340 --> 00:39:02.900
here for any questions.

00:39:02.900 --> 00:39:05.576
So from all three
of us, thank you.

00:39:05.576 --> 00:39:09.316
[MUSIC PLAYING]

