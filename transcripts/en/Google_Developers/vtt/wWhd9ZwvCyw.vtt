WEBVTT
Kind: captions
Language: en

00:00:03.467 --> 00:00:04.801
Fried: Good afternoon.

00:00:04.801 --> 00:00:07.367
My name is Ben Fried.
I'm Google's CIO,

00:00:07.367 --> 00:00:09.234
and I'm here with
some of my colleagues

00:00:09.234 --> 00:00:10.534
from Google Corporate
Engineering

00:00:10.534 --> 00:00:13.033
to talk to you about how
we write enterprise apps

00:00:13.033 --> 00:00:15.300
for Google on App Engine.

00:00:15.300 --> 00:00:18.133
Now, at some point in the
evolution of this slide deck

00:00:18.133 --> 00:00:20.167
of this presentation,

00:00:20.167 --> 00:00:22.133
we realized that a better name
for this might have been

00:00:22.133 --> 00:00:24.968
"Enterprise Design Patterns
for App Engine".

00:00:24.968 --> 00:00:27.100
Unfortunately, that stroke
of genius came to us

00:00:27.100 --> 00:00:31.067
after the print deadline for the
I/O schedule had already passed,

00:00:31.067 --> 00:00:36.367
so we have the slide deck title
that you see in front of you.

00:00:36.367 --> 00:00:39.300
Now, before I go any further,
I thought it might be good

00:00:39.300 --> 00:00:42.100
to get to know a little bit
about all of you.

00:00:42.100 --> 00:00:45.033
How many of you are here
because you're writing apps

00:00:45.033 --> 00:00:48.968
for App Engine, for enterprise
purposes of some sort?

00:00:48.968 --> 00:00:50.334
Okay, cool.

00:00:50.334 --> 00:00:54.000
How many of you are here
because you'd like to write

00:00:54.000 --> 00:00:57.000
enterprise apps on App Engine
and you think maybe we have

00:00:57.000 --> 00:00:58.834
something to share with you?

00:00:58.834 --> 00:01:00.534
All right, awesome.

00:01:00.534 --> 00:01:04.167
How many of you would just like
to write apps for App Engine?

00:01:04.167 --> 00:01:07.701
How many of you are here
by mistake?

00:01:07.701 --> 00:01:10.033
Okay, all right,
well, you know,

00:01:10.033 --> 00:01:11.934
they say that honesty
is the foundation

00:01:11.934 --> 00:01:13.567
of any strong relationship,

00:01:13.567 --> 00:01:17.701
and I'm glad that we have
that to begin with.

00:01:17.701 --> 00:01:19.300
So to give you
a little road map

00:01:19.300 --> 00:01:21.133
for what we're going
to be talking about,

00:01:21.133 --> 00:01:24.567
I'm going to do some kind of
high level CIO-ish stuff

00:01:24.567 --> 00:01:26.901
about what I've learned
and what we've learned

00:01:26.901 --> 00:01:29.868
as a result of using App Engine
to solve Google's own problems.

00:01:29.868 --> 00:01:32.467
Then Eric and the Justins
are going to show you

00:01:32.467 --> 00:01:35.734
actual design patterns
that they've developed

00:01:35.734 --> 00:01:37.300
and that other engineers
who we've worked with

00:01:37.300 --> 00:01:38.934
have developed to solve
Google's problems

00:01:38.934 --> 00:01:40.467
and show you
a bunch of actual code,

00:01:40.467 --> 00:01:45.701
and I'll close it up
and we'll take Q&amp;A at the end.

00:01:45.701 --> 00:01:48.367
So, you know, we run Google
on App Engine,

00:01:48.367 --> 00:01:50.234
like the slide says.

00:01:50.234 --> 00:01:52.634
Over two years ago,
two and a half years ago,

00:01:52.634 --> 00:01:54.467
we made the decision
that App Engine

00:01:54.467 --> 00:01:57.868
would be our first choice
for the hosting platform

00:01:57.868 --> 00:02:00.300
for the apps that we write
to run the business of Google,

00:02:00.300 --> 00:02:02.067
and over the last
two and a half years,

00:02:02.067 --> 00:02:03.400
dozens of engineers

00:02:03.400 --> 00:02:05.934
have written hundreds
and hundreds of applications,

00:02:05.934 --> 00:02:10.167
for every conceivable purpose
inside the company.

00:02:10.167 --> 00:02:11.234
And the variety,
the scope of this stuff,

00:02:11.234 --> 00:02:12.634
is pretty incredible.

00:02:12.634 --> 00:02:17.167
It ranges from things like
managing our fleet of Macs,

00:02:17.167 --> 00:02:19.234
doing software update,
operating system update,

00:02:19.234 --> 00:02:21.801
and patching and pushing
to these Macs--I'm told

00:02:21.801 --> 00:02:24.534
one of the largest enterprise
fleets of Macs in the world--

00:02:24.534 --> 00:02:28.801
to running the system
that does 360-degree employee

00:02:28.801 --> 00:02:32.234
performance review
and promotion management,

00:02:32.234 --> 00:02:36.467
to doing online
scheduling of classes,

00:02:36.467 --> 00:02:38.567
to the software
that our recruiters use

00:02:38.567 --> 00:02:40.701
to schedule interviews
for job candidates,

00:02:40.701 --> 00:02:42.701
software used
by our lawyers.

00:02:42.701 --> 00:02:44.200
You know, in every corner
of Google,

00:02:44.200 --> 00:02:45.734
there's an app running
on App Engine,

00:02:45.734 --> 00:02:48.334
serving some important
business purpose.

00:02:48.334 --> 00:02:49.934
As a result of all
that experience,

00:02:49.934 --> 00:02:54.901
we've learned an awful lot
about App Engine,

00:02:54.901 --> 00:02:57.234
and hopefully we have some
useful things to share with you

00:02:57.234 --> 00:03:00.434
about how to actually make App
Engine work for your business

00:03:00.434 --> 00:03:01.901
in interesting ways,

00:03:01.901 --> 00:03:04.934
for solving enterprise problems
in interesting ways.

00:03:04.934 --> 00:03:07.834
Now, you know, so, based on
this audience survey,

00:03:07.834 --> 00:03:11.567
I assume that many of you,
hopefully most, are kind of

00:03:11.567 --> 00:03:14.801
fellow travelers in the cause of
App Engine for the enterprise,

00:03:14.801 --> 00:03:17.200
and my goal over
the next three slides

00:03:17.200 --> 00:03:19.133
is to give you a few really
good arguments

00:03:19.133 --> 00:03:22.000
for bringing App Engine in
for solving enterprise problems

00:03:22.000 --> 00:03:25.367
in your organization.

00:03:25.367 --> 00:03:27.968
And you know,
as we thought about it,

00:03:27.968 --> 00:03:29.467
as we thought about it

00:03:29.467 --> 00:03:33.467
and over two plus years
of having actually lived this,

00:03:33.467 --> 00:03:35.167
it's interesting
what we've observed,

00:03:35.167 --> 00:03:37.901
which is that the reasons
why App Engine

00:03:37.901 --> 00:03:41.501
is such a great choice
and such an obvious choice

00:03:41.501 --> 00:03:45.100
for building Internet-based
services, you know,

00:03:45.100 --> 00:03:46.501
consumer Internet-based
services,

00:03:46.501 --> 00:03:48.501
also actually have
tremendous applicability.

00:03:48.501 --> 00:03:49.934
Those reasons have
tremendous applicability

00:03:49.934 --> 00:03:52.901
inside the enterprise as well,
although it was often

00:03:52.901 --> 00:03:55.567
not obvious to us at the time
when we went down this path,

00:03:55.567 --> 00:03:58.234
that the arguments for doing,
why App Engine,

00:03:58.234 --> 00:03:59.501
and why the Cloud hosting
is so great

00:03:59.501 --> 00:04:00.767
for consumer services,

00:04:00.767 --> 00:04:04.434
would be just as powerful
for the enterprise.

00:04:04.434 --> 00:04:07.334
So the first one of these
reasons that came to us

00:04:07.334 --> 00:04:08.968
was this idea
that App Engine apps,

00:04:08.968 --> 00:04:12.501
you can access and use
from absolutely anywhere.

00:04:12.501 --> 00:04:13.601
Right?

00:04:13.601 --> 00:04:15.167
And why this is
such a killer feature

00:04:15.167 --> 00:04:17.734
for the enterprise
can become clearer

00:04:17.734 --> 00:04:20.367
when you think about the fact
that we're using App Engine

00:04:20.367 --> 00:04:22.100
to manage software
and operating system updates

00:04:22.100 --> 00:04:23.501
for our fleet of Macs, right?

00:04:23.501 --> 00:04:26.334
Well, as Sumdar mentioned
at the keynote today,

00:04:26.334 --> 00:04:29.133
most computers are laptops
these days, not desktops, right?

00:04:29.133 --> 00:04:32.133
And that means that they are
as likely to not be connected

00:04:32.133 --> 00:04:33.968
to our corporate network
as they are to be connected

00:04:33.968 --> 00:04:35.534
to our corporate network.

00:04:35.534 --> 00:04:37.367
And what's great about
App Engine is it means

00:04:37.367 --> 00:04:39.367
that we can reach
and patch these Macs

00:04:39.367 --> 00:04:40.601
no matter where they are.

00:04:40.601 --> 00:04:44.200
For Googlers who are at I/O,
or at an airport,

00:04:44.200 --> 00:04:45.767
or when they're at home,

00:04:45.767 --> 00:04:47.200
they still get the operating
system updates,

00:04:47.200 --> 00:04:48.567
and in fact
what we've noticed

00:04:48.567 --> 00:04:54.434
is that software updates happen
off our corporate network

00:04:54.434 --> 00:04:57.033
a tremendous
percentage of the time.

00:04:57.033 --> 00:04:59.100
Another--you know,
one of the truisms

00:04:59.100 --> 00:05:01.667
I think that--of modern
enterprise life

00:05:01.667 --> 00:05:05.133
is that this idea that--

00:05:05.133 --> 00:05:07.267
of a tightly controlled
corporate network

00:05:07.267 --> 00:05:10.968
that you give blanket access
to a large number of people to

00:05:10.968 --> 00:05:13.901
is kind of becoming antiquated
in the world of security threats

00:05:13.901 --> 00:05:15.567
and interesting
business partnerships

00:05:15.567 --> 00:05:17.534
that modern companies
all have, right?

00:05:17.534 --> 00:05:19.400
So, the great thing
about App Engine apps

00:05:19.400 --> 00:05:21.167
is you don't need a separate
remote access solution

00:05:21.167 --> 00:05:22.667
to make them available
to people.

00:05:22.667 --> 00:05:25.567
You also don't need to give
people a separate VPN

00:05:25.567 --> 00:05:28.501
or remote access technology
to use it,

00:05:28.501 --> 00:05:30.200
so you're not exposing
your corporate network.

00:05:30.200 --> 00:05:31.701
You're not exposing apps
other than the ones

00:05:31.701 --> 00:05:33.200
you might want to use
to App Engine.

00:05:33.200 --> 00:05:36.834
It's really, really nice
if you want to, for example,

00:05:36.834 --> 00:05:38.167
make a set of apps
only available

00:05:38.167 --> 00:05:39.300
to a contingent workforce.

00:05:39.300 --> 00:05:40.667
You can do that
without needing to expose

00:05:40.667 --> 00:05:42.434
your corporate network
in any way,

00:05:42.434 --> 00:05:43.834
and we've certainly seen
this to be a big,

00:05:43.834 --> 00:05:46.501
big benefit for us
as Google expands the nature

00:05:46.501 --> 00:05:48.901
of its business relationships.

00:05:48.901 --> 00:05:51.267
So accessing from anywhere,
a great advantage

00:05:51.267 --> 00:05:54.033
of using cloud-based platform
as a service,

00:05:54.033 --> 00:05:59.067
also, really, really cool and
important for the enterprise.

00:05:59.067 --> 00:06:00.901
I don't know why I chose
pink pigs here.

00:06:00.901 --> 00:06:04.534
But the...

00:06:04.534 --> 00:06:06.968
obviously scalability is
what App Engine and the Cloud

00:06:06.968 --> 00:06:08.200
is all about,
and this makes sense

00:06:08.200 --> 00:06:09.601
if you want to build a service
to be used by

00:06:09.601 --> 00:06:11.133
hundreds of millions of users.

00:06:11.133 --> 00:06:12.467
But as it turns out,

00:06:12.467 --> 00:06:14.234
in the enterprise,
if you think about it,

00:06:14.234 --> 00:06:16.567
we all have a whole bunch
of scaling problems as well.

00:06:16.567 --> 00:06:17.801
Now the form
that this often takes

00:06:17.801 --> 00:06:19.334
that many people can relate to
is that there's

00:06:19.334 --> 00:06:21.267
a whole bunch of apps
in the enterprise portfolio

00:06:21.267 --> 00:06:24.434
that have enormous
periodicity in their usage.

00:06:24.434 --> 00:06:26.067
An example
that I mentioned earlier

00:06:26.067 --> 00:06:27.868
is the performance management,

00:06:27.868 --> 00:06:29.701
the employee performance
review system, right?

00:06:29.701 --> 00:06:32.100
You know, it turns out that
like the five or ten minutes

00:06:32.100 --> 00:06:35.701
before the system closes
are the time when it has a load

00:06:35.701 --> 00:06:37.767
like a hundred times
the rest of the year, right?

00:06:37.767 --> 00:06:42.501
It's funny how some people are
deadline-motivated, I guess.

00:06:42.501 --> 00:06:45.901
Most people are
deadline-motivated, I guess.

00:06:45.901 --> 00:06:48.100
And who wants to have
to kind of build out

00:06:48.100 --> 00:06:50.601
or manage a hosting environment
at the capacity

00:06:50.601 --> 00:06:52.567
of that last five minutes
or ten minutes, right?

00:06:52.567 --> 00:06:56.968
You know, the sad reality of
the life of the IT professional

00:06:56.968 --> 00:06:58.767
is that it's when your apps
are under the most load

00:06:58.767 --> 00:07:00.267
and the busiest
and that we need them the most

00:07:00.267 --> 00:07:01.934
that we can least afford
to have them.

00:07:01.934 --> 00:07:06.767
You know, we suffer denial
of service from, you know,

00:07:06.767 --> 00:07:10.133
usage--you know, powerful usage
patterns within your company,

00:07:10.133 --> 00:07:13.000
and hosting on App Engine
gives you all that.

00:07:13.000 --> 00:07:14.534
But there's another
enterprise use case

00:07:14.534 --> 00:07:16.467
that's a little less obvious,
but one that we discovered,

00:07:16.467 --> 00:07:17.667
related to the first one
but different

00:07:17.667 --> 00:07:19.267
and very, very powerful.

00:07:19.267 --> 00:07:21.934
You know, inside the enterprise,
we often have this problem

00:07:21.934 --> 00:07:26.501
that you rarely want to build
a testing or QA infrastructure

00:07:26.501 --> 00:07:29.200
that is the same capacity as
your production infrastructure,

00:07:29.200 --> 00:07:31.133
right? It's just, that can be
a lot of money

00:07:31.133 --> 00:07:34.467
to spend on something
that you'll use for testing,

00:07:34.467 --> 00:07:35.868
as opposed to
actually in production.

00:07:35.868 --> 00:07:38.100
So all too often,
we only actually learn

00:07:38.100 --> 00:07:41.634
how our apps behave
in production...in production,

00:07:41.634 --> 00:07:43.367
which means we get
unpleasant surprises, right?

00:07:43.367 --> 00:07:45.367
And again,
it stems from this fact

00:07:45.367 --> 00:07:46.934
that you don't want to spend
the money on having a plant

00:07:46.934 --> 00:07:49.000
of equal or greater capacity
to production

00:07:49.000 --> 00:07:50.567
to understand
where all the needs

00:07:50.567 --> 00:07:53.167
are and the performance curves
of the code that you've written.

00:07:53.167 --> 00:07:57.067
With App Engine, you know,
it's brilliant, right?

00:07:57.067 --> 00:08:00.834
You just deploy a test instance,
throw as much synthetic load

00:08:00.834 --> 00:08:03.133
at that test instance
as you want--

00:08:03.133 --> 00:08:04.701
you know, 10 times,
100 times, 1000 times,

00:08:04.701 --> 00:08:06.133
whatever your expected
peak load is--

00:08:06.133 --> 00:08:07.601
observe how it behaves,

00:08:07.601 --> 00:08:09.901
and understand exactly
what you're going to be in for

00:08:09.901 --> 00:08:11.801
on your application's
busiest days.

00:08:11.801 --> 00:08:13.634
There are certain regulated
industries I'm familiar with,

00:08:13.634 --> 00:08:15.434
where I know
that the ability to do this

00:08:15.434 --> 00:08:17.133
is not just
an important feature,

00:08:17.133 --> 00:08:20.067
but something that regulators
actually demand as well.

00:08:20.067 --> 00:08:21.667
And I guess it goes
without saying

00:08:21.667 --> 00:08:23.067
that one of the nice things
about App Engine

00:08:23.067 --> 00:08:25.767
as opposed to a lot of other
ways you could choose to do

00:08:25.767 --> 00:08:27.701
scaling and capacity planning
and so on

00:08:27.701 --> 00:08:28.767
is that you don't
have to do anything

00:08:28.767 --> 00:08:30.501
to get the extra capacity.

00:08:30.501 --> 00:08:32.934
App Engine just scales up more,
spins up more instances

00:08:32.934 --> 00:08:34.567
to solve your problem,

00:08:34.567 --> 00:08:37.334
to handle the load
that's being thrown at it.

00:08:37.334 --> 00:08:39.868
And then,
when that load goes away,

00:08:39.868 --> 00:08:41.367
those instances idle
and go away

00:08:41.367 --> 00:08:43.934
and you only actually paid
for the cycles that you needed.

00:08:43.934 --> 00:08:47.367
It's a really nice model,
far less capital-intensive,

00:08:47.367 --> 00:08:52.000
than the, kind of traditional
way of doing things.

00:08:52.000 --> 00:08:53.200
Yeah, I don't know
what's up

00:08:53.200 --> 00:08:54.634
with the orange floor
tile puller either,

00:08:54.634 --> 00:08:56.434
but this was the image I got

00:08:56.434 --> 00:08:59.367
when I searched for
systems administrator.

00:08:59.367 --> 00:09:04.167
[laughter]

00:09:04.167 --> 00:09:06.667
But, and again,
this makes perfect sense

00:09:06.667 --> 00:09:08.234
when you think
about this point,

00:09:08.234 --> 00:09:11.067
that you do a lot less
administration with App Engine.

00:09:11.067 --> 00:09:12.567
It's a complete
rich platform.

00:09:12.567 --> 00:09:15.167
App Engine is doing
all this work for you.

00:09:15.167 --> 00:09:16.934
You know, the typical
alternative that we face

00:09:16.934 --> 00:09:18.133
is something
that's the equivalent

00:09:18.133 --> 00:09:20.634
of a virtualized version
of bare metal, you know,

00:09:20.634 --> 00:09:23.167
onto which you have to manage
an entire web hosting stack

00:09:23.167 --> 00:09:24.467
yourself, right?

00:09:24.467 --> 00:09:26.400
I mean, you need to make
a pretty significant investment

00:09:26.400 --> 00:09:27.934
in administration
and operations teams

00:09:27.934 --> 00:09:30.467
in order to run that
web hosting stack

00:09:30.467 --> 00:09:32.534
with load balancing
and web servers

00:09:32.534 --> 00:09:33.701
and application servers,

00:09:33.701 --> 00:09:35.767
and, you know, on and on and on
and on and on.

00:09:35.767 --> 00:09:37.033
Whereas with App Engine,

00:09:37.033 --> 00:09:39.133
you mostly just think
about solving the problem.

00:09:39.133 --> 00:09:40.968
Now what we've seen after
two and a half plus years

00:09:40.968 --> 00:09:42.667
of doing this,
many, many applications

00:09:42.667 --> 00:09:45.834
that we're running at Google,
is that App Engine apps

00:09:45.834 --> 00:09:51.400
typically take 1/10 or less
the system administration effort

00:09:51.400 --> 00:09:54.734
of apps running on a traditional
web hosting environment

00:09:54.734 --> 00:09:56.801
that you might find inside
your corporate network.

00:09:56.801 --> 00:09:59.567
And you know,
what's great about that,

00:09:59.567 --> 00:10:01.968
the thing that I think
is a great case to be made

00:10:01.968 --> 00:10:03.734
in the argument for App Engine
in the enterprise,

00:10:03.734 --> 00:10:06.567
is that it means that the IT
people, the enterprise people,

00:10:06.567 --> 00:10:08.667
get to spend way more time
doing new things,

00:10:08.667 --> 00:10:10.667
innovating, building new apps,
and way less time

00:10:10.667 --> 00:10:14.200
operating the things
they've already done.

00:10:14.200 --> 00:10:16.234
And I certainly
got into computing

00:10:16.234 --> 00:10:18.100
because I liked
building new things,

00:10:18.100 --> 00:10:19.667
innovating,
solving new problems.

00:10:19.667 --> 00:10:22.434
That was far more attractive
to me than operating solutions

00:10:22.434 --> 00:10:24.534
to yesterday's problems,
and I really, really liked

00:10:24.534 --> 00:10:26.300
being able to go
to my management

00:10:26.300 --> 00:10:28.200
and show that, as we made
this move to App Engine,

00:10:28.200 --> 00:10:30.267
we spent a lot less time
thinking about

00:10:30.267 --> 00:10:32.300
systems administration
and operations stuff

00:10:32.300 --> 00:10:33.834
that's really important,

00:10:33.834 --> 00:10:35.634
but only tangential
to the business of

00:10:35.634 --> 00:10:39.634
the problem solving that we're
supposed to be doing.

00:10:39.634 --> 00:10:44.701
So, okay, that's kind of my
30,000-foot CIO level fly-by

00:10:44.701 --> 00:10:47.100
about why we think App Engine
is really, really good

00:10:47.100 --> 00:10:49.434
for the enterprise and some of
the benefits that we've seen.

00:10:49.434 --> 00:10:51.133
They're going to translate
that into something

00:10:51.133 --> 00:10:54.467
that you can actually use.

00:10:54.467 --> 00:10:57.100
I'm very happy that Eric
and the Justins are here

00:10:57.100 --> 00:10:59.334
to talk about actual
development patterns

00:10:59.334 --> 00:11:00.868
that they've discovered
in writing the applications

00:11:00.868 --> 00:11:02.334
that we use at Google.

00:11:02.334 --> 00:11:03.968
They'll show you a bunch of code
that implements that.

00:11:03.968 --> 00:11:05.501
Justin McWilliams
is going to start off

00:11:05.501 --> 00:11:09.534
with three design patterns
that he's discovered.

00:11:09.534 --> 00:11:10.834
McWilliams: Thanks, Ben.

00:11:10.834 --> 00:11:11.834
Hello, everyone.

00:11:11.834 --> 00:11:13.300
I'm Justin McWilliams.

00:11:13.300 --> 00:11:15.501
I'm an engineer on the corporate
platforms engineering team

00:11:15.501 --> 00:11:17.033
in New York City.

00:11:17.033 --> 00:11:19.734
This team is responsible for
building tools and applications

00:11:19.734 --> 00:11:23.033
to help manage our fleet
of workstations within Google.

00:11:23.033 --> 00:11:25.567
You'll see this
in my patterns.

00:11:25.567 --> 00:11:27.100
So the first pattern I'd like
to talk to you about

00:11:27.100 --> 00:11:29.868
is considering App Engine
as a web service host,

00:11:29.868 --> 00:11:33.634
not simply a website
hosting platform.

00:11:33.634 --> 00:11:36.467
So yes, App Engine
is an HTTP server,

00:11:36.467 --> 00:11:39.067
but that doesn't mean
it needs to serve HTML.

00:11:39.067 --> 00:11:41.033
It's actually good for
running a web service

00:11:41.033 --> 00:11:44.100
that other services and clients
can integrate with,

00:11:44.100 --> 00:11:47.200
and as of the App Engine 1.5
release yesterday,

00:11:47.200 --> 00:11:48.534
it's actually good for consuming

00:11:48.534 --> 00:11:51.767
other external web services
as well.

00:11:51.767 --> 00:11:54.367
Now, when building your
web service on App Engine,

00:11:54.367 --> 00:11:57.133
you have various
authentication options.

00:11:57.133 --> 00:11:59.901
Given to you by the platform
are Google Account-Auth,

00:11:59.901 --> 00:12:03.367
and OAuth, but you're not
limited to just those two.

00:12:03.367 --> 00:12:05.701
You could build whatever
custom authentication protocol

00:12:05.701 --> 00:12:06.901
you'd like.

00:12:06.901 --> 00:12:08.534
For example, something
certificate based,

00:12:08.534 --> 00:12:11.000
or a shared secret.

00:12:11.000 --> 00:12:13.701
Now a good example of where
we use App Engine in this way

00:12:13.701 --> 00:12:16.901
is the Simian application
that Ben mentioned.

00:12:16.901 --> 00:12:21.434
This is our enterprise class OSX
software deployment solution.

00:12:21.434 --> 00:12:24.067
So the idea here is we have
a bunch of OSX machines

00:12:24.067 --> 00:12:25.267
in our environments,

00:12:25.267 --> 00:12:27.434
and they have programmatic
clients on them

00:12:27.434 --> 00:12:30.767
that are interfacing with
their App Engine application.

00:12:30.767 --> 00:12:33.901
Now, we use HTTPs for encryption
of our traffic here,

00:12:33.901 --> 00:12:35.501
but we can't use it
for authentication

00:12:35.501 --> 00:12:37.200
for a couple of reasons.

00:12:37.200 --> 00:12:39.834
First off, the App Engine
front ends

00:12:39.834 --> 00:12:43.067
all share the same SSL
wild card certificates.

00:12:43.067 --> 00:12:44.334
And therefore to our clients,

00:12:44.334 --> 00:12:46.300
all App Engine front ends
look the same.

00:12:46.300 --> 00:12:50.067
My app, your app, his app,
they're all the same.

00:12:50.067 --> 00:12:54.334
Now second, there is
no client HTTPs access

00:12:54.334 --> 00:12:55.667
on your app as well,

00:12:55.667 --> 00:12:59.968
so it's not clear
which client is connecting.

00:12:59.968 --> 00:13:02.434
So what we do is we store
some certificates

00:13:02.434 --> 00:13:05.534
on the OSX machines,
and in the Datastore,

00:13:05.534 --> 00:13:07.501
and we use these to sign
messages that get sent

00:13:07.501 --> 00:13:10.133
back and forth,
verifying the authenticity

00:13:10.133 --> 00:13:13.100
of both the clients
and the server.

00:13:13.100 --> 00:13:14.267
Now once this goes through,

00:13:14.267 --> 00:13:15.701
we send a cookie
down to the client

00:13:15.701 --> 00:13:18.501
that is used for
subsequent requests.

00:13:18.501 --> 00:13:21.501
Those include fetching
a manifest out of Datastore,

00:13:21.501 --> 00:13:24.667
which is basically a list
of packages to install.

00:13:24.667 --> 00:13:26.901
And then we're going to fetch
the packages out of Datastore--

00:13:26.901 --> 00:13:30.334
or sorry, out of Blobstore,
and install them.

00:13:30.334 --> 00:13:32.934
After that happens, it reports
the installation results

00:13:32.934 --> 00:13:36.100
up to the server, which is
stored back in Datastore.

00:13:36.100 --> 00:13:38.467
And then, we're going
to log out,

00:13:38.467 --> 00:13:41.534
so that cookie
is expired immediately.

00:13:41.534 --> 00:13:44.200
But we have cron jobs
that run regularly

00:13:44.200 --> 00:13:45.400
that clean these cookies up,

00:13:45.400 --> 00:13:47.133
just in case
that logout didn't work.

00:13:47.133 --> 00:13:48.501
And there's
other cron jobs.

00:13:48.501 --> 00:13:51.234
I'll talk about one of them
a little bit later--

00:13:51.234 --> 00:13:53.901
basically report
generation.

00:13:53.901 --> 00:13:56.667
So, I mentioned that App Engine
is good for other services

00:13:56.667 --> 00:13:57.701
to integrate with.

00:13:57.701 --> 00:13:59.200
Here's an example.

00:13:59.200 --> 00:14:01.901
So we have this system at Google
where employees can request

00:14:01.901 --> 00:14:03.667
commercially licensed software,

00:14:03.667 --> 00:14:07.000
maybe something like Adobe
Photoshop, for example.

00:14:07.000 --> 00:14:10.200
So what happens currently is
the employee makes that request,

00:14:10.200 --> 00:14:12.601
their manager approves it,
and then a technician has to

00:14:12.601 --> 00:14:15.534
manually install that piece
of software on their machine.

00:14:15.534 --> 00:14:18.534
We want to get to a point where
these systems are integrated,

00:14:18.534 --> 00:14:20.601
so when that approval
goes through,

00:14:20.601 --> 00:14:22.000
the systems
talk to one another,

00:14:22.000 --> 00:14:23.701
and that package
is automatically pushed down

00:14:23.701 --> 00:14:27.000
to their machine.

00:14:27.000 --> 00:14:28.868
So next App Engine pattern
I'd like to talk to you about

00:14:28.868 --> 00:14:31.467
is using agents to sync with
your corporate services.

00:14:31.467 --> 00:14:33.467
Now, last year, I told you
how you could use

00:14:33.467 --> 00:14:36.000
secure data connector
to accomplish this.

00:14:36.000 --> 00:14:39.067
This will work
in a similar way.

00:14:39.067 --> 00:14:42.534
So you're going to use
HTTP PUT or POST,

00:14:42.534 --> 00:14:44.567
or BulkLoader,
to push your data up

00:14:44.567 --> 00:14:46.801
into your App Engine
application.

00:14:46.801 --> 00:14:48.667
But now you have data
in two different places

00:14:48.667 --> 00:14:50.467
and of course you're going
to want to make modifications

00:14:50.467 --> 00:14:52.667
on the App Engine side.

00:14:52.667 --> 00:14:54.534
So you're going to expose
the cloud state

00:14:54.534 --> 00:14:57.734
and those changes
via some HTTP end points.

00:14:57.734 --> 00:14:59.701
And then you're going to have
a cron or an agent

00:14:59.701 --> 00:15:01.534
within your corporate
environment

00:15:01.534 --> 00:15:04.634
that's pulling that end point,
looking for that state.

00:15:04.634 --> 00:15:07.133
When it sees the changes,
it can make those changes

00:15:07.133 --> 00:15:09.834
on your corporate services,
and then report back

00:15:09.834 --> 00:15:12.167
up to App Engine that
those changes were made,

00:15:12.167 --> 00:15:15.601
so that all systems
are in sync.

00:15:15.601 --> 00:15:18.534
Now this particular pattern
we use in various applications

00:15:18.534 --> 00:15:20.767
within Google,
but I'll give you an example

00:15:20.767 --> 00:15:22.501
of something you might be
able to relate to

00:15:22.501 --> 00:15:24.634
within your corporate
environments.

00:15:24.634 --> 00:15:27.400
So, let's say you have
an antivirus solution

00:15:27.400 --> 00:15:29.000
of some sort
and you're not happy

00:15:29.000 --> 00:15:31.167
with the interface
it provides for you.

00:15:31.167 --> 00:15:33.033
Maybe you're not able
to delegate access

00:15:33.033 --> 00:15:34.667
to different levels
of technicians,

00:15:34.667 --> 00:15:37.667
or maybe you're not happy with
the reporting that it gives you,

00:15:37.667 --> 00:15:39.901
so you want to build your own
interface for that.

00:15:39.901 --> 00:15:42.334
Here's how you can do it
on App Engine.

00:15:42.334 --> 00:15:43.634
So you're going to have
a bunch of workstations,

00:15:43.634 --> 00:15:46.100
obviously, running
antivirus clients,

00:15:46.100 --> 00:15:47.667
and they're going to report
some events

00:15:47.667 --> 00:15:49.734
up to a server
of some sort.

00:15:49.734 --> 00:15:52.200
In this case,
the example is SQL,

00:15:52.200 --> 00:15:54.467
but it could be
any API or service

00:15:54.467 --> 00:15:56.667
within your corporate
environment.

00:15:56.667 --> 00:15:59.734
So, let's say that it reports
like a virus notification

00:15:59.734 --> 00:16:01.367
up to that server.

00:16:01.367 --> 00:16:03.400
You're going to have an agent
that's looking at that server

00:16:03.400 --> 00:16:05.267
for changes,
and when it sees them,

00:16:05.267 --> 00:16:09.133
HTTP PUT or POST pushes it up
into App Engine,

00:16:09.133 --> 00:16:11.968
and now your admin can see
all of those virus notifications

00:16:11.968 --> 00:16:14.100
on the App Engine side.

00:16:14.100 --> 00:16:16.234
Now you can imagine that admin
is going to want to run

00:16:16.234 --> 00:16:19.000
some, like, full disk scans
on some of those machines.

00:16:19.000 --> 00:16:20.334
So we can click a button.

00:16:20.334 --> 00:16:22.133
That action
is going to get exposed

00:16:22.133 --> 00:16:23.467
through some HTTP endpoint,

00:16:23.467 --> 00:16:25.567
which you have
another agent monitoring,

00:16:25.567 --> 00:16:27.000
and then it's going
to make some changes

00:16:27.000 --> 00:16:30.167
within that SQL server
for that antivirus solution,

00:16:30.167 --> 00:16:31.701
and eventually that client's
going to run

00:16:31.701 --> 00:16:33.834
that full disk scan.

00:16:33.834 --> 00:16:37.400
Now, you can imagine that after
that full disk scan is complete,

00:16:37.400 --> 00:16:39.267
it's going to report
some more information

00:16:39.267 --> 00:16:41.434
up to that SQL server,
which will then propagate

00:16:41.434 --> 00:16:43.801
its way into App Engine,
so the admin gets a nice,

00:16:43.801 --> 00:16:48.567
consolidated view
of that machine.

00:16:48.567 --> 00:16:50.701
So the last pattern
I'd like to talk to you

00:16:50.701 --> 00:16:55.934
about is using query cursors to
accomplish iterative fetching.

00:16:55.934 --> 00:16:59.000
So, the idea with any app
in general,

00:16:59.000 --> 00:17:00.801
especially in App Engine,
is you want to respond

00:17:00.801 --> 00:17:03.601
to your users and clients
as quickly as possible.

00:17:03.601 --> 00:17:05.667
And any expensive tasks
that you have to do,

00:17:05.667 --> 00:17:07.601
you defer to the background.

00:17:07.601 --> 00:17:09.100
In App Engine,
you can accomplish this

00:17:09.100 --> 00:17:11.701
using TaskQueue Tasks.

00:17:11.701 --> 00:17:14.367
So, query cursors allow you
to do--

00:17:14.367 --> 00:17:16.367
They allow you
to step through queries.

00:17:16.367 --> 00:17:19.234
So with this you can accomplish
UI pagination,

00:17:19.234 --> 00:17:23.000
or simply check-pointing
during large query operations.

00:17:23.000 --> 00:17:25.267
Query cursors can be
expressed as strings,

00:17:25.267 --> 00:17:26.968
and therefore
they're very portable.

00:17:26.968 --> 00:17:29.067
You can save them in
Datastore and Memcache,

00:17:29.067 --> 00:17:31.834
or wherever else you want
to store your data.

00:17:31.834 --> 00:17:32.968
They're also persistent,

00:17:32.968 --> 00:17:34.834
so you can use them
across requests,

00:17:34.834 --> 00:17:38.467
and continue where you left off
on a previous request.

00:17:38.467 --> 00:17:40.100
Now, a good example
of where we use this

00:17:40.100 --> 00:17:42.634
is back in our Simian
application.

00:17:42.634 --> 00:17:44.701
I mentioned these programmatic
clients are posting

00:17:44.701 --> 00:17:47.934
install results up to our app,
and we want to respond

00:17:47.934 --> 00:17:51.267
to those, uh, those clients
as quickly as possible,

00:17:51.267 --> 00:17:54.901
so they can continue on doing
whatever else they need to do,

00:17:54.901 --> 00:17:57.934
installing further packages
or whatever.

00:17:57.934 --> 00:17:59.901
So what we do is we simply
save those results

00:17:59.901 --> 00:18:02.734
to the Datastore very quickly,
and then we have a cron job

00:18:02.734 --> 00:18:05.033
that runs and analyzes
the results

00:18:05.033 --> 00:18:08.334
to generate some reports
for our admins.

00:18:08.334 --> 00:18:10.534
So the first thing
this cron's going to do

00:18:10.534 --> 00:18:12.667
is pull the stats
out of the dictionary.

00:18:12.667 --> 00:18:15.434
Or, sorry, dictionary
of stats out of Datastore.

00:18:15.434 --> 00:18:17.067
And we use a little helper
method here,

00:18:17.067 --> 00:18:18.133
just in case this is like,

00:18:18.133 --> 00:18:20.434
the first time
the function has run,

00:18:20.434 --> 00:18:25.200
and it's also--it's also
Memcache-backed.

00:18:25.200 --> 00:18:27.133
So we're going to
set up our query.

00:18:27.133 --> 00:18:29.234
We're looking at all installs,
oldest to newest,

00:18:29.234 --> 00:18:31.501
as they come in.

00:18:31.501 --> 00:18:33.167
And then we're going to pull
our query cursor

00:18:33.167 --> 00:18:34.400
out of the dictionary.

00:18:34.400 --> 00:18:36.567
Again, this was saved
on the last execution

00:18:36.567 --> 00:18:38.601
of this function.

00:18:38.601 --> 00:18:39.934
If that cursor exists,

00:18:39.934 --> 00:18:41.367
we're going to attach it
to our query

00:18:41.367 --> 00:18:45.701
so that we pick up where
we left off the last time.

00:18:45.701 --> 00:18:48.868
Then we're going to fetch
1,000 installs out of Datastore.

00:18:48.868 --> 00:18:51.000
Now, 1,000 here is
completely arbitrary.

00:18:51.000 --> 00:18:54.934
Could be 10, 100, it's going
to work the same way here.

00:18:54.934 --> 00:18:56.534
If there's no more installs
to process,

00:18:56.534 --> 00:18:59.968
we'll just return out,
but I mentioned this is a cron,

00:18:59.968 --> 00:19:02.434
so in a few more minutes
when this cron kicks off again,

00:19:02.434 --> 00:19:05.467
hopefully there's more installs
to process.

00:19:05.467 --> 00:19:07.234
Once we do have some installs
to process,

00:19:07.234 --> 00:19:09.334
we'll loop over them,
analyze whatever we need to,

00:19:09.334 --> 00:19:11.968
and update that install
stats dictionary.

00:19:11.968 --> 00:19:13.000
And then, of course,
we're going to save it

00:19:13.000 --> 00:19:15.067
back into the Datastore.

00:19:15.067 --> 00:19:17.167
And this helper method
also updates Memcache,

00:19:17.167 --> 00:19:21.267
so our reports
go live immediately.

00:19:21.267 --> 00:19:23.601
Of course, we're also going to
have to save our current

00:19:23.601 --> 00:19:24.901
query cursors to Datastore,

00:19:24.901 --> 00:19:26.234
so that the next time
this function runs,

00:19:26.234 --> 00:19:29.467
we continue
where we just left off.

00:19:29.467 --> 00:19:31.901
And then finally, we're going to
defer the execution

00:19:31.901 --> 00:19:33.767
of this function to happen
one more time in the background

00:19:33.767 --> 00:19:35.901
using TaskQueue Tasks,

00:19:35.901 --> 00:19:38.167
so that just in case
that magic number we chose,

00:19:38.167 --> 00:19:41.167
the 1,000 or 10 or 100
or whatever, wasn't enough,

00:19:41.167 --> 00:19:44.300
and there's actually
further installs to process.

00:19:44.300 --> 00:19:47.667
So it's important to note that
query cursors and cron jobs

00:19:47.667 --> 00:19:50.067
are not directly tied
in any way.

00:19:50.067 --> 00:19:52.367
We could easily kick off
this same exact code

00:19:52.367 --> 00:19:56.434
based on any other criteria,
maybe every 10 installs

00:19:56.434 --> 00:19:57.434
that are reported
to our server.

00:19:57.434 --> 00:19:58.667
We would just fire this off,

00:19:58.667 --> 00:20:01.601
and things would work
just as you see here.

00:20:01.601 --> 00:20:03.634
So next up, I'd like to welcome
Eric to the stage.

00:20:03.634 --> 00:20:05.234
He's going to talk to you
about some creative ways

00:20:05.234 --> 00:20:10.734
of using Blobstore.

00:20:10.734 --> 00:20:11.901
Schoeffler: Thanks, Justin.

00:20:11.901 --> 00:20:13.334
Hi, everyone.

00:20:13.334 --> 00:20:14.801
I'm Eric Schoeffler,
and I'm here from the staffing

00:20:14.801 --> 00:20:16.734
applications team
out in New York City.

00:20:16.734 --> 00:20:19.634
Now basically, the team
works on the software

00:20:19.634 --> 00:20:22.634
we use to get people
hired at Google.

00:20:22.634 --> 00:20:24.667
I'm here today to talk to you
about an alternative

00:20:24.667 --> 00:20:26.868
to using Datastore
on App Engine.

00:20:26.868 --> 00:20:28.834
So I saw a lot of you
raise your hands

00:20:28.834 --> 00:20:30.501
saying you worked
on App Engine before.

00:20:30.501 --> 00:20:31.934
Now, if you've stored
any data on App Engine,

00:20:31.934 --> 00:20:33.801
you've probably used
Datastore.

00:20:33.801 --> 00:20:36.100
And Datastore works really well
when you're dealing with

00:20:36.100 --> 00:20:37.367
a few records at a time.

00:20:37.367 --> 00:20:39.767
So let's say you had
an employee database,

00:20:39.767 --> 00:20:42.267
and you wanted to look up
how many vacation days

00:20:42.267 --> 00:20:45.200
an employee has,
or you want to update

00:20:45.200 --> 00:20:47.234
the phone number
of an employee.

00:20:47.234 --> 00:20:48.834
Datastore is great at that,
because you're only dealing

00:20:48.834 --> 00:20:51.067
with a few records
at a time.

00:20:51.067 --> 00:20:52.133
But what if you
need to do a report

00:20:52.133 --> 00:20:54.133
on everyone
in the database?

00:20:54.133 --> 00:20:56.200
It turns out Datastore
is actually fairly slow

00:20:56.200 --> 00:20:57.667
when you do something
like that.

00:20:57.667 --> 00:21:00.100
It actually becomes more
efficient to store your data

00:21:00.100 --> 00:21:02.133
as a blob in Blobstore,

00:21:02.133 --> 00:21:04.334
deserialize that information
into memory,

00:21:04.334 --> 00:21:06.167
and then you can run
whatever sort of operations

00:21:06.167 --> 00:21:08.300
you'd like to on that data.

00:21:08.300 --> 00:21:10.601
Now, obviously this has
some limitations.

00:21:10.601 --> 00:21:12.334
When you're updating your data,
you have to update

00:21:12.334 --> 00:21:14.133
that entire blob,
so that means

00:21:14.133 --> 00:21:16.567
you can't individually update
one record at a time.

00:21:16.567 --> 00:21:18.501
You have to update
the whole thing.

00:21:18.501 --> 00:21:20.601
The other thing is, you're
pulling out all the data

00:21:20.601 --> 00:21:22.467
whenever you want
to read anything,

00:21:22.467 --> 00:21:24.901
so that means
that you need to pull out

00:21:24.901 --> 00:21:27.067
that large blob of data
into memory,

00:21:27.067 --> 00:21:29.434
which leads to the second
limitation.

00:21:29.434 --> 00:21:32.601
There's a limitation of RAM on
whatever machine you're using.

00:21:32.601 --> 00:21:34.868
You're pulling out that entire
database into your RAM,

00:21:34.868 --> 00:21:38.100
so that needs to be able
to fit there.

00:21:38.100 --> 00:21:39.434
But there's going to be
certain cases

00:21:39.434 --> 00:21:40.834
where this is going
to work out fine,

00:21:40.834 --> 00:21:42.434
and these limitations aren't
going to be a problem.

00:21:42.434 --> 00:21:45.033
And in those cases, you're
going to get some benefits.

00:21:45.033 --> 00:21:46.067
There are a couple benefits.

00:21:46.067 --> 00:21:48.200
The first one is flexibility.

00:21:48.200 --> 00:21:50.400
So when you're dealing
with Datastore,

00:21:50.400 --> 00:21:53.067
you have to deal with the query
language that it provides.

00:21:53.067 --> 00:21:55.367
So if you wanted to do
some sort of query like,

00:21:55.367 --> 00:21:57.033
finding all the people
in a company

00:21:57.033 --> 00:22:00.467
who started two years ago and
have done over 50 interviews,

00:22:00.467 --> 00:22:02.501
that's impossible
with Datastore,

00:22:02.501 --> 00:22:04.133
and that's because
you're not allowed to do

00:22:04.133 --> 00:22:05.501
multiple filters--

00:22:05.501 --> 00:22:08.000
multiple inequality filters
on multiple properties

00:22:08.000 --> 00:22:09.868
in the same query.

00:22:09.868 --> 00:22:11.634
But with Blobstore, since
you're pulling all your data

00:22:11.634 --> 00:22:14.400
into memory, you can do whatever
sort of data manipulation

00:22:14.400 --> 00:22:18.200
and filtering that you'd like to
on that data.

00:22:18.200 --> 00:22:21.200
Now, you can even do something
as arbitrary as finding everyone

00:22:21.200 --> 00:22:24.467
in the company who started
on an odd week of the year.

00:22:24.467 --> 00:22:27.601
The other benefit you're going
to get with Blobstore is speed.

00:22:27.601 --> 00:22:30.033
It's speed in upload
and speed in access.

00:22:30.033 --> 00:22:33.434
So, whenever you upload
all your data,

00:22:33.434 --> 00:22:35.868
all you have to do is upload
that one blob.

00:22:35.868 --> 00:22:39.334
Now with Datastore,
to upload 50,000 records could

00:22:39.334 --> 00:22:43.000
take over 30 minutes;
but with Blobstore,

00:22:43.000 --> 00:22:45.601
the equivalent 5 MB blob
will take only

00:22:45.601 --> 00:22:49.167
about 5 seconds to upload,
so that's pretty quick.

00:22:49.167 --> 00:22:53.133
The speed benefit is also there
with accessing the data.

00:22:53.133 --> 00:22:54.400
So I could just talk
to you about it,

00:22:54.400 --> 00:22:57.767
but I'd rather show you.

00:22:57.767 --> 00:23:02.000
So what I've done here is
I've created 50,000 records,

00:23:02.000 --> 00:23:04.400
each one of these records
has a hair color,

00:23:04.400 --> 00:23:08.234
an arbitrary test score,
and 100 bytes of arbitrary data.

00:23:08.234 --> 00:23:12.434
So essentially, we have 50,000
records of about 100 bytes each,

00:23:12.434 --> 00:23:16.601
and I've uploaded that
to Datastore as 50,000 records,

00:23:16.601 --> 00:23:17.834
and I've uploaded it
to Blobstore

00:23:17.834 --> 00:23:20.334
as a serialized CSV file.

00:23:20.334 --> 00:23:22.234
It's about 5 MB.

00:23:22.234 --> 00:23:24.434
And what you see here is
a front end that allows me

00:23:24.434 --> 00:23:26.200
to filter based on
hair color

00:23:26.200 --> 00:23:29.334
and find the average test score
of those people.

00:23:29.334 --> 00:23:31.200
So the first thing
I'd like to show you

00:23:31.200 --> 00:23:32.667
is a small result set.

00:23:32.667 --> 00:23:34.801
So I'm going to look for people
with blue hair.

00:23:34.801 --> 00:23:37.634
There's not many people
with blue hair in this database.

00:23:37.634 --> 00:23:39.901
And you'll see that Datastore
returns extremely quickly.

00:23:39.901 --> 00:23:43.534
It's actually less
than 20 milliseconds.

00:23:43.534 --> 00:23:45.200
With Blobstore, it takes
a little bit longer

00:23:45.200 --> 00:23:47.767
because you're pulling in
all of the data.

00:23:47.767 --> 00:23:50.033
But what happens if we look
at a larger result set,

00:23:50.033 --> 00:23:52.868
say people with black hair?

00:23:52.868 --> 00:23:55.000
It turns out there's 25,000
people with black hair

00:23:55.000 --> 00:23:56.334
in this data set.

00:23:56.334 --> 00:23:57.701
And what you'll see
is that Blobstore returns

00:23:57.701 --> 00:23:59.267
in the same amount of time
that it did

00:23:59.267 --> 00:24:01.267
when we were looking
for one record,

00:24:01.267 --> 00:24:03.534
but Datastore takes
a little longer.

00:24:03.534 --> 00:24:05.834
Now that was only half
of the records in that database,

00:24:05.834 --> 00:24:07.300
so what if I don't
filter at all?

00:24:07.300 --> 00:24:09.334
What if I'm looking for everyone
and trying to average out

00:24:09.334 --> 00:24:12.067
the scores of everyone?

00:24:12.067 --> 00:24:13.901
You'll find that in that case,
Blobstore returns in about

00:24:13.901 --> 00:24:16.200
the same amount of time,
around two seconds,

00:24:16.200 --> 00:24:18.667
and with Datastore,
it takes even slower.

00:24:18.667 --> 00:24:20.234
It's nearly twice as long
as it took

00:24:20.234 --> 00:24:22.601
when we were looking for
people with black hair.

00:24:22.601 --> 00:24:24.100
And the reason for that
is because Datastore

00:24:24.100 --> 00:24:26.267
has some overhead
for pulling in a row.

00:24:26.267 --> 00:24:29.701
So the more rows you pull in,
the longer it's going to take.

00:24:29.701 --> 00:24:31.667
But with Blobstore,
you're always pulling in

00:24:31.667 --> 00:24:34.400
all of the data, so whether
you're looking at one record,

00:24:34.400 --> 00:24:36.167
or 50,000 records,

00:24:36.167 --> 00:24:39.067
it's going to take
the same amount of time.

00:24:39.067 --> 00:24:42.734
So now let's look at that demo
100 more times.

00:24:42.734 --> 00:24:44.901
Now, I'm not going to make you
watch me do it 100 more times.

00:24:44.901 --> 00:24:48.801
I've already done
the work for you.

00:24:48.801 --> 00:24:52.167
So what you see here is
that last demo,

00:24:52.167 --> 00:24:55.701
run 100 times on both
Blobstore and Datastore--

00:24:55.701 --> 00:24:58.300
Blobstore in blue,
and Datastore in red--

00:24:58.300 --> 00:25:02.200
and as it hits the gram
as latency for both of them.

00:25:02.200 --> 00:25:03.934
And what you'll see
is some variations

00:25:03.934 --> 00:25:06.434
for both Blobstore
and Datastore.

00:25:06.434 --> 00:25:09.334
But in general, you'll see
two different spikes,

00:25:09.334 --> 00:25:12.834
so there's one spike
at two seconds for Blobstore,

00:25:12.834 --> 00:25:15.934
and one spike at 11 seconds
for Datastore.

00:25:15.934 --> 00:25:17.200
So what this is showing you

00:25:17.200 --> 00:25:19.901
is when you're dealing
with 50,000 records,

00:25:19.901 --> 00:25:24.067
Blobstore is going to be
a lot faster than Datastore.

00:25:24.067 --> 00:25:26.367
So now that I've showed you
that Blobstore can be faster

00:25:26.367 --> 00:25:27.667
than Datastore,
you're probably wondering,

00:25:27.667 --> 00:25:30.167
"How do I implement this
on my own app?"

00:25:30.167 --> 00:25:32.367
Well, it's a three-step process.

00:25:32.367 --> 00:25:36.067
The first step is you have to
allow your app to accept blobs.

00:25:36.067 --> 00:25:38.601
So to do that, you need
to create two servlets.

00:25:38.601 --> 00:25:40.934
The first servlet
is an upload servlet,

00:25:40.934 --> 00:25:42.167
and what that does is,

00:25:42.167 --> 00:25:45.467
it creates a one-time use
upload URL

00:25:45.467 --> 00:25:47.367
that you can upload
your blob to.

00:25:47.367 --> 00:25:48.534
Now when you create that,

00:25:48.534 --> 00:25:51.033
you have to specify
a callback servlet,

00:25:51.033 --> 00:25:54.234
and in this case, the callback
servlet is post upload.

00:25:54.234 --> 00:25:57.400
And that's the second servlet
that you need to create.

00:25:57.400 --> 00:26:01.434
This callback is called once
Blobstore has stored that blob.

00:26:01.434 --> 00:26:04.334
And what it does is it gives
you metadata about the blob

00:26:04.334 --> 00:26:07.100
in the form of a blob
key object.

00:26:07.100 --> 00:26:09.267
Now if you want to access
that blob in the future,

00:26:09.267 --> 00:26:11.300
you need to store
that blob key somewhere.

00:26:11.300 --> 00:26:13.567
So I would suggest storing it
in Datastore.

00:26:13.567 --> 00:26:16.067
That way you can access it
whenever you need it.

00:26:16.067 --> 00:26:18.934
Now, remember, we talked about
Datastore being fast

00:26:18.934 --> 00:26:20.634
when you're dealing with
a few records?

00:26:20.634 --> 00:26:23.334
Well since you're only pulling
in one blob key at a time,

00:26:23.334 --> 00:26:25.734
it's going to be very quick,
and the time is negligible

00:26:25.734 --> 00:26:28.701
to pull out that data.

00:26:28.701 --> 00:26:31.601
So, now once you've added
the ability to upload blobs,

00:26:31.601 --> 00:26:34.467
you need to create a blob
and actually upload it.

00:26:34.467 --> 00:26:37.234
So to do that, you need to
take all of your records,

00:26:37.234 --> 00:26:40.000
and serialize them up
into a file somehow.

00:26:40.000 --> 00:26:44.234
In the example I gave,
we serialized it as a CSV file.

00:26:44.234 --> 00:26:45.534
Now, obviously that's not

00:26:45.534 --> 00:26:47.100
the fastest
serialization method,

00:26:47.100 --> 00:26:49.100
and in fact
in production for Java,

00:26:49.100 --> 00:26:51.868
we use protocol buffers.

00:26:51.868 --> 00:26:53.033
But you're going to
have to find the one

00:26:53.033 --> 00:26:54.234
that works best
for the environment

00:26:54.234 --> 00:26:56.167
that you're running on.

00:26:56.167 --> 00:26:57.400
So, for example,
in Python,

00:26:57.400 --> 00:26:59.100
you wouldn't want to use
protocol buffers,

00:26:59.100 --> 00:27:02.400
because they're a little bit
slower in Python.

00:27:02.400 --> 00:27:06.300
So once you've done that,
you need to upload that blob.

00:27:06.300 --> 00:27:08.434
So you use the servlets
you created in Step 1

00:27:08.434 --> 00:27:10.667
to upload the blob,

00:27:10.667 --> 00:27:12.400
and then once the blob
has been uploaded,

00:27:12.400 --> 00:27:15.501
it's ready to be accessed
whenever you need that data.

00:27:15.501 --> 00:27:17.467
So to do that, you need
to pull out the blob key

00:27:17.467 --> 00:27:20.434
that you stored in Datastore,
use that blob key to pull out

00:27:20.434 --> 00:27:23.234
the stream that represents
the blob,

00:27:23.234 --> 00:27:25.501
and deserialize that blob.

00:27:25.501 --> 00:27:28.033
Once you've deserialized it,
you have all the data in memory

00:27:28.033 --> 00:27:30.400
and you can do whatever
you'd like to with that data,

00:27:30.400 --> 00:27:32.400
and that brings us back
to the flexibility thing

00:27:32.400 --> 00:27:34.300
that we were talking about
before.

00:27:34.300 --> 00:27:36.501
Since the data's in memory,
you can run any sort of

00:27:36.501 --> 00:27:38.868
arbitrary filters,
or any sort of manipulation

00:27:38.868 --> 00:27:41.801
on that data
that you'd like.

00:27:41.801 --> 00:27:45.067
Now, if you're anything like me,
hair color, test scores--

00:27:45.067 --> 00:27:46.901
they're not very interesting.
It's really fake.

00:27:46.901 --> 00:27:49.834
So how can this be used
in the real world?

00:27:49.834 --> 00:27:54.667
Well, it turns out I do that
in a project called Lineup.

00:27:54.667 --> 00:27:56.667
And Lineup is
an interview-scheduling tool

00:27:56.667 --> 00:27:58.033
that we use here
at Google.

00:27:58.033 --> 00:27:59.534
You see, at Google,
we have this problem

00:27:59.534 --> 00:28:01.934
where we have a lot of
candidates and a lot of people

00:28:01.934 --> 00:28:03.901
who can interview
those candidates.

00:28:03.901 --> 00:28:06.100
And what we want to do is find
the best interviewers

00:28:06.100 --> 00:28:07.868
for each candidate.

00:28:07.868 --> 00:28:09.701
So what we do is
we store information

00:28:09.701 --> 00:28:11.868
about all of our employees,

00:28:11.868 --> 00:28:13.601
so every employee
has some information,

00:28:13.601 --> 00:28:16.801
like what program
and languages they know,

00:28:16.801 --> 00:28:17.801
how many interviews
they've done,

00:28:17.801 --> 00:28:19.334
what their job level is,

00:28:19.334 --> 00:28:21.534
and we pack that all up
into a blob

00:28:21.534 --> 00:28:24.033
and we push that blob
up to Lineup.

00:28:24.033 --> 00:28:26.901
Then, whenever a recruiter
needs to set up an interview,

00:28:26.901 --> 00:28:29.400
they just describe
the candidate,

00:28:29.400 --> 00:28:33.133
and we go through that blob,
and we score every employee

00:28:33.133 --> 00:28:36.234
based on how well they match
a candidate,

00:28:36.234 --> 00:28:37.934
and then we rank them.

00:28:37.934 --> 00:28:40.934
We go and find their
availability in Google Calendar,

00:28:40.934 --> 00:28:42.801
and we schedule them
based on how well

00:28:42.801 --> 00:28:44.400
they match that candidate.

00:28:44.400 --> 00:28:45.701
And this way,
everyone's happy

00:28:45.701 --> 00:28:48.000
because the interviewers
are interviewing candidates

00:28:48.000 --> 00:28:50.501
that they actually understand,

00:28:50.501 --> 00:28:53.968
and the recruiter doesn't have
to spend all that time

00:28:53.968 --> 00:28:55.167
figuring out the schedule,

00:28:55.167 --> 00:28:57.501
and can spend more time
talking to the candidate

00:28:57.501 --> 00:29:00.968
and getting them
excited about Google.

00:29:00.968 --> 00:29:03.167
So, the bottom line here
is that there are two different

00:29:03.167 --> 00:29:06.033
data storage solutions
in App Engine.

00:29:06.033 --> 00:29:07.467
Now, you might have heard
of Blobstore before,

00:29:07.467 --> 00:29:10.167
but you probably thought of it
as just a storage system

00:29:10.167 --> 00:29:14.467
for blobs like images, PDFs,
and that sort of thing.

00:29:14.467 --> 00:29:18.234
But it's actually useful for
your main data source as well.

00:29:18.234 --> 00:29:20.100
And both Datastore and Blobstore
can be useful

00:29:20.100 --> 00:29:21.601
in different situations.

00:29:21.601 --> 00:29:23.667
So when you're dealing with
a few records at a time,

00:29:23.667 --> 00:29:25.033
Datastore is great,

00:29:25.033 --> 00:29:27.133
or when you have
a very, very large database,

00:29:27.133 --> 00:29:28.601
Datastore is great

00:29:28.601 --> 00:29:30.133
because you don't have to pull
all that data into memory

00:29:30.133 --> 00:29:31.868
at any given time.

00:29:31.868 --> 00:29:35.200
But with Blobstore,
you can do large updates

00:29:35.200 --> 00:29:37.601
and you can grab
a lot of information

00:29:37.601 --> 00:29:39.434
all at once very quickly.

00:29:39.434 --> 00:29:40.901
It also allows you
the flexibility

00:29:40.901 --> 00:29:44.667
to do any sort of queries
that you'd like on that data.

00:29:44.667 --> 00:29:47.734
So, with that I'd like to
pass it off to our next Justin,

00:29:47.734 --> 00:29:50.434
who's going to talk about
using the channel API

00:29:50.434 --> 00:29:57.934
for collaborative apps.

00:29:57.934 --> 00:29:59.968
Fagnani: Thanks, Eric.

00:29:59.968 --> 00:30:02.234
So my name's Justin Fagnani,
and I'm an engineer

00:30:02.234 --> 00:30:04.100
in corporate engineering
down in Mountain View,

00:30:04.100 --> 00:30:06.000
and today I'm going to talk
about how to implement

00:30:06.000 --> 00:30:07.901
a real-time collaborative
editing system

00:30:07.901 --> 00:30:14.167
using App Engine
and Google Web Toolkit.

00:30:14.167 --> 00:30:15.968
So, real-time
collaborative editing

00:30:15.968 --> 00:30:19.067
has been popularized by many
apps in the past few years,

00:30:19.067 --> 00:30:20.734
especially Google Docs.

00:30:20.734 --> 00:30:22.400
And this feature
is really awesome to have

00:30:22.400 --> 00:30:24.567
when you have multiple people
editing the same document

00:30:24.567 --> 00:30:27.834
at the same time.

00:30:27.834 --> 00:30:31.167
So, what we're going to do here
to implement this

00:30:31.167 --> 00:30:33.167
is we're going to use
the command pattern.

00:30:33.167 --> 00:30:35.367
We're going to use
the App Engine channel API,

00:30:35.367 --> 00:30:39.601
and we're going to use some
internals of GWT serialization.

00:30:39.601 --> 00:30:41.834
Now, notice
that the command pattern

00:30:41.834 --> 00:30:43.901
in the related
operational transformer

00:30:43.901 --> 00:30:45.334
are patterns
that are commonly used

00:30:45.334 --> 00:30:48.033
to implement
real-time collaboration.

00:30:48.033 --> 00:30:50.767
You can find out about those
in more detail online,

00:30:50.767 --> 00:30:53.467
but today I'm mostly going
to talk about the channel API

00:30:53.467 --> 00:30:55.167
and how to wire things
together.

00:30:55.167 --> 00:30:57.834
All you really need to know
about the command pattern

00:30:57.834 --> 00:31:00.133
is that instead of sending
entire objects back and forth

00:31:00.133 --> 00:31:02.300
like a traditional
web application,

00:31:02.300 --> 00:31:07.467
we're just going to send
each edit as it happens.

00:31:07.467 --> 00:31:09.300
So, collaboration relies on
sending messages

00:31:09.300 --> 00:31:11.367
from the server
to the client,

00:31:11.367 --> 00:31:14.167
and traditionally this has
been very tricky to do well.

00:31:14.167 --> 00:31:16.701
It's actually been somewhat
impossible also on App Engine

00:31:16.701 --> 00:31:19.400
due to the 30-second
request time out.

00:31:19.400 --> 00:31:20.601
Luckily, though,
the App Engine team

00:31:20.601 --> 00:31:22.601
has released
the channel API

00:31:22.601 --> 00:31:24.801
and this takes care of
all the technical details

00:31:24.801 --> 00:31:27.167
of setting up
this server-to-client

00:31:27.167 --> 00:31:30.400
communication channel for us.

00:31:30.400 --> 00:31:32.934
So that's great, we can
have collaboration, right?

00:31:32.934 --> 00:31:34.767
Unfortunately
it's not that simple.

00:31:34.767 --> 00:31:36.300
We still have to do
a lot of things ourselves,

00:31:36.300 --> 00:31:40.300
specifically the channel API
only allows you to send

00:31:40.300 --> 00:31:43.367
a simple string message
to one client at a time.

00:31:43.367 --> 00:31:45.901
So if you want to send
a message to all of your clients

00:31:45.901 --> 00:31:48.000
or to a group of clients,
you have to build and maintain

00:31:48.000 --> 00:31:49.868
a registry on your own.

00:31:49.868 --> 00:31:52.367
Also, we would like to be able
to send something more

00:31:52.367 --> 00:31:56.067
than a simple string message,
say a GWT serialized object.

00:31:56.067 --> 00:31:59.634
So that brings us to our three
key responsibilities here.

00:31:59.634 --> 00:32:01.868
First, we need to
build and maintain

00:32:01.868 --> 00:32:05.667
a list of the active clients and
what objects they're editing.

00:32:05.667 --> 00:32:08.100
Then we need to be able to
serialize and de-serialize

00:32:08.100 --> 00:32:10.234
our command objects,
so that we can send them

00:32:10.234 --> 00:32:12.601
as a string
over the channel API.

00:32:12.601 --> 00:32:15.133
And finally, we need to be able
to execute the commands,

00:32:15.133 --> 00:32:17.067
and then dispatch them
back to all the clients

00:32:17.067 --> 00:32:20.601
that are listening
to that object.

00:32:20.601 --> 00:32:22.133
So here are our main
components.

00:32:22.133 --> 00:32:24.667
We have a command object,
which I've talked about.

00:32:24.667 --> 00:32:27.601
This object represents
a user action,

00:32:27.601 --> 00:32:30.968
and it's the instructions on how
to modify a particular object.

00:32:30.968 --> 00:32:34.234
The command object also performs
this modification,

00:32:34.234 --> 00:32:37.234
and it performs it the same
on the client and the server,

00:32:37.234 --> 00:32:41.901
thanks to the wonders of GWT's
Java to JavaScript translation.

00:32:41.901 --> 00:32:44.100
Then, on the client,
we have the CommandController,

00:32:44.100 --> 00:32:46.000
and this coordinates
all the command-related activity

00:32:46.000 --> 00:32:47.434
in the browser.

00:32:47.434 --> 00:32:49.534
The client is responsible
for opening a channel

00:32:49.534 --> 00:32:51.000
and registering
that it's listening

00:32:51.000 --> 00:32:52.434
to a particular object,

00:32:52.434 --> 00:32:54.234
and it also periodically
pings the server

00:32:54.234 --> 00:32:56.567
to let the server know
that it's still listening.

00:32:56.567 --> 00:32:58.868
And then, most importantly,
it's responsible for sending

00:32:58.868 --> 00:33:02.601
and receiving command objects
to and from the server.

00:33:02.601 --> 00:33:05.467
On the server, we have something
called CommandService,

00:33:05.467 --> 00:33:07.501
and this is the brains
of the whole operation.

00:33:07.501 --> 00:33:10.767
The CommandService builds this
mapping of objects to clients

00:33:10.767 --> 00:33:12.734
that are editing them.

00:33:12.734 --> 00:33:14.868
Uh, it, you know,
listens and makes sure

00:33:14.868 --> 00:33:16.901
that the clients
are still listening,

00:33:16.901 --> 00:33:19.100
and then it also sends
and receives the commands

00:33:19.100 --> 00:33:21.000
to and from the clients.

00:33:21.000 --> 00:33:24.100
And finally we have something
called the CommandExcecutor.

00:33:24.100 --> 00:33:27.234
The CommandExcecutor
is a helper that loads objects

00:33:27.234 --> 00:33:28.434
that the commands
need to edit,

00:33:28.434 --> 00:33:30.667
and then invokes
commands on them.

00:33:30.667 --> 00:33:32.133
The CommandExcecutor
is a little bit different,

00:33:32.133 --> 00:33:34.300
possibly, on the client
or the server.

00:33:34.300 --> 00:33:37.200
We can have different behavior--
load objects from Datastore

00:33:37.200 --> 00:33:39.467
or, you know,
from some cache

00:33:39.467 --> 00:33:42.601
that you have in the browser
differently.

00:33:42.601 --> 00:33:46.501
So here's a diagram that shows
how these pieces fit together.

00:33:46.501 --> 00:33:48.334
If we start over here
on the left,

00:33:48.334 --> 00:33:50.501
you see that we have
the CommandController,

00:33:50.501 --> 00:33:54.567
and it sends a command to the
CommandService over at GWT RPC,

00:33:54.567 --> 00:33:56.801
where the service receives it
and then executes it

00:33:56.801 --> 00:33:59.367
via server side
CommandExcecutor.

00:33:59.367 --> 00:34:01.767
The executor
will produce a result,

00:34:01.767 --> 00:34:04.400
which is also a command,
and this command is serialized

00:34:04.400 --> 00:34:06.767
and then sent over
the channel API back

00:34:06.767 --> 00:34:09.167
to the listening clients,
where it deserializes it

00:34:09.167 --> 00:34:13.100
and executes it via the client
side CommandExcecutor.

00:34:13.100 --> 00:34:15.601
The important thing to note here
is that we are sending commands

00:34:15.601 --> 00:34:17.734
to the server over GWT RPC,

00:34:17.734 --> 00:34:23.501
and back to the clients
via the channel API.

00:34:23.501 --> 00:34:24.868
So I talked about
how the channel API

00:34:24.868 --> 00:34:26.801
does not help us keep track
of our clients.

00:34:26.801 --> 00:34:28.467
We have to do it ourselves.

00:34:28.467 --> 00:34:30.534
So here's a little bit
on how to do that.

00:34:30.534 --> 00:34:32.033
This is the interaction
between the command

00:34:32.033 --> 00:34:33.567
controller on the client,

00:34:33.567 --> 00:34:36.000
and the CommandService
on the server.

00:34:36.000 --> 00:34:37.934
So the first thing that happens
is that the CommandController

00:34:37.934 --> 00:34:41.067
is going to open a channel
for a specific object.

00:34:41.067 --> 00:34:43.200
When the CommandService
receives that call,

00:34:43.200 --> 00:34:46.701
it's going to store this mapping
from an object ID

00:34:46.701 --> 00:34:48.734
to a list of the clients
that are editing it,

00:34:48.734 --> 00:34:51.834
and the timestamp, so the last
time it's seen that client.

00:34:51.834 --> 00:34:54.434
And it stores this mapping
in Memcache.

00:34:54.434 --> 00:34:56.767
Then, periodically,
the CommandController

00:34:56.767 --> 00:34:59.067
is going to call KeepAlive
in the CommandService

00:34:59.067 --> 00:35:01.367
to let it know that it's
still listening.

00:35:01.367 --> 00:35:03.534
When the service receives
this KeepAlive call,

00:35:03.534 --> 00:35:05.667
it's going to make sure that it
still knows about that client.

00:35:05.667 --> 00:35:07.067
It's going to check
that it has a valid mapping

00:35:07.067 --> 00:35:09.367
for that client
and that object ID,

00:35:09.367 --> 00:35:11.167
and if it does,
it sends an okay.

00:35:11.167 --> 00:35:12.968
If it doesn't,
it sends an error.

00:35:12.968 --> 00:35:14.934
The client,
if it receives an error,

00:35:14.934 --> 00:35:19.934
has to reopen the channel and
then resync the entire object.

00:35:19.934 --> 00:35:23.000
So let's look
at some code now.

00:35:23.000 --> 00:35:25.534
So this is a method
on the CommandService.

00:35:25.534 --> 00:35:27.501
This is open channel
that lets the client register

00:35:27.501 --> 00:35:29.868
for a particular object.

00:35:29.868 --> 00:35:32.434
So the first thing we do here
is we load a mapping

00:35:32.434 --> 00:35:37.834
for the object that we're
interested in out of Memcache.

00:35:37.834 --> 00:35:41.167
And then we have to put
a new entry for the map.

00:35:41.167 --> 00:35:43.701
This is our client ID,
and then the last time

00:35:43.701 --> 00:35:46.968
we've seen or the time that this
method was called here.

00:35:46.968 --> 00:35:49.767
We put that into
our mapping.

00:35:49.767 --> 00:35:53.167
And then next we need to store
the mapping back into Memcache.

00:35:53.167 --> 00:35:55.834
Now, notice that we're using
GetIdentifiable

00:35:55.834 --> 00:35:58.467
and PutIfUntouched
on Memcache here.

00:35:58.467 --> 00:35:59.968
This lets us perform
this whole action

00:35:59.968 --> 00:36:03.200
as an atomic operation
so that another server

00:36:03.200 --> 00:36:05.501
or App Engine instance
cannot modify the mapping

00:36:05.501 --> 00:36:09.267
for this object
as we're doing this.

00:36:09.267 --> 00:36:12.634
So next, let's talk about how
we actually execute a command.

00:36:12.634 --> 00:36:14.067
So the first thing
that happens here

00:36:14.067 --> 00:36:16.701
is that a user performs
some action in the browser.

00:36:16.701 --> 00:36:18.968
And we need to process
this action into a command

00:36:18.968 --> 00:36:21.567
and give it to the command
controller.

00:36:21.567 --> 00:36:23.801
The CommandController
will then call execute command

00:36:23.801 --> 00:36:26.300
on the CommandService,
and that sends it to the server

00:36:26.300 --> 00:36:28.434
over at GWT RPC.

00:36:28.434 --> 00:36:31.267
And then, the CommandService
will execute this command

00:36:31.267 --> 00:36:33.634
via the server side
CommandExcecutors,

00:36:33.634 --> 00:36:36.267
and it gets the result command
and broadcasts it back

00:36:36.267 --> 00:36:38.767
to the appropriate
listening clients.

00:36:38.767 --> 00:36:40.467
Finally, all the clients
that are listening

00:36:40.467 --> 00:36:42.300
for that particular object
receive the command

00:36:42.300 --> 00:36:44.601
over the channel API,
deserialize it,

00:36:44.601 --> 00:36:48.667
and execute it locally.

00:36:48.667 --> 00:36:51.067
So, here we can see
how we execute the command

00:36:51.067 --> 00:36:52.634
on the server.

00:36:52.634 --> 00:36:55.567
The first thing we do is we pass
the command to an executor.

00:36:55.567 --> 00:36:58.701
And, I gloss over how we locate
the particular executor

00:36:58.701 --> 00:37:01.000
we need a little bit,
but typically what you'll have

00:37:01.000 --> 00:37:03.033
is a dictionary of executors
where you look up one

00:37:03.033 --> 00:37:06.901
based on the command type.

00:37:06.901 --> 00:37:09.267
Next, we get the result command
from the executor,

00:37:09.267 --> 00:37:11.634
and we serialize it
via a helper class,

00:37:11.634 --> 00:37:14.167
and I'll go over this helper
class in a second.

00:37:14.167 --> 00:37:16.801
So that gives us a string.

00:37:16.801 --> 00:37:19.100
Then we can load all
the channels that are listening

00:37:19.100 --> 00:37:22.033
for this particular object
out of Memcache.

00:37:22.033 --> 00:37:23.434
And this function here
is a helper

00:37:23.434 --> 00:37:27.734
that just gets the map out
of Memcache like you saw before.

00:37:27.734 --> 00:37:30.868
And finally, once we have
a list of all of our clients,

00:37:30.868 --> 00:37:32.667
we can iterate through them,
and for each one

00:37:32.667 --> 00:37:35.133
we can individually send
the serialized command message

00:37:35.133 --> 00:37:37.033
over the channel API.

00:37:37.033 --> 00:37:43.167
So this is the channel API
call right here, "send message".

00:37:43.167 --> 00:37:45.634
So now let's talk about
how we get GWT serialization

00:37:45.634 --> 00:37:47.701
to work over the channel API.

00:37:47.701 --> 00:37:51.267
So normally GWT serialization
only works for GWT RPC calls,

00:37:51.267 --> 00:37:53.133
and the compiler
takes care of making this

00:37:53.133 --> 00:37:55.734
transparently
happen for you.

00:37:55.734 --> 00:37:57.934
But we can get this to work
with arbitrary strings,

00:37:57.934 --> 00:38:00.267
and then therefore
the channel API.

00:38:00.267 --> 00:38:02.067
So the first thing we have to do
is we have to create

00:38:02.067 --> 00:38:05.067
a dummy method
on the CommandService.

00:38:05.067 --> 00:38:07.868
This dummy method forces GWT
to include the command class

00:38:07.868 --> 00:38:09.901
in the serialization policy.

00:38:09.901 --> 00:38:11.234
So you can see
we have a snippet

00:38:11.234 --> 00:38:13.434
of the CommandService
interface here.

00:38:13.434 --> 00:38:16.167
And we've defined a method
literally named dummy method

00:38:16.167 --> 00:38:18.067
that just returns
a command.

00:38:18.067 --> 00:38:20.167
So the implementation of this
doesn't do anything,

00:38:20.167 --> 00:38:21.434
because it's never called,

00:38:21.434 --> 00:38:24.534
but we need it to be able
to serialize the object.

00:38:24.534 --> 00:38:28.000
After that, we need to locate
the RPC manifest file,

00:38:28.000 --> 00:38:30.834
which will help us load
the serialization policy file.

00:38:30.834 --> 00:38:32.234
And once we have
those two things,

00:38:32.234 --> 00:38:34.934
the dummy method and
the serialization policy file,

00:38:34.934 --> 00:38:37.534
we can call encode response
for success with our command,

00:38:37.534 --> 00:38:40.501
and it will turn our command
into a string for us,

00:38:40.501 --> 00:38:43.834
and then that's what we send
over the channel API.

00:38:43.834 --> 00:38:46.167
On the client, things are
a little bit simpler.

00:38:46.167 --> 00:38:47.934
We can simply cast
our CommandService to

00:38:47.934 --> 00:38:50.234
a SerializationStreamFactory.

00:38:50.234 --> 00:38:51.300
From the StreamFactory,

00:38:51.300 --> 00:38:52.968
we can give it
our serialized message

00:38:52.968 --> 00:38:54.601
and it will give us
a stream reader,

00:38:54.601 --> 00:39:00.033
and then we can call read object
and get our command object back.

00:39:00.033 --> 00:39:02.734
So here's the code on
how to do serialization.

00:39:02.734 --> 00:39:05.467
On the server, we have
a command serializer class.

00:39:05.467 --> 00:39:06.868
The first couple lines here,

00:39:06.868 --> 00:39:09.267
we're just loading the dummy
method via Reflection,

00:39:09.267 --> 00:39:10.968
and then using
some file system operations

00:39:10.968 --> 00:39:13.434
to load
the serialization policy.

00:39:13.434 --> 00:39:15.334
In your project,
you'll have to include

00:39:15.334 --> 00:39:17.334
the serialization policy
in your build, you know,

00:39:17.334 --> 00:39:19.067
ant or something like
that to be able to get in,

00:39:19.067 --> 00:39:20.601
so I left that out here.

00:39:20.601 --> 00:39:22.067
But once we have those,

00:39:22.067 --> 00:39:24.400
then you see we can call
encode response for success

00:39:24.400 --> 00:39:27.868
with the command object,
and we get a string.

00:39:27.868 --> 00:39:30.501
On the client side, we have
the command deserializer.

00:39:30.501 --> 00:39:31.767
Here we're casting
our service

00:39:31.767 --> 00:39:35.267
to a SerializationStreamFactory.

00:39:35.267 --> 00:39:36.734
Here we're using
the StreamFactory

00:39:36.734 --> 00:39:39.501
to create a stream reader
out of the message.

00:39:39.501 --> 00:39:41.300
And then finally
we can call read object,

00:39:41.300 --> 00:39:45.033
and we get a command object
back.

00:39:45.033 --> 00:39:46.934
So, I hope that was
an incredibly brief

00:39:46.934 --> 00:39:49.367
but hopefully helpful overview
on how to implement

00:39:49.367 --> 00:39:53.334
real-time collaboration
on App Engine using GWT.

00:39:53.334 --> 00:39:54.567
So, quick summary here.

00:39:54.567 --> 00:39:56.234
So, the first thing we did
is we had to build

00:39:56.234 --> 00:39:59.400
this map of clients and objects
they're listening to

00:39:59.400 --> 00:40:01.334
and we stored
that in Memcache.

00:40:01.334 --> 00:40:02.701
Then we need to be
able to serialize

00:40:02.701 --> 00:40:05.000
and deserialize objects,
and we forced GWT

00:40:05.000 --> 00:40:07.033
to let us do this by creating
this dummy method,

00:40:07.033 --> 00:40:09.200
and then finally we need
to be able to execute commands

00:40:09.200 --> 00:40:11.400
and dispatch them
to the correct clients.

00:40:11.400 --> 00:40:15.267
We use that mapping that
we established in Step 1.

00:40:15.267 --> 00:40:17.467
So I think this is a great
enterprise feature actually,

00:40:17.467 --> 00:40:20.234
and I hope that you consider
using the channel API.

00:40:20.234 --> 00:40:21.767
It opens this up to a lot
more applications

00:40:21.767 --> 00:40:25.467
and developers than may have
previously considered it.

00:40:25.467 --> 00:40:29.667
Thanks, and I'll hand it
back off to Ben.

00:40:29.667 --> 00:40:31.567
Fried: Thanks.

00:40:31.567 --> 00:40:39.234
[applause]

00:40:39.234 --> 00:40:42.734
So I asked the App Engine team
last week

00:40:42.734 --> 00:40:44.968
approximately how many apps
does Google itself have

00:40:44.968 --> 00:40:46.067
running on App Engine?

00:40:46.067 --> 00:40:48.167
I guess in Hollywood
they like to say,

00:40:48.167 --> 00:40:49.467
"Everyone wants to direct."

00:40:49.467 --> 00:40:51.167
I think at Google,
everyone wants to write code.

00:40:51.167 --> 00:40:53.200
Maybe everyone wants
to write App Engine code.

00:40:53.200 --> 00:40:54.767
The reason I say
that is that the answer

00:40:54.767 --> 00:40:56.534
I got from the App Engine
team is that,

00:40:56.534 --> 00:40:58.234
if you look across
all the different environments

00:40:58.234 --> 00:40:59.734
and all the different users,

00:40:59.734 --> 00:41:03.267
there's something north of
10,000 unique application IDs

00:41:03.267 --> 00:41:05.434
that are assigned
to Google purposes.

00:41:05.434 --> 00:41:06.968
I wouldn't claim
that that means

00:41:06.968 --> 00:41:08.968
there's 10,000 production
applications running

00:41:08.968 --> 00:41:10.467
on App Engine for Google;
far from it.

00:41:10.467 --> 00:41:13.067
A lot of that
is individual experimentation,

00:41:13.067 --> 00:41:15.634
small tools, testing,
things like that,

00:41:15.634 --> 00:41:18.634
but hopefully, that number
gives you a sense of the scale

00:41:18.634 --> 00:41:20.501
and the way in which Google
is using App Engine

00:41:20.501 --> 00:41:22.100
for its own purposes.

00:41:22.100 --> 00:41:25.968
And, you know, it's based on
that experience that we've got

00:41:25.968 --> 00:41:28.868
that Justin, Eric,
and Justin gave you

00:41:28.868 --> 00:41:30.601
some tips based
on their experience,

00:41:30.601 --> 00:41:32.734
a lot of cumulative wisdom

00:41:32.734 --> 00:41:34.167
of how to get useful things
done

00:41:34.167 --> 00:41:35.934
for the enterprise
with App Engine.

00:41:35.934 --> 00:41:38.834
Hopefully you found that useful
and then you can tie that back

00:41:38.834 --> 00:41:40.400
to those arguments
I was making about

00:41:40.400 --> 00:41:42.667
why App Engine is this great
enterprise tool

00:41:42.667 --> 00:41:44.434
at the beginning.

00:41:44.434 --> 00:41:47.000
So, one thing to note
before we take Q&amp;A,

00:41:47.000 --> 00:41:48.567
some good news
for all of you

00:41:48.567 --> 00:41:51.267
is that we've posted sample
code for all the patterns

00:41:51.267 --> 00:41:53.601
that we went over,
for--for these five patterns.

00:41:53.601 --> 00:41:55.601
There's sample code
for all of them available

00:41:55.601 --> 00:41:56.701
on code.google.com.

00:41:56.701 --> 00:41:57.968
You can look
for them there.

00:41:57.968 --> 00:42:02.534
I think the--our sample code
continues to get better.

00:42:02.534 --> 00:42:04.868
We're going to post more online
over the next couple days,

00:42:04.868 --> 00:42:06.300
but it's a lot there.

00:42:06.300 --> 00:42:07.968
Take note of the URL,

00:42:07.968 --> 00:42:10.267
and Simian and a handful
of other projects

00:42:10.267 --> 00:42:12.534
that we run on App Engine
are fully open source

00:42:12.534 --> 00:42:13.968
and available for you
to download,

00:42:13.968 --> 00:42:16.334
and you know,
copy, duplicate,

00:42:16.334 --> 00:42:19.601
use in your own environment
as you see fit.

00:42:19.601 --> 00:42:21.501
With that, I think we're ready
to take questions.

00:42:21.501 --> 00:42:23.767
If anyone has questions,
please come to one of the mics

00:42:23.767 --> 00:42:27.133
so that you can be recorded
on video for,

00:42:27.133 --> 00:42:30.734
you know, all of history.

00:42:30.734 --> 00:42:33.901
Oh, and people here will tend
to shoot T-shirts at you

00:42:33.901 --> 00:42:38.067
while you do that, so...

00:42:38.067 --> 00:42:41.367
man: So, I work in Detroit
in the automotive industry,

00:42:41.367 --> 00:42:43.834
and we have a lot of--
we can generate a lot of data.

00:42:43.834 --> 00:42:47.167
32 gigs, 64 gigs can be
a common use case

00:42:47.167 --> 00:42:48.334
for some of our customers.

00:42:48.334 --> 00:42:50.934
And we need to do
some processing

00:42:50.934 --> 00:42:53.334
on that in the Cloud,
so App Engine sounds like

00:42:53.334 --> 00:42:54.667
it'd be great for me.

00:42:54.667 --> 00:42:57.601
But I'm wondering
why should I use App Engine

00:42:57.601 --> 00:43:01.667
and not something like
Amazon EC2 to do my processing

00:43:01.667 --> 00:43:04.267
when I have a lot more control
with EC2?

00:43:04.267 --> 00:43:06.767
I'm kind of wondering
which direction to go with,

00:43:06.767 --> 00:43:08.000
if you could offer me some...
Fried: Right.

00:43:08.000 --> 00:43:10.067
man: You know,
convince me, I guess.

00:43:10.067 --> 00:43:11.334
Fried: We have
some of our friends

00:43:11.334 --> 00:43:13.000
from the App Engine team
here to talk about it.

00:43:13.000 --> 00:43:14.100
This is Greg Dalesandre,

00:43:14.100 --> 00:43:15.634
but can I take
the first shot at it,

00:43:15.634 --> 00:43:16.667
and you can tell me
if I screw it up?

00:43:16.667 --> 00:43:17.667
Dalesandre: Okay.

00:43:17.667 --> 00:43:19.133
Fried: Okay, so, I mean,
as CIO guy,

00:43:19.133 --> 00:43:21.367
let me give you my perspective
on why App Engine is better.

00:43:21.367 --> 00:43:24.601
It goes back to that third
point that I made, right?

00:43:24.601 --> 00:43:26.667
I mean, you can...

00:43:26.667 --> 00:43:28.534
you know, if you want
the abstraction

00:43:28.534 --> 00:43:31.567
of some virtualized version
of bare iron,

00:43:31.567 --> 00:43:33.667
you can have that,
but with great control

00:43:33.667 --> 00:43:36.200
comes great responsibility.

00:43:36.200 --> 00:43:38.734
I might rather not worry
about that responsibility.

00:43:38.734 --> 00:43:41.200
I might rather worry about
solving the actual problems

00:43:41.200 --> 00:43:44.067
that we've got
and allow the Google SREs

00:43:44.067 --> 00:43:46.801
to worry about keeping all
that stuff running yourself.

00:43:46.801 --> 00:43:48.634
I mean, if you're getting
virtualized bare metal,

00:43:48.634 --> 00:43:50.033
you've got to build
that complete hosting

00:43:50.033 --> 00:43:52.467
environment yourself,
monitor it yourself.

00:43:52.467 --> 00:43:54.033
You know, you have
to worry about kind of

00:43:54.033 --> 00:43:56.667
provisioning mechanisms
and so on.

00:43:56.667 --> 00:43:59.367
You know, I mean, it's--
I view that as kind of

00:43:59.367 --> 00:44:01.534
the assembly language
of cloud hosting,

00:44:01.534 --> 00:44:02.934
and, yes,
in assembly language,

00:44:02.934 --> 00:44:05.501
you can make a machine do
exactly what you want it to do,

00:44:05.501 --> 00:44:07.367
but, you know,

00:44:07.367 --> 00:44:09.367
we all want to move on
and operate at a higher level.

00:44:09.367 --> 00:44:11.968
That's my take on it.
Greg, did you...

00:44:11.968 --> 00:44:14.133
Dalesandre: Yeah.
What he said, um...

00:44:14.133 --> 00:44:17.534
But, in all seriousness, I--
a lot of our customers

00:44:17.534 --> 00:44:19.868
that we talk to initially start
using App Engine

00:44:19.868 --> 00:44:23.100
because the scaling
seemed appealing to them.

00:44:23.100 --> 00:44:26.834
And in the end, what they found
that they really actually loved

00:44:26.834 --> 00:44:29.801
about App Engine was the fact
that they didn't have to have

00:44:29.801 --> 00:44:31.934
a team of people maintaining,
and, you know,

00:44:31.934 --> 00:44:33.367
every new update
that came around,

00:44:33.367 --> 00:44:34.767
they have to apply
the new updates.

00:44:34.767 --> 00:44:37.033
And I've worked
at a bunch of start-ups,

00:44:37.033 --> 00:44:39.234
and I know what happens
at start-ups all the time

00:44:39.234 --> 00:44:41.434
is--is, you know,
you'll build something,

00:44:41.434 --> 00:44:43.133
and then as soon as
it starts scaling,

00:44:43.133 --> 00:44:45.367
you're scrambling
to try to figure out

00:44:45.367 --> 00:44:47.100
you know, how to--
how to, um,

00:44:47.100 --> 00:44:48.501
keep things alive.

00:44:48.501 --> 00:44:50.667
And so it's that, like,
not needing to worry

00:44:50.667 --> 00:44:55.634
about patching things or
figuring out who's managing it

00:44:55.634 --> 00:44:57.400
or who's carrying the pager
and all those things

00:44:57.400 --> 00:45:00.167
that I think is why
you'd use App Engine

00:45:00.167 --> 00:45:01.634
instead of just
the bare metal.

00:45:01.634 --> 00:45:03.501
Fried: I mean, since we started
using App Engine,

00:45:03.501 --> 00:45:06.601
I think we've net added
no system administrators

00:45:06.601 --> 00:45:09.701
to the teams that support this
fleet of corporate applications.

00:45:09.701 --> 00:45:11.400
Right? And that's a pretty
powerful statement.

00:45:11.400 --> 00:45:12.634
I might be off
by one or two,

00:45:12.634 --> 00:45:20.334
but that's kind of
directionally right.

00:45:20.334 --> 00:45:22.167
Schoeffler: You got
one more over here.

00:45:22.167 --> 00:45:23.434
Oh.

00:45:23.434 --> 00:45:26.767
man: Oh, oh.

00:45:26.767 --> 00:45:30.934
Fagnani: Quick,
shut off the camera.

00:45:30.934 --> 00:45:32.601
man: I have a question
on the channel example

00:45:32.601 --> 00:45:34.000
that was given.

00:45:34.000 --> 00:45:37.467
I started using Memcache
to store the list of clients

00:45:37.467 --> 00:45:39.701
that we're connecting.

00:45:39.701 --> 00:45:43.267
What happens when, you know,
it's no longer in Memcache?

00:45:43.267 --> 00:45:45.601
Fagnani: That's a really
good question.

00:45:45.601 --> 00:45:47.701
So, there's a couple of things
to understand

00:45:47.701 --> 00:45:48.734
about the channel API.

00:45:48.734 --> 00:45:49.901
The first thing
is that a channel

00:45:49.901 --> 00:45:52.400
is only valid
for two hours.

00:45:52.400 --> 00:45:54.501
You get a token,
send it to the client,

00:45:54.501 --> 00:45:56.334
and then it opens
the channel, right?

00:45:56.334 --> 00:45:59.801
So your channels are basically
going to be going away anyway.

00:45:59.801 --> 00:46:02.534
And Memcache ends up
being fairly stable,

00:46:02.534 --> 00:46:06.367
so the choice I made here
is that, you know, assume

00:46:06.367 --> 00:46:07.701
that the channels
can come and go,

00:46:07.701 --> 00:46:09.767
and that you need to build
a resyncing mechanism

00:46:09.767 --> 00:46:11.667
for your object,
so that you can open the channel

00:46:11.667 --> 00:46:13.167
and download
the whole object again.

00:46:13.167 --> 00:46:14.868
Once you make that assumption,
you know,

00:46:14.868 --> 00:46:16.567
whether or not Memcache
gets cleared

00:46:16.567 --> 00:46:17.834
doesn't really matter.

00:46:17.834 --> 00:46:19.934
And the fact that it's faster
and simpler

00:46:19.934 --> 00:46:22.701
was an advantage over
storing these in Datastore.

00:46:22.701 --> 00:46:26.000
You could certainly store
these mappings in Datastore,

00:46:26.000 --> 00:46:28.300
cache them in Memcache,
and use a two-layer mechanism

00:46:28.300 --> 00:46:31.834
to get to them, but I don't know
if it's actually worth it.

00:46:31.834 --> 00:46:35.100
man: So the channel API then
wouldn't really be used

00:46:35.100 --> 00:46:37.400
to allow--
I'm just thinking like--

00:46:37.400 --> 00:46:40.767
for developing, like,
a Google Docs type thing?

00:46:40.767 --> 00:46:43.300
For collaboration, you know,
and people that could be,

00:46:43.300 --> 00:46:47.234
you know, in there for, you
know, their entire workday.

00:46:47.234 --> 00:46:49.767
I mean, if there's
a two-hour limit, or can--

00:46:49.767 --> 00:46:51.934
every time it's used,
is it extended for,

00:46:51.934 --> 00:46:53.334
you know,
another period?

00:46:53.334 --> 00:46:55.300
Fagnani: No, it doesn't
extend it for another period,

00:46:55.300 --> 00:46:58.200
but basically, you know,
you're on a network,

00:46:58.200 --> 00:46:59.934
you have connectivity issues,
right?

00:46:59.934 --> 00:47:02.067
The laptop might close,
it might go off the network,

00:47:02.067 --> 00:47:03.234
things like that.

00:47:03.234 --> 00:47:04.901
So you have to build
in this mechanism

00:47:04.901 --> 00:47:07.734
to be able to say, okay,
we got disconnected,

00:47:07.734 --> 00:47:09.534
and we might have missed
a whole bunch of commands.

00:47:09.534 --> 00:47:12.067
We need to resync
the entire object.

00:47:12.067 --> 00:47:15.200
And if you have, you know,
an easy way to do that,

00:47:15.200 --> 00:47:16.767
then these other concerns
kind of go away,

00:47:16.767 --> 00:47:19.067
because you can say, Oh,
we might have lost a connection.

00:47:19.067 --> 00:47:21.601
Just reset the object.

00:47:21.601 --> 00:47:24.100
So that's the kind of philosophy
I've taken there.

00:47:24.100 --> 00:47:25.801
So I think
that two-hour token window

00:47:25.801 --> 00:47:27.634
doesn't really matter either.

00:47:27.634 --> 00:47:28.634
man: Okay, thanks.

00:47:28.634 --> 00:47:31.167
Fagnani: Welcome.

00:47:31.167 --> 00:47:33.467
man: We developed enterprise
mobile applications

00:47:33.467 --> 00:47:35.701
that often require
a middleware of some sort,

00:47:35.701 --> 00:47:38.734
and our customers say we need
to be able to support it,

00:47:38.734 --> 00:47:40.734
much like the first question
that was asked.

00:47:40.734 --> 00:47:42.234
What kind of guidance
can you give us

00:47:42.234 --> 00:47:45.801
for folks who don't want to
kind of relinquish that control,

00:47:45.801 --> 00:47:48.634
but want the flexibility
of what App Engine offers?

00:47:48.634 --> 00:47:50.100
And being the developers
that we are,

00:47:50.100 --> 00:47:52.534
how do we kind of
message this

00:47:52.534 --> 00:47:54.534
and try and get through
the download app engine?

00:47:54.534 --> 00:47:55.934
What kind of guidance there?

00:47:55.934 --> 00:47:57.767
Fried: I didn't quite
understand the point,

00:47:57.767 --> 00:48:01.734
the middleware-related
to control point.

00:48:01.734 --> 00:48:03.901
Is the idea that people want
to run the middleware

00:48:03.901 --> 00:48:06.200
in their own kind
of data center?

00:48:06.200 --> 00:48:08.067
man: Exactly.

00:48:08.067 --> 00:48:09.968
To be able to structure it,
and be able to control

00:48:09.968 --> 00:48:14.667
and support it from there.

00:48:14.667 --> 00:48:17.868
Fried: I mean, I'm--
I don't think I--

00:48:17.868 --> 00:48:20.267
I may not fully
understand the question,

00:48:20.267 --> 00:48:23.167
but, I mean, I think
there are a few options

00:48:23.167 --> 00:48:24.601
that are available to you.

00:48:24.601 --> 00:48:29.000
One is you can have the same app
running on App Engine

00:48:29.000 --> 00:48:31.667
in Google's Cloud and running,
you know, more or less

00:48:31.667 --> 00:48:33.434
in some other internal
environment.

00:48:33.434 --> 00:48:35.200
There are App Engine
emulation systems

00:48:35.200 --> 00:48:36.567
that you can get
to run inside,

00:48:36.567 --> 00:48:38.567
and that way people can kind
of get their feet wet

00:48:38.567 --> 00:48:40.033
with both environments, right,

00:48:40.033 --> 00:48:42.334
and understand
the benefits of one

00:48:42.334 --> 00:48:44.000
and the costs of the other
and so on.

00:48:44.000 --> 00:48:45.901
It's really, really easy
to make that migration,

00:48:45.901 --> 00:48:47.334
especially if you make
the decision

00:48:47.334 --> 00:48:49.567
from the beginning to code
for App Engine, right?

00:48:49.567 --> 00:48:51.200
I mean, the thing
you really need to learn

00:48:51.200 --> 00:48:53.033
is you need to--
to code for App Engine

00:48:53.033 --> 00:48:54.367
is you need to think
through things like

00:48:54.367 --> 00:48:55.901
your data
integration issues,

00:48:55.901 --> 00:48:57.400
and, you know, what storage
techniques you're going to use,

00:48:57.400 --> 00:48:59.100
but if you make the decision
that it's going to be

00:48:59.100 --> 00:49:00.868
an App Engine app,
maybe you know,

00:49:00.868 --> 00:49:03.000
whether or not you host it,
and from day--

00:49:03.000 --> 00:49:04.734
where--no matter how
you host it from day one,

00:49:04.734 --> 00:49:06.467
that's going to make it very,
very easy to move in

00:49:06.467 --> 00:49:07.934
and kind of get people
to do that.

00:49:07.934 --> 00:49:11.267
I think once you start trying
to run an app engine, you know,

00:49:11.267 --> 00:49:14.501
to answer the first person's
point about control--

00:49:14.501 --> 00:49:17.534
Control is also
highly illusory, right?

00:49:17.534 --> 00:49:19.934
I mean, I've had lots of
conversations with people

00:49:19.934 --> 00:49:22.868
from a previous job of mine,
in fact.

00:49:22.868 --> 00:49:24.400
You know, people think
because stuff

00:49:24.400 --> 00:49:26.133
runs in their data centers,
they have a lot of control

00:49:26.133 --> 00:49:27.968
and they don't necessarily
realize how many people

00:49:27.968 --> 00:49:29.734
have keycard access
to their data centers,

00:49:29.734 --> 00:49:32.167
or what happens to tapes
when they move off site,

00:49:32.167 --> 00:49:34.601
or how do I know someone
didn't pull that disk out,

00:49:34.601 --> 00:49:36.701
or how do I actually know
everyone who was rude

00:49:36.701 --> 00:49:40.033
on my systems, or you know--
control is also great

00:49:40.033 --> 00:49:41.868
until you have some massive
data center failure,

00:49:41.868 --> 00:49:44.067
and then it's all your fault,
too, right?

00:49:44.067 --> 00:49:46.567
So, um...

00:49:46.567 --> 00:49:48.334
control has pluses
and minuses.

00:49:48.334 --> 00:49:51.367
I think that the economies
of scale that you get

00:49:51.367 --> 00:49:53.601
from, you know, the expertise
of cloud hosting

00:49:53.601 --> 00:49:55.701
and kind of the dynamic
scalability you get from it

00:49:55.701 --> 00:49:59.234
make the App Engine choice
really, really compelling.

00:49:59.234 --> 00:50:01.334
And people discover that
after they start to use it.

00:50:01.334 --> 00:50:04.167
Greg, did you have...

00:50:04.167 --> 00:50:05.634
Dalesandre: No, again.

00:50:05.634 --> 00:50:07.767
I think Ben handled
the question well.

00:50:07.767 --> 00:50:09.868
Ooh!
Oh, yeah, look at that.

00:50:09.868 --> 00:50:12.200
Um...yeah, again,

00:50:12.200 --> 00:50:13.901
I don't know
if that answered the question,

00:50:13.901 --> 00:50:18.133
but there are a number of people
who essentially ease into it,

00:50:18.133 --> 00:50:20.934
because one of the things
that, you know, it's really easy

00:50:20.934 --> 00:50:22.601
after you've been using
App Engine for a while

00:50:22.601 --> 00:50:27.400
to understand how there are
things that you want to tackle,

00:50:27.400 --> 00:50:28.968
and then there are things
you want somebody else

00:50:28.968 --> 00:50:30.267
to tackle, right?

00:50:30.267 --> 00:50:32.334
You know, you want
to worry about--

00:50:32.334 --> 00:50:35.434
about essentially
the useful part

00:50:35.434 --> 00:50:37.667
of the development,
not necessarily the part

00:50:37.667 --> 00:50:43.167
where it's not only useful
for you to sort of manage

00:50:43.167 --> 00:50:45.968
your own machines,
it's, um, it's also--

00:50:45.968 --> 00:50:47.634
I think, an area

00:50:47.634 --> 00:50:49.133
that you have to
build up expertise in

00:50:49.133 --> 00:50:51.901
that's not an important
sort of core competency

00:50:51.901 --> 00:50:53.601
of your organization.

00:50:53.601 --> 00:50:56.367
And so, it's only when you
sort of start getting into that

00:50:56.367 --> 00:50:58.634
for a while that you start
to understand,

00:50:58.634 --> 00:51:02.133
when you're running on something
like App Engine as a platform,

00:51:02.133 --> 00:51:04.133
that you don't need to deal
with those things anymore.

00:51:04.133 --> 00:51:09.267
It becomes just very--
you realize the advantage of it.

00:51:09.267 --> 00:51:11.000
I don't know if that
makes sense, though. Is that--

00:51:11.000 --> 00:51:12.000
man: Yeah, that's helpful.

00:51:12.000 --> 00:51:16.667
Dalesandre: Okay.
man: Thanks.

00:51:16.667 --> 00:51:20.968
all: Oh!

00:51:20.968 --> 00:51:22.234
Dalesandre: Are you
all right?

00:51:22.234 --> 00:51:26.200
Fried: Too much caffeine.

00:51:26.200 --> 00:51:29.734
man: We developed lots of apps
on App Engine

00:51:29.734 --> 00:51:32.100
for our clients
in South America,

00:51:32.100 --> 00:51:36.067
fairly large clients
with 10,000 users.

00:51:36.067 --> 00:51:40.634
And most of the time,
when we are previewing the work,

00:51:40.634 --> 00:51:42.901
most of our clients
ask about security.

00:51:42.901 --> 00:51:45.567
You know, how much secure
would the app be in their hands.

00:51:45.567 --> 00:51:47.634
How should we address
our clients

00:51:47.634 --> 00:51:50.567
about security
of Google App Engine?

00:51:50.567 --> 00:51:53.934
Fried: So, I mean, I am,
as Google's CIO,

00:51:53.934 --> 00:51:55.501
I get asked that question
a lot by people

00:51:55.501 --> 00:51:57.701
who are interested in Google's
cloud applications

00:51:57.701 --> 00:51:59.133
and cloud technologies,

00:51:59.133 --> 00:52:02.467
and here's my perspective
on it, right?

00:52:02.467 --> 00:52:05.634
Is that, um...

00:52:05.634 --> 00:52:08.234
Google is a great place
for security people to work,

00:52:08.234 --> 00:52:09.601
because, you know,

00:52:09.601 --> 00:52:11.267
everyone wants
to attack us, right?

00:52:11.267 --> 00:52:14.834
And so as a result, the best
security people in the world

00:52:14.834 --> 00:52:16.400
come to us, right?

00:52:16.400 --> 00:52:17.767
And we get--
there's this ec--

00:52:17.767 --> 00:52:19.100
it's not just
an economy of scale,

00:52:19.100 --> 00:52:21.067
it's a benefit of scale
that we get, right?

00:52:21.067 --> 00:52:22.934
That it's, uh...

00:52:22.934 --> 00:52:24.000
it is, you know--

00:52:24.000 --> 00:52:25.367
and previous
to working at Google,

00:52:25.367 --> 00:52:26.834
I worked in the financial
services industry,

00:52:26.834 --> 00:52:29.267
where we had certain ways
we could incent really talented

00:52:29.267 --> 00:52:31.000
people to work for us.

00:52:31.000 --> 00:52:34.801
But even so, you know,
my experience is,

00:52:34.801 --> 00:52:37.400
it's very, very hard,
even for great companies

00:52:37.400 --> 00:52:39.634
that don't have this kind of
profile that Google does,

00:52:39.634 --> 00:52:41.868
to attract the kind of security
people they need

00:52:41.868 --> 00:52:43.868
to really be able to make
hard guarantees

00:52:43.868 --> 00:52:45.634
about what security means
or not.

00:52:45.634 --> 00:52:48.567
The thing about Google is that
security is so important to us,

00:52:48.567 --> 00:52:50.167
it really is part
of our business.

00:52:50.167 --> 00:52:52.601
We hire the best people
in the world to work on it.

00:52:52.601 --> 00:52:54.267
They're attracted
as great people come up

00:52:54.267 --> 00:52:57.267
that want to work here
for us at Google, right?

00:52:57.267 --> 00:52:58.868
And they keep on
getting better.

00:52:58.868 --> 00:53:00.434
What we keep on doing
keeps on getting better.

00:53:00.434 --> 00:53:02.200
Security is part
of our business.

00:53:02.200 --> 00:53:04.133
For, you know,
for other companies,

00:53:04.133 --> 00:53:05.534
you know,
for your clients,

00:53:05.534 --> 00:53:08.000
it's a tax to secure
their own corporate networks

00:53:08.000 --> 00:53:09.267
and enterprises, right?

00:53:09.267 --> 00:53:11.601
And taxes are things
people prefer not to pay.

00:53:11.601 --> 00:53:13.601
For us,
it's a business benefit.

00:53:13.601 --> 00:53:14.868
It's something
we need to do.

00:53:14.868 --> 00:53:16.634
It's something
we need to be excellent at

00:53:16.634 --> 00:53:18.501
in order to be the business
that we're in.

00:53:18.501 --> 00:53:21.701
So my argument is that,
you know, over time, actually,

00:53:21.701 --> 00:53:23.167
you know,
the big cloud providers

00:53:23.167 --> 00:53:25.567
will have this incredible
advantage in security

00:53:25.567 --> 00:53:28.133
that even great enterprises
won't be able to have,

00:53:28.133 --> 00:53:29.601
just, you know,
given the nature

00:53:29.601 --> 00:53:31.334
of the way
the world is working.

00:53:31.334 --> 00:53:34.133
man: Are you guys thinking about
some sort of certification,

00:53:34.133 --> 00:53:37.234
like SAS 70, or whatever?

00:53:37.234 --> 00:53:40.067
Dalesandre: Um, so...
we're currently working

00:53:40.067 --> 00:53:41.601
on SAS 70 certification.

00:53:41.601 --> 00:53:42.934
Um, we, uh...

00:53:42.934 --> 00:53:44.934
I believe the stage
we're in right now

00:53:44.934 --> 00:53:47.834
is that we've, um,
we've gotten to the point

00:53:47.834 --> 00:53:49.400
where we've satisfied
the criteria,

00:53:49.400 --> 00:53:50.801
but then you have to do
a review later

00:53:50.801 --> 00:53:52.167
to actually get
the certification.

00:53:52.167 --> 00:53:55.033
So we're--the review comes,
I believe, a year later.

00:53:55.033 --> 00:53:57.167
And so, we're
in that waiting period

00:53:57.167 --> 00:54:01.133
after we've hit the cert--
the requirements

00:54:01.133 --> 00:54:02.667
when you're waiting
for the review.

00:54:02.667 --> 00:54:04.801
So, certification,
absolutely.

00:54:04.801 --> 00:54:06.801
The other thing I would say,
just to Ben's point,

00:54:06.801 --> 00:54:09.300
is that App Engine was built
with security in mind

00:54:09.300 --> 00:54:10.534
from the beginning.

00:54:10.534 --> 00:54:12.701
A lot of the limitations
that people didn't like

00:54:12.701 --> 00:54:16.868
about, you know, time limits,
those sorts of things,

00:54:16.868 --> 00:54:18.901
the reason we did all of that
is because

00:54:18.901 --> 00:54:21.868
from the very beginning we knew
that we had to build something

00:54:21.868 --> 00:54:24.801
that was sand-boxed
in such a way

00:54:24.801 --> 00:54:28.701
that there was no risk ever
of any sort of, essentially,

00:54:28.701 --> 00:54:30.267
security problems happening.

00:54:30.267 --> 00:54:34.367
And we've had an incredible
track record because of that,

00:54:34.367 --> 00:54:36.167
because we built it
from the ground up,

00:54:36.167 --> 00:54:38.934
assuming we needed
to have security in mind.

00:54:38.934 --> 00:54:43.934
Fried: Yeah.
man: Thank you.

00:54:43.934 --> 00:54:46.400
woman: Hi, this
is great stuff.

00:54:46.400 --> 00:54:49.234
I work at Chalet Tech,
and we actually are building

00:54:49.234 --> 00:54:52.033
lots and lots of apps
on App Engine,

00:54:52.033 --> 00:54:56.133
and we've run out of our
ten-per-user quota.

00:54:56.133 --> 00:54:58.567
Is there--I mean,
what we really want to do

00:54:58.567 --> 00:55:01.434
is sort of have either
an account whitelisted,

00:55:01.434 --> 00:55:06.634
so that it could create like an
advent account or subs account.

00:55:06.634 --> 00:55:09.601
Is that the model going forward,
or is there going to be

00:55:09.601 --> 00:55:14.000
more flexibility on users
being able to create more apps?

00:55:14.000 --> 00:55:17.067
Dalesandre: So we just
talked yesterday--

00:55:17.067 --> 00:55:18.734
I don't know if you guys
want to know--

00:55:18.734 --> 00:55:20.267
but we just
announced yesterday

00:55:20.267 --> 00:55:22.634
that we'll be leaving preview
later on this year,

00:55:22.634 --> 00:55:25.667
and when we do, we're
introducing a new account type,

00:55:25.667 --> 00:55:27.200
which will allow you
to essentially get

00:55:27.200 --> 00:55:29.968
as many apps as you want
and operational support

00:55:29.968 --> 00:55:32.033
for $500 per month.

00:55:32.033 --> 00:55:34.400
And I imagine that's probably
what you guys would want to do.

00:55:34.400 --> 00:55:35.467
woman: Yes. Yeah.
Thank you.

00:55:35.467 --> 00:55:36.501
Dalesandre: We can
talk afterwards

00:55:36.501 --> 00:55:38.934
to get you apps
ahead of time,

00:55:38.934 --> 00:55:41.200
you know, before
that goes online though.

00:55:41.200 --> 00:55:44.834
woman: Okay, thank you.

00:55:44.834 --> 00:55:46.300
man: Just a very simple
question.

00:55:46.300 --> 00:55:51.767
Do you have any insights to get
App Engine to work in China?

00:55:51.767 --> 00:55:53.801
McWilliams: It works
in China for Simian.

00:55:53.801 --> 00:55:56.934
We update all of our OSX clients
that are in China with Simian,

00:55:56.934 --> 00:55:59.868
so what restrictions
are you seeing?

00:55:59.868 --> 00:56:02.567
man: We built a few applications
on App Engine,

00:56:02.567 --> 00:56:06.367
and they--they work good
outside China,

00:56:06.367 --> 00:56:13.067
but they--the access to them
are blocked in China.

00:56:13.067 --> 00:56:15.701
Dalesandre: So, it's, um...

00:56:15.701 --> 00:56:17.801
there might be
restrictions in place

00:56:17.801 --> 00:56:22.834
for some of the ISPs that people
are trying to access it through.

00:56:22.834 --> 00:56:25.934
So I don't know if we can give
a specific answer

00:56:25.934 --> 00:56:28.434
without sort of knowing more
of the specifics around

00:56:28.434 --> 00:56:30.467
sort of what it is
that's not working

00:56:30.467 --> 00:56:33.367
and what you're
trying to do.

00:56:33.367 --> 00:56:36.133
man: Well, it's--
we build...

00:56:36.133 --> 00:56:38.167
[man speaking indistinctly]

00:56:38.167 --> 00:56:39.868
Actually very simple.

00:56:39.868 --> 00:56:44.601
But they are soon to be used
by general consumers in China,

00:56:44.601 --> 00:56:45.801
and--

00:56:45.801 --> 00:56:46.934
Fried: Maybe the thing
for us to do is kind of

00:56:46.934 --> 00:56:48.434
have someone
from the App Engine team

00:56:48.434 --> 00:56:49.534
go offline with you
and have them--

00:56:49.534 --> 00:56:50.834
Dalesandre:
Yeah, I think that--

00:56:50.834 --> 00:56:52.133
We can talk afterwards
about this.

00:56:52.133 --> 00:56:55.901
Fried: And follow up.

00:56:55.901 --> 00:56:58.300
Nomination.

00:56:58.300 --> 00:57:00.934
man: Hi, I have
a short question,

00:57:00.934 --> 00:57:02.334
or two questions.

00:57:02.334 --> 00:57:06.501
Follow up on that 25--or 20--
$500 a month.

00:57:06.501 --> 00:57:10.400
Is that 24/7 phone support?

00:57:10.400 --> 00:57:12.567
Dalesandre: So it is
going to be 24/7 support.

00:57:12.567 --> 00:57:16.901
It's ticket-based support
with a guaranteed response time

00:57:16.901 --> 00:57:19.133
that I'm not going to quote
right now.

00:57:19.133 --> 00:57:23.267
I believe it's eight hours in
response for operational issues,

00:57:23.267 --> 00:57:25.567
and then if you have
developer issues,

00:57:25.567 --> 00:57:29.334
like if you want to ask, "How
should I build X, Y, and Z,"

00:57:29.334 --> 00:57:31.100
you'll be able to pay
per ticket

00:57:31.100 --> 00:57:33.901
for additional
sort of developer support.

00:57:33.901 --> 00:57:35.434
man: So that actually
involves phone?

00:57:35.434 --> 00:57:36.968
You could actually
talk to somebody?

00:57:36.968 --> 00:57:38.734
Dalesandre: So it's tickets,

00:57:38.734 --> 00:57:41.000
and once with
the ticket process,

00:57:41.000 --> 00:57:43.567
they might engage in phone calls
if that's the best way

00:57:43.567 --> 00:57:45.667
to solve the problem,
but it's a ticketing system

00:57:45.667 --> 00:57:48.067
is the way to engage
in the process.

00:57:48.067 --> 00:57:50.133
man: And a different question
is, the Blobstore.

00:57:50.133 --> 00:57:54.534
If you load the data into Python
or whatever,

00:57:54.534 --> 00:57:57.567
how do you search--
like, do you have a SQL language

00:57:57.567 --> 00:57:58.767
to search it, or how?

00:57:58.767 --> 00:58:00.868
That's just
a simple question.

00:58:00.868 --> 00:58:02.067
Schoeffler: So, essentially,

00:58:02.067 --> 00:58:03.767
once you've
pulled it into memory,

00:58:03.767 --> 00:58:06.400
it's just like
a list in memory

00:58:06.400 --> 00:58:09.334
and you can do whatever
you want to with it there.

00:58:09.334 --> 00:58:11.567
It's based on how
you deserialilze it,

00:58:11.567 --> 00:58:14.634
so if you deserialize it into
a list or a map or whatever,

00:58:14.634 --> 00:58:15.868
it's there in memory

00:58:15.868 --> 00:58:18.167
and you can do whatever
you want to with it there.

00:58:18.167 --> 00:58:20.100
man: So you could just use
Python to do it or--

00:58:20.100 --> 00:58:22.033
Schoeffler: You'd have a Python
dictionary in memory

00:58:22.033 --> 00:58:24.934
at that point, yeah.
man: Thank you.

00:58:24.934 --> 00:58:26.267
man: Hi.

00:58:26.267 --> 00:58:29.501
I was more curious
about test patterns you have.

00:58:29.501 --> 00:58:32.834
So you would program to
anticipate possible failures

00:58:32.834 --> 00:58:34.334
in the Cloud somehow,

00:58:34.334 --> 00:58:37.934
or if you guys have
any specific type of suites

00:58:37.934 --> 00:58:40.434
that you're--
uh, code suites

00:58:40.434 --> 00:58:43.334
that you run that you
make in-house to kind of

00:58:43.334 --> 00:58:50.501
mock up these failures
to anticipate it in your code.

00:58:50.501 --> 00:58:52.033
Fagnani: So I do notice
that some people

00:58:52.033 --> 00:58:56.501
use an App Engine app to monitor
other App Engine apps.

00:58:56.501 --> 00:58:59.367
You know, obviously there are
some systematic problems there

00:58:59.367 --> 00:59:00.901
that you could miss
that you monitor

00:59:00.901 --> 00:59:02.033
if an app goes down.

00:59:02.033 --> 00:59:03.901
Um, we--we've...

00:59:03.901 --> 00:59:05.234
created some frameworks
that help us, too,

00:59:05.234 --> 00:59:06.467
like load testing
on App Engine.

00:59:06.467 --> 00:59:07.767
That takes care of, like,

00:59:07.767 --> 00:59:11.033
disabling security
and authorization and stuff.

00:59:11.033 --> 00:59:13.100
In terms of monitoring
App Engine itself,

00:59:13.100 --> 00:59:16.467
I mean, I think that the App
Engine team has--

00:59:16.467 --> 00:59:18.133
Dalesandre: Right.
We're actually going

00:59:18.133 --> 00:59:21.434
into trusted tester program,
well, today

00:59:21.434 --> 00:59:24.634
with a monitoring API
that is in fact one--

00:59:24.634 --> 00:59:27.634
it's an App Engine app
that runs to monitor

00:59:27.634 --> 00:59:30.501
your other App Engine apps,
if that's sort of what

00:59:30.501 --> 00:59:32.601
you're concerned
about in terms of making sure

00:59:32.601 --> 00:59:34.434
that things
are running appropriately

00:59:34.434 --> 00:59:36.534
and sort of within
the parameters you want.

00:59:36.534 --> 00:59:38.267
man: Not so much
in actual run time

00:59:38.267 --> 00:59:39.567
as the development
process.

00:59:39.567 --> 00:59:41.567
Say you want to--say you
want to mock-up a failure

00:59:41.567 --> 00:59:44.167
of the Datastore and then you
want to see how your app would--

00:59:44.167 --> 00:59:45.734
Dalesandre: So--
so we have--

00:59:45.734 --> 00:59:47.934
Right. So we have, like,
unit-testing frameworks

00:59:47.934 --> 00:59:50.267
for both Java and Python
that are online

00:59:50.267 --> 00:59:51.567
if you want to
check those out.

00:59:51.567 --> 00:59:52.968
McWilliams: Yeah.

00:59:52.968 --> 00:59:54.534
When there's Datastore outages,
it's going to throw

00:59:54.534 --> 00:59:56.767
a certain type of exception,
so you can certainly

00:59:56.767 --> 00:59:58.501
write test code that will
throw that exception

00:59:58.501 --> 01:00:00.734
and handle it in
an appropriate manner.

01:00:00.734 --> 01:00:01.767
man: But there's no
standard methods

01:00:01.767 --> 01:00:02.868
how you guys go about it?

01:00:02.868 --> 01:00:04.067
Fagnani: Well, if you use--

01:00:04.067 --> 01:00:05.701
I mean, we use dependency
injection heavily,

01:00:05.701 --> 01:00:06.968
so, you know,

01:00:06.968 --> 01:00:08.534
the way I typically
write an application is that

01:00:08.534 --> 01:00:11.767
I have objects inject the
service that they want to use,

01:00:11.767 --> 01:00:13.567
like the Memcache service
or the Datastore service.

01:00:13.567 --> 01:00:15.334
So in your test,
there's an interface,

01:00:15.334 --> 01:00:17.000
you can just mock it
through a failure.

01:00:17.000 --> 01:00:18.367
man: Okay.
Fagnani: Yeah.

01:00:18.367 --> 01:00:19.767
Fried: I'm sorry,
we're getting the high sign

01:00:19.767 --> 01:00:21.334
that the next team
is to come in and talk,

01:00:21.334 --> 01:00:23.033
but thank you all very much.

01:00:23.033 --> 01:00:24.834
[applause]

