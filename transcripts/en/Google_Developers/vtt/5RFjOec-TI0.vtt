WEBVTT
Kind: captions
Language: en

00:00:01.650 --> 00:00:01.850
DAVID SEHR: OK.

00:00:01.850 --> 00:00:04.059
Can everybody hear me?

00:00:04.059 --> 00:00:05.030
OK, great.

00:00:05.030 --> 00:00:08.540
So welcome to the last talk
of the track today.

00:00:08.540 --> 00:00:10.110
I'm going to give you an
introduction to Portable

00:00:10.110 --> 00:00:12.750
Native Client, or something
we call PNaCl.

00:00:12.750 --> 00:00:13.750
My name's David Sehr.

00:00:13.750 --> 00:00:16.010
I'm the tech lead of the
Native Client team.

00:00:16.010 --> 00:00:17.260
And let's get started.

00:00:23.140 --> 00:00:25.930
So since I'm going to assume
that some of you probably

00:00:25.930 --> 00:00:27.170
haven't heard about Native
Client, I'm going to give you

00:00:27.170 --> 00:00:28.640
a little background
to start with.

00:00:28.640 --> 00:00:30.900
I'm going to talk to you about
Native Client, about why

00:00:30.900 --> 00:00:34.880
having C++ code running it in
the web is a good idea.

00:00:34.880 --> 00:00:36.510
And I'm going to talk to you
about Native Client and how it

00:00:36.510 --> 00:00:40.280
makes it something
we can really do.

00:00:40.280 --> 00:00:43.690
So I don't think I need to tell
most of you, but there's

00:00:43.690 --> 00:00:45.540
a lot of good C++ code
in the world, maybe a

00:00:45.540 --> 00:00:46.900
little bad C++ code.

00:00:46.900 --> 00:00:48.860
But a lot of good C++ code
out in the world.

00:00:48.860 --> 00:00:50.670
People have written a lot of
great applications, things

00:00:50.670 --> 00:00:53.580
that take advantage of sort of
the natural advantages of

00:00:53.580 --> 00:00:54.820
Native Client.

00:00:54.820 --> 00:00:57.370
Things like performance, low
level access to operating

00:00:57.370 --> 00:00:59.870
system features, et cetera to
create a really rich and

00:00:59.870 --> 00:01:01.830
immersive experience.

00:01:01.830 --> 00:01:03.580
These sorts of applications
would be great if we could

00:01:03.580 --> 00:01:04.399
bring them into the web.

00:01:04.399 --> 00:01:07.870
But the problem is you really
can't bring them to the web as

00:01:07.870 --> 00:01:11.120
they are because it's
not really safe.

00:01:11.120 --> 00:01:11.500
Right?

00:01:11.500 --> 00:01:13.430
You bring Native Client to the
web, and you open up all the

00:01:13.430 --> 00:01:15.960
possibilities that we've all
come to know and hate about

00:01:15.960 --> 00:01:20.340
the web, which is insecurity
and all the things that can

00:01:20.340 --> 00:01:22.330
come from that like having your

00:01:22.330 --> 00:01:25.010
identity stolen or whatever.

00:01:25.010 --> 00:01:27.510
So what you'd really like to
have, you'd like to be able to

00:01:27.510 --> 00:01:30.110
bring Native Client to the web,
but you want a secure

00:01:30.110 --> 00:01:34.580
execution environment that can
contain the bad stuff, make

00:01:34.580 --> 00:01:37.140
sure that it can't do bad things
to you, while letting

00:01:37.140 --> 00:01:41.480
the good stuff run,
which is what we

00:01:41.480 --> 00:01:43.510
built with Native Client.

00:01:43.510 --> 00:01:47.140
Now Native Client has been a
feature of Chrome since Chrome

00:01:47.140 --> 00:01:49.760
version 14, about a year
and a half ago.

00:01:49.760 --> 00:01:51.380
We built this for x86.

00:01:51.380 --> 00:01:53.440
Had a big launch party
you might have seen.

00:01:53.440 --> 00:01:56.020
And it's been a persistent
feature of

00:01:56.020 --> 00:01:58.340
Chrome since that time.

00:01:58.340 --> 00:02:01.780
About that time, same time
last year as the Samsung

00:02:01.780 --> 00:02:04.580
Chromebooks launched that Sundar
already talked about in

00:02:04.580 --> 00:02:08.889
his keynote, we brought
Native Client to ARM.

00:02:08.889 --> 00:02:13.000
And since that time, we've been
bringing native code to

00:02:13.000 --> 00:02:18.620
the web with performance 90ish
percent on x8632 and 80ish

00:02:18.620 --> 00:02:25.400
percent of native code
performance on x8664 at ARM.

00:02:25.400 --> 00:02:27.220
So you can build the cool
applications that you've

00:02:27.220 --> 00:02:32.210
always built in native code
but bring them to the web.

00:02:32.210 --> 00:02:36.570
So when we started doing Native
Client, we built a few

00:02:36.570 --> 00:02:39.570
applications, we ported a few
things and said, we'd really

00:02:39.570 --> 00:02:42.360
like to showcase what are the
cool things that people can do

00:02:42.360 --> 00:02:44.060
with Native Client.

00:02:44.060 --> 00:02:45.560
And we continue to do this.

00:02:45.560 --> 00:02:48.300
I've got a group of people that
work with me that are

00:02:48.300 --> 00:02:50.280
continually porting a few
applications and saying,

00:02:50.280 --> 00:02:52.070
here's something that shows
off a new possibility, say

00:02:52.070 --> 00:02:55.710
vector instructions or some
other feature that we'd like

00:02:55.710 --> 00:02:57.240
to show off.

00:02:57.240 --> 00:03:00.450
And we think there's some
amazing potential shown here.

00:03:00.450 --> 00:03:01.760
And we're not alone.

00:03:01.760 --> 00:03:05.290
Over the last year and a half
or so, over 30 applications,

00:03:05.290 --> 00:03:07.330
30 games have imported
Native Client.

00:03:07.330 --> 00:03:09.160
And you can go to the Chrome
Web Store, and you can

00:03:09.160 --> 00:03:11.880
download a bunch of the titles
that I've shown here plus a

00:03:11.880 --> 00:03:12.960
bunch more.

00:03:12.960 --> 00:03:14.910
So 30 plus games.

00:03:14.910 --> 00:03:16.900
And more recently applications
that are

00:03:16.900 --> 00:03:18.300
probably not in that category.

00:03:18.300 --> 00:03:22.410
Things like productivity
applications, applications to

00:03:22.410 --> 00:03:27.730
do secure shell accesses, or
remote desktop viewers for

00:03:27.730 --> 00:03:28.820
Native Client.

00:03:28.820 --> 00:03:31.780
So there are lots of other
things outside of games that

00:03:31.780 --> 00:03:32.450
were also bringing.

00:03:32.450 --> 00:03:36.830
Things, for instance, with
Chrome RDP and with SSH, it's

00:03:36.830 --> 00:03:38.920
the cryptography performance
that we can bring with native

00:03:38.920 --> 00:03:42.710
code opens up a new class
of applications as well.

00:03:42.710 --> 00:03:45.690
So lots of applications
have come.

00:03:45.690 --> 00:03:48.420
We think the potential has been
seen by a lot of people.

00:03:48.420 --> 00:03:54.870
And also people out there have
been doing these great

00:03:54.870 --> 00:03:58.400
applications and seeing the
performance that we provide.

00:04:01.030 --> 00:04:02.710
So you probably are asking
yourself, if you haven't done

00:04:02.710 --> 00:04:05.400
this before, how do I build a
Native Client application?

00:04:05.400 --> 00:04:09.030
Well, it's a native compilation
basically as

00:04:09.030 --> 00:04:10.240
you've always done.

00:04:10.240 --> 00:04:12.120
You take your C++ source code.

00:04:12.120 --> 00:04:14.140
In this case, use a
custom compiler.

00:04:14.140 --> 00:04:17.620
I have a compiler based off
the GCC tool chain.

00:04:17.620 --> 00:04:20.220
And you build something
called a nexe.

00:04:20.220 --> 00:04:23.200
And that's a native
ELF binary.

00:04:23.200 --> 00:04:25.930
And it's portable across
operating systems.

00:04:25.930 --> 00:04:30.150
It runs on Windows, Linux,
Mac, Chrome OS.

00:04:30.150 --> 00:04:33.090
But it's restricted to a
particular instruction set

00:04:33.090 --> 00:04:39.600
architecture, to x86,
32, or 64, or ARM.

00:04:39.600 --> 00:04:42.680
So actually, if you want to
bring the full experience to

00:04:42.680 --> 00:04:46.830
the full range of Chrome
platforms, you'll use a set of

00:04:46.830 --> 00:04:51.980
custom compilers, you'll
build a set of nexes.

00:04:51.980 --> 00:04:53.720
And that will be the
starting point.

00:04:53.720 --> 00:04:58.150
You'll add something we call a
manifest file, or NMF file.

00:04:58.150 --> 00:05:01.220
And then, along with that,
you'll build a web page.

00:05:01.220 --> 00:05:03.380
And the web page will
use an embed tag.

00:05:03.380 --> 00:05:06.550
And this embed tag tells where
to find the manifest file and

00:05:06.550 --> 00:05:08.905
basically that this is going to
be a Native Client enabled

00:05:08.905 --> 00:05:10.620
application.

00:05:10.620 --> 00:05:13.960
And with that, you have a
Native Client enabled

00:05:13.960 --> 00:05:16.100
application.

00:05:16.100 --> 00:05:19.127
So this is what the developer
needs to do to build an

00:05:19.127 --> 00:05:20.470
application.

00:05:20.470 --> 00:05:24.670
What does the user see when he
surfs to a page that's Native

00:05:24.670 --> 00:05:27.240
Client enabled?

00:05:27.240 --> 00:05:31.540
Well first of all, we need to
talk about the manifest file.

00:05:31.540 --> 00:05:33.110
We talked about the manifest
file before.

00:05:33.110 --> 00:05:36.270
The manifest file serves
several purposes.

00:05:36.270 --> 00:05:40.150
But the major purpose of the
manifest file is to tell the

00:05:40.150 --> 00:05:42.270
browser where to
find resources.

00:05:42.270 --> 00:05:45.660
So where to find resources can
be a lot more than just this

00:05:45.660 --> 00:05:47.840
in the case of dynamic linking
and some other things.

00:05:47.840 --> 00:05:51.080
But you at least need to say
where to find the Native

00:05:51.080 --> 00:05:53.260
Client executables.

00:05:53.260 --> 00:05:57.400
And you need to have an entry
in this manifest file for

00:05:57.400 --> 00:05:59.170
every one of those executables
that you provide.

00:05:59.170 --> 00:06:02.380
So that's basically for one
target the Native Client

00:06:02.380 --> 00:06:03.870
version of your application
is going to run on.

00:06:03.870 --> 00:06:09.340
You'll need one entry in this
manifest JSON dictionary.

00:06:09.340 --> 00:06:13.880
And that's going to tell for
which ISA where to find the

00:06:13.880 --> 00:06:16.430
native find executable.

00:06:16.430 --> 00:06:18.790
So back to the user.

00:06:18.790 --> 00:06:22.077
When the user points a browser
at a Native Client enabled web

00:06:22.077 --> 00:06:25.430
page, the browser sees that
embed tags and says, ah.

00:06:25.430 --> 00:06:26.810
Native Client.

00:06:26.810 --> 00:06:29.650
I'll need to do something
with that.

00:06:29.650 --> 00:06:34.430
It will load the manifest and
say, I'm running on an x86 64.

00:06:34.430 --> 00:06:39.100
So I need to find my resource
in this particular location.

00:06:39.100 --> 00:06:43.920
Once it's found that nexe, then
it loads the nexe and

00:06:43.920 --> 00:06:47.240
puts it in something we call
the Native Client process.

00:06:47.240 --> 00:06:49.920
The Native Client process is a
key part of the whole security

00:06:49.920 --> 00:06:54.050
story that we've built with
the Native Client System.

00:06:54.050 --> 00:06:56.770
The Native Client System is
built around a technique

00:06:56.770 --> 00:06:59.350
called software fault
isolation.

00:06:59.350 --> 00:07:04.910
The software fault isolation
is a scheme for basically

00:07:04.910 --> 00:07:10.760
analyzing and ensuring that the
nexe doesn't contain any

00:07:10.760 --> 00:07:13.010
forbidden instructions,
typically those are the ones

00:07:13.010 --> 00:07:15.420
that allow direct native
access to the operating

00:07:15.420 --> 00:07:18.690
system, and that furthermore, it
behaves itself with regard

00:07:18.690 --> 00:07:20.090
to control flow.

00:07:20.090 --> 00:07:21.350
That is it can't run any
instructions that

00:07:21.350 --> 00:07:22.520
I didn't look at.

00:07:22.520 --> 00:07:25.430
And data flow, that it can't
touch other memory in the

00:07:25.430 --> 00:07:28.160
browser or even in the Native
Client process that I'm

00:07:28.160 --> 00:07:29.400
looking at here.

00:07:29.400 --> 00:07:32.040
So it can't look at your
cookies, or look at your SSL

00:07:32.040 --> 00:07:33.380
keys, or things like that.

00:07:33.380 --> 00:07:35.940
It can only look at the memory
that the software fault

00:07:35.940 --> 00:07:39.460
isolation sandbox allows
it to talk to.

00:07:39.460 --> 00:07:43.490
So once of validator has scanned
the nexe and has

00:07:43.490 --> 00:07:47.830
confirmed those properties hold,
then execution of that

00:07:47.830 --> 00:07:50.830
executable can start.

00:07:50.830 --> 00:07:55.770
So once the execution of the
nexe starts, again you still

00:07:55.770 --> 00:08:00.240
cannot have raw unfiltered
access to the operating system

00:08:00.240 --> 00:08:03.680
because that's where the root of
the security discussions we

00:08:03.680 --> 00:08:06.270
talked about before is.

00:08:06.270 --> 00:08:10.200
So any time the Native Client
executable needs to do an

00:08:10.200 --> 00:08:15.640
operating system service, say to
load an URL, or to talk in

00:08:15.640 --> 00:08:17.950
a socket, or read a file.

00:08:17.950 --> 00:08:19.660
It's going to talk to something
we call the Native

00:08:19.660 --> 00:08:21.090
Client runtime.

00:08:21.090 --> 00:08:23.260
Now I like to use shorter
phrases than Native Client.

00:08:23.260 --> 00:08:25.070
So I'll say NaCl quite
a bit here.

00:08:25.070 --> 00:08:27.060
You'll hear me say that
several times.

00:08:27.060 --> 00:08:30.500
So the NaCl run time actually
is what the executable

00:08:30.500 --> 00:08:31.670
interfaces with.

00:08:31.670 --> 00:08:35.750
And the NaCl runtime is
responsible for checking that

00:08:35.750 --> 00:08:39.520
the executable has the privilege
to do the things

00:08:39.520 --> 00:08:41.179
that it's requesting to do.

00:08:41.179 --> 00:08:44.970
And if not, it can always
abort the execution.

00:08:44.970 --> 00:08:46.020
So with this in place--

00:08:46.020 --> 00:08:48.040
so the executable has
been scanned.

00:08:48.040 --> 00:08:51.650
The Native Client runtime is
monitoring to make sure that

00:08:51.650 --> 00:08:54.040
only secure accesses are made.

00:08:54.040 --> 00:08:55.440
You've got a process
that's running.

00:08:55.440 --> 00:08:56.960
And it's safe.

00:08:56.960 --> 00:08:58.670
And you've got a browser.

00:08:58.670 --> 00:09:01.380
But they're not talking
to each other.

00:09:01.380 --> 00:09:03.040
So how do we make them
talk to each other?

00:09:06.370 --> 00:09:09.500
Native Client executables are
going to be plug ins.

00:09:09.500 --> 00:09:14.680
So the web page that we talked
about before created embed

00:09:14.680 --> 00:09:16.720
tag, which is the classic way
of loading a plug in.

00:09:16.720 --> 00:09:19.985
In this case, this is an
out of process plug in.

00:09:19.985 --> 00:09:21.690
It's something that's going to
run in the secure environment

00:09:21.690 --> 00:09:23.120
we created.

00:09:23.120 --> 00:09:26.650
And it's going to talk to the
browser via something we call

00:09:26.650 --> 00:09:29.730
PPAPI, or Pepper.

00:09:29.730 --> 00:09:34.160
And PPAPI is a rich interface,
having 2D, and 3D, and audio,

00:09:34.160 --> 00:09:37.170
and video, and other
things like that.

00:09:37.170 --> 00:09:39.880
But the simplest of interfaces
is you just start a plug-in.

00:09:39.880 --> 00:09:42.950
And you can postMessage back and
forth between your plug-in

00:09:42.950 --> 00:09:44.460
and your page.

00:09:44.460 --> 00:09:48.390
And with that, the plug-in
becomes an extension of the

00:09:48.390 --> 00:09:49.640
browser's capabilities.

00:09:52.780 --> 00:09:54.520
So I think you can see
the potential.

00:09:54.520 --> 00:09:55.630
Now we've brought native code.

00:09:55.630 --> 00:09:57.140
We made it run securely.

00:09:57.140 --> 00:09:58.370
We run it in this environment.

00:09:58.370 --> 00:10:02.840
And we can interface with the
web browser to do cool things.

00:10:02.840 --> 00:10:07.470
So there are a couple
limitations yet.

00:10:07.470 --> 00:10:12.200
We didn't want to bring native
instruction set architectures

00:10:12.200 --> 00:10:14.470
as part of the web platform.

00:10:14.470 --> 00:10:15.670
Why not?

00:10:15.670 --> 00:10:19.800
Well, any time you list off
the set of instruction set

00:10:19.800 --> 00:10:22.950
architectures, there's always
one more that you didn't list.

00:10:22.950 --> 00:10:24.230
And what do you do for that?

00:10:24.230 --> 00:10:26.620
Well, there won't be an entry
in everybody's manifest.

00:10:26.620 --> 00:10:27.650
There won't be support
for that.

00:10:27.650 --> 00:10:31.140
And this will cause lots
of user confusion.

00:10:31.140 --> 00:10:32.840
And there are also security
reasons about this.

00:10:32.840 --> 00:10:37.480
The very low level access is to
instructions cause issues

00:10:37.480 --> 00:10:42.180
that I'd be glad to talk with
other people about offline, if

00:10:42.180 --> 00:10:45.280
you actually allow them
in the open web.

00:10:45.280 --> 00:10:49.240
So we didn't want ISAs in
the open web platform.

00:10:49.240 --> 00:10:52.490
But we really do see there's
tremendous potential to this.

00:10:52.490 --> 00:10:53.780
There's great performance.

00:10:53.780 --> 00:10:57.270
There's the ability to create
these applications in the web.

00:10:57.270 --> 00:10:59.760
And we wanted people
to get at them.

00:10:59.760 --> 00:11:02.130
So we made Native Client
executables available through

00:11:02.130 --> 00:11:03.590
the Chrome Web Store.

00:11:03.590 --> 00:11:04.950
And so you can go to the
Chrome Web Store.

00:11:04.950 --> 00:11:07.135
And it just so happens that at
the top of that page is Don't

00:11:07.135 --> 00:11:10.630
Starve, which just so happens
to be a Native Client based

00:11:10.630 --> 00:11:12.030
application.

00:11:12.030 --> 00:11:14.490
But you see any the 30 games
that I talked about before are

00:11:14.490 --> 00:11:16.100
in the Chrome Web Store.

00:11:16.100 --> 00:11:18.320
Or if you're wanting to develop
for yourself, there's

00:11:18.320 --> 00:11:20.030
a flag which you can toggle that
will little allow you to

00:11:20.030 --> 00:11:21.530
run things yourself.

00:11:21.530 --> 00:11:24.630
But by default, we have
limited Native Client

00:11:24.630 --> 00:11:26.240
execution to running out
of the web store.

00:11:29.160 --> 00:11:31.620
So we're done, right?

00:11:31.620 --> 00:11:34.350
We brought C++, native
applications.

00:11:34.350 --> 00:11:36.620
We run them in Chrome.

00:11:36.620 --> 00:11:38.940
And they're deployed
in the web.

00:11:38.940 --> 00:11:41.200
What else could there be?

00:11:41.200 --> 00:11:46.630
Well, we said we really didn't
want native ISAs in the web.

00:11:46.630 --> 00:11:50.360
So what we'd really like to have
is something that wasn't

00:11:50.360 --> 00:11:54.960
a native ISA, that you could
package up on your website,

00:11:54.960 --> 00:11:58.590
download, and have it become
something in the native ISA so

00:11:58.590 --> 00:11:59.840
that it can run on
your platform.

00:12:03.170 --> 00:12:07.140
So that's what brings us to
Portable Native Client.

00:12:07.140 --> 00:12:09.280
So Portable Native Client, so
we talk a little bit about

00:12:09.280 --> 00:12:11.560
this in the Native Client
introduction.

00:12:11.560 --> 00:12:13.540
It impinges on the cycle
all the way from the

00:12:13.540 --> 00:12:14.560
developer to the user.

00:12:14.560 --> 00:12:17.430
So the developer, and the
distribution, and the user.

00:12:17.430 --> 00:12:20.990
I'll talk about those starting
with the developer.

00:12:20.990 --> 00:12:25.590
So you as a developer start--

00:12:25.590 --> 00:12:28.290
you probably already have a C++
application, maybe it runs

00:12:28.290 --> 00:12:31.830
on a typical 32-bit machine, a
typical 32-bit machine might

00:12:31.830 --> 00:12:33.190
be a little endian, might
be big endian.

00:12:33.190 --> 00:12:34.250
But I think for the most
part, things are

00:12:34.250 --> 00:12:36.000
little endian nowadays.

00:12:36.000 --> 00:12:39.840
And you want to make it so
that it runs on all those

00:12:39.840 --> 00:12:42.330
platforms you had before,
that is Windows, Linux,

00:12:42.330 --> 00:12:45.130
Macintosh, Chrome OS.

00:12:45.130 --> 00:12:47.900
But you want it to run across
all the instructions and

00:12:47.900 --> 00:12:50.880
architectures as well.

00:12:50.880 --> 00:12:51.960
So you've got this
cool application.

00:12:51.960 --> 00:12:54.622
Say in this case, it's this
secure shell thing that we

00:12:54.622 --> 00:12:57.840
were talking about before, just
chosen as an example.

00:12:57.840 --> 00:12:59.920
And this is also kind of
interesting because in the

00:12:59.920 --> 00:13:03.060
secure shell case, as opposed
to a game, which typically

00:13:03.060 --> 00:13:06.300
will put up a 2D screen and
manipulate it all directly in

00:13:06.300 --> 00:13:09.900
NaCl, the UI in my secure shell
application is done in

00:13:09.900 --> 00:13:10.510
JavaScript.

00:13:10.510 --> 00:13:13.970
So it's an example of I'm doing
a cryptography in the

00:13:13.970 --> 00:13:15.970
Native Client executable, in
the UI, in JavaScript.

00:13:15.970 --> 00:13:19.940
So it's a really different sort
of model and one that's

00:13:19.940 --> 00:13:21.910
doing a lot of postMessage
back and forth.

00:13:21.910 --> 00:13:24.900
So you'd like to bring
that to the web.

00:13:24.900 --> 00:13:27.400
So the development cycle looks
a lot the same as it did for

00:13:27.400 --> 00:13:28.870
Native Client.

00:13:28.870 --> 00:13:31.610
The development cycle starts
when you take your code, you

00:13:31.610 --> 00:13:33.610
use of custom compiler.

00:13:33.610 --> 00:13:37.880
In this case is PNaCl Clang or
PNaCl Clang++, to bring, to

00:13:37.880 --> 00:13:42.390
compile, the application
to an executable.

00:13:42.390 --> 00:13:44.990
Now this case-- so PNaCl Clang
is based, as you might guess

00:13:44.990 --> 00:13:46.180
from the name Clang for
those of you that are

00:13:46.180 --> 00:13:46.910
familiar with LLVM.

00:13:46.910 --> 00:13:49.080
It's based on the LLVM
set of tools.

00:13:49.080 --> 00:13:49.720
OK.

00:13:49.720 --> 00:13:53.480
So the executable that's
produced is no longer and ISA

00:13:53.480 --> 00:13:54.910
executable.

00:13:54.910 --> 00:13:59.130
It's an LLVM bit code, or what
we call a PNaCl bit code.

00:13:59.130 --> 00:14:01.640
With some simplifications and
with some versioning for

00:14:01.640 --> 00:14:04.290
making it backward compatible
across a

00:14:04.290 --> 00:14:07.380
longer set of lifetimes.

00:14:07.380 --> 00:14:10.200
But it's essentially
LLVM bit code.

00:14:10.200 --> 00:14:14.120
You again pair that up with a
manifest and a bit tag and

00:14:14.120 --> 00:14:16.520
build your web page
as you did before.

00:14:16.520 --> 00:14:18.480
And you get the cool experience

00:14:18.480 --> 00:14:20.100
that the user wants.

00:14:20.100 --> 00:14:22.360
So this was the developer
side.

00:14:22.360 --> 00:14:24.200
What's the user going to see?

00:14:24.200 --> 00:14:27.120
Well, back to the
manifest again.

00:14:27.120 --> 00:14:30.640
Instead of, previously remember
we had one line for

00:14:30.640 --> 00:14:39.190
each of the ISAs that were
supported by the application.

00:14:39.190 --> 00:14:41.620
Instead of that, we
just have one.

00:14:41.620 --> 00:14:44.550
And the one says
it's portable.

00:14:44.550 --> 00:14:45.780
You still have to say
where to find it.

00:14:45.780 --> 00:14:47.610
That's an URL.

00:14:47.610 --> 00:14:50.140
And there's one other little
gadget I'll tell you about

00:14:50.140 --> 00:14:51.570
here a little later.

00:14:51.570 --> 00:14:54.050
But the developer, when he put
that up, can say, where to

00:14:54.050 --> 00:14:56.780
find the performance setting.

00:14:56.780 --> 00:15:00.200
And so basically this will
be a trade off between

00:15:00.200 --> 00:15:02.880
translation time and full
bore performance.

00:15:06.400 --> 00:15:10.070
So the user, when he start
things up, the browser sees

00:15:10.070 --> 00:15:11.590
again the embed tag.

00:15:11.590 --> 00:15:13.760
It looks at the manifest file.

00:15:13.760 --> 00:15:16.920
And it sees there's a
portable executable.

00:15:16.920 --> 00:15:19.720
And this time, instead of
immediately starting the

00:15:19.720 --> 00:15:22.490
Native Client process, it has to
start something called the

00:15:22.490 --> 00:15:24.160
translator.

00:15:24.160 --> 00:15:25.980
Now the translator has the
responsibility of taking it

00:15:25.980 --> 00:15:30.250
from this portable executable
format and producing the ISA

00:15:30.250 --> 00:15:33.340
specific executable that
runs on the platform.

00:15:33.340 --> 00:15:35.040
I'm still on an x86 64.

00:15:35.040 --> 00:15:37.590
So it produces a nexe.

00:15:37.590 --> 00:15:40.890
Once it's produced that nexe,
it again passes that to the

00:15:40.890 --> 00:15:44.720
Native Client process that it
creates because we've already

00:15:44.720 --> 00:15:47.310
shown that we know how to run
native code securely.

00:15:47.310 --> 00:15:51.100
So once it's translated, it runs
the same way as it always

00:15:51.100 --> 00:15:54.500
has in NaCl.

00:15:54.500 --> 00:15:59.710
So what's more, the translator
is more than just a

00:15:59.710 --> 00:16:00.440
compiler back end.

00:16:00.440 --> 00:16:03.660
It's more than just the part
that takes the bit code and

00:16:03.660 --> 00:16:06.860
produces native code.

00:16:06.860 --> 00:16:12.260
The translator's responsible for
taking basically the pexe.

00:16:12.260 --> 00:16:14.900
And the first thing it does is
see, do I already have a

00:16:14.900 --> 00:16:16.355
translation for that?

00:16:16.355 --> 00:16:17.480
And we have a translation
cache.

00:16:17.480 --> 00:16:20.320
And the translation cache will
keep track of all the times

00:16:20.320 --> 00:16:22.320
that we've previously
translated it.

00:16:22.320 --> 00:16:25.150
If there is something
there, and voila.

00:16:25.150 --> 00:16:27.240
We start the Native
Client process.

00:16:27.240 --> 00:16:29.890
And off we go.

00:16:29.890 --> 00:16:32.870
If not, we have to start
the translator.

00:16:32.870 --> 00:16:34.790
And again, for those of you who
are familiar with LLVM,

00:16:34.790 --> 00:16:36.070
this will be familiar.

00:16:36.070 --> 00:16:40.940
LLC is the back end of the
LLVM compiler tool chain.

00:16:40.940 --> 00:16:42.580
We'll start LLC.

00:16:42.580 --> 00:16:48.750
And LLC will stream the
executable down from the web.

00:16:48.750 --> 00:16:51.170
So we've changed it to interface
with the web to

00:16:51.170 --> 00:16:52.780
actually pull the pexe down.

00:16:52.780 --> 00:16:55.970
And while the pexe is being
pulled down, it will be

00:16:55.970 --> 00:16:58.760
translating the previous parts
that have been pulled down.

00:16:58.760 --> 00:17:02.650
So we dovetail translation
with download.

00:17:02.650 --> 00:17:04.730
And it will produce a nexe.

00:17:04.730 --> 00:17:06.319
And you might have noticed this
is running on a Native

00:17:06.319 --> 00:17:07.740
Client process.

00:17:07.740 --> 00:17:11.060
This is to provide additional
security from a tax where if

00:17:11.060 --> 00:17:14.250
somebody puts on a malicious
page a pexe that tries to own

00:17:14.250 --> 00:17:15.890
the translator.

00:17:15.890 --> 00:17:18.170
In previous situations, there
have been language

00:17:18.170 --> 00:17:22.200
environments that had jets
that were exploited by

00:17:22.200 --> 00:17:24.800
unscrupulous pages
to do things.

00:17:24.800 --> 00:17:26.710
And this is an additional
level of secure

00:17:26.710 --> 00:17:29.660
execution for PNaCl.

00:17:29.660 --> 00:17:31.650
So once we have the nexe,
they put it in the

00:17:31.650 --> 00:17:32.900
cache, and off we go.

00:17:35.690 --> 00:17:37.860
So you're probably asking
yourself, this guy's up here

00:17:37.860 --> 00:17:39.620
talking about all this
compiler stuff.

00:17:39.620 --> 00:17:40.470
I think it's really cool.

00:17:40.470 --> 00:17:42.720
We've got compilers, we've got
caches, we've got Native

00:17:42.720 --> 00:17:43.420
Client executables.

00:17:43.420 --> 00:17:44.920
And I'd love to talk
to you about that.

00:17:44.920 --> 00:17:49.090
But you're asking yourself,
how do I use it?

00:17:49.090 --> 00:17:50.590
Well, I have some good news for
those of you chomping at

00:17:50.590 --> 00:17:52.880
the bit to get using it.

00:17:52.880 --> 00:17:55.060
We have a developer
preview in Chrome.

00:17:55.060 --> 00:17:59.600
Developer preview is in Chrome
29, actually it's in canary as

00:17:59.600 --> 00:18:02.210
we speak, going to dev channel
I don't know what exactly the

00:18:02.210 --> 00:18:04.790
dates are but within
a few days I hope.

00:18:04.790 --> 00:18:06.690
So there's a flag.

00:18:06.690 --> 00:18:08.130
You can go to About Flags.

00:18:08.130 --> 00:18:10.930
And you can look for Portable
Native Client.

00:18:10.930 --> 00:18:12.810
You can toggle the flag.

00:18:12.810 --> 00:18:14.470
Toggle the flag.

00:18:14.470 --> 00:18:15.640
Go to the Chrome Web Store.

00:18:15.640 --> 00:18:19.120
Find our Portable Native
Client examples.

00:18:19.120 --> 00:18:21.080
And you can try it
out yourself.

00:18:21.080 --> 00:18:23.050
And here, in a couple of minutes
I'll show you some of

00:18:23.050 --> 00:18:24.190
that running.

00:18:24.190 --> 00:18:26.290
You can see it for yourself.

00:18:26.290 --> 00:18:27.550
What we're really
after, though--

00:18:27.550 --> 00:18:28.830
this is an early preview.

00:18:28.830 --> 00:18:31.000
Things may be changing.

00:18:31.000 --> 00:18:32.920
We're looking for
your feedback.

00:18:32.920 --> 00:18:34.520
What did you see for
translation time?

00:18:34.520 --> 00:18:35.970
What did you see for the
performance that we

00:18:35.970 --> 00:18:37.150
delivered for you?

00:18:37.150 --> 00:18:39.490
What did you see about the
executable sizes, et cetera

00:18:39.490 --> 00:18:42.420
that you might want
to play with?

00:18:42.420 --> 00:18:45.890
We want you to give us feedback
on what you observe

00:18:45.890 --> 00:18:47.180
at gonacl.com.

00:18:47.180 --> 00:18:48.550
And that's still a
work in progress.

00:18:48.550 --> 00:18:51.780
We've put up some Portable
Native Client stuff that's

00:18:51.780 --> 00:18:54.160
just very, very much
in the beginning.

00:18:54.160 --> 00:18:56.350
But we're going to be adding
more as we go along.

00:18:58.970 --> 00:19:01.590
But the things we do
already have--

00:19:01.590 --> 00:19:04.070
we do have an SDK for this.

00:19:04.070 --> 00:19:06.430
And it just so happens, it's
already part of the Native

00:19:06.430 --> 00:19:07.070
Client SDK.

00:19:07.070 --> 00:19:09.170
If you've downloaded the more
recent Native Client SDKs, so

00:19:09.170 --> 00:19:11.780
you pick the 29 SDK.

00:19:11.780 --> 00:19:15.060
You have the compiler, the
debugger, the libraries that

00:19:15.060 --> 00:19:19.820
will build Portable Native
Client applications for you.

00:19:19.820 --> 00:19:23.280
And also the NaCl port stuff,
which has recently become part

00:19:23.280 --> 00:19:24.570
of our SDK story.

00:19:24.570 --> 00:19:28.500
So you can see there's a bunch
of libraries there that we

00:19:28.500 --> 00:19:29.980
have ported.

00:19:29.980 --> 00:19:32.640
And so you can build
applications with a lot of

00:19:32.640 --> 00:19:34.770
these things as well.

00:19:34.770 --> 00:19:37.270
And you're probably asking
yourself so porting libraries.

00:19:37.270 --> 00:19:38.530
Why did you have to
port libraries?

00:19:38.530 --> 00:19:39.950
This is a compiler tool chain.

00:19:39.950 --> 00:19:41.830
Shouldn't I just be able to
compile anything just by

00:19:41.830 --> 00:19:44.900
changing my cc variable
in my make file?

00:19:44.900 --> 00:19:49.050
Well, there's a little more to
it than that because it's

00:19:49.050 --> 00:19:50.070
native code.

00:19:50.070 --> 00:19:51.820
It's running in the
web browser.

00:19:51.820 --> 00:19:56.480
We need secure APIs for
doing these plug ins.

00:19:56.480 --> 00:19:59.480
So where your native application
might have used

00:19:59.480 --> 00:20:04.170
message queues or event
registration mechanisms that

00:20:04.170 --> 00:20:05.930
the operating system provides.

00:20:05.930 --> 00:20:08.480
Now, your application is going
to be talking to the browser

00:20:08.480 --> 00:20:11.590
to get those kinds
of event streams.

00:20:11.590 --> 00:20:13.540
Furthermore, where you might
have gotten a hardware device

00:20:13.540 --> 00:20:16.950
context, the H wind or whatever
to scribble your 2D

00:20:16.950 --> 00:20:21.050
applications output into, now
you're going to have to change

00:20:21.050 --> 00:20:24.360
those to use secure interfaces
that actually interface with

00:20:24.360 --> 00:20:26.220
the browser.

00:20:26.220 --> 00:20:30.020
And last, then, of course,
unfiltered file access is not

00:20:30.020 --> 00:20:30.800
going to be OK.

00:20:30.800 --> 00:20:33.870
So you'll have to do some
work to actually make

00:20:33.870 --> 00:20:36.330
file accesses work.

00:20:36.330 --> 00:20:39.590
And we have examples of this in
our SDK that you can work

00:20:39.590 --> 00:20:41.150
from to start with.

00:20:41.150 --> 00:20:43.830
We have a very vibrant developer
discussion list.

00:20:43.830 --> 00:20:45.080
And you could join that.

00:20:47.430 --> 00:20:51.190
Or last year, a couple of my
good friends were here.

00:20:51.190 --> 00:20:53.380
That's Colt and Noel.

00:20:53.380 --> 00:20:55.770
And they gave a talk about
porting a Native Client

00:20:55.770 --> 00:20:58.620
application in 60 minutes.

00:20:58.620 --> 00:21:02.570
So they took an application,
took it from a running native

00:21:02.570 --> 00:21:05.130
application on Windows, used
some of the tools that I'm

00:21:05.130 --> 00:21:06.130
showing down here
at the bottom.

00:21:06.130 --> 00:21:09.580
They used the visual studio
integration that we have.

00:21:09.580 --> 00:21:12.470
They used the debugger
that we have.

00:21:12.470 --> 00:21:15.910
And they showed how to take it
step by step through this long

00:21:15.910 --> 00:21:19.540
sequence of steps here, most
of which is about just

00:21:19.540 --> 00:21:23.550
building things to be
PPAPI compliant.

00:21:23.550 --> 00:21:24.960
And that's where you're going to
spend most of your time as

00:21:24.960 --> 00:21:28.530
you port an application to
Native Client is the PPAPI

00:21:28.530 --> 00:21:30.570
translation.

00:21:30.570 --> 00:21:33.750
And since we provide threads
in these environments,

00:21:33.750 --> 00:21:36.010
particularly converting threads
from one thread

00:21:36.010 --> 00:21:38.830
package to P threads can
be a challenging

00:21:38.830 --> 00:21:39.560
part of that equation.

00:21:39.560 --> 00:21:43.260
So there will take some
time in porting.

00:21:43.260 --> 00:21:46.730
But once you've got it ported,
then you have a Native Client

00:21:46.730 --> 00:21:47.740
application.

00:21:47.740 --> 00:21:49.430
So what does it take to bring
a Portable Native Client

00:21:49.430 --> 00:21:50.680
application?

00:21:53.650 --> 00:21:55.510
Really one more step.

00:21:55.510 --> 00:21:58.900
That one more step is that you
need to remove assembly code.

00:22:05.000 --> 00:22:06.320
As I said before, these
are portable.

00:22:06.320 --> 00:22:08.110
They're not tied to a particular
instruction set

00:22:08.110 --> 00:22:08.620
architecture.

00:22:08.620 --> 00:22:10.340
So having assembly code
just violates

00:22:10.340 --> 00:22:12.200
portability on its very face.

00:22:12.200 --> 00:22:13.960
So you have to remove
the assembly code.

00:22:13.960 --> 00:22:15.080
But that's pretty much
the only thing

00:22:15.080 --> 00:22:16.330
that you have to have.

00:22:18.640 --> 00:22:21.750
I need to take a little step
back and say, we're bringing

00:22:21.750 --> 00:22:24.320
native binaries to the web.

00:22:24.320 --> 00:22:28.090
We're bringing large, immersive
high performance

00:22:28.090 --> 00:22:30.260
applications to the web.

00:22:30.260 --> 00:22:33.620
These may not be small.

00:22:33.620 --> 00:22:36.660
So one of the web design
principles that you'll need to

00:22:36.660 --> 00:22:40.000
be aware of in doing this--

00:22:40.000 --> 00:22:42.000
now there are many versions
of this sort of thing.

00:22:42.000 --> 00:22:45.360
But it has to do with the
StartUp Experience.

00:22:45.360 --> 00:22:48.050
That when you surf to that
page, the user is sitting

00:22:48.050 --> 00:22:51.630
there waiting, waiting, and
waiting while you download an

00:22:51.630 --> 00:22:52.990
application.

00:22:52.990 --> 00:22:58.990
Be that in nexe, or a large
JavaScript file, or a pexe, it

00:22:58.990 --> 00:23:01.810
is something that the user wants
to be aware of something

00:23:01.810 --> 00:23:06.760
going on, wants to be aware of
and be able to deal with as

00:23:06.760 --> 00:23:09.750
part of the application
experience.

00:23:09.750 --> 00:23:15.600
So when I surf to this SSH page,
the translator's going

00:23:15.600 --> 00:23:16.340
to kick off for us.

00:23:16.340 --> 00:23:18.030
Now I said that we're going
to stream translation.

00:23:18.030 --> 00:23:20.510
So the download time
and the translation

00:23:20.510 --> 00:23:21.730
time are largely overlap.

00:23:21.730 --> 00:23:25.900
But there will be a small
addition to the download time

00:23:25.900 --> 00:23:28.430
to do the translation.

00:23:28.430 --> 00:23:31.540
So we provide you with
progress events.

00:23:34.830 --> 00:23:39.680
Now the progress events will
be able to tell you in the

00:23:39.680 --> 00:23:42.280
JavaScript, I'm making
progress.

00:23:42.280 --> 00:23:44.870
I've got this much of the
code actually compiled.

00:23:44.870 --> 00:23:46.550
And you can put a progress
bar at the top of your

00:23:46.550 --> 00:23:47.010
application.

00:23:47.010 --> 00:23:48.310
And I'll show you
that in a little

00:23:48.310 --> 00:23:50.080
second here, an example.

00:23:50.080 --> 00:23:53.310
So that's one thing
you can do.

00:23:53.310 --> 00:23:55.070
Another thing you can do is
think about your application

00:23:55.070 --> 00:23:56.580
architecture a little bit.

00:23:56.580 --> 00:23:58.350
A lot of those examples I
showed you awhile ago of

00:23:58.350 --> 00:24:00.200
things that people have done,
cool things that people have

00:24:00.200 --> 00:24:02.900
done with Native Client
were games.

00:24:02.900 --> 00:24:05.380
And games tend to have this
property that you have maybe a

00:24:05.380 --> 00:24:09.490
medium to large application and
a huge bunch of assets.

00:24:09.490 --> 00:24:14.190
You have a lot of 3D textures,
and game areas, et cetera that

00:24:14.190 --> 00:24:16.730
you want to download.

00:24:16.730 --> 00:24:19.820
So if your application
architecture says, I'm going

00:24:19.820 --> 00:24:22.080
to have the executable actually
slurp down the

00:24:22.080 --> 00:24:25.810
assets, then in a system where
you're pulling down a large

00:24:25.810 --> 00:24:29.485
executable, translating it,
and then having to have it

00:24:29.485 --> 00:24:32.750
start running before you start
pulling any assets down, it's

00:24:32.750 --> 00:24:36.220
going to be awhile before you
actually get to useful work

00:24:36.220 --> 00:24:39.720
that the user can experience.

00:24:39.720 --> 00:24:43.800
Maybe if your application has
a static asset list that you

00:24:43.800 --> 00:24:45.230
can know ahead of time.

00:24:45.230 --> 00:24:48.450
Say it has got a few animals
for your games that

00:24:48.450 --> 00:24:49.640
you want to put up.

00:24:49.640 --> 00:24:51.680
And you know those
ahead of time.

00:24:51.680 --> 00:24:55.930
Maybe a better way to do it is
to have the JavaScript request

00:24:55.930 --> 00:25:00.270
those assets, put them in a
local HTML file system, and

00:25:00.270 --> 00:25:02.630
then let Native Client open
the local HTML file system

00:25:02.630 --> 00:25:03.740
afterwards.

00:25:03.740 --> 00:25:05.630
This gives you the ability
that the assets are being

00:25:05.630 --> 00:25:07.180
download while the translation's
happening and

00:25:07.180 --> 00:25:09.230
maybe even dovetailing with some
of the download of the

00:25:09.230 --> 00:25:12.810
pexe itself and gets you to
useful work in the game or the

00:25:12.810 --> 00:25:16.460
application at large faster.

00:25:16.460 --> 00:25:18.340
Lastly, I told you I had that
fiddle in there, that one

00:25:18.340 --> 00:25:21.900
extra entry in the
manifest file.

00:25:21.900 --> 00:25:26.490
And that was to control what we
called optimization level.

00:25:26.490 --> 00:25:29.220
I told you before that pexe to
nexe translation is actually

00:25:29.220 --> 00:25:31.350
the back end of a compiler.

00:25:31.350 --> 00:25:34.520
So there is some amount of
optimization that still

00:25:34.520 --> 00:25:37.730
happens in that part
of the compiler.

00:25:37.730 --> 00:25:39.640
Such things as registrar
allocation and high

00:25:39.640 --> 00:25:42.490
performance scheduling can
take some extra time and

00:25:42.490 --> 00:25:44.850
produce some extra
performance.

00:25:44.850 --> 00:25:49.300
So we provide the developer with
the ability to specify, I

00:25:49.300 --> 00:25:53.210
want low optimization, which
gives you a faster translation

00:25:53.210 --> 00:25:56.890
time, and about 50% of
native performance.

00:25:56.890 --> 00:26:00.910
Or you can request higher
optimization levels, take a

00:26:00.910 --> 00:26:06.500
translation time slow down and
get a much higher performance,

00:26:06.500 --> 00:26:10.190
the 80 plus percent of native
code performance.

00:26:10.190 --> 00:26:12.860
So these are the things that
the developer can do to try

00:26:12.860 --> 00:26:16.420
and improve the user
experience.

00:26:16.420 --> 00:26:19.410
So look at concrete about
the translation rates.

00:26:19.410 --> 00:26:21.090
So since we're adding
translation, which was

00:26:21.090 --> 00:26:22.460
something that was not there in
Native Client, we have to

00:26:22.460 --> 00:26:25.060
talk about that just
a little bit.

00:26:25.060 --> 00:26:28.760
So as you can see on x86,
we're doing about 750

00:26:28.760 --> 00:26:31.980
kilobytes a second, which will
about keep up with the average

00:26:31.980 --> 00:26:35.070
American's DSL sort
of connection.

00:26:35.070 --> 00:26:37.980
I think the average American's
bandwidth is about what six

00:26:37.980 --> 00:26:39.870
megabits a second
or so nowadays.

00:26:39.870 --> 00:26:41.310
So we can keep up with that.

00:26:41.310 --> 00:26:43.080
So we think that it's reasonably
balanced against

00:26:43.080 --> 00:26:44.770
that at the moment.

00:26:44.770 --> 00:26:45.310
ARM.

00:26:45.310 --> 00:26:46.720
It's a little earlier
in the process.

00:26:46.720 --> 00:26:50.690
And we are seeing a lower number
for ARM, partly because

00:26:50.690 --> 00:26:53.870
the processors aren't quite as
beefy but also because we know

00:26:53.870 --> 00:26:56.050
there are some features of the
ARM translator that we haven't

00:26:56.050 --> 00:26:58.120
brought to bear that are going
to speed our translation

00:26:58.120 --> 00:27:00.810
considerably.

00:27:00.810 --> 00:27:05.210
And then if you want optimize
code, as I said you want more

00:27:05.210 --> 00:27:10.440
optimize code, two to three
times sort of slow downs but

00:27:10.440 --> 00:27:13.030
with the considerably higher
performance that you get for

00:27:13.030 --> 00:27:14.280
it as well.

00:27:15.970 --> 00:27:17.170
Performance.

00:27:17.170 --> 00:27:18.400
I already said, what
was the performance

00:27:18.400 --> 00:27:20.310
number that you see?

00:27:20.310 --> 00:27:22.190
Well, we've done a
few benchmarks.

00:27:22.190 --> 00:27:22.940
We're going to do a lot more.

00:27:22.940 --> 00:27:25.960
We're still in the process of
gathering a lot of benchmarks.

00:27:25.960 --> 00:27:29.560
But the Box2D benchmarks at O0,
we're seeing about 55% of

00:27:29.560 --> 00:27:31.350
native performance.

00:27:31.350 --> 00:27:34.960
And at O2 we're seeing 85%.

00:27:34.960 --> 00:27:39.350
For SPEC about 50 and more
like 90% of native

00:27:39.350 --> 00:27:40.000
performance.

00:27:40.000 --> 00:27:42.890
SPEC is a kind of a standard
platform CPU intensive

00:27:42.890 --> 00:27:44.670
benchmark suite.

00:27:44.670 --> 00:27:45.760
So we think this is a
pretty good start.

00:27:45.760 --> 00:27:49.550
We have a lot of additional
optimization work that we're

00:27:49.550 --> 00:27:53.160
going to be doing and a lot of
additional translation time

00:27:53.160 --> 00:27:55.760
performance changes
we're working on.

00:27:55.760 --> 00:27:57.600
It should be emphasized that the
translation stuff that I

00:27:57.600 --> 00:28:00.450
just talked about a second
ago, that's still single

00:28:00.450 --> 00:28:02.260
threaded translation for us.

00:28:02.260 --> 00:28:03.160
So we haven't done
multi-threaded

00:28:03.160 --> 00:28:07.000
translation yet here.

00:28:07.000 --> 00:28:08.780
So I talked about
the developer.

00:28:08.780 --> 00:28:11.190
I talked about the user.

00:28:11.190 --> 00:28:14.530
So how does the user get the
cool application that the

00:28:14.530 --> 00:28:15.780
developer built in PNaCl?

00:28:18.270 --> 00:28:20.320
Instead of putting it in the
Chrome Web Store as we did

00:28:20.320 --> 00:28:23.060
with NaCl, it's going
to be in the web.

00:28:23.060 --> 00:28:26.710
You put it up on your favorite
Apache server or whatever your

00:28:26.710 --> 00:28:27.916
server of choice happens
to be, it's going

00:28:27.916 --> 00:28:29.166
to be on the web.

00:28:31.470 --> 00:28:46.060
So let's talk a little bit about
applications actually

00:28:46.060 --> 00:28:48.700
running in the web.

00:28:48.700 --> 00:28:54.890
So this is the PNaCl examples
extension that I talked to you

00:28:54.890 --> 00:28:56.230
about before.

00:28:56.230 --> 00:28:59.800
And this is running one of the
benchmarks, or the examples

00:28:59.800 --> 00:29:02.690
that's there.

00:29:02.690 --> 00:29:05.240
This is to start our favorite
spinning cube from the demo

00:29:05.240 --> 00:29:06.040
from last year.

00:29:06.040 --> 00:29:07.080
And you can see there's
a little bit of a

00:29:07.080 --> 00:29:08.210
pause in the beginning.

00:29:08.210 --> 00:29:11.150
That's the translation time
and the download from the

00:29:11.150 --> 00:29:12.400
local machine.

00:29:14.750 --> 00:29:16.000
That's the first time
experience.

00:29:19.750 --> 00:29:23.340
And after the first time, it
pulls it from the cache, it

00:29:23.340 --> 00:29:24.760
just starts.

00:29:24.760 --> 00:29:28.550
And even the start up time is
improving because we're doing

00:29:28.550 --> 00:29:30.510
some Native Client improvements
actually that'll

00:29:30.510 --> 00:29:33.690
reduce the overhead of
validation, which you can

00:29:33.690 --> 00:29:36.170
still occasionally see.

00:29:36.170 --> 00:29:38.170
So you can see it's not
a terribly long

00:29:38.170 --> 00:29:39.720
pause to start with.

00:29:39.720 --> 00:29:42.190
But it gets even better
on the second time.

00:29:42.190 --> 00:29:43.820
Here's a little bigger
application.

00:29:43.820 --> 00:29:45.910
This is Bullet Physics.

00:29:45.910 --> 00:29:49.860
And you could see there's our
progress meter going.

00:29:49.860 --> 00:29:54.120
And we're done.

00:29:54.120 --> 00:29:57.190
And there go our 500
cylinders falling.

00:30:02.970 --> 00:30:05.470
And here it is on
the second time.

00:30:05.470 --> 00:30:07.050
You see the progress meter
move so fast you

00:30:07.050 --> 00:30:08.540
couldn't even see it.

00:30:08.540 --> 00:30:10.244
And we're ready to go.

00:30:14.220 --> 00:30:21.880
Lastly, if you build without
optimization, you can see the

00:30:21.880 --> 00:30:27.940
progress bar chugs a little
faster and gets you visually

00:30:27.940 --> 00:30:30.050
pretty close looking
performance.

00:30:30.050 --> 00:30:33.310
So that's the O level
translation that I talked

00:30:33.310 --> 00:30:34.440
about before.

00:30:34.440 --> 00:30:36.370
That versus-- this was O0.

00:30:36.370 --> 00:30:38.240
The previous one I showed
you on cache was O2.

00:30:45.430 --> 00:30:46.530
So hopefully, you've
seen there's some

00:30:46.530 --> 00:30:47.700
real potential here.

00:30:47.700 --> 00:30:48.840
We're really excited
about this.

00:30:48.840 --> 00:30:51.160
We think this is going to bring
us the ability to really

00:30:51.160 --> 00:30:52.510
put some cool stuff
in the web.

00:30:52.510 --> 00:30:54.820
Really immersive for high
performance native

00:30:54.820 --> 00:30:57.680
applications on the web.

00:30:57.680 --> 00:31:00.930
So we're working really hard now
on bringing that out into

00:31:00.930 --> 00:31:02.280
the market.

00:31:02.280 --> 00:31:03.320
We're planning for a launch.

00:31:03.320 --> 00:31:04.590
We're working hard
for a launch.

00:31:04.590 --> 00:31:07.445
And we're going to bring all
the instructions and

00:31:07.445 --> 00:31:10.440
architectures that you had with
Native Client for the

00:31:10.440 --> 00:31:11.400
first launch.

00:31:11.400 --> 00:31:14.260
We're going to have threads
and atomics of day one as

00:31:14.260 --> 00:31:16.040
we've always had with
Native Client.

00:31:16.040 --> 00:31:19.340
And as I said before, we'll have
the SDK full of all the

00:31:19.340 --> 00:31:21.150
tools that you've come
to know and love.

00:31:21.150 --> 00:31:24.600
The Windows Visual Studio work
is still sort of ongoing.

00:31:24.600 --> 00:31:25.450
That may be a little later.

00:31:25.450 --> 00:31:27.970
But for the most part, you'll
have all the tools that you

00:31:27.970 --> 00:31:30.270
had with Native Client,
especially the debugger.

00:31:30.270 --> 00:31:33.280
This was one of the things that
we're very proud that we

00:31:33.280 --> 00:31:34.550
have added recently
to the Native

00:31:34.550 --> 00:31:35.800
Client Development Suite.

00:31:39.070 --> 00:31:42.150
Unfortunately, for the first
release, we've had to

00:31:42.150 --> 00:31:46.450
defeature SIMD instructions and
C++ Exception Handling.

00:31:46.450 --> 00:31:49.450
These are the two things that
we really wish we could have

00:31:49.450 --> 00:31:51.300
delivered in the first version
but I think we're probably not

00:31:51.300 --> 00:31:52.730
going to make.

00:31:52.730 --> 00:31:55.320
So we have a first update
already sort of in the works.

00:31:55.320 --> 00:31:58.720
And the first update provides
one of its big benefits will

00:31:58.720 --> 00:31:59.770
bring SIMD instructions.

00:31:59.770 --> 00:32:03.060
For a broad class of SIMD
instructions, things like four

00:32:03.060 --> 00:32:07.160
wide 32-bit float additions,
and multiplications, and

00:32:07.160 --> 00:32:09.000
places that sort of strike
the sweet spot in these

00:32:09.000 --> 00:32:09.620
applications.

00:32:09.620 --> 00:32:11.830
We think we can do
those in SIMD.

00:32:11.830 --> 00:32:15.340
So our first update
will have that.

00:32:15.340 --> 00:32:18.190
And in the second update, we'll
hopefully bring C++

00:32:18.190 --> 00:32:22.030
exception handling and
resolve that issue.

00:32:22.030 --> 00:32:24.610
A couple of things to mention
are that dynamic linking

00:32:24.610 --> 00:32:28.080
support and JIT support are
sort of longer term issues

00:32:28.080 --> 00:32:30.150
we're working on.

00:32:30.150 --> 00:32:31.560
We're very interested in getting
those up and going

00:32:31.560 --> 00:32:34.640
because some of our
games have used--

00:32:34.640 --> 00:32:36.450
JITing especially.

00:32:36.450 --> 00:32:37.560
We have some ideas.

00:32:37.560 --> 00:32:38.810
But those are longer term.

00:32:41.240 --> 00:32:42.270
So the user side.

00:32:42.270 --> 00:32:44.270
So the user experience, we're
going to have translation

00:32:44.270 --> 00:32:45.320
caching from day one.

00:32:45.320 --> 00:32:47.510
We're going to have optimization
level control so

00:32:47.510 --> 00:32:52.320
the user can say whether you
want that splash screen to be

00:32:52.320 --> 00:32:54.310
compiled quickly and up in front
of them or whether you

00:32:54.310 --> 00:32:56.350
want your physics engine
to provide the utmost

00:32:56.350 --> 00:32:57.890
performance.

00:32:57.890 --> 00:33:01.592
And we're also going to give
the progress events so that

00:33:01.592 --> 00:33:06.210
you can build UIs that tell
the user what's going on.

00:33:06.210 --> 00:33:07.270
And I said before,
we don't have

00:33:07.270 --> 00:33:08.970
multicore translation yet.

00:33:08.970 --> 00:33:10.670
But the guys in the team
are all chomping at

00:33:10.670 --> 00:33:11.460
the bit to do this.

00:33:11.460 --> 00:33:14.900
So at some point in the not too
distant future after that,

00:33:14.900 --> 00:33:17.920
we're going to have multicore
translation.

00:33:17.920 --> 00:33:21.850
So we also have some ideas for
the O0 side for some really

00:33:21.850 --> 00:33:24.200
fast O0 code generation.

00:33:24.200 --> 00:33:25.530
And we're looking into that.

00:33:25.530 --> 00:33:27.350
And we're not quite
certain when that

00:33:27.350 --> 00:33:28.170
would probably intercept.

00:33:28.170 --> 00:33:30.560
But that's also something we're
considering [INAUDIBLE]

00:33:30.560 --> 00:33:31.810
fairly soon.

00:33:33.590 --> 00:33:36.600
So let's sum up.

00:33:36.600 --> 00:33:39.590
Native code.

00:33:39.590 --> 00:33:43.880
It's run securely in Chrome
and the open web.

00:33:43.880 --> 00:33:45.910
80 plus percent of native
performance.

00:33:45.910 --> 00:33:49.450
85, 90 even some of
those examples.

00:33:49.450 --> 00:33:53.480
You could try it right now in
Chrome 29 Canary hopefully dev

00:33:53.480 --> 00:33:56.420
channel within a few days.

00:33:56.420 --> 00:34:03.300
And we're shooting for Chrome
30 as our launch.

00:34:03.300 --> 00:34:05.570
Thanks.

00:34:05.570 --> 00:34:09.489
[APPLAUSE]

00:34:09.489 --> 00:34:10.489
DAVID SEHR: Questions?

00:34:10.489 --> 00:34:14.850
If you want to step up to the
microphone for questions?

00:34:14.850 --> 00:34:16.170
AUDIENCE: So I had
a quick question.

00:34:16.170 --> 00:34:19.480
And maybe, I'm not sure if it's
a dumb question or not.

00:34:19.480 --> 00:34:22.020
But it seems as though you've
built an abstraction layer

00:34:22.020 --> 00:34:25.610
that allows me to write native
code and build it to LLVM.

00:34:25.610 --> 00:34:28.880
And then, you can then translate
the LLVM on the

00:34:28.880 --> 00:34:30.020
browser as you demonstrated.

00:34:30.020 --> 00:34:33.440
And the translated
code is cached.

00:34:33.440 --> 00:34:36.560
So my question is let's say if
I build an application that's

00:34:36.560 --> 00:34:38.600
really successful, and millions
of people all over

00:34:38.600 --> 00:34:42.239
the world download it, millions
of people all over

00:34:42.239 --> 00:34:45.270
the world are going to be
compiling it and translating

00:34:45.270 --> 00:34:45.960
this the same way.

00:34:45.960 --> 00:34:51.290
Why is this not done on the
server side, or even why can't

00:34:51.290 --> 00:34:54.340
I do this as a developer
and sort of do a cross

00:34:54.340 --> 00:34:55.940
compilation?

00:34:55.940 --> 00:34:56.199
DAVID SEHR: OK.

00:34:56.199 --> 00:34:57.160
So that's an excellent
question.

00:34:57.160 --> 00:34:59.850
So the question is why--
so millions of people--

00:34:59.850 --> 00:35:02.350
you think of millions
of watts spent on

00:35:02.350 --> 00:35:03.276
translation let's say.

00:35:03.276 --> 00:35:05.490
AUDIENCE: [INAUDIBLE], right?

00:35:05.490 --> 00:35:06.710
DAVID SEHR: Yes.

00:35:06.710 --> 00:35:10.980
It's millions of seconds of
people's lives spent in this

00:35:10.980 --> 00:35:12.272
thing, perhaps.

00:35:12.272 --> 00:35:13.770
Yeah, it's an excellent
question.

00:35:13.770 --> 00:35:19.000
So this is for a variety
of reasons.

00:35:19.000 --> 00:35:21.200
So doing the translation
actually on the platform

00:35:21.200 --> 00:35:25.470
provides the ability to take
advantage of the specific,

00:35:25.470 --> 00:35:27.000
particular platform we're
talking about.

00:35:27.000 --> 00:35:30.410
So I buy a latest generation
Intel or

00:35:30.410 --> 00:35:32.230
AMD, or ARM, whatever.

00:35:32.230 --> 00:35:33.560
And it happens to
have some super

00:35:33.560 --> 00:35:34.570
microarchitectural feature.

00:35:34.570 --> 00:35:37.920
Translation there would allow
the possibility of optimizing

00:35:37.920 --> 00:35:40.140
for that specific user
specific department.

00:35:40.140 --> 00:35:41.800
That's one thing we've
always talked about.

00:35:41.800 --> 00:35:45.430
But no, in the broad, moving
things up and say, in a place

00:35:45.430 --> 00:35:49.750
where I have for instance an
installed step where I get it

00:35:49.750 --> 00:35:50.810
through an app store.

00:35:50.810 --> 00:35:53.060
Then translation up in the cloud
someplace obviously make

00:35:53.060 --> 00:35:56.860
sense or translation caching
it up there someplace.

00:35:56.860 --> 00:35:59.570
Even if you're surfing the web,
maybe having a proxy that

00:35:59.570 --> 00:36:02.120
can do some translation,
this makes sense.

00:36:02.120 --> 00:36:05.200
These are things that we'd like
to investigate further.

00:36:05.200 --> 00:36:08.080
And definitely the technology
base we built lends itself to

00:36:08.080 --> 00:36:08.830
doing things there.

00:36:08.830 --> 00:36:12.550
It's more a question of
deployment and user model that

00:36:12.550 --> 00:36:13.600
is the issue at the moment.

00:36:13.600 --> 00:36:14.098
AUDIENCE: Sure.

00:36:14.098 --> 00:36:16.588
So if you look at things that
are deployed today, like

00:36:16.588 --> 00:36:20.572
[INAUDIBLE], so sure there
are billions of different

00:36:20.572 --> 00:36:21.568
[INAUDIBLE].

00:36:21.568 --> 00:36:23.160
But today, it's not
done this way.

00:36:23.160 --> 00:36:27.160
If you needed applications
today, [INAUDIBLE].

00:36:27.160 --> 00:36:27.590
DAVID SEHR: Right.

00:36:27.590 --> 00:36:32.360
Well, I should say also the SSH
application that I showed

00:36:32.360 --> 00:36:35.640
there actually is right now
in the Chrome Web Store.

00:36:35.640 --> 00:36:37.920
It was built using the
PNaCl tool chain.

00:36:37.920 --> 00:36:40.683
But they forced translation
ahead of time and installed it

00:36:40.683 --> 00:36:41.400
in the Chrome Web Store.

00:36:41.400 --> 00:36:43.730
So that's an option
for you also.

00:36:43.730 --> 00:36:46.280
And so this sort of thing is
something we're considering.

00:36:46.280 --> 00:36:48.800
It's really like sort of a user
model sort of question

00:36:48.800 --> 00:36:50.120
that we're trying to resolve.

00:36:50.120 --> 00:36:51.920
I think it's a great idea to
do what you're saying.

00:36:51.920 --> 00:36:54.140
But there are questions about
where do you host

00:36:54.140 --> 00:36:55.450
this caching mechanism?

00:36:55.450 --> 00:36:57.150
Where do you get these
things from?

00:36:57.150 --> 00:36:57.770
Definitely.

00:36:57.770 --> 00:36:59.590
Excellent question.

00:36:59.590 --> 00:37:01.040
Over here?

00:37:01.040 --> 00:37:03.420
AUDIENCE: I had a question,
like Dart recently added

00:37:03.420 --> 00:37:06.100
support for SIMD instructions?

00:37:06.100 --> 00:37:10.940
So how you see Dart and
PNaCl in the future?

00:37:10.940 --> 00:37:13.450
DAVID SEHR: Well, I think that
the two are complementary

00:37:13.450 --> 00:37:14.855
technologies to start with.

00:37:14.855 --> 00:37:18.330
I think that we're really
after taking the C++

00:37:18.330 --> 00:37:18.780
application.

00:37:18.780 --> 00:37:20.990
I've used C++ as a sort of broad
umbrella for all kinds

00:37:20.990 --> 00:37:23.340
of native applications that
might exist out there.

00:37:23.340 --> 00:37:25.570
Where Dart is much more targeted
at sort of the web

00:37:25.570 --> 00:37:30.870
applications viewed more in
that sort of category.

00:37:30.870 --> 00:37:32.580
But if you're asking the
question around the

00:37:32.580 --> 00:37:37.220
performance, Dart is still a
language that supports a

00:37:37.220 --> 00:37:40.195
richer and more dynamically
typed sort of execution model

00:37:40.195 --> 00:37:42.260
than we're targeting
with this.

00:37:42.260 --> 00:37:46.050
So we believe there's still a
performance gap between the

00:37:46.050 --> 00:37:48.650
way their code runs and the
way native code, which has

00:37:48.650 --> 00:37:51.800
been, for instance, fully
devirtualized and targeted

00:37:51.800 --> 00:37:55.500
toward a specific set
of polymorphism.

00:37:55.500 --> 00:37:59.090
So we think there's a
performance gap that would

00:37:59.090 --> 00:38:01.910
move toward the sort of the
higher end of as opposed to

00:38:01.910 --> 00:38:05.130
Dart or JavaScript today.

00:38:05.130 --> 00:38:07.440
The SIMD instruction
thing is sort of--

00:38:07.440 --> 00:38:09.730
we're going to get SIMD
instructions.

00:38:09.730 --> 00:38:12.420
But then, they having SIMD
instructions, of course, moves

00:38:12.420 --> 00:38:13.380
them closer to us.

00:38:13.380 --> 00:38:15.670
But there's still a performance

00:38:15.670 --> 00:38:18.170
gap there, I believe.

00:38:18.170 --> 00:38:19.380
Over here to the left?

00:38:19.380 --> 00:38:21.740
AUDIENCE: Yeah, so having
developed at the native layer

00:38:21.740 --> 00:38:25.130
for Android, I can really
appreciate this.

00:38:25.130 --> 00:38:28.450
So you mentioned there's going
to be no support for assembly.

00:38:28.450 --> 00:38:32.190
Are you going to provide some
kind of hint so that we can,

00:38:32.190 --> 00:38:38.120
for example, kind of hint for
the-- to provide some cues for

00:38:38.120 --> 00:38:39.390
the SIMD compiler.

00:38:39.390 --> 00:38:45.000
We've seen tremendous use
of the ARM7 NEON.

00:38:45.000 --> 00:38:46.120
DAVID SEHR: The SIMD instruction
stuff in

00:38:46.120 --> 00:38:46.520
particular.

00:38:46.520 --> 00:38:50.460
So the likeliest thing is
a set of intrinsics.

00:38:50.460 --> 00:38:52.205
So we're going to have a set
of intrinsic functions that

00:38:52.205 --> 00:38:55.160
you call and say, I want to do a
four wide multiplier, a four

00:38:55.160 --> 00:38:55.870
wide add, or whatever.

00:38:55.870 --> 00:38:58.160
And you'll use some
data types.

00:38:58.160 --> 00:39:01.330
LLVM has some of this stuff for
Intel in particular, for

00:39:01.330 --> 00:39:02.380
NEON in particular.

00:39:02.380 --> 00:39:06.410
But there's no sort of common
way to express it.

00:39:06.410 --> 00:39:08.900
Now for the specific things, say
I want to do a horizontal

00:39:08.900 --> 00:39:11.220
summation, which only some
platforms support.

00:39:11.220 --> 00:39:14.690
Or I want to do some sort of
transcendental or something

00:39:14.690 --> 00:39:17.520
that maybe somebody's vector
instructions support.

00:39:17.520 --> 00:39:20.640
That kind of discussion we've
had a few times internally.

00:39:20.640 --> 00:39:25.440
Maybe we'd like to provide some
way to key CPU id and to

00:39:25.440 --> 00:39:29.660
say I'd like this version to run
with this class of CPU and

00:39:29.660 --> 00:39:32.610
then have maybe some platform
specific intrinsics.

00:39:32.610 --> 00:39:33.970
But that's a very early
discussion.

00:39:33.970 --> 00:39:35.640
And we haven't really gotten
very far with it.

00:39:35.640 --> 00:39:37.750
We rightfully recognize, for
instance, their instructions

00:39:37.750 --> 00:39:42.230
to do AES encoding better on
some Intel and AMD parts.

00:39:42.230 --> 00:39:44.140
We'd like to be able to
get to those things.

00:39:44.140 --> 00:39:45.770
And it's really hard
to do that with a

00:39:45.770 --> 00:39:46.960
portable intrinsic today.

00:39:46.960 --> 00:39:47.585
But yes.

00:39:47.585 --> 00:39:50.050
AUDIENCE: Thanks.

00:39:50.050 --> 00:39:53.620
AUDIENCE: You say you're
using LLVM for this.

00:39:53.620 --> 00:39:57.800
Up to now, the intermediate
language in the LLVM, that was

00:39:57.800 --> 00:40:00.930
an intermediate step in their
tool change, which means that

00:40:00.930 --> 00:40:03.190
they can upgrade
it, add to it.

00:40:03.190 --> 00:40:07.450
And you are making it a
persistent thing in a file all

00:40:07.450 --> 00:40:10.020
over the world on servers.

00:40:10.020 --> 00:40:10.510
DAVID SEHR: Yep.

00:40:10.510 --> 00:40:12.530
That's another excellent
question.

00:40:12.530 --> 00:40:13.820
AUDIENCE: How is that
going to work?

00:40:13.820 --> 00:40:15.460
DAVID SEHR: How are we going
to make it persistent when

00:40:15.460 --> 00:40:17.210
it's really a compiler
intermediate representation.

00:40:17.210 --> 00:40:21.020
So there was a nice discussion
on the LLVM mailing list--

00:40:21.020 --> 00:40:23.480
I don't know, a year and a half
ago or so-- where it was

00:40:23.480 --> 00:40:26.300
exactly that statement,
LLVM as a compiler IR.

00:40:26.300 --> 00:40:30.830
So we have been working very
hard recently on simplifying.

00:40:30.830 --> 00:40:34.290
I kind of obliquely said this
earlier, simplifying LLVM IR.

00:40:34.290 --> 00:40:37.090
So there are some complicated
things, complicated

00:40:37.090 --> 00:40:42.050
instruction patterns that seem
to raise the risk of changes

00:40:42.050 --> 00:40:44.370
happening, attributes on
functions, attributes on

00:40:44.370 --> 00:40:47.920
variables, which have just gone
through major morphs.

00:40:47.920 --> 00:40:50.710
These are things that we're
severely restricting those

00:40:50.710 --> 00:40:54.000
down to just a small set that
we believe we can support.

00:40:54.000 --> 00:40:59.670
We've also cut the readers and
writers of LLVM IR off.

00:40:59.670 --> 00:41:01.590
We're going to keep frozen
versions of those that will

00:41:01.590 --> 00:41:04.910
allow us to translate into the
more recent versions that we

00:41:04.910 --> 00:41:06.230
use for the back end.

00:41:06.230 --> 00:41:09.200
So the physical writing of it
will always be in the format

00:41:09.200 --> 00:41:11.230
that we sort of control.

00:41:11.230 --> 00:41:14.360
And with the simplifications,
the get rid of linearizing

00:41:14.360 --> 00:41:19.230
addressing and some of the
other things that are, we

00:41:19.230 --> 00:41:21.990
think, potentially vulnerable
to IR changes.

00:41:21.990 --> 00:41:23.140
We've tried to write
those out.

00:41:23.140 --> 00:41:26.590
We have a series of passes that
simplified those away and

00:41:26.590 --> 00:41:31.010
hopefully reduced the surface of
LLVM IR susceptible change.

00:41:31.010 --> 00:41:33.180
AUDIENCE: So what you're saying
is that you're freezing

00:41:33.180 --> 00:41:35.430
the intermediate
language, or--

00:41:35.430 --> 00:41:37.420
DAVID SEHR: Well, we have
a versioning scheme.

00:41:37.420 --> 00:41:41.960
So we can turn the version when
it really diverges too

00:41:41.960 --> 00:41:43.270
severely from that.

00:41:43.270 --> 00:41:45.160
But we think that we've reduced
the likelihood of it

00:41:45.160 --> 00:41:49.130
diverging very severely by
these simplifications.

00:41:49.130 --> 00:41:49.350
AUDIENCE: OK.

00:41:49.350 --> 00:41:50.506
Thank you.

00:41:50.506 --> 00:41:50.930
DAVID SEHR: Over here.

00:41:50.930 --> 00:41:51.700
AUDIENCE: Two questions.

00:41:51.700 --> 00:41:53.240
One is regarding benchmark.

00:41:53.240 --> 00:41:55.170
You saw the performance
numbers.

00:41:55.170 --> 00:41:57.960
But are the numbers
similar on?

00:41:57.960 --> 00:42:02.090
And the second is once Google
Chrome 30 has been raised,

00:42:02.090 --> 00:42:04.650
will it support PNaCl
any website?

00:42:04.650 --> 00:42:08.260
DAVID SEHR: OK, so with regard
to the ARM question, I don't

00:42:08.260 --> 00:42:10.170
have the ARM numbers with
me at the moment.

00:42:10.170 --> 00:42:12.810
So traditionally when we run the
ARM numbers, again, we see

00:42:12.810 --> 00:42:15.740
numbers that look like the
x86 64 sort of numbers.

00:42:15.740 --> 00:42:20.400
So it'd be toward the 80% as
opposed to 90% sort of range

00:42:20.400 --> 00:42:22.030
for the high end of
these things.

00:42:22.030 --> 00:42:23.540
So I would guess it
would be there.

00:42:23.540 --> 00:42:26.080
But I can get those numbers
and ask this on

00:42:26.080 --> 00:42:26.960
Native Client Discuss.

00:42:26.960 --> 00:42:28.620
And we'll be glad to publish
those things

00:42:28.620 --> 00:42:30.170
out there as well.

00:42:30.170 --> 00:42:33.480
Now the other question that you
just asked was about will

00:42:33.480 --> 00:42:34.850
it be available in the open
web, I believe, right?

00:42:34.850 --> 00:42:35.570
AUDIENCE: Yep.

00:42:35.570 --> 00:42:37.260
DAVID SEHR: So the intent
is that actually, yes.

00:42:37.260 --> 00:42:38.410
It will be available
in the open web.

00:42:38.410 --> 00:42:40.160
You can host a site that
has a manifest file

00:42:40.160 --> 00:42:41.560
or refers to a pexe.

00:42:41.560 --> 00:42:42.836
And you point Chrome at that.

00:42:42.836 --> 00:42:45.010
You won't need to have any sort
of install step, or any

00:42:45.010 --> 00:42:49.130
sort of flags, or any sort of
web store to get it enabled.

00:42:49.130 --> 00:42:50.990
AUDIENCE: Thank you.

00:42:50.990 --> 00:42:53.160
DAVID SEHR: Do I
have more time?

00:42:53.160 --> 00:42:53.510
OK.

00:42:53.510 --> 00:42:55.220
It looks like we're out
of time, folks.

00:42:55.220 --> 00:42:58.300
I'll be over in the chat area
for the next 15 minutes or so.

00:42:58.300 --> 00:42:59.880
So feel free to come by.

00:42:59.880 --> 00:43:00.840
And we can talk some more.

00:43:00.840 --> 00:43:04.728
[APPLAUSE]

