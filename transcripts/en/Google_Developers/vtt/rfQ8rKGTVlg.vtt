WEBVTT
Kind: captions
Language: en

00:00:03.929 --> 00:00:07.790
&gt;&gt;Gregg Tavares: All right. Let's get started.
Welcome, everybody. I hope you enjoyed the

00:00:07.790 --> 00:00:11.030
keynote. This is the WebGL techniques and
performance talk.

00:00:11.030 --> 00:00:16.920
My name is Gregg Tavares. I'm a member of
the Chrome team, on the GPU part of that team.

00:00:16.920 --> 00:00:23.950
If you're going to tweet about this, we ask
that you add the Chrome hashtag, and also

00:00:23.950 --> 00:00:28.520
there's a link up there. That is a Google
Moderator link, where, if you think of questions

00:00:28.520 --> 00:00:31.130
during the talk, you can put them on there,
and at the end of the talk, you can put them

00:00:31.130 --> 00:00:35.310
on there and we'll take the top questions.
You can also vote on questions. And there's

00:00:35.310 --> 00:00:39.440
also two mics if you don't feel like putting
them there. But it might help you remember

00:00:39.440 --> 00:00:44.360
your questions.
So how many of you have used WebGL? Raise

00:00:44.360 --> 00:00:46.760
the hands.
All right. Good.

00:00:46.760 --> 00:00:51.880
How many of you who haven't used WebGL have
used OpenGL with shaders?

00:00:51.880 --> 00:00:56.219
All right. Quite a few of you.
Okay. That's good, because this is a 201 talk,

00:00:56.219 --> 00:01:00.290
so it's kind of assuming that you've used
WebGL. I'm not going to go into like tiny

00:01:00.290 --> 00:01:02.550
little details that you might need to know
if you haven't.

00:01:02.550 --> 00:01:07.549
I will give you a short overview of WebGL
so hopefully you'll be able to follow along

00:01:07.549 --> 00:01:11.521
even if you've never used WebGL before.
I'm going to go over drawing a lot of objects

00:01:11.521 --> 00:01:16.750
and different techniques to optimize that.
I'm also going to go over a few post-processing

00:01:16.750 --> 00:01:21.960
techniques, a few general dos and don'ts,
and some tips.

00:01:21.960 --> 00:01:26.260
So WebGL, if you guys -- if there's anybody
out there that hasn't used it, it's standard.

00:01:26.260 --> 00:01:32.180
It's built into most modern web browsers.
It's not a plug-in and it provides access

00:01:32.180 --> 00:01:36.509
to the system's GPU, and so it's actually
really simple.

00:01:36.509 --> 00:01:42.470
At a conceptual level, you have two functions
that run on the GPU, and so the whole API,

00:01:42.470 --> 00:01:48.240
the WebGL API, is there to help you get all
your data and these two functions set up on

00:01:48.240 --> 00:01:50.450
the GPU so you can tell it to run these two
functions for you.

00:01:50.450 --> 00:01:54.720
And so those two functions are represented
in green in this diagram.

00:01:54.720 --> 00:01:57.799
One is called the vertex shader, and the other
is the fragment shader.

00:01:57.799 --> 00:02:00.950
The vertex shader is responsible for processing
your mesh.

00:02:00.950 --> 00:02:05.040
So if you've ever seen any 3D or worked in
any 3D, you see that -- like if you've watched

00:02:05.040 --> 00:02:10.509
a Pixar "making of" or something like that,
you see that 3D models are made out of vertices

00:02:10.509 --> 00:02:14.540
and polygons.
All that data goes in this blue box on the

00:02:14.540 --> 00:02:22.609
screen, your buffers, and then through something
called attributes, you describe how that data

00:02:22.609 --> 00:02:27.219
is delivered to your vertex shader.
Your vertex shader, as far as WebGL is concerned,

00:02:27.219 --> 00:02:33.049
only has one responsibility, and that is to
fill in this global variable called GL position,

00:02:33.049 --> 00:02:38.999
and it fills that in in clipped space coordinates.
And I'll explain that in a moment.

00:02:38.999 --> 00:02:42.799
You also have something called a fragment
shader, and when the GPU renders your triangles

00:02:42.799 --> 00:02:48.139
or your graphics, it calls your fragment shader
and says "What color do you want this pixel?"

00:02:48.139 --> 00:02:52.120
And so the fragment shader's only responsibility
is to set this global variable, GL frag color,

00:02:52.120 --> 00:02:53.829
with the color you want the next pixel to
be.

00:02:53.829 --> 00:02:59.280
Both of those shaders can take some inputs
or parameters, and they're called uniforms

00:02:59.280 --> 00:03:04.339
in WebGL, and a vertex shader can pass data
to the fragment shader through something called

00:03:04.339 --> 00:03:09.049
varyings.
So you can see that it's fairly simple.

00:03:09.049 --> 00:03:12.650
Another thing that I like to point out is
that WebGL is actually a 2D API. Of course

00:03:12.650 --> 00:03:16.230
everybody is doing 3D with it, but at a base
level, it's a 2D API.

00:03:16.230 --> 00:03:20.489
And I'll show you what I mean.
So the first thing is, this is the simplest

00:03:20.489 --> 00:03:24.120
vertex shader you could write. We're just
going to take a position from our buffers

00:03:24.120 --> 00:03:27.859
and we're just going to store it in that global
vary I mentioned a moment ago. No math. Nothing

00:03:27.859 --> 00:03:32.519
special. Straight into that variable.
This is about the simplest fragment shader

00:03:32.519 --> 00:03:37.120
you can write. We're just going to say "Every
pixel is red."

00:03:37.120 --> 00:03:39.559
If we give it some data that's already in
clipped space coordinates --

00:03:39.559 --> 00:03:43.609
So clipped space coordinates are basically
no matter what size you're rendering, no matter

00:03:43.609 --> 00:03:48.049
how large your canvas is, they also go from
negative 1 on the left to positive 1 on the

00:03:48.049 --> 00:03:52.019
right, they go from positive 1 on the top
to negative 1 on the bottom.

00:03:52.019 --> 00:03:55.239
And so if you give it clipped space data and
say "Draw that," you'll get that result. There's

00:03:55.239 --> 00:03:59.349
the data for a square. Here's a square on
the screen.

00:03:59.349 --> 00:04:03.379
You're the one who has the 3D. You do that
by modifying your vertex shader. So here's

00:04:03.379 --> 00:04:08.339
our original shader on the left. On the right,
we've just added two lines. We've added the

00:04:08.339 --> 00:04:13.169
ability to pass in a matrix and we're multiplying
that matrix -- multiplying the position we're

00:04:13.169 --> 00:04:19.079
passing in by that matrix before storing it
in that global variable mentioned before.

00:04:19.079 --> 00:04:23.050
We can compute that matrix in JavaScript.
So here is some kind of pseudocode. The first

00:04:23.050 --> 00:04:28.050
part is computing a prospective matrix. The
prospective matrix is what actually takes

00:04:28.050 --> 00:04:32.689
your 3D data and converts it to 2D.
A look-at matrix is what's considered the

00:04:32.689 --> 00:04:36.720
camera or the view. It says where the camera
is in the scene.

00:04:36.720 --> 00:04:40.669
A world matrix is usually the matrix you use
to orient something in the world and rotate

00:04:40.669 --> 00:04:44.930
it and position it.
You multiply all those together and set them

00:04:44.930 --> 00:04:49.669
into that matrix uniform, and then if you
call it, you'll get that same data prospected

00:04:49.669 --> 00:04:53.979
-- looking like it's prospected in 3D, when
in actuality you took that 3D data and converted

00:04:53.979 --> 00:04:58.370
it to 2D by adding your own math.
And so that's the unique thing about WebGL.

00:04:58.370 --> 00:05:03.620
It's really 2D. You add the 3D.
And all of WebGL is really about how creatively

00:05:03.620 --> 00:05:06.681
you use those two functions, the vertex shader
and the fragment shader.

00:05:06.681 --> 00:05:13.210
So I'm going to go over drawing lots of objects.
So let's say we want to draw a hundred objects.

00:05:13.210 --> 00:05:16.439
If you want to draw a hundred objects, you
can pretty much do anything. WebGL is pretty

00:05:16.439 --> 00:05:20.560
fast and a hundred objects is not going to
tax it. You can use any library that's out

00:05:20.560 --> 00:05:24.270
there.
You have a typical model-based library. I

00:05:24.270 --> 00:05:27.430
have some pseudocode here.
So assume that I have an array of models,

00:05:27.430 --> 00:05:30.669
and this code for each model. It's going to
pull out that model. It's going to call this

00:05:30.669 --> 00:05:35.060
function, "use program." That's the function
that uploads your two functions, your vertex

00:05:35.060 --> 00:05:38.740
shader and your fragment shader. Together
they're called a program. And uploads those

00:05:38.740 --> 00:05:43.689
to the GPU. I have a function here called
"setup attributes" that would tell it how

00:05:43.689 --> 00:05:49.450
to use our mesh data, and, you know, that's
representing a bunch of calls into WebGL.

00:05:49.450 --> 00:05:53.770
Set up uniforms would set up our parameters.
And then finally, GL draw elements is what

00:05:53.770 --> 00:06:01.849
draws that object on the screen.
And so if I show you a sample of that, here

00:06:01.849 --> 00:06:05.639
are a hundred objects, and you can see that
-- I don't know if you can see that from a

00:06:05.639 --> 00:06:09.949
distance but it's running at about 60 frames
a second, which is about as fast as you're

00:06:09.949 --> 00:06:16.400
going to get. Monitors usually refresh at
60 frames per second so you're not going to

00:06:16.400 --> 00:06:22.069
go faster than that.
But let's say we want to draw a thousand objects.

00:06:22.069 --> 00:06:28.570
So we can use that same technique and try
drawing a thousand objects, and you can see

00:06:28.570 --> 00:06:33.090
that we're now down to about 30 frames a second.
It's running slower. So we need to do something

00:06:33.090 --> 00:06:40.389
about that. So what can we do?
So one thing to notice is that most apps draw

00:06:40.389 --> 00:06:44.909
many instances of a few objects. In this particular
application, there are only three objects.

00:06:44.909 --> 00:06:48.389
There's a square -- a cube, a sphere, and
a cone.

00:06:48.389 --> 00:06:52.390
And so why am I executing these heavy steps
in my inner loop? And those heavy steps are

00:06:52.390 --> 00:06:56.189
these three red steps. "Use GL program" is
a very heavy step. It has to upload your program

00:06:56.189 --> 00:07:02.389
to the GPU. "Setup attributes" may have to
call from 15 to 30 GL functions to set up

00:07:02.389 --> 00:07:05.610
all your attributes and tell the GPU how to
use your data.

00:07:05.610 --> 00:07:12.569
"Set up uniforms" as well could be 5 to 20
calls. And we're doing that a thousand times

00:07:12.569 --> 00:07:15.699
every frame, and that's going to add up to
a lot of time.

00:07:15.699 --> 00:07:22.330
So what if, instead, for each type of object
-- in this case, we have sphere, cube and

00:07:22.330 --> 00:07:26.889
cone -- set up what's common to that and then
for each instance of that type of object,

00:07:26.889 --> 00:07:31.770
set up whatever is unique and draw that instance.
And so here is the code changed a little bit.

00:07:31.770 --> 00:07:38.099
I sorted my array of models by the model type,
and then I have a variable, "last model,"

00:07:38.099 --> 00:07:40.499
that I can remember which model did I just
draw.

00:07:40.499 --> 00:07:44.090
And inside my inner loop, I'm checking, "Is
the model I'm about to draw different than

00:07:44.090 --> 00:07:48.490
the model I just drew? If so, then I'm going
to set up this program for this new model

00:07:48.490 --> 00:07:52.180
and set up the attributes and again, set up
the uniforms, but this time I'm only setting

00:07:52.180 --> 00:07:55.740
up shared uniforms."
So for example, shared uniforms in this case

00:07:55.740 --> 00:07:59.069
are like the lighting. The lighting is the
same for all thousand of those objects, so

00:07:59.069 --> 00:08:02.979
I only need to set it up once.
At the bottom, I'm still calling set uniforms

00:08:02.979 --> 00:08:07.210
again, but this time I'm passing in unique
uniforms and in this case, unique uniforms

00:08:07.210 --> 00:08:11.349
are like its position in the world and the
color of each object. And so in that particular

00:08:11.349 --> 00:08:14.849
case, we went from a thousand times setting
up these things to three, because we only

00:08:14.849 --> 00:08:21.270
have three types of objects. And so if I go
back and I run this optimized version, you

00:08:21.270 --> 00:08:27.539
can see we're up to 45, 50. It depends.
But definitely better than we were doing at

00:08:27.539 --> 00:08:30.610
30.
So that's the first thing you could do when

00:08:30.610 --> 00:08:33.810
you optimize.
And that's a pretty generic technique. You

00:08:33.810 --> 00:08:36.630
can use it almost anywhere.
One thing to notice, though, is that I was

00:08:36.630 --> 00:08:43.490
sorting those thousand objects every frame,
and of course this is just an obvious suggestion,

00:08:43.490 --> 00:08:48.100
is that if you can move that sorting outside
of your rendering, maybe do it at setup time

00:08:48.100 --> 00:08:52.751
or organize your code so that all your models
are in separate arrays, whatever you can do,

00:08:52.751 --> 00:08:56.250
use some kind of insertion sort as you add
and remove objects, whatever you can do to

00:08:56.250 --> 00:09:00.940
keep that sorted, you could save yourself
from sorting it at the last moment and keep

00:09:00.940 --> 00:09:05.490
your speed up.
But let's say I want to draw 10,000 objects.

00:09:05.490 --> 00:09:13.260
So let's use that same technique with 10,000
objects.

00:09:13.260 --> 00:09:18.170
So now we're running at five frames a second.
And, you know, five frames a second, yeah,

00:09:18.170 --> 00:09:21.430
that's pretty bad, but it depends on the application.
Maybe you're going to do something static

00:09:21.430 --> 00:09:29.290
or that doesn't animate all that often and
that's okay. But let's try optimizing it.

00:09:29.290 --> 00:09:33.260
So the first thing to notice is how much work
is JavaScript doing. So in our current code,

00:09:33.260 --> 00:09:38.220
we have a loop. It's going over 10,000 models,
and for every model, it is computing a world

00:09:38.220 --> 00:09:42.730
matrix. That's the first line here where it
says "M4 translation." And M4 is a reference

00:09:42.730 --> 00:09:48.630
to a JavaScript math library that I'm using.
And then it's multiplying the world matrix

00:09:48.630 --> 00:09:52.470
by the view projection to get a world view
projection and that was the example we showed

00:09:52.470 --> 00:09:56.940
at the very beginning when I showed the simple
3D shader. If you want the minimal math in

00:09:56.940 --> 00:10:00.570
your -- in your shader, this is what you'd
end up doing in JavaScript.

00:10:00.570 --> 00:10:04.930
But those two things represent a lot of work.
So that making a translation matrix is filling

00:10:04.930 --> 00:10:10.529
out a 16-element matrix. Multiplying two matrices
is 64 multiplies and 16 adds or something

00:10:10.529 --> 00:10:14.730
like that. It's a lot of work. And we're doing
that 10,000 times per frame.

00:10:14.730 --> 00:10:20.370
Great.
[Laughter]

00:10:20.370 --> 00:10:28.750
Thank you, Microsoft!
[Laughter]

00:10:28.750 --> 00:10:36.259
[Applause]
I think they did that in intentionally.

00:10:36.259 --> 00:10:42.570
[Laughter]
&gt;&gt;&gt; Talk about WebGL support in IE.

00:10:42.570 --> 00:10:49.380
&gt;&gt;Gregg Tavares: So WebGL support in IE. Well,
we will hammer our best on Microsoft and convince

00:10:49.380 --> 00:10:54.060
them to add it. Until that time, you have
Chrome Frame, if you're running IE, and it

00:10:54.060 --> 00:10:59.430
runs great and WebGL performs excellent there.
&gt;&gt;&gt; (Speaker is off microphone).

00:10:59.430 --> 00:11:04.040
&gt;&gt;Gregg Tavares: This demo does work in Linux.
&gt;&gt;&gt; (Speaker is off microphone).

00:11:04.040 --> 00:11:11.610
&gt;&gt;Gregg Tavares: If I had a Linux machine
set up, I would have considered that.

00:11:11.610 --> 00:11:15.019
Sorry about this.
What other questions can you come up with

00:11:15.019 --> 00:11:17.730
while we're wasting time?
&gt;&gt;&gt; (Speaker is off microphone).

00:11:17.730 --> 00:11:28.800
&gt;&gt;Gregg Tavares: The math library I'm using
is called TLD or 3D library. File it at 3Dlibrary.googlecode.com.

00:11:28.800 --> 00:11:32.110
There's also a benchmark. If you search the
WebGL math benchmarks, I'm sure you'll find

00:11:32.110 --> 00:11:37.540
one that's kind of comparing these, and it's
getting the different library makers to make

00:11:37.540 --> 00:11:43.019
their libraries as fast as possible, and it's
also getting the browser developers to look

00:11:43.019 --> 00:11:47.779
at those benchmarks and speed them up.
So obviously all of the browser developers

00:11:47.779 --> 00:11:56.910
are trying to be the fastest browser out there.
And we take those very seriously, and we definitely

00:11:56.910 --> 00:11:59.060
are speeding them up all the time. I think,
in fact --

00:11:59.060 --> 00:12:04.800
I actually had to change my talk in the last
week, because one of my optimizations was

00:12:04.800 --> 00:12:10.410
based on JavaScript being slow and V8 got
faster and it no longer made sense.

00:12:10.410 --> 00:12:16.769
&gt;&gt;&gt; Which version of (inaudible) based on?
&gt;&gt;Gregg Tavares: WebGL is based on OpenGL

00:12:16.769 --> 00:12:23.390
ES 2.0 with zero extensions, so that's pretty
much like the saying, "Well, iPhone and Android

00:12:23.390 --> 00:12:33.750
both use OpenGL ES 2.0."
What else uses it? Chrome OS uses it. WebGL

00:12:33.750 --> 00:12:39.410
uses it.
It's similar to OpenGL but, OpenGL -- a lot

00:12:39.410 --> 00:12:42.209
of things have been removed in OpenGL ES which
make it more streamlined.

00:12:42.209 --> 00:13:08.110
Okay. Where were we? So we went through this
optimization, and I was just about to show

00:13:08.110 --> 00:13:13.410
you. Right. So before we were doing all this
work, we're doing this -- creating this translation

00:13:13.410 --> 00:13:16.970
matrix and doing this multiply that's very
expensive work for JavaScript.

00:13:16.970 --> 00:13:22.339
So what if we move that work to the GPU? So
instead of actually generating those matrices

00:13:22.339 --> 00:13:26.320
in JavaScript, let's just pass the position
up to the GPU and let the GPU create those

00:13:26.320 --> 00:13:31.829
matrices. So we are changing the JavaScript,
so we just give it the position.

00:13:31.829 --> 00:13:39.769
Here we are taking the position of one instance
and sending it into a uniform and setting

00:13:39.769 --> 00:13:42.209
up the uniforms.
This is how we change the GPU -- or the vertex

00:13:42.209 --> 00:13:46.450
shader. So the old vertex shader was multiplying
by the world view projection that we're passing

00:13:46.450 --> 00:13:51.380
in. The new vertex shader where we are only
passing in world position, this is the code

00:13:51.380 --> 00:13:56.889
that will build a world matrix. This the code
-- Instead, we are going to pass in a view

00:13:56.889 --> 00:13:58.940
projection.
This is another advantage. Not only are we

00:13:58.940 --> 00:14:04.310
not computing a world view projection in JavaScript
for every one of those 10,000 objects but

00:14:04.310 --> 00:14:08.360
the view projection is global. We only have
to pass it in once. It is the same for all

00:14:08.360 --> 00:14:12.649
objects. We are saving the time of even passing
it in on top of computing it.

00:14:12.649 --> 00:14:16.660
So then you can see at the end where we actually
use it, those lines haven't changed. The only

00:14:16.660 --> 00:14:20.709
thing that has changed is whether we have
passed in the world view projection computed

00:14:20.709 --> 00:14:24.379
from JavaScript or that we only passed in
a world position, a computed-in line.

00:14:24.379 --> 00:14:34.920
So if I show you that example, we were running
at five frames a second before. Now we're

00:14:34.920 --> 00:14:41.870
running at about eight -- seven, eight. So
it is running a little bit faster, but that's

00:14:41.870 --> 00:14:47.790
not really good enough, right? We want to
do better.

00:14:47.790 --> 00:14:51.180
So what are we really doing? Right now we
are drawing 10,000 objects. For every one

00:14:51.180 --> 00:14:55.560
of those objects, we are -- currently we are
setting up a world position. Before we were

00:14:55.560 --> 00:14:58.949
setting up a world matrix, we are setting
up a color. And then we are calling draw.

00:14:58.949 --> 00:15:03.600
We will get it in one of these cubes.
We set up a new world matrix and a new color

00:15:03.600 --> 00:15:05.850
and we call draw again and we get another
one of these cubes.

00:15:05.850 --> 00:15:10.279
On the left, that represents the cube data.
There is only one cube in memory, a mesh for

00:15:10.279 --> 00:15:14.769
one cube, and we're using it to draw multiple
cubes.

00:15:14.769 --> 00:15:18.459
What if instead we put all the cubes in one
mesh and we'll add some extra data so we can

00:15:18.459 --> 00:15:20.270
actually treat them as though they were separate
meshes.

00:15:20.270 --> 00:15:24.890
What do I mean by that? I will take the data
for one cube and instead of just having that

00:15:24.890 --> 00:15:29.079
one cube, I'm going to repeat it inside our
buffers basically 10,000 times.

00:15:29.079 --> 00:15:33.610
And I'm going to add two more columns of data.
I'm going to add a world position column.

00:15:33.610 --> 00:15:38.379
That world position is the same for every
vertex of cube zero and then switches to whatever

00:15:38.379 --> 00:15:41.230
the position needs for cube one, but it is
the same for every vertex of cube one.

00:15:41.230 --> 00:15:45.930
The same with color. The color is repeated
for every vertex of cube zero, and then it

00:15:45.930 --> 00:15:48.940
is repeated again for whatever color cube
one is for every vertex of cube one.

00:15:48.940 --> 00:15:53.180
In this example, we were going to draw four
cubes. We ended up being able to draw them

00:15:53.180 --> 00:15:57.589
with one draw call. So instead of JavaScript
making four draw calls for four cubes, we

00:15:57.589 --> 00:16:03.720
would make one draw call for four cubes. And
that should save us some time.

00:16:03.720 --> 00:16:08.360
Again, we have to change our shader. So we
had our old shader. Our new shader we are

00:16:08.360 --> 00:16:13.970
passing in -- we are getting our world position
from these buffers. And we're going to compute

00:16:13.970 --> 00:16:17.290
the world position by just adding it to the
position of the individual vertices of our

00:16:17.290 --> 00:16:21.759
cube at the origin. And, again, we are only
passing in view projections so we save that

00:16:21.759 --> 00:16:25.779
time because it is global.
We also have to pass in our color. We are

00:16:25.779 --> 00:16:30.260
getting our color out of our buffer, and we
are going to pass it through a varying over

00:16:30.260 --> 00:16:35.610
to the fragment shader.
The fragment shader used to have a color that

00:16:35.610 --> 00:16:39.959
we passed in where we changed it before each
draw call and passed that in as a uniform.

00:16:39.959 --> 00:16:42.320
But now we are getting that from the vertex
shader.

00:16:42.320 --> 00:16:44.480
So what this means is there's very little
work going on -- I shouldn't say there is

00:16:44.480 --> 00:16:48.600
very little work going on, but we are only
doing a couple draw calls. Actually, that's

00:16:48.600 --> 00:16:52.899
one of the things you need to pay attention
for when you are trying to optimize for WebGL.

00:16:52.899 --> 00:16:57.380
The fewer draw calls you can make usually
the faster it is going to run.

00:16:57.380 --> 00:17:00.379
Here's one thing. We are still updating a
lot of vertices. We have to update the world

00:17:00.379 --> 00:17:05.160
position of every vertice for all those 10,000
objects in JavaScript. But let's see how it

00:17:05.160 --> 00:17:12.970
does.
So now we are running at 24 frames a second.

00:17:12.970 --> 00:17:18.620
That's a lot better than five or eight. That
might be good enough. Let's take it to the

00:17:18.620 --> 00:17:26.140
next level.
Let's say we want to draw 40,000 objects.

00:17:26.140 --> 00:17:36.310
So we'll use that same technique and we'll
draw 40,000 objects. And we're running at

00:17:36.310 --> 00:17:39.960
about 13 frames a second. That's actually
pretty impressive when you think of what's

00:17:39.960 --> 00:17:45.130
going on.
I will tell you what I mean. What is JavaScript

00:17:45.130 --> 00:17:51.890
actually doing? JavaScript is actually computing
40,000 positions every frame. It's updating

00:17:51.890 --> 00:17:56.750
the world position of all the vertices, and
those objects are average of 21 vertices each.

00:17:56.750 --> 00:18:02.600
That's 852,000 vertices every frame. That's
2 1/2 million values because every vertice

00:18:02.600 --> 00:18:07.650
has an X, Y and Z. It has to update all three.
It was doing it at 15 frames a second. That's

00:18:07.650 --> 00:18:13.460
like 37 million operations a second that JavaScript
is doing. I mean, some of those JavaScript

00:18:13.460 --> 00:18:19.420
engines are doing -- are pretty amazing.
But let's see if we can make it go even faster.

00:18:19.420 --> 00:18:24.240
One of the things we're doing is we're computing
for those 40,000 objects. Each instance of

00:18:24.240 --> 00:18:29.800
those objects has a clock in the current limitation.
So you can see here we're updating the clock

00:18:29.800 --> 00:18:35.450
in each axis of a particular instance. Each
axis has a speed. Each axis has a clock. We

00:18:35.450 --> 00:18:37.891
are taking the elapsed time and advancing
those three clocks.

00:18:37.891 --> 00:18:44.790
The way these objects move, they kind of move
in a kind of spherical spirograph function,

00:18:44.790 --> 00:18:50.810
which is what this math is doing. Each axis
has a radius. We multiply it by the clock,

00:18:50.810 --> 00:18:54.520
and we get the spinning motion that you saw.
The problem with that is that their state

00:18:54.520 --> 00:19:00.190
going back here every instance has three clocks.
So there's 120,000 clocks that we're updating

00:19:00.190 --> 00:19:09.700
and they say persistent from frame to frame.
What if we have one clock and we compute where

00:19:09.700 --> 00:19:16.810
those clocks would be every time we need them?
We have just one clock. Instead, we have an

00:19:16.810 --> 00:19:21.780
offset for each of the individual clocks for
all 120,000 clocks. We can take our global

00:19:21.780 --> 00:19:25.580
clock. We can multiply it by a speed. We can
add where the clock started. That will give

00:19:25.580 --> 00:19:28.850
us the same answer. We're not actually storing
any result. We only need it temporarily, just

00:19:28.850 --> 00:19:34.180
long enough to draw.
This math stays exactly the same. But what

00:19:34.180 --> 00:19:38.040
does that do for us? If there is no state
in your computation, then you can use that

00:19:38.040 --> 00:19:43.810
math to the GPU. So what do we have to do
to do that? We have to add the data we needed.

00:19:43.810 --> 00:19:47.340
We will get rid of the world position from
our data because we are going to compute it

00:19:47.340 --> 00:19:52.760
now. We're going to add our clock offset,
clock speed and clock radius to our buffers.

00:19:52.760 --> 00:19:58.370
Again, they are repeated. So those values
will be repeated for each vertex for a single

00:19:58.370 --> 00:20:04.090
cube. And then for the next cube, there will
be unique values for each vertex of that cube.

00:20:04.090 --> 00:20:07.320
So here's our shader again. We're back to
our old shader at the top. The new shader

00:20:07.320 --> 00:20:12.290
we are going to pass in our clock. We are
going to get our clock offset, speed and radius

00:20:12.290 --> 00:20:17.910
from our buffers. And before, like in JavaScript,
we did this in three lines. In the shader,

00:20:17.910 --> 00:20:22.771
we can do it in one like because that clock
is a vec3. Vec3 has an X, Y, and a Z. Clock

00:20:22.771 --> 00:20:27.170
offset has an X, Y and a Z. Clock speed has
an X, Y and a Z. That's actually doing all

00:20:27.170 --> 00:20:31.910
three clocks at once.
This line we're pulling out our spherical

00:20:31.910 --> 00:20:37.410
coordinates and putting them in a temporary.
And then we are computing world position.

00:20:37.410 --> 00:20:42.480
Again, T has an X, Y and Z. Radius has an
X, Y and a Z. So a lot more is happening there

00:20:42.480 --> 00:20:47.020
than was in JavaScript in a single line.
Finally, where we can put in a position, this

00:20:47.020 --> 00:20:50.930
is the same code again. It is just what's
changed is how we are computing that at the

00:20:50.930 --> 00:21:00.050
beginning.
And so if we do that example, 

00:21:00.050 --> 00:21:05.100
now you can see we are running 40,000 objects
at 30 frames a second, 40 frames a second.

00:21:05.100 --> 00:21:09.280
At this point, almost everything is happening
on the GPU. So this is going to be very GPU-dependent.

00:21:09.280 --> 00:21:14.510
If you run it on a desktop, it is probably
going to run at 60 hertz JavaScript is actually

00:21:14.510 --> 00:21:20.880
making about 14 draw calls, period. The only
reason it is making 14 instead of one is that

00:21:20.880 --> 00:21:29.370
WebGL has a limit of 64,000 polygons per draw
call. That's actually not per draw call. If

00:21:29.370 --> 00:21:32.360
you use index primitives, if you know what
that means, then you can only have indices

00:21:32.360 --> 00:21:36.760
that are 16 bits. In this particular case,
there are 14 draw calls. That means the CPU

00:21:36.760 --> 00:21:40.710
is actually probably sleeping, so you are
not using a whole lot of battery and the GPU

00:21:40.710 --> 00:21:52.010
is doing everything for you.
So, to recap those things, in the simple case,

00:21:52.010 --> 00:21:55.300
order by model. If you are not ordering by
model now, add that to your library. If you

00:21:55.300 --> 00:21:58.800
are using somebody else's library and you're
running up to some performance issues, make

00:21:58.800 --> 00:22:04.750
sure they are ordering by model.
If it makes sense, use the GPU for instancing.

00:22:04.750 --> 00:22:09.720
So a good example are trees. I don't know
if any of you remember the O3D beach demo.

00:22:09.720 --> 00:22:14.600
I have been too lazy to port that to WebGL.
If somebody wants to volunteer, it is open

00:22:14.600 --> 00:22:20.500
source. Originally all the trees, the bushes,
the shrubs were all instanced. That had 1500

00:22:20.500 --> 00:22:25.410
draw calls to do one frame. To do the reflections
and things like that required another rendering

00:22:25.410 --> 00:22:32.090
of the entire scene for 4,500 draw calls.
Instead, we merged all those trees and merged

00:22:32.090 --> 00:22:37.100
all those bushes into one large model and
got it down to 70 draw calls. And then, of

00:22:37.100 --> 00:22:42.111
course, it sped up significantly.
Another one is tile-based maps. If you are

00:22:42.111 --> 00:22:45.670
doing any kind of like platform game or any
kind of old-school game that uses a tile-based

00:22:45.670 --> 00:22:51.160
map, if you had a map on the screen and you
were displaying, say, 40 tiles by 20 tiles,

00:22:51.160 --> 00:22:55.430
if you want to draw each tile individually,
that's 800 draw calls. Instead, if you use

00:22:55.430 --> 00:22:59.780
some of these techniques, you could probably
get it to be one draw call per row and still

00:22:59.780 --> 00:23:05.630
be just as flexible and you would get it down
from 800 draw calls to 20. That's a huge optimization.

00:23:05.630 --> 00:23:09.250
And then finally visualizations. I don't know
if any of you have seen the WebGL globe that

00:23:09.250 --> 00:23:14.990
Google just posted last week. You have a globe
and you have all these little lines that you

00:23:14.990 --> 00:23:19.440
want to put all over the Earth or in your
visualization. You could draw every one of

00:23:19.440 --> 00:23:22.500
those lines individually, and it would go
very slow. Or you could somehow bake them

00:23:22.500 --> 00:23:28.080
into a mesh at run time or offline and get
it to run very fast.

00:23:28.080 --> 00:23:30.970
And then, finally, if it makes sense, put
the math in the GPU. If you have ever seen

00:23:30.970 --> 00:23:35.710
the field demo on WebGL samples, all that
grass is computed in a GPU, all its motion.

00:23:35.710 --> 00:23:40.460
All of that is just math from the GPU. JavaScript
is doing nothing but passing in a clock.

00:23:40.460 --> 00:23:46.250
There is a particle library on the WebGL Wiki.
If you haven't seen it, I highly recommend

00:23:46.250 --> 00:23:49.010
that you take a look at the code. It is very
flexible. You can put it in your own apps

00:23:49.010 --> 00:23:52.920
and you can instantly add particles to your
game with very little work. All those particles,

00:23:52.920 --> 00:23:56.450
all the math for them is running on the GPU
so they take very little time and it is very

00:23:56.450 --> 00:24:01.180
flexible. You can do flames. You can do smoke.
You can do fog. You can do ripples. You can

00:24:01.180 --> 00:24:06.220
do jet exhaust, whatever you need.
Another one is simulations. I don't have a

00:24:06.220 --> 00:24:11.360
picture here, but there was a simulation of
every meteor that's been discovered in the

00:24:11.360 --> 00:24:17.360
last 50 years. I think it has all 500,000
something meteors. If you wanted to do that,

00:24:17.360 --> 00:24:21.020
you could do that very easily by putting all
that data for those meteors into your buffers

00:24:21.020 --> 00:24:25.520
and writing a shader that used them, pass
in time what time you want to see the discoveries,

00:24:25.520 --> 00:24:29.770
and either show them or don't inside your
shader.

00:24:29.770 --> 00:24:33.710
All right. So let's move on to post processing.
What is post processing? Well, post processing

00:24:33.710 --> 00:24:40.260
is almost anything you do to a photo in Photoshop.
A few examples, one is blur. I'm not going

00:24:40.260 --> 00:24:43.070
to go over blur today because if you want
to see blur, you can go look at the field

00:24:43.070 --> 00:24:48.000
demo we wrote last summer. If you press D
for "debug," I think it will show you how

00:24:48.000 --> 00:24:52.420
it is blurring and you can look at that code.
Color adjustments is obviously just doing

00:24:52.420 --> 00:24:57.170
anything with the colors, like this picture
on the top right, to have the color tweaked.

00:24:57.170 --> 00:25:00.360
Persistence is something you wouldn't do in
Photoshop but you might do in After Effects.

00:25:00.360 --> 00:25:05.990
I will go into that when I get there.
There is this really cool technique called

00:25:05.990 --> 00:25:10.141
color adjusting using a color cube. Basically
you have a cube that represents each color

00:25:10.141 --> 00:25:15.420
in a certain axis. We have red across one
axis, green across another, and blue across

00:25:15.420 --> 00:25:20.400
the third. If you make one of these color
cubes and adjust it to, say, something like

00:25:20.400 --> 00:25:25.470
this and then you use that cube, you can map
an image. We will take a pixel out of the

00:25:25.470 --> 00:25:29.950
first image. Let's say it is red. Of course,
in WebGL, colors go from 0 to 1. A pure red

00:25:29.950 --> 00:25:36.210
pixel would be 1-0-0. We use that to index
this cube. We go over 1 in the red, 0 in the

00:25:36.210 --> 00:25:40.030
green and 0 in the blue we pull that color
out and we use that to draw the image.

00:25:40.030 --> 00:25:47.540
To do one more, we pull green out from a palm
frond. This time it is .6 in red, 1.0 in green,

00:25:47.540 --> 00:25:54.330
and 0 in blue. Again, we go over .6 in red,
1 in green, which is in the back, and 0 in

00:25:54.330 --> 00:25:58.030
blue, which is still the top. We get that
color, and we draw with that color. This is

00:25:58.030 --> 00:26:02.610
a great technique. I'm actually not a video
editor, so I don't know if it's in After Effects,

00:26:02.610 --> 00:26:08.790
Final Cut Pro or any of those, but I do know
games use this a lot.

00:26:08.790 --> 00:26:14.110
One problem, though, WebGL doesn't support
3D textures. But, fortunately, we can simulate

00:26:14.110 --> 00:26:17.790
3D textures with 2D textures. I will show
you how to do that.

00:26:17.790 --> 00:26:21.900
The first thing is we take every slice of
our 3D texture and we spread it out into a

00:26:21.900 --> 00:26:25.640
2D texture.
And then we are going to make a function that

00:26:25.640 --> 00:26:29.960
you can use in any shader you want that should
give it that 2D texture. You give it the coordinate

00:26:29.960 --> 00:26:34.192
inside the cube you want, in texture coordinates,
and you give it a size.

00:26:34.192 --> 00:26:39.590
When I say "size," this size is how many units
there are in the cube. So the cube I'm going

00:26:39.590 --> 00:26:44.650
to use in the example is 8 by 8 by 8. This
sample in this case size would be equal to

00:26:44.650 --> 00:26:48.110
8.
The first thing we need to know is how big

00:26:48.110 --> 00:26:56.340
is one slice. So one slice is obviously -- textures
always are referenced from 0 to 1. One slice

00:26:56.340 --> 00:27:03.640
is 1/8 in this case since our size is 8.
We need to know the size of a pixel. A pixel

00:27:03.640 --> 00:27:09.740
is one size of the slice divided by the number
of pixels. Again, that's 8.

00:27:09.740 --> 00:27:14.320
Now we need to know the size we are going
to interpolate across. We want to interpolate

00:27:14.320 --> 00:27:18.100
from the middle of the first pixel to the
middle of the last pixel. So the question

00:27:18.100 --> 00:27:22.180
is why do we want to do that? Why not go from
the very left to the far right?

00:27:22.180 --> 00:27:30.350
Well, here's the reason. If you have a three-pixel
texture and you use nearest filtering, you

00:27:30.350 --> 00:27:34.460
are going to get the image drawn up like that
with no filtering whatsoever. If you turn

00:27:34.460 --> 00:27:37.750
filtering on, what you will notice is it only
filters from the middle of the first pixel

00:27:37.750 --> 00:27:43.430
to the middle of the last pixel. So if we
used the whole texture, we would get too much

00:27:43.430 --> 00:27:46.491
white and too much black when we are remapping.
So we actually want to map from the middle

00:27:46.491 --> 00:27:49.690
of the first pixel to the middle of the last
pixel and that's why you have to subtract

00:27:49.690 --> 00:27:54.600
half a pixel.
So now that we have that size, we can compute

00:27:54.600 --> 00:28:01.300
each slice. If we got passed in a blue of
.6 and our size was 8, we'd figure out from

00:28:01.300 --> 00:28:05.820
the math above that we want slice 4.
Slice 5, the next slice, is pretty straightforward.

00:28:05.820 --> 00:28:11.000
Just add one.
Then we need to know how far into that slice

00:28:11.000 --> 00:28:15.630
to get a color, and so here we're going to
add half a pixel, like we mentioned before,

00:28:15.630 --> 00:28:21.280
and then we're going to take our red, which
is in texture coordinate X and we're going

00:28:21.280 --> 00:28:25.210
to multiply it by that size that we computed
before to get the right position.

00:28:25.210 --> 00:28:30.520
So in this case, if red was .08, you could
see it comes at about the seventh pixel in

00:28:30.520 --> 00:28:36.210
that slice.
Now we need to compute the position of each

00:28:36.210 --> 00:28:40.250
of the slices, since we want to pull out two
pixels.

00:28:40.250 --> 00:28:44.470
And then finally, we actually pull out those
two colors from those two slices, and here

00:28:44.470 --> 00:28:48.800
we've added in the Y component, which is green.
And so if it was about .3, you can see we'd

00:28:48.800 --> 00:28:51.700
pull those pixels where the two arrows are
pointing.

00:28:51.700 --> 00:28:57.470
Finally, we need to mix those two pixels so
this math computes how much to mix them. If

00:28:57.470 --> 00:29:03.570
we were passing in a blue of .6, it would
come out with a value of .8, and what .8 means

00:29:03.570 --> 00:29:08.590
is that you can think of it as a position
80% of the way between slice 0 and slice 1

00:29:08.590 --> 00:29:12.780
or you can think of it as 20% of slice 0 and
80% of slice 1.

00:29:12.780 --> 00:29:18.650
And in GL SL, you can do that with one line
called "mix."

00:29:18.650 --> 00:29:26.990
So demo time. What does that let us do?
Well, here's a video you might have seen,

00:29:26.990 --> 00:29:32.080
and here I am adjusting the hue, say plus
60 degrees, or setting it to all weird shades

00:29:32.080 --> 00:29:37.360
of blue with a little bit of yellow, or putting
it to Googley colors. Just some crazy things

00:29:37.360 --> 00:29:41.460
there.
Or make it look like it's, you know, some

00:29:41.460 --> 00:29:48.990
'80s movie sci-fi thing. Or color negatives
or posterize it.

00:29:48.990 --> 00:29:53.820
Or make it supersaturated, or make it sepia.
And another thing you might notice is that

00:29:53.820 --> 00:29:57.670
I'm actually blending between two settings.
I'm actually using two cubes at once. I call

00:29:57.670 --> 00:30:01.040
that function I just showed you twice to get
the values from two cubes and then I choose

00:30:01.040 --> 00:30:05.820
how much to mix them. So each time you pick
a different setting, I interpolate between

00:30:05.820 --> 00:30:09.570
those two.
And it doesn't have to be for video. Obviously

00:30:09.570 --> 00:30:18.060
you can do this through any 3D scene, anything
you can get into WebGL.

00:30:18.060 --> 00:30:19.600
So that's great. But how do you make that
cube?

00:30:19.600 --> 00:30:23.450
Well, it turns out that's really easy.
To make those cubes, you just take any photo

00:30:23.450 --> 00:30:27.660
and load it into Photoshop or some other video
editing program or image editing program,

00:30:27.660 --> 00:30:35.560
and then you take a cube that's been stretched
out and you paste it in the top corner.

00:30:35.560 --> 00:30:41.570
And after that, you pick any full-screen adjustment,
and as you adjust, you'll notice that it actually

00:30:41.570 --> 00:30:45.070
adjusted the colors of that cube, and that's
exactly the cube you needed.

00:30:45.070 --> 00:30:49.330
You just take that texture out, and you'll
get what you needed to make those -- that

00:30:49.330 --> 00:30:55.841
effect, get the same adjustment that you made.
Now, one thing here is that if you wanted

00:30:55.841 --> 00:30:59.780
to save time -- and you guys are making apps
for millions of users -- you probably want

00:30:59.780 --> 00:31:04.460
to have the minimal amount of data. You would
probably at this point take that image and

00:31:04.460 --> 00:31:07.180
crop it just to that cube, so you can load
that into WebGL.

00:31:07.180 --> 00:31:13.440
On the other hand, in WebGL, you have a whole
library, you have the canvas 2D library, and

00:31:13.440 --> 00:31:17.730
if you don't really care about the space -- and
these images aren't that big; I think they're

00:31:17.730 --> 00:31:23.120
like, you know, 60K or something like that
uncropped -- then you could load that in and

00:31:23.120 --> 00:31:29.000
this is what I do in the sample. I load that
in and then using the canvas API, I just pull

00:31:29.000 --> 00:31:32.820
out the top 64-by-8.
The reason I do that is that when I go to

00:31:32.820 --> 00:31:36.140
inspect my images, I actually have an image
there and I can see what the effect is. If

00:31:36.140 --> 00:31:39.190
it was just the cube, then it would be kind
of hard to tell what that's really going to

00:31:39.190 --> 00:31:43.830
turn into. So I kind of like that, so I thought
I'd pass that on.

00:31:43.830 --> 00:31:47.380
Okay. Let's go on to the next effect. This
is persistence, and persistence is best explained

00:31:47.380 --> 00:31:54.760
with a demo, so we'll do the demo first.
Persistence is adding a persistence. So you

00:31:54.760 --> 00:31:58.410
can see that these images with no persistence
on this side are very sharp and if I bring

00:31:58.410 --> 00:32:06.620
it over here, they start getting all blurry.
So I'll show you how to do that effect.

00:32:06.620 --> 00:32:10.350
So the first thing is, we want to create three
framebuffers.

00:32:10.350 --> 00:32:13.350
I'm going can to call them new frame, framebuffer
1, and framebuffer 2.

00:32:13.350 --> 00:32:18.170
And the steps are, we draw to a new frame.
We draw our normal scene that we didn't have

00:32:18.170 --> 00:32:22.221
persistence in to this new frame.
We blend the new frame with framebuffer 1

00:32:22.221 --> 00:32:28.000
into framebuffer 2. Then we draw framebuffer
2 into the canvas and then we're going to

00:32:28.000 --> 00:32:31.220
swap those two framebuffers and repeat.
So I'll give you a diagram.

00:32:31.220 --> 00:32:33.400
Here's our new frame.
We drew our scene. Our scene in this case

00:32:33.400 --> 00:32:36.580
is just a blue circle. It's in the top left
corner.

00:32:36.580 --> 00:32:40.890
Here's framebuffer 1 in the first frame of
our simulation, of our app. It has nothing

00:32:40.890 --> 00:32:43.450
in it.
So we blend those two 50% each. We're going

00:32:43.450 --> 00:32:47.580
to get this in framebuffer 2.
And then finally we need to copy that result

00:32:47.580 --> 00:32:51.430
to the screen by copying to the canvas.
And now we're going to swap framebuffer 1

00:32:51.430 --> 00:32:55.160
and framebuffer 2. And by "swap," I just mean
in this second time, we're going to use framebuffer

00:32:55.160 --> 00:32:59.610
2 where -- in the first step and we're going
to use framebuffer 1 in the second step.

00:32:59.610 --> 00:33:04.360
So here is them swapped. We have a new frame.
We drew a circle in the middle. We have the

00:33:04.360 --> 00:33:08.740
old framebuffer 2 that has the circle from
the last frame in it. We're blending those

00:33:08.740 --> 00:33:13.460
together into framebuffer 1, so now we have
something with two circles and you can see

00:33:13.460 --> 00:33:16.110
they're kind of fading. And we copy that to
the canvas.

00:33:16.110 --> 00:33:21.000
We'll do a third frame. Here are the circles
moved to the bottom right. We're blending

00:33:21.000 --> 00:33:27.540
with the last framebuffer we used as a destination
before, and you can see now in framebuffer

00:33:27.540 --> 00:33:31.210
2 we have the three circles and we copy that
to the canvas.

00:33:31.210 --> 00:33:39.820
And so if you play around with that -- right?
-- we have this example working here but we're

00:33:39.820 --> 00:33:42.320
copying those canvas directly on top of each
other.

00:33:42.320 --> 00:33:46.250
Well, what if we skew how we blend them? We
don't actually blend them directly on top

00:33:46.250 --> 00:33:49.960
of each other but we move it a little bit?
So let's say we move it a little bit to left.

00:33:49.960 --> 00:33:56.280
We'll start getting kind of a wind effect.
Or move it to the right, depending on how

00:33:56.280 --> 00:34:01.900
our persistence is.
We can multiply it and make it kind of look

00:34:01.900 --> 00:34:09.990
-- go out. We can rotate it and make it spin.
So what would you use this effect for?

00:34:09.990 --> 00:34:14.889
Well, you would use it for things like -- a
good example is Grand Theft Auto. So Grand

00:34:14.889 --> 00:34:18.870
Theft Auto uses persistence -- Grand Theft
Auto on the PS2 uses persistence all the time

00:34:18.870 --> 00:34:24.609
to try to hide their atrocious frame rate.
They also use it if you drink liquor in that

00:34:24.609 --> 00:34:28.250
game. Their character gets drunk and everything
becomes blurry.

00:34:28.250 --> 00:34:30.880
If you were doing a platform game, you might
say, "Well, when the person gets to speed

00:34:30.880 --> 00:34:38.109
power-up, make everything use this effect
and blur across the screen."

00:34:38.109 --> 00:34:41.889
And you can also kind of see, this is how,
you know, probably iTunes or some other things

00:34:41.889 --> 00:34:48.200
do their visualizers. They just keep drawing
the stuff on top, so if you want to make some

00:34:48.200 --> 00:34:53.509
music visualizers, this is another good technique.
So the things about post-processing, they're

00:34:53.509 --> 00:34:56.290
very easy to add at the end of your project.
You might be thinking you don't need them

00:34:56.290 --> 00:35:00.500
and then at the last second, you go, "Oh,
I can add some visual pizzazz by using this."

00:35:00.500 --> 00:35:05.230
Another great thing to do is that if you guys
are making any canvas 2D applications, there's

00:35:05.230 --> 00:35:10.760
a library out there called WebGL2D.JS which
you can Google for, and it implements the

00:35:10.760 --> 00:35:14.690
canvas API on top of WebGL.
And so what that means is you could check,

00:35:14.690 --> 00:35:19.220
does the user have WebGL? If so, use this.
You don't have to change any code in your

00:35:19.220 --> 00:35:22.559
application, but now that it's in WebGL you
can apply these effects.

00:35:22.559 --> 00:35:27.160
So it could be that if the user has WebGL,
he gets to play your fancy 2D game with effects,

00:35:27.160 --> 00:35:31.420
like maybe the screen goes all radioactive
when he's, you know, invincible or you add

00:35:31.420 --> 00:35:34.140
like that kind of blur effect when he's going
really fast, and if he's using the regular

00:35:34.140 --> 00:35:38.500
canvas, you skip that.
And the other thing is, it doesn't have to

00:35:38.500 --> 00:35:41.550
be used in the entire canvas. In this case,
I was calling post-progressing because I'm

00:35:41.550 --> 00:35:45.589
applying it to the entire canvas. But there
are games like Metroid Prime where you have

00:35:45.589 --> 00:35:48.680
glasses, goggles, that you look through and
only through those goggles is this effect

00:35:48.680 --> 00:35:52.950
applied and, you know, you see infrared inside
the goggles and outside the goggles you don't.

00:35:52.950 --> 00:35:55.920
Those kind of games is -- this is how they
do some of those effects.

00:35:55.920 --> 00:36:04.460
All right. I'm going to go through a few WebGL
dos and don'ts.

00:36:04.460 --> 00:36:09.589
Number one is, never ever call GL get anything
while rendering. And I've seen this in people's

00:36:09.589 --> 00:36:14.329
code. You can call -- when you're looking
up uniforms, you need to call get uniform

00:36:14.329 --> 00:36:18.009
location, and sometimes if you want to check
for errors, you call GL get error. There's

00:36:18.009 --> 00:36:21.759
a few other things you might query out of
GL. You should be doing that all during setup.

00:36:21.759 --> 00:36:26.940
That's normal for experienced OpenGL programmers,
that you should never call get anything while

00:36:26.940 --> 00:36:30.350
rendering, but if you're new, you might not
have known this. The thing is that that's

00:36:30.350 --> 00:36:35.280
normal, right? It's just normal to set up
your code so that you don't need to call it.

00:36:35.280 --> 00:36:39.130
One other thing you can do is -- for checking
for errors is there are things we like to

00:36:39.130 --> 00:36:43.000
call internally "debug context" and if you
search for WebGL debug context, I'm sure something

00:36:43.000 --> 00:36:46.069
will come up. There's one on the WebGL Wiki
if you search for that.

00:36:46.069 --> 00:36:52.140
It's a function that wraps the whole WebGL
context so that it calls GL error after every

00:36:52.140 --> 00:36:54.710
function, and that makes it very easy to turn
on and off. You can -- when you're debugging,

00:36:54.710 --> 00:36:57.990
you can turn that on, see if you get an error,
then turn it off, and you're back to normal.

00:36:57.990 --> 00:37:01.089
You didn't have to affect the rest of your
code with all your checks.

00:37:01.089 --> 00:37:07.640
And to give you an example, here is our thousand-cube
example before that was running at 30 to 40

00:37:07.640 --> 00:37:18.140
hertz. It's now returning at 8 because I'm
calling GL get after every object.

00:37:18.140 --> 00:37:22.519
This is kind of similar, and it probably comes
up less often, but don't attach render buffers

00:37:22.519 --> 00:37:25.280
while rendering.
And what I mean by that, a good example is

00:37:25.280 --> 00:37:31.240
our persistence example. We had two framebuffer
objects, and those framebuffer objects each

00:37:31.240 --> 00:37:35.259
have two render buffer objects. Render buffers
are the actual memory that holds their data

00:37:35.259 --> 00:37:41.250
and the framebuffer object is just state.
A lot of people will make one framebuffer

00:37:41.250 --> 00:37:44.809
object and say two render buffer objects or
two textures and when they need to switch

00:37:44.809 --> 00:37:48.079
to what they're going to render to, they will
attach the texture to this framebuffer object,

00:37:48.079 --> 00:37:51.109
do some rendering, attach a different one,
and do some rendering.

00:37:51.109 --> 00:37:56.250
Well, that attaching is actually a relatively
slow process. A lot of checks have to be made

00:37:56.250 --> 00:38:00.839
by GL. Instead, just make two or more framebuffer
objects. The framebuffer objects just hold

00:38:00.839 --> 00:38:05.720
state. They hold a combination of render buffers
and textures, and so you can make as many

00:38:05.720 --> 00:38:09.640
of them as you want. They don't take a lot
of memory. They're just state. But that means

00:38:09.640 --> 00:38:12.950
you can do that all during setup. And when
you do set those up, you also have to call

00:38:12.950 --> 00:38:16.549
check framebuffer status to see if they actually
worked. That, is, again, another set call

00:38:16.549 --> 00:38:21.630
-- or get call like in the last example and
will really slow your code down. So do this

00:38:21.630 --> 00:38:27.829
all during setup and it's all good.
One thing to do do is do use request animation

00:38:27.829 --> 00:38:30.549
frame.
Up until this point, if you've done any animation

00:38:30.549 --> 00:38:35.980
in JavaScript, even in just regular HTML or
with the canvas, the only way to do it was

00:38:35.980 --> 00:38:41.160
with -- was with using set interval or set
time-out.

00:38:41.160 --> 00:38:45.220
The problem with those two functions are,
JavaScript and the browser have no way to

00:38:45.220 --> 00:38:49.369
know why are you -- why you are using that
function. Maybe you're writing a Gmail type

00:38:49.369 --> 00:38:53.700
of app and you are going to check for messages
or you're writing a chat app and you're checking

00:38:53.700 --> 00:38:58.430
for new chat things.
And so even when your tab is hidden or it's

00:38:58.430 --> 00:39:03.869
off the screen somehow or your window is minimized,
JavaScript or the browser has to call your

00:39:03.869 --> 00:39:05.789
function. Because it doesn't know why you're
using it.

00:39:05.789 --> 00:39:08.990
So if you're rendering a game and it's off
the screen, you're just going to sit there

00:39:08.990 --> 00:39:11.799
and kind of DOS the user's machine. You're
sitting there rendering your game for no reason.

00:39:11.799 --> 00:39:14.430
He's not playing it, he's not looking at it,
it's not on the screen.

00:39:14.430 --> 00:39:19.380
Whereas if you use set -- if you use request
animation frame, that's specifically for animation.

00:39:19.380 --> 00:39:24.289
It only calls you when your canvas is visible,
whether it's scrolled off, whether it's minimized,

00:39:24.289 --> 00:39:26.869
whether it's under the tab, and so you won't
DOS the user's machine.

00:39:26.869 --> 00:39:30.890
So I kind of like to put it, set interval
or set time-out is for people who hate their

00:39:30.890 --> 00:39:34.430
users and request animation frame is for people
who love their users.

00:39:34.430 --> 00:39:38.180
The fortunate thing is, it's implemented in
Chrome, it's implemented in FireFox, it's

00:39:38.180 --> 00:39:44.570
implemented in Webkit, or will be soon, and
there are wrappers. They're very short. You

00:39:44.570 --> 00:39:48.880
can just search Google for request animation
frame and I'm sure you'll find one that will

00:39:48.880 --> 00:39:51.930
just work across browsers. They will fall
back to the bad set interval or set time-out

00:39:51.930 --> 00:39:56.190
if they have no other option, but they will
use request animation frame in any browser

00:39:56.190 --> 00:40:03.319
that implements it, if it's available.
So a few tips.

00:40:03.319 --> 00:40:08.240
One, consider stretching the canvas for performance.
This might be obvious, but I think a lot of

00:40:08.240 --> 00:40:12.710
people don't notice. The canvas has two actual
sizes. One is the size you actually render

00:40:12.710 --> 00:40:15.609
to and one is the size that displays that,
and those are separate.

00:40:15.609 --> 00:40:20.430
So in this top example, I'm setting the canvas
size that I want to render to to 512-by-512,

00:40:20.430 --> 00:40:24.009
but I'm saying "Display that a hundred percent
of whatever my container is."

00:40:24.009 --> 00:40:29.010
And why would you want to do that?
Well, if you're doing something complex -- for

00:40:29.010 --> 00:40:34.480
example, the WebGL aquarium -- it has fairly
complex shaders in certain parts, and those

00:40:34.480 --> 00:40:36.589
shaders have to run for every pixel to get
rendered.

00:40:36.589 --> 00:40:41.720
So if you have a 30-inch monitor and you have
whatever that is, 4 million pixels, well,

00:40:41.720 --> 00:40:46.299
that's a lot of work for the GPU to do.
Instead, you can draw it to a much smaller

00:40:46.299 --> 00:40:51.530
resolution. The actual aquarium only draws
to 1,024-by-1,024 and then it lets the browser

00:40:51.530 --> 00:40:56.609
stretch that canvas. Of course you're going
to get bit of resolution. It's kind of the

00:40:56.609 --> 00:40:59.410
like the difference between HD and SD, depending,
but it depends on what you're trying to do.

00:40:59.410 --> 00:41:02.950
A lot of times because you have a lot of motion
in your apps, that stuff is hidden. It's a

00:41:02.950 --> 00:41:06.140
great way to get more speed. And video does
this all the time, right? We take our small

00:41:06.140 --> 00:41:08.220
videos and we make them full-screen. Even
though the resolution in the video isn't the

00:41:08.220 --> 00:41:14.350
same size as the screen, it stretches.
The very cool thing about working in WebGL

00:41:14.350 --> 00:41:19.549
is that almost all your apps are going to
be 3D, and if you're doing it in 3D, almost

00:41:19.549 --> 00:41:24.160
every 3D library uses a function where you
set your prospective matrix -- you set your

00:41:24.160 --> 00:41:27.700
projection matrix to a prospective matrix,
and there's also this function called prospective,

00:41:27.700 --> 00:41:32.430
and it almost -- and every library takes the
same four arguments, field, view, aspect,

00:41:32.430 --> 00:41:36.390
and your Z settings.
To make this work, all you have to do is set

00:41:36.390 --> 00:41:40.140
your aspect to those values. You get the canvas
width divided by the canvas height. That's

00:41:40.140 --> 00:41:41.960
the size of the browser you're using to display
your canvas, not the size it's using to render

00:41:41.960 --> 00:41:51.480
it. And it just works. You didn't change anything.
And you get speed.

00:41:51.480 --> 00:41:59.249
Another tip is send your users to getWebGL.org.
And so you -- there are ways to detect if

00:41:59.249 --> 00:42:04.460
the browser supports WebGL at all and then
there's also the chance that it can't initialize

00:42:04.460 --> 00:42:09.869
WebGL for some reason. Maybe the user's card
is blacklisted or maybe it's out of memory

00:42:09.869 --> 00:42:12.970
or for whatever reason, it might not be able
to start it.

00:42:12.970 --> 00:42:20.349
In either case, if you send them to getWebGL.org,
we can try to direct them to the best help

00:42:20.349 --> 00:42:23.890
for their situation.
And I've seen some libraries kind of doing

00:42:23.890 --> 00:42:27.890
it themselves. They're like, "Oh, you can't
run WebGL. Download, you know, Chrome, or

00:42:27.890 --> 00:42:30.440
download FireFox."
Well, that's great until I'm running on a

00:42:30.440 --> 00:42:33.640
Web OS machine. That information is not going
to be useful to me.

00:42:33.640 --> 00:42:39.470
And so the idea is that the Chronos group
runs getWebGL.org, and you can go to their

00:42:39.470 --> 00:42:44.711
-- you can go to the WebGL public mailing
list and you can tell them if there's any

00:42:44.711 --> 00:42:48.839
issues you want, if you want them to redesign
this or you have some input, but basically

00:42:48.839 --> 00:42:51.510
they will try to keep it up-to-date for all
devices.

00:42:51.510 --> 00:42:56.200
And that's something that probably every developer
out there is not going to do by themselves.

00:42:56.200 --> 00:43:02.220
The last one I'm going to put up is to use
the WebGL inspector. If you haven't seen the

00:43:02.220 --> 00:43:08.880
WebGL inspector, it's very much like PIX for
directX or gDEBugger for GL. I won't tell

00:43:08.880 --> 00:43:14.990
you what Google uses it for but I will show
you it working.

00:43:14.990 --> 00:43:19.780
So here's an app you might have seen that
came out last Thursday. I changed the texture

00:43:19.780 --> 00:43:23.700
so it would be easier to visualize. I was
actually asked to review this app to make

00:43:23.700 --> 00:43:27.000
sure they weren't doing anything crazy, like
drawing every one of those lines one draw

00:43:27.000 --> 00:43:30.960
call at a time. And I looked at the code and
I wasn't exactly sure what it was doing, so

00:43:30.960 --> 00:43:33.430
I thought, "I know, I'll try out the WebGL
inspector."

00:43:33.430 --> 00:43:41.339
So the WebGL inspector is an extension for
Chrome. There's also a plug-in for FireFox.

00:43:41.339 --> 00:43:45.059
And it adds this little icon up here in Chrome.
And so I click that, and it will reload the

00:43:45.059 --> 00:43:52.970
page with the inspector installed. And I'll
tell it to capture a frame, and it's captured

00:43:52.970 --> 00:43:58.930
every draw call that WebGL made, and you can
step through them down here, and you can see

00:43:58.930 --> 00:44:03.740
here's the actual frame on the bottom right
corner. But if I scroll down and I find the

00:44:03.740 --> 00:44:10.109
first draw call, which is here, and I click
that, it will redraw the scene just using

00:44:10.109 --> 00:44:14.299
those first 17 commands, as I click command
17, and you can see in the bottom right -- it's

00:44:14.299 --> 00:44:17.579
kind of hard to see because the lines are
small but that's the globe without the line.

00:44:17.579 --> 00:44:23.730
I can also look, "Well, what program was that
using?" Well, I'll control up until I find

00:44:23.730 --> 00:44:27.299
the "use program" before that draw call. I'll
click it. Here's the program that was used

00:44:27.299 --> 00:44:34.599
to draw it. Here's all the inputs that it
had, and -- as well as the actual source code

00:44:34.599 --> 00:44:38.740
for that shader.
I can also like look at the textures. Here's

00:44:38.740 --> 00:44:41.430
all the textures that are used. There's only
three. Here's the world texture. It shows

00:44:41.430 --> 00:44:46.380
in the bottom right. I could go back to the
trace and I could see that it's setting up

00:44:46.380 --> 00:44:49.890
a buffer here. I'll click on that buffer and
it will show that buffer, and potentially

00:44:49.890 --> 00:44:56.869
how it was used and all the data in that buffer.
This is a great way to inspect your own program,

00:44:56.869 --> 00:45:05.009
find bugs, see what's going on and look at
other people's techniques and see what they

00:45:05.009 --> 00:45:12.880
are doing including your own.
And that's pretty much it. All the samples

00:45:12.880 --> 00:45:21.480
that I have shown are available now live at
WebGL samples. I put other demos up here.

00:45:21.480 --> 00:45:27.279
You could Google for all of those. I didn't
want to put links.

00:45:27.279 --> 00:45:31.079
If you have questions, come to the mics to
ask a question.

00:45:31.079 --> 00:45:32.079
[ Applause ]
Any questions?

00:45:32.079 --> 00:45:47.240
&gt;&gt;&gt; Yeah, hi.
&gt;&gt;Gregg Tavares: Hello.

00:45:47.240 --> 00:45:56.339
&gt;&gt;&gt; How can we deal with different platforms
like a Chrome Netbook that has add-on processors,

00:45:56.339 --> 00:46:03.470
a desktop that has a full-blown discrete GPU?
&gt;&gt;Gregg Tavares: How can we deal with?

00:46:03.470 --> 00:46:13.359
&gt;&gt;&gt; Different GPUs compared to the GPU in
JavaScript?

00:46:13.359 --> 00:46:15.200
&gt;&gt;Gregg Tavares: Well, one thing you have
to do -- You mean like the timing, the fact

00:46:15.200 --> 00:46:19.275
that they are different speeds or do you mean
the fact they have different capabilities?

00:46:19.275 --> 00:46:29.070
So the question was how to deal with different
GPUs. And the easiest way to do that is either

00:46:29.070 --> 00:46:37.579
to do something like they do on the PC and
ask people what features they want or to structure

00:46:37.579 --> 00:46:40.079
a code. You could do a timing and you could
see is it running too slow and, say, take

00:46:40.079 --> 00:46:44.190
some features out.
The other thing you need to do -- It is a

00:46:44.190 --> 00:46:49.329
hard question because you could be running
on a desktop that has, say, the highest-end

00:46:49.329 --> 00:46:55.640
GPU, the newest one with 2 gig of RAM or you
could be running on a low-end GPU like a G1.

00:46:55.640 --> 00:46:59.319
The original Google phones, I don't think
you can even run WebGL.

00:46:59.319 --> 00:47:04.069
And I don't really have a good answer for
that other than to either add some options

00:47:04.069 --> 00:47:08.130
and say have an SD version and HD version.
Some games do that.

00:47:08.130 --> 00:47:13.089
Or, yeah, just structure your code so you
can fall back if you run out of memory. Like,

00:47:13.089 --> 00:47:18.790
texture the things that are important first
and the other things that are less important

00:47:18.790 --> 00:47:20.490
later.
Yes, sir?

00:47:20.490 --> 00:47:28.150
&gt;&gt;&gt; This might be slightly off topic. So I
have been watching the FireFox team implement

00:47:28.150 --> 00:47:30.289
WebGL.
&gt;&gt;Gregg Tavares: Okay.

00:47:30.289 --> 00:47:41.260
&gt;&gt;&gt; And they have been having a pretty large
share of problems dealing with platform-specific

00:47:41.260 --> 00:47:43.760
driver bugs. And while dealing with that,
they've been very active in the driver community,

00:47:43.760 --> 00:47:44.760
asking lots of questions, contributing -- filing
upstream bugs.

00:47:44.760 --> 00:47:45.760
The Chrome team has been completely silent,
at least from the Linux driver perspective.

00:47:45.760 --> 00:47:57.099
And I was wondering if that's simply because
you guys had relatively little challenge with

00:47:57.099 --> 00:48:04.710
implementing WebGL or is it just a team policy?
&gt;&gt;Gregg Tavares: So I think the question was

00:48:04.710 --> 00:48:12.190
there's been a lot of talk from FireFox about
talking to the various graphic driver manufacturers

00:48:12.190 --> 00:48:15.089
about issues with driver stability, in particular
Linux.

00:48:15.089 --> 00:48:17.829
&gt;&gt;&gt; Yeah.
&gt;&gt;Gregg Tavares: Or just in general. And you

00:48:17.829 --> 00:48:21.349
haven't heard much from Google.
I can tell you that the chairman of the WebGL

00:48:21.349 --> 00:48:28.499
group is now Ken Russell, who's on the Chrome
GPU team. And he's probably the most vocal

00:48:28.499 --> 00:48:32.920
guy ever. That he isn't being vocal in public,
I think that's just happenstance because he

00:48:32.920 --> 00:48:36.630
is very vocal internally and he is very vocal.
I don't think it has crossed his mind he needs

00:48:36.630 --> 00:48:39.839
to be more vocal in public, and I will bring
that up with him.

00:48:39.839 --> 00:48:45.599
He is heading the charge to get our robustness
stuff into the drivers and to make sure all

00:48:45.599 --> 00:48:51.119
these issues are dealt with both for platforms
in general including Linux.

00:48:51.119 --> 00:48:58.240
&gt;&gt;&gt; Okay, thank you.
&gt;&gt;&gt; Just a sort of platform-specific question.

00:48:58.240 --> 00:49:06.809
Honeycomb tablets with Tegra processors and
video chips, when do you see WebGL making

00:49:06.809 --> 00:49:12.460
it to Mobile Web Kit?
&gt;&gt;Gregg Tavares: When do I see -- so the question

00:49:12.460 --> 00:49:17.269
is related to tablets and them having good
GPUs, when do we see WebGL making it to Mobile

00:49:17.269 --> 00:49:20.759
Web Kit? I don't have a good answer for you
on the Web Kit front. I do know it is available

00:49:20.759 --> 00:49:25.599
in FireFox right now. You can download FireFox
for those machines and it will run WebGL.

00:49:25.599 --> 00:49:30.859
I have been told that it's not -- you know,
it is still very beta and there is not performance

00:49:30.859 --> 00:49:34.069
optimize there yet, but it does work. I have
seen demos come up.

00:49:34.069 --> 00:49:37.829
&gt;&gt;&gt; Okay, great, thanks.
&gt;&gt;Gregg Tavares: I actually -- yeah. I actually

00:49:37.829 --> 00:49:40.170
have seen it running in Web Kit in certain
places. But when it would be available, I

00:49:40.170 --> 00:49:43.829
have no idea.
&gt;&gt;&gt; There's been a bit of press about security

00:49:43.829 --> 00:49:52.380
vulnerabilities exposed by WebGL. Are you
guys doing anything to address that?

00:49:52.380 --> 00:49:57.130
&gt;&gt;Gregg Tavares: So the question is there's
been some security vulnerabilities that just

00:49:57.130 --> 00:50:00.730
came out, I think it was yesterday, in WebGL
and what are we doing to address that. We

00:50:00.730 --> 00:50:04.869
are taking that seriously. Obviously Chrome's
main thing is that we are all about security.

00:50:04.869 --> 00:50:09.329
Chrome in particular, we actually run all
of our GPU processing in a separate process.

00:50:09.329 --> 00:50:16.220
So, like, we do for other things, even if
somehow a Web page was able to execute code

00:50:16.220 --> 00:50:21.650
in the process that actually runs your Web
page, it is not allowed to call GL at all.

00:50:21.650 --> 00:50:27.023
Or at least if it does call it, it can't call
it with any parameters that we don't approve.

00:50:27.023 --> 00:50:31.920
That said, we are taking it very seriously.
We are talking -- we are with the Chronos

00:50:31.920 --> 00:50:36.410
group and discussing it with the other browser
vendors to decide what to do. We are working

00:50:36.410 --> 00:50:39.960
with the driver manufacturers to make sure
all these issues are covered because they

00:50:39.960 --> 00:50:43.869
know up until this point, it has always been
you installed an app and you trusted that

00:50:43.869 --> 00:50:47.680
app when you installed it.
And it is changing to this new Web model where

00:50:47.680 --> 00:50:51.289
things are supposed to be not trusted and
you just have to make yourself secure. So

00:50:51.289 --> 00:50:55.180
we file every bug we can. We blacklist any
card we find that has a problem.

00:50:55.180 --> 00:51:00.559
That's why so many cards are blacklisted right
now. Any card before 2009, January 2009, is

00:51:00.559 --> 00:51:04.329
blacklisted and other one that is we find
bugs in.

00:51:04.329 --> 00:51:07.190
&gt;&gt;&gt; Okay, thank you.
&gt;&gt;Gregg Tavares: Any other questions?

00:51:07.190 --> 00:51:18.759
(Speaker off microphone.)
&gt;&gt;Gregg Tavares: So the question was what's

00:51:18.759 --> 00:51:22.470
the performance penalty for the Sandbox in
Chrome? We are actually not sure.

00:51:22.470 --> 00:51:27.359
My personal opinion is that we actually run
faster. And the reason is that we are, basically,

00:51:27.359 --> 00:51:33.000
multi-processing your app because what we
do is we take all your WebGL calls and we

00:51:33.000 --> 00:51:36.780
serialize them through a command buffer. That
actually get called by another process. And

00:51:36.780 --> 00:51:41.529
that means your WebGL code is able to issue
them much faster than it could without that.

00:51:41.529 --> 00:51:46.760
And then some other process is able to spend
the time doing the hard work.

00:51:46.760 --> 00:51:50.440
There are issues we have. We have flow control
issues we keep working on, that we get more

00:51:50.440 --> 00:51:56.349
speed and add something else and then we break
that and get a little less speed. Ultimately,

00:51:56.349 --> 00:52:00.970
we should be able to run faster because of
our Sandbox, not slower.

00:52:00.970 --> 00:52:03.150
Any other questions? All right. Thank you
very much.

00:52:03.150 --> 00:52:03.339
[ Applause ]

