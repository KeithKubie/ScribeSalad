WEBVTT
Kind: captions
Language: en

00:00:00.050 --> 00:00:01.150
ANKUR KOTWAL: G'day, everyone.

00:00:01.150 --> 00:00:02.280
How you guys doing?

00:00:02.280 --> 00:00:05.720
[APPLAUSE]

00:00:05.720 --> 00:00:06.890
ANKUR KOTWAL: That's good.

00:00:06.890 --> 00:00:09.900
So this is the last session
before you guys

00:00:09.900 --> 00:00:10.950
get your new toys--

00:00:10.950 --> 00:00:13.690
I mean, Android development
devices.

00:00:13.690 --> 00:00:15.560
That's what you're going
to use them for, right?

00:00:15.560 --> 00:00:18.130
So we're going to make sure we
finish on time, and you guys

00:00:18.130 --> 00:00:20.930
can rush down and
pick them up.

00:00:20.930 --> 00:00:23.480
So the good thing is, we're
not too far from the

00:00:23.480 --> 00:00:26.500
elevators, so you'll be
able to get down.

00:00:26.500 --> 00:00:29.210
My name is Ankur Kotwal, and
I'm an Android developer

00:00:29.210 --> 00:00:31.310
advocate from Sydney,
Australia.

00:00:31.310 --> 00:00:35.160
I'm also joined today by some
friends and colleagues, Tony

00:00:35.160 --> 00:00:39.870
Chan from Hong Kong and Tim Bray
from Vancouver, Canada.

00:00:39.870 --> 00:00:42.870
So you'll see we have a very
global panel here today, and I

00:00:42.870 --> 00:00:46.660
hope that you find what we're
presenting to not just be

00:00:46.660 --> 00:00:51.190
interesting, but our aim is so
that it plants that seed in

00:00:51.190 --> 00:00:57.860
your mind that makes you want
to build innovative and fun

00:00:57.860 --> 00:01:00.040
experiences for your users.

00:01:00.040 --> 00:01:02.840
So today, we're going to
talk about sensors.

00:01:02.840 --> 00:01:07.220
And not those types of censors
that rate movies or silence

00:01:07.220 --> 00:01:07.810
their critics.

00:01:07.810 --> 00:01:10.850
We're talking about the pieces
of hardware in your Android

00:01:10.850 --> 00:01:14.860
devices that provide you with
useful information that you

00:01:14.860 --> 00:01:20.810
can't get from traditional
computing devices like laptops

00:01:20.810 --> 00:01:23.540
or desktop computers.

00:01:23.540 --> 00:01:26.280
So we're going to start
off by showing you a

00:01:26.280 --> 00:01:28.720
demo that we've built.

00:01:28.720 --> 00:01:29.970
So let's switch over.

00:01:33.074 --> 00:01:37.210
Have we got on the
right screen?

00:01:37.210 --> 00:01:38.160
Just waiting for it to switch.

00:01:38.160 --> 00:01:42.300
OK, so we've built a
game of Blackjack.

00:01:42.300 --> 00:01:44.550
And we thought, how can
we push the envelope?

00:01:44.550 --> 00:01:46.535
Let's use four Nexus
7 devices.

00:01:50.420 --> 00:01:53.220
With Blackjack, it's typically
dealer versus player.

00:01:53.220 --> 00:01:55.260
You're not competing against
one another,

00:01:55.260 --> 00:01:56.960
just against the casino.

00:01:56.960 --> 00:02:01.610
And the aim of the game is to
have your cards tally to 21 or

00:02:01.610 --> 00:02:05.980
as close to 21 as you can get
without exceeding it.

00:02:05.980 --> 00:02:07.770
So let's get started.

00:02:07.770 --> 00:02:11.110
I'm going to play the dealer,
and you'll see I've got a deck

00:02:11.110 --> 00:02:12.970
of cards here.

00:02:12.970 --> 00:02:17.100
And on the right-hand side,
it's the dealer's cards.

00:02:17.100 --> 00:02:18.790
Tim and Tony have
their rounds.

00:02:18.790 --> 00:02:21.440
So we're going to use a bunch
of gestures and a bunch of

00:02:21.440 --> 00:02:25.436
sensors to actually simulate
this demo.

00:02:25.436 --> 00:02:27.760
All right, so it says
game started.

00:02:27.760 --> 00:02:30.140
What I'm going to do
is deal one card

00:02:30.140 --> 00:02:30.620
to each of the players.

00:02:30.620 --> 00:02:35.810
So one to Tim, one to Tony, one
to the dealer, do another

00:02:35.810 --> 00:02:38.620
round of cards.

00:02:38.620 --> 00:02:40.380
I'm just going to space
them out nicely.

00:02:40.380 --> 00:02:42.866
So right now, it says
it's Tim's turn.

00:02:42.866 --> 00:02:44.670
Tim, you're on 15.

00:02:44.670 --> 00:02:45.640
What would you like to do?

00:02:45.640 --> 00:02:46.580
TIM BRAY: Hit me, baby.

00:02:46.580 --> 00:02:47.050
Wait a second.

00:02:47.050 --> 00:02:49.150
You wrote the software,
didn't you?

00:02:49.150 --> 00:02:49.980
ANKUR KOTWAL: I did.

00:02:49.980 --> 00:02:53.610
So Tim said "Hit me." What that
means in Blackjack is

00:02:53.610 --> 00:02:55.110
give me another card.

00:02:55.110 --> 00:02:58.790
And the way you signal that in
a casino to a dealer is by

00:02:58.790 --> 00:03:02.190
tapping on your cards
or on the table.

00:03:02.190 --> 00:03:07.090
So Tim, could you
please do that?

00:03:07.090 --> 00:03:09.454
One more time?

00:03:09.454 --> 00:03:10.780
No.

00:03:10.780 --> 00:03:11.990
There we go.

00:03:11.990 --> 00:03:14.370
All right, so we're going
to deal a card to Tim.

00:03:14.370 --> 00:03:15.490
And Tim, now you're on 20.

00:03:15.490 --> 00:03:16.470
What would you like to do?

00:03:16.470 --> 00:03:18.400
TIM BRAY: Oh, I'll stand.

00:03:18.400 --> 00:03:19.150
ANKUR KOTWAL: You're
going to stand.

00:03:19.150 --> 00:03:21.670
So "stand" in Blackjack
means, I'm done.

00:03:21.670 --> 00:03:23.500
I'm happy with how many
points I'm on.

00:03:23.500 --> 00:03:24.300
And Tim's on 20.

00:03:24.300 --> 00:03:25.600
He doesn't want to
take a risk.

00:03:25.600 --> 00:03:28.730
So the way you do that in a
casino is that you wave your

00:03:28.730 --> 00:03:32.150
hand over the cards.

00:03:32.150 --> 00:03:36.160
And you'll see that Tim's
device said you're done.

00:03:36.160 --> 00:03:36.705
You're on 20.

00:03:36.705 --> 00:03:39.790
It's told me to deal a card
on my side to Tony.

00:03:39.790 --> 00:03:42.080
So Tony, what would
you like to do?

00:03:42.080 --> 00:03:43.470
TONY CHAN: Well, I'm on 11.

00:03:43.470 --> 00:03:48.270
I want to hit a blackjack,
so hit me.

00:03:48.270 --> 00:03:49.740
ANKUR KOTWAL: OK,
so there we go.

00:03:49.740 --> 00:03:51.490
It came up on mine.

00:03:51.490 --> 00:03:53.690
Tony, you're on 18.

00:03:53.690 --> 00:03:54.860
Come on, take a gamble.

00:03:54.860 --> 00:03:55.510
No?

00:03:55.510 --> 00:03:56.660
TONY CHAN: No, I'm
going to stay.

00:03:56.660 --> 00:03:58.040
ANKUR KOTWAL: You're
going to stand.

00:03:58.040 --> 00:04:01.470
All right so Tony
has stood on 18.

00:04:01.470 --> 00:04:02.910
Tim is on 20.

00:04:02.910 --> 00:04:06.150
The dealer has one card face
up, one card face down.

00:04:06.150 --> 00:04:09.240
So we're going to
flip the card.

00:04:09.240 --> 00:04:11.144
[LAUGHTER]

00:04:11.144 --> 00:04:12.100
ANKUR KOTWAL: 19.

00:04:12.100 --> 00:04:14.290
Now, that's pretty good for the
dealer, so I'm also going

00:04:14.290 --> 00:04:16.529
to just stand.

00:04:16.529 --> 00:04:18.350
And you'll see that that's
the end of the round.

00:04:18.350 --> 00:04:22.180
So I was able to defeat
Tony, and I

00:04:22.180 --> 00:04:23.420
unfortunately lost to Tim.

00:04:23.420 --> 00:04:25.970
How about we do one more
round of that, guys?

00:04:25.970 --> 00:04:27.530
You OK with that?

00:04:27.530 --> 00:04:29.500
TONY CHAN: Well, I'm going
to sit this one out.

00:04:29.500 --> 00:04:32.640
I saw your code, too.

00:04:32.640 --> 00:04:34.260
ANKUR KOTWAL: You're saying
it's rigged, Tony?

00:04:34.260 --> 00:04:35.710
That's fine.

00:04:35.710 --> 00:04:38.820
So since Tony's not playing,
Tony just flipped his device.

00:04:38.820 --> 00:04:40.290
All right, Tim, it's
just you and me.

00:04:40.290 --> 00:04:42.716
Let's have one more round.

00:04:42.716 --> 00:04:44.280
All right, here we go.

00:04:44.280 --> 00:04:48.030
One card to you, one card to
dealer, one card to you, one

00:04:48.030 --> 00:04:50.030
card to me.

00:04:50.030 --> 00:04:52.040
What do you reckon, Tim?

00:04:52.040 --> 00:04:54.590
Hit you, all right.

00:04:54.590 --> 00:04:55.880
What're you on?

00:04:55.880 --> 00:04:56.870
20.

00:04:56.870 --> 00:04:59.360
What would you like to do?

00:04:59.360 --> 00:05:00.060
You're standing.

00:05:00.060 --> 00:05:03.840
All right Dealer's turn.

00:05:03.840 --> 00:05:04.840
Blackjack!

00:05:04.840 --> 00:05:06.990
[LAUGHTER]

00:05:06.990 --> 00:05:08.280
TIM BRAY: He wrote the
code, like I said.

00:05:08.280 --> 00:05:10.070
ANKUR KOTWAL: The moral of the
story is that the casino

00:05:10.070 --> 00:05:13.125
always wins.

00:05:13.125 --> 00:05:15.280
All right, let's switch
back to the slides.

00:05:15.280 --> 00:05:17.440
So that was a fun little
demo that we built.

00:05:17.440 --> 00:05:19.950
And what we want you to realize
is that that demo

00:05:19.950 --> 00:05:22.820
didn't actually utilize the
traditional layer of

00:05:22.820 --> 00:05:24.780
abstraction you get from
a user interface.

00:05:24.780 --> 00:05:25.950
There were no buttons.

00:05:25.950 --> 00:05:28.920
We were trying to build a
natural user interface to

00:05:28.920 --> 00:05:31.320
simulate a natural experience.

00:05:31.320 --> 00:05:33.590
And we did that using sensors.

00:05:33.590 --> 00:05:36.400
So let's look at which sensors
and how we did it.

00:05:36.400 --> 00:05:39.400
First and foremost, touch,
the touchscreen.

00:05:39.400 --> 00:05:41.980
The great thing about the
touchscreen is that you

00:05:41.980 --> 00:05:44.030
automatically get these
events passed to you.

00:05:44.030 --> 00:05:45.410
You don't need to
ask for them.

00:05:45.410 --> 00:05:48.030
All you have to do in your
code is override the

00:05:48.030 --> 00:05:50.340
onTouchEvent method.

00:05:50.340 --> 00:05:53.680
Now, on developer.android.com,
there's a lot of information

00:05:53.680 --> 00:05:56.620
on how to process these
motion events.

00:05:56.620 --> 00:05:59.530
And there are also third-party
websites that have a lot of

00:05:59.530 --> 00:06:02.010
documentation for this.

00:06:02.010 --> 00:06:04.300
So you would think, oh, well,
with all this information

00:06:04.300 --> 00:06:07.410
available, it's really
easy, right?

00:06:07.410 --> 00:06:08.390
Not quite.

00:06:08.390 --> 00:06:11.700
There is a bit of a learning
curve that's involved in

00:06:11.700 --> 00:06:13.690
processing this stuff.

00:06:13.690 --> 00:06:16.000
So that documentation,
it helps.

00:06:16.000 --> 00:06:18.700
So once you know what you're
doing, you can really achieve

00:06:18.700 --> 00:06:20.040
things rapidly.

00:06:20.040 --> 00:06:23.250
But to start off with, it can
be a little bit hard.

00:06:23.250 --> 00:06:25.880
So what I'd like to share with
you is a couple of utility

00:06:25.880 --> 00:06:29.630
classes that we have in the
framework that can help you.

00:06:29.630 --> 00:06:34.360
We use the GestureDetector class
in this sample to detect

00:06:34.360 --> 00:06:35.895
things like the tap.

00:06:35.895 --> 00:06:40.050
And all we have to do was pass
out motion event objects to

00:06:40.050 --> 00:06:44.000
the gesture detector, and it
would call back when one of

00:06:44.000 --> 00:06:46.750
those gestures had
been fired off.

00:06:46.750 --> 00:06:49.420
We also use the VelocityTracker
to track that

00:06:49.420 --> 00:06:53.710
when I've lifted my finger after
the swipe, what speed

00:06:53.710 --> 00:06:57.700
those cards needed
to fly across at.

00:06:57.700 --> 00:07:00.610
So that was the VelocityTracker.

00:07:00.610 --> 00:07:03.330
The next one is the Gesture
builder sample.

00:07:03.330 --> 00:07:07.080
This is a piece of open-source
code that we've made available

00:07:07.080 --> 00:07:11.590
on Google Code that allows you
to detect or capture complex

00:07:11.590 --> 00:07:15.840
gestures, like drawing a plus
symbol and then acting on it.

00:07:15.840 --> 00:07:18.800
Or something even more
complicated is doing a spiral.

00:07:18.800 --> 00:07:21.590
So in a game, you might use
that to cast a spell.

00:07:21.590 --> 00:07:24.550
So that sample there helps
you capture that gesture

00:07:24.550 --> 00:07:26.940
and then detect it.

00:07:26.940 --> 00:07:29.220
We also have a blog post that
goes with it, so it's really

00:07:29.220 --> 00:07:31.560
worth your while
looking at it.

00:07:31.560 --> 00:07:35.430
What I'd like to share with
you now is a recipe.

00:07:35.430 --> 00:07:38.410
So we did a multi-touch gesture
to collect cards.

00:07:38.410 --> 00:07:41.600
We used five fingers and pulled
it in, and it collected

00:07:41.600 --> 00:07:43.560
the cards from the players.

00:07:43.560 --> 00:07:45.830
And what we're going to do is
share an algorithm with you

00:07:45.830 --> 00:07:47.020
with some code.

00:07:47.020 --> 00:07:50.330
And you'll see with all of our
recipes, the way it works is

00:07:50.330 --> 00:07:52.610
that we have a data-gathering
phase and a

00:07:52.610 --> 00:07:54.510
gesture-detection phase.

00:07:54.510 --> 00:07:57.200
So this here is the
data-gathering phase.

00:07:57.200 --> 00:07:59.490
And the way it works is that
we have an initial IF

00:07:59.490 --> 00:08:02.700
condition that says, is there
a gesture still in progress?

00:08:02.700 --> 00:08:04.870
Because the motion event tells
us that, hey, you want to

00:08:04.870 --> 00:08:07.320
cancel the gesture
or you want--

00:08:07.320 --> 00:08:10.040
the last finger has come off,
so just reset your state.

00:08:10.040 --> 00:08:11.140
That's not what we're
doing here.

00:08:11.140 --> 00:08:13.220
We're saying we're continuing.

00:08:13.220 --> 00:08:14.660
And what we do for
this particular

00:08:14.660 --> 00:08:16.920
algorithm is two things.

00:08:16.920 --> 00:08:20.620
One is get an initial snapshot
of all your fingers.

00:08:20.620 --> 00:08:24.040
And once we have that initial
snapshot, we also go and get a

00:08:24.040 --> 00:08:25.195
current snapshot.

00:08:25.195 --> 00:08:28.900
And as this method is invoked
again and again, we keep

00:08:28.900 --> 00:08:31.890
updating that current
snapshot.

00:08:31.890 --> 00:08:35.450
Now that's the data-gathering
phase.

00:08:35.450 --> 00:08:38.730
Let's look at the
gesture-detection phase.

00:08:38.730 --> 00:08:43.970
What we do here is basically we
go through and compare that

00:08:43.970 --> 00:08:46.990
initial snapshot and the
current snapshot.

00:08:46.990 --> 00:08:50.300
So the way we do that is that we
get our initial snapshot--

00:08:50.300 --> 00:08:52.090
well, we do this for
both snapshots.

00:08:52.090 --> 00:08:55.040
We work out what is the maximum
distance between any

00:08:55.040 --> 00:08:56.970
two combinations of fingers?

00:08:56.970 --> 00:08:59.270
And we store that in our
initial snapshot.

00:08:59.270 --> 00:09:01.990
We do the same thing for
our current snapshot.

00:09:01.990 --> 00:09:07.050
And when the current snapshot
is 30% or less than the

00:09:07.050 --> 00:09:10.110
initial snapshot, we consider
the gesture as having been

00:09:10.110 --> 00:09:15.440
triggered, so initial snapshot,
current snapshot.

00:09:15.440 --> 00:09:18.000
We can go the opposite way as
well to say when our initial

00:09:18.000 --> 00:09:21.880
snapshot is 30% of the size
or less than our current

00:09:21.880 --> 00:09:24.990
snapshot, we've gone
a pinch out.

00:09:24.990 --> 00:09:27.650
So this is a very simple
implementation of that

00:09:27.650 --> 00:09:29.440
particular gesture, but
it worked quite

00:09:29.440 --> 00:09:31.830
well for our demo.

00:09:31.830 --> 00:09:36.070
There is a "gotcha," and that
"gotcha" is that we have used

00:09:36.070 --> 00:09:38.110
in our algorithm
three fingers.

00:09:38.110 --> 00:09:40.680
We said we only need to
detect three fingers.

00:09:40.680 --> 00:09:45.650
Now the reason for only three
fingers is because, as your

00:09:45.650 --> 00:09:49.970
fingers converge on a
touchscreen, the touchscreen

00:09:49.970 --> 00:09:53.550
can stop seeing them as two
skinny fingers and sometimes

00:09:53.550 --> 00:09:56.560
start to see them as one big fat
finger when they're really

00:09:56.560 --> 00:09:58.220
close together.

00:09:58.220 --> 00:10:01.020
So you don't want to sit there
waiting for five fingers

00:10:01.020 --> 00:10:04.180
because you make may never
hit your 30% threshold.

00:10:04.180 --> 00:10:06.770
So what we do is we say,
whenever we have three fingers

00:10:06.770 --> 00:10:10.425
or more, it's a valid
precondition for our

00:10:10.425 --> 00:10:12.340
gesture-detection phase.

00:10:12.340 --> 00:10:13.530
All right.

00:10:13.530 --> 00:10:16.860
So that's the multi-finger
pinch.

00:10:16.860 --> 00:10:18.900
One of the other interesting
things you would have seen

00:10:18.900 --> 00:10:23.500
today is that we had this wave
gesture when we did the stand.

00:10:23.500 --> 00:10:25.690
We just waved our hand over
the top of the device.

00:10:25.690 --> 00:10:28.222
We didn't actually touch
the screen at all.

00:10:28.222 --> 00:10:31.660
So you might be thinking, well,
how did we do this?

00:10:31.660 --> 00:10:33.260
Most developers assume
that we used the

00:10:33.260 --> 00:10:35.090
camera, and we didn't.

00:10:35.090 --> 00:10:37.460
We've used some other sensors.

00:10:37.460 --> 00:10:39.860
But before we talk about those,
I want to talk about

00:10:39.860 --> 00:10:42.285
best practices when
using sensors.

00:10:42.285 --> 00:10:45.480
See, the thing is, again,
sensors and sensor manager is

00:10:45.480 --> 00:10:48.750
quite well documented in
a variety of places.

00:10:48.750 --> 00:10:51.480
So what I want to share are
the best practices.

00:10:51.480 --> 00:10:55.670
The first one is that when you
request sensor data, you can

00:10:55.670 --> 00:10:59.000
actually specify how much or how
often it should give that

00:10:59.000 --> 00:11:01.300
data back, the rate.

00:11:01.300 --> 00:11:04.300
And we have four stages
or four rates

00:11:04.300 --> 00:11:06.710
that you can specify.

00:11:06.710 --> 00:11:10.100
You should not be tempted into
asking data back at the

00:11:10.100 --> 00:11:12.120
fastest rate as possible.

00:11:12.120 --> 00:11:15.980
Because if you do, you end
up like this guy--

00:11:15.980 --> 00:11:16.920
data overload.

00:11:16.920 --> 00:11:18.320
What do I do with it?

00:11:18.320 --> 00:11:21.730
The sensor data doesn't
necessarily mean that you have

00:11:21.730 --> 00:11:22.800
useful information.

00:11:22.800 --> 00:11:27.090
It is up to you, as the
developer, to translate that.

00:11:27.090 --> 00:11:28.980
And the way you do that is
using these different

00:11:28.980 --> 00:11:30.230
algorithms.

00:11:30.230 --> 00:11:32.720
But you want to make sure that
you don't have too much data,

00:11:32.720 --> 00:11:35.700
because the more data you
have, the more effort is

00:11:35.700 --> 00:11:40.190
required by your app to process
it, which means, then,

00:11:40.190 --> 00:11:43.240
if you're getting too much data,
your app could be less

00:11:43.240 --> 00:11:45.645
responsive to that gesture
because you're not processing

00:11:45.645 --> 00:11:47.950
it in time.

00:11:47.950 --> 00:11:51.280
The other thing you should look
at is the unregistered

00:11:51.280 --> 00:11:52.670
part of it.

00:11:52.670 --> 00:11:58.880
As soon as you can, you should
unregister for the sensor.

00:11:58.880 --> 00:12:01.800
And the reason for that is
that, again, from an

00:12:01.800 --> 00:12:05.000
efficiency point of view, your
app isn't sitting there

00:12:05.000 --> 00:12:07.760
processing all of this sensor
data that's coming in when

00:12:07.760 --> 00:12:11.640
you're just either not using
it or throwing it away.

00:12:11.640 --> 00:12:14.800
The other thing that happens
from running the sensors

00:12:14.800 --> 00:12:18.220
nonstop is that you cause
a drain on the battery.

00:12:18.220 --> 00:12:20.360
So suddenly, your
app is now a bad

00:12:20.360 --> 00:12:23.030
citizen on a user's device.

00:12:23.030 --> 00:12:25.920
You never want that.

00:12:25.920 --> 00:12:27.820
All right, now that we've talked
about this, let's go

00:12:27.820 --> 00:12:30.750
back to those telepathic
gestures.

00:12:30.750 --> 00:12:32.700
The first sensor I want
to talk about is

00:12:32.700 --> 00:12:34.610
the proximity sensor.

00:12:34.610 --> 00:12:38.300
The proximity sensor is
typically found on phones.

00:12:38.300 --> 00:12:42.780
And what it's used for is that,
when someone's on a call

00:12:42.780 --> 00:12:46.550
and we put the device up to our
face, the proximity sensor

00:12:46.550 --> 00:12:49.600
turns off the screen so that
our face isn't pressing

00:12:49.600 --> 00:12:52.260
buttons on the screen.

00:12:52.260 --> 00:12:54.900
You don't typically find it on
tablets because people don't

00:12:54.900 --> 00:12:57.290
tend to make phone calls on
these things, although I've

00:12:57.290 --> 00:13:00.330
seen some really large devices
that make me feel otherwise.

00:13:00.330 --> 00:13:02.300
Different topic.

00:13:02.300 --> 00:13:06.520
So with a Galaxy Nexus, the
maximum range of the proximity

00:13:06.520 --> 00:13:09.270
sensor is about 5 centimeters.

00:13:09.270 --> 00:13:13.110
So what that means is anything
outside of 5 centimeters it

00:13:13.110 --> 00:13:13.770
won't detect.

00:13:13.770 --> 00:13:16.110
It'll just say there's
no obstruction.

00:13:16.110 --> 00:13:19.310
Proximity sensors can give data
in gradual measurements--

00:13:19.310 --> 00:13:21.650
let's say 2 centimeters
or 3 centimeters--

00:13:21.650 --> 00:13:24.900
but many Android devices will
actually give you data in a

00:13:24.900 --> 00:13:27.070
binary or an on/off state.

00:13:27.070 --> 00:13:29.480
There is an obstruction
or there isn't.

00:13:29.480 --> 00:13:32.310
So again, from a best practices
point-of-view, you

00:13:32.310 --> 00:13:37.270
want to assume that you're
using binary data.

00:13:37.270 --> 00:13:39.920
Now, in terms of gestures, if we
try and do a gestures where

00:13:39.920 --> 00:13:45.370
our hand moves in and out from
the device and graph that, it

00:13:45.370 --> 00:13:49.090
looks a little bit like this
graph here, where between 0

00:13:49.090 --> 00:13:52.240
and 5 centimeters, I have
an obstruction.

00:13:52.240 --> 00:13:54.170
The distance is 0 centimeters.

00:13:54.170 --> 00:13:55.340
And above that, it's 5.

00:13:55.340 --> 00:13:58.260
So proximity sensors
are not so useful

00:13:58.260 --> 00:14:00.390
for detecting gestures.

00:14:00.390 --> 00:14:03.640
What is useful is
a light sensor.

00:14:03.640 --> 00:14:07.150
The light sensor gives you the
measurement in lumens per

00:14:07.150 --> 00:14:11.250
square meter of your ambient
light conditions.

00:14:11.250 --> 00:14:14.910
Now, if we look at the same
gesture with an ambient light

00:14:14.910 --> 00:14:18.360
sensor, move our hand in and out
and graph that, what you

00:14:18.360 --> 00:14:23.060
see is a gradual drop as the
hand comes in, and then stays

00:14:23.060 --> 00:14:25.580
there, and then goes back out.

00:14:25.580 --> 00:14:28.620
The cool thing about a light
sensor, however, is that we

00:14:28.620 --> 00:14:31.060
can detect another type
of gesture, which is

00:14:31.060 --> 00:14:33.720
the wave or the swipe.

00:14:33.720 --> 00:14:37.550
So if we graph that, you'll see
that the drop in the graph

00:14:37.550 --> 00:14:42.840
is a lot more sudden because
there wasn't much opportunity

00:14:42.840 --> 00:14:45.020
where your hand was partially
covering the light sensor.

00:14:45.020 --> 00:14:47.190
It pretty much is or it isn't.

00:14:47.190 --> 00:14:49.740
Now, you might be looking at
that graph and saying, what's

00:14:49.740 --> 00:14:52.580
that weird spike on the
right-hand side?

00:14:52.580 --> 00:14:54.240
Let me explain that.

00:14:54.240 --> 00:14:58.250
So when we recorded this
gesture, we used our fingers.

00:14:58.250 --> 00:15:01.720
And between the four fingers and
the thumb, there is a gap.

00:15:01.720 --> 00:15:04.390
So what's happened is when the
four fingers have swiped over

00:15:04.390 --> 00:15:08.140
the light sensor and gone past,
light has bled through

00:15:08.140 --> 00:15:10.820
between the fingers and the
thumb, and then the thumb has

00:15:10.820 --> 00:15:14.940
obscured it again, which is why
you get that little drop.

00:15:14.940 --> 00:15:18.550
So in terms of comparing these
two gestures, you have to look

00:15:18.550 --> 00:15:20.780
at the shape of the data or
the shape of the graph.

00:15:20.780 --> 00:15:22.800
You need to do some analysis.

00:15:22.800 --> 00:15:25.080
What I'm going to show you now
is the recipe that we used in

00:15:25.080 --> 00:15:29.820
the Blackjack game for the
swipe, or the stand gesture.

00:15:29.820 --> 00:15:32.520
What we do in the data gathering
phase is literally

00:15:32.520 --> 00:15:35.210
just fill up a circular
buffer.

00:15:35.210 --> 00:15:40.460
Our buffer is only 100 data
points, but it's enough.

00:15:40.460 --> 00:15:44.420
And then, every half a second,
what we do is go through that

00:15:44.420 --> 00:15:48.630
circular buffer and work out the
maximum light reading that

00:15:48.630 --> 00:15:53.280
we had from that buffer, and
then we get the current value

00:15:53.280 --> 00:15:55.990
and we compare them.

00:15:55.990 --> 00:16:00.180
If the current value is 20% or
less of that maximum value, we

00:16:00.180 --> 00:16:02.900
consider the gesture as having
being triggered.

00:16:02.900 --> 00:16:06.700
So initially, our maximum
value is there's lots of

00:16:06.700 --> 00:16:09.630
light, and then suddenly,
there's a lot less light, we

00:16:09.630 --> 00:16:10.610
consider it triggered.

00:16:10.610 --> 00:16:13.140
This is a very simple
and unsophisticated

00:16:13.140 --> 00:16:14.350
implementation.

00:16:14.350 --> 00:16:15.680
But for our demo, it
was sufficient.

00:16:18.430 --> 00:16:21.420
This particular implementation
does not distinguish between

00:16:21.420 --> 00:16:24.440
in and out and side to side.

00:16:24.440 --> 00:16:26.280
But as I said, it's more
than sufficient for

00:16:26.280 --> 00:16:28.130
what we were demoing.

00:16:28.130 --> 00:16:32.080
One last best practice that I'd
like to tell you is that I

00:16:32.080 --> 00:16:35.320
initially talked about
the proximity sensor.

00:16:35.320 --> 00:16:37.670
I said it's not really good
for gesture detection.

00:16:37.670 --> 00:16:41.700
But what it is good for is
gesture validation when you're

00:16:41.700 --> 00:16:43.200
using the light sensor.

00:16:43.200 --> 00:16:46.910
So one of the downsides to
purely using the light sensor

00:16:46.910 --> 00:16:50.280
is that you are relying on
consistent ambient lighting

00:16:50.280 --> 00:16:51.370
conditions.

00:16:51.370 --> 00:16:54.930
So if the user is using that app
on a train or bus, then as

00:16:54.930 --> 00:16:58.480
they go through a tunnel or go
through the shadow of trees or

00:16:58.480 --> 00:17:01.200
buildings, those light
conditions can change.

00:17:01.200 --> 00:17:03.350
And you don't want your gesture
being incorrectly

00:17:03.350 --> 00:17:04.589
triggered then.

00:17:04.589 --> 00:17:07.400
So what you do is use the light
sensor to detect the

00:17:07.400 --> 00:17:10.930
type of gesture, and then use
the proximity sensor to ensure

00:17:10.930 --> 00:17:14.569
that there was a hand or some
sort of obstruction in front

00:17:14.569 --> 00:17:15.660
of the device.

00:17:15.660 --> 00:17:17.329
And then you can be certain
that it was

00:17:17.329 --> 00:17:19.980
an intentional gesture.

00:17:19.980 --> 00:17:22.960
Now with that, I'm going
to hand it over to Tim.

00:17:22.960 --> 00:17:23.614
TIM BRAY: Thank you.

00:17:23.614 --> 00:17:25.300
Hey, how about a round of
applause for that Blackjack

00:17:25.300 --> 00:17:26.797
game that Ankur pulled
together?

00:17:26.797 --> 00:17:31.580
[APPLAUSE]

00:17:31.580 --> 00:17:34.410
TIM BRAY: So I'm here to talk
about motion-related stuff.

00:17:34.410 --> 00:17:36.930
And I would normally use the
word "gesture" to describe

00:17:36.930 --> 00:17:37.940
that, but they took that word.

00:17:37.940 --> 00:17:40.360
Gestures is apparently now what
you do on the screen and

00:17:40.360 --> 00:17:42.040
scribbles you make
on the screen.

00:17:42.040 --> 00:17:43.080
So I had to think of a word.

00:17:43.080 --> 00:17:46.210
So I'm going to say "kinetics"
to mean anything

00:17:46.210 --> 00:17:47.460
motion-related.

00:17:47.460 --> 00:17:50.880
And the core idea here is to
have apps that you control

00:17:50.880 --> 00:17:54.620
without having any buttons
or sliders or any

00:17:54.620 --> 00:17:55.310
other kind of thing.

00:17:55.310 --> 00:17:57.770
And you can imagine lots of
different kinetic gestures you

00:17:57.770 --> 00:18:01.210
can make with phones and devices
to control this.

00:18:01.210 --> 00:18:02.840
We've seen some usage in
the field of shake

00:18:02.840 --> 00:18:04.270
to undo, for example.

00:18:04.270 --> 00:18:06.600
But I think would go a lot
further than that.

00:18:06.600 --> 00:18:09.870
So what happened was I got an
idea for an app that would

00:18:09.870 --> 00:18:11.440
need a lot of this stuff.

00:18:11.440 --> 00:18:16.190
And like I always do when I'm
looking at a new Android API

00:18:16.190 --> 00:18:18.230
that I haven't used before, I
just went out and typed it

00:18:18.230 --> 00:18:21.210
into Google and assumed all the
best practices would pop

00:18:21.210 --> 00:18:24.630
up on stack overflow and our own
developer pages and so on.

00:18:24.630 --> 00:18:27.740
And I found more or
less nothing.

00:18:27.740 --> 00:18:29.630
And that may be the real news
story of this session here

00:18:29.630 --> 00:18:32.160
today, is not many people
are doing this stuff.

00:18:32.160 --> 00:18:34.350
I found a few places where they
told you how to detect a

00:18:34.350 --> 00:18:37.640
simple shake, but very, very
little for detecting anything

00:18:37.640 --> 00:18:39.830
by way of more structured
gestures.

00:18:39.830 --> 00:18:42.520
So the kind of stuff we're
talking about here is just not

00:18:42.520 --> 00:18:45.250
being done that much
out there.

00:18:45.250 --> 00:18:45.970
OK.

00:18:45.970 --> 00:18:50.340
So when I actually sat down to
write the app, I found that

00:18:50.340 --> 00:18:52.360
there's a lot of data coming
out of these things.

00:18:52.360 --> 00:18:55.240
They're throwing triples of
floating-point numbers at you

00:18:55.240 --> 00:18:58.310
many, many times per second, and
you need to get a feel for

00:18:58.310 --> 00:18:59.650
what this data is.

00:18:59.650 --> 00:19:01.920
And so I wrote this
app on Android

00:19:01.920 --> 00:19:03.640
market called Sensplore.

00:19:03.640 --> 00:19:05.550
S-E-N-S-P-L-O-R-E.

00:19:05.550 --> 00:19:06.470
It's there.

00:19:06.470 --> 00:19:08.680
And it gathers data.

00:19:08.680 --> 00:19:10.830
It's the simplest possible
app you can imagine.

00:19:10.830 --> 00:19:13.630
You press the button, and then
you shake the phone around,

00:19:13.630 --> 00:19:14.820
doing whatever you're doing.

00:19:14.820 --> 00:19:17.770
Then you press the button again,
and it saves it out as

00:19:17.770 --> 00:19:21.090
a CSV file and emails
you the CSV file.

00:19:21.090 --> 00:19:23.130
So then you drop that into a
spreadsheet, and you can look

00:19:23.130 --> 00:19:25.080
at all the beautiful numbers
coming out of the sensor and

00:19:25.080 --> 00:19:29.630
do things like draw graphs of
them like you see there on

00:19:29.630 --> 00:19:30.880
that device.

00:19:33.290 --> 00:19:34.860
Some people said, well, why
don't you just display the

00:19:34.860 --> 00:19:37.180
values on the screen of
the device instead?

00:19:37.180 --> 00:19:38.310
And that doesn't work.

00:19:38.310 --> 00:19:39.680
Because, first of all,
it's too small.

00:19:39.680 --> 00:19:41.630
And secondly, it's really hard
to watch the screen while

00:19:41.630 --> 00:19:43.990
you're shaking the
device around.

00:19:43.990 --> 00:19:48.150
So you can grab this and
run it and look at the

00:19:48.150 --> 00:19:49.240
graphs and so on.

00:19:49.240 --> 00:19:51.860
But since this is a developer
tool, you might find it

00:19:51.860 --> 00:19:55.720
handier to download the source
from code.google.com and hack

00:19:55.720 --> 00:19:58.200
it around to generate data
out of the sensor you're

00:19:58.200 --> 00:20:00.830
interested in and make use of
the stuff that's already in

00:20:00.830 --> 00:20:03.540
there for generating CSV and
emailing it to you and that

00:20:03.540 --> 00:20:05.250
kind of stuff.

00:20:05.250 --> 00:20:07.160
OK, it's got a few other
utility functions, too.

00:20:07.160 --> 00:20:10.320
So there are a lot of
kinetics-related sensors on

00:20:10.320 --> 00:20:12.930
your typical Android devices,
and they've kind of trickled

00:20:12.930 --> 00:20:14.020
in over the years.

00:20:14.020 --> 00:20:17.000
So typically, a modern high-end
Android device is

00:20:17.000 --> 00:20:20.620
going to have a lot more than
an older, cheaper device.

00:20:20.620 --> 00:20:23.210
Here is some timeline data.

00:20:23.210 --> 00:20:25.190
It's a little bit misleading.

00:20:25.190 --> 00:20:27.500
Just because something showed
up in API level 3 does not

00:20:27.500 --> 00:20:29.570
mean you can assume that
it's there in every

00:20:29.570 --> 00:20:32.410
device level 3 or higher.

00:20:32.410 --> 00:20:35.250
Some of these correspond
directly to actual physical

00:20:35.250 --> 00:20:36.310
sensors on the device.

00:20:36.310 --> 00:20:37.760
Others are synthetic.

00:20:37.760 --> 00:20:41.500
In particular, the data coming
out of the gyroscope is very

00:20:41.500 --> 00:20:43.450
accurate and very useful.

00:20:43.450 --> 00:20:45.850
But it doesn't come out in units
that correspond very

00:20:45.850 --> 00:20:48.810
well to the way computer
programmers think about how

00:20:48.810 --> 00:20:51.330
devices are moving around in
space unless, of course,

00:20:51.330 --> 00:20:54.920
they're PhDs in math who fully
understand the appropriate

00:20:54.920 --> 00:20:57.040
level of matrix algebra.

00:20:57.040 --> 00:20:59.190
So anyhow, so for that reason,
there are three synthetic

00:20:59.190 --> 00:21:00.980
sensors in there--
gravity, linear

00:21:00.980 --> 00:21:02.570
acceleration, and rotation.

00:21:02.570 --> 00:21:06.700
And they take the data coming
out of the accelerometer and

00:21:06.700 --> 00:21:08.670
the gyroscope and combine it to
something that's a little

00:21:08.670 --> 00:21:11.490
bit more programmer friendly.

00:21:11.490 --> 00:21:14.610
The good news is that these
have gotten a lot

00:21:14.610 --> 00:21:15.680
better since ICS.

00:21:15.680 --> 00:21:18.440
The quality of the data that's
coming out at you really is a

00:21:18.440 --> 00:21:22.710
lot better, but really only in
devices that have a gyroscope.

00:21:22.710 --> 00:21:25.600
And just to make that realistic,
here's some graphs

00:21:25.600 --> 00:21:29.930
that I drew coming out of
Sensplore of data, some

00:21:29.930 --> 00:21:31.330
gestures I'll talk about.

00:21:31.330 --> 00:21:33.500
But the top one is the Galaxy
Nexus and the bottom one is

00:21:33.500 --> 00:21:34.620
the Nexus One.

00:21:34.620 --> 00:21:36.920
And you can see-- well, first
of all, the data rate of the

00:21:36.920 --> 00:21:39.100
samples is different on the
Nexus One, even though I put

00:21:39.100 --> 00:21:40.510
the same argument in.

00:21:40.510 --> 00:21:44.150
And, secondly, the data on the
Nexus One is much less

00:21:44.150 --> 00:21:47.150
granular and much messier
and sort of floppy and

00:21:47.150 --> 00:21:48.360
harder to deal with.

00:21:48.360 --> 00:21:51.620
It may be the case that for
certain apps, you might want

00:21:51.620 --> 00:21:54.160
to probe for the presence of the
gyroscope and decline to

00:21:54.160 --> 00:21:55.410
proceed without it.

00:21:57.560 --> 00:21:59.590
OK, so let's talk about some
of the data coming out.

00:21:59.590 --> 00:22:02.290
You have to learn to think in
terms of coordinate systems.

00:22:02.290 --> 00:22:05.475
The sensors typically, for the
motion stuff, give you triples

00:22:05.475 --> 00:22:07.460
of floating point data.

00:22:07.460 --> 00:22:09.580
And it's really totally
essentially that you go and

00:22:09.580 --> 00:22:12.510
read the Java Docs in detail,
which are all in the Sensor

00:22:12.510 --> 00:22:15.430
Event Java Docs because
sometimes they are moving

00:22:15.430 --> 00:22:16.830
along the axes, and
sometimes they're

00:22:16.830 --> 00:22:19.080
moving around the axes.

00:22:19.080 --> 00:22:20.960
And by the way, since we're
all from Commonwealth

00:22:20.960 --> 00:22:23.360
countries, those would be
the x-, y- and z axes.

00:22:26.000 --> 00:22:30.180
In device coordinates, x is
right, y is up, and z is

00:22:30.180 --> 00:22:32.690
towards you.

00:22:32.690 --> 00:22:35.120
So another reason you have to
read the Java Docs is they

00:22:35.120 --> 00:22:37.110
don't always come out
as x, y, and z.

00:22:37.110 --> 00:22:39.340
Some of them come out as z, x,
and y, and there's no way to

00:22:39.340 --> 00:22:41.190
find out that without
reading it.

00:22:41.190 --> 00:22:43.980
That corresponds to yaw, pitch,
and roll, for those of

00:22:43.980 --> 00:22:45.800
you who are aeronautical
engineers.

00:22:45.800 --> 00:22:48.860
Now, as far as I know, all of
the data coming out of the

00:22:48.860 --> 00:22:51.770
devices is in device
coordinates, not world

00:22:51.770 --> 00:22:55.460
coordinates, where y is North, x
is East, and z is coming out

00:22:55.460 --> 00:22:57.370
of the center of the Earth.

00:22:57.370 --> 00:22:59.130
And that's OK for
a lot of stuff.

00:22:59.130 --> 00:23:01.050
But if you want to do something
like a compass, you

00:23:01.050 --> 00:23:04.060
really need to transform things
into world coordinates.

00:23:04.060 --> 00:23:05.730
Now, you can do that because
we've got a magnetic field

00:23:05.730 --> 00:23:07.990
censor and a gravity
sensor and so on.

00:23:07.990 --> 00:23:13.520
But it requires some really
fairly advanced 3D rotation

00:23:13.520 --> 00:23:16.330
matrix math that I once
knew, but then I

00:23:16.330 --> 00:23:18.790
forgot 15 minutes later.

00:23:18.790 --> 00:23:20.650
Quaternions and things
like that.

00:23:20.650 --> 00:23:23.370
Fortunately, there's a lot
of helper functions.

00:23:23.370 --> 00:23:28.400
One particular thing you've got
to watch out for is that

00:23:28.400 --> 00:23:31.020
the device coordinate
system is up towards

00:23:31.020 --> 00:23:32.160
the top of the device.

00:23:32.160 --> 00:23:34.160
And when you turn it sideways
in the landscape mode, well,

00:23:34.160 --> 00:23:36.160
it now has a different
top, and all

00:23:36.160 --> 00:23:37.200
your data values change.

00:23:37.200 --> 00:23:39.150
You can actually see the readout
change as it gets past

00:23:39.150 --> 00:23:40.540
45 degrees.

00:23:40.540 --> 00:23:42.980
And enough people have been
screwed up by this that we

00:23:42.980 --> 00:23:45.980
actually wrote a whole great big
long blog post about how

00:23:45.980 --> 00:23:47.970
to avoid getting screwed up by
sensor rotation, because

00:23:47.970 --> 00:23:50.400
there's lots of ways you can try
and fix it that don't work

00:23:50.400 --> 00:23:51.880
and one that does.

00:23:51.880 --> 00:23:54.540
So you should go
and read this.

00:23:54.540 --> 00:23:56.360
There's a bunch of other
things to worry about.

00:23:56.360 --> 00:23:58.930
And probably the primary thing
is the one Ankur already

00:23:58.930 --> 00:24:01.320
mentioned because doing this
kind of programming is a

00:24:01.320 --> 00:24:04.270
really good way to burn the
battery on your device.

00:24:04.270 --> 00:24:06.940
And it's not so much that the
little, tiny, infinitesimal

00:24:06.940 --> 00:24:08.650
bit of silicon in there
is burning power.

00:24:13.350 --> 00:24:17.690
It's that it calls back into
your code 10, 20, 50 or more

00:24:17.690 --> 00:24:18.650
times a second.

00:24:18.650 --> 00:24:20.580
And this isn't a simple kind
of callback where you

00:24:20.580 --> 00:24:21.680
increment an integer.

00:24:21.680 --> 00:24:23.690
You're typically passing on
a bunch of floating point

00:24:23.690 --> 00:24:26.320
numbers and diving straight into
the trigonometry library

00:24:26.320 --> 00:24:28.420
or doing matrix inversions
and multiplications

00:24:28.420 --> 00:24:29.500
and things like this.

00:24:29.500 --> 00:24:31.610
And you're typically doing it,
not on lightweight local

00:24:31.610 --> 00:24:34.930
variables, but on class
variables that are full of

00:24:34.930 --> 00:24:36.900
shared state, because they're
getting called back.

00:24:36.900 --> 00:24:39.190
So this is not lightweight
computing, and you don't have

00:24:39.190 --> 00:24:41.770
to be a rocket scientist to
figure out that it's going to

00:24:41.770 --> 00:24:43.390
play hell with your battery.

00:24:43.390 --> 00:24:47.620
So what that means is only
sample as fast as you need to.

00:24:47.620 --> 00:24:51.600
And especially, you've got to
stop sampling when you don't

00:24:51.600 --> 00:24:52.330
need to anymore.

00:24:52.330 --> 00:24:55.000
So when your app gets an
on-pause event or you're

00:24:55.000 --> 00:24:57.100
passing something you've
recognized off the client

00:24:57.100 --> 00:24:59.920
code, you've got to turn
off the sensors.

00:24:59.920 --> 00:25:01.740
Because the system won't, and
you'll sit there in the

00:25:01.740 --> 00:25:03.180
background with the sensors
grinding and the

00:25:03.180 --> 00:25:04.790
battery going like this.

00:25:04.790 --> 00:25:06.910
So don't do this.

00:25:06.910 --> 00:25:08.970
Another thing to watch out for,
as you saw on that graph,

00:25:08.970 --> 00:25:10.370
is the sampling rate.

00:25:10.370 --> 00:25:12.470
It changes from device to
device, so you actually have

00:25:12.470 --> 00:25:15.140
to look at and use the time
stamp comes in with the sensor

00:25:15.140 --> 00:25:17.790
event, which is irritatingly
in nanoseconds, not

00:25:17.790 --> 00:25:20.360
milliseconds, and irritatingly
not synchronized with the

00:25:20.360 --> 00:25:21.030
system time.

00:25:21.030 --> 00:25:23.120
Oh well.

00:25:23.120 --> 00:25:24.510
What else do you have
to worry about?

00:25:24.510 --> 00:25:28.730
Oh, well, just the fact that
the data is messy.

00:25:28.730 --> 00:25:32.440
These are not high-grade
industrial A-to-D converters

00:25:32.440 --> 00:25:34.310
that they'll use in steel
mills and so on.

00:25:34.310 --> 00:25:37.060
These are flimsy little bits
of the silicon that are put

00:25:37.060 --> 00:25:39.690
into handsets by cost-conscious
manufactures.

00:25:39.690 --> 00:25:42.960
And the data is janky and messy
and has variation in

00:25:42.960 --> 00:25:45.950
static, and you just have
to deal with that fact.

00:25:45.950 --> 00:25:48.440
And one particular thing
to watch out for is the

00:25:48.440 --> 00:25:49.170
accelerometer.

00:25:49.170 --> 00:25:50.940
Now, the accelerometer
is a cool device.

00:25:50.940 --> 00:25:52.680
There's this video you can see
on YouTube as to how it's

00:25:52.680 --> 00:25:53.620
actually built.

00:25:53.620 --> 00:25:55.930
There actually is a little
prong of silicon with the

00:25:55.930 --> 00:25:58.120
stuff underneath it etched
away that is on

00:25:58.120 --> 00:25:59.360
a little thin stem.

00:25:59.360 --> 00:26:01.680
And it actually bends and
changes, causes variations in

00:26:01.680 --> 00:26:02.120
the current.

00:26:02.120 --> 00:26:03.640
And there's three of
these things facing

00:26:03.640 --> 00:26:04.880
in the three axes.

00:26:04.880 --> 00:26:07.480
And they measure the attractive
forces, which

00:26:07.480 --> 00:26:10.250
obviously include gravity.

00:26:10.250 --> 00:26:13.090
And that means that the only
time the accelerometer is

00:26:13.090 --> 00:26:17.720
giving you a zero readout is
when the device is falling or

00:26:17.720 --> 00:26:18.770
it's in orbit.

00:26:18.770 --> 00:26:20.880
One side effect of this is that
if you take an Android

00:26:20.880 --> 00:26:23.660
device into orbit, all the games
will immediately stop

00:26:23.660 --> 00:26:27.410
working because they count
on gravity being there.

00:26:27.410 --> 00:26:28.580
So, I said that Ankur
wrote all of the

00:26:28.580 --> 00:26:29.260
code for the Blackjack.

00:26:29.260 --> 00:26:31.010
Well, there was one piece I
wrote, which was the thing

00:26:31.010 --> 00:26:33.580
where he flipped it up and
the cards flipped over.

00:26:33.580 --> 00:26:35.990
So let's talk through that in
detail and get a feel for how

00:26:35.990 --> 00:26:37.690
this kind of stuff works.

00:26:37.690 --> 00:26:41.970
So this graph here shows what
happens when I take a Galaxy

00:26:41.970 --> 00:26:48.710
Nexus and I hold it facing me
and I chop left, back, right,

00:26:48.710 --> 00:26:51.350
and forward, simple discrete
chop motions.

00:26:51.350 --> 00:26:53.950
So what we're interested in here
is obviously the last of

00:26:53.950 --> 00:26:56.360
those four motions,
chop forward.

00:26:56.360 --> 00:26:58.260
And so the top graph shows
the actual raw

00:26:58.260 --> 00:27:00.230
accelerometer data readout.

00:27:00.230 --> 00:27:03.810
The bottom graph shows a readout
of the change in angle

00:27:03.810 --> 00:27:07.930
around the x-, y- and
z-coordinates per sample.

00:27:07.930 --> 00:27:09.580
I'll show you how you
get that in a sec.

00:27:09.580 --> 00:27:12.070
And it's easy to see by looking
at this, that the

00:27:12.070 --> 00:27:15.340
motion we're looking for is
characterized by a sustained

00:27:15.340 --> 00:27:21.530
and fairly large delta angle
around the x-coordinate in a

00:27:21.530 --> 00:27:23.570
negative direction because it's
coming up toward you as

00:27:23.570 --> 00:27:24.650
opposed to going down.

00:27:24.650 --> 00:27:26.920
So that's the condition we're
going to look for.

00:27:26.920 --> 00:27:29.260
So let's look at some
of the code here.

00:27:29.260 --> 00:27:31.820
So once again, this is the best
practice design pattern

00:27:31.820 --> 00:27:33.830
you see in sensor-reading
code.

00:27:33.830 --> 00:27:36.260
You always check the type of the
sensor that you're getting

00:27:36.260 --> 00:27:38.910
the event for, and that allows
you to pack all your different

00:27:38.910 --> 00:27:41.830
sensor handling code into one
class, too, with a K-statement

00:27:41.830 --> 00:27:42.820
wrapped around it.

00:27:42.820 --> 00:27:46.480
So in this case, I'm going to
handle the rotation vector

00:27:46.480 --> 00:27:49.600
sensor, which is a synthetic
sensor, again.

00:27:49.600 --> 00:27:51.590
And here's where we're going
to do all the math.

00:27:51.590 --> 00:27:55.060
So we get these float arrays,
which are three by three, and

00:27:55.060 --> 00:27:57.860
the central operation here
compares two of them, these

00:27:57.860 --> 00:28:00.810
two rotation matrices to compute
a change in angles.

00:28:00.810 --> 00:28:03.080
And you don't have to be a
genius to figure out that it's

00:28:03.080 --> 00:28:05.850
probably a bad idea to allocate
three-by-three

00:28:05.850 --> 00:28:09.910
floating point matrices
50 times a second.

00:28:09.910 --> 00:28:10.900
That's going to make
your garbage

00:28:10.900 --> 00:28:11.890
collector super unhappy.

00:28:11.890 --> 00:28:14.720
So that flipper class there
simply keeps two of them

00:28:14.720 --> 00:28:16.490
around and flips them back
and forth, so you

00:28:16.490 --> 00:28:18.710
have next and last.

00:28:18.710 --> 00:28:21.170
So what happens is we
get called with a

00:28:21.170 --> 00:28:22.690
vector of three arguments.

00:28:22.690 --> 00:28:25.280
And we call the library routine
there to turn them

00:28:25.280 --> 00:28:28.540
into a matrix, and then we
compare it to last matrix and

00:28:28.540 --> 00:28:31.880
that gives us the delta and
angles and radians per--

00:28:31.880 --> 00:28:33.560
I have no idea what the
units are, radians per

00:28:33.560 --> 00:28:35.870
something or other--

00:28:35.870 --> 00:28:38.780
around the z-, x-, and y-axes.

00:28:38.780 --> 00:28:40.190
And then so we'd go and
do some comparison.

00:28:40.190 --> 00:28:42.570
And because to deal with all
the static we've got some

00:28:42.570 --> 00:28:45.010
threshold values, and we
established two Booleans,

00:28:45.010 --> 00:28:48.000
minus x and plus x, depending
on whether we've decided the

00:28:48.000 --> 00:28:51.600
device is rotating forwards or
backwards around the x-axis.

00:28:51.600 --> 00:28:53.660
So then a dive into the code.

00:28:53.660 --> 00:28:56.710
So all the sensor code I've
written ends up being a sort

00:28:56.710 --> 00:28:58.010
of a twisted-state machine.

00:28:58.010 --> 00:28:59.560
I don't know, maybe some
other technique will

00:28:59.560 --> 00:29:00.770
work better for you.

00:29:00.770 --> 00:29:04.550
I say "twisted" because I
require that the device stay

00:29:04.550 --> 00:29:06.930
in a particular state for a
certain amount of time.

00:29:06.930 --> 00:29:09.850
In particular, you chop the
device, then it settles down.

00:29:09.850 --> 00:29:12.430
So there's this state called
being at rest, and I require

00:29:12.430 --> 00:29:14.420
that it stay there for a certain
number of clicks

00:29:14.420 --> 00:29:16.220
before I'll start looking
for a new state.

00:29:16.220 --> 00:29:17.750
So this is pretty easy to see.

00:29:17.750 --> 00:29:22.580
So I sum up clicks for awhile,
and then I start looking.

00:29:22.580 --> 00:29:25.440
And if it goes negative, I move
into the Going Negative

00:29:25.440 --> 00:29:27.230
state, and then it goes
positive, I move into the

00:29:27.230 --> 00:29:28.870
Going Positive state.

00:29:28.870 --> 00:29:32.110
And then, if I'm in the Going
Negative state, which is

00:29:32.110 --> 00:29:35.020
flipping up, and I require
that it stay there for a

00:29:35.020 --> 00:29:37.550
certain amount of time, and then
I detect the case that

00:29:37.550 --> 00:29:40.110
it's no longer in that state,
and I decide that we've

00:29:40.110 --> 00:29:44.050
detected a flip-up event and
dispatch to Ankur's code to

00:29:44.050 --> 00:29:45.760
turn the cards over.

00:29:45.760 --> 00:29:48.280
You'll notice that when I do
that dispatch, the first thing

00:29:48.280 --> 00:29:52.400
I do is instantly unregister all
my listeners so that the

00:29:52.400 --> 00:29:55.830
sensors are no longer running
And then I call his code.

00:29:55.830 --> 00:29:57.590
And if it returns true,
I turn them back on.

00:29:57.590 --> 00:29:58.760
Otherwise, I don't.

00:29:58.760 --> 00:30:00.590
So that's what it's like
down against the

00:30:00.590 --> 00:30:02.100
cold face of the sensors.

00:30:02.100 --> 00:30:03.840
Tony, you want to show
that tilt up there?

00:30:03.840 --> 00:30:04.600
TONY CHAN: Sure.

00:30:04.600 --> 00:30:07.970
TIM BRAY: So here's a silly
little app I wrote to see if

00:30:07.970 --> 00:30:09.465
this works.

00:30:09.465 --> 00:30:10.715
It's got to be vertical.

00:30:18.120 --> 00:30:20.295
Oh, well, maybe this isn't going
to-- oh, there is it.

00:30:20.295 --> 00:30:21.870
OK, it shows this thing
on the screen.

00:30:21.870 --> 00:30:24.750
And as Tony tilts back and
forth, it keeps it level.

00:30:24.750 --> 00:30:26.590
It keeps the red line
level as the device

00:30:26.590 --> 00:30:27.740
moves back and forth.

00:30:27.740 --> 00:30:28.740
Trust me, it looks cool.

00:30:28.740 --> 00:30:30.990
It's in the Sensplore app,
the code for it.

00:30:30.990 --> 00:30:33.410
Anyhow, so what we're trying
to do is simply calculate--

00:30:33.410 --> 00:30:35.080
let's go back to the slides,
which is one?

00:30:35.080 --> 00:30:35.330
TONY CHAN: Two.

00:30:35.330 --> 00:30:36.580
TIM BRAY: Two.

00:30:39.965 --> 00:30:40.410
Hello?

00:30:40.410 --> 00:30:41.050
Slides?

00:30:41.050 --> 00:30:43.420
Yeah, so we're going to try to
calculate that angle theta to

00:30:43.420 --> 00:30:45.220
figure out how far we slipped.

00:30:45.220 --> 00:30:47.780
And a little bit of trigonometry
suffices.

00:30:47.780 --> 00:30:50.220
But there's some other
interesting stuff in here.

00:30:50.220 --> 00:30:52.740
So first of all, you have
to be defensive.

00:30:52.740 --> 00:30:56.210
You're computing the ratio
between the value of gravity

00:30:56.210 --> 00:30:59.940
and the component of that along
the vertical axis of the

00:30:59.940 --> 00:31:03.310
phone and taking the
arc cosine of that.

00:31:03.310 --> 00:31:05.990
And if you feed a number greater
than 1 to math.acos,

00:31:05.990 --> 00:31:08.140
it gets all unhappy
and barfs at you.

00:31:08.140 --> 00:31:10.560
So you have to defend yourself
against that.

00:31:10.560 --> 00:31:13.020
The other thing you have to
watch out for is that the

00:31:13.020 --> 00:31:15.170
units coming out of the sensors
may be non-intuitive,

00:31:15.170 --> 00:31:18.770
so there's a certain amount of
adding and subtracting pi/2.

00:31:18.770 --> 00:31:23.520
And then the real problem I
fought within in this thing is

00:31:23.520 --> 00:31:26.810
as the math routines get near
the zero and come out the

00:31:26.810 --> 00:31:29.880
other side, they go nonlinear
sometimes, and you get weird

00:31:29.880 --> 00:31:30.530
variations.

00:31:30.530 --> 00:31:33.160
So you need a circular buffer
in there that saves up some

00:31:33.160 --> 00:31:34.190
small number of samples.

00:31:34.190 --> 00:31:35.480
I think I used five.

00:31:35.480 --> 00:31:38.470
And so each time you get a new
data point, you put in there.

00:31:38.470 --> 00:31:41.475
It takes out the oldest one and
returns you the average of

00:31:41.475 --> 00:31:42.370
all the ones that
are in there.

00:31:42.370 --> 00:31:45.500
So that smooths out the
curve a little bit.

00:31:45.500 --> 00:31:46.860
So this is the kind
of defensive

00:31:46.860 --> 00:31:48.640
programming you have to do.

00:31:48.640 --> 00:31:52.370
Now, one thing you'll notice is
a lot of Android games, you

00:31:52.370 --> 00:31:55.640
hold the device flat like this,
and you tilt it back and

00:31:55.640 --> 00:31:58.130
forth, and your spacecraft goes
right or left, or the

00:31:58.130 --> 00:32:00.190
ball rolls around, or
something like that.

00:32:00.190 --> 00:32:02.830
The reason game developers
love to do this, and the

00:32:02.830 --> 00:32:06.270
reason I recommend it, is you
can use the accelerometer data

00:32:06.270 --> 00:32:07.440
almost directly.

00:32:07.440 --> 00:32:09.620
If you're holding it flat like
this, if you think about it,

00:32:09.620 --> 00:32:12.270
the component of gravity
is zero, both on this

00:32:12.270 --> 00:32:13.840
axis and that axis.

00:32:13.840 --> 00:32:16.650
And as you tilt it a little bit
this way, it goes positive

00:32:16.650 --> 00:32:20.990
on this axis and negative,
positive, negative.

00:32:20.990 --> 00:32:23.440
And it turns out you can use the
values coming out of this

00:32:23.440 --> 00:32:26.390
almost directly, if you think
about the math, as force

00:32:26.390 --> 00:32:28.940
values, which gives you
acceleration values.

00:32:28.940 --> 00:32:30.930
And if you remember Newton's
laws of motion, you can

00:32:30.930 --> 00:32:34.500
integrate and compute where the
spacecraft is, or where

00:32:34.500 --> 00:32:36.260
the little ball rolled
to, or so on.

00:32:36.260 --> 00:32:38.140
There's a nice mathematical
technique called Verlet

00:32:38.140 --> 00:32:39.490
integration.

00:32:39.490 --> 00:32:42.830
And there's this terrific sample
in the samples with the

00:32:42.830 --> 00:32:45.920
SDK that uses Verlet integration
to track a bunch

00:32:45.920 --> 00:32:51.630
of little silver balls rolling
around on a surface with an

00:32:51.630 --> 00:32:53.970
astoundingly small
amount of code.

00:32:53.970 --> 00:32:57.370
Very elegant, very, very good.

00:32:57.370 --> 00:32:59.240
OK, so I advise you to get it.

00:32:59.240 --> 00:33:01.740
Now, if you're like me, you saw
what these sensors could

00:33:01.740 --> 00:33:04.700
do, and you immediately thought,
wow, I can track

00:33:04.700 --> 00:33:05.720
motion in space.

00:33:05.720 --> 00:33:11.310
I'm going to build
a light saber and

00:33:11.310 --> 00:33:13.360
track balletic motions.

00:33:13.360 --> 00:33:16.230
And, well, no, you
can't, sorry.

00:33:16.230 --> 00:33:17.660
Well, anyhow, I couldn't.

00:33:17.660 --> 00:33:19.840
And I tried really hard
for a couple of weeks.

00:33:19.840 --> 00:33:23.420
It turns out that this is not
like a Nintendo Wii, which has

00:33:23.420 --> 00:33:26.650
multiple high-quality industrial
gyroscopes in it.

00:33:26.650 --> 00:33:29.640
Phones have these much smaller,
much less precise

00:33:29.640 --> 00:33:33.030
objects, and the data coming out
is nowhere near accurate

00:33:33.030 --> 00:33:35.100
enough to track your
position in space.

00:33:35.100 --> 00:33:38.580
And I would point out that the
Microsoft Kinect actually uses

00:33:38.580 --> 00:33:41.230
a camera sitting in there to
track where the thing is

00:33:41.230 --> 00:33:44.280
moving and gets really, really
accurate data like that.

00:33:44.280 --> 00:33:46.610
Now, there are some
things you can do.

00:33:46.610 --> 00:33:50.200
You can very easily compute the
total acceleration of the

00:33:50.200 --> 00:33:52.660
device, which is very,
very useful in

00:33:52.660 --> 00:33:54.130
tracking things like shakes.

00:33:54.130 --> 00:33:56.730
And you can get general events,
such as they jerked it

00:33:56.730 --> 00:33:58.520
left, they jerked it right, they
jerked it up, they jerked

00:33:58.520 --> 00:34:00.390
it down, this kind of thing.

00:34:00.390 --> 00:34:04.040
I found that, generally
speaking, rotational events of

00:34:04.040 --> 00:34:07.480
one sort or another were
easier to capture.

00:34:07.480 --> 00:34:09.819
But it's tough stuff.

00:34:09.819 --> 00:34:12.239
The last thing I'm going
to talk about is

00:34:12.239 --> 00:34:13.239
how to build a compass.

00:34:13.239 --> 00:34:15.090
There are several examples
of compasses out

00:34:15.090 --> 00:34:16.520
there on the net.

00:34:16.520 --> 00:34:19.739
This is actually Ankur's
code here.

00:34:19.739 --> 00:34:22.630
The complicated thing is moving
from device coordinates

00:34:22.630 --> 00:34:23.949
to world coordinates.

00:34:23.949 --> 00:34:26.040
And to do this, first of all,
you have to get both the

00:34:26.040 --> 00:34:29.230
accelerometer and the magnetic
field data, and then you have

00:34:29.230 --> 00:34:34.929
to do some very, very scary
real math to change the

00:34:34.929 --> 00:34:36.510
coordinates.

00:34:36.510 --> 00:34:39.739
And, well, here's an example
of that math in action.

00:34:39.739 --> 00:34:42.219
And it's actually not that hard
to construct something

00:34:42.219 --> 00:34:45.199
that keeps the needle pointing
magnetic north, anyhow.

00:34:45.199 --> 00:34:48.150
If you want true North, you'd
have to do GPS math and all

00:34:48.150 --> 00:34:49.400
sorts of stuff.

00:34:55.690 --> 00:34:56.510
Let me backtrack.

00:34:56.510 --> 00:34:59.090
Probably the best example of
sensor programming I've ever

00:34:59.090 --> 00:35:01.160
seen on an Android is something
that just came out

00:35:01.160 --> 00:35:02.240
now with Jelly Bean.

00:35:02.240 --> 00:35:05.760
And this is what's called the
Compass View in the Maps app,

00:35:05.760 --> 00:35:07.940
so you get the Maps app,
particularly on a device like

00:35:07.940 --> 00:35:09.390
the Nexus 7 here.

00:35:09.390 --> 00:35:12.740
And you go to a location, and
you go into Street View, then

00:35:12.740 --> 00:35:16.250
hit the Menu and select
Compass mode.

00:35:16.250 --> 00:35:17.950
And it is remarkable.

00:35:17.950 --> 00:35:20.410
You hold it like this, and it
captures the most subtle,

00:35:20.410 --> 00:35:23.200
slightest variations in the way
you hold the device and

00:35:23.200 --> 00:35:25.270
moves-- pans around the view
you're looking at.

00:35:25.270 --> 00:35:26.950
It is totally magical.

00:35:26.950 --> 00:35:29.880
Now, that is accomplished using
techniques that are

00:35:29.880 --> 00:35:34.190
probably a bit more advanced
than the ones I

00:35:34.190 --> 00:35:35.960
talked about here.

00:35:35.960 --> 00:35:39.060
They involve taking the actual
rotation matrices and using

00:35:39.060 --> 00:35:42.580
quaternions and probably taking
them and blasting them

00:35:42.580 --> 00:35:44.680
straight into the OpenGL
code that is

00:35:44.680 --> 00:35:46.920
actually driving the maps.

00:35:46.920 --> 00:35:49.960
The bad news is that you really
have to be a competent

00:35:49.960 --> 00:35:51.930
mathematician who really
understands this stuff in

00:35:51.930 --> 00:35:53.190
order to use that stuff.

00:35:53.190 --> 00:35:55.030
But if you really want to
achieve that kind of

00:35:55.030 --> 00:35:57.250
semi-magical effect, you're
going to have to do it.

00:35:57.250 --> 00:35:59.825
The good news, however, is that
the library routines have

00:35:59.825 --> 00:36:03.230
been set up carefully so that
the rotation matrices that

00:36:03.230 --> 00:36:05.460
come out are either
nine-by-nine, or

00:36:05.460 --> 00:36:07.240
three-by-three, or
four-by-four.

00:36:07.240 --> 00:36:09.060
And they are set up in such a
way that they can be pumped

00:36:09.060 --> 00:36:12.110
directly into the OpenGL
routines that want rotation

00:36:12.110 --> 00:36:14.200
matrices, and they're all
just right, just the

00:36:14.200 --> 00:36:15.140
way you want them.

00:36:15.140 --> 00:36:18.800
And so it's not that hard to
write, assuming you know what

00:36:18.800 --> 00:36:19.920
you're doing.

00:36:19.920 --> 00:36:22.520
OK, I think that's all
I'm going to--

00:36:22.520 --> 00:36:24.470
you all know what you're
doing, right?

00:36:24.470 --> 00:36:26.740
That's all going to say about
motion and kinetics.

00:36:26.740 --> 00:36:30.080
You know, as Ankur showed, your
device can feel and see

00:36:30.080 --> 00:36:31.480
what's going on around it.

00:36:31.480 --> 00:36:35.400
And as I've been showing
you, it can feel what

00:36:35.400 --> 00:36:36.520
you do to it as well.

00:36:36.520 --> 00:36:38.470
Now, it can do one more thing,
which is listen.

00:36:38.470 --> 00:36:41.100
So, Tony, take it away, give
us audio processing.

00:36:41.100 --> 00:36:42.770
TONY CHAN: Thank you, Tim.

00:36:42.770 --> 00:36:45.870
So besides being able to
detect your motion with

00:36:45.870 --> 00:36:49.950
Android, Android can also listen
to you through the

00:36:49.950 --> 00:36:52.190
microphone.

00:36:52.190 --> 00:36:57.100
But if I ask you, as a developer
usually how you use

00:36:57.100 --> 00:37:00.850
the microphone, you probably
will say use it for voice

00:37:00.850 --> 00:37:04.050
recording or music
recording, right?

00:37:04.050 --> 00:37:08.130
But what if I tell you you can
use the microphone to make it

00:37:08.130 --> 00:37:10.230
as a baby monitor?

00:37:10.230 --> 00:37:13.900
Or a musical instrument tuner?

00:37:13.900 --> 00:37:18.430
Or even use it to detect some
inaudible frequency that only

00:37:18.430 --> 00:37:20.740
your application
can understand.

00:37:20.740 --> 00:37:25.090
So a good use case of that is
maybe in global positioning.

00:37:25.090 --> 00:37:27.180
So there are a lot of
interesting ways you can use

00:37:27.180 --> 00:37:29.750
the microphone.

00:37:29.750 --> 00:37:35.290
And today, I want to show you
another interesting way of

00:37:35.290 --> 00:37:40.500
using the microphone as
a heartbeat monitor.

00:37:40.500 --> 00:37:45.270
So here, let me walk you
through what I built.

00:37:45.270 --> 00:37:49.020
So here I have a regular
stethoscope that is used by

00:37:49.020 --> 00:37:51.620
any doctor around the world.

00:37:51.620 --> 00:37:57.270
And I connect one side of the
earpiece of the stethoscope to

00:37:57.270 --> 00:38:02.440
an external microphone, which
is connected by a very

00:38:02.440 --> 00:38:06.380
sophisticated piece
of connector--

00:38:06.380 --> 00:38:07.290
actually, I'm kidding.

00:38:07.290 --> 00:38:08.730
This is a pencil grip.

00:38:08.730 --> 00:38:10.880
I got it online.

00:38:10.880 --> 00:38:14.530
But it would fit perfectly
the two ends.

00:38:14.530 --> 00:38:19.630
So the other end of that the
microphone is connected to the

00:38:19.630 --> 00:38:21.340
headphone jack of the
Android device.

00:38:23.940 --> 00:38:25.190
So let me--

00:38:36.310 --> 00:38:39.740
So I cannot talk while taking
the measurements, so I'll ask

00:38:39.740 --> 00:38:41.085
Ankur to help me to take
the measurement.

00:38:43.980 --> 00:38:46.530
So I want to walk you
through what the

00:38:46.530 --> 00:38:48.290
application is working--

00:38:48.290 --> 00:38:49.994
ANKUR KOTWAL: It's
dangerously high.

00:38:49.994 --> 00:38:51.922
[LAUGHTER]

00:38:51.922 --> 00:38:57.720
[APPLAUSE]

00:38:57.720 --> 00:38:58.240
TONY CHAN: Wow.

00:38:58.240 --> 00:39:01.570
It picked up your clapping,
so let it settle

00:39:01.570 --> 00:39:04.600
down a little bit.

00:39:04.600 --> 00:39:08.050
So this is how the heartbeat
monitor is working.

00:39:08.050 --> 00:39:11.560
So first, it takes the heartbeat
sound signal from

00:39:11.560 --> 00:39:13.830
the stethoscope.

00:39:13.830 --> 00:39:15.580
This is still analog,
by the way.

00:39:15.580 --> 00:39:20.220
And then the signal goes to the
microphone, and then we do

00:39:20.220 --> 00:39:22.550
some sampling.

00:39:22.550 --> 00:39:26.660
And after that, I pass it
through a low-pass filter.

00:39:26.660 --> 00:39:31.050
And then before displaying the
signal on the screen, I do a

00:39:31.050 --> 00:39:31.810
down-sampling.

00:39:31.810 --> 00:39:35.320
So we will talk a little bit
about all these steps in the

00:39:35.320 --> 00:39:37.990
future slides.

00:39:37.990 --> 00:39:38.590
So I guess--

00:39:38.590 --> 00:39:39.766
TIM BRAY: I'll go back.

00:39:39.766 --> 00:39:40.625
Back to the slides?

00:39:40.625 --> 00:39:41.560
TONY CHAN: You're still
pretty excited

00:39:41.560 --> 00:39:42.850
actually, Ankur, today.

00:39:42.850 --> 00:39:44.600
ANKUR KOTWAL: I get to share a
stage with you guys, so I'm

00:39:44.600 --> 00:39:45.790
pretty excited, right?

00:39:45.790 --> 00:39:48.270
TONY CHAN: Yep.

00:39:48.270 --> 00:39:54.140
So let's talk about how you can
access the microphone in

00:39:54.140 --> 00:39:55.610
the Android framework.

00:39:55.610 --> 00:39:59.730
So if you are just talking about
recording some sound or

00:39:59.730 --> 00:40:05.520
music and code it in some
common format, the

00:40:05.520 --> 00:40:08.450
MediaRecorder class is what
you're looking for.

00:40:08.450 --> 00:40:11.180
However, if you need to do
some advanced signal

00:40:11.180 --> 00:40:14.900
processing stuff, you need
to access the raw data.

00:40:14.900 --> 00:40:18.190
You need to use the
AudioRecord class.

00:40:18.190 --> 00:40:20.450
And by the way, the MediaRecord
class is available

00:40:20.450 --> 00:40:23.380
since day one of Android, and
the AudioRecord classes is

00:40:23.380 --> 00:40:25.020
available since 1.5.

00:40:28.710 --> 00:40:33.980
So before we get to the more
technical part of the session,

00:40:33.980 --> 00:40:36.620
let's start with some
fundamentals so that we are

00:40:36.620 --> 00:40:38.400
the same page.

00:40:38.400 --> 00:40:45.580
The human hearing range is
between 20 Hz and 20 kHz.

00:40:45.580 --> 00:40:49.000
And this range will shrink
when we get older.

00:40:49.000 --> 00:40:53.360
Well, I guess actually that's
a pretty nice thing, because

00:40:53.360 --> 00:40:58.000
suddenly all our mp3 songs
will sound like CD song

00:40:58.000 --> 00:41:01.230
quality when we get older,
because we cannot tell the

00:41:01.230 --> 00:41:04.140
difference anymore.

00:41:04.140 --> 00:41:06.400
When we talk about sound
wave, there are two

00:41:06.400 --> 00:41:08.270
things we talk about--

00:41:08.270 --> 00:41:10.420
The pitch and the loudness.

00:41:10.420 --> 00:41:13.820
So pitch is really the frequency
of the sound, and

00:41:13.820 --> 00:41:16.750
loudness is the amplitude,
as illustrated

00:41:16.750 --> 00:41:18.000
in the diagram here.

00:41:20.480 --> 00:41:24.590
One interesting property thing
about sound waves is it

00:41:24.590 --> 00:41:27.600
respects something called
superposition principle.

00:41:27.600 --> 00:41:33.330
And this allows us to analyze
a very complex signal in its

00:41:33.330 --> 00:41:37.460
simpler, fundamental sinusoidal
components.

00:41:37.460 --> 00:41:41.450
And this is what enabled us to
do what we call the SWIFT,

00:41:41.450 --> 00:41:44.450
Fourier transform, which is the
low-pass filtering stuff.

00:41:47.340 --> 00:41:52.090
So now, let's--

00:41:52.090 --> 00:41:55.500
sorry, I'll skip a slide,
but that's the idea.

00:41:55.500 --> 00:41:58.860
The next thing I want to talk
about is sampling So Tim

00:41:58.860 --> 00:42:03.210
actually mentioned about
sampling before, but this is

00:42:03.210 --> 00:42:07.180
really important, and I think
a lot of developers didn't

00:42:07.180 --> 00:42:11.100
quite get how to choose the
right sampling rate.

00:42:11.100 --> 00:42:15.600
So I want to point out one thing
about sampling rate.

00:42:15.600 --> 00:42:21.660
The sampling rate, 44.1 kHz,
is the only sampling range

00:42:21.660 --> 00:42:23.890
that is guaranteed
to support in all

00:42:23.890 --> 00:42:26.580
Android-compatible devices.

00:42:26.580 --> 00:42:29.320
However, does that mean that
this is the frequency you

00:42:29.320 --> 00:42:32.010
should use as a default

00:42:32.010 --> 00:42:34.550
frequency when you do sampling?

00:42:34.550 --> 00:42:35.760
Well, guess what?

00:42:35.760 --> 00:42:37.370
The answer is no.

00:42:37.370 --> 00:42:41.900
And the reason is you should
always understand very well

00:42:41.900 --> 00:42:44.640
about your signal before you
choose the right frequency.

00:42:48.280 --> 00:42:50.820
So you may ask the question,
now, how can I choose the

00:42:50.820 --> 00:42:52.290
right frequency?

00:42:52.290 --> 00:42:54.520
It turns out the good
news is there is

00:42:54.520 --> 00:42:56.310
really a rule of thumb.

00:42:56.310 --> 00:43:00.520
You always want to pick a
sampling rate that is more

00:43:00.520 --> 00:43:03.940
than two times the
highest frequency

00:43:03.940 --> 00:43:06.700
component of your signal.

00:43:06.700 --> 00:43:12.010
And if you ask why, well,
trust me on that one.

00:43:12.010 --> 00:43:14.690
Actually, there are some smart
people already proved that in

00:43:14.690 --> 00:43:16.440
mathematics.

00:43:16.440 --> 00:43:20.520
So if this condition is not
satisfied, something called

00:43:20.520 --> 00:43:21.820
aliasing will occur.

00:43:21.820 --> 00:43:25.790
And I want to show you visually
what that means.

00:43:25.790 --> 00:43:31.330
So here, I have a signal
of 0.9-Hertz frequency.

00:43:31.330 --> 00:43:37.510
And I'm going to sample this
signal at 1 Hertz.

00:43:37.510 --> 00:43:42.470
So you can see there are a lot
of blue dots on the screen,

00:43:42.470 --> 00:43:44.690
which is the sample data.

00:43:44.690 --> 00:43:49.650
So it looks OK, until now I
introduce another signal of

00:43:49.650 --> 00:43:53.430
0.1 Hertz, which I call
the alias signal.

00:43:53.430 --> 00:43:58.240
So as you can see from the
graph, this alias signal fits

00:43:58.240 --> 00:44:01.950
perfectly on all the sample
data you have.

00:44:01.950 --> 00:44:03.610
And this is the problem.

00:44:03.610 --> 00:44:09.030
Because there's no way you can
reconstruct an original signal

00:44:09.030 --> 00:44:14.080
reliably if you sample
your data at 1 Hertz.

00:44:14.080 --> 00:44:16.830
So now, how to solve
this problem?

00:44:16.830 --> 00:44:20.690
So let's say I am now, instead
of 1 Hertz, I'm going to

00:44:20.690 --> 00:44:25.690
sample this data at 2 Hertz,
which is more than two times

00:44:25.690 --> 00:44:27.240
the original signal frequency.

00:44:29.970 --> 00:44:33.130
So now, there are more
data points that

00:44:33.130 --> 00:44:33.970
we're capturing now.

00:44:33.970 --> 00:44:40.970
So we take a sample every half
a second, and so you can see

00:44:40.970 --> 00:44:47.260
the alias signal no longer fits
the new sample data, and

00:44:47.260 --> 00:44:48.810
this is how we solve
the problem.

00:44:51.720 --> 00:44:56.490
So another topic I wanted to
talk about is how to choose

00:44:56.490 --> 00:44:58.220
the right buffer size.

00:44:58.220 --> 00:45:03.300
So it turns out there's no
one-size-fits-all solution to

00:45:03.300 --> 00:45:06.910
that, because it's really a
trade-off among a couple of

00:45:06.910 --> 00:45:10.820
things, like responsiveness
and memory, CPU

00:45:10.820 --> 00:45:11.940
cycle, things like that.

00:45:11.940 --> 00:45:16.190
So if you choose a small buffer,
so you can update your

00:45:16.190 --> 00:45:18.020
UI more frequently.

00:45:18.020 --> 00:45:20.730
So that's a nice thing.

00:45:20.730 --> 00:45:25.840
But if you choose a large
buffer, you probably put more

00:45:25.840 --> 00:45:30.620
stress to your system, use more
memory and CPU cycle for

00:45:30.620 --> 00:45:33.040
each round of operation.

00:45:33.040 --> 00:45:38.660
However, there is really a
plus on picking a larger

00:45:38.660 --> 00:45:41.620
buffer, which is your
application will be more

00:45:41.620 --> 00:45:46.820
tolerant to failure by network
congestions or resource

00:45:46.820 --> 00:45:48.280
competition with other
applications

00:45:48.280 --> 00:45:49.530
in the Android system.

00:45:51.840 --> 00:45:54.840
There are also a couple of
pitfalls I want to point out.

00:45:54.840 --> 00:46:00.520
So the first one is always make
sure you call the Gadmin

00:46:00.520 --> 00:46:04.310
buffer side method to initialize
your AudioRecord

00:46:04.310 --> 00:46:09.270
class, because this is the
minimum buffer requirement to

00:46:09.270 --> 00:46:12.820
properly instantiate the
AudioRecord object.

00:46:12.820 --> 00:46:16.650
Another thing is this is also
the size of a buffer that will

00:46:16.650 --> 00:46:20.700
guarantee you not dropping
sample data.

00:46:20.700 --> 00:46:26.790
Another thing is when you pick
the encoding bit def, make

00:46:26.790 --> 00:46:30.080
sure you use the right method.

00:46:30.080 --> 00:46:34.830
So if you are using the
8-bit encoding, use

00:46:34.830 --> 00:46:36.740
the read(byte) method.

00:46:36.740 --> 00:46:39.790
And if you're using the 16-bit
one, make sure you use the

00:46:39.790 --> 00:46:40.880
read(short) method.

00:46:40.880 --> 00:46:45.520
Trust me, that will save you
from a lot of trouble.

00:46:45.520 --> 00:46:49.670
So now let's get to
signal processing.

00:46:49.670 --> 00:46:53.460
So when do you usually
do signal processing?

00:46:53.460 --> 00:46:55.120
So there are a couple
of things.

00:46:55.120 --> 00:46:59.660
So the first one is if you want
to filter some noises.

00:46:59.660 --> 00:47:04.290
And I would like to show you a
quick demo, like what we can

00:47:04.290 --> 00:47:08.150
achieve by adding a filter
to a signal.

00:47:13.930 --> 00:47:18.160
So let's turn the filter
off right now.

00:47:18.160 --> 00:47:22.890
So you can see a very strong
signal right here.

00:47:22.890 --> 00:47:32.470
And if I turn on the filter, you
can see immediately, the

00:47:32.470 --> 00:47:34.120
signal goes away, besides
my voice.

00:47:39.230 --> 00:47:43.310
So that quickly illustrates how
a low-pass filter works.

00:47:47.090 --> 00:47:50.270
Another use case for doing
signal processing is if you

00:47:50.270 --> 00:47:54.840
want to do some spectral
analysis on your signal.

00:47:54.840 --> 00:48:00.340
But one thing about doing this
kind of signal processing is

00:48:00.340 --> 00:48:03.520
it's really, really hard to
do it in the time domain.

00:48:03.520 --> 00:48:11.410
So I have to diagram here that
the same signal, but in

00:48:11.410 --> 00:48:14.260
different formats, one in time
domain and one in the

00:48:14.260 --> 00:48:15.910
frequency domain.

00:48:15.910 --> 00:48:20.570
So, as you can see, in the
time domain, there isn't

00:48:20.570 --> 00:48:24.370
really much things
you can do to

00:48:24.370 --> 00:48:26.080
de-componentize your single.

00:48:26.080 --> 00:48:29.280
But on the other hand, in the
frequency domain, you can find

00:48:29.280 --> 00:48:32.320
it very easy to see individual
components that

00:48:32.320 --> 00:48:35.620
represent your signal.

00:48:35.620 --> 00:48:38.570
So that's why a lot of people
are doing all this low-pass

00:48:38.570 --> 00:48:42.730
filtering in the frequency
domain.

00:48:42.730 --> 00:48:46.630
Now, the question is, how can
you transform your signal from

00:48:46.630 --> 00:48:49.880
the time domain to the
frequency domain?

00:48:49.880 --> 00:48:51.470
And I have another good
news for you.

00:48:51.470 --> 00:48:54.012
So someone already
figured this out.

00:48:54.012 --> 00:48:57.360
So it's what we call the
Discrete Fourier Transform.

00:48:57.360 --> 00:49:00.300
And this is math.

00:49:00.300 --> 00:49:05.190
So when we talk about
DFT, it's really a

00:49:05.190 --> 00:49:07.540
computing-intensive operation.

00:49:07.540 --> 00:49:11.420
So the complexity of DFT
is really N squared.

00:49:11.420 --> 00:49:16.280
However, in practice, thanks to
some computer scientists,

00:49:16.280 --> 00:49:19.400
we already figured out another
more efficient algorithm to

00:49:19.400 --> 00:49:23.090
achieve the same result, which
is, Fast Fourier Transform,

00:49:23.090 --> 00:49:27.720
FFT And the complexity
of that is N log N.

00:49:27.720 --> 00:49:32.560
But even that, when you
implement FFT, you can choose

00:49:32.560 --> 00:49:35.130
to use some library.

00:49:35.130 --> 00:49:38.490
But it's not really
a lot of code.

00:49:38.490 --> 00:49:41.320
But if you really implement
FFT, there are a couple of

00:49:41.320 --> 00:49:43.990
things you want to
look out for.

00:49:43.990 --> 00:49:47.290
The first thing is, of course,
garbage collection.

00:49:47.290 --> 00:49:52.560
So, I saw some implementation of
FFT using a Java object to

00:49:52.560 --> 00:49:55.470
represent a complex
data value.

00:49:55.470 --> 00:49:58.190
That's really expensive, because
if you are talking

00:49:58.190 --> 00:50:02.540
about sampling data at 44.1
kilohertz, you are talking

00:50:02.540 --> 00:50:06.920
about creating 40,000 objects
for every single second, which

00:50:06.920 --> 00:50:09.440
is totally inefficient.

00:50:09.440 --> 00:50:14.060
So in my demo, instead of
using a Java object to

00:50:14.060 --> 00:50:17.820
represent a complex data value,
I'm using two arrays of

00:50:17.820 --> 00:50:23.560
double primitive to store the
complex data value, so one for

00:50:23.560 --> 00:50:27.140
the real part of the number
and another part for the

00:50:27.140 --> 00:50:29.200
imaginary one.

00:50:29.200 --> 00:50:33.550
Another thing, when you write
your methods, consider doing

00:50:33.550 --> 00:50:36.780
something called in-place
algorithm, if possible.

00:50:36.780 --> 00:50:42.390
If your algorithm can do that,
do it, because you can save a

00:50:42.390 --> 00:50:43.190
lot of memory.

00:50:43.190 --> 00:50:49.870
So basically, what that does is
we use the input array to

00:50:49.870 --> 00:50:53.560
store the output of
your results.

00:50:53.560 --> 00:50:59.620
And finally, if your computation
is really complex,

00:50:59.620 --> 00:51:01.415
you can always consider
using the NDK.

00:51:04.300 --> 00:51:10.770
So now, it's relatively
easy to get

00:51:10.770 --> 00:51:12.990
sensor data from Android.

00:51:12.990 --> 00:51:16.370
However, it is quite challenging
to really make

00:51:16.370 --> 00:51:21.660
sense of the data, as teammate
Ankur pointed out earlier.

00:51:21.660 --> 00:51:26.110
So I would like to share some
tips with you on how to really

00:51:26.110 --> 00:51:29.280
understand or interpret data.

00:51:29.280 --> 00:51:33.330
So the first one is
using thresholds.

00:51:33.330 --> 00:51:38.980
In Tim and Ankur's code snippet
earlier, we're using a

00:51:38.980 --> 00:51:42.240
lot of places using thresholding
to extract useful

00:51:42.240 --> 00:51:45.930
information from the
sensor data.

00:51:45.930 --> 00:51:49.280
And in my heartbeat
demo, I also used

00:51:49.280 --> 00:51:51.070
that in a couple places.

00:51:51.070 --> 00:51:54.720
The first one is I used that
to detect peaks, heartbeat

00:51:54.720 --> 00:51:59.990
peaks, in order to calculate
the heartbeat rate.

00:51:59.990 --> 00:52:03.860
Another place I used that is I
used that to filter out some

00:52:03.860 --> 00:52:06.640
peaks that are too close
to each other.

00:52:06.640 --> 00:52:11.370
And the third place I used this
is because I don't want

00:52:11.370 --> 00:52:14.210
the heartbeat rate to fluctuate
too quickly.

00:52:14.210 --> 00:52:19.410
So I used some threshold
criteria to determine--

00:52:19.410 --> 00:52:23.140
only if the heartbeat rate
repeat like x number of times,

00:52:23.140 --> 00:52:26.300
then I update the UI.

00:52:26.300 --> 00:52:31.200
So threshold is really
useful when you're

00:52:31.200 --> 00:52:33.620
handling sensor data.

00:52:33.620 --> 00:52:36.040
Another thing is time.

00:52:36.040 --> 00:52:39.870
In my heartbeat demo, I'm using
time combining with the

00:52:39.870 --> 00:52:44.730
sensor data to calculate
the heartbeat rate.

00:52:44.730 --> 00:52:49.360
Finally, statistics are your
friend when you handle sensor

00:52:49.360 --> 00:52:54.400
data because sensor data are
inherently noisy, messy, as

00:52:54.400 --> 00:52:56.210
Tim mentioned.

00:52:56.210 --> 00:52:59.395
It's always good to use some
basic statistics to interpret

00:52:59.395 --> 00:53:01.440
and understand your data.

00:53:01.440 --> 00:53:05.670
And in my heartbeat demo, I used
something called weighted

00:53:05.670 --> 00:53:11.400
moving average to control how
sensitive the heartbeat

00:53:11.400 --> 00:53:12.910
detection algorithm.

00:53:12.910 --> 00:53:16.810
So it turns out it works
pretty well.

00:53:16.810 --> 00:53:20.925
So after you get all the data,
you want to display them to

00:53:20.925 --> 00:53:22.800
your user, right?

00:53:22.800 --> 00:53:28.620
So the Android framework comes
with a visualizer in the

00:53:28.620 --> 00:53:30.660
AudioEffects package.

00:53:30.660 --> 00:53:32.890
However, there are
a couple caveats.

00:53:32.890 --> 00:53:37.770
So the first thing is, in order
to use this visualizer,

00:53:37.770 --> 00:53:44.060
the visualizer only applies to a
current playing audio track.

00:53:44.060 --> 00:53:46.960
In other words, in my example,
since I'm not playing the

00:53:46.960 --> 00:53:51.670
heartbeat sound, so I cannot use
the visualizer that comes

00:53:51.670 --> 00:53:55.090
with the Android framework, so
I have to build my own custom

00:53:55.090 --> 00:53:56.800
visualizer.

00:53:56.800 --> 00:54:00.750
But when you have to build a
custom visualizer, there are a

00:54:00.750 --> 00:54:02.760
couple of things you
need to remember.

00:54:02.760 --> 00:54:07.970
First of all, you have to
down-sample your data, because

00:54:07.970 --> 00:54:10.280
on any phone screen,
you probably only

00:54:10.280 --> 00:54:12.570
1,280 pixels, right?

00:54:12.570 --> 00:54:14.460
But you definitely have
a lot more data

00:54:14.460 --> 00:54:16.480
points when you do sampling.

00:54:16.480 --> 00:54:18.810
So make sure you have to
down-sample your data.

00:54:18.810 --> 00:54:22.910
And probably it's a good idea
to pass your data through a

00:54:22.910 --> 00:54:27.490
low-pass filter before doing
the down-sample.

00:54:27.490 --> 00:54:33.120
If you want to achieve that
horizontal scrolling effect on

00:54:33.120 --> 00:54:38.210
the UI I have, you also want
to use a circular buffer to

00:54:38.210 --> 00:54:41.610
keep track of your data.

00:54:41.610 --> 00:54:45.830
So that's pretty much what I
want to talk about audio.

00:54:45.830 --> 00:54:49.730
And I hope you guys find it
useful, and I really look

00:54:49.730 --> 00:54:52.970
forward to see some more
exciting ways of using the

00:54:52.970 --> 00:54:56.880
microphone in your applications
in Google Play.

00:54:56.880 --> 00:55:00.185
So I'll pass this stage
back to Tim.

00:55:00.185 --> 00:55:00.670
TIM BRAY: All right.

00:55:00.670 --> 00:55:06.500
[APPLAUSE]

00:55:06.500 --> 00:55:07.270
TIM BRAY: Thank you, Tony.

00:55:07.270 --> 00:55:09.240
So check that link there.

00:55:09.240 --> 00:55:12.460
That's where our organization,
the Developer Relations

00:55:12.460 --> 00:55:14.490
Organization, puts our
training materials.

00:55:14.490 --> 00:55:16.420
As of yet, there's not
actually a course on

00:55:16.420 --> 00:55:17.940
sensors there yet.

00:55:17.940 --> 00:55:20.740
But there will be real soon now
as a consequence of having

00:55:20.740 --> 00:55:21.870
done this session.

00:55:21.870 --> 00:55:25.260
And it's a super valuable
resource for anybody who's

00:55:25.260 --> 00:55:27.660
trying to be an Android
developer.

00:55:27.660 --> 00:55:30.370
So a housekeeping note
and a takeaway.

00:55:30.370 --> 00:55:32.260
Housekeeping note is we're kind
of low on time already,

00:55:32.260 --> 00:55:34.320
so I don't think we're going to
really be able to do much

00:55:34.320 --> 00:55:35.890
in the way of questions here.

00:55:35.890 --> 00:55:38.320
We're all going to go from
here straight up to the

00:55:38.320 --> 00:55:41.460
Android Office Hours
on the third floor.

00:55:41.460 --> 00:55:43.660
And you want to talk about
sensors or anything else, come

00:55:43.660 --> 00:55:46.730
on up and find us there, and
we can relax and talk.

00:55:46.730 --> 00:55:51.110
Final point I want to make is
it's hard to stand out.

00:55:51.110 --> 00:55:54.140
There's a lot of apps up
there in Google Play.

00:55:54.140 --> 00:55:56.340
Not many people are doing
the sensor stuff.

00:55:56.340 --> 00:56:00.280
This could be the hook that
makes your app stand out from

00:56:00.280 --> 00:56:02.510
the big, big, big crowd.

00:56:02.510 --> 00:56:03.760
Thank you.

