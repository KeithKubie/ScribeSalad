WEBVTT
Kind: captions
Language: en

00:00:06.300 --> 00:00:07.820
SETH LADD: OK, we are live.

00:00:07.820 --> 00:00:11.080
Here we are, special episode
of "Dartisans," with Dart

00:00:11.080 --> 00:00:12.530
engineer Nicolas Geoffray.

00:00:12.530 --> 00:00:13.930
Hello, Nicolas.

00:00:13.930 --> 00:00:15.080
NICOLAS GEOFFRAY: Hello.

00:00:15.080 --> 00:00:16.850
SETH LADD: Now where
are you today?

00:00:16.850 --> 00:00:19.390
NICOLAS GEOFFRAY: I'm hanging
out in Zurich.

00:00:19.390 --> 00:00:20.040
SETH LADD: This is awesome.

00:00:20.040 --> 00:00:21.840
So you look like you're
in a little car.

00:00:21.840 --> 00:00:24.590
Where are you?

00:00:24.590 --> 00:00:27.990
NICOLAS GEOFFRAY: I could make
you a little tour, actually.

00:00:27.990 --> 00:00:29.440
I don't know how it's
called in English,

00:00:29.440 --> 00:00:30.950
but it's like a skillet.

00:00:30.950 --> 00:00:32.380
SETH LADD: I think it's
a little gondola.

00:00:32.380 --> 00:00:35.020
NICOLAS GEOFFRAY: Gondola.

00:00:35.020 --> 00:00:36.070
SETH LADD: I love the
Zurich office.

00:00:36.070 --> 00:00:39.190
It's a very, very cool office.

00:00:39.190 --> 00:00:41.330
NICOLAS GEOFFRAY: Yeah, it's
nice to hang out here.

00:00:41.330 --> 00:00:43.000
SETH LADD: Well thank you
for taking the time.

00:00:43.000 --> 00:00:45.670
So some really interesting
developments over the past

00:00:45.670 --> 00:00:47.390
couple weeks.

00:00:47.390 --> 00:00:50.400
So we should start off with
where do you normally work,

00:00:50.400 --> 00:00:53.330
and what project
do you work on?

00:00:53.330 --> 00:00:57.490
NICOLAS GEOFFRAY: I normally
work in Aarhus, Denmark.

00:00:57.490 --> 00:00:59.990
That's where lots of Dart
stuff is happening.

00:00:59.990 --> 00:01:02.250
And I'm working on dart2js.

00:01:02.250 --> 00:01:06.750
That's the compiler that
compiles Dart programs to

00:01:06.750 --> 00:01:08.880
JavaScript.

00:01:08.880 --> 00:01:11.430
SETH LADD: And the dart2js
compiler itself is written in

00:01:11.430 --> 00:01:12.710
Dart, correct?

00:01:12.710 --> 00:01:13.480
NICOLAS GEOFFRAY: It is.

00:01:13.480 --> 00:01:14.270
SETH LADD: So that's
pretty cool.

00:01:14.270 --> 00:01:17.640
So we're dog fooding our own
language and tools to make

00:01:17.640 --> 00:01:18.270
more tools.

00:01:18.270 --> 00:01:21.020
I like that.

00:01:21.020 --> 00:01:24.470
We had a very interesting
development last week.

00:01:24.470 --> 00:01:27.160
Why don't you go ahead and share
your screen, and we'll

00:01:27.160 --> 00:01:29.900
talk about what happened.

00:01:29.900 --> 00:01:31.150
NICOLAS GEOFFRAY: Sounds good.

00:01:34.400 --> 00:01:35.650
Start screenshare.

00:01:40.980 --> 00:01:42.580
So here you can see
what happened.

00:01:42.580 --> 00:01:45.220
SETH LADD: Ah, look at
those healthy bumps.

00:01:45.220 --> 00:01:48.360
So we're looking at the
performance charts you can

00:01:48.360 --> 00:01:53.030
find on dartlang.org, where we
track the performance of some

00:01:53.030 --> 00:01:56.890
well-known benchmarks across
the V8 world, which is our

00:01:56.890 --> 00:02:01.240
JavaScript engine; the Dart VM
world, which is the teal line

00:02:01.240 --> 00:02:05.690
on the top; and dart2js, which
is the purple line.

00:02:05.690 --> 00:02:10.419
And Nicolas, what happened
there last week?

00:02:10.419 --> 00:02:13.711
NICOLAS GEOFFRAY: You can see
the small bumps here.

00:02:13.711 --> 00:02:17.640
I don't know if you can follow
me with the mouse.

00:02:17.640 --> 00:02:22.970
But what actually happened is
that now we have better

00:02:22.970 --> 00:02:25.690
tracking of types of fields and

00:02:25.690 --> 00:02:29.035
parameters given to a method.

00:02:29.035 --> 00:02:33.350
That enables us to do better
optimizations inside methods.

00:02:33.350 --> 00:02:35.590
So we know what kind of fields,
what kind of types

00:02:35.590 --> 00:02:37.860
we're getting in the field, and
what kind of types we're

00:02:37.860 --> 00:02:40.580
getting when we're in a method
for a parameter.

00:02:44.050 --> 00:02:46.330
So the small bumps that
come into little--

00:02:46.330 --> 00:02:51.770
I mean, like this was last week,
this was a few days ago.

00:02:51.770 --> 00:02:57.050
It's because we got better
improvements on that type

00:02:57.050 --> 00:02:59.780
inferencing, as we call it.

00:02:59.780 --> 00:03:01.080
SETH LADD: So it looks--

00:03:01.080 --> 00:03:03.240
and what's really interesting,
maybe you can explain this to

00:03:03.240 --> 00:03:06.920
me, is the code which is the
purple line here, that is

00:03:06.920 --> 00:03:08.770
output by dart2js--

00:03:08.770 --> 00:03:10.640
which is outputting
JavaScript--

00:03:10.640 --> 00:03:13.860
is actually running
faster than V8.

00:03:13.860 --> 00:03:18.300
Now of course when we run the
output JavaScript on V8--

00:03:18.300 --> 00:03:19.830
I mean, what are we
looking at here?

00:03:19.830 --> 00:03:23.752
How can V8 run faster than V8?

00:03:23.752 --> 00:03:26.100
NICOLAS GEOFFRAY: So this
is pretty funny.

00:03:26.100 --> 00:03:33.270
You would guess that we would
run at 100% of V8 ideally.

00:03:33.270 --> 00:03:36.190
That's our goal in
the dart2js team.

00:03:36.190 --> 00:03:41.470
What is happening is that we're
getting pretty lucky

00:03:41.470 --> 00:03:48.360
with the V8 compiler, because
we're reaching a nice path in

00:03:48.360 --> 00:03:51.460
the V8 compiler that
allocates--

00:03:51.460 --> 00:03:56.490
that does better register
allocation, things like that.

00:03:56.490 --> 00:03:57.840
So that's one explanation.

00:03:57.840 --> 00:04:00.900
A second explanation is that
we're doing pretty aggressive

00:04:00.900 --> 00:04:04.220
aligning because we have
better knowledge

00:04:04.220 --> 00:04:07.120
of the whole program.

00:04:07.120 --> 00:04:14.367
And that knowledge is kind of
hard to gather with V8 when it

00:04:14.367 --> 00:04:17.769
runs the JavaScript version.

00:04:17.769 --> 00:04:21.320
SETH LADD: OK, so the
purple line isn't V8

00:04:21.320 --> 00:04:22.280
running faster than V8.

00:04:22.280 --> 00:04:28.440
It's the outputted code from
dart2js is just more

00:04:28.440 --> 00:04:32.580
intelligent than the handwritten
benchmark code

00:04:32.580 --> 00:04:36.130
that V8 is running as the
benchmark by which all other

00:04:36.130 --> 00:04:37.110
benchmarks are measured.

00:04:37.110 --> 00:04:38.110
NICOLAS GEOFFRAY: Yeah.

00:04:38.110 --> 00:04:39.110
That's correct.

00:04:39.110 --> 00:04:42.230
SETH LADD: That's awesome
So this is really cool.

00:04:42.230 --> 00:04:45.770
And so everyone can check this
out, dartlang.org/performance.

00:04:45.770 --> 00:04:49.020
I would say expect more
benchmarks soon.

00:04:49.020 --> 00:04:52.170
There's only two operating now,
DeltaBlue and Richards.

00:04:52.170 --> 00:04:54.470
And from what I guess, your
team is just getting

00:04:54.470 --> 00:04:56.570
started with this.

00:04:56.570 --> 00:04:58.840
From what I'm hearing, you're
even being a little

00:04:58.840 --> 00:05:01.740
conservative about how you
apply these inferences.

00:05:01.740 --> 00:05:06.710
So what's your feeling for the
runway here in terms of just

00:05:06.710 --> 00:05:08.360
general dart2js performance?

00:05:08.360 --> 00:05:11.120
Do you have more work to do?

00:05:11.120 --> 00:05:13.410
NICOLAS GEOFFRAY: We have
a lot of work to do.

00:05:13.410 --> 00:05:18.810
If you look at the benchmarks
DeltaBlue and Richards, we

00:05:18.810 --> 00:05:23.140
cover a lot when it comes to
doing type inferencing.

00:05:23.140 --> 00:05:25.930
There are some other benchmarks
that we're still

00:05:25.930 --> 00:05:31.130
working on where the type
inferencing still needs some

00:05:31.130 --> 00:05:35.110
improvements, and
working on that.

00:05:35.110 --> 00:05:35.770
SETH LADD: Cool.

00:05:35.770 --> 00:05:39.850
Well I know you prepared a
couple slides here to walk us

00:05:39.850 --> 00:05:43.800
through exactly what global
type inferencing means.

00:05:43.800 --> 00:05:47.800
Do you mind giving us kind of
a tour behind the scenes on

00:05:47.800 --> 00:05:50.340
how you guys achieved
these speed bumps?

00:05:50.340 --> 00:05:53.510
NICOLAS GEOFFRAY: Sure, so
a small explanation.

00:05:53.510 --> 00:05:57.090
The global type inferencing
looks at you whole program an

00:05:57.090 --> 00:06:01.900
looks at assignments to fields,
assignments to local

00:06:01.900 --> 00:06:04.700
variables, parameters
of methods.

00:06:04.700 --> 00:06:08.340
So every time you call a
method, we look at what

00:06:08.340 --> 00:06:10.700
parameters you call it with.

00:06:10.700 --> 00:06:13.790
And when you gather all that
information, at the end, you

00:06:13.790 --> 00:06:20.470
actually calculate or compute
the types of the fields and

00:06:20.470 --> 00:06:23.240
the types given to parameters.

00:06:23.240 --> 00:06:27.440
And in order to be correct,
you actually need to have

00:06:27.440 --> 00:06:29.440
global knowledge.

00:06:29.440 --> 00:06:32.390
And that's what we have when
we compile the Dart

00:06:32.390 --> 00:06:35.860
application to JavaScript.

00:06:35.860 --> 00:06:36.970
SETH LADD: And it's
global now.

00:06:36.970 --> 00:06:38.500
What about the Dart--
and by the way, all

00:06:38.500 --> 00:06:39.540
we see is your slide.

00:06:39.540 --> 00:06:42.700
So if you want to stop
screensharing for a minute,

00:06:42.700 --> 00:06:43.950
I'll ask you a couple
questions.

00:06:43.950 --> 00:06:45.810
Then we'll jump back
to the slides.

00:06:45.810 --> 00:06:48.740
But what is it about
Dart that--

00:06:48.740 --> 00:06:51.410
there you go.

00:06:51.410 --> 00:06:52.280
Hey.

00:06:52.280 --> 00:06:53.780
What is it about Dart
that allows you

00:06:53.780 --> 00:06:55.710
to do global analysis?

00:06:55.710 --> 00:06:57.130
Why can't we do this--

00:06:57.130 --> 00:06:58.880
why can't V8 do this
in JavaScript?

00:07:01.690 --> 00:07:05.530
NICOLAS GEOFFRAY: What happens
in JavaScript is that you can

00:07:05.530 --> 00:07:08.610
download JavaScript
code on demand.

00:07:12.530 --> 00:07:18.480
You can dynamically extend
your application with new

00:07:18.480 --> 00:07:20.490
calls, new assignments
to fields.

00:07:20.490 --> 00:07:22.940
And suddenly what you thought
you knew about

00:07:22.940 --> 00:07:24.565
the world gets extended.

00:07:27.480 --> 00:07:32.350
In V8 land, when it's a VM doing
optimization, it needs

00:07:32.350 --> 00:07:33.580
to de-optimize.

00:07:33.580 --> 00:07:38.000
Because now it sees, oh, this
field is an int and not just a

00:07:38.000 --> 00:07:40.850
string or something like that.

00:07:40.850 --> 00:07:42.410
So that's the difference.

00:07:42.410 --> 00:07:44.640
With Dart, we actually have
knowledge of the whole

00:07:44.640 --> 00:07:46.990
application.

00:07:46.990 --> 00:07:50.860
There's no dynamic loading, and
it's pretty structured.

00:07:50.860 --> 00:07:54.990
So we know when we analyze
the program what kind of

00:07:54.990 --> 00:07:57.900
[INAUDIBLE] the fields
will have.

00:07:57.900 --> 00:08:00.160
SETH LADD: For everyone who's
just joining us, we're here

00:08:00.160 --> 00:08:02.580
chatting with Nicolas Geoffray,
one of the engineers

00:08:02.580 --> 00:08:05.520
on the dart2js project, who
normally works in Aarhus,

00:08:05.520 --> 00:08:08.020
Denmark, but today is joining
us in a gondola

00:08:08.020 --> 00:08:09.920
in the Zurich office.

00:08:09.920 --> 00:08:12.880
And we were chatting about some
of the recent performance

00:08:12.880 --> 00:08:17.630
bumps that he and his team have
landed which have shown

00:08:17.630 --> 00:08:19.590
some pretty nice improvements
with the

00:08:19.590 --> 00:08:22.190
benchmarks that we're tracking.

00:08:22.190 --> 00:08:25.290
We're talking about global type
inferencing and what the

00:08:25.290 --> 00:08:28.860
Dart language allows us to do
above and beyond maybe what

00:08:28.860 --> 00:08:30.985
the JavaScript or V8 can
do to get some of

00:08:30.985 --> 00:08:32.450
these performance bumps.

00:08:32.450 --> 00:08:36.230
But one thing that I like to
explain to people about Dart

00:08:36.230 --> 00:08:38.990
is that it has a known
starting point.

00:08:38.990 --> 00:08:41.909
Every Dart program starts
with the main function.

00:08:41.909 --> 00:08:43.470
And from there, the program--

00:08:43.470 --> 00:08:46.160
the whole program analysis
can start by holistically

00:08:46.160 --> 00:08:48.670
understanding the complete
boundaries of that program.

00:08:48.670 --> 00:08:52.150
And it sounds like you're able
to take advantage of this by

00:08:52.150 --> 00:08:56.190
doing a global type inference
across the entire program.

00:08:56.190 --> 00:08:57.800
NICOLAS GEOFFRAY: One thing I
should probably also add is

00:08:57.800 --> 00:09:00.130
that in JavaScript,
it's so dynamic.

00:09:00.130 --> 00:09:06.070
There's lots of functionalities
like eval, and

00:09:06.070 --> 00:09:11.790
different ways of changing
the value of a field.

00:09:11.790 --> 00:09:13.960
And that makes it very difficult
for a static

00:09:13.960 --> 00:09:18.680
analysis to actually track
types of variables.

00:09:18.680 --> 00:09:20.270
SETH LADD: Right.

00:09:20.270 --> 00:09:22.810
And so one thing I should
probably ask though is, we

00:09:22.810 --> 00:09:26.050
keep mentioning this global
type inferencing.

00:09:26.050 --> 00:09:29.170
My understanding, of course,
is Dart has an

00:09:29.170 --> 00:09:30.390
optional type system.

00:09:30.390 --> 00:09:34.810
Now for everyone following along
at home, why don't you

00:09:34.810 --> 00:09:37.320
just respect those
type annotations?

00:09:37.320 --> 00:09:39.370
I put those in there.

00:09:39.370 --> 00:09:41.560
But why you have to go to a
global type inferencing?

00:09:45.670 --> 00:09:47.710
NICOLAS GEOFFRAY: The type
system in Dart is optional.

00:09:47.710 --> 00:09:49.600
You don't have to use it.

00:09:49.600 --> 00:09:51.160
And we actually have--

00:09:51.160 --> 00:09:55.030
Dart actually has two modes
for running applications.

00:09:55.030 --> 00:09:58.530
One is called checked
mode, and one is

00:09:58.530 --> 00:09:59.890
called unchecked mode.

00:10:02.630 --> 00:10:05.770
In checked mode, the type
annotations actually have

00:10:05.770 --> 00:10:11.430
meaning, that we will check that
the types match what you

00:10:11.430 --> 00:10:13.520
put in a variable.

00:10:13.520 --> 00:10:17.605
So if you string a equals 2,
we'll check that and produce a

00:10:17.605 --> 00:10:19.250
runtime error.

00:10:19.250 --> 00:10:22.860
In unchecked mode, we don't
look at that limitations.

00:10:22.860 --> 00:10:24.230
We just go through.

00:10:24.230 --> 00:10:25.470
So string a equals 2?

00:10:25.470 --> 00:10:27.360
Fine, we'll continue.

00:10:27.360 --> 00:10:30.465
And that's the main reason
we do not use those type

00:10:30.465 --> 00:10:33.470
annotations for optimizing.

00:10:33.470 --> 00:10:38.680
It's like, if you see
string a, well,

00:10:38.680 --> 00:10:41.200
nothing will make sure--

00:10:41.200 --> 00:10:44.560
in non-checked mode, nothing
will make sure that your

00:10:44.560 --> 00:10:46.380
variable a will hold a string.

00:10:46.380 --> 00:10:48.390
You can put anything in it.

00:10:48.390 --> 00:10:52.540
So you need to analyze every
assignment to that a variable

00:10:52.540 --> 00:10:57.500
to make sure it gets
that type.

00:10:57.500 --> 00:10:59.130
SETH LADD: Awesome.

00:10:59.130 --> 00:11:02.040
And as a developer, I actually
really like the way Dart does

00:11:02.040 --> 00:11:05.090
this, in that I don't feel
like I have to appease a

00:11:05.090 --> 00:11:07.730
ceremonial type checker just
to get my program to run.

00:11:07.730 --> 00:11:10.660
And now that I see that the
engineers, like the guys in

00:11:10.660 --> 00:11:14.280
the dart2js team, are able to
analyze my program for me and

00:11:14.280 --> 00:11:18.590
infer these types anyway, I
still feel like the tools and

00:11:18.590 --> 00:11:21.230
runtimes can take
advantage of--

00:11:21.230 --> 00:11:24.200
if I use int everywhere, then
you're going to start assuming

00:11:24.200 --> 00:11:26.210
that's an int and take advantage
of that optimization

00:11:26.210 --> 00:11:27.680
by assuming it's an int.

00:11:31.780 --> 00:11:34.640
This a good time to jump over
to the slides that you have,

00:11:34.640 --> 00:11:37.430
because I'm really curious to
see actually how this works.

00:11:37.430 --> 00:11:39.710
So can you walk us through
a little bit?

00:11:39.710 --> 00:11:40.960
NICOLAS GEOFFRAY: Yeah.

00:11:43.980 --> 00:11:47.790
I've taken a small
code snippet of

00:11:47.790 --> 00:11:49.040
the DeltaBlue benchmark.

00:11:51.882 --> 00:11:54.820
Here you have the slides.

00:11:54.820 --> 00:11:56.070
SETH LADD: I see me.

00:11:58.280 --> 00:12:00.052
NICOLAS GEOFFRAY: Oh,
you only see you.

00:12:00.052 --> 00:12:01.302
SETH LADD: Yep.

00:12:03.390 --> 00:12:05.860
NICOLAS GEOFFRAY: Screenshare.

00:12:05.860 --> 00:12:08.250
Let's try again.

00:12:08.250 --> 00:12:09.500
Desktop.

00:12:13.810 --> 00:12:15.040
There it is now.

00:12:15.040 --> 00:12:15.290
SETH LADD: OK.

00:12:15.290 --> 00:12:15.800
I see it.

00:12:15.800 --> 00:12:17.770
Fire it up.

00:12:17.770 --> 00:12:19.020
NICOLAS GEOFFRAY: Present.

00:12:26.860 --> 00:12:28.580
SETH LADD: And so before you
jump into this though, let's

00:12:28.580 --> 00:12:30.990
talk a little bit about the
benchmark that everyone's

00:12:30.990 --> 00:12:32.700
talking about, DeltaBlue.

00:12:32.700 --> 00:12:33.860
Where did this thing
come from?

00:12:33.860 --> 00:12:35.900
What does it do?

00:12:35.900 --> 00:12:39.160
Do you know anything about
its lineage or history?

00:12:39.160 --> 00:12:40.410
NICOLAS GEOFFRAY: Not really.

00:12:43.890 --> 00:12:46.970
So DeltaBlue is a pretty popular
benchmark that I think

00:12:46.970 --> 00:12:49.200
started with maybe Smalltalk--

00:12:49.200 --> 00:12:51.140
I'm actually not sure--

00:12:51.140 --> 00:12:55.200
and got ported to Java,
and ported to

00:12:55.200 --> 00:12:57.410
JavaScript by the V8 team.

00:12:57.410 --> 00:13:01.165
And now it's been ported to Dart
by the same-- well, the

00:13:01.165 --> 00:13:04.210
former V8 team, and
now the Dart team.

00:13:04.210 --> 00:13:05.370
It's a fairly--

00:13:05.370 --> 00:13:09.520
it's an object-oriented
benchmark, uses typical

00:13:09.520 --> 00:13:15.310
objects, and object dispatch.

00:13:15.310 --> 00:13:20.270
So it's the kind of benchmark
that should represent a real

00:13:20.270 --> 00:13:21.650
application.

00:13:21.650 --> 00:13:22.310
SETH LADD: OK, cool.

00:13:22.310 --> 00:13:26.210
So it has a long lineage that's
been ported many times.

00:13:26.210 --> 00:13:27.540
And it's really stressing an

00:13:27.540 --> 00:13:29.900
object-oriented type of system.

00:13:29.900 --> 00:13:31.840
NICOLAS GEOFFRAY: Yes.

00:13:31.840 --> 00:13:35.245
So if you write applications
really object-oriented, it

00:13:35.245 --> 00:13:37.530
should be pretty similar.

00:13:37.530 --> 00:13:40.830
SETH LADD: So what are
we looking at here?

00:13:40.830 --> 00:13:43.370
NICOLAS GEOFFRAY: This is a
method written in Dart of the

00:13:43.370 --> 00:13:46.500
DeltaBlue benchmark.

00:13:46.500 --> 00:13:50.450
It's one of the hottest methods
of the benchmark.

00:13:52.960 --> 00:13:53.940
I've taken a snipped.

00:13:53.940 --> 00:13:57.885
And you can see it's
pretty simple.

00:13:57.885 --> 00:14:00.650
You've got a method with
two parameters.

00:14:00.650 --> 00:14:11.700
And walk over the elements of
the list and check if it

00:14:11.700 --> 00:14:16.600
satisfies some constraint, and
then add it to another list.

00:14:16.600 --> 00:14:18.290
SETH LADD: OK, pretty
straightforward code here.

00:14:21.410 --> 00:14:24.670
NICOLAS GEOFFRAY: The next slide
shows what we used to

00:14:24.670 --> 00:14:26.760
generate back then.

00:14:26.760 --> 00:14:30.620
That means like two weeks ago.

00:14:30.620 --> 00:14:32.240
SETH LADD: We can
see your mouse.

00:14:32.240 --> 00:14:35.680
So if you want to move your
mouse to point to areas that

00:14:35.680 --> 00:14:36.810
you're talking about,
go for it.

00:14:36.810 --> 00:14:38.060
NICOLAS GEOFFRAY: Oh, sure.

00:14:39.730 --> 00:14:46.010
That's revision 19850, back
when we didn't have global

00:14:46.010 --> 00:14:48.810
type inferencing.

00:14:48.810 --> 00:14:51.860
And you can see it's
not looking as

00:14:51.860 --> 00:14:56.010
good as the Dart version.

00:14:56.010 --> 00:15:01.770
There's a lot of checking, like
you were checking if a

00:15:01.770 --> 00:15:05.880
call to a length getter on some

00:15:05.880 --> 00:15:08.410
variable gives you a number.

00:15:08.410 --> 00:15:11.640
And if it doesn't, we actually
jump to a method

00:15:11.640 --> 00:15:15.270
that will handle it.

00:15:15.270 --> 00:15:18.460
You can see that before,
we used the Dart

00:15:18.460 --> 00:15:20.300
version as a for loop.

00:15:20.300 --> 00:15:24.590
Now we can just have a while
loop because we have all these

00:15:24.590 --> 00:15:29.130
statements that cannot be
expressed in a for loop.

00:15:29.130 --> 00:15:32.280
We need to break here
to break the loop.

00:15:32.280 --> 00:15:36.650
So it doesn't look as nice
as the Dart version.

00:15:36.650 --> 00:15:40.720
And today what we generate is
actually pretty close to the

00:15:40.720 --> 00:15:48.680
Dart version, with a for loop,
and just a check of the

00:15:48.680 --> 00:15:54.690
condition, and adding to a new
collection, very similar to

00:15:54.690 --> 00:15:58.940
that Dart version.

00:15:58.940 --> 00:16:02.180
SETH LADD: Now help me
understand for the second

00:16:02.180 --> 00:16:05.440
slide, the original
JavaScript.

00:16:05.440 --> 00:16:08.220
Why did you have to move
to a while loop and

00:16:08.220 --> 00:16:09.470
put all those bailouts?

00:16:12.540 --> 00:16:14.910
NICOLAS GEOFFRAY: The reason we
have those bailouts is to

00:16:14.910 --> 00:16:20.120
actually have good performance
when running on top of

00:16:20.120 --> 00:16:21.700
JavaScript.

00:16:21.700 --> 00:16:26.040
If you were not to have all
these checks here, we couldn't

00:16:26.040 --> 00:16:28.620
omit this less than
directly, like

00:16:28.620 --> 00:16:31.710
JavaScript built-in operators.

00:16:31.710 --> 00:16:34.090
Dart has different semantics.

00:16:34.090 --> 00:16:40.850
And every object actually has
its own less than method.

00:16:40.850 --> 00:16:43.370
So it's not like we can use
the JavaScript built-in

00:16:43.370 --> 00:16:46.180
operator for that.

00:16:46.180 --> 00:16:48.580
SETH LADD: Right, because at
that point you don't know it's

00:16:48.580 --> 00:16:49.950
actually an int.

00:16:49.950 --> 00:16:53.120
So first you'd say, is this
thing really an int.

00:16:53.120 --> 00:16:53.800
If so, great.

00:16:53.800 --> 00:16:54.760
Go ahead and use less than.

00:16:54.760 --> 00:16:57.700
Because in Dart code, you have
operator overriding.

00:16:57.700 --> 00:16:58.880
You could have any object--

00:16:58.880 --> 00:17:01.810
or, sorry, any class implement
its own version of less than.

00:17:01.810 --> 00:17:02.440
NICOLAS GEOFFRAY:
That's correct.

00:17:02.440 --> 00:17:04.640
And you can see that I actually
have another check

00:17:04.640 --> 00:17:09.430
here, which is always
v.get$constraints, an array.

00:17:09.430 --> 00:17:14.099
And if it's not then I need to
go again in a bailout in the

00:17:14.099 --> 00:17:15.910
non-optimized version.

00:17:15.910 --> 00:17:16.960
And if it is, then great.

00:17:16.960 --> 00:17:20.220
I can do typical array indexing,
like transcript

00:17:20.220 --> 00:17:24.920
array indexing, and call--

00:17:24.920 --> 00:17:28.940
yeah, so typical array
indexing here.

00:17:28.940 --> 00:17:33.760
SETH LADD: OK, so the original
code has to accommodate a very

00:17:33.760 --> 00:17:36.090
dynamic world, because
he doesn't know

00:17:36.090 --> 00:17:37.594
these objects can be.

00:17:37.594 --> 00:17:38.370
NICOLAS GEOFFRAY: Yeah.

00:17:38.370 --> 00:17:38.870
He doesn't know.

00:17:38.870 --> 00:17:41.152
SETH LADD: But, the new world.

00:17:41.152 --> 00:17:45.260
NICOLAS GEOFFRAY: The new world,
which does a better

00:17:45.260 --> 00:17:51.190
inferencing on variables,
does know all of this.

00:17:51.190 --> 00:17:56.900
You can see it knows that t1
here is a JavaScript array.

00:17:56.900 --> 00:18:01.840
So v.constraints is a
JavaScript array.

00:18:01.840 --> 00:18:05.670
So it can just use the
built-in less than of

00:18:05.670 --> 00:18:06.920
JavaScript.

00:18:10.080 --> 00:18:13.890
Again, it uses the built-in
indexing operator here.

00:18:16.600 --> 00:18:17.850
SETH LADD: That is so cool.

00:18:23.530 --> 00:18:26.440
OK, so the new world.

00:18:29.310 --> 00:18:33.860
How do you actually go about
analyzing and say, OK, i is

00:18:33.860 --> 00:18:35.790
really an int now.

00:18:35.790 --> 00:18:37.690
It looks like that's the
major change, isn't it?

00:18:37.690 --> 00:18:41.260
Now you've been able to analyze
the program and say I

00:18:41.260 --> 00:18:45.410
know for a fact that some of
these variables point to

00:18:45.410 --> 00:18:49.440
objects of these types so I can
eliminate all bailouts.

00:18:49.440 --> 00:18:51.150
That's basically what's
happening, right?

00:18:51.150 --> 00:18:52.370
NICOLAS GEOFFRAY: That's
basically what's happening.

00:18:52.370 --> 00:18:57.600
We have better information of
the types of some fields.

00:18:57.600 --> 00:18:58.580
And we can do better.

00:18:58.580 --> 00:19:04.080
I'll actually go through some
of them, just to show the

00:19:04.080 --> 00:19:07.530
difference of some statements
of the [INAUDIBLE] code.

00:19:12.010 --> 00:19:13.260
This is the old version.

00:19:15.660 --> 00:19:20.690
And you can see that we're
actually calling a getter.

00:19:20.690 --> 00:19:23.630
This is calling a getter
method on v. And that's

00:19:23.630 --> 00:19:25.050
because we have no--

00:19:25.050 --> 00:19:28.720
we don't know what v is.

00:19:28.720 --> 00:19:33.250
So the Dart code that used to
do v.determinedBy will get

00:19:33.250 --> 00:19:35.590
translated to
v.get$determinedBy.

00:19:35.590 --> 00:19:41.250
Because we don't know if it's
a field or a getter.

00:19:41.250 --> 00:19:44.000
But with the new type
inferencing, we actually know

00:19:44.000 --> 00:19:47.910
that v is an object that has
a field and a getter called

00:19:47.910 --> 00:19:49.120
determinedBy.

00:19:49.120 --> 00:19:50.780
SETH LADD: Oh, that's so cool.

00:19:50.780 --> 00:19:52.790
NICOLAS GEOFFRAY: So we can just
inline the field access,

00:19:52.790 --> 00:19:54.050
like JavaScript field access.

00:19:54.050 --> 00:19:58.950
We know it won't
throw an error.

00:19:58.950 --> 00:20:01.160
And we know v has that field.

00:20:03.670 --> 00:20:07.620
So that's one improvement.

00:20:07.620 --> 00:20:11.410
A second improvement
is the loop itself.

00:20:11.410 --> 00:20:14.870
So I told you that before we
couldn't generate a for loop

00:20:14.870 --> 00:20:16.120
because of all these checks.

00:20:18.590 --> 00:20:22.800
These statements don't hold
in the for [INAUDIBLE]

00:20:22.800 --> 00:20:25.870
condition update typical loop.

00:20:25.870 --> 00:20:30.530
But with the new version, you
don't have these statements.

00:20:30.530 --> 00:20:32.550
You're not checking anymore.

00:20:32.550 --> 00:20:35.720
So you can actually just
generate something very

00:20:35.720 --> 00:20:39.530
similar to the Dart code, which
is, oh, I'm fetching

00:20:39.530 --> 00:20:42.690
constraints out of v. But
I know that the field

00:20:42.690 --> 00:20:47.190
constraints of v is a
JavaScript array.

00:20:47.190 --> 00:20:48.720
So I can just iterate
over the lengths.

00:20:53.070 --> 00:20:57.120
And that makes it very easy
to generate a for loop.

00:20:57.120 --> 00:20:59.970
SETH LADD: And not only is this
faster code, but it's

00:20:59.970 --> 00:21:01.310
also much easier to read.

00:21:01.310 --> 00:21:03.930
So now the debugging of the
generated code, to me at

00:21:03.930 --> 00:21:05.300
least, gets a lot easier.

00:21:05.300 --> 00:21:05.560
NICOLAS GEOFFRAY: Yeah.

00:21:05.560 --> 00:21:08.635
If you look at the generated
code and the original code, it

00:21:08.635 --> 00:21:09.490
looks very similar.

00:21:09.490 --> 00:21:14.030
So you actually can make sense
of, oh, I got an error here.

00:21:14.030 --> 00:21:15.315
How does that map
to my Dart code?

00:21:21.330 --> 00:21:25.080
Another improvement is all
this checking again.

00:21:25.080 --> 00:21:28.890
You're checking if t1 is
actually an array.

00:21:28.890 --> 00:21:30.870
And you're doing--

00:21:30.870 --> 00:21:33.400
so that's the check, right?

00:21:33.400 --> 00:21:39.630
And since you don't know if i is
in the range of the array,

00:21:39.630 --> 00:21:42.850
you do a range check here.

00:21:42.850 --> 00:21:44.620
And then you do the access,
because you know it's a

00:21:44.620 --> 00:21:46.442
JavaScript array.

00:21:46.442 --> 00:21:52.340
You know that it's in bounds,
so you don't throw an error.

00:21:52.340 --> 00:21:53.805
And you can just access
directly.

00:21:56.840 --> 00:22:00.200
Because of the new type
inferencing, we now know that

00:22:00.200 --> 00:22:02.110
t1 is a JavaScript array.

00:22:02.110 --> 00:22:06.600
We know that i is in between
0 and t1.length.

00:22:06.600 --> 00:22:08.030
So we know it's not
out of bounds.

00:22:08.030 --> 00:22:11.150
So we don't need to emit
a bounds check.

00:22:11.150 --> 00:22:12.695
And we just generate the
[INAUDIBLE] access.

00:22:15.710 --> 00:22:16.350
SETH LADD: That's huge.

00:22:16.350 --> 00:22:19.380
And one of the differences
there, thinking about the

00:22:19.380 --> 00:22:22.510
original code, is the difference
in behavior in a

00:22:22.510 --> 00:22:25.545
Dart list and a JavaScript array
when you access an index

00:22:25.545 --> 00:22:26.020
out of bounds.

00:22:26.020 --> 00:22:27.780
In Dart you'll get a--

00:22:27.780 --> 00:22:29.740
forgive if I don't get the
right name, but it's like

00:22:29.740 --> 00:22:31.880
index out of range error?

00:22:31.880 --> 00:22:32.940
NICOLAS GEOFFRAY: I think
that's changed

00:22:32.940 --> 00:22:33.990
to reg error now.

00:22:33.990 --> 00:22:35.630
SETH LADD: OK.

00:22:35.630 --> 00:22:36.290
You'll get a range error.

00:22:36.290 --> 00:22:39.480
But you'll get an actual
exception thrown when you try

00:22:39.480 --> 00:22:42.540
to access an index that's out
of the range of the list.

00:22:42.540 --> 00:22:45.880
But in JavaScript, I believe
you'll just get undefined.

00:22:45.880 --> 00:22:49.450
So the original Dart code had
to match that behavior.

00:22:49.450 --> 00:22:51.590
But it looks like now you're
able to be even smarter and

00:22:51.590 --> 00:22:55.440
say well, I know ahead of time
if these accesses are actually

00:22:55.440 --> 00:22:56.420
out of range.

00:22:56.420 --> 00:22:59.880
And if I know that, I don't
need to put that check in.

00:22:59.880 --> 00:23:01.340
That is great.

00:23:01.340 --> 00:23:02.190
NICOLAS GEOFFRAY:
That's correct.

00:23:02.190 --> 00:23:06.020
If JavaScript was to throw an
error when we got out of

00:23:06.020 --> 00:23:10.800
bounds, we wouldn't need
this code here.

00:23:10.800 --> 00:23:11.710
But it doesn't.

00:23:11.710 --> 00:23:14.830
And what happens is you just
get undefined out of it.

00:23:14.830 --> 00:23:18.750
And then you maybe get
an error later.

00:23:18.750 --> 00:23:23.410
But with Dart, you do get the
bounds check early, just

00:23:23.410 --> 00:23:25.560
before the access.

00:23:25.560 --> 00:23:27.830
But in that case, you actually
don't need it, because you

00:23:27.830 --> 00:23:30.000
know i is within the range.

00:23:36.110 --> 00:23:39.100
SETH LADD: OK, I like that.

00:23:39.100 --> 00:23:40.740
NICOLAS GEOFFRAY: I'm sorry?

00:23:40.740 --> 00:23:41.780
SETH LADD: I like what
I see so far.

00:23:41.780 --> 00:23:44.492
This is great.

00:23:44.492 --> 00:23:46.590
NICOLAS GEOFFRAY: I
think that's not

00:23:46.590 --> 00:23:49.230
the last, but almost.

00:23:49.230 --> 00:23:50.130
That's another--

00:23:50.130 --> 00:23:55.200
that's the last optimization
that triggered the jump, the

00:23:55.200 --> 00:23:58.260
bump in the graph.

00:23:58.260 --> 00:24:04.100
It's knowing that when you're
doing an equals check--

00:24:04.100 --> 00:24:09.080
so the original code is c double
equal determining.

00:24:09.080 --> 00:24:15.150
And when dart2js knows that
you're actually just doing an

00:24:15.150 --> 00:24:19.900
identity check, because that
equals results in the object

00:24:19.900 --> 00:24:22.640
equals in Dart.

00:24:22.640 --> 00:24:29.240
So you could just emit the
definition of the identity

00:24:29.240 --> 00:24:32.650
check in Dart, which
is pretty complex.

00:24:32.650 --> 00:24:36.480
But the intent is that the
[INAUDIBLE] equals doesn't

00:24:36.480 --> 00:24:39.170
have to check for null.

00:24:39.170 --> 00:24:49.586
So if you pass a null, if
the receiver is null--

00:24:49.586 --> 00:24:49.960
I'm sorry.

00:24:49.960 --> 00:24:52.710
Let me revert.

00:24:52.710 --> 00:24:57.720
What I'm saying is that in
dart2js, we actually have two

00:24:57.720 --> 00:25:01.500
nulls, because of some
dumb problems with

00:25:01.500 --> 00:25:03.710
interaction with the DOM.

00:25:03.710 --> 00:25:06.815
One is undefined,
just undefined.

00:25:06.815 --> 00:25:09.460
And the other is JavaScript
null.

00:25:09.460 --> 00:25:16.460
So we cannot just use triple
equal for checking if two

00:25:16.460 --> 00:25:19.010
things are identical.

00:25:19.010 --> 00:25:20.600
We need to use double equal.

00:25:20.600 --> 00:25:22.030
That's what's happening here.

00:25:22.030 --> 00:25:24.030
c could be undefined of null.

00:25:24.030 --> 00:25:27.530
In that case, we need to
check if determining is

00:25:27.530 --> 00:25:28.270
undefined or null.

00:25:28.270 --> 00:25:30.480
And that's what's
happening here.

00:25:30.480 --> 00:25:35.260
The most interesting is that
here, it's the identity check.

00:25:35.260 --> 00:25:36.785
And we don't need to go
through a method.

00:25:36.785 --> 00:25:38.700
We just use the JavaScript
identity check.

00:25:44.420 --> 00:25:47.770
SETH LADD: How does dart2js know
or infer that I'm doing

00:25:47.770 --> 00:25:52.960
basically an identity check?

00:25:52.960 --> 00:25:56.900
NICOLAS GEOFFRAY: It knows that
c, the [INAUDIBLE] equals

00:25:56.900 --> 00:25:59.940
on c is the wanted object.

00:25:59.940 --> 00:26:00.790
SETH LADD: OK.

00:26:00.790 --> 00:26:04.510
So this one, this particular
thing, wouldn't work if I

00:26:04.510 --> 00:26:07.510
implemented my own equals
equals, of course.

00:26:07.510 --> 00:26:11.550
NICOLAS GEOFFRAY: So if you
implemented your own, and the

00:26:11.550 --> 00:26:16.110
type inferencing would know what
kind of variable, what

00:26:16.110 --> 00:26:17.830
type that variable is.

00:26:17.830 --> 00:26:22.110
Then you would do actual direct
call of that method, of

00:26:22.110 --> 00:26:26.030
that operator equal of yours.

00:26:26.030 --> 00:26:28.570
In that case here-- before,
it actually didn't know

00:26:28.570 --> 00:26:29.820
what c could be.

00:26:33.480 --> 00:26:36.410
Because of the way we generate
code, we cannot just call a

00:26:36.410 --> 00:26:37.890
method on c.

00:26:37.890 --> 00:26:42.270
If c was to be an integer, for
example, I mean, it's a

00:26:42.270 --> 00:26:46.230
JavaScript integer or number.

00:26:46.230 --> 00:26:48.170
It's not like you can call
something on it.

00:26:48.170 --> 00:26:51.720
So we need to code local
methods that will

00:26:51.720 --> 00:26:53.890
do all these checks.

00:26:53.890 --> 00:26:56.270
But now we actually know
what c could be.

00:26:56.270 --> 00:27:00.130
And we know that c, that you're
just doing an identity

00:27:00.130 --> 00:27:01.906
check on c.

00:27:01.906 --> 00:27:04.600
And you only need to emit
this code instead.

00:27:04.600 --> 00:27:07.130
SETH LADD: Great.

00:27:07.130 --> 00:27:11.990
NICOLAS GEOFFRAY: And the last
optimization I'll show you is

00:27:11.990 --> 00:27:12.620
this check.

00:27:12.620 --> 00:27:21.520
So the semantics in Dart of an
if check is that the condition

00:27:21.520 --> 00:27:24.000
must evaluate true.

00:27:24.000 --> 00:27:28.400
If it evaluates to anything
else, it's false.

00:27:28.400 --> 00:27:32.120
And that's very different than
JavaScript, where lots of

00:27:32.120 --> 00:27:33.670
things evaluate to true--

00:27:33.670 --> 00:27:38.830
1, non 0, non null,
non undefined.

00:27:38.830 --> 00:27:41.380
SETH LADD: Right, many
truthy values.

00:27:41.380 --> 00:27:42.630
NICOLAS GEOFFRAY: Exactly.

00:27:44.320 --> 00:27:48.850
And Dart is very different, that
you have to be true to

00:27:48.850 --> 00:27:52.100
actually pass an if test.

00:27:52.100 --> 00:27:55.780
We generate a lot of triple
equals true when doing calls

00:27:55.780 --> 00:28:02.720
in if checks, because we
don't know what this

00:28:02.720 --> 00:28:06.780
method actually returns.

00:28:06.780 --> 00:28:10.170
With the new type inferencing,
we know that all the

00:28:10.170 --> 00:28:13.690
isSatisfied methods
in the benchmark

00:28:13.690 --> 00:28:17.180
always return the Boolean.

00:28:17.180 --> 00:28:20.680
It returns either false, the
JavaScript false, or the

00:28:20.680 --> 00:28:22.150
JavaScript true.

00:28:22.150 --> 00:28:24.490
So we don't need to compare.

00:28:24.490 --> 00:28:27.010
If that evaluates to false,
then the condition will be

00:28:27.010 --> 00:28:31.570
false and we won't go
in the if block.

00:28:31.570 --> 00:28:32.683
If it evaluates to
true, then fine.

00:28:32.683 --> 00:28:33.933
It will continue.

00:28:36.540 --> 00:28:38.645
SETH LADD: Yeah, this code
is so much smarter.

00:28:38.645 --> 00:28:39.895
Good job.

00:28:44.170 --> 00:28:49.330
NICOLAS GEOFFRAY: That's it,
comparing the old version of

00:28:49.330 --> 00:28:51.300
what we generated and the new
version of what we generated.

00:28:51.300 --> 00:28:57.160
I have a slide of what is the
actual implementation in the

00:28:57.160 --> 00:28:58.730
JavaScript benchmark.

00:28:58.730 --> 00:29:02.970
SETH LADD: OK, so this is what
V8 has been running as its

00:29:02.970 --> 00:29:06.110
version of DeltaBlue
for many years.

00:29:06.110 --> 00:29:07.960
This is the one we
measure against.

00:29:07.960 --> 00:29:10.110
NICOLAS GEOFFRAY: Yes, that's
the one idea of what is called

00:29:10.110 --> 00:29:11.670
now the Octane benchmark.

00:29:15.800 --> 00:29:17.050
This is the Dart version.

00:29:19.530 --> 00:29:20.340
No.

00:29:20.340 --> 00:29:21.410
This is not the Dart version.

00:29:21.410 --> 00:29:27.600
That's the dart2js version.

00:29:27.600 --> 00:29:30.670
Let me check if I have a Dart
version close to it.

00:29:35.860 --> 00:29:37.920
No I don't.

00:29:37.920 --> 00:29:40.110
SETH LADD: I think we can flip
back and forth between the

00:29:40.110 --> 00:29:43.890
dart2js version and the
original V8 version.

00:29:43.890 --> 00:29:47.280
Because what's really
interesting to me is how did

00:29:47.280 --> 00:29:53.060
dart2js generate a version of
that method that's faster than

00:29:53.060 --> 00:29:53.950
the handwritten.

00:29:53.950 --> 00:29:55.940
Which, I guess most people
would assume that the

00:29:55.940 --> 00:29:58.440
handwritten benchmark is always

00:29:58.440 --> 00:29:59.210
going to be the fastest.

00:29:59.210 --> 00:30:01.150
So I think you you've got
a couple areas you're

00:30:01.150 --> 00:30:02.430
going to point out.

00:30:02.430 --> 00:30:04.960
NICOLAS GEOFFRAY: Yeah.

00:30:04.960 --> 00:30:09.410
So what's happening here,
actually I've highlighted what

00:30:09.410 --> 00:30:12.130
is happening.

00:30:12.130 --> 00:30:17.510
If you look at those statements
where you're doing

00:30:17.510 --> 00:30:22.400
something on cc and call,
the call variable--

00:30:25.450 --> 00:30:26.700
how to start?

00:30:29.875 --> 00:30:36.530
The JavaScript benchmark needs
to add some behavior to the

00:30:36.530 --> 00:30:37.780
JavaScript array.

00:30:41.130 --> 00:30:44.157
There are multiple ways to
add new behaviors to

00:30:44.157 --> 00:30:45.220
a JavaScript array.

00:30:45.220 --> 00:30:51.360
You can drop it so you have your
own object that grabs a

00:30:51.360 --> 00:30:52.290
JavaScript array.

00:30:52.290 --> 00:30:55.840
And you do calls on
that object, and

00:30:55.840 --> 00:30:57.750
you get that behavior.

00:30:57.750 --> 00:31:00.040
Another way is to
monkey patch.

00:31:00.040 --> 00:31:04.190
That's adding new
methods to the

00:31:04.190 --> 00:31:06.050
JavaScript array prototype.

00:31:06.050 --> 00:31:11.730
But that latter solution
doesn't really scale.

00:31:11.730 --> 00:31:13.910
If you start to monkey patching
in one component of

00:31:13.910 --> 00:31:18.995
your application, then monkey
patching in another component

00:31:18.995 --> 00:31:23.250
could just not work, because
you're adding the same method

00:31:23.250 --> 00:31:26.610
name with different
parameters.

00:31:26.610 --> 00:31:28.510
SETH LADD: When you mix these
two worlds, you don't know

00:31:28.510 --> 00:31:30.000
what's going to happen.

00:31:30.000 --> 00:31:32.270
NICOLAS GEOFFRAY: Yes.

00:31:32.270 --> 00:31:37.330
So I guess that's the reason why
the JavaScript benchmark

00:31:37.330 --> 00:31:46.610
wraps the JavaScript array in
order to add new behavior, so

00:31:46.610 --> 00:31:50.090
the size, the add, and the add
under the new behavior.

00:31:50.090 --> 00:31:56.980
There's another method in the
benchmark that moves something

00:31:56.980 --> 00:32:01.520
from your array that matches
a pattern, or

00:32:01.520 --> 00:32:04.490
something like that.

00:32:04.490 --> 00:32:07.980
The benchmark actually wraps
a JavaScript array.

00:32:07.980 --> 00:32:14.270
And that's what Dart is also
doing with its list class.

00:32:14.270 --> 00:32:18.740
The list class in Dart has lots
of behavior, not just the

00:32:18.740 --> 00:32:21.230
JavaScript array behavior.

00:32:21.230 --> 00:32:27.240
And what dart2js does is it
compiles a list object to a

00:32:27.240 --> 00:32:28.650
JavaScript array.

00:32:28.650 --> 00:32:33.490
But in order to have that new
behavior in the JavaScript

00:32:33.490 --> 00:32:36.440
array, it uses that
functionality called

00:32:36.440 --> 00:32:44.510
interceptors that will hold
this new behavior.

00:32:44.510 --> 00:32:47.210
And that's the reason why
we could just generate a

00:32:47.210 --> 00:32:52.460
JavaScript array out of
a list, a Dart list.

00:32:52.460 --> 00:32:55.160
And when you call methods
that are on the list--

00:32:55.160 --> 00:32:58.480
like filter--

00:32:58.480 --> 00:33:00.100
well now it's called
RemoveWhere--

00:33:00.100 --> 00:33:04.080
all these methods are in list
in a simple class called

00:33:04.080 --> 00:33:05.380
[? iterable. ?]

00:33:05.380 --> 00:33:07.490
All these methods will actually
go through an

00:33:07.490 --> 00:33:16.415
interceptor that will implement
the behavior.

00:33:16.415 --> 00:33:17.990
SETH LADD: Let's see
the version that

00:33:17.990 --> 00:33:19.210
dart2js spits out again.

00:33:19.210 --> 00:33:22.100
I think that will make
it more clear.

00:33:26.120 --> 00:33:27.640
NICOLAS GEOFFRAY: Since we
actually use a JavaScript

00:33:27.640 --> 00:33:34.140
array for a Dart list, the
dart2js knows that you can

00:33:34.140 --> 00:33:38.130
actually just do an
array access, a

00:33:38.130 --> 00:33:40.540
JavaScript array access.

00:33:40.540 --> 00:33:44.770
Like here, so you notice at t1
is a Dart list that will map

00:33:44.770 --> 00:33:46.190
to a JavaScript array.

00:33:46.190 --> 00:33:51.140
So you can just do a direct
JavaScript array axis.

00:33:51.140 --> 00:33:54.270
And the same for call here.

00:33:54.270 --> 00:33:56.750
It knows that it's
a Dart list.

00:33:56.750 --> 00:34:00.200
That means it knows it's a
JavaScript array at runtime.

00:34:00.200 --> 00:34:03.290
So you can just call the push
method, which is something

00:34:03.290 --> 00:34:05.850
that is on the JavaScript array
prototype by default.

00:34:08.650 --> 00:34:10.600
SETH LADD: And you can do this
because you've globally

00:34:10.600 --> 00:34:13.889
analyzed the program and
you know what t1 is.

00:34:13.889 --> 00:34:15.000
NICOLAS GEOFFRAY: Exactly.

00:34:15.000 --> 00:34:16.120
SETH LADD: That is awesome.

00:34:16.120 --> 00:34:17.570
That is so cool.

00:34:17.570 --> 00:34:20.520
NICOLAS GEOFFRAY: And we also
know that all the [INAUDIBLE]

00:34:20.520 --> 00:34:24.580
of add constraints consuming
to pass an array

00:34:24.580 --> 00:34:26.909
here, or a Dart list.

00:34:26.909 --> 00:34:29.219
SETH LADD: So that's actually
really good key point.

00:34:29.219 --> 00:34:33.690
Again, when we say global type
inferencing, you mean not just

00:34:33.690 --> 00:34:37.620
obviously inside a function, but
also everyone, and we mean

00:34:37.620 --> 00:34:39.449
everybody who calls into
this function.

00:34:39.449 --> 00:34:41.679
You know what they're passing
in, so you make a whole bunch

00:34:41.679 --> 00:34:44.310
of assumptions then inside
the function.

00:34:44.310 --> 00:34:44.680
NICOLAS GEOFFRAY: Yeah.

00:34:44.680 --> 00:34:45.630
That's correct.

00:34:45.630 --> 00:34:47.460
SETH LADD: Yeah, cool.

00:34:47.460 --> 00:34:52.340
That to me sounds like one of
the major differences between

00:34:52.340 --> 00:34:55.920
how far V8's able to go and how
far dart2js or the VM is

00:34:55.920 --> 00:34:58.990
able to go, based on--

00:34:58.990 --> 00:35:01.560
we really have a closed world
assumption when we're thinking

00:35:01.560 --> 00:35:03.760
about Dart applications.

00:35:03.760 --> 00:35:04.530
NICOLAS GEOFFRAY: That's
basically it.

00:35:04.530 --> 00:35:06.280
And since it's very
structured, it's

00:35:06.280 --> 00:35:07.930
very easy to analyze.

00:35:07.930 --> 00:35:09.821
Well, it's relatively
easy to analyze.

00:35:09.821 --> 00:35:12.800
It's definitely easier
than JavaScript code.

00:35:12.800 --> 00:35:16.510
SETH LADD: So here's an
interesting point.

00:35:16.510 --> 00:35:20.080
Your global type inferencing
system does not respect type

00:35:20.080 --> 00:35:24.850
annotations at all, due to the
semantics of the types or the

00:35:24.850 --> 00:35:25.900
type annotations.

00:35:25.900 --> 00:35:28.280
So I means I could write a
program with zero type

00:35:28.280 --> 00:35:32.670
annotations and still get the
exact same benefits from

00:35:32.670 --> 00:35:34.596
dart2js today.

00:35:34.596 --> 00:35:35.080
NICOLAS GEOFFRAY: Yeah.

00:35:35.080 --> 00:35:38.016
Same benefits, and the same
applies to the VM.

00:35:38.016 --> 00:35:38.850
SETH LADD: Yeah.

00:35:38.850 --> 00:35:39.200
That's a great point.

00:35:39.200 --> 00:35:40.550
NICOLAS GEOFFRAY: The VM
doesn't look at type

00:35:40.550 --> 00:35:41.910
annotations either.

00:35:41.910 --> 00:35:46.320
So type annotations is really a
tool for the developer to do

00:35:46.320 --> 00:35:50.150
refactoring and share some code
with other developers.

00:35:50.150 --> 00:35:53.680
SETH LADD: So it sounds like
if I as a developer want to

00:35:53.680 --> 00:35:56.170
take advantage of some of these
nice new inferencing

00:35:56.170 --> 00:36:00.130
optimizations, just make sure
that I assign a variable the

00:36:00.130 --> 00:36:05.390
same type all the time, and
dart2js will respect that.

00:36:05.390 --> 00:36:05.710
NICOLAS GEOFFRAY: Yeah.

00:36:05.710 --> 00:36:08.040
There are some couple of things
that will make dart2js

00:36:08.040 --> 00:36:08.750
very happy.

00:36:08.750 --> 00:36:12.310
So if you start assigning the
same thing to a variable or a

00:36:12.310 --> 00:36:16.450
field, it will be able to apply

00:36:16.450 --> 00:36:18.340
optimization based on it.

00:36:18.340 --> 00:36:21.740
SETH LADD: So for everyone
following at home, use final

00:36:21.740 --> 00:36:26.740
and don't change field types,
and you'll be much happier.

00:36:26.740 --> 00:36:29.410
NICOLAS GEOFFRAY: And if you
have a field that is supposed

00:36:29.410 --> 00:36:32.790
to hold a number, make sure
it holds a number.

00:36:32.790 --> 00:36:34.380
And it can never be null.

00:36:38.960 --> 00:36:40.670
So the Dart VM--

00:36:40.670 --> 00:36:43.060
it shouldn't affect
the Dart VM much.

00:36:43.060 --> 00:36:45.810
But for dart2js, it's very
important because of what's

00:36:45.810 --> 00:36:46.720
happening in JavaScript.

00:36:46.720 --> 00:36:49.710
In JavaScript, when you
do null plus 42, you

00:36:49.710 --> 00:36:50.500
actually get 42.

00:36:50.500 --> 00:36:54.700
To the null gets
converted to 0.

00:36:54.700 --> 00:36:55.880
SETH LADD: That's logical.

00:36:55.880 --> 00:37:00.430
NICOLAS GEOFFRAY: In Dart, null
plus should throw you a

00:37:00.430 --> 00:37:03.540
null pointer exception.

00:37:03.540 --> 00:37:09.840
So if dart2js knows that this
field is always a number, it

00:37:09.840 --> 00:37:13.310
won't have to do any checking.

00:37:13.310 --> 00:37:15.250
SETH LADD: So what I'm thinking
about now is when I

00:37:15.250 --> 00:37:19.480
have classes that have fields
that should be numbers, make

00:37:19.480 --> 00:37:25.540
sure I initialize them in
the initializer list.

00:37:25.540 --> 00:37:29.250
NICOLAS GEOFFRAY: In the
initializer list, or where the

00:37:29.250 --> 00:37:32.220
field is declared.

00:37:32.220 --> 00:37:35.320
It makes the type
inferencing--

00:37:35.320 --> 00:37:39.240
it makes the life of the type
inferencing a lot easier.

00:37:39.240 --> 00:37:40.430
SETH LADD: Wow, that
is a great tip.

00:37:40.430 --> 00:37:43.680
I was going to ask is there
anything else that I need to

00:37:43.680 --> 00:37:47.190
do as a developer to write code
in a special way to take

00:37:47.190 --> 00:37:47.960
advantage of this.

00:37:47.960 --> 00:37:50.020
And so the good tip is, if I'm
dealing with numbers, make

00:37:50.020 --> 00:37:51.520
sure they're always initialized
to a number, and

00:37:51.520 --> 00:37:54.284
don't change them from a number
to something else.

00:37:54.284 --> 00:37:56.350
NICOLAS GEOFFRAY: Yeah.

00:37:56.350 --> 00:37:59.640
Keep your fields sane.

00:37:59.640 --> 00:38:01.950
That's what you should say.

00:38:01.950 --> 00:38:04.020
SETH LADD: Well I really,
really appreciate this.

00:38:04.020 --> 00:38:05.700
This video is recorded.

00:38:05.700 --> 00:38:07.890
We're going to post it up
for everyone to watch.

00:38:07.890 --> 00:38:11.810
And so I am very encouraged
and happy to see the bumps

00:38:11.810 --> 00:38:14.820
that you and your team are able
to push out for dart2js,

00:38:14.820 --> 00:38:17.490
so excellent work there.

00:38:17.490 --> 00:38:19.970
Can we expect more benchmarks?

00:38:19.970 --> 00:38:26.100
And what we expect in terms of
how much you're rolling out

00:38:26.100 --> 00:38:28.320
this type inferencing?

00:38:28.320 --> 00:38:30.010
NICOLAS GEOFFRAY: So
it just started.

00:38:30.010 --> 00:38:33.620
It's been two weeks since we
started on type inferencing.

00:38:33.620 --> 00:38:36.550
And right now it's
pretty naive.

00:38:36.550 --> 00:38:41.970
There's a lot of improvements we
know we can do, except that

00:38:41.970 --> 00:38:44.235
it gets more and more complex
to implement.

00:38:48.250 --> 00:38:50.330
We still have the same bar.

00:38:50.330 --> 00:38:53.180
We were generating JavaScript
code, and what we want is

00:38:53.180 --> 00:38:57.120
actually to be as fast as
handwritten JavaScript code.

00:38:57.120 --> 00:38:59.180
And we're getting
closer to that.

00:38:59.180 --> 00:39:03.000
If you look at DeltaBlue,
that's what's happening.

00:39:03.000 --> 00:39:07.850
We have some other benchmarks,
and we're getting close to the

00:39:07.850 --> 00:39:09.840
same performance.

00:39:09.840 --> 00:39:11.840
They need more work,
obviously.

00:39:11.840 --> 00:39:15.960
The reason why they're not
public yet, those benchmarks,

00:39:15.960 --> 00:39:19.766
is because publishing
a new benchmark is--

00:39:19.766 --> 00:39:22.130
I mean, we need to make
sure they're relevant.

00:39:22.130 --> 00:39:25.770
And we need to make sure that
they apply to JavaScript and

00:39:25.770 --> 00:39:31.202
Dart, and both versions have
equivalent functionalities and

00:39:31.202 --> 00:39:33.030
stuff like that.

00:39:33.030 --> 00:39:36.420
So it's not that [INAUDIBLE] to
publish those benchmarks.

00:39:36.420 --> 00:39:38.870
SETH LADD: Right, but I get the
sense we'll see more over

00:39:38.870 --> 00:39:43.220
time as we've tested them out
and making sure they're

00:39:43.220 --> 00:39:44.750
relevant and correct.

00:39:44.750 --> 00:39:45.430
NICOLAS GEOFFRAY: Yes.

00:39:45.430 --> 00:39:49.610
I mean, the V8 benchmark suite
that is now Octane benchmark

00:39:49.610 --> 00:39:53.715
suite, it took some time
to publish it.

00:39:53.715 --> 00:39:57.480
It's not super obvious that all
those benchmarks actually

00:39:57.480 --> 00:40:00.330
are relevant initially.

00:40:00.330 --> 00:40:04.040
SETH LADD: Well I like
what I see so far.

00:40:04.040 --> 00:40:06.360
Dart developers can take
advantage of this today.

00:40:06.360 --> 00:40:09.050
This is code that has
been checked in.

00:40:09.050 --> 00:40:14.130
When you get the dart SDK and
you compile the JavaScript,

00:40:14.130 --> 00:40:16.680
they're going to see these
improvements, or at least the

00:40:16.680 --> 00:40:17.620
beginnings of these
improvements.

00:40:17.620 --> 00:40:19.460
So this stuff is real
and available today.

00:40:22.510 --> 00:40:24.890
Well, thank you on the behalf
of the Dartisans community.

00:40:24.890 --> 00:40:26.380
Nicolas, thanks for joining
us today and

00:40:26.380 --> 00:40:27.370
preparing these slides.

00:40:27.370 --> 00:40:29.910
It was a great walkthrough, and
I really appreciate it and

00:40:29.910 --> 00:40:32.120
learned a ton of stuff myself.

00:40:32.120 --> 00:40:36.270
So hopefully we'll have you back
again later when we've

00:40:36.270 --> 00:40:39.540
got other cool stuff to show
from the dart2js world.

00:40:39.540 --> 00:40:40.220
NICOLAS GEOFFRAY: My pleasure.

00:40:40.220 --> 00:40:43.030
Maybe tomorrow.

00:40:43.030 --> 00:40:45.910
SETH LADD: You guys are fast.

00:40:45.910 --> 00:40:48.040
Well thank you very much and
we'll see you next time.

00:40:48.040 --> 00:40:49.310
Bye, Nicolas.

00:40:49.310 --> 00:40:50.560
NICOLAS GEOFFRAY: See you.

