WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.952
[UPBEAT MUSIC PLAYING]

00:00:08.380 --> 00:00:10.000
HADI HARIRI: Welcome to Krakow.

00:00:10.000 --> 00:00:11.740
Welcome to Poland, obviously.

00:00:11.740 --> 00:00:14.450
And welcome to this
session on Kotlin.

00:00:14.450 --> 00:00:16.030
Now I'm assuming
the majority of you

00:00:16.030 --> 00:00:17.560
here have probably
heard of Kotlin,

00:00:17.560 --> 00:00:20.426
maybe not played with it,
have seen it a little bit.

00:00:20.426 --> 00:00:21.550
If I got that right, great.

00:00:21.550 --> 00:00:24.640
If I got it wrong, just
keep it to yourself.

00:00:24.640 --> 00:00:26.080
And we'll start.

00:00:26.080 --> 00:00:28.690
I'll show you a bunch of
different things with Kotlin.

00:00:28.690 --> 00:00:31.210
And I will do it a little
bit differently this time.

00:00:31.210 --> 00:00:34.300
I'll compare it a little bit
to some other programming

00:00:34.300 --> 00:00:34.960
language.

00:00:34.960 --> 00:00:38.380
Namely, we'll pick
Java today to give you

00:00:38.380 --> 00:00:47.830
a feel of where and what we
try and provide you with value.

00:00:47.830 --> 00:00:51.380
And just to get started,
this is my main function.

00:00:51.380 --> 00:00:53.410
So you can see it up there.

00:00:53.410 --> 00:00:55.930
And I can write hello.

00:00:55.930 --> 00:00:57.280
And then I can run this.

00:00:57.280 --> 00:00:59.620
And that's as simple as it gets.

00:00:59.620 --> 00:01:04.340
So to start with, you don't
have a public static void main,

00:01:04.340 --> 00:01:05.980
and you don't have
a static class.

00:01:05.980 --> 00:01:09.250
You just have basically
top level functions.

00:01:09.250 --> 00:01:13.000
As I always say, it's like
JavaScript, but in a good way.

00:01:13.000 --> 00:01:17.380
And you can basically define
your functions as you like.

00:01:17.380 --> 00:01:20.290
So I can say function,
for instance,

00:01:20.290 --> 00:01:25.210
print message, and then have a
parameter here of type string,

00:01:25.210 --> 00:01:29.170
and then print line,
and then the message.

00:01:29.170 --> 00:01:31.180
And I can do string
interrelation here

00:01:31.180 --> 00:01:34.420
and do whatever I want.

00:01:34.420 --> 00:01:37.760
Now notice that
there's no return type.

00:01:37.760 --> 00:01:39.910
By default, it's unit.

00:01:39.910 --> 00:01:43.240
And you can omit it if you
don't have a return type.

00:01:43.240 --> 00:01:45.074
And functions, again,
conciseness of Kotlin.

00:01:45.074 --> 00:01:47.323
So what we're trying to do
is make functions as simple

00:01:47.323 --> 00:01:49.570
as possible, and as easy
as possible to write,

00:01:49.570 --> 00:01:51.370
and as concise as
possible to write.

00:01:51.370 --> 00:01:54.400
And if a function returns an
expression, returns a value,

00:01:54.400 --> 00:01:56.890
you can just write that as what
we call a single expression

00:01:56.890 --> 00:01:57.389
function.

00:01:57.389 --> 00:02:01.990
So essentially, if I do a
sum, for instance x int y int,

00:02:01.990 --> 00:02:04.670
I can just write
that as x plus y.

00:02:04.670 --> 00:02:06.790
I don't need to explicitly
put the return type.

00:02:06.790 --> 00:02:10.120
I don't need to open the curly
braces, close the curly braces.

00:02:10.120 --> 00:02:11.695
Just write it as simple as that.

00:02:11.695 --> 00:02:13.570
Then, of course, you
can call these functions

00:02:13.570 --> 00:02:14.320
anywhere you want.

00:02:14.320 --> 00:02:18.070
Print message, something.

00:02:18.070 --> 00:02:23.200
Now how does this help in
terms of what you already have?

00:02:23.200 --> 00:02:26.650
You're like, OK, the syntax
is a little bit more concise,

00:02:26.650 --> 00:02:29.750
and I write fun
instead of not fun.

00:02:29.750 --> 00:02:31.676
And I write unit
instead of void.

00:02:31.676 --> 00:02:32.800
But what does that give me?

00:02:32.800 --> 00:02:35.320
So let's take a look
at, for example,

00:02:35.320 --> 00:02:37.750
overloaded functions
in Java, This

00:02:37.750 --> 00:02:40.120
is overloaded methods in Java.

00:02:40.120 --> 00:02:42.850
And I'm going to
split that vertically.

00:02:42.850 --> 00:02:46.840
And now take a look at
overloaded function in Kotlin,

00:02:46.840 --> 00:02:49.442
So you can see that this
is already somewhere

00:02:49.442 --> 00:02:50.650
where it's cutting down code.

00:02:50.650 --> 00:02:52.816
I don't need to do these
overloading methods anymore

00:02:52.816 --> 00:02:53.950
in Java.

00:02:53.950 --> 00:02:57.850
Obviously, I'm putting this
outside in its own top level

00:02:57.850 --> 00:02:58.510
function.

00:02:58.510 --> 00:03:01.960
But this could actually be a
member function of a class.

00:03:01.960 --> 00:03:04.060
So don't worry about
saying, where is the class?

00:03:04.060 --> 00:03:05.226
The class is somewhere here.

00:03:05.226 --> 00:03:06.470
The class is here.

00:03:06.470 --> 00:03:07.224
There you go.

00:03:07.224 --> 00:03:08.140
Now you got the class.

00:03:11.820 --> 00:03:12.390
There.

00:03:12.390 --> 00:03:13.110
Now you got the class.

00:03:13.110 --> 00:03:13.610
Happy?

00:03:13.610 --> 00:03:14.210
There.

00:03:14.210 --> 00:03:15.930
People think, oh, there's
no classes in Kotlin.

00:03:15.930 --> 00:03:16.560
Yes, there are.

00:03:16.560 --> 00:03:20.694
Anyway, so already cutting
down boilerplate code.

00:03:20.694 --> 00:03:21.360
What am I doing?

00:03:21.360 --> 00:03:26.046
Essentially here, I'm just
passing in optional parameters.

00:03:26.046 --> 00:03:26.670
Simple as that.

00:03:26.670 --> 00:03:28.290
Why do I have to
have all of this,

00:03:28.290 --> 00:03:30.832
with all of this code over and
over again if essentially, I'm

00:03:30.832 --> 00:03:33.415
doing the same thing, but with
different number of parameters.

00:03:33.415 --> 00:03:35.040
And then, of course,
I can call this,

00:03:35.040 --> 00:03:39.330
and I can say, for
example, val is here.

00:03:39.330 --> 00:03:40.770
We'll now create a class.

00:03:40.770 --> 00:03:44.310
By the way, val is something in
Kotlin, which means immutable,

00:03:44.310 --> 00:03:45.030
read only.

00:03:45.030 --> 00:03:46.650
It means that I
can't reassign that.

00:03:46.650 --> 00:03:49.530
If you want to reassign
something, you declare it var.

00:03:49.530 --> 00:03:51.210
My rule of thumb is don't do it.

00:03:51.210 --> 00:03:54.420
Just declare it as val
and work towards having

00:03:54.420 --> 00:03:56.100
read-only variables.

00:03:56.100 --> 00:03:59.970
And then I can do is
here, and print message,

00:03:59.970 --> 00:04:02.100
So I can pass in one parameter.

00:04:02.100 --> 00:04:04.890
I can pass in two parameters.

00:04:04.890 --> 00:04:09.730
I can pass in three parameters,

00:04:09.730 --> 00:04:12.534
And the good thing is that you
can see that this is actually--

00:04:12.534 --> 00:04:13.950
this is [? Intelliger ?]
giving me

00:04:13.950 --> 00:04:15.241
that the name of the parameter.

00:04:15.241 --> 00:04:18.540
But we actually have named
parameters in Kotlin too.

00:04:18.540 --> 00:04:20.550
So if I want to pass
in the suffix first,

00:04:20.550 --> 00:04:23.650
I could just put suffix,
and then pass in the suffix.

00:04:23.650 --> 00:04:26.950
And then here I would say the
prefix, and pass in the prefix.

00:04:26.950 --> 00:04:29.400
And then this would
become the actual message.

00:04:29.400 --> 00:04:30.900
I can alternate the
order in which I

00:04:30.900 --> 00:04:32.550
want to pass in the parameters.

00:04:32.550 --> 00:04:35.550
And this is useful, of course,
not only for alternating order,

00:04:35.550 --> 00:04:37.020
which why would
you want to do it?

00:04:37.020 --> 00:04:41.040
But anyway, but it's useful when
you have multiple functions,

00:04:41.040 --> 00:04:44.010
probably legacy that
has 200 parameters,

00:04:44.010 --> 00:04:46.297
and you're playing a
game of true and false.

00:04:46.297 --> 00:04:47.880
So you can start to
name those things.

00:04:47.880 --> 00:04:49.500
Or you could refactor.

00:04:49.500 --> 00:04:53.550
But why bother when you
can hack things together.

00:04:53.550 --> 00:04:55.855
Now Kotlin does have
classes, as I've shown you.

00:04:55.855 --> 00:04:56.730
I've created a class.

00:04:56.730 --> 00:04:59.490
And one of the typical
quintessential examples

00:04:59.490 --> 00:05:02.700
that we show is a class in Java.

00:05:02.700 --> 00:05:06.970
So let's say customer job,
customer type, ID type,

00:05:06.970 --> 00:05:12.420
customer Java, split vertically,
and let's show customer Kotlin.

00:05:12.420 --> 00:05:14.269
OK, there you go.

00:05:14.269 --> 00:05:16.560
Now, and then again, you're
going to say, oh, big deal.

00:05:16.560 --> 00:05:18.150
Any ID generates this for me.

00:05:18.150 --> 00:05:18.900
Yes, it does.

00:05:18.900 --> 00:05:21.326
But the ID doesn't
maintain it for you.

00:05:21.326 --> 00:05:22.950
And the ID doesn't
come and say to you,

00:05:22.950 --> 00:05:24.991
oh, don't look at that,
Hadi, because that's just

00:05:24.991 --> 00:05:27.960
boilerplate code that
I've generated for you.

00:05:27.960 --> 00:05:31.990
I don't know if someone's gone
and modified all of that code.

00:05:31.990 --> 00:05:34.980
So all of this,
essentially, is declared

00:05:34.980 --> 00:05:36.630
with a single line of code.

00:05:36.630 --> 00:05:40.170
And the data class over here,
when I add the data modifier

00:05:40.170 --> 00:05:42.060
to it, what essentially
that is doing

00:05:42.060 --> 00:05:44.550
is providing me with
some new functionality.

00:05:44.550 --> 00:05:48.350
Namely, it's giving me
the equals, the hash code,

00:05:48.350 --> 00:05:52.290
the to string, and the copy,
which we'll see in a moment.

00:05:52.290 --> 00:05:54.780
What you'll also notice here
is that essentially, I'm

00:05:54.780 --> 00:05:59.050
doing the whole property
declaration and constructor

00:05:59.050 --> 00:06:00.820
also in a single line.

00:06:00.820 --> 00:06:02.860
So here, I'm declaring
three properties.

00:06:02.860 --> 00:06:04.110
One of them is read-only.

00:06:04.110 --> 00:06:05.640
The other two are read-write.

00:06:05.640 --> 00:06:08.310
And that, in turn, is also
creating a constructor.

00:06:08.310 --> 00:06:10.740
That's the short syntax.

00:06:10.740 --> 00:06:13.020
You can also do this
in a longer syntax.

00:06:13.020 --> 00:06:15.420
One thing to notice, if you're
not familiar with Kotlin,

00:06:15.420 --> 00:06:17.610
is that we don't
have fields as such.

00:06:17.610 --> 00:06:19.200
We just have properties.

00:06:19.200 --> 00:06:21.660
And then you access these
properties with accessors.

00:06:21.660 --> 00:06:22.970
There's no get or set.

00:06:22.970 --> 00:06:25.770
Or there is, but it's
under the covers for you.

00:06:25.770 --> 00:06:31.290
When you talk Java to Kotlin,
you get the Java to Kotlin--

00:06:31.290 --> 00:06:32.190
Java to Kotlin.

00:06:32.190 --> 00:06:34.530
There you go, or
Kotlin to Java, you

00:06:34.530 --> 00:06:37.230
get the idiomatic
approach in each language.

00:06:37.230 --> 00:06:39.300
But if you're just--
you're working with Kotlin,

00:06:39.300 --> 00:06:40.750
you can just use them directly.

00:06:40.750 --> 00:06:43.380
So I can say, for
example, val customer

00:06:43.380 --> 00:06:45.870
equals customer Kotlin.

00:06:45.870 --> 00:06:49.740
And then this will be 1 a b.

00:06:49.740 --> 00:06:56.640
And then do customer.email
equals something.

00:06:56.640 --> 00:06:59.040
So a lot of boilerplate
code you're saving there.

00:06:59.040 --> 00:07:02.290
Now, one other thing that you
have is also the copy class.

00:07:02.290 --> 00:07:06.420
So here, you can see that I
have a data class contacts

00:07:06.420 --> 00:07:09.150
and then I have a list
of type email, which

00:07:09.150 --> 00:07:10.710
is in turn is a data class.

00:07:10.710 --> 00:07:12.691
And if you do a copy
contacts, this in turn

00:07:12.691 --> 00:07:14.190
is actually going
to do a deep copy.

00:07:14.190 --> 00:07:15.960
So it's going to copy
everything for you.

00:07:15.960 --> 00:07:18.120
So you're going to get all of
those different properties.

00:07:18.120 --> 00:07:19.770
And you can, in
fact, overwrite this.

00:07:19.770 --> 00:07:22.620
You can say, I want the
company name to be--

00:07:22.620 --> 00:07:25.230
when I copy, I want, for
example, the company name

00:07:25.230 --> 00:07:28.540
to be something else.

00:07:28.540 --> 00:07:30.429
And then it will
default the other ones

00:07:30.429 --> 00:07:31.470
to whatever the value is.

00:07:31.470 --> 00:07:33.136
So you can override
the values as you're

00:07:33.136 --> 00:07:36.240
doing the copy [INAUDIBLE].

00:07:36.240 --> 00:07:38.580
We use data classes,
as you know.

00:07:38.580 --> 00:07:39.900
We like data classes.

00:07:39.900 --> 00:07:42.510
Initially, we used
to have two pools.

00:07:42.510 --> 00:07:44.580
And we got rid of
them, because one

00:07:44.580 --> 00:07:48.330
of the key aspects of Kotlin
is to write maintainable code.

00:07:48.330 --> 00:07:51.210
Now, we can't guarantee that,
because we are developers.

00:07:51.210 --> 00:07:57.100
And we can take any language and
make it completely unreadable.

00:07:57.100 --> 00:08:00.480
And as Kevlin Henney recently
said, there's a difference.

00:08:00.480 --> 00:08:01.970
Every code is readable.

00:08:01.970 --> 00:08:06.150
The bigger issue is whether
it's comprehensible, which

00:08:06.150 --> 00:08:08.100
is where we basically struggle.

00:08:08.100 --> 00:08:11.660
But we do have
pairs and triples,

00:08:11.660 --> 00:08:13.550
So, for instance,
let's say that I have

00:08:13.550 --> 00:08:16.680
a function that returns pairs.

00:08:16.680 --> 00:08:19.430
So just basically,
I can just return

00:08:19.430 --> 00:08:21.440
pair of type string string.

00:08:21.440 --> 00:08:22.820
And we also have triples.

00:08:22.820 --> 00:08:26.660
So if you go beyond
triple, then we

00:08:26.660 --> 00:08:29.040
say for you to use a data class.

00:08:29.040 --> 00:08:35.330
So here, I could just
do pair something else.

00:08:35.330 --> 00:08:41.085
Now, if I call this
function, how do I

00:08:41.085 --> 00:08:42.085
access those properties?

00:08:42.085 --> 00:08:43.669
Well, the first
one is with first.

00:08:43.669 --> 00:08:46.640
And guess what the second
one is going to be?

00:08:46.640 --> 00:08:47.630
There you go.

00:08:47.630 --> 00:08:49.480
You're really
interactive, aren't you?

00:08:49.480 --> 00:08:52.680
Anyway, so the second one
is going to be second.

00:08:52.680 --> 00:08:54.530
Now, that kind of
sucks, because, hey,

00:08:54.530 --> 00:08:56.690
we're talking about
readability, comprehensibility.

00:08:56.690 --> 00:08:57.440
And what is first?

00:08:57.440 --> 00:08:58.430
What is second?

00:08:58.430 --> 00:09:01.400
So you have destructuring
of variables in Kotlin.

00:09:01.400 --> 00:09:05.390
So you can do, for
example, name and email,

00:09:05.390 --> 00:09:08.320
and then do this
as return pairs.

00:09:08.320 --> 00:09:12.980
And now I can access those
in a much more nicer way,

00:09:12.980 --> 00:09:15.710
giving me context and
meaning of what exactly

00:09:15.710 --> 00:09:17.090
it is that I'm accessing.

00:09:17.090 --> 00:09:19.250
So I could do now print email.

00:09:19.250 --> 00:09:21.530
And this destructuring
you get when

00:09:21.530 --> 00:09:23.056
you're working
with data classes,

00:09:23.056 --> 00:09:24.680
you get when you're
working with pairs,

00:09:24.680 --> 00:09:26.660
you get when you
work in with lambdas.

00:09:26.660 --> 00:09:28.440
And notice here
that it's saying,

00:09:28.440 --> 00:09:30.260
well, you're not
actually using name.

00:09:30.260 --> 00:09:33.450
So that's a hint that the
compiler is giving you,

00:09:33.450 --> 00:09:35.060
and the IDE is
surfacing for you.

00:09:35.060 --> 00:09:37.280
What you can do is also use
the underscore, and say,

00:09:37.280 --> 00:09:39.200
anything that I
don't use, I'll just

00:09:39.200 --> 00:09:41.600
use underscore for,
and then just get rid

00:09:41.600 --> 00:09:43.610
of all of those hints.

00:09:43.610 --> 00:09:45.920
But more importantly,
tell the developer

00:09:45.920 --> 00:09:50.510
that's reading this code that
this value is not important.

00:09:50.510 --> 00:09:52.100
And as I said,
this destructuring

00:09:52.100 --> 00:09:53.150
can work with anything.

00:09:53.150 --> 00:09:56.540
So, for instance, we've got
contacts or our email class.

00:09:56.540 --> 00:10:02.180
So I can say, this is the name,
name1, and this is the email1,

00:10:02.180 --> 00:10:05.630
and then do exactly
the same for email.

00:10:05.630 --> 00:10:08.960
So I could say
something and something.

00:10:08.960 --> 00:10:10.190
So it's not only with pairs.

00:10:10.190 --> 00:10:11.450
It also works with data classes.

00:10:11.450 --> 00:10:13.241
And it's basically
following the convention

00:10:13.241 --> 00:10:15.200
of the first parameter
is the first position,

00:10:15.200 --> 00:10:17.120
the second parameter
is the second position,

00:10:17.120 --> 00:10:20.160
so on and so forth.

00:10:20.160 --> 00:10:22.790
Where else do we try and
improve on the boilerplate code

00:10:22.790 --> 00:10:23.600
that you write?

00:10:23.600 --> 00:10:26.200
So how many of you
love design patterns?

00:10:26.200 --> 00:10:27.410
It's OK.

00:10:27.410 --> 00:10:28.820
Don't be ashamed.

00:10:28.820 --> 00:10:31.500
Raise your hands.

00:10:31.500 --> 00:10:33.940
Singleton, let's see.

00:10:33.940 --> 00:10:35.800
Singleton in Java.

00:10:35.800 --> 00:10:39.490
Now, this is a singleton in
Java, which is fantastic.

00:10:39.490 --> 00:10:41.680
Not advocating the
use of singletons,

00:10:41.680 --> 00:10:44.890
I'm just saying this
is a singleton in Java.

00:10:44.890 --> 00:10:48.730
And let's take a look at
the singleton in Kotlin.

00:10:48.730 --> 00:10:53.550
We'll go here, and we'll
do a singleton in Kotlin.

00:10:53.550 --> 00:10:56.090
That's a singleton in Kotlin,
because we essentially

00:10:56.090 --> 00:10:57.110
have objects.

00:10:57.110 --> 00:11:00.500
So much like in
normal languages,

00:11:00.500 --> 00:11:03.890
you have a class,
a type, and then

00:11:03.890 --> 00:11:05.750
you create an
instance of that type.

00:11:05.750 --> 00:11:08.900
In JavaScript, you
only have objects,

00:11:08.900 --> 00:11:10.880
and then you try
and mimic everything

00:11:10.880 --> 00:11:13.820
you learn from another
language, and bring classes

00:11:13.820 --> 00:11:14.810
into JavaScript.

00:11:14.810 --> 00:11:16.010
In Kotlin, we have both.

00:11:16.010 --> 00:11:19.700
We have objects, which just
represent a single value,

00:11:19.700 --> 00:11:21.440
and classes.

00:11:21.440 --> 00:11:23.370
So here, I can just
create an object,

00:11:23.370 --> 00:11:24.620
which is a single Kotlin.

00:11:24.620 --> 00:11:25.630
And it has a property.

00:11:25.630 --> 00:11:27.200
And, of course,
I can access this

00:11:27.200 --> 00:11:30.890
by just saying Singleton,
Kotlin, and property,

00:11:30.890 --> 00:11:32.030
and then assign a value.

00:11:32.030 --> 00:11:34.047
No, you don't assign a
value to global things.

00:11:34.047 --> 00:11:36.380
You don't have singletons
that you can change values on.

00:11:36.380 --> 00:11:37.670
That's a no-no.

00:11:37.670 --> 00:11:39.840
For read-only, though,
it's kind of nice.

00:11:39.840 --> 00:11:41.660
And notice that I'm
not advocating, again,

00:11:41.660 --> 00:11:44.839
saying oh, well, since Kotlin
makes singletons so easy,

00:11:44.839 --> 00:11:47.380
let me just create singletons
throughout my entire code base.

00:11:47.380 --> 00:11:48.770
Nope, not saying that either.

00:11:51.360 --> 00:11:52.190
What else?

00:11:52.190 --> 00:11:54.020
So one thing that
we added to Kotlin

00:11:54.020 --> 00:11:58.410
is the concept of a type alias,
So here, I have, for instance,

00:11:58.410 --> 00:12:02.030
a data class, and I have a name,
customer name, and an email.

00:12:02.030 --> 00:12:04.070
Now, notice the customer
name is actually

00:12:04.070 --> 00:12:06.710
the same thing as a string.

00:12:06.710 --> 00:12:09.320
But it is providing me
with more semantics.

00:12:09.320 --> 00:12:13.040
Here, I have-- and I've done
that using this thing over here

00:12:13.040 --> 00:12:17.180
called type alias
customer name to string,

00:12:17.180 --> 00:12:22.760
meaning that this property
is actually of type string.

00:12:22.760 --> 00:12:25.940
But to provide more meaning,
to provide more semantics,

00:12:25.940 --> 00:12:29.170
I'm using the name
customer name.

00:12:29.170 --> 00:12:29.933
But I can pass in.

00:12:29.933 --> 00:12:31.990
It will verify this
at runtimes at string,

00:12:31.990 --> 00:12:33.290
at compile times at string.

00:12:33.290 --> 00:12:37.010
You can pass string where
it's customer name, et cetera,

00:12:37.010 --> 00:12:39.590
Now, this comes in
useful, actually,

00:12:39.590 --> 00:12:41.350
sometimes combining
this type alias

00:12:41.350 --> 00:12:42.850
with something else,
which is called

00:12:42.850 --> 00:12:44.390
the deprecated annotations.

00:12:44.390 --> 00:12:46.080
And I'll show you
how this works.

00:12:46.080 --> 00:12:50.360
So let's say that I
have a class, customer,

00:12:50.360 --> 00:12:53.000
and we're going
to now come here.

00:12:53.000 --> 00:12:54.672
And I'm going to rename this.

00:12:54.672 --> 00:12:56.380
Well, actually, I'll
just comment it out.

00:13:00.027 --> 00:13:01.610
And what I've done
here is essentially

00:13:01.610 --> 00:13:03.650
created a deprecated
annotation that

00:13:03.650 --> 00:13:05.810
comes with Kotlin, that
you say a customer is now

00:13:05.810 --> 00:13:10.140
called awesome customer, and
replace with awesome customer.

00:13:10.140 --> 00:13:11.510
And this actually doesn't work.

00:13:11.510 --> 00:13:12.926
Eventually, it
will be implemented

00:13:12.926 --> 00:13:16.430
so that you can do Alt-Enter
and replace that in the IDE.

00:13:16.430 --> 00:13:18.260
And notice, that
now type alias, I'm

00:13:18.260 --> 00:13:22.430
saying customer is awesome
customer, So what happens here

00:13:22.430 --> 00:13:24.380
is that now when
I hover to this,

00:13:24.380 --> 00:13:26.227
it says awesome
customer is deprecated.

00:13:26.227 --> 00:13:27.560
I did that the wrong way around.

00:13:27.560 --> 00:13:29.990
Awesome customer is
deprecated, and you

00:13:29.990 --> 00:13:32.240
should use customer instead.

00:13:32.240 --> 00:13:33.650
Now, the good
thing about that is

00:13:33.650 --> 00:13:36.620
that this allows you to
refactor things and rename

00:13:36.620 --> 00:13:40.520
things without potentially
breaking people's codes.

00:13:40.520 --> 00:13:42.360
But then you're
probably thinking,

00:13:42.360 --> 00:13:46.070
why do I care about
breaking people's code?

00:13:46.070 --> 00:13:48.200
Let me just do that myself.

00:13:48.200 --> 00:13:52.520
So it is actually quite
useful in that sense.

00:13:52.520 --> 00:13:54.630
And we use it quite a bit.

00:13:54.630 --> 00:13:57.170
You can do a multiple
phase change.

00:13:57.170 --> 00:14:00.200
I'll rename something,
and then issue a warning.

00:14:00.200 --> 00:14:02.990
And then on the next one, I
will remove that, deprecate it,

00:14:02.990 --> 00:14:04.410
and away we go.

00:14:04.410 --> 00:14:06.710
And nobody can
complain because we

00:14:06.710 --> 00:14:08.540
don't complain as developers.

00:14:08.540 --> 00:14:11.720
So that was a joke.

00:14:11.720 --> 00:14:13.982
Here's another example.

00:14:13.982 --> 00:14:17.090
Of course, it's not funny
when you say that was a joke.

00:14:17.090 --> 00:14:19.310
So I have conditional
expressions,

00:14:19.310 --> 00:14:21.110
Kotlin conditional
expressions here.

00:14:21.110 --> 00:14:23.450
So for now, just let's
focus on this one.

00:14:23.450 --> 00:14:24.920
Let me actually close this one.

00:14:24.920 --> 00:14:26.960
And I have a string parameter.

00:14:26.960 --> 00:14:28.330
So I'm declaring the string.

00:14:28.330 --> 00:14:30.500
And then I'm doing if
rx length equals 0,

00:14:30.500 --> 00:14:31.550
assign a parameter to it.

00:14:31.550 --> 00:14:33.110
If not, whatever.

00:14:33.110 --> 00:14:37.070
I've got another case where
I'm returning a value.

00:14:37.070 --> 00:14:38.570
And then I've got
a switch statement

00:14:38.570 --> 00:14:41.550
where I'm saying, if it's
case one, if it's case two.

00:14:41.550 --> 00:14:45.470
If not, then if the value
is within a specific range,

00:14:45.470 --> 00:14:46.910
then do this, et cetera.

00:14:46.910 --> 00:14:47.510
Ignore that.

00:14:47.510 --> 00:14:48.740
And it's going to say,
oh, this is always

00:14:48.740 --> 00:14:49.823
going to be true or false.

00:14:49.823 --> 00:14:53.490
But for the case of this
demo, it doesn't matter.

00:14:53.490 --> 00:14:55.010
So what about Kotlin?

00:14:55.010 --> 00:14:57.660
Where do we kind of
try and improve here?

00:14:57.660 --> 00:14:59.450
Well, the first thing
that you can see

00:14:59.450 --> 00:15:04.620
is that an if and a when
in Kotlin is an expression.

00:15:04.620 --> 00:15:07.730
So I don't-- well, it can
be treated as an expression

00:15:07.730 --> 00:15:08.720
or as a statement.

00:15:08.720 --> 00:15:12.530
But I don't have to
explicitly declare a variable,

00:15:12.530 --> 00:15:15.680
assign that variable based
on the actual branch.

00:15:15.680 --> 00:15:19.270
I could just return that as
the result of the expression.

00:15:19.270 --> 00:15:21.230
This is a single
line of expression.

00:15:21.230 --> 00:15:23.870
If I have multiple
lines, curly braces,

00:15:23.870 --> 00:15:28.040
then the last line
of that branch

00:15:28.040 --> 00:15:30.030
is going to be the return value.

00:15:30.030 --> 00:15:33.320
So here, I'm doing
value can be 1, 20,

00:15:33.320 --> 00:15:35.240
or I can write
multiple statements.

00:15:35.240 --> 00:15:38.450
And then the last value is
going to be the return value.

00:15:38.450 --> 00:15:41.210
I could even return
a string here.

00:15:41.210 --> 00:15:42.890
But if I return a
string, the compiler

00:15:42.890 --> 00:15:45.050
is going to give me a
warning and say, well,

00:15:45.050 --> 00:15:48.000
conditional branch is
returning a type string.

00:15:48.000 --> 00:15:50.990
So I'm casting the
return type to any.

00:15:50.990 --> 00:15:53.330
Any is the top level
object in Kotlin,

00:15:53.330 --> 00:15:56.540
meaning that if you
want to, you can return

00:15:56.540 --> 00:15:58.340
a different type per branch.

00:15:58.340 --> 00:15:59.360
Why would you want to?

00:15:59.360 --> 00:16:02.370
I don't know, but you can do it.

00:16:02.370 --> 00:16:04.300
Well, there are
cases, obviously.

00:16:04.300 --> 00:16:09.050
Now in the when statements,
similar to a case, but we do

00:16:09.050 --> 00:16:10.910
allow a certain level
of pattern matching.

00:16:10.910 --> 00:16:12.620
So you can see
that I have one, I

00:16:12.620 --> 00:16:14.810
have two, which we
had in the Java case.

00:16:14.810 --> 00:16:18.500
Then I can have a bunch of
values, three, four, five.

00:16:18.500 --> 00:16:20.630
I can even check for
whether it's a type.

00:16:20.630 --> 00:16:22.220
I can even check
for whether it's

00:16:22.220 --> 00:16:25.340
an arrange and an else branch.

00:16:25.340 --> 00:16:28.600
I can even call a function,
and have the function calculate

00:16:28.600 --> 00:16:30.916
a value, and return whether
that's a true or false

00:16:30.916 --> 00:16:32.270
for that statement.

00:16:32.270 --> 00:16:33.650
Point being what?

00:16:33.650 --> 00:16:35.840
It is very similar
in code to what

00:16:35.840 --> 00:16:37.880
you've seen in Java,
difference being

00:16:37.880 --> 00:16:40.610
that it's saving
you a lot of pain

00:16:40.610 --> 00:16:42.180
when you're writing this code.

00:16:42.180 --> 00:16:45.440
It's allowing you to be more
concise, more expressive.

00:16:45.440 --> 00:16:47.610
And that is essentially
what Kotlin is about.

00:16:47.610 --> 00:16:50.420
It's not about a single
feature that you look at

00:16:50.420 --> 00:16:52.100
and say, OK, this is cool.

00:16:52.100 --> 00:16:53.810
But I can do this in Java.

00:16:53.810 --> 00:16:55.195
You can do everything in Java.

00:16:55.195 --> 00:16:58.190
And when I say Java, I mean you
can do everything in Assembly.

00:16:58.190 --> 00:17:00.637
How many of you here
program in Assembly?

00:17:00.637 --> 00:17:02.599
Oh, come on.

00:17:02.599 --> 00:17:03.140
Three people.

00:17:03.140 --> 00:17:04.540
Awesome.

00:17:04.540 --> 00:17:06.380
That's good.

00:17:06.380 --> 00:17:07.369
Not still, no?

00:17:07.369 --> 00:17:08.689
Well, yes, still?

00:17:08.689 --> 00:17:09.188
No?

00:17:09.188 --> 00:17:09.687
OK.

00:17:13.630 --> 00:17:17.319
Now another thing that we try
to help with is Java nulls.

00:17:17.319 --> 00:17:20.050
This is your typical
example of a Java null,

00:17:20.050 --> 00:17:22.960
If customer's not null, if
customer.getName is not null,

00:17:22.960 --> 00:17:26.380
if customer.getName starts with
blah, blah, blah, then do this.

00:17:26.380 --> 00:17:27.230
Do that.

00:17:27.230 --> 00:17:28.930
How do we solve this
problem in Kotlin?

00:17:28.930 --> 00:17:30.670
Well, we said we
don't have nulls.

00:17:30.670 --> 00:17:32.050
We do, but we don't.

00:17:32.050 --> 00:17:34.810
Well, we do, but
I'll tell you we--

00:17:34.810 --> 00:17:36.505
yes, anyway.

00:17:36.505 --> 00:17:41.120
So by default, we don't
have nullable types.

00:17:41.120 --> 00:17:44.950
So when you declare a type
in Kotlin, if I come here,

00:17:44.950 --> 00:17:52.060
and I say val my string
equals some value,

00:17:52.060 --> 00:17:56.290
and then I do my string equals
null, that's not going to work,

00:17:56.290 --> 00:17:59.080
because it says this
type is not nullable,

00:17:59.080 --> 00:18:02.620
If I initialize it to
null, then it will work.

00:18:02.620 --> 00:18:05.290
You can also do explicit
type declaration in Kotlin.

00:18:05.290 --> 00:18:08.377
But you normally don't, so
I can do string something.

00:18:08.377 --> 00:18:10.960
That, again, is going to give
an error because string does not

00:18:10.960 --> 00:18:11.740
nullable.

00:18:11.740 --> 00:18:14.300
And one day, I will
write something properly.

00:18:14.300 --> 00:18:18.800
Now, what I can do to make this
nullable is add a question mark

00:18:18.800 --> 00:18:21.580
and now say this is
actually now nullable,

00:18:21.580 --> 00:18:24.130
And so I can assign a
nullable type to it.

00:18:24.130 --> 00:18:25.380
Why would you want to do this?

00:18:25.380 --> 00:18:29.650
Again, try and move away
from nullable types.

00:18:29.650 --> 00:18:33.260
In Kotlin, by default, you
don't declare nullable types.

00:18:33.260 --> 00:18:37.300
However, one of the
purposes of creating Kotlin

00:18:37.300 --> 00:18:41.380
was to be able to interop with
all of the existing Java code

00:18:41.380 --> 00:18:43.390
that we have and you have.

00:18:43.390 --> 00:18:44.980
And when you're
interoping with Java,

00:18:44.980 --> 00:18:47.020
you're going to
face nullable types.

00:18:47.020 --> 00:18:49.930
So you need to have that
question mark there sometimes

00:18:49.930 --> 00:18:52.270
to be able to interop
with nullable types.

00:18:52.270 --> 00:18:54.490
So in the case of Kotlin,
what we try and do

00:18:54.490 --> 00:18:57.500
is make it a little
bit nicer to work with.

00:18:57.500 --> 00:19:01.580
So here, you see that basically
the same kind of code.

00:19:01.580 --> 00:19:04.150
In this case, I don't
have to do any checks,

00:19:04.150 --> 00:19:06.700
because it's a customer
Kotlin, and I'm

00:19:06.700 --> 00:19:09.700
saying that it's not nullable.

00:19:09.700 --> 00:19:13.330
In this case, however, given
that this is coming from Java,

00:19:13.330 --> 00:19:15.460
I can actually
explicitly say that this

00:19:15.460 --> 00:19:19.240
is going to be a nullable type
by adding the question mark.

00:19:19.240 --> 00:19:22.810
Since I say it's going to be
a nullable type, then Kotlin,

00:19:22.810 --> 00:19:27.820
I would have to do in line
of if customer is not null,

00:19:27.820 --> 00:19:31.420
then do something with it.

00:19:31.420 --> 00:19:35.830
You can do a much
shorter syntax with that

00:19:35.830 --> 00:19:37.420
by just using the
question mark here.

00:19:37.420 --> 00:19:39.545
So that's basically saying
if customer is not null,

00:19:39.545 --> 00:19:41.080
then if name is
not null, then it

00:19:41.080 --> 00:19:42.730
starts with blah, blah, blah.

00:19:42.730 --> 00:19:45.910
And if that equals
true, then do something,

00:19:45.910 --> 00:19:47.770
So when you're
working with Java,

00:19:47.770 --> 00:19:51.160
you have to decide whether the
type you're actually working

00:19:51.160 --> 00:19:52.720
with is nullable or not.

00:19:52.720 --> 00:19:55.870
I could actually remove
this and say, there you go.

00:19:55.870 --> 00:19:58.780
I now know that this
will never be null.

00:19:58.780 --> 00:20:00.850
So you can use the
not null annotations

00:20:00.850 --> 00:20:04.870
that different libraries
provide to kind of recognize

00:20:04.870 --> 00:20:07.330
whether that's going
to be nullable or not.

00:20:07.330 --> 00:20:12.400
What you can't do is remove
that and then get null reference

00:20:12.400 --> 00:20:14.560
exceptions at runtime,
and then say, well,

00:20:14.560 --> 00:20:17.130
didn't Kotlin say
that it removed null?

00:20:17.130 --> 00:20:20.080
No, because you are explicitly
saying that this is null.

00:20:20.080 --> 00:20:23.900
And as I always say, if you
really want to be brave,

00:20:23.900 --> 00:20:27.220
what you can also do is
declare this as nullable,

00:20:27.220 --> 00:20:28.630
and then do customer!!ID.

00:20:31.150 --> 00:20:32.770
And that means I don't care.

00:20:32.770 --> 00:20:34.930
I miss my null
reference exceptions.

00:20:34.930 --> 00:20:38.936
I just want you to
blow up at runtime.

00:20:38.936 --> 00:20:40.060
So you can do that as well.

00:20:40.060 --> 00:20:43.510
While you're at
that, don't start--

00:20:43.510 --> 00:20:47.140
this is one of the main
things that people fall into,

00:20:47.140 --> 00:20:48.175
the trap.

00:20:48.175 --> 00:20:50.610
When they start to pore
over their Java code,

00:20:50.610 --> 00:20:53.090
initially, they're like,
oh, well, this is null.

00:20:53.090 --> 00:20:53.830
What shall I do?

00:20:53.830 --> 00:20:54.730
Double exclamation.

00:20:54.730 --> 00:20:56.200
No, you don't.

00:20:56.200 --> 00:20:59.320
Not having nulls in the
language is actually

00:20:59.320 --> 00:21:03.760
forcing you to think more
about nulls, essentially,

00:21:03.760 --> 00:21:05.932
because it's not the happy path.

00:21:05.932 --> 00:21:07.390
Normally, when we
do error control,

00:21:07.390 --> 00:21:09.390
it's like, well, if it's
not null, I'll do this.

00:21:09.390 --> 00:21:11.470
And if it's null,
then I'll pretend

00:21:11.470 --> 00:21:15.170
that nobody saw anything,
Now it's saying,

00:21:15.170 --> 00:21:16.650
what happens if it's not null?

00:21:16.650 --> 00:21:19.150
Oh, I don't know.

00:21:19.150 --> 00:21:20.590
So what else?

00:21:20.590 --> 00:21:24.460
One of the things in Kotlin
is extension functions,

00:21:24.460 --> 00:21:31.300
So what I can essentially
do is do fun string Krakow.

00:21:31.300 --> 00:21:36.100
And then what that
will do is essentially

00:21:36.100 --> 00:21:43.030
print line Krakow
is great, So now I

00:21:43.030 --> 00:21:51.520
can say Poland and
Krakow are great,

00:21:51.520 --> 00:21:56.170
So I've just added a new
function to Krakow are great,

00:21:56.170 --> 00:21:57.550
It's only done Krakow.

00:21:57.550 --> 00:21:58.150
Why?

00:21:58.150 --> 00:21:59.950
Because I've written
Krakow are great.

00:21:59.950 --> 00:22:02.740
Now what I could do
is actually reference.

00:22:02.740 --> 00:22:05.320
This is essentially what it's
doing is adding an extension

00:22:05.320 --> 00:22:07.340
function to the type string.

00:22:07.340 --> 00:22:11.740
And I can extend any
type in Kotlin or Java,

00:22:11.740 --> 00:22:15.880
So you're thinking, well,
why would I want to do this?

00:22:15.880 --> 00:22:18.340
Again, to make code expressive.

00:22:18.340 --> 00:22:21.930
Now I normally wouldn't add
a function in my codebase

00:22:21.930 --> 00:22:22.900
called Krakow.

00:22:22.900 --> 00:22:25.690
We can do something
like two camel

00:22:25.690 --> 00:22:30.460
case with inverted
colons German style,

00:22:30.460 --> 00:22:33.910
I could do something
like that, because you

00:22:33.910 --> 00:22:35.230
know that in Germany, they do.

00:22:35.230 --> 00:22:36.550
They invert things.

00:22:36.550 --> 00:22:40.900
So this gives you,
again, expressivity.

00:22:40.900 --> 00:22:43.720
I don't have to take a string
class, inherit from it,

00:22:43.720 --> 00:22:48.520
add a new method to be able
to just add one more function.

00:22:48.520 --> 00:22:52.429
This is where the beauty of
this extension functions are.

00:22:52.429 --> 00:22:54.970
And if you actually look at the
standard library, which we'll

00:22:54.970 --> 00:22:57.610
see in a moment, most of
the functionality you get

00:22:57.610 --> 00:23:02.210
are in fact extension
functions over generic types,

00:23:02.210 --> 00:23:04.750
meaning that you get a
whole bunch of functionality

00:23:04.750 --> 00:23:07.050
independently of
the type of things

00:23:07.050 --> 00:23:08.800
you use, whether it's
string, whether it's

00:23:08.800 --> 00:23:11.427
collections, et cetera.

00:23:11.427 --> 00:23:13.510
And we'll see that when
we take a look at lambdas.

00:23:13.510 --> 00:23:16.480
Now talking about
lambdas, lambda in Java.

00:23:16.480 --> 00:23:18.880
I have a lambdas in Java.

00:23:18.880 --> 00:23:22.540
If I want to declare something
in Java that is a higher order

00:23:22.540 --> 00:23:26.110
function, I say, well,
I can do it in two ways.

00:23:26.110 --> 00:23:29.770
I can define an interface
that takes two parameters.

00:23:29.770 --> 00:23:34.300
Or I can do something like a
by consumer, or a by function,

00:23:34.300 --> 00:23:38.290
or a whatever, and then have
all of these different types,

00:23:38.290 --> 00:23:41.390
and then pass in the
parameters that I need.

00:23:41.390 --> 00:23:44.107
And then the IDE will say
to me, OK, this is a lambda.

00:23:44.107 --> 00:23:45.940
You don't have to
implement a route handler.

00:23:45.940 --> 00:23:49.780
You can just pass this in as
a lambda, just like I'm using,

00:23:49.780 --> 00:23:51.550
like the using listener in Java.

00:23:51.550 --> 00:23:53.680
Here I'm creating
a new instance.

00:23:53.680 --> 00:23:57.550
But I can do Alt-Enter and
replace that with lambda.

00:23:57.550 --> 00:24:00.550
You can do pretty much
the same thing in Kotlin,

00:24:00.550 --> 00:24:03.100
except you don't have to have
the explicit type declaration.

00:24:03.100 --> 00:24:05.110
You can just pass
in lambda like that.

00:24:05.110 --> 00:24:08.370
And you'll see that this is
omitting the brackets, which

00:24:08.370 --> 00:24:09.580
we'll see in a moment.

00:24:09.580 --> 00:24:11.860
But how do I work with
lambdas in Kotlin,

00:24:11.860 --> 00:24:14.080
and how do I declare
higher order functions?

00:24:14.080 --> 00:24:17.690
Essentially, we're using
always the same syntax.

00:24:17.690 --> 00:24:20.230
I don't have to know about by
function or things like that.

00:24:20.230 --> 00:24:23.440
I just say int, int
returns int, meaning

00:24:23.440 --> 00:24:25.960
that this is a function
that takes two integers,

00:24:25.960 --> 00:24:27.730
and returns an integer.

00:24:27.730 --> 00:24:29.530
And then I'm invoking
that function.

00:24:29.530 --> 00:24:34.081
Here is a function that takes
no parameters, and returns void,

00:24:34.081 --> 00:24:35.580
So technically,
it's not a function.

00:24:35.580 --> 00:24:36.163
It's a method.

00:24:36.163 --> 00:24:41.500
But anyway, so always following
the same syntax, always.

00:24:41.500 --> 00:24:44.020
And now, it clearly says to
me, oh, this is a lambda.

00:24:44.020 --> 00:24:45.480
I can pass in a lambda.

00:24:45.480 --> 00:24:48.030
And when you want to invoke
it, you do higher order,

00:24:48.030 --> 00:24:49.780
and you actually pass
in the lambda, which

00:24:49.780 --> 00:24:55.270
we use this syntax, which is
the same if the last parameter

00:24:55.270 --> 00:24:57.250
to have a function
is another function,

00:24:57.250 --> 00:24:59.890
then I can omit
the curly braces,

00:24:59.890 --> 00:25:02.860
And then what I can do is make
this multi-line, which will

00:25:02.860 --> 00:25:04.400
make it a little bit nicer.

00:25:04.400 --> 00:25:05.230
Then you say, why?

00:25:05.230 --> 00:25:07.180
Well, then I can do
something like this.

00:25:07.180 --> 00:25:12.580
I can create a function called
using, for instance, object,

00:25:12.580 --> 00:25:16.500
which is closable,
and then have a body--

00:25:16.500 --> 00:25:21.160
bloody-- no, body, that
basically, what it's doing

00:25:21.160 --> 00:25:24.310
is going to invoke the body.

00:25:24.310 --> 00:25:28.210
And then I'll do
finally object close.

00:25:28.210 --> 00:25:32.770
And then what I could do--
imagine that I have a val

00:25:32.770 --> 00:25:36.430
closable thing here, whatever.

00:25:36.430 --> 00:25:39.490
We'll close it, whatever.

00:25:39.490 --> 00:25:41.230
Imagine that that works.

00:25:41.230 --> 00:25:45.340
And then I could
do using closable,

00:25:45.340 --> 00:25:48.760
and then not have to worry
about that resource being freed.

00:25:48.760 --> 00:25:52.480
Using as a statement that we
have in C# and you have similar

00:25:52.480 --> 00:25:55.990
[? try ?] with resources, but
essentially giving you that

00:25:55.990 --> 00:26:00.400
fluidity of feeling as if
you are adding functionality

00:26:00.400 --> 00:26:03.010
to the language in a way that
is very expressive and easy

00:26:03.010 --> 00:26:06.340
to read and understand,

00:26:06.340 --> 00:26:09.970
And all of these functions,
as I mentioned, we have.

00:26:09.970 --> 00:26:13.556
When working with functions,
all of these things

00:26:13.556 --> 00:26:14.930
are part of the
standard library.

00:26:14.930 --> 00:26:17.350
So, by the way, this is how
you create a very nice--

00:26:17.350 --> 00:26:19.430
easily, you create
a list of numbers.

00:26:19.430 --> 00:26:21.190
And Kotlin is one to 100.

00:26:21.190 --> 00:26:25.330
And then on the numbers, I
can do things like filter.

00:26:25.330 --> 00:26:27.760
It is less than 100.

00:26:27.760 --> 00:26:30.490
So it is following the
same syntax as Groovy,

00:26:30.490 --> 00:26:33.130
saying that if the function
that I'm passing in

00:26:33.130 --> 00:26:36.040
is a single parameter, I
don't have to explicitly name

00:26:36.040 --> 00:26:37.070
that parameter.

00:26:37.070 --> 00:26:42.250
So instead of doing
something like x, and then x

00:26:42.250 --> 00:26:46.420
is less than 100, I can
actually convert that

00:26:46.420 --> 00:26:50.120
into using implicit.

00:26:50.120 --> 00:26:51.560
And then I can chain these.

00:26:51.560 --> 00:26:58.790
Map to it div 100,
or what have you,

00:26:58.790 --> 00:27:00.960
So these functions,
as I mentioned,

00:27:00.960 --> 00:27:03.200
they're basically part
of the standard library.

00:27:03.200 --> 00:27:05.720
You can see that they're
extension functions on interval

00:27:05.720 --> 00:27:06.260
of t.

00:27:06.260 --> 00:27:07.940
So I have all of
this functionality

00:27:07.940 --> 00:27:10.700
for all the different types of
collections that I want to use.

00:27:10.700 --> 00:27:13.370
And Kotlin doesn't provide
right now its own collections.

00:27:13.370 --> 00:27:15.770
It basically provides
a set of interfaces

00:27:15.770 --> 00:27:18.200
on top of Java's
collections, by default,

00:27:18.200 --> 00:27:20.090
moving towards immutable.

00:27:20.090 --> 00:27:23.990
So when I do, for
instance, val customers

00:27:23.990 --> 00:27:27.530
equals list of, and
then a customer Kotlin,

00:27:27.530 --> 00:27:30.590
that is going to create an
immutable customer for me

00:27:30.590 --> 00:27:31.190
in Kotlin.

00:27:31.190 --> 00:27:33.830
And I can add a second
one, customer Kotlin,

00:27:33.830 --> 00:27:37.850
and then get
whatever I want here.

00:27:37.850 --> 00:27:40.580
One other thing,
difference with Java,

00:27:40.580 --> 00:27:45.380
is that in Java, you would have
the Java streams over here,

00:27:45.380 --> 00:27:46.820
streams in Java.

00:27:46.820 --> 00:27:50.660
So the equivalent of
what I did is 1 to 100

00:27:50.660 --> 00:27:54.020
is in stream, in
stream range, 1 to 100.

00:27:54.020 --> 00:27:57.260
The difference is that this
in Kotlin, all of these lists

00:27:57.260 --> 00:27:59.330
are equally evaluated.

00:27:59.330 --> 00:28:01.850
If you want to do lazy
evaluation, then what you do

00:28:01.850 --> 00:28:03.580
is you just write ask sequence.

00:28:03.580 --> 00:28:05.840
And you can do that
to any collection.

00:28:05.840 --> 00:28:07.720
And if you want to
do it to something

00:28:07.720 --> 00:28:10.220
a little bit more complex than
a collection, what you can do

00:28:10.220 --> 00:28:13.190
is use the top level function,
generate sequence, and then

00:28:13.190 --> 00:28:15.980
here, pass in a C,
and then on this,

00:28:15.980 --> 00:28:18.940
basically generate the code that
you want to, and then on that,

00:28:18.940 --> 00:28:21.890
map it to, or filter it--

00:28:24.520 --> 00:28:26.290
it is less than 100--

00:28:26.290 --> 00:28:30.170
and then for each, and then
here, print line it, et cetera.

00:28:30.170 --> 00:28:34.630
Chain those together,

00:28:34.630 --> 00:28:38.200
One other thing that we've
tried to-- again, focusing on it

00:28:38.200 --> 00:28:42.730
is just more compact, more
concise, easier to read.

00:28:42.730 --> 00:28:45.310
Another thing that we
have, which is nice,

00:28:45.310 --> 00:28:48.880
is the return types.

00:28:48.880 --> 00:28:52.270
The return types are a way of
implementing algebraic data

00:28:52.270 --> 00:28:55.990
types, which is useful,
where you essentially

00:28:55.990 --> 00:28:59.320
say that a type, a
function, for instance,

00:28:59.320 --> 00:29:01.090
is returning one
type or another.

00:29:01.090 --> 00:29:02.740
A type can be one
type or another.

00:29:02.740 --> 00:29:04.540
The way that we
represent that in Kotlin

00:29:04.540 --> 00:29:07.330
is essentially through
a hierarchy of classes.

00:29:07.330 --> 00:29:09.910
But then what we do is add
the sealed modifier, which

00:29:09.910 --> 00:29:12.760
essentially means that
this hierarchy is closed,

00:29:12.760 --> 00:29:17.980
meaning that nobody else can
ever inherit from response,

00:29:17.980 --> 00:29:19.960
And these are inside.

00:29:19.960 --> 00:29:21.820
I can actually take
them outside, and then

00:29:21.820 --> 00:29:28.120
have something like failure,
success, and response,

00:29:28.120 --> 00:29:32.114
and then get rid of
all of these things.

00:29:32.114 --> 00:29:34.030
And notice-- I don't
know if you see it there,

00:29:34.030 --> 00:29:35.931
but this has gone green.

00:29:35.931 --> 00:29:37.930
This has gone green because
that's another thing

00:29:37.930 --> 00:29:41.260
that we have in Kotlin, which is
smart class, which essentially

00:29:41.260 --> 00:29:45.520
means save me having to type
things over and over again.

00:29:45.520 --> 00:29:48.250
And instead of casting
this to type success,

00:29:48.250 --> 00:29:51.220
I can essentially just
assume that it is success,

00:29:51.220 --> 00:29:53.177
because the compiler
has done that for me.

00:29:53.177 --> 00:29:55.510
So these are some of the
things that Kotlin provides you

00:29:55.510 --> 00:30:00.300
in order to be able to work more
concisely, and more fluently,

00:30:00.300 --> 00:30:03.100
and more rapidly, and more fun.

00:30:03.100 --> 00:30:04.030
Thank you.

00:30:04.030 --> 00:30:05.530
[APPLAUSE]

00:30:05.530 --> 00:30:08.280
[UPBEAT MUSIC PLAYING]

