WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.826
[MUSIC PLAYING]

00:00:04.710 --> 00:00:06.130
CLARA BAYARRI: Good afternoon!

00:00:06.130 --> 00:00:08.990
Welcome to Best Practices
for Text on Android.

00:00:08.990 --> 00:00:10.910
My name is Clara Bayarri,
and I'm a tech lead

00:00:10.910 --> 00:00:12.020
on the Android Tool Kit team.

00:00:12.020 --> 00:00:13.580
FLORINA MUNTENESCU:
I'm Florina Muntenescu,

00:00:13.580 --> 00:00:15.370
and I'm an Android
developer advocate.

00:00:15.370 --> 00:00:19.250
SIYAMED SINIR: Siyamed Sinir,
tech lead for Android Text.

00:00:19.250 --> 00:00:22.010
CLARA BAYARRI: So why are
we giving a talk about text?

00:00:22.010 --> 00:00:24.599
Well, it turns out text is
a major part of your app.

00:00:24.599 --> 00:00:25.640
It's part of your design.

00:00:25.640 --> 00:00:26.765
It's part of your branding.

00:00:26.765 --> 00:00:27.830
It's part of who you are.

00:00:27.830 --> 00:00:30.920
And it is the major thing that
your users will be consuming.

00:00:30.920 --> 00:00:34.160
It is front-front, the first
thing that your users read,

00:00:34.160 --> 00:00:36.470
and the thing that will
mostly affect readability,

00:00:36.470 --> 00:00:39.260
accessibility,
usability, all of that.

00:00:39.260 --> 00:00:41.300
On top of that, the
Android Text Stack

00:00:41.300 --> 00:00:44.050
is responsible for
emoji, which we all love.

00:00:44.050 --> 00:00:46.884
But all of this obviously
comes at a cost.

00:00:46.884 --> 00:00:48.800
So there's a bunch of
performance implications

00:00:48.800 --> 00:00:51.071
related to text that we
want you to be aware of.

00:00:51.071 --> 00:00:52.820
So today we're going
to go through a bunch

00:00:52.820 --> 00:00:56.060
of best practices and
things that you should know.

00:00:56.060 --> 00:00:57.710
Before we can do
that, let's talk

00:00:57.710 --> 00:00:59.030
a bit about the architecture.

00:00:59.030 --> 00:01:02.749
We want to explain how the tech
stack is fitted within Android,

00:01:02.749 --> 00:01:04.790
so that you can better
than understand what we're

00:01:04.790 --> 00:01:07.000
going to talk about later.

00:01:07.000 --> 00:01:10.050
The text stack on Android
is split into two parts.

00:01:10.050 --> 00:01:13.780
There's Java code, and then
there's native, or C++ code.

00:01:13.780 --> 00:01:15.430
At the very top
of the Java layer,

00:01:15.430 --> 00:01:17.263
you will find the thing
that you're probably

00:01:17.263 --> 00:01:19.822
most familiar with, which
is text view and edit text.

00:01:19.822 --> 00:01:22.030
These are widgets that
provide text functionality out

00:01:22.030 --> 00:01:24.142
of the box and do
everything for you.

00:01:24.142 --> 00:01:25.600
If you have custom
views, where you

00:01:25.600 --> 00:01:26.920
don't want to use our
widget, then you're

00:01:26.920 --> 00:01:28.750
probably using the
second layer, which

00:01:28.750 --> 00:01:30.780
is layout paint in Canvas.

00:01:30.780 --> 00:01:33.130
This class is in Java
will help you lay out text

00:01:33.130 --> 00:01:36.140
and render it without
actually using our widget.

00:01:36.140 --> 00:01:39.020
Once we get into the native
part the very first layer

00:01:39.020 --> 00:01:40.970
is a library we call Minikin.

00:01:40.970 --> 00:01:43.790
Minikin helps us do word
measurement, line breaking,

00:01:43.790 --> 00:01:44.900
and hyphenation.

00:01:44.900 --> 00:01:47.750
And it is our first point
of contact with C++.

00:01:47.750 --> 00:01:50.750
Below that, there's a bunch of
libraries we use to help us,

00:01:50.750 --> 00:01:54.290
ICU, which deals with
Unicode, HarfBuzz, which

00:01:54.290 --> 00:01:57.320
does tech shaping
for us, FreeType

00:01:57.320 --> 00:02:00.050
which generates bitmaps
for all of the Gifs,

00:02:00.050 --> 00:02:03.140
and finally Skia, which
is our graphics engine.

00:02:03.140 --> 00:02:05.270
Today, we're going to
focus on the top three,

00:02:05.270 --> 00:02:07.400
as these are the layers
that the Android team owns,

00:02:07.400 --> 00:02:12.550
and the one we can provide most
best practices and hints into.

00:02:12.550 --> 00:02:15.660
SIYAMED SINIR: Minikin lies at
the core of Android Text Stack

00:02:15.660 --> 00:02:18.000
and is implemented in C++.

00:02:18.000 --> 00:02:21.000
Its main responsibilities
our text layout, measurement,

00:02:21.000 --> 00:02:22.590
and line breaking.

00:02:22.590 --> 00:02:24.975
It is important to understand
what parts are implemented

00:02:24.975 --> 00:02:27.990
in Minikin versus
Java, as that defines

00:02:27.990 --> 00:02:31.050
which features we can backboard
using support library, which

00:02:31.050 --> 00:02:33.960
doesn't allow native code.

00:02:33.960 --> 00:02:35.700
Let's start with
text measurement.

00:02:35.700 --> 00:02:38.160
If you provide a string
like this to Minikin,

00:02:38.160 --> 00:02:40.430
first it tests to
identify the glyphs.

00:02:40.430 --> 00:02:42.990
Glyph is a representation
of a character.

00:02:42.990 --> 00:02:45.587
And you can think of it
as the image to be drawn.

00:02:45.587 --> 00:02:47.670
However, the correct
[INAUDIBLE] of glyph matching

00:02:47.670 --> 00:02:49.380
is not always one to one.

00:02:49.380 --> 00:02:54.000
Here, we have three letters,
FFI matching a single glyph.

00:02:54.000 --> 00:02:56.670
Glyphs can also be found
in different fonts, which

00:02:56.670 --> 00:02:59.680
is the case with the Japanese
character in the example.

00:02:59.680 --> 00:03:01.710
This is called the
font fallback chain.

00:03:01.710 --> 00:03:03.780
Once all the glyphs
are identified,

00:03:03.780 --> 00:03:05.640
the system can
position them together

00:03:05.640 --> 00:03:07.110
to have the final look.

00:03:07.110 --> 00:03:09.840
However at this point,
positioning is not always

00:03:09.840 --> 00:03:11.940
putting the glyphs
side by side, which

00:03:11.940 --> 00:03:15.850
is the case with the
letter e and acute accent.

00:03:15.850 --> 00:03:18.230
If you provide a longer
string, Minikin first

00:03:18.230 --> 00:03:19.720
divide it into words.

00:03:19.720 --> 00:03:22.400
And for each word, it
does the measurement.

00:03:22.400 --> 00:03:25.220
The result of this measurement
is added into a cache

00:03:25.220 --> 00:03:27.860
so that if the system comes
across with the same word

00:03:27.860 --> 00:03:30.350
again, it can raise
the computed value.

00:03:30.350 --> 00:03:32.810
This is a system wide
LRU cache, and has

00:03:32.810 --> 00:03:36.870
a fixed size of 5,000 items.

00:03:36.870 --> 00:03:39.710
Then the string is wider than
the array test [INAUDIBLE]

00:03:39.710 --> 00:03:42.140
Minikin has to do a line break.

00:03:42.140 --> 00:03:45.260
In the simplest case, this is
putting the boxes side by side

00:03:45.260 --> 00:03:47.420
until the boundary is
reached, and then moving

00:03:47.420 --> 00:03:48.950
to the next line.

00:03:48.950 --> 00:03:52.280
The behavior is controlled with
the break strategy attribute.

00:03:52.280 --> 00:03:55.250
And if you were to switch
from simple to balanced here,

00:03:55.250 --> 00:03:57.950
Minikin will distribute the
[INAUDIBLE] among the lines

00:03:57.950 --> 00:04:00.110
to have better text element.

00:04:00.110 --> 00:04:02.090
The default value
is high quality,

00:04:02.090 --> 00:04:04.010
which is very
similar to balanced,

00:04:04.010 --> 00:04:07.730
except a few subtle differences,
one of them being hyphenation

00:04:07.730 --> 00:04:10.200
for the last line.

00:04:10.200 --> 00:04:13.290
Hyphenation improves the
alignment of the text

00:04:13.290 --> 00:04:17.250
and the use of whitespace, and
it gets more and more important

00:04:17.250 --> 00:04:19.390
as the line width gets shorter.

00:04:19.390 --> 00:04:21.300
Although, this
comes with a cost.

00:04:21.300 --> 00:04:23.520
The cost arises
because now the system

00:04:23.520 --> 00:04:25.580
has to measure more
words and it has

00:04:25.580 --> 00:04:29.762
to compare more configurations
for an optimum solution.

00:04:29.762 --> 00:04:32.640
After Android P,
enabling hyphenation

00:04:32.640 --> 00:04:34.740
is 2 and 1/2 times
more expensive

00:04:34.740 --> 00:04:36.990
than the disabled state.

00:04:36.990 --> 00:04:40.660
On Android P we improved the
simple break strategy case.

00:04:40.660 --> 00:04:42.300
However, the default
configuration

00:04:42.300 --> 00:04:45.410
still has the same cost.

00:04:45.410 --> 00:04:49.430
Another thing that affects
hyphenations the locale.

00:04:49.430 --> 00:04:52.840
In this example, we have a
device in the English locale,

00:04:52.840 --> 00:04:54.830
and two example strings.

00:04:54.830 --> 00:04:57.230
One of them is not
hyphenated correctly,

00:04:57.230 --> 00:04:59.810
and the other one the
last use the right glyph

00:04:59.810 --> 00:05:01.710
for the Japanese text.

00:05:01.710 --> 00:05:04.280
This will mostly happen
for dynamically loaded text

00:05:04.280 --> 00:05:07.180
such as these things
loaded from network.

00:05:07.180 --> 00:05:09.080
And it happens because
the system is not

00:05:09.080 --> 00:05:11.190
aware of the languages
of those strings.

00:05:11.190 --> 00:05:15.070
To fix this, we have to tell the
system about the language using

00:05:15.070 --> 00:05:17.850
the setTextLocale function.

00:05:17.850 --> 00:05:20.800
If the string contains
multiple languages,

00:05:20.800 --> 00:05:24.180
you can use LocaleSpan to mark
different parts of the word

00:05:24.180 --> 00:05:25.080
string.

00:05:25.080 --> 00:05:28.140
However, keep in mind that
the number of locale spans

00:05:28.140 --> 00:05:31.230
affects the performance
of the text layout.

00:05:31.230 --> 00:05:33.230
FLORINA MUNTENESCU: One
of the most common tasks

00:05:33.230 --> 00:05:36.380
when working with
text is text styling.

00:05:36.380 --> 00:05:38.360
So usually we would start
working with the text

00:05:38.360 --> 00:05:42.740
attributes and set text
excise, text color, and font.

00:05:42.740 --> 00:05:46.730
So we call this a single style
because all of these attributes

00:05:46.730 --> 00:05:50.000
effect the entire text
from the text field.

00:05:50.000 --> 00:05:52.564
But usually for the
designer, this is not enough.

00:05:52.564 --> 00:05:54.230
And they will want
to style specifically

00:05:54.230 --> 00:05:56.970
one word or one paragraph.

00:05:56.970 --> 00:06:01.660
So what they want is to apply a
multiple style to the same text

00:06:01.660 --> 00:06:02.900
block.

00:06:02.900 --> 00:06:06.710
So in order to achieve this
in Android we work with spans.

00:06:06.710 --> 00:06:09.440
Spans our markup objects
that can be attached to text

00:06:09.440 --> 00:06:12.470
from a start, tone, and index.

00:06:12.470 --> 00:06:15.980
And spans can be categorized
into character and paragraph

00:06:15.980 --> 00:06:19.730
spans, depending on whether they
apply to only a few characters

00:06:19.730 --> 00:06:22.100
or to entire paragraphs.

00:06:22.100 --> 00:06:25.160
And then characters spans
can be split into appearance

00:06:25.160 --> 00:06:26.740
and metric affecting.

00:06:26.740 --> 00:06:28.320
And the difference
between them lies

00:06:28.320 --> 00:06:31.340
in the method that needs to
be called on the text view

00:06:31.340 --> 00:06:33.920
in order to render the slide.

00:06:33.920 --> 00:06:38.520
So appearance affecting spans
require a redraw to be called,

00:06:38.520 --> 00:06:41.210
whereas metric
affecting spans require

00:06:41.210 --> 00:06:44.450
both a remeasure and a redraw.

00:06:44.450 --> 00:06:46.070
Let's see an example.

00:06:46.070 --> 00:06:48.920
So let's say that we need
to style a code block.

00:06:48.920 --> 00:06:50.960
So in order to do
this, first we would

00:06:50.960 --> 00:06:52.640
change the background color.

00:06:52.640 --> 00:06:55.820
So for this, we would use
a background color span.

00:06:55.820 --> 00:06:59.150
This doesn't change
the metric of the text.

00:06:59.150 --> 00:07:02.330
So this means this is an
appearance affecting span.

00:07:02.330 --> 00:07:04.730
But we also need
to change the font.

00:07:04.730 --> 00:07:09.520
So for this, we would
use typeface span.

00:07:09.520 --> 00:07:12.740
But because fonts also
change the size of the text,

00:07:12.740 --> 00:07:16.060
this is a metrics
affecting span.

00:07:16.060 --> 00:07:18.620
To style blocks of
text by, for example,

00:07:18.620 --> 00:07:20.590
changing the layout
margin or drawing

00:07:20.590 --> 00:07:24.640
a bullet in front of the
text, would use a bullet span.

00:07:24.640 --> 00:07:27.490
So paragraph spans,
like the bullet span,

00:07:27.490 --> 00:07:30.040
have to be attached from the
beginning of the paragraph,

00:07:30.040 --> 00:07:33.144
and affect the entire
text of the paragraph.

00:07:33.144 --> 00:07:34.810
The thing is that if
you don't attach it

00:07:34.810 --> 00:07:37.210
from the beginning of the
paragraph, well, chances are,

00:07:37.210 --> 00:07:40.150
you'll lose the
styling completely.

00:07:40.150 --> 00:07:42.730
So in the framework
we define a series

00:07:42.730 --> 00:07:45.370
of interfaces and
abstract classes.

00:07:45.370 --> 00:07:47.140
And under the
hood, the framework

00:07:47.140 --> 00:07:49.390
checks for instances
of these classes,

00:07:49.390 --> 00:07:53.000
and then triggers different
actions depending on them.

00:07:53.000 --> 00:07:56.300
But actually what
makes spans so powerful

00:07:56.300 --> 00:07:59.300
is the fact that they give you
access to things like the text

00:07:59.300 --> 00:08:03.560
paints or the canvas, in the
case of some paragraph's spans.

00:08:03.560 --> 00:08:06.050
So this means that you can
pretty much handle everything

00:08:06.050 --> 00:08:08.750
you need in terms of text.

00:08:08.750 --> 00:08:11.390
So first of all,
whenever you need a span,

00:08:11.390 --> 00:08:13.880
check the ones that are
available in the framework.

00:08:13.880 --> 00:08:19.020
Because they cover most
of the common use cases.

00:08:19.020 --> 00:08:20.620
But if you go back
to our example,

00:08:20.620 --> 00:08:24.210
we see that the typeface span
only gets a typeface starting

00:08:24.210 --> 00:08:26.700
with Android P. So
this means that if we

00:08:26.700 --> 00:08:29.460
want to support free
P devices, we want

00:08:29.460 --> 00:08:32.100
to create our own custom span.

00:08:32.100 --> 00:08:35.860
So to do this, we would expand
from metric affecting span.

00:08:35.860 --> 00:08:38.580
And this class gives us
access to two methods.

00:08:38.580 --> 00:08:40.845
To update measure
state, which is called

00:08:40.845 --> 00:08:43.140
when textView
onMeasure is called,

00:08:43.140 --> 00:08:46.830
and update draw state, which is
called when the textView onDraw

00:08:46.830 --> 00:08:48.300
method is called.

00:08:48.300 --> 00:08:51.750
And both of these methods give
us access to the textPaint.

00:08:51.750 --> 00:08:54.150
So then in the textPaint
all we need to do

00:08:54.150 --> 00:08:56.750
is change the type face.

00:08:56.750 --> 00:09:01.630
But if we have the textPaint,
it means that we can also

00:09:01.630 --> 00:09:03.070
set the background color.

00:09:03.070 --> 00:09:06.110
So it means that we can
just create one code blocks

00:09:06.110 --> 00:09:09.160
span to style our code block.

00:09:09.160 --> 00:09:13.480
So now we have two different
ways of styling our code block,

00:09:13.480 --> 00:09:16.030
one with composing
multiple spans,

00:09:16.030 --> 00:09:18.310
one from the framework
and a custom one,

00:09:18.310 --> 00:09:22.450
and another way where
we're using a custom span.

00:09:22.450 --> 00:09:24.577
So which one should you use?

00:09:24.577 --> 00:09:27.160
To help you decide, there's one
important piece of information

00:09:27.160 --> 00:09:28.780
that you need to remember.

00:09:28.780 --> 00:09:31.900
Only framework spans
can be parceled.

00:09:31.900 --> 00:09:35.410
So there are two common cases
when the spans are parceled,

00:09:35.410 --> 00:09:38.560
first, when we're
passing text via intense,

00:09:38.560 --> 00:09:40.720
or when we're copying text.

00:09:40.720 --> 00:09:43.180
Independently, for copying
text, for example, from a text

00:09:43.180 --> 00:09:45.700
view to an edit text
in the same activity,

00:09:45.700 --> 00:09:48.370
or whether we're copying
text from one application

00:09:48.370 --> 00:09:51.750
to another, that text gets
to be parceled and unparceled

00:09:51.750 --> 00:09:53.810
via the clipboard service.

00:09:53.810 --> 00:09:55.540
So this is what will happen.

00:09:55.540 --> 00:09:58.090
If we're passing the text with
one framework span and one

00:09:58.090 --> 00:10:01.810
custom span, well, just our
framework spans our passed.

00:10:01.810 --> 00:10:05.260
So this means that we're losing
our custom typeface span.

00:10:05.260 --> 00:10:08.530
But then if we're passing a
text with one custom span,

00:10:08.530 --> 00:10:11.920
that it means that no
styling will be kept.

00:10:11.920 --> 00:10:14.320
So in general, when you
are implementing spans

00:10:14.320 --> 00:10:18.400
and the text gets parceled,
consider the behavior you want.

00:10:18.400 --> 00:10:22.760
Should the style be
partially kept or not?

00:10:22.760 --> 00:10:24.760
CLARA BAYARRI: So now
that you know about spans,

00:10:24.760 --> 00:10:26.400
how do we use them in text?

00:10:26.400 --> 00:10:29.510
Well, the framework provides
two key interfaces for this.

00:10:29.510 --> 00:10:30.820
The first one is Spanned.

00:10:30.820 --> 00:10:33.940
Spanned is for immutable
tags and immutable markup,

00:10:33.940 --> 00:10:36.340
and declares methods
such as get spans

00:10:36.340 --> 00:10:38.290
or it get span start
and get span end.

00:10:38.290 --> 00:10:40.672
It lets query spans,
but not modify them.

00:10:40.672 --> 00:10:42.130
If you want to
modify them, we have

00:10:42.130 --> 00:10:44.320
Spannable, which has
the ability to mutate

00:10:44.320 --> 00:10:48.319
the markup with methods that
does set span or remove spam.

00:10:48.319 --> 00:10:50.110
Then we have three
concrete implementations

00:10:50.110 --> 00:10:51.710
of these interfaces.

00:10:51.710 --> 00:10:54.730
The first one is SpannedString,
which implements Spanned,

00:10:54.730 --> 00:10:57.730
and as such has immutable
text an immutable markup.

00:10:57.730 --> 00:11:00.700
SpannableString, which
implements Spannable,

00:11:00.700 --> 00:11:03.772
as such has immutable
text but mutable markup.

00:11:03.772 --> 00:11:05.230
And finally, we
have a third class,

00:11:05.230 --> 00:11:07.020
which adds mutability
to the text, which

00:11:07.020 --> 00:11:08.557
is SpannableStringBuilder.

00:11:08.557 --> 00:11:10.390
This is what we use
internally, for example,

00:11:10.390 --> 00:11:12.306
for edit text, because
it allows you to modify

00:11:12.306 --> 00:11:14.170
the text and the markup.

00:11:14.170 --> 00:11:17.230
These last two classes are
very different internally.

00:11:17.230 --> 00:11:19.870
SpannableString holds
an array of spans,

00:11:19.870 --> 00:11:22.930
whereas SpannableStringBuilder
holds a tree of spans.

00:11:22.930 --> 00:11:25.420
So these are widely
differently implemented.

00:11:25.420 --> 00:11:28.751
So as a team, we were wondering,
well, is a tree more efficient?

00:11:28.751 --> 00:11:31.000
Maybe there's a case where
we want to recommend people

00:11:31.000 --> 00:11:33.400
to only use
SpannableStringBuilder

00:11:33.400 --> 00:11:35.110
all the time because
it's more efficient.

00:11:35.110 --> 00:11:36.670
So we ran tests.

00:11:36.670 --> 00:11:40.240
The answer is up to 250
spans, they're the same.

00:11:40.240 --> 00:11:41.560
They basically perform equally.

00:11:41.560 --> 00:11:44.260
So we recommend you do what
makes most semantic sense,

00:11:44.260 --> 00:11:47.020
which is use SpannableString
for immutable text,

00:11:47.020 --> 00:11:49.510
SpannableStringBuilder
for mutable text.

00:11:49.510 --> 00:11:53.102
However after 250 spans, they
really do start to diverge.

00:11:53.102 --> 00:11:55.060
And we recommend you use
SpannableStringBuilder

00:11:55.060 --> 00:11:58.450
for all of your cases just
because it is more performance.

00:11:58.450 --> 00:12:01.690
Out of curiosity, we ran
these tests to the limit.

00:12:01.690 --> 00:12:04.420
Turns out, when you
have thousands of spans,

00:12:04.420 --> 00:12:05.567
they really diverge.

00:12:05.567 --> 00:12:07.150
But we really, really
hope this is not

00:12:07.150 --> 00:12:09.947
a common use case for anyone.

00:12:09.947 --> 00:12:11.530
Another common thing
we see with spans

00:12:11.530 --> 00:12:13.480
is people trying to
check if one span is

00:12:13.480 --> 00:12:15.370
present within a spannable.

00:12:15.370 --> 00:12:18.910
And the solution we've seen
online, uses span.getspans.

00:12:18.910 --> 00:12:20.530
So it's something
like this, you just

00:12:20.530 --> 00:12:22.870
query for all the
spans of a given type,

00:12:22.870 --> 00:12:26.030
get an array back, and then just
check if the array is empty.

00:12:26.030 --> 00:12:27.440
This is extremely inefficient.

00:12:27.440 --> 00:12:28.990
You're going through
the entire span

00:12:28.990 --> 00:12:31.840
looking for all of the
instances of that span,

00:12:31.840 --> 00:12:33.520
collecting them
all into an array,

00:12:33.520 --> 00:12:35.800
and then just checking
if that array is empty.

00:12:35.800 --> 00:12:39.100
There's a better way to do this,
which is nextSpanTransition.

00:12:39.100 --> 00:12:41.860
This method checks for
the boundaries of spans.

00:12:41.860 --> 00:12:44.696
So when you ask for the first
boundary of a certain span,

00:12:44.696 --> 00:12:47.320
it will just have to do the work
until it finds the first span,

00:12:47.320 --> 00:12:48.640
and then it can stop.

00:12:48.640 --> 00:12:51.790
And it won't collect any spans
into an array, wasting memory

00:12:51.790 --> 00:12:53.682
that you shouldn't do.

00:12:53.682 --> 00:12:55.140
FLORINA MUNTENESCU:
A frequent task

00:12:55.140 --> 00:12:57.200
when working with
styling text is

00:12:57.200 --> 00:12:59.490
styling internationalized text.

00:12:59.490 --> 00:13:01.590
So usually in your
resources, you

00:13:01.590 --> 00:13:04.890
will define the same string
in multiple languages.

00:13:04.890 --> 00:13:08.080
But then you need to
highlight one specific word.

00:13:08.080 --> 00:13:11.280
So here, for example, we want
the word text to be bold.

00:13:11.280 --> 00:13:13.800
But the thing is that the
word and where it appears

00:13:13.800 --> 00:13:16.300
is different in every language.

00:13:16.300 --> 00:13:20.890
So one easy solution would
be to just use HTML text.

00:13:20.890 --> 00:13:22.920
But the problem with
this is that HTML text

00:13:22.920 --> 00:13:24.700
have limited functionality.

00:13:24.700 --> 00:13:27.720
So if, for example, we
want to change the font,

00:13:27.720 --> 00:13:31.050
this is not something
that HTML can provide.

00:13:31.050 --> 00:13:34.770
The solution for this is
to use annotation tags.

00:13:34.770 --> 00:13:38.880
So the annotation tag allows
us to set key and value pairs

00:13:38.880 --> 00:13:41.380
and then define
whatever we need.

00:13:41.380 --> 00:13:42.930
So here, for
example, I'm defining

00:13:42.930 --> 00:13:46.950
the key font and the
value to be the font name.

00:13:46.950 --> 00:13:49.810
And this is how we
would use it in code.

00:13:49.810 --> 00:13:51.840
So we would get the
text from the resources

00:13:51.840 --> 00:13:53.880
as a spanned string.

00:13:53.880 --> 00:13:57.275
Then we would get the
annotations from the span.

00:13:57.275 --> 00:13:58.650
We would [INAUDIBLE]
through them

00:13:58.650 --> 00:14:01.590
and get the ones that have the
key that we're interested in,

00:14:01.590 --> 00:14:03.410
and then the value.

00:14:03.410 --> 00:14:06.230
And then it would set the
span based on the indices.

00:14:10.364 --> 00:14:12.060
SIYAMED SINIR: We
will now look at how

00:14:12.060 --> 00:14:14.860
text is laid out in the view.

00:14:14.860 --> 00:14:16.510
Let's assume that
you have a text field

00:14:16.510 --> 00:14:18.070
with some padding applied.

00:14:18.070 --> 00:14:20.950
When you set the robot up,
text will reposition the image

00:14:20.950 --> 00:14:23.470
to top of the view
after the padding.

00:14:23.470 --> 00:14:25.110
Get compound
padding top function

00:14:25.110 --> 00:14:27.670
will get only the distance
from top of the view

00:14:27.670 --> 00:14:29.670
to bottom of the image.

00:14:29.670 --> 00:14:32.290
Setting the drawable padding
with that extra spacing

00:14:32.290 --> 00:14:35.620
between the image and the idea
that the text will be drawn in.

00:14:35.620 --> 00:14:37.390
And now get compound
padding top will

00:14:37.390 --> 00:14:40.320
point to this new location.

00:14:40.320 --> 00:14:41.520
Then you set text.

00:14:41.520 --> 00:14:43.620
Text we will create
a layout object.

00:14:43.620 --> 00:14:47.040
Layout is responsible for
rendering and measuring text.

00:14:47.040 --> 00:14:48.750
Here, the boundaries
of the layout

00:14:48.750 --> 00:14:50.670
are highlighted in orange.

00:14:50.670 --> 00:14:53.100
It will also provide you
some more information

00:14:53.100 --> 00:14:56.130
about the text it contains
such as the baseline top

00:14:56.130 --> 00:14:59.520
and bottom of the lines.

00:14:59.520 --> 00:15:02.070
There are three layered
classes on Android.

00:15:02.070 --> 00:15:05.210
BoringLayout is for single
style and simple text,

00:15:05.210 --> 00:15:07.960
which doesn't contain
top, next line, or right

00:15:07.960 --> 00:15:09.710
or left characters.

00:15:09.710 --> 00:15:13.310
DynamicLayout is created for
editable and selectable text.

00:15:13.310 --> 00:15:17.860
And for other cases, textView
will create a static layout.

00:15:17.860 --> 00:15:19.780
When we set the
gravity, the layout

00:15:19.780 --> 00:15:22.390
object itself will be
positioned in the view.

00:15:22.390 --> 00:15:24.070
Get total padding
top will return

00:15:24.070 --> 00:15:28.670
it a distance from top of
view to the top of the layout.

00:15:28.670 --> 00:15:30.210
IncludeFontPadding.

00:15:30.210 --> 00:15:32.360
This attribute will
add extra spacing

00:15:32.360 --> 00:15:34.370
to top and bottom of the layout.

00:15:34.370 --> 00:15:37.190
And the height of the
spacing is calculated

00:15:37.190 --> 00:15:39.330
using the values in the font.

00:15:39.330 --> 00:15:42.770
The effect is more visible
than you use a tall script.

00:15:42.770 --> 00:15:44.810
In this example, when
it is set to false,

00:15:44.810 --> 00:15:47.570
we see that the text is clipped.

00:15:47.570 --> 00:15:49.850
Since it only applies
when you set to true,

00:15:49.850 --> 00:15:53.660
it only applies to spacing to
top and bottom of the text,

00:15:53.660 --> 00:15:56.780
on Android we will see
that lines will overlap.

00:15:56.780 --> 00:15:58.910
On Android P we
fixed this issue.

00:15:58.910 --> 00:16:03.230
Now if the system identifies
that the lines will overlap,

00:16:03.230 --> 00:16:05.960
it will put extra spacing
between the lines,

00:16:05.960 --> 00:16:10.300
and will apply this rule
to the whole paragraph.

00:16:10.300 --> 00:16:13.890
To provide an opt
out option, we added

00:16:13.890 --> 00:16:16.700
an attribute named
fallbackLineSpacing,

00:16:16.700 --> 00:16:19.950
which is by default, turned on.

00:16:19.950 --> 00:16:22.650
A similar attribute that
changes the line height,

00:16:22.650 --> 00:16:26.010
is the elegant text
height attribute.

00:16:26.010 --> 00:16:29.250
However, unlikely, even though
it changes the line height,

00:16:29.250 --> 00:16:32.430
unlike the other attributes,
it will not add spacing,

00:16:32.430 --> 00:16:35.220
but it will actually start
using a different font.

00:16:35.220 --> 00:16:37.830
There are two different fonts
defined in the Android font

00:16:37.830 --> 00:16:40.940
fallback chain,
compact and elegant.

00:16:40.940 --> 00:16:42.910
Setting elegant
textHeight to do it

00:16:42.910 --> 00:16:46.350
will make the system
choose the elegant version

00:16:46.350 --> 00:16:49.275
of the same script
if that font exists.

00:16:51.940 --> 00:16:54.640
Speaking of line height, it
is an important attribute

00:16:54.640 --> 00:16:56.890
for the readability
of the text, and you

00:16:56.890 --> 00:16:59.170
can't control it using
line spacing extra

00:16:59.170 --> 00:17:01.120
and multiply it attribute.

00:17:01.120 --> 00:17:04.000
These attributes will
add extra spacing

00:17:04.000 --> 00:17:07.170
in between the lines,
but not the last line.

00:17:07.170 --> 00:17:09.700
Since the developers
mentioned us,

00:17:09.700 --> 00:17:11.950
that designers mostly
provide line night

00:17:11.950 --> 00:17:15.040
as it is, but not as
multiplayer or extra.

00:17:15.040 --> 00:17:20.089
On Android P, we added
the line height attribute.

00:17:20.089 --> 00:17:22.819
Two other attributes that
we added on Android P

00:17:22.819 --> 00:17:25.940
in order to bridge
the gap between design

00:17:25.940 --> 00:17:28.790
and implementation are
FirstBaselineToTopHeight

00:17:28.790 --> 00:17:30.770
and LastBaselinetoBottomHeight.

00:17:30.770 --> 00:17:32.330
The first one will
let you control

00:17:32.330 --> 00:17:34.610
the distance between
the top of the view

00:17:34.610 --> 00:17:37.010
to the baseline
of the first line.

00:17:37.010 --> 00:17:38.730
And the second one
similarly, will

00:17:38.730 --> 00:17:41.660
let you control the distance
between bottom of the view

00:17:41.660 --> 00:17:45.160
to the baseline
of the last line.

00:17:45.160 --> 00:17:46.990
Finally, when you
set text alignment,

00:17:46.990 --> 00:17:49.810
the text will be
positioned in the layout.

00:17:49.810 --> 00:17:53.670
Get line left and get line right
functions of the layout object

00:17:53.670 --> 00:17:56.200
will give you information
about this positioning

00:17:56.200 --> 00:17:59.875
relative to the
layout boundaries.

00:17:59.875 --> 00:18:02.375
Now that you know about layout
and some important functions,

00:18:02.375 --> 00:18:06.210
we can answer a frequently asked
question on the internet, which

00:18:06.210 --> 00:18:09.540
is how can you implement
a rounded background span?

00:18:09.540 --> 00:18:13.470
This is not doable with Spans,
but we can draw it ourselves

00:18:13.470 --> 00:18:16.160
using the layout functions.

00:18:16.160 --> 00:18:19.730
To do that, first, we need to
mark our words that we want

00:18:19.730 --> 00:18:21.435
to draw the background for.

00:18:21.435 --> 00:18:23.540
Annotation, that
Florina mentioned,

00:18:23.540 --> 00:18:26.560
is a good option
for such a use case.

00:18:26.560 --> 00:18:29.380
Then we will define our
drawables, three for the words

00:18:29.380 --> 00:18:32.740
that start and end on different
lines, and one for the words

00:18:32.740 --> 00:18:35.640
that start and end
on the same line.

00:18:35.640 --> 00:18:40.090
We will look over our own
annotations to find our words.

00:18:40.090 --> 00:18:44.920
Then for each annotation, using
the start and end indices,

00:18:44.920 --> 00:18:46.840
we want to learn
the line number.

00:18:46.840 --> 00:18:49.300
And we can use get line
for offset function

00:18:49.300 --> 00:18:51.610
of the layout, which will
convert the character

00:18:51.610 --> 00:18:55.060
index into a line number.

00:18:55.060 --> 00:18:58.160
For the words that start
and end on the same thing

00:18:58.160 --> 00:19:00.650
we also want to learn about
the vertical coordinates

00:19:00.650 --> 00:19:01.620
of the line.

00:19:01.620 --> 00:19:06.240
We can get line up and get line
by them functions for this.

00:19:06.240 --> 00:19:07.910
And finally, we
want to learn about

00:19:07.910 --> 00:19:10.370
the horizontal
coordinates of the words

00:19:10.370 --> 00:19:12.290
and get primary
horizontal function

00:19:12.290 --> 00:19:16.040
to convert the correct index
to horizontal coordinates

00:19:16.040 --> 00:19:18.420
relative to the
layout boundaries.

00:19:18.420 --> 00:19:21.070
Now that we know the rectangle
that we want to draw in,

00:19:21.070 --> 00:19:23.180
we can draw our drawable.

00:19:23.180 --> 00:19:24.710
The other case,
where words start

00:19:24.710 --> 00:19:27.830
an end on the different line
will have almost exactly

00:19:27.830 --> 00:19:31.226
the same code, except now it
has to identify more rectangles

00:19:31.226 --> 00:19:31.850
to the drawing.

00:19:34.484 --> 00:19:36.900
CLARA BAYARRI: TextView goes
through the same three phases

00:19:36.900 --> 00:19:40.500
that any view on Android goes,
measure, layout, and draw.

00:19:40.500 --> 00:19:43.207
Measure is by far the most
expensive for textView.

00:19:43.207 --> 00:19:45.540
Here is where we create the
layouts we just talked about

00:19:45.540 --> 00:19:47.520
or recreate them if
we need to, and where

00:19:47.520 --> 00:19:50.010
we decide on the width and
the height of the view.

00:19:50.010 --> 00:19:51.780
This is really expensive work.

00:19:51.780 --> 00:19:54.630
Later, and on layout, we
barely do anything, just

00:19:54.630 --> 00:19:56.460
some scrolling and auto sizing.

00:19:56.460 --> 00:19:59.340
And finally, in onDraw we
issue the drawing commands.

00:19:59.340 --> 00:20:01.050
But measure is really,
really expensive,

00:20:01.050 --> 00:20:02.980
and you need to be
very aware of this.

00:20:02.980 --> 00:20:06.060
It's important to distinguish
what causes an onMeasure

00:20:06.060 --> 00:20:07.710
with what causes an onDraw.

00:20:07.710 --> 00:20:10.710
As Florina mentioned before,
anything that causes the text

00:20:10.710 --> 00:20:12.420
to change in size
or how it needs

00:20:12.420 --> 00:20:15.750
to be laid out, such as the
letter spacing, the typeface,

00:20:15.750 --> 00:20:18.330
maybe that text size, that
will have to trigger onMeasure,

00:20:18.330 --> 00:20:20.369
as we need to
recalculate that layout,

00:20:20.369 --> 00:20:22.410
whereas if you change
something that just changes

00:20:22.410 --> 00:20:25.530
the appearance, but not how we
place the text on the screen,

00:20:25.530 --> 00:20:27.879
such as the text color
you're going to paint it in,

00:20:27.879 --> 00:20:29.670
that only needs to
trigger an onDraw, which

00:20:29.670 --> 00:20:33.720
is much, much cheaper than
doing an onMeasure as well.

00:20:33.720 --> 00:20:36.670
Let's look at these
two phases separately.

00:20:36.670 --> 00:20:38.370
So we have a textView like this.

00:20:38.370 --> 00:20:41.580
I've set some text that
has several paragraphs.

00:20:41.580 --> 00:20:45.180
And then I view spans to
style some of the words in it.

00:20:45.180 --> 00:20:46.320
I've changed the text size.

00:20:46.320 --> 00:20:47.970
I've changed the colors.

00:20:47.970 --> 00:20:50.220
Well, the first option
to measure your text,

00:20:50.220 --> 00:20:53.100
is there's method in
Paint called measureText.

00:20:53.100 --> 00:20:54.660
A dead giveaway
of this method is

00:20:54.660 --> 00:20:57.000
it takes a string,
not a spannable.

00:20:57.000 --> 00:20:58.050
So what this will do--

00:20:58.050 --> 00:20:59.960
paint just doesn't
understand spans.

00:20:59.960 --> 00:21:01.887
So it will take the
text you've given it--

00:21:01.887 --> 00:21:03.720
it doesn't understand
line breaking either--

00:21:03.720 --> 00:21:06.630
so it will place all of the
text as one very long line,

00:21:06.630 --> 00:21:08.550
ignore all of your
spans, and give you

00:21:08.550 --> 00:21:11.500
the width of that text.

00:21:11.500 --> 00:21:14.840
The next option is to use
kickstands, also from Paint.

00:21:14.840 --> 00:21:15.990
Again, dead give away.

00:21:15.990 --> 00:21:17.310
It takes a string.

00:21:17.310 --> 00:21:18.660
So it will do exactly the same.

00:21:18.660 --> 00:21:20.370
No line breaking, no spans.

00:21:20.370 --> 00:21:21.820
It will place it all together.

00:21:21.820 --> 00:21:23.370
And it will give
you the bounding box

00:21:23.370 --> 00:21:26.310
of all of your glyphs,
which is a width and height.

00:21:26.310 --> 00:21:28.560
It's important to notice
that these two methods return

00:21:28.560 --> 00:21:30.480
slightly different values.

00:21:30.480 --> 00:21:33.720
So textPaint.measureText will
return you the next advance

00:21:33.720 --> 00:21:35.070
glyph.

00:21:35.070 --> 00:21:37.460
This is where you will
position the next glyph

00:21:37.460 --> 00:21:40.170
if you were to add another
one, whereas getTextBounds

00:21:40.170 --> 00:21:42.632
will give you the bounding
box of the glyphs you have.

00:21:42.632 --> 00:21:45.090
And these two values come from
different parts of the font.

00:21:45.090 --> 00:21:47.770
So they may be very different.

00:21:47.770 --> 00:21:50.605
If we want improve on
this, well, we use layouts.

00:21:50.605 --> 00:21:53.590
Layout has a static method
called getDesiredWidth.

00:21:53.590 --> 00:21:55.960
What this does is it
takes a text you give it.

00:21:55.960 --> 00:21:58.720
It places each
paragraph into one line,

00:21:58.720 --> 00:22:00.970
and taking into account
all of the styling,

00:22:00.970 --> 00:22:03.310
it measures each of the lines.

00:22:03.310 --> 00:22:05.686
And then it returns the width
of the longest line it has.

00:22:05.686 --> 00:22:07.518
So it will give you the
width of the longest

00:22:07.518 --> 00:22:08.800
paragraph you've given it.

00:22:08.800 --> 00:22:12.220
This is useful to know how
much your text wants to be

00:22:12.220 --> 00:22:13.990
before you can restrict it.

00:22:13.990 --> 00:22:15.890
If you know the
width of your view,

00:22:15.890 --> 00:22:18.160
well then you actually
create a layout object.

00:22:18.160 --> 00:22:20.320
In this case, we've
created a static layout.

00:22:20.320 --> 00:22:23.170
By having the constrained
width want to fit it in,

00:22:23.170 --> 00:22:26.260
layouts can actually calculate
how to reflow the text,

00:22:26.260 --> 00:22:29.230
and how to make it fit, and
give you a height in return.

00:22:29.230 --> 00:22:32.470
So by giving it a width, we can
actually calculate the height.

00:22:32.470 --> 00:22:34.356
On top that, as Siyamed
had mentioned before,

00:22:34.356 --> 00:22:35.980
you will get a lot
more information out

00:22:35.980 --> 00:22:37.150
of your layout object.

00:22:37.150 --> 00:22:39.610
For each line, it will give
you things like the baseline,

00:22:39.610 --> 00:22:43.210
the lines start,
the line end, so on.

00:22:43.210 --> 00:22:46.030
We've measured the performance
of all of these methods

00:22:46.030 --> 00:22:46.930
next to each other.

00:22:46.930 --> 00:22:48.210
Measure text is the cheapest.

00:22:48.210 --> 00:22:50.740
So compared to
measure text, you will

00:22:50.740 --> 00:22:54.010
see that layout getDesiredWidth
and Paint getTextBounds

00:22:54.010 --> 00:22:55.090
are quite cheap to run.

00:22:55.090 --> 00:22:56.252
They are similar.

00:22:56.252 --> 00:22:58.210
But once you get into
creating a static layout,

00:22:58.210 --> 00:23:00.430
or once add text
view to measure text,

00:23:00.430 --> 00:23:02.290
that gets more and
more expensive.

00:23:02.290 --> 00:23:05.050
So now that you know what each
of these methods do, make sure

00:23:05.050 --> 00:23:08.960
you use the one that makes
sense for your use case.

00:23:08.960 --> 00:23:11.780
Similarly, we've talked before
about the word measure cache,

00:23:11.780 --> 00:23:15.230
and how we measure words, once
and we place them in a cache.

00:23:15.230 --> 00:23:18.170
Well for paint, when you call
measure text on the same word

00:23:18.170 --> 00:23:21.620
a second time, turns out it only
cost us about 3% of the work

00:23:21.620 --> 00:23:23.840
to return that value,
which is a huge gain.

00:23:23.840 --> 00:23:26.390
So once we have a hit in
the cache, it's only 3%

00:23:26.390 --> 00:23:27.410
of the work.

00:23:27.410 --> 00:23:31.700
If we measure this in
text view, onMeasure

00:23:31.700 --> 00:23:33.980
takes about 16%
to 11% of the work

00:23:33.980 --> 00:23:36.200
that it did the first
time it sees a word.

00:23:36.200 --> 00:23:40.620
So definitely using that cache
is really important for us.

00:23:40.620 --> 00:23:42.650
So as I said several
times now, measurement

00:23:42.650 --> 00:23:44.010
is really expensive.

00:23:44.010 --> 00:23:45.029
What can we do about it?

00:23:45.029 --> 00:23:46.820
Well in P, we've come
up with a new feature

00:23:46.820 --> 00:23:48.860
called premeasured text.

00:23:48.860 --> 00:23:51.370
The idea behind it is we
know that in onMeasure we

00:23:51.370 --> 00:23:54.029
need to take all of the
glyphs, find them in the font,

00:23:54.029 --> 00:23:56.570
place them next to each other,
and measure all of these words

00:23:56.570 --> 00:23:58.410
that we will place in the cache.

00:23:58.410 --> 00:24:00.380
So what premeasured
text does is it takes

00:24:00.380 --> 00:24:01.970
care of this phase for you.

00:24:01.970 --> 00:24:04.130
And you can run
this in any thread,

00:24:04.130 --> 00:24:06.650
so that then once you
have that pre-calculation,

00:24:06.650 --> 00:24:09.410
sending it on the text
view only takes about 10%

00:24:09.410 --> 00:24:11.250
of the work that you
had to do initially,

00:24:11.250 --> 00:24:13.070
which is a huge gain.

00:24:13.070 --> 00:24:16.610
The way this looks in code is
we need a bunch of attributes

00:24:16.610 --> 00:24:19.460
to know how to measure the text,
things like the font you're

00:24:19.460 --> 00:24:21.352
going to use, the text size.

00:24:21.352 --> 00:24:23.060
We have a convenience
method in text view

00:24:23.060 --> 00:24:25.040
that will retrieve
all of these for you.

00:24:25.040 --> 00:24:26.690
It's got text metrics params.

00:24:26.690 --> 00:24:28.530
You can also build
this option yourself

00:24:28.530 --> 00:24:31.160
if you don't have the textView
you are going to work with yet.

00:24:31.160 --> 00:24:35.630
And then on a background thread
called precomputedtext.create.

00:24:35.630 --> 00:24:38.010
This triggers all of the things
we've been talking about.

00:24:38.010 --> 00:24:39.770
It measures each of the words.

00:24:39.770 --> 00:24:41.590
It places them in
the cache, and it's

00:24:41.590 --> 00:24:42.820
stores all of those values.

00:24:42.820 --> 00:24:44.403
So this is also
useful if you're going

00:24:44.403 --> 00:24:46.550
to measure more than 5,000
words, as this actually

00:24:46.550 --> 00:24:48.890
stores all of the values.

00:24:48.890 --> 00:24:51.560
Then once you have all of
this pre-computed information,

00:24:51.560 --> 00:24:55.190
you can go back to the II thread
and set it on your textView.

00:24:55.190 --> 00:24:56.690
Notice that all
of this only makes

00:24:56.690 --> 00:24:58.767
sense if you know
your text beforehand.

00:24:58.767 --> 00:25:01.100
If you just know your text
as you're going to render it,

00:25:01.100 --> 00:25:02.808
do what we've always
done, because you're

00:25:02.808 --> 00:25:04.594
going to be blocking
the UI thread anyway.

00:25:04.594 --> 00:25:06.260
But if you do know
your text beforehand,

00:25:06.260 --> 00:25:07.884
say you're loading
it from the internet

00:25:07.884 --> 00:25:10.686
or you have an infinite
scroll, you can run this,

00:25:10.686 --> 00:25:12.560
pre-computer all of your
text before it needs

00:25:12.560 --> 00:25:15.290
to be shown on screen,
and the gain is literally

00:25:15.290 --> 00:25:17.810
90% of the work will be done
on the background thread, which

00:25:17.810 --> 00:25:19.600
is amazing.

00:25:19.600 --> 00:25:22.940
Mention in Support Library
we do have a solution.

00:25:22.940 --> 00:25:24.860
For P, we've just run this.

00:25:24.860 --> 00:25:28.970
Between L and P, we can actually
not do exactly the competitions

00:25:28.970 --> 00:25:31.910
that we've done, but we can
warm up that cache for you.

00:25:31.910 --> 00:25:33.552
So that's what we do.

00:25:33.552 --> 00:25:35.510
And then before L, sadly,
we can't do anything.

00:25:35.510 --> 00:25:37.884
So it's a no up, but we do
have a solution in the support

00:25:37.884 --> 00:25:39.810
libraries.

00:25:39.810 --> 00:25:42.140
Another common thing we
see related to all of this

00:25:42.140 --> 00:25:43.640
is very long text.

00:25:43.640 --> 00:25:45.650
People tend to just say,
oh, I've got the text.

00:25:45.650 --> 00:25:48.000
I'll just set it
all on the textView.

00:25:48.000 --> 00:25:52.250
When you set text on textView,
it measures all of the words

00:25:52.250 --> 00:25:55.490
and lays out the entire text
you've given it, even if you've

00:25:55.490 --> 00:25:57.480
given us an entire book.

00:25:57.480 --> 00:25:59.060
So this can be a
huge performance hit

00:25:59.060 --> 00:26:01.700
if you're setting very long text
that then you're not actually

00:26:01.700 --> 00:26:04.820
showing on screen, because
maybe the user never scrolls.

00:26:04.820 --> 00:26:08.540
A solution to this is to split
your text into separate pieces,

00:26:08.540 --> 00:26:10.730
say, for example,
paragraphs, and put them

00:26:10.730 --> 00:26:13.130
all into a recyclerView
as different items.

00:26:13.130 --> 00:26:15.080
Then this way while
the user scrolls,

00:26:15.080 --> 00:26:16.712
we will start loading
the next bits,

00:26:16.712 --> 00:26:18.170
but we won't actually
be triggering

00:26:18.170 --> 00:26:20.720
a measure in a layout
of all of your texts.

00:26:20.720 --> 00:26:22.910
You can also link this to
premeasured text, which

00:26:22.910 --> 00:26:24.740
I just talked about,
and pre-measured all

00:26:24.740 --> 00:26:26.570
of the background measurement.

00:26:26.570 --> 00:26:28.300
Then you will have
all that information

00:26:28.300 --> 00:26:31.070
really, really efficiently.

00:26:31.070 --> 00:26:32.750
So we've talked about measure.

00:26:32.750 --> 00:26:33.520
What about draw?

00:26:33.520 --> 00:26:35.090
Draw is much
cheaper, but you also

00:26:35.090 --> 00:26:38.120
have several options if
you're going drive yourself.

00:26:38.120 --> 00:26:40.070
A easy one that people
tend to say, oh,

00:26:40.070 --> 00:26:41.840
why don't you just
canvas.drawtext?

00:26:41.840 --> 00:26:43.010
That's easy, right?

00:26:43.010 --> 00:26:44.720
Turns out, canvas
does not understand

00:26:44.720 --> 00:26:46.910
spans or line breaking
or any of the things

00:26:46.910 --> 00:26:48.260
we've been talking about.

00:26:48.260 --> 00:26:50.810
So similar to the things
were talking about before,

00:26:50.810 --> 00:26:52.850
it will just draw
the text you give it

00:26:52.850 --> 00:26:55.250
with no styling as one run.

00:26:55.250 --> 00:26:56.900
Instead, if you have
styling, or if you

00:26:56.900 --> 00:26:59.660
want to use line breaking,
again, use the layout classes.

00:26:59.660 --> 00:27:01.566
You can see the recurring theme.

00:27:01.566 --> 00:27:04.190
All of the layout classes have
a draw method that will actually

00:27:04.190 --> 00:27:06.076
draw on the Canvas for you.

00:27:06.076 --> 00:27:08.700
FLORINA MUNTENESCU: I think it's
time we actually set the text,

00:27:08.700 --> 00:27:11.450
but in a performance way.

00:27:11.450 --> 00:27:14.880
So set text, I think is the
most commonly used method.

00:27:14.880 --> 00:27:17.390
And it's great for text
views that don't change,

00:27:17.390 --> 00:27:20.580
so when both the text and
the markup attached to it

00:27:20.580 --> 00:27:22.520
are immutable.

00:27:22.520 --> 00:27:25.620
So under the hoods, the textView
creates a defensive copy

00:27:25.620 --> 00:27:27.210
as a spanned string.

00:27:27.210 --> 00:27:28.860
So this means that
if you're changing

00:27:28.860 --> 00:27:33.080
the original reference, the
textView doesn't update.

00:27:33.080 --> 00:27:36.750
But what if we want to
mutate the spans later?

00:27:36.750 --> 00:27:38.580
Or to do this, we
would send the text

00:27:38.580 --> 00:27:41.100
using buffer type spannable.

00:27:41.100 --> 00:27:44.130
So under the hood, the textView
will create a copy of it,

00:27:44.130 --> 00:27:45.660
but as a spannable.

00:27:45.660 --> 00:27:48.700
So this means that while
the text is immutable,

00:27:48.700 --> 00:27:50.760
the spans are mutable.

00:27:50.760 --> 00:27:54.570
So once what we
can do here is we

00:27:54.570 --> 00:27:57.060
can get the text as a
spannable, and then we

00:27:57.060 --> 00:28:00.100
can add or remove spans to it.

00:28:00.100 --> 00:28:01.650
And I know that
you'll be tempted

00:28:01.650 --> 00:28:03.870
to call tech or set
text again, but you

00:28:03.870 --> 00:28:05.340
don't need to do this anymore.

00:28:05.340 --> 00:28:08.530
Because textView has an
all span change listener.

00:28:08.530 --> 00:28:12.060
And it automatically knows when
something was added or removed,

00:28:12.060 --> 00:28:14.880
and the text will
just be displayed.

00:28:14.880 --> 00:28:17.670
But what if you want to
change an internal property

00:28:17.670 --> 00:28:18.490
of the span?

00:28:18.490 --> 00:28:22.020
So in our case, we want
to change that typeface

00:28:22.020 --> 00:28:23.690
in our custom typeface span.

00:28:23.690 --> 00:28:27.030
Well, in this case, the textView
doesn't know what's changed.

00:28:27.030 --> 00:28:30.250
And it doesn't know that
it needs to do something.

00:28:30.250 --> 00:28:32.040
So we need to tell it.

00:28:32.040 --> 00:28:35.970
And we will do this with either
request layout or invalidate,

00:28:35.970 --> 00:28:39.040
depending on what kind
of attribute has changed.

00:28:39.040 --> 00:28:42.060
So if you change the
measure affecting attribute,

00:28:42.060 --> 00:28:44.840
and the textView needs to
remeasure and then redraw,

00:28:44.840 --> 00:28:46.830
it would call request layout.

00:28:46.830 --> 00:28:49.890
But if you just change an
appearance affecting attribute,

00:28:49.890 --> 00:28:54.060
then you just need to
invalidate and call redraw.

00:28:54.060 --> 00:28:57.340
But what if you also
want to mutate the text?

00:28:57.340 --> 00:28:59.760
So if I look at the code,
we see that under the hood

00:28:59.760 --> 00:29:03.300
the textView creates a copy
using a spannable factory.

00:29:03.300 --> 00:29:07.290
So it has a default spannable
factory implementation.

00:29:07.290 --> 00:29:09.150
But we can implement our own.

00:29:09.150 --> 00:29:11.820
And then instead of
creating a copy of it,

00:29:11.820 --> 00:29:14.970
we will just return the same
reference to the object,

00:29:14.970 --> 00:29:17.250
in case the object
is a spannable.

00:29:17.250 --> 00:29:19.620
And then we just set
that spannable factory

00:29:19.620 --> 00:29:21.670
to the textView.

00:29:21.670 --> 00:29:24.040
So this is
specifically important

00:29:24.040 --> 00:29:27.550
if you're using style text
inside a recyclerView.

00:29:27.550 --> 00:29:29.770
Because like this,
you avoid creating

00:29:29.770 --> 00:29:33.940
copies inside the recyclerView,
saving both CPU time and memory

00:29:33.940 --> 00:29:35.530
allocation.

00:29:35.530 --> 00:29:38.100
So in the recyclerView, this
is how you would use it.

00:29:38.100 --> 00:29:40.720
In the viewHolder, you would
set the spannable factory

00:29:40.720 --> 00:29:44.920
you've just created, and then in
the onBindViewHolder, make sure

00:29:44.920 --> 00:29:47.530
you're also setting the
buffer type as spannable

00:29:47.530 --> 00:29:49.982
when you're setting the text.

00:29:49.982 --> 00:29:51.440
CLARA BAYARRI:
Another common thing

00:29:51.440 --> 00:29:55.287
we see related to recyclerView
is the use of autolink.

00:29:55.287 --> 00:29:57.120
You might be familiar
with taking a textView

00:29:57.120 --> 00:29:58.920
and just setting
autolink to say web

00:29:58.920 --> 00:30:01.320
to be able to detect
URLs within your text

00:30:01.320 --> 00:30:03.216
and have them
automatically linked.

00:30:03.216 --> 00:30:05.340
Well, what happens under
the hood when you do this?

00:30:05.340 --> 00:30:08.100
Turns out that when you set a
text on that textView, first

00:30:08.100 --> 00:30:10.770
of all, we will create a
copy, just like Florina said,

00:30:10.770 --> 00:30:13.020
and then we run a matcher
for a regular expression

00:30:13.020 --> 00:30:14.090
on your text.

00:30:14.090 --> 00:30:16.170
And for each match
where we find a URL,

00:30:16.170 --> 00:30:19.770
we will create a URL span
and add that to your text.

00:30:19.770 --> 00:30:21.920
If you do this inside
onBindViewHolder,

00:30:21.920 --> 00:30:23.400
you're creating
copies, and you're

00:30:23.400 --> 00:30:26.580
running that regular expression
every time you're setting text,

00:30:26.580 --> 00:30:29.050
even if you're showing the
same text in each item.

00:30:29.050 --> 00:30:30.910
So you have a little
footer with a link.

00:30:30.910 --> 00:30:34.320
You're going to be recalculating
that for each and every item.

00:30:34.320 --> 00:30:37.422
So the solution to this is one,
don't use autolink in your XML,

00:30:37.422 --> 00:30:38.880
because that
automatically triggers

00:30:38.880 --> 00:30:42.210
all of the process,
instead, first of all,

00:30:42.210 --> 00:30:44.310
create a spannable
copy of your string,

00:30:44.310 --> 00:30:46.714
and run either Linkify
or LinkifyCompat

00:30:46.714 --> 00:30:48.630
to be able to find all
those links beforehand.

00:30:48.630 --> 00:30:50.460
So you pre-calculate all of it.

00:30:50.460 --> 00:30:52.170
And then in
onBindViewHolder, you simply

00:30:52.170 --> 00:30:53.400
have to set the text.

00:30:53.400 --> 00:30:56.310
And if you use Florina's trick
of using buffer type spannable,

00:30:56.310 --> 00:30:58.830
you will be avoiding
all of those copies,

00:30:58.830 --> 00:31:02.220
and avoiding all of
this extra computation.

00:31:02.220 --> 00:31:05.190
Related to this, in general,
we want to discourage everyone

00:31:05.190 --> 00:31:07.400
from using autolink map.

00:31:07.400 --> 00:31:09.180
All of the other
options in autolink

00:31:09.180 --> 00:31:12.390
use regular expressions
and are easy to run.

00:31:12.390 --> 00:31:15.420
However, in map actually spins
off an instance of a web view

00:31:15.420 --> 00:31:17.940
to find addresses, which
is a huge performance hit

00:31:17.940 --> 00:31:18.965
for your app.

00:31:18.965 --> 00:31:20.340
So we want to
discourage everyone

00:31:20.340 --> 00:31:22.950
from using map or all,
which includes map.

00:31:22.950 --> 00:31:24.857
And you might say,
well, but I need this.

00:31:24.857 --> 00:31:25.940
And you're taking it away.

00:31:25.940 --> 00:31:27.540
What do I do?

00:31:27.540 --> 00:31:30.120
Coming to the rescue
is Smart Linkify.

00:31:30.120 --> 00:31:33.630
You might remember last year we
presented Smart Selection in O

00:31:33.630 --> 00:31:36.030
where we used machine learning
to detect entities when

00:31:36.030 --> 00:31:37.680
you were trying to select text.

00:31:37.680 --> 00:31:39.750
Well, this year, we've
taken those same machine

00:31:39.750 --> 00:31:42.540
learning models that detect
entities and apply them

00:31:42.540 --> 00:31:43.710
to Linkify.

00:31:43.710 --> 00:31:45.900
This way, we can do a
much better accuracy

00:31:45.900 --> 00:31:47.400
at detecting all
of the entities,

00:31:47.400 --> 00:31:48.960
and we can detect new types.

00:31:48.960 --> 00:31:52.170
So on top of phone numbers,
URLs, and addresses

00:31:52.170 --> 00:31:54.900
like we're doing before, we can
do more sophisticated things

00:31:54.900 --> 00:31:57.060
like flight codes.

00:31:57.060 --> 00:31:59.790
The way this works in code is
you create a textLinks request

00:31:59.790 --> 00:32:02.730
with your text, and it can
also take some options,

00:32:02.730 --> 00:32:04.560
then on a background
thread, you call

00:32:04.560 --> 00:32:06.410
textClassifier.GenerateLinks.

00:32:06.410 --> 00:32:08.910
It's very important that you
do this on a background thread,

00:32:08.910 --> 00:32:11.200
as this is loading a machine
learning model from disk.

00:32:11.200 --> 00:32:13.530
So please don't do
this on the UI thread.

00:32:13.530 --> 00:32:16.590
Once it comes back, it has
all of the detected entities.

00:32:16.590 --> 00:32:19.140
You can apply those
links to the text.

00:32:19.140 --> 00:32:22.410
There's a change here between
the old Linkify and this.

00:32:22.410 --> 00:32:24.990
The old Linkify, it used
to generate a URL span

00:32:24.990 --> 00:32:27.390
that when you clicked, it
would just go through the link.

00:32:27.390 --> 00:32:29.767
And the case with Smart
Linkify, file the URL spans

00:32:29.767 --> 00:32:31.350
that are being added
pop up a floating

00:32:31.350 --> 00:32:33.940
toolbar with smart
actions that you can take.

00:32:33.940 --> 00:32:37.570
So for example, for an
address, we might suggest maps.

00:32:37.570 --> 00:32:39.640
Finally, when you have
all of your text ready,

00:32:39.640 --> 00:32:42.070
you can go back to the UI
thread and set that text

00:32:42.070 --> 00:32:43.300
on the textView.

00:32:43.300 --> 00:32:45.730
Notice there's a big difference
between the old linkify

00:32:45.730 --> 00:32:48.700
and the new linkify, and that
the old one was synchronous,

00:32:48.700 --> 00:32:50.574
and this is asynchronous.

00:32:50.574 --> 00:32:52.240
We understand this
is a huge difference.

00:32:52.240 --> 00:32:54.820
But it is the way that we can
use machine learning to really

00:32:54.820 --> 00:32:56.350
enhance how we detect entities.

00:32:56.350 --> 00:32:57.820
And the accuracy
on the new models

00:32:57.820 --> 00:33:00.350
is really, really much better.

00:33:00.350 --> 00:33:02.130
And since I'm talking
about new features,

00:33:02.130 --> 00:33:03.671
let me introduce
our last new feature

00:33:03.671 --> 00:33:05.330
for P, which is Magnifier.

00:33:05.330 --> 00:33:08.420
A lot of people tell us that
selecting text is really hard,

00:33:08.420 --> 00:33:11.140
and placing the cursor where
you want is a really hard task.

00:33:11.140 --> 00:33:13.310
So Magnifier shows
a zoomed in version

00:33:13.310 --> 00:33:15.080
of where you are
touching with your finger

00:33:15.080 --> 00:33:18.050
to help you place the cursor
in the correct position.

00:33:18.050 --> 00:33:21.020
We've implemented this by
default in textView, edit text,

00:33:21.020 --> 00:33:22.160
and in web view in Chrome.

00:33:22.160 --> 00:33:23.909
So you don't have to
do any work if you're

00:33:23.909 --> 00:33:25.670
using the default widgets.

00:33:25.670 --> 00:33:27.800
However, if you're doing
your own custom widgets

00:33:27.800 --> 00:33:29.900
and you want to
implement this yourself,

00:33:29.900 --> 00:33:32.756
there is a very easy
API to use there.

00:33:32.756 --> 00:33:34.169
You could do
something like this,

00:33:34.169 --> 00:33:35.460
just take your untouched event.

00:33:35.460 --> 00:33:37.020
And whenever the
finger goes down,

00:33:37.020 --> 00:33:39.090
show the magnifier,
whenever the finger goes up,

00:33:39.090 --> 00:33:40.184
dismiss the magnifier.

00:33:40.184 --> 00:33:42.600
This creates an effect where
the magnifier kind of follows

00:33:42.600 --> 00:33:44.654
your finger around the screen.

00:33:44.654 --> 00:33:46.320
This is not the final
UX we've gone for.

00:33:46.320 --> 00:33:48.060
We kind of snapped to the lines.

00:33:48.060 --> 00:33:50.310
We will publish
guidelines on the final UX

00:33:50.310 --> 00:33:54.870
we've come up with, but
it is very easy to use.

00:33:54.870 --> 00:33:58.040
So I hope today we've presented
a bunch of tips and tricks.

00:33:58.040 --> 00:34:01.052
We've shown you what text is
under the hood on Android,

00:34:01.052 --> 00:34:02.510
and we've provided
more information

00:34:02.510 --> 00:34:04.070
on how to style your
text so that you

00:34:04.070 --> 00:34:05.900
can take all of this
back to your apps

00:34:05.900 --> 00:34:08.426
and build beautiful
more performant apps.

00:34:08.426 --> 00:34:13.078
[MUSIC PLAYING]

