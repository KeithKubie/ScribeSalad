WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.227
[MUSIC PLAYING]

00:00:03.227 --> 00:00:05.560
LIZA MA: Thank you for taking
the time to join us today.

00:00:05.560 --> 00:00:06.720
My name is Liza.

00:00:06.720 --> 00:00:09.120
I'm a product manager
on the Weave Team.

00:00:09.120 --> 00:00:11.110
My colleague, Alex, here
is a software engineer

00:00:11.110 --> 00:00:12.050
on the Weave Team.

00:00:12.050 --> 00:00:14.508
And we're here today to talk
to you about Weave and mobile.

00:00:18.950 --> 00:00:20.910
In our last session
on Weave, we learned

00:00:20.910 --> 00:00:24.790
about how Weave enables an
interoperable device ecosystem.

00:00:24.790 --> 00:00:27.440
We are excited by the
future of IoT devices.

00:00:27.440 --> 00:00:30.000
And we can't wait to see
how this space evolves.

00:00:30.000 --> 00:00:32.439
One intersection point that
is already obvious to us

00:00:32.439 --> 00:00:36.150
is the interaction users will
have with their IoT devices

00:00:36.150 --> 00:00:37.816
and their mobile phones.

00:00:37.816 --> 00:00:39.440
In this presentation,
we will talk more

00:00:39.440 --> 00:00:42.560
about the app ecosystem
that we envision supporting

00:00:42.560 --> 00:00:43.766
for future Weave devices.

00:00:43.766 --> 00:00:45.140
And we will walk
you through what

00:00:45.140 --> 00:00:47.050
building an experience
for a Weave device

00:00:47.050 --> 00:00:50.410
will look like on Android.

00:00:50.410 --> 00:00:53.240
Interoperability is one of
the most important tenets

00:00:53.240 --> 00:00:54.670
of the Weave ecosystem.

00:00:54.670 --> 00:00:57.666
We want consumers to have
confidence when they purchase

00:00:57.666 --> 00:00:59.040
a Weave device,
that it will work

00:00:59.040 --> 00:01:02.454
with all the existing Weave
devices they already have.

00:01:02.454 --> 00:01:03.870
And we want to
make sure that they

00:01:03.870 --> 00:01:06.560
have compelling and compatible
choices available to them

00:01:06.560 --> 00:01:09.370
from a wide range of
device manufacturers.

00:01:09.370 --> 00:01:11.970
We actually expect device
makers to challenge each other

00:01:11.970 --> 00:01:15.770
over time to build increasingly
more compelling device

00:01:15.770 --> 00:01:17.530
experiences.

00:01:17.530 --> 00:01:19.700
The Weave mobile
platform will enable

00:01:19.700 --> 00:01:22.040
them to easily interconnect
not just their own devices,

00:01:22.040 --> 00:01:24.230
but devices of their partners.

00:01:24.230 --> 00:01:26.140
We also anticipate
that app developers

00:01:26.140 --> 00:01:29.370
will be able to add a lot
of value to this ecosystem

00:01:29.370 --> 00:01:32.950
and build unique experiences
that further increase the value

00:01:32.950 --> 00:01:36.250
users get from
their Weave devices.

00:01:36.250 --> 00:01:38.360
We recognize that
most IoT devices,

00:01:38.360 --> 00:01:41.270
unlike our mobile phones,
are often shared devices.

00:01:41.270 --> 00:01:43.590
And not everyone who
uses the same IoT

00:01:43.590 --> 00:01:47.080
device will necessarily use the
same mobile operating system.

00:01:47.080 --> 00:01:48.940
Weave will support
development platforms

00:01:48.940 --> 00:01:51.350
on Android, iOS, and web.

00:01:51.350 --> 00:01:54.130
This will allow developers to
build both apps and services

00:01:54.130 --> 00:01:57.320
on top of Weave devices.

00:01:57.320 --> 00:01:59.600
The diagram behind us
paints a very simple picture

00:01:59.600 --> 00:02:01.790
of why we think the
Weave platform can

00:02:01.790 --> 00:02:04.350
help accelerate and
simplify development

00:02:04.350 --> 00:02:05.700
for these developers.

00:02:05.700 --> 00:02:07.720
For an app developer
today who wants

00:02:07.720 --> 00:02:09.287
to integrate with
three devices--

00:02:09.287 --> 00:02:11.370
and let's just say, for
simplicity, that these are

00:02:11.370 --> 00:02:13.590
devices of the same
type-- they have

00:02:13.590 --> 00:02:15.540
to work with three
different APIs from three

00:02:15.540 --> 00:02:17.060
different manufacturers.

00:02:17.060 --> 00:02:19.195
Or in a worst case
scenario, want

00:02:19.195 --> 00:02:22.420
to integrate with a device that
does not have an API available

00:02:22.420 --> 00:02:25.880
because the device developer
has not yet devoted resources

00:02:25.880 --> 00:02:27.630
to that, or they
don't have an existing

00:02:27.630 --> 00:02:30.650
partnership with this
developer to make that happen.

00:02:30.650 --> 00:02:34.970
With Weave, developers will have
a single API interaction point

00:02:34.970 --> 00:02:37.700
with all Weave devices,
independent of type.

00:02:37.700 --> 00:02:39.840
And Weave enables this
by working very closely

00:02:39.840 --> 00:02:43.610
with device developers
to develop public schemas

00:02:43.610 --> 00:02:46.700
for functionality that we know
devices of a particular class

00:02:46.700 --> 00:02:47.720
share.

00:02:47.720 --> 00:02:51.260
For example, every single
light bulb you have at home

00:02:51.260 --> 00:02:53.600
supports the capability
to turn on and off.

00:02:53.600 --> 00:02:55.490
There should be no
reason why sending

00:02:55.490 --> 00:02:57.980
a command to this kind
of device is different

00:02:57.980 --> 00:03:00.060
depending on the OEM.

00:03:00.060 --> 00:03:02.070
Optional functionality,
like sending brightness,

00:03:02.070 --> 00:03:04.440
for example, should
also be standardized.

00:03:04.440 --> 00:03:05.900
This does not
preclude, of course,

00:03:05.900 --> 00:03:09.682
developers from adding unique
functionality to their devices.

00:03:09.682 --> 00:03:11.640
And you can learn more
about our device schemas

00:03:11.640 --> 00:03:14.620
on the Weave developer website.

00:03:14.620 --> 00:03:16.190
I'm going to hand
things over to Alex

00:03:16.190 --> 00:03:18.606
now, who's actually going to
walk us through what building

00:03:18.606 --> 00:03:20.760
an app on Android will
look like for Weave.

00:03:20.760 --> 00:03:22.440
We will have a code
lab session tomorrow

00:03:22.440 --> 00:03:25.340
where you will actually
get the opportunity

00:03:25.340 --> 00:03:29.450
to try a code lab with an
upcoming update of our Weave

00:03:29.450 --> 00:03:31.270
APIs on Android.

00:03:31.270 --> 00:03:31.917
Over to you.

00:03:31.917 --> 00:03:33.250
ALEXEY SEMENOV: Thank you, Liza.

00:03:33.250 --> 00:03:35.780
So in this section,
we'll focus on

00:03:35.780 --> 00:03:38.080
how you would use Weave
Android APIs to build

00:03:38.080 --> 00:03:39.955
an application that
works with a Weave device

00:03:39.955 --> 00:03:42.900
and which steps you need to
take in order to get it up

00:03:42.900 --> 00:03:43.890
and running.

00:03:43.890 --> 00:03:46.420
Now, when you work
with the Weave devices,

00:03:46.420 --> 00:03:48.080
we would like you
to focus on what

00:03:48.080 --> 00:03:50.670
you would like to achieve, and
not on how you would do that.

00:03:50.670 --> 00:03:56.410
So all the semantics of a device
is what you care about, right?

00:03:56.410 --> 00:03:58.521
Weave is a very,
very broad platform.

00:03:58.521 --> 00:04:00.770
So we support cloud devices,
we support local devices,

00:04:00.770 --> 00:04:02.310
we support different
authentication mechanisms,

00:04:02.310 --> 00:04:02.860
and so on.

00:04:02.860 --> 00:04:04.760
So when using our
APIs, you will not

00:04:04.760 --> 00:04:06.130
need to care about any of that.

00:04:06.130 --> 00:04:10.150
So as long as the device is what
you care about, you can see,

00:04:10.150 --> 00:04:12.207
hey, does this
device have a feature

00:04:12.207 --> 00:04:13.290
I would like to work with?

00:04:13.290 --> 00:04:16.570
And if so, you
can start on that.

00:04:16.570 --> 00:04:18.079
Before I move on
to the actual code,

00:04:18.079 --> 00:04:20.769
I'd like to spend a few
minutes and talk about the life

00:04:20.769 --> 00:04:21.690
cycle of Weave API.

00:04:21.690 --> 00:04:26.440
So which steps do you need to
do to get APIs working for you?

00:04:26.440 --> 00:04:29.440
Now, anyone of you who ever
used Google Play services

00:04:29.440 --> 00:04:32.600
would feel immediately
familiar with Weave APIs.

00:04:32.600 --> 00:04:35.070
We have a concept of
WeaveApiClient, client,

00:04:35.070 --> 00:04:38.060
which is very similar to
that of GoogleApiClient.

00:04:38.060 --> 00:04:42.440
And working with it would
be really familiar to you,

00:04:42.440 --> 00:04:44.190
if you ever used
GoogleApiClient.

00:04:44.190 --> 00:04:47.100
Now, WeaveApiClient is
required for every API call.

00:04:47.100 --> 00:04:48.620
And it has a life cycle.

00:04:48.620 --> 00:04:50.560
And by that, I mean
that, before you

00:04:50.560 --> 00:04:52.319
try to use any of
Weave APIs, you

00:04:52.319 --> 00:04:53.985
would need to connect
to the API client.

00:04:53.985 --> 00:04:58.160
And after you're done using it,
you need to disconnect from it.

00:04:58.160 --> 00:05:01.470
Now, one important
property of WeaveApiClient

00:05:01.470 --> 00:05:03.410
is that we require that
Weave application is

00:05:03.410 --> 00:05:05.400
installed on a user's device.

00:05:05.400 --> 00:05:08.990
We believe that this
would bring two benefits,

00:05:08.990 --> 00:05:11.330
both for developers
and for the users.

00:05:11.330 --> 00:05:13.855
For developers, you will not
need to care about API updates.

00:05:13.855 --> 00:05:14.980
So we will do that for you.

00:05:14.980 --> 00:05:17.720
So all the fixes and so on,
they will be pushed by us,

00:05:17.720 --> 00:05:19.522
along with Weave app updates.

00:05:19.522 --> 00:05:20.980
And secondly, for
users, they would

00:05:20.980 --> 00:05:22.896
have a consistent
experience across the board.

00:05:22.896 --> 00:05:24.740
So there will not be
case when the user will

00:05:24.740 --> 00:05:26.400
have two applications
that target

00:05:26.400 --> 00:05:28.900
the same types of devices.

00:05:28.900 --> 00:05:31.360
But when updated
our API library,

00:05:31.360 --> 00:05:34.060
now they can see more
devices than the other one.

00:05:34.060 --> 00:05:36.480
So if Weave application
is not installed,

00:05:36.480 --> 00:05:38.480
be prepared to handle an error.

00:05:38.480 --> 00:05:41.680
So the API will fail, and we
will give a special status

00:05:41.680 --> 00:05:43.260
code, RESOLUTION_REQUIRED.

00:05:43.260 --> 00:05:44.786
And this will also
include an intent

00:05:44.786 --> 00:05:45.910
that you'll need to launch.

00:05:45.910 --> 00:05:48.110
And we'll fix things
for you, so nothing else

00:05:48.110 --> 00:05:50.340
that you need to do here.

00:05:50.340 --> 00:05:52.540
So before you start
using WeaveApiClient,

00:05:52.540 --> 00:05:53.800
you need to configure it.

00:05:53.800 --> 00:05:55.390
When you build the
API client, there's

00:05:55.390 --> 00:05:57.830
two important properties
that you need to specify.

00:05:57.830 --> 00:06:00.150
First is you need to
add APIs that you're

00:06:00.150 --> 00:06:01.300
going to be working with.

00:06:01.300 --> 00:06:03.270
Now, there are
three APIs that we

00:06:03.270 --> 00:06:06.170
have, app access, device, and
command APIs, all of which

00:06:06.170 --> 00:06:08.720
I'm going to talk
in just a minute.

00:06:08.720 --> 00:06:10.530
You also need to supply
ConnectionCallbacks

00:06:10.530 --> 00:06:12.600
to the API client.

00:06:12.600 --> 00:06:14.320
And ConnectionCallbacks
is our way

00:06:14.320 --> 00:06:17.154
of telling you that APIs
are ready for consumption.

00:06:17.154 --> 00:06:18.820
Once you're done with
that, and once you

00:06:18.820 --> 00:06:23.520
have your API client set up,
you need to connect to it.

00:06:23.520 --> 00:06:26.290
When you do so, our
ConnectionCallbacks,

00:06:26.290 --> 00:06:27.750
there's an onConnected method.

00:06:27.750 --> 00:06:29.730
And at this point, this
means that Weave APIs

00:06:29.730 --> 00:06:30.820
are ready for consumption.

00:06:30.820 --> 00:06:33.499
Now again, all of this will be
familiar to those of you who

00:06:33.499 --> 00:06:34.790
are using Google Play services.

00:06:34.790 --> 00:06:36.498
And so the life cycle
is exactly the same

00:06:36.498 --> 00:06:40.300
as you would expect
from Google APIs.

00:06:40.300 --> 00:06:42.730
Once you're done
using WeaveApiClient,

00:06:42.730 --> 00:06:44.550
please disconnect from it.

00:06:44.550 --> 00:06:47.310
We did an onPause
here in this example.

00:06:47.310 --> 00:06:49.720
So working with Weave
devices, what does it involve?

00:06:49.720 --> 00:06:51.380
It's actually four steps.

00:06:51.380 --> 00:06:54.120
First is, you need to
ask user for permission

00:06:54.120 --> 00:06:58.127
to grant access to Weave
device for your application.

00:06:58.127 --> 00:06:59.960
Secondly, you need to
find the device you're

00:06:59.960 --> 00:07:01.310
going to be working with.

00:07:01.310 --> 00:07:03.470
Third is, you need to
get to know your device.

00:07:03.470 --> 00:07:06.090
Is in the right type of
device, is it ready for use,

00:07:06.090 --> 00:07:08.100
does it have the right
features, and so on.

00:07:08.100 --> 00:07:10.650
And fourth part is act,
which is send commands

00:07:10.650 --> 00:07:12.770
to your Weave device.

00:07:12.770 --> 00:07:14.220
Now, we're going
to walk over each

00:07:14.220 --> 00:07:16.030
of these steps in more details.

00:07:16.030 --> 00:07:17.920
So first is asking
for permission.

00:07:17.920 --> 00:07:20.300
Now, we defined a
permission model

00:07:20.300 --> 00:07:21.950
that will put user in control.

00:07:21.950 --> 00:07:24.520
And so before any
application tries

00:07:24.520 --> 00:07:28.581
to access any of user's devices,
it will need to request access.

00:07:28.581 --> 00:07:30.080
So what you will
need to say, you'll

00:07:30.080 --> 00:07:32.420
need to specify device type,
as you'll see in a moment,

00:07:32.420 --> 00:07:34.628
and what kind of role you'd
like to have in a device.

00:07:34.628 --> 00:07:36.900
And a user will be able
to see which devices he's

00:07:36.900 --> 00:07:39.250
willing to grant access to.

00:07:39.250 --> 00:07:42.230
So the way you do that is you
create an AppAccessRequest.

00:07:42.230 --> 00:07:43.859
And there's three
important fields

00:07:43.859 --> 00:07:44.900
that you need to fill in.

00:07:44.900 --> 00:07:47.560
First is, your role in a device
that you would like to get,

00:07:47.560 --> 00:07:49.800
whether it's a user, a
viewer, or a manager.

00:07:49.800 --> 00:07:52.380
Second one is types of devices
that your application is

00:07:52.380 --> 00:07:54.570
aware of and can interact with.

00:07:54.570 --> 00:07:58.319
And third one, you need to
supply us the project number

00:07:58.319 --> 00:08:00.360
that you will take from
Google Developer Console.

00:08:00.360 --> 00:08:02.580
And this is our way of
identifying your application

00:08:02.580 --> 00:08:04.520
for sending out requests.

00:08:04.520 --> 00:08:07.320
Now, there's a few caveats
of how you'd do that,

00:08:07.320 --> 00:08:09.490
so please minimize
the role that you

00:08:09.490 --> 00:08:12.320
request into the minimum
role that would allow you

00:08:12.320 --> 00:08:13.890
to cover all your use cases.

00:08:13.890 --> 00:08:15.990
Now, suppose you have
an application that

00:08:15.990 --> 00:08:19.470
shows temperature inside your
house, or uses read sensor data

00:08:19.470 --> 00:08:21.440
and displays the
temperature to a user.

00:08:21.440 --> 00:08:24.300
You probably do not want
to request manager access

00:08:24.300 --> 00:08:26.062
level to user's
devices, because it

00:08:26.062 --> 00:08:27.270
might be surprising for user.

00:08:27.270 --> 00:08:29.750
And as a rule of thumb,
do not surprise the user

00:08:29.750 --> 00:08:32.780
in ways he does not expect.

00:08:32.780 --> 00:08:36.100
Once you have the request, you
would use our app access APIs

00:08:36.100 --> 00:08:37.980
to request access.

00:08:37.980 --> 00:08:40.824
And if this succeeds,
will return an intent

00:08:40.824 --> 00:08:43.220
that you need to launch
in order for the user

00:08:43.220 --> 00:08:46.870
to go through authentication
flow for your application.

00:08:46.870 --> 00:08:48.850
At this point, please
make sure that you

00:08:48.850 --> 00:08:51.340
use startActivityForResult,
because that's

00:08:51.340 --> 00:08:54.080
the only way for us to know
the identity of the calling

00:08:54.080 --> 00:08:58.180
application and for you to see
the result of user's action.

00:08:58.180 --> 00:09:00.800
Otherwise, you'll
be in the blind.

00:09:00.800 --> 00:09:04.680
Once you have that, what you see
on the left side of this slide

00:09:04.680 --> 00:09:06.740
is authentication flow.

00:09:06.740 --> 00:09:09.120
So the user will see that
application such and such

00:09:09.120 --> 00:09:11.750
is requesting access to
these types of devices

00:09:11.750 --> 00:09:13.570
and requests this kind of role.

00:09:13.570 --> 00:09:17.400
Now, the user can selectively
choose which device he's

00:09:17.400 --> 00:09:18.650
willing to grant access to.

00:09:18.650 --> 00:09:23.520
Suppose there's the use case of
user and surveillance cameras

00:09:23.520 --> 00:09:25.460
application that is
requesting access

00:09:25.460 --> 00:09:27.810
to view his cameras with
some cloud solution.

00:09:27.810 --> 00:09:31.600
So the user might be OK to
try this new application

00:09:31.600 --> 00:09:33.182
with his outside
cameras, but not

00:09:33.182 --> 00:09:34.640
so sure about
whether he would want

00:09:34.640 --> 00:09:37.510
to grant access to his
bedroom cameras and so on.

00:09:37.510 --> 00:09:39.580
So he would be able
to selectively choose

00:09:39.580 --> 00:09:41.330
which devices he's
willing to grant access

00:09:41.330 --> 00:09:42.290
to your application.

00:09:42.290 --> 00:09:44.810
And also, possibly, if you
request manager level of access

00:09:44.810 --> 00:09:46.730
for, like I said,
to a monitor app,

00:09:46.730 --> 00:09:48.970
the user will be able
to say, that's not

00:09:48.970 --> 00:09:49.970
what I would like to do.

00:09:49.970 --> 00:09:51.970
I would like to only give
a viewer access level,

00:09:51.970 --> 00:09:54.400
because that's what it seems
like this application does.

00:09:54.400 --> 00:09:56.500
And that's the sufficient level.

00:09:56.500 --> 00:09:57.990
At any point in
time in the future,

00:09:57.990 --> 00:10:02.200
the user will be able to go to
Weave application and update

00:10:02.200 --> 00:10:04.414
the settings for any
particular application.

00:10:04.414 --> 00:10:05.830
So he would be
able to add device.

00:10:05.830 --> 00:10:08.220
He would be able to update
access level for existing

00:10:08.220 --> 00:10:10.490
devices, and so on.

00:10:10.490 --> 00:10:14.400
Once the user
acknowledges his choice.

00:10:14.400 --> 00:10:16.780
Your application will
receive RESULT_OK

00:10:16.780 --> 00:10:19.530
as a result of
[INAUDIBLE] execution.

00:10:19.530 --> 00:10:21.920
And this means that
user made his choice,

00:10:21.920 --> 00:10:24.240
and you're free to
start device discovery.

00:10:24.240 --> 00:10:27.410
And selected devices will
appear in your application.

00:10:27.410 --> 00:10:30.470
Now, we build application
permission model

00:10:30.470 --> 00:10:32.820
in a similar way to
Android's runtime permission.

00:10:32.820 --> 00:10:35.300
And so it has the
same caveats of usage

00:10:35.300 --> 00:10:37.730
that you would expect
from runtime permissions.

00:10:37.730 --> 00:10:41.690
First one is, if the user said
no, do not just request it

00:10:41.690 --> 00:10:42.580
again.

00:10:42.580 --> 00:10:44.880
Make sure the user
understands the choice.

00:10:44.880 --> 00:10:47.320
If your application
works with Weave devices,

00:10:47.320 --> 00:10:50.410
but the feature is not
really obvious at this point,

00:10:50.410 --> 00:10:52.190
try to educate the
user so that, when

00:10:52.190 --> 00:10:54.350
he sees the screen
with a permission,

00:10:54.350 --> 00:10:55.910
it's not a surprise for him.

00:10:55.910 --> 00:10:58.200
If he says no-- and this
is a critical feature

00:10:58.200 --> 00:11:00.940
of your application-- again,
don't just request access

00:11:00.940 --> 00:11:01.880
again.

00:11:01.880 --> 00:11:03.480
Try to explain to
the user why you

00:11:03.480 --> 00:11:08.150
would need to request
access to his device again.

00:11:08.150 --> 00:11:11.240
The only exception to that rule
of not asking multiple times

00:11:11.240 --> 00:11:13.630
is when you would
update your application

00:11:13.630 --> 00:11:14.970
with some new features.

00:11:14.970 --> 00:11:17.900
Now, if you take the
example of thermometer app,

00:11:17.900 --> 00:11:19.550
suppose you can
now not only read

00:11:19.550 --> 00:11:20.966
the temperature
inside your house,

00:11:20.966 --> 00:11:23.570
but it can also set the
temperature on a thermostat.

00:11:23.570 --> 00:11:26.751
So all of a sudden, your
application cannot be a viewer

00:11:26.751 --> 00:11:27.250
of device.

00:11:27.250 --> 00:11:29.550
He needs to be user,
because you need to set

00:11:29.550 --> 00:11:30.989
the temperature for a device.

00:11:30.989 --> 00:11:33.030
At this point, when you
have elevated permission,

00:11:33.030 --> 00:11:34.990
you might ask for access again.

00:11:34.990 --> 00:11:36.540
And again, use
your best judgment,

00:11:36.540 --> 00:11:38.456
whether you would like
to educate the user why

00:11:38.456 --> 00:11:40.240
you're doing that or not.

00:11:40.240 --> 00:11:42.510
And the second case
is, again, when

00:11:42.510 --> 00:11:45.780
you have a feature
that would allow

00:11:45.780 --> 00:11:48.870
you to extend your
support of Weave device

00:11:48.870 --> 00:11:51.840
to multiple device type that
were not previously present.

00:11:51.840 --> 00:11:53.347
So at this point,
you can say, hey,

00:11:53.347 --> 00:11:55.430
I would like to request
access to those new device

00:11:55.430 --> 00:11:58.460
types that now supported.

00:11:58.460 --> 00:12:00.730
Now, OK, we got
it out of the way.

00:12:00.730 --> 00:12:03.130
And the user said, yes,
please use my devices.

00:12:03.130 --> 00:12:04.520
You need to discover those.

00:12:04.520 --> 00:12:06.650
So for this, we
have discovery APIs

00:12:06.650 --> 00:12:09.080
as part of our device APIs.

00:12:09.080 --> 00:12:11.960
To use those, you would
call the startLoading method

00:12:11.960 --> 00:12:13.010
and supply a callback.

00:12:13.010 --> 00:12:16.210
And this callback
will be receiving

00:12:16.210 --> 00:12:18.850
a snapshot of all devices
that are available to you.

00:12:18.850 --> 00:12:21.250
Now, those would be cloud
devices, local device.

00:12:21.250 --> 00:12:23.730
And you should never care
about which type of device

00:12:23.730 --> 00:12:26.560
you're working with, as long as
the semantics is right for you.

00:12:26.560 --> 00:12:29.500
When you're done with
discovery, you call stopLoading.

00:12:29.500 --> 00:12:32.440
And this will free up some
resource for the user.

00:12:32.440 --> 00:12:35.700
Now to reiterate that, discovery
a very expensive operation.

00:12:35.700 --> 00:12:37.550
So we might use multiple
sensors on a device

00:12:37.550 --> 00:12:38.280
to discover a device.

00:12:38.280 --> 00:12:39.220
We might send requests.

00:12:39.220 --> 00:12:40.250
We might use cloud connection.

00:12:40.250 --> 00:12:41.500
We might use local connection.

00:12:41.500 --> 00:12:42.950
We might use
Bluetooth, and so on.

00:12:42.950 --> 00:12:46.840
So as soon as you don't need
it, please stop the discovery

00:12:46.840 --> 00:12:49.420
and save up some resources.

00:12:49.420 --> 00:12:51.080
Devices are also
returning a buffer.

00:12:51.080 --> 00:12:53.020
And one thing I'd
like to point here

00:12:53.020 --> 00:12:55.430
is that, as soon as you
don't need the buffer,

00:12:55.430 --> 00:12:56.770
please release it.

00:12:56.770 --> 00:12:58.100
It will save up some resource.

00:12:58.100 --> 00:12:59.847
But before you do so,
make sure that you

00:12:59.847 --> 00:13:01.430
freeze all devices
that you would like

00:13:01.430 --> 00:13:04.090
to still maintain access to.

00:13:04.090 --> 00:13:06.654
So suppose you have
thousands of devices

00:13:06.654 --> 00:13:08.570
that you can have access
to, but you only care

00:13:08.570 --> 00:13:10.170
about one particular device.

00:13:10.170 --> 00:13:13.600
It might be a good way to
just freeze this one device

00:13:13.600 --> 00:13:15.790
and freeze the buffer with
the rest of the devices,

00:13:15.790 --> 00:13:18.710
so you could save up some memory
and provide better experience

00:13:18.710 --> 00:13:21.500
for all users.

00:13:21.500 --> 00:13:24.210
Now that you have your device,
what you would like to know

00:13:24.210 --> 00:13:28.740
is you would like to know what
this device can do for you.

00:13:28.740 --> 00:13:30.170
Does it have the right features?

00:13:30.170 --> 00:13:32.480
Can it executive some of
the commands on the device?

00:13:32.480 --> 00:13:33.580
Is it of the right type?

00:13:33.580 --> 00:13:34.960
Is it ready, and so on.

00:13:34.960 --> 00:13:37.320
And for this, you would
need to get some information

00:13:37.320 --> 00:13:38.340
about a device.

00:13:38.340 --> 00:13:39.990
There's two main
components to that

00:13:39.990 --> 00:13:42.020
that we define as part
of Weave protocol.

00:13:42.020 --> 00:13:45.310
One is command definitions, and
the other one is device state.

00:13:45.310 --> 00:13:48.460
I'm going to talk
about both of those,

00:13:48.460 --> 00:13:50.980
starting with
command definitions.

00:13:50.980 --> 00:13:53.180
So command definitions
are our way

00:13:53.180 --> 00:13:55.630
of describing what
device can do for you,

00:13:55.630 --> 00:13:57.190
so what kind of
commands it supports,

00:13:57.190 --> 00:13:59.184
what kind of parameters
do those commands take,

00:13:59.184 --> 00:14:00.600
do you have
sufficient permissions

00:14:00.600 --> 00:14:03.090
or sufficient access level to
a device in order to execute

00:14:03.090 --> 00:14:04.510
this command.

00:14:04.510 --> 00:14:06.530
Let's take jump
command as an example

00:14:06.530 --> 00:14:09.600
here that you can
see on this slide.

00:14:09.600 --> 00:14:11.310
So as you can see,
this jump command

00:14:11.310 --> 00:14:13.860
requires you to be at
least a user on the device.

00:14:13.860 --> 00:14:15.820
And it has a single
parameter, called height,

00:14:15.820 --> 00:14:16.910
which is an integer.

00:14:16.910 --> 00:14:19.170
And it takes values
from 1 to 100.

00:14:19.170 --> 00:14:22.590
Now, based on the
command definition alone,

00:14:22.590 --> 00:14:24.730
you can build up a UI
to execute any command

00:14:24.730 --> 00:14:27.670
on any Weave-enabled
device that you would like.

00:14:27.670 --> 00:14:29.870
But to help you a
little bit, in here,

00:14:29.870 --> 00:14:32.780
we're grouping command
definitions into packages.

00:14:32.780 --> 00:14:35.010
And so packages are
per device type.

00:14:35.010 --> 00:14:36.910
Now, they can be a,
say, base package,

00:14:36.910 --> 00:14:39.960
which is applicable to all
device types out there.

00:14:39.960 --> 00:14:42.656
And it would contain
commands that absolutely

00:14:42.656 --> 00:14:44.280
must be implemented
by any device type,

00:14:44.280 --> 00:14:47.160
say rename command, or
something like this.

00:14:47.160 --> 00:14:48.970
For you camera
manufacturers, there

00:14:48.970 --> 00:14:50.500
can be a camera
package that will

00:14:50.500 --> 00:14:55.140
contain specific commands that
can be executed on a camera.

00:14:55.140 --> 00:14:59.940
Say ISO setting, or file size,
or [INAUDIBLE] versus JPEG

00:14:59.940 --> 00:15:01.216
output, and so on.

00:15:01.216 --> 00:15:02.590
Now, for any
package, there would

00:15:02.590 --> 00:15:03.780
be some standard commands.

00:15:03.780 --> 00:15:05.910
And there would be
custom commands.

00:15:05.910 --> 00:15:08.030
So any package is
extensible, but there's

00:15:08.030 --> 00:15:12.730
a core set of commands that
any device of a particular type

00:15:12.730 --> 00:15:16.980
needs to implement in order
to be called, say, a camera.

00:15:16.980 --> 00:15:20.910
So based on that, you might
be able to build a UI that

00:15:20.910 --> 00:15:22.200
works for your application.

00:15:22.200 --> 00:15:23.783
And if you are a
manufacturer, and you

00:15:23.783 --> 00:15:26.241
know of some advanced
capabilities of your devices,

00:15:26.241 --> 00:15:28.740
we would provide those as well,
as part command definitions.

00:15:28.740 --> 00:15:30.950
You would be able
to build up a better

00:15:30.950 --> 00:15:32.600
experience for the users.

00:15:32.600 --> 00:15:34.180
So to get those
command definitions,

00:15:34.180 --> 00:15:36.900
you would use command APIs,
GetCommandDefinitions,

00:15:36.900 --> 00:15:38.280
and supply device ID.

00:15:38.280 --> 00:15:42.512
Now, you might notice any
API that works with devices,

00:15:42.512 --> 00:15:43.970
or to get some info
about a device,

00:15:43.970 --> 00:15:45.011
will take just Device ID.

00:15:45.011 --> 00:15:48.620
So you don't need to keep the
entire device resource alive,

00:15:48.620 --> 00:15:52.710
in order to execute
further API calls.

00:15:52.710 --> 00:15:54.680
So the second part
is DeviceState.

00:15:54.680 --> 00:15:58.380
And DeviceState would describe
what device looks like,

00:15:58.380 --> 00:16:00.090
what's going on with this now.

00:16:00.090 --> 00:16:03.310
Now, this can be as simple as
some statistics about device,

00:16:03.310 --> 00:16:05.700
such as on/off state
or battery percentage.

00:16:05.700 --> 00:16:09.220
Or this can be more
complicated or more structured

00:16:09.220 --> 00:16:11.350
information about a
particular device type.

00:16:11.350 --> 00:16:13.720
Say, for cameras, there
would be a light sensitivity.

00:16:13.720 --> 00:16:17.870
And you could use, again, device
APIs to get this device state,

00:16:17.870 --> 00:16:20.810
using the getDeviceState method.

00:16:20.810 --> 00:16:22.680
So now, on to the fun part.

00:16:22.680 --> 00:16:24.600
So you found your device.

00:16:24.600 --> 00:16:25.850
You know what it's capable of.

00:16:25.850 --> 00:16:27.344
You know it fits your criteria.

00:16:27.344 --> 00:16:29.260
And you would like to
execute a command on it.

00:16:29.260 --> 00:16:31.610
For this, we have
command execution APIs.

00:16:31.610 --> 00:16:34.200
Now, when you want
to execute a command,

00:16:34.200 --> 00:16:36.550
you would build it based
on the command definition

00:16:36.550 --> 00:16:38.710
that you read earlier.

00:16:38.710 --> 00:16:41.400
If you know that your target
in a particular type of device,

00:16:41.400 --> 00:16:43.613
say, a thermometer, a
light, or so on-- say,

00:16:43.613 --> 00:16:47.570
a light, you know it does
have a command, on/off.

00:16:47.570 --> 00:16:51.914
So you technically don't need to
execute GetCommandDefinitions,

00:16:51.914 --> 00:16:54.080
if you only want to build
a very simple application.

00:16:54.080 --> 00:16:55.110
You could just
construct a command,

00:16:55.110 --> 00:16:57.540
because you know there is
a standard set of commands

00:16:57.540 --> 00:16:59.690
that every light
bulb will support.

00:16:59.690 --> 00:17:01.240
You would do so
by setting a name.

00:17:01.240 --> 00:17:05.290
So in our example there was
jump or setLight, for light.

00:17:05.290 --> 00:17:06.790
And you would add
a parameter, which

00:17:06.790 --> 00:17:09.800
is PARAMETER_NAME
PARAMETER_VALUE, to the command

00:17:09.800 --> 00:17:10.690
and build that.

00:17:10.690 --> 00:17:12.859
Once you have the command,
you will use command APIs

00:17:12.859 --> 00:17:13.950
in order to execute that.

00:17:13.950 --> 00:17:15.658
You will supply device
ID in this command

00:17:15.658 --> 00:17:19.270
that you just constructed
and send it over to a device.

00:17:19.270 --> 00:17:22.790
So command execution is
not an immediate process.

00:17:22.790 --> 00:17:24.690
And so things will take time.

00:17:24.690 --> 00:17:26.329
Some things can go wrong.

00:17:26.329 --> 00:17:27.810
It might be due to user error.

00:17:27.810 --> 00:17:29.689
It might be due to
some device state.

00:17:29.689 --> 00:17:31.480
It might be due to
connectivity, and so on.

00:17:31.480 --> 00:17:35.600
And so you might
want to check what's

00:17:35.600 --> 00:17:37.730
going on with the
command that I just sent.

00:17:37.730 --> 00:17:41.940
And for this, we
supply a get method

00:17:41.940 --> 00:17:44.970
that will give you command
information about any command

00:17:44.970 --> 00:17:46.780
that you send for execution.

00:17:46.780 --> 00:17:50.700
Now, it takes CommandInfo
getID, which is ID of a command.

00:17:50.700 --> 00:17:53.080
And you will receive that
when you insert a command

00:17:53.080 --> 00:17:55.751
for execution onto a device.

00:17:55.751 --> 00:17:56.250
OK.

00:17:56.250 --> 00:17:58.660
So to reiterate that,
there's four things

00:17:58.660 --> 00:18:01.410
that you need to do
in order to build

00:18:01.410 --> 00:18:04.190
a functional application that
works with any Weave device.

00:18:04.190 --> 00:18:06.020
First is, you need to
ask user permission,

00:18:06.020 --> 00:18:07.460
and only do it once.

00:18:07.460 --> 00:18:09.470
Secondly, you need
to find device

00:18:09.470 --> 00:18:12.880
you're going to work with
and shut down discovery soon

00:18:12.880 --> 00:18:14.530
as you don't need it.

00:18:14.530 --> 00:18:16.460
Third is, get to
know your device.

00:18:16.460 --> 00:18:17.020
Is it ready?

00:18:17.020 --> 00:18:18.353
Does it have the right features?

00:18:18.353 --> 00:18:19.630
What can I do with that?

00:18:19.630 --> 00:18:24.310
And fourth is, act on
your device, which is just

00:18:24.310 --> 00:18:25.740
create a command
and send it over

00:18:25.740 --> 00:18:27.830
for execution on your device.

00:18:27.830 --> 00:18:31.210
Now with that, I think
that's all for our session.

00:18:31.210 --> 00:18:33.370
As Liza mentioned, we'll
have code labs tomorrow

00:18:33.370 --> 00:18:37.340
where you'd be able to get
your hands on our new APIs

00:18:37.340 --> 00:18:40.490
and try it yourself and build
a functional Weave application.

00:18:40.490 --> 00:18:44.757
So within an hour, you should
be up and running and working

00:18:44.757 --> 00:18:46.090
with any Weave device out there.

00:18:46.090 --> 00:18:47.310
So I encourage you to attend.

00:18:47.310 --> 00:18:49.840
And thank you, for
your attention.

00:18:49.840 --> 00:18:51.040
[APPLAUSE]

00:18:51.940 --> 00:19:00.990
[MUSIC PLAYING]

