WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.844
[MUSIC PLAYING]

00:00:07.297 --> 00:00:09.380
CHRIS CRAIK: Hey, I'm Chris
Craik from the Android

00:00:09.380 --> 00:00:10.530
framework team.

00:00:10.530 --> 00:00:11.780
YIGIT BOYER: My name is Yigit.

00:00:11.780 --> 00:00:14.670
I also work in the
Android framework team,

00:00:14.670 --> 00:00:17.145
and today, we are
going to talk about how

00:00:17.145 --> 00:00:23.080
to handle large lists with
paging and RecyclerView.

00:00:23.080 --> 00:00:26.800
Now, list UI is a very common
thing in Android applications.

00:00:26.800 --> 00:00:30.190
Pretty much every single
app has a list of something

00:00:30.190 --> 00:00:32.180
they want to display.

00:00:32.180 --> 00:00:34.360
So if you're using
architecture components,

00:00:34.360 --> 00:00:38.340
let's see how you would
model a list like this.

00:00:38.340 --> 00:00:40.010
So you'll have a
view model where

00:00:40.010 --> 00:00:43.840
you keep the list of items so
that it survives configuration

00:00:43.840 --> 00:00:45.160
change.

00:00:45.160 --> 00:00:47.650
You put your data
into the database

00:00:47.650 --> 00:00:50.560
so that your application
works offline.

00:00:50.560 --> 00:00:52.995
And of course, you have
some server side component

00:00:52.995 --> 00:00:55.840
where you pull the data from.

00:00:55.840 --> 00:00:58.310
But usually, data is dynamic.

00:00:58.310 --> 00:00:59.740
It changes.

00:00:59.740 --> 00:01:03.440
So to handle these changes,
you will ask database

00:01:03.440 --> 00:01:06.580
to return your LiveData
of list of things

00:01:06.580 --> 00:01:10.250
or an observable list
of things so that you

00:01:10.250 --> 00:01:12.910
can handle the updates.

00:01:12.910 --> 00:01:15.640
For instance, if you
pulled the updated version

00:01:15.640 --> 00:01:18.660
of two records
from your database,

00:01:18.660 --> 00:01:21.620
and you inserted and
then Room realizes,

00:01:21.620 --> 00:01:25.000
oh, there's a query
observing this table,

00:01:25.000 --> 00:01:28.950
let me reveal the result,
paste it over to the ViewModel,

00:01:28.950 --> 00:01:32.340
and then your UI can
pull from the ViewModel

00:01:32.340 --> 00:01:36.100
and update itself with
the correct animations.

00:01:36.100 --> 00:01:41.110
This looks cool, but there
is actually a problem here.

00:01:41.110 --> 00:01:42.940
There's something we don't like.

00:01:42.940 --> 00:01:45.490
To better understand
the issue, let's look

00:01:45.490 --> 00:01:50.530
at the interaction between
the database and the UI.

00:01:50.530 --> 00:01:55.360
So when I mention that database
is going to rebuild the result,

00:01:55.360 --> 00:01:58.140
it is going to rebuild
all of the results.

00:01:58.140 --> 00:02:03.100
So if you ask for the user's
order by their last name,

00:02:03.100 --> 00:02:05.620
and if you have
10,000 users, it's

00:02:05.620 --> 00:02:10.389
going to create 10,000 users,
paste it over to the UI,

00:02:10.389 --> 00:02:12.990
and it's very inefficient
because user only

00:02:12.990 --> 00:02:15.010
sees 8 to 10 items.

00:02:15.010 --> 00:02:18.400
Why would you
create 10,000 items?

00:02:18.400 --> 00:02:19.990
So we don't like it.

00:02:19.990 --> 00:02:21.430
We want to change this.

00:02:21.430 --> 00:02:24.040
So what are we looking for here?

00:02:24.040 --> 00:02:26.140
First, we like that convenience.

00:02:26.140 --> 00:02:28.700
It's so nice to
tell the database,

00:02:28.700 --> 00:02:31.250
give me a LiveData
of list of users.

00:02:31.250 --> 00:02:34.720
We want the same convenience.

00:02:34.720 --> 00:02:36.535
We want it to handle
multiple layers.

00:02:36.535 --> 00:02:39.340
We want to be able to
bring data from the server,

00:02:39.340 --> 00:02:42.390
put it in the database,
and put in the UI.

00:02:42.390 --> 00:02:45.430
And this should be
very easy to implement.

00:02:45.430 --> 00:02:47.240
We want it to be fast.

00:02:47.240 --> 00:02:49.460
We don't want it to do
any unnecessary work.

00:02:49.460 --> 00:02:52.750
We don't want it to do any big
chunk of work in the UI thread.

00:02:52.750 --> 00:02:55.240
It should be efficient.

00:02:55.240 --> 00:02:57.070
We want it to be
lifecycle aware.

00:02:57.070 --> 00:02:59.350
So if user's not
looking at the screen,

00:02:59.350 --> 00:03:01.870
it shouldn't do any work.

00:03:01.870 --> 00:03:05.020
Last but not least, we
want it to be flexible.

00:03:05.020 --> 00:03:08.500
Everybody has their different
back end APIs, different data

00:03:08.500 --> 00:03:09.640
structures.

00:03:09.640 --> 00:03:13.840
Our solution should work
with all of these things.

00:03:13.840 --> 00:03:16.450
Now, if we go back
to our first example,

00:03:16.450 --> 00:03:20.440
how do we implement these
lists if we don't use paging?

00:03:20.440 --> 00:03:24.360
If you're using Room in your
Dao, you specify your query.

00:03:24.360 --> 00:03:28.530
You tell it to return a
LiveData of list of users.

00:03:28.530 --> 00:03:31.720
Now, in your ViewModel,
you hold a reference to it

00:03:31.720 --> 00:03:33.635
and serve it to your UI.

00:03:33.635 --> 00:03:37.120
In your activity, you will
use this list activity-- list

00:03:37.120 --> 00:03:39.130
adapter clause,
but if you're not

00:03:39.130 --> 00:03:41.260
following our
releases closely, you

00:03:41.260 --> 00:03:42.890
may not have heard about it.

00:03:42.890 --> 00:03:44.540
Let's focus on that one.

00:03:44.540 --> 00:03:49.360
ListAdapter is a RecyclerView
adapter that displays a list.

00:03:49.360 --> 00:03:52.840
So if you have the
RecyclerView on the right, when

00:03:52.840 --> 00:03:55.500
you call sumbitList
method on the adapter,

00:03:55.500 --> 00:03:57.530
it just displays it.

00:03:57.530 --> 00:04:00.220
The nice thing is, if you
pull the same submitList

00:04:00.220 --> 00:04:02.430
method with a
different list, it's

00:04:02.430 --> 00:04:04.900
going to calculate the
difference between these two

00:04:04.900 --> 00:04:07.930
lists on a background
thread and update the UI

00:04:07.930 --> 00:04:10.130
with the correct animations.

00:04:10.130 --> 00:04:13.580
This is available in
RecyclerView 27.1,

00:04:13.580 --> 00:04:17.100
and the same function also
exists in the AsyncListDiffer

00:04:17.100 --> 00:04:21.000
class if you cannot
extend the adapter.

00:04:21.000 --> 00:04:22.890
Let's go back to our example.

00:04:22.890 --> 00:04:24.640
We have our adapter.

00:04:24.640 --> 00:04:26.460
We observed the LiveData.

00:04:26.460 --> 00:04:29.470
We send the list to the adapter.

00:04:29.470 --> 00:04:31.890
So for when we
initialize the adapter,

00:04:31.890 --> 00:04:34.680
we need to give it a callback.

00:04:34.680 --> 00:04:36.330
So let's do functionalities.

00:04:36.330 --> 00:04:41.310
First, it can check if two
items are equal identically,

00:04:41.310 --> 00:04:44.310
and the other one checks
whether their contents are equal

00:04:44.310 --> 00:04:44.860
or not.

00:04:44.860 --> 00:04:50.340
So we can decide whether we need
to remind those views or not.

00:04:50.340 --> 00:04:53.130
Once you have that, your
onBindViewHolder method,

00:04:53.130 --> 00:04:55.590
you can call the
getItem function,

00:04:55.590 --> 00:04:59.100
obtain the item in the list, and
do whatever you want with it.

00:04:59.100 --> 00:04:59.870
Super simple.

00:05:02.465 --> 00:05:03.840
CHRIS CRAIK: All
right, so we see

00:05:03.840 --> 00:05:06.200
what that looks like
with a LiveData of list,

00:05:06.200 --> 00:05:08.750
but you also started out with--

00:05:08.750 --> 00:05:09.750
this isn't good enough.

00:05:09.750 --> 00:05:11.791
So let's look at what this
looks like when you're

00:05:11.791 --> 00:05:14.286
using new Paging library.

00:05:14.286 --> 00:05:16.160
So first of all, the
most important component

00:05:16.160 --> 00:05:18.830
of the Paging library
is the PagedLists,

00:05:18.830 --> 00:05:22.250
and this is a list that
implements the listed or face,

00:05:22.250 --> 00:05:26.030
but it loads data in
pages asynchronously.

00:05:26.030 --> 00:05:29.210
It's backed by a class called a
data source that provides data

00:05:29.210 --> 00:05:36.000
as the page list needs it, swaps
it in, and updates the list.

00:05:36.000 --> 00:05:38.230
So this serves as a
replacement for the list

00:05:38.230 --> 00:05:40.067
in all the examples
that we've done before.

00:05:40.067 --> 00:05:41.900
So let's go ahead and
start swapping it out.

00:05:41.900 --> 00:05:43.430
We have this ViewModel.

00:05:43.430 --> 00:05:47.330
Let's swap out the
list with a PagedList,

00:05:47.330 --> 00:05:48.650
and then we go back to our Dao.

00:05:48.650 --> 00:05:50.941
Now, what we want to do here
is we want to ask our Dao,

00:05:50.941 --> 00:05:53.990
hey, can you give me a
LiveData of a PagedList?

00:05:53.990 --> 00:05:57.790
But there's actually
an issue with this.

00:05:57.790 --> 00:06:01.710
So if we look over at what the
data looks like on the database

00:06:01.710 --> 00:06:04.800
side, you could imagine
paging this in one way,

00:06:04.800 --> 00:06:07.150
and you could imagine paging
this in a different way.

00:06:07.150 --> 00:06:09.240
There's actually some
interesting decision here.

00:06:09.240 --> 00:06:11.000
Are you showing
really large items?

00:06:11.000 --> 00:06:12.420
Are you showing
tiny items, or you

00:06:12.420 --> 00:06:14.300
want to have a lot of
data paged at once?

00:06:14.300 --> 00:06:18.810
Well, the page size really needs
to be configurable to serve

00:06:18.810 --> 00:06:20.430
every app's needs.

00:06:20.430 --> 00:06:23.340
So instead, Room can produce
this data source class that

00:06:23.340 --> 00:06:26.250
backs a PagedList, and
that way, the PagedList

00:06:26.250 --> 00:06:30.060
can access it and say,
give me item 6 through 12

00:06:30.060 --> 00:06:34.187
and load those data
directly into the PagedList.

00:06:34.187 --> 00:06:36.270
Now, because we say that
we want multiple of them,

00:06:36.270 --> 00:06:38.728
though-- remember that we want
something that's observable,

00:06:38.728 --> 00:06:40.200
so we just wrap
that in a factory.

00:06:40.200 --> 00:06:43.470
Every time that we need a new
PagedList out of the database,

00:06:43.470 --> 00:06:45.950
we create a new data source.

00:06:45.950 --> 00:06:49.050
All right, so instead of
the LiveData of PagedList,

00:06:49.050 --> 00:06:52.110
what the user now
provides us here

00:06:52.110 --> 00:06:55.870
is a data source factory
keyed off of Integer

00:06:55.870 --> 00:06:59.130
because we're using positions.

00:06:59.130 --> 00:07:02.340
So we go back to
our ViewModel here

00:07:02.340 --> 00:07:05.169
and define how are we
going to load this data.

00:07:05.169 --> 00:07:06.210
Well, it's not much code.

00:07:06.210 --> 00:07:08.250
We just say get the
data source factory

00:07:08.250 --> 00:07:10.350
that we just declared
in our user Dao

00:07:10.350 --> 00:07:12.900
and use this live
PagedListBuilder class

00:07:12.900 --> 00:07:15.852
from the library to
create a LiveData.

00:07:15.852 --> 00:07:18.060
The minimum amount of data
that you need to pass here

00:07:18.060 --> 00:07:19.140
is page size.

00:07:19.140 --> 00:07:20.880
And here, we're passing 30.

00:07:20.880 --> 00:07:21.480
That's it.

00:07:21.480 --> 00:07:25.470
Now, you have a
LiveData of PagedList.

00:07:25.470 --> 00:07:28.260
So now, all of the repository
side changes are done.

00:07:28.260 --> 00:07:29.350
The ViewModel's updated.

00:07:29.350 --> 00:07:31.270
Let's go to the activity.

00:07:31.270 --> 00:07:33.390
So now, we were using
listAdapter before.

00:07:33.390 --> 00:07:36.210
Well, simply you change this
into a PagedListAdapter.

00:07:36.210 --> 00:07:39.150
A PagedListAdapter is the exact
same thing as listAdapter.

00:07:39.150 --> 00:07:42.420
It just happens to handle
the loading of pages

00:07:42.420 --> 00:07:45.360
as content is internally
updating in those page lists.

00:07:49.640 --> 00:07:52.570
So if we look at how we'd
actually implement this list

00:07:52.570 --> 00:07:55.750
adapter, though, we'd
have to switch over

00:07:55.750 --> 00:08:00.321
to the new PagedListAdapter
and use the exact same diff

00:08:00.321 --> 00:08:00.820
callback.

00:08:00.820 --> 00:08:02.270
We don't have to
change any code there.

00:08:02.270 --> 00:08:03.880
The only thing that
changes as part

00:08:03.880 --> 00:08:05.710
of implementing this
on the adapter side

00:08:05.710 --> 00:08:08.650
is that the user object
becomes nullable,

00:08:08.650 --> 00:08:12.050
and we'll get into why
in just a little bit.

00:08:12.050 --> 00:08:14.750
So let's go through how you
can do further configuration,

00:08:14.750 --> 00:08:17.980
because we don't stop
at just page size.

00:08:17.980 --> 00:08:22.060
So the code that we showed
before of creating a live

00:08:22.060 --> 00:08:24.820
PagedListBuilder-- you can
simply just pass a minimum

00:08:24.820 --> 00:08:25.480
page--

00:08:25.480 --> 00:08:27.563
a page size, and that's
the minimum amount of data

00:08:27.563 --> 00:08:28.610
that you need to pass.

00:08:28.610 --> 00:08:31.120
But you can also create
a configuration object

00:08:31.120 --> 00:08:32.747
where you can declare more.

00:08:32.747 --> 00:08:34.330
So one thing that
you might want to do

00:08:34.330 --> 00:08:37.270
is set an initial load size
hint, and this-- what this does

00:08:37.270 --> 00:08:40.090
is it requests that the
initial load is larger

00:08:40.090 --> 00:08:43.780
to make that initial load
avoid initial page fetches

00:08:43.780 --> 00:08:46.540
immediately after
you've fetched it.

00:08:46.540 --> 00:08:48.970
Another thing that you can
change is prefetch distance.

00:08:48.970 --> 00:08:50.530
By default, this
is the page size,

00:08:50.530 --> 00:08:51.905
but you can
configure this if you

00:08:51.905 --> 00:08:55.930
know that your data source
is higher or lower latency.

00:08:55.930 --> 00:08:57.850
You can also control
placeholders,

00:08:57.850 --> 00:08:59.920
which are an important
part of this library,

00:08:59.920 --> 00:09:02.380
so let's start
talking about those.

00:09:02.380 --> 00:09:06.490
So Placeholders False is
kind of the default paging

00:09:06.490 --> 00:09:07.750
that you might have--

00:09:07.750 --> 00:09:09.574
the expectation
that you might have,

00:09:09.574 --> 00:09:11.240
where typically you
load the first page.

00:09:11.240 --> 00:09:14.250
The RecyclerView has access
to the number of items

00:09:14.250 --> 00:09:16.000
that you've loaded,
and you see, well, you

00:09:16.000 --> 00:09:17.200
have a big scroll bar.

00:09:17.200 --> 00:09:19.270
The user can scroll
through it, and once they

00:09:19.270 --> 00:09:21.730
get to the bottom,
there's no more data.

00:09:21.730 --> 00:09:24.790
Once the page loads,
the scroll bar jumps,

00:09:24.790 --> 00:09:27.107
and the user is able
to scroll forward.

00:09:27.107 --> 00:09:29.440
So we also support a completely
different type of paging

00:09:29.440 --> 00:09:31.446
here that presents
this differently.

00:09:31.446 --> 00:09:33.070
If you asked for
placeholders, and this

00:09:33.070 --> 00:09:36.100
is the default in the library,
we will present your lists

00:09:36.100 --> 00:09:36.931
like this.

00:09:36.931 --> 00:09:39.430
You notice here that the scroll
bar is a little bit smaller,

00:09:39.430 --> 00:09:40.888
and that's because
we're presenting

00:09:40.888 --> 00:09:43.670
the entire data set to the
RecyclerView immediately.

00:09:43.670 --> 00:09:46.030
That scroll bar won't jump
while we're scrolling.

00:09:46.030 --> 00:09:48.160
As the user scrolls
down, you see

00:09:48.160 --> 00:09:50.890
that there are unloaded
items, and those are presented

00:09:50.890 --> 00:09:53.240
as nulls in the adapter.

00:09:53.240 --> 00:09:56.140
These items, as the
data eventually loads,

00:09:56.140 --> 00:10:00.206
display, and you'll get a
nice animation for that.

00:10:00.206 --> 00:10:02.080
So let's talk about
placeholders because they

00:10:02.080 --> 00:10:04.371
don't work everywhere, but
we think that they're really

00:10:04.371 --> 00:10:05.692
useful in a lot of cases.

00:10:05.692 --> 00:10:07.150
So one of the big
positives of them

00:10:07.150 --> 00:10:09.850
is that the user can
scroll past what's loaded.

00:10:09.850 --> 00:10:12.520
The user doesn't have to
hit a block at the very end

00:10:12.520 --> 00:10:14.820
because you don't have
any more data yet.

00:10:14.820 --> 00:10:16.771
The scroll bar looks
correct instantly,

00:10:16.771 --> 00:10:18.270
and also this is
very important, you

00:10:18.270 --> 00:10:20.110
can use fast
scroller very easily

00:10:20.110 --> 00:10:22.780
because you have the
entire data set presented

00:10:22.780 --> 00:10:26.442
to the RecyclerView so
you can jump anywhere.

00:10:26.442 --> 00:10:28.150
And then another nice
feature is that you

00:10:28.150 --> 00:10:30.130
don't have to implement a
loading spinner at the bottom

00:10:30.130 --> 00:10:31.930
because the users can
see the placeholder.

00:10:31.930 --> 00:10:36.010
They can see that there's a
gray icon instead of a user icon

00:10:36.010 --> 00:10:38.847
and know that that
item is still loading.

00:10:38.847 --> 00:10:40.930
There are some downsides,
though, of placeholders.

00:10:40.930 --> 00:10:42.790
First of all, it's
pretty important

00:10:42.790 --> 00:10:45.050
that your items
stay the same size.

00:10:45.050 --> 00:10:47.680
If you can't guess what the item
height is going to be before

00:10:47.680 --> 00:10:49.900
you have content-- for
instance, if you have, say,

00:10:49.900 --> 00:10:52.540
a social media post with an
arbitrary amount of text--

00:10:52.540 --> 00:10:56.591
the crossfade animation
doesn't look great.

00:10:56.591 --> 00:10:58.090
Additionally, your
adapter has to be

00:10:58.090 --> 00:11:00.640
able to handle null items, so
that's a little bit more code

00:11:00.640 --> 00:11:03.040
that you have to write to
say, if this item doesn't

00:11:03.040 --> 00:11:06.070
exist, pass an empty
string to the text view,

00:11:06.070 --> 00:11:08.020
that kind of thing.

00:11:08.020 --> 00:11:10.500
And then your data source has
to be able to count items.

00:11:10.500 --> 00:11:12.327
Now, Room can count
items out of the box,

00:11:12.327 --> 00:11:14.410
but if you're using something
that is loading data

00:11:14.410 --> 00:11:16.840
from, say, the
network, your back end

00:11:16.840 --> 00:11:21.040
may not be able to
provide a precise count.

00:11:21.040 --> 00:11:24.770
So we've been talking a lot
about LiveData thus far,

00:11:24.770 --> 00:11:27.370
but as Yig introduced at
the beginning, there's--

00:11:27.370 --> 00:11:31.040
we also want to support
our RxJava developers.

00:11:31.040 --> 00:11:33.320
So instead of
producing a LiveData,

00:11:33.320 --> 00:11:36.070
you may want to produce,
say, an observable,

00:11:36.070 --> 00:11:38.440
and we provide the
class RxPagedListBuilder

00:11:38.440 --> 00:11:41.000
to do exactly that.

00:11:41.000 --> 00:11:43.940
So you can change
the return type here,

00:11:43.940 --> 00:11:47.100
use an RxPagedListBuilder, and
then just specifically request

00:11:47.100 --> 00:11:48.904
an observable or a
flowable out of it.

00:11:48.904 --> 00:11:50.320
And you get all
the same behavior.

00:11:50.320 --> 00:11:53.470
You can use all the same code
that we were showing before,

00:11:53.470 --> 00:11:57.559
with a little bit of change
to switch you Rx observation.

00:11:57.559 --> 00:11:59.350
Now, let's go under
the hood, because we've

00:11:59.350 --> 00:12:01.120
shown how small of
a code change this

00:12:01.120 --> 00:12:02.680
can be to switch
the Paging library,

00:12:02.680 --> 00:12:06.070
but how does that
work underneath?

00:12:06.070 --> 00:12:09.490
So here, on the left,
you have the repository

00:12:09.490 --> 00:12:12.430
that represents the data loading
portion of your application.

00:12:12.430 --> 00:12:15.080
And then you, on the right,
you have the ViewModel,

00:12:15.080 --> 00:12:17.860
which is how it
communicates to the UI.

00:12:17.860 --> 00:12:20.140
So inside the
repository, we want

00:12:20.140 --> 00:12:22.070
to build the source
for this LiveData.

00:12:22.070 --> 00:12:23.530
We want to produce
something that

00:12:23.530 --> 00:12:26.440
will push updates to the UI.

00:12:26.440 --> 00:12:28.930
So when you call
LivePageListBuilder.build,

00:12:28.930 --> 00:12:31.150
we create not only
a LiveData that

00:12:31.150 --> 00:12:33.290
can be used to funnel
information to the UI,

00:12:33.290 --> 00:12:36.070
but the producer side as well.

00:12:36.070 --> 00:12:39.400
Once someone starts
observing that LiveData,

00:12:39.400 --> 00:12:43.450
we will create a new
page list, because that's

00:12:43.450 --> 00:12:47.380
the way that we start passing
information down this pipeline.

00:12:47.380 --> 00:12:49.530
And to do that, we create
a new data source out

00:12:49.530 --> 00:12:51.420
of the factory that we--

00:12:51.420 --> 00:12:53.770
that Room is able to produce.

00:12:53.770 --> 00:12:55.350
Now, to pass this
page list over,

00:12:55.350 --> 00:12:57.340
though-- we don't want
to send an empty list.

00:12:57.340 --> 00:13:01.560
If the UI can avoid it, we'd
really like to load data first.

00:13:01.560 --> 00:13:03.790
And so we do that on
a background thread,

00:13:03.790 --> 00:13:06.487
initialize that data, and
create a PagedList out of it.

00:13:06.487 --> 00:13:08.320
And here, you can see
at the very beginning,

00:13:08.320 --> 00:13:11.310
the first PagedList that we
produce has data only loaded

00:13:11.310 --> 00:13:13.350
at the very front.

00:13:13.350 --> 00:13:15.820
We can send that over
to the UI thread.

00:13:15.820 --> 00:13:18.060
And then, if you remember,
our submitList call

00:13:18.060 --> 00:13:21.270
on PagedListAdapter submits
this to the adapter.

00:13:21.270 --> 00:13:23.250
And the adapter can
start immediately

00:13:23.250 --> 00:13:25.510
presenting those items.

00:13:25.510 --> 00:13:27.300
Now, as the user
scrolls, though, we

00:13:27.300 --> 00:13:28.990
might need to load more data.

00:13:28.990 --> 00:13:32.730
So the PagedList, internally,
will trigger a data load

00:13:32.730 --> 00:13:36.570
from its data source and
append that data directly

00:13:36.570 --> 00:13:38.820
to the PagedList.

00:13:38.820 --> 00:13:41.310
Now, the crossfade
animation occurs

00:13:41.310 --> 00:13:43.650
because we have signaled
the RecyclerView

00:13:43.650 --> 00:13:47.070
that these new items
are updated again,

00:13:47.070 --> 00:13:50.260
but what happens when a
content update occurs?

00:13:50.260 --> 00:13:53.730
So if the database says, oh,
this table has been validated,

00:13:53.730 --> 00:13:55.530
something has changed,
we immediately

00:13:55.530 --> 00:13:57.480
stopped loading from
the data source.

00:13:57.480 --> 00:13:59.590
We invalidate it.

00:13:59.590 --> 00:14:01.320
So let's look at
what happens in order

00:14:01.320 --> 00:14:05.622
to start pushing those updates,
though, from the other side.

00:14:05.622 --> 00:14:07.830
So on the other side of
things, we can see, oh, well,

00:14:07.830 --> 00:14:09.990
the database had an
item added to it.

00:14:09.990 --> 00:14:12.600
That's why we invalidated
the previous data source.

00:14:12.600 --> 00:14:14.340
And at the same time,
the producer side

00:14:14.340 --> 00:14:16.500
is listening to the
signal to know I need

00:14:16.500 --> 00:14:18.540
to produce a new PagedList.

00:14:18.540 --> 00:14:20.850
So we use this signal
to create a new data

00:14:20.850 --> 00:14:24.000
source so that we can create
a new PagedList to send over.

00:14:24.000 --> 00:14:26.520
And when we load the
initial data for that,

00:14:26.520 --> 00:14:28.770
though, we're careful
to initialize that

00:14:28.770 --> 00:14:31.650
based upon the
loading position that

00:14:31.650 --> 00:14:32.880
was signaled by the adapter.

00:14:32.880 --> 00:14:34.830
So the user has
partially scrolled down.

00:14:34.830 --> 00:14:37.890
So let's center our load
around where the user is.

00:14:37.890 --> 00:14:45.211
We send that over to the UI,
and now we submitList again.

00:14:45.211 --> 00:14:46.960
But because these are
two different lists,

00:14:46.960 --> 00:14:50.410
and we really don't want to
call NotifyDataSetChange, what

00:14:50.410 --> 00:14:52.720
happens is that we compute
an asynchronous diff

00:14:52.720 --> 00:14:54.880
on a background thread
just like with listAdapter,

00:14:54.880 --> 00:14:56.890
as Yig mentioned earlier.

00:14:56.890 --> 00:15:00.280
Once that diff is computed,
we pass that diff result

00:15:00.280 --> 00:15:03.490
into the RecyclerView and
swap the new PagedList in.

00:15:03.490 --> 00:15:05.890
Immediately, you get
a new item showing up,

00:15:05.890 --> 00:15:07.540
a new animation for
that, and we only

00:15:07.540 --> 00:15:10.000
have to do the minimal
amount of UI work to bind

00:15:10.000 --> 00:15:13.330
and show the new item.

00:15:13.330 --> 00:15:16.570
So fundamentally, under the
hood, we do a lot of trickery

00:15:16.570 --> 00:15:17.660
to make this work.

00:15:17.660 --> 00:15:20.080
But from the outside, we try
and make it look as close as

00:15:20.080 --> 00:15:22.270
possible to a LiveData
of a list because this

00:15:22.270 --> 00:15:23.920
is a really nice experience.

00:15:23.920 --> 00:15:26.470
It lets you keep your
UI really, really simple

00:15:26.470 --> 00:15:29.620
and avoid all of the information
about paging on that side

00:15:29.620 --> 00:15:31.135
and let you configure
and construct

00:15:31.135 --> 00:15:35.530
your flow in one place
from the repository.

00:15:35.530 --> 00:15:38.140
The PagedListAdapter is able
to handle both the new page

00:15:38.140 --> 00:15:41.980
lists as they flow in and
also the internal updates

00:15:41.980 --> 00:15:43.590
of the page list as it loads.

00:15:49.000 --> 00:15:51.410
YIGIT BOYER: Let's talk
about data sources.

00:15:51.410 --> 00:15:55.270
So we mentioned that PagedList
is a list implementation that

00:15:55.270 --> 00:15:58.480
works with a data source, and
we have different types of data

00:15:58.480 --> 00:15:59.680
sources.

00:15:59.680 --> 00:16:01.980
You can have a
PositionalDataSource,

00:16:01.980 --> 00:16:07.780
an ItemKeyedDataSource,
and a PageKeyedDataSource.

00:16:07.780 --> 00:16:10.360
Let's start with the
PositionalDataSource.

00:16:10.360 --> 00:16:13.330
If you have an application
like the Contacts application

00:16:13.330 --> 00:16:16.620
on Android, where you
have the data locally,

00:16:16.620 --> 00:16:20.430
but user may want to jump
into arbitrary positions,

00:16:20.430 --> 00:16:23.980
PositionalDataSource
is your best option.

00:16:23.980 --> 00:16:28.400
This is actually what Room
uses behind the scenes.

00:16:28.400 --> 00:16:30.760
So if you have a data
source or UI like that,

00:16:30.760 --> 00:16:33.610
you extend this
PositionalDataSource class,

00:16:33.610 --> 00:16:37.090
and you specify
the type of items.

00:16:37.090 --> 00:16:40.780
But to better understand how
this data source behaves,

00:16:40.780 --> 00:16:42.140
let's look at an example.

00:16:42.140 --> 00:16:43.880
So we have the UI here.

00:16:43.880 --> 00:16:46.950
We'll just zoom out, go
to the bird's eye view,

00:16:46.950 --> 00:16:51.160
and we have our data source
on the right back by our list.

00:16:51.160 --> 00:16:54.000
The very first time you
come to the RecyclerView,

00:16:54.000 --> 00:16:57.335
PagedList will call this
LoadInitial method on the data

00:16:57.335 --> 00:17:02.110
source, pass the start
position and page size,

00:17:02.110 --> 00:17:03.050
and then load size--

00:17:03.050 --> 00:17:05.020
InitialLoadSize,
which is usually

00:17:05.020 --> 00:17:07.329
larger than the page size,
because you want to have

00:17:07.329 --> 00:17:09.619
more items at the beginning--

00:17:09.619 --> 00:17:13.089
and whether placeholders
are enabled or not.

00:17:13.089 --> 00:17:16.690
In this example, we just assume
placeholders are enabled.

00:17:16.690 --> 00:17:19.839
So our data source--
we return the data.

00:17:19.839 --> 00:17:22.190
Tell us about where
that data starts,

00:17:22.190 --> 00:17:25.190
and it will give us the total
number of items in the data

00:17:25.190 --> 00:17:26.380
source.

00:17:26.380 --> 00:17:29.240
Based on that, we'll
start displaying the data,

00:17:29.240 --> 00:17:31.900
but we'll also display
the placeholders

00:17:31.900 --> 00:17:35.410
so that the size of the pages
is equal to the total number

00:17:35.410 --> 00:17:39.640
of items in the data source.

00:17:39.640 --> 00:17:41.250
Now, a user can start scrolling.

00:17:41.250 --> 00:17:43.530
As soon as users
start scrolling,

00:17:43.530 --> 00:17:46.520
pages will realize that it's
going to run out of data,

00:17:46.520 --> 00:17:48.660
and it's going to
call this LoadRange

00:17:48.660 --> 00:17:51.465
method on the
PositionalDataSource,

00:17:51.465 --> 00:17:56.100
paste at the start position of
the first item that's missing

00:17:56.100 --> 00:18:01.540
and the page size, and get the
new data appended to the list.

00:18:01.540 --> 00:18:05.030
So imagine in this case,
user uses the fast scroller

00:18:05.030 --> 00:18:07.410
and jumps into an
arbitrary position where

00:18:07.410 --> 00:18:09.570
we didn't have the data yet.

00:18:09.570 --> 00:18:13.650
When this happens, it won't
call the data source LoadRange

00:18:13.650 --> 00:18:15.130
position.

00:18:15.130 --> 00:18:19.570
We take positions slight
level RecyclerView and load

00:18:19.570 --> 00:18:23.280
that page so that we can
display it to the user.

00:18:23.280 --> 00:18:26.580
This is why PositionalDataSource
is really good if user can

00:18:26.580 --> 00:18:28.440
jump into arbitrary positions.

00:18:28.440 --> 00:18:31.210
You never block them.

00:18:31.210 --> 00:18:33.600
Let's say something has
happened in the database.

00:18:33.600 --> 00:18:35.520
Data has been invalidated.

00:18:35.520 --> 00:18:37.170
So we'll get a new data source.

00:18:37.170 --> 00:18:41.370
So each data source represents
a snapshot of the data.

00:18:41.370 --> 00:18:43.150
So we get this new one.

00:18:43.150 --> 00:18:45.320
We'll create the
new pages for it,

00:18:45.320 --> 00:18:48.750
and we'll load the initial
page from this data source

00:18:48.750 --> 00:18:51.780
based on where user is
in the previous one.

00:18:51.780 --> 00:18:55.110
We'll bring this one, as
always, on a background thread.

00:18:55.110 --> 00:18:58.500
We will calculate the difference
between these two lists

00:18:58.500 --> 00:19:03.750
and update the RecyclerView
with the correct animations.

00:19:03.750 --> 00:19:06.850
Second one is the
ItemKeyedDataSource.

00:19:06.850 --> 00:19:11.740
So imagine you have some data,
like a list, list of names.

00:19:11.740 --> 00:19:14.280
If you look at the
page out of this,

00:19:14.280 --> 00:19:17.220
you could identify the
items before this page

00:19:17.220 --> 00:19:20.820
by using the first item in
the list, and the next page

00:19:20.820 --> 00:19:22.830
by using the last
item in the list.

00:19:22.830 --> 00:19:26.070
Basically, every item
can identify a page

00:19:26.070 --> 00:19:28.260
after or before it.

00:19:28.260 --> 00:19:30.030
If your data source
is like that,

00:19:30.030 --> 00:19:33.660
you should implement the
ItemKeyedDataSource class.

00:19:33.660 --> 00:19:35.250
You provide a key type--

00:19:35.250 --> 00:19:38.060
in this case, we are
using names, so String--

00:19:38.060 --> 00:19:41.390
and the item type in the list.

00:19:41.390 --> 00:19:43.260
Let's look at an example.

00:19:43.260 --> 00:19:45.740
So first time you come
to the RecyclerView,

00:19:45.740 --> 00:19:48.370
it called the
LoadInitial method.

00:19:48.370 --> 00:19:52.190
Passed the initial key, which is
null, because we don't have it.

00:19:52.190 --> 00:19:55.160
It requests the load size
and whether placeholders

00:19:55.160 --> 00:19:56.540
are enabled or not.

00:19:56.540 --> 00:19:59.990
We'll just assume they're
not enabled in this example,

00:19:59.990 --> 00:20:03.200
so data source will
only return this data.

00:20:03.200 --> 00:20:04.960
It's not going to count
it because there's

00:20:04.960 --> 00:20:06.980
no placeholders.

00:20:06.980 --> 00:20:08.720
So start displaying it.

00:20:08.720 --> 00:20:11.210
As soon as users
start scrolling,

00:20:11.210 --> 00:20:15.315
we will extract the key from
the last line that we have

00:20:15.315 --> 00:20:17.700
and call the data
source LoadAfter

00:20:17.700 --> 00:20:20.070
method to load that other page.

00:20:20.070 --> 00:20:23.780
Similarly, as user
keeps scrolling,

00:20:23.780 --> 00:20:27.740
just extracts a key, and
then loads another page

00:20:27.740 --> 00:20:29.900
the same way.

00:20:29.900 --> 00:20:32.225
By this point,
let's say this data

00:20:32.225 --> 00:20:34.400
was coming from the
database, similarly

00:20:34.400 --> 00:20:37.860
something has changed, so
we lost the data source.

00:20:37.860 --> 00:20:39.530
It's been invalidated.

00:20:39.530 --> 00:20:41.440
We'll get a new data source.

00:20:41.440 --> 00:20:44.930
When we create a new PagedList
for this data source,

00:20:44.930 --> 00:20:48.650
we are going to extract the key
from one of the items that's

00:20:48.650 --> 00:20:52.520
currently visible in the
RecyclerView closer to the top

00:20:52.520 --> 00:20:56.920
and load a page from
this new data source.

00:20:56.920 --> 00:20:58.900
And we get that page.

00:20:58.900 --> 00:21:00.760
We understand these
are PagedLists.

00:21:00.760 --> 00:21:03.550
We will calculate the
diff and update the UI

00:21:03.550 --> 00:21:06.300
with the correct animations.

00:21:06.300 --> 00:21:08.960
Now, we don't take the
data on top anymore.

00:21:08.960 --> 00:21:13.260
So if user tries to scroll
up, we need more data.

00:21:13.260 --> 00:21:16.510
Same thing-- you just extract
the key from the first item,

00:21:16.510 --> 00:21:20.995
call LoadBefore method on the
data source, Get that page,

00:21:20.995 --> 00:21:26.610
prepend it to the PagedList, and
now user can scroll outwards.

00:21:26.610 --> 00:21:30.821
So it's always lazy,
always reactive.

00:21:30.821 --> 00:21:33.420
Third one is the
pagedKeyedDataSource.

00:21:33.420 --> 00:21:36.500
Now, this is a really common
way of paging, especially

00:21:36.500 --> 00:21:38.450
on the server side APIs.

00:21:38.450 --> 00:21:42.150
So your client sends a request,
and when the response comes in

00:21:42.150 --> 00:21:45.060
from the server, it
includes the data.

00:21:45.060 --> 00:21:50.330
It also includes pointers for
the next and previous keys.

00:21:50.330 --> 00:21:52.380
GitHub API works this way.

00:21:52.380 --> 00:21:53.820
Reddit API works this way.

00:21:53.820 --> 00:21:55.500
It's very common.

00:21:55.500 --> 00:21:57.830
So if you have a data
source like that,

00:21:57.830 --> 00:22:01.490
you should implement the
PagedKeyedDataSource, specify

00:22:01.490 --> 00:22:04.980
the type of your keys that
you use in the pointers,

00:22:04.980 --> 00:22:07.460
and the item type.

00:22:07.460 --> 00:22:09.620
Let's look at the example.

00:22:09.620 --> 00:22:11.140
First time user comes to the UI.

00:22:11.140 --> 00:22:12.990
We call LoadInitial.

00:22:12.990 --> 00:22:16.370
We give it a size, and we
ask whether placeholders

00:22:16.370 --> 00:22:17.920
are enabled or not.

00:22:17.920 --> 00:22:21.050
They're usually disabled because
your server doesn't give you

00:22:21.050 --> 00:22:22.150
an accurate count.

00:22:22.150 --> 00:22:24.260
We'll just assume
they're disabled--

00:22:24.260 --> 00:22:26.450
easier.

00:22:26.450 --> 00:22:30.460
And then the data
source returns the data,

00:22:30.460 --> 00:22:34.020
but it also gives us
pointers for the previous key

00:22:34.020 --> 00:22:36.830
and the next page key.

00:22:36.830 --> 00:22:39.110
Now, we start displaying it.

00:22:39.110 --> 00:22:43.070
If user scrolls, we
need more contact.

00:22:43.070 --> 00:22:45.670
So we're going to call
the LoadAfter method,

00:22:45.670 --> 00:22:49.690
use the key that was returned
in the previous request

00:22:49.690 --> 00:22:53.180
to get the next page
from the data source.

00:22:53.180 --> 00:22:57.700
Now, this next page comes with a
field called AdjustmentPageKey,

00:22:57.700 --> 00:23:00.580
so it always tells, OK,
what is the next page

00:23:00.580 --> 00:23:01.960
in this direction?

00:23:01.960 --> 00:23:06.590
It's literally like a
linked list of pages.

00:23:06.590 --> 00:23:10.570
Once you take that,
user can scroll more.

00:23:10.570 --> 00:23:12.530
Now, a difference
in this data source

00:23:12.530 --> 00:23:15.410
is how we handle invalidation.

00:23:15.410 --> 00:23:18.510
Imagine user hit the Refresh
button on the screen.

00:23:18.510 --> 00:23:20.090
Data source is invalidated.

00:23:20.090 --> 00:23:24.440
We'll get a new data source,
but in the LoadInitial method,

00:23:24.440 --> 00:23:26.150
there is no key anymore.

00:23:26.150 --> 00:23:27.560
This is because--

00:23:27.560 --> 00:23:29.420
I mentioned, this is
like a linked list.

00:23:29.420 --> 00:23:33.290
So if the previous list is
invalid, links in the list

00:23:33.290 --> 00:23:34.920
doesn't mean anything.

00:23:34.920 --> 00:23:38.270
So you always need to load
the very first page again

00:23:38.270 --> 00:23:40.370
and display it in the UI.

00:23:40.370 --> 00:23:43.100
This is usually not
a problem in practice

00:23:43.100 --> 00:23:46.610
because you only do this if
a user does swipe to refresh,

00:23:46.610 --> 00:23:48.530
so they are already
on top of the list.

00:23:53.189 --> 00:23:54.730
CHRIS CRAIK: All
right, so Yig talked

00:23:54.730 --> 00:23:58.270
through what we might see
implementing a data source,

00:23:58.270 --> 00:24:01.540
but what happens when we want
to load from multiple sources

00:24:01.540 --> 00:24:03.010
at once?

00:24:03.010 --> 00:24:06.791
So a database plus
network solution--

00:24:06.791 --> 00:24:08.290
these two components
can work really

00:24:08.290 --> 00:24:10.090
nicely together when
the database acts

00:24:10.090 --> 00:24:12.590
as a cache for the network.

00:24:12.590 --> 00:24:14.410
You can page from
your back end that you

00:24:14.410 --> 00:24:16.450
have with all the benefits
of the local cache.

00:24:16.450 --> 00:24:19.330
You can have a really
nice offline support.

00:24:19.330 --> 00:24:23.620
You can resume quickly if the
application has been killed

00:24:23.620 --> 00:24:25.780
and restarted, and you can
minimize network traffic

00:24:25.780 --> 00:24:29.930
by taking advantage of data
that's already on device.

00:24:29.930 --> 00:24:31.990
So let's look at how
this might look compared

00:24:31.990 --> 00:24:36.950
to what we were showing before
with a single source of data.

00:24:36.950 --> 00:24:40.580
So how does the network
fit into this system?

00:24:40.580 --> 00:24:43.640
So one way that we could do
this is we could basically say,

00:24:43.640 --> 00:24:46.210
well, the network is my source
of data when I'm connected,

00:24:46.210 --> 00:24:49.300
and the database is my
source when I'm not.

00:24:49.300 --> 00:24:54.010
So if I'm connected, then I
page data from the network,

00:24:54.010 --> 00:24:56.890
and if I'm not, I page
data from the database.

00:24:56.890 --> 00:24:59.525
The one problem there is that
you don't have anything storing

00:24:59.525 --> 00:25:01.900
data in your database even
when you're loading a network,

00:25:01.900 --> 00:25:03.076
but it's pretty easy.

00:25:03.076 --> 00:25:04.950
As a side effect of
loading from the network,

00:25:04.950 --> 00:25:06.408
you can just store
in the database,

00:25:06.408 --> 00:25:09.070
and there, you have
paging from both.

00:25:09.070 --> 00:25:11.360
However, this is a couple
of really big problems

00:25:11.360 --> 00:25:12.610
that are important to discuss.

00:25:12.610 --> 00:25:15.520
So this switching model
has the first problem

00:25:15.520 --> 00:25:19.060
that this connected state
is really oversimplifying.

00:25:19.060 --> 00:25:21.610
In reality, individual
request to your servers

00:25:21.610 --> 00:25:23.830
can succeed and fail,
and a user that's

00:25:23.830 --> 00:25:28.090
connected, like, 20%, some
of the packets go through.

00:25:28.090 --> 00:25:31.249
That doesn't really fit
really nicely into this model.

00:25:31.249 --> 00:25:33.790
The other big problem is that
we're not using local data when

00:25:33.790 --> 00:25:38.260
it's present, so let's go about
looking at a different way

00:25:38.260 --> 00:25:40.970
to do this.

00:25:40.970 --> 00:25:44.470
So what if instead we
just monitor the database

00:25:44.470 --> 00:25:48.010
and use that as our local
single source of truth?

00:25:48.010 --> 00:25:49.870
What we can do
then is we can say,

00:25:49.870 --> 00:25:52.180
well, the only time
I need to load data

00:25:52.180 --> 00:25:55.480
is when the database tells
me that it's out of data.

00:25:55.480 --> 00:25:58.450
I can use that as a signal to
load more data from the network

00:25:58.450 --> 00:26:02.820
stored into the
database, and then

00:26:02.820 --> 00:26:06.540
I have my entire solution
built. I just load data

00:26:06.540 --> 00:26:07.980
when I need to,
but I can present

00:26:07.980 --> 00:26:11.670
only the database, which
makes things a lot simpler.

00:26:11.670 --> 00:26:14.930
So we get the benefits of
consistent data presentation.

00:26:14.930 --> 00:26:17.210
We have a similarly
simple process.

00:26:17.210 --> 00:26:20.270
But importantly, this
gracefully degrades on failures.

00:26:20.270 --> 00:26:24.050
If your user is in that
20% connected state,

00:26:24.050 --> 00:26:26.630
you can still produce-- you can
still present all of the data

00:26:26.630 --> 00:26:31.130
that you have locally and try
and fetch or potentially retry

00:26:31.130 --> 00:26:34.390
when the network is around.

00:26:34.390 --> 00:26:36.470
So potentially, you
might say, well,

00:26:36.470 --> 00:26:37.820
this doesn't keep my data fresh.

00:26:37.820 --> 00:26:40.480
And an easy way to work around
that is to just say, whenever

00:26:40.480 --> 00:26:43.900
anyone starts observing
the stream of data,

00:26:43.900 --> 00:26:44.980
we start a new fetch.

00:26:44.980 --> 00:26:47.740
We see if we need to
refresh our content,

00:26:47.740 --> 00:26:49.480
and that's especially
important usually

00:26:49.480 --> 00:26:52.810
when you have a
frequently updating data.

00:26:55.750 --> 00:26:57.730
So in that proposed
model here that we saw,

00:26:57.730 --> 00:27:00.490
we need an out of data
signal from the database.

00:27:00.490 --> 00:27:03.190
Because the rest of that,
we've basically already built

00:27:03.190 --> 00:27:05.290
in the first few slides.

00:27:05.290 --> 00:27:08.650
So when we have that
signal, we can trigger loads

00:27:08.650 --> 00:27:10.780
from the network directly
into the database,

00:27:10.780 --> 00:27:14.380
and the UI doesn't have
to enter into any of that.

00:27:14.380 --> 00:27:17.650
So paging built exactly this
signal for exactly this reason,

00:27:17.650 --> 00:27:19.410
and we call that the
boundary callback.

00:27:19.410 --> 00:27:23.150
So let's go ahead and look
at what that might look like.

00:27:23.150 --> 00:27:26.970
So the first most important part
of the boundary callback that

00:27:26.970 --> 00:27:29.740
you implement is that you
pass it to different--

00:27:29.740 --> 00:27:32.960
that you'll want to provide it
two different sources of data--

00:27:32.960 --> 00:27:36.290
the database and the network--
because that's its job.

00:27:36.290 --> 00:27:39.430
So the first-- the important
callback that we have here

00:27:39.430 --> 00:27:41.080
is onItemAtEndLoaded.

00:27:41.080 --> 00:27:43.540
And this signifies the
last item in the database

00:27:43.540 --> 00:27:45.732
has been loaded
from the PagedList,

00:27:45.732 --> 00:27:48.190
and if there's more from the
network, it's time to load it.

00:27:50.710 --> 00:27:52.800
So the first thing that
we do in response to this

00:27:52.800 --> 00:27:54.600
is that we, over on
a network thread,

00:27:54.600 --> 00:27:58.540
we can request our service--
hey, give me more data.

00:27:58.540 --> 00:28:00.240
And in this
particular case, we're

00:28:00.240 --> 00:28:04.290
using the item at the end to
feed which data we need more

00:28:04.290 --> 00:28:07.320
of because we're
in an item key case

00:28:07.320 --> 00:28:11.440
similar to the item key data
source that you saw before.

00:28:11.440 --> 00:28:13.470
Now, if that request
is successful,

00:28:13.470 --> 00:28:17.610
we simply jump over to
the database thread,

00:28:17.610 --> 00:28:20.460
insert that data that we
loaded from the response

00:28:20.460 --> 00:28:23.180
into the database, and
we're basically done.

00:28:23.180 --> 00:28:25.034
We've connected that
signal that we needed,

00:28:25.034 --> 00:28:26.700
and now we've added
network to something

00:28:26.700 --> 00:28:28.205
that was purely database.

00:28:28.205 --> 00:28:29.580
Now, the one other
trick that you

00:28:29.580 --> 00:28:32.280
need to be aware of, though,
is that it's possible,

00:28:32.280 --> 00:28:34.620
when the database is
being invalidated locally

00:28:34.620 --> 00:28:39.390
for multiple at end signals to
trigger-- so what you can do

00:28:39.390 --> 00:28:42.720
is you can just protect this
with a simple Boolean to say,

00:28:42.720 --> 00:28:44.730
if I'm already
loading, don't try.

00:28:48.410 --> 00:28:50.330
And then we can reset
that at the end.

00:28:50.330 --> 00:28:52.960
So using this boundary
callback is pretty simple.

00:28:52.960 --> 00:28:55.670
You can just add this back into
your live page list builder

00:28:55.670 --> 00:28:59.000
or to your Rx page list
builder, and then that

00:28:59.000 --> 00:29:02.630
gives you the database plus
network solution all isolated

00:29:02.630 --> 00:29:05.640
in that one callback.

00:29:05.640 --> 00:29:08.490
So let's talk about what
the Paging Library is.

00:29:08.490 --> 00:29:12.150
So the Paging Library
provides paging from database,

00:29:12.150 --> 00:29:14.220
network, and importantly
both, as we just

00:29:14.220 --> 00:29:18.630
saw, and it can load the data
directly into RecyclerView.

00:29:18.630 --> 00:29:21.980
It extends this live data of
list, this observable list

00:29:21.980 --> 00:29:23.930
pattern that we really
like because it keeps

00:29:23.930 --> 00:29:26.060
our UI incredibly
simple, and it lets

00:29:26.060 --> 00:29:30.370
us contain all of the
complex logic on one side.

00:29:30.370 --> 00:29:31.330
It's configurable.

00:29:31.330 --> 00:29:35.650
We have configurable load size,
prefetch, and placeholders.

00:29:35.650 --> 00:29:38.650
And it integrates directly
with Room, with LiveData,

00:29:38.650 --> 00:29:40.410
and with Rx.

00:29:40.410 --> 00:29:43.160
The Paging 1.0
was just released,

00:29:43.160 --> 00:29:44.729
and so please give it a try.

00:29:44.729 --> 00:29:45.520
Take it for a spin.

00:29:49.019 --> 00:29:51.550
YIGIT BOYER: Hi, that
was a lot of information.

00:29:51.550 --> 00:29:52.750
We know.

00:29:52.750 --> 00:29:54.250
So where to go next?

00:29:54.250 --> 00:29:58.720
Well, we have extensive
documentation on d.android.com.

00:29:58.720 --> 00:30:01.960
If you can just read,
we provide more details

00:30:01.960 --> 00:30:04.000
and more samples there.

00:30:04.000 --> 00:30:05.560
We have an amazing code lab.

00:30:05.560 --> 00:30:08.110
You can just check it
out in the Code Lab area,

00:30:08.110 --> 00:30:10.840
or you can try it online.

00:30:10.840 --> 00:30:13.240
We also have samples
on GitHub where

00:30:13.240 --> 00:30:16.870
we implement different data
sources using [INAUDIBLE] API

00:30:16.870 --> 00:30:19.130
or a different look
[INAUDIBLE] database,

00:30:19.130 --> 00:30:22.600
and you can compare and contrast
the behavior of different data

00:30:22.600 --> 00:30:23.630
sources.

00:30:23.630 --> 00:30:25.690
And you can also see how
you could handle things

00:30:25.690 --> 00:30:27.940
like errors, retries.

00:30:27.940 --> 00:30:31.270
We have all of it there.

00:30:31.270 --> 00:30:35.590
But if you've been sitting
here for the last 30 minutes,

00:30:35.590 --> 00:30:37.600
and wondering whether
these two guys never

00:30:37.600 --> 00:30:43.510
heard about Cursor and its
built-in paging, rest assured,

00:30:43.510 --> 00:30:45.850
we did hear about that.

00:30:45.850 --> 00:30:48.390
So that's actually what
we wanted to use initially

00:30:48.390 --> 00:30:50.850
when we started this
project because we already

00:30:50.850 --> 00:30:52.570
have Cursor adapters.

00:30:52.570 --> 00:30:53.180
It's Cursor.

00:30:53.180 --> 00:30:54.640
It takes care of all the work.

00:30:54.640 --> 00:30:55.550
Right?

00:30:55.550 --> 00:31:01.440
Wrong, so we realize it is very
unpredictable and inefficient

00:31:01.440 --> 00:31:03.740
if your cursor becomes large.

00:31:03.740 --> 00:31:06.680
So especially fearing your
application currently,

00:31:06.680 --> 00:31:11.880
if you are using Cursor for
lazy loading, be very careful.

00:31:11.880 --> 00:31:15.480
Room and Paging together
avoids this problem

00:31:15.480 --> 00:31:18.860
because we create
much smaller queries,

00:31:18.860 --> 00:31:22.410
not to rely on the paging
behavior of Cursor.

00:31:22.410 --> 00:31:25.890
Now, it's a very complex topic,
but Chris wrote an amazing blog

00:31:25.890 --> 00:31:29.890
post about this, that
you can go to that link,

00:31:29.890 --> 00:31:33.180
and we will post this
URL after the talk.

00:31:33.180 --> 00:31:37.170
It's amazing, but
TLDR, Cursor's paging

00:31:37.170 --> 00:31:40.030
is not the right
way to the paging.

00:31:40.030 --> 00:31:42.010
We did it wrong.

00:31:42.010 --> 00:31:43.469
We hopefully fixed it this time.

00:31:43.469 --> 00:31:45.510
CHRIS CRAIK: Did it wrong
10 years ago, at least.

00:31:45.510 --> 00:31:47.220
YIGIT BOYER: 10 years ago.

00:31:47.220 --> 00:31:47.750
It's not me.

00:31:52.640 --> 00:31:57.080
So paging is part of
Jetpack, our new initiative

00:31:57.080 --> 00:32:00.840
to accelerate
Android development.

00:32:00.840 --> 00:32:03.300
We had great many
talks at this I/O.

00:32:03.300 --> 00:32:05.680
This was the last
one, so please,

00:32:05.680 --> 00:32:08.430
if you are not able to
attend those sessions,

00:32:08.430 --> 00:32:09.390
check them on Youtube.

00:32:09.390 --> 00:32:11.610
Everything is recorded.

00:32:11.610 --> 00:32:14.640
And you can also learn more
about Jetpack on our website

00:32:14.640 --> 00:32:16.680
and provide us feedback.

00:32:16.680 --> 00:32:18.758
Thank you.

00:32:18.758 --> 00:32:22.930
[MUSIC PLAYING]

