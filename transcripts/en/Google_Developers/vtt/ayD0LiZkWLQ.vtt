WEBVTT
Kind: captions
Language: en

00:00:01.431 --> 00:00:02.670
CHRIS PALMER: Hi, everybody.

00:00:02.670 --> 00:00:04.240
Thanks for coming out.

00:00:04.240 --> 00:00:05.840
Hopefully, you're having fun.

00:00:05.840 --> 00:00:09.950
And hopefully, you
won't scream and cry.

00:00:09.950 --> 00:00:13.000
I noticed that
when Alex said you

00:00:13.000 --> 00:00:15.690
have to have HTTPS
for service workers,

00:00:15.690 --> 00:00:20.450
and when Adrian said all the
cool new APIs need HTTPS too,

00:00:20.450 --> 00:00:22.790
I'd like to thank you
all for not screaming.

00:00:22.790 --> 00:00:24.870
Maybe you screamed inwardly.

00:00:24.870 --> 00:00:27.805
But I really appreciate
it, because a lot

00:00:27.805 --> 00:00:28.930
of times there's screaming.

00:00:28.930 --> 00:00:33.360
So I want to help you find out
how to reduce the screaming.

00:00:33.360 --> 00:00:35.350
And the good news is we can.

00:00:35.350 --> 00:00:41.790
So first, I'd like to
pitch why you need TLS.

00:00:41.790 --> 00:00:43.360
So I'm going to
be focusing mostly

00:00:43.360 --> 00:00:45.920
on the performance aspects.

00:00:45.920 --> 00:00:48.330
But first, I should motivate it.

00:00:48.330 --> 00:00:51.090
So as you may know,
Chrome has the three goals

00:00:51.090 --> 00:00:53.790
of speed, simplicity,
and security.

00:00:53.790 --> 00:00:57.080
And I'm on the Chrome
security team, specifically

00:00:57.080 --> 00:00:59.320
the secure usability team.

00:00:59.320 --> 00:01:02.230
But all those things
have to go together.

00:01:02.230 --> 00:01:07.670
We can't have an easy, fast
path to crash into the wall.

00:01:07.670 --> 00:01:10.590
We can't have
terribly slow safety.

00:01:10.590 --> 00:01:12.940
The safety can't
be too complicated.

00:01:12.940 --> 00:01:16.530
So unless all those three
things are working in harmony,

00:01:16.530 --> 00:01:19.390
we and our users are
going to be really sad.

00:01:19.390 --> 00:01:22.610
So I'm going to
try to combine them

00:01:22.610 --> 00:01:25.220
in a way that works
well for everyone.

00:01:25.220 --> 00:01:27.540
So why do you need TLS?

00:01:30.410 --> 00:01:34.260
I'm speaking today to you
as website developers.

00:01:34.260 --> 00:01:38.680
And I want you to think
about the needs of your users

00:01:38.680 --> 00:01:40.100
as well.

00:01:40.100 --> 00:01:42.310
So your users care
about the data

00:01:42.310 --> 00:01:44.790
that they're storing
in your application.

00:01:44.790 --> 00:01:47.190
If your application
matters at all,

00:01:47.190 --> 00:01:49.350
then it matters
to people who care

00:01:49.350 --> 00:01:52.140
about the privacy,
the correctness,

00:01:52.140 --> 00:01:55.360
whether or not it's
been mangled in transit.

00:01:55.360 --> 00:01:58.280
Even if it's just
a news site, it

00:01:58.280 --> 00:02:00.650
matters that they're
seeing the true news.

00:02:00.650 --> 00:02:02.880
And sometimes the
news gets falsified.

00:02:02.880 --> 00:02:04.740
And it really does happen.

00:02:04.740 --> 00:02:06.930
For example, the
AP's Twitter account

00:02:06.930 --> 00:02:09.210
was hijacked a while
back and caused

00:02:09.210 --> 00:02:13.600
a two-seconds long
huge dip in the value

00:02:13.600 --> 00:02:17.160
of some stocks because of a
false tweet that was sent out.

00:02:17.160 --> 00:02:19.900
And someone made a lot of
money in those two seconds.

00:02:19.900 --> 00:02:23.360
And so we want the news to be
true so that that kind of thing

00:02:23.360 --> 00:02:25.120
has less chance of happening.

00:02:25.120 --> 00:02:29.220
So any app, even the simplest
just publishing facts app,

00:02:29.220 --> 00:02:31.170
should be safe.

00:02:31.170 --> 00:02:32.630
And if you went to
all this trouble

00:02:32.630 --> 00:02:37.160
to animate your UI nicely,
and to have cool graphics that

00:02:37.160 --> 00:02:39.450
fit a material
design specification,

00:02:39.450 --> 00:02:42.080
or whatever it might be,
you went to a lot of work.

00:02:42.080 --> 00:02:46.850
And you want your users to see
the true work that you've done.

00:02:46.850 --> 00:02:51.380
Unfortunately, when we don't
use a data channel that

00:02:51.380 --> 00:02:55.890
provides authentication
and data integrity,

00:02:55.890 --> 00:02:57.880
people between
you and your users

00:02:57.880 --> 00:02:59.760
can mangle that experience.

00:02:59.760 --> 00:03:02.290
And in fact, mangling
the user experience

00:03:02.290 --> 00:03:04.662
is other people's
business model.

00:03:04.662 --> 00:03:07.120
Messing with your business
model is someone else's business

00:03:07.120 --> 00:03:07.770
model.

00:03:07.770 --> 00:03:12.280
Here's an Ars Technica
story about how Comcast

00:03:12.280 --> 00:03:15.340
is doing that for
their own gain.

00:03:15.340 --> 00:03:19.197
So if that little thing appears
over your nice animations,

00:03:19.197 --> 00:03:21.280
your users aren't going
to have a good experience.

00:03:21.280 --> 00:03:25.250
So you want what you
built to get to people.

00:03:25.250 --> 00:03:27.040
You also want your
privacy policy

00:03:27.040 --> 00:03:29.060
to have any meaning
at all, which

00:03:29.060 --> 00:03:33.800
requires the basic bare minimum
of security that TLS provides.

00:03:33.800 --> 00:03:35.890
If you're monetizing
your site-- and I hope

00:03:35.890 --> 00:03:40.371
you are, so that you can all
continue to have food and rent.

00:03:40.371 --> 00:03:42.120
Either people are
paying for it directly--

00:03:42.120 --> 00:03:46.140
and obviously you need to secure
people's payment instruments,

00:03:46.140 --> 00:03:49.490
whether it's credit cards,
or Paypal, or whatever--

00:03:49.490 --> 00:03:52.720
or, if you're
monetizing by ads, you

00:03:52.720 --> 00:03:56.970
want to monetize your ads, and
not the ads that random people

00:03:56.970 --> 00:04:00.260
are inserting, which,
incidentally, is a business

00:04:00.260 --> 00:04:01.090
model.

00:04:01.090 --> 00:04:05.150
So here is a person on
Stack Overflow asking,

00:04:05.150 --> 00:04:08.260
I'd like to monetize--
I'm giving away Wi-Fi,

00:04:08.260 --> 00:04:10.440
and I want to make
some money on it.

00:04:10.440 --> 00:04:15.070
How bad would it be if I
took people's AdSense IDs,

00:04:15.070 --> 00:04:16.670
and put in my own?

00:04:16.670 --> 00:04:18.790
Would I get in a lot
of trouble for that?

00:04:18.790 --> 00:04:21.240
And obviously the answer
is, what the hell, man?

00:04:21.240 --> 00:04:23.164
AUDIENCE: [LAUGHTER]

00:04:23.164 --> 00:04:24.830
CHRIS PALMER: But
people are doing that.

00:04:24.830 --> 00:04:26.750
People want to do that.

00:04:26.750 --> 00:04:28.840
When I've given forms
of this talk before,

00:04:28.840 --> 00:04:34.370
I used to show-- I was at a
free Wi-Fi cafe in Austin.

00:04:34.370 --> 00:04:36.780
And they were inserting
all sorts of goodness

00:04:36.780 --> 00:04:39.670
on the front page
on Google, including

00:04:39.670 --> 00:04:43.060
enticing me to download
software, which was possible

00:04:43.060 --> 00:04:43.740
back then.

00:04:43.740 --> 00:04:47.700
This is many years ago, when
Google Search wasn't on HTTPS.

00:04:47.700 --> 00:04:49.840
And so people have been
doing this for a long time.

00:04:49.840 --> 00:04:52.910
It's a stable strategy,
so we should all

00:04:52.910 --> 00:04:55.830
get together and make it
not a stable strategy.

00:04:55.830 --> 00:04:57.840
So TLS is good.

00:04:57.840 --> 00:04:58.790
It's good for you.

00:04:58.790 --> 00:04:59.830
It's good for users.

00:04:59.830 --> 00:05:01.097
It's good for your business.

00:05:01.097 --> 00:05:02.680
But let's get to the
performance part,

00:05:02.680 --> 00:05:05.340
because it's a big
concern that people have.

00:05:05.340 --> 00:05:07.400
Is this going to kill my speed?

00:05:07.400 --> 00:05:10.420
We've talked about, we
want rendering to be fast.

00:05:10.420 --> 00:05:12.500
It's got to be paper smooth.

00:05:12.500 --> 00:05:15.100
And if TLS messes it
up, then I'm in trouble.

00:05:15.100 --> 00:05:18.680
So let's figure out why not.

00:05:18.680 --> 00:05:23.450
So HTTP/2 is the new
fancy HTTP version.

00:05:23.450 --> 00:05:24.980
It's coming up.

00:05:24.980 --> 00:05:28.800
We've built previous demo
versions of it before.

00:05:28.800 --> 00:05:30.730
You may have heard of SPDY.

00:05:30.730 --> 00:05:34.590
Google is using it
for lots of its sites.

00:05:34.590 --> 00:05:36.900
Chrome supports it.

00:05:36.900 --> 00:05:39.010
I think at least one
other browser does.

00:05:39.010 --> 00:05:42.240
And HTTP/2 is
being standardized.

00:05:42.240 --> 00:05:46.280
And we've experienced great
results-- speed improvements

00:05:46.280 --> 00:05:48.440
when we turned on TLS.

00:05:48.440 --> 00:05:50.870
And there's important
reasons for that.

00:05:50.870 --> 00:05:55.470
So the first web was
for documents, HTTP/1.

00:05:55.470 --> 00:05:57.510
HTTP/2 is about applications.

00:05:57.510 --> 00:06:00.830
And it's tailored to the
needs of dynamic applications,

00:06:00.830 --> 00:06:03.730
like real appy apps on the web.

00:06:03.730 --> 00:06:06.730
So that requires that it
perform very differently

00:06:06.730 --> 00:06:11.170
on the network than old-timey,
document-based HTTP.

00:06:11.170 --> 00:06:16.270
So HTTP/2 brings a couple
super important features

00:06:16.270 --> 00:06:19.050
to make apps responsive
on the internet.

00:06:19.050 --> 00:06:20.860
One is multiplexing.

00:06:20.860 --> 00:06:24.350
So if you think about HTTP/1,
you have this nice feature

00:06:24.350 --> 00:06:29.810
where you can establish a TCP
connection, and then you say,

00:06:29.810 --> 00:06:32.260
get/, and then they
give you the answer.

00:06:32.260 --> 00:06:35.360
And if you want to save the
cost of having set up that TCP

00:06:35.360 --> 00:06:37.750
connection, you can send
another get, or another post,

00:06:37.750 --> 00:06:39.210
or whatever.

00:06:39.210 --> 00:06:40.090
And that's very cool.

00:06:40.090 --> 00:06:41.190
And it helps.

00:06:41.190 --> 00:06:44.230
But we need more than that
for these super responsive

00:06:44.230 --> 00:06:47.030
modern 2014 apps.

00:06:47.030 --> 00:06:49.240
So for that, we have
multiplexing in HTTP/2.

00:06:52.170 --> 00:06:56.360
In a sense, it's kind of
like streams within a stream.

00:06:56.360 --> 00:06:59.930
If you've ever heard of
SCTP, it had a similar idea.

00:06:59.930 --> 00:07:02.910
So once you set up
your HTTP connection

00:07:02.910 --> 00:07:05.920
to a server, your
HTTP/2 connection,

00:07:05.920 --> 00:07:09.310
you can interleave
requests and responses

00:07:09.310 --> 00:07:11.640
at all different times
over the same connection.

00:07:11.640 --> 00:07:13.380
And it can live
really long, and it

00:07:13.380 --> 00:07:17.120
can be sending tons of stuff--
not even simple documents,

00:07:17.120 --> 00:07:19.070
but constant streams,
video streaming,

00:07:19.070 --> 00:07:23.000
interleaved with your get
the icon, get the avatar,

00:07:23.000 --> 00:07:27.120
post a comment, all happening
on the same HTTP connection.

00:07:27.120 --> 00:07:32.700
So that's a huge improvement
over mere pipelining

00:07:32.700 --> 00:07:34.230
and mere persistence.

00:07:34.230 --> 00:07:38.240
It also solved this problem
where, over one connection,

00:07:38.240 --> 00:07:41.880
you really need to get that
CSS file to style the page.

00:07:41.880 --> 00:07:43.720
But you're waiting
for the JPEG to come,

00:07:43.720 --> 00:07:46.146
which you asked for first.

00:07:46.146 --> 00:07:47.645
And so until that
JPEG comes, you're

00:07:47.645 --> 00:07:48.880
not going to get any CSS.

00:07:48.880 --> 00:07:53.620
And there's going to be that
style jank, where suddenly

00:07:53.620 --> 00:07:55.540
the style appears too late.

00:07:55.540 --> 00:07:57.160
So the head-of-line
blocking problem

00:07:57.160 --> 00:07:58.730
is a big problem on networks.

00:07:58.730 --> 00:08:02.041
And HTTP/2 does its job to deal
with that at the application

00:08:02.041 --> 00:08:02.540
layer.

00:08:02.540 --> 00:08:04.240
And it's super important.

00:08:04.240 --> 00:08:07.500
Another important
thing is that you--

00:08:07.500 --> 00:08:09.250
the server, or the
client, whoever

00:08:09.250 --> 00:08:13.010
initiates a stream within
the long-lived persistent

00:08:13.010 --> 00:08:17.950
connection-- can tell the other
side how important that stream

00:08:17.950 --> 00:08:20.350
is in among all the other
streams that are currently

00:08:20.350 --> 00:08:21.490
running.

00:08:21.490 --> 00:08:24.260
So a server can say,
hey there client,

00:08:24.260 --> 00:08:25.720
here's the main webpage.

00:08:25.720 --> 00:08:28.485
And now you're going to want to
focus on this JavaScript file.

00:08:28.485 --> 00:08:29.360
It's super important.

00:08:29.360 --> 00:08:31.780
It's jQuery, and we can't
do anything without that.

00:08:31.780 --> 00:08:35.340
And you'll need the CSS next.

00:08:35.340 --> 00:08:38.890
And all those avatars for all
users, those are important.

00:08:38.890 --> 00:08:39.799
But they're third.

00:08:39.799 --> 00:08:43.332
So don't get those before
you get the JavaScript.

00:08:43.332 --> 00:08:45.540
Because it's really important
to have the JavaScript.

00:08:45.540 --> 00:08:47.150
And then the client
can prioritize

00:08:47.150 --> 00:08:49.300
how it handles the
incoming packets.

00:08:49.300 --> 00:08:51.340
And you can get a much
lower latency page

00:08:51.340 --> 00:08:54.810
load, a much better
user experience.

00:08:54.810 --> 00:08:57.080
And either client or server
can initiate a stream.

00:08:57.080 --> 00:09:01.350
You can say, hey server, I'm
sending you up some updates.

00:09:01.350 --> 00:09:03.400
Say it's a mail application.

00:09:03.400 --> 00:09:07.840
It's really important that
you processes these emails

00:09:07.840 --> 00:09:14.270
that I'm posting before you
process the whatever, the IMs.

00:09:14.270 --> 00:09:16.700
Maybe the emails are more
important, or vice versa,

00:09:16.700 --> 00:09:18.500
whatever it might be.

00:09:18.500 --> 00:09:21.490
So that's super cool features.

00:09:21.490 --> 00:09:24.380
And then as a minor
sort of bonus,

00:09:24.380 --> 00:09:29.840
HTTP/2 compresses the headers
of HTTP requests and responses.

00:09:29.840 --> 00:09:34.480
In the old days, you
could compress the bodies,

00:09:34.480 --> 00:09:36.570
but sometimes the
headers would get big.

00:09:36.570 --> 00:09:38.310
If you have like
millions of cookies,

00:09:38.310 --> 00:09:41.750
or just huge lists of options,
and you keep repeating them--

00:09:41.750 --> 00:09:43.600
sometimes it can be
nice to compress those.

00:09:43.600 --> 00:09:45.010
So now we can.

00:09:45.010 --> 00:09:47.970
It can be useful.

00:09:47.970 --> 00:09:52.210
But all of that goodness
only works on TLS.

00:09:52.210 --> 00:09:53.650
There's two reasons for that.

00:09:53.650 --> 00:09:55.870
One is we really
want the future web

00:09:55.870 --> 00:09:59.400
to be safe so that
it can be appy.

00:09:59.400 --> 00:10:02.020
If you think about your
mobile apps, and even

00:10:02.020 --> 00:10:05.770
Windows and OS10, but
certainly iOS and Android,

00:10:05.770 --> 00:10:09.960
all of those apps pretty much
have to be, these days, signed.

00:10:09.960 --> 00:10:11.600
You can't get into
the Android store

00:10:11.600 --> 00:10:14.940
without your developer key, you
can't get into the iOS store

00:10:14.940 --> 00:10:16.840
without your
developer certificate,

00:10:16.840 --> 00:10:20.200
so that people can believe
that they've got the real app.

00:10:20.200 --> 00:10:24.410
Well, if we want to have that
same goodness, HTTPS is that.

00:10:24.410 --> 00:10:26.040
TLS is that for the web.

00:10:26.040 --> 00:10:29.330
But the second reason, that
relates to performance,

00:10:29.330 --> 00:10:33.400
is that we need to have
end-to-end reliability

00:10:33.400 --> 00:10:36.460
to deliver all that goodness,
all those multiplexed streams

00:10:36.460 --> 00:10:38.510
and the header compression.

00:10:38.510 --> 00:10:41.580
We need for our communications
between client and server

00:10:41.580 --> 00:10:44.970
to be opaque to all these
meddling middle boxes, all

00:10:44.970 --> 00:10:48.480
those people who want to insert
their own ads into your stream.

00:10:48.480 --> 00:10:50.880
They're also doing
things like, oh, I'm

00:10:50.880 --> 00:10:54.250
going to optimize your site
for you by stripping out

00:10:54.250 --> 00:10:55.230
some of your headers.

00:10:55.230 --> 00:10:55.990
It looks kind of big.

00:10:55.990 --> 00:10:57.640
I'm just going to get
rid of those for you.

00:10:57.640 --> 00:10:58.950
Well, maybe you needed those.

00:10:58.950 --> 00:11:00.560
Maybe your app depended on that.

00:11:00.560 --> 00:11:02.810
Or maybe they're
going to say, oh,

00:11:02.810 --> 00:11:05.010
I'm just going to
downscale all your images.

00:11:05.010 --> 00:11:06.620
It's better, trust us.

00:11:06.620 --> 00:11:09.400
And the users are like, why
does everything look so fuzzy,

00:11:09.400 --> 00:11:10.320
or whatever.

00:11:10.320 --> 00:11:13.640
Or there is passive
eavesdroppers.

00:11:13.640 --> 00:11:16.960
Mean time to Snowden
is 11 minutes.

00:11:16.960 --> 00:11:20.430
Passive eavesdroppers,
active tampers

00:11:20.430 --> 00:11:22.280
who are not messing
with your traffic

00:11:22.280 --> 00:11:24.690
for the purpose
of inserting ads,

00:11:24.690 --> 00:11:28.780
but may be inserting spamware,
adware, or fraudware,

00:11:28.780 --> 00:11:30.150
or spyware.

00:11:30.150 --> 00:11:32.440
All those sorts of
things can happen.

00:11:32.440 --> 00:11:34.809
Whether they're for
nominally good reasons

00:11:34.809 --> 00:11:36.600
or for nominally bad
reasons, we don't even

00:11:36.600 --> 00:11:38.660
need to worry about that.

00:11:38.660 --> 00:11:42.690
The fact is, HTTP/2 looks
so different on the wire,

00:11:42.690 --> 00:11:46.420
that all those middle boxes
that are expecting to see HTTP/1

00:11:46.420 --> 00:11:48.590
will do the wrong
thing when they

00:11:48.590 --> 00:11:51.200
try to help by
mangling your traffic.

00:11:51.200 --> 00:11:55.910
So we know from experience
that it's really, really hard

00:11:55.910 --> 00:12:00.130
to get a successful HTTP/2
deployment over not-TLS.

00:12:00.130 --> 00:12:03.990
Over plain TCP, all sorts
of breakage happens.

00:12:03.990 --> 00:12:05.740
So we need the reliability.

00:12:05.740 --> 00:12:08.900
If you think about
it, inside a computer,

00:12:08.900 --> 00:12:11.870
you've got your USB
wires and your PCIe.

00:12:11.870 --> 00:12:14.330
Well, we're building a
planet-sized computer.

00:12:14.330 --> 00:12:18.102
And the message bus is all
the air, all the copper.

00:12:18.102 --> 00:12:20.060
And basically, anyone
could be messing with it.

00:12:20.060 --> 00:12:21.350
And they are.

00:12:21.350 --> 00:12:25.470
So we need the basic
safety that TLS provides.

00:12:25.470 --> 00:12:30.290
In fact, this argument has
been going around and around

00:12:30.290 --> 00:12:32.640
since the very beginning
of the internet.

00:12:32.640 --> 00:12:35.440
If you haven't read it yet, you
should read this great paper

00:12:35.440 --> 00:12:39.480
by Jerry Saltzer from 1980.

00:12:39.480 --> 00:12:42.130
I think there was
drafts of it in 1979.

00:12:42.130 --> 00:12:45.140
And he's trying
to define what he

00:12:45.140 --> 00:12:48.920
calls a careful file transfer
application, which is basically

00:12:48.920 --> 00:12:51.700
what we're doing here, HTTP.

00:12:51.700 --> 00:12:53.460
And he says, so
if you were going

00:12:53.460 --> 00:12:55.990
to try to build such a
thing, you'd want the server

00:12:55.990 --> 00:12:57.549
to tell the client,
here's your file.

00:12:57.549 --> 00:12:59.340
And you want the client
to have some reason

00:12:59.340 --> 00:13:02.470
to believe they got the
full file with no damage.

00:13:02.470 --> 00:13:04.000
How would you do that?

00:13:04.000 --> 00:13:06.990
You could build reliability
stuff at the ends.

00:13:06.990 --> 00:13:08.830
Or you could try to
build reliability stuff

00:13:08.830 --> 00:13:10.130
in the middle.

00:13:10.130 --> 00:13:11.630
You could have the
telephone network

00:13:11.630 --> 00:13:15.610
try to make some kind of promise
of reliability or something

00:13:15.610 --> 00:13:16.670
like that.

00:13:16.670 --> 00:13:19.670
But instead, he
argued that the place

00:13:19.670 --> 00:13:23.540
to put the reliability
guarantee is at the endpoints.

00:13:23.540 --> 00:13:26.510
And any reliability guarantees
that happen in the middle--

00:13:26.510 --> 00:13:28.560
or if you will, at lower
layers in the network

00:13:28.560 --> 00:13:33.200
stack-- those are nice
optimizations if they work,

00:13:33.200 --> 00:13:34.650
which is not always.

00:13:34.650 --> 00:13:36.950
So if you really care,
do it at the endpoints.

00:13:36.950 --> 00:13:40.140
And that's, again, what TLS
gives us cryptographically.

00:13:40.140 --> 00:13:43.930
It cryptographically gives
us server authentication,

00:13:43.930 --> 00:13:46.960
data integrity, and
data confidentiality.

00:13:46.960 --> 00:13:49.960
What we mean by that, when I
say "cryptographically," what

00:13:49.960 --> 00:13:51.920
I mean is that it would
be computationally

00:13:51.920 --> 00:13:54.840
infeasible for one of
those middle layers

00:13:54.840 --> 00:13:58.230
to get away with
messing with your stuff.

00:13:58.230 --> 00:14:00.770
They could, but it
might take more energy

00:14:00.770 --> 00:14:03.730
than there is in the sun,
so we'll call that good,

00:14:03.730 --> 00:14:06.030
hopefully-- if the
cryptographers have done

00:14:06.030 --> 00:14:08.990
their job right, and
they usually have.

00:14:08.990 --> 00:14:10.990
They're much smarter than me.

00:14:10.990 --> 00:14:13.460
So really, security
and reliability

00:14:13.460 --> 00:14:15.170
are kind of the same thing.

00:14:15.170 --> 00:14:18.440
Security is reliability even
when people are purposefully

00:14:18.440 --> 00:14:19.690
messing with you.

00:14:19.690 --> 00:14:22.390
Reliability is like, oh, there's
noise, and there's bad weather,

00:14:22.390 --> 00:14:25.960
and lightning strikes caused
that server to go down, bummer.

00:14:25.960 --> 00:14:27.920
Security is when it was
not a lightning strike,

00:14:27.920 --> 00:14:32.620
it was a bomb, or some crazy
person inserting their own ads.

00:14:32.620 --> 00:14:35.890
And since the message
bus is the planet,

00:14:35.890 --> 00:14:38.510
we must, and should, assume
that we're always under attack.

00:14:41.260 --> 00:14:42.650
This all sounds good.

00:14:42.650 --> 00:14:45.850
I want to have all those
nice benefits of HTTP/2.

00:14:45.850 --> 00:14:47.620
I want to provide
safety to my users.

00:14:47.620 --> 00:14:50.020
I want my privacy
policy to be true.

00:14:50.020 --> 00:14:52.090
I want people to
feel good, and happy,

00:14:52.090 --> 00:14:54.110
and safe when
they're using my app.

00:14:54.110 --> 00:14:57.100
But I've heard that
TLS is really slow.

00:14:57.100 --> 00:14:58.330
Isn't it really slow?

00:14:58.330 --> 00:14:59.450
How can we fix that?

00:14:59.450 --> 00:15:00.390
Hmm.

00:15:00.390 --> 00:15:07.140
So there's several shades
of answer to that question.

00:15:07.140 --> 00:15:09.420
If you think of it
not as a Boolean,

00:15:09.420 --> 00:15:12.120
but as like an
8-bit wide answer,

00:15:12.120 --> 00:15:16.880
the high-order six bits
are all, no, it's not slow.

00:15:16.880 --> 00:15:18.870
And the low-order two
bits are, well, we

00:15:18.870 --> 00:15:20.600
could probably tune
up a couple things.

00:15:20.600 --> 00:15:23.710
So my colleague Ilya
Grigorik has a cool website,

00:15:23.710 --> 00:15:25.760
which if you haven't seen
it, you should visit,

00:15:25.760 --> 00:15:30.070
that expands on why all those
high-order six bits are zero.

00:15:30.070 --> 00:15:32.766
It's called istlsfastyet.com.

00:15:32.766 --> 00:15:34.930
And the answer
is, yes, except we

00:15:34.930 --> 00:15:36.640
need to get more
people using it.

00:15:36.640 --> 00:15:38.360
And he's also got
a really good book

00:15:38.360 --> 00:15:42.580
about optimizing
those last two bits.

00:15:42.580 --> 00:15:45.110
But let's think
about making sure

00:15:45.110 --> 00:15:49.610
that TLS always fits into
our performance budget.

00:15:49.610 --> 00:15:53.050
If we want to say we have 1,000
milliseconds before people will

00:15:53.050 --> 00:15:54.940
get bored and look
away, we've got

00:15:54.940 --> 00:15:56.950
to make sure we
meet that deadline.

00:15:56.950 --> 00:15:58.690
So let's do what
we can to make sure

00:15:58.690 --> 00:16:01.970
that TLS is not the thing
that breaks it, right?

00:16:01.970 --> 00:16:05.260
So the first thing to do is
optimize the higher layers

00:16:05.260 --> 00:16:08.950
first-- the content
layer, the HTTP layer.

00:16:08.950 --> 00:16:13.310
And HTTP/2 is all about building
in a lot of those HTTP layer

00:16:13.310 --> 00:16:16.570
optimizations into the protocol
so that you don't have to.

00:16:16.570 --> 00:16:18.110
And it gives you
more knobs to tune,

00:16:18.110 --> 00:16:20.920
like prioritizing different
file types and stuff.

00:16:20.920 --> 00:16:23.780
But the content
layer is a huge cost.

00:16:23.780 --> 00:16:27.060
And a lot of websites--
maybe even most websites--

00:16:27.060 --> 00:16:30.800
are paying way too much
there, in my experience.

00:16:30.800 --> 00:16:35.010
So here's some-- oh, I've
got my examples coming later.

00:16:35.010 --> 00:16:36.470
Yes, they're coming.

00:16:36.470 --> 00:16:39.460
So think about--
when you're thinking

00:16:39.460 --> 00:16:42.130
about how to optimize,
at the higher levels

00:16:42.130 --> 00:16:44.190
or at the lower
levels, you want to go

00:16:44.190 --> 00:16:46.330
through a workflow like this.

00:16:46.330 --> 00:16:49.370
Start by setting a
quantified target.

00:16:49.370 --> 00:16:53.070
If you don't have a quantity--
like 1,000 milliseconds,

00:16:53.070 --> 00:16:56.630
or each page load must be
less than 50 kilobytes,

00:16:56.630 --> 00:17:00.070
or whatever-- then,
by definition,

00:17:00.070 --> 00:17:01.680
you don't have a problem.

00:17:01.680 --> 00:17:03.260
And that might seem obvious.

00:17:03.260 --> 00:17:05.190
But in my previous
life, I did a lot

00:17:05.190 --> 00:17:09.480
of consulting where I would
beg people to turn on HTTPS.

00:17:09.480 --> 00:17:11.390
And they would
say, it's so slow.

00:17:11.390 --> 00:17:13.990
And I would say, well,
how fast is it now?

00:17:13.990 --> 00:17:15.730
And they would
say, I don't know.

00:17:15.730 --> 00:17:18.200
But it's got to be
as fast as possible.

00:17:18.200 --> 00:17:19.740
And it's like,
well, that's true.

00:17:19.740 --> 00:17:21.359
It should be as
fast as possible.

00:17:21.359 --> 00:17:23.960
But if you don't know how
fast or slow it is now,

00:17:23.960 --> 00:17:26.490
then you don't know
if TLS would hurt.

00:17:26.490 --> 00:17:28.700
And they never
liked that answer.

00:17:28.700 --> 00:17:31.480
So then I had to draw
pictures for them

00:17:31.480 --> 00:17:32.880
and give them examples.

00:17:32.880 --> 00:17:35.740
So assuming you've got a
quantified target-- and 1,000

00:17:35.740 --> 00:17:38.790
milliseconds is a pretty good
target-- measure the status

00:17:38.790 --> 00:17:39.720
quo.

00:17:39.720 --> 00:17:41.750
And we'll talk about
measuring in a moment.

00:17:41.750 --> 00:17:43.060
Where are you at now?

00:17:43.060 --> 00:17:45.330
Are you already,
even without TLS,

00:17:45.330 --> 00:17:47.060
not meeting your guarantee?

00:17:47.060 --> 00:17:48.122
Well, got work to do.

00:17:48.122 --> 00:17:49.830
Or maybe you already
are, and we're good.

00:17:49.830 --> 00:17:51.090
Let's stay there.

00:17:51.090 --> 00:17:56.300
And assuming you're not, you
can play this circle game

00:17:56.300 --> 00:17:58.280
of checking all the red squares.

00:17:58.280 --> 00:18:00.290
How many connections
are you making?

00:18:00.290 --> 00:18:02.120
How many resources
are you downloading?

00:18:02.120 --> 00:18:04.530
How many bytes is each
of those resources?

00:18:04.530 --> 00:18:06.330
Reduce all those
things-- how many

00:18:06.330 --> 00:18:09.960
TCP handshakes, how
many DNS lookups?

00:18:09.960 --> 00:18:12.730
I've seen sites where
just because they wanted

00:18:12.730 --> 00:18:15.860
to parallelize all
the 50 resources

00:18:15.860 --> 00:18:18.710
they load per page load,
they would parallelize it

00:18:18.710 --> 00:18:20.900
over 25 CDNs.

00:18:20.900 --> 00:18:24.450
And looking up 25 host
names blew their budget

00:18:24.450 --> 00:18:27.760
before making any TCP
or HTTP connections.

00:18:27.760 --> 00:18:33.660
So well, maybe too much
parallelism can be a bad thing.

00:18:33.660 --> 00:18:37.040
And again, HTTP/2 does a
lot of this stuff for you.

00:18:37.040 --> 00:18:39.630
But it still matters
at the content layer.

00:18:39.630 --> 00:18:41.500
So do all that.

00:18:41.500 --> 00:18:43.080
Measure the status quo again.

00:18:43.080 --> 00:18:44.220
How are we doing?

00:18:44.220 --> 00:18:46.390
Have we met our
guarantee or not?

00:18:46.390 --> 00:18:47.310
Maybe go back.

00:18:47.310 --> 00:18:49.260
Maybe you've met
a new guarantee,

00:18:49.260 --> 00:18:51.700
and you'd like to tighten
your quantified goal.

00:18:51.700 --> 00:18:52.950
So that's great.

00:18:52.950 --> 00:18:55.060
Obviously, now you
can do even better,

00:18:55.060 --> 00:18:56.990
500 milliseconds
instead of 1,000.

00:18:56.990 --> 00:18:58.120
That would be sweet.

00:18:58.120 --> 00:19:00.880
When you feel you're happy,
you can go to the green circle

00:19:00.880 --> 00:19:02.220
and be done.

00:19:02.220 --> 00:19:04.970
And then when you add TLS, you
can do this exercise again,

00:19:04.970 --> 00:19:08.030
make sure you're still meeting
your budget, whatever it is.

00:19:08.030 --> 00:19:10.990
And if not, fix some stuff.

00:19:10.990 --> 00:19:16.920
So to recap, TLS underlies all
those performance guarantees.

00:19:16.920 --> 00:19:18.110
So we have to have it.

00:19:18.110 --> 00:19:21.770
And I admit, TLS is not free.

00:19:21.770 --> 00:19:23.890
I like to do this.

00:19:23.890 --> 00:19:25.370
Let's have a poll.

00:19:25.370 --> 00:19:29.480
So there's all those
things of TLS-- the server

00:19:29.480 --> 00:19:32.120
authentication, the data
integrity, and the data

00:19:32.120 --> 00:19:33.230
confidentiality.

00:19:33.230 --> 00:19:35.140
There's a lot of
crypto going on.

00:19:35.140 --> 00:19:39.130
And there's additional network
traffic to do the handshake.

00:19:39.130 --> 00:19:44.960
So who thinks that the symmetric
cryptography, the encryption

00:19:44.960 --> 00:19:47.670
of the data, is the
slow thing of TLS?

00:19:47.670 --> 00:19:49.400
Anyone think that?

00:19:49.400 --> 00:19:50.396
Nobody thinks that?

00:19:50.396 --> 00:19:52.770
That's interesting, because
everyone else on the internet

00:19:52.770 --> 00:19:53.910
does think that.

00:19:53.910 --> 00:19:54.630
They're wrong.

00:19:54.630 --> 00:19:57.597
You're all right,
so good on you.

00:19:57.597 --> 00:19:59.055
Another thing that
could be slow is

00:19:59.055 --> 00:20:03.470
the asymmetry chromatography,
the public/private key pairs

00:20:03.470 --> 00:20:05.820
where you say, hi, I'm
really twitter.com,

00:20:05.820 --> 00:20:09.450
and no one could, in the
lifetime of the universe,

00:20:09.450 --> 00:20:11.549
falsify this guarantee
that I'm about to make you.

00:20:11.549 --> 00:20:14.090
And then the clients says, well,
let me just check that math.

00:20:14.090 --> 00:20:14.910
Is that slow?

00:20:14.910 --> 00:20:16.030
Any hands?

00:20:16.030 --> 00:20:18.900
Some hands, not zero.

00:20:18.900 --> 00:20:21.550
Those of you who raised
your hands are about right.

00:20:21.550 --> 00:20:24.700
That's slower stuff.

00:20:24.700 --> 00:20:28.450
It's fixable, but yeah, you're
going to pay some price there.

00:20:28.450 --> 00:20:30.820
It's going to be like
in the milliseconds.

00:20:30.820 --> 00:20:32.530
You'll notice it.

00:20:32.530 --> 00:20:34.050
And that's a bummer.

00:20:34.050 --> 00:20:36.110
And then the third thing
that might cost us time

00:20:36.110 --> 00:20:38.890
is the network, the additional
part of the handshake.

00:20:38.890 --> 00:20:40.720
Who thinks that's expensive?

00:20:40.720 --> 00:20:43.310
Many more people-- and
again, you are right.

00:20:43.310 --> 00:20:44.560
That's the thing.

00:20:44.560 --> 00:20:46.260
So when you're
worrying about TLS,

00:20:46.260 --> 00:20:48.970
worry first about
that network overhead.

00:20:48.970 --> 00:20:52.480
Worry second about
that asymmetric crypto.

00:20:52.480 --> 00:20:54.339
Don't worry about
the symmetric crypto.

00:20:54.339 --> 00:20:55.380
Think about it like this.

00:20:55.380 --> 00:20:58.310
We can watch DRM video, right?

00:20:58.310 --> 00:21:00.190
So it's being
symmetrically decrypted,

00:21:00.190 --> 00:21:02.210
and then blasted to your GPU.

00:21:02.210 --> 00:21:05.210
And nobody ever even knows
that the video is encrypted,

00:21:05.210 --> 00:21:06.640
because it just does not matter.

00:21:06.640 --> 00:21:07.640
So don't worry about it.

00:21:07.640 --> 00:21:09.380
So worry about
the network stuff.

00:21:09.380 --> 00:21:14.670
So we can amortise those
costs-- after, of course,

00:21:14.670 --> 00:21:16.540
working on our content layer.

00:21:16.540 --> 00:21:21.080
So what you want to
do is, at every stage,

00:21:21.080 --> 00:21:26.610
in that playing the red
square game, keep measuring.

00:21:26.610 --> 00:21:30.390
And Chrome provides you
some nice measurement tools.

00:21:30.390 --> 00:21:32.610
I'm a huge fan of the DevTools.

00:21:32.610 --> 00:21:35.730
They're super nice, as
hopefully you already know.

00:21:35.730 --> 00:21:38.310
There's this network
tab that tells you

00:21:38.310 --> 00:21:42.090
what Chrome is doing on the
network to load your app.

00:21:42.090 --> 00:21:44.040
And I'll say "app"
instead of "site."

00:21:44.040 --> 00:21:46.520
So here's a page load.

00:21:46.520 --> 00:21:49.130
I visit the "New York
Times" every day.

00:21:49.130 --> 00:21:55.180
And I'm always interested to see
what is going on content-wise.

00:21:55.180 --> 00:21:57.640
It's very heavy weight.

00:21:57.640 --> 00:22:00.760
And before you laugh, make sure
that your site isn't like this.

00:22:00.760 --> 00:22:02.480
I don't use them
to pick on them.

00:22:02.480 --> 00:22:05.100
I use them because it's
just a super common site

00:22:05.100 --> 00:22:06.830
that everybody visits.

00:22:06.830 --> 00:22:09.050
So we can see a couple
things in this network tab.

00:22:09.050 --> 00:22:12.710
It tells us the status
and type of each request,

00:22:12.710 --> 00:22:16.210
how many seconds it
takes to load the page,

00:22:16.210 --> 00:22:19.890
and where in time
the request happened.

00:22:19.890 --> 00:22:21.940
Here we are, 57 requests.

00:22:21.940 --> 00:22:24.110
I just visited just
the front page.

00:22:24.110 --> 00:22:26.690
We've already transferred
half a megabyte,

00:22:26.690 --> 00:22:30.590
and whichever request we're
on here-- maybe it's 15.

00:22:30.590 --> 00:22:32.250
We're toward the
bottom, I guess.

00:22:32.250 --> 00:22:35.140
We're one, two,
three seconds in.

00:22:35.140 --> 00:22:39.600
And we can also see how big each
resource is-- 4 kilobytes, 500,

00:22:39.600 --> 00:22:41.700
whatever it might be.

00:22:41.700 --> 00:22:45.830
So there's a couple good things
about how the "New York Times"

00:22:45.830 --> 00:22:49.020
site loads, some bad stuff.

00:22:49.020 --> 00:22:51.810
And make sure that we
want to move things

00:22:51.810 --> 00:22:53.410
into the good category.

00:22:53.410 --> 00:22:57.340
So first thing, they sprited
their many little icons.

00:22:57.340 --> 00:23:00.740
So obviously, if you figure
there's like 50 icons there,

00:23:00.740 --> 00:23:03.280
you definitely would not
want to make 50 requests

00:23:03.280 --> 00:23:04.900
to get them all.

00:23:04.900 --> 00:23:06.070
So you sprite them.

00:23:06.070 --> 00:23:07.112
And that helps a lot.

00:23:07.112 --> 00:23:09.320
So make sure you're doing
that if you're not already.

00:23:09.320 --> 00:23:12.330
Because the overhead of
starting a new network

00:23:12.330 --> 00:23:14.680
connection for each of
those would really kill you.

00:23:14.680 --> 00:23:16.710
And then TLS would
look really bad,

00:23:16.710 --> 00:23:19.730
if you made 50, just to
get little bitty icons.

00:23:19.730 --> 00:23:22.260
So there's some bad
stuff about their site

00:23:22.260 --> 00:23:24.620
that they could easily fix.

00:23:24.620 --> 00:23:27.510
First, we have here
some JavaScript.

00:23:27.510 --> 00:23:29.520
It's gzipped, which
is super good.

00:23:29.520 --> 00:23:31.470
Always make sure
you're doing that.

00:23:31.470 --> 00:23:35.860
But even gzipped, it's
still 62 kilobytes.

00:23:35.860 --> 00:23:37.730
So think about
what a browser has

00:23:37.730 --> 00:23:41.280
to do to parse and
execute all that code.

00:23:41.280 --> 00:23:45.540
62 kilobytes compressed-- so
multiply it by five, or eight.

00:23:45.540 --> 00:23:47.750
So pretty soon, you're
talking about a lot of code.

00:23:47.750 --> 00:23:49.580
And that's just one of many.

00:23:49.580 --> 00:23:54.140
Here is another JavaScript--
not compressed, for some reason.

00:23:54.140 --> 00:23:56.050
And it's set to never cache.

00:23:56.050 --> 00:23:58.540
It says, specifically,
don't cache this.

00:23:58.540 --> 00:24:02.350
Well, it turns out it's
often exactly the same text,

00:24:02.350 --> 00:24:03.886
so they could have cached it.

00:24:03.886 --> 00:24:05.760
And certainly, they
could have compressed it.

00:24:05.760 --> 00:24:07.843
So make sure you're always
caching and compressing

00:24:07.843 --> 00:24:09.200
as much as you can.

00:24:09.200 --> 00:24:13.160
And here's a trouble spot that
would be the kind of thing that

00:24:13.160 --> 00:24:15.830
would make TLS
seem too expensive,

00:24:15.830 --> 00:24:17.930
but really the
cost is elsewhere.

00:24:17.930 --> 00:24:22.350
So here's a CSS file
that contains within it

00:24:22.350 --> 00:24:25.440
a base64 encoded font.

00:24:25.440 --> 00:24:27.500
And the base64
encoding multiplies it

00:24:27.500 --> 00:24:32.060
by what ratio, anyone?

00:24:32.060 --> 00:24:35.534
Four over three-- someone said
four over three, which is true.

00:24:35.534 --> 00:24:36.950
So it's bigger
than it needs to be

00:24:36.950 --> 00:24:38.570
because of how
they've encoded it.

00:24:38.570 --> 00:24:42.480
And then they set it to
cache for only 300 seconds.

00:24:42.480 --> 00:24:44.532
And it's half a megabyte.

00:24:44.532 --> 00:24:45.990
So every five
minutes, you're going

00:24:45.990 --> 00:24:48.670
to get another half megabyte
font file that's probably

00:24:48.670 --> 00:24:50.810
the same as it was
five minutes ago.

00:24:50.810 --> 00:24:53.680
So don't live in this world.

00:24:53.680 --> 00:24:54.800
That would be sad.

00:24:54.800 --> 00:24:55.680
That would be slow.

00:24:55.680 --> 00:24:57.390
That will blow your budget.

00:24:57.390 --> 00:24:59.860
So in addition to
Chrome DevTools,

00:24:59.860 --> 00:25:01.900
it's also good to
look a layer below.

00:25:01.900 --> 00:25:05.570
Look at the TCP, and
DNS, and IP layers.

00:25:05.570 --> 00:25:07.200
So who has used Wireshark?

00:25:07.200 --> 00:25:10.170
Hopefully some people--
good, many of you, great.

00:25:10.170 --> 00:25:11.670
So you can see
lots of good stuff,

00:25:11.670 --> 00:25:15.170
including what's going on at
the TLS layer in Wireshark.

00:25:15.170 --> 00:25:18.360
And I find that it's
always an eye opener.

00:25:18.360 --> 00:25:21.320
When I was in consulting world
trying to convince people

00:25:21.320 --> 00:25:23.860
that they could
indeed afford HTTPS,

00:25:23.860 --> 00:25:27.370
I'd bring up a screen like
this, and many eyes would open.

00:25:27.370 --> 00:25:31.480
So there's a couple things
going on in this page.

00:25:31.480 --> 00:25:34.480
This one, it's a
very small page load.

00:25:34.480 --> 00:25:38.620
It only took a quarter of a
second to get all the packets.

00:25:38.620 --> 00:25:41.980
There's only about 18 total.

00:25:41.980 --> 00:25:44.810
We can see at the bottom,
there's no visible text.

00:25:44.810 --> 00:25:46.270
It doesn't look like a web page.

00:25:46.270 --> 00:25:47.750
It's all cypher text.

00:25:47.750 --> 00:25:50.050
And that's what you want all
those ad inserting people

00:25:50.050 --> 00:25:51.640
to see, is nothing.

00:25:51.640 --> 00:25:55.989
All those people, all
those passive surveillers,

00:25:55.989 --> 00:25:58.530
all those tamperers, you don't
want them to be able to do it.

00:25:58.530 --> 00:25:59.155
So that's good.

00:25:59.155 --> 00:26:00.770
We can see that that's working.

00:26:00.770 --> 00:26:05.180
And then we see that the size
of the packets is mostly small.

00:26:05.180 --> 00:26:08.370
There is one thing that
stands out, though.

00:26:08.370 --> 00:26:10.920
The Server Hello, which
contains the certificate,

00:26:10.920 --> 00:26:14.990
is like 2,700,
2,800 bytes, which

00:26:14.990 --> 00:26:18.380
is also about the same
size as the whole web page.

00:26:18.380 --> 00:26:20.120
So that's a bummer.

00:26:20.120 --> 00:26:23.600
I would really like to amortise
that cost, and reduce it.

00:26:23.600 --> 00:26:27.680
So one thing you want
to do is make sure

00:26:27.680 --> 00:26:31.040
that your TLS sessions
live as long as possible so

00:26:31.040 --> 00:26:34.280
that you don't need
to re-handshake TLS.

00:26:34.280 --> 00:26:35.660
I don't know if you knew this.

00:26:35.660 --> 00:26:39.386
You can restart an
existing TLS session

00:26:39.386 --> 00:26:41.010
that the client and
server have already

00:26:41.010 --> 00:26:44.820
negotiated over a totally
different TCP connection five

00:26:44.820 --> 00:26:47.650
minutes, or five days,
later, if either side is

00:26:47.650 --> 00:26:49.510
keeping a cache that long.

00:26:49.510 --> 00:26:51.480
So make sure that your
server is configured

00:26:51.480 --> 00:26:54.810
to keep TLS sessions
alive as long as

00:26:54.810 --> 00:26:57.840
possible so that you don't
pay that expensive network

00:26:57.840 --> 00:27:01.800
thing very often.

00:27:01.800 --> 00:27:05.000
And also, things like
HTTP persistence,

00:27:05.000 --> 00:27:10.410
and pipelining, or HTTP/2
streams get the most benefit

00:27:10.410 --> 00:27:14.520
from the handshake
that you do pay for.

00:27:14.520 --> 00:27:17.450
Also, you want to make sure
that that initial stuff, all

00:27:17.450 --> 00:27:21.500
the setup, the TCP
setup, and the TLS setup,

00:27:21.500 --> 00:27:25.760
falls within the initial
congestion window in TCP.

00:27:25.760 --> 00:27:27.840
If they don't, you'll
have to wait just

00:27:27.840 --> 00:27:30.300
for the acts for your handshake.

00:27:30.300 --> 00:27:33.280
And that will slow
you down badly.

00:27:33.280 --> 00:27:35.890
The good news there
is that it's becoming

00:27:35.890 --> 00:27:39.030
a standard internet-wide to
make that congestion window much

00:27:39.030 --> 00:27:40.470
larger.

00:27:40.470 --> 00:27:44.360
In the old bad days,
that 2,700, 2,800 bytes

00:27:44.360 --> 00:27:46.360
might have blown the budget.

00:27:46.360 --> 00:27:49.620
But these days,
usually, often-- and you

00:27:49.620 --> 00:27:54.440
can check with Wireshark
and libpcap, and other tools

00:27:54.440 --> 00:27:58.010
that you are in fact not
blowing the initial congestion

00:27:58.010 --> 00:27:59.790
window just with your handshake.

00:27:59.790 --> 00:28:01.030
Because that can be a bummer.

00:28:01.030 --> 00:28:03.860
So these days you have
a lot more head room,

00:28:03.860 --> 00:28:07.180
maybe as much as 5,000
bytes, maybe even 8,000.

00:28:07.180 --> 00:28:08.430
And that helps a lot.

00:28:08.430 --> 00:28:10.890
But if your server
certificate is really big,

00:28:10.890 --> 00:28:13.170
or the chain is
unnecessarily long,

00:28:13.170 --> 00:28:14.990
or if your CA gave
you a certificate that

00:28:14.990 --> 00:28:19.900
includes their logo-- some of
them have JPEGs of the logo.

00:28:19.900 --> 00:28:21.600
It's like, well, those
bytes are wasted.

00:28:21.600 --> 00:28:24.430
And those are the most important
bytes, those starting bytes,

00:28:24.430 --> 00:28:25.930
so don't get caught there.

00:28:25.930 --> 00:28:30.030
So just by looking,
almost everybody-- and I'd

00:28:30.030 --> 00:28:32.770
be surprised if any of
you are already at a point

00:28:32.770 --> 00:28:35.270
where your app was already
maximally optimized

00:28:35.270 --> 00:28:36.820
at each of the layers.

00:28:36.820 --> 00:28:40.800
So just by looking, you can
discover lots of headroom

00:28:40.800 --> 00:28:42.470
where you can introduce safety.

00:28:42.470 --> 00:28:46.100
And overall, I should
note that in this move

00:28:46.100 --> 00:28:52.240
to SPDY and HTTP/2, in certain
cases, by going to HTTPS,

00:28:52.240 --> 00:28:56.160
Google has experienced an
overall latency reduction, not

00:28:56.160 --> 00:28:57.320
an increase.

00:28:57.320 --> 00:28:59.630
Even an affordable
increase would be cool.

00:28:59.630 --> 00:29:02.380
But oftentimes, we're
actually able to do better

00:29:02.380 --> 00:29:05.720
by introducing end-to-end
security and reliability.

00:29:05.720 --> 00:29:07.250
And it's good for users.

00:29:07.250 --> 00:29:09.200
So thanks for hanging out.

00:29:09.200 --> 00:29:13.270
And I'll be at the panel,
I think, immediately next.

00:29:13.270 --> 00:29:14.520
There's a booth.

00:29:14.520 --> 00:29:16.770
So come yell at me if I'm wrong.

00:29:16.770 --> 00:29:17.270
Thanks.

00:29:17.270 --> 00:29:20.320
[APPLAUSE]

