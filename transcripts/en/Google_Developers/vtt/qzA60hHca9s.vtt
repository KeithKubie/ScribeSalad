WEBVTT
Kind: captions
Language: en

00:00:03.740 --> 00:00:07.670
&gt;&gt;Alex Komoroske: Hi and welcome to HTML5,
What's Next? My name is Alex Komoroske. I'm

00:00:07.670 --> 00:00:11.830
a product manager on Chrome focusing on the
open Web platform. And I'm also a Web developer

00:00:11.830 --> 00:00:15.070
myself, spent many years working on the Web
platform. That's why I'm so excited about

00:00:15.070 --> 00:00:17.820
making it even better.
&gt;&gt;Ian Fette: Hi, everyone. My name's Ian Fette.

00:00:17.820 --> 00:00:22.840
I'm a product manager on Google Chrome. I
joined the team about four years ago working

00:00:22.840 --> 00:00:27.420
on security and infrastructure, like networking
stack and disk cache. And for the past few

00:00:27.420 --> 00:00:32.050
years, I have been focused on HTML5.
&gt;&gt;Alex Russell: Hi, I'm Alex Russell. I'm

00:00:32.050 --> 00:00:36.510
a software engineer on the Chrome project,
working on Chrome Frame and the Chrome Web

00:00:36.510 --> 00:00:37.700
platform more generally.
&gt;&gt;Alex Komoroske: Cool.

00:00:37.700 --> 00:00:42.600
So before we get started, here is the speaker
meter link for this talk as well as the hash-tag

00:00:42.600 --> 00:00:46.510
if you feel the need to tweet.
Today, if you came to any of the earlier talks,

00:00:46.510 --> 00:00:49.690
you saw a the lot of really cool demos about
what you can do with HTML5 today.

00:00:49.690 --> 00:00:54.090
Today we are also going to continue that by
telling you about capabilities that are being

00:00:54.090 --> 00:00:58.260
built into the platform today including FileSystem
and WebSocket 3D.

00:00:58.260 --> 00:01:04.660
We are also going to spend a lot of time talking
about the future of the Web platform, really

00:01:04.660 --> 00:01:08.020
how you can unlock the potential -- what we
think is important for unlocking the potential

00:01:08.020 --> 00:01:11.140
of the Web platform going forward.
Some of the things we will talk about are

00:01:11.140 --> 00:01:16.009
so new, they are still under discussion there
is no spec for them necessarily yet. And they

00:01:16.009 --> 00:01:18.789
definitely aren't implemented.
We think it is important that these kinds

00:01:18.789 --> 00:01:20.049
of things are going to be important for making
the Web platform even better going forward.

00:01:20.049 --> 00:01:27.039
We will talk about some proposals for CSS,
for JavaScript and also something we call

00:01:27.039 --> 00:01:31.289
model-driven views.
But, first, let's very quickly just review

00:01:31.289 --> 00:01:35.340
how we got here on the Web platform.
The Web platform started out obviously as

00:01:35.340 --> 00:01:40.469
a very -- as a long time ago as a way to share
very simple documents written in HTML. Of

00:01:40.469 --> 00:01:43.499
course, that wasn't enough. People wanted
to be able to style their stuff. Now you have

00:01:43.499 --> 00:01:44.929
CSS.
Of course, people wanted to be able to add

00:01:44.929 --> 00:01:49.700
simple behaviors and so you have JavaScript.
People pushed that basic capability so far,

00:01:49.700 --> 00:01:55.890
they built things like Google Maps and Gmail
and Google Docs. You have apps -- real apps

00:01:55.890 --> 00:01:58.869
being built on a platform that originally
was designed for documents.

00:01:58.869 --> 00:02:02.460
Now, of course, the Web platform hasn't stayed
still. It has been adding tons of capabilities.

00:02:02.460 --> 00:02:06.759
You can do some really amazing stuff with
it now with complex graphical effects, video,

00:02:06.759 --> 00:02:11.709
even 3D. We are adding more and more capabilities
to the platform all the time, really expanding

00:02:11.709 --> 00:02:14.780
the vocabulary of what you can say on this
platform.

00:02:14.780 --> 00:02:20.390
Remember, this platform did originally begin
with static documents. And although it is

00:02:20.390 --> 00:02:25.220
a very full-fledged, full-featured platform,
some of these features were added ad hoc.

00:02:25.220 --> 00:02:30.222
And it takes a lot of -- a lot to wield the
power inherent in the platform today.

00:02:30.222 --> 00:02:34.440
So although today you can build incredibly,
amazingly beautifully, powerful apps, it requires

00:02:34.440 --> 00:02:37.570
a lot of JavaScript and it requires you to
basically be what I would describe as kind

00:02:37.570 --> 00:02:42.730
of a Web development ninja. And not everyone
has the patience to become a Web development

00:02:42.730 --> 00:02:45.080
ninja.
That's why we think it is important not just

00:02:45.080 --> 00:02:49.680
to expand the vocabulary of the platform but
also to focus on making it so you don't have

00:02:49.680 --> 00:02:53.850
to be a ninja to write delightful apps.
We think by doing that, it will really unlock

00:02:53.850 --> 00:02:58.880
the potential of the platform.
We think the way to do that is to allow developers

00:02:58.880 --> 00:03:02.220
to say what they mean.
Before we get to what I mean by "say what

00:03:02.220 --> 00:03:06.530
you mean," let's go to Ian to hear more about
the capabilities in the platform today.

00:03:06.530 --> 00:03:13.390
&gt;&gt;Ian Fette: Thanks, Alex. So a quick question.
How many of you were here for Google I/O 2010?

00:03:13.390 --> 00:03:20.230
Awesome. I see a lot of hands. And it is really
cool to see so many people here because last

00:03:20.230 --> 00:03:25.790
year when Chrome was giving some talks, we
were in what was then the largest room that

00:03:25.790 --> 00:03:32.450
held about 500 people. This room here holds
about 750 people and it looks quite full.

00:03:32.450 --> 00:03:36.930
So I'm very excited to see all these people
sort of interested in knowing what's going

00:03:36.930 --> 00:03:41.150
on.
So Alex sort of gave a great lead-in. We do

00:03:41.150 --> 00:03:46.460
think it is important to let you do more on
the Web, to expand your vocabulary, to let

00:03:46.460 --> 00:03:51.750
you be more expressive in the types of applications
that you want to develop. We talked a little

00:03:51.750 --> 00:03:55.431
bit last year about what we're doing, and
I want to give an update of what's going on

00:03:55.431 --> 00:04:01.820
in terms of new capabilities that we're adding
to the Web platform through Chrome.

00:04:01.820 --> 00:04:07.910
So if you were at Eric and Arne's talk this
morning, you saw FileSystem being demoed.

00:04:07.910 --> 00:04:16.810
FileSystem is something we first talked about
it at Google I/O 2010, so almost a year ago.

00:04:16.810 --> 00:04:21.259
There have been a lot of changes since then,
since Chrome 8 when we introduced this.

00:04:21.259 --> 00:04:25.900
For those who aren't familiar with FileSystem,
I have a snippet of code which sort of shows

00:04:25.900 --> 00:04:30.240
what you can do with a FileSystem. Here I
am requesting a FileSystem that's temporary.

00:04:30.240 --> 00:04:35.160
I will talk a little bit more about that later.
I'm creating a file, a simple logfile. I am

00:04:35.160 --> 00:04:39.300
going to move to the end of the file. I will
get a writer for the file so I can write to

00:04:39.300 --> 00:04:45.669
it. I will seek that to the end. I will write
some data to it. So FileSystem is an API that

00:04:45.669 --> 00:04:49.639
let's you store data on the user's computer,
relatively straightforward.

00:04:49.639 --> 00:04:54.289
I want to talk a little bit about some of
the changes that have happened since Chrome

00:04:54.289 --> 00:04:59.020
8 to actually let you use FileSystem and let
you use it in a more useful way.

00:04:59.020 --> 00:05:04.780
So perhaps the most boring change since Chrome
8 is we used to have a lot of references with

00:05:04.780 --> 00:05:10.650
respect to URIs. These are now URLs. It is
very simple and straightforward and boring,

00:05:10.650 --> 00:05:14.259
but I wanted to get it out of the way so we
can talk about more interesting changes.

00:05:14.259 --> 00:05:18.991
What's actually interesting in FileSystem
land, when we first introduced this API about

00:05:18.991 --> 00:05:24.449
a year ago, it was only usable within the
context of Chrome apps and Chrome extensions.

00:05:24.449 --> 00:05:28.289
If you are developing a Chrome app or Chrome
extension, you can use this now. You can request

00:05:28.289 --> 00:05:33.479
unlimited storage quota and you can save things
on the user's hard drive in a structured way,

00:05:33.479 --> 00:05:37.629
in a FileSystem. And that's great.
But we've gotten feedback that there is a

00:05:37.629 --> 00:05:42.120
lot of people that don't necessarily want
to have to get users to install a Chrome application

00:05:42.120 --> 00:05:46.620
or a Chrome extension just so they can use
this API.

00:05:46.620 --> 00:05:51.939
So we're working to make this available outside
of apps and extensions, and we're hoping to

00:05:51.939 --> 00:05:57.969
have this working on dev channel by the end
of the month. In Chrome 13, we are going to

00:05:57.969 --> 00:06:03.180
enable this -- this API outside of apps and
extensions. So that's one big change.

00:06:03.180 --> 00:06:07.279
But the second big change, for those of you
that have tried to use a lot of the storage

00:06:07.279 --> 00:06:15.759
APIs, be it FileSystem, WebSQL Database Indexed
Database API, AppCache, you often hit this

00:06:15.759 --> 00:06:20.400
five-megabyte limit. You are like, Wow, what
can I actually do with five megabytes?

00:06:20.400 --> 00:06:26.219
If you are trying to store a user's email,
my inbox is somewhere around 30 gigabytes.

00:06:26.219 --> 00:06:30.259
You are going to hit that five-meg limit pretty
quick. If you are trying to let users edit

00:06:30.259 --> 00:06:34.350
photos and then upload those, again, five
megabytes, it is like poof, gone.

00:06:34.350 --> 00:06:39.650
It is like, Can you just get rid of that five
megabytes? No, we can't because if we get

00:06:39.650 --> 00:06:43.880
rid of it entirely and say, Sure, we will
store data on the user's computer and we'll

00:06:43.880 --> 00:06:48.900
never delete it, it will be there for you,
then anyone can sort of just fill up the hard

00:06:48.900 --> 00:06:52.090
drive. This isn't a good solution.
So what we're trying to do is we're trying

00:06:52.090 --> 00:07:00.069
to introduce a notion of quota. The way we
are doing this, there's two things happening.

00:07:00.069 --> 00:07:05.699
One is that we now have a notion of two types
of quota: One is temporary, one is persistent.

00:07:05.699 --> 00:07:11.189
The way you interact with this quota is through
an interface called StorageInfo.

00:07:11.189 --> 00:07:17.540
So before I get into StorageInfo, let me explain
what temporary and persistent quota are. First

00:07:17.540 --> 00:07:24.379
of all, a lot of APIs nowadays are requesting
-- they're requesting some capability and

00:07:24.379 --> 00:07:28.650
then the browser puts up this modal dialogue
or this info bar and says, Hey, user, can

00:07:28.650 --> 00:07:33.150
I do X, Y, Z? We really want to avoid this
as much as possible.

00:07:33.150 --> 00:07:38.270
What we are doing by creating temporary quota
is we are saying, you, the developer, can

00:07:38.270 --> 00:07:42.589
store things on the user's computer. You can
already store things like cookies, so the

00:07:42.589 --> 00:07:48.110
actual impact of storing something on the
computer is not that great. And we won't ask

00:07:48.110 --> 00:07:51.839
the user. We won't put up any annoying dialogues.
We will just let you have some storage. You

00:07:51.839 --> 00:07:57.279
can say, Hey, I want to make the user's email
available for offline browsing. Give me five

00:07:57.279 --> 00:08:02.490
gigabytes of temporary quota. We'll say, Sure.
There is, like, 500 gigabytes free on the

00:08:02.490 --> 00:08:05.871
hard drive. Here's your five gigs. Have fun
with it.

00:08:05.871 --> 00:08:09.509
You can keep doing this and getting more quota.
But, eventually, we're going to run out of

00:08:09.509 --> 00:08:17.219
space. And the key thing about temporary quota
is it is managed by the browser. So if another

00:08:17.219 --> 00:08:22.319
site requests quota and there's none available,
we have to figure out as a browser how do

00:08:22.319 --> 00:08:26.009
we make this available? So we, the browser,
will feel free to delete things in temporary

00:08:26.009 --> 00:08:30.009
storage to make room for applications that
users use most frequently.

00:08:30.009 --> 00:08:34.790
This let's all the management happen outside
the user's view. There is no annoying dialogues

00:08:34.790 --> 00:08:37.909
or prompts, and it just works.
But that doesn't work for everything. What

00:08:37.909 --> 00:08:43.159
if you're an offline email program and the
user is typing up an email? You don't really

00:08:43.159 --> 00:08:47.860
want that email they've composed to get deleted
by something else. So temporary storage doesn't

00:08:47.860 --> 00:08:50.949
work for everything. For this, we have the
notion of persistent storage.

00:08:50.949 --> 00:08:56.339
So if you request persistent storage, we guarantee
you that we won't just evict it. We won't

00:08:56.339 --> 00:09:00.810
delete it. Because of this, we will ask the
user for permission. So we're hoping that

00:09:00.810 --> 00:09:07.800
together this will enable offline apps to
actually make use of the storage APIs.

00:09:07.800 --> 00:09:12.070
The interface for this is quite simple. You
can query how much quota you're using and

00:09:12.070 --> 00:09:16.350
should you need to request quota, there is
a simple API to request quota.

00:09:16.350 --> 00:09:20.380
So this is what's going on in the land of
storage. What else is going on?

00:09:20.380 --> 00:09:24.509
Well, last year we talked a little bit about
WebSockets. WebSockets, as you can see on

00:09:24.509 --> 00:09:31.399
the screen, is an API for bidirectional communication.
So a lot of applications do this today, things

00:09:31.399 --> 00:09:37.930
like chat. You are sending chat messages,
updates back and forth to a server. If it

00:09:37.930 --> 00:09:42.130
is email, you might be pulling for email.
And although it is possible to do this, it

00:09:42.130 --> 00:09:46.779
is very inefficient right now. You often have
to open two connections. You're sending a

00:09:46.779 --> 00:09:52.269
full HTTP request with headers, cookies each
time. Even if you are sending one word, five

00:09:52.269 --> 00:09:57.850
bytes, that might get blown up to hundreds
of kilobytes depending on all the headers

00:09:57.850 --> 00:10:02.350
and cookies and who knows what else.
So WebSockets is meant to be a very simple

00:10:02.350 --> 00:10:08.380
API that lets you send and receive messages
over a persistent connection.

00:10:08.380 --> 00:10:13.670
The spec is now in last call as of April so
this is really getting finalized. We've got

00:10:13.670 --> 00:10:18.220
a lot of browser interest, all the browsers
are looking at this. Microsoft has an experimental

00:10:18.220 --> 00:10:22.319
implementation out that you can download.
FireFox and Opera are both also working on

00:10:22.319 --> 00:10:28.390
it. So a lot of momentum around WebSockets,
and now we are sort of changing our focus

00:10:28.390 --> 00:10:32.680
to multiplexing so you have even more connections
open at one time and still be efficient.

00:10:32.680 --> 00:10:37.970
And last, but not least, 3D. Those of you
who were at the keynote this morning, you

00:10:37.970 --> 00:10:43.450
got to see Angry Birds in 3D. This is my absolute
favorite. I'm sort of addicted to it. There

00:10:43.450 --> 00:10:48.680
has been a lot of progress in 3D.
As of Chrome 9 back in February, we now have

00:10:48.680 --> 00:10:53.319
WebGL enabled by default, not just on the
latest, greatest, Windows 7 computers but

00:10:53.319 --> 00:11:00.389
also for people who are running Vista and
XP as well. So WebGL, broadly enabled, that's

00:11:00.389 --> 00:11:04.580
really cool if you are building games or things
with immersive 3D environments.

00:11:04.580 --> 00:11:10.790
But what if you want to just sort of add some
3D flare? You've got, like -- if you look

00:11:10.790 --> 00:11:16.730
at the new tab page in Safari, it has got
these cool 3D perspectives. A lot of things

00:11:16.730 --> 00:11:22.459
make great use of 3D not for like a fully
immersive gaming environment but just to add

00:11:22.459 --> 00:11:27.220
some nice flare, some nice perspective.
3D CSS transforms are a very way to add this

00:11:27.220 --> 00:11:32.319
into your application. I'm very excited to
say that as of Chrome 12 we now have initial

00:11:32.319 --> 00:11:37.800
support for a lot of the 3D CSS transforms.
And as Sundar said this morning, Chrome 12

00:11:37.800 --> 00:11:41.509
is now going out to the beta channel. This
is something you can already use and will

00:11:41.509 --> 00:11:47.019
be out to all users very shortly.
So we're doing a lot to sort of expand your

00:11:47.019 --> 00:11:54.070
vocabulary, let you say more things, as you
will. But sometimes this can be a bit overwhelming.

00:11:54.070 --> 00:11:58.750
And so to talk about what we're doing in that
aspect, I would like to welcome Alex Komoroske

00:11:58.750 --> 00:12:00.240
back.
&gt;&gt;Alex Komoroske: Thanks, Ian. That was an

00:12:00.240 --> 00:12:04.470
overview of some of the stuff that you can
do today in the Web platform. But now let's

00:12:04.470 --> 00:12:08.319
take it and look towards the future. So once
we've gotten to all of everyone having all

00:12:08.319 --> 00:12:14.959
the pieces of HTML5, what's next, right?
The problem right now is that you have this

00:12:14.959 --> 00:12:18.740
huge vocabulary. But it isn't necessarily
easy or short or succinct to say the things

00:12:18.740 --> 00:12:23.180
you want to get across. This isn't just a
theoretical problem. This is a problem you

00:12:23.180 --> 00:12:26.759
running into every single day. Even for simple
sites, popular sites, well-implemented sites,

00:12:26.759 --> 00:12:31.420
you are doing a lot of things. You are saying
a lot of stuff just to get some basics across.

00:12:31.420 --> 00:12:35.670
The way I think of it is that the Web platform
today is kind of like a savant. He amazingly

00:12:35.670 --> 00:12:39.430
smart and he's amazingly effective at doing
precisely what you tell him to do. But he

00:12:39.430 --> 00:12:40.959
doesn't understand that much about the real
world.

00:12:40.959 --> 00:12:44.879
You have to spend a whole lot of time explaining
to him precisely how the world works, and

00:12:44.879 --> 00:12:50.129
you do all this via JavaScript before you
tell him to do anything that's particularly

00:12:50.129 --> 00:12:53.089
useful.
And, you know, you can do this. It's possible

00:12:53.089 --> 00:12:57.040
to have these conversations. But why should
you have to? Why can't you just have a normal

00:12:57.040 --> 00:13:01.329
conversation? And we think that should be
the future of the web platform. Moving from

00:13:01.329 --> 00:13:07.250
this idea of saying what you must, this very
comprehensive encyclopedia of information,

00:13:07.250 --> 00:13:10.580
and moving just to saying what you mean. Why
should you have to write an entire encyclopedia

00:13:10.580 --> 00:13:15.790
and ship it down the wire when all you really
wanted to say is a short story? This is something

00:13:15.790 --> 00:13:19.350
that we think is really important, and that
will unlock a lot of the potential of the

00:13:19.350 --> 00:13:23.459
web platform. We think there's lots of benefits
from this or good reasons to do this. The

00:13:23.459 --> 00:13:27.529
first is reducing maintenance burden. The
more code you have to write, the more service

00:13:27.529 --> 00:13:31.829
area you have for bugs and typos. But there's
something else too. If you codify in your

00:13:31.829 --> 00:13:36.160
encyclopedia of knowledge about the world
that a car is something with an internal combustion

00:13:36.160 --> 00:13:41.029
engine and that uses fossil fuels, well, it's
going to continue being that way even if electric

00:13:41.029 --> 00:13:44.290
cars become the norm.
Whereas if you can rely on the platform more

00:13:44.290 --> 00:13:49.170
to understand these things natively, these
common patterns, then as electric cars become

00:13:49.170 --> 00:13:52.630
normal, you sort of get that for free. You
just say, "Hey, give me a car," not "Give

00:13:52.630 --> 00:13:56.680
me something with an internal combustion engine."
Another way to think about it is that reduce

00:13:56.680 --> 00:14:00.350
time down the wire. So one of the great things
about the web platform is that you have this

00:14:00.350 --> 00:14:04.880
enormous reach. Anyone with an Internet connection
on any number of devices can get your app.

00:14:04.880 --> 00:14:08.670
But they also have to be shipped down the
wire. So if you're shipping down an entire

00:14:08.670 --> 00:14:12.009
encyclopedia, that's going to take time. But
if you can be succinct, if you can just ship

00:14:12.009 --> 00:14:14.570
down your short story, you can get to your
users much faster.

00:14:14.570 --> 00:14:19.000
Another way, of course, is execution time.
If you've got this whole encyclopedia that

00:14:19.000 --> 00:14:22.790
the browser has to read and understand, that's
going to take some time. Even with really

00:14:22.790 --> 00:14:27.129
fast JavaScript engines like V8 and on other
browsers. This is something that will always

00:14:27.129 --> 00:14:29.420
take time. It will never be quite as fast
as native code.

00:14:29.420 --> 00:14:32.779
There are two ways to fix this particular
problem. One of them is by increasing the

00:14:32.779 --> 00:14:36.050
reading speed, increasing how quickly these
engines can process this stuff.

00:14:36.050 --> 00:14:39.300
That's incredibly important, and of course
everyone's working on it.

00:14:39.300 --> 00:14:42.569
But there's a second strategy, a supplemental
strategy, and that's reducing the amount of

00:14:42.569 --> 00:14:45.970
stuff you have to say that the browser has
to understand.

00:14:45.970 --> 00:14:49.800
You're raising up the common patterns and
allowing you to express that natively, so

00:14:49.800 --> 00:14:53.329
that more logic can run natively and it can
run fast.

00:14:53.329 --> 00:14:56.750
That means that you don't have to process
this entire encyclopedia before you can get

00:14:56.750 --> 00:14:59.890
to the juicy stuff, the good stuff, the stuff
that you actually care about.

00:14:59.890 --> 00:15:03.491
But the final way, and I think the most important
way, is reducing cognitive overhead and complexity.

00:15:03.491 --> 00:15:08.240
You as a developer only have a certain amount
of patience and time, and right now you're

00:15:08.240 --> 00:15:12.569
spending a lot of that building up this encyclopedia
when really all you want to say is this short

00:15:12.569 --> 00:15:16.779
story. Even if you're building on top of exiting
encyclopedias and existing frameworks, there's

00:15:16.779 --> 00:15:21.540
still some overhead there. Each of these frameworks
has to build up their own version of the world

00:15:21.540 --> 00:15:26.060
and explain it to the browser in an incompatible
way, so, you know, if you've got -- if you're

00:15:26.060 --> 00:15:29.649
driving a BMW, parts from a Toyota probably
aren't going to fit. You can't pick and choose

00:15:29.649 --> 00:15:33.949
pieces from across these frameworks.
So again, we think that the web platform of

00:15:33.949 --> 00:15:36.990
today is amazingly powerful. It's getting
more and more powerful every day. But now

00:15:36.990 --> 00:15:41.600
we think it's important to really focus on
allowing people to say what they mean, to

00:15:41.600 --> 00:15:45.230
really bring in -- usher in a new era of amazing
Web apps.

00:15:45.230 --> 00:15:48.240
And so now that's sort of the high level,
but now let's turn to Alex Russell for some

00:15:48.240 --> 00:15:50.629
specifics.
And again, just to set the context here, these

00:15:50.629 --> 00:15:55.269
are ideas that are so new, so cutting-edge,
that they aren't in specs yet, let alone being

00:15:55.269 --> 00:15:59.339
implemented.
&gt;&gt;Alex Russell: Thanks, Alex.

00:15:59.339 --> 00:16:04.999
So as Alex laid out the cogent case for why
we need improvement in not just the vocabulary,

00:16:04.999 --> 00:16:10.579
but sort of the slang, the common use cases
of the languages that we use every day, it's

00:16:10.579 --> 00:16:13.670
important to ask the question: What is it
exactly that we need to change?

00:16:13.670 --> 00:16:17.529
So if we go and we sort of ask anybody and
say, "What is it that you would like to be

00:16:17.529 --> 00:16:20.629
different about the web platform," we'd get
a lot of different answers, and in fact, we

00:16:20.629 --> 00:16:23.320
have.
And so what we've done instead is go and look

00:16:23.320 --> 00:16:26.709
at the largest applications that we're building
because they sort of have aspirational levels

00:16:26.709 --> 00:16:30.300
to the complexity. When you throw hundreds
of engineers at a problem, you can expect

00:16:30.300 --> 00:16:35.579
them to build something that a couple of guys
in a garage won't be able to do over a weekend.

00:16:35.579 --> 00:16:40.240
And so what we'd like to do is make it possible
for you to build richer, more complicated,

00:16:40.240 --> 00:16:44.330
more sophisticated applications, without having
to work as hard. And so if we look at the

00:16:44.330 --> 00:16:47.509
biggest applications that we've got today,
we've started as to ask ourselves: What are

00:16:47.509 --> 00:16:50.790
the areas where we could get the biggest bang
for the buck if we take the common things

00:16:50.790 --> 00:16:55.250
that everyone is trying to do and just put
them directly in the platform?

00:16:55.250 --> 00:17:01.800
So one of the big things that has been clamored
for by developers since the early days of

00:17:01.800 --> 00:17:07.380
CSS has been the ability to refactor your
CSS in a lot of different ways.

00:17:07.380 --> 00:17:12.179
The first of them is variables, where variables
names in programming languages are actually

00:17:12.179 --> 00:17:16.540
descriptive. They're not just chaff. They're
not just sort of like a stand-in for your

00:17:16.540 --> 00:17:20.650
own understanding. They wind up being the
language that you use to communicate to yourself

00:17:20.650 --> 00:17:24.339
later and another programmer about what it
is that this value does.

00:17:24.339 --> 00:17:31.220
And so what we've looked at is how we're using
CSS in the real world. CSS style sheets have

00:17:31.220 --> 00:17:35.850
gotten very large and factoring your CSS has
turned into an incredibly important task for

00:17:35.850 --> 00:17:40.070
many large websites. And so CSS variables
unlock a lot of the potential to do exactly

00:17:40.070 --> 00:17:44.880
that. And so we're working on a syntax that's
been proposed on the CSS working group mailing

00:17:44.880 --> 00:17:49.900
list to help us do exactly that. We're using
a new at rule. As you can see, in this case,

00:17:49.900 --> 00:17:53.220
we're going to create a base version of this
value, which otherwise has to be repeated

00:17:53.220 --> 00:17:56.410
over and over again in the example at the
top.

00:17:56.410 --> 00:18:01.200
Instead of repeating the values, we can start
to repeat what it is we're trying to say inside

00:18:01.200 --> 00:18:05.740
of our CSS. CSS variables help us factor stuff
out. And this is going to be great for themes.

00:18:05.740 --> 00:18:11.620
This is going to be great for building stylable
websites in which you can put the burden of

00:18:11.620 --> 00:18:15.950
maintenance not just on one person who has
to know the entire system all at once, but

00:18:15.950 --> 00:18:20.510
you can hand over your variables sort of as
the contract for how you want to theme and

00:18:20.510 --> 00:18:23.920
style your CSS rules.
So this is really good. CSS variables give

00:18:23.920 --> 00:18:28.400
us the ability not just to do this statically,
but we also want these to be dynamic, so that

00:18:28.400 --> 00:18:32.320
you can come back later with JavaScript and
change the value and have them change live

00:18:32.320 --> 00:18:36.080
in a document. CSS variables can be an incredibly
powerful way to do that, add dynamic behavior,

00:18:36.080 --> 00:18:41.230
not just sort of macro style one-time fire-and-forget
behavior.

00:18:41.230 --> 00:18:44.460
So the next thing that we looked at, when
we were looking at very large style sheets,

00:18:44.460 --> 00:18:49.630
the sorts of things that get generated from
large teams or from the preprocessors that

00:18:49.630 --> 00:18:54.500
are so popular now inside of client and server
side toolkits, is the idea of factoring out

00:18:54.500 --> 00:19:01.390
common sub-expressions inside your CSS rules.
So if you look at CSS rules today, we've got

00:19:01.390 --> 00:19:05.300
media queries which give us the ability to
say, "Please turn on or turn off this set

00:19:05.300 --> 00:19:10.529
of CSS rules for some environment," but after
that, there's no sort of layer that allows

00:19:10.529 --> 00:19:13.940
you to target some chunk of CSS to some portion
of your document.

00:19:13.940 --> 00:19:19.659
Because what happens in small documents is
that you write very terse, very expressive

00:19:19.659 --> 00:19:24.991
selectors and rule bodies which only have
to operate on a small chunk of DOM. But when

00:19:24.991 --> 00:19:29.200
we build really big applications, we build
those big applications out of similarly small

00:19:29.200 --> 00:19:34.020
chunks of DOM. But if I write a very small
rule that has a descendant selector or is

00:19:34.020 --> 00:19:39.130
relatively naive about what it's going to
target, I wind up in a place where I have

00:19:39.130 --> 00:19:44.840
to defensively prefix all of my CSS rules
with some ID or some class name, so that I'm

00:19:44.840 --> 00:19:50.110
not overbroadly applying my CSS rules to some
portion of DOM that I didn't mean to. We're

00:19:50.110 --> 00:19:53.779
trying to get to a place where we can think
about CSS and HTML having this component.

00:19:53.779 --> 00:20:00.110
So today we wind up with these shrink-wrapped
rules with a lot of prefixes to get there.

00:20:00.110 --> 00:20:05.899
And so one of the things that we think is
going to be helpful in this case is the ability

00:20:05.899 --> 00:20:11.799
to factor out common sub-expressions so that
you can mix things in like a function would.

00:20:11.799 --> 00:20:15.440
You can say "I don't want to have to write
out the code that does this thing every time.

00:20:15.440 --> 00:20:20.700
I just want to import it into my CSS rules."
And CSS mixins give us a way that's analogous

00:20:20.700 --> 00:20:25.450
to using variables, but instead not importing
the value of something but importing a bunch

00:20:25.450 --> 00:20:30.610
of different rules into a particular CSS rule
body.

00:20:30.610 --> 00:20:34.020
So in this case, we've got a themed button
and the themed button doesn't want to have

00:20:34.020 --> 00:20:40.200
to care about which style of linear gradient
syntax is supported in which browsers. Instead,

00:20:40.200 --> 00:20:45.010
it wants to use whichever one is going to
be available. CSS has been evolving in a very

00:20:45.010 --> 00:20:50.370
compatible way, thanks to this vendor prefixing,
but it leads to kind of a diarrhea of vendor

00:20:50.370 --> 00:20:54.070
prefix names when you mostly have the same
thing supported everywhere but nobody wants

00:20:54.070 --> 00:20:59.770
to implement the exact same unprefixed thing,
lest the spec change out from underneath them.

00:20:59.770 --> 00:21:03.809
And there's some transition period after browsers
support the new thing because not all browsers

00:21:03.809 --> 00:21:07.500
update automatically.
So we need a way to stop saying the same thing

00:21:07.500 --> 00:21:12.990
over and over and over again when we just
want to say it once, and mixins, defined with

00:21:12.990 --> 00:21:16.210
this new at trait rule, give us the ability
to do exactly that.

00:21:16.210 --> 00:21:20.399
We can pass in variables to mixins so that
they can be paramaterized and then the local

00:21:20.399 --> 00:21:22.960
name for that could be populated into the
rule.

00:21:22.960 --> 00:21:27.220
You could think of this as sort of simply
expanding in line, inside of our themed button

00:21:27.220 --> 00:21:31.330
class, exactly what we were going to say longhand,
but we can reuse that over and over and over

00:21:31.330 --> 00:21:35.620
again in different CSS rules. It's sort of
like a macro. So that's pretty good. It's

00:21:35.620 --> 00:21:40.500
a macro that we can configure in a bunch of
different places to refactor and factor out

00:21:40.500 --> 00:21:46.000
common sub-expressions and common behavior.
So I mentioned earlier that we wind up doing

00:21:46.000 --> 00:21:49.049
this shrink-wrapping thing where I have a
little chunk of DOM and I want to factor out

00:21:49.049 --> 00:21:52.649
some common rules that apply only to that
thing.

00:21:52.649 --> 00:21:58.529
Mixins give us the power of saying "Aha, when
I want to reuse some set of rules that apply

00:21:58.529 --> 00:22:02.299
in a bunch of different rules, I can just
turn them into a function or a mixin that

00:22:02.299 --> 00:22:05.919
I can use in different places."
But at the same time, we want to make that

00:22:05.919 --> 00:22:08.649
stuff appropriate only for the DOM that we
care about.

00:22:08.649 --> 00:22:14.850
So this is an example of some CSS from an
earlier version of this slide deck.

00:22:14.850 --> 00:22:21.460
So this CSS, as you can see, has dot slide
dot image as this premix that gets used for

00:22:21.460 --> 00:22:25.590
a whole bunch of rules that come after the
initial formatting for this chunk of HTML,

00:22:25.590 --> 00:22:29.650
and these rules roughly correspond to the
structure of the HTML that these rules should

00:22:29.650 --> 00:22:33.580
apply to.
So in this case, the -- any element underneath

00:22:33.580 --> 00:22:40.140
this slide image that's got a credit should
have this behavior, whereas any counter-element

00:22:40.140 --> 00:22:45.149
should have a separate set of styling applied
to it. And so in this way, we wind up, you

00:22:45.149 --> 00:22:49.950
know, using descendant selectors with a prefix
to sort of replicate the structure of our

00:22:49.950 --> 00:22:54.179
document in our CSS, so that we don't over-apply
rules and that we don't under-apply rules.

00:22:54.179 --> 00:23:00.690
So that we wind up with exactly what we meant
to say in our document without creating a

00:23:00.690 --> 00:23:04.409
problem for somebody else. Specificity helps
us here.

00:23:04.409 --> 00:23:07.940
But it's very verbose.
So what we're proposing is the idea of CSS

00:23:07.940 --> 00:23:12.190
nesting and hierarchy, where you can write
rules in a hierarchical way. Using the new

00:23:12.190 --> 00:23:16.649
ampersand character, we are effectively doing
exactly the same thing: shortening up the

00:23:16.649 --> 00:23:23.720
subrules by saying when I want to target an
element underneath the slide image with the

00:23:23.720 --> 00:23:30.780
credit class applied to it, simply repeat
the selector that was -- simply repeat the

00:23:30.780 --> 00:23:36.090
selector that was written out at the beginning
in front of this rule here.

00:23:36.090 --> 00:23:42.360
It's sort of like you're not doing the loop
unrolling for the system anymore.

00:23:42.360 --> 00:23:45.860
Dave Herman at JSConf last week said last
week that he doesn't think that humans are

00:23:45.860 --> 00:23:50.510
very good compilers and that nobody should
be a compiler; compilers are compilers. And

00:23:50.510 --> 00:23:54.899
I agree with that statement. We want you to
be able to write only the stuff that you need

00:23:54.899 --> 00:23:59.450
to say in order to get your job done.
And so being able to nest your rules makes

00:23:59.450 --> 00:24:03.309
it read like you would actually see the HTML
that you're trying to target here, and using

00:24:03.309 --> 00:24:07.750
the ampersand to stop repeating yourself so
much makes it possible to read the CSS rules

00:24:07.750 --> 00:24:11.480
without quite so much visual cruft, and without
sending so much down the wire in order to

00:24:11.480 --> 00:24:14.970
say exactly what it is you were trying to
get to. That's pretty cool.

00:24:14.970 --> 00:24:19.460
It's worth noting that all these things compose
together too. CSS nesting and hierarchy works

00:24:19.460 --> 00:24:23.299
inside mixins, so I can have a mixin that
has hierarchy inside of it.

00:24:23.299 --> 00:24:26.241
Variables work with all of these things.
So we're starting to get to a place where

00:24:26.241 --> 00:24:33.850
CSS is a really expressive language that helps
us map behavior and visual formatting back

00:24:33.850 --> 00:24:37.570
onto HTML in the way that we want to write
our HTML in the first place: structurally,

00:24:37.570 --> 00:24:43.220
semantically, and in a way that is very clear
to read.

00:24:43.220 --> 00:24:48.740
So that's great. That gives us some really
powerful tools for maintaining our CSS, structuring

00:24:48.740 --> 00:24:53.350
it in ways that are reusable and maintainable
and that don't have high complexity, reducing

00:24:53.350 --> 00:24:58.740
the size of our CSS down the wire so that
we don't have to fight so much for performance,

00:24:58.740 --> 00:25:02.850
but we have a couple of other parts of the
platform that could use some love here too.

00:25:02.850 --> 00:25:06.730
We've gotten out of the world of JavaScript
animations recently, especially in mobile

00:25:06.730 --> 00:25:13.600
platforms, by using CSS animations and transforms.
And CSS animations and transforms are a great

00:25:13.600 --> 00:25:17.740
way for us to put the job of making things
fly around the screen onto the browser. We

00:25:17.740 --> 00:25:20.650
don't have to do it in JavaScript. We don't
have to strip down a library in JavaScript

00:25:20.650 --> 00:25:25.640
that's going to do the work for us. We don't
have to come up with a whole set of prebuilt

00:25:25.640 --> 00:25:29.690
easing functions. That can all be put into
the browser. It's really powerful stuff and

00:25:29.690 --> 00:25:33.640
it's sort of de rigueur on mobile platforms
today.

00:25:33.640 --> 00:25:38.090
But we wind up with a couple of problems as
we start to exercise the edge of this syntax.

00:25:38.090 --> 00:25:42.480
It's great stuff and we really want it to
be as easy to use as possible.

00:25:42.480 --> 00:25:47.200
But today, it's a little bit unclear, when
I look at an animation or a transition, what

00:25:47.200 --> 00:25:50.940
it is it's supposed to do.
I think the easiest way to sort of communicate

00:25:50.940 --> 00:25:57.210
what it is animations and transitions do is
to think of transitions as being edge triggered.

00:25:57.210 --> 00:26:04.820
When I want to migrate from State A to State
B, the transition helps me communicate visually

00:26:04.820 --> 00:26:11.330
about that transition, that change in state,
from Point A to Point B, whereas animations

00:26:11.330 --> 00:26:14.190
are things that happen at the level in my
step function.

00:26:14.190 --> 00:26:19.340
They happen when I reach that state. When
I get to that state, then kick off the animation.

00:26:19.340 --> 00:26:23.830
And so transitions are designed to help you
interpolate from Point A to Point B, whereas

00:26:23.830 --> 00:26:28.210
animations aren't designed to help you interpolate;
they're designed to help you express some

00:26:28.210 --> 00:26:37.679
visual behavior in a way that's very compact
in terms of expression for a fixed set of

00:26:37.679 --> 00:26:40.591
things but it doesn't give you a way to reach
in and say where did I start from and where

00:26:40.591 --> 00:26:43.769
did I go to.
So it's not clear which one you should use

00:26:43.769 --> 00:26:48.919
for each task. If I'm communicating visually
about what just happened to my application,

00:26:48.919 --> 00:26:52.100
I might want to use a transition, but there's
some missing expressive power.

00:26:52.100 --> 00:26:58.169
If I use an animation, I have complete control.
I can declare an entire set of joined behaviors

00:26:58.169 --> 00:27:03.720
and visual artifacts that I'd like to have
spring from me arriving at a place, but I

00:27:03.720 --> 00:27:09.419
can't tie that to the beginning and end states
of my application's behavior.

00:27:09.419 --> 00:27:14.830
And most of all, when I write my CSS, I sort
of think of writing my CSS as a series of

00:27:14.830 --> 00:27:18.649
states.
My CSS rules -- in this case the hover class

00:27:18.649 --> 00:27:24.620
-- are a great example of wanting my CSS rules
to express positions that my elements might

00:27:24.620 --> 00:27:27.519
be in.
Roles or states that they might take on.

00:27:27.519 --> 00:27:33.809
And so if we want to reuse that language on
the selector side of my CSS, we need a way

00:27:33.809 --> 00:27:40.559
to tie our transitions and our animations
more tightly to that graph of potential states.

00:27:40.559 --> 00:27:46.080
So we're proposing a new set of syntax to
help you do exactly that.

00:27:46.080 --> 00:27:52.650
In this case, we're going to reuse the CSS
for the button and the active class as a way

00:27:52.650 --> 00:27:59.120
of tying this state, dash, interaction role
to it, which is a way of saying my button

00:27:59.120 --> 00:28:06.250
is going to participate in sort of a new set
of classes and in this case that's going to

00:28:06.250 --> 00:28:09.820
be the interaction.
And whenever I am in the active state, that

00:28:09.820 --> 00:28:14.950
interaction is going to go from normal to
pressed. So when that happens, now we want

00:28:14.950 --> 00:28:22.780
a way of targeting that with some new expressive
behavior for visual formatting. We don't want

00:28:22.780 --> 00:28:27.659
to have to put that in our JavaScript. We
don't want to have that happen from events

00:28:27.659 --> 00:28:34.500
that happen in programmatic code. Instead,
we just want this to happen because the CSS

00:28:34.500 --> 00:28:38.399
transition does from one place to another.
So what we've got here is a new at transition

00:28:38.399 --> 00:28:44.899
rule. And the new at transition rule says,
when I target the button class and I move

00:28:44.899 --> 00:28:52.919
from normal to pressed over the interaction
state, then run this animation over this frequency.

00:28:52.919 --> 00:28:59.659
And when -- if I wind up interrupting this,
if I wind up coming back and not applying

00:28:59.659 --> 00:29:05.650
the active class for a 10th of a second, reverse
the animation. Automatically reverse it. Today

00:29:05.650 --> 00:29:11.190
this is a lot of code to go. This is really
powerful stuff. We can write our CSS as though

00:29:11.190 --> 00:29:19.059
it is a series of statements to transition
to and through. We can tie our behavior, our

00:29:19.059 --> 00:29:25.350
visual behavior directly to those transitions.
So this is a little bit of code, so the smallest

00:29:25.350 --> 00:29:32.650
code I could write, to go and figure out a
way to take the start and the end of a CSS

00:29:32.650 --> 00:29:35.730
animation and configure them for something.
I don't expect to you read this or understand

00:29:35.730 --> 00:29:41.600
it. But, basically, I pull in a library. I
write a function, which is going to go substitute

00:29:41.600 --> 00:29:47.721
some values in and out. Because today CSS
animations can't be subject to some relative

00:29:47.721 --> 00:29:51.649
start and end state. So what we need to do
is go calculate that start and end state,

00:29:51.649 --> 00:29:56.649
add it to the key frames, add it to a new
rule, apply that rule and those key frames

00:29:56.649 --> 00:30:00.779
to the document, and then trigger them. Well,
that's a lot of work to do in JavaScript.

00:30:00.779 --> 00:30:05.649
It means that you now have to go write all
this out and trigger animations through JavaScript.

00:30:05.649 --> 00:30:10.190
It's kind of a pain. You don't really want
to end up doing this. Instead, it would be

00:30:10.190 --> 00:30:15.000
better if CSS gave us a way in our key frames
to say wherever I started from and wherever

00:30:15.000 --> 00:30:21.040
I'm going to, calculated by the engine, please
go run this animation in a relative way to

00:30:21.040 --> 00:30:25.950
those start and end states. And so we can
combine that. And in this case we're going

00:30:25.950 --> 00:30:30.950
to try from some position on the left, wherever
we started, to some position on the right.

00:30:30.950 --> 00:30:36.049
But we're going to bounce. We can use the
key frame system that's available for CSS

00:30:36.049 --> 00:30:41.480
animations today, but parameterize it with
where we start and where we end to tie the

00:30:41.480 --> 00:30:46.070
animation syntax back into the transitions
so that we can visually communicate with the

00:30:46.070 --> 00:30:50.919
sorts of things our application is trying
to do and configure it with this rich visual

00:30:50.919 --> 00:30:53.860
language that we have and keep it through
animations.

00:30:53.860 --> 00:30:59.409
Again, we're going to tie that back through
a transition so that when we move over, any

00:30:59.409 --> 00:31:07.190
class that has the state-dash-left interaction
state associated with it, we can then apply

00:31:07.190 --> 00:31:12.460
this animation. So it is a really great way
of starting to think about writing your CSS

00:31:12.460 --> 00:31:20.039
as a series of nodes in a state graph. And
when we have a transition from one node to

00:31:20.039 --> 00:31:24.019
the other, you can start to address the edge
of the state graph as opposed to start backing

00:31:24.019 --> 00:31:28.610
this stuff back into your selectors where
you might otherwise have to try to target

00:31:28.610 --> 00:31:33.380
something with a bunch of additional ID or
class rules in order to kick off some particular

00:31:33.380 --> 00:31:38.279
transition or some particular animation.
We think this is really powerful stuff and

00:31:38.279 --> 00:31:45.200
it is going to open up a whole bunch of new
complex behavior in animations and transitions.

00:31:45.200 --> 00:31:50.649
But we're working in a bunch of other areas,
too. At the last hour, I gave a talk on JavaScript,

00:31:50.649 --> 00:31:56.541
and at JSConf and Node Conf last week, we
unveiled JavaScript to JavaScript compiler

00:31:56.541 --> 00:32:03.350
called Traceur. It is to help us innovate
in exactly the same way but for the JavaScript

00:32:03.350 --> 00:32:07.140
language so that we can start to prototype
ideas out quickly, work with the standards

00:32:07.140 --> 00:32:11.210
committees, work with the broader community
to help understand whether or not these ideas

00:32:11.210 --> 00:32:15.030
are good ideas or bad ideas.
As Alex said, a lot of this stuff is prestandards.

00:32:15.030 --> 00:32:19.279
We are working hard to make sure these are
the best designs we could come up with, but

00:32:19.279 --> 00:32:26.590
we need your help to do it.
So we're working in CSS to go add a whole

00:32:26.590 --> 00:32:30.090
slew of other stuff, too, because CSS is one
of the weaker parts of the Web platform today.

00:32:30.090 --> 00:32:37.750
CSS rule values, CSS layouts, better performance,
a layout model that's easier to use and easier

00:32:37.750 --> 00:32:41.460
to understand when you're positioning things
relative to each other and a real object model

00:32:41.460 --> 00:32:44.419
for scripting all of this.
These are the sorts of things that we are

00:32:44.419 --> 00:32:50.179
focused on. We don't have time to go through
all of them today, but I hope you'll engage

00:32:50.179 --> 00:32:57.820
with us through the XS project, which is on
Google Code today, which gives us the ability

00:32:57.820 --> 00:33:02.809
to prototype this in a preprocessor style,
the same way that Traceur does for JavaScript,

00:33:02.809 --> 00:33:07.960
less sass, the sorts of preprocessors that
you might have come to use. But it operates

00:33:07.960 --> 00:33:13.169
on the client side. And so it is a really
powerful facility for helping to prototype

00:33:13.169 --> 00:33:17.789
these features, use them early and get started
with a bunch of the new capabilities that

00:33:17.789 --> 00:33:22.370
we hope that you're excited about for the
Web platform, too.

00:33:22.370 --> 00:33:25.850
So, as I mentioned, we're working in Traceur
to help improve JavaScript. And improving

00:33:25.850 --> 00:33:30.049
JavaScript happens at a lot of levels. JavaScript
is a language, but doesn't necessarily just

00:33:30.049 --> 00:33:34.750
have its own library. The DOM is important
part of the JavaScript ecosystem. And so we're

00:33:34.750 --> 00:33:40.950
working with not just the ECMAscript standards
body, but also the webIDL standards body to

00:33:40.950 --> 00:33:45.389
help make the things that you do in JavaScript
more natural. Working on a CSS logic model

00:33:45.389 --> 00:33:50.730
to help make interacting with JavaScript and
CSS much more natural and more fluid. So,

00:33:50.730 --> 00:33:54.039
as a JavaScript programmer, you don't have
to think of those things as being alien to

00:33:54.039 --> 00:33:59.090
your environment. They act the way that everything
else in JavaScript should. Hopefully, through

00:33:59.090 --> 00:34:03.070
the Traceur project, you can help inform us
about whether or not we're scratching your

00:34:03.070 --> 00:34:07.360
itches, too.
So the last piece I want to sort of go through

00:34:07.360 --> 00:34:14.679
today, one of the big pieces of infrastructure
that we've identified as a common thing for

00:34:14.679 --> 00:34:20.260
web developers to do that doesn't have a lot
of platform support today is the idea of templating

00:34:20.260 --> 00:34:24.899
or data binding. Those are both scary words.
I understand. There's a bazillion templating

00:34:24.899 --> 00:34:30.310
languages in the world. Data binding is something
that isn't the sort of idea you want to foist

00:34:30.310 --> 00:34:36.100
on to newbies. HTML is a great language because
it allows you to go from zero to amazing applications

00:34:36.100 --> 00:34:41.060
in a relatively linear path. So we don't want
to put a lot of code in the way between how

00:34:41.060 --> 00:34:44.990
you start writing your application and where
it eventually ends up at. We want to supply

00:34:44.990 --> 00:34:49.890
a path. HTML and the web platform have done
a good job at providing exactly that. If you

00:34:49.890 --> 00:34:54.970
can't get it through HTML, maybe try it in
CSS. If CSS doesn't do it, maybe try JavaScript.

00:34:54.970 --> 00:34:58.700
So these things have sort of fit together,
composed together in a way that's allowed

00:34:58.700 --> 00:35:03.400
us to evolve from just a document rendering
system to a place where we're building real

00:35:03.400 --> 00:35:08.410
applications. And that's a property we want
to preserve. So we asked ourselves, when we

00:35:08.410 --> 00:35:11.630
generate all this stuff on the client side,
what is it we're trying to do?

00:35:11.630 --> 00:35:16.710
And the key insight that Rafael Einstein and
other folks have come up with is that data

00:35:16.710 --> 00:35:21.270
binding and templating are exactly the same
problem. They're two sides of the same coin.

00:35:21.270 --> 00:35:26.340
On the service side, you wind up writing a
templating engine that takes your data, mixes

00:35:26.340 --> 00:35:31.920
it together with some templates and then spits
out a string. Why does it spit out a string?

00:35:31.920 --> 00:35:35.630
Because it's on the surface side, and you
have to serialize it to send it to the client.

00:35:35.630 --> 00:35:39.510
On the client side, you wind up taking that
generated thing, because it's pretty fast,

00:35:39.510 --> 00:35:44.700
and you wind up trying to attach some out
of band model or view to it so when something

00:35:44.700 --> 00:35:49.349
changes through JavaScript events, you can
go be informed of it and tell the server and

00:35:49.349 --> 00:35:54.490
reserialize the changes that you'd like to
notify the server of.

00:35:54.490 --> 00:35:58.450
What if, instead, on the client side, we were
able to take a lot of the templating and do

00:35:58.450 --> 00:36:03.619
it right there?
And so this is some sample syntax that we're

00:36:03.619 --> 00:36:08.320
working with now where we're introducing a
new template element into HTML. And that template

00:36:08.320 --> 00:36:14.500
element is creating an inert chunk of DOM,
which, in this case, we're going to use directly

00:36:14.500 --> 00:36:19.720
because we're going to iterate over some property.
But that inert chunk of DOM iterates over

00:36:19.720 --> 00:36:24.940
some items. It has an ID. It is actually an
element. And it's going to go grab some properties

00:36:24.940 --> 00:36:29.780
out of the current item it's iterating. In
this case, we've got another template we're

00:36:29.780 --> 00:36:35.339
going to use this is going to iterate over
the children property of the current item.

00:36:35.339 --> 00:36:38.280
But it's going to not define its own template.
It's going to refer to another one. In this

00:36:38.280 --> 00:36:41.359
case we actually have recursive templates
here and very little code. This would have

00:36:41.359 --> 00:36:46.960
been a lot in JavaScript to write and send
down the wire just to do the string replacement.

00:36:46.960 --> 00:36:53.410
But later in script, we can take a regular
JSON object. This is a regular JSON object.

00:36:53.410 --> 00:36:58.490
This is not an object in some special format.
It's just JSON. We're going to wrap in this

00:36:58.490 --> 00:37:03.020
model.get. And this is an ECMAscript harmony
proxies. ECMAscript harmony is the next version

00:37:03.020 --> 00:37:07.670
of JavaScript. We're excited about proxies
because they give us a way to take any JavaScript

00:37:07.670 --> 00:37:12.220
object and look at all the operations that
you might do on it. So, when you change it

00:37:12.220 --> 00:37:18.620
directly -- add some property, delete something,
add something to an array, change some value

00:37:18.620 --> 00:37:22.270
-- we can get informed of that. We can listen
in on that directly, so that you don't have

00:37:22.270 --> 00:37:26.750
to send your data down the wire in a special
format in order to have it wrapped up in something

00:37:26.750 --> 00:37:31.690
that can then notify you back about changes
to it. We can wrap it directly. We also want

00:37:31.690 --> 00:37:37.109
to add a new model property to all HTML elements.
In this case, the model property is something

00:37:37.109 --> 00:37:41.369
that's inherited. So, if there isn't something
else in the document that's going to iterate

00:37:41.369 --> 00:37:47.860
or use a template, we'll see the items that
were inherited from wherever this element

00:37:47.860 --> 00:37:52.630
was used in the document, which means that
the items property here in my JSON is going

00:37:52.630 --> 00:37:56.780
to be the thing that we iterate over. We're
going to go run through all the items. And,

00:37:56.780 --> 00:38:00.360
if they've got children, we're going to apply
this template once again while pulling the

00:38:00.360 --> 00:38:06.460
name property right back out of it. This is
pretty cool. This is in 20 or so lines. We've

00:38:06.460 --> 00:38:12.089
got the real ability not just to go generate
UI on the client side, sending down significantly

00:38:12.089 --> 00:38:18.520
more terse data, but also wiring up the behavior
of observing yet a change and modifying the

00:38:18.520 --> 00:38:22.920
UI. Let's look at an example of how this might
work. We've built, again, a prototyping library

00:38:22.920 --> 00:38:27.180
that helps you work with this stuff today.
And it works in Mozilla Firefox, because they've

00:38:27.180 --> 00:38:34.550
got good proxy support. So I like Firefox.
What I've got here is an example of a recursive

00:38:34.550 --> 00:38:39.700
template. This, again, is available as a Google
code project. Google.code.com/model-driven.

00:38:39.700 --> 00:38:53.119
Model-driven views give us the ability to
look at the source code for this page. So

00:38:53.119 --> 00:38:59.500
we have our template. And we've got our data.
And it's exactly what we saw before. And this

00:38:59.500 --> 00:39:03.821
is all driven by this little library. I commented
a bunch of stuff out. But let's see what it

00:39:03.821 --> 00:39:10.130
looks like live. So this page, you know, loaded
pretty fast, because it doesn't have to send

00:39:10.130 --> 00:39:15.300
down an exploded version of the HTML. But
that model is also live. That model is something

00:39:15.300 --> 00:39:24.030
I can change. So let's go and do that. I'm
going to come back in here and grab a snippet

00:39:24.030 --> 00:39:33.860
of code, which, if we can read this, this
code just takes the model. It's got some items.

00:39:33.860 --> 00:39:39.120
We're going to read it back out. And we're
going to add a new JavaScript object to the

00:39:39.120 --> 00:39:44.170
front of it. We're just going to add a single
object with a name property called Antarctica

00:39:44.170 --> 00:39:50.490
to the front of our items. We're just going
to mutate in line through Firebug. Great.

00:39:50.490 --> 00:39:57.619
Let's go paste that in. And what we see here
is that the document got updated in realtime.

00:39:57.619 --> 00:40:01.119
We didn't have to do anything special. We
didn't have to say, please, go rerender your

00:40:01.119 --> 00:40:05.230
view. Please go change everything about your
document. In fact, it's only going to try

00:40:05.230 --> 00:40:09.970
to mutate as much of the document as the underlying
data that changed. The model-driven views

00:40:09.970 --> 00:40:14.560
concept is incredibly powerful because, if
you're going to script this stuff or put an

00:40:14.560 --> 00:40:19.390
event handler on it or put references to generated
content, it isn't going to blow up underneath

00:40:19.390 --> 00:40:24.109
you unless your data changes. This is an incredibly
powerful thing. You're not going to be hands-off

00:40:24.109 --> 00:40:29.410
on DOM that's generated from these templates.
We think this is a really critical procedure

00:40:29.410 --> 00:40:34.700
both from performance because we're only calculating
and updating as much UI as has been calculated

00:40:34.700 --> 00:40:39.330
from the data but also for scriptability.
We want to maintain the simplicity. If you

00:40:39.330 --> 00:40:45.420
change your data, your view should update,
but only the parts that would have otherwise

00:40:45.420 --> 00:40:52.210
been updated.
So model-driven views are the sort of thing

00:40:52.210 --> 00:40:59.270
that are incredibly powerful. We hope that
other web engine vendors will help us out

00:40:59.270 --> 00:41:04.270
and help us -- help inform us about what's
working well and what's not in this system,

00:41:04.270 --> 00:41:08.800
as we go to take it through the standards
process and put it in implementations. But

00:41:08.800 --> 00:41:14.460
the question for you is sort of between JavaScript,
between CSS, all the CSS improvements and

00:41:14.460 --> 00:41:16.440
the model-driven view stuff, when can you
start to use it?

00:41:16.440 --> 00:41:21.619
It's an important question. And we've been
using a series of prototypes to help us start

00:41:21.619 --> 00:41:27.460
to write real code in these systems. Our view
has been that, if you propose a new spec and

00:41:27.460 --> 00:41:31.329
you don't have an implementation, you don't
have a way to run real code through it, you're

00:41:31.329 --> 00:41:35.180
going to sort of miss stuff. We have a long
history of sort missing stuff on the web platform.

00:41:35.180 --> 00:41:41.330
So, if we can use prototypes to write a lot
of real code in these styles today, we can

00:41:41.330 --> 00:41:45.190
catch a lot of the stuff early. And, in fact,
we've been working with some of the authors

00:41:45.190 --> 00:41:50.369
of some the existing systems, like less, to
help inform our view of what the platform

00:41:50.369 --> 00:41:54.859
can do and where the gnarly corner bits are
that we're going to have to watch out for

00:41:54.859 --> 00:42:00.030
early. So we hope you'll join us at these
open source projects. Start using this stuff.

00:42:00.030 --> 00:42:05.170
Start using these prototypes, and start working
with it in your own code insofar as you can

00:42:05.170 --> 00:42:08.920
to give us feedback. Help us understand whether
or not these new features are right for your

00:42:08.920 --> 00:42:12.240
application, whether or not they're solving
the pain points that you're seeing in your

00:42:12.240 --> 00:42:16.260
apps. Because we took a survey of our apps.
But we, certainly, aren't the entire world.

00:42:16.260 --> 00:42:21.920
And we're curious to know if this is the sort
of stuff that's going to really be off for

00:42:21.920 --> 00:42:24.900
you.
The next step in the standardization process

00:42:24.900 --> 00:42:30.450
is always to get browser vendors to implement
things. It's one thing to say we think this

00:42:30.450 --> 00:42:34.579
is going to work in a JavaScript library and
we think this is grog to work in a prototype,

00:42:34.579 --> 00:42:38.363
but we really need to know if it's going to
apply in an important way in implementations.

00:42:38.363 --> 00:42:44.099
So Mozilla Firefox and Chrome are all starting
to work early in the standards, as we've done

00:42:44.099 --> 00:42:48.230
in things like the Cloud system and video
tag to go add new features to the web platform

00:42:48.230 --> 00:42:54.349
quickly so you can start to use them in places
like the web store or in extensions, things

00:42:54.349 --> 00:43:00.950
that aren't subject to the churn and the regular
set of constraints of deploying an application

00:43:00.950 --> 00:43:07.770
to the full web.
And things like Chrome Frame, the sorts of

00:43:07.770 --> 00:43:10.900
protected environments that are adding new
features quickly and auto updating, are going

00:43:10.900 --> 00:43:14.780
to help make the future of the web platform
a reality. But we need your help to do it.

00:43:14.780 --> 00:43:21.230
We need you to work with us to try out these
features. Give us feedback. Help understand

00:43:21.230 --> 00:43:27.559
-- help us understand where you're still spending
a lot of time writing stuff out for the savant

00:43:27.559 --> 00:43:32.069
and not saying what you mean. Because we really
need to get to a place, we think, where, when

00:43:32.069 --> 00:43:37.859
you write a web application and go and construct
something, you're thinking about what it is

00:43:37.859 --> 00:43:42.970
you're going to get done and less time thinking
about what it is you needed to say to get

00:43:42.970 --> 00:43:54.030
it done. So thanks so much. I think we'll
open it up for questions now.

00:43:54.030 --> 00:43:57.690
[ Applause ]
&gt;&gt;Ian Fette: We've got mics in the middle

00:43:57.690 --> 00:43:59.420
of the room. We'd be happy to take questions.
&gt;&gt;&gt; Hello. Thank you for the talk. I was wondering

00:43:59.420 --> 00:44:09.240
if you're familiar with the app engine channel
API. And, if so, how that technology relates

00:44:09.240 --> 00:44:25.400
or compares to the WebSockets technology.
&gt;&gt;Ian Fette: So, if I recall the app engine

00:44:25.400 --> 00:44:29.869
channel -- I think is that browser channel?
So browser channel, what it, essentially,

00:44:29.869 --> 00:44:36.040
does is it opens two concurrent connections.
One is for downstream. One is for upstream.

00:44:36.040 --> 00:44:40.970
And so, first of all, one difference right
there is you've got now two connections to

00:44:40.970 --> 00:44:45.500
your back end instead of one. And, if you're
scaling up to a large number of users, the

00:44:45.500 --> 00:44:49.930
number of connections can actually become
a limiting factor. So that's one difference.

00:44:49.930 --> 00:44:56.440
Two, even though you've got that, you're still,
often times, having to close -- I forget if

00:44:56.440 --> 00:45:00.079
it's the upstream or the downstream connection.
I want to say it's the downstream connection

00:45:00.079 --> 00:45:04.309
you have to close each time you send something.
Otherwise there are intermediaries that will

00:45:04.309 --> 00:45:11.040
cache whatever is being sent or buffer it.
So you create a new connection. You then have

00:45:11.040 --> 00:45:19.609
all the cookies that get sent, all the headers.
So your data transfer gets blown up by a lot.

00:45:19.609 --> 00:45:24.309
So WebSockets has one connection instead of
two. It's persistent. So you don't have all

00:45:24.309 --> 00:45:29.500
the headers going each time. And WebSockets
also supports binary data. So, if you're sending

00:45:29.500 --> 00:45:35.099
binary data, you don't have to UTF it. You
don't have to base 64 encode it. You don't

00:45:35.099 --> 00:45:42.190
have to, like, shove it in some giant string
or giant JSON format. You can send it, however,

00:45:42.190 --> 00:45:48.559
you want. WebSockets is designed to be a more
efficient implementation of bidirectional

00:45:48.559 --> 00:45:51.660
communication. So same use cases but much
more efficient.

00:45:51.660 --> 00:45:56.290
&gt;&gt;Alex Komoroske: I should say the channel
API today presents a simpler case to you,

00:45:56.290 --> 00:45:57.758
the user of the API. But it is, ultimately,
doing the stuff under the covers, which has

00:45:57.758 --> 00:45:58.771
all the extra headers, closed connections,
and all this extra stuff.

00:45:58.771 --> 00:46:00.900
&gt;&gt;&gt; Thank you.
&gt;&gt;&gt; This is probably a little early to ask.

00:46:00.900 --> 00:46:08.329
But I'm curious with the model-driven views,
if you go and inspect the DOM and try to edit

00:46:08.329 --> 00:46:16.119
it later? Are you editing the template or
rendered result? Or do you get to choose which

00:46:16.119 --> 00:46:20.250
side you're on?
&gt;&gt;Alex Russell: So when you go with model-driven

00:46:20.250 --> 00:46:25.990
views, our goal is to extract out the latent
driven model that's in HTML. If you think

00:46:25.990 --> 00:46:31.540
about structuring your HTML, you've got form
inputs. Hierarchy of your document, semi-semantic

00:46:31.540 --> 00:46:37.069
tags. In that case, we just sort of want to
make it easier for you to transition to a

00:46:37.069 --> 00:46:41.050
world where you're modifying your data and
not so much modifying the DOM. If you can

00:46:41.050 --> 00:46:46.120
get away with modifying your data and propagating
sort of input events back to your data to

00:46:46.120 --> 00:46:51.540
your model and have that regenerate the DOM
that you've got, that's the nirvana. That's

00:46:51.540 --> 00:46:55.849
the place we all want to be, where we don't
have to think so hard about what's going to

00:46:55.849 --> 00:47:01.290
happen when I modify this piece of DOM. If
you do have to modify DOM, the template isn't

00:47:01.290 --> 00:47:08.570
unlike HTML 2 templates. You wind up in a
place where, if I change the template, which

00:47:08.570 --> 00:47:14.180
you can do later, it will take effect the
next time I apply it, the next time I stamp

00:47:14.180 --> 00:47:18.770
out new instance of that template. But existing
instances of the template aren't affected.

00:47:18.770 --> 00:47:26.510
If I go and change the generated DOM, there's
the potential we may disconnect the two. We

00:47:26.510 --> 00:47:31.170
don't want to really sort keep you from doing
that. But you may no longer see updates that

00:47:31.170 --> 00:47:48.109
are generated back from the model.
&gt;&gt;&gt; Thanks.

00:47:48.109 --> 00:48:10.630
&gt;&gt; Ian Fette: In the back, I think.
&gt;&gt;&gt; I have a question. I built a small HTML5

00:48:10.630 --> 00:48:12.570
thing for myself that used the HTML5 audio
tag. And then I was dragging and dropping

00:48:12.570 --> 00:48:13.570
files from the local computer to then populate
that audio tag.

00:48:13.570 --> 00:48:14.570
And I ran into a couple problems with, actually,
dropping a blob onto the page and totally

00:48:14.570 --> 00:48:16.990
crashing the page by dumping 5 megabytes of
memory onto it. But, as far as -- but I'm

00:48:16.990 --> 00:48:20.440
wondering how the file system API and the
HTML5 audio tag or the HTML5 video tag could

00:48:20.440 --> 00:48:21.440
interact with each other and, if that's being
thought of.

00:48:21.440 --> 00:48:22.440
&gt;&gt;Ian Fette: So, without knowing the exact
details of your implementation, there are

00:48:22.440 --> 00:48:26.549
certainly ways that you can, like, try to
get a data URI from whatever is dropped on.

00:48:26.549 --> 00:48:31.520
And that turns into some giant amount of memory.
One of the cool things that comes from the

00:48:31.520 --> 00:48:38.700
file system is a class called file reader.
So you can, essentially, rather than having

00:48:38.700 --> 00:48:45.089
to get a -- just like the whole contents of
the file and put that in some data URI, you

00:48:45.089 --> 00:48:51.000
can use file reader to seek around parts of
the file. You can get a URI that you can then

00:48:51.000 --> 00:48:56.190
put inside the source attribute of an audio
or video tag. So what we're really trying

00:48:56.190 --> 00:49:02.170
to do is we're trying to make sure that anything
you store in the HTML5 file system API or

00:49:02.170 --> 00:49:08.150
anything that you get a reference to, like
if someone drags a file on or someone chooses

00:49:08.150 --> 00:49:11.609
a file from an input type equals file dialogue,
we want you to be able to get sort of a handle

00:49:11.609 --> 00:49:16.390
to that file and then do intelligent things
with the file wherever it already is without

00:49:16.390 --> 00:49:22.360
having to copy it. So get a URI that you can
shove in an image tag, an audio tag, open

00:49:22.360 --> 00:49:27.359
a file, reader or writer, that you can seek
or read or write parts of the file. Like,

00:49:27.359 --> 00:49:30.530
we really want, like, all these things that
you can do on Unix when you just F open a

00:49:30.530 --> 00:49:37.270
file, F seek, F read, F write. We want those
simple use cases in a way that's, obviously,

00:49:37.270 --> 00:49:53.630
safe for the web but in a way that's equally
performant and expressive. That's really our

00:49:53.630 --> 00:50:03.970
goal.
&gt;&gt;&gt; That's great. Thank you very much.

00:50:03.970 --> 00:50:06.650
&gt;&gt;&gt; I would like to ask what is the plan for
the hardware or device supporting HTML5 starting

00:50:06.650 --> 00:50:07.650
from, for example, most common devices like
web cam or the microphone or smart card readers.

00:50:07.650 --> 00:50:13.890
&gt;&gt; Ian Fette: We have a team that's working
on microphone and camera input. It's not quite

00:50:13.890 --> 00:50:20.490
there yet. But we do want to make it so that
you can do -- like we have a whole group inside

00:50:20.490 --> 00:50:24.849
of our team that's focused on what we call
realtime communications. So how do I get access

00:50:24.849 --> 00:50:30.350
to the microphone and video camera? That's
one part of it. But then, once I get access

00:50:30.350 --> 00:50:34.099
to it, what do I actually do with it?
It's one thing to be able to put that into

00:50:34.099 --> 00:50:39.619
a canvas or video tag and display it on the
screen. But then how do I take that data and

00:50:39.619 --> 00:50:45.010
transmit it somewhere? Like, if I'm doing
streaming, I don't really want to use WebSockets.

00:50:45.010 --> 00:50:51.829
Because that's TCP. And, if I'm on a slow
connection, I'd rather just drop frames than,

00:50:51.829 --> 00:50:57.400
you know, make the other guy wait. So we're
-- we're not there yet. But we are doing a

00:50:57.400 --> 00:51:02.720
lot of work around video and audio and streaming
that, in particular.

00:51:02.720 --> 00:51:08.410
As for other types of devices, it's sort of
an open question. There's a few proposals

00:51:08.410 --> 00:51:16.059
for how to deal with sort of letting the browser
interact with types of devices it doesn't

00:51:16.059 --> 00:51:20.619
know about yet. So, like, a new input device,
a new game pad. It's still sort of in the

00:51:20.619 --> 00:51:22.640
early days of specs. And there's not really
that much that you can play with at this point.

00:51:22.640 --> 00:51:30.160
&gt;&gt;Alex Russell: My personal hope is we get
to a place where a lot of these things have

00:51:30.160 --> 00:51:37.599
an easy onramp and a sophisticated API behind
them. So, if I have the device capability,

00:51:37.599 --> 00:51:43.040
the input tag gives you access to that thing.
Files, for instance. that seems like a good

00:51:43.040 --> 00:51:49.900
analogy where you could hang a sophisticated
DOM off it later. But still have an easy onramp

00:51:49.900 --> 00:51:54.930
for web authors. There's a lot of permissioning
questions like how many info bars are we going

00:51:54.930 --> 00:51:57.739
to throw? It's complicated but coming.
&gt;&gt;&gt; Thanks.

00:51:57.739 --> 00:52:05.829
&gt;&gt;&gt; Hello, with the new templating scheme
that you showed us in all of your data living

00:52:05.829 --> 00:52:09.860
in JSON somewhere, what would be the implications
for SEO?

00:52:09.860 --> 00:52:15.940
&gt;&gt;Alex Russell: That's a great question. In
fact, my hope is that, because a lot of this

00:52:15.940 --> 00:52:21.170
can be declared -- what we showed you is the
data in JSON, but the template in HTML. Those

00:52:21.170 --> 00:52:27.329
things don't have to be that way. The data
could be HTML. If the data is HTML, then you've

00:52:27.329 --> 00:52:32.600
got the content that you're trying to express
there. And, if that has the links in the content

00:52:32.600 --> 00:52:35.280
that is important to the web engine, that
gives you degradability, for one. But it gives

00:52:35.280 --> 00:52:42.740
you the ability to search. The other question
is how smart can the web crawlers be?

00:52:42.740 --> 00:52:48.000
So a lot of that is declarative. We showed
you imperative version. But, if a lot is declarative,

00:52:48.000 --> 00:52:52.799
then there's a hope we cannot have a big gap
in support as this rolls out.

00:52:52.799 --> 00:52:58.250
&gt;&gt;Ian Fette: Hopefully, it makes it easier,
if you look at what the -- obviously, there's

00:52:58.250 --> 00:53:03.670
school.com. But there's also insider Google.
there's things like product search and trying

00:53:03.670 --> 00:53:06.829
to extract meaningful, actual, like, data,
not just strings of text, entities, entity

00:53:06.829 --> 00:53:09.470
recognition. So this will, hopefully, make
that easier. But we are still in the early

00:53:09.470 --> 00:53:10.470
days.
&gt;&gt;&gt; Thank you.

00:53:10.470 --> 00:53:17.310
&gt;&gt;&gt; Alex, data banding to model, framework
to date? It's built into the platform. You

00:53:17.310 --> 00:53:31.099
don't have to send it down the wire.
&gt;&gt;Alex Russell: A lot of these things, I should

00:53:31.099 --> 00:53:36.839
say, are predicated on not inventing something
brand-new but looking at existing best practice

00:53:36.839 --> 00:53:39.690
and trying to work backwards and say what
could we do in the platform, if we had the

00:53:39.690 --> 00:53:45.349
power to change the platform? A lot of the
toolkits like I worked on before I joined

00:53:45.349 --> 00:53:50.589
Google can do a lot of the same things, but
they can't do it in as natural a way. So the

00:53:50.589 --> 00:53:56.990
opportunity for the platform is to do it -- express
the capacity in the most natural way for you

00:53:56.990 --> 00:54:03.339
as a developer and so not to go necessarily
plow new ground entirely but to go figure

00:54:03.339 --> 00:54:04.910
out what's working and then just make it faster,
easier, and simpler for developers.

00:54:04.910 --> 00:54:05.910
&gt;&gt;&gt; Okay. Thank you.
&gt;&gt;&gt; Hey. I noticed in the template, that was,

00:54:05.910 --> 00:54:08.740
basically, a four loop. Oftentimes in template
like in Jango, we have like "if", which is

00:54:08.740 --> 00:54:16.569
useful but I know also some people are uncomfortable
with things like "if" in templates.

00:54:16.569 --> 00:54:24.400
How far are you guys going to go in terms
of that stuff and logic?

00:54:24.400 --> 00:54:29.500
&gt;&gt;Alex Russell: So there is a small expression
language, basically which ties back to JavaScript.

00:54:29.500 --> 00:54:34.590
But that's, again, not going to be language
dependent and won't tie necessarily to JavaScript,

00:54:34.590 --> 00:54:38.781
whatever is there.
But the hope is you won't have to rely on

00:54:38.781 --> 00:54:43.440
that. If a property isn't available, there's
going to be a pipe filter syntax like you

00:54:43.440 --> 00:54:48.990
might see out of -- there is a pipe filter
syntax in the MBV prototype today, the sort

00:54:48.990 --> 00:54:51.240
of thing you might see in Jango where you
can run filters through.

00:54:51.240 --> 00:54:55.550
One of the things you could do is specify
the hidden property from HTML5. If you want

00:54:55.550 --> 00:54:59.809
something to not be output, you can just hide
it and that gives you the ability to do a

00:54:59.809 --> 00:55:03.720
lot of conditional logic based on the structure
of your data without necessarily going to

00:55:03.720 --> 00:55:09.109
programmatic expression which, again, is going
to be the sort of thing that defeats SEO or

00:55:09.109 --> 00:55:10.989
machine recognition of what you have done.
&gt;&gt;&gt; Thanks.

00:55:10.989 --> 00:55:17.700
&gt;&gt;&gt; What's the status of IndexedDB? And how
long do you think it is going to be practical

00:55:17.700 --> 00:55:23.140
before we can actually make end users have
good use of it?

00:55:23.140 --> 00:55:32.369
&gt;&gt;Ian Fette: Yeah, so, right now we've got
support for all of the asynchronous IndexedDB

00:55:32.369 --> 00:55:38.780
-- we have support for all asynchronous IndexedDB
on Chrome dev.

00:55:38.780 --> 00:55:42.700
We are doing a few things right now to make
it more performance. So our initial implementation

00:55:42.700 --> 00:55:47.869
was using SQLite as a backend, and we found
this to be sort of unacceptably slow for a

00:55:47.869 --> 00:55:54.190
lot of transactions. So we have a new backend
called LevelDB.

00:55:54.190 --> 00:56:01.960
We are working on trying to get that in Chrome
13 as well as working on a synchronous set

00:56:01.960 --> 00:56:05.470
of APIs for IndexedDB that are available for
workers.

00:56:05.470 --> 00:56:12.530
Hopefully in, like -- by the end of the month,
it should be pretty usable with the new backend.

00:56:12.530 --> 00:56:14.160
There's a chance that might slip into early
June.

00:56:14.160 --> 00:56:21.349
But definitely very soon, we will have the
new backend and all the IndexedDB, asynchronous

00:56:21.349 --> 00:56:25.430
and Worker Synchronous APIs working in Chrome.
So broadly summertime.

00:56:25.430 --> 00:56:26.930
&gt;&gt;&gt; All right, thanks.
&gt;&gt;&gt; Hi. Are you working on standardization

00:56:26.930 --> 00:56:41.369
of background pages or background apps?
[ Laughter ]

00:56:41.369 --> 00:56:45.599
&gt;&gt;Ian Fette: As we both look at each other.
So, you know, we had this interesting discussion

00:56:45.599 --> 00:56:49.829
over beer a night or two ago about background
pages versus workers.

00:56:49.829 --> 00:56:54.260
And workers are absolutely awesome because
there is a lot of things that you want to

00:56:54.260 --> 00:56:58.559
do off the main threads, some heavy computation,
but then there is also things you want to

00:56:58.559 --> 00:57:02.420
do off the main thread that requires some
access to the DOM.

00:57:02.420 --> 00:57:07.700
So the prototypical example of this is image
manipulation. Sure you can try to code everything

00:57:07.700 --> 00:57:14.880
up in JavaScript. It would be really nice
just to have a canvas in -- off the main thread

00:57:14.880 --> 00:57:19.020
that you can do manipulations with, but you
can't have a canvas without the DOMs. So we

00:57:19.020 --> 00:57:25.730
get into this whole thing of background pages.
And, yeah, I mean, there's a lot of great

00:57:25.730 --> 00:57:31.500
use cases for it. There's also things like,
I've got an offline email app and it wants

00:57:31.500 --> 00:57:36.910
to check for email every half-hour and how
am I supposed to do that?

00:57:36.910 --> 00:57:42.829
It's something we're trying to figure out.
We don't have a clear path right now, but

00:57:42.829 --> 00:57:46.750
there's so many use cases for it, we have
to figure out a way. It is just a matter of

00:57:46.750 --> 00:57:48.740
when and how.
&gt;&gt;Alex Russell: This is the return of viewable

00:57:48.740 --> 00:57:52.319
shared state, right? That's the thing we never
want to get into as a platform. We never want

00:57:52.319 --> 00:57:57.220
to have some other thing running in parallel
to your application which can go unexpectedly

00:57:57.220 --> 00:58:03.089
change that stuff out from under you causing
you to have to create some new text primitive

00:58:03.089 --> 00:58:05.950
or something like that.
But at the same time, we need sort of zero

00:58:05.950 --> 00:58:11.340
copy or one-copy access to a lot of those
things so we can shuttle them back and forth

00:58:11.340 --> 00:58:15.190
across these processes.
It is not clear exactly how this is going

00:58:15.190 --> 00:58:20.480
to be won, right? Maybe there's some model
like transactional shared memory, something

00:58:20.480 --> 00:58:24.440
like that.
But for now, we're doing this sort of one-off

00:58:24.440 --> 00:58:29.619
when you have a big use case, like image processing.
Let's make Canvas data available. So those

00:58:29.619 --> 00:58:40.720
are the sorts of things where if we can see
where computation is going to be needed and

00:58:40.720 --> 00:58:46.440
we can off load it, maybe we can build a bridge
from the DOM to that computational unit.

00:58:46.440 --> 00:58:48.030
&gt;&gt;&gt; The reason I'm asking is one of the last
things missing to have an alternative to native

00:58:48.030 --> 00:58:49.850
Android apps to HTML5 because you don't have
the background wake up the app or something

00:58:49.850 --> 00:58:53.180
with HTML5 apps.
&gt;&gt;Ian Fette: I think it is a part of a much

00:58:53.180 --> 00:58:57.490
broader question which is sort of how do we
get away from the model where the application

00:58:57.490 --> 00:59:05.650
always has to be running? Like, on Android,
I don't have the entire mail application running

00:59:05.650 --> 00:59:08.320
all the time. And, yet, my email is still
syncing.

00:59:08.320 --> 00:59:14.480
How do we get Web applications to a point
where they can be told by a server that something

00:59:14.480 --> 00:59:19.010
interesting has happened and they should process
it without having to run the full application?

00:59:19.010 --> 00:59:22.990
I think that's sort of a broader question
that we definitely need to solve, especially

00:59:22.990 --> 00:59:28.440
as we try to target mobile devices like phones
and Chromebooks and -- I mean, it is something

00:59:28.440 --> 00:59:30.760
we have to solve.
&gt;&gt;Alex Russell: The question is which part

00:59:30.760 --> 00:59:35.920
of the Web platform is going to reach down
and intercede on your behalf with the OS.

00:59:35.920 --> 00:59:40.690
Open question.
&gt;&gt;Ian Fette: All right. Thank you all so much

00:59:40.690 --> 00:59:47.330
for coming. We really appreciate it. I hope
you have a great rest of the day here at Google

00:59:47.330 --> 00:59:49.630
I/O. Thanks again.
[ Applause ]

