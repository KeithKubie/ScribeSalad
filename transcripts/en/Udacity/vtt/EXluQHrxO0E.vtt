WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:04.000
So we've just finished learning about interpreters and formal semantics.

00:00:04.000 --> 00:00:07.000
We touched briefly on the halting problem.

00:00:07.000 --> 00:00:11.000
Surprisingly, although the halting problem officially is impossible to solve,

00:00:11.000 --> 00:00:15.000
it's actually one of my favorite areas in computer science.

00:00:15.000 --> 00:00:18.000
The halting problem and its cousin, Rice's Theorem,

00:00:18.000 --> 00:00:20.000
are sometimes informally known as the

00:00:20.000 --> 00:00:23.000
Law of Interpreter/Writer Employability.

00:00:23.000 --> 00:00:28.000
Because it's officially impossible to solve all these problems and get them right every time,

00:00:28.000 --> 00:00:31.000
there's always a market for people who can make

00:00:31.000 --> 00:00:33.000
closer approximations or be almost right,

00:00:33.000 --> 00:00:37.000
be right most of the time, be right with high probability.

00:00:37.000 --> 00:00:40.000
We know it's impossible to do absolutely correctly,

00:00:40.000 --> 00:00:43.000
but nothing stops us from being 99.999% correct.

00:00:43.000 --> 00:00:46.000
So we keep trying, with closer and closer approximations.

00:00:46.000 --> 00:00:50.000
In fact, a few years ago, with a student, I was trying to do just that.

00:00:50.000 --> 00:00:53.000
We wanted to look at a programmed source code

00:00:53.000 --> 00:00:57.000
and guess which lines were likely to be executed frequently

00:00:57.000 --> 00:00:59.000
without actually running the program.

00:00:59.000 --> 00:01:01.000
If we could solve this formally,

00:01:01.000 --> 00:01:04.000
we could definitely solve the halting problem.

00:01:04.000 --> 00:01:06.000
So we know it's impossible,

00:01:06.000 --> 00:01:10.000
but we can solve it before a subset of programs or be often right.

00:01:10.000 --> 00:01:13.000
You might imagine looking at the recursive definition for Fibonacci.

00:01:13.000 --> 00:01:16.000
If you're calling Fibonacci of ten,

00:01:16.000 --> 00:01:20.000
the recursive call happens much, much more frequently

00:01:20.000 --> 00:01:23.000
than the base case that just returns one.

00:01:23.000 --> 00:01:26.000
Is there some way we can look at how humans write programs

00:01:26.000 --> 00:01:28.000
and figure out what's common based on that?

00:01:28.000 --> 00:01:31.000
It turns out we were able to extract

00:01:31.000 --> 00:01:34.000
this sort of structural information or comments

00:01:34.000 --> 00:01:36.000
that are present in human written programs

00:01:36.000 --> 00:01:40.000
and figure out for them which lines are more or less likely to be executed,

00:01:40.000 --> 00:01:43.000
or executed more or less frequently at run time.

00:01:43.000 --> 00:01:46.000
So even though the problem is impossible to solve in practice,

00:01:46.000 --> 00:01:48.000
we actually view this as an opportunity.

00:01:48.000 --> 00:01:51.000
Because it's not possible to get it exactly right,

00:01:51.000 --> 09:59:59.000
we want to come as close as we can and reach for the stars.

