WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.415
[APPLAUSE]

00:00:03.870 --> 00:00:06.436
JOE CONWAY: I hope you clap
like that after the talk.

00:00:06.436 --> 00:00:08.310
I'm also very glad that
we had a lunch break.

00:00:08.310 --> 00:00:09.768
Because following
some of the stuff

00:00:09.768 --> 00:00:13.532
these guys had in the morning,
that would be a tough task.

00:00:13.532 --> 00:00:15.240
So let's thank them
for all the hard work

00:00:15.240 --> 00:00:17.340
that they do to
allow us to build--

00:00:17.340 --> 00:00:20.130
[APPLAUSE]

00:00:20.130 --> 00:00:22.650
--really great tools on
top of what they produce.

00:00:22.650 --> 00:00:23.700
So my name is Joe Conway.

00:00:23.700 --> 00:00:26.790
I am the CEO of Stable Kernel,
and we are a mobile development

00:00:26.790 --> 00:00:27.900
consultancy.

00:00:27.900 --> 00:00:30.900
And we have to write back-ends
an awful lot of the time.

00:00:30.900 --> 00:00:35.100
And we started using Dart to
build our server-side stuff

00:00:35.100 --> 00:00:36.390
about a year ago.

00:00:36.390 --> 00:00:38.880
And as a programmer, the
most important thing is,

00:00:38.880 --> 00:00:40.380
I don't want to
write a lot of code.

00:00:40.380 --> 00:00:42.080
Because I'm human,
and I make mistakes.

00:00:42.080 --> 00:00:44.280
And the more code I write, the
more opportunity for mistakes.

00:00:44.280 --> 00:00:46.500
So as we were building
things, we were abstracting it

00:00:46.500 --> 00:00:50.574
into another layer, a lower
layer that we call Aqueduct--

00:00:50.574 --> 00:00:51.240
or "Ah-queduct."

00:00:51.240 --> 00:00:54.990
I actually do not know
how to pronounce it.

00:00:54.990 --> 00:00:57.240
And just to clarify-- so
what I mean when I say--

00:00:57.240 --> 00:01:00.222
it's an open-source server-side
framework written in Dart.

00:01:00.222 --> 00:01:01.680
And to clarify what
I mean by that,

00:01:01.680 --> 00:01:03.210
just in case there's
any confusion--

00:01:03.210 --> 00:01:04.769
you've got a getup where
you've got some clients,

00:01:04.769 --> 00:01:06.750
and they're talking
over HTTP, probably

00:01:06.750 --> 00:01:08.866
with JSON, or some sort
of format like that.

00:01:08.866 --> 00:01:09.990
And they're hitting an API.

00:01:09.990 --> 00:01:12.365
And then maybe that talks to
a database or another larger

00:01:12.365 --> 00:01:13.030
system.

00:01:13.030 --> 00:01:17.919
And that's where Aqueduct
goes, so pretty normal stuff.

00:01:17.919 --> 00:01:19.710
One of the things we
want to do, because we

00:01:19.710 --> 00:01:21.626
have to start from scratch
on all the projects

00:01:21.626 --> 00:01:24.280
that we work for, is we want
to be able to get moving very,

00:01:24.280 --> 00:01:25.170
very quickly.

00:01:25.170 --> 00:01:27.720
And so the setup process
is extremely quick,

00:01:27.720 --> 00:01:29.850
and there's templates
to get started.

00:01:29.850 --> 00:01:32.340
And all you have to do is you
set up your packet, or pub,

00:01:32.340 --> 00:01:34.100
to activate Aqueduct globally.

00:01:34.100 --> 00:01:35.612
You run the setup one time.

00:01:35.612 --> 00:01:38.070
I'll leave that surprise for
what happens when you actually

00:01:38.070 --> 00:01:39.060
run it yourself.

00:01:39.060 --> 00:01:41.730
You create a new project, and
then you're ready to go, right?

00:01:41.730 --> 00:01:45.260
And the things that come
in the template here--

00:01:45.260 --> 00:01:48.124
it's kind of a fully-featured
web application.

00:01:48.124 --> 00:01:50.040
It's kind of ready to
start and get you going.

00:01:50.040 --> 00:01:51.600
And you can build on top of it.

00:01:51.600 --> 00:01:54.420
And so this magically
just fit on this slide.

00:01:54.420 --> 00:01:56.490
But you get authentication.

00:01:56.490 --> 00:01:57.990
So there's an OAuth
2 implementation

00:01:57.990 --> 00:01:58.870
that's available.

00:01:58.870 --> 00:02:00.570
You get a few routes
hooked up to ensure

00:02:00.570 --> 00:02:02.190
that you can do authentication.

00:02:02.190 --> 00:02:04.230
You get a registration endpoint.

00:02:04.230 --> 00:02:06.330
You get scripts for
running your application

00:02:06.330 --> 00:02:08.520
on EC2 and on Heroku.

00:02:08.520 --> 00:02:11.940
You get the ability to reflect
in your code with a one-liner

00:02:11.940 --> 00:02:16.320
and generate an open API
specification of the API

00:02:16.320 --> 00:02:17.774
that you've built.

00:02:17.774 --> 00:02:18.940
You can have a test harness.

00:02:18.940 --> 00:02:20.023
You get stuff for testing.

00:02:20.023 --> 00:02:21.630
You get configuration files.

00:02:21.630 --> 00:02:22.920
You can put it onto Travis.

00:02:22.920 --> 00:02:24.690
We've just kind of given you
all the things so that you just

00:02:24.690 --> 00:02:26.273
say, OK, I'm going
to write some code.

00:02:29.100 --> 00:02:31.200
So if you're going
to write that code,

00:02:31.200 --> 00:02:32.702
you need to understand
how it works.

00:02:32.702 --> 00:02:33.660
And it's pretty simple.

00:02:33.660 --> 00:02:35.850
There's nothing really
revolutionary about this.

00:02:35.850 --> 00:02:38.970
A lot of frameworks that
do this do this same thing.

00:02:38.970 --> 00:02:40.950
You have this concept
of request controllers,

00:02:40.950 --> 00:02:43.080
and they form a stream.

00:02:43.080 --> 00:02:45.880
And when an HTTP request
comes into the system,

00:02:45.880 --> 00:02:47.880
it starts with something
called a requestSync.

00:02:47.880 --> 00:02:49.590
And that requestSync
forwards it onto a router.

00:02:49.590 --> 00:02:50.970
And that router
forwards it onto,

00:02:50.970 --> 00:02:52.939
based on the path,
different HTTP controllers,

00:02:52.939 --> 00:02:54.480
or different types
of things that are

00:02:54.480 --> 00:02:56.250
going to handle that request.

00:02:56.250 --> 00:02:59.310
And along the way, something
might respond to the request.

00:02:59.310 --> 00:03:02.310
Or it might forward it onto
a subsequent controller

00:03:02.310 --> 00:03:03.810
to handle that request.

00:03:03.810 --> 00:03:07.020
So for example, once that
request gets to a router,

00:03:07.020 --> 00:03:09.450
and there's no registered
route for the path of the HTTP

00:03:09.450 --> 00:03:11.570
request, it'll
respond with a 404.

00:03:11.570 --> 00:03:13.920
If it matches one, it
passes it onto the next guy.

00:03:13.920 --> 00:03:16.280
And that one's responsible
for responding to it.

00:03:16.280 --> 00:03:17.640
Make sense?

00:03:17.640 --> 00:03:20.240
Pretty standard stuff?

00:03:20.240 --> 00:03:22.190
And so that requestSync,
that thing that's

00:03:22.190 --> 00:03:24.810
sort of the initial
part of the chain, when

00:03:24.810 --> 00:03:26.370
you create an
Aqueduct application,

00:03:26.370 --> 00:03:27.690
you subclass requestSync.

00:03:27.690 --> 00:03:30.647
And this is where you
set up your application.

00:03:30.647 --> 00:03:32.730
This is where you're going
to set up your routing.

00:03:32.730 --> 00:03:34.230
You're going to set
up any resources

00:03:34.230 --> 00:03:36.480
that you're going to use,
like a database connection.

00:03:36.480 --> 00:03:39.630
And the routing is, again,
pretty simple stuff.

00:03:39.630 --> 00:03:42.690
This is an example of
a route specification.

00:03:42.690 --> 00:03:45.330
And you're probably familiar
with syntax like this,

00:03:45.330 --> 00:03:48.630
or this specific one,
where I'm saying, hey,

00:03:48.630 --> 00:03:50.580
this route will go to /articles.

00:03:50.580 --> 00:03:53.210
And then I've got these brackets
here, which means optional.

00:03:53.210 --> 00:03:55.380
So /articles slash some index.

00:03:55.380 --> 00:03:58.480
The colon here means a
variable, a path variable.

00:03:58.480 --> 00:04:01.050
So this particular route
says if you send a request,

00:04:01.050 --> 00:04:04.975
it has /articles, or
/articles/whatever.

00:04:04.975 --> 00:04:07.350
Then we're going to move onto
something called an article

00:04:07.350 --> 00:04:07.920
controller.

00:04:07.920 --> 00:04:09.810
That will be the thing that's
responsible for responding

00:04:09.810 --> 00:04:10.462
to the request.

00:04:13.770 --> 00:04:16.680
The typical situation--
there's a lot of different ways

00:04:16.680 --> 00:04:18.420
to actually handle requests.

00:04:18.420 --> 00:04:21.180
The middle ground is
an HTTP controller.

00:04:21.180 --> 00:04:23.881
So it's got a lot of power but
still retains some flexibility.

00:04:23.881 --> 00:04:25.630
There's things that
go in both directions.

00:04:25.630 --> 00:04:28.830
Like I can use a closure
here in this spot.

00:04:28.830 --> 00:04:32.010
And I can just have
that respond to it.

00:04:32.010 --> 00:04:34.080
But HTTP controller is
one of those things that

00:04:34.080 --> 00:04:38.100
gives us a lot of value
and allows us to properly

00:04:38.100 --> 00:04:39.824
compartmentalize our code.

00:04:39.824 --> 00:04:41.490
So when you get into
an HTTP controller,

00:04:41.490 --> 00:04:43.670
you've already been matched on
the route that you care about.

00:04:43.670 --> 00:04:44.753
So we're coming into here.

00:04:44.753 --> 00:04:47.970
We have /articles or
/articles/something.

00:04:47.970 --> 00:04:51.649
And what an HTTP controller
does is it picks out a method.

00:04:51.649 --> 00:04:52.440
It's a Dart method.

00:04:52.440 --> 00:04:54.230
We call it a responder method.

00:04:54.230 --> 00:04:58.062
And responder methods are always
decorated with an HTTP method.

00:04:58.062 --> 00:04:58.770
So this is a GET.

00:04:58.770 --> 00:05:01.890
So if I GET into this
controller with a request,

00:05:01.890 --> 00:05:06.041
and it's a GET request, this
method's going to be invoked.

00:05:06.041 --> 00:05:08.540
The responsibility of a method
like this is that number one,

00:05:08.540 --> 00:05:09.820
it has to be asynchronous,
because you're probably

00:05:09.820 --> 00:05:11.400
going to do some stuff in it.

00:05:11.400 --> 00:05:14.400
And then it has to
return a response object.

00:05:14.400 --> 00:05:17.040
And there's constructors for
all the different responses

00:05:17.040 --> 00:05:18.230
that you need.

00:05:18.230 --> 00:05:22.300
Response objects know how to
serialize and encode data.

00:05:22.300 --> 00:05:25.850
So this will take these articles
that we get from somewhere,

00:05:25.850 --> 00:05:29.102
and it will serialize this and
encode it into JSON by default.

00:05:29.102 --> 00:05:30.560
And you can add
different encoders.

00:05:30.560 --> 00:05:32.210
You can add different decoders.

00:05:32.210 --> 00:05:35.840
But this is the basic format
of an HTTP controller.

00:05:35.840 --> 00:05:37.000
I mark it up.

00:05:37.000 --> 00:05:41.190
It calls a method,
responds to a request.

00:05:41.190 --> 00:05:44.970
Of course, in this
particular endpoint,

00:05:44.970 --> 00:05:47.700
we could get
/article/article/index.

00:05:47.700 --> 00:05:51.900
And so if we wanted to
run a different method

00:05:51.900 --> 00:05:55.770
for the particular case when
the endpoint is /article/index,

00:05:55.770 --> 00:05:59.160
we add it as a parameter to a
different HTTP GET responder

00:05:59.160 --> 00:06:00.690
method.

00:06:00.690 --> 00:06:02.850
And so we're basically
saying here, in the route,

00:06:02.850 --> 00:06:04.100
we've called this thing index.

00:06:04.100 --> 00:06:06.750
We call this a path
variable in index.

00:06:06.750 --> 00:06:09.090
And we specify the type.

00:06:09.090 --> 00:06:12.390
And we're going to GET whatever
that path variable is parsed

00:06:12.390 --> 00:06:14.520
into this particular type.

00:06:14.520 --> 00:06:17.460
So the two different endpoints
for that particular route

00:06:17.460 --> 00:06:19.930
are going to call one
of these two methods.

00:06:19.930 --> 00:06:22.560
And this particular method
would go get a specific article

00:06:22.560 --> 00:06:24.740
and return a different response.

00:06:24.740 --> 00:06:28.770
So the great part about this
is, let's say, for example,

00:06:28.770 --> 00:06:30.650
you passed in something
that could not

00:06:30.650 --> 00:06:33.030
be parsed into an integer.

00:06:33.030 --> 00:06:36.360
It would select this method,
try and parse that path variable

00:06:36.360 --> 00:06:39.999
into an integer, fail, come
back and return you a 404.

00:06:39.999 --> 00:06:41.373
And it will not
call your method.

00:06:45.150 --> 00:06:48.430
Now obviously, once
you're handling a request,

00:06:48.430 --> 00:06:51.620
you can always access the
Dart standard library request

00:06:51.620 --> 00:06:52.750
object.

00:06:52.750 --> 00:06:54.230
So here's some
code that you might

00:06:54.230 --> 00:06:57.780
write to go in and grab query
parameters from the URI,

00:06:57.780 --> 00:06:58.875
to grab headers.

00:06:58.875 --> 00:07:00.500
We want to make sure
that they actually

00:07:00.500 --> 00:07:01.890
include this particular header.

00:07:01.890 --> 00:07:04.440
And so if they don't,
we return a bad request.

00:07:04.440 --> 00:07:05.970
But that's boilerplate.

00:07:05.970 --> 00:07:08.490
And the idea is to write less
code, because more code means

00:07:08.490 --> 00:07:09.540
more errors.

00:07:09.540 --> 00:07:12.110
And so HTTP controller
also has a built-in ability

00:07:12.110 --> 00:07:14.640
to handle that type of thing.

00:07:14.640 --> 00:07:17.025
So I can say, listen,
this particular method

00:07:17.025 --> 00:07:20.292
is going to have a header
with X-Required-ID.

00:07:20.292 --> 00:07:22.500
And it's going to have a
query parameter, potentially

00:07:22.500 --> 00:07:23.560
contains.

00:07:23.560 --> 00:07:25.970
And for you Dart
programmers, everyone here,

00:07:25.970 --> 00:07:28.892
you know that the squigglies
here, that means optional.

00:07:28.892 --> 00:07:30.600
And so that actually
means the same thing

00:07:30.600 --> 00:07:33.450
for this particular
request handler.

00:07:33.450 --> 00:07:37.100
I can get this method invoked
when I send an HTTP request,

00:07:37.100 --> 00:07:39.860
and it could potentially have
a contains query parameter.

00:07:39.860 --> 00:07:43.290
If it doesn't, I get null
for the contains variable.

00:07:43.290 --> 00:07:45.330
And if I do, I get
whatever value they pass.

00:07:45.330 --> 00:07:48.720
But this header here, this is in
the positional arguments, which

00:07:48.720 --> 00:07:50.071
means that it is required.

00:07:50.071 --> 00:07:51.570
And so if you get
to the point where

00:07:51.570 --> 00:07:53.640
this method has been
selected, and you did not

00:07:53.640 --> 00:07:55.872
attach X-Required-ID,
you're going to get a 400.

00:07:55.872 --> 00:07:57.330
It's going to say,
hey, by the way,

00:07:57.330 --> 00:08:00.409
you're missing X-Required-ID
as a parameter, as a header.

00:08:00.409 --> 00:08:01.950
So again, it's just
making the things

00:08:01.950 --> 00:08:04.324
that we have to do over and
over again a lot more simple.

00:08:07.490 --> 00:08:09.900
Now because of
the way this thing

00:08:09.900 --> 00:08:12.480
is structured, this idea of
having request controllers that

00:08:12.480 --> 00:08:16.410
either pass it on or return some
response and do not pass it on,

00:08:16.410 --> 00:08:19.000
we can add middleware
into the whole thing.

00:08:19.000 --> 00:08:21.150
And so one of the examples
that comes built-in

00:08:21.150 --> 00:08:22.850
is an OAuth 2 implementation.

00:08:22.850 --> 00:08:24.670
And within the OAuth
2 implementation,

00:08:24.670 --> 00:08:27.444
there is a request
controller called Authorizer.

00:08:27.444 --> 00:08:29.360
And we can just put that
in between the router

00:08:29.360 --> 00:08:31.081
and a particular controller.

00:08:31.081 --> 00:08:32.789
And that thing is
responsible for looking

00:08:32.789 --> 00:08:35.422
at the authorization header
and saying, you don't match,

00:08:35.422 --> 00:08:37.880
or, you do match, and I'll let
you go a little bit further.

00:08:37.880 --> 00:08:39.380
If you fail, you get a 401.

00:08:39.380 --> 00:08:40.586
You do not go any further.

00:08:40.586 --> 00:08:42.169
And that works
together with an object

00:08:42.169 --> 00:08:45.540
called an authentication server,
which implements OAuth 2.

00:08:45.540 --> 00:08:47.783
And then you provide
the persistence

00:08:47.783 --> 00:08:49.300
for what the OAuth server wants.

00:08:49.300 --> 00:08:50.720
So it'll say, hey, I want
you to store a token.

00:08:50.720 --> 00:08:52.110
You store it in
Postgres or whatever

00:08:52.110 --> 00:08:53.318
database you're working with.

00:08:56.700 --> 00:09:00.360
So the way that these
routes are set up,

00:09:00.360 --> 00:09:03.340
this concept of just sort
of chaining things together,

00:09:03.340 --> 00:09:06.420
we want that metaphor
to make sense in the way

00:09:06.420 --> 00:09:08.000
that you actually
write the code.

00:09:08.000 --> 00:09:09.621
So you look at other
frameworks, some

00:09:09.621 --> 00:09:11.870
of those controllers, those
things that handle things,

00:09:11.870 --> 00:09:13.911
they kind of have to know
where they are in that.

00:09:13.911 --> 00:09:15.710
They have to explicitly
say, hey, now

00:09:15.710 --> 00:09:17.340
you can go onto the next one.

00:09:17.340 --> 00:09:20.600
That type of behavior is sort
of handled at a higher level.

00:09:20.600 --> 00:09:23.010
You're just returning
requests and response objects.

00:09:23.010 --> 00:09:24.843
If you want to go
forward, return a request.

00:09:24.843 --> 00:09:27.454
If you want to complete the
request and respond to it,

00:09:27.454 --> 00:09:28.370
you return a response.

00:09:28.370 --> 00:09:31.120
And this is the thing
that forms that stream.

00:09:31.120 --> 00:09:32.550
So we set up a router.

00:09:32.550 --> 00:09:34.950
We can pipe it to an Authorizer.

00:09:34.950 --> 00:09:37.100
That's that thing that
checks for authentication.

00:09:37.100 --> 00:09:38.850
And then we can generate
a new controller.

00:09:38.850 --> 00:09:41.225
Now, there's a little subtle
difference here between pipe

00:09:41.225 --> 00:09:43.290
and generate.

00:09:43.290 --> 00:09:44.730
The idea is this.

00:09:44.730 --> 00:09:48.210
When you have HTTP controller,
when a request comes in,

00:09:48.210 --> 00:09:50.060
it has properties
that represent things

00:09:50.060 --> 00:09:51.620
in that particular request.

00:09:51.620 --> 00:09:54.180
It has that actual reference to
the request that's coming in.

00:09:54.180 --> 00:09:56.160
If it decodes an
HTTP body, it's going

00:09:56.160 --> 00:09:58.230
to have that body as a property.

00:09:58.230 --> 00:10:01.227
And so when you're working in
an asynchronous environment,

00:10:01.227 --> 00:10:03.060
this particular controller
could get halfway

00:10:03.060 --> 00:10:04.290
through processing requests.

00:10:04.290 --> 00:10:06.450
And then a new
request could come in,

00:10:06.450 --> 00:10:08.220
and it would trump
those properties.

00:10:08.220 --> 00:10:09.240
And that would be bad.

00:10:09.240 --> 00:10:11.700
So generate means
for every request,

00:10:11.700 --> 00:10:13.830
create a new
instance of this guy.

00:10:13.830 --> 00:10:15.710
Pipe, because you
don't have to-- it's

00:10:15.710 --> 00:10:16.470
just a pass-through, right?

00:10:16.470 --> 00:10:18.110
The Authorizer does
not keep any state

00:10:18.110 --> 00:10:19.920
about the request
it's processing.

00:10:19.920 --> 00:10:24.080
So pipe versus generate--
small little nuance.

00:10:24.080 --> 00:10:26.160
The different strategies
for these Authorizers--

00:10:26.160 --> 00:10:28.800
so if you're familiar with
OAuth 2 specification,

00:10:28.800 --> 00:10:31.200
you have a resource owner.

00:10:31.200 --> 00:10:33.270
You have authorization code.

00:10:33.270 --> 00:10:34.054
You have client.

00:10:34.054 --> 00:10:36.470
The default is resource owner,
because most of your routes

00:10:36.470 --> 00:10:37.950
will have that.

00:10:37.950 --> 00:10:40.560
The ability to change
the strategy to something

00:10:40.560 --> 00:10:43.650
like the application level,
client ID, client secret pair,

00:10:43.650 --> 00:10:44.764
is done right here.

00:10:44.764 --> 00:10:46.680
And so the idea is you
can come into one place

00:10:46.680 --> 00:10:48.240
and kind of see the
entire structure

00:10:48.240 --> 00:10:50.062
and flow of your application.

00:10:50.062 --> 00:10:52.020
But all that code is
actually compartmentalized

00:10:52.020 --> 00:10:54.270
and allows for a better
structure of your application.

00:10:57.126 --> 00:10:58.500
The really great
part about this,

00:10:58.500 --> 00:11:00.840
though, is because
of this structure,

00:11:00.840 --> 00:11:03.110
you can actually spawn
that entire stream

00:11:03.110 --> 00:11:05.340
onto multiple isolates.

00:11:05.340 --> 00:11:07.860
And so this allows for
a lot of great things.

00:11:07.860 --> 00:11:10.326
So you don't have to
do anything special.

00:11:10.326 --> 00:11:11.700
You just set up
your requestSync,

00:11:11.700 --> 00:11:14.279
and you say, here are my routes,
and here are my resources.

00:11:14.279 --> 00:11:16.320
And there's this thing
called an application that

00:11:16.320 --> 00:11:18.720
sort of manages
and supervises all

00:11:18.720 --> 00:11:20.580
of these different isolates.

00:11:20.580 --> 00:11:22.140
And it's responsible,
more or less,

00:11:22.140 --> 00:11:24.777
for being able to round
robin deliver requests

00:11:24.777 --> 00:11:26.110
into each one of these isolates.

00:11:26.110 --> 00:11:28.300
You get multi-threading, right?

00:11:28.300 --> 00:11:31.710
And each set, or each
isolate and its requestSync,

00:11:31.710 --> 00:11:33.180
will have its own
set of resources,

00:11:33.180 --> 00:11:34.666
like a database connection.

00:11:34.666 --> 00:11:36.540
You don't necessarily
have to do it that way.

00:11:36.540 --> 00:11:38.520
But when you think about
a typical application,

00:11:38.520 --> 00:11:40.690
you probably have a pool
of database connections.

00:11:40.690 --> 00:11:42.850
And as you're doing things
sort of concurrently,

00:11:42.850 --> 00:11:45.150
you go and ask that pool,
hey, let me use your database

00:11:45.150 --> 00:11:46.410
connection for a second.

00:11:46.410 --> 00:11:47.380
I've made that request.

00:11:47.380 --> 00:11:47.921
Now I'm done.

00:11:47.921 --> 00:11:50.701
Here's the connection so
someone else can use it.

00:11:50.701 --> 00:11:52.950
With this process, you don't
have to think about that.

00:11:52.950 --> 00:11:55.920
Because each one of these guys
has their own set of resources.

00:11:55.920 --> 00:11:57.690
And because of the way
that isolates work,

00:11:57.690 --> 00:11:59.670
you can't really
get in a situation

00:11:59.670 --> 00:12:02.690
where you create race
conditions between the two.

00:12:07.230 --> 00:12:09.280
And opting into that
behavior, you just

00:12:09.280 --> 00:12:11.400
specify when you
start the application.

00:12:11.400 --> 00:12:12.810
So you have that requestSync.

00:12:12.810 --> 00:12:15.000
That's the type parameter
for an application.

00:12:15.000 --> 00:12:16.880
When you start the
application, you just say,

00:12:16.880 --> 00:12:18.809
I want three of those things.

00:12:18.809 --> 00:12:20.850
And the other great part
about that is it kind of

00:12:20.850 --> 00:12:23.800
forces you into this model of
writing a stateless web server.

00:12:23.800 --> 00:12:26.370
And so you already know that
once you've done it once

00:12:26.370 --> 00:12:28.950
on one machine, it's
technically kind of distributed

00:12:28.950 --> 00:12:30.909
across a number of threads
in that one machine.

00:12:30.909 --> 00:12:32.825
So when you scale it out
to multiple machines,

00:12:32.825 --> 00:12:34.350
you put it behind
a load balancer.

00:12:34.350 --> 00:12:35.370
That stuff's just going to work.

00:12:35.370 --> 00:12:37.294
You've already kind of
tested that behavior.

00:12:41.080 --> 00:12:42.762
So that's the request
handling stuff.

00:12:42.762 --> 00:12:44.220
There isn't really
anything-- other

00:12:44.220 --> 00:12:46.330
than isolate stuff,
which is pretty neat.

00:12:46.330 --> 00:12:48.450
It should be pretty
typical stuff.

00:12:48.450 --> 00:12:50.479
Having an ORM is
another portion of this.

00:12:50.479 --> 00:12:52.020
There are really
three major portions

00:12:52.020 --> 00:12:54.519
that I'll touch on today and a
few accoutrements at the end.

00:12:54.519 --> 00:12:55.500
And we're in Europe.

00:12:55.500 --> 00:12:56.875
I probably pronounced
that wrong.

00:12:56.875 --> 00:12:59.610
I don't know.

00:12:59.610 --> 00:13:04.200
So the ORM here-- the way
you work with the database

00:13:04.200 --> 00:13:05.670
is you create query objects.

00:13:05.670 --> 00:13:07.530
And then you specify
the type of the object

00:13:07.530 --> 00:13:09.030
that you're working with.

00:13:09.030 --> 00:13:11.310
And then you execute
an operation on it.

00:13:11.310 --> 00:13:13.415
And the great part about
Dart here is async await.

00:13:13.415 --> 00:13:14.040
I'll be honest.

00:13:14.040 --> 00:13:17.700
That was the deciding factor
for all of this stuff.

00:13:17.700 --> 00:13:20.950
Having callbacks is
not exactly fun for me.

00:13:20.950 --> 00:13:22.850
So this would, in
this particular case,

00:13:22.850 --> 00:13:24.384
fetch every article
from a database.

00:13:24.384 --> 00:13:26.550
So there is a corresponding
article table somewhere,

00:13:26.550 --> 00:13:27.917
and it's got columns.

00:13:27.917 --> 00:13:30.000
And we're pulling in
instances-- every single one,

00:13:30.000 --> 00:13:33.565
in this case-- of
those articles.

00:13:33.565 --> 00:13:35.190
The great part about
this is the things

00:13:35.190 --> 00:13:38.612
that represent database rows
in our Aqueduct applications,

00:13:38.612 --> 00:13:41.070
we don't have to do anything
special to serialize or encode

00:13:41.070 --> 00:13:43.130
them, as I was saying
a little bit earlier.

00:13:43.130 --> 00:13:45.620
I can pass them as the body
argument to a response,

00:13:45.620 --> 00:13:47.841
and it knows how
to serialize them.

00:13:47.841 --> 00:13:49.590
And then the HTTP
controller will actually

00:13:49.590 --> 00:13:52.080
make the decision about
the encoding-- so JSON,

00:13:52.080 --> 00:13:52.697
for example.

00:13:57.330 --> 00:14:00.380
Now, you typically don't want
to fetch an entire table.

00:14:00.380 --> 00:14:02.280
I don't think that
happens all that often.

00:14:02.280 --> 00:14:04.960
Typically you want to have
some sort of WHERE clause.

00:14:04.960 --> 00:14:09.272
And so this is the thing
I'm most excited about.

00:14:09.272 --> 00:14:09.980
The idea is this.

00:14:09.980 --> 00:14:12.290
When you create a
query object, there's

00:14:12.290 --> 00:14:13.480
a property called matchOn.

00:14:13.480 --> 00:14:15.480
I was trying to make this
sound like a sentence,

00:14:15.480 --> 00:14:17.850
like, matchOn the
category where equal to.

00:14:17.850 --> 00:14:19.350
It only really reads
like a sentence

00:14:19.350 --> 00:14:20.850
if you were born
in a household that

00:14:20.850 --> 00:14:25.770
spoke SQL-- not my household.

00:14:25.770 --> 00:14:26.670
But the idea is this.

00:14:26.670 --> 00:14:29.820
MatchOn has the
same properties--

00:14:29.820 --> 00:14:32.964
it's an interface to the same
type that you're querying.

00:14:32.964 --> 00:14:34.380
Now, there's some
special behavior

00:14:34.380 --> 00:14:37.730
that goes on underneath the hood
to make this kind of all work.

00:14:37.730 --> 00:14:41.760
But the idea is that now we
get the Analyzer and code

00:14:41.760 --> 00:14:44.435
completion to help
us build our queries.

00:14:44.435 --> 00:14:46.810
We don't really have to think
about, what do I name this?

00:14:46.810 --> 00:14:48.810
And especially for
refactoring-- if you refactor

00:14:48.810 --> 00:14:52.020
to rename something, and you
have extremely tight data,

00:14:52.020 --> 00:14:54.000
you end up in a pretty
crappy situation.

00:14:54.000 --> 00:14:56.790
This allows us to build
queries in a way that's

00:14:56.790 --> 00:14:59.010
very similar to the way
that we do Dart tests.

00:14:59.010 --> 00:15:01.370
Dart tests-- we use the
Hamcrest matchers style.

00:15:01.370 --> 00:15:04.400
And so we have the same
concept of matchers

00:15:04.400 --> 00:15:06.750
that we can apply to each
one of these properties.

00:15:06.750 --> 00:15:08.170
So what we're
saying here is, hey,

00:15:08.170 --> 00:15:09.750
I'm going to go
fetch some articles.

00:15:09.750 --> 00:15:11.124
But I only want
the articles that

00:15:11.124 --> 00:15:15.110
have a category that's equal to
whatever I got passed in here.

00:15:15.110 --> 00:15:16.360
And I go to fetch them.

00:15:16.360 --> 00:15:17.950
I get the subset of articles.

00:15:17.950 --> 00:15:19.120
And I return them.

00:15:19.120 --> 00:15:22.090
Now, you can match on
a number of properties.

00:15:22.090 --> 00:15:24.430
It logically ANDs them together.

00:15:24.430 --> 00:15:27.220
And there's also a
number of matchers.

00:15:27.220 --> 00:15:29.590
And the matchers will
be appropriately--

00:15:29.590 --> 00:15:32.500
you can pass in a date,
time, a number, a string.

00:15:32.500 --> 00:15:34.702
The underlying mechanism
that takes care of this

00:15:34.702 --> 00:15:36.410
is going to tell you
when you screwed up.

00:15:36.410 --> 00:15:38.409
Unfortunately, it can't
do that at compile time.

00:15:38.409 --> 00:15:42.130
But the idea is that you can
build most queries out of this.

00:15:42.130 --> 00:15:43.420
And there's a manhole as well.

00:15:43.420 --> 00:15:45.550
If you can't build a query
that you want to build,

00:15:45.550 --> 00:15:47.590
you can drop down and just write
the WHERE clause by itself.

00:15:47.590 --> 00:15:49.910
Or you could drop down and
just write SQL by itself.

00:15:49.910 --> 00:15:52.139
So it's not preventing
you from getting deeper.

00:15:52.139 --> 00:15:53.930
But the idea is it's
there to do the things

00:15:53.930 --> 00:15:56.013
that you want to do in a
much more productive way.

00:16:00.280 --> 00:16:03.097
With queries, you can insert,
update, delete, fetch,

00:16:03.097 --> 00:16:04.180
all those sorts of things.

00:16:04.180 --> 00:16:07.240
So this would be an example
of me wanting to update

00:16:07.240 --> 00:16:08.890
one of these articles.

00:16:08.890 --> 00:16:11.440
So when I'm building
a query for update,

00:16:11.440 --> 00:16:12.940
not only do I still
get my matchOn--

00:16:12.940 --> 00:16:13.480
and that's the
thing that's going

00:16:13.480 --> 00:16:15.310
to specify which row
I'm going to update,

00:16:15.310 --> 00:16:18.020
or number of rows that
I'm going to update.

00:16:18.020 --> 00:16:20.110
There's also a values
object that a query has.

00:16:20.110 --> 00:16:22.480
And again, it has
the same properties

00:16:22.480 --> 00:16:24.370
that this article object has.

00:16:24.370 --> 00:16:26.740
And so that's going to allow
me to configure that thing.

00:16:26.740 --> 00:16:28.281
The great part about
that, of course,

00:16:28.281 --> 00:16:31.000
is that the article object,
or any of these objects

00:16:31.000 --> 00:16:33.820
that we use to
represent database rows,

00:16:33.820 --> 00:16:35.890
have this readMap method.

00:16:35.890 --> 00:16:38.560
And that's going to bring in,
from the request body that's

00:16:38.560 --> 00:16:41.337
been decoded for
you, those values.

00:16:41.337 --> 00:16:42.670
And it's going to validate them.

00:16:42.670 --> 00:16:43.840
It's going to validate keys.

00:16:43.840 --> 00:16:47.050
So you send a key that's not
appropriate, it'll throw a 400

00:16:47.050 --> 00:16:47.600
for you.

00:16:47.600 --> 00:16:49.600
It's going to validate
the types of those values

00:16:49.600 --> 00:16:52.660
and just kind of make sure
you have the right data.

00:16:52.660 --> 00:16:54.670
Now, one thing you'll
probably notice

00:16:54.670 --> 00:16:57.580
is that I've really not
done any error handling.

00:16:57.580 --> 00:16:59.980
And for that reason, you
might think I'm full of crap.

00:16:59.980 --> 00:17:05.281
But the idea is when a query
has a failure-- so first of all,

00:17:05.281 --> 00:17:07.030
if this article, if
this fails, if there's

00:17:07.030 --> 00:17:09.290
a reason for this not to
validate, we're going to get

00:17:09.290 --> 00:17:09.790
bumped out.

00:17:09.790 --> 00:17:12.790
We're going to get
a 400 responded to.

00:17:12.790 --> 00:17:15.369
With queries, there's plenty
of things that can go on.

00:17:15.369 --> 00:17:17.319
I could not get a
connection to the database.

00:17:17.319 --> 00:17:19.660
I could have written a really
weird query that doesn't work.

00:17:19.660 --> 00:17:21.535
The user could have
given me something weird.

00:17:21.535 --> 00:17:24.369
It could have a unique
constraint violation.

00:17:24.369 --> 00:17:27.038
All those things are baked
into the request control.

00:17:27.038 --> 00:17:28.329
Well, they're not really baked.

00:17:28.329 --> 00:17:29.620
They're decoupled enough, right?

00:17:29.620 --> 00:17:31.744
But when a query runs into
one of those situations,

00:17:31.744 --> 00:17:32.981
it throws an exception.

00:17:32.981 --> 00:17:34.480
And the request
controller knows how

00:17:34.480 --> 00:17:36.370
to interpret that exception.

00:17:36.370 --> 00:17:40.600
And so if this article, let's
say that for whatever reason,

00:17:40.600 --> 00:17:43.000
update date is unique.

00:17:43.000 --> 00:17:45.130
And that update date is
already in the database

00:17:45.130 --> 00:17:46.730
for another row.

00:17:46.730 --> 00:17:49.450
I'm going to get a unique
constraint violation exception

00:17:49.450 --> 00:17:51.530
from when I execute this query.

00:17:51.530 --> 00:17:54.130
The request controller layer is
going to look at that and say,

00:17:54.130 --> 00:17:55.310
that's a 409.

00:17:55.310 --> 00:17:57.670
And it's going to respond
409 to the requesting client.

00:18:02.140 --> 00:18:04.540
In order to get all
that lovely behavior

00:18:04.540 --> 00:18:08.470
about being able to model
a database in your Dart

00:18:08.470 --> 00:18:12.320
application, it's really
a two component thing.

00:18:12.320 --> 00:18:14.890
The first is something we
call a persistent type.

00:18:14.890 --> 00:18:18.544
And the persistent type is
going to be a plain Dart class.

00:18:18.544 --> 00:18:19.960
And that plain
Dart class is going

00:18:19.960 --> 00:18:23.020
to have all the columns
that are on that table.

00:18:23.020 --> 00:18:24.670
And the name of
that table is going

00:18:24.670 --> 00:18:26.255
to be the name of this class.

00:18:26.255 --> 00:18:27.880
And there's a number
of things that you

00:18:27.880 --> 00:18:30.715
can set up-- indexing and
nullability and et cetera, et

00:18:30.715 --> 00:18:32.680
cetera.

00:18:32.680 --> 00:18:34.680
To get all the fun behavior
that I've discussed,

00:18:34.680 --> 00:18:36.388
there's this concept
of a managed object.

00:18:36.388 --> 00:18:37.780
If you're coming
from iOS, you've

00:18:37.780 --> 00:18:39.863
seen a managed object
before, because I ripped off

00:18:39.863 --> 00:18:42.040
the entire core data
stack to do this.

00:18:42.040 --> 00:18:45.156
It's just a really good stack.

00:18:45.156 --> 00:18:46.780
And so the idea is
that we kind of wrap

00:18:46.780 --> 00:18:48.100
this thing in a managed object.

00:18:48.100 --> 00:18:49.880
And I'm not going to get into
the specific details of how

00:18:49.880 --> 00:18:50.260
that works.

00:18:50.260 --> 00:18:52.259
But that's the thing
responsible for translating

00:18:52.259 --> 00:18:55.000
between the database and
serializing and de-serializing

00:18:55.000 --> 00:18:57.710
data.

00:18:57.710 --> 00:18:59.860
We can also set
up relationships.

00:18:59.860 --> 00:19:02.410
So if I have two objects,
one that contains the other--

00:19:02.410 --> 00:19:04.870
this author, for example, has
a managed set of articles.

00:19:04.870 --> 00:19:08.080
Managed set is, again, just like
a set, except for it's managed

00:19:08.080 --> 00:19:10.360
like a managed object is.

00:19:10.360 --> 00:19:12.490
On the other side of
that, I have to set up

00:19:12.490 --> 00:19:13.900
an inverse relationship.

00:19:13.900 --> 00:19:16.780
So what's going to happen here
is in this persistent type,

00:19:16.780 --> 00:19:20.230
this resolves to
rows in a database.

00:19:20.230 --> 00:19:22.630
And this, on the other
side of the relationship,

00:19:22.630 --> 00:19:24.970
resolves to a
foreign key column.

00:19:24.970 --> 00:19:27.460
And it will use the
idiomatic naming conventions

00:19:27.460 --> 00:19:29.000
of the underlying database.

00:19:29.000 --> 00:19:31.900
So this actually ends
up being author_ID,

00:19:31.900 --> 00:19:33.760
because the primary
key of this guy is ID.

00:19:37.860 --> 00:19:39.475
When I have a
relationship set up,

00:19:39.475 --> 00:19:42.220
I can fetch an object
and its sub-objects.

00:19:42.220 --> 00:19:43.155
So I can do a JOIN.

00:19:43.155 --> 00:19:45.250
And that's really great,
because I use the matchOn

00:19:45.250 --> 00:19:47.560
property again, and I say,
hey, I want to include these.

00:19:47.560 --> 00:19:49.270
By default, you're not going
to grab an entire object

00:19:49.270 --> 00:19:50.230
tree, right?

00:19:50.230 --> 00:19:53.650
So you can choose
to opt into that.

00:19:53.650 --> 00:19:55.660
When you do opt into
it, you can additionally

00:19:55.660 --> 00:19:57.750
specify extra constraints
in the WHERE clause.

00:19:57.750 --> 00:20:00.587
So I can say, listen, I
want this author's articles.

00:20:00.587 --> 00:20:02.920
I want the author himself,
and then I want the articles.

00:20:02.920 --> 00:20:05.336
But I only want the articles
that are written about rocks.

00:20:08.520 --> 00:20:11.010
Another great thing--
database migrations.

00:20:11.010 --> 00:20:13.184
So clearly, as you
build an application,

00:20:13.184 --> 00:20:15.600
you've already defined your
data model in your application

00:20:15.600 --> 00:20:17.010
by defining all these things.

00:20:17.010 --> 00:20:18.990
I ripped this off from .NET.

00:20:18.990 --> 00:20:20.945
Let me just clarify--
I'm not that smart.

00:20:20.945 --> 00:20:22.320
I just ripped all
this stuff off.

00:20:22.320 --> 00:20:23.695
But it's in Dart,
so it's better.

00:20:26.430 --> 00:20:29.370
So the great thing about this
is you get a migration file.

00:20:29.370 --> 00:20:31.560
You have a number of
migration files over time.

00:20:31.560 --> 00:20:33.610
And you can execute
those migration files.

00:20:33.610 --> 00:20:35.100
The other great thing
about that-- I'm not even

00:20:35.100 --> 00:20:35.940
going to get into
this, because you

00:20:35.940 --> 00:20:37.148
don't need to worry about it.

00:20:37.148 --> 00:20:40.410
Oh, son of a-- all
right, there we go.

00:20:40.410 --> 00:20:42.900
Because Aqueduct will
actually do this for you.

00:20:42.900 --> 00:20:44.790
It will generate
your migration files

00:20:44.790 --> 00:20:46.560
by reflecting on
your data model.

00:20:46.560 --> 00:20:48.150
And so when you make
a change, you're

00:20:48.150 --> 00:20:51.060
going to get that change
into the migration file.

00:20:51.060 --> 00:20:53.280
There's things that
you can't 100% resolve.

00:20:53.280 --> 00:20:54.210
What is a rename?

00:20:54.210 --> 00:20:55.961
Is it a delete and
add, or is it a rename?

00:20:55.961 --> 00:20:58.043
So it gives you an opportunity
to go in and modify

00:20:58.043 --> 00:20:58.590
those files.

00:20:58.590 --> 00:21:00.720
Once you've modified
them, you run validate.

00:21:00.720 --> 00:21:03.814
And it'll tell you every single
thing that you did wrong.

00:21:03.814 --> 00:21:05.730
And once you're cool
with it, you run upgrade,

00:21:05.730 --> 00:21:09.120
and that's actually going to run
those actions in a transaction

00:21:09.120 --> 00:21:12.180
against that database.

00:21:12.180 --> 00:21:15.720
OK, I have three minutes, so
I'm going to go real fast.

00:21:15.720 --> 00:21:19.110
Testing-- code that isn't
tested doesn't work, just one

00:21:19.110 --> 00:21:20.700
of those things.

00:21:20.700 --> 00:21:23.820
We try to have an ability to put
things in a test harness that

00:21:23.820 --> 00:21:25.050
makes sense.

00:21:25.050 --> 00:21:27.450
When you use the template
to create a new project,

00:21:27.450 --> 00:21:29.040
this code's all written for you.

00:21:29.040 --> 00:21:30.450
There's no mocking, OK?

00:21:30.450 --> 00:21:31.197
The idea is this.

00:21:31.197 --> 00:21:32.030
I don't trust mocks.

00:21:32.030 --> 00:21:34.800
Because it's more code that I
wrote, and it's probably wrong.

00:21:34.800 --> 00:21:36.630
So it actually
starts a web server.

00:21:36.630 --> 00:21:37.740
It connects to a database.

00:21:37.740 --> 00:21:40.110
It creates temporary
versions of your tables.

00:21:40.110 --> 00:21:42.617
Those only exist for as long
as the connection is alive.

00:21:42.617 --> 00:21:43.950
And then you can run your tests.

00:21:43.950 --> 00:21:46.366
And we don't really care about
this because, again, that's

00:21:46.366 --> 00:21:47.610
lower level.

00:21:47.610 --> 00:21:50.110
Once you have that thing
running-- by the way,

00:21:50.110 --> 00:21:51.930
this takes milliseconds.

00:21:51.930 --> 00:21:53.550
Your tests are just,
hey, I want to go

00:21:53.550 --> 00:21:56.370
make an authenticated
request for this end point.

00:21:56.370 --> 00:21:57.340
It's a GET.

00:21:57.340 --> 00:22:00.450
And when I get it back, there's
some additional matchers

00:22:00.450 --> 00:22:03.720
to complement the test
framework that already exists

00:22:03.720 --> 00:22:05.100
to match against the responses.

00:22:05.100 --> 00:22:08.670
So here, you're saying,
listen, it needs to be at 200.

00:22:08.670 --> 00:22:10.470
And this is going
to match the body.

00:22:10.470 --> 00:22:13.410
The body gets decoded
according to its content type.

00:22:13.410 --> 00:22:16.609
And then you can specify a
map or list and all kinds

00:22:16.609 --> 00:22:18.900
of matchers to ensure that
the object that you got back

00:22:18.900 --> 00:22:21.380
is accurate.

00:22:21.380 --> 00:22:22.770
Make sense?

00:22:22.770 --> 00:22:24.190
And there's that word again.

00:22:24.190 --> 00:22:27.660
I like it-- "accoutrement."

00:22:27.660 --> 00:22:30.090
Big thing-- it's a very
well-documented framework.

00:22:30.090 --> 00:22:31.590
Because if it's not
well-documented,

00:22:31.590 --> 00:22:33.630
you're not going to use it.

00:22:33.630 --> 00:22:35.280
Documentation is up
on pub-- thank you

00:22:35.280 --> 00:22:37.290
for doing that-- or Dart Docs.

00:22:37.290 --> 00:22:40.590
The whole API is sort
of named consistently.

00:22:40.590 --> 00:22:43.049
So the idea should be that if
you're dealing with queries--

00:22:43.049 --> 00:22:44.548
if you type in
"query," you're going

00:22:44.548 --> 00:22:47.190
to find all the things that
are related to queries, right?

00:22:47.190 --> 00:22:48.840
You don't want to
make any surprises.

00:22:48.840 --> 00:22:51.690
Classes need to be clean.

00:22:51.690 --> 00:22:53.710
There's manholes, as I
was talking about before.

00:22:53.710 --> 00:22:55.260
You can use bits and
pieces of this thing.

00:22:55.260 --> 00:22:56.280
You can just use the ORM.

00:22:56.280 --> 00:22:58.050
You can just use the
request controller stuff.

00:22:58.050 --> 00:23:00.591
You could use bits and pieces
of the authentication mechanism

00:23:00.591 --> 00:23:03.210
if you want to.

00:23:03.210 --> 00:23:06.390
Customizable-- comes with
JSON and form-urlencoded,

00:23:06.390 --> 00:23:08.140
because we have to
support the OAuth spec.

00:23:08.140 --> 00:23:10.020
So if you want to add
protobufs or XML or anything

00:23:10.020 --> 00:23:12.360
like that, these top-level
objects-- or these classes,

00:23:12.360 --> 00:23:14.070
excuse me, stack
methods-- you can

00:23:14.070 --> 00:23:16.590
add closures that are
responsible for serializing and

00:23:16.590 --> 00:23:17.550
de-serialized data.

00:23:17.550 --> 00:23:22.146
Or encoding and decoding--
they're different things.

00:23:22.146 --> 00:23:24.520
Greatest part, though, I feel
like, especially when we're

00:23:24.520 --> 00:23:26.640
working on a big team,
is it automatically

00:23:26.640 --> 00:23:29.426
generates an open API
specification from your code.

00:23:29.426 --> 00:23:31.800
There's things that you can
do to improve it-- thank you.

00:23:31.800 --> 00:23:34.077
Somebody appreciates that.

00:23:34.077 --> 00:23:35.910
There's things you can
do to improve and add

00:23:35.910 --> 00:23:37.770
more information to that.

00:23:37.770 --> 00:23:39.360
But just by default,
you're going

00:23:39.360 --> 00:23:41.670
to get a lot of
information by just running

00:23:41.670 --> 00:23:43.992
one script to get all of this.

00:23:43.992 --> 00:23:44.700
And that's great.

00:23:44.700 --> 00:23:46.949
Put in your build tools,
goes out to your entire team,

00:23:46.949 --> 00:23:51.150
and no one gets to say, well,
when did you change this field?

00:23:51.150 --> 00:23:54.210
More information is
available on our website.

00:23:54.210 --> 00:23:56.790
These slides, kind of,
are up on SlideShare.

00:23:56.790 --> 00:23:58.410
I changed all of
them last night.

00:23:58.410 --> 00:24:00.180
But the gist is there.

00:24:00.180 --> 00:24:01.620
And that's it for me.

00:24:01.620 --> 00:24:04.670
[APPLAUSE]

