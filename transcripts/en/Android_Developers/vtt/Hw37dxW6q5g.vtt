WEBVTT
Kind: captions
Language: en

00:00:00.710 --> 00:00:02.790
KENNY STOLTZ: Hey everybody.

00:00:02.790 --> 00:00:05.810
Really glad that you
could join us here today.

00:00:05.810 --> 00:00:07.130
I'm Kenny Stoltz.

00:00:07.130 --> 00:00:09.200
I'm a product manager on Wear.

00:00:09.200 --> 00:00:12.360
And I lead product for some
of the standalone and iOS

00:00:12.360 --> 00:00:13.960
features.

00:00:13.960 --> 00:00:15.350
GRIFF HAZEN: And
I'm Griff Hazen.

00:00:15.350 --> 00:00:16.970
I'm a software
engineer and tech lead

00:00:16.970 --> 00:00:18.800
for Wear's Developer Platform.

00:00:18.800 --> 00:00:21.560
KENNY STOLTZ: So both of us have
been working on Android Wear

00:00:21.560 --> 00:00:23.604
since before 1.0.

00:00:23.604 --> 00:00:25.020
And today, we're
going to take you

00:00:25.020 --> 00:00:26.770
through a couple of
the things that you'll

00:00:26.770 --> 00:00:28.910
want to consider when you're
designing and building

00:00:28.910 --> 00:00:32.730
standalone apps in Wear 2.0.

00:00:32.730 --> 00:00:33.230
OK.

00:00:33.230 --> 00:00:35.240
So first, a question.

00:00:35.240 --> 00:00:37.240
Why would you build
a standalone app?

00:00:37.240 --> 00:00:38.650
There are three reasons.

00:00:38.650 --> 00:00:40.390
And the first is
the most obvious.

00:00:40.390 --> 00:00:43.420
Sometimes, you just don't
have your phone with you.

00:00:43.420 --> 00:00:45.700
Running is an obvious
use case where

00:00:45.700 --> 00:00:49.060
you might want not to have some
phone strapped to your wrist.

00:00:49.060 --> 00:00:51.860
And a bunch of other fitness
scenarios are similar.

00:00:51.860 --> 00:00:53.680
But standalone offers
the opportunity

00:00:53.680 --> 00:00:56.850
to free you from your phone
in a lot of other situations

00:00:56.850 --> 00:00:59.080
that you might find yourself
in throughout the day.

00:00:59.080 --> 00:01:01.654
So if you run to the store,
and you forget your phone.

00:01:01.654 --> 00:01:03.320
If you're doing chores
around the house,

00:01:03.320 --> 00:01:05.195
and you don't want to
have it in your pocket.

00:01:05.195 --> 00:01:07.090
If your phone dies, etc.

00:01:07.090 --> 00:01:09.550
Standalone will
let you still use

00:01:09.550 --> 00:01:12.460
that small screen on your
watch between the times

00:01:12.460 --> 00:01:15.290
when you've got
your phone with you.

00:01:15.290 --> 00:01:19.410
Second that building
standalone apps

00:01:19.410 --> 00:01:22.410
is a lot more like
building mobile apps.

00:01:22.410 --> 00:01:25.810
It's particularly faster
and easier to build them

00:01:25.810 --> 00:01:29.020
if you already have an
existing mobile app.

00:01:29.020 --> 00:01:31.230
So you'll spend
less time rewriting

00:01:31.230 --> 00:01:33.760
the basic infrastructure
for your app, which

00:01:33.760 --> 00:01:36.620
means that you can spend more
time making your app better

00:01:36.620 --> 00:01:39.160
on wearables.

00:01:39.160 --> 00:01:42.020
The last reason is
that standalone apps

00:01:42.020 --> 00:01:45.790
will work on watches connected
to both Android and iOS

00:01:45.790 --> 00:01:47.200
devices.

00:01:47.200 --> 00:01:49.750
So you want to make
your app as-- you

00:01:49.750 --> 00:01:52.319
want to offer your app to
as many people as possible.

00:01:52.319 --> 00:01:53.860
And if you follow
the design patterns

00:01:53.860 --> 00:01:55.310
that we'll share
with you, you can

00:01:55.310 --> 00:01:58.150
write one wearable app
that will work on watches

00:01:58.150 --> 00:02:01.310
connected to both devices.

00:02:01.310 --> 00:02:01.810
OK.

00:02:01.810 --> 00:02:03.880
So now we'll go through
a couple of things

00:02:03.880 --> 00:02:08.150
that you'll want to consider
before you start coding.

00:02:08.150 --> 00:02:12.330
So first of all, what
should a standalone app do?

00:02:12.330 --> 00:02:14.310
The easiest way to
start is to think

00:02:14.310 --> 00:02:18.220
about what your phone app does
and then distill that down.

00:02:18.220 --> 00:02:22.060
So think about what the most
important tasks that your app

00:02:22.060 --> 00:02:23.940
allows the user to accomplish.

00:02:23.940 --> 00:02:25.930
And then what flows
are absolutely

00:02:25.930 --> 00:02:27.920
necessary for the user
to go through, in order

00:02:27.920 --> 00:02:30.940
to accomplish those tasks.

00:02:30.940 --> 00:02:33.690
Now, you want to think a
little bit about your user

00:02:33.690 --> 00:02:35.580
and how they'll
be using your app.

00:02:35.580 --> 00:02:37.609
They're likely to be on the go.

00:02:37.609 --> 00:02:39.900
So you don't want to hold
their attention for too long.

00:02:39.900 --> 00:02:41.441
And you want to make
sure that you're

00:02:41.441 --> 00:02:45.430
making it fast and easy
to complete those tasks.

00:02:45.430 --> 00:02:48.050
Keep in mind, that
you don't want

00:02:48.050 --> 00:02:50.570
to let the user get
halfway through a task,

00:02:50.570 --> 00:02:54.920
and then ask them to switch
from the watch to the phone.

00:02:54.920 --> 00:02:56.630
First of all, obviously,
they might not

00:02:56.630 --> 00:02:57.847
have their phone with them.

00:02:57.847 --> 00:02:59.680
And second of all, they
might get frustrated

00:02:59.680 --> 00:03:01.300
or lose their place.

00:03:01.300 --> 00:03:04.230
So you want to try to support
every flow that you can from

00:03:04.230 --> 00:03:08.190
end to end on just the wearable.

00:03:08.190 --> 00:03:12.670
That said, your user often has
two awesome devices with them

00:03:12.670 --> 00:03:14.290
at the same time.

00:03:14.290 --> 00:03:17.680
So it's great to make
the two work in harmony

00:03:17.680 --> 00:03:21.960
and have appropriate and
useful content on each screen.

00:03:21.960 --> 00:03:26.200
The data layer APIs that we
released with Android Wear

00:03:26.200 --> 00:03:28.180
1.0 will continue to work.

00:03:28.180 --> 00:03:31.720
And you can use those to
build multI-screen experiences

00:03:31.720 --> 00:03:35.170
with Android phones.

00:03:35.170 --> 00:03:39.270
Finally, you want to
consider both types of phone

00:03:39.270 --> 00:03:42.040
that your user might have
while they're using your app.

00:03:42.040 --> 00:03:45.090
So Wear 2.0 Developer
Preview will allow

00:03:45.090 --> 00:03:47.380
you to pair with an iOS phone.

00:03:47.380 --> 00:03:49.030
Once you've paired
with the phone,

00:03:49.030 --> 00:03:53.780
you can sideload your app onto
the watch, and then test it.

00:03:53.780 --> 00:03:56.080
There are performance
differences, particularly

00:03:56.080 --> 00:03:58.450
the amount of bandwidth
that you'll have.

00:03:58.450 --> 00:03:59.890
So you really should test.

00:03:59.890 --> 00:04:01.850
And it's a great way to
make sure that you've

00:04:01.850 --> 00:04:03.380
got a standalone app.

00:04:06.780 --> 00:04:08.780
GRIFF HAZEN: If you're
already familiar with how

00:04:08.780 --> 00:04:11.140
to architect an
Android phone app,

00:04:11.140 --> 00:04:13.400
you'll be glad to learn
that Wear apps can now be

00:04:13.400 --> 00:04:16.200
written in a very similar way.

00:04:16.200 --> 00:04:18.269
Sure, the user
interface may need

00:04:18.269 --> 00:04:20.440
to be scoped down to
the most important user

00:04:20.440 --> 00:04:22.470
flows and the
limited real estate,

00:04:22.470 --> 00:04:24.600
but the underlying
code and services

00:04:24.600 --> 00:04:27.190
can be written in the same way
and even shared between phone

00:04:27.190 --> 00:04:28.820
and Wear apps.

00:04:28.820 --> 00:04:30.960
You can access the
cloud in the same way,

00:04:30.960 --> 00:04:32.960
use similar
authentication methods,

00:04:32.960 --> 00:04:36.530
and the same cloud
to device messaging.

00:04:36.530 --> 00:04:38.510
Let's dig in to
a few areas where

00:04:38.510 --> 00:04:41.740
we are providing additional
help for standalone apps.

00:04:41.740 --> 00:04:43.900
We'll also go through
some Android APIs

00:04:43.900 --> 00:04:45.730
you may be familiar
with on the phone,

00:04:45.730 --> 00:04:49.480
and how they can be
applicable and useful in Wear.

00:04:49.480 --> 00:04:52.040
First off, well take a
look at how standalone Wear

00:04:52.040 --> 00:04:56.720
apps can communicate with
cloud services and store data.

00:04:56.720 --> 00:04:58.850
One of the most important
platform changes

00:04:58.850 --> 00:05:01.500
to enable standalone
apps is the expansion

00:05:01.500 --> 00:05:03.860
of direct network access.

00:05:03.860 --> 00:05:06.090
Wear apps will now be able
to communicate directly

00:05:06.090 --> 00:05:08.070
with cloud services,
and can also

00:05:08.070 --> 00:05:12.790
schedule background work
that requires network access.

00:05:12.790 --> 00:05:14.900
When the phone is
connected over Bluetooth,

00:05:14.900 --> 00:05:18.460
network traffic proxies through
the phone's connections.

00:05:18.460 --> 00:05:20.680
When the watch is
outside of phone range,

00:05:20.680 --> 00:05:22.930
Wi-Fi and cellular
networks are used,

00:05:22.930 --> 00:05:25.360
depending on hardware support.

00:05:25.360 --> 00:05:27.637
The Wear platform takes
care of the transitioning

00:05:27.637 --> 00:05:28.345
between networks.

00:05:33.170 --> 00:05:35.590
In existing wearable apps,
data stored in the cloud

00:05:35.590 --> 00:05:39.540
was often relayed to the
wearable via an Android phone--

00:05:39.540 --> 00:05:41.900
via an Android app on the
phone, using data items

00:05:41.900 --> 00:05:44.250
in the wearable data layer APIs.

00:05:44.250 --> 00:05:46.260
The wearable data
layer is still useful

00:05:46.260 --> 00:05:49.090
when coordinating
between watch and phone.

00:05:49.090 --> 00:05:50.980
But with standalone,
it may be simpler

00:05:50.980 --> 00:05:54.510
to go directly to the
cloud for many use cases.

00:05:54.510 --> 00:05:56.360
In addition to
simplicity, it also

00:05:56.360 --> 00:05:58.310
works when the phone
is not available,

00:05:58.310 --> 00:06:01.030
or when paired to an iOS device.

00:06:01.030 --> 00:06:03.270
When talking to the cloud,
you can use protocols

00:06:03.270 --> 00:06:09.740
that you're already familiar
with like HTTP, TCP, or UDP.

00:06:09.740 --> 00:06:12.070
Once your data is fetched,
you can store it locally

00:06:12.070 --> 00:06:14.230
on the device,
just like on phones

00:06:14.230 --> 00:06:17.105
using shared preferences,
SQLite, or internal storage.

00:06:19.780 --> 00:06:22.790
If your Android phone app is
well maintained and tested,

00:06:22.790 --> 00:06:26.060
you may be better off starting
from your existing code base,

00:06:26.060 --> 00:06:28.240
and cutting things out
as opposed to starting

00:06:28.240 --> 00:06:29.670
from scratch.

00:06:29.670 --> 00:06:33.160
Common code and services, like
your networking data model

00:06:33.160 --> 00:06:36.260
and business logic, can be
shared between your phone app

00:06:36.260 --> 00:06:39.990
and Wear app, using
a shared library.

00:06:39.990 --> 00:06:42.380
Form factors, specific
code, and resources

00:06:42.380 --> 00:06:46.130
can remain in separate build
flavors for phone and Wear.

00:06:46.130 --> 00:06:48.500
This type of structure is
already supported natively

00:06:48.500 --> 00:06:49.954
in Android Studio and Gradle.

00:06:52.620 --> 00:06:54.250
When fetching data
from the cloud,

00:06:54.250 --> 00:06:56.960
it's important to fetch only
the data that your wearable app

00:06:56.960 --> 00:06:57.900
will need.

00:06:57.900 --> 00:07:01.390
Otherwise, you may introduce
latency, memory use,

00:07:01.390 --> 00:07:04.300
or battery use unnecessarily.

00:07:04.300 --> 00:07:08.020
In some cases, for example, when
over a Bluetooth LE connection,

00:07:08.020 --> 00:07:10.060
your app may have access
to just 10 kilobytes

00:07:10.060 --> 00:07:13.160
per second of bandwidth.

00:07:13.160 --> 00:07:16.340
We recommend auditing your
network traffic, both requests

00:07:16.340 --> 00:07:19.040
and responses, for extra
data that perhaps is only

00:07:19.040 --> 00:07:21.640
intended for phones.

00:07:21.640 --> 00:07:23.260
Shrinking large
images server-side

00:07:23.260 --> 00:07:24.930
before sending them
to the wearable

00:07:24.930 --> 00:07:29.490
is another great way to
reduce network traffic.

00:07:29.490 --> 00:07:32.700
In Android, background
services are a powerful tool

00:07:32.700 --> 00:07:35.970
but should be used wisely in
order to preserve battery life.

00:07:35.970 --> 00:07:38.780
In Android 6.0,
Doze and App Standby

00:07:38.780 --> 00:07:41.820
resulted in significant
improvements to battery life

00:07:41.820 --> 00:07:44.660
by allowing devices to
enter a deep sleep when

00:07:44.660 --> 00:07:47.290
idle or stationary.

00:07:47.290 --> 00:07:51.020
Doze has been extended in
Android and in Android Wear 2.0

00:07:51.020 --> 00:07:53.630
to enable some lighter
optimizations whenever

00:07:53.630 --> 00:07:58.010
the screen is in low power,
ambient mode, or off.

00:07:58.010 --> 00:08:01.090
Here's an overview of
the new Doze lifecycle.

00:08:01.090 --> 00:08:03.460
After the screen turns
off or enters ambient mode

00:08:03.460 --> 00:08:06.960
for long enough, lightweight
Doze can kick in.

00:08:06.960 --> 00:08:09.300
During Doze,
background tasks may

00:08:09.300 --> 00:08:13.590
be deferred to execute during
periodic maintenance windows.

00:08:13.590 --> 00:08:16.670
If the device later becomes
stationary for long enough,

00:08:16.670 --> 00:08:22.170
a deeper Doze mode kicks in,
similar to Doze in Android 6.0.

00:08:22.170 --> 00:08:25.250
To ensure your background
tasks are executed as desired,

00:08:25.250 --> 00:08:28.820
it's important to write
them in a Doze-safe manner.

00:08:28.820 --> 00:08:31.290
The JobScheduler
API allows an app

00:08:31.290 --> 00:08:33.960
to register for
Doze-save code execution,

00:08:33.960 --> 00:08:36.840
and is recommended
for background work.

00:08:36.840 --> 00:08:38.450
Various constraints
can be selected

00:08:38.450 --> 00:08:40.700
when scheduling
jobs, for example,

00:08:40.700 --> 00:08:43.120
the need for connectivity,
device charging,

00:08:43.120 --> 00:08:45.890
or periodic execution.

00:08:45.890 --> 00:08:47.680
It's important to
be conservative

00:08:47.680 --> 00:08:50.800
when scheduling jobs,
and to avoid execution

00:08:50.800 --> 00:08:53.230
in ways that could adversely
impact battery life.

00:08:56.050 --> 00:08:58.310
Job scheduled with
the JobScheduler API

00:08:58.310 --> 00:09:00.720
use the JobInfo Builder
object to provide

00:09:00.720 --> 00:09:02.830
constraints and metadata.

00:09:02.830 --> 00:09:06.690
We'll go on for a few useful
constraints that are available.

00:09:06.690 --> 00:09:10.290
To request networking, use the
setRequiredNetworkType method,

00:09:10.290 --> 00:09:12.940
and specify any or unmetered.

00:09:12.940 --> 00:09:15.290
NETWORK_TYPE_UNMETERED
is an appropriate choice

00:09:15.290 --> 00:09:17.120
for large data transfers.

00:09:17.120 --> 00:09:19.720
While NETWORK_TYPE_ANY is
more appropriate for smaller

00:09:19.720 --> 00:09:21.280
transfers.

00:09:21.280 --> 00:09:24.420
Note that in Wear 2.0, some
low bandwidth networks like,

00:09:24.420 --> 00:09:27.370
Bluetooth LE, are considered
unmetered-- sorry-- considered

00:09:27.370 --> 00:09:29.770
metered.

00:09:29.770 --> 00:09:31.680
To schedule a task that
requires the device

00:09:31.680 --> 00:09:35.640
to be on the charger, use the
setRequiresCharging method,

00:09:35.640 --> 00:09:37.400
or to be currently
idle, by calling

00:09:37.400 --> 00:09:39.780
the setRequiresDeviceIdle
method.

00:09:39.780 --> 00:09:42.010
Using both of these
together can be

00:09:42.010 --> 00:09:43.581
useful for lower
priority background

00:09:43.581 --> 00:09:44.580
work or synchronization.

00:09:47.400 --> 00:09:49.460
Here's an example of
a job being scheduled

00:09:49.460 --> 00:09:51.110
that requires
unmetered networking

00:09:51.110 --> 00:09:53.840
at the time the job is run
in addition to the device

00:09:53.840 --> 00:09:55.950
being on the charger.

00:09:55.950 --> 00:09:58.320
JobScheduler will
activate MyJobService

00:09:58.320 --> 00:10:00.660
when both of these
constraints are met.

00:10:00.660 --> 00:10:03.160
The Builder method
setExtras can be used

00:10:03.160 --> 00:10:05.790
to provide additional metadata.

00:10:05.790 --> 00:10:10.490
This bundle will be passed
to the job when executed.

00:10:10.490 --> 00:10:13.360
Note the MY_JOB_ID value
passed to the JobInfo.Builder

00:10:13.360 --> 00:10:14.840
constructor.

00:10:14.840 --> 00:10:17.720
This is an application-specific
identifier.

00:10:17.720 --> 00:10:20.960
Subsequent calls to cancel
jobs or create a new job

00:10:20.960 --> 00:10:23.270
with the same job ID will
update the existing job.

00:10:26.180 --> 00:10:28.560
Here is an implementation
of a JobService

00:10:28.560 --> 00:10:31.040
to handle the job from
the previous slide.

00:10:31.040 --> 00:10:33.700
When the job executes,
the onStartJob method

00:10:33.700 --> 00:10:37.080
is called with the
JobParameters object passed in.

00:10:37.080 --> 00:10:40.080
The JobParameters object
allows you to get the job ID

00:10:40.080 --> 00:10:42.070
and also any extras
bundle provided

00:10:42.070 --> 00:10:44.240
when scheduling the job.

00:10:44.240 --> 00:10:47.910
The onStartJob method is called
on the main application thread.

00:10:47.910 --> 00:10:50.850
So therefore, if any expensive
logic needs to be run,

00:10:50.850 --> 00:10:53.210
it should be pushed
to a separate thread.

00:10:53.210 --> 00:10:55.890
In this example, an
async task is used

00:10:55.890 --> 00:10:58.040
to run code in the background.

00:10:58.040 --> 00:11:01.400
Once your work is completed,
call the jobFinished method

00:11:01.400 --> 00:11:03.738
to notify JobScheduler
that the task is done.

00:11:06.730 --> 00:11:07.470
KENNY STOLTZ: OK.

00:11:07.470 --> 00:11:10.090
So now we'll go over a
couple of different options

00:11:10.090 --> 00:11:13.140
that you have for
authentication.

00:11:13.140 --> 00:11:14.540
The reason that
you need to start

00:11:14.540 --> 00:11:18.060
thinking about authenticating
is that now your app is running

00:11:18.060 --> 00:11:19.740
entirely on the wearable.

00:11:19.740 --> 00:11:22.530
So whenever it makes a request
for the cloud on behalf

00:11:22.530 --> 00:11:25.970
of the user, it's going to need
to have a valid auth token that

00:11:25.970 --> 00:11:27.590
shows that web
service that it has

00:11:27.590 --> 00:11:30.440
access to that private data.

00:11:30.440 --> 00:11:34.520
But before you rush to
ask the user to login,

00:11:34.520 --> 00:11:38.210
please consider what you can
do with an anonymous user.

00:11:38.210 --> 00:11:40.390
You want to try to
avoid authentication

00:11:40.390 --> 00:11:42.730
where it's not necessary.

00:11:42.730 --> 00:11:44.940
And if you need to
record data, you

00:11:44.940 --> 00:11:47.920
should try to record it
locally, instead of writing it

00:11:47.920 --> 00:11:49.370
to the cloud by
default. You have

00:11:49.370 --> 00:11:51.960
to remember that
the user might not

00:11:51.960 --> 00:11:53.940
have access to the
network at the time

00:11:53.940 --> 00:11:55.830
when your app is running.

00:11:55.830 --> 00:11:58.700
Finally, when you do need
to authenticate the user,

00:11:58.700 --> 00:12:01.730
you want to focus on the
fastest and easiest methods

00:12:01.730 --> 00:12:05.060
from the user's perspective.

00:12:05.060 --> 00:12:08.660
So the simplest way, from
a developer perspective,

00:12:08.660 --> 00:12:10.370
is the same as on the phone.

00:12:10.370 --> 00:12:13.060
You can create a login activity.

00:12:13.060 --> 00:12:17.160
And you can ask the user to type
in their username and password.

00:12:17.160 --> 00:12:19.440
Now this activity is
a normal activity,

00:12:19.440 --> 00:12:22.980
and if it has an input
field with the inputType

00:12:22.980 --> 00:12:28.490
textPassword, then Wear 2.0 will
show a special password style

00:12:28.490 --> 00:12:30.930
keyboard that will
allow the user to type

00:12:30.930 --> 00:12:32.780
in their password on the watch.

00:12:32.780 --> 00:12:36.390
Now, this keyboard is
optimized for the watch,

00:12:36.390 --> 00:12:38.510
but it is still
very small, so you

00:12:38.510 --> 00:12:42.470
should try to keep from having
to show that keyboard where

00:12:42.470 --> 00:12:43.450
you can.

00:12:43.450 --> 00:12:45.770
A couple of ways that you
can do that which are better

00:12:45.770 --> 00:12:49.690
and avoid that typing are to
use our sign in technologies,

00:12:49.690 --> 00:12:53.370
like Google Sign-in or
Smart Lock for Passwords.

00:12:53.370 --> 00:12:57.190
So both of those technologies
use the existing authentication

00:12:57.190 --> 00:12:59.500
that the user already
has to Google,

00:12:59.500 --> 00:13:01.700
and exchange that
for a token that's

00:13:01.700 --> 00:13:04.180
valid for your web service.

00:13:04.180 --> 00:13:06.530
Smart Lock for
Passwords, in particular,

00:13:06.530 --> 00:13:09.740
is very simple to add to
your existing client app.

00:13:09.740 --> 00:13:11.950
It only requires
client-side changes.

00:13:11.950 --> 00:13:14.030
And it works with
existing users,

00:13:14.030 --> 00:13:17.870
who've already registered using
whatever IDP they're using.

00:13:17.870 --> 00:13:20.150
So both of these options
will be available

00:13:20.150 --> 00:13:22.024
in some future
developer previews

00:13:22.024 --> 00:13:23.940
that we'll be releasing
throughout the summer.

00:13:23.940 --> 00:13:26.540
So please keep an eye on it.

00:13:26.540 --> 00:13:30.520
So if you're familiar with
writing Wear on the data layer,

00:13:30.520 --> 00:13:32.230
you might have already
thought of one way

00:13:32.230 --> 00:13:35.150
that you can get a
token over to the watch.

00:13:35.150 --> 00:13:37.860
That's to request that
token on the phone,

00:13:37.860 --> 00:13:41.740
and then pass it over to the
watch via the data layer.

00:13:41.740 --> 00:13:43.840
So this method
has some benefits.

00:13:43.840 --> 00:13:48.010
It's fast and easy for the user,
but it may have some problems

00:13:48.010 --> 00:13:51.290
if your off provider doesn't
like the fact that you're

00:13:51.290 --> 00:13:56.830
requesting a token for the watch
on the phone, so a token that's

00:13:56.830 --> 00:13:58.600
destined for a different device.

00:13:58.600 --> 00:14:01.510
It also does require the user
to have their phone with them

00:14:01.510 --> 00:14:04.600
and have it on and connected
when they're running your app.

00:14:04.600 --> 00:14:07.100
And finally, it
doesn't work on iOS.

00:14:07.100 --> 00:14:10.290
So if you do choose to use
this method in your app,

00:14:10.290 --> 00:14:12.770
make sure that you have
at least one backup method

00:14:12.770 --> 00:14:15.230
that does work.

00:14:15.230 --> 00:14:16.880
So one final method
that we'll also

00:14:16.880 --> 00:14:19.570
be bringing to a future
developer preview

00:14:19.570 --> 00:14:23.050
is the ability to open
an OAuth URL on a phone.

00:14:23.050 --> 00:14:26.660
So this OAuth URL points to
an OAuth 2.0 authentication

00:14:26.660 --> 00:14:27.570
service.

00:14:27.570 --> 00:14:30.080
The user will then
switch to their phone,

00:14:30.080 --> 00:14:32.890
follow through the
OAuth login flow.

00:14:32.890 --> 00:14:35.300
And then when they
complete, the auth service

00:14:35.300 --> 00:14:38.190
will return a token destined
for the wearable, which

00:14:38.190 --> 00:14:40.250
is sent via a call
back to the same call

00:14:40.250 --> 00:14:42.290
that you used to open that URL.

00:14:42.290 --> 00:14:46.060
So this option will
work on iOS, but it

00:14:46.060 --> 00:14:48.810
does require the user to have
their phone with them when

00:14:48.810 --> 00:14:51.370
they need to log in.

00:14:51.370 --> 00:14:52.900
So there are a lot
of options here.

00:14:52.900 --> 00:14:56.520
So here's a quick table
showing some of the tradeoffs.

00:14:56.520 --> 00:15:00.830
As you can see, Google Sign-in
and Smart Lock for Passwords

00:15:00.830 --> 00:15:03.990
both work if the watch is
connected or disconnected

00:15:03.990 --> 00:15:06.500
from the phone, and they
work on iOS and Android,

00:15:06.500 --> 00:15:08.550
and they're fast and
easy for the user.

00:15:08.550 --> 00:15:10.780
The middle two options
both require the user

00:15:10.780 --> 00:15:12.400
to have their phone with them.

00:15:12.400 --> 00:15:15.710
And the final option is
a good fallback option

00:15:15.710 --> 00:15:17.270
if all else fails.

00:15:17.270 --> 00:15:19.220
If you follow along
with the previews,

00:15:19.220 --> 00:15:22.511
we'll be sharing these methods
throughout the preview cycle.

00:15:22.511 --> 00:15:24.010
And that will help
you to build apps

00:15:24.010 --> 00:15:26.742
that are as fast and easy
to log onto as possible.

00:15:30.882 --> 00:15:33.340
GRIFF HAZEN: A third area of
focus for standalone Wear apps

00:15:33.340 --> 00:15:35.990
is how to retrieve
notification from the cloud,

00:15:35.990 --> 00:15:38.550
either for display to
the user or as data

00:15:38.550 --> 00:15:41.060
for your wearable app to use.

00:15:41.060 --> 00:15:42.800
Google Cloud
Messaging, now known

00:15:42.800 --> 00:15:47.380
as Firebase Cloud Messaging or
FCM, is now supported by Wear.

00:15:47.380 --> 00:15:51.020
FCM allows you to push data
and notifications directly

00:15:51.020 --> 00:15:53.970
to Wear devices from the cloud.

00:15:53.970 --> 00:15:57.390
Example uses include delivering
sync tickles, small data

00:15:57.390 --> 00:16:00.250
payloads, and user
visible notification.

00:16:00.250 --> 00:16:03.380
It works well with Doze
and is cross-platform.

00:16:03.380 --> 00:16:05.870
The same reasons to use
the service on phones

00:16:05.870 --> 00:16:08.370
apply to standalone Wear apps.

00:16:08.370 --> 00:16:12.400
It's the recommended way
to push events to watches.

00:16:12.400 --> 00:16:15.010
To send messages
using FCM, first

00:16:15.010 --> 00:16:18.080
collect your registration token
when your wearable app runs,

00:16:18.080 --> 00:16:20.040
and include it as
a destination when

00:16:20.040 --> 00:16:24.400
posting messages to the FCM
rest endpoint from your server.

00:16:24.400 --> 00:16:28.310
Those messages will then be
delivered to that device.

00:16:28.310 --> 00:16:31.460
FCM messages can include
two types of payloads.

00:16:31.460 --> 00:16:33.010
Here's an example
of a JSON formatted

00:16:33.010 --> 00:16:36.030
a message that will deliver
a user-visible notification

00:16:36.030 --> 00:16:39.900
directly to the stream when
received by a Wear device.

00:16:39.900 --> 00:16:41.840
When the user taps
this notification,

00:16:41.840 --> 00:16:44.920
your app is launched.

00:16:44.920 --> 00:16:46.690
The second type of
payload is a data

00:16:46.690 --> 00:16:49.922
payload with a set of
custom key value pairs.

00:16:49.922 --> 00:16:51.880
You can include both of
these types of payloads

00:16:51.880 --> 00:16:55.360
in the same message, as well.

00:16:55.360 --> 00:16:58.680
Where FCM is for notifications
from cloud to device,

00:16:58.680 --> 00:17:01.910
we'll now talk a little bit
about Android Notifications.

00:17:01.910 --> 00:17:04.410
One of the most useful
features of a Wear device

00:17:04.410 --> 00:17:07.140
is the ability to see your
phone notifications bridged

00:17:07.140 --> 00:17:08.550
to the wrist.

00:17:08.550 --> 00:17:11.500
With standalone Wear
apps, both phone and watch

00:17:11.500 --> 00:17:13.380
may receive a
similar cloud event

00:17:13.380 --> 00:17:15.950
and decide independently
to display a notification

00:17:15.950 --> 00:17:17.540
for that content.

00:17:17.540 --> 00:17:19.849
This may result in
duplicate notifications

00:17:19.849 --> 00:17:21.220
showing in the stream.

00:17:21.220 --> 00:17:23.329
One for the Wear-side
notification and one

00:17:23.329 --> 00:17:26.930
for the phone-side notification.

00:17:26.930 --> 00:17:29.900
You can stop a notification
from bridging phone-side

00:17:29.900 --> 00:17:33.260
using the setLocal.only API,
but that would also prevent it

00:17:33.260 --> 00:17:35.370
from displaying on Wear
devices that don't have

00:17:35.370 --> 00:17:37.480
your wearable app installed.

00:17:37.480 --> 00:17:39.960
Therefore, we're
introducing a new API

00:17:39.960 --> 00:17:43.160
to disable notification bridging
only when the Wear app is

00:17:43.160 --> 00:17:44.870
installed on the device.

00:17:44.870 --> 00:17:47.240
By adding the notification
bridge mode metadata

00:17:47.240 --> 00:17:49.690
element to your
Wear app's manifest

00:17:49.690 --> 00:17:52.600
and setting it to no
bridging, phone notifications

00:17:52.600 --> 00:17:54.100
will be ignored
and not displayed

00:17:54.100 --> 00:17:58.360
in the watch when
your app is present.

00:17:58.360 --> 00:18:01.800
Another API we're adding for
end notifications is the ability

00:18:01.800 --> 00:18:05.330
to link a phone-side and
the Wear-side notification

00:18:05.330 --> 00:18:08.390
together, so they
dismiss at the same time,

00:18:08.390 --> 00:18:10.780
even if they were
posted independently.

00:18:10.780 --> 00:18:14.820
This is useful if the content
is for the same topic.

00:18:14.820 --> 00:18:17.850
The new API,
setDismissalId, allows

00:18:17.850 --> 00:18:20.470
you to tag notifications
on both watch and phone

00:18:20.470 --> 00:18:22.540
as dismissing together.

00:18:22.540 --> 00:18:25.270
This API is now available
in the Wearable Extender

00:18:25.270 --> 00:18:29.220
class in Android N's
Preview Support Library.

00:18:29.220 --> 00:18:31.050
You can see how to
add a dismissal ID

00:18:31.050 --> 00:18:34.300
string to a notification here.

00:18:34.300 --> 00:18:35.900
If you're add on
watch and phone each

00:18:35.900 --> 00:18:38.680
post a notification with
the same dismissal ID,

00:18:38.680 --> 00:18:40.484
and the user dismisses
either one of them,

00:18:40.484 --> 00:18:42.025
the other will
dismiss automatically.

00:18:44.940 --> 00:18:47.480
A fourth area of focus
for standalone Wear apps

00:18:47.480 --> 00:18:50.020
is how to get them
installed and distributed.

00:18:50.020 --> 00:18:54.190
And we have some exciting
changes coming in Wear 2.0.

00:18:54.190 --> 00:18:57.540
In Wear 2.0, Wear apps
are downloaded directly

00:18:57.540 --> 00:18:59.360
to devices from Play Store.

00:18:59.360 --> 00:19:02.930
You no longer need to bundle
them inside of your phone app.

00:19:02.930 --> 00:19:04.900
We are expanding the
multi-APK feature

00:19:04.900 --> 00:19:08.540
of Google Play Developer
Console to support Wear.

00:19:08.540 --> 00:19:12.232
Multi-APK allows you to
publish separate APKs

00:19:12.232 --> 00:19:13.940
for your application
for different device

00:19:13.940 --> 00:19:15.370
configurations.

00:19:15.370 --> 00:19:18.040
You'll now be able to
have one or more phone,

00:19:18.040 --> 00:19:21.330
tablet, Wear, or other APKs
in your Play Store listing

00:19:21.330 --> 00:19:23.020
at the same time.

00:19:23.020 --> 00:19:25.800
This change brings with
it a number of benefits,

00:19:25.800 --> 00:19:30.239
including smaller phone APKs,
a decoupled release process,

00:19:30.239 --> 00:19:31.780
where your phone
app and Wear app can

00:19:31.780 --> 00:19:34.750
be updated
independently, support

00:19:34.750 --> 00:19:38.670
for per-application APKs, when
using the-- per-architecture

00:19:38.670 --> 00:19:42.990
APKs when using native
libraries, and more.

00:19:42.990 --> 00:19:45.980
To give you a taste for how
multi-APK support will work

00:19:45.980 --> 00:19:48.390
for Wear, here's an
Android manifest file

00:19:48.390 --> 00:19:50.630
for a typical wearable app.

00:19:50.630 --> 00:19:52.430
It includes a
uses-feature element

00:19:52.430 --> 00:19:54.420
set to hardware type watch.

00:19:54.420 --> 00:19:56.360
Because of this
feature restrict,

00:19:56.360 --> 00:19:59.500
APKs built from this manifest
will target only Wear devices

00:19:59.500 --> 00:20:00.990
in Google Play.

00:20:00.990 --> 00:20:04.340
Similarly, APKs built
without this restrict

00:20:04.340 --> 00:20:06.660
will not target Wear devices.

00:20:06.660 --> 00:20:08.420
Wear device targeting
can be combined

00:20:08.420 --> 00:20:12.530
with other criteria, such as
SDK version, screen resolution,

00:20:12.530 --> 00:20:14.890
and CPU architecture.

00:20:14.890 --> 00:20:16.660
Let's walk through
an example of how

00:20:16.660 --> 00:20:20.810
this may work in Google
Play Developer Console.

00:20:20.810 --> 00:20:23.510
Say you've built both a
phone APK and a wearable APK

00:20:23.510 --> 00:20:26.180
for your application
in Android Studio.

00:20:26.180 --> 00:20:28.180
You then go to the Google
Play Developer Console

00:20:28.180 --> 00:20:31.017
to upload both of
them, one at a time.

00:20:31.017 --> 00:20:32.850
You'll need to select
Advanced Mode in order

00:20:32.850 --> 00:20:38.630
to have more than one APK
in your application at once.

00:20:38.630 --> 00:20:41.260
After uploading the
wearable APK first,

00:20:41.260 --> 00:20:43.600
we'd expect the list
of Supported Devices

00:20:43.600 --> 00:20:48.010
for this application to
be just watch devices.

00:20:48.010 --> 00:20:50.540
And by clicking the
Supported Devices link,

00:20:50.540 --> 00:20:54.730
you'd be able to verify that
only watch devices are shown.

00:20:54.730 --> 00:20:59.090
Now you upload the phone
APK to Developer Console.

00:20:59.090 --> 00:21:00.930
The set of Supported
Devices for this app

00:21:00.930 --> 00:21:05.560
has now increased to over
2000 and includes phones.

00:21:05.560 --> 00:21:08.200
You'll also notice, at
the bottom of the screen,

00:21:08.200 --> 00:21:12.570
there are two APKs listed: one
for watch and one for phone.

00:21:12.570 --> 00:21:16.470
The watch entry shows the
feature restrict being present.

00:21:16.470 --> 00:21:19.630
Multi-APK a support requires
that you use a unique version

00:21:19.630 --> 00:21:22.270
code for each upload APK.

00:21:22.270 --> 00:21:24.520
In this example,
the wearable APK

00:21:24.520 --> 00:21:26.620
was set to version code
two, while the phone

00:21:26.620 --> 00:21:30.860
APK used version code one.

00:21:30.860 --> 00:21:33.780
Since Wear 1.0, Android
Studio and Gradle

00:21:33.780 --> 00:21:36.640
have provided a very simple
way to automatically bundle

00:21:36.640 --> 00:21:41.130
Wear APKs inside of
phone APKs, as shown.

00:21:41.130 --> 00:21:44.510
You can turn this bundling
off by removing the Wear app

00:21:44.510 --> 00:21:46.140
project dependency
from your phone apps

00:21:46.140 --> 00:21:50.710
Gradle file while
testing standalone apps.

00:21:50.710 --> 00:21:53.825
Multi-APK support for
Wear 2.0 is coming soon,

00:21:53.825 --> 00:21:55.200
and we'll have
more announcements

00:21:55.200 --> 00:21:56.620
on this over the summer.

00:21:56.620 --> 00:21:59.730
For now, simply sideload
your application,

00:21:59.730 --> 00:22:01.550
your standalone
Wear app, directly

00:22:01.550 --> 00:22:03.650
to your device for testing.

00:22:03.650 --> 00:22:07.520
Now I'll hand it over to Kenny
to show you a couple examples.

00:22:07.520 --> 00:22:08.340
KENNY STOLTZ: OK.

00:22:08.340 --> 00:22:11.160
So let's put together
all the principles

00:22:11.160 --> 00:22:13.170
that we just talked
about and see

00:22:13.170 --> 00:22:16.140
what it will be like to make
standalone apps in Wear 2.0.

00:22:16.140 --> 00:22:18.110
We'll start with a chat app.

00:22:18.110 --> 00:22:18.620
And

00:22:18.620 --> 00:22:20.810
For this example, I'll
assume a couple of things.

00:22:20.810 --> 00:22:24.130
I'll assume that you've already
got an existing Android phone

00:22:24.130 --> 00:22:25.030
app.

00:22:25.030 --> 00:22:28.510
You are at production
quality, and you're public,

00:22:28.510 --> 00:22:31.630
and you have a
fairly big user base.

00:22:31.630 --> 00:22:32.300
OK.

00:22:32.300 --> 00:22:36.324
So going from the top, key
use cases are pretty obvious.

00:22:36.324 --> 00:22:38.240
The key use cases are
going to be sent a chat,

00:22:38.240 --> 00:22:40.680
receive a chat, basically.

00:22:40.680 --> 00:22:43.780
So that's going to require a
bunch of different activities:

00:22:43.780 --> 00:22:46.430
log in, list of friends,
chat settings, etc.

00:22:46.430 --> 00:22:49.590
But because we're really trying
to streamline interactions,

00:22:49.590 --> 00:22:53.220
you want to make sure that
every UI that you build

00:22:53.220 --> 00:22:56.671
is in service of
those key use cases.

00:22:56.671 --> 00:22:57.170
OK.

00:22:57.170 --> 00:22:59.560
So now let's talk about how
we're going to build it.

00:22:59.560 --> 00:23:03.270
We've already got a phone
project in Android Studio.

00:23:03.270 --> 00:23:06.490
So we're going to create a
second flavor of our build.

00:23:06.490 --> 00:23:09.340
So this new flavor is going
to be our wearable build.

00:23:09.340 --> 00:23:12.250
And it will start out
the same as the phone.

00:23:12.250 --> 00:23:16.940
But we'll factor out the shared
code between the two builds.

00:23:16.940 --> 00:23:20.355
And we'll build a shared library
that both of those will use.

00:23:20.355 --> 00:23:21.730
So the first thing
that we'll put

00:23:21.730 --> 00:23:25.920
into that will be our entire
REST client service that we had

00:23:25.920 --> 00:23:28.270
built for the phone, so that
both are wearable and phone

00:23:28.270 --> 00:23:31.830
are now able to
talk to the cloud.

00:23:31.830 --> 00:23:33.740
So on top of that
REST client, we're

00:23:33.740 --> 00:23:35.570
going to build some activities.

00:23:35.570 --> 00:23:39.160
Now, we're going to use
material design for Wear

00:23:39.160 --> 00:23:41.110
and I'll just hand
wave through that,

00:23:41.110 --> 00:23:43.050
because the next
talk in this room,

00:23:43.050 --> 00:23:46.830
at 3:00, is about
material design for Wear.

00:23:46.830 --> 00:23:51.140
So now we have a wearable app
that uses those material design

00:23:51.140 --> 00:23:54.800
principles and can talk to
a web service on the watch.

00:23:54.800 --> 00:23:59.150
So we're already pretty far
along in building an app.

00:23:59.150 --> 00:24:02.480
But this app is not always
going to be in the foreground.

00:24:02.480 --> 00:24:05.480
Messaging is really
driven by notifications.

00:24:05.480 --> 00:24:08.290
So the next thing that we're
going to add to our app

00:24:08.290 --> 00:24:11.800
is we're going to
register it for FCM.

00:24:11.800 --> 00:24:14.090
So once we register
for the FCM, we're

00:24:14.090 --> 00:24:16.530
going to start
getting pings from FCM

00:24:16.530 --> 00:24:19.330
whenever we need to
show a notification.

00:24:19.330 --> 00:24:21.370
Because we're now
getting pings, we'll

00:24:21.370 --> 00:24:23.790
disable bridging
so that we don't

00:24:23.790 --> 00:24:27.960
get bridge notifications from
the phone at the same time.

00:24:27.960 --> 00:24:30.200
When we show a
notification, we'll

00:24:30.200 --> 00:24:34.050
use the new messaging style
for a notification, which

00:24:34.050 --> 00:24:37.660
will show a really nice
presentation for that message

00:24:37.660 --> 00:24:39.420
on the user's watch.

00:24:39.420 --> 00:24:42.660
Now when the user taps
that reply button,

00:24:42.660 --> 00:24:44.810
we'll use a content
intent, which

00:24:44.810 --> 00:24:47.720
will allow us to start
a reply activity that's

00:24:47.720 --> 00:24:52.950
custom-designed for our app
and meets our exact needs.

00:24:52.950 --> 00:24:53.450
OK.

00:24:53.450 --> 00:24:56.420
So we're going to have to
make this user sign in.

00:24:56.420 --> 00:24:59.110
There is no-- well, we could
make an anonymous chat,

00:24:59.110 --> 00:25:00.537
but we won't.

00:25:00.537 --> 00:25:03.120
That means we're going to start
with a basic sign-in activity.

00:25:03.120 --> 00:25:05.036
So we're going to have
a username and password

00:25:05.036 --> 00:25:06.460
as our two blank boxes.

00:25:06.460 --> 00:25:10.120
But then we're going to add
some fast sign-in features.

00:25:10.120 --> 00:25:13.015
So I'm going to assume here
that I already had an existing

00:25:13.015 --> 00:25:15.350
OAuth web service.

00:25:15.350 --> 00:25:17.450
And since I have
that, Smart Lock

00:25:17.450 --> 00:25:19.650
is a really good option,
because it integrates well

00:25:19.650 --> 00:25:21.930
with an existing auth service.

00:25:21.930 --> 00:25:24.610
Another option that I
can add is OAuth URL,

00:25:24.610 --> 00:25:28.520
which will allow me to log
in via a couple of changes

00:25:28.520 --> 00:25:32.690
that I'll have to
make to my web flow.

00:25:32.690 --> 00:25:34.650
So now let's start
thinking about how

00:25:34.650 --> 00:25:37.100
to make this app work
really well when you've

00:25:37.100 --> 00:25:38.500
got your phone.

00:25:38.500 --> 00:25:40.710
We're going to
coordinate dismissal

00:25:40.710 --> 00:25:45.220
by sending a notification ID
inside the FCM payload for each

00:25:45.220 --> 00:25:47.180
of our messages from FCM.

00:25:47.180 --> 00:25:48.930
And then we'll
add that dismissal

00:25:48.930 --> 00:25:51.770
ID-- sorry-- we'll add the
notification ID as a dismissal

00:25:51.770 --> 00:25:55.690
ID to both the phone and
the watch notifications.

00:25:55.690 --> 00:25:58.020
So then, when I swipe away
a notification on one,

00:25:58.020 --> 00:26:00.650
it will swipe away on both.

00:26:00.650 --> 00:26:04.070
So now we have a great
wearable chat app.

00:26:04.070 --> 00:26:06.410
It works well with the phone.

00:26:06.410 --> 00:26:09.410
But we really need to
test it on all the watches

00:26:09.410 --> 00:26:10.900
we can get our
hands on connected

00:26:10.900 --> 00:26:12.870
to both types of device.

00:26:12.870 --> 00:26:15.800
You really have to make sure
that your app is working well

00:26:15.800 --> 00:26:19.186
on both Android and
iOS connected watches.

00:26:19.186 --> 00:26:20.810
And then the next
thing that you really

00:26:20.810 --> 00:26:23.090
want to do when you
have an existing app is

00:26:23.090 --> 00:26:25.610
to profile your REST services.

00:26:25.610 --> 00:26:28.070
So probably in this app,
what we're looking for

00:26:28.070 --> 00:26:31.342
is data that's not being
used on the wearable.

00:26:31.342 --> 00:26:33.050
And there are a couple
of options we have

00:26:33.050 --> 00:26:35.310
if we find big chunks of
data that aren't actually

00:26:35.310 --> 00:26:36.650
being shown to the user.

00:26:36.650 --> 00:26:39.030
One is that we can cut it
out entirely if it's not

00:26:39.030 --> 00:26:40.850
being used on the phone either.

00:26:40.850 --> 00:26:44.450
Or we can make new
requests and responses

00:26:44.450 --> 00:26:47.440
that are specific
to the wearable app.

00:26:47.440 --> 00:26:49.140
So sort of cutting
out that data,

00:26:49.140 --> 00:26:52.890
and only showing the wearable
what it needs to know

00:26:52.890 --> 00:26:56.620
When we're ready to distribute,
make an unbundled wearable APK,

00:26:56.620 --> 00:27:01.390
set up the manifest as Griff
described and upload to Play.

00:27:01.390 --> 00:27:04.130
So now we've built a
pretty easy chat app

00:27:04.130 --> 00:27:09.910
based on our existing phone app,
and it works great in Wear 2.0.

00:27:09.910 --> 00:27:10.870
OK.

00:27:10.870 --> 00:27:14.560
Go to another example
now-- a fitness app.

00:27:14.560 --> 00:27:18.070
So everybody has their favorite
running and cycling app.

00:27:18.070 --> 00:27:20.680
And those are all
pretty horizontal.

00:27:20.680 --> 00:27:24.930
So a new idea might
be to go vertical.

00:27:24.930 --> 00:27:27.660
So I'm going to make
rock climbing app.

00:27:27.660 --> 00:27:30.610
And this is a new idea, so
we'll start from scratch,

00:27:30.610 --> 00:27:34.200
with no existing phone app,
no existing web service.

00:27:34.200 --> 00:27:36.140
So since we're
starting from scratch,

00:27:36.140 --> 00:27:38.000
we'll really be thinking
about the wearable

00:27:38.000 --> 00:27:40.260
first, how people are
going to use a wearable

00:27:40.260 --> 00:27:42.230
to track climbing, what
kind of information

00:27:42.230 --> 00:27:45.780
they might want to
see on their watch.

00:27:45.780 --> 00:27:50.310
So I'm going to assume here that
there is some black box sensor

00:27:50.310 --> 00:27:53.400
magic that somebody is
going to build in order

00:27:53.400 --> 00:27:56.020
to make this work,
because I'm a PM,

00:27:56.020 --> 00:27:58.100
and that means that
I don't have to code.

00:27:58.100 --> 00:28:01.600
So thank you, engineers.

00:28:01.600 --> 00:28:04.220
But what we do want to
make sure is happening

00:28:04.220 --> 00:28:08.040
is that, when we're
processing sensor data,

00:28:08.040 --> 00:28:11.320
that were as battery-efficient
as we possibly can be.

00:28:11.320 --> 00:28:13.740
Because whenever
you're processing data,

00:28:13.740 --> 00:28:17.616
the processor has to stay awake,
and that is burning battery.

00:28:17.616 --> 00:28:19.240
So what we really
don't want to have is

00:28:19.240 --> 00:28:21.580
the user gets halfway
up that rock wall,

00:28:21.580 --> 00:28:23.550
and then their watch dies.

00:28:23.550 --> 00:28:25.800
So once we process
all the data, we're

00:28:25.800 --> 00:28:28.230
going to store it locally
in a SQLite database,

00:28:28.230 --> 00:28:33.860
in case the user isn't currently
connected to the network.

00:28:33.860 --> 00:28:36.140
Now, we're going to
build some new activities

00:28:36.140 --> 00:28:38.160
with material design for Wear.

00:28:38.160 --> 00:28:41.310
We're going to support
Always On, which is something

00:28:41.310 --> 00:28:44.160
that we release last year
and allows apps to keep

00:28:44.160 --> 00:28:46.770
running in the foreground
when the watch goes

00:28:46.770 --> 00:28:48.490
into ambient mode.

00:28:48.490 --> 00:28:50.300
So if you want to find
out more about that,

00:28:50.300 --> 00:28:52.770
you can to still check
out last year's talk

00:28:52.770 --> 00:28:55.970
on YouTube about Always On
apps, and those principles

00:28:55.970 --> 00:28:58.540
will still work in Wear 2.0.

00:28:58.540 --> 00:29:01.640
So at this point, we
have a wearable app

00:29:01.640 --> 00:29:06.800
that's storing data locally, and
it's a cool app for climbers.

00:29:06.800 --> 00:29:08.680
What we might want to
do next with the app

00:29:08.680 --> 00:29:10.570
is start storing
that data in Fit.

00:29:10.570 --> 00:29:12.790
Now, Fit can give us a
lot of interesting stuff.

00:29:12.790 --> 00:29:15.274
We can get biometric
data from the user,

00:29:15.274 --> 00:29:16.690
like their height
and their weight

00:29:16.690 --> 00:29:18.470
and other data that
they've entered.

00:29:18.470 --> 00:29:21.520
And we can also write
into the Fit platform,

00:29:21.520 --> 00:29:23.820
our rock climbing
sessions, so that the user

00:29:23.820 --> 00:29:26.220
can see all of their
fitness data in one place.

00:29:26.220 --> 00:29:29.230
And I can verify that
Fit has an activity

00:29:29.230 --> 00:29:30.360
type for rock climbing.

00:29:30.360 --> 00:29:34.350
So we're already
halfway there, easily.

00:29:34.350 --> 00:29:39.070
So far, our app is a
generic, anonymous app,

00:29:39.070 --> 00:29:41.980
but if you're not a
generic lumberjack,

00:29:41.980 --> 00:29:45.180
and you're a climber Jane,
you want the user to log in,

00:29:45.180 --> 00:29:47.300
so that you'll be
able to identify

00:29:47.300 --> 00:29:51.490
that user in the future, and
also bring that user online

00:29:51.490 --> 00:29:53.220
onto the cloud.

00:29:53.220 --> 00:29:56.270
So our app can offer
a good amount of value

00:29:56.270 --> 00:29:59.760
without a login, so we're
going to make login optional,

00:29:59.760 --> 00:30:03.500
and defer it to when the
user wants to log in.

00:30:03.500 --> 00:30:06.020
And when we do ask
the user to log in,

00:30:06.020 --> 00:30:09.720
we use fast sign-in flows,
such as Google Sign-in, which

00:30:09.720 --> 00:30:12.020
is easy because, if I'm
starting out from scratch,

00:30:12.020 --> 00:30:13.860
I don't have an auth
service, I probably

00:30:13.860 --> 00:30:16.110
don't want to deal with all the
requirements of figuring out

00:30:16.110 --> 00:30:17.193
how to do an auth service.

00:30:17.193 --> 00:30:20.731
So I can just let Google
do that hard work.

00:30:20.731 --> 00:30:21.230
OK.

00:30:21.230 --> 00:30:22.910
So now we're logged in.

00:30:22.910 --> 00:30:26.140
That means that we can
write data to the cloud.

00:30:26.140 --> 00:30:27.790
What you want to
remember here is

00:30:27.790 --> 00:30:31.030
that, although watches
can run standalone apps,

00:30:31.030 --> 00:30:32.861
not every watch
has cellular, which

00:30:32.861 --> 00:30:35.110
means that not every watch
is going to be continuously

00:30:35.110 --> 00:30:37.070
connected to the cloud.

00:30:37.070 --> 00:30:39.750
So whenever you're writing
data to those two sources

00:30:39.750 --> 00:30:43.440
locally and remotely, you
want to think about a sync.

00:30:43.440 --> 00:30:45.570
So you want to make sure
that they're eventually

00:30:45.570 --> 00:30:49.640
consistent on both the
local store and the cloud.

00:30:49.640 --> 00:30:52.552
So this diagram is
getting pretty busy here.

00:30:52.552 --> 00:30:54.385
But let's say we want
to throw the phone in.

00:30:54.385 --> 00:30:57.070
And how do we tie the
phone into the party?

00:30:57.070 --> 00:30:57.870
OK.

00:30:57.870 --> 00:31:01.830
Now, I think there's a
pretty easy first step.

00:31:01.830 --> 00:31:04.025
This is, again, my
PM speak-- I think

00:31:04.025 --> 00:31:06.400
there's a pretty easy first
step, which is basically just

00:31:06.400 --> 00:31:08.575
to do everything that we
just did on the wearable,

00:31:08.575 --> 00:31:10.700
but now, since the wearable's
writing all this data

00:31:10.700 --> 00:31:12.509
to the cloud, we
just need to write

00:31:12.509 --> 00:31:15.050
the same thing on the left on
the right, and then we're done.

00:31:15.050 --> 00:31:15.549
Right?

00:31:15.549 --> 00:31:18.960
We have a phone app that can
now read and-- see everything

00:31:18.960 --> 00:31:20.580
that happened on the wearable.

00:31:20.580 --> 00:31:23.420
But what would be
even cooler is if I

00:31:23.420 --> 00:31:28.530
could hand my phone to my
belayer while I'm on the wall,

00:31:28.530 --> 00:31:32.380
and my phone could stream
real time data from my watch

00:31:32.380 --> 00:31:34.890
down to my phone, and my
belayer could be checking out

00:31:34.890 --> 00:31:36.870
how my progress is going.

00:31:36.870 --> 00:31:40.479
So if I wanted to do that, I
would use the Data Layer APIs,

00:31:40.479 --> 00:31:42.520
and particularly here,
probably the messaging API

00:31:42.520 --> 00:31:46.650
is a good choice, because
it's very low latency.

00:31:46.650 --> 00:31:47.150
OK.

00:31:47.150 --> 00:31:49.450
So as before, test.

00:31:49.450 --> 00:31:54.680
Test on iOS, test on Android,
profile-- so there's probably

00:31:54.680 --> 00:31:56.580
less to do on the web
services side here,

00:31:56.580 --> 00:31:58.330
since we're sort of
starting from scratch.

00:31:58.330 --> 00:31:59.788
There's probably
not a lot of cruft

00:31:59.788 --> 00:32:01.077
sitting in the web services.

00:32:01.077 --> 00:32:02.660
But where you would
want to focus here

00:32:02.660 --> 00:32:05.510
is on how much processor
that you're using.

00:32:05.510 --> 00:32:07.080
So make sure that
you're not going

00:32:07.080 --> 00:32:09.660
to leave the
hanging-- oh, well--

00:32:09.660 --> 00:32:12.670
that's the first time
I tried that joke.

00:32:12.670 --> 00:32:15.470
Last, we'll set up
an unbundled APK

00:32:15.470 --> 00:32:19.730
and upload it the Play
Developer Console as before.

00:32:19.730 --> 00:32:21.530
So those are just
two examples of how

00:32:21.530 --> 00:32:26.180
you'll now start to build
standalone apps in Wear 2.0.

00:32:26.180 --> 00:32:29.850
So just to recap--
three easy things

00:32:29.850 --> 00:32:33.150
to remember about why you
want to build standalone apps.

00:32:33.150 --> 00:32:36.870
So first of all, standalone
is phone-independent.

00:32:36.870 --> 00:32:39.450
It allows you to free
yourself in any situation

00:32:39.450 --> 00:32:41.890
during the day from
the phone and still

00:32:41.890 --> 00:32:44.550
be able to use those
apps on your wrist.

00:32:44.550 --> 00:32:47.622
Next up, standalone apps
are built like phone apps.

00:32:47.622 --> 00:32:49.080
So they use phone
app architecture.

00:32:49.080 --> 00:32:51.820
And all of those skills that
you've learned and honed

00:32:51.820 --> 00:32:54.690
apply to the wearable apps
that you're going to build.

00:32:54.690 --> 00:32:58.150
And finally, standalone apps
work with both Android and iOS

00:32:58.150 --> 00:32:58.650
phones.

00:33:02.967 --> 00:33:05.300
GRIFF HAZEN: If you like what
you heard today, and can't

00:33:05.300 --> 00:33:07.200
wait to try it out, you can.

00:33:07.200 --> 00:33:10.170
Just go to g.co/wearpreview.

00:33:10.170 --> 00:33:13.380
You can find out about how to
get the preview SDK, device

00:33:13.380 --> 00:33:15.970
images, and more information
about the new APIs we're

00:33:15.970 --> 00:33:18.010
launching.

00:33:18.010 --> 00:33:19.746
In addition to the
developer preview,

00:33:19.746 --> 00:33:21.120
we also have a
few other sessions

00:33:21.120 --> 00:33:22.440
that you should check out.

00:33:22.440 --> 00:33:24.110
The next session
in this very room

00:33:24.110 --> 00:33:27.940
is about how to build Wear
2.0 apps with material design.

00:33:27.940 --> 00:33:31.737
You can also catch up on YouTube
if you've missed anything.

00:33:31.737 --> 00:33:34.070
One of the main reasons we
are doing a developer preview

00:33:34.070 --> 00:33:35.070
is to get your feedback.

00:33:35.070 --> 00:33:37.710
So if you have any bugs
or API suggestions,

00:33:37.710 --> 00:33:40.870
please g.co/wearpreviewbug.

00:33:40.870 --> 00:33:44.052
We also have an Android Wear
Developers Google+ Community,

00:33:44.052 --> 00:33:46.240
where you can discuss
with your peers.

00:33:46.240 --> 00:33:49.960
The URL is g.com/androidweardev.

00:33:49.960 --> 00:33:52.600
And with that, let's go to Q&amp;A.

00:33:52.600 --> 00:33:56.250
[MUSIC PLAYING]

