WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:09.870
&gt;&gt; BRAY: Welcome to the last of the Android
presentations for Google Developer Day 2010

00:00:09.870 --> 00:00:14.990
in Brazil. So this is the last time I'll speak
to you until next year, unless you come and

00:00:14.990 --> 00:00:23.080
join us for a beer afterwards. Today, we are
going to talk about high-performance Android

00:00:23.080 --> 00:00:29.900
apps. As I mentioned during my last talk,
the performance of an Android application

00:00:29.900 --> 00:00:40.030
is very, very important to the quality of
the user experience. And that's good but unfortunately

00:00:40.030 --> 00:00:45.420
you can't always make things happen fast.
To start with, you know, Android phones are

00:00:45.420 --> 00:00:53.289
computers but they're kind of slow computers.
And furthermore, Android phones are most interesting

00:00:53.289 --> 00:00:57.360
when they are doing things that are in contact
with the Net. And of course, whenever you

00:00:57.360 --> 00:01:01.969
are doing something that involves the Net
you are running at the speed of the Net. So,

00:01:01.969 --> 00:01:06.750
first of all, you have to make the user's
experience very fast. And secondly, you are

00:01:06.750 --> 00:01:12.140
running on a slow computer that's talking
to the Net. So clearly, you have some conflicts

00:01:12.140 --> 00:01:17.760
there. So we're going to talk about two things.
You know, how do you make this thing run fast?

00:01:17.760 --> 00:01:21.790
But even more important, when you have to
do something that's slow, how do you keep

00:01:21.790 --> 00:01:28.360
the user's life good, okay? Now, this presentation
should have a little bit of time for questions

00:01:28.360 --> 00:01:33.560
at the end but we're starting late so--oh,
well. So, when you listen to the Google engineers,

00:01:33.560 --> 00:01:38.530
and particularly the Chrome team talk, they
have this word called "jank" that they invented.

00:01:38.530 --> 00:01:42.820
And jank is when it doesn't quite run--keep
up with your finger when you're moving on

00:01:42.820 --> 00:01:49.100
the screen. And when something feels slow
they'll say, "Well, that's a janky app." And

00:01:49.100 --> 00:01:54.990
you really have to work hard to avoid this
because users are very sensitive to applications

00:01:54.990 --> 00:01:59.719
that aren't responsive to them. And so what
that means is you have to get out of the way

00:01:59.719 --> 00:02:05.430
of the user Intervoice base code and let it
do its job. And if you don't do that, bad

00:02:05.430 --> 00:02:10.799
things happen. In particular on Android, every
application has a special thread that is concerned

00:02:10.799 --> 00:02:17.840
with doing the UI of the application. This
is unfortunately called the "main thread"

00:02:17.840 --> 00:02:22.370
and it creates the erroneous expectation from
some people that they should do some--their

00:02:22.370 --> 00:02:26.150
main work on the main thread. Well, they shouldn't.
That thread belongs to the UI and they should

00:02:26.150 --> 00:02:32.650
get out of the way. And if you do the wrong
thing, this will happen to you. Users hate

00:02:32.650 --> 00:02:40.489
this. You should hate this, too. In the developer
relations group at Android at Google, we get

00:02:40.489 --> 00:02:45.180
a lot of applications for review. And we get
them for review because they come from important

00:02:45.180 --> 00:02:50.050
partners or because we hear good things about
them and especially because we are looking

00:02:50.050 --> 00:02:56.430
for good applications to feature in Android
market. And if an--if we evaluate an application

00:02:56.430 --> 00:03:04.879
and this happens once, that application is
gone. It's just not interesting. It's an unacceptable

00:03:04.879 --> 00:03:14.370
situation. So, why does that happen? Basically,
when you tap on the screen and the system

00:03:14.370 --> 00:03:23.680
calls your application and it doesn't return
in five seconds, you're dead. If you have

00:03:23.680 --> 00:03:31.549
a broadcast receiver that gets an event and
it doesn't finish in 10 seconds, you're dead.

00:03:31.549 --> 00:03:36.330
And when that happens, it doesn't just stop
you, it destroys your task, clears you from

00:03:36.330 --> 00:03:42.170
memory, finishes you off; you're really dead.
So the computers are really, you know, a billion--it's

00:03:42.170 --> 00:03:46.091
a gigahertz processor in there so really,
you shouldn't really have to do anything,

00:03:46.091 --> 00:03:50.379
while the user is waiting, that will take
five or ten seconds. But, you know, it's actually

00:03:50.379 --> 00:03:56.209
much worse than that because users complain
about delays that are much shorter than five

00:03:56.209 --> 00:04:03.239
seconds. So, let's give you some numbers here
and the context is--the red text at the top

00:04:03.239 --> 00:04:07.850
is very important. For video to look really
good, you know, 60 frames a second, so each

00:04:07.850 --> 00:04:14.280
frame is 16 mega--milliseconds. So if you
are computing your video frames, you have

00:04:14.280 --> 00:04:20.180
16 milliseconds, no longer, to compute each
frame. And if you actually measure people

00:04:20.180 --> 00:04:25.570
and find out, you know, how short a delay
can they measure, it's 100 to 200 milliseconds.

00:04:25.570 --> 00:04:29.970
So if it's over a fifth of a second delay
they will see it every time. If it's less

00:04:29.970 --> 00:04:36.000
than a tenth of a second possibly they won't
notice it, okay? So if you look at some of

00:04:36.000 --> 00:04:40.940
the--some--this is measured on a Nexus One,
which is still a pretty fast Android phone.

00:04:40.940 --> 00:04:46.230
So if you look at those first two bullet points,
it's obvious that sending interprocess messages

00:04:46.230 --> 00:04:50.850
back and forth is very fast, so you shouldn't
worry about that. If, you know, if you need

00:04:50.850 --> 00:04:55.320
to send a message to another process to get
it to do something and get it come back to

00:04:55.320 --> 00:05:01.560
you, that's safe, that's good practice. What
happens is as soon as you get into I/O, things

00:05:01.560 --> 00:05:10.040
start to hurt. So, just to read one byte off
the flash storage, 5 to 25 milliseconds. So,

00:05:10.040 --> 00:05:19.960
that means you can't even read one byte and
compute a frame of video. To write Flash,

00:05:19.960 --> 00:05:26.150
it's horrible. It, you know, can be between
5 and 200 milliseconds to write into the storage

00:05:26.150 --> 00:05:31.620
and it's variable. It varies according to
a bunch of things and it's complex and unpredictable.

00:05:31.620 --> 00:05:38.370
And if you want to send a simple ping over
a 3G network, you're really casting your fate

00:05:38.370 --> 00:05:42.620
out into the hands of luck. You know, it can
be anywhere from a tenth of a second to, you

00:05:42.620 --> 00:05:46.590
know, most of a second just to ping. And it
depends on how strong the signal is, it depends

00:05:46.590 --> 00:05:50.680
where you are, it depends how busy the network
is, it depends on all sorts of things that

00:05:50.680 --> 00:05:53.970
you don't control. So basically if you're
going to do anything over the network, you

00:05:53.970 --> 00:05:57.740
know, you're really, really looking for some
delay. And, of course, what is the thing that

00:05:57.740 --> 00:06:03.440
we do most often over the network? The most
single, most common thing we do is to go do

00:06:03.440 --> 00:06:09.729
an HTTP request to get something from a web
server. And, you know, it's really rare that,

00:06:09.729 --> 00:06:14.240
that executes in under one second. I mean,
if you happen to be going to Google to get

00:06:14.240 --> 00:06:19.290
the Google front page, you know, and you're
near an edge server, maybe. But typically

00:06:19.290 --> 00:06:26.050
you should count on the best part of 10 seconds,
you know, to just get a simple, you know,

00:06:26.050 --> 00:06:31.020
6K over 3G networking. It's a little better
if you're on Wi-Fi, but still, it's tough

00:06:31.020 --> 00:06:36.240
to see anything under one second, okay? So,
that's the bad news and it gets even worse.

00:06:36.240 --> 00:06:44.370
So, here is a little disk benchmark that--it
does much like a--similar to what happens

00:06:44.370 --> 00:06:50.610
when you update a SQLite database. So it creates
a file, writes half a K and deletes it and

00:06:50.610 --> 00:07:00.860
so on. And the flash storage that we have
on these devices is not like the hard disks

00:07:00.860 --> 00:07:07.449
that you are used to in your laptop computers
and your big servers. It--the performance

00:07:07.449 --> 00:07:11.990
depends on how full the disc is as you can
see from here. Weirdly enough, it also depends

00:07:11.990 --> 00:07:18.270
on how old the Flash storage is because it
gets slower as it gets older. It get--it depends

00:07:18.270 --> 00:07:25.620
on a bunch of other factors that you just
don't control. So, you really have very little

00:07:25.620 --> 00:07:31.660
way to predict how long writing data to persistent
storage is. Now, it turns out that in Google

00:07:31.660 --> 00:07:39.520
up through Froyo--I'm sorry, Android up through
Froyo, we're using the yaffs file system which

00:07:39.520 --> 00:07:45.160
has some advantages and some other disadvantages.
And we're doing actually a lot of work to

00:07:45.160 --> 00:07:50.800
improve this in future releases of Android
but still, it's, you know, this is not high-performance

00:07:50.800 --> 00:08:00.840
storage and you just have to deal with that.
And many people who do any kind of storage

00:08:00.840 --> 00:08:08.430
operations in their applications use SQLite
to store all their data. And that's fine.

00:08:08.430 --> 00:08:14.490
Except for just like any relational database,
any time you update it, that's expensive.

00:08:14.490 --> 00:08:18.650
And it's very similar to the situation you
find in your relational databases in your

00:08:18.650 --> 00:08:23.509
big business applications, retrieving data
from the database can be slow so you can put

00:08:23.509 --> 00:08:27.080
an index in there and that will make it very
fast. But then, that--when you update it,

00:08:27.080 --> 00:08:30.880
it has to update the index and that's slow.
So it's a tradeoff between read performance

00:08:30.880 --> 00:08:36.950
and write performance, it's the same old one.
And you got to watch out because sometimes

00:08:36.950 --> 00:08:43.050
the most amazingly simple-looking SQLite queries
can actually lead to a lot of complicated

00:08:43.050 --> 00:08:47.670
work. So, SQLite has a thing where you can
say, Explain--what's it called, Explain and

00:08:47.670 --> 00:08:52.019
Explain Query Plan. So, you can give a query
and SQLite will tell you how it plans to execute

00:08:52.019 --> 00:08:57.800
it and you can--I advice doing that, you know,
especially if you're having performance problems,

00:08:57.800 --> 00:09:02.670
have a check and see what SQL's really doing.
Now, one thing we see a lot of that is a really

00:09:02.670 --> 00:09:09.100
bad idea is many, many applications keep log
files. And if we see a lot of people putting

00:09:09.100 --> 00:09:16.120
a log file in a SQLite database, and that's
really expensive and there's no good reason

00:09:16.120 --> 00:09:20.290
to do it. I mean, after all, Android is Linux
and Linux has a perfectly good file system,

00:09:20.290 --> 00:09:26.130
really quite a very good file system, in fact.
And so, why wouldn't you just do a write onto

00:09:26.130 --> 00:09:33.080
the file system for your logging? I mean,
what do you need a database for your file

00:09:33.080 --> 00:09:37.459
system for, for your log file for? So to,
you know, stay away from SQLite when you can

00:09:37.459 --> 00:09:46.160
and when you can't, use it very, very carefully.
Now, the lesson from this is obvious is that,

00:09:46.160 --> 00:09:52.560
you know, I/O hurts. The good news is that,
you know, computation is actually surprisingly

00:09:52.560 --> 00:09:55.970
fast. You know, because we're all used to
these very fast processors and things like

00:09:55.970 --> 00:09:59.010
this you think, "Oh, it's got a one gigahertz
processor. That's not fast." Well, you know,

00:09:59.010 --> 00:10:03.080
I'm an old guy and I can--you know, one gigahertz
processors are really fast. You can do an

00:10:03.080 --> 00:10:09.579
amazing amount of computation in there. So
caching things, you know, in memory and saving

00:10:09.579 --> 00:10:16.570
I/O by doing computation is almost always
a good idea. And so, you just have to assume

00:10:16.570 --> 00:10:21.140
that anytime you do I/O something bad is going
to happen. And like I said, that's where bad

00:10:21.140 --> 00:10:24.820
reviews come from, that's where bad ratings
come from, and that's how you never get featured,

00:10:24.820 --> 00:10:33.410
is if you do I/O in a stupid way. So the only
answer is to do threads, to split the work

00:10:33.410 --> 00:10:38.360
off into another thread. If you do anything
on the I/O thread, you're just really asking

00:10:38.360 --> 00:10:43.921
for trouble. So what you really need to do
is you need to fire up another thread, pass

00:10:43.921 --> 00:10:52.060
it the workload and have it update you when
you're doing that. Now, in the example I showed

00:10:52.060 --> 00:10:55.140
in the first talk, we're going to be looking
that again. I did all that stuff by hand.

00:10:55.140 --> 00:10:59.320
I manually created a thread and it passed
back and stepped to the main thread to update

00:10:59.320 --> 00:11:02.991
the UI. And that was kind of clumsy, and that
was because I didn't know about this thing.

00:11:02.991 --> 00:11:10.529
So there's something called asyncTask. And
you know, I forgot to ask at the very beginning,

00:11:10.529 --> 00:11:16.660
a question I always ask, "How many of are
actual Android developers?" Oh, wow. So a

00:11:16.660 --> 00:11:21.010
lot of you aren't. And for you--to those who
aren't, I apologize, some of this will go

00:11:21.010 --> 00:11:28.540
over our heads but, oh well, okay. So asyncTask
is basically a wrapper for sending something

00:11:28.540 --> 00:11:33.480
to execute in a background thread. And as
you know, since it's the same semantics as

00:11:33.480 --> 00:11:37.740
Java.lang.thread, setting up threads and running
them and controlling them is kind of awkward,

00:11:37.740 --> 00:11:43.110
and difficult, and tricky. And asyncTask is
a very useful tool to get around that. So

00:11:43.110 --> 00:11:51.220
I'm going to show you an example of a class
here that is downloading some files. Now,

00:11:51.220 --> 00:11:55.570
I suppose the people at the back have a hard
time seeing the code, I'm sorry. If you really

00:11:55.570 --> 00:11:58.709
want to see the code, there's people sitting
on the floor here at the front so that's a

00:11:58.709 --> 00:12:03.860
good option. So what this thing does is it
downloads some files, okay? Now, downloading

00:12:03.860 --> 00:12:07.389
a file from the network and storing it on
your computer--on your phone is something

00:12:07.389 --> 00:12:13.330
that's guaranteed to be slow, right, and uncontrollable.
So what it does is it, you know, for--and

00:12:13.330 --> 00:12:20.180
I'll zero up the count, it downloads a file
and then it calls publish progress. So the

00:12:20.180 --> 00:12:25.709
way that asyncTask works is that you see how
you start it down at the bottom? You make

00:12:25.709 --> 00:12:31.700
a new download files task. So asyncTask is
an abstract class so you have to extend it.

00:12:31.700 --> 00:12:35.690
So you make a new one of those things and
when you call the execute method, it goes

00:12:35.690 --> 00:12:40.680
and calls the doing background method and
it takes care of setting up the other thread

00:12:40.680 --> 00:12:49.370
and starting it and all that stuff for you.
So when you call the publish progress method,

00:12:49.370 --> 00:12:55.410
that goes and calls the on progress update
method but it calls it in the UI thread, okay?

00:12:55.410 --> 00:13:00.450
So it takes care of maneuvering things back
and forth between the threads. So in the on

00:13:00.450 --> 00:13:05.829
progress update method, he is just--I don't
know, updating a progress bar or, you know,

00:13:05.829 --> 00:13:09.410
showing a number or something to the user
on the screen. And to do that, you have to

00:13:09.410 --> 00:13:14.060
be in the UI thread. So getting the messages
back and forth between the threads can be

00:13:14.060 --> 00:13:18.230
tricky and this just does all that. It's also
got some other handy methods. It's gotten

00:13:18.230 --> 00:13:23.899
on pre-execute and in on post-execute and
so on so it takes care of all the book-keeping

00:13:23.899 --> 00:13:30.079
for you and I totally recommend it. You know,
to do that, using naked thread messages and

00:13:30.079 --> 00:13:34.089
so on, you probably will be looking at three
or four screen-full of code with lots of chances

00:13:34.089 --> 00:13:39.080
to make silly errors and this just takes care
of it. Was there anything else I was going

00:13:39.080 --> 00:13:45.029
to say? No. So this is very handy. Now, in
this particular example, he's doing something

00:13:45.029 --> 00:13:49.269
that the user probably wants to be informed
about. You know, the user said, download these

00:13:49.269 --> 00:13:53.600
files, so the user's willing to wait, will
it download? So, we're going up in the bound

00:13:53.600 --> 00:13:58.170
and informing him, and if he loses his patience
and just, you know, hits the home key to go

00:13:58.170 --> 00:14:02.029
to some other application, that's fine, it
will keep running in the background and everything

00:14:02.029 --> 00:14:06.740
will be just fine. But there's some cases
where you don't really care about what's happening.

00:14:06.740 --> 00:14:12.760
So this is what's called "fire and forget"
mode and this is from the Android Browser.

00:14:12.760 --> 00:14:17.220
Now, whenever I go to a new page in the browser
it has to update my browsing history so that

00:14:17.220 --> 00:14:21.420
I can use, you know, the back button and things
like that. But the user doesn't care. The

00:14:21.420 --> 00:14:24.850
user doesn't want to be informed that I'm
updating the browser history, that's just

00:14:24.850 --> 00:14:31.040
a complete background task. So in this case,
he is not doing any progress updating or anything,

00:14:31.040 --> 00:14:36.940
he's just, you know, making a new asyncTask
right there on the fly and calling its doing

00:14:36.940 --> 00:14:43.230
background method and there you go. So we
call that fire and forget mode. It's off in

00:14:43.230 --> 00:14:48.040
the background. I don't care about it, just
do it, finish it, come back. So that works

00:14:48.040 --> 00:14:55.220
just fine but it's got one problem. Now, let
me just talk a little bit more about asyncTask,

00:14:55.220 --> 00:14:58.800
yeah. So there are few things you got to be
careful about with asyncTask. You can't call

00:14:58.800 --> 00:15:02.900
it recursively, right? You can't launch an
asyncTask and then have that asyncTask go

00:15:02.900 --> 00:15:12.580
and launch another asyncTask. So basically
it has to come from a UI thread. And it's

00:15:12.580 --> 00:15:17.851
perfectly possible that if you launch an asyncTask
you're activity could go away and you could

00:15:17.851 --> 00:15:22.300
be killed. The other reasoning is that, you
know, he's doing something else, you're still

00:15:22.300 --> 00:15:26.279
running in the background, the system runs
short of memory, it'll just go kill your thread.

00:15:26.279 --> 00:15:30.380
And if it's doing something important you
know that's bad. You don't want that to happen.

00:15:30.380 --> 00:15:36.899
So it turns out that if you want to run something
in the background and you want to tell the

00:15:36.899 --> 00:15:41.899
system that it needs to be alive, that's what
services are for. And once again, just like

00:15:41.899 --> 00:15:47.589
activities and threads, services take a certain
amount of work to set up and run. So there's

00:15:47.589 --> 00:15:51.639
this thing called IntentService that sort
of does the same thing. It launches a service

00:15:51.639 --> 00:15:58.810
in the background and you just start the service
and it goes off and you send in intents and

00:15:58.810 --> 00:16:03.269
it runs the intents. And since it's a service,
the system will try really hard not to kill

00:16:03.269 --> 00:16:09.089
it. Now in practical terms, in all the Android
programming I've done, which is a certain--not

00:16:09.089 --> 00:16:12.350
a huge amount, I do other things as well but
I've done quite a bit, I've never ever seen

00:16:12.350 --> 00:16:16.110
a service get killed. I know it can happen
in principle but I've never actually seen

00:16:16.110 --> 00:16:21.399
it--seen that happened so it's really pretty
safe. So here's an--a good example of that.

00:16:21.399 --> 00:16:27.190
So this is the calendar application on the
system. So, I don't know about you but you

00:16:27.190 --> 00:16:30.470
know, sometimes I pull out my phone after
I've been talking to somebody for a while

00:16:30.470 --> 00:16:34.460
and it's got a calendar notification in the
notice bar. So I pull that down, it will tell

00:16:34.460 --> 00:16:38.490
me about three things that, you know, I either
should have gone to or I already went to or

00:16:38.490 --> 00:16:43.029
I'm going to go to. And so you just say, "dismiss
all," right? So when it hits--when you hit

00:16:43.029 --> 00:16:46.440
the dismiss all button, the calendar has to
go and acknowledge that you've seen all of

00:16:46.440 --> 00:16:49.660
those things and mark them as being in the
past and so on, and actually it has to do

00:16:49.660 --> 00:16:54.570
quite a lot of database clean-up. And the
user doesn't care. The user doesn't want to

00:16:54.570 --> 00:16:57.370
wait for that. The user doesn't want to hear
about it. You just want it to happen. But

00:16:57.370 --> 00:17:00.480
you ought to make sure it really does happen
because you don't, you know, you don't want

00:17:00.480 --> 00:17:07.980
it coming back to bother the user again. So
what he does is he goes and makes a--extends

00:17:07.980 --> 00:17:14.610
intentService, and then he goes and, you know,
gets the resolver and goes and fix this up

00:17:14.610 --> 00:17:21.470
and it takes care of all the calendar stuff.
And then when you--when this thing happens,

00:17:21.470 --> 00:17:27.179
you make a new intent to point it directly
at that class and then you just say, go and

00:17:27.179 --> 00:17:30.850
start that service and away it goes in the
background and the user's off doing something

00:17:30.850 --> 00:17:35.490
else, okay? So start services is really, really
good. Start services is also very good for

00:17:35.490 --> 00:17:39.800
use in a broadcast receiver. So you get a
broadcast receiver, you know, like something

00:17:39.800 --> 00:17:42.590
needs to happen in the background, you can't
spend much time, you start the service, you

00:17:42.590 --> 00:17:54.789
go away. So we've talked about, you know,
getting things off of the main UI loop, in

00:17:54.789 --> 00:17:59.549
order to that the user doesn't have to wait
for them. And just to make it a 100% clear,

00:17:59.549 --> 00:18:03.370
the reason we're doing this, like for example
in that application where he was downloading

00:18:03.370 --> 00:18:08.010
files, so he was willing to wait for downloading
the files. So to be polite to him, you want

00:18:08.010 --> 00:18:11.000
to show a progress, you know, that, "Hey,
I'm working and downloading those files for

00:18:11.000 --> 00:18:19.230
you." But if you actually were doing the downloading
of the files in the UI thread, and the guy

00:18:19.230 --> 00:18:23.210
does something like tap the menu key or something
like that, well, it won't respond because

00:18:23.210 --> 00:18:26.710
it's busy downloading the file. So the user
will see a frozen phone. That's why you have

00:18:26.710 --> 00:18:32.860
to do these things, okay? So the question
is--so this also gets us to some very interesting

00:18:32.860 --> 00:18:37.920
user interface design. So, here's a sketch
of how you might design the user interface

00:18:37.920 --> 00:18:42.940
for something that is slow and going to be
relatively time-consuming. So the first thing

00:18:42.940 --> 00:18:47.000
is, if you're doing something time-consuming
and you don't want the user pushing any buttons

00:18:47.000 --> 00:18:50.030
in your app or something like that, disable
them first. You know, before you actually

00:18:50.030 --> 00:18:53.980
start doing any work, turn off all the buttons
that you don't want the user pushing. Then

00:18:53.980 --> 00:18:57.559
if it's just going to be a really, really
quick job, there's a way. They run a little

00:18:57.559 --> 00:19:01.080
spinner, a little progress dialogue, right
there in the status bar to show that it's

00:19:01.080 --> 00:19:04.390
working. And if it's going to be something
that's only going to be, you know, a fraction

00:19:04.390 --> 00:19:08.309
of a second or a second maybe, go ahead and
just spin there. And so what they're--in this

00:19:08.309 --> 00:19:11.940
strategy, what they're saying is, first of
all you turn off the UI, and then you show

00:19:11.940 --> 00:19:15.950
a little spinner and if it really goes on
for a while, you set an alarm to go off in,

00:19:15.950 --> 00:19:19.150
you know, a fifth of a second or something,
and if you're still working, well then, you

00:19:19.150 --> 00:19:22.880
know, put up a progress dialogue of some sort
to show the users that you're working. And,

00:19:22.880 --> 00:19:28.230
of course, the work is always has to be happening
off in another thread. So designing the user

00:19:28.230 --> 00:19:42.510
interface for these kinds of slow activities
is actually a tricky thing.

00:19:42.510 --> 00:19:48.120
So some of the general lessons that apply
to application performance are what we just

00:19:48.120 --> 00:19:52.070
spent a few minutes talking about, it's, you
know, the network and storage UI are really

00:19:52.070 --> 00:19:57.130
painful and you have to be careful about those.
So, let's assume you all ready know this.

00:19:57.130 --> 00:20:04.700
Watch out for excessive memory allocation.
In particular, a very rapid burst of a whole

00:20:04.700 --> 00:20:10.760
bunch of new calls of small object allocations
tends to be fairly expensive and to cause

00:20:10.760 --> 00:20:15.720
the garbage collector to burn some CPU later
so, you know, it's a good idea to batch up

00:20:15.720 --> 00:20:25.570
your allocations if you can. A very common
technique in Java, particularly among fairly

00:20:25.570 --> 00:20:29.909
advanced Java programmers, is reflection.
You get an abstract object, you know, it's

00:20:29.909 --> 00:20:33.110
just an object of some sort. You look inside
it to see what methods it has and you call

00:20:33.110 --> 00:20:36.950
those methods. This is very, very useful when
you're dealing with for example, databases

00:20:36.950 --> 00:20:40.750
and you, you know, you get a database object.
You can look inside it and see what couples

00:20:40.750 --> 00:20:46.270
it has and things like that. It turns out
that at the moment in Android, this Java technique

00:20:46.270 --> 00:20:52.630
is called reflection, Android reflection is
extremely painful and extremely slow. We are

00:20:52.630 --> 00:20:58.740
talking 100 times as slow as typical native
code. So it will really, really slow down

00:20:58.740 --> 00:21:02.880
your applications. Now, it's a common technique
to use, reflection, if you want to have an

00:21:02.880 --> 00:21:09.640
application that runs on both 1.5, 1.6, 2.0
and 2.2 of Android, it's very, very common

00:21:09.640 --> 00:21:12.730
to say, "Oh, well let me see. Do I have this
method? If I have this method then I know

00:21:12.730 --> 00:21:16.620
I'm running on 2.2 and I can do this extra
fancy technique. Otherwise, I'll do it the

00:21:16.620 --> 00:21:19.940
simple way." And that's perfectly okay. We
recommend doing that in fact, that kind of

00:21:19.940 --> 00:21:23.780
reflection. But that--but you only want to
do that kind of thing when you're at the very

00:21:23.780 --> 00:21:26.970
beginning of your application, just getting
started, right? You don't want to do it in

00:21:26.970 --> 00:21:31.190
the middle of a tight loop or you'll just
totally kill your performance. There's a whole

00:21:31.190 --> 00:21:35.850
section in developers at Andriod.com about
designing for performance and it's worth reading.

00:21:35.850 --> 00:21:40.090
There's some things in there that are kind
of surprising. You get a surprising benefit

00:21:40.090 --> 00:21:45.270
for making things static when you can and
so on. Floating point math is a problem in

00:21:45.270 --> 00:21:53.630
any system and it's also a problem. So now,
I'm going to do a demo to show you two things,

00:21:53.630 --> 00:21:58.180
what a performance-sensitive UI might look
like and then what it does. So, this is a

00:21:58.180 --> 00:22:04.032
little application I wrote and when you get
a new Android phone--put it back for a sec,

00:22:04.032 --> 00:22:11.630
please. So, can I have the computer for one
more minute? Yeah, thanks. So, this app is

00:22:11.630 --> 00:22:15.090
for when you get a new Android phone. When
you get a new Android phone as you know, you're

00:22:15.090 --> 00:22:20.600
email addresses, your contacts, your schedules,
all that kind of stuff comes over to your

00:22:20.600 --> 00:22:24.890
new phone. But the history of your phone calls
doesn't. They are your call log and your history

00:22:24.890 --> 00:22:28.541
of your SMS' and I hated that because there's
a lot of useful information in there. So I

00:22:28.541 --> 00:22:33.990
wrote this little application called LifeSaver
that takes the SMS messages of you--out of

00:22:33.990 --> 00:22:38.610
your log and all the phone number calls you've
made and puts in on the SD card. You move

00:22:38.610 --> 00:22:42.510
the SD card into a new computer, you run it,
it copies them back and then it saves your

00:22:42.510 --> 00:22:46.610
life and brings it back for you. Okay, so
let me show you that app. Can we have this

00:22:46.610 --> 00:22:56.620
thing now, please? So, I'm running it on my
Nexus One here. So, can we see that? Yes,

00:22:56.620 --> 00:23:05.640
I see that. So, here's the LifeSaver app--okay.
So, what it's going to do is it's going to--oh,

00:23:05.640 --> 00:23:11.409
I'm sorry. Thank you. What it's going to do
is it's going to read all the phone calls

00:23:11.409 --> 00:23:15.679
out of the phone call log and all the SMS'
out of the SMS and it's going to save them

00:23:15.679 --> 00:23:20.230
onto the SD card. So, there's a lot of I/O
in this. So, it says, "Oh, where do you want

00:23:20.230 --> 00:23:24.860
it," once. "There's like a life here, can
I write it," so. So, immediately I send these

00:23:24.860 --> 00:23:28.770
things away and I draw a progress bar. Well,
that's working. Now, there's only a couple

00:23:28.770 --> 00:23:34.990
of 100 calls on here. So, we showed the users
something to look at to keep them busy while

00:23:34.990 --> 00:23:38.390
it was working. Now, this simply--if this
was a teenager's phone, it would take like

00:23:38.390 --> 00:23:51.120
two hours to run. But, you know, but for me
it's okay. And that's not bad, but it seems

00:23:51.120 --> 00:23:54.440
to me that that is actually a little bit slow.
And for it wasn't--actually I do have a couple

00:23:54.440 --> 00:23:57.789
of complaints in my comments on, you know,
what they'd be saying, "Gee, it took a long

00:23:57.789 --> 00:24:01.820
time." Frankly, I don't worry too much because
it only runs once, you know, once on the old

00:24:01.820 --> 00:24:06.230
phone and once on the new phone and then it's
done. But, you know, I would like it to run

00:24:06.230 --> 00:24:23.080
faster. So, can we come back to the slides
now, please? Oh, drat, I forgot something

00:24:23.080 --> 00:24:49.929
here. One moment. Oh, well, we can work around
that. So, I want that to run faster. So now

00:24:49.929 --> 00:24:53.250
I'm going to consider how would I make that
app run faster. So, I have to think, "Well,

00:24:53.250 --> 00:24:59.020
why is it slow?" So, here's the bad news.
If you're going to write an app and it's reasonably

00:24:59.020 --> 00:25:04.360
complex, you're not smart enough to predict
where the performance bottlenecks are. Nobody

00:25:04.360 --> 00:25:08.760
is smart enough. Trying to optimize your program
in advance, it will waste your time and it'll

00:25:08.760 --> 00:25:13.620
probably make your program bad. And I noticed
that a lot of young programmers. In particular,

00:25:13.620 --> 00:25:18.100
young male programmers are, you know, really
like to think that they're super smart and

00:25:18.100 --> 00:25:21.309
they're, "Oh, I know that's slow because it's
this and I'm going to put a hashtable in there."

00:25:21.309 --> 00:25:28.320
And they spend three weeks coding up a hashtable
and then it doesn't run any faster. So, you

00:25:28.320 --> 00:25:33.500
just can't guess. This is the right way to
do it. So, the right approach is that, you

00:25:33.500 --> 00:25:37.720
know, simple programs are better than complex
ones. So you should write your app in the

00:25:37.720 --> 00:25:43.289
simplest way that could possibly work. Now,
of course, that doesn't include doing any

00:25:43.289 --> 00:25:46.450
heavy work on the UI thread. Maybe it'll,
you know, maybe it's fast enough then. You're

00:25:46.450 --> 00:25:51.409
done. Go have a beer. And if it's slow, then
you have to measure. You have to get a profiler

00:25:51.409 --> 00:25:55.350
and you have to measure to find out why your
program is slow before you start to fix it,

00:25:55.350 --> 00:26:04.330
okay? So, Android app two Froyo has a decent
profiling tool called Traceview. And the way--and

00:26:04.330 --> 00:26:08.960
we'll talk about that in a second but, you
know, you can do a lot of profiling just by

00:26:08.960 --> 00:26:13.260
putting log statements with time stamps and
time stamps and to find out what's going on.

00:26:13.260 --> 00:26:16.840
What we do at Google is we get all the Googlers
to run code and we run profilers on all of

00:26:16.840 --> 00:26:20.700
them at once and collect the data just statistically.
That's a very powerful profiling technique.

00:26:20.700 --> 00:26:25.400
But--so, let's talk about Traceview because
it's sort of the default profiler. So the

00:26:25.400 --> 00:26:30.580
way it works is you can start and stop it
from adb, but I find it actually better to

00:26:30.580 --> 00:26:46.990
put code in to do it. So, let's actually do
that and I'll show you how it works. I need

00:26:46.990 --> 00:26:51.169
to type one in here. So what I'm what going
do is you put it in a--here's that actual

00:26:51.169 --> 00:26:55.210
code that does that. So I would put it--I'm
going to put in a start tracing and a stop

00:26:55.210 --> 00:27:13.250
tracing call.
&gt;&gt; Hey, Tim, we can't see the presentation

00:27:13.250 --> 00:27:27.460
right now.
&gt;&gt; BRAY: Okay. So, you couldn't call it the...

00:27:27.460 --> 00:27:29.120
&gt;&gt; You forgot your mic.
&gt;&gt; BRAY: Now, what I would normally do, we're

00:27:29.120 --> 00:27:33.299
a little short on time, so I actually--so
what--the way that you would normally is you

00:27:33.299 --> 00:27:39.210
would put those calls in, send it over, run
it and then it will write a trace file. Now,

00:27:39.210 --> 00:27:44.600
that call I put it, I said, you know, android.SD.debug,
they'll start method tracing LSD for LifeSaver

00:27:44.600 --> 00:27:52.880
Debug and it'll create a file called /SDcard/LSD.trace
and then you pull that over onto the--onto

00:27:52.880 --> 00:27:56.289
your computer and you run the program called
Traceview. Since we're a little bit short

00:27:56.289 --> 00:28:32.200
of time, I'm going to actually skip doing
that and just go and run Traceview.

00:28:32.200 --> 00:28:36.279
So, what I--so one thing you would have observed
if I'd actually run that is that be--when

00:28:36.279 --> 00:28:39.960
turned the method tracing on, it all runs
a lot slower. So here you see the display

00:28:39.960 --> 00:28:44.230
that Traceview makes and you can see that
here is the main thread, where it's doing

00:28:44.230 --> 00:28:47.941
the UI. There's my thread where I'm doing
the reading and writing. And then you can

00:28:47.941 --> 00:28:51.020
look at these things for example and you can
see that that's the garbage collection, that

00:28:51.020 --> 00:28:56.760
purple stripe, okay? So, let's zero in on
just, you know, 100 milliseconds or so of

00:28:56.760 --> 00:29:05.130
this. We're even closer. And the colors there
correspond to the colors in the display below.

00:29:05.130 --> 00:29:08.200
Now the really interesting part here is the
display below. If I go down here and look

00:29:08.200 --> 00:29:14.960
I can see that two-thirds of the time of this
thing is being spent inside print line. Oh,

00:29:14.960 --> 00:29:19.840
now if I had looked that up and asked myself,
"Why is that slow," my first two theories

00:29:19.840 --> 00:29:23.429
would have been, "Well, it's slow reading
the telephone logs out of the system or it's

00:29:23.429 --> 00:29:28.600
slow writing the data of the SD card," right?
So this suggests that the problem is the writing

00:29:28.600 --> 00:29:34.600
the data to the SD card so let's just drill
down on that. And we discover that of the

00:29:34.600 --> 00:29:41.210
two-thirds of the time it spends in print
line, half the time is actually doing print

00:29:41.210 --> 00:29:45.260
line. And if you look at that, it's spending
half of it's time doing new lines. So, it

00:29:45.260 --> 00:29:49.669
looks--if you look--drill down further on
that, it becomes fairly obvious that yeah,

00:29:49.669 --> 00:29:54.899
they're both, you know, half of two-thirds
of the time is actually the I/O time but the

00:29:54.899 --> 00:30:01.560
other half seems to be in Java.lang.string.valueof,
what? Oops, I put on the wrong thing at the

00:30:01.560 --> 00:30:18.440
back here. And--what did I do wrong? I know,
there it is. So there, that is, and in value

00:30:18.440 --> 00:30:27.559
of 99% of that time is in jsonobject.tostring.
So it--apparently 34% of my total time on

00:30:27.559 --> 00:30:32.490
this program is in jsonobject.tostring. Now
you can drill down on this but another thing

00:30:32.490 --> 00:30:36.190
you could do is you could turn and just sort
this stuff by the amount of time it spends

00:30:36.190 --> 00:30:41.080
in the routine and you discover that these
are all the things of over 1%. They are all

00:30:41.080 --> 00:30:46.179
bits of json.tostring. So it turns out that
I've discovered the fact that this particular

00:30:46.179 --> 00:30:53.140
Android implementation, the json.tostring,
is incredibly inefficient and stupid and it's

00:30:53.140 --> 00:30:57.010
slowing down my application. So I could go
and try and optimize the I/O or I could just

00:30:57.010 --> 00:31:02.120
stop using json. But the real lesson I want
to teach you is, is that my intuition about

00:31:02.120 --> 00:31:07.960
what was making the program run slow, my guess,
was completely wrong. And your guess is going

00:31:07.960 --> 00:31:12.490
to be completely wrong too, when you do it.
So you need to use tools like Traceview to

00:31:12.490 --> 00:31:19.470
make things like this work better. Now, I'm
going to switch back to my presentation here

00:31:19.470 --> 00:31:28.370
and talk a little bit about Traceview. Now
you do have to worry about Traceview a little

00:31:28.370 --> 00:31:33.429
bit. The picture it presents is not that great.
To start with it, it turns that the JIT off

00:31:33.429 --> 00:31:38.580
in the VM, so that really hurts your performance.
Secondly, it overestimates the cost of calling

00:31:38.580 --> 00:31:43.100
methods, because the--it turns off a bunch
of optimizations there. So, you know, when

00:31:43.100 --> 00:31:48.809
I say that this thing taking 35% of my time
that doesn't mean, you know, between 34 and

00:31:48.809 --> 00:31:53.600
36 that means, you know, well, you know, a
noticeable chunk. So the numbers are not very

00:31:53.600 --> 00:31:57.549
quantitatively reliable. But they are very
useful actually in terms of teaching you what's

00:31:57.549 --> 00:32:04.600
going on. In terms of futures, were actually
doing in the future releases of the operating

00:32:04.600 --> 00:32:07.899
system, were doing a lot of work on the screen
manager, to make the screen management faster.

00:32:07.899 --> 00:32:11.740
One thing we're talking about--Brad already
talked about this at I/O so it's not a secret,

00:32:11.740 --> 00:32:17.049
we have all talked about not doing I/O on
the UI thread, right? Well, all of us are

00:32:17.049 --> 00:32:21.140
smart now. We'll never do that again. But
it turns out there's many simple-looking utility

00:32:21.140 --> 00:32:25.529
calls in the system that end up doing some
database I/O even if when you're not looking

00:32:25.529 --> 00:32:29.149
and you don't know about that. So were introducing--were
going to be introducing the thing before too

00:32:29.149 --> 00:32:33.320
long where you can say I'm in "Strict" mode.
And whenever--when you're in strict mode,

00:32:33.320 --> 00:32:39.360
whenever you see--encounter any I/O on the
UI thread, it will throw an exception. So

00:32:39.360 --> 00:32:43.510
this will help you--and the amount of speed
up it's brought, just to ordinary utilities

00:32:43.510 --> 00:32:48.730
even some reroute is amazing. So that'll be
nice. And also Traceview is much better than

00:32:48.730 --> 00:32:53.850
nothing. But it's not that great so were going
to be bringing in some better profiling tools

00:32:53.850 --> 00:33:00.190
in the next release. So that's it. That was
about all I was going to say. So just to recap,

00:33:00.190 --> 00:33:05.980
the UI thread is sacred. Keep your I/O off
the UI thread. Entertain the user, show them

00:33:05.980 --> 00:33:10.769
something while you're doing something that
you have to wait for. And to make your program

00:33:10.769 --> 00:33:16.500
run fast don't guess, profile it, figure out
what your problems are before you fix them.

00:33:16.500 --> 00:33:25.919
We've got one or two minutes for questions.
Lights up, please. Any questions? Yeah? Nope?

00:33:25.919 --> 00:33:26.730
Okay, thank you all.

