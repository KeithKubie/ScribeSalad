WEBVTT
Kind: captions
Language: en

00:00:01.334 --> 00:00:03.467
Slatkin: Well, hello.
Welcome to my talk.

00:00:03.467 --> 00:00:05.601
It's called
"Large-scale Data Analysis

00:00:05.601 --> 00:00:07.334
Using the App Engine
Pipeline API."

00:00:07.334 --> 00:00:08.734
My name is Brett Slatkin.

00:00:08.734 --> 00:00:12.267
I'm a software engineer
on the Google App Engine team.

00:00:12.267 --> 00:00:14.968
These are the
hashtags for this,

00:00:14.968 --> 00:00:17.501
and our feedback form,
that's a 1.

00:00:17.501 --> 00:00:21.734
So "1gGbS."

00:00:21.734 --> 00:00:24.234
Couldn't possibly
be any harder.

00:00:24.234 --> 00:00:27.033
Sure I'll get some
great feedback. Anyway.

00:00:27.033 --> 00:00:28.968
Here are the two projects we're
kind of talking about today,

00:00:28.968 --> 00:00:32.567
"appengine-pipeline"
and "mapreduce,"

00:00:32.567 --> 00:00:35.734
the MapReduce projects.
I also realize

00:00:35.734 --> 00:00:37.434
that it's kind of bad
to put a 301 session

00:00:37.434 --> 00:00:39.400
as the last session
of an entire conference,

00:00:39.400 --> 00:00:41.234
which is what this is,

00:00:41.234 --> 00:00:44.234
so there's a lot of code
in this presentation,

00:00:44.234 --> 00:00:46.767
and I realize it might be very
hard for you to read,

00:00:46.767 --> 00:00:48.400
so luckily,
you all have tablets

00:00:48.400 --> 00:00:50.701
and other things
to read things on,

00:00:50.701 --> 00:00:53.100
so this is linked to the slides
that you're about to see.

00:00:53.100 --> 00:00:56.234
So if you want to
follow along and can't read,

00:00:56.234 --> 00:00:59.868
it's,
"goo.gl/P2U2S."

00:00:59.868 --> 00:01:02.467
So you can click on that,

00:01:02.467 --> 00:01:03.701
or download that
and check it out.

00:01:03.701 --> 00:01:05.801
It's PDF.

00:01:05.801 --> 00:01:08.234
Okay, so let's talk
about, kind of,

00:01:08.234 --> 00:01:11.667
motivation for
the Pipeline API,

00:01:11.667 --> 00:01:14.267
and then I'll kind of talk
about what it is and--

00:01:14.267 --> 00:01:15.467
and all that.

00:01:15.467 --> 00:01:19.067
So--so there's
something, you know,

00:01:19.067 --> 00:01:20.634
people want to do
that's very common,

00:01:20.634 --> 00:01:21.667
it's the data join.

00:01:21.667 --> 00:01:22.767
What is
a data join?

00:01:22.767 --> 00:01:24.167
Basically, we're saying,

00:01:24.167 --> 00:01:27.234
I have a bunch of data
and I want to do a join on it,

00:01:27.234 --> 00:01:28.467
like an SQL join.

00:01:28.467 --> 00:01:30.667
I want to join two
unrelated tables together

00:01:30.667 --> 00:01:32.467
into a single view.

00:01:32.467 --> 00:01:36.000
I want to combine data
by the features that it has.

00:01:36.000 --> 00:01:37.767
And you want to do this
for all kinds of reasons,

00:01:37.767 --> 00:01:39.667
the same reasons you
want to do an SQL join,

00:01:39.667 --> 00:01:41.868
because you want to join--
generate views or reports

00:01:41.868 --> 00:01:46.167
or any kind of aggregate
data or derivative data.

00:01:46.167 --> 00:01:49.067
So some examples of this
is any kind of ranking,

00:01:49.067 --> 00:01:52.400
doing heat-map diagrams,
any kind of fiscal roll-ups,

00:01:52.400 --> 00:01:54.901
stats, et cetera.

00:01:54.901 --> 00:01:59.367
And, you know, so since
you know what you want to do,

00:01:59.367 --> 00:02:01.767
why you want to do it,
when do you want to do it?

00:02:01.767 --> 00:02:04.067
I mean, you need to do
a join when the data sources

00:02:04.067 --> 00:02:07.334
are kind of mismatched for what
you're trying to accomplish.

00:02:07.334 --> 00:02:11.234
So each data set that you're
trying to analyze or join

00:02:11.234 --> 00:02:13.801
has something else
that it's optimized for.

00:02:13.801 --> 00:02:18.067
So logging is optimized
for rate li--write latency,

00:02:18.067 --> 00:02:19.801
and then, especially with
a high replication Datastore,

00:02:19.801 --> 00:02:21.667
a lot of things
are optimized

00:02:21.667 --> 00:02:24.067
for per-user views,
not global views.

00:02:24.067 --> 00:02:26.868
So you want to
join different data

00:02:26.868 --> 00:02:28.667
that's optimized for
totally different uses

00:02:28.667 --> 00:02:34.634
to produce other outputs
for a third use, you know.

00:02:34.634 --> 00:02:36.834
So that's kind of what
we're talking about.

00:02:36.834 --> 00:02:40.834
When you'd really
want to do a data join.

00:02:40.834 --> 00:02:43.033
Now, what makes this all unique
from just a standard SQL join

00:02:43.033 --> 00:02:44.501
is that you have
a lot of data,

00:02:44.501 --> 00:02:48.167
so you can't just do it in
an SQL table with a simple join

00:02:48.167 --> 00:02:49.300
or and in-memory join.

00:02:49.300 --> 00:02:51.133
There's just too much
information.

00:02:51.133 --> 00:02:54.167
So that's why
I'm calling it "data join."

00:02:54.167 --> 00:02:57.968
So I wanted to use, like,
a real example for this.

00:02:57.968 --> 00:03:00.133
So I wanted to just
give one that really,

00:03:00.133 --> 00:03:01.300
I think,
everyone can relate to.

00:03:01.300 --> 00:03:02.601
I was going to do
a contrived example,

00:03:02.601 --> 00:03:04.534
but I think this one's
a little more solid.

00:03:04.534 --> 00:03:06.100
So it's
a sales report. Okay?

00:03:06.100 --> 00:03:10.133
We've got simple Datastore
kinds, tables, we've got sales,

00:03:10.133 --> 00:03:12.400
so what was sold
to a customer

00:03:12.400 --> 00:03:14.367
that's basically
customers to items.

00:03:14.367 --> 00:03:16.534
So "many-to-many" table.
Pretty easy.

00:03:16.534 --> 00:03:19.534
We have the items.
How much they cost.

00:03:19.534 --> 00:03:21.734
Item-to-cost,
it's one-to-one.

00:03:21.734 --> 00:03:23.834
And then we have
categories of things.

00:03:23.834 --> 00:03:25.300
So what kind of thing
is an item?

00:03:25.300 --> 00:03:29.968
So items have
many categories.

00:03:29.968 --> 00:03:31.501
And, so here's some
example data

00:03:31.501 --> 00:03:34.100
in our fake business
tables here.

00:03:34.100 --> 00:03:35.667
We have "A"--
customers "A," "B," and "C."

00:03:35.667 --> 00:03:37.968
We've got "milkshakes,"
"pies," and "fries."

00:03:37.968 --> 00:03:40.300
We've got categories
that these can belong to:

00:03:40.300 --> 00:03:42.200
"desserts,"
"food," or "drinks."

00:03:42.200 --> 00:03:43.467
Then we have a price
for each one.

00:03:43.467 --> 00:03:46.667
So a milkshake is both
a dessert and a drink.

00:03:46.667 --> 00:03:48.767
It's not rocket science.

00:03:48.767 --> 00:03:51.133
But, something you might
want to do with this information

00:03:51.133 --> 00:03:53.234
is generate a report.
Right?

00:03:53.234 --> 00:03:55.133
So you've got custo--
you want to know how much

00:03:55.133 --> 00:03:56.567
is each customer spending

00:03:56.567 --> 00:04:00.701
and what category is
making you the most revenue.

00:04:00.701 --> 00:04:03.534
Very simple,
like, desirable thing,

00:04:03.534 --> 00:04:05.334
and most of you would say,
"Well, this is really easy.

00:04:05.334 --> 00:04:07.934
I'll just do a join
of an SQL table."

00:04:07.934 --> 00:04:10.667
And you may know
that--

00:04:10.667 --> 00:04:12.100
Well, I'll get to that
in a second.

00:04:12.100 --> 00:04:15.767
So here's the SQL
that would do this.

00:04:15.767 --> 00:04:18.667
So you have--if you
want to do by customer,

00:04:18.667 --> 00:04:21.667
you just do a join of the
sales table to the items table,

00:04:21.667 --> 00:04:24.934
and that would--and group
by the customer I.D.

00:04:24.934 --> 00:04:26.000
If you want to do it
by category,

00:04:26.000 --> 00:04:27.234
you kind of have to do
a triple join.

00:04:27.234 --> 00:04:28.701
I'm sure that someone
in the room knows

00:04:28.701 --> 00:04:30.767
how to do this with
no joins in SQL.

00:04:30.767 --> 00:04:33.200
I'm just trying
to emphasize

00:04:33.200 --> 00:04:34.467
that you need multiple joins,
usually,

00:04:34.467 --> 00:04:35.968
to do this kind of thing.

00:04:35.968 --> 00:04:40.167
So you join "categories" to
"sales" and "sales" to "items"

00:04:40.167 --> 00:04:43.868
and then you sum up
by the item price.

00:04:43.868 --> 00:04:46.267
The problem is that
this eventually will break.

00:04:46.267 --> 00:04:49.067
At some point, you will get
so much data in your Datastore

00:04:49.067 --> 00:04:52.000
that you cannot do
these joins anymore.

00:04:52.000 --> 00:04:55.200
And so
I think that it's--

00:04:55.200 --> 00:04:56.501
so what we're talking about
and what--

00:04:56.501 --> 00:04:58.200
the way I'm trying to frame this
is that you want

00:04:58.200 --> 00:04:59.801
this information,
these aggregates,

00:04:59.801 --> 00:05:02.701
these roll-ups,

00:05:02.701 --> 00:05:03.767
and you want them
to keep working forever

00:05:03.767 --> 00:05:05.300
no matter how
much data you have.

00:05:05.300 --> 00:05:08.501
So that's
a big problem,

00:05:08.501 --> 00:05:09.834
and the solution
that people usually say is,

00:05:09.834 --> 00:05:11.200
"Oh, MapReduce.

00:05:11.200 --> 00:05:13.033
I will just use MapReduce
and that will solve everything."

00:05:13.033 --> 00:05:14.300
It's like,
"Throw some MapReduce on it.

00:05:14.300 --> 00:05:16.501
It's great."
And that's true.

00:05:16.501 --> 00:05:18.734
It keeps working
at extreme sizes.

00:05:18.734 --> 00:05:23.400
Oh, so, ooh, that was
a big diagram, huh?

00:05:23.400 --> 00:05:24.901
Okay, so MapReduce
is great.

00:05:24.901 --> 00:05:27.501
The problem is that MapReduce
doesn't actually solve this.

00:05:27.501 --> 00:05:29.534
There's a whole bunch of
different kinds of data analysis

00:05:29.534 --> 00:05:32.300
that you cannot do
in a single MapReduce.

00:05:32.300 --> 00:05:34.467
So what you find is that people
end up making MapReduces

00:05:34.467 --> 00:05:36.868
that are multiple stages
or very deep.

00:05:36.868 --> 00:05:38.734
So they run
one MapReduce,

00:05:38.734 --> 00:05:40.100
take the output of that
into another MapReduce,

00:05:40.100 --> 00:05:43.334
and so on and so forth.

00:05:43.334 --> 00:05:44.434
Excuse me.

00:05:44.434 --> 00:05:47.234
So let me give you
an example.

00:05:47.234 --> 00:05:49.801
Here's a diagram of
when you might do this.

00:05:49.801 --> 00:05:51.934
So here's the same joins
again,

00:05:51.934 --> 00:05:54.567
the roll-ups that I just
told you about,

00:05:54.567 --> 00:05:57.133
as a series of MapReduces.

00:05:57.133 --> 00:05:58.334
So I'm going to
step you through this,

00:05:58.334 --> 00:06:02.000
so don't worry.
So in blue are Maps.

00:06:02.000 --> 00:06:04.467
On the left we have
Mapping categories,

00:06:04.467 --> 00:06:07.701
Mapping items,
Mapping sales.

00:06:07.701 --> 00:06:10.701
So we Map "itemIds"
to "Categories,"

00:06:10.701 --> 00:06:13.701
"itemIds" to "Prices,"
"itemIds" to "Customers."

00:06:13.701 --> 00:06:16.734
Then we do a Shuffle and Reduce
to join them on the "itemId"

00:06:16.734 --> 00:06:19.634
that basically collates
them all by the "itemId"

00:06:19.634 --> 00:06:21.133
and aggregates them
together.

00:06:21.133 --> 00:06:24.801
So then we have a Mapping
of "itemIds" to the categories,

00:06:24.801 --> 00:06:29.567
the costs,
and a list of customer sales.

00:06:29.567 --> 00:06:31.767
Then we run a Map
on the output of that

00:06:31.767 --> 00:06:34.868
and then invert that--
those key value pairs.

00:06:34.868 --> 00:06:38.100
So then we output a list
of "categories to cost"

00:06:38.100 --> 00:06:40.467
and of "customerIds
to cost,"

00:06:40.467 --> 00:06:43.634
and then we Shuffle and Reduce
that to collate or join

00:06:43.634 --> 00:06:47.067
on "Category"
and "Customer" again.

00:06:47.067 --> 00:06:49.367
And at the end,
it spits out

00:06:49.367 --> 00:06:52.000
the sum of all costs per--

00:06:52.000 --> 00:06:55.300
for each category or
for each "customerId." Okay?

00:06:55.300 --> 00:06:56.934
There are more efficient
ways to do this,

00:06:56.934 --> 00:06:59.400
but I'm just trying to
illustrate the example here.

00:06:59.400 --> 00:07:02.601
I think that this is a common
use case that you'll see.

00:07:02.601 --> 00:07:03.601
So it's great.

00:07:03.601 --> 00:07:04.701
You can solve this
with MapReduces.

00:07:04.701 --> 00:07:06.534
Isn't that awesome?

00:07:06.534 --> 00:07:08.133
Wonderful. Well,
there's a few things

00:07:08.133 --> 00:07:10.901
that are actually kind of
difficult about this.

00:07:10.901 --> 00:07:13.133
It's mostly a solution,
but now you have a new problem,

00:07:13.133 --> 00:07:16.334
which is how do you actually run
all these MapReduces?

00:07:16.334 --> 00:07:18.667
If I asked you what to do
with a lot of big data,

00:07:18.667 --> 00:07:19.767
you'd say,
"Oh, I'll use a dup,

00:07:19.767 --> 00:07:20.901
I'll use a MapReduce."

00:07:20.901 --> 00:07:23.667
But if I said,
"You have five MapReduces.

00:07:23.667 --> 00:07:26.667
Connect them together," name
a tool off the top of your head.

00:07:26.667 --> 00:07:28.701
Maybe people
will say "Oozie,"

00:07:28.701 --> 00:07:31.667
which is the thing
from Yahoo for hadoop,

00:07:31.667 --> 00:07:34.767
but it's not like there's
a common thing we all agree on

00:07:34.767 --> 00:07:37.267
for the go--
to tool for this

00:07:37.267 --> 00:07:40.067
in the open source toolkit.
So that's kind of the problem.

00:07:40.067 --> 00:07:42.367
And the reason is
that Fan-in is really hard.

00:07:42.367 --> 00:07:44.033
It's hard to
make this work.

00:07:44.033 --> 00:07:46.901
And Fan-in is this thing
on the left,

00:07:46.901 --> 00:07:48.167
mapping "Categories,"
mapping "Items,"

00:07:48.167 --> 00:07:49.334
mapping "Sales,"

00:07:49.334 --> 00:07:51.767
all separately and then
Shuffling them together

00:07:51.767 --> 00:07:53.200
or joining them together.

00:07:53.200 --> 00:07:54.467
So that's Fanning-in.

00:07:54.467 --> 00:07:56.601
That's what we're
trying to do.

00:07:56.601 --> 00:07:57.701
And it turns out
that Fan-in

00:07:57.701 --> 00:07:59.567
is actually
just a type of workflow.

00:07:59.567 --> 00:08:02.534
So you're saying, you know,
"Do this, then that,"

00:08:02.534 --> 00:08:04.267
or, "Wait," you know,
"Do this thing,

00:08:04.267 --> 00:08:05.868
then wait for these three
other things to finish."

00:08:05.868 --> 00:08:08.300
It's kind of
a general problem,

00:08:08.300 --> 00:08:10.033
and so if you've solve
the general problem--I know

00:08:10.033 --> 00:08:12.634
"workflow" is a dirty word,
but if you've, kind of,

00:08:12.634 --> 00:08:14.734
solved the workflow problem,

00:08:14.734 --> 00:08:18.968
then in a similar way it should
solve the Fan-in problem too.

00:08:18.968 --> 00:08:21.968
Okay. So hopefully
that makes sense.

00:08:21.968 --> 00:08:25.634
Are people with me so far?
So great. Okay.

00:08:25.634 --> 00:08:28.300
So I just want to talk about
some workflow Prior Art

00:08:28.300 --> 00:08:29.734
really quickly.

00:08:29.734 --> 00:08:31.634
Workflow is like content
management systems.

00:08:31.634 --> 00:08:32.868
It is the--
it's a dirty word.

00:08:32.868 --> 00:08:34.300
It's, like, a terrible thing.

00:08:34.300 --> 00:08:36.767
Like, don't ever say,
"I have created the world's

00:08:36.767 --> 00:08:39.734
foremost workflow engine,"
or, "content management system."

00:08:39.734 --> 00:08:42.234
Like, it's,
you know, terrible.

00:08:42.234 --> 00:08:46.534
Sorry, but-- And so I wanted
to kind of just throw some mud

00:08:46.534 --> 00:08:48.367
or basically show you
how I've been unhappy

00:08:48.367 --> 00:08:50.067
with the workflow tools
out there.

00:08:50.067 --> 00:08:52.167
I'm not trying to create
a generalized workflow platform.

00:08:52.167 --> 00:08:53.667
Don't worry.

00:08:53.667 --> 00:08:56.601
This is about data
and I'll get back to why.

00:08:56.601 --> 00:08:58.133
But, I wanted to just
kind of frame the context here

00:08:58.133 --> 00:08:59.367
a little bit.

00:08:59.367 --> 00:09:02.234
So the first one
is finite state machines.

00:09:02.234 --> 00:09:05.200
So I have had a
lot of experience building

00:09:05.200 --> 00:09:07.367
finite state machines
at Google.

00:09:07.367 --> 00:09:09.133
I built a cluster
management tool

00:09:09.133 --> 00:09:10.567
that I'll show you in a sec.

00:09:10.567 --> 00:09:13.567
The App Engine billing system is
mostly a finite state machine.

00:09:13.567 --> 00:09:14.801
There's a lot of
high-performance flows

00:09:14.801 --> 00:09:17.634
throughout Google
that are state machines.

00:09:17.634 --> 00:09:20.167
The problem is it's just
this explosion of states.

00:09:20.167 --> 00:09:22.501
You've got determinates
of behavior,

00:09:22.501 --> 00:09:26.000
you've got a small number
of states in the beginning,

00:09:26.000 --> 00:09:27.234
and then what happens
is every time

00:09:27.234 --> 00:09:29.133
you need to add a feature
you add more states,

00:09:29.133 --> 00:09:30.200
and you get this
kind of, like,

00:09:30.200 --> 00:09:33.467
combinatorial
explosion of behavior.

00:09:33.467 --> 00:09:35.567
It's really hard to work with
somebody else on something

00:09:35.567 --> 00:09:40.868
that has a, kind of,
finite state machine semantics.

00:09:40.868 --> 00:09:43.701
It's hard to have an interface.
It's hard to do reuse.

00:09:43.701 --> 00:09:45.334
It's very difficult
to test.

00:09:45.334 --> 00:09:47.501
There's tons of examples
out there.

00:09:47.501 --> 00:09:48.801
There's Fantasm
for App Engine,

00:09:48.801 --> 00:09:50.968
which we have an article about.
You should read about.

00:09:50.968 --> 00:09:53.133
I'm not trying to knock Fantasm
in particular.

00:09:53.133 --> 00:09:54.801
For certain thing--
for certain workloads

00:09:54.801 --> 00:09:57.000
finite state machines
are very good,

00:09:57.000 --> 00:09:58.834
but for the kind of thing
I wanted to do,

00:09:58.834 --> 00:10:01.934
I don't think
it's a good fit.

00:10:01.934 --> 00:10:03.767
Oozie is
the other one

00:10:03.767 --> 00:10:05.501
that is kind of like
a finite state machine.

00:10:05.501 --> 00:10:07.501
You describe, I swear,
you describe

00:10:07.501 --> 00:10:09.801
your whole state machine
in XML with, like,

00:10:09.801 --> 00:10:11.634
"if" statements in XML
and stuff like that,

00:10:11.634 --> 00:10:15.000
and it's really verbose.

00:10:15.000 --> 00:10:18.067
This is the state diagram
for my project

00:10:18.067 --> 00:10:20.300
that did cluster management.
This is not my state diagram,

00:10:20.300 --> 00:10:25.167
this is the one I replaced.
It's, like, 70 states,

00:10:25.167 --> 00:10:28.434
this deleted all of the error
states and error transitions,

00:10:28.434 --> 00:10:30.200
and they're like,
"Hey, maintain this."

00:10:30.200 --> 00:10:32.200
And it's--no.
I'm not going to do that.

00:10:32.200 --> 00:10:36.467
Like, I'm going to replace it
with something else. Right?

00:10:36.467 --> 00:10:39.934
So, okay, yeah.
so--alright, keep going.

00:10:39.934 --> 00:10:41.767
So another one's
work queues.

00:10:41.767 --> 00:10:45.801
This is very similar to
App Engine queues or Gearman,

00:10:45.801 --> 00:10:46.834
if you've heard of that.

00:10:46.834 --> 00:10:49.267
Producer style--
consumer style queues,

00:10:49.267 --> 00:10:50.734
everything's
a small chunk of, kind of,

00:10:50.734 --> 00:10:54.267
equal size or large,
you know, but equal size.

00:10:54.267 --> 00:10:56.934
The input and output's
really well defined.

00:10:56.934 --> 00:10:58.667
The big thing here is
that they're linear, you know,

00:10:58.667 --> 00:11:02.267
Do "A" then "B" then "C"
then "D" then "E," always.

00:11:02.267 --> 00:11:04.200
Or dump it
in the error bucket.

00:11:04.200 --> 00:11:06.133
And I think that work queues
work really well

00:11:06.133 --> 00:11:08.534
for that kind of stuff.

00:11:08.534 --> 00:11:10.200
I feel like
you see that a lot.

00:11:10.200 --> 00:11:11.601
But there's really
no control flow.

00:11:11.601 --> 00:11:13.567
If you need to branch off to
a whole different set of logic,

00:11:13.567 --> 00:11:15.901
that's very difficult to do,

00:11:15.901 --> 00:11:19.434
and so it's hard to test the
whole workflow from end to end

00:11:19.434 --> 00:11:23.367
if you need to try
variations of, you know,

00:11:23.367 --> 00:11:27.934
kind of, how to progress
through the workflow.

00:11:27.934 --> 00:11:29.267
Another kind is
Data dependencies.

00:11:29.267 --> 00:11:30.734
We have a bunch of
these at Google.

00:11:30.734 --> 00:11:33.868
Think about, like, "make,"
the semantics of a "make" file,

00:11:33.868 --> 00:11:37.968
but instead of being
"cc" files and ".o" files,

00:11:37.968 --> 00:11:40.100
it's input data
and output data,

00:11:40.100 --> 00:11:41.367
and instead of running
a compiler,

00:11:41.367 --> 00:11:44.300
you're running MapReduce
for eight hours.

00:11:44.300 --> 00:11:46.367
It's really cool.
It's really, really cool.

00:11:46.367 --> 00:11:48.167
The coolest thing it can do
is incremental builds.

00:11:48.167 --> 00:11:49.601
That's really cool.

00:11:49.601 --> 00:11:52.100
So you can say, okay, build
this hard thing once a day,

00:11:52.100 --> 00:11:54.467
build these small things
a hundred times a day,

00:11:54.467 --> 00:11:56.133
and then
with the final result,

00:11:56.133 --> 00:11:57.901
go spit out
some other output data.

00:11:57.901 --> 00:11:59.133
So that's--
that's really cool.

00:11:59.133 --> 00:12:01.834
It's great for that.
Zero control flow.

00:12:01.834 --> 00:12:04.000
It's, like,
totally declarative.

00:12:04.000 --> 00:12:06.968
You can't have any outside input
or intervention from a human.

00:12:06.968 --> 00:12:09.167
It has to be all files.

00:12:09.167 --> 00:12:11.267
You can only really
test it as black-box,

00:12:11.267 --> 00:12:13.501
so inputs and outputs.
Just look at the data.

00:12:13.501 --> 00:12:15.000
We haven't open-sourced
any of these

00:12:15.000 --> 00:12:17.968
because they're so tightly
coupled to their infrastructures

00:12:17.968 --> 00:12:21.400
so I don't expect to see
any of those out there.

00:12:21.400 --> 00:12:22.868
And the last one
is flow oriented,

00:12:22.868 --> 00:12:24.801
so this is Cascading.
If you've ever used Cascading,

00:12:24.801 --> 00:12:26.167
that's flow oriented.

00:12:26.167 --> 00:12:29.934
So you convert your data
into this tuple/tuple space,

00:12:29.934 --> 00:12:33.334
you define transforms
on the arbitrary tuples.

00:12:33.334 --> 00:12:35.167
It's awesome because
it automatically optimizes

00:12:35.167 --> 00:12:38.901
your code by figuring out
the graph of what you're doing

00:12:38.901 --> 00:12:42.000
in transforms and then, you
know, it'll merge, you know,

00:12:42.000 --> 00:12:45.000
certain operations and
do all kinds of cool stuff.

00:12:45.000 --> 00:12:47.434
I think that this
is really cool,

00:12:47.434 --> 00:12:48.868
but it's really complex,

00:12:48.868 --> 00:12:50.601
and you have to buy
into the religion

00:12:50.601 --> 00:12:52.934
that is flow processing.

00:12:52.934 --> 00:12:55.067
And for most people,
you--you know,

00:12:55.067 --> 00:12:57.267
this isn't even useful until you
get over a Terabyte of data,

00:12:57.267 --> 00:12:59.467
so you don't even need to do it.
Right?

00:12:59.467 --> 00:13:01.634
And there's no glue,
so you can't--

00:13:01.634 --> 00:13:04.501
at some point, you might just
need to shell out and, you know,

00:13:04.501 --> 00:13:07.968
download a file or, you know,
ca--you know, "cat"

00:13:07.968 --> 00:13:09.934
something or look at a list
somewhere, like, hit a--

00:13:09.934 --> 00:13:11.400
ping a server,
like, whatever.

00:13:11.400 --> 00:13:14.534
You need some kind of glue in
order to do certain workflows.

00:13:14.534 --> 00:13:16.033
I think
that's really important.

00:13:16.033 --> 00:13:18.100
So I think
this is cool, cool stuff,

00:13:18.100 --> 00:13:19.200
but I don't think
it's quite right

00:13:19.200 --> 00:13:21.100
for what I want it to do.

00:13:21.100 --> 00:13:25.033
Okay, so "How the Pipeline API
is different."

00:13:25.033 --> 00:13:28.734
So basically it took all,
kind of, these different systems

00:13:28.734 --> 00:13:31.467
that are already there
and tried to learn from them,

00:13:31.467 --> 00:13:34.067
and the other thing
that kind of carried--

00:13:34.067 --> 00:13:35.400
I carried--you know,
kind of carried into this

00:13:35.400 --> 00:13:37.534
was thinking about
functional languages

00:13:37.534 --> 00:13:40.400
like Erlang and--
and Haskell.

00:13:40.400 --> 00:13:41.601
And so one of
the coolest things

00:13:41.601 --> 00:13:44.801
about those besides the fact
that, you know,

00:13:44.801 --> 00:13:46.000
you have to use your brain
differently in order

00:13:46.000 --> 00:13:49.901
to use them is that
they are parallelizable.

00:13:49.901 --> 00:13:51.801
So when someone says,
"I like functional programming,"

00:13:51.801 --> 00:13:53.100
and you ask them why,
and it's like,

00:13:53.100 --> 00:13:54.767
"I like the style,"
it's like yes, that's--

00:13:54.767 --> 00:13:56.901
the style is cool.

00:13:56.901 --> 00:13:59.300
But the coolest reason
is that you can just,

00:13:59.300 --> 00:14:01.767
you know, when you do a
fold or something like that,

00:14:01.767 --> 00:14:04.000
it can run on
multiple machines.

00:14:04.000 --> 00:14:05.601
That's why it's cool;
it's parallelizable.

00:14:05.601 --> 00:14:06.834
That's the point.

00:14:06.834 --> 00:14:07.968
It's a first-class
part of the language,

00:14:07.968 --> 00:14:09.601
is the fact that it can
be optimized in ways

00:14:09.601 --> 00:14:12.200
you don't even understand,
and that's really cool.

00:14:12.200 --> 00:14:16.033
So I wanted to see, can
I carry over some of those ideas

00:14:16.033 --> 00:14:17.767
to languages
I like to use?

00:14:17.767 --> 00:14:19.400
I don't think I'm smart enough
to use Haskell.

00:14:19.400 --> 00:14:21.534
I've tried;
cannot do it.

00:14:21.534 --> 00:14:23.367
I don't know,
maybe there'd be,

00:14:23.367 --> 00:14:26.367
like a Haskell for Python
programmers kind of tutorial

00:14:26.367 --> 00:14:27.567
I could read.

00:14:27.567 --> 00:14:29.567
That would be nice,
but it's too hard.

00:14:29.567 --> 00:14:31.467
And so I wanted to
carry those over to--

00:14:31.467 --> 00:14:34.667
to Python and Java
and see, you know,

00:14:34.667 --> 00:14:37.033
what it could be like.

00:14:37.033 --> 00:14:38.501
Oh.

00:14:38.501 --> 00:14:43.000
I wanted to have--I wanted to
link back to the slides here.

00:14:43.000 --> 00:14:45.067
Just in case because with--
now it's, like, a lot of code.

00:14:45.067 --> 00:14:49.634
So "P2U2S" if you
want the slides.

00:14:49.634 --> 00:14:52.567
P2U2S.
So okay.

00:14:52.567 --> 00:14:54.467
So here are
my assumptions.

00:14:54.467 --> 00:14:56.601
I have a lot--
I have a lot of threads.

00:14:56.601 --> 00:14:58.701
I've got extremely
highly available storage,

00:14:58.701 --> 00:15:00.167
which is awesome.

00:15:00.167 --> 00:15:02.801
I've got elastic scaling--
scaling of dynamic instances,

00:15:02.801 --> 00:15:04.901
so the queues
will just spool them up.

00:15:04.901 --> 00:15:07.767
I've got apps for
thousands of instances,

00:15:07.767 --> 00:15:10.667
and I don't have to configure
any-- configure anything.

00:15:10.667 --> 00:15:14.133
I just--it just--
they just get spooled up,

00:15:14.133 --> 00:15:16.767
which is pretty crazy
assumptions.

00:15:16.767 --> 00:15:18.334
And then my goals
were kind of different

00:15:18.334 --> 00:15:19.434
than a lot of
other kind of workflow

00:15:19.434 --> 00:15:20.901
or data oriented engines.

00:15:20.901 --> 00:15:24.100
I didn't want to be
deterministic specifically.

00:15:24.100 --> 00:15:25.334
Functional testing

00:15:25.334 --> 00:15:27.567
was a core part of what
I wanted to be able to do.

00:15:27.567 --> 00:15:30.400
I wanted the components that you
generate to be fully reusable

00:15:30.400 --> 00:15:31.534
so that people
can actual--

00:15:31.534 --> 00:15:34.133
multiple teams can
actually build tools,

00:15:34.133 --> 00:15:37.634
like workflows that build
on the same data.

00:15:37.634 --> 00:15:41.100
I want it to be productionized,
so that's like having tools

00:15:41.100 --> 00:15:43.534
to look at the state of
the process as it's running,

00:15:43.534 --> 00:15:46.601
or to diagnose problems
when things fail,

00:15:46.601 --> 00:15:49.234
to have "back off"
and "retry, "

00:15:49.234 --> 00:15:50.400
and then I want it
to be minimal,

00:15:50.400 --> 00:15:51.801
so what's the minimal
number of tools

00:15:51.801 --> 00:15:55.167
I need in order
to build this.

00:15:55.167 --> 00:15:57.901
Non goals: static analysis.
I'm not doing that.

00:15:57.901 --> 00:16:00.000
Automatic optimization
I don't want to do.

00:16:00.000 --> 00:16:02.534
I'm not trying to make
a flow system.

00:16:02.534 --> 00:16:05.234
I'm not trying to create
sustainable flow rates,

00:16:05.234 --> 00:16:10.634
and I don't want to use XML.
I don't want BPEL in there.

00:16:10.634 --> 00:16:11.901
Yeah.

00:16:11.901 --> 00:16:14.067
Okay, so the types of work
I do want to do,

00:16:14.067 --> 00:16:15.501
so first of all is
synchronous work.

00:16:15.501 --> 00:16:19.767
So up until yesterday, up to 10
minutes was a task queue task.

00:16:19.767 --> 00:16:21.767
That was the limit.

00:16:21.767 --> 00:16:23.334
Now you can go
as long as you want

00:16:23.334 --> 00:16:27.167
as long as you have an
instant surround of a backend.

00:16:27.167 --> 00:16:29.300
So synchronous work
is what web service calls

00:16:29.300 --> 00:16:30.567
doing a lot of transactions,

00:16:30.567 --> 00:16:31.901
any kind of iteration
on the Datastore

00:16:31.901 --> 00:16:33.334
that takes a really long time.

00:16:33.334 --> 00:16:35.801
If you just want to write your
code in a straight line, do it.

00:16:35.801 --> 00:16:37.367
That's the first--

00:16:37.367 --> 00:16:38.934
that's the easiest and fastest
and first way to do anything,

00:16:38.934 --> 00:16:41.801
so just do it.
That's a great place to start.

00:16:41.801 --> 00:16:44.667
I want to be able to support
that work and let that code,

00:16:44.667 --> 00:16:46.767
like, run for a long time
if you want to--

00:16:46.767 --> 00:16:50.300
You know, you don't have to keep
maintaining it or something.

00:16:50.300 --> 00:16:52.501
Then I also want to allow for
asynchronous work.

00:16:52.501 --> 00:16:56.067
So fire off the work,
wait for a callback,

00:16:56.067 --> 00:16:58.968
and then tie-in with other
frameworks to you know,

00:16:58.968 --> 00:17:00.734
basically tell them to start

00:17:00.734 --> 00:17:02.300
and then have them call you back
when they're done

00:17:02.300 --> 00:17:04.767
and then hook into the rest
of the system like that.

00:17:04.767 --> 00:17:06.501
So MapReduce is
a good example of this.

00:17:06.501 --> 00:17:08.534
You know,
it takes hours to run.

00:17:08.534 --> 00:17:11.067
If you want to send
an email to users,

00:17:11.067 --> 00:17:12.100
this is a really simple one.

00:17:12.100 --> 00:17:14.000
Like, we have
exceptional things

00:17:14.000 --> 00:17:15.567
happen in production
all the time.

00:17:15.567 --> 00:17:17.300
If the process
had just told us,

00:17:17.300 --> 00:17:19.167
we would've been able
to tell it, like,

00:17:19.167 --> 00:17:21.234
"Here's what you should do.
Do the right thing."

00:17:21.234 --> 00:17:24.701
But we don't even really have
the tools to do that right now.

00:17:24.701 --> 00:17:26.767
So what I'd really like is
if I could run a MapReduce

00:17:26.767 --> 00:17:29.667
and it's like, hey, I just hit
a piece of data

00:17:29.667 --> 00:17:31.501
that's totally weird,
or something corrupted,

00:17:31.501 --> 00:17:32.734
or I don't know
what to do here.

00:17:32.734 --> 00:17:35.534
If it could just email me
with a "yes or no"

00:17:35.534 --> 00:17:37.534
and a description
of what it saw,

00:17:37.534 --> 00:17:38.968
and I could just click "yes"

00:17:38.968 --> 00:17:41.267
and then it would go back
to work, that'd be awesome.

00:17:41.267 --> 00:17:42.968
Or I could go
and look at the panel

00:17:42.968 --> 00:17:45.133
and say, "Oh, yes. Okay.
There's something wrong here.

00:17:45.133 --> 00:17:47.000
I'm going to diagnose
the problem right now,"

00:17:47.000 --> 00:17:49.434
it--while it's paused,
you know.

00:17:49.434 --> 00:17:51.434
So that's like,
that kind of asynchronous work

00:17:51.434 --> 00:17:53.567
is really important too.

00:17:53.567 --> 00:17:56.300
And then Webhooks, so
post-commit hooks on G.I.D

00:17:56.300 --> 00:17:57.734
or anything like that,

00:17:57.734 --> 00:17:59.334
I'd want to be able
to interface with.

00:17:59.334 --> 00:18:01.501
But, in the end it's all
about the coordination stuff,

00:18:01.501 --> 00:18:03.534
so it's--
I'm trying to build glue.

00:18:03.534 --> 00:18:04.968
I want to be able
to pass arguments

00:18:04.968 --> 00:18:08.701
between different functions
and--and--and pieces of work,

00:18:08.701 --> 00:18:11.300
and take their outputs and pass
them to other pieces of work.

00:18:11.300 --> 00:18:12.901
I want to be able to spawn
a lot of different child tasks

00:18:12.901 --> 00:18:14.300
and wait for them,

00:18:14.300 --> 00:18:16.601
and in the end I want
to make "joining" really easy

00:18:16.601 --> 00:18:19.133
so that first
diagram I had with the Maps

00:18:19.133 --> 00:18:20.501
on the left side,

00:18:20.501 --> 00:18:22.634
I want to make that process
of combining data together

00:18:22.634 --> 00:18:25.067
really easy.

00:18:25.067 --> 00:18:28.601
Okay, so let's talk about
making Python and Java parallel.

00:18:28.601 --> 00:18:29.801
Maybe I--
Ah, here's the slides.

00:18:29.801 --> 00:18:33.300
Yes. Okay.
That's where it is.

00:18:33.300 --> 00:18:34.467
So that's where they are.

00:18:34.467 --> 00:18:35.601
Okay, so let's
get into this.

00:18:35.601 --> 00:18:38.200
So I'm trying
to define a--I--

00:18:38.200 --> 00:18:40.467
trying to define
a subset of Python

00:18:40.467 --> 00:18:43.000
and a subset of Java
that can be parallelized

00:18:43.000 --> 00:18:45.501
but isn't wacky.

00:18:45.501 --> 00:18:48.133
So here's how it started.

00:18:48.133 --> 00:18:49.234
Alright.
So here's some Python.

00:18:49.234 --> 00:18:51.033
I have
three pipelines here.

00:18:51.033 --> 00:18:54.968
The first one is "Add," adds
"a" and "b," returns a value.

00:18:54.968 --> 00:18:58.334
"Multiply" multiplies "a"
and "b," returns a value.

00:18:58.334 --> 00:19:02.067
But then,
this linear function here

00:19:02.067 --> 00:19:03.567
is actually a
multi-stage pipeline with--

00:19:03.567 --> 00:19:05.567
that can be--well, this one
can't be parallelized,

00:19:05.567 --> 00:19:07.534
but you'll see
what's happening.

00:19:07.534 --> 00:19:13.367
So you may remember
a linear function is "y=mx+b."

00:19:13.367 --> 00:19:15.400
So here I'm saying "yield"--

00:19:15.400 --> 00:19:17.067
I'm using Python
"yield" statement--

00:19:17.067 --> 00:19:19.300
"yield"
and you multiply child pipeline.

00:19:19.300 --> 00:19:22.467
Give it the parameters
"x" and "slope."

00:19:22.467 --> 00:19:24.667
Take "mx,"
which is the future--

00:19:24.667 --> 00:19:26.534
it's a FutureValue--

00:19:26.534 --> 00:19:28.968
take that future
and then pass it to "add,"

00:19:28.968 --> 00:19:32.167
and then also add "offset,"
to there..

00:19:32.167 --> 00:19:35.033
Yield that job also,
and then, basically,

00:19:35.033 --> 00:19:37.300
return the result.

00:19:37.300 --> 00:19:40.534
So this is really
simple syntax,

00:19:40.534 --> 00:19:42.501
but what happens is that
"multiply" and "add"

00:19:42.501 --> 00:19:44.601
can actually be scheduled
to run in the future.

00:19:44.601 --> 00:19:47.434
They don't have to be run
synchronously.

00:19:47.434 --> 00:19:49.167
That's like, so it looks
like really simple code.

00:19:49.167 --> 00:19:50.934
It is.
That's the point, right?

00:19:50.934 --> 00:19:52.834
It almost looks
kind of stupid,

00:19:52.834 --> 00:19:54.934
but this--this style of just
allowing you to pass futures

00:19:54.934 --> 00:19:57.200
around lets you do
some really powerful things,

00:19:57.200 --> 00:19:59.367
which is really cool.

00:19:59.367 --> 00:20:00.634
The other thing
I wanted to do

00:20:00.634 --> 00:20:02.100
is make it
really easy to invoke.

00:20:02.100 --> 00:20:03.234
So now that I have
a linear function,

00:20:03.234 --> 00:20:05.167
I want to just pass
in some parameters,

00:20:05.167 --> 00:20:08.834
call start, and then
it'll give me back a handle

00:20:08.834 --> 00:20:10.534
to talk to this job later,

00:20:10.534 --> 00:20:12.000
and then later on
I can just say,

00:20:12.000 --> 00:20:15.200
"Hey, from this ID, give me
back that object from before."

00:20:15.200 --> 00:20:16.434
Check to see if it's done.

00:20:16.434 --> 00:20:18.667
If it is, then I can get--
I can hit the value

00:20:18.667 --> 00:20:20.667
and get the result.

00:20:20.667 --> 00:20:23.300
So I want to make it
really, really easy

00:20:23.300 --> 00:20:28.767
to start and receive
the output of these things.

00:20:28.767 --> 00:20:29.968
And then testing.

00:20:29.968 --> 00:20:31.334
I wanted testing to be
a first-class thing.

00:20:31.334 --> 00:20:36.167
So there's two parts to this.

00:20:36.167 --> 00:20:37.968
The first part
is on the bottom here.

00:20:37.968 --> 00:20:39.801
So start test.

00:20:39.801 --> 00:20:42.067
Because of the way
we're defining pipelines,

00:20:42.067 --> 00:20:44.300
you can run them in serial.

00:20:44.300 --> 00:20:46.534
So you can use
your Python debugger

00:20:46.534 --> 00:20:49.767
and just step through it.

00:20:49.767 --> 00:20:51.467
So if you have a problem,

00:20:51.467 --> 00:20:53.634
you can run in the whole
pipeline in test mode,

00:20:53.634 --> 00:20:55.767
does all the things
you think it should be doing,

00:20:55.767 --> 00:20:58.300
and then as soon as you get
an exception stack trace,

00:20:58.300 --> 00:20:59.701
the call stack at that point

00:20:59.701 --> 00:21:01.400
will be how
you actually got there

00:21:01.400 --> 00:21:03.033
through all of
the sub-pipelines.

00:21:03.033 --> 00:21:05.000
I've never seen a workflow
tool that can do that.

00:21:05.000 --> 00:21:07.434
That's really important to me
because that's the kind of stuff

00:21:07.434 --> 00:21:10.801
I need to debug
and then build new tests for.

00:21:10.801 --> 00:21:12.834
And then at the end, you
can just grab the values here

00:21:12.834 --> 00:21:14.767
and assert--make some assertions
about how the--

00:21:14.767 --> 00:21:17.067
how the pipeline ran.

00:21:17.067 --> 00:21:19.200
Further, though, sometimes
pipelines take too long

00:21:19.200 --> 00:21:21.801
or they have to hit external
resources that aren't there.

00:21:21.801 --> 00:21:24.067
So you want to have built--
in mocking facilities for that,

00:21:24.067 --> 00:21:25.467
which is what "run test" is.

00:21:25.467 --> 00:21:26.701
So "run test"
is a special method

00:21:26.701 --> 00:21:29.334
that's also there
that basically says,

00:21:29.334 --> 00:21:30.767
"Oh, when you run me
in testing mode,

00:21:30.767 --> 00:21:32.300
just do this behavior.

00:21:32.300 --> 00:21:33.801
It's good enough
of an approximation

00:21:33.801 --> 00:21:36.367
of the real thing for--
for our purposes of testing."

00:21:36.367 --> 00:21:37.367
Right?

00:21:37.367 --> 00:21:38.901
So for instance,
in MapReduce,

00:21:38.901 --> 00:21:41.667
the Mapper Framework,
when it has "run test"

00:21:41.667 --> 00:21:43.133
it doesn't have to add tasks,

00:21:43.133 --> 00:21:45.267
it doesn't have to do
any scheduling or quotas,

00:21:45.267 --> 00:21:46.634
it just takes the data,

00:21:46.634 --> 00:21:49.033
calls the map function
on it synchronously,

00:21:49.033 --> 00:21:51.267
and then
returns the result.

00:21:51.267 --> 00:21:52.834
So you don't have
to do all the work

00:21:52.834 --> 00:21:56.167
that you normally would do to--
to--to test the thing.

00:21:56.167 --> 00:21:59.367
You can make a fake.

00:21:59.367 --> 00:22:01.367
Okay. Yeah.

00:22:01.367 --> 00:22:03.801
Alright. So this is
the same thing for Java.

00:22:03.801 --> 00:22:06.367
So I'm trying to be,
you know,

00:22:06.367 --> 00:22:08.400
equal with my,
kind of, focus here.

00:22:08.400 --> 00:22:09.267
The font size
has to be small.

00:22:09.267 --> 00:22:10.467
What can I say?

00:22:10.467 --> 00:22:13.701
It is a little bit more verbose.
I'm sorry, guys.

00:22:13.701 --> 00:22:14.701
But--Yeah, bulk it up.

00:22:14.701 --> 00:22:15.701
Yeah.

00:22:15.701 --> 00:22:17.234
But, the--
[laughs]

00:22:17.234 --> 00:22:18.901
but, I will say for Java
this is pretty pithy,

00:22:18.901 --> 00:22:21.567
so it's the same thing.
"Add" and "multiply."

00:22:21.567 --> 00:22:25.434
They return two immediate
values, "a + b," "a x b,"

00:22:25.434 --> 00:22:28.300
and then we've got
that linear function which is--

00:22:28.300 --> 00:22:30.567
computes "mx"
and then passes "mx"

00:22:30.567 --> 00:22:35.267
to the "futureCall"
adding "mx + b."

00:22:35.267 --> 00:22:38.868
That's it.

00:22:38.868 --> 00:22:40.234
And the invocation
style's similar.

00:22:40.234 --> 00:22:41.968
You grab the service
from the factory,

00:22:41.968 --> 00:22:43.968
you start a new pipeline
with the simple parameters.

00:22:43.968 --> 00:22:48.634
Sometime later,
you take that "pipeline id",

00:22:48.634 --> 00:22:51.434
grab the certain job info,
look at the output,

00:22:51.434 --> 00:22:53.133
look at the sta--status,
see that it's done,

00:22:53.133 --> 00:22:57.033
look at the output.
Really simple, right?

00:22:57.033 --> 00:22:59.000
Java does not have a functional
testing piece yet,

00:22:59.000 --> 00:23:00.467
but that's something
we're working on.

00:23:00.467 --> 00:23:02.601
It'll come soon.
It'll work the same way

00:23:02.601 --> 00:23:04.767
where you can step
through the Java debugger

00:23:04.767 --> 00:23:09.334
to find where your code's
not working the way it should.

00:23:09.334 --> 00:23:11.234
Okay, so just to kind of clarify
what we're doing here,

00:23:11.234 --> 00:23:13.434
I want to talk about kind of
more of the specifics

00:23:13.434 --> 00:23:15.234
about how this thing works.

00:23:15.234 --> 00:23:18.400
So FutureValues.
What is a future?

00:23:18.400 --> 00:23:19.667
If you've ever done
asynchronous programmer,

00:23:19.667 --> 00:23:22.200
used Twisted Python
or anything like that,

00:23:22.200 --> 00:23:24.801
it's--FutureValues
are kind of a weird thing

00:23:24.801 --> 00:23:26.033
to get your head around

00:23:26.033 --> 00:23:28.667
and I think
Twisted Python programmers,

00:23:28.667 --> 00:23:32.033
they are constructed
differently often.

00:23:32.033 --> 00:23:33.334
As programmers,
they just,

00:23:33.334 --> 00:23:34.434
they think about things
very differently,

00:23:34.434 --> 00:23:35.834
much like functional
programmers think

00:23:35.834 --> 00:23:38.234
about things differently.

00:23:38.234 --> 00:23:40.467
But, I wanted the
Pipeline API to be really easy

00:23:40.467 --> 00:23:42.534
to understand and make it look
like procedural code,

00:23:42.534 --> 00:23:45.234
but there are still
restrictions.

00:23:45.234 --> 00:23:48.567
So FutureValues,
when you call "yield Multiply"

00:23:48.567 --> 00:23:52.133
and get back a result,
you can't access it right now.

00:23:52.133 --> 00:23:53.334
You can't do that.

00:23:53.334 --> 00:23:54.334
It'll raise an exception
that'll say,

00:23:54.334 --> 00:23:55.634
"You can't do this."

00:23:55.634 --> 00:23:56.934
You can't grab the value,

00:23:56.934 --> 00:23:59.400
and there's no way
to actually wait for it.

00:23:59.400 --> 00:24:00.501
So the function's
not even there.

00:24:00.501 --> 00:24:02.100
It's not even defined.

00:24:02.100 --> 00:24:04.067
But what you can do is
you can create another child

00:24:04.067 --> 00:24:05.400
that reads the result.

00:24:05.400 --> 00:24:07.934
So you can create a LogValue
that will log a value

00:24:07.934 --> 00:24:09.200
that's passed through it,

00:24:09.200 --> 00:24:12.467
and then you can pass
a future to that pipeline.

00:24:12.467 --> 00:24:15.167
So a really simple idea.

00:24:15.167 --> 00:24:17.167
This--this one works.

00:24:17.167 --> 00:24:20.534
So essentially anything that's
passed into your "run" method,

00:24:20.534 --> 00:24:23.634
you can access.
That's the gist of this.

00:24:23.634 --> 00:24:27.534
And this is what lets you
do all these cool things.

00:24:27.534 --> 00:24:29.167
So again,
immediate values,

00:24:29.167 --> 00:24:31.801
if you're past it
in your "run" method,

00:24:31.801 --> 00:24:33.100
then you can do anything
you want with it.

00:24:33.100 --> 00:24:35.234
You can do comparisons,
you can pass it to functions,

00:24:35.234 --> 00:24:38.133
whatever you want.
It's just a value.

00:24:38.133 --> 00:24:41.767
But, the key thing
here is that when you

00:24:41.767 --> 00:24:44.334
pass values
between different pipelines--

00:24:44.334 --> 00:24:47.067
so here I'm passing the output
of "Multiply" to "LogValue"--

00:24:47.067 --> 00:24:48.968
"Multiply" is going
to run in one task,

00:24:48.968 --> 00:24:51.234
totally on its own,
up to ten minute deadline,

00:24:51.234 --> 00:24:53.300
and "LogValue" is going
to run in its own task,

00:24:53.300 --> 00:24:56.834
totally separate,
for ten minutes.

00:24:56.834 --> 00:24:58.567
They're totally separated
from each other

00:24:58.567 --> 00:25:01.067
and the Pipeline API is
coordinating the communication

00:25:01.067 --> 00:25:03.334
of the results between them.

00:25:03.334 --> 00:25:08.434
Okay? It looks like procedural
code, but it's not.

00:25:08.434 --> 00:25:10.567
Java works the same way.

00:25:10.567 --> 00:25:12.434
You cannot access
the value of a future.

00:25:12.434 --> 00:25:13.434
It just doesn't work.

00:25:13.434 --> 00:25:15.000
So when you make
a "futureCall, "

00:25:15.000 --> 00:25:16.501
you can't call
a "getValue."

00:25:16.501 --> 00:25:18.200
There's no such method.

00:25:18.200 --> 00:25:21.834
But you can take that
value of the future

00:25:21.834 --> 00:25:24.100
and pass it to another
job, like "PrintIt,"

00:25:24.100 --> 00:25:26.167
which will then
print the value.

00:25:26.167 --> 00:25:29.100
So it works exactly
the same way.

00:25:29.100 --> 00:25:32.701
So just really simple semantics
for how to deal with futures.

00:25:35.834 --> 00:25:38.167
Java med--immediates
work exactly the same way.

00:25:38.167 --> 00:25:39.901
The only difference
is that you have to wrap them

00:25:39.901 --> 00:25:42.234
in this immediate
little function wrapper

00:25:42.234 --> 00:25:43.801
or method wrapper.

00:25:43.801 --> 00:25:45.434
We'll--we'll probably make
that shorter to like,

00:25:45.434 --> 00:25:47.968
"I," or something,
or "M" or--I--I don't know.

00:25:47.968 --> 00:25:49.767
Sometime.

00:25:49.767 --> 00:25:53.200
But that's all it takes.

00:25:53.200 --> 00:25:55.033
So let's talk about
why this works.

00:25:55.033 --> 00:25:56.200
This is--so this is--

00:25:56.200 --> 00:25:57.734
hopefully we'll now
clarify everything

00:25:57.734 --> 00:26:00.734
we've just been talking about.
So here's a pipeline.

00:26:00.734 --> 00:26:02.467
I'm sorry if I'm giving you
math flashbacks.

00:26:02.467 --> 00:26:04.968
Here's a polynomial function.

00:26:04.968 --> 00:26:09.133
You might remember
"A x 2 + B x + C" gives you

00:26:09.133 --> 00:26:12.367
some kind of polynomial,
some variety.

00:26:12.367 --> 00:26:15.133
So I have "Add" which
takes multiple values

00:26:15.133 --> 00:26:16.767
and sums them,
I have "Multiply"

00:26:16.767 --> 00:26:18.734
which will multiply multiple
values together.

00:26:18.734 --> 00:26:20.734
So this is kind of
the same things from before.

00:26:20.734 --> 00:26:24.234
And now I have
three child pipelines here.

00:26:24.234 --> 00:26:29.267
So "Ax = yield
Multiply (A, x, x),"

00:26:29.267 --> 00:26:32.267
then I have
"Bx = yield Multiply (B, x)."

00:26:32.267 --> 00:26:35.200
Now, what's really cool is
I can run those in parallel.

00:26:35.200 --> 00:26:37.400
And the Pipeline API
will do that.

00:26:37.400 --> 00:26:39.400
So when you yield those
two things and it's like,

00:26:39.400 --> 00:26:40.968
"Oh, I have no data
dependencies,"

00:26:40.968 --> 00:26:42.334
it just runs them.

00:26:42.334 --> 00:26:44.033
And they run
in two separate tasks--

00:26:44.033 --> 00:26:47.067
two separate tasks, with as much
of a deadline as they can have,

00:26:47.067 --> 00:26:48.334
and then when they're done,

00:26:48.334 --> 00:26:51.934
they pass the results back
and then the "Add" child

00:26:51.934 --> 00:26:53.434
gets kicked off,
which took it's--

00:26:53.434 --> 00:26:56.601
those results
and then it runs.

00:26:56.601 --> 00:26:59.133
So that's what I'm talking
about coordination in Fan-in.

00:26:59.133 --> 00:27:00.300
So let's go
through, like,

00:27:00.300 --> 00:27:02.467
a graphical version
of this, 'cause it--

00:27:02.467 --> 00:27:03.467
hopefully this'll
solidify

00:27:03.467 --> 00:27:05.334
what I'm talking about.

00:27:05.334 --> 00:27:06.801
So on the left are
immediate values,

00:27:06.801 --> 00:27:10.167
"A," "B," "X," and "C."
Okay?

00:27:10.167 --> 00:27:13.534
The green boxes are tasks.

00:27:13.534 --> 00:27:17.501
The blue Slots are data
that we're going to generate,

00:27:17.501 --> 00:27:19.334
and then we'll talk
about the Barrier.

00:27:19.334 --> 00:27:22.601
So straightaway, once
you say "Pipeline start,"

00:27:22.601 --> 00:27:23.801
it's like, "Well, okay.

00:27:23.801 --> 00:27:25.467
I've immediate values
on "Multiply."

00:27:25.467 --> 00:27:27.801
These guys are good to go."
It schedules tasks.

00:27:27.801 --> 00:27:30.501
The tasks run,
and when the tasks are done,

00:27:30.501 --> 00:27:32.801
they fill the Slots.

00:27:32.801 --> 00:27:35.067
The tasks can run in any order.
It doesn't matter.

00:27:35.067 --> 00:27:37.067
They can be item potent.
They might run multiple times.

00:27:37.067 --> 00:27:39.701
It doesn't matter. The--those
are the semantics of the API.

00:27:39.701 --> 00:27:42.434
And when each Slot is filled,
it'll notify the Barrier.

00:27:42.434 --> 00:27:44.934
The Barrier will wait
for both Slot A and B,

00:27:44.934 --> 00:27:47.067
in any order, to be done.

00:27:47.067 --> 00:27:49.868
Once they're both done,
it'll notify "Add"

00:27:49.868 --> 00:27:51.501
and will say, "Run."

00:27:51.501 --> 00:27:53.868
"Add" will then go find
the parameters it needs,

00:27:53.868 --> 00:27:55.801
pull them in Slot
"A," "B," and "C,"

00:27:55.801 --> 00:28:00.300
do what it needs to do,
and then fill Slot "C"

00:28:00.300 --> 00:28:02.501
and then it'll call you back
and basically say, "I'm done."

00:28:02.501 --> 00:28:06.267
And now you can go grab
the result of the polynomial.

00:28:06.267 --> 00:28:08.534
That's it.

00:28:08.534 --> 00:28:10.634
Make sense so far?
People getting it?

00:28:10.634 --> 00:28:12.434
Okay, cool.

00:28:12.434 --> 00:28:14.601
Okay, so demo--I have
like a small demo of this.

00:28:14.601 --> 00:28:20.601
Okay, so I have this--this
is my Favorite Color Guestbook.

00:28:20.601 --> 00:28:22.667
This is some--
a lot of data here.

00:28:22.667 --> 00:28:24.801
I know you came to see
large-scale data analysis,

00:28:24.801 --> 00:28:27.567
so I didn't--
did not fail to deliver here.

00:28:27.567 --> 00:28:30.734
So I've got, like,
at least 500 colors in here

00:28:30.734 --> 00:28:32.534
that people like,
I'm pretty sure.

00:28:32.534 --> 00:28:35.734
Anyway, so what you
can do is you can add a color,

00:28:35.734 --> 00:28:39.167
so you know, orange or--

00:28:39.167 --> 00:28:41.133
oh, there we go--
wireless is working, okay--

00:28:41.133 --> 00:28:43.501
azure is a great color.
I like that one.

00:28:43.501 --> 00:28:44.767
It's a really nice color.

00:28:44.767 --> 00:28:48.234
Okay, so I'll run
a reporting pipeline and--

00:28:48.234 --> 00:28:49.534
and so this says,

00:28:49.534 --> 00:28:51.000
"Send me an email of
the count of favorite colors."

00:28:51.000 --> 00:28:52.234
Okay?

00:28:52.234 --> 00:28:57.167
So let's just do the basic--
the basic kind.

00:28:57.167 --> 00:29:00.834
Three colors we like.
Blue. Alright.

00:29:00.834 --> 00:29:02.467
So you click "Run" and now
this is going to redirect us

00:29:02.467 --> 00:29:04.734
to this UI.

00:29:04.734 --> 00:29:05.834
I'm going to
turn off autopilot

00:29:05.834 --> 00:29:07.567
just so we don't
overwhelm ourselves.

00:29:07.567 --> 00:29:10.734
Okay, so what happens is,
the--the pipeline's now running

00:29:10.734 --> 00:29:12.334
and this is the production
interface and you--

00:29:12.334 --> 00:29:15.133
if you went to Mike Aizatskyi's
talk on MapReduce,

00:29:15.133 --> 00:29:16.534
it's the same UI.

00:29:16.534 --> 00:29:18.667
The UI is generated
from the callGraph.

00:29:18.667 --> 00:29:19.434
You don't have
to do anything.

00:29:19.434 --> 00:29:20.767
You just get the UI.

00:29:20.767 --> 00:29:22.300
It'--just--that's--
we just figure it out

00:29:22.300 --> 00:29:25.300
from how your code works.
That's the point.

00:29:25.300 --> 00:29:26.868
And the same UI is used
in Java and Python

00:29:26.868 --> 00:29:28.267
because it's all JavaScript.

00:29:28.267 --> 00:29:30.534
We just take the description
of your graph and we render it.

00:29:30.534 --> 00:29:32.801
That's all there is to it.

00:29:32.801 --> 00:29:35.067
And then it's got a bunch
of facilities in it, so--

00:29:35.067 --> 00:29:36.767
you--the--the pipeline
is going along here.

00:29:36.767 --> 00:29:40.567
I'll describe what it's doing.
You can watch it as it goes.

00:29:40.567 --> 00:29:43.300
You can see that the--
the current leftmost,

00:29:43.300 --> 00:29:45.834
newest pipeline is
selected automatically.

00:29:45.834 --> 00:29:49.634
That's part of what it does.
And, so it'll progress and--

00:29:49.634 --> 00:29:50.801
and we'll get into it.

00:29:50.801 --> 00:29:52.400
So the key--
the key things here, though,

00:29:52.400 --> 00:29:56.267
are that you--you--
you see every sub-stage

00:29:56.267 --> 00:29:58.834
that was created,

00:29:58.834 --> 00:30:00.634
you see how the parameters
were passed between them,

00:30:00.634 --> 00:30:01.934
you see
what the outputs were,

00:30:01.934 --> 00:30:03.367
you see who filled
the outputs.

00:30:03.367 --> 00:30:04.901
If I go down here to a task--

00:30:04.901 --> 00:30:06.033
You don't really have to know
what these are,

00:30:06.033 --> 00:30:07.601
but the point is--
Let me make this bigger.

00:30:07.601 --> 00:30:09.033
I'm sorry.

00:30:09.033 --> 00:30:11.267
So here's
an "Append" operation.

00:30:11.267 --> 00:30:13.734
"Append" is doing a Fan-out--
a Fan-in.

00:30:13.734 --> 00:30:15.601
It's taking
three different jobs

00:30:15.601 --> 00:30:18.367
and adding them all
into one list. Okay?

00:30:18.367 --> 00:30:21.667
And so here you can see
the first value is filled

00:30:21.667 --> 00:30:23.367
by this "LongCount" operation,

00:30:23.367 --> 00:30:25.701
the second value is filled
by this other one,

00:30:25.701 --> 00:30:28.434
and the th--and the third one
is filled by this other one,

00:30:28.434 --> 00:30:30.200
and then "Append"
just mashed them all together

00:30:30.200 --> 00:30:32.133
and then
it outputted something--

00:30:32.133 --> 00:30:33.801
output something here.

00:30:33.801 --> 00:30:36.667
So you--you can inspect
your own call graph as it ran,

00:30:36.667 --> 00:30:38.467
then you'd be, like,
"Hey, why did this break?

00:30:38.467 --> 00:30:39.767
What happened?

00:30:39.767 --> 00:30:41.834
Why am I in "retry"
or "backoff"?"

00:30:41.834 --> 00:30:43.200
And by--by default,

00:30:43.200 --> 00:30:45.901
Pipeline API will actually email
you when something breaks.

00:30:45.901 --> 00:30:49.300
So you, like,
you have to turn that off.

00:30:49.300 --> 00:30:50.634
And you can click around,
so you can be, like,

00:30:50.634 --> 00:30:51.901
"Oh, "LongCount,"
what did that do?"

00:30:51.901 --> 00:30:54.701
And you can click on it
and it goes there and so on.

00:30:54.701 --> 00:30:59.234
So I'm going to
run this again, if I can.

00:30:59.234 --> 00:31:03.701
Da, da, da--

00:31:03.701 --> 00:31:04.834
Let's see.

00:31:04.834 --> 00:31:06.200
How many times
do I need to push "back"?

00:31:06.200 --> 00:31:07.400
This is a bug.
It's the "back" button.

00:31:07.400 --> 00:31:09.100
What can I say?

00:31:09.100 --> 00:31:10.667
Oh, you know what's good
is just deleting

00:31:10.667 --> 00:31:12.300
the URL bar.

00:31:12.300 --> 00:31:16.601
Okay. So
try this again.

00:31:16.601 --> 00:31:18.434
I want to just highlight
another part of this

00:31:18.434 --> 00:31:21.167
which is the--the--kind of--
the production piece which is,

00:31:21.167 --> 00:31:23.734
when I run the pipeline--
there's a pipeline here.

00:31:23.734 --> 00:31:25.033
You'll see
it turns yellow.

00:31:25.033 --> 00:31:26.100
That's one that's
in the "retry" state.

00:31:26.100 --> 00:31:27.133
I have one here
that just automatically

00:31:27.133 --> 00:31:28.300
just raises an exception,

00:31:28.300 --> 00:31:29.934
just to show
what it looks like.

00:31:29.934 --> 00:31:31.400
So you'll see it
on the left here.

00:31:31.400 --> 00:31:33.367
It's a useless pipeline,
and it's, like, it just--

00:31:33.367 --> 00:31:37.234
it just "errored,"
and it's going to--it's like,

00:31:37.234 --> 00:31:39.934
here's the exception string.
So "Whoops, I need to retry,"

00:31:39.934 --> 00:31:42.367
is what it said,
and it's retrying

00:31:42.367 --> 00:31:44.467
and it says
it'll run in 14 seconds.

00:31:44.467 --> 00:31:45.734
And if you click here,

00:31:45.734 --> 00:31:47.434
it says, well,
it's going to run in one second,

00:31:47.434 --> 00:31:49.834
and then the second time around
it runs, and then it's done.

00:31:49.834 --> 00:31:54.200
And this is just all on the task
queue in the background.

00:31:54.200 --> 00:31:55.367
Now, what this thing
actually does,

00:31:55.367 --> 00:31:58.167
I can describe
really quickly.

00:31:58.167 --> 00:32:00.501
What happens is, there's
a function that gets called

00:32:00.501 --> 00:32:01.934
called "SplitCount."

00:32:01.934 --> 00:32:05.634
"SplitCount" says,
"I have these guestbook posts.

00:32:05.634 --> 00:32:07.667
They have an attribute
called "color."

00:32:07.667 --> 00:32:10.033
I want to know the counts
for red and blue."

00:32:10.033 --> 00:32:13.200
So it'll go and it'll spit out
two child pipelines

00:32:13.200 --> 00:32:14.634
that do LongCounts,

00:32:14.634 --> 00:32:17.767
that just basically do a query
and just keep going, iterating,

00:32:17.767 --> 00:32:19.267
until it gets to the end.

00:32:19.267 --> 00:32:20.701
And so they'll count
up to 10,000

00:32:20.701 --> 00:32:23.067
or it's for ten minutes,
or as long as you want.

00:32:23.067 --> 00:32:24.801
With cursors,
you can just keep going,

00:32:24.801 --> 00:32:27.100
so you can count
as many objects as you want

00:32:27.100 --> 00:32:30.367
and do that--do that
report generation.

00:32:30.367 --> 00:32:31.701
And then finally,
when LongCount's done,

00:32:31.701 --> 00:32:33.534
it's like,
"I have the answer."

00:32:33.534 --> 00:32:36.234
It says it's done,
the output gets set out,

00:32:36.234 --> 00:32:39.567
and then it goes
and tells all of its--

00:32:39.567 --> 00:32:40.968
all of its
dependent pipelines.

00:32:40.968 --> 00:32:42.167
So here's "Append."

00:32:42.167 --> 00:32:45.400
"Append" waits for those
two, like I said before,

00:32:45.400 --> 00:32:48.501
and then at the very end,
basically,

00:32:48.501 --> 00:32:50.567
there's an aggregation
of all those reports

00:32:50.567 --> 00:32:53.033
across all the different tasks
down into this email

00:32:53.033 --> 00:32:54.767
and the email basically says,
"Hey, here's--

00:32:54.767 --> 00:32:56.200
here's Brett's email address.

00:32:56.200 --> 00:32:57.901
Send him an email
with this report.

00:32:57.901 --> 00:33:01.868
We found 97 red
and 130 blue" Okay?

00:33:01.868 --> 00:33:03.167
So it--it--
it--what--what--

00:33:03.167 --> 00:33:04.534
what this actually does
is totally stupid.

00:33:04.534 --> 00:33:06.300
The point is
that you have the tools

00:33:06.300 --> 00:33:07.834
to look at all of
the different parameters,

00:33:07.834 --> 00:33:10.067
how they're passed,
how much time they took,

00:33:10.067 --> 00:33:12.601
why they--why they went
into an error state,

00:33:12.601 --> 00:33:13.767
et cetera, et cetera.

00:33:13.767 --> 00:33:15.234
So it's a really
nice debugging tool.

00:33:15.234 --> 00:33:18.234
You can also can--add consoles
and links to every single job

00:33:18.234 --> 00:33:19.534
in a status message.

00:33:19.534 --> 00:33:23.400
So you can have a graph here
of how things are going.

00:33:23.400 --> 00:33:26.334
And, I think I have
a word count demo.

00:33:26.334 --> 00:33:28.434
So here's, like,
a more advanced--

00:33:28.434 --> 00:33:29.434
Let's see if that loads.

00:33:29.434 --> 00:33:34.200
If that loads,
that'd be cool.

00:33:34.200 --> 00:33:36.701
Really?
Oh, there it is. Okay.

00:33:36.701 --> 00:33:37.934
So here's,
like, another--

00:33:37.934 --> 00:33:39.234
this is like a hacked-up
word count pipeline I had

00:33:39.234 --> 00:33:41.834
from some other time.

00:33:41.834 --> 00:33:44.801
But what's cool here
is you can see, like,

00:33:44.801 --> 00:33:45.968
here's a shuffler--
Oh, wait.

00:33:45.968 --> 00:33:47.701
That's not a good example.

00:33:47.701 --> 00:33:50.400
Da da da da.

00:33:50.400 --> 00:33:51.434
So here's, like,
the Mapper Framework

00:33:51.434 --> 00:33:54.367
running inside the Pipeline API.
Okay?

00:33:54.367 --> 00:33:58.000
So the point is
that, you know,

00:33:58.000 --> 00:34:00.534
you can do all kinds of
really cool stuff here

00:34:00.534 --> 00:34:01.968
just creating
consoles for yourself,

00:34:01.968 --> 00:34:03.667
and it just kind of
builds the UI for you.

00:34:03.667 --> 00:34:04.968
You don't have to,
like, worry about that.

00:34:04.968 --> 00:34:06.767
Oh, and it reloads
and automatically--

00:34:06.767 --> 00:34:08.434
that's the autopilot feature--
it reloads

00:34:08.434 --> 00:34:10.934
and automatically finds
the next cool thing to look at.

00:34:10.934 --> 00:34:13.133
So it's pretty nice.

00:34:13.133 --> 00:34:16.701
That's--
that just comes for free.

00:34:16.701 --> 00:34:18.000
Okay, so let's talk
about a few more, kind of,

00:34:18.000 --> 00:34:22.367
details of what
the Pipeline API can do,

00:34:22.367 --> 00:34:26.033
and then we'll get back to
our motivating example.

00:34:26.033 --> 00:34:29.534
So Fan-out.
Again, this is really simple.

00:34:29.534 --> 00:34:31.667
I want to send
a bunch of emails to people.

00:34:31.667 --> 00:34:34.434
Sometimes emails happen to
take a long time to send,

00:34:34.434 --> 00:34:36.868
or, you know,
you have to retry.

00:34:36.868 --> 00:34:39.434
So here I have
an "EmailInvites" pipeline.

00:34:39.434 --> 00:34:42.167
It takes an "event id," it goes
to the Datastore, gets it.

00:34:42.167 --> 00:34:43.567
It goes through all the people
who are invited

00:34:43.567 --> 00:34:44.767
and then it sends
an email to them.

00:34:44.767 --> 00:34:47.968
It yields a child
for each one.

00:34:47.968 --> 00:34:50.934
For each "to" address,
send them an email.

00:34:50.934 --> 00:34:52.467
Alright?
Pretty simple.

00:34:52.467 --> 00:34:54.567
The cool thing is
that this code,

00:34:54.567 --> 00:34:56.968
"EmailInvites"
will run linearly.

00:34:56.968 --> 00:34:58.434
It'll just run through.

00:34:58.434 --> 00:34:59.901
Every time you yield a child,
that will

00:34:59.901 --> 00:35:02.167
get scheduled for running
in the future,

00:35:02.167 --> 00:35:04.434
and then as soon
as this finishes,

00:35:04.434 --> 00:35:06.968
all the children
will start running.

00:35:06.968 --> 00:35:10.667
It'll just kick off.

00:35:10.667 --> 00:35:12.734
Fan-in is also
similarly interesting.

00:35:12.734 --> 00:35:15.434
So I had this great idea
for a search engine.

00:35:15.434 --> 00:35:19.234
I want to take the--the word
count of every link on the page,

00:35:19.234 --> 00:35:20.701
like, what it links to,

00:35:20.701 --> 00:35:23.067
and that's how you determine
the quality of the current page.

00:35:23.067 --> 00:35:24.667
So if you've got more links

00:35:24.667 --> 00:35:26.934
to content that's bigger,
it's better.

00:35:26.934 --> 00:35:29.434
That's my, like,
million dollar idea here.

00:35:29.434 --> 00:35:31.868
So I--I built the beginnings
of this search engine.

00:35:31.868 --> 00:35:34.934
I have a new pipeline
called "WordCountURL."

00:35:34.934 --> 00:35:37.267
It goes and fetches a URL
and it splits the data

00:35:37.267 --> 00:35:39.234
and counts how many words
are on it,

00:35:39.234 --> 00:35:40.534
and then returns
that value.

00:35:40.534 --> 00:35:42.300
So that's the top.
That's synchronous.

00:35:42.300 --> 00:35:43.434
That could take
ten minutes,

00:35:43.434 --> 00:35:44.901
or maybe it'll take
30 minutes,

00:35:44.901 --> 00:35:47.400
maybe you want to do some more
interesting processing on it.

00:35:47.400 --> 00:35:48.901
The--it doesn't
really matter.

00:35:48.901 --> 00:35:52.467
I've got a "sum" pipeline that
just adds up a bunch of values,

00:35:52.467 --> 00:35:55.100
and then I have
my search engine pipeline.

00:35:55.100 --> 00:35:56.868
It says,
"Hey, here's a bunch of URLs

00:35:56.868 --> 00:36:00.000
I found in this page.
Please go fetch all of them,

00:36:00.000 --> 00:36:02.100
count up how many words
are on each one,

00:36:02.100 --> 00:36:04.968
sum them together,
and then return the result."

00:36:04.968 --> 00:36:07.000
So you do a "for" loop
through the URLs,

00:36:07.000 --> 00:36:09.501
you yield the child pipeline
for all of them,

00:36:09.501 --> 00:36:13.067
and then you sum the results
of all the children.

00:36:13.067 --> 00:36:16.501
So this is a barrier
on all of the child pipelines.

00:36:16.501 --> 00:36:19.567
All of the different
"WordCountURL" child pipelines,

00:36:19.567 --> 00:36:21.734
they'll all go out and run

00:36:21.734 --> 00:36:23.801
and then once all of them
have completed,

00:36:23.801 --> 00:36:25.667
all of the answers
will be aggregated together

00:36:25.667 --> 00:36:27.067
and then handed to "Sum."

00:36:27.067 --> 00:36:28.901
"Sum" will add them up
and then say,

00:36:28.901 --> 00:36:30.567
"Here's the total,"
and then "MyPipeline"

00:36:30.567 --> 00:36:33.400
will complete the total.
So that's Fan-in.

00:36:33.400 --> 00:36:34.934
I mean,
it's really simple.

00:36:34.934 --> 00:36:37.467
This shouldn't look like much
because it's not,

00:36:37.467 --> 00:36:39.734
but you can do
really powerful things

00:36:39.734 --> 00:36:44.601
just with
that simple mechanism.

00:36:44.601 --> 00:36:45.634
Sequencing
is another thing

00:36:45.634 --> 00:36:46.901
you need to do.

00:36:46.901 --> 00:36:49.234
So you want to say,
"Run "JobA" then run "JobB,"

00:36:49.234 --> 00:36:50.400
and once they're both--
you know,

00:36:50.400 --> 00:36:52.167
after both of those,
go clean up some files

00:36:52.167 --> 00:36:54.067
I accidentally wrote
along the way.

00:36:54.067 --> 00:36:55.234
And then after that,
you know,

00:36:55.234 --> 00:36:57.968
update the dashboard
and email the team."

00:36:57.968 --> 00:36:59.501
Sometimes you just
want to do stuff in order

00:36:59.501 --> 00:37:00.868
if you don't have
any data dependencies,

00:37:00.868 --> 00:37:05.734
so you have a way
of describing that.

00:37:05.734 --> 00:37:08.801
Okay, that same stuff in Java.
Fan-out.

00:37:08.801 --> 00:37:10.000
"SendEmail"
is the same thing.

00:37:10.000 --> 00:37:11.801
We don't really
have to look at it.

00:37:11.801 --> 00:37:13.434
"SendInvites,"
same thing again.

00:37:13.434 --> 00:37:15.601
I pass in the serializeable
invite object

00:37:15.601 --> 00:37:18.000
that's got
some properties.

00:37:18.000 --> 00:37:21.100
It goes through,
spawns a child for each one.

00:37:21.100 --> 00:37:22.467
That's all there is to it.

00:37:22.467 --> 00:37:24.267
This fans out,
they all run immediately.

00:37:24.267 --> 00:37:26.400
It's great.

00:37:26.400 --> 00:37:27.868
And then, same thing
with Fan-in.

00:37:27.868 --> 00:37:29.868
So with Fan-in,
I've got--

00:37:29.868 --> 00:37:34.067
here I've got the "WordCountURL"
and "Sum" again.

00:37:34.067 --> 00:37:35.200
In Java I've got to get
a few more things.

00:37:35.200 --> 00:37:36.934
I've got to get some
"UTF-8" in there,

00:37:36.934 --> 00:37:38.934
got to get some kind of,
like, factories,

00:37:38.934 --> 00:37:40.300
but, you know, not so bad.

00:37:40.300 --> 00:37:42.300
I had to go on the next page.
What can I say?

00:37:42.300 --> 00:37:46.400
But, here again you see
I have a list of results.

00:37:46.400 --> 00:37:51.467
I call "WordCountURL"
for each URL that I received,

00:37:51.467 --> 00:37:53.367
and then I take the list

00:37:53.367 --> 00:37:59.033
and I pass it to "Sum"
and I return that at the bottom.

00:37:59.033 --> 00:38:04.267
So Fan-in is also very easy
to describe in Java.

00:38:04.267 --> 00:38:05.467
This making sense
so far to people?

00:38:05.467 --> 00:38:09.200
Also? Okay.
Cool.

00:38:09.200 --> 00:38:10.801
And sequencing on Java
is exactly the same.

00:38:10.801 --> 00:38:12.033
You have another parameter,

00:38:12.033 --> 00:38:14.767
you can say, "waitFor(a),"
so you don't--

00:38:14.767 --> 00:38:15.901
you don't have to have
data dependencies.

00:38:15.901 --> 00:38:20.000
You can just say,
"Do this after that."

00:38:20.000 --> 00:38:24.167
And then, let's talk about
asynchronous real quick.

00:38:24.167 --> 00:38:25.868
This is the silliest
asynchronous pipeline

00:38:25.868 --> 00:38:28.267
you could make.
It's just a delay.

00:38:28.267 --> 00:38:30.534
"Do something after
five seconds," right?

00:38:30.534 --> 00:38:32.400
So all this does is,
when you run it,

00:38:32.400 --> 00:38:35.334
it says how many seconds
to run for.

00:38:35.334 --> 00:38:36.934
It enqueues a task,
a callback task,

00:38:36.934 --> 00:38:38.701
which is built into
the system,

00:38:38.701 --> 00:38:41.801
says "Count down the seconds,
call me back,"

00:38:41.801 --> 00:38:45.300
and then, you know,
it enqueues it,

00:38:45.300 --> 00:38:47.434
and the pipeline A--
API has built-in routing

00:38:47.434 --> 00:38:49.601
to call you back
on your actual object.

00:38:49.601 --> 00:38:51.167
It'll reconstruct
the object for you

00:38:51.167 --> 00:38:54.000
and then dump you into,
kind of, the exactly--

00:38:54.000 --> 00:38:55.300
the state you
were in before,

00:38:55.300 --> 00:38:57.501
and then "run"
you right there.

00:38:57.501 --> 00:38:59.067
So when you get called here,

00:38:59.067 --> 00:39:01.434
"self" has all the different
methods you're used to

00:39:01.434 --> 00:39:04.667
and it feels like you're in
the same pipeline again.

00:39:04.667 --> 00:39:07.801
So--so this is also how
we execute the Mapper Framework

00:39:07.801 --> 00:39:09.167
in the Pipeline API and so on.

00:39:09.167 --> 00:39:11.234
And anything that's asynchronous
you can run this way.

00:39:11.234 --> 00:39:12.834
Any toolkit you've already
built that's asynchronous,

00:39:12.834 --> 00:39:14.100
you can run it this way.

00:39:14.100 --> 00:39:15.834
So this is how you connect
to existing tools.

00:39:15.834 --> 00:39:18.767
It's just like,
"I'm going to run,"

00:39:18.767 --> 00:39:23.334
schedule some stuff to happen,
give that stuff a callback.

00:39:23.334 --> 00:39:24.667
It's opaque--
just, you know,

00:39:24.667 --> 00:39:26.801
enqueue a task
that looks like this,

00:39:26.801 --> 00:39:28.267
so whatever framework
you're using

00:39:28.267 --> 00:39:31.167
can then enqueue that task,
and when that framework's done,

00:39:31.167 --> 00:39:32.968
the task goes in,
it calls me back,

00:39:32.968 --> 00:39:34.868
and then the callback
function runs,

00:39:34.868 --> 00:39:37.100
and then it can figure
out what it needs to do.

00:39:37.100 --> 00:39:39.801
It can move to the next state,
you can do multiple callbacks

00:39:39.801 --> 00:39:41.267
for every asynchronous worker.

00:39:41.267 --> 00:39:43.167
It's totally up to you
what you do here,

00:39:43.167 --> 00:39:46.667
so it's just--
this is the kind of the way to,

00:39:46.667 --> 00:39:50.400
like, connect into other pieces.
Java has the same thing.

00:39:50.400 --> 00:39:51.868
It's done
a little differently.

00:39:51.868 --> 00:39:53.667
In Java,
we actually have "Promises."

00:39:53.667 --> 00:39:55.000
So "Promises"
are like "Futures,"

00:39:55.000 --> 00:39:58.400
but they're like "Futures"
from somebody else.

00:39:58.400 --> 00:39:59.834
So this is a "Promise"
that somebody else

00:39:59.834 --> 00:40:01.334
will fill this value.

00:40:01.334 --> 00:40:04.667
So in this example,
I have an--I have something

00:40:04.667 --> 00:40:07.200
that I want to go find out
everybody's favorite color.

00:40:07.200 --> 00:40:09.300
Okay?
So I send them an email.

00:40:09.300 --> 00:40:10.701
I have their address,
send them an email,

00:40:10.701 --> 00:40:15.868
say, "Hey, here's your token,"
and then with that--

00:40:15.868 --> 00:40:17.801
with that token
I want to then save the color

00:40:17.801 --> 00:40:20.167
that somebody gave me.

00:40:20.167 --> 00:40:23.901
So see the bottom
"futureCall(new SaveColor()"?

00:40:23.901 --> 00:40:25.501
So that's--that's the--
the piece that actually

00:40:25.501 --> 00:40:27.434
uses the--
the "Promised" value,

00:40:27.434 --> 00:40:29.167
and then what this means
is that some other agent,

00:40:29.167 --> 00:40:31.567
some other framework,
some web request handler--

00:40:31.567 --> 00:40:32.567
it doesn't matter--

00:40:32.567 --> 00:40:34.400
can call
"submitPromisedValue"

00:40:34.400 --> 00:40:36.701
anytime in the future
using that token.

00:40:36.701 --> 00:40:38.667
As soon as it
submits that value,

00:40:38.667 --> 00:40:41.334
the "SaveColor" pipeline
will get kicked off.

00:40:41.334 --> 00:40:42.667
So it's all, kind of,
event-driven

00:40:42.667 --> 00:40:47.400
based on data dependencies.

00:40:47.400 --> 00:40:50.400
And then, finally, I--
Sorry.

00:40:50.400 --> 00:40:53.901
Half-- one before finally,
there's "Finalized," which is,

00:40:53.901 --> 00:40:55.968
sometimes you've jut got to do
something when you're done.

00:40:55.968 --> 00:40:57.267
So MapReduce, you've always
got to delete files

00:40:57.267 --> 00:40:58.400
when you're done.

00:40:58.400 --> 00:41:00.167
So the Pipeline API
just has that built in.

00:41:00.167 --> 00:41:02.634
"Finalize," you know,
"Map," "Shuffle," "Reduce,"

00:41:02.634 --> 00:41:04.634
and then delete all
the blobstore files

00:41:04.634 --> 00:41:06.033
that were passed
into this thing.

00:41:06.033 --> 00:41:07.300
So that's built--

00:41:07.300 --> 00:41:10.767
that's a primary feature
of the system.

00:41:10.767 --> 00:41:12.567
And then, finally, there's
the "Production" part,

00:41:12.567 --> 00:41:14.200
which is basically, like,
you need to be able to

00:41:14.200 --> 00:41:16.234
abort a pipeline
all the way to the root,

00:41:16.234 --> 00:41:17.834
you need to be able
to retry a pipeline,

00:41:17.834 --> 00:41:19.367
you need to be
able to set status,

00:41:19.367 --> 00:41:20.601
you need to be able to do
it from the inside

00:41:20.601 --> 00:41:23.234
or from the outside.
All these tools are there.

00:41:23.234 --> 00:41:24.934
So if you've ever dealt with
workflows in "Production,"

00:41:24.934 --> 00:41:26.534
these are the tools
I've always wanted,

00:41:26.534 --> 00:41:30.000
and so they're all there
for you to use.

00:41:30.000 --> 00:41:31.133
So language differences.

00:41:31.133 --> 00:41:33.934
So coming to Java,
functional testing,

00:41:33.934 --> 00:41:35.367
some production optimization
of the way

00:41:35.367 --> 00:41:39.200
that the entities are
constructed, status, links,

00:41:39.200 --> 00:41:40.367
integration with
Mapper Framework

00:41:40.367 --> 00:41:44.100
to make full MapReduce
for App Engine Java.

00:41:44.100 --> 00:41:46.534
Maybe we'll add "Finalized."

00:41:46.534 --> 00:41:47.968
Python has support
for named return values.

00:41:47.968 --> 00:41:49.234
It's a pretty
advanced feature.

00:41:49.234 --> 00:41:51.534
You can check it out.
Probably won't add that.

00:41:51.534 --> 00:41:53.767
Java ha--can serialize
anything, which is cool,

00:41:53.767 --> 00:41:56.000
so Java has this edge
where you can just pass

00:41:56.000 --> 00:41:57.367
all your classes around.

00:41:57.367 --> 00:42:00.534
In Python, you can only
use JSON-able types.

00:42:00.534 --> 00:42:02.801
Okay? So that's--you can't
pass raw objects though,

00:42:02.801 --> 00:42:06.100
you have to have something
that can be serialized in JSON.

00:42:06.100 --> 00:42:07.868
Python probably won't
add promises either,

00:42:07.868 --> 00:42:12.334
because that's not
really the style.

00:42:12.334 --> 00:42:16.701
So let's get back to
this data join example.

00:42:16.701 --> 00:42:18.367
So this has
been kind of a moving target

00:42:18.367 --> 00:42:23.367
over the last few weeks.
So I'm going to--

00:42:23.367 --> 00:42:25.100
Well, I'll get to it
in a second, but--

00:42:25.100 --> 00:42:26.367
So this is the big
diagram I had

00:42:26.367 --> 00:42:29.367
at the beginning,
if you remember.

00:42:29.367 --> 00:42:32.200
Again, we Map
the "Category," "Item,"

00:42:32.200 --> 00:42:34.701
"Sales" on the left, so
those would be child pipelines

00:42:34.701 --> 00:42:37.033
that would get
run doing Maps.

00:42:37.033 --> 00:42:39.467
The outputs of all those
would then get joined

00:42:39.467 --> 00:42:41.000
into one Shuffle,

00:42:41.000 --> 00:42:44.734
and then the Shuffle output
would be passed to Reduce,

00:42:44.734 --> 00:42:47.200
then the Reduce output
would get passed to a Map,

00:42:47.200 --> 00:42:48.400
and then the Map
would get passed

00:42:48.400 --> 00:42:50.067
to another Shuffle
and another Reduce. Okay?

00:42:50.067 --> 00:42:53.000
So you can see, the first
part is really the join here.

00:42:53.000 --> 00:42:55.234
You can imagine other things
being joined in

00:42:55.234 --> 00:42:57.868
at other parts along the way.
Okay?

00:42:57.868 --> 00:42:59.167
So this is, like,
the simplest graph I can make,

00:42:59.167 --> 00:43:00.968
but you can think of
a lot of other, kind of,

00:43:00.968 --> 00:43:04.667
crazy graphs with
a lot of other inputs.

00:43:04.667 --> 00:43:08.167
But--so earlier today,
Mike Aizatskyi pushed out--

00:43:08.167 --> 00:43:10.667
who is my colleague--
pushed out the Mapper--

00:43:10.667 --> 00:43:13.067
MapR--full MapReduce
for App Engine

00:43:13.067 --> 00:43:15.200
using the Mapper Framework
and Pipeline API together.

00:43:15.200 --> 00:43:18.734
It's in the projects,
and I wanted to show you

00:43:18.734 --> 00:43:24.100
how you'd describe this whole
workflow using his system,

00:43:24.100 --> 00:43:26.767
and using the Pipeline API.
So the moving target thing

00:43:26.767 --> 00:43:29.934
I was talking about is that,
wha--what the IP--

00:43:29.934 --> 00:43:32.501
API that Mike's pushed out
has been a moving target,

00:43:32.501 --> 00:43:34.534
so I do not have
an example for you

00:43:34.534 --> 00:43:36.300
to run right now
that runs this code,

00:43:36.300 --> 00:43:37.701
but I will very soon
and I'll--

00:43:37.701 --> 00:43:39.467
I'll get it out there
so you can all run it.

00:43:39.467 --> 00:43:40.801
But, I want to show you
what the code looks like,

00:43:40.801 --> 00:43:42.801
just so you can understand
the kinds of things

00:43:42.801 --> 00:43:45.467
that this is able to do.

00:43:45.467 --> 00:43:49.200
So data--so here's
the data join

00:43:49.200 --> 00:43:50.367
on the Pipeline API.

00:43:50.367 --> 00:43:51.801
So the first thing
we need to do

00:43:51.801 --> 00:43:53.167
is the left part of this.

00:43:53.167 --> 00:43:54.400
Actually,
I have this in red.

00:43:54.400 --> 00:43:55.567
Yeah. So this part.

00:43:55.567 --> 00:43:58.801
So Mapping three things
together, joining them,

00:43:58.801 --> 00:44:00.801
and then doing "Shuffle"
and a "Reduce."

00:44:00.801 --> 00:44:02.167
That's, like,
the first step.

00:44:02.167 --> 00:44:03.734
I want to do that part.

00:44:03.734 --> 00:44:07.300
So here's the Python code
to describe that.

00:44:07.300 --> 00:44:09.234
I want to run
three Map pipelines,

00:44:09.234 --> 00:44:11.234
one for "Categories,"
one for "Items,"

00:44:11.234 --> 00:44:13.067
and one for "Sales."

00:44:13.067 --> 00:44:14.467
The first "MapPipeline"
is going to call

00:44:14.467 --> 00:44:16.601
"map categories"
on everything,

00:44:16.601 --> 00:44:20.100
reading from the Datastore
of the "Category" "entity kind."

00:44:20.100 --> 00:44:23.801
The second one will call
"map items" on the "Items"

00:44:23.801 --> 00:44:25.501
Datastore kind.

00:44:25.501 --> 00:44:27.868
The third one will do
"map sales" on "Sales" kind.

00:44:27.868 --> 00:44:29.234
Pretty easy.

00:44:29.234 --> 00:44:32.767
And then I'll take the results
of the--all three,

00:44:32.767 --> 00:44:33.968
append them together

00:44:33.968 --> 00:44:35.968
and then pass them
to the "ShufflePipeline."

00:44:35.968 --> 00:44:37.601
That will shuffle them
all together,

00:44:37.601 --> 00:44:40.834
collate them by "item id."

00:44:40.834 --> 00:44:43.801
So this, I think
it's 15 lines,

00:44:43.801 --> 00:44:47.234
describes
the left side of this.

00:44:47.234 --> 00:44:48.701
There's obviously
Mapper code in there

00:44:48.701 --> 00:44:50.767
that's maybe one or two lines
each to actually pull out

00:44:50.767 --> 00:44:52.133
the fields into tuples,

00:44:52.133 --> 00:44:54.834
but the point is, like,
the hard part, in my opinion,

00:44:54.834 --> 00:44:57.367
which is connecting the pieces,
is really simple.

00:44:57.367 --> 00:44:59.934
That's all it is.

00:44:59.934 --> 00:45:02.234
So once I've gotten
that result,

00:45:02.234 --> 00:45:03.334
then I need the rest.

00:45:03.334 --> 00:45:06.167
So--so here's
the whole sales report.

00:45:06.167 --> 00:45:09.000
I yield that pipeline
I just told you,

00:45:09.000 --> 00:45:13.501
so "JoinOnItemId" gives me back
a future of "joined data,"

00:45:13.501 --> 00:45:17.000
then I run "Reduce" on that,
reducing the items,

00:45:17.000 --> 00:45:22.734
output it to "Bloblstore"
as records,

00:45:22.734 --> 00:45:25.033
then I run "MapReduce"
on the output again,

00:45:25.033 --> 00:45:28.234
which inverts pairs
and then sums the values.

00:45:28.234 --> 00:45:30.400
So that's those two functions
using the "RecordsReader"

00:45:30.400 --> 00:45:33.467
and the "RecordsOutputWriter."

00:45:33.467 --> 00:45:34.567
And that's it.

00:45:34.567 --> 00:45:35.934
And then there's another
future in there

00:45:35.934 --> 00:45:39.067
for passing in
the "reduce" output.

00:45:39.067 --> 00:45:40.901
So this is another,
you know, 10, 15 lines

00:45:40.901 --> 00:45:42.868
to describe
the second part,

00:45:42.868 --> 00:45:45.868
which is the Map expansion
and the Shuffle reduction.

00:45:45.868 --> 00:45:48.133
And so through--just--
you know,

00:45:48.133 --> 00:45:50.968
about 25, 30 lines
of code total,

00:45:50.968 --> 00:45:52.868
you can describe
this whole pipeline

00:45:52.868 --> 00:45:54.100
through a series
of data dependencies

00:45:54.100 --> 00:45:57.200
that are functionally
described--

00:45:57.200 --> 00:46:00.934
procedurally described.

00:46:00.934 --> 00:46:02.501
So that's--that's
where we're going.

00:46:02.501 --> 00:46:03.834
So I'm going to have
this example for you guys.

00:46:03.834 --> 00:46:04.934
I'm sorry
I don't have it today,

00:46:04.934 --> 00:46:06.367
but this is what
we're going to have

00:46:06.367 --> 00:46:09.734
as a demo of the Pipeline API
to show you how big you can go,

00:46:09.734 --> 00:46:11.033
but I hope
I've given you an idea

00:46:11.033 --> 00:46:12.267
of the kind of
class of problems

00:46:12.267 --> 00:46:15.567
that we can solve
using this API.

00:46:15.567 --> 00:46:17.834
And that's it.
So if there are any questions,

00:46:17.834 --> 00:46:23.167
please come up to the mic.
[clapping]

00:46:27.300 --> 00:46:28.367
Yep.

00:46:28.367 --> 00:46:29.667
man: I think
it's fantastic...

00:46:29.667 --> 00:46:30.667
Slatkin:
Thanks.

00:46:30.667 --> 00:46:33.634
man:
For my applications,

00:46:33.634 --> 00:46:36.300
and I think the syntax is
a little bit more complicated

00:46:36.300 --> 00:46:38.767
when you compare it
to functional programming.

00:46:38.767 --> 00:46:40.634
You know, functional
programming has this idea

00:46:40.634 --> 00:46:42.367
of hierarchic functions

00:46:42.367 --> 00:46:45.567
where you can return
a function as a return type

00:46:45.567 --> 00:46:47.200
and that executes,

00:46:47.200 --> 00:46:49.734
so that will take care of
the pipelining problem.

00:46:49.734 --> 00:46:51.367
I know it's hard problem
for Java,

00:46:51.367 --> 00:46:54.467
because you can't directly
return the function

00:46:54.467 --> 00:46:56.734
but probably, it's--at least
for Python it would be easier.

00:46:56.734 --> 00:46:58.100
Slatkin: Yeah, we--

00:46:58.100 --> 00:47:03.000
I think we thought
of some ways to simplify,

00:47:03.000 --> 00:47:06.501
you know, basically get rid
of a lot of the wrapper

00:47:06.501 --> 00:47:08.000
syntax in the Pipeline API,

00:47:08.000 --> 00:47:09.968
so you could add a--
maybe you could add, like,

00:47:09.968 --> 00:47:10.901
an annotation
to existing function

00:47:10.901 --> 00:47:12.167
and that would just work,

00:47:12.167 --> 00:47:15.234
or you could return a function
that then is run.

00:47:15.234 --> 00:47:17.767
We want to do
a lot of these things.

00:47:17.767 --> 00:47:20.667
There's kind of
I consider that the "sugar",

00:47:20.667 --> 00:47:22.701
so I agree that
functional languages

00:47:22.701 --> 00:47:24.767
are shorter at describing
a lot of this stuff.

00:47:24.767 --> 00:47:26.000
I think we'll be able
to add some things

00:47:26.000 --> 00:47:27.767
to make it even shorter.

00:47:27.767 --> 00:47:29.901
So I agree with you,
but, you know,

00:47:29.901 --> 00:47:32.000
that's why functional languages
are the way they are,

00:47:32.000 --> 00:47:33.968
is so they can do
all sorts of currying

00:47:33.968 --> 00:47:35.133
and other events, though.

00:47:35.133 --> 00:47:36.367
man: I think
from a use case standpoint,

00:47:36.367 --> 00:47:40.167
it would help us a lot
in terms of, you know,

00:47:40.167 --> 00:47:42.067
online reporting so if
you want to, you know,

00:47:42.067 --> 00:47:45.701
create different analytics with
different sets of operatives--

00:47:45.701 --> 00:47:47.334
Slatkin: Yep.

00:47:47.334 --> 00:47:50.868
man: You would want to create
functions dynamically.

00:47:50.868 --> 00:47:52.901
Slatkin: Yeah, and
that makes sense, and, you know,

00:47:52.901 --> 00:47:54.868
one of the things we've just
talked about is maybe--you know,

00:47:54.868 --> 00:47:56.367
Java can serialize
all kinds of really cool stuff

00:47:56.367 --> 00:47:58.100
that Python can't,
like code,

00:47:58.100 --> 00:47:59.601
and so I think
that we've talked about,

00:47:59.601 --> 00:48:01.167
I mean,
under certain circumstances.

00:48:01.167 --> 00:48:04.767
So yeah, we were trying to make
it even more dynamic to add,

00:48:04.767 --> 00:48:06.267
you know, say, like,
first cla--"Functions"

00:48:06.267 --> 00:48:07.734
is a first-class part
of the API,

00:48:07.734 --> 00:48:09.200
but I don't think
we're there yet.

00:48:09.200 --> 00:48:10.801
But, it's definitely
an interesting direction.

00:48:10.801 --> 00:48:12.300
I--I don't know
how that'll turn out.

00:48:12.300 --> 00:48:13.701
So. Okay, thanks.

00:48:13.701 --> 00:48:15.167
Yep.
man: Hi.

00:48:15.167 --> 00:48:18.000
You talked about--you were
comparing with other things

00:48:18.000 --> 00:48:21.167
that exist inside
Google [indistinct].

00:48:21.167 --> 00:48:24.033
Like, a very common thing
is, like,

00:48:24.033 --> 00:48:26.033
[speaks indistinctly]

00:48:26.033 --> 00:48:27.267
Slatkin:
Yeah.

00:48:27.267 --> 00:48:28.767
man: So how
does that fit in?

00:48:28.767 --> 00:48:30.667
I don't actually see,
like, if, let's say,

00:48:30.667 --> 00:48:32.100
I read on the pipeline

00:48:32.100 --> 00:48:34.200
and there's pieces of the code
there, of data

00:48:34.200 --> 00:48:36.067
that I'm feeding into the
pipeline that haven't changed?

00:48:36.067 --> 00:48:36.868
Slatkin:
Right.

00:48:36.868 --> 00:48:38.234
man:
Does it, just--

00:48:38.234 --> 00:48:39.968
Slatkin: So there's
no incremental builds here.

00:48:39.968 --> 00:48:41.267
That's--I think
that's what you're asking.

00:48:41.267 --> 00:48:42.434
man:
Yeah.

00:48:42.434 --> 00:48:43.601
Slatkin: Yeah, there are
no incremental builds.

00:48:43.601 --> 00:48:44.601
You'd have to build
in your own logic

00:48:44.601 --> 00:48:46.400
into a child pipeline
to say,

00:48:46.400 --> 00:48:48.801
"Oh, you wanted to run
MapReduce here.

00:48:48.801 --> 00:48:51.434
I have a cache of
those input values.

00:48:51.434 --> 00:48:53.734
Here's the last time
I ran the output values."

00:48:53.734 --> 00:48:56.200
I think that it would be very
easy to add a cache like that

00:48:56.200 --> 00:48:57.634
to any existing pipeline,

00:48:57.634 --> 00:48:59.634
where it's just, like,
"Before you actually do this,

00:48:59.634 --> 00:49:00.868
check to see
in some index,

00:49:00.868 --> 00:49:03.300
either in a Datastore or
table or--or whatever,

00:49:03.300 --> 00:49:05.067
if, you know,
a memorization function

00:49:05.067 --> 00:49:06.067
or something like that.

00:49:06.067 --> 00:49:07.634
Have I run it in
the last 15 minutes?

00:49:07.634 --> 00:49:10.200
If I have, just return
the result I already computed.

00:49:10.200 --> 00:49:12.801
So I think you can add
incremental builds to this,

00:49:12.801 --> 00:49:15.968
but you'd probably
have to do it yourself.

00:49:15.968 --> 00:49:17.534
But I think that that
might be a cool thing

00:49:17.534 --> 00:49:20.367
we could add at the-- at
the MapReduce Framework layer,

00:49:20.367 --> 00:49:21.801
where the framework
would understand

00:49:21.801 --> 00:49:24.100
you could mark something
as being in incremental builds.

00:49:24.100 --> 00:49:26.501
Say "Don't make--don't do this
more than once every hour."

00:49:26.501 --> 00:49:28.100
And then have
that carry through.

00:49:28.100 --> 00:49:30.334
So I think that's a direction
we want to go in, but--

00:49:30.334 --> 00:49:31.634
man: So for example,
MapReduce does, like,

00:49:31.634 --> 00:49:35.300
does this automatically,
like, if for most cases,

00:49:35.300 --> 00:49:39.834
especially when it's, you know,
things are failing [indistinct].

00:49:39.834 --> 00:49:41.300
Slatkin: You're saying,
like, partial progress,

00:49:41.300 --> 00:49:42.968
if you restart it
and stuff like that?

00:49:42.968 --> 00:49:43.968
man: Right.
Slatkin: Yeah.

00:49:43.968 --> 00:49:45.200
I think
the MapReduce Framework

00:49:45.200 --> 00:49:48.467
will do that too
to a point, but what I--

00:49:48.467 --> 00:49:50.434
what I think's interesting
is more of running MapReduce,

00:49:50.434 --> 00:49:52.567
like, multiple times
over the same day

00:49:52.567 --> 00:49:54.801
over new data
or variations of the data.

00:49:54.801 --> 00:49:56.234
man:
Mmm-hmm.

00:49:56.234 --> 00:49:57.701
Slatkin:
And that's where we're--

00:49:57.701 --> 00:49:59.133
I don't think
the MapReduce Frameworks--

00:49:59.133 --> 00:50:00.501
I mean, the MapReduce Frameworks
I've worked with

00:50:00.501 --> 00:50:02.934
don't do that part.

00:50:02.934 --> 00:50:05.033
Like, MapReduce itself--
doesn't do that part.

00:50:05.033 --> 00:50:08.434
So you kind of have to
add the incremental piece to it.

00:50:08.434 --> 00:50:10.100
So I think, yeah--
that's--I mean,

00:50:10.100 --> 00:50:14.100
I think it'd be
a cool feature to add. So.

00:50:14.100 --> 00:50:15.968
Yeah.

00:50:15.968 --> 00:50:18.067
man: I know that you said
you could get a StackTrace

00:50:18.067 --> 00:50:19.234
if you get an error,

00:50:19.234 --> 00:50:20.934
but can you also trap
the exception itself

00:50:20.934 --> 00:50:23.234
for production code?

00:50:23.234 --> 00:50:24.300
Slatkin:
Right.

00:50:24.300 --> 00:50:26.534
So if you get an error--

00:50:26.534 --> 00:50:28.033
So you're saying, like,
a concurrency error?

00:50:28.033 --> 00:50:31.334
Like, I accidentally added
access to this value or--

00:50:31.334 --> 00:50:33.834
man: Yeah. Well, let's say
that you have a pipeline

00:50:33.834 --> 00:50:35.067
that goes off and fails
for some reason and--

00:50:35.067 --> 00:50:36.067
Slatkin: Oh, oh, okay.

00:50:36.067 --> 00:50:37.300
Yeah.

00:50:37.300 --> 00:50:39.067
No, in--in production,
you can't catch it.

00:50:39.067 --> 00:50:43.067
So in--so it can run
serially, so you have,

00:50:43.067 --> 00:50:44.901
like, child pipeline--
you have parent pipeline,

00:50:44.901 --> 00:50:46.334
child pipeline,
child pipeline.

00:50:46.334 --> 00:50:48.200
If this thing
raises an exception,

00:50:48.200 --> 00:50:50.133
you don't get the exception
back in the parent.

00:50:50.133 --> 00:50:52.067
I think that'd be a
really cool thing to add.

00:50:52.067 --> 00:50:53.567
Functionally, or, like,
or technically,

00:50:53.567 --> 00:50:55.634
that's difficult to
implement

00:50:55.634 --> 00:51:00.434
for a lot of reasons, but,
so far what happens is

00:51:00.434 --> 00:51:03.434
that if the child dies
for an exception,

00:51:03.434 --> 00:51:05.667
it'll retry
if you ask it to,

00:51:05.667 --> 00:51:07.400
and if it retries
too many times,

00:51:07.400 --> 00:51:09.033
it'll abort
all the way to the root,

00:51:09.033 --> 00:51:10.234
and then it'll send
this "abort" message

00:51:10.234 --> 00:51:11.234
to everybody saying,

00:51:11.234 --> 00:51:12.834
"Alright,
something totally broke.

00:51:12.834 --> 00:51:14.534
Everybody stop
what you're going to do,"

00:51:14.534 --> 00:51:16.033
and then it emails the
administrator with the status

00:51:16.033 --> 00:51:18.367
and the link to the page.

00:51:18.367 --> 00:51:21.100
But adding exceptional states
would be cool.

00:51:21.100 --> 00:51:25.167
It's something we should do.
Thanks.

00:51:25.167 --> 00:51:27.033
Okay.

00:51:27.033 --> 00:51:28.133
Alright, well,
thanks a lot for coming.

00:51:28.133 --> 00:51:30.601
I know this is the last talk
of the last day,

00:51:30.601 --> 00:51:31.667
so I appreciate you coming.

00:51:31.667 --> 00:51:34.167
I hope I have not
hurt you too much,

00:51:34.167 --> 00:51:38.901
and thanks again.
[clapping]

