WEBVTT
Kind: captions
Language: en

00:00:02.029 --> 00:00:02.860
BRIAN CAIRNS: Hello, everyone.

00:00:02.860 --> 00:00:03.980
I'm Brian Cairns.

00:00:03.980 --> 00:00:04.890
CHERYL SIMON: I'm
Cheryl Simon.

00:00:04.890 --> 00:00:06.230
BRIAN CAIRNS: And we're going to
tell you a little bit about

00:00:06.230 --> 00:00:09.870
the secrets behind the
Drive Realtime API.

00:00:09.870 --> 00:00:11.900
So what does that mean?

00:00:11.900 --> 00:00:14.030
Well first, we're going to give
you a brief introduction

00:00:14.030 --> 00:00:16.940
to the Realtime API and a demo
of what sort of apps you can

00:00:16.940 --> 00:00:19.510
build with the Realtime API.

00:00:19.510 --> 00:00:21.800
We're then going to go into a
little bit more depth on the

00:00:21.800 --> 00:00:24.470
technical details behind
Google's realtime

00:00:24.470 --> 00:00:26.940
collaborative technology, which
is used in a lot of our

00:00:26.940 --> 00:00:29.280
products, as well as
the Realtime API.

00:00:29.280 --> 00:00:32.790
We're going to talk through a
few points about how you can

00:00:32.790 --> 00:00:35.730
design a good data model and
avoid some of the potential

00:00:35.730 --> 00:00:38.570
pitfalls that come from
collaboration.

00:00:38.570 --> 00:00:40.950
And then finally, we're going
to give you a little sneak

00:00:40.950 --> 00:00:43.740
preview of the things we're
working on to improve the

00:00:43.740 --> 00:00:47.810
Realtime API for your
great apps.

00:00:47.810 --> 00:00:50.390
So Cheryl, want to talk
a little bit about

00:00:50.390 --> 00:00:52.430
the Realtime API?

00:00:52.430 --> 00:00:53.100
CHERYL SIMON: Sure.

00:00:53.100 --> 00:00:55.320
So at this point you guys are
probably wondering, what is

00:00:55.320 --> 00:00:56.700
the Realtime API?

00:00:56.700 --> 00:00:59.780
So I assume many of you have
used Google Docs before, or

00:00:59.780 --> 00:01:01.700
least seen it.

00:01:01.700 --> 00:01:04.650
So what the Realtime API does is
it allows you to take your

00:01:04.650 --> 00:01:08.060
application and add to it
the power of instant

00:01:08.060 --> 00:01:10.920
collaboration, just like what
you get in Google Docs.

00:01:10.920 --> 00:01:13.910
It's all done client-side via a
JavaScript API, so you don't

00:01:13.910 --> 00:01:15.560
even have to run your
own server.

00:01:15.560 --> 00:01:18.320
But you get really powerful
collaboration with

00:01:18.320 --> 00:01:21.540
click-by-click or
character-by-character view of

00:01:21.540 --> 00:01:23.550
what your collaborators
are doing.

00:01:23.550 --> 00:01:25.320
We handle conflict resolution.

00:01:25.320 --> 00:01:28.170
So if multiple people are making
changes to the document

00:01:28.170 --> 00:01:31.010
at the same time or to whatever
your application is.

00:01:31.010 --> 00:01:32.560
And you can get collaborator
presence.

00:01:32.560 --> 00:01:35.120
So you can see who else is
working on the document or

00:01:35.120 --> 00:01:37.300
playing the game at
the same time.

00:01:37.300 --> 00:01:40.280
And this is all backed by Google
Drive, which means that

00:01:40.280 --> 00:01:43.470
you get the power of Google's
Cloud Storage Services, and

00:01:43.470 --> 00:01:46.360
high availability, and all the
sort of ecosystem that comes

00:01:46.360 --> 00:01:48.740
with Google Drive.

00:01:48.740 --> 00:01:51.340
So now we're going to show
a quick demo, just so

00:01:51.340 --> 00:01:54.960
you can just see.

00:01:54.960 --> 00:01:58.210
So the Google Docs you're
familiar with are probably the

00:01:58.210 --> 00:02:01.430
Docs, Sheets, and Slides that
are more productivity focused.

00:02:01.430 --> 00:02:03.590
So we just thought we'd show a
quick demo of the other sort

00:02:03.590 --> 00:02:06.320
of things you can do with
the Realtime API.

00:02:06.320 --> 00:02:08.830
So this is a little game called
Realtime Cube that was

00:02:08.830 --> 00:02:11.720
written by one of our Drive
developers, Mike Propcopio.

00:02:11.720 --> 00:02:16.000
And you can see here that as
Brian makes a change to the

00:02:16.000 --> 00:02:18.660
cube, that change is instantly
seen by all of the other

00:02:18.660 --> 00:02:20.240
players in the game.

00:02:20.240 --> 00:02:22.530
In the upper right, you can see
the other people that are

00:02:22.530 --> 00:02:23.850
playing right now.

00:02:23.850 --> 00:02:26.730
And because this is backed by
Google Drive, everything is

00:02:26.730 --> 00:02:28.040
stored instantly.

00:02:28.040 --> 00:02:30.890
So if you were to close and
reopen the game, you could

00:02:30.890 --> 00:02:32.140
easily restore state.

00:02:41.350 --> 00:02:43.990
So let's just think for a
second, what would it take to

00:02:43.990 --> 00:02:44.990
build this kind of

00:02:44.990 --> 00:02:46.840
collaboration system from scratch?

00:02:46.840 --> 00:02:47.920
BRIAN CAIRNS: Oh,
I can do that.

00:02:47.920 --> 00:02:48.350
CHERYL SIMON: Oh, yeah?

00:02:48.350 --> 00:02:48.615
BRIAN CAIRNS: OK.

00:02:48.615 --> 00:02:49.280
CHERYL SIMON: You think so?

00:02:49.280 --> 00:02:51.020
All right, let's
think about it.

00:02:51.020 --> 00:02:53.740
So first, you need some sort
of consistent storage,

00:02:53.740 --> 00:02:55.980
someplace that all these bits
that represent the document

00:02:55.980 --> 00:02:56.500
are going to be.

00:02:56.500 --> 00:02:57.410
BRIAN CAIRNS: That's
simple, we'll just

00:02:57.410 --> 00:02:58.850
throw it in a database.

00:02:58.850 --> 00:02:59.750
CHERYL SIMON: OK.

00:02:59.750 --> 00:03:00.830
Well, what about
authentication?

00:03:00.830 --> 00:03:02.500
How are you going to know
who your users are?

00:03:02.500 --> 00:03:03.750
BRIAN CAIRNS: I'm sure we can
do something with like a

00:03:03.750 --> 00:03:06.760
cookie or maybe a session
ID, something like that.

00:03:06.760 --> 00:03:07.710
CHERYL SIMON: All right.

00:03:07.710 --> 00:03:09.500
What about your client
server protocol?

00:03:09.500 --> 00:03:11.830
What sort of networking are
you going to have set up?

00:03:11.830 --> 00:03:14.750
BRIAN CAIRNS: We'll use JSON and
come up with some sort of

00:03:14.750 --> 00:03:16.500
serialization format.

00:03:16.500 --> 00:03:16.860
CHERYL SIMON: OK.

00:03:16.860 --> 00:03:18.240
How are you going to
handle conflicts?

00:03:18.240 --> 00:03:20.460
What happens when multiple
people are making changes

00:03:20.460 --> 00:03:21.880
together at the same time?

00:03:21.880 --> 00:03:24.380
BRIAN CAIRNS: Well, we'll just
tell our users not to do that.

00:03:24.380 --> 00:03:25.580
[LAUGHTER]

00:03:25.580 --> 00:03:26.480
CHERYL SIMON: OK.

00:03:26.480 --> 00:03:27.900
How about push notifications?

00:03:27.900 --> 00:03:30.400
You at least have to be able
to tell the client when

00:03:30.400 --> 00:03:32.990
there's new changes available.

00:03:32.990 --> 00:03:35.120
BRIAN CAIRNS: Well, if we just
continuously make get requests

00:03:35.120 --> 00:03:37.700
to the server, that pretty
much solves itself.

00:03:37.700 --> 00:03:38.100
CHERYL SIMON: All right.

00:03:38.100 --> 00:03:40.080
Well, what about document
management?

00:03:40.080 --> 00:03:41.550
Or here's a good one,
server failover.

00:03:41.550 --> 00:03:42.685
What do you do if your
server crashes?

00:03:42.685 --> 00:03:44.460
BRIAN CAIRNS: So there's only
going to be one server.

00:03:44.460 --> 00:03:47.848
So if it crashes, then
we'll reboot it.

00:03:47.848 --> 00:03:49.280
CHERYL SIMON: OK.

00:03:49.280 --> 00:03:51.620
Are you going to handle
undo/redo?

00:03:51.620 --> 00:03:53.120
BRIAN CAIRNS: To
be determined.

00:03:53.120 --> 00:03:53.590
CHERYL SIMON: OK.

00:03:53.590 --> 00:03:55.410
Well, what about
authorization?

00:03:55.410 --> 00:03:57.730
This is really important, you
don't want users to be able to

00:03:57.730 --> 00:04:00.010
see each other documents or get
access to things that they

00:04:00.010 --> 00:04:02.590
shouldn't have.

00:04:02.590 --> 00:04:03.590
BRIAN CAIRNS: I can't
really come up with

00:04:03.590 --> 00:04:04.816
anything for that.

00:04:04.816 --> 00:04:05.160
CHERYL SIMON: Yeah.

00:04:05.160 --> 00:04:05.670
All right.

00:04:05.670 --> 00:04:08.270
Well, what about server
affinity, or data replication,

00:04:08.270 --> 00:04:09.050
or user presence?

00:04:09.050 --> 00:04:10.420
Or, how about sharing?

00:04:10.420 --> 00:04:13.610
Or document metadata,
profiles?

00:04:13.610 --> 00:04:15.430
BRIAN CAIRNS: I think this might
be a little bit harder

00:04:15.430 --> 00:04:16.089
than I was thinking.

00:04:16.089 --> 00:04:18.670
What if there were some kind
of an API that did

00:04:18.670 --> 00:04:20.480
all of this for us?

00:04:20.480 --> 00:04:22.610
CHERYL SIMON: Well,
luckily there is.

00:04:22.610 --> 00:04:25.940
So with the Realtime API, you
can let us handle all of the

00:04:25.940 --> 00:04:28.490
complication of network
communication, storage,

00:04:28.490 --> 00:04:31.010
sharing, high availability,
all of that

00:04:31.010 --> 00:04:32.070
is handled for you.

00:04:32.070 --> 00:04:34.760
All you have to do is to create
a realtime data model

00:04:34.760 --> 00:04:36.850
that makes sense for
your application.

00:04:36.850 --> 00:04:39.900
So you can focus all your
energies on just creating

00:04:39.900 --> 00:04:41.530
really awesome applications
that'll make

00:04:41.530 --> 00:04:43.570
users really happy.

00:04:43.570 --> 00:04:45.650
So what's the data
model look like?

00:04:45.650 --> 00:04:48.230
Thinking back to that demo we
showed just a few minutes

00:04:48.230 --> 00:04:51.180
earlier, this is a
representation of what this

00:04:51.180 --> 00:04:52.540
data model could look like.

00:04:52.540 --> 00:04:54.640
So at the root of the data
model is always a

00:04:54.640 --> 00:04:57.650
collaborative map, which just
is where you put all of the

00:04:57.650 --> 00:05:00.150
data objects that you need
for your application.

00:05:00.150 --> 00:05:02.490
In this case, there's just a
single collaborator of list

00:05:02.490 --> 00:05:06.070
that consists of the moves
that the players

00:05:06.070 --> 00:05:07.290
have made in the game.

00:05:07.290 --> 00:05:10.450
And each move is just
represented as a JSON object.

00:05:10.450 --> 00:05:14.070
So these collaborative types,
this map and list, are special

00:05:14.070 --> 00:05:16.900
in that whenever you add
something or make a change to

00:05:16.900 --> 00:05:19.920
this map or to this list, the
changes are automatically sent

00:05:19.920 --> 00:05:23.790
to the server and sent to all
the different collaborators.

00:05:23.790 --> 00:05:26.560
So here, I'm going to show you
in one slide all the code that

00:05:26.560 --> 00:05:30.630
you need in order to integrate
the Realtime API with this

00:05:30.630 --> 00:05:33.010
data model I just
talked about.

00:05:33.010 --> 00:05:36.160
So the first thing that you do
is you just load a file.

00:05:36.160 --> 00:05:38.040
And when you load it, you have
to give it three things.

00:05:38.040 --> 00:05:40.060
You have to give it the file
that you want to be loaded.

00:05:40.060 --> 00:05:42.280
And then you give it two
function pointers, one that

00:05:42.280 --> 00:05:44.460
represents the file--

00:05:44.460 --> 00:05:47.360
what you want to happen when
the file is loaded, and one

00:05:47.360 --> 00:05:49.760
that represents what you want
to happen the first time the

00:05:49.760 --> 00:05:51.680
data model is initialized.

00:05:51.680 --> 00:05:53.420
So let's look at that
second one first.

00:05:53.420 --> 00:05:57.560
So this initialize model is
called exactly once for each

00:05:57.560 --> 00:06:00.450
time that the data model
comes into existence.

00:06:00.450 --> 00:06:03.690
So not every time the document
is loaded, just the first time

00:06:03.690 --> 00:06:05.110
the document is created.

00:06:05.110 --> 00:06:08.200
And here, you want to initialize
all the state that

00:06:08.200 --> 00:06:10.520
you want to guarantee that every
document in your system

00:06:10.520 --> 00:06:11.600
is going to have.

00:06:11.600 --> 00:06:15.040
So here we tell the model to
create a list and that creates

00:06:15.040 --> 00:06:16.180
a collaborative list.

00:06:16.180 --> 00:06:20.210
And then we add it to the root
by just saying, set this thing

00:06:20.210 --> 00:06:23.240
on the root with a
name of moves.

00:06:23.240 --> 00:06:25.920
Then, on the onfileLoaded, this
is what happens every

00:06:25.920 --> 00:06:28.480
time a collaborator opens
the document.

00:06:28.480 --> 00:06:31.550
So what you want to do here is
to set up some listeners so

00:06:31.550 --> 00:06:33.830
that you can be informed
of when changes

00:06:33.830 --> 00:06:35.150
happen to this list.

00:06:35.150 --> 00:06:38.290
So in this case, we're adding
an event listener onto that

00:06:38.290 --> 00:06:40.480
moves object that we
created above.

00:06:40.480 --> 00:06:43.090
And we're going to get notified
whenever a value is

00:06:43.090 --> 00:06:44.370
added to the list.

00:06:44.370 --> 00:06:48.090
And we just want to update the
display when that happens.

00:06:48.090 --> 00:06:50.890
And then finally, you just need
a little bit of code to

00:06:50.890 --> 00:06:52.200
respond to user actions.

00:06:52.200 --> 00:06:55.650
So whenever a user makes a
move here, we'll tie this

00:06:55.650 --> 00:06:57.050
addMove handler into it.

00:06:57.050 --> 00:07:00.320
So we create a new move, which
is just a JSON object, and we

00:07:00.320 --> 00:07:03.290
add it to this moves
collaborative list that we

00:07:03.290 --> 00:07:04.460
created before.

00:07:04.460 --> 00:07:05.290
And that's it.

00:07:05.290 --> 00:07:08.320
With just these three simple
steps, all of those moves are

00:07:08.320 --> 00:07:10.070
going to be automatically
sent around.

00:07:10.070 --> 00:07:13.050
And you can update the display
and handle all of the sort of

00:07:13.050 --> 00:07:15.180
complexity of networking
storage, all of that is

00:07:15.180 --> 00:07:18.970
handled with just these three
simple functions.

00:07:18.970 --> 00:07:20.900
And now Brian, here, is going to
tell us a little bit about

00:07:20.900 --> 00:07:23.400
some apps that have already
put this to use.

00:07:23.400 --> 00:07:23.930
BRIAN CAIRNS: Thanks, Cheryl.

00:07:23.930 --> 00:07:26.100
So we have a lot of great
partners that made really

00:07:26.100 --> 00:07:28.370
awesome apps for the
Realtime API.

00:07:28.370 --> 00:07:30.570
We already demonstrated Realtime
Cube, which was

00:07:30.570 --> 00:07:34.050
developed by a member of the
Drive team here at Google.

00:07:34.050 --> 00:07:35.280
We also have some other
apps that were

00:07:35.280 --> 00:07:37.300
developed by Google engineers.

00:07:37.300 --> 00:07:39.370
Multi Sudoku was actually
developed by Cheryl.

00:07:39.370 --> 00:07:42.600
It's just a Sudoku game and
it's really fun to play.

00:07:42.600 --> 00:07:45.150
And then, we have another
developer, John Day-Richter,

00:07:45.150 --> 00:07:50.410
who developed a make your own
adventure text-based game

00:07:50.410 --> 00:07:52.770
called CollabQuest, which is
really cool if you're into

00:07:52.770 --> 00:07:54.040
MUDs or something like that.

00:07:54.040 --> 00:07:56.440
But maybe you're interested in
something that's a little bit

00:07:56.440 --> 00:07:59.270
more productive than that.

00:07:59.270 --> 00:08:03.380
If you like editing code--
and who doesn't--

00:08:03.380 --> 00:08:05.540
we have a great cloud-based IDE
developed by one of our

00:08:05.540 --> 00:08:07.480
partners called Neutron Drive.

00:08:07.480 --> 00:08:10.570
Many of you have maybe
seen this or used it.

00:08:10.570 --> 00:08:13.940
With the Real time API, now
you can collaborate on the

00:08:13.940 --> 00:08:16.550
code you have stored in Google
Drive, just like you could

00:08:16.550 --> 00:08:18.520
collaborate on a document
in Google Drive.

00:08:18.520 --> 00:08:21.430
And this is really great for
para-programming or code

00:08:21.430 --> 00:08:25.670
reviews, or whatever you want to
do to collaborate on code.

00:08:25.670 --> 00:08:28.720
If you want to plan some sort of
project or a schedule, one

00:08:28.720 --> 00:08:31.100
of our partners created
an app called Gantter.

00:08:31.100 --> 00:08:34.159
And Gantter is a Gantt-plotting
program for

00:08:34.159 --> 00:08:36.059
project management
and schedules

00:08:36.059 --> 00:08:37.510
and things like that.

00:08:37.510 --> 00:08:39.780
And now, of course, that's
a collaborative activity.

00:08:39.780 --> 00:08:42.179
And you can now see people's
changes in realtime

00:08:42.179 --> 00:08:43.830
as they make them.

00:08:43.830 --> 00:08:47.990
Or, if you're into doing some
sort of diagramming, draw.io

00:08:47.990 --> 00:08:49.510
has really great diagramming
tools.

00:08:49.510 --> 00:08:52.940
You can make flow charts, or
network diagrams, or any kind

00:08:52.940 --> 00:08:55.050
of diagram that you would
want to make.

00:08:55.050 --> 00:08:57.400
And again, because of the
Realtime API, now you can do

00:08:57.400 --> 00:08:58.680
this in realtime,

00:08:58.680 --> 00:09:00.620
collaborating with other users.

00:09:00.620 --> 00:09:03.920
So lots of really great
capabilities that the Realtime

00:09:03.920 --> 00:09:05.870
API can bring to your apps.

00:09:05.870 --> 00:09:08.210
And it's not just limited to
productivity apps, it could

00:09:08.210 --> 00:09:11.680
work in games or whatever else
you can dream of that you want

00:09:11.680 --> 00:09:13.125
to have realtime
collaboration.

00:09:16.380 --> 00:09:19.570
Let's go through a few of
the secrets of realtime

00:09:19.570 --> 00:09:20.060
collaboration.

00:09:20.060 --> 00:09:22.040
How does this technology
actually work?

00:09:26.730 --> 00:09:28.470
So what's the goal with realtime
collaboration?

00:09:28.470 --> 00:09:30.840
Well, the goal is something
like this.

00:09:30.840 --> 00:09:34.920
This experience where everyone
can edit at the same time, and

00:09:34.920 --> 00:09:37.930
everyone can see everyone
changes in realtime.

00:09:37.930 --> 00:09:39.850
But getting there is
not actually as

00:09:39.850 --> 00:09:41.190
easy is it maybe seems.

00:09:41.190 --> 00:09:44.680
Because we really want two
properties out of this system.

00:09:44.680 --> 00:09:47.470
We want to be able to apply the
changes to the data model

00:09:47.470 --> 00:09:50.200
immediately without waiting
for network latency.

00:09:50.200 --> 00:09:52.850
Maybe you're on crappy hotel
internet connection or maybe

00:09:52.850 --> 00:09:56.120
you're on the conference network
here at Google I/O and

00:09:56.120 --> 00:09:59.450
it takes 500, 600, 700
milliseconds for things to go

00:09:59.450 --> 00:10:00.220
to the server and back.

00:10:00.220 --> 00:10:03.490
You can't wait that long to
update the local display.

00:10:03.490 --> 00:10:06.200
But then, that means that
every user is seeing a

00:10:06.200 --> 00:10:09.380
slightly different sequence
of events in a document.

00:10:09.380 --> 00:10:12.520
And we need to come up with a
consistent answer at the end

00:10:12.520 --> 00:10:15.530
where everyone gets the same
result, regardless of the

00:10:15.530 --> 00:10:21.050
order or timing in which these
changes were applied.

00:10:21.050 --> 00:10:24.510
And the way we do that is we
break every change you do to

00:10:24.510 --> 00:10:26.720
the data model, we break
down into these

00:10:26.720 --> 00:10:28.430
things called mutations.

00:10:28.430 --> 00:10:31.760
And a mutation's just a simple
operation on the data model.

00:10:31.760 --> 00:10:33.240
So let's go through
an example here.

00:10:33.240 --> 00:10:34.820
Here we have just a string.

00:10:34.820 --> 00:10:37.340
And we can assume this is
a collaborative string.

00:10:37.340 --> 00:10:40.080
And the user starts with this
string, Hello World, and they

00:10:40.080 --> 00:10:41.830
start typing in.

00:10:41.830 --> 00:10:45.230
Well, we generate an
insert mutation.

00:10:45.230 --> 00:10:47.750
Let's say that the user inserted
the word Realtime

00:10:47.750 --> 00:10:48.670
between Hello and World.

00:10:48.670 --> 00:10:51.540
Well, we generate this insert
mutation that says insert at

00:10:51.540 --> 00:10:54.170
position six this
text Realtime.

00:10:54.170 --> 00:10:58.750
When that gets applied, we end
up with Hello Realtime World,

00:10:58.750 --> 00:11:00.260
as you would expect.

00:11:00.260 --> 00:11:02.080
Then the user might decide,
OK, I want to

00:11:02.080 --> 00:11:03.100
actually delete something.

00:11:03.100 --> 00:11:05.390
Maybe I want to delete the
word "World." So again,

00:11:05.390 --> 00:11:08.250
starting with Hello Realtime
World, the user goes in,

00:11:08.250 --> 00:11:11.630
selects World, and backspaces
or whatever.

00:11:11.630 --> 00:11:14.380
And we generate a delete
mutation that says to delete

00:11:14.380 --> 00:11:17.900
starting at index 14, which is
where the word "World" begins,

00:11:17.900 --> 00:11:18.970
these six characters.

00:11:18.970 --> 00:11:22.530
And of course, once that's
applied, we erase that word

00:11:22.530 --> 00:11:24.100
"World" and you end up
with Hello Realtime.

00:11:28.340 --> 00:11:32.250
What this means for storage is
actually really interesting.

00:11:32.250 --> 00:11:35.010
So one way you could store this
document is you could try

00:11:35.010 --> 00:11:38.170
to store a snapshot of the
document, or some sort of

00:11:38.170 --> 00:11:39.590
serialized form of the state.

00:11:39.590 --> 00:11:41.200
What we do is actually
a little bit

00:11:41.200 --> 00:11:42.590
simpler and more powerful.

00:11:42.590 --> 00:11:45.810
We store the entire history of
mutations that are applied to

00:11:45.810 --> 00:11:46.800
the document.

00:11:46.800 --> 00:11:50.480
So as you edit, every edit gets
just stored in a log.

00:11:50.480 --> 00:11:52.750
And this is append only.

00:11:52.750 --> 00:11:55.990
And that means that we have the
complete history of every

00:11:55.990 --> 00:11:57.860
state the document
has ever been in

00:11:57.860 --> 00:12:00.580
throughout editing time.

00:12:00.580 --> 00:12:02.930
The one challenge this creates
is that this log's going to

00:12:02.930 --> 00:12:04.320
get really, really long.

00:12:04.320 --> 00:12:06.960
And we don't want to send the
entire mutation history every

00:12:06.960 --> 00:12:08.600
time you load the document.

00:12:08.600 --> 00:12:11.590
So what we do is we have a thing
that takes a snapshot of

00:12:11.590 --> 00:12:12.380
the mutation log.

00:12:12.380 --> 00:12:16.250
It basically rebuilds the data
model from this log, and then

00:12:16.250 --> 00:12:19.990
creates a new set of mutations
that is the minimal set of

00:12:19.990 --> 00:12:23.010
mutations needed to recreate
the data model.

00:12:23.010 --> 00:12:25.020
So in this case, we have
an inset, another

00:12:25.020 --> 00:12:26.120
insert, and a delete.

00:12:26.120 --> 00:12:28.790
And all of that gets condensed
down into a single insert that

00:12:28.790 --> 00:12:31.070
recreates the final result.

00:12:31.070 --> 00:12:34.990
And that's what we send
when we load.

00:12:34.990 --> 00:12:38.055
As I said before, local
mutations get applied easy--

00:12:38.055 --> 00:12:39.140
or immediately.

00:12:39.140 --> 00:12:41.850
So in this case, we have two
different users, Alice and

00:12:41.850 --> 00:12:43.430
Bob, who are both collaborating

00:12:43.430 --> 00:12:46.130
on this single string.

00:12:46.130 --> 00:12:49.560
If Alice inserts the word
"rainy" and Bob inserts the

00:12:49.560 --> 00:12:53.530
word "brightly" at the same
time, we apply both of those

00:12:53.530 --> 00:12:55.690
changes immediately locally.

00:12:55.690 --> 00:12:58.740
So you can see that Alice gets
the rainy day dawned

00:12:58.740 --> 00:13:01.050
immediately and Bob gets
the day dawned brightly

00:13:01.050 --> 00:13:02.230
immediately.

00:13:02.230 --> 00:13:06.320
And this is great, but it's
not collaborative.

00:13:06.320 --> 00:13:08.880
So what you might think is, why
don't we just broadcast

00:13:08.880 --> 00:13:10.550
these mutations around
and then apply

00:13:10.550 --> 00:13:12.570
them when we get them?

00:13:12.570 --> 00:13:15.050
And that sounds good, but the
problem is that the mutations

00:13:15.050 --> 00:13:16.210
end up getting out of date.

00:13:16.210 --> 00:13:19.670
And let's go through an example
for how this happens.

00:13:19.670 --> 00:13:21.550
Let's look just at
Alice's state.

00:13:21.550 --> 00:13:25.220
Alice starts with
The day dawned.

00:13:25.220 --> 00:13:28.350
She applies the insert of
rainy, which she sent.

00:13:28.350 --> 00:13:33.070
And she also applies Bob's
insert of the word "brightly."

00:13:33.070 --> 00:13:36.040
The problem is, you don't
get the right result.

00:13:36.040 --> 00:13:39.860
Bob's insert is too far to
the left in the string.

00:13:39.860 --> 00:13:41.820
The index doesn't make any sense
because there was an

00:13:41.820 --> 00:13:43.880
insert that occurred
before it.

00:13:43.880 --> 00:13:46.050
And you end up inserting in
the middle of a word and

00:13:46.050 --> 00:13:48.440
nothing works.

00:13:48.440 --> 00:13:50.330
And that's the key takeaway
here, is that applying

00:13:50.330 --> 00:13:53.540
mutations as is just
doesn't work.

00:13:53.540 --> 00:13:57.380
What we really want to do is
take these same mutations, but

00:13:57.380 --> 00:14:00.710
instead of applying Bob's
mutation directly, we somehow

00:14:00.710 --> 00:14:04.640
fix Bob's mutation to shift it
over to where it should have

00:14:04.640 --> 00:14:06.760
been, and apply that.

00:14:06.760 --> 00:14:10.570
And when we do this, we get
the correct result.

00:14:10.570 --> 00:14:14.390
Again, the key premise here is
Alice needs to apply something

00:14:14.390 --> 00:14:17.010
that's been modified,
not the exact same

00:14:17.010 --> 00:14:18.700
mutation that Bob applied.

00:14:18.700 --> 00:14:21.860
And the way we do this is
through a process we call

00:14:21.860 --> 00:14:23.670
transformation.

00:14:23.670 --> 00:14:24.780
So let's go through
an example of how

00:14:24.780 --> 00:14:26.250
transformation actually works.

00:14:26.250 --> 00:14:29.600
Again, we have Alice and Bob.

00:14:29.600 --> 00:14:32.130
They both send out
their changes.

00:14:32.130 --> 00:14:34.620
Alice has the insert of the
word "rainy," Bob has the

00:14:34.620 --> 00:14:36.990
insert of the word "brightly."
And they both apply those

00:14:36.990 --> 00:14:38.740
immediately locally.

00:14:38.740 --> 00:14:40.500
They both then, send those
to the server.

00:14:40.500 --> 00:14:43.170
Let's say that Alice's
gets to Google first.

00:14:43.170 --> 00:14:47.940
OK, the server looks at this,
sees that there's nothing that

00:14:47.940 --> 00:14:50.470
Bob has yet sent
to the server.

00:14:50.470 --> 00:14:51.980
So there's nothing
we need to do.

00:14:51.980 --> 00:14:53.664
It just sends it over to Bob.

00:14:53.664 --> 00:14:56.510
And Bob gets the
correct result.

00:14:56.510 --> 00:14:57.740
We're good.

00:14:57.740 --> 00:15:01.340
Bob now, his mutation that
inserts the word "brightly"

00:15:01.340 --> 00:15:02.220
gets to Google.

00:15:02.220 --> 00:15:06.410
Well, Google, our servers notice
that Alice's mutation

00:15:06.410 --> 00:15:08.730
came before Bob's mutation.

00:15:08.730 --> 00:15:13.650
And so Bob's mutation needs
to be fixed to be

00:15:13.650 --> 00:15:14.750
in the correct location.

00:15:14.750 --> 00:15:16.960
And it looks at the indexes
specifically here.

00:15:16.960 --> 00:15:20.340
It notices that the insert that
Alice issued happened

00:15:20.340 --> 00:15:24.530
earlier in the document than
the insert that Bob issued.

00:15:24.530 --> 00:15:28.060
And so it shifts over Bob's
insert by the length of what

00:15:28.060 --> 00:15:29.160
Alice inserted.

00:15:29.160 --> 00:15:31.490
And this new transformed
mutation, which is now an

00:15:31.490 --> 00:15:35.210
insert at position 20, is what
Alice actually gets.

00:15:35.210 --> 00:15:37.635
Alice applies it, and everyone's
happy again.

00:15:37.635 --> 00:15:38.885
Yay, we win.

00:15:42.190 --> 00:15:45.300
But it turns out that's
not really enough.

00:15:45.300 --> 00:15:48.530
Transforming on just the server
doesn't actually solve

00:15:48.530 --> 00:15:50.240
the problem.

00:15:50.240 --> 00:15:52.570
And the reason is that the
server doesn't know about

00:15:52.570 --> 00:15:55.100
every change, possibly
until it's too late.

00:15:55.100 --> 00:15:56.895
So let's go through
another example of

00:15:56.895 --> 00:15:58.020
where this might happen.

00:15:58.020 --> 00:15:59.810
Again, we have Alice and Bob.

00:15:59.810 --> 00:16:01.710
Both issue the same mutations
they did last

00:16:01.710 --> 00:16:03.970
time at the same time.

00:16:03.970 --> 00:16:06.850
But this time, Bob's mutation
gets to the server first.

00:16:06.850 --> 00:16:11.070
Well, the server doesn't
transform Bob's mutation

00:16:11.070 --> 00:16:12.640
because there's nothing
previous to

00:16:12.640 --> 00:16:13.890
transform it against.

00:16:16.560 --> 00:16:18.860
So the server just sends
it onto Alice.

00:16:18.860 --> 00:16:23.360
And of course, panic ensues and
Alice is going to get the

00:16:23.360 --> 00:16:24.810
wrong result.

00:16:24.810 --> 00:16:26.175
Alice now sends her mutation.

00:16:26.175 --> 00:16:29.220
And let's say it gets to the
server after Bob's mutation

00:16:29.220 --> 00:16:31.500
got to the server.

00:16:31.500 --> 00:16:33.820
Well, the server's going to
transform it against Bob's

00:16:33.820 --> 00:16:37.060
mutation because it knows about
Bob's mutation now.

00:16:37.060 --> 00:16:38.925
But Bob mutation comes
later in the document

00:16:38.925 --> 00:16:40.400
than Alice's mutation.

00:16:40.400 --> 00:16:42.550
So in reality, the
transformation for this

00:16:42.550 --> 00:16:44.600
doesn't do anything.

00:16:44.600 --> 00:16:48.122
The mutation just gets sent
as-is over to Bob.

00:16:48.122 --> 00:16:51.000
And of course, the server get
the correct result and Bob

00:16:51.000 --> 00:16:54.030
gets the correct result,
but Alice didn't.

00:16:54.030 --> 00:16:56.280
So how do we solve this?

00:16:56.280 --> 00:16:58.600
Well, the solution is to put the
exact same transformation

00:16:58.600 --> 00:17:01.960
logic we use on the server
on the client.

00:17:01.960 --> 00:17:04.200
So we have this thing called
the transformation manager

00:17:04.200 --> 00:17:07.230
that runs in every
single client.

00:17:07.230 --> 00:17:11.550
In JavaScript, it runs on
the server in Java.

00:17:11.550 --> 00:17:13.710
And we have this mutation queue
that we keep, which is

00:17:13.710 --> 00:17:17.790
basically the list of all
mutations that a user has

00:17:17.790 --> 00:17:20.000
issued but haven't yet been
acknowledged by the server.

00:17:20.000 --> 00:17:22.630
In this case, Alice's insert
of the word "rainy" goes on

00:17:22.630 --> 00:17:25.240
this queue as soon
as it's sent.

00:17:25.240 --> 00:17:28.230
Let's say the server sent out
Bob's mutation unmodified.

00:17:28.230 --> 00:17:30.880
Well, this transformation
manager on the client notices

00:17:30.880 --> 00:17:36.490
that Bob's mutation needs to be
transformed because it was

00:17:36.490 --> 00:17:40.610
not made with respect
to Alice's mutation.

00:17:40.610 --> 00:17:44.590
So we send all the mutations
from the pending queue and the

00:17:44.590 --> 00:17:46.460
mutations from the server
through this transformer

00:17:46.460 --> 00:17:50.120
function, which is the same as
it is on the server, and we

00:17:50.120 --> 00:17:51.300
get the fixed result.

00:17:51.300 --> 00:17:52.550
And everything's fine now.

00:17:56.440 --> 00:17:59.420
And then, the server just has
to acknowledge mutations.

00:17:59.420 --> 00:18:02.610
The server, when it receives a
mutation, it just sends back

00:18:02.610 --> 00:18:05.240
an acknowledgement that looks
very much like the mutation,

00:18:05.240 --> 00:18:08.090
but it doesn't have to
have the actual data.

00:18:08.090 --> 00:18:12.310
And the client just removes
the mutation

00:18:12.310 --> 00:18:13.930
from the pending queue.

00:18:13.930 --> 00:18:16.120
And that's how we manage
conflicts in the system.

00:18:16.120 --> 00:18:19.700
That's how we keep everyone on
the same state despite the

00:18:19.700 --> 00:18:23.950
fact that these mutations
happened in different orders.

00:18:23.950 --> 00:18:26.870
So let's look at a use case,
Cheryl, where you have to undo

00:18:26.870 --> 00:18:28.140
a user's change.

00:18:28.140 --> 00:18:28.580
CHERYL SIMON: All right.

00:18:28.580 --> 00:18:29.390
Thanks, Brian.

00:18:29.390 --> 00:18:32.440
So a lot of times in the
productivity-focused apps, the

00:18:32.440 --> 00:18:34.900
user wants to be able to just
hit a button and have his last

00:18:34.900 --> 00:18:36.540
change get undone.

00:18:36.540 --> 00:18:38.990
So it turns out that this is a
little bit complicated in a

00:18:38.990 --> 00:18:41.550
collaborative environment
because it's possible that

00:18:41.550 --> 00:18:44.690
since he made his last change,
other users have actually made

00:18:44.690 --> 00:18:46.380
other changes to the document.

00:18:46.380 --> 00:18:49.060
Well, it turns out that the same
transformation logic that

00:18:49.060 --> 00:18:51.390
Brian just talked about can
actually help us solve this

00:18:51.390 --> 00:18:53.150
problem, basically for free.

00:18:53.150 --> 00:18:54.540
So let's just think
about what might

00:18:54.540 --> 00:18:55.510
happen here for a minute.

00:18:55.510 --> 00:18:59.160
So we start with this document,
The day dawned.

00:18:59.160 --> 00:19:03.000
And the local user tries to
insert "brightly" into it.

00:19:03.000 --> 00:19:06.590
So what we do is whenever the
local user makes a change, we

00:19:06.590 --> 00:19:09.520
add a mutation to
the undo stack.

00:19:09.520 --> 00:19:12.730
And what this mutation is, is
the inverse of the original

00:19:12.730 --> 00:19:16.380
mutation, such that if you
applied this inverse mutation,

00:19:16.380 --> 00:19:18.250
it would undo the original
mutation.

00:19:18.250 --> 00:19:21.560
So in this case, the opposite of
inserting "brightly" is to

00:19:21.560 --> 00:19:23.220
delete nine characters.

00:19:23.220 --> 00:19:26.800
So now this undo stack consists
of a set of mutations

00:19:26.800 --> 00:19:29.240
that'll sort of like reverse
the changes that the local

00:19:29.240 --> 00:19:30.530
user has made.

00:19:30.530 --> 00:19:32.910
And then later on in the
document, somebody else went

00:19:32.910 --> 00:19:35.730
ahead and made some
more changes.

00:19:35.730 --> 00:19:38.140
So if we just keep the undo
stack like that, and then we

00:19:38.140 --> 00:19:42.240
try to go undo that user's
last change-- we pop this

00:19:42.240 --> 00:19:44.830
inverse mutation off the stack
and go and apply it-- we run

00:19:44.830 --> 00:19:47.940
into the same problem where this
inverse mutation doesn't

00:19:47.940 --> 00:19:48.820
make sense anymore.

00:19:48.820 --> 00:19:52.660
It goes and delete the wrong
section of the document.

00:19:52.660 --> 00:19:54.300
So we can solve this.

00:19:54.300 --> 00:19:57.380
So what we do, instead, is we
still store this inverse

00:19:57.380 --> 00:19:58.900
mutation on the undo stack.

00:19:58.900 --> 00:20:01.930
But in addition, we actually go
ahead and store all of the

00:20:01.930 --> 00:20:04.160
collaborator mutations
as they come in.

00:20:04.160 --> 00:20:07.740
So now this undo stack consists
of a combination of

00:20:07.740 --> 00:20:11.080
inverse local mutations and
collaborator mutations.

00:20:11.080 --> 00:20:14.560
Then, when the user asks us to
undo, what we do is we walk

00:20:14.560 --> 00:20:17.570
down the stack and pop off all
the collaborator mutations,

00:20:17.570 --> 00:20:20.990
until we find one that belonged
to the local user.

00:20:20.990 --> 00:20:24.950
When that happens, we pull the
local user's mutation off and

00:20:24.950 --> 00:20:27.940
we transform it against all of
the collaborator mutations

00:20:27.940 --> 00:20:29.330
that have happened since.

00:20:29.330 --> 00:20:32.410
So in this case, the delete gets
transformed against this

00:20:32.410 --> 00:20:36.120
insert mutation from which we
know we need to shift the

00:20:36.120 --> 00:20:38.270
delete over by four
characters.

00:20:38.270 --> 00:20:41.395
So we get out this transformed
mutation, which when we apply

00:20:41.395 --> 00:20:44.845
it the model, undoes exactly
what the user did before.

00:20:47.490 --> 00:20:51.180
So we've talked a little bit
now about how all the stuff

00:20:51.180 --> 00:20:52.810
sort of works behind
the scenes.

00:20:52.810 --> 00:20:55.240
It turns out you really don't
have to know all that in order

00:20:55.240 --> 00:20:56.710
to be able to use the API.

00:20:56.710 --> 00:20:59.380
But it can come in handy a
little bit as you're designing

00:20:59.380 --> 00:21:02.340
your data models to just
have a little bit of an

00:21:02.340 --> 00:21:04.650
understanding of how these
conflicts are handled, so you

00:21:04.650 --> 00:21:06.960
can understand the implications
of the choices

00:21:06.960 --> 00:21:08.660
you're making in your
data model.

00:21:08.660 --> 00:21:11.630
So now we're just going to go
through a few examples of data

00:21:11.630 --> 00:21:14.460
models in this event planning
system so you can see some of

00:21:14.460 --> 00:21:16.400
the challenges that come up
when you're working in a

00:21:16.400 --> 00:21:17.720
collaborative system.

00:21:17.720 --> 00:21:21.290
So in this event planning
system, you have a bunch of

00:21:21.290 --> 00:21:24.010
tasks, each represented by
one of these blue cards.

00:21:24.010 --> 00:21:26.800
And each task has some
properties associated with it,

00:21:26.800 --> 00:21:29.540
like what the task is that has
to happen and how much time

00:21:29.540 --> 00:21:30.820
it's going to take.

00:21:30.820 --> 00:21:33.700
And then it's organized into
columns, where each column is

00:21:33.700 --> 00:21:37.780
the work assigned to
a particular user.

00:21:37.780 --> 00:21:39.600
So here's an example
of what this data

00:21:39.600 --> 00:21:40.750
model might look like.

00:21:40.750 --> 00:21:44.690
You could have a collaborative
map of users, each of which

00:21:44.690 --> 00:21:47.510
contains a collaborative list
for each user, which in turn

00:21:47.510 --> 00:21:50.035
contains the specific tasks
that are assigned to them.

00:21:52.930 --> 00:21:57.130
And so one situation that might
come up is here we have

00:21:57.130 --> 00:22:00.140
two properties, time and unit,
that are sort of intrinsically

00:22:00.140 --> 00:22:01.120
tied together.

00:22:01.120 --> 00:22:03.150
It doesn't really make sense
to update one of these

00:22:03.150 --> 00:22:05.660
properties without also updating
the other one.

00:22:05.660 --> 00:22:08.790
Or at least, they should
go together.

00:22:08.790 --> 00:22:12.330
So how would you handle updating
these two properties

00:22:12.330 --> 00:22:14.090
atomically?

00:22:14.090 --> 00:22:16.550
Well, so this task is
represented by something

00:22:16.550 --> 00:22:20.080
called a custom object, which is
basically just a fancy way

00:22:20.080 --> 00:22:23.190
of being able to assign
names to specific

00:22:23.190 --> 00:22:25.090
collaborative fields.

00:22:25.090 --> 00:22:27.710
So that means that when you
change the values on these

00:22:27.710 --> 00:22:31.650
fields, what you end up with are
two set mutations, one for

00:22:31.650 --> 00:22:33.870
the unit and one for the time.

00:22:33.870 --> 00:22:36.600
And this is all great as long as
only one person is making a

00:22:36.600 --> 00:22:38.470
change at the same time because
you set the two

00:22:38.470 --> 00:22:40.080
properties and you're happy.

00:22:40.080 --> 00:22:42.830
But the problem comes in when
somebody else comes in and

00:22:42.830 --> 00:22:44.810
makes a change at
the same time.

00:22:44.810 --> 00:22:47.890
And the problem is that you
can't control the order in

00:22:47.890 --> 00:22:49.210
which these changes happen.

00:22:49.210 --> 00:22:51.320
It's left up to sort of the
vagaries of the network

00:22:51.320 --> 00:22:52.530
communication.

00:22:52.530 --> 00:22:56.360
So it's possible that half of
Salina's change is actually

00:22:56.360 --> 00:22:58.580
going to come before Amir's
change, and the other half

00:22:58.580 --> 00:22:59.850
comes after.

00:22:59.850 --> 00:23:02.340
And so the result of this is
going to be that you have a

00:23:02.340 --> 00:23:05.490
task that has the time from what
Salina tried to set it

00:23:05.490 --> 00:23:08.450
to, but the units from what
Amir tried to set it to.

00:23:08.450 --> 00:23:09.670
And this is obviously wrong.

00:23:09.670 --> 00:23:11.590
You just don't want this
two changes to be

00:23:11.590 --> 00:23:13.340
intermixing like this.

00:23:13.340 --> 00:23:14.780
So what do you do?

00:23:14.780 --> 00:23:18.150
We solved this with a concept
called compound operations.

00:23:18.150 --> 00:23:21.090
So what a compound operation is,
is a way to tell us that

00:23:21.090 --> 00:23:24.260
these mutations belong to a
set and should be applied

00:23:24.260 --> 00:23:26.050
together at the same time.

00:23:26.050 --> 00:23:29.220
So all you do to create a
compound operation is tell the

00:23:29.220 --> 00:23:30.710
model you're beginning one.

00:23:30.710 --> 00:23:32.690
And then you go and make a bunch
of changes to your data

00:23:32.690 --> 00:23:35.950
model, like setting the units or
the time, and then you end

00:23:35.950 --> 00:23:38.370
the compound operation.

00:23:38.370 --> 00:23:41.540
And what happens now is the
mutations that resulted in all

00:23:41.540 --> 00:23:44.730
the changes you made inside that
block get sent over the

00:23:44.730 --> 00:23:46.800
network together as a set.

00:23:46.800 --> 00:23:50.510
And you can guarantee that
they'll always be processed in

00:23:50.510 --> 00:23:53.490
order with nothing else being
processed in between.

00:23:53.490 --> 00:23:56.350
So now we know that Amir's
change is always going to be

00:23:56.350 --> 00:23:58.540
processed fully before
we process anything

00:23:58.540 --> 00:23:59.980
from Salina's change.

00:23:59.980 --> 00:24:03.060
And so now we can guarantee that
the end task is going to

00:24:03.060 --> 00:24:05.096
be in a consistent state.

00:24:05.096 --> 00:24:07.000
Now, Brian's going to work
through a different example.

00:24:07.000 --> 00:24:08.380
BRIAN CAIRNS: Thanks, Cheryl.

00:24:08.380 --> 00:24:10.080
So here's another use
case that you

00:24:10.080 --> 00:24:11.440
might see in this system.

00:24:11.440 --> 00:24:12.780
Let's say you have
some priority

00:24:12.780 --> 00:24:13.990
assigned to these tasks.

00:24:13.990 --> 00:24:16.650
In this case, we have high,
medium, and low, but you might

00:24:16.650 --> 00:24:19.650
have a real numbered priority
or something like that.

00:24:19.650 --> 00:24:21.920
And you wanted to keep them
sorted in some sort of

00:24:21.920 --> 00:24:25.000
priority order where high tasks
appear first in the UI,

00:24:25.000 --> 00:24:28.270
and then medium, and then low.

00:24:28.270 --> 00:24:31.490
Well, you might think the best
way to do this is to just sort

00:24:31.490 --> 00:24:32.615
the data model.

00:24:32.615 --> 00:24:35.460
But the problem is that any sort
you do in this system is

00:24:35.460 --> 00:24:38.040
going to be represented to the
server and to every other

00:24:38.040 --> 00:24:40.810
collaborator as a series
of inserts and deletes.

00:24:40.810 --> 00:24:43.990
And there's nothing stopping
anyone from interleaving other

00:24:43.990 --> 00:24:47.070
inserts or deletes in between
these changes.

00:24:47.070 --> 00:24:48.790
Or, for that matter, two
people trying to

00:24:48.790 --> 00:24:50.380
sort at the same time.

00:24:50.380 --> 00:24:54.840
And the system has no knowledge,
the Realtime API

00:24:54.840 --> 00:24:56.630
has no knowledge that you wanted
this to be sorted.

00:24:56.630 --> 00:25:00.110
And as a result, it has no way
to know that these changes are

00:25:00.110 --> 00:25:02.840
somehow interrelated in
very complex ways.

00:25:02.840 --> 00:25:05.450
And the result you end up with
is that the sorted list is not

00:25:05.450 --> 00:25:07.210
necessarily going
to stay sorted.

00:25:07.210 --> 00:25:10.060
In this case, we have an insert
of a high priority task

00:25:10.060 --> 00:25:12.590
first, and then an insert of
a medium priority task.

00:25:12.590 --> 00:25:15.220
And of course, because the way
indexes work, the medium

00:25:15.220 --> 00:25:18.080
priority task will end up first
in the list, which is

00:25:18.080 --> 00:25:20.040
not what you want.

00:25:20.040 --> 00:25:22.170
So the solution to this
kind of problem--

00:25:22.170 --> 00:25:24.340
and this is actually a generic
solution that works with all

00:25:24.340 --> 00:25:26.510
kinds of different problems
you end up with in the

00:25:26.510 --> 00:25:27.150
Realtime API.

00:25:27.150 --> 00:25:30.880
And it's very powerful, is to
keep your data model unsorted,

00:25:30.880 --> 00:25:33.220
and then do a sort.

00:25:33.220 --> 00:25:36.390
But only keep a sorted view
of the data model.

00:25:36.390 --> 00:25:38.770
So this sorted view is something
that's just local to

00:25:38.770 --> 00:25:41.320
your client and in memory.

00:25:41.320 --> 00:25:45.090
And you might think that this
is very inefficient.

00:25:45.090 --> 00:25:47.830
I mean, after all, sorting is
not necessarily the cheapest

00:25:47.830 --> 00:25:49.470
operation and you might
be doing it a lot.

00:25:49.470 --> 00:25:52.540
But the reality is you can be a
little bit lazier than that.

00:25:52.540 --> 00:25:54.390
As it turns out, you can
sort just when the

00:25:54.390 --> 00:25:56.250
user loads the document.

00:25:56.250 --> 00:25:59.150
And then, you add listeners
to the unsorted view.

00:25:59.150 --> 00:26:03.375
And as users insert or delete
items from the unsorted view

00:26:03.375 --> 00:26:06.980
or move them around, all you
have to do is a simple binary

00:26:06.980 --> 00:26:10.410
search on your view to figure
out what's the location of

00:26:10.410 --> 00:26:12.780
those items.

00:26:12.780 --> 00:26:15.980
And this sort of keep a modified
view, and then update

00:26:15.980 --> 00:26:18.735
it based on listeners is a very
powerful technique that

00:26:18.735 --> 00:26:22.260
can solve a wide variety
of problems.

00:26:22.260 --> 00:26:24.211
So let's look at another task.

00:26:24.211 --> 00:26:25.010
CHERYL SIMON: All right.

00:26:25.010 --> 00:26:27.590
So another situation that you
want to be able to do in this

00:26:27.590 --> 00:26:30.710
application is to assign tasks
to different users.

00:26:30.710 --> 00:26:32.950
So you can do this just by
dragging something from one

00:26:32.950 --> 00:26:35.200
column into another.

00:26:35.200 --> 00:26:38.830
So this is a little bit
problematic, again, in a

00:26:38.830 --> 00:26:41.340
collaborative environment
because this move is not an

00:26:41.340 --> 00:26:42.690
atomic operation.

00:26:42.690 --> 00:26:44.940
The move is actually going
to be represented by two

00:26:44.940 --> 00:26:48.140
different mutations, a
delete and an insert.

00:26:48.140 --> 00:26:51.430
And so again, if two people make
changes at the same time,

00:26:51.430 --> 00:26:52.600
you end up with problems.

00:26:52.600 --> 00:26:55.710
In this case, you end up with
having the task in two

00:26:55.710 --> 00:26:58.370
different users' queues, which
is obviously not what you were

00:26:58.370 --> 00:26:59.450
looking for.

00:26:59.450 --> 00:27:01.660
So what do we do about this?

00:27:01.660 --> 00:27:03.560
Well, one thing you might think
is a solution, because

00:27:03.560 --> 00:27:05.690
it was a solution to a kind of
similar problem before, is

00:27:05.690 --> 00:27:07.180
compound operations.

00:27:07.180 --> 00:27:08.800
But it turns out that
this doesn't solve

00:27:08.800 --> 00:27:10.320
this particular problem.

00:27:10.320 --> 00:27:13.200
And the reason is that all a
compound operation does is

00:27:13.200 --> 00:27:16.490
affect the order in which the
mutations are applied, but it

00:27:16.490 --> 00:27:19.280
doesn't affect how the mutations
are transformed.

00:27:19.280 --> 00:27:23.730
So in this case, we get these
two compound operations and we

00:27:23.730 --> 00:27:27.130
still individually transform
every mutation within them

00:27:27.130 --> 00:27:29.740
against every other mutation,
and then apply them

00:27:29.740 --> 00:27:31.260
individually.

00:27:31.260 --> 00:27:33.940
So the first transformation
is a [INAUDIBLE]

00:27:33.940 --> 00:27:35.330
because we'll just assume
we don't have

00:27:35.330 --> 00:27:36.840
any historical state.

00:27:36.840 --> 00:27:40.280
But then the second one, we're
going to start with this

00:27:40.280 --> 00:27:42.670
delete here and transform it
against the delete and the

00:27:42.670 --> 00:27:44.340
insert that came before.

00:27:44.340 --> 00:27:47.450
Here, the delete actually just
goes away, because the delete

00:27:47.450 --> 00:27:47.985
already happened.

00:27:47.985 --> 00:27:49.930
So it gets transformed in all.

00:27:49.930 --> 00:27:52.700
But the insert is actually the
one that we want to go away,

00:27:52.700 --> 00:27:53.810
and it doesn't.

00:27:53.810 --> 00:27:56.530
Because if you transform the
insert against the delete and

00:27:56.530 --> 00:27:57.900
the insert and the
delete that came

00:27:57.900 --> 00:28:00.160
before it, nothing happens.

00:28:00.160 --> 00:28:02.500
They're all affecting different
lists, so it doesn't

00:28:02.500 --> 00:28:04.860
really affect the ability for
us to do this insert.

00:28:04.860 --> 00:28:06.340
So it happens anyways.

00:28:06.340 --> 00:28:09.050
So you still end up with a case
where you have the thing

00:28:09.050 --> 00:28:12.080
inserted into two
different lists.

00:28:12.080 --> 00:28:14.690
So what you want to do instead,
is to adjust your

00:28:14.690 --> 00:28:17.850
data model to make it so that
this assignment is actually an

00:28:17.850 --> 00:28:19.300
atomic operation.

00:28:19.300 --> 00:28:23.250
So before, we had a list for
every individual user, which

00:28:23.250 --> 00:28:25.930
represented the tasks that
belonged to the user.

00:28:25.930 --> 00:28:28.560
What we could do instead is
just have a single list of

00:28:28.560 --> 00:28:30.670
tasks and make the
assignee just a

00:28:30.670 --> 00:28:33.050
field on the task object.

00:28:33.050 --> 00:28:36.290
And because it's a field in a
custom object, it just becomes

00:28:36.290 --> 00:28:38.360
a set operation.

00:28:38.360 --> 00:28:41.250
And if you transform two set
operations against each other,

00:28:41.250 --> 00:28:42.700
one of them is always
going to win.

00:28:42.700 --> 00:28:45.730
So you guarantee that you'll
always have exactly one

00:28:45.730 --> 00:28:51.180
assignee for the card, which is
what you were looking for.

00:28:51.180 --> 00:28:53.390
So up till now, we've been
talking about things that you

00:28:53.390 --> 00:28:55.250
can do in the API today.

00:28:55.250 --> 00:28:57.470
So now Brian's going to give
us a little bit of a sneak

00:28:57.470 --> 00:28:59.230
peak about what's
coming up soon.

00:28:59.230 --> 00:29:01.350
BRIAN CAIRNS: Thanks, Cheryl.

00:29:01.350 --> 00:29:04.730
So one thing that we've gotten
a lot of feedback on, and we

00:29:04.730 --> 00:29:07.060
know that you value a lot, is
the ability to get your data

00:29:07.060 --> 00:29:09.180
out of the Realtime API.

00:29:09.180 --> 00:29:10.760
And there's a lot of reasons
you might want to do this.

00:29:10.760 --> 00:29:13.740
You might want to backup your
data, or you might want to do

00:29:13.740 --> 00:29:16.520
processing of the data in the
Realtime API on your server,

00:29:16.520 --> 00:29:17.980
and we want to make
that possible.

00:29:17.980 --> 00:29:20.220
So we're excited to announce
that we're going to be adding

00:29:20.220 --> 00:29:23.760
the capability to the Drive API
to take a realtime data

00:29:23.760 --> 00:29:26.320
model and export a JSON
representation

00:29:26.320 --> 00:29:28.080
of that data model.

00:29:28.080 --> 00:29:31.370
Now, because this is part of the
Drive API, you can use any

00:29:31.370 --> 00:29:33.820
of the great client libraries we
have for the Drive API for

00:29:33.820 --> 00:29:34.740
a variety of languages.

00:29:34.740 --> 00:29:39.090
Or, if you want, you can just
use a very simple HTTP RESTful

00:29:39.090 --> 00:29:41.080
call to download this
data model.

00:29:41.080 --> 00:29:43.200
And again, we use OAuth
2.0 for this.

00:29:43.200 --> 00:29:46.190
It's very simple
to get set up.

00:29:46.190 --> 00:29:47.440
And you get this--

00:29:53.730 --> 00:29:55.680
What the user does to the
document or whatever app

00:29:55.680 --> 00:29:58.460
you're building, we always
generate a consistent format.

00:29:58.460 --> 00:30:00.830
And it's designed to be easy
to understand from a human

00:30:00.830 --> 00:30:04.040
perspective and easy for you
to work with in code.

00:30:04.040 --> 00:30:08.100
Well, of course, the natural
follow-up to I can export the

00:30:08.100 --> 00:30:11.840
data is, what do I do with
it once I get it out?

00:30:11.840 --> 00:30:14.240
And so we're also going to be
adding the capability, again

00:30:14.240 --> 00:30:17.520
to the Drive API, to take this
exported representation and

00:30:17.520 --> 00:30:20.240
convert it back into a
realtime data model.

00:30:20.240 --> 00:30:23.360
So let's say you have a JSON
that has been exported, and

00:30:23.360 --> 00:30:25.470
maybe you've done some
modifications to it.

00:30:25.470 --> 00:30:28.270
What you can do is you can
upload it to the Drive API.

00:30:28.270 --> 00:30:31.260
Again, this is very simple using
our client libraries or

00:30:31.260 --> 00:30:36.370
using a simple HTTP post call.

00:30:36.370 --> 00:30:39.640
We then take that uploaded
representation and

00:30:39.640 --> 00:30:41.730
reconstitute a realtime
data model.

00:30:41.730 --> 00:30:44.480
This is our sort of
temporary model.

00:30:44.480 --> 00:30:47.100
And we take this temporary
model, along with the current

00:30:47.100 --> 00:30:50.880
data model as it exists on the
server, and we run them

00:30:50.880 --> 00:30:52.250
through a diffing algorithm.

00:30:52.250 --> 00:30:54.670
And the diffing algorithm
actually computes the

00:30:54.670 --> 00:30:58.190
mutations that take the current
state that's on the

00:30:58.190 --> 00:31:02.360
server and transform it into the
state that you uploaded.

00:31:02.360 --> 00:31:03.940
In this case, there's an
insert and a delete.

00:31:03.940 --> 00:31:05.870
And again, these are just
mutations, just like any other

00:31:05.870 --> 00:31:07.530
mutations in the system.

00:31:07.530 --> 00:31:11.020
And then what we do is we apply
these mutations back to

00:31:11.020 --> 00:31:13.690
the data model on the server.

00:31:13.690 --> 00:31:16.870
And the net result of this is
that if there were changes

00:31:16.870 --> 00:31:19.280
going on, they actually end up
getting merged together.

00:31:19.280 --> 00:31:21.760
And if you have collaborators
working on the document, they

00:31:21.760 --> 00:31:23.870
see the final result
immediately.

00:31:23.870 --> 00:31:26.710
They don't have to reload or
do anything like that.

00:31:26.710 --> 00:31:28.720
They see the changes in realtime
just like they came

00:31:28.720 --> 00:31:30.490
from any other collaborator.

00:31:30.490 --> 00:31:32.750
And so we think this is a really
great capability that

00:31:32.750 --> 00:31:36.190
you're all going to love
and use in cool ways.

00:31:36.190 --> 00:31:40.100
But we also understand that
you might want to have the

00:31:40.100 --> 00:31:43.660
full richness of the Realtime
API and programming model in

00:31:43.660 --> 00:31:44.450
different contexts.

00:31:44.450 --> 00:31:46.410
And of course, one of the
obvious contexts is you want

00:31:46.410 --> 00:31:48.130
to develop a mobile app.

00:31:48.130 --> 00:31:50.750
So we're also excited to
announce that we're working on

00:31:50.750 --> 00:31:55.070
an Android Java API for
the Realtime API.

00:31:55.070 --> 00:31:57.820
So this will give you the same
sort of great, easy to use

00:31:57.820 --> 00:32:01.050
objects, collaborative
objects, and other

00:32:01.050 --> 00:32:04.130
capabilities as our JavaScript
API, but in a Java

00:32:04.130 --> 00:32:04.640
environment.

00:32:04.640 --> 00:32:07.900
And I should say, we want this
to work really well on

00:32:07.900 --> 00:32:10.890
Android, so we're doing a lot of
work on things like keeping

00:32:10.890 --> 00:32:14.340
CPU usage low and making
sure that we're not

00:32:14.340 --> 00:32:15.450
using a lot of bandwidth.

00:32:15.450 --> 00:32:17.700
But this is a generic
Java API.

00:32:17.700 --> 00:32:20.300
So if you want to use it in a
desktop Java application, or

00:32:20.300 --> 00:32:22.780
you want to use it in a
server-side Java application,

00:32:22.780 --> 00:32:23.600
that's great, too.

00:32:23.600 --> 00:32:26.230
And it'll work wonderfully.

00:32:26.230 --> 00:32:29.480
And of course, because we have
this sort of data model that

00:32:29.480 --> 00:32:31.660
we've built from the ground
up, we can provide

00:32:31.660 --> 00:32:33.300
cross-platform compatibility.

00:32:33.300 --> 00:32:36.750
So the Java API and the
JavaScript API work on the

00:32:36.750 --> 00:32:38.130
same data models.

00:32:38.130 --> 00:32:41.310
And we automatically translate
between types for you.

00:32:41.310 --> 00:32:44.380
So if you have a collaborative
string, for example, in

00:32:44.380 --> 00:32:46.850
JavaScript, you get the
JavaScript object, the

00:32:46.850 --> 00:32:49.320
gabi.drive.realtime.collab
string.

00:32:49.320 --> 00:32:51.640
Which will have the properties
and other things that you

00:32:51.640 --> 00:32:55.120
expect from a JavaScript
implementation.

00:32:55.120 --> 00:32:57.060
If you take that same data model
and load it with the

00:32:57.060 --> 00:33:00.720
Java API, what you'll get is
another collaborative string

00:33:00.720 --> 00:33:01.780
but written in Java.

00:33:01.780 --> 00:33:04.080
And the Java version will
support the same interfaces

00:33:04.080 --> 00:33:07.500
that you expect from Java,
things like appendable.

00:33:07.500 --> 00:33:10.080
So this makes it a great way to
build cross-platform apps

00:33:10.080 --> 00:33:11.440
that share the same data.

00:33:14.750 --> 00:33:16.640
CHERYL SIMON: So that's all
we have for you today.

00:33:16.640 --> 00:33:19.320
I hope you guys learned a little
bit about the Realtime

00:33:19.320 --> 00:33:21.850
API, and how it can make it
really easy for you to add

00:33:21.850 --> 00:33:23.960
collaboration to your
own applications.

00:33:23.960 --> 00:33:25.870
And I hope you have a little bit
better of an understanding

00:33:25.870 --> 00:33:28.090
of how it works behind the
scenes, so this can help you

00:33:28.090 --> 00:33:31.250
design really good data models
that will make your

00:33:31.250 --> 00:33:33.990
applications just work
really well.

00:33:33.990 --> 00:33:35.230
But now it's your turn.

00:33:35.230 --> 00:33:37.930
So we think we have a really
great technology here that can

00:33:37.930 --> 00:33:40.120
enable some really amazing
applications.

00:33:40.120 --> 00:33:43.510
But you guys are the ones with
the great application ideas.

00:33:43.510 --> 00:33:45.140
So we just hope that you
can go out there

00:33:45.140 --> 00:33:45.960
and put this to use.

00:33:45.960 --> 00:33:49.340
And we're really excited to
see what you have going.

00:33:49.340 --> 00:33:51.170
So now we have time for
a few questions here.

00:33:51.170 --> 00:33:53.070
And if you don't want to stick
around, we'll be upstairs in

00:33:53.070 --> 00:33:56.070
the Chrome Apps area later on
this afternoon, so you can

00:33:56.070 --> 00:33:58.594
come find us.

00:33:58.594 --> 00:34:06.380
[APPLAUSE]

00:34:06.380 --> 00:34:08.580
AUDIENCE: So I was just
curious about your

00:34:08.580 --> 00:34:09.590
implementation for that.

00:34:09.590 --> 00:34:12.540
Do you guys use WebSockets
or long polling?

00:34:12.540 --> 00:34:12.730
BRIAN CAIRNS: Yeah.

00:34:12.730 --> 00:34:17.220
So we use long get requests.

00:34:21.929 --> 00:34:24.940
So we use cores to do
cross-origin communication.

00:34:24.940 --> 00:34:28.060
And sort of the design of the
system is we want to be

00:34:28.060 --> 00:34:29.510
transport agnostic.

00:34:29.510 --> 00:34:32.489
So we used long gets because we
want to have compatibility

00:34:32.489 --> 00:34:35.929
with older browsers, like we
support Internet Explorer 9.

00:34:35.929 --> 00:34:38.739
But we haven't seen a huge
advantage of going to

00:34:38.739 --> 00:34:39.780
WebSockets at this point.

00:34:39.780 --> 00:34:43.420
If that's something that is
something we want, that'll be

00:34:43.420 --> 00:34:44.880
something that'll be transparent
to your app.

00:34:44.880 --> 00:34:48.520
And again, on the Java API, and
all of the other APIs we

00:34:48.520 --> 00:34:49.980
do, are not necessarily
going to use the

00:34:49.980 --> 00:34:51.080
same transport mechanism.

00:34:51.080 --> 00:34:52.620
AUDIENCE: And then, my other
question was, so one of the

00:34:52.620 --> 00:34:54.949
things that you get with Google
Apps is the ability to

00:34:54.949 --> 00:34:56.692
have revision history.

00:34:56.692 --> 00:35:00.090
Is that something that
we have with this?

00:35:00.090 --> 00:35:03.010
BRIAN CAIRNS: So we have not
yet exposed the revision

00:35:03.010 --> 00:35:03.960
history for documents.

00:35:03.960 --> 00:35:05.980
It's something we're
already keeping.

00:35:05.980 --> 00:35:09.060
And we don't have anything to
announce right now, but that

00:35:09.060 --> 00:35:10.530
would definitely be a capability
that would be

00:35:10.530 --> 00:35:11.675
really cool to have.

00:35:11.675 --> 00:35:14.690
AUDIENCE: OK, thanks.

00:35:14.690 --> 00:35:18.030
AUDIENCE: Hi, John Blossom.

00:35:18.030 --> 00:35:21.060
It sounds like you've avoided
certain things that were in

00:35:21.060 --> 00:35:25.350
Wave protocol, such as XMPP
underpinnings and going to

00:35:25.350 --> 00:35:28.440
character-by-character updates
and things of that sort.

00:35:28.440 --> 00:35:29.950
BRIAN CAIRNS: Well, I should
say, we can do

00:35:29.950 --> 00:35:31.480
character-by-character
updates.

00:35:31.480 --> 00:35:31.900
AUDIENCE: You can.

00:35:31.900 --> 00:35:34.590
But if I understand from the
examples, that's not what

00:35:34.590 --> 00:35:37.880
you're doing in terms of
managing the stack of updates.

00:35:37.880 --> 00:35:39.850
BRIAN CAIRNS: So an update could
be a single character

00:35:39.850 --> 00:35:42.300
insert or a single
character delete.

00:35:42.300 --> 00:35:45.220
We have, basically, a throttling
algorithm in place,

00:35:45.220 --> 00:35:48.700
so that we batch up updates so
that we're not using tons and

00:35:48.700 --> 00:35:49.970
tons of bandwidth for
single characters.

00:35:49.970 --> 00:35:51.570
AUDIENCE: So, in effect,
what you have is a

00:35:51.570 --> 00:35:52.810
micro-timer if you will.

00:35:52.810 --> 00:35:56.240
If somebody's a fast typer,
then that's one update?

00:35:56.240 --> 00:35:57.560
BRIAN CAIRNS: Right.

00:35:57.560 --> 00:35:59.620
And in fact, the algorithm's
actually somewhat adaptive.

00:35:59.620 --> 00:36:01.470
So it tries to prioritize
low latency if

00:36:01.470 --> 00:36:03.760
updates are coming slowly.

00:36:03.760 --> 00:36:06.180
And then, it tries to
prioritize bandwidth

00:36:06.180 --> 00:36:10.042
efficiency if updates are
coming more quickly.

00:36:10.042 --> 00:36:11.292
AUDIENCE: [INAUDIBLE].

00:36:13.770 --> 00:36:14.410
AUDIENCE: Makes sense.

00:36:14.410 --> 00:36:15.240
Thank you.

00:36:15.240 --> 00:36:19.980
On the JSON exporting of the
data, you're exporting the

00:36:19.980 --> 00:36:20.620
data model.

00:36:20.620 --> 00:36:22.650
And as you said, it would be
nice if you could export the

00:36:22.650 --> 00:36:24.230
history stack.

00:36:24.230 --> 00:36:29.430
Is there any provision of being
able to export access

00:36:29.430 --> 00:36:33.400
capabilities for a
federated model?

00:36:33.400 --> 00:36:34.820
BRIAN CAIRNS: So we don't have
anything to announce

00:36:34.820 --> 00:36:36.500
right now on that.

00:36:36.500 --> 00:36:38.280
I would love to chat about that
if you want to come to

00:36:38.280 --> 00:36:38.820
office hours, though.

00:36:38.820 --> 00:36:39.560
AUDIENCE: Sure.

00:36:39.560 --> 00:36:40.720
Thanks.

00:36:40.720 --> 00:36:42.016
CHERYL SIMON: Gentleman
in the back.

00:36:42.016 --> 00:36:45.150
AUDIENCE: Do you have a maximum
number of subscribers

00:36:45.150 --> 00:36:46.520
or collaborators?

00:36:46.520 --> 00:36:49.750
BRIAN CAIRNS: I think the
maximum number is 50.

00:36:49.750 --> 00:36:51.990
Beyond that, the more
collaborators you get, they

00:36:51.990 --> 00:36:54.090
end up in a read-only mode.

00:36:54.090 --> 00:36:56.870
So it's 50 actively editing
collaborators at a time.

00:36:56.870 --> 00:37:00.045
AUDIENCE: So you can have
anonymous collaborators that

00:37:00.045 --> 00:37:00.855
don't collaborate?

00:37:00.855 --> 00:37:02.220
They're kind of read-only?

00:37:02.220 --> 00:37:05.920
Could use it kind of like as
a PubSub kind of thing?

00:37:05.920 --> 00:37:09.310
BRIAN CAIRNS: We're probably not
the best thing to use as a

00:37:09.310 --> 00:37:10.960
PubSub kind of thing.

00:37:10.960 --> 00:37:13.100
But, I mean, yeah, that's
certainly a use case that you

00:37:13.100 --> 00:37:15.140
might consider if you like other
properties of the API.

00:37:17.970 --> 00:37:19.370
AUDIENCE: How would you
represent something like a

00:37:19.370 --> 00:37:22.450
Google Docs, which has on one
hand, like a large body of

00:37:22.450 --> 00:37:25.120
text, and on the other hand,
like the possibility to modify

00:37:25.120 --> 00:37:27.110
individual characters
and attributes?

00:37:27.110 --> 00:37:31.140
So what kind of data model
would you use for that?

00:37:31.140 --> 00:37:32.600
CHERYL SIMON: So you're asking
what kind of data model you

00:37:32.600 --> 00:37:34.490
would use to represent, like
a Google document?

00:37:34.490 --> 00:37:34.876
AUDIENCE: Yes.

00:37:34.876 --> 00:37:35.262
AUDIENCE: Format.

00:37:35.262 --> 00:37:35.800
AUDIENCE: Yes, formatting.

00:37:35.800 --> 00:37:37.750
CHERYL SIMON: Oh,
the formatting.

00:37:37.750 --> 00:37:39.710
Well, obviously the string
is pretty easy.

00:37:39.710 --> 00:37:41.210
We have a collaborative string,
which we didn't really

00:37:41.210 --> 00:37:43.630
talk about here, but which
automatically handles all the

00:37:43.630 --> 00:37:45.350
updates and edits
to the string.

00:37:45.350 --> 00:37:47.930
And we also have this thing
called index references, which

00:37:47.930 --> 00:37:50.850
is a way for you to sort of put
a pointer at a location in

00:37:50.850 --> 00:37:53.220
the string and it will
automatically shift rounds

00:37:53.220 --> 00:37:54.280
with the updates.

00:37:54.280 --> 00:37:57.640
And so we actually, historically
had a version of

00:37:57.640 --> 00:38:00.380
this working with these index
references, where basically

00:38:00.380 --> 00:38:02.510
you can mark the beginning
and end of formatting

00:38:02.510 --> 00:38:04.870
areas in order to--

00:38:04.870 --> 00:38:07.765
and then you can apply that
at the rendering phase.

00:38:07.765 --> 00:38:08.830
BRIAN CAIRNS: And let's
try to take a

00:38:08.830 --> 00:38:10.400
question, if we can, from--

00:38:13.900 --> 00:38:14.500
CHERYL SIMON: While he's
setting that up,

00:38:14.500 --> 00:38:15.370
you want to go ahead?

00:38:15.370 --> 00:38:16.070
AUDIENCE: Sure.

00:38:16.070 --> 00:38:19.360
How do you handle authorization
in the data

00:38:19.360 --> 00:38:23.180
model in terms of segmentation
of what certain users or

00:38:23.180 --> 00:38:26.580
certain roles can have access
to edit or not access?

00:38:26.580 --> 00:38:29.100
CHERYL SIMON: So the Realtime
Docs are just Google Documents

00:38:29.100 --> 00:38:29.940
in Google Drive.

00:38:29.940 --> 00:38:33.470
So we use their sharing and
authorization services.

00:38:33.470 --> 00:38:37.730
So you can have viewers and
editors, and you can actually

00:38:37.730 --> 00:38:40.640
integrate with the common
sharing dialog in order to

00:38:40.640 --> 00:38:42.260
have that all be configured.

00:38:42.260 --> 00:38:43.300
AUDIENCE: So that's
at the document

00:38:43.300 --> 00:38:44.390
level, the entire document?

00:38:44.390 --> 00:38:48.820
BRIAN CAIRNS: The unit of
access controls at the

00:38:48.820 --> 00:38:51.320
document level and each one
will have a document ID.

00:38:51.320 --> 00:38:54.110
And you can manipulate these
with Drive API if you want to

00:38:54.110 --> 00:38:56.140
do permissions or whatever.

00:38:56.140 --> 00:38:57.600
You can have multiple documents

00:38:57.600 --> 00:38:58.530
open at the same time.

00:38:58.530 --> 00:38:59.950
So if you want to have--

00:38:59.950 --> 00:39:01.910
in a single application, you
want to have different parts

00:39:01.910 --> 00:39:03.770
that have different access
rules, that's definitely

00:39:03.770 --> 00:39:04.350
something you can do.

00:39:04.350 --> 00:39:06.370
And in fact, something
when Neutron Drive

00:39:06.370 --> 00:39:08.030
does exactly that.

00:39:08.030 --> 00:39:10.320
AUDIENCE: Is that multiplexed
over the same connection then?

00:39:10.320 --> 00:39:12.340
BRIAN CAIRNS: So right now
we do not have connection

00:39:12.340 --> 00:39:12.970
multiplexing.

00:39:12.970 --> 00:39:17.530
There's a separate browser
channel for each one of those.

00:39:17.530 --> 00:39:19.682
AUDIENCE: OK, thanks.

00:39:19.682 --> 00:39:22.530
AUDIENCE: Is it possible to use
the Realtime API for an

00:39:22.530 --> 00:39:23.550
offline sync?

00:39:23.550 --> 00:39:25.950
So two users make changes
independently offline and then

00:39:25.950 --> 00:39:27.480
want to sync them?

00:39:27.480 --> 00:39:28.870
BRIAN CAIRNS: So we don't
currently have offline

00:39:28.870 --> 00:39:32.590
capability, except I should
note the import/export

00:39:32.590 --> 00:39:33.870
capability is actually a pretty

00:39:33.870 --> 00:39:36.330
decent way to do offline.

00:39:36.330 --> 00:39:38.640
I think we're a little bit out
of time, but I would be happy

00:39:38.640 --> 00:39:41.070
to talk about different ways you
could implement offline if

00:39:41.070 --> 00:39:42.140
you'd like to come
to office hours.

00:39:42.140 --> 00:39:45.790
And I should say, office hours
is immediately, right now,

00:39:45.790 --> 00:39:50.990
after this talk upstairs in the
Chrome section over by the

00:39:50.990 --> 00:39:52.374
question booth.

00:39:52.374 --> 00:39:53.170
Thank you all.

00:39:53.170 --> 00:39:54.420
CHERYL SIMON: Thanks.

