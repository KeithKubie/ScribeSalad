WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:08.189
&gt;&gt; BUTCHER: Okay. Let's get it started then.
So, welcome everyone to Boot Camp and this

00:00:08.189 --> 00:00:14.470
is the Beginner's Guide to Android talk. I
hope you guys are on the right place. As Tim

00:00:14.470 --> 00:00:19.160
ably said in the--in the introduction. This--today
is all about kind of getting you up to speed

00:00:19.160 --> 00:00:22.750
so you kind of know everything you need to
know. So, you can get the most out of IO.

00:00:22.750 --> 00:00:26.650
So, this talk is really pitched for someone
who kind of knows what Android is but has

00:00:26.650 --> 00:00:31.960
never developed for it. My name is--my name
is Nick Butcher. I'm a developer advocate

00:00:31.960 --> 00:00:36.739
out of the London office and I work on Android.
And I love writing Android apps and I hope

00:00:36.739 --> 00:00:40.550
by the end of this you will too. And--and
we will also put in some hashtags here so

00:00:40.550 --> 00:00:47.629
you can join the conversation and chat about
what's going on. So, this is the speakermeter.

00:00:47.629 --> 00:00:52.039
So, as Tim said, this is a kind of experiment
this year, we really will hope you--you can

00:00:52.039 --> 00:00:55.399
use it. So I’ll leave it up there for a
minute. This is a short code, just there so

00:00:55.399 --> 00:01:00.019
if you haven't QR [INDISTINCT] camera app,
you can tie that in. And also for this link

00:01:00.019 --> 00:01:08.560
up at the end, if you want to wait to the
end, to leave your feedback, that's absolutely

00:01:08.560 --> 00:01:13.140
cool. So while people are snapping that picture,
just want to get a quick idea of who is in

00:01:13.140 --> 00:01:20.260
the room. So, could you put your hand up if
you have written an Android app before. Okay.

00:01:20.260 --> 00:01:25.200
Cool. And put your hand up if you've kind
of--had an idea for an Android app but never

00:01:25.200 --> 00:01:29.020
had the know-how to actually write and execute
it. Excellent, so you guys just--is going

00:01:29.020 --> 00:01:33.490
to get the most out of this talk, I hope.
For some of the people that are more experienced,

00:01:33.490 --> 00:01:37.210
I hope you pick up a few tips and tricks along
the way. But I'd really recommend you go to

00:01:37.210 --> 00:01:42.170
the Android best practices lab later on today,
which is really going to teach you some--some

00:01:42.170 --> 00:01:45.920
really good techniques. And also we're going
to be running an introduction to honeycomb

00:01:45.920 --> 00:01:49.200
lab later on. So, if you can see if you're
getting up to speed with tablet development

00:01:49.200 --> 00:01:55.659
then that's the place for you guys. Okay.
So, today I'm going to talk a little bit about

00:01:55.659 --> 00:02:00.499
what Android is and what the Android platform
is and how you develop for it. I’ll talk

00:02:00.499 --> 00:02:04.070
about writing your first app. So, what is
an app, I'll go through the anatomy of what

00:02:04.070 --> 00:02:07.970
it is that makes up an Android application.
I’ll talk about the ways you'd go about

00:02:07.970 --> 00:02:13.190
building it. And then go and to talk a little
bit about some of the unique ways that Android

00:02:13.190 --> 00:02:18.989
lets you surface your content, access hardware
sensors, and then how to make, you know, not

00:02:18.989 --> 00:02:23.489
just a good app but a great app. And then
go into--talking about the tools you can use

00:02:23.489 --> 00:02:28.200
to build these applications and finish up
by going through the process for publishing

00:02:28.200 --> 00:02:35.120
your application on the Android Market. So,
Android, it’s a bit of a juggernaut, it's

00:02:35.120 --> 00:02:40.500
in the kind of newspapers and tech press all
the time; 170 plus devices, 100 countries,

00:02:40.500 --> 00:02:45.670
and shipping 350,000 devices a day. That's
kind of a [INDISTINCT], kind of staggering

00:02:45.670 --> 00:02:49.470
number to me, I feel. My colleague would sit
here last year, saying you know, proudly at

00:02:49.470 --> 00:02:54.049
60,000 devices a day and now we're up 350,000.
So, you can think about the--the slant of

00:02:54.049 --> 00:02:57.780
the graph and the trajectory they're on. A
little bit of mental arithmetic for you, that's

00:02:57.780 --> 00:03:02.290
over a million devices every three days. This
really speaks to the opportunity out there

00:03:02.290 --> 00:03:07.920
and the reach you can have in writing an application
and shipping it. The same thing, that got

00:03:07.920 --> 00:03:12.040
kind of a size of opportunity can seem a bit
daunting as well, when you think of the variety

00:03:12.040 --> 00:03:17.860
and number of devices out there. But the great
thing about writing for a platform rather

00:03:17.860 --> 00:03:22.720
than through a device is that every device
which has the Google services--so, that's

00:03:22.720 --> 00:03:27.680
like Android Market, and Gmail, and Maps for
example, and everybody wants those--has to

00:03:27.680 --> 00:03:35.480
pass a compatibility test suite. This guarantees
that any app written against RSDK will run

00:03:35.480 --> 00:03:41.950
on those devices. So, it's our way of kind
of making it easy for you to write to the

00:03:41.950 --> 00:03:47.129
platform rather than have to worry about individual
device characteristics. So, we build in tools

00:03:47.129 --> 00:03:50.930
to help support many different screen sizes
and resolutions and font factors and hardware,

00:03:50.930 --> 00:03:56.989
and variety, and the system that you take
advantage of those where they're available.

00:03:56.989 --> 00:04:01.950
Android Market also helps you out by filtering
based on what their phone--the applications

00:04:01.950 --> 00:04:06.810
running on and supports--so yeah, if you write
to work to the platform, you don't have to

00:04:06.810 --> 00:04:13.520
worry so much about the underlying phone.
With that said, the platform isn't a static

00:04:13.520 --> 00:04:19.000
thing. You are probably aware that Android
team’s hard at work, releasing--new platform

00:04:19.000 --> 00:04:22.860
releases every kind of three to six months,
so we've just had--Honey Comb came out for

00:04:22.860 --> 00:04:28.810
tablet not long ago and the end of last year
it changed a bit for phones. And we'd advocate

00:04:28.810 --> 00:04:34.080
always kind of targeting the latest and greatest
so you can take advantage of all of the new

00:04:34.080 --> 00:04:38.310
shiny APIs that get released. But we can teach
you techniques to gracefully degrade your

00:04:38.310 --> 00:04:44.200
application. So, if certain functionalities
aren't available in an older platform, you

00:04:44.200 --> 00:04:48.640
can greatly degrade and perhaps use another
technique. So, for example a multi-touch got

00:04:48.640 --> 00:04:55.160
introduced at some point. So you can detect
at run time in the application if the device

00:04:55.160 --> 00:04:59.420
you're running on supports that, and if so,
enable a multi-touch kind of control or else

00:04:59.420 --> 00:05:07.150
you can pull back and perhaps offer buttons
or something to offer the same functionality.

00:05:07.150 --> 00:05:13.220
So writing your first app, so an Android application
is really kind of a series of components,

00:05:13.220 --> 00:05:17.710
it's all about kind of loosely coupled components
of an android and the thing which holds them

00:05:17.710 --> 00:05:21.870
all together and makes them into an application
is the AndroidManifest file. So I'm going

00:05:21.870 --> 00:05:26.420
to take through what are these components
that make it up so the four major ones being;

00:05:26.420 --> 00:05:30.820
the activity, service, content provider, and
broadcast receiver. And I'm going to take

00:05:30.820 --> 00:05:35.130
through what intents are and why that it's
so key to the Android system and then comeback

00:05:35.130 --> 00:05:42.440
around to the manifest and how you string
these things all together. So first up is

00:05:42.440 --> 00:05:48.170
the activity. This class is how you write
your user interface. So a single activity

00:05:48.170 --> 00:05:54.490
defines a single screen. Activities are kind
of independent and you string a series of

00:05:54.490 --> 00:06:00.820
these together to form a cohesive whole, for
a whole application. And it's possible to

00:06:00.820 --> 00:06:06.470
invoke these activities from within your application
but also from within other applications. So

00:06:06.470 --> 00:06:09.750
in that way, you could expose functionality
from your app to other applications and you

00:06:09.750 --> 00:06:13.120
can borrow functionality from other applications
of from the system within your app. Every

00:06:13.120 --> 00:06:18.590
class that you write for an activity should
extend the activity class and you get a bunch

00:06:18.590 --> 00:06:25.180
of methods there to help you do your UI. The
next major component I talk about is the service.

00:06:25.180 --> 00:06:29.540
So a service is the--what is the heavy lifting
or the major--the majority of your processing

00:06:29.540 --> 00:06:35.430
in your application so it's going to run all
your kind of long range tasks or so on. So

00:06:35.430 --> 00:06:38.820
a service doesn't offer any user interface
but it kind of--is the kind of logic behind

00:06:38.820 --> 00:06:44.960
that. And other components combined and interact
with your service. So a great example of this

00:06:44.960 --> 00:06:48.750
is if you're going to write a music player
application for example. You might write the

00:06:48.750 --> 00:06:52.280
user interface as--well, you will write the
user interface as an activity offering, you

00:06:52.280 --> 00:06:56.940
know, skip, play, pause controls for example.
But then you’d use a service to actually

00:06:56.940 --> 00:07:01.520
control the music playback itself. So if you
use the start playback in the activity and

00:07:01.520 --> 00:07:04.780
then leaves and goes and checks their email
or browses the web, the service carries on

00:07:04.780 --> 00:07:13.050
running the background and keeps on playing
the music. The next component is the content

00:07:13.050 --> 00:07:18.310
provider. So a content provider, it says here,
manages a shared set of application state.

00:07:18.310 --> 00:07:24.780
So it's really kind of a façade in all of
your persistence of any data. It provides

00:07:24.780 --> 00:07:29.050
a consistent interface to the Android system
and to the rest of the world on how to interact

00:07:29.050 --> 00:07:34.770
with your data so there'll be that querying,
storing, updating. So it eases, sorry, exposes

00:07:34.770 --> 00:07:41.800
CRUD type operations. It's also a restful
interface so every unique entity has a URI

00:07:41.800 --> 00:07:48.740
associated with it and then you can perform
operations upon those URIs. So underneath

00:07:48.740 --> 00:07:54.160
this façade you can back it with any kind
of store so commonly it'd be a SQLite database

00:07:54.160 --> 00:07:58.930
but equally, you could back your content on
the file system or on the web, it's up to

00:07:58.930 --> 00:08:03.580
you how you implement it. And you just expose
this consistent interface so the system knows

00:08:03.580 --> 00:08:07.970
how to talk to other apps and know how to
talk to it. Content providers allow you to

00:08:07.970 --> 00:08:15.400
expose data from within your application to
other applications into the system. So for

00:08:15.400 --> 00:08:20.810
example the system makes extensive use of
content providers in this search infrastructure.

00:08:20.810 --> 00:08:25.740
So when the Android finally hit search and
you can search for your data on the device,

00:08:25.740 --> 00:08:28.841
it's because of this consistent interface
that it knows how to search an application

00:08:28.841 --> 00:08:34.279
you've just installed for market and how to
query it. Equally the systems exposes its

00:08:34.279 --> 00:08:39.729
data to you as a content provider so in your
applications that you write, you can do things

00:08:39.729 --> 00:08:44.480
like query the contact system or the call
log or the music in the device, or the pictures

00:08:44.480 --> 00:08:50.819
on the device because of this consistent interface.
And the next major component is the broadcast

00:08:50.819 --> 00:08:56.540
receiver. So as I mentioned then, Android
applications are kind of loosely coupled components

00:08:56.540 --> 00:09:01.949
talking to each other. The way they listen
to things, to messages between each component

00:09:01.949 --> 00:09:08.370
is the broadcast receiver. So you can respond
to system-wide messages. So if a text message

00:09:08.370 --> 00:09:12.660
comes in or a phone call comes in, a message
will be broadcast to the system and apps can

00:09:12.660 --> 00:09:18.120
respond and offer functionality based on that.
There are two major types of message that

00:09:18.120 --> 00:09:22.890
can be broadcast; first one being the normal
broadcast which is delivered kind of asynchronously

00:09:22.890 --> 00:09:28.371
to all receivers in no guaranteed order or
there's an auto broadcast which you can say

00:09:28.371 --> 00:09:32.920
set a priority in which the messages will
be sent out. So an example of this is if you

00:09:32.920 --> 00:09:37.949
want to write your own message for handling
an SMS for example, URI application for handling

00:09:37.949 --> 00:09:42.610
an SMS. You might want your application to
handle it rather than the systems built in

00:09:42.610 --> 00:09:48.100
one so you can register with a higher priority,
catch the message that a new SMS has come

00:09:48.100 --> 00:09:55.319
in and say it's handled so it doesn't carry
on propagating. Broadcast receivers can be

00:09:55.319 --> 00:09:59.690
registered to listen for certain messages
either statically, so you define it in the

00:09:59.690 --> 00:10:03.379
Android manifest or at runtime so you can
dynamically start and stop listening if you

00:10:03.379 --> 00:10:08.040
wish. BroadcastReceivers are just that, they're
just listening in for messages. They shouldn't

00:10:08.040 --> 00:10:12.449
really be doing lots of heavy lifting and
processing. So once you've kind of listened--listened

00:10:12.449 --> 00:10:18.939
out for message, you want to hand off any
long running tasks to a service to process.

00:10:18.939 --> 00:10:25.829
So there's four major--the four major components.
Now, intents are the magic that kind of glues

00:10:25.829 --> 00:10:31.690
this all together really, if you will. There's
always an intent for--for launching and talking

00:10:31.690 --> 00:10:36.600
to different components in your application.
So when we say BroadcastReceiver listens for

00:10:36.600 --> 00:10:43.339
a message, that message itself is an intent.
Now these intents can be explicit or implicit.

00:10:43.339 --> 00:10:48.209
So an explicit intent is like an explicit
message. You just kind of--it says exactly

00:10:48.209 --> 00:10:52.170
who I want to deliver something to. So if
I have an application made up of two screens,

00:10:52.170 --> 00:10:56.950
screen A and screen B, and in screen A, I
click a button which should take me to the

00:10:56.950 --> 00:11:02.220
second one. I can explicitly address it to
launch screen B. So clicking that invokes

00:11:02.220 --> 00:11:08.399
screen B and it launches. More interestingly
is the--interesting is the implicit intent

00:11:08.399 --> 00:11:16.370
system. So just by describing something you
would like to achieve, so an action you'd

00:11:16.370 --> 00:11:22.470
like to perform upon some data with some extra
Metadata, and then handing out to the system

00:11:22.470 --> 00:11:26.180
and asking is there anything installed on
this device which can handle this action on

00:11:26.180 --> 00:11:32.120
this type of data. So by standardizing on
a set of common actions, so you know, I want

00:11:32.120 --> 00:11:38.339
to view this data. I want to send this data.
I want to edit this data; you can have lots

00:11:38.339 --> 00:11:44.519
of different and unforeseen applications handling
a standard message. So a great example of

00:11:44.519 --> 00:11:50.319
this is photo sharing. If I had it write an
application and which kind of, can take photos

00:11:50.319 --> 00:11:55.449
and then share them, you know, I could think
about all the possible ways, you know, places

00:11:55.449 --> 00:11:59.420
I want to share that photo to. You know, I
could write in Facebook sharing, Twitter sharing,

00:11:59.420 --> 00:12:04.769
Buzz sharing, but more interestingly I could
just say I have this data or type and photo

00:12:04.769 --> 00:12:08.021
and the action I want to perform on it is
share, and hand it over to the system and

00:12:08.021 --> 00:12:14.519
say, "Hey, what's in store that can handle
this intent?" And then, you know, the user

00:12:14.519 --> 00:12:19.370
could install you know, obscure or kind of
different social network or whatever the site

00:12:19.370 --> 00:12:24.860
that they want to share it to, and that application
can then say, "Hey, I know how to handle a

00:12:24.860 --> 00:12:31.100
share action on that picture. Let me do it."
So by doing this and kind of standardization

00:12:31.100 --> 00:12:39.510
on actions, you kind of can have this unintended
and the uses of your data is great. One of

00:12:39.510 --> 00:12:47.380
my favorite examples of this is an out patient
called barcode scanner, so barcode scanner

00:12:47.380 --> 00:12:50.449
had said, "Hey, I got this kind of great use
case of scanning barcodes and it's really

00:12:50.449 --> 00:12:54.699
helpful," but what--wouldn't it be even greater
if I can offer up this functionality to other

00:12:54.699 --> 00:12:59.660
applications? So what they did is they standardized
on an action and published this action out

00:12:59.660 --> 00:13:06.290
on their website. And now, other applications
are free to invoke this application. So the

00:13:06.290 --> 00:13:09.920
way they do that, and so for example, this
is one of my favorite greater apps in the

00:13:09.920 --> 00:13:15.550
U.K. called [INDISTINCT]. So [INDISTINCT]
wanted to offer the ability to add groceries

00:13:15.550 --> 00:13:19.990
to your basket by scanning a barcode, but
they didn't have to write their own barcode

00:13:19.990 --> 00:13:24.029
scanning software, which is quite complex.
They simply click on the barcode button and

00:13:24.029 --> 00:13:28.649
this will invoke the barcode scanning application
which will do the work of scanning the barcode,

00:13:28.649 --> 00:13:34.410
and then hand back to the grocery app to add
it to your basket. So it is a pretty complex

00:13:34.410 --> 00:13:39.350
task, I guess, scanning a barcode. But it
can be achieved very simply through the coding

00:13:39.350 --> 00:13:43.079
application. So the grocery apps, this has
to include some very simple, you know, not

00:13:43.079 --> 00:13:49.529
huge amount of code for quite a complex interaction
in order to accomplish it. So going through

00:13:49.529 --> 00:13:54.240
this, this is one of these explicit intents
I mentioned earlier. So when we create the

00:13:54.240 --> 00:13:59.129
intent, we know exactly the action we're trying
perform to this Android.scan action. And we

00:13:59.129 --> 00:14:04.499
set the package which we know we will perform
it. We can then send some extra Metadata,

00:14:04.499 --> 00:14:09.949
so we're saying here that we want to do a
QR code type scan. We then do a code to start

00:14:09.949 --> 00:14:15.390
activity for result passing in that information
we just set up. So what this does is it's

00:14:15.390 --> 00:14:21.850
going to start a component written in an entirely
separate application and run it. Now to the

00:14:21.850 --> 00:14:25.170
user, this is completely transparent. So I
just think I'm in my grocery app. I just hit

00:14:25.170 --> 00:14:29.480
a button and the barcode scanner comes up.
I've got no idea that the developer or the

00:14:29.480 --> 00:14:35.629
grocery app didn't have to write this barcode
app. It's kind of seamlessly integrated. So

00:14:35.629 --> 00:14:41.310
the user just to work, it takes a photo of
the barcode and--and finishes scanning, and

00:14:41.310 --> 00:14:44.999
the result gets returned back to the coding
application. So here we can check some things

00:14:44.999 --> 00:14:50.779
like make sure that it completes successfully
by checking for the result, okay. And then,

00:14:50.779 --> 00:14:55.600
grab back from the intent, the results this
is the actual code that they scan. So in very

00:14:55.600 --> 00:15:04.249
few lines of code, you've got this quite complex
interaction all powered by intents. So, wrapping

00:15:04.249 --> 00:15:08.699
this back up together and coming back to the
Android Manifest, so, the Manifest declares

00:15:08.699 --> 00:15:12.660
all of the components within your app. This
is where you're talking to the systems. When

00:15:12.660 --> 00:15:15.860
the user installs your apps, you're saying,
"Hey," this is what my application is actually

00:15:15.860 --> 00:15:21.410
made up of. I have this many activities, this
many services, this many [INDISTINCT] for

00:15:21.410 --> 00:15:28.480
example. It's also an opportunity to declare
the features that your application requires.

00:15:28.480 --> 00:15:37.110
So, if you need Internet, for example, or
if you require GPS hardware, then you can

00:15:37.110 --> 00:15:40.829
use the Android Manifest to declare there
and then what your application requires to

00:15:40.829 --> 00:15:46.380
run. So, the system knows how to run you as
well. You can also state what versions of

00:15:46.380 --> 00:15:51.579
the Android System you require for your application
to run. More interestingly, you can actually

00:15:51.579 --> 00:15:58.160
say the lowest version you require to run
but you are also aware of a high version.

00:15:58.160 --> 00:16:04.029
So, you can say a target SDK or say the latest
and greatest, say, Gingerbread. But I also

00:16:04.029 --> 00:16:09.420
run incompatible all the way back to say,
cupcake. So, by doing this, you're essentially

00:16:09.420 --> 00:16:16.670
completing a contract saying I won't use any
of the newer APIs when I'm running on an older

00:16:16.670 --> 00:16:22.569
version. So, when you're writing an app, it's
really important to remember that you're running

00:16:22.569 --> 00:16:27.819
on a multitasking environment. Mobile phones
and tablets are kind of multitasking devices

00:16:27.819 --> 00:16:32.639
with lots of things going on at once and often
quite memory constrained. So, users will switch

00:16:32.639 --> 00:16:36.540
between new applications all the time. The
system is going run low of memory; calls are

00:16:36.540 --> 00:16:40.399
going to come in. So, your application, when
you're writing it, you need to be aware that

00:16:40.399 --> 00:16:45.660
you're in this kind of busy environment and
be able to handle it properly. The system

00:16:45.660 --> 00:16:50.509
will call into your application at a series
of kind of callback events to let you know

00:16:50.509 --> 00:16:55.630
when these events happen. So, it's really
key to remember that at some point, the system

00:16:55.630 --> 00:17:00.679
will kill your application. When we were writing
our amazing apps, it's kind of really kind

00:17:00.679 --> 00:17:03.170
of nice to think that the user is going to
sit there in full concentration just use the

00:17:03.170 --> 00:17:07.970
app as you kind of intended, and then happy
days, finish, and they're done. But in reality,

00:17:07.970 --> 00:17:12.910
there's going to be 101 things going on at
the same time. So, the key thing, I'm going

00:17:12.910 --> 00:17:17.310
to walk through this activity lifecycle in
a bit more detail. But the key message is

00:17:17.310 --> 00:17:22.580
to respond and work with the system activity,
the system lifecycle. And make sure you save

00:17:22.580 --> 00:17:25.970
your state, for example, so that if the user
comes back your application that has been

00:17:25.970 --> 00:17:29.650
killed by a system, they don't get surprised
and say, "Hey, where's my data? I was in the

00:17:29.650 --> 00:17:35.590
middle of something“ So, when you launch
your--an activity for the first time, and

00:17:35.590 --> 00:17:42.120
the activity is created, you'll get a callback
into your applications onCreate. This is kind

00:17:42.120 --> 00:17:45.620
of similar if you've done some Java programming
to kind of your main method. It's the first

00:17:45.620 --> 00:17:48.880
entry point and it's your first chance to
do any kind of set up and initialization logic.

00:17:48.880 --> 00:17:53.130
You then get a callback into the onResume
method, which is just before you're about

00:17:53.130 --> 00:18:00.920
to become foreground and then you’re activity
to be running. So, if while your activity

00:18:00.920 --> 00:18:05.000
is running, say, a call comes in or they switched
to another application, the system will them

00:18:05.000 --> 00:18:08.700
let you know that that's happening to your
application. It's no longer going to become

00:18:08.700 --> 00:18:13.050
foreground. So, we get a call back to--your
application's onPause. This is key like in

00:18:13.050 --> 00:18:18.430
onPause, you definitely want to be saving
all your state so if a user comes back to

00:18:18.430 --> 00:18:23.900
your application at some point, it's still
in the state that they thought it was in.

00:18:23.900 --> 00:18:27.640
There's nothing worse than kind of, you know,
I was playing a game or something like and

00:18:27.640 --> 00:18:31.500
then the call comes in and then I forget I
was playing the game and I surf the web. And

00:18:31.500 --> 00:18:34.720
I come back to the game, and it's kind of
I've lost all my progressing, I have to start

00:18:34.720 --> 00:18:39.020
again. I mean, that's an example of someone
not using onPause properly to save the state.

00:18:39.020 --> 00:18:45.260
So, if after the calls come in and user just
comes back to your app straight away, you

00:18:45.260 --> 00:18:48.330
going to get a callback to the onResume so
then you can just make sure that the application's

00:18:48.330 --> 00:18:52.510
in the right place. But if they don't come
back to it, so they go off and stuff [INDISTINCT]

00:18:52.510 --> 00:18:58.510
whatever and the system and--starts running
low on memory; t's going to kind of kill your

00:18:58.510 --> 00:19:02.090
application, it's going to reclaim some of
that memory, it's going to stop you. So, the

00:19:02.090 --> 00:19:08.040
user should be completely unaware that this
happening. So, if your activity gets destroyed

00:19:08.040 --> 00:19:11.281
and then the user later comes back to launch
your application, it should be like it was

00:19:11.281 --> 00:19:16.440
just sitting in the wings waiting. So, when
they go through the onCreate again and onResume,

00:19:16.440 --> 00:19:21.090
you need to be grabbing the state that you
saved in onPause and just set it up like it

00:19:21.090 --> 00:19:26.770
was just waiting for them. So, the next step,
I want to talk about something unique ways

00:19:26.770 --> 00:19:34.260
that Android lets you surface your content
to the user. Android’s got a really great

00:19:34.260 --> 00:19:39.550
notification system. So, you can throw up
notifications up into the top bar as I've

00:19:39.550 --> 00:19:45.040
highlighted here. And if you show like an
icon, you can buzz the device or flash a light

00:19:45.040 --> 00:19:49.320
if it has one and you can also have some scrolling
text going across, or if you pull the tray

00:19:49.320 --> 00:19:55.920
down, you can get some expanded information.
So, these unobtrusive notifications are a

00:19:55.920 --> 00:20:00.530
fantastic lifeline for kind of these busy
lives that we lead with 500 apps installed

00:20:00.530 --> 00:20:03.840
and things. I don't want to be going into
my apps and to check it, I want the app to

00:20:03.840 --> 00:20:08.230
let me know whenever that happens. So it lets
you kind of create invent-driven and kind

00:20:08.230 --> 00:20:12.670
of models so that the user can come back whenever
something interesting has happened. You can

00:20:12.670 --> 00:20:16.480
also provide quite a lot of information for
them. You can provide custom views in this

00:20:16.480 --> 00:20:20.810
expanded tray so if you want your happy application
show up progress bar or something to let these

00:20:20.810 --> 00:20:26.940
and know that something is going on. You can
also deep link to a place within your application

00:20:26.940 --> 00:20:31.130
with setting one of these in 10 objects--a
pending intent onto the notification. So it

00:20:31.130 --> 00:20:35.300
doesn't have to take them just to the front
screen of your application. It can take you

00:20:35.300 --> 00:20:44.650
right in there. Widget. It's another strong
feature of Android. So many times, I'm using

00:20:44.650 --> 00:20:48.310
my phone and kind of, you know, you're bored
on the bus and you just kind of playing around

00:20:48.310 --> 00:20:52.850
on the homescreen. And by letting you put
your applications data right there on the

00:20:52.850 --> 00:20:58.110
user's homescreen, it stays kind of forefront
in their minds. You can have the data on there

00:20:58.110 --> 00:21:01.750
widget updates regularly so it doesn't have
to be just static information, you can update

00:21:01.750 --> 00:21:07.060
it when events happen and--or just on time
basis. You can also offer multiple widgets

00:21:07.060 --> 00:21:11.330
for your applications. So one application
can have, you know, a large widget, a small

00:21:11.330 --> 00:21:16.510
widget, a widget to show this type of information--this
type of information and have interactivity.

00:21:16.510 --> 00:21:21.260
So this music play widget example lets the
user can of kind of play the music or just

00:21:21.260 --> 00:21:25.250
skip the track, go right from the homescreen.
So it's a great way to drive user engagement.

00:21:25.250 --> 00:21:30.740
We find applications which have--widgets included
in them have high use rate, people kind of

00:21:30.740 --> 00:21:38.430
keep on coming back to them and then [INDISTINCT].
And people love them, they're fun. And next

00:21:38.430 --> 00:21:43.560
I’m going to talk about cloud to device
messaging. So this lets you reach in from

00:21:43.560 --> 00:21:48.360
your service, kind of--right down to the Android
application and kind of send it timely messages.

00:21:48.360 --> 00:21:51.870
You can send, like, tickles. It's got a very
small payload but it's very timely and a very

00:21:51.870 --> 00:21:57.430
fast [INDISTINCT]. So you can use this to
kind of push messages down to the device.

00:21:57.430 --> 00:22:01.290
So your application doesn't even have to be
running when you want to send a message to

00:22:01.290 --> 00:22:06.110
it. If it's not running the system, it will
wake up your app and deliver the push message

00:22:06.110 --> 00:22:09.450
straight to your application. And then it's
up to you how you respond. There's no, you

00:22:09.450 --> 00:22:13.460
know, pre-defined UI. You don't just get a
model dialogue popping up or whatever saying

00:22:13.460 --> 00:22:19.230
something is updating. It's up to you. So
if, for example, you're writing a messaging

00:22:19.230 --> 00:22:26.850
app or, say, a news app, you can have your
service, ping the Google cloud to device messaging

00:22:26.850 --> 00:22:30.050
services which will reach on to the device
and wake up your app and let it know there’s

00:22:30.050 --> 00:22:34.720
some new content. Your application then wakes
up and it can then retrieve that content straight

00:22:34.720 --> 00:22:40.081
down from the Web server and let the user
know, perhaps using notifications. Because

00:22:40.081 --> 00:22:45.360
it's built on top of the existing Google messaging
services, so the same thing that Gmail and

00:22:45.360 --> 00:22:50.330
Google Talk uses, there's minimal effect on
the battery. You're not keeping other kind

00:22:50.330 --> 00:22:53.940
of persistent channels of communication open
between the device and the cloud so you're

00:22:53.940 --> 00:22:59.740
not going to be hammering the user battery.
Okay. So we've talked about some of the cool

00:22:59.740 --> 00:23:03.930
features in Android. I'm going to talk about
how you can go about building them to create

00:23:03.930 --> 00:23:11.040
your app. So building your apps UI is kind
of very important so the user interface is

00:23:11.040 --> 00:23:16.620
a hierarchy of widgets which extend the view
and view group classes. So you can define

00:23:16.620 --> 00:23:21.920
this in code, and create them all in code
but it's much cleaner to define your layouts

00:23:21.920 --> 00:23:27.910
by XML. So on the left here; we have an example
of a layout. So this has got linear layout

00:23:27.910 --> 00:23:34.110
which includes a label and a button. So a
very simple, very clean to define your layout

00:23:34.110 --> 00:23:38.140
and then the system will kind of inflate that
layout into a series of these hierarchy of

00:23:38.140 --> 00:23:44.111
these objects. So Android, by default, comes
with a pallet of widgets which you can use

00:23:44.111 --> 00:23:49.130
to like delineate out the text in the button.
You can also create your own components to--if

00:23:49.130 --> 00:23:54.690
you need some richer controls or combine existing
ones into kind of custom component. So once

00:23:54.690 --> 00:24:00.620
you defined your layout, you can then tell
your application how to use it. So in an activity

00:24:00.620 --> 00:24:06.100
below, we're calling the method set content
view and pausing it, identify it, so it says

00:24:06.100 --> 00:24:12.720
here [INDISTINCT] main. So imagine the XML
file above was called main.XML. Then the code

00:24:12.720 --> 00:24:19.090
below is telling the application, this is
the layout that I want to use for my display.

00:24:19.090 --> 00:24:24.260
So we're without [INDISTINCT] so anything
that's not codeless in a res folder in your

00:24:24.260 --> 00:24:29.650
Android project. So in here, we have a folder
for layout and there's a main.XML. So, right

00:24:29.650 --> 00:24:35.960
there, you can define your applications layout.
More interestingly, the resource's folder

00:24:35.960 --> 00:24:41.220
lets you provide qualifiers to provide different
versions of resources for different configurations

00:24:41.220 --> 00:24:47.501
or device. So just beneath that layout photo
here you see there's a layout-dash-port. What

00:24:47.501 --> 00:24:52.080
this means is allowing—we’re specifying
a completely--a different layout for a device

00:24:52.080 --> 00:24:56.780
when it's running it in portrait mode. That
means rather than the default one in layout

00:24:56.780 --> 00:25:03.250
mode. So at runtime, the device will know
that--what configuration it’s running in

00:25:03.250 --> 00:25:08.110
and grab the right resource appropriately.
This is really powerful when you think about

00:25:08.110 --> 00:25:10.980
all the different--and so when you look at
the different qualifiers that you can use

00:25:10.980 --> 00:25:15.600
so as well as orientation, you can use the
density of the screen that you're running

00:25:15.600 --> 00:25:20.510
on. The size of the screen so if you're running
on, say, a small device or an extra large

00:25:20.510 --> 00:25:26.390
device, you can have different lay-outs or
different image assets or even if you have

00:25:26.390 --> 00:25:30.250
a--you're running on a different language
of device then you can provide different strings

00:25:30.250 --> 00:25:39.830
for example. So looking how--out there what
devices on the market, there's a huge variety

00:25:39.830 --> 00:25:43.400
and kind of sizes and shapes and capabilities.
So you've got, you know, your tiny little

00:25:43.400 --> 00:25:49.560
phones to regular phones to tablets. Even
to apps who kind of Google TV. So you have

00:25:49.560 --> 00:25:55.480
to think about these devices and how your
applications will run on them. So supporting

00:25:55.480 --> 00:25:59.990
multiple different screen sizes, there's lot
of techniques built into the Android platform

00:25:59.990 --> 00:26:05.170
that will help you out with that. So one technique
I definitely advocate using is the relative

00:26:05.170 --> 00:26:09.560
layout, so doing kind of a slice things in
exact, like, pixel dimensions. Using relative

00:26:09.560 --> 00:26:14.120
layouts you can say, "I want this kind of
to the left of this component, on this right

00:26:14.120 --> 00:26:18.821
of the component and this taking out the rest
of the room." So you're not going to constrained

00:26:18.821 --> 00:26:24.470
by fixed dimensions. You can use attributes
such as wrapping content and matching the

00:26:24.470 --> 00:26:28.960
parent and weights. Say, this one is take
up a third of the screen and this is to take

00:26:28.960 --> 00:26:32.990
up two-thirds of the screen and this will
help to keep your layouts to scale appropriately

00:26:32.990 --> 00:26:39.350
and no matter what the device. Another great
platform feature is the DP or the density

00:26:39.350 --> 00:26:45.000
independent pixel. This lets you say, "I want
this to be a hundred pixels when it's running

00:26:45.000 --> 00:26:48.951
on a medium density screen for example." If
I'm running on a super-high density screen,

00:26:48.951 --> 00:26:53.330
I want it to be sized slightly larger. So
the physical size of it will be the same even

00:26:53.330 --> 00:26:59.140
though the pixel size is larger. So techniques
like this kind of think web style development,

00:26:59.140 --> 00:27:03.720
so you have kind of fluid layouts that will
scale no matter what the size Window it's

00:27:03.720 --> 00:27:08.370
running in. You can provide--using the resource
framework that I talked about in the last

00:27:08.370 --> 00:27:13.970
slide, you can provide specific density assets.
And so, on a high density screen like, say

00:27:13.970 --> 00:27:20.590
the Nexus S, you can provide a higher resolution
image, so it looks great on that screen whereas

00:27:20.590 --> 00:27:26.080
on an older G1, you might want to provide
a lower res image, so it's not taking as much

00:27:26.080 --> 00:27:31.240
size. You can use then the resource qualifiers
provide specific layouts for different devices.

00:27:31.240 --> 00:27:37.660
So, if I--if your application is running on
a Motorola Xoom for example, you can use a

00:27:37.660 --> 00:27:43.790
layout-xlarge to provide an optimized layout
for that larger device. Another great technique

00:27:43.790 --> 00:27:49.410
is a 9-patch drawable which is a system of
specifying which parts of your image assets

00:27:49.410 --> 00:27:54.120
can be stretched and which should be rendered
as is. So this lets you say, you know, create

00:27:54.120 --> 00:27:58.670
a [INDISTINCT] by saying the corner should
be rendered exactly as they are but the middle

00:27:58.670 --> 00:28:05.020
bit can be stretched out. And what I'm here
I’d say if you're interested in learning

00:28:05.020 --> 00:28:09.450
some great techniques about this, you should
go along to the best practices, Android best

00:28:09.450 --> 00:28:12.940
practices code lab later on today that--which
you're going to look much in more detail about

00:28:12.940 --> 00:28:18.200
how to use these techniques. So, one of the
most interesting things about writing Android

00:28:18.200 --> 00:28:22.730
applications at the moment is the devices
that run on have these fantastic hardware

00:28:22.730 --> 00:28:30.250
sensors. So, you know you have access to cameras,
to accelerometers, G meters and light meters.

00:28:30.250 --> 00:28:34.590
So all this kind of like really fancy kind
of sensors that haven’t been available to

00:28:34.590 --> 00:28:40.620
us in software development on desktop devices,
enable all kinds of interesting applications

00:28:40.620 --> 00:28:46.390
to be written. So, using the Android system
you can use the sensor manager to find out

00:28:46.390 --> 00:28:51.190
what sensors are available to you to your
application at runtime. You can then register

00:28:51.190 --> 00:28:56.350
listeners to listen up for updates so you
can get hold of a G meter and listen for changes

00:28:56.350 --> 00:29:01.760
in orientation for example. So, yeah, and
really think about what sensors are available

00:29:01.760 --> 00:29:05.570
in devices now and what's coming and how you
can really use that to make a really kind

00:29:05.570 --> 00:29:11.630
of compelling application. Another Android
strength is its ability to do background tasks.

00:29:11.630 --> 00:29:15.052
And when I talk about background tasks, I
don't just mean kind of multitasking. I'm

00:29:15.052 --> 00:29:19.410
not talking about listening to music and reading
your email. I more mean then system's ability

00:29:19.410 --> 00:29:26.730
to accomplish a task without any interaction
from you. So you can use the alarm manager

00:29:26.730 --> 00:29:31.090
to schedule your application to wake up and
perform an update without the user having

00:29:31.090 --> 00:29:37.940
to interact with it. So think about if you
write a news application or something which

00:29:37.940 --> 00:29:41.410
grabs content from the web. There's nothing
worse than like putting out your phone, opening

00:29:41.410 --> 00:29:45.690
in application and seeing, you know, a model
loading dialogue or nothing's happening. Or

00:29:45.690 --> 00:29:50.660
if I pull up my phone and I have no an out
coverage, you know, and it doesn't let me

00:29:50.660 --> 00:29:54.840
even get access to any items, it's so frustrating.
There's no--especially because there's no

00:29:54.840 --> 00:30:01.530
reason for it. Using kind of background tasks
and periodic updates, your application can

00:30:01.530 --> 00:30:06.060
wake up in the back--in the background, grab
content so it's right there ready to go fresh

00:30:06.060 --> 00:30:11.360
for the user to use when they want to. So
this is great. So it's available offline and

00:30:11.360 --> 00:30:17.130
it's always kind of up to date. There's another
point, it’s one of my favorite features

00:30:17.130 --> 00:30:22.991
of the system that you also use; inexact alarms.
What this means is you can, you know, you

00:30:22.991 --> 00:30:26.630
might be worried if you have 50 Apps installed
in your device all doing this kind of waking

00:30:26.630 --> 00:30:30.710
up in the background and checking content
that your device is going to be awake most

00:30:30.710 --> 00:30:34.320
of the time, it's going to have harm your
battery. But the system gives a system called

00:30:34.320 --> 00:30:38.480
inexact repeating alarms which will actually
phase shift your alarms to all coincide and

00:30:38.480 --> 00:30:47.590
go off at once so that it has minimum--it
minimizes the effect on your device so be

00:30:47.590 --> 00:30:50.740
kind of friendly to the user. Next step, Android
makes it really easy to make an accessible

00:30:50.740 --> 00:30:56.161
app. So using things like setting the content
restriction--description on your content and

00:30:56.161 --> 00:31:01.200
works well with the kind of screen reader
technologies, it also--Android also fully

00:31:01.200 --> 00:31:07.890
supports and navigation by dbol and trackpad,
so as a developer, you have to be aware of

00:31:07.890 --> 00:31:13.690
how to implement this. So setting appropriate
drawables that respond to the states when

00:31:13.690 --> 00:31:18.690
a control is selected by the D pad to kind
of indicate that selection. I definitely recommend

00:31:18.690 --> 00:31:25.000
you go to the new best practices on accessibility
section and read up on how to make your app

00:31:25.000 --> 00:31:30.990
accessible or better yet, try it. If you install
the talk back application, you can try to

00:31:30.990 --> 00:31:41.590
navigating the application in kind of accessible
mode and see how it is for a kind of vision-impaired

00:31:41.590 --> 00:31:46.170
user. Next, I will say that there is over
150,000 applications in the Android market,

00:31:46.170 --> 00:31:53.250
150,000. And so how do you stand out, I mean,
the way to do that is to single quality. And--so

00:31:53.250 --> 00:31:58.140
using the techniques we talked about before,
this is how you kind of like get users to

00:31:58.140 --> 00:32:03.080
realize your App is well made. So work with
the activity life cycle. Make sure your App

00:32:03.080 --> 00:32:08.590
isn't kind of dumping the user state when
it kind of gets killed off by a system. Offload

00:32:08.590 --> 00:32:14.450
any long running tasks into the background
so that using the service, so that they--the

00:32:14.450 --> 00:32:21.150
user interface stays buttery smooth. Users
have very low kind of tolerance for any latency

00:32:21.150 --> 00:32:25.160
in the user interface so make sure that any
kind of long running task or processing isn't

00:32:25.160 --> 00:32:30.900
happening on the UI thread that you handoff
to the background. What's more, listen to

00:32:30.900 --> 00:32:35.981
your users, have a conversation with them.
The Android market offers them feedback on

00:32:35.981 --> 00:32:39.590
your application so you can leave comments
on your application to they let you know what

00:32:39.590 --> 00:32:45.150
they think of them, sometimes they're quite
colorful. And better the yet, you can offer

00:32:45.150 --> 00:32:48.470
your own feedback mechanisms so if you set
up your own kind of forums or kind of stock

00:32:48.470 --> 00:32:52.481
exchange or some kind of technique for having
a feedback mechanism so your users can say

00:32:52.481 --> 00:32:56.640
what's working for you. You know, as the writer
of the App, you know exactly where functionality

00:32:56.640 --> 00:33:03.350
is and how to use it, but you might not realize
that it's not obvious to some of your users.

00:33:03.350 --> 00:33:07.840
And to that end, work with the design otherwise
advocate. As developers, sometimes we're very

00:33:07.840 --> 00:33:13.260
keen to run 100 miles an hour and get as much
cool functionality into an application, but

00:33:13.260 --> 00:33:18.390
if your application isn't usable or aesthetically
pleasing, your users might not find it or

00:33:18.390 --> 00:33:26.930
keep coming back to it so it might be wasted.
Also to put skin to wonderful applications,

00:33:26.930 --> 00:33:31.880
here's the tools you can use. First up, you
want to go and grab the Android SDK. So this

00:33:31.880 --> 00:33:36.810
SDK will have all the kind of tools you need
for building your applications as well as

00:33:36.810 --> 00:33:42.230
things like the emulator which will let you
run the application without the device and

00:33:42.230 --> 00:33:45.060
tools for your signing your application when
you come to apply them. There's a very polished

00:33:45.060 --> 00:33:49.440
tool changers built around Eclipse which is
going to make your development life really

00:33:49.440 --> 00:33:54.680
easy. So if you install Eclipse and then grab
the Android Development Tools plug-in, this

00:33:54.680 --> 00:34:00.670
is an Eclipse plug-in which will make it really
easy to build your code against the SDK to

00:34:00.670 --> 00:34:05.850
deploy it onto a device or onto the emulator
and interactively debug it. With these four

00:34:05.850 --> 00:34:11.889
other tool changers as well, so IntelliJ or
just using an [INDISTINCT] for example to

00:34:11.889 --> 00:34:17.109
build these completely fine and lots of people
like that. But for new people who are getting

00:34:17.109 --> 00:34:21.070
up and running, Eclipse is definitely going
to be kind of at least--path of least resistance

00:34:21.070 --> 00:34:27.309
to getting going. Once you have the ADT installed,
you can use the SDK and AVD Manager to kind

00:34:27.309 --> 00:34:30.759
of grab all the latest versions of the platform.
So when we're releasing a new version of the

00:34:30.759 --> 00:34:34.139
platform, so when Gingerbread came out for
example. Or we're releasing an update to the

00:34:34.139 --> 00:34:38.819
SDK so you can build against these new APIs
that's just been released. And--again if you're

00:34:38.819 --> 00:34:42.999
getting started, these slides will be online,
I'd advocate you go to--towards the full guide

00:34:42.999 --> 00:34:47.690
to getting going, I'll walk you through the
process of getting up and running. Cool, so

00:34:47.690 --> 00:34:52.679
you’ve built your amazing application, implemented
your idea, and you now want to share it with

00:34:52.679 --> 00:34:57.030
the world so here's how you publish your app
on an Android market. It couldn’t be simpler,

00:34:57.030 --> 00:35:03.640
you just develop your application, register,
and then hit publish. So you go to market.Android.com/publish.

00:35:03.640 --> 00:35:08.730
You can create a developer profile and sign
in with a Gmail account. And then there's

00:35:08.730 --> 00:35:19.849
a one time $25 fee to gain access to the market.
This is just to kind of prevent spam applications.

00:35:19.849 --> 00:35:23.839
So when you sign up, you agree to the Developer
Distribution Agreement, which kind of sets

00:35:23.839 --> 00:35:28.190
out the agreement between you just--yourself
as a seller and Google. And then if you want

00:35:28.190 --> 00:35:31.499
to sell your applications, you can also create
a Checkout Market Account, which will enable

00:35:31.499 --> 00:35:37.009
you to sell the apps and get the--get the
revenue for it. So once you've signed up,

00:35:37.009 --> 00:35:42.020
you just log in and it's a self-service process
to upload your application. There's no review

00:35:42.020 --> 00:35:45.790
process at all. You're going to hit upload
and your application is live to the world.

00:35:45.790 --> 00:35:51.180
Google just performed a, kind of, retrospective
take- down on some applications. So if you're,

00:35:51.180 --> 00:35:56.040
for example--or if someone infringes on a
copyright and that gets reported back to us,

00:35:56.040 --> 00:36:02.430
we will take down the app. But there's no
review process. So, you know, as soon as you

00:36:02.430 --> 00:36:06.230
decide to listen to the user's feedback and
like, kind of fix a bug they experience, you

00:36:06.230 --> 00:36:14.170
hit publish and within minutes it's live and
updating for all your users. So the maximum

00:36:14.170 --> 00:36:19.759
application size you can set is 50 megabyte
and that's entirely hosted by us. And then

00:36:19.759 --> 00:36:22.999
the downloader will be accessible both on
the device and on the recently launched Android

00:36:22.999 --> 00:36:28.910
Web Market. So the web market, if you've not
used it, is a fantastic tool. Not only does

00:36:28.910 --> 00:36:33.319
it, kind of expose all the--all the great
application you can see on your device, but

00:36:33.319 --> 00:36:37.799
it's also good for using traditional advertising
techniques. So you can drive any existing

00:36:37.799 --> 00:36:42.990
web traffic you might have to this place on
the web, so they can then, kind of, discover

00:36:42.990 --> 00:36:48.090
your app and install it straight from the
website. To this end, we'd like you to provide

00:36:48.090 --> 00:36:52.990
like, kind of, high-res promotional images
and videos onto your listing so that users

00:36:52.990 --> 00:36:56.609
can see immediately how high-quality your
application is and get an idea of what using

00:36:56.609 --> 00:37:03.960
it will be like. In addition as a publisher,
you can log into your publisher account and

00:37:03.960 --> 00:37:10.329
see any application crash supports. So if
your application encounters a bug on a certain

00:37:10.329 --> 00:37:15.160
device and the user hits report, you can see
their complete stat trace right in the web

00:37:15.160 --> 00:37:19.940
browser. So you can immediately keep on top
of any, kind of crashes or stability issues

00:37:19.940 --> 00:37:24.190
you might have. We also launched lots of application
statistics for your applications so you can

00:37:24.190 --> 00:37:30.740
see what platforms your users are running
their application on and also what languages

00:37:30.740 --> 00:37:34.829
they're in. So, you can use this information
to improve your app. Let's say if you've find

00:37:34.829 --> 00:37:41.250
out that you have lots of users in a certain
country, you might want to localize into that

00:37:41.250 --> 00:37:47.300
language. When uploading your app, you can
also target quite specifically your audience.

00:37:47.300 --> 00:37:53.299
So in the publisher site, you can set countries
or languages you want to target. So say, my

00:37:53.299 --> 00:37:58.950
UK grocery app is only available to UK users,
so they can restrict it to only be available

00:37:58.950 --> 00:38:04.109
to people using Android Market in the UK.
Similarly, you can target based on hardware

00:38:04.109 --> 00:38:09.950
availability on the device. So if you write
a application which requires GPS or Telephony

00:38:09.950 --> 00:38:16.180
or a level of OpenGL, in your Android Manifest,
you specify for the users feature tag that

00:38:16.180 --> 00:38:21.771
you require this attribute. And then Android
Market will know not to offer your application

00:38:21.771 --> 00:38:30.569
to devices which don't have that functionality.
So that was a crash course in what an Android

00:38:30.569 --> 00:38:35.640
Application is, how you go about writing it,
some of the unique features that you have

00:38:35.640 --> 00:38:40.731
available to you on Android, and how to make
an awesome app. And I hope that was useful

00:38:40.731 --> 00:38:45.710
to you and I do advocate you to kind of go
along to some of the code labs today where

00:38:45.710 --> 00:38:48.490
you'll get a chance to actually get your hands
dirty and try out writing applications for

00:38:48.490 --> 00:38:56.269
the first time. Do please fill out the speakermeter
and let us know what you think of the sessions.

00:38:56.269 --> 00:39:01.690
All right. So, we have a bit of time at the
end, if anybody has any questions about writing

00:39:01.690 --> 00:39:04.150
an Android app? Okay, [INDISTINCT].
&gt;&gt; [INDISTINCT]

00:39:04.150 --> 00:39:13.340
&gt;&gt; BUTCHER: Yes. We're going to be on the
IOB campsite after the event. Anyone else?

00:39:13.340 --> 00:39:18.579
Cool. Well, thank you very much.

