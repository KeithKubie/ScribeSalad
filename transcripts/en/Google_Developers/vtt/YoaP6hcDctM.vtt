WEBVTT
Kind: captions
Language: en

00:00:01.970 --> 00:00:03.290
FRANCESCO: Welcome.

00:00:03.290 --> 00:00:04.780
How are you guys doing so far?

00:00:04.780 --> 00:00:05.240
AUDIENCE: Good.

00:00:05.240 --> 00:00:07.500
FRANCESCO: Having fun?

00:00:07.500 --> 00:00:09.710
Lots of things happening here.

00:00:09.710 --> 00:00:12.420
At some point, I thought they
wanted to have me base jump

00:00:12.420 --> 00:00:13.560
into this room.

00:00:13.560 --> 00:00:16.290
Crazy stuff.

00:00:16.290 --> 00:00:19.530
My name is Francesco, and I'm
the engineering manager for a

00:00:19.530 --> 00:00:22.690
cloud messaging team
in Android.

00:00:22.690 --> 00:00:24.020
How many of you guys
in this room have

00:00:24.020 --> 00:00:25.790
experience with C2DM?

00:00:25.790 --> 00:00:26.700
Android cloud--

00:00:26.700 --> 00:00:28.010
a lot of you.

00:00:28.010 --> 00:00:31.140
OK, I'm in the right room.

00:00:31.140 --> 00:00:34.220
So let me start giving you a
brief introduction about this

00:00:34.220 --> 00:00:38.100
service, which we launched
in Labs two years ago

00:00:38.100 --> 00:00:41.940
at Google I/O 2010.

00:00:41.940 --> 00:00:46.600
Now, very simply, what C2DM
allows you is for your server

00:00:46.600 --> 00:00:49.100
to send a message to
your application

00:00:49.100 --> 00:00:52.390
on any Android device.

00:00:52.390 --> 00:00:55.020
What C2DM allows for
is what we call the

00:00:55.020 --> 00:00:58.070
send-to-sync mechanism.

00:00:58.070 --> 00:00:59.670
Let me explain with
an example.

00:00:59.670 --> 00:01:02.710
We have a news server that wants
to deliver an update on

00:01:02.710 --> 00:01:06.370
a topic to the devices
of its subscribers.

00:01:06.370 --> 00:01:09.380
So the server goes ahead,
sends the message.

00:01:09.380 --> 00:01:12.540
And when the application
receives it, all it does is to

00:01:12.540 --> 00:01:14.920
connect back to the
news server and

00:01:14.920 --> 00:01:16.170
grab for the new data.

00:01:18.620 --> 00:01:21.880
Now, the beauty of this
mechanism is that it allows

00:01:21.880 --> 00:01:24.270
the application to avoid the
nuisance of having to

00:01:24.270 --> 00:01:28.470
continuously poll to check if
there even is new data.

00:01:28.470 --> 00:01:32.110
This saves battery life.

00:01:32.110 --> 00:01:35.740
Another thing that C2DM does is
that if the server sends a

00:01:35.740 --> 00:01:39.460
message, and the device is
offline, it holds onto the

00:01:39.460 --> 00:01:41.710
message and delivers
it as soon as the

00:01:41.710 --> 00:01:44.900
device comes back online.

00:01:44.900 --> 00:01:49.610
Now, C2DM messages are not
really meant to carry the

00:01:49.610 --> 00:01:52.350
content with them.

00:01:52.350 --> 00:01:55.900
What they're mostly used for
is to say, look, there's

00:01:55.900 --> 00:01:56.700
something new.

00:01:56.700 --> 00:01:58.020
Go check it out.

00:01:58.020 --> 00:02:03.080
So if the news server sends
three messages, which refers

00:02:03.080 --> 00:02:06.830
to an update on the very same
topic, and the device is

00:02:06.830 --> 00:02:09.560
offline, it would be really
silly for us to deliver all

00:02:09.560 --> 00:02:11.930
three of them when it
comes back online.

00:02:11.930 --> 00:02:15.230
Because the application will
continuously connect to the

00:02:15.230 --> 00:02:18.530
server and grab for the
very same data.

00:02:18.530 --> 00:02:22.270
So C2DM does something that
we call collapsing.

00:02:22.270 --> 00:02:24.060
When the device comes
back online, we

00:02:24.060 --> 00:02:26.840
deliver only one of these.

00:02:26.840 --> 00:02:29.500
This saves data and allows
for an easy application

00:02:29.500 --> 00:02:30.410
development.

00:02:30.410 --> 00:02:34.610
Because, since the server takes
care of this use case,

00:02:34.610 --> 00:02:38.050
all that our application needs
to do is, every time I get a

00:02:38.050 --> 00:02:42.500
message, I'm going to connect
to my server.

00:02:42.500 --> 00:02:46.170
Now, send-to-sync is a simple
and flexible mechanism.

00:02:46.170 --> 00:02:49.070
However, much can be done
to optimize for all the

00:02:49.070 --> 00:02:51.170
use cases out there.

00:02:51.170 --> 00:02:53.790
And speaking about improvement,
let's see how

00:02:53.790 --> 00:02:55.630
today we get started
with C2DM.

00:03:02.470 --> 00:03:07.230
So we need a Google account so
that we can go ahead and

00:03:07.230 --> 00:03:09.560
create and manage a client
login token.

00:03:09.560 --> 00:03:13.420
At this point, we can compile a
sign-up form, and wait until

00:03:13.420 --> 00:03:16.580
we receive an activation
email confirmation.

00:03:16.580 --> 00:03:19.000
At this stage, we are granted
some initial quota.

00:03:19.000 --> 00:03:22.140
Now, the more we develop the
application, the more users we

00:03:22.140 --> 00:03:23.730
get, hopefully.

00:03:23.730 --> 00:03:26.720
The more messages we send,
the more quota we need.

00:03:26.720 --> 00:03:29.480
We come back, ask for
more quota, and

00:03:29.480 --> 00:03:32.630
so on, and so forth.

00:03:32.630 --> 00:03:36.690
Without any doubt there is a lot
that we can do to improve

00:03:36.690 --> 00:03:38.870
this process.

00:03:38.870 --> 00:03:42.540
Nonetheless, this service has
seen a lot of traction.

00:03:42.540 --> 00:03:44.460
Along with all the applications
of you guys that

00:03:44.460 --> 00:03:47.310
before raised your hands,
we tens of thousands of

00:03:47.310 --> 00:03:50.100
applications that actively are
using this service every

00:03:50.100 --> 00:03:52.070
single day.

00:03:52.070 --> 00:03:57.250
C2DM processes billions of
messages every single day.

00:03:57.250 --> 00:03:59.070
Which is kind of impressive
for a service

00:03:59.070 --> 00:04:01.390
that launched in Labs.

00:04:01.390 --> 00:04:04.790
We were also kind of impressed
by the amount of great

00:04:04.790 --> 00:04:06.170
feedback that you
guys provided.

00:04:06.170 --> 00:04:11.220
So we decided to bring cloud
messaging to the next level.

00:04:11.220 --> 00:04:14.560
So today, I'm very excited
because I finally get to

00:04:14.560 --> 00:04:18.760
announce our new service,
Google Cloud

00:04:18.760 --> 00:04:20.470
Messaging for Android.

00:04:20.470 --> 00:04:27.820
[APPLAUSE]

00:04:27.820 --> 00:04:29.230
FRANCESCO: We specifically
designed this

00:04:29.230 --> 00:04:31.570
service to make it simple.

00:04:31.570 --> 00:04:34.400
So how do you get started,
for example?

00:04:34.400 --> 00:04:39.970
You go to the Google Developer
console, click Enable GCM, and

00:04:39.970 --> 00:04:41.440
you're done.

00:04:41.440 --> 00:04:44.820
There's no more client login
that you have to care about,

00:04:44.820 --> 00:04:47.600
no more sign-up form or waiting
for activations.

00:04:47.600 --> 00:04:53.570
And best of them all, we got
rid completely of quota.

00:04:53.570 --> 00:04:54.280
Thank you.

00:04:54.280 --> 00:04:58.210
[APPLAUSE]

00:04:58.210 --> 00:04:59.630
FRANCESCO: We're launching this
service because we want

00:04:59.630 --> 00:05:02.530
to make it powerful.

00:05:02.530 --> 00:05:04.780
We want to address a lot more
use cases out there.

00:05:04.780 --> 00:05:07.410
Let's go back to our news
server example.

00:05:07.410 --> 00:05:10.880
What that application wants to
do is to deliver that update

00:05:10.880 --> 00:05:15.770
on that topic to a big bunch
of its subscribers in one

00:05:15.770 --> 00:05:18.510
time, with one request.

00:05:18.510 --> 00:05:20.555
And now we can do that.

00:05:20.555 --> 00:05:23.350
A voice over IP or a video
chat application wants to

00:05:23.350 --> 00:05:26.890
deliver an incoming call request
if, and only if, the

00:05:26.890 --> 00:05:30.330
user at the other end of the
line is online right now.

00:05:30.330 --> 00:05:31.965
Otherwise there's no point.

00:05:31.965 --> 00:05:33.640
And GCM makes this
really simple.

00:05:36.910 --> 00:05:39.230
And instant messaging
applications, they don't

00:05:39.230 --> 00:05:41.160
really have a syncing problem.

00:05:41.160 --> 00:05:43.120
They have a messaging problem.

00:05:43.120 --> 00:05:45.140
Send-to-sync is a bit
tight for them.

00:05:45.140 --> 00:05:46.960
They want to deliver the content
of the chat message

00:05:46.960 --> 00:05:48.830
straight down to the
application and

00:05:48.830 --> 00:05:50.650
be done with it.

00:05:50.650 --> 00:05:52.940
And now you can.

00:05:52.940 --> 00:05:56.010
And finally, we've been working
really hard to make

00:05:56.010 --> 00:05:58.790
this service fast.

00:05:58.790 --> 00:06:01.820
But how fast can GCM get?

00:06:01.820 --> 00:06:07.990
We take 4.7 milliseconds
to send a message.

00:06:07.990 --> 00:06:10.020
Now that I've given you the
flashy numbers, I'm going to

00:06:10.020 --> 00:06:11.270
read through the disclaimers.

00:06:13.850 --> 00:06:19.350
This means 4.7 milliseconds is
when GCM receives the message

00:06:19.350 --> 00:06:21.160
'til the time that GCM
sends the message.

00:06:21.160 --> 00:06:24.250
It does not include the latency
due to the network

00:06:24.250 --> 00:06:28.690
between the server and the
client for one simple reason--

00:06:28.690 --> 00:06:30.580
I don't have a say in that.

00:06:30.580 --> 00:06:33.850
And second, this works if the
news server is here in the

00:06:33.850 --> 00:06:37.900
Moscone Center, and the user
is probably in Ocean Beach,

00:06:37.900 --> 00:06:39.440
San Francisco.

00:06:39.440 --> 00:06:43.540
But globally, what is the
average latency that GCM

00:06:43.540 --> 00:06:46.160
introduces, with those billions
of messages including

00:06:46.160 --> 00:06:50.470
use cases like a news server in
Munich, Germany, and a user

00:06:50.470 --> 00:06:53.310
in Taipei, Taiwan.

00:06:53.310 --> 00:06:57.060
GCM has quite a bit of routing
to do in that case.

00:06:57.060 --> 00:07:01.180
Well, globally, GCM still takes
less than 1/10 of a

00:07:01.180 --> 00:07:03.570
second to process the message.

00:07:03.570 --> 00:07:05.690
The problem is, you're not
going to notice this.

00:07:05.690 --> 00:07:09.050
But the best part of them all
is that all this is still

00:07:09.050 --> 00:07:11.102
completely free.

00:07:11.102 --> 00:07:13.582
[APPLAUSE]

00:07:13.582 --> 00:07:14.832
[INAUDIBLE].

00:07:17.060 --> 00:07:18.470
So let's dive into this.

00:07:18.470 --> 00:07:20.860
Since the European championship
is going on, and

00:07:20.860 --> 00:07:24.800
Italy just won, of course,
let's say that we want to

00:07:24.800 --> 00:07:28.700
build the best football
application ever--

00:07:28.700 --> 00:07:30.840
or soccer.

00:07:30.840 --> 00:07:33.080
So, first thing first, what
we're going to do is to

00:07:33.080 --> 00:07:36.840
deliver score updates in real
time during live events.

00:07:36.840 --> 00:07:39.620
And to do this, we're
going to use GCM.

00:07:39.620 --> 00:07:42.360
So let me give you a high-level
overview of how

00:07:42.360 --> 00:07:44.630
this system works.

00:07:44.630 --> 00:07:47.640
Well, first of all, our football
application needs to

00:07:47.640 --> 00:07:50.890
tell the server that
we want to use GCM.

00:07:50.890 --> 00:07:54.660
To do this, it sends a
registration request, and GCM

00:07:54.660 --> 00:07:57.830
server generates a Registration
ID for us.

00:07:57.830 --> 00:07:59.910
Now, what is a Registration
ID?

00:07:59.910 --> 00:08:02.810
You can consider it as an
address for this application,

00:08:02.810 --> 00:08:04.810
on this device.

00:08:04.810 --> 00:08:08.880
The football app sends the
address to the server, so when

00:08:08.880 --> 00:08:11.600
it wants to send a message,
it can tell GCM where

00:08:11.600 --> 00:08:14.400
to deliver it to.

00:08:14.400 --> 00:08:17.860
Now let's say that for some
unknown reason, our users want

00:08:17.860 --> 00:08:20.830
to uninstall our app.

00:08:20.830 --> 00:08:24.100
The GCM server doesn't know
yet that the app is gone.

00:08:24.100 --> 00:08:25.420
So when the football
server sends a

00:08:25.420 --> 00:08:28.070
message, it sends it down.

00:08:28.070 --> 00:08:31.930
Now the GCM framework on
the device realizes,

00:08:31.930 --> 00:08:33.990
oops, the app is gone.

00:08:33.990 --> 00:08:36.669
So it heads back to the server,

00:08:36.669 --> 00:08:38.440
invalidates this address.

00:08:38.440 --> 00:08:41.335
From this moment on, every
single message that the

00:08:41.335 --> 00:08:45.330
football server sends, it
bounces back with an error of

00:08:45.330 --> 00:08:49.180
"Device Not Registered." If you
get this type of error,

00:08:49.180 --> 00:08:51.790
it's a good thing to get rid
of the Registration ID from

00:08:51.790 --> 00:08:54.050
your database.

00:08:54.050 --> 00:08:56.960
So now that we have a high-level
picture of how the

00:08:56.960 --> 00:09:01.370
system works, let's go ahead
and implement this.

00:09:01.370 --> 00:09:04.170
Remember when I said that all
you need to do is to go to the

00:09:04.170 --> 00:09:07.410
Developer Console and click
Enable Google Cloud Messaging

00:09:07.410 --> 00:09:08.180
for Android?

00:09:08.180 --> 00:09:13.270
If you do so, you'll end
up on a page like this.

00:09:13.270 --> 00:09:18.100
We only need two things here,
the project ID up there and

00:09:18.100 --> 00:09:19.440
the API key down there.

00:09:19.440 --> 00:09:21.140
And you can consider these
two as a username

00:09:21.140 --> 00:09:22.690
and password pair.

00:09:22.690 --> 00:09:25.660
Just grab them, and you're
done for good with this.

00:09:25.660 --> 00:09:29.370
So we go ahead and start writing
some code finally.

00:09:29.370 --> 00:09:32.000
Let's start with the application
on the device.

00:09:32.000 --> 00:09:33.380
Three simple steps.

00:09:33.380 --> 00:09:36.000
Number one, we said we
want to register.

00:09:36.000 --> 00:09:39.250
To do this, we send an intent
to the GCM framework, which

00:09:39.250 --> 00:09:43.070
then talks to the server and
generates the ID for us.

00:09:43.070 --> 00:09:45.080
So how do we send this intent?

00:09:45.080 --> 00:09:46.730
Now, bear with me, because
the code can get a

00:09:46.730 --> 00:09:47.990
bit complicated here.

00:09:50.520 --> 00:09:54.230
With the GCM client library we
just released on the SDK as

00:09:54.230 --> 00:09:58.510
open source code, the line in
red is all you need to write.

00:09:58.510 --> 00:10:01.310
So you call the register
function and pass in the

00:10:01.310 --> 00:10:02.970
Project ID.

00:10:02.970 --> 00:10:06.140
Now, make sure that the Project
ID is correct because

00:10:06.140 --> 00:10:08.720
that's the only authorized
sender that can deliver

00:10:08.720 --> 00:10:10.095
messages to this one
application.

00:10:13.150 --> 00:10:15.300
But perhaps I oversimplified
the code a bit.

00:10:15.300 --> 00:10:18.110
Because if you leave the code in
this state, every time the

00:10:18.110 --> 00:10:20.580
user clicks on the application,
we're going to do

00:10:20.580 --> 00:10:23.520
this registration dance
over and over again.

00:10:23.520 --> 00:10:27.570
To fix this, we add
one line of code.

00:10:27.570 --> 00:10:31.150
The getRegistrationId gives us
an empty string if we did not

00:10:31.150 --> 00:10:34.940
register yet, so we should
go ahead and do so.

00:10:34.940 --> 00:10:37.500
Or it returns the Registration
ID, in which case we are done.

00:10:37.500 --> 00:10:42.020
And we can proceed to
our second step.

00:10:42.020 --> 00:10:43.880
Now the server is done
generating our

00:10:43.880 --> 00:10:44.770
Registration ID.

00:10:44.770 --> 00:10:47.950
It sends it to the framework,
which then delivers it to us

00:10:47.950 --> 00:10:49.540
via an intent.

00:10:49.540 --> 00:10:53.300
So all we need to do is to
listen for this intent.

00:10:53.300 --> 00:10:55.270
And here is how we do that.

00:10:55.270 --> 00:10:58.440
Extremely simple, we extend
the GCMBaseIntentService

00:10:58.440 --> 00:11:02.330
class, and we override the
onRegistered function.

00:11:02.330 --> 00:11:05.030
Now this function gives us
already a Registration ID, so

00:11:05.030 --> 00:11:06.370
we take it and give
it to our server.

00:11:09.570 --> 00:11:12.130
But since we are here, there are
two things that we want to

00:11:12.130 --> 00:11:15.790
listen for, registrations
and messages.

00:11:15.790 --> 00:11:19.180
So let's go ahead and see
how we grab a message.

00:11:19.180 --> 00:11:22.930
Same exact thing, we override
the All Message Function.

00:11:22.930 --> 00:11:27.300
If we need the payload, we
extract it from the intent.

00:11:27.300 --> 00:11:29.980
And now it's our time
to do some magic.

00:11:29.980 --> 00:11:33.290
So we can go ahead and see
step number three,

00:11:33.290 --> 00:11:35.640
permissions.

00:11:35.640 --> 00:11:39.500
Well, we do want our users to
know that we are using GCM

00:11:39.500 --> 00:11:41.480
because we are effectively
sending

00:11:41.480 --> 00:11:43.570
messages from the cloud.

00:11:43.570 --> 00:11:45.520
We're using data from
the network, which

00:11:45.520 --> 00:11:47.690
is not always free.

00:11:47.690 --> 00:11:50.230
In Jelly Bean, we made this
extremely simple, again.

00:11:50.230 --> 00:11:54.540
It's one line of code in
the Manifest file.

00:11:54.540 --> 00:11:56.990
You still see C2DM
written up there.

00:11:56.990 --> 00:11:58.230
It's not a typo.

00:11:58.230 --> 00:12:00.310
It's because we want to keep it
backwards-compatible with

00:12:00.310 --> 00:12:03.470
Froyo-plus devices.

00:12:03.470 --> 00:12:05.700
So let's see what we've
been checking so far.

00:12:05.700 --> 00:12:08.490
Our application can
register with GCM.

00:12:08.490 --> 00:12:12.760
We can receive registrations and
messages from the cloud.

00:12:12.760 --> 00:12:14.370
And we can tell our users
that we are using

00:12:14.370 --> 00:12:16.710
data from the network.

00:12:16.710 --> 00:12:19.500
Nothing else to do, so we can
go ahead and have a look at

00:12:19.500 --> 00:12:20.750
the server.

00:12:23.380 --> 00:12:25.180
What does our server know?

00:12:25.180 --> 00:12:28.960
So in step number two, we gave
him the Registration ID.

00:12:28.960 --> 00:12:32.390
In the authentication slide,
we gave him the API key.

00:12:32.390 --> 00:12:35.880
So, to send a message, what the
football server needs to

00:12:35.880 --> 00:12:41.060
do is to perform an HTTP post
request to the GCM server and

00:12:41.060 --> 00:12:44.070
pass in, along with the message,
the Registration ID

00:12:44.070 --> 00:12:46.170
and the API key.

00:12:46.170 --> 00:12:50.640
So the GCM servers get the API
key and sends it directly to

00:12:50.640 --> 00:12:54.410
an authentication server, which
in turn responds with a

00:12:54.410 --> 00:12:55.490
project ID--

00:12:55.490 --> 00:12:57.920
remember, a username
and password pair.

00:12:57.920 --> 00:13:01.770
But if you also remember step
number one, the Registration

00:13:01.770 --> 00:13:03.240
ID contains the project ID.

00:13:03.240 --> 00:13:05.260
We pass it into the
register function.

00:13:05.260 --> 00:13:08.510
So GCM takes that project ID,
compares it to the one from

00:13:08.510 --> 00:13:12.690
Auth server, and if they do
match it delivers the message

00:13:12.690 --> 00:13:15.580
to the device, to the
application specified by the

00:13:15.580 --> 00:13:17.610
Registration ID.

00:13:17.610 --> 00:13:21.080
Let's have a look at an
example of a request.

00:13:21.080 --> 00:13:23.870
In blue up there is what we're
going to put in the header of

00:13:23.870 --> 00:13:26.570
the HTTP post request.

00:13:26.570 --> 00:13:27.750
The content type--

00:13:27.750 --> 00:13:31.580
GCM allows for plain
text and JSON.

00:13:31.580 --> 00:13:34.560
Authorization key is our
password, the API key.

00:13:34.560 --> 00:13:37.660
While in green is what we put
in the body of the message,

00:13:37.660 --> 00:13:40.550
the Registration ID, which is
the address of the device, and

00:13:40.550 --> 00:13:43.110
the content of the message.

00:13:43.110 --> 00:13:46.080
So now we have a fully working
client-server application

00:13:46.080 --> 00:13:49.610
which is able to deliver score
updates during real time--

00:13:49.610 --> 00:13:50.910
during live events--

00:13:50.910 --> 00:13:53.060
and we can notify our
users that Portugal

00:13:53.060 --> 00:13:55.380
just closed the match.

00:13:55.380 --> 00:13:58.000
This is pretty cool, but let's
make it more awesome.

00:13:58.000 --> 00:14:02.410
Say that we want to add news
updates to our applications.

00:14:02.410 --> 00:14:05.720
We want our users to be notified
about news of their

00:14:05.720 --> 00:14:09.600
favorite teams, of their
favorite users.

00:14:09.600 --> 00:14:12.105
For example, I hear that Beckham
was holding on top of

00:14:12.105 --> 00:14:13.940
his head that giant cup.

00:14:13.940 --> 00:14:16.050
Too bad for him it was
a Stanley Cup.

00:14:16.050 --> 00:14:20.970
We want to deliver this
news to all his users.

00:14:20.970 --> 00:14:22.800
And to do this, we're going
to use the message

00:14:22.800 --> 00:14:24.720
multicasting API.

00:14:24.720 --> 00:14:27.920
The idea is that we send one
HTTP request, with one

00:14:27.920 --> 00:14:31.350
message, and GCM delivers it
to all the devices that we

00:14:31.350 --> 00:14:33.680
specified at the same time.

00:14:33.680 --> 00:14:36.270
And since this is a news update,
we also want to use

00:14:36.270 --> 00:14:39.500
the send-to-sync mechanism.

00:14:39.500 --> 00:14:41.780
Let's look at the request.

00:14:41.780 --> 00:14:45.330
The first parameter in red up
there is the collapse key.

00:14:45.330 --> 00:14:47.830
This comes from the
C2DM times.

00:14:47.830 --> 00:14:50.480
If you remember when I said
that the news server sends

00:14:50.480 --> 00:14:53.600
three messages, three updates
about the very same topic, and

00:14:53.600 --> 00:14:54.990
when the device comes
back online,

00:14:54.990 --> 00:14:56.890
only one gets delivered.

00:14:56.890 --> 00:15:01.080
Well, this happens if GCM knows
that those messages

00:15:01.080 --> 00:15:02.850
refer to the very same topic.

00:15:02.850 --> 00:15:05.260
And to do so, we need
to specify the very

00:15:05.260 --> 00:15:07.620
same collapse key.

00:15:07.620 --> 00:15:10.080
Now below, we see the
Registration IDs.

00:15:10.080 --> 00:15:13.450
And this time, we'll put two
on a list of them, which is

00:15:13.450 --> 00:15:15.860
the list of all the devices that
we want GCM to deliver

00:15:15.860 --> 00:15:17.626
this message to.

00:15:17.626 --> 00:15:21.100
Let's have a look
at the response.

00:15:21.100 --> 00:15:25.080
Well, GCM answers us with the
number of messages succeeded,

00:15:25.080 --> 00:15:27.770
the number of messages that
failed, and the list, in the

00:15:27.770 --> 00:15:30.280
same order in which we specified
the Registration IDs

00:15:30.280 --> 00:15:34.560
in the request, with a message
ID, if it was successful, or

00:15:34.560 --> 00:15:38.360
an error code name,
in case it failed.

00:15:38.360 --> 00:15:42.460
So to summarize, we can send
one HTTP request, with one

00:15:42.460 --> 00:15:45.110
message, and deliver it
to multiple devices.

00:15:45.110 --> 00:15:48.120
And GCM allows us to
specify up to 1,000

00:15:48.120 --> 00:15:51.680
devices per one request.

00:15:51.680 --> 00:15:53.840
So if you look at our app, as
you can clearly see, we have a

00:15:53.840 --> 00:15:58.140
Nexus 7 and a Galaxy Nexus,
which all of you have now.

00:15:58.140 --> 00:16:02.360
Our application can receive the
news update at the same

00:16:02.360 --> 00:16:05.280
time if our football server
sends one request.

00:16:05.280 --> 00:16:06.770
But let's keep going.

00:16:06.770 --> 00:16:09.785
We want to know what David
Beckham has to say about this

00:16:09.785 --> 00:16:11.400
Stanley Cup.

00:16:11.400 --> 00:16:15.520
It would be really cool if we
could add social updates

00:16:15.520 --> 00:16:19.240
inside our application delivered
by some third-party

00:16:19.240 --> 00:16:23.050
service that does this for us.

00:16:23.050 --> 00:16:26.660
The idea is that our football
server will deliver a message,

00:16:26.660 --> 00:16:29.240
a news update or a score update,
straight down to our

00:16:29.240 --> 00:16:32.030
application, while a third-party
service will

00:16:32.030 --> 00:16:36.340
deliver a social update
to our application.

00:16:36.340 --> 00:16:39.730
GCM allows for this, and
it's very simple.

00:16:39.730 --> 00:16:44.230
Let's look at the registration
code again.

00:16:44.230 --> 00:16:47.780
In the Register Function, this
time we specify a list of

00:16:47.780 --> 00:16:48.920
Project IDs.

00:16:48.920 --> 00:16:51.800
These are all the authorized
senders that will be able to

00:16:51.800 --> 00:16:55.540
deliver messages down
to our application.

00:16:55.540 --> 00:16:57.770
When GCM receives this
registration request, it

00:16:57.770 --> 00:17:01.445
creates one Registration ID,
which contains the list of all

00:17:01.445 --> 00:17:02.600
the senders.

00:17:02.600 --> 00:17:06.520
So when we listen for the
Registration ID, all we need

00:17:06.520 --> 00:17:10.970
to do is to send it to both our
football server and to the

00:17:10.970 --> 00:17:14.530
third-party social
update server.

00:17:14.530 --> 00:17:17.790
So with one common Registration
ID, we allow

00:17:17.790 --> 00:17:21.369
multiple parties to deliver
multiple different messages to

00:17:21.369 --> 00:17:23.540
our very own application.

00:17:23.540 --> 00:17:27.790
And GCM allows us to specify
up to 100 different Project

00:17:27.790 --> 00:17:30.750
IDs per application.

00:17:30.750 --> 00:17:33.860
So our football server sends
the news update, and the

00:17:33.860 --> 00:17:35.800
social update server sends
the social update.

00:17:35.800 --> 00:17:39.564
And both get delivered
to our app.

00:17:39.564 --> 00:17:41.690
But let's keep going.

00:17:41.690 --> 00:17:44.120
We want to monetize with
our application.

00:17:44.120 --> 00:17:46.380
First, it would be cool if the
app could tell us, hey, the

00:17:46.380 --> 00:17:48.060
match just started right now.

00:17:48.060 --> 00:17:50.780
But second, it would be awesome
if it tells us, look,

00:17:50.780 --> 00:17:54.310
if you go into one of these bars
which we have deals with

00:17:54.310 --> 00:17:58.450
before the match is over, and
you show our application,

00:17:58.450 --> 00:18:01.180
you're going to get a 25%
discount on the spiciest

00:18:01.180 --> 00:18:02.810
chicken wings ever.

00:18:02.810 --> 00:18:04.550
And I really love
chicken wings.

00:18:04.550 --> 00:18:05.800
Sounds like a good deal.

00:18:07.850 --> 00:18:10.450
The idea is that we send the
message down, but we don't

00:18:10.450 --> 00:18:15.600
want to deliver it if
the message expires.

00:18:15.600 --> 00:18:18.242
If we're sending this message
after the match is over, we

00:18:18.242 --> 00:18:20.550
don't want the application
to receive it.

00:18:20.550 --> 00:18:23.330
Obviously, the application could
see the message, the

00:18:23.330 --> 00:18:26.500
fact that there is a time stamp
that expired, and decide

00:18:26.500 --> 00:18:27.180
to drop it.

00:18:27.180 --> 00:18:29.870
But why deliver in
the first place?

00:18:29.870 --> 00:18:32.570
So GCM helps us here and
allows us to specify a

00:18:32.570 --> 00:18:35.710
lifetime for a message.

00:18:35.710 --> 00:18:36.680
The idea is very simple.

00:18:36.680 --> 00:18:37.550
We send the message.

00:18:37.550 --> 00:18:41.250
If the device is offline, and
the message expires before the

00:18:41.250 --> 00:18:43.200
device comes back online,
well, GCM

00:18:43.200 --> 00:18:46.750
simply gets rid of it.

00:18:46.750 --> 00:18:48.350
Let's have a look
at the request.

00:18:48.350 --> 00:18:52.080
The first parameter up there in
red is Time To Live, which

00:18:52.080 --> 00:18:56.310
is how we specify the lifetime
of the message in seconds.

00:18:56.310 --> 00:18:58.520
There's a second parameter
called Delay While Idle.

00:18:58.520 --> 00:19:02.445
This as well comes from
the C2DM times.

00:19:02.445 --> 00:19:04.990
It is a very nice feature.

00:19:04.990 --> 00:19:08.790
It lets us tell the GCM server,
look, even if the

00:19:08.790 --> 00:19:12.390
device is online, do not deliver
the message unless the

00:19:12.390 --> 00:19:14.580
user is doing something
with it.

00:19:14.580 --> 00:19:17.370
If it's idle in the pocket, just
do not send the message.

00:19:17.370 --> 00:19:20.290
Do not wake up the device.

00:19:20.290 --> 00:19:22.130
This feature is really powerful
in combination with

00:19:22.130 --> 00:19:26.430
Time To Live because even
if the device is online,

00:19:26.430 --> 00:19:29.810
sometimes the message could
expire because of the Delay

00:19:29.810 --> 00:19:31.830
While Idle before it
gets delivered.

00:19:31.830 --> 00:19:35.150
Well, let's go back
to Time To Live.

00:19:35.150 --> 00:19:39.020
We can specify values between
zero seconds and four weeks.

00:19:39.020 --> 00:19:42.880
If we set a value of zero, well,
what it means is that if

00:19:42.880 --> 00:19:45.840
GCM receives the message, and
the device is online, we

00:19:45.840 --> 00:19:47.500
deliver immediately.

00:19:47.500 --> 00:19:50.760
If it's offline, we just
drop it on the floor.

00:19:50.760 --> 00:19:54.550
If we do not specify any
parameter, well, GCM adds a

00:19:54.550 --> 00:19:56.770
default value of four weeks.

00:19:56.770 --> 00:19:59.160
The reason behind this
is really simple.

00:19:59.160 --> 00:20:02.920
Say that you're a speaker in a
conference, like me right now.

00:20:02.920 --> 00:20:03.790
It's your first time.

00:20:03.790 --> 00:20:06.830
You're all tense, and your hands
are shaking, and you

00:20:06.830 --> 00:20:08.180
drop your phone in the toilet.

00:20:08.180 --> 00:20:11.020
Happens to everybody, right?

00:20:11.020 --> 00:20:13.860
I think they gave us a
seven-inch tablet so it's a

00:20:13.860 --> 00:20:15.510
bit too big to fit
in the pipes--

00:20:15.510 --> 00:20:17.600
I save it.

00:20:17.600 --> 00:20:20.960
So the device is offline,
and the server

00:20:20.960 --> 00:20:23.230
keeps on sending messages.

00:20:23.230 --> 00:20:24.560
But it's not going to
come back online.

00:20:24.560 --> 00:20:27.770
So after four weeks, GCM decides
to do some cleanup and

00:20:27.770 --> 00:20:29.020
clears the database.

00:20:31.120 --> 00:20:34.180
But the best feature of them
all, the one I like the most,

00:20:34.180 --> 00:20:37.000
is to be able to chat during
live events in real time with

00:20:37.000 --> 00:20:40.070
users I don't know, but with
which I share the passion

00:20:40.070 --> 00:20:41.840
about the sport.

00:20:41.840 --> 00:20:44.080
And to do this we use the
very basic messaging

00:20:44.080 --> 00:20:46.010
functionality of GCM.

00:20:46.010 --> 00:20:48.690
The idea is that we want to send
the chat message with the

00:20:48.690 --> 00:20:50.820
content straight down to
the application and

00:20:50.820 --> 00:20:52.780
be done with it.

00:20:52.780 --> 00:20:56.590
So if, for example, we send
three messages while the

00:20:56.590 --> 00:21:00.660
device is offline, what we want
GCM to do is to deliver

00:21:00.660 --> 00:21:03.180
all three of them, one after
the other, as soon as the

00:21:03.180 --> 00:21:06.210
device comes back online.

00:21:06.210 --> 00:21:08.540
Let's look at the request.

00:21:08.540 --> 00:21:11.970
The simplest of them all,
Registration ID and the data

00:21:11.970 --> 00:21:14.290
of the message.

00:21:14.290 --> 00:21:15.950
Let's say that I went
on vacation for a

00:21:15.950 --> 00:21:17.070
weekend, or for a week.

00:21:17.070 --> 00:21:20.040
I went to Australia, driving
the Savannah Way.

00:21:20.040 --> 00:21:21.590
I was lucky if I
saw a person--

00:21:21.590 --> 00:21:23.880
definitely was not
connected online.

00:21:23.880 --> 00:21:26.930
So when I come back, I'm
actually really scared of

00:21:26.930 --> 00:21:28.410
turning on my device.

00:21:28.410 --> 00:21:30.500
Who knows how much data is
sitting on the cloud, waiting

00:21:30.500 --> 00:21:33.740
for me to just turn
on the phone?

00:21:33.740 --> 00:21:35.890
If GCM detects this
use case, well, it

00:21:35.890 --> 00:21:37.130
does one simple thing.

00:21:37.130 --> 00:21:39.691
It just deletes all your data.

00:21:39.691 --> 00:21:43.590
And instead, it creates one
little message that gets

00:21:43.590 --> 00:21:47.110
delivered down to our
application and says, look ,

00:21:47.110 --> 00:21:48.330
you're completely out of sync.

00:21:48.330 --> 00:21:51.660
There is so much data waiting
for you on your server.

00:21:51.660 --> 00:21:53.640
Just go sync yourself.

00:21:53.640 --> 00:21:55.700
It's an angry little message.

00:21:55.700 --> 00:21:58.630
And what it tells us is how many
messages we are behind,

00:21:58.630 --> 00:22:01.040
how many messages have
been deleted.

00:22:01.040 --> 00:22:03.390
And if you use our client
library, there is also a

00:22:03.390 --> 00:22:04.450
helper function.

00:22:04.450 --> 00:22:07.280
You override the
onDeletedMessages, and you get

00:22:07.280 --> 00:22:08.810
this total number of
messages deleted.

00:22:08.810 --> 00:22:11.290
So you can go ahead, connect
to your server,

00:22:11.290 --> 00:22:14.250
and do a full sync.

00:22:14.250 --> 00:22:19.110
But how much content does GCM
allow us to put in a message?

00:22:19.110 --> 00:22:22.160
We are allowed to specify up to
four kilobytes of payload

00:22:22.160 --> 00:22:23.970
per single message.

00:22:23.970 --> 00:22:26.980
And we can send up to 100
messages, if the device is

00:22:26.980 --> 00:22:31.470
offline, before GCM decides
to delete them and have us

00:22:31.470 --> 00:22:33.990
trigger a full sync.

00:22:33.990 --> 00:22:36.520
So let's pause for a bit,
and let's check what we

00:22:36.520 --> 00:22:39.180
have seen so far.

00:22:39.180 --> 00:22:42.130
We have been delivering news
updates with one HTTP request

00:22:42.130 --> 00:22:46.700
to up to 1,000 devices using
the multicasting API.

00:22:46.700 --> 00:22:50.030
We've been leveraging
third-party services' features

00:22:50.030 --> 00:22:53.300
by adding them as authorized
senders to deliver messages to

00:22:53.300 --> 00:22:55.730
our application.

00:22:55.730 --> 00:22:58.250
We've been delivering events,
or messages that expire, by

00:22:58.250 --> 00:23:00.590
using the Time To
Live parameter.

00:23:00.590 --> 00:23:03.250
And finally we've been adding
instant messaging

00:23:03.250 --> 00:23:06.840
functionality to our application
by using the very

00:23:06.840 --> 00:23:09.480
basic GCM messaging API.

00:23:09.480 --> 00:23:13.380
So with this in mind, we can
go back to our very first

00:23:13.380 --> 00:23:16.770
feature, the one in which we
deliver score updates in real

00:23:16.770 --> 00:23:20.350
time, and make it better by
using a combination of some of

00:23:20.350 --> 00:23:21.800
these APIs.

00:23:21.800 --> 00:23:25.980
In this case, I would use the
collapse key because if a team

00:23:25.980 --> 00:23:29.380
scores twice, and then we come
online, well, only the last

00:23:29.380 --> 00:23:31.260
message matters.

00:23:31.260 --> 00:23:34.470
Time To Live because if the
match is over before we come

00:23:34.470 --> 00:23:37.240
online, then we don't want
to receive any messages.

00:23:37.240 --> 00:23:42.400
And multicasting because that
simply makes our lives easier.

00:23:42.400 --> 00:23:45.240
So now we have this awesome
server that sends lots of

00:23:45.240 --> 00:23:48.770
messages to lots of users,
keeping them up to date with

00:23:48.770 --> 00:23:52.320
social updates, news updates,
score updates, and whatnot.

00:23:52.320 --> 00:23:54.450
But what happens to all
these messages?

00:23:54.450 --> 00:23:57.290
When the football server
sends a message to GCM,

00:23:57.290 --> 00:23:58.240
what happens to it?

00:23:58.240 --> 00:24:01.390
Does it get dropped, sent,
received, collapsed?

00:24:01.390 --> 00:24:04.820
I mean, mobile networks are
pretty flaky connections.

00:24:04.820 --> 00:24:08.140
One moment they're up, a second
later they're down.

00:24:08.140 --> 00:24:11.150
I drive through a tunnel,
connection drops.

00:24:11.150 --> 00:24:13.480
I exit a tunnel, back up.

00:24:13.480 --> 00:24:15.520
How reliable is GCM?

00:24:18.950 --> 00:24:21.920
Well, Google Cloud Messaging
has this technology we call

00:24:21.920 --> 00:24:25.810
Reliable Message Queue, RMQ,
which sits between the server

00:24:25.810 --> 00:24:28.240
and the GCM framework
on the device.

00:24:28.240 --> 00:24:31.330
And what it does, it ensures
that the messages are

00:24:31.330 --> 00:24:33.460
delivered reliably.

00:24:33.460 --> 00:24:35.780
For example, if the server sends
a message and, right

00:24:35.780 --> 00:24:38.460
there, when we lose the
connection, before hitting the

00:24:38.460 --> 00:24:41.250
device, the message is gone.

00:24:41.250 --> 00:24:44.530
Now the server swears it sent
the message, but the device

00:24:44.530 --> 00:24:46.350
never received it.

00:24:46.350 --> 00:24:48.280
When the connection
comes back up, the

00:24:48.280 --> 00:24:50.130
device connects to GCM.

00:24:50.130 --> 00:24:53.230
During the login dance, RMQ
figures out that the message

00:24:53.230 --> 00:24:54.190
has not been delivered.

00:24:54.190 --> 00:24:57.380
So the server goes ahead
and sends it again.

00:24:57.380 --> 00:25:00.210
Now, ensuring message delivery,
the classic way to

00:25:00.210 --> 00:25:01.900
do it is by ACKing a message.

00:25:01.900 --> 00:25:03.740
Server sends a message.

00:25:03.740 --> 00:25:05.210
The device receives
the message.

00:25:05.210 --> 00:25:07.570
The device sends an ACK
of the message.

00:25:07.570 --> 00:25:09.680
The server receives
the ACK and marks

00:25:09.680 --> 00:25:12.390
the message as delivered.

00:25:12.390 --> 00:25:15.410
But this mechanism is a bit
expensive in terms of data and

00:25:15.410 --> 00:25:17.000
resources for us.

00:25:17.000 --> 00:25:20.370
Because if both sides have to
send an ACK message every time

00:25:20.370 --> 00:25:22.740
they receive one, well, we've
basically doubled the number

00:25:22.740 --> 00:25:24.450
of messages.

00:25:24.450 --> 00:25:28.620
So what RMQ does is a little
clever thing and implements a

00:25:28.620 --> 00:25:31.230
variant of selective ACKing.

00:25:31.230 --> 00:25:35.170
The high level idea here is that
both sides store a bunch

00:25:35.170 --> 00:25:39.450
of messages, and once in a
while, we ACK the bunch.

00:25:39.450 --> 00:25:42.500
But this optimization reveals
something, one of the biggest

00:25:42.500 --> 00:25:44.580
strengths of GCM.

00:25:44.580 --> 00:25:47.990
It is one that you guys don't
even need to care about

00:25:47.990 --> 00:25:50.850
because it's transparent to the
users and to developers.

00:25:50.850 --> 00:25:54.990
Which is why Google Cloud
Messaging is committed.

00:25:54.990 --> 00:25:57.470
It's focused to deliver the
best user experience by

00:25:57.470 --> 00:26:01.120
providing fresh and up to date
data for all the apps.

00:26:01.120 --> 00:26:05.610
It is heavily optimized
for battery life.

00:26:05.610 --> 00:26:08.590
Now let me give you a high-level
overview of some of

00:26:08.590 --> 00:26:11.960
the features that we added to
GCM to optimize for battery.

00:26:14.470 --> 00:26:18.300
One thing that GCM knows is
what's happening on the cloud.

00:26:18.300 --> 00:26:20.030
It sees a lot of messages
coming from different

00:26:20.030 --> 00:26:21.940
applications.

00:26:21.940 --> 00:26:25.650
And if we go back to the
collapsing mechanism--

00:26:25.650 --> 00:26:29.415
remember, the three messages on
the same update, and when

00:26:29.415 --> 00:26:32.230
the device comes back online,
only one gets delivered.

00:26:32.230 --> 00:26:35.170
Well, that's awesome if
the device is offline.

00:26:35.170 --> 00:26:37.010
But what happens if the
device is online?

00:26:37.010 --> 00:26:39.110
Does it make sense to send,
continuously, the very same

00:26:39.110 --> 00:26:41.910
update, the same news, every
30 seconds maybe?

00:26:41.910 --> 00:26:46.240
If GCM detects such a pattern,
well, then it decides to start

00:26:46.240 --> 00:26:48.620
throttling this type
of message.

00:26:48.620 --> 00:26:51.360
And by throttling, it's
a very simple thing.

00:26:51.360 --> 00:26:55.410
We just delay the delivery
of this message.

00:26:55.410 --> 00:26:58.430
Now delaying the delivery
achieves two things.

00:26:58.430 --> 00:27:01.680
One, it increases the chances
of collapsing.

00:27:01.680 --> 00:27:03.730
Let's say that we send this
update every 30 seconds.

00:27:03.730 --> 00:27:06.600
And let's say that the
delay is two minutes.

00:27:06.600 --> 00:27:09.840
Instead of sending four
messages, we send only one.

00:27:09.840 --> 00:27:12.440
But second, and more
importantly, it increases the

00:27:12.440 --> 00:27:15.580
chances of batching.

00:27:15.580 --> 00:27:20.320
Now if we put a message in the
throttle queue, and we start a

00:27:20.320 --> 00:27:21.690
timer, let's say two minutes.

00:27:21.690 --> 00:27:24.150
I'm just giving random
numbers here.

00:27:24.150 --> 00:27:27.670
And two seconds before the alarm
goes off so we can send

00:27:27.670 --> 00:27:29.660
the message, another application
sends a different

00:27:29.660 --> 00:27:32.790
message which we want
to throttle as well.

00:27:32.790 --> 00:27:36.160
Well, when the alarm goes off,
we send both messages.

00:27:36.160 --> 00:27:38.970
Because the most expensive thing
that GCM can do is to

00:27:38.970 --> 00:27:40.170
deliver a message.

00:27:40.170 --> 00:27:41.120
We wake up the network.

00:27:41.120 --> 00:27:42.270
We wake up the radio.

00:27:42.270 --> 00:27:43.460
We wake up the resources.

00:27:43.460 --> 00:27:46.420
So if we send one message, the
best thing we can do is to

00:27:46.420 --> 00:27:48.452
send everything that we have.

00:27:48.452 --> 00:27:51.700
And following this idea, let's
say that we have a few

00:27:51.700 --> 00:27:54.140
messages in the throttle queue,
and another server

00:27:54.140 --> 00:27:56.510
sends one message that we
don't want to throttle.

00:27:56.510 --> 00:27:59.160
It's probably a chat message,
instant message,

00:27:59.160 --> 00:28:01.590
SMS type, or whatever.

00:28:01.590 --> 00:28:04.850
When this message comes along,
even if the throttle queue

00:28:04.850 --> 00:28:07.310
should keep this message for
two more minutes, we just

00:28:07.310 --> 00:28:10.650
piggyback on this one and
deliver everything.

00:28:10.650 --> 00:28:12.970
But we want to do
more batching.

00:28:12.970 --> 00:28:18.640
So what if the server knew
something of the client?

00:28:18.640 --> 00:28:21.500
What if the client tells
him, hey, I'm idle.

00:28:21.500 --> 00:28:23.900
Now the chances that the message
from the cloud is the

00:28:23.900 --> 00:28:27.860
one that prompts the user to
wake up the device and look at

00:28:27.860 --> 00:28:29.570
it diminishes over time.

00:28:29.570 --> 00:28:32.660
If we have been sending messages
from the cloud for an

00:28:32.660 --> 00:28:35.090
idle device for up to an hour,
and the user's never reacted

00:28:35.090 --> 00:28:37.710
to it, well, we can kind of
assume that the next message

00:28:37.710 --> 00:28:39.580
is not the one that's going
to have the user look at

00:28:39.580 --> 00:28:41.720
it and unlock it.

00:28:41.720 --> 00:28:44.390
Now the best thing we can do if
we detect a similar pattern

00:28:44.390 --> 00:28:48.830
is to batch all the messages on
the cloud and send batches

00:28:48.830 --> 00:28:50.100
of messages once in a while.

00:28:52.670 --> 00:28:55.960
But more, what if the device
could tell us, look,

00:28:55.960 --> 00:28:57.170
the radio is up.

00:28:57.170 --> 00:28:58.570
And the display's on.

00:28:58.570 --> 00:29:00.300
Maybe the user is browsing
the web.

00:29:00.300 --> 00:29:02.860
What a perfect moment to
send out messages.

00:29:02.860 --> 00:29:06.530
What if it could tell us, I'm
plugged in, or battery life is

00:29:06.530 --> 00:29:07.710
less of a concern.

00:29:07.710 --> 00:29:08.890
Maybe data is.

00:29:08.890 --> 00:29:11.180
So for data, what if we knew
that it is connected over

00:29:11.180 --> 00:29:13.530
Wi-Fi rather than 4G or 3G?

00:29:13.530 --> 00:29:15.910
Well, one is definitely
cheaper.

00:29:15.910 --> 00:29:18.960
But all these optimizations work
really well if you're a

00:29:18.960 --> 00:29:20.170
power user.

00:29:20.170 --> 00:29:21.310
I have millions of
applications.

00:29:21.310 --> 00:29:22.500
I'm a super popular guy.

00:29:22.500 --> 00:29:23.920
I receive messages
continuously.

00:29:23.920 --> 00:29:25.970
Well, this is really awesome.

00:29:25.970 --> 00:29:27.790
But if I have two apps
that once in a

00:29:27.790 --> 00:29:29.710
while send a message?

00:29:29.710 --> 00:29:30.810
Well if my device starts
telling the

00:29:30.810 --> 00:29:31.850
server, hey, I'm up.

00:29:31.850 --> 00:29:32.600
I'm on radio.

00:29:32.600 --> 00:29:33.480
I'm plugged in.

00:29:33.480 --> 00:29:34.820
Well that's worse.

00:29:34.820 --> 00:29:37.090
You're wasting messaging,
wasting data.

00:29:37.090 --> 00:29:39.600
So since the server is the one
that has global knowledge of

00:29:39.600 --> 00:29:41.360
what's happening, it's the one
that's going to tell the

00:29:41.360 --> 00:29:44.880
device, look, now is a perfect
moment for you to tell me when

00:29:44.880 --> 00:29:46.680
you're idle.

00:29:46.680 --> 00:29:51.550
Or, look, now it's a perfect
moment for you to shut up.

00:29:51.550 --> 00:29:54.240
Another thing is use cases
are different.

00:29:54.240 --> 00:29:57.710
It varies by usage behavior.

00:29:57.710 --> 00:29:59.580
Let's say that we
have a few apps.

00:29:59.580 --> 00:30:01.380
And one of these sends,
once in a while, the

00:30:01.380 --> 00:30:03.870
Delay While Idle bit.

00:30:03.870 --> 00:30:06.300
Remember, we can send the
message, but we don't deliver

00:30:06.300 --> 00:30:10.030
it unless the device
is unlocked.

00:30:10.030 --> 00:30:13.520
Well, then GCM would tell the
device, hey, I need to know

00:30:13.520 --> 00:30:15.480
when you're idle and
when you're up.

00:30:15.480 --> 00:30:19.120
But I don't need to know that
frequently, so just tell me

00:30:19.120 --> 00:30:21.390
you're idle five minutes in.

00:30:21.390 --> 00:30:24.250
Only in other use cases, it
would be way better for

00:30:24.250 --> 00:30:26.500
optimization to tell the device,
hey, let me know

00:30:26.500 --> 00:30:30.830
you're idle the moment
the screen turns off.

00:30:30.830 --> 00:30:32.290
This is a really cool
space where lots of

00:30:32.290 --> 00:30:33.630
innovation is happening.

00:30:33.630 --> 00:30:36.450
But one thing we learn here,
that our messages can be in

00:30:36.450 --> 00:30:37.970
yet another state.

00:30:37.970 --> 00:30:40.710
They can be sent if the
device is online.

00:30:40.710 --> 00:30:43.150
They can be stored if the
device is offline.

00:30:43.150 --> 00:30:45.490
They can be collapsed if the
device is offline, and another

00:30:45.490 --> 00:30:47.810
message with the same Collapse
Key comes along.

00:30:47.810 --> 00:30:50.540
And now they can also
be throttled.

00:30:50.540 --> 00:30:52.760
So on an average day, for those
billions of messages

00:30:52.760 --> 00:30:56.260
that we manage, what happens
to these messages?

00:30:56.260 --> 00:30:57.430
Where do they fit?

00:30:57.430 --> 00:30:59.940
Which of these categories
do they fall in?

00:30:59.940 --> 00:31:03.170
We went ahead and analyzed our
logs and found out that on an

00:31:03.170 --> 00:31:07.790
average day almost 55% of
messages are delivered to

00:31:07.790 --> 00:31:08.835
online devices.

00:31:08.835 --> 00:31:13.160
While almost 42%, they're stored
on devices, waiting for

00:31:13.160 --> 00:31:15.310
the devices to come
back online.

00:31:15.310 --> 00:31:17.270
2.6 are collapsed--

00:31:17.270 --> 00:31:18.250
yes, collapsed--

00:31:18.250 --> 00:31:20.350
and 1.2, they're throttled.

00:31:20.350 --> 00:31:23.220
Those popular guys,
they're 1%.

00:31:23.220 --> 00:31:24.510
We found two things.

00:31:24.510 --> 00:31:28.130
One is that GCM does
not lose messages.

00:31:28.130 --> 00:31:30.600
If we receive a message, we know
exactly in which of these

00:31:30.600 --> 00:31:32.220
categories it falls.

00:31:32.220 --> 00:31:35.080
And two, well, it would be
really awesome if our

00:31:35.080 --> 00:31:38.460
developer's could have access
to similar stats.

00:31:38.460 --> 00:31:40.630
So we went ahead and integrated
with the Android

00:31:40.630 --> 00:31:44.330
Developer Console, which already
shows stats for your

00:31:44.330 --> 00:31:44.980
applications.

00:31:44.980 --> 00:31:47.800
But now if you login, you can
also see these type of metrics

00:31:47.800 --> 00:31:52.660
for your GCM and C2DM
applications.

00:31:52.660 --> 00:31:55.710
In a few weeks, Android
Developer Console will roll

00:31:55.710 --> 00:31:57.440
out a new UI.

00:31:57.440 --> 00:32:00.230
So let me give you a preview of
this new UI integrated with

00:32:00.230 --> 00:32:01.480
our metrics.

00:32:03.750 --> 00:32:05.590
Here it is.

00:32:05.590 --> 00:32:09.570
On the top left corner, you
have a drop-down box menu

00:32:09.570 --> 00:32:11.150
where you can select
the metric type.

00:32:11.150 --> 00:32:14.410
In this case, it's the
GCM registrations.

00:32:14.410 --> 00:32:17.340
Now, this metric means the
number of requests that

00:32:17.340 --> 00:32:21.220
devices out there make to
register for this application

00:32:21.220 --> 00:32:24.120
with the GCM servers.

00:32:24.120 --> 00:32:27.020
On the top right, you can select
the period of time for

00:32:27.020 --> 00:32:29.650
which you want to analyze
this metric.

00:32:29.650 --> 00:32:31.790
And the tabs in the middle,
they allow you to do a

00:32:31.790 --> 00:32:35.550
breakdown of this metric by
Android version, device,

00:32:35.550 --> 00:32:37.750
country, language, and so on.

00:32:37.750 --> 00:32:40.340
For example, here the breakdown

00:32:40.340 --> 00:32:41.620
is by Android version.

00:32:41.620 --> 00:32:44.150
And we can see that a majority
of requests come from

00:32:44.150 --> 00:32:48.310
Gingerbread, ICS devices,
followed by Froyo.

00:32:48.310 --> 00:32:50.890
We can go ahead and have it,
for example, look at the

00:32:50.890 --> 00:32:52.460
application version tab.

00:32:52.460 --> 00:32:54.650
We see we've launched
a few versions.

00:32:54.650 --> 00:32:57.500
The last one is most popular.

00:32:57.500 --> 00:33:01.360
And go ahead and go to the GCM
errors tab, which is going to

00:33:01.360 --> 00:33:04.560
change its name soon, and
represent all the successful

00:33:04.560 --> 00:33:06.360
messages and all the
error messages.

00:33:06.360 --> 00:33:09.340
Well, in this case, we
had no failures.

00:33:09.340 --> 00:33:13.510
But the best metric is
the GCM messages one.

00:33:13.510 --> 00:33:16.180
If we look at the graph, we can
see that in the first week

00:33:16.180 --> 00:33:19.120
of June, something happened.

00:33:19.120 --> 00:33:22.760
All of a sudden, we started
delivering way more messages.

00:33:22.760 --> 00:33:27.738
So either we rolled out a
feature or rolled out a bug.

00:33:27.738 --> 00:33:31.310
And if you look at the Android
version breakdown, we can see

00:33:31.310 --> 00:33:33.560
that the majority of messages
we send, they land on

00:33:33.560 --> 00:33:37.100
Gingerbread, Froyo, and ICS
devices-- which is kind of in

00:33:37.100 --> 00:33:38.710
line with what we've
seen with the

00:33:38.710 --> 00:33:42.360
registration request metric.

00:33:42.360 --> 00:33:43.660
We can look, for example,
in the country.

00:33:43.660 --> 00:33:47.010
We see we launched in North
America as almost all the

00:33:47.010 --> 00:33:51.590
messages that we send land on
users in US and Canada.

00:33:51.590 --> 00:33:55.880
And finally, look at the GCM
messages status, which shows

00:33:55.880 --> 00:33:57.450
the metrics I was
talking about--

00:33:57.450 --> 00:33:59.320
sent, stored, collapsed, and

00:33:59.320 --> 00:34:03.140
throttled, and invalid requests.

00:34:03.140 --> 00:34:06.650
Which, in this case, they look
like to be the majority.

00:34:06.650 --> 00:34:10.590
They are more than 70%
invalid requests.

00:34:10.590 --> 00:34:12.675
So we can go ahead in
the GCM errors tab,

00:34:12.675 --> 00:34:15.340
and see what's happening.

00:34:15.340 --> 00:34:16.860
Very simple--

00:34:16.860 --> 00:34:19.639
we all of a sudden started
sending lots of messages, but

00:34:19.639 --> 00:34:21.770
we ran out of quota.

00:34:21.770 --> 00:34:26.880
Now, the best way to fix this
is to migrate to GCM.

00:34:26.880 --> 00:34:28.699
Now, I'm feeling a bit lucky.

00:34:28.699 --> 00:34:34.690
And I'll try to give a live demo
of one GCM application

00:34:34.690 --> 00:34:37.170
which all of you have been using
so far, which is the

00:34:37.170 --> 00:34:41.409
Google IU app, and see how the
stats look like today in the

00:34:41.409 --> 00:34:42.679
Android Developer Console.

00:34:48.540 --> 00:34:52.020
Can you guys see, or should
I magnify more?

00:34:52.020 --> 00:34:53.560
It's good?

00:34:53.560 --> 00:34:56.679
This is GCM messages, and you
can see that on June 25 is

00:34:56.679 --> 00:34:59.285
when we started to
deliver content.

00:35:02.540 --> 00:35:07.345
We can see a majority of the
devices are ICS, Gingerbread,

00:35:07.345 --> 00:35:09.080
Honeycomb--

00:35:09.080 --> 00:35:11.390
weird.

00:35:11.390 --> 00:35:13.500
Let's go to the GCM
message status.

00:35:13.500 --> 00:35:15.450
And what we see is
that are sent

00:35:15.450 --> 00:35:17.640
messages, stored messages.

00:35:17.640 --> 00:35:21.300
But there are also a lot
of throttle messages.

00:35:21.300 --> 00:35:24.285
Simple explanation, because when
we were testing this, we

00:35:24.285 --> 00:35:28.110
started sending a lot of sync
requests, and then GCM decided

00:35:28.110 --> 00:35:31.010
to start throttling it.

00:35:31.010 --> 00:35:34.980
And the GCM errors, I want to
show you that, if we remove

00:35:34.980 --> 00:35:39.000
the OK, we have Not
Registered errors.

00:35:39.000 --> 00:35:44.660
We changed the version during
the past two days, so we had a

00:35:44.660 --> 00:35:46.820
bunch of Registration
IDs in our servers.

00:35:46.820 --> 00:35:48.350
And when we changed the version
and sent all the

00:35:48.350 --> 00:35:51.400
messages, well, the old
registrations were invalid.

00:35:51.400 --> 00:35:52.700
just figured it out.

00:35:52.700 --> 00:35:54.330
And so we had massive errors.

00:35:54.330 --> 00:35:56.440
And you can see that it's
steadily going down, and

00:35:56.440 --> 00:36:00.860
tomorrow it will probably
drop completely.

00:36:00.860 --> 00:36:04.680
One thing with this metric is
that they are daily metrics.

00:36:04.680 --> 00:36:08.590
And they usually refer to
up to the day before.

00:36:08.590 --> 00:36:10.260
Well, let's go back
to our slides.

00:36:13.510 --> 00:36:17.090
So I said that to fix this
error, the best thing you can

00:36:17.090 --> 00:36:19.450
do is to migrate to GCM.

00:36:19.450 --> 00:36:22.850
Well, to be honest, it's
also the only chance

00:36:22.850 --> 00:36:23.620
that you have now.

00:36:23.620 --> 00:36:29.130
Because, as of now, C2DM
is in deprecation mode.

00:36:29.130 --> 00:36:34.760
We do not accept sign-ups, nor
quota increase requests.

00:36:34.760 --> 00:36:38.080
But do not be scared, because
the C2DM servers are still up

00:36:38.080 --> 00:36:39.620
and running.

00:36:39.620 --> 00:36:42.070
I was debating whether to kill
all your applications, but

00:36:42.070 --> 00:36:44.920
then I flipped a coin.

00:36:44.920 --> 00:36:46.570
I lost it.

00:36:46.570 --> 00:36:51.200
But GCM servers are also up and
running, and they're very

00:36:51.200 --> 00:36:52.340
much alive.

00:36:52.340 --> 00:36:54.690
And I suggest you migrate
for two main reasons.

00:36:54.690 --> 00:36:57.270
One, this service
is really cool.

00:36:57.270 --> 00:37:01.110
And two, no, really, this
service is really cool.

00:37:01.110 --> 00:37:03.130
And migrating is very simple.

00:37:03.130 --> 00:37:04.830
Three simple steps--

00:37:04.830 --> 00:37:08.280
click to enable GCM, point
your server to

00:37:08.280 --> 00:37:11.940
android.googleap
is.com/gcm/send--

00:37:11.940 --> 00:37:14.200
here, you want to use
the API Key--

00:37:14.200 --> 00:37:17.080
and all you need to change on
the device is to register with

00:37:17.080 --> 00:37:18.330
a Project ID.

00:37:20.260 --> 00:37:23.060
But if you want to take your
time, you can do so.

00:37:23.060 --> 00:37:26.480
We're not going to bring down
the servers for a while.

00:37:26.480 --> 00:37:29.570
And you can read all the cool
new stuff we add in GCM.

00:37:29.570 --> 00:37:32.930
Read our documentation, which
includes a Getting Started

00:37:32.930 --> 00:37:36.710
Guide with a step-by-step
tutorial, with demo code,

00:37:36.710 --> 00:37:40.810
which is open sourced, a demo
application, which is as well

00:37:40.810 --> 00:37:45.410
open sourced with instruction on
how to use it and run it, a

00:37:45.410 --> 00:37:50.380
quick-and-dirty guide for C2DM
experts on how to migrate, and

00:37:50.380 --> 00:37:54.120
advance topics with pro-tips
on the rest of this

00:37:54.120 --> 00:37:54.850
implementation.

00:37:54.850 --> 00:37:57.450
And all this at
developer.android.com.

00:38:00.560 --> 00:38:01.160
Thank you.

00:38:01.160 --> 00:38:11.471
[APPLAUSE]

00:38:11.471 --> 00:38:14.850
FRANCESCO: So I hoped to land
a little bit longer so I

00:38:14.850 --> 00:38:16.270
wouldn't get questions,
but I guess.

00:38:20.070 --> 00:38:21.320
Any questions?

00:38:27.330 --> 00:38:30.670
AUDIENCE: I had a question
about multicasting.

00:38:30.670 --> 00:38:33.280
Is there a way to send messages
to all devices

00:38:33.280 --> 00:38:36.590
without specifying
individual IDs?

00:38:36.590 --> 00:38:40.630
FRANCESCO: So the question is,
is there a way to do broadcast

00:38:40.630 --> 00:38:42.910
of messaging?

00:38:42.910 --> 00:38:47.810
I expected this question, and
the short answer is "no." The

00:38:47.810 --> 00:38:51.730
longer answer is, it's a
very dangerous feature.

00:38:51.730 --> 00:38:54.300
Every time I think about it,
it's like a big red button

00:38:54.300 --> 00:38:59.360
that if you press it,
everything explodes.

00:38:59.360 --> 00:39:01.930
We're doing our best, and we are
still thinking about it.

00:39:01.930 --> 00:39:04.700
But for now, the best of your
options is to use multicasting

00:39:04.700 --> 00:39:06.870
and add up to 1,000
in batches.

00:39:12.730 --> 00:39:14.630
AUDIENCE: Is there any
possibility to send cloud

00:39:14.630 --> 00:39:19.490
messages to applications not
installed from Play?

00:39:19.490 --> 00:39:20.830
FRANCESCO: Second question
I was expecting.

00:39:20.830 --> 00:39:23.120
It's pretty easy today.

00:39:23.120 --> 00:39:28.360
Short and long answer-- "no."
The reason is GCM framework

00:39:28.360 --> 00:39:31.080
relies on the Google Services
Framework, which is part of

00:39:31.080 --> 00:39:33.950
the GMS core, which includes
Play and everything else.

00:39:33.950 --> 00:39:36.950
It's a Google service, and we
will provide it only with

00:39:36.950 --> 00:39:38.380
these other services.

00:39:38.380 --> 00:39:40.210
AUDIENCE: I heard a rumor
that you don't have to

00:39:40.210 --> 00:39:43.160
publish it in Play.

00:39:43.160 --> 00:39:45.897
So if you upload it, and
not publish it, is

00:39:45.897 --> 00:39:47.290
that going to work?

00:39:47.290 --> 00:39:50.990
FRANCESCO: Yes, so, to use GCM,
you don't have to use the

00:39:50.990 --> 00:39:52.450
Developer Console.

00:39:52.450 --> 00:39:53.476
Is that the question?

00:39:53.476 --> 00:39:54.190
AUDIENCE: Yeah.

00:39:54.190 --> 00:39:54.600
FRANCESCO: Yes.

00:39:54.600 --> 00:39:57.860
What you're not going to
get is the metrics.

00:39:57.860 --> 00:39:59.680
So to have access to all the
stats that we showed at the

00:39:59.680 --> 00:40:03.330
end, you need to upload your
APK on the place on the

00:40:03.330 --> 00:40:04.640
Developer Console.

00:40:04.640 --> 00:40:05.800
But to use GCM, you
don't need to.

00:40:05.800 --> 00:40:09.300
You just go to the Google
Developer Console, where you

00:40:09.300 --> 00:40:12.800
have all the services, click for
the API, and you're done.

00:40:12.800 --> 00:40:14.050
AUDIENCE: Thank you.

00:40:16.060 --> 00:40:18.460
AUDIENCE: For an app that
already exists, and we're

00:40:18.460 --> 00:40:20.770
using C2DM, we know that when
we release an update, not

00:40:20.770 --> 00:40:21.860
everybody's going to
get that update.

00:40:21.860 --> 00:40:24.520
So we can't just switch it all
over to the GCM framework.

00:40:24.520 --> 00:40:26.840
So do we have to keep two
separate systems, one

00:40:26.840 --> 00:40:29.960
processing C2DM requests,
and the other one GCM?

00:40:29.960 --> 00:40:32.890
FRANCESCO: For existing
C2DM applications,

00:40:32.890 --> 00:40:36.610
the migration is--

00:40:36.610 --> 00:40:39.550
well, you need to up the version
of the app, which will

00:40:39.550 --> 00:40:42.220
have the Project ID.

00:40:42.220 --> 00:40:45.030
And all the [? third ?] parties
on your server.

00:40:45.030 --> 00:40:48.360
Now, you have to tell the
server, I'm using GCM.

00:40:48.360 --> 00:40:50.680
So he knows to connect to
this new URL rather

00:40:50.680 --> 00:40:51.735
than the old one.

00:40:51.735 --> 00:40:53.290
That's all you need to do.

00:40:53.290 --> 00:40:56.650
AUDIENCE: Basically we would
have to maintain our C2DM code

00:40:56.650 --> 00:40:59.610
until enough clients
are off of that?

00:40:59.610 --> 00:41:01.510
FRANCESCO: That is correct,
unless you want to kill all

00:41:01.510 --> 00:41:03.460
your clients, yes, because
we changed the

00:41:03.460 --> 00:41:04.690
authentication method.

00:41:04.690 --> 00:41:08.500
But this is not just
forced by GCM.

00:41:08.500 --> 00:41:12.510
Client login is deprecated, so
we had to switch away anyways.

00:41:12.510 --> 00:41:14.780
AUDIENCE: Thank you.

00:41:14.780 --> 00:41:24.220
AUDIENCE: So if I have an
application that relies on GCM

00:41:24.220 --> 00:41:28.730
in order to synchronize, and
my messages expire after a

00:41:28.730 --> 00:41:32.740
maximum of four weeks, what are
the circumstances where

00:41:32.740 --> 00:41:35.530
the client receives the delete
message that says, hey, you're

00:41:35.530 --> 00:41:38.570
way out of date, you need
to go and synchronize?

00:41:38.570 --> 00:41:43.405
Is that only when messages just
get deleted, or are there

00:41:43.405 --> 00:41:44.730
certain other kinds
of circumstances?

00:41:44.730 --> 00:41:46.930
Can I guarantee-- can I
always rely on the--

00:41:46.930 --> 00:41:50.090
FRANCESCO: All right, the
question is, if a message--

00:41:50.090 --> 00:41:53.480
I'm repeating just to see if
I understood correctly--

00:41:53.480 --> 00:41:56.410
if a message expires with a Time
To Live of four weeks, do

00:41:56.410 --> 00:41:59.948
we get notified about the
fact that they expired?

00:41:59.948 --> 00:42:03.860
No, because Time To Live means
simply that if the message

00:42:03.860 --> 00:42:07.100
expired, the device doesn't
need to know that.

00:42:07.100 --> 00:42:10.310
What I suggest to do, because
you're saying, well, if an app

00:42:10.310 --> 00:42:12.440
doesn't connect for four
weeks, well, some of my

00:42:12.440 --> 00:42:14.710
messages are deleted, right?

00:42:14.710 --> 00:42:16.950
Well, four weeks
is a long time.

00:42:16.950 --> 00:42:20.530
And what I would do is have
a full sync of my app if I

00:42:20.530 --> 00:42:22.210
detect that for four weeks,
it's not been

00:42:22.210 --> 00:42:23.800
connected to the network.

00:42:23.800 --> 00:42:24.640
AUDIENCE: OK, good idea.

00:42:24.640 --> 00:42:26.730
Thanks.

00:42:26.730 --> 00:42:32.000
AUDIENCE: Is the Gmail sign-up
still required for Google

00:42:32.000 --> 00:42:34.250
Cloud Messaging?

00:42:34.250 --> 00:42:35.110
FRANCESCO: Gmail sign-up?

00:42:35.110 --> 00:42:38.310
AUDIENCE: Yeah, at the
beginning, for a tour.

00:42:38.310 --> 00:42:40.480
FRANCESCO: So to go to the
Google Developer Console, you

00:42:40.480 --> 00:42:41.650
need a Google account?

00:42:41.650 --> 00:42:42.300
AUDIENCE: No, not that.

00:42:42.300 --> 00:42:43.550
I'm talking about
from the device.

00:42:46.670 --> 00:42:48.450
FRANCESCO: No.

00:42:48.450 --> 00:42:51.050
From ICS plus, you do
not need a Google

00:42:51.050 --> 00:42:52.890
account on the device.

00:42:52.890 --> 00:42:56.290
AUDIENCE: So, for example,
C2DM, you have to have a

00:42:56.290 --> 00:43:01.790
sign-up for Gmail, right,
before it works.

00:43:01.790 --> 00:43:06.460
Right now, you're saying that
it's not required, right?

00:43:06.460 --> 00:43:09.280
FRANCESCO: It doesn't mean if
it's GCM or C2DM, it's a

00:43:09.280 --> 00:43:10.570
change in ICS.

00:43:10.570 --> 00:43:13.670
From ICS plus, you're not
required to add a Google

00:43:13.670 --> 00:43:16.860
account on the device to be able
to use push messaging.

00:43:16.860 --> 00:43:17.940
AUDIENCE: OK, one last thing.

00:43:17.940 --> 00:43:19.860
What is the heartbeat, now?

00:43:19.860 --> 00:43:21.950
What is the heartbeat rate?

00:43:21.950 --> 00:43:22.900
FRANCESCO: For the persistent
connection?

00:43:22.900 --> 00:43:24.500
AUDIENCE: Yeah.

00:43:24.500 --> 00:43:27.330
FRANCESCO: Well, it varies,
depends on the carriers,

00:43:27.330 --> 00:43:29.000
depends on the countries.

00:43:29.000 --> 00:43:33.480
The default classic value we
used is 28 minutes, but it's

00:43:33.480 --> 00:43:36.925
changed a lot based on carriers
and countries.

00:43:36.925 --> 00:43:37.380
AUDIENCE: OK.

00:43:37.380 --> 00:43:38.630
Thank you.

00:43:41.020 --> 00:43:44.210
AUDIENCE: I take it that this
means that it's back-ported to

00:43:44.210 --> 00:43:46.520
at least Gingerbread?

00:43:46.520 --> 00:43:48.530
FRANCESCO: GCM works
from Froyo plus.

00:43:48.530 --> 00:43:49.540
AUDIENCE: Awesome, thanks.

00:43:49.540 --> 00:43:52.210
FRANCESCO: Of course.

00:43:52.210 --> 00:43:54.960
AUDIENCE: What about the
security of the messages?

00:43:54.960 --> 00:43:56.860
How is that going
to be handled?

00:43:56.860 --> 00:44:00.870
So if I was sending account
information for a bank?

00:44:00.870 --> 00:44:04.370
FRANCESCO: So if you add
information on the payload of

00:44:04.370 --> 00:44:09.250
the message, well, the
connection between your server

00:44:09.250 --> 00:44:12.360
and GCM server should
be HTTPS.

00:44:12.360 --> 00:44:14.370
If you're comfortable with
that, then you can send a

00:44:14.370 --> 00:44:16.930
message, and the connection
between the GCM server and the

00:44:16.930 --> 00:44:19.900
device is secure, is encrypted
and whatnot.

00:44:19.900 --> 00:44:23.400
But you can do your own security
on top of that and

00:44:23.400 --> 00:44:26.105
encrypt your payload and
decrypt it down.

00:44:26.105 --> 00:44:27.720
AUDIENCE: OK, and what
about the messages, I

00:44:27.720 --> 00:44:28.970
guess, on the GCM?

00:44:28.970 --> 00:44:32.320
Do they have a shelf life,
or does Google delete the

00:44:32.320 --> 00:44:34.860
messages after a certain
amount of time?

00:44:34.860 --> 00:44:39.640
Or are they kept for
x amount of time?

00:44:39.640 --> 00:44:41.990
FRANCESCO: So the question is,
if you send a message, how

00:44:41.990 --> 00:44:43.230
long GCM stores them?

00:44:43.230 --> 00:44:46.110
AUDIENCE: Yeah, and I guess, if
you send a message through

00:44:46.110 --> 00:44:48.450
GCM, does Google hold onto that

00:44:48.450 --> 00:44:50.780
message and keep it somewhere?

00:44:50.780 --> 00:44:51.560
FRANCESCO: Right.

00:44:51.560 --> 00:44:54.890
So unless you specify Time To
Live of zero, in which case

00:44:54.890 --> 00:44:57.650
we're not storing it at all,
we store it for up to the

00:44:57.650 --> 00:44:58.680
lifetime of the message.

00:44:58.680 --> 00:45:00.570
If you don't specify, the
top is four weeks.

00:45:00.570 --> 00:45:02.510
And we store it in our servers,
but we don't modify

00:45:02.510 --> 00:45:03.630
the message or anything.

00:45:03.630 --> 00:45:05.770
As soon as the device is online,
we just send it down.

00:45:05.770 --> 00:45:09.950
AUDIENCE: OK, but I'm thinking
for a banking application.

00:45:09.950 --> 00:45:12.470
If you're sending messages
through GCM, they might not

00:45:12.470 --> 00:45:16.220
want those messages to be stored
on Google servers.

00:45:16.220 --> 00:45:19.230
They just want it to be a
transparent pass-through.

00:45:19.230 --> 00:45:21.280
FRANCESCO: Well, then the only
option you have is to specify

00:45:21.280 --> 00:45:22.490
Time To Live of zero.

00:45:22.490 --> 00:45:22.860
We do not--

00:45:22.860 --> 00:45:24.480
AUDIENCE: And then nothing
will be stored on--

00:45:24.480 --> 00:45:25.620
FRANCESCO: We do not store it.

00:45:25.620 --> 00:45:26.120
AUDIENCE: OK, perfect.

00:45:26.120 --> 00:45:28.440
Thank you.

00:45:28.440 --> 00:45:30.410
AUDIENCE: I don't know if this
was mentioned, but can you

00:45:30.410 --> 00:45:32.165
send messages from a device?

00:45:35.040 --> 00:45:36.430
FRANCESCO: We have
an API for that.

00:45:36.430 --> 00:45:38.330
It's not open to
developers yet.

00:45:38.330 --> 00:45:40.060
We use it a lot for all
the optimization

00:45:40.060 --> 00:45:42.370
I was talking about.

00:45:42.370 --> 00:45:44.715
We are thinking to maybe
open it later on.

00:45:44.715 --> 00:45:47.110
It depends on use cases.

00:45:47.110 --> 00:45:49.760
So keep coming your feedbacks
and requests, and

00:45:49.760 --> 00:45:51.790
we will back it.

00:45:51.790 --> 00:45:52.490
AUDIENCE: And then
one more thing.

00:45:52.490 --> 00:45:56.040
Is there any failure callback
for if a message fails

00:45:56.040 --> 00:46:00.200
immediately or within a certain
period of time?

00:46:00.200 --> 00:46:01.380
FRANCESCO: What type
of failures?

00:46:01.380 --> 00:46:05.750
So if your request from your
server to our GCM server does

00:46:05.750 --> 00:46:10.130
not fail, well then we ensure
delivery in the time span of

00:46:10.130 --> 00:46:11.465
the four weeks.

00:46:11.465 --> 00:46:11.950
AUDIENCE: OK.

00:46:11.950 --> 00:46:13.200
All right, thanks.

00:46:14.900 --> 00:46:19.530
AUDIENCE: Is there any chance to
use GCM for other devices,

00:46:19.530 --> 00:46:23.050
like iOS devices, as well?

00:46:23.050 --> 00:46:23.870
FRANCESCO: No.

00:46:23.870 --> 00:46:29.930
The reason is we have a
persistent connection between

00:46:29.930 --> 00:46:35.160
Android and our servers, in the
background, something that

00:46:35.160 --> 00:46:38.010
you're not allowed to have
in other systems.

00:46:38.010 --> 00:46:44.070
You can use APNS for Apple and
Microsoft Push, I think.

00:46:44.070 --> 00:46:46.910
AUDIENCE: Second question, is
there some sort of time frame

00:46:46.910 --> 00:46:48.030
delivery guaranteed?

00:46:48.030 --> 00:46:50.050
Like say my server pings GCM.

00:46:50.050 --> 00:46:52.970
What's the guaranteed time frame
it's going to reach my

00:46:52.970 --> 00:46:56.800
device, considering that,
say, it is online and

00:46:56.800 --> 00:46:58.100
available to GCM?

00:46:58.100 --> 00:46:59.810
FRANCESCO: So we are
a very reliable

00:46:59.810 --> 00:47:01.960
service, but we do not--

00:47:01.960 --> 00:47:03.620
I don't want to say they
guarantee delivery.

00:47:03.620 --> 00:47:06.110
It's a free service.

00:47:06.110 --> 00:47:07.810
AUDIENCE: What if I need--

00:47:07.810 --> 00:47:10.530
is there like a paid version
that I can get a--

00:47:10.530 --> 00:47:11.075
FRANCESCO: Nope.

00:47:11.075 --> 00:47:14.020
There's no paid version,
nothing.

00:47:14.020 --> 00:47:18.070
All Google services and apps
use this as their reliable

00:47:18.070 --> 00:47:19.920
mechanism to deliver messages
to Android.

00:47:19.920 --> 00:47:21.220
It works very well.

00:47:21.220 --> 00:47:26.260
But we just offer a free
service, and we have no--

00:47:26.260 --> 00:47:27.550
we don't want to say we
guarantee delivery.

00:47:27.550 --> 00:47:27.960
AUDIENCE: OK.

00:47:27.960 --> 00:47:29.228
Cool, thank you.

00:47:32.550 --> 00:47:35.940
AUDIENCE: Would GCM be
appropriate for turn-based

00:47:35.940 --> 00:47:38.094
game messaging?

00:47:38.094 --> 00:47:38.970
FRANCESCO: A what game?

00:47:38.970 --> 00:47:41.300
AUDIENCE: Turn-based game,
like a board game,

00:47:41.300 --> 00:47:42.855
multiplayer.

00:47:42.855 --> 00:47:48.460
FRANCESCO: Yeah, you know, if
you need very quick messaging

00:47:48.460 --> 00:47:50.580
between two devices,
for example?

00:47:50.580 --> 00:47:53.020
Well, you should open your
connection there, because you

00:47:53.020 --> 00:47:54.500
want to keep up the
radio anyways.

00:47:54.500 --> 00:47:54.900
Right?

00:47:54.900 --> 00:47:56.840
So the main issue if you
use mobile networks

00:47:56.840 --> 00:47:59.370
is the paging mechanism.

00:47:59.370 --> 00:48:00.810
So let's say that you
have a device, and I

00:48:00.810 --> 00:48:01.420
send you the message.

00:48:01.420 --> 00:48:04.730
Even if I take those 4.7
milliseconds, well, now the

00:48:04.730 --> 00:48:07.150
mobile carrier has to do the
paging, wake up the radio, do

00:48:07.150 --> 00:48:10.150
the connection, reconnect the
socket, and send it down.

00:48:10.150 --> 00:48:14.210
So that can take
a few seconds.

00:48:14.210 --> 00:48:17.160
And radios go dormant pretty
quickly, because they also

00:48:17.160 --> 00:48:19.320
want to optimize for battery.

00:48:19.320 --> 00:48:23.110
So if you are in a
game modality--

00:48:23.110 --> 00:48:25.140
so you want to keep the radio
up-- at that point why don't

00:48:25.140 --> 00:48:27.670
you establish your own
peer-to-peer connection?

00:48:27.670 --> 00:48:32.640
You can use GCM to create this
connection, to discover

00:48:32.640 --> 00:48:33.700
something, but then--

00:48:33.700 --> 00:48:34.400
AUDIENCE: Right.

00:48:34.400 --> 00:48:38.040
And there's a way, I assume, to
say this message is OK to

00:48:38.040 --> 00:48:39.540
be throttled, and this
other message

00:48:39.540 --> 00:48:43.170
needs to never be throttled?

00:48:43.170 --> 00:48:44.160
FRANCESCO: Well, you can
look at the stats.

00:48:44.160 --> 00:48:48.330
You can not, for now, v1, see
a particular message, what

00:48:48.330 --> 00:48:49.550
happened to it.

00:48:49.550 --> 00:48:52.110
We're thinking to extend this,
and so that if you could put

00:48:52.110 --> 00:48:53.030
the message ID--

00:48:53.030 --> 00:48:55.640
which is what we return
in the response code--

00:48:55.640 --> 00:48:58.900
and look what happened to the
lifetime of this message.

00:48:58.900 --> 00:49:01.220
But for v1, you just see the
number of total throttled.

00:49:01.220 --> 00:49:04.920
But as I said, throttled
messages happen only to very

00:49:04.920 --> 00:49:06.935
small, super-powered users.

00:49:06.935 --> 00:49:07.370
AUDIENCE: OK.

00:49:07.370 --> 00:49:08.472
Thank you.

00:49:08.472 --> 00:49:10.400
FRANCESCO: Cheers.

00:49:10.400 --> 00:49:13.940
AUDIENCE: Are there any
limitations around hardware

00:49:13.940 --> 00:49:16.570
profiles, like a
Google-authorized Android

00:49:16.570 --> 00:49:19.570
hardware device versus I take
the open-source version of

00:49:19.570 --> 00:49:23.730
Android, do a build, and put
it on some independent

00:49:23.730 --> 00:49:25.200
hardware profile.

00:49:25.200 --> 00:49:28.040
Will this still work?

00:49:28.040 --> 00:49:29.590
FRANCESCO: This works on
any device that has

00:49:29.590 --> 00:49:30.942
the GMS core APK.

00:49:35.010 --> 00:49:37.920
AUDIENCE: If I have a really
large number of messages to

00:49:37.920 --> 00:49:40.780
send, is it possible to batch
a bunch of messages for

00:49:40.780 --> 00:49:43.790
different destinations in
a single service call?

00:49:43.790 --> 00:49:46.760
FRANCESCO: We don't have
localization API to offer.

00:49:46.760 --> 00:49:49.050
This should be done by your
server that knows what you

00:49:49.050 --> 00:49:50.300
want to deliver.

00:49:53.750 --> 00:49:56.370
AUDIENCE: Is there a way to know
whether the message is

00:49:56.370 --> 00:50:01.240
throttled or saved
and not sent?

00:50:01.240 --> 00:50:02.350
FRANCESCO: Can you
repeat, please?

00:50:02.350 --> 00:50:05.230
AUDIENCE: Is there a way for my
server to know whether the

00:50:05.230 --> 00:50:09.190
message is throttled
or not sent?

00:50:09.190 --> 00:50:09.630
FRANCESCO: Not yet.

00:50:09.630 --> 00:50:12.690
As I was saying before, you can
see how many messages have

00:50:12.690 --> 00:50:15.130
been throttled or stored,
whatever.

00:50:15.130 --> 00:50:19.160
But for now, for a particular
message, we don't offer yet

00:50:19.160 --> 00:50:20.220
that trace.

00:50:20.220 --> 00:50:21.280
It's coming.

00:50:21.280 --> 00:50:24.150
AUDIENCE: OK.

00:50:24.150 --> 00:50:24.340
AUDIENCE: Hi.

00:50:24.340 --> 00:50:27.800
In your server code example, you
showed a bunch of Device

00:50:27.800 --> 00:50:29.640
IDs that would get sent.

00:50:29.640 --> 00:50:32.640
Is that required, or if the
devices are registering with

00:50:32.640 --> 00:50:35.660
GCM, can you just not have
it broadcast to all the

00:50:35.660 --> 00:50:37.050
registered devices?

00:50:37.050 --> 00:50:39.830
FRANCESCO: Right, the
Registration IDs list allows

00:50:39.830 --> 00:50:42.480
you to specify 1 up
to 1000 devices.

00:50:42.480 --> 00:50:44.940
You have to say which device
you want to hit.

00:50:44.940 --> 00:50:48.110
So you can put 1 or 1,000.

00:50:48.110 --> 00:50:49.690
I mean 2, 3, whatever.

00:50:49.690 --> 00:50:51.580
AUDIENCE: So, but you have
to put at least one?

00:50:51.580 --> 00:50:53.990
You can't just say, all
registered devices will get

00:50:53.990 --> 00:50:54.630
notified, right?

00:50:54.630 --> 00:50:56.360
FRANCESCO: OK, so no.

00:50:56.360 --> 00:50:58.880
We didn't offer a broadcast
feature.

00:50:58.880 --> 00:51:01.000
That's what you want, is like
send to all [INAUDIBLE].

00:51:01.000 --> 00:51:03.980
As I was saying to one of the
first questions, it's a very

00:51:03.980 --> 00:51:05.340
dangerous feature for
us to provide.

00:51:05.340 --> 00:51:07.250
Because if abused--

00:51:07.250 --> 00:51:08.318
you know.

00:51:08.318 --> 00:51:09.568
AUDIENCE: I see.

00:51:12.110 --> 00:51:14.940
AUDIENCE: So you mentioned
Google services use this to

00:51:14.940 --> 00:51:15.650
deliver messages.

00:51:15.650 --> 00:51:18.090
Does the Google Talk
app use this to

00:51:18.090 --> 00:51:19.750
deliver instant messages?

00:51:19.750 --> 00:51:21.770
FRANCESCO: Google Talk
application--

00:51:21.770 --> 00:51:26.430
it uses this channel, definitely
for down delivery.

00:51:26.430 --> 00:51:29.960
And use also this channel
for upstream delivery.

00:51:29.960 --> 00:51:31.780
Yes, it's the same channel.

00:51:31.780 --> 00:51:35.630
AUDIENCE: So they use Cloud
to Device Messaging?

00:51:35.630 --> 00:51:37.320
FRANCESCO: The next version that
we're going to be using

00:51:37.320 --> 00:51:39.930
is Cloud to Device Messaging
like everyone else.

00:51:39.930 --> 00:51:44.460
Talk, right now, it has its
own channel inside this

00:51:44.460 --> 00:51:45.710
connection.

00:51:47.920 --> 00:51:50.730
AUDIENCE: Will this work
on a Wi-Fi only device?

00:51:50.730 --> 00:51:51.160
FRANCESCO: Excuse me?

00:51:51.160 --> 00:51:53.890
AUDIENCE: Will this work
on a Wi-Fi only device?

00:51:53.890 --> 00:51:55.000
FRANCESCO: Yes, of course.

00:51:55.000 --> 00:51:56.250
It actually works faster.

00:52:00.540 --> 00:52:04.010
Well, if you guys have more
offline questions, I can take

00:52:04.010 --> 00:52:05.590
them in the office
hours upstairs

00:52:05.590 --> 00:52:07.100
in the Android section.

00:52:07.100 --> 00:52:08.350
Thank you.

