WEBVTT
Kind: captions
Language: en

00:00:00.500 --> 00:00:03.660
What I want you to attempt to
do is given an arbitrary list--

00:00:03.660 --> 00:00:06.030
I made a particular example
of an arbitrary list right

00:00:06.030 --> 00:00:09.880
here-- write a function that
sorts that arbitrary list.

00:00:09.880 --> 00:00:12.340
So maybe you call
your function My Sort,

00:00:12.340 --> 00:00:13.670
you can call it whatever.

00:00:13.670 --> 00:00:19.800
What I want is after I call
My Sort on a list, the list

00:00:19.800 --> 00:00:21.130
itself gets resorted.

00:00:21.130 --> 00:00:25.080
So I don't want My Sort to
return a copy of the list.

00:00:25.080 --> 00:00:29.710
I want, after I call My Sort
on a, if I then refer to a,

00:00:29.710 --> 00:00:33.920
if let's say I do print a,
then that will literally

00:00:33.920 --> 00:00:36.270
return a sorted version of a.

00:00:36.270 --> 00:00:40.110
Or I should say it will return
a, but now a itself is sorted,

00:00:40.110 --> 00:00:43.090
or the list that a is
referring to is now sorted.

00:00:43.090 --> 00:00:45.590
So it would now
look like this. a

00:00:45.590 --> 00:00:51.380
would now look like
1, 2, 3, 5, 7, 8.

00:00:51.380 --> 00:00:53.510
And you might say, wait
Sal, that's very easy,

00:00:53.510 --> 00:00:55.690
there is already a sort
function in Python.

00:00:55.690 --> 00:00:59.770
You literally can
call a dot sort,

00:00:59.770 --> 00:01:02.750
and that will sort a
in place just the way

00:01:02.750 --> 00:01:03.921
I've asked you to do.

00:01:03.921 --> 00:01:05.379
And when I say in
place, I'm saying

00:01:05.379 --> 00:01:08.192
it's actually going to
work on the actual list.

00:01:08.192 --> 00:01:10.650
It's not going to create a copy
of the list that is sorted.

00:01:10.650 --> 00:01:14.420
It's actually going to work
in place on that actual list.

00:01:14.420 --> 00:01:17.550
And a sort does this, but I
don't want you to use that.

00:01:17.550 --> 00:01:18.780
So let's cross this off.

00:01:18.780 --> 00:01:21.460
The whole point of
this is to learn just

00:01:21.460 --> 00:01:25.255
to kind of try our best to
write our own sorting function.

00:01:25.255 --> 00:01:26.880
What you're going to
see, and hopefully

00:01:26.880 --> 00:01:29.200
appreciate as we go deeper
and deeper into this, is it

00:01:29.200 --> 00:01:32.320
there's many, many, many,
many ways to sort things.

00:01:32.320 --> 00:01:37.460
And sorting is really a good
way to think about how good

00:01:37.460 --> 00:01:40.700
a function, and we'll start
talking about algorithms,

00:01:40.700 --> 00:01:43.660
how good a process is,
or how fast a process is,

00:01:43.660 --> 00:01:47.090
or how efficient a process
is, at doing something.

00:01:47.090 --> 00:01:48.430
So I'll leave you there.

00:01:48.430 --> 00:01:49.890
Try to sort this.

00:01:49.890 --> 00:01:53.100
In the next video, I'll try
to outline an algorithm, which

00:01:53.100 --> 00:01:55.660
is really just a process
for doing something.

00:01:55.660 --> 00:01:58.040
I'll outline an
algorithm that's kind

00:01:58.040 --> 00:01:59.520
of an intuitive
way to sort things.

00:01:59.520 --> 00:02:01.478
It's not the most efficient
way to sort things.

00:02:01.478 --> 00:02:06.335
And then after that,
I'll try my best try

00:02:06.335 --> 00:02:11.272
at actually writing that
algorithm in a Python program.

