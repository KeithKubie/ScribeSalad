WEBVTT
Kind: captions
Language: en

00:00:00.667 --> 00:00:01.868
Wilkerson:
Okay.

00:00:01.868 --> 00:00:06.534
I'm supposed
to start talking now.

00:00:06.534 --> 00:00:08.601
I'm Daniel
Shawcross Wilkerson.

00:00:08.601 --> 00:00:10.400
I'm here to speak to you

00:00:10.400 --> 00:00:13.000
about
distributed transactions

00:00:13.000 --> 00:00:15.400
for Google App Engine.

00:00:18.968 --> 00:00:21.000
Worked with several
really amazing,

00:00:21.000 --> 00:00:22.968
first-rate people
on this project,

00:00:22.968 --> 00:00:24.400
and what I can't stand

00:00:24.400 --> 00:00:27.267
on my short list of things

00:00:27.267 --> 00:00:28.701
I really can't stand
about the media

00:00:28.701 --> 00:00:33.067
is this myth
of the lone scientist,

00:00:33.067 --> 00:00:35.701
you know, working alone
with his laboratory,

00:00:35.701 --> 00:00:38.601
the lone genius coming up
with something amazing.

00:00:38.601 --> 00:00:40.033
Most things worth doing

00:00:40.033 --> 00:00:41.601
get done by a team.

00:00:41.601 --> 00:00:42.968
I would like the media,

00:00:42.968 --> 00:00:43.968
anyone watching this,

00:00:43.968 --> 00:00:45.667
to please
start acknowledging that

00:00:45.667 --> 00:00:48.701
when you write articles.

00:00:48.701 --> 00:00:51.801
Simon Goldsmith is
a very good friend of mine

00:00:51.801 --> 00:00:53.267
from Berkeley.

00:00:53.267 --> 00:00:54.968
He now works at Coverity.

00:00:54.968 --> 00:00:56.400
A very smart guy

00:00:56.400 --> 00:00:58.000
and very humble.

00:00:58.000 --> 00:01:01.067
Robert Johnson is a professor
at Stony Brook.

00:01:01.067 --> 00:01:02.601
Another friend of mine
from Berkeley.

00:01:02.601 --> 00:01:04.167
He helped us greatly simplify

00:01:04.167 --> 00:01:05.767
the locking protocol.

00:01:05.767 --> 00:01:08.868
Erick Armbrust at Google

00:01:08.868 --> 00:01:11.968
is a really enthusiastic
engineer, great guy,

00:01:11.968 --> 00:01:13.334
who found a bug.

00:01:13.334 --> 00:01:14.901
Found an optimization.

00:01:14.901 --> 00:01:16.901
And also did this little,
minor thing.

00:01:16.901 --> 00:01:19.634
He implemented it.

00:01:19.634 --> 00:01:21.334
That's a joke.

00:01:21.334 --> 00:01:22.834
Ryan Barrett is right here.

00:01:22.834 --> 00:01:24.267
Where is Ryan?

00:01:24.267 --> 00:01:25.234
Ryan, raise your hand,

00:01:25.234 --> 00:01:26.234
'cause I can't see you.

00:01:26.234 --> 00:01:27.234
There he is.

00:01:27.234 --> 00:01:30.000
Ryan Barrett is at Google

00:01:30.000 --> 00:01:31.834
on the App Engine team.

00:01:31.834 --> 00:01:32.834
He is, I believe,

00:01:32.834 --> 00:01:33.834
in charge of the interface

00:01:33.834 --> 00:01:35.167
between App Engine
and BigTable.

00:01:35.167 --> 00:01:39.400
And just a very generous guy
with his time

00:01:39.400 --> 00:01:41.300
when he knows someone's
trying to do something

00:01:41.300 --> 00:01:42.300
with App Engine.

00:01:42.300 --> 00:01:43.734
A very humble guy.

00:01:43.734 --> 00:01:45.434
A very friendly guy.

00:01:45.434 --> 00:01:46.834
And Erick as well.

00:01:46.834 --> 00:01:48.300
Great guys at Google.

00:01:48.300 --> 00:01:51.167
Let's see.

00:01:51.167 --> 00:01:53.968
You'll notice
my corporate affiliation.

00:01:53.968 --> 00:01:56.267
It's unemployed.

00:01:56.267 --> 00:01:59.100
Case anyone cares
to help remedy that,

00:01:59.100 --> 00:02:00.267
let me know.

00:02:00.267 --> 00:02:02.767
Afterward, Tony and I
may do a startup,

00:02:02.767 --> 00:02:03.934
but if that collapses,

00:02:03.934 --> 00:02:06.234
then I'll be talking
to you guys.

00:02:06.234 --> 00:02:08.767
So this
is a preliminary report.

00:02:08.767 --> 00:02:11.234
What does that mean?

00:02:11.234 --> 00:02:14.200
We thought we had this thing
nailed down months ago,

00:02:14.200 --> 00:02:16.934
and then we just kept
finding ways to improve it.

00:02:16.934 --> 00:02:19.634
And, you know, you can't
resist those things.

00:02:19.634 --> 00:02:22.334
Once you find one,
you have to do it.

00:02:22.334 --> 00:02:23.801
The only problem
is once you prove it,

00:02:23.801 --> 00:02:25.167
you have to prove it
correct again.

00:02:25.167 --> 00:02:26.334
And as we'll see,

00:02:26.334 --> 00:02:28.000
much of the challenge
to this algorithm--

00:02:28.000 --> 00:02:29.534
It's a very
simple looking algorithm.

00:02:29.534 --> 00:02:30.868
Don't let that fool you.

00:02:30.868 --> 00:02:31.901
Distributed algorithms

00:02:31.901 --> 00:02:33.934
and those involving
multi-threading

00:02:33.934 --> 00:02:36.167
and distributed...together

00:02:36.167 --> 00:02:39.033
are very, very difficult
to debug.

00:02:39.033 --> 00:02:40.634
They're basically
impossible to debug.

00:02:40.634 --> 00:02:41.834
You have to prove them correct.

00:02:41.834 --> 00:02:44.501
So this isn't so much
the algorithm,

00:02:44.501 --> 00:02:46.300
but the algorithm plus
proof of correctness.

00:02:46.300 --> 00:02:48.601
Yesterday I was
really checking it

00:02:48.601 --> 00:02:50.067
to make sure
it was really right

00:02:50.067 --> 00:02:51.534
and didn't have any extra parts

00:02:51.534 --> 00:02:53.601
and the proof was tight
and the algorithm was tight,

00:02:53.601 --> 00:02:54.767
and I'm very convinced now.

00:02:54.767 --> 00:02:56.834
But we didn't want
to release it to you

00:02:56.834 --> 00:02:59.400
till we, you know,
all looked at it

00:02:59.400 --> 00:03:00.634
and made sure
that was the case.

00:03:00.634 --> 00:03:01.901
So we'll be releasing this

00:03:01.901 --> 00:03:04.501
probably in the next month
or so--the paper--

00:03:04.501 --> 00:03:06.000
and Erick
has been following along

00:03:06.000 --> 00:03:07.100
with an implementation

00:03:07.100 --> 00:03:08.567
as we've been
revising the paper,

00:03:08.567 --> 00:03:09.667
and we hope to get that out

00:03:09.667 --> 00:03:11.200
somewhere around
the next month or so.

00:03:11.200 --> 00:03:12.901
Sorry, Erick,
for inventing the vaporware

00:03:12.901 --> 00:03:14.200
and signing you up
for something

00:03:14.200 --> 00:03:15.200
without asking you.

00:03:15.200 --> 00:03:18.234
Erick is away at a wedding

00:03:18.234 --> 00:03:19.234
and Simon's in Europe

00:03:19.234 --> 00:03:20.501
and Rob's in New York,

00:03:20.501 --> 00:03:23.367
but Ryan is here
and I am here.

00:03:23.367 --> 00:03:25.434
What is the fundamental concern

00:03:25.434 --> 00:03:27.567
that hits most engineers

00:03:27.567 --> 00:03:28.968
when they start
writing software?

00:03:28.968 --> 00:03:30.534
There are many concerns,

00:03:30.534 --> 00:03:31.734
but two of the fundamental ones

00:03:31.734 --> 00:03:32.901
that engineers run into

00:03:32.901 --> 00:03:35.400
is correctness
and performance.

00:03:35.400 --> 00:03:39.133
Correctness.

00:03:39.133 --> 00:03:41.133
Is the output
what you really wanted?

00:03:41.133 --> 00:03:42.133
Performance.

00:03:42.133 --> 00:03:44.000
How much did that cost?

00:03:44.000 --> 00:03:45.734
There's no
getting around this.

00:03:45.734 --> 00:03:47.234
This is a timeless problem.

00:03:47.234 --> 00:03:49.968
What I don't like
about most talks

00:03:49.968 --> 00:03:51.133
about distributed computing

00:03:51.133 --> 00:03:55.234
or transactions or databases--

00:03:55.234 --> 00:03:56.234
anything--systems

00:03:56.234 --> 00:03:58.067
or almost
any talk you go to

00:03:58.067 --> 00:03:59.100
in computer science,

00:03:59.100 --> 00:04:00.367
they'll start talking about,

00:04:00.367 --> 00:04:01.901
"Wouldn't it be cool
if we could enforce

00:04:01.901 --> 00:04:03.200
the isolation
of these objects,"

00:04:03.200 --> 00:04:05.067
or, "If we could do
these transactions faster..."

00:04:05.067 --> 00:04:06.667
And it's like,
"Why do I need transactions?

00:04:06.667 --> 00:04:07.901
"Why would I want them?

00:04:07.901 --> 00:04:09.834
"Do I want transactions?
No, they're annoying.

00:04:09.834 --> 00:04:11.467
"I don't want
to deal with transactions.

00:04:11.467 --> 00:04:13.567
I just want to write my code."
Right?

00:04:13.567 --> 00:04:15.968
So when
I'm presenting something,

00:04:15.968 --> 00:04:18.234
you got to start
with what you actually want.

00:04:18.234 --> 00:04:19.834
So instead of a script
going forward,

00:04:19.834 --> 00:04:20.901
this is more like a makefile

00:04:20.901 --> 00:04:22.467
going backward
from the ultimate goal.

00:04:22.467 --> 00:04:24.534
The ultimate goal
is I have a program

00:04:24.534 --> 00:04:27.501
that I would like to run.

00:04:27.501 --> 00:04:31.067
And it should be correct
to do what I want,

00:04:31.067 --> 00:04:32.501
and it shouldn't cost very much.

00:04:32.501 --> 00:04:35.267
And I think basically all talks
should start this way.

00:04:35.267 --> 00:04:38.100
But from here we can motivate
why you need transactions.

00:04:38.100 --> 00:04:39.868
And Brian said,

00:04:39.868 --> 00:04:41.701
"You know,
people at this talk,

00:04:41.701 --> 00:04:43.501
"they're really gonna want
to see the details.

00:04:43.501 --> 00:04:45.067
"They're gonna
want to know the details

00:04:45.067 --> 00:04:46.100
of how this thing works."

00:04:46.100 --> 00:04:47.267
I go to a lot
of technical talks,

00:04:47.267 --> 00:04:48.434
and I'm not an idiot.

00:04:48.434 --> 00:04:50.033
And I've been to
a lot of talks at Berkeley

00:04:50.033 --> 00:04:52.801
where some
incredibly detailed thing

00:04:52.801 --> 00:04:54.334
that I can't follow
after two minutes,

00:04:54.334 --> 00:04:55.400
and then I have to sit there,

00:04:55.400 --> 00:04:56.501
'cause I can't leave the room

00:04:56.501 --> 00:04:57.567
'cause it would be impolite

00:04:57.567 --> 00:04:58.767
for another 40 minutes,

00:04:58.767 --> 00:05:00.901
and, "oh, my god,
I'm gonna fall asleep."

00:05:00.901 --> 00:05:03.200
I don't want to give
a talk like that.

00:05:03.200 --> 00:05:04.601
So the details
of this algorithm,

00:05:04.601 --> 00:05:06.267
they're subtle,
the proof is very subtle.

00:05:06.267 --> 00:05:07.334
I'm not gonna pretend

00:05:07.334 --> 00:05:08.667
to give it to you
during this talk.

00:05:08.667 --> 00:05:12.300
I'm gonna tell you

00:05:12.300 --> 00:05:13.300
why you should care.

00:05:13.300 --> 00:05:14.701
You can read it yourself

00:05:14.701 --> 00:05:16.133
or you can trust us.

00:05:16.133 --> 00:05:18.901
The implementation
will be open source.

00:05:18.901 --> 00:05:20.501
But hopefully
what you'll get out of this

00:05:20.501 --> 00:05:22.033
is why do you care
about transactions,

00:05:22.033 --> 00:05:23.901
why do you need them
for distributed computing,

00:05:23.901 --> 00:05:25.133
and why this is the future

00:05:25.133 --> 00:05:26.934
and you absolutely cannot
avoid learning about it.

00:05:26.934 --> 00:05:28.734
There's no more avoiding
learning about this.

00:05:28.734 --> 00:05:30.968
By the way,
this talk was originally

00:05:30.968 --> 00:05:32.534
written to be, like,
about 25 minutes,

00:05:32.534 --> 00:05:34.601
'cause I gave it
at CodeCon 2009.

00:05:34.601 --> 00:05:35.934
If you guys never been
to CodeCon,

00:05:35.934 --> 00:05:36.934
be sure to go next year.

00:05:36.934 --> 00:05:37.934
It's more like a party.

00:05:37.934 --> 00:05:39.767
It's a un-conference.

00:05:39.767 --> 00:05:41.634
It's kind of the opposite

00:05:41.634 --> 00:05:43.033
of how managed this is.

00:05:43.033 --> 00:05:45.667
A lot of good stuff is there.

00:05:45.667 --> 00:05:47.534
Most people
don't hear about it.

00:05:47.534 --> 00:05:50.033
So if I'm giving a talk

00:05:50.033 --> 00:05:52.000
and I've got it designed
for 25 minutes

00:05:52.000 --> 00:05:53.767
and I have 60 minutes,

00:05:53.767 --> 00:05:55.234
what I'd really like
you guys to do

00:05:55.234 --> 00:05:57.033
is just raise your hand
if you have a question.

00:05:57.033 --> 00:05:58.834
And I'll probably wait
to the end of my sentence

00:05:58.834 --> 00:06:00.100
or the end of my paragraph,

00:06:00.100 --> 00:06:01.834
and then I'll probably
take your question.

00:06:01.834 --> 00:06:03.567
If your question
is completely off the wall,

00:06:03.567 --> 00:06:05.534
then I'm gonna maybe say,
"Well, let's prune that,

00:06:05.534 --> 00:06:06.667
or talk about it offline,"

00:06:06.667 --> 00:06:07.667
but go ahead and feel free.

00:06:07.667 --> 00:06:09.801
I can't stand sitting in a talk

00:06:09.801 --> 00:06:10.901
not knowing what's going on,

00:06:10.901 --> 00:06:11.901
so raise your hand.

00:06:11.901 --> 00:06:13.467
When you do it,
you all look very small,

00:06:13.467 --> 00:06:14.767
so raise your hand high
like that.

00:06:14.767 --> 00:06:16.200
You know, don't do this,

00:06:16.200 --> 00:06:18.200
'cause I'm wondering,
are you fixing your hair?

00:06:18.200 --> 00:06:19.601
But feel free. Please.

00:06:19.601 --> 00:06:24.367
It's much more fun
to have a conversation.

00:06:24.367 --> 00:06:27.334
Correctness
is our primary concern,

00:06:27.334 --> 00:06:29.234
and it requires invariants.

00:06:29.234 --> 00:06:30.467
A lot of people
who didn't spend

00:06:30.467 --> 00:06:32.033
a lot of their time
in a computer science

00:06:32.033 --> 00:06:33.033
or math department

00:06:33.033 --> 00:06:34.567
don't think about invariants,

00:06:34.567 --> 00:06:36.033
but if you really want
to think about

00:06:36.033 --> 00:06:37.601
the correctness
of your code,

00:06:37.601 --> 00:06:39.267
especially in domains

00:06:39.267 --> 00:06:40.734
where it's getting
harder and harder

00:06:40.734 --> 00:06:42.300
to debug code,

00:06:42.300 --> 00:06:43.968
distributed parallel stuff,

00:06:43.968 --> 00:06:46.367
it's just impossible
to debug it.

00:06:46.367 --> 00:06:47.367
'Cause you may have a bug,

00:06:47.367 --> 00:06:48.801
and it's just unreproducible.

00:06:48.801 --> 00:06:49.968
How are you gonna debug it?

00:06:49.968 --> 00:06:51.400
You're not gonna run it
in debugger.

00:06:51.400 --> 00:06:53.400
Unless you've got
some really clever--

00:06:53.400 --> 00:06:54.968
There are some
clever infrastructures

00:06:54.968 --> 00:06:56.801
people build to try
to make them reproducible,

00:06:56.801 --> 00:07:00.701
but then
you got to learn that.

00:07:00.701 --> 00:07:03.734
So the way to think about
the correctness of your code is,

00:07:03.734 --> 00:07:06.167
what doesn't change while
all this stuff is changing?

00:07:06.167 --> 00:07:07.200
I've heard someone say,

00:07:07.200 --> 00:07:08.701
"The essence of software
has changed."

00:07:08.701 --> 00:07:10.100
So you want stuff to happen,

00:07:10.100 --> 00:07:11.100
but you also want

00:07:11.100 --> 00:07:12.834
some other stuff
to not happen.

00:07:12.834 --> 00:07:16.400
So computers make it easy
to say what you want

00:07:16.400 --> 00:07:17.400
and have it happen.

00:07:17.400 --> 00:07:18.501
They also make it real easy

00:07:18.501 --> 00:07:19.834
to say what you really
did not want

00:07:19.834 --> 00:07:20.834
and have it happen.

00:07:20.834 --> 00:07:22.567
This is
a fundamental problem.

00:07:22.567 --> 00:07:25.033
So invariants are sentences
that are always true.

00:07:25.033 --> 00:07:28.267
they do not change
when all else is changing.

00:07:28.267 --> 00:07:30.701
I should have put
one more thing on this slide.

00:07:30.701 --> 00:07:33.067
You decide
what should not move.

00:07:33.067 --> 00:07:34.968
You know, my data structures
maybe have invariants.

00:07:34.968 --> 00:07:35.968
I'll give a few examples.

00:07:35.968 --> 00:07:36.968
You initialize them

00:07:36.968 --> 00:07:37.968
when you construct

00:07:37.968 --> 00:07:39.501
your data structures
or your objects.

00:07:39.501 --> 00:07:40.501
You maintain them

00:07:40.501 --> 00:07:42.234
during operation
as you do things.

00:07:42.234 --> 00:07:43.400
Okay?

00:07:43.400 --> 00:07:44.834
And the third thing
you want to do is,

00:07:44.834 --> 00:07:46.300
you want to pick invariants

00:07:46.300 --> 00:07:48.934
whereby you can insure
the correctness of your code

00:07:48.934 --> 00:07:50.534
if you know
they're always true.

00:07:50.534 --> 00:07:51.834
And you'll see
what I mean by that

00:07:51.834 --> 00:07:53.067
when you see the examples.

00:07:53.067 --> 00:07:54.901
If you aren't thinking
in terms of invariants,

00:07:54.901 --> 00:07:55.901
start now.

00:07:55.901 --> 00:07:57.200
Software is becoming

00:07:57.200 --> 00:07:59.367
more and more and more critical
to our infrastructure.

00:07:59.367 --> 00:08:02.067
Bugs are just more and more
and more devastating.

00:08:02.067 --> 00:08:03.934
People die now
'cause of software bugs.

00:08:03.934 --> 00:08:05.133
Okay? It's not a joke.

00:08:05.133 --> 00:08:07.634
So you have to start
thinking about this.

00:08:07.634 --> 00:08:09.734
If you get nothing else
out of my talk,

00:08:09.734 --> 00:08:10.734
remember this--

00:08:10.734 --> 00:08:12.767
invariants
and code correctness.

00:08:12.767 --> 00:08:14.567
Here's an example invariant.

00:08:14.567 --> 00:08:16.234
You have
a doubly-linked list.

00:08:16.234 --> 00:08:18.467
This example
is due to Scott McPeak.

00:08:18.467 --> 00:08:20.067
People think you can't do

00:08:20.067 --> 00:08:21.501
automated
proofs of correctness,

00:08:21.501 --> 00:08:22.501
but you can now.

00:08:22.501 --> 00:08:23.701
His PhD thesis at Berkeley

00:08:23.701 --> 00:08:27.234
was a C compiler

00:08:27.234 --> 00:08:29.467
that could prove
some memory drivers

00:08:29.467 --> 00:08:31.133
in Linux memory save.

00:08:31.133 --> 00:08:34.200
Some, sorry, driver's
memory save in Linux.

00:08:34.200 --> 00:08:37.434
It's the sort of thing
you should start thinking about.

00:08:37.434 --> 00:08:39.067
This is really
a talk about correctness.

00:08:39.067 --> 00:08:43.300
So the invariant that he liked
to give a demo of

00:08:43.300 --> 00:08:45.767
was a doubly-linked list.

00:08:45.767 --> 00:08:48.133
You either want x-&gt;next
to be null,

00:08:48.133 --> 00:08:49.400
or you want x-&gt;next-&gt;prev

00:08:49.400 --> 00:08:50.400
to equal x.

00:08:50.400 --> 00:08:52.367
If that is ever not true,

00:08:52.367 --> 00:08:53.567
you've got a problem.

00:08:53.567 --> 00:08:56.167
Further, you don't
just want it to be true.

00:08:56.167 --> 00:08:58.133
You want--If it's
a multi-threaded program--

00:08:58.133 --> 00:09:00.634
Sometimes you have
to modify your list, right?

00:09:00.634 --> 00:09:02.267
You have to add an element

00:09:02.267 --> 00:09:04.267
in the middle of your list
or at the end.

00:09:04.267 --> 00:09:06.467
Temporarily,
this invariant may be violated.

00:09:06.467 --> 00:09:07.834
What you really want

00:09:07.834 --> 00:09:09.434
is no other thread can see that,

00:09:09.434 --> 00:09:12.801
and you want that when
you violate the invariant,

00:09:12.801 --> 00:09:14.801
you don't end up
in this violated state,

00:09:14.801 --> 00:09:16.200
that you get
to another good state.

00:09:16.200 --> 00:09:18.934
Those are
isolation and atomicity,

00:09:18.934 --> 00:09:20.267
which are
two properties we want

00:09:20.267 --> 00:09:21.467
of databases, right?

00:09:21.467 --> 00:09:23.300
But it's not just about
databases anymore.

00:09:23.300 --> 00:09:24.534
Transactions and correctness,

00:09:24.534 --> 00:09:26.100
it's not just about
databases anymore.

00:09:26.100 --> 00:09:27.934
It's about
all of your software.

00:09:27.934 --> 00:09:30.534
Many other data structures
have similar invariants.

00:09:30.534 --> 00:09:34.501
You know,
"Don't turn off your computer

00:09:34.501 --> 00:09:35.734
"without shutting it down,

00:09:35.734 --> 00:09:37.501
'cause your file system
could get corrupted."

00:09:37.501 --> 00:09:38.634
Boy,
that was a good idea.

00:09:38.634 --> 00:09:40.167
Let's design
our software that way.

00:09:40.167 --> 00:09:42.501
No. Let's not
do that anymore, okay?

00:09:42.501 --> 00:09:44.534
It's because they're missing

00:09:44.534 --> 00:09:46.801
the transaction semantics
in the file system.

00:09:46.801 --> 00:09:48.300
Here's another invariant.

00:09:48.300 --> 00:09:49.300
Conservation of money.

00:09:49.300 --> 00:09:50.400
You're implementing a bank.

00:09:50.400 --> 00:09:52.701
When you transfer money
from Alice to Bob,

00:09:52.701 --> 00:09:54.334
no money is transferred,
right?

00:09:54.334 --> 00:09:55.767
You're just subtracting
an adding.

00:09:55.767 --> 00:09:57.934
There's an illusion
of transferring an object,

00:09:57.934 --> 00:10:00.133
but why does
that illusion persist?

00:10:00.133 --> 00:10:01.634
The illusion persists

00:10:01.634 --> 00:10:04.067
because there are invariants
that are maintained.

00:10:04.067 --> 00:10:06.834
For example, the sum
of all money does not change.

00:10:06.834 --> 00:10:08.501
If money goes away somewhere,

00:10:08.501 --> 00:10:09.834
it has to show up
somewhere else.

00:10:09.834 --> 00:10:10.934
Local conservation of money

00:10:10.934 --> 00:10:12.300
is what makes money work.

00:10:12.300 --> 00:10:13.467
If we could just invent money,

00:10:13.467 --> 00:10:15.200
it wouldn't be money, right?

00:10:15.200 --> 00:10:16.801
All right.

00:10:16.801 --> 00:10:19.434
We'll get back to that
invariant, that example.

00:10:19.434 --> 00:10:20.634
Scalability.

00:10:20.634 --> 00:10:22.667
We'd really like
our software to scale now.

00:10:22.667 --> 00:10:23.834
And that's why, you know,

00:10:23.834 --> 00:10:24.834
lots of people come

00:10:24.834 --> 00:10:27.033
to Google App Engine
conferences.

00:10:27.033 --> 00:10:29.467
It's the whole thing
Google does is,

00:10:29.467 --> 00:10:30.634
"Let's do all this cool stuff

00:10:30.634 --> 00:10:31.634
and make it scalable."

00:10:31.634 --> 00:10:32.968
This is a great idea,

00:10:32.968 --> 00:10:36.200
but you're not gonna do it
with a big computer.

00:10:36.200 --> 00:10:37.667
Gee, Google must just have

00:10:37.667 --> 00:10:39.300
this really big computer,
right?

00:10:39.300 --> 00:10:40.567
That's how they do all that.

00:10:40.567 --> 00:10:42.834
They just have this huge,
honking computer.

00:10:42.834 --> 00:10:43.901
No, they don't.

00:10:43.901 --> 00:10:45.934
They have
a deconstructed semantics.

00:10:45.934 --> 00:10:47.000
They figure out how

00:10:47.000 --> 00:10:48.434
to deconstruct
what they're doing

00:10:48.434 --> 00:10:49.534
so they can spread it out

00:10:49.534 --> 00:10:51.133
over a whole bunch
of little computers.

00:10:51.133 --> 00:10:52.601
There's no way around that.

00:10:52.601 --> 00:10:54.400
There's no such thing
as this mythological,

00:10:54.400 --> 00:10:55.968
big, powerful computer.

00:10:55.968 --> 00:10:59.734
Unbounded
performance scalability.

00:10:59.734 --> 00:11:02.634
The people who are enthusiastic
about App Engine, it's great.

00:11:02.634 --> 00:11:04.067
If you write
your app the right way,

00:11:04.067 --> 00:11:05.968
it just scales and scales
and scales and scales,

00:11:05.968 --> 00:11:06.968
and it just keeps going.

00:11:06.968 --> 00:11:08.534
That's awesome, isn't it?

00:11:08.534 --> 00:11:11.200
And there's only
a finite amount of stuff

00:11:11.200 --> 00:11:12.200
you have to deal with

00:11:12.200 --> 00:11:13.400
to make your app do that,

00:11:13.400 --> 00:11:15.167
but there is some stuff
you have to deal with.

00:11:15.167 --> 00:11:18.601
So the illusion
many of us grew up with,

00:11:18.601 --> 00:11:20.968
you know, I grew up programming
an Atari 800 in BASIC,

00:11:20.968 --> 00:11:23.067
and, you know, you're
programming this computer.

00:11:23.067 --> 00:11:24.067
It does what you want.

00:11:24.067 --> 00:11:25.501
But it was single-threaded.

00:11:25.501 --> 00:11:28.200
It didn't turn itself off
at random times.

00:11:28.200 --> 00:11:29.934
The hardware--
I had one piece of hardware

00:11:29.934 --> 00:11:31.367
and it never failed.

00:11:31.367 --> 00:11:32.701
I suppose it could have.

00:11:32.701 --> 00:11:33.767
But in a big, distributed--

00:11:33.767 --> 00:11:35.234
If your app is scaling

00:11:35.234 --> 00:11:36.767
across this huge data center,

00:11:36.767 --> 00:11:38.200
computers that
are running your app

00:11:38.200 --> 00:11:40.133
will be failing.

00:11:40.133 --> 00:11:43.033
I'm sure there's Google people
here besides Ryan.

00:11:43.033 --> 00:11:45.834
They can confirm that
Google's just losing machines

00:11:45.834 --> 00:11:47.000
every second, probably.

00:11:47.000 --> 00:11:48.534
They're just
losing them constantly.

00:11:48.534 --> 00:11:50.300
Things become disconnected.

00:11:50.300 --> 00:11:51.300
Things go away.

00:11:51.300 --> 00:11:53.701
So distributed machines

00:11:53.701 --> 00:11:55.601
have,
if we can call them that,

00:11:55.601 --> 00:11:56.601
or clusters of machines,

00:11:56.601 --> 00:11:58.100
have the following
characteristics,

00:11:58.100 --> 00:11:59.434
which are very annoying.

00:11:59.434 --> 00:12:01.701
They're not reliable,
as I said.

00:12:01.701 --> 00:12:02.868
They're not serial.

00:12:02.868 --> 00:12:06.167
Many threads
are happening all at once.

00:12:06.167 --> 00:12:09.100
Most people, the way
they write data-structure code,

00:12:09.100 --> 00:12:10.767
if there were two threads
manipulating it,

00:12:10.767 --> 00:12:11.767
it would be a mess.

00:12:11.767 --> 00:12:12.767
You don't want that.

00:12:12.767 --> 00:12:14.000
And they're non-synchronized.

00:12:14.000 --> 00:12:16.167
There's no single ringmaster

00:12:16.167 --> 00:12:17.601
coordinating everything,

00:12:17.601 --> 00:12:19.934
making it all coordinated.

00:12:19.934 --> 00:12:22.300
And not only that,

00:12:22.300 --> 00:12:23.901
there's not even
a global notion of time.

00:12:23.901 --> 00:12:25.601
If you've got
a distributed algorithm,

00:12:25.601 --> 00:12:26.667
and it's got a global notion

00:12:26.667 --> 00:12:27.667
of wall-clock time in it

00:12:27.667 --> 00:12:29.100
in order to insure
its correctness,

00:12:29.100 --> 00:12:30.100
you're gonna have a bug.

00:12:30.100 --> 00:12:31.133
Something's wrong.

00:12:31.133 --> 00:12:32.667
This is the future.

00:12:32.667 --> 00:12:34.067
You might as well learn it.

00:12:34.067 --> 00:12:36.100
This is what
we all have to deal with,

00:12:36.100 --> 00:12:38.467
but it's a finite
problem to deal with.

00:12:38.467 --> 00:12:40.200
Especially if you have...
[clears throat]

00:12:40.200 --> 00:12:42.534
Well, okay, so--shoot.

00:12:42.534 --> 00:12:44.300
I thought the next slide
was something else.

00:12:44.300 --> 00:12:45.534
Okay,
distributed computing

00:12:45.534 --> 00:12:47.000
makes maintaining
invariants hard.

00:12:47.000 --> 00:12:48.634
We have to maintain invariants

00:12:48.634 --> 00:12:49.801
in order to have correctness.

00:12:49.801 --> 00:12:50.801
We want performance,

00:12:50.801 --> 00:12:52.000
unlimited scalability,

00:12:52.000 --> 00:12:53.734
so we need
to distribute this.

00:12:53.734 --> 00:12:56.467
When these two meet,
it's difficult.

00:12:56.467 --> 00:12:57.467
Here's why.

00:12:57.467 --> 00:12:58.767
Alice sends $10 to Bob.

00:12:58.767 --> 00:13:00.334
This time it's $10.
I don't know why.

00:13:00.334 --> 00:13:03.701
Okay, step one,
add $10 to Bob's account.

00:13:03.701 --> 00:13:04.834
Step two...

00:13:04.834 --> 00:13:06.167
Oops,
we didn't get to step two.

00:13:06.167 --> 00:13:07.701
Process times out
and machine crashes.

00:13:07.701 --> 00:13:10.167
$10 is never subtracted
from Alice's account.

00:13:10.167 --> 00:13:11.834
If you're the
federal government,

00:13:11.834 --> 00:13:13.000
this is not a problem,

00:13:13.000 --> 00:13:15.367
'cause you can just
create money,

00:13:15.367 --> 00:13:16.901
as we've noticed recently.

00:13:16.901 --> 00:13:18.200
They can create a lot of money.

00:13:18.200 --> 00:13:20.367
But most of us are not
the federal government.

00:13:20.367 --> 00:13:22.067
We don't work
for the federal government,

00:13:22.067 --> 00:13:23.968
so we're not allowed
to do that.

00:13:23.968 --> 00:13:26.667
How do we solve this problem?

00:13:26.667 --> 00:13:27.701
Transactions.

00:13:27.701 --> 00:13:29.767
Transactions are where

00:13:29.767 --> 00:13:31.801
maintaining
invariants correctness

00:13:31.801 --> 00:13:33.868
meets unlimited scalability.

00:13:33.868 --> 00:13:35.801
It's called a "good" state,

00:13:35.801 --> 00:13:38.334
a state where all of your
invariants are satisfied.

00:13:38.334 --> 00:13:39.534
Your program
is in a good state.

00:13:39.534 --> 00:13:41.567
It has all the properties
the user wants.

00:13:41.567 --> 00:13:42.834
Good. Leave it that way.

00:13:42.834 --> 00:13:43.934
Don't change anything.

00:13:43.934 --> 00:13:46.133
If the user says,
"I'd like you

00:13:46.133 --> 00:13:48.400
to compute
a service for me," no.

00:13:48.400 --> 00:13:50.033
Don't change anything.

00:13:50.033 --> 00:13:51.634
That'll preserve correctness.

00:13:51.634 --> 00:13:52.667
The only problem is,

00:13:52.667 --> 00:13:54.100
it won't give you
any performance,

00:13:54.100 --> 00:13:55.300
so in order
to get performance,

00:13:55.300 --> 00:13:57.067
we have to temporarily
violate invariants.

00:13:57.067 --> 00:13:59.367
You know,
we have a data structure.

00:13:59.367 --> 00:14:00.701
It's supposed
to point like this.

00:14:00.701 --> 00:14:02.767
Well, you're gonna
change one pointer,

00:14:02.767 --> 00:14:04.467
then you're gonna
change the next pointer.

00:14:04.467 --> 00:14:06.234
In between,
you've violated the invariant.

00:14:06.234 --> 00:14:08.334
If that state were visible
to someone else,

00:14:08.334 --> 00:14:09.934
that would be bad.

00:14:09.934 --> 00:14:11.934
So what we want to do is,

00:14:11.934 --> 00:14:13.267
we want to have
a set of operations

00:14:13.267 --> 00:14:15.067
that takes us
from one good state

00:14:15.067 --> 00:14:16.667
where all our invariants
are satisfied

00:14:16.667 --> 00:14:17.701
to another good state

00:14:17.701 --> 00:14:20.634
where all our invariants
are satisfied.

00:14:20.634 --> 00:14:21.801
I'm used to thinking this way,

00:14:21.801 --> 00:14:22.934
but maybe some people aren't.

00:14:22.934 --> 00:14:24.367
People talk about
the design space

00:14:24.367 --> 00:14:25.701
or the state space.

00:14:25.701 --> 00:14:28.167
You can imagine all
the variables in your program,

00:14:28.167 --> 00:14:29.467
all the pointers
and everything,

00:14:29.467 --> 00:14:32.234
it's this huge, horrible,
high-dimensional space.

00:14:32.234 --> 00:14:33.801
There are certain islands
in that space

00:14:33.801 --> 00:14:34.801
which are the good points,

00:14:34.801 --> 00:14:35.968
and what you really want to do,

00:14:35.968 --> 00:14:37.567
and everything else
is horrible, right?

00:14:37.567 --> 00:14:38.567
Badness.

00:14:38.567 --> 00:14:40.000
And this space is,
the good set,

00:14:40.000 --> 00:14:41.200
is very non-convex.

00:14:41.200 --> 00:14:44.367
It's very non-local.

00:14:44.367 --> 00:14:45.567
You have to go through badness

00:14:45.567 --> 00:14:46.734
to get to other goodness, okay?

00:14:46.734 --> 00:14:49.834
So there's islands
of good states,

00:14:49.834 --> 00:14:52.100
and you would like to hop
from one island to the other

00:14:52.100 --> 00:14:53.100
and not fall in the ocean.

00:14:53.100 --> 00:14:55.400
If you think that way,

00:14:55.400 --> 00:14:56.667
it's very easy.

00:14:56.667 --> 00:14:59.000
So a transaction
is a set of operations

00:14:59.000 --> 00:15:02.300
to get us from
one good state to another.

00:15:02.300 --> 00:15:05.200
If they satisfy all the
transaction properties, that is.

00:15:05.200 --> 00:15:08.767
You first start hearing
about transactions in school,

00:15:08.767 --> 00:15:11.033
and they say,
"ACID properties. ACID."

00:15:11.033 --> 00:15:12.501
And they say it
over and over and over.

00:15:12.501 --> 00:15:13.634
And they say it in every class.

00:15:13.634 --> 00:15:15.200
You get books on transactions,

00:15:15.200 --> 00:15:17.934
and they'll say--even Gray's
famous book on transactions,

00:15:17.934 --> 00:15:19.501
I actually
read a lot of that.

00:15:19.501 --> 00:15:21.200
He says the ACID properties,

00:15:21.200 --> 00:15:23.067
and then the next page
he says them again.

00:15:23.067 --> 00:15:24.868
Sometimes he says them
twice on the same page.

00:15:24.868 --> 00:15:26.934
Why doesn't he say it
one time, you know?

00:15:26.934 --> 00:15:28.567
And then I started thinking,
you know,

00:15:28.567 --> 00:15:30.267
why are these
four properties enough?

00:15:30.267 --> 00:15:32.400
Like, are these four properties
what we really need?

00:15:32.400 --> 00:15:34.334
I've never seen this
ever written down anywhere,

00:15:34.334 --> 00:15:36.767
so I wrote it down.

00:15:36.767 --> 00:15:40.667
Actually motivate--Why do we
need these four properties?

00:15:40.667 --> 00:15:42.267
If you're hopping
from island to island,

00:15:42.267 --> 00:15:43.667
first of all,
when you hop to an island,

00:15:43.667 --> 00:15:45.067
you'd like
to actually stay there.

00:15:45.067 --> 00:15:46.501
That's called durability.

00:15:46.501 --> 00:15:48.667
It's got to have a big,
fancy, Latin name,

00:15:48.667 --> 00:15:50.501
because we couldn't
explain anything simply.

00:15:50.501 --> 00:15:52.167
I don't know why.

00:15:52.167 --> 00:15:53.167
That's academia.

00:15:53.167 --> 00:15:54.801
So, atomicity.

00:15:54.801 --> 00:15:58.801
We would like it that
you don't fall in the ocean.

00:15:58.801 --> 00:16:00.434
Okay, that's atomicity.

00:16:00.434 --> 00:16:02.434
You either hop there
or you don't.

00:16:02.434 --> 00:16:04.167
It's okay if you try
to hop to an island

00:16:04.167 --> 00:16:05.868
and your plane gets cancelled

00:16:05.868 --> 00:16:07.367
and you stay at home.

00:16:07.367 --> 00:16:09.200
That's okay, 'cause
you're still on an island.

00:16:09.200 --> 00:16:12.100
Isolation is that
nobody else can observe

00:16:12.100 --> 00:16:13.334
your in-between state

00:16:13.334 --> 00:16:15.033
between one island
and the next island.

00:16:15.033 --> 00:16:16.467
These are really
the same property.

00:16:16.467 --> 00:16:18.400
These are like,
there is no in-between time,

00:16:18.400 --> 00:16:20.834
semantically, between...

00:16:20.834 --> 00:16:22.267
for yourself, atomicity,

00:16:22.267 --> 00:16:23.267
or others, isolation.

00:16:23.267 --> 00:16:25.434
Consistency.

00:16:25.434 --> 00:16:28.634
Jump, hop from one island
to another island.

00:16:28.634 --> 00:16:30.067
Don't hop
to the middle of the ocean.

00:16:30.067 --> 00:16:31.734
That's really
the responsibility

00:16:31.734 --> 00:16:32.934
of the layer above,

00:16:32.934 --> 00:16:34.734
and durability
is really the responsibility

00:16:34.734 --> 00:16:35.901
of the layer below.

00:16:35.901 --> 00:16:37.434
So all we really need
to concentrate on

00:16:37.434 --> 00:16:39.100
when we're using, say,
Google App Engine...

00:16:39.100 --> 00:16:41.734
Underneath is a lot
of good infrastructure

00:16:41.734 --> 00:16:44.667
by people like Ryan,
and others I'm sure,

00:16:44.667 --> 00:16:46.868
that provide durability

00:16:46.868 --> 00:16:48.434
and a lot of other properties.

00:16:48.434 --> 00:16:50.100
So you can
count on App Engine

00:16:50.100 --> 00:16:52.234
to keep your data
once you've put it,

00:16:52.234 --> 00:16:54.033
and that put comes come back.

00:16:54.033 --> 00:16:55.734
You know, it's replicated.

00:16:55.734 --> 00:16:57.334
We heard earlier today
in a different talk,

00:16:57.334 --> 00:16:58.968
it's in at least three
different places,

00:16:58.968 --> 00:17:00.701
and it's geographically
distributed, good.

00:17:00.701 --> 00:17:02.033
I think that's good enough.

00:17:02.033 --> 00:17:03.734
It's up to you
as the application developer

00:17:03.734 --> 00:17:05.501
to hop from good state
to good state,

00:17:05.501 --> 00:17:06.734
to say,
"Run this transaction.

00:17:06.734 --> 00:17:08.567
Take me from this state
to another good state."

00:17:08.567 --> 00:17:10.200
But the in-between layer,

00:17:10.200 --> 00:17:11.968
the transactional layer
I'm gonna talk about,

00:17:11.968 --> 00:17:14.267
the distributed transaction
layer I'm gonna tell you about,

00:17:14.267 --> 00:17:19.434
we need to be worried
about atomicy and isolation.

00:17:19.434 --> 00:17:21.133
And here ACID is again.

00:17:21.133 --> 00:17:22.300
I don't know
why I put that in.

00:17:22.300 --> 00:17:24.934
All right.
So no questions yet so far?

00:17:24.934 --> 00:17:26.534
Nobody's like,
"What is he talking about?"

00:17:26.534 --> 00:17:28.300
No? Okay.

00:17:28.300 --> 00:17:31.467
Local transactions.

00:17:31.467 --> 00:17:34.267
Google App Engine
provides local transactions.

00:17:34.267 --> 00:17:36.100
They provide some
transactional semantics.

00:17:36.100 --> 00:17:37.100
These guys aren't dumb.

00:17:37.100 --> 00:17:38.400
They're at Google.

00:17:38.400 --> 00:17:41.000
They said, "Obviously
people need transactions."

00:17:41.000 --> 00:17:44.801
But for various underlying
implementation reasons

00:17:44.801 --> 00:17:46.467
that Ryan could tell you
a lot about,

00:17:46.467 --> 00:17:47.534
and I think he actually will

00:17:47.534 --> 00:17:48.534
in his next talk.

00:17:48.534 --> 00:17:50.467
It really helps them

00:17:50.467 --> 00:17:52.767
to localize the transactions

00:17:52.767 --> 00:17:56.000
in space, or what we call
space in data.

00:17:56.000 --> 00:17:57.501
So, in other words,

00:17:57.501 --> 00:17:59.701
when you make an object
in App Engine,

00:17:59.701 --> 00:18:02.634
you can group it
with other objects,

00:18:02.634 --> 00:18:05.234
and make something
called entity group.

00:18:05.234 --> 00:18:07.234
Once you've done that,
that's it.

00:18:07.234 --> 00:18:09.167
You get to pick
the entity group of your object

00:18:09.167 --> 00:18:10.467
at object construction time.

00:18:10.467 --> 00:18:12.167
You can't move objects
from group to group.

00:18:12.167 --> 00:18:13.167
There's no such thing.

00:18:13.167 --> 00:18:14.934
Okay,
so these entity groups

00:18:14.934 --> 00:18:16.834
form a partition of your data.

00:18:16.834 --> 00:18:19.701
And I think the suggested size
in the documentation is,

00:18:19.701 --> 00:18:21.968
"Well, that's enough
for one user's data."

00:18:21.968 --> 00:18:23.100
Um, yeah, okay,

00:18:23.100 --> 00:18:24.901
but maybe my users
would like to interact.

00:18:24.901 --> 00:18:27.100
There's this Web 2.0 thing.

00:18:27.100 --> 00:18:31.467
Okay. Maybe I'd like
to build a bank.

00:18:31.467 --> 00:18:33.868
You can't build a bank
on App Engine right now,

00:18:33.868 --> 00:18:35.701
because you can't put
everybody's bank account

00:18:35.701 --> 00:18:38.067
into one entity group
that'll overwhelm...

00:18:38.067 --> 00:18:39.400
I mean,
you could, technically,

00:18:39.400 --> 00:18:40.467
but something would break,

00:18:40.467 --> 00:18:42.167
because it would overwhelm...

00:18:42.167 --> 00:18:44.300
they've assumed the entity
groups have a certain size,

00:18:44.300 --> 00:18:45.868
and it's not that big.

00:18:45.868 --> 00:18:47.801
It's about the data
for one user, like I said.

00:18:47.801 --> 00:18:49.400
That's what they say.

00:18:49.400 --> 00:18:51.100
So how do we
solve this problem?

00:18:51.100 --> 00:18:52.200
We would like transactions,

00:18:52.200 --> 00:18:53.634
but with local transactions,

00:18:53.634 --> 00:18:55.067
you run a transaction,

00:18:55.067 --> 00:18:57.300
you'd better only operate
on data in one entity group,

00:18:57.300 --> 00:18:58.834
'cause you try
to operate on two,

00:18:58.834 --> 00:19:01.467
you get an exception,
I believe, right, Ryan?

00:19:01.467 --> 00:19:04.133
You get an exception
if you try to--Yeah.

00:19:04.133 --> 00:19:07.300
And also if you try
to run queries,

00:19:07.300 --> 00:19:08.934
you can't do that either.

00:19:08.934 --> 00:19:10.434
We're not gonna solve--

00:19:10.434 --> 00:19:12.067
So we're gonna solve
the first problem,

00:19:12.067 --> 00:19:13.300
not the second problem.

00:19:13.300 --> 00:19:15.300
So those of you who come
from the relational world,

00:19:15.300 --> 00:19:16.534
everything's done with a query.

00:19:16.534 --> 00:19:17.567
You can't look up an object

00:19:17.567 --> 00:19:18.868
without running a query.

00:19:18.868 --> 00:19:20.667
In App Engine, if you have
the key to an object,

00:19:20.667 --> 00:19:21.868
you can get it
and you can put it

00:19:21.868 --> 00:19:23.000
without running a query.

00:19:23.000 --> 00:19:26.100
There's something else
called a query.

00:19:26.100 --> 00:19:28.367
We're not gonna solve
the problem called

00:19:28.367 --> 00:19:30.567
"You can't run queries
in a transaction on App Engine."

00:19:30.567 --> 00:19:31.667
That's future work.

00:19:31.667 --> 00:19:33.200
We are gonna
solve the problem called,

00:19:33.200 --> 00:19:34.767
"You can't do transactions

00:19:34.767 --> 00:19:36.167
"across a set of objects

00:19:36.167 --> 00:19:37.701
that span
more than one entity group."

00:19:37.701 --> 00:19:40.501
We're gonna solve that problem.

00:19:40.501 --> 00:19:47.367
You haven't been able
to do that until now.

00:19:47.367 --> 00:19:48.834
Any questions so far?

00:19:48.834 --> 00:19:49.834
That's the problem.

00:19:49.834 --> 00:19:50.834
And why you should care.

00:19:50.834 --> 00:19:52.434
Solution.

00:19:52.434 --> 00:19:54.067
Well, this is the algorithm.

00:19:54.067 --> 00:19:55.467
That's it.

00:19:55.467 --> 00:20:00.200
Fits on one slide.

00:20:00.200 --> 00:20:02.934
I'll read it to you.

00:20:02.934 --> 00:20:05.133
The first thing is...

00:20:05.133 --> 00:20:06.667
What we're gonna do is,

00:20:06.667 --> 00:20:08.033
we basically want the user,

00:20:08.033 --> 00:20:09.167
when they run a transaction,

00:20:09.167 --> 00:20:10.601
they're gonna
read some objects,

00:20:10.601 --> 00:20:12.601
they're gonna read something,
maybe from the user,

00:20:12.601 --> 00:20:14.133
and they're gonna
write some objects.

00:20:14.133 --> 00:20:17.467
We want that to look
to all other threads

00:20:17.467 --> 00:20:20.334
as if it happened
instantaneously.

00:20:20.334 --> 00:20:22.567
So the database
was in some state,

00:20:22.567 --> 00:20:24.067
and then when the user--

00:20:24.067 --> 00:20:26.234
they mapped basically
reads to writes,

00:20:26.234 --> 00:20:28.667
and that happened
in one instant in time.

00:20:28.667 --> 00:20:29.934
Now,
it doesn't really happen

00:20:29.934 --> 00:20:31.033
in an instant in time,

00:20:31.033 --> 00:20:32.467
so we have to provide
that illusion.

00:20:32.467 --> 00:20:34.367
Semantically, it happens
in an instant in time,

00:20:34.367 --> 00:20:35.934
but we're separating that

00:20:35.934 --> 00:20:37.267
from how it actually runs.

00:20:37.267 --> 00:20:38.901
So what we do is,
first of all,

00:20:38.901 --> 00:20:42.334
when the client says,

00:20:42.334 --> 00:20:44.400
"Here's a function
and here's some arguments,

00:20:44.400 --> 00:20:45.734
run this in a transaction
for me."

00:20:45.734 --> 00:20:47.033
That's the interface.

00:20:47.033 --> 00:20:48.267
You say,
"Run in transaction."

00:20:48.267 --> 00:20:50.901
Hand it a client function.

00:20:50.901 --> 00:20:52.734
When the client
asks for reads,

00:20:52.734 --> 00:20:54.834
when they say, "Read these
objects from the database,"

00:20:54.834 --> 00:20:56.300
we read them then,

00:20:56.300 --> 00:20:58.067
but we record
the version number

00:20:58.067 --> 00:20:59.133
of the object read.

00:20:59.133 --> 00:21:01.367
All objects
get a version number.

00:21:01.367 --> 00:21:02.934
And they can't roll over.

00:21:02.934 --> 00:21:04.501
I'll tell you about that later.

00:21:04.501 --> 00:21:06.501
Then the client function says,

00:21:06.501 --> 00:21:08.434
"Hey, write these objects
back to the database."

00:21:08.434 --> 00:21:10.534
We don't do that.

00:21:10.534 --> 00:21:11.534
That could be bad.

00:21:11.534 --> 00:21:12.734
That could break something.

00:21:12.734 --> 00:21:14.300
So we're not gonna write
any of your data.

00:21:14.300 --> 00:21:16.868
So we said instead
we store the writes

00:21:16.868 --> 00:21:18.300
in these shadow objects,

00:21:18.300 --> 00:21:20.501
and if you try
to write a user object

00:21:20.501 --> 00:21:22.000
in the client function,

00:21:22.000 --> 00:21:23.167
we store that, what you wrote,

00:21:23.167 --> 00:21:24.300
in a shadow object

00:21:24.300 --> 00:21:27.000
in the same entity group
as the user object.

00:21:27.000 --> 00:21:28.200
So we spread your data out.

00:21:28.200 --> 00:21:29.734
It's in many different
entity groups.

00:21:29.734 --> 00:21:30.734
It's cool.

00:21:30.734 --> 00:21:32.067
It's all gonna work.

00:21:32.067 --> 00:21:33.801
Now the client function
is done.

00:21:33.801 --> 00:21:35.734
I should have put that in here.

00:21:35.734 --> 00:21:37.634
So the client function is done.

00:21:37.634 --> 00:21:40.133
The map it computes
from reads to writes,

00:21:40.133 --> 00:21:43.133
that's now a static object
of finite size.

00:21:43.133 --> 00:21:46.467
This is very handy for us.

00:21:46.467 --> 00:21:47.534
So now what we do is,

00:21:47.534 --> 00:21:48.734
we get write locks

00:21:48.734 --> 00:21:51.033
on all the objects
we're gonna write.

00:21:51.033 --> 00:21:52.501
Now if we just do that
in any order,

00:21:52.501 --> 00:21:54.067
what can happen?

00:21:54.067 --> 00:21:56.067
'Cause write locks
exclude each other,

00:21:56.067 --> 00:21:57.968
so no two
distributor's transactions

00:21:57.968 --> 00:21:59.734
can have a write lock
on the same user object

00:21:59.734 --> 00:22:00.901
at the same time.

00:22:00.901 --> 00:22:03.400
What can happen
if you just get write locks?

00:22:03.400 --> 00:22:04.868
Deadlock.

00:22:04.868 --> 00:22:06.467
Somebody said it.
Deadlock.

00:22:06.467 --> 00:22:09.167
Because, "I need this,"
and "You need that,"

00:22:09.167 --> 00:22:10.200
and we all grab,

00:22:10.200 --> 00:22:11.567
and we just sort of wait,

00:22:11.567 --> 00:22:13.400
'cause none of us can get
what we need to finish,

00:22:13.400 --> 00:22:15.467
but we're not about to let go
of the resources we have,

00:22:15.467 --> 00:22:18.200
so we just stay there
in deadlock.

00:22:18.200 --> 00:22:19.634
All right, so instead,

00:22:19.634 --> 00:22:21.801
the standard algorithm
for getting rid of that,

00:22:21.801 --> 00:22:23.734
sort your objects,
get them in increasing order.

00:22:23.734 --> 00:22:24.734
You can't get a cycle,

00:22:24.734 --> 00:22:25.834
because your wait-for graph

00:22:25.834 --> 00:22:27.934
is only pointing up the order.

00:22:27.934 --> 00:22:30.667
Then we go
and check the version numbers

00:22:30.667 --> 00:22:32.100
on all the objects you read

00:22:32.100 --> 00:22:34.067
to see if they still have
the same versions they had

00:22:34.067 --> 00:22:36.934
when you read them.

00:22:36.934 --> 00:22:38.467
Now some of you are saying,

00:22:38.467 --> 00:22:39.868
"But that's a race condition,
Dan.

00:22:39.868 --> 00:22:41.300
They could change
after you check."

00:22:41.300 --> 00:22:43.200
No, it'll work.

00:22:43.200 --> 00:22:45.133
Trust me.

00:22:45.133 --> 00:22:46.701
Someone should say,
"Race condition?"

00:22:46.701 --> 00:22:48.834
Come on.
You guys are just sitting there.

00:22:48.834 --> 00:22:50.400
It's much more fun
if you say something.

00:22:50.400 --> 00:22:54.033
Okay. We also check not only
is the version the same,

00:22:54.033 --> 00:22:55.334
but nobody else
is in write lock

00:22:55.334 --> 00:22:56.601
on that read object.

00:22:56.601 --> 00:22:58.868
And then we're gonna
go do something later.

00:22:58.868 --> 00:23:01.267
It's not a race condition.

00:23:01.267 --> 00:23:05.267
Then we go and we
take all the shadows

00:23:05.267 --> 00:23:09.234
and we copy them, stomping on
the state of the user object.

00:23:09.234 --> 00:23:11.501
We make your write
actually for real.

00:23:11.501 --> 00:23:12.968
We copy the shadow object

00:23:12.968 --> 00:23:14.300
to the user object state.

00:23:14.300 --> 00:23:15.934
We update the version number,

00:23:15.934 --> 00:23:17.634
which is actually the ID

00:23:17.634 --> 00:23:19.234
of the distributed
transaction object.

00:23:19.234 --> 00:23:21.834
IDs are guaranteed
never to repeat.

00:23:21.834 --> 00:23:22.968
Ah-ha.

00:23:22.968 --> 00:23:25.133
So version numbers
can't roll over.

00:23:25.133 --> 00:23:26.567
And then we delete
the write locks

00:23:26.567 --> 00:23:27.567
and the shadow objects

00:23:27.567 --> 00:23:28.968
leaving no garbage.

00:23:28.968 --> 00:23:29.968
There's a very subtle,

00:23:29.968 --> 00:23:31.567
very rare condition

00:23:31.567 --> 00:23:33.767
under which we can still
get garbage in this algorithm.

00:23:33.767 --> 00:23:34.767
I'm working on it.

00:23:34.767 --> 00:23:36.267
If I told you,

00:23:36.267 --> 00:23:38.100
Ryan would say,
"Dan, that'll never happen."

00:23:38.100 --> 00:23:39.567
Well, I don't know
what he would say.

00:23:39.567 --> 00:23:40.767
Sorry, Ryan.

00:23:40.767 --> 00:23:42.868
But I'm obsessive
about these things.

00:23:42.868 --> 00:23:43.901
See, that's what you want.

00:23:43.901 --> 00:23:45.601
You want someone
designing this algorithm

00:23:45.601 --> 00:23:46.868
to be obsessive.

00:23:46.868 --> 00:23:49.367
All right, there's a lot
of things you can do.

00:23:49.367 --> 00:23:51.501
That's all
the correctness depends on.

00:23:51.501 --> 00:23:52.701
There's some things you can do

00:23:52.701 --> 00:23:54.033
so that transactions
kind of try

00:23:54.033 --> 00:23:55.033
not to stomp on each other.

00:23:55.033 --> 00:23:56.567
Ah. Yes.
We have a question.

00:23:56.567 --> 00:23:58.501
Thank you.

00:24:11.767 --> 00:24:13.167
I'll repeat the question.

00:24:13.167 --> 00:24:14.234
If I got write locks,

00:24:14.234 --> 00:24:15.367
why do I then check

00:24:15.367 --> 00:24:16.968
that the objects
don't have write locks?

00:24:16.968 --> 00:24:19.667
I get write locks
on all the objects I write.

00:24:19.667 --> 00:24:21.634
For all the objects I read,

00:24:21.634 --> 00:24:23.734
which could be a different
set of objects.

00:24:23.734 --> 00:24:25.834
I check the version numbers
are still good,

00:24:25.834 --> 00:24:27.367
so no one else has written it,

00:24:27.367 --> 00:24:28.868
and no one else has it locked.

00:24:28.868 --> 00:24:32.067
No one else has the objects
I read write locked.

00:24:32.067 --> 00:24:34.868
'Cause you could read
some objects and write others.

00:24:34.868 --> 00:24:36.767
You tend to read and then
write the same objects,

00:24:36.767 --> 00:24:39.000
but it could be
separate sets of objects.

00:24:39.000 --> 00:24:40.534
Good question. Thank you.

00:24:40.534 --> 00:24:41.901
Yes.

00:24:41.901 --> 00:24:43.100
And if you're near the mic,

00:24:43.100 --> 00:24:44.200
please use the mic.

00:24:44.200 --> 00:24:49.734
man: This is similar
to phase commit...

00:24:49.734 --> 00:24:51.133
Wilkerson:
It's--yeah.

00:24:51.133 --> 00:24:52.934
There's only so many
good ideas in this world.

00:24:52.934 --> 00:24:54.701
man: How do you prevent
a client from crashing?

00:24:54.701 --> 00:24:56.334
Wilkerson: I'm not
gonna patent this. Yes?

00:24:56.334 --> 00:24:57.634
man: How do you
prevent the locks

00:24:57.634 --> 00:25:00.667
from being held indefinitely
when a client crashes?

00:25:00.667 --> 00:25:02.234
Wilkerson:
How do I prevent the locks

00:25:02.234 --> 00:25:03.534
from being held indefinitely

00:25:03.534 --> 00:25:04.667
if someone crashes?

00:25:04.667 --> 00:25:06.067
Very good question.

00:25:06.067 --> 00:25:11.000
Okay.

00:25:11.000 --> 00:25:12.734
So a lot of the complexity
of the algorithm

00:25:12.734 --> 00:25:13.767
goes into these concerns.

00:25:13.767 --> 00:25:15.033
This is very simple,

00:25:15.033 --> 00:25:16.801
but there's lots of things
that can go wrong.

00:25:16.801 --> 00:25:18.267
I'll actually
talk about that later,

00:25:18.267 --> 00:25:19.367
but I'll answer it now.

00:25:19.367 --> 00:25:21.267
Which is, if you grab
some write locks

00:25:21.267 --> 00:25:22.334
and then you just crash,

00:25:22.334 --> 00:25:23.734
your thread crashes,

00:25:23.734 --> 00:25:24.901
first of all,

00:25:24.901 --> 00:25:26.567
all the state of
the distributed transaction

00:25:26.567 --> 00:25:28.367
is stored in the distributed
transaction object,

00:25:28.367 --> 00:25:29.534
which is also in the database,

00:25:29.534 --> 00:25:31.000
and we don't start
rolling it forward

00:25:31.000 --> 00:25:32.400
until it's in the database.

00:25:32.400 --> 00:25:33.868
So you grab some locks,

00:25:33.868 --> 00:25:35.601
and then your thread
goes away.

00:25:35.601 --> 00:25:37.200
Someone else
tries to lock that object,

00:25:37.200 --> 00:25:39.501
they block,
'cause you have the lock.

00:25:39.501 --> 00:25:43.467
They can check
your creation time of the--

00:25:43.467 --> 00:25:44.767
So distributed
transaction one

00:25:44.767 --> 00:25:46.033
gets a lock on an object.

00:25:46.033 --> 00:25:47.267
Distributed transaction two

00:25:47.267 --> 00:25:48.434
tries to get it.

00:25:48.434 --> 00:25:50.000
Distributed
transaction one's thread

00:25:50.000 --> 00:25:51.000
is timed out or something.

00:25:51.000 --> 00:25:52.601
Distributed transaction two--

00:25:52.601 --> 00:25:54.634
Since all the state of
the distributed transactions

00:25:54.634 --> 00:25:55.634
is in the database,

00:25:55.634 --> 00:25:57.801
its thread can pause,

00:25:57.801 --> 00:26:01.701
go and become the thread
that's rolling forward this one

00:26:01.701 --> 00:26:02.701
that has the lock,

00:26:02.701 --> 00:26:03.901
roll it forward to completion,

00:26:03.901 --> 00:26:06.100
then go back
and complete itself.

00:26:06.100 --> 00:26:09.234
So the entire state
of the distributed transaction

00:26:09.234 --> 00:26:10.734
is in the database as well.

00:26:10.734 --> 00:26:12.868
So different threads
can kind of switch off

00:26:12.868 --> 00:26:15.000
and roll forward different
distributed transactions

00:26:15.000 --> 00:26:17.901
if they're blocking.

00:26:17.901 --> 00:26:20.167
That's the answer.

00:26:20.167 --> 00:26:25.367
Make sense?

00:26:25.367 --> 00:26:27.033
Transactions and cooperate.

00:26:27.033 --> 00:26:28.534
If you are reading an object

00:26:28.534 --> 00:26:29.734
and, hey,
it has a write lock,

00:26:29.734 --> 00:26:32.934
you probably ought to wait.

00:26:32.934 --> 00:26:34.834
That's pretty much it.

00:26:34.834 --> 00:26:36.234
That probably works.

00:26:36.234 --> 00:26:37.567
This is all
not as easy as it looks.

00:26:37.567 --> 00:26:38.767
In case you're wondering,

00:26:38.767 --> 00:26:40.300
why'd this guy
get to talk at Google IO?

00:26:40.300 --> 00:26:42.934
I could have done this
in a weekend.

00:26:42.934 --> 00:26:44.934
Deadlock prevention,
yeah, you've got to do that.

00:26:44.934 --> 00:26:46.067
But deadlock prevention

00:26:46.067 --> 00:26:47.734
prevents a lot
of other cool stuff.

00:26:47.734 --> 00:26:49.834
If you've got to sort
all the objects you're writing,

00:26:49.834 --> 00:26:51.033
what that means is

00:26:51.033 --> 00:26:52.534
the client has to be done
writing them.

00:26:52.534 --> 00:26:54.400
So you have to do it
after a client's done writing,

00:26:54.400 --> 00:26:56.200
and these restrictions begin
to accumulate ongoing progress.

00:26:56.200 --> 00:26:58.667
There's a lot of things
that can cause...

00:26:58.667 --> 00:27:00.968
There's a lot of ways
to deal with ongoing progress.

00:27:00.968 --> 00:27:02.767
This is--it's a big topic.

00:27:02.767 --> 00:27:04.934
One is your thread
can go away.

00:27:04.934 --> 00:27:06.868
Someone else needs to be able
to roll you forward.

00:27:06.868 --> 00:27:08.667
But what if no one does
try to get a write lock

00:27:08.667 --> 00:27:09.734
on one of your objects

00:27:09.734 --> 00:27:11.200
and no one
tries to roll you forward?

00:27:11.200 --> 00:27:12.467
Well, you need
a background thread

00:27:12.467 --> 00:27:14.300
that's looking for old
distributed transactions

00:27:14.300 --> 00:27:15.334
and rolling them forward.

00:27:15.334 --> 00:27:18.400
Also,
how do you prevent the user

00:27:18.400 --> 00:27:21.100
from accumulating unsatisfied
distributed transactions?

00:27:21.100 --> 00:27:22.701
We thought a lot
about how to,

00:27:22.701 --> 00:27:23.834
or I thought about

00:27:23.834 --> 00:27:27.601
how not to...

00:27:27.601 --> 00:27:29.033
One of the things Gray

00:27:29.033 --> 00:27:30.534
talks about in his book
on databases,

00:27:30.534 --> 00:27:31.701
he has this huge book

00:27:31.701 --> 00:27:33.300
the size of a calculus book
on databases,

00:27:33.300 --> 00:27:34.767
and then he has
this one little aside.

00:27:34.767 --> 00:27:36.200
It's, like,
a page and a half.

00:27:36.200 --> 00:27:39.701
He says, "But this reality
can become completely decoupled

00:27:39.701 --> 00:27:40.868
from what's in the database."

00:27:40.868 --> 00:27:43.367
For example, something
that actually happened,

00:27:43.367 --> 00:27:45.767
in a branch office of this,
like, bank,

00:27:45.767 --> 00:27:46.934
they took all the records,

00:27:46.934 --> 00:27:49.133
and they hid them
in the ladies' room.

00:27:49.133 --> 00:27:51.601
And they never got entered
in the database.

00:27:51.601 --> 00:27:53.200
So keeping your database

00:27:53.200 --> 00:27:55.701
synchronized
with the user interface

00:27:55.701 --> 00:27:57.367
is actually part of our paper.

00:27:57.367 --> 00:28:00.667
So we actually record the user,

00:28:00.667 --> 00:28:02.601
the request of the
distributed transactions,

00:28:02.601 --> 00:28:05.767
so that, A, well, when you get
another request from a user,

00:28:05.767 --> 00:28:07.100
first thing you can do

00:28:07.100 --> 00:28:09.100
is query for all the pending
distributed transactions

00:28:09.100 --> 00:28:10.100
they haven't finished

00:28:10.100 --> 00:28:11.200
and roll those forward first,

00:28:11.200 --> 00:28:12.300
so the user has an experience

00:28:12.300 --> 00:28:13.501
of transactions committing

00:28:13.501 --> 00:28:15.734
in the order in which
they requested them.

00:28:15.734 --> 00:28:17.167
I think that's important,
you know.

00:28:17.167 --> 00:28:18.400
In algorithms class

00:28:18.400 --> 00:28:20.100
they've never
probably talked about that,

00:28:20.100 --> 00:28:21.534
but this is reality.

00:28:21.534 --> 00:28:23.067
Concurrent roll-forward.

00:28:23.067 --> 00:28:25.067
The second half
of the algorithm,

00:28:25.067 --> 00:28:27.300
where once the client
function is finished...

00:28:27.300 --> 00:28:28.834
If other threads can come

00:28:28.834 --> 00:28:31.100
and start rolling your
distributed transaction forward,

00:28:31.100 --> 00:28:33.000
there can be multiple threads
doing that, right?

00:28:33.000 --> 00:28:34.934
So that means
your entire roll-forward

00:28:34.934 --> 00:28:35.934
has to be thread-safe.

00:28:35.934 --> 00:28:37.501
But how do you do that?

00:28:37.501 --> 00:28:38.567
Because I have to get locks,

00:28:38.567 --> 00:28:39.901
and then release them later.

00:28:39.901 --> 00:28:41.501
That's not item potent, right?

00:28:41.501 --> 00:28:42.968
Item potent
means I do something

00:28:42.968 --> 00:28:44.868
and then it's done,
I never go back.

00:28:44.868 --> 00:28:46.234
Or like a light switch.

00:28:46.234 --> 00:28:47.567
You switch it on,

00:28:47.567 --> 00:28:49.501
no matter how many times
you switch it on, it's on.

00:28:49.501 --> 00:28:50.534
It's not a toggle switch.

00:28:50.534 --> 00:28:52.000
Toggle switches
are not item potent.

00:28:52.000 --> 00:28:53.234
They're also not thread-safe.

00:28:53.234 --> 00:28:54.968
Because if I went
and turned the lights on,

00:28:54.968 --> 00:28:56.901
another thread could come
and hit the button also

00:28:56.901 --> 00:28:57.901
and then turn 'em off.

00:28:57.901 --> 00:28:59.033
And, no, I want 'em on,

00:28:59.033 --> 00:29:00.400
and they come
and turn 'em off again.

00:29:00.400 --> 00:29:01.767
I want it on.

00:29:01.767 --> 00:29:03.601
And two people trying
to turn on a toggle switch,

00:29:03.601 --> 00:29:04.834
they could fight with each other

00:29:04.834 --> 00:29:05.968
and keep turning the lights off.

00:29:05.968 --> 00:29:06.968
This is not thread safe,

00:29:06.968 --> 00:29:08.167
so you need your entire process

00:29:08.167 --> 00:29:09.734
of getting the locks
and releasing them

00:29:09.734 --> 00:29:11.033
to somehow be thread-safe.

00:29:11.033 --> 00:29:12.901
And I'll leave that as a puzzle
for the listener.

00:29:12.901 --> 00:29:14.834
How do you get a lock
and then release it

00:29:14.834 --> 00:29:18.901
in a way that's item potent?

00:29:18.901 --> 00:29:22.033
Erick Armbrust
came up with a way to do that.

00:29:22.033 --> 00:29:23.067
It's really clever.

00:29:23.067 --> 00:29:24.434
By accident, actually,
in a sense.

00:29:24.434 --> 00:29:28.701
We didn't realize
he solved that problem.

00:29:28.701 --> 00:29:30.200
Proof of isolation.

00:29:30.200 --> 00:29:33.033
We need to guarantee
all these properties

00:29:33.033 --> 00:29:36.267
where no one can see
things happening in between.

00:29:36.267 --> 00:29:37.901
So, deadlock prevention,

00:29:37.901 --> 00:29:38.901
we talked about that.

00:29:38.901 --> 00:29:40.400
Get locks in a certain order.

00:29:40.400 --> 00:29:42.734
Ongoing progress,
oh, yeah.

00:29:42.734 --> 00:29:43.934
We want read-storms.

00:29:43.934 --> 00:29:46.167
I think Ryan
once said in a talk,

00:29:46.167 --> 00:29:48.167
found that Google
has ten to a hundred times

00:29:48.167 --> 00:29:50.367
as many reads per writes
in web apps.

00:29:50.367 --> 00:29:52.767
So this is optimized so that

00:29:52.767 --> 00:29:54.033
if you have a write

00:29:54.033 --> 00:29:55.734
and lots of people
are reading that object,

00:29:55.734 --> 00:29:58.667
those reads
can't keep out your write.

00:29:58.667 --> 00:30:00.901
Some of this
I already talked about,

00:30:00.901 --> 00:30:03.567
rolling forward
when you're blocked.

00:30:03.567 --> 00:30:05.868
We take care
not to create garbage,

00:30:05.868 --> 00:30:11.033
which is actually
kind of hard to do.

00:30:11.033 --> 00:30:12.634
I talked about
concurrent rollforward,

00:30:12.634 --> 00:30:14.300
so when we're getting locks,

00:30:14.300 --> 00:30:16.200
we want to proceed--

00:30:16.200 --> 00:30:18.367
We want the state space
of our distributed transaction

00:30:18.367 --> 00:30:19.400
to proceed monotonically

00:30:19.400 --> 00:30:20.868
through some big state space

00:30:20.868 --> 00:30:23.000
where there's only one path,

00:30:23.000 --> 00:30:25.334
so multiple threads
rolling it forward won't matter,

00:30:25.334 --> 00:30:28.133
'cause they're all
going along the same path.

00:30:28.133 --> 00:30:32.067
So they'll all
get to the same place.

00:30:32.067 --> 00:30:35.133
And this is more about that.

00:30:35.133 --> 00:30:37.067
So this says the answer.

00:30:37.067 --> 00:30:38.467
But can anybody else
figure out how,

00:30:38.467 --> 00:30:40.601
looking at this
and thinking about it,

00:30:40.601 --> 00:30:41.801
how do you release a lock

00:30:41.801 --> 00:30:47.000
in an item-potent way?

00:30:47.000 --> 00:30:49.567
When we created
the need for the lock,

00:30:49.567 --> 00:30:51.167
we wrote a shadow object.

00:30:51.167 --> 00:30:52.534
So first you have
a shadow object.

00:30:52.534 --> 00:30:54.567
Then you have a shadow object
and a lock.

00:30:54.567 --> 00:30:56.367
Then you delete the lock
and the shadow object

00:30:56.367 --> 00:30:58.534
at the same time
in a local transaction.

00:30:58.534 --> 00:31:00.901
So those
are three distinct states

00:31:00.901 --> 00:31:02.267
that actually aren't repeating.

00:31:02.267 --> 00:31:04.767
Even though the lock is getting
set and then released,

00:31:04.767 --> 00:31:06.467
the whole state's base
is still monotonic.

00:31:06.467 --> 00:31:08.734
Locally,
it looks non-item potent,

00:31:08.734 --> 00:31:10.968
but it isn't.

00:31:10.968 --> 00:31:13.400
Strong consistency.

00:31:13.400 --> 00:31:16.834
Eventual consistency
is this new fad

00:31:16.834 --> 00:31:19.367
in distributed algorithms

00:31:19.367 --> 00:31:21.167
where you don't have
to actually make sure

00:31:21.167 --> 00:31:23.300
everybody else finds out
when you update objects,

00:31:23.300 --> 00:31:24.767
but that's a real pain
to program too.

00:31:24.767 --> 00:31:25.934
Thankfully...

00:31:25.934 --> 00:31:27.067
Ryan is nodding.

00:31:27.067 --> 00:31:29.133
Thankfully
the good people at Google

00:31:29.133 --> 00:31:30.234
on the App Engine team

00:31:30.234 --> 00:31:32.534
have provided us
with a strong consistency,

00:31:32.534 --> 00:31:35.367
which means if I update
an object and it returns,

00:31:35.367 --> 00:31:40.167
then anybody else
I talk to subsequently,

00:31:40.167 --> 00:31:43.868
if they look,
they're gonna see that update.

00:31:43.868 --> 00:31:46.267
There's something in between
called causal consistency,

00:31:46.267 --> 00:31:48.701
where I can tell certain people
and they're guaranteed to know.

00:31:48.701 --> 00:31:50.767
You could actually
do our algorithm

00:31:50.767 --> 00:31:52.234
on top of causal consistency,

00:31:52.234 --> 00:31:56.300
but we have strong consistency,
so we don't need it.

00:31:56.300 --> 00:31:59.701
Without strong consistency,

00:31:59.701 --> 00:32:02.167
it's very, very funky
what does time mean

00:32:02.167 --> 00:32:05.200
in a distributed algorithm.

00:32:05.200 --> 00:32:07.968
Local and distributed
transactions don't mix.

00:32:07.968 --> 00:32:10.000
Local transactions
are obviously cheaper.

00:32:10.000 --> 00:32:11.334
They have less mechanisms.

00:32:11.334 --> 00:32:15.501
So Erick has carefully
implemented this algorithm

00:32:15.501 --> 00:32:17.868
so that if you only need
distributed transactions

00:32:17.868 --> 00:32:19.367
for certain objects,

00:32:19.367 --> 00:32:21.200
you can have them
only for those objects

00:32:21.200 --> 00:32:23.501
and not use them
for other objects.

00:32:23.501 --> 00:32:28.501
Also, you really don't want
to mix them accidentally,

00:32:28.501 --> 00:32:30.033
because local transactions

00:32:30.033 --> 00:32:32.567
don't honor our
distributed transaction locks,

00:32:32.567 --> 00:32:34.968
so there's no way with
the way Erick has it set up,

00:32:34.968 --> 00:32:36.267
at least the way he told me,

00:32:36.267 --> 00:32:38.634
is there's no way to use
distributed transactions

00:32:38.634 --> 00:32:40.400
on an object without entering

00:32:40.400 --> 00:32:42.267
the distributed transaction
infrastructure.

00:32:42.267 --> 00:32:44.100
You can't use a DT.

00:32:44.100 --> 00:32:45.534
If you do,

00:32:45.534 --> 00:32:47.334
you're objects suddenly
become DT flavored,

00:32:47.334 --> 00:32:49.133
and you are using
distributed transactions.

00:32:49.133 --> 00:32:51.267
We did a lot of work
to try to prevent you guys

00:32:51.267 --> 00:32:52.501
from falling into holes.

00:32:52.501 --> 00:32:54.367
Like, if you use
the algorithm just right,

00:32:54.367 --> 00:32:55.400
everything's fine,

00:32:55.400 --> 00:32:56.801
and then
if you do something wrong,

00:32:56.801 --> 00:32:58.601
too bad for you,
'cause you're the stupid user.

00:32:58.601 --> 00:32:59.601
No.
We didn't do that.

00:32:59.601 --> 00:33:00.667
We really tried to make it

00:33:00.667 --> 00:33:01.834
so that it's fool-proof,

00:33:01.834 --> 00:33:03.667
so that you guys
don't fall into holes.

00:33:03.667 --> 00:33:05.701
Also, there's a thing

00:33:05.701 --> 00:33:06.701
if we're buffering writes

00:33:06.701 --> 00:33:07.801
from an algorithm I read,

00:33:07.801 --> 00:33:09.300
object x, I get x is 1.

00:33:09.300 --> 00:33:10.300
Then I write x is 2.

00:33:10.300 --> 00:33:12.100
Then I read object x again,

00:33:12.100 --> 00:33:13.534
I'm gonna get x is 1,

00:33:13.534 --> 00:33:14.701
'cause it's a buffered write.

00:33:14.701 --> 00:33:16.701
So we prevent that
from happening.

00:33:16.701 --> 00:33:18.300
We don't allow you
to do read after write.

00:33:18.300 --> 00:33:20.267
We also don't allow you
to do write after write,

00:33:20.267 --> 00:33:22.167
but again,
this allows the illusion

00:33:22.167 --> 00:33:23.334
of correct data flow

00:33:23.334 --> 00:33:24.801
in your client code,

00:33:24.801 --> 00:33:25.801
so that you're not--

00:33:25.801 --> 00:33:27.133
we're not messing you up.

00:33:27.133 --> 00:33:28.934
Even though we're messing
with the data flow,

00:33:28.934 --> 00:33:30.267
you can't see that.

00:33:30.267 --> 00:33:31.968
So you can't mess yourself up

00:33:31.968 --> 00:33:34.167
by using our infrastructure
that way.

00:33:34.167 --> 00:33:38.033
Also failed DTs
throw an exception.

00:33:38.033 --> 00:33:39.400
Oops.
That's not true any more.

00:33:39.400 --> 00:33:42.234
Anyway, we leave distributed
transactions around

00:33:42.234 --> 00:33:43.234
after they're completed,

00:33:43.234 --> 00:33:44.234
so you can query them.

00:33:44.234 --> 00:33:46.534
See, distributed
transactions are...

00:33:46.534 --> 00:33:47.601
They're synchronous issue

00:33:47.601 --> 00:33:48.934
and asynchronous complete.

00:33:48.934 --> 00:33:50.400
You don't know
when they'll complete,

00:33:50.400 --> 00:33:51.801
'cause your thread
might time out.

00:33:51.801 --> 00:33:53.734
So they stay in the database

00:33:53.734 --> 00:33:57.901
so that other threads
of your application

00:33:57.901 --> 00:33:59.367
can actually report
that to the user.

00:33:59.367 --> 00:34:01.067
This action you took, user,

00:34:01.067 --> 00:34:02.801
I'm imagining an Ajax UI.

00:34:02.801 --> 00:34:03.801
We're in another window.

00:34:03.801 --> 00:34:04.801
You say, you know,

00:34:04.801 --> 00:34:06.501
"This action
you took succeeded.

00:34:06.501 --> 00:34:08.300
"This one succeeded.
Sorry, this one failed.

00:34:08.300 --> 00:34:09.467
"You might want to retry that.

00:34:09.467 --> 00:34:10.901
"But since
the database has changed,

00:34:10.901 --> 00:34:12.834
you might want to check it out
before you retry it."

00:34:12.834 --> 00:34:14.167
So you can really have

00:34:14.167 --> 00:34:16.200
a very professional
conversation with the user.

00:34:16.200 --> 00:34:17.834
"These are
exactly what succeeded,

00:34:17.834 --> 00:34:19.000
This is exactly what failed."

00:34:19.000 --> 00:34:21.200
The user
doesn't have to guess.

00:34:21.200 --> 00:34:23.300
And then the client code,

00:34:23.300 --> 00:34:25.267
the calling client code,

00:34:25.267 --> 00:34:28.367
can delete the distributed
transaction objects

00:34:28.367 --> 00:34:30.501
when it's sure
it has informed the user,

00:34:30.501 --> 00:34:33.734
and the user knows
what they need to know.

00:34:33.734 --> 00:34:37.501
So this is a way
to really do crisp apps

00:34:37.501 --> 00:34:38.601
with very clean semantics,

00:34:38.601 --> 00:34:40.234
where there's nothing
funny like,

00:34:40.234 --> 00:34:42.601
"Oh, I did something,
and, well, it didn't happen.

00:34:42.601 --> 00:34:43.601
I wonder why."

00:34:43.601 --> 00:34:45.067
You know, you can find out.

00:34:45.067 --> 00:34:46.100
The user can find out.

00:34:46.100 --> 00:34:47.133
So the whole vision

00:34:47.133 --> 00:34:49.067
is to write
enterprise-ready apps

00:34:49.067 --> 00:34:50.234
where you can write a bank,

00:34:50.234 --> 00:34:51.901
and, you know,
if you try to transfer money

00:34:51.901 --> 00:34:52.901
and it doesn't happen,

00:34:52.901 --> 00:34:54.234
you can tell
the user precisely,

00:34:54.234 --> 00:34:55.267
"That did not happen.

00:34:55.267 --> 00:34:56.334
For sure it didn't happen."

00:34:56.334 --> 00:34:57.501
Not, "Oh, this seems to--

00:34:57.501 --> 00:35:02.567
I guess it doesn't seem
to have happened."

00:35:02.567 --> 00:35:04.367
We don't handle queries.

00:35:04.367 --> 00:35:06.968
That's because
queries are hard.

00:35:06.968 --> 00:35:08.968
The ability to handle queries

00:35:08.968 --> 00:35:11.033
depends a lot on the semantics
of the query predicate.

00:35:11.033 --> 00:35:14.334
Also even local transactions
in App Engine

00:35:14.334 --> 00:35:15.934
do not honor queries.

00:35:15.934 --> 00:35:17.601
Ryan is nodding his head.

00:35:17.601 --> 00:35:19.868
But soon maybe some of them?

00:35:19.868 --> 00:35:21.501
Oh, sorry.

00:35:21.501 --> 00:35:22.834
Maybe I shouldn't
have said that.

00:35:22.834 --> 00:35:24.901
Oops. Sorry.

00:35:24.901 --> 00:35:25.968
No.

00:35:25.968 --> 00:35:27.300
[laughing]
They don't handle...

00:35:27.300 --> 00:35:29.567
So queries are really tough.

00:35:29.567 --> 00:35:31.934
And one thing you can do,

00:35:31.934 --> 00:35:33.701
and I'm not quite sure
what the semantics is,

00:35:33.701 --> 00:35:35.267
but you can do a query

00:35:35.267 --> 00:35:36.634
and then take
all the objects you got

00:35:36.634 --> 00:35:39.300
and mark them as read
in a distributive transaction,

00:35:39.300 --> 00:35:41.334
and that
will give you something.

00:35:41.334 --> 00:35:43.567
But I'd have to think
exactly what it would give you.

00:35:43.567 --> 00:35:44.901
We need future work on that.

00:35:44.901 --> 00:35:46.667
Maybe Google will hire me
to work on that.

00:35:46.667 --> 00:35:48.467
I don't know.

00:35:48.467 --> 00:35:49.467
They have a hiring freeze.

00:35:49.467 --> 00:35:50.467
He tried to get me hired,

00:35:50.467 --> 00:35:52.501
but they have a hiring freeze.

00:35:52.501 --> 00:35:54.934
ACID correctness
example isolation.

00:35:54.934 --> 00:35:56.133
Ah, yes.

00:35:56.133 --> 00:35:58.000
Here's an example
of why you need ACID.

00:35:58.000 --> 00:35:59.400
This is from Simon.

00:35:59.400 --> 00:36:02.267
So distributed
transaction one

00:36:02.267 --> 00:36:04.267
gets write locks
on two objects,

00:36:04.267 --> 00:36:05.667
and has written object A.

00:36:05.667 --> 00:36:08.300
It has written
the new balance for Alice,

00:36:08.300 --> 00:36:10.300
but not the new balance
for Bob.

00:36:10.300 --> 00:36:12.701
The other
distributed transaction--

00:36:12.701 --> 00:36:14.534
Oh, and then DT1 is paused.

00:36:14.534 --> 00:36:15.567
I don't know.

00:36:15.567 --> 00:36:17.801
Gets swapped out
or gets scheduled out.

00:36:17.801 --> 00:36:21.434
DT2 now comes and reads
the state of A and B.

00:36:21.434 --> 00:36:23.000
So it sees that Alice
has lost $10,

00:36:23.000 --> 00:36:25.901
but not that Bob has gained
$10, or whichever.

00:36:25.901 --> 00:36:29.234
DT2 has read
a state of the database

00:36:29.234 --> 00:36:30.968
that does not
satisfy the invariant.

00:36:30.968 --> 00:36:33.834
DT2 must die.
It must be doomed.

00:36:33.834 --> 00:36:35.334
We cannot let it complete.

00:36:35.334 --> 00:36:36.934
We must abort DT2.

00:36:36.934 --> 00:36:38.434
And we do guarantee

00:36:38.434 --> 00:36:41.834
that if this happens,
DT2 will abort,

00:36:41.834 --> 00:36:44.067
and the reason it will abort

00:36:44.067 --> 00:36:45.067
is because when DT2--

00:36:45.067 --> 00:36:47.067
when it goes to commit,

00:36:47.067 --> 00:36:48.934
when DT2 checks
the version number

00:36:48.934 --> 00:36:52.501
for object B,

00:36:52.501 --> 00:36:56.501
it will fail.

00:36:56.501 --> 00:36:58.200
Well, there'll be either
a lock on object B,

00:36:58.200 --> 00:37:01.167
or the version number check
will fail.

00:37:01.167 --> 00:37:03.601
Oh, yeah, this is--

00:37:03.601 --> 00:37:05.534
Yeah, there'll be a lock,
so it'll fail.

00:37:05.534 --> 00:37:07.534
Anyway, there's various
different ways it can fail

00:37:07.534 --> 00:37:09.133
depending on
when things get scheduled,

00:37:09.133 --> 00:37:12.701
but it will definitely fail.

00:37:12.701 --> 00:37:18.100
Here's that example written out
in painful detail.

00:37:18.100 --> 00:37:20.234
I'm not sure if you really want
me to go through this example.

00:37:20.234 --> 00:37:22.200
Anybody want me
to go through it?

00:37:22.200 --> 00:37:24.901
Wow. Nope. Okay.

00:37:24.901 --> 00:37:26.300
Future work.

00:37:26.300 --> 00:37:27.467
We'd like to do queries.

00:37:27.467 --> 00:37:29.100
It's very dependent
on the predicate.

00:37:29.100 --> 00:37:30.634
We need the--

00:37:30.634 --> 00:37:32.067
Do we really need to rely

00:37:32.067 --> 00:37:33.534
on underlying
strong consistency?

00:37:33.534 --> 00:37:35.334
Google App Engine provides it,
so that's cool,

00:37:35.334 --> 00:37:36.400
but maybe you could use this

00:37:36.400 --> 00:37:37.667
on other infrastructures.

00:37:37.667 --> 00:37:39.501
We don't actually
provide strong consistency

00:37:39.501 --> 00:37:42.367
to some degree.

00:37:42.367 --> 00:37:45.100
You have to do queries
to find out

00:37:45.100 --> 00:37:46.634
when you issue a transaction,
you know,

00:37:46.634 --> 00:37:48.200
did it complete?

00:37:48.200 --> 00:37:50.501
So you can kind of do it,

00:37:50.501 --> 00:37:52.300
but you've got to keep asking,

00:37:52.300 --> 00:37:54.133
"Did this distributed
transaction complete?"

00:37:54.133 --> 00:37:57.167
So you can probably get it
if you work.

00:37:57.167 --> 00:37:59.968
We can add that.

00:37:59.968 --> 00:38:01.534
Performance.

00:38:01.534 --> 00:38:04.033
I'm not an expert
on the deep,

00:38:04.033 --> 00:38:07.267
underlying layers
under Google App Engine,

00:38:07.267 --> 00:38:09.267
but Erick Armbrust
at least did

00:38:09.267 --> 00:38:11.067
one really cool optimization

00:38:11.067 --> 00:38:12.234
where shadow objects

00:38:12.234 --> 00:38:13.834
actually aren't
manifested as objects.

00:38:13.834 --> 00:38:16.234
They're just a string
which is in the protocol

00:38:16.234 --> 00:38:18.734
that Google sends over the wire
to other machines.

00:38:18.734 --> 00:38:20.901
So there are people at Google--

00:38:20.901 --> 00:38:22.767
The reason to do this
is open source,

00:38:22.767 --> 00:38:24.400
is because, you know,

00:38:24.400 --> 00:38:26.634
people at Google
can help me get it right, A,

00:38:26.634 --> 00:38:28.934
and, B, do the cool
optimizations underneath,

00:38:28.934 --> 00:38:30.367
and, C, I get
to come talk to you guys.

00:38:30.367 --> 00:38:33.801
So...conclusion.

00:38:33.801 --> 00:38:35.734
Ryan said, "You have to have
a conclusion slide."

00:38:35.734 --> 00:38:37.167
What does it say?

00:38:37.167 --> 00:38:40.300
"Distributed Transactions
on Google App Engine exist."

00:38:40.300 --> 00:38:44.000
Or sometime
in the next month or two

00:38:44.000 --> 00:38:47.133
we'll get them released.

00:38:47.133 --> 00:38:48.467
And let us know
if they help you,

00:38:48.467 --> 00:38:49.467
or let me know,
I guess,

00:38:49.467 --> 00:38:51.234
or write any of us,
I suppose.

00:38:51.234 --> 00:38:53.167
Probably Ryan would want
to hear from you as well.

00:38:53.167 --> 00:38:55.067
Yeah,
he's nodding his head.

00:38:55.067 --> 00:38:56.601
That's pretty much it.

00:38:56.601 --> 00:39:00.934
I'd love to take questions
if you have them.

00:39:00.934 --> 00:39:01.934
Thank you.

00:39:01.934 --> 00:39:06.200
[applause]

00:39:06.200 --> 00:39:07.267
Yes, sir.

00:39:07.267 --> 00:39:08.667
Would you guys
mind using the mics?

00:39:08.667 --> 00:39:10.200
They asked me to ask you
to use the mics.

00:39:10.200 --> 00:39:11.501
I can repeat questions

00:39:11.501 --> 00:39:14.534
if you're in a wheelchair
or something, but...

00:39:21.934 --> 00:39:24.300
man: So is this gonna be
a library that's released

00:39:24.300 --> 00:39:26.167
that we can use
in our application,

00:39:26.167 --> 00:39:27.167
or is it gonna be built

00:39:27.167 --> 00:39:29.100
in the Google App Engine
itself?

00:39:29.100 --> 00:39:30.234
Wilkerson:
Erick Armbrust

00:39:30.234 --> 00:39:33.100
is releasing
his implementation

00:39:33.100 --> 00:39:36.334
as a personal, open-source
project at Google.

00:39:36.334 --> 00:39:38.934
So it will be released
as part of...

00:39:38.934 --> 00:39:42.133
I think, in fact,
he's gonna call it Tapioca.

00:39:42.133 --> 00:39:44.467
Or Tapioca ORM,

00:39:44.467 --> 00:39:45.934
which has an R in it
for "Relational,"

00:39:45.934 --> 00:39:47.868
even though there's nothing
relational going on,

00:39:47.868 --> 00:39:49.167
which drives me nuts,

00:39:49.167 --> 00:39:51.767
but anyway I couldn't get Erick
to change that.

00:39:51.767 --> 00:39:53.033
Yeah,
so it'll be a library.

00:39:53.033 --> 00:39:54.334
You'll be able to--

00:39:54.334 --> 00:39:56.934
It's for the Java version
of App Engine right now.

00:39:56.934 --> 00:39:58.801
I asked, "Will this work
for Python too?"

00:39:58.801 --> 00:39:59.834
They said no.

00:39:59.834 --> 00:40:01.067
Sorry.

00:40:01.067 --> 00:40:08.467
So if you're writing
App Engine apps in Java,

00:40:08.467 --> 00:40:09.901
you'll be able to use it
as a library,

00:40:09.901 --> 00:40:12.701
as an open-source library.
Yeah.

00:40:15.968 --> 00:40:17.901
Please.

00:40:20.567 --> 00:40:21.567
Hey, Ryan.

00:40:21.567 --> 00:40:22.801
Barrett:
Hey, Dan.

00:40:22.801 --> 00:40:24.601
So you talked a little bit
about roll-forward.

00:40:24.601 --> 00:40:27.400
And so most people,
myself included,

00:40:27.400 --> 00:40:29.934
have more background with
rollback than roll-forward.

00:40:29.934 --> 00:40:32.100
Do you want to talk about
the difference between the two

00:40:32.100 --> 00:40:33.200
and why this is roll-forward?

00:40:33.200 --> 00:40:37.501
Wilkerson:
Oh, right.

00:40:37.501 --> 00:40:38.901
Ryan's the one who suggested

00:40:38.901 --> 00:40:42.868
that this be an optimistic
transaction protocol,

00:40:42.868 --> 00:40:44.667
and I don't know if
I would have thought of that

00:40:44.667 --> 00:40:45.934
without his suggestion.

00:40:45.934 --> 00:40:47.734
In fact, he had to suggest it
to me repeatedly,

00:40:47.734 --> 00:40:49.334
'cause I kept trying
to do it another way.

00:40:49.334 --> 00:40:51.601
So that was very helpful.
So thanks, Ryan.

00:40:51.601 --> 00:40:52.834
And I think
it's because of that

00:40:52.834 --> 00:40:54.367
that we have roll-forward.

00:40:54.367 --> 00:40:58.334
Basically, when
the client function is running,

00:40:58.334 --> 00:41:00.367
if anything goes wrong,
abort.

00:41:00.367 --> 00:41:02.567
Once the client function
is done,

00:41:02.567 --> 00:41:05.767
now the client function
has basically created a map

00:41:05.767 --> 00:41:07.133
where it did some reads

00:41:07.133 --> 00:41:09.334
and it wrote them
to some writes.

00:41:09.334 --> 00:41:12.667
It's just a finite diff
on your database.

00:41:12.667 --> 00:41:13.868
And now all we have to do

00:41:13.868 --> 00:41:15.634
is apply that diff.

00:41:15.634 --> 00:41:20.200
Preserving atomicity
and isolation.

00:41:20.200 --> 00:41:22.834
Well, the entire result

00:41:22.834 --> 00:41:23.834
of what the client did,

00:41:23.834 --> 00:41:24.834
that whole diff,

00:41:24.834 --> 00:41:26.634
the change to the database,

00:41:26.634 --> 00:41:28.300
that delta to the database,

00:41:28.300 --> 00:41:29.934
is written in the database

00:41:29.934 --> 00:41:31.367
as objects in the database.

00:41:31.367 --> 00:41:32.801
It's in shadow objects.

00:41:32.801 --> 00:41:36.200
It's in the distributed
transaction object.

00:41:36.200 --> 00:41:40.367
There's no need--

00:41:40.367 --> 00:41:41.367
Okay, so...

00:41:41.367 --> 00:41:43.834
It still might fail,

00:41:43.834 --> 00:41:44.868
because there's checks.

00:41:44.868 --> 00:41:46.000
We have to get locks.

00:41:46.000 --> 00:41:48.200
We have to check
read object version numbers,

00:41:48.200 --> 00:41:49.200
and we have to get locks

00:41:49.200 --> 00:41:50.567
on the written objects.

00:41:50.567 --> 00:41:52.300
If any of that fails,

00:41:52.300 --> 00:41:54.667
then your transaction's
gonna abort,

00:41:54.667 --> 00:41:56.834
and we're gonna throw
the whole thing away.

00:41:56.834 --> 00:41:58.400
But once you have locks

00:41:58.400 --> 00:42:00.033
and you've checked
the version numbers,

00:42:00.033 --> 00:42:01.601
at this point,

00:42:01.601 --> 00:42:02.901
nothing can go wrong.

00:42:02.901 --> 00:42:05.334
And my way of thinking
about what is two-phase commit,

00:42:05.334 --> 00:42:06.734
in the first phase,
do all the work,

00:42:06.734 --> 00:42:08.968
and get it set up
so that nothing can go wrong.

00:42:08.968 --> 00:42:10.834
And phase two,
throw the switch.

00:42:10.834 --> 00:42:11.968
That's basically what we do.

00:42:11.968 --> 00:42:13.067
Once you have all the locks,

00:42:13.067 --> 00:42:14.701
you've checked
all the version numbers,

00:42:14.701 --> 00:42:15.701
nothing can go wrong.

00:42:15.701 --> 00:42:16.968
So if you time out,

00:42:16.968 --> 00:42:18.868
which happens on App Engine
all the time, right?

00:42:18.868 --> 00:42:20.834
App Engine comes
and times you out.

00:42:20.834 --> 00:42:24.100
There's no reason that we have
to abort your transaction.

00:42:24.100 --> 00:42:26.100
In fact,
once you've started copying

00:42:26.100 --> 00:42:29.200
shadow objects
to written objects

00:42:29.200 --> 00:42:30.467
and you've copied
a few of them,

00:42:30.467 --> 00:42:32.267
you can't go back.

00:42:32.267 --> 00:42:33.868
It's in there.

00:42:33.868 --> 00:42:35.901
You must roll forward
to completion.

00:42:35.901 --> 00:42:37.167
There's no going back.

00:42:37.167 --> 00:42:39.334
There's no way
for us to undo that.

00:42:39.334 --> 00:42:41.901
So if you time out,

00:42:41.901 --> 00:42:43.767
and another thread locks
on the same objects

00:42:43.767 --> 00:42:44.934
or a background thread says,

00:42:44.934 --> 00:42:46.501
"Hey, what's this old DT
from yesterday

00:42:46.501 --> 00:42:47.767
doing lying around,"

00:42:47.767 --> 00:42:50.934
those threads can roll you
forward to completion,

00:42:50.934 --> 00:42:52.400
and there's nothing
that can go wrong

00:42:52.400 --> 00:42:55.934
other than being delayed
by more timeouts.

00:42:55.934 --> 00:42:59.934
Rollback would be,
I suppose, if, I don't know...

00:42:59.934 --> 00:43:01.701
I had to learn
about databases in order to--

00:43:01.701 --> 00:43:02.767
I'm trained as a theory guy

00:43:02.767 --> 00:43:04.300
and a software guy
and maybe PL guy,

00:43:04.300 --> 00:43:06.467
but I'm not a database guy,
or wasn't.

00:43:06.467 --> 00:43:08.868
I don't know how
rollback works, actually,

00:43:08.868 --> 00:43:12.701
so whatever it is,
we don't do it,

00:43:12.701 --> 00:43:13.868
'cause I don't understand it.

00:43:13.868 --> 00:43:16.634
Yeah. Please.

00:43:16.634 --> 00:43:17.868
man: Hey.
I have two questions.

00:43:17.868 --> 00:43:19.234
Wilkerson:
Please.

00:43:19.234 --> 00:43:21.033
man: I don't quite
understand what you mean--

00:43:21.033 --> 00:43:23.200
Wilkerson: Could you speak
a little bit closer to the mic?

00:43:23.200 --> 00:43:24.334
man:
Oh, excuse me.

00:43:24.334 --> 00:43:25.868
I don't quite
understand what you mean

00:43:25.868 --> 00:43:27.801
when you say the DT is
synchronized when it's issued,

00:43:27.801 --> 00:43:28.801
but not synchronized...

00:43:28.801 --> 00:43:30.133
Wilkerson:
When it completes.

00:43:30.133 --> 00:43:31.133
man:
Who sees what where?

00:43:31.133 --> 00:43:32.133
I mean, what is--
Yeah.

00:43:32.133 --> 00:43:33.133
Wilkerson:
Very good.

00:43:33.133 --> 00:43:34.634
Thank you.
Great question.

00:43:34.634 --> 00:43:36.667
If I'm the client code,

00:43:36.667 --> 00:43:37.667
I have two parts.

00:43:37.667 --> 00:43:39.100
I have the caller code,

00:43:39.100 --> 00:43:41.467
which says,
"Gee, I need to update--

00:43:41.467 --> 00:43:42.901
I need to send $10
from Alice to Bob."

00:43:42.901 --> 00:43:45.334
Then that code, your code,

00:43:45.334 --> 00:43:47.767
calls, "Run
indistributed transaction,"

00:43:47.767 --> 00:43:48.767
my code,

00:43:48.767 --> 00:43:51.300
but you hand me a function

00:43:51.300 --> 00:43:53.200
called transfer,

00:43:53.200 --> 00:43:56.067
with arguments
Alice, Bob, and $10.

00:43:56.067 --> 00:44:00.868
So then I run your function
for you, okay?

00:44:00.868 --> 00:44:02.100
So that's all synchronous.

00:44:02.100 --> 00:44:04.868
You called me,
I called your function back.

00:44:04.868 --> 00:44:06.801
You know,
that's normal code.

00:44:06.801 --> 00:44:08.801
If function F
calls function G,

00:44:08.801 --> 00:44:09.801
function F pauses,

00:44:09.801 --> 00:44:11.667
function G
gets a new stack frame.

00:44:11.667 --> 00:44:12.667
Function G returns.

00:44:12.667 --> 00:44:13.667
Function F then resumes.

00:44:13.667 --> 00:44:14.667
That's all synchronous.

00:44:14.667 --> 00:44:15.734
That's what you're used to.

00:44:15.734 --> 00:44:18.067
However,
if you tell me

00:44:18.067 --> 00:44:22.901
to run your function in
a distributed transaction,

00:44:22.901 --> 00:44:24.567
what can happen is
while that's happening,

00:44:24.567 --> 00:44:25.767
your code can take so long

00:44:25.767 --> 00:44:27.534
or there can be so many delays
in the database,

00:44:27.534 --> 00:44:29.300
it can all timeout.

00:44:29.300 --> 00:44:31.534
Google can come
and just time you out.

00:44:31.534 --> 00:44:33.400
And then boop, it's timed out.

00:44:33.400 --> 00:44:35.033
There's nothing
I can do about that.

00:44:35.033 --> 00:44:36.801
That's part of the constraints
of App Engine.

00:44:36.801 --> 00:44:38.467
However,
that distributed transaction,

00:44:38.467 --> 00:44:39.467
if it got far enough,

00:44:39.467 --> 00:44:41.701
it's in there in the database.

00:44:41.701 --> 00:44:43.300
It just hasn't applied yet.

00:44:43.300 --> 00:44:45.801
So some other thread
may discover it.

00:44:45.801 --> 00:44:48.234
In fact, the user
will probably hit reload,

00:44:48.234 --> 00:44:49.534
or, "What the heck?"

00:44:49.534 --> 00:44:50.934
And they'll say,
"What happened?"

00:44:50.934 --> 00:44:52.567
Somehow your user

00:44:52.567 --> 00:44:54.400
will come an interact
with the database again.

00:44:54.400 --> 00:44:57.033
Your calling code
ought to query the database,

00:44:57.033 --> 00:44:59.534
find any pending
distributed transactions

00:44:59.534 --> 00:45:02.267
by that same user
that haven't completed yet,

00:45:02.267 --> 00:45:04.434
and go,
"Hey, I didn't finish this."

00:45:04.434 --> 00:45:06.033
And then call us and go,

00:45:06.033 --> 00:45:07.934
"Hey, finish
rolling that forward."

00:45:07.934 --> 00:45:09.734
That might timeout again.

00:45:09.734 --> 00:45:11.200
Some background thread
might find it

00:45:11.200 --> 00:45:12.400
and finish rolling it forward.

00:45:12.400 --> 00:45:14.267
In any case,
the completion,

00:45:14.267 --> 00:45:16.000
you never quite know
when it's gonna happen,

00:45:16.000 --> 00:45:17.534
'cause your code
could take ten hours,

00:45:17.534 --> 00:45:18.968
and every ten seconds

00:45:18.968 --> 00:45:20.601
App Engine's timing you out.

00:45:20.601 --> 00:45:22.400
So there could be a lot
of different threads

00:45:22.400 --> 00:45:23.467
that have to discover that,

00:45:23.467 --> 00:45:24.634
roll it forward a bit further.

00:45:24.634 --> 00:45:25.634
Finally it completes.

00:45:25.634 --> 00:45:27.434
It'll complete who knows when,

00:45:27.434 --> 00:45:29.100
but whenever it completes,

00:45:29.100 --> 00:45:30.767
your threads may not be around.

00:45:30.767 --> 00:45:31.767
Somebody else's threads

00:45:31.767 --> 00:45:32.767
maybe have tried to lock

00:45:32.767 --> 00:45:33.767
one of the same objects

00:45:33.767 --> 00:45:35.100
and have
rolled it forward for you

00:45:35.100 --> 00:45:36.534
and completed it for you.

00:45:36.534 --> 00:45:38.567
Now it's sitting there
in the database, completed.

00:45:38.567 --> 00:45:40.167
And it's sitting there.
"I'm complete."

00:45:40.167 --> 00:45:43.334
Then your user comes back...

00:45:43.334 --> 00:45:47.100
and you find it lying around,

00:45:47.100 --> 00:45:49.234
and you go, "Ah,
this completed asynchronously.

00:45:49.234 --> 00:45:50.801
It completed some other time."

00:45:50.801 --> 00:45:52.901
And there's really
no way around this.

00:45:52.901 --> 00:45:54.501
If you write code
that takes long enough,

00:45:54.501 --> 00:45:55.734
there's no way I can prevent,

00:45:55.734 --> 00:45:56.868
in the presence of timeouts,

00:45:56.868 --> 00:45:58.300
there's no way
I can prevent the need

00:45:58.300 --> 00:46:00.534
for sometimes asynchronous
completes to happen.

00:46:00.534 --> 00:46:02.234
So it'll complete.

00:46:02.234 --> 00:46:03.934
If it completes synchronously,

00:46:03.934 --> 00:46:05.534
if you say, "Run this,"

00:46:05.534 --> 00:46:08.167
and it completes synchronously,

00:46:08.167 --> 00:46:10.734
you get the distributed
transaction object back,

00:46:10.734 --> 00:46:13.033
and it has a return value.

00:46:13.033 --> 00:46:14.534
This is my recommended idiom

00:46:14.534 --> 00:46:15.968
that they do
in the implementation.

00:46:15.968 --> 00:46:17.167
It would have the return value.

00:46:17.167 --> 00:46:19.133
If it failed,
it would have why it failed,

00:46:19.133 --> 00:46:20.234
the exception value.

00:46:20.234 --> 00:46:22.033
It would also have
the function you called.

00:46:22.033 --> 00:46:23.868
So you could say,
"You were trying to do what?

00:46:23.868 --> 00:46:25.400
"Oh, yesterday you were trying

00:46:25.400 --> 00:46:26.567
"to send $10
from Alice to Bob.

00:46:26.567 --> 00:46:27.901
"Oh,
let me put that in the UI.

00:46:27.901 --> 00:46:29.400
"That thing
you tried to do yesterday,

00:46:29.400 --> 00:46:30.400
"it completed.

00:46:30.400 --> 00:46:31.601
Let me send that to you,
user."

00:46:31.601 --> 00:46:34.334
So you could
complete synchronously,

00:46:34.334 --> 00:46:35.467
but if you timeout,

00:46:35.467 --> 00:46:36.934
you could complete
asynchronously,

00:46:36.934 --> 00:46:38.400
and have to discover
that fact later.

00:46:38.400 --> 00:46:39.400
With a query.

00:46:39.400 --> 00:46:40.868
I thought about how--

00:46:40.868 --> 00:46:42.234
And I'm not just a theory guy.

00:46:42.234 --> 00:46:44.434
I thought about how
to write the code to do that.

00:46:44.434 --> 00:46:45.701
And there's a nice way
to do it,

00:46:45.701 --> 00:46:46.734
so you can discover things

00:46:46.734 --> 00:46:48.133
to show 'em to the user.

00:46:48.133 --> 00:46:49.834
man: So you're saying
we'll be able to query

00:46:49.834 --> 00:46:51.334
the distributed
transaction itself

00:46:51.334 --> 00:46:53.133
to ask it,
"Are you complete?" Or--?

00:46:53.133 --> 00:46:54.267
Wilkerson:
You can query

00:46:54.267 --> 00:46:56.133
the distributed transaction
infrastructure.

00:46:56.133 --> 00:46:57.234
Go,
"Hey, does this user

00:46:57.234 --> 00:46:59.000
"have any pending
distributed transactions

00:46:59.000 --> 00:47:00.334
"lying around
that aren't done?

00:47:00.334 --> 00:47:01.501
"Do those first,

00:47:01.501 --> 00:47:03.300
"or tell me so that
I can tell the user.

00:47:03.300 --> 00:47:04.634
"Or are there some
that are done,

00:47:04.634 --> 00:47:05.701
and I should tell the user?"

00:47:05.701 --> 00:47:07.801
You can query it for that.

00:47:07.801 --> 00:47:09.000
man:
Well, the second one was,

00:47:09.000 --> 00:47:11.100
if this works
as you say it works,

00:47:11.100 --> 00:47:13.701
what would the point
of entity groups be in it?

00:47:13.701 --> 00:47:15.534
Wilkerson: Because
you might have something

00:47:15.534 --> 00:47:17.133
you can do with
only local transactions.

00:47:17.133 --> 00:47:18.133
Those will be faster.

00:47:18.133 --> 00:47:19.868
Our infrastructure costs you.

00:47:19.868 --> 00:47:22.000
Man, we really
worked on it for months

00:47:22.000 --> 00:47:23.067
to try to minimize the cost.

00:47:23.067 --> 00:47:24.567
Erick put stuff in there.

00:47:24.567 --> 00:47:26.634
Rob thought
of some optimizations.

00:47:26.634 --> 00:47:28.300
We really tried
to minimize the impact.

00:47:28.300 --> 00:47:30.567
But if you can do something
with only local transactions,

00:47:30.567 --> 00:47:32.701
go ahead,
because they'll be faster.

00:47:32.701 --> 00:47:33.801
man:
But, I mean, like,

00:47:33.801 --> 00:47:34.901
you could put entity groups

00:47:34.901 --> 00:47:36.200
around every single property,

00:47:36.200 --> 00:47:37.968
what you're currently
putting around, like,

00:47:37.968 --> 00:47:39.367
user spaces,

00:47:39.367 --> 00:47:42.033
and it'd be the same with
distributed transactions.

00:47:42.033 --> 00:47:44.167
Wilkerson:
You could put entity groups--

00:47:44.167 --> 00:47:45.334
In fact, you can--

00:47:45.334 --> 00:47:46.801
Erick was like,
"No, I want people

00:47:46.801 --> 00:47:47.901
"to be able to use them both.

00:47:47.901 --> 00:47:49.334
"And if you have
an entity group,

00:47:49.334 --> 00:47:51.767
some objects can be distributed
transactions and some local."

00:47:51.767 --> 00:47:53.634
I was like, "Erick,
nobody's gonna need that."

00:47:53.634 --> 00:47:55.434
He's like, "No,
there's this optimization.

00:47:55.434 --> 00:47:57.267
Sometimes you got
to group things for speed."

00:47:57.267 --> 00:47:59.501
And he made it all work.
So you can have--

00:47:59.501 --> 00:48:01.767
Evidently, he's told me
you can have an entity group.

00:48:01.767 --> 00:48:04.334
Some objects in there
you do transactions

00:48:04.334 --> 00:48:05.767
to the distributed
infrastructure.

00:48:05.767 --> 00:48:06.868
And others you do with local.

00:48:06.868 --> 00:48:08.868
But if you try to mix them,

00:48:08.868 --> 00:48:12.367
it'll have to go
to distributed for all of them.

00:48:12.367 --> 00:48:13.534
That answer your question?

00:48:13.534 --> 00:48:14.567
man:
Yeah, thank you.

00:48:14.567 --> 00:48:15.567
Wilkerson:
Cool.

00:48:15.567 --> 00:48:16.868
We try to think of everything.

00:48:16.868 --> 00:48:18.968
We really wanted it to work
in reality for you guys.

00:48:18.968 --> 00:48:20.901
I spent a long time
trying to think of--

00:48:20.901 --> 00:48:22.234
Yes, please.

00:48:22.234 --> 00:48:25.300
man: So are you saying
that the application then

00:48:25.300 --> 00:48:27.868
has to check
if there were transactions

00:48:27.868 --> 00:48:29.467
that completed

00:48:29.467 --> 00:48:32.734
but weren't...

00:48:32.734 --> 00:48:33.934
What is it called?

00:48:33.934 --> 00:48:35.701
Wilkerson:
The completed asynchronously.

00:48:35.701 --> 00:48:37.000
You issued a request.
man: Yeah.

00:48:37.000 --> 00:48:38.701
Wilkerson:
"In a distributed transaction,

00:48:38.701 --> 00:48:40.267
please transfer $10
from Alice to Bob."

00:48:40.267 --> 00:48:41.267
But for some reason,

00:48:41.267 --> 00:48:42.601
that has
to go recompile Mozilla.

00:48:42.601 --> 00:48:43.934
Okay,
so that takes a long time.

00:48:43.934 --> 00:48:46.067
That doesn't return
in the timeout window.

00:48:46.067 --> 00:48:48.100
You got, like, ten seconds,
is it, Ryan? Something?

00:48:48.100 --> 00:48:49.100
Barrett:
30.

00:48:49.100 --> 00:48:50.100
Wilkerson:
30 seconds.

00:48:50.100 --> 00:48:51.267
Oh, they got generous.

00:48:51.267 --> 00:48:52.801
Now you got 30 seconds

00:48:52.801 --> 00:48:54.100
for it to do something,
you know?

00:48:54.100 --> 00:48:55.767
But if it doesn't come back
in 30 seconds,

00:48:55.767 --> 00:48:58.434
then it might still succeed,
but later.

00:48:58.434 --> 00:48:59.767
If it does come back
in 30 seconds,

00:48:59.767 --> 00:49:01.934
you get
a synchronous return back.

00:49:01.934 --> 00:49:03.601
man:
So if it succeeds later,

00:49:03.601 --> 00:49:06.000
do I still
have to have in my code

00:49:06.000 --> 00:49:08.234
checks to see
if there are any pending ones

00:49:08.234 --> 00:49:10.567
and then ask for them
to be completed?

00:49:10.567 --> 00:49:12.734
Wilkerson:
Unless a background thread--

00:49:12.734 --> 00:49:14.801
Somebody else's thread
or the background thread

00:49:14.801 --> 00:49:15.801
may have done it for you,

00:49:15.801 --> 00:49:17.634
but you still have to check--

00:49:17.634 --> 00:49:19.801
Even if it got completed,

00:49:19.801 --> 00:49:22.067
even if someone else
rolls them all forward for you

00:49:22.067 --> 00:49:23.267
and they're all completed,

00:49:23.267 --> 00:49:24.367
you still have to check--

00:49:24.367 --> 00:49:26.133
"Hey, are there
any completed tasks

00:49:26.133 --> 00:49:27.133
"that got done?

00:49:27.133 --> 00:49:28.133
"Oh, well, thank you.

00:49:28.133 --> 00:49:29.334
Let me tell the user."

00:49:29.334 --> 00:49:32.133
'Cause how can I otherwise
tell you, right?

00:49:32.133 --> 00:49:34.734
man: No, I'm thinking
if I don't care, right?

00:49:34.734 --> 00:49:36.234
I've got this transaction

00:49:36.234 --> 00:49:40.000
and it either succeeds
or fails, right?

00:49:40.000 --> 00:49:42.467
Wilkerson: It will eventually
succeed or fail.

00:49:42.467 --> 00:49:43.767
Unfortunately
it can starve---

00:49:43.767 --> 00:49:45.334
Man: So I don't need
to do anything else?

00:49:45.334 --> 00:49:47.200
Wilkerson: If you want
to absolutely make sure

00:49:47.200 --> 00:49:48.167
it doesn't starve,

00:49:48.167 --> 00:49:49.367
and you're kind of wondering

00:49:49.367 --> 00:49:50.367
the background thread

00:49:50.367 --> 00:49:51.667
might take a while
to get around,

00:49:51.667 --> 00:49:53.467
you can do background stuff
in App Engine now.

00:49:53.467 --> 00:49:56.100
If you want to rely
on the background thread

00:49:56.100 --> 00:49:57.734
to find old distributed
transactions

00:49:57.734 --> 00:49:59.400
and keep pushing on 'em
till they're done,

00:49:59.400 --> 00:50:01.033
and that thing's
pretty aggressive,

00:50:01.033 --> 00:50:02.734
then, yeah, there's nothing
you have to do.

00:50:02.734 --> 00:50:04.200
It will abort
or it will succeed.

00:50:04.200 --> 00:50:05.200
man:
All right.

00:50:05.200 --> 00:50:07.968
Wilkerson:
Yeah.

00:50:07.968 --> 00:50:09.534
One or the other,
eventually.

00:50:09.534 --> 00:50:10.767
Yeah. Please.

00:50:10.767 --> 00:50:12.467
man: Probably related
to his question was,

00:50:12.467 --> 00:50:15.133
did you look at stability
as a factor

00:50:15.133 --> 00:50:17.734
with these transactions?

00:50:17.734 --> 00:50:20.167
I mean, the bane
in web applications

00:50:20.167 --> 00:50:21.400
for the most part

00:50:21.400 --> 00:50:23.701
is in instability
of the web applications

00:50:23.701 --> 00:50:25.400
by complications, so...

00:50:25.400 --> 00:50:27.434
Wilkerson: What do you mean
exactly by instability?

00:50:27.434 --> 00:50:28.501
Like, a not reproducible--

00:50:28.501 --> 00:50:30.300
like sometimes
takes a long time,

00:50:30.300 --> 00:50:31.367
sometimes a short time?

00:50:31.367 --> 00:50:33.267
man: Like applications
going offline

00:50:33.267 --> 00:50:34.334
because they're clogged up

00:50:34.334 --> 00:50:36.467
or they're destabilized

00:50:36.467 --> 00:50:38.801
because of an
overly-complicated component

00:50:38.801 --> 00:50:41.000
in the application server.

00:50:41.000 --> 00:50:42.467
So did you take a look at that?

00:50:42.467 --> 00:50:43.467
And then related to that--

00:50:43.467 --> 00:50:44.667
Wilkerson:
Well, hold on.

00:50:44.667 --> 00:50:45.767
I still don't understand.

00:50:45.767 --> 00:50:47.534
What exactly
does instability mean?

00:50:47.534 --> 00:50:48.701
What's the exact phenomenon?

00:50:48.701 --> 00:50:51.934
Like,
you mean did we look at

00:50:51.934 --> 00:50:53.801
if we make things take longer

00:50:53.801 --> 00:50:55.133
and therefore
they're timing out

00:50:55.133 --> 00:50:56.133
when they didn't used to?

00:50:56.133 --> 00:50:57.133
man:
They're timing out,

00:50:57.133 --> 00:50:58.334
and then the work required

00:50:58.334 --> 00:51:03.300
to go remediate those
transactions

00:51:03.300 --> 00:51:04.968
that are still
left running in the system.

00:51:04.968 --> 00:51:06.133
In other words,

00:51:06.133 --> 00:51:08.167
is there a consideration

00:51:08.167 --> 00:51:10.367
of stability
in the application

00:51:10.367 --> 00:51:11.734
in your design center

00:51:11.734 --> 00:51:12.767
looking at this?

00:51:12.767 --> 00:51:13.868
And related to that

00:51:13.868 --> 00:51:16.067
is did you look at
any other technology

00:51:16.067 --> 00:51:17.400
that's an alternative

00:51:17.400 --> 00:51:19.033
to distributed transactions,

00:51:19.033 --> 00:51:21.434
like technology provided by

00:51:21.434 --> 00:51:23.868
business process
execution languages

00:51:23.868 --> 00:51:29.167
that sort of compile, like,
a business process

00:51:29.167 --> 00:51:32.734
into a...

00:51:36.767 --> 00:51:42.200
you know, a simpler type
of back-end mechanism?

00:51:42.200 --> 00:51:43.567
Wilkerson:
All right.

00:51:43.567 --> 00:51:45.667
Both these questions
are kind of a little amorphous,

00:51:45.667 --> 00:51:46.734
so I'll do my best.

00:51:46.734 --> 00:51:47.734
In terms of instability,

00:51:47.734 --> 00:51:49.067
what we did is,

00:51:49.067 --> 00:51:51.033
we did the algorithm
that has the lowest impact--

00:51:51.033 --> 00:51:52.434
Oh, I forgot.

00:51:52.434 --> 00:51:54.234
There's something
I didn't put in a slide for.

00:51:54.234 --> 00:51:56.167
It would have been
really easy to have read locks.

00:51:56.167 --> 00:51:57.868
If you notice, our system
has no read locks.

00:51:57.868 --> 00:52:01.133
So web apps
tend to be read-heavy,

00:52:01.133 --> 00:52:03.400
as Ryan says.

00:52:03.400 --> 00:52:05.567
So one thing that--

00:52:05.567 --> 00:52:06.567
Several months ago,

00:52:06.567 --> 00:52:07.634
I had an algorithm,

00:52:07.634 --> 00:52:08.801
and I was like,

00:52:08.801 --> 00:52:10.234
"All right.
It's done. It's baked."

00:52:10.234 --> 00:52:11.234
We're way ahead of...

00:52:11.234 --> 00:52:12.367
we're done.

00:52:12.367 --> 00:52:13.934
But then I realized
I was getting read--

00:52:13.934 --> 00:52:14.968
I had these read locks,

00:52:14.968 --> 00:52:16.033
and I was getting read locks

00:52:16.033 --> 00:52:17.400
on objects which I'd read,

00:52:17.400 --> 00:52:18.534
which means if you read

00:52:18.534 --> 00:52:20.100
in the distributed
transaction layer,

00:52:20.100 --> 00:52:21.767
that was turning into a write

00:52:21.767 --> 00:52:24.200
at the underlying
local transaction layer,

00:52:24.200 --> 00:52:26.300
and I realized,
"That's really bad,"

00:52:26.300 --> 00:52:29.667
because writes are always
way harder to handle than reads.

00:52:29.667 --> 00:52:31.467
So we had to turn
the whole algorithm around

00:52:31.467 --> 00:52:32.701
and spend a long time on this

00:52:32.701 --> 00:52:33.901
just so that reads

00:52:33.901 --> 00:52:35.434
at the distributed
transaction layer

00:52:35.434 --> 00:52:38.834
turn into reads and no writes
on the underlying layer.

00:52:38.834 --> 00:52:40.300
So if we hadn't done that,

00:52:40.300 --> 00:52:43.100
this would be a piece of garbage
I think, probably.

00:52:43.100 --> 00:52:44.834
And you would have
a very good point.

00:52:44.834 --> 00:52:46.734
You'd say, well,
you just destabilized my app,

00:52:46.734 --> 00:52:47.734
and you know what?

00:52:47.734 --> 00:52:48.868
You'd probably be right.

00:52:48.868 --> 00:52:51.167
But we've done
everything we can

00:52:51.167 --> 00:52:53.300
to use the minimum resources

00:52:53.300 --> 00:52:54.868
to make this happen.

00:52:54.868 --> 00:52:58.701
We have not
implemented the latest thing

00:52:58.701 --> 00:53:05.467
and done lots of performance
evaluation on it.

00:53:05.467 --> 00:53:06.601
We haven't done that.

00:53:06.601 --> 00:53:09.300
So we can find out
when you profile it.

00:53:09.300 --> 00:53:11.901
Are there alternatives
to transactions?

00:53:11.901 --> 00:53:14.701
Boy.

00:53:14.701 --> 00:53:16.968
Could you not use transactions?

00:53:16.968 --> 00:53:20.734
You could try to fold
the transactional semantics

00:53:20.734 --> 00:53:22.934
into the actual
logic of your app

00:53:22.934 --> 00:53:24.267
in such a way
that you just happen

00:53:24.267 --> 00:53:25.868
to manipulate structures
in such a way

00:53:25.868 --> 00:53:27.467
that they're kind of
doing transactions

00:53:27.467 --> 00:53:28.634
and manipulations at once,

00:53:28.634 --> 00:53:30.601
and kind of save the cost
of our layer.

00:53:30.601 --> 00:53:31.601
Good luck.

00:53:31.601 --> 00:53:32.601
I would never do that.

00:53:32.601 --> 00:53:34.300
It's just too hard.

00:53:34.300 --> 00:53:35.300
I don't know.

00:53:35.300 --> 00:53:36.734
Alternatives to transactions,

00:53:36.734 --> 00:53:38.767
It's an ongoing area
of research I think, actually.

00:53:38.767 --> 00:53:40.634
Can anyone--Ryan, you know
a lot about this stuff.

00:53:40.634 --> 00:53:44.868
Do you want
to say anything about that?

00:53:44.868 --> 00:53:47.634
I think they probably want you
to talk into the mic, but...

00:53:54.701 --> 00:53:56.334
Ryan says
there's a talk tomorrow

00:53:56.334 --> 00:53:57.634
at 10:45 on offline processing,

00:53:57.634 --> 00:53:58.801
and to go see that.

00:53:58.801 --> 00:54:00.634
And, in fact,
you should probably stick around

00:54:00.634 --> 00:54:02.167
for Ryan's talk,
which is next.

00:54:02.167 --> 00:54:04.467
He's gonna tell you a lot
about App Engine infrastructure.

00:54:04.467 --> 00:54:06.667
Yes, ma'am.
You have a question?

00:54:06.667 --> 00:54:09.334
And, sir, if you want
to get at the mic, I can...

00:54:09.334 --> 00:54:10.367
Go ahead and get to the mic.

00:54:10.367 --> 00:54:11.501
Yes, sir.
Yes, ma'am.

00:54:11.501 --> 00:54:14.367
woman: In Java,
you can specify something

00:54:14.367 --> 00:54:15.734
to run in a transaction

00:54:15.734 --> 00:54:18.167
and something to not
run in a transaction, right?

00:54:18.167 --> 00:54:19.234
You provide two interfaces.

00:54:19.234 --> 00:54:20.601
Wilkerson:
You can specify this--

00:54:20.601 --> 00:54:22.000
"Do this in a transaction,

00:54:22.000 --> 00:54:23.934
and then don't bother
with this other stuff," yes.

00:54:23.934 --> 00:54:25.968
woman: Can you put a little more
highlight about that?

00:54:25.968 --> 00:54:28.968
[speaks indistinct]

00:54:28.968 --> 00:54:30.434
...In a transaction,

00:54:30.434 --> 00:54:32.267
and to run in a transaction?

00:54:32.267 --> 00:54:34.000
Wilkerson:
Oh, boy.

00:54:34.000 --> 00:54:35.734
Can you say that again?

00:54:35.734 --> 00:54:37.234
Did any--

00:54:37.234 --> 00:54:40.601
I just didn't really
hear what you said, so...

00:54:40.601 --> 00:54:42.634
maybe you can...

00:54:42.634 --> 00:54:44.868
woman: So suppose
you specify something

00:54:44.868 --> 00:54:46.300
to run in a transaction,

00:54:46.300 --> 00:54:48.801
and some things to not run
in a transaction.

00:54:48.801 --> 00:54:51.767
Can you give me
what will be the difference

00:54:51.767 --> 00:54:54.267
in the state
of the two of them,

00:54:54.267 --> 00:54:56.901
and what will be
the difference between them?

00:54:56.901 --> 00:54:59.200
Wilkerson: Oh, how to know
what to do in a transaction?

00:54:59.200 --> 00:55:00.434
Well, you explicitly say,

00:55:00.434 --> 00:55:01.501
"Here's a function.

00:55:01.501 --> 00:55:02.501
"Run that in a transaction

00:55:02.501 --> 00:55:03.767
"with these arguments.

00:55:03.767 --> 00:55:05.434
And then here's another one.
Do that one."

00:55:05.434 --> 00:55:07.634
So you are explicitly
telling the program

00:55:07.634 --> 00:55:09.000
what to run in a transaction.

00:55:09.000 --> 00:55:10.200
Now the question is,

00:55:10.200 --> 00:55:11.968
How do you know what to run
in a transaction

00:55:11.968 --> 00:55:13.400
and what not to run
in a transaction?

00:55:13.400 --> 00:55:15.100
Basically, as I said earlier,

00:55:15.100 --> 00:55:16.868
you want to figure out
how you guarantee

00:55:16.868 --> 00:55:18.400
the correctness
of your application.

00:55:18.400 --> 00:55:19.968
What things
always have to be true?

00:55:19.968 --> 00:55:20.968
The invariants.

00:55:20.968 --> 00:55:21.968
Like your data structure.

00:55:21.968 --> 00:55:23.167
You have a doubly-linked list.

00:55:23.167 --> 00:55:24.868
Pointing like this, okay?

00:55:24.868 --> 00:55:26.267
Whenever you go to--

00:55:26.267 --> 00:55:27.701
If you start in a good state,
you know--

00:55:27.701 --> 00:55:28.701
At this point in my code,

00:55:28.701 --> 00:55:29.701
I'm in a good state.

00:55:29.701 --> 00:55:30.868
All of my invariants are true.

00:55:30.868 --> 00:55:31.868
At this point,

00:55:31.868 --> 00:55:32.901
I'm at a good state again.

00:55:32.901 --> 00:55:34.100
All my invariants are true.

00:55:34.100 --> 00:55:35.834
But in between,
I might have to temporarily

00:55:35.834 --> 00:55:36.901
inviolate an invariant.

00:55:36.901 --> 00:55:38.367
I have to, like,
delete this pointer,

00:55:38.367 --> 00:55:39.667
point it somewhere else.
Uh-oh.

00:55:39.667 --> 00:55:41.501
Then I have to point
that pointer back to there.

00:55:41.501 --> 00:55:42.501
Ah, now we're good again.

00:55:42.501 --> 00:55:45.701
That, from a good state
to a good state,

00:55:45.701 --> 00:55:48.100
that should be
in a transaction.

00:55:48.100 --> 00:55:50.501
Yeah.
Very good question.

00:55:50.501 --> 00:55:52.567
And there's a lot
of literature on that.

00:55:52.567 --> 00:55:54.534
You go look at an
undergraduate database's book,

00:55:54.534 --> 00:55:56.701
they'll probably
say a lot about that.

00:55:56.701 --> 00:55:58.934
Sorry. Sir.

00:55:58.934 --> 00:56:00.033
man: Sure.

00:56:00.033 --> 00:56:01.434
Let's say
I built my application,

00:56:01.434 --> 00:56:03.100
and I have various types
of objects to find

00:56:03.100 --> 00:56:05.434
and I'm about to, you know,

00:56:05.434 --> 00:56:07.868
I develop all my code

00:56:07.868 --> 00:56:10.667
using regular,
in-built Google transactions,

00:56:10.667 --> 00:56:13.300
and then I want to add--

00:56:13.300 --> 00:56:14.868
But I know it's not reliable,

00:56:14.868 --> 00:56:16.334
because I can't guarantee

00:56:16.334 --> 00:56:17.868
that things will all commit

00:56:17.868 --> 00:56:20.167
across
these various operations.

00:56:20.167 --> 00:56:21.968
You know,
either all or none.

00:56:21.968 --> 00:56:24.334
So then I add your framework

00:56:24.334 --> 00:56:25.901
and your distributed
transactions.

00:56:25.901 --> 00:56:27.167
How much longer will it take

00:56:27.167 --> 00:56:28.734
for typical-use case

00:56:28.734 --> 00:56:30.434
where I'm updating
a number of records,

00:56:30.434 --> 00:56:32.467
inserting some, deleting some.

00:56:32.467 --> 00:56:34.133
You know,
what's the overhead

00:56:34.133 --> 00:56:35.868
of doing these
distributed transactions?

00:56:35.868 --> 00:56:37.000
That's one thing.

00:56:37.000 --> 00:56:38.334
Wilkerson:
What's the overhead?

00:56:38.334 --> 00:56:40.000
I've got less than
one minute, unfortunately.

00:56:40.000 --> 00:56:41.300
Unless they want
to let me go over.

00:56:41.300 --> 00:56:42.734
Is there any chance
to go over or not?

00:56:42.734 --> 00:56:44.000
No, she's shaking her head.

00:56:44.000 --> 00:56:45.767
man: The other is
how intrusive is it to my code?

00:56:45.767 --> 00:56:47.133
You know,
I've got my objects to find.

00:56:47.133 --> 00:56:48.367
How much more do I need
to add?

00:56:48.367 --> 00:56:50.334
How hard is it from
an engineering viewpoint?

00:56:50.334 --> 00:56:53.067
I don't want to worry
about the details.

00:56:53.067 --> 00:56:55.567
Wilkerson: I tried to make it
as easy to use as I could.

00:56:55.567 --> 00:56:56.767
If you need transactions

00:56:56.767 --> 00:56:58.400
to maintain
the correctness of your code,

00:56:58.400 --> 00:57:00.267
there's no--I don't, like,
you have to use them.

00:57:00.267 --> 00:57:01.501
So there's sort of a--

00:57:01.501 --> 00:57:02.901
Not using them
is a bit of a red herring.

00:57:02.901 --> 00:57:04.501
It's like you're
waiting for a disaster.

00:57:04.501 --> 00:57:07.634
And in terms
of the performance,

00:57:07.634 --> 00:57:09.901
I've got 20 seconds or so.

00:57:09.901 --> 00:57:12.133
You know, for every read,

00:57:12.133 --> 00:57:13.934
we actually do two reads.

00:57:13.934 --> 00:57:17.534
For every write,
we actually do three writes.

00:57:17.534 --> 00:57:20.300
And if you have
a read and a write

00:57:20.300 --> 00:57:21.300
of the same object,

00:57:21.300 --> 00:57:22.634
you get to save
one of those reads.

00:57:22.634 --> 00:57:24.200
So if you read and write
the same object,

00:57:24.200 --> 00:57:25.734
they have to do
three writes and one read.

00:57:25.734 --> 00:57:28.033
So, yeah.

00:57:28.033 --> 00:57:29.601
There's a constant multiple

00:57:29.601 --> 00:57:31.200
on how many reads
and writes are going on,

00:57:31.200 --> 00:57:32.501
but it's as small
as we can get it.

00:57:32.501 --> 00:57:34.167
I'm pretty convinced myself

00:57:34.167 --> 00:57:37.667
that there is no shorter way
to really do it.

00:57:37.667 --> 00:57:39.133
And now I'm over. Okay.

00:57:39.133 --> 00:57:42.167
The nice lady in the back
is telling me--

00:57:42.167 --> 00:57:43.734
No? One more? Okay.

00:57:43.734 --> 00:57:44.901
man:
I was just wondering

00:57:44.901 --> 00:57:46.400
if there was any
resource constraints

00:57:46.400 --> 00:57:47.934
on the distributed
transaction table.

00:57:47.934 --> 00:57:49.501
Like, can you have
a limited number

00:57:49.501 --> 00:57:50.901
open at any given time,

00:57:50.901 --> 00:57:52.834
or is there
a rate of insert limit

00:57:52.834 --> 00:57:54.067
like there are
on other tables?

00:57:54.067 --> 00:57:56.133
Wilkerson:
It's gonna be--

00:57:56.133 --> 00:57:57.901
I mean, a distributed
transaction object

00:57:57.901 --> 00:57:59.601
is just an object
like any other object,

00:57:59.601 --> 00:58:01.634
and it has any limits that
Google App Engine

00:58:01.634 --> 00:58:03.200
has decided to put
on the number of objects

00:58:03.200 --> 00:58:04.434
you can have.

00:58:04.434 --> 00:58:06.167
man: So like
any other entity, basically.

00:58:06.167 --> 00:58:07.701
Wilkerson:
It's one more entity, yes.

00:58:07.701 --> 00:58:08.801
And they do go away.

00:58:08.801 --> 00:58:09.968
So they are increasing

00:58:09.968 --> 00:58:12.601
the amount of resource usage
of your app,

00:58:12.601 --> 00:58:14.501
but when
the transaction completes

00:58:14.501 --> 00:58:15.801
and the client code reads it

00:58:15.801 --> 00:58:17.200
and says,
"Yep, that's complete.

00:58:17.200 --> 00:58:20.033
Done. Delete that thing",

00:58:20.033 --> 00:58:21.033
it shouldn't be using--

00:58:21.033 --> 00:58:22.267
There shouldn't be any garbage.

00:58:22.267 --> 00:58:23.467
There's one very rare case,

00:58:23.467 --> 00:58:24.868
where I'm trying
to get rid of the--

00:58:24.868 --> 00:58:26.033
It's an extremely rare case

00:58:26.033 --> 00:58:28.434
where you might get
a little bit of garbage.

00:58:28.434 --> 00:58:29.801
All right.

00:58:29.801 --> 00:58:31.767
It looks like I'm out of time,
right, ma'am?

00:58:31.767 --> 00:58:33.334
Yes, I am. Thank you.

00:58:33.334 --> 00:58:35.501
[applause]

