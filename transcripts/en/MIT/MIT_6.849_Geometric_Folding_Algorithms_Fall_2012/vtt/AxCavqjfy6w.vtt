WEBVTT
Kind: captions
Language: en

00:01:15.466 --> 00:01:16.340
PROFESSOR: All right.

00:01:16.340 --> 00:01:17.090
Let's get started.

00:01:19.460 --> 00:01:23.580
So we have a fun lecture today
about efficient origami design.

00:01:23.580 --> 00:01:26.670
Last Monday, we did
inefficient origami design,

00:01:26.670 --> 00:01:27.730
but it was universal.

00:01:27.730 --> 00:01:30.000
We could fold anything.

00:01:30.000 --> 00:01:31.590
And let's see,
Thursday, we talked

00:01:31.590 --> 00:01:34.120
about some basic
foldability, crease patterns,

00:01:34.120 --> 00:01:35.410
what make the valid.

00:01:35.410 --> 00:01:37.400
That'll ground us
a little bit today

00:01:37.400 --> 00:01:40.060
when designing some
crease patterns.

00:01:40.060 --> 00:01:42.780
Although, we're going to
stay fairly high level today

00:01:42.780 --> 00:01:45.250
because there are two big
methods I want to talk about.

00:01:45.250 --> 00:01:47.470
One is tree method
which is hit it pretty

00:01:47.470 --> 00:01:50.380
big in the impractical
origami design.

00:01:50.380 --> 00:01:53.070
Lot of modern complex
origami designers

00:01:53.070 --> 00:01:57.270
use it either in their head
or occasionally on a computer.

00:01:57.270 --> 00:01:59.160
I demoed it quickly last time.

00:01:59.160 --> 00:02:03.390
So we are going to see some
level of detail how that works.

00:02:03.390 --> 00:02:05.590
And then, I want to
talk about Orgamizer

00:02:05.590 --> 00:02:08.960
which is one of the latest
techniques for designing

00:02:08.960 --> 00:02:11.822
crazy, arbitrary,
three-dimensional shapes that

00:02:11.822 --> 00:02:13.030
seems to be pretty efficient.

00:02:13.030 --> 00:02:17.010
Although we don't have a formal
sense in which it is efficient,

00:02:17.010 --> 00:02:18.990
it has some nice properties.

00:02:18.990 --> 00:02:21.260
And it's pretty cool,
and I can also demo it.

00:02:21.260 --> 00:02:27.330
It's also freely downloadable
software for Windows.

00:02:27.330 --> 00:02:28.250
Good.

00:02:28.250 --> 00:02:32.140
So just to get you
motivated a little bit,

00:02:32.140 --> 00:02:35.150
I brought a bunch of examples.

00:02:35.150 --> 00:02:37.246
I'll show you more later.

00:02:37.246 --> 00:02:38.620
But this is the
sort of thing you

00:02:38.620 --> 00:02:39.786
can do with the tree method.

00:02:39.786 --> 00:02:42.540
It's not going to be the tree
method as I presented here.

00:02:42.540 --> 00:02:44.590
This is a variation
on it called box

00:02:44.590 --> 00:02:46.760
pleating which
you can read about

00:02:46.760 --> 00:02:48.430
in Origami Design Secrets.

00:02:48.430 --> 00:02:51.120
And I don't think Jason
will talk about that either.

00:02:51.120 --> 00:02:55.600
But it's a variation on
what we'll be talking about.

00:02:55.600 --> 00:02:59.640
It lets you do crazy things like
these two praying mantises, one

00:02:59.640 --> 00:03:01.800
eating the other.

00:03:01.800 --> 00:03:03.910
This is a design by Robert Lang.

00:03:03.910 --> 00:03:04.849
Fairly new.

00:03:04.849 --> 00:03:06.390
I don't have a year
here, but I think

00:03:06.390 --> 00:03:08.590
it's last year or something.

00:03:08.590 --> 00:03:11.700
And that's the sort
of thing you can

00:03:11.700 --> 00:03:15.070
do getting all the limbs, all
the right proportions, even

00:03:15.070 --> 00:03:17.870
multiple characters
by representing

00:03:17.870 --> 00:03:19.630
your model as a stick figure.

00:03:19.630 --> 00:03:21.790
And that's what
the tree method is

00:03:21.790 --> 00:03:24.880
all about and doing
that efficiently.

00:03:24.880 --> 00:03:30.200
So this is a statement
last time of the theorem.

00:03:30.200 --> 00:03:32.150
There's some catches to this.

00:03:32.150 --> 00:03:33.670
It's an algorithm.

00:03:33.670 --> 00:03:35.740
Find a folding of
the smallest square

00:03:35.740 --> 00:03:40.510
possible into and origami
base with the desired

00:03:40.510 --> 00:03:45.520
tree as a shadow
or as a projection.

00:03:45.520 --> 00:03:48.257
So you remember,
this kind of picture.

00:03:48.257 --> 00:03:49.340
You want to make a lizard.

00:03:49.340 --> 00:03:51.900
You specify the lengths
of each of these limbs

00:03:51.900 --> 00:03:54.120
and how they're connected
together into a tree.

00:03:54.120 --> 00:04:00.300
And then, you want to build an
origami model on top of that,

00:04:00.300 --> 00:04:02.290
so to speak.

00:04:02.290 --> 00:04:08.160
So that it looks
something like this.

00:04:12.320 --> 00:04:15.190
And you want to find a square
the folds into such a shape.

00:04:15.190 --> 00:04:17.200
This projection is
exactly that tree.

00:04:17.200 --> 00:04:20.320
Now, say it's an algorithm, and
it finds the smallest square.

00:04:20.320 --> 00:04:23.600
But to do that, essentially
requires exponential time.

00:04:23.600 --> 00:04:26.670
We'll prove in the next class
that this problem, in general,

00:04:26.670 --> 00:04:28.370
is NP-complete.

00:04:28.370 --> 00:04:30.469
So it's really hard.

00:04:30.469 --> 00:04:32.260
But there is an
exponential time algorithm,

00:04:32.260 --> 00:04:34.270
and I didn't say efficient here.

00:04:34.270 --> 00:04:37.080
It's efficient in terms
of design, quality,

00:04:37.080 --> 00:04:38.260
or in terms of algorithm.

00:04:38.260 --> 00:04:40.210
But you have to
pick one of the two.

00:04:40.210 --> 00:04:43.830
So in TreeMaker the
program, there's

00:04:43.830 --> 00:04:45.600
an efficient
algorithm, which finds

00:04:45.600 --> 00:04:47.297
a reasonably good-sized square.

00:04:47.297 --> 00:04:48.880
But it's not guaranteed
to be optimal.

00:04:48.880 --> 00:04:51.200
It's just a local optimum.

00:04:51.200 --> 00:04:54.250
In principle, you could
spend exponential time here.

00:04:54.250 --> 00:04:56.900
So slow algorithm and
get the smallest square.

00:04:56.900 --> 00:04:58.680
So it depends.

00:04:58.680 --> 00:05:00.750
The other catch is this folding.

00:05:00.750 --> 00:05:03.570
We're still working on proving
that this does not actually

00:05:03.570 --> 00:05:07.030
self-intersect in
the folded state.

00:05:07.030 --> 00:05:08.080
I checked the dates.

00:05:08.080 --> 00:05:10.830
We've been working on
that for six years.

00:05:10.830 --> 00:05:13.340
But it's closing in.

00:05:13.340 --> 00:05:16.770
Maybe next year we'll have
a draft of this proof.

00:05:16.770 --> 00:05:18.405
It's quite-- it's
many, many pages.

00:05:21.640 --> 00:05:24.010
Good.

00:05:24.010 --> 00:05:25.730
So those are the catches.

00:05:25.730 --> 00:05:28.960
Now, let me tell you
about this term uniaxial.

00:05:28.960 --> 00:05:31.470
Essentially, it just
means tree shapes.

00:05:31.470 --> 00:05:34.050
But I'd like to be a little
bit more formal about that.

00:05:34.050 --> 00:05:38.120
And last time, I showed you
the standard origami bases.

00:05:38.120 --> 00:05:41.000
All of these are
uniaxial, I think,

00:05:41.000 --> 00:05:44.830
except the pinwheel
which we folded.

00:05:44.830 --> 00:05:47.970
So the pinwheel-- so let
me tell you intuitively

00:05:47.970 --> 00:05:49.470
what uniaxial means.

00:05:49.470 --> 00:05:51.870
It means you can take
all these flaps of paper

00:05:51.870 --> 00:05:55.590
and lie them, place
them along a line.

00:05:55.590 --> 00:06:00.120
And the hinges
between those flaps

00:06:00.120 --> 00:06:02.670
are all perpendicular
to that line.

00:06:02.670 --> 00:06:06.500
So this is the axis.

00:06:06.500 --> 00:06:09.330
Whereas something like
this, essentially there

00:06:09.330 --> 00:06:10.780
are four axes.

00:06:10.780 --> 00:06:14.240
The flaps are here,
or two axes I guess.

00:06:14.240 --> 00:06:15.980
But definitely not one.

00:06:15.980 --> 00:06:18.790
So these cannot be
lined up along a line,

00:06:18.790 --> 00:06:22.880
even if you've flapped
them around some other way.

00:06:22.880 --> 00:06:24.740
That's intuitive definition.

00:06:24.740 --> 00:06:27.960
Multiaxial is not a
formally defined thing.

00:06:27.960 --> 00:06:30.390
But uniaxial we can
formally define.

00:06:30.390 --> 00:06:34.520
And it will capture things
like this water bomb base,

00:06:34.520 --> 00:06:40.370
all the other bases there,
as well as bases like this.

00:06:40.370 --> 00:06:43.100
And it's defined
by Robert Lang, I

00:06:43.100 --> 00:06:48.185
think probably around '94
was the first publication.

00:06:59.550 --> 00:07:02.105
And it's just a
bunch of conditions.

00:07:11.170 --> 00:07:13.600
And a bunch of them are just
technical to make things work

00:07:13.600 --> 00:07:16.090
out mathematically.

00:07:16.090 --> 00:07:20.010
First thing I'd like to say
is that the entire base-- base

00:07:20.010 --> 00:07:24.380
just means origami
for our purposes.

00:07:24.380 --> 00:07:27.060
It's sort of
practical distinction

00:07:27.060 --> 00:07:28.940
not a mathematical one.

00:07:28.940 --> 00:07:31.410
Is that everything
lies above the floor.

00:07:31.410 --> 00:07:34.040
So the floor is equal
to zero, and we'll just

00:07:34.040 --> 00:07:35.260
say everything's above that.

00:07:35.260 --> 00:07:37.260
And the action is going
to be in the floor.

00:07:37.260 --> 00:07:39.570
That's where I've
drawn it that way.

00:07:39.570 --> 00:07:41.890
Here, there's a floor.

00:07:41.890 --> 00:07:44.460
And the tree is going
to lie on the floor,

00:07:44.460 --> 00:07:45.890
and everything
else is above that.

00:07:49.000 --> 00:07:49.935
Second property.

00:07:57.670 --> 00:08:01.530
Sort of a shadow property.

00:08:01.530 --> 00:08:03.940
If I look at where
the base meets

00:08:03.940 --> 00:08:08.310
the floor is equals to
zero, that's the same thing

00:08:08.310 --> 00:08:11.740
as if I look at the
shadow onto the floor.

00:08:18.890 --> 00:08:21.890
This is essentially saying
that this base does not

00:08:21.890 --> 00:08:23.730
have any overhang.

00:08:23.730 --> 00:08:26.680
So if it had, for
example, some feature

00:08:26.680 --> 00:08:31.650
like this that hung over
its shadow-- was more--

00:08:31.650 --> 00:08:32.340
went out here.

00:08:32.340 --> 00:08:34.350
The shadow goes out here,
but the base does not.

00:08:34.350 --> 00:08:35.610
That's not allowed.

00:08:35.610 --> 00:08:37.289
So I want everything--
actually want

00:08:37.289 --> 00:08:41.809
things to get smaller
as you go up in z.

00:08:41.809 --> 00:08:44.735
This is a stronger
statement of property two.

00:08:48.290 --> 00:08:50.300
And then, I want to
define this notion flaps.

00:08:53.070 --> 00:08:58.410
And the basic idea
is that you have

00:08:58.410 --> 00:09:01.020
faces of the crease pattern.

00:09:08.310 --> 00:09:12.260
so the faces are
just the regions

00:09:12.260 --> 00:09:15.250
we get out of the creases, all
these triangles for example.

00:09:15.250 --> 00:09:17.170
I can divide them,
partition them

00:09:17.170 --> 00:09:18.930
into groups which I call flaps.

00:09:18.930 --> 00:09:23.020
So for example, these two
guys over here form one flap.

00:09:23.020 --> 00:09:24.360
They fold together.

00:09:24.360 --> 00:09:26.430
They're going to be
manipulated together.

00:09:26.430 --> 00:09:28.955
And so in this case,
I'll get four flaps.

00:09:42.790 --> 00:09:44.480
Anything I want to say here?

00:09:44.480 --> 00:09:45.310
Yeah.

00:09:45.310 --> 00:10:01.400
Each flap is going to
project to a line segment.

00:10:12.470 --> 00:10:14.800
It's going to be one of
the edges of the tree.

00:10:17.340 --> 00:10:19.760
So then, there's the
notion of a hinge crease.

00:10:26.300 --> 00:10:31.690
And these are just creases
shared by two flaps.

00:10:31.690 --> 00:10:38.270
So they're the creases that
separate one flap from another.

00:10:41.150 --> 00:10:49.300
These will always require
that they projects to a point.

00:10:51.910 --> 00:10:54.650
So this is equivalent to saying
the hinge crease is vertical.

00:10:54.650 --> 00:10:56.320
It's perpendicular to the floor.

00:10:56.320 --> 00:10:58.800
I'm always projecting
straight down onto the floor

00:10:58.800 --> 00:11:04.680
orthographically, just
setting z to zero.

00:11:04.680 --> 00:11:08.950
And so that's saying
these are the hinges.

00:11:08.950 --> 00:11:12.000
They should be vertical.

00:11:12.000 --> 00:11:13.690
So projection is a point.

00:11:13.690 --> 00:11:15.390
And then from those
two properties,

00:11:15.390 --> 00:11:18.225
I can define a graph
which I want to be a tree.

00:11:28.820 --> 00:11:32.910
So each flap I want to
make an edge of my graph.

00:11:32.910 --> 00:11:35.050
And that edge is going
to be the line segment

00:11:35.050 --> 00:11:39.200
that the flap projects,
each flat projects to.

00:11:39.200 --> 00:11:42.580
And I'm going to connect
those edges together

00:11:42.580 --> 00:11:52.995
at vertices when the flaps
share the hinge crease.

00:12:01.620 --> 00:12:02.120
All right.

00:12:02.120 --> 00:12:04.630
That's a graph which
you can define.

00:12:04.630 --> 00:12:07.294
And that graph is a tree.

00:12:07.294 --> 00:12:08.210
That's the constraint.

00:12:10.720 --> 00:12:12.645
And I think I have even more.

00:12:15.680 --> 00:12:16.960
I've got one more property.

00:12:37.140 --> 00:12:40.220
I think I actually
want projects here.

00:12:40.220 --> 00:12:41.451
Let's try that.

00:12:45.540 --> 00:12:46.040
All right.

00:12:46.040 --> 00:12:49.940
This is a bunch of formalism to
state what's pretty intuitive.

00:12:49.940 --> 00:12:54.920
I want all the flaps of
paper to be vertical,

00:12:54.920 --> 00:12:57.710
so they project
to a line segment.

00:12:57.710 --> 00:13:03.140
When I look from the-- when
I look at the projection,

00:13:03.140 --> 00:13:06.380
I can define a
graph where there's

00:13:06.380 --> 00:13:09.200
an edge for each flap,
where it's projecting.

00:13:09.200 --> 00:13:10.992
And I join those edges together.

00:13:10.992 --> 00:13:12.700
Here, I'm joinging
four them at a vertex.

00:13:12.700 --> 00:13:17.020
Because if you unfold it,
they all share hinge creases.

00:13:17.020 --> 00:13:19.330
Hinge creases in this case
are the perpendicular.

00:13:19.330 --> 00:13:22.230
These four guys.

00:13:22.230 --> 00:13:26.180
So because-- it's
hard to manipulate.

00:13:26.180 --> 00:13:27.420
I've got a flap over here.

00:13:27.420 --> 00:13:28.340
A flap over here.

00:13:28.340 --> 00:13:32.700
They share a hinge, so I connect
them together in the graph.

00:13:32.700 --> 00:13:35.966
It's just a formal way to
make the graph correct.

00:13:35.966 --> 00:13:40.090
It may seem tedious,
but this definition

00:13:40.090 --> 00:13:42.715
sidesteps some issues which
would occur if you defined it

00:13:42.715 --> 00:13:45.340
in the more obvious way which
is just take the projection,

00:13:45.340 --> 00:13:46.851
call it a tree.

00:13:46.851 --> 00:13:48.350
But I don't want
to get into why you

00:13:48.350 --> 00:13:49.980
need to do it this way exactly.

00:13:49.980 --> 00:13:51.940
Maybe, we'll see
it at some point.

00:13:51.940 --> 00:13:54.250
Essentially, some flaps can
be hidden inside others,

00:13:54.250 --> 00:13:56.370
so you need this definition
for it to really work.

00:13:59.260 --> 00:14:01.110
And then, there's
this extra constraint

00:14:01.110 --> 00:14:04.580
which is that my base
is pointy at the leaves.

00:14:04.580 --> 00:14:07.320
Leaves are the
vertices of the tree

00:14:07.320 --> 00:14:09.320
to have only one incident edge.

00:14:09.320 --> 00:14:12.060
And so I want there
to be only one

00:14:12.060 --> 00:14:13.800
point that lives at the leaf.

00:14:13.800 --> 00:14:15.720
Obviously, elsewhere
in the tree,

00:14:15.720 --> 00:14:18.267
there's a whole bunch of points,
a whole vertical segment,

00:14:18.267 --> 00:14:19.600
that all projects to that point.

00:14:19.600 --> 00:14:21.134
Here, I just want one.

00:14:21.134 --> 00:14:22.800
That's important
because I want to think

00:14:22.800 --> 00:14:24.010
about where the leaves are.

00:14:24.010 --> 00:14:25.790
And the whole idea
in the tree method

00:14:25.790 --> 00:14:28.790
is to think about how to
place the leaves on your piece

00:14:28.790 --> 00:14:33.790
of paper so that
this folding exists.

00:14:33.790 --> 00:14:35.330
So that's what
we're going to do.

00:14:51.220 --> 00:14:54.619
The tree method is kind of
surprising in its simplicity.

00:14:54.619 --> 00:14:56.410
There's a bunch of
details to make it work.

00:14:56.410 --> 00:15:00.350
But the idea is
actually very simple.

00:15:00.350 --> 00:15:04.680
Let's suppose you want
ability uniaxial base.

00:15:04.680 --> 00:15:06.930
I'll tell you something
that must be satisfied

00:15:06.930 --> 00:15:09.915
by your uniaxial base,
a necessary condition.

00:15:12.490 --> 00:15:21.337
Assuming you're starting from
a convex piece of paper, which

00:15:21.337 --> 00:15:23.725
is the case we
usually care about.

00:15:23.725 --> 00:15:26.240
Actually, we're starting
from a square, a rectangle,

00:15:26.240 --> 00:15:29.970
or something convex.

00:15:29.970 --> 00:15:31.120
Here's what has to be true.

00:15:49.740 --> 00:15:55.900
I didn't give a
name, but this graph

00:15:55.900 --> 00:15:57.510
that's supposed
to be a tree, I'm

00:15:57.510 --> 00:16:05.850
going to call the shadow
tree for obvious reasons.

00:16:05.850 --> 00:16:09.200
And now, I want to take two
points in the shadow tree,

00:16:09.200 --> 00:16:11.990
measure their distance
in a tree sense.

00:16:11.990 --> 00:16:16.370
So I have some tree like this.

00:16:16.370 --> 00:16:20.130
I have two points like, say,
this point and that point.

00:16:20.130 --> 00:16:22.910
The distance between
them is the distance as

00:16:22.910 --> 00:16:26.850
measured if you had to walk
in the tree, how far is it

00:16:26.850 --> 00:16:28.490
to go from here to here.

00:16:28.490 --> 00:16:30.100
And because our tree
is a metric tree,

00:16:30.100 --> 00:16:31.849
because we specified
all the edge lengths,

00:16:31.849 --> 00:16:34.850
we can just add up those
lengths, measure them.

00:16:34.850 --> 00:16:38.160
And that's the distance
between two points in the tree.

00:16:38.160 --> 00:16:42.330
That must be less than
or equal to the distance

00:16:42.330 --> 00:16:46.200
between those two points
on the piece of paper.

00:17:06.960 --> 00:17:08.730
What does that mean?

00:17:08.730 --> 00:17:12.160
So on piece of paper
that's convex--

00:17:12.160 --> 00:17:17.089
so it might not be a square, but
square's easier picture draw.

00:17:17.089 --> 00:17:20.060
The distance between
them is that.

00:17:20.060 --> 00:17:22.260
Pretty simple.

00:17:22.260 --> 00:17:24.599
So what does this mean?

00:17:24.599 --> 00:17:25.750
I'm taking this square.

00:17:25.750 --> 00:17:28.119
Somehow, I'm folding
it into a base

00:17:28.119 --> 00:17:30.650
whose projection is the tree.

00:17:30.650 --> 00:17:36.630
So I look at these
two points, p and q,

00:17:36.630 --> 00:17:38.940
I fold them somewhere
in the 3D picture

00:17:38.940 --> 00:17:40.980
which is not drawn up here.

00:17:40.980 --> 00:17:46.070
Those points-- so maybe there's
a p up here and a q up here.

00:17:46.070 --> 00:17:49.380
I project those points
down onto the floor which

00:17:49.380 --> 00:17:53.000
is going to fall on the
tree by this definition.

00:17:53.000 --> 00:17:56.390
Call that, let's say, p prime
for the projected version of p,

00:17:56.390 --> 00:17:58.160
q prime.

00:17:58.160 --> 00:18:00.360
I measure the distance here.

00:18:00.360 --> 00:18:04.186
That has to be-- the
distance between p prime

00:18:04.186 --> 00:18:05.560
and q prime in
the tree should be

00:18:05.560 --> 00:18:07.950
less than or equal to the
distance between p and q

00:18:07.950 --> 00:18:11.110
in the piece of paper, for
every pair points p and q.

00:18:11.110 --> 00:18:13.870
That's the condition.

00:18:13.870 --> 00:18:19.650
It's almost trivial
to show because when

00:18:19.650 --> 00:18:23.490
I take this segment of paper,
I fold the piece of paper.

00:18:23.490 --> 00:18:26.250
But in particular, I
fold p and q somehow.

00:18:26.250 --> 00:18:29.280
I can't get p and q farther
away from each other

00:18:29.280 --> 00:18:32.650
because folding only
makes things closer.

00:18:32.650 --> 00:18:35.530
There, I'm assuming that the
piece of paper is convex.

00:18:35.530 --> 00:18:37.704
There's no way to
fold and stretch pq

00:18:37.704 --> 00:18:39.120
because that's a
segment of paper.

00:18:39.120 --> 00:18:41.670
It can only contract.

00:18:41.670 --> 00:18:44.950
I mean, you can fold the
segment something like this.

00:18:44.950 --> 00:18:47.170
Then, the distance
between p and q

00:18:47.170 --> 00:18:50.890
gets smaller than the
length of this segment.

00:18:50.890 --> 00:18:55.460
Because if I took this-- this
line segment of paper that got

00:18:55.460 --> 00:18:56.650
folded.

00:18:56.650 --> 00:18:58.240
If I project it
onto the line here,

00:18:58.240 --> 00:19:01.120
it's only going to get shorter.

00:19:01.120 --> 00:19:02.030
So I fold p and q.

00:19:02.030 --> 00:19:05.750
They get closer in three-space.

00:19:05.750 --> 00:19:08.430
And then, I project
them down to the floor.

00:19:08.430 --> 00:19:11.750
They can also only get
closer when I do that.

00:19:16.170 --> 00:19:18.476
So that's essentially the proof.

00:19:18.476 --> 00:19:20.220
Do I need to spell that out?

00:19:20.220 --> 00:19:22.850
So you have the line
segment on the paper.

00:19:22.850 --> 00:19:23.410
You fold it.

00:19:23.410 --> 00:19:24.420
It gets shorter.

00:19:24.420 --> 00:19:25.880
You project it onto the floor.

00:19:25.880 --> 00:19:26.730
It also get shorter.

00:19:26.730 --> 00:19:28.465
Therefore, whatever
this distance

00:19:28.465 --> 00:19:31.320
is on the tree has to be less
than or equal to the distance

00:19:31.320 --> 00:19:32.310
you started with.

00:19:32.310 --> 00:19:34.400
So this may seem
kind of trivial.

00:19:34.400 --> 00:19:40.180
But the surprising thing is it
this is really all you need.

00:19:40.180 --> 00:19:43.227
So this is true between any
two points in the shadow tree.

00:19:43.227 --> 00:19:45.060
In fact, we're going
to focus on the leaves.

00:19:45.060 --> 00:19:47.750
We'll say, all right,
so in particular, I've

00:19:47.750 --> 00:19:51.750
got a place this leaf, and
each of these six leaves here,

00:19:51.750 --> 00:19:54.430
I have to place them somewhere
on the piece of paper.

00:19:54.430 --> 00:19:58.310
I better do it so that that
condition is satisfied.

00:19:58.310 --> 00:20:01.150
I have to place these two
leaves and the piece of paper--

00:20:01.150 --> 00:20:06.637
let's say this distance is
one, and this distance is one.

00:20:06.637 --> 00:20:08.970
These two leaves have to be
placed on the piece of paper

00:20:08.970 --> 00:20:12.110
such that their distance
is at least two.

00:20:12.110 --> 00:20:14.870
And the distance between these
two guys has to be at least two

00:20:14.870 --> 00:20:17.300
and between these two guys
has to be at least two.

00:20:17.300 --> 00:20:18.620
And same over here.

00:20:18.620 --> 00:20:20.270
Let's say all the
edge lengths are one.

00:20:20.270 --> 00:20:24.940
And the distance between,
say, this leaf and this leaf

00:20:24.940 --> 00:20:27.840
has to be at least three
because the distance in the tree

00:20:27.840 --> 00:20:29.510
is three.

00:20:29.510 --> 00:20:32.945
So at the very least, we should
place the points on the paper

00:20:32.945 --> 00:20:34.570
so that those conditions
are satisfied,

00:20:34.570 --> 00:20:36.767
and it turns out,
that's enough as long

00:20:36.767 --> 00:20:39.350
as you find a placement of the
points such as those conditions

00:20:39.350 --> 00:20:40.260
are satisfied.

00:20:40.260 --> 00:20:43.230
There will be a folding where
those leaves actually come

00:20:43.230 --> 00:20:44.710
from those points of paper.

00:20:44.710 --> 00:20:46.500
That's the crazy part.

00:20:46.500 --> 00:20:50.070
But this idea is actually
kind of obvious in some sense.

00:20:50.070 --> 00:20:52.390
I mean, once you know
it, it's really obvious.

00:20:52.390 --> 00:20:57.010
But what's surprising is it this
is all you need to worry about.

00:20:57.010 --> 00:21:01.490
There's a lot of details that
make that work, but you can.

00:21:01.490 --> 00:21:06.940
So let me just
mention one detail

00:21:06.940 --> 00:21:09.960
which is the scale factor.

00:21:09.960 --> 00:21:12.730
If you fix the size,
the edge lengths

00:21:12.730 --> 00:21:14.510
on the tree which
is the usual, which

00:21:14.510 --> 00:21:17.430
is one way to think
about it, and you

00:21:17.430 --> 00:21:19.750
start with some square--
like if I start with a one

00:21:19.750 --> 00:21:22.166
by one square, there's no way
I'm going to fold that tree.

00:21:22.166 --> 00:21:24.737
There's just not enough
distance in the square.

00:21:24.737 --> 00:21:26.820
So what I'd like to do is
find the smallest square

00:21:26.820 --> 00:21:28.970
that can fold into this thing.

00:21:28.970 --> 00:21:31.810
Or equivalently find--
you can think of scaling

00:21:31.810 --> 00:21:34.110
the piece of paper, or
you can think of scaling

00:21:34.110 --> 00:21:37.150
the tree with a
fixed piece of paper.

00:21:37.150 --> 00:21:38.850
Doesn't really matter.

00:21:38.850 --> 00:21:42.930
In general, you get
this problem which

00:21:42.930 --> 00:21:44.259
I'll call scale optimization.

00:21:44.259 --> 00:21:45.300
This is the hard problem.

00:21:53.970 --> 00:22:19.000
So let's say-- just
defining some variables.

00:22:19.000 --> 00:22:22.470
So P i, I'm going to
maybe number the leaves

00:22:22.470 --> 00:22:25.150
or label label them
somehow, various letters.

00:22:25.150 --> 00:22:27.800
And then, P i is going
to be the point where

00:22:27.800 --> 00:22:30.200
that-- of paper
that actually forms

00:22:30.200 --> 00:22:32.020
that leaf in the folded state.

00:22:32.020 --> 00:22:36.924
That leaf which corresponds
to a single point of paper

00:22:36.924 --> 00:22:37.840
projects to that leaf.

00:22:40.900 --> 00:22:45.190
And then, my goal is
to maximize some scale

00:22:45.190 --> 00:22:46.755
factor which I'll call lambda.

00:22:50.990 --> 00:22:56.150
Subject to a bunch of
constraints which are just

00:22:56.150 --> 00:23:00.910
those constraints, except
that I add a scale factor.

00:23:10.100 --> 00:23:14.705
So for every pair
of leaves, i and j,

00:23:14.705 --> 00:23:16.080
I'm going to
measure the distance

00:23:16.080 --> 00:23:18.190
between those
leaves in the tree.

00:23:18.190 --> 00:23:19.930
This as a tree distance.

00:23:19.930 --> 00:23:21.870
Compare that to the
distance and the piece

00:23:21.870 --> 00:23:25.450
of paper between those two
points, the Euclidean distance.

00:23:25.450 --> 00:23:26.980
And instead of
requiring that this

00:23:26.980 --> 00:23:28.820
is greater than or equal to
this, which is the usual one,

00:23:28.820 --> 00:23:30.950
I'm going to add in
the scale factor which

00:23:30.950 --> 00:23:35.110
you can think of as shrinking
this or expanding that.

00:23:35.110 --> 00:23:36.540
It doesn't matter.

00:23:36.540 --> 00:23:41.630
But I want to-- because here I'm
sort of shrinking this amount.

00:23:41.630 --> 00:23:44.840
I want to maximize
that factor, so I

00:23:44.840 --> 00:23:47.360
shrink it the least possible.

00:23:47.360 --> 00:23:51.560
You can formulate it this way
or maybe a more intuitive way.

00:23:51.560 --> 00:23:54.640
But this is the standard set up.

00:23:54.640 --> 00:23:57.500
And this is something-- this is
called a nonlinear optimization

00:23:57.500 --> 00:23:58.000
problem.

00:23:58.000 --> 00:24:01.060
It's something that lots
of people think about.

00:24:01.060 --> 00:24:02.770
There are heuristics
to solve it.

00:24:02.770 --> 00:24:04.815
You can solve in an
exponential time.

00:24:04.815 --> 00:24:06.440
In general, it's
NP-complete, and we'll

00:24:06.440 --> 00:24:10.190
see next class that actually
this problem of origami design

00:24:10.190 --> 00:24:11.540
is NP-complete.

00:24:11.540 --> 00:24:14.850
So there's not going to be
anything better than heuristics

00:24:14.850 --> 00:24:16.175
and and slow algorithms.

00:24:18.730 --> 00:24:20.670
So the idea is, you solve that.

00:24:20.670 --> 00:24:25.610
Now, you have your leaves on
your piece of paper somewhere.

00:24:25.610 --> 00:24:27.090
Now what?

00:24:27.090 --> 00:24:31.730
Now, you have to figure
out how everything folds.

00:24:31.730 --> 00:24:34.430
That's where we get to
some real combinatorial,

00:24:34.430 --> 00:24:37.656
some discrete geometry.

00:24:37.656 --> 00:24:38.570
Fun stuff.

00:24:44.770 --> 00:24:45.270
Yeah.

00:24:45.270 --> 00:24:48.750
I have one extra
motivation here.

00:24:48.750 --> 00:24:50.200
Origami design is
fun, but here's

00:24:50.200 --> 00:24:51.810
a puzzle you can solve, too.

00:24:56.170 --> 00:24:57.550
Which we can already see.

00:25:05.020 --> 00:25:07.860
Margulis napkin problem.

00:25:07.860 --> 00:25:09.990
Origin of this problem
is not entirely clear,

00:25:09.990 --> 00:25:13.690
but I think it came
from Russia originally.

00:25:13.690 --> 00:25:18.060
And the problem, the puzzle
is usually stated as follows.

00:25:18.060 --> 00:25:21.400
Prove that if you take
a unit square paper--

00:25:21.400 --> 00:25:25.400
so it has perimeter
four that you can,

00:25:25.400 --> 00:25:29.770
no matter how you fold it, the
perimeter always gets smaller.

00:25:29.770 --> 00:25:31.684
Never bigger than four.

00:25:31.684 --> 00:25:33.100
We used a very
similar thing here.

00:25:33.100 --> 00:25:34.766
We said, if you have
two points, they're

00:25:34.766 --> 00:25:36.690
distance can only get smaller.

00:25:36.690 --> 00:25:38.230
That's true.

00:25:38.230 --> 00:25:41.300
Margulis napkin
puzzle is not true.

00:25:41.300 --> 00:25:42.330
That's the difference.

00:25:42.330 --> 00:25:44.481
Perimeter is different
from distance.

00:25:44.481 --> 00:25:46.230
And in fact, you can
fold a piece of paper

00:25:46.230 --> 00:25:49.610
to make the perimeter
arbitrarily large,

00:25:49.610 --> 00:25:50.567
which is pretty crazy.

00:25:50.567 --> 00:25:52.150
And this is something
that Robert Lang

00:25:52.150 --> 00:25:55.720
proved few years ago, using--

00:25:55.720 --> 00:25:58.530
It's sort of easy once
you have the fact-- which

00:25:58.530 --> 00:26:02.150
I haven't quite written down
here, but I've been saying.

00:26:02.150 --> 00:26:05.520
As long as you place your
points subject to this property,

00:26:05.520 --> 00:26:08.290
there is a folding that
has that shadow tree.

00:26:10.890 --> 00:26:13.620
And so the idea with the
Margulis napkin problem

00:26:13.620 --> 00:26:17.080
is let's make a really
spiky tree, a star.

00:26:20.810 --> 00:26:23.720
I want to fold the
smallest square possible,

00:26:23.720 --> 00:26:25.780
so that projection
is this thing.

00:26:25.780 --> 00:26:31.750
Let's say that it has-- I won't
say how many limbs it has.

00:26:31.750 --> 00:26:35.190
But the idea is, if you're using
paper efficiently, in fact,

00:26:35.190 --> 00:26:37.600
the folding will be very narrow.

00:26:37.600 --> 00:26:41.060
It'll be a pretty efficient
use of paper, hopefully.

00:26:41.060 --> 00:26:43.640
And so the actual
3D state will just

00:26:43.640 --> 00:26:46.960
be a little bit
taller than that tree.

00:26:46.960 --> 00:26:48.510
And then, you just wash it.

00:26:48.510 --> 00:26:50.330
And the idea is that then
the perimeter is really big.

00:26:50.330 --> 00:26:51.788
You've got a-- the
perimeter as you

00:26:51.788 --> 00:26:53.370
walk around the
edges of that tree.

00:26:53.370 --> 00:26:56.760
So how big a tree can I get?

00:26:56.760 --> 00:26:59.330
I'd like to somehow
place these leaves-- now,

00:26:59.330 --> 00:27:01.640
what's the constraint
on the leaves?

00:27:01.640 --> 00:27:04.480
Let's say all of
these are length one.

00:27:04.480 --> 00:27:06.700
Then, this says it
every pair of leaves

00:27:06.700 --> 00:27:10.150
must be at least distance
two way from each other.

00:27:10.150 --> 00:27:12.900
So I got to place these
dots in the square

00:27:12.900 --> 00:27:15.100
so that every pair has
distance at least two.

00:27:15.100 --> 00:27:18.350
This is like saying--
here's my square.

00:27:18.350 --> 00:27:22.384
--I'd like to place dots
so their distance is

00:27:22.384 --> 00:27:23.300
at least distance two.

00:27:23.300 --> 00:27:25.150
That's like saying
if, I drew a unit

00:27:25.150 --> 00:27:29.910
disk around two points--
I got to remember.

00:27:29.910 --> 00:27:32.530
You should always draw the
disk first and then the center.

00:27:32.530 --> 00:27:33.900
Much easier.

00:27:33.900 --> 00:27:36.460
Those disks should
not be overlapping.

00:27:36.460 --> 00:27:41.750
If this is length one,
and this is length one,

00:27:41.750 --> 00:27:43.650
the disks will be
overlapping if and only

00:27:43.650 --> 00:27:46.140
if this distance is
smaller than two.

00:27:46.140 --> 00:27:48.420
I want it always to be
greater than or equal to two.

00:27:48.420 --> 00:27:52.677
So I just have to place a whole
bunch of disks in the square

00:27:52.677 --> 00:27:54.010
so that they're not overlapping.

00:27:54.010 --> 00:27:57.690
So how big a square
do I need to do that?

00:27:57.690 --> 00:28:00.850
This is a well-studied problem,
is the disk packing problem.

00:28:00.850 --> 00:28:02.670
A lot of results known about it.

00:28:02.670 --> 00:28:04.450
It's quite difficult.

00:28:04.450 --> 00:28:07.910
But we don't need to be super
smart here to get a good bound.

00:28:07.910 --> 00:28:12.830
Let's put a point-- let's
put points along a grid.

00:28:12.830 --> 00:28:14.660
I'm going to regret
making such a big grid.

00:28:18.960 --> 00:28:21.640
Let's say, an n by n grid.

00:28:27.380 --> 00:28:30.545
And I'm going to set
the size of my disks

00:28:30.545 --> 00:28:33.305
right so that these
guys just barely touch.

00:28:38.290 --> 00:28:40.870
This is actually not a
terribly good packing.

00:28:40.870 --> 00:28:43.810
You should do a triangular
grid instead of a square grid.

00:28:43.810 --> 00:28:47.610
But it'll be good
enough asymptotically.

00:28:47.610 --> 00:28:49.070
You get the idea.

00:28:49.070 --> 00:28:52.840
If I set the size of
my paper to be n by n,

00:28:52.840 --> 00:28:58.030
I can fit about n squared
unit disks in there.

00:28:58.030 --> 00:29:05.340
N by n paper folds something
like n plus 1 squared.

00:29:05.340 --> 00:29:10.320
But let's just say,
approximately n squared disks.

00:29:10.320 --> 00:29:16.170
So that means I can make a star
with about n squared limbs.

00:29:16.170 --> 00:29:17.990
It's insane.

00:29:17.990 --> 00:29:19.400
It's like super efficient.

00:29:19.400 --> 00:29:21.100
Each of these little
portions of paper

00:29:21.100 --> 00:29:22.599
ends up being one
of these segments.

00:29:22.599 --> 00:29:24.620
That's the claim is,
you could fold that.

00:29:24.620 --> 00:29:27.230
So once you fold this thing,
I have an n by n square.

00:29:27.230 --> 00:29:30.100
You started with
perimeter about four n

00:29:30.100 --> 00:29:33.200
And now, I have perimeter
about n squared.

00:29:33.200 --> 00:29:35.480
That's huge with
respect to four n.

00:29:35.480 --> 00:29:42.316
So this is much bigger than four
n, for n sufficiently large.

00:29:42.316 --> 00:29:44.759
AUDIENCE: [INAUDIBLE]
about the length flaps.

00:29:44.759 --> 00:29:47.300
PROFESSOR: Here, I was assuming
all the flaps are length one.

00:29:47.300 --> 00:29:50.600
So the disks are size one,
and so it's an n by n square.

00:29:54.540 --> 00:29:55.040
Clear?

00:29:55.040 --> 00:29:56.990
So this is more
motivation for why

00:29:56.990 --> 00:29:58.210
this theorem is interesting.

00:29:58.210 --> 00:30:01.280
It lets you solve
this fun math puzzle

00:30:01.280 --> 00:30:06.020
and show not only does a
perimeter not go-- not only

00:30:06.020 --> 00:30:08.716
does the perimeter
not only go down,

00:30:08.716 --> 00:30:11.229
but it can go arbitrarily high.

00:30:11.229 --> 00:30:12.520
It just takes a lot of folding.

00:30:16.370 --> 00:30:20.440
So let's say
something about how we

00:30:20.440 --> 00:30:22.820
prove that once you have a
valid placement of the points,

00:30:22.820 --> 00:30:26.405
you can actually fill in
the creases, find folding.

00:30:41.970 --> 00:30:43.145
Let me bring up an example.

00:30:46.966 --> 00:30:48.340
So this is actually
the example I

00:30:48.340 --> 00:30:51.110
keep using which is, you
want to make a lizard

00:30:51.110 --> 00:30:58.090
or some generic four-legged
tail and head kind of creature.

00:30:58.090 --> 00:31:00.900
This is the output
from TreeMaker,

00:31:00.900 --> 00:31:02.810
complete with crease
pattern and everything.

00:31:02.810 --> 00:31:05.080
But here, I've labeled
all the-- or actually

00:31:05.080 --> 00:31:07.920
Robert Lang, I think, has
labeled all of-- this a figure

00:31:07.920 --> 00:31:08.920
from our book.

00:31:08.920 --> 00:31:13.270
--all the vertices of
the tree and the shadow.

00:31:13.270 --> 00:31:15.480
And then, we're
labeling where they

00:31:15.480 --> 00:31:16.890
come from on the piece of paper.

00:31:19.750 --> 00:31:22.730
So in particular, you see
something like a leaf h.

00:31:22.730 --> 00:31:26.410
And it comes from this
one point on the paper.

00:31:26.410 --> 00:31:29.380
This leaf d comes
from this point,

00:31:29.380 --> 00:31:31.030
and g comes from that point.

00:31:31.030 --> 00:31:33.710
It's actually kind of
similarly oriented to this guy.

00:31:33.710 --> 00:31:36.730
The interior vertices, they
come from several points.

00:31:36.730 --> 00:31:38.440
It's a little messy.

00:31:38.440 --> 00:31:41.310
But let's-- one of the things
is to try to locate where those

00:31:41.310 --> 00:31:43.146
points ought to be.

00:31:43.146 --> 00:31:48.810
s So there's this idea
of an active path which

00:31:48.810 --> 00:31:55.720
is a path in the tree
between two leaves.

00:31:55.720 --> 00:31:57.227
I'll call them
shadow leaves to say

00:31:57.227 --> 00:31:58.560
that they're in the shadow tree.

00:32:03.650 --> 00:32:12.850
And the length of
that path equals

00:32:12.850 --> 00:32:19.370
the distance in the paper.

00:32:22.120 --> 00:32:25.020
So in the case of
making a star graph,

00:32:25.020 --> 00:32:28.140
this is exactly
when the disks kiss,

00:32:28.140 --> 00:32:32.130
when the just touch each
other on the boundary.

00:32:32.130 --> 00:32:35.860
So in other words, we
have this inequality,

00:32:35.860 --> 00:32:38.110
saying the distance
between in the paper should

00:32:38.110 --> 00:32:40.630
be greater than or equal
to distance in the tree.

00:32:40.630 --> 00:32:43.090
If that inequality is
actually an equality,

00:32:43.090 --> 00:32:46.640
if they're the same thing,
then it's kind of critical.

00:32:46.640 --> 00:32:50.730
I can't get those points
any closer in the paper.

00:32:50.730 --> 00:32:52.970
Those things I
call active paths.

00:32:52.970 --> 00:32:57.440
And that is some of
the lines up here.

00:32:57.440 --> 00:33:01.510
I guess the black
dashed line, actually,

00:33:01.510 --> 00:33:03.880
in a lot of the dash lines.

00:33:03.880 --> 00:33:06.360
All of the dash lines, I think.

00:33:06.360 --> 00:33:12.650
So for example, d to h, that's
a distance between two leaves.

00:33:12.650 --> 00:33:14.770
And if you measure the
distance here, it's two.

00:33:14.770 --> 00:33:17.410
And just imagine,
this example has

00:33:17.410 --> 00:33:19.130
been set up so this
is exactly two.

00:33:19.130 --> 00:33:19.910
So this is tight.

00:33:19.910 --> 00:33:22.950
I can't move h any closer
to d or vice versa.

00:33:22.950 --> 00:33:26.210
And also from h to
a, a is actually

00:33:26.210 --> 00:33:30.180
in the middle of the paper
and corresponds to that flap.

00:33:30.180 --> 00:33:33.540
That's all of those
green, actually

00:33:33.540 --> 00:33:37.190
it's just the green lines,
green dashed lines are active.

00:33:37.190 --> 00:33:38.960
They're kind of critical.

00:33:38.960 --> 00:33:41.480
And what's nice is that
subdivides my piece of paper

00:33:41.480 --> 00:33:43.800
into a bunch of smaller shapes.

00:33:43.800 --> 00:33:45.567
So I have a little
triangle out here.

00:33:45.567 --> 00:33:46.650
That turns out to be junk.

00:33:46.650 --> 00:33:48.070
We're not going to need
it because the sort

00:33:48.070 --> 00:33:49.260
of outside the diagram.

00:33:49.260 --> 00:33:50.690
You could folder underneath.

00:33:50.690 --> 00:33:53.420
Get rid of it.

00:33:53.420 --> 00:33:56.738
You've got a quadrilateral
here between the green lines.

00:33:56.738 --> 00:33:58.404
We've got a triangle
up here, a triangle

00:33:58.404 --> 00:34:00.700
at the top, triangle
on the left.

00:34:00.700 --> 00:34:04.190
All we need to do is fill
in those little parts.

00:34:04.190 --> 00:34:05.190
Fill in that triangle.

00:34:05.190 --> 00:34:06.410
Fill in that quadrilateral.

00:34:06.410 --> 00:34:08.868
Of course, in general, there
might not be any active paths,

00:34:08.868 --> 00:34:10.865
and we haven't simplified
the diagram at all.

00:34:10.865 --> 00:34:12.239
But if there are
no active paths,

00:34:12.239 --> 00:34:13.988
you're really probably
not very efficient.

00:34:13.988 --> 00:34:17.080
That means none of these
constraints are tight.

00:34:17.080 --> 00:34:21.960
That means you could increase
the scale factor lambda,

00:34:21.960 --> 00:34:23.544
make a better model.

00:34:23.544 --> 00:34:25.460
You can increase lambda
at least a little bit.

00:34:25.460 --> 00:34:27.909
If all of these are
strictly greater,

00:34:27.909 --> 00:34:30.846
you can increase lambda until
one of them becomes equal.

00:34:30.846 --> 00:34:32.679
So you should have at
least one active path.

00:34:32.679 --> 00:34:34.179
And in fact if
you're efficient, you

00:34:34.179 --> 00:34:37.300
should have lots
of active paths.

00:34:37.300 --> 00:34:40.620
I don't think I need to
be too formal about that.

00:34:46.080 --> 00:34:46.760
But it's true.

00:34:49.380 --> 00:34:53.469
And here's one thing you
can show about active paths.

00:34:53.469 --> 00:34:55.750
So what would be really
nice, in this example,

00:34:55.750 --> 00:34:57.450
I have triangles
and quadrilaterals.

00:34:57.450 --> 00:34:59.241
In general, I'm going
to have a whole bunch

00:34:59.241 --> 00:35:00.369
of different shapes.

00:35:00.369 --> 00:35:01.910
Some of them could
even be non-convex

00:35:01.910 --> 00:35:03.512
which would be annoying.

00:35:03.512 --> 00:35:05.470
I would really just like
to deal with triangles

00:35:05.470 --> 00:35:07.670
because I like
triangles-- geometer.

00:35:07.670 --> 00:35:09.087
And triangles are simple.

00:35:09.087 --> 00:35:11.170
And it looks like the
crease pattern in a triangle

00:35:11.170 --> 00:35:12.500
is pretty simple.

00:35:12.500 --> 00:35:14.440
In fact, it's just
angular bisectors

00:35:14.440 --> 00:35:19.940
of the triangle plus a few
extra perpendicular folds.

00:35:19.940 --> 00:35:22.380
So that would be
kind of nice if I

00:35:22.380 --> 00:35:24.220
could get everything triangles.

00:35:24.220 --> 00:35:26.640
To do that, I need
lots of active paths.

00:35:26.640 --> 00:35:30.360
So how can I guarantee that
there's lots of active paths?

00:35:30.360 --> 00:35:33.420
I'm going wave my hands a little
bit about how this is done.

00:35:37.580 --> 00:35:43.200
But the idea is to
augment the tree.

00:35:43.200 --> 00:35:46.060
So I have some tree that
I actually want to make,

00:35:46.060 --> 00:35:47.490
like lizard.

00:35:47.490 --> 00:35:49.930
And I'm going to add
some extra stuff.

00:35:49.930 --> 00:35:52.655
Like maybe I'll add a branch
here and a branch here

00:35:52.655 --> 00:35:53.700
or whatever.

00:35:53.700 --> 00:35:54.450
Whatever it takes.

00:35:57.130 --> 00:35:59.830
I got to do so carefully.

00:35:59.830 --> 00:36:01.160
So let me say what that means.

00:36:05.400 --> 00:36:15.360
So I'm going to add extra
leaves to the shadow tree.

00:36:19.340 --> 00:36:47.300
My goal is to make the active
paths triangulate the paper

00:36:47.300 --> 00:36:49.030
without changing
the scale factor.

00:36:57.040 --> 00:36:58.365
So this is kind of a cheat.

00:36:58.365 --> 00:37:00.740
And most of the time, you
don't actually need this cheat.

00:37:00.740 --> 00:37:06.330
But for proving things, it
makes life a little easier.

00:37:06.330 --> 00:37:08.890
So we want to show that
it's enough to place

00:37:08.890 --> 00:37:10.800
the vertices subject
to this, the leaves

00:37:10.800 --> 00:37:14.080
subject to this constraint.

00:37:14.080 --> 00:37:16.090
So ideally, we make our tree.

00:37:16.090 --> 00:37:18.790
But if we make an even
more complicated tree,

00:37:18.790 --> 00:37:22.551
like with these extra little
limbs, we can get rid of them

00:37:22.551 --> 00:37:23.050
at the end.

00:37:23.050 --> 00:37:24.930
You just fold them
over and collapse

00:37:24.930 --> 00:37:27.770
this flap against
an adjacent flap.

00:37:27.770 --> 00:37:31.872
So if we make our life
harder, that's OK, too.

00:37:31.872 --> 00:37:33.580
If we could fold a
more complicated tree,

00:37:33.580 --> 00:37:35.540
in particular we folded
the tree we wanted.

00:37:35.540 --> 00:37:38.850
If we can do that without
changing the scale factor,

00:37:38.850 --> 00:37:41.270
then great.

00:37:41.270 --> 00:37:43.480
Then, we did what
we wanted to do.

00:37:43.480 --> 00:37:47.845
We folded our piece of paper
with the desired scale factor.

00:37:47.845 --> 00:37:49.970
In reality, we're actually
going to move the leaves

00:37:49.970 --> 00:37:52.709
around a little bit
so that we have to do.

00:37:52.709 --> 00:37:54.250
We're going to move
around the leaves

00:37:54.250 --> 00:37:56.125
that you already placed
in order to make room

00:37:56.125 --> 00:37:57.400
for the new leaves.

00:37:57.400 --> 00:37:58.520
But here's the idea.

00:37:58.520 --> 00:38:01.600
We have these leaves.

00:38:01.600 --> 00:38:04.470
There's some active
paths, these green lines.

00:38:04.470 --> 00:38:07.610
And we'd really-- we have this
quadrilateral in the center.

00:38:07.610 --> 00:38:09.380
We'd really like
to subdivide it.

00:38:09.380 --> 00:38:11.420
Like this black line is
kind of asking for it.

00:38:11.420 --> 00:38:13.140
It would be really
nice if we could just

00:38:13.140 --> 00:38:16.590
add in an active paths there.

00:38:16.590 --> 00:38:17.930
And you can do it.

00:38:17.930 --> 00:38:21.170
Let's see if I can identify
what we're talking about here.

00:38:21.170 --> 00:38:23.570
So a fun thing
about active paths,

00:38:23.570 --> 00:38:27.130
you look at two leaves like
g d here, which corresponds

00:38:27.130 --> 00:38:31.140
to this path g d here,
because it's active,

00:38:31.140 --> 00:38:35.490
you know this length is exactly
the length traced right here.

00:38:35.490 --> 00:38:37.100
So that means, this
segment has to be

00:38:37.100 --> 00:38:39.080
folded right along
the tree here.

00:38:39.080 --> 00:38:41.340
You know that this
segment is that.

00:38:41.340 --> 00:38:44.790
And so in particular, you know
where c is on that segment.

00:38:44.790 --> 00:38:47.360
C actually comes from multiple
points in this diagram.

00:38:47.360 --> 00:38:52.345
But you know that this point
right here must fold to c.

00:38:52.345 --> 00:38:55.260
And you know this point
must fold here and so on.

00:38:55.260 --> 00:38:56.520
These guys correspond.

00:39:00.500 --> 00:39:01.730
So that's good.

00:39:01.730 --> 00:39:04.590
So if I look at
this quadrilateral,

00:39:04.590 --> 00:39:13.450
it corresponds so g to c to d
to c to h to c to b to a back

00:39:13.450 --> 00:39:16.220
to b back to c.

00:39:16.220 --> 00:39:25.300
And so my guess is if you
add a little limb in here--

00:39:25.300 --> 00:39:26.670
I think I can draw on this.

00:39:26.670 --> 00:39:30.050
That would be nice.

00:39:30.050 --> 00:39:35.100
Should really tell you
about-- is this going to work?

00:39:35.100 --> 00:39:35.600
Yes.

00:39:35.600 --> 00:39:37.190
It's kind of white,
but there we go.

00:39:39.940 --> 00:39:44.020
So great.

00:39:44.020 --> 00:39:45.380
Draw a fun diagram here.

00:39:48.450 --> 00:39:50.760
This is how I make my lecture
notes if you're curious.

00:39:50.760 --> 00:39:51.730
This is a tablet PC.

00:39:56.100 --> 00:40:02.261
Now, I've got
some-- Tell me if I

00:40:02.261 --> 00:40:04.260
make a mistake, those who
know what I'm drawing.

00:40:08.088 --> 00:40:10.060
What the hell is this?

00:40:10.060 --> 00:40:12.916
I think it goes there.

00:40:12.916 --> 00:40:15.320
There.

00:40:15.320 --> 00:40:16.150
There.

00:40:16.150 --> 00:40:18.880
I'll explain what I'm
drawing once I've drawn it.

00:40:18.880 --> 00:40:21.920
It's easier.

00:40:21.920 --> 00:40:23.180
Something like that.

00:40:23.180 --> 00:40:27.330
This is a bunch of disks
and a bunch of other things,

00:40:27.330 --> 00:40:30.490
there's only one
here called rivers.

00:40:30.490 --> 00:40:34.260
And this is a geometric way to
think about the constraints.

00:40:34.260 --> 00:40:41.180
If you look at this structure--
so I have a disk down

00:40:41.180 --> 00:40:42.290
here corresponding to d.

00:40:42.290 --> 00:40:44.540
I have a disk corresponding
to h, a disk corresponding

00:40:44.540 --> 00:40:48.392
to g, a river corresponding
to the segment b c.

00:40:48.392 --> 00:40:49.850
The reason I only
have one river is

00:40:49.850 --> 00:40:52.420
there's only one interior
edge in this tree.

00:40:52.420 --> 00:40:54.160
Everything else is a leaf edge.

00:40:54.160 --> 00:40:56.330
So leaf edges are
going to be disks.

00:40:56.330 --> 00:40:58.760
All non leaf edges are
going to be rivers.

00:40:58.760 --> 00:41:01.300
And the structure, the way
that those things connect

00:41:01.300 --> 00:41:04.560
to each other is the same as
the structure in this tree.

00:41:04.560 --> 00:41:07.020
So you've got the
three disks down here,

00:41:07.020 --> 00:41:08.930
which corresponds
to these leaf edges.

00:41:08.930 --> 00:41:11.830
They all touch a common river
because all of those edges

00:41:11.830 --> 00:41:16.096
are incident to that
edge in the center.

00:41:16.096 --> 00:41:17.720
And there's three
disks on the top that

00:41:17.720 --> 00:41:21.082
correspond to the three
leaf edges up here.

00:41:21.082 --> 00:41:22.540
This is really just
the same thing.

00:41:22.540 --> 00:41:25.100
It's saying that if
you want to look, say,

00:41:25.100 --> 00:41:28.440
at the distance
between h and a here.

00:41:28.440 --> 00:41:31.140
The distance between h and
a should be length three.

00:41:31.140 --> 00:41:32.940
And those three
lengths are represented

00:41:32.940 --> 00:41:35.400
by the size of
this disk, followed

00:41:35.400 --> 00:41:37.410
by the width of
this river, followed

00:41:37.410 --> 00:41:39.660
by the size of the a disk.

00:41:39.660 --> 00:41:42.510
It's say exactly the same
constraints, just represented

00:41:42.510 --> 00:41:43.500
geometrically.

00:41:43.500 --> 00:41:45.900
Now, if I'm lucky,
these regions actually

00:41:45.900 --> 00:41:47.530
kiss, they touch at points.

00:41:47.530 --> 00:41:49.550
That's when things are active.

00:41:49.550 --> 00:41:53.940
And you could draw straight
across from a to h and never go

00:41:53.940 --> 00:41:56.050
in these outside regions.

00:41:56.050 --> 00:41:58.640
If you're not lucky,
they won't touch.

00:41:58.640 --> 00:42:01.620
If they don't touch,
make them touch.

00:42:01.620 --> 00:42:04.210
That's all I want to do.

00:42:04.210 --> 00:42:08.240
And so I just want to
blow up these regions,

00:42:08.240 --> 00:42:13.280
make them longer, for
example, until things touch.

00:42:13.280 --> 00:42:15.580
When they touch enough,
if you do it right,

00:42:15.580 --> 00:42:17.670
you can actually get
them to triangulate.

00:42:17.670 --> 00:42:20.270
That's my very
hand wavy argument.

00:42:20.270 --> 00:42:22.110
It's proved formally
in the book,

00:42:22.110 --> 00:42:23.740
and it's a little bit technical.

00:42:23.740 --> 00:42:31.137
So I think I will
move on and tell you

00:42:31.137 --> 00:42:32.220
what to do with triangles.

00:43:29.610 --> 00:43:34.310
So suppose you
have some triangle.

00:43:34.310 --> 00:43:36.970
And each of these edges
is an active path.

00:43:36.970 --> 00:43:38.160
So there's some leaf here.

00:43:41.130 --> 00:43:44.700
We'll call them a, b, and c.

00:43:44.700 --> 00:43:49.670
And this segment we know will
map right along the floor

00:43:49.670 --> 00:43:56.430
to make up that path, that
active path in the tree.

00:43:56.430 --> 00:43:59.720
Like I said, we're going to
follow along angular bisectors.

00:44:05.260 --> 00:44:09.560
You may know the angular
bisectors of a triangle

00:44:09.560 --> 00:44:12.750
meet at a single point.

00:44:12.750 --> 00:44:15.200
And then, we're going to
make some perpendicular

00:44:15.200 --> 00:44:27.705
folds like that.

00:44:30.990 --> 00:44:33.280
Where the
perpendicular folds go,

00:44:33.280 --> 00:44:38.140
well, they go whenever
there's a shadow

00:44:38.140 --> 00:44:40.680
vertex along this segment.

00:44:40.680 --> 00:44:44.920
Remember this edge,
b c corresponds

00:44:44.920 --> 00:44:49.620
to some path between b
and c in the tree which

00:44:49.620 --> 00:44:52.134
looks like whatever.

00:44:52.134 --> 00:44:53.550
And so for each
of these branching

00:44:53.550 --> 00:44:56.684
points that we visit along
that, we can just measure.

00:44:56.684 --> 00:44:59.350
As we move along here, we get to
some vertex then another vertex

00:44:59.350 --> 00:45:04.630
then another vertex then c,
except I did it backwards.

00:45:04.630 --> 00:45:07.079
And so for each of
these guys, I know

00:45:07.079 --> 00:45:08.870
that I need to be able
to articulate there.

00:45:08.870 --> 00:45:10.510
I need a hinge crease.

00:45:10.510 --> 00:45:13.480
And so I just put in a
hinge grace perpendicular

00:45:13.480 --> 00:45:15.100
to the floor,
essentially, because we

00:45:15.100 --> 00:45:17.370
know this is mapping
to the floor.

00:45:17.370 --> 00:45:19.560
And conveniently,
those will all line up.

00:45:19.560 --> 00:45:22.730
So if I have some vertex
here-- let's call it d.

00:45:22.730 --> 00:45:24.150
--d will be here.

00:45:24.150 --> 00:45:25.900
But d will also be here.

00:45:25.900 --> 00:45:27.720
Because if I follow
the path from b to a,

00:45:27.720 --> 00:45:30.580
a is some other
guy, maybe this one,

00:45:30.580 --> 00:45:32.960
I also have to go through d.

00:45:32.960 --> 00:45:35.464
And so these things will
conveniently line up perfectly.

00:45:35.464 --> 00:45:36.880
I'm not going to
prove that again.

00:45:36.880 --> 00:45:39.420
But it's true.

00:45:39.420 --> 00:45:42.730
And you just get this really
nice simple to fold thing.

00:45:45.421 --> 00:45:46.920
Shoot, I'll fold
one if you haven't.

00:45:46.920 --> 00:45:50.545
This is a standard rabbit ear
molecule in making origami.

00:45:50.545 --> 00:45:51.670
You have a little triangle.

00:45:51.670 --> 00:45:53.080
You want to make it an ear.

00:45:53.080 --> 00:45:55.260
You squeeze along the
angular bisectors,

00:45:55.260 --> 00:45:58.150
and it makes a cute rabbit ear.

00:45:58.150 --> 00:46:00.310
And you can see it also,
the crease pattern,

00:46:00.310 --> 00:46:05.980
in here like in this
triangle in the upper right.

00:46:05.980 --> 00:46:08.940
You've got the red lines which
are the angular bisectors.

00:46:08.940 --> 00:46:11.470
And then, you've got all
those perpendicular folds.

00:46:11.470 --> 00:46:14.680
And they go exactly
where those letters go.

00:46:14.680 --> 00:46:18.430
And the triangle at
the top is similar.

00:46:18.430 --> 00:46:22.280
It's a little different because
the very top edge of the paper

00:46:22.280 --> 00:46:23.550
is not actually active.

00:46:23.550 --> 00:46:27.030
So there's really a
special case there.

00:46:27.030 --> 00:46:28.410
Upper right is also not active.

00:46:28.410 --> 00:46:30.460
Oh, that's annoying.

00:46:30.460 --> 00:46:33.012
Yeah.

00:46:33.012 --> 00:46:34.470
There's a little
bit of extra stuff

00:46:34.470 --> 00:46:35.850
that happens at the
boundary of the paper

00:46:35.850 --> 00:46:37.450
where you don't
have active paths.

00:46:37.450 --> 00:46:39.590
But it's, as you can see
from the crease pattern,

00:46:39.590 --> 00:46:41.770
it's basically the same.

00:46:41.770 --> 00:46:46.200
In fact, I could
call it the same.

00:46:46.200 --> 00:46:48.595
It's a little bit less pretty
because this is not green.

00:46:48.595 --> 00:46:50.511
And so you don't actually
know that c is here.

00:46:50.511 --> 00:46:52.030
And you don't know
that b is there.

00:46:52.030 --> 00:46:54.542
But you know about
all the other edges.

00:46:54.542 --> 00:46:56.500
There's just one edge
you might not know about.

00:46:56.500 --> 00:46:57.890
And so you can figure
out what the right edge

00:46:57.890 --> 00:47:00.700
is based on the other edges
of the triangle, the other two

00:47:00.700 --> 00:47:01.200
edges.

00:47:04.210 --> 00:47:05.190
That's just a feature.

00:47:05.190 --> 00:47:09.000
You can triangulate everything
except the boundary.

00:47:09.000 --> 00:47:11.700
You may not be able to get
active paths in this step.

00:47:16.070 --> 00:47:18.300
That kind of does
the tree method

00:47:18.300 --> 00:47:20.465
in a super abbreviated version.

00:47:23.980 --> 00:47:27.930
I showed you a demo last
time, just in case you forgot.

00:47:27.930 --> 00:47:30.135
You draw your favorite tree.

00:47:30.135 --> 00:47:31.760
See if I can get it
to do the same one.

00:47:37.360 --> 00:47:41.645
And you optimize,
generate a crease pattern.

00:47:41.645 --> 00:47:43.350
Oh, it's a different one.

00:47:43.350 --> 00:47:44.150
Fun.

00:47:44.150 --> 00:47:46.930
There it is.

00:47:46.930 --> 00:47:49.129
And here, TreeMaker knows
how to draw the disks.

00:47:49.129 --> 00:47:51.670
It doesn't currently know how
to draw the rivers because it's

00:47:51.670 --> 00:47:55.790
kind of tricky to make a snakey
path in a computer program.

00:47:55.790 --> 00:47:59.380
But you see the three disks down
here, the three disks up there,

00:47:59.380 --> 00:48:01.290
and you can imagine
the one river

00:48:01.290 --> 00:48:07.437
in the middle representing the
central segment of your tree.

00:48:07.437 --> 00:48:09.270
And one of the problems
on the problems set,

00:48:09.270 --> 00:48:11.490
problem set one is
released, is to just make

00:48:11.490 --> 00:48:12.769
something using TreeMaker.

00:48:12.769 --> 00:48:14.310
I would encourage
you to start simple

00:48:14.310 --> 00:48:15.420
unless you know
what you're doing.

00:48:15.420 --> 00:48:16.750
You don't have to
use the program.

00:48:16.750 --> 00:48:18.380
You could do it by
hand, placing disks.

00:48:18.380 --> 00:48:20.760
That's how most
origamists actually do it.

00:48:20.760 --> 00:48:23.850
I'm sure Jason will
do it that way.

00:48:23.850 --> 00:48:27.642
You can use the program,
print out a crease pattern,

00:48:27.642 --> 00:48:28.600
see what it looks like.

00:48:31.760 --> 00:48:32.440
Next thing.

00:48:36.320 --> 00:48:38.200
If you want to do
this in reality--

00:48:38.200 --> 00:48:40.962
and what TreeMaker is doing
is not this triangulation.

00:48:40.962 --> 00:48:42.670
Doing a triangulation
is a bit of a pain,

00:48:42.670 --> 00:48:44.474
but you could keep
modifying your tree

00:48:44.474 --> 00:48:45.390
until it triangulates.

00:48:45.390 --> 00:48:47.860
The alternative is you
just deal with polygons

00:48:47.860 --> 00:48:49.654
that are bigger than triangles.

00:48:49.654 --> 00:48:51.820
And there's this thing
called the universal molecule

00:48:51.820 --> 00:48:52.980
by Robert Lang.

00:48:52.980 --> 00:48:55.610
Here it is for a quadrilateral.

00:48:55.610 --> 00:49:01.070
And it makes it-- this works
for any convex polygon.

00:49:01.070 --> 00:49:03.430
Now sometimes, you're
active paths don't decompose

00:49:03.430 --> 00:49:05.360
your shape into convex polygons.

00:49:05.360 --> 00:49:06.710
And this still doesn't work.

00:49:06.710 --> 00:49:08.370
You still have to
do something here.

00:49:08.370 --> 00:49:10.080
You need to add some
extra leaf edges

00:49:10.080 --> 00:49:13.790
to the tree to just
fill things up.

00:49:13.790 --> 00:49:15.910
But you don't have to stop.

00:49:15.910 --> 00:49:18.440
You have to go all the way to
the point of triangulation.

00:49:18.440 --> 00:49:21.370
You can stop at the point which
happens most the time when

00:49:21.370 --> 00:49:23.150
all of the faces are convex.

00:49:23.150 --> 00:49:27.440
And then, it's a slightly more
general picture what happens.

00:49:27.440 --> 00:49:29.060
Intuitively, what
you want to do is,

00:49:29.060 --> 00:49:33.010
this is the tree you want
to make among those leaves.

00:49:33.010 --> 00:49:35.305
All the boundary edges
here are active paths.

00:49:35.305 --> 00:49:37.502
You have g d h a.

00:49:37.502 --> 00:49:38.960
Those are active
paths, so you know

00:49:38.960 --> 00:49:43.679
where all of those branching
points are in the middle.

00:49:43.679 --> 00:49:44.720
You'd like to build that.

00:49:44.720 --> 00:49:47.460
And so what we're going to
do is build it bottom up

00:49:47.460 --> 00:49:52.050
in the literal sense from z
equals zero, increasing z.

00:49:52.050 --> 00:49:54.650
And what that corresponds
to in this picture

00:49:54.650 --> 00:49:59.580
is shrinking or offsetting
these edges inward.

00:49:59.580 --> 00:50:01.790
So you offset these
all by the same amount.

00:50:01.790 --> 00:50:04.014
That's like traveling
up over here.

00:50:04.014 --> 00:50:05.680
So you see the red
lines here correspond

00:50:05.680 --> 00:50:07.890
to the red cross sections.

00:50:07.890 --> 00:50:10.010
So I just see what happens
in cross section is

00:50:10.010 --> 00:50:11.460
I shrink things in.

00:50:11.460 --> 00:50:15.580
And the first thing that happens
at this first critical red

00:50:15.580 --> 00:50:20.890
drawing is that the path
from d to a becomes critical,

00:50:20.890 --> 00:50:22.860
becomes active.

00:50:22.860 --> 00:50:25.364
Before it was
inactive that-- that

00:50:25.364 --> 00:50:26.530
was kind of annoying for me.

00:50:26.530 --> 00:50:28.680
I wanted it to be
triangulated, but it wasn't.

00:50:28.680 --> 00:50:32.070
The distance from a to
d in the piece of paper

00:50:32.070 --> 00:50:40.180
was bigger than the distance
between the leaves in the tree.

00:50:40.180 --> 00:50:41.264
I wanted them to be equal.

00:50:41.264 --> 00:50:43.138
Well, it turns out, if
you shrink this thing,

00:50:43.138 --> 00:50:44.650
eventually they
might become equal.

00:50:44.650 --> 00:50:45.650
And that's what happens.

00:50:45.650 --> 00:50:47.109
And that's what
TreeMaker computes.

00:50:47.109 --> 00:50:48.816
And what you should
do if you're building

00:50:48.816 --> 00:50:49.800
the universal molecule.

00:50:49.800 --> 00:50:53.680
If you discover, oh,
now a d is active,

00:50:53.680 --> 00:50:55.730
now, I subdivide
into two triangles.

00:50:55.730 --> 00:50:57.960
And then, I do the thing
in the two triangles.

00:50:57.960 --> 00:51:00.167
And generally, you start
with some convex polygon.

00:51:00.167 --> 00:51:00.750
You shrink it.

00:51:00.750 --> 00:51:03.370
At some point, some diagonal
might become active.

00:51:03.370 --> 00:51:07.240
You split it into two,
just keep going in the two.

00:51:07.240 --> 00:51:10.510
And there's one other
thing which can happen,

00:51:10.510 --> 00:51:12.640
which is what's happening
at the end of a triangle.

00:51:12.640 --> 00:51:13.585
You shrink.

00:51:13.585 --> 00:51:15.710
And then, it could be two
vertices actually collide

00:51:15.710 --> 00:51:16.704
with each other.

00:51:16.704 --> 00:51:18.620
And then, you just think
of them as one vertex

00:51:18.620 --> 00:51:20.360
and keep shrinking.

00:51:20.360 --> 00:51:23.250
So that's the general universal
molecule construction.

00:51:23.250 --> 00:51:29.380
You see in a sort of-- these are
the cross sections from above.

00:51:29.380 --> 00:51:32.290
You see that as you go up,
things are getting smaller.

00:51:32.290 --> 00:51:36.870
That is one of the statements of
the uniaxial base as you go up.

00:51:36.870 --> 00:51:40.467
Cross sections get tinier.

00:51:40.467 --> 00:51:42.050
And that gives you
the crease pattern.

00:51:42.050 --> 00:51:44.780
If you follow along
where the vertices go

00:51:44.780 --> 00:51:46.290
during this process,
and you draw in

00:51:46.290 --> 00:51:48.760
and all the active path that
you create along the way,

00:51:48.760 --> 00:51:49.884
that's your crease pattern.

00:51:54.490 --> 00:51:56.579
So that's how you do
it more practically is

00:51:56.579 --> 00:51:57.870
you use the universal molecule.

00:51:57.870 --> 00:51:59.786
But to prove it, you
don't actually need that.

00:52:02.560 --> 00:52:03.450
All right.

00:52:03.450 --> 00:52:10.725
I have now some more real
examples by Robert Lang

00:52:10.725 --> 00:52:13.030
and by Jason Ku.

00:52:13.030 --> 00:52:15.850
So here is Roosevelt elk.

00:52:15.850 --> 00:52:21.900
And Rob is all about
getting very realistic form.

00:52:21.900 --> 00:52:25.070
So all of the branching
measurements and-- I'm

00:52:25.070 --> 00:52:26.839
sure if you knew
a lot about elks,

00:52:26.839 --> 00:52:28.380
you could recognizes
this a Roosevelt

00:52:28.380 --> 00:52:30.380
elk not some other elk.

00:52:30.380 --> 00:52:33.506
And you can achieve that
level of detail and realism

00:52:33.506 --> 00:52:34.880
using the tree
method because you

00:52:34.880 --> 00:52:38.080
can control all of the relative
lengths of those segments

00:52:38.080 --> 00:52:39.719
and get perfect
branching structure

00:52:39.719 --> 00:52:41.843
and get the right proportions
for the legs and tail

00:52:41.843 --> 00:52:43.310
and so on.

00:52:43.310 --> 00:52:46.730
And you can see
here, the-- and you

00:52:46.730 --> 00:52:50.640
can go to Robert Lang's webpage,
landorigami.com and print this

00:52:50.640 --> 00:52:51.190
out.

00:52:51.190 --> 00:52:52.790
And try it out if you want.

00:52:52.790 --> 00:52:56.110
This will fold not this but
the base for that model.

00:52:56.110 --> 00:52:57.570
And you could see the disks.

00:52:57.570 --> 00:52:59.740
And you can see some
approximation of the rivers

00:52:59.740 --> 00:53:01.220
here.

00:53:01.220 --> 00:53:06.220
But they're not quite drawn
in in this particular diagram.

00:53:06.220 --> 00:53:07.302
But a lot of detail.

00:53:07.302 --> 00:53:09.010
And if you look
carefully, you can really

00:53:09.010 --> 00:53:10.360
read off what the tree is here.

00:53:10.360 --> 00:53:12.500
You can see how these
things are separated,

00:53:12.500 --> 00:53:16.850
and it will correspond to the
branching structure over there.

00:53:16.850 --> 00:53:19.390
Here's a more complicated one.

00:53:19.390 --> 00:53:23.010
Scorpion varleg
which you can also

00:53:23.010 --> 00:53:27.450
fold at lifesize if
you're really crazy.

00:53:27.450 --> 00:53:32.420
And you can also see from
these kinds of diagrams

00:53:32.420 --> 00:53:36.530
that paper usage is super
efficient in these designs.

00:53:36.530 --> 00:53:40.200
And presumably that's
how Robert design them.

00:53:40.200 --> 00:53:42.340
The only paper we're
wasting in some sense

00:53:42.340 --> 00:53:47.910
is the little regions between
the disks and the rivers

00:53:47.910 --> 00:53:49.341
which is quite small.

00:53:49.341 --> 00:53:51.465
Most of the papers getting
absorbed into the flaps.

00:53:54.570 --> 00:53:57.810
Here's one of the first
models by Jason Ku that I saw,

00:53:57.810 --> 00:54:00.380
the Nazgul from
Lord of the Rings.

00:54:00.380 --> 00:54:02.890
And pretty complicated.

00:54:02.890 --> 00:54:05.760
So here, the bold lines
show you essentially

00:54:05.760 --> 00:54:07.900
where the disks and the
rivers are that have been--

00:54:07.900 --> 00:54:09.320
AUDIENCE: Those are
actually the hinge creases.

00:54:09.320 --> 00:54:10.944
PROFESSOR: Oh, those
are hinge creases.

00:54:10.944 --> 00:54:12.200
Yeah.

00:54:12.200 --> 00:54:12.820
Good.

00:54:12.820 --> 00:54:16.150
And the top is the
actual crease pattern.

00:54:16.150 --> 00:54:17.860
And it's pretty awesome.

00:54:17.860 --> 00:54:20.400
You've got a horse and rider
out of one square paper.

00:54:24.110 --> 00:54:26.260
Here's a shrimp.

00:54:26.260 --> 00:54:29.440
He's super complicated
and super realistic.

00:54:29.440 --> 00:54:32.010
It looks very shrimpy.

00:54:32.010 --> 00:54:34.210
I know some people who
are freaked out by shrimp.

00:54:34.210 --> 00:54:37.320
And so this should really
elicit that similar response.

00:54:37.320 --> 00:54:42.140
Or other people get really
hungry at this point, I guess.

00:54:42.140 --> 00:54:45.180
But you could see the
tree is pretty dense here,

00:54:45.180 --> 00:54:49.980
lots of little features
getting that branching right.

00:54:49.980 --> 00:54:52.770
And one last example
is this butterfly

00:54:52.770 --> 00:54:56.790
which is pretty
awesome in its realism.

00:54:56.790 --> 00:55:00.160
And I guess the tree
is a lot simpler here.

00:55:00.160 --> 00:55:03.120
But there's a lot of
extra creases here.

00:55:03.120 --> 00:55:07.130
You see just for getting
the flaps nice and narrow.

00:55:07.130 --> 00:55:11.740
So in general, these
kinds of constructions

00:55:11.740 --> 00:55:14.590
will make this guy
rather pointy and tall.

00:55:14.590 --> 00:55:16.540
And you can just squash it back.

00:55:16.540 --> 00:55:18.430
And it's called a
sync fold and make

00:55:18.430 --> 00:55:23.180
it tinier like-- you
have something like this.

00:55:23.180 --> 00:55:25.280
The flaps are you
think are too tall.

00:55:25.280 --> 00:55:30.300
You just fold here.

00:55:30.300 --> 00:55:32.600
Which, if you look at
the crease pattern,

00:55:32.600 --> 00:55:35.840
makes just an offset
version of the original.

00:55:35.840 --> 00:55:38.050
And hey, now your
flaps are half is tall.

00:55:38.050 --> 00:55:41.140
And if you're a
proper origamist,

00:55:41.140 --> 00:55:45.878
you-- I shouldn't do this live.

00:55:50.760 --> 00:55:53.400
You change the mountain valley
assignment a little bit,

00:55:53.400 --> 00:55:55.840
and you sync everything
on the inside

00:55:55.840 --> 00:55:57.470
instead of just folding it over.

00:56:02.728 --> 00:56:05.370
It's not going to
look super pretty.

00:56:05.370 --> 00:56:11.680
But same tree structure, just
the flaps are half as tall.

00:56:11.680 --> 00:56:14.740
So that's all this
pleating here.

00:56:14.740 --> 00:56:18.310
And I think that's it
for my little tour.

00:56:18.310 --> 00:56:21.350
And Jason Ku next.

00:56:21.350 --> 00:56:23.220
Next Monday we'll
be talking more

00:56:23.220 --> 00:56:26.290
about the artistic side,
history of origami design,

00:56:26.290 --> 00:56:29.300
and what it takes to
really make something

00:56:29.300 --> 00:56:31.150
real by these approaches.

00:56:31.150 --> 00:56:33.690
That should be lots of fun.

00:56:33.690 --> 00:56:37.380
I want to move on to other kinds
of efficient origami design.

00:56:37.380 --> 00:56:43.510
Less directly applicable
to real origami design

00:56:43.510 --> 00:56:46.400
so to speak, at least currently.

00:56:46.400 --> 00:56:48.370
But mathematically
more powerful.

00:56:48.370 --> 00:56:50.700
Uniaxial bases are
nice, but it's not

00:56:50.700 --> 00:56:52.840
everything you
might want to fold.

00:56:52.840 --> 00:56:56.940
So what if we want
to fold other stuff.

00:57:03.180 --> 00:57:06.290
And to a geometer,
most natural version

00:57:06.290 --> 00:57:08.650
of folding other stuff
or folding anything

00:57:08.650 --> 00:57:09.740
is a polyhedron.

00:57:09.740 --> 00:57:13.300
You have a bunch of
polygons, flat panels in 3D,

00:57:13.300 --> 00:57:15.570
somehow joined together
to make some surface.

00:57:15.570 --> 00:57:17.130
How do I fold that?

00:57:17.130 --> 00:57:20.410
And let's start with a super
simple example which is I

00:57:20.410 --> 00:57:25.600
want to fold a
square into a cube.

00:57:25.600 --> 00:57:30.590
How big a square do I
need to fold a unit cube?

00:57:30.590 --> 00:57:33.850
Or how big cube can I
fold for a unit square?

00:57:33.850 --> 00:57:36.450
Either way.

00:57:36.450 --> 00:57:43.700
And I'm going to make
it a one by one square.

00:57:43.700 --> 00:57:51.060
And I'm going to fold it
into a cube of dimension x.

00:57:51.060 --> 00:57:55.160
And I want to know--
it looks funny.

00:57:55.160 --> 00:57:56.930
It's the quintuple x cubed.

00:57:59.460 --> 00:58:00.586
It's the x-coordinate.

00:58:00.586 --> 00:58:01.460
That's my motivation.

00:58:06.800 --> 00:58:09.660
So we talked-- one
thing we can think about

00:58:09.660 --> 00:58:13.330
is what makes the
corners of the cubes

00:58:13.330 --> 00:58:15.910
and how far away should they be.

00:58:15.910 --> 00:58:18.650
So if I want to fold
this cube, I look at,

00:58:18.650 --> 00:58:22.420
let's say, the opposite
corners of the cube.

00:58:22.420 --> 00:58:24.920
They're pretty far
away on the cube.

00:58:24.920 --> 00:58:26.560
And I know that by
folding I could only

00:58:26.560 --> 00:58:28.400
make distance is smaller.

00:58:28.400 --> 00:58:33.370
So somehow, if I measure the
shortest path on the cube,

00:58:33.370 --> 00:58:36.460
from this point to
this point, it's

00:58:36.460 --> 00:58:40.980
that if you believe-- when
you unfold this thing,

00:58:40.980 --> 00:58:42.720
it should be flat.

00:58:42.720 --> 00:58:45.240
If I unfolds to just
those two squares,

00:58:45.240 --> 00:58:48.686
it's a straight line
between the two.

00:58:48.686 --> 00:58:50.560
And so that goes to the
midpoint of this edge

00:58:50.560 --> 00:58:51.610
and then over there.

00:58:51.610 --> 00:58:53.700
And you measure that length.

00:58:53.700 --> 00:58:54.960
And oh, trigonometry.

00:58:57.510 --> 00:58:59.730
Root five, that's
not what I wanted.

00:59:04.090 --> 00:59:09.460
So we have x here, 2x here.

00:59:09.460 --> 00:59:18.310
So this distance
is-- yeah, I see.

00:59:23.959 --> 00:59:26.125
Why is that different from
what I have written down?

00:59:33.674 --> 00:59:35.590
Because that was not the
diameter of the cube.

00:59:35.590 --> 00:59:37.710
I see.

00:59:37.710 --> 00:59:40.287
AUDIENCE: You want
them equidistant.

00:59:40.287 --> 00:59:40.870
PROFESSOR: No.

00:59:40.870 --> 00:59:44.750
I do want this but,
I think if I go

00:59:44.750 --> 00:59:48.120
from the center of this
square-- this is hard to draw.

00:59:48.120 --> 00:59:54.570
--to the center of the back
square, which is back here,

00:59:54.570 --> 00:59:58.980
that distance is going
to be wrapping around.

00:59:58.980 --> 01:00:02.550
Which is just going
to be like 2x.

01:00:02.550 --> 01:00:04.812
Is that bigger or
smaller than root 5x?

01:00:04.812 --> 01:00:05.770
AUDIENCE: It's smaller.

01:00:05.770 --> 01:00:07.560
PROFESSOR: Smaller.

01:00:07.560 --> 01:00:08.060
Interesting.

01:00:11.676 --> 01:00:16.100
One, two, three, four.

01:00:16.100 --> 01:00:17.317
What did I do wrong?

01:00:21.610 --> 01:00:22.410
Oh, I see.

01:00:22.410 --> 01:00:23.710
OK.

01:00:23.710 --> 01:00:25.600
Here's a fun fact.

01:00:25.600 --> 01:00:29.280
This is actually the
smallest antipodal distance.

01:00:29.280 --> 01:00:30.470
Get this right.

01:00:30.470 --> 01:00:32.530
So if you take some
point on the cube,

01:00:32.530 --> 01:00:34.290
and you look at the
point farthest away

01:00:34.290 --> 01:00:35.873
from it on the other
side of the cube,

01:00:35.873 --> 01:00:38.780
it will always be
at least 2x away.

01:00:38.780 --> 01:00:39.830
So here, it's bigger.

01:00:39.830 --> 01:00:41.450
This is probably the diameter.

01:00:41.450 --> 01:00:44.130
It's bigger than 2x, but it
will always be at least 2x away.

01:00:44.130 --> 01:00:48.380
This is actually the smallest
situation you can get.

01:00:48.380 --> 01:00:50.850
And so I want to think
about the point that

01:00:50.850 --> 01:00:53.260
corresponds to the
center of the square.

01:00:53.260 --> 01:00:53.870
Right?

01:00:53.870 --> 01:00:55.880
Yes.

01:00:55.880 --> 01:00:59.810
Now maybe that maps to
the center like this.

01:00:59.810 --> 01:01:03.390
And the antipodal points is
2x away, or maybe it's bigger.

01:01:03.390 --> 01:01:09.060
But at least I know that this
length is greater than or equal

01:01:09.060 --> 01:01:15.200
to 2x because that's-- the
antipodal point has to be made

01:01:15.200 --> 01:01:16.540
from that.

01:01:16.540 --> 01:01:18.290
I need to think
about all situation

01:01:18.290 --> 01:01:20.873
because I really want to think
about the center of the square.

01:01:20.873 --> 01:01:23.260
Once that is at
least 2x, then I know

01:01:23.260 --> 01:01:29.570
that the side of the square
is at least 2 root 2x.

01:01:29.570 --> 01:01:30.070
Yes.

01:01:35.450 --> 01:01:40.780
And so I know that this is one.

01:01:40.780 --> 01:01:41.880
And you work it out.

01:01:41.880 --> 01:01:43.740
And x is root 2 over 4.

01:01:46.910 --> 01:01:49.370
Or it's at most that.

01:01:49.370 --> 01:01:52.235
And so that gives you some
bound on what it takes.

01:01:52.235 --> 01:01:54.110
So this is actually
really the only technique

01:01:54.110 --> 01:01:57.550
we know to prove lower
bounds on how much-- how big

01:01:57.550 --> 01:01:59.520
a square you need
to make something.

01:01:59.520 --> 01:02:02.540
It's this kind of distance
increasing argument.

01:02:02.540 --> 01:02:05.390
And it turns out you can
actually achieve x equals this.

01:02:05.390 --> 01:02:07.230
So this is what I
call lower bound.

01:02:07.230 --> 01:02:09.440
It says, you can't do
any better than this.

01:02:09.440 --> 01:02:16.310
But there's also a matching
upper bound which achieves this

01:02:16.310 --> 01:02:29.840
and not going to
draw it perfectly.

01:02:40.950 --> 01:02:42.760
So there are the six
sides of the cube.

01:02:42.760 --> 01:02:45.220
You've got one, two,
three, four, five.

01:02:45.220 --> 01:02:47.470
And the sixth one is
split into quarters.

01:02:47.470 --> 01:02:51.390
And you can see, you just
actually fold here, here,

01:02:51.390 --> 01:02:53.880
here, and here to get
rid of that excess.

01:02:53.880 --> 01:02:55.440
And it will come
together as a cube.

01:02:55.440 --> 01:02:57.320
You also fold along
the edges of the cube.

01:02:57.320 --> 01:03:00.180
And it perfectly
achieves this property.

01:03:00.180 --> 01:03:02.870
That from the
center of the paper,

01:03:02.870 --> 01:03:07.400
you have exactly one
this distance 2 root

01:03:07.400 --> 01:03:10.590
2x to the antipodal
point which is

01:03:10.590 --> 01:03:12.630
the center of the opposite face.

01:03:12.630 --> 01:03:13.130
Question?

01:03:13.130 --> 01:03:13.796
AUDIENCE: Sorry.

01:03:13.796 --> 01:03:17.670
Can you explain where the
2x came from [INAUDIBLE]?

01:03:17.670 --> 01:03:20.440
PROFESSOR: I wave my hands.

01:03:20.440 --> 01:03:22.530
So I'm thinking
about an arbitrary

01:03:22.530 --> 01:03:24.410
point on the
surface of the cube.

01:03:24.410 --> 01:03:26.560
Here, it should
be clear it's 2x.

01:03:26.560 --> 01:03:28.350
There's x right here.

01:03:28.350 --> 01:03:30.290
And there's 1/2x here.

01:03:30.290 --> 01:03:32.800
And there's 1/2x on the back.

01:03:32.800 --> 01:03:34.860
And I looked at
another situation

01:03:34.860 --> 01:03:38.335
which is when it was at a
corner that bigger than 2x.

01:03:38.335 --> 01:03:40.210
And I claim if you
interpolate in the middle,

01:03:40.210 --> 01:03:41.668
you'll get something
in the middle,

01:03:41.668 --> 01:03:44.920
in between 2x and root 5x.

01:03:44.920 --> 01:03:46.830
For example, if
take a point here

01:03:46.830 --> 01:03:50.530
that's closer to the
corner, then that

01:03:50.530 --> 01:03:53.300
point-- you should probably
also think about the edge case.

01:03:53.300 --> 01:03:55.780
But you check all of them,
and they're at least 2x.

01:03:55.780 --> 01:03:57.480
That's what I'm claiming.

01:03:57.480 --> 01:03:59.330
So I didn't really
prove that formally.

01:03:59.330 --> 01:04:03.820
But claim is 2x is the smallest
antepodal pair you could get.

01:04:03.820 --> 01:04:05.480
AUDIENCE: What does
antipodal mean?

01:04:05.480 --> 01:04:07.750
PROFESSOR: Antipodal simple
means on the other side.

01:04:07.750 --> 01:04:10.980
The anti pode, the opposite
pole, like from North Pole

01:04:10.980 --> 01:04:11.600
to South Pole.

01:04:11.600 --> 01:04:12.516
AUDIENCE: [INAUDIBLE].

01:04:14.532 --> 01:04:15.990
PROFESSOR: Right
now, we know we're

01:04:15.990 --> 01:04:18.430
taking whatever point is
the center of the square.

01:04:18.430 --> 01:04:20.350
It maps somewhere in the cube.

01:04:20.350 --> 01:04:21.760
I take the antipode from there.

01:04:21.760 --> 01:04:26.540
I know that has to
be at least 2x away.

01:04:26.540 --> 01:04:29.850
And if you look at
the distance map here,

01:04:29.850 --> 01:04:32.480
the farthest away point in
the squared from the center

01:04:32.480 --> 01:04:34.230
is the corner point.

01:04:34.230 --> 01:04:36.760
So I know that that distance
can only get smaller.

01:04:36.760 --> 01:04:38.800
And other distances
only get smaller.

01:04:38.800 --> 01:04:41.610
So if I have to make a
2x distance from there,

01:04:41.610 --> 01:04:43.770
this is my best
chance for doing it.

01:04:43.770 --> 01:04:45.200
And that gives
you a lower bound.

01:04:45.200 --> 01:04:46.533
Doesn't mean it can be achieved.

01:04:46.533 --> 01:04:49.260
But this shows you that
you can achieve it.

01:04:49.260 --> 01:04:53.550
This is a result by Catalano,
Johnson, and Lobe in 2001.

01:04:53.550 --> 01:04:56.341
It's like the only optimality
result we have for folding 3D

01:04:56.341 --> 01:04:56.840
shapes.

01:04:56.840 --> 01:04:58.110
That's why I mention it.

01:04:58.110 --> 01:05:00.379
Tons of fun open
problems like you

01:05:00.379 --> 01:05:01.920
don't want to make
a square-- a cube.

01:05:01.920 --> 01:05:06.190
Maybe you want to
make a triangle.

01:05:06.190 --> 01:05:08.240
If you want to cover a
triangle on both sides,

01:05:08.240 --> 01:05:09.280
that's probably open.

01:05:09.280 --> 01:05:10.946
If you want to make
regular tetrahedron,

01:05:10.946 --> 01:05:12.050
that's probably open.

01:05:12.050 --> 01:05:14.030
Pretty much any problem
you pose here is open.

01:05:14.030 --> 01:05:16.385
It would make fun project.

01:05:16.385 --> 01:05:17.760
You can also think
about, instead

01:05:17.760 --> 01:05:19.176
of starting from
square, you start

01:05:19.176 --> 01:05:22.000
with a rectangle of
some given aspect ratio.

01:05:22.000 --> 01:05:23.696
What's the biggest
cube you can make?

01:05:23.696 --> 01:05:25.320
That's kind of fun
because in the limit

01:05:25.320 --> 01:05:28.800
for a super long rectangle,
you should do strip wrapping.

01:05:28.800 --> 01:05:30.520
For a square, we have
the right answer.

01:05:30.520 --> 01:05:32.760
What's the right
answer in between?

01:05:32.760 --> 01:05:33.260
Who knows.

01:05:37.550 --> 01:05:42.070
The next thing I wanted to
talk about where there's

01:05:42.070 --> 01:05:45.080
been some recent progress
is checkerboard folding.

01:05:53.630 --> 01:05:57.190
In lecture one, I showed
you this model which I never

01:05:57.190 --> 01:05:59.950
go anywhere without,
the four by four

01:05:59.950 --> 01:06:06.460
checkerboard folded from one
square paper, white on one side

01:06:06.460 --> 01:06:08.020
and red on the other.

01:06:08.020 --> 01:06:11.260
And so I think this is
probably the most efficient way

01:06:11.260 --> 01:06:13.310
to fold a four by
four checkerboard.

01:06:13.310 --> 01:06:14.835
You start with a
square of one size,

01:06:14.835 --> 01:06:16.874
and you shrink both
dimensions by two.

01:06:16.874 --> 01:06:18.540
And you get a four
by four checkerboard.

01:06:18.540 --> 01:06:20.081
But we don't know
if this is the best

01:06:20.081 --> 01:06:21.310
way to fold a checkerboard.

01:06:21.310 --> 01:06:22.940
Be nice to know.

01:06:22.940 --> 01:06:28.610
And this has been
studied for a while.

01:06:28.610 --> 01:06:31.110
And this is not
the standard method

01:06:31.110 --> 01:06:32.500
for folding a checkerboard.

01:06:32.500 --> 01:06:34.010
But it's actually
pretty efficient

01:06:34.010 --> 01:06:37.180
which is kind of crazy.

01:06:37.180 --> 01:06:39.000
So you take a
square, white on one

01:06:39.000 --> 01:06:40.620
side and brown on the other.

01:06:40.620 --> 01:06:42.310
You do this accordion pleat.

01:06:42.310 --> 01:06:46.420
You get a bunch of nice color
reversals, bunch of squares.

01:06:46.420 --> 01:06:50.910
And then, you just need to make
a square of squares from that.

01:06:50.910 --> 01:06:53.870
So general problem is, I want
to fold an n by n checkerboard

01:06:53.870 --> 01:06:55.360
from the smallest
possible square.

01:06:55.360 --> 01:06:58.340
How big does it have to
be as a function of n?

01:06:58.340 --> 01:07:01.670
And the standard
approach is-- well,

01:07:01.670 --> 01:07:03.700
this is the first
method that does it

01:07:03.700 --> 01:07:06.590
for all n in a
general simple way.

01:07:06.590 --> 01:07:08.120
But the practical
foldings people

01:07:08.120 --> 01:07:09.955
have designed, like four by four
and there are a bunch of eight

01:07:09.955 --> 01:07:12.850
by eights out there, are little
more efficient than this.

01:07:12.850 --> 01:07:14.410
But they have the
same asymptotics

01:07:14.410 --> 01:07:17.060
which is the perimeter
of the square you start

01:07:17.060 --> 01:07:20.580
with has to be about
twice n squared

01:07:20.580 --> 01:07:22.600
to make an n by n checkerboard.

01:07:22.600 --> 01:07:24.800
And the reason
that is, is if you

01:07:24.800 --> 01:07:27.010
look at the
checkerboard pattern,

01:07:27.010 --> 01:07:29.700
we're trying to get
color reversals along all

01:07:29.700 --> 01:07:35.370
of these lines between the red
and the white, brown and white.

01:07:35.370 --> 01:07:37.120
And the way we're doing
that here is we're

01:07:37.120 --> 01:07:39.020
taking the boundary
of the paper,

01:07:39.020 --> 01:07:42.710
and we're mapping it along
all the color reversals.

01:07:42.710 --> 01:07:45.320
And if you work out how
much color reversal is there

01:07:45.320 --> 01:07:49.200
in an n by n thing, it's
about twice n squared.

01:07:49.200 --> 01:07:52.100
And so either your perimeter
has to be at least that large

01:07:52.100 --> 01:07:54.960
if you're going to cover the
color reversals with perimeter.

01:07:54.960 --> 01:07:58.130
And for a long time, we thought
that was the best we could do

01:07:58.130 --> 01:08:01.090
was to cover color reversals
with a perimeter of paper.

01:08:01.090 --> 01:08:03.620
Of course, know that you
can take a square of paper

01:08:03.620 --> 01:08:05.630
make the perimeter
arbitrarily large.

01:08:05.630 --> 01:08:08.770
So this was never
really a lower bound.

01:08:08.770 --> 01:08:12.890
We never really knew that
you needed 2n squared.

01:08:12.890 --> 01:08:15.440
The four by four
achieves 2n squared.

01:08:15.440 --> 01:08:18.720
We think it's the
best for four by four,

01:08:18.720 --> 01:08:20.939
but we proved last
year-- this is

01:08:20.939 --> 01:08:25.359
with Marty and [INAUDIBLE]
and Robert Lang--

01:08:25.359 --> 01:08:28.735
that you can do better and
get perimeter about n squared.

01:08:28.735 --> 01:08:31.359
Now, there are some lower order
terms there, the order n parts.

01:08:31.359 --> 01:08:33.880
So this is really only
practical for large n.

01:08:33.880 --> 01:08:38.850
I think-- I'll elaborate on
that a little more in a moment.

01:08:38.850 --> 01:08:39.689
But here's the idea.

01:08:39.689 --> 01:08:43.609
Instead of visiting
all the boundaries

01:08:43.609 --> 01:08:45.319
between red and
white squares, I just

01:08:45.319 --> 01:08:47.620
want to visit the
squares themselves.

01:08:47.620 --> 01:08:50.439
So if I could fold
a, in this case

01:08:50.439 --> 01:08:52.830
a rectangle paper
into this shape

01:08:52.830 --> 01:08:55.529
which has slits down
the sides, and it

01:08:55.529 --> 01:08:57.250
has these flaps hanging out.

01:08:57.250 --> 01:08:59.620
Now, you've seen how to make
flaps super efficiently.

01:08:59.620 --> 01:09:01.550
You really don't need
to shrink the paper

01:09:01.550 --> 01:09:04.370
by very much to
make this pattern.

01:09:04.370 --> 01:09:08.779
Then, you take these guys-- and
everything is white side up.

01:09:08.779 --> 01:09:13.090
You take these flaps,
fold them over.

01:09:13.090 --> 01:09:15.189
They become brown.

01:09:15.189 --> 01:09:17.229
And these guys fall over.

01:09:17.229 --> 01:09:18.470
These fall down.

01:09:18.470 --> 01:09:19.289
These guys fall up.

01:09:19.289 --> 01:09:21.330
You can actually make any
two color pixel pattern

01:09:21.330 --> 01:09:22.770
from this idea.

01:09:22.770 --> 01:09:26.710
And it will make white squares
on top of the brown surface

01:09:26.710 --> 01:09:28.420
that you folded.

01:09:28.420 --> 01:09:29.870
So this is the starting point.

01:09:29.870 --> 01:09:31.140
You just fold everything over.

01:09:31.140 --> 01:09:33.350
And you get your checkerboard.

01:09:33.350 --> 01:09:36.760
And now, essentially, you're
visiting each square only once

01:09:36.760 --> 01:09:38.850
instead of the boundary
edge for all the squares.

01:09:38.850 --> 01:09:40.439
And so you end up
using only n squared

01:09:40.439 --> 01:09:41.696
instead of twice n squared.

01:09:41.696 --> 01:09:43.779
And you can do it if you
start from a square also.

01:09:43.779 --> 01:09:47.260
You just need more flaps.

01:09:47.260 --> 01:09:50.920
And there's a bunch of
tabs sticking up here,

01:09:50.920 --> 01:09:52.800
and a bunch of tabs
sticking up there.

01:09:52.800 --> 01:09:54.550
You can fold this again
super efficiently,

01:09:54.550 --> 01:09:57.590
using all these
standard techniques.

01:09:57.590 --> 01:09:59.640
And then, you make a
checkerboard twice as

01:09:59.640 --> 01:10:04.370
efficient for large n as we've
previously thought possible.

01:10:04.370 --> 01:10:07.200
Now, we still don't know
whether this is optimal.

01:10:07.200 --> 01:10:08.330
We think it is.

01:10:08.330 --> 01:10:11.370
But we thought so before also.

01:10:14.340 --> 01:10:16.640
Who knows?

01:10:16.640 --> 01:10:19.410
So big open problem is
[INAUDIBLE] for anything.

01:10:19.410 --> 01:10:25.270
In terms of actual values
of n, for n bigger than 16,

01:10:25.270 --> 01:10:31.120
this method is better than
the standard approach.

01:10:31.120 --> 01:10:36.756
Although if you look just
at seamless-- so seamless,

01:10:36.756 --> 01:10:38.130
I didn't mention,
but we're going

01:10:38.130 --> 01:10:39.820
to talk about it
more in a moment.

01:10:39.820 --> 01:10:41.870
When I make a square
of a checkerboard,

01:10:41.870 --> 01:10:45.160
I'd really like this to
be a single panel of paper

01:10:45.160 --> 01:10:47.200
not divided into little panels.

01:10:47.200 --> 01:10:50.030
And like in this checkerboard,
this white square

01:10:50.030 --> 01:10:51.450
has a bunch of seems on it.

01:10:51.450 --> 01:10:54.080
It's made out of three
smaller triangles.

01:10:54.080 --> 01:10:55.710
And that's not so nice.

01:10:55.710 --> 01:10:57.240
This method is seamless.

01:10:57.240 --> 01:11:00.230
You get whole panels making
each of your squares,

01:11:00.230 --> 01:11:01.930
so it looks a little prettier.

01:11:01.930 --> 01:11:04.450
If you look at the best eight
by eight seamless folding,

01:11:04.450 --> 01:11:07.550
this beats the best seamless
eight by eight folding.

01:11:07.550 --> 01:11:09.700
Although it's rather
difficult to fold.

01:11:09.700 --> 01:11:11.214
Hasn't yet been folded.

01:11:11.214 --> 01:11:12.630
That would be a
good project also.

01:11:16.070 --> 01:11:18.010
Build an actual checkerboard
with this method.

01:11:21.450 --> 01:11:24.040
Questions?

01:11:24.040 --> 01:11:25.810
Now, I want to move
to the general case.

01:11:25.810 --> 01:11:29.100
So I talked a little bit about
checkerboards and about cubes.

01:11:29.100 --> 01:11:31.320
Let's think about
arbitrary polyhedra.

01:11:31.320 --> 01:11:32.660
And this is the Origamizer.

01:11:54.340 --> 01:11:56.880
So Origamizer's
actually two things.

01:11:56.880 --> 01:12:00.460
It's a computer program for
Windows that you can download,

01:12:00.460 --> 01:12:02.880
and it's an algorithm.

01:12:02.880 --> 01:12:04.730
And they're not quite the same.

01:12:04.730 --> 01:12:06.990
So there's original
computer program

01:12:06.990 --> 01:12:09.750
and Tomohiro Tachi wrote
a couple papers about it.

01:12:09.750 --> 01:12:13.020
That program does
not always work.

01:12:13.020 --> 01:12:15.140
Doesn't make every polyhedron.

01:12:15.140 --> 01:12:19.990
It need some finesse to make it
work, but it's super efficient.

01:12:19.990 --> 01:12:20.790
And it's practical.

01:12:20.790 --> 01:12:23.060
He's made lots of models
with it like the bunny

01:12:23.060 --> 01:12:25.450
you've seen on the poster.

01:12:25.450 --> 01:12:27.980
There's the algorithm,
which we developed together.

01:12:27.980 --> 01:12:30.520
And we know it's similar.

01:12:30.520 --> 01:12:32.630
And we know it always works.

01:12:32.630 --> 01:12:35.910
But it's a little
bit less practical.

01:12:35.910 --> 01:12:39.960
So it's-- theory's always
a little behind practice,

01:12:39.960 --> 01:12:40.460
let's say.

01:12:40.460 --> 01:12:42.046
So there's a
practical thing here.

01:12:42.046 --> 01:12:44.170
There's also a theoretically
guaranteed thing here.

01:12:44.170 --> 01:12:46.399
They're not quite the same,
but they're very similar.

01:12:46.399 --> 01:12:47.690
I'm going to tell you a little.

01:12:47.690 --> 01:12:50.640
I'll show you both, basically.

01:12:50.640 --> 01:12:56.160
But the idea is, a
practical algorithm

01:12:56.160 --> 01:12:58.215
to fold any polyhedron.

01:13:11.710 --> 01:13:14.360
And practical here
is a bit vague.

01:13:14.360 --> 01:13:16.920
We don't-- that's not a theorem.

01:13:16.920 --> 01:13:20.791
We don't know how to define
practical in mathematics

01:13:20.791 --> 01:13:21.290
anyway.

01:13:24.550 --> 01:13:27.200
It has some fun features,
though, mathematically.

01:13:27.200 --> 01:13:29.050
One is that it's seamless.

01:13:29.050 --> 01:13:34.076
So for it to be seamless, I
need to assume convex faces.

01:13:36.690 --> 01:13:39.130
So faces are the sides
of the polyhedron.

01:13:39.130 --> 01:13:41.890
So like in a cube,
every face is a square.

01:13:41.890 --> 01:13:43.510
Those are convex.

01:13:43.510 --> 01:13:45.930
And provided all the faces
are convex, if they're not,

01:13:45.930 --> 01:13:48.920
you have to cut them
up into convex pieces.

01:13:48.920 --> 01:13:51.320
My folding will be
seamless in that

01:13:51.320 --> 01:13:53.740
it will be covered by an
entire piece of paper.

01:13:53.740 --> 01:13:56.090
There maybe other things
hidden underneath.

01:13:56.090 --> 01:14:01.300
But there won't be any
visible seems on the top side.

01:14:01.300 --> 01:14:02.290
So that's nice.

01:14:04.870 --> 01:14:07.055
It's also water tight.

01:14:13.290 --> 01:14:15.700
And for this, I have
an illustration.

01:14:15.700 --> 01:14:17.854
This is a feature missed
by the strip method.

01:14:17.854 --> 01:14:19.520
And if you've always
felt like the strip

01:14:19.520 --> 01:14:21.270
method of making
anything is cheating,

01:14:21.270 --> 01:14:25.220
here's a nice formal sense
in which it's cheating.

01:14:25.220 --> 01:14:28.560
We didn't realize it until we
start talking about Origamizer

01:14:28.560 --> 01:14:31.820
which does not have
this cheating sense.

01:14:31.820 --> 01:14:35.140
So here I'm trying to
make a 3D surface, looks

01:14:35.140 --> 01:14:38.590
like a saddle
surface, by a strip.

01:14:38.590 --> 01:14:41.835
If I just visited the guys in
this nice zigzag order, which

01:14:41.835 --> 01:14:46.020
I know is possible, I get all
these slits down the sides.

01:14:46.020 --> 01:14:47.550
This thing would not hold water.

01:14:47.550 --> 01:14:49.008
If you poured water
on it, it would

01:14:49.008 --> 01:14:51.270
fall through all the cracks.

01:14:51.270 --> 01:14:55.110
And if I fold it right,
like in this picture,

01:14:55.110 --> 01:14:56.690
there should be
no seems in here.

01:14:56.690 --> 01:15:00.450
The square, the boundary of the
squares is what's drawn in red.

01:15:00.450 --> 01:15:02.740
So here the boundary
of your piece of paper

01:15:02.740 --> 01:15:04.160
gets mapped all over the place.

01:15:04.160 --> 01:15:05.600
So it's lots of holes.

01:15:05.600 --> 01:15:07.480
Here, I want the
boundary of the paper

01:15:07.480 --> 01:15:11.600
to be the same as the
boundary of the surface.

01:15:11.600 --> 01:15:14.980
So the only place the water
to run off is at the edge.

01:15:14.980 --> 01:15:18.690
I mean, obviously, this
thing is not a closed solid.

01:15:18.690 --> 01:15:20.469
But if you actually
made a cube, you're

01:15:20.469 --> 01:15:22.510
still going to get some
edge because the boundary

01:15:22.510 --> 01:15:24.090
paper has to go somewhere.

01:15:24.090 --> 01:15:26.440
But if you then
sewed up the edge,

01:15:26.440 --> 01:15:30.220
it would totally hold water.

01:15:30.220 --> 01:15:33.390
So that is the informal
version of watertight.

01:15:33.390 --> 01:15:36.470
The formal version
is the boundary

01:15:36.470 --> 01:15:47.890
of the paper maps within
some tiny distance

01:15:47.890 --> 01:15:51.245
epsilon of the boundary
of the surface, boundary

01:15:51.245 --> 01:15:52.000
of the polyhedron.

01:15:58.470 --> 01:16:02.730
And here, when I say
polyhedron, I really

01:16:02.730 --> 01:16:05.875
means something that's
topologically a disk.

01:16:12.770 --> 01:16:15.410
Brief topology.

01:16:15.410 --> 01:16:18.050
This is a disk.

01:16:18.050 --> 01:16:20.730
This is a disk.

01:16:20.730 --> 01:16:23.995
This is not a disk.

01:16:28.520 --> 01:16:30.586
Cube is not a disk.

01:16:30.586 --> 01:16:31.450
It's a sphere.

01:16:34.590 --> 01:16:36.010
This is a disk.

01:16:36.010 --> 01:16:37.140
A piece of paper is a disk.

01:16:37.140 --> 01:16:39.390
So really the only things
you could fold topologically

01:16:39.390 --> 01:16:43.270
in a pure sense in a water
tight sense are disks.

01:16:43.270 --> 01:16:44.900
You can't glue things together.

01:16:44.900 --> 01:16:46.760
That's not in the rules.

01:16:46.760 --> 01:16:49.550
So I can't make--
I could fold this.

01:16:49.550 --> 01:16:51.910
But I'd have to have
an extra seem somewhere

01:16:51.910 --> 01:16:54.730
in order to make this
thing just be a disk.

01:16:54.730 --> 01:16:56.160
I could fold a cube.

01:16:56.160 --> 01:16:58.950
But I have to have
some seem somewhere.

01:16:58.950 --> 01:17:02.840
Here-- the top-- a square
gets cut into four pieces

01:17:02.840 --> 01:17:04.280
in order to make it into a disk.

01:17:04.280 --> 01:17:08.590
Any higher topology can be
cut down and made a disk.

01:17:08.590 --> 01:17:09.770
So this is still universal.

01:17:09.770 --> 01:17:11.270
But in terms of the
water tightness,

01:17:11.270 --> 01:17:14.270
you have to think
about the disk version.

01:17:14.270 --> 01:17:15.035
AUDIENCE: Erik?

01:17:15.035 --> 01:17:15.660
PROFESSOR: Yes.

01:17:15.660 --> 01:17:18.588
AUDIENCE: Even when you go
back and forth with the script

01:17:18.588 --> 01:17:21.887
method, you could argue that
that was topologically a disk.

01:17:21.887 --> 01:17:22.720
PROFESSOR: Oh, yeah.

01:17:22.720 --> 01:17:25.650
Anything, any folding you make
is still topologically a disk.

01:17:25.650 --> 01:17:26.940
This is making a disk.

01:17:26.940 --> 01:17:29.060
But it's doesn't
preserve the boundary.

01:17:29.060 --> 01:17:29.820
AUDIENCE: It what?

01:17:29.820 --> 01:17:30.980
PROFESSOR: It's not
preserving the boundary.

01:17:30.980 --> 01:17:31.480
So yeah.

01:17:31.480 --> 01:17:33.620
Any origami, you're
still disk like,

01:17:33.620 --> 01:17:36.300
and you're watertight
for some disk surface.

01:17:36.300 --> 01:17:40.520
But I want to make this disk
surface with that boundary.

01:17:40.520 --> 01:17:44.310
And watertightness is supposed
to match the given boundary.

01:17:44.310 --> 01:17:46.270
But that boundary
must form a disk.

01:17:46.270 --> 01:17:46.980
That's the point.

01:17:46.980 --> 01:17:48.950
I can't say, oh, there's
no boundary in a cube.

01:17:48.950 --> 01:17:51.490
So you have-- so the boundary
of paper goes nowhere.

01:17:51.490 --> 01:17:53.530
That's not allowed.

01:17:53.530 --> 01:17:57.892
So you get to specify it,
but it has to be a disk.

01:17:57.892 --> 01:17:59.724
I'm going to wave
my hand some more.

01:17:59.724 --> 01:18:02.140
There's another feature which
you can see in this picture.

01:18:02.140 --> 01:18:05.860
This is a schematic of what
Origamizer would produce which

01:18:05.860 --> 01:18:09.510
is that there's some
extra stuff underneath.

01:18:09.510 --> 01:18:13.020
It's slightly lighter because
it's on the bottom side there.

01:18:13.020 --> 01:18:14.850
But you can see
along every edge,

01:18:14.850 --> 01:18:16.770
these are the edges of
the actual polyhedron.

01:18:16.770 --> 01:18:18.650
And then, there's these
extra little tabs,

01:18:18.650 --> 01:18:21.190
extra flaps on the underside.

01:18:21.190 --> 01:18:22.440
This is actually necessary.

01:18:22.440 --> 01:18:24.600
If you want
watertightness, you can't

01:18:24.600 --> 01:18:27.100
fold exactly that polyhedron.

01:18:27.100 --> 01:18:29.720
You fold a slightly
thickened version.

01:18:29.720 --> 01:18:31.980
But you can keep all
those flaps on one side.

01:18:31.980 --> 01:18:34.127
So if you're making
something like a cube,

01:18:34.127 --> 01:18:35.835
you can put all the
garbage on the inside

01:18:35.835 --> 01:18:38.320
where no one can see it.

01:18:38.320 --> 01:18:42.455
So there's another feature
here is we get a little extra.

01:18:48.200 --> 01:18:50.869
And that's necessary if
you want watertightness.

01:18:50.869 --> 01:18:52.410
And it's sort of
the trick that makes

01:18:52.410 --> 01:18:54.640
all of this possible
and efficient and so on.

01:18:57.570 --> 01:19:00.455
So the high level
idea of Origamizer

01:19:00.455 --> 01:19:03.030
is we're going to say,
there's all these faces

01:19:03.030 --> 01:19:05.780
that we need to make.

01:19:05.780 --> 01:19:09.010
So just plop them down on
the piece of paper somewhere.

01:19:09.010 --> 01:19:11.390
And then, fold away the excess.

01:19:11.390 --> 01:19:13.850
Get rid of it by tucking.

01:19:13.850 --> 01:19:15.700
And that excess
paper is going to get

01:19:15.700 --> 01:19:19.480
mapped into these
little chunks here.

01:19:19.480 --> 01:19:21.980
And maybe I'll show you a demo.

01:19:28.110 --> 01:19:31.600
So you takes
something like-- this

01:19:31.600 --> 01:19:34.510
is similar to the
thing I was showing.

01:19:34.510 --> 01:19:36.335
And I forgot a mouse.

01:19:40.610 --> 01:19:42.660
There are all the
faces in the plane.

01:19:42.660 --> 01:19:45.490
And they've conveniently
already been arranged.

01:19:45.490 --> 01:19:48.720
I can't zoom out because
I lack scroll wheel.

01:19:48.720 --> 01:19:55.450
But there's a square
that makes the-- yeah,

01:19:55.450 --> 01:19:57.460
or a multi-touch trackpad.

01:19:57.460 --> 01:19:59.300
Sorry.

01:19:59.300 --> 01:20:00.900
And all the faces
are just there.

01:20:00.900 --> 01:20:02.350
And then there's
this extra stuff.

01:20:02.350 --> 01:20:06.760
And now I say-- I should
probably do this, too.

01:20:06.760 --> 01:20:08.130
Maybe not.

01:20:08.130 --> 01:20:09.520
Well, all right.

01:20:09.520 --> 01:20:15.010
And then I say, crease pattern.

01:20:15.010 --> 01:20:15.510
Boom.

01:20:15.510 --> 01:20:16.810
That folds away the excess.

01:20:16.810 --> 01:20:18.930
And then, just the
white faces, these guys

01:20:18.930 --> 01:20:24.520
which correspond faces
over there, are used.

01:20:24.520 --> 01:20:27.440
And then, you just fold
away the extra junk.

01:20:27.440 --> 01:20:29.940
Easy.

01:20:29.940 --> 01:20:31.170
You want to make a bunny.

01:20:35.280 --> 01:20:36.770
This is actually
an example where

01:20:36.770 --> 01:20:40.985
it will not work by itself.

01:20:40.985 --> 01:20:42.360
Because as I said,
this algorithm

01:20:42.360 --> 01:20:45.550
is not quite guaranteed to work.

01:20:45.550 --> 01:20:49.780
So I'm going to change
the boundary little bit

01:20:49.780 --> 01:20:55.180
by cutting to the ears.

01:20:55.180 --> 01:20:57.360
And so this is still--
it was a disk before.

01:20:57.360 --> 01:21:00.810
It's a disk after because
there's this boundary here.

01:21:00.810 --> 01:21:02.520
But it turns out,
now the algorithm

01:21:02.520 --> 01:21:04.900
will work, assuming
I didn't mess up.

01:21:09.070 --> 01:21:11.760
It's bouncing
around a little bit.

01:21:11.760 --> 01:21:13.480
You can see it's
pretty efficient here.

01:21:13.480 --> 01:21:17.010
There's very tiny gaps
between the triangles.

01:21:17.010 --> 01:21:19.090
There's actually a little
bit a violation here.

01:21:19.090 --> 01:21:23.350
What's happening, which you
can see here, is, on the inside

01:21:23.350 --> 01:21:26.160
are all this extra
structure, these flaps.

01:21:26.160 --> 01:21:28.340
And sometimes they're so
big that they actually

01:21:28.340 --> 01:21:29.780
penetrate the surface.

01:21:29.780 --> 01:21:34.480
But that can be dealt with by
just a little bit of cutting,

01:21:34.480 --> 01:21:36.730
maybe a little more cutting.

01:21:36.730 --> 01:21:38.800
Not cutting in
the literal sense.

01:21:38.800 --> 01:21:40.600
But we just subdivided
these panels

01:21:40.600 --> 01:21:42.260
into lots of smaller panels.

01:21:42.260 --> 01:21:45.450
And now, it is valid.

01:21:45.450 --> 01:21:48.310
This not the design that
you've seen on the poster.

01:21:48.310 --> 01:21:50.390
The design on poster's
little more efficient.

01:21:50.390 --> 01:21:52.020
I'm not so expert.

01:21:52.020 --> 01:21:54.820
I'm not so pro that I can
make exactly that design.

01:21:54.820 --> 01:21:57.020
So it's a little inefficient
on the sides here.

01:21:57.020 --> 01:21:59.840
But you can use this tool
to make super complicated 3D

01:21:59.840 --> 01:22:01.120
models.

01:22:01.120 --> 01:22:06.110
Let me quickly tell you what
goes into the algorithm.

01:22:06.110 --> 01:22:08.560
So the first part
is to figure out

01:22:08.560 --> 01:22:10.820
where all these tucks
are going to go.

01:22:10.820 --> 01:22:13.970
They lie essentially
along angular bisectors

01:22:13.970 --> 01:22:16.410
on one side of every edge.

01:22:16.410 --> 01:22:19.820
But at the vertices, things
are super complicated.

01:22:19.820 --> 01:22:22.880
And in general, if you have a
non-convex surface with tons

01:22:22.880 --> 01:22:25.770
of material coming together,
what I'd like to do

01:22:25.770 --> 01:22:28.570
is add lots of little
flaps on the side.

01:22:28.570 --> 01:22:31.450
So that when I
open it up-- so let

01:22:31.450 --> 01:22:33.700
me draw you a generic picture.

01:22:33.700 --> 01:22:36.350
So we have two faces
coming together.

01:22:36.350 --> 01:22:40.680
What I'd like to do
is add a flap here

01:22:40.680 --> 01:22:43.900
and a corresponding
one just behind it.

01:22:43.900 --> 01:22:45.105
So that's sort of a tab.

01:22:49.110 --> 01:22:52.220
And I can unfold that and
think of some other surface

01:22:52.220 --> 01:22:53.470
that I'm trying to fold.

01:22:53.470 --> 01:22:56.450
So I really wanted just
those two polygons.

01:22:56.450 --> 01:22:59.610
But now, I've made some other
thing which is still a disk.

01:22:59.610 --> 01:23:02.980
You can add those faces in
such a way that you will have,

01:23:02.980 --> 01:23:05.690
at most, 360 degrees
of material everywhere.

01:23:05.690 --> 01:23:07.760
So even though in
the original thing,

01:23:07.760 --> 01:23:10.190
you had maybe tons of material
coming together which you

01:23:10.190 --> 01:23:13.360
cannot make with real paper,
you add in a bunch of tabs along

01:23:13.360 --> 01:23:15.480
the edges and a few
more at the vertices.

01:23:15.480 --> 01:23:18.660
You can fix things so
that the thing is actually

01:23:18.660 --> 01:23:20.940
makeable from one
sheet of paper.

01:23:20.940 --> 01:23:22.852
That's the high level idea.

01:23:22.852 --> 01:23:24.060
Doing that is a bit detailed.

01:23:24.060 --> 01:23:25.351
The paper isn't even published.

01:23:25.351 --> 01:23:26.784
These are some figures from it.

01:23:26.784 --> 01:23:28.200
But this is some--
way this is how

01:23:28.200 --> 01:23:31.050
you resolve a vertex with
some triangulation stuff.

01:23:31.050 --> 01:23:35.180
Each of these corresponds to
a flap in the original thing.

01:23:35.180 --> 01:23:40.216
And then, this is where
we're a little impractical.

01:23:40.216 --> 01:23:42.030
It doesn't quite
match what we do

01:23:42.030 --> 01:23:44.900
in practice in the
computer program.

01:23:44.900 --> 01:23:47.300
But the idea is, you imagine,
you have your faces which

01:23:47.300 --> 01:23:50.430
you want to bring
together somehow.

01:23:50.430 --> 01:23:54.690
They're distributed in the
piece of paper somewhere.

01:23:54.690 --> 01:23:56.810
But you'd really like
to connect them together

01:23:56.810 --> 01:23:58.270
when they have matching edges.

01:23:58.270 --> 01:24:00.570
So this edge might
be glued to some edge

01:24:00.570 --> 01:24:02.700
of some other triangle.

01:24:02.700 --> 01:24:07.775
And I need to just navigate
these little river-like strips

01:24:07.775 --> 01:24:09.150
to visit one edge
from the other.

01:24:09.150 --> 01:24:12.050
And we proved that if these
guys are sufficiently tiny,

01:24:12.050 --> 01:24:13.270
you can always do that.

01:24:13.270 --> 01:24:15.659
And of course, in reality,
you want to arrange things,

01:24:15.659 --> 01:24:17.700
so you can do it efficiently
with little wastage.

01:24:17.700 --> 01:24:19.825
But we proved at least it's
possible with this kind

01:24:19.825 --> 01:24:21.005
of wiggly path stuff.

01:24:24.530 --> 01:24:26.850
So now our picture, the
thing we're trying to make

01:24:26.850 --> 01:24:28.190
looks something like that.

01:24:28.190 --> 01:24:30.400
Where we have-- originally
it was four triangles,

01:24:30.400 --> 01:24:31.480
the gray triangles.

01:24:31.480 --> 01:24:34.350
We added in these extra
flaps so that it's

01:24:34.350 --> 01:24:36.720
nice and well-behaved.

01:24:36.720 --> 01:24:40.780
And each of those flaps we're
covering from both sides.

01:24:40.780 --> 01:24:48.610
And if you think the red
diagram-- I'll get this right.

01:24:48.610 --> 01:24:50.190
The red diagram
corresponds to that.

01:24:50.190 --> 01:24:52.060
It's just been kind of squashed.

01:24:52.060 --> 01:24:53.620
So there are four
triangles, which

01:24:53.620 --> 01:24:55.530
correspond to the
four top flaps.

01:24:55.530 --> 01:25:02.010
And there's this outer chunk
which corresponds to that flap.

01:25:02.010 --> 01:25:05.950
And then, you look at the dual
which is the blue diagram.

01:25:05.950 --> 01:25:07.820
You take that
picture, and that's

01:25:07.820 --> 01:25:11.390
how you set up the crease
pattern essentially.

01:25:11.390 --> 01:25:13.430
So these are the
original four triangles.

01:25:13.430 --> 01:25:13.930
And then.

01:25:13.930 --> 01:25:16.190
There's all this
stuff that represents

01:25:16.190 --> 01:25:19.230
the structure of that
thing that we want to make.

01:25:19.230 --> 01:25:22.220
And then, you just have to fill
in the creases in the middle.

01:25:22.220 --> 01:25:24.900
And you do that just
with something--

01:25:24.900 --> 01:25:26.900
this is how you do it
guaranteed correct.

01:25:26.900 --> 01:25:29.570
And we saw I had to do
lots of subdivision here.

01:25:29.570 --> 01:25:32.030
What I called,
accidentally, cutting.

01:25:32.030 --> 01:25:34.660
But just lots of pleats there.

01:25:34.660 --> 01:25:37.350
Because, essentially,
this is the edge.

01:25:37.350 --> 01:25:40.091
And we want that edge to
lie in a tiny little tab.

01:25:40.091 --> 01:25:41.965
So it's got to go up
and down and up and down

01:25:41.965 --> 01:25:43.970
and up and down,
accordion style.

01:25:43.970 --> 01:25:46.110
And if you do it
right, all those things

01:25:46.110 --> 01:25:49.400
will collapse down to
a little tab attached

01:25:49.400 --> 01:25:51.530
to that edge which is
also attach that edge.

01:25:51.530 --> 01:25:52.771
And they will get joined up.

01:25:52.771 --> 01:25:55.270
Then, you've got to get rid of
all this stuff in the middle.

01:25:55.270 --> 01:25:57.980
And rough idea is,
if you pack it with--

01:25:57.980 --> 01:26:00.230
or I guess you
cover it with disks

01:26:00.230 --> 01:26:02.730
so that everything
is again very tiny.

01:26:02.730 --> 01:26:06.430
And you fold what's called the
[INAUDIBLE] with those points.

01:26:06.430 --> 01:26:09.020
And it works.

01:26:09.020 --> 01:26:11.850
It's a complicated
but very cool.

01:26:11.850 --> 01:26:16.650
And the paper hopefully will
be released later this year

01:26:16.650 --> 01:26:17.560
finally.

01:26:17.560 --> 01:26:19.560
And that's Origamizer.

01:26:19.560 --> 01:26:22.030
And that's efficient
origami design.

