WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.400
[MUSIC PLAYING]

00:00:07.369 --> 00:00:08.910
JONATHAN GERRISH:
My name's Jonathan,

00:00:08.910 --> 00:00:10.980
and I work on the Mobile Ninjas.

00:00:10.980 --> 00:00:13.740
We're a team within Google,
passionate about testing

00:00:13.740 --> 00:00:14.670
and testability.

00:00:17.230 --> 00:00:19.870
If you've ever written test for
Android before, it's likely,

00:00:19.870 --> 00:00:21.700
you've used some
of our products--

00:00:21.700 --> 00:00:25.540
Espresso, Robolectric, or
the Android Testing Support

00:00:25.540 --> 00:00:26.710
Library.

00:00:26.710 --> 00:00:28.330
And together,
these tools combine

00:00:28.330 --> 00:00:30.640
for billions of
test invocations,

00:00:30.640 --> 00:00:32.619
both within and
outside of Google.

00:00:35.750 --> 00:00:37.640
So today, there's
a general consensus

00:00:37.640 --> 00:00:40.340
within the software development
community of the virtues

00:00:40.340 --> 00:00:42.260
of writing tests.

00:00:42.260 --> 00:00:44.480
Sure, there's a cost
for writing tests,

00:00:44.480 --> 00:00:46.280
but it's an accepted
one, and it's

00:00:46.280 --> 00:00:48.920
one that quickly pays dividends
throughout the lifecycle

00:00:48.920 --> 00:00:51.630
of your project.

00:00:51.630 --> 00:00:54.660
Tests provide fast
feedback on failures.

00:00:54.660 --> 00:00:56.610
A bug caught early
on in development

00:00:56.610 --> 00:01:01.110
is far cheaper to fix than after
you deployed your application.

00:01:01.110 --> 00:01:04.530
They give you a safety net for
making changes to your code.

00:01:04.530 --> 00:01:06.210
You're free to
re-factor, clean up,

00:01:06.210 --> 00:01:08.657
and optimize, safe
in the knowledge

00:01:08.657 --> 00:01:10.740
that you're not going to
break any of the existing

00:01:10.740 --> 00:01:12.890
functionality.

00:01:12.890 --> 00:01:15.780
And what's more, a
suite of readable tests

00:01:15.780 --> 00:01:18.644
provides the living,
breathing specification

00:01:18.644 --> 00:01:19.935
of your application's behavior.

00:01:24.342 --> 00:01:25.800
Now, in software
development, there

00:01:25.800 --> 00:01:28.350
exists the concept of
the testing pyramid.

00:01:28.350 --> 00:01:30.300
It's made up of three layers--

00:01:30.300 --> 00:01:33.530
unit, integration,
and end-to-end tests.

00:01:33.530 --> 00:01:36.900
And as you go up the pyramid,
you're gaining fidelity,

00:01:36.900 --> 00:01:40.470
but this comes at the expense
of test execution time.

00:01:40.470 --> 00:01:44.970
It also gets harder to maintain
and debug these kinds of tests.

00:01:44.970 --> 00:01:47.220
But just like a
rock band, where you

00:01:47.220 --> 00:01:48.990
need a perfect
blend of musicians

00:01:48.990 --> 00:01:52.290
to create that great track,
each layer in the pyramid

00:01:52.290 --> 00:01:54.330
is equally important.

00:01:54.330 --> 00:01:57.720
You're leveraging the
advantages of one layer

00:01:57.720 --> 00:02:00.150
to compensate for
trade-offs in others

00:02:00.150 --> 00:02:05.380
to produce a holistic
automated testing environment.

00:02:05.380 --> 00:02:11.870
We recommend a 70/20/10 split
as a general, healthy guideline.

00:02:11.870 --> 00:02:15.754
And now, while the rules of
these pyramids still apply,

00:02:15.754 --> 00:02:17.170
some of the unique
characteristics

00:02:17.170 --> 00:02:19.780
of Android development have
introduced some difficulties

00:02:19.780 --> 00:02:20.410
along the way.

00:02:24.100 --> 00:02:27.250
So unit tests, due to
their need to be fast,

00:02:27.250 --> 00:02:31.900
will run on the
local workstation.

00:02:31.900 --> 00:02:34.130
And integration and
end-to-end tests,

00:02:34.130 --> 00:02:37.180
due to their need to run in a
really faithful environment,

00:02:37.180 --> 00:02:41.460
tend to run on a real
or a virtual device.

00:02:41.460 --> 00:02:43.070
And so, separate
tools have evolved

00:02:43.070 --> 00:02:46.650
at each layer of the pyramid.

00:02:46.650 --> 00:02:49.590
Robolectric, or the
mockable Android framework

00:02:49.590 --> 00:02:53.550
for your off-device unit tests.

00:02:53.550 --> 00:02:56.490
Espresso and the Android
Testing Support Library,

00:02:56.490 --> 00:02:59.120
for those on-device tests.

00:02:59.120 --> 00:03:02.060
Now, Android's got some
really familiar core concepts,

00:03:02.060 --> 00:03:05.450
such as getting a handle to
your application context,

00:03:05.450 --> 00:03:08.600
or maybe driving your
activity lifecycle.

00:03:08.600 --> 00:03:11.620
And each of these tools
has its own distinct APIs

00:03:11.620 --> 00:03:13.910
and ways of doing
things for achieving

00:03:13.910 --> 00:03:15.085
these exact same tasks.

00:03:18.780 --> 00:03:22.830
Now, this has led to something
of a test-writing crisis.

00:03:22.830 --> 00:03:25.380
As a developer, it's
hard, sometimes,

00:03:25.380 --> 00:03:27.840
to know what tools
are available for use

00:03:27.840 --> 00:03:31.870
and which of those
are recommended.

00:03:31.870 --> 00:03:34.150
Having multiple
tools at each level

00:03:34.150 --> 00:03:36.430
has led to an
explosion of styles,

00:03:36.430 --> 00:03:38.530
each with their own
distinct patterns and APIs.

00:03:41.180 --> 00:03:42.770
And this, in turn,
leads to a lack

00:03:42.770 --> 00:03:45.630
of mobility between layers.

00:03:45.630 --> 00:03:48.080
Tests can't easily be
re-factored or reused

00:03:48.080 --> 00:03:50.390
between layers in the pyramid
without being completely

00:03:50.390 --> 00:03:54.010
rewritten for a new tool.

00:03:54.010 --> 00:03:56.650
To discuss this further,
let's orientate ourselves

00:03:56.650 --> 00:03:59.020
with what constitutes
a well-structured test.

00:04:02.860 --> 00:04:05.590
So there's some following
common patterns that

00:04:05.590 --> 00:04:08.380
define a well-structured test.

00:04:08.380 --> 00:04:10.060
And so, we generally
break tests down

00:04:10.060 --> 00:04:12.040
into three clear sections--

00:04:12.040 --> 00:04:14.890
given, when, and then.

00:04:14.890 --> 00:04:16.959
And I like to separate
them with a blank line

00:04:16.959 --> 00:04:20.920
to clearly demarcate them.

00:04:20.920 --> 00:04:26.080
So given some predetermined
state of the system,

00:04:26.080 --> 00:04:30.440
when you execute an action
that you wish to test,

00:04:30.440 --> 00:04:33.200
then verify the new state of
the system or some behavior

00:04:33.200 --> 00:04:35.510
has occurred.

00:04:35.510 --> 00:04:37.970
Be sure to name the test after
both the condition you're

00:04:37.970 --> 00:04:41.846
testing and the
expected outcome.

00:04:41.846 --> 00:04:45.500
Keep the test focused on
very specific behavior.

00:04:45.500 --> 00:04:49.990
And then, test all your
behaviors independently.

00:04:49.990 --> 00:04:52.260
And less is always
more with tests.

00:04:52.260 --> 00:04:54.450
These guidelines will
help you keep each test

00:04:54.450 --> 00:04:57.900
understandable in isolation.

00:04:57.900 --> 00:05:01.480
Use common setup methods,
only for scaffolding.

00:05:01.480 --> 00:05:03.780
This is maybe
creating the object

00:05:03.780 --> 00:05:08.810
that's under test and wiring
up some of its dependences.

00:05:08.810 --> 00:05:11.770
Let's take a look at the problem
of the explosion of styles,

00:05:11.770 --> 00:05:15.840
and we'll highlight this
using a simple test case.

00:05:15.840 --> 00:05:19.610
We'll have a single activity
with one button that

00:05:19.610 --> 00:05:23.770
responds to a click, sending an
intent to the Android system.

00:05:23.770 --> 00:05:26.420
And I'm going to walk you
through this test case,

00:05:26.420 --> 00:05:30.590
comparing the different styles
of Mockito, Robolectric,

00:05:30.590 --> 00:05:31.640
or Espresso.

00:05:35.810 --> 00:05:38.760
So first up, let's
consider Mockito.

00:05:38.760 --> 00:05:41.240
Now mocking is a
really powerful tool,

00:05:41.240 --> 00:05:43.670
but it's one that's often
overused and sometimes,

00:05:43.670 --> 00:05:46.040
used inappropriately.

00:05:46.040 --> 00:05:48.500
Mocking your own
classes is great,

00:05:48.500 --> 00:05:50.240
but while mocking
the Android framework

00:05:50.240 --> 00:05:52.470
may seem like a
great idea at first,

00:05:52.470 --> 00:05:56.820
it can soon lead down a
path of difficult problems.

00:05:56.820 --> 00:05:58.710
Many Android classes
are stateful,

00:05:58.710 --> 00:06:00.812
or they have complex
contracts, and these

00:06:00.812 --> 00:06:02.520
are really difficult,
or even impossible,

00:06:02.520 --> 00:06:04.920
to satisfy with mocks.

00:06:04.920 --> 00:06:07.380
So even though we
don't recommend it,

00:06:07.380 --> 00:06:09.810
let's just start by taking
a look at one of these tests

00:06:09.810 --> 00:06:13.860
and walk through it using
the Mockito framework to mock

00:06:13.860 --> 00:06:15.327
the Android framework.

00:06:18.250 --> 00:06:22.420
So in the Given section, we
can [? new up ?] our activity

00:06:22.420 --> 00:06:24.610
under test, but look.

00:06:24.610 --> 00:06:26.230
We first of all,
have to step out

00:06:26.230 --> 00:06:28.750
some of the Android
framework behavior

00:06:28.750 --> 00:06:33.010
in the superclass activity
so that it responds

00:06:33.010 --> 00:06:36.070
as we expect in our tests.

00:06:36.070 --> 00:06:38.770
Now, this introduces
some problems.

00:06:38.770 --> 00:06:42.450
First of all, we're partially
stubbing the class under test.

00:06:42.450 --> 00:06:45.090
And this means we're not
testing the true behavior

00:06:45.090 --> 00:06:48.050
of that object under test.

00:06:48.050 --> 00:06:51.530
And furthermore, it brings
with it excessive stubbing,

00:06:51.530 --> 00:06:54.440
which introduces all this
undesirable boilerplate.

00:06:54.440 --> 00:06:56.300
And that quickly
becomes distracting

00:06:56.300 --> 00:06:58.040
from the true
intention of your test.

00:07:01.780 --> 00:07:03.710
For the When
section of the test,

00:07:03.710 --> 00:07:05.690
to execute your code
under test, you'd

00:07:05.690 --> 00:07:08.990
have first needed to register
an ArgumentCaptor earlier

00:07:08.990 --> 00:07:11.660
to get a handle on that click
listener, which you would then

00:07:11.660 --> 00:07:17.120
vote manually to call the code
that you're wishing to test.

00:07:17.120 --> 00:07:18.710
Now, with this
approach, you can soon

00:07:18.710 --> 00:07:22.550
descend into an undesirable
mess of ArgumentCaptors,

00:07:22.550 --> 00:07:25.280
stubbing calls, and
answer invocations.

00:07:28.560 --> 00:07:32.330
Finally, in the Then
section, to obtain intent

00:07:32.330 --> 00:07:34.140
sent to the Android
system, you're

00:07:34.140 --> 00:07:36.950
going to have to use
another ArgumentCaptor.

00:07:36.950 --> 00:07:39.330
And mocking the Android
frameworks in this way

00:07:39.330 --> 00:07:43.680
tends to force you into testing
implementation details, when

00:07:43.680 --> 00:07:47.490
you want to be testing
behavior instead.

00:07:47.490 --> 00:07:49.330
And furthermore,
these drawbacks have

00:07:49.330 --> 00:07:52.330
tended to lead developers to
build their own abstractions

00:07:52.330 --> 00:07:54.640
to isolate Android.

00:07:54.640 --> 00:07:58.160
This, in turn, leads to
its own set of problems.

00:07:58.160 --> 00:08:00.850
Firstly, you're introducing
another layer of cruft

00:08:00.850 --> 00:08:02.800
into your application.

00:08:02.800 --> 00:08:05.270
And secondly, you're
introducing texting

00:08:05.270 --> 00:08:06.950
gaps, where bugs can hide.

00:08:09.684 --> 00:08:11.600
And we believe that while
you should architect

00:08:11.600 --> 00:08:14.270
your application
very thoughtfully,

00:08:14.270 --> 00:08:16.180
the limitations of
the tools shouldn't

00:08:16.180 --> 00:08:18.490
dictate your application
architecture either.

00:08:23.110 --> 00:08:26.290
So let's see how this looks
like with Robolectric.

00:08:26.290 --> 00:08:29.920
Robolectric is the popular
open source testing framework.

00:08:29.920 --> 00:08:33.120
It allows you to follow the best
practices surrounding mocks,

00:08:33.120 --> 00:08:35.919
as you're able to use real
Android objects in your tests,

00:08:35.919 --> 00:08:38.610
rather than having to
program your own stubbing

00:08:38.610 --> 00:08:41.250
behavior in each test.

00:08:41.250 --> 00:08:44.340
It runs on your local host,
which means it's very fast,

00:08:44.340 --> 00:08:47.340
making it ideal for unit tests.

00:08:47.340 --> 00:08:50.739
Robolectric tends to create
tests that read a lot cleaner.

00:08:50.739 --> 00:08:52.530
So let's walk through
each section in turn.

00:08:56.060 --> 00:08:58.970
In the Given section, we
can simply bring an activity

00:08:58.970 --> 00:09:01.040
into the resume
state for our test

00:09:01.040 --> 00:09:03.740
just by calling Robolectric's
setup activity API.

00:09:08.520 --> 00:09:11.680
In the When section, we're
able to use real Android SDK

00:09:11.680 --> 00:09:15.850
APIs, such as Find View by
ID, to get a hold of the view.

00:09:15.850 --> 00:09:19.360
And then, Robolectric's click-on
API, safely click on that view

00:09:19.360 --> 00:09:21.080
and invoke the code
that we wish to test.

00:09:24.280 --> 00:09:26.740
And finally, in
the Then section,

00:09:26.740 --> 00:09:29.550
we again use Robolectric's
own testing APIs

00:09:29.550 --> 00:09:32.850
to check that the intent
was sent to the system.

00:09:32.850 --> 00:09:34.890
See how much cleaner
this version is?

00:09:34.890 --> 00:09:37.860
We're focusing on the items
that really matter in the test,

00:09:37.860 --> 00:09:40.964
and we're free of all those
extra pieces of distraction.

00:09:44.920 --> 00:09:47.440
Now, Espresso is an
UI testing framework,

00:09:47.440 --> 00:09:50.410
and it runs on a real
or a virtual device.

00:09:50.410 --> 00:09:53.380
It provides you with a
really realistic environment.

00:09:53.380 --> 00:09:57.400
The trade-off here is a
much slower execution speed.

00:09:57.400 --> 00:09:59.560
You're building up
your entire APK,

00:09:59.560 --> 00:10:03.190
deploying it to the device,
and instantiating the test run.

00:10:03.190 --> 00:10:05.500
Waiting for the results and
then collecting those back

00:10:05.500 --> 00:10:07.330
on your local workstation.

00:10:07.330 --> 00:10:11.780
All of this is adding
valuable development cycles.

00:10:11.780 --> 00:10:13.990
Now, the exact same
Android concepts

00:10:13.990 --> 00:10:17.320
exist here, we're just
getting hold of an activity,

00:10:17.320 --> 00:10:19.810
clicking a button, and
then, verifying an intent

00:10:19.810 --> 00:10:22.370
was sent to the Android system.

00:10:22.370 --> 00:10:26.409
Here, though, as you'll see,
the APIs are very different.

00:10:26.409 --> 00:10:27.950
Let's step through
this one together.

00:10:31.120 --> 00:10:33.620
So in the Given section,
we'll use the activity test

00:10:33.620 --> 00:10:36.420
rule, which comes from the
Android Testing Support

00:10:36.420 --> 00:10:37.950
Library.

00:10:37.950 --> 00:10:39.960
This can be used to
start an activity,

00:10:39.960 --> 00:10:41.860
bring it to the resume
state, and provide us

00:10:41.860 --> 00:10:43.310
with a handle to
it in our tests.

00:10:48.240 --> 00:10:52.230
For the When section, we can use
the Espresso view matcher APIs.

00:10:52.230 --> 00:10:54.130
We'll find the view
in question, and then

00:10:54.130 --> 00:10:56.840
safely click on it to invoke
the code that we wish to test.

00:11:00.720 --> 00:11:03.340
And finally, in
the Then section,

00:11:03.340 --> 00:11:06.387
we use Espresso Intents
Library to capture that intent,

00:11:06.387 --> 00:11:07.970
and verify that it
was the one that we

00:11:07.970 --> 00:11:11.460
wanted sent to the system.

00:11:11.460 --> 00:11:14.660
Notice here that, while a test
has many similar structures

00:11:14.660 --> 00:11:18.150
to Robolectric tests-- the
example that we saw earlier--

00:11:18.150 --> 00:11:20.534
the syntax is very,
very different.

00:11:23.320 --> 00:11:26.340
So while each of these
testing frameworks

00:11:26.340 --> 00:11:29.640
have contrasting
strengths and weaknesses,

00:11:29.640 --> 00:11:31.140
it's this explosion
of styles that's

00:11:31.140 --> 00:11:35.090
really become the big
problem for writing tests.

00:11:35.090 --> 00:11:36.590
Who, in the audience,
has been using

00:11:36.590 --> 00:11:37.727
Robolectric to write tests?

00:11:37.727 --> 00:11:38.435
Raise your hands.

00:11:40.761 --> 00:11:41.760
And what about Espresso?

00:11:44.530 --> 00:11:45.850
And who's using both?

00:11:49.130 --> 00:11:51.350
We often hear developers
talking about,

00:11:51.350 --> 00:11:53.360
I need to write a
Robolectric test,

00:11:53.360 --> 00:11:55.790
or I need an Espresso test.

00:11:55.790 --> 00:11:57.980
But we'd much rather you
be thinking about writing

00:11:57.980 --> 00:12:01.210
an Android test instead.

00:12:01.210 --> 00:12:03.650
We feel, as a developer, that
no matter what kind of test

00:12:03.650 --> 00:12:05.210
you're writing,
you shouldn't first

00:12:05.210 --> 00:12:08.240
have to think about environments
and tools and libraries

00:12:08.240 --> 00:12:09.975
that you'll need.

00:12:09.975 --> 00:12:11.600
We believe you
shouldn't have to suffer

00:12:11.600 --> 00:12:15.210
the mental load of having to
learn multiple sets of APIs

00:12:15.210 --> 00:12:17.210
for doing exactly
the same thing.

00:12:21.845 --> 00:12:23.710
And of course, you
should have the freedom

00:12:23.710 --> 00:12:26.230
to re-factor and
reuse your code,

00:12:26.230 --> 00:12:30.060
no matter where you
choose to run it.

00:12:30.060 --> 00:12:32.790
So what if there was
only one set of APIs

00:12:32.790 --> 00:12:35.150
that you needed to learn?

00:12:35.150 --> 00:12:37.650
And now, imagine also,
being free to focus

00:12:37.650 --> 00:12:40.980
on writing your test, rather
than considering those tools

00:12:40.980 --> 00:12:42.992
and libraries and environments.

00:12:47.330 --> 00:12:50.210
Well, to make this a
reality, today, we're

00:12:50.210 --> 00:12:53.030
launching Android Test.

00:12:53.030 --> 00:12:55.310
It's part of Jetpack.

00:12:55.310 --> 00:12:58.290
With Jetpack, testing is
now a first-class citizen

00:12:58.290 --> 00:13:00.720
of the Android toolchain.

00:13:00.720 --> 00:13:02.940
We're unifying the
development experience

00:13:02.940 --> 00:13:06.190
around a canonical, high
quality set of APIs,

00:13:06.190 --> 00:13:08.790
that will reduce the
boilerplate and eliminate

00:13:08.790 --> 00:13:11.790
the number of tools
that you need to learn.

00:13:11.790 --> 00:13:14.580
Naturally, Kotlin and
support is included,

00:13:14.580 --> 00:13:17.730
allowing you to write
beautifully concise tests.

00:13:17.730 --> 00:13:20.604
And, of course, all of
this will be open sourced.

00:13:20.604 --> 00:13:22.645
We love contributions from
our community members.

00:13:26.590 --> 00:13:28.900
We're going to satisfy
developers' needs in each

00:13:28.900 --> 00:13:30.910
of the four key
sections of the test--

00:13:30.910 --> 00:13:36.550
remember, Scaffolding,
Given, When, and Then.

00:13:36.550 --> 00:13:40.470
Scaffolding encompasses the
configuration and control APIs.

00:13:40.470 --> 00:13:42.700
Think getting a hold of
that application context.

00:13:45.550 --> 00:13:47.990
For your test scaffolding,
Android JUnit 4 Runner

00:13:47.990 --> 00:13:50.364
is used to execute your tests.

00:13:50.364 --> 00:13:52.030
You can use the
instrumentation registry

00:13:52.030 --> 00:13:55.300
to get a handle to that
application context.

00:13:55.300 --> 00:13:57.330
Well, today, we're
excited to announce,

00:13:57.330 --> 00:13:59.260
for the very first
time, you can now

00:13:59.260 --> 00:14:02.740
use these APIs for both your
on and off-device tests.

00:14:07.590 --> 00:14:10.530
The next section of a
test is the Given section,

00:14:10.530 --> 00:14:13.980
and here, we're going to provide
two key categories of APIs

00:14:13.980 --> 00:14:15.240
for you.

00:14:15.240 --> 00:14:18.450
Firstly, the Android JUnit
rules from the Android Testing

00:14:18.450 --> 00:14:21.250
Support Library will
become part of Jetpack.

00:14:21.250 --> 00:14:24.150
And we're soon adding more APIs
to help drive the component

00:14:24.150 --> 00:14:25.785
lifecycle for you in tests.

00:14:28.380 --> 00:14:31.230
As you've seen previously,
the activity test rule

00:14:31.230 --> 00:14:32.670
is used to start
up your activity

00:14:32.670 --> 00:14:35.670
and make it available to
test in the resume state.

00:14:35.670 --> 00:14:39.030
You probably used this API
running on a device many times

00:14:39.030 --> 00:14:40.050
before.

00:14:40.050 --> 00:14:43.350
Well, today, this API, too,
will be available for tests

00:14:43.350 --> 00:14:44.870
that run off-device, as well.

00:14:48.770 --> 00:14:52.700
Secondly, we'll be providing you
with a set of Android test data

00:14:52.700 --> 00:14:54.010
builders.

00:14:54.010 --> 00:14:56.080
These will help you
construct Android objects

00:14:56.080 --> 00:14:58.120
that your code and the
test will interact with.

00:15:00.980 --> 00:15:02.570
Many of the Android
framework classes

00:15:02.570 --> 00:15:05.510
that you need for setting
up your test state

00:15:05.510 --> 00:15:07.550
are difficult to create.

00:15:07.550 --> 00:15:09.350
Often, there's no
public constructor,

00:15:09.350 --> 00:15:11.685
so they can't be
instantiated for test.

00:15:11.685 --> 00:15:14.060
Perhaps they're final, so
mocking is out of the question,

00:15:14.060 --> 00:15:14.696
either.

00:15:14.696 --> 00:15:16.070
And sometimes,
they're just plain

00:15:16.070 --> 00:15:20.150
clumsy to instantiate with
any degree of brevity at all.

00:15:20.150 --> 00:15:23.470
So we're including Android
test builders within Jetpack

00:15:23.470 --> 00:15:27.260
to give you a concise way to
set up your test environment.

00:15:27.260 --> 00:15:29.760
They produce readable
code, that fluent way

00:15:29.760 --> 00:15:33.230
to create the Android components
that you need to interact with.

00:15:33.230 --> 00:15:35.240
And of course, they're portable.

00:15:35.240 --> 00:15:37.820
Android test data builders
work for both your on

00:15:37.820 --> 00:15:39.440
and off-device use cases.

00:15:43.330 --> 00:15:45.370
The third section of
a well-structured test

00:15:45.370 --> 00:15:49.240
is the When section,
exercising the code under test.

00:15:49.240 --> 00:15:50.800
Usually, this is
just simply a case

00:15:50.800 --> 00:15:53.180
of calling your
own code directly,

00:15:53.180 --> 00:15:54.850
but when you're
writing an UI test,

00:15:54.850 --> 00:16:00.580
it's likely that you'd reach for
the Espresso View Matcher APIs.

00:16:00.580 --> 00:16:03.610
Today, we're happy to announce
that Espresso, too, is

00:16:03.610 --> 00:16:05.790
joining Android Test Jetpack.

00:16:08.780 --> 00:16:12.140
Espresso View APIs are fluent,
and they read beautifully.

00:16:12.140 --> 00:16:15.140
You've used them for your
on-device tests for a while

00:16:15.140 --> 00:16:18.710
now, and today, we're
providing preliminary support

00:16:18.710 --> 00:16:21.270
for these tests in the
off-device use case also.

00:16:24.890 --> 00:16:27.020
The final part of a
well-structured test

00:16:27.020 --> 00:16:28.825
is the Then section.

00:16:28.825 --> 00:16:30.200
This is where you
make assertions

00:16:30.200 --> 00:16:34.340
on the state of the system
in response to an action.

00:16:34.340 --> 00:16:36.500
So firstly,
Espresso-Intents, too,

00:16:36.500 --> 00:16:40.575
is going to be joining Jetpack
as Android Test Intents.

00:16:43.880 --> 00:16:46.550
Those intents APIs that you've
been using for your own device

00:16:46.550 --> 00:16:48.530
testing, great news.

00:16:48.530 --> 00:16:51.640
Today, they, too, will run
in your off-device tests.

00:16:55.320 --> 00:16:58.940
And finally, we're also
releasing an assertions library

00:16:58.940 --> 00:17:00.845
to help reduce the
boilerplate in your tests.

00:17:03.890 --> 00:17:05.690
Using traditional
JUnit assertions

00:17:05.690 --> 00:17:08.660
can lead to tests that are
not immediately readable.

00:17:08.660 --> 00:17:10.700
See here, how easy it
is to get the actual

00:17:10.700 --> 00:17:14.060
and the expected
arguments mixed up?

00:17:14.060 --> 00:17:16.339
And Android uses a lot
of integer constants

00:17:16.339 --> 00:17:19.220
for efficiency,
but this makes it

00:17:19.220 --> 00:17:24.050
difficult to comprehend the
error messages in tests.

00:17:24.050 --> 00:17:26.720
At Google, we love to use Truth.

00:17:26.720 --> 00:17:31.880
It's our own open source, fluent
testing assertions library.

00:17:31.880 --> 00:17:33.470
Using a fluent
assertions library

00:17:33.470 --> 00:17:36.590
is a great step to producing
more readable code.

00:17:36.590 --> 00:17:39.020
And writing the tests
become much more easy, too,

00:17:39.020 --> 00:17:42.170
because you can lean on the
built-in support of your IDEs

00:17:42.170 --> 00:17:45.660
auto completion feature.

00:17:45.660 --> 00:17:49.400
So to help you write concise
tests against Android code,

00:17:49.400 --> 00:17:51.330
we'll be releasing a
set of truth extensions

00:17:51.330 --> 00:17:54.090
for Android, which
reduces the boilerplate,

00:17:54.090 --> 00:17:57.060
reads beautifully, and gives
immediately meaningful error

00:17:57.060 --> 00:17:58.930
messages.

00:17:58.930 --> 00:18:01.150
Of course, these
assertions will work

00:18:01.150 --> 00:18:04.915
across all environments, both
the on and off-device tests.

00:18:09.410 --> 00:18:13.910
So with Jetpack Android Test,
we'll be bringing you the tools

00:18:13.910 --> 00:18:16.010
that you need so that
you can concentrate

00:18:16.010 --> 00:18:19.550
on writing beautifully
concise, easy-to-read tests,

00:18:19.550 --> 00:18:22.280
without first, worrying
about libraries or tools

00:18:22.280 --> 00:18:24.110
or environments.

00:18:24.110 --> 00:18:28.010
A single set of canonical
APIs for common tasks

00:18:28.010 --> 00:18:29.930
that will reduce the
boilerplate, leaving

00:18:29.930 --> 00:18:32.200
your test clear and readable.

00:18:32.200 --> 00:18:34.340
And that are
environmentally agnostic,

00:18:34.340 --> 00:18:36.770
allowing you to run the
tests either on-device,

00:18:36.770 --> 00:18:41.470
on your local workstation, or
perhaps, in a Cloud Test Lab.

00:18:41.470 --> 00:18:45.470
And now that I've shown you how
to use this unified set of APIs

00:18:45.470 --> 00:18:47.390
that decouple the act
of actually writing

00:18:47.390 --> 00:18:49.550
a test from where
it's going to run,

00:18:49.550 --> 00:18:51.170
I'll hand you over
to my colleague,

00:18:51.170 --> 00:18:53.420
Stefan, who's going
to show you how

00:18:53.420 --> 00:18:56.900
you can run these tests in
the new simplified world.

00:18:56.900 --> 00:18:57.810
Stefan.

00:18:57.810 --> 00:19:00.260
[APPLAUSE]

00:19:08.100 --> 00:19:10.370
STEFAN RAMSAUER:
Thank you, Jonathan.

00:19:10.370 --> 00:19:12.980
Welcome, everyone.

00:19:12.980 --> 00:19:16.220
10 years Android, quite amazing.

00:19:16.220 --> 00:19:20.150
I also want to say a big welcome
to everybody who is joining us

00:19:20.150 --> 00:19:22.390
at the Livestream today.

00:19:22.390 --> 00:19:26.880
At Google, we
believe that testing

00:19:26.880 --> 00:19:31.770
should be a fundamental part of
your app development strategy.

00:19:31.770 --> 00:19:35.300
Let's bring back the pyramid.

00:19:35.300 --> 00:19:38.270
As we can see, our
friend with the Jetpack

00:19:38.270 --> 00:19:41.270
has solved the API dilemma.

00:19:41.270 --> 00:19:45.610
Now that we got one
API to rule them all,

00:19:45.610 --> 00:19:49.550
it's really easy to start
writing tests for Android.

00:19:49.550 --> 00:19:52.240
No more excuses.

00:19:52.240 --> 00:19:56.310
We can start with a simple
test for our business logic,

00:19:56.310 --> 00:19:58.530
usually, a unit test.

00:19:58.530 --> 00:20:02.040
And over time, we can
add more and more tests.

00:20:02.040 --> 00:20:06.460
Once we start implementing
the UI for our application,

00:20:06.460 --> 00:20:10.420
it might be worth adding
an integration test.

00:20:10.420 --> 00:20:14.020
This just became a
fluent experience,

00:20:14.020 --> 00:20:19.060
since both layers
support the same APIs.

00:20:19.060 --> 00:20:21.010
No more context switching.

00:20:21.010 --> 00:20:23.450
Great.

00:20:23.450 --> 00:20:26.900
But that's not the only
use case where the new API

00:20:26.900 --> 00:20:28.710
becomes really handy.

00:20:28.710 --> 00:20:31.980
Let's imagine we have
an integration test that

00:20:31.980 --> 00:20:36.090
got too large and complicated.

00:20:36.090 --> 00:20:39.110
I have seen many of those tests.

00:20:39.110 --> 00:20:42.940
It's just too convenient to
test business logic and UI

00:20:42.940 --> 00:20:46.730
flow in one single test.

00:20:46.730 --> 00:20:50.240
At Google, we don't
like those tests.

00:20:50.240 --> 00:20:55.750
They are hard to read, and
they tend to become flaky.

00:20:55.750 --> 00:21:00.980
Small, well-focused
tests are much better.

00:21:00.980 --> 00:21:05.770
So let's re-factor this
large, complicated test.

00:21:05.770 --> 00:21:11.630
Re-factoring a large test
can be a very painful task.

00:21:11.630 --> 00:21:14.284
Who in the audience has
experienced this recently?

00:21:14.284 --> 00:21:14.950
Raise your hand.

00:21:17.720 --> 00:21:19.370
Here's some good news for you.

00:21:19.370 --> 00:21:23.860
If the original test was
written with the new API,

00:21:23.860 --> 00:21:27.220
this task becomes much simpler.

00:21:27.220 --> 00:21:30.430
We still have to test
our UI, and we'll

00:21:30.430 --> 00:21:34.720
keep this part in
the integration test.

00:21:34.720 --> 00:21:37.630
This layer provides
high fidelity,

00:21:37.630 --> 00:21:41.336
and we don't want to lose
that for our UI test.

00:21:41.336 --> 00:21:44.980
The rest, mainly business
logic, can directly

00:21:44.980 --> 00:21:47.440
go into the unit test layer.

00:21:47.440 --> 00:21:52.180
Here, we gain speed
since we can run

00:21:52.180 --> 00:21:55.780
off-device on a local
[? travel ?] VM.

00:21:55.780 --> 00:21:58.900
So let's verify the
re-factoring together.

00:21:58.900 --> 00:22:02.155
We still have high
fidelity for the UI test.

00:22:02.155 --> 00:22:04.470
That's good.

00:22:04.470 --> 00:22:05.610
We gain speed.

00:22:05.610 --> 00:22:07.740
Even better.

00:22:07.740 --> 00:22:12.180
And the tests are
decoupled and less complex.

00:22:12.180 --> 00:22:13.280
Nice job.

00:22:13.280 --> 00:22:15.330
Your coworkers will thank you.

00:22:15.330 --> 00:22:17.430
So let's run those tests.

00:22:17.430 --> 00:22:19.350
But wait.

00:22:19.350 --> 00:22:23.250
We still have to choose
a runtime environment.

00:22:23.250 --> 00:22:27.720
It's not always trivial
to pick the right one.

00:22:27.720 --> 00:22:31.620
We also have to work in
multiple source sets.

00:22:31.620 --> 00:22:36.300
The combination of runtime
environments plus source sets

00:22:36.300 --> 00:22:39.740
will lead to an explosion
of test configurations.

00:22:39.740 --> 00:22:44.000
Just imagine how hard
it will get to choose

00:22:44.000 --> 00:22:46.640
the right configuration.

00:22:46.640 --> 00:22:50.420
Should I run on a
device or off a device?

00:22:50.420 --> 00:22:52.700
And don't we need to
run the entire test

00:22:52.700 --> 00:22:55.610
suite on our continuous
integration server

00:22:55.610 --> 00:22:58.150
before we submit?

00:22:58.150 --> 00:23:01.490
And you all know the
feeling, after we kicked off

00:23:01.490 --> 00:23:05.450
the test run, waiting
eagerly for the results.

00:23:08.050 --> 00:23:09.060
Oh, no.

00:23:09.060 --> 00:23:10.200
Hold the Submit.

00:23:10.200 --> 00:23:12.240
One of the tests is flaky.

00:23:12.240 --> 00:23:17.140
I'm pretty sure many of you
have been in this situation.

00:23:17.140 --> 00:23:21.040
Flakiness is one of
the biggest pain points

00:23:21.040 --> 00:23:24.010
for developer productivity.

00:23:24.010 --> 00:23:29.320
So what if there
was a better way

00:23:29.320 --> 00:23:34.090
to set up your test
harness, execute

00:23:34.090 --> 00:23:37.510
your tests in a
reliable environment,

00:23:37.510 --> 00:23:39.420
with unified test results?

00:23:42.710 --> 00:23:46.810
Today, we are proud to
announce Project Nitrogen,

00:23:46.810 --> 00:23:51.580
the new single entry point
for all Android tests.

00:23:51.580 --> 00:23:53.965
Nitrogen is fuel
for your jetpacks.

00:24:00.240 --> 00:24:04.050
With our expertise of
running billions of tests

00:24:04.050 --> 00:24:08.850
a year, we had to build the
fastest and most reliable

00:24:08.850 --> 00:24:10.980
test executor.

00:24:10.980 --> 00:24:15.300
Nitrogen covers the entire
testing lifecycle, from setup

00:24:15.300 --> 00:24:18.720
to test execution and reporting.

00:24:18.720 --> 00:24:22.320
Nitrogen provides deterministic
behavior across different

00:24:22.320 --> 00:24:25.210
build systems.

00:24:25.210 --> 00:24:29.410
It will be fully integrated
in Android Studio.

00:24:29.410 --> 00:24:31.840
At Google, we
already use Nitrogen

00:24:31.840 --> 00:24:39.100
to test our own apps, such as
Gmail, Google Maps, Photos,

00:24:39.100 --> 00:24:42.580
YouTube, and many more.

00:24:42.580 --> 00:24:46.060
Nitrogen is highly extensible.

00:24:46.060 --> 00:24:48.820
It provides APIs
for test authors

00:24:48.820 --> 00:24:53.380
to customize the test
invocation at any point.

00:24:56.480 --> 00:25:00.760
Nitrogen will be fully open
sourced later this year,

00:25:00.760 --> 00:25:05.670
but let me give you an
overview, starting with setup.

00:25:05.670 --> 00:25:09.500
Nitrogen connects your test
to any execution environment--

00:25:09.500 --> 00:25:14.260
on-device, off-device,
or in the Cloud.

00:25:14.260 --> 00:25:17.560
It installs required
test artifacts.

00:25:17.560 --> 00:25:21.480
And if necessary, it can run
custom fixture scripts for you.

00:25:24.180 --> 00:25:25.920
Let me show you how this works.

00:25:25.920 --> 00:25:31.210
First, Nitrogen finds
and provisions a device.

00:25:31.210 --> 00:25:34.000
This can either be a simulated
device, a virtual device,

00:25:34.000 --> 00:25:35.660
or a real device.

00:25:35.660 --> 00:25:38.140
Once the device
is ready, Nitrogen

00:25:38.140 --> 00:25:43.550
installs the application,
under test, and the test.

00:25:43.550 --> 00:25:46.050
Nitrogen then,
stages any test data

00:25:46.050 --> 00:25:49.307
dependencies and sets
device properties.

00:25:52.050 --> 00:25:54.720
If additional
setup is necessary,

00:25:54.720 --> 00:25:57.520
it can all be done here.

00:25:57.520 --> 00:25:59.440
Let me give you examples.

00:25:59.440 --> 00:26:02.770
Setting up a network tunnel,
starting a hermetic server,

00:26:02.770 --> 00:26:07.380
gaining/granting
permissions, and much more.

00:26:07.380 --> 00:26:10.020
And finally, it
prepares the device

00:26:10.020 --> 00:26:12.330
for the next step,
test execution.

00:26:15.270 --> 00:26:19.880
There are many ways how we
can run an Android test.

00:26:19.880 --> 00:26:23.240
It's a little bit like
running in the real world.

00:26:23.240 --> 00:26:27.730
Here, we have sprints,
mid-distance, and long distance

00:26:27.730 --> 00:26:29.070
runs.

00:26:29.070 --> 00:26:31.230
We also have different
environments--

00:26:31.230 --> 00:26:36.750
track running, road running,
cross-country running,

00:26:36.750 --> 00:26:39.150
and mountain running.

00:26:39.150 --> 00:26:42.360
A unit test on your
local workstation,

00:26:42.360 --> 00:26:44.550
it's like a sprint--

00:26:44.550 --> 00:26:49.160
as fast as possible
to the finish line.

00:26:49.160 --> 00:26:52.360
The test suite on your
continuous integration server

00:26:52.360 --> 00:26:54.130
is the marathon.

00:26:54.130 --> 00:26:58.210
The goal is to get
to the finish line

00:26:58.210 --> 00:27:00.191
and not to fail along the way.

00:27:03.420 --> 00:27:08.370
Today, these tests are
executed in different ways,

00:27:08.370 --> 00:27:11.680
from the command line
from Android Studio,

00:27:11.680 --> 00:27:15.740
or triggered automatically
when you submit.

00:27:15.740 --> 00:27:21.710
With Project Nitrogen, this
will become consistent.

00:27:21.710 --> 00:27:25.340
We provide a
well-defined protocol,

00:27:25.340 --> 00:27:30.960
and are unifying all the
Android test offerings.

00:27:30.960 --> 00:27:34.260
Nitrogen uses our own
device infrastructure

00:27:34.260 --> 00:27:37.570
to run your tests--

00:27:37.570 --> 00:27:42.190
Android Orchestrator and
Android JUnit Runner.

00:27:45.230 --> 00:27:50.000
You can already enable the
on-device infrastructure today.

00:27:50.000 --> 00:27:55.760
It has been available
since Android Studio 3.0.

00:27:55.760 --> 00:27:59.540
The Orchestrator
collects your tests

00:27:59.540 --> 00:28:03.040
and kicks off test execution.

00:28:03.040 --> 00:28:07.180
By running each test
in a separate process,

00:28:07.180 --> 00:28:13.590
shared state is minimized
and crashes are isolated.

00:28:13.590 --> 00:28:16.770
Moreover, your
tests are executed

00:28:16.770 --> 00:28:20.800
in a familiar JUnit environment,
provided by Android JUnit

00:28:20.800 --> 00:28:21.300
Runner.

00:28:24.350 --> 00:28:26.730
The Orchestrator
collects all test

00:28:26.730 --> 00:28:30.090
results, additional
artifacts, and streams

00:28:30.090 --> 00:28:39.280
it back to Nitrogen. Nitrogen
provides a unified reporting

00:28:39.280 --> 00:28:42.330
format for these test results.

00:28:42.330 --> 00:28:47.750
In addition, it provides a huge
selection of test output data,

00:28:47.750 --> 00:28:53.380
such as Locket, screenshots,
video, profiling data, battery

00:28:53.380 --> 00:28:56.570
performance, and much more.

00:28:56.570 --> 00:28:59.520
All artifacts are
scoped per test.

00:28:59.520 --> 00:29:04.430
This means that, for
example, a Locket snippet

00:29:04.430 --> 00:29:08.480
is reduced to the test method.

00:29:08.480 --> 00:29:11.240
No more digging through
hundreds of lines of Locket.

00:29:14.020 --> 00:29:18.520
So let me show you how Nitrogen
improves the entire testing

00:29:18.520 --> 00:29:20.360
flow on Android.

00:29:20.360 --> 00:29:24.050
First, Nitrogen finds the
device and configures it

00:29:24.050 --> 00:29:26.500
for the test run.

00:29:26.500 --> 00:29:30.160
Second, it runs
tests in isolation,

00:29:30.160 --> 00:29:32.670
using the Orchestrator.

00:29:32.670 --> 00:29:37.170
And finally, while
tests are running,

00:29:37.170 --> 00:29:39.990
Nitrogen host site
infrastructure

00:29:39.990 --> 00:29:44.190
will be streaming the test
results from the device,

00:29:44.190 --> 00:29:46.680
pulling down all
test output data,

00:29:46.680 --> 00:29:47.890
and feeding it back to you.

00:29:50.700 --> 00:29:53.800
With Nitrogen, all
this complexity

00:29:53.800 --> 00:29:58.010
is hidden from
you, whether you're

00:29:58.010 --> 00:30:05.420
running a test on Android
Studio or on a CI server.

00:30:05.420 --> 00:30:10.195
Nitrogen is the single entry
point for all Android tests.

00:30:12.980 --> 00:30:17.510
It works from a
sprint to a marathon.

00:30:17.510 --> 00:30:22.570
Nitrogen can regress the
device in a Firebase Test Lab,

00:30:22.570 --> 00:30:29.620
reliably running your tests,
returning unified test results.

00:30:29.620 --> 00:30:31.490
Nitrogen supports Google Cloud.

00:30:34.160 --> 00:30:37.640
From your workstation, you
can deploy and run tests

00:30:37.640 --> 00:30:40.260
on the real device or
on a virtual device.

00:30:42.980 --> 00:30:46.920
Nitrogen works seamless
seamlessly with Robolectric.

00:30:46.920 --> 00:30:51.510
Now, we can treat Robolectric
as a simulated device.

00:30:54.150 --> 00:30:59.250
With Robolectric 4.0, we
have made big improvements

00:30:59.250 --> 00:31:03.470
in startup time and
memory consumption.

00:31:03.470 --> 00:31:08.146
Robolectric 4.0
is released today.

00:31:08.146 --> 00:31:10.566
[APPLAUSE]

00:31:13.470 --> 00:31:16.830
And if this is not
enough, Nitrogen

00:31:16.830 --> 00:31:19.060
supports your custom needs.

00:31:19.060 --> 00:31:22.890
For example, if you have
an in-house device lab.

00:31:26.400 --> 00:31:29.640
Allow me to summarize.

00:31:29.640 --> 00:31:33.420
Previously, you had to
learn multiple approaches

00:31:33.420 --> 00:31:36.920
for doing the same thing.

00:31:36.920 --> 00:31:41.240
Tools lacked the mobility
to move between the layers

00:31:41.240 --> 00:31:41.900
of the pyramid.

00:31:44.750 --> 00:31:46.570
You had to choose wisely.

00:31:50.540 --> 00:31:53.210
We have reduced
the cognitive load

00:31:53.210 --> 00:31:58.100
by providing you a
single set of APIs that

00:31:58.100 --> 00:32:04.640
work across environments for
both on and off scenarios.

00:32:04.640 --> 00:32:08.570
And a single entry
point for Android

00:32:08.570 --> 00:32:13.900
tests with the flexibility to
customize any point in the test

00:32:13.900 --> 00:32:14.880
invocation.

00:32:18.380 --> 00:32:22.130
Jetpack with Nitrogen,
is a giant leap forward

00:32:22.130 --> 00:32:23.630
in test automation for Android.

00:32:27.660 --> 00:32:33.180
Write your test once,
run it everywhere.

00:32:33.180 --> 00:32:35.600
[APPLAUSE]

00:32:42.860 --> 00:32:45.810
This is just the beginning.

00:32:45.810 --> 00:32:51.280
Now, you have both the
tools and the knowledge

00:32:51.280 --> 00:32:55.970
to accelerate your
testing experience.

00:32:55.970 --> 00:32:58.460
I strongly encourage
you to check out

00:32:58.460 --> 00:33:03.630
our codelabs, especially
our latest addition,

00:33:03.630 --> 00:33:05.820
building Android
apps with Bazel.

00:33:08.590 --> 00:33:11.500
Bazel is the open source
version of our internal

00:33:11.500 --> 00:33:16.370
build system, allowing
you to build large Android

00:33:16.370 --> 00:33:17.800
apps at Google scale.

00:33:21.330 --> 00:33:23.700
If you have further
questions, or if you

00:33:23.700 --> 00:33:27.420
would like to discuss
your testing strategy,

00:33:27.420 --> 00:33:30.970
come find us tomorrow
morning at 11:00

00:33:30.970 --> 00:33:38.930
AM in the office hours
tent in section A.

00:33:38.930 --> 00:33:42.800
We hope you enjoyed
our session, and we

00:33:42.800 --> 00:33:45.510
would love to hear from you.

00:33:45.510 --> 00:33:49.820
So please, take a moment
to submit your feedback.

00:33:49.820 --> 00:33:52.820
And with that, happy testing.

00:33:52.820 --> 00:33:56.415
[MUSIC PLAYING]

