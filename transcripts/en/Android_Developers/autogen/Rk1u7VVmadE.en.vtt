WEBVTT
Kind: captions
Language: en

00:00:07.700 --> 00:00:10.100
 
hi my name is reto Meier and I'm the

00:00:10.100 --> 00:00:10.110
hi my name is reto Meier and I'm the
 

00:00:10.110 --> 00:00:12.049
hi my name is reto Meier and I'm the
tech lead for Google's Android developer

00:00:12.049 --> 00:00:12.059
tech lead for Google's Android developer
 

00:00:12.059 --> 00:00:14.299
tech lead for Google's Android developer
relations team this efficient data

00:00:14.299 --> 00:00:14.309
relations team this efficient data
 

00:00:14.309 --> 00:00:16.099
relations team this efficient data
transfers dev byte focuses on how you

00:00:16.099 --> 00:00:16.109
transfers dev byte focuses on how you
 

00:00:16.109 --> 00:00:18.109
transfers dev byte focuses on how you
can use prefetching to implement the big

00:00:18.109 --> 00:00:18.119
can use prefetching to implement the big
 

00:00:18.119 --> 00:00:19.519
can use prefetching to implement the big
cookie model of efficient data transfers

00:00:19.519 --> 00:00:19.529
cookie model of efficient data transfers
 

00:00:19.529 --> 00:00:21.859
cookie model of efficient data transfers
and improve your apps user experience by

00:00:21.859 --> 00:00:21.869
and improve your apps user experience by
 

00:00:21.869 --> 00:00:23.509
and improve your apps user experience by
reducing latency and improving battery

00:00:23.509 --> 00:00:23.519
reducing latency and improving battery
 

00:00:23.519 --> 00:00:25.880
reducing latency and improving battery
life in previous efficient data

00:00:25.880 --> 00:00:25.890
life in previous efficient data
 

00:00:25.890 --> 00:00:28.250
life in previous efficient data
transfers dev bytes I looked at the cell

00:00:28.250 --> 00:00:28.260
transfers dev bytes I looked at the cell
 

00:00:28.260 --> 00:00:29.990
transfers dev bytes I looked at the cell
radio state machine and examined ways to

00:00:29.990 --> 00:00:30.000
radio state machine and examined ways to
 

00:00:30.000 --> 00:00:32.060
radio state machine and examined ways to
analyze apps data transfer profiles to

00:00:32.060 --> 00:00:32.070
analyze apps data transfer profiles to
 

00:00:32.070 --> 00:00:33.709
analyze apps data transfer profiles to
uncover anti patterns such as these

00:00:33.709 --> 00:00:33.719
uncover anti patterns such as these
 

00:00:33.719 --> 00:00:36.560
uncover anti patterns such as these
short intermittent Peaks and consecutive

00:00:36.560 --> 00:00:36.570
short intermittent Peaks and consecutive
 

00:00:36.570 --> 00:00:39.049
short intermittent Peaks and consecutive
but non overlapping downloads having

00:00:39.049 --> 00:00:39.059
but non overlapping downloads having
 

00:00:39.059 --> 00:00:40.459
but non overlapping downloads having
discovered potential problems in this

00:00:40.459 --> 00:00:40.469
discovered potential problems in this
 

00:00:40.469 --> 00:00:41.959
discovered potential problems in this
episode I'll look at how to use

00:00:41.959 --> 00:00:41.969
episode I'll look at how to use
 

00:00:41.969 --> 00:00:44.479
episode I'll look at how to use
prefetching to solve some of them we

00:00:44.479 --> 00:00:44.489
prefetching to solve some of them we
 

00:00:44.489 --> 00:00:46.040
prefetching to solve some of them we
know that carriers adjust the timings of

00:00:46.040 --> 00:00:46.050
know that carriers adjust the timings of
 

00:00:46.050 --> 00:00:47.600
know that carriers adjust the timings of
cell radio state machine to compromise

00:00:47.600 --> 00:00:47.610
cell radio state machine to compromise
 

00:00:47.610 --> 00:00:49.369
cell radio state machine to compromise
between data transfer latency and

00:00:49.369 --> 00:00:49.379
between data transfer latency and
 

00:00:49.379 --> 00:00:51.139
between data transfer latency and
battery drain but within our app we want

00:00:51.139 --> 00:00:51.149
battery drain but within our app we want
 

00:00:51.149 --> 00:00:52.970
battery drain but within our app we want
to create the perfect user experience

00:00:52.970 --> 00:00:52.980
to create the perfect user experience
 

00:00:52.980 --> 00:00:55.400
to create the perfect user experience
that actually sits here at the sweet

00:00:55.400 --> 00:00:55.410
that actually sits here at the sweet
 

00:00:55.410 --> 00:00:57.139
that actually sits here at the sweet
spot of non-existent latency and

00:00:57.139 --> 00:00:57.149
spot of non-existent latency and
 

00:00:57.149 --> 00:00:59.540
spot of non-existent latency and
virtually no battery impact is such a

00:00:59.540 --> 00:00:59.550
virtually no battery impact is such a
 

00:00:59.550 --> 00:01:01.900
virtually no battery impact is such a
thing even possible yes it is

00:01:01.900 --> 00:01:01.910
thing even possible yes it is
 

00:01:01.910 --> 00:01:03.740
thing even possible yes it is
prefetching offers the best of both

00:01:03.740 --> 00:01:03.750
prefetching offers the best of both
 

00:01:03.750 --> 00:01:05.119
prefetching offers the best of both
worlds an effective way to reduce

00:01:05.119 --> 00:01:05.129
worlds an effective way to reduce
 

00:01:05.129 --> 00:01:06.950
worlds an effective way to reduce
battery drain by reducing the number of

00:01:06.950 --> 00:01:06.960
battery drain by reducing the number of
 

00:01:06.960 --> 00:01:09.020
battery drain by reducing the number of
data transfers and minimizing the in

00:01:09.020 --> 00:01:09.030
data transfers and minimizing the in
 

00:01:09.030 --> 00:01:10.580
data transfers and minimizing the in
herb latency triggered when users have

00:01:10.580 --> 00:01:10.590
herb latency triggered when users have
 

00:01:10.590 --> 00:01:12.350
herb latency triggered when users have
to wait for dollars to complete before

00:01:12.350 --> 00:01:12.360
to wait for dollars to complete before
 

00:01:12.360 --> 00:01:15.289
to wait for dollars to complete before
performing in action or viewing data by

00:01:15.289 --> 00:01:15.299
performing in action or viewing data by
 

00:01:15.299 --> 00:01:16.580
performing in action or viewing data by
downloading all of the data that they're

00:01:16.580 --> 00:01:16.590
downloading all of the data that they're
 

00:01:16.590 --> 00:01:18.020
downloading all of the data that they're
likely to need for the current session

00:01:18.020 --> 00:01:18.030
likely to need for the current session
 

00:01:18.030 --> 00:01:19.670
likely to need for the current session
in a single burst over a single

00:01:19.670 --> 00:01:19.680
in a single burst over a single
 

00:01:19.680 --> 00:01:21.830
in a single burst over a single
connection at full capacity you can

00:01:21.830 --> 00:01:21.840
connection at full capacity you can
 

00:01:21.840 --> 00:01:23.780
connection at full capacity you can
significantly reduce the number of radio

00:01:23.780 --> 00:01:23.790
significantly reduce the number of radio
 

00:01:23.790 --> 00:01:26.300
significantly reduce the number of radio
activations your challenge is figuring

00:01:26.300 --> 00:01:26.310
activations your challenge is figuring
 

00:01:26.310 --> 00:01:28.460
activations your challenge is figuring
out what you need to download ahead of

00:01:28.460 --> 00:01:28.470
out what you need to download ahead of
 

00:01:28.470 --> 00:01:30.140
out what you need to download ahead of
time so that you can present the user

00:01:30.140 --> 00:01:30.150
time so that you can present the user
 

00:01:30.150 --> 00:01:32.060
time so that you can present the user
with exactly what they need when they

00:01:32.060 --> 00:01:32.070
with exactly what they need when they
 

00:01:32.070 --> 00:01:33.890
with exactly what they need when they
need it without simply downloading

00:01:33.890 --> 00:01:33.900
need it without simply downloading
 

00:01:33.900 --> 00:01:35.749
need it without simply downloading
everything and wasting battery power and

00:01:35.749 --> 00:01:35.759
everything and wasting battery power and
 

00:01:35.759 --> 00:01:37.580
everything and wasting battery power and
bandwidth downloading data that's never

00:01:37.580 --> 00:01:37.590
bandwidth downloading data that's never
 

00:01:37.590 --> 00:01:39.890
bandwidth downloading data that's never
used how aggressively you prefetch

00:01:39.890 --> 00:01:39.900
used how aggressively you prefetch
 

00:01:39.900 --> 00:01:41.300
used how aggressively you prefetch
depends on the size of the data being

00:01:41.300 --> 00:01:41.310
depends on the size of the data being
 

00:01:41.310 --> 00:01:43.730
depends on the size of the data being
downloaded and the likelihood over being

00:01:43.730 --> 00:01:43.740
downloaded and the likelihood over being
 

00:01:43.740 --> 00:01:46.010
downloaded and the likelihood over being
used as a rough guide for a typical cell

00:01:46.010 --> 00:01:46.020
used as a rough guide for a typical cell
 

00:01:46.020 --> 00:01:48.260
used as a rough guide for a typical cell
radio connected over 3G you can prefetch

00:01:48.260 --> 00:01:48.270
radio connected over 3G you can prefetch
 

00:01:48.270 --> 00:01:50.569
radio connected over 3G you can prefetch
around 6 seconds that's about 1 to 2

00:01:50.569 --> 00:01:50.579
around 6 seconds that's about 1 to 2
 

00:01:50.579 --> 00:01:53.510
around 6 seconds that's about 1 to 2
Meg's worth of data if that data has a

00:01:53.510 --> 00:01:53.520
Meg's worth of data if that data has a
 

00:01:53.520 --> 00:01:55.370
Meg's worth of data if that data has a
50% chance of being used within the

00:01:55.370 --> 00:01:55.380
50% chance of being used within the
 

00:01:55.380 --> 00:01:57.260
50% chance of being used within the
current session now at that point the

00:01:57.260 --> 00:01:57.270
current session now at that point the
 

00:01:57.270 --> 00:01:59.240
current session now at that point the
likely cost of downloading any unused

00:01:59.240 --> 00:01:59.250
likely cost of downloading any unused
 

00:01:59.250 --> 00:02:01.069
likely cost of downloading any unused
data matches the potential savings lost

00:02:01.069 --> 00:02:01.079
data matches the potential savings lost
 

00:02:01.079 --> 00:02:02.840
data matches the potential savings lost
by not downloading that data to begin

00:02:02.840 --> 00:02:02.850
by not downloading that data to begin
 

00:02:02.850 --> 00:02:05.270
by not downloading that data to begin
with but of course not every network

00:02:05.270 --> 00:02:05.280
with but of course not every network
 

00:02:05.280 --> 00:02:07.520
with but of course not every network
transfers data at the same rate so the

00:02:07.520 --> 00:02:07.530
transfers data at the same rate so the
 

00:02:07.530 --> 00:02:09.290
transfers data at the same rate so the
equation will change based on the speed

00:02:09.290 --> 00:02:09.300
equation will change based on the speed
 

00:02:09.300 --> 00:02:10.940
equation will change based on the speed
of transfers and the efficiency of the

00:02:10.940 --> 00:02:10.950
of transfers and the efficiency of the
 

00:02:10.950 --> 00:02:12.860
of transfers and the efficiency of the
cell radio technology

00:02:12.860 --> 00:02:12.870
cell radio technology
 

00:02:12.870 --> 00:02:15.410
cell radio technology
this code sets a default value for 3G

00:02:15.410 --> 00:02:15.420
this code sets a default value for 3G
 

00:02:15.420 --> 00:02:17.780
this code sets a default value for 3G
networks and increases and/or decreases

00:02:17.780 --> 00:02:17.790
networks and increases and/or decreases
 

00:02:17.790 --> 00:02:20.119
networks and increases and/or decreases
the size of the prefetch cache based on

00:02:20.119 --> 00:02:20.129
the size of the prefetch cache based on
 

00:02:20.129 --> 00:02:22.430
the size of the prefetch cache based on
the speed and cost of each network note

00:02:22.430 --> 00:02:22.440
the speed and cost of each network note
 

00:02:22.440 --> 00:02:24.050
the speed and cost of each network note
that we want to prefetch significantly

00:02:24.050 --> 00:02:24.060
that we want to prefetch significantly
 

00:02:24.060 --> 00:02:26.660
that we want to prefetch significantly
more data on faster 4G networks and

00:02:26.660 --> 00:02:26.670
more data on faster 4G networks and
 

00:02:26.670 --> 00:02:28.039
more data on faster 4G networks and
that's both to account for the larger

00:02:28.039 --> 00:02:28.049
that's both to account for the larger
 

00:02:28.049 --> 00:02:29.300
that's both to account for the larger
amount of data that can be downloaded

00:02:29.300 --> 00:02:29.310
amount of data that can be downloaded
 

00:02:29.310 --> 00:02:31.220
amount of data that can be downloaded
within the same time period but also

00:02:31.220 --> 00:02:31.230
within the same time period but also
 

00:02:31.230 --> 00:02:32.630
within the same time period but also
because the higher battery cost

00:02:32.630 --> 00:02:32.640
because the higher battery cost
 

00:02:32.640 --> 00:02:34.789
because the higher battery cost
associated with these radios so that

00:02:34.789 --> 00:02:34.799
associated with these radios so that
 

00:02:34.799 --> 00:02:36.319
associated with these radios so that
makes it even more important that we

00:02:36.319 --> 00:02:36.329
makes it even more important that we
 

00:02:36.329 --> 00:02:38.210
makes it even more important that we
avoid extra straight transitions

00:02:38.210 --> 00:02:38.220
avoid extra straight transitions
 

00:02:38.220 --> 00:02:39.289
avoid extra straight transitions
whenever we can

00:02:39.289 --> 00:02:39.299
whenever we can
 

00:02:39.299 --> 00:02:41.930
whenever we can
but if networks are different so are our

00:02:41.930 --> 00:02:41.940
but if networks are different so are our
 

00:02:41.940 --> 00:02:44.030
but if networks are different so are our
apps and as the likelihood of the data

00:02:44.030 --> 00:02:44.040
apps and as the likelihood of the data
 

00:02:44.040 --> 00:02:45.949
apps and as the likelihood of the data
being used increases so does the amount

00:02:45.949 --> 00:02:45.959
being used increases so does the amount
 

00:02:45.959 --> 00:02:47.809
being used increases so does the amount
of data it's worth prefetching so it's

00:02:47.809 --> 00:02:47.819
of data it's worth prefetching so it's
 

00:02:47.819 --> 00:02:50.360
of data it's worth prefetching so it's
important to understand both what data

00:02:50.360 --> 00:02:50.370
important to understand both what data
 

00:02:50.370 --> 00:02:52.430
important to understand both what data
your users will likely use and what your

00:02:52.430 --> 00:02:52.440
your users will likely use and what your
 

00:02:52.440 --> 00:02:52.729
your users will likely use and what your
app's

00:02:52.729 --> 00:02:52.739
app's
 

00:02:52.739 --> 00:02:55.039
app's
average session length is a good

00:02:55.039 --> 00:02:55.049
average session length is a good
 

00:02:55.049 --> 00:02:56.599
average session length is a good
starting point is to expect session

00:02:56.599 --> 00:02:56.609
starting point is to expect session
 

00:02:56.609 --> 00:02:58.369
starting point is to expect session
lengths of around 2 to 5 minutes so

00:02:58.369 --> 00:02:58.379
lengths of around 2 to 5 minutes so
 

00:02:58.379 --> 00:03:00.229
lengths of around 2 to 5 minutes so
large downloads such as video files

00:03:00.229 --> 00:03:00.239
large downloads such as video files
 

00:03:00.239 --> 00:03:01.789
large downloads such as video files
should be downloaded in chunks at

00:03:01.789 --> 00:03:01.799
should be downloaded in chunks at
 

00:03:01.799 --> 00:03:03.949
should be downloaded in chunks at
regular intervals using the same logic

00:03:03.949 --> 00:03:03.959
regular intervals using the same logic
 

00:03:03.959 --> 00:03:06.110
regular intervals using the same logic
for a music player it will be good

00:03:06.110 --> 00:03:06.120
for a music player it will be good
 

00:03:06.120 --> 00:03:08.180
for a music player it will be good
practice to maintain a buffer of one

00:03:08.180 --> 00:03:08.190
practice to maintain a buffer of one
 

00:03:08.190 --> 00:03:09.589
practice to maintain a buffer of one
song in addition to the one already

00:03:09.589 --> 00:03:09.599
song in addition to the one already
 

00:03:09.599 --> 00:03:12.050
song in addition to the one already
being played rather than prefetching say

00:03:12.050 --> 00:03:12.060
being played rather than prefetching say
 

00:03:12.060 --> 00:03:15.050
being played rather than prefetching say
a whole album or playlist this mitigates

00:03:15.050 --> 00:03:15.060
a whole album or playlist this mitigates
 

00:03:15.060 --> 00:03:16.909
a whole album or playlist this mitigates
the risk of wasting significant

00:03:16.909 --> 00:03:16.919
the risk of wasting significant
 

00:03:16.919 --> 00:03:18.500
the risk of wasting significant
bandwidth and battery life if you user

00:03:18.500 --> 00:03:18.510
bandwidth and battery life if you user
 

00:03:18.510 --> 00:03:20.289
bandwidth and battery life if you user
stops listening halfway through a song

00:03:20.289 --> 00:03:20.299
stops listening halfway through a song
 

00:03:20.299 --> 00:03:22.430
stops listening halfway through a song
you can take a similar approach when

00:03:22.430 --> 00:03:22.440
you can take a similar approach when
 

00:03:22.440 --> 00:03:24.440
you can take a similar approach when
streaming by using HTTP Live Streaming

00:03:24.440 --> 00:03:24.450
streaming by using HTTP Live Streaming
 

00:03:24.450 --> 00:03:27.199
streaming by using HTTP Live Streaming
which transmits audio in bursts rather

00:03:27.199 --> 00:03:27.209
which transmits audio in bursts rather
 

00:03:27.209 --> 00:03:28.909
which transmits audio in bursts rather
than maintaining a continuous string

00:03:28.909 --> 00:03:28.919
than maintaining a continuous string
 

00:03:28.919 --> 00:03:30.619
than maintaining a continuous string
that will keep the radio constantly

00:03:30.619 --> 00:03:30.629
that will keep the radio constantly
 

00:03:30.629 --> 00:03:33.199
that will keep the radio constantly
active if we look at something like a

00:03:33.199 --> 00:03:33.209
active if we look at something like a
 

00:03:33.209 --> 00:03:35.360
active if we look at something like a
news app things get a little more

00:03:35.360 --> 00:03:35.370
news app things get a little more
 

00:03:35.370 --> 00:03:37.610
news app things get a little more
complicated a typical use case for music

00:03:37.610 --> 00:03:37.620
complicated a typical use case for music
 

00:03:37.620 --> 00:03:40.009
complicated a typical use case for music
players to find an album or playlist hit

00:03:40.009 --> 00:03:40.019
players to find an album or playlist hit
 

00:03:40.019 --> 00:03:42.289
players to find an album or playlist hit
play and then listen so you have a

00:03:42.289 --> 00:03:42.299
play and then listen so you have a
 

00:03:42.299 --> 00:03:43.789
play and then listen so you have a
really good chance of knowing what's

00:03:43.789 --> 00:03:43.799
really good chance of knowing what's
 

00:03:43.799 --> 00:03:45.710
really good chance of knowing what's
coming next and a reasonable expectation

00:03:45.710 --> 00:03:45.720
coming next and a reasonable expectation
 

00:03:45.720 --> 00:03:48.080
coming next and a reasonable expectation
for what your user is going to do and

00:03:48.080 --> 00:03:48.090
for what your user is going to do and
 

00:03:48.090 --> 00:03:49.250
for what your user is going to do and
they're gonna have a reasonable

00:03:49.250 --> 00:03:49.260
they're gonna have a reasonable
 

00:03:49.260 --> 00:03:50.629
they're gonna have a reasonable
expectation that there's going to be a

00:03:50.629 --> 00:03:50.639
expectation that there's going to be a
 

00:03:50.639 --> 00:03:52.759
expectation that there's going to be a
start up latency if they select a new

00:03:52.759 --> 00:03:52.769
start up latency if they select a new
 

00:03:52.769 --> 00:03:55.490
start up latency if they select a new
track now in contrast the browsing path

00:03:55.490 --> 00:03:55.500
track now in contrast the browsing path
 

00:03:55.500 --> 00:03:57.650
track now in contrast the browsing path
when you're using something like a news

00:03:57.650 --> 00:03:57.660
when you're using something like a news
 

00:03:57.660 --> 00:03:59.839
when you're using something like a news
reader is much less predictable with

00:03:59.839 --> 00:03:59.849
reader is much less predictable with
 

00:03:59.849 --> 00:04:01.189
reader is much less predictable with
readers potentially swiping between

00:04:01.189 --> 00:04:01.199
readers potentially swiping between
 

00:04:01.199 --> 00:04:02.750
readers potentially swiping between
dozens of different categories and

00:04:02.750 --> 00:04:02.760
dozens of different categories and
 

00:04:02.760 --> 00:04:04.670
dozens of different categories and
jumping between hundreds of articles in

00:04:04.670 --> 00:04:04.680
jumping between hundreds of articles in
 

00:04:04.680 --> 00:04:06.920
jumping between hundreds of articles in
many ways and users rate reader behaves

00:04:06.920 --> 00:04:06.930
many ways and users rate reader behaves
 

00:04:06.930 --> 00:04:09.050
many ways and users rate reader behaves
a lot like a browser so your approach to

00:04:09.050 --> 00:04:09.060
a lot like a browser so your approach to
 

00:04:09.060 --> 00:04:10.879
a lot like a browser so your approach to
prefetching can utilize some of the same

00:04:10.879 --> 00:04:10.889
prefetching can utilize some of the same
 

00:04:10.889 --> 00:04:12.680
prefetching can utilize some of the same
techniques browsers use to improve

00:04:12.680 --> 00:04:12.690
techniques browsers use to improve
 

00:04:12.690 --> 00:04:15.770
techniques browsers use to improve
speeds now the most naive solution is to

00:04:15.770 --> 00:04:15.780
speeds now the most naive solution is to
 

00:04:15.780 --> 00:04:17.330
speeds now the most naive solution is to
download the headlines for a category

00:04:17.330 --> 00:04:17.340
download the headlines for a category
 

00:04:17.340 --> 00:04:19.849
download the headlines for a category
once it's been selected and download the

00:04:19.849 --> 00:04:19.859
once it's been selected and download the
 

00:04:19.859 --> 00:04:21.500
once it's been selected and download the
related thumbnails when they scroll into

00:04:21.500 --> 00:04:21.510
related thumbnails when they scroll into
 

00:04:21.510 --> 00:04:23.390
related thumbnails when they scroll into
view and then each of the articles once

00:04:23.390 --> 00:04:23.400
view and then each of the articles once
 

00:04:23.400 --> 00:04:24.820
view and then each of the articles once
it's being clicked now

00:04:24.820 --> 00:04:24.830
it's being clicked now
 

00:04:24.830 --> 00:04:26.740
it's being clicked now
this forces the radio to remain active

00:04:26.740 --> 00:04:26.750
this forces the radio to remain active
 

00:04:26.750 --> 00:04:28.719
this forces the radio to remain active
for basically the entire session is

00:04:28.719 --> 00:04:28.729
for basically the entire session is
 

00:04:28.729 --> 00:04:30.429
for basically the entire session is
you're switching categories scrolling

00:04:30.429 --> 00:04:30.439
you're switching categories scrolling
 

00:04:30.439 --> 00:04:31.929
you're switching categories scrolling
headlines and reading different articles

00:04:31.929 --> 00:04:31.939
headlines and reading different articles
 

00:04:31.939 --> 00:04:33.999
headlines and reading different articles
and as a bonus each click is going to

00:04:33.999 --> 00:04:34.009
and as a bonus each click is going to
 

00:04:34.009 --> 00:04:35.980
and as a bonus each click is going to
have that latency associated with it as

00:04:35.980 --> 00:04:35.990
have that latency associated with it as
 

00:04:35.990 --> 00:04:38.080
have that latency associated with it as
it has to download and process and

00:04:38.080 --> 00:04:38.090
it has to download and process and
 

00:04:38.090 --> 00:04:40.409
it has to download and process and
present the data that you've selected a

00:04:40.409 --> 00:04:40.419
present the data that you've selected a
 

00:04:40.419 --> 00:04:42.969
present the data that you've selected a
much better approach is prefetching a

00:04:42.969 --> 00:04:42.979
much better approach is prefetching a
 

00:04:42.979 --> 00:04:44.920
much better approach is prefetching a
reasonable amount of data at startup

00:04:44.920 --> 00:04:44.930
reasonable amount of data at startup
 

00:04:44.930 --> 00:04:46.779
reasonable amount of data at startup
prioritizing the first set of news

00:04:46.779 --> 00:04:46.789
prioritizing the first set of news
 

00:04:46.789 --> 00:04:48.580
prioritizing the first set of news
headlines and thumbnails which are

00:04:48.580 --> 00:04:48.590
headlines and thumbnails which are
 

00:04:48.590 --> 00:04:50.649
headlines and thumbnails which are
likely to be displayed and continuing on

00:04:50.649 --> 00:04:50.659
likely to be displayed and continuing on
 

00:04:50.659 --> 00:04:51.879
likely to be displayed and continuing on
with the remaining headlines and

00:04:51.879 --> 00:04:51.889
with the remaining headlines and
 

00:04:51.889 --> 00:04:54.790
with the remaining headlines and
thumbnails and also article text now

00:04:54.790 --> 00:04:54.800
thumbnails and also article text now
 

00:04:54.800 --> 00:04:56.409
thumbnails and also article text now
it's also important to ensure that your

00:04:56.409 --> 00:04:56.419
it's also important to ensure that your
 

00:04:56.419 --> 00:04:57.939
it's also important to ensure that your
prefetching doesn't delay the app

00:04:57.939 --> 00:04:57.949
prefetching doesn't delay the app
 

00:04:57.949 --> 00:05:00.010
prefetching doesn't delay the app
startup by making the app wait for the

00:05:00.010 --> 00:05:00.020
startup by making the app wait for the
 

00:05:00.020 --> 00:05:01.360
startup by making the app wait for the
prefetch to complete fully before

00:05:01.360 --> 00:05:01.370
prefetch to complete fully before
 

00:05:01.370 --> 00:05:03.580
prefetch to complete fully before
letting the user interact the worst

00:05:03.580 --> 00:05:03.590
letting the user interact the worst
 

00:05:03.590 --> 00:05:05.290
letting the user interact the worst
example of this is after the display a

00:05:05.290 --> 00:05:05.300
example of this is after the display a
 

00:05:05.300 --> 00:05:08.230
example of this is after the display a
splash screen until a ping or download

00:05:08.230 --> 00:05:08.240
splash screen until a ping or download
 

00:05:08.240 --> 00:05:11.110
splash screen until a ping or download
or process cycle is completed so be sure

00:05:11.110 --> 00:05:11.120
or process cycle is completed so be sure
 

00:05:11.120 --> 00:05:12.790
or process cycle is completed so be sure
to process all of your downloads in the

00:05:12.790 --> 00:05:12.800
to process all of your downloads in the
 

00:05:12.800 --> 00:05:14.619
to process all of your downloads in the
background using intense services and

00:05:14.619 --> 00:05:14.629
background using intense services and
 

00:05:14.629 --> 00:05:16.269
background using intense services and
libraries like volley to help process

00:05:16.269 --> 00:05:16.279
libraries like volley to help process
 

00:05:16.279 --> 00:05:18.430
libraries like volley to help process
that data progressively and concurrently

00:05:18.430 --> 00:05:18.440
that data progressively and concurrently
 

00:05:18.440 --> 00:05:20.469
that data progressively and concurrently
and therefore minimize that startup

00:05:20.469 --> 00:05:20.479
and therefore minimize that startup
 

00:05:20.479 --> 00:05:24.189
and therefore minimize that startup
latency the real trick is being able to

00:05:24.189 --> 00:05:24.199
latency the real trick is being able to
 

00:05:24.199 --> 00:05:26.379
latency the real trick is being able to
accurately guess which articles each

00:05:26.379 --> 00:05:26.389
accurately guess which articles each
 

00:05:26.389 --> 00:05:28.659
accurately guess which articles each
user is likely to read and prefetch only

00:05:28.659 --> 00:05:28.669
user is likely to read and prefetch only
 

00:05:28.669 --> 00:05:31.209
user is likely to read and prefetch only
those now one approach is a

00:05:31.209 --> 00:05:31.219
those now one approach is a
 

00:05:31.219 --> 00:05:33.070
those now one approach is a
breadth-first search assuming that users

00:05:33.070 --> 00:05:33.080
breadth-first search assuming that users
 

00:05:33.080 --> 00:05:35.019
breadth-first search assuming that users
are more likely to read articles near

00:05:35.019 --> 00:05:35.029
are more likely to read articles near
 

00:05:35.029 --> 00:05:36.580
are more likely to read articles near
the current one or you can go

00:05:36.580 --> 00:05:36.590
the current one or you can go
 

00:05:36.590 --> 00:05:38.140
the current one or you can go
depth-first and bank on them reading

00:05:38.140 --> 00:05:38.150
depth-first and bank on them reading
 

00:05:38.150 --> 00:05:40.540
depth-first and bank on them reading
lots of articles on a given topic now a

00:05:40.540 --> 00:05:40.550
lots of articles on a given topic now a
 

00:05:40.550 --> 00:05:43.379
lots of articles on a given topic now a
better approach is to use science

00:05:43.379 --> 00:05:43.389
better approach is to use science
 

00:05:43.389 --> 00:05:45.850
better approach is to use science
measure how your content is actually

00:05:45.850 --> 00:05:45.860
measure how your content is actually
 

00:05:45.860 --> 00:05:47.529
measure how your content is actually
being consumed and use that to inform

00:05:47.529 --> 00:05:47.539
being consumed and use that to inform
 

00:05:47.539 --> 00:05:49.300
being consumed and use that to inform
your decisions dynamically and on a per

00:05:49.300 --> 00:05:49.310
your decisions dynamically and on a per
 

00:05:49.310 --> 00:05:51.640
your decisions dynamically and on a per
user basis you can start by keeping

00:05:51.640 --> 00:05:51.650
user basis you can start by keeping
 

00:05:51.650 --> 00:05:53.439
user basis you can start by keeping
track of the metadata associated with a

00:05:53.439 --> 00:05:53.449
track of the metadata associated with a
 

00:05:53.449 --> 00:05:55.209
track of the metadata associated with a
content read by each user such as the

00:05:55.209 --> 00:05:55.219
content read by each user such as the
 

00:05:55.219 --> 00:05:57.790
content read by each user such as the
categories of authors you can widen this

00:05:57.790 --> 00:05:57.800
categories of authors you can widen this
 

00:05:57.800 --> 00:05:59.740
categories of authors you can widen this
go further by incorporating the content

00:05:59.740 --> 00:05:59.750
go further by incorporating the content
 

00:05:59.750 --> 00:06:01.300
go further by incorporating the content
that their friends use by integrating a

00:06:01.300 --> 00:06:01.310
that their friends use by integrating a
 

00:06:01.310 --> 00:06:03.879
that their friends use by integrating a
social graph like Google+ and finally

00:06:03.879 --> 00:06:03.889
social graph like Google+ and finally
 

00:06:03.889 --> 00:06:05.019
social graph like Google+ and finally
you can aggregate all of this

00:06:05.019 --> 00:06:05.029
you can aggregate all of this
 

00:06:05.029 --> 00:06:06.879
you can aggregate all of this
information together across all of your

00:06:06.879 --> 00:06:06.889
information together across all of your
 

00:06:06.889 --> 00:06:09.159
information together across all of your
users and just go discover what's being

00:06:09.159 --> 00:06:09.169
users and just go discover what's being
 

00:06:09.169 --> 00:06:11.740
users and just go discover what's being
used by a lot of people now taken

00:06:11.740 --> 00:06:11.750
used by a lot of people now taken
 

00:06:11.750 --> 00:06:12.760
used by a lot of people now taken
together you can form a sophisticated

00:06:12.760 --> 00:06:12.770
together you can form a sophisticated
 

00:06:12.770 --> 00:06:15.010
together you can form a sophisticated
picture of typical and expected usage

00:06:15.010 --> 00:06:15.020
picture of typical and expected usage
 

00:06:15.020 --> 00:06:17.140
picture of typical and expected usage
patterns of your app customized for each

00:06:17.140 --> 00:06:17.150
patterns of your app customized for each
 

00:06:17.150 --> 00:06:19.029
patterns of your app customized for each
user and that allows you to make an

00:06:19.029 --> 00:06:19.039
user and that allows you to make an
 

00:06:19.039 --> 00:06:20.769
user and that allows you to make an
intelligent choice over which data you

00:06:20.769 --> 00:06:20.779
intelligent choice over which data you
 

00:06:20.779 --> 00:06:23.379
intelligent choice over which data you
should prefetch if that all sounds like

00:06:23.379 --> 00:06:23.389
should prefetch if that all sounds like
 

00:06:23.389 --> 00:06:25.360
should prefetch if that all sounds like
a bit too much work than the some apps

00:06:25.360 --> 00:06:25.370
a bit too much work than the some apps
 

00:06:25.370 --> 00:06:26.769
a bit too much work than the some apps
it may even make sense to simply

00:06:26.769 --> 00:06:26.779
it may even make sense to simply
 

00:06:26.779 --> 00:06:28.659
it may even make sense to simply
prefetch everything effectively

00:06:28.659 --> 00:06:28.669
prefetch everything effectively
 

00:06:28.669 --> 00:06:30.459
prefetch everything effectively
providing support for a fully offline

00:06:30.459 --> 00:06:30.469
providing support for a fully offline
 

00:06:30.469 --> 00:06:33.370
providing support for a fully offline
experience this can be really effective

00:06:33.370 --> 00:06:33.380
experience this can be really effective
 

00:06:33.380 --> 00:06:34.659
experience this can be really effective
for apps with data that doesn't change

00:06:34.659 --> 00:06:34.669
for apps with data that doesn't change
 

00:06:34.669 --> 00:06:36.699
for apps with data that doesn't change
very often such as magazines but you

00:06:36.699 --> 00:06:36.709
very often such as magazines but you
 

00:06:36.709 --> 00:06:37.450
very often such as magazines but you
risk spending

00:06:37.450 --> 00:06:37.460
risk spending
 

00:06:37.460 --> 00:06:38.950
risk spending
sniffing in bandwidth and battery life

00:06:38.950 --> 00:06:38.960
sniffing in bandwidth and battery life
 

00:06:38.960 --> 00:06:41.890
sniffing in bandwidth and battery life
downloading contact that's never used so

00:06:41.890 --> 00:06:41.900
downloading contact that's never used so
 

00:06:41.900 --> 00:06:43.090
downloading contact that's never used so
it should be done with caution

00:06:43.090 --> 00:06:43.100
it should be done with caution
 

00:06:43.100 --> 00:06:45.279
it should be done with caution
one way to mitigate that cost associated

00:06:45.279 --> 00:06:45.289
one way to mitigate that cost associated
 

00:06:45.289 --> 00:06:46.990
one way to mitigate that cost associated
with downloading more than five minutes

00:06:46.990 --> 00:06:47.000
with downloading more than five minutes
 

00:06:47.000 --> 00:06:48.850
with downloading more than five minutes
worth of data is to schedule the

00:06:48.850 --> 00:06:48.860
worth of data is to schedule the
 

00:06:48.860 --> 00:06:50.290
worth of data is to schedule the
download to occur at a time when

00:06:50.290 --> 00:06:50.300
download to occur at a time when
 

00:06:50.300 --> 00:06:52.270
download to occur at a time when
bandwidth and battery life isn't as

00:06:52.270 --> 00:06:52.280
bandwidth and battery life isn't as
 

00:06:52.280 --> 00:06:53.800
bandwidth and battery life isn't as
important specifically when the device

00:06:53.800 --> 00:06:53.810
important specifically when the device
 

00:06:53.810 --> 00:06:56.230
important specifically when the device
is charging and connected to Wi-Fi as

00:06:56.230 --> 00:06:56.240
is charging and connected to Wi-Fi as
 

00:06:56.240 --> 00:06:57.879
is charging and connected to Wi-Fi as
determined here by using the

00:06:57.879 --> 00:06:57.889
determined here by using the
 

00:06:57.889 --> 00:06:59.760
determined here by using the
connectivity manager and battery manager

00:06:59.760 --> 00:06:59.770
connectivity manager and battery manager
 

00:06:59.770 --> 00:07:01.900
connectivity manager and battery manager
and as long as you monitoring the device

00:07:01.900 --> 00:07:01.910
and as long as you monitoring the device
 

00:07:01.910 --> 00:07:03.640
and as long as you monitoring the device
state why not take it a step further and

00:07:03.640 --> 00:07:03.650
state why not take it a step further and
 

00:07:03.650 --> 00:07:05.580
state why not take it a step further and
track the current activity of the user

00:07:05.580 --> 00:07:05.590
track the current activity of the user
 

00:07:05.590 --> 00:07:08.950
track the current activity of the user
using the new location-based services

00:07:08.950 --> 00:07:08.960
using the new location-based services
 

00:07:08.960 --> 00:07:11.230
using the new location-based services
activity recognition API you can modify

00:07:11.230 --> 00:07:11.240
activity recognition API you can modify
 

00:07:11.240 --> 00:07:13.029
activity recognition API you can modify
the aggressiveness of your prefetching

00:07:13.029 --> 00:07:13.039
the aggressiveness of your prefetching
 

00:07:13.039 --> 00:07:15.339
the aggressiveness of your prefetching
based on what the user is doing in this

00:07:15.339 --> 00:07:15.349
based on what the user is doing in this
 

00:07:15.349 --> 00:07:17.200
based on what the user is doing in this
example we're going to increase the

00:07:17.200 --> 00:07:17.210
example we're going to increase the
 

00:07:17.210 --> 00:07:18.640
example we're going to increase the
amount that we prefetch when the user

00:07:18.640 --> 00:07:18.650
amount that we prefetch when the user
 

00:07:18.650 --> 00:07:20.620
amount that we prefetch when the user
has the app open and is standing skill

00:07:20.620 --> 00:07:20.630
has the app open and is standing skill
 

00:07:20.630 --> 00:07:22.659
has the app open and is standing skill
still the assumption being that they're

00:07:22.659 --> 00:07:22.669
still the assumption being that they're
 

00:07:22.669 --> 00:07:24.279
still the assumption being that they're
more likely to be browsing articles

00:07:24.279 --> 00:07:24.289
more likely to be browsing articles
 

00:07:24.289 --> 00:07:25.629
more likely to be browsing articles
while stationary than if they're riding

00:07:25.629 --> 00:07:25.639
while stationary than if they're riding
 

00:07:25.639 --> 00:07:28.150
while stationary than if they're riding
a bike now so far we've talked about the

00:07:28.150 --> 00:07:28.160
a bike now so far we've talked about the
 

00:07:28.160 --> 00:07:29.649
a bike now so far we've talked about the
case where the app is active in the

00:07:29.649 --> 00:07:29.659
case where the app is active in the
 

00:07:29.659 --> 00:07:30.820
case where the app is active in the
foreground but it's worth considering

00:07:30.820 --> 00:07:30.830
foreground but it's worth considering
 

00:07:30.830 --> 00:07:32.290
foreground but it's worth considering
the background case to should we

00:07:32.290 --> 00:07:32.300
the background case to should we
 

00:07:32.300 --> 00:07:33.939
the background case to should we
prefetch the item when the app is in the

00:07:33.939 --> 00:07:33.949
prefetch the item when the app is in the
 

00:07:33.949 --> 00:07:36.339
prefetch the item when the app is in the
background well generally speaking it's

00:07:36.339 --> 00:07:36.349
background well generally speaking it's
 

00:07:36.349 --> 00:07:37.930
background well generally speaking it's
better practice to delay your dollas

00:07:37.930 --> 00:07:37.940
better practice to delay your dollas
 

00:07:37.940 --> 00:07:40.270
better practice to delay your dollas
until the app is open though this will

00:07:40.270 --> 00:07:40.280
until the app is open though this will
 

00:07:40.280 --> 00:07:42.580
until the app is open though this will
increase your startup latency a good

00:07:42.580 --> 00:07:42.590
increase your startup latency a good
 

00:07:42.590 --> 00:07:43.810
increase your startup latency a good
approach is to use Google Cloud

00:07:43.810 --> 00:07:43.820
approach is to use Google Cloud
 

00:07:43.820 --> 00:07:45.760
approach is to use Google Cloud
messaging to notify your app of updates

00:07:45.760 --> 00:07:45.770
messaging to notify your app of updates
 

00:07:45.770 --> 00:07:47.200
messaging to notify your app of updates
available on the server and that

00:07:47.200 --> 00:07:47.210
available on the server and that
 

00:07:47.210 --> 00:07:49.270
available on the server and that
eliminates the need to pull to check for

00:07:49.270 --> 00:07:49.280
eliminates the need to pull to check for
 

00:07:49.280 --> 00:07:51.370
eliminates the need to pull to check for
updates and provides a channel to notify

00:07:51.370 --> 00:07:51.380
updates and provides a channel to notify
 

00:07:51.380 --> 00:07:52.719
updates and provides a channel to notify
your app of exactly what it should be

00:07:52.719 --> 00:07:52.729
your app of exactly what it should be
 

00:07:52.729 --> 00:07:55.270
your app of exactly what it should be
requesting at startup typically you'll

00:07:55.270 --> 00:07:55.280
requesting at startup typically you'll
 

00:07:55.280 --> 00:07:57.310
requesting at startup typically you'll
use GCM as a way to initiate client-side

00:07:57.310 --> 00:07:57.320
use GCM as a way to initiate client-side
 

00:07:57.320 --> 00:07:59.170
use GCM as a way to initiate client-side
notifications without the app needing to

00:07:59.170 --> 00:07:59.180
notifications without the app needing to
 

00:07:59.180 --> 00:08:00.969
notifications without the app needing to
initiate a separate download but where

00:08:00.969 --> 00:08:00.979
initiate a separate download but where
 

00:08:00.979 --> 00:08:02.469
initiate a separate download but where
it makes sense you can use this same

00:08:02.469 --> 00:08:02.479
it makes sense you can use this same
 

00:08:02.479 --> 00:08:04.330
it makes sense you can use this same
mechanism to trigger background updates

00:08:04.330 --> 00:08:04.340
mechanism to trigger background updates
 

00:08:04.340 --> 00:08:07.149
mechanism to trigger background updates
I'll cover GCM in more detail as well as

00:08:07.149 --> 00:08:07.159
I'll cover GCM in more detail as well as
 

00:08:07.159 --> 00:08:08.770
I'll cover GCM in more detail as well as
topics including batching bundling

00:08:08.770 --> 00:08:08.780
topics including batching bundling
 

00:08:08.780 --> 00:08:10.810
topics including batching bundling
transfers and using sync adapters in

00:08:10.810 --> 00:08:10.820
transfers and using sync adapters in
 

00:08:10.820 --> 00:08:13.510
transfers and using sync adapters in
future episodes of the efficient data

00:08:13.510 --> 00:08:13.520
future episodes of the efficient data
 

00:08:13.520 --> 00:08:16.960
future episodes of the efficient data
transfers devbyte series

