WEBVTT
Kind: captions
Language: en

00:00:03.390 --> 00:00:07.280
PROFESSOR: So this lecture was
about hyperbolic paraboloids,

00:00:07.280 --> 00:00:10.910
and the extent to which
they don't exist or exist.

00:00:10.910 --> 00:00:13.650
Here is a regular
non-existing hyperbolic

00:00:13.650 --> 00:00:19.000
paraboloid with the concentric
squares, no diagonals, folded

00:00:19.000 --> 00:00:20.300
here.

00:00:20.300 --> 00:00:24.380
And so, those are just a
few questions about this.

00:00:24.380 --> 00:00:26.950
What does it mean, other things.

00:00:26.950 --> 00:00:29.420
These are all asked by
[INAUDIBLE] I believe,

00:00:29.420 --> 00:00:35.290
and they're all open, so--
they're all good questions.

00:00:35.290 --> 00:00:38.150
We don't know whether
the good triangulation,

00:00:38.150 --> 00:00:40.050
the alternating one,
works for arbitrary,

00:00:40.050 --> 00:00:42.920
and we only know
up to n equals 100,

00:00:42.920 --> 00:00:45.670
for the various fixed
angles that we checked.

00:00:45.670 --> 00:00:48.630
We don't have a proof
technique to do arbitrary in.

00:00:48.630 --> 00:00:51.510
You could try to do some
amount of alternation,

00:00:51.510 --> 00:00:54.500
but not, somewhere in
between the two extremes,

00:00:54.500 --> 00:00:57.020
and probably you'll get
something in between goodness,

00:00:57.020 --> 00:00:58.916
but I don't know.

00:00:58.916 --> 00:01:01.070
You could certainly
play with that.

00:01:01.070 --> 00:01:05.209
And it's very natural to try
this with larger than squares.

00:01:05.209 --> 00:01:07.390
The only trouble is,
the center no longer

00:01:07.390 --> 00:01:10.530
has a single degree of
freedom, so the only thing

00:01:10.530 --> 00:01:14.240
to answer there would be, How
do you want to initially fold,

00:01:14.240 --> 00:01:16.147
like, if you're doing
a hexagon, hexagon

00:01:16.147 --> 00:01:17.980
is probably clear what
you might want to do,

00:01:17.980 --> 00:01:21.530
but for general
k-gon, how do you

00:01:21.530 --> 00:01:23.770
want to arrange that
innermost k-gon?

00:01:23.770 --> 00:01:26.090
From that, you
could propagate out,

00:01:26.090 --> 00:01:28.020
just like we did with
the square, if you

00:01:28.020 --> 00:01:30.126
use an alternating
triangulation, say.

00:01:30.126 --> 00:01:32.000
Probably works well,
but we haven't tried it.

00:01:32.000 --> 00:01:37.040
That could be a cool project
to do that, not that hard.

00:01:37.040 --> 00:01:40.730
So those were open problems.

00:01:40.730 --> 00:01:47.510
Next, we have some, sort of,
math, general math questions.

00:01:47.510 --> 00:01:50.400
c1, c2, and semi-creases.

00:01:50.400 --> 00:01:52.720
These are related questions.

00:01:52.720 --> 00:01:56.875
So let me do a quick visual
review of these terms.

00:02:00.720 --> 00:02:03.710
I'm going to do it for
one-dimensional curves in 2D,

00:02:03.710 --> 00:02:06.420
because that's a lot
easier to think about, then

00:02:06.420 --> 00:02:08.039
what we really care
about, which is

00:02:08.039 --> 00:02:09.910
two-dimensional services in 3D.

00:02:09.910 --> 00:02:16.740
But all the ideas carry over,
so here is just a function.

00:02:29.710 --> 00:02:32.390
Let's say, for example,
this is a parabolic arc,

00:02:32.390 --> 00:02:33.590
than a straight segment.

00:02:33.590 --> 00:02:36.250
This point is missing,
and instead it's up here.

00:02:36.250 --> 00:02:38.000
These points are
present, and here we

00:02:38.000 --> 00:02:40.230
have another parabolic arc.

00:02:40.230 --> 00:02:50.210
So, this function I would
call piecewise C infinity.

00:02:50.210 --> 00:02:53.330
Let me explain what
these things mean.

00:02:53.330 --> 00:02:57.490
So we have, on the one
hand, c zero is a term,

00:02:57.490 --> 00:02:58.540
meaning just continuous.

00:03:02.030 --> 00:03:04.450
Continuous means
no jumps like this,

00:03:04.450 --> 00:03:08.040
so this is not a
continuous function.

00:03:08.040 --> 00:03:10.460
So this function overall
is not even c zero. c1

00:03:10.460 --> 00:03:13.960
is a stronger condition, which
means that not only are you

00:03:13.960 --> 00:03:18.220
continuous, but you also have
a continuous and existing

00:03:18.220 --> 00:03:18.960
first derivative.

00:03:25.847 --> 00:03:27.680
So whereas here we're
thinking about f, here

00:03:27.680 --> 00:03:30.500
we're thinking of f prime.

00:03:30.500 --> 00:03:34.440
So, not only can you talk about
the function being continuous,

00:03:34.440 --> 00:03:37.700
c0c1, but you can talk about
individual moments in time.

00:03:37.700 --> 00:03:42.880
So for example, this moment
here is going to be c1.

00:03:42.880 --> 00:03:44.650
It has a nice derivative.

00:03:44.650 --> 00:03:48.030
That derivative is
changing continuously here.

00:03:48.030 --> 00:03:54.880
Here, however, this
is c zero, but not c1,

00:03:54.880 --> 00:03:57.730
because the tangent
on the left is

00:03:57.730 --> 00:03:59.980
different from the
tangent on the right.

00:03:59.980 --> 00:04:02.910
So this is not a c1 function,
because the derivative

00:04:02.910 --> 00:04:03.980
is jumping at that point.

00:04:03.980 --> 00:04:05.730
I'm not going to draw
the derivative here,

00:04:05.730 --> 00:04:07.854
it's a little harder to
draw, but you could draw it

00:04:07.854 --> 00:04:10.500
with the same x-axis,
and you'd see a jump

00:04:10.500 --> 00:04:13.460
from one angle to another.

00:04:13.460 --> 00:04:17.560
This point is not even c zero.

00:04:17.560 --> 00:04:22.480
This point is c
zero, but not c1.

00:04:22.480 --> 00:04:29.500
This point is c1, because
the tangent here is equal,

00:04:29.500 --> 00:04:31.590
on the left, is equal to
the tangent on the right,

00:04:31.590 --> 00:04:33.510
if I drew this
properly, where this

00:04:33.510 --> 00:04:36.400
is the bottom of the parabola.

00:04:36.400 --> 00:04:38.990
You can ask for more than
c1, and we do in class,

00:04:38.990 --> 00:04:42.200
we talk about c2,
and this says you

00:04:42.200 --> 00:04:47.230
should have a continuous
second derivative.

00:04:47.230 --> 00:04:48.840
So acceleration.

00:04:48.840 --> 00:04:53.156
And this point, for
example, is not c2.

00:04:53.156 --> 00:04:54.780
Because while the
tangents meet, if you

00:04:54.780 --> 00:04:58.020
take the next derivative, you
see that it's suddenly-- here

00:04:58.020 --> 00:04:59.630
the tangent was
completely flat, it

00:04:59.630 --> 00:05:02.010
has a second derivative of
zero, and then suddenly it

00:05:02.010 --> 00:05:03.580
starts increasing.

00:05:03.580 --> 00:05:06.430
Now you can design functions
that are even C infinity.

00:05:06.430 --> 00:05:08.610
C infinity means no matter
how many derivatives

00:05:08.610 --> 00:05:12.320
you take, it's continuous
and defined, no jumps.

00:05:12.320 --> 00:05:15.080
But if you do a
parabola, for example,

00:05:15.080 --> 00:05:19.670
it will not be so
well-behaved, I think, yes.

00:05:22.900 --> 00:05:26.350
Got the x, y equals x squared,
you take the derivative,

00:05:26.350 --> 00:05:33.240
you get 2x, take the derivative
of that, you get 2, and then

00:05:33.240 --> 00:05:35.140
the derivative of
that, you get zero.

00:05:37.680 --> 00:05:44.024
So the second derivative here
is 2, all along the curve.

00:05:44.024 --> 00:05:46.422
So I guess y prime,
y double prime.

00:05:46.422 --> 00:05:48.880
So, in particular here, we had
a second derivative of zero,

00:05:48.880 --> 00:05:52.090
here we have a second
derivative of 2.

00:05:52.090 --> 00:05:54.470
All right, so that's
a quick crash course

00:05:54.470 --> 00:05:59.350
on individual points
being c zero or c1 or c2,

00:05:59.350 --> 00:06:03.340
or C infinity is when
you can go all the way.

00:06:03.340 --> 00:06:08.210
Creases are points on the
paper where you're not c1.

00:06:08.210 --> 00:06:11.320
That means that you have
two different tangent

00:06:11.320 --> 00:06:14.340
plans coming
together, typically.

00:06:14.340 --> 00:06:16.250
So discontinuity is in
the first derivative,

00:06:16.250 --> 00:06:18.320
that's what we call creases.

00:06:18.320 --> 00:06:24.770
Semi-creases are discontinuities
in the second derivative

00:06:24.770 --> 00:06:32.970
So semi-crease is
where you're not c2,

00:06:32.970 --> 00:06:37.870
crease is where you're
not c1, according

00:06:37.870 --> 00:06:39.680
to this particular paper.

00:06:39.680 --> 00:06:41.430
Semi-crease is not
too common a term,

00:06:41.430 --> 00:06:44.430
but crease is very comm-- this
is the usual meaning of crease,

00:06:44.430 --> 00:06:47.340
semi-crease is maybe a little
new to this paper we're talking

00:06:47.340 --> 00:06:50.060
about, nonexistence of pi parse.

00:06:50.060 --> 00:06:55.757
And so, for example,
this would be a crease,

00:06:55.757 --> 00:06:57.090
and this would be a semi-crease.

00:07:01.630 --> 00:07:03.920
Here the derivative changes,
that looks like a crease,

00:07:03.920 --> 00:07:06.120
if you had a one-dimensional
piece of paper.

00:07:06.120 --> 00:07:08.570
This doesn't look like a
crease, it's kind of smooth,

00:07:08.570 --> 00:07:11.250
but not-- it's a little
bit smooth, it's c1,

00:07:11.250 --> 00:07:12.180
but it's not c2.

00:07:12.180 --> 00:07:14.420
So there's a semi-crease there.

00:07:14.420 --> 00:07:17.310
And part of that paper is sort
of worrying about semi-creases,

00:07:17.310 --> 00:07:19.570
because we want to
deal with c2 parts,

00:07:19.570 --> 00:07:22.692
because c2 functions are nice.

00:07:22.692 --> 00:07:24.400
I mean, ideally we
have C infinity parts,

00:07:24.400 --> 00:07:26.690
but we only need
c2 parts, and so

00:07:26.690 --> 00:07:28.170
we subdivide at
the semi-creases.

00:07:28.170 --> 00:07:30.670
And basically, argue most the
time semi-creases don't really

00:07:30.670 --> 00:07:32.586
happen, so you don't
have to worry about them.

00:07:32.586 --> 00:07:34.860
But that's what they are.

00:07:34.860 --> 00:07:36.490
Any questions about smoothness?

00:07:36.490 --> 00:07:39.366
These are all different
kinds of smoothness.

00:07:39.366 --> 00:07:40.830
Yeah.

00:07:40.830 --> 00:07:43.270
AUDIENCE: [INAUDIBLE].

00:07:43.270 --> 00:07:47.480
PROFESSOR: All of these
things are C infinity,

00:07:47.480 --> 00:07:49.770
except at these points.

00:07:49.770 --> 00:07:52.260
So every polynomial C infinity,
you can differentiate it

00:07:52.260 --> 00:07:56.100
all the time,
eventually get to zero.

00:07:56.100 --> 00:07:58.080
Exponentials are
C infinity, pretty

00:07:58.080 --> 00:08:00.535
much all functions you can
think of that are smooth

00:08:00.535 --> 00:08:01.425
are C infinity.

00:08:04.070 --> 00:08:04.570
Yeah.

00:08:08.080 --> 00:08:12.180
All right, so next
question is about one

00:08:12.180 --> 00:08:19.560
of the proofs, which was that--
the proof involving normals

00:08:19.560 --> 00:08:21.870
basically, the one
involving tangent planes,

00:08:21.870 --> 00:08:23.560
and the other one is
involving normals.

00:08:23.560 --> 00:08:26.840
This is the polygonal
implies flat proof,

00:08:26.840 --> 00:08:29.570
so this was, If you
have a region of paper

00:08:29.570 --> 00:08:31.980
that is bounded by
polygonal creases,

00:08:31.980 --> 00:08:37.010
so they're piecewise straight,
then that region of paper,

00:08:37.010 --> 00:08:40.360
if it's uncreased,
must actually be flat.

00:08:40.360 --> 00:08:42.145
And I'm just going
to, I want to talk

00:08:42.145 --> 00:08:43.520
about just one
part of the proof.

00:08:43.520 --> 00:08:45.790
So there was a
sequence of steps,

00:08:45.790 --> 00:08:49.470
but ultimately what we
wanted was some segment, bf.

00:08:49.470 --> 00:08:54.100
This is a boundary of your
region, somewhere over here,

00:08:54.100 --> 00:08:56.690
and we assume that
it's straight.

00:08:56.690 --> 00:08:59.970
So, we took a few
steps to get here.

00:08:59.970 --> 00:09:02.970
But suppose we have a
straight region and locally,

00:09:02.970 --> 00:09:06.700
around this point,
there's some ruling.

00:09:06.700 --> 00:09:11.250
And then we're looking
at a point, Q, here.

00:09:11.250 --> 00:09:16.162
I'm going to define this
ruling to be r of q.

00:09:16.162 --> 00:09:21.015
The rule line from q, and
so q is an arbitrary point,

00:09:21.015 --> 00:09:23.310
it slides along this segment.

00:09:23.310 --> 00:09:25.580
And then we're interested
in a normal vector

00:09:25.580 --> 00:09:29.020
here, which we called n of q.

00:09:29.020 --> 00:09:32.200
That's normal to the
surface at this point,

00:09:32.200 --> 00:09:35.230
and so as q slides,
n of q changes.

00:09:35.230 --> 00:09:37.810
And we were claiming
a few things,

00:09:37.810 --> 00:09:41.630
but so the definition
of this guy being normal

00:09:41.630 --> 00:09:45.602
is it has to be perpendicular
to-- normal to the surface is

00:09:45.602 --> 00:09:46.810
perpendicular to the surface.

00:09:46.810 --> 00:09:49.470
It has to be perpendicular
to this axis of the surface,

00:09:49.470 --> 00:09:51.760
and it has to be
perpendicular to this axis.

00:09:51.760 --> 00:09:54.620
So we know, just from
definition of normal, n of q

00:09:54.620 --> 00:10:00.300
is perpendicular
to bf, and n of q

00:10:00.300 --> 00:10:06.890
is perpendicular to r
of q, the rule line.

00:10:06.890 --> 00:10:09.900
So that's the definition but
it wasn't quite what we wanted.

00:10:09.900 --> 00:10:13.770
We wanted to prove, for
example, that the derivative

00:10:13.770 --> 00:10:19.130
of the normal, funny thing,
is perpendicular to bf.

00:10:19.130 --> 00:10:20.980
That was one of the
things we wanted,

00:10:20.980 --> 00:10:24.770
and the other one was the
corresponding perpendicular

00:10:24.770 --> 00:10:25.810
to the rule line.

00:10:25.810 --> 00:10:27.810
I don't know if I used
this notation in lecture,

00:10:27.810 --> 00:10:29.768
but this just means that
they're perpendicular,

00:10:29.768 --> 00:10:33.260
which is like the dot product
of those two vectors is zero.

00:10:33.260 --> 00:10:36.810
So, how do we go
from here to here?

00:10:36.810 --> 00:10:39.260
This was actually the part
that was most confusing to me.

00:10:39.260 --> 00:10:42.620
I find this one more confusing,
because it uses the fact

00:10:42.620 --> 00:10:44.819
that it's [INAUDIBLE],
but the question

00:10:44.819 --> 00:10:47.360
was actually about this one, so
unless you ask about this one

00:10:47.360 --> 00:10:48.740
now, I'll just cover this one.

00:10:48.740 --> 00:10:49.700
It's a little simpler.

00:10:49.700 --> 00:10:51.630
Both are in the notes.

00:10:51.630 --> 00:10:54.630
So why is this true?

00:10:54.630 --> 00:10:56.810
I guess, first, the
intuitive reason.

00:10:56.810 --> 00:10:59.297
So, you've got all these
different normals here.

00:10:59.297 --> 00:11:01.130
We're going to end up
concluding they're all

00:11:01.130 --> 00:11:03.180
pointed the same
way but, in general,

00:11:03.180 --> 00:11:07.380
they're changing
direction somehow.

00:11:07.380 --> 00:11:09.760
We know that at all
times the normal

00:11:09.760 --> 00:11:11.780
is perpendicular
to this segment,

00:11:11.780 --> 00:11:15.180
so it is pointing away,
straight away from the segments.

00:11:15.180 --> 00:11:18.189
So you've got a
right angle here.

00:11:18.189 --> 00:11:19.980
So it's kind of spinning
around the segment

00:11:19.980 --> 00:11:23.720
at best, as it moves around.

00:11:23.720 --> 00:11:27.410
We claim that the change in
the normal, the derivative

00:11:27.410 --> 00:11:30.280
of the normal, as you
walk along this segment,

00:11:30.280 --> 00:11:32.400
must also be perpendicular
to the segment.

00:11:32.400 --> 00:11:38.020
Intuitively, this is obvious,
if you think about it enough.

00:11:38.020 --> 00:11:40.520
If you were changing in
a direction that was not

00:11:40.520 --> 00:11:42.940
perpendicular to normal, to
this segment, for example

00:11:42.940 --> 00:11:44.870
you're going this
way or something,

00:11:44.870 --> 00:11:47.220
then, while initially
you're perpendicular,

00:11:47.220 --> 00:11:49.140
you're kind of falling
over, and then you'll

00:11:49.140 --> 00:11:50.470
no longer be perpendicular.

00:11:50.470 --> 00:11:52.010
So if you change
in a first order

00:11:52.010 --> 00:11:54.110
way that is not
perpendicular to this thing,

00:11:54.110 --> 00:11:56.400
then afterwards you will
no longer be perpendicular.

00:11:56.400 --> 00:12:00.410
So that's intuitively why
this follows from this.

00:12:03.250 --> 00:12:06.020
One way to formalize that
is to use Taylor expansion,

00:12:06.020 --> 00:12:08.630
so I'll just write that quickly.

00:12:08.630 --> 00:12:10.690
If you look at a
point, q, and I'm

00:12:10.690 --> 00:12:12.630
going to use this
notation, q plus epsilon,

00:12:12.630 --> 00:12:14.960
to mean a point just
a little bit over.

00:12:14.960 --> 00:12:17.490
This is q plus
epsilon, this is q.

00:12:20.330 --> 00:12:23.140
For a very small epsilon, this
is going to be approximately n

00:12:23.140 --> 00:12:26.670
of q, plus epsilon,
and the prime of q.

00:12:29.990 --> 00:12:32.690
In Taylor expansion, then
you have epsilon squared,

00:12:32.690 --> 00:12:35.950
but for small enough epsilon,
this is a good approximation.

00:12:35.950 --> 00:12:45.700
And so, on the one
hand, you have--

00:12:45.700 --> 00:12:47.810
If you look at n
of q plus epsilon,

00:12:47.810 --> 00:12:49.286
and you compare
it to bf, you know

00:12:49.286 --> 00:12:51.660
that these are perpendicular,
and what you can write that

00:12:51.660 --> 00:12:54.070
as a product being
equal to zero.

00:12:54.070 --> 00:12:55.730
So the dot product
of these two vectors

00:12:55.730 --> 00:12:58.097
should be equal to zero,
that is, being perpendicular.

00:12:58.097 --> 00:12:59.680
We know this is true
for all points q,

00:12:59.680 --> 00:13:02.390
so in particular, it's going
to be true for q plus epsilon.

00:13:02.390 --> 00:13:05.730
So that's what we know, but
now we can expand this thing,

00:13:05.730 --> 00:13:07.650
and we get these two terms.

00:13:07.650 --> 00:13:17.820
So we get n of q dot bf, plus
epsilon and prime of q, dot bf.

00:13:17.820 --> 00:13:21.720
That's just distributing
that sum over this product,

00:13:21.720 --> 00:13:23.910
dot products work OK that way.

00:13:23.910 --> 00:13:27.250
Now this thing is also
zero, because this

00:13:27.250 --> 00:13:29.204
is just another point
q dotted with bf,

00:13:29.204 --> 00:13:30.870
and they should always
be perpendicular.

00:13:30.870 --> 00:13:33.640
And this is the
thing we care about.

00:13:33.640 --> 00:13:35.560
Now if this whole
sum is equal to zero,

00:13:35.560 --> 00:13:37.770
and this term is equal
to zero, then this better

00:13:37.770 --> 00:13:38.870
be equal to zero.

00:13:38.870 --> 00:13:41.740
So implies this
thing equals zero,

00:13:41.740 --> 00:13:43.140
and that's what we wanted.

00:13:43.140 --> 00:13:45.040
And prime of q is
perpendicular to bf.

00:13:45.040 --> 00:13:47.840
So that's the algebra
way to see it.

00:13:47.840 --> 00:13:50.220
But if you think about it
enough, and you believe things

00:13:50.220 --> 00:13:52.730
are linear to the
first order, as we say,

00:13:52.730 --> 00:13:55.657
than that has to be true.

00:13:55.657 --> 00:13:57.740
You can get second derivatives
and things as well,

00:13:57.740 --> 00:14:01.370
but first derivative
better hold in, particular.

00:14:01.370 --> 00:14:04.696
Any questions about that?

00:14:04.696 --> 00:14:06.570
You can do the same
thing with this property,

00:14:06.570 --> 00:14:07.382
but it's messier.

00:14:07.382 --> 00:14:09.340
You need to use the
[INAUDIBLE] property, which

00:14:09.340 --> 00:14:11.310
we didn't really go
into much detail on,

00:14:11.310 --> 00:14:13.670
so I think I'll skip it.

00:14:16.540 --> 00:14:20.615
Last question is,
what does it all mean?

00:14:20.615 --> 00:14:22.240
If we're proving
things are impossible,

00:14:22.240 --> 00:14:26.150
and yet here I have physical
models of them existing,

00:14:26.150 --> 00:14:26.920
what's going on?

00:14:26.920 --> 00:14:28.920
What's the difference
between mathematical paper

00:14:28.920 --> 00:14:29.940
and real paper?

00:14:29.940 --> 00:14:33.300
And, of course, there's no
real mathematical answer

00:14:33.300 --> 00:14:36.540
to that question, but there--
we have a couple competing

00:14:36.540 --> 00:14:40.450
theories for what might be
happening in this model.

00:14:40.450 --> 00:14:45.080
One is that perhaps the
paper is not being isometric.

00:14:45.080 --> 00:14:47.660
Perhaps it's
stretching or shearing.

00:14:47.660 --> 00:14:53.590
So normally we think of paper
as unstretchable and not

00:14:53.590 --> 00:14:57.630
shearable, the only way
to shear is to fold it.

00:14:57.630 --> 00:15:00.890
And that is almost perfectly
true but, of course,

00:15:00.890 --> 00:15:01.990
no material is perfect.

00:15:01.990 --> 00:15:05.370
So it might be
shearing or changing

00:15:05.370 --> 00:15:08.460
the geometry, the intrinsic
geometry just enough

00:15:08.460 --> 00:15:10.822
to somehow make this possible.

00:15:10.822 --> 00:15:12.530
Our theory only says
that it's impossible

00:15:12.530 --> 00:15:15.050
if you're exactly
perfect, so maybe-- it

00:15:15.050 --> 00:15:17.960
would be interesting to
measure how exact paper is.

00:15:17.960 --> 00:15:18.830
Question?

00:15:18.830 --> 00:15:21.770
AUDIENCE: If it's possible
to imitate a shear,

00:15:21.770 --> 00:15:26.019
if it compresses the paper
but I fold it, then--

00:15:26.019 --> 00:15:27.310
PROFESSOR: This is not a shear.

00:15:27.310 --> 00:15:29.046
AUDIENCE: I know, but
if you can fold it,

00:15:29.046 --> 00:15:30.760
so that it, like,
imitates a shear--

00:15:30.760 --> 00:15:32.910
PROFESSOR: Well, you can
add creases to make it,

00:15:32.910 --> 00:15:34.374
to simulate a shear.

00:15:34.374 --> 00:15:35.040
AUDIENCE: Right.

00:15:35.040 --> 00:15:36.623
PROFESSOR: But only
by adding creases,

00:15:36.623 --> 00:15:38.820
that's what we
proved in lecture.

00:15:38.820 --> 00:15:41.370
So yeah, you can kind of
fake a shear, but only

00:15:41.370 --> 00:15:42.120
by adding creases.

00:15:42.120 --> 00:15:44.390
Now, it doesn't look like
there's extra creases here.

00:15:44.390 --> 00:15:46.040
Theory number 2
is there are lots

00:15:46.040 --> 00:15:48.860
of really tiny creases
here that are so small.

00:15:48.860 --> 00:15:50.780
I mean, here you could
detect the crease,

00:15:50.780 --> 00:15:53.170
because it was a
big change in angle,

00:15:53.170 --> 00:15:54.732
but if they're super,
super tiny here

00:15:54.732 --> 00:15:57.070
and, you know, we never
fold these things completely

00:15:57.070 --> 00:16:00.205
perfect, it could be lots
of little tiny things,

00:16:00.205 --> 00:16:01.580
maybe you look
under a microscope

00:16:01.580 --> 00:16:03.380
and you'll see
that, I don't know.

00:16:03.380 --> 00:16:04.796
It could be an
interesting project

00:16:04.796 --> 00:16:07.750
to try to investigate what
really happens with paper

00:16:07.750 --> 00:16:10.600
in these kinds of
models in real life,

00:16:10.600 --> 00:16:13.000
and how it differs
from mathematics.

00:16:13.000 --> 00:16:17.370
But the two theories are
maybe some stretching or maybe

00:16:17.370 --> 00:16:18.220
extra creases.

00:16:18.220 --> 00:16:21.550
We know by adding the
diagonals, it folds.

00:16:21.550 --> 00:16:23.080
Now here, you could
pretty clearly

00:16:23.080 --> 00:16:25.090
see the diagonals
are not being added,

00:16:25.090 --> 00:16:27.880
but there might be-- there
might be effectively,

00:16:27.880 --> 00:16:31.650
there might be enough added
creases that are together

00:16:31.650 --> 00:16:34.186
so tiny, you can't see them.

00:16:34.186 --> 00:16:36.630
AUDIENCE: It's
not semi-creases--

00:16:36.630 --> 00:16:39.210
PROFESSOR: Semi-creases
are not enough.

00:16:39.210 --> 00:16:42.740
The theory says that if you
have these creases and possibly

00:16:42.740 --> 00:16:46.110
any number of semi-creases,
you can't fold it all.

00:16:46.110 --> 00:16:48.550
So you need to add
actual creases.

00:16:48.550 --> 00:16:51.640
Yeah, good question.

00:16:51.640 --> 00:16:57.050
All right, that's
it for old material.

00:16:57.050 --> 00:16:59.950
Now I wanted to show you
some cool new material,

00:16:59.950 --> 00:17:02.474
which is based on--

00:17:02.474 --> 00:17:03.430
AUDIENCE: [INAUDIBLE].

00:17:03.430 --> 00:17:04.513
PROFESSOR: Yeah, question?

00:17:04.513 --> 00:17:06.298
AUDIENCE: [INAUDIBLE]
don't really

00:17:06.298 --> 00:17:08.192
look like straight lines.

00:17:08.192 --> 00:17:08.900
PROFESSOR: Right.

00:17:08.900 --> 00:17:10.720
The creases here do not
look like straight lines,

00:17:10.720 --> 00:17:12.690
and yet we prove they
must be straight lines,

00:17:12.690 --> 00:17:14.900
so something's going on.

00:17:14.900 --> 00:17:17.630
Now, we didn't know initially
that straight creases had

00:17:17.630 --> 00:17:19.589
to stay straight
in 3D, but once we

00:17:19.589 --> 00:17:23.172
proved that, we were pretty
sure this didn't exist.

00:17:23.172 --> 00:17:25.380
It's not obvious that straight
creases stay straight,

00:17:25.380 --> 00:17:27.803
but they do.

00:17:27.803 --> 00:17:31.130
It's evidence there's a problem.

00:17:31.130 --> 00:17:32.922
OK, I wanted to talk
about this paper,

00:17:32.922 --> 00:17:34.130
because it's kind of related.

00:17:34.130 --> 00:17:38.550
It's about how to efficiently
make pleat folding happen,

00:17:38.550 --> 00:17:42.050
and it's written by a bunch of
people, Jean Cardinal, Marty,

00:17:42.050 --> 00:17:47.900
our cameraman, Shinji Imahori,
Yoshi Ito, Messashi Kiomi,

00:17:47.900 --> 00:17:50.240
Stefan Langerman,
Ryuhei Uehara, who's

00:17:50.240 --> 00:17:54.440
here on sabbatical,
and Tachiachi Uno.

00:17:54.440 --> 00:17:56.510
Good practice.

00:17:56.510 --> 00:17:59.940
So, here's the kind of setting.

00:17:59.940 --> 00:18:02.390
It's going to be
familiar, in that we

00:18:02.390 --> 00:18:07.130
have a one-D piece of
paper, so it's a segment,

00:18:07.130 --> 00:18:10.040
and we're also going to assume
that it's uniformly creased,

00:18:10.040 --> 00:18:13.890
so each of these
is spacing of 1.

00:18:13.890 --> 00:18:18.000
And now usually we think
of preassigning mountains

00:18:18.000 --> 00:18:20.340
and valleys here, and then
you could only fold mountains

00:18:20.340 --> 00:18:23.390
on the mountains, you can only
fold valleys in the valleys.

00:18:23.390 --> 00:18:25.040
The model here is
that you're allowed

00:18:25.040 --> 00:18:29.020
to fold and unfold repeatedly
on the same segments.

00:18:29.020 --> 00:18:33.510
So you can do some
layers, simple folds,

00:18:33.510 --> 00:18:37.250
although, I think, we'll just
need all layers here today.

00:18:40.510 --> 00:18:45.340
But you can also unfold
any previous folds.

00:18:50.780 --> 00:18:54.599
And I'll say that
unfolds are free,

00:18:54.599 --> 00:18:56.390
you don't pay for the
unfolding operations,

00:18:56.390 --> 00:18:58.220
because it's just
a constant factor.

00:18:58.220 --> 00:19:00.720
You can only unfold things that
have previously been folded.

00:19:00.720 --> 00:19:02.762
So we'll count the
number of folds you make.

00:19:02.762 --> 00:19:04.970
Each time you do a fold,
it's a mountain or a valley,

00:19:04.970 --> 00:19:07.680
say, through all the layers
and through some of the layers.

00:19:07.680 --> 00:19:11.660
But our goal is in, the end,
to have our segment creased

00:19:11.660 --> 00:19:12.880
in a particular pattern.

00:19:12.880 --> 00:19:17.900
And the pleat pattern
would be mv, mv, mv.

00:19:17.900 --> 00:19:20.960
So we want the last time
each crease to be folded,

00:19:20.960 --> 00:19:23.290
to be a particular
pattern, but along the way

00:19:23.290 --> 00:19:26.840
we could fold it in
lots of-- it could be,

00:19:26.840 --> 00:19:29.510
this one could be mountain for a
while, as long as the last time

00:19:29.510 --> 00:19:33.570
we crease this thing, it's
a valley, we're happy.

00:19:33.570 --> 00:19:37.650
So we end up with
mountain valley strings,

00:19:37.650 --> 00:19:41.540
and we want to know
how many folds,

00:19:41.540 --> 00:19:44.110
how many folding operations
do you need to make,

00:19:44.110 --> 00:19:47.640
in order to achieve a particular
mountain valley string?

00:19:52.950 --> 00:19:56.370
And, in particular, we care
about strings like mv mv mv,

00:19:56.370 --> 00:19:59.990
because, as we'll learn later
today when we fold these,

00:19:59.990 --> 00:20:02.530
pleating takes a lot
of time, it's tedious.

00:20:02.530 --> 00:20:04.660
It would be nice if you
could do things faster.

00:20:04.660 --> 00:20:07.600
Now, why do we think we
can do things faster?

00:20:07.600 --> 00:20:11.840
Because I can take a piece
of paper and, imagine this

00:20:11.840 --> 00:20:14.780
is one-dimensional,
and fold it in half,

00:20:14.780 --> 00:20:16.890
and then fold it in half again.

00:20:16.890 --> 00:20:19.020
Boom, I got how many creases?

00:20:19.020 --> 00:20:21.700
Two creases for the
price of one operation.

00:20:21.700 --> 00:20:23.530
Now I fold again, Boom!

00:20:23.530 --> 00:20:25.710
I get four creases
for the price of one.

00:20:25.710 --> 00:20:27.180
I fold it again.

00:20:27.180 --> 00:20:29.700
Wow, I get eight creases
for the price of one.

00:20:29.700 --> 00:20:32.620
So the number of folding
operations you do here

00:20:32.620 --> 00:20:35.260
may be much, much
smaller than n.

00:20:35.260 --> 00:20:38.970
n is going to be the
number of the creases,

00:20:38.970 --> 00:20:42.150
the length of your string.

00:20:42.150 --> 00:20:44.530
So if I fold a piece
of paper like this--

00:20:44.530 --> 00:20:46.600
I actually tried
this-- and then I

00:20:46.600 --> 00:20:48.970
unfold to see what
mountain valley assignment

00:20:48.970 --> 00:20:55.060
I got-- unfolding is free--
I get this weird shape.

00:20:55.060 --> 00:20:56.390
And I didn't do it perfectly.

00:20:56.390 --> 00:20:58.947
It's hard to do perfectly
because of creep.

00:20:58.947 --> 00:20:59.780
I get a weird thing.

00:20:59.780 --> 00:21:03.580
Anyone know what
this thing is called?

00:21:03.580 --> 00:21:06.917
I think that's pretty much--
if I unfold them to 90 degrees.

00:21:06.917 --> 00:21:07.875
AUDIENCE: Dragon curve.

00:21:07.875 --> 00:21:08.875
PROFESSOR: Dragon curve.

00:21:08.875 --> 00:21:09.700
Yeah.

00:21:09.700 --> 00:21:11.880
Dragon curve looks like this.

00:21:11.880 --> 00:21:15.110
This is the Wikipedia
drawing, and the more

00:21:15.110 --> 00:21:18.210
you fold in half, that you
keep adding this iteration,

00:21:18.210 --> 00:21:20.690
it's a nice fractal.

00:21:20.690 --> 00:21:22.190
It's kind of cool,
it doesn't have--

00:21:22.190 --> 00:21:23.860
you can prove it
doesn't self intersect.

00:21:23.860 --> 00:21:27.250
It touches itself at vertices,
but it doesn't properly

00:21:27.250 --> 00:21:28.541
cross itself.

00:21:28.541 --> 00:21:30.540
You take the limit, it
looks something like this

00:21:30.540 --> 00:21:32.930
if you fill it in, very cool.

00:21:32.930 --> 00:21:36.190
Wikipedia calls it the, I don't
want to spoil the surprise,

00:21:36.190 --> 00:21:40.660
but there's actually a book
where the section headings are

00:21:40.660 --> 00:21:41.800
iterations of this fractal?

00:21:41.800 --> 00:21:43.050
Anyone know what this book is?

00:21:43.050 --> 00:21:44.050
AUDIENCE: Jurassic Park.

00:21:44.050 --> 00:21:48.370
PROFESSOR: Jurassic Park,
yes, Ian Malcolm right there.

00:21:48.370 --> 00:21:49.820
So, pretty cool.

00:21:49.820 --> 00:21:52.153
It's called the Jurassic Park
fractal, to some, at least

00:21:52.153 --> 00:21:54.650
on Wikipedia.

00:21:54.650 --> 00:21:57.780
And so that's one particular
mountain valley assignment

00:21:57.780 --> 00:21:58.510
you can get.

00:21:58.510 --> 00:22:00.910
And let me tell you what is.

00:22:03.610 --> 00:22:06.554
It's pretty easy to figure out,
and you see why it's a fractal.

00:22:06.554 --> 00:22:07.970
So the first time
we make a fold--

00:22:07.970 --> 00:22:10.390
let's say I always make
mountains, just for simplicity.

00:22:10.390 --> 00:22:14.567
You have a little bit of
choice here, but not very much.

00:22:14.567 --> 00:22:16.400
So first I make a
mountain fold, so now I've

00:22:16.400 --> 00:22:17.700
got things folded in half.

00:22:17.700 --> 00:22:19.840
Now let's say I make a
mountain fold over here.

00:22:19.840 --> 00:22:21.465
Of course, it's
already folded in half,

00:22:21.465 --> 00:22:23.370
which means I get
a valley over here.

00:22:23.370 --> 00:22:26.370
So I'm going to-- Yeah.

00:22:26.370 --> 00:22:31.275
So now I make another
mountain fold, maybe

00:22:31.275 --> 00:22:34.430
I should have done it the
other way, anyway, so it is.

00:22:34.430 --> 00:22:38.310
So I make another mountain
fold here, and on the left

00:22:38.310 --> 00:22:42.090
I get this, on the right I
get the reflection of that.

00:22:42.090 --> 00:22:43.855
And then I make
another mountain fold,

00:22:43.855 --> 00:22:45.534
and I get this on
the left, and I

00:22:45.534 --> 00:22:47.200
get the reflection
of that on the right.

00:22:47.200 --> 00:22:49.730
And when I reflect, I'm reading
backwards and also inverting

00:22:49.730 --> 00:22:50.230
everything.

00:22:55.780 --> 00:22:57.260
vv and so on.

00:22:57.260 --> 00:22:59.870
So you see the kind of
fractal nature here,

00:22:59.870 --> 00:23:03.090
and that's what
gives the cool curve.

00:23:03.090 --> 00:23:04.810
Keep repeating that.

00:23:04.810 --> 00:23:06.750
You have, essentially,
n choices,

00:23:06.750 --> 00:23:08.532
because they're log n
folds that you make,

00:23:08.532 --> 00:23:09.990
each could be a
mountain or valley.

00:23:09.990 --> 00:23:13.060
So there are n
different mv strings

00:23:13.060 --> 00:23:19.720
you can get in
essentially log n folds.

00:23:19.720 --> 00:23:22.000
But sadly, none
of them is the one

00:23:22.000 --> 00:23:25.490
we want, mvmvmv, the pleat fold.

00:23:25.490 --> 00:23:28.405
So that leaves us with the
question of how many operations

00:23:28.405 --> 00:23:30.300
do you need to get a pleat fold?

00:23:36.570 --> 00:23:38.790
This is where things get cool.

00:23:38.790 --> 00:23:46.270
So-- why don't I tell
you some answers.

00:23:46.270 --> 00:23:51.880
So if you want to
fold mmmm, or mvmv,

00:23:51.880 --> 00:23:53.630
these turn out to be
the same, because you

00:23:53.630 --> 00:23:57.610
can do m's on the odd positions,
v's on the even positions.

00:23:57.610 --> 00:24:02.390
Then you can do it in
log squared n folds,

00:24:02.390 --> 00:24:08.050
and you need at least log
squared n over log, log n.

00:24:08.050 --> 00:24:10.590
This is way, way faster than n.

00:24:10.590 --> 00:24:12.090
There's an open
problem between log

00:24:12.090 --> 00:24:13.506
squared n and log
squared over log

00:24:13.506 --> 00:24:16.320
log, small gap of
the log log factor.

00:24:16.320 --> 00:24:19.150
But somewhere in between here.

00:24:19.150 --> 00:24:27.470
If you want to do, let's say,
a random pattern, then we

00:24:27.470 --> 00:24:38.810
can prove you need about
n divided by log n.

00:24:38.810 --> 00:24:42.800
So the obvious way to do it
is fold each crease unfolds,

00:24:42.800 --> 00:24:44.230
that takes n steps.

00:24:44.230 --> 00:24:46.600
So you can always
improve by a log factor,

00:24:46.600 --> 00:24:49.290
and that's the best you
could do for most strings.

00:24:49.290 --> 00:24:51.630
But these strings are
sufficiently special,

00:24:51.630 --> 00:24:54.920
that you can get a huge factor,
basically exponential, when,

00:24:54.920 --> 00:24:56.620
instead of doing
roughly n steps,

00:24:56.620 --> 00:24:59.290
you're only doing
poly log steps.

00:24:59.290 --> 00:25:02.050
So, there's four results here.

00:25:02.050 --> 00:25:04.100
Which ones would
you like to see?

00:25:04.100 --> 00:25:06.690
How many people vote for
log squared n upper bound?

00:25:09.290 --> 00:25:09.790
Four.

00:25:09.790 --> 00:25:12.120
How many people vote for
log squared over log log

00:25:12.120 --> 00:25:13.750
lower bound?

00:25:13.750 --> 00:25:15.840
Completely different
set of four.

00:25:15.840 --> 00:25:19.010
How many people vote for the
n over log n story, upper

00:25:19.010 --> 00:25:22.461
bound first and lower bound?

00:25:22.461 --> 00:25:22.960
OK.

00:25:22.960 --> 00:25:26.250
I think the upper bound
here wins, just curious.

00:25:26.250 --> 00:25:29.447
They all these similar ideas.

00:25:29.447 --> 00:25:31.030
I'm going to briefly
sketch, because I

00:25:31.030 --> 00:25:36.170
want to get to folding stuff,
how you achieve n over log n

00:25:36.170 --> 00:25:39.090
upper bound, maybe then I'll do
log squared upper bound here.

00:25:39.090 --> 00:25:45.630
Lower bounds are,
well, they're bounds.

00:25:45.630 --> 00:25:47.830
That doesn't say anything.

00:25:47.830 --> 00:25:52.580
So, if you have an mv string,
to get this bound, arbitrary

00:25:52.580 --> 00:25:58.840
string, I'm going to
consider epsilon-- sorry,

00:25:58.840 --> 00:26:04.250
1 minus epsilon log n,
consecutive letters,

00:26:04.250 --> 00:26:11.340
and split into, basically, n
over log n chunks, each of size

00:26:11.340 --> 00:26:15.760
roughly log n, a little
bit smaller than log n.

00:26:15.760 --> 00:26:17.000
Why do I do that?

00:26:17.000 --> 00:26:20.270
Because the number of
different chunk values

00:26:20.270 --> 00:26:23.890
is 2 to the 1 minus
epsilon, times log n, right,

00:26:23.890 --> 00:26:27.280
each can be mountain or valley.

00:26:27.280 --> 00:26:31.090
Now 2 the log n is n, so
this is n to the 1 minus

00:26:31.090 --> 00:26:34.945
epsilon, possible
different chunk values.

00:26:42.010 --> 00:26:43.940
These are chunks.

00:26:43.940 --> 00:26:45.520
Why is that interesting?

00:26:45.520 --> 00:26:48.525
Because I have basically
n over log n chunks,

00:26:48.525 --> 00:26:50.900
but there's only n to the 1
minus epsilon different chunk

00:26:50.900 --> 00:26:51.400
values.

00:26:51.400 --> 00:26:53.840
This is much, much
smaller than this.

00:26:53.840 --> 00:26:56.460
Think of epsilon being a half,
as the square root of n, this

00:26:56.460 --> 00:26:57.940
is n over log n.

00:26:57.940 --> 00:27:02.410
So there's actually most-- many
the chunks have to be repeated.

00:27:02.410 --> 00:27:13.950
So this means that an average
chunk is repeated, What is it?

00:27:13.950 --> 00:27:19.620
It's n over log n of
them, is n over log n,

00:27:19.620 --> 00:27:23.100
times n to the 1
minus epsilon times,

00:27:23.100 --> 00:27:26.220
which is n to the
epsilon over log n.

00:27:29.840 --> 00:27:32.060
This is the number
of chunks here,

00:27:32.060 --> 00:27:36.030
and we're dividing by the
number of different ones,

00:27:36.030 --> 00:27:37.844
so typical repetition
is going to be

00:27:37.844 --> 00:27:39.260
n to the epsilon
over log n times.

00:27:39.260 --> 00:27:41.689
I'll just assume all chunks
are repeated this many times.

00:27:41.689 --> 00:27:43.230
It's all linear, so
it doesn't matter

00:27:43.230 --> 00:27:47.490
whether some are more common
and some are less common.

00:27:47.490 --> 00:27:51.601
OK, cool.

00:27:51.601 --> 00:27:52.100
Now what?

00:27:55.780 --> 00:28:01.435
So, if I look at one of
these chunks and all of it

00:28:01.435 --> 00:28:03.950
is repetitions, I would like
to fold them all somehow

00:28:03.950 --> 00:28:06.160
more efficiently.

00:28:06.160 --> 00:28:08.710
And there's one key
idea in this paper

00:28:08.710 --> 00:28:17.710
on how to do that, which is--
so here's my strip, maybe here's

00:28:17.710 --> 00:28:20.690
one instance of the
chunk, here's another one.

00:28:20.690 --> 00:28:23.360
They can be kind of
spaced out arbitrarily.

00:28:23.360 --> 00:28:28.410
So what I'm going to do is fold
here, fold here, fold here.

00:28:28.410 --> 00:28:30.410
I think that's right,
all the bisectors.

00:28:30.410 --> 00:28:32.660
So I end up with
one chunk like this,

00:28:32.660 --> 00:28:37.550
than another chunk like this,
than another chunk something

00:28:37.550 --> 00:28:39.180
like this.

00:28:39.180 --> 00:28:41.410
Then, this one is very tiny.

00:28:41.410 --> 00:28:43.390
Can I get my four
repetitions of the chunk

00:28:43.390 --> 00:28:45.660
all on top of each other?

00:28:45.660 --> 00:28:49.810
What I then do, so this is going
to take how many repetitions

00:28:49.810 --> 00:28:52.060
is, n to the epsilon over
log n, so this is about n

00:28:52.060 --> 00:28:57.250
to the epsilon over log n
steps, to do all these folds.

00:28:57.250 --> 00:29:01.240
Now I fold here, fold here, fold
here, fold here simultaneously,

00:29:01.240 --> 00:29:02.940
getting them all correct.

00:29:02.940 --> 00:29:05.240
That's going to take
1 minus epsilon times

00:29:05.240 --> 00:29:09.400
basically log n
steps, then I unfold.

00:29:09.400 --> 00:29:13.580
And then I discover, Darn it,
half of them were upside down.

00:29:13.580 --> 00:29:15.580
Because I got this one
right and this one right,

00:29:15.580 --> 00:29:18.990
but these two are flipped,
so that's so good,

00:29:18.990 --> 00:29:21.967
so then I recurse on
the remaining half.

00:29:21.967 --> 00:29:23.800
But this turns out to
be a geometric series,

00:29:23.800 --> 00:29:25.940
so if I do all four of these,
and then I do two of them,

00:29:25.940 --> 00:29:27.790
and then I do one of
them, I'll be done,

00:29:27.790 --> 00:29:31.200
and it will only cost me
another factor of 2 in time.

00:29:31.200 --> 00:29:36.200
So I get log n plus n to
the epsilon over log n.

00:29:36.200 --> 00:29:39.070
I have to do this for each of
the different chunk values,

00:29:39.070 --> 00:29:43.190
so I need to do n to
the 1 minus epsilon,

00:29:43.190 --> 00:29:50.080
times log n plus n to the
epsilon over log n, times 2

00:29:50.080 --> 00:29:52.630
because of the geometric series.

00:29:52.630 --> 00:29:55.225
And this comes out
to n over log n.

00:29:55.225 --> 00:29:55.724
Ta-da!

00:29:59.340 --> 00:30:00.519
Magic.

00:30:00.519 --> 00:30:02.810
The log n is basically coming
from the chunk size being

00:30:02.810 --> 00:30:06.480
log n and 1 minus epsilon log
n as big as we could make it,

00:30:06.480 --> 00:30:10.810
because we needed this to
be a lot smaller than n.

00:30:10.810 --> 00:30:14.160
So that's how you save a
factor of log n, little crazy,

00:30:14.160 --> 00:30:16.986
but it works in theory.

00:30:16.986 --> 00:30:18.610
That's the upper
bound, the lower bound

00:30:18.610 --> 00:30:22.970
is actually pretty obvious,
because if you only

00:30:22.970 --> 00:30:29.030
use k folds, you're doing--
there's n to the k or maybe 2n

00:30:29.030 --> 00:30:31.040
to the k, different
things you can do,

00:30:31.040 --> 00:30:33.415
because there's n different
places you could make a fold,

00:30:33.415 --> 00:30:34.770
could be a mountain or a valley.

00:30:34.770 --> 00:30:37.490
And this better be,
at least, 2 to the n,

00:30:37.490 --> 00:30:39.830
because they're 2 the n
different mountain valley

00:30:39.830 --> 00:30:41.730
patterns you could
make, and you have

00:30:41.730 --> 00:30:43.180
to somehow make
them with k folds.

00:30:43.180 --> 00:30:45.570
These are all the things
you could make with k folds.

00:30:45.570 --> 00:30:47.550
And you work that
out and k has to be,

00:30:47.550 --> 00:30:50.080
at least, about n over log n.

00:30:50.080 --> 00:30:53.130
So that's why it's optimal, and
because this is an information

00:30:53.130 --> 00:30:55.700
theoretic argument, this works
in the average case as well.

00:30:55.700 --> 00:30:57.270
Take a random example.

00:30:57.270 --> 00:30:59.420
You need at least n over log n.

00:30:59.420 --> 00:31:03.190
Most examples, high probability,
will need n over log n.

00:31:03.190 --> 00:31:05.900
So that's those lower bounds.

00:31:05.900 --> 00:31:10.340
Let me briefly tell you about
this log squared n upper bound.

00:31:10.340 --> 00:31:14.890
It uses the same idea, but
because everything is repeated

00:31:14.890 --> 00:31:19.170
in the mmmm string, you don't--
it's a lot easier to do this

00:31:19.170 --> 00:31:20.570
kind of folding.

00:31:20.570 --> 00:31:23.190
Oh sorry, there's one
step I left out here.

00:31:23.190 --> 00:31:25.600
So great, you make these
folds, you line things up,

00:31:25.600 --> 00:31:27.820
you fold these things.

00:31:27.820 --> 00:31:29.140
Then you unfold.

00:31:29.140 --> 00:31:33.010
So in recurse, eventually
you fix these guys,

00:31:33.010 --> 00:31:35.384
but you also destroyed
this crease and this crease

00:31:35.384 --> 00:31:37.800
and this crease, so you kind
of messed things up a little.

00:31:37.800 --> 00:31:39.480
You've got to do this
repeatedly for every chunk.

00:31:39.480 --> 00:31:41.188
You don't want to mess
up previous chunks

00:31:41.188 --> 00:31:41.950
that you've done.

00:31:41.950 --> 00:31:43.730
So you have to go back
and fix this fold,

00:31:43.730 --> 00:31:46.000
unfold, fix this fold,
unfold, but that,

00:31:46.000 --> 00:31:49.350
again, it only costs n to
the epsilon over log n,

00:31:49.350 --> 00:31:50.850
so not too bad.

00:31:50.850 --> 00:31:54.160
So another factor of 2 here.

00:31:54.160 --> 00:31:57.480
But I'm ignoring
constant factors.

00:31:57.480 --> 00:32:00.900
OK, that was n over
log n, upper bound.

00:32:00.900 --> 00:32:05.340
Let's do log squared
upper bound for mmmmm.

00:32:08.860 --> 00:32:13.970
So I need to look this
up, it's a little tricky.

00:32:13.970 --> 00:32:16.120
We're going to use the
trick of the dragon curve,

00:32:16.120 --> 00:32:18.820
essentially, which is
repeatedly fold in half,

00:32:18.820 --> 00:32:22.130
and we're going to keep
doing that until we

00:32:22.130 --> 00:32:27.410
are left with three creases,
which haven't yet been folded.

00:32:27.410 --> 00:32:28.650
So this is my folded bundle.

00:32:28.650 --> 00:32:31.430
There's many, many,
many layers here.

00:32:31.430 --> 00:32:35.357
And then I'm going to fold
mmm on those three creases.

00:32:35.357 --> 00:32:37.940
Instead of going all the way to
dragon curve, which would just

00:32:37.940 --> 00:32:41.960
be, Do m, fold here first, I'm
going to fold this, unfold,

00:32:41.960 --> 00:32:45.610
fold this, unfold, fold this,
unfold, so I get this pattern.

00:32:45.610 --> 00:32:48.800
When I unfold this,
it actually turns out

00:32:48.800 --> 00:32:50.800
to be kind of nice
and alternating.

00:32:50.800 --> 00:32:56.470
It will be something mmm,
something, valley valley

00:32:56.470 --> 00:33:00.250
valley, something, mountain
mountain mountain, something,

00:33:00.250 --> 00:33:03.640
valley valley valley, and so on.

00:33:03.640 --> 00:33:08.380
OK great, half of my things,
roughly, are mountains.

00:33:08.380 --> 00:33:11.020
I just need to
fix these valleys.

00:33:11.020 --> 00:33:16.905
So I use the same trick,
which is I'm going to fold,

00:33:16.905 --> 00:33:22.390
let me use red maybe-- fold in
the middle of these mountain

00:33:22.390 --> 00:33:23.696
segments.

00:33:23.696 --> 00:33:27.610
If I do that, I line up
all the valley segments.

00:33:27.610 --> 00:33:33.680
So I end up with, after folding,
this is going to look like,

00:33:33.680 --> 00:33:35.880
you almost need a computer
to work all this out,

00:33:35.880 --> 00:33:39.990
but we have implemented
this, it works.

00:33:39.990 --> 00:33:42.600
It's going to look like this,
I mean, with many layers

00:33:42.600 --> 00:33:43.100
like this.

00:33:43.100 --> 00:33:45.300
All the values are
on top of each other.

00:33:45.300 --> 00:33:47.310
These question marks are
still question marks.

00:33:47.310 --> 00:33:50.100
This mountain is that mountain,
this mountain is that mountain,

00:33:50.100 --> 00:33:52.182
my mountain is your
mountain, I don't know.

00:33:52.182 --> 00:33:54.390
So now we're going to fold
mountain mountain mountain

00:33:54.390 --> 00:33:59.380
mountain, on all
five of these things,

00:33:59.380 --> 00:34:01.160
and these two remain mountains.

00:34:01.160 --> 00:34:05.790
And then unfold, and what I
end up with is twice as good.

00:34:05.790 --> 00:34:10.840
I end up with question mark,
and then, I think, sorry,

00:34:10.840 --> 00:34:13.179
not quite-- because this
part also gets messed up.

00:34:13.179 --> 00:34:17.239
So I end up with valley,
mountain, question mark,

00:34:17.239 --> 00:34:24.010
then seven mountains,
then question mark,

00:34:24.010 --> 00:34:30.650
then some not so pretty stuff,
m v v v v v m, question mark,

00:34:30.650 --> 00:34:34.120
and then this repeats until we
get to the end of the string.

00:34:34.120 --> 00:34:36.840
And then the end looks
kind of like this.

00:34:36.840 --> 00:34:38.861
So the point is, I had
three m's in a row,

00:34:38.861 --> 00:34:40.110
now I have seven m's in a row.

00:34:40.110 --> 00:34:41.500
Each time I do this,
I roughly double

00:34:41.500 --> 00:34:42.690
the number of m's in a row.

00:34:42.690 --> 00:34:44.106
By the end, almost
everything will

00:34:44.106 --> 00:34:48.190
be m's, after I do
this log n times.

00:34:48.190 --> 00:34:51.800
I have pretty much all m's
and then I can finish it off.

00:34:51.800 --> 00:34:54.199
And each of these
steps took log n steps,

00:34:54.199 --> 00:34:56.367
because I had to fold
along all these things.

00:34:56.367 --> 00:34:57.450
How did I fold along them?

00:34:57.450 --> 00:35:00.175
Not one at a time, of course, I
fold in half and fold in half,

00:35:00.175 --> 00:35:01.570
and fold in half, roughly.

00:35:01.570 --> 00:35:04.620
I choose the middlemost
red line to fold first,

00:35:04.620 --> 00:35:07.600
and about log n steps later,
everything will be piled up.

00:35:07.600 --> 00:35:10.070
So I get to use this efficiency
of dragon curve things.

00:35:10.070 --> 00:35:12.360
I'm messing up these
creases, of course,

00:35:12.360 --> 00:35:14.960
but it's OK, because
I get a big chunk

00:35:14.960 --> 00:35:17.030
that all gets correct at once.

00:35:17.030 --> 00:35:18.922
Half of it gets wrong,
half of it's correct,

00:35:18.922 --> 00:35:21.380
but the half that's getting
correct, gets longer and longer

00:35:21.380 --> 00:35:22.800
each step, doubling.

00:35:22.800 --> 00:35:24.762
So only log squared steps.

00:35:24.762 --> 00:35:26.970
Pretty sure this is optimal,
but the best lower bound

00:35:26.970 --> 00:35:31.220
we can prove is log
squared over log log.

00:35:31.220 --> 00:35:34.830
All right, finally,
let's fold some stuff.

00:35:34.830 --> 00:35:37.362
I thought we would fold
some hyperbolic paraboloids

00:35:37.362 --> 00:35:43.770
and maybe put them together
into structures like this.

00:35:43.770 --> 00:35:45.710
So, you have your squares.

00:35:45.710 --> 00:35:47.960
If you don't have squares,
a bunch of squares up here.

00:35:50.560 --> 00:35:53.025
You can start folding
as many as you like.

00:35:53.025 --> 00:35:54.800
We're going to
put them together.

00:35:54.800 --> 00:35:57.040
I will demonstrate up here.

00:36:00.080 --> 00:36:04.210
So the first thing we want to
do is fold along the diagonals.

00:36:04.210 --> 00:36:08.510
These aren't perfect
squares, but it's OK.

00:36:08.510 --> 00:36:14.809
So we fold along on diagonal,
and the other diagonal.

00:36:14.809 --> 00:36:17.100
This is mainly so we know
where the center is, but also

00:36:17.100 --> 00:36:18.558
because we need to
fold a diagonal,

00:36:18.558 --> 00:36:20.075
so we kill two birds
with one stone.

00:36:25.310 --> 00:36:27.930
Whereas we just saw how
to kill, in this case,

00:36:27.930 --> 00:36:30.780
log n birds with one stone.

00:36:30.780 --> 00:36:33.220
Say log n, here we're
only killing two.

00:36:33.220 --> 00:36:36.190
So now you've got your
diagonals and your square,

00:36:36.190 --> 00:36:37.700
we want to fold--
it's kind of cool,

00:36:37.700 --> 00:36:40.730
I colored the edges
with my chalk hands.

00:36:40.730 --> 00:36:42.340
Now everything's
going to be parallel

00:36:42.340 --> 00:36:43.466
to the sides of the square.

00:36:43.466 --> 00:36:44.965
So the first thing
we're going to do

00:36:44.965 --> 00:36:46.710
is construct a
square that's half as

00:36:46.710 --> 00:36:49.670
big, centered along that point.

00:36:49.670 --> 00:36:53.425
So this involves folding
the bottom edge, usually

00:36:53.425 --> 00:36:54.550
do this valley fold.

00:36:54.550 --> 00:36:56.890
Fold the bottom edge to
line up with that center,

00:36:56.890 --> 00:36:58.890
and also line up the edges.

00:36:58.890 --> 00:37:00.300
Now, very important.

00:37:00.300 --> 00:37:03.000
When you make this fold,
don't fold it all the way,

00:37:03.000 --> 00:37:06.930
just fold the middle half,
between the two diagonals.

00:37:06.930 --> 00:37:09.470
That's really key, otherwise
this will not work.

00:37:09.470 --> 00:37:11.490
It's the only thing you
have to be careful of.

00:37:11.490 --> 00:37:13.810
Don't fall all the way,
just in the middle.

00:37:13.810 --> 00:37:15.930
OK, that's one quarter.

00:37:15.930 --> 00:37:16.940
Do that four times.

00:37:20.030 --> 00:37:26.070
So we go here, line up at
the center, fold the middle.

00:37:37.080 --> 00:37:39.140
Once you've got
the inner square,

00:37:39.140 --> 00:37:41.267
you're going to make two more.

00:37:41.267 --> 00:37:43.600
There's going to be this
square at the one quarter mark,

00:37:43.600 --> 00:37:48.010
and an inner square
at the 3/4 mark.

00:37:48.010 --> 00:37:51.390
To make the outer square, you
fold the edge to the thing

00:37:51.390 --> 00:37:54.310
that you just folded.

00:37:54.310 --> 00:37:58.030
Keep careful note of which
crease you're folding to,

00:37:58.030 --> 00:38:00.800
should be from the
previous square,

00:38:00.800 --> 00:38:02.850
not from the current square.

00:38:02.850 --> 00:38:04.950
To fold the inner square,
you go all the way up

00:38:04.950 --> 00:38:09.340
to the opposite side
of the first square.

00:38:09.340 --> 00:38:11.700
And you can just look visually,
are these evenly spaced.

00:38:11.700 --> 00:38:16.365
If yes, you did it right,
if not, you're in trouble.

00:38:16.365 --> 00:38:18.530
You're probably OK if you
make a few extra creases,

00:38:18.530 --> 00:38:21.500
but don't try to make as few
extra creases as possible.

00:38:24.170 --> 00:38:28.614
So then repeat that four
times and you'll get your,

00:38:28.614 --> 00:38:30.905
I guess, four squares, if
you count the outer boundary.

00:38:53.160 --> 00:38:56.732
It's a little hard to see, once
you've got that, those squares,

00:38:56.732 --> 00:38:58.440
looks like I did one
of them incorrectly.

00:39:03.570 --> 00:39:07.500
Got your nice concentric
squares, four of them.

00:39:07.500 --> 00:39:11.040
Now you're halfway
down, you flip it over,

00:39:11.040 --> 00:39:13.139
and do valley folds
on the other side,

00:39:13.139 --> 00:39:15.180
because you want these to
be alternating mountain

00:39:15.180 --> 00:39:18.160
valley, mountain valley, and
just fill in all the squares

00:39:18.160 --> 00:39:20.430
in between those squares.

00:39:20.430 --> 00:39:22.950
And you can figure out what
the reference markers are,

00:39:22.950 --> 00:39:27.050
they're all the mountain folds,
actually every other mountain

00:39:27.050 --> 00:39:29.540
fold will be one
of your references.

00:39:29.540 --> 00:39:31.820
Don't go to one of
your new valley folds,

00:39:31.820 --> 00:39:35.314
always go to the mountain ones.

00:39:35.314 --> 00:39:37.480
And just check that you're
always filling in halfway

00:39:37.480 --> 00:39:40.590
in between two of
your mountain folds.

00:39:40.590 --> 00:39:43.765
Don't forget to flip
over, very important.

00:39:50.734 --> 00:39:52.980
And skip every other
guy, otherwise you

00:39:52.980 --> 00:39:58.471
will make a refold and just
increase the wrong way.

00:39:58.471 --> 00:40:00.720
This is what it looks like
after one quarter of those.

00:40:51.050 --> 00:40:53.700
And once you've done all
this crazy pre-creasing,

00:40:53.700 --> 00:40:56.040
concentric squares,
alternating mountain valley,

00:40:56.040 --> 00:40:57.410
then the fun part begins.

00:40:57.410 --> 00:40:59.050
This is actually, literally fun.

00:41:01.840 --> 00:41:05.170
It's, I guess, also harder,
but much more exciting

00:41:05.170 --> 00:41:06.660
than all that pre-creasing.

00:41:06.660 --> 00:41:09.490
So, in this case, you have to
fold all the creases at once,

00:41:09.490 --> 00:41:12.340
and the easy way to do that
is start at the outside

00:41:12.340 --> 00:41:19.340
and make the outermost
ring, fold it, just

00:41:19.340 --> 00:41:20.890
go around once or twice.

00:41:20.890 --> 00:41:24.370
Make sure everything's folded,
including that diagonal.

00:41:24.370 --> 00:41:26.190
So here I have valley
folded everything,

00:41:26.190 --> 00:41:28.040
including the outer diagonal.

00:41:28.040 --> 00:41:30.520
And then you want to
mountain fold the next one,

00:41:30.520 --> 00:41:32.250
and get them to be
against each other.

00:41:32.250 --> 00:41:34.800
You're aiming for a
kind of x shape, which

00:41:34.800 --> 00:41:37.210
is drawn over here.

00:41:37.210 --> 00:41:39.950
It's going to look
like that ideally.

00:41:39.950 --> 00:41:44.330
Just keep collapsing, square
by square, making sure you

00:41:44.330 --> 00:41:46.390
alternating mountain
valley, it should just

00:41:46.390 --> 00:41:50.260
fall into place pretty much.

00:41:50.260 --> 00:41:53.620
But paper likes to
misfold a little bit,

00:41:53.620 --> 00:41:55.430
so you've got to fix it all.

00:41:55.430 --> 00:41:58.755
Here I've done two
squares, little more.

00:42:02.554 --> 00:42:04.470
It gets easier and easier,
because the squares

00:42:04.470 --> 00:42:06.480
get smaller and smaller.

00:42:06.480 --> 00:42:11.060
We've got three squares done,
so I'm, like, halfway to an x.

00:42:11.060 --> 00:42:11.930
Fourth square.

00:42:15.430 --> 00:42:17.020
The center is a
little bit tricky,

00:42:17.020 --> 00:42:20.530
try to get it so it alternates,
so now it's nice and thin.

00:42:20.530 --> 00:42:24.760
It's like repeated sync
folds of a water bomb base,

00:42:24.760 --> 00:42:26.400
and it's like an x.

00:42:26.400 --> 00:42:28.100
And then this is
your opportunity

00:42:28.100 --> 00:42:30.810
to recrease all your
creases really hard,

00:42:30.810 --> 00:42:34.070
just give it a good squeeze
on each of the three,

00:42:34.070 --> 00:42:35.185
four legs of the starfish.

00:42:38.240 --> 00:42:42.010
And now you've got your
hyperbolic paraboloid.

00:42:42.010 --> 00:42:46.650
To make it, you want to take two
midpoints here of the squares,

00:42:46.650 --> 00:42:50.560
pull them apart until
it's a little bit open,

00:42:50.560 --> 00:42:55.146
and then give it a twist,
and then open it up a little,

00:42:55.146 --> 00:42:57.760
and you've got your
hyperbolic paraboloid.

00:43:00.847 --> 00:43:03.260
If we make enough of
these, we can assemble it

00:43:03.260 --> 00:43:04.760
into some cool shapes.

00:43:07.340 --> 00:43:10.390
How many people have folded one?

00:43:10.390 --> 00:43:13.450
At least one.

00:43:13.450 --> 00:43:16.460
A few people.

00:43:16.460 --> 00:43:20.054
I will show you--
you can fold more.

00:43:20.054 --> 00:43:21.470
We're going to
assemble something,

00:43:21.470 --> 00:43:23.840
might need a bunch of people.

00:43:23.840 --> 00:43:27.000
This is the algorithm we use
for converting a polyhedron

00:43:27.000 --> 00:43:31.220
into a bunch of
hyperbolic paraboloids.

00:43:31.220 --> 00:43:33.900
It's in this paper
for '99, and we

00:43:33.900 --> 00:43:37.450
take each face of the polygons,
of the polyhedron, sorry.

00:43:37.450 --> 00:43:39.760
So if you have a cube, you've
got a bunch of squares.

00:43:39.760 --> 00:43:41.420
For each square,
we will make what

00:43:41.420 --> 00:43:45.240
we call a four hat, which is
four hyperbolic paraboloids,

00:43:45.240 --> 00:43:48.170
joined in a cycle, like this.

00:43:48.170 --> 00:43:50.790
And you've got to be careful
the join it the right way,

00:43:50.790 --> 00:43:54.010
but then, these, the tips of
the high parts that are not

00:43:54.010 --> 00:43:58.740
joined-- I mean, one tip
of each of the high parts

00:43:58.740 --> 00:44:00.237
comes together at the center.

00:44:00.237 --> 00:44:01.820
Than these tips are
going to represent

00:44:01.820 --> 00:44:04.570
the edge of the
polygon, these red dots.

00:44:04.570 --> 00:44:11.352
And so these two sides are
the sides of-- these two sides

00:44:11.352 --> 00:44:12.560
are the sides of [INAUDIBLE].

00:44:12.560 --> 00:44:17.140
They're going to join to an
adjacent [INAUDIBLE] over here.

00:44:17.140 --> 00:44:18.370
So that's the idea.

00:44:22.220 --> 00:44:25.290
So I've got-- I've already
folded a bunch of these

00:44:25.290 --> 00:44:27.277
already.

00:44:27.277 --> 00:44:29.110
I'll show you, maybe,
what a hat looks like.

00:44:35.410 --> 00:44:41.180
So take two of them, join
them along those edges.

00:44:41.180 --> 00:44:43.590
We're going to use tape
or staples to join them,

00:44:43.590 --> 00:44:46.570
I don't have a fancy
lock, I'm afraid.

00:44:46.570 --> 00:44:51.290
And join these edges
together, and you

00:44:51.290 --> 00:44:57.330
get-- this is a three-hat
and you can put on your head,

00:44:57.330 --> 00:45:00.717
whatever, and that would
represent a triangle.

00:45:00.717 --> 00:45:02.800
And then we're going to
join along these two sides

00:45:02.800 --> 00:45:05.150
to an adjacent
triangle or whatever.

00:45:07.760 --> 00:45:12.490
So we could make
a platonic solid.

00:45:12.490 --> 00:45:17.120
I guess the simplest one would
be a tetrahedron has six edges,

00:45:17.120 --> 00:45:20.560
so it needs 12 [INAUDIBLE].

00:45:20.560 --> 00:45:22.550
I was thinking we
could make this solid,

00:45:22.550 --> 00:45:24.020
it's never been made before.

00:45:24.020 --> 00:45:24.440
It should be cool.

00:45:24.440 --> 00:45:25.940
It's the simplest
Archimedean solid,

00:45:25.940 --> 00:45:29.130
in terms of number of edges,
the truncated tetrahedron.

00:45:29.130 --> 00:45:34.580
This requires 36 parts,
so if we're ambitious,

00:45:34.580 --> 00:45:38.000
we can go for it, but I
think we're low on time.

00:45:38.000 --> 00:45:41.637
So a tetrahedron might
be an easier bet.

00:45:41.637 --> 00:45:43.595
If people want to come
up and start assembling.

00:45:46.440 --> 00:45:47.980
Finish taping that.

00:45:47.980 --> 00:45:52.860
Hold these, and
then this goes here.

00:45:52.860 --> 00:45:55.320
Do you want to hold this one?

00:45:55.320 --> 00:45:58.030
Virtual assembly
here, so maybe we'll

00:45:58.030 --> 00:46:00.520
finish assembling next class.

