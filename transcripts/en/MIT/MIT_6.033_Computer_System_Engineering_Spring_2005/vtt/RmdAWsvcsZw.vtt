WEBVTT
Kind: captions
Language: en

00:00:00.760 --> 00:00:02.790
So what we're going
to do today is

00:00:02.790 --> 00:00:07.310
continue our discussion of
modular computer software,

00:00:07.310 --> 00:00:10.150
and specifically
focus on the topic

00:00:10.150 --> 00:00:13.960
we started talking about last
time called soft modularity.

00:00:18.770 --> 00:00:23.730
And once we figure out,
you know, finish our story

00:00:23.730 --> 00:00:27.720
with regard to soft
modularity and understand

00:00:27.720 --> 00:00:30.390
exactly what this
means, we're going

00:00:30.390 --> 00:00:33.890
to start talking about a
different kind of modularity

00:00:33.890 --> 00:00:35.780
called enforced modularity.

00:00:39.187 --> 00:00:41.020
And enforced modularity
is going to actually

00:00:41.020 --> 00:00:45.950
take us through three lectures,
today and the next two lectures

00:00:45.950 --> 00:00:47.510
next week.

00:00:47.510 --> 00:00:49.830
And the topic for today
in terms of enforced

00:00:49.830 --> 00:00:53.110
modularity is a particular
way of obtaining modularity

00:00:53.110 --> 00:00:56.185
in computer systems called
client/service organization.

00:01:01.530 --> 00:01:03.780
Some people call it
client/server computing.

00:01:03.780 --> 00:01:08.100
And that's the plan for today.

00:01:08.100 --> 00:01:12.590
So what we saw the last time was
basically a lecture describing,

00:01:12.590 --> 00:01:14.850
for the most part,
how linking worked.

00:01:14.850 --> 00:01:17.560
And the idea in
linking is that when

00:01:17.560 --> 00:01:21.370
you have a number
of software modules,

00:01:21.370 --> 00:01:23.990
and your goal is
to take all of them

00:01:23.990 --> 00:01:25.720
and get an executable
program out

00:01:25.720 --> 00:01:30.450
of them that another program
could load into memory and run.

00:01:30.450 --> 00:01:34.920
And that task was
being done by a piece

00:01:34.920 --> 00:01:36.890
of system software
called a linker,

00:01:36.890 --> 00:01:40.360
and out pops an
executable program.

00:01:40.360 --> 00:01:44.789
So at the end of the lecture
last time, a couple of students

00:01:44.789 --> 00:01:46.820
asked me two things.

00:01:46.820 --> 00:01:48.930
One was why we were
actually talking about this.

00:01:48.930 --> 00:01:51.160
And the second more
important question

00:01:51.160 --> 00:01:53.620
was why it wasn't in the notes.

00:01:53.620 --> 00:01:56.160
And so let me answer the first
question [SOUND OFF/THEN ON]

00:01:56.160 --> 00:01:58.320
question first.

00:01:58.320 --> 00:02:01.510
The plan in lectures is to
understand concepts of computer

00:02:01.510 --> 00:02:02.690
systems with examples.

00:02:02.690 --> 00:02:04.982
And oftentimes we
find examples that

00:02:04.982 --> 00:02:06.190
aren't actually in the notes.

00:02:06.190 --> 00:02:08.199
And we use them,
A, because if we

00:02:08.199 --> 00:02:09.740
don't use different
examples, there's

00:02:09.740 --> 00:02:12.089
sort of not as much
incentive to show up.

00:02:12.089 --> 00:02:14.380
But often because some of
the examples that work better

00:02:14.380 --> 00:02:17.840
in lecture don't actually work
out as clearly in the notes.

00:02:17.840 --> 00:02:20.954
So we do tend to use
different examples.

00:02:20.954 --> 00:02:22.829
To answer the first
question, why we actually

00:02:22.829 --> 00:02:25.350
looked at the
linker, first of all

00:02:25.350 --> 00:02:28.790
it's a common piece of software
that pretty much every program

00:02:28.790 --> 00:02:32.599
that you run today goes
through a process of linking.

00:02:32.599 --> 00:02:34.140
But what it actually
allowed us to do

00:02:34.140 --> 00:02:38.490
was illustrate two
main concepts in naming

00:02:38.490 --> 00:02:41.322
having to do with the way
in which the main mapping

00:02:41.322 --> 00:02:42.030
algorithm worked.

00:02:46.290 --> 00:02:47.970
And in the context
of the linker,

00:02:47.970 --> 00:02:49.880
the problem was to
take these symbols

00:02:49.880 --> 00:02:53.970
that you find in the program,
and basically resolve them,

00:02:53.970 --> 00:02:55.970
in other words, find out
where they are defined,

00:02:55.970 --> 00:02:58.400
and where the instructions
corresponding to those symbols,

00:02:58.400 --> 00:03:00.390
or where the data
corresponding to the symbol

00:03:00.390 --> 00:03:03.140
was actually located.

00:03:03.140 --> 00:03:07.900
And the concepts that we saw
were two different concepts.

00:03:07.900 --> 00:03:14.530
The first was name mapping
using a table lookup, where

00:03:14.530 --> 00:03:16.820
within each object file
there was a symbol table that

00:03:16.820 --> 00:03:19.590
mapped between the
symbols found in a module

00:03:19.590 --> 00:03:23.350
to the location where the
symbols were defined further.

00:03:23.350 --> 00:03:27.870
And another example of
doing name mapping, which

00:03:27.870 --> 00:03:30.500
was the process of search
through a series of contexts.

00:03:33.930 --> 00:03:36.310
And in particular, we
looked at the problem

00:03:36.310 --> 00:03:42.079
of when you are in the context
of LD, which GCC uses when

00:03:42.079 --> 00:03:44.590
it finds, goes through
a sequence of dot O

00:03:44.590 --> 00:03:46.500
files as well as
libraries on the command

00:03:46.500 --> 00:03:51.770
line, what algorithm it actually
uses to resolve its symbols.

00:03:51.770 --> 00:03:55.930
And I realize now that what
I had left out on the board,

00:03:55.930 --> 00:03:58.160
there was a couple of
mistakes in the algorithm,

00:03:58.160 --> 00:04:00.000
and I asked what mistakes were.

00:04:00.000 --> 00:04:04.681
And I realized I didn't show
you what the actual algorithm is

00:04:04.681 --> 00:04:05.180
correctly.

00:04:05.180 --> 00:04:07.037
So I thought I'd spend
a minute doing that

00:04:07.037 --> 00:04:09.120
so that if you have something
wrong in your notes,

00:04:09.120 --> 00:04:12.200
you can fix that up, because
I actually never said

00:04:12.200 --> 00:04:13.690
what the right thing was.

00:04:13.690 --> 00:04:15.360
So if you recall,
the general problem

00:04:15.360 --> 00:04:19.010
was you have GCC running
on a set of dot O files,

00:04:19.010 --> 00:04:21.990
F1 dot O all the way
through Fn dot O.

00:04:21.990 --> 00:04:26.790
And what we're trying to do
is describe an algorithm where

00:04:26.790 --> 00:04:30.214
when you obtain the I'th
object file and you have a set

00:04:30.214 --> 00:04:32.380
of currently defined symbols,
and a set of currently

00:04:32.380 --> 00:04:36.060
undefined symbols, how you
can maintain three sets:

00:04:36.060 --> 00:04:38.340
the set of object files
that go into the executable,

00:04:38.340 --> 00:04:41.090
the set of defined symbols
that have been seen so far,

00:04:41.090 --> 00:04:44.170
and the set of undefined symbols
that have been seen so far.

00:04:44.170 --> 00:04:46.840
And you want to
keep updating that.

00:04:46.840 --> 00:04:50.390
So one way to easily see what's
going on is with a picture.

00:04:50.390 --> 00:04:54.270
So up until now, until you've
finished I minus one files,

00:04:54.270 --> 00:04:58.710
let's say you've built
up a set, U, of all

00:04:58.710 --> 00:05:02.990
of the undefined symbols that
have been encountered so far.

00:05:02.990 --> 00:05:05.532
And likewise, you have another
set, D, of all the symbols

00:05:05.532 --> 00:05:07.740
that have been defined so
far that you've encountered

00:05:07.740 --> 00:05:09.280
and have been defined so far.

00:05:09.280 --> 00:05:11.580
So, D and U dynamically
change as you

00:05:11.580 --> 00:05:14.242
go from left to right through
the sequence of files.

00:05:14.242 --> 00:05:15.700
Now, when you are
on the I'th file,

00:05:15.700 --> 00:05:18.140
there is a set of symbols that
have been defined that are

00:05:18.140 --> 00:05:20.600
going to be defined
in the I'th file.

00:05:20.600 --> 00:05:23.910
And that set does not
intersect with a set, D,

00:05:23.910 --> 00:05:27.730
because if it did, then you have
an overlapping defined symbol

00:05:27.730 --> 00:05:28.900
and that's an error.

00:05:28.900 --> 00:05:32.340
So the interesting case is to
look at this kind of an example

00:05:32.340 --> 00:05:35.960
where you have a set, Di, of
the symbols that were defined

00:05:35.960 --> 00:05:38.630
in the I'th file.

00:05:38.630 --> 00:05:41.770
And likewise, in the I'th file,
there are going to be a set

00:05:41.770 --> 00:05:44.100
of undefined symbols.

00:05:44.100 --> 00:05:46.990
And clearly, that set doesn't
overlap with a set, Di,

00:05:46.990 --> 00:05:48.470
because if it's
undefined, it can't

00:05:48.470 --> 00:05:50.420
be defined in the same file.

00:05:50.420 --> 00:05:54.670
So that said, in general,
looks something like this.

00:05:54.670 --> 00:05:58.190
It has some symbols undefined
in this object file that

00:05:58.190 --> 00:06:00.500
are also undefined previously.

00:06:00.500 --> 00:06:02.690
Some symbols that are
undefined in this file that

00:06:02.690 --> 00:06:05.240
have been defined previously,
and some symbols that

00:06:05.240 --> 00:06:07.240
have been undefined here
that you've have really

00:06:07.240 --> 00:06:08.080
never seen before.

00:06:10.830 --> 00:06:12.480
So you've got to
update to things.

00:06:12.480 --> 00:06:13.940
So D gets updated pretty easily.

00:06:13.940 --> 00:06:16.570
D just becomes D union Di.

00:06:16.570 --> 00:06:18.990
And if D intersection
Di is not null,

00:06:18.990 --> 00:06:21.390
then you know there's an error.

00:06:21.390 --> 00:06:24.080
And now you need to update
U, and there are many ways

00:06:24.080 --> 00:06:25.830
to do it that are more
efficient than what

00:06:25.830 --> 00:06:26.871
we're going to write out.

00:06:26.871 --> 00:06:28.990
But it's pretty
easy to see that U

00:06:28.990 --> 00:06:36.100
needs to get updated by unioning
the current set with Ui.

00:06:36.100 --> 00:06:38.587
So that kind of gives you
this together with that.

00:06:38.587 --> 00:06:40.420
But now, you have to
subtract out everything

00:06:40.420 --> 00:06:41.890
that's been defined already.

00:06:41.890 --> 00:06:45.020
And since we updated D first,
we could do that very easily

00:06:45.020 --> 00:06:48.596
by just subtracting out the
set of all defined symbols.

00:06:48.596 --> 00:06:50.220
And you run this
through until the end.

00:06:50.220 --> 00:06:52.820
And if you find that in
the end U is not null,

00:06:52.820 --> 00:06:55.390
then you know that there's
an undefined symbol

00:06:55.390 --> 00:06:57.140
so that the linking
doesn't actually work.

00:06:57.140 --> 00:07:00.090
You can produce an executable
out of it with static linking,

00:07:00.090 --> 00:07:00.590
OK?

00:07:03.130 --> 00:07:08.090
OK, so when you do combined
programs in this fashion

00:07:08.090 --> 00:07:11.940
to produce an executable, there
are all these different modules

00:07:11.940 --> 00:07:16.390
that have been brought together
to run in an interpreter.

00:07:16.390 --> 00:07:18.350
And you have to ask,
what kind of properties

00:07:18.350 --> 00:07:20.410
that program ends up having.

00:07:20.410 --> 00:07:23.340
What kind of modularity do you
get by combining these modules

00:07:23.340 --> 00:07:24.570
together in this fashion?

00:07:24.570 --> 00:07:27.940
It will turn out
that modularity is,

00:07:27.940 --> 00:07:31.230
it's a form of modularity
called soft modularity.

00:07:31.230 --> 00:07:33.550
And to understand why,
you have to understand

00:07:33.550 --> 00:07:37.860
what the interfaces between the
different modules look like.

00:07:37.860 --> 00:07:39.550
Basically when you
look at a C program,

00:07:39.550 --> 00:07:41.966
and you saw an example last
time of how these modules hook

00:07:41.966 --> 00:07:45.580
together, the different
modules track with one another

00:07:45.580 --> 00:07:47.140
through procedures.

00:07:47.140 --> 00:07:49.454
And procedures
between modules have

00:07:49.454 --> 00:07:51.370
something that I'll call
a procedure contract.

00:07:57.047 --> 00:07:59.380
And really, to understand the
property of the modularity

00:07:59.380 --> 00:08:01.664
that you get from
procedural contract,

00:08:01.664 --> 00:08:03.080
we need to understand
a little bit

00:08:03.080 --> 00:08:04.940
about what happens
underneath the callers

00:08:04.940 --> 00:08:08.120
when a caller of a
procedure invokes

00:08:08.120 --> 00:08:09.410
a callee of a procedure.

00:08:09.410 --> 00:08:12.240
And this is actually
material from 004.

00:08:12.240 --> 00:08:16.170
So if you have forgotten,
I'll refresh your memory

00:08:16.170 --> 00:08:20.070
a little bit about it.

00:08:20.070 --> 00:08:22.440
So, very abstractly, if
you look at a computer,

00:08:22.440 --> 00:08:27.500
it's got a processor in it that
actually executes instructions,

00:08:27.500 --> 00:08:29.261
and it has a chunk of memory.

00:08:29.261 --> 00:08:31.260
And in that memory, there
is a portion of memory

00:08:31.260 --> 00:08:34.289
that corresponds to the
stack which is really

00:08:34.289 --> 00:08:37.210
where procedures,
the interesting stuff

00:08:37.210 --> 00:08:40.000
with procedures
gets implemented.

00:08:40.000 --> 00:08:41.909
And you also have a
bunch of registers,

00:08:41.909 --> 00:08:44.930
so, inside the processor.

00:08:44.930 --> 00:08:48.650
And you have a
special variable here

00:08:48.650 --> 00:08:50.950
called the stack
pointer, which keeps

00:08:50.950 --> 00:08:53.590
track of where the
current head of the stack

00:08:53.590 --> 00:08:56.060
is that you can then start
pulling elements off.

00:08:58.840 --> 00:09:01.200
The general plan, the
caller and the callee

00:09:01.200 --> 00:09:04.510
interact with one another
by means of the stack.

00:09:04.510 --> 00:09:09.430
So when a caller wants to
invoke the callee, what it does

00:09:09.430 --> 00:09:11.350
is it takes arguments
of the procedure,

00:09:11.350 --> 00:09:14.600
and pushes them on to the
stack one after another.

00:09:14.600 --> 00:09:17.550
Then the last thing it
does is to tell the callee

00:09:17.550 --> 00:09:21.400
where it should return control
after the procedure function

00:09:21.400 --> 00:09:22.590
has actually been executed.

00:09:22.590 --> 00:09:25.850
And that's the last thing that
pushed on top of the stack

00:09:25.850 --> 00:09:28.620
is the [NOISE OBSCURES].

00:09:28.620 --> 00:09:32.500
So then, after it does that, the
caller then jumps to a location

00:09:32.500 --> 00:09:35.040
where the callee's
module is located,

00:09:35.040 --> 00:09:38.380
and then control
passes to the callee.

00:09:38.380 --> 00:09:41.194
What the callee then
does is it finds out

00:09:41.194 --> 00:09:43.110
what the return address
is, pops the arguments

00:09:43.110 --> 00:09:45.670
one after the other, and
then goes ahead and runs

00:09:45.670 --> 00:09:46.880
the function.

00:09:46.880 --> 00:09:49.390
And then at the end of that,
it looks at the return address

00:09:49.390 --> 00:09:50.860
and passes control back.

00:09:50.860 --> 00:09:55.390
And before it does that, it
actually puts the answer.

00:09:55.390 --> 00:09:58.930
Let's assume that it puts the
answer in a special register.

00:09:58.930 --> 00:10:00.940
And that's part of
the contract as well.

00:10:04.880 --> 00:10:08.580
And once the caller gets the
control back from the callee,

00:10:08.580 --> 00:10:11.450
it can proceed as before.

00:10:11.450 --> 00:10:13.660
Now, the important
thing about this way

00:10:13.660 --> 00:10:17.510
of interacting between caller
and callee with procedure stack

00:10:17.510 --> 00:10:22.536
is this contract has to obey an
invariant or discipline called

00:10:22.536 --> 00:10:23.410
the stack discipline.

00:10:31.196 --> 00:10:32.820
And the essence of
the stack discipline

00:10:32.820 --> 00:10:35.800
is that the callee should
leave the stack exactly

00:10:35.800 --> 00:10:41.320
the way the caller left it when
it invoked the callee, which

00:10:41.320 --> 00:10:43.650
means the caller had set up
a bunch of arguments on it,

00:10:43.650 --> 00:10:47.340
and it but the
return address on it.

00:10:47.340 --> 00:10:49.050
The callee should
leave things as is.

00:10:49.050 --> 00:10:50.900
And in fact, the callee is
not allowed to touch anything.

00:10:50.900 --> 00:10:52.733
It should leave everything
as is this pretty

00:10:52.733 --> 00:10:55.756
much except for the register
that has the answer.

00:10:55.756 --> 00:10:57.630
And as long as this
discipline is maintained,

00:10:57.630 --> 00:11:00.255
and that invariant is maintained
across procedure implications,

00:11:00.255 --> 00:11:02.630
this model of using stacks
is extremely powerful.

00:11:02.630 --> 00:11:05.544
You could implement all sorts
of procedures, nested procedure,

00:11:05.544 --> 00:11:07.960
I mean, recursive procedure,
mutually recursive procedures

00:11:07.960 --> 00:11:11.970
and so on because each of these
implications of the procedure

00:11:11.970 --> 00:11:14.750
has a certain portion of
the stack that corresponds

00:11:14.750 --> 00:11:16.290
to an activation frame.

00:11:16.290 --> 00:11:18.670
And as long as this
discipline is maintained,

00:11:18.670 --> 00:11:22.640
you can do quite complicated
and interesting combinations

00:11:22.640 --> 00:11:25.470
of modules.

00:11:25.470 --> 00:11:30.610
But the problem is that that
modularity depends crucially

00:11:30.610 --> 00:11:33.140
on the stack discipline
being maintained.

00:11:33.140 --> 00:11:35.450
And any violation of
[SOUND  OFF/THEN ON] callee

00:11:35.450 --> 00:11:39.480
can disrupt the caller
and bring it down.

00:11:39.480 --> 00:11:41.560
And there are many ways
in which this discipline

00:11:41.560 --> 00:11:42.930
could be violated.

00:11:42.930 --> 00:11:45.160
And the easiest
one is that there

00:11:45.160 --> 00:11:46.794
is some error or
bug in the callee,

00:11:46.794 --> 00:11:48.210
and the callee
corrupts the stack.

00:11:54.040 --> 00:11:55.817
Or the callee corrupts
the stack pointer,

00:11:55.817 --> 00:11:57.650
so it actually
[SOUND OFF/THEN  ON] control,

00:11:57.650 --> 00:11:59.530
but the stack pointer
points somewhere else

00:11:59.530 --> 00:12:06.530
and some bad instruction
runs, or you have a problem.

00:12:06.530 --> 00:12:09.490
Now, another problem is
that the callee crashes.

00:12:15.460 --> 00:12:17.210
For instance, there
is a divide by zero,

00:12:17.210 --> 00:12:18.876
or there is some
other violation that

00:12:18.876 --> 00:12:20.000
causes the callee to crash.

00:12:20.000 --> 00:12:23.670
And then the caller comes
crashing down as well.

00:12:29.342 --> 00:12:31.550
And there's a bunch of other
reasons, but all of them

00:12:31.550 --> 00:12:33.770
have to do with the stack
discipline being violated,

00:12:33.770 --> 00:12:36.040
or with the callee
crashing and control never

00:12:36.040 --> 00:12:39.350
returning to the
caller, which means

00:12:39.350 --> 00:12:42.530
that the caller and
the callee share fate.

00:12:42.530 --> 00:12:45.330
If something bad happens to
the person who has called,

00:12:45.330 --> 00:12:50.220
sorry, the callee, then the
caller struggles as well

00:12:50.220 --> 00:12:52.110
and isn't able to continue.

00:12:57.790 --> 00:13:00.510
So colloquially this is
referred to as fate sharing.

00:13:03.940 --> 00:13:06.000
And the resulting
modularity is soft

00:13:06.000 --> 00:13:10.070
because any fault or error in
the callee affects the caller.

00:13:10.070 --> 00:13:13.760
The caller, there isn't
any kind of a firewall

00:13:13.760 --> 00:13:17.067
where errors in the
callee are insulated

00:13:17.067 --> 00:13:18.150
from errors in the caller.

00:13:18.150 --> 00:13:21.000
There's no shielding between
the caller and callee.

00:13:21.000 --> 00:13:24.440
And, where is this thing going?

00:13:24.440 --> 00:13:27.750
Like, all right, so
there's no insulation

00:13:27.750 --> 00:13:28.850
between caller and callee.

00:13:28.850 --> 00:13:32.980
And the resulting
modularity is not as hard

00:13:32.980 --> 00:13:38.990
as we would like it to be.

00:13:38.990 --> 00:13:43.240
So this is the problem
we'd like to solve today.

00:13:43.240 --> 00:13:46.090
And the first solution
we're going to discuss

00:13:46.090 --> 00:13:53.070
is a way of organizing
callers and callees

00:13:53.070 --> 00:13:56.430
into an organization called
client service organization.

00:14:04.440 --> 00:14:06.650
And the main idea is
going to actually involve

00:14:06.650 --> 00:14:10.280
a different abstraction by which
callers and callees communicate

00:14:10.280 --> 00:14:12.650
with one another
from the abstractions

00:14:12.650 --> 00:14:13.782
we've seen already.

00:14:13.782 --> 00:14:15.490
We've already seen
the memory abstraction

00:14:15.490 --> 00:14:19.340
where you could write
values to a name,

00:14:19.340 --> 00:14:21.775
and another person
could read from it.

00:14:21.775 --> 00:14:23.900
And we've already seen the
interpreter abstraction.

00:14:23.900 --> 00:14:27.760
It could turn out we are going
to use a different abstraction

00:14:27.760 --> 00:14:31.950
A location path abstraction to
implement the client service

00:14:31.950 --> 00:14:34.210
organization.

00:14:34.210 --> 00:14:37.710
And the idea is the following.

00:14:37.710 --> 00:14:39.640
The program is going
to be decomposed

00:14:39.640 --> 00:14:41.750
into clients and services.

00:14:41.750 --> 00:14:43.860
And you might have many
clients and many services,

00:14:43.860 --> 00:14:45.540
and you could have
a client which

00:14:45.540 --> 00:14:47.670
is a client of one service
and service in turn

00:14:47.670 --> 00:14:50.510
is a client of yet another
service and complicated things

00:14:50.510 --> 00:14:52.170
like that.

00:14:52.170 --> 00:14:54.060
But any pair-wise
interaction is going

00:14:54.060 --> 00:14:58.680
to be between a
client and a service.

00:14:58.680 --> 00:15:01.610
And think of mapping
that example onto here.

00:15:01.610 --> 00:15:04.567
Think of the callee, for
example, being the service

00:15:04.567 --> 00:15:05.900
and the caller being the client.

00:15:05.900 --> 00:15:08.740
The caller wants some work
done, so it's the client.

00:15:08.740 --> 00:15:13.150
And it invokes the service, the
callee, to get that work done.

00:15:13.150 --> 00:15:16.020
And the plan is going to be
that the client and the service

00:15:16.020 --> 00:15:18.240
are going to run on different
computers, physically

00:15:18.240 --> 00:15:19.781
different computers,
and we are going

00:15:19.781 --> 00:15:23.300
to connect the
computers up with wire.

00:15:23.300 --> 00:15:27.160
And the idea is the moment you
do that, the crash of a callee

00:15:27.160 --> 00:15:29.146
doesn't actually bring
the caller coming down

00:15:29.146 --> 00:15:31.520
because it's running on a
completely different processor.

00:15:31.520 --> 00:15:33.730
The stack is not shared.

00:15:33.730 --> 00:15:35.880
The memory is not shared.

00:15:35.880 --> 00:15:37.500
The stack point is not shared.

00:15:37.500 --> 00:15:41.320
There's really no problem with
regard to the callee crashing,

00:15:41.320 --> 00:15:42.510
bringing the caller down.

00:15:42.510 --> 00:15:45.950
Of course, we now need a
way by which the client can

00:15:45.950 --> 00:15:47.720
communicate its
arguments to the service,

00:15:47.720 --> 00:15:49.803
and the service can
communicate its arguments back

00:15:49.803 --> 00:15:50.480
to the client.

00:15:50.480 --> 00:15:51.960
Previously, we
did the first one.

00:15:51.960 --> 00:15:57.660
The arguments were communicated
by putting them using memory

00:15:57.660 --> 00:16:01.490
on the stack, and the answers
were coming back to us

00:16:01.490 --> 00:16:03.110
from register.

00:16:03.110 --> 00:16:05.380
And we don't have that
shared state anymore.

00:16:05.380 --> 00:16:09.515
So, we're going to have to
implement that using messages.

00:16:09.515 --> 00:16:11.140
And we're going to
take these messages,

00:16:11.140 --> 00:16:12.870
use the communication
path abstraction,

00:16:12.870 --> 00:16:16.940
and send messages from
the client to the service.

00:16:16.940 --> 00:16:20.660
So imagine that time flows
downwards starting from when

00:16:20.660 --> 00:16:24.340
the client invokes the service.

00:16:24.340 --> 00:16:25.790
A message is sent
from the client

00:16:25.790 --> 00:16:28.800
as a message to the
service saying here's

00:16:28.800 --> 00:16:31.620
all the arguments, and
here's the procedure

00:16:31.620 --> 00:16:33.180
that I want you to run.

00:16:33.180 --> 00:16:37.020
And it takes that information
up, somehow packages it up

00:16:37.020 --> 00:16:39.560
into a message, and calls send.

00:16:39.560 --> 00:16:42.030
OK, and the assumption is
that the client somehow

00:16:42.030 --> 00:16:45.100
already knows something
about the name of the service

00:16:45.100 --> 00:16:47.380
or the location of the service.

00:16:47.380 --> 00:16:50.490
That's outside of the scope
of the current discussion.

00:16:50.490 --> 00:16:53.020
Let's pretend somebody
tells you that here's

00:16:53.020 --> 00:16:54.970
where the service
is running that can

00:16:54.970 --> 00:16:57.000
run this function for you.

00:16:57.000 --> 00:17:00.500
So it takes the arguments in
the name of the procedure,

00:17:00.500 --> 00:17:04.180
packages it up the message,
and send it across.

00:17:04.180 --> 00:17:05.950
When the service
gets the message.

00:17:05.950 --> 00:17:09.040
It validates the message to make
sure that it's the right sizes,

00:17:09.040 --> 00:17:13.420
and it's not too big, and so on.

00:17:13.420 --> 00:17:17.544
And then, it takes this message
and then does some processing

00:17:17.544 --> 00:17:18.210
on that message.

00:17:18.210 --> 00:17:19.760
The technical term
for it is going

00:17:19.760 --> 00:17:22.010
to be called
un-marshalling because when

00:17:22.010 --> 00:17:24.740
we took these arguments
and put into a message,

00:17:24.740 --> 00:17:27.240
that process is
called marshalling.

00:17:27.240 --> 00:17:29.500
The service is going to
un-marshall this message

00:17:29.500 --> 00:17:32.360
and obtain the actual arguments
and the name of the procedure,

00:17:32.360 --> 00:17:34.140
and then it's going to run it.

00:17:40.890 --> 00:17:44.970
I don't know if it's
one L or two L's.

00:17:44.970 --> 00:17:48.430
And then it's going to run the
procedure that's named here.

00:17:48.430 --> 00:17:49.920
And it's going to
find the answer.

00:17:49.920 --> 00:17:50.980
And then when it
gets the answer,

00:17:50.980 --> 00:17:52.330
it does the same thing back.

00:17:52.330 --> 00:17:55.000
It puts it back into the
message and sends it across

00:17:55.000 --> 00:17:55.724
to the client.

00:17:55.724 --> 00:17:57.640
And now the client is
waiting for this message

00:17:57.640 --> 00:18:01.060
because it sends off the
message to the service

00:18:01.060 --> 00:18:02.270
to run this thing.

00:18:02.270 --> 00:18:03.812
It gets this answer back.

00:18:03.812 --> 00:18:04.770
It does the same thing.

00:18:04.770 --> 00:18:07.960
It takes the message in that
it recovers the answer from it,

00:18:07.960 --> 00:18:09.350
and then it runs continuously.

00:18:13.600 --> 00:18:18.930
So this is the basic idea in
client/server organization.

00:18:18.930 --> 00:18:21.590
And the way in which
we solve this problem

00:18:21.590 --> 00:18:24.610
is that these two problems are
solved because the callee can't

00:18:24.610 --> 00:18:26.950
really corrupt the
stack or the stack point

00:18:26.950 --> 00:18:29.070
or anything else
that in this model

00:18:29.070 --> 00:18:31.812
would have affected the caller.

00:18:31.812 --> 00:18:33.770
And because we have put
them both on physically

00:18:33.770 --> 00:18:35.640
different computers and
hooked them up with,

00:18:35.640 --> 00:18:39.630
let's say, a wire, the service
crashing does not actually

00:18:39.630 --> 00:18:43.580
bring the client, if the
service decides that it crashes,

00:18:43.580 --> 00:18:46.560
then the client actually
doesn't come crashing down.

00:18:46.560 --> 00:18:48.130
Of course, the
client has to somehow

00:18:48.130 --> 00:18:51.140
have a plan by which it knows
that the service is still,

00:18:51.140 --> 00:18:52.810
for example, the
client has to know

00:18:52.810 --> 00:18:55.393
whether the service has crashed
or whether the service is just

00:18:55.393 --> 00:18:57.360
taking a long time
to run something.

00:18:57.360 --> 00:19:00.300
That's something we have to
address, and we will in a bit.

00:19:00.300 --> 00:19:03.740
But as long as the client
is able to do that,

00:19:03.740 --> 00:19:06.160
a service going away or
crashing is not really

00:19:06.160 --> 00:19:11.640
going to bring the caller
or the client down with it.

00:19:11.640 --> 00:19:13.420
So, some properties
of this organization

00:19:13.420 --> 00:19:14.961
are, first of all,
that it's modular.

00:19:14.961 --> 00:19:16.720
It has essentially
the same modularity

00:19:16.720 --> 00:19:19.690
as we had with
procedures because if you

00:19:19.690 --> 00:19:21.190
had enough computers,
you could move

00:19:21.190 --> 00:19:24.130
all of the different procedures
on different computers, all

00:19:24.130 --> 00:19:25.590
of the caller/callee
relationships,

00:19:25.590 --> 00:19:27.490
and you can preserve,
essentially,

00:19:27.490 --> 00:19:29.880
the same modularity
that you had before.

00:19:33.540 --> 00:19:37.960
Moreover, this modularity
has a different adjective

00:19:37.960 --> 00:19:39.970
in front of it
different from soft.

00:19:39.970 --> 00:19:41.340
This modularity is enforced.

00:19:45.770 --> 00:19:48.330
What that means
is not only is it

00:19:48.330 --> 00:19:53.830
a modular organization, it's one
where errors of, for example,

00:19:53.830 --> 00:19:58.420
things where one
module fails or crashes

00:19:58.420 --> 00:20:00.420
does not bring the other
one come crashing down.

00:20:00.420 --> 00:20:02.830
So the modularity
is more enforced

00:20:02.830 --> 00:20:07.180
than when they were both running
on the same computer using

00:20:07.180 --> 00:20:08.200
the procedure interface.

00:20:10.780 --> 00:20:12.900
And the third property of
this kind of modularity

00:20:12.900 --> 00:20:14.210
is something already mentioned.

00:20:14.210 --> 00:20:19.222
It lies on the message
abstraction, actually

00:20:19.222 --> 00:20:20.680
the communication
path abstraction.

00:20:24.050 --> 00:20:29.990
The client and service
communicate with each other

00:20:29.990 --> 00:20:31.192
through messages.

00:20:31.192 --> 00:20:32.650
And these aren't
actually messages.

00:20:32.650 --> 00:20:36.140
You can't just sort of take
a random string of bytes

00:20:36.140 --> 00:20:38.237
and send it to the service.

00:20:38.237 --> 00:20:39.820
It's actually messages
that correspond

00:20:39.820 --> 00:20:41.150
to a particular format.

00:20:41.150 --> 00:20:43.070
And these are really
known in advance.

00:20:43.070 --> 00:20:44.970
So, that way the
service isn't surprised

00:20:44.970 --> 00:20:46.690
and the client
isn't surprised when

00:20:46.690 --> 00:20:49.545
messages that don't conform
to that pattern arrive.

00:20:49.545 --> 00:20:51.420
I mean, you know exactly
what kind of message

00:20:51.420 --> 00:20:52.140
is going to arrive.

00:20:52.140 --> 00:20:53.514
And anything that
doesn't conform

00:20:53.514 --> 00:20:55.655
to what is agreed upon
in advance is rejected.

00:20:58.160 --> 00:21:00.980
But you basically make
it so that you explicitly

00:21:00.980 --> 00:21:03.270
declare the nature of
these messages much

00:21:03.270 --> 00:21:06.630
like you did the nature
of procedural interface.

00:21:06.630 --> 00:21:08.630
But now, because you've
physically separated it,

00:21:08.630 --> 00:21:11.630
you have a more
enforced modularity

00:21:11.630 --> 00:21:13.130
than in the previous model.

00:21:17.574 --> 00:21:18.990
Of course, nothing
comes for free.

00:21:18.990 --> 00:21:21.070
It's not like you got
this enforced modularity,

00:21:21.070 --> 00:21:24.105
and you have all of these nice
properties that you did before.

00:21:27.360 --> 00:21:29.710
Here, you had a nice
property that the callee

00:21:29.710 --> 00:21:33.050
could, has the property
that either when

00:21:33.050 --> 00:21:37.580
it runs and it returns to you,
you know exactly what happened.

00:21:37.580 --> 00:21:41.469
And if it doesn't return,
you know that you usually

00:21:41.469 --> 00:21:42.260
come crashing down.

00:21:42.260 --> 00:21:44.634
If the callee doesn't return,
it means that control never

00:21:44.634 --> 00:21:46.590
comes back to the caller.

00:21:46.590 --> 00:21:48.515
So it's not like
the caller is left

00:21:48.515 --> 00:21:50.890
wondering what really happened
because the caller doesn't

00:21:50.890 --> 00:21:52.020
get control again.

00:21:54.549 --> 00:21:55.590
Here, you have a problem.

00:21:55.590 --> 00:21:59.620
If the callee, the service
doesn't return back

00:21:59.620 --> 00:22:01.280
to the client, the
client actually

00:22:01.280 --> 00:22:04.060
doesn't know what's going on.

00:22:04.060 --> 00:22:07.040
When you have two machines, two
computers connected over a wire

00:22:07.040 --> 00:22:09.050
or over a network,
it's extremely hard

00:22:09.050 --> 00:22:13.000
to distinguish between a service
running really, really slow,

00:22:13.000 --> 00:22:16.550
and a service that's gone away.

00:22:16.550 --> 00:22:20.490
And we'll revisit this a few
different times in the course.

00:22:20.490 --> 00:22:24.180
But it's going to be impossible
for us to tell for sure,

00:22:24.180 --> 00:22:25.964
although we're going
to try very hard.

00:22:25.964 --> 00:22:28.130
It's going to be really
hard for us to tell for sure

00:22:28.130 --> 00:22:30.995
whether something
exactly happened.

00:22:30.995 --> 00:22:32.370
And if the service
didn't return,

00:22:32.370 --> 00:22:35.630
we don't really know for sure
without much more machinery

00:22:35.630 --> 00:22:38.310
whether it was just that the
service is still running,

00:22:38.310 --> 00:22:43.020
or whether it's crashed,
and we are just waiting.

00:22:43.020 --> 00:22:47.540
And so, this organization
requires a timer at the client,

00:22:47.540 --> 00:22:50.009
and there are many names
given to this timer.

00:22:50.009 --> 00:22:51.550
I mean, people call
them keep-alives,

00:22:51.550 --> 00:22:53.420
or people call them
with various names.

00:22:53.420 --> 00:22:57.850
I'm going to call it a
watchdog timer, where

00:22:57.850 --> 00:23:00.570
the client has to
keep track using

00:23:00.570 --> 00:23:03.025
some kind of a timer
of the service.

00:23:03.025 --> 00:23:05.400
And if the service doesn't
return within a certain period

00:23:05.400 --> 00:23:08.490
of time, the client has
to time out and say,

00:23:08.490 --> 00:23:12.479
well, the service didn't
return, and I'm not

00:23:12.479 --> 00:23:13.520
quite sure what happened.

00:23:13.520 --> 00:23:16.760
It might be that the procedure
I wanted to execute had ran,

00:23:16.760 --> 00:23:18.040
but I didn't get the answer.

00:23:18.040 --> 00:23:20.390
Or it might be that
the procedure didn't

00:23:20.390 --> 00:23:23.670
get executed at all, and
I have to deal with it.

00:23:23.670 --> 00:23:25.880
And you might be able to,
by retrying the procedure,

00:23:25.880 --> 00:23:27.630
or you might contact
another service which

00:23:27.630 --> 00:23:29.772
provides the same
functionality, but the client

00:23:29.772 --> 00:23:30.980
has to deal with all of that.

00:23:35.930 --> 00:23:38.280
So fundamental to this
client's organization

00:23:38.280 --> 00:23:42.340
is the notion of a time out.

00:23:42.340 --> 00:23:45.600
And we didn't have
that here because here,

00:23:45.600 --> 00:23:49.630
if the callee decides that
it's just going to continue on

00:23:49.630 --> 00:23:52.351
and not return, the caller
never gets a message back.

00:23:52.351 --> 00:23:54.100
So, it doesn't have
this decision to make.

00:23:54.100 --> 00:23:56.160
There is no such
notion of a watchdog

00:23:56.160 --> 00:23:58.475
that we have to worry about
in this other organization.

00:24:13.150 --> 00:24:16.450
So another nice property of
this client service organization

00:24:16.450 --> 00:24:19.140
is that so far
we've presented it

00:24:19.140 --> 00:24:21.440
in the context of the
client and the service

00:24:21.440 --> 00:24:23.490
being modularized
from each other,

00:24:23.490 --> 00:24:28.390
and we've enforced modularity
to the client and the service.

00:24:28.390 --> 00:24:30.500
But in fact, there is
another nice property to it,

00:24:30.500 --> 00:24:34.120
which is that a client
service organization allows

00:24:34.120 --> 00:24:38.920
us to design modules and design
systems where clients get

00:24:38.920 --> 00:24:41.530
modularized from each other.

00:24:41.530 --> 00:24:44.840
We can achieve soft modularity
by protecting clients

00:24:44.840 --> 00:24:56.080
from each other.

00:24:56.080 --> 00:24:59.880
The idea here is that if you
have many clients all of which

00:24:59.880 --> 00:25:03.480
want to use a given service,
for example, there's

00:25:03.480 --> 00:25:07.080
a service that's, let's
say, implemented by a bank

00:25:07.080 --> 00:25:09.934
and what it does is
it's the service that

00:25:09.934 --> 00:25:11.350
deals with managing
your accounts,

00:25:11.350 --> 00:25:13.040
and you can move money
between accounts,

00:25:13.040 --> 00:25:16.720
and it will tell you your
account balance and so on.

00:25:16.720 --> 00:25:18.700
You can implement
that as one service,

00:25:18.700 --> 00:25:22.650
and many, many clients can
share the same service.

00:25:22.650 --> 00:25:25.090
Now, all of the clients trust
the service because, I mean,

00:25:25.090 --> 00:25:27.950
if you are a customer of a bank,
and you are using your browser

00:25:27.950 --> 00:25:30.530
to look for your account
balance, that means

00:25:30.530 --> 00:25:31.950
you sort of trust the bank.

00:25:31.950 --> 00:25:34.470
And all the clients
trust the service.

00:25:34.470 --> 00:25:38.150
But the clients sure
don't trust each other.

00:25:38.150 --> 00:25:39.960
And the nice thing
about this organization

00:25:39.960 --> 00:25:44.360
is that you can use the service
in the form of an intermediary

00:25:44.360 --> 00:25:50.320
that allows the clients to be
separated from each other, each

00:25:50.320 --> 00:25:51.580
of which can use the service.

00:25:51.580 --> 00:25:53.580
But the clients don't
have to trust each other,

00:25:53.580 --> 00:25:56.460
and clients don't
really have to know

00:25:56.460 --> 00:25:58.950
about each other's information.

00:25:58.950 --> 00:26:03.280
And this idea of using a
service to modularize clients

00:26:03.280 --> 00:26:06.750
from each other is called
a trusted intermediary.

00:26:06.750 --> 00:26:13.180
There is many examples
of trusted intermediaries

00:26:13.180 --> 00:26:15.690
that we'll see in this course.

00:26:15.690 --> 00:26:18.350
In fact, tomorrow's recitation
on the X Windows system

00:26:18.350 --> 00:26:20.800
has a system where
your computer screen

00:26:20.800 --> 00:26:26.120
is going to be managed by a
service called by the X Windows

00:26:26.120 --> 00:26:26.760
system.

00:26:26.760 --> 00:26:29.343
And there are many clients that
are going to use that service.

00:26:29.343 --> 00:26:32.440
And the clients don't
actually trust each other.

00:26:32.440 --> 00:26:36.040
They want to get modularized
away from each other.

00:26:36.040 --> 00:26:39.644
And the X Windows system
as a trusted intermediary

00:26:39.644 --> 00:26:40.310
deals with that.

00:26:40.310 --> 00:26:42.680
It managed this resource
-- your display,

00:26:42.680 --> 00:26:47.035
and it arranges for the clients
to be designed each independent

00:26:47.035 --> 00:26:47.660
from the other.

00:26:50.190 --> 00:26:53.540
And in general, we are going to
see in the next few lectures,

00:26:53.540 --> 00:26:56.570
many examples of the operating
system being a trusted

00:26:56.570 --> 00:27:00.800
intermediary, arranging
for many different clients

00:27:00.800 --> 00:27:03.720
to use some resource on your
computer like the processor

00:27:03.720 --> 00:27:05.760
or the memory or the disk.

00:27:05.760 --> 00:27:08.340
And our architecture
for the operating

00:27:08.340 --> 00:27:11.225
is going to end up being in
the form of these trusted

00:27:11.225 --> 00:27:11.850
intermediaries.

00:27:29.940 --> 00:27:33.850
So, so far we've seen what
client service organization

00:27:33.850 --> 00:27:34.350
means.

00:27:34.350 --> 00:27:36.141
It means you have a
client and the service,

00:27:36.141 --> 00:27:37.710
and they communicate
with messages

00:27:37.710 --> 00:27:39.800
using the communication
path abstraction

00:27:39.800 --> 00:27:41.420
of send and receive.

00:27:41.420 --> 00:27:44.612
And we've seen some properties
of client service organization.

00:27:44.612 --> 00:27:46.070
But I haven't
actually told you how

00:27:46.070 --> 00:27:48.110
to implement any of this stuff.

00:27:48.110 --> 00:27:51.480
And so that's what we're
going to do the rest of today.

00:27:51.480 --> 00:27:53.130
And in fact, we are
going to continue

00:27:53.130 --> 00:27:54.900
with different ways
of implementing

00:27:54.900 --> 00:27:58.450
various forms of client service
many times in the course.

00:28:15.910 --> 00:28:19.280
So there are many ways to
implement client service

00:28:19.280 --> 00:28:20.000
organization.

00:28:20.000 --> 00:28:22.960
And all of them have
to do with, all of them

00:28:22.960 --> 00:28:26.060
involved different ways
in which messages are sent

00:28:26.060 --> 00:28:28.830
between client and service.

00:28:28.830 --> 00:28:31.560
A common way, and a
pretty standard way,

00:28:31.560 --> 00:28:34.800
of implementing it is something
called a remote procedure call.

00:28:43.620 --> 00:28:45.660
There are many examples
of remote procedure

00:28:45.660 --> 00:28:46.360
called systems.

00:28:46.360 --> 00:28:49.929
I mean, one of the
most common ones

00:28:49.929 --> 00:28:51.970
is something called the
Sun Remote Procedure Call

00:28:51.970 --> 00:28:54.090
system, or Sun RPC.

00:28:54.090 --> 00:28:56.120
That's one example.

00:28:56.120 --> 00:28:58.440
There are many other
examples as well.

00:28:58.440 --> 00:29:03.160
A more modern example which
some of you may have heard of

00:29:03.160 --> 00:29:06.180
is a relatively new system,
about five years old,

00:29:06.180 --> 00:29:07.630
called XML RPC.

00:29:11.670 --> 00:29:15.090
So if you've heard of
buzzwords like Web services

00:29:15.090 --> 00:29:18.110
in business-to-business
interactions,

00:29:18.110 --> 00:29:21.460
or business-to-business
applications,

00:29:21.460 --> 00:29:24.410
these things use
something called XML RPC.

00:29:24.410 --> 00:29:28.730
And, there is a lot of different
three letter acronyms and four

00:29:28.730 --> 00:29:30.020
letter acronyms.

00:29:30.020 --> 00:29:32.140
This has led to
something called SOAP,

00:29:32.140 --> 00:29:37.750
which stands for the Simple
Object Access Protocol.

00:29:37.750 --> 00:29:41.390
So there are many different ways
of implementing RPC systems.

00:29:41.390 --> 00:29:46.700
And until last year
or a couple of years

00:29:46.700 --> 00:29:48.640
ago, we used to
talk about Sun RPC

00:29:48.640 --> 00:29:50.450
as an example in this class.

00:29:50.450 --> 00:29:52.290
But I decided that's
so 20th century.

00:29:52.290 --> 00:29:56.230
So we're going to talk
about XML RPC today.

00:29:56.230 --> 00:29:59.560
It has a property that's
much more inefficient,

00:29:59.560 --> 00:30:01.724
but that's sort of
keeping with the fact

00:30:01.724 --> 00:30:03.140
that computers
have become faster.

00:30:03.140 --> 00:30:06.030
We don't have to worry in
many cases about efficiency.

00:30:06.030 --> 00:30:10.350
So we are going to talk a little
bit about how XML RPC works.

00:30:14.450 --> 00:30:22.200
So let me first show you
what a client written what

00:30:22.200 --> 00:30:24.630
this kind of RPC looks like.

00:30:24.630 --> 00:30:28.090
It's going to show
you a code snippet.

00:30:32.620 --> 00:30:43.320
All right, I had to work hard to
make sure it would fit on this.

00:30:43.320 --> 00:30:47.020
OK, all right, the
way this thing works

00:30:47.020 --> 00:30:50.420
is actually very, very simple.

00:30:50.420 --> 00:30:55.360
This uses something called XML
RPC Library for Java that was

00:30:55.360 --> 00:30:58.520
written by the Apache people.

00:30:58.520 --> 00:31:00.640
And once you incorporate
that library,

00:31:00.640 --> 00:31:03.020
your program becomes
completely easy.

00:31:03.020 --> 00:31:04.620
So let me just walk
you through this.

00:31:04.620 --> 00:31:06.780
The high level idea
here is that it's

00:31:06.780 --> 00:31:10.780
transferring money from
one account to the other

00:31:10.780 --> 00:31:14.440
through a service
that's run by the bank.

00:31:14.440 --> 00:31:17.320
So, the first line
of this thing here

00:31:17.320 --> 00:31:21.455
creates an XML RPC object,
an XML RPC client object.

00:31:21.455 --> 00:31:23.830
And what you give it is actually
the name of the service.

00:31:23.830 --> 00:31:25.996
So somebody has to tell you
the name of the service.

00:31:25.996 --> 00:31:28.550
And I don't want to get into
the details of everything here,

00:31:28.550 --> 00:31:31.010
but the basic idea
is your backname.com

00:31:31.010 --> 00:31:34.570
colon 8080 is the name, the DNS
name at which the service runs

00:31:34.570 --> 00:31:35.510
and the port.

00:31:35.510 --> 00:31:37.200
The thing about
XML RPC is that it

00:31:37.200 --> 00:31:39.330
runs over HTTP which
is what you use

00:31:39.330 --> 00:31:42.260
to transfer objects on the Web.

00:31:42.260 --> 00:31:44.430
And underneath, we talk
about how it's implemented;

00:31:44.430 --> 00:31:48.040
underneath this is implemented
using a standard method in HTTP

00:31:48.040 --> 00:31:50.050
called a POST which
allows, normally

00:31:50.050 --> 00:31:51.990
HTTP has a GET
where you retrieve

00:31:51.990 --> 00:31:53.700
But it also has a
POST that many of you

00:31:53.700 --> 00:31:55.490
are familiar with
where the client can

00:31:55.490 --> 00:31:57.810
push some stuff to the server.

00:31:57.810 --> 00:32:01.752
And it just uses POST method.

00:32:01.752 --> 00:32:02.960
What's going on is very easy?

00:32:02.960 --> 00:32:05.310
You create a vector
of parameters,

00:32:05.310 --> 00:32:07.610
and you fill that
vector in with,

00:32:07.610 --> 00:32:09.620
in this case, your
account number.

00:32:09.620 --> 00:32:13.720
And let's say here the
idea is this sort of thing

00:32:13.720 --> 00:32:16.280
is very popular in big
companies like Ford or Cisco,

00:32:16.280 --> 00:32:18.110
which have thousands
of suppliers.

00:32:18.110 --> 00:32:21.800
And, they never
actually maintain a lot

00:32:21.800 --> 00:32:23.944
of inventory of their own.

00:32:23.944 --> 00:32:25.860
They're always trying
to figure out the latest

00:32:25.860 --> 00:32:27.190
cost of any of their supplies.

00:32:27.190 --> 00:32:29.550
And they are using this
Web service like interface.

00:32:29.550 --> 00:32:32.702
In fact, this is also called
a Web service interface

00:32:32.702 --> 00:32:34.160
to communicate with
their suppliers

00:32:34.160 --> 00:32:38.040
to always have the latest info
whether their suppliers have

00:32:38.040 --> 00:32:40.452
any given item in stock, and
how much it costs and so on.

00:32:40.452 --> 00:32:42.660
So, let's pretend you have
done that in your company,

00:32:42.660 --> 00:32:45.220
and you are trying
to pay off, you

00:32:45.220 --> 00:32:47.410
are taking your
suppliers' account number

00:32:47.410 --> 00:32:49.200
and pay some money to him, OK?

00:32:49.200 --> 00:32:54.750
So in this case, whatever,
dollars is that argument.

00:32:54.750 --> 00:32:55.840
So you create parameters.

00:32:55.840 --> 00:32:58.970
And all you do at the end is
you use these XML RPC client

00:32:58.970 --> 00:33:03.800
objects, and invoke a method it
presents to you called execute.

00:33:03.800 --> 00:33:05.600
And you give it two arguments.

00:33:05.600 --> 00:33:07.255
The second argument
is the parameters.

00:33:07.255 --> 00:33:09.380
And the first argument is
the name of the procedure

00:33:09.380 --> 00:33:12.050
that you wish to
run on the service.

00:33:12.050 --> 00:33:15.590
OK, that's in this case
called MoneyTransfer.

00:33:15.590 --> 00:33:17.830
So, corresponding to
this, somewhat longer

00:33:17.830 --> 00:33:20.570
is a piece of code running on
the service which implements

00:33:20.570 --> 00:33:25.610
the server side of it,
which basically obtains

00:33:25.610 --> 00:33:33.130
[SOUND OFF/THEN ON] calls an
object that will un-marshall

00:33:33.130 --> 00:33:35.800
the arguments, and then it
will execute money transfer,

00:33:35.800 --> 00:33:40.310
both of which [SOUND There
is very little that actually

00:33:40.310 --> 00:33:41.524
has to run on the service.

00:33:41.524 --> 00:33:43.190
It's just a little
bit longer than this.

00:33:45.700 --> 00:33:48.685
Now, this line
here is important.

00:33:48.685 --> 00:33:50.560
That's the line on which
you get your result.

00:33:50.560 --> 00:33:52.530
And this gives the
result as a string.

00:33:52.530 --> 00:33:55.300
If I tell you that I
finished transferring

00:33:55.300 --> 00:33:59.160
X dollars from this account to
that account, or if I tell you

00:33:59.160 --> 00:34:02.080
I couldn't transfer, and there
was some kind of an error,

00:34:02.080 --> 00:34:06.210
or you might actually not
get any answer, in which case

00:34:06.210 --> 00:34:10.570
the underlying library that
implements this procedure call

00:34:10.570 --> 00:34:13.580
would throw an exception
your code has to deal with.

00:34:13.580 --> 00:34:16.120
And how you deal with it is
a little tricky because you

00:34:16.120 --> 00:34:17.934
don't, and you'll
see this in a moment,

00:34:17.934 --> 00:34:19.350
you don't quite
know what happened

00:34:19.350 --> 00:34:21.389
when you didn't
get an answer back

00:34:21.389 --> 00:34:25.639
from the You don't know if
this actually got your transfer

00:34:25.639 --> 00:34:30.159
request and crashed after that.

00:34:30.159 --> 00:34:31.500
And, it got the request.

00:34:31.500 --> 00:34:33.400
It actually implemented the
transfer and then crashed.

00:34:33.400 --> 00:34:35.000
It just couldn't send
your response back.

00:34:35.000 --> 00:34:36.748
So, you're not quite
sure whether you need

00:34:36.748 --> 00:34:38.900
to retry the request or not.

00:34:38.900 --> 00:34:41.070
You will actually
see how to deal

00:34:41.070 --> 00:34:45.239
with this in a few minutes.

00:34:45.239 --> 00:34:47.699
Now, there's one
thing that's really

00:34:47.699 --> 00:34:49.850
important about
this line of code.

00:34:49.850 --> 00:34:54.650
This xmlrpc.execute(
"MoneyTransfer") block,

00:34:54.650 --> 00:34:57.750
that line of code actually
is not something that runs

00:34:57.750 --> 00:34:59.590
on the service.

00:34:59.590 --> 00:35:02.000
OK, it's a local procedure.

00:35:02.000 --> 00:35:05.150
xmlprc.execute() is
a local procedure.

00:35:05.150 --> 00:35:10.110
OK, and that procedure is an
example of something called

00:35:10.110 --> 00:35:15.205
a stub because what it is,
is a stub that to this caller

00:35:15.205 --> 00:35:17.580
fakes out the fact that there's
a service somewhere else.

00:35:17.580 --> 00:35:20.330
I mean, it prevents
the caller from having

00:35:20.330 --> 00:35:22.640
to deal with 15 arguments
and putting it in the message

00:35:22.640 --> 00:35:24.440
and sending it to
the other side.

00:35:24.440 --> 00:35:26.800
The caller just calls
it over the procedure,

00:35:26.800 --> 00:35:29.910
giving it suitable arguments
that pinch for this

00:35:29.910 --> 00:35:31.700
function now to do
the work of sending

00:35:31.700 --> 00:35:33.080
a message across the network.

00:35:33.080 --> 00:35:36.360
But this is a local call.

00:35:36.360 --> 00:35:38.030
So, what happens underneath?

00:35:38.030 --> 00:35:41.400
Underneath in the library,
once you call xmlrpc.execute()

00:35:41.400 --> 00:35:43.690
in this example,
somebody does work.

00:35:43.690 --> 00:35:46.540
That library does the work of
taking the different arguments

00:35:46.540 --> 00:35:49.440
that have been presented
to it and converting them

00:35:49.440 --> 00:35:52.930
into a message, marshalling all
of the stuff into a message,

00:35:52.930 --> 00:35:55.220
and then shipping that
message off to the server.

00:35:55.220 --> 00:35:57.761
That has to be going to some
kind of a format on the Fly,

00:35:57.761 --> 00:35:58.260
right?

00:35:58.260 --> 00:36:00.134
Ultimately on this wire
connecting the client

00:36:00.134 --> 00:36:01.700
to the service, there's format.

00:36:01.700 --> 00:36:04.670
And I already mentioned that
this runs on top of HTTP.

00:36:04.670 --> 00:36:08.610
And so we can actually look
at what that looks like.

00:36:12.750 --> 00:36:20.520
OK, so POST here is the
method that you use in HTTP.

00:36:20.520 --> 00:36:24.860
The /RPC2 is actually the same
thing that was used in, if you

00:36:24.860 --> 00:36:28.890
remember in the
previous screenshot,

00:36:28.890 --> 00:36:34.770
when we did the new call to
get a new XML RPC client,

00:36:34.770 --> 00:36:36.980
we gave it a server
name and a port number.

00:36:36.980 --> 00:36:38.970
But we also gave it
something called RPC2.

00:36:38.970 --> 00:36:41.600
Now, that's just like a
file on the other side.

00:36:41.600 --> 00:36:44.140
It says there are many
different RPC programs running

00:36:44.140 --> 00:36:45.060
on your service.

00:36:45.060 --> 00:36:46.590
And I want RPC2 to run.

00:36:46.590 --> 00:36:50.610
I mean, I could have named
it anything I wanted.

00:36:50.610 --> 00:36:54.360
And that's a lot like
giving a file name on a URL.

00:36:54.360 --> 00:36:56.887
And then, you go on.

00:36:56.887 --> 00:36:57.970
You give it the host name.

00:36:57.970 --> 00:36:59.900
This is a lot like
an HTTP header.

00:36:59.900 --> 00:37:04.900
The interesting new stuff
here is in the XML arguments.

00:37:04.900 --> 00:37:06.590
But those were not
familiar with XML.

00:37:06.590 --> 00:37:08.950
It's just a method,
a way of sending

00:37:08.950 --> 00:37:11.520
things that have attributes and
values associated with them.

00:37:11.520 --> 00:37:15.140
So, every method has
the format that it's

00:37:15.140 --> 00:37:16.610
attributes and
values, and they can

00:37:16.610 --> 00:37:18.520
be nested within each other.

00:37:18.520 --> 00:37:20.350
The only interesting
thing that's here,

00:37:20.350 --> 00:37:23.750
this particular XML RPC system
supports a few different data

00:37:23.750 --> 00:37:24.380
formats.

00:37:24.380 --> 00:37:26.970
You can do integers, and
characters, and strings,

00:37:26.970 --> 00:37:30.410
and doubles, and floats, and a
few different things like that.

00:37:30.410 --> 00:37:32.640
And I thought it just means
that the 32 bit integer,

00:37:32.640 --> 00:37:36.570
and you can take numbers that
sum up your account number,

00:37:36.570 --> 00:37:39.520
your supplier's account
number, and the amount of money

00:37:39.520 --> 00:37:41.769
that you want to transfer.

00:37:41.769 --> 00:37:43.310
The good thing is
that all this stuff

00:37:43.310 --> 00:37:45.580
has gone underneath the
covers, and you don't actually

00:37:45.580 --> 00:37:47.180
have to deal with it if
you are writing the client

00:37:47.180 --> 00:37:48.150
or you are writing the service.

00:37:48.150 --> 00:37:49.750
All this work
happens underneath.

00:37:49.750 --> 00:37:54.150
So, it greatly simplifies
your ability to take,

00:37:54.150 --> 00:37:56.760
implement client
service programs

00:37:56.760 --> 00:38:08.950
with clients and services being
separated from one another.

00:38:08.950 --> 00:38:10.980
OK.

00:38:10.980 --> 00:38:12.480
So, so far, we've
made it look a lot

00:38:12.480 --> 00:38:14.771
except for this little timer
that you have to maintain.

00:38:14.771 --> 00:38:20.660
We've made it look a lot
like a remote procedure call,

00:38:20.660 --> 00:38:21.786
it's like a procedure call.

00:38:21.786 --> 00:38:23.576
In fact, the code here,
the only difference

00:38:23.576 --> 00:38:25.010
is you replace
what was previously

00:38:25.010 --> 00:38:27.610
what would have been one
big transfer with arguments

00:38:27.610 --> 00:38:30.576
we replace with a
stub call, taking

00:38:30.576 --> 00:38:31.950
the name of the
procedure we want

00:38:31.950 --> 00:38:33.740
to run on the service
[NOISE  OBSCURES].

00:38:33.740 --> 00:38:36.930
So, it looks a lot
like a procedure call.

00:38:36.930 --> 00:38:38.680
That actually is a
pretty deceptive thing.

00:38:38.680 --> 00:38:40.930
And in fact, a
hint at that is you

00:38:40.930 --> 00:38:43.870
can get at the bottom
of this thing up there,

00:38:43.870 --> 00:38:47.540
there is a light
that says you have

00:38:47.540 --> 00:38:50.720
to deal with XML RPC exception.

00:38:50.720 --> 00:38:53.620
And that's the kind of exception
you get when the underlying RPC

00:38:53.620 --> 00:38:55.650
library decides
that it hasn't heard

00:38:55.650 --> 00:38:58.460
an answer from the service in a
while, it throws an exception.

00:38:58.460 --> 00:39:00.460
And your code has
to deal with it.

00:39:00.460 --> 00:39:02.960
You are never going to
get that kind of exception

00:39:02.960 --> 00:39:04.210
from a regular procedure call.

00:39:04.210 --> 00:39:06.150
I didn't hear back
from the caller

00:39:06.150 --> 00:39:08.080
or from the callee
to do something.

00:39:08.080 --> 00:39:13.120
See, that's a new exception
mode that you didn't previously

00:39:13.120 --> 00:39:15.200
have to deal with.

00:39:15.220 --> 00:39:16.840
I mean, you have to deal with
other kinds of exceptions

00:39:16.840 --> 00:39:19.160
but not this one.

00:39:19.160 --> 00:39:22.240
So, an RPC is not the
same as a procedure call.

00:39:22.240 --> 00:39:24.820
And in fact, it's a
little unfortunate

00:39:24.840 --> 00:39:31.040
that, for historical reasons, we
are stuck a little bit with a remote

00:39:31.040 --> 00:39:32.580
procedure call.

00:39:32.580 --> 00:39:36.080
In fact, increasingly
more and more RPC systems

00:39:36.080 --> 00:39:38.440
don't look like
procedure calls at all

00:39:38.440 --> 00:39:40.760
in terms of the semantics.

00:39:40.760 --> 00:39:42.240
But we were so
stuck with the name

00:39:42.260 --> 00:39:45.360
that people continue to have
various kinds of remote procedure

00:39:45.360 --> 00:39:47.480
calls, and they used
the same name for it.

00:39:48.840 --> 00:39:51.120
And the first main difference
arises from the fact

00:39:51.120 --> 00:39:57.300
that there is no fate sharing
between client and service.

00:39:57.300 --> 00:39:59.160
If the service crashes,
the client doesn't crash.

00:39:59.160 --> 00:40:00.960
Already you have
a big difference

00:40:00.960 --> 00:40:05.150
between a regular
procedure call.

00:40:05.150 --> 00:40:08.320
And previously I presented
this as an advantage

00:40:08.320 --> 00:40:11.450
because if you have
fate sharing, then

00:40:11.450 --> 00:40:14.920
this caller is always at
the mercy of the callee.

00:40:14.920 --> 00:40:16.580
But because you have
no fate sharing,

00:40:16.580 --> 00:40:19.317
you have other
problems to deal with.

00:40:19.317 --> 00:40:21.400
And in particular, all of
these stem from the fact

00:40:21.400 --> 00:40:25.050
that it's extremely hard to
distinguish between a failure

00:40:25.050 --> 00:40:27.570
versus extremely slow.

00:40:34.590 --> 00:40:36.720
And it will turn out
that we revisit this

00:40:36.720 --> 00:40:38.020
over and over again.

00:40:38.020 --> 00:40:40.900
We'll talk about networks
and reliable transmission

00:40:40.900 --> 00:40:42.640
over networks and
deal with it, and then

00:40:42.640 --> 00:40:44.410
we're going to talk
about fall tolerance,

00:40:44.410 --> 00:40:47.415
and we're going to talk about
an idea for atomicity,

00:40:47.415 --> 00:40:49.540
and then we're going to
talk about something called

00:40:49.540 --> 00:40:50.322
transactions.

00:40:50.322 --> 00:40:52.280
And they're all going to
deal with this problem

00:40:52.280 --> 00:40:55.150
that it's going to be
very hard for us to tell,

00:40:55.150 --> 00:40:57.240
when you ask somebody
to do a piece of work,

00:40:57.240 --> 00:41:00.130
whether they did it
fully or did nothing.

00:41:00.130 --> 00:41:03.470
OK, and this is going
to be a repeated theme,

00:41:03.470 --> 00:41:06.320
a theme that is going
to repeat in the course.

00:41:06.320 --> 00:41:11.020
But to complicate
why this is hard,

00:41:11.020 --> 00:41:13.050
let me say three
possible things that

00:41:13.050 --> 00:41:15.680
could happen when you have
a client talk to service

00:41:15.680 --> 00:41:20.200
and what kind of semantics you
want from a client They all

00:41:20.200 --> 00:41:23.170
stem from the fact that this
is extremely hard to determine.

00:41:23.170 --> 00:41:25.840
The first semantics
that you might want

00:41:25.840 --> 00:41:27.360
is the idea semantic.

00:41:27.360 --> 00:41:31.560
The client talks to the service,
and either the service answers

00:41:31.560 --> 00:41:33.500
with a response or it doesn't.

00:41:33.500 --> 00:41:36.840
OK, and that's something
called exactly-once semantics.

00:41:40.750 --> 00:41:43.160
So in this example here,
underneath the library,

00:41:43.160 --> 00:41:44.040
it may time out.

00:41:44.040 --> 00:41:45.370
And it may wish to retransmit.

00:41:45.370 --> 00:41:47.890
Or it may wish to throw an
exception at the caller.

00:41:47.890 --> 00:41:51.670
The client may want
to send this again.

00:41:51.670 --> 00:41:55.160
But in an ideal case,
you want exactly

00:41:55.160 --> 00:41:57.270
once this amount of money
to be moved from bank

00:41:57.270 --> 00:41:58.980
account one to bank
account two, right?

00:41:58.980 --> 00:42:01.350
You certainly don't want
your amount of money

00:42:01.350 --> 00:42:03.770
to be moved twice
to your supplier.

00:42:03.770 --> 00:42:06.740
The term of this
is ideal, and it's

00:42:06.740 --> 00:42:09.300
going to be pretty difficult,
and extremely hard,

00:42:09.300 --> 00:42:12.310
to achieve
exactly-once semantics.

00:42:12.310 --> 00:42:14.847
And, we're going to talk
about different methods

00:42:14.847 --> 00:42:15.430
in the course.

00:42:15.430 --> 00:42:17.704
This is not an easy
problem at all.

00:42:17.704 --> 00:42:19.870
It stems from the fact that
it is very hard to know.

00:42:22.610 --> 00:42:24.100
So, you might give
up a little bit

00:42:24.100 --> 00:42:27.700
and say, OK, I can't really
get exactly-once semantics

00:42:27.700 --> 00:42:28.660
very easily.

00:42:28.660 --> 00:42:31.200
But let me try
for at least once.

00:42:34.100 --> 00:42:38.480
So what this means is the
client will keep retrying or the

00:42:38.480 --> 00:42:39.930
the library will keep retrying.

00:42:39.930 --> 00:42:41.900
And you can decompose
it in either way

00:42:41.900 --> 00:42:45.960
until it is sure that this
call succeeded at least once.

00:42:45.960 --> 00:42:49.640
Now, it might have
succeeded more than once

00:42:49.640 --> 00:42:51.494
because the service
is very slow.

00:42:51.494 --> 00:42:52.410
And then it times out.

00:42:52.410 --> 00:42:54.618
You try it again, the service
says, oh, OK, I see it;

00:42:54.618 --> 00:42:55.810
I must not do it again.

00:42:55.810 --> 00:42:58.610
But, it's at least once, OK?

00:42:58.610 --> 00:43:00.820
Now, at least once
is not nice semantics

00:43:00.820 --> 00:43:03.240
that you're using at least
one semantics in your code

00:43:03.240 --> 00:43:06.540
here, right, because your
supplier might end up with $7

00:43:06.540 --> 00:43:08.480
million instead of $1 million.

00:43:08.480 --> 00:43:10.410
But at least once
is OK if the service

00:43:10.410 --> 00:43:14.220
has some kind of semantic
called idem-potent semantics.

00:43:17.990 --> 00:43:21.710
What that means is that when you
do an operation more than once,

00:43:21.710 --> 00:43:24.860
the answers are the
same as at-least-once.

00:43:24.860 --> 00:43:28.070
A simple example of this
was the transfer of money,

00:43:28.070 --> 00:43:30.440
but you checking
your bank account

00:43:30.440 --> 00:43:33.317
It doesn't really matter that
you do it a hundred times.

00:43:33.317 --> 00:43:35.900
As long as one of them succeeds
and you get your bank balance,

00:43:35.900 --> 00:43:36.350
you are fine.

00:43:36.350 --> 00:43:37.920
I mean, doing it seven
times does not really

00:43:37.920 --> 00:43:40.570
change anything; it does not
move extra money anywhere else.

00:43:40.570 --> 00:43:43.347
So that's an example of
an idem-potent action,

00:43:43.347 --> 00:43:45.430
which works out well with
at-least-once semantics.

00:43:49.910 --> 00:43:52.440
And at-least-once
semantics is much easier

00:43:52.440 --> 00:43:58.400
to obtain than
exactly-once semantics.

00:43:58.400 --> 00:44:03.430
And the third kind of semantics
is something converse:

00:44:03.430 --> 00:44:06.720
most-once semantics.

00:44:06.720 --> 00:44:08.420
That means zero or more times.

00:44:11.290 --> 00:44:13.750
And here, the
challenge is really

00:44:13.750 --> 00:44:17.740
figuring out if it really
worked at least once around.

00:44:17.740 --> 00:44:19.120
I mean, I pushed once or not.

00:44:19.120 --> 00:44:23.154
So, if you don't get a response
back, then you time out.

00:44:23.154 --> 00:44:25.070
And it might be that it
didn't succeed at all.

00:44:25.070 --> 00:44:26.070
And you say that's fine.

00:44:26.070 --> 00:44:27.460
I'll deal with it separately.

00:44:27.460 --> 00:44:30.286
And if you get a response back,
then you know that it worked.

00:44:30.286 --> 00:44:32.410
It turns out, even that is
going to be a little bit

00:44:32.410 --> 00:44:33.243
tricky to implement.

00:44:33.243 --> 00:44:35.320
But these kinds of
semantics you could

00:44:35.320 --> 00:44:38.480
expect from your RPC system.

00:44:38.480 --> 00:44:41.596
Now, actually the first R in
most RPC systems like XML RPC

00:44:41.596 --> 00:44:43.720
don't really deal with any
of this in a particular,

00:44:43.720 --> 00:44:45.094
I mean, they don't
really provide

00:44:45.094 --> 00:44:46.290
any well-defined semantics.

00:44:46.290 --> 00:44:48.450
It's usually for the
client sitting on top,

00:44:48.450 --> 00:44:49.950
and the service is
still, they don't

00:44:49.950 --> 00:44:51.580
know what kind of
semantics they need,

00:44:51.580 --> 00:44:54.430
and implement that at
a higher layer at least

00:44:54.430 --> 00:44:56.820
with most of these
standard protocols.

00:44:56.820 --> 00:44:58.560
But many of them
are well equipped

00:44:58.560 --> 00:45:01.710
to deal with
at-least-once semantics.

00:45:01.710 --> 00:45:04.450
OK, and through
the course, there

00:45:04.450 --> 00:45:05.840
are different ways
in which we'll

00:45:05.840 --> 00:45:08.010
accomplish these
different goals,

00:45:08.010 --> 00:45:15.050
these different semantics that
we want from our different RPC

00:45:15.050 --> 00:45:16.040
systems.

00:45:16.040 --> 00:45:24.010
Now, there's another difference
between regular procedure calls

00:45:24.010 --> 00:45:26.210
and remote procedure
calls, or more

00:45:26.210 --> 00:45:29.660
generally from client service.

00:45:29.660 --> 00:45:32.310
Remember in the
second lecture, I

00:45:32.310 --> 00:45:35.050
told you that you can
always get more bandwidth,

00:45:35.050 --> 00:45:37.526
and you can always get more
processing past Moore's law,

00:45:37.526 --> 00:45:39.150
but one thing you
can't actually change

00:45:39.150 --> 00:45:42.320
is the legacy between
two computers connected

00:45:42.320 --> 00:45:43.850
by a wire connected
by a network.

00:45:43.850 --> 00:45:46.630
The speed of light
doesn't change.

00:45:46.630 --> 00:45:49.090
What that means
is that with time,

00:45:49.090 --> 00:45:51.000
the number of constructions
that you can run,

00:45:51.000 --> 00:45:53.000
when you have two computers
separated by a wire,

00:45:53.000 --> 00:45:55.600
there is a certain delay between
that no matter what you do.

00:45:55.600 --> 00:45:58.280
So there is a certain delay that
you do a procedure call that's

00:45:58.280 --> 00:45:59.490
a remote procedure call.

00:45:59.490 --> 00:46:00.870
It takes a certain
delay to send a message

00:46:00.870 --> 00:46:01.994
and to get a response back.

00:46:01.994 --> 00:46:04.360
Even as computers get faster
and faster and faster,

00:46:04.360 --> 00:46:06.447
that isn't changing at all.

00:46:06.447 --> 00:46:08.530
But the problem is that
the number of instructions

00:46:08.530 --> 00:46:10.110
you can run but
within that duration

00:46:10.110 --> 00:46:12.610
is increasing with time because
it's a fixed amount of time,

00:46:12.610 --> 00:46:14.776
and the number of instructions
you could run locally

00:46:14.776 --> 00:46:18.430
on the computer
increases with time.

00:46:18.430 --> 00:46:22.940
So that has led people to be
more aggressive about what they

00:46:22.940 --> 00:46:24.721
do in a remote procedure call.

00:46:24.721 --> 00:46:26.720
What people said is, wait,
it doesn't make sense

00:46:26.720 --> 00:46:30.380
for a client to issue
a procedure call,

00:46:30.380 --> 00:46:31.960
relocate to a
service, and then just

00:46:31.960 --> 00:46:35.490
sit and wait like in a regular
procedure call, for the answer.

00:46:35.490 --> 00:46:37.810
I mean, I'm just sitting
there twiddling my thumbs,

00:46:37.810 --> 00:46:41.170
and this thing is that way, and
I'm waiting for it to respond.

00:46:41.170 --> 00:46:44.290
I could be doing work.

00:46:44.290 --> 00:46:51.370
So, that's led people to
changing the synchronous model

00:46:51.370 --> 00:46:53.680
of RPC, of a procedure
call interface

00:46:53.680 --> 00:46:56.190
to do something called
asynchronous procedure call

00:46:56.190 --> 00:46:56.690
interface.

00:46:56.690 --> 00:46:59.909
And all the things like
XML RPC and its follow-on,

00:46:59.909 --> 00:47:01.700
and the difference
between SOAP and XML RPC

00:47:01.700 --> 00:47:05.950
is that I can understand this,
and this builds on XML RPC.

00:47:05.950 --> 00:47:11.820
It seems like very few
people understand SOAP.

00:47:11.820 --> 00:47:14.440
There is a lot of
people who have given up

00:47:14.440 --> 00:47:16.670
on trying to understand
the specification.

00:47:16.670 --> 00:47:20.300
But XML RPC turns out to be a
really simple seven or ten page

00:47:20.300 --> 00:47:22.320
document that's very
easy to understand.

00:47:22.320 --> 00:47:24.330
A lot of people use it.

00:47:24.330 --> 00:47:27.620
But anyway, all these systems
support asynchronous RPC.

00:47:27.620 --> 00:47:30.380
The idea here is
that the client sends

00:47:30.380 --> 00:47:33.150
a procedure call indicating a
remote request to the service.

00:47:33.150 --> 00:47:36.260
And then it goes
about doing its work.

00:47:36.260 --> 00:47:38.430
When the service
responds with an answer,

00:47:38.430 --> 00:47:40.580
it responds with not
just the answer, but also

00:47:40.580 --> 00:47:42.630
something that tells
the client which

00:47:42.630 --> 00:47:44.760
service request, which
procedure caller request

00:47:44.760 --> 00:47:47.300
it's responding to.

00:47:47.300 --> 00:47:52.050
And when the response comes
back, the client can handle it.

00:47:52.050 --> 00:47:54.570
Now, the way in which you
have to implement this,

00:47:54.570 --> 00:47:55.990
or the way you
have to design this

00:47:55.990 --> 00:47:58.780
is that associated with
every procedure call request,

00:47:58.780 --> 00:48:00.480
you also have to
associate what's

00:48:00.480 --> 00:48:03.260
called a handler
because you're going

00:48:03.260 --> 00:48:05.630
to issue this request
to the service

00:48:05.630 --> 00:48:07.260
and then go about
doing your work.

00:48:07.260 --> 00:48:11.360
When the answer comes back,
the RPC library underneath,

00:48:11.360 --> 00:48:14.141
the communication library has
to know: who gets this answer?

00:48:14.141 --> 00:48:16.390
Because you might have to a
sheet of many such service

00:48:16.390 --> 00:48:17.160
requests.

00:48:17.160 --> 00:48:19.000
So who gets this answer?

00:48:19.000 --> 00:48:21.770
So you associate
with every request

00:48:21.770 --> 00:48:23.940
a callback, a handler,
which then is called back.

00:48:23.940 --> 00:48:26.550
And that handler runs,
dealing with the answer that

00:48:26.550 --> 00:48:27.740
comes back.

00:48:27.740 --> 00:48:31.350
And so, that actually allows you
to be a little more decoupled

00:48:31.350 --> 00:48:33.830
than we were with the remote
procedure call; even more

00:48:33.830 --> 00:48:34.330
decoupled.

00:48:34.330 --> 00:48:36.280
The client services
are even more decoupled

00:48:36.280 --> 00:48:39.350
because the client is no
longer waiting for the service

00:48:39.350 --> 00:48:43.270
to return an answer to.

00:48:43.270 --> 00:48:46.390
So that's the first way which
people have extended it.

00:48:46.390 --> 00:48:48.260
The second way in which
people have extended

00:48:48.260 --> 00:48:51.680
is using this intermediary
idea that we talked about

00:48:51.680 --> 00:48:55.010
before where the services
cross the intermediary.

00:48:55.010 --> 00:48:58.250
To use this intermediary
idea to actually make

00:48:58.250 --> 00:49:02.430
design remote message based
communication systems where

00:49:02.430 --> 00:49:07.160
the client and service
don't actually have to be up

00:49:07.160 --> 00:49:09.300
and running at the same time.

00:49:09.300 --> 00:49:13.260
So actually, the client
could send a request out

00:49:13.260 --> 00:49:14.092
to the service.

00:49:14.092 --> 00:49:16.050
But the service is actually
not up and running.

00:49:16.050 --> 00:49:18.000
So, the idea is there
is an intermediary that

00:49:18.000 --> 00:49:20.240
acts as a broker on
behalf of the service,

00:49:20.240 --> 00:49:21.980
and buffers the message.

00:49:21.980 --> 00:49:23.360
And then, when the
service comes up,

00:49:23.360 --> 00:49:26.380
the service knows to pull the
message from this intermediary.

00:49:26.380 --> 00:49:27.800
That's buffered
messages, correct?

00:49:27.800 --> 00:49:30.120
And then it processes the message,
and then pushes the answer

00:49:30.120 --> 00:49:32.420
back to the
intermediary, which then

00:49:32.420 --> 00:49:35.059
stores the message to some
other intermediary perhaps.

00:49:35.059 --> 00:49:36.850
And then the client
knows to get the answer

00:49:36.850 --> 00:49:38.230
from that intermediary.

00:49:38.230 --> 00:49:40.580
So now, we can actually
have clients and services

00:49:40.580 --> 00:49:43.330
that interact with each
other without actually

00:49:43.330 --> 00:49:45.510
having to be up and
running at the same time.

00:49:45.510 --> 00:49:48.020
There are many examples
of this, and the notes

00:49:48.020 --> 00:49:53.740
talk about various examples
of intermediary communication.

00:49:53.740 --> 00:49:55.520
So the general summary of
what we've talked about so far

00:49:55.520 --> 00:49:59.680
is that we looked at different
ways of attaining modularity,

00:49:59.680 --> 00:50:02.140
talked about soft
modularity last time,

00:50:02.140 --> 00:50:06.150
and today about a particular way
of enforcing modularity using

00:50:06.150 --> 00:50:07.740
client service organization.

00:50:07.740 --> 00:50:09.320
And the next few
lectures, we are

00:50:09.320 --> 00:50:12.080
going to solve a big weakness
of the current system which

00:50:12.080 --> 00:50:13.960
is that you need many
different computers.

00:50:13.960 --> 00:50:14.960
So we are going to
take these ideas,

00:50:14.960 --> 00:50:17.580
and implement them
all on one computer.

00:50:17.580 --> 00:50:19.560
See you next week Tuesday.

