WEBVTT
Kind: captions
Language: en

00:00:00.500 --> 00:00:01.997
I'm Francesc Campoy.

00:00:01.997 --> 00:00:04.205
And today, I'm going to be
talking about Google Cloud

00:00:04.205 --> 00:00:05.540
Spin.

00:00:05.540 --> 00:00:07.400
Just to have a basic
idea, how many of you

00:00:07.400 --> 00:00:10.360
know what Google Cloud Spin is?

00:00:10.360 --> 00:00:13.740
How many of you have actually
taken a photo with it?

00:00:13.740 --> 00:00:14.360
Only one.

00:00:14.360 --> 00:00:15.140
Wow.

00:00:15.140 --> 00:00:16.490
And me too.

00:00:16.490 --> 00:00:18.540
So you're going to see
what Google Cloud Spin is.

00:00:18.540 --> 00:00:20.560
It's a demo that we
built. Lots of fun.

00:00:20.560 --> 00:00:22.710
And the whole thing is
I'm going to show you

00:00:22.710 --> 00:00:25.930
how we actually made it
with all the fails included.

00:00:25.930 --> 00:00:28.230
There were a lot of them.

00:00:28.230 --> 00:00:31.010
So the idea was,
OK, so let's build

00:00:31.010 --> 00:00:35.540
a demo for GCP NEXT 2016, which
was a month ago, actually,

00:00:35.540 --> 00:00:37.200
in San Francisco.

00:00:37.200 --> 00:00:39.390
And we had two options.

00:00:39.390 --> 00:00:40.640
Well, we had a couple options.

00:00:40.640 --> 00:00:43.860
We had a couple of constraints.

00:00:43.860 --> 00:00:46.590
We needed to be able
to make it in two weeks

00:00:46.590 --> 00:00:50.560
with basically no budget,
which is always fun.

00:00:50.560 --> 00:00:53.452
We're four people, and there
was actually three weeks.

00:00:53.452 --> 00:00:55.910
But in the meanwhile, it was
my birthday, and someone else,

00:00:55.910 --> 00:00:58.510
there were holidays in
the middle, lots of fun.

00:00:58.510 --> 00:01:01.990
So we decided let's just
reuse the one we already have

00:01:01.990 --> 00:01:04.160
from 2015, which is Abelana.

00:01:04.160 --> 00:01:07.120
And if you are interested,
it's an Instagram clone,

00:01:07.120 --> 00:01:08.440
and it's open sourced.

00:01:08.440 --> 00:01:10.210
So you can take it out.

00:01:10.210 --> 00:01:11.490
It's a pretty simple app.

00:01:11.490 --> 00:01:14.970
It's more of an Android
app more than a Cloud app.

00:01:14.970 --> 00:01:17.210
But there is some image
processing on the back.

00:01:17.210 --> 00:01:20.340
That's pretty cool.

00:01:20.340 --> 00:01:22.650
Then someone came with the
idea, like, hey, slow-mo

00:01:22.650 --> 00:01:24.410
is the thing everybody does.

00:01:24.410 --> 00:01:25.470
Why don't we do slow-mo?

00:01:25.470 --> 00:01:28.580
It's like, Android does
slow-mo. iOS does slow-mo.

00:01:28.580 --> 00:01:29.500
Awesome.

00:01:29.500 --> 00:01:30.610
But where is the Cloud?

00:01:30.610 --> 00:01:31.890
Yeah, no.

00:01:31.890 --> 00:01:37.120
But what if we could
do slower than slow-mo?

00:01:37.120 --> 00:01:40.010
What if we could stop time?

00:01:40.010 --> 00:01:45.690
And we had this idea where,
basically, it's like, OK,

00:01:45.690 --> 00:01:49.060
so I love "The Matrix,"
at least the first one.

00:01:49.060 --> 00:01:55.030
So what if we took all of these
pictures at the same time,

00:01:55.030 --> 00:01:59.680
as they do, by using
100 cameras surrounding

00:01:59.680 --> 00:02:00.870
Keanu Reeves in the middle?

00:02:00.870 --> 00:02:03.589
And then we use all
of those pictures

00:02:03.589 --> 00:02:05.130
to generate this
animation that makes

00:02:05.130 --> 00:02:07.410
the effect of stopping time?

00:02:07.410 --> 00:02:10.172
I was like, that is awesome.

00:02:10.172 --> 00:02:12.130
And then I went to my
manager, I was like, hey,

00:02:12.130 --> 00:02:13.526
I want to buy 100 cameras.

00:02:13.526 --> 00:02:18.190
And he was like, no.

00:02:18.190 --> 00:02:19.840
Which I understand.

00:02:19.840 --> 00:02:22.810
So how do you reduce the budget?

00:02:22.810 --> 00:02:24.280
Well, two ways.

00:02:24.280 --> 00:02:26.640
Instead of 100 very
expensive cameras,

00:02:26.640 --> 00:02:29.080
let's reuse 20 phones
we already have.

00:02:29.080 --> 00:02:31.600
So we had 20 Android
phones together.

00:02:31.600 --> 00:02:34.830
And then instead of having
Keanu Reeves or whoever,

00:02:34.830 --> 00:02:36.280
just have me.

00:02:36.280 --> 00:02:39.840
Much cheaper, I guarantee.

00:02:39.840 --> 00:02:40.890
And this is what we did.

00:02:40.890 --> 00:02:42.690
We had 20 phones.

00:02:42.690 --> 00:02:45.760
And then we talked to
our friends in Android,

00:02:45.760 --> 00:02:50.190
it was like, hey, so we want
to take 20 pictures exactly

00:02:50.190 --> 00:02:53.680
at the same time
over the network.

00:02:53.680 --> 00:02:56.170
And they were
like, sure, try it.

00:02:56.170 --> 00:02:57.670
And that's pretty
much what you get.

00:02:57.670 --> 00:03:01.670
You get 20 pictures that
are around the same time,

00:03:01.670 --> 00:03:04.010
but definitely not good enough.

00:03:04.010 --> 00:03:05.510
And then we had this idea.

00:03:05.510 --> 00:03:09.210
OK, so instead of taking
pictures, let's make a video.

00:03:09.210 --> 00:03:12.880
So what we do is we
have a 6 seconds video.

00:03:12.880 --> 00:03:15.870
Now that variability of
when the picture is taken

00:03:15.870 --> 00:03:19.600
is now when the video
starts, which is fine,

00:03:19.600 --> 00:03:22.190
because then we're going to
use it like on the movies.

00:03:22.190 --> 00:03:23.608
We're going to use that clap.

00:03:23.608 --> 00:03:27.350
[CLAP] And that's my
animation for clap.

00:03:27.350 --> 00:03:29.780
And that's going to be
the synchronization point.

00:03:29.780 --> 00:03:32.270
And then we stop the video.

00:03:32.270 --> 00:03:33.210
Cool.

00:03:33.210 --> 00:03:37.250
So once we had the idea and
pretty much the concept,

00:03:37.250 --> 00:03:40.410
we created this beautiful,
beautiful diagram.

00:03:40.410 --> 00:03:42.960
This is an engineering
diagram, basically, it

00:03:42.960 --> 00:03:47.460
shows there's a circle,
there's degrees, and that's it.

00:03:47.460 --> 00:03:51.250
So 19 phones, then degrees,
180 degrees, everything works.

00:03:51.250 --> 00:03:52.342
We're happy.

00:03:52.342 --> 00:03:53.800
And then we sent
this to marketing,

00:03:53.800 --> 00:03:56.800
and they were like, yeah,
it's going to look like this.

00:03:56.800 --> 00:04:00.670
And we're like,
yeah, that is cool.

00:04:00.670 --> 00:04:01.620
That is much better.

00:04:01.620 --> 00:04:03.636
And that's actually
how it looks like.

00:04:03.636 --> 00:04:05.010
This is the first
time we did it.

00:04:05.010 --> 00:04:06.730
This is in New York.

00:04:06.730 --> 00:04:10.260
And this is really cool.

00:04:10.260 --> 00:04:12.290
And this is one of
the first trials

00:04:12.290 --> 00:04:14.610
we did with the whole demo.

00:04:14.610 --> 00:04:16.550
And I hope you're going
to be able to hear.

00:04:16.550 --> 00:04:18.334
There's two important
things here.

00:04:18.334 --> 00:04:20.750
One is listen to the noise,
the background noise, and also

00:04:20.750 --> 00:04:21.720
the beep.

00:04:21.720 --> 00:04:27.294
And also, pay attention to
where the black duct tape goes.

00:04:30.719 --> 00:04:34.100
[CRACKLING]

00:04:34.100 --> 00:04:35.070
[BEEP]

00:04:35.070 --> 00:04:36.150
That's my head.

00:04:36.150 --> 00:04:37.590
Yes.

00:04:37.590 --> 00:04:39.290
So the important
thing is that you

00:04:39.290 --> 00:04:42.751
hear that noise, the background
noise, that is part of life.

00:04:42.751 --> 00:04:44.250
There's background
noise everywhere.

00:04:44.250 --> 00:04:45.490
You have to deal with it.

00:04:45.490 --> 00:04:47.710
But we need to find
that noisy frame,

00:04:47.710 --> 00:04:49.650
and then from that
noisy frame, we're

00:04:49.650 --> 00:04:54.390
able to extract one image,
which is this image here.

00:04:54.390 --> 00:05:00.000
Then we have 19 phones, so we
extract more, more, more, more.

00:05:00.000 --> 00:05:01.810
And then we put it together.

00:05:01.810 --> 00:05:04.350
And then we stop time,
which is pretty amazing.

00:05:04.350 --> 00:05:06.210
And it looks
really, really cool,

00:05:06.210 --> 00:05:08.320
taking into account that
everything you need here

00:05:08.320 --> 00:05:13.210
is just a bunch of
phones and writing code.

00:05:13.210 --> 00:05:15.340
So the backend architecture,
how does this work?

00:05:15.340 --> 00:05:17.990
Well, we upload videos.

00:05:17.990 --> 00:05:20.650
Magically, we process them.

00:05:20.650 --> 00:05:24.620
We extract a single
frame from that video.

00:05:24.620 --> 00:05:27.340
Then we put all those
frames together,

00:05:27.340 --> 00:05:29.600
and we stitch them into one
single animation, video,

00:05:29.600 --> 00:05:31.790
or GIF.

00:05:31.790 --> 00:05:33.970
And then we display it.

00:05:33.970 --> 00:05:36.140
And this is the whole thing.

00:05:36.140 --> 00:05:40.610
Now the next step is like,
sure, how do you do this?

00:05:40.610 --> 00:05:42.750
And that's the rest of the talk.

00:05:42.750 --> 00:05:47.770
So the first part is,
how do I tell 20 phones,

00:05:47.770 --> 00:05:50.660
take a picture now,
at the same time?

00:05:50.660 --> 00:05:52.580
And every single
one of the phones

00:05:52.580 --> 00:05:56.680
knows what's their ID, what
is the picture quality that I

00:05:56.680 --> 00:06:02.070
want, all the things that you
need to specify for a picture?

00:06:02.070 --> 00:06:08.000
Well, let's see,
actually, this demo now.

00:06:08.000 --> 00:06:11.740
It's going to give you a
bigger idea of what kind

00:06:11.740 --> 00:06:15.160
of synchronization we need.

00:06:15.160 --> 00:06:17.739
This is Ray, one of the guys
that helped with the demo.

00:06:17.739 --> 00:06:19.030
And you can see all the phones.

00:06:19.030 --> 00:06:19.950
And they're green.

00:06:19.950 --> 00:06:22.730
That's because they're
ready to record.

00:06:22.730 --> 00:06:25.570
Then we have that tablet that
said, OK, start recording.

00:06:25.570 --> 00:06:29.430
Yellow means wait a second,
I'm starting to record.

00:06:29.430 --> 00:06:32.100
Blue means I'm recording.

00:06:32.100 --> 00:06:33.100
Then Ray jumps.

00:06:33.100 --> 00:06:34.340
We press a button.

00:06:34.340 --> 00:06:36.480
And actually, that
button sends the audio

00:06:36.480 --> 00:06:38.260
through all the cables.

00:06:38.260 --> 00:06:41.190
And then we have
this dashboard that

00:06:41.190 --> 00:06:44.680
is going to be showing
everything that is going on.

00:06:44.680 --> 00:06:47.660
So the videos now
are being uploaded.

00:06:47.660 --> 00:06:52.967
We were over conference
Wi-Fi, so good luck with that.

00:06:52.967 --> 00:06:54.050
But it takes a little bit.

00:06:54.050 --> 00:06:56.080
But now, all those
[INAUDIBLE] it

00:06:56.080 --> 00:06:58.280
means that we're now
extracting the frames.

00:06:58.280 --> 00:07:00.080
You can now see the frames.

00:07:00.080 --> 00:07:03.150
And once all the frames have
been extracted together,

00:07:03.150 --> 00:07:05.940
we'll be able to actually stitch
them together and generate

00:07:05.940 --> 00:07:07.600
the image.

00:07:07.600 --> 00:07:10.380
The cool thing is that this
dashboard was created two days

00:07:10.380 --> 00:07:12.410
before the demo.

00:07:12.410 --> 00:07:15.410
And how was it possible for
us to build these things

00:07:15.410 --> 00:07:16.292
so easily?

00:07:16.292 --> 00:07:18.500
It was actually because the
synchronization mechanism

00:07:18.500 --> 00:07:21.030
that we used was very powerful.

00:07:21.030 --> 00:07:22.450
Almost there.

00:07:22.450 --> 00:07:26.810
Yeah, the Wi-Fi still upsets
me when I see the video.

00:07:26.810 --> 00:07:29.570
I know it's going to
happen, but still.

00:07:29.570 --> 00:07:30.240
There you go.

00:07:30.240 --> 00:07:33.780
The last video gets
uploaded, extracted.

00:07:33.780 --> 00:07:35.700
We stitch everything
together and then

00:07:35.700 --> 00:07:38.570
we put it into
the upload bucket.

00:07:38.570 --> 00:07:40.050
And then you get Ray.

00:07:40.050 --> 00:07:43.195
Ray is about to jump.

00:07:43.195 --> 00:07:45.070
The picture was taken
a little bit too early.

00:07:45.070 --> 00:07:46.903
That's actually kind
of the hard part of it.

00:07:50.300 --> 00:07:53.650
So we want to be able to
synchronize a bunch of devices.

00:07:53.650 --> 00:07:55.100
We want real-time notifications.

00:07:55.100 --> 00:07:57.070
Start recording has
to happen right now.

00:07:57.070 --> 00:07:58.180
You cannot wait.

00:07:58.180 --> 00:08:01.470
If you wait for too long,
the video is only 6 seconds.

00:08:01.470 --> 00:08:02.689
You will miss it.

00:08:02.689 --> 00:08:04.480
We need to be able to
have diverse clients.

00:08:04.480 --> 00:08:07.020
We've seen the Android
phones, but we also

00:08:07.020 --> 00:08:10.150
have things like our
web dashboard needs

00:08:10.150 --> 00:08:12.630
to be able to get that data.

00:08:12.630 --> 00:08:14.630
And then our extractors,
our stitchers,

00:08:14.630 --> 00:08:16.130
and all the other
workers need to be

00:08:16.130 --> 00:08:20.370
able to also modify the status.

00:08:20.370 --> 00:08:23.270
And then also, I don't want to
be pulling data all the time.

00:08:23.270 --> 00:08:24.260
Is this frame ready?

00:08:24.260 --> 00:08:25.110
Is this frame ready?

00:08:25.110 --> 00:08:25.609
No.

00:08:25.609 --> 00:08:29.380
I just want to say, just let
me know when this is ready.

00:08:29.380 --> 00:08:32.190
And obviously, we used Firebase.

00:08:32.190 --> 00:08:33.429
Why did we use Firebase?

00:08:33.429 --> 00:08:37.024
Well, because this
console is pretty amazing.

00:08:37.024 --> 00:08:39.190
The fact that I can see
what's going on in my system

00:08:39.190 --> 00:08:42.200
before building any dashboard,
for me, that's a huge thing.

00:08:42.200 --> 00:08:43.650
Especially when
you're debugging,

00:08:43.650 --> 00:08:46.380
and you have weird
bugs like, oh, someone

00:08:46.380 --> 00:08:48.100
misspelled this
name on this field.

00:08:48.100 --> 00:08:49.000
Things happen.

00:08:49.000 --> 00:08:51.730
So the fact that you're able
to see it here so easily

00:08:51.730 --> 00:08:54.370
is pretty powerful.

00:08:54.370 --> 00:08:59.015
It has three main clients, for
JavaScript, iOS, and Android.

00:08:59.015 --> 00:09:01.860
And in Java, this is
a part of the code

00:09:01.860 --> 00:09:04.750
that we have to be
able to send the status

00:09:04.750 --> 00:09:05.800
of the current camera.

00:09:05.800 --> 00:09:08.730
So we're saying, camera
number 1 is ready to record,

00:09:08.730 --> 00:09:11.734
and it's getting input from
external mic or internal mic.

00:09:11.734 --> 00:09:13.150
We actually care
about that a lot,

00:09:13.150 --> 00:09:17.152
so when we show the state,
external mic is green,

00:09:17.152 --> 00:09:18.110
internal mic is yellow.

00:09:18.110 --> 00:09:19.810
And if something
fails, it's red.

00:09:19.810 --> 00:09:21.268
So at least from
the tablet, you're

00:09:21.268 --> 00:09:24.090
actually able to see the
status of all the phones.

00:09:24.090 --> 00:09:27.870
You're also able to modify the
ISO for the pictures, which

00:09:27.870 --> 00:09:28.500
is very cool.

00:09:28.500 --> 00:09:29.560
Because imagine if
you had to change

00:09:29.560 --> 00:09:31.400
the ISO in every single
phone separately.

00:09:31.400 --> 00:09:33.617
We did that once, only once.

00:09:36.420 --> 00:09:41.120
And as I said, we had these
three library clients.

00:09:41.120 --> 00:09:45.383
But my favorite API, which
one do you think it is?

00:09:45.383 --> 00:09:49.004
Rest API because
I'm a Cloud man.

00:09:49.004 --> 00:09:50.550
And the cool thing
about Rest API

00:09:50.550 --> 00:09:53.420
is then you can build
things on top of it.

00:09:53.420 --> 00:09:55.220
And I'm also a Gofer.

00:09:55.220 --> 00:09:57.460
So you can actually
write in Go things

00:09:57.460 --> 00:10:00.170
like this that will
modify Firebase from Go.

00:10:00.170 --> 00:10:02.590
And this works perfectly,
and it's super nice to use.

00:10:02.590 --> 00:10:03.840
So I was very happy with this.

00:10:03.840 --> 00:10:05.760
The stitcher is written
in Go completely,

00:10:05.760 --> 00:10:08.880
and it uses Firebase.

00:10:08.880 --> 00:10:11.290
So the extractor is
written in Python.

00:10:11.290 --> 00:10:16.370
It also uses the API, but
it uses the bare Rest API

00:10:16.370 --> 00:10:20.210
without any client
library on top.

00:10:20.210 --> 00:10:22.600
So we have Firebase
in the middle.

00:10:22.600 --> 00:10:24.270
How does this work?

00:10:24.270 --> 00:10:27.220
Well, we upload the
videos with Firebase,

00:10:27.220 --> 00:10:29.160
and we tell the dashboard.

00:10:29.160 --> 00:10:31.380
We extract the frames,
we tell Firebase,

00:10:31.380 --> 00:10:34.060
and we tell the dashboard.

00:10:34.060 --> 00:10:37.480
We stitch all the
frames, we tell Firebase.

00:10:37.480 --> 00:10:40.450
And then we display the result,
and everything is in Firebase.

00:10:40.450 --> 00:10:43.830
So the thing is that
dashboard was created two days

00:10:43.830 --> 00:10:44.990
before the demo.

00:10:44.990 --> 00:10:45.790
Why?

00:10:45.790 --> 00:10:47.650
Because all the data
was already there.

00:10:47.650 --> 00:10:50.070
Everything we had to
do was basically just

00:10:50.070 --> 00:10:52.558
map it into some cute
way of displaying it.

00:10:52.558 --> 00:10:53.516
That was very powerful.

00:10:57.100 --> 00:11:00.210
So media storage,
let's talk about how

00:11:00.210 --> 00:11:03.890
we store all of those videos.

00:11:03.890 --> 00:11:06.500
So we have three places
where we have to store

00:11:06.500 --> 00:11:08.110
videos, media in general.

00:11:08.110 --> 00:11:09.970
We have our videos,
we have the frames,

00:11:09.970 --> 00:11:12.306
and then we have the
generate animations.

00:11:12.306 --> 00:11:13.680
And there's a
couple requirements

00:11:13.680 --> 00:11:14.640
that we have on this.

00:11:14.640 --> 00:11:16.880
First of all, these are videos.

00:11:16.880 --> 00:11:18.650
And every single
one of those videos

00:11:18.650 --> 00:11:21.090
is between 10 and
20 megs depending

00:11:21.090 --> 00:11:23.380
on what you're actually doing.

00:11:23.380 --> 00:11:25.410
But what if we wanted
to do extra things?

00:11:25.410 --> 00:11:27.920
Or what if our animation starts
to get pretty cool, pretty

00:11:27.920 --> 00:11:31.430
crazy, and we started to
have gigabytes of video?

00:11:31.430 --> 00:11:32.470
Maybe terabytes?

00:11:32.470 --> 00:11:33.420
Nah, terabytes, no.

00:11:33.420 --> 00:11:35.410
But what if we had
terabytes of data?

00:11:35.410 --> 00:11:37.560
We need to plan for that.

00:11:37.560 --> 00:11:40.530
Also, we want to be able to
say as soon as a frame has been

00:11:40.530 --> 00:11:42.950
extracted, and I
put it in the disk,

00:11:42.950 --> 00:11:45.686
I want anyone to be
able to go and read it.

00:11:45.686 --> 00:11:47.810
I don't want something that
was like, put it there,

00:11:47.810 --> 00:11:50.560
and then I read it directly,
and I'm like, wait, what?

00:11:50.560 --> 00:11:53.920
And then two seconds later,
oh, yeah, the file was there.

00:11:53.920 --> 00:11:54.440
Sorry.

00:11:54.440 --> 00:11:56.600
That is what we call
eventual consistency.

00:11:56.600 --> 00:11:59.070
I do not want that
for this system.

00:11:59.070 --> 00:12:02.690
And then finally, it'd be very
sweet of every single time

00:12:02.690 --> 00:12:05.800
there's a new file, a new
video, that has been uploaded,

00:12:05.800 --> 00:12:07.495
I could get a
notification from it.

00:12:11.800 --> 00:12:14.550
We have three options to store
data on Google Cloud Platform.

00:12:14.550 --> 00:12:16.770
There's actually a fourth
one, Cloud Bigtable.

00:12:16.770 --> 00:12:20.200
I will not mention it other
than it is a very, very, very

00:12:20.200 --> 00:12:21.020
big table.

00:12:21.020 --> 00:12:23.660
So if your tables
are not that big,

00:12:23.660 --> 00:12:25.560
maybe don't even consider it.

00:12:25.560 --> 00:12:26.680
But we have Datastore.

00:12:26.680 --> 00:12:31.000
Datastore is for structured
data that is non-relational.

00:12:31.000 --> 00:12:32.240
Our data is not structured.

00:12:32.240 --> 00:12:33.510
It's a video.

00:12:33.510 --> 00:12:34.820
We cannot do that.

00:12:34.820 --> 00:12:39.330
SQL is structured data
again that is relational.

00:12:39.330 --> 00:12:41.170
Again, we have
unstructured data.

00:12:41.170 --> 00:12:42.660
We cannot use it.

00:12:42.660 --> 00:12:44.560
The last one, Cloud Storage.

00:12:44.560 --> 00:12:46.380
What do we use
Cloud Storage for?

00:12:46.380 --> 00:12:47.270
Everything else.

00:12:47.270 --> 00:12:52.550
You can store cat videos, and
GIFs, and whatever you want.

00:12:52.550 --> 00:12:58.440
A little bit of the marketing
aspect of Google Cloud Storage.

00:12:58.440 --> 00:13:00.520
You can store terabytes
of data, which

00:13:00.520 --> 00:13:05.210
is way more than a GIF
will ever be, I hope.

00:13:05.210 --> 00:13:06.900
It is very reliable.

00:13:06.900 --> 00:13:09.076
There's three flavors,
and we'll see them later.

00:13:09.076 --> 00:13:10.909
But the highest
availability that we provide

00:13:10.909 --> 00:13:13.690
is 99.9% availability,
which is really good.

00:13:13.690 --> 00:13:15.880
And it's also replicated
across many regions, which

00:13:15.880 --> 00:13:19.520
means that if, for any reason,
a Google data center disappeared

00:13:19.520 --> 00:13:21.472
into the void, you could
still not lose data

00:13:21.472 --> 00:13:23.680
because your data is actually
replicated in many data

00:13:23.680 --> 00:13:25.230
centers.

00:13:25.230 --> 00:13:27.630
And then it actually has
that change notification

00:13:27.630 --> 00:13:28.470
that we wanted.

00:13:28.470 --> 00:13:31.070
We're going to be able to get
notifications every single time

00:13:31.070 --> 00:13:34.360
something happens
in our storage.

00:13:34.360 --> 00:13:37.730
So the three flavors that I
mentioned before are Standard.

00:13:37.730 --> 00:13:40.540
And Standard is the
fastest, the most available.

00:13:40.540 --> 00:13:43.320
And all of them are exactly
the same durability.

00:13:43.320 --> 00:13:44.644
Important thing.

00:13:44.644 --> 00:13:47.590
Durability is, will
we lose your data?

00:13:47.590 --> 00:13:48.542
And the answer is no.

00:13:48.542 --> 00:13:50.000
The durability is
always to the top

00:13:50.000 --> 00:13:52.057
in every single one of them.

00:13:52.057 --> 00:13:54.640
Standard is the one that we're
using because we want something

00:13:54.640 --> 00:13:57.306
that will allow us to access the
information very quick and very

00:13:57.306 --> 00:13:58.100
often.

00:13:58.100 --> 00:13:59.970
If you don't need
that information

00:13:59.970 --> 00:14:02.550
to be available all the time,
but you want it to still

00:14:02.550 --> 00:14:06.350
be pretty quick,
imagine [INAUDIBLE],

00:14:06.350 --> 00:14:09.810
you can use Durable Reduced
Availability Storage.

00:14:09.810 --> 00:14:14.780
It's less available, but the
durability is still there.

00:14:14.780 --> 00:14:16.710
And finally, we have Nearline.

00:14:16.710 --> 00:14:20.630
And Nearline is basically when
you want to store a lot of data

00:14:20.630 --> 00:14:23.214
that you will never read
until you have a bug,

00:14:23.214 --> 00:14:24.630
and then you will
want to read it,

00:14:24.630 --> 00:14:26.610
and it's really
important it's there.

00:14:26.610 --> 00:14:29.470
So all the durability
is there, but instead

00:14:29.470 --> 00:14:34.731
of taking milliseconds to
download the files that you

00:14:34.731 --> 00:14:37.230
put there, you're going to have
to wait an incredible amount

00:14:37.230 --> 00:14:38.840
of seconds.

00:14:38.840 --> 00:14:39.720
So it's not hours.

00:14:39.720 --> 00:14:42.220
It's just seconds.

00:14:42.220 --> 00:14:44.130
A little bit of Android code.

00:14:44.130 --> 00:14:47.670
I'm not a Java person, so
every single time I see so many

00:14:47.670 --> 00:14:49.310
[INAUDIBLE] it's like [GROAN].

00:14:49.310 --> 00:14:54.250
But you first build a
storage with Storage Builder.

00:14:54.250 --> 00:14:57.170
Basically, you give all the
authentication and stuff

00:14:57.170 --> 00:15:01.310
like that to be able to say
this is my storage client.

00:15:01.310 --> 00:15:03.470
Then I create a storage object.

00:15:03.470 --> 00:15:06.980
That is the file
that is going to be.

00:15:06.980 --> 00:15:08.720
And then we have a
file input stream.

00:15:08.720 --> 00:15:12.430
I will actually upload
my video into the output.

00:15:12.430 --> 00:15:14.960
And what could go wrong?

00:15:14.960 --> 00:15:15.600
Exceptions?

00:15:15.600 --> 00:15:16.984
Yeah, sure.

00:15:16.984 --> 00:15:18.900
There are some exceptions
to be handled there,

00:15:18.900 --> 00:15:20.191
but it doesn't fit in the code.

00:15:20.191 --> 00:15:25.980
So just don't copy paste
into production yet.

00:15:25.980 --> 00:15:26.895
Cool.

00:15:26.895 --> 00:15:29.980
So let's talk about Object
Change Notifications.

00:15:29.980 --> 00:15:31.584
Object Change
Notifications allows us

00:15:31.584 --> 00:15:33.750
to every single time there's
a change in our bucket,

00:15:33.750 --> 00:15:37.710
we're going to get a
notification sent to a webhook.

00:15:37.710 --> 00:15:39.991
And you can set
that up with gsutil.

00:15:39.991 --> 00:15:40.490
That's it.

00:15:40.490 --> 00:15:42.300
You say, hey,
gsutil notification,

00:15:42.300 --> 00:15:47.790
watch this bucket, and send
changes to that webhook.

00:15:47.790 --> 00:15:51.110
So now when one of my
phones uploads a video,

00:15:51.110 --> 00:15:53.770
that video will
generate a notification

00:15:53.770 --> 00:15:57.300
sent to my notification
processing endpoint.

00:15:57.300 --> 00:16:00.110
We'll see what that
is in a minute.

00:16:00.110 --> 00:16:01.840
And what is in
that notification?

00:16:01.840 --> 00:16:05.050
Well, it's an HTTP POST request
that has a lot of things

00:16:05.050 --> 00:16:05.626
inside.

00:16:05.626 --> 00:16:07.250
But we care only
about the fact there's

00:16:07.250 --> 00:16:08.400
the name and the bucket.

00:16:08.400 --> 00:16:10.980
So you get the name of the
file and what happened to it.

00:16:10.980 --> 00:16:14.030
It's like, hey, there's a new
file, and there's the name.

00:16:14.030 --> 00:16:15.620
So then inside,
we're going to be

00:16:15.620 --> 00:16:18.610
using a convention
for the file structure

00:16:18.610 --> 00:16:21.310
to decide what picture
is that, what phone is

00:16:21.310 --> 00:16:24.340
that, and all of these things.

00:16:24.340 --> 00:16:24.840
Cool.

00:16:24.840 --> 00:16:27.930
So for the buckets, we
have everything solved.

00:16:27.930 --> 00:16:30.030
Meanwhile, on the
hardware side of things,

00:16:30.030 --> 00:16:34.170
that I'm very happy
not to partake,

00:16:34.170 --> 00:16:36.240
this is Matt, one
of our interns.

00:16:36.240 --> 00:16:39.170
And he wrote the first version
of the sound structure.

00:16:39.170 --> 00:16:40.949
Matt is a very smart intern.

00:16:40.949 --> 00:16:42.240
And I think he's now a Googler.

00:16:42.240 --> 00:16:43.450
I'm not sure.

00:16:43.450 --> 00:16:47.240
He's trying to figure out why
this lamp doesn't turn on.

00:16:47.240 --> 00:16:51.700
When I saw this, I thought,
it's mounted backwards.

00:16:51.700 --> 00:16:52.200
No.

00:16:52.200 --> 00:16:53.670
It's actually mounted correctly.

00:16:53.670 --> 00:16:55.380
But it is not plugged.

00:16:55.380 --> 00:16:58.280
So that is a problem.

00:16:58.280 --> 00:17:01.000
Yeah.

00:17:01.000 --> 00:17:02.440
He's still a very smart guy.

00:17:02.440 --> 00:17:04.770
He wrote really good code.

00:17:04.770 --> 00:17:08.940
This was our first
version of Cloud Spin.

00:17:08.940 --> 00:17:10.940
There's actually a previous
version to this one.

00:17:10.940 --> 00:17:12.560
I could not find
a picture of it.

00:17:12.560 --> 00:17:15.619
But before having tripods,
we had selfie sticks.

00:17:15.619 --> 00:17:18.480
So we had 20 selfie sticks
with phones on them.

00:17:18.480 --> 00:17:19.829
Really not stable.

00:17:19.829 --> 00:17:21.599
I do not recommend.

00:17:21.599 --> 00:17:22.180
Yeah.

00:17:22.180 --> 00:17:24.139
We did not break any
of the phones, which

00:17:24.139 --> 00:17:25.430
I don't know how that happened.

00:17:25.430 --> 00:17:30.590
But yeah, so that was our first
iteration of the processing.

00:17:30.590 --> 00:17:32.130
Back to the software
side of things.

00:17:36.010 --> 00:17:38.140
So we have those
notifications that

00:17:38.140 --> 00:17:39.990
are now being sent somewhere.

00:17:39.990 --> 00:17:42.570
We have to be able
to handle them.

00:17:42.570 --> 00:17:43.740
How do we do it?

00:17:43.740 --> 00:17:47.550
Well, we need to be able to
handle HTTP POST request.

00:17:47.550 --> 00:17:49.080
We saw that that's what we had.

00:17:49.080 --> 00:17:52.030
And we're going to need
to decode that JSON file,

00:17:52.030 --> 00:17:54.162
that JSON object.

00:17:54.162 --> 00:17:55.370
We need to do authentication.

00:17:55.370 --> 00:17:57.725
And we're going to do
authentication two ways.

00:17:57.725 --> 00:17:59.600
We're going to do
authentication to make sure

00:17:59.600 --> 00:18:01.420
that the notification
we're receiving

00:18:01.420 --> 00:18:03.180
is actually a notification
we're receiving

00:18:03.180 --> 00:18:04.960
from the bucket
and not something

00:18:04.960 --> 00:18:07.510
that someone might have
forged, which is something

00:18:07.510 --> 00:18:11.050
that we actually got.

00:18:11.050 --> 00:18:13.380
He was a Googler, but he
was basically trolling us,

00:18:13.380 --> 00:18:14.180
and he did.

00:18:14.180 --> 00:18:16.437
So we decided to add
authentication on that side.

00:18:16.437 --> 00:18:18.020
And also, we need
authentication to be

00:18:18.020 --> 00:18:21.550
able to communicate safely
with the rest of our system.

00:18:21.550 --> 00:18:24.110
And we want that
to be easy to do.

00:18:24.110 --> 00:18:27.950
And then we're going to
need to also use task queues

00:18:27.950 --> 00:18:28.940
or push tasks.

00:18:28.940 --> 00:18:32.590
And we're going to see how
those work in a minute.

00:18:32.590 --> 00:18:34.330
So we're going with App Engine.

00:18:34.330 --> 00:18:35.770
And why did we go
with App Engine?

00:18:35.770 --> 00:18:37.240
Well, we need
something that will

00:18:37.240 --> 00:18:40.990
be able to reply
to ACB requests,

00:18:40.990 --> 00:18:43.940
and that is what App
Engine was made for.

00:18:43.940 --> 00:18:46.010
I am very happy to write
in Go, so all of those

00:18:46.010 --> 00:18:46.990
are written in Go.

00:18:46.990 --> 00:18:48.970
And Go is one of the
languages supported

00:18:48.970 --> 00:18:51.240
by App Engine classic.

00:18:51.240 --> 00:18:54.290
There is Java, PHP,
Python, and Go.

00:18:54.290 --> 00:18:56.420
And it has a lot of constraints.

00:18:56.420 --> 00:18:59.226
You cannot spend more than 60
seconds to reply to a request,

00:18:59.226 --> 00:19:00.600
which we're totally
fine with it.

00:19:00.600 --> 00:19:04.260
You cannot access the file
system in the machine,

00:19:04.260 --> 00:19:05.280
totally fine with it.

00:19:05.280 --> 00:19:06.980
So awesome.

00:19:06.980 --> 00:19:12.740
On the good side of things is
that I get to just send my code

00:19:12.740 --> 00:19:14.210
and forget about it.

00:19:14.210 --> 00:19:15.010
There's no DevOps.

00:19:15.010 --> 00:19:17.180
I don't choose how many
machines or which machines

00:19:17.180 --> 00:19:18.510
should run this thing.

00:19:18.510 --> 00:19:21.300
And if, for any reason,
I have a lot of traffic,

00:19:21.300 --> 00:19:22.960
it would just
autoscale directly.

00:19:22.960 --> 00:19:25.500
There's a lot of
companies that use this.

00:19:25.500 --> 00:19:29.430
Khan Academy, Angry Birds,
and all of these people

00:19:29.430 --> 00:19:32.210
that have very varied traffic,
and you have traffic spikes,

00:19:32.210 --> 00:19:36.320
App Engine manages that
very well for them.

00:19:36.320 --> 00:19:38.750
So we have two flavors.

00:19:38.750 --> 00:19:40.710
And they changed names
not that long ago.

00:19:40.710 --> 00:19:43.417
They used to be called
App Engine in Managed VMs.

00:19:43.417 --> 00:19:45.750
And now, they're called App
Engine Standard Environment,

00:19:45.750 --> 00:19:48.145
which is the one that
I was talking about.

00:19:48.145 --> 00:19:50.270
You're running a sandbox,
and everything is awesome

00:19:50.270 --> 00:19:54.820
as long as you match the
constraints that we have.

00:19:54.820 --> 00:19:57.110
And then we have App Engine
Flexible Environment.

00:19:57.110 --> 00:19:59.800
And App Engine Flexible
Environment, basically,

00:19:59.800 --> 00:20:03.440
give as a Docker container,
and it will run it for you.

00:20:03.440 --> 00:20:06.200
And this is really cool, because
basically, all of a sudden,

00:20:06.200 --> 00:20:07.950
you have the good
things about App Engine,

00:20:07.950 --> 00:20:10.990
it will scale as
much as you need.

00:20:10.990 --> 00:20:13.390
It will not start as fast
because it is not a sandbox.

00:20:13.390 --> 00:20:14.730
It is a VM now.

00:20:14.730 --> 00:20:18.011
So your scaling will not be
as fast as classic App Engine.

00:20:18.011 --> 00:20:19.510
So if you can do
classic App Engine,

00:20:19.510 --> 00:20:22.480
I could still say go with
Standard Environment.

00:20:22.480 --> 00:20:25.880
But if you need
to Go plus FFmpeg,

00:20:25.880 --> 00:20:28.000
for instance, which is
an awesome library that

00:20:28.000 --> 00:20:30.780
doesn't run on
Standard Environment,

00:20:30.780 --> 00:20:34.660
you could do it on a
Flexible Environment.

00:20:34.660 --> 00:20:38.010
So we wrote a Go App Engine
App, and now we're good.

00:20:38.010 --> 00:20:41.830
Except that we're missing the
whole part that does things.

00:20:41.830 --> 00:20:46.630
So how do we manage the fact
that, OK, I got a notification.

00:20:46.630 --> 00:20:48.437
I want to send it somewhere.

00:20:48.437 --> 00:20:50.270
I could send it to the
machine that is doing

00:20:50.270 --> 00:20:52.360
the extraction of the frames.

00:20:52.360 --> 00:20:54.440
But what if that
machine is down?

00:20:54.440 --> 00:20:56.130
What if there's many machines?

00:20:56.130 --> 00:20:57.790
Which one should I send it to?

00:20:57.790 --> 00:21:00.150
Do I need a load balancer?

00:21:00.150 --> 00:21:01.760
Kind of complicated.

00:21:01.760 --> 00:21:03.260
Instead, what I'm
going to do is I'm

00:21:03.260 --> 00:21:07.580
going to use a messaging system,
asynchronous messaging system.

00:21:07.580 --> 00:21:08.520
Why do I want that?

00:21:08.520 --> 00:21:11.200
Well, for availability,
if all of my machines

00:21:11.200 --> 00:21:13.250
are down because I'm
upgrading, or maintaining,

00:21:13.250 --> 00:21:16.610
or I broke it-- things
happen-- I don't

00:21:16.610 --> 00:21:18.480
want people to get errors.

00:21:18.480 --> 00:21:20.050
I want them to
just wait a couple

00:21:20.050 --> 00:21:22.060
more seconds till
that new VM is up,

00:21:22.060 --> 00:21:24.150
and that will be able
to handle the message.

00:21:24.150 --> 00:21:26.920
So that will actually
absorb those problems.

00:21:26.920 --> 00:21:29.230
Also, if you have
too much traffic,

00:21:29.230 --> 00:21:31.250
I don't want to DDoS
my own machines.

00:21:31.250 --> 00:21:33.679
I want those messages to be
there for a little bit longer.

00:21:33.679 --> 00:21:35.470
Yes, you will wait for
a little bit longer,

00:21:35.470 --> 00:21:37.490
but my machines
will not go down.

00:21:37.490 --> 00:21:40.190
And then also, if
there's any outage,

00:21:40.190 --> 00:21:41.260
no one needs to see that.

00:21:41.260 --> 00:21:43.260
Only me.

00:21:43.260 --> 00:21:45.950
On the other hand, there
is better throughput.

00:21:45.950 --> 00:21:50.400
So imagine that you have, all of
a sudden, 1 million videos that

00:21:50.400 --> 00:21:51.680
arrive at the same time.

00:21:51.680 --> 00:21:55.460
And I send 1 million requests
to my three sad machines.

00:21:55.460 --> 00:21:56.730
What will happen?

00:21:56.730 --> 00:21:58.860
Not a single video
will be processed.

00:21:58.860 --> 00:22:00.310
All of the machines
will go down.

00:22:00.310 --> 00:22:02.210
And the new ones
will go down again.

00:22:02.210 --> 00:22:03.870
So sad state of things.

00:22:03.870 --> 00:22:05.900
Instead, with that
messaging, I'm

00:22:05.900 --> 00:22:07.770
going to have a stable
throughput, which

00:22:07.770 --> 00:22:11.249
is as much as machines can
deal with, and then you wait.

00:22:11.249 --> 00:22:12.790
And then you have
timeouts and things

00:22:12.790 --> 00:22:14.900
like that if you really
want to say, oh, yeah,

00:22:14.900 --> 00:22:18.090
it took too long.

00:22:18.090 --> 00:22:20.100
So we're going to
put two queues-- one

00:22:20.100 --> 00:22:23.820
before the extractors and
one before the stitchers.

00:22:23.820 --> 00:22:27.220
And we're going to need
asynchronous messaging.

00:22:27.220 --> 00:22:29.367
And also pull subscriptions.

00:22:29.367 --> 00:22:30.950
And why do we need
pull subscriptions?

00:22:30.950 --> 00:22:32.700
First of all, what are
pull subscriptions?

00:22:35.110 --> 00:22:36.980
Basically, pull
subscriptions are

00:22:36.980 --> 00:22:39.410
the ones where I'm going to
say, is there a new message?

00:22:39.410 --> 00:22:42.276
And then the queue is going
to say, yes, there you go.

00:22:42.276 --> 00:22:43.650
And then I'm going
to process it.

00:22:43.650 --> 00:22:46.220
And once I'm done, I'm going
to say, hey, I'm done with it.

00:22:46.220 --> 00:22:48.970
If, for any reason, I
fail or I forget to say,

00:22:48.970 --> 00:22:52.610
oh, I'm actually done, after
a couple seconds, minutes,

00:22:52.610 --> 00:22:56.072
you choose, that task
will be timed out

00:22:56.072 --> 00:22:57.780
and will be available
in the queue again.

00:22:57.780 --> 00:23:00.990
So if, for any reason, your
process fails, which happens,

00:23:00.990 --> 00:23:03.500
your task will still
be processed later on.

00:23:03.500 --> 00:23:05.330
Push subscription,
on the other hand,

00:23:05.330 --> 00:23:08.580
is I just send you a message
and say, this is a new message.

00:23:08.580 --> 00:23:11.496
And then you have x amount of
seconds to reply saying, OK,

00:23:11.496 --> 00:23:11.995
done.

00:23:14.730 --> 00:23:16.144
So we used Cloud Pub/Sub.

00:23:16.144 --> 00:23:18.240
Cloud Pub/Sub is exactly this.

00:23:18.240 --> 00:23:20.380
And why did we use Pub/Sub?

00:23:20.380 --> 00:23:22.990
Because it's very flexible
and very powerful.

00:23:22.990 --> 00:23:25.650
We're going to see in a
minute how it actually works.

00:23:25.650 --> 00:23:28.810
But basically, it provides
real-time communication,

00:23:28.810 --> 00:23:31.064
many-to-many, and
completely decoupled.

00:23:31.064 --> 00:23:33.230
And this is something
important for some experiments

00:23:33.230 --> 00:23:33.938
that we do later.

00:23:36.560 --> 00:23:37.730
So how does this work?

00:23:37.730 --> 00:23:40.680
Well, publishers send
messages to topics.

00:23:40.680 --> 00:23:44.840
And then those topics have
subscriptions, as many of them

00:23:44.840 --> 00:23:45.620
as you want.

00:23:45.620 --> 00:23:48.640
When they send a
message to a topic,

00:23:48.640 --> 00:23:52.090
that topic will be sent
once per subscription.

00:23:52.090 --> 00:23:54.900
So you can, there,
multiply your messages.

00:23:54.900 --> 00:23:57.300
And then for every
subscription, you

00:23:57.300 --> 00:23:59.160
have a bunch of subscribers.

00:23:59.160 --> 00:24:01.910
And every message that
gets to a subscription

00:24:01.910 --> 00:24:05.204
will be sent to one of
the subscribers, which

00:24:05.204 --> 00:24:07.620
means that all of a sudden,
you can have one-to-one if you

00:24:07.620 --> 00:24:09.380
want, one-to-many as you choose.

00:24:09.380 --> 00:24:11.140
This is really
powerful because if you

00:24:11.140 --> 00:24:15.700
want to add topics
or subscriptions,

00:24:15.700 --> 00:24:18.240
you don't need to tell
neither the publishers

00:24:18.240 --> 00:24:19.060
or the subscribers.

00:24:19.060 --> 00:24:20.684
You can add things
on top quite easily.

00:24:23.510 --> 00:24:25.240
You can use it from anywhere.

00:24:25.240 --> 00:24:26.724
There's a Rest API.

00:24:26.724 --> 00:24:28.260
Rest APIs are awesome.

00:24:28.260 --> 00:24:30.590
So you can use it
from Go, from Android,

00:24:30.590 --> 00:24:33.475
from a Raspberry Pi hidden
under your bed, whatever

00:24:33.475 --> 00:24:34.100
you want to do.

00:24:37.000 --> 00:24:38.580
In our case, we use
it in two places.

00:24:38.580 --> 00:24:40.038
We used it for the
extraction topic

00:24:40.038 --> 00:24:41.660
where we have a
lot of extractors.

00:24:41.660 --> 00:24:44.490
And only one of those extractors
will receive that message

00:24:44.490 --> 00:24:47.120
and process our video.

00:24:47.120 --> 00:24:50.820
And then all the extractors
will send the extracted frames

00:24:50.820 --> 00:24:52.460
to the stitch topic.

00:24:52.460 --> 00:24:55.130
And then the stitcher will
receive all the stitchers,

00:24:55.130 --> 00:24:59.180
and at some point say, I have
all the frames for animation,

00:24:59.180 --> 00:25:02.200
I'll just generate it now.

00:25:02.200 --> 00:25:06.220
So the fact that we
had this allowed us

00:25:06.220 --> 00:25:10.170
to add extra weird stitchers.

00:25:10.170 --> 00:25:12.800
And we created this one where
we have the beginning of one

00:25:12.800 --> 00:25:15.260
of the videos, then the
jump, then the animation,

00:25:15.260 --> 00:25:17.244
and then the end
of another video.

00:25:17.244 --> 00:25:18.910
So this starts to
look a little bit more

00:25:18.910 --> 00:25:22.150
like "The Matrix,"
which was really cool.

00:25:22.150 --> 00:25:23.560
I totally forgot
his name, but he

00:25:23.560 --> 00:25:26.570
was helping us record a video,
and he was super excited

00:25:26.570 --> 00:25:28.730
about this.

00:25:28.730 --> 00:25:30.620
It was lots of fun.

00:25:30.620 --> 00:25:32.500
So now we have
pipeline processing.

00:25:32.500 --> 00:25:33.700
So we have everything.

00:25:33.700 --> 00:25:34.660
It's already done.

00:25:34.660 --> 00:25:36.910
We're just missing
doing the thing itself.

00:25:36.910 --> 00:25:40.750
Extracting the frame, so
detecting that audio peak

00:25:40.750 --> 00:25:42.970
and extracting the
frame, and then

00:25:42.970 --> 00:25:44.650
stitching all the
images together

00:25:44.650 --> 00:25:46.820
to generate that image.

00:25:46.820 --> 00:25:49.430
So how do we do this?

00:25:49.430 --> 00:25:53.120
So Matt, our dear
intern, wrote some code

00:25:53.120 --> 00:25:54.300
that did exactly this.

00:25:54.300 --> 00:25:57.060
And I just modified
it a little bit

00:25:57.060 --> 00:25:59.690
to be able to basically
get files from Google Cloud

00:25:59.690 --> 00:26:02.080
Storage, process the
video, and then put it

00:26:02.080 --> 00:26:04.620
back to Cloud Storage again.

00:26:04.620 --> 00:26:09.080
This is the whole code
for the frame extraction.

00:26:09.080 --> 00:26:11.063
And the important
thing about this

00:26:11.063 --> 00:26:13.560
is that this is the
code that I modified.

00:26:13.560 --> 00:26:15.220
A git blame says so.

00:26:15.220 --> 00:26:18.750
So there's a bug in this
code, and it's mine.

00:26:18.750 --> 00:26:24.610
And I'm using standard deviation
instead of mean for the noise.

00:26:24.610 --> 00:26:28.390
And this, basically, instead
of getting the mean power

00:26:28.390 --> 00:26:31.100
of the sound on a frame, I'm
getting the standard deviation

00:26:31.100 --> 00:26:33.580
of the power on a frame.

00:26:33.580 --> 00:26:37.690
And this works as long
as the room is silent,

00:26:37.690 --> 00:26:41.200
which is why, the night
before the demo, Ray and I

00:26:41.200 --> 00:26:44.870
are trying to figure out, at
the venue at 1:00 AM, what

00:26:44.870 --> 00:26:45.870
is going on.

00:26:45.870 --> 00:26:48.520
See, we actually figured
out that standard deviation

00:26:48.520 --> 00:26:50.650
was just silly, and
it was instead mean.

00:26:50.650 --> 00:26:52.860
We changed one function
call, and then we

00:26:52.860 --> 00:26:54.232
were all happy again.

00:26:54.232 --> 00:26:55.000
Yay.

00:26:55.000 --> 00:26:57.910
That was pretty intense.

00:26:57.910 --> 00:27:02.380
Then we modified it to
instead of getting something

00:27:02.380 --> 00:27:04.630
with standard deviation
and very complex stuff,

00:27:04.630 --> 00:27:07.920
we just compute how
noisy a single frame is,

00:27:07.920 --> 00:27:09.620
and we choose the noisiest one.

00:27:09.620 --> 00:27:14.120
And that single
algorithm just works.

00:27:14.120 --> 00:27:17.239
So what do we need to do
to process these things?

00:27:17.239 --> 00:27:18.780
Well, we need
something that is going

00:27:18.780 --> 00:27:22.962
to be using FFmpeg to
do audio processing.

00:27:22.962 --> 00:27:26.500
MoviePy is actually
a Python library that

00:27:26.500 --> 00:27:30.890
is a port-- no, not a port.

00:27:30.890 --> 00:27:32.100
I forgot the word.

00:27:32.100 --> 00:27:32.620
Whatever.

00:27:32.620 --> 00:27:35.910
It actually calls behind FFmpeg.

00:27:35.910 --> 00:27:37.920
We're going to need
to use Pub/Sub again.

00:27:37.920 --> 00:27:42.650
And we're going to need
this to work really quick.

00:27:42.650 --> 00:27:44.070
We use Google Compute Engine.

00:27:44.070 --> 00:27:44.990
Why?

00:27:44.990 --> 00:27:46.860
Well, we want
something that is going

00:27:46.860 --> 00:27:49.900
to be running continuously,
and that's not App Engine.

00:27:49.900 --> 00:27:52.360
App Engine is for something
that replies to requests.

00:27:52.360 --> 00:27:55.120
We want something that
will start the process up,

00:27:55.120 --> 00:27:59.770
going to Pub/Sub and say,
give me one new task.

00:27:59.770 --> 00:28:02.712
So we use Compute Engine.

00:28:02.712 --> 00:28:04.670
We have Compute Engine
everywhere in the world,

00:28:04.670 --> 00:28:08.949
it's very fast, and
it's very affordable.

00:28:08.949 --> 00:28:10.490
Then on top of that,
you can actually

00:28:10.490 --> 00:28:12.370
choose what kind of
machine you want.

00:28:12.370 --> 00:28:15.520
So you could say, I want
a machine with 32 cores

00:28:15.520 --> 00:28:17.910
and 208 gigabytes of RAM.

00:28:17.910 --> 00:28:19.050
And we have that.

00:28:19.050 --> 00:28:21.080
But maybe you want
to spend less.

00:28:23.810 --> 00:28:27.535
I think it's G1 Micro, which
is like a piece of a processor

00:28:27.535 --> 00:28:30.260
or somewhere, and it's
less than 1 cent per hour.

00:28:30.260 --> 00:28:31.670
It's super, super cheap.

00:28:31.670 --> 00:28:33.750
And that's what you find,
and we have those too.

00:28:33.750 --> 00:28:35.958
And then also, you can choose
whatever you feel like.

00:28:35.958 --> 00:28:38.500
So basically, you have sliders
and choose more memory,

00:28:38.500 --> 00:28:41.510
less memory, more CPU, less.

00:28:41.510 --> 00:28:43.860
I'm going to go quite
quick on this one.

00:28:43.860 --> 00:28:46.080
But basically, what
we did was, OK,

00:28:46.080 --> 00:28:48.980
so I want a bunch of
machines to be running,

00:28:48.980 --> 00:28:51.610
and I want those machines
to be managed somehow.

00:28:51.610 --> 00:28:53.900
So I'm going to create
this Manage Instance Group.

00:28:53.900 --> 00:28:55.620
And a Manage Instance
Group is just

00:28:55.620 --> 00:28:58.970
a group that is managed of
instances, as the name implies.

00:28:58.970 --> 00:29:02.036
And they're all exactly the
same except for metadata.

00:29:02.036 --> 00:29:04.160
The metadata is the only
thing that you can change,

00:29:04.160 --> 00:29:06.190
but they run exactly
the same software,

00:29:06.190 --> 00:29:08.230
exactly the same
hardware, same OS,

00:29:08.230 --> 00:29:11.000
all of those things the same.

00:29:11.000 --> 00:29:12.750
Then you have the
Instance Group Manager.

00:29:12.750 --> 00:29:15.110
And this is the one that
is going to add or remove

00:29:15.110 --> 00:29:16.420
instances as we need.

00:29:16.420 --> 00:29:22.734
And this allows us to have
load balancing or scaling.

00:29:22.734 --> 00:29:24.150
Then we need an
instance template.

00:29:24.150 --> 00:29:26.330
And the instance template
is basically, OK, I

00:29:26.330 --> 00:29:28.710
need one more machine,
give me the recipe for it.

00:29:28.710 --> 00:29:33.150
So you're going to run an Ubuntu
machine with 32 cores and all

00:29:33.150 --> 00:29:36.024
those things, and this
is the startup script.

00:29:36.024 --> 00:29:36.940
You can toy with that.

00:29:36.940 --> 00:29:39.780
It's very simple to do.

00:29:39.780 --> 00:29:41.810
And if you have a
new template, you

00:29:41.810 --> 00:29:44.330
can always say, hey,
this is the new template,

00:29:44.330 --> 00:29:46.530
please do a rolling update.

00:29:46.530 --> 00:29:49.610
And it will just restart,
regularly, those machines, one

00:29:49.610 --> 00:29:52.390
after the other, to make
sure that after a while,

00:29:52.390 --> 00:29:54.150
all of your machines,
all of your fleet,

00:29:54.150 --> 00:29:55.316
is running the new software.

00:29:55.316 --> 00:29:57.970
So that's pretty cool.

00:29:57.970 --> 00:30:00.240
So you end up with something
which is kind of complex.

00:30:00.240 --> 00:30:02.580
But we actually did
this at the beginning.

00:30:02.580 --> 00:30:06.610
And since I'm a very special
person, I decided, no, no, no.

00:30:06.610 --> 00:30:09.620
This has to run on Docker
because, come on, Docker.

00:30:09.620 --> 00:30:12.930
So what I did is I'm just
going to create a Docker

00:30:12.930 --> 00:30:15.300
container for the stitcher
and a Docker container

00:30:15.300 --> 00:30:16.330
for the extractor.

00:30:16.330 --> 00:30:20.390
And now, what I'm doing is every
single time I start one VM,

00:30:20.390 --> 00:30:22.440
it's going to be running
CoreOS, because CoreOS

00:30:22.440 --> 00:30:25.230
runs Docker by default. I
don't have to install anything.

00:30:25.230 --> 00:30:28.890
And then the startup script
is docker run my container.

00:30:28.890 --> 00:30:31.260
And it works, which
is really cool.

00:30:31.260 --> 00:30:36.680
So we got started, and then we
have 20 machines running just

00:30:36.680 --> 00:30:40.830
to manage this load, which
is kind of ridiculous.

00:30:40.830 --> 00:30:43.380
Because we're running
on the old world, right?

00:30:43.380 --> 00:30:46.210
We're not on this
old, old world where

00:30:46.210 --> 00:30:48.864
you have one machine and a
bunch of applications on it.

00:30:48.864 --> 00:30:50.550
But we're on right after.

00:30:50.550 --> 00:30:52.620
We have a bunch of
virtual machines running

00:30:52.620 --> 00:30:54.610
on every single machine,
and every application

00:30:54.610 --> 00:30:56.550
runs inside of its
virtual machine.

00:30:56.550 --> 00:30:57.620
They're kind of slow.

00:30:57.620 --> 00:31:00.090
There's a lot of resources
that are wasted because you're

00:31:00.090 --> 00:31:02.550
replicating many of the things
that every single machine is

00:31:02.550 --> 00:31:04.710
using.

00:31:04.710 --> 00:31:08.970
But since I'm using Docker,
one good thing-- well, you're

00:31:08.970 --> 00:31:11.680
using containers, why don't you
put all the containers inside

00:31:11.680 --> 00:31:14.140
of a single virtual machine?

00:31:14.140 --> 00:31:16.260
And I decided that
that was a good idea.

00:31:16.260 --> 00:31:17.610
So we started doing that.

00:31:17.610 --> 00:31:20.420
And then it's like, OK, how
many do I want to put in there?

00:31:20.420 --> 00:31:22.390
Do I want to put four, five?

00:31:22.390 --> 00:31:23.600
No idea.

00:31:23.600 --> 00:31:26.330
So as soon as you start
having many containers,

00:31:26.330 --> 00:31:29.640
the next step is
container orchestration.

00:31:29.640 --> 00:31:33.350
So we went to Google
Container Engine.

00:31:33.350 --> 00:31:35.390
And this is what Google
Container Engine looks

00:31:35.390 --> 00:31:39.400
like, which is exactly what we
had built from the beginning,

00:31:39.400 --> 00:31:41.035
but now, this is
automated, and you

00:31:41.035 --> 00:31:44.050
don't have to manage it by
yourself, which is awesome.

00:31:44.050 --> 00:31:45.780
And basically,
everything you need to do

00:31:45.780 --> 00:31:48.630
is you say, hey,
I want a cluster.

00:31:48.630 --> 00:31:51.340
My cluster's going to
have five machines.

00:31:51.340 --> 00:31:52.750
These are the kind of machines.

00:31:52.750 --> 00:31:55.530
And I want to run 20
of these containers.

00:31:55.530 --> 00:31:56.995
Run them wherever you feel like.

00:31:56.995 --> 00:31:59.370
And if one of the machines
goes down, don't even tell me.

00:31:59.370 --> 00:32:00.275
Just move it away.

00:32:00.275 --> 00:32:02.150
Restart the machine
later on, because there's

00:32:02.150 --> 00:32:03.340
an Instance Group Manager.

00:32:03.340 --> 00:32:06.770
And all of those things
work automatically.

00:32:06.770 --> 00:32:08.750
So I like to think
about it as, if you

00:32:08.750 --> 00:32:11.070
have Compute Engine,
which is the part where

00:32:11.070 --> 00:32:13.716
you have a lot of
flexibility but also DevOps,

00:32:13.716 --> 00:32:15.340
and you have App
Engine, where you have

00:32:15.340 --> 00:32:17.750
no DevOps but not
as much flexibility,

00:32:17.750 --> 00:32:20.994
I like to think that
Container Engine is up there.

00:32:20.994 --> 00:32:22.410
Where you have all
the flexibility

00:32:22.410 --> 00:32:23.740
you want because
it's got a container,

00:32:23.740 --> 00:32:25.550
and you can run
whatever you want in it.

00:32:25.550 --> 00:32:27.350
But at the same time,
you have less DevOps

00:32:27.350 --> 00:32:29.910
to do because you have all
of the Container Engine

00:32:29.910 --> 00:32:32.762
and [INAUDIBLE] is helping you
orchestrate all of those tasks.

00:32:32.762 --> 00:32:35.856
So it's a pretty sweet world.

00:32:35.856 --> 00:32:37.230
So yeah, Google
Container Engine.

00:32:37.230 --> 00:32:38.960
And I'm almost
running out of time,

00:32:38.960 --> 00:32:42.310
but that's what we got--
around three times resource

00:32:42.310 --> 00:32:44.300
increase, which is pretty good.

00:32:44.300 --> 00:32:46.960
At this point, we had spent
enough money on tripods

00:32:46.960 --> 00:32:48.680
that this was not that
important anymore,

00:32:48.680 --> 00:32:52.610
but still, our manager
was happy for this.

00:32:52.610 --> 00:32:55.600
So this is the
whole architecture.

00:32:55.600 --> 00:32:58.200
All our files are stored
in Google Cloud storage.

00:32:58.200 --> 00:33:01.530
We use App Engine to
process our notifications.

00:33:01.530 --> 00:33:07.110
Pub/Sub to manage all the
tasks and smooth the workload.

00:33:07.110 --> 00:33:12.100
And then Container Engine to
actually track those tasks.

00:33:12.100 --> 00:33:14.150
Time for a fun story.

00:33:14.150 --> 00:33:16.010
We did this also in Tokyo.

00:33:16.010 --> 00:33:18.510
And we just send the
whole specifications off--

00:33:18.510 --> 00:33:21.260
these are all the cables
we need-- to Tokyo,

00:33:21.260 --> 00:33:24.550
and then people in
Tokyo bought them.

00:33:24.550 --> 00:33:28.180
So the phone, to be able
to detect the audio,

00:33:28.180 --> 00:33:30.880
we need this specific cable.

00:33:30.880 --> 00:33:34.270
This is a TRS to TRRS thing.

00:33:34.270 --> 00:33:37.577
Because we tried to
make them ourselves,

00:33:37.577 --> 00:33:38.660
and this is how it looked.

00:33:38.660 --> 00:33:40.790
Super pro.

00:33:40.790 --> 00:33:41.980
And these didn't work.

00:33:41.980 --> 00:33:46.960
So let's use off the shelf,
much better, Google style.

00:33:46.960 --> 00:33:49.480
Let's use cheap off
the shelf components

00:33:49.480 --> 00:33:51.390
that we can reuse if they break.

00:33:51.390 --> 00:33:54.160
So what we did is, OK, we
have the control tablet.

00:33:54.160 --> 00:33:55.030
We press the button.

00:33:55.030 --> 00:33:56.640
There's a cable
that goes to an amp.

00:33:56.640 --> 00:33:58.940
Then that amp sends four cables.

00:33:58.940 --> 00:34:00.340
Every single one has a hub.

00:34:00.340 --> 00:34:01.770
And then that's 20 phones.

00:34:01.770 --> 00:34:02.270
Boom.

00:34:02.270 --> 00:34:03.320
Done.

00:34:03.320 --> 00:34:04.690
Yeah, doesn't work.

00:34:04.690 --> 00:34:06.470
Because you need that cable.

00:34:06.470 --> 00:34:09.047
It's a TRS to TRRS adapter.

00:34:09.047 --> 00:34:10.630
And what happens if
you don't have it?

00:34:10.630 --> 00:34:12.270
Which happened in Tokyo.

00:34:12.270 --> 00:34:17.030
Well, you go to the Google
Makerspace in the Tokyo office,

00:34:17.030 --> 00:34:19.219
you find a bunch of
resistors, and you

00:34:19.219 --> 00:34:22.699
spend the night soldering,
making those amazing

00:34:22.699 --> 00:34:23.650
looking cables.

00:34:23.650 --> 00:34:26.070
And the demo actually worked.

00:34:26.070 --> 00:34:28.620
That was lots of fun.

00:34:28.620 --> 00:34:31.260
So in conclusion, I just have
a couple seconds to finish.

00:34:31.260 --> 00:34:34.690
We were able to build, in
around two weeks, a demo that,

00:34:34.690 --> 00:34:39.550
hardware-wise, yeah, it
worked, but software-wise,

00:34:39.550 --> 00:34:40.900
is very robust.

00:34:40.900 --> 00:34:42.920
It was very easy to build.

00:34:42.920 --> 00:34:45.020
It's actually very
effective to run.

00:34:45.020 --> 00:34:47.630
Whenever it's not running,
the autoscaler just shuts down

00:34:47.630 --> 00:34:49.600
everything, so there's
no cost accorded

00:34:49.600 --> 00:34:51.739
to it other than the storage.

00:34:51.739 --> 00:34:54.360
And it was lots of fun.

00:34:54.360 --> 00:34:56.850
So thank you for all
the demo builders,

00:34:56.850 --> 00:35:00.080
for the team building it and
throwing plushies in the air.

00:35:00.080 --> 00:35:01.380
There's a gopher there.

00:35:01.380 --> 00:35:03.250
Thank you very much.

