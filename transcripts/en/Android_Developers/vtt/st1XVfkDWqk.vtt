WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:01.944
[MUSIC PLAYING]

00:00:06.306 --> 00:00:07.430
JAKE WHARTON: Hi, everyone.

00:00:07.430 --> 00:00:08.290
My name is Jake.

00:00:08.290 --> 00:00:12.480
I work on the Android
team on Kotlin stuff.

00:00:12.480 --> 00:00:15.840
And so today, I'm going to
be talking about Android KTX.

00:00:15.840 --> 00:00:18.130
And I'm not going
to be just going

00:00:18.130 --> 00:00:20.180
over a bunch of the
stuff that's in there.

00:00:20.180 --> 00:00:22.430
I want to make it a little
more interesting than that.

00:00:22.430 --> 00:00:26.140
So I'm going to start with a
little bit of what happened

00:00:26.140 --> 00:00:27.740
last year at Google I/O.

00:00:27.740 --> 00:00:29.710
I was here last year,
talking about how

00:00:29.710 --> 00:00:33.310
you can write extensions
for Android types,

00:00:33.310 --> 00:00:35.410
such as this example,
where we have

00:00:35.410 --> 00:00:39.280
code that iterates over the
views inside of a ViewGroup.

00:00:39.280 --> 00:00:42.580
You can pull that common
code out into an extension.

00:00:42.580 --> 00:00:46.260
And what this extension
does is enhance a type

00:00:46.260 --> 00:00:48.790
that we don't control,
the ViewGroup type.

00:00:48.790 --> 00:00:53.770
We're allowed to, essentially,
create a member function

00:00:53.770 --> 00:00:55.650
that's not actually
a member function.

00:00:55.650 --> 00:00:58.630
It actually turns into a static
function in the bytecode,

00:00:58.630 --> 00:01:00.880
with the functionality
that we want to enhance.

00:01:03.910 --> 00:01:06.380
And so we can take
our original code that

00:01:06.380 --> 00:01:10.640
had the explicit for-loop in
it and use this new member

00:01:10.640 --> 00:01:15.440
to create a more concise version
of what we intended to do.

00:01:15.440 --> 00:01:17.330
It is actually
visually distinguished

00:01:17.330 --> 00:01:20.540
from a normal member function,
that it's italicized.

00:01:20.540 --> 00:01:23.140
If you use dark yellow,
it'll actually be yellow.

00:01:23.140 --> 00:01:25.400
But it's semantically
equivalent to calling a member,

00:01:25.400 --> 00:01:30.370
or the intent is to feel
semantically equivalent.

00:01:30.370 --> 00:01:32.560
And so oftentimes,
when you start

00:01:32.560 --> 00:01:34.360
talking about
extension functions,

00:01:34.360 --> 00:01:36.730
you think, well, if
this is so useful,

00:01:36.730 --> 00:01:39.460
why don't we just put the
function directly on D-group?

00:01:39.460 --> 00:01:43.180
Why doesn't ViewGroup just offer
a for-each and a for-each index

00:01:43.180 --> 00:01:46.170
that takes in a lambda?

00:01:46.170 --> 00:01:48.920
And really, the reason
is because of the lambda.

00:01:48.920 --> 00:01:54.090
When we pass a lambda in Java
8 or in Kotlin, by default,

00:01:54.090 --> 00:01:57.690
that has to create an anonymous
class, which eats up methods

00:01:57.690 --> 00:02:00.640
and causes class-loading.

00:02:00.640 --> 00:02:03.340
Kotlin, however, provides
language functionality,

00:02:03.340 --> 00:02:07.290
which allows us to eliminate
that lambda's allocation.

00:02:07.290 --> 00:02:09.120
By marking the
function as inline,

00:02:09.120 --> 00:02:11.910
the body of the extension gets
copied into the call-site,

00:02:11.910 --> 00:02:14.438
and we have a zero
overhead abstraction.

00:02:17.430 --> 00:02:19.450
Let's take a look
at another example.

00:02:19.450 --> 00:02:22.230
In API 23, we were able
to get a system service

00:02:22.230 --> 00:02:24.420
based on the class type.

00:02:24.420 --> 00:02:27.450
And in 27.1 of the
support libraries,

00:02:27.450 --> 00:02:29.700
a ContextCompat
version of this was

00:02:29.700 --> 00:02:32.880
added that allowed it to
work on all API levels.

00:02:32.880 --> 00:02:37.170
We can pull this into an
extension that is also inline,

00:02:37.170 --> 00:02:40.800
like the previous one, but
doesn't contain a lambda.

00:02:40.800 --> 00:02:42.360
What this one has
that's different

00:02:42.360 --> 00:02:44.370
is something called reified.

00:02:44.370 --> 00:02:46.350
Now, this is a compiler trick.

00:02:46.350 --> 00:02:50.190
And what that trick does is
it forces the type information

00:02:50.190 --> 00:02:53.760
of the generic to be
known at compile time,

00:02:53.760 --> 00:02:57.890
so that it can be made
available at runtime.

00:02:57.890 --> 00:03:00.660
And so this is
what allows us to--

00:03:00.660 --> 00:03:03.600
where we would otherwise
be calling class.java

00:03:03.600 --> 00:03:07.050
on notification manager, we
can now abstract that away

00:03:07.050 --> 00:03:09.630
behind this extension.

00:03:09.630 --> 00:03:12.930
And so our calling code now
becomes simplified to just

00:03:12.930 --> 00:03:14.850
be able to pass the generic.

00:03:14.850 --> 00:03:18.360
And because it's reified,
the implementation of that

00:03:18.360 --> 00:03:21.030
has access to be able
to call class.java.

00:03:26.610 --> 00:03:31.080
So if we want to update
the padding of a view, just

00:03:31.080 --> 00:03:33.654
where we're only
specifying two of the four

00:03:33.654 --> 00:03:35.070
parameters-- in
this case, we want

00:03:35.070 --> 00:03:37.320
to update both the
left and the right.

00:03:37.320 --> 00:03:40.020
We have to pull out
the existing padding

00:03:40.020 --> 00:03:42.660
for the top and the bottom
because Android requires

00:03:42.660 --> 00:03:46.050
you to specify all four.

00:03:46.050 --> 00:03:48.750
This is something that
we can remedy, again,

00:03:48.750 --> 00:03:49.930
using an extension function.

00:03:52.580 --> 00:03:54.760
The key here is that,
for each of the arguments

00:03:54.760 --> 00:03:56.830
on this new function
that we've defined,

00:03:56.830 --> 00:03:59.080
we're specifying a
default. And that default

00:03:59.080 --> 00:04:05.684
will be used when a value is
not provided for that argument.

00:04:05.684 --> 00:04:07.600
So it allows us to take
the calling code where

00:04:07.600 --> 00:04:12.630
we're specifying all four and,
now, specify them as just two.

00:04:12.630 --> 00:04:16.200
But the problem here is
that we've eliminated

00:04:16.200 --> 00:04:17.269
two of the arguments.

00:04:17.269 --> 00:04:19.230
But since we're
only supplying two,

00:04:19.230 --> 00:04:22.079
Kotlin takes that as
meaning the first two,

00:04:22.079 --> 00:04:26.062
and the latter two are the ones
where the defaults are used.

00:04:26.062 --> 00:04:27.270
This is not what we intended.

00:04:27.270 --> 00:04:29.400
We intended to do
left and right,

00:04:29.400 --> 00:04:31.350
which are the first and third.

00:04:31.350 --> 00:04:35.160
Another language feature
comes to help here,

00:04:35.160 --> 00:04:38.760
which is named parameters.

00:04:38.760 --> 00:04:41.110
By specifying the
name of the parameter,

00:04:41.110 --> 00:04:44.190
we're able to tell the compiler
which of the two arguments

00:04:44.190 --> 00:04:46.374
we're specifying,
and allow it to fill

00:04:46.374 --> 00:04:47.665
in the defaults for the others.

00:04:55.630 --> 00:04:57.340
OK.

00:04:57.340 --> 00:05:00.470
Android APIs have a
bunch of composite types.

00:05:00.470 --> 00:05:04.260
These are things like
point, rectangle, pair--

00:05:04.260 --> 00:05:06.070
even the location class.

00:05:06.070 --> 00:05:07.750
These composite types
are just wrappers

00:05:07.750 --> 00:05:11.360
around smaller individual
pieces of data.

00:05:11.360 --> 00:05:14.150
In this case, I'm calling an
API, which has a rectangle,

00:05:14.150 --> 00:05:17.830
which is a composite around the
four-- the left, top, right,

00:05:17.830 --> 00:05:19.240
and bottom--

00:05:19.240 --> 00:05:21.340
values of a rectangle.

00:05:21.340 --> 00:05:23.200
And if you need
to do calculations

00:05:23.200 --> 00:05:26.350
based on the values inside
of these composite types,

00:05:26.350 --> 00:05:30.760
you have to pull them out into
individual values or variables

00:05:30.760 --> 00:05:35.815
in order to do that calculation
and then, potentially,

00:05:35.815 --> 00:05:36.940
put them all back together.

00:05:40.050 --> 00:05:44.210
So with the help of the
extension, we can avoid this.

00:05:44.210 --> 00:05:46.080
This one is a little
bit different.

00:05:46.080 --> 00:05:48.320
We have a new keyword
called an operator.

00:05:48.320 --> 00:05:50.120
An operator means
that Kotlin will

00:05:50.120 --> 00:05:54.590
allow us to use a
special call site syntax.

00:05:54.590 --> 00:05:58.190
And each operator function
has a very specific name--

00:05:58.190 --> 00:05:59.090
a well-known name.

00:05:59.090 --> 00:06:01.280
You can't just make up any name.

00:06:01.280 --> 00:06:04.940
And the name defines which
call site syntax that you're

00:06:04.940 --> 00:06:06.530
intending to create.

00:06:06.530 --> 00:06:08.240
In this case, it's
called Component.

00:06:08.240 --> 00:06:10.190
And Component allows
us to use a feature

00:06:10.190 --> 00:06:12.560
of Kotlin called destructuring.

00:06:12.560 --> 00:06:15.440
And so our original code, which
had to individually pull out

00:06:15.440 --> 00:06:20.660
the four different components,
can now use this call site

00:06:20.660 --> 00:06:23.270
syntax where the rectangle
was automatically

00:06:23.270 --> 00:06:28.760
unpacked into the four values
and assigned to four variables

00:06:28.760 --> 00:06:31.977
with the names that we choose.

00:06:31.977 --> 00:06:33.560
What's really nice
about this is that,

00:06:33.560 --> 00:06:36.910
if you don't care about ones
later on, you can omit them.

00:06:36.910 --> 00:06:39.110
And if you don't care
about ones in the middle,

00:06:39.110 --> 00:06:41.001
you can specify
them as underscore.

00:06:41.001 --> 00:06:43.250
And so, if we just need to
pull out two of the values,

00:06:43.250 --> 00:06:46.436
we can do that very succinctly.

00:06:52.500 --> 00:06:53.430
OK.

00:06:53.430 --> 00:06:56.160
An experienced Kotlin
user might know

00:06:56.160 --> 00:06:57.920
that-- well, I guess
we flipped through--

00:06:57.920 --> 00:06:58.910
could go back a slide?

00:07:04.070 --> 00:07:05.340
OK.

00:07:05.340 --> 00:07:07.176
So this is some
code that shows how

00:07:07.176 --> 00:07:08.550
we could determine
whether or not

00:07:08.550 --> 00:07:11.970
a string contains only digits.

00:07:11.970 --> 00:07:14.010
It basically just loops
through the characters,

00:07:14.010 --> 00:07:17.670
using Kotlin's for-in syntax;
checks whether it's a digit,

00:07:17.670 --> 00:07:20.460
using an extension
function on character;

00:07:20.460 --> 00:07:23.820
and then sets a value
to true or false

00:07:23.820 --> 00:07:26.760
whenever it detects a non-digit.

00:07:26.760 --> 00:07:28.830
If you're an
experienced Kotlin user,

00:07:28.830 --> 00:07:31.710
you might know about
the All function, which

00:07:31.710 --> 00:07:34.880
exists on string, which
encapsulates the same looping

00:07:34.880 --> 00:07:38.460
and allows you to specify a
predicate, which, in this case,

00:07:38.460 --> 00:07:39.756
is digit.

00:07:39.756 --> 00:07:41.130
It's actually an
inline function,

00:07:41.130 --> 00:07:44.610
so it desugars into the exact
same thing we would have

00:07:44.610 --> 00:07:47.670
wrote in the previous slide.

00:07:47.670 --> 00:07:49.800
But what's interesting is
that Android actually has

00:07:49.800 --> 00:07:51.300
a built-in function for this.

00:07:51.300 --> 00:07:52.770
And I suspect that
a lot of people

00:07:52.770 --> 00:07:56.470
don't actually know this exists.

00:07:56.470 --> 00:07:59.120
And so this is something that
we can actually take and turn

00:07:59.120 --> 00:08:00.620
into an extension.

00:08:00.620 --> 00:08:04.670
But you start to wonder,
is this actually worth

00:08:04.670 --> 00:08:05.930
its weight in an extension?

00:08:05.930 --> 00:08:09.710
What value do we gain by turning
this static method that we

00:08:09.710 --> 00:08:12.290
can call into an extension?

00:08:12.290 --> 00:08:14.540
Well, for one, it
changes the way

00:08:14.540 --> 00:08:18.050
that we invoke to feel a lot
more natural and idiomatic

00:08:18.050 --> 00:08:19.020
in Kotlin--

00:08:19.020 --> 00:08:19.820
sure.

00:08:19.820 --> 00:08:25.530
But still, is there really
value that we extract from this?

00:08:25.530 --> 00:08:27.540
The biggest one that I
think we gain from this

00:08:27.540 --> 00:08:30.360
is that, when you're in the
IDE, you have your string,

00:08:30.360 --> 00:08:36.929
and you're wanting to make
this query as to whether or not

00:08:36.929 --> 00:08:39.720
it contains only digits.

00:08:39.720 --> 00:08:42.659
If you didn't know that static
method on TextUtils was there,

00:08:42.659 --> 00:08:44.450
you probably would
never find it.

00:08:44.450 --> 00:08:48.810
When it's extension, if you
start typing in the IDE,

00:08:48.810 --> 00:08:52.770
it will actually show this
extension and auto-complete,

00:08:52.770 --> 00:08:55.820
where it's much more
discoverable than otherwise.

00:08:55.820 --> 00:08:56.820
So you just press Enter.

00:08:56.820 --> 00:08:58.721
And you get it.

00:08:58.721 --> 00:08:59.220
All right.

00:08:59.220 --> 00:09:02.316
So I covered a few
extensions here.

00:09:02.316 --> 00:09:03.690
I just wanted to
remind you a bit

00:09:03.690 --> 00:09:06.570
of the power of these
extensions, the fact

00:09:06.570 --> 00:09:09.450
that we are leveraging language
features that exist only

00:09:09.450 --> 00:09:12.330
in Kotlin, not in
the Java language.

00:09:12.330 --> 00:09:14.070
And actually, some
of these examples

00:09:14.070 --> 00:09:15.870
we're going to keep coming
back to throughout the rest

00:09:15.870 --> 00:09:16.500
of this talk.

00:09:19.550 --> 00:09:22.420
So all of the extensions
that I just showed

00:09:22.420 --> 00:09:25.390
are part of the
Android KTX library

00:09:25.390 --> 00:09:28.130
that we announced
in early February.

00:09:28.130 --> 00:09:30.160
There's been two
releases since then.

00:09:30.160 --> 00:09:35.355
And as of Tuesday, it's
now part of Jetpack,

00:09:35.355 --> 00:09:36.760
and versioned with Jetpack.

00:09:36.760 --> 00:09:42.605
So on Tuesday, Core-KTX
is now 1.0 Alpha 1.

00:09:42.605 --> 00:09:44.230
It's going to be
versioned and released

00:09:44.230 --> 00:09:45.840
with future Jetpack libraries.

00:09:49.550 --> 00:09:51.649
So we called this
Core-KTX when we launched,

00:09:51.649 --> 00:09:52.940
which was kind of a weird name.

00:09:52.940 --> 00:09:55.250
It didn't make sense.

00:09:55.250 --> 00:09:59.630
This was for extensions for
types only in the framework.

00:09:59.630 --> 00:10:02.870
A lot of people suggested, can
we add support library stuff?

00:10:02.870 --> 00:10:05.240
And we were very
adamant about saying no.

00:10:05.240 --> 00:10:07.770
That should, hopefully,
make a lot more sense now.

00:10:07.770 --> 00:10:09.440
But even this
isn't exactly true,

00:10:09.440 --> 00:10:13.850
because Core-KTX initially
depended on support-compat.

00:10:13.850 --> 00:10:18.140
Support-compat is there to
provide backwards compatibility

00:10:18.140 --> 00:10:21.920
versions of things that are
in the Android framework.

00:10:21.920 --> 00:10:25.280
And so earlier, I showed the
example with ContextCompat.

00:10:25.280 --> 00:10:28.220
That's something that
came from support-compat.

00:10:28.220 --> 00:10:31.860
And so now, with the Jetpack
rebranding and the Android X

00:10:31.860 --> 00:10:35.600
packages, support-compat
has become core.

00:10:35.600 --> 00:10:38.590
And so now, Core-KTX
lines up with Core.

00:10:38.590 --> 00:10:41.090
So we kind of knew
what we were doing back

00:10:41.090 --> 00:10:42.680
when we started this.

00:10:42.680 --> 00:10:45.990
And now, it's only
starting to pay off.

00:10:45.990 --> 00:10:48.210
Along with the other
Jetpack libraries,

00:10:48.210 --> 00:10:50.970
there's actually a
few new KTX libraries

00:10:50.970 --> 00:10:52.830
that are launching with it.

00:10:52.830 --> 00:10:57.050
So we have ones for
fragment, collection, SQLite.

00:10:57.050 --> 00:11:01.160
For the newer components,
navigation, and work runtime.

00:11:01.160 --> 00:11:04.500
I'm going to touch on how you
can discover these a bit later.

00:11:04.500 --> 00:11:06.780
But I want to talk
a bit about scoping,

00:11:06.780 --> 00:11:11.490
about how we determine whether
or not something should

00:11:11.490 --> 00:11:13.440
go into one of these libraries.

00:11:18.201 --> 00:11:18.700
All right.

00:11:18.700 --> 00:11:23.890
So in Core-KTX 0.3, we
offered an extension

00:11:23.890 --> 00:11:26.030
that looked like this.

00:11:26.030 --> 00:11:29.110
If you look at its
signature, it's an operator.

00:11:29.110 --> 00:11:31.330
And it operates on color.

00:11:31.330 --> 00:11:32.500
And the name is Plus.

00:11:32.500 --> 00:11:36.720
So this allows us to use the
normal plus syntax for adding,

00:11:36.720 --> 00:11:39.440
for compositing two
colors together.

00:11:39.440 --> 00:11:42.910
So the signature-- it's
definitely an extension.

00:11:42.910 --> 00:11:45.306
But the body of this
looks very different

00:11:45.306 --> 00:11:46.930
than the other
extensions we looked at.

00:11:46.930 --> 00:11:51.530
There's a significant
amount of code in here.

00:11:51.530 --> 00:11:54.050
If you look inside,
support-compat,

00:11:54.050 --> 00:11:57.980
which is now Core, there
is a color utilities class.

00:11:57.980 --> 00:11:59.930
And that color
utilities class has

00:11:59.930 --> 00:12:04.165
a method called composite colors
that works on integer colors.

00:12:04.165 --> 00:12:06.290
It allows you to take a
foreground and a background

00:12:06.290 --> 00:12:09.150
and turn them into
a single color.

00:12:09.150 --> 00:12:13.100
So this is the perfect candidate
for placing the implementation

00:12:13.100 --> 00:12:16.910
of what that
extension function was

00:12:16.910 --> 00:12:19.700
into this class, so that
everyone can use it--

00:12:19.700 --> 00:12:21.997
so that can be used
from the Java language

00:12:21.997 --> 00:12:22.955
or the Kotlin language.

00:12:25.500 --> 00:12:29.790
And so in Core-KTX
1.0, this actually

00:12:29.790 --> 00:12:34.720
has been rewritten to just
delegate to that ColorUtils.

00:12:34.720 --> 00:12:38.640
So the Java language users
get that functionality.

00:12:38.640 --> 00:12:41.305
But the Kotlin users
get the enhanced syntax.

00:12:43.721 --> 00:12:45.970
And if you look at the
extensions that we talked about

00:12:45.970 --> 00:12:49.840
so far, the bodies of
them, the implementation

00:12:49.840 --> 00:12:53.564
of these functions,
they're all trivial.

00:12:53.564 --> 00:12:54.730
They're exceedingly trivial.

00:12:54.730 --> 00:12:56.740
And that's by design.

00:12:56.740 --> 00:13:02.670
And this gets me into covering
some of the principles

00:13:02.670 --> 00:13:07.150
that we defined that KTX
extensions should have.

00:13:07.150 --> 00:13:10.210
And so this first one is that
we want to adapt functionality

00:13:10.210 --> 00:13:13.060
that already exists.

00:13:13.060 --> 00:13:14.710
And if we want to
add any new features,

00:13:14.710 --> 00:13:17.196
those should be redirected
upstream to a place

00:13:17.196 --> 00:13:19.570
where they're language agnostic,
where both languages can

00:13:19.570 --> 00:13:21.640
take advantage of them.

00:13:21.640 --> 00:13:23.500
Other examples of this--

00:13:23.500 --> 00:13:27.370
there was some HTML compat
stuff and a path iterator

00:13:27.370 --> 00:13:30.130
that were implemented first
in Core-KTX that have since

00:13:30.130 --> 00:13:32.950
moved upstream into
Core to be able to be

00:13:32.950 --> 00:13:36.830
used in both languages.

00:13:36.830 --> 00:13:40.460
Another thing that's common
to all these extensions

00:13:40.460 --> 00:13:42.360
is that they're
marked as inline.

00:13:47.930 --> 00:13:50.720
The reason that we do
inline on the first one--

00:13:50.720 --> 00:13:51.710
the one at the top--

00:13:51.710 --> 00:13:54.830
is that we want to avoid
the lambda allocation.

00:13:54.830 --> 00:13:58.040
For the second one, because
we're using reified generics,

00:13:58.040 --> 00:14:02.210
we're actually forced to
use inline by the compiler.

00:14:02.210 --> 00:14:06.460
The third, the component
ones, and the very bottom one

00:14:06.460 --> 00:14:09.170
are all inline,
mostly because they're

00:14:09.170 --> 00:14:11.930
just aliases to what you
would otherwise write

00:14:11.930 --> 00:14:13.190
if the extension didn't exist.

00:14:16.230 --> 00:14:19.020
If we look at an example
of something that's

00:14:19.020 --> 00:14:23.680
not inline in Core-KTX, we
have this iterator extension

00:14:23.680 --> 00:14:26.560
to ViewGroup, which allows
us to use Kotlin's for/in

00:14:26.560 --> 00:14:31.100
syntax to iterate over
the views and a ViewGroup.

00:14:31.100 --> 00:14:34.760
This is not inline for
a very specific reason.

00:14:34.760 --> 00:14:38.470
And that is because the
implementation of this function

00:14:38.470 --> 00:14:41.206
defines an anonymous class.

00:14:41.206 --> 00:14:43.580
If we were to inline this,
that means that every time you

00:14:43.580 --> 00:14:47.610
use it, an anonymous class would
be defined at your call site.

00:14:47.610 --> 00:14:50.490
And so this would increase
your deck size, method count,

00:14:50.490 --> 00:14:52.300
and class loading.

00:14:52.300 --> 00:14:54.020
We explicitly make
this not inline,

00:14:54.020 --> 00:14:57.230
because we want that
single implementation to be

00:14:57.230 --> 00:14:58.785
reused by all of the callers.

00:15:03.540 --> 00:15:06.960
So we default to an extension
being inline unless there

00:15:06.960 --> 00:15:09.739
are allocation reasons.

00:15:09.739 --> 00:15:11.280
And I should note
that this is really

00:15:11.280 --> 00:15:14.310
only for KTX-style extensions.

00:15:14.310 --> 00:15:17.340
In normal Kotlin code, this
is not a good recommendation.

00:15:17.340 --> 00:15:19.560
You don't want to
default to inline

00:15:19.560 --> 00:15:22.770
because it has the potential
to lead to actually having

00:15:22.770 --> 00:15:26.040
a negative effect on your code
rather than a positive one.

00:15:29.971 --> 00:15:30.470
All right.

00:15:30.470 --> 00:15:33.110
So earlier when we
showed this extension,

00:15:33.110 --> 00:15:37.370
I talked about how the inline
modifier, coupled with the fact

00:15:37.370 --> 00:15:39.920
that there's a lambda,
allows this extension

00:15:39.920 --> 00:15:43.640
to be a zero
overhead abstraction.

00:15:43.640 --> 00:15:47.230
In the reified case,
we get the ability

00:15:47.230 --> 00:15:49.270
to have a more
declarative version

00:15:49.270 --> 00:15:52.420
of the lookup at the call
site without having to specify

00:15:52.420 --> 00:15:54.280
the colon colon class.java.

00:15:57.320 --> 00:16:01.040
For updating the padding,
we get to use default values

00:16:01.040 --> 00:16:03.350
to not have to specify
each of the arguments,

00:16:03.350 --> 00:16:07.400
and name parameters to specify
which subset of arguments

00:16:07.400 --> 00:16:10.700
we want to actually provide.

00:16:10.700 --> 00:16:13.810
For the destructuring case,
we get the fancy syntax

00:16:13.810 --> 00:16:17.170
that allows us to pull apart
the component variables out

00:16:17.170 --> 00:16:19.600
of a composite object.

00:16:19.600 --> 00:16:21.020
This is useful.

00:16:21.020 --> 00:16:24.670
This is enabled by
the fact that we have

00:16:24.670 --> 00:16:26.620
operator overloading in Kotlin.

00:16:26.620 --> 00:16:30.210
We also talked about how we were
able to add the plus for color.

00:16:33.290 --> 00:16:38.990
For this one, we're aliasing an
extension to a static method.

00:16:38.990 --> 00:16:41.120
And this is just to help
improve discoverability

00:16:41.120 --> 00:16:44.215
for built-in helpers that you
might otherwise not know exist.

00:16:47.130 --> 00:16:50.190
And then, for types that
are collection-like but not

00:16:50.190 --> 00:16:52.590
actually collections,
we have the ability

00:16:52.590 --> 00:16:56.220
to turn them into pseudo
collections, where

00:16:56.220 --> 00:16:58.890
we can use the affordances
of the language

00:16:58.890 --> 00:17:02.400
as if they were
actual collections.

00:17:02.400 --> 00:17:07.210
And so each one of those has a
very Kotlin-specific language

00:17:07.210 --> 00:17:09.170
feature that it uses.

00:17:09.170 --> 00:17:12.310
And we want to make sure that
all these extensions that we're

00:17:12.310 --> 00:17:15.760
defining leverage some
feature of the Kotlin language

00:17:15.760 --> 00:17:20.260
that doesn't otherwise
exist for Java callers.

00:17:20.260 --> 00:17:24.069
We want to resist trying to
fix an API just by creating

00:17:24.069 --> 00:17:26.680
extensions for it,
but rather enhance

00:17:26.680 --> 00:17:29.170
it to become more pleasant
to use by leveraging

00:17:29.170 --> 00:17:30.670
these Kotlin-specific features.

00:17:34.590 --> 00:17:36.740
OK.

00:17:36.740 --> 00:17:40.610
One of the suggestions
we get quite frequently

00:17:40.610 --> 00:17:45.110
is to take something
like setOnClickListener

00:17:45.110 --> 00:17:46.790
and write an
extension, which allows

00:17:46.790 --> 00:17:51.920
you to call it using something
like Click or OnClick.

00:17:51.920 --> 00:17:53.690
This allows the calling code--

00:17:53.690 --> 00:17:57.140
instead of having to
call setOnClickListener,

00:17:57.140 --> 00:18:00.810
we get the shorter
version of Click.

00:18:00.810 --> 00:18:03.810
Are we leveraging a feature
of the language here?

00:18:03.810 --> 00:18:07.440
Well, we're leveraging extension
functions, but not really.

00:18:07.440 --> 00:18:10.650
We're really just
creating a shorter alias.

00:18:10.650 --> 00:18:14.220
What value are we extracting
from this extension?

00:18:14.220 --> 00:18:16.200
Well, we're typing a
few less characters.

00:18:16.200 --> 00:18:20.130
But really, it's
autocompleted anyway.

00:18:20.130 --> 00:18:22.980
But even worse, what precedent
will we be setting here

00:18:22.980 --> 00:18:25.284
by adding this extension?

00:18:25.284 --> 00:18:27.075
Are we going to do this
for every listener?

00:18:29.780 --> 00:18:31.760
And so this is a great
example of something

00:18:31.760 --> 00:18:35.580
we explicitly do not want
to do in the KTX libraries.

00:18:38.900 --> 00:18:41.280
If you're not familiar
with the term,

00:18:41.280 --> 00:18:43.650
we call this code
golf, where you

00:18:43.650 --> 00:18:47.786
have the desire to create
the shortest code possible.

00:18:47.786 --> 00:18:49.410
This is something we
do not want to do.

00:18:49.410 --> 00:18:51.370
We're not here to just
make the code shorter.

00:18:54.791 --> 00:18:55.290
OK.

00:18:55.290 --> 00:18:58.230
There's another one that gets
suggested every now and then,

00:18:58.230 --> 00:18:59.565
and that I've seen people using.

00:19:02.100 --> 00:19:04.500
With Android, because of
the different API levels

00:19:04.500 --> 00:19:06.330
we have to support,
you very frequently

00:19:06.330 --> 00:19:10.870
see these IF checks
around the SDK int.

00:19:10.870 --> 00:19:12.510
So it can be tempted
to pull this out

00:19:12.510 --> 00:19:14.100
into an extension,
where you have

00:19:14.100 --> 00:19:17.160
a little bit more
declarative version of this.

00:19:17.160 --> 00:19:21.750
We move the comparison
into an extension function.

00:19:21.750 --> 00:19:24.810
It's an inline function, so
we don't have the overhead.

00:19:24.810 --> 00:19:28.485
The lambda's the last parameter,
so we get the nice Kotlin call

00:19:28.485 --> 00:19:29.960
site syntax.

00:19:29.960 --> 00:19:35.490
And it turns our IF statement
from this into this.

00:19:35.490 --> 00:19:38.760
Now, this by itself
is not too terrible.

00:19:38.760 --> 00:19:42.210
We're really not leveraging
any of the language features.

00:19:42.210 --> 00:19:47.790
Again, similar to the last one,
it's still kind of an alias.

00:19:47.790 --> 00:19:50.040
But at least this one, you
can argue a little bit more

00:19:50.040 --> 00:19:52.410
for its merits.

00:19:52.410 --> 00:19:54.270
But there's a problem.

00:19:54.270 --> 00:19:59.770
While these two statements are
equivalent, what happens when--

00:19:59.770 --> 00:20:02.989
oh, one thing is that you can
at least static import SDK int,

00:20:02.989 --> 00:20:04.530
and then they're a
little bit closer.

00:20:04.530 --> 00:20:08.700
So that's one reason why
this is less justified.

00:20:08.700 --> 00:20:10.740
But one thing is
that an IF statement

00:20:10.740 --> 00:20:15.060
is a very primitive construct
of a programming language.

00:20:15.060 --> 00:20:19.100
And because an IF statement
is not just an IF statement,

00:20:19.100 --> 00:20:21.600
there's constructs like ELSE.

00:20:21.600 --> 00:20:23.340
So what if your
requirements change such

00:20:23.340 --> 00:20:25.980
that you need to alter
the behavior on these two

00:20:25.980 --> 00:20:27.600
different versions?

00:20:27.600 --> 00:20:31.410
Well, if you were using this
extension that you wrote,

00:20:31.410 --> 00:20:33.480
in order to support
this case, you either

00:20:33.480 --> 00:20:37.650
have to change back to
using an IF statement

00:20:37.650 --> 00:20:39.420
or you have to
modify the function,

00:20:39.420 --> 00:20:41.190
where maybe it takes
two lambdas now.

00:20:41.190 --> 00:20:44.340
One for the case where you're
above 19, one for the case

00:20:44.340 --> 00:20:46.770
where you're not.

00:20:46.770 --> 00:20:49.020
Because we're not taking two
lambdas in this function,

00:20:49.020 --> 00:20:52.110
we've lost the special
trailing lambda syntax,

00:20:52.110 --> 00:20:54.600
where we now have to pass
them as arguments inside

00:20:54.600 --> 00:20:58.110
the parentheses, whereas
before, we didn't.

00:20:58.110 --> 00:21:02.040
So immediately, this extension
starts falling apart.

00:21:02.040 --> 00:21:04.500
If we introduce another
conditional branch--

00:21:04.500 --> 00:21:07.910
maybe we need to vary
the behavior across APIs

00:21:07.910 --> 00:21:09.540
in three different ways--

00:21:09.540 --> 00:21:11.520
well, there's really
no way that we

00:21:11.520 --> 00:21:14.030
can make the extension do this.

00:21:14.030 --> 00:21:18.330
The other thing that is
different about this extension

00:21:18.330 --> 00:21:21.060
compared to the IF statement
is that we're assuming

00:21:21.060 --> 00:21:22.830
the conditional that
we want to check

00:21:22.830 --> 00:21:24.520
is greater than or equal to.

00:21:24.520 --> 00:21:26.550
That the behavior we want
to run in the lambda,

00:21:26.550 --> 00:21:29.900
we only want to run on 19-plus.

00:21:29.900 --> 00:21:32.460
Well, a lot of times, some
of the IF statements--

00:21:32.460 --> 00:21:35.100
again, SDK int-- will be
less than or equal to.

00:21:35.100 --> 00:21:37.650
And so now, we need a
second extension in order

00:21:37.650 --> 00:21:39.840
to support that use case.

00:21:43.570 --> 00:21:45.390
So this is another
example of something

00:21:45.390 --> 00:21:48.460
that we're not looking to do.

00:21:48.460 --> 00:21:51.270
We don't want to optimize
for just a single use

00:21:51.270 --> 00:21:56.310
case or a specific use case,
where the extension only

00:21:56.310 --> 00:21:59.710
supports one way
of doing something.

00:21:59.710 --> 00:22:02.470
And then, when you need to
move to something more complex,

00:22:02.470 --> 00:22:04.860
you have to revert to
the original behavior.

00:22:04.860 --> 00:22:07.890
We want the extensions
to allow you

00:22:07.890 --> 00:22:09.480
to express everything
you would need

00:22:09.480 --> 00:22:11.735
to express if it didn't exist.

00:22:17.701 --> 00:22:18.200
OK.

00:22:18.200 --> 00:22:21.080
So all the extensions we've
been talking about thus far

00:22:21.080 --> 00:22:23.660
have been ones that are
in the Core-KTX library.

00:22:26.360 --> 00:22:29.360
I don't want to go through
a ton of the extensions that

00:22:29.360 --> 00:22:30.680
are in these other libraries.

00:22:30.680 --> 00:22:33.960
Again, I'm going to show you how
you can discover them in a bit.

00:22:33.960 --> 00:22:36.970
But I want to touch on one.

00:22:41.110 --> 00:22:44.950
So for the fragment KTX,
we have an extension, which

00:22:44.950 --> 00:22:48.100
encapsulates transactions.

00:22:48.100 --> 00:22:51.820
We move the beginTransaction
and the commit function

00:22:51.820 --> 00:22:53.890
calls into an extension.

00:22:53.890 --> 00:22:57.880
We use the fact that we
can use an inline function

00:22:57.880 --> 00:23:00.820
and a lambda, again, to turn
this into a zero overhead

00:23:00.820 --> 00:23:02.340
thing.

00:23:02.340 --> 00:23:07.270
Our calling code then
becomes a little bit shorter,

00:23:07.270 --> 00:23:11.360
where we now use the
transaction with a lambda body.

00:23:11.360 --> 00:23:12.850
So if you've used
fragments, you'll

00:23:12.850 --> 00:23:17.050
know that commit is not
the only commit function.

00:23:17.050 --> 00:23:19.330
There's actually more than one.

00:23:19.330 --> 00:23:21.610
And so we can model
this by doing something

00:23:21.610 --> 00:23:25.030
like allowing you to
supply a Boolean as to

00:23:25.030 --> 00:23:28.990
whether or not you want to allow
state loss or disallow state

00:23:28.990 --> 00:23:31.130
loss when you're committing.

00:23:31.130 --> 00:23:34.100
This is really easy
to accommodate.

00:23:34.100 --> 00:23:36.500
But it sort of goes
against something

00:23:36.500 --> 00:23:38.860
I said earlier, where--

00:23:38.860 --> 00:23:41.700
oh, and we can update our call
site to be able to use this.

00:23:41.700 --> 00:23:44.090
It goes against something I
said earlier though, where

00:23:44.090 --> 00:23:48.200
I talked about minimizing the
impact of the implementation

00:23:48.200 --> 00:23:50.240
of these extensions.

00:23:50.240 --> 00:23:52.490
Since this is an
inline function,

00:23:52.490 --> 00:23:55.190
and then we've now put a
conditional inside that inline

00:23:55.190 --> 00:23:58.160
function, that conditional
is being inlined

00:23:58.160 --> 00:24:00.099
into all of the call sites.

00:24:00.099 --> 00:24:01.640
And so all of the
call sites now have

00:24:01.640 --> 00:24:05.010
to have that conditional
inside of them.

00:24:05.010 --> 00:24:06.530
So is this actually a bad thing?

00:24:09.129 --> 00:24:10.670
Well, if we look at
the bytecode that

00:24:10.670 --> 00:24:13.010
gets generated
from the call site,

00:24:13.010 --> 00:24:16.142
when we specify allow
state loss true--

00:24:16.142 --> 00:24:17.600
you don't really
have to understand

00:24:17.600 --> 00:24:19.910
bytecode to understand
what's going on here.

00:24:19.910 --> 00:24:22.160
There's essentially
three function calls.

00:24:22.160 --> 00:24:24.330
The first one is
beginTransaction.

00:24:24.330 --> 00:24:28.160
The second one is that replace,
which was inside the lambda.

00:24:28.160 --> 00:24:32.760
And the third one is just a
call to commitAllowingStateLoss.

00:24:32.760 --> 00:24:35.180
There's no IF statement here.

00:24:35.180 --> 00:24:38.860
There's no conditional.

00:24:38.860 --> 00:24:41.910
And that's because, since
this is an inline function

00:24:41.910 --> 00:24:44.680
and since the
argument is a Boolean,

00:24:44.680 --> 00:24:48.010
the compiler actually
knows, at compile time, what

00:24:48.010 --> 00:24:51.420
value you're supplying.

00:24:51.420 --> 00:24:53.225
And so since it knows
at compile time,

00:24:53.225 --> 00:24:55.340
it can actually do
dead code elimination

00:24:55.340 --> 00:25:00.090
and eliminate the branches that
can never possibly be executed.

00:25:00.090 --> 00:25:03.560
And so you actually
get, in bytecode,

00:25:03.560 --> 00:25:07.715
what's equivalent to what you
otherwise would have written.

00:25:07.715 --> 00:25:11.202
And there's actually
more commit functions.

00:25:11.202 --> 00:25:13.410
There's one which allow you
to commit now and commit.

00:25:13.410 --> 00:25:16.730
So we can also support that by
adding an additional Boolean.

00:25:16.730 --> 00:25:18.140
And the same thing happens here.

00:25:18.140 --> 00:25:20.770
Even though they're now
nested, dead code elimination

00:25:20.770 --> 00:25:23.210
will make it so that
there is only one function

00:25:23.210 --> 00:25:25.066
call in the resulting bytecode.

00:25:28.190 --> 00:25:30.460
OK.

00:25:30.460 --> 00:25:34.780
As part of this effort of
all these releases at I/O,

00:25:34.780 --> 00:25:36.190
one of the things
that we've done

00:25:36.190 --> 00:25:39.880
is start creating
a Kotlin-specific

00:25:39.880 --> 00:25:43.690
view of the libraries that
we publish in the Android

00:25:43.690 --> 00:25:46.070
framework itself.

00:25:46.070 --> 00:25:47.890
So if you see, in
that blue box there,

00:25:47.890 --> 00:25:51.070
when you visit the
reference docs,

00:25:51.070 --> 00:25:54.550
it'll actually ask
you if you want

00:25:54.550 --> 00:25:56.710
to view a Kotlin-specific
version of the platform

00:25:56.710 --> 00:25:58.480
or Android X libraries.

00:25:58.480 --> 00:26:02.230
And also, if you scroll down
in that left navigation pane,

00:26:02.230 --> 00:26:06.220
at the very bottom, we have
links to them, as well.

00:26:06.220 --> 00:26:11.800
And what these are are a
Kotlin view of these libraries.

00:26:11.800 --> 00:26:15.340
And so when you're browsing
through, say, the fragment

00:26:15.340 --> 00:26:19.750
package, you'll be able to see
the extensions for fragment

00:26:19.750 --> 00:26:21.250
inside the documentation.

00:26:21.250 --> 00:26:23.860
It's no longer
completely separate.

00:26:23.860 --> 00:26:25.390
One thing that's
missing right now

00:26:25.390 --> 00:26:27.010
is that we don't
actually tell you

00:26:27.010 --> 00:26:31.060
the maven coordinates of the
artifact that these come from.

00:26:31.060 --> 00:26:32.680
That's coming soon.

00:26:32.680 --> 00:26:35.560
And also, the
extensions in Core-KTX,

00:26:35.560 --> 00:26:39.490
which extend the
platform types, don't yet

00:26:39.490 --> 00:26:41.320
show up on the platform docs.

00:26:41.320 --> 00:26:43.270
But this is something
that we wanted

00:26:43.270 --> 00:26:47.080
to get out to show you
that it's being worked on.

00:26:47.080 --> 00:26:49.750
And so hopefully, those two
things will be coming soon.

00:26:54.180 --> 00:26:56.640
All right.

00:26:56.640 --> 00:26:58.350
I'm here to talk
about Android KTX.

00:26:58.350 --> 00:27:01.110
But Kotlin extensions--
there's nothing

00:27:01.110 --> 00:27:04.050
Android-specific about it.

00:27:04.050 --> 00:27:07.140
What we're doing is
building extensions

00:27:07.140 --> 00:27:10.630
to try and make these
libraries more Kotlin-friendly.

00:27:10.630 --> 00:27:13.810
And that's something
that any library can do.

00:27:13.810 --> 00:27:15.660
And so I want to
talk about the ways

00:27:15.660 --> 00:27:18.990
that we think about how
we can make libraries more

00:27:18.990 --> 00:27:21.600
Kotlin-friendly that apply to
both the Android libraries,

00:27:21.600 --> 00:27:23.924
but also apply to libraries
that you might be writing

00:27:23.924 --> 00:27:24.840
or you might be using.

00:27:28.500 --> 00:27:31.005
The first way to make a
library really Kotlin-friendly

00:27:31.005 --> 00:27:34.770
is just rewrite the
whole thing in Kotlin.

00:27:34.770 --> 00:27:37.650
Obviously, this isn't
feasible for every library,

00:27:37.650 --> 00:27:40.080
but it's certainly
an option for some.

00:27:40.080 --> 00:27:43.160
If it's a library that's
private to your app--

00:27:43.160 --> 00:27:47.600
it's in your repository or
it's internal to your company--

00:27:47.600 --> 00:27:51.710
and you're already using
Kotlin, this is a viable option.

00:27:51.710 --> 00:27:54.950
It doesn't seem like something
that's totally viable for, say,

00:27:54.950 --> 00:27:56.510
the Android framework.

00:27:56.510 --> 00:28:00.350
And I'm not quite sure we're
at the stage where an Android X

00:28:00.350 --> 00:28:02.180
library could do this.

00:28:02.180 --> 00:28:05.780
Maybe a future Android X library
could be written in Kotlin.

00:28:05.780 --> 00:28:08.288
That seems like a
strong possibility.

00:28:12.280 --> 00:28:15.640
What we've chosen to do
with most of the things

00:28:15.640 --> 00:28:18.970
that we publish is
sibling artifacts.

00:28:18.970 --> 00:28:21.700
So the main library
remains written

00:28:21.700 --> 00:28:23.110
using the Java language.

00:28:23.110 --> 00:28:26.350
And we ship Kotlin language
features as a sibling artifact.

00:28:26.350 --> 00:28:27.850
What's great about
this is you don't

00:28:27.850 --> 00:28:32.020
force the Kotlin standard
library onto your consumers

00:28:32.020 --> 00:28:34.300
unless they explicitly want it.

00:28:34.300 --> 00:28:36.310
You can curate the
extensions to be

00:28:36.310 --> 00:28:40.660
exactly what's needed
to augment your API,

00:28:40.660 --> 00:28:43.300
where you get the
Kotlin-specific features.

00:28:43.300 --> 00:28:45.160
And what's really
nice about this is you

00:28:45.160 --> 00:28:48.500
don't have to control the
library that you're extending.

00:28:48.500 --> 00:28:50.590
So if you're just
consuming a library

00:28:50.590 --> 00:28:54.084
and you want to make part
of it more Kotlin-friendly,

00:28:54.084 --> 00:28:54.750
you can do that.

00:28:54.750 --> 00:28:56.980
You can do that
either in your own app

00:28:56.980 --> 00:29:01.060
or you can publish a set
of extensions for a library

00:29:01.060 --> 00:29:02.380
that someone else publishes.

00:29:05.490 --> 00:29:10.690
But are these the
only two options?

00:29:10.690 --> 00:29:12.490
I want to take a
look at something

00:29:12.490 --> 00:29:18.271
that I think will lead into a
third somewhat hybrid option.

00:29:18.271 --> 00:29:22.080
And I go back to this simple
alias extension, where

00:29:22.080 --> 00:29:24.837
we've taken the static method
defined in the Java language

00:29:24.837 --> 00:29:27.420
and turned it into an extension
method in the Kotlin language.

00:29:30.710 --> 00:29:35.960
If we look at the implementation
of this class on the Java side,

00:29:35.960 --> 00:29:38.330
I've included the
first line, because we

00:29:38.330 --> 00:29:40.970
can see that it
immediately dereferences

00:29:40.970 --> 00:29:42.690
the argument that we pass in.

00:29:42.690 --> 00:29:44.770
As soon as we pass
in a string, it says,

00:29:44.770 --> 00:29:47.570
what's the maximum
number of characters

00:29:47.570 --> 00:29:49.310
that I can iterate
over, in order

00:29:49.310 --> 00:29:53.710
to determine whether or
not there are digits?

00:29:53.710 --> 00:29:59.740
And so if you've been using
Kotlin with Java APIs,

00:29:59.740 --> 00:30:03.250
you might know that this
means that the parameter is

00:30:03.250 --> 00:30:06.400
going to be exposed as what's
called a platform type.

00:30:06.400 --> 00:30:08.810
It has unknown nullability.

00:30:08.810 --> 00:30:12.070
But from the implementation,
we know right away that this

00:30:12.070 --> 00:30:17.420
method simply cannot
accept null values.

00:30:17.420 --> 00:30:18.880
And the way that
we would fix this

00:30:18.880 --> 00:30:22.890
is by adding the
non-null annotation.

00:30:22.890 --> 00:30:27.400
So what this annotation does is
it informs the Kotlin compiler

00:30:27.400 --> 00:30:28.900
that there is a restriction.

00:30:28.900 --> 00:30:31.090
That there is special
behavior that it

00:30:31.090 --> 00:30:32.590
needs to take into
account, where

00:30:32.590 --> 00:30:36.760
it needs to enforce
that no one passes

00:30:36.760 --> 00:30:43.590
a potentially nullable value,
or null, into this method.

00:30:43.590 --> 00:30:48.210
And so this is enabling a
language feature in Kotlin that

00:30:48.210 --> 00:30:50.970
simply doesn't exist in Java.

00:30:50.970 --> 00:30:55.560
Now, you can use tools that
will allow this enforcement

00:30:55.560 --> 00:30:57.150
to work for Java.

00:30:57.150 --> 00:30:59.070
But it's not intrinsic
to the language itself.

00:31:02.610 --> 00:31:04.870
So if we can do something
like that for nullness--

00:31:04.870 --> 00:31:06.620
if we can add this
annotation for nullness

00:31:06.620 --> 00:31:08.630
to inform the Kotlin
compiler that it needs

00:31:08.630 --> 00:31:12.440
to change its behavior
when we invoke this method,

00:31:12.440 --> 00:31:14.960
can we do this for
something else?

00:31:14.960 --> 00:31:19.280
Say, I want to take this static
method where the first argument

00:31:19.280 --> 00:31:22.040
is really the receiver.

00:31:22.040 --> 00:31:23.630
And can I say that
this is actually

00:31:23.630 --> 00:31:26.150
going to be an
extension function when

00:31:26.150 --> 00:31:27.050
invoked from Kotlin?

00:31:29.750 --> 00:31:32.180
And what this allows
us to do, potentially,

00:31:32.180 --> 00:31:35.210
is eliminate the need to
have this explicitly-defined

00:31:35.210 --> 00:31:37.310
extension at all.

00:31:37.310 --> 00:31:40.370
This extension only exists to
change the calling convention,

00:31:40.370 --> 00:31:43.699
to inform the compiler that we
want to allow you to call it

00:31:43.699 --> 00:31:44.490
in a different way.

00:31:48.027 --> 00:31:49.610
And so now, we're
left with just this.

00:31:49.610 --> 00:31:52.650
The Kotlin compiler
sees that annotation,

00:31:52.650 --> 00:31:54.830
just like it saw the
non-null annotation,

00:31:54.830 --> 00:31:56.820
infers something
from it, and allows

00:31:56.820 --> 00:31:58.530
you to call it in
a way that's more

00:31:58.530 --> 00:32:00.320
idiomatic for that language.

00:32:03.570 --> 00:32:06.510
In the bytecode, we get what we
otherwise would have written.

00:32:06.510 --> 00:32:09.540
We still get the call
to the static method,

00:32:09.540 --> 00:32:11.400
and the receiver becomes
the first argument.

00:32:14.346 --> 00:32:15.819
How about this example?

00:32:19.982 --> 00:32:21.440
One thing you might
have noticed is

00:32:21.440 --> 00:32:25.860
that this extension is named
updatePadding, not setPadding.

00:32:25.860 --> 00:32:29.931
Now, we can actually call
this extension setPadding.

00:32:29.931 --> 00:32:31.430
But the problem is
that it will only

00:32:31.430 --> 00:32:33.356
work for a subset of arguments.

00:32:33.356 --> 00:32:34.730
So in this case,
where we're just

00:32:34.730 --> 00:32:38.600
passing left and right values,
we could call that setPadding,

00:32:38.600 --> 00:32:40.220
and it would work fine.

00:32:40.220 --> 00:32:44.600
But if we passed left-right
and then top-bottom,

00:32:44.600 --> 00:32:47.510
we'd be supplying
four arguments.

00:32:47.510 --> 00:32:49.670
And the Kotlin compiler
is going to see

00:32:49.670 --> 00:32:53.420
that the real set padding
also accepts four arguments.

00:32:53.420 --> 00:32:55.930
And it's going to prefer
calling the real one.

00:32:55.930 --> 00:32:57.980
And the real one doesn't
have named parameters.

00:32:57.980 --> 00:33:00.260
So you're going to get
a compilation error.

00:33:00.260 --> 00:33:02.766
That's the reason we have
to name this updatePadding.

00:33:05.890 --> 00:33:07.930
If we look at the
real setPadding--

00:33:07.930 --> 00:33:11.740
a simple method that
takes four integers--

00:33:11.740 --> 00:33:15.040
what if we could inform
the Kotlin compiler

00:33:15.040 --> 00:33:18.440
that these parameters have
names associated with them?

00:33:21.860 --> 00:33:24.490
Now, it'd be nice to infer this
just from the parameter names

00:33:24.490 --> 00:33:28.060
directly and not have to
specify the redundancy.

00:33:28.060 --> 00:33:29.890
But I'll argue
that, for one, it's

00:33:29.890 --> 00:33:35.080
very nice being explicit about
these names in the annotation.

00:33:35.080 --> 00:33:37.210
In Java 8 bytecode,
there actually

00:33:37.210 --> 00:33:41.630
is a way for you to
retain parameter names.

00:33:41.630 --> 00:33:44.260
So the Kotlin compiler
could, in theory, use those.

00:33:44.260 --> 00:33:46.360
But one problem is
that then it becomes

00:33:46.360 --> 00:33:47.530
an all-or-nothing thing.

00:33:47.530 --> 00:33:50.830
You have to opt in
to this behavior.

00:33:50.830 --> 00:33:52.690
And then suddenly,
every parameter name

00:33:52.690 --> 00:33:54.795
across your library
is set in stone.

00:33:54.795 --> 00:33:56.170
Whereas, with
annotations, that's

00:33:56.170 --> 00:34:00.740
something that you could
incrementally migrate.

00:34:00.740 --> 00:34:05.490
So this has the potential to
solve the naming part where,

00:34:05.490 --> 00:34:08.540
now, we can call the
real method from Kotlin

00:34:08.540 --> 00:34:11.960
and specify the four arguments
in any order that we want,

00:34:11.960 --> 00:34:16.323
based on what names we provide.

00:34:16.323 --> 00:34:17.489
How about the default value?

00:34:21.050 --> 00:34:24.389
What if we could specify
a Kotlin expression,

00:34:24.389 --> 00:34:28.889
which allowed the compiler
to supply a default when

00:34:28.889 --> 00:34:31.320
one wasn't supplied by you?

00:34:34.469 --> 00:34:39.120
This would change our original
extension calling convention

00:34:39.120 --> 00:34:42.239
from calling our extension
to actually just using

00:34:42.239 --> 00:34:45.199
the real method.

00:34:45.199 --> 00:34:47.300
And then, in the
bytecode, we get the thing

00:34:47.300 --> 00:34:52.040
that we started with, the thing
that our explicit extension

00:34:52.040 --> 00:34:53.449
would inline to.

00:34:53.449 --> 00:34:56.300
But now, the extension
doesn't have to exist.

00:34:56.300 --> 00:35:00.710
The metadata that we added
in the form of annotations

00:35:00.710 --> 00:35:02.630
informed the Kotlin
compiler that we

00:35:02.630 --> 00:35:05.270
wanted to enhance
our ability to call

00:35:05.270 --> 00:35:07.910
this function in a
Kotlin-specific way,

00:35:07.910 --> 00:35:10.860
leveraging the Kotlin features.

00:35:10.860 --> 00:35:12.040
And so we're able to do so.

00:35:15.870 --> 00:35:20.860
So Kotlin has this process,
which is called KEEP.

00:35:20.860 --> 00:35:25.720
It's Kotlin Evolution
and Enhancement Process.

00:35:25.720 --> 00:35:31.680
And just this morning, we
proposed these annotations

00:35:31.680 --> 00:35:33.270
as KEEP-110.

00:35:33.270 --> 00:35:34.770
So this is something
we're proposing

00:35:34.770 --> 00:35:39.810
to add to the Kotlin
compiler, so that it can

00:35:39.810 --> 00:35:42.000
understand these annotations.

00:35:42.000 --> 00:35:44.310
We have ExtensionFunction
and ExtensionProperty,

00:35:44.310 --> 00:35:47.880
which are for static
methods; DefaultValue,

00:35:47.880 --> 00:35:52.230
which allow supply and
default values for parameters;

00:35:52.230 --> 00:35:54.360
and then KtName,
which allows you

00:35:54.360 --> 00:35:59.610
to provide an alternate name for
methods, fields, or parameters.

00:35:59.610 --> 00:36:05.640
Now, it's very important to note
that this is extremely early.

00:36:05.640 --> 00:36:06.890
These names might change.

00:36:06.890 --> 00:36:08.370
The semantics might change.

00:36:08.370 --> 00:36:10.290
This may never
actually be accepted

00:36:10.290 --> 00:36:12.420
into the Kotlin compiler.

00:36:12.420 --> 00:36:14.490
We have been working
with the JetBrains team

00:36:14.490 --> 00:36:15.810
for quite a while on this.

00:36:15.810 --> 00:36:18.690
And some of this is
already prototyped

00:36:18.690 --> 00:36:21.210
inside the Kotlin compiler.

00:36:21.210 --> 00:36:25.110
We really think this would be
a way that we could enhance

00:36:25.110 --> 00:36:29.010
the Android framework
for Kotlin callers,

00:36:29.010 --> 00:36:32.160
without actually having to
go and rewrite the Android

00:36:32.160 --> 00:36:35.561
framework, or at least its API,
in Kotlin, which is really not

00:36:35.561 --> 00:36:36.060
feasible.

00:36:38.770 --> 00:36:42.620
And it's also important to note
that, while this is an option--

00:36:42.620 --> 00:36:47.280
assuming that it actually makes
it into the Kotlin compiler--

00:36:47.280 --> 00:36:49.260
it doesn't totally
solve every problem

00:36:49.260 --> 00:36:54.090
that our existing
extensions are solving.

00:36:54.090 --> 00:36:58.200
We determined these annotations
that we proposed in KEEP-110

00:36:58.200 --> 00:37:01.380
through looking through a
bunch of open source libraries,

00:37:01.380 --> 00:37:03.510
looking through
our own libraries,

00:37:03.510 --> 00:37:07.140
and seeing what we thought would
be the most useful extensions--

00:37:07.140 --> 00:37:15.270
what the pattern of Java methods
were, such that they would want

00:37:15.270 --> 00:37:18.710
to be turned into extensions.

00:37:18.710 --> 00:37:22.880
And so the latter two
really are complementary.

00:37:22.880 --> 00:37:24.830
The big advantages
of the annotations

00:37:24.830 --> 00:37:28.280
is that you retain the
single source of truth.

00:37:28.280 --> 00:37:31.430
You don't have to
really know Kotlin.

00:37:31.430 --> 00:37:34.540
You don't have to add Kotlin
compiler to your build system.

00:37:34.540 --> 00:37:37.100
You don't have to publish
sibling artifacts.

00:37:37.100 --> 00:37:39.080
Even if you're a
pure Java library,

00:37:39.080 --> 00:37:43.460
you can add these annotations
and just enhance your API, so

00:37:43.460 --> 00:37:45.890
that Kotlin callers get
the more idiomatic syntax.

00:37:50.310 --> 00:37:51.080
All right.

00:37:51.080 --> 00:37:56.150
So to sum up, Core-KTX is
now part of Android Jetpack--

00:37:56.150 --> 00:38:00.150
versioned with Android Jetpack,
released with Android Jetpack.

00:38:00.150 --> 00:38:04.070
There's a few new artifacts, as
you can see here on the screen.

00:38:04.070 --> 00:38:06.320
There's definitely more coming.

00:38:06.320 --> 00:38:08.180
Notable ones that
we think are missing

00:38:08.180 --> 00:38:10.520
are slices and view model.

00:38:10.520 --> 00:38:12.980
So I would not be
surprised to see artifacts

00:38:12.980 --> 00:38:14.705
for those in the coming months.

00:38:17.470 --> 00:38:19.987
Please check out
the Kotlin version

00:38:19.987 --> 00:38:21.070
of the reference document.

00:38:25.600 --> 00:38:28.240
This is extremely early.

00:38:28.240 --> 00:38:30.190
This required
changes in [? doca ?]

00:38:30.190 --> 00:38:31.470
and how we produce docs.

00:38:31.470 --> 00:38:33.940
And so it's something
that we just

00:38:33.940 --> 00:38:36.172
wanted to get out there
and show you as a preview.

00:38:36.172 --> 00:38:37.630
This is definitely
something that's

00:38:37.630 --> 00:38:38.860
being actively worked on.

00:38:41.980 --> 00:38:44.800
There's a new component
on the Android bug

00:38:44.800 --> 00:38:48.480
tracker for Android KTX.

00:38:48.480 --> 00:38:51.730
Because Core-KTX and
all the KTX libraries

00:38:51.730 --> 00:38:54.610
are now a part of Jetpack,
the source of truth

00:38:54.610 --> 00:39:00.280
has moved into the Android
Support Repository.

00:39:00.280 --> 00:39:03.150
We're going to be migrating
the GitHub issues on the GitHub

00:39:03.150 --> 00:39:08.100
project over to this bug
tracker in the coming weeks.

00:39:08.100 --> 00:39:09.910
But it's important to
note that we're still

00:39:09.910 --> 00:39:14.020
going to be accepting pull
requests to the GitHub repo

00:39:14.020 --> 00:39:16.000
and syncing things back
out to the GitHub repo.

00:39:16.000 --> 00:39:17.920
It's just that the
issues will no longer be

00:39:17.920 --> 00:39:19.607
the source of truth on GitHub.

00:39:19.607 --> 00:39:21.190
It will be on the
Android bug tracker.

00:39:24.840 --> 00:39:26.910
The [? KEEP ?] was proposed--

00:39:26.910 --> 00:39:30.030
I created the pull
requests about an hour ago.

00:39:30.030 --> 00:39:31.260
Please go check that out.

00:39:31.260 --> 00:39:36.020
The document contains a lot
more detail about examples.

00:39:36.020 --> 00:39:38.670
And like I said, the
annotations that were chosen

00:39:38.670 --> 00:39:41.044
were the ones that we
think have the most impact.

00:39:41.044 --> 00:39:42.460
But at the bottom
of the document,

00:39:42.460 --> 00:39:45.960
you'll see that, if something
like this gets accepted,

00:39:45.960 --> 00:39:48.450
there's a potential for future
enhancement of even more.

00:39:51.240 --> 00:39:54.210
The link to that should be this.

00:39:54.210 --> 00:39:56.390
I made this link last night
before I submitted it.

00:39:56.390 --> 00:39:59.750
So hopefully, it's accurate.

00:39:59.750 --> 00:40:00.470
And that's it.

00:40:00.470 --> 00:40:01.257
Thank you.

00:40:01.257 --> 00:40:03.242
[APPLAUSE]

00:40:03.742 --> 00:40:07.477
[MUSIC PLAYING]

