WEBVTT
Kind: captions
Language: en

00:00:03.000 --> 00:00:04.300
Russell:
Good afternoon.

00:00:04.300 --> 00:00:05.534
I'm Alex Russell.

00:00:05.534 --> 00:00:06.701
I'm a software engineer
on the Chrome Team.

00:00:06.701 --> 00:00:08.434
Thanks for tearing yourself
away from lunch

00:00:08.434 --> 00:00:10.200
to come hear
about JavaScript.

00:00:10.200 --> 00:00:14.501
So like I said, I'm an engineer
on the Chrome Team,

00:00:14.501 --> 00:00:15.767
and before I joined Google,

00:00:15.767 --> 00:00:18.400
I spent a lot of my life
working in JavaScript.

00:00:18.400 --> 00:00:21.534
I joined the Chrome Team from
a web development background,

00:00:21.534 --> 00:00:23.300
specifically working on open
source JavaScript tool kits

00:00:23.300 --> 00:00:24.567
and before that,

00:00:24.567 --> 00:00:26.934
working web application
development and security.

00:00:26.934 --> 00:00:30.934
And before my recent
detour into C++,

00:00:30.934 --> 00:00:33.033
I spent most of my day
trying to figure out

00:00:33.033 --> 00:00:35.767
how to make JavaScript
do interesting things.

00:00:35.767 --> 00:00:39.033
My personal history with
JavaScript started in 1997,

00:00:39.033 --> 00:00:42.334
I think when a lot of us started
to be cognizant of the web.

00:00:42.334 --> 00:00:44.534
And at the time, JavaScript
was this thing

00:00:44.534 --> 00:00:46.367
that was starting
to become powerful

00:00:46.367 --> 00:00:47.834
and somewhat standardized

00:00:47.834 --> 00:00:52.567
and somewhat widely available on
the back of the browser wars.

00:00:52.567 --> 00:00:54.868
So I want to talk a lot about

00:00:54.868 --> 00:00:56.634
how we got to where we are
today with JavaScript,

00:00:56.634 --> 00:00:58.434
why it's so important,
why that history,

00:00:58.434 --> 00:01:00.767
that long history continues

00:01:00.767 --> 00:01:03.167
to figure into the sorts of
things we try to do

00:01:03.167 --> 00:01:05.334
with JavaScript on
a day-to-day basis.

00:01:05.334 --> 00:01:07.667
And I want to take you
through what's really

00:01:07.667 --> 00:01:08.701
inside of JavaScript.

00:01:08.701 --> 00:01:10.767
What is it about
JavaScript that it is,

00:01:10.767 --> 00:01:12.367
that makes it so different
to the languages

00:01:12.367 --> 00:01:14.234
that you might be using
in your day-to-day work

00:01:14.234 --> 00:01:17.534
that aren't JavaScript,
because there's a lot that is.

00:01:17.534 --> 00:01:19.067
Exactly where
are we right now?

00:01:19.067 --> 00:01:20.601
Because I think
this is also sort of

00:01:20.601 --> 00:01:23.300
an ambiguous question, right?
If you're a browser bender,

00:01:23.300 --> 00:01:27.467
it's easy to say
we're this fast--easy-ish.

00:01:27.467 --> 00:01:28.634
If you're a web developer,

00:01:28.634 --> 00:01:29.801
you can look
in your deployed base

00:01:29.801 --> 00:01:31.667
and understand
who's got what,

00:01:31.667 --> 00:01:32.767
but that doesn't necessarily
tell you anything

00:01:32.767 --> 00:01:34.167
about the future.

00:01:34.167 --> 00:01:36.067
And I want to spend a lot
of time today talking about

00:01:36.067 --> 00:01:38.467
how it is that we are going
to get a different future

00:01:38.467 --> 00:01:39.601
for JavaScript,

00:01:39.601 --> 00:01:40.934
because JavaScript,
like the browsers,

00:01:40.934 --> 00:01:42.367
is starting to move again,

00:01:42.367 --> 00:01:46.667
and I want to
tear back the veil

00:01:46.667 --> 00:01:48.033
that covers each of
these topics

00:01:48.033 --> 00:01:49.767
and help you understand
exactly what's going on

00:01:49.767 --> 00:01:52.400
and how these parts relate to
each other, because they do.

00:01:52.400 --> 00:01:54.234
The history informs
the future,

00:01:54.234 --> 00:01:57.901
and the current state informs
what's going to happen next.

00:01:57.901 --> 00:02:00.033
So JavaScript is
a functional language.

00:02:00.033 --> 00:02:02.367
So how many of you write
in other functional languages

00:02:02.367 --> 00:02:04.000
or are familiar with
functional languages?

00:02:04.000 --> 00:02:05.267
Awesome.

00:02:05.267 --> 00:02:06.767
The front of this talk is
going to be something

00:02:06.767 --> 00:02:10.367
that maybe just warms your heart
and may not be new information.

00:02:10.367 --> 00:02:12.734
So JavaScript is
a functional language.

00:02:12.734 --> 00:02:18.534
In the sort of the history
of functional languages,

00:02:18.534 --> 00:02:19.834
it supports closures.

00:02:19.834 --> 00:02:21.200
Much like Scheme,

00:02:21.200 --> 00:02:25.300
it's got this nice
first class function system,

00:02:25.300 --> 00:02:30.567
and in 1995, Brenda and I hacked
it up as a little prototype

00:02:30.567 --> 00:02:32.434
which made its way
into Netscape 2,

00:02:32.434 --> 00:02:34.400
and Netscape 2
was the first browser

00:02:34.400 --> 00:02:36.767
to really have any serious
scripting supported.

00:02:36.767 --> 00:02:40.601
It had DOM level 0,
and soon afterwards,

00:02:40.601 --> 00:02:43.300
JavaScript sort of, you know,

00:02:43.300 --> 00:02:44.634
once it escaped
into the browser,

00:02:44.634 --> 00:02:46.968
started the standards
process at ECMA,

00:02:46.968 --> 00:02:48.300
not inside the W3C,

00:02:48.300 --> 00:02:52.367
because the W3C wasn't
the place for languages.

00:02:52.367 --> 00:02:55.501
And in 1997, we got
the first version of JavaScript

00:02:55.501 --> 00:02:56.767
as a standard.

00:02:56.767 --> 00:03:02.133
In 1996, Microsoft
shipped IE 3.0,

00:03:02.133 --> 00:03:03.868
and that was the first version
of JScript.

00:03:03.868 --> 00:03:05.801
So we now had two competing,

00:03:05.801 --> 00:03:07.400
mostly compatible
implementations

00:03:07.400 --> 00:03:09.501
of a scripting language
for the web.

00:03:09.501 --> 00:03:11.167
Nobody knew how big
the web was going to be,

00:03:11.167 --> 00:03:12.334
although, at the time,

00:03:12.334 --> 00:03:14.534
it looked like things
were trending up.

00:03:14.534 --> 00:03:15.801
Well, we know how
that story ends.

00:03:15.801 --> 00:03:17.968
Today, you can't ship
a credible platform

00:03:17.968 --> 00:03:19.634
that doesn't have the web.

00:03:19.634 --> 00:03:23.901
In 1999, ECMAScript
version 3

00:03:23.901 --> 00:03:27.434
was finalized at TC39,
which is the technical committee

00:03:27.434 --> 00:03:32.934
that is the standards body
for JavaScript.

00:03:32.934 --> 00:03:34.200
And from its humble roots

00:03:34.200 --> 00:03:39.400
as Mocha/LiveScript/JavaScript
in Netscape 2,

00:03:39.400 --> 00:03:43.834
JavaScript 3, ECMAScript 262-3,
the version or the standard

00:03:43.834 --> 00:03:48.701
that was released in 1999 has
powered us pretty much to today.

00:03:48.701 --> 00:03:51.100
It has been the thing
that for more than a decade

00:03:51.100 --> 00:03:54.167
has been what
we think of as JavaScript.

00:03:54.167 --> 00:03:57.000
And JavaScript, on the back
of that standard,

00:03:57.000 --> 00:03:58.767
has gone pretty much everywhere.

00:03:58.767 --> 00:04:01.868
JScript, the component that runs
JavaScript inside of IE,

00:04:01.868 --> 00:04:04.934
has been built in to the OS
for Windows since Windows 98.

00:04:04.934 --> 00:04:06.901
You can't get
a copy of Windows,

00:04:06.901 --> 00:04:08.334
you can't buy
a copy of Windows today

00:04:08.334 --> 00:04:11.133
that does not include
JavaScript in the OS,

00:04:11.133 --> 00:04:13.234
and every browser on the planet
now includes

00:04:13.234 --> 00:04:14.801
at least one implementation of
JavaScript,

00:04:14.801 --> 00:04:16.400
and these things are moving
really, really fast.

00:04:16.400 --> 00:04:20.200
I work on the Chrome Team;
therefore, I'm partial to V8.

00:04:20.200 --> 00:04:21.701
It goes nice and quickly,

00:04:21.701 --> 00:04:23.100
but these things
are all compatible

00:04:23.100 --> 00:04:24.601
to a very high degree.

00:04:24.601 --> 00:04:27.033
All of these implementations
are separate implementations,

00:04:27.033 --> 00:04:28.634
and they're competing
on things that aren't,

00:04:28.634 --> 00:04:30.033
"Oh, here's a new language
feature."

00:04:30.033 --> 00:04:31.968
We're collaborating
on language features

00:04:31.968 --> 00:04:33.033
in the standards committee,

00:04:33.033 --> 00:04:36.234
but we're competing
on performance,

00:04:36.234 --> 00:04:38.000
which is a really great place
to be for a language,

00:04:38.000 --> 00:04:39.467
because it takes
a lot of investment

00:04:39.467 --> 00:04:40.767
to make a language
a real success.

00:04:40.767 --> 00:04:42.100
It takes
a lot of deployment,

00:04:42.100 --> 00:04:43.901
a lot of competition,
and a lot of investment

00:04:43.901 --> 00:04:45.234
to sort of get
the really smart guys

00:04:45.234 --> 00:04:47.667
that it takes to go make
a VM go like hell.

00:04:47.667 --> 00:04:49.801
And so JavaScript has been
the beneficiary

00:04:49.801 --> 00:04:52.434
of this sort of ecosystem of
investment in a way

00:04:52.434 --> 00:04:54.667
that only a couple of languages
before it ever have.

00:04:54.667 --> 00:04:58.567
And as a result, today's
JavaScript runtimes

00:04:58.567 --> 00:05:00.634
and today's JavaScript
performance are vastly different

00:05:00.634 --> 00:05:03.734
than they have been in the past,
even the recent past.

00:05:03.734 --> 00:05:07.000
And so every device
that you get today,

00:05:07.000 --> 00:05:09.534
including the tablets that were
handed out to you yesterday

00:05:09.534 --> 00:05:15.400
and the Chrome books that you'll
be receiving as attendees

00:05:15.400 --> 00:05:17.467
on June 15th,

00:05:17.467 --> 00:05:21.000
these all have JavaScript as
a core part of their runtimes

00:05:21.000 --> 00:05:22.367
because the web
is the platform.

00:05:22.367 --> 00:05:24.234
The web is the way
that you're going to build

00:05:24.234 --> 00:05:25.400
a lot of the applications

00:05:25.400 --> 00:05:26.601
that your user
is going to care about,

00:05:26.601 --> 00:05:28.267
and it's the way to build
portably today.

00:05:28.267 --> 00:05:33.234
So JavaScript is everywhere,
and it's terribly misunderstood.

00:05:33.234 --> 00:05:36.334
And I think what I want to do
first here

00:05:36.334 --> 00:05:38.067
is to talk you
through the parts

00:05:38.067 --> 00:05:40.801
that most people don't
really have a sense of,

00:05:40.801 --> 00:05:42.133
when they talk about,

00:05:42.133 --> 00:05:43.901
like, what is it that makes
JavaScript different?

00:05:43.901 --> 00:05:45.067
Because we hear it's
a dynamic language.

00:05:45.067 --> 00:05:46.400
We hear it's
a functional language.

00:05:46.400 --> 00:05:48.434
But it looks a lot like C.
It looks a lot like Java.

00:05:48.434 --> 00:05:49.567
It looks a lot like C++.

00:05:49.567 --> 00:05:51.067
And some folks have been
doing a great job

00:05:51.067 --> 00:05:53.534
in the last couple of years at
sort of helping to tear back

00:05:53.534 --> 00:05:55.868
the blinders
that are on us,

00:05:55.868 --> 00:05:59.000
as folks who come from
a C or C++ background,

00:05:59.000 --> 00:06:01.367
and help lay out what it is.

00:06:01.367 --> 00:06:02.767
But I want to go
through it very briefly,

00:06:02.767 --> 00:06:04.834
because I think it's
important to understand

00:06:04.834 --> 00:06:06.267
what's actually in there,

00:06:06.267 --> 00:06:07.501
because when we understand
what's actually in there,

00:06:07.501 --> 00:06:09.467
we'll understand how
the language can evolve,

00:06:09.467 --> 00:06:11.767
because you don't want
necessarily separate--

00:06:11.767 --> 00:06:14.501
competing ideas to be existing
inside the same language.

00:06:14.501 --> 00:06:16.734
You want a language to sort of
have a theory of itself.

00:06:16.734 --> 00:06:20.234
You want it to be coherent
in ways that make it,

00:06:20.234 --> 00:06:21.734
so that when you understand
one part of the language,

00:06:21.734 --> 00:06:23.234
you can understand
the next part of it.

00:06:23.234 --> 00:06:24.767
And my interest in this is
coming from a background

00:06:24.767 --> 00:06:26.133
as a web developer,

00:06:26.133 --> 00:06:29.000
I serve as one of Google's
representatives to TC39,

00:06:29.000 --> 00:06:31.067
the standards committee
for JavaScript.

00:06:31.067 --> 00:06:32.868
And so I have a particular
and keen interest

00:06:32.868 --> 00:06:34.501
in making sure that we evolve
the language in ways

00:06:34.501 --> 00:06:38.534
that are reasonable
and solve real world problems

00:06:38.534 --> 00:06:39.801
that we've all got.

00:06:39.801 --> 00:06:43.734
So JavaScript only has
a couple of key languages.

00:06:43.734 --> 00:06:46.901
I said earlier that JavaScript
is a little functional language,

00:06:46.901 --> 00:06:49.100
and JavaScript started out as
a very small language entity.

00:06:49.100 --> 00:06:50.701
There aren't a lot
of core concepts.

00:06:50.701 --> 00:06:52.100
There's no type
system, per se.

00:06:52.100 --> 00:06:53.367
There are types.

00:06:53.367 --> 00:06:57.634
You can have a number,
or an object, or an array,

00:06:57.634 --> 00:06:59.033
but there's no
type testing.

00:06:59.033 --> 00:07:01.901
There's no way to define
your own types, necessarily,

00:07:01.901 --> 00:07:05.634
and have them participate at,
like, function call time

00:07:05.634 --> 00:07:07.400
and have the system throw
an exception for you,

00:07:07.400 --> 00:07:09.701
unless you do the testing
yourself.

00:07:09.701 --> 00:07:11.868
And JavaScript
reads top to bottom.

00:07:11.868 --> 00:07:13.701
JavaScript has
run-to-completion semantics.

00:07:13.701 --> 00:07:15.167
That means that if you
start a body of code,

00:07:15.167 --> 00:07:16.901
there's no multithreading
in the language.

00:07:16.901 --> 00:07:19.300
There's no way for you to sort
of fork off some other process.

00:07:19.300 --> 00:07:22.334
Anything that does that in
a JavaScript environment

00:07:22.334 --> 00:07:23.834
is doing it as a built-on.

00:07:23.834 --> 00:07:26.634
So browsers with their set
timeout and their set interval.

00:07:26.634 --> 00:07:29.701
That's all happening outside
of the core language semantics.

00:07:29.701 --> 00:07:31.067
JavaScript reads
top to bottom,

00:07:31.067 --> 00:07:33.667
and the interpreter
and runtimes read it exactly

00:07:33.667 --> 00:07:35.100
and run it exactly that way.

00:07:35.100 --> 00:07:36.601
If you see a block of
JavaScript code,

00:07:36.601 --> 00:07:39.868
it goes from top to bottom,
and that'll become important,

00:07:39.868 --> 00:07:42.367
as we see in
just a minute.

00:07:42.367 --> 00:07:44.167
Almost everything in
JavaScript is mutable.

00:07:44.167 --> 00:07:46.367
That means that you can
change nearly everything,

00:07:46.367 --> 00:07:50.968
and we'll talk about the
several exemptions to this rule,

00:07:50.968 --> 00:07:52.534
but those exemptions
are very small,

00:07:52.534 --> 00:07:55.234
and they're very narrow,
but they wind up being powerful.

00:07:55.234 --> 00:07:56.801
So that means that if you
get an object back from

00:07:56.801 --> 00:07:57.968
some function call,

00:07:57.968 --> 00:08:00.000
you can probably change it
in JavaScript.

00:08:00.000 --> 00:08:01.868
Closure is the way we do
private state, though,

00:08:01.868 --> 00:08:02.901
so if I get an object,

00:08:02.901 --> 00:08:04.334
and everything is mutable,

00:08:04.334 --> 00:08:05.734
it means, ah, I might be able
to surprise somebody else.

00:08:05.734 --> 00:08:07.033
I might be able to go
change some state out

00:08:07.033 --> 00:08:08.367
from underneath them.

00:08:08.367 --> 00:08:10.167
The thing that returned me
the object might expect it

00:08:10.167 --> 00:08:13.300
back in some
reasonably okay state.

00:08:13.300 --> 00:08:15.100
Well, the way we do data
hiding in JavaScript

00:08:15.100 --> 00:08:17.400
isn't through the private key
order,

00:08:17.400 --> 00:08:20.033
through some method that gives
you some sort of a private field

00:08:20.033 --> 00:08:21.968
that you can only see.

00:08:21.968 --> 00:08:24.334
Instead, we invert
the relationship

00:08:24.334 --> 00:08:26.734
between classes and functions,

00:08:26.734 --> 00:08:30.701
and we treat functions as
behavior that can carry data,

00:08:30.701 --> 00:08:31.834
versus classes,

00:08:31.834 --> 00:08:33.601
which are data that can
carry behavior.

00:08:33.601 --> 00:08:37.234
And so the last key concept is,
instead of having a class,

00:08:37.234 --> 00:08:38.534
as you understand it in
other languages,

00:08:38.534 --> 00:08:40.000
we have prototypes,

00:08:40.000 --> 00:08:43.534
which is to say we don't have
this strong "is a" relationship

00:08:43.534 --> 00:08:45.400
through a hierarchy
of classes.

00:08:45.400 --> 00:08:46.767
Instead, we say,
when I don't find it here,

00:08:46.767 --> 00:08:48.267
please look over there.

00:08:48.267 --> 00:08:52.767
It's delegation, and
it's a one-link chain delegation

00:08:52.767 --> 00:08:54.801
up to a root object
that everybody shares.

00:08:54.801 --> 00:08:57.467
So we'll talk a lot about
how exactly all this works,

00:08:57.467 --> 00:08:58.701
how it fits together,

00:08:58.701 --> 00:09:01.667
and hopefully you'll
understand at the end

00:09:01.667 --> 00:09:04.167
how it's going to inform
where we can go from here.

00:09:04.167 --> 00:09:07.000
I said earlier that
JavaScript runs top to bottom.

00:09:07.000 --> 00:09:09.400
That means if I see
a piece of code in JavaScript,

00:09:09.400 --> 00:09:10.734
one line before the next,

00:09:10.734 --> 00:09:13.100
before the next--because there
isn't necessarily

00:09:13.100 --> 00:09:14.400
a compile cycle.

00:09:14.400 --> 00:09:17.968
Most JavaScript runtimes
traditionally were interpreters.

00:09:17.968 --> 00:09:19.234
That means that the easiest way

00:09:19.234 --> 00:09:20.734
to think about your
JavaScript program

00:09:20.734 --> 00:09:26.400
is as something that is going
to happen in a live environment.

00:09:26.400 --> 00:09:28.167
So if you had
a command line,

00:09:28.167 --> 00:09:29.434
and you started typing in
commands,

00:09:29.434 --> 00:09:32.133
JavaScript runs almost
exactly the same way.

00:09:32.133 --> 00:09:34.601
Top to bottom,
line for line,

00:09:34.601 --> 00:09:40.968
it gets evaluated in the order
that it is written out

00:09:40.968 --> 00:09:42.968
in the program,
more or less.

00:09:42.968 --> 00:09:44.567
And so
statement to statement,

00:09:44.567 --> 00:09:47.400
your programs--they can change
in ways that are surprising

00:09:47.400 --> 00:09:48.834
in other languages.

00:09:48.834 --> 00:09:50.234
Where you might otherwise
have compile time exceptions,

00:09:50.234 --> 00:09:52.467
JavaScript just sort of
merrily goes on

00:09:52.467 --> 00:09:53.701
and runs the next line.

00:09:53.701 --> 00:09:56.367
So whenever we read
some JavaScript code,

00:09:56.367 --> 00:09:59.400
it's important to think about
it simply as running at the top

00:09:59.400 --> 00:10:00.534
and going to the bottom.

00:10:00.534 --> 00:10:03.534
It's not really
some big magical machine

00:10:03.534 --> 00:10:05.367
that's going to be out there
doing something for you,

00:10:05.367 --> 00:10:07.100
and then it's going to start
running your program.

00:10:07.100 --> 00:10:08.501
It's just running
top to bottom.

00:10:08.501 --> 00:10:09.968
So when you evaluate
JavaScript code,

00:10:09.968 --> 00:10:11.300
and you're trying to figure
out what's going on,

00:10:11.300 --> 00:10:13.133
remember that the line
before it may be the thing

00:10:13.133 --> 00:10:15.200
that caused the problem.

00:10:15.200 --> 00:10:18.367
And JavaScript is functional
and object-based.

00:10:18.367 --> 00:10:22.434
It's really important
to think of functions

00:10:22.434 --> 00:10:25.067
as first class in JavaScript.

00:10:25.067 --> 00:10:27.067
That means that they're
not simply a pointer out

00:10:27.067 --> 00:10:30.834
in the world that you
invoke against something.

00:10:30.834 --> 00:10:32.133
They are actual objects.

00:10:32.133 --> 00:10:33.234
I'm going to refer to them
through this talk

00:10:33.234 --> 00:10:34.701
as function objects,

00:10:34.701 --> 00:10:37.601
because function objects are
indeed objects that you can go

00:10:37.601 --> 00:10:38.834
and hang behavior off of.

00:10:38.834 --> 00:10:39.968
But you don't hang behavior
off of them

00:10:39.968 --> 00:10:42.701
by extending their public
API area.

00:10:42.701 --> 00:10:44.601
You don't say,
"I've got a function object.

00:10:44.601 --> 00:10:46.067
I'm going to add
some new property to it."

00:10:46.067 --> 00:10:49.534
Most of the time, you do that
by using functions as scopes.

00:10:49.534 --> 00:10:51.501
The only way to create
a new scope in JavaScript

00:10:51.501 --> 00:10:53.300
is to invoke a function.

00:10:53.300 --> 00:10:55.801
When you invoke a function,
it sort of creates a new scope.

00:10:55.801 --> 00:10:58.601
If statements, while statements,
for-in statements--

00:10:58.601 --> 00:10:59.834
those things
don't create scopes.

00:10:59.834 --> 00:11:03.100
Only functions do,
so we have this problem of

00:11:03.100 --> 00:11:04.234
how do we do beta hiding?

00:11:04.234 --> 00:11:05.734
Well, these scopes
are really smart,

00:11:05.734 --> 00:11:07.534
because these scopes
hold on to the variables

00:11:07.534 --> 00:11:10.501
that have been defined
above them in another scope.

00:11:10.501 --> 00:11:13.667
So what we've got here is
a function called get counter,

00:11:13.667 --> 00:11:15.534
and get counter defines
a local variable, I,

00:11:15.534 --> 00:11:18.400
and it returns
another function,

00:11:18.400 --> 00:11:22.534
and that function references
the variable I inside of it.

00:11:22.534 --> 00:11:26.734
In other languages
like C++ or Java,

00:11:26.734 --> 00:11:28.200
you really can't do
anything here,

00:11:28.200 --> 00:11:30.234
because that variable I
is going to go out of scope

00:11:30.234 --> 00:11:31.467
in the return function.

00:11:31.467 --> 00:11:32.767
We're allocating
a new function here,

00:11:32.767 --> 00:11:35.868
but that inner function is
going to hold on to I.

00:11:35.868 --> 00:11:39.133
It actually allocates private
memory to store a reference

00:11:39.133 --> 00:11:41.000
to I on the function object

00:11:41.000 --> 00:11:44.100
that's returned out of
this statement here.

00:11:44.100 --> 00:11:45.901
It, again, inverts
the relationship.

00:11:45.901 --> 00:11:48.667
It's not storage
with behavior.

00:11:48.667 --> 00:11:50.968
It's behavior
that has hidden storage.

00:11:50.968 --> 00:11:52.400
And so the way we do
private variables

00:11:52.400 --> 00:11:56.267
and the way we do
data hiding in JavaScript

00:11:56.267 --> 00:11:58.534
is to use this idea of a
closure, something that encloses

00:11:58.534 --> 00:11:59.934
its lexical scope

00:11:59.934 --> 00:12:01.601
and holds on to variables

00:12:01.601 --> 00:12:03.701
as a way
of passing behavior around.

00:12:03.701 --> 00:12:05.934
So we can call
the get counter function.

00:12:05.934 --> 00:12:07.501
It hands us back
a function object.

00:12:07.501 --> 00:12:10.100
We can call it multiple times,
and that state isn't gone.

00:12:10.100 --> 00:12:12.834
We can still see the variable I
from inside the outside one,

00:12:12.834 --> 00:12:14.367
but it isn't referenceable.

00:12:14.367 --> 00:12:17.300
We can't go and inspect some
property on that function object

00:12:17.300 --> 00:12:20.400
and find out which variables
it's holding references to.

00:12:20.400 --> 00:12:24.367
It gets GC'd just like
everything else in the language.

00:12:24.367 --> 00:12:25.734
So these are
first class functions.

00:12:25.734 --> 00:12:28.634
These are functions
that are things in the system.

00:12:28.634 --> 00:12:30.767
They're actually objects.
You can create them.

00:12:30.767 --> 00:12:33.734
You can add properties to them.
It can enclose scope.

00:12:33.734 --> 00:12:37.801
They're not simply inert
bodies of code that get run.

00:12:37.801 --> 00:12:39.801
They're participants
in the object model.

00:12:39.801 --> 00:12:42.300
They're participants
in the storage system.

00:12:42.300 --> 00:12:44.400
You can use them--I know
the fundamental concept

00:12:44.400 --> 00:12:46.334
that underpins
a lot of the patterns

00:12:46.334 --> 00:12:48.067
that we're going to see later.

00:12:48.067 --> 00:12:50.667
So these functions
work together

00:12:50.667 --> 00:12:52.934
with a lot of other
sort of functional ideas

00:12:52.934 --> 00:12:55.133
about how a program language
can be structured.

00:12:55.133 --> 00:12:57.167
In JavaScript, we have a filter,
map, reduce,

00:12:57.167 --> 00:13:00.133
and for each method
on the array prototype,

00:13:00.133 --> 00:13:02.534
which means that every array
in the system has these methods,

00:13:02.534 --> 00:13:05.234
which means that instead
of having an external iterator,

00:13:05.234 --> 00:13:06.434
you have
an internal iterator.

00:13:06.434 --> 00:13:08.400
You have something
that can call a function

00:13:08.400 --> 00:13:10.133
across some set of arguments,

00:13:10.133 --> 00:13:12.501
and so you wind up
creating a stack of stuff

00:13:12.501 --> 00:13:14.567
that you'd like to do
in terms of behavior.

00:13:14.567 --> 00:13:16.534
Instead of passing
data structures around

00:13:16.534 --> 00:13:18.734
and around and around, you pass
in arguments to functions,

00:13:18.734 --> 00:13:20.267
and that sort of
unwinds the thing

00:13:20.267 --> 00:13:21.400
that you were
trying to get done.

00:13:21.400 --> 00:13:23.501
You express
your program's intent

00:13:23.501 --> 00:13:25.601
in the form of
nested functions

00:13:25.601 --> 00:13:28.467
that are going to
unwind to some result,

00:13:28.467 --> 00:13:31.601
not linear code
that's going to be executed

00:13:31.601 --> 00:13:33.534
by passing in
the same data structures

00:13:33.534 --> 00:13:34.868
over and over
and over again.

00:13:34.868 --> 00:13:39.300
So these sorts of things
are not hard and fast rules

00:13:39.300 --> 00:13:40.434
about any programming
language.

00:13:40.434 --> 00:13:42.567
Like, you can have
an endless debate about

00:13:42.567 --> 00:13:44.634
what makes something a
functional programming language.

00:13:44.634 --> 00:13:45.767
Can it have side effects?

00:13:45.767 --> 00:13:48.567
Can it not have side effects?
You know--

00:13:48.567 --> 00:13:51.067
How completely does it
support some particular

00:13:51.067 --> 00:13:53.234
set of macro languages,
or hygienic macros,

00:13:53.234 --> 00:13:54.601
or whatever it is?

00:13:54.601 --> 00:13:57.534
Many people define functional
languages differently,

00:13:57.534 --> 00:13:59.334
but for the intents
and purposes here,

00:13:59.334 --> 00:14:00.334
we're just going to say
it has closures,

00:14:00.334 --> 00:14:01.701
first class functions,

00:14:01.701 --> 00:14:04.834
and some concept of
using those sorts of things

00:14:04.834 --> 00:14:08.300
to compose behavior
nicely together.

00:14:08.300 --> 00:14:10.501
So another important thing
to remember about JavaScript

00:14:10.501 --> 00:14:12.734
is that everything
is just an object.

00:14:12.734 --> 00:14:15.033
So there aren't a lot of
key concepts in JavaScript,

00:14:15.033 --> 00:14:18.067
and so you can think of it as
sort of a lazy language design.

00:14:18.067 --> 00:14:20.601
It doesn't really have
a lot of specialized,

00:14:20.601 --> 00:14:22.200
compartmentalized things

00:14:22.200 --> 00:14:23.200
to hold on
to different concepts

00:14:23.200 --> 00:14:24.400
that you might encounter.

00:14:24.400 --> 00:14:25.767
Instead, it just relies
on the same systems

00:14:25.767 --> 00:14:27.100
over and over again.

00:14:27.100 --> 00:14:31.234
One of those systems
is this small type system,

00:14:31.234 --> 00:14:35.000
where objects are objects,
that first object literal there.

00:14:35.000 --> 00:14:37.501
It's an instance of object.
Arrays are objects,

00:14:37.501 --> 00:14:39.834
which means that arrays are
instances of objects, too.

00:14:39.834 --> 00:14:42.167
And functions
are also objects.

00:14:42.167 --> 00:14:45.033
In this case,
I've got a paren here,

00:14:45.033 --> 00:14:47.033
which is going to create
a new expression.

00:14:47.033 --> 00:14:49.133
I've got a function,
which I define inside of here.

00:14:49.133 --> 00:14:50.734
It doesn't have a name.
It's an anonymous function.

00:14:50.734 --> 00:14:53.334
You can have anonymous
functions in JavaScript.

00:14:53.334 --> 00:14:54.968
And the result
of this expression

00:14:54.968 --> 00:14:57.000
is just going to be
that function object.

00:14:57.000 --> 00:15:01.167
And the function object also is
an instance of the object type,

00:15:01.167 --> 00:15:03.033
which means that nearly
everything in the system

00:15:03.033 --> 00:15:05.067
that you encounter
is going to be an object.

00:15:05.067 --> 00:15:06.434
This is really powerful,
because it means,

00:15:06.434 --> 00:15:07.767
as we'll see later,

00:15:07.767 --> 00:15:10.133
when we compose things,
and everything is mutable,

00:15:10.133 --> 00:15:11.467
we can start
to change the behavior

00:15:11.467 --> 00:15:13.767
of large parts of the system
all at once.

00:15:13.767 --> 00:15:16.100
And every object in the system
acts more or less like a map.

00:15:16.100 --> 00:15:18.033
There's no separate
map type in JavaScript.

00:15:18.033 --> 00:15:20.133
So if you want a map,
just take an object.

00:15:20.133 --> 00:15:22.501
This is where--
sort of where JSON comes from,

00:15:22.501 --> 00:15:24.901
this object literal syntax
that we've got here,

00:15:24.901 --> 00:15:26.100
where we're
defining an object

00:15:26.100 --> 00:15:28.234
with a single property
and a single value.

00:15:28.234 --> 00:15:30.267
It allows us to de-reference
properties the same way.

00:15:30.267 --> 00:15:32.868
So the data operator does
almost exactly the same thing

00:15:32.868 --> 00:15:34.234
as this map operator.

00:15:34.234 --> 00:15:36.200
It just finds a property
by its name

00:15:36.200 --> 00:15:37.601
and returns it out
the other side.

00:15:37.601 --> 00:15:40.400
So in JavaScript,
everything is an object.

00:15:40.400 --> 00:15:43.234
Objects operate like maps.
That's pretty cool.

00:15:43.234 --> 00:15:44.667
Arrays do exactly
the same thing.

00:15:44.667 --> 00:15:47.767
And arrays are very confusing
when you start out working

00:15:47.767 --> 00:15:48.968
in JavaScript,

00:15:48.968 --> 00:15:51.100
because you think array
is some separate thing

00:15:51.100 --> 00:15:53.667
over on the side.
Arrays are not objects.

00:15:53.667 --> 00:15:55.801
Arrays are this linear bag
of memory

00:15:55.801 --> 00:15:58.367
that you're going to access
with an integer someplace.

00:15:58.367 --> 00:16:00.667
And as a result of that,

00:16:00.667 --> 00:16:04.000
you're not going to be surprised
by some other identity.

00:16:04.000 --> 00:16:06.067
But you are, because
very often what happens is

00:16:06.067 --> 00:16:08.300
you go and extend an object.
You add a new property to it.

00:16:08.300 --> 00:16:11.200
In this case, we're going to add
this other greeting property

00:16:11.200 --> 00:16:15.300
to an object dynamically, and--
or to an array dynamically.

00:16:15.300 --> 00:16:18.367
And as a result,
when we go into a for-in loop,

00:16:18.367 --> 00:16:22.434
this is now an innumerable
property on this array.

00:16:22.434 --> 00:16:24.767
We might get surprised, because
we see these other things

00:16:24.767 --> 00:16:27.300
showing up in our object.

00:16:27.300 --> 00:16:29.100
Well, that's weird.

00:16:29.100 --> 00:16:32.067
I mean, we iterated
over the public properties.

00:16:32.067 --> 00:16:34.734
Isn't 0 just
an integer index thing?

00:16:34.734 --> 00:16:36.334
It's not a public
property, right?

00:16:36.334 --> 00:16:38.434
Well, remember that
everything in JavaScript

00:16:38.434 --> 00:16:40.667
just sort of falls back
on these core concepts.

00:16:40.667 --> 00:16:44.901
And if you think about
the array integer indexing

00:16:44.901 --> 00:16:47.834
working exactly the same way
that property indexing does,

00:16:47.834 --> 00:16:48.968
it all makes sense.

00:16:48.968 --> 00:16:50.300
Yeah,
in the implementation,

00:16:50.300 --> 00:16:52.033
there might be some special
machinery to make arrays

00:16:52.033 --> 00:16:53.634
efficient
or to pack them tightly,

00:16:53.634 --> 00:16:55.968
so that you don't wind up
slowing things down

00:16:55.968 --> 00:16:57.300
unnecessarily.

00:16:57.300 --> 00:16:58.901
But in the language semantics,

00:16:58.901 --> 00:17:00.067
what happens here
when I say,

00:17:00.067 --> 00:17:02.801
"Please give me item 0
out of this list,"

00:17:02.801 --> 00:17:05.000
is that it turns
that 0 into a string,

00:17:05.000 --> 00:17:06.801
and then does a map lookup.

00:17:06.801 --> 00:17:07.968
That's all it does.

00:17:07.968 --> 00:17:09.300
So the only magical thing
about arrays

00:17:09.300 --> 00:17:11.400
versus any other kind of object
in the system

00:17:11.400 --> 00:17:13.033
is that,
when I push onto an array

00:17:13.033 --> 00:17:15.467
or I set the length property,

00:17:15.467 --> 00:17:17.868
it actually affects
which properties are visible.

00:17:17.868 --> 00:17:19.567
The length property is
the only thing in an array

00:17:19.567 --> 00:17:21.067
that's actually magic.

00:17:21.067 --> 00:17:23.267
It has a little bit of syntax
for defining arrays naturally;

00:17:23.267 --> 00:17:25.534
but other than that,
arrays are just objects.

00:17:25.534 --> 00:17:28.067
Things get turned into strings
and then de-referenced that way.

00:17:28.067 --> 00:17:29.534
The spec is pretty clear
about this.

00:17:29.534 --> 00:17:33.167
So JavaScript doesn't have
that many core concepts.

00:17:33.167 --> 00:17:34.801
And if you understand them,
you can understand

00:17:34.801 --> 00:17:36.300
what's going on
in your system.

00:17:36.300 --> 00:17:38.934
So we've got mutable objects.
We've got closures,

00:17:38.934 --> 00:17:40.501
which are behavior
that carries data

00:17:40.501 --> 00:17:42.767
and not data
that carries behavior.

00:17:42.767 --> 00:17:44.701
We've got mutable objects,

00:17:44.701 --> 00:17:46.467
and we've got everything
being an object

00:17:46.467 --> 00:17:49.300
and everything being an object
also being a map.

00:17:49.300 --> 00:17:51.300
Okay, that's not a lot
of concepts, so far,

00:17:51.300 --> 00:17:52.834
for a programming language.

00:17:52.834 --> 00:17:56.267
And we can use these to build
some really powerful stuff.

00:17:56.267 --> 00:17:57.467
So I mentioned mutability,

00:17:57.467 --> 00:17:59.167
and I said
everything is mutable.

00:17:59.167 --> 00:18:01.801
Just a really quick example,
we can add new properties

00:18:01.801 --> 00:18:03.200
at runtime to every object.

00:18:03.200 --> 00:18:06.534
Remember how I said that
JavaScript runs top to bottom?

00:18:06.534 --> 00:18:08.100
When you're reading
a program like this,

00:18:08.100 --> 00:18:10.634
it's not like my object type
somehow was extended

00:18:10.634 --> 00:18:12.367
and, therefore, every object
of this type is going to have

00:18:12.367 --> 00:18:13.734
one of these properties.

00:18:13.734 --> 00:18:17.901
I'm just adding a new property
to the object directly.

00:18:17.901 --> 00:18:21.667
So in this case,
object.item is being replaced,

00:18:21.667 --> 00:18:24.767
and object.item2
is simply being added.

00:18:24.767 --> 00:18:26.434
These are exactly
the same operations,

00:18:26.434 --> 00:18:28.367
as far as JavaScript
is concerned.

00:18:28.367 --> 00:18:30.534
The dot operator
just finds you the object

00:18:30.534 --> 00:18:32.601
and then assigns to it.
That's all it's doing.

00:18:32.601 --> 00:18:34.501
Every object in the system
is extensible.

00:18:34.501 --> 00:18:36.567
Most of them are mutable.

00:18:36.567 --> 00:18:40.467
Most of the values are mutable,
and we run top to bottom.

00:18:40.467 --> 00:18:43.100
So that means
that when I come down here,

00:18:43.100 --> 00:18:44.901
and I delete a property
off of the object,

00:18:44.901 --> 00:18:46.400
the very next line
isn't going to see it.

00:18:46.400 --> 00:18:48.334
But if I had said
console.log(obj.item)

00:18:48.334 --> 00:18:50.534
one line above,
it would see it there.

00:18:50.534 --> 00:18:51.934
This is not
a compile time thing.

00:18:51.934 --> 00:18:55.100
It's just doing what you said,
line after line,

00:18:55.100 --> 00:18:57.601
statement after statement,
expression after expression.

00:18:57.601 --> 00:18:59.067
It seems really simple.

00:18:59.067 --> 00:19:01.400
It seems pretty obvious, but
very few programming languages

00:19:01.400 --> 00:19:03.300
that you might be using
in a compiled environment

00:19:03.300 --> 00:19:05.267
work this way.

00:19:05.267 --> 00:19:07.367
So I mentioned that closures
are the other side of classes,

00:19:07.367 --> 00:19:08.834
whereas classes
are sort of a nice way

00:19:08.834 --> 00:19:10.400
of saying,
"Here's a structure of data.

00:19:10.400 --> 00:19:12.133
"I'm going to associate
some properties with them,

00:19:12.133 --> 00:19:15.634
and maybe they'll have
some type behavior as well."

00:19:15.634 --> 00:19:18.200
In this case,
we're going to create something

00:19:18.200 --> 00:19:19.834
that we would call a class
in JavaScript.

00:19:19.834 --> 00:19:21.133
We know it's a class,

00:19:21.133 --> 00:19:23.167
because it's got
an uppercase B for the name.

00:19:23.167 --> 00:19:24.601
This is not a language
enforced semantic.

00:19:24.601 --> 00:19:28.634
JavaScript doesn't necessarily
have classes today.

00:19:28.634 --> 00:19:30.534
This is just a convention.
And as we'll see, conventions

00:19:30.534 --> 00:19:34.067
figure large in day-to-day
JavaScript programming.

00:19:34.067 --> 00:19:35.934
So remember
every object is mutable.

00:19:35.934 --> 00:19:38.667
So we're going to create
down here,

00:19:38.667 --> 00:19:42.801
we're going to create a new
instance of our behavior class.

00:19:42.801 --> 00:19:46.534
We're going to extend
the local object, this dot,

00:19:46.534 --> 00:19:48.534
with the variable that
was passed in the configuration,

00:19:48.534 --> 00:19:50.467
and then we're going to
extend the object again

00:19:50.467 --> 00:19:52.000
with a function called do it.

00:19:52.000 --> 00:19:53.334
In this case,

00:19:53.334 --> 00:19:56.734
when I call the do it method
of my behavior instance,

00:19:56.734 --> 00:19:57.834
it's then going to
run through,

00:19:57.834 --> 00:19:59.601
and it's going to say
this.config

00:19:59.601 --> 00:20:01.767
and go grab some flag
off the configuration.

00:20:01.767 --> 00:20:05.234
Okay, so we stored some property
and some behavior on the object.

00:20:05.234 --> 00:20:06.801
This looks a lot like
what you might expect out

00:20:06.801 --> 00:20:08.200
of another
object-oriented language.

00:20:08.200 --> 00:20:10.367
The declaration syntax
is a little bit funky,

00:20:10.367 --> 00:20:11.801
but you sort of
understand it, right?

00:20:11.801 --> 00:20:14.033
I've added a method.
I've added some data.

00:20:14.033 --> 00:20:16.100
The data operates on
the local objects method.

00:20:16.100 --> 00:20:18.300
Sweet--
or other way around.

00:20:18.300 --> 00:20:20.934
Strike that, reverse it.

00:20:20.934 --> 00:20:23.234
New behavior, passing a flag,
then I call it false.

00:20:23.234 --> 00:20:24.634
I get a behavior object,

00:20:24.634 --> 00:20:27.934
and now I can call a method
that uses that behavior, right?

00:20:27.934 --> 00:20:32.467
So it's going to look
at the local object, this,

00:20:32.467 --> 00:20:35.167
for the configuration,
and it may change its behavior

00:20:35.167 --> 00:20:38.534
based on that configuration by
passing some other value to it.

00:20:38.534 --> 00:20:41.133
Make sense?
Cool? All right.

00:20:41.133 --> 00:20:44.067
So this is maybe a little bit
more idiomatic for JavaScript.

00:20:44.067 --> 00:20:46.133
It's the flip side of that.

00:20:46.133 --> 00:20:49.033
Instead of creating a class
that I created an instance of,

00:20:49.033 --> 00:20:51.834
I'm going to
create a generator

00:20:51.834 --> 00:20:54.067
that's going to pass me
back a function object,

00:20:54.067 --> 00:20:55.667
which is going to hold
on to the state.

00:20:55.667 --> 00:20:57.100
I'm not going to go
create a class for it.

00:20:57.100 --> 00:20:59.400
I'm going to create
a behavior generator.

00:20:59.400 --> 00:21:01.200
You can think of them
doing the same thing,

00:21:01.200 --> 00:21:02.334
just the flip side of it.

00:21:02.334 --> 00:21:04.634
So instead of saying
new behavior,

00:21:04.634 --> 00:21:07.000
I'm going to say
bind me a behavior,

00:21:07.000 --> 00:21:09.100
which when I call this,

00:21:09.100 --> 00:21:11.400
note the lack of
the new keyword here,

00:21:11.400 --> 00:21:13.634
I'm going to pass
into configuration.

00:21:13.634 --> 00:21:14.901
Like we saw earlier,

00:21:14.901 --> 00:21:16.434
I'm going to pass back out
a function object.

00:21:16.434 --> 00:21:17.667
This is a new
function object.

00:21:17.667 --> 00:21:19.734
Every time I call this method,
bind behavior,

00:21:19.734 --> 00:21:22.167
it's going to pass me back out
a new function object.

00:21:22.167 --> 00:21:26.400
So I'm actually having a new
function object allocated here,

00:21:26.400 --> 00:21:28.567
and that function object
is going to have, again,

00:21:28.567 --> 00:21:30.701
some private storage,
and that private storage is

00:21:30.701 --> 00:21:32.834
going to hold on to
the config variable

00:21:32.834 --> 00:21:34.901
that was passed into
the outer function, right?

00:21:34.901 --> 00:21:36.501
Because each one of these
is a new scope,

00:21:36.501 --> 00:21:38.734
and because scopes
can hold on to the variables

00:21:38.734 --> 00:21:41.634
that they were able to see
when they were defined,

00:21:41.634 --> 00:21:43.701
the function object
that gets passed out of here now

00:21:43.701 --> 00:21:44.868
has a reference.

00:21:44.868 --> 00:21:47.467
It's holding on to
that local state.

00:21:47.467 --> 00:21:50.033
In this case, it's going to be
the object that was passed in.

00:21:50.033 --> 00:21:52.534
This might go out of scope here
in every other place

00:21:52.534 --> 00:21:53.834
in my program.

00:21:53.834 --> 00:21:55.434
I may not be able to get
a reference back to this object,

00:21:55.434 --> 00:22:00.267
but my behavior, the B variable
that was passed back out,

00:22:00.267 --> 00:22:02.033
will have access to that data

00:22:02.033 --> 00:22:03.734
because it's being held on to
internally.

00:22:03.734 --> 00:22:04.901
It's not going to be
garbage collected out

00:22:04.901 --> 00:22:06.200
from underneath me.

00:22:06.200 --> 00:22:08.133
Closures are the way to invert
the way you think

00:22:08.133 --> 00:22:09.434
about your programs.

00:22:09.434 --> 00:22:12.868
You don't create classes
that are state with data,

00:22:12.868 --> 00:22:14.367
state with behavior attached.

00:22:14.367 --> 00:22:17.267
You create behavior that holds
on to the state that it needs,

00:22:17.267 --> 00:22:18.601
and you can pass
that behavior around,

00:22:18.601 --> 00:22:22.234
because functions
are first class.

00:22:22.234 --> 00:22:25.767
So I mentioned earlier that
the last sort of big conceit

00:22:25.767 --> 00:22:28.434
in the language is that we
don't have a way of saying,

00:22:28.434 --> 00:22:30.868
hey, here's a class of stuff.

00:22:30.868 --> 00:22:33.601
Instead we say,
if you don't find it here,

00:22:33.601 --> 00:22:40.067
don't look at my like
chain of class inheritance.

00:22:40.067 --> 00:22:42.467
Instead, just go look
at that other object.

00:22:42.467 --> 00:22:44.367
Remember how I said
over and over again

00:22:44.367 --> 00:22:47.133
that JavaScript
just reads top to bottom?

00:22:47.133 --> 00:22:48.434
I get some code.

00:22:48.434 --> 00:22:52.334
The thing executes
front to back, top to bottom.

00:22:52.334 --> 00:22:54.033
We're going to see
the exact same thing here,

00:22:54.033 --> 00:22:56.767
because what happens every time
you call the .operator

00:22:56.767 --> 00:22:57.901
is exactly the same thing.

00:22:57.901 --> 00:22:59.834
I'm going to create
some variable

00:22:59.834 --> 00:23:01.133
that I'm going
to call my delegate.

00:23:01.133 --> 00:23:03.267
It's an object.
It's got a single property.

00:23:03.267 --> 00:23:04.767
Okay, cool.

00:23:04.767 --> 00:23:08.100
There's a new ECMAScript 5
method called object.create.

00:23:08.100 --> 00:23:09.534
There's other ways to do this
in older versions,

00:23:09.534 --> 00:23:10.534
but they're a little bit
mind bending,

00:23:10.534 --> 00:23:11.834
and we won't go over them.

00:23:11.834 --> 00:23:13.267
But object.create--
the easiest way to think of it

00:23:13.267 --> 00:23:17.033
is that it creates a new object
which will look at the object

00:23:17.033 --> 00:23:19.701
that you pass
as its first property

00:23:19.701 --> 00:23:23.067
if you don't find a value
with this same property name

00:23:23.067 --> 00:23:24.601
on that object.

00:23:24.601 --> 00:23:29.534
So let's say--and in this case,
I'm going to create object 2

00:23:29.534 --> 00:23:31.667
and have my delegate
be the delegate.

00:23:31.667 --> 00:23:34.934
And so when I reference
a property out of object 2,

00:23:34.934 --> 00:23:36.734
it's going to go look it
up dynamically,

00:23:36.734 --> 00:23:39.200
and if it doesn't find it
on object 2 directly,

00:23:39.200 --> 00:23:41.901
it's going to go look it up
off of the delegated 2 object.

00:23:41.901 --> 00:23:43.367
It's going to go,
dynamically go

00:23:43.367 --> 00:23:45.234
and try and find it
over there.

00:23:45.234 --> 00:23:47.868
Well, we created
another object.

00:23:47.868 --> 00:23:52.033
In this case, we're setting
a local property on that object,

00:23:52.033 --> 00:23:54.934
whose name is item,
whose value is value.

00:23:54.934 --> 00:23:56.701
And that means that
when I look it up at runtime

00:23:56.701 --> 00:23:58.834
directly top to bottom,
left to right,

00:23:58.834 --> 00:24:01.000
what I see is that
I don't get the value

00:24:01.000 --> 00:24:02.133
that was set on my delegate.

00:24:02.133 --> 00:24:03.834
I get the value that was
on the local object.

00:24:03.834 --> 00:24:06.367
The .operator doesn't fail
on the local lookup.

00:24:06.367 --> 00:24:07.901
It finds it on
the local object.

00:24:07.901 --> 00:24:09.434
And instead of looking up
the chain, it says,

00:24:09.434 --> 00:24:12.667
ah, I'll just give you this
object's value right back.

00:24:12.667 --> 00:24:14.634
So JavaScript is
incredibly dynamic

00:24:14.634 --> 00:24:17.133
when it comes even to looking up
properties on objects.

00:24:17.133 --> 00:24:19.501
There's not some fixed list
of stuff that you can do.

00:24:19.501 --> 00:24:20.734
You can change
the delegation,

00:24:20.734 --> 00:24:22.000
and you can change
the properties

00:24:22.000 --> 00:24:23.667
that are available
on every object

00:24:23.667 --> 00:24:26.200
that you're delegating to,
or your local object,

00:24:26.200 --> 00:24:27.634
and that changes what happens
when you go

00:24:27.634 --> 00:24:30.100
and look stuff up
at the very next line.

00:24:30.100 --> 00:24:31.300
So in this case,

00:24:31.300 --> 00:24:34.334
if I go and I change the value
on the delegate,

00:24:34.334 --> 00:24:35.834
I change the item value
on the delegate,

00:24:35.834 --> 00:24:38.033
remember that object 2
doesn't have a local property

00:24:38.033 --> 00:24:39.100
called item.

00:24:39.100 --> 00:24:41.367
If I fail on that lookup
on object 2,

00:24:41.367 --> 00:24:44.200
it just goes and says, ah, okay,
let's go consult my delegate,

00:24:44.200 --> 00:24:46.267
and that delegate is now
going to have the new value.

00:24:46.267 --> 00:24:48.234
So the new value has
been shadowed all the way

00:24:48.234 --> 00:24:49.634
through to everything else
in the system

00:24:49.634 --> 00:24:51.601
that is delegating
to that object.

00:24:51.601 --> 00:24:53.033
This is incredibly
powerful.

00:24:53.033 --> 00:24:55.334
The dynamic nature of
JavaScript means that

00:24:55.334 --> 00:24:56.634
because it reads
top to bottom,

00:24:56.634 --> 00:24:58.133
because almost everything
is mutable,

00:24:58.133 --> 00:25:00.367
and because I can delegate
to most other objects

00:25:00.367 --> 00:25:01.801
when I create something,

00:25:01.801 --> 00:25:05.200
I wind up in a place where
I can create brand-new behavior

00:25:05.200 --> 00:25:06.767
at runtime.

00:25:06.767 --> 00:25:09.100
I can compose things on the next
line that didn't exist before,

00:25:09.100 --> 00:25:10.501
or I can change
the behavior of other objects

00:25:10.501 --> 00:25:11.701
in the system,

00:25:11.701 --> 00:25:13.100
based on what
they're delegating to.

00:25:13.100 --> 00:25:15.167
This turns out to be
a great way

00:25:15.167 --> 00:25:17.000
to go build up
a lot of the constructs

00:25:17.000 --> 00:25:18.701
that we get in other languages
for ourselves,

00:25:18.701 --> 00:25:21.701
because JavaScript may not
give them to us naturally.

00:25:21.701 --> 00:25:24.434
This power is the sort of thing
that really drew me

00:25:24.434 --> 00:25:26.968
to JavaScript
as a young programmer.

00:25:26.968 --> 00:25:28.834
I didn't really understand
what I was dealing with.

00:25:28.834 --> 00:25:31.033
I remember I had a friend
who told me,

00:25:31.033 --> 00:25:34.234
after I'd written some article
about how to do

00:25:34.234 --> 00:25:36.367
signals and slots,
some sort of aspect-oriented

00:25:36.367 --> 00:25:38.834
event style thing,
he's like,

00:25:38.834 --> 00:25:40.300
"Well, why didn't you just use
a closure for that?"

00:25:40.300 --> 00:25:41.801
And it took me a long time,

00:25:41.801 --> 00:25:43.200
probably six months
or more after that,

00:25:43.200 --> 00:25:45.133
to sort of really understand
what it was

00:25:45.133 --> 00:25:47.200
that he meant when he said,
"Just use a closure for that."

00:25:47.200 --> 00:25:48.634
I didn't understand
that you could hide data

00:25:48.634 --> 00:25:49.834
inside of functions.

00:25:49.834 --> 00:25:51.033
I didn't understand
that JavaScript sort of

00:25:51.033 --> 00:25:53.234
ran top to bottom.

00:25:53.234 --> 00:25:55.434
But these core concepts
allow you to create

00:25:55.434 --> 00:25:59.367
all sorts of
really powerful stuff,

00:25:59.367 --> 00:26:02.501
assuming we understand what
happens with the word "this."

00:26:02.501 --> 00:26:04.300
So the word this
is really special.

00:26:04.300 --> 00:26:06.300
In order--Because we don't have
classes that wire up

00:26:06.300 --> 00:26:07.734
this inheritance hierarchy,

00:26:07.734 --> 00:26:09.734
and because we're always
delegating at runtime, right,

00:26:09.734 --> 00:26:13.234
every .operator sort of
does the dynamic lookup

00:26:13.234 --> 00:26:14.434
on the local object--

00:26:14.434 --> 00:26:16.267
looks at its delegate,
looks at its delegates.

00:26:16.267 --> 00:26:18.667
The this object
is a way of saying,

00:26:18.667 --> 00:26:21.501
okay, whatever scope I'm in,

00:26:21.501 --> 00:26:26.334
execute the next lookup
against the local object,

00:26:26.334 --> 00:26:29.701
which means that the this
keyword in any function

00:26:29.701 --> 00:26:31.834
isn't pointing
at some fixed object.

00:26:31.834 --> 00:26:34.667
It's not fixed
when I necessarily say,

00:26:34.667 --> 00:26:36.901
you know, create me an object.
It's promiscuous.

00:26:36.901 --> 00:26:39.067
The this keyword points
at whatever object my function

00:26:39.067 --> 00:26:40.901
is being called through.

00:26:40.901 --> 00:26:42.667
Right, remember function
objects are first class?

00:26:42.667 --> 00:26:46.434
They don't actually sort of
carry around relationships

00:26:46.434 --> 00:26:48.767
to their class or the thing
that they were defined in.

00:26:48.767 --> 00:26:50.100
They hold their own data.

00:26:50.100 --> 00:26:52.634
So the this keyword is
a nice little syntactic out

00:26:52.634 --> 00:26:58.434
which lets you say, okay,
whenever I look up a property,

00:26:58.434 --> 00:26:59.901
which happens to be
a function,

00:26:59.901 --> 00:27:04.934
and I call it, the .operator
for method calls says

00:27:04.934 --> 00:27:06.300
don't just return it.

00:27:06.300 --> 00:27:10.501
But if I evaluate it directly,
use the .call property

00:27:10.501 --> 00:27:11.934
of the function object

00:27:11.934 --> 00:27:14.767
that's returned and call it
in the scope of the object

00:27:14.767 --> 00:27:17.067
on the left hand side
of the .operator.

00:27:17.067 --> 00:27:18.634
I know this is a little bit
maybe tricky,

00:27:18.634 --> 00:27:21.634
but the easiest way to think
about this is that in order to

00:27:21.634 --> 00:27:23.100
wire up this behavior
correctly,

00:27:23.100 --> 00:27:26.434
so that it sort of does what you
expect out of other languages,

00:27:26.434 --> 00:27:28.434
we rely on the function
being first class,

00:27:28.434 --> 00:27:31.067
meaning it has its own call
and apply methods.

00:27:31.067 --> 00:27:33.934
You don't say necessarily,
hey, function,

00:27:33.934 --> 00:27:35.167
you're not going to work
if you're not called inside

00:27:35.167 --> 00:27:36.601
of some other object.

00:27:36.601 --> 00:27:40.000
I can call any function in
the scope of any other object.

00:27:40.000 --> 00:27:42.868
I can assign a function to any
other object and then call it

00:27:42.868 --> 00:27:45.734
through that object
dynamically, right?

00:27:45.734 --> 00:27:47.334
Everything is mutable.

00:27:47.334 --> 00:27:48.834
Functions are first class.
Why not?

00:27:48.834 --> 00:27:50.200
So in order to get
that to execute

00:27:50.200 --> 00:27:51.400
against the right object,

00:27:51.400 --> 00:27:52.968
you use the this keyword
to go grab

00:27:52.968 --> 00:27:54.567
the value out of the thing

00:27:54.567 --> 00:27:56.367
that was on
the left hand side of dot,

00:27:56.367 --> 00:27:58.234
which is exactly
the same thing as saying

00:27:58.234 --> 00:27:59.367
please call my function,

00:27:59.367 --> 00:28:00.767
which I pulled
out of that object,

00:28:00.767 --> 00:28:03.534
in the scope of the object
on the left hand side.

00:28:03.534 --> 00:28:05.200
Cool?

00:28:05.200 --> 00:28:06.701
All right.

00:28:06.701 --> 00:28:08.567
Okay.

00:28:08.567 --> 00:28:10.801
So all this fits together
in ways that allow us

00:28:10.801 --> 00:28:12.667
to recreate a lot of this stuff
that we expected

00:28:12.667 --> 00:28:13.667
in other languages.

00:28:13.667 --> 00:28:15.033
A lot of this
is convention.

00:28:15.033 --> 00:28:16.601
A lot of this isn't necessarily
the sort of thing

00:28:16.601 --> 00:28:18.234
that you're going
to have language level

00:28:18.234 --> 00:28:19.601
or syntactic support for,

00:28:19.601 --> 00:28:21.467
but if you understand
what's going on there,

00:28:21.467 --> 00:28:26.133
those sort of core little ideas
about mutability,

00:28:26.133 --> 00:28:32.067
scope, functions as first class
citizens, and dynamic behavior,

00:28:32.067 --> 00:28:34.834
we can start to recreate
things like classes.

00:28:34.834 --> 00:28:36.868
So here we've got an item type,

00:28:36.868 --> 00:28:39.701
which is we're going to
think of as a class.

00:28:39.701 --> 00:28:41.501
It's not really
called a class.

00:28:41.501 --> 00:28:43.200
It's just a function.
It's got the word function.

00:28:43.200 --> 00:28:44.567
As you saw earlier,

00:28:44.567 --> 00:28:46.634
when you use the word new
in front of any function,

00:28:46.634 --> 00:28:48.167
it sort of creates an object,

00:28:48.167 --> 00:28:50.400
calls that function inside
the context of that object,

00:28:50.400 --> 00:28:52.300
and then returns
that object back to you.

00:28:52.300 --> 00:28:54.267
That's the way to think
about the new keyword.

00:28:54.267 --> 00:28:56.100
So we're just going to
create a function,

00:28:56.100 --> 00:28:58.934
which we're going to call
with new sometime later,

00:28:58.934 --> 00:29:00.534
and inside of it
we're going to execute

00:29:00.534 --> 00:29:02.033
a couple of other functions.

00:29:02.033 --> 00:29:04.801
Now, we just saw .call,
and .call calls

00:29:04.801 --> 00:29:07.133
those other functions
in the scope of the object

00:29:07.133 --> 00:29:10.200
that we're being executed in
or that we want to pass in.

00:29:10.200 --> 00:29:12.868
In this case, we're going to
pass in the local object,

00:29:12.868 --> 00:29:14.067
and we're going
to do it twice,

00:29:14.067 --> 00:29:16.400
which means that
inside of tract,

00:29:16.400 --> 00:29:20.000
we're going to assign
a new property to this--

00:29:20.000 --> 00:29:22.434
which is to say the object
that was passed in--

00:29:22.434 --> 00:29:25.868
and inside of logged, we're
going to assign a new method

00:29:25.868 --> 00:29:29.133
where that method is going to go
dynamically look up the ID

00:29:29.133 --> 00:29:31.167
and log it out.

00:29:31.167 --> 00:29:32.467
So we call these mix-ins.

00:29:32.467 --> 00:29:34.367
These two methods up here
were written in a way

00:29:34.367 --> 00:29:35.968
that they don't delegate
to anything else.

00:29:35.968 --> 00:29:40.968
They don't assume anything about
the behavior of their methods

00:29:40.968 --> 00:29:43.033
or the properties
that they define.

00:29:43.033 --> 00:29:44.701
And instead,
they just add stuff.

00:29:44.701 --> 00:29:46.067
They just add stuff
dynamically

00:29:46.067 --> 00:29:50.334
when they're invoked against
some other object.

00:29:50.334 --> 00:29:52.200
So I could call them
in any other context,

00:29:52.200 --> 00:29:55.934
but in this case, I can use them
in the item type constructor

00:29:55.934 --> 00:29:59.067
to extend the item type
with some new stuff.

00:29:59.067 --> 00:30:01.968
We saw earlier how
delegation allows you to

00:30:01.968 --> 00:30:06.033
create new delegate
relationships between things,

00:30:06.033 --> 00:30:08.267
and functions also have
this idea of a prototype.

00:30:08.267 --> 00:30:09.934
This is the exposed version
of the thing we saw

00:30:09.934 --> 00:30:11.300
before with object.create,

00:30:11.300 --> 00:30:13.033
where I can say,
please wire up this relationship

00:30:13.033 --> 00:30:15.801
so that this object,
when you don't find it here,

00:30:15.801 --> 00:30:18.100
looks at that thing over there.

00:30:18.100 --> 00:30:21.434
So if we create
a new item type,

00:30:21.434 --> 00:30:23.667
what we'll see is
that it has an ID,

00:30:23.667 --> 00:30:27.434
and it has a type associated
with property added to them,

00:30:27.434 --> 00:30:30.200
which is pretty good.
And if we create another one,

00:30:30.200 --> 00:30:31.634
the counter is incremented,

00:30:31.634 --> 00:30:35.133
and the type is still
assigned to the same value.

00:30:35.133 --> 00:30:37.000
But if we create
a new sub item type,

00:30:37.000 --> 00:30:41.701
what we see is that,
because the prototype created

00:30:41.701 --> 00:30:46.400
a new property called type
with a new value,

00:30:46.400 --> 00:30:50.300
again, the delegate system
faults on the local object,

00:30:50.300 --> 00:30:53.167
looks at the object's
prototype--in this case,

00:30:53.167 --> 00:30:56.300
SubItemType.prototype--
pulls it out of there

00:30:56.300 --> 00:30:59.734
and doesn't fault all the way
through to ItemType.prototype.

00:30:59.734 --> 00:31:01.501
So we can compose
these things together in a way

00:31:01.501 --> 00:31:04.267
that gives us something like
classical inheritance.

00:31:04.267 --> 00:31:05.501
It's not exactly
the same thing.

00:31:05.501 --> 00:31:06.634
All this is dynamic.

00:31:06.634 --> 00:31:07.901
I can go and change
these prototypes.

00:31:07.901 --> 00:31:10.200
I can change
these objects later.

00:31:10.200 --> 00:31:12.667
But I've got the ability
to factor out code

00:31:12.667 --> 00:31:16.267
into something like a macro
or a trait, using mix-ins,

00:31:16.267 --> 00:31:18.267
and I've got the ability
to create

00:31:18.267 --> 00:31:20.868
an entire subclass
relationship,

00:31:20.868 --> 00:31:22.601
where I define
new function types

00:31:22.601 --> 00:31:25.133
which defer
to their super classes

00:31:25.133 --> 00:31:26.834
for a lot of their behavior.

00:31:26.834 --> 00:31:28.534
All right, we're starting
to get someplace.

00:31:28.534 --> 00:31:30.367
These core concepts have
given us the ability to

00:31:30.367 --> 00:31:33.767
define things that the language
didn't give us naturally,

00:31:33.767 --> 00:31:36.400
but we can go get
for ourselves.

00:31:36.400 --> 00:31:38.434
You know how I said
that everything is mutable,

00:31:38.434 --> 00:31:40.534
more or less?

00:31:40.534 --> 00:31:42.767
That means that we can
go and extend the stuff

00:31:42.767 --> 00:31:45.100
that is deferred to
by almost every object

00:31:45.100 --> 00:31:46.100
in the system, right?

00:31:46.100 --> 00:31:48.100
Remember, arrays
are objects.

00:31:48.100 --> 00:31:50.801
Objects are objects.
Functions are objects.

00:31:50.801 --> 00:31:52.467
Well, those things
have prototypes, too.

00:31:52.467 --> 00:31:53.901
They have exposed objects,

00:31:53.901 --> 00:31:56.434
which are--they defer to
when you don't find a property

00:31:56.434 --> 00:31:57.901
in the local object.

00:31:57.901 --> 00:32:01.367
So a radar prototype is, again,
an object which is mutable,

00:32:01.367 --> 00:32:04.467
and every instance of array,
every array in the system

00:32:04.467 --> 00:32:07.634
that faults on some property
is going to go look it up off

00:32:07.634 --> 00:32:10.300
of this object instead.
So I can extend it.

00:32:10.300 --> 00:32:12.801
I can say array.prototype.clear
is a new function.

00:32:12.801 --> 00:32:16.567
I can extend every single
array in the system at runtime,

00:32:16.567 --> 00:32:18.667
because the next line
is going to look it up

00:32:18.667 --> 00:32:21.767
through exactly
the same mechanism

00:32:21.767 --> 00:32:23.100
as everything else, right?

00:32:23.100 --> 00:32:25.734
This is not me
changing the type of array.

00:32:25.734 --> 00:32:27.467
I'm just extending
it dynamically.

00:32:27.467 --> 00:32:30.100
I'm creating a new thing
for you to hit,

00:32:30.100 --> 00:32:33.200
when you don't find the property
in the local array object.

00:32:33.200 --> 00:32:34.567
And I'm going to add to.

00:32:34.567 --> 00:32:36.334
In this case, they're
going to return new arrays

00:32:36.334 --> 00:32:38.968
when they're done, and so
I can chain them together.

00:32:38.968 --> 00:32:40.334
And so this is how
you can sort of create

00:32:40.334 --> 00:32:42.801
little dynamic languages
in JavaScript.

00:32:42.801 --> 00:32:44.133
You can create DSLs
in JavaScript

00:32:44.133 --> 00:32:46.567
by changing the things
that you delegate to.

00:32:46.567 --> 00:32:48.133
If you create new objects,

00:32:48.133 --> 00:32:49.667
and they delegate
to some prototype,

00:32:49.667 --> 00:32:51.234
and you can mutate
that prototype,

00:32:51.234 --> 00:32:55.334
well, then you can change almost
everything about the system.

00:32:55.334 --> 00:32:58.501
Yes, you can change almost
everything about the system.

00:32:58.501 --> 00:33:00.834
And, yes, it is a huge
maintainability nightmare.

00:33:00.834 --> 00:33:03.267
This is really good
when your code can do it.

00:33:03.267 --> 00:33:06.267
This can be a huge problem
when everybody's code can do it,

00:33:06.267 --> 00:33:08.467
especially as you get
into larger code bases.

00:33:08.467 --> 00:33:11.100
So collectively,
as a community,

00:33:11.100 --> 00:33:13.801
the JavaScript world has started
to learn these patterns

00:33:13.801 --> 00:33:17.234
of practice, which they say,
please don't ever go

00:33:17.234 --> 00:33:19.367
and mutate array.prototype.

00:33:19.367 --> 00:33:21.501
Please don't change
object.prototype,

00:33:21.501 --> 00:33:23.467
so that you don't wind up

00:33:23.467 --> 00:33:24.834
stepping on somebody
else's toes,

00:33:24.834 --> 00:33:26.567
stepping on somebody
else's extensions.

00:33:26.567 --> 00:33:28.367
But this is power
that we'd really like to have.

00:33:28.367 --> 00:33:29.801
This is power that
we'd really like to be able

00:33:29.801 --> 00:33:31.000
to take advantage of.

00:33:31.000 --> 00:33:32.601
Being able to extend
methods in the system

00:33:32.601 --> 00:33:34.000
is the sort of thing

00:33:34.000 --> 00:33:35.934
that we've seen work pretty well
in languages like C#,

00:33:35.934 --> 00:33:38.467
where they have extension
methods to interfaces.

00:33:38.467 --> 00:33:39.501
We really want to be able
to use this,

00:33:39.501 --> 00:33:40.734
because it shortens up our code.

00:33:40.734 --> 00:33:42.467
It makes it dynamic.
It makes it easy to read,

00:33:42.467 --> 00:33:44.868
and it makes it possible
to build up the language

00:33:44.868 --> 00:33:46.834
to meet us halfway,

00:33:46.834 --> 00:33:49.567
which is a great feature
of many dynamic languages.

00:33:49.567 --> 00:33:54.167
So JavaScript has this
incredible dynamic behavior,

00:33:54.167 --> 00:33:55.501
which gives us
a lot of power,

00:33:55.501 --> 00:33:58.400
and so we wind up using it
to do all sorts of things

00:33:58.400 --> 00:34:00.400
that the language
doesn't necessarily,

00:34:00.400 --> 00:34:03.067
because it's a little language,
have built-in support for.

00:34:03.067 --> 00:34:05.801
So in this case,
I'm going to, again,

00:34:05.801 --> 00:34:08.100
create an expression
that has an anonymous function

00:34:08.100 --> 00:34:09.367
defined inside of it.

00:34:09.367 --> 00:34:10.767
But, instead,
I'm going to do some stuff here

00:34:10.767 --> 00:34:13.567
where I'm going to define
a local object, right?

00:34:13.567 --> 00:34:14.868
We've seen this before,

00:34:14.868 --> 00:34:16.133
that might get captured
in an enclosure;

00:34:16.133 --> 00:34:18.434
and, in fact,
it's going to here.

00:34:18.434 --> 00:34:21.968
But the little piece
of sophistry

00:34:21.968 --> 00:34:23.234
at the bottom there,

00:34:23.234 --> 00:34:26.701
or in the middle there,
where I end the function,

00:34:26.701 --> 00:34:28.100
I end the expression,

00:34:28.100 --> 00:34:30.801
which is going to return
that function

00:34:30.801 --> 00:34:32.334
as the result of
that expression,

00:34:32.334 --> 00:34:34.267
and then I invoke it
immediately,

00:34:34.267 --> 00:34:35.534
means that what happens here

00:34:35.534 --> 00:34:37.701
is that I've sort of
created some code

00:34:37.701 --> 00:34:39.467
and just run it directly.

00:34:39.467 --> 00:34:40.801
I've just top to bottom

00:34:40.801 --> 00:34:44.100
run some code, which is going to
define a local variable,

00:34:44.100 --> 00:34:45.934
create a function--
which is not local,

00:34:45.934 --> 00:34:49.100
which is going to get exported
back out to the global scope,

00:34:49.100 --> 00:34:51.767
but that function can see
the local stuff, right?

00:34:51.767 --> 00:34:54.334
So I can sort of hide away
in my own private stuff

00:34:54.334 --> 00:34:55.868
inside of my module
by putting it in this pattern,

00:34:55.868 --> 00:34:57.467
using VAR for the stuff.

00:34:57.467 --> 00:35:00.367
It's a local and emitting VAR
for the stuff that's global.

00:35:00.367 --> 00:35:01.734
That's pretty good.

00:35:01.734 --> 00:35:03.434
We've got some sense
of modularity, again,

00:35:03.434 --> 00:35:07.501
built on this few set of
prototypical properties

00:35:07.501 --> 00:35:08.834
of the language:

00:35:08.834 --> 00:35:11.067
mutability, functions
as first class and functions

00:35:11.067 --> 00:35:12.968
as the only things
that create scope,

00:35:12.968 --> 00:35:16.133
the ability to modify
nearly everything,

00:35:16.133 --> 00:35:20.834
and closures as a way
to bind behavior to data

00:35:20.834 --> 00:35:24.968
and not the other way around.
Okay, so as you can imagine,

00:35:24.968 --> 00:35:26.334
we've seen a couple
of places here now

00:35:26.334 --> 00:35:28.067
with classes
and now with modules,

00:35:28.067 --> 00:35:30.701
where we could start to use
these patterns together

00:35:30.701 --> 00:35:33.501
to start to build up
our little library of stuff

00:35:33.501 --> 00:35:34.767
to help us
meet the challenges

00:35:34.767 --> 00:35:36.267
that we've got in
the large code base;

00:35:36.267 --> 00:35:38.167
and, in fact,
nearly every large code base

00:35:38.167 --> 00:35:40.701
has a library like this.

00:35:40.701 --> 00:35:42.100
The world of
JavaScript libraries

00:35:42.100 --> 00:35:44.400
has a lot of different answers
to a lot of the questions

00:35:44.400 --> 00:35:46.534
that you want.
So for modularity,

00:35:46.534 --> 00:35:48.901
it'd be great if we could
sort of have a script loader

00:35:48.901 --> 00:35:50.367
that would pull in
a bunch of stuff.

00:35:50.367 --> 00:35:51.767
It would transitive
dependency management,

00:35:51.767 --> 00:35:54.834
and it would put our stuff
inside of this body of code

00:35:54.834 --> 00:35:56.968
that we could then
think of as something

00:35:56.968 --> 00:35:59.868
that has dependencies
but can also hide local state.

00:35:59.868 --> 00:36:01.267
So this is the closure example.

00:36:01.267 --> 00:36:04.634
This is the tree control,
and these are its dependencies.

00:36:04.634 --> 00:36:06.067
And it does almost
exactly this, right?

00:36:06.067 --> 00:36:09.300
This is the module
that it might define,

00:36:09.300 --> 00:36:11.634
and it's going to
export some stuff.

00:36:11.634 --> 00:36:13.934
Okay, that's pretty good.

00:36:13.934 --> 00:36:15.934
But then you look at
other JavaScript libraries,

00:36:15.934 --> 00:36:17.634
and they do almost exactly
the same thing.

00:36:17.634 --> 00:36:19.400
Here's a tree control
from the tool kit

00:36:19.400 --> 00:36:22.067
that I used to work on, digit.

00:36:22.067 --> 00:36:25.267
And so that does exactly
the same thing, right?

00:36:25.267 --> 00:36:26.901
We've got this
module pattern here,

00:36:26.901 --> 00:36:29.467
where that's going to be
what you define inside of it.

00:36:29.467 --> 00:36:32.767
And at the same time,
these two syntaxes

00:36:32.767 --> 00:36:35.100
and these two semantics
aren't interoperable.

00:36:35.100 --> 00:36:37.667
You can't use them together.
That's not great.

00:36:37.667 --> 00:36:40.000
Now, we're in a place where
we have all of this raw power,

00:36:40.000 --> 00:36:42.634
and we can start to harness it
in ways that solve our problems,

00:36:42.634 --> 00:36:46.300
but we can't say the same thing
unless we all agree a priori

00:36:46.300 --> 00:36:47.767
which sort of patterns
we're going to use

00:36:47.767 --> 00:36:50.567
and in which style
we're going to use them.

00:36:50.567 --> 00:36:52.701
So this is the role
of the language.

00:36:52.701 --> 00:36:54.901
This is where language
evolution can really start

00:36:54.901 --> 00:36:56.767
to pay off
some big dividends.

00:36:56.767 --> 00:37:02.501
And so this is Dave Herman's
simple module proposal syntax,

00:37:02.501 --> 00:37:05.100
and this is something
like the array,

00:37:05.100 --> 00:37:10.033
the tree control requirements
written out in the new syntax.

00:37:10.033 --> 00:37:12.968
As you can see,
we actually have syntax saying

00:37:12.968 --> 00:37:14.200
this thing
is going to be a module.

00:37:14.200 --> 00:37:15.501
I'd like you
to acquire it.

00:37:15.501 --> 00:37:18.267
I'd like you to import
these sets of things

00:37:18.267 --> 00:37:20.601
into my local scope.

00:37:20.601 --> 00:37:23.934
And because we've got syntax
for this in harmony,

00:37:23.934 --> 00:37:26.267
which is the next version
of ECMAScript,

00:37:26.267 --> 00:37:27.801
we've got the ability
for everyone

00:37:27.801 --> 00:37:29.934
to agree on what it is
you're trying to get done.

00:37:29.934 --> 00:37:31.334
Because you have syntax,

00:37:31.334 --> 00:37:34.467
no one now has the incentive
to go write their own thing.

00:37:34.467 --> 00:37:37.868
You can start to rely on
there being one canonical way

00:37:37.868 --> 00:37:41.267
of saying here are my exports,
here are my imports.

00:37:41.267 --> 00:37:42.434
Here's how it's done.

00:37:42.434 --> 00:37:44.434
And so tool kits can
start to interoperate.

00:37:44.434 --> 00:37:45.934
They don't have to
continue to compete

00:37:45.934 --> 00:37:47.701
or, you know, reinvent

00:37:47.701 --> 00:37:50.367
on the basis of
a low level set of things

00:37:50.367 --> 00:37:52.400
that you might hope
would be provided for you

00:37:52.400 --> 00:37:54.067
in the language.

00:37:54.067 --> 00:37:55.567
The same thing
goes for classes.

00:37:55.567 --> 00:37:57.534
You know how we saw
all that boilerplate earlier,

00:37:57.534 --> 00:37:59.234
where you had the mix-ins
were for functions,

00:37:59.234 --> 00:38:01.567
and the classes which were
defined as functions--

00:38:01.567 --> 00:38:04.033
well, they all have
the same word, function.

00:38:04.033 --> 00:38:05.334
How do you know
it's a function?

00:38:05.334 --> 00:38:06.901
Again, we saw the word function
reused to go define

00:38:06.901 --> 00:38:08.200
that closure,

00:38:08.200 --> 00:38:11.200
which gave us the scope
for using the module pattern.

00:38:11.200 --> 00:38:12.834
Well, the word function
gets a lot of use,

00:38:12.834 --> 00:38:15.400
and in fact,
it is used so often

00:38:15.400 --> 00:38:17.000
that it's hard
to understand exactly

00:38:17.000 --> 00:38:18.901
what it is
you're reading sometimes,

00:38:18.901 --> 00:38:20.734
if you're not familiar
with all of these patterns.

00:38:20.734 --> 00:38:23.467
And so nearly every tool kit
comes along

00:38:23.467 --> 00:38:26.167
and creates a shorthand
to help you define a class,

00:38:26.167 --> 00:38:27.434
because, you know,

00:38:27.434 --> 00:38:28.667
you can just write
a function that'll do it.

00:38:28.667 --> 00:38:32.234
Closure does it.

00:38:32.234 --> 00:38:34.200
Prototype does it.

00:38:34.200 --> 00:38:35.834
You can imagine
that MochiKit

00:38:35.834 --> 00:38:37.534
or Dojo all do it slightly
differently,

00:38:37.534 --> 00:38:39.467
and these all lead to slightly
different semantics,

00:38:39.467 --> 00:38:42.667
because the way that you wire up
those relationships internally--

00:38:42.667 --> 00:38:47.534
and I showed you one way
with using traits

00:38:47.534 --> 00:38:49.868
or mix-ins inside
of constructor functions.

00:38:49.868 --> 00:38:51.234
They make different
decisions.

00:38:51.234 --> 00:38:52.734
You can compose this stuff
a lot of different ways,

00:38:52.734 --> 00:38:54.467
because you're always sort of
cobbling it together

00:38:54.467 --> 00:38:56.734
from the raw material
that's already in front of you.

00:38:56.734 --> 00:38:57.901
It's incredibly powerful,

00:38:57.901 --> 00:38:59.734
but with that power
comes the requirement

00:38:59.734 --> 00:39:01.868
that you have to get a bunch
of people to agree with you

00:39:01.868 --> 00:39:03.501
about how to use it.

00:39:03.501 --> 00:39:04.667
And in this case,

00:39:04.667 --> 00:39:06.901
a bunch of well-meaning
library authors came up

00:39:06.901 --> 00:39:09.501
with really good solutions
that fit their constraints.

00:39:09.501 --> 00:39:11.200
And in this case,

00:39:11.200 --> 00:39:12.701
they all differ
a little bit in terms of

00:39:12.701 --> 00:39:14.734
the underlying semantic, and
that's a little bit frustrating

00:39:14.734 --> 00:39:16.467
when you want to just
share a little bit of code

00:39:16.467 --> 00:39:17.701
with somebody over there.

00:39:17.701 --> 00:39:20.501
So what we'd like to do
is say what we mean.

00:39:20.501 --> 00:39:23.400
So this is a little bit of code
that comes from

00:39:23.400 --> 00:39:26.667
Marcin Wichary's
awesome Pac-Man demo,

00:39:26.667 --> 00:39:28.834
but this wouldn't be
how you'd write it today.

00:39:28.834 --> 00:39:31.133
This is how you'd have
to write in the future.

00:39:31.133 --> 00:39:33.033
Or this isn't how you would
have to write it today.

00:39:33.033 --> 00:39:34.300
This is what you would
like to be writing.

00:39:34.300 --> 00:39:35.934
You'd like to say,
I've got a class.

00:39:35.934 --> 00:39:39.367
It's got a constructor body,
and it's got some methods,

00:39:39.367 --> 00:39:40.968
and then I've got
a subclass which,

00:39:40.968 --> 00:39:43.100
you know, wires with that
prototypal relationship

00:39:43.100 --> 00:39:45.868
with the other thing.
It's got a constructor body,

00:39:45.868 --> 00:39:48.534
and it defines some properties
on its prototype.

00:39:48.534 --> 00:39:50.701
What we'd like to do
is have this syntax map

00:39:50.701 --> 00:39:52.367
to exactly what
we saw before, right?

00:39:52.367 --> 00:39:56.267
We don't want to change
the fundamental idea

00:39:56.267 --> 00:39:57.601
of what the language is.

00:39:57.601 --> 00:40:00.133
Prototype based,
functions as first class,

00:40:00.133 --> 00:40:03.701
closures to carry state,
top to bottom evaluation,

00:40:03.701 --> 00:40:07.033
delegation and not classes.

00:40:07.033 --> 00:40:09.834
When we introduce a syntax
for the word class, right,

00:40:09.834 --> 00:40:11.934
what we would like
for this to have happen here

00:40:11.934 --> 00:40:13.300
is when we evolve
the language,

00:40:13.300 --> 00:40:15.934
we want to hold on to
that fundamental set of things

00:40:15.934 --> 00:40:17.501
that define JavaScript
as JavaScript,

00:40:17.501 --> 00:40:20.234
so that you can understand old
code in the context of new code

00:40:20.234 --> 00:40:22.567
and that JavaScript can maintain
a lot of that dynamic,

00:40:22.567 --> 00:40:25.534
which pays off so well when
we need to start doing things

00:40:25.534 --> 00:40:26.834
that the language
doesn't provide for us.

00:40:26.834 --> 00:40:28.300
Because
what we've seen today is

00:40:28.300 --> 00:40:32.000
that we've put together a whole
series of things from raw parts,

00:40:32.000 --> 00:40:34.300
just little raw material, things
that are very high level,

00:40:34.300 --> 00:40:37.767
very high level constructs that
you're going to need to use,

00:40:37.767 --> 00:40:40.367
that you might not expect
to be there on JavaScript,

00:40:40.367 --> 00:40:41.734
but JavaScript
provides them for you.

00:40:41.734 --> 00:40:42.834
And it's easy
to love a language

00:40:42.834 --> 00:40:45.400
that gives you
that kind of power.

00:40:45.400 --> 00:40:46.868
So we wanted something that

00:40:46.868 --> 00:40:48.300
we in the standards committee
call de-sugaring.

00:40:48.300 --> 00:40:49.734
And de-sugaring
is the concept

00:40:49.734 --> 00:40:53.100
of when you define a new idea,
or you define new syntax,

00:40:53.100 --> 00:40:56.868
or a new semantic
in the language,

00:40:56.868 --> 00:40:59.634
it would be best if we could
describe that new thing

00:40:59.634 --> 00:41:01.767
in terms of the stuff
that's already there.

00:41:01.767 --> 00:41:04.868
So if I describe
a new language feature by

00:41:04.868 --> 00:41:07.501
what it would be like
if I'd just written it all out,

00:41:07.501 --> 00:41:09.334
we can start to say, aha.

00:41:09.334 --> 00:41:10.634
This fits
or this doesn't fit

00:41:10.634 --> 00:41:12.667
with the way we start to use
JavaScript today.

00:41:12.667 --> 00:41:14.801
So this is an example
of what I'd like to write

00:41:14.801 --> 00:41:18.367
in the new style, and what
you would have to write today

00:41:18.367 --> 00:41:21.734
to go make this all
work in the old style.

00:41:21.734 --> 00:41:25.501
Okay, that's a lot,
and it's a lot of boilerplate

00:41:25.501 --> 00:41:28.100
that we shouldn't
have to write.

00:41:28.100 --> 00:41:30.334
The same thing goes for
a lot of sort of little

00:41:30.334 --> 00:41:31.567
syntactic niggles.

00:41:31.567 --> 00:41:34.167
So let's say
I want a function

00:41:34.167 --> 00:41:35.601
that takes variable arguments.

00:41:35.601 --> 00:41:37.667
Today, in JavaScript, I have
to go unpack those arguments

00:41:37.667 --> 00:41:39.534
out of an explicit
arguments property

00:41:39.534 --> 00:41:41.634
that's available
inside the scope of any--

00:41:41.634 --> 00:41:44.167
inside of any function.

00:41:44.167 --> 00:41:46.100
So if I want a default value,

00:41:46.100 --> 00:41:47.601
I have to go
provide it for myself,

00:41:47.601 --> 00:41:50.267
and if I want to go grab
variable array arguments,

00:41:50.267 --> 00:41:54.467
I have to go grab the--turn
the best of the arguments

00:41:54.467 --> 00:41:58.934
into an array,
using array.prototype.slice,

00:41:58.934 --> 00:42:02.100
pass it in to the arguments
object as the scope,

00:42:02.100 --> 00:42:04.601
and then say give me everything
after the first one, right?

00:42:04.601 --> 00:42:06.167
And then create me
the list of parameters.

00:42:06.167 --> 00:42:07.367
That's a lot of boilerplate.

00:42:07.367 --> 00:42:09.834
It's sort of hard
to read that function,

00:42:09.834 --> 00:42:14.968
if you don't know this
particular sort of pattern,

00:42:14.968 --> 00:42:16.901
and then to understand what
it is that it's trying to do.

00:42:16.901 --> 00:42:18.367
It's much better
as a language,

00:42:18.367 --> 00:42:20.868
if what we get to is a place
where we can say what we mean

00:42:20.868 --> 00:42:22.200
when we're writing
our functions.

00:42:22.200 --> 00:42:25.000
I'd like the format
to have a default property

00:42:25.000 --> 00:42:28.167
of a blank string,
and I'd like the parameters

00:42:28.167 --> 00:42:33.033
that you don't have allocated
to some named argument

00:42:33.033 --> 00:42:35.567
stashed away in an array
called params.

00:42:35.567 --> 00:42:38.300
That's a pretty common thing
to want to do.

00:42:38.300 --> 00:42:42.501
And so this sort of thing
is coming in the next version

00:42:42.501 --> 00:42:44.000
of the language,

00:42:44.000 --> 00:42:50.601
and last week at JS Conf
and again at Node Conf,

00:42:50.601 --> 00:42:51.968
we started talking
about some work

00:42:51.968 --> 00:42:55.234
that we're doing on the Chrome
Team with the JavaScript

00:42:55.234 --> 00:42:57.734
and JavaScript compiler
written in JavaScript

00:42:57.734 --> 00:42:59.334
called Traceur.

00:42:59.334 --> 00:43:00.767
And Traceur's goal

00:43:00.767 --> 00:43:02.968
is to help us design
these new language features

00:43:02.968 --> 00:43:06.567
in a way that works really
well by trying them out,

00:43:06.567 --> 00:43:09.033
because language evolution
isn't a straight line thing.

00:43:09.033 --> 00:43:11.234
You know, we said that all these
libraries have different ways

00:43:11.234 --> 00:43:13.300
of doing a lot of the stuff,

00:43:13.300 --> 00:43:14.667
so what we'd like to do
is figure out

00:43:14.667 --> 00:43:16.100
what's the best pattern
or practice?

00:43:16.100 --> 00:43:17.868
What's the thing that
we would really like to blast?

00:43:17.868 --> 00:43:19.100
Or when there is
a new semantic

00:43:19.100 --> 00:43:21.067
that we can introduce
into the language,

00:43:21.067 --> 00:43:22.934
what is it that we would be
trying to say

00:43:22.934 --> 00:43:24.567
in JavaScript directly?

00:43:24.567 --> 00:43:31.033
And so this way, we sort of
have a way of, at runtime,

00:43:31.033 --> 00:43:34.300
running this compiler over
some piece of JavaScript

00:43:34.300 --> 00:43:36.033
written in the new syntax
and have it do something

00:43:36.033 --> 00:43:37.667
in the old syntax.

00:43:37.667 --> 00:43:40.934
So in this case--

00:43:48.400 --> 00:43:51.100
I'm going to go grab something
out of the parameters,

00:43:51.100 --> 00:43:55.701
and as you can see, it's
recompiling here, as I type.

00:44:08.167 --> 00:44:12.834
And now it has--

00:44:12.834 --> 00:44:14.601
ah, yes, there we are.

00:44:14.601 --> 00:44:16.501
Now it's created
all of the stuff

00:44:16.501 --> 00:44:18.167
that I was going to have
to write out by hand.

00:44:18.167 --> 00:44:19.300
It's just compiled that down

00:44:19.300 --> 00:44:21.734
from the new syntax
to the old syntax,

00:44:21.734 --> 00:44:24.567
and I can run it.

00:44:24.567 --> 00:44:27.300
I should be able to run it.

00:44:27.300 --> 00:44:33.033
man:
[indistinct comment]

00:44:33.033 --> 00:44:39.334
Russell:
Ah, yes, good call.

00:44:39.334 --> 00:44:40.601
Great, there we go.

00:44:40.601 --> 00:44:45.367
So this is a tool
that we're starting to use

00:44:45.367 --> 00:44:47.634
to help inform
the language evolution

00:44:47.634 --> 00:44:50.200
in order to help us
prototype stuff fast,

00:44:50.200 --> 00:44:51.901
get feedback
about how it works,

00:44:51.901 --> 00:44:53.701
and so we can
start to understand

00:44:53.701 --> 00:44:55.467
how the new stuff that
we're adding into the language

00:44:55.467 --> 00:44:57.801
fits with the old stuff
by writing real code in it.

00:44:57.801 --> 00:44:59.300
And as we work
in the standards committee

00:44:59.300 --> 00:45:02.033
to help make this stuff reality,
this sort of tool,

00:45:02.033 --> 00:45:04.067
I hope, is going to
make it possible for us

00:45:04.067 --> 00:45:06.767
to evolve faster and evolve
in a straighter line

00:45:06.767 --> 00:45:09.167
with the existing versions
of JavaScript,

00:45:09.167 --> 00:45:10.400
because what we don't want
is for us

00:45:10.400 --> 00:45:13.367
to add new things
like the idea of a class

00:45:13.367 --> 00:45:15.868
and have it be at war with the
idea of prototypal inheritance

00:45:15.868 --> 00:45:17.734
or functions
as first class objects.

00:45:17.734 --> 00:45:21.901
We want to continue to help you
build on these core fundamental,

00:45:21.901 --> 00:45:23.534
really powerful building blocks
in the language

00:45:23.534 --> 00:45:29.033
without introducing
new sorts of ideas or overhead

00:45:29.033 --> 00:45:30.801
that you have to consider
when you're writing your code.

00:45:30.801 --> 00:45:33.567
And so Traceur, again,
is an effort to help us

00:45:33.567 --> 00:45:35.701
understand and experiment
with the language,

00:45:35.701 --> 00:45:39.000
and it's available as an open
source project on Google Code.

00:45:39.000 --> 00:45:41.834
You can use it today, both on
the server and on the client,

00:45:41.834 --> 00:45:43.734
and you can start
to play with it.

00:45:43.734 --> 00:45:45.300
You can start to write
real code in it.

00:45:45.300 --> 00:45:48.167
There's a read, evaluate,
and print loop

00:45:48.167 --> 00:45:56.033
that you can just go to
and start typing code into.

00:45:56.033 --> 00:45:58.133
So I won't belabor
that anymore,

00:45:58.133 --> 00:46:04.067
but what we're really hoping
for is that you can start to use

00:46:04.067 --> 00:46:06.767
a lot of the new features that
we've started to play with.

00:46:06.767 --> 00:46:09.033
We have a list of features that
we've implemented in Traceur,

00:46:09.033 --> 00:46:10.367
and that's expanding every day.

00:46:10.367 --> 00:46:12.868
But things like modules,
classes, and traits,

00:46:12.868 --> 00:46:14.200
asynchronous programming--

00:46:14.200 --> 00:46:16.000
Asynchronous programming
is something we have to do

00:46:16.000 --> 00:46:17.968
all the time, and we wind up
doing it with a callback system.

00:46:17.968 --> 00:46:19.434
It'd be great if
there was support for that

00:46:19.434 --> 00:46:21.133
in a language that we didn't
have to continue to write

00:46:21.133 --> 00:46:23.100
the same boilerplate
over and over and over again.

00:46:23.100 --> 00:46:24.968
Destructuring assignment,
like we just saw,

00:46:24.968 --> 00:46:27.834
and the ability to use
the prototypal sort of style

00:46:27.834 --> 00:46:29.868
of extension,
but have it happen in a way

00:46:29.868 --> 00:46:31.601
that doesn't conflict
with everybody else's objects

00:46:31.601 --> 00:46:32.801
in the system.

00:46:32.801 --> 00:46:34.667
Those are the sorts of
high priority work items

00:46:34.667 --> 00:46:38.734
that we're starting to use
Traceur to evaluate designs for,

00:46:38.734 --> 00:46:40.167
and we'd love your help.

00:46:40.167 --> 00:46:42.601
We'd love for you to start
using it, testing it out,

00:46:42.601 --> 00:46:44.968
working with the system,
and helping us write code

00:46:44.968 --> 00:46:46.234
in the new style,
so we can understand

00:46:46.234 --> 00:46:48.667
whether or not
it's actually good.

00:46:48.667 --> 00:46:52.133
So Traceur is one idea
to help us get there.

00:46:52.133 --> 00:46:54.968
We need implementations early
to inform the design process

00:46:54.968 --> 00:46:57.267
for the future of the language,
so that the things that you do

00:46:57.267 --> 00:47:00.334
in the language now
carry out into the future

00:47:00.334 --> 00:47:05.100
as core idioms and core concepts
that you can rely on there, too.

00:47:05.100 --> 00:47:07.300
But we need those things
to eventually trickle down

00:47:07.300 --> 00:47:10.934
into real, live implementations,
V8, other JavaScript engines,

00:47:10.934 --> 00:47:12.367
and we want to make sure
that these things

00:47:12.367 --> 00:47:15.033
are available to you quickly in
the fast-moving constituencies.

00:47:15.033 --> 00:47:18.667
So if you can start to use this
stuff in the Chrome Web Store--

00:47:18.667 --> 00:47:21.534
because almost everyone in
the Chrome Web Store gets--

00:47:21.534 --> 00:47:23.868
or who you can target
through the Chrome Web Store

00:47:23.868 --> 00:47:25.734
gets the latest version
of Chrome within a week--

00:47:25.734 --> 00:47:26.968
that's really good.

00:47:26.968 --> 00:47:28.868
We can start to get fast
feedback in the language

00:47:28.868 --> 00:47:31.501
and in the design of the
next version of JavaScript

00:47:31.501 --> 00:47:33.467
based on your feedback
about what's working

00:47:33.467 --> 00:47:36.267
and what's not in ways
that we couldn't before.

00:47:36.267 --> 00:47:39.467
The lead time on a new version
of the language has been years--

00:47:39.467 --> 00:47:42.267
in some cases,
closer to a decade.

00:47:42.267 --> 00:47:47.267
And so you can follow along
the ECMAScript wiki.

00:47:47.267 --> 00:47:48.567
I realize this is--
the link

00:47:48.567 --> 00:47:50.033
is a little bit long,
but there's a list

00:47:50.033 --> 00:47:51.868
of accepted proposals for the
next version of the language.

00:47:51.868 --> 00:47:53.267
That's going to be
somewhat formalized

00:47:53.267 --> 00:47:54.567
in the next couple of months.

00:47:54.567 --> 00:47:56.300
And as that list
is locked down,

00:47:56.300 --> 00:47:58.300
we're going to continue
to iterate on those proposals.

00:47:58.300 --> 00:47:59.601
They're going to get
new syntax.

00:47:59.601 --> 00:48:01.100
Things are going
to change there.

00:48:01.100 --> 00:48:02.968
But the list of things
that are in the proposal stage

00:48:02.968 --> 00:48:04.334
for Harmony are the set
of things that we,

00:48:04.334 --> 00:48:06.267
as a committee,
have agreed to go work on

00:48:06.267 --> 00:48:07.667
and standardize together.

00:48:07.667 --> 00:48:08.868
And so Traceur
is going to continue

00:48:08.868 --> 00:48:10.200
to follow that evolution

00:48:10.200 --> 00:48:12.634
and allow us
to start to work in ways

00:48:12.634 --> 00:48:15.367
that give us quick feedback
about whether or not

00:48:15.367 --> 00:48:17.000
we're doing the right things
for you

00:48:17.000 --> 00:48:20.734
as you're writing large
pieces of JavaScript.

00:48:20.734 --> 00:48:24.167
Okay, questions?

00:48:29.734 --> 00:48:33.501
man: Hi. So the common JS
modules specification

00:48:33.501 --> 00:48:37.434
has like a really simple
require and exports

00:48:37.434 --> 00:48:39.767
that really doesn't--
that--it's kind of--

00:48:39.767 --> 00:48:41.367
it doesn't factor in,
you know,

00:48:41.367 --> 00:48:42.734
how things
get loaded or whatever.

00:48:42.734 --> 00:48:44.801
It's really just a binding
mechanism between

00:48:44.801 --> 00:48:46.334
disparate name space.

00:48:46.334 --> 00:48:47.934
That seems ultimately
simple to me,

00:48:47.934 --> 00:48:50.968
but it doesn't seem like Harmony
is going in that direction.

00:48:50.968 --> 00:48:54.868
Russell: So the simple
modules proposal

00:48:54.868 --> 00:48:57.734
gives us a way
to have a first pass.

00:48:57.734 --> 00:49:01.968
So...sorry, I should run this
backwards.

00:49:01.968 --> 00:49:07.534
The common JS module system
sort of is implicitly server JS.

00:49:07.534 --> 00:49:09.534
You kind of assume that
the thing that you're getting

00:49:09.534 --> 00:49:11.200
in the next statement
is cheap to fetch.

00:49:11.200 --> 00:49:12.868
And so what we need
for the client

00:49:12.868 --> 00:49:17.534
is an ability to make the
require and provide statements

00:49:17.534 --> 00:49:19.734
look apparently synchronous
but have them operate

00:49:19.734 --> 00:49:22.000
asynchronously on the network,
which means that we want to get

00:49:22.000 --> 00:49:24.667
the transitive closure
of all of the dependencies

00:49:24.667 --> 00:49:26.000
that your module needs.

00:49:26.000 --> 00:49:27.601
man: Then you're kind of
mixing like load,

00:49:27.601 --> 00:49:28.601
the loading and--

00:49:28.601 --> 00:49:29.601
Russell:
They are mixed.

00:49:29.601 --> 00:49:30.834
There's no way
to unmix them.

00:49:30.834 --> 00:49:32.767
Because of the way
that JavaScript evaluates

00:49:32.767 --> 00:49:34.367
top to bottom,
we either have to--

00:49:34.367 --> 00:49:35.834
and because
it runs on the UI thread,

00:49:35.834 --> 00:49:39.267
we either have to block
the entire client

00:49:39.267 --> 00:49:41.367
while we go fetch resources,
which is what happens

00:49:41.367 --> 00:49:43.234
with the document.write,
that sort of thing--

00:49:43.234 --> 00:49:44.234
man: Yeah, I see
what you're saying.

00:49:44.234 --> 00:49:45.567
Russell:
Or we have to find a way

00:49:45.567 --> 00:49:48.467
to accommodate asynchronous
loading in the syntax,

00:49:48.467 --> 00:49:49.834
and that's what the simple
module proposal does.

00:49:49.834 --> 00:49:50.968
man:
I see what you're saying.

00:49:50.968 --> 00:49:52.234
Russell: Which is
fundamentally different,

00:49:52.234 --> 00:49:53.968
because we can use syntax
to do that in a way

00:49:53.968 --> 00:49:55.400
that common JS can't.

00:49:55.400 --> 00:49:57.767
man: Yeah, I use a system where
I kind of--you use common JS

00:49:57.767 --> 00:50:02.400
on the client, but I don't--
I allow for, like,

00:50:02.400 --> 00:50:03.634
forward references.
Russell: Right.

00:50:03.634 --> 00:50:05.567
man: So like, those things,
they get resolved

00:50:05.567 --> 00:50:06.934
at a later time,

00:50:06.934 --> 00:50:10.067
so you can't kind of use them
completely until later.

00:50:10.067 --> 00:50:11.534
Russell: Yeah, I'm really
hopeful that we can get

00:50:11.534 --> 00:50:13.901
the semantic that Dave Herman
has put forward,

00:50:13.901 --> 00:50:16.300
because it really does give us
the power to not force you

00:50:16.300 --> 00:50:17.734
to think about when your code
is going to run.

00:50:17.734 --> 00:50:20.033
If you say require in one line,
you can use it in the next one,

00:50:20.033 --> 00:50:23.267
and I think that's
a key usability feature

00:50:23.267 --> 00:50:27.834
of a language improvement
in this area.

00:50:27.834 --> 00:50:29.367
man:
Question. On the last slide,

00:50:29.367 --> 00:50:31.033
one of the things you mentioned
was asynchronous programming

00:50:31.033 --> 00:50:32.467
with JavaScript.

00:50:32.467 --> 00:50:36.701
And, you know, like Node JS
is one of the new frameworks.

00:50:36.701 --> 00:50:38.133
I'm wondering if you can talk
a little bit about

00:50:38.133 --> 00:50:41.300
some best practices for
how to handle error conditions

00:50:41.300 --> 00:50:45.334
or exceptions when you're
doing an asynchronous call

00:50:45.334 --> 00:50:47.133
that may not be
in the same call stack

00:50:47.133 --> 00:50:49.901
as when you actually
executed the call.

00:50:49.901 --> 00:50:52.434
Russell:
So this is a hot topic.

00:50:52.434 --> 00:50:56.868
The asynchronous pattern
that seems to have won

00:50:56.868 --> 00:50:59.701
the most mindshare is something
like deferreds or promises.

00:50:59.701 --> 00:51:02.367
Again, the common JS guys
have done great work there.

00:51:02.367 --> 00:51:06.234
And so those systems
tend to have some error

00:51:06.234 --> 00:51:10.300
handling callback
that you can register,

00:51:10.300 --> 00:51:13.601
so that if an error does occur,
you can be notified of it.

00:51:13.601 --> 00:51:16.634
I actually was talking with
the Node JS guys just last week

00:51:16.634 --> 00:51:19.000
in Portland about exactly
how they want to do this,

00:51:19.000 --> 00:51:21.167
because I'm hopeful
that what we can do

00:51:21.167 --> 00:51:25.033
is build on top of built-in
language deferred

00:51:25.033 --> 00:51:28.000
or promise API,
the ability to use the weight

00:51:28.000 --> 00:51:31.167
or async keywords to go help
mark particular methods

00:51:31.167 --> 00:51:32.667
of returning
these deferred objects,

00:51:32.667 --> 00:51:36.601
but error handling does turn
into a primary question then.

00:51:36.601 --> 00:51:39.467
So what they came to,

00:51:39.467 --> 00:51:41.000
and I think
it's a pretty good answer,

00:51:41.000 --> 00:51:43.267
is that you have
a single callback, right?

00:51:43.267 --> 00:51:46.067
And that needs to be
also informed of errors.

00:51:46.067 --> 00:51:48.601
But you can have
an optional second callback,

00:51:48.601 --> 00:51:51.200
which will be told
about error conditions

00:51:51.200 --> 00:51:53.200
if you choose to handle them
independently.

00:51:53.200 --> 00:51:55.467
And I think,
you know, the idea

00:51:55.467 --> 00:51:56.534
that you're not going
to have to deal with errors

00:51:56.534 --> 00:51:58.400
in the primary callback

00:51:58.400 --> 00:51:59.767
is a little bit farfetched,

00:51:59.767 --> 00:52:01.601
and so I think that's maybe
a good trade-off.

00:52:01.601 --> 00:52:04.934
But it is an open topic.

00:52:04.934 --> 00:52:07.133
We probably need
language level support

00:52:07.133 --> 00:52:10.868
for sort of moving
stack traces.

00:52:10.868 --> 00:52:14.434
Like, if I throw in one catch
here and then re-throw

00:52:14.434 --> 00:52:16.400
the exception someplace else,
we need some VM

00:52:16.400 --> 00:52:19.734
or language level support
to help us make that reporting

00:52:19.734 --> 00:52:21.501
cleaner and nicer.

00:52:21.501 --> 00:52:23.834
And I think
that's another important area

00:52:23.834 --> 00:52:27.434
that we might be able to help
tie these things back together,

00:52:27.434 --> 00:52:30.400
once we go async.
man: Okay, great.

00:52:30.400 --> 00:52:33.267
man: Hi, I just wanted to know
if there was any interest

00:52:33.267 --> 00:52:39.234
or effort within Google
to do some more of the more

00:52:39.234 --> 00:52:41.234
server side JavaScript,
stuff like Node JS,

00:52:41.234 --> 00:52:45.367
and maybe any possibility
of ever having that available

00:52:45.367 --> 00:52:46.901
like on App Engine.

00:52:46.901 --> 00:52:48.701
Russell: I can't speak
to future product plans,

00:52:48.701 --> 00:52:50.801
but I can say that the VA team
is working closely

00:52:50.801 --> 00:52:54.534
with the Node team to continue
to make Node faster.

00:52:54.534 --> 00:52:56.167
We care a lot about
their use cases,

00:52:56.167 --> 00:53:00.801
and we want to make sure
that we're supporting them.

00:53:00.801 --> 00:53:04.634
man: So looking at the Traceur
function and the no sugar,

00:53:04.634 --> 00:53:07.467
de-sugaring, in Lisp,
this was done

00:53:07.467 --> 00:53:10.033
because they had
a powerful macro facility,

00:53:10.033 --> 00:53:12.934
so that the developer could
actually introduce new syntax

00:53:12.934 --> 00:53:16.901
into their programs and define
the behaviors in Lisp.

00:53:16.901 --> 00:53:18.434
Is there any thought of
doing something like that

00:53:18.434 --> 00:53:19.734
in JavaScript?

00:53:19.734 --> 00:53:21.434
Russell: We have a hard time
with that in JavaScript,

00:53:21.434 --> 00:53:23.868
because we have both statements
and expressions,

00:53:23.868 --> 00:53:26.400
and we have, you know,

00:53:26.400 --> 00:53:30.033
a lot of complex grammar
that's not movable.

00:53:30.033 --> 00:53:32.334
And as a result,
any macro facility

00:53:32.334 --> 00:53:34.300
is going to quickly
become undecidable.

00:53:34.300 --> 00:53:37.801
And so I think
we're in a place where macros,

00:53:37.801 --> 00:53:40.667
the way I think you want them,
aren't possible

00:53:40.667 --> 00:53:41.968
in JavaScript.

00:53:41.968 --> 00:53:43.634
New syntax, specifically,

00:53:43.634 --> 00:53:48.534
is going to have to continue
to happen through the committee.

00:53:48.534 --> 00:53:50.000
So I think there are places

00:53:50.000 --> 00:53:52.834
where we can carve out
some stuff.

00:53:52.834 --> 00:53:55.100
There's been some good work
in string formatting,

00:53:55.100 --> 00:53:57.334
for instance, to make it
possible to plug in--

00:53:57.334 --> 00:54:01.000
through protocols--some new
behavior into existing syntax,

00:54:01.000 --> 00:54:03.634
and I think that's maybe
the promising way forward.

00:54:03.634 --> 00:54:06.534
man: Yeah.

00:54:06.534 --> 00:54:09.801
man: So did you know
that you can build Firefox

00:54:09.801 --> 00:54:13.234
with support for Python
as a scripting language?

00:54:13.234 --> 00:54:14.667
Russell:
I've heard tell of this,

00:54:14.667 --> 00:54:16.734
but it's been that way
for many years, as I recall.

00:54:16.734 --> 00:54:19.200
man: Yes, debug build
with Firefox comes with it.

00:54:19.200 --> 00:54:21.767
More seriously,
what do you think of GWT

00:54:21.767 --> 00:54:27.734
or more usefully Pyjamas
as actual development platforms

00:54:27.734 --> 00:54:30.767
instead of writing
direct JavaScript,

00:54:30.767 --> 00:54:36.033
and using the richer type system
of Python or Java

00:54:36.033 --> 00:54:38.701
instead of the bare bones one
in JavaScript?

00:54:38.701 --> 00:54:40.067
Russell: Type systems
are really great.

00:54:40.067 --> 00:54:44.033
I think that it's a key
missing feature from JavaScript

00:54:44.033 --> 00:54:45.934
specifically because what
you wind up writing, again,

00:54:45.934 --> 00:54:47.501
is a lot of boilerplate
to help you test

00:54:47.501 --> 00:54:50.467
whether or not you were actually
tall enough to ride the ride.

00:54:50.467 --> 00:54:52.100
You actually have to
sort of go cart around

00:54:52.100 --> 00:54:53.467
a lot of this
testing magic.

00:54:53.467 --> 00:54:55.000
I'm not hopeful
for type systems.

00:54:55.000 --> 00:54:56.367
This is my personal opinion.

00:54:56.367 --> 00:54:59.234
I'm not hopeful for type systems
as a be all and end all

00:54:59.234 --> 00:55:02.334
sort of verification system
for your program.

00:55:02.334 --> 00:55:03.834
The web is too dynamic.

00:55:03.834 --> 00:55:05.734
Client-side programs
are too dynamic for that.

00:55:05.734 --> 00:55:07.434
We're dealing with
user behavior a lot.

00:55:07.434 --> 00:55:10.234
Instead, what I'd like for us
to get to is a place

00:55:10.234 --> 00:55:14.334
where the syntactic warts
of JavaScript sort of get

00:55:14.334 --> 00:55:15.567
eased over one way
or the other.

00:55:15.567 --> 00:55:16.701
Things like CoffeeScript

00:55:16.701 --> 00:55:18.133
are pointing
in a good direction here,

00:55:18.133 --> 00:55:22.734
where you can sort of come
back up with some new syntax,

00:55:22.734 --> 00:55:24.467
and hopefully that'll
eventually work its way

00:55:24.467 --> 00:55:25.667
into the language.

00:55:25.667 --> 00:55:27.167
But things like
the module that are--

00:55:27.167 --> 00:55:29.467
they're going to have
an analogous API, again,

00:55:29.467 --> 00:55:32.634
building a protocol that you can
plug into with your own code,

00:55:32.634 --> 00:55:35.067
and that API will allow you
to do things like run

00:55:35.067 --> 00:55:37.934
the CoffeeScript compiler
or the Pyjamas compiler

00:55:37.934 --> 00:55:40.267
across loaded modules
before they're run,

00:55:40.267 --> 00:55:42.567
which means that you can
sort of have runtime support

00:55:42.567 --> 00:55:45.033
for those built-in.

00:55:45.033 --> 00:55:46.667
I think the--you asked a
question

00:55:46.667 --> 00:55:47.834
of what do I think about

00:55:47.834 --> 00:55:51.200
those tools as a way to do
production work.

00:55:51.200 --> 00:55:54.334
If your language veers far
enough from the core semantics

00:55:54.334 --> 00:55:57.334
of JavaScript, you wind up
not just with the ability

00:55:57.334 --> 00:55:59.901
to do all sorts of tooling
and stuff that comes along

00:55:59.901 --> 00:56:02.667
with your source language,
but you also wind up with

00:56:02.667 --> 00:56:06.067
the need for the runtime
to do dead code edition.

00:56:06.067 --> 00:56:11.234
You need to go and sort of
not just do a one-for-one

00:56:11.234 --> 00:56:13.167
translation down to the
analogous statements

00:56:13.167 --> 00:56:14.434
in the other language,
but you have to make sure

00:56:14.434 --> 00:56:16.234
that the semantics are right.

00:56:16.234 --> 00:56:17.667
You have to make sure
that you have code in there

00:56:17.667 --> 00:56:20.367
to support any differences,
any impotence mismatches

00:56:20.367 --> 00:56:21.434
between the two languages.

00:56:21.434 --> 00:56:23.234
And so I'm much more hopeful

00:56:23.234 --> 00:56:27.501
about things like CoffeeScript
and the Traceur editions

00:56:27.501 --> 00:56:30.033
because they don't add
a lot of extra stuff,

00:56:30.033 --> 00:56:31.467
because the languages
aren't that far away

00:56:31.467 --> 00:56:33.033
in terms of core semantic.

00:56:33.033 --> 00:56:35.534
man: All right,
thank you.

00:56:35.534 --> 00:56:38.968
man: Hi, one kind of application
domain that could benefit

00:56:38.968 --> 00:56:41.634
from scripting
that's not really--

00:56:41.634 --> 00:56:45.067
doesn't have a solution today
is a native Android app.

00:56:45.067 --> 00:56:46.334
So I wonder if there are any--

00:56:46.334 --> 00:56:47.968
we've dabbled with,
you know, plug-in Rhino

00:56:47.968 --> 00:56:49.334
and things like that.

00:56:49.334 --> 00:56:52.434
I wonder if there's any activity
in that area right now.

00:56:52.434 --> 00:56:54.100
Russell: I think you'd have
to ask the Android team.

00:56:54.100 --> 00:56:55.968
I'm sorry, I'm not up-to-date
on what they're doing there.

00:56:55.968 --> 00:56:58.567
man: Okay.
Russell: Thanks.

00:56:58.567 --> 00:56:59.834
man:
I had another question.

00:56:59.834 --> 00:57:04.400
So in my Python programs,
I like to use sometimes

00:57:04.400 --> 00:57:07.167
multiple inheritance,
and I have complex--

00:57:07.167 --> 00:57:08.968
Russell: C3MRO,
right, yeah.

00:57:08.968 --> 00:57:10.567
man: Dependency graphs
and so on, yeah.

00:57:10.567 --> 00:57:14.534
So and they have a method
resolution order in Python

00:57:14.534 --> 00:57:17.434
that allows you to call
the super classes methods,

00:57:17.434 --> 00:57:19.601
you know, exactly once
in the right order, and--

00:57:19.601 --> 00:57:22.100
or at least
a well-defined order.

00:57:22.100 --> 00:57:26.334
Is anything going on in Harmony
for allowing for something

00:57:26.334 --> 00:57:30.300
like an MRO type
call graph resolution?

00:57:30.300 --> 00:57:33.000
Russell: I don't think
we're going to break the idea

00:57:33.000 --> 00:57:35.234
of a single prototype.
man: Right.

00:57:35.234 --> 00:57:37.033
Russell: So the analogous
thing here would be

00:57:37.033 --> 00:57:39.501
multi prototype languages.

00:57:39.501 --> 00:57:40.801
I'm hopeful
that what we'll get done

00:57:40.801 --> 00:57:42.734
is something like
Tom Van Cutsem's

00:57:42.734 --> 00:57:44.634
Traits semantic,

00:57:44.634 --> 00:57:46.767
where we can add
a syntax for defining

00:57:46.767 --> 00:57:49.100
a set of things
that you would sort of--

00:57:49.100 --> 00:57:51.100
like we did with mix-ins,
add to the class,

00:57:51.100 --> 00:57:54.968
and then do conflict resolution
with syntax.

00:57:54.968 --> 00:57:56.567
Because what you're trying to
say in a lot of these cases

00:57:56.567 --> 00:57:58.901
isn't, I'd like for you
to sort of decide for me

00:57:58.901 --> 00:58:00.567
which of these things
I am at runtime.

00:58:00.567 --> 00:58:02.300
It's not really a--
an "is a" relationship.

00:58:02.300 --> 00:58:03.434
It's sort of a "has a"
relationship,

00:58:03.434 --> 00:58:04.467
what you're saying.

00:58:04.467 --> 00:58:05.734
I'd like this new behavior

00:58:05.734 --> 00:58:07.834
to also be available
to my object.

00:58:07.834 --> 00:58:09.200
And if you can factor
those things out,

00:58:09.200 --> 00:58:11.267
it can help with composability
and then eventually

00:58:11.267 --> 00:58:12.667
with type testing.

00:58:12.667 --> 00:58:15.901
And I think Traits are where,
at least I'm hopeful,

00:58:15.901 --> 00:58:18.200
that we'll go
to make a lot of that easier.

00:58:18.200 --> 00:58:20.701
man: Yeah, I use a wrapper
where like I kind of

00:58:20.701 --> 00:58:23.834
build a copy of
a well-defined prototype chain,

00:58:23.834 --> 00:58:26.534
specifically for this
particular set of mix-ins,

00:58:26.534 --> 00:58:28.567
and so like
you can kind of emulate,

00:58:28.567 --> 00:58:29.934
you know,
by specifically listing

00:58:29.934 --> 00:58:33.601
the order in which you want
things to be resolved

00:58:33.601 --> 00:58:39.234
and kind of get the behavior
for that in JavaScript.

00:58:39.234 --> 00:58:42.067
man: Mainly curious, do you know
whether Traceur shares

00:58:42.067 --> 00:58:44.734
common lineage with
the cross interpreter

00:58:44.734 --> 00:58:47.234
in Google Widget Toolkit?

00:58:47.234 --> 00:58:48.834
Russell: The Traceur code base
is brand-new.

00:58:48.834 --> 00:58:51.000
It's a, you know,

00:58:51.000 --> 00:58:55.968
a new client-side compiler
that we wrote,

00:58:55.968 --> 00:58:59.868
hand-built parser,
that sort of thing.

00:58:59.868 --> 00:59:03.267
man: Thank you.
Russell: Yeah.

00:59:03.267 --> 00:59:06.801
All right, one more.
All right.

00:59:06.801 --> 00:59:08.901
man:
So I'm a C# developer,

00:59:08.901 --> 00:59:13.200
and I've stayed away from
JavaScript for a very long time,

00:59:13.200 --> 00:59:15.834
mostly because I didn't--
I knew the what,

00:59:15.834 --> 00:59:18.901
but I didn't know the why,
and that's been really good

00:59:18.901 --> 00:59:21.000
in today's session.

00:59:21.000 --> 00:59:24.634
I'd like to continue
exploring.

00:59:24.634 --> 00:59:27.934
Can you recommend any reading--
specific reading material?

00:59:27.934 --> 00:59:29.868
Because, of course, I could
always do a Google search.

00:59:29.868 --> 00:59:31.234
Russell:
Yeah.

00:59:31.234 --> 00:59:33.501
man: But that would continue
along the path of not just

00:59:33.501 --> 00:59:35.534
the what but the why also.

00:59:35.534 --> 00:59:36.868
Russell:
The latest version

00:59:36.868 --> 00:59:39.067
of "JavaScript, the Definitive
Guide" is pretty good.

00:59:39.067 --> 00:59:42.067
I recommend
"Eloquent JavaScript."

00:59:42.067 --> 00:59:44.634
It does a great job of sort of
introducing these core concepts

00:59:44.634 --> 00:59:48.567
and getting you through not just
sort of what you can do.

00:59:48.567 --> 00:59:50.801
I didn't talk a lot
about how DOM interacts

00:59:50.801 --> 00:59:53.601
with all of these things.

00:59:53.601 --> 00:59:57.100
My recommendation
is that you find someplace

00:59:57.100 --> 00:59:59.868
to start playing with a language
that's not a web browser.

00:59:59.868 --> 01:00:01.234
I mean, web browsers
are really handy.

01:00:01.234 --> 01:00:03.968
You can start to sort of like
make this all happen.

01:00:03.968 --> 01:00:05.767
But if you just sort of play
with the command line

01:00:05.767 --> 01:00:09.400
in the browser or start to work
with a local copy of V8

01:00:09.400 --> 01:00:11.334
or Node JS,
you can really get a feel

01:00:11.334 --> 01:00:13.501
for what's in the language
and what's not in the browser.

01:00:13.501 --> 01:00:15.400
JavaScript takes--in almost
every environment,

01:00:15.400 --> 01:00:18.234
it takes a lot of its identity
from the standard library

01:00:18.234 --> 01:00:20.567
that sort of
it's been wedded to.

01:00:20.567 --> 01:00:21.901
And in most cases,

01:00:21.901 --> 01:00:22.934
because it has
a very small standard library,

01:00:22.934 --> 01:00:24.400
all of that is in
the environment.

01:00:24.400 --> 01:00:28.300
And so the more you can sort of
remove those potential hurdles

01:00:28.300 --> 01:00:29.934
or sort of impotence mismatches

01:00:29.934 --> 01:00:31.567
with what's just
in the language,

01:00:31.567 --> 01:00:34.701
I think the faster
it'll help you learn it.

01:00:34.701 --> 01:00:35.934
Yeah.

01:00:35.934 --> 01:00:38.200
man: Actually,
in a similar situation

01:00:38.200 --> 01:00:40.601
as the previous question,
which is I stayed away

01:00:40.601 --> 01:00:43.467
from JavaScript
for a number of reasons.

01:00:43.467 --> 01:00:44.968
Probably
one of the biggest ones

01:00:44.968 --> 01:00:47.367
was the lack of debug support.
Russell: Mm-hmm.

01:00:47.367 --> 01:00:52.033
man: And the fact that you have
unexpected surprises,

01:00:52.033 --> 01:00:56.267
like being able to overload
the array constructor,

01:00:56.267 --> 01:00:59.968
that lend itself to,
you know, security holes,

01:00:59.968 --> 01:01:01.801
whereas someone coming
from another language

01:01:01.801 --> 01:01:04.000
isn't expecting that,
and they don't even consider

01:01:04.000 --> 01:01:06.434
that as a possibility
when you're looking at code.

01:01:06.434 --> 01:01:09.934
So specifically, is there
anything that's talked about

01:01:09.934 --> 01:01:13.200
being added, where--
when you talk about modules,

01:01:13.200 --> 01:01:16.000
that the module can set up
certainly like preconditions?

01:01:16.000 --> 01:01:19.634
I'm expecting these sets
of things to be true,

01:01:19.634 --> 01:01:22.234
like the array constructor
cannot be overloaded,

01:01:22.234 --> 01:01:26.934
or anything else
where you can say, flag,

01:01:26.934 --> 01:01:29.701
this is going to be a problem
or not going to run right.

01:01:29.701 --> 01:01:31.100
Russell: So one of the big
things that's happening

01:01:31.100 --> 01:01:33.834
with the module syntax
is that we're removing

01:01:33.834 --> 01:01:36.300
the ability to share globals,
so you won't have

01:01:36.300 --> 01:01:39.300
a single shared global,
which is going to be big,

01:01:39.300 --> 01:01:41.767
to prevent people from sort of
blowing your own legs off.

01:01:41.767 --> 01:01:44.133
The other thing
is that ECMAScript 5,

01:01:44.133 --> 01:01:47.968
the version that was just
recently ratified,

01:01:47.968 --> 01:01:50.200
implements what we call
a strict mode.

01:01:50.200 --> 01:01:52.467
And strict mode turns off
some of the worst foot guns.

01:01:52.467 --> 01:01:59.234
It helps keep you out of trouble
by giving you more and more

01:01:59.234 --> 01:02:02.367
pre-checking for things
like uninitialized variables,

01:02:02.367 --> 01:02:04.634
that sort of thing,
where it keeps you from

01:02:04.634 --> 01:02:07.968
sort of tripping over yourself
in some pretty common areas.

01:02:07.968 --> 01:02:10.200
It's not perfect,
but it's certainly a start.

01:02:10.200 --> 01:02:11.801
So use strict inside
of all of your functions,

01:02:11.801 --> 01:02:13.200
and you should be good to go.

01:02:13.200 --> 01:02:17.300
man: And what about the idea
of like official debug support?

01:02:17.300 --> 01:02:20.667
Russell: So that's
an engine-by-engine thing.

01:02:20.667 --> 01:02:26.033
The topic of common stack traces
has been raised

01:02:26.033 --> 01:02:28.000
a bunch of times, and it's
going to be very difficult,

01:02:28.000 --> 01:02:30.067
because that constrains
our ability to optimize.

01:02:30.067 --> 01:02:33.400
So things like
alighting away dead code,

01:02:33.400 --> 01:02:35.567
those are the sorts of things
that are going to be hard to do

01:02:35.567 --> 01:02:37.267
if we have to agree
on a stack trace format.

01:02:37.267 --> 01:02:39.367
So what we do have is
really good support,

01:02:39.367 --> 01:02:43.300
say, in the Chrome web inspector
for setting breakpoints,

01:02:43.300 --> 01:02:46.000
future breakpoints,
getting call stacks,

01:02:46.000 --> 01:02:50.033
and soon the ability to
sort of wire up line numbers

01:02:50.033 --> 01:02:51.167
to source code.

01:02:51.167 --> 01:02:53.734
So yeah, debugability
is a hot topic.

01:02:53.734 --> 01:02:55.701
It tends to happen
through the browser

01:02:55.701 --> 01:02:57.634
and not through
the language runtime.

01:02:57.634 --> 01:03:01.467
man:
[indistinct]

01:03:01.467 --> 01:03:03.200
Russell: So the question was
will a closure compiler

01:03:03.200 --> 01:03:05.601
help with the debugability.
If the closure compiler has--

01:03:05.601 --> 01:03:08.901
man:
[indistinct]

01:03:08.901 --> 01:03:11.434
Russell: Oh, will the closure
compiler help beginners?

01:03:11.434 --> 01:03:15.767
No. It's designed
to help folks who know

01:03:15.767 --> 01:03:17.767
that they have a problem
avoid having problems.

01:03:17.767 --> 01:03:19.133
Okay, cool.

01:03:19.133 --> 01:03:22.100
Thanks again for coming,
and I'm looking forward to it.

