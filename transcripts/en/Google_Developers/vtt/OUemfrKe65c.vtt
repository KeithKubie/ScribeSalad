WEBVTT
Kind: captions
Language: en

00:00:01.000 --> 00:00:01.467
Jeff Sharkey:
Well, hey, everybody,

00:00:01.467 --> 00:00:02.868
thanks for coming
this afternoon.

00:00:02.868 --> 00:00:04.367
My name is Jeff Sharkey,

00:00:04.367 --> 00:00:06.601
and I've been working on Android
for about a year and a half

00:00:06.601 --> 00:00:08.501
outside of the Google team.

00:00:08.501 --> 00:00:10.501
And then recently,
about six months ago,

00:00:10.501 --> 00:00:12.000
I joined Google,

00:00:12.000 --> 00:00:13.667
and I've been working on some
cool stuff in the meantime.

00:00:13.667 --> 00:00:15.934
And today we're gonna talk
about battery life.

00:00:15.934 --> 00:00:18.400
So you guys got a whole bunch
of really cool devices

00:00:18.400 --> 00:00:19.801
this morning.

00:00:19.801 --> 00:00:22.434
How many of you still have
charge left on your device?

00:00:22.434 --> 00:00:24.267
You still have
some battery life.

00:00:24.267 --> 00:00:26.267
Okay, there's still
some hands in the crowd.

00:00:26.267 --> 00:00:28.868
You might notice,
as you go through the day,

00:00:28.868 --> 00:00:30.434
you'll slowly watch
that battery life go down

00:00:30.434 --> 00:00:32.467
further and further,
and then the device will die.

00:00:32.467 --> 00:00:35.167
And that's something that
today we're gonna talk about--

00:00:35.167 --> 00:00:38.033
you as developers, as you're
writing these applications,

00:00:38.033 --> 00:00:40.033
writing third-party
applications,

00:00:40.033 --> 00:00:42.701
ways that you can make
that battery last longer...

00:00:42.701 --> 00:00:44.267
for your users
that are out on the field,

00:00:44.267 --> 00:00:46.067
not just for yourselves.

00:00:46.067 --> 00:00:47.834
So just wanted to mention
up front

00:00:47.834 --> 00:00:49.467
that as I go through
the talk today,

00:00:49.467 --> 00:00:51.067
if you guys have any questions,

00:00:51.067 --> 00:00:52.868
if they come to you
during the presentation--

00:00:52.868 --> 00:00:54.367
I'm using Google Moderator,

00:00:54.367 --> 00:00:56.067
so you should have
received links.

00:00:56.067 --> 00:00:57.667
There's links up on
the screen right there.

00:00:57.667 --> 00:01:01.801
The haveasec--I don't know
if that goes to the right one.

00:01:01.801 --> 00:01:03.868
But this link,
code.google.com,

00:01:03.868 --> 00:01:05.901
that'll link you guys
to the Moderator,

00:01:05.901 --> 00:01:07.601
and then at the end
of the talk.

00:01:07.601 --> 00:01:09.634
There's a couple questions
up there already,

00:01:09.634 --> 00:01:10.834
it looks like, on it.

00:01:10.834 --> 00:01:11.934
So I'll be switching
back and forth

00:01:11.934 --> 00:01:13.367
between the mikes
and the Moderator

00:01:13.367 --> 00:01:14.667
at the end of the session.

00:01:14.667 --> 00:01:16.801
So just a heads-up--
if you have questions, go ask,

00:01:16.801 --> 00:01:18.267
and also vote,
'cause that'll bubble up

00:01:18.267 --> 00:01:20.667
the important questions
to the top.

00:01:20.667 --> 00:01:23.334
All right, so battery life.
Why does it matter?

00:01:23.334 --> 00:01:25.367
Why does it matter
to the users that are out there?

00:01:25.367 --> 00:01:27.634
When we think of Android
devices, we typically--

00:01:27.634 --> 00:01:29.167
they're mostly phones right now.

00:01:29.167 --> 00:01:31.334
And these phones, they might
be on someone's nightstand,

00:01:31.334 --> 00:01:34.934
and then they take them out
for the rest of an entire day.

00:01:34.934 --> 00:01:37.000
They leave in the morning.
They unplug the device.

00:01:37.000 --> 00:01:38.834
And that device
may not see power,

00:01:38.834 --> 00:01:40.234
it may not see a charge,

00:01:40.234 --> 00:01:42.167
until that person gets home
late that night.

00:01:42.167 --> 00:01:44.033
So during the course of the day,

00:01:44.033 --> 00:01:47.000
the battery needs to power
the device.

00:01:47.000 --> 00:01:48.467
And the risk is

00:01:48.467 --> 00:01:51.100
that if the battery
runs out during the day,

00:01:51.100 --> 00:01:53.167
the user can't use
the device anymore.

00:01:53.167 --> 00:01:55.200
When the battery's gone,
it truly is gone.

00:01:55.200 --> 00:01:57.801
It's a sad state of affairs.

00:01:57.801 --> 00:02:00.133
So the apps needs to work
together to be good citizens

00:02:00.133 --> 00:02:01.868
of the battery
that's on the device,

00:02:01.868 --> 00:02:03.267
because you're
all running together.

00:02:03.267 --> 00:02:06.400
Your app is running alongside
Gmail and Maps

00:02:06.400 --> 00:02:09.200
and a lot of these other apps
on the device.

00:02:09.200 --> 00:02:11.567
So you need to work together
with those apps

00:02:11.567 --> 00:02:13.801
to be good citizens.

00:02:13.801 --> 00:02:15.734
Today I'll be throwing around
a bunch of different numbers,

00:02:15.734 --> 00:02:18.100
and I'll be using
two units of measurement.

00:02:18.100 --> 00:02:19.901
They're actually SI units.

00:02:19.901 --> 00:02:21.801
The first type of measurement

00:02:21.801 --> 00:02:23.868
I'll be talking about
is current,

00:02:23.868 --> 00:02:26.300
or typically
we think of this in amps,

00:02:26.300 --> 00:02:28.534
or milliamps is the unit
I'll be using today.

00:02:28.534 --> 00:02:31.868
So if you think--
current is a way of saying

00:02:31.868 --> 00:02:34.868
how fast we're consuming
the battery on the device

00:02:34.868 --> 00:02:36.667
or the rate of consumption.

00:02:36.667 --> 00:02:38.334
So when you're doing
a lot on the device,

00:02:38.334 --> 00:02:39.901
let's say you're watching
a YouTube video,

00:02:39.901 --> 00:02:42.767
you'll be pulling a lot
of milliamps on the device.

00:02:42.767 --> 00:02:44.767
The second number
I'll be mentioning

00:02:44.767 --> 00:02:47.567
is milliamp hours,
and that's a capacity.

00:02:47.567 --> 00:02:50.901
That's how much storage,
how much battery life

00:02:50.901 --> 00:02:52.968
we actually store
in the battery on the device

00:02:52.968 --> 00:02:55.000
when it is fully charged.

00:02:55.000 --> 00:02:56.767
So just some numbers
for comparison.

00:02:56.767 --> 00:02:58.367
If we think of the HTC Dream

00:02:58.367 --> 00:03:00.267
or the G1 device
that recently came out

00:03:00.267 --> 00:03:01.601
last Octoberish,

00:03:01.601 --> 00:03:05.334
it had a battery
of 1,150 milliamp hours.

00:03:05.334 --> 00:03:07.334
That was the capacity
that it could hold.

00:03:07.334 --> 00:03:09.267
The device that you guys
received today,

00:03:09.267 --> 00:03:12.067
the HTC Magic,
has a slightly larger battery,

00:03:12.067 --> 00:03:13.834
about 1,350.

00:03:13.834 --> 00:03:16.033
And another device that was
also recently announced

00:03:16.033 --> 00:03:17.400
in a press release,

00:03:17.400 --> 00:03:19.467
a Samsung device
that runs Android,

00:03:19.467 --> 00:03:22.601
and its battery
is about 1,500 milliamp hours.

00:03:22.601 --> 00:03:25.100
So something to realize between
all three of these devices

00:03:25.100 --> 00:03:28.801
is that they roughly have
the same battery--

00:03:28.801 --> 00:03:30.868
the same battery capacity.

00:03:30.868 --> 00:03:34.534
They're all in the same class.
It's roughly the same.

00:03:34.534 --> 00:03:37.300
And this is partially
an industrial design problem.

00:03:37.300 --> 00:03:38.868
When you're building a phone,

00:03:38.868 --> 00:03:41.000
you want to build something
that fits in someone's pocket.

00:03:41.000 --> 00:03:42.467
You don't want to build a device

00:03:42.467 --> 00:03:44.601
that they have to carry around
a 12-volt battery with them.

00:03:44.601 --> 00:03:46.267
[laughs]
You want to have a device

00:03:46.267 --> 00:03:47.868
that fits nicely
in their pocket.

00:03:47.868 --> 00:03:50.100
So you only have so much
room for a battery.

00:03:50.100 --> 00:03:52.501
And the way the technology
is progressing right now,

00:03:52.501 --> 00:03:53.834
we're looking forward to having

00:03:53.834 --> 00:03:55.267
better battery life
in the future,

00:03:55.267 --> 00:03:57.701
or better battery capacities.

00:03:57.701 --> 00:03:59.300
But for the moment,

00:03:59.300 --> 00:04:02.133
this is kind of
what we have to deal with.

00:04:02.133 --> 00:04:03.934
Just to compare
these capacities,

00:04:03.934 --> 00:04:07.100
something like a typical
laptop that you might see,

00:04:07.100 --> 00:04:09.033
like a Asus EEE PC,

00:04:09.033 --> 00:04:10.934
its battery is about
three or four times the size

00:04:10.934 --> 00:04:13.300
of what we're dealing with
on these mobile devices.

00:04:13.300 --> 00:04:16.033
It's about 5,800
milliamp hours.

00:04:16.033 --> 00:04:18.934
And that's about the same as
if you know a MacBook Pro,

00:04:18.934 --> 00:04:21.534
the battery in that's about
5,600 milliamp hours.

00:04:21.534 --> 00:04:25.000
So those are the types of
numbers that we're dealing with.

00:04:25.000 --> 00:04:28.100
So then we can ask the question,
we have the capacity,

00:04:28.100 --> 00:04:30.133
we have
the 1,150 milliamp hours--

00:04:30.133 --> 00:04:32.234
where does it all go
through the course of a day

00:04:32.234 --> 00:04:34.334
as the user's doing
different tasks?

00:04:34.334 --> 00:04:35.801
So this is just an overview.

00:04:35.801 --> 00:04:37.501
If we start over
on the left-hand side,

00:04:37.501 --> 00:04:39.033
if you have a device,
it's booted,

00:04:39.033 --> 00:04:40.467
but the screen's turned off.

00:04:40.467 --> 00:04:42.000
It's sitting on the table
completely idle.

00:04:42.000 --> 00:04:43.567
And it's in airplane mode.

00:04:43.567 --> 00:04:45.701
This means we've turned off
all the radios in the device.

00:04:45.701 --> 00:04:48.000
It takes about 2 milliamp hours

00:04:48.000 --> 00:04:50.067
or 2 milliamps of current
that it's pulling

00:04:50.067 --> 00:04:52.133
just to sit there waiting
for the user to wake it up--

00:04:52.133 --> 00:04:55.033
waiting for a user to wake it up
and interact with it.

00:04:55.033 --> 00:04:56.901
If we add in one of
the radio connections--

00:04:56.901 --> 00:04:59.200
let's say if we have an EDGE
or a 3G connection

00:04:59.200 --> 00:05:02.434
just sitting idle--it takes
a slightly little bit more.

00:05:02.434 --> 00:05:04.734
It's about 5 milliamps
that the device is pulling

00:05:04.734 --> 00:05:06.501
just sitting there idle.

00:05:06.501 --> 00:05:08.067
On WiFi,
it costs a little bit more,

00:05:08.067 --> 00:05:11.200
about 12 milliamps
of current that it's pulling.

00:05:11.200 --> 00:05:14.000
As soon as the user begins
interacting with the device,

00:05:14.000 --> 00:05:15.801
this is where
we see the jump.

00:05:15.801 --> 00:05:17.767
Just turning on the LCD
on the device

00:05:17.767 --> 00:05:19.467
to display something
to the user

00:05:19.467 --> 00:05:21.734
ends up taking
90 milliamps of battery.

00:05:21.734 --> 00:05:23.534
So anytime the screen is on,

00:05:23.534 --> 00:05:25.901
that's the amount of current
that the screen is pulling.

00:05:25.901 --> 00:05:28.067
And as soon as we start
adding in things like CPU...

00:05:28.067 --> 00:05:30.334
if you're doing 50%
or 100% CPU--

00:05:30.334 --> 00:05:33.968
so 100% CPU on top of
the screen already being on,

00:05:33.968 --> 00:05:35.767
so this is the blue
specific item--

00:05:35.767 --> 00:05:37.467
on top of the screen being
turned on,

00:05:37.467 --> 00:05:41.334
100% CPU ends up being
110 milliamps

00:05:41.334 --> 00:05:44.033
to run the CPU
at full speed.

00:05:44.033 --> 00:05:46.100
Something if you're looking
at writing a game,

00:05:46.100 --> 00:05:47.601
running the game sensor,

00:05:47.601 --> 00:05:48.868
so the accelerometer
on the device,

00:05:48.868 --> 00:05:50.767
this takes something like
80 milliamps

00:05:50.767 --> 00:05:52.300
of current
that you're pulling.

00:05:52.300 --> 00:05:55.734
If you're trying to get
a GPS fix using the GPS radio,

00:05:55.734 --> 00:05:58.367
that ends up taking another
80 or 85 milliamps

00:05:58.367 --> 00:06:00.467
that that radio is pulling.

00:06:00.467 --> 00:06:02.734
And then finally we get
to the data on the device,

00:06:02.734 --> 00:06:04.334
when you have a data radio
turned on

00:06:04.334 --> 00:06:06.234
and you're doing data transfer.

00:06:06.234 --> 00:06:08.801
So these numbers
are full-bore.

00:06:08.801 --> 00:06:11.133
We're transferring as much data
as we possibly can.

00:06:11.133 --> 00:06:12.968
So this is--we're stressing
the radio out,

00:06:12.968 --> 00:06:15.000
we're doing
lots of data transfer.

00:06:15.000 --> 00:06:16.334
So something like this.

00:06:16.334 --> 00:06:18.567
The 3G radio is actually
pretty cheap in the device.

00:06:18.567 --> 00:06:21.300
It ends up costing
about 150 milliamps

00:06:21.300 --> 00:06:24.033
just to run the 3G radio
full-bore

00:06:24.033 --> 00:06:26.334
so that you're transferring
a lot of data.

00:06:26.334 --> 00:06:27.801
On an EDGE connection,

00:06:27.801 --> 00:06:31.267
it costs about 250 milliamps
to run that radio at full-speed.

00:06:31.267 --> 00:06:33.400
And then finally, WiFi,
which costs the most.

00:06:33.400 --> 00:06:38.534
It's about 275 milliamps
to run that at full-speed.

00:06:38.534 --> 00:06:40.400
So now that we know
where it actually goes,

00:06:40.400 --> 00:06:41.534
let's compare those numbers.

00:06:41.534 --> 00:06:43.100
Let's take a moment
and step back

00:06:43.100 --> 00:06:45.133
and think,
do these numbers make sense?

00:06:45.133 --> 00:06:48.200
Do these match up with
the real life battery statistics

00:06:48.200 --> 00:06:49.534
we're seeing in the field?

00:06:49.534 --> 00:06:51.100
So let's take
a couple of examples.

00:06:51.100 --> 00:06:52.901
Let's say you're watching
a YouTube video.

00:06:52.901 --> 00:06:55.334
So this is something--
we're watching it on 3G.

00:06:55.334 --> 00:06:56.801
So we have the 3G radio
spun up.

00:06:56.801 --> 00:06:58.667
We're doing a good amount
of data transfer.

00:06:58.667 --> 00:07:00.033
We're transferring video.

00:07:00.033 --> 00:07:01.400
The CPU's doing a lot of work.

00:07:01.400 --> 00:07:02.767
It's decoding the video

00:07:02.767 --> 00:07:04.234
and then putting it
on the screen for the user.

00:07:04.234 --> 00:07:05.767
And then they have
the LCD on.

00:07:05.767 --> 00:07:07.901
So in total,
watching a YouTube video,

00:07:07.901 --> 00:07:10.701
it's pulling about
340 milliamps of current.

00:07:10.701 --> 00:07:13.434
That's how much current
it's using to show the video.

00:07:13.434 --> 00:07:15.734
And so we have those
two units of measurement,

00:07:15.734 --> 00:07:18.200
or those two units,

00:07:18.200 --> 00:07:20.968
and we can divide it
by the capacity in the device,

00:07:20.968 --> 00:07:23.734
and we can figure out how long
the device should last,

00:07:23.734 --> 00:07:26.200
the expected life
of the device.

00:07:26.200 --> 00:07:27.834
So something playing
a YouTube video,

00:07:27.834 --> 00:07:31.033
at 1,150 milliamp hours,
the capacity in the battery

00:07:31.033 --> 00:07:34.434
should last us about
3 1/2 hours of actual use,

00:07:34.434 --> 00:07:37.234
of the person, if they watched
YouTube video continuously.

00:07:37.234 --> 00:07:40.334
Something a little more
typical--browsing the 3G web.

00:07:40.334 --> 00:07:41.567
So it's a little bit cheaper.

00:07:41.567 --> 00:07:43.067
We're not doing as much
data transfer.

00:07:43.067 --> 00:07:44.834
It's about 225 milliamps

00:07:44.834 --> 00:07:47.133
or about
five hours of battery life.

00:07:47.133 --> 00:07:49.000
So that's if the user's
sitting there

00:07:49.000 --> 00:07:52.434
interacting with the device
solid for three or four hours.

00:07:52.434 --> 00:07:53.968
A more typical use case

00:07:53.968 --> 00:07:55.701
is that they pull it
out of their pocket

00:07:55.701 --> 00:07:57.567
maybe once or twice an hour.

00:07:57.567 --> 00:07:59.300
They're not interacting
with it very much.

00:07:59.300 --> 00:08:00.901
Most of the time
it's in their pocket.

00:08:00.901 --> 00:08:02.901
So a typical use case,
we can think of

00:08:02.901 --> 00:08:04.467
the device being turned on

00:08:04.467 --> 00:08:06.567
about ten minutes
out of every hour.

00:08:06.567 --> 00:08:08.767
So we have the device turned on
and doing activities

00:08:08.767 --> 00:08:10.167
for about ten minutes,

00:08:10.167 --> 00:08:12.133
and the other 50 minutes
of that hour,

00:08:12.133 --> 00:08:13.734
the device
is in the person's pocket.

00:08:13.734 --> 00:08:14.901
It's asleep.

00:08:14.901 --> 00:08:18.000
It's using
very little current.

00:08:18.000 --> 00:08:19.601
So if we average that out,

00:08:19.601 --> 00:08:22.367
it's about 42 milliamps
on average, over an hour.

00:08:22.367 --> 00:08:24.934
So if we do the computation,
that battery life ends up--

00:08:24.934 --> 00:08:26.634
the battery life
in that case

00:08:26.634 --> 00:08:28.767
ends up being about
32 hours.

00:08:28.767 --> 00:08:30.934
And that's fairly typical.

00:08:30.934 --> 00:08:32.734
That's usually what we're seeing
from people out in the field

00:08:32.734 --> 00:08:34.400
that are using G1 devices.

00:08:34.400 --> 00:08:37.400
They usually see a battery life
that lasts them about a day.

00:08:37.400 --> 00:08:39.934
So then let's take a look at
the other end of the spectrum.

00:08:39.934 --> 00:08:41.100
Let's say we have a device

00:08:41.100 --> 00:08:42.767
that's just sitting there
completely idle.

00:08:42.767 --> 00:08:44.934
The user isn't interacting
with it at all.

00:08:44.934 --> 00:08:48.400
So the number that we measured
earlier was 5 milliamps.

00:08:48.400 --> 00:08:50.567
That's the amount of current
that it was pulling.

00:08:50.567 --> 00:08:53.000
If we do the math--
the 1,150 milliamp hours,

00:08:53.000 --> 00:08:54.534
the capacity of the battery,

00:08:54.534 --> 00:08:56.734
should last us
about 9 1/2 days

00:08:56.734 --> 00:08:58.267
and even further

00:08:58.267 --> 00:08:59.801
if we have the device
in an airplane mode.

00:08:59.801 --> 00:09:01.434
So all the radios
are turned off,

00:09:01.434 --> 00:09:02.834
we're only pulling
that 2 milliamps,

00:09:02.834 --> 00:09:04.467
it should last about
24 days.

00:09:04.467 --> 00:09:06.534
Then we can ask the question,

00:09:06.534 --> 00:09:08.400
where did
all that battery life go?

00:09:08.400 --> 00:09:09.701
What's happening
in between?

00:09:09.701 --> 00:09:11.400
What costs the most?

00:09:11.400 --> 00:09:12.667
What are we doing
in the background

00:09:12.667 --> 00:09:14.534
that's using
all of that battery,

00:09:14.534 --> 00:09:16.634
all of that capacity
that the phone could use

00:09:16.634 --> 00:09:20.834
to last longer?

00:09:24.534 --> 00:09:27.534
So we can ask the question,
what costs the most?

00:09:27.534 --> 00:09:29.367
And the first thing
at the top of the list

00:09:29.367 --> 00:09:31.167
is waking up in the background,

00:09:31.167 --> 00:09:33.501
and this is when the phone
would otherwise be asleep

00:09:33.501 --> 00:09:35.033
in your pocket.

00:09:35.033 --> 00:09:36.701
You can have background tasks
that wake up

00:09:36.701 --> 00:09:39.400
to go check the person's email,
say every 15 or 20 minutes

00:09:39.400 --> 00:09:41.601
or every half hour.

00:09:41.601 --> 00:09:43.400
Or maybe an incoming email
comes in

00:09:43.400 --> 00:09:46.133
and needs to do
some network activity.

00:09:46.133 --> 00:09:48.868
Things that the device
wakes up to do in the background

00:09:48.868 --> 00:09:50.567
when it would
otherwise be asleep

00:09:50.567 --> 00:09:53.601
end up costing a lot
towards battery life.

00:09:53.601 --> 00:09:55.467
So let's take
a typical example.

00:09:55.467 --> 00:09:58.701
Let's say you're writing
an app that checks RSS feeds

00:09:58.701 --> 00:10:00.300
for new incoming posts.

00:10:00.300 --> 00:10:02.133
And let's check
every ten minutes.

00:10:02.133 --> 00:10:05.033
So this is just an example app
just for the sake of example.

00:10:05.033 --> 00:10:06.567
And when it wakes up
in the background,

00:10:06.567 --> 00:10:08.100
it probably takes
about eight seconds

00:10:08.100 --> 00:10:09.334
to perform a full update.

00:10:09.334 --> 00:10:10.434
When you think of it,

00:10:10.434 --> 00:10:11.801
we're pulling up
the radio stack,

00:10:11.801 --> 00:10:13.167
we're going and we're doing
a DNS request,

00:10:13.167 --> 00:10:14.601
doing a network connection,

00:10:14.601 --> 00:10:16.868
pulling down the page,
doing parsing on the device.

00:10:16.868 --> 00:10:18.300
And then it takes a few seconds

00:10:18.300 --> 00:10:19.868
for the device
to settle back down

00:10:19.868 --> 00:10:22.934
and fall into
a sleep mode again.

00:10:22.934 --> 00:10:25.434
So about eight seconds.

00:10:25.434 --> 00:10:27.367
And the battery usage
during that period

00:10:27.367 --> 00:10:30.467
is about 300--
let's say 350 milliamps.

00:10:30.467 --> 00:10:31.868
We don't have the screen on,

00:10:31.868 --> 00:10:34.601
but we're using a lot of data
and a lot of CPU.

00:10:34.601 --> 00:10:36.701
So now let's take a look

00:10:36.701 --> 00:10:40.534
at what this would cost
during a given hour.

00:10:40.534 --> 00:10:42.133
So the idle cost,

00:10:42.133 --> 00:10:44.467
if the device was completely
idle for that hour,

00:10:44.467 --> 00:10:46.167
it would cost us about
5 milliamp hours.

00:10:46.167 --> 00:10:47.634
That's the cost of the device

00:10:47.634 --> 00:10:49.133
just sitting there
completely idle.

00:10:49.133 --> 00:10:50.767
But as soon as we add in
this application

00:10:50.767 --> 00:10:52.567
that's waking up
in the background,

00:10:52.567 --> 00:10:54.067
doing these seemingly innocent--

00:10:54.067 --> 00:10:56.000
just going out and checking,
checking in our assess feed,

00:10:56.000 --> 00:10:58.467
we do the math--
six times every ten minutes,

00:10:58.467 --> 00:11:01.000
six times an hour times the
eight seconds for each update,

00:11:01.000 --> 00:11:02.868
times the 350 milliamps.

00:11:02.868 --> 00:11:04.667
The amount of current
that we're using there

00:11:04.667 --> 00:11:06.400
is about 4.6 milliamp hours.

00:11:06.400 --> 00:11:10.367
That's the amount that we're
taking for this app to run.

00:11:10.367 --> 00:11:12.167
So just this small,
innocent app

00:11:12.167 --> 00:11:15.434
is actually cutting
the user's battery life in half.

00:11:15.434 --> 00:11:17.567
And that's really something
to realize.

00:11:17.567 --> 00:11:19.634
Apps like these are waking up,

00:11:19.634 --> 00:11:22.100
and they can start using
a lot of the user's battery

00:11:22.100 --> 00:11:23.367
without them even knowing.

00:11:23.367 --> 00:11:25.934
They think the device is turned
off and in their pocket.

00:11:25.934 --> 00:11:27.601
And another thing to realize

00:11:27.601 --> 00:11:29.200
is that these apps waking up,

00:11:29.200 --> 00:11:31.567
it's not just your update
that might happen.

00:11:31.567 --> 00:11:34.067
On the system,
we have a notion of services

00:11:34.067 --> 00:11:35.434
that can only wake up,

00:11:35.434 --> 00:11:37.267
that can set alarms
for themselves,

00:11:37.267 --> 00:11:39.868
that only wake up when
the device is already awake.

00:11:39.868 --> 00:11:43.334
So if the device--if you
force the device awake,

00:11:43.334 --> 00:11:45.534
other services may piggyback

00:11:45.534 --> 00:11:47.667
on top of your waking up
of the device.

00:11:47.667 --> 00:11:51.501
So it actually--
it compounds itself.

00:11:51.501 --> 00:11:54.167
Other apps jump on,
and you can cascade a trigger--

00:11:54.167 --> 00:11:56.968
or you can trigger a cascade
of several of these updates

00:11:56.968 --> 00:11:58.701
all happening
at the same time.

00:11:58.701 --> 00:12:00.467
So it might not just be
your eight seconds.

00:12:00.467 --> 00:12:02.000
If you wake up
for your eight seconds,

00:12:02.000 --> 00:12:04.901
you might end up forcing
the phone awake

00:12:04.901 --> 00:12:06.501
for 15 or 20 seconds

00:12:06.501 --> 00:12:10.968
as other apps try to pile on
and do their updates as well.

00:12:14.634 --> 00:12:16.834
[coughs]

00:12:16.834 --> 00:12:18.367
So what else
costs the most?

00:12:18.367 --> 00:12:21.367
Another thing that costs a lot
is bulk data transfer.

00:12:21.367 --> 00:12:23.834
So we have phones
with data connections.

00:12:23.834 --> 00:12:26.400
You can think of them
transferring bulk data.

00:12:26.400 --> 00:12:28.534
We have people that are
watching videos on YouTube.

00:12:28.534 --> 00:12:30.300
We have people
that are generating content.

00:12:30.300 --> 00:12:31.734
They're taking pictures
and videos,

00:12:31.734 --> 00:12:33.300
and they want to upload those.

00:12:33.300 --> 00:12:35.667
So we have heavy data traffic
in both directions.

00:12:35.667 --> 00:12:37.267
And it ends up
that bulk data transfer

00:12:37.267 --> 00:12:38.767
can actually cost a lot

00:12:38.767 --> 00:12:40.734
towards the life
of a person's battery.

00:12:40.734 --> 00:12:43.334
So if we look at three different
types of data connections

00:12:43.334 --> 00:12:45.434
that are available
on the phone today,

00:12:45.434 --> 00:12:48.634
we have an EDGE connection,
a 3G, and a WiFi connection.

00:12:48.634 --> 00:12:51.000
And they all cost roughly
about the same,

00:12:51.000 --> 00:12:54.567
anywhere from 210
to 330 milliamps.

00:12:54.567 --> 00:12:56.000
Those numbers
are slightly different

00:12:56.000 --> 00:12:58.434
'cause we're including CPU
in those numbers

00:12:58.434 --> 00:13:00.067
from the numbers
that I mentioned earlier.

00:13:00.067 --> 00:13:01.701
That's why
they're slightly different.

00:13:01.701 --> 00:13:03.834
So they all cost roughly
in the same ballpark

00:13:03.834 --> 00:13:05.067
to run those data connections.

00:13:05.067 --> 00:13:06.601
The key differentiator

00:13:06.601 --> 00:13:08.501
is that they can transfer
at different rates.

00:13:08.501 --> 00:13:10.434
A 3G connection
is a lot more efficient.

00:13:10.434 --> 00:13:13.000
It can transfer data a lot
faster than an EDGE connection.

00:13:13.000 --> 00:13:14.501
Or even if you're familiar,

00:13:14.501 --> 00:13:16.434
there's a notion of
a GPRS connection

00:13:16.434 --> 00:13:18.734
which is even slower
than EDGE--

00:13:18.734 --> 00:13:20.567
which is
even slower than EDGE,

00:13:20.567 --> 00:13:22.868
whereas WiFi can transfer
stuff a lot faster.

00:13:22.868 --> 00:13:25.501
So let's take an example
of a 6 megabyte song.

00:13:25.501 --> 00:13:27.968
You're writing a music store
application

00:13:27.968 --> 00:13:29.434
for a person
to go buy music,

00:13:29.434 --> 00:13:31.601
and you need to transfer
6 megabytes down to the phone.

00:13:31.601 --> 00:13:33.334
This is just bulk data transfer.

00:13:33.334 --> 00:13:35.133
We can do the math,
and we can figure out

00:13:35.133 --> 00:13:37.000
how long it would take
in each of those cases.

00:13:37.000 --> 00:13:40.334
To do that transfer on EDGE,
it takes about nine minutes.

00:13:40.334 --> 00:13:42.234
But to do it on WiFi,
which is a lot faster,

00:13:42.234 --> 00:13:46.234
it takes under a minute,
about 46, 48 seconds.

00:13:46.234 --> 00:13:48.634
But then, consider
that we have to multiply that

00:13:48.634 --> 00:13:52.234
by how much the battery
is being used over that time.

00:13:52.234 --> 00:13:54.901
So something like an EDGE
transfer, the nine minutes,

00:13:54.901 --> 00:13:57.501
ends up costing us
45 milliamp hours.

00:13:57.501 --> 00:14:00.334
That's how much battery we're
using to do that data transfer.

00:14:00.334 --> 00:14:03.200
That same data transfer,
that same 6 megabytes

00:14:03.200 --> 00:14:05.767
would cost us
an order of magnitude less

00:14:05.767 --> 00:14:07.300
if we did it over WiFi,

00:14:07.300 --> 00:14:10.067
if we waited around
to get a faster connection.

00:14:10.067 --> 00:14:12.901
It costs only less than
5 milliamp hours.

00:14:12.901 --> 00:14:16.801
So it's less than 10%
of the original cost.

00:14:16.801 --> 00:14:18.534
Other things
that end up costing a lot

00:14:18.534 --> 00:14:20.501
are moving between
cells and networks.

00:14:20.501 --> 00:14:22.300
So as the phone--
you can think of a phone,

00:14:22.300 --> 00:14:24.501
as a person commutes with it
different locations,

00:14:24.501 --> 00:14:27.968
the phone radio ramps up
to associate with new cells.

00:14:27.968 --> 00:14:30.234
So as I drove here
this morning on a bus,

00:14:30.234 --> 00:14:33.067
my phone transferred between
multiple cell towers

00:14:33.067 --> 00:14:34.501
as I went along the road,

00:14:34.501 --> 00:14:37.501
if you're riding Caltrain
or something like that.

00:14:37.501 --> 00:14:40.100
So this is something
we can't avoid,

00:14:40.100 --> 00:14:42.634
the radio chipset needs to
wake up and be always associated

00:14:42.634 --> 00:14:44.567
so that the user can receive
incoming text

00:14:44.567 --> 00:14:46.100
and incoming phone calls.

00:14:46.100 --> 00:14:47.901
But on Android,
we also wake up the system

00:14:47.901 --> 00:14:49.100
to possibly deal--

00:14:49.100 --> 00:14:50.501
Maybe your app,
maybe an app on the system

00:14:50.501 --> 00:14:52.634
is interested
when the connectivity changes.

00:14:52.634 --> 00:14:54.300
For example,
if you have a photo

00:14:54.300 --> 00:14:56.100
that the user
wanted to upload,

00:14:56.100 --> 00:14:57.901
you might want to check to see

00:14:57.901 --> 00:14:59.567
if the network connection
goes up and down.

00:14:59.567 --> 00:15:01.234
So if the network connection
comes back up,

00:15:01.234 --> 00:15:02.767
you may want to finish
uploading your video.

00:15:02.767 --> 00:15:04.567
So we actually--
the Android operating system

00:15:04.567 --> 00:15:07.801
allows us to wake up
applications in the background

00:15:07.801 --> 00:15:09.834
using the notion
of broadcast intents.

00:15:09.834 --> 00:15:11.133
I'll get into that
a little bit later,

00:15:11.133 --> 00:15:13.467
but those actually
cost a lot towards battery,

00:15:13.467 --> 00:15:16.100
especially when we're waking up
those applications

00:15:16.100 --> 00:15:17.601
and they aren't
going to do anything.

00:15:17.601 --> 00:15:19.968
If we wake it up to tell it
network connectivity changed

00:15:19.968 --> 00:15:22.567
and it decides,
"I don't need to do anything,"

00:15:22.567 --> 00:15:24.767
it can end up costing a lot.

00:15:24.767 --> 00:15:27.534
Two other things in the end
that end up costing a lot

00:15:27.534 --> 00:15:28.934
are textual data.

00:15:28.934 --> 00:15:32.133
So if we're receiving
that RSS feed down from XML,

00:15:32.133 --> 00:15:33.701
parsing that on the device

00:15:33.701 --> 00:15:35.067
can actually be
really expensive.

00:15:35.067 --> 00:15:36.634
We're walking through
the text data,

00:15:36.634 --> 00:15:37.868
we're trying to parse it.

00:15:37.868 --> 00:15:39.968
You can think of all
the different data formats

00:15:39.968 --> 00:15:41.367
that you might have out there,

00:15:41.367 --> 00:15:44.167
XML or JSON or even YAML,
Yet Another Markup Language,

00:15:44.167 --> 00:15:47.601
which is--its structure
is based on spaces,

00:15:47.601 --> 00:15:50.300
so there's a lot of textual data
that it has to parse through.

00:15:50.300 --> 00:15:52.434
So parsing through text data
that comes from the web

00:15:52.434 --> 00:15:53.868
can be really expensive,

00:15:53.868 --> 00:15:55.968
and I'll touch on that
a little bit later

00:15:55.968 --> 00:15:57.167
the differences between them.

00:15:57.167 --> 00:15:58.567
And finally, another thing

00:15:58.567 --> 00:16:00.033
that ends up costing a lot
on the device

00:16:00.033 --> 00:16:02.567
is regular expressions,
especially on Android.

00:16:02.567 --> 00:16:04.234
So the current virtual
machine that we're using,

00:16:04.234 --> 00:16:08.167
the Dalvik VM, doesn't have
just-in-time compiling,

00:16:08.167 --> 00:16:11.334
which is a luxury
that a lot of people are used to

00:16:11.334 --> 00:16:12.934
from the desktop world.

00:16:12.934 --> 00:16:14.634
So in a desktop
virtual machine,

00:16:14.634 --> 00:16:16.434
if we run into
a regular expression,

00:16:16.434 --> 00:16:19.367
the desktop machine can actually
compile a regular expression

00:16:19.367 --> 00:16:23.033
into really fast, tight code
that runs very efficiently.

00:16:23.033 --> 00:16:25.534
But on a platform like Android,

00:16:25.534 --> 00:16:26.834
the current virtual machine

00:16:26.834 --> 00:16:28.501
that doesn't support
just-in-time compiling,

00:16:28.501 --> 00:16:29.834
this can actually be
pretty expensive.

00:16:29.834 --> 00:16:32.601
It can't optimize that
just yet.

00:16:32.601 --> 00:16:35.934
So those are some things
to be aware of.

00:16:40.934 --> 00:16:42.367
So then we can ask
the question--

00:16:42.367 --> 00:16:44.801
we know what the battery
capacity that we're looking at.

00:16:44.801 --> 00:16:46.434
We know what things cost.

00:16:46.434 --> 00:16:47.734
And now we know

00:16:47.734 --> 00:16:49.367
what things actually
cost a lot on the device.

00:16:49.367 --> 00:16:51.501
So how can we do better
as we're developers,

00:16:51.501 --> 00:16:53.267
as we're out there
writing apps?

00:16:53.267 --> 00:16:55.501
Today I'll be splitting this up
into three separate sections.

00:16:55.501 --> 00:16:58.534
We're gonna talk first about
foreground applications.

00:16:58.534 --> 00:17:00.934
First we'll talk about
networking,

00:17:00.934 --> 00:17:03.968
then foreground apps,
and finally background apps.

00:17:03.968 --> 00:17:05.934
So first, networking.

00:17:05.934 --> 00:17:07.467
Check the network connection.

00:17:07.467 --> 00:17:09.234
So this comes back
to you're about to do

00:17:09.234 --> 00:17:11.033
a set of bulk data transfers.

00:17:11.033 --> 00:17:12.701
You have that 6 megabyte song

00:17:12.701 --> 00:17:14.367
that the user
wants to have downloaded.

00:17:14.367 --> 00:17:16.200
Something that you can do
as a developer

00:17:16.200 --> 00:17:18.367
is you can check
the current network connection

00:17:18.367 --> 00:17:20.434
that the user is on,
that the device is on.

00:17:20.434 --> 00:17:21.801
So for example,

00:17:21.801 --> 00:17:23.467
if you know you need
to download a lot of data,

00:17:23.467 --> 00:17:24.834
maybe you'll hold off
on that transfer

00:17:24.834 --> 00:17:27.667
until the user comes into
an area with 3G coverage

00:17:27.667 --> 00:17:29.501
or they connect
to a WiFi network.

00:17:29.501 --> 00:17:31.734
So this is a quick
code snippet example

00:17:31.734 --> 00:17:33.367
that...Android makes it
really easy

00:17:33.367 --> 00:17:35.501
to check to see what kind
of network you're on.

00:17:35.501 --> 00:17:38.501
So I skipped past it.
It was on the first slide here.

00:17:38.501 --> 00:17:40.000
There's a notion
of a connectivity

00:17:40.000 --> 00:17:41.467
and a telephony manager

00:17:41.467 --> 00:17:44.033
that you can get references to
if you have a context in Java.

00:17:44.033 --> 00:17:46.734
So with
the connectivity manager,

00:17:46.734 --> 00:17:48.868
we can get an instance
of the current network info,

00:17:48.868 --> 00:17:50.501
and that's what
this info object is.

00:17:50.501 --> 00:17:51.734
And we can probe it.

00:17:51.734 --> 00:17:54.133
We can ask it what type
of network we're on,

00:17:54.133 --> 00:17:56.734
that the user is currently on,
what subtype of network.

00:17:56.734 --> 00:17:58.400
And then we can do
some pretty quick logic

00:17:58.400 --> 00:18:01.234
to check to see if we should
actually perform a transfer.

00:18:01.234 --> 00:18:02.767
So in this case,
the first if block

00:18:02.767 --> 00:18:05.033
is checking to see
if we're on a network connection

00:18:05.033 --> 00:18:06.400
of type WiFi,

00:18:06.400 --> 00:18:09.567
and if that's the type
that's currently enabled

00:18:09.567 --> 00:18:11.501
and we're connected
to that network, return true.

00:18:11.501 --> 00:18:13.400
Let's actually perform
the data transfer,

00:18:13.400 --> 00:18:14.400
'cause WiFi's fast.

00:18:14.400 --> 00:18:16.000
It'll be cheap.

00:18:16.000 --> 00:18:17.901
Otherwise, if we're on
a mobile network...

00:18:17.901 --> 00:18:20.234
let's check to see
if we're on a 3G network.

00:18:20.234 --> 00:18:22.200
Another name for this
is UMTS.

00:18:22.200 --> 00:18:24.434
There's several different
3G technologies,

00:18:24.434 --> 00:18:26.634
but this is the one
that we have the constants for

00:18:26.634 --> 00:18:28.234
in the platform right now.

00:18:28.234 --> 00:18:30.467
And finally, one other thing
that you can do as developers

00:18:30.467 --> 00:18:31.767
is you might be smart--

00:18:31.767 --> 00:18:34.133
you might check to see
if the user's roaming.

00:18:34.133 --> 00:18:36.667
Roaming data can end up
costing users a lot,

00:18:36.667 --> 00:18:38.601
so if this is just something
in the background

00:18:38.601 --> 00:18:41.667
and you're offering to download
music for the user,

00:18:41.667 --> 00:18:43.267
this can end up costing a lot,

00:18:43.267 --> 00:18:45.534
especially not only time
and battery-wise,

00:18:45.534 --> 00:18:47.033
but monetarily,

00:18:47.033 --> 00:18:48.834
when they get their bill
at the end of the month.

00:18:48.834 --> 00:18:51.267
So this is just one of those
flags that we can check to see

00:18:51.267 --> 00:18:52.834
is the network roaming,

00:18:52.834 --> 00:18:56.334
some stuff that we can check
to help our users in the end.

00:18:56.334 --> 00:18:58.267
So if that returns true,
we can go ahead

00:18:58.267 --> 00:19:00.067
if we're actually connected
to a 3G network

00:19:00.067 --> 00:19:01.467
and we're not roaming.

00:19:01.467 --> 00:19:03.300
Otherwise,
we can return false.

00:19:03.300 --> 00:19:05.167
Some other choices here too.

00:19:05.167 --> 00:19:06.767
Instead of
just returning false,

00:19:06.767 --> 00:19:09.367
you might choose to involve
the user in the process.

00:19:09.367 --> 00:19:12.334
So if the user takes a video
and they wanna upload it online,

00:19:12.334 --> 00:19:14.234
if you know that you're
on an EDGE connection,

00:19:14.234 --> 00:19:15.901
you might actually
do the math--

00:19:15.901 --> 00:19:19.334
do some quick math
in the code to see:

00:19:19.334 --> 00:19:22.634
would I be able to transfer
this without killing the device?

00:19:22.634 --> 00:19:24.567
Is there enough
battery life left?

00:19:24.567 --> 00:19:26.033
And you might involve
the user in the process

00:19:26.033 --> 00:19:27.734
and just tell them,
transferring this file--

00:19:27.734 --> 00:19:29.567
transferring this raw data
over EDGE--

00:19:29.567 --> 00:19:31.234
is gonna cost you a lot.

00:19:31.234 --> 00:19:32.834
You might actually lose
your device,

00:19:32.834 --> 00:19:34.701
because it would suck
all the battery life

00:19:34.701 --> 00:19:36.901
out of your device,
and I may not even finish.

00:19:36.901 --> 00:19:38.634
And you might ask the user

00:19:38.634 --> 00:19:40.434
if they really want
to go ahead with that.

00:19:40.434 --> 00:19:43.467
So instead of just
blanketedly canceling,

00:19:43.467 --> 00:19:44.801
you might involve them
with that process

00:19:44.801 --> 00:19:46.234
and allow them
to override it,

00:19:46.234 --> 00:19:48.067
'cause there's certain
instances where they may

00:19:48.067 --> 00:19:50.400
really want photos
to be uploaded right away.

00:19:50.400 --> 00:19:51.968
It also allows them
to be aware of--

00:19:51.968 --> 00:19:53.234
so if they're on
an EDGE connection

00:19:53.234 --> 00:19:54.634
and you inform them,

00:19:54.634 --> 00:19:56.901
they might know of
a WiFi hotspot down the street

00:19:56.901 --> 00:19:58.300
that they can go connect to.

00:19:58.300 --> 00:20:00.300
So involving them
in that process can really--

00:20:00.300 --> 00:20:03.267
you're helping them
save battery.

00:20:03.267 --> 00:20:05.100
One other thing
that we can check.

00:20:05.100 --> 00:20:06.934
So this is jumping back
a slide.

00:20:06.934 --> 00:20:10.200
In the Settings app right now,
Settings and Synchronization,

00:20:10.200 --> 00:20:11.767
there's a check box in there,

00:20:11.767 --> 00:20:13.834
and the user can change
the preference

00:20:13.834 --> 00:20:15.501
for using background data.

00:20:15.501 --> 00:20:19.901
Right now, all of the Google
services that are on the device

00:20:19.901 --> 00:20:21.434
look at that check box,

00:20:21.434 --> 00:20:24.000
and that's how they figure out
what the user wants to do

00:20:24.000 --> 00:20:26.968
as far as data happening
in the background on the device.

00:20:26.968 --> 00:20:29.167
So if the user un-checks
that box,

00:20:29.167 --> 00:20:31.200
the Google services
will actually turn off,

00:20:31.200 --> 00:20:33.467
and they will only synchronize
if the user goes into the app

00:20:33.467 --> 00:20:34.734
and forces it,

00:20:34.734 --> 00:20:36.868
or if they come back
and turn on this check box.

00:20:36.868 --> 00:20:38.234
So this is something
you as developers

00:20:38.234 --> 00:20:39.501
can also run in a check.

00:20:39.501 --> 00:20:41.000
If you have
a connectivity manager object,

00:20:41.000 --> 00:20:43.000
you can check to see
the state of that flag.

00:20:43.000 --> 00:20:44.901
And this is something
that's new in Cupcake.

00:20:44.901 --> 00:20:46.634
And I'll be mentioning
a couple of features

00:20:46.634 --> 00:20:48.734
that have come out
in the Cupcake

00:20:48.734 --> 00:20:50.767
or the 1.5 SDK
that recently came out,

00:20:50.767 --> 00:20:52.033
and I'll just indicate them

00:20:52.033 --> 00:20:53.334
with a little icon over there
on the right.

00:20:53.334 --> 00:20:54.901
So that's just something
to be aware of

00:20:54.901 --> 00:20:56.701
as we go through the rest
of the presentation today.

00:21:02.834 --> 00:21:04.567
So we talked about...

00:21:04.567 --> 00:21:06.734
we talked about
bulk data transfer

00:21:06.734 --> 00:21:09.067
involving the user
in that process.

00:21:09.067 --> 00:21:11.033
One of the other things
that can cost us a lot

00:21:11.033 --> 00:21:13.300
networking-wise
is doing textual data,

00:21:13.300 --> 00:21:15.701
is transferring and parsing
that text data.

00:21:15.701 --> 00:21:17.868
And as developers, we have
a lot of different choices.

00:21:17.868 --> 00:21:19.868
A lot of us have
a favored data format

00:21:19.868 --> 00:21:21.701
that we like pushing stuff
across the web.

00:21:21.701 --> 00:21:26.234
If you come from a restful
approach of doing web services,

00:21:26.234 --> 00:21:28.067
maybe you're used to XML.

00:21:28.067 --> 00:21:30.968
Or maybe you wrap your data
in a JSON format.

00:21:30.968 --> 00:21:32.934
Or maybe you're used to other
different formats

00:21:32.934 --> 00:21:35.234
such as YAML,
Yet Another Markup Language,

00:21:35.234 --> 00:21:37.133
or some of
these other formats.

00:21:37.133 --> 00:21:40.601
Another popular protocol--
or another popular data format

00:21:40.601 --> 00:21:42.334
for passing stuff
across the web

00:21:42.334 --> 00:21:44.033
is using a binary format.

00:21:44.033 --> 00:21:46.634
So if you're used to
something called ASN.1,

00:21:46.634 --> 00:21:48.567
it's a public standard
for parsing,

00:21:48.567 --> 00:21:52.200
for packaging and parceling
binary data across the web.

00:21:52.200 --> 00:21:54.801
Or something we've developed
here, it's similar.

00:21:54.801 --> 00:21:57.100
It's another binary form.
It's called protocol buffers.

00:21:57.100 --> 00:21:59.234
It's something that we've
open sourced here at Google.

00:21:59.234 --> 00:22:02.000
And so it's a slightly more
efficient way

00:22:02.000 --> 00:22:04.000
of packing data
across the network.

00:22:04.000 --> 00:22:05.367
So you have
all of these choices

00:22:05.367 --> 00:22:06.701
for the different protocols

00:22:06.701 --> 00:22:08.100
when communicating
with the device.

00:22:08.100 --> 00:22:11.267
So we can ask the question,
which one is the cheapest?

00:22:11.267 --> 00:22:12.567
What are the best choices?

00:22:12.567 --> 00:22:15.601
So it boils down--
we need to back up a second,

00:22:15.601 --> 00:22:17.067
and we need ask ourselves
the question,

00:22:17.067 --> 00:22:19.167
what type of parser
are we actually going to use

00:22:19.167 --> 00:22:20.534
on the device?

00:22:20.534 --> 00:22:23.300
Most parsers fall into
one of two categories.

00:22:23.300 --> 00:22:24.801
It's either a tree parser

00:22:24.801 --> 00:22:27.234
or an event
or stream-based parser.

00:22:27.234 --> 00:22:28.934
So a tree parser
is something,

00:22:28.934 --> 00:22:30.534
if you're used to
in the desktop world

00:22:30.534 --> 00:22:31.968
of working with a DOM

00:22:31.968 --> 00:22:33.400
or the Document Object Model
in a browser,

00:22:33.400 --> 00:22:36.000
it parses the entire document
into an in-memory tree

00:22:36.000 --> 00:22:37.734
that then you can go
and interact with

00:22:37.734 --> 00:22:39.200
and pull data out of.

00:22:39.200 --> 00:22:41.000
But that tree can become
really expensive

00:22:41.000 --> 00:22:42.334
on a mobile device.

00:22:42.334 --> 00:22:43.467
You're building
the entire document

00:22:43.467 --> 00:22:44.901
into an in-memory structure.

00:22:44.901 --> 00:22:46.200
And maybe you're just going

00:22:46.200 --> 00:22:47.767
 and pulling some of the data
out of that tree,

00:22:47.767 --> 00:22:49.400
and then you end up
having to dispose it.

00:22:49.400 --> 00:22:51.901
It becomes garbage that the
system then has to collect.

00:22:51.901 --> 00:22:54.167
It become somewhat wasteful.

00:22:54.167 --> 00:22:56.767
So tree parsers can be
pretty wasteful in these cases,

00:22:56.767 --> 00:22:59.000
because they're generating
a lot of garbage.

00:22:59.000 --> 00:23:00.067
On the flip side,

00:23:00.067 --> 00:23:01.801
an event
or a stream-based parser

00:23:01.801 --> 00:23:04.501
allows you as a developer
to become directly involved

00:23:04.501 --> 00:23:06.200
with the parsing process.

00:23:06.200 --> 00:23:08.601
So as the parser
walks along a document,

00:23:08.601 --> 00:23:12.167
it might-- it actually has
callbacks to your code

00:23:12.167 --> 00:23:14.601
saying "I found the beginning
of a tag or the end of a tag,"

00:23:14.601 --> 00:23:16.968
or maybe "I found
a section of text or a number

00:23:16.968 --> 00:23:18.467
or an XML attribute."

00:23:18.467 --> 00:23:20.734
And it can make these callbacks
for you to handle in your code.

00:23:20.734 --> 00:23:22.501
It allows you to become
directly involved

00:23:22.501 --> 00:23:23.868
with the parsing process.

00:23:23.868 --> 00:23:26.133
The key takeaway there
is to realize

00:23:26.133 --> 00:23:28.100
that event
or stream-based parsers

00:23:28.100 --> 00:23:31.734
can be a lot more efficient
memory-wise than tree parsers.

00:23:31.734 --> 00:23:33.868
So this slide is a comparison
on the device.

00:23:33.868 --> 00:23:36.033
Let's say we have
a six-item RSS feed

00:23:36.033 --> 00:23:37.567
that we want to pull down
and parse from the web.

00:23:37.567 --> 00:23:38.834
And let's look at it

00:23:38.834 --> 00:23:40.300
from a number
of different data formats.

00:23:40.300 --> 00:23:41.701
Let's choose three.

00:23:41.701 --> 00:23:44.133
We have XML or JSON
or protocol buffers,

00:23:44.133 --> 00:23:46.067
which is a binary format.

00:23:46.067 --> 00:23:47.834
So in this case,
we see on the left

00:23:47.834 --> 00:23:50.400
those tree parsers in gray
end up being pretty expensive.

00:23:50.400 --> 00:23:51.801
It takes a lot of time

00:23:51.801 --> 00:23:53.868
to actually parse and handle
those documents.

00:23:53.868 --> 00:23:55.434
But then we see
on the right-hand side

00:23:55.434 --> 00:23:58.367
when we're using the event
or stream-based parsers,

00:23:58.367 --> 00:24:00.167
it ends up being
a lot cheaper,

00:24:00.167 --> 00:24:02.167
especially when we can see
the stair-step effect.

00:24:02.167 --> 00:24:05.400
XML is a little bit less
efficient than JSON.

00:24:05.400 --> 00:24:07.133
And then protocol buffers,

00:24:07.133 --> 00:24:08.868
because it's a binary
data format,

00:24:08.868 --> 00:24:10.701
ends up being
pretty efficient.

00:24:10.701 --> 00:24:11.968
Ends up being
the most efficient

00:24:11.968 --> 00:24:14.701
out of the ones
that we compared here.

00:24:14.701 --> 00:24:16.100
So the key takeaway is

00:24:16.100 --> 00:24:19.000
use those stream parsers
instead of the tree parsers.

00:24:19.000 --> 00:24:20.534
So this is something

00:24:20.534 --> 00:24:22.534
if you're using XML pull parser
on the device,

00:24:22.534 --> 00:24:25.901
that's one of the good parsers
that you should be using.

00:24:25.901 --> 00:24:29.100
Sad to say the JSON object
and the JSON array libraries

00:24:29.100 --> 00:24:31.334
that ship with the platform...
they're tree parsers right now.

00:24:31.334 --> 00:24:32.701
So it's something
we'd like to find

00:24:32.701 --> 00:24:33.868
other libraries to integrate.

00:24:33.868 --> 00:24:35.100
So it's something
to be aware of

00:24:35.100 --> 00:24:36.968
if you're parsing JSON data
on the device--

00:24:36.968 --> 00:24:39.400
the ones that ship with
the framework are tree parsers.

00:24:39.400 --> 00:24:41.267
So they're slightly
less efficient.

00:24:41.267 --> 00:24:43.701
There's other libraries
that you can use in their place.

00:24:43.701 --> 00:24:46.300
For example, the numbers
that I did on the last slide,

00:24:46.300 --> 00:24:49.100
I used Jackson,
with is another JSON library

00:24:49.100 --> 00:24:52.501
which allows it to parse
as a stream.

00:24:52.501 --> 00:24:53.901
So we have text formats,

00:24:53.901 --> 00:24:55.501
then we also have
these binary formats,

00:24:55.501 --> 00:24:58.267
like protocol buffers
or the ASN.1.

00:24:58.267 --> 00:25:00.901
Another benefit to using
the binary formats like that

00:25:00.901 --> 00:25:04.367
is that we can incorporate
both text and binary data

00:25:04.367 --> 00:25:05.767
in the same request.

00:25:05.767 --> 00:25:08.634
And one place this is
actually evident on the platform

00:25:08.634 --> 00:25:10.067
is in the Market client.

00:25:10.067 --> 00:25:12.267
If you're scrolling through
a list of apps in Market,

00:25:12.267 --> 00:25:13.968
you might notice
that all of the sudden

00:25:13.968 --> 00:25:15.601
five--four or five icons

00:25:15.601 --> 00:25:17.067
of the apps
that you're browsing through

00:25:17.067 --> 00:25:18.567
just appear
all of the sudden.

00:25:18.567 --> 00:25:20.767
They don't slowly fill in.
You'll see five at once.

00:25:20.767 --> 00:25:23.367
And the reason is
we're using protocol buffers

00:25:23.367 --> 00:25:25.767
to actually bundle up
multiple requests

00:25:25.767 --> 00:25:27.367
into a single request,

00:25:27.367 --> 00:25:30.367
and then we return the images
in one bunch to the device.

00:25:30.367 --> 00:25:32.767
And this is really helpful
on some mobile networks

00:25:32.767 --> 00:25:34.167
that can be laggy,

00:25:34.167 --> 00:25:37.067
where you have a lot of latency
between yourself and the server.

00:25:37.067 --> 00:25:38.968
So instead of making
an individual request

00:25:38.968 --> 00:25:41.534
for each of those assets,
for each of those icons,

00:25:41.534 --> 00:25:43.467
we actually wrap that
into a single request,

00:25:43.467 --> 00:25:44.767
requesting four or five,

00:25:44.767 --> 00:25:46.167
and we get
a larger response back

00:25:46.167 --> 00:25:47.567
that then we can parse.

00:25:47.567 --> 00:25:50.367
So something like a binary
format like protocol buffers

00:25:50.367 --> 00:25:52.400
allows us to pack
even multiple files

00:25:52.400 --> 00:25:54.868
into a single request
coming back to the device.

00:25:54.868 --> 00:25:58.400
And that can really help you
have fewer round trips

00:25:58.400 --> 00:26:00.968
and serve faster
user experience

00:26:00.968 --> 00:26:03.968
to people
that are using your apps.

00:26:08.434 --> 00:26:10.467
One other way that we can
actually do a good job

00:26:10.467 --> 00:26:13.734
on the device as far
as networking is using GZIP.

00:26:13.734 --> 00:26:16.033
If you're familiar with
the desktop environment,

00:26:16.033 --> 00:26:18.133
some web servers
support the notion

00:26:18.133 --> 00:26:21.167
of compressing the data before
they send it to the browser,

00:26:21.167 --> 00:26:22.801
and almost all modern browsers,

00:26:22.801 --> 00:26:25.701
automatically, when they see
GZIP data coming from a website,

00:26:25.701 --> 00:26:27.868
will decompress it
and show it to the user.

00:26:27.868 --> 00:26:30.801
So many of you have actually
used this in browsers today,

00:26:30.801 --> 00:26:33.400
possibly without realizing
that it's happening

00:26:33.400 --> 00:26:34.901
under the hood.

00:26:34.901 --> 00:26:37.734
So to back up a second,
GZIP is compressing the data.

00:26:37.734 --> 00:26:39.100
The server compresses the data

00:26:39.100 --> 00:26:40.834
before it sends it
across the network,

00:26:40.834 --> 00:26:43.100
and the device handles it.

00:26:43.100 --> 00:26:44.868
So in Android,
the GZIP libraries

00:26:44.868 --> 00:26:47.601
that come with the platform
are really efficient.

00:26:47.601 --> 00:26:50.634
And that's in part because
they go directly to native code

00:26:50.634 --> 00:26:51.868
on the device.

00:26:51.868 --> 00:26:54.400
So if you're parsing
a GZIP stream coming in,

00:26:54.400 --> 00:26:55.901
if you're decompressing it,

00:26:55.901 --> 00:26:57.801
it ends up being
incredibly efficient,

00:26:57.801 --> 00:26:59.133
incredibly fast.

00:26:59.133 --> 00:27:00.667
So here's a quick example.

00:27:00.667 --> 00:27:03.567
If you're using something like
the Apache HTTP client library,

00:27:03.567 --> 00:27:05.567
something a lot of us
have used in our code,

00:27:05.567 --> 00:27:07.767
the first set of code
should be--

00:27:07.767 --> 00:27:10.100
the first couple lines there
should be pretty familiar.

00:27:10.100 --> 00:27:11.868
We're making
a get request website

00:27:11.868 --> 00:27:13.334
and receiving something back.

00:27:13.334 --> 00:27:15.067
But in this case,
if we know, for instance,

00:27:15.067 --> 00:27:16.667
that the web server
we're talking to

00:27:16.667 --> 00:27:18.701
is going to be sending back
compressed data,

00:27:18.701 --> 00:27:20.868
we only need to add
one line of code,

00:27:20.868 --> 00:27:23.234
one extra step
to decompress that data.

00:27:23.234 --> 00:27:24.534
We take the input stream

00:27:24.534 --> 00:27:26.000
that we're receiving
from the site,

00:27:26.000 --> 00:27:28.334
and we just wrap it
in a GZIP input stream.

00:27:28.334 --> 00:27:30.834
The system on the fly
will decompress the data

00:27:30.834 --> 00:27:32.033
coming from the server

00:27:32.033 --> 00:27:33.667
and so we can continue
handling it.

00:27:33.667 --> 00:27:35.000
So we can pass
that input stream,

00:27:35.000 --> 00:27:36.267
the decompressed one,

00:27:36.267 --> 00:27:38.667
into one of our data format
parsers earlier

00:27:38.667 --> 00:27:41.133
that takes an input stream
into it.

00:27:41.133 --> 00:27:43.968
So GZIP on the platform
goes directly to native code,

00:27:43.968 --> 00:27:45.801
and it's really cheap.

00:27:45.801 --> 00:27:47.734
So we can ask the question,
how cheap is it?

00:27:47.734 --> 00:27:49.167
Should I consider using this?

00:27:49.167 --> 00:27:50.767
So just for the sake
of an example,

00:27:50.767 --> 00:27:52.767
let's say we had
a large RSS feed,

00:27:52.767 --> 00:27:54.067
say like a thousand items.

00:27:54.067 --> 00:27:56.067
And this is what I did
for this test.

00:27:56.067 --> 00:27:58.501
So if we're on a WiFi connection
which is really fast,

00:27:58.501 --> 00:28:00.334
it doesn't make
too much of a difference.

00:28:00.334 --> 00:28:02.534
We're looking here
at the three bars,

00:28:02.534 --> 00:28:05.467
the raw data itself,
so the raw XML,

00:28:05.467 --> 00:28:06.868
and then we compressed it

00:28:06.868 --> 00:28:08.767
using two levels
of GZIP compression.

00:28:08.767 --> 00:28:10.400
Those are
the two blue colors.

00:28:10.400 --> 00:28:12.100
And that's just the two levels.

00:28:12.100 --> 00:28:13.634
1 is light compression

00:28:13.634 --> 00:28:16.167
and 9 is the heaviest
compression available.

00:28:16.167 --> 00:28:19.100
So in WiFi, it doesn't make
too much of a difference.

00:28:19.100 --> 00:28:21.334
But as soon as we start
going over to a 3G

00:28:21.334 --> 00:28:23.901
or an EDGE connection,
we can begin to see

00:28:23.901 --> 00:28:26.534
where the value of compressing
the data comes in.

00:28:26.534 --> 00:28:28.634
So on a 3G network connection,

00:28:28.634 --> 00:28:31.133
just by compressing the data
as it comes across the network,

00:28:31.133 --> 00:28:33.167
we end up cutting the transfer
and parsing time,

00:28:33.167 --> 00:28:35.100
that total time, in half.

00:28:35.100 --> 00:28:36.834
And so it's not just
the parsing time.

00:28:36.834 --> 00:28:38.367
Remember
that this is battery time,

00:28:38.367 --> 00:28:40.200
because the radio is spun out
that entire time.

00:28:40.200 --> 00:28:41.934
The CPU is spun up.
It's waiting for data.

00:28:41.934 --> 00:28:43.234
It's parsing it.

00:28:43.234 --> 00:28:44.734
So this is the user's
battery life.

00:28:44.734 --> 00:28:47.033
We've essentially,
in terms of our application,

00:28:47.033 --> 00:28:49.601
we've doubled the user's
battery life on 3G.

00:28:49.601 --> 00:28:50.968
And it's even better on EDGE.

00:28:50.968 --> 00:28:52.200
EDGE to do this transfer,

00:28:52.200 --> 00:28:53.501
to transfer it across
and parse it,

00:28:53.501 --> 00:28:55.234
ended up taking over
40 seconds.

00:28:55.234 --> 00:28:58.067
But that same data
transferred across the network,

00:28:58.067 --> 00:29:00.367
if we GZIP it,
if we compress it,

00:29:00.367 --> 00:29:02.100
ends up taking
under ten seconds.

00:29:02.100 --> 00:29:04.033
So again,
an order of magnitude,

00:29:04.033 --> 00:29:07.167
it's ten times more expensive
to do the raw data.

00:29:07.167 --> 00:29:09.234
Another thing
to take away from this slide,

00:29:09.234 --> 00:29:11.200
you might wonder how expensive
are the GZIP libraries

00:29:11.200 --> 00:29:12.400
on the device.

00:29:12.400 --> 00:29:13.834
So we can see that

00:29:13.834 --> 00:29:15.434
with the WiFi connection
on the far right,

00:29:15.434 --> 00:29:19.701
we're seeing that adding GZIP
doesn't cost us anything.

00:29:19.701 --> 00:29:22.033
It doesn't take us longer
to parse the data,

00:29:22.033 --> 00:29:24.234
even when we have
a really fast connection.

00:29:24.234 --> 00:29:27.000
And then one final thing
to mention about GZIP is

00:29:27.000 --> 00:29:29.801
this is really helpful when
you're working with text data.

00:29:29.801 --> 00:29:32.234
Text data can be really
well-compressed using GZIP.

00:29:32.234 --> 00:29:34.033
If you're doing
binary transfers,

00:29:34.033 --> 00:29:36.367
if you're doing images
or video,

00:29:36.367 --> 00:29:38.167
those items,
because they're binary data,

00:29:38.167 --> 00:29:39.634
don't compress as well.

00:29:39.634 --> 00:29:41.601
So experiment with the data
that you're using

00:29:41.601 --> 00:29:42.934
to see how well it compresses

00:29:42.934 --> 00:29:44.934
to see if this would
actually be an advantage.

00:29:44.934 --> 00:29:47.667
For most binary formats,
like the images and video,

00:29:47.667 --> 00:29:52.601
it won't actually offer you
very much savings.

00:29:55.901 --> 00:29:57.767
Okay, so we talked about
networking.

00:29:57.767 --> 00:29:59.501
Another thing
that we can talk about

00:29:59.501 --> 00:30:01.634
is foreground applications
that we're interacting with,

00:30:01.634 --> 00:30:04.501
that the user interacts with
on the device.

00:30:04.501 --> 00:30:07.634
So if you're writing an app,
there's a note of wakelocks

00:30:07.634 --> 00:30:10.167
that you can acquire
to keep the device awake.

00:30:10.167 --> 00:30:12.767
Let's say, for example, you're
writing a video application

00:30:12.767 --> 00:30:15.334
that you want the user
to sit and watch videos in,

00:30:15.334 --> 00:30:16.734
something like YouTube.

00:30:16.734 --> 00:30:17.934
You can acquire a wakelock,

00:30:17.934 --> 00:30:20.467
which forces the device
to stay awake

00:30:20.467 --> 00:30:22.067
at least a certain level.

00:30:22.067 --> 00:30:25.334
There's multiple levels
of wakelocks in Android.

00:30:25.334 --> 00:30:27.501
You could request--
one of the lowest levels

00:30:27.501 --> 00:30:30.501
is just one that forces
the CPU to stay on.

00:30:30.501 --> 00:30:33.167
So you acquire this lock
that the system knows

00:30:33.167 --> 00:30:35.300
someone out there
needs the CPU to be turned on.

00:30:35.300 --> 00:30:36.634
And then
when you're finished,

00:30:36.634 --> 00:30:38.067
let's say you're parsing
the document,

00:30:38.067 --> 00:30:39.601
you can release
that wakelock.

00:30:39.601 --> 00:30:42.734
And if the system--if the user
isn't doing anything,

00:30:42.734 --> 00:30:44.534
releasing that wakelock
would allow the system

00:30:44.534 --> 00:30:46.167
to fall back asleep.

00:30:46.167 --> 00:30:47.667
Like I was saying,

00:30:47.667 --> 00:30:49.267
there's multiple levels
of these wakelocks.

00:30:49.267 --> 00:30:51.033
That's just one
that would keep the CPU on.

00:30:51.033 --> 00:30:52.534
We can have other ones that,
for example,

00:30:52.534 --> 00:30:53.968
keep the LCD on,

00:30:53.968 --> 00:30:56.534
which is very useful for
something playing back video.

00:30:56.534 --> 00:30:58.267
We want the screen to stay on

00:30:58.267 --> 00:30:59.734
so the user
doesn't have to actively

00:30:59.734 --> 00:31:01.467
interact with the screen.

00:31:01.467 --> 00:31:03.367
Wakelocks can be really useful

00:31:03.367 --> 00:31:05.934
because they allow you,
as developers, power

00:31:05.934 --> 00:31:07.467
in keeping the device awake.

00:31:07.467 --> 00:31:09.634
But on the flip side, they can
actually be really expensive,

00:31:09.634 --> 00:31:11.901
especially
if you forget to release them,

00:31:11.901 --> 00:31:15.968
because even though
we're working in the Java...

00:31:15.968 --> 00:31:17.534
in a Java world,

00:31:17.534 --> 00:31:20.167
wakelocks actually...
the system acquires them,

00:31:20.167 --> 00:31:22.033
and it doesn't
garbage collect them.

00:31:22.033 --> 00:31:24.400
If you take out a wakelock
and you forget to release it,

00:31:24.400 --> 00:31:26.300
the system still thinks
that you're out there,

00:31:26.300 --> 00:31:27.501
having acquired it,

00:31:27.501 --> 00:31:28.901
and it will keep
the system awake.

00:31:28.901 --> 00:31:30.300
So if your code crashes

00:31:30.300 --> 00:31:32.801
or if you forget to release
the wakelock,

00:31:32.801 --> 00:31:35.501
you might be responsible
for keeping the device awake

00:31:35.501 --> 00:31:37.501
for a long period of time

00:31:37.501 --> 00:31:39.701
and possibly draining
the user's battery.

00:31:39.701 --> 00:31:41.534
If you acquire wakelock
and don't release it,

00:31:41.534 --> 00:31:43.868
the system will stay awake
that entire time

00:31:43.868 --> 00:31:47.367
and possibly
not allow it to fall asleep.

00:31:47.367 --> 00:31:49.367
So if you're worried
about correctness--

00:31:49.367 --> 00:31:51.200
'cause I was mentioning
there's these wakelocks;

00:31:51.200 --> 00:31:52.501
you have to acquire
and release them--

00:31:52.501 --> 00:31:53.901
if you're worried about
the correctness,

00:31:53.901 --> 00:31:55.834
of proving that your code
is correct,

00:31:55.834 --> 00:31:58.033
that you'll actually
release them at the right time,

00:31:58.033 --> 00:32:00.601
there's one of two approaches
you can use.

00:32:00.601 --> 00:32:03.901
If you're writing UI
from a user perspective,

00:32:03.901 --> 00:32:06.868
you can add one single tag
into your UI,

00:32:06.868 --> 00:32:09.667
into any of the layouts,
the Android layouts in XML--

00:32:09.667 --> 00:32:12.367
and that's
android:keepScreenOn="true".

00:32:12.367 --> 00:32:14.000
Just using that,
if you add that tag

00:32:14.000 --> 00:32:15.400
you'll keep the screen on,

00:32:15.400 --> 00:32:16.734
and you don't
have to worry about

00:32:16.734 --> 00:32:18.000
going and acquiring
wakelocks.

00:32:18.000 --> 00:32:19.567
You don't
have to go touch them.

00:32:19.567 --> 00:32:20.934
The window manager
in the device

00:32:20.934 --> 00:32:23.701
will actually acquire a wakelock
on your behalf

00:32:23.701 --> 00:32:25.701
when your application shows,

00:32:25.701 --> 00:32:27.033
and then whether you crash

00:32:27.033 --> 00:32:28.968
or the user switches
to a different application,

00:32:28.968 --> 00:32:30.734
as soon as your activity
goes away,

00:32:30.734 --> 00:32:32.434
the system will,
on your behalf,

00:32:32.434 --> 00:32:33.868
release that wakelock.

00:32:33.868 --> 00:32:36.167
So that can be one way
of guaranteeing the correctness

00:32:36.167 --> 00:32:38.334
if you just need
to keep the screen on.

00:32:38.334 --> 00:32:40.367
Another way is if you're
acquiring these wakelocks

00:32:40.367 --> 00:32:42.567
behind the scene, say,
to keep the CPU awake

00:32:42.567 --> 00:32:44.234
while you're performing
some parsing,

00:32:44.234 --> 00:32:45.634
you can actually set a limit.

00:32:45.634 --> 00:32:47.767
You can say I'd like
to acquire this wakelock

00:32:47.767 --> 00:32:50.701
for, at most, 30 seconds,
or for, at most, a minute.

00:32:50.701 --> 00:32:52.968
So if you know how long

00:32:52.968 --> 00:32:55.434
the worst-case parsing
is going to take,

00:32:55.434 --> 00:32:57.634
you can actually use that
when you acquire the wakelock.

00:32:57.634 --> 00:33:00.000
So if the system
doesn't hear back from you

00:33:00.000 --> 00:33:02.567
by the time
that time-out elapses,

00:33:02.567 --> 00:33:04.834
the system will automatically
release the wakelock.

00:33:04.834 --> 00:33:07.300
So if you know you're just
parsing an RSS feed image

00:33:07.300 --> 00:33:10.100
and it shouldn't take any longer
than 30 seconds,

00:33:10.100 --> 00:33:12.801
you can actually
just set that as the time out,

00:33:12.801 --> 00:33:14.534
and the system will release it
on your behalf.

00:33:14.534 --> 00:33:16.968
So just in case there are
any lagging issues in the code,

00:33:16.968 --> 00:33:18.300
any correctness issues,

00:33:18.300 --> 00:33:20.634
the system will release it
on your behalf

00:33:20.634 --> 00:33:23.367
when the time out passes.

00:33:23.367 --> 00:33:27.834
Another way we can help save
battery from a UI perspective

00:33:27.834 --> 00:33:31.868
is recycling Java objects,
especially complex ones.

00:33:31.868 --> 00:33:36.634
So, yes, on Android,
we have a garbage collector.

00:33:36.634 --> 00:33:38.067
So we can create objects,

00:33:38.067 --> 00:33:40.000
and then they get garbage
collected at a later date.

00:33:40.000 --> 00:33:42.334
But it's usually better
in the long run

00:33:42.334 --> 00:33:44.000
if we just create
less garbage.

00:33:44.000 --> 00:33:46.801
If we're running in a tight--
say a tight code loop

00:33:46.801 --> 00:33:49.601
doing some text operations,

00:33:49.601 --> 00:33:51.834
building up a response
to send back to a server

00:33:51.834 --> 00:33:53.234
on the other side,

00:33:53.234 --> 00:33:57.501
a response to send
to the server...

00:33:57.501 --> 00:33:59.701
we can actually
recycle buffers.

00:33:59.701 --> 00:34:02.434
If we recycle objects
inside of that tight loop,

00:34:02.434 --> 00:34:04.501
we end up creating
less garbage overall.

00:34:04.501 --> 00:34:05.801
And there's a couple places

00:34:05.801 --> 00:34:07.267
that this shows up
in the system.

00:34:07.267 --> 00:34:10.767
One is XmlPullParserFactory,
and this is just an example.

00:34:10.767 --> 00:34:15.033
It borrows from the factory
design principle,

00:34:15.033 --> 00:34:17.701
and it also keeps
some generic state

00:34:17.701 --> 00:34:19.200
for the entire--

00:34:19.200 --> 00:34:21.901
for all XML pull parsers
that you might acquire.

00:34:21.901 --> 00:34:24.200
And so using
the pull parser factory

00:34:24.200 --> 00:34:27.367
allows you to get an instance
of a pull parser as you need it

00:34:27.367 --> 00:34:28.767
with very low overhead.

00:34:28.767 --> 00:34:31.300
It takes care of recycling--
recycling some of those objects.

00:34:31.300 --> 00:34:33.367
The same with BitmapFactory
on the device

00:34:33.367 --> 00:34:35.400
if you're acquiring bitmaps
for various things.

00:34:35.400 --> 00:34:37.234
Using BitmapFactory
internally,

00:34:37.234 --> 00:34:39.567
it keeps a pool
of bitmap objects

00:34:39.567 --> 00:34:41.067
that it's prepared
to send to you,

00:34:41.067 --> 00:34:43.667
almost pre-warmed,
ready to give to you.

00:34:43.667 --> 00:34:45.234
Then when you're done,

00:34:45.234 --> 00:34:47.267
you can release them back into
the pool to be recycled.

00:34:47.267 --> 00:34:48.868
So some of these things

00:34:48.868 --> 00:34:51.534
can really help you recycle
objects in your code.

00:34:51.534 --> 00:34:53.234
Two other places
that this can show up--

00:34:53.234 --> 00:34:54.734
If you do find yourselves

00:34:54.734 --> 00:34:56.400
having to use
regular expressions,

00:34:56.400 --> 00:34:58.400
in Java regular expression,

00:34:58.400 --> 00:34:59.968
we compile it into a pattern,

00:34:59.968 --> 00:35:01.734
an instance
of the pattern class.

00:35:01.734 --> 00:35:03.434
And with that pattern class,

00:35:03.434 --> 00:35:06.133
we can get a matcher
for a given string.

00:35:06.133 --> 00:35:08.634
And one mistake
that I've made in my code before

00:35:08.634 --> 00:35:10.834
is that I've acquired
a new matcher object

00:35:10.834 --> 00:35:12.133
every single time,

00:35:12.133 --> 00:35:13.801
for every single string
that I wanna match

00:35:13.801 --> 00:35:15.467
that regular expression
against.

00:35:15.467 --> 00:35:17.200
And something I need to
remind myself of

00:35:17.200 --> 00:35:20.367
is that I can actually recycle
that matcher object.

00:35:20.367 --> 00:35:22.300
I can call a method on it
called reset

00:35:22.300 --> 00:35:23.934
and pass it a new string.

00:35:23.934 --> 00:35:25.901
So this can be
a lot more efficient.

00:35:25.901 --> 00:35:27.167
If you're writing
a tight code loop

00:35:27.167 --> 00:35:29.868
where you're parsing
multiple strings,

00:35:29.868 --> 00:35:32.667
you can recycle
those matcher objects.

00:35:32.667 --> 00:35:34.100
Also in the case,

00:35:34.100 --> 00:35:36.033
if you're building strings
for a UI,

00:35:36.033 --> 00:35:38.033
you might end up using
something called StringBuilder.

00:35:38.033 --> 00:35:40.200
So remember in Java
that strings are immutable,

00:35:40.200 --> 00:35:42.033
and every time we use
the plus operator

00:35:42.033 --> 00:35:43.667
to concatenate strings
together,

00:35:43.667 --> 00:35:45.634
we're actually acquiring
a new string

00:35:45.634 --> 00:35:47.567
and throwing away
the two old ones.

00:35:47.567 --> 00:35:49.634
So something like StringBuilder

00:35:49.634 --> 00:35:52.667
actually acquires a byte buffer
in the background,

00:35:52.667 --> 00:35:53.934
inside of the object,

00:35:53.934 --> 00:35:56.000
and you can append things
very cheaply to it.

00:35:56.000 --> 00:35:59.467
And you can also recycle those
StringBuilder objects.

00:35:59.467 --> 00:36:01.033
You call setLength,

00:36:01.033 --> 00:36:03.767
and it actually just erases
everything that's in the string,

00:36:03.767 --> 00:36:05.033
the StringBuilder,

00:36:05.033 --> 00:36:07.067
allowing you to build
a brand-new string,

00:36:07.067 --> 00:36:10.334
and you don't have to reallocate
the buffer that's underneath.

00:36:10.334 --> 00:36:12.000
Some of these recycling issues,

00:36:12.000 --> 00:36:13.601
you might find yourselves
working--

00:36:13.601 --> 00:36:15.100
you can create a static object

00:36:15.100 --> 00:36:17.000
that you might borrow
between multiple methods.

00:36:17.000 --> 00:36:19.834
And sometimes that can introduce
synchronization issues

00:36:19.834 --> 00:36:22.634
or correctness,
if two different threads

00:36:22.634 --> 00:36:25.234
are borrowing
the same object in code.

00:36:25.234 --> 00:36:27.834
And this actually is solved--
this can be solved in Android

00:36:27.834 --> 00:36:30.033
because we're using
a single UI thread model.

00:36:30.033 --> 00:36:32.033
If it's UI-driven,
for example,

00:36:32.033 --> 00:36:33.868
if we're recycling
a string builder,

00:36:33.868 --> 00:36:35.267
instead of allocating it,

00:36:35.267 --> 00:36:36.767
let's saying you were
writing a ListView,

00:36:36.767 --> 00:36:38.467
and there's a bindView method

00:36:38.467 --> 00:36:40.234
where we're actually
setting the text

00:36:40.234 --> 00:36:41.767
for the item in the ListView.

00:36:41.767 --> 00:36:43.634
Instead of allocating
a string builder

00:36:43.634 --> 00:36:46.834
inside of each call
of the method,

00:36:46.834 --> 00:36:48.834
we can actually share an object,
a static object,

00:36:48.834 --> 00:36:51.434
inside of something like
that list adaptor.

00:36:51.434 --> 00:36:53.501
So on Android,

00:36:53.501 --> 00:36:55.834
because it's a single
UI thread-based model,

00:36:55.834 --> 00:36:57.834
we know that that code
is only going to ever be called,

00:36:57.834 --> 00:37:00.467
that method is only going
to be called from the UI thread.

00:37:00.467 --> 00:37:02.033
And we can guarantee

00:37:02.033 --> 00:37:05.434
that the synchronization issues
are solved in those cases.

00:37:05.434 --> 00:37:07.067
So it's something to handle
on a case-by-case basis,

00:37:07.067 --> 00:37:10.100
but just to remember that
Android is a single UI thread.

00:37:10.100 --> 00:37:13.501
It can help solve
some synchronization problems.

00:37:13.501 --> 00:37:15.234
I was mentioning ListView.

00:37:15.234 --> 00:37:18.067
ListView actually uses a lot
of recycling strategies.

00:37:18.067 --> 00:37:19.901
If you're interesting
in digging more,

00:37:19.901 --> 00:37:23.133
Romain Guy's talk later--
I believe it's tomorrow--

00:37:23.133 --> 00:37:25.033
he'll be diving into ListView
a lot more

00:37:25.033 --> 00:37:27.000
on some of the recycling
strategies

00:37:27.000 --> 00:37:30.834
that are used in ListView.

00:37:35.033 --> 00:37:37.367
So other ways
with foreground apps

00:37:37.367 --> 00:37:38.834
that we can end up
saving battery.

00:37:38.834 --> 00:37:41.200
A lot of people write
geolocation apps,

00:37:41.200 --> 00:37:43.367
apps that need to know about
the user's location.

00:37:43.367 --> 00:37:45.033
So something you might
want to consider

00:37:45.033 --> 00:37:47.033
is using the coarse
network location.

00:37:47.033 --> 00:37:51.267
So on Android we provide
two different providers

00:37:51.267 --> 00:37:53.300
of the location of the device.

00:37:53.300 --> 00:37:55.767
One is a network provider
and one is GPS

00:37:55.767 --> 00:37:57.701
that the device
also happens to have.

00:37:57.701 --> 00:38:00.434
And it ends up
that using the network provider

00:38:00.434 --> 00:38:01.934
is a lot cheaper.

00:38:01.934 --> 00:38:04.534
So network provider, this is
something Vic was mentioning

00:38:04.534 --> 00:38:06.868
in his keynote earlier today

00:38:06.868 --> 00:38:08.567
is that we might use
nearby cell towers

00:38:08.567 --> 00:38:12.067
and WiFi access points to
triangulate where the user is.

00:38:12.067 --> 00:38:14.667
And that can actually
be really cheap on the device.

00:38:14.667 --> 00:38:16.033
We're just looking
at some sensors,

00:38:16.033 --> 00:38:18.300
pulling in the cell towers
that we see,

00:38:18.300 --> 00:38:20.701
and asking a server
to triangulate on our behalf.

00:38:20.701 --> 00:38:23.701
And that can actually be
a lot cheaper than doing GPS.

00:38:23.701 --> 00:38:27.133
That's because GPS fixes,
getting a fix from satellites,

00:38:27.133 --> 00:38:29.167
the time to fix,
the time it takes us

00:38:29.167 --> 00:38:32.133
to get a fix of our location
from the GPS satellites,

00:38:32.133 --> 00:38:34.234
varies wildly.

00:38:34.234 --> 00:38:36.100
It can be any length of time.

00:38:36.100 --> 00:38:38.267
If you're out in the middle
of an open field,

00:38:38.267 --> 00:38:40.267
the fix may only take
a few seconds.

00:38:40.267 --> 00:38:42.200
But let's say you're in
an indoor environment like this

00:38:42.200 --> 00:38:44.901
here in this conference
here today.

00:38:44.901 --> 00:38:48.968
Your device may look for
GPS satellites,

00:38:48.968 --> 00:38:50.934
and it may never find them.

00:38:50.934 --> 00:38:53.834
We may keep the GPS radio awake
that entire time

00:38:53.834 --> 00:38:55.801
and never actually
get a fix.

00:38:55.801 --> 00:38:57.167
There's a risk of us

00:38:57.167 --> 00:38:59.601
not actually getting
a latitude/longitude.

00:38:59.601 --> 00:39:01.501
So it's something
to be aware of.

00:39:01.501 --> 00:39:03.400
If you're interested
in just rough location,

00:39:03.400 --> 00:39:05.868
if the accuracy
that you're interested in

00:39:05.868 --> 00:39:08.334
is just within a couple
kilometers of where the user is,

00:39:08.334 --> 00:39:10.501
network location
can be a lot cheaper.

00:39:10.501 --> 00:39:12.334
So the numbers here
that we're looking at--

00:39:12.334 --> 00:39:15.634
an average GPS fix
might take about 25 seconds.

00:39:15.634 --> 00:39:17.968
And then we multiply that
times the actual battery

00:39:17.968 --> 00:39:19.334
that's used during that time.

00:39:19.334 --> 00:39:21.667
It ends up costing
about 1 milliamp hour on average

00:39:21.667 --> 00:39:22.901
to get a GPS fix

00:39:22.901 --> 00:39:24.133
whereas getting
a network fix

00:39:24.133 --> 00:39:25.968
is an order
of magnitude cheaper.

00:39:25.968 --> 00:39:28.667
We're just doing a quick,
simple network query

00:39:28.667 --> 00:39:30.234
based on information,

00:39:30.234 --> 00:39:32.868
the cell towers
that we already know about.

00:39:32.868 --> 00:39:34.868
And also you notice
the Cupcake there,

00:39:34.868 --> 00:39:38.367
something that in 1.5 we're
actually using Assisted GPS.

00:39:38.367 --> 00:39:40.067
So when we have a GPS

00:39:40.067 --> 00:39:41.968
and we first bring it up
on the network,

00:39:41.968 --> 00:39:43.834
there's something known
as a cold start.

00:39:43.834 --> 00:39:45.968
So if the user hasn't used
GPS in a while,

00:39:45.968 --> 00:39:49.067
the device has to sit
and listen for the satellites

00:39:49.067 --> 00:39:52.434
to send down an almanac
or a set of information

00:39:52.434 --> 00:39:54.667
describing the movement
of the satellites.

00:39:54.667 --> 00:39:56.667
That actually--
that can happen a lot faster

00:39:56.667 --> 00:40:00.033
if you use something called
AGPS or Assisted GPS

00:40:00.033 --> 00:40:03.334
where, instead of listening
for that almanac data

00:40:03.334 --> 00:40:05.067
over a low bit rate--

00:40:05.067 --> 00:40:07.701
the satellites are transmitting
it at all times,

00:40:07.701 --> 00:40:09.067
but at a very low bit rate--

00:40:09.067 --> 00:40:10.567
instead of waiting
a couple minutes

00:40:10.567 --> 00:40:12.000
to collect that
almanac information,

00:40:12.000 --> 00:40:14.167
AGPS goes to the network.

00:40:14.167 --> 00:40:15.467
It assumes you have
a network connection.

00:40:15.467 --> 00:40:17.334
It can go request
that almanac information

00:40:17.334 --> 00:40:19.901
which allows fixes to happen
a lot faster.

00:40:19.901 --> 00:40:24.701
So that's something
that is shipped in 1.5.

00:40:24.701 --> 00:40:26.834
Some final things to mention
about foreground apps

00:40:26.834 --> 00:40:29.133
is that floating point math
is expensive on the device.

00:40:29.133 --> 00:40:30.667
The current devices
that have shipped

00:40:30.667 --> 00:40:33.767
don't have floating point units
in their CPUs,

00:40:33.767 --> 00:40:35.801
so doing floating point math
is expensive.

00:40:35.801 --> 00:40:37.734
If you worked with Map Ap--

00:40:37.734 --> 00:40:40.534
Map Activity
or Map View on the device,

00:40:40.534 --> 00:40:42.701
you may have noticed
something called GeoPoint.

00:40:42.701 --> 00:40:44.934
And so it's just like
a latitude/longitude,

00:40:44.934 --> 00:40:46.467
which are decimal numbers,

00:40:46.467 --> 00:40:48.701
except it's multiplied
by 10 to the 6.

00:40:48.701 --> 00:40:50.200
We just shifted over
the decimal place.

00:40:50.200 --> 00:40:51.801
So we can treat these
as integers,

00:40:51.801 --> 00:40:53.534
which ends up being
a lot cheaper

00:40:53.534 --> 00:40:55.667
when we're working
on the device.

00:40:55.667 --> 00:40:57.701
And also, if you end up
writing your own views,

00:40:57.701 --> 00:40:59.200
you may need to worry about

00:40:59.200 --> 00:41:00.901
scaling to different densities
of devices.

00:41:00.901 --> 00:41:03.000
A device may have
a higher density screen.

00:41:03.000 --> 00:41:04.634
So you can actually--

00:41:04.634 --> 00:41:06.634
and that density
is expressed in a float.

00:41:06.634 --> 00:41:08.000
So if you're writing
your own views,

00:41:08.000 --> 00:41:09.534
you can pre-cache that.

00:41:09.534 --> 00:41:12.067
If you pre-multiply
that density that's coming in,

00:41:12.067 --> 00:41:13.834
you can often cache
the value

00:41:13.834 --> 00:41:17.100
and end up saving time
in the long run.

00:41:17.100 --> 00:41:18.334
And one final mention.

00:41:18.334 --> 00:41:19.601
If you're looking at using

00:41:19.601 --> 00:41:21.300
the accelerometer
or game sensors,

00:41:21.300 --> 00:41:22.734
there's four different rates,

00:41:22.734 --> 00:41:24.767
four different polling rates
that you can use--

00:41:24.767 --> 00:41:26.767
normal,
UI, game, and fastest.

00:41:26.767 --> 00:41:30.133
They each have their own cost
associated with them.

00:41:30.133 --> 00:41:32.200
Usually, when you're using
the accelerometer,

00:41:32.200 --> 00:41:35.033
the user's playing a game,
so you need it anyway.

00:41:35.033 --> 00:41:36.567
But it's just something
to be aware of,

00:41:36.567 --> 00:41:39.434
that this is the cost
that's added on.

00:41:45.234 --> 00:41:46.868
So we talked about network

00:41:46.868 --> 00:41:48.634
and we talked about
foreground apps.

00:41:48.634 --> 00:41:50.400
And finally,
I'd like to take some time

00:41:50.400 --> 00:41:52.601
to talk about background
applications on the phone

00:41:52.601 --> 00:41:55.501
and how they can do better
managing battery life.

00:41:55.501 --> 00:41:56.767
So first of all,
let's back up

00:41:56.767 --> 00:41:58.300
and talk about services
in general.

00:41:58.300 --> 00:41:59.968
If you come from a UNIX
or a Windows background,

00:41:59.968 --> 00:42:01.367
when we think of a service,

00:42:01.367 --> 00:42:03.100
we think of something
we start in the background

00:42:03.100 --> 00:42:05.501
and it continues to run,
almost like a daemon.

00:42:05.501 --> 00:42:07.367
So it's waiting for
a request to come in.

00:42:07.367 --> 00:42:09.033
It's running at all times.

00:42:09.033 --> 00:42:11.200
And that works really well
in the desktop world.

00:42:11.200 --> 00:42:12.734
but in the mobile world,

00:42:12.734 --> 00:42:14.400
each of those processes running,
each of those services

00:42:14.400 --> 00:42:16.701
has an overhead
associated with it.

00:42:16.701 --> 00:42:18.367
So say, for example,

00:42:18.367 --> 00:42:20.033
some of the devices
that first came out,

00:42:20.033 --> 00:42:22.767
say the HTC Dream device
that came out--

00:42:22.767 --> 00:42:25.000
when the system
finally boots...

00:42:25.000 --> 00:42:27.701
so we think we have
an amount of RAM on the system,

00:42:27.701 --> 00:42:29.167
and the system boots.

00:42:29.167 --> 00:42:30.934
We have an amount of RAM
that's reserved for the kernel

00:42:30.934 --> 00:42:32.234
and then we have some RAM

00:42:32.234 --> 00:42:33.701
that's reserved for
the Android framework.

00:42:33.701 --> 00:42:35.434
And when the device
finally finishes booting,

00:42:35.434 --> 00:42:39.133
we have roughly about
30 to 40 megabytes of actual RAM

00:42:39.133 --> 00:42:41.601
that applications--
that foreground applications

00:42:41.601 --> 00:42:45.200
and background apps
on the device can make use of.

00:42:45.200 --> 00:42:47.968
And something to be aware of--
that each process on the device,

00:42:47.968 --> 00:42:49.834
even if you're running
a lightweight service,

00:42:49.834 --> 00:42:52.734
takes somewhere around
2 megabytes of overhead

00:42:52.734 --> 00:42:54.467
just to start that
application,

00:42:54.467 --> 00:42:57.300
and that's just the foundation
of starting your app.

00:42:57.300 --> 00:42:59.667
If you're doing other things
on top of that,

00:42:59.667 --> 00:43:03.167
that's even more RAM
that you end up using.

00:43:03.167 --> 00:43:05.267
And then finally,
if you have a service

00:43:05.267 --> 00:43:07.200
that's running
in the background constantly,

00:43:07.200 --> 00:43:09.067
the system
will actually kill you.

00:43:09.067 --> 00:43:11.534
If the user is doing
some foreground task

00:43:11.534 --> 00:43:13.200
say like using the browser

00:43:13.200 --> 00:43:15.000
and the browser needs
more memory,

00:43:15.000 --> 00:43:16.667
it will go through
and kill off

00:43:16.667 --> 00:43:18.267
some of these background
services.

00:43:18.267 --> 00:43:20.267
And it will try restarting you
at a later time

00:43:20.267 --> 00:43:21.734
so you can continue
whatever work you were doing

00:43:21.734 --> 00:43:23.100
in the background.

00:43:23.100 --> 00:43:24.734
But again, that overhead
having to kill you

00:43:24.734 --> 00:43:26.701
and then come back
and restart you

00:43:26.701 --> 00:43:28.601
can really add up over time.

00:43:28.601 --> 00:43:30.300
Okay, so we asked the question,

00:43:30.300 --> 00:43:32.234
if we can't have
the service running

00:43:32.234 --> 00:43:33.734
at all times in the background,

00:43:33.734 --> 00:43:35.400
if we can't use a daemon model

00:43:35.400 --> 00:43:37.067
that works really well
on the desktop,

00:43:37.067 --> 00:43:39.000
how should we write services?

00:43:39.000 --> 00:43:40.901
There's two primary methods
that we can use.

00:43:40.901 --> 00:43:43.100
One is if you have a point
in the future,

00:43:43.100 --> 00:43:44.434
have a time in the future

00:43:44.434 --> 00:43:45.734
that you know you need
to wake up--

00:43:45.734 --> 00:43:47.367
say you're performing
an RSS feed update

00:43:47.367 --> 00:43:49.734
every 15 minutes
or half an hour--

00:43:49.734 --> 00:43:52.000
you can set an alarm
for the system to wake you up

00:43:52.000 --> 00:43:53.634
at that point in the future.

00:43:53.634 --> 00:43:56.300
And another method
is using a broadcast receiver,

00:43:56.300 --> 00:43:58.033
so it allows you
to be event-driven.

00:43:58.033 --> 00:44:00.601
So if the user moves between
network connections--

00:44:00.601 --> 00:44:02.300
for example,
if they're on an EDGE network

00:44:02.300 --> 00:44:03.968
and they transfer to a 3G,

00:44:03.968 --> 00:44:06.000
if they all of the sudden
get a 3G connection,

00:44:06.000 --> 00:44:07.300
on broadcast intents--

00:44:07.300 --> 00:44:09.367
the system sends out
broadcast intents

00:44:09.367 --> 00:44:12.601
that anyone interested
can pick up on and handle.

00:44:12.601 --> 00:44:13.968
So those are just two--

00:44:13.968 --> 00:44:15.467
I'll jump into those more
in detail--

00:44:15.467 --> 00:44:17.501
but those are
two of the methods

00:44:17.501 --> 00:44:19.501
that you should use
as writing services.

00:44:19.501 --> 00:44:20.868
And a final note is,
once you handle--

00:44:20.868 --> 00:44:22.501
if your service is woken up

00:44:22.501 --> 00:44:24.100
and you handle
one of these events,

00:44:24.100 --> 00:44:27.467
make sure to call stopSelf
if you're writing the service

00:44:27.467 --> 00:44:29.100
which tells the system
that you're finished

00:44:29.100 --> 00:44:30.501
with whatever work
you were doing,

00:44:30.501 --> 00:44:32.501
and the system
can kill your process.

00:44:32.501 --> 00:44:34.000
It's free to kill your process.

00:44:34.000 --> 00:44:38.100
So remember to stopSelf whenever
you're done processing data.

00:44:38.100 --> 00:44:39.501
So first, let's jump into
those two types,

00:44:39.501 --> 00:44:40.901
using AlarmManager,

00:44:40.901 --> 00:44:43.901
and then later we'll talk about
the broadcast intents.

00:44:43.901 --> 00:44:45.901
So first AlarmManager.

00:44:45.901 --> 00:44:47.734
If you have a point in time
in the future

00:44:47.734 --> 00:44:49.200
that you know you'd like
to wake up,

00:44:49.200 --> 00:44:53.501
you can have the system wake
you up to perform that action.

00:44:53.501 --> 00:44:56.100
So this--it allows you
to set a time, a specific time

00:44:56.100 --> 00:45:01.167
using the notion of an RTC
or a real-time clock.

00:45:01.167 --> 00:45:02.367
So if you're familiar with

00:45:02.367 --> 00:45:04.567
the concept of UNIX time
on Android,

00:45:04.567 --> 00:45:07.167
the RTC is the number
of seconds--

00:45:07.167 --> 00:45:11.167
the number of milliseconds
since the epoch, back in 1970.

00:45:11.167 --> 00:45:12.767
So you can specify
an exact time

00:45:12.767 --> 00:45:14.567
that you'd like the system
to wake you up

00:45:14.567 --> 00:45:17.133
to perform some action
in the future.

00:45:17.133 --> 00:45:19.100
You can also specify--
you can add in a flag.

00:45:19.100 --> 00:45:20.467
So here at the bottom,

00:45:20.467 --> 00:45:22.567
we're using
the AlarmManager.RTC flag.

00:45:22.567 --> 00:45:24.200
There's other flags
that we can use.

00:45:24.200 --> 00:45:26.267
We can use RTC_WAKEUP,

00:45:26.267 --> 00:45:28.767
and what that does,
that forces the device awake.

00:45:28.767 --> 00:45:31.133
So if we get to that point
in time

00:45:31.133 --> 00:45:33.167
and we absolutely need
the device to wake up--

00:45:33.167 --> 00:45:34.968
Let's say, for example,
we're writing an alarm clock.

00:45:34.968 --> 00:45:38.234
We need to wake up and tell
the user to get out of bed.

00:45:38.234 --> 00:45:40.767
We want to wake the device up
if it's sleeping,

00:45:40.767 --> 00:45:42.367
so we should use
a wake-up flag.

00:45:42.367 --> 00:45:44.000
Otherwise,
if we don't use that,

00:45:44.000 --> 00:45:46.767
the service will only start
at that point in the future

00:45:46.767 --> 00:45:48.367
if the system is already awake,

00:45:48.367 --> 00:45:50.100
if it's awake
handling other things

00:45:50.100 --> 00:45:54.400
on behalf of the user.

00:45:54.400 --> 00:45:56.200
So another thing
we introduced in Cupcake--

00:45:56.200 --> 00:45:58.267
we have the notion
of repeating alarms.

00:45:58.267 --> 00:45:59.534
We can set an alarm.

00:45:59.534 --> 00:46:01.000
Say you wanted
to update your RSS feed

00:46:01.000 --> 00:46:02.834
or you have a Twitter feed

00:46:02.834 --> 00:46:04.834
that you want to update
every 15 minutes or so.

00:46:04.834 --> 00:46:07.968
Currently, right now, the old
approach in the 1.1 SDK,

00:46:07.968 --> 00:46:09.934
you set a repeating alarm
and you set an interval.

00:46:09.934 --> 00:46:11.434
You set 15 minutes,

00:46:11.434 --> 00:46:13.534
and the system would actually
set those alarms.

00:46:13.534 --> 00:46:14.801
So here on the left-hand side,

00:46:14.801 --> 00:46:16.701
this is an example
of what it used to look like.

00:46:16.701 --> 00:46:17.934
Let's say you had a Twitter

00:46:17.934 --> 00:46:19.501
and a news app
and a mail application

00:46:19.501 --> 00:46:21.000
that all wanted to wake up,

00:46:21.000 --> 00:46:22.734
say every half hour,
in this case.

00:46:22.734 --> 00:46:26.100
So we would run into
the worst-case circumstance

00:46:26.100 --> 00:46:28.067
where the Twitter application
would wake up,

00:46:28.067 --> 00:46:29.734
and then the system would
fall back asleep,

00:46:29.734 --> 00:46:32.000
go into an idle state
for about ten minutes.

00:46:32.000 --> 00:46:34.601
And then the news application
would wake the device up

00:46:34.601 --> 00:46:35.934
and do an update

00:46:35.934 --> 00:46:37.934
and then fall back asleep
for another ten minutes.

00:46:37.934 --> 00:46:39.734
And then the mail application--

00:46:39.734 --> 00:46:41.334
you can see how
that's the worst case,

00:46:41.334 --> 00:46:43.400
all of these being spread out
across time.

00:46:43.400 --> 00:46:46.167
And the overhead associated
with waking up the system

00:46:46.167 --> 00:46:47.934
each time to go do
network activity

00:46:47.934 --> 00:46:50.734
and falling back asleep,
there's all that extra overhead.

00:46:50.734 --> 00:46:53.834
So something we introduced
in 1.5 is the notion--

00:46:53.834 --> 00:46:56.901
AlarmManager has a new method
called setinexactRepeating

00:46:56.901 --> 00:46:58.701
which allows you
as a developer,

00:46:58.701 --> 00:47:00.567
if you're willing
to be flexible

00:47:00.567 --> 00:47:02.801
with the time interval
that you're woken up with,

00:47:02.801 --> 00:47:05.834
if you say, I'm okay with being
woken up every 30 minutes-ish,

00:47:05.834 --> 00:47:08.434
if you're okay
being adjusted around,

00:47:08.434 --> 00:47:10.968
the system will offer
to bin you together.

00:47:10.968 --> 00:47:12.934
It will bin you together
with anyone else

00:47:12.934 --> 00:47:14.834
that's interested in updating
at the same interval.

00:47:14.834 --> 00:47:16.634
So in this case,
those three applications

00:47:16.634 --> 00:47:18.534
that they use
setinexactRepeating,

00:47:18.534 --> 00:47:19.801
the system would group them
all together.

00:47:19.801 --> 00:47:21.167
It would look and compare

00:47:21.167 --> 00:47:23.701
and group everyone together
to do one single update.

00:47:23.701 --> 00:47:26.200
It would wake up the device,
perform all three updates,

00:47:26.200 --> 00:47:28.200
and then fall asleep
for an entire half hour

00:47:28.200 --> 00:47:29.934
until the next set
of updates happened.

00:47:29.934 --> 00:47:32.601
So that's something to be
aware of in the 1.5 SDK

00:47:32.601 --> 00:47:36.834
if you're looking to do
some things in the background.

00:47:36.834 --> 00:47:39.601
[coughs]

00:47:39.601 --> 00:47:41.834
Okay, so that covers
AlarmManager.

00:47:41.834 --> 00:47:44.801
One of the other methods that
you can wake up from a service

00:47:44.801 --> 00:47:46.467
or wake your service up
is using the notion

00:47:46.467 --> 00:47:47.834
of broadcast intents.

00:47:47.834 --> 00:47:50.501
so the system--
here's just a couple examples

00:47:50.501 --> 00:47:52.767
that can be really useful
for developers.

00:47:52.767 --> 00:47:54.534
For example,
if the times aren't changed,

00:47:54.534 --> 00:47:56.501
if you're writing an application
that wakes the person up,

00:47:56.501 --> 00:47:57.934
maybe you're interested
in that

00:47:57.934 --> 00:47:59.434
or if you have
a calendar application.

00:47:59.434 --> 00:48:01.734
The second one is probably
one of the most important--

00:48:01.734 --> 00:48:03.000
ConnectivityManager.

00:48:03.000 --> 00:48:04.601
Something happened
with the network connection.

00:48:04.601 --> 00:48:06.501
We changed.
We were on EDGE before.

00:48:06.501 --> 00:48:07.968
Now we're connected to WiFi,

00:48:07.968 --> 00:48:10.033
or maybe we lost network
connection all together.

00:48:10.033 --> 00:48:11.667
Or maybe we didn't have
network connection,

00:48:11.667 --> 00:48:13.934
and now we're connected
to WiFi.

00:48:13.934 --> 00:48:15.767
 That broadcast intent,

00:48:15.767 --> 00:48:18.701
that ConnectivityManager.
Connectivity_Action

00:48:18.701 --> 00:48:20.000
is sent out by the system

00:48:20.000 --> 00:48:22.567
every time
the network state changes.

00:48:22.567 --> 00:48:24.400
So that's something
you can listen for.

00:48:24.400 --> 00:48:25.701
The same if you--

00:48:25.701 --> 00:48:27.167
Let's say you're holding
a cache on the device,

00:48:27.167 --> 00:48:29.067
and you're interested when
the device storage is low.

00:48:29.067 --> 00:48:30.734
Maybe you have a cache
that you can clean out

00:48:30.734 --> 00:48:32.100
to help make room
for the user.

00:48:32.100 --> 00:48:33.667
You can listen
for that broadcast.

00:48:33.667 --> 00:48:35.234
Or if you're doing
some background tasks,

00:48:35.234 --> 00:48:37.601
you can listen for
the battery low broadcast.

00:48:37.601 --> 00:48:39.534
So the system
will send this out

00:48:39.534 --> 00:48:42.400
at the same time that it shows
the notification to the user

00:48:42.400 --> 00:48:45.234
that they have 15%
of their battery left.

00:48:45.234 --> 00:48:47.100
If you're doing
some background tasks,

00:48:47.100 --> 00:48:49.300
you might fall asleep
during this period

00:48:49.300 --> 00:48:51.434
and wake yourself up
maybe a day later

00:48:51.434 --> 00:48:53.234
when you might have
more battery.

00:48:53.234 --> 00:48:56.767
So you could use that
to cancel some background tasks.

00:48:56.767 --> 00:48:59.067
So this is
one quick code snippet

00:48:59.067 --> 00:49:00.868
about how you'd register
for these.

00:49:00.868 --> 00:49:02.400
So just like we have
an activity

00:49:02.400 --> 00:49:05.167
or in our service definition
in our Android manifest,

00:49:05.167 --> 00:49:06.400
we define a receiver

00:49:06.400 --> 00:49:08.334
and then an intent filter
that matches

00:49:08.334 --> 00:49:12.033
any of those intents
that we're interested in.

00:49:12.033 --> 00:49:14.200
So part of the issue
is that ConnectivityManager

00:49:14.200 --> 00:49:16.133
actually happens a lot
on the device.

00:49:16.133 --> 00:49:17.634
As I was mentioning,

00:49:17.634 --> 00:49:19.467
if these were moving between
EDGE and WiFi,

00:49:19.467 --> 00:49:20.968
every single one
of those actions

00:49:20.968 --> 00:49:23.000
will wake up your service
because you've told the system

00:49:23.000 --> 00:49:24.901
that you're interested
in that update.

00:49:24.901 --> 00:49:26.567
It will wake you up every time.

00:49:26.567 --> 00:49:27.834
And the risk is that--

00:49:27.834 --> 00:49:29.701
let's say you're writing
an application

00:49:29.701 --> 00:49:32.868
that uploads video,
say to YouTube,

00:49:32.868 --> 00:49:34.501
on behalf of the user.

00:49:34.501 --> 00:49:36.634
If you register
for this broadcast,

00:49:36.634 --> 00:49:38.834
the risk
is that most of the time,

00:49:38.834 --> 00:49:41.868
the user isn't going to have
a video waiting in the queue

00:49:41.868 --> 00:49:43.000
to upload.

00:49:43.000 --> 00:49:45.300
They might not have
anything to do.

00:49:45.300 --> 00:49:48.434
So your process, your server,
your service that you're writing

00:49:48.434 --> 00:49:49.767
will be woken up

00:49:49.767 --> 00:49:51.667
for every one of these
connectivity change events,

00:49:51.667 --> 00:49:53.534
even when you don't have
anything to do.

00:49:53.534 --> 00:49:55.901
And that can cause
a lot of overhead.

00:49:55.901 --> 00:49:57.701
So one way to solve that

00:49:57.701 --> 00:49:59.234
is actually
enabling and disabling

00:49:59.234 --> 00:50:00.801
those manifest elements.

00:50:00.801 --> 00:50:02.467
So we define
the manifest element

00:50:02.467 --> 00:50:03.801
using that receiver tag.

00:50:03.801 --> 00:50:05.601
We can programmatically,
at run-time,

00:50:05.601 --> 00:50:07.133
enable and disable it,

00:50:07.133 --> 00:50:10.467
so we can get those broadcast
intents when we need them,

00:50:10.467 --> 00:50:11.701
when we need to know
about them,

00:50:11.701 --> 00:50:12.901
and we can turn them off

00:50:12.901 --> 00:50:15.067
when we know we wouldn't
be doing anything.

00:50:15.067 --> 00:50:16.534
So something like this--

00:50:16.534 --> 00:50:17.901
this is a code example
at the top here.

00:50:17.901 --> 00:50:19.734
We're starting with
enabled="false."

00:50:19.734 --> 00:50:22.801
We're not gonna receive
any of those broadcast actions.

00:50:22.801 --> 00:50:24.501
Then in the code later on,

00:50:24.501 --> 00:50:27.133
let's say the user has a video
that they're ready to upload.

00:50:27.133 --> 00:50:28.667
In that code,

00:50:28.667 --> 00:50:30.634
we can actually grab a copy
of the package manager

00:50:30.634 --> 00:50:34.067
and find the component name
for our broadcast receiver.

00:50:34.067 --> 00:50:35.868
And we can dynamically
enable it

00:50:35.868 --> 00:50:39.234
so that we start receiving
those broadcast intents

00:50:39.234 --> 00:50:41.000
so that as we're uploading
the video,

00:50:41.000 --> 00:50:43.601
we watch to see as the user
changes between WiFi

00:50:43.601 --> 00:50:46.634
to EDGE to 3G so that
we can handle it correctly.

00:50:46.634 --> 00:50:49.367
And then, the same code
works in the inverse case.

00:50:49.367 --> 00:50:50.868
Once we've finished uploading
everything

00:50:50.868 --> 00:50:52.200
on behalf of the user,

00:50:52.200 --> 00:50:54.467
we can go and disable
this manifest element again

00:50:54.467 --> 00:50:56.601
because we don't have anything
left in our upload queue,

00:50:56.601 --> 00:50:59.234
and we would just be
using system resources

00:50:59.234 --> 00:51:01.767
when we don't have anything
to upload.

00:51:01.767 --> 00:51:05.501
So this can really help us
be more efficient.

00:51:05.501 --> 00:51:07.534
Another thing that we can do
is, actually,

00:51:07.534 --> 00:51:09.133
we can check
the battery state.

00:51:09.133 --> 00:51:11.334
And this is a little bit
of a tricky code example.

00:51:11.334 --> 00:51:14.167
You can check to see the battery
percentage that's left.

00:51:14.167 --> 00:51:17.000
The system sends out
a broadcast intent,

00:51:17.000 --> 00:51:19.234
a sticky broadcast
that sticks around

00:51:19.234 --> 00:51:21.901
that you can catch that has
the current battery level,

00:51:21.901 --> 00:51:24.234
say it'd be like 40% or 45%.

00:51:24.234 --> 00:51:26.834
And so you might be interested
in getting that exact number

00:51:26.834 --> 00:51:28.601
so that you could do
some calculations.

00:51:28.601 --> 00:51:29.901
So if the user's on EDGE

00:51:29.901 --> 00:51:31.434
and they have more than
60% battery,

00:51:31.434 --> 00:51:33.567
maybe it's okay, and you wanna
go ahead with that.

00:51:33.567 --> 00:51:35.200
So this is a quick code snippet

00:51:35.200 --> 00:51:38.133
that would explain
how to go grab that broadcast.

00:51:38.133 --> 00:51:39.901
It's a little bit hard
to explain,

00:51:39.901 --> 00:51:41.801
and we're running
a little short on time,

00:51:41.801 --> 00:51:43.701
so we'll skip it for now.

00:51:43.701 --> 00:51:46.467
Okay, so we talked about
how we as developers

00:51:46.467 --> 00:51:48.801
can save battery,
both in terms of network,

00:51:48.801 --> 00:51:50.968
foreground apps,
and background apps.

00:51:50.968 --> 00:51:53.100
So now let's talk about
what's beyond 1.5,

00:51:53.100 --> 00:51:54.100
beyond Cupcake.

00:51:54.100 --> 00:51:56.434
What's coming next?

00:51:56.434 --> 00:51:57.968
So here I'd like to show
an example.

00:51:57.968 --> 00:52:00.801
This is actually in SpareParts
on Cupcake.

00:52:00.801 --> 00:52:02.567
It's not on your phones
that you got today,

00:52:02.567 --> 00:52:04.033
because those are
user builds.

00:52:04.033 --> 00:52:06.634
If you go home, you should
be able t flash your phones,

00:52:06.634 --> 00:52:08.767
re-flash your phones
with an engineering build

00:52:08.767 --> 00:52:10.200
which will give you root,

00:52:10.200 --> 00:52:12.767
and it will start collecting
battery statistics.

00:52:12.767 --> 00:52:14.901
So this is an example
of what that screen looks like.

00:52:14.901 --> 00:52:18.334
The system is actually
keeping track in 1.5 now

00:52:18.334 --> 00:52:20.467
of each of the applications
and how much they're doing

00:52:20.467 --> 00:52:22.801
with respect to various
pieces on the system.

00:52:22.801 --> 00:52:24.934
In this case, we're looking
at how much network activity

00:52:24.934 --> 00:52:26.701
each of the apps,
and we're tabulating,

00:52:26.701 --> 00:52:28.267
we're keeping these statistics.

00:52:28.267 --> 00:52:30.601
So it's something
that's not exposed just yet,

00:52:30.601 --> 00:52:32.701
but in future versions
down the road,

00:52:32.701 --> 00:52:35.267
this is something we'd like
to expose to end users.

00:52:35.267 --> 00:52:36.767
So they know, for instance,

00:52:36.767 --> 00:52:39.367
that "My device's battery
doesn't last very long.

00:52:39.367 --> 00:52:40.834
What can I do about it?"

00:52:40.834 --> 00:52:42.267
So this will be an answer.

00:52:42.267 --> 00:52:44.000
This will be a place
that they can go

00:52:44.000 --> 00:52:46.067
and actually check to see
who on their phone--

00:52:46.067 --> 00:52:48.033
which applications
are using battery.

00:52:48.033 --> 00:52:49.601
So this is something
that you guys can use

00:52:49.601 --> 00:52:51.334
as you're working and
debugging your applications,

00:52:51.334 --> 00:52:53.000
but it's also motivation.

00:52:53.000 --> 00:52:54.567
It's also motivation
to be aware

00:52:54.567 --> 00:52:56.534
that users will be watching
in the future,

00:52:56.534 --> 00:52:58.934
and they'll be able to see
which apps are using battery.

00:52:58.934 --> 00:53:00.701
And they'll actually
uninstall you,

00:53:00.701 --> 00:53:02.634
and then you won't be around.

00:53:02.634 --> 00:53:04.534
So one thing to keep in mind,
if you're writing apps,

00:53:04.534 --> 00:53:06.868
give your users flexibility.

00:53:06.868 --> 00:53:10.467
Say, for example, you're writing
a stock ticker application.

00:53:10.467 --> 00:53:12.434
Some of your users
may only be interested

00:53:12.434 --> 00:53:14.601
in getting updates
once or twice a day.

00:53:14.601 --> 00:53:16.634
But other users
may be really interested

00:53:16.634 --> 00:53:18.434
and want updates
every five minutes.

00:53:18.434 --> 00:53:22.033
So giving your users flexibility
on how much they want to update

00:53:22.033 --> 00:53:24.234
will make them less likely
to uninstall you.

00:53:24.234 --> 00:53:25.634
Because they have a choice.

00:53:25.634 --> 00:53:27.501
They have some control
over the amount of battery

00:53:27.501 --> 00:53:29.100
that your application is using

00:53:29.100 --> 00:53:32.968
if they can change preferences
inside of your app.

00:53:32.968 --> 00:53:34.567
So some overall takeaways

00:53:34.567 --> 00:53:36.300
about everything
we talked about today.

00:53:36.300 --> 00:53:38.834
First of all,
use an efficient data parser.

00:53:38.834 --> 00:53:42.400
Use one of those event
or pull-base parsers

00:53:42.400 --> 00:53:44.467
instead of a tree parser.

00:53:44.467 --> 00:53:46.734
Also use GZIP
to compress text data

00:53:46.734 --> 00:53:49.334
if you're sending a lot of
textual data to the phone

00:53:49.334 --> 00:53:52.300
so that you can save
network and CPU resources.

00:53:52.300 --> 00:53:55.100
Services that sleep or poll
are bad.

00:53:55.100 --> 00:53:58.400
So don't use the daemon
approach from the desktop.

00:53:58.400 --> 00:54:00.234
Instead, be event-driven.

00:54:00.234 --> 00:54:02.501
Set alarms for yourself
to wake up in the future

00:54:02.501 --> 00:54:04.534
and respond
to broadcast intents.

00:54:04.534 --> 00:54:06.267
Also disable
those manifest elements.

00:54:06.267 --> 00:54:07.968
If you're interested
in those broadcasts,

00:54:07.968 --> 00:54:09.834
disable them
when you wouldn't do anything.

00:54:09.834 --> 00:54:11.400
If the system
is just going to wake you up

00:54:11.400 --> 00:54:13.067
to look and decide

00:54:13.067 --> 00:54:15.334
that you're going to fall
back asleep again, disable it.

00:54:15.334 --> 00:54:17.634
Disable those manifest elements
in those cases.

00:54:17.634 --> 00:54:19.701
Also, wake up along
with everyone else.

00:54:19.701 --> 00:54:22.968
That's the set inexact alarms
repeating alarms.

00:54:22.968 --> 00:54:25.067
Also wait for a better network
or battery

00:54:25.067 --> 00:54:26.701
before you do bulk transfers,

00:54:26.701 --> 00:54:29.000
and possibly involve
the user in that process

00:54:29.000 --> 00:54:31.767
so that they know they can
go find WiFi somewhere to--

00:54:31.767 --> 00:54:33.501
if it's going to affect
their battery life.

00:54:33.501 --> 00:54:35.367
And finally,
give choices to the user

00:54:35.367 --> 00:54:37.300
about the background behavior
of your apps.

00:54:37.300 --> 00:54:38.934
It'll allow them to--

00:54:38.934 --> 00:54:41.033
you'll be much more friendly
towards users,

00:54:41.033 --> 00:54:43.567
because they have choices,
they have a choice now

00:54:43.567 --> 00:54:46.901
between how much battery
you're using in the background.

00:54:46.901 --> 00:54:48.901
So with that, that's about
all I had to talk about

00:54:48.901 --> 00:54:50.234
about battery life.

00:54:50.234 --> 00:54:51.400
It looks like we have just over

00:54:51.400 --> 00:54:53.434
five, six minutes left
for questions.

00:54:53.434 --> 00:54:55.467
So I'm gonna switch over
to Google Moderator,

00:54:55.467 --> 00:54:57.634
and then also feel free
to come up to the microphones

00:54:57.634 --> 00:54:59.067
to ask any of your questions.

00:54:59.067 --> 00:55:01.634
Then we'll alternate
back and forth

00:55:01.634 --> 00:55:04.667
between everything.

00:55:06.701 --> 00:55:08.467
Okay, so first question
on Moderator.

00:55:08.467 --> 00:55:10.200
Someone asked, "What happened
to the GoogleIO apps?

00:55:10.200 --> 00:55:11.601
I can't find it on market!"

00:55:11.601 --> 00:55:13.400
So over the weekend,
a couple friends and I

00:55:13.400 --> 00:55:15.467
wrote an application for
the schedule for the conference,

00:55:15.467 --> 00:55:17.133
and you can find it on market.

00:55:17.133 --> 00:55:19.400
You can only get it
on Cupcake devices.

00:55:19.400 --> 00:55:22.601
If you go to market and just
search for IO as a single word,

00:55:22.601 --> 00:55:25.734
you should be able
to find it.

00:55:25.734 --> 00:55:28.434
Let's take a live question
over here on the left.

00:55:28.434 --> 00:55:29.734
man: Yeah, real quick.

00:55:29.734 --> 00:55:31.167
You didn't mention
the overhead involved

00:55:31.167 --> 00:55:33.067
with UDP transmissions.

00:55:33.067 --> 00:55:34.567
How does that compare?

00:55:34.567 --> 00:55:36.200
Sharkey: Okay.
That's a good question.

00:55:36.200 --> 00:55:38.968
So, right, there's a little
more overhead TCP connections

00:55:38.968 --> 00:55:40.968
'cause we need to build up
the entire transaction.

00:55:40.968 --> 00:55:44.100
There's a syn-ack process
that happens between both ends.

00:55:44.100 --> 00:55:45.968
So there's more latency
involved.

00:55:45.968 --> 00:55:48.000
So there's a little more
setup time there.

00:55:48.000 --> 00:55:52.300
I would expect the UDP...
UDP is cheaper,

00:55:52.300 --> 00:55:53.767
but when you think about it,

00:55:53.767 --> 00:55:55.334
the devices are running
on mobile networks

00:55:55.334 --> 00:55:57.434
that are definitely
not as reliable,

00:55:57.434 --> 00:55:59.267
so UDP doesn't give you
any guarantees

00:55:59.267 --> 00:56:01.234
that your message actually got
to the other end.

00:56:01.234 --> 00:56:03.701
So most cases,
you do wanna use TCP

00:56:03.701 --> 00:56:05.534
just because you'll have
that guarantee

00:56:05.534 --> 00:56:07.000
that it made it across
the mobile network,

00:56:07.000 --> 00:56:08.234
which might be flaky.

00:56:08.234 --> 00:56:10.434
So UDP might offer you
some savings,

00:56:10.434 --> 00:56:11.834
but I'd say in the long run,

00:56:11.834 --> 00:56:14.567
you're probably gonna want
to go with TCP.

00:56:14.567 --> 00:56:16.434
Let's take a question
over on the right.

00:56:16.434 --> 00:56:18.133
man: Me?
Sharkey: Yeah, yeah.

00:56:18.133 --> 00:56:19.901
man: What about screen
brightness?

00:56:19.901 --> 00:56:21.601
How does that affect
the battery?

00:56:21.601 --> 00:56:23.701
Sharkey: So I took a peek
at that,

00:56:23.701 --> 00:56:25.567
so there's the 0% brightness
on the screen.

00:56:25.567 --> 00:56:28.067
You can turn it all the way
down so it's very, very dim.

00:56:28.067 --> 00:56:31.834
It ended up still taking
quite a bit of battery.

00:56:31.834 --> 00:56:33.234
I think it was about
70 milliamps

00:56:33.234 --> 00:56:34.467
at the lowest brightness.

00:56:34.467 --> 00:56:35.634
And part of that was because

00:56:35.634 --> 00:56:37.434
we're actually driving
the entire LCD.

00:56:37.434 --> 00:56:39.834
We have that refresh rate
of up to 60 hertz

00:56:39.834 --> 00:56:41.033
that we're pushing pixels,

00:56:41.033 --> 00:56:43.000
so there was a lot of cost
with that.

00:56:43.000 --> 00:56:44.501
And it was a little higher.

00:56:44.501 --> 00:56:47.234
I think it was about 100, 110
if we had it at 100% brightness.

00:56:47.234 --> 00:56:50.601
So roughly in that ballpark.

00:56:50.601 --> 00:56:52.334
So the sweet spot
that the device--

00:56:52.334 --> 00:56:54.133
someone asked the question
in the crowd,

00:56:54.133 --> 00:56:56.667
what is the sweet spot
for the display brightness?

00:56:56.667 --> 00:56:58.667
And the default one
that ships with the device

00:56:58.667 --> 00:57:00.300
that most users
don't change it from,

00:57:00.300 --> 00:57:02.701
that's the number
that I mentioned there,

00:57:02.701 --> 00:57:05.701
which is about 90 milliamps
that it ends up costing.

00:57:05.701 --> 00:57:07.534
That's right in the middle
of the road.

00:57:07.534 --> 00:57:09.567
Let's take a couple questions
from the Moderator,

00:57:09.567 --> 00:57:11.667
Someone asked, "Are there any
battery profiling tools

00:57:11.667 --> 00:57:13.100
out there?"

00:57:13.100 --> 00:57:15.133
And the short answer is,
sadly, no, there isn't.

00:57:15.133 --> 00:57:17.734
However, there's
a direct correlation

00:57:17.734 --> 00:57:20.901
between how much processing,
how much CPU you're using

00:57:20.901 --> 00:57:23.234
and the impact
on battery life.

00:57:23.234 --> 00:57:26.868
So if you're using tools--
so if you're using TraceView,

00:57:26.868 --> 00:57:29.334
which is one of the tools
that's distributed with the SDK

00:57:29.334 --> 00:57:31.901
to look at the amount of time
that your code is running,

00:57:31.901 --> 00:57:33.534
it allows you to do
method level tracing

00:57:33.534 --> 00:57:35.334
to see how many times
methods are called

00:57:35.334 --> 00:57:37.033
and how much time overall
your app is taking

00:57:37.033 --> 00:57:38.434
for certain operations.

00:57:38.434 --> 00:57:40.834
If you're using TraceView,
that's a good indicator

00:57:40.834 --> 00:57:43.167
of how much battery you're using
on the other side.

00:57:43.167 --> 00:57:45.601
So, sad to say, there aren't
any direct profiling tools

00:57:45.601 --> 00:57:48.767
kind of because
measuring milliamps

00:57:48.767 --> 00:57:51.467
is somewhat
of an electronic black art.

00:57:51.467 --> 00:57:52.901
You can't do it in software.

00:57:52.901 --> 00:57:55.634
You actually need specific
hardware to directly measure it.

00:57:55.634 --> 00:57:58.267
Take one more question
from Moderator.

00:57:58.267 --> 00:58:00.701
"How can you customize the power
management features of Android

00:58:00.701 --> 00:58:03.000
to enable more power modes?"

00:58:03.000 --> 00:58:06.534
So this is actually--
the base Android system

00:58:06.534 --> 00:58:08.501
doesn't come with very much
profile management,

00:58:08.501 --> 00:58:10.434
but this is a place we've
actually seen in the Market.

00:58:10.434 --> 00:58:12.601
Several apps have stepped up
to the challenge

00:58:12.601 --> 00:58:14.801
and written apps
that help the user

00:58:14.801 --> 00:58:16.200
manage their battery life.

00:58:16.200 --> 00:58:17.667
So, for example,

00:58:17.667 --> 00:58:19.601
Locale was one of the winners
of the first ADC

00:58:19.601 --> 00:58:22.434
which allows you to change
your network preferences

00:58:22.434 --> 00:58:25.400
to turn on WiFi when it sees
that you're getting near home

00:58:25.400 --> 00:58:27.200
and to turn Bluetooth off

00:58:27.200 --> 00:58:28.801
when you start getting
on the train,

00:58:28.801 --> 00:58:31.367
'cause you wanna listen to music
on your Bluetooth headset.

00:58:31.367 --> 00:58:34.234
So there's apps out there--
as of right now,

00:58:34.234 --> 00:58:35.334
I don't think
there's any plans

00:58:35.334 --> 00:58:36.834
of including that
in the platform.

00:58:36.834 --> 00:58:38.767
I think it's a niche
that third-party apps

00:58:38.767 --> 00:58:41.033
have filled very well.

00:58:41.033 --> 00:58:42.567
Let's take a question
from the right.

00:58:42.567 --> 00:58:46.434
man: I actually have
a question that's quite long.

00:58:46.434 --> 00:58:50.567
So one is--can you go back
to the slides of the sensor,

00:58:50.567 --> 00:58:52.400
the gaming side?

00:58:52.400 --> 00:58:56.167
So, uh...and how you
calculate--yes.

00:58:56.167 --> 00:58:58.367
How you calculated 10 milliamps.

00:58:58.367 --> 00:59:00.267
Actually, accelerometer itself

00:59:00.267 --> 00:59:03.400
only consume less than
half milliamps.

00:59:03.400 --> 00:59:06.033
And what is like a--
Sharkey: Right, right.

00:59:06.033 --> 00:59:07.367
Okay, so that's a good question.

00:59:07.367 --> 00:59:09.267
He's asking, the actual
sensor in the device uses--

00:59:09.267 --> 00:59:11.067
is very little power,

00:59:11.067 --> 00:59:12.934
the accelerometer in the device,
the hardware,

00:59:12.934 --> 00:59:14.934
the piece of hardware
that measures the accelerometer.

00:59:14.934 --> 00:59:16.834
That device
uses very little power,

00:59:16.834 --> 00:59:18.234
only a couple milliamps.

00:59:18.234 --> 00:59:19.667
The overhead
that we're seeing here,

00:59:19.667 --> 00:59:21.300
the cost between
these polling rates,

00:59:21.300 --> 00:59:24.734
is because the device
is shipping that information,

00:59:24.734 --> 00:59:26.767
those details,
the accelerometer,

00:59:26.767 --> 00:59:29.534
the actual measurements,
up into Java code.

00:59:29.534 --> 00:59:31.567
And that's where we start
to see the overhead.

00:59:31.567 --> 00:59:33.334
We have to marshal that
into the Java environment.

00:59:33.334 --> 00:59:34.968
And that's where we see
the overhead.

00:59:34.968 --> 00:59:37.334
That's where we start seeing
this battery life.

00:59:37.334 --> 00:59:38.767
So these battery measurements

00:59:38.767 --> 00:59:41.167
aren't strictly the cost
of running the accelerometer.

00:59:41.167 --> 00:59:43.601
They're the overhead of actually
having to pass that information

00:59:43.601 --> 00:59:45.400
back up into the Java world.

00:59:45.400 --> 00:59:50.534
man: Along that, so how you
think we can reduce that

00:59:50.534 --> 00:59:53.100
by like interrupt driven by--

00:59:53.100 --> 00:59:56.267
interrupt
for orientation detection

00:59:56.267 --> 00:59:58.300
and you can reduce
the traffic?

00:59:58.300 --> 01:00:00.734
Sharkey: Okay, so this--
man: So because...

01:00:00.734 --> 01:00:04.534
I think the sensor manager
in the Android

01:00:04.534 --> 01:00:06.067
do not take interrupt.

01:00:06.067 --> 01:00:08.501
Sharkey: Okay, right now
the sensor manager's

01:00:08.501 --> 01:00:10.033
just available from Java code,

01:00:10.033 --> 01:00:12.634
so we're stuck with
this overhead right now.

01:00:12.634 --> 01:00:14.434
With some of the other stuff

01:00:14.434 --> 01:00:17.033
that Dan Morrill was covering
this morning,

01:00:17.033 --> 01:00:18.868
talking about writing
native code,

01:00:18.868 --> 01:00:21.067
I don't know if there's efforts

01:00:21.067 --> 01:00:23.300
to have sensor manager available
in native code,

01:00:23.300 --> 01:00:25.367
but that would actually help
save some of this overhead.

01:00:25.367 --> 01:00:26.734
If you're writing C++ code

01:00:26.734 --> 01:00:28.234
that can look directly
at the sensor values,

01:00:28.234 --> 01:00:30.234
you can really help
save some battery.

01:00:30.234 --> 01:00:32.234
You don't have the overhead
of going all the way up to Java.

01:00:32.234 --> 01:00:33.734
Again, it's something
I'm not aware of

01:00:33.734 --> 01:00:35.234
that people are working on
right now,

01:00:35.234 --> 01:00:37.801
but it definitely would help
in the long run

01:00:37.801 --> 01:00:39.634
for game developers.

01:00:39.634 --> 01:00:41.868
Let's take a couple more
questions from Moderator,

01:00:41.868 --> 01:00:44.467
'cause these are the ones
that you guys have voted up

01:00:44.467 --> 01:00:46.067
over the course of the talk.

01:00:46.067 --> 01:00:47.667
Okay, someone asked
the question,

01:00:47.667 --> 01:00:50.100
"What is the rule of thumb
for employing caching of data

01:00:50.100 --> 01:00:51.901
"to avoid repeated data
transmissions

01:00:51.901 --> 01:00:53.934
and, consequently,
draining the battery?"

01:00:53.934 --> 01:00:55.634
I have about ten seconds left,

01:00:55.634 --> 01:00:58.334
so I'll quickly try to answer
this question.

01:00:58.334 --> 01:00:59.901
So on the device,

01:00:59.901 --> 01:01:02.667
probably the best place
to store a data cache

01:01:02.667 --> 01:01:04.334
is on the SD card.

01:01:04.334 --> 01:01:06.467
When you store it
in the internal directory,

01:01:06.467 --> 01:01:08.100
internal structure for your app,

01:01:08.100 --> 01:01:09.767
you're actually counting
against the space

01:01:09.767 --> 01:01:12.367
that the user could be
installing other apps into.

01:01:12.367 --> 01:01:15.334
So it's probably best
to use the SD card.

01:01:15.334 --> 01:01:16.968
You can also check
the SD card state

01:01:16.968 --> 01:01:19.634
using the environment object
in Java.

01:01:19.634 --> 01:01:22.968
With that, I think we're
about half a minute past time.

01:01:22.968 --> 01:01:24.367
I'd be happy to talk
with any of you guys.

01:01:24.367 --> 01:01:26.701
If you have questions
afterwards, come up and talk.

01:01:26.701 --> 01:01:28.467
Thanks for your time.

01:01:28.467 --> 01:01:31.400
[applause]

