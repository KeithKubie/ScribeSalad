WEBVTT
Kind: captions
Language: en

00:00:00.039 --> 00:00:01.080
SPEAKER 1: Hey, I'm Jens.

00:00:01.080 --> 00:00:04.680
I'm the senior rendering
engineer for Crytek,

00:00:04.680 --> 00:00:08.310
and I'm here to share a
bit of the experience what

00:00:08.310 --> 00:00:13.730
happens when you drop
Robinson on a mobile phone.

00:00:13.730 --> 00:00:17.610
Robinson is actually
a VR game that

00:00:17.610 --> 00:00:21.630
is about a little boy
stranded on a planet.

00:00:21.630 --> 00:00:28.680
And we published that
in 2016 for PS VR,

00:00:28.680 --> 00:00:33.360
and then later for fro
HTC Vive and Oculus Rift.

00:00:33.360 --> 00:00:36.000
So they're actually very
different platforms.

00:00:36.000 --> 00:00:38.190
The PS4 has the
UMA architecture,

00:00:38.190 --> 00:00:40.260
just like a mobile phone.

00:00:40.260 --> 00:00:44.370
And the other ones are PC.

00:00:44.370 --> 00:00:49.080
We had NUMA versus
UMA differences

00:00:49.080 --> 00:00:50.140
built into the engine.

00:00:50.140 --> 00:00:56.380
So when we tackled working
on the mobile phone,

00:00:56.380 --> 00:00:59.970
we didn't have to change very
much to get optimal streaming

00:00:59.970 --> 00:01:02.940
and stuff like that, because
memory management is very

00:01:02.940 --> 00:01:04.950
important, and you
don't want to copy

00:01:04.950 --> 00:01:11.550
stuff around which you already
have in your mobile device.

00:01:11.550 --> 00:01:15.300
For us, it was basically
a learning experience.

00:01:15.300 --> 00:01:23.040
We had the hope to support
GVR with Vulkan, which wasn't

00:01:23.040 --> 00:01:26.660
the case back then at GDC 2017.

00:01:26.660 --> 00:01:34.187
And still today, Vulkan has no
connection to any VR interface

00:01:34.187 --> 00:01:34.770
at the moment.

00:01:37.820 --> 00:01:44.260
The Android system
part of the Cry engine,

00:01:44.260 --> 00:01:48.860
we did need to touch,
because in 2015, for GDC,

00:01:48.860 --> 00:01:53.020
we made an equally
quick and dirty hack

00:01:53.020 --> 00:01:54.980
for our Crysis 3 MP--

00:01:54.980 --> 00:01:58.400
multi-player on a Tegra device.

00:01:58.400 --> 00:02:01.750
That Tegra device was
much more powerful

00:02:01.750 --> 00:02:08.539
than an Android mobile device,
and it ran on an open [? GN. ?]

00:02:08.539 --> 00:02:12.720
So basically that was an
exercise in orientation

00:02:12.720 --> 00:02:18.640
and evaluating how was the
performance of the GPU, what

00:02:18.640 --> 00:02:24.590
are the tools that we have,
and how we can improve on that.

00:02:24.590 --> 00:02:26.650
And I brought the demo.

00:02:34.560 --> 00:02:37.410
So this is an S7 Edge.

00:02:37.410 --> 00:02:47.620
I think it runs at 1920 by 1080.

00:02:47.620 --> 00:02:51.140
And this is our loading screen.

00:02:51.140 --> 00:02:57.380
And this is a sequence from
the beginning of the game.

00:02:57.380 --> 00:03:03.220
It's obviously not VR
because we don't want to--

00:03:03.220 --> 00:03:05.200
we had-- we don't
have the capability

00:03:05.200 --> 00:03:08.330
to write everything, which is
in the regular Oculus driver,

00:03:08.330 --> 00:03:11.460
both [INAUDIBLE] Chronos
missions, and hair tracking,

00:03:11.460 --> 00:03:14.220
and all of this which we
would have to make ourselves,

00:03:14.220 --> 00:03:17.770
which obviously is possible.

00:03:17.770 --> 00:03:20.730
By default, it's
on [? rayint, ?]

00:03:20.730 --> 00:03:25.800
and you can't hear
it sadly, but it

00:03:25.800 --> 00:03:29.310
actually Hicks, which was
this little AI in the boy

00:03:29.310 --> 00:03:33.490
with AI is talking
to us, and there

00:03:33.490 --> 00:03:42.146
are sounds in the background,
and for fun, we also made it--

00:03:42.146 --> 00:03:44.680
this is very difficult to see--

00:03:44.680 --> 00:03:51.675
made it react to the
orientation of the cell phone.

00:03:56.900 --> 00:04:00.620
It's kind of sad,
but I mean, you

00:04:00.620 --> 00:04:04.430
can come forward after
the talk, and then

00:04:04.430 --> 00:04:06.690
you can try it yourself.

00:04:06.690 --> 00:04:08.822
It's not a big deal.

00:04:08.822 --> 00:04:12.512
As you saw, It runs
about 45 frames

00:04:12.512 --> 00:04:13.970
per second, sometimes
a bit better,

00:04:13.970 --> 00:04:17.170
or sometimes a bit worse.

00:04:17.170 --> 00:04:20.019
We also experimented
with a Nexus 6P

00:04:20.019 --> 00:04:27.310
which was, I would say, a
failure in the Samsung S7.

00:04:27.310 --> 00:04:32.670
This is a version with an
Exynos, and a Mali T880.

00:04:32.670 --> 00:04:35.920
And the Nexus 6P
has an Adreno chip

00:04:35.920 --> 00:04:38.340
which has severe limitations.

00:04:38.340 --> 00:04:44.250
So it didn't work out very well.

00:04:44.250 --> 00:04:50.950
OK, so regarding Vulkan, we
reworked the entire Cryengine

00:04:50.950 --> 00:04:55.640
over the last years
to be more abstract.

00:04:55.640 --> 00:04:59.010
Initially, it was
entirely DX11 models,

00:04:59.010 --> 00:05:03.460
so even the GL renderer that
we used on the Tegra device

00:05:03.460 --> 00:05:09.970
was actually a DX11
to OpenGL translation.

00:05:09.970 --> 00:05:14.190
So this time we made everything
abstract in all the APIs

00:05:14.190 --> 00:05:18.190
that we are supporting, like 11
and 12, and Vulkan, and so on.

00:05:18.190 --> 00:05:22.310
It's natively integrated, and
has all the optimizations--

00:05:22.310 --> 00:05:26.562
PS4, Xbox, and so on.

00:05:26.562 --> 00:05:30.850
So this was not our
first attempt at Vulkan.

00:05:30.850 --> 00:05:36.380
Our PC version ran relatively
stable at that time,

00:05:36.380 --> 00:05:38.100
but it was our first attempt.

00:05:38.100 --> 00:05:40.250
And we're running Vulkan
on a mobile device.

00:05:43.570 --> 00:05:47.670
Our Android approach is SDL,
the open source project,

00:05:47.670 --> 00:05:51.540
and there was no Vulkan
support at that time.

00:05:51.540 --> 00:05:56.310
So I ripped out the entire
default OpenGL context

00:05:56.310 --> 00:05:59.030
initialization, which
happens by default,

00:05:59.030 --> 00:06:05.475
and used our regular Vk
surface and Vk swap-chain,

00:06:05.475 --> 00:06:12.130
a function ID that we had to
create the necessary Vulkan

00:06:12.130 --> 00:06:16.720
objects to run on
an Android window.

00:06:16.720 --> 00:06:20.800
When we ran it just like
that, a lot of bad things

00:06:20.800 --> 00:06:25.720
happened, and no validation
errors were generated.

00:06:29.890 --> 00:06:33.070
In the introspection
when we tried

00:06:33.070 --> 00:06:39.860
to find out what happened
on the Adreno chip,

00:06:39.860 --> 00:06:46.740
it only supported four
descriptor tables per stage,

00:06:46.740 --> 00:06:51.444
and stuff like that, without
any validation error when you

00:06:51.444 --> 00:06:55.080
turn on the validation data.

00:06:55.080 --> 00:06:57.660
Besides that, there
were tons of formats

00:06:57.660 --> 00:06:58.710
which were not supported.

00:06:58.710 --> 00:07:05.630
I mean, Robinson ran on
the regular PC GPUs, which

00:07:05.630 --> 00:07:08.050
all support block compression.

00:07:08.050 --> 00:07:11.720
So we had to find
corresponding mappings to EAC.

00:07:15.090 --> 00:07:17.520
Luckily the [? S ?] [? block ?]
[? field ?] was already

00:07:17.520 --> 00:07:25.340
in place because our OpenGL
implementation had all the EAC

00:07:25.340 --> 00:07:27.720
codings enabled.

00:07:27.720 --> 00:07:31.270
Then there were some
surprising fails.

00:07:31.270 --> 00:07:33.150
There were specific
SNORM targets

00:07:33.150 --> 00:07:36.720
which were [? unavailable. ?]
We mapped them

00:07:36.720 --> 00:07:41.790
to half float formats.

00:07:41.790 --> 00:07:46.180
There were some, I think,
[INAUDIBLE]---- both.

00:07:46.180 --> 00:07:49.947
I'm not sure which of them
didn't support 32-bit float--

00:07:49.947 --> 00:07:50.530
depth stencil.

00:07:53.790 --> 00:07:58.230
Then we had to go back to a D16.

00:07:58.230 --> 00:08:01.200
There was also a problem
getting something

00:08:01.200 --> 00:08:06.150
as basic as a [? RAD16, ?]
which was in the Tegra format--

00:08:06.150 --> 00:08:08.250
single-channel in
Tegra format, which

00:08:08.250 --> 00:08:11.040
would actually alias the D16.

00:08:11.040 --> 00:08:16.360
So we had problems
actually accessing this D16

00:08:16.360 --> 00:08:19.360
by aliasing the [INAUDIBLE].

00:08:19.360 --> 00:08:24.520
We didn't pick ASTC
over EAC because we just

00:08:24.520 --> 00:08:26.760
worked one month on it.

00:08:26.760 --> 00:08:28.910
[CHUCKLING]

00:08:28.910 --> 00:08:32.208
And it was just an
experiment, so it's not that.

00:08:32.208 --> 00:08:36.039
But we have to make the
whole feature list complete.

00:08:39.159 --> 00:08:44.620
So basically we ran
through the code

00:08:44.620 --> 00:08:51.760
and made a large part of
the code base flexible.

00:08:51.760 --> 00:08:55.840
There was the situation
where the [? regressive ?]

00:08:55.840 --> 00:08:59.140
swap-chain mode of
FIFO wasn't available,

00:08:59.140 --> 00:09:01.490
and we had to get to mailbox.

00:09:01.490 --> 00:09:04.315
There was a situation that
you ask for trigger buffering,

00:09:04.315 --> 00:09:06.580
and so that you get
three big buffers,

00:09:06.580 --> 00:09:09.880
and you actually got four.

00:09:09.880 --> 00:09:13.930
There was the problem with
the specific texture formats,

00:09:13.930 --> 00:09:21.060
and like for example
the Mali T880 on this S7

00:09:21.060 --> 00:09:24.460
doesn't have
anisotropic filtering.

00:09:24.460 --> 00:09:29.860
On the Adreno, we don't have
any cube arrays or 3D samplers,

00:09:29.860 --> 00:09:34.140
and when the geometry
shader and tesselation

00:09:34.140 --> 00:09:36.910
support is all over
the place, most of them

00:09:36.910 --> 00:09:42.660
basically don't support any of
that, and there's a problem--

00:09:42.660 --> 00:09:45.130
if you're from a
PC environment, you

00:09:45.130 --> 00:09:49.660
know that you always
can bind Adreno targets,

00:09:49.660 --> 00:09:53.680
and you basically have
unlimited descriptors,

00:09:53.680 --> 00:09:58.990
and/or you have 256 HLSA or
shader slots, and all of this

00:09:58.990 --> 00:10:01.780
is--

00:10:01.780 --> 00:10:03.520
the numbers are not very large.

00:10:03.520 --> 00:10:07.180
Most of the time it's
four [? inner ?] targets.

00:10:07.180 --> 00:10:09.850
Sometimes you have,
because of a [INAUDIBLE]

00:10:09.850 --> 00:10:13.100
run descriptor table, sometimes
you have three descriptor

00:10:13.100 --> 00:10:14.450
or four descriptor tables.

00:10:14.450 --> 00:10:19.570
So you have to keep
the engine running

00:10:19.570 --> 00:10:24.700
on all of these restrictions,
and just not quit and say, oh,

00:10:24.700 --> 00:10:27.700
sorry, you can't run.

00:10:27.700 --> 00:10:30.370
That is not
necessarily a problem

00:10:30.370 --> 00:10:36.010
to allow the system to
downcast the swap-chain modes.

00:10:36.010 --> 00:10:38.890
That's not a big deal if
you're using FIFO or mailbox,

00:10:38.890 --> 00:10:40.690
or something like that.

00:10:40.690 --> 00:10:44.650
You can write your code
so that the texture

00:10:44.650 --> 00:10:49.780
formats can downcast competitor
formats that are available.

00:10:49.780 --> 00:10:55.120
It's just you have to make a
lot of reflection on the device,

00:10:55.120 --> 00:10:57.640
and see what you can do.

00:10:57.640 --> 00:10:59.560
In the case if you
really need a 3D texture,

00:10:59.560 --> 00:11:02.370
it becomes a bit
complicated, but I

00:11:02.370 --> 00:11:05.545
mean, having
alternatives available--

00:11:05.545 --> 00:11:09.120
algorithmic alternatives--
is always a good thing.

00:11:11.690 --> 00:11:14.920
Our shaders are a lot.

00:11:14.920 --> 00:11:19.105
We have 45,000
lines of HLSL code.

00:11:22.360 --> 00:11:28.870
So when we supported
the OpenGL, we

00:11:28.870 --> 00:11:32.320
had a transcoder
that translated HLSL

00:11:32.320 --> 00:11:40.150
to GLSL, which was HLSLCC, which
was also used in [? Unity. ?]

00:11:40.150 --> 00:11:43.040
We heavily modified it.

00:11:43.040 --> 00:11:45.880
We added compute shader
support, and all kinds

00:11:45.880 --> 00:11:47.770
of different simpler
types of [? fonts, ?]

00:11:47.770 --> 00:11:52.130
and so on, so that the thing
became feature complete

00:11:52.130 --> 00:11:53.588
in the end, basically.

00:11:56.910 --> 00:12:01.480
The problem is that on the
Vulkan, GLSL is not GLSL.

00:12:01.480 --> 00:12:05.130
On the Vulkan, GLSL is
a Vulkan-specific GLSL

00:12:05.130 --> 00:12:08.350
with different imitations
and difference syntaxes,

00:12:08.350 --> 00:12:14.850
and so I had to go over
HLSLCC again, and make

00:12:14.850 --> 00:12:21.120
a lot of adjustments, like
how to pass metadata from HLSL

00:12:21.120 --> 00:12:25.620
to SPIR-V, because you want
to reflect on the SPIR-V.

00:12:25.620 --> 00:12:30.780
Basically this is an
exercise in [INAUDIBLE]

00:12:30.780 --> 00:12:38.670
So luckily this is over
because now we have,

00:12:38.670 --> 00:12:43.240
I think it's called DXC or DBC.

00:12:43.240 --> 00:12:46.540
We have a native HLSL
to SPIV-V translator

00:12:46.540 --> 00:12:49.690
which has been developed
by Chronos together

00:12:49.690 --> 00:12:52.640
with a few folks of Google.

00:12:52.640 --> 00:12:57.850
So this is not anymore.

00:12:57.850 --> 00:12:59.980
We don't repeat that.

00:13:02.800 --> 00:13:06.590
So we ran into a lot of
early adopter issues,

00:13:06.590 --> 00:13:11.990
even after we thought we
make everything right,

00:13:11.990 --> 00:13:14.680
and we adapt to all the
different parameters

00:13:14.680 --> 00:13:17.750
of these devices.

00:13:17.750 --> 00:13:20.830
Like we said, on the PC, it ran.

00:13:20.830 --> 00:13:24.230
There were no validation
errors on the devices.

00:13:24.230 --> 00:13:29.500
There were no validation
errors, but sometimes it

00:13:29.500 --> 00:13:33.610
was completely broken, or it
looked slightly different.

00:13:33.610 --> 00:13:35.980
Specific parts of it
looked different-- flickers

00:13:35.980 --> 00:13:39.190
or some constant
buffer, or they just

00:13:39.190 --> 00:13:44.292
weren't transferred to the
draw in the correct way

00:13:44.292 --> 00:13:45.250
or something like that.

00:13:45.250 --> 00:13:47.570
We don't know really
what happened there.

00:13:47.570 --> 00:13:51.880
So on the Adreno,
like I said, there

00:13:51.880 --> 00:13:54.250
was absolutely
keymap array support,

00:13:54.250 --> 00:13:56.500
so we limit that to one cubemap.

00:14:01.330 --> 00:14:06.280
There were problems with
the constant buffers,

00:14:06.280 --> 00:14:11.980
so we actually made big
areas in the shaders

00:14:11.980 --> 00:14:16.990
where we had coded lines, like
for example, for this demo.

00:14:16.990 --> 00:14:18.920
This is not because of
performance reasons.

00:14:18.920 --> 00:14:24.370
This is really because
the device or the driver

00:14:24.370 --> 00:14:27.100
just didn't do what
we told them to do.

00:14:31.010 --> 00:14:32.710
And then there was
a problem on Adreno

00:14:32.710 --> 00:14:34.510
which was relatively severe.

00:14:34.510 --> 00:14:37.300
We couldn't actually
target descriptor tables,

00:14:37.300 --> 00:14:41.770
so we bound one monstrous
descriptor table,

00:14:41.770 --> 00:14:45.790
and we dynamically offset
it with every [? draw ?]

00:14:45.790 --> 00:14:52.130
[? core, ?] which is a
solution on several--

00:14:52.130 --> 00:14:55.750
basically all of these solutions
just to make the demo running.

00:14:55.750 --> 00:14:59.020
I cannot recommend that
you try something like that

00:14:59.020 --> 00:15:02.960
for delivering a game.

00:15:02.960 --> 00:15:10.180
So after it ran with
the expected result,

00:15:10.180 --> 00:15:13.954
the next problem
was performance.

00:15:13.954 --> 00:15:19.030
Well, this is Robinson,
which means that our baseline

00:15:19.030 --> 00:15:22.422
performance is a PS4.

00:15:22.422 --> 00:15:28.340
And the subsequent releases
on Steam and on the Oculus

00:15:28.340 --> 00:15:32.600
were for PCs, which
means open-ended.

00:15:32.600 --> 00:15:35.460
You can run it on Titan,
so there were no problems.

00:15:38.270 --> 00:15:41.030
This is a comparison
between an S7 and a PS4,

00:15:41.030 --> 00:15:49.830
which is in some
ways very severe.

00:15:49.830 --> 00:15:58.910
Here the CPU is an Exynos
MP12, which is a 2.3 gigahertz

00:15:58.910 --> 00:16:00.532
four-core.

00:16:00.532 --> 00:16:03.470
It runs in big.LITTLE,
I think, so in theory we

00:16:03.470 --> 00:16:08.190
could have eight, but
we could only use four.

00:16:08.190 --> 00:16:10.550
These gigaflops
are without Neon.

00:16:10.550 --> 00:16:13.730
Neon is a vectorization
instruction

00:16:13.730 --> 00:16:17.360
for [? ARM, ?] which,
if you would use it,

00:16:17.360 --> 00:16:27.746
would quadruple the gigaflops,
which means you would be at 9.2

00:16:27.746 --> 00:16:32.710
versus 102.4 gigaflops.

00:16:32.710 --> 00:16:34.540
In this demo it's not
such a big problem

00:16:34.540 --> 00:16:36.490
because we don't have
any collision detection.

00:16:36.490 --> 00:16:40.280
We don't have any
complex CPU code.

00:16:40.280 --> 00:16:49.120
But if you would actually
try to calculate any of that,

00:16:49.120 --> 00:16:53.120
some problems would occur.

00:16:53.120 --> 00:16:55.810
The GPU is in a
similar ballpark.

00:16:55.810 --> 00:17:04.160
The Mali T880 has 260
gigahertz versus 1.8 teraflops

00:17:04.160 --> 00:17:06.920
of the PS4.

00:17:06.920 --> 00:17:14.786
Basically these gigaflops don't
necessarily mean that much.

00:17:14.786 --> 00:17:16.719
You also have
[? theorate ?] limitations.

00:17:16.719 --> 00:17:21.900
You have [? throughput ?]
limitations, and so on.

00:17:21.900 --> 00:17:27.800
So this is just like a
rough idea [? about ?] this.

00:17:27.800 --> 00:17:31.070
The biggest problem, actually,
even if it doesn't really

00:17:31.070 --> 00:17:35.150
look like that, is
the memory bandwidth.

00:17:35.150 --> 00:17:38.930
On the PS4, we have a GEDDR
5 [? shared ?] [? piece ?]

00:17:38.930 --> 00:17:45.980
between the CPU and GPU, and
on the S7, we have LDP DDR4,

00:17:45.980 --> 00:17:56.300
which is a low-power DDR4, which
is actually [? the bitrate, ?]

00:17:56.300 --> 00:18:01.330
so it's 28.7 gigabytes per
second versus was 176 gigabytes

00:18:01.330 --> 00:18:03.120
per second and this--

00:18:05.640 --> 00:18:09.720
because we're having-- we're
implementing deferred shading.

00:18:09.720 --> 00:18:11.960
We have a lot of
post-processing effects

00:18:11.960 --> 00:18:14.295
which are full-screen effects.

00:18:19.530 --> 00:18:22.260
The cost of everything
after the GBuffer

00:18:22.260 --> 00:18:24.240
is proportional
to the resolution.

00:18:26.850 --> 00:18:32.900
And the bandwidth cost is
proportional to the resolution

00:18:32.900 --> 00:18:34.040
as well.

00:18:34.040 --> 00:18:38.710
So you can run a
very small resolution

00:18:38.710 --> 00:18:45.670
and run the whole pipeline
or you have to make cuts.

00:18:45.670 --> 00:18:48.010
And then, there are
the thermal issues,

00:18:48.010 --> 00:18:51.210
which we completely ignored.

00:18:51.210 --> 00:18:57.510
But this device
behaves very nice.

00:18:57.510 --> 00:19:01.740
The [? take-around ?] that we
ran three years ago was running

00:19:01.740 --> 00:19:06.000
hot after five minutes
and was throttling,

00:19:06.000 --> 00:19:10.580
which didn't happen with
this, which was pretty nice.

00:19:10.580 --> 00:19:12.780
So the rendering
framework of Robinson

00:19:12.780 --> 00:19:17.340
is [INAUDIBLE] deferred shading.

00:19:17.340 --> 00:19:19.490
Pipeline.

00:19:19.490 --> 00:19:21.510
We're running
GBuffer pass, which

00:19:21.510 --> 00:19:28.380
means all the drawers are
writing out material attributes

00:19:28.380 --> 00:19:30.840
into different render targets.

00:19:30.840 --> 00:19:32.190
And we are storing depth.

00:19:32.190 --> 00:19:37.650
And then afterwards, we can
do all kinds of magic things

00:19:37.650 --> 00:19:43.190
with it, like AO, screen
space AO, or the lighting,

00:19:43.190 --> 00:19:45.185
or depth of field, motion blur.

00:19:45.185 --> 00:19:47.830
All of these things can
be done on this GBuffer.

00:19:52.020 --> 00:19:57.330
Here, we have three
[? bound ?] render targets.

00:19:57.330 --> 00:20:00.450
Each one is [INAUDIBLE]
8-bit, which

00:20:00.450 --> 00:20:06.080
means we have about 24
bites in 3 render targets.

00:20:06.080 --> 00:20:09.880
And it's relative
[? filler rate ?] heavy.

00:20:09.880 --> 00:20:15.270
It gives us a lot of the
capacities of the [INAUDIBLE]..

00:20:15.270 --> 00:20:22.830
And if you look at the pure
memory bandwidth occupation,

00:20:22.830 --> 00:20:26.490
just looking at
it, that's about--

00:20:26.490 --> 00:20:27.960
almost a gigabyte per second.

00:20:27.960 --> 00:20:30.900
You can just look 28
times [? and set your ?]

00:20:30.900 --> 00:20:33.550
buffer on a mobile
device, and then you

00:20:33.550 --> 00:20:35.850
eat up all your bandwidth.

00:20:35.850 --> 00:20:38.730
So that is pretty problematic.

00:20:38.730 --> 00:20:43.620
That is just one 2560 by 1440.

00:20:43.620 --> 00:20:46.110
So we had to find
an alternative.

00:20:46.110 --> 00:20:47.610
In the beginning,
we experimented

00:20:47.610 --> 00:20:49.880
with 4-bit render targets.

00:20:49.880 --> 00:20:51.450
These are 8-bit
render targets that

00:20:51.450 --> 00:20:54.990
would then go to 12, 12-bit.

00:20:54.990 --> 00:20:57.990
But we still would be
[INAUDIBLE] because we still

00:20:57.990 --> 00:21:00.540
have three render targets bound.

00:21:00.540 --> 00:21:10.015
So our idea was we reduced
the entire three render target

00:21:10.015 --> 00:21:17.910
GBuffer to a single
4-component render target.

00:21:17.910 --> 00:21:20.650
In a previous
version of crisis--

00:21:20.650 --> 00:21:21.820
[COUGHING]

00:21:21.820 --> 00:21:23.730
Excuse me.

00:21:23.730 --> 00:21:29.230
We already employed
a technique that we

00:21:29.230 --> 00:21:32.305
are storing some
information just on even

00:21:32.305 --> 00:21:34.750
and [? alternating ?]
information

00:21:34.750 --> 00:21:44.550
on odd pixels, which resides
in the half-size rendering.

00:21:44.550 --> 00:21:48.500
Not a quarter-size rendering,
but a half-size rendering.

00:21:48.500 --> 00:21:52.810
Here, we store albedo
at full resolution.

00:21:52.810 --> 00:22:01.250
So the basic non-metallic
surface color

00:22:01.250 --> 00:22:02.900
is full resolution.

00:22:02.900 --> 00:22:08.220
And then, we are storing normal
smoothness and reflectance

00:22:08.220 --> 00:22:12.130
at [? alternating ?]
positions, like you'll

00:22:12.130 --> 00:22:16.616
see in the little square there.

00:22:16.616 --> 00:22:19.580
The reflectance is non-color.

00:22:19.580 --> 00:22:22.060
We could get away
with it in this demo,

00:22:22.060 --> 00:22:24.905
but normally you
would actually want

00:22:24.905 --> 00:22:31.430
to have color to reflectance,
which needs more time.

00:22:31.430 --> 00:22:37.860
So we just wanted to
see, how fast could we

00:22:37.860 --> 00:22:44.580
get CRYENGINE running
without major modifications?

00:22:44.580 --> 00:22:52.610
Can we actually get into the
direction of VR performance?

00:22:52.610 --> 00:22:57.410
So here, we have examples
of this tiny micro GBuffer.

00:22:57.410 --> 00:23:00.780
So there are the
three render targets.

00:23:00.780 --> 00:23:03.070
The upper one is the rgb
part and the lower one

00:23:03.070 --> 00:23:03.880
is the a part.

00:23:03.880 --> 00:23:08.470
So really, just
three render targets.

00:23:08.470 --> 00:23:12.410
And everything, all these
six things, are in those two.

00:23:15.145 --> 00:23:20.870
If you zoom a bit
nearer, you see the cost.

00:23:20.870 --> 00:23:22.370
The cost is that--
of course, you're

00:23:22.370 --> 00:23:24.990
under-sampling your edges.

00:23:24.990 --> 00:23:30.830
You sometimes see that every
even/odd line just forms

00:23:30.830 --> 00:23:33.440
a diagonal, except--

00:23:33.440 --> 00:23:36.230
instead of like the
regular diagonal

00:23:36.230 --> 00:23:39.640
that you have in the
full-resolution GBuffer.

00:23:42.880 --> 00:23:44.920
The meaning of the
[? alternating ?] pixels

00:23:44.920 --> 00:23:46.890
here is also not
always the same.

00:23:46.890 --> 00:23:51.920
So it's a bit difficult
to label this.

00:23:51.920 --> 00:23:57.440
It's just that you get the
idea of what's the price.

00:23:57.440 --> 00:24:00.150
We actually have an edge
where reconstruction

00:24:00.150 --> 00:24:06.760
of this in the
lighting [? pass, ?]

00:24:06.760 --> 00:24:09.190
it comes out in
acceptable quantity.

00:24:12.140 --> 00:24:16.740
In other areas,
like we render HDR.

00:24:16.740 --> 00:24:20.550
And we [? tone up ?]
the HDR later.

00:24:20.550 --> 00:24:24.810
The bandwidth savings
we reach by reducing

00:24:24.810 --> 00:24:29.560
the precision of the HDR
buffer from regular halves

00:24:29.560 --> 00:24:35.170
to 11-bit halves.

00:24:35.170 --> 00:24:40.300
Even lower precision floating
point representations.

00:24:40.300 --> 00:24:46.000
We kicked [? stencil ?] out so
that we could use D16 instead

00:24:46.000 --> 00:24:49.900
of [? D24S8. ?]

00:24:49.900 --> 00:24:56.530
And Robinson as a VR
game, already provides

00:24:56.530 --> 00:24:57.470
a lot of effects.

00:24:57.470 --> 00:24:59.200
We don't have depth of field.

00:24:59.200 --> 00:25:03.510
We don't have motion blur
because all of this stuff just

00:25:03.510 --> 00:25:09.130
in the VR environment breaks
the illusion that you are really

00:25:09.130 --> 00:25:09.880
in the scene.

00:25:09.880 --> 00:25:11.340
It breaks immersiveness.

00:25:11.340 --> 00:25:22.860
So we had to turn off a lot
of the additional nice-making

00:25:22.860 --> 00:25:25.560
post-processing effects, like
the subsurface scattering

00:25:25.560 --> 00:25:28.986
because it requires
space in the GBuffer.

00:25:28.986 --> 00:25:33.030
We also don't have any
screen space reflection

00:25:33.030 --> 00:25:36.170
because it eats way
too much bandwidth.

00:25:36.170 --> 00:25:43.430
It's basically ray tracing
rays in screen space, which

00:25:43.430 --> 00:25:48.500
probably eats up the entire
bandwidth that we have.

00:25:48.500 --> 00:25:50.790
No volumetric fog.

00:25:50.790 --> 00:25:53.500
That's a 3D texture.

00:25:53.500 --> 00:25:56.680
Back then, we wouldn't
have had an alternative,

00:25:56.680 --> 00:25:58.780
like two-dimensional fog
or something like that.

00:26:01.750 --> 00:26:03.910
Like I said, of all the
other [INAUDIBLE] effects,

00:26:03.910 --> 00:26:06.730
we only needed tone mapping
and the vignette effect,

00:26:06.730 --> 00:26:11.890
so that you have the simulation
of a reduced field of view.

00:26:11.890 --> 00:26:17.590
And we made one uber
shader out of that,

00:26:17.590 --> 00:26:21.280
which looking at
the bandwidth is,

00:26:21.280 --> 00:26:26.750
I think, the correct
suggestion that you merge

00:26:26.750 --> 00:26:29.040
all your post-processing,
all your screen space

00:26:29.040 --> 00:26:32.460
passes, if possible,
into one big shader

00:26:32.460 --> 00:26:38.500
because the [? ALU ?]
capacity of the mobile GPU

00:26:38.500 --> 00:26:41.170
is way above the bandwidth.

00:26:41.170 --> 00:26:44.370
So instead of read/write,
read/write, read/write,

00:26:44.370 --> 00:26:46.600
it's better to just
read once, and then

00:26:46.600 --> 00:26:50.560
drop 5,000 instruction shader,
and then only write once.

00:26:54.360 --> 00:26:54.860
All right.

00:26:54.860 --> 00:27:01.505
So our conclusion of the project
regarding games on Android.

00:27:04.030 --> 00:27:12.320
The effort to make Vulkan run on
the mobile platform from our PC

00:27:12.320 --> 00:27:16.045
platform was
relative [? minor. ?]

00:27:16.045 --> 00:27:20.270
We were four people
working one month on it.

00:27:20.270 --> 00:27:25.910
So you could basically say
one of us worked one month

00:27:25.910 --> 00:27:34.010
on polishing all the problematic
cases of Vulkan on mobile.

00:27:34.010 --> 00:27:40.160
The biggest problem is the
variety of targetable hardware.

00:27:40.160 --> 00:27:41.780
Like we had in the
talks before, you

00:27:41.780 --> 00:27:44.540
can make a business
decision, like it's not

00:27:44.540 --> 00:27:47.860
viable to target this
and that much hardware.

00:27:47.860 --> 00:27:49.360
But as a software
engineer, you also

00:27:49.360 --> 00:27:54.150
have the problem there's
tons of hardware,

00:27:54.150 --> 00:27:56.490
which is almost equivalent.

00:27:56.490 --> 00:27:58.790
And there's just one
checkbox missing, or here's

00:27:58.790 --> 00:28:00.380
just one checkbox missing.

00:28:00.380 --> 00:28:02.954
So you have to write your
engine relative flexible

00:28:02.954 --> 00:28:04.370
that you can adapt
yourself to it.

00:28:09.070 --> 00:28:18.800
We also didn't really believe if
we would render this in stereo,

00:28:18.800 --> 00:28:23.720
then we would be at
20 fps maybe, which

00:28:23.720 --> 00:28:31.710
is way below what is supportable
by a [? personal ?] VR device.

00:28:31.710 --> 00:28:34.290
But if you didn't really
expect that to happen.

00:28:34.290 --> 00:28:38.720
But basically, if we
have GPU that is twice

00:28:38.720 --> 00:28:44.600
as powerful as a
[INAUDIBLE],, then we actually

00:28:44.600 --> 00:28:50.200
might get into the direction
of having something like this

00:28:50.200 --> 00:28:51.860
in VR on a mobile device.

00:28:54.690 --> 00:28:57.470
We were very happy
that in principle, it

00:28:57.470 --> 00:29:03.680
was possible to run a fully
physically-based shading

00:29:03.680 --> 00:29:08.560
pipeline on the mobile device
with actual [INAUDIBLE]

00:29:08.560 --> 00:29:11.150
deferred rendering
and forward plus.

00:29:11.150 --> 00:29:17.060
And while I didn't observe
any compute queue in Vulkan

00:29:17.060 --> 00:29:18.890
on any of these
tested devices, I'm

00:29:18.890 --> 00:29:24.800
pretty sure that the modern
mobile devices are coming up

00:29:24.800 --> 00:29:31.130
with a compute queue
earlier than later.

00:29:31.130 --> 00:29:37.500
Vulkan is very well-positioned
because the CPU overhead

00:29:37.500 --> 00:29:39.330
is very low.

00:29:39.330 --> 00:29:43.770
You have a lot of possibility
to control your GPU performance.

00:29:43.770 --> 00:29:47.730
You can submit stuff
in different ways.

00:29:47.730 --> 00:29:55.340
That's contrary to openGL,
which is a very large black box.

00:29:55.340 --> 00:29:58.720
It's difficult to
optimize for it.

00:29:58.720 --> 00:30:01.630
Because I mean, the
driver can make something,

00:30:01.630 --> 00:30:03.220
and then you don't
know about it.

00:30:03.220 --> 00:30:07.330
And everything you
did was in vain.

00:30:07.330 --> 00:30:10.591
While for Vulkan, everything
is relative well-defined.

00:30:13.180 --> 00:30:14.860
The conclusion for
Vulkan on Android.

00:30:17.680 --> 00:30:20.900
Well, I already
announced a few of those.

00:30:23.430 --> 00:30:26.930
The good part is that
in Vulkan, you can

00:30:26.930 --> 00:30:28.250
do multi-threader rendering.

00:30:28.250 --> 00:30:35.980
Our entire renderer is actually
submitting the big scene

00:30:35.980 --> 00:30:38.050
graphs in a multi-threaded way.

00:30:40.810 --> 00:30:44.000
This is very, very
difficult in openGL.

00:30:44.000 --> 00:30:46.270
You can open
concurrent contexts,

00:30:46.270 --> 00:30:50.970
but I wouldn't suggest it.

00:30:50.970 --> 00:30:55.170
It's probably not worth it.

00:30:55.170 --> 00:30:59.520
What's very nice is
actually, the renderer

00:30:59.520 --> 00:31:05.380
sub-passes of Vulkan, which
requires huge refactoring

00:31:05.380 --> 00:31:06.800
of your engine.

00:31:06.800 --> 00:31:16.970
It basically means that
little tiles of your shader

00:31:16.970 --> 00:31:20.320
run once through
the whole process.

00:31:20.320 --> 00:31:24.580
Let's say you have 10 passes.

00:31:24.580 --> 00:31:29.170
So then, this tile
is run 10 times.

00:31:29.170 --> 00:31:32.150
And then, another tile is
run 10 times, and so on.

00:31:32.150 --> 00:31:35.800
So you are having the
possibility in the driver

00:31:35.800 --> 00:31:40.630
to actually merge parts of
that using optimal memory I/O

00:31:40.630 --> 00:31:43.450
and stuff like that.

00:31:43.450 --> 00:31:49.170
But that requires
making dedicated changes

00:31:49.170 --> 00:31:52.330
in the architecture.

00:31:52.330 --> 00:31:58.960
So at the end, I want to thank
everyone who participated.

00:31:58.960 --> 00:32:07.345
Alex, myself, Theo, Mathjs,
Nico, and the other Nico.

00:32:07.345 --> 00:32:12.620
And without the guys
working on these tools,

00:32:12.620 --> 00:32:15.650
almost nothing of this
would have been possible.

00:32:15.650 --> 00:32:22.420
HLSLcc is an open
source project, which

00:32:22.420 --> 00:32:26.370
we could manipulate, give back.

00:32:26.370 --> 00:32:31.015
Spirv-cross is, I
think, from Khronos now.

00:32:34.660 --> 00:32:37.880
SDL2, standard stuff
since [INAUDIBLE]..

00:32:37.880 --> 00:32:44.500
And we have properly used a few
more open source tool chains

00:32:44.500 --> 00:32:47.410
to make all this weird
stuff happen where we don't

00:32:47.410 --> 00:32:49.540
have any official support.

00:32:49.540 --> 00:32:53.760
And special thanks to Lei
Zhang and Ehsan Nasiri,

00:32:53.760 --> 00:32:57.670
who are actually
from Google, I think.

00:32:57.670 --> 00:33:02.110
They are working on the DXC,
which is this new SPIR-V

00:33:02.110 --> 00:33:08.770
backend which removes all
the problematic things

00:33:08.770 --> 00:33:09.475
with shaders.

00:33:14.530 --> 00:33:16.290
Crytek is hiring.

00:33:16.290 --> 00:33:21.420
So if you want to work on
mobile for the CRYENGINE,

00:33:21.420 --> 00:33:22.518
write us an email.

00:33:26.910 --> 00:33:27.886
Questions?

00:33:34.230 --> 00:33:37.646
AUDIENCE: Question about
the [INAUDIBLE] mentioned.

00:33:37.646 --> 00:33:41.320
Because it looks to
me that most of--

00:33:41.320 --> 00:33:43.070
some of your bandwidth
problems could

00:33:43.070 --> 00:33:48.250
be alleviated by not spilling
the tile after every pass.

00:33:48.250 --> 00:33:50.750
And you mentioned that
that would require

00:33:50.750 --> 00:33:54.010
a retexturing of the engine.

00:33:54.010 --> 00:33:57.310
Is that a problem of
resources in a sense

00:33:57.310 --> 00:34:00.440
that it could take you a long
time to [INAUDIBLE] the engine?

00:34:00.440 --> 00:34:02.470
Or is it a problem
of the API that

00:34:02.470 --> 00:34:04.550
is not making your life easier?

00:34:04.550 --> 00:34:06.350
SPEAKER 1: No.

00:34:06.350 --> 00:34:10.440
The problem is that the last
missing piece in the CRYENGINE

00:34:10.440 --> 00:34:13.989
is that we don't
have render graph.

00:34:13.989 --> 00:34:19.480
The big API makers are
evangelizing the idea

00:34:19.480 --> 00:34:28.909
that you submit the whole
framework as a render graph.

00:34:28.909 --> 00:34:34.659
And if you generate the render
graph dynamically every frame,

00:34:34.659 --> 00:34:36.719
like you don't write
the render graph in code

00:34:36.719 --> 00:34:38.710
in your [? CPP ?]
and it's static.

00:34:38.710 --> 00:34:41.545
If you have a manager
that generates a render

00:34:41.545 --> 00:34:44.590
graph every frame to
schedule all of this,

00:34:44.590 --> 00:34:49.389
then you can actually generate
render sub-passes for Vulkan

00:34:49.389 --> 00:34:52.170
automagically because
you have to specify,

00:34:52.170 --> 00:34:55.600
OK, this is an input.

00:34:55.600 --> 00:34:57.560
Which status this
input is [INAUDIBLE]..

00:34:57.560 --> 00:34:58.250
Is this cleared?

00:34:58.250 --> 00:35:01.620
Do I read from it?

00:35:01.620 --> 00:35:03.600
Is it a [INAUDIBLE]
write, and so on?

00:35:03.600 --> 00:35:07.570
So you have to annotate
a lot of the [INAUDIBLE]

00:35:07.570 --> 00:35:11.350
that you use generating
sub-passes in Vulkan.

00:35:11.350 --> 00:35:16.920
And it's not recommendable
to make this manually.

00:35:16.920 --> 00:35:19.810
So you have to have
an automated system

00:35:19.810 --> 00:35:25.690
to generate render graphs
in data, in memory.

00:35:25.690 --> 00:35:27.464
And then, it's a
[? trivial ?] thing.

00:35:27.464 --> 00:35:29.005
AUDIENCE: So it's
a high-level issue?

00:35:29.005 --> 00:35:30.671
SPEAKER 1: Yes, it's
a high-level issue.

00:35:30.671 --> 00:35:31.636
AUDIENCE: [INAUDIBLE].

00:35:36.250 --> 00:35:37.900
And then, move
onto the next tile?

00:35:37.900 --> 00:35:38.610
SPEAKER 1: Yeah.

00:35:38.610 --> 00:35:39.730
AUDIENCE: [INAUDIBLE].

00:35:39.730 --> 00:35:43.240
SPEAKER 1: Yeah, that's
even independent.

00:35:43.240 --> 00:35:47.830
In Vulkan, you have
the possibility--

00:35:47.830 --> 00:35:50.500
like what we saw in
these capture tools,

00:35:50.500 --> 00:35:53.640
you had the render
targets where you write to

00:35:53.640 --> 00:35:56.500
and you have the
depth [INAUDIBLE]..

00:35:56.500 --> 00:36:00.250
And if you express something
at sub-passes in Vulkan,

00:36:00.250 --> 00:36:04.120
you're basically
describing a chain

00:36:04.120 --> 00:36:07.400
of shaders, how they
interact with each other,

00:36:07.400 --> 00:36:12.170
how they are feeding
data from one shader

00:36:12.170 --> 00:36:14.200
pass to a next shader pass.

00:36:14.200 --> 00:36:17.390
It's similar to how we
describe at the shader

00:36:17.390 --> 00:36:20.480
stages between vertex
shader and pixel shader,

00:36:20.480 --> 00:36:23.930
and how they're interacting
with each other in the data

00:36:23.930 --> 00:36:25.340
transportation way.

00:36:25.340 --> 00:36:28.910
So on Vulkan, you have
one step above that.

00:36:28.910 --> 00:36:36.270
So that you are basically
putting entire [? drawers ?]

00:36:36.270 --> 00:36:40.050
into relation to subsequent
[? draws. ?] And that brings

00:36:40.050 --> 00:36:42.090
a lot of performance.

00:36:42.090 --> 00:36:44.290
Can potentially bring
a lot of performance,

00:36:44.290 --> 00:36:48.900
like we have the imagination
ships, which are actually

00:36:48.900 --> 00:36:54.130
ships which have hardware
support for this mechanism.

00:36:54.130 --> 00:36:56.040
So it doesn't spill to memory.

00:36:56.040 --> 00:37:01.810
We have this problem
that LPDDR4 is very slow.

00:37:01.810 --> 00:37:05.070
So the imagination ship
has an [INAUDIBLE] buffer,

00:37:05.070 --> 00:37:11.460
where he spills the data between
the different sub-passes,

00:37:11.460 --> 00:37:12.660
not into main memory.

00:37:12.660 --> 00:37:16.800
He spills into a special,
dedicated piece of hardware.

00:37:16.800 --> 00:37:23.540
And you can maybe get away
with 10 times speedup by that.

00:37:23.540 --> 00:37:26.920
The bandwidth of this
internal area of the chip

00:37:26.920 --> 00:37:28.500
is 10 times faster than LPDDR4.

00:37:43.020 --> 00:37:46.410
AUDIENCE: You mentioned
texture formats.

00:37:46.410 --> 00:37:51.090
Did you guys use ETC2, or did
you find that not sufficient?

00:37:51.090 --> 00:37:52.557
I mean, in [? SATC. ?]

00:37:52.557 --> 00:37:53.140
SPEAKER 1: No.

00:37:53.140 --> 00:37:54.710
For is, it's not sufficient.

00:37:54.710 --> 00:37:57.660
We are almost using every
texture format under the sun.

00:38:00.770 --> 00:38:04.234
AUDIENCE: I believe that's the
only one across all Android.

00:38:04.234 --> 00:38:04.900
SPEAKER 1: Yeah.

00:38:04.900 --> 00:38:12.810
No, there are weird
permutations of ETC2,

00:38:12.810 --> 00:38:20.020
which provide one-channel,
two-channel, and additional bit

00:38:20.020 --> 00:38:22.720
depths until 11-bit.

00:38:22.720 --> 00:38:25.264
And we are using all
of those [INAUDIBLE]..

00:38:25.264 --> 00:38:26.130
Yeah.

00:38:26.130 --> 00:38:29.370
AUDIENCE: And are
you going to continue

00:38:29.370 --> 00:38:30.550
with your experimentation?

00:38:30.550 --> 00:38:34.170
Are you going to wait for mobile
to get a little bit better?

00:38:40.670 --> 00:38:42.850
SPEAKER 1: Maybe it
depends on how fast

00:38:42.850 --> 00:38:45.370
openXR is going to finalize.

00:38:45.370 --> 00:38:50.560
There's an initiative from
Khronos called openXR, which

00:38:50.560 --> 00:38:59.500
encapsulates openAR,
openMR, and openVR, where

00:38:59.500 --> 00:39:02.840
they want to attach Vulkan to.

00:39:02.840 --> 00:39:04.630
And then, we have a
real VR interface.

00:39:04.630 --> 00:39:11.850
And then, we definitely are
[? back ?] experimenting.

00:39:11.850 --> 00:39:17.300
The problem for us is the
gap between the PS4, which

00:39:17.300 --> 00:39:20.744
is our regular [? min ?] spec,
and the next mobile device.

00:39:27.390 --> 00:39:31.020
AUDIENCE: It's great to see you
working with our open source

00:39:31.020 --> 00:39:33.370
teams on the shader
compiler stuff.

00:39:33.370 --> 00:39:37.700
On the validation errors you
were seeing with the device

00:39:37.700 --> 00:39:40.280
physical limits, have
you submitted an issue

00:39:40.280 --> 00:39:42.520
to the open source GitHub
project for the Vulkan

00:39:42.520 --> 00:39:43.270
validation layers?

00:39:45.930 --> 00:39:49.735
There's a GitHub project for
Vulkan validation layers.

00:39:49.735 --> 00:39:50.610
SPEAKER 1: All right.

00:39:50.610 --> 00:39:54.330
AUDIENCE: And you were saying
they were not catching issues

00:39:54.330 --> 00:39:56.160
with physical limits?

00:39:56.160 --> 00:39:57.210
SPEAKER 1: Yes.

00:39:57.210 --> 00:40:00.870
AUDIENCE: Have you submitted
a bug to that GitHub project?

00:40:00.870 --> 00:40:05.100
SPEAKER 1: No, because the
state of the Adreno driver

00:40:05.100 --> 00:40:11.530
was so shaky, that we
didn't expect any--

00:40:11.530 --> 00:40:12.120
well, OK.

00:40:12.120 --> 00:40:15.870
I understand that the validation
layer is a different part

00:40:15.870 --> 00:40:16.570
from the driver.

00:40:16.570 --> 00:40:21.087
But for us, it's not
transparent if we

00:40:21.087 --> 00:40:23.670
[? fault ?] the validation layer
or we [? fault ?] the driver.

00:40:26.730 --> 00:40:28.930
But this is one year ago, right?

00:40:28.930 --> 00:40:30.480
Even on the PC, the
validation layer

00:40:30.480 --> 00:40:36.150
was not firing for some
stuff which was obvious.

00:40:36.150 --> 00:40:38.130
And then half a
year ago, there was

00:40:38.130 --> 00:40:41.550
a moment where the validation
layer fired too much.

00:40:41.550 --> 00:40:44.640
And now, we have a moment
where the validation layer

00:40:44.640 --> 00:40:46.790
is probably in a good place.

00:40:46.790 --> 00:40:47.890
AUDIENCE: OK.

00:40:47.890 --> 00:40:48.390
Thanks.

00:40:48.390 --> 00:40:51.630
SPEAKER 1: Regarding the PC
validation layer problems,

00:40:51.630 --> 00:40:54.075
I think we submitted
bug reports.

00:40:54.075 --> 00:40:55.450
AUDIENCE: They
should be unified.

00:40:55.450 --> 00:40:59.070
So whatever you're seeing on PC
should work on Android as well.

00:40:59.070 --> 00:41:00.349
SPEAKER 1: OK.

