WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:06.290
&gt;&gt; WEBBER: Hi, good afternoon, everybody.
My name is Joel Webber. This is Ray Cromwell

00:00:06.290 --> 00:00:10.509
and Stefan Haustein, my partners in crime
over here. And we're going to talk a little

00:00:10.509 --> 00:00:15.809
bit, this afternoon, about HTML5. That seems
to be a common theme in this conference. And

00:00:15.809 --> 00:00:20.070
specifically what you can do with HTML5 and
the Google Web Toolkit. A little setup work,

00:00:20.070 --> 00:00:26.080
just remember that there's a live Wave going
on. There is also a moderator question and

00:00:26.080 --> 00:00:32.960
answer there. And at the end of the talk,
we'll get questions from both moderator and

00:00:32.960 --> 00:00:38.310
from the mics. So, we're going to talk about
three things today, we're going to show you

00:00:38.310 --> 00:00:42.430
three things today, something for your eyes,
something for your ears and something for

00:00:42.430 --> 00:00:48.250
your Id. In other words, we're going to blow
something up. You may have heard a little--a

00:00:48.250 --> 00:00:53.370
thing or two about this. And specifically,
we're going to talk about what you can do

00:00:53.370 --> 00:01:00.059
with Google Web Toolkit on top of HTML5. Obviously,
HTML5 is its own technology but there are

00:01:00.059 --> 00:01:11.270
some specific advantages that GWT brings to
actually doing HTML5 work to take advantage

00:01:11.270 --> 00:01:23.439
of these modern and bleeding-edge browsers.
So first of, I'm going to clear up a couple

00:01:23.439 --> 00:01:34.790
of things about HTML5 itself. We have a formal
definition that is the things that are actually

00:01:34.790 --> 00:01:42.720
in the spec called HTML5, you know, just best
practices for HTML interpretation, some new

00:01:42.720 --> 00:01:50.600
elements, things like audio and video, so
forth and so on. Then we have the thing that

00:01:50.600 --> 00:01:59.110
we actually are referring to most of the time
when we say it colloquially, which are--which

00:01:59.110 --> 00:02:09.240
include things like canvas. Canvas may be
part of the spec, I forget. But other specs

00:02:09.240 --> 00:02:22.220
like WebGL, WebSockets, all the stuff in CSS3,
lots of little ancillary specs and we've really

00:02:22.220 --> 00:02:37.030
been referring to it more in a colloquial
sense as a whole in this conference because

00:02:37.030 --> 00:02:43.910
we believe that really captures the essence
of what sort of coming in the next phase of

00:02:43.910 --> 00:02:51.360
all these browsers that are busily updating
themselves right now. So, very briefly, you

00:02:51.360 --> 00:03:05.990
may be asking yourself if you're a current
GWT user, "Where are all these great HTML5

00:03:05.990 --> 00:03:22.480
features in GWT?" And the answer is most of
them are in extra libraries right now because

00:03:22.480 --> 00:03:39.560
we spend a lot of time trying to make GWT
actually across browsers so that if you write

00:03:39.560 --> 00:03:51.470
GWT code, it will actually compile and run
everywhere within reason. We haven't moved

00:03:51.470 --> 00:04:09.620
these things into GWT proper for the most
part, but there are a lot of external--internal

00:04:09.620 --> 00:04:20.079
and external open-source libraries for wrapping
features like WebGL and WebSockets and so

00:04:20.079 --> 00:04:32.630
forth and so on. And we're going to try to
move these things into the core GWT over time

00:04:32.630 --> 00:04:42.490
with appropriate measures to determine whether
they're supportive or not so that you, at

00:04:42.490 --> 00:04:55.180
least, to know what browsers you're actually
going to be able to support. So first, WebGL,

00:04:55.180 --> 00:05:01.230
so, all three of us are ex-graphics guys,
some game industry people. And when we saw

00:05:01.230 --> 00:05:11.150
WebGL, we thought, "This is pretty cool. I
had no idea when I was working on this." It

00:05:11.150 --> 00:05:16.910
turns out that there was someone at Mozilla
whose name I forgot now but, well, I will

00:05:16.910 --> 00:05:23.160
thank at the end for starting this work, originally
called Canvas 3D. It's essentially OpenGL

00:05:23.160 --> 00:05:27.970
ES 2.0. If you're a graphics geek, you know
what that means. It's the same OpenGL APIs

00:05:27.970 --> 00:05:34.420
you see in Android and the iPhone, and they
have been made JavaScript friendly. So, things

00:05:34.420 --> 00:05:39.480
that were sort of C-style APIs have been morphed
into more JavaScript-friendly APIs. The--I

00:05:39.480 --> 00:05:45.890
guess, the work began at Mozilla, but it spread
quickly in the Safari and WebKit which--and

00:05:45.890 --> 00:05:50.990
all three of them have--I mean, nearly--I
would say at this point, nearly production

00:05:50.990 --> 00:05:55.870
grade implementations. And it's the thing
we all kind of hope it was coming when we

00:05:55.870 --> 00:06:00.630
saw canvas.getcontext and it took an argument
that said 2D. The obvious implication of that

00:06:00.630 --> 00:06:09.751
is at some point, we get 3D. It turned into
WebGL rather than 3D, but the idea is the

00:06:09.751 --> 00:06:14.110
same. Little bit of a deep dive. Stefan's
going to tell you a lot more about the details

00:06:14.110 --> 00:06:16.550
of the implementation. But, the WebGL, if
you're a graphics person, is kind of an interesting

00:06:16.550 --> 00:06:22.610
beast because it's really a drastic simplification
of original GL libraries. Again, there won't

00:06:22.610 --> 00:06:29.270
be a pop quiz on these details but the--it
really moves a lot of the work into shader

00:06:29.270 --> 00:06:36.480
languages and that's actually the really core
thing that makes OpenGL--makes GL ES and therefore

00:06:36.480 --> 00:06:44.420
WebGL special. And that's really, really great
for Web browsers because the JavaScript VMs

00:06:44.420 --> 00:06:52.930
have gotten really fast, but they're not C-code.
C-code has gotten really fast, but they're

00:06:52.930 --> 00:06:59.460
not specialized graphics processors. The more
you can move over to these specialized graphics

00:06:59.460 --> 00:07:06.630
processors, the more really crazy heavyweight
stuff you can do that would just have been

00:07:06.630 --> 00:07:11.020
completely intractable had you tried it in
JavaScript or often even in just raw C-code.

00:07:11.020 --> 00:07:22.110
So, first, something for your eyes, I'm going
to have Ray talk about a little library he

00:07:22.110 --> 00:07:29.900
built that does some things that I think you'll
find it fairly interesting. Again, take this

00:07:29.900 --> 00:07:33.810
with--understand that these are sort of just
bleeding-edge demos. These are things--they're

00:07:33.810 --> 00:07:40.280
not finished products or anything like that,
but their--there are attempts to really see

00:07:40.280 --> 00:07:48.610
what we can do with these new features in
a fairly short period of time. So, I'm going

00:07:48.610 --> 00:07:54.570
to pass it on to Ray now.
&gt;&gt; CROMWELL: Thanks, Joel. So as Joel talked

00:07:54.570 --> 00:08:03.020
about, HTML5 has added a lot of new stuff:
WebSockets, new elements, new APIs. But some

00:08:03.020 --> 00:08:10.810
of the most of important APIs that's added
has to do with media manipulation. So--I mean,

00:08:10.810 --> 00:08:21.100
it's one thing to use a video tag to just
playback content, but it's another thing to

00:08:21.100 --> 00:08:27.210
use it to actually edit video. And some of
the things that people used to do with flash,

00:08:27.210 --> 00:08:38.150
because they can only be done with flash or
be done with a plug-in, can now be done with

00:08:38.150 --> 00:08:43.710
HTML5. So what I've done is I've put together
a little demo to kind of show what's possible.

00:08:43.710 --> 00:08:51.800
And the demo here basically is to try to recreate
Photoshop filters in the browser, but to make

00:08:51.800 --> 00:09:00.200
them run really perform it. So what we want
to do is we want to make these filters work

00:09:00.200 --> 00:09:05.300
on megapixel images, and not just some kind
of like small image you took with your cell

00:09:05.300 --> 00:09:11.370
phone but, you know, four megapixels, eight
megapixels and so on. So, we want it to be--we

00:09:11.370 --> 00:09:18.770
want it to be really fast. Secondly, we want
to provide it in a--as like a general purpose

00:09:18.770 --> 00:09:25.820
library for GWT eventually where if you want
to build your own filters you just kind of

00:09:25.820 --> 00:09:28.960
concatenate together a bunch of low-level
operations like scaling, convolutions, transformations,

00:09:28.960 --> 00:09:36.810
and so on, and you can just make your own
sort of Photoshop. But more importantly, we

00:09:36.810 --> 00:09:40.870
want to leverage native acceleration where
possible. So, if you've got a WebGL-enabled

00:09:40.870 --> 00:09:50.180
browser, we'd like to actually use the hardware
to execute these operations. So this is a

00:09:50.180 --> 00:09:55.970
sort of high-level overview of the architecture
that, as we've implemented. It's basically

00:09:55.970 --> 00:10:04.890
a tree of filters. And each filter does something
and it passes it on to the next one. So for

00:10:04.890 --> 00:10:12.080
example the source filter, all it does is
simply load the image from some resource like

00:10:12.080 --> 00:10:19.300
a URL or off the disk and so on. And then
you can basically send that into various other

00:10:19.300 --> 00:10:24.730
filters. One example would be like a ColorOP
would--could convert it to grayscale or sepia

00:10:24.730 --> 00:10:30.210
tone it or something like that. Another one
would be a convolution filter. And convolution

00:10:30.210 --> 00:10:34.760
filters are really powerful. Many, many, many
of the Photoshop filters use convolutions

00:10:34.760 --> 00:10:40.900
like sharpening and things like that so you
can do that. And you can blend them together

00:10:40.900 --> 00:10:46.690
so you have separate layers and you do like
Photoshop-like layers and blend them together

00:10:46.690 --> 00:10:55.240
and just output them to display at the end.
So, one of the things you might be asking

00:10:55.240 --> 00:10:59.970
is, "Well, what does GWT have to do with this,"
right? I mean, if it's JavaScript and WebGL

00:10:59.970 --> 00:11:05.580
in a browser, you could probably just write
what I'm putting up here as the architecture

00:11:05.580 --> 00:11:12.230
in JavaScript. And that's true, you could.
But what GWT buys you is two things. If you

00:11:12.230 --> 00:11:31.690
saw my compiler talk yesterday, it's able
to optimize the JavaScript a lot more so some

00:11:31.690 --> 00:11:38.410
of these really hot loops for processing pixels
will run a little bit faster. Secondly, it

00:11:38.410 --> 00:11:47.750
allows us to target multiple platforms. So
that's okay too. But anyway, there's two implementations.

00:11:47.750 --> 00:11:59.940
One of them is based off with just the Canvas
tag. And this new API where you're able to

00:11:59.940 --> 00:12:25.850
get something called a CanvasPixelArray and
actually looked at the raw pixels of a JPEG

00:12:25.850 --> 00:12:36.029
or a PNG that you're loading in. However,
this mode's probably not going to be as fast

00:12:36.029 --> 00:12:48.520
as the hardware accelerated one. So for really
large images like eight megapixel, we might

00:12:48.520 --> 00:13:01.290
have to like sort of crop it down and let
you only kind of work on a preview image.

00:13:01.290 --> 00:13:06.680
And then, the second implementation is WebGL.
So if you've got a WebGL-enabled HTML5 browser,

00:13:06.680 --> 00:13:20.370
we're hoping that it's going to run blisteringly
fast. So, here's an example of one of the

00:13:20.370 --> 00:13:30.660
operations I'm going to show you, it's called
convolution. Now, what's a convolution? A

00:13:30.660 --> 00:13:46.630
convolution is simply a weighted sum of nearby
pixels. So if you kind of think about you're

00:13:46.630 --> 00:13:56.730
taking one pixel, and then taking the ones
that are right or next to it, and multiplying

00:13:56.730 --> 00:14:07.360
those by some value like 0.5 or 0.3, and adding
them all together, and then using that as

00:14:07.360 --> 00:14:14.240
the final output pixel. And the way this is
represented typically is by a matrix. So up

00:14:14.240 --> 00:14:19.890
here is a 3x3 convolution filter. This is
actually the sharpen filter. So, if you're

00:14:19.890 --> 00:14:28.220
using iPhoto or Photoshop and you say "Sharpen
this image," this is actually what it does.

00:14:28.220 --> 00:14:33.110
And what it's doing there is it's saying,
"Look, take the current pixel you're operating

00:14:33.110 --> 00:14:44.300
on and multiply it by five. Take the pixels
to the left of it and to the right of it and

00:14:44.300 --> 00:14:53.220
above and below and multiply those by -1.
Add them all together and output them." And

00:14:53.220 --> 00:15:00.940
you can make up your own convolution filters.
You can plug in whatever your numbers you

00:15:00.940 --> 00:15:10.440
want to just sort of play around and creating
filters. But one important property is that

00:15:10.440 --> 00:15:19.459
if all the numbers add up to one at the end,
it will preserve the overall brightness of

00:15:19.459 --> 00:15:25.830
the image, so that's an important property
of convolutions. Some of the other convolutions

00:15:25.830 --> 00:15:29.010
you might be familiar with, Gaussian Blur.
If you've seen drop shadows or glow effects,

00:15:29.010 --> 00:15:39.160
that's how they do it. So, we have a pure
Java implementation written in GWT. And just

00:15:39.160 --> 00:15:45.019
to sort of give you a taste of the amount
of processing that's going on in JavaScript,

00:15:45.019 --> 00:15:58.680
for a 5x5 convolution--that's a 5x5 matrix--on
a one megapixel image, you're going to do

00:15:58.680 --> 00:16:17.570
25 million multiplies adds, loads, and stores
times three because you've got to do it for

00:16:17.570 --> 00:16:35.100
red, green, and blue, and sometimes for the
alpha channel. So that could be up to a hundred

00:16:35.100 --> 00:16:59.709
million operations in JavaScript. And if your
image is, let's say, twice as wide, it's four

00:16:59.709 --> 00:17:17.480
times as bad, so you can imagine it could
get slow pretty quickly. Now, the WebGL implementation

00:17:17.480 --> 00:17:27.519
takes advantage of pixel shaders. So if you
got WebGL, what we do is we upload a shader

00:17:27.519 --> 00:17:38.090
onto your graphics card and the actual code
executes on the chip itself. And if you're

00:17:38.090 --> 00:17:44.289
interested in actually how this is really
done, there's a great article that NVIDIA

00:17:44.289 --> 00:17:52.590
has in their online book called GPU Gems.
It's available at this link that will tell

00:17:52.590 --> 00:17:59.429
you precisely how to implement these filters
on the hardware. But basically, it's just

00:17:59.429 --> 00:18:05.330
really simple if you know anything about graphics.
You take the image that you want to process

00:18:05.330 --> 00:18:12.970
and you bind it to a texture, then you just
render a rectangle that's of a certain size,

00:18:12.970 --> 00:18:18.169
the size of the image, and you attach this
pixel shader to it. So every time it tries

00:18:18.169 --> 00:18:26.019
to copy a pixel from the texture to the rectangles
that's drawing it, it applies your code. It

00:18:26.019 --> 00:18:34.559
says, "Well, I need to write out a pixel,
so I'm going to execute this little time mini-program."

00:18:34.559 --> 00:18:46.919
And then finally, you just kind of run this
in a loop if you want to apply a chain set

00:18:46.919 --> 00:18:53.240
of filters. So, now, I'll show you a demo.
Okay. Hey, Joel, the back tick trick didn't

00:18:53.240 --> 00:18:54.240
work.
&gt;&gt; WEBBER: Sorry.

00:18:54.240 --> 00:19:00.070
&gt;&gt; CROMWELL: Okay, I'll just switch over.
Okay. So, here is an image of Notre Dame.

00:19:00.070 --> 00:19:09.799
And what I do is--have--is I have a little
sort of scaffold up here around my library

00:19:09.799 --> 00:19:20.679
and I'm going to do some Photoshop filters
on it. So

00:19:20.679 --> 00:19:37.039
the first that I'm going to show is done in
JavaScript. So for example, I'm going to click

00:19:37.039 --> 00:19:51.129
Gaussian, and I'm going to blur this image.
So I'm going to click this button once and

00:19:51.129 --> 00:19:59.289
you can see it's kind of frozen, the browser,
and it took 1,600 milliseconds. That's like

00:19:59.289 --> 00:20:13.499
1.6 seconds. I could click it again and keep,
making it blurrier and blurrier. Using a different

00:20:13.499 --> 00:20:24.989
convolution, you could do edge detection.
Well let's--let me reset it. I combined the

00:20:24.989 --> 00:21:22.480
blur with the edge detection. That didn't--okay,
hold on. Let me reload it. Okay. Let's do

00:21:22.480 --> 00:21:37.840
an edge detection. There you go. So that ran--oh,
that's the WebGL. I'm sorry. That's why it's

00:21:37.840 --> 00:21:58.789
so fast. Here's the edge detection in JavaScript,
672 milliseconds. So, there's another button

00:21:58.789 --> 00:22:32.580
I can click here, which is WebGL, and that's
going to switch me over to hardware rendering

00:22:32.580 --> 00:22:53.419
mode. And if I click--I'm going to reload
the browser, it's cached. So if I do it here,

00:22:53.419 --> 00:23:13.580
you can see I can click this and I can just
keep clicking it as fast as I want, and it

00:23:13.580 --> 00:23:47.090
just responds instantly. Like if I sharpen,
I can sharpen it up, I can emboss it, and

00:23:47.090 --> 00:23:54.360
so on, grayscale filter. And likewise, if
I'm doing like a color space correction, it's

00:23:54.360 --> 00:24:05.440
like real-time. So, if you're like editing
the exposure of a photo, you want it to be

00:24:05.440 --> 00:24:14.330
like super real-time. You don't want this
like, wanted to take like half a second every

00:24:14.330 --> 00:24:31.629
time you adjust. In fact, WebGL is so fast
that we can actually play a video. And, you

00:24:31.629 --> 00:24:43.080
know, I can emboss Conan O'Brien in real-time,
or I can edge detect him, so. So, if you haven't

00:24:43.080 --> 00:24:52.130
seen this, it's pretty funny. It's Vick and
Conan together. So, that's the gist of that

00:24:52.130 --> 00:25:02.549
demo. Let me go back to my presentation. Yeah,
I keep forgetting where I am. Okay. So what

00:25:02.549 --> 00:25:15.730
is--what I have shown you--what I've shown
you actually is a library written in GWT called

00:25:15.730 --> 00:25:30.259
IMGwt for image processing for Google Web
Toolkit. And what it is has two implementations.

00:25:30.259 --> 00:25:38.879
It's a pure Java implementation and a WebGL
implementation. Now, this is where it comes--the

00:25:38.879 --> 00:25:46.470
question of why GWT come in, because you could
do this with just pure JavaScript. And the

00:25:46.470 --> 00:25:54.369
reason is this, the pure Java implementation
can actually run in the Cloud. So if you wanted

00:25:54.369 --> 00:25:59.840
to do some image processing in the server,
so upload it to the server, you could run

00:25:59.840 --> 00:26:02.409
this inside of App Engine if you want it to,
it's pure Java. Likewise, you could even port

00:26:02.409 --> 00:26:05.210
this to Android and just stick in the Android
graphics APIs on the bottom layer, and it

00:26:05.210 --> 00:26:09.149
would work there too. But the front-end API
would be the same. And it's got a compact

00:26:09.149 --> 00:26:13.529
DSL-like API so you just do something like
"imaging.load" a URL; ".convolve" an array

00:26:13.529 --> 00:26:16.630
that has your kernel; and then ".to" and a
widget to actually poke it into. An important

00:26:16.630 --> 00:26:22.419
fact, I've measured these WebGL filters up
to 1,700 times faster than JavaScript. So

00:26:22.419 --> 00:26:35.519
if you want to edit really, really large images,
doing it in JavaScript or doing it with, like,

00:26:35.519 --> 00:26:47.129
SVG filters is not going to fly you. WebGL
is the way to go. So, now something for your

00:26:47.129 --> 00:26:56.869
ears; can I see a show of hands? How many
people in the audience have ever owned a Commodore

00:26:56.869 --> 00:27:08.320
64? Wow, I didn't expect that. So if so, you're
going to--I think you might like this next

00:27:08.320 --> 00:27:17.720
demo. So, I was--we were trying to think about
what kind of demos could we do that kind of

00:27:17.720 --> 00:27:27.190
really freak you out. And I think this one's
pretty freaky. So what we did is we ported

00:27:27.190 --> 00:27:36.450
a Commodore 64 emulator to JavaScript using
GWT. And the demo I'm going to show you is

00:27:36.450 --> 00:27:44.219
not the formulator. This is just the sound
part. So what I've done is I've ported, essentially,

00:27:44.219 --> 00:27:48.840
the Commodore 64 emulator just to run a SID
player for SID music. How many people know

00:27:48.840 --> 00:27:56.679
about SID music? Okay. So what this is? Is
it's just--basically, it's a complete Commodore

00:27:56.679 --> 00:28:02.659
64 emulator that only exists to playback SID
files. So, let me go there. Okay. So, I'll

00:28:02.659 --> 00:28:12.759
briefly play--actually, this is not going
to be Commando because I don't have the rights

00:28:12.759 --> 00:28:26.121
to it. It's a different song. But I'll click
the link, and it's going to load up, let it

00:28:26.121 --> 00:28:31.749
play for a second. Okay, so enough with that.
So, Commodore 64 emulator in a browser. Let

00:28:31.749 --> 00:28:39.029
me go back to my slides so I can tell you
what's special about it besides the fact that

00:28:39.029 --> 00:28:45.840
Commodore 64 is cool. All right, hold on,
Joel, my--I want to kill that. I think it

00:28:45.840 --> 00:28:49.259
was still playing.
&gt;&gt; WEBBER: Did you escape your way out.

00:28:49.259 --> 00:28:54.389
&gt;&gt; CROMWELL: I probably did. All right, let
me--it's going to go back to--yeah, okay,

00:28:54.389 --> 00:29:02.969
I'll just skip ahead. Okay. So, what did we
do here? This is the demonstration of HTML5

00:29:02.969 --> 00:29:10.369
audio, but the current audio element can only
playback the static sound files that you've

00:29:10.369 --> 00:29:16.289
got sitting on the Web somewhere. So, what
this actually demonstrates is the fact that

00:29:16.289 --> 00:29:22.129
you can dynamically generate audio in the
browser, but there's kind of a couple tricks

00:29:22.129 --> 00:29:31.539
you have to do. But the emulator, to do this,
has to actually run a cycle-accurate Commodore

00:29:31.539 --> 00:29:34.850
64. That means like a million times a second.
It's got to be executing the processors opcode,

00:29:34.850 --> 00:29:43.779
it's going to be fetching from simulated memories,
it's got to be updating all the I/O chips,

00:29:43.779 --> 00:29:52.499
and actually for the sound chip in particular
to make it sound authentic to an original

00:29:52.499 --> 00:29:56.979
Commodore 64, it actually emulates the hardware
analog circuitry that was on the backend of

00:29:56.979 --> 00:30:09.720
the Commodore 64 so the capacitors and resistors
and all that kind of stuff to make it actually

00:30:09.720 --> 00:30:19.379
sound completely accurate. So it, that take--it
takes a lot of processing power. And the browsers

00:30:19.379 --> 00:30:25.919
are getting fast enough, they can finally
do this. So just to keep in mind, SID music

00:30:25.919 --> 00:30:36.659
is not data, it's not like an MP3. It's not
a Codec. It's basically a code. So the way

00:30:36.659 --> 00:30:45.960
you play the music is you have to run it.
And the way this demo works is, is at basically

00:30:45.960 --> 00:30:52.879
44,000 times a second. It samples these virtual
I/O registers that are being emulated in a

00:30:52.879 --> 00:31:00.369
browser and then collects them into a buffer.
And then what it does is it takes that buffer

00:31:00.369 --> 00:31:08.799
and it encodes it as an audio/wave, a PCM
file and then base64 encodes it into a data

00:31:08.799 --> 00:31:17.159
URI. And then finally, inserts an audio source
equals that URL, which is a long URL which

00:31:17.159 --> 00:31:30.469
has the entire sound clip in it and it just
keeps doing that as the song is playing.

00:31:30.469 --> 00:31:37.309
&gt;&gt; WEBBER: Yet somehow, it actually works.
&gt;&gt; CROMWELL: Amazingly, yeah. So, that's it

00:31:37.309 --> 00:31:50.309
for audio and the browser. And if people are
interested in a deeper dive on this or how

00:31:50.309 --> 00:31:55.309
to do other sort of audio tricks, you can
combine WebGL with audio processing, so you

00:31:55.309 --> 00:32:02.590
can do all kinds of cool things like having
the hardware do echo and reverberation and

00:32:02.590 --> 00:32:12.230
things like that. But, now, I'd like to bring
Joel up on the stage to give you what you

00:32:12.230 --> 00:32:17.809
all have been waiting for which is blood and
guts.

00:32:17.809 --> 00:32:28.799
&gt;&gt; WEBBER: I expect maybe you've already seen
this before but, so it won't be a real pop

00:32:28.799 --> 00:32:36.580
in the demo but still fun to see. So, this
also goes back to the question of "why GWT?"

00:32:36.580 --> 00:32:43.940
So, what we've done, okay, for those of you
who aren't aware of this, is to take the Quake

00:32:43.940 --> 00:32:51.309
II game from 1997, which still looks remarkably
good for a '97 game, I must say. Taken a Java

00:32:51.309 --> 00:32:57.039
port of it called Jake2 that someone wrote
a few years ago. They sort of transliterated

00:32:57.039 --> 00:33:05.960
the code directly into Java for Java could
run this quite fast, which it actually does.

00:33:05.960 --> 00:33:13.099
And we saw this right about the time that
WebGL started actually coming up with real

00:33:13.099 --> 00:33:19.399
implementations, just started seeing a real
implementation in WebKit and Mozilla, the

00:33:19.399 --> 00:33:28.399
Firefox. And we sat--and we've kind of scratching
our heads and thinking, "Well, could we really

00:33:28.399 --> 00:33:35.070
port that? Would that work? No, there's no
way. There's no way it'll work." But, you

00:33:35.070 --> 00:33:41.029
know, why not, right? It's more fun that working
on trying to optimize table rendering so,

00:33:41.029 --> 00:33:48.719
I don't see why not, so let's give it a shot.
By the way, I wanted to make this a multiplayer

00:33:48.719 --> 00:33:54.999
demo, but as you've seen from both keynotes,
wireless is incredibly unreliable. So, we're

00:33:54.999 --> 00:34:02.869
just going to do a single player. Oops. Loading's
a little slow and I'll explain why later,

00:34:02.869 --> 00:34:07.419
specifically. Ah, there we go.
&gt;&gt; Established communications. We're already

00:34:07.419 --> 00:34:08.940
out.
&gt;&gt; Computer update.

00:34:08.940 --> 00:34:20.810
&gt;&gt; WEBBER: Let's see if I can play it for
the track pad and survive. Notice that I put

00:34:20.810 --> 00:34:28.790
it on easy for a reason. I hope you noticed
this is handling about 23 frames a second

00:34:28.790 --> 00:34:35.510
on this laptop at 1024x758. Not as good as
we'd like it to be, but it's not too bad.

00:34:35.510 --> 00:34:40.540
Ooh, I got that guy that was beautiful. Well,
you know why they put the barrels there, right.

00:34:40.540 --> 00:34:47.149
They put them so you could blow things up.
So, you get the general idea. We've actually--this

00:34:47.149 --> 00:35:03.450
is just a demo level. We've seen the full
game run quite well. Actually, if I go that

00:35:03.450 --> 00:35:11.590
way, I'm going to get my [INDISTINCT] in a
big hurry. I've been there from experience,

00:35:11.590 --> 00:35:19.310
so. And this is a very literal port. So, we're
talking about the direct code, all the logics

00:35:19.310 --> 00:35:29.860
here, multiplayer works like a champ. There's
a guy hiding right there. I played this once

00:35:29.860 --> 00:35:44.580
or twice. And there's somebody hiding, and
there he is. It doesn't like having perfect

00:35:44.580 --> 00:36:01.830
[INDISTINCT] knowledge of the universe to--I
hope you get this. I mean, it's sort of like

00:36:01.830 --> 00:36:23.740
Groundhog Day with guns. And can I make it
through here? All I really want is a shotgun.

00:36:23.740 --> 00:36:44.579
There we go. Okay, I'll stop boring you with
this any minute now, but I'm having fun, so.

00:36:44.579 --> 00:37:00.780
&gt;&gt; CROMWELL: You know you can't stop playing.
&gt;&gt; WEBBER: What time is it? Thirty, okay,

00:37:00.780 --> 00:37:21.620
we have plenty of time; 37 minutes. Hey, this
is my last talk ran over--ran under by 20

00:37:21.620 --> 00:37:36.130
minutes so, I'm not going through that again.
Okay, let's see if we can make it through

00:37:36.130 --> 00:37:55.560
to the fun part, the guys with the big machine
guns. Think about the--I mean, think about

00:37:55.560 --> 00:38:24.000
the fact we're talking about a browser right
here. There we go, that's a much better weapon.

00:38:24.000 --> 00:38:50.571
I mean this is a--this is a browser you're
looking at here. I mean imagine how cool it

00:38:50.571 --> 00:39:06.880
would be if I could just send you a link,
you click on it, and you're in a multiplayer

00:39:06.880 --> 00:39:25.500
game with me. I mean, this is the--this is--this
is a--oh, crap--this is a proof of concept.

00:39:25.500 --> 00:39:42.610
But, you know, when you think about--there's
a guy behind me. Oh, no head. That's not good.

00:39:42.610 --> 00:39:54.150
Here we go. All right so, anyway, okay, I'm
a--I really am going to stop now. All right,

00:39:54.150 --> 00:40:09.490
I'm going to kill that guy and then I'm going
to stop. All right, all right. Oh, demo time.

00:40:09.490 --> 00:40:24.920
That was demo time, okay. So, before I let--Stefan's
going to take an incredibly deep dive into

00:40:24.920 --> 00:40:47.210
all the details. He did a lot of the graphics
work in this and there was a fair amount of

00:40:47.210 --> 00:40:59.190
it. But the question of why--again, why GWT?
What is really valuable about having done

00:40:59.190 --> 00:41:13.150
this through Java as opposed to just writing
this, you know, on JavaScript? Now, I might

00:41:13.150 --> 00:41:31.620
not be able to prove this statement, but I
strongly believe that with the complexity

00:41:31.620 --> 00:41:47.910
of that code base, I think, what was it? A
hundred thousand...?

00:41:47.910 --> 00:42:01.600
&gt;&gt; HAUSTEIN: A hundred thousand lines code.
&gt;&gt; WEBBER: Have you ever take, thought about

00:42:01.600 --> 00:42:12.090
100K logs for the IBMers out there. That's
a really complex code base. It's convoluted.

00:42:12.090 --> 00:42:21.950
It's a good code by '90s era game standard.
It's a very clean code. But that's by '90s

00:42:21.950 --> 00:42:32.950
era game standards. It took an enormous amount
of tooling to get through this process. And

00:42:32.950 --> 00:42:52.710
again, I'm going to let Stefan go into details.
But the tooling that we provided, the tooling

00:42:52.710 --> 00:43:06.680
that was provided by Eclipse, we primarily
used Eclipse. Or IntelliJ would be fine as

00:43:06.680 --> 00:43:27.970
well. Any tool that can revive lots of cross-referencing,
lots of "Find me all the places where this

00:43:27.970 --> 00:43:47.540
piece of code is used," "Find me all the places
where, you know, [INDISTINCT] with this piece

00:43:47.540 --> 00:43:55.830
of code is used." Tell me when I made a mistake.
Show me a red squiggly in the browser when

00:43:55.830 --> 00:44:09.060
I had just screwed something up. It was a
complicated enough porting process had we

00:44:09.060 --> 00:44:17.720
just, you know, without having to worry about
those kinds of problems. Without the tools,

00:44:17.720 --> 00:44:26.910
I don't--I honestly don't think we would have
ever completed it because we're really talking

00:44:26.910 --> 00:44:41.890
about 20% time, really sort of -5% time project,
the stuff that happens between 10 pm and midnight

00:44:41.890 --> 00:44:58.310
at home. So, that's the reason this is a GWT
related, I would argue. And I have more to

00:44:58.310 --> 00:45:11.190
say about that later. But first, let me let
Stefan go into the excruciating technical

00:45:11.190 --> 00:45:23.660
details of what actually happened to make
this go.

00:45:23.660 --> 00:46:05.721
&gt;&gt; HAUSTEIN: Thank you, Joel. Yeah, so when
trying to do this port, we faced a set of

00:46:05.721 --> 00:46:15.280
problems. And the first problem was rendering.
So the Rendering API used in the Quake, original

00:46:15.280 --> 00:46:20.060
Quake source code, Lightweight J--Lightweight
Java OpenGL is based on OpenGL 1.X, and it

00:46:20.060 --> 00:46:29.710
uses a Java nio buffers for data transfer.
But WebGL is based on OpenGL ES 2.0 and you

00:46:29.710 --> 00:46:38.720
don't have any fixed function pipeline there
and it uses its own WebGL arrays and buffers.

00:46:38.720 --> 00:46:50.600
And arrays and buffers are distinct, and you
don't have this distinction in pure Java.

00:46:50.600 --> 00:47:03.940
And of course, we didn't have any development
mode support for WebGL in GWT. Then, we have

00:47:03.940 --> 00:47:15.710
problems with resource loading because there
is no file system in the browser, and the

00:47:15.710 --> 00:47:28.950
Quake code loads everything from the file
system. And if we want to use XHRs for loading

00:47:28.950 --> 00:47:43.340
resources, they are asynchronous. So they
don't really fit into the control flow of

00:47:43.340 --> 00:47:56.180
the existing code. And local storage is synchronous,
but it has a very limited capacity. Then,

00:47:56.180 --> 00:48:07.020
for networking, Quake uses UDP, but there
is no UDP support in any browser in JavaScript.

00:48:07.020 --> 00:48:12.980
And some Java APIs to Quake code base are--is
using are missing in GWT. And, of course,

00:48:12.980 --> 00:48:20.790
we have not any, didn't have any idea if it
would be fast enough. Okay. So the first part

00:48:20.790 --> 00:48:26.691
is the renderer port. So, our first idea was
to just do our drop-in LWJGL emulation, and

00:48:26.691 --> 00:48:40.470
just to emulate the missing GL 1.X fixed function
pipeline. But the problem is that a pure drop-in

00:48:40.470 --> 00:48:51.070
wouldn't take advantage--wouldn't be able
to take advantage of the DOM-based image loading

00:48:51.070 --> 00:49:02.200
capabilities of WebGL and handling image data
at a pixel level were transferred to WebGL

00:49:02.200 --> 00:49:10.980
in JavaScript seemed too expensive. And, finally,
we needed slightly different signatures to

00:49:10.980 --> 00:49:24.700
support WebGL buffers. I'll come back to this
later. So, instead of a pure drop-in replacement

00:49:24.700 --> 00:49:36.491
for LWJGL, we added an intermediate abstraction
layer that is close to our original API and

00:49:36.491 --> 00:49:47.790
still uses nio buffers. And the nio buffers,
we emulate using WebGL arrays. And a nice

00:49:47.790 --> 00:50:00.800
property of the GWT development mode is that
the nio buffer emulation falls back to pure

00:50:00.800 --> 00:50:16.110
Java nio in development mode and that enabled
us to create a WireframeRenderer that we could

00:50:16.110 --> 00:50:22.770
use to the backend development mode result
needing WebGL. So the whole structure of their--our

00:50:22.770 --> 00:50:29.660
implementation is that we have an abstract
GLAdapter at the top and/or we have an LWJGL

00:50:29.660 --> 00:50:44.920
adapter that still runs the original code
base, so we

00:50:44.920 --> 00:50:52.760
still can run it in Java and pure Java on
the desktop. And then our abstract GL 2.0

00:50:52.760 --> 00:50:57.930
Adapter does all their fixed function pipeline
stuff. And that's used by the WireframeRenderer

00:50:57.930 --> 00:51:02.410
and the WebGLAdapter. And that's how their
wireframe mode looks like. A trivial translation

00:51:02.410 --> 00:51:09.020
from GL 1.X to WebGL is to turn all the calls
that set vector data into sequences of glBindBuffer(),

00:51:09.020 --> 00:51:15.210
or glBufferData() and then glVertexAttribPointer().
To make this faster, we changed the code to

00:51:15.210 --> 00:51:22.530
make sure that static data, like level geometry,
static lightmap coordinates, and stuff like

00:51:22.530 --> 00:51:28.030
that, is only copied to a buffer once and
then reused. And in the code, we did this

00:51:28.030 --> 00:51:35.350
by assigning a unique ID to reused buffers
so we can identify and skip the copy step

00:51:35.350 --> 00:51:43.540
for WebGL, but still run the original code
in pure Java. We did some other rendering

00:51:43.540 --> 00:51:52.420
improvements for WebGL, basically to reduce
the number of GL codes--GL calls. So we ported

00:51:52.420 --> 00:52:02.590
GL_DrawAliasFrame in mesh to--from DrawElements
to DrawArrays and the reuse part of the GL

00:52:02.590 --> 00:52:12.840
setup when rendering strings of text. The
next problem was our resource loading, porting

00:52:12.840 --> 00:52:19.610
resource loading to asynchronous I/O for textures
that was quite straightforward. We just deferred

00:52:19.610 --> 00:52:31.720
the corresponding GL calls to the onload event.
And in the meantime, we use a holodeck texture

00:52:31.720 --> 00:52:45.980
that looks like this. You have seen this by
loading the game I think. And that was quite

00:52:45.980 --> 00:52:55.300
straightforward and had little impact on the
control flow of the game. And the sizes of

00:52:55.300 --> 00:52:56.300
all images which are needed in building the
models are sent to the client in JSON as part

00:52:56.300 --> 00:52:59.860
of index.html. Porting the code for loading
models and maps was a bit more difficult.

00:52:59.860 --> 00:53:04.050
As I said earlier, Quake assumes asynchronous
access to resources so it required a significant

00:53:04.050 --> 00:53:06.280
amount of refactoring. The main trick there
was to skip frames while resource loading

00:53:06.280 --> 00:53:09.890
is in progress. So for networking, we replaced
UDP with WebSockets. And with the renderer,

00:53:09.890 --> 00:53:10.890
async IO, and networking implemented, we were
able to run multiplayer games. So, ironically,

00:53:10.890 --> 00:53:11.890
multiplayer support was the easy part because
we didn't need to port any of the server logic.

00:53:11.890 --> 00:53:15.080
However, we wanted to get the demo mode running,
so we would have something that we could use

00:53:15.080 --> 00:53:23.650
as some kind of benchmark that we could reproduce
and that would like output some kind of frame

00:53:23.650 --> 00:53:34.440
rate and then you see how good your browser
or computer performs at--with WebGL. And after

00:53:34.440 --> 00:53:41.930
making sure that all of their additional causes
that were needed for this would compile, nothing

00:53:41.930 --> 00:53:47.820
worked for us. So, we kind of knew that there
must be an error somewhere in our changes

00:53:47.820 --> 00:53:51.940
but diff show that we have like changes everywhere.
And that made it kind of hard to find the

00:53:51.940 --> 00:53:54.700
bugs. So, instead of trying to fully understand
what was going wrong, we just tried to review

00:53:54.700 --> 00:54:02.610
some differences and that means we reverted
all unnecessary changes in the code base such

00:54:02.610 --> 00:54:06.470
as import clean ups, package changes and formatting
changes. And we also replace other changes

00:54:06.470 --> 00:54:25.590
in the code. All changes where we could do
emulations. We did so. So we added there a

00:54:25.590 --> 00:54:35.600
simple file system simulation based on local
storage for saving preferences and games.

00:54:35.600 --> 00:54:45.510
Before that, we were using a local storage
directly for this stuff. We ported some additional

00:54:45.510 --> 00:54:46.600
parts of java.util and we pushed down the
networking changes from our pretty high-level

00:54:46.600 --> 00:54:48.540
where we're using the JSON messages to our
lower level of the NET class and the code

00:54:48.540 --> 00:54:51.970
base that's more at a byte-level. So, with
those changes, we got the differences down

00:54:51.970 --> 00:54:57.470
to about 60 from 200. And we also were able
to reduce the amount of changes in the remaining

00:54:57.470 --> 00:55:02.390
classes. This didn't really provide much insight
into the nature of the bugs we had in our

00:55:02.390 --> 00:55:04.960
code before, but it made them go away. And
that's where I would like hand back to Joel.

00:55:04.960 --> 00:55:10.730
&gt;&gt; WEBBER: Thank you. That was a pretty crazy
process. Thankfully, Stefan is smarter than

00:55:10.730 --> 00:55:22.670
I am. He was able to make it all work. I'm
the one who made all those diffs that he had

00:55:22.670 --> 00:55:37.140
to revert. Then I came just hacking and slashing
through it and then thinking I'm sure it'll

00:55:37.140 --> 00:55:38.140
work out fine, or I'm sure I can debug it,
well, maybe not. But, so--okay, so we saw

00:55:38.140 --> 00:55:39.890
this and I mentioned a minute ago it was running
20, I use 22, 23 frames a seconds on this

00:55:39.890 --> 00:55:41.150
laptop. This laptop is significantly faster
than the machine you probably own in 1997

00:55:41.150 --> 00:55:44.100
and this frame rates are actually quite a
bit lower. So this really bags a few questions,

00:55:44.100 --> 00:55:45.100
I mean one--and I'm--okay, to be fair, in
my Linux desktop at home which is rather beefy,

00:55:45.100 --> 00:55:46.100
it runs at about 60 frames a second which
is kind of nice. But still, it should be running

00:55:46.100 --> 00:55:47.200
at about 500 frames a second on that machine.
I'm making up the number, but a lot faster.

00:55:47.200 --> 00:55:49.030
So this bagged a few questions, like I said.
One, is it the code? What can we do to the

00:55:49.030 --> 00:55:50.320
code to make it faster? Two, what could we
do to the--well, the code and the compiler,

00:55:50.320 --> 00:55:51.320
that's because there is a compiler involved.
What can we do to the browser to make it either

00:55:51.320 --> 00:55:53.250
just directly faster or change the APIs in
such a way that we could make things run faster

00:55:53.250 --> 00:55:57.550
by using the APIs more intelligently or creating
better APIs. And three, what does this tells

00:55:57.550 --> 00:55:59.160
about the inherent limits of actually porting--of
actually running JavaScript code. Inherent

00:55:59.160 --> 00:56:00.500
or near inherent, or at one assumes that VA
performance will eventually tap out to some

00:56:00.500 --> 00:56:01.500
maximum or some asymptote. And so, you know,
what's possible in JavaScript and what's,

00:56:01.500 --> 00:56:02.500
you know, what would be--what would require
you to switch over to something like native

00:56:02.500 --> 00:56:03.500
client? You know, as far as the--as far as
the code itself is concerned, you know, this

00:56:03.500 --> 00:56:04.500
is two levels of porting across two different
languages effectively. I mean, at two different--certainly,

00:56:04.500 --> 00:56:05.500
two different target platforms. And the code
got pretty crufty in the process. There's

00:56:05.500 --> 00:56:06.500
a lot things being done in code that would
be better pushed off to the vertex shaders

00:56:06.500 --> 00:56:08.190
as well. So there's a lot of things that,
you know, there were no vertex shaders in

00:56:08.190 --> 00:56:09.190
this code that was written. So things like,
I mentioned mesh animation here. Mesh animation

00:56:09.190 --> 00:56:10.190
is done. Quake II did not use bone deformation.
It used just key frame point clouds and did

00:56:10.190 --> 00:56:11.190
linear interpolation between them. That's
in straight up Java code and JavaScript ultimately,

00:56:11.190 --> 00:56:12.190
and that's really slow because it's essentially
DSP-style, floating point DSP-style work.

00:56:12.190 --> 00:56:13.190
I mean, down in the language, it was very
much not designed for it. So we could move

00:56:13.190 --> 00:56:14.190
that over into the vertex shader and probably
get a lot more performance out of that, a

00:56:14.190 --> 00:56:15.190
whole lot more, I'm sure. And we've seen that
as a common hotspot because each one of those,

00:56:15.190 --> 00:56:16.190
even the little rotating things are still
running this deformation code. And certainly

00:56:16.190 --> 00:56:17.190
all the characters are. So there are a few
other things like that, but those are essential

00:56:17.190 --> 00:56:18.190
the bigger hotspots when your running in the
game. GWT compiler optimizations; one of the

00:56:18.190 --> 00:56:19.190
goals also was--well, at least for me, personally--was
discovered things we could do in the compiler

00:56:19.190 --> 00:56:20.190
that we're not currently doing as well we
could. This is a big complex, apps. There's

00:56:20.190 --> 00:56:21.190
a lot of opportunities to learn from it. We
discovered a couple of particular things that

00:56:21.190 --> 00:56:22.190
were nasty for this code that are a little
unusual. One, it initializes lots of little

00:56:22.190 --> 00:56:23.190
bit arrays. Usually for, you know, major [INDISTINCT].
And that is unfortunately--that unfortunately

00:56:23.190 --> 00:56:24.190
incurs some overhead in the GWT compiler output
right now that we aim to eliminate. Just some

00:56:24.190 --> 00:56:25.190
minor semantic fix-up between Java and JavaScript
arrays, but we can get rid of that. I'm going

00:56:25.190 --> 00:56:26.190
to make Ray do that because he's a better
compiler guy than me. Lazy Static initializers

00:56:26.190 --> 00:56:27.190
are also a serious problem. So static initialization
when you hit a class for the first time, we

00:56:27.190 --> 00:56:28.190
do that lazily because that's the Java Semantics.
And because there are so many static methods

00:56:28.190 --> 00:56:29.190
in this code, you're triggering the static
initializers everywhere. We--I've been pushing

00:56:29.190 --> 00:56:30.190
to eliminate those for a long time even if
we do break the Java Semantics to make it

00:56:30.190 --> 00:56:37.400
a dash X atomization or something. That would
make a pretty big difference and, you know,

00:56:37.400 --> 00:56:40.931
at a complete guess, I would guess, we could
probably get 20% or so or at least more speed

00:56:40.931 --> 00:56:41.931
out of those--out of those kind of changes,
maybe more than that but I may be wrong about

00:56:41.931 --> 00:56:50.180
that mesh animation stuff. And if we were
to completely rewrite the code rather than

00:56:50.180 --> 00:56:52.890
just porting what was there, there are probably
a lot of other things where the code--they're

00:56:52.890 --> 00:56:53.890
doing things that made sense and see that
are probably, you know, had become awkward

00:56:53.890 --> 00:56:54.890
through translation. So that puts us in the--let's
say, that puts us in the realm of, you know,

00:56:54.890 --> 00:56:55.890
40% faster. There, you're talking about something
that's tractable like that's, you could build

00:56:55.890 --> 00:56:59.530
a real game that way. You're not going to
build Crisis 27 this way but, you know, the

00:56:59.530 --> 00:57:00.530
far crime which everyone is the engine, which
everyone is the game. You're not going to

00:57:00.530 --> 00:57:01.530
be building that in the browser anytime soon
using JavaScript. And probably you're not

00:57:01.530 --> 00:57:02.530
going to want to port your C game to JavaScript
anyway if you have a game written in C, you're

00:57:02.530 --> 00:57:03.810
probably going to want to use native client
for that. It's a perfectly sensible thing

00:57:03.810 --> 00:57:07.020
to do. We just wanted to prove the balance
of where it could get to. So, then it comes

00:57:07.020 --> 00:57:11.410
to questions of "What do I do to make the
browser itself faster?" Now the JavaScript

00:57:11.410 --> 00:57:21.220
engine could get faster but there's probably
some inherent limits there. I don't know what

00:57:21.220 --> 00:57:25.390
those limits are. I should probably ask the
V8 guys what they think the limits are. But

00:57:25.390 --> 00:57:28.610
it's going to have--there's going to be some
limits on that. One thing we really did find

00:57:28.610 --> 00:57:30.570
though, because this is really probably one
of the first big things built on top of WebGL

00:57:30.570 --> 00:57:31.570
is certainly that I'm aware of. And we really
wanted to push on the APIs before they were

00:57:31.570 --> 00:57:32.570
solidified so that we could push back if there
are things that needed to change. What we

00:57:32.570 --> 00:57:33.570
really discovered was in--I mentioned earlier
that loading was really slow. I mean that

00:57:33.570 --> 00:57:34.630
load--that map should have loaded it. It was
completely cached. It should have loaded in

00:57:34.630 --> 00:57:37.090
less than a second or two. I mean there's
a lot of stuff in there. You know, there's

00:57:37.090 --> 00:57:38.510
two megs of binary data or so for the level
itself plus the mesh animations and so forth

00:57:38.510 --> 00:57:39.960
take up some space. Parsing that binary data
in JavaScript is excruciatingly slow. If you've

00:57:39.960 --> 00:57:41.800
ever--if you want to understand how slow it
is, go try to write parse float in JavaScript

00:57:41.800 --> 00:57:42.800
from bits. It's exactly as bad as you might
imagined and we hit that thousands and thousands

00:57:42.800 --> 00:57:43.800
and thousands and thousands of times in the
course of loading a level. Which begs the

00:57:43.800 --> 00:57:44.800
question, "Why are we even parsing floats
in JavaScript? Why can't we just pass that

00:57:44.800 --> 00:57:45.800
data directly through the WebGL?" And WebGL
has these TypedArray classes, WebGL, ArrayWebGL,

00:57:45.800 --> 00:57:46.800
FloatArray, et cetera for this purpose, for
loading data directly to the card efficiently.

00:57:46.800 --> 00:57:47.800
The problem is the gap's not covered between
XML HTTP request, WebSockets, and the WebGL

00:57:47.800 --> 00:57:48.800
layer. They don't speak the same language.
So you end up having to parse all those data

00:57:48.800 --> 00:57:49.800
out in a slow way in JavaScript or Strings,
Strings and then ultimately bit fields, and

00:57:49.800 --> 00:57:50.800
then repackage it in a form that WebGL wants.
So it turns out that the guys at Mozilla and

00:57:50.800 --> 00:57:51.800
Khronos Group who manages WebGL's spec, and
on the Chrome team. We're already thinking

00:57:51.800 --> 00:57:52.800
about this problem. We got together and we
said, "Look if you were to make the other

00:57:52.800 --> 00:57:53.800
APIs in the browser speak the same language,
we could make processing binary data in the

00:57:53.800 --> 00:57:54.800
browser a lot faster." Some experiments yielded
results are probably to at least to, if not,

00:57:54.800 --> 00:57:55.800
more, or is the magnitude faster. That also
would have made Ray's life a lot easier with

00:57:55.800 --> 00:57:56.800
the audio example. You've, I'm sure some of
you cringed when he said "I packed it all

00:57:56.800 --> 00:57:57.800
into it. I PCM encoded it and then packed
it all into a data URI, base64 encoded it

00:57:57.800 --> 00:57:58.800
and shoved it into the URL field," like that's
just wrong. I mean it's really cool that it

00:57:58.800 --> 00:57:59.800
works, but it's just wrong. So--but that's
another perfect example of a place where if

00:57:59.800 --> 00:58:00.800
you just made all these APIs speak the same
language, you can have huge optimizations

00:58:00.800 --> 00:58:01.800
that have nothing to do with making your code
run faster and everything to do with not running

00:58:01.800 --> 00:58:02.800
code at all. So, you know--that--there are
a few other things we discovered as well.

00:58:02.800 --> 00:58:03.800
In particular that there are some inefficient
frame buffer handling in Chrome right now

00:58:03.800 --> 00:58:04.800
that the team already knows about it and is
working on. So, if you shrink that window

00:58:04.800 --> 00:58:05.800
down, the frame rate goes up pretty fast which
is kind of surprising, given that it was not

00:58:05.800 --> 00:58:06.800
pushing the card very hard. So they--they
are certainly aware of that. They're going

00:58:06.800 --> 00:58:07.800
to work on that as well. But they already
knew about it and they're working on it. So,

00:58:07.800 --> 00:58:08.800
the point, again, is let's see what we can
do with HTML5, colloquial definition of HTML5

00:58:08.800 --> 00:58:09.800
as it exist in modern browsers right now.
And that to recap--I mean to reiterate what

00:58:09.800 --> 00:58:10.800
we actually showed there where that was--that
demo was WebSockets, WebGL, audio, where I

00:58:10.800 --> 00:58:11.800
showed the video tag earlier.
&gt;&gt; Local storage.

00:58:11.800 --> 00:58:12.800
&gt;&gt; WEBBER: Local storage, right, local storage
per settings and preferences, things like

00:58:12.800 --> 00:58:13.800
that. And the Canvas itself obviously mixed
2D and 3D rendering. Anything else? I think

00:58:13.800 --> 00:58:14.800
that was it?
&gt;&gt; HAUSTEIN: HTML5 would probably.

00:58:14.800 --> 00:58:15.800
&gt;&gt; WEBBER: Yeah, as Ray said, if it's an HTML5,
we'd probably use it. And that was kind of

00:58:15.800 --> 00:58:16.800
the point. And, you know, again, this is not
for necessarily--we're not suggesting that

00:58:16.800 --> 00:58:17.800
everyone should go porting their C games to
JavaScript but I think this is a pretty compelling

00:58:17.800 --> 00:58:18.800
demo. What you can actually get done now,
completely ignoring the native stack. I mean,

00:58:18.800 --> 00:58:19.800
I think that is pretty impressive. And this--doing
these kinds of demos will help us continue

00:58:19.800 --> 00:58:20.800
to get the APIs right so that we have proofs
of concept before the API solidify, and we

00:58:20.800 --> 00:58:21.800
can really build the browser into a real platform.
So, and I think this is probably--you're probably

00:58:21.800 --> 00:58:22.800
aware of this but the code is all--it's all
an open source. It's all on a Google code

00:58:22.800 --> 00:58:23.800
projects so you're welcome to download it
and try it yourself. Obviously, we don't own

00:58:23.800 --> 00:58:24.800
Quake, so we can't just put up our own servers
and let everyone play, but it's really easy.

00:58:24.800 --> 00:58:25.800
There's a couple of scripts. Download it and
try it yourself and get LAN multiplayer death

00:58:25.800 --> 00:58:26.800
matches going like it's 1997. So, a few thanks
also before I forget, ED Software for being

00:58:26.800 --> 00:58:27.800
a really, really awesome about open sourcing
almost everything they do after it gets only

00:58:27.800 --> 00:58:28.800
slightly long in a tooth, Bytonic Software
for doing the actual Jake2port of Quake and

00:58:28.800 --> 00:58:29.800
proving that it could actually be really fast
in Java, and the Khronos Group for maintaining

00:58:29.800 --> 00:58:30.800
and actually pushing the spec forward. Also
Vladimir, I would simply say Vladimir. If

00:58:30.800 --> 00:58:31.800
anyone has any idea how to pronounce his last
name? Please let me know. Thank you very much

00:58:31.800 --> 00:58:32.800
for getting this whole thing started, and
somebody--the guy at Mozilla who really kicked

00:58:32.800 --> 00:58:33.800
off this whole process. And, Ray wants a special
shoutout for [INDISTINCT] of Covert BitOps

00:58:33.800 --> 00:58:34.800
who actually provided the license Commodore
64 music. We really wanted to play the Commando

00:58:34.800 --> 00:58:35.800
theme but, you know, we can't even find who
owns it anymore, so.

00:58:35.800 --> 00:58:36.800
&gt;&gt; I think [INDISTINCT] Commodore 64 [INDISTINCT]
greets.

00:58:36.800 --> 00:58:37.800
&gt;&gt; WEBBER: Greets to, yes, you're right. That
would be the hacker term, "greets to" [INDISTINCT],

00:58:37.800 --> 00:58:38.800
so thank you very much for providing that,
and thank you all for sitting through this,

00:58:38.800 --> 00:58:39.800
we appreciate it. With any luck, feel free
to come to the microphones if you have questions,

00:58:39.800 --> 00:58:40.800
and I'm going to try and cover the ones in
the [INDISTINCT} the moderator link as well.

00:58:40.800 --> 00:58:41.800
We'll do a little of both.
&gt;&gt; Hey. Well...

00:58:41.800 --> 00:58:42.800
&gt;&gt; WEBBER: Wow.
&gt;&gt; Is that image library posted somewhere?

00:58:42.800 --> 00:58:43.800
&gt;&gt; WEBBER: I'm sorry?
&gt;&gt; The image from the first example. The image

00:58:43.800 --> 00:58:44.800
library, is that GWT library posted somewhere?
&gt;&gt; WEBBER: Oh, the image. Did you put that

00:58:44.800 --> 00:58:45.800
up on the...
&gt;&gt; CROMWELL: No, it's not available yet because

00:58:45.800 --> 00:58:46.800
it's kind of in a wonky state. But as soon
as it is in a nice state with some documentation,

00:58:46.800 --> 00:58:47.800
I will be releasing it. I'll probably announce
it on GWT users or GWT contributors list.

00:58:47.800 --> 00:58:48.800
&gt;&gt; Okay, thanks.
&gt;&gt; WEBBER: Okay, yeah, and as soon as we,

00:58:48.800 --> 00:58:49.800
as soon as Ray gets a little post eye of sleep,
he'll probably do that. And I'm going to go

00:58:49.800 --> 00:58:50.800
back and forth if it's okay between there
and the--wow, that's a lot of percent 20s.

00:58:50.800 --> 00:58:51.800
We will be promoting the use of with GWT with
WebGL as a gain development platform. I think

00:58:51.800 --> 00:58:52.800
I've addressed that. You know, this is an
experiment more than it is an actual proposal

00:58:52.800 --> 00:58:53.800
for the way you should be doing things but
it's something to learn from. And, yeah?

00:58:53.800 --> 00:58:54.800
&gt;&gt; SO, I've certainly never, I've certainly
never have ported any, you know, graphics,

00:58:54.800 --> 00:58:55.800
games, or anything like that. But I've created
a couple libraries, Java libraries that are

00:58:55.800 --> 00:58:56.800
meant to be targeted both by javac and by
the GWT compiler.

00:58:56.800 --> 00:58:57.800
&gt;&gt; WEBBER: Right.
&gt;&gt; Rather than having two sets of code, I've

00:58:57.800 --> 00:58:58.800
sort of, you know, gone through the strife
of trying to make, you know, one little--one

00:58:58.800 --> 00:58:59.800
package that can sort of be used in either
situation.

00:58:59.800 --> 00:59:00.800
&gt;&gt; WEBBER: Right.
&gt;&gt; And I've done that a few times now and

00:59:00.800 --> 00:59:01.800
I've started to see some of the abstractions
that can be made--Anyway, so, I'm just wondering

00:59:01.800 --> 00:59:02.800
if, you know, the GWT team at Google has started
to notice similar abstractions and if there's

00:59:02.800 --> 00:59:03.800
any effort or dream to come up with a set
of standards for making libraries that are

00:59:03.800 --> 00:59:04.800
meant to be compiled by either javac, or the
GWT compiler.

00:59:04.800 --> 00:59:05.800
&gt;&gt; WEBBER: Right, so I mean, I wouldn't say
as such in an overarching effort but there

00:59:05.800 --> 00:59:06.800
are particular cases where, for example, we've
run into problems with like collections being

00:59:06.800 --> 00:59:07.800
inefficient when like maps and sets, in particular,
being hyper inefficient when--well, barely

00:59:07.800 --> 00:59:08.800
inefficient when translated to JavaScript.
And we're trying to, for example, look at

00:59:08.800 --> 00:59:09.800
replacing some of those collections or with
lighter weight versions, for example, where

00:59:09.800 --> 00:59:10.800
it would--that would work well on a server
but also are built with the constraints of

00:59:10.800 --> 00:59:11.800
JavaScript in mind. If there are other cases
that you're hitting--I know there are some

00:59:11.800 --> 00:59:12.800
cases where we're simply missing like the
strain constructor that takes a byte array.

00:59:12.800 --> 00:59:13.800
Mostly because it's a giant paint implemented
in JavaScript, and we had, we ran into a bunch

00:59:13.800 --> 00:59:14.800
of those as well. But if there are specific
cases that you've hit and if you're noticing

00:59:14.800 --> 00:59:15.800
a pattern of cases you've hit where you had
to do extra work to make the code work on

00:59:15.800 --> 00:59:16.800
both server and the client, and assuming it
wasn't things like, you know, thread that's

00:59:16.800 --> 00:59:17.800
just not going to work. We probably should
actually be accumulating that knowledge somewhere.

00:59:17.800 --> 00:59:18.800
So, if you could bring it up on the contributor
list, I'd really appreciate that actually.

00:59:18.800 --> 00:59:19.800
It'd be really helpful.
&gt;&gt; CROMWELL: I think it's fair to say also

00:59:19.800 --> 00:59:20.800
that we've kind of been thinking a lot about
code that runs in multiple context lately

00:59:20.800 --> 00:59:21.800
in sort of ways that we can tweak the super
source mechanism to sort of generalize it

00:59:21.800 --> 00:59:22.800
more and...
&gt;&gt; WEBBER: Right.

00:59:22.800 --> 00:59:23.800
&gt;&gt; CROMWELL: I think that's--maybe in the
future we'll have better answer for sort of

00:59:23.800 --> 00:59:24.800
a hacky way that's done today.
&gt;&gt; WEBBER: Right, right, and that can actually

00:59:24.800 --> 00:59:25.800
really go along with those answering questions
about, not just server and client but also

00:59:25.800 --> 00:59:26.800
say GWT client and Android client. Yeah, so
you can share code there as well. From here?

00:59:26.800 --> 00:59:27.800
&gt;&gt; Cross-browser compatibility has always
kind of been a paramount goal of Web development

00:59:27.800 --> 00:59:28.800
that I felt. What do you tell somebody with
a bad GPU, or a non-open GL 2.0 capable GPU

00:59:28.800 --> 00:59:29.800
that can do these GLSL and VBO things that
you guys are putting on to a browser. The

00:59:29.800 --> 00:59:30.800
same thing video game vendors say, you're
screwed or what?

00:59:30.800 --> 00:59:31.800
&gt;&gt; WEBBER: I would say--and feel free to butt
in if you guy have other thoughts. I mean

00:59:31.800 --> 00:59:32.800
there's a serious problem, right, especially
on Windows platforms where you tend have a

00:59:32.800 --> 00:59:33.800
pretty good DirectX driver and a really terrible
OpenGL driver--does anyone remember the name

00:59:33.800 --> 00:59:34.800
of the project that we open sourced recently
to.

00:59:34.800 --> 00:59:35.800
&gt;&gt; The angle, the angle project.
&gt;&gt; WEBBER: What was it?

00:59:35.800 --> 00:59:36.800
&gt;&gt; The angle project, A-N-G-L-E? [INDISTINCT].
&gt;&gt; WEBBER: Oh, that's it, that's it, exactly.

00:59:36.800 --> 00:59:37.800
Yeah, but--so that's one opportunity, someone's
just really needed to sit down and write a

00:59:37.800 --> 00:59:38.800
good OpenGL on DirectX abstraction. Probably
comes in some overhead, but it's a lot less

00:59:38.800 --> 00:59:39.800
overhead to not running at all. And, you know,
and this is sort of forward-looking, all right?

00:59:39.800 --> 00:59:40.800
I mean, this is--these are things that--this
will be serious problems. People on bad GPUs

00:59:40.800 --> 00:59:41.800
or people that only support, you know, the
simplest kinds of shaders and things like

00:59:41.800 --> 00:59:42.800
that. So we view this is really forward looking
in that sense.

00:59:42.800 --> 00:59:43.800
&gt;&gt; Is there any type of CPU fallback mechanism
in WebGL? Or it would just be so unbearably

00:59:43.800 --> 00:59:44.800
slow, it's not worth it?
&gt;&gt; WEBBER: It would probably be slow. So slow

00:59:44.800 --> 00:59:45.800
it wouldn't be worth the trouble.
&gt;&gt; CROMWELL: I think for the...

00:59:45.800 --> 00:59:46.800
&gt;&gt; WEBBER: But it's not directly true. That--there
are some, but it would have to be at the driver

00:59:46.800 --> 00:59:47.800
level.
&gt;&gt; CROMWELL: I think maybe what Khronos was

00:59:47.800 --> 00:59:48.800
getting at is because OpenGL was such an enormously
large library. They kind of maybe went a little

00:59:48.800 --> 00:59:49.800
bit too far in stripping it down. But the
idea was basically if they remove all of the

00:59:49.800 --> 00:59:50.800
old fix function cruft, they can make the
surface area they [INDISTINCT] a lot smaller.

00:59:50.800 --> 00:59:51.800
So for like iPhones and mobile devices, it
could be more compact. And the people who

00:59:51.800 --> 00:59:52.800
are partnered with Khronos, basically--or
essentially, voting on that spec and their

00:59:52.800 --> 00:59:53.800
saying, "Yeah," Apple is saying, "Yes, we
will put a GPU capable of doing OpenGL ES."

00:59:53.800 --> 00:59:54.800
And probably Android came to saying, "Yes,
we will do that." So that's probably how that,

00:59:54.800 --> 00:59:55.800
it arrived at that state where it's like,
if you got a DirectX 8 card on a Windows machine,

00:59:55.800 --> 00:59:56.800
you're probably out of luck. But we do have
a Canvas Renderer so if you want to go with

00:59:56.800 --> 00:59:57.800
flat shading, you can still play it. You just
won't get textures.

00:59:57.800 --> 00:59:58.800
&gt;&gt; WEBBER: Right, one of the thing on that
front is that if you look at where OpenGL

00:59:58.800 --> 00:59:59.800
is going, WebGL, OpenGL, you know, all the
new Android device--all the Android devices,

00:59:59.800 --> 01:00:00.800
all the iPhones, I believe the Palms as well
are supporting in baseline of GL ES 1.5 or

01:00:00.800 --> 01:00:01.800
2.0 whichever it is. So, that actually could--if
that forces GPU manufacturers across the board

01:00:01.800 --> 01:00:02.800
to get into a mode where pretty much any device
that you get. I mean we're talking, you know,

01:00:02.800 --> 01:00:03.800
my little phone has a pretty good--you know,
pretty solid driver on it. That can provide

01:00:03.800 --> 01:00:04.800
a pretty stable baseline. And that's a pretty,
that's a good enough baseline to do anything

01:00:04.800 --> 01:00:05.800
that we can do for example. I mean, it's pretty
much a similar level of functionality so.

01:00:05.800 --> 01:00:06.800
It's a little farther off in the future, I
think, before that long tail of old GPUs goes

01:00:06.800 --> 01:00:07.800
away. But once we can get to that point, we
have a pretty stable baseline for writing

01:00:07.800 --> 01:00:08.800
code across a wide range of devices, okay.
Sir?

01:00:08.800 --> 01:00:09.800
&gt;&gt; Sort of three implementation questions.
The first one Web servers is UTF-8 bound.

01:00:09.800 --> 01:00:10.800
Did you guys use BSON, B-S-O-N, for encoding?
&gt;&gt; WEBBER: Oh, you don't want to know what

01:00:10.800 --> 01:00:11.800
we use. I'm just kidding. It's--we--okay,
I'll not to drive too deep on this. We have

01:00:11.800 --> 01:00:12.800
seven minutes, but, very briefly we cheated
like crazy and use the custom encoding which

01:00:12.800 --> 01:00:13.800
cause it through every byte as a separate
entity. There's a few, I found a few libraries

01:00:13.800 --> 01:00:14.800
that use this trick. You have to fix up anything
that falls above HEX, FF, something or other--or

01:00:14.800 --> 01:00:15.800
something like those weird fix up code you
have to do. And this is precisely the kind

01:00:15.800 --> 01:00:16.800
of stuff that we basically--the precise of
the reason that we wanted to move binary support

01:00:16.800 --> 01:00:17.800
directly into XHR and WebSocket and things
like that. I mean strings are just not always

01:00:17.800 --> 01:00:18.800
the right--lowest common denominator. In fact,
it was--even if you take something like JSON--we

01:00:18.800 --> 01:00:19.800
tried base64 encoding. That was even worse.
Base64 encoding was really, really slow, comparatively

01:00:19.800 --> 01:00:20.800
speaking. We're talking about two megs, you
know, plus base64 overhead. That just takes

01:00:20.800 --> 01:00:21.800
forever to decode. And we've tried, we even
tried JSON encoding. The thing is, you're

01:00:21.800 --> 01:00:22.800
parsing an entire programming language when
you do that and it is, you know, you think

01:00:22.800 --> 01:00:23.800
of it as really fast in a browser because
it's so much faster than anything you could

01:00:23.800 --> 01:00:24.800
write by hand. But it was, in my experiment,
it was 250 times slower. Almost precisely

01:00:24.800 --> 01:00:25.800
than the equivalent just raw packed buffers
passing on the straight through. We kind of

01:00:25.800 --> 01:00:26.800
hacked up Chrome a little bit to do that.
And so that's, again, that's the reason to

01:00:26.800 --> 01:00:27.800
work around that, to do that. String encodings
are the only option you have right now though.

01:00:27.800 --> 01:00:28.800
You're absolutely correct about that.
&gt;&gt; And the second question is, resource loading

01:00:28.800 --> 01:00:29.800
and mesh loading you mentioned are using JSON.
Did you guys look into doing, say, loading

01:00:29.800 --> 01:00:30.800
a texture, binding it on a Canvas, and then
pulling it in as--rendering it with a vertex

01:00:30.800 --> 01:00:31.800
shader like a hide map fields sort of thing?
&gt;&gt; WEBBER: Sorry, loading texture, I miss

01:00:31.800 --> 01:00:32.800
that.
&gt;&gt; Loading a texture, and then using a vertex

01:00:32.800 --> 01:00:33.800
shader to adjust the mesh?
&gt;&gt; WEBBER: Oh, you mean to--you mean for adjusting

01:00:33.800 --> 01:00:34.800
the textures themselves, the gamma correction,
and that sort of thing?

01:00:34.800 --> 01:00:35.800
&gt;&gt; A faster way to load the resource, the
mesh resource.

01:00:35.800 --> 01:00:36.800
&gt;&gt; WEBBER: Oh, oh, oh, oh.
&gt;&gt; CROMWELL: He means like decoding them,

01:00:36.800 --> 01:00:37.800
I think, isn't it?
&gt;&gt; WEBBER: I'm not sure, that might have work.

01:00:37.800 --> 01:00:38.800
It would be--you'd be paying for a buffer
copy backs from the, over the card. That probably

01:00:38.800 --> 01:00:39.800
is still faster than what we did. Would you
explore that?

01:00:39.800 --> 01:00:40.800
&gt;&gt; CROMWELL: Yeah.
&gt;&gt; WEBBER: That would, that might actually

01:00:40.800 --> 01:00:41.800
work. It's kind of a freakish hack...
&gt;&gt; CROMWELL: Yeah, our first...

01:00:41.800 --> 01:00:42.800
&gt;&gt; WEBBER: ...but it will be really cool if
it worked.

01:00:42.800 --> 01:00:43.800
&gt;&gt; CROMWELL: Our first hack [INDISTINCT] was
using like CanvasPixelArray and we were, because

01:00:43.800 --> 01:00:44.800
it was Quake code where it's doing like its
processing images before it uploads into the--and

01:00:44.800 --> 01:00:45.800
puts them in the image and its like doing
gamma correction.

01:00:45.800 --> 01:00:46.800
&gt;&gt; WEBBER: Right.
&gt;&gt; CROMWELL: We have the light maps get all

01:00:46.800 --> 01:00:47.800
processed up and...
&gt;&gt; WEBBER: We ultimately dropped most of that,

01:00:47.800 --> 01:00:48.800
right?
&gt;&gt; CROMWELL: Yeah, we dropped most of it.

01:00:48.800 --> 01:00:49.800
&gt;&gt; WEBBER: The light maps are still processed
by hand, I think, but anyway. I'll come back

01:00:49.800 --> 01:00:50.800
to that, but sorry. Question?
&gt;&gt; When will GWT support a file API?

01:00:50.800 --> 01:00:51.800
&gt;&gt; WEBBER: Support?
&gt;&gt; File API.

01:00:51.800 --> 01:00:52.800
&gt;&gt; WEBBER: Oh, file API? I think there is--so
there's often a little misconception about

01:00:52.800 --> 01:00:53.800
what GWT sort of supports and doesn't? As
I mentioned in the beginning, there are things

01:00:53.800 --> 01:00:54.800
that we have baked into the actual core jars
that again here to four have always tried--we've

01:00:54.800 --> 01:00:55.800
always tried to make a cross browser. But
there are a lot of open source projects. And

01:00:55.800 --> 01:00:56.800
in fact some of the--if you look up on going
Google code, the regular project hosting site,

01:00:56.800 --> 01:00:57.800
search for GWT and HTML5, you'll find two
or three libraries. They seem to be converging.

01:00:57.800 --> 01:00:58.800
Most of them are written by external people,
but we're just eventually going to talk to

01:00:58.800 --> 01:00:59.800
them about bringing their code in that abstracts,
you know, WebSockets, file API, local storage,

01:00:59.800 --> 01:01:00.800
WebGL, Canvas, et cetera. So--and they're
solid. They seem to be from what I've seen.

01:01:00.800 --> 01:01:01.800
So, don't hesitate to look there for other
sources of APIs. We'll--again, we'll try to

01:01:01.800 --> 01:01:02.800
bring those in as fast as we can, but it definitely
it shouldn't stop you from using those.

01:01:02.800 --> 01:01:03.800
&gt;&gt; Yes.
&gt;&gt; WEBBER: Let's see, more GWT, [INDISTINCT]

01:01:03.800 --> 01:01:04.800
support Canvas, I think that's pretty clear.
Unrelated.

01:01:04.800 --> 01:01:05.800
&gt;&gt; CROMWELL: Size question.
&gt;&gt; WEBBER: Oh, that's--okay, so this question

01:01:05.800 --> 01:01:06.800
is about white paper describing the whole
process. I guess we have a slide deck now.

01:01:06.800 --> 01:01:07.800
Stefan went into quite some detail on that.
And SVG, [INDISTINCT], et cetera. Again, look

01:01:07.800 --> 01:01:08.800
for third party libraries. People--you know,
we're fairly a small team and there are a

01:01:08.800 --> 01:01:09.800
lot of people out there doing a lot of good
work faster than we can ever get around to

01:01:09.800 --> 01:01:10.800
it. So definitely look for open source projects
when it comes to these things. And, what will

01:01:10.800 --> 01:01:11.800
happen to flash? Those are good questions.
I have no idea. Hopefully, it will continue

01:01:11.800 --> 01:01:12.800
to do very well as it's moving into Android
and so forth.

01:01:12.800 --> 01:01:13.800
&gt;&gt; CROMWELL: On the size question, I think
the compiled and gzip Quake binary, the Quake

01:01:13.800 --> 01:01:14.800
binary is like, I think it's like a 100K or
something.

01:01:14.800 --> 01:01:15.800
&gt;&gt; WEBBER: Gzip maybe.
&gt;&gt; CROMWELL: Yeah, gzip. It's like a 100K.

01:01:15.800 --> 01:01:16.800
So it's actually, it's not too large.
&gt;&gt; WEBBER: Right.

01:01:16.800 --> 01:01:17.800
&gt;&gt; CROMWELL: It's the--all of the RSS are
actually the large part of it.

01:01:17.800 --> 01:01:18.800
&gt;&gt; WEBBER: Right. Anyone else? [INDISTINCT].
Nope. Okay. Well, thanks again, everybody.

01:01:18.800 --> 01:01:19.800
I appreciate your time.
&gt;&gt; HAUSTEIN: Thank you.

01:01:19.800 --> 01:01:19.803
&gt;&gt; WEBBER: And, okay.

