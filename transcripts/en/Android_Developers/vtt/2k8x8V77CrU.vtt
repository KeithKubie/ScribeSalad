WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.872
[MUSIC PLAYING]

00:00:07.750 --> 00:00:08.710
IAN LAKE: Hi, everyone.

00:00:08.710 --> 00:00:10.240
Thanks for joining me.

00:00:10.240 --> 00:00:11.550
My name is Ian Lake.

00:00:11.550 --> 00:00:14.160
I am a developer on
the Android team.

00:00:14.160 --> 00:00:17.550
And I work on quite a few
projects, but most notably

00:00:17.550 --> 00:00:20.880
the Navigation architecture
component, as well as

00:00:20.880 --> 00:00:23.160
Fragments, as well as
some of our new libraries,

00:00:23.160 --> 00:00:27.020
like the AndroidX Activity
Artifact and Loaders.

00:00:27.020 --> 00:00:30.870
And today, I wanted to talk
to you about Single Activity--

00:00:30.870 --> 00:00:34.260
Why, When, and How, and
really try and share

00:00:34.260 --> 00:00:37.410
some of the best practices
from the Android team

00:00:37.410 --> 00:00:41.250
and from the architecture
component team on what actually

00:00:41.250 --> 00:00:42.985
is going on in this world.

00:00:42.985 --> 00:00:49.350
There's been a lot of questions
way back from 2014, '16,

00:00:49.350 --> 00:00:51.580
and even here in 2018.

00:00:51.580 --> 00:00:53.670
So we're here today
to kind of talk

00:00:53.670 --> 00:00:56.310
over all of those
wonderful things that

00:00:56.310 --> 00:00:59.570
make up what are activities.

00:00:59.570 --> 00:01:03.960
So activities are really a
component at the Android level.

00:01:03.960 --> 00:01:07.680
So they're at the same level
as content providers, broadcast

00:01:07.680 --> 00:01:09.690
receivers, and services.

00:01:09.690 --> 00:01:12.030
And they're registered in
your Android manifests.

00:01:12.030 --> 00:01:16.740
And really, they are the UI
facing pieces of your app.

00:01:16.740 --> 00:01:19.020
So when the Android
framework goes

00:01:19.020 --> 00:01:22.320
to start your application
from a launcher icon or an app

00:01:22.320 --> 00:01:25.770
shortcut or what you see when
you're doing multi window,

00:01:25.770 --> 00:01:28.350
those are all activities.

00:01:28.350 --> 00:01:33.180
So they really are kind of the
entry point into your app's UI.

00:01:33.180 --> 00:01:35.700
When the user goes
to launch your app,

00:01:35.700 --> 00:01:39.190
they're launching an activity.

00:01:39.190 --> 00:01:42.370
And we had a very interesting
quote from Dianne Hackborn

00:01:42.370 --> 00:01:47.050
back in 2016 that, "Once we've
gotten into this entry-point

00:01:47.050 --> 00:01:50.020
to your UI, we
really don't care how

00:01:50.020 --> 00:01:52.280
you organize the flow inside."

00:01:52.280 --> 00:01:55.180
Now, this was 2016.

00:01:55.180 --> 00:01:59.590
And I think it
was controversial,

00:01:59.590 --> 00:02:02.050
I guess, in 2016.

00:02:02.050 --> 00:02:05.860
Maybe we'll just say it
had 77 comments on Google+.

00:02:05.860 --> 00:02:13.950
So a lot of people were really
enthusiastic about this post.

00:02:13.950 --> 00:02:17.110
But really, what does it mean?

00:02:17.110 --> 00:02:20.840
Well, what I think it
means is that the framework

00:02:20.840 --> 00:02:23.050
shouldn't care.

00:02:23.050 --> 00:02:25.720
The framework shouldn't care
about your application's

00:02:25.720 --> 00:02:27.340
architecture.

00:02:27.340 --> 00:02:31.360
It needs to provide the
hooks needed for the Android

00:02:31.360 --> 00:02:35.492
framework to start
your application.

00:02:35.492 --> 00:02:38.310
But you should probably
care about the architecture

00:02:38.310 --> 00:02:39.210
of your app.

00:02:39.210 --> 00:02:40.890
That's why you're
all here today.

00:02:40.890 --> 00:02:43.630
And I love having you here.

00:02:43.630 --> 00:02:46.650
So the biggest problem
is that you really

00:02:46.650 --> 00:02:51.120
don't know what an activity
is actually going to do.

00:02:51.120 --> 00:02:54.570
So what's the default
animation for an activity?

00:02:54.570 --> 00:02:55.370
Well, it depends.

00:02:55.370 --> 00:02:58.200
It depends on the
version of Android,

00:02:58.200 --> 00:03:03.450
what manufacturer you're on,
and even what themes the user

00:03:03.450 --> 00:03:06.220
has selected.

00:03:06.220 --> 00:03:10.260
So similarly, we had
property animations

00:03:10.260 --> 00:03:12.870
that were added in API 11.

00:03:12.870 --> 00:03:17.770
And they're much superior
to view animations.

00:03:17.770 --> 00:03:20.850
And the thing is that while
these new things become

00:03:20.850 --> 00:03:23.100
possible on a new
version of Android,

00:03:23.100 --> 00:03:26.700
they're not always
applied to everything.

00:03:26.700 --> 00:03:31.510
And things like activities,
they don't support property

00:03:31.510 --> 00:03:34.650
animations at all, even today.

00:03:34.650 --> 00:03:38.650
And even if we were to add them
in the next version of Android,

00:03:38.650 --> 00:03:42.740
maybe the letter
after P, we wouldn't

00:03:42.740 --> 00:03:44.510
be able to backport
them, because they're

00:03:44.510 --> 00:03:46.970
part of the framework.

00:03:46.970 --> 00:03:51.410
So thinking about all these
things, it's like, well, OK,

00:03:51.410 --> 00:03:54.110
what should an
activity be used for?

00:03:54.110 --> 00:03:56.000
Why do we even have activities?

00:03:56.000 --> 00:03:59.300
They're useful as this entry
point, but then beyond that,

00:03:59.300 --> 00:04:01.210
you're in your realm.

00:04:01.210 --> 00:04:04.280
You're in your realm of
what your app needs to do.

00:04:04.280 --> 00:04:06.440
And you don't
necessarily need to rely

00:04:06.440 --> 00:04:12.200
on activities being the thing
that you have to work with.

00:04:12.200 --> 00:04:14.230
So let's take an example.

00:04:14.230 --> 00:04:16.089
Here we have some
code like this.

00:04:16.089 --> 00:04:18.100
We're calling startActivity.

00:04:18.100 --> 00:04:20.110
And we have to use
ActivityCompat,

00:04:20.110 --> 00:04:23.400
because we want to do a
shared element transition.

00:04:23.400 --> 00:04:25.450
So create our intent.

00:04:25.450 --> 00:04:29.350
And then we say, oh, we want to
have this one element shared.

00:04:29.350 --> 00:04:32.920
Well, what API does
this actually work on?

00:04:32.920 --> 00:04:35.500
Well, it depends on what
you mean by "work," right?

00:04:35.500 --> 00:04:37.840
It technically
launches an activity.

00:04:37.840 --> 00:04:40.750
That's true, but it's
only actually going

00:04:40.750 --> 00:04:43.810
to do a shared element
transition on newer devices,

00:04:43.810 --> 00:04:45.810
API 21-plus.

00:04:45.810 --> 00:04:49.910
And really, how many compact
shims do we need in our life?

00:04:49.910 --> 00:04:51.150
It technically works.

00:04:51.150 --> 00:04:54.100
You're saving some API
checks, but really this

00:04:54.100 --> 00:04:56.810
isn't the prettiest
code to look at.

00:04:56.810 --> 00:05:00.100
And similarly, are there
any hidden gotchas?

00:05:00.100 --> 00:05:02.966
If you are testing this on
the latest version of Android,

00:05:02.966 --> 00:05:04.840
if you tested on an
older version of Android,

00:05:04.840 --> 00:05:07.020
are you actually going to
get the same experience?

00:05:07.020 --> 00:05:10.450
Well, in this example, I
actually ran into this.

00:05:10.450 --> 00:05:15.250
And I was like, oh, well,
things are fading in and out.

00:05:15.250 --> 00:05:17.410
And it's like,
sure, I chose fade.

00:05:17.410 --> 00:05:19.990
But it turns out you need to
exclude things like the status

00:05:19.990 --> 00:05:21.160
bar and navigation bar.

00:05:21.160 --> 00:05:22.960
Otherwise, they'll flicker.

00:05:22.960 --> 00:05:26.440
And I was like, OK,
well, that's fun.

00:05:26.440 --> 00:05:29.662
I wouldn't have ever known
that unless I tried it once.

00:05:29.662 --> 00:05:31.870
And I tried it on a whole
bunch of different devices.

00:05:31.870 --> 00:05:34.335
And it turns out on some
devices, it's totally fine.

00:05:34.335 --> 00:05:37.140
On other devices, not so much.

00:05:37.140 --> 00:05:39.160
So there's a lot of
little hidden gotchas

00:05:39.160 --> 00:05:44.701
here that you can't actually
control or rely on in your app.

00:05:44.701 --> 00:05:49.230
Another example where we
have multiple activities.

00:05:49.230 --> 00:05:52.990
And really, each activity
is kind of its own component

00:05:52.990 --> 00:05:54.520
in your app.

00:05:54.520 --> 00:05:56.500
So if you have two
activities and you

00:05:56.500 --> 00:05:59.230
want to share data between
them, well, there's

00:05:59.230 --> 00:06:01.282
not really a scope for that.

00:06:01.282 --> 00:06:02.740
There is a scope
for that, but it's

00:06:02.740 --> 00:06:04.280
called your application scope.

00:06:04.280 --> 00:06:05.980
It's the same
scope that's shared

00:06:05.980 --> 00:06:09.440
by services and everything
else in your app.

00:06:09.440 --> 00:06:11.980
But you really want kind of
a shared scope that's just

00:06:11.980 --> 00:06:15.310
within a couple of components.

00:06:15.310 --> 00:06:17.870
So this is a structure
that Android provides,

00:06:17.870 --> 00:06:22.110
but it's maybe not the one
you actually want to use.

00:06:22.110 --> 00:06:24.650
So what you actually want is
you want to build the layering

00:06:24.650 --> 00:06:26.580
you actually need.

00:06:26.580 --> 00:06:29.630
So in this case, we can
have multiple things,

00:06:29.630 --> 00:06:32.930
multiple destinations
within an activity,

00:06:32.930 --> 00:06:38.540
and share information across
each of these destinations

00:06:38.540 --> 00:06:43.010
by using the activity scope as
an actually useful element now.

00:06:43.010 --> 00:06:46.970
So for example, you could have
a shared view element or view

00:06:46.970 --> 00:06:50.520
model that both
destinations talk to.

00:06:50.520 --> 00:06:52.760
So one destination
could put data in,

00:06:52.760 --> 00:06:56.030
and the other one could
observe changes to that data.

00:06:56.030 --> 00:06:58.700
You don't need to work
at the application scope

00:06:58.700 --> 00:07:01.990
level for this to work.

00:07:01.990 --> 00:07:05.620
So I mentioned this
word "destination."

00:07:05.620 --> 00:07:07.120
So what is the destination?

00:07:07.120 --> 00:07:11.100
Well, really, it's just
a subsection of your UI.

00:07:11.100 --> 00:07:13.930
So for most
destinations, they're

00:07:13.930 --> 00:07:16.860
going to take over the
majority of your screen.

00:07:16.860 --> 00:07:18.450
Like when you move
from one screen

00:07:18.450 --> 00:07:20.520
to the next screen
in your app, it's

00:07:20.520 --> 00:07:23.400
going to change the vast
majority of your screen.

00:07:23.400 --> 00:07:27.480
Maybe you have some global
navigation, like a bottom nav,

00:07:27.480 --> 00:07:30.180
or maybe you have an
action bar at the top.

00:07:30.180 --> 00:07:33.440
But the rest of this is
all in a destination.

00:07:33.440 --> 00:07:35.970
So the subsection of your UI.

00:07:35.970 --> 00:07:39.000
We have a word for
this called a fragment.

00:07:39.000 --> 00:07:41.850
But a fragment is really
just one implementation

00:07:41.850 --> 00:07:45.990
of this idea of having
separate destinations

00:07:45.990 --> 00:07:48.330
for each screen in your app.

00:07:48.330 --> 00:07:50.280
And really, this
fragment is serving

00:07:50.280 --> 00:07:53.070
as kind of the view controller.

00:07:53.070 --> 00:07:56.280
The thing that isn't a
view itself, but something

00:07:56.280 --> 00:08:00.270
that owns and changes those
views, which are really

00:08:00.270 --> 00:08:02.930
more about display.

00:08:02.930 --> 00:08:06.380
So really, the activity,
instead of owning

00:08:06.380 --> 00:08:08.900
all of this business logic
and things like that,

00:08:08.900 --> 00:08:12.560
is really as small as is
physically possible, and really

00:08:12.560 --> 00:08:15.740
only working on the kind
that shared UI that's

00:08:15.740 --> 00:08:17.540
shared across all destinations.

00:08:20.250 --> 00:08:24.600
However, thinking about this, if
we're moving from this activity

00:08:24.600 --> 00:08:26.910
world to a destination
world, we really

00:08:26.910 --> 00:08:29.850
want to make that world
as easy as possible.

00:08:29.850 --> 00:08:32.669
Otherwise, why would we move?

00:08:32.669 --> 00:08:36.400
And we focused
kind of two things.

00:08:36.400 --> 00:08:39.690
One was that global
UI kind of thing.

00:08:39.690 --> 00:08:42.450
How can we make that part easy?

00:08:42.450 --> 00:08:44.220
It's something that
every app kind of

00:08:44.220 --> 00:08:46.330
has the same kind of patterns.

00:08:46.330 --> 00:08:48.720
And we really don't want
that to be something that

00:08:48.720 --> 00:08:52.200
takes a lot of effort to do.

00:08:52.200 --> 00:08:55.980
Also, the navigating
between destinations,

00:08:55.980 --> 00:09:01.690
that start ActivityCompat thing,
can we make that even easier?

00:09:01.690 --> 00:09:05.490
So we started the Navigation
architecture component

00:09:05.490 --> 00:09:10.470
and we introduced it to you all
in I/O this last year in 2018.

00:09:10.470 --> 00:09:12.500
It is still in alpha right now.

00:09:12.500 --> 00:09:15.120
And we're looking to
fill out all the feature

00:09:15.120 --> 00:09:19.560
gaps before taking
it to 1.0 here soon.

00:09:19.560 --> 00:09:22.230
But really, what
this allows us to do

00:09:22.230 --> 00:09:27.180
is take a super simple activity
like this, this set content

00:09:27.180 --> 00:09:27.690
view.

00:09:27.690 --> 00:09:32.940
We'll set an action bar,
because that's a thing, right?

00:09:32.940 --> 00:09:35.822
And we want to make this smart.

00:09:35.822 --> 00:09:37.530
We want to make this
useful, but we still

00:09:37.530 --> 00:09:40.750
want it to fit on
this one code slide.

00:09:40.750 --> 00:09:44.330
So some of this is we
need a NavController.

00:09:44.330 --> 00:09:47.190
A NavController is really
the heart of Navigation.

00:09:47.190 --> 00:09:49.020
It's the thing that
knows everything

00:09:49.020 --> 00:09:53.130
about how your app works
via a navigation graph.

00:09:53.130 --> 00:09:55.260
And we can get one--

00:09:55.260 --> 00:09:57.950
we're using Kotlin here,
Kotlin extensions--

00:09:57.950 --> 00:10:00.300
and call findNavController.

00:10:00.300 --> 00:10:04.280
And here we're just giving it
the ID of a NavHostFragment.

00:10:04.280 --> 00:10:07.320
The NavHostFragment is
basically that part of your UI

00:10:07.320 --> 00:10:10.560
that's going to change whenever
you change destinations.

00:10:10.560 --> 00:10:13.420
We'll also add an app
bar configuration.

00:10:13.420 --> 00:10:16.200
This is what controls
the up action

00:10:16.200 --> 00:10:20.810
and what needs to happen when
you move up from a destination.

00:10:20.810 --> 00:10:22.140
And how do we hook that up?

00:10:22.140 --> 00:10:24.690
Well, we have a nice one
liner that just says,

00:10:24.690 --> 00:10:25.784
set up the action bar.

00:10:25.784 --> 00:10:27.450
It gives it a
NavController and gives it

00:10:27.450 --> 00:10:29.820
an app bar configuration.

00:10:29.820 --> 00:10:33.990
Now, because we're using
a drawer layout here

00:10:33.990 --> 00:10:36.720
in our app bar
configuration, we also

00:10:36.720 --> 00:10:39.390
want to open and shut the drawer
when you hit the Up button.

00:10:39.390 --> 00:10:44.150
So we'll call navigate up
in our support navigate up.

00:10:44.150 --> 00:10:46.850
And we've set up our
whole action bar.

00:10:46.850 --> 00:10:50.060
Now it changes titles as
our destinations change.

00:10:50.060 --> 00:10:51.150
We're good.

00:10:51.150 --> 00:10:54.380
If we want to add
the navigation view

00:10:54.380 --> 00:10:57.290
and make sure that we can click
on things in our side nav,

00:10:57.290 --> 00:11:01.280
and then go to the right
place, that's, again, one line.

00:11:01.280 --> 00:11:03.560
We can do this all
because the NavController

00:11:03.560 --> 00:11:08.110
knows about our
destinations in our app.

00:11:08.110 --> 00:11:11.390
So then how do we actually
do navigate actions

00:11:11.390 --> 00:11:14.240
if we're not doing
fancy one liner stuff?

00:11:14.240 --> 00:11:17.245
Well, we can get a NavController
from basically anywhere.

00:11:17.245 --> 00:11:18.270
We're in our activity.

00:11:18.270 --> 00:11:20.000
We can use findNavController.

00:11:20.000 --> 00:11:22.480
It's even easier
from a fragment.

00:11:22.480 --> 00:11:24.260
We can just call
findNavController.

00:11:24.260 --> 00:11:27.020
And we've built the
Kotlin extension for this.

00:11:27.020 --> 00:11:29.180
And similarly, even from a view.

00:11:29.180 --> 00:11:32.780
Any view that's created by any
fragment in your navigation

00:11:32.780 --> 00:11:37.980
graph can just call
findNavController from a view.

00:11:37.980 --> 00:11:41.910
So you have this reference to
it from basically anywhere.

00:11:41.910 --> 00:11:43.940
And we really tried
to think like,

00:11:43.940 --> 00:11:47.570
all right, well, if you have
arguments to something, how

00:11:47.570 --> 00:11:50.160
do we make this nice?

00:11:50.160 --> 00:11:54.260
So we built a Gradle plugin
called Safe Args, which

00:11:54.260 --> 00:11:56.330
for every destination
in your graph,

00:11:56.330 --> 00:12:00.170
such as this Main fragment,
we generate a directions

00:12:00.170 --> 00:12:04.580
object, which has a nice simple
Show Profile method, which

00:12:04.580 --> 00:12:08.900
gives you a directions object
with type safe arguments

00:12:08.900 --> 00:12:11.020
that you defined in
your navigation graph,

00:12:11.020 --> 00:12:12.670
and then you just call Navigate.

00:12:12.670 --> 00:12:13.880
And that's it.

00:12:13.880 --> 00:12:16.660
We'll take care of all of
the fragment transaction, all

00:12:16.660 --> 00:12:19.130
of that sort of stuff for you.

00:12:19.130 --> 00:12:21.150
So it makes it a lot easier.

00:12:21.150 --> 00:12:24.302
But we can really go a lot
farther with navigation.

00:12:24.302 --> 00:12:27.110
So has anyone ever built
an intent filter before,

00:12:27.110 --> 00:12:29.240
deep linking, in your app?

00:12:29.240 --> 00:12:32.390
Has anyone enjoyed
that experience?

00:12:32.390 --> 00:12:33.380
Great.

00:12:33.380 --> 00:12:37.210
One person enjoyed
that experience.

00:12:37.210 --> 00:12:39.650
And really, you have to do
this, because this is what

00:12:39.650 --> 00:12:41.900
the Android framework knows.

00:12:41.900 --> 00:12:46.860
It knows, I can parse an intent
filter, and start an activity.

00:12:46.860 --> 00:12:50.230
But oftentimes, that's
not quite enough.

00:12:50.230 --> 00:12:52.940
You need to go a
little bit farther.

00:12:52.940 --> 00:12:55.370
So what we've done
in navigation is

00:12:55.370 --> 00:12:59.030
for any one of your fragments,
any destination in your graph,

00:12:59.030 --> 00:13:00.860
you can add a deep link.

00:13:00.860 --> 00:13:02.540
It's a simple one liner.

00:13:02.540 --> 00:13:05.270
And you can even add
arguments right here.

00:13:05.270 --> 00:13:07.730
And we'll parse those
out even for things

00:13:07.730 --> 00:13:08.660
like query parameters.

00:13:08.660 --> 00:13:10.460
We'll parse those
out, and give you them

00:13:10.460 --> 00:13:14.090
as arguments to
your destination.

00:13:14.090 --> 00:13:16.910
And then, because no one
likes writing intent filters,

00:13:16.910 --> 00:13:19.460
we'll also generate the
intent filters for you

00:13:19.460 --> 00:13:21.380
by adding a navigation graph.

00:13:21.380 --> 00:13:24.440
So this is something we actually
added to manifest merger

00:13:24.440 --> 00:13:27.570
to kind of generate
that for you.

00:13:27.570 --> 00:13:33.270
So all of this layering
helps us build nicer APIs.

00:13:33.270 --> 00:13:38.190
But it also makes it easier
to test your application.

00:13:38.190 --> 00:13:41.010
If you're testing at
the activity level, all

00:13:41.010 --> 00:13:43.230
of sudden that
means, well, how do I

00:13:43.230 --> 00:13:47.460
test that start activity
actually did the right intent?

00:13:47.460 --> 00:13:49.740
And we have to build
extra testing frameworks

00:13:49.740 --> 00:13:52.860
on top of testing frameworks to
try and mock up these things.

00:13:55.690 --> 00:13:58.390
If we're moving towards more
of a single activity model

00:13:58.390 --> 00:14:00.640
into the navigation
controller world,

00:14:00.640 --> 00:14:02.830
we still want to test
all of those things.

00:14:02.830 --> 00:14:06.160
We want that to be easy to test.

00:14:06.160 --> 00:14:08.640
So rule number one
of testing things

00:14:08.640 --> 00:14:11.160
at the destination
level is don't

00:14:11.160 --> 00:14:14.600
test the destination level.

00:14:14.600 --> 00:14:18.010
It's really the number
one thing with testing,

00:14:18.010 --> 00:14:20.290
is making things
nice and separate,

00:14:20.290 --> 00:14:22.900
and extracting some
of that business logic

00:14:22.900 --> 00:14:25.210
out of a destination
and into something

00:14:25.210 --> 00:14:27.550
you can test in isolation.

00:14:27.550 --> 00:14:30.220
So an example, a view model
is a really nice place

00:14:30.220 --> 00:14:31.840
to put some of your
business logic,

00:14:31.840 --> 00:14:35.070
because you can test
it in isolation.

00:14:35.070 --> 00:14:37.540
We have a view model
provider factory

00:14:37.540 --> 00:14:41.020
for providing view models,
where you can just inject things

00:14:41.020 --> 00:14:42.190
into your view model.

00:14:42.190 --> 00:14:45.490
Test that totally
separate from your UI.

00:14:45.490 --> 00:14:49.540
But that doesn't mean
you don't want to test

00:14:49.540 --> 00:14:51.360
any of your UI stuff at all.

00:14:51.360 --> 00:14:54.220
We have Espresso tests
for a reason, right?

00:14:54.220 --> 00:14:56.620
We want to make sure
that all parts of our app

00:14:56.620 --> 00:15:00.465
work well and are testable.

00:15:00.465 --> 00:15:03.460
So how can we do this?

00:15:03.460 --> 00:15:08.690
Last-- this Monday, we released
Fragment 1.1, the first alpha.

00:15:08.690 --> 00:15:10.970
And with this came
a new artifact

00:15:10.970 --> 00:15:12.830
called fragment-testing,
which is

00:15:12.830 --> 00:15:16.310
about like six years overdue.

00:15:16.310 --> 00:15:21.200
And it's really around being
able to test your AndroidX

00:15:21.200 --> 00:15:25.640
fragments in isolation,
separate from an activity,

00:15:25.640 --> 00:15:27.100
separate from everything else.

00:15:27.100 --> 00:15:29.990
But being able to test and
verify that that fragment

00:15:29.990 --> 00:15:31.730
is doing the right thing.

00:15:31.730 --> 00:15:34.850
So super useful for things like
Espresso tests, where you do

00:15:34.850 --> 00:15:36.200
want to test that logic.

00:15:36.200 --> 00:15:41.170
Your business logic, separate
object, but your UI logic,

00:15:41.170 --> 00:15:43.180
what happens when you
click that button,

00:15:43.180 --> 00:15:46.872
is still something that we
want to verify is correct.

00:15:46.872 --> 00:15:49.600
Now, the nice part about this--
it's called FragmentScenario--

00:15:49.600 --> 00:15:52.360
it's actually built
on a different class

00:15:52.360 --> 00:15:56.781
called ActivityScenario, which
is part of the AndroidX testing

00:15:56.781 --> 00:15:57.280
team.

00:15:57.280 --> 00:15:58.930
And actually, the
testing team was

00:15:58.930 --> 00:16:02.160
instrumental in getting
FragmentScenario out there.

00:16:02.160 --> 00:16:04.870
But the best part about
this whole scenario

00:16:04.870 --> 00:16:08.020
is that it works both on
instrumentation tests, tests

00:16:08.020 --> 00:16:11.750
on your actual device,
and on Robolectric.

00:16:11.750 --> 00:16:15.130
So you've got one test framework
that works on both of these.

00:16:15.130 --> 00:16:17.320
So a really exciting
opportunity,

00:16:17.320 --> 00:16:19.930
and something that now you
can test with fragments.

00:16:19.930 --> 00:16:22.430
So what does this look like?

00:16:22.430 --> 00:16:26.080
So let's say we want to
test our profile fragment.

00:16:26.080 --> 00:16:28.050
We did our directions thing.

00:16:28.050 --> 00:16:30.730
We're passing in a
fake user ID here.

00:16:30.730 --> 00:16:36.260
And we call
launchFragmentInContainer.

00:16:36.260 --> 00:16:37.100
That's it.

00:16:37.100 --> 00:16:42.020
This one line has both created
an empty hosting activity,

00:16:42.020 --> 00:16:46.740
added the fragment to it, and
waited for it to be resumed.

00:16:46.740 --> 00:16:48.150
And now it's ready.

00:16:48.150 --> 00:16:49.950
You can now use this fragment.

00:16:49.950 --> 00:16:52.500
So if you want to
call onFragment,

00:16:52.500 --> 00:16:55.710
and run some code on your
fragment, and say, well,

00:16:55.710 --> 00:16:57.660
is the fragment in
the right state?

00:16:57.660 --> 00:16:58.200
Great.

00:16:58.200 --> 00:16:59.080
You can do that.

00:16:59.080 --> 00:17:01.740
Here, we're just going to
check to see if our args are

00:17:01.740 --> 00:17:03.090
what we think they are.

00:17:03.090 --> 00:17:04.950
We've passed in a user ID.

00:17:04.950 --> 00:17:09.089
We can use the other half of
safe args using the args class,

00:17:09.089 --> 00:17:11.490
another generated class,
and just say like,

00:17:11.490 --> 00:17:13.980
well, is the args
user ID actually

00:17:13.980 --> 00:17:16.089
equal to the user
ID we passed in?

00:17:16.089 --> 00:17:18.819
Did we not mess up on all
of that sort of stuff?

00:17:18.819 --> 00:17:21.150
But you can see you
can run any logic,

00:17:21.150 --> 00:17:24.625
any method on your
fragment right from here.

00:17:24.625 --> 00:17:26.720
Or we just run an Espresso test.

00:17:26.720 --> 00:17:29.040
You say, is the user
name actually equal

00:17:29.040 --> 00:17:30.960
to the user ID we passed in?

00:17:30.960 --> 00:17:32.670
When we click the
Subscribe button,

00:17:32.670 --> 00:17:35.700
does it actually change
the text to subscribed?

00:17:35.700 --> 00:17:38.310
Does it do its thing?

00:17:38.310 --> 00:17:40.290
We can do this with
just that one line

00:17:40.290 --> 00:17:42.870
of launchFragmentInContainer.

00:17:42.870 --> 00:17:46.800
For Java users, it'll be
FragmentScenario [? launch ?]

00:17:46.800 --> 00:17:48.550
in container.

00:17:48.550 --> 00:17:52.566
We obviously make that a
little bit nicer for you guys.

00:17:52.566 --> 00:17:56.980
But you don't test a
fragment in isolation,

00:17:56.980 --> 00:18:00.310
because fragments do
talk to other fragments.

00:18:00.310 --> 00:18:02.490
And like, I work on navigation.

00:18:02.490 --> 00:18:04.410
So there's that other
bit of testing of,

00:18:04.410 --> 00:18:09.690
how can we test the links
between different destinations,

00:18:09.690 --> 00:18:11.530
between different fragments?

00:18:11.530 --> 00:18:14.790
And really, the nice
part here that we have,

00:18:14.790 --> 00:18:18.240
because we're using these
higher level components and not

00:18:18.240 --> 00:18:24.600
something like activity, is
that we have a mockable layer.

00:18:24.600 --> 00:18:28.140
One of the things that we found
when building navigation is

00:18:28.140 --> 00:18:31.800
that most companies, once
they got to a certain point,

00:18:31.800 --> 00:18:33.900
and they're like, wow, we
should add some testing.

00:18:33.900 --> 00:18:36.510
And they're like, wow, we can't
really test start activities.

00:18:36.510 --> 00:18:38.070
So they built their
own navigator,

00:18:38.070 --> 00:18:42.080
which just provides a layer
to mock out the start activity

00:18:42.080 --> 00:18:42.580
calls.

00:18:42.580 --> 00:18:45.880
Well, that layer
is handled for you.

00:18:45.880 --> 00:18:47.130
It's called NavController.

00:18:47.130 --> 00:18:48.760
We test NavController.

00:18:48.760 --> 00:18:51.570
So now what we can
do in our activities

00:18:51.570 --> 00:18:54.540
is just mock out
that NavController

00:18:54.540 --> 00:18:57.480
and confirm that,
yes, you're calling

00:18:57.480 --> 00:18:59.560
the right navigate calls.

00:18:59.560 --> 00:19:01.920
So here we have our
profile fragment again.

00:19:01.920 --> 00:19:03.990
And now it's
getting our user ID.

00:19:03.990 --> 00:19:05.970
And really, what
we want to test is

00:19:05.970 --> 00:19:08.710
this on viewSubscribers button.

00:19:08.710 --> 00:19:11.250
So you can tell, we click this.

00:19:11.250 --> 00:19:15.000
And like, oh, my god, it's like
doing something complicated

00:19:15.000 --> 00:19:16.050
in the fragment.

00:19:16.050 --> 00:19:17.540
How are we going to test this?

00:19:17.540 --> 00:19:19.830
Here, it's calling Navigate.

00:19:19.830 --> 00:19:21.750
How can we make sure
that this is actually

00:19:21.750 --> 00:19:24.134
doing what we want it to do?

00:19:24.134 --> 00:19:25.900
Well, it's pretty easy.

00:19:25.900 --> 00:19:29.320
We can do our scenario thing
just the same, launch fragment.

00:19:29.320 --> 00:19:32.970
And now we can just mark
out our NavController.

00:19:32.970 --> 00:19:35.820
And now you call onFragment.

00:19:35.820 --> 00:19:39.150
And what we're doing here
is actually just creating

00:19:39.150 --> 00:19:41.650
our own NavController.

00:19:41.650 --> 00:19:44.360
There's no nav host here.

00:19:44.360 --> 00:19:47.130
But we can just inject one.

00:19:47.130 --> 00:19:49.410
This is actually
what NavHostFragment

00:19:49.410 --> 00:19:51.360
is doing under the covers.

00:19:51.360 --> 00:19:54.960
It's calling setNavController
on a view, and saying,

00:19:54.960 --> 00:19:56.400
here's my NavController.

00:19:56.400 --> 00:20:00.570
But now what we've done is from
this fragment's point of view,

00:20:00.570 --> 00:20:02.340
it has a navigation controller.

00:20:02.340 --> 00:20:06.570
All those findNavController
calls that normally you'd

00:20:06.570 --> 00:20:10.140
have to inject something in
to get your NavController,

00:20:10.140 --> 00:20:12.160
now it just works.

00:20:12.160 --> 00:20:13.860
They're in there.

00:20:13.860 --> 00:20:16.710
And now we can just
run Espresso tests,

00:20:16.710 --> 00:20:19.580
and say, click on the
viewSubscribers button.

00:20:19.580 --> 00:20:21.690
And the nice part is
that because we're

00:20:21.690 --> 00:20:25.920
using these directions class, we
can use them also in our tests.

00:20:25.920 --> 00:20:28.530
And because they
implement equals,

00:20:28.530 --> 00:20:31.470
we can just do a simple
verify, and say, verify,

00:20:31.470 --> 00:20:33.270
did you actually
navigate to where

00:20:33.270 --> 00:20:35.280
we think you're navigating?

00:20:35.280 --> 00:20:38.010
And even if there's a lot
of parameters in there,

00:20:38.010 --> 00:20:40.920
if there's extras and
other options in there,

00:20:40.920 --> 00:20:43.020
we can now just verify.

00:20:43.020 --> 00:20:46.980
And this makes it so much easier
to test those interconnections

00:20:46.980 --> 00:20:48.750
between each destination.

00:20:51.970 --> 00:20:54.710
So nav control is kind
of a special case,

00:20:54.710 --> 00:20:57.260
because we find a NavController.

00:20:57.260 --> 00:21:02.140
So many other things aren't
a service locator kind

00:21:02.140 --> 00:21:02.640
of pattern.

00:21:02.640 --> 00:21:06.170
It's we need to inject
in those dependencies.

00:21:06.170 --> 00:21:09.680
And this is another one of those
like "six years too late" kind

00:21:09.680 --> 00:21:13.630
of a thing, but we're
finally working on it.

00:21:13.630 --> 00:21:18.830
So there's a class in Android
P called AppComponentFactory,

00:21:18.830 --> 00:21:21.920
which allows you to construct
activities, services,

00:21:21.920 --> 00:21:24.050
broadcast receivers,
and services,

00:21:24.050 --> 00:21:27.350
all via dependency injection.

00:21:27.350 --> 00:21:30.730
You get a chance of
calling the constructor,

00:21:30.730 --> 00:21:32.990
instead of the system
calling your constructor.

00:21:32.990 --> 00:21:35.210
The same thing here
with fragments,

00:21:35.210 --> 00:21:39.230
where now you can actually
do constructor injection

00:21:39.230 --> 00:21:41.090
into fragments.

00:21:41.090 --> 00:21:44.840
You no longer need to only
have a no-args constructor

00:21:44.840 --> 00:21:46.100
to use fragments.

00:21:46.100 --> 00:21:49.730
You can use a FragmentFactory
to instantiate your fragments

00:21:49.730 --> 00:21:51.630
for you.

00:21:51.630 --> 00:21:54.080
So this is really
useful also for cases

00:21:54.080 --> 00:21:56.540
where your fragment
was like passing

00:21:56.540 --> 00:21:58.590
your activity to something.

00:21:58.590 --> 00:22:02.690
I know we probably still have
a template that does this.

00:22:02.690 --> 00:22:04.640
We'll fix that.

00:22:04.640 --> 00:22:06.710
And there's lot of
ways where really we

00:22:06.710 --> 00:22:09.570
want to inject in all of
those external dependencies

00:22:09.570 --> 00:22:12.480
so we can test
again in isolation.

00:22:12.480 --> 00:22:17.990
And FragmentFactory works great
with our FragmentScenario.

00:22:17.990 --> 00:22:19.730
So what does this look like?

00:22:19.730 --> 00:22:22.400
We know how to
test a view model.

00:22:22.400 --> 00:22:23.570
It's just an object.

00:22:23.570 --> 00:22:24.620
You instantiate it.

00:22:24.620 --> 00:22:25.600
You do the thing.

00:22:25.600 --> 00:22:28.710
And it has a real
method called Subscribe.

00:22:28.710 --> 00:22:31.940
But really, we want
to test our fragment.

00:22:31.940 --> 00:22:34.220
And our fragment has
an onSubscribe method

00:22:34.220 --> 00:22:38.150
that calls viewModel.Subscribe
And it does its thing.

00:22:38.150 --> 00:22:39.680
How do we get this viewModel?

00:22:39.680 --> 00:22:43.520
Well, we can inject
the factory itself,

00:22:43.520 --> 00:22:46.810
inject the viewModelFactory.

00:22:46.810 --> 00:22:50.360
And here we're using some of the
other new stuff in Fragment 1.1

00:22:50.360 --> 00:22:55.070
that's by viewModels, another
Kotlin property delegate that

00:22:55.070 --> 00:22:57.777
does all that viewModel
providers of kind

00:22:57.777 --> 00:22:59.790
of stuff for you.

00:22:59.790 --> 00:23:03.510
But we now have a fragment that,
well, we've injected something,

00:23:03.510 --> 00:23:06.200
but then we still need
to test like, OK, well,

00:23:06.200 --> 00:23:07.705
did it actually call subscribe?

00:23:07.705 --> 00:23:11.990
We're back to the same situation
of building testable code.

00:23:14.570 --> 00:23:16.890
We can build a
navigation activity.

00:23:16.890 --> 00:23:19.770
This is what it's going
to look like in real life.

00:23:19.770 --> 00:23:22.520
We're going to inject
our viewModelFactory.

00:23:22.520 --> 00:23:27.300
And then because code is hard
and I wanted to write things

00:23:27.300 --> 00:23:30.470
on slides, I built a
helper class called

00:23:30.470 --> 00:23:32.310
Initializer FragmentFactory.

00:23:32.310 --> 00:23:35.880
That basically just calls add
Initializer for each fragment.

00:23:35.880 --> 00:23:39.300
And we call that method
to construct your fragment

00:23:39.300 --> 00:23:42.930
rather than use the
default no-arg constructor.

00:23:42.930 --> 00:23:44.700
So a little bit of magic.

00:23:44.700 --> 00:23:46.980
There is a link here if
you want to check it out.

00:23:46.980 --> 00:23:49.590
We're looking at trying to
integrate this more deeply

00:23:49.590 --> 00:23:51.930
into the actual library itself.

00:23:51.930 --> 00:23:54.570
But once you've called
this FragmentFactory, now

00:23:54.570 --> 00:23:59.130
whenever your activity creates
a profile fragment, instead

00:23:59.130 --> 00:24:01.020
of using that
no-arg constructor,

00:24:01.020 --> 00:24:02.760
it's going to use
this constructor.

00:24:02.760 --> 00:24:06.390
It's going to pass in
our viewModelFactory.

00:24:06.390 --> 00:24:09.810
So our activity looks fine.

00:24:09.810 --> 00:24:12.780
But our test, how
does that look?

00:24:12.780 --> 00:24:17.480
Well, we create a mock
of our profile viewModel.

00:24:17.480 --> 00:24:20.100
And then we can set
up a factory for it.

00:24:20.100 --> 00:24:24.150
And then, again, kind of
use a FragmentFactory here

00:24:24.150 --> 00:24:26.070
that, again, does the
same type of thing

00:24:26.070 --> 00:24:30.350
where we're passing in
our mock viewModelFactory.

00:24:30.350 --> 00:24:33.270
And then our scenario
looks almost the same.

00:24:33.270 --> 00:24:37.110
We just add it in and add
instead of just the arguments,

00:24:37.110 --> 00:24:38.720
also the FragmentFactory.

00:24:38.720 --> 00:24:40.130
Great.

00:24:40.130 --> 00:24:43.510
Now we can do our
same thing on view.

00:24:43.510 --> 00:24:44.770
Perform the click.

00:24:44.770 --> 00:24:48.620
And then verify that, yes,
our mocked out viewModel

00:24:48.620 --> 00:24:49.830
did the subscribe call.

00:24:49.830 --> 00:24:53.380
So now we have a testable
fragment, a testable viewModel.

00:24:53.380 --> 00:24:57.610
And we've injected all of the
dependencies into our fragment.

00:24:57.610 --> 00:24:59.940
We actually have
a testable thing.

00:24:59.940 --> 00:25:03.040
Now, we are looking at some
improvements to this API,

00:25:03.040 --> 00:25:06.770
because we want to
make this even easier.

00:25:06.770 --> 00:25:10.870
So in this case, because we know
you're constructing a profile

00:25:10.870 --> 00:25:13.390
fragment, what we want
to change this into

00:25:13.390 --> 00:25:16.850
is actually something
that looks like this,

00:25:16.850 --> 00:25:20.740
where you can say launch, and
then give it a method saying,

00:25:20.740 --> 00:25:25.690
oh, launch this fragment,
and specifically give it

00:25:25.690 --> 00:25:29.250
the constructed out
instance of your fragment.

00:25:29.250 --> 00:25:30.730
So you don't have
to actually know

00:25:30.730 --> 00:25:33.400
that, oh, it's using a
FragmentFactory under the hood.

00:25:33.400 --> 00:25:37.750
You can test just one
fragment just fine.

00:25:37.750 --> 00:25:43.580
Now there are a few cases where
you might think, oh, man, maybe

00:25:43.580 --> 00:25:47.090
I do need multiple activities.

00:25:47.090 --> 00:25:50.690
And there's got to be reasons
to use multiple activities

00:25:50.690 --> 00:25:53.270
besides just momentum.

00:25:53.270 --> 00:25:55.880
I understand a
lot of apps if you

00:25:55.880 --> 00:25:58.100
have multiple
activities right now,

00:25:58.100 --> 00:26:01.110
this isn't actually
an easy sell.

00:26:01.110 --> 00:26:04.820
So there are a few cases where
even today we do recommend

00:26:04.820 --> 00:26:07.600
using multiple activities.

00:26:07.600 --> 00:26:09.080
Not a lot, though.

00:26:09.080 --> 00:26:13.860
So what I'd like to say
is you don't actually

00:26:13.860 --> 00:26:15.870
need multiple activities.

00:26:15.870 --> 00:26:20.358
What you need are
multiple tasks.

00:26:20.358 --> 00:26:23.154
So what are tasks?

00:26:23.154 --> 00:26:26.060
Tasks are actually the thing
that users are actually

00:26:26.060 --> 00:26:27.620
interacting with.

00:26:27.620 --> 00:26:30.960
So a task is a
stack of activities.

00:26:30.960 --> 00:26:33.470
And each task has a back stack.

00:26:33.470 --> 00:26:37.850
So in your Overview menu here,
each one of these entries

00:26:37.850 --> 00:26:40.640
isn't just an activity.

00:26:40.640 --> 00:26:43.550
It's actually a
whole task stack.

00:26:43.550 --> 00:26:48.560
So you're only just seeing the
topmost activity of that stack.

00:26:48.560 --> 00:26:53.120
So each element here is a stack.

00:26:53.120 --> 00:26:55.490
When you're doing split
screen multi window,

00:26:55.490 --> 00:27:00.120
that's two tasks side by side.

00:27:00.120 --> 00:27:02.300
On Chrome OS
devices, things that

00:27:02.300 --> 00:27:07.340
support floating multi window,
each one of these tasks

00:27:07.340 --> 00:27:08.770
is a window.

00:27:08.770 --> 00:27:13.070
So a one to one between
windows and tasks--

00:27:13.070 --> 00:27:18.710
not activities and
windows, tasks and windows.

00:27:18.710 --> 00:27:24.500
So launching a new task on
one of these Chrome OS devices

00:27:24.500 --> 00:27:27.890
gives you a new window.

00:27:27.890 --> 00:27:32.900
So your app, maybe it doesn't
need multiple activities,

00:27:32.900 --> 00:27:37.490
but maybe it wants
multiple windows.

00:27:37.490 --> 00:27:40.340
So this is a case
where, yes, you

00:27:40.340 --> 00:27:43.280
need to use activities
under the hood.

00:27:43.280 --> 00:27:47.332
Each one of these tasks is
going to be a separate activity.

00:27:47.332 --> 00:27:53.430
But you may not use some of the
other things, such as a stack

00:27:53.430 --> 00:27:56.050
of activities, in one task.

00:27:56.050 --> 00:27:58.941
So what does this
actually look like?

00:27:58.941 --> 00:28:00.840
Well, a lot of
this is that there

00:28:00.840 --> 00:28:04.080
are a lot of different
ways of saying new task.

00:28:04.080 --> 00:28:07.110
Has anyone looked at all
those wonderful launch mode

00:28:07.110 --> 00:28:09.330
flags and all that fun?

00:28:09.330 --> 00:28:10.740
Yeah.

00:28:10.740 --> 00:28:13.710
How many people that have
used it are still sane?

00:28:13.710 --> 00:28:14.910
OK.

00:28:14.910 --> 00:28:19.230
Well, I'll say that there
were a lot of good flags

00:28:19.230 --> 00:28:23.040
out there in Android 1.

00:28:23.040 --> 00:28:27.840
They were great
back in Android 1.

00:28:27.840 --> 00:28:31.940
Today, in 2018, they're maybe
not the best thing to use.

00:28:31.940 --> 00:28:35.490
What you actually want to
use is documentLaunchMode.

00:28:35.490 --> 00:28:39.540
documentLaunchMode was
added actually an API 21.

00:28:39.540 --> 00:28:43.920
So please if you're thinking
about pre-API 21, first,

00:28:43.920 --> 00:28:45.370
what are you doing?

00:28:45.370 --> 00:28:48.900
And second, probably
try and steer away

00:28:48.900 --> 00:28:50.790
from hacky solutions.

00:28:50.790 --> 00:28:54.690
Maybe it's just not
worth it for those users.

00:28:54.690 --> 00:28:58.410
But try and avoid things like
launch mode flags and task

00:28:58.410 --> 00:29:00.210
affinity and those
type of things,

00:29:00.210 --> 00:29:04.290
because while the
framework does honor those,

00:29:04.290 --> 00:29:06.390
it maybe doesn't honor
them in the way you

00:29:06.390 --> 00:29:09.249
want them to honor it.

00:29:09.249 --> 00:29:11.290
They're certainly a very
different kind of thing.

00:29:11.290 --> 00:29:14.880
So what can you actually
do with documentLaunchMode?

00:29:14.880 --> 00:29:18.360
Well, the biggest
thing is multitasking.

00:29:18.360 --> 00:29:22.440
If you can have
multiple tasks, then you

00:29:22.440 --> 00:29:24.210
can have multiple windows.

00:29:24.210 --> 00:29:27.770
You can have multiple entries
in your Overview screen.

00:29:27.770 --> 00:29:32.330
So the first way of really doing
multitasking is intoExisting.

00:29:32.330 --> 00:29:35.100
Now, intoExisting
basically means

00:29:35.100 --> 00:29:42.180
whenever I launch this activity,
that activity has its own task.

00:29:42.180 --> 00:29:45.160
Every time you launch this
activity, it has its own task.

00:29:45.160 --> 00:29:48.970
But if we already have
launched that task,

00:29:48.970 --> 00:29:51.510
don't create a second
and a third copy.

00:29:51.510 --> 00:29:54.300
So this is really useful
for things like documents,

00:29:54.300 --> 00:29:56.610
conversations,
things where someone

00:29:56.610 --> 00:29:59.010
might want to
side-by-side compare

00:29:59.010 --> 00:30:00.300
two different documents.

00:30:00.300 --> 00:30:03.210
If they're copy-pasting from
one document to the other,

00:30:03.210 --> 00:30:05.610
they're not going to
exit out of one doc,

00:30:05.610 --> 00:30:08.520
open one, copy it, and
then open the other one,

00:30:08.520 --> 00:30:10.440
and then copy it into there.

00:30:10.440 --> 00:30:13.530
This is kind of taking that
multitasking model that

00:30:13.530 --> 00:30:16.650
is Android, that is
that recent screen,

00:30:16.650 --> 00:30:20.220
and making it so that your
app actually gets to use this.

00:30:20.220 --> 00:30:22.980
Now, of course, the
intoExisting assumes

00:30:22.980 --> 00:30:25.830
you have some notion
of uniqueness.

00:30:25.830 --> 00:30:29.010
So it does assume that
from an intent filter

00:30:29.010 --> 00:30:32.670
equals kind of point of view,
like if you're using the data

00:30:32.670 --> 00:30:37.970
URI on your activity, that
there is some sort of unique ID,

00:30:37.970 --> 00:30:40.890
a conversation
ID, a document ID,

00:30:40.890 --> 00:30:45.400
something to uniquely define
that task in and of itself.

00:30:45.400 --> 00:30:47.880
Now one great example of
this that you can try out

00:30:47.880 --> 00:30:50.410
on your phones is Google Docs.

00:30:50.410 --> 00:30:52.860
So Google Docs,
when you open a doc,

00:30:52.860 --> 00:30:56.330
it actually launches
it in a another task.

00:30:56.330 --> 00:30:58.240
And if you have
multiple docs, you

00:30:58.240 --> 00:31:01.390
can actually load
them up side by side

00:31:01.390 --> 00:31:05.380
on a phone, two different
windows on a Chrome OS device.

00:31:05.380 --> 00:31:06.700
And it just works.

00:31:06.700 --> 00:31:10.900
Even though it's one app,
it can have multiple windows

00:31:10.900 --> 00:31:14.200
and really allow a different
level of multitasking

00:31:14.200 --> 00:31:17.050
between different things.

00:31:17.050 --> 00:31:20.640
So another big one is
creating new content.

00:31:20.640 --> 00:31:22.260
So new content is
a little different,

00:31:22.260 --> 00:31:25.400
because there's not
really any unique ID.

00:31:25.400 --> 00:31:28.800
But you still want that kind
of multitasking behavior

00:31:28.800 --> 00:31:32.670
where you can reference
existing material while you're

00:31:32.670 --> 00:31:35.100
creating something new.

00:31:35.100 --> 00:31:38.550
So the Always flag is very
similar to into existing,

00:31:38.550 --> 00:31:41.590
but it just always
create something new.

00:31:41.590 --> 00:31:43.620
Wow, it's like
self-descriptive names.

00:31:43.620 --> 00:31:46.250
We can do this, guys.

00:31:46.250 --> 00:31:49.870
And it allows you to do
multiple things at once.

00:31:49.870 --> 00:31:51.280
That's great.

00:31:51.280 --> 00:31:53.220
So one example of this is Gmail.

00:31:53.220 --> 00:31:56.320
So Gmail actually
uses this kind of mode

00:31:56.320 --> 00:31:58.250
when you create a new email.

00:31:58.250 --> 00:32:01.180
So this allows you
to create a new email

00:32:01.180 --> 00:32:05.290
and reference your existing
email at the same time.

00:32:05.290 --> 00:32:06.880
Magic, right?

00:32:06.880 --> 00:32:11.290
This is the equivalent on mobile
of when you do it on the web

00:32:11.290 --> 00:32:12.820
and it pops up a
little mole that's

00:32:12.820 --> 00:32:14.020
separate from the other one.

00:32:14.020 --> 00:32:17.410
You still need that other
material as reference even when

00:32:17.410 --> 00:32:19.110
you're creating something new.

00:32:19.110 --> 00:32:21.100
Of course, on a
phone or on a tablet,

00:32:21.100 --> 00:32:23.920
it looks slightly different.

00:32:23.920 --> 00:32:26.600
The other case is
picture-in-picture.

00:32:26.600 --> 00:32:31.040
Now, picture-in-picture actually
has two entirely separate modes

00:32:31.040 --> 00:32:34.230
for how you want to
approach picture-in-picture.

00:32:34.230 --> 00:32:36.800
One is using a separate task.

00:32:36.800 --> 00:32:39.170
So this would be a
separate activity

00:32:39.170 --> 00:32:41.030
just for your playback.

00:32:41.030 --> 00:32:44.090
So this is really common
on Android TV devices.

00:32:44.090 --> 00:32:46.460
For example, Google
Play Movies and TV

00:32:46.460 --> 00:32:49.310
uses this approach so
that you can actually

00:32:49.310 --> 00:32:51.710
put things into
picture-in-picture mode,

00:32:51.710 --> 00:32:55.740
and then browse
through other movies.

00:32:55.740 --> 00:32:58.520
So in this mode, it's
very much that you

00:32:58.520 --> 00:33:01.370
have a specific
Picture-In-Picture Mode

00:33:01.370 --> 00:33:04.170
button in your UI.

00:33:04.170 --> 00:33:08.300
The other mode is using just
a single task, one activity.

00:33:08.300 --> 00:33:10.530
You actually don't need
anything at all here.

00:33:10.530 --> 00:33:13.820
And this is the approach the
things like Duo and Google Maps

00:33:13.820 --> 00:33:17.540
use, where your whole
task is becoming

00:33:17.540 --> 00:33:20.870
the picture-in-picture activity.

00:33:20.870 --> 00:33:24.720
So when would you want to
choose one or the other?

00:33:24.720 --> 00:33:26.820
And it's really this
case where once I'm

00:33:26.820 --> 00:33:30.650
in picture-in-picture mode, if
they were to click my Launcher

00:33:30.650 --> 00:33:32.140
icon, what would happen?

00:33:32.140 --> 00:33:35.420
Because the Launcher icon
always launches the default

00:33:35.420 --> 00:33:38.150
task of your app.

00:33:38.150 --> 00:33:41.240
So in Duo's case,
where they only

00:33:41.240 --> 00:33:46.280
have one task, when you launch
that Duo from your Launcher

00:33:46.280 --> 00:33:50.210
icon, it's just going to pop
open the picture-in-picture.

00:33:50.210 --> 00:33:52.550
You go from a little
tiny picture-in-picture

00:33:52.550 --> 00:33:55.340
to full screen, because
it doesn't make sense

00:33:55.340 --> 00:33:58.940
to have multiple conversations
going at the same time.

00:33:58.940 --> 00:34:01.202
You're never going to
replace one with the other.

00:34:01.202 --> 00:34:03.410
You're never going to continue
to reference something

00:34:03.410 --> 00:34:06.290
even though something
is already going.

00:34:06.290 --> 00:34:08.480
So that's kind of the
differentiator here,

00:34:08.480 --> 00:34:11.690
where do you want to be able to
browse and picture-in-picture

00:34:11.690 --> 00:34:13.409
at the same time?

00:34:13.409 --> 00:34:16.570
If you do want to
browse, then yes, you

00:34:16.570 --> 00:34:19.070
are using the Android
framework, and therefore they

00:34:19.070 --> 00:34:20.960
need to position
those separately,

00:34:20.960 --> 00:34:23.485
separate tasks,
separate activities.

00:34:26.395 --> 00:34:29.280
But that's kind of it.

00:34:29.280 --> 00:34:33.258
The one thing I didn't mention
are things like Instant Apps.

00:34:33.258 --> 00:34:37.260
Now, Instant Apps kind of
works at the activity level.

00:34:37.260 --> 00:34:38.489
You call startActivity.

00:34:38.489 --> 00:34:41.080
It downloads your
Instant App module.

00:34:41.080 --> 00:34:43.281
But there's actually some
really exciting things

00:34:43.281 --> 00:34:45.030
that are being worked
on by the Play team.

00:34:45.030 --> 00:34:47.850
I think there was a talk
here at Android Dev Summit.

00:34:47.850 --> 00:34:52.020
But a lot of it is around the
instant experience for your app

00:34:52.020 --> 00:34:55.949
bundle, making your whole
app instant, and also

00:34:55.949 --> 00:34:58.560
dynamic feature modules.

00:34:58.560 --> 00:35:01.530
These are really
interesting ways

00:35:01.530 --> 00:35:04.230
of adding things
onto the thing that

00:35:04.230 --> 00:35:08.940
don't require a specific app
architecture to implement.

00:35:08.940 --> 00:35:11.100
We can actually do
more things with this.

00:35:11.100 --> 00:35:13.950
So for the instant
experience, it's

00:35:13.950 --> 00:35:18.086
adding this distribution
instant equals true.

00:35:18.086 --> 00:35:20.730
Now, this means
that someone can try

00:35:20.730 --> 00:35:24.670
your entire app, your
entire base module,

00:35:24.670 --> 00:35:26.940
all at once, totally instant.

00:35:26.940 --> 00:35:31.560
And this works really well
with things like app links.

00:35:31.560 --> 00:35:35.790
So those deep links that I said
you can add to any destination,

00:35:35.790 --> 00:35:38.490
you can also make them
into app links by adding

00:35:38.490 --> 00:35:40.320
the autoVerify="true".

00:35:40.320 --> 00:35:43.080
And that means you skip
the disambiguation.

00:35:43.080 --> 00:35:46.560
And when someone launches
your deep link on the web,

00:35:46.560 --> 00:35:50.340
they're going to open up
your instant app experience.

00:35:50.340 --> 00:35:53.010
They're going to download that
whole base module for you,

00:35:53.010 --> 00:35:57.470
and your whole navigation graph
is already there, ready to go.

00:35:57.470 --> 00:36:01.590
But this doesn't work if
your app is too large.

00:36:01.590 --> 00:36:04.500
So you want to
dynamically deliver

00:36:04.500 --> 00:36:09.000
things that are not used very
often or rather big things.

00:36:09.000 --> 00:36:11.460
That's what dynamic
feature modules

00:36:11.460 --> 00:36:16.800
are all about, about being able
to download them on demand.

00:36:16.800 --> 00:36:20.340
Now, the really interesting part
about dynamic feature modules

00:36:20.340 --> 00:36:23.480
is that you're adding classes.

00:36:23.480 --> 00:36:25.590
You don't need to
add activities.

00:36:25.590 --> 00:36:29.880
You can add just destinations,
just a number of fragments.

00:36:29.880 --> 00:36:34.530
So in this case, you can add
new destinations on demand.

00:36:34.530 --> 00:36:37.080
Just because you've
built out an XML

00:36:37.080 --> 00:36:41.160
file for your navigation
graph statically,

00:36:41.160 --> 00:36:42.960
each one of these
dynamic feature modules

00:36:42.960 --> 00:36:47.040
can also add their
own navigation graph.

00:36:47.040 --> 00:36:51.750
So this means that we're not
tied to separate activities.

00:36:51.750 --> 00:36:54.860
We can now actually
still use one activity.

00:36:54.860 --> 00:36:58.020
Now, there's still
more to be done here,

00:36:58.020 --> 00:37:02.580
both on the Play side and
on the Navigation side,

00:37:02.580 --> 00:37:06.810
but we want to make this really
easy for developers to use.

00:37:06.810 --> 00:37:10.290
So what we want to get to is
where you can add something

00:37:10.290 --> 00:37:12.990
to your navigation graph
with just a feature tag,

00:37:12.990 --> 00:37:16.260
just like you'd add a fragment
tag or something like that.

00:37:16.260 --> 00:37:19.710
And when you navigate
to this destination,

00:37:19.710 --> 00:37:23.580
that's actually going to
do all of the downloading

00:37:23.580 --> 00:37:26.730
and making your feature
module available from whatever

00:37:26.730 --> 00:37:28.170
your split name is.

00:37:28.170 --> 00:37:30.180
So that's the world
we want to get into,

00:37:30.180 --> 00:37:34.590
where you can use a single
activity, where you can use

00:37:34.590 --> 00:37:38.610
a lot of the useful things, like
deep linking and navigation,

00:37:38.610 --> 00:37:42.870
without necessarily contorting
your app architecture

00:37:42.870 --> 00:37:45.372
around everything else.

00:37:45.372 --> 00:37:49.010
So I'd really like to
end this with one note.

00:37:49.010 --> 00:37:51.500
A lot of you have
existing apps that

00:37:51.500 --> 00:37:54.710
have very different
kind of experiences.

00:37:54.710 --> 00:38:00.020
And I'd like to say, do
what's right for your app.

00:38:00.020 --> 00:38:02.180
I think single
activity is great.

00:38:02.180 --> 00:38:04.130
If I was writing a new
activity, it would also

00:38:04.130 --> 00:38:05.900
be a single activity.

00:38:05.900 --> 00:38:10.070
But I realize that
going to your PM

00:38:10.070 --> 00:38:14.510
and being like, hey let's
rip the whole app apart,

00:38:14.510 --> 00:38:18.470
is sometimes a hard sell.

00:38:18.470 --> 00:38:20.390
Some of them don't
like your current app.

00:38:20.390 --> 00:38:24.392
So maybe you'll actually get
some, yeah, OK, go for it.

00:38:24.392 --> 00:38:26.540
It really depends on
your own experience.

00:38:26.540 --> 00:38:30.910
If you find yourself
contorting your own experience

00:38:30.910 --> 00:38:35.300
and it's not making sense
to you, don't do it.

00:38:35.300 --> 00:38:38.120
If something is
working, that's good.

00:38:38.120 --> 00:38:39.780
Keep it working.

00:38:39.780 --> 00:38:42.380
But if you're finding
you're running into issues,

00:38:42.380 --> 00:38:45.000
you're having
inconsistent behavior,

00:38:45.000 --> 00:38:48.710
or you want to do things
like share viewModels, maybe

00:38:48.710 --> 00:38:51.020
that's the time to
think about moving

00:38:51.020 --> 00:38:53.620
towards a single
activity structure.

00:38:53.620 --> 00:38:55.400
So thank you.

00:38:55.400 --> 00:38:57.125
Q&amp;A will be outside.

00:38:57.125 --> 00:38:58.790
I really appreciate
you all coming.

00:38:58.790 --> 00:39:02.440
[MUSIC PLAYING]

