WEBVTT
Kind: captions
Language: en

00:00:02.150 --> 00:00:04.170
MALE SPEAKER: Hello, everybody.

00:00:04.170 --> 00:00:08.020
Welcome to this Tech Talk
on "The Stellar Consensus

00:00:08.020 --> 00:00:09.160
Protocol."

00:00:09.160 --> 00:00:10.140
My name is [INAUDIBLE].

00:00:10.140 --> 00:00:13.090
And I'm a director of
engineering here at Google.

00:00:13.090 --> 00:00:19.330
I want you to welcome our
speaker today, David Mazieres.

00:00:19.330 --> 00:00:23.150
David is a professor of computer
science at Stanford University

00:00:23.150 --> 00:00:28.250
and the chief scientist
at The Stellar Foundation.

00:00:28.250 --> 00:00:30.930
David also wears a
lot of cool T-shirts.

00:00:30.930 --> 00:00:33.220
And so give a warm
welcome to David.

00:00:33.220 --> 00:00:33.855
Thank you.

00:00:33.855 --> 00:00:35.202
[APPLAUSE]

00:00:36.757 --> 00:00:37.840
DAVID MAZIERES: Thank you.

00:00:37.840 --> 00:00:39.720
So before we get
started, Stanford

00:00:39.720 --> 00:00:42.710
requires me to tell you that
this work is paid consulting.

00:00:42.710 --> 00:00:46.260
It wasn't part of my regular
Stanford University duties

00:00:46.260 --> 00:00:48.460
and responsibilities.

00:00:48.460 --> 00:00:52.370
So if you think about banking,
the core job of a bank

00:00:52.370 --> 00:00:55.290
is really keeping track
of customer assets

00:00:55.290 --> 00:00:56.380
and liabilities.

00:00:56.380 --> 00:00:59.090
If you walk into a Wells Fargo
branch here in California

00:00:59.090 --> 00:01:00.626
and you deposit
a bunch of money,

00:01:00.626 --> 00:01:03.250
they're going to put your bills
in the same drawer as everybody

00:01:03.250 --> 00:01:04.319
else's bills.

00:01:04.319 --> 00:01:06.300
And so they have to
keep track of the fact

00:01:06.300 --> 00:01:09.490
that they owe you so much money
and you owe them so much money

00:01:09.490 --> 00:01:10.820
and so on.

00:01:10.820 --> 00:01:13.250
And typically the way
they would do this

00:01:13.250 --> 00:01:16.340
is by replicating a ledger.

00:01:16.340 --> 00:01:18.950
So the ledger is the most
important thing the bank has.

00:01:18.950 --> 00:01:21.096
So they might keep
at least three copies

00:01:21.096 --> 00:01:21.970
of this thing around.

00:01:21.970 --> 00:01:23.720
So even if there's
a data center that

00:01:23.720 --> 00:01:25.610
experiences some big
disaster, they'll

00:01:25.610 --> 00:01:29.200
still know how much
money is in your account.

00:01:29.200 --> 00:01:33.920
But this begs the question,
what about interbank transfers?

00:01:33.920 --> 00:01:36.930
So suppose now that
somebody over here in China

00:01:36.930 --> 00:01:40.940
wants to send me
$150 in California.

00:01:40.940 --> 00:01:43.440
Well, now the bills aren't
sitting in the same drawer.

00:01:43.440 --> 00:01:45.860
In fact, they're not
even the same currency.

00:01:45.860 --> 00:01:48.840
And so what happens
is this Chinese bank

00:01:48.840 --> 00:01:52.080
and the bank in California
need to find some third bank,

00:01:52.080 --> 00:01:55.720
a corespondent bank that maybe
the Chinese bank has an account

00:01:55.720 --> 00:01:58.740
with so that they can adjust
the ledger at that bank.

00:01:58.740 --> 00:02:00.230
And then that bank
can do whatever

00:02:00.230 --> 00:02:02.460
it needs to do to send
the money to Wells Fargo.

00:02:02.460 --> 00:02:04.120
This is all very complicated.

00:02:04.120 --> 00:02:07.540
And the net result is that
it adds a lot of delay.

00:02:07.540 --> 00:02:09.100
And it adds a lot of cost.

00:02:09.100 --> 00:02:11.780
And so you end up seeing
headlines like this where

00:02:11.780 --> 00:02:15.040
people end up paying sometimes
huge commissions-- up to, like,

00:02:15.040 --> 00:02:19.640
22%-- just to send money
around between countries.

00:02:19.640 --> 00:02:22.790
And a lot of the fees that
are paid to send money around

00:02:22.790 --> 00:02:26.420
are actually shouldered
by the poorest people.

00:02:26.420 --> 00:02:30.160
So it kind of brings this
kind of ironic comment

00:02:30.160 --> 00:02:32.560
that it turns out it's
expensive to be poor

00:02:32.560 --> 00:02:35.580
because these poor people are
paying more in banking fees.

00:02:35.580 --> 00:02:37.740
It's not all bad
news, of course.

00:02:37.740 --> 00:02:39.880
If you're Western
Union, you managed

00:02:39.880 --> 00:02:43.700
to make $5.6 billion dollars
moving just $85 billion dollars

00:02:43.700 --> 00:02:46.470
around in 2014.

00:02:46.470 --> 00:02:48.350
But, of course, those
fees are coming out

00:02:48.350 --> 00:02:51.810
of the pockets of people
who can least afford it.

00:02:51.810 --> 00:02:54.180
Now there's actually
something worse

00:02:54.180 --> 00:02:58.550
than having to pay excessive
fees to Western Union.

00:02:58.550 --> 00:03:01.370
And that is you might not
be able to send money around

00:03:01.370 --> 00:03:02.880
at all.

00:03:02.880 --> 00:03:05.012
So imagine that you
want to send money

00:03:05.012 --> 00:03:07.220
home to your family in
Somalia, and it just turns out

00:03:07.220 --> 00:03:08.950
there's no way to do that.

00:03:08.950 --> 00:03:11.210
And in fact, that happened.

00:03:11.210 --> 00:03:14.820
So you see headlines like this
where people are literally

00:03:14.820 --> 00:03:21.040
unable to send money back to
family members who need it.

00:03:21.040 --> 00:03:22.340
So what's going on here?

00:03:22.340 --> 00:03:24.730
Well, if you think about
today's financial networks,

00:03:24.730 --> 00:03:29.340
they actually look a lot like
email did before the internet.

00:03:29.340 --> 00:03:31.710
So before we had
internet mail, we

00:03:31.710 --> 00:03:33.250
had things like UUCP and BITNET.

00:03:35.746 --> 00:03:37.370
Email addresses used
to look like this.

00:03:37.370 --> 00:03:39.078
There were these things
called bang paths

00:03:39.078 --> 00:03:43.160
where you had host1, bang,
host2, bang, host3, bang user.

00:03:43.160 --> 00:03:46.549
And these addresses, they're
not globally meaningful.

00:03:46.549 --> 00:03:48.590
And they add a lot of
delay because the email had

00:03:48.590 --> 00:03:51.510
to go through a bunch of
hops with store and forward

00:03:51.510 --> 00:03:52.780
and nowadays it's pretty easy.

00:03:52.780 --> 00:03:54.863
It doesn't matter where
you have an email account,

00:03:54.863 --> 00:03:58.140
if it's your Gmail or Yahoo
mail or wherever, you can just

00:03:58.140 --> 00:04:00.170
send email to anybody else.

00:04:00.170 --> 00:04:02.900
So wouldn't it be nice
if we could send money

00:04:02.900 --> 00:04:05.020
around the internet
in the same way?

00:04:05.020 --> 00:04:08.310
And that's really
been the core focus

00:04:08.310 --> 00:04:10.980
of what we've been working
on at the Stellar Development

00:04:10.980 --> 00:04:12.440
Foundation.

00:04:12.440 --> 00:04:14.830
And the first observation
here is that it actually

00:04:14.830 --> 00:04:18.290
would be possible to move
money around like this

00:04:18.290 --> 00:04:20.370
if we had some kind of
global ledger keeping

00:04:20.370 --> 00:04:23.340
track of who had what money.

00:04:23.340 --> 00:04:26.880
Because now, instead of having
to find some correspondent

00:04:26.880 --> 00:04:31.000
bank in order to send the
money from China to California,

00:04:31.000 --> 00:04:32.870
the two banks could
just make the adjustment

00:04:32.870 --> 00:04:36.470
in the global ledger
that $150 had moved here.

00:04:36.470 --> 00:04:38.930
And then the money could just
pop out in my account here.

00:04:38.930 --> 00:04:40.340
It would be much easier.

00:04:40.340 --> 00:04:42.260
The problem, of
course, is if you're

00:04:42.260 --> 00:04:44.020
going to have this
kind of global ledger,

00:04:44.020 --> 00:04:45.960
there's no single
party that would

00:04:45.960 --> 00:04:48.510
be trusted enough to manage
this ledger that keeps track

00:04:48.510 --> 00:04:50.690
of how much money
all of the banks

00:04:50.690 --> 00:04:53.740
have in this international
financial network.

00:04:53.740 --> 00:04:57.680
And even kind of trying
to split the trust

00:04:57.680 --> 00:04:59.070
across some kind
of consortium is

00:04:59.070 --> 00:05:01.910
problematic because
who gets more seats?

00:05:01.910 --> 00:05:02.430
The US?

00:05:02.430 --> 00:05:04.490
Or China because China
has a bigger population?

00:05:04.490 --> 00:05:06.200
Then if Cuba has a
seat at the table,

00:05:06.200 --> 00:05:07.390
can US banks participate?

00:05:07.390 --> 00:05:11.830
You can imagine all these thorny
questions that would come up.

00:05:11.830 --> 00:05:14.820
So this is problematic.

00:05:14.820 --> 00:05:17.380
On the other hand, we do
have this existence proof

00:05:17.380 --> 00:05:19.770
of a global
decentralized system that

00:05:19.770 --> 00:05:23.310
works really well without any
kind of centralized control.

00:05:23.310 --> 00:05:25.570
And that is inter-domain
routing on the internet.

00:05:25.570 --> 00:05:27.395
The internet is this
giant global network.

00:05:27.395 --> 00:05:28.270
It works pretty well.

00:05:28.270 --> 00:05:30.640
But it's built out of these
pairwise peering and transit

00:05:30.640 --> 00:05:34.070
relationships between
pairs of ISPs.

00:05:34.070 --> 00:05:35.720
So what I'm going
to talk about today

00:05:35.720 --> 00:05:38.520
is how we can use the same
kind of pairwise trust

00:05:38.520 --> 00:05:42.150
to achieve this secure
global consensus.

00:05:42.150 --> 00:05:45.240
And once we have this kind
of internet-level consensus,

00:05:45.240 --> 00:05:48.450
we'll use that to realize
the global ledger.

00:05:48.450 --> 00:05:49.640
Now why consensus?

00:05:49.640 --> 00:05:52.490
Well, turns out consensus
is the key to replication.

00:05:52.490 --> 00:05:54.654
The most common way to
build a replicated system

00:05:54.654 --> 00:05:56.820
is to use what's called the
replicated state machine

00:05:56.820 --> 00:05:59.620
approach where
every replica starts

00:05:59.620 --> 00:06:00.910
in the same initial state.

00:06:00.910 --> 00:06:04.420
And then you agree on the
exact sequence of operations

00:06:04.420 --> 00:06:05.790
that you're going to apply.

00:06:05.790 --> 00:06:10.310
And therefore all the replicas
maintain the same state.

00:06:10.310 --> 00:06:13.850
And the second one, making sure
that all the replicas agree

00:06:13.850 --> 00:06:15.440
on the exact sequence
of operations,

00:06:15.440 --> 00:06:17.670
turns out to be
the hard problem.

00:06:17.670 --> 00:06:21.950
So in this case, maybe we want
to agree that operation 7 here

00:06:21.950 --> 00:06:25.020
is this transfer of $150 into
my account in California.

00:06:25.020 --> 00:06:26.560
And so essentially,
the whole talk

00:06:26.560 --> 00:06:28.760
is going to be concentrated
on this question of,

00:06:28.760 --> 00:06:30.760
how does the whole
world agree that,

00:06:30.760 --> 00:06:34.480
yes, this $150 transfer
actually happened

00:06:34.480 --> 00:06:37.496
and was part of operation 7?

00:06:37.496 --> 00:06:39.120
So here's an outline
of what I'll talk.

00:06:39.120 --> 00:06:41.130
First, I'm going to
give some background

00:06:41.130 --> 00:06:43.390
and cover Byzantine Agreement.

00:06:43.390 --> 00:06:45.990
But I'm going to kind of present
it-- there's a novel twist.

00:06:45.990 --> 00:06:48.156
I'm going to present it
through this new lens, which

00:06:48.156 --> 00:06:49.890
is viewing everything
in terms of voting

00:06:49.890 --> 00:06:53.180
on what I'll call irrefutable
and neutralizable statements.

00:06:53.180 --> 00:06:55.384
And we'll see what that means.

00:06:55.384 --> 00:06:57.550
And then I'll discuss
Federated Byzantine Agreement,

00:06:57.550 --> 00:07:00.410
which is a generalization
of Byzantine Agreement,

00:07:00.410 --> 00:07:02.160
to a model that could
actually accommodate

00:07:02.160 --> 00:07:04.506
this kind of
internet-level consensus.

00:07:04.506 --> 00:07:06.130
Then I'll talk about
failure resistance

00:07:06.130 --> 00:07:08.997
and how well we can do in
terms of tolerating failures.

00:07:08.997 --> 00:07:10.580
And then I'll present
my construction,

00:07:10.580 --> 00:07:12.440
which is the Stellar
Consensus Protocol.

00:07:15.040 --> 00:07:16.820
So let's get into the
consensus problem.

00:07:16.820 --> 00:07:18.195
The goal of the
consensus problem

00:07:18.195 --> 00:07:23.040
is for multiple replicas to
agree on an output value.

00:07:23.040 --> 00:07:25.750
And so you have a bunch of
agents in the system, each

00:07:25.750 --> 00:07:27.240
of which is storing a replica.

00:07:27.240 --> 00:07:29.422
Each agent starts
with an input value.

00:07:29.422 --> 00:07:30.880
And the input value
would typically

00:07:30.880 --> 00:07:33.570
be the candidate for
the nth operation

00:07:33.570 --> 00:07:35.890
in some replicated
state machine log.

00:07:35.890 --> 00:07:39.210
And then the agents are going
to exchange a bunch of messages

00:07:39.210 --> 00:07:42.259
and use those messages to
agree on one of their inputs.

00:07:42.259 --> 00:07:44.050
And then they're going
to output the value.

00:07:44.050 --> 00:07:46.110
In this case, v2's input was 9.

00:07:46.110 --> 00:07:47.860
Maybe the three agents pick 9.

00:07:47.860 --> 00:07:49.570
And so then they output 9.

00:07:49.570 --> 00:07:53.696
And the important point here is
that the output is right once.

00:07:53.696 --> 00:07:55.500
Once you output the
value 9, it could

00:07:55.500 --> 00:07:58.760
cause ATM machines to spit
out $20 bills or something.

00:07:58.760 --> 00:08:00.264
Irreversible actions may happen.

00:08:00.264 --> 00:08:01.680
So you can never
change your mind.

00:08:01.680 --> 00:08:03.880
You better be sure everybody
agrees on the value

00:08:03.880 --> 00:08:06.710
before you output it.

00:08:06.710 --> 00:08:09.720
So there's some properties you
might want of your consensus

00:08:09.720 --> 00:08:10.590
protocol.

00:08:10.590 --> 00:08:13.650
So one is that you'd like
all the outputs produced

00:08:13.650 --> 00:08:15.200
to have the same value.

00:08:15.200 --> 00:08:17.270
Otherwise, it's not much
of a consensus protocol.

00:08:17.270 --> 00:08:19.150
So that's called agreement.

00:08:19.150 --> 00:08:21.740
You'd also like the alpha
value to actually equal one

00:08:21.740 --> 00:08:23.367
of the agent's input values.

00:08:23.367 --> 00:08:24.950
Otherwise, there's
a trivial solution.

00:08:24.950 --> 00:08:27.160
Everybody just outputs
0, and it's not

00:08:27.160 --> 00:08:28.520
a very interesting protocol.

00:08:28.520 --> 00:08:31.672
So together, this
agreement and validity,

00:08:31.672 --> 00:08:33.630
which is what you call
when the output actually

00:08:33.630 --> 00:08:37.140
equals one of the inputs,
I'll call this safety.

00:08:37.140 --> 00:08:39.159
Those two properties
constitute safety.

00:08:39.159 --> 00:08:42.450
You might also
want your protocol

00:08:42.450 --> 00:08:45.790
to guarantee that eventually
all the non-faulty nodes will

00:08:45.790 --> 00:08:46.940
actually output a value.

00:08:46.940 --> 00:08:49.010
So that's called liveness.

00:08:49.010 --> 00:08:51.900
And finally, you might want
your consensus protocol

00:08:51.900 --> 00:08:53.800
to provide fault
tolerance, meaning

00:08:53.800 --> 00:08:56.000
that you can recover from
the failure of an agent

00:08:56.000 --> 00:08:58.289
at any point in the
execution of a protocol.

00:08:58.289 --> 00:08:59.830
And when it comes
to fault tolerance,

00:08:59.830 --> 00:09:01.850
we actually care about
two different kinds

00:09:01.850 --> 00:09:03.300
of fault tolerance.

00:09:03.300 --> 00:09:06.700
In a fail-stop model, you assume
that agents fail by crashing,

00:09:06.700 --> 00:09:09.130
and then they just never
send any more messages.

00:09:09.130 --> 00:09:11.810
And in the Byzantine-fault
tolerant model,

00:09:11.810 --> 00:09:17.530
you assume that agents can
fail by behaving arbitrarily.

00:09:17.530 --> 00:09:19.850
So you can imagine an
attacker takes over an agent

00:09:19.850 --> 00:09:22.870
and sends the worst possible
messages with the goal

00:09:22.870 --> 00:09:26.240
of trying to mess everybody up.

00:09:26.240 --> 00:09:29.490
Now there's this seminal
result in distributed system

00:09:29.490 --> 00:09:31.160
due to Fischer,
Lynch, and Paterson

00:09:31.160 --> 00:09:33.730
called the FLP
impossibility result, which

00:09:33.730 --> 00:09:36.360
states that no deterministic
consensus protocol can

00:09:36.360 --> 00:09:39.720
guarantee all three of safety,
liveness, and fault tolerance

00:09:39.720 --> 00:09:41.440
in an asynchronous system.

00:09:41.440 --> 00:09:45.780
So that's a bummer since
that's what we limited.

00:09:45.780 --> 00:09:49.585
But let's try to build up an
intuition for why this is.

00:09:49.585 --> 00:09:51.210
So if you remember
a couple slides ago,

00:09:51.210 --> 00:09:52.980
we had these three agents.

00:09:52.980 --> 00:09:56.340
And they chose v2's
input, which was 9.

00:09:56.340 --> 00:09:58.550
And they output the value 9.

00:09:58.550 --> 00:10:00.620
Now suppose we turn
back the clock,

00:10:00.620 --> 00:10:01.830
and we restart this protocol.

00:10:01.830 --> 00:10:04.270
But right as the agents
start to execute,

00:10:04.270 --> 00:10:06.510
there's some kind of
transient network outage.

00:10:06.510 --> 00:10:09.100
And v2 is cut off from
the rest of the network.

00:10:09.100 --> 00:10:12.057
So if v1 and v3 can
talk, but not v2.

00:10:12.057 --> 00:10:13.890
So at this point, in
an asynchronous system,

00:10:13.890 --> 00:10:16.240
v1 and v3 may start
to think, oh, it

00:10:16.240 --> 00:10:18.482
looks like v2 may have failed.

00:10:18.482 --> 00:10:20.440
And so if the protocol
was fault tolerant, then

00:10:20.440 --> 00:10:23.120
v1 and v3 need to be able
to complete the protocol

00:10:23.120 --> 00:10:27.200
and terminate without
talking to v2.

00:10:27.200 --> 00:10:29.120
And since they don't
know what v2's input is,

00:10:29.120 --> 00:10:31.680
they're going to pick another
input, so either 3 or 7.

00:10:31.680 --> 00:10:33.640
Let's say that in this
case, they pick 7.

00:10:33.640 --> 00:10:35.450
And then they output 7.

00:10:35.450 --> 00:10:37.960
And at some point, of course,
the network may come back up.

00:10:37.960 --> 00:10:40.410
And then v2 can talk
to the other nodes.

00:10:40.410 --> 00:10:42.560
And if the protocol is safe
and provides agreement,

00:10:42.560 --> 00:10:45.300
then v2 also better output
7 so that it can match

00:10:45.300 --> 00:10:48.000
with the other nodes' output.

00:10:48.000 --> 00:10:52.240
So what you can see here
is that the output value

00:10:52.240 --> 00:10:53.840
chosen by the nodes
actually depended

00:10:53.840 --> 00:10:54.840
on the network behavior.

00:10:54.840 --> 00:10:57.400
Depending on whose messages
got delivered first,

00:10:57.400 --> 00:11:00.590
they could pick the value 9 or
they could pick the value 7.

00:11:00.590 --> 00:11:03.370
So when a consensus protocol
is in this kind of state

00:11:03.370 --> 00:11:06.050
where the network can affect
which of several values

00:11:06.050 --> 00:11:08.710
can be output, we'll
say that the protocol

00:11:08.710 --> 00:11:10.560
is in a bivalent state.

00:11:10.560 --> 00:11:12.310
Or you would maybe
think multivalent,

00:11:12.310 --> 00:11:15.240
but I'm using bivalent to be
consistent with the literature

00:11:15.240 --> 00:11:17.350
here.

00:11:17.350 --> 00:11:19.610
So conversely, you
could reach a point

00:11:19.610 --> 00:11:22.880
where there's only one
output value possible.

00:11:22.880 --> 00:11:24.450
The fate of the
system's been sealed.

00:11:24.450 --> 00:11:26.920
7 is the only
possible output value.

00:11:26.920 --> 00:11:29.150
And in that case, we'll say
the system is univalent.

00:11:29.150 --> 00:11:30.910
Or if the only
output value is 7,

00:11:30.910 --> 00:11:34.880
we'll say the system
is 7-valent, say.

00:11:34.880 --> 00:11:37.200
In addition, you hope
this won't happen,

00:11:37.200 --> 00:11:39.870
but if you don't have a very
good consensus protocol,

00:11:39.870 --> 00:11:42.537
you could also end up in a
situation where you get stuck.

00:11:42.537 --> 00:11:44.120
And there are one
or more faulty nodes

00:11:44.120 --> 00:11:46.080
that can never output
a value, no matter what

00:11:46.080 --> 00:11:49.680
the-- even if the network
decides to start cooperating.

00:11:49.680 --> 00:11:52.702
So in that case, we'll say
that the protocol is stuck.

00:11:52.702 --> 00:11:54.410
So if you remember
from a few slides ago,

00:11:54.410 --> 00:11:55.850
we said the output
is right once.

00:11:55.850 --> 00:11:57.810
You can never change your mind.

00:11:57.810 --> 00:12:01.760
And, of course, all the
output values need to agree.

00:12:01.760 --> 00:12:05.400
And so what that means
is that it's never

00:12:05.400 --> 00:12:07.050
possible to output
a value if you're

00:12:07.050 --> 00:12:09.610
in a bivalent state because
once a particular value has

00:12:09.610 --> 00:12:11.112
been output, well,
then that should

00:12:11.112 --> 00:12:12.320
seal the state of the system.

00:12:12.320 --> 00:12:16.745
Any other output values
should be the same.

00:12:16.745 --> 00:12:18.870
So that means that if you
have one of these systems

00:12:18.870 --> 00:12:20.411
and you have an
execution that starts

00:12:20.411 --> 00:12:23.160
in a bivalent state and then
it eventually terminates, then

00:12:23.160 --> 00:12:26.360
it must at some point have
reached a univalent state.

00:12:29.300 --> 00:12:32.620
So now here's an intuition
behind this FLP impossibility

00:12:32.620 --> 00:12:36.460
result. Let's imagine that you
have a terminating execution

00:12:36.460 --> 00:12:37.580
of a bivalent system.

00:12:37.580 --> 00:12:38.430
You start bivalent.

00:12:38.430 --> 00:12:40.920
Then eventually everybody
outputs some value.

00:12:40.920 --> 00:12:44.530
And let's let m be
the last message that

00:12:44.530 --> 00:12:47.450
was received by any node
in a bivalent state.

00:12:47.450 --> 00:12:51.090
So receiving m is what flipped
the system from a bivalent

00:12:51.090 --> 00:12:52.930
to a univalent state.

00:12:52.930 --> 00:12:57.420
So in that case, we'll
call m the deciding message

00:12:57.420 --> 00:12:59.180
because somehow
delivering m is what

00:12:59.180 --> 00:13:01.810
decided the fate of the system.

00:13:01.810 --> 00:13:03.530
Now let's turn back
the clock and say

00:13:03.530 --> 00:13:06.100
that instead of delivering
m, the network had delayed m,

00:13:06.100 --> 00:13:08.880
and a bunch of other messages
had gotten delivered first.

00:13:08.880 --> 00:13:11.200
And those messages, of
course, might have altered

00:13:11.200 --> 00:13:12.200
the state of the system.

00:13:12.200 --> 00:13:13.256
And they might have
altered the state

00:13:13.256 --> 00:13:15.870
of the system in such a way
that when m is eventually

00:13:15.870 --> 00:13:17.940
delivered-- much later
than it was originally--

00:13:17.940 --> 00:13:20.050
it's no longer a
deciding message.

00:13:20.050 --> 00:13:22.880
And just delivering m is
not enough to flip over

00:13:22.880 --> 00:13:24.629
to a univalent state.

00:13:24.629 --> 00:13:26.420
So in that case, we'll
say that the message

00:13:26.420 --> 00:13:27.780
m has been neutralized.

00:13:27.780 --> 00:13:29.985
Neutralizing a
message means taking

00:13:29.985 --> 00:13:31.610
what would have been
a deciding message

00:13:31.610 --> 00:13:35.080
and now making it no
longer interesting

00:13:35.080 --> 00:13:37.780
or no longer able to decide
the fate of the system.

00:13:37.780 --> 00:13:41.166
So here's the overview
of the FLP proof.

00:13:41.166 --> 00:13:43.040
You can show that there
are bivalent starting

00:13:43.040 --> 00:13:44.650
configurations.

00:13:44.650 --> 00:13:47.460
And then if your system
is fault tolerance,

00:13:47.460 --> 00:13:50.600
it turns out that the
network can neutralize

00:13:50.600 --> 00:13:51.830
any deciding message.

00:13:51.830 --> 00:13:54.050
And the reason is
that whatever nodes

00:13:54.050 --> 00:13:56.380
sent that deciding
message might have failed.

00:13:56.380 --> 00:13:58.562
So you can't always
count on being

00:13:58.562 --> 00:13:59.770
able to receive that message.

00:13:59.770 --> 00:14:01.353
So there has to be
some way to recover

00:14:01.353 --> 00:14:04.050
and say, OK, let's stop
waiting for that message

00:14:04.050 --> 00:14:06.480
and do something else so that
we can make some progress

00:14:06.480 --> 00:14:08.100
and pick a value.

00:14:08.100 --> 00:14:10.270
And so taken together,
what these two things mean

00:14:10.270 --> 00:14:14.220
is that the system can
essentially remain bivalent

00:14:14.220 --> 00:14:15.700
in perpetuity if
every time there's

00:14:15.700 --> 00:14:18.711
about to be a deciding message
the network pathologically

00:14:18.711 --> 00:14:21.085
delays just that one message
until it's been neutralized.

00:14:21.085 --> 00:14:23.770
And so you'll never
end up transitioning

00:14:23.770 --> 00:14:26.700
to a univalent state.

00:14:26.700 --> 00:14:30.354
So how do we cope given that
we want to achieve consensus

00:14:30.354 --> 00:14:31.770
and a lot of systems
depend on it?

00:14:31.770 --> 00:14:33.920
Well, what you want to
do is design protocols

00:14:33.920 --> 00:14:36.540
that terminate in practice
even if they're not

00:14:36.540 --> 00:14:38.110
guaranteed to terminate.

00:14:38.110 --> 00:14:40.880
And the most important property
they need to achieve for this

00:14:40.880 --> 00:14:42.610
is that you have to
avoid stuck states.

00:14:42.610 --> 00:14:44.920
You want to make sure that
whatever weird stuff is

00:14:44.920 --> 00:14:46.711
happening on the network,
if eventually you

00:14:46.711 --> 00:14:48.960
fix the network and
things start behaving

00:14:48.960 --> 00:14:51.270
in a more friendly way,
that you can recover

00:14:51.270 --> 00:14:53.980
and everybody can agree on a
value and output that value.

00:14:57.280 --> 00:14:57.780
Good.

00:14:57.780 --> 00:15:03.940
So now let's look at a straw man
attempt to implement consensus.

00:15:03.940 --> 00:15:06.422
So let's say that you have
a system with N nodes.

00:15:06.422 --> 00:15:07.880
And for now, to
keep things simple,

00:15:07.880 --> 00:15:09.213
we'll assume fail-stop behavior.

00:15:09.213 --> 00:15:12.130
So they might crash, but
they won't act arbitrarily.

00:15:12.130 --> 00:15:15.110
And now we're going to pick
some quorum sized T where

00:15:15.110 --> 00:15:16.910
T is greater than N over 2.

00:15:16.910 --> 00:15:20.710
So T includes a
majority of nodes.

00:15:20.710 --> 00:15:23.990
And we say that if
T nodes-- namely,

00:15:23.990 --> 00:15:27.690
in other words, a quorum-- ever
all vote for the same value,

00:15:27.690 --> 00:15:29.570
then it becomes safe
to output that value.

00:15:29.570 --> 00:15:33.350
In this example up here, you
can notice that quorum A here

00:15:33.350 --> 00:15:35.200
has all voted for the value 9.

00:15:35.200 --> 00:15:38.580
So at that point it becomes
safe to output the value 9.

00:15:38.580 --> 00:15:42.500
And this guarantees agreement
because the quorum size

00:15:42.500 --> 00:15:43.830
includes a majority of nodes.

00:15:43.830 --> 00:15:46.220
So any two quorums will
intersect in at least one node.

00:15:46.220 --> 00:15:48.180
And nodes aren't allowed
to change their votes.

00:15:48.180 --> 00:15:52.300
So there can be at most a one
value that will be output.

00:15:52.300 --> 00:15:53.790
Now what's the problem?

00:15:53.790 --> 00:15:56.530
Well, the reason this isn't a
very good consensus protocol

00:15:56.530 --> 00:15:59.600
is because you can
have stuck states.

00:15:59.600 --> 00:16:02.390
So, in particular, imagine
that one of these nodes that

00:16:02.390 --> 00:16:04.010
was voting 9 actually failed.

00:16:04.010 --> 00:16:08.420
Now you no longer have T
nodes voting for the value 9.

00:16:08.420 --> 00:16:10.210
Some people might have
heard all T votes.

00:16:10.210 --> 00:16:11.740
But some people
might not have heard

00:16:11.740 --> 00:16:14.440
the vote of this node that
failed because it won't be

00:16:14.440 --> 00:16:16.410
around to retransmit its vote.

00:16:16.410 --> 00:16:21.300
And so there will be nodes that
cannot actually output a value.

00:16:21.300 --> 00:16:24.870
Another problem you could have
is you could have a split vote.

00:16:24.870 --> 00:16:27.479
So everybody votes
for a different value.

00:16:27.479 --> 00:16:28.770
And you can't change your vote.

00:16:28.770 --> 00:16:31.750
Then you'll never be
able to output any value

00:16:31.750 --> 00:16:35.800
because no value
will ever actually

00:16:35.800 --> 00:16:37.230
have a quorum voting for it.

00:16:37.230 --> 00:16:38.180
Make sense?

00:16:43.890 --> 00:16:49.161
So this is what voting
actually gives us.

00:16:49.161 --> 00:16:51.160
If we try to use voting
as a consensus protocol,

00:16:51.160 --> 00:16:53.640
we'll find that we start
in some bivalent state.

00:16:53.640 --> 00:16:56.470
And then if we get
enough votes, we

00:16:56.470 --> 00:16:59.410
might end up in an a
valent state for some value

00:16:59.410 --> 00:17:04.367
a that we're voting Or we could
end up in some a bar valent

00:17:04.367 --> 00:17:06.950
state-- where a bar, we'll let
that stand for any value that's

00:17:06.950 --> 00:17:09.960
not equal to a
and contradicts a.

00:17:09.960 --> 00:17:13.109
But if enough people vote,
then maybe the whole system

00:17:13.109 --> 00:17:15.349
would end up agreeing on a.

00:17:15.349 --> 00:17:17.480
Otherwise, you can end
up in this stuck state

00:17:17.480 --> 00:17:19.890
over on the right.

00:17:19.890 --> 00:17:21.920
So voting might give
us what we wanted,

00:17:21.920 --> 00:17:23.900
but it might put us
in the stuck state

00:17:23.900 --> 00:17:25.890
that we can never recover from.

00:17:25.890 --> 00:17:27.790
So what this means is
you can never directly

00:17:27.790 --> 00:17:30.410
vote on the actual consensus
question you care about,

00:17:30.410 --> 00:17:33.750
never take an up or down
vote on is operation 7

00:17:33.750 --> 00:17:37.850
a credit of $150 to this bank
in California to my account.

00:17:37.850 --> 00:17:40.060
You can't vote on that
because if that gets stuck,

00:17:40.060 --> 00:17:42.380
you'll never be able to
figure out how much money is

00:17:42.380 --> 00:17:43.200
in my account.

00:17:43.200 --> 00:17:46.310
There'll be no more
well-defined notion of that.

00:17:46.310 --> 00:17:49.390
So what kind of statements
is it safe to vote on?

00:17:49.390 --> 00:17:52.550
Well, first of all, it would
be OK to vote on a statement

00:17:52.550 --> 00:17:54.490
if that statement
never gets stuck

00:17:54.490 --> 00:17:57.199
because that means you could
eventually reach agreement.

00:17:57.199 --> 00:17:59.240
And second of all, it's
OK to vote on a statement

00:17:59.240 --> 00:18:02.370
if you can somehow break the
hold that that statement has

00:18:02.370 --> 00:18:05.180
on the actual consensus
question that we care about.

00:18:05.180 --> 00:18:06.831
So if a statement
gets stuck, but that

00:18:06.831 --> 00:18:08.330
doesn't prevent me
from figuring out

00:18:08.330 --> 00:18:12.170
how much money is in my
account, well, then that's OK.

00:18:12.170 --> 00:18:15.640
So let's look at this
in a bit more detail.

00:18:15.640 --> 00:18:19.200
So first observation is that
the reason that you end up

00:18:19.200 --> 00:18:20.950
in these stuck states
is that nodes aren't

00:18:20.950 --> 00:18:22.210
allowed to change their vote.

00:18:22.210 --> 00:18:23.810
If everybody votes
for a different value,

00:18:23.810 --> 00:18:24.840
and they can't
change their vote,

00:18:24.840 --> 00:18:27.570
then they can't turn around and
all vote for the same value,

00:18:27.570 --> 00:18:30.170
or at least have a quorum
vote for the same value.

00:18:30.170 --> 00:18:33.450
But suppose you have a statement
where, for some reason,

00:18:33.450 --> 00:18:36.390
you can reason about the fact
that no correct node would ever

00:18:36.390 --> 00:18:38.360
vote against it or
vote for anything that

00:18:38.360 --> 00:18:40.120
contradicts that statement.

00:18:40.120 --> 00:18:42.792
Well, then you won't get stuck.

00:18:42.792 --> 00:18:44.750
And so I'm going to call
that kind of statement

00:18:44.750 --> 00:18:46.625
an irrefutable statement.

00:18:46.625 --> 00:18:48.500
So irrefutable statements
are fine to vote on

00:18:48.500 --> 00:18:52.970
because nobody is prevented
from voting on it by past votes,

00:18:52.970 --> 00:18:55.190
so eventually, as long
as there's a quorum,

00:18:55.190 --> 00:18:59.390
that quorum can vote for
the irrefutable statement.

00:18:59.390 --> 00:19:00.970
The second kind
of statements are

00:19:00.970 --> 00:19:03.360
statements whose hold on
the consensus question

00:19:03.360 --> 00:19:04.850
can actually be broken.

00:19:04.850 --> 00:19:08.654
And if you recall from when
we were talking about the FLP

00:19:08.654 --> 00:19:10.820
proof that we said that for
a fault-tolerant system,

00:19:10.820 --> 00:19:12.194
you need to be
able to neutralize

00:19:12.194 --> 00:19:13.810
any deciding message.

00:19:13.810 --> 00:19:16.980
And so, we'll say that a
statement is neutralizable

00:19:16.980 --> 00:19:20.010
if you can transition
the system to a state

00:19:20.010 --> 00:19:23.720
where you no longer care about
the value of that statement.

00:19:23.720 --> 00:19:27.100
As it turns out, most of
the trickiness involved

00:19:27.100 --> 00:19:28.860
in designing a
consensus protocol

00:19:28.860 --> 00:19:31.770
is in the question of how do
you formulate statements that

00:19:31.770 --> 00:19:33.800
are useful towards
consensus, but can also

00:19:33.800 --> 00:19:37.970
be neutralized if you need to.

00:19:37.970 --> 00:19:40.369
So there are two popular
ways of designing

00:19:40.369 --> 00:19:41.660
these neutralizable statements.

00:19:41.660 --> 00:19:43.800
One is the
ballot-based approach.

00:19:43.800 --> 00:19:46.680
And the other is what I call
the view-based approach.

00:19:46.680 --> 00:19:49.040
The view-based approach
may actually be simpler,

00:19:49.040 --> 00:19:52.300
and you should probably use it
if you can get away with it.

00:19:52.300 --> 00:19:54.084
But in this
particular context, I

00:19:54.084 --> 00:19:55.750
couldn't figure out
how to make it work.

00:19:55.750 --> 00:19:58.060
So we'll talk about
ballot-based neutralization.

00:19:58.060 --> 00:19:59.730
So ballot-based
neutralization is

00:19:59.730 --> 00:20:02.960
something that was introduced
by Leslie Lamport for Paxos.

00:20:02.960 --> 00:20:06.877
And the idea is that you vote to
commit or abort ballots, where

00:20:06.877 --> 00:20:07.960
the two are contradictory.

00:20:07.960 --> 00:20:09.720
You can only vote one way.

00:20:09.720 --> 00:20:13.090
And each ballot
is a pair-- n, x--

00:20:13.090 --> 00:20:15.140
where n is just a
counter that can

00:20:15.140 --> 00:20:18.180
keep incrementing so you have
an unlimited supply of ballots.

00:20:18.180 --> 00:20:21.900
And x is a candidate
output value

00:20:21.900 --> 00:20:23.210
for the consensus protocol.

00:20:26.440 --> 00:20:29.140
And if you actually
have a quorum that votes

00:20:29.140 --> 00:20:32.050
to commit n, x, then we'll
say that it's safe to output

00:20:32.050 --> 00:20:33.840
the value x.

00:20:33.840 --> 00:20:37.890
Now in order to make
this work, we're

00:20:37.890 --> 00:20:40.280
going to have to
preserve an invariant.

00:20:40.280 --> 00:20:42.940
And the invariant is that
all committed and all stuck

00:20:42.940 --> 00:20:46.310
ballots are going to have
to have the same value x.

00:20:46.310 --> 00:20:48.345
So how are we going to
preserve this invariant?

00:20:48.345 --> 00:20:50.720
Well, the way we preserve this
invariant, this thing, you

00:20:50.720 --> 00:20:53.960
can't just vote to commit
a ballot arbitrarily.

00:20:53.960 --> 00:20:55.670
Before you vote to
commit a ballot,

00:20:55.670 --> 00:20:57.247
you have to prepare that ballot.

00:20:57.247 --> 00:20:59.080
And what does it mean
to prepare the ballot?

00:20:59.080 --> 00:21:04.570
Well, you prepare a ballot
n, x by aborting every ballot

00:21:04.570 --> 00:21:07.850
with a lesser or equal
counter and prime

00:21:07.850 --> 00:21:11.390
that has a different
value not equal to x.

00:21:11.390 --> 00:21:15.140
And because of the way
it's been designed,

00:21:15.140 --> 00:21:17.980
even if some ballot
n, x gets stuck,

00:21:17.980 --> 00:21:21.570
there's nothing that prevents
you from preparing n plus 1, x.

00:21:21.570 --> 00:21:23.570
So that means you can
neutralize a stuck ballot

00:21:23.570 --> 00:21:25.450
and move on to the next ballot.

00:21:25.450 --> 00:21:28.770
So let's maybe illustrate
this with an example.

00:21:28.770 --> 00:21:32.370
So here, let's say we have eight
candidate values, a through h.

00:21:32.370 --> 00:21:37.070
And initially, all the ballots
in the system are bivalent.

00:21:37.070 --> 00:21:40.610
And then let's say the system
agrees that they've prepared

00:21:40.610 --> 00:21:41.380
1, g.

00:21:41.380 --> 00:21:43.890
In other words, they've
aborted all the other ballots.

00:21:43.890 --> 00:21:46.260
At that point, you might
vote to commit 1, g.

00:21:46.260 --> 00:21:47.800
But you could lose that vote.

00:21:47.800 --> 00:21:51.300
It could turn out the 1, g
she was aborted after all.

00:21:51.300 --> 00:21:53.980
And so then you'll move
on to ballot round two.

00:21:53.980 --> 00:21:58.100
And now maybe you'll
try to prepare 2, f.

00:21:58.100 --> 00:22:01.250
So let's say you
manage to prepare 2, f.

00:22:01.250 --> 00:22:03.221
And now you vote to commit it.

00:22:03.221 --> 00:22:04.970
And it might be that,
well, you know what?

00:22:04.970 --> 00:22:06.010
That vote gets stuck.

00:22:06.010 --> 00:22:08.750
It turns out we'll never
manage to commit 2,f.

00:22:08.750 --> 00:22:09.654
Oh, well.

00:22:09.654 --> 00:22:10.820
Just bump the counter again.

00:22:10.820 --> 00:22:12.710
And now let's move to 3, f.

00:22:12.710 --> 00:22:16.235
And now you'll prepare 3,
f and vote to commit 3, f.

00:22:16.235 --> 00:22:18.530
And maybe this time,
the vote succeeds.

00:22:18.530 --> 00:22:20.839
So you've managed to
commit ballot 3, f.

00:22:20.839 --> 00:22:21.630
And now we're done.

00:22:21.630 --> 00:22:23.200
We've chosen the
value of the system.

00:22:23.200 --> 00:22:25.370
We can output the value f.

00:22:25.370 --> 00:22:27.140
And notice that at
this point, nobody

00:22:27.140 --> 00:22:28.700
cares about the status of 2, f.

00:22:28.700 --> 00:22:29.390
anymore.

00:22:29.390 --> 00:22:32.450
That's been totally--
it's been neutralized.

00:22:32.450 --> 00:22:37.229
Whether 2, f is aborted, or
committed, or we'll never know,

00:22:37.229 --> 00:22:39.520
it just doesn't matter because
the question we actually

00:22:39.520 --> 00:22:42.103
care about-- which is, should
we output the value f-- that one

00:22:42.103 --> 00:22:43.260
has been decided.

00:22:43.260 --> 00:22:45.530
And if for some
reason not everybody

00:22:45.530 --> 00:22:49.344
can see the quorum
that voted for 3, f

00:22:49.344 --> 00:22:51.760
because maybe some nodes failed
or something, that's fine.

00:22:51.760 --> 00:22:52.926
Just bump the counter again.

00:22:52.926 --> 00:22:56.760
And now we can prepare
and commit 4, f.

00:22:56.760 --> 00:22:59.010
So this is Paxos.

00:22:59.010 --> 00:23:00.950
This may be an unusual
way to present Paxos.

00:23:00.950 --> 00:23:03.940
But we'll see that it's a way
that generalizes to the model

00:23:03.940 --> 00:23:06.320
that we need for this kind
of global financial network.

00:23:09.845 --> 00:23:10.345
OK.

00:23:10.345 --> 00:23:12.710
So, so far, we've been
in the fail-stop case.

00:23:12.710 --> 00:23:14.840
We've been imagining that
the nodes have failed.

00:23:14.840 --> 00:23:16.390
They just crashed.

00:23:16.390 --> 00:23:18.820
And they never output
another message.

00:23:18.820 --> 00:23:21.760
What happens when you
have Byzantine failure?

00:23:21.760 --> 00:23:23.870
So the big difference
here is that when

00:23:23.870 --> 00:23:26.700
you have a Byzantine
failure, the failed node,

00:23:26.700 --> 00:23:28.690
it can actually change its vote.

00:23:28.690 --> 00:23:31.207
It can give inconsistent
messages to different people.

00:23:31.207 --> 00:23:33.290
It can tell one person,
oh, I vote for this value,

00:23:33.290 --> 00:23:35.820
and somebody else, oh,
I vote for that value.

00:23:35.820 --> 00:23:38.800
So in the fail-stop
case, in order

00:23:38.800 --> 00:23:41.300
to guarantee safety
and, in particular,

00:23:41.300 --> 00:23:43.570
in order to guarantee
agreement, we

00:23:43.570 --> 00:23:45.955
needed this guarantee that
any two quorums shared a node.

00:23:45.955 --> 00:23:48.080
And we said, well, that
node won't change its vote.

00:23:48.080 --> 00:23:52.070
So therefore any two quorums
that vote for a value

00:23:52.070 --> 00:23:53.840
will vote for the same value.

00:23:53.840 --> 00:23:56.900
Now we need to kind of
strengthen that assumption.

00:23:56.900 --> 00:23:59.910
We need to say that
any quorums need

00:23:59.910 --> 00:24:03.100
to share a non-faulty node
because a faulty node can just

00:24:03.100 --> 00:24:06.810
lie and give
contradictory votes.

00:24:06.810 --> 00:24:09.960
So if you have N nodes
in your quorum size is T,

00:24:09.960 --> 00:24:13.440
then the minimum overlap
between any two quorums

00:24:13.440 --> 00:24:16.325
is going to be to
2T minus N. So what

00:24:16.325 --> 00:24:18.490
that means, if you want
an honest node in there,

00:24:18.490 --> 00:24:21.900
then the greatest number
of Byzantine failures

00:24:21.900 --> 00:24:25.950
you can tolerate is going
to be 2T minus N minus 1.

00:24:25.950 --> 00:24:27.700
And I'm going to
call that value f

00:24:27.700 --> 00:24:31.590
sub s because it's the
failure tolerance with respect

00:24:31.590 --> 00:24:33.920
to safety, basically.

00:24:33.920 --> 00:24:35.020
Now what about liveliness?

00:24:35.020 --> 00:24:37.270
Well, for liveness you
actually want to make progress.

00:24:37.270 --> 00:24:39.550
You actually need
there to be a quorum.

00:24:39.550 --> 00:24:42.210
And so if you have N nodes
and a quorum size of T,

00:24:42.210 --> 00:24:45.616
that means you can tolerate
up to N minus T failures

00:24:45.616 --> 00:24:46.990
and still have a
quorum left over

00:24:46.990 --> 00:24:48.156
with which to make progress.

00:24:48.156 --> 00:24:51.320
So I'll call that value f sub
l because it's the failure

00:24:51.320 --> 00:24:54.040
tolerance for liveliness.

00:24:54.040 --> 00:24:57.150
And there exist
long-standing solutions

00:24:57.150 --> 00:24:59.920
to the Byzantine agreement
protocol in this problem,

00:24:59.920 --> 00:25:01.290
in this model.

00:25:01.290 --> 00:25:03.110
And typically what
people do is that they

00:25:03.110 --> 00:25:07.690
set the number of nodes, N, to
be 3f plus 1 for some integer

00:25:07.690 --> 00:25:10.811
f, and the quorum size
T to be 2f plus 1.

00:25:10.811 --> 00:25:12.810
And the reason they do
that is that it gives you

00:25:12.810 --> 00:25:17.357
the equilibrium point where
fs equals fl which equals f.

00:25:17.357 --> 00:25:18.940
In other words, this
failure tolerance

00:25:18.940 --> 00:25:22.020
for both safety and
liveness are the same.

00:25:22.020 --> 00:25:23.690
But for the purposes
of this talk,

00:25:23.690 --> 00:25:27.370
it's going to be important to
keep those numbers different.

00:25:27.370 --> 00:25:30.085
So I'll just keep referring
to them as fs and fl

00:25:30.085 --> 00:25:34.710
so you know which one I
mean when I talk about this.

00:25:34.710 --> 00:25:40.230
So here again is the picture
of what we get from a vote.

00:25:40.230 --> 00:25:42.370
And so a question
that we need to answer

00:25:42.370 --> 00:25:45.580
at this point is how do
we know when we're done?

00:25:45.580 --> 00:25:48.390
So if you're in the system, and
you see T votes for some value

00:25:48.390 --> 00:25:50.270
a, then you know system
is at least a valent.

00:25:50.270 --> 00:25:51.936
You know the system's
not going to agree

00:25:51.936 --> 00:25:54.180
on some different value.

00:25:54.180 --> 00:25:58.790
But you don't know that all
the non-faulty nodes will

00:25:58.790 --> 00:26:02.230
eventually agree on this
value a or even know

00:26:02.230 --> 00:26:04.700
that the system reached
an a valent state.

00:26:04.700 --> 00:26:06.460
So what do we do about this?

00:26:06.460 --> 00:26:09.790
Well, if you remember
from the previous slide,

00:26:09.790 --> 00:26:14.260
we said that f sub s was
the greatest number of nodes

00:26:14.260 --> 00:26:16.984
we could survive
failing and still

00:26:16.984 --> 00:26:18.150
be able to guarantee safety.

00:26:18.150 --> 00:26:23.740
So that means if fs plus
1 nodes actually fail,

00:26:23.740 --> 00:26:25.279
you've lost all
safety guarantees

00:26:25.279 --> 00:26:27.070
because now the
intersection of two quorums

00:26:27.070 --> 00:26:29.740
can be entirely malicious.

00:26:29.740 --> 00:26:31.550
So suppose you have
fs plus 1 nodes

00:26:31.550 --> 00:26:32.980
that all say the same thing.

00:26:32.980 --> 00:26:36.400
They all say, we saw a
quorum vote for the value a.

00:26:36.400 --> 00:26:38.110
Well, at this point,
you can say, well,

00:26:38.110 --> 00:26:42.700
either they're all lying
to me, in which case

00:26:42.700 --> 00:26:46.270
they're all malicious so
I've lost all safety anyway,

00:26:46.270 --> 00:26:47.820
or one of them is
telling the truth

00:26:47.820 --> 00:26:51.195
so I might as well assume
that a quorum has voted for a

00:26:51.195 --> 00:26:54.590
without actually losing safety.

00:26:54.590 --> 00:27:00.552
Now suppose you hear actually
fl plus fs plus 1 nodes

00:27:00.552 --> 00:27:01.510
all say the same thing.

00:27:01.510 --> 00:27:04.260
They all say, we saw
a quorum vote for a.

00:27:04.260 --> 00:27:09.500
Well, could be that after
saying this, fl or more than fl

00:27:09.500 --> 00:27:11.900
of those nodes die, in
which case the system--

00:27:11.900 --> 00:27:13.770
we can't guarantee
liveness anyway.

00:27:13.770 --> 00:27:16.104
But if fl or fewer of
these nodes have failed,

00:27:16.104 --> 00:27:17.770
then that means that
there will continue

00:27:17.770 --> 00:27:19.800
to be fs plus 1 of them around.

00:27:19.800 --> 00:27:22.024
And those fs plus one,
if they're not faulty,

00:27:22.024 --> 00:27:24.440
they'll continue to repeat the
fact that they saw a quorum

00:27:24.440 --> 00:27:25.045
vote for a.

00:27:25.045 --> 00:27:28.230
So that will convince everybody
that a quorum voted for a.

00:27:28.230 --> 00:27:30.210
So at that point, all
the non-faulty nodes

00:27:30.210 --> 00:27:32.450
will come to accept the
fact that the system reached

00:27:32.450 --> 00:27:33.420
an a valent state.

00:27:33.420 --> 00:27:36.095
And so they'll know that none
of them have gotten stuck.

00:27:36.095 --> 00:27:38.470
And so at that point, we can
say that system has actually

00:27:38.470 --> 00:27:40.398
agreed on the statement a.

00:27:43.890 --> 00:27:46.020
All right.

00:27:46.020 --> 00:27:47.010
So this is all good.

00:27:47.010 --> 00:27:50.010
But so far we've been
in this T of N system

00:27:50.010 --> 00:27:54.377
where you had to know what the
end nodes were to begin with.

00:27:54.377 --> 00:27:56.960
So now I'm going to talk about
this new model called Federated

00:27:56.960 --> 00:27:59.630
Byzantine Agreement,
which is a generalization

00:27:59.630 --> 00:28:02.890
of standard Byzantine Agreement
to a setting where you don't

00:28:02.890 --> 00:28:05.280
have universal agreement
on who all the nodes are

00:28:05.280 --> 00:28:08.010
or how trustworthy
all the nodes are.

00:28:08.010 --> 00:28:11.100
And the key idea in
Federated Byzantine Agreement

00:28:11.100 --> 00:28:15.830
is that we're going to pick our
quorums in a decentralized way.

00:28:15.830 --> 00:28:20.760
So each node in the system V
is going to pick one or more

00:28:20.760 --> 00:28:21.980
of what I call quorum slices.

00:28:21.980 --> 00:28:26.100
So quorum slices are sets of
nodes that include v itself.

00:28:26.100 --> 00:28:28.890
And a quorum slice
is a set of nodes

00:28:28.890 --> 00:28:31.540
that v believes is important
enough that if the whole quorum

00:28:31.540 --> 00:28:35.440
slice agrees on something,
then that thing is true.

00:28:35.440 --> 00:28:37.340
And it's not going
to be rolled back.

00:28:37.340 --> 00:28:42.220
And you can think of
deciding to put somebody

00:28:42.220 --> 00:28:43.340
in your quorum slice.

00:28:43.340 --> 00:28:47.282
And one of your quorum slices
is vaguely analogous to

00:28:47.282 --> 00:28:50.180
in the inter-domain
routing setting of two ISPs

00:28:50.180 --> 00:28:51.240
deciding to peer.

00:28:51.240 --> 00:28:55.500
They decide there's
some value in exchanging

00:28:55.500 --> 00:28:57.790
internet traffic or, in
this case, some value

00:28:57.790 --> 00:29:01.910
in waiting for somebody to agree
to something before considering

00:29:01.910 --> 00:29:04.652
that statement settled.

00:29:04.652 --> 00:29:06.360
So a Federated Byzantine
Agreement system

00:29:06.360 --> 00:29:09.910
is basically a set of nodes
V and a quorum function Q,

00:29:09.910 --> 00:29:11.610
where Q of V is
the set of slices

00:29:11.610 --> 00:29:14.990
that were chosen by node v. And
so now we can define a quorum.

00:29:14.990 --> 00:29:17.840
We can say that quorum
U is just a set of nodes

00:29:17.840 --> 00:29:20.660
that contains at least
one slice belonging

00:29:20.660 --> 00:29:23.330
to each one of its members.

00:29:23.330 --> 00:29:28.390
And this is like the key
definition in the whole talk.

00:29:28.390 --> 00:29:31.110
So I want to zoom in on this
with a couple of examples

00:29:31.110 --> 00:29:34.600
to make this much more concrete.

00:29:34.600 --> 00:29:37.100
So let's start with a simple
example, just a system

00:29:37.100 --> 00:29:39.020
with four nodes.

00:29:39.020 --> 00:29:41.760
And you have quorum--
each node also,

00:29:41.760 --> 00:29:44.780
to make this even simpler, has
only a single quorum slice.

00:29:44.780 --> 00:29:46.770
And I'm representing
the quorum slices

00:29:46.770 --> 00:29:49.560
by drawing arrows from a
node to all the other nodes

00:29:49.560 --> 00:29:51.960
in its quorum slice.

00:29:51.960 --> 00:29:56.430
So in this case, you
can see v1's quorum

00:29:56.430 --> 00:29:57.620
slice is v1, v2, v3.

00:29:57.620 --> 00:29:59.190
And the other three
nodes, v2, v3, v4

00:29:59.190 --> 00:30:03.090
are a quorum slice
for each other.

00:30:03.090 --> 00:30:06.560
So you can see that if you
look at just nodes v2, v3,

00:30:06.560 --> 00:30:09.990
and v4, that is actually a
quorum because it contains

00:30:09.990 --> 00:30:13.090
a slice belonging to
each one of its members.

00:30:13.090 --> 00:30:17.710
If you look at the set v1, v2,
v3, that is a quorum slice,

00:30:17.710 --> 00:30:21.806
but it's not actually a
quorum because, in a sense,

00:30:21.806 --> 00:30:23.930
v1 is saying, well, I'll
agree to something as long

00:30:23.930 --> 00:30:25.650
as v2 and v3 agree to it.

00:30:25.650 --> 00:30:27.200
But then v2 is
saying, well, I'll

00:30:27.200 --> 00:30:29.452
agree to something only
if v3 and v4 agree to it.

00:30:29.452 --> 00:30:31.410
So you can see v2 is
never to be able to accept

00:30:31.410 --> 00:30:35.190
any statement unless v4
agrees to it because v2 is not

00:30:35.190 --> 00:30:39.550
going to agree to it unless
v4 is somehow involved here.

00:30:39.550 --> 00:30:42.450
So in fact, the smallest
quorum that contains v1

00:30:42.450 --> 00:30:47.730
is a set of all nodes in
the system, v1, v2, v3, v4.

00:30:47.730 --> 00:30:49.950
So this is a simple example.

00:30:49.950 --> 00:30:52.690
Let's turn to maybe a more
realistic example, which

00:30:52.690 --> 00:30:54.780
would be a tiered quorum slice.

00:30:54.780 --> 00:30:58.130
So maybe there's a top tier
of very important nodes.

00:30:58.130 --> 00:30:59.630
And they only know
about each other,

00:30:59.630 --> 00:31:01.450
but they're
configured in a three

00:31:01.450 --> 00:31:04.880
out of four setting, where
each, v1, v2, v3, v4,

00:31:04.880 --> 00:31:06.720
believes that three
of those nodes

00:31:06.720 --> 00:31:08.680
constitutes a quorum slice.

00:31:08.680 --> 00:31:10.340
Then you have
maybe a middle tier

00:31:10.340 --> 00:31:12.720
that depends not on each
other, but on the top tier.

00:31:12.720 --> 00:31:16.360
So v5 here is saying, well, I'll
consider a quorum slice myself

00:31:16.360 --> 00:31:18.620
plus two of the top tier notes.

00:31:18.620 --> 00:31:20.340
Then maybe you have
a leaf here that also

00:31:20.340 --> 00:31:22.450
depends on the middle tier.

00:31:22.450 --> 00:31:24.640
So this is a lot
like the internet

00:31:24.640 --> 00:31:25.899
where we have tier one ISPs.

00:31:25.899 --> 00:31:27.440
But the nice thing
about the internet

00:31:27.440 --> 00:31:31.510
is nobody had to magically
designate these tier one ISPs.

00:31:31.510 --> 00:31:35.720
The tier one status arose
out of market forces.

00:31:35.720 --> 00:31:38.050
And you don't even need
universal agreement

00:31:38.050 --> 00:31:39.410
over who's a tier one ISP.

00:31:39.410 --> 00:31:42.710
Occasionally you have, is
Cogent the tier one ISP or not?

00:31:42.710 --> 00:31:45.460
And level three and Cogent
will play chicken or something.

00:31:45.460 --> 00:31:48.620
And then eventually
market forces prevail.

00:31:48.620 --> 00:31:50.863
And they have to reach
some kind of agreement.

00:31:54.030 --> 00:31:56.750
So in this case, let's say that
the market decides that these

00:31:56.750 --> 00:31:58.380
are top four banks in the US.

00:31:58.380 --> 00:32:01.340
T These are really the top
tier of financial institutions.

00:32:01.340 --> 00:32:04.110
So nothing happens
unless two out

00:32:04.110 --> 00:32:08.430
of these-- or three out of
these four banks agrees to it.

00:32:08.430 --> 00:32:10.314
But the nice thing is
you don't need to have

00:32:10.314 --> 00:32:11.480
unanimous agreement on that.

00:32:11.480 --> 00:32:14.774
So let's see v7 and v8
are extremely paranoid.

00:32:14.774 --> 00:32:15.940
And they say, you know what?

00:32:15.940 --> 00:32:17.820
I realize I can't through
life without interacting

00:32:17.820 --> 00:32:18.460
with these big banks.

00:32:18.460 --> 00:32:19.660
But I don't trust them at all.

00:32:19.660 --> 00:32:22.076
I think they're going to try
to rip me off the minute they

00:32:22.076 --> 00:32:23.900
have the opportunity to do so.

00:32:23.900 --> 00:32:24.610
Well, no problem.

00:32:24.610 --> 00:32:26.140
You can have some other
people come along.

00:32:26.140 --> 00:32:28.431
Let's say we have a couple
of nonprofits here, Stellar,

00:32:28.431 --> 00:32:29.960
the EFF, or the ACLU.

00:32:29.960 --> 00:32:33.650
They can also participate
in this consensus protocol.

00:32:33.650 --> 00:32:35.297
And maybe v7 and
v8 say, not only

00:32:35.297 --> 00:32:37.130
am I going to wait for
two of the big banks,

00:32:37.130 --> 00:32:38.690
I also want one of
these nonprofits

00:32:38.690 --> 00:32:42.500
to sign off on a transaction
before I consider it settled.

00:32:42.500 --> 00:32:44.430
And the nonprofits
are going to depend

00:32:44.430 --> 00:32:46.100
on two out of
three of each other

00:32:46.100 --> 00:32:48.577
in addition to depending
on the main banks.

00:32:48.577 --> 00:32:49.910
So now let's look at an example.

00:32:49.910 --> 00:32:54.310
Suppose Citibank decides
to pay a $1 billion to v7.

00:32:54.310 --> 00:32:59.480
And v7 hands over whatever,
$1 billion worth of goods.

00:32:59.480 --> 00:33:01.040
So why would v7 do this?

00:33:01.040 --> 00:33:04.220
Well, v7 would do this because
here's two out of the four

00:33:04.220 --> 00:33:05.920
main banks doing this.

00:33:05.920 --> 00:33:08.530
And also because it hears
one of the nonprofits,

00:33:08.530 --> 00:33:09.520
let's say, Stellar.

00:33:09.520 --> 00:33:11.370
But Stellar is not going to
agree to something unless one

00:33:11.370 --> 00:33:12.286
of the other one does.

00:33:12.286 --> 00:33:14.730
So let's say the EFF had
to sign off on this, too.

00:33:14.730 --> 00:33:17.800
So basically, if you look at the
nodes with green check marks,

00:33:17.800 --> 00:33:19.040
that constitutes a quorum.

00:33:19.040 --> 00:33:22.640
And those nodes can agree
that this transaction happened

00:33:22.640 --> 00:33:25.950
and permanently
place it in a log.

00:33:25.950 --> 00:33:28.360
So now let's see that
v7's paranoia was actually

00:33:28.360 --> 00:33:29.010
justified.

00:33:29.010 --> 00:33:31.150
So these big three
banks collude.

00:33:31.150 --> 00:33:31.870
They're evil.

00:33:31.870 --> 00:33:33.850
And they try to
reverse this $1 billion

00:33:33.850 --> 00:33:36.540
transaction after they've
walked away with $1 billion

00:33:36.540 --> 00:33:37.322
worth of goods.

00:33:37.322 --> 00:33:39.530
And now what they want to
do is they want to go to v8

00:33:39.530 --> 00:33:43.200
and give v8 $1 billion and
also walk away with $1 billion

00:33:43.200 --> 00:33:45.034
worth of v8's goods.

00:33:45.034 --> 00:33:46.450
Well, what's going
to happen here?

00:33:46.450 --> 00:33:48.680
v8's going to say, OK, I
need two out of the big banks

00:33:48.680 --> 00:33:49.179
to agree.

00:33:49.179 --> 00:33:52.860
That's OK because these evil
banks, they'll read anything.

00:33:52.860 --> 00:33:55.490
But then he also needs
one of the nonprofits.

00:33:55.490 --> 00:33:57.157
So v8's going, well,
Stellar and the EFF

00:33:57.157 --> 00:33:59.198
aren't going to agree to
this because they agreed

00:33:59.198 --> 00:34:01.660
to a contradictory-- to a
different transaction, which

00:34:01.660 --> 00:34:03.610
the $1 billion went
somewhere else.

00:34:03.610 --> 00:34:05.450
So that leaves the ACLU.

00:34:05.450 --> 00:34:06.770
So v8 goes to the ACLU.

00:34:06.770 --> 00:34:09.500
But the ACLU says, well,
my quorum slice also

00:34:09.500 --> 00:34:12.179
has to include one of
Stellar or the EFF.

00:34:12.179 --> 00:34:16.022
And since those organizations
won't agree to this,

00:34:16.022 --> 00:34:17.230
the ACLU won't agree to that.

00:34:17.230 --> 00:34:19.313
And so v8 is never going
to accept this $1 billion

00:34:19.313 --> 00:34:22.590
and is never going to turn
over $1 billion worth of goods.

00:34:26.120 --> 00:34:28.280
So that's the model.

00:34:28.280 --> 00:34:32.630
And now the question is,
how secure can we make this?

00:34:32.630 --> 00:34:36.040
So the first big difference
between Federated Byzantine

00:34:36.040 --> 00:34:40.060
Agreement and the standard
centralized Byzantine Agreement

00:34:40.060 --> 00:34:42.600
is that in the
Federated model, failure

00:34:42.600 --> 00:34:43.871
becomes a per node thing.

00:34:43.871 --> 00:34:45.870
In the centralized case,
either the whole system

00:34:45.870 --> 00:34:48.760
fails or at least all the
non-faulty nodes agree.

00:34:48.760 --> 00:34:52.687
Now you can have some nodes
failing and others not.

00:34:52.687 --> 00:34:54.520
And so particularly you
can divide the nodes

00:34:54.520 --> 00:34:56.650
into the ill-behaved nodes
and the well-behaved nodes.

00:34:56.650 --> 00:34:59.025
The ill-behaved nodes are
going to deviate from protocol,

00:34:59.025 --> 00:35:00.530
do all kinds of nasty things.

00:35:00.530 --> 00:35:04.530
They've obviously failed, but
who cares because they're not

00:35:04.530 --> 00:35:06.510
implementing the protocol.

00:35:06.510 --> 00:35:09.640
The well-behaved nodes,
unfortunately, some of them

00:35:09.640 --> 00:35:12.015
might fail, too, if there are
too many ill-behaved nodes.

00:35:12.015 --> 00:35:13.181
And two things could happen.

00:35:13.181 --> 00:35:15.140
What would be bad is
if well-behaved nodes

00:35:15.140 --> 00:35:17.750
stop being able to make
progress because they

00:35:17.750 --> 00:35:20.620
can no longer assemble a quorum
or they can no longer agree

00:35:20.620 --> 00:35:22.730
to a new transaction.

00:35:22.730 --> 00:35:25.280
That's like all your
ATM machines shut down.

00:35:25.280 --> 00:35:28.660
What's worse is if all the
well-behaved nodes somehow get

00:35:28.660 --> 00:35:30.200
driven into divergent states.

00:35:30.200 --> 00:35:32.240
So that's now like each
of your ATM machines

00:35:32.240 --> 00:35:34.550
pays out the entire value
of somebody's account.

00:35:34.550 --> 00:35:39.910
So you've lost many times the
value of the deposits you had,

00:35:39.910 --> 00:35:41.740
were storing for someone.

00:35:41.740 --> 00:35:44.280
And, obviously, if a
well-behaved node is not

00:35:44.280 --> 00:35:47.237
in either of these
two cases, then we'll

00:35:47.237 --> 00:35:48.195
say that it is correct.

00:35:51.030 --> 00:35:54.140
So let's say that we
want to guarantee safety.

00:35:54.140 --> 00:35:55.990
Well, what's a
necessary property

00:35:55.990 --> 00:35:57.490
for guaranteeing safety?

00:35:57.490 --> 00:35:59.160
Suppose your system
is configured such

00:35:59.160 --> 00:36:02.664
that you have two quorums
that are entirely disjoint.

00:36:02.664 --> 00:36:04.830
Well, at that point,
obviously, the guys on the left

00:36:04.830 --> 00:36:05.950
can vote for something.

00:36:05.950 --> 00:36:07.280
The guys on the right
can vote for something

00:36:07.280 --> 00:36:08.154
completely different.

00:36:08.154 --> 00:36:10.030
In fact, both sides
of the diagram

00:36:10.030 --> 00:36:12.820
can make progress without
even exchanging any messages

00:36:12.820 --> 00:36:15.180
across the two halves
of the diagram.

00:36:15.180 --> 00:36:19.130
So clearly, there's no way
to guarantee safety here.

00:36:19.130 --> 00:36:22.870
So like traditional consensus,
in order to guarantee safety,

00:36:22.870 --> 00:36:24.870
we need what's called
quorum intersection.

00:36:24.870 --> 00:36:28.130
Quorum intersection means that
any two quorums are actually

00:36:28.130 --> 00:36:29.836
going to share at
least one node.

00:36:29.836 --> 00:36:31.960
So in this case, you say,
OK, well, let's fix this.

00:36:31.960 --> 00:36:33.520
Let's throw in some node v7.

00:36:33.520 --> 00:36:35.480
And let's make
everybody depend on v7.

00:36:35.480 --> 00:36:39.030
And great, now all are
quorums intersect at v7.

00:36:39.030 --> 00:36:41.670
But what happens if v7 fails?

00:36:41.670 --> 00:36:44.860
What happens if all
your quorums intersect

00:36:44.860 --> 00:36:48.050
at in the intersection
of two quorums

00:36:48.050 --> 00:36:50.470
because it's entirely
of malicious nodes?

00:36:50.470 --> 00:36:53.000
Well, remember these
Byzantine malicious nodes,

00:36:53.000 --> 00:36:55.870
they can give inconsistent
messages to different people.

00:36:55.870 --> 00:36:57.760
So v7, it can say one
thing to the nodes

00:36:57.760 --> 00:37:00.250
on the left, something else
to the nodes on the right.

00:37:00.250 --> 00:37:03.660
And again, it can drive the
system into divergent states.

00:37:03.660 --> 00:37:06.910
So in fact, the property
that's necessary for safety

00:37:06.910 --> 00:37:08.930
in the presence of
Byzantine failures

00:37:08.930 --> 00:37:10.800
is that we need
quorum intersection

00:37:10.800 --> 00:37:13.750
despite the behavior of
any ill-behaved nodes.

00:37:13.750 --> 00:37:16.630
What that means is that we
have to basically delete

00:37:16.630 --> 00:37:18.720
all the ill-behaved
nodes from the system

00:37:18.720 --> 00:37:20.470
and from everybody's
quorum slices.

00:37:20.470 --> 00:37:22.178
And we want to make
sure that after we've

00:37:22.178 --> 00:37:24.240
deleted all those bad
nodes that we still

00:37:24.240 --> 00:37:25.580
have quorum intersection.

00:37:25.580 --> 00:37:27.600
But in this example,
if we delete v7,

00:37:27.600 --> 00:37:30.150
it just reverts to the
diagram on the previous page.

00:37:30.150 --> 00:37:32.360
And, obviously, there's no
way to guarantee safety.

00:37:36.460 --> 00:37:38.710
So what about liveliness?

00:37:38.710 --> 00:37:42.770
So suppose you have some
three out of four system,

00:37:42.770 --> 00:37:45.560
and two out of the
four nodes fail.

00:37:45.560 --> 00:37:49.370
So in this case, v1, it
includes two quorum places

00:37:49.370 --> 00:37:51.950
that has v1, v2, v3--
actually three slices, v1, v2,

00:37:51.950 --> 00:37:56.470
v3-- v1, v3, v4-- v1, v2 v4--
Every single one of his quorum

00:37:56.470 --> 00:38:00.310
slices actually
contains a failed node.

00:38:00.310 --> 00:38:03.580
So if there's a
set of nodes that

00:38:03.580 --> 00:38:06.390
intersect every single one
of some node's v slices,

00:38:06.390 --> 00:38:08.580
we'll say that-- we'll
call that a v-blocking set.

00:38:08.580 --> 00:38:10.830
So in this case, we can say
that the set of fail nodes

00:38:10.830 --> 00:38:16.490
is v1 blocking because it denies
v1 the ability to have a quorum

00:38:16.490 --> 00:38:19.160
slice of non-faulty nodes.

00:38:19.160 --> 00:38:22.830
So you can see that
failed nodes can't

00:38:22.830 --> 00:38:25.950
be v-blocking for any correct
node v because if they were,

00:38:25.950 --> 00:38:28.900
then v could never make progress
because the failed nodes could

00:38:28.900 --> 00:38:30.830
just crash and never
output a message.

00:38:30.830 --> 00:38:33.336
And the view would never
be able to hear unanimously

00:38:33.336 --> 00:38:35.460
from one of its quorums
because each of its quorums

00:38:35.460 --> 00:38:37.490
would include one of
its quorum slices.

00:38:37.490 --> 00:38:41.400
And that quorum slice would
include a failed node.

00:38:41.400 --> 00:38:44.535
And it turns out saying that the
field nodes aren't v-blocking

00:38:44.535 --> 00:38:45.410
for any correct node.

00:38:45.410 --> 00:38:47.160
That's equivalent to saying
that the correct nodes have

00:38:47.160 --> 00:38:48.340
to form a quorum.

00:38:48.340 --> 00:38:50.900
So the necessary property
for liveness in the system

00:38:50.900 --> 00:38:53.780
is that the correct nodes
actually have to form a quorum.

00:38:56.580 --> 00:38:59.860
So to summarize,
let's say you have

00:38:59.860 --> 00:39:04.260
a set U of well-behaved nodes in
a Federated Byzantine Agreement

00:39:04.260 --> 00:39:05.040
system.

00:39:05.040 --> 00:39:08.780
And let's say that U bar are
the nodes that are not in U.

00:39:08.780 --> 00:39:09.745
And we don't know.

00:39:09.745 --> 00:39:11.703
Those nodes might actually
be able ill-behaved.

00:39:11.703 --> 00:39:12.930
We can't assume otherwise.

00:39:12.930 --> 00:39:16.090
So in order to guarantee
safety for you,

00:39:16.090 --> 00:39:19.230
we need to know that U enjoys
quorum intersection despite U

00:39:19.230 --> 00:39:23.390
bar, that even if you delete
U bar from everybody's slices,

00:39:23.390 --> 00:39:26.271
you'll still have
quorum intersection.

00:39:26.271 --> 00:39:28.520
And if you want to guarantee
both safety and liveness,

00:39:28.520 --> 00:39:32.820
then you need not only quorum
intersection despite U bar,

00:39:32.820 --> 00:39:35.960
but you also need U
itself to be a quorum,

00:39:35.960 --> 00:39:40.170
meaning U bar's not v-blocking
for any of the nodes in U.

00:39:40.170 --> 00:39:42.880
And if both of these
properties hold,

00:39:42.880 --> 00:39:46.290
then we'll say that
the-- for set U--

00:39:46.290 --> 00:39:49.730
then we'll say that the nodes
in set U are actually intact.

00:39:49.730 --> 00:39:52.630
And, in fact, you can show
that if your system has quorum

00:39:52.630 --> 00:39:55.280
intersection, then
there's actually

00:39:55.280 --> 00:39:57.419
one maximal set
of intact nodes U.

00:39:57.419 --> 00:39:58.960
So that's convenient
because it means

00:39:58.960 --> 00:40:02.474
we can just talk about the
intact nodes in the system.

00:40:05.530 --> 00:40:07.870
So now the question is,
can we actually achieve

00:40:07.870 --> 00:40:11.150
this kind of optimal failure
resistance in a Federated

00:40:11.150 --> 00:40:12.610
Byzantine Agreement system?

00:40:12.610 --> 00:40:15.970
So what I'll talk about
now is the protocol

00:40:15.970 --> 00:40:17.700
that's at the core
of the Stellar system

00:40:17.700 --> 00:40:21.975
that actually satisfies this
optimal failure resilience.

00:40:26.554 --> 00:40:27.970
So the Stellar
Consensus Protocol,

00:40:27.970 --> 00:40:31.440
it's obviously the first
general FBA protocol.

00:40:31.440 --> 00:40:33.960
And it guarantees safety
for well-behaved nodes

00:40:33.960 --> 00:40:37.590
that enjoy quorum intersection
despite the ill-behaved nodes.

00:40:37.590 --> 00:40:40.590
So what that means is
if you use my protocol,

00:40:40.590 --> 00:40:43.730
and then you end up
in a situation where

00:40:43.730 --> 00:40:46.310
your nodes diverge
and you lost safety,

00:40:46.310 --> 00:40:48.320
then you can at least
take comfort in the fact

00:40:48.320 --> 00:40:50.937
that no other protocol
could have done any better,

00:40:50.937 --> 00:40:53.270
could have guaranteed you
safety under the circumstance.

00:40:53.270 --> 00:40:55.040
You just had too many failures.

00:40:55.040 --> 00:41:01.120
Or your quorum slices were too
small or were poorly chosen.

00:41:01.120 --> 00:41:03.710
Also, SCP is going to guarantee
that intact nodes never

00:41:03.710 --> 00:41:04.230
get stuck.

00:41:04.230 --> 00:41:07.670
So you can always end
up making progress.

00:41:07.670 --> 00:41:09.890
And the core idea
in the protocol

00:41:09.890 --> 00:41:11.492
is this technique
Federated voting.

00:41:11.492 --> 00:41:12.950
So the idea is that
nodes are going

00:41:12.950 --> 00:41:16.640
to exchange vote messages,
but piggybacked on the votes

00:41:16.640 --> 00:41:19.970
are going to be a specification
of every node's quorum slices

00:41:19.970 --> 00:41:22.050
so that as you're
assembling votes,

00:41:22.050 --> 00:41:23.430
you learn people's
quorum slices.

00:41:23.430 --> 00:41:25.870
And out of that, you
can discover quorums

00:41:25.870 --> 00:41:30.510
and decide when a quorum has
actually voted for something.

00:41:33.350 --> 00:41:36.315
So as before, Federated
voting, nodes v

00:41:36.315 --> 00:41:38.240
are issuing these vote messages.

00:41:38.240 --> 00:41:41.110
And if a node votes for
some statement a, of course,

00:41:41.110 --> 00:41:44.540
that has to be consistent with
all of node v's past votes

00:41:44.540 --> 00:41:47.850
and any statements
that v has accepted.

00:41:47.850 --> 00:41:51.390
And if you reach a point
where there's a whole quorum

00:41:51.390 --> 00:41:56.900
U in which every node has
voted for the same statement,

00:41:56.900 --> 00:42:00.370
then we say that the quorum
has ratified the statement.

00:42:00.370 --> 00:42:03.940
So ratifying a statement means
an entire quorum voting for it.

00:42:03.940 --> 00:42:06.620
And you can show, and
it's not very surprising,

00:42:06.620 --> 00:42:08.980
that if the well-behaved
nodes in the system

00:42:08.980 --> 00:42:11.530
enjoy a quorum intersection
despite the ill-behaved nodes,

00:42:11.530 --> 00:42:14.360
that they won't ratify
contradictory statements.

00:42:14.360 --> 00:42:18.312
Makes sense intuitively
because when

00:42:18.312 --> 00:42:20.020
you delete all the
ill-behaved nodes that

00:42:20.020 --> 00:42:23.040
are issuing multiple votes, you
still have quorum intersection.

00:42:23.040 --> 00:42:26.342
Well, the good nodes at the
intersection of any two quorums

00:42:26.342 --> 00:42:27.800
are not going to
change their vote.

00:42:27.800 --> 00:42:29.716
So you're not going to
have two quorums voting

00:42:29.716 --> 00:42:32.340
for contradictory statements.

00:42:32.340 --> 00:42:33.851
So that's all well and good.

00:42:33.851 --> 00:42:35.850
We still have two problems,
though, which is you

00:42:35.850 --> 00:42:38.140
could have an
intact node v that's

00:42:38.140 --> 00:42:40.600
unable to ratify
some statement a,

00:42:40.600 --> 00:42:43.350
even after other nodes have
ratified the statement a.

00:42:43.350 --> 00:42:46.040
So some nodes might get
stuck while other nodes think

00:42:46.040 --> 00:42:49.130
the system's agreed
on something.

00:42:49.130 --> 00:42:52.880
Or you could have, yeah, and
so that could happen either

00:42:52.880 --> 00:42:57.215
because v voted against
a value, and it's not

00:42:57.215 --> 00:42:58.340
allowed to change its vote.

00:42:58.340 --> 00:43:01.440
Or because some node failed
after voting and v didn't

00:43:01.440 --> 00:43:02.620
hear the votes.

00:43:02.620 --> 00:43:04.880
So effectively, the
outcome of federated voting

00:43:04.880 --> 00:43:06.600
looks like this.

00:43:06.600 --> 00:43:08.550
Now this should be
a familiar diagram.

00:43:08.550 --> 00:43:10.800
This is exactly the
same set of outputs

00:43:10.800 --> 00:43:15.000
that we could have in
the centralized case.

00:43:15.000 --> 00:43:17.130
And so the first
thing you might think

00:43:17.130 --> 00:43:19.359
is, well, maybe we could
apply the same reasoning

00:43:19.359 --> 00:43:20.400
as in centralized voting.

00:43:20.400 --> 00:43:22.080
So if you remember, in
centralized voting, we said,

00:43:22.080 --> 00:43:24.510
well, let's say you have the
intersection of two quorums.

00:43:24.510 --> 00:43:26.587
And that intersection
unanimously says,

00:43:26.587 --> 00:43:27.920
hey, we saw a quorum vote for a.

00:43:27.920 --> 00:43:29.060
Well, then, maybe
other people could

00:43:29.060 --> 00:43:30.809
decide that a quorum
was voting for a even

00:43:30.809 --> 00:43:32.800
if they themselves
didn't vote for a,

00:43:32.800 --> 00:43:35.380
or if they didn't
hear the votes.

00:43:35.380 --> 00:43:37.150
So does that work here?

00:43:37.150 --> 00:43:39.320
Well, unfortunately not.

00:43:39.320 --> 00:43:40.772
So what's the problem?

00:43:40.772 --> 00:43:42.480
The problem is before
we had this premise

00:43:42.480 --> 00:43:45.490
that either the whole
system failed or it was OK

00:43:45.490 --> 00:43:47.290
and all the
non-faulty nodes were

00:43:47.290 --> 00:43:48.770
going to have safety, right?

00:43:48.770 --> 00:43:52.860
And now, failure is
this per-node property.

00:43:52.860 --> 00:43:55.320
It's not a system-wide property.

00:43:55.320 --> 00:43:57.660
And so, in particular,
if you look at node vn

00:43:57.660 --> 00:43:59.430
minus 1 over on the
right-hand side here,

00:43:59.430 --> 00:44:01.990
you might say, oh, well, the
intersection of my quorum

00:44:01.990 --> 00:44:05.160
and quorum A is unanimously
telling me something.

00:44:05.160 --> 00:44:07.640
But I don't really care about
quorum A. For all I know,

00:44:07.640 --> 00:44:10.950
quorum A on the left is some
weird [? civil ?] attack that

00:44:10.950 --> 00:44:13.620
was constructed just to try to
get me to accept some statement

00:44:13.620 --> 00:44:15.040
that I shouldn't accept.

00:44:15.040 --> 00:44:16.720
So, tough.

00:44:16.720 --> 00:44:18.960
I can't conclude
anything from the fact

00:44:18.960 --> 00:44:22.160
that these people are telling
me a quorum voted for a.

00:44:22.160 --> 00:44:25.530
In fact, in a federated system,
you only care about the quorums

00:44:25.530 --> 00:44:27.890
that you belong to yourself.

00:44:27.890 --> 00:44:29.950
And so what that means
that the only way

00:44:29.950 --> 00:44:33.320
to know that the system has
reached an a valent state

00:44:33.320 --> 00:44:35.800
is to ratify the
statement a firsthand.

00:44:35.800 --> 00:44:38.570
You can't believe it just
because somebody else

00:44:38.570 --> 00:44:40.280
tells you that.

00:44:40.280 --> 00:44:42.580
So what are we going
to do about this?

00:44:42.580 --> 00:44:46.520
Well, here's an idea.

00:44:46.520 --> 00:44:51.670
Suppose that there's a
v-blocking set that unanimously

00:44:51.670 --> 00:44:59.200
tells node v, hey, we saw--
we've accepted the statement a.

00:44:59.200 --> 00:45:04.590
So either that whole set
is lying, in which case

00:45:04.590 --> 00:45:07.240
node v is no longer intact.

00:45:07.240 --> 00:45:08.970
So we can't guarantee
it's correct.

00:45:08.970 --> 00:45:13.490
Or, in fact, the system did
reach some a valent state,

00:45:13.490 --> 00:45:16.540
and these guys correctly
accepted the statement a.

00:45:16.540 --> 00:45:19.470
So based on [INAUDIBLE]
define this notion

00:45:19.470 --> 00:45:20.790
of accepting something.

00:45:20.790 --> 00:45:22.885
We'll say that a node
accepts the statement

00:45:22.885 --> 00:45:26.520
a that's consistent
with v's history

00:45:26.520 --> 00:45:28.160
as long as one of
two things holds.

00:45:28.160 --> 00:45:30.600
Either there's a
quorum that includes

00:45:30.600 --> 00:45:35.430
v, in which each member either
voted for a or accepted a.

00:45:35.430 --> 00:45:37.830
So that's includes the
case where v is firsthand

00:45:37.830 --> 00:45:39.900
ratifying the statement a.

00:45:39.900 --> 00:45:43.130
Or there's some
v-blocking set that

00:45:43.130 --> 00:45:47.100
unanimously claims that they
have accepted the statement a.

00:45:47.100 --> 00:45:49.850
So the statement
number two here is

00:45:49.850 --> 00:45:53.450
what allows a node to accept
a statement even after it's

00:45:53.450 --> 00:45:56.120
voted against that statement.

00:45:56.120 --> 00:45:57.610
And, in fact, you can show.

00:45:57.610 --> 00:46:00.370
I show in the white paper
that corresponds to this talk

00:46:00.370 --> 00:46:03.560
that intact nodes
will never accept

00:46:03.560 --> 00:46:05.110
contradictory statements.

00:46:05.110 --> 00:46:08.540
So that sounds great except
we still have two problems.

00:46:08.540 --> 00:46:12.920
First of all, there is the
standard liveness and stuck

00:46:12.920 --> 00:46:13.519
problem.

00:46:13.519 --> 00:46:15.810
There's still no guarantee
that because one intact node

00:46:15.810 --> 00:46:19.010
accepted something, all the
intact nodes will accept it.

00:46:19.010 --> 00:46:22.150
And second of all,
there's this problem

00:46:22.150 --> 00:46:23.960
that we've actually
weakened safety

00:46:23.960 --> 00:46:26.062
by adding the second
property here.

00:46:26.062 --> 00:46:27.520
And you could end
up in a situation

00:46:27.520 --> 00:46:29.650
where you have
non-intact nodes but that

00:46:29.650 --> 00:46:33.790
ought to enjoy safety even
if they don't enjoy liveness.

00:46:33.790 --> 00:46:36.060
And now we have no
way of guaranteeing

00:46:36.060 --> 00:46:38.060
that they won't accept
contradictory statements.

00:46:38.060 --> 00:46:39.800
One way to look at
this, by analogy

00:46:39.800 --> 00:46:43.040
with the centralized system,
is that what we really wanted

00:46:43.040 --> 00:46:45.570
was a set of size fs plus
1 to tell us something.

00:46:45.570 --> 00:46:47.890
And what we have, a v-blocking
set, is more like fl

00:46:47.890 --> 00:46:50.320
plus 1 instead of fs plus 1.

00:46:54.010 --> 00:46:55.410
So how do we fix this?

00:46:55.410 --> 00:46:58.700
Well, the solution is
actually to hold a second vote

00:46:58.700 --> 00:47:01.620
on the fact that the
first vote succeeded.

00:47:01.620 --> 00:47:05.190
So we'll say that a quorum
confirms some statement

00:47:05.190 --> 00:47:09.790
a when that quorum ratifies
the statement we accepted a.

00:47:09.790 --> 00:47:12.230
And so a node that's
part of that quorum

00:47:12.230 --> 00:47:14.830
has confirmed the statement.

00:47:14.830 --> 00:47:16.850
So this immediately
solves problem two,

00:47:16.850 --> 00:47:19.910
the suboptimal safety problem,
because now in confirmation, it

00:47:19.910 --> 00:47:21.510
is a firsthand ratification.

00:47:21.510 --> 00:47:23.900
There's no weird
second criterion here

00:47:23.900 --> 00:47:25.570
that involves some
v-blocking set.

00:47:25.570 --> 00:47:28.240
You need a quorum to
confirm something.

00:47:28.240 --> 00:47:30.790
Turns out this also
solves the first problem

00:47:30.790 --> 00:47:34.000
where you have intact nodes that
are unable to accept something

00:47:34.000 --> 00:47:36.860
because if you think about
it, you can have intact nodes

00:47:36.860 --> 00:47:40.100
that vote against a statement
that's later accepted.

00:47:40.100 --> 00:47:42.204
But they won't vote
against the fact

00:47:42.204 --> 00:47:43.370
that the state was accepted.

00:47:43.370 --> 00:47:44.870
The fact that the
state was accepted

00:47:44.870 --> 00:47:46.275
is actually irrefutable.

00:47:46.275 --> 00:47:47.650
And if you remember,
that was one

00:47:47.650 --> 00:47:49.941
of the two kinds of statements
that it's OK to vote on,

00:47:49.941 --> 00:47:51.710
is irrefutable statements.

00:47:51.710 --> 00:47:54.760
And, in fact, I show that once
you have a single intact node

00:47:54.760 --> 00:47:56.630
in your system that's
confirmed a statement,

00:47:56.630 --> 00:47:59.110
you're guaranteed that all
intact nodes will eventually

00:47:59.110 --> 00:48:02.170
confirm that statement
once enough messages have

00:48:02.170 --> 00:48:05.120
been delivered.

00:48:05.120 --> 00:48:09.840
So here's summarizing this
Federated voting process.

00:48:09.840 --> 00:48:11.341
You start in some
uncommitted state.

00:48:11.341 --> 00:48:13.423
You have some statement a
that you think is valid.

00:48:13.423 --> 00:48:14.396
You might vote for a.

00:48:14.396 --> 00:48:18.159
And then if you see a quorum
vote for a, you'll accept a.

00:48:18.159 --> 00:48:19.200
You'll hold another vote.

00:48:19.200 --> 00:48:20.530
And then you'll confirm a.

00:48:20.530 --> 00:48:23.130
Or it could be that
you voted against a.

00:48:23.130 --> 00:48:23.690
That's OK.

00:48:23.690 --> 00:48:26.674
You might see a
v-blocking set say

00:48:26.674 --> 00:48:27.840
that they've all accepted a.

00:48:27.840 --> 00:48:29.715
And so at that point,
you'll accept a anyway.

00:48:29.715 --> 00:48:32.360
And then you'll again
vote to confirm it and get

00:48:32.360 --> 00:48:34.130
to the right-hand side.

00:48:34.130 --> 00:48:37.012
And once you reach
the confirm stage,

00:48:37.012 --> 00:48:39.470
you know that all the other
intact nodes, if you're intact,

00:48:39.470 --> 00:48:41.252
will also confirm a.

00:48:41.252 --> 00:48:45.220
And so you can rely on a
for both purposes of safety

00:48:45.220 --> 00:48:48.120
and liveness.

00:48:48.120 --> 00:48:50.460
So how do you get from
voting to consensus?

00:48:50.460 --> 00:48:53.990
Well, it turns out to be
exactly the same thing as Paxos.

00:48:53.990 --> 00:48:56.300
So you're going to vote to
commit and abort ballots.

00:48:56.300 --> 00:48:58.440
We're going to have the same
invariant as before, namely all

00:48:58.440 --> 00:49:00.148
the committed and
stuck ballots are going

00:49:00.148 --> 00:49:02.080
to have to have the same x.

00:49:02.080 --> 00:49:05.060
And you're going to have to
prepare a ballot before you

00:49:05.060 --> 00:49:06.380
vote to commit it.

00:49:06.380 --> 00:49:10.330
There's just, for convenience,
slightly different definition

00:49:10.330 --> 00:49:15.439
of prepare where we just totally
order all the ballots rather

00:49:15.439 --> 00:49:16.730
than the way [INAUDIBLE] Paxos.

00:49:16.730 --> 00:49:20.190
But it effectively works
out to be the same thing.

00:49:20.190 --> 00:49:22.760
Now there's one
interesting twist,

00:49:22.760 --> 00:49:25.100
which is how do you
know what values

00:49:25.100 --> 00:49:26.616
to vote for in the first place?

00:49:26.616 --> 00:49:28.240
So far this has all
been very abstract.

00:49:28.240 --> 00:49:30.140
And what you'd
like is, actually,

00:49:30.140 --> 00:49:32.390
for the system to
converge on some value.

00:49:32.390 --> 00:49:34.510
And then everybody
votes for the same value

00:49:34.510 --> 00:49:36.130
with reasonable likelihood.

00:49:36.130 --> 00:49:38.910
And then you can just
finish your protocol quickly

00:49:38.910 --> 00:49:40.950
versus everybody
trying to nominate

00:49:40.950 --> 00:49:43.770
different incompatible ballots
and you never make progress.

00:49:43.770 --> 00:49:45.710
So the other thing,
the other component

00:49:45.710 --> 00:49:47.860
of this protocol that I
don't have time to get into

00:49:47.860 --> 00:49:49.920
is a decentralized
nomination protocol

00:49:49.920 --> 00:49:52.390
that basically lets you
select a set of values

00:49:52.390 --> 00:49:55.960
that you can then combine
deterministically so everybody

00:49:55.960 --> 00:49:57.740
ends up with the same value.

00:49:57.740 --> 00:50:01.690
And the key insight in
the nomination protocol

00:50:01.690 --> 00:50:03.960
is the fact that you can
vote to nominate a value,

00:50:03.960 --> 00:50:06.110
but you can't vote against
nominating a value.

00:50:06.110 --> 00:50:09.760
So nominating values is
essentially irrefutable.

00:50:09.760 --> 00:50:11.420
And that's what
allows the system

00:50:11.420 --> 00:50:14.670
to converge on some set
of nominated values.

00:50:17.760 --> 00:50:21.780
So this protocol SCP has a
bunch of interesting properties.

00:50:21.780 --> 00:50:23.480
First of all, it's
decentralized.

00:50:23.480 --> 00:50:25.770
And then it can actually
realistically accommodate

00:50:25.770 --> 00:50:28.270
this internet-level consensus.

00:50:28.270 --> 00:50:31.250
It's also low latency, by which
I don't mean microseconds,

00:50:31.250 --> 00:50:32.130
but, I mean, compared
to the amount

00:50:32.130 --> 00:50:34.010
of time you wait for
credit card swipe, yeah,

00:50:34.010 --> 00:50:37.340
we can do this in five
seconds, no problem.

00:50:37.340 --> 00:50:38.650
It's got flexible trust.

00:50:38.650 --> 00:50:43.380
You can have a small nonprofit,
like Stellar or the EFF,

00:50:43.380 --> 00:50:45.630
helping to keep the big banks
honest, even though they

00:50:45.630 --> 00:50:47.350
have many fewer resources.

00:50:47.350 --> 00:50:50.760
And it just depends on digital
signatures and hash functions.

00:50:50.760 --> 00:50:52.959
So you've got a standard
asymptotic security.

00:50:52.959 --> 00:50:54.750
You tell me how powerful
your adversary is,

00:50:54.750 --> 00:50:57.780
and I'll tell you whether to
choose a 256- or a 512-bit

00:50:57.780 --> 00:51:00.250
has function, how big your
signature keys should be,

00:51:00.250 --> 00:51:01.580
et cetera.

00:51:01.580 --> 00:51:05.250
And basically you can have
effectively zero chance

00:51:05.250 --> 00:51:07.690
of an adversary breaking it.

00:51:07.690 --> 00:51:09.931
Now, obviously, there's
a lot of related work.

00:51:09.931 --> 00:51:12.180
Standard Byzantine Agreement
provides the latter three

00:51:12.180 --> 00:51:14.190
properties, but it's
not decentralized.

00:51:14.190 --> 00:51:16.670
That's why it didn't
solve this problem.

00:51:16.670 --> 00:51:19.400
What did solve this
is proof of work.

00:51:19.400 --> 00:51:23.840
And we've seen how powerful that
is because of how much bitcoin

00:51:23.840 --> 00:51:24.564
has taken off.

00:51:24.564 --> 00:51:26.730
But bitcoin doesn't have
the other three properties.

00:51:26.730 --> 00:51:29.160
In bitcoin, you can't decide
you want to trust the EFF.

00:51:29.160 --> 00:51:32.869
You have to trust whoever
has the most hashing power.

00:51:32.869 --> 00:51:34.410
And then there's
also proof of stake,

00:51:34.410 --> 00:51:39.870
which is like a cross
between proof of work

00:51:39.870 --> 00:51:41.810
and Byzantine Agreement.

00:51:41.810 --> 00:51:43.900
But it's still,
there you're trusting

00:51:43.900 --> 00:51:47.280
the people who have the most
money, which is not necessarily

00:51:47.280 --> 00:51:50.140
the ACLU or whatever.

00:51:50.140 --> 00:51:52.630
So it's important to point
out that consensus is not

00:51:52.630 --> 00:51:54.260
the same thing as
a crypto currency.

00:51:54.260 --> 00:51:57.400
So SCP doesn't offer
some rate-limited way

00:51:57.400 --> 00:51:58.820
to mint new coins.

00:51:58.820 --> 00:52:01.930
It doesn't provide intrinsic
incentives for good behavior.

00:52:01.930 --> 00:52:03.930
We expect people are
participating in our system

00:52:03.930 --> 00:52:06.260
because they're financial
institutions that see value

00:52:06.260 --> 00:52:11.590
in having this global
financial network.

00:52:11.590 --> 00:52:12.970
But they don't
get paid to do it.

00:52:12.970 --> 00:52:15.625
They get paid because they're
making money as banks.

00:52:15.625 --> 00:52:17.250
It also doesn't tell
you whom to trust.

00:52:17.250 --> 00:52:20.970
So you could obviously configure
you quorum slices in a bad way

00:52:20.970 --> 00:52:24.310
and end up with an
insecure system.

00:52:24.310 --> 00:52:27.240
But that said, I think that
SCP has a bunch of applications

00:52:27.240 --> 00:52:28.610
beyond financial networks.

00:52:28.610 --> 00:52:32.820
And one of them that I want to
point out is CA accountability.

00:52:32.820 --> 00:52:34.760
So one problem is
that all our browsers,

00:52:34.760 --> 00:52:38.580
they ship with dozens and dozens
of root CAs, any one of which

00:52:38.580 --> 00:52:40.230
can sign certificates.

00:52:40.230 --> 00:52:44.850
True story, Turktrust went
and signed a bogus certificate

00:52:44.850 --> 00:52:47.840
for Google.com allowing
man-in-the-middle attacks.

00:52:47.840 --> 00:52:50.060
So people are trying to
address this through efforts

00:52:50.060 --> 00:52:52.059
like certificate transparency.

00:52:52.059 --> 00:52:53.600
But certificate
transparency requires

00:52:53.600 --> 00:52:57.580
you to trust a set
of logging agents who

00:52:57.580 --> 00:52:59.985
are going to output these
logs of certificates.

00:52:59.985 --> 00:53:02.360
And so you can actually increase
confidence in the system

00:53:02.360 --> 00:53:04.026
by having this be
more like a global log

00:53:04.026 --> 00:53:07.200
that the entire
internet signs off on.

00:53:07.200 --> 00:53:09.280
And that would make it
virtually impossible

00:53:09.280 --> 00:53:13.460
to roll back a certificate
that had been issued.

00:53:13.460 --> 00:53:16.140
So SCP could basically
increase confidence

00:53:16.140 --> 00:53:18.020
in the auditing process.

00:53:18.020 --> 00:53:21.157
Now Stellar is this
financial network

00:53:21.157 --> 00:53:22.240
that I've been mentioning.

00:53:22.240 --> 00:53:25.630
And, in fact, it is a
system that we've deployed.

00:53:25.630 --> 00:53:29.087
Our initial focus is in Nigeria
because the banking system

00:53:29.087 --> 00:53:30.170
there is a big pain point.

00:53:30.170 --> 00:53:32.840
There are many fewer people
with bank accounts there,

00:53:32.840 --> 00:53:36.236
and financial services
are much less smooth.

00:53:36.236 --> 00:53:38.110
A few months ago, we
integrated with Oradian,

00:53:38.110 --> 00:53:43.610
who's a vendor of software to
micro-finance institutions.

00:53:43.610 --> 00:53:47.310
And so that provided
access to about 200 or 300

00:53:47.310 --> 00:53:49.780
microfinance institutions
who can now send money

00:53:49.780 --> 00:53:52.780
over Stellar, or will
be able to soon as we

00:53:52.780 --> 00:53:56.057
get regulatory
approval for that.

00:53:56.057 --> 00:53:57.640
And finally, since
I know this is also

00:53:57.640 --> 00:54:01.351
going to be on YouTube where
some non-Googlers see it,

00:54:01.351 --> 00:54:02.850
I want to mention
that we're hiring.

00:54:02.850 --> 00:54:04.266
So if you like the
idea of working

00:54:04.266 --> 00:54:05.940
on cutting edge
distributed systems,

00:54:05.940 --> 00:54:08.080
please contact us at Stellar.

00:54:08.080 --> 00:54:10.580
We've got some cool-- everything
we're doing is open source.

00:54:10.580 --> 00:54:13.140
And it's pretty
interesting stuff.

00:54:16.770 --> 00:54:17.270
[APPLAUSE]

00:54:17.270 --> 00:54:19.269
FEMALE SPEAKER: Thank you
so much for joining us

00:54:19.269 --> 00:54:22.120
today and taking time out
of your busy schedule.

00:54:22.120 --> 00:54:25.310
I think we might have
just a few minutes.

00:54:25.310 --> 00:54:27.323
Does anybody in the
audience have any questions?

00:54:36.797 --> 00:54:38.380
AUDIENCE: Am I to
understand correctly

00:54:38.380 --> 00:54:40.550
that the slices are immutable?

00:54:40.550 --> 00:54:43.541
And if not, how do
they get reconfigured?

00:54:43.541 --> 00:54:45.290
DAVID MAZIERES: So
that's a good question.

00:54:45.290 --> 00:54:48.190
So in traditional Byzantine
Agreement systems,

00:54:48.190 --> 00:54:50.370
it turns out the
reconfiguration is a big pain.

00:54:50.370 --> 00:54:53.170
And sometimes you have to feed
it back to the system itself.

00:54:53.170 --> 00:54:56.210
Turns out that that's the one
area that we get that for free.

00:54:56.210 --> 00:54:59.440
So you can unilaterally
change your quorum slice

00:54:59.440 --> 00:55:00.750
whenever you want.

00:55:00.750 --> 00:55:03.535
Now it's better if you do it
from one log entry to the next.

00:55:03.535 --> 00:55:05.160
In other words, if
you're in the middle

00:55:05.160 --> 00:55:07.490
of deciding on something,
you could change it

00:55:07.490 --> 00:55:09.810
before you move to
the next question

00:55:09.810 --> 00:55:10.900
that you're deciding on.

00:55:10.900 --> 00:55:14.490
But you can do it midstream.

00:55:14.490 --> 00:55:15.907
It's just in terms
of safety, it's

00:55:15.907 --> 00:55:17.406
a little bit weaker
because you have

00:55:17.406 --> 00:55:19.652
to treat it like the union
of all the configurations

00:55:19.652 --> 00:55:21.128
that you had.

00:55:26.630 --> 00:55:27.870
A question over there?

00:55:27.870 --> 00:55:28.470
Oh, sorry.

00:55:28.470 --> 00:55:32.650
AUDIENCE: [INAUDIBLE]
said the messages

00:55:32.650 --> 00:55:36.105
themselves contain the
definition of all your slices,

00:55:36.105 --> 00:55:36.605
essentially?

00:55:36.605 --> 00:55:38.146
DAVID MAZIERES:
Yeah, so they contain

00:55:38.146 --> 00:55:39.280
a cryptographic hash of it.

00:55:39.280 --> 00:55:41.500
And you have a big cache.

00:55:41.500 --> 00:55:45.871
And then if you don't have-- if
that hash is not in your cache,

00:55:45.871 --> 00:55:48.120
then you just-- there's a
separate side protocol where

00:55:48.120 --> 00:55:50.494
you say, please give me the
pre-image of this hash value.

00:55:50.494 --> 00:55:51.690
AUDIENCE: I see.

00:55:51.690 --> 00:55:57.650
And you guys-- who runs
the service that provides

00:55:57.650 --> 00:55:59.140
these pre-images, basically?

00:55:59.140 --> 00:56:00.840
DAVID MAZIERES: Oh, each node.

00:56:00.840 --> 00:56:04.050
So if I hear a message from
you, and it includes a hash,

00:56:04.050 --> 00:56:06.740
and I don't have that hash,
I just ask you for it.

00:56:06.740 --> 00:56:09.720
So I mean, effectively,
it's just an optimization.

00:56:09.720 --> 00:56:11.470
Conceptually, it
includes the whole thing.

00:56:11.470 --> 00:56:13.290
It's just it would
be of more bandwidth

00:56:13.290 --> 00:56:14.480
than we want to consume.

00:56:14.480 --> 00:56:15.975
AUDIENCE: Sort of
like public keys

00:56:15.975 --> 00:56:18.080
and [INAUDIBLE] in a sense.

00:56:18.080 --> 00:56:18.996
DAVID MAZIERES: Maybe.

00:56:26.902 --> 00:56:27.610
AUDIENCE: Thanks.

00:56:27.610 --> 00:56:29.234
This is a bit open
ended, but if you've

00:56:29.234 --> 00:56:31.286
given this talk to a
group of graph theorists,

00:56:31.286 --> 00:56:33.410
I was curious if you run
across some good analogies

00:56:33.410 --> 00:56:36.405
or other ways of describing
[INAUDIBLE] problems,

00:56:36.405 --> 00:56:38.030
about creating
[INAUDIBLE] or colorings

00:56:38.030 --> 00:56:39.870
or paths between subsets.

00:56:39.870 --> 00:56:41.660
Certainly following
along your explanation

00:56:41.660 --> 00:56:43.980
has been very helpful.

00:56:43.980 --> 00:56:45.590
DAVID MAZIERES: No, I haven't.

00:56:45.590 --> 00:56:47.900
And it would be interesting.

00:56:47.900 --> 00:56:51.250
I mean, one thing is we have--
the stellar core daemon,

00:56:51.250 --> 00:56:53.000
there's a command
line switch that

00:56:53.000 --> 00:56:57.570
lets you look at the health
of your quorum slices.

00:56:57.570 --> 00:56:59.650
And it can give you--
and it spits out

00:56:59.650 --> 00:57:02.540
a few examples of
failures that might

00:57:02.540 --> 00:57:06.030
undermine the system, just
to kind of give you a sense.

00:57:06.030 --> 00:57:09.080
But that mode is
actually-- I think

00:57:09.080 --> 00:57:10.670
it's like exponential time.

00:57:10.670 --> 00:57:16.000
So maybe there's actually
some better way of doing this.

00:57:16.000 --> 00:57:19.080
So it could be interesting
future work there.

00:57:24.792 --> 00:57:28.837
FEMALE SPEAKER: [INAUDIBLE]
concludes the talk for today.

00:57:28.837 --> 00:57:31.420
As mentioned earlier, it's going
to be on the YouTube channel.

00:57:31.420 --> 00:57:34.440
So feel free to check it out
and share with your friends

00:57:34.440 --> 00:57:35.030
and coworkers.

00:57:35.030 --> 00:57:35.630
All right.

00:57:35.630 --> 00:57:36.130
Great.

00:57:36.130 --> 00:57:36.630
Thank you.

00:57:36.630 --> 00:57:38.160
[APPLAUSE]

