WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.704
[MUSIC PLAYING]

00:00:05.556 --> 00:00:06.980
RICCARDO GOVONI: [INAUDIBLE].

00:00:06.980 --> 00:00:07.840
LYDIA FITZPATRICK: Are we ready?

00:00:07.840 --> 00:00:08.756
RICCARDO GOVONI: Yeah.

00:00:08.756 --> 00:00:10.160
LYDIA FITZPATRICK: Hi, everyone.

00:00:10.160 --> 00:00:12.160
Welcome to our talk on
the fact that no one

00:00:12.160 --> 00:00:14.340
likes crashing or janky apps.

00:00:14.340 --> 00:00:15.100
I'm Lydia.

00:00:15.100 --> 00:00:17.080
I'm a technical program
manager on Android.

00:00:17.080 --> 00:00:19.330
RICCARDO GOVONI: And I'm
Riccardo, engineering manager

00:00:19.330 --> 00:00:20.760
on Google Play.

00:00:20.760 --> 00:00:22.135
FERGUS HURLEY:
Hey, everyone, I'm

00:00:22.135 --> 00:00:24.700
Fergus, product manager
for Android vitals.

00:00:24.700 --> 00:00:27.800
Hands up here, who
likes one star ratings?

00:00:27.800 --> 00:00:30.370
OK, we got one person
who's in the wrong talk.

00:00:30.370 --> 00:00:34.990
I'm sorry, but the people who
don't like one star ratings

00:00:34.990 --> 00:00:36.220
are in the right place.

00:00:36.220 --> 00:00:38.950
So we're here to
tell you how you

00:00:38.950 --> 00:00:41.380
can engineer your app
for high performance

00:00:41.380 --> 00:00:45.370
with the new tools available
on Android and on Google Play.

00:00:47.475 --> 00:00:49.850
We're going to start off by
talking about why performance

00:00:49.850 --> 00:00:51.240
matters in general.

00:00:51.240 --> 00:00:53.900
And then we're going to
jump into the new initiative

00:00:53.900 --> 00:00:56.096
that we have around
Android vitals,

00:00:56.096 --> 00:00:58.595
and how we've simplified it for
you to be able to understand

00:00:58.595 --> 00:01:00.620
and take action
much easier by using

00:01:00.620 --> 00:01:02.460
the concept of bad behaviors.

00:01:02.460 --> 00:01:05.510
Then we're going to jump into
how you can detect and fix

00:01:05.510 --> 00:01:09.150
these issues most effectively to
be able to have successful app.

00:01:11.671 --> 00:01:12.170
Great.

00:01:12.170 --> 00:01:14.390
So for the people who want
to avoid those one star

00:01:14.390 --> 00:01:16.160
ratings, the number
one way you can

00:01:16.160 --> 00:01:19.850
do that is by focusing on
stability of your applications.

00:01:19.850 --> 00:01:21.920
We put Google's machine
learning to work

00:01:21.920 --> 00:01:24.649
to be able to figure out, what
are people talking about in one

00:01:24.649 --> 00:01:25.190
star ratings?

00:01:25.190 --> 00:01:28.250
And we found that 50%
of one star ratings

00:01:28.250 --> 00:01:32.960
are talking about
stability and bugs.

00:01:32.960 --> 00:01:34.860
Then, once you fix
those issues, how

00:01:34.860 --> 00:01:36.470
can you get to a five star app?

00:01:36.470 --> 00:01:39.110
What we found is that, if you
want to get to a five star app,

00:01:39.110 --> 00:01:42.575
focusing on design,
usability, and speed

00:01:42.575 --> 00:01:43.700
are the things that matter.

00:01:43.700 --> 00:01:47.330
Because 60% of five star reviews
are talking about those topics.

00:01:51.130 --> 00:01:53.670
But don't just take our
word for it, or more likely,

00:01:53.670 --> 00:01:56.010
Google's machine
learning words for it.

00:01:56.010 --> 00:01:58.941
You need to actually take
developers' words for it.

00:01:58.941 --> 00:02:01.440
The Busuu team, which has built
an amazing language-learning

00:02:01.440 --> 00:02:04.980
app found that, by
focusing on performance

00:02:04.980 --> 00:02:07.200
and making that a part
of their culture, they

00:02:07.200 --> 00:02:12.600
were able to increase their
star rating as a result.

00:02:12.600 --> 00:02:14.550
The Big Fish Games
team have even

00:02:14.550 --> 00:02:17.494
seen increases in retention
by focusing on performance.

00:02:22.340 --> 00:02:24.980
At Google, and specifically
within Android,

00:02:24.980 --> 00:02:27.170
we're obsessed with our
performance and device

00:02:27.170 --> 00:02:28.040
performance.

00:02:28.040 --> 00:02:30.890
We've been obsessing over this
for a number of years now.

00:02:30.890 --> 00:02:35.300
Back in 2012, we launched
Project Butter with Jellybean.

00:02:35.300 --> 00:02:39.260
Since then, we've launched
the Doze mode, Project Vulkan

00:02:39.260 --> 00:02:42.710
last year, and this year, a
bunch of new tools in Android

00:02:42.710 --> 00:02:46.730
O, and the ability for you
to be able to get insights

00:02:46.730 --> 00:02:49.340
with Android vitals.

00:02:49.340 --> 00:02:51.590
So what is Android vitals?

00:02:51.590 --> 00:02:53.940
You might have seen this in
the keynote earlier today.

00:02:53.940 --> 00:02:56.120
This is our new initiative
to be able to help

00:02:56.120 --> 00:02:58.460
you be able to gain deeper
insights into the performance

00:02:58.460 --> 00:03:02.880
of your application across
core performance metrics.

00:03:02.880 --> 00:03:04.700
The three that
we're starting with

00:03:04.700 --> 00:03:10.130
are stability, battery,
and render times.

00:03:10.130 --> 00:03:11.840
You'll see many more
come over the course

00:03:11.840 --> 00:03:14.030
of the next few
months, and we'll

00:03:14.030 --> 00:03:17.600
be able to give you
those insights on Android

00:03:17.600 --> 00:03:19.320
and on the Play console.

00:03:19.320 --> 00:03:21.980
So let's jump into the three
that we're launching today.

00:03:21.980 --> 00:03:23.810
First one is stability.

00:03:23.810 --> 00:03:26.399
So everyone knows that you
shouldn't have your app crash.

00:03:26.399 --> 00:03:28.690
People have been focused on
this for a number of years.

00:03:28.690 --> 00:03:31.400
And at crash analytics
have introduced the concept

00:03:31.400 --> 00:03:32.852
of crash-free users.

00:03:32.852 --> 00:03:34.310
Now in the Play
console, you can be

00:03:34.310 --> 00:03:38.240
able to see your user
rate and your crash rate.

00:03:38.240 --> 00:03:41.040
You can also be able
to see your ANR rate.

00:03:41.040 --> 00:03:42.600
And this is where your--

00:03:42.600 --> 00:03:45.740
ANR is a concept
on Android, which

00:03:45.740 --> 00:03:47.570
is Application Not Responding.

00:03:47.570 --> 00:03:50.060
That's when your app
appears frozen, and does not

00:03:50.060 --> 00:03:51.680
respond for five seconds.

00:03:56.340 --> 00:03:58.220
The next area is battery.

00:03:58.220 --> 00:04:02.210
So this is where we want you to
avoid using people's devices,

00:04:02.210 --> 00:04:05.230
and consuming their
battery inefficiently.

00:04:05.230 --> 00:04:09.920
So is where we want to avoid
using the radios, or using

00:04:09.920 --> 00:04:11.650
the CPU when you
shouldn't be, and you

00:04:11.650 --> 00:04:12.650
don't need to, actually.

00:04:16.339 --> 00:04:17.962
The next area is rendering.

00:04:17.962 --> 00:04:20.420
So this is where we want to be
able to help you understand,

00:04:20.420 --> 00:04:24.300
how can you provide a silky
smooth experience to your users

00:04:24.300 --> 00:04:26.660
so that they feel like your
app is smooth and fluid

00:04:26.660 --> 00:04:27.560
on their device.

00:04:27.560 --> 00:04:29.034
And we have two
metrics that we're

00:04:29.034 --> 00:04:30.950
going to introduce you
today that can actually

00:04:30.950 --> 00:04:33.350
help you be able to deeply
understand that area.

00:04:36.930 --> 00:04:39.750
So we're talking about three
major performance areas here.

00:04:39.750 --> 00:04:41.340
And within each
performance area,

00:04:41.340 --> 00:04:43.747
we're going to be
introducing two metrics.

00:04:43.747 --> 00:04:46.080
It's a lot of data to be able
to understand and consume,

00:04:46.080 --> 00:04:50.050
so we've simplified it to
this concept of bad behaviors.

00:04:50.050 --> 00:04:54.030
This is where we take your app,
and we study the performance

00:04:54.030 --> 00:04:55.890
data on it, and we
figure out, if you're

00:04:55.890 --> 00:04:59.540
in the bottom 25% of apps
according to that metric,

00:04:59.540 --> 00:05:03.240
we flag it to you
and say, hey, you

00:05:03.240 --> 00:05:05.250
need to improve in this area.

00:05:05.250 --> 00:05:06.460
Let's do a show of hands.

00:05:06.460 --> 00:05:09.300
So if-- let's say
5% of your users

00:05:09.300 --> 00:05:13.830
are experiencing that
50% of their frames

00:05:13.830 --> 00:05:15.770
are taking more than
16 frames per se--

00:05:15.770 --> 00:05:19.070
and 60 milliseconds to render on
the screen, is that a problem?

00:05:19.070 --> 00:05:21.950
Hands up if they think
that's a problem.

00:05:21.950 --> 00:05:22.961
OK, great.

00:05:22.961 --> 00:05:25.460
So lots of people agree that's
a problem, and lots of people

00:05:25.460 --> 00:05:26.876
don't agree that
that's a problem.

00:05:26.876 --> 00:05:29.480
Well, we will actually
tell you in the console

00:05:29.480 --> 00:05:32.450
when you've reached the boundary
of when that's a problem,

00:05:32.450 --> 00:05:33.980
and you're in the bottom 25%.

00:05:33.980 --> 00:05:36.420
Right now that's at
about 2% of users.

00:05:36.420 --> 00:05:40.220
Impacting-- experiencing that
rate will actually be flagged,

00:05:40.220 --> 00:05:43.010
and that is putting
you in the bottom 25%.

00:05:43.010 --> 00:05:45.890
So we're really trying to
simplify it there for you

00:05:45.890 --> 00:05:48.890
so you can be able to understand
where you are positioned

00:05:48.890 --> 00:05:52.710
according to the benchmark.

00:05:52.710 --> 00:05:53.960
So where do you see this data?

00:05:53.960 --> 00:05:56.480
You see this data in a
new top level navigation

00:05:56.480 --> 00:05:59.170
item in the Play console
called Android vitals.

00:05:59.170 --> 00:06:00.692
It's live right
now to all of you.

00:06:00.692 --> 00:06:02.150
And if you have
enough data, you'll

00:06:02.150 --> 00:06:04.880
see the insights that
I'm talking about,

00:06:04.880 --> 00:06:08.702
and that Riccardo is going to
tell you more about right now.

00:06:08.702 --> 00:06:10.160
RICCARDO GOVONI:
Thank you, Fergus.

00:06:10.160 --> 00:06:12.670
So as Fergus just said, we
just launched a new section

00:06:12.670 --> 00:06:16.450
in the Play console which
is called Android vitals.

00:06:16.450 --> 00:06:18.320
And it is available
to all of you today,

00:06:18.320 --> 00:06:20.420
and you can go and
check it out now.

00:06:20.420 --> 00:06:23.270
What it does, it
summarizes all the findings

00:06:23.270 --> 00:06:25.250
that we have about
your app performance

00:06:25.250 --> 00:06:27.560
across these three
domains that Fergus just

00:06:27.560 --> 00:06:31.610
mentioned-- stability,
battery, and rendering.

00:06:31.610 --> 00:06:34.780
It works out of the box
without any integration needed.

00:06:34.780 --> 00:06:36.290
Not is the case to add--

00:06:36.290 --> 00:06:38.990
nothing to add to your APK size.

00:06:38.990 --> 00:06:41.870
The data that you find there
is collected from millions

00:06:41.870 --> 00:06:44.400
of Android users that
have opted in to share

00:06:44.400 --> 00:06:47.870
diagnostic information with
Google to help all of you

00:06:47.870 --> 00:06:51.470
understand and improve
the quality of your apps.

00:06:51.470 --> 00:06:55.910
Android vitals also highlights
wherever, at any given time,

00:06:55.910 --> 00:06:59.090
there is a problem that
affects a significant fraction

00:06:59.090 --> 00:07:00.657
of your users.

00:07:00.657 --> 00:07:02.990
For example, you can see one
of the red marks over there

00:07:02.990 --> 00:07:05.365
to indicate that you should
be looking at your rendering,

00:07:05.365 --> 00:07:08.050
and understand if there
is an issue there.

00:07:08.050 --> 00:07:10.490
And so you can use these
as the first port of call

00:07:10.490 --> 00:07:14.019
to understand your
application performance.

00:07:14.019 --> 00:07:15.560
So we're going to
spend some time now

00:07:15.560 --> 00:07:18.180
to go into detail about
all these three domains--

00:07:18.180 --> 00:07:20.570
stability, battery,
and rendering.

00:07:20.570 --> 00:07:22.340
I'm going to start
with stability.

00:07:22.340 --> 00:07:26.090
Stability is about crashes
and ANR reports, Applications

00:07:26.090 --> 00:07:27.740
Not Responding.

00:07:27.740 --> 00:07:31.070
Until today, the
only way for an ANR

00:07:31.070 --> 00:07:33.830
or a crash to surface
in the Play console

00:07:33.830 --> 00:07:36.890
was if your users explicitly
acknowledge a dialogue

00:07:36.890 --> 00:07:40.220
on the phone for each ANR
and crash to be reported.

00:07:40.220 --> 00:07:41.870
And this obviously
tedious, and it

00:07:41.870 --> 00:07:45.590
led to low volume of
crash and ANR reports.

00:07:45.590 --> 00:07:48.440
So the first thing that we
have done with Android vitals,

00:07:48.440 --> 00:07:51.080
we have greatly
reduced user friction.

00:07:51.080 --> 00:07:53.720
As I mentioned, the
data that you find there

00:07:53.720 --> 00:07:55.610
comes from users
that had opted in

00:07:55.610 --> 00:07:58.040
to share diagnostic information.

00:07:58.040 --> 00:08:00.470
Opt in typically
happens only once

00:08:00.470 --> 00:08:02.690
when a person
activates a new phone,

00:08:02.690 --> 00:08:05.600
and that is a very
low friction gesture.

00:08:05.600 --> 00:08:07.580
So this means that
in the Play console,

00:08:07.580 --> 00:08:10.060
now you see over
100-fold coverage

00:08:10.060 --> 00:08:12.110
in the number of
reports, with the reports

00:08:12.110 --> 00:08:15.430
coming from users running
versions of Android as old

00:08:15.430 --> 00:08:16.580
as Jellybean.

00:08:16.580 --> 00:08:19.430
And this reaches 98%
of the Android devices

00:08:19.430 --> 00:08:21.374
that have Play
services installed.

00:08:23.980 --> 00:08:26.340
So let's start with
the first domain--

00:08:26.340 --> 00:08:27.600
stability.

00:08:27.600 --> 00:08:30.670
What are the bad behaviors
that we want to flag out there?

00:08:30.670 --> 00:08:32.799
Crashes and application
not responding,

00:08:32.799 --> 00:08:36.059
which is application freezes.

00:08:36.059 --> 00:08:38.850
For sure, you never really
want any user of your app

00:08:38.850 --> 00:08:40.480
to experience one of them.

00:08:40.480 --> 00:08:42.210
And so we define
these bad behaviors

00:08:42.210 --> 00:08:45.510
in terms of percentage of
users that are experiencing

00:08:45.510 --> 00:08:48.090
any of them in any given day.

00:08:48.090 --> 00:08:50.640
You may be familiar with
the equivalent metric

00:08:50.640 --> 00:08:52.800
that other crash reporting
tools have introduced,

00:08:52.800 --> 00:08:54.200
crash-free users.

00:08:54.200 --> 00:08:56.100
And so for the next
few minutes, I'm

00:08:56.100 --> 00:08:58.511
going to focus on
ANR specifically.

00:09:01.740 --> 00:09:02.630
What is an ANR?

00:09:02.630 --> 00:09:05.100
ANR means Application
Not Responding,

00:09:05.100 --> 00:09:07.680
and this happens when your
application freezes, and stop

00:09:07.680 --> 00:09:09.032
responding to user input.

00:09:09.032 --> 00:09:10.740
This could be because
you have a deadlock

00:09:10.740 --> 00:09:12.660
in your multithreaded
code, because you

00:09:12.660 --> 00:09:14.356
have a UI thread
which is too slow,

00:09:14.356 --> 00:09:16.230
or because you have
background receivers that

00:09:16.230 --> 00:09:20.560
do not complete within a
meaningful amount of time.

00:09:20.560 --> 00:09:23.580
ANRs are super disruptive
of the user experience,

00:09:23.580 --> 00:09:26.940
and therefore you should aim
to never have any of them.

00:09:26.940 --> 00:09:29.880
And because the application
is frozen during an ANR,

00:09:29.880 --> 00:09:31.920
it means that you cannot
typically used a crash

00:09:31.920 --> 00:09:34.620
reporting SDK to collect them.

00:09:34.620 --> 00:09:37.830
On the other side, the Android
platform tracks all of them

00:09:37.830 --> 00:09:39.117
automatically.

00:09:39.117 --> 00:09:41.450
So they're all available in
the Play console without you

00:09:41.450 --> 00:09:42.670
having to do anything at all.

00:09:46.480 --> 00:09:48.810
We just got today
Android vital section,

00:09:48.810 --> 00:09:52.940
and in there you will find a
tab which is called ANR Rate.

00:09:52.940 --> 00:09:56.390
Here you can see how many unique
users experience an application

00:09:56.390 --> 00:09:59.250
not responding when the app
was used on a given day,

00:09:59.250 --> 00:10:03.040
across versions,
device, and OS versions.

00:10:03.040 --> 00:10:05.940
And if the fraction of
the user is significant,

00:10:05.940 --> 00:10:08.640
you get a red highlight
to drive your attention

00:10:08.640 --> 00:10:10.770
so you can focus on the
most prominent issues

00:10:10.770 --> 00:10:12.560
and dive into the details.

00:10:12.560 --> 00:10:15.480
You can click the
related ANR section.

00:10:15.480 --> 00:10:17.700
And in there, you
arrive in the ANR

00:10:17.700 --> 00:10:21.250
and crashes section
of the Play console.

00:10:21.250 --> 00:10:24.530
Here, in addition to reviewing
your overall crash failure

00:10:24.530 --> 00:10:29.250
rate and ANR rate, you can
dive into each crash and ANR

00:10:29.250 --> 00:10:31.451
that has been detected
for your application.

00:10:34.680 --> 00:10:37.510
Android collects ANRs and
crashes almost immediately

00:10:37.510 --> 00:10:38.410
as they occur.

00:10:38.410 --> 00:10:40.720
So here, you find crashes
and ANRs that are typically

00:10:40.720 --> 00:10:43.356
a few minutes old, at most.

00:10:43.356 --> 00:10:44.980
There's a bunch of
little new features.

00:10:44.980 --> 00:10:47.800
For example, we highlight
when a given ANR

00:10:47.800 --> 00:10:50.440
has been introduced for
the first time in your most

00:10:50.440 --> 00:10:53.750
recent app version with those
little orange highlights

00:10:53.750 --> 00:10:56.920
to help you track the
quality of your last release.

00:10:56.920 --> 00:10:59.650
You also get to see the
number of unique users

00:10:59.650 --> 00:11:02.110
that have been affected
by that particular ANR

00:11:02.110 --> 00:11:04.980
so you can distinguish between
high volume issues that

00:11:04.980 --> 00:11:07.000
are affecting only
a handful of users,

00:11:07.000 --> 00:11:08.470
versus widespread
ones that might

00:11:08.470 --> 00:11:10.780
be affecting a significant
fraction of your user base.

00:11:13.610 --> 00:11:16.150
You can dive into the
details, and observe

00:11:16.150 --> 00:11:19.040
how the number of reports and
the number of affected users

00:11:19.040 --> 00:11:21.170
trends over time, and
how it breaks down

00:11:21.170 --> 00:11:25.640
across device versions,
OS version, app versions.

00:11:25.640 --> 00:11:27.950
And obviously, you also
get the full thread dump

00:11:27.950 --> 00:11:29.870
that captures the
application state

00:11:29.870 --> 00:11:31.700
at the time the ANR occurred.

00:11:31.700 --> 00:11:34.170
And for crashes, obviously
you get similar functionality

00:11:34.170 --> 00:11:36.500
where you get the stack
trace that was observed

00:11:36.500 --> 00:11:38.084
when the crash occurred.

00:11:38.084 --> 00:11:40.250
So I think this gives you
a pretty good information,

00:11:40.250 --> 00:11:43.220
visibility into what is
happening on your users' phone.

00:11:43.220 --> 00:11:47.960
The next step is to try and
reproduce and debug them.

00:11:47.960 --> 00:11:50.340
What I recommend is
the new Android Studio

00:11:50.340 --> 00:11:54.370
3.0 that has plenty of new
profiling capabilities.

00:11:54.370 --> 00:11:56.870
The new Android
profilers in Studio 3.0

00:11:56.870 --> 00:12:00.320
provide real time data
about your app CPU, memory,

00:12:00.320 --> 00:12:02.100
and network activity.

00:12:02.100 --> 00:12:03.740
And I think this is
a great next step

00:12:03.740 --> 00:12:06.470
to debug your ANRs,
because root [INAUDIBLE]

00:12:06.470 --> 00:12:10.190
them often lies in not taking
into proper consideration

00:12:10.190 --> 00:12:13.190
CPU intensive operation,
or blocking operations

00:12:13.190 --> 00:12:17.035
like fetching data
from the network.

00:12:17.035 --> 00:12:18.890
The CPU profiler, for
example, gives you

00:12:18.890 --> 00:12:23.480
a real time CPU usage for your
app process on a timeline.

00:12:23.480 --> 00:12:26.210
You can dive through
instrumented method traces,

00:12:26.210 --> 00:12:29.360
and understand which methods
in-- maybe in your UI thread

00:12:29.360 --> 00:12:34.010
are using up most of the
time, and become blocking.

00:12:34.010 --> 00:12:37.460
Similarly, the network profiler
display network activity

00:12:37.460 --> 00:12:40.030
on a timeline, showing
data that was sent,

00:12:40.030 --> 00:12:43.040
received, and
associated latencies.

00:12:43.040 --> 00:12:45.590
Again, you can use these to
understand if a slow network

00:12:45.590 --> 00:12:49.550
call is making your threat
blocks for a response,

00:12:49.550 --> 00:12:52.140
and because of an ANR this way.

00:12:52.140 --> 00:12:54.200
And as Steph showed
in the keynote before,

00:12:54.200 --> 00:12:55.997
it's very easy from
here to jump directly

00:12:55.997 --> 00:12:58.080
into the code that is
responsible for that network

00:12:58.080 --> 00:13:00.122
call.

00:13:00.122 --> 00:13:02.330
If you want to learn more
about the studio profilers,

00:13:02.330 --> 00:13:04.538
there's a great talk tomorrow
morning in Amphitheater

00:13:04.538 --> 00:13:07.220
that I encourage you
to go and attend to.

00:13:07.220 --> 00:13:12.640
OK, now we discussed how to
review how many ANRs you have,

00:13:12.640 --> 00:13:13.932
how to debug them.

00:13:13.932 --> 00:13:15.640
But the thing is, how
do you prevent them

00:13:15.640 --> 00:13:17.680
from happening in
the first place?

00:13:17.680 --> 00:13:19.900
Textbook recommendation,
Android 101 is,

00:13:19.900 --> 00:13:23.110
do not do blocking
operations in the UI thread.

00:13:23.110 --> 00:13:25.690
And use, for example,
a sync task instead.

00:13:25.690 --> 00:13:29.560
You can use StrictMode to catch
accidental disk or network

00:13:29.560 --> 00:13:33.190
access on the application
main thread as well.

00:13:33.190 --> 00:13:36.580
Another common case is when you
have a broadcast receiver that

00:13:36.580 --> 00:13:38.920
receives an intent, and
does not finish processing

00:13:38.920 --> 00:13:41.770
within a window of time,
which is around 10 seconds.

00:13:41.770 --> 00:13:43.660
Or your broadcast
receiver gets a sync,

00:13:43.660 --> 00:13:45.940
but you forgot to call
finish on the pending result

00:13:45.940 --> 00:13:47.400
that you get back.

00:13:47.400 --> 00:13:50.600
Again, this Android 101,
very simple examples.

00:13:50.600 --> 00:13:53.860
Most likely your code is much
more complicated than this.

00:13:53.860 --> 00:13:55.720
You may be using
queues, asynchronous

00:13:55.720 --> 00:13:59.440
operation, libraries
like Rx Java.

00:13:59.440 --> 00:14:00.940
The basics do not change.

00:14:00.940 --> 00:14:02.620
The same recommendations apply.

00:14:02.620 --> 00:14:04.939
Be mindful of
which threads are--

00:14:04.939 --> 00:14:07.480
on which thread the callback
for your asynchronous processing

00:14:07.480 --> 00:14:08.950
and dump executing on.

00:14:08.950 --> 00:14:10.900
Use semantics in
your coding practices

00:14:10.900 --> 00:14:13.870
that make sure that you don't
end up executing accidentally

00:14:13.870 --> 00:14:18.690
on UI threads when you
don't want, and so on.

00:14:18.690 --> 00:14:21.260
Finally, be mindful of
introducing deadlocks

00:14:21.260 --> 00:14:22.190
in your app.

00:14:22.190 --> 00:14:24.565
And be it because you go
and check the ANR trackes

00:14:24.565 --> 00:14:26.690
that you're collecting when
the device is connected

00:14:26.690 --> 00:14:29.330
to your PC when you're
doing debugging,

00:14:29.330 --> 00:14:32.300
or by downloading the tracing
from the Play console.

00:14:32.300 --> 00:14:34.190
You can easily spot
if, at any time,

00:14:34.190 --> 00:14:36.440
you have deadlocks by,
for example, looking

00:14:36.440 --> 00:14:39.530
when a given thread, like the
UI thread here, is locked,

00:14:39.530 --> 00:14:41.840
waiting for a background
one, and vice versa.

00:14:45.190 --> 00:14:47.490
So that's all I had
to cover about ANR.

00:14:47.490 --> 00:14:49.350
But a fundamental
question remains--

00:14:49.350 --> 00:14:50.780
how much do they matter?

00:14:50.780 --> 00:14:52.080
How much should you care?

00:14:52.080 --> 00:14:54.305
And the answer is, you
should really care a lot.

00:14:54.305 --> 00:14:58.350
We look at the apps that have a
high and low crash rates imply.

00:14:58.350 --> 00:15:03.030
High crash rate-- more than 5%
of users experiencing a crash

00:15:03.030 --> 00:15:04.440
or in an hour per day.

00:15:04.440 --> 00:15:08.880
But what we find is that
these apps have 30% more

00:15:08.880 --> 00:15:11.350
uninstallation in the
first day than apps

00:15:11.350 --> 00:15:12.660
that have a low crash rate--

00:15:12.660 --> 00:15:14.110
less than 1%.

00:15:14.110 --> 00:15:16.090
So the message is
pretty simple--

00:15:16.090 --> 00:15:18.150
if your users find your
app and they experience

00:15:18.150 --> 00:15:21.662
a crash, most likely they will
leave as soon as they found it.

00:15:21.662 --> 00:15:25.950
I will now hand over to Lydia
for battery and rendering.

00:15:25.950 --> 00:15:27.870
LYDIA FITZPATRICK:
Thanks, Riccardo.

00:15:27.870 --> 00:15:30.580
Android users care a
lot about battery life.

00:15:30.580 --> 00:15:32.077
In fact, making
it through the day

00:15:32.077 --> 00:15:33.660
without needing to
charge their device

00:15:33.660 --> 00:15:36.439
is a top concern
for Android users.

00:15:36.439 --> 00:15:37.980
Because of this,
the Android platform

00:15:37.980 --> 00:15:41.040
has spent a lot of time building
features to save battery.

00:15:41.040 --> 00:15:44.040
One of the number one ways we
can conserve power and battery

00:15:44.040 --> 00:15:47.310
power is by putting the
device into a deep sleep when

00:15:47.310 --> 00:15:48.420
it's idle.

00:15:48.420 --> 00:15:51.090
This means powering
down the CPU, radio,

00:15:51.090 --> 00:15:54.510
and other components that
would otherwise drain power.

00:15:54.510 --> 00:15:57.270
However, you, as
application developers,

00:15:57.270 --> 00:16:00.210
can prevent the device
from going into deep sleep

00:16:00.210 --> 00:16:02.640
and conserving power.

00:16:02.640 --> 00:16:05.450
One of the ways you can do
this is through wake locks.

00:16:05.450 --> 00:16:07.530
Wake locks keep
the device awake so

00:16:07.530 --> 00:16:11.280
that it can perform an activity
on behalf of your application.

00:16:11.280 --> 00:16:13.620
There's a couple of different
types of wake locks.

00:16:13.620 --> 00:16:15.570
The first is a full wake lock.

00:16:15.570 --> 00:16:17.640
This keeps the screen on.

00:16:17.640 --> 00:16:21.090
And this is usually used by
a video app or a gaming app.

00:16:21.090 --> 00:16:22.890
Because the screen
is on, the user

00:16:22.890 --> 00:16:25.290
is going to be aware that
wake lock is being held,

00:16:25.290 --> 00:16:27.300
and in full control of
powering down the app

00:16:27.300 --> 00:16:28.929
and saving their battery.

00:16:28.929 --> 00:16:30.720
There's another kind
of wake clock, though.

00:16:30.720 --> 00:16:33.190
This is called a
partial wake lock.

00:16:33.190 --> 00:16:36.306
A partial wake lock
doesn't keep the screen on.

00:16:36.306 --> 00:16:37.680
Because of this,
the user doesn't

00:16:37.680 --> 00:16:39.960
know that the wake
lock is being held.

00:16:39.960 --> 00:16:42.720
And so, if a partial wake
lock is held for too long,

00:16:42.720 --> 00:16:46.740
it can become a silent and
deadly killer of battery power.

00:16:46.740 --> 00:16:48.570
Because of this, we
defined a bad behavior

00:16:48.570 --> 00:16:50.640
around stuck partial wake locks.

00:16:50.640 --> 00:16:52.770
We define a stuck
partial wake lock as one

00:16:52.770 --> 00:16:55.800
that's held for over an hour
by a significant percentage

00:16:55.800 --> 00:16:56.460
of your users.

00:16:59.970 --> 00:17:02.460
The Android vitals
dashboard will show you

00:17:02.460 --> 00:17:05.849
how you're using, and
possibly abusing, wake locks.

00:17:05.849 --> 00:17:07.349
It will show you
the distribution

00:17:07.349 --> 00:17:08.970
of how long wake
locks are being held

00:17:08.970 --> 00:17:11.099
by each version of your app.

00:17:11.099 --> 00:17:13.329
In this example, you
can see the majority

00:17:13.329 --> 00:17:15.780
of the wake locks are being
held for a minute or less,

00:17:15.780 --> 00:17:18.780
which is ideal from a
power saving perspective.

00:17:18.780 --> 00:17:20.670
However, there's a
long tail of wake locks

00:17:20.670 --> 00:17:22.829
that are being held
for over an hour, which

00:17:22.829 --> 00:17:25.920
meet our definition of bad
behavior, or stuck wake locks.

00:17:25.920 --> 00:17:27.630
And so you can see
that we flagged

00:17:27.630 --> 00:17:30.120
this app for this bad
behavior in the Android vitals

00:17:30.120 --> 00:17:31.138
dashboard.

00:17:34.730 --> 00:17:36.470
In the Android vitals
dashboard, we'll

00:17:36.470 --> 00:17:37.845
give you the
information you need

00:17:37.845 --> 00:17:40.130
to debug your stuck wake lock.

00:17:40.130 --> 00:17:43.130
Most importantly, the
name of the wake lock.

00:17:43.130 --> 00:17:44.270
In order to prevent--

00:17:44.270 --> 00:17:47.300
to protect user
privacy, we will only

00:17:47.300 --> 00:17:51.740
show wake lock names if it's
been used across many sessions.

00:17:51.740 --> 00:17:54.380
This will prevent the leaking
of any personally identifiable

00:17:54.380 --> 00:17:55.910
information.

00:17:55.910 --> 00:18:00.110
Because of this, I encourage
you to use standard wake lock

00:18:00.110 --> 00:18:03.020
names for each distinct wake
lock in your application

00:18:03.020 --> 00:18:04.790
in order for them to
be debuggable in case

00:18:04.790 --> 00:18:06.110
they become stuck wake locks.

00:18:09.800 --> 00:18:12.050
The reason that we're
highlighting stuck wake locks

00:18:12.050 --> 00:18:14.720
in the vitals dashboard is
because of just how dangerous

00:18:14.720 --> 00:18:16.310
they are.

00:18:16.310 --> 00:18:20.450
I mentioned in Android we care
a lot about conserving power.

00:18:20.450 --> 00:18:24.050
So every day, we collect reports
from internal Google users

00:18:24.050 --> 00:18:26.790
who have experienced
a bad battery day.

00:18:26.790 --> 00:18:29.504
A bad battery day is
one where your device--

00:18:29.504 --> 00:18:31.670
the battery doesn't last
as long as it usually does,

00:18:31.670 --> 00:18:33.320
or as long as you
expect it to do.

00:18:33.320 --> 00:18:35.480
So they'll send
us these reports.

00:18:35.480 --> 00:18:37.310
We did some analysis
across a two month

00:18:37.310 --> 00:18:39.320
period of all these
reports last summer,

00:18:39.320 --> 00:18:42.620
and we found that 30% of
these bad battery days

00:18:42.620 --> 00:18:45.080
were caused by stuck wake locks.

00:18:45.080 --> 00:18:48.890
I think this highlights really
how dangerous wake locks are.

00:18:48.890 --> 00:18:51.830
They cause real
problems for real users.

00:18:51.830 --> 00:18:52.670
Because of this.

00:18:52.670 --> 00:18:58.152
I encourage you to avoid
using wake locks entirely.

00:18:58.152 --> 00:19:00.610
Wake locks were introduced in
the early days of the Android

00:19:00.610 --> 00:19:01.660
platform.

00:19:01.660 --> 00:19:03.580
And since then, many
of the use cases

00:19:03.580 --> 00:19:05.350
for which you
needed a wake lock,

00:19:05.350 --> 00:19:07.370
you no longer need
a wake lock for.

00:19:07.370 --> 00:19:10.690
For example, if you're doing
a long-running download,

00:19:10.690 --> 00:19:13.480
you can use the Download
Manager instead.

00:19:13.480 --> 00:19:15.910
If you're synchronizing data
with an external server,

00:19:15.910 --> 00:19:18.250
use a Sync Adapter instead.

00:19:18.250 --> 00:19:22.950
If you need to run a background
task, use the Job Dispatcher.

00:19:22.950 --> 00:19:24.520
And if you're
holding a wake lock

00:19:24.520 --> 00:19:26.890
so that you can process an
intent before the device goes

00:19:26.890 --> 00:19:29.560
to sleep, use the new
Job Intent Services,

00:19:29.560 --> 00:19:32.830
which is being released in
the Support Lib V. 26 that's

00:19:32.830 --> 00:19:34.960
coming out later this quarter.

00:19:34.960 --> 00:19:38.200
Both Job Dispatcher and
the Job Intent Service

00:19:38.200 --> 00:19:40.600
are compatible with the
background restrictions

00:19:40.600 --> 00:19:42.580
that we're going to
be rolling out in On.

00:19:42.580 --> 00:19:43.450
So it's a win-win.

00:19:43.450 --> 00:19:45.970
You get a background check--
a background restrictions

00:19:45.970 --> 00:19:50.050
compatible service, and you
don't get any stuck wake locks.

00:19:50.050 --> 00:19:52.840
So definitely check
out Job Intent Services

00:19:52.840 --> 00:19:54.040
in Support Lib V. 26.

00:19:58.230 --> 00:20:00.460
If you're unable to use
any of these alternatives,

00:20:00.460 --> 00:20:03.210
and you need to use a wake
lock in your application,

00:20:03.210 --> 00:20:06.360
I'll rehash some of the
fundamentals from CS 101,

00:20:06.360 --> 00:20:08.170
because they're
just so dangerous.

00:20:08.170 --> 00:20:10.170
I'll spent some time rehashing.

00:20:10.170 --> 00:20:12.780
First is, keep the logic
around your wake lock extremely

00:20:12.780 --> 00:20:15.000
simple, because any
errors in the logic

00:20:15.000 --> 00:20:17.100
could lead to them
getting stuck.

00:20:17.100 --> 00:20:19.380
Second, try to do as little
as possible while you're

00:20:19.380 --> 00:20:21.270
holding this wake
lock so that it

00:20:21.270 --> 00:20:23.790
doesn't need to run
for an hour or more

00:20:23.790 --> 00:20:26.260
to do whatever operation
you're holding it for.

00:20:26.260 --> 00:20:29.010
And finally, use
defensive error handling.

00:20:29.010 --> 00:20:30.690
You can see in
this example here,

00:20:30.690 --> 00:20:33.370
if I hadn't defended
against my cleanup task

00:20:33.370 --> 00:20:36.240
throwing an exception, the
release method on my wake lock

00:20:36.240 --> 00:20:39.270
would never have gotten called,
and some poor user, or perhaps

00:20:39.270 --> 00:20:42.358
millions of users, would end
up with dead phone batteries.

00:20:46.660 --> 00:20:48.430
So if you follow all
my advice and are

00:20:48.430 --> 00:20:51.880
able to not use any wake
locks in your application,

00:20:51.880 --> 00:20:54.080
I still want you to go
check out the Android vitals

00:20:54.080 --> 00:20:56.680
dashboard for stuck wake
locks because it's possible

00:20:56.680 --> 00:20:58.750
that services you
depend on are using

00:20:58.750 --> 00:21:01.870
wake locks under the covers.

00:21:01.870 --> 00:21:04.600
For example, the network
location provider wake lock.

00:21:04.600 --> 00:21:06.940
In this case, it's used
by millions of apps

00:21:06.940 --> 00:21:08.950
to find a user's location.

00:21:08.950 --> 00:21:11.320
If you're using it
too aggressively,

00:21:11.320 --> 00:21:13.870
it could hold wake locks for
an extended period of time

00:21:13.870 --> 00:21:16.460
that become stuck, and
you get flagged for that.

00:21:16.460 --> 00:21:18.940
So in this case, you would
fix that suck wake lock

00:21:18.940 --> 00:21:21.676
by throttling back the amount of
calls you make to this service.

00:21:21.676 --> 00:21:23.050
So definitely
check out this tab,

00:21:23.050 --> 00:21:24.508
even if you're not
using wake lock,

00:21:24.508 --> 00:21:27.190
so you can tune how you use the
services under the covers that

00:21:27.190 --> 00:21:28.783
might be using wake locks.

00:21:31.960 --> 00:21:34.090
The second way you, as
an application developer,

00:21:34.090 --> 00:21:36.250
can prevent the phone from
going into a deep sleep

00:21:36.250 --> 00:21:39.940
and saving power for users is
through the use of wakeups.

00:21:39.940 --> 00:21:42.250
Wakeups are alarms
that you can fire

00:21:42.250 --> 00:21:44.320
outside the lifetime
of your application

00:21:44.320 --> 00:21:46.690
to wake the device up
to do some sort of task

00:21:46.690 --> 00:21:49.000
on behalf of your application.

00:21:49.000 --> 00:21:52.120
If you do this excessively, the
device won't be able to rest,

00:21:52.120 --> 00:21:53.950
and you'll end up
draining a lot of power.

00:21:53.950 --> 00:21:57.160
So we've identified a bad
behavior of excessive wakeups.

00:21:57.160 --> 00:21:59.830
We define frequent app
wakeups as a percentage

00:21:59.830 --> 00:22:02.830
of users who are impacted by
wakeups that occur more than 10

00:22:02.830 --> 00:22:03.620
times per hour.

00:22:07.990 --> 00:22:10.450
Just like wake locks,
you can get a full report

00:22:10.450 --> 00:22:13.360
on the wakeups that you're
using, or possibly abusing,

00:22:13.360 --> 00:22:14.921
in the vitals dashboard.

00:22:14.921 --> 00:22:16.420
And just like wake
locks, you'll see

00:22:16.420 --> 00:22:19.977
the distribution of the number
of wakeups across sessions.

00:22:19.977 --> 00:22:22.060
And you'll be able to see
the names of each wakeup

00:22:22.060 --> 00:22:25.020
so you can debug any
frequent wakeup issues.

00:22:25.020 --> 00:22:27.820
And just like wake locks,
we'll only show the wakeup name

00:22:27.820 --> 00:22:29.590
if it's seen across
a lot of sessions

00:22:29.590 --> 00:22:32.620
so that we don't leak
any personal identifying

00:22:32.620 --> 00:22:33.800
information.

00:22:33.800 --> 00:22:36.530
So again, be sure to use a
standard name for all wakeups.

00:22:41.440 --> 00:22:44.470
A lot of people use the
pattern of firing a wakeup

00:22:44.470 --> 00:22:46.900
to get the device awake,
and then holding a wake lock

00:22:46.900 --> 00:22:48.400
to keep the device
awake so that you

00:22:48.400 --> 00:22:50.620
can perform some sort of task.

00:22:50.620 --> 00:22:53.200
This is a double whammy
of possible bad behavior

00:22:53.200 --> 00:22:55.750
because you might be waking
up the device too frequently,

00:22:55.750 --> 00:22:58.220
and your wake lock that
you're holding may get stuck.

00:22:58.220 --> 00:23:00.010
So let's get rid
of both of these.

00:23:00.010 --> 00:23:03.280
A much better alternative
to wakeups and wake locks

00:23:03.280 --> 00:23:05.890
is a Firebase JobDispatcher.

00:23:05.890 --> 00:23:08.470
The Android platform itself
does have a job scheduler,

00:23:08.470 --> 00:23:11.530
but I encourage you to use the
Firebase JobDispatcher because

00:23:11.530 --> 00:23:14.440
of its backward compatibility.

00:23:14.440 --> 00:23:16.450
In the Firebase
JobDispatcher, you

00:23:16.450 --> 00:23:19.240
can set up a task to
run as a repeating task.

00:23:19.240 --> 00:23:22.480
For example, I can run
this every 30 minutes.

00:23:22.480 --> 00:23:24.820
Dialing back the frequency
that you're running the task

00:23:24.820 --> 00:23:26.566
is a first step to
save some power.

00:23:26.566 --> 00:23:28.690
So 30 minutes is certainly
better than running this

00:23:28.690 --> 00:23:30.250
every 5 minutes.

00:23:30.250 --> 00:23:32.800
However, you can also
constrain the job

00:23:32.800 --> 00:23:35.140
to run only when
it's on a charger.

00:23:35.140 --> 00:23:38.620
This is obviously the
ultimate battery saver

00:23:38.620 --> 00:23:42.550
because it wouldn't ever run
while the user's on battery.

00:23:42.550 --> 00:23:45.460
Here at Google, a lot of
our apps employ this method.

00:23:45.460 --> 00:23:48.220
For example, Play Store
will wait to update--

00:23:48.220 --> 00:23:50.739
auto-update apps until
you're on a charger.

00:23:50.739 --> 00:23:52.780
This is because we understand
a user would rather

00:23:52.780 --> 00:23:55.930
have a device that lasts
through the day than a latest

00:23:55.930 --> 00:23:57.610
update of some apps.

00:23:57.610 --> 00:24:00.430
So I encourage you to use
that same very critical lens

00:24:00.430 --> 00:24:02.460
when you're considering
scheduling jobs.

00:24:02.460 --> 00:24:04.630
See if it can wait until
the device is on a charger.

00:24:09.936 --> 00:24:11.810
The final bad behavior
we'll talk about today

00:24:11.810 --> 00:24:13.370
is render times.

00:24:13.370 --> 00:24:15.430
Render times measures
the amount of time

00:24:15.430 --> 00:24:17.360
a frame drawn by
your application

00:24:17.360 --> 00:24:20.870
takes to actually get rendered
on the screen hardware.

00:24:20.870 --> 00:24:23.884
Render time directly correlates
with how users perceive

00:24:23.884 --> 00:24:25.050
the performance of your app.

00:24:29.140 --> 00:24:32.420
Android devices render
at 60 frames per second.

00:24:32.420 --> 00:24:34.000
This is based on
the refresh rate

00:24:34.000 --> 00:24:37.360
that's available in the
screen hardware itself.

00:24:37.360 --> 00:24:40.150
If you do the math,
60 frames per second

00:24:40.150 --> 00:24:43.762
breaks down to having to render
a frame every 16 milliseconds.

00:24:43.762 --> 00:24:45.220
So as long as your
app is rendering

00:24:45.220 --> 00:24:47.620
a frame every 16
milliseconds, users

00:24:47.620 --> 00:24:50.530
will feel that your app is very
smooth, very fluid, and very

00:24:50.530 --> 00:24:51.670
pleasant to browse.

00:24:54.430 --> 00:24:57.040
If your frames take longer
than 16 milliseconds,

00:24:57.040 --> 00:25:01.660
even just 17 milliseconds,
it will get dropped.

00:25:01.660 --> 00:25:04.600
If you have a lot
of dropped frames,

00:25:04.600 --> 00:25:07.900
your application will feel
very stuttery, very jarring

00:25:07.900 --> 00:25:08.734
to users.

00:25:08.734 --> 00:25:10.900
So you want to minimize the
number of dropped frames

00:25:10.900 --> 00:25:11.983
that your application has.

00:25:16.030 --> 00:25:19.330
If you drop many frames in a
row, and you get to the point

00:25:19.330 --> 00:25:21.790
that it's been 700
milliseconds before you draw

00:25:21.790 --> 00:25:23.999
the next frame in
your application,

00:25:23.999 --> 00:25:25.540
this is the point
at which users will

00:25:25.540 --> 00:25:27.430
think your app is
unresponsive, and they'll

00:25:27.430 --> 00:25:29.860
begin to feel frustrated by it.

00:25:29.860 --> 00:25:32.219
You should aim to have
zero frames that take 700

00:25:32.219 --> 00:25:33.510
milliseconds or more to render.

00:25:37.250 --> 00:25:38.840
We've used both of
these thresholds

00:25:38.840 --> 00:25:41.280
to identify some bad behavior.

00:25:41.280 --> 00:25:42.770
The first is slow rendering.

00:25:42.770 --> 00:25:45.290
We define this bad
behavior as the percentage

00:25:45.290 --> 00:25:50.120
of users who experience more
than 50% dropped frames.

00:25:50.120 --> 00:25:53.090
The second bad rendering
behavior are frozen frames.

00:25:53.090 --> 00:25:55.430
We define this as the
percentage of users

00:25:55.430 --> 00:25:59.760
who experience more than 0.1%
of their frames being frozen.

00:26:04.080 --> 00:26:05.950
The Android vitals
dashboard reports

00:26:05.950 --> 00:26:08.590
on both of these metrics,
and will flag you

00:26:08.590 --> 00:26:12.850
if you're excessively slow in
rendering, or too many frozen

00:26:12.850 --> 00:26:14.200
frames.

00:26:14.200 --> 00:26:15.700
Just like wake
locks and wakeups,

00:26:15.700 --> 00:26:18.889
you can see the distribution
of wakeup-- of rendering times

00:26:18.889 --> 00:26:19.555
across sessions.

00:26:22.770 --> 00:26:25.270
And the dashboard will also
give you some other statistics

00:26:25.270 --> 00:26:28.270
that help you understand what
might be causing your rendering

00:26:28.270 --> 00:26:29.590
issues.

00:26:29.590 --> 00:26:33.130
For example, I can see a high
percentage of slow UI thread

00:26:33.130 --> 00:26:35.260
activity.

00:26:35.260 --> 00:26:37.210
This indicates to
me that I'm probably

00:26:37.210 --> 00:26:39.670
trying to do too much
work on the UI thread.

00:26:39.670 --> 00:26:41.860
So I should move
things like disk I/O,

00:26:41.860 --> 00:26:44.810
or network activity to
a background thread.

00:26:44.810 --> 00:26:46.810
These statistics, though,
are pretty high level,

00:26:46.810 --> 00:26:49.184
and they'll just hint at the
root cause of your rendering

00:26:49.184 --> 00:26:49.704
issues.

00:26:49.704 --> 00:26:52.120
To really understand what's
causing your rendering issues,

00:26:52.120 --> 00:26:55.420
you'll need to dive deeper.

00:26:55.420 --> 00:26:58.070
You can do this in three steps.

00:26:58.070 --> 00:27:00.490
The first step is to
instrument your app

00:27:00.490 --> 00:27:03.490
with the
FrameMetricsAggregator API.

00:27:03.490 --> 00:27:06.250
This API is built on the
FrameMetrics API that

00:27:06.250 --> 00:27:09.160
was released in Android Nougat.

00:27:09.160 --> 00:27:12.100
The FrameMetrics API collect
statistics about how long

00:27:12.100 --> 00:27:14.560
each frame takes to render.

00:27:14.560 --> 00:27:17.830
The FrameMetricsAggregator
API, as the name suggests,

00:27:17.830 --> 00:27:22.000
aggregates these statistics
across a series of activities

00:27:22.000 --> 00:27:25.060
that you define, and you define
the start and the endpoint

00:27:25.060 --> 00:27:26.600
of that collection.

00:27:26.600 --> 00:27:29.740
So you can collect
statistics about how long

00:27:29.740 --> 00:27:33.310
specific workflows in your
application take to render.

00:27:33.310 --> 00:27:35.560
Once you've done
this step, step two

00:27:35.560 --> 00:27:38.140
is to get this data
off the device,

00:27:38.140 --> 00:27:40.150
and upload it to the
cloud or your servers

00:27:40.150 --> 00:27:41.980
where you can then analyze it.

00:27:41.980 --> 00:27:45.070
You'll analyze it to find what
flows are rendering slowly

00:27:45.070 --> 00:27:48.310
for the majority of your users.

00:27:48.310 --> 00:27:49.840
From there, you
can move on to step

00:27:49.840 --> 00:27:52.840
three, which is getting
your device out, walking

00:27:52.840 --> 00:27:57.250
through those flows, all the
meanwhile recording a trace.

00:27:57.250 --> 00:27:59.140
Once you've reproduced
that slow rendering

00:27:59.140 --> 00:28:02.650
behavior or those frozen
frames, you can upload that

00:28:02.650 --> 00:28:05.590
trace into Systrace
which will tell you

00:28:05.590 --> 00:28:07.540
exactly what was going
on in your application

00:28:07.540 --> 00:28:09.130
when that slow
rendering occurred--

00:28:09.130 --> 00:28:11.320
and not just your application,
but what was going on

00:28:11.320 --> 00:28:12.760
in the system as well.

00:28:12.760 --> 00:28:14.260
From there, you can
figure out which

00:28:14.260 --> 00:28:16.900
specific code paths you need to
optimize to fix your rendering

00:28:16.900 --> 00:28:20.190
performance.

00:28:20.190 --> 00:28:23.670
I've just skimmed the surface of
the FrameMetricsAggregator API,

00:28:23.670 --> 00:28:25.140
as well as Systrace.

00:28:25.140 --> 00:28:26.850
Luckily, you have two
more opportunities

00:28:26.850 --> 00:28:28.530
to learn more about them.

00:28:28.530 --> 00:28:31.002
This evening, Tim Murray,
who's an expert on Systrace,

00:28:31.002 --> 00:28:32.460
will give a talk
on how you can use

00:28:32.460 --> 00:28:35.250
it to debug rendering issues.

00:28:35.250 --> 00:28:37.860
Tim has analyzed
over 1,000 traces,

00:28:37.860 --> 00:28:40.500
and is a true
expert in the field.

00:28:40.500 --> 00:28:44.220
On Friday, you can go learn
from Chris and Chet, the authors

00:28:44.220 --> 00:28:46.350
of the
FrameMetricsAggregator API

00:28:46.350 --> 00:28:48.390
about how you can use
it to really understand

00:28:48.390 --> 00:28:50.910
your application performance.

00:28:50.910 --> 00:28:53.970
And with that, I'll give
it back to Fergus to close.

00:28:53.970 --> 00:28:55.797
FERGUS HURLEY: Thanks very much.

00:28:55.797 --> 00:28:56.380
Thanks, Lydia.

00:28:59.411 --> 00:28:59.910
Great.

00:28:59.910 --> 00:29:02.370
So today we introduced
three performance areas.

00:29:02.370 --> 00:29:03.870
We have many other
performance areas

00:29:03.870 --> 00:29:05.040
that we're going
to be introducing,

00:29:05.040 --> 00:29:06.664
as I mentioned earlier,
over the course

00:29:06.664 --> 00:29:07.980
of the next couple of months--

00:29:07.980 --> 00:29:12.374
app startup time,
memory, and network use.

00:29:12.374 --> 00:29:14.040
For each one of these
performance areas,

00:29:14.040 --> 00:29:15.796
we're going to
introduce bad behaviors

00:29:15.796 --> 00:29:17.670
so it's really easy to
understand the metric,

00:29:17.670 --> 00:29:20.970
and how you're doing in that
metric compared to other apps.

00:29:24.540 --> 00:29:27.670
A lot of the tools we've talked
about, especially on the Play

00:29:27.670 --> 00:29:30.970
developer console side for
the Android vitals dashboard,

00:29:30.970 --> 00:29:33.580
aggregate over your whole APK.

00:29:33.580 --> 00:29:37.510
If you want to understand within
your APK specific performance

00:29:37.510 --> 00:29:42.040
areas, I'd encourage you to
use the Firebase Performance

00:29:42.040 --> 00:29:42.910
Monitoring tool.

00:29:42.910 --> 00:29:46.180
It was launched earlier today
at the developer keynote,

00:29:46.180 --> 00:29:48.370
and it enable you to be
able to instrument your app.

00:29:48.370 --> 00:29:50.960
Out of the box comes
network and startup time,

00:29:50.960 --> 00:29:53.830
but you'll also able to
use your own counters

00:29:53.830 --> 00:29:55.870
to be able to track
whatever you would like

00:29:55.870 --> 00:29:58.900
to track in your application.

00:29:58.900 --> 00:30:01.260
There's a talk on this that's
going to happen tomorrow,

00:30:01.260 --> 00:30:02.680
and I encourage
you all to attend

00:30:02.680 --> 00:30:05.890
that to learn more about how you
can be able to use the Firebase

00:30:05.890 --> 00:30:08.380
Performance Monitoring
SDK in your application

00:30:08.380 --> 00:30:11.930
to be able improve performance.

00:30:11.930 --> 00:30:13.600
So we covered a lot today.

00:30:13.600 --> 00:30:15.490
We covered why
performance matters.

00:30:15.490 --> 00:30:18.400
We covered Android vitals, and
introduced the new concepts

00:30:18.400 --> 00:30:21.030
around bad behaviors,
and the six performance--

00:30:21.030 --> 00:30:22.850
six bad behaviors.

00:30:22.850 --> 00:30:26.500
And again, those bad behaviors
are high ANR rate, high crash

00:30:26.500 --> 00:30:32.680
rate, excessive wakeups, stuck
wake locks, slow rendering,

00:30:32.680 --> 00:30:35.260
and frozen frames.

00:30:35.260 --> 00:30:37.275
We introduced the
Android vitals dashboards

00:30:37.275 --> 00:30:38.440
within the Play console.

00:30:38.440 --> 00:30:40.510
We talked about
the Android Studio

00:30:40.510 --> 00:30:43.435
3.0 profilers, and
the Android APIs

00:30:43.435 --> 00:30:44.560
that are available for you.

00:30:47.800 --> 00:30:50.490
So if you're not motivated
by all the things we talked

00:30:50.490 --> 00:30:52.385
about around
performance today, I

00:30:52.385 --> 00:30:53.760
encourage you to
come to our talk

00:30:53.760 --> 00:30:57.200
tomorrow where we can give you
a Buzzfeed-like talk on why

00:30:57.200 --> 00:30:58.860
should you care more
about performance

00:30:58.860 --> 00:31:01.840
with all the Play console
tools that we have available.

00:31:01.840 --> 00:31:04.110
So one of the things that
we're going to talk about

00:31:04.110 --> 00:31:06.630
in this talk is the
rewards that the Play Store

00:31:06.630 --> 00:31:10.380
is going to offer you for being
able to improve the performance

00:31:10.380 --> 00:31:12.227
of your application.

00:31:12.227 --> 00:31:13.810
We'll get more into
the details there.

00:31:13.810 --> 00:31:15.930
But we're going to
start using performance

00:31:15.930 --> 00:31:19.614
data in the promotability
within the store.

00:31:19.614 --> 00:31:21.780
Another reason why you
should care about performance

00:31:21.780 --> 00:31:24.270
is, we have 2 billion
users on Android right now.

00:31:24.270 --> 00:31:25.230
It's a lot of users.

00:31:25.230 --> 00:31:27.750
Lot of users using their
devices to make emergency calls.

00:31:27.750 --> 00:31:30.854
If you improve the battery
life of your device,

00:31:30.854 --> 00:31:33.270
and you're-- of the device
itself by improving the battery

00:31:33.270 --> 00:31:36.131
life of your app, then users'
device will last longer.

00:31:36.131 --> 00:31:38.380
They'll be able to make more
emergency calls, and be--

00:31:38.380 --> 00:31:40.838
you're basically, I'm going to
go out on a limb and say it,

00:31:40.838 --> 00:31:43.989
saving people's lives by
focusing on performance.

00:31:43.989 --> 00:31:45.030
RICCARDO GOVONI: [LAUGHS]

00:31:45.030 --> 00:31:45.570
FERGUS HURLEY: Great.

00:31:45.570 --> 00:31:47.987
Maybe stretching a little
there, but hopefully you get it.

00:31:47.987 --> 00:31:48.486
Great.

00:31:48.486 --> 00:31:49.780
Thank you very much, everyone.

00:31:49.780 --> 00:31:51.392
I really appreciate
joining today.

00:31:51.392 --> 00:31:55.730
[APPLAUSE]

00:31:55.730 --> 00:31:59.980
[MUSIC PLAYING]

