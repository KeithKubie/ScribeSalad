WEBVTT
Kind: captions
Language: en

00:00:00.686 --> 00:00:02.670
FLORIAN LOITSCH: So
hi, my name is Florian.

00:00:02.670 --> 00:00:05.660
And I'm working also in
the office in Denmark,

00:00:05.660 --> 00:00:07.890
and I'm going to present
asynchronous programming

00:00:07.890 --> 00:00:09.710
in Dart.

00:00:09.710 --> 00:00:12.490
So a small outline-- I will
start with an introduction,

00:00:12.490 --> 00:00:15.230
compare the asynchronous and
synchronous programming model,

00:00:15.230 --> 00:00:18.910
and remind you of how the
asynchronous primitives work

00:00:18.910 --> 00:00:20.340
in Dart.

00:00:20.340 --> 00:00:22.400
I will then spend a
little bit of time

00:00:22.400 --> 00:00:25.060
on this new, cool feature
they've introduced in 1.9,

00:00:25.060 --> 00:00:28.820
Async/Await, talk-- I have
a few slides on debugging--

00:00:28.820 --> 00:00:31.900
and then finish with a summary.

00:00:31.900 --> 00:00:34.370
So basically an introduction
of asynchronous programming

00:00:34.370 --> 00:00:37.470
versus synchronous programming
can be reduced to two words,

00:00:37.470 --> 00:00:41.710
basically wait or yield, so
basically wait or don't wait.

00:00:41.710 --> 00:00:46.670
And I will give a small example
of what I mean with that.

00:00:46.670 --> 00:00:48.570
Let's say, you
have a web server.

00:00:48.570 --> 00:00:50.057
And you get a request in.

00:00:50.057 --> 00:00:52.390
So if you're in a parallel
synchronous environment, what

00:00:52.390 --> 00:00:54.380
you can do is, you
spawn off a thread.

00:00:54.380 --> 00:00:56.170
Then you're handed a response.

00:00:56.170 --> 00:00:58.760
And at some point, when
you're done, you have a reply.

00:00:58.760 --> 00:01:01.350
And your return that response.

00:01:01.350 --> 00:01:03.535
Now, if you get a
second request in,

00:01:03.535 --> 00:01:04.910
you just do the
same thing again.

00:01:04.910 --> 00:01:06.290
You spawn off a thread.

00:01:06.290 --> 00:01:08.280
You handle the request.

00:01:08.280 --> 00:01:10.210
And then, at some point,
you have a response.

00:01:10.210 --> 00:01:12.600
And you do that for all
the requests that come in.

00:01:12.600 --> 00:01:14.915
And if you do that, you have
a nice parallel execution.

00:01:14.915 --> 00:01:16.720
You have, in this
case, five threads.

00:01:16.720 --> 00:01:18.280
And you just run them.

00:01:18.280 --> 00:01:21.880
It looks kind of
nice, busy, great.

00:01:21.880 --> 00:01:24.259
The problem with it is,
clearly, in the moment,

00:01:24.259 --> 00:01:25.300
you have multi-threading.

00:01:25.300 --> 00:01:28.750
So parallel execution,
you have race conditions.

00:01:28.750 --> 00:01:30.450
That's a classic problem.

00:01:30.450 --> 00:01:32.150
But it also is
that, it can also be

00:01:32.150 --> 00:01:34.270
the threads are
expensive, especially

00:01:34.270 --> 00:01:37.196
if you use system threads.

00:01:37.196 --> 00:01:38.820
You only have a
limited number of them,

00:01:38.820 --> 00:01:41.185
and it costs to put
them up and run them.

00:01:41.185 --> 00:01:43.720
And it's also an
inefficient use of threads.

00:01:43.720 --> 00:01:46.010
And the reason for that
is that, let's say, we

00:01:46.010 --> 00:01:47.800
have this thread running here.

00:01:47.800 --> 00:01:48.810
It looks very busy.

00:01:48.810 --> 00:01:50.630
It looks like it's
doing a lot of things.

00:01:50.630 --> 00:01:53.440
But really, what's happening
most of the time in reality

00:01:53.440 --> 00:01:54.892
is that you have system calls.

00:01:54.892 --> 00:01:56.350
And during the
system calls, you're

00:01:56.350 --> 00:01:57.516
just waiting for the system.

00:01:57.516 --> 00:01:59.162
You're actually
not doing anything.

00:01:59.162 --> 00:02:02.500
And in the end, your there is
just waiting for the system

00:02:02.500 --> 00:02:04.800
most of the time.

00:02:04.800 --> 00:02:07.780
So the asynchronous
program modeling return

00:02:07.780 --> 00:02:10.380
basically says, don't
wait, especially

00:02:10.380 --> 00:02:12.294
for these systems calls.

00:02:12.294 --> 00:02:13.210
We will call you back.

00:02:13.210 --> 00:02:14.930
So the system will
call you back.

00:02:14.930 --> 00:02:18.200
So if you go back to
these parallel tasks that

00:02:18.200 --> 00:02:21.700
are running in multiple threads,
the green and the blue ones

00:02:21.700 --> 00:02:23.910
here, in the parallel
synchronous model,

00:02:23.910 --> 00:02:24.920
you just had to threads.

00:02:24.920 --> 00:02:26.010
And they were waiting.

00:02:26.010 --> 00:02:29.160
Whereas, in the asynchronous
model, you're just one thread.

00:02:29.160 --> 00:02:31.090
And you run the same
tasks on the same thread.

00:02:31.090 --> 00:02:33.548
And you just basically, when
you're waiting for the system,

00:02:33.548 --> 00:02:36.880
you continue running another
task on the same thread.

00:02:36.880 --> 00:02:40.970
So even though, as you can
see, it's not as fast and true,

00:02:40.970 --> 00:02:43.582
because well, you sometimes
could run two things

00:02:43.582 --> 00:02:44.290
at the same time.

00:02:44.290 --> 00:02:47.250
But the thread makes
you basically wait

00:02:47.250 --> 00:02:48.930
for the other one to finish.

00:02:48.930 --> 00:02:50.994
In total, for one,
given that we only

00:02:50.994 --> 00:02:52.410
use one thread,
instead of two, we

00:02:52.410 --> 00:02:54.850
don't lose much time for that.

00:02:57.214 --> 00:02:58.880
The other thing that's
important to note

00:02:58.880 --> 00:03:01.340
is that there's a typically
asynchronous pattern,

00:03:01.340 --> 00:03:04.590
in the sense that when
you ask for something

00:03:04.590 --> 00:03:05.970
that takes a long
time-- so here,

00:03:05.970 --> 00:03:07.136
it's called doSomethingSlow.

00:03:10.170 --> 00:03:11.670
You give that
function a callback.

00:03:11.670 --> 00:03:14.394
So that when it's done,
it can call you back.

00:03:14.394 --> 00:03:16.810
And then, more importantly,
you go back to the event loop.

00:03:16.810 --> 00:03:20.110
So instead of waiting
for the thing to return,

00:03:20.110 --> 00:03:21.900
you just finish all your things.

00:03:21.900 --> 00:03:22.840
You return from Main.

00:03:22.840 --> 00:03:24.920
And then, only at some
point, the event loop

00:03:24.920 --> 00:03:28.480
will come back and call you.

00:03:28.480 --> 00:03:29.992
So this has a few properties.

00:03:29.992 --> 00:03:31.700
For one, it's a better
use of the thread.

00:03:31.700 --> 00:03:35.940
As I said, you use fewer threads
for the same number of tasks.

00:03:35.940 --> 00:03:37.060
It's a cooperative model.

00:03:37.060 --> 00:03:38.970
So on the same
threads, you're not

00:03:38.970 --> 00:03:42.340
going to have race conditions
if you do not yield.

00:03:42.340 --> 00:03:43.800
I mean, obviously,
once you yield,

00:03:43.800 --> 00:03:49.390
you let others do something
on your static variables.

00:03:49.390 --> 00:03:51.220
It's callback based.

00:03:51.220 --> 00:03:52.840
And there must be an event loop.

00:03:52.840 --> 00:03:54.820
And the interesting
part about the callback

00:03:54.820 --> 00:03:56.361
based and the event
loop is that this

00:03:56.361 --> 00:03:59.380
is something that fits very
well in UI-driven, event-driven

00:03:59.380 --> 00:04:00.269
programs.

00:04:00.269 --> 00:04:02.310
So there's a nice fit of
asynchronous programming

00:04:02.310 --> 00:04:04.890
and event-driven,
UI-driven programs.

00:04:04.890 --> 00:04:09.220
And that also means that
programs are more reactive.

00:04:09.220 --> 00:04:11.147
If you have UI on
one thread and you do

00:04:11.147 --> 00:04:12.980
asynchronous programming
on the same thread.

00:04:12.980 --> 00:04:14.680
Well, because you do
not wait and you do not

00:04:14.680 --> 00:04:16.200
block your threads,
your program actually

00:04:16.200 --> 00:04:18.420
can still do UI, while you
are waiting for the system

00:04:18.420 --> 00:04:20.700
and so on.

00:04:20.700 --> 00:04:22.980
So now this was the
small synchronous

00:04:22.980 --> 00:04:25.140
versus asynchronous programming.

00:04:25.140 --> 00:04:26.840
How does it work in Dart?

00:04:26.840 --> 00:04:29.350
From the beginning on, when
we designed the [INAUDIBLE]--

00:04:29.350 --> 00:04:31.766
and when we designed Dart, we
had asynchronous programming

00:04:31.766 --> 00:04:32.840
in mind.

00:04:32.840 --> 00:04:34.784
And there's a nice
library, dart colon async,

00:04:34.784 --> 00:04:35.950
has also lots of primitives.

00:04:35.950 --> 00:04:38.960
And I will show at least a few
[INAUDIBLE] in the next slides.

00:04:38.960 --> 00:04:42.080
And we also use these
asynchronous primitives

00:04:42.080 --> 00:04:42.890
all over the place.

00:04:42.890 --> 00:04:46.390
So dart io, dart convert,
html, and isolate, all of them

00:04:46.390 --> 00:04:49.290
consistently use the
primitives that we have.

00:04:49.290 --> 00:04:51.210
Even though, as I said,
HTML, for instance,

00:04:51.210 --> 00:04:53.090
is not really an
asynchronous programming,

00:04:53.090 --> 00:04:54.880
it's a UI, event-driven
programming model.

00:04:54.880 --> 00:04:56.710
But since they
fit so nicely, you

00:04:56.710 --> 00:05:01.460
have a consistent model that
fits just all over the place.

00:05:01.460 --> 00:05:04.626
So before I talk about the
futures and streams in general,

00:05:04.626 --> 00:05:06.000
I want to give
this small picture

00:05:06.000 --> 00:05:08.760
of these fundamental
types that you have.

00:05:08.760 --> 00:05:10.920
In general, you have
one single value.

00:05:10.920 --> 00:05:14.930
That's the single
synchronous case.

00:05:14.930 --> 00:05:16.550
Or you return multiple values.

00:05:16.550 --> 00:05:19.129
That's the interval case
in synchronous world.

00:05:19.129 --> 00:05:21.420
And then in the asynchronous
world, you have a duality.

00:05:21.420 --> 00:05:26.790
We have the features for single
values that are not there yet

00:05:26.790 --> 00:05:28.940
and streams for multiple values.

00:05:28.940 --> 00:05:33.070
So here's the future
from the dot colon async.

00:05:33.070 --> 00:05:35.430
So really, a future
just represents

00:05:35.430 --> 00:05:37.130
a value that isn't there yet.

00:05:37.130 --> 00:05:38.940
And the way to
interact with it, you

00:05:38.940 --> 00:05:42.460
have three basic functions
on it-- then, catchError,

00:05:42.460 --> 00:05:43.350
and whenComplete.

00:05:43.350 --> 00:05:46.019
All of them take a callback,
the callback that you execute

00:05:46.019 --> 00:05:47.060
once you have that value.

00:05:47.060 --> 00:05:48.970
And all of them also
return a future,

00:05:48.970 --> 00:05:50.840
which allows this
nice future chaining

00:05:50.840 --> 00:05:54.010
that we have seen earlier and
since beginning, basically,

00:05:54.010 --> 00:05:56.640
of Dart.

00:05:56.640 --> 00:05:59.180
Here's just a small example
where we create a file.

00:05:59.180 --> 00:06:02.180
So we instantiate a new
file, call create on it.

00:06:02.180 --> 00:06:03.890
Create, itself,
returns as a future,

00:06:03.890 --> 00:06:05.640
so we can do this
nice Dart chaining.

00:06:05.640 --> 00:06:06.960
We do that Dart then.

00:06:06.960 --> 00:06:08.840
We add the callback.

00:06:08.840 --> 00:06:11.130
We also get a future
back, which allows us

00:06:11.130 --> 00:06:13.820
Dart catchError on it,
which then-- depending on

00:06:13.820 --> 00:06:16.930
if we were able to create the
file or not-- prints created

00:06:16.930 --> 00:06:19.350
or couldn't create.

00:06:19.350 --> 00:06:23.837
Basic things-- we have had
that in Dart since 1.0.

00:06:23.837 --> 00:06:26.420
The stream, on the other hand,
it's the asynchronous interval.

00:06:26.420 --> 00:06:28.790
So as I said, we have the
duality between single value

00:06:28.790 --> 00:06:31.420
and multiple values.

00:06:31.420 --> 00:06:34.750
So the stream is the
Asynchronous Iterable.

00:06:34.750 --> 00:06:36.440
We have a sequence of values.

00:06:36.440 --> 00:06:39.210
And we have operations
to manipulate and filter

00:06:39.210 --> 00:06:42.129
those values, just the
same as in iterables.

00:06:42.129 --> 00:06:44.170
The main difference is
that iterables are pulled,

00:06:44.170 --> 00:06:45.642
and streams are pushed.

00:06:45.642 --> 00:06:47.100
And what I mean,
with that is that,

00:06:47.100 --> 00:06:49.547
when you have an iterable, in
order to get the next value,

00:06:49.547 --> 00:06:50.880
you really have to do something.

00:06:50.880 --> 00:06:53.060
You have to say, I
want to move to next.

00:06:53.060 --> 00:06:54.560
I want to get the current.

00:06:54.560 --> 00:06:57.350
So you are the one in control.

00:06:57.350 --> 00:07:00.250
Whereas, if you go for streams,
while here you have the stream

00:07:00.250 --> 00:07:03.350
element onClick, you cannot
say, give me the next value.

00:07:03.350 --> 00:07:06.070
You can say, yes, once you
have a value, give it to me.

00:07:06.070 --> 00:07:11.482
But it's the stream is going
to push the value to you.

00:07:11.482 --> 00:07:12.940
That is really the
main difference.

00:07:12.940 --> 00:07:14.845
Because if you now
look at the API--

00:07:14.845 --> 00:07:16.780
here is the iterable,
for instance.

00:07:16.780 --> 00:07:18.410
You have the
Iterator, map, where,

00:07:18.410 --> 00:07:20.460
first, forEach, sold
all the things that we

00:07:20.460 --> 00:07:21.930
love on these iterables.

00:07:21.930 --> 00:07:25.780
If you look at the stream
API, it's almost the same.

00:07:25.780 --> 00:07:30.384
We replaced Iterator with
a listen on the callback.

00:07:30.384 --> 00:07:31.800
But all the other
functions-- map,

00:07:31.800 --> 00:07:34.597
where, first and forEach--
they're all still there.

00:07:34.597 --> 00:07:36.430
Clearly, they cannot
return the same values,

00:07:36.430 --> 00:07:38.138
because they don't
have those values yet.

00:07:38.138 --> 00:07:41.140
So they need to go to
a futures and streams,

00:07:41.140 --> 00:07:43.440
in cases where we had
iterables and normal values.

00:07:43.440 --> 00:07:47.890
But really the duality between
an iterable and a stream.

00:07:47.890 --> 00:07:49.160
And this isn't really nice.

00:07:49.160 --> 00:07:51.490
Because when you go now
to this cool feature

00:07:51.490 --> 00:07:54.380
that we introduced
recently, Async/Await,

00:07:54.380 --> 00:07:57.750
the whole concepts
really emerge even more.

00:07:57.750 --> 00:08:01.260
And basically, when we
introduced Async/Await,

00:08:01.260 --> 00:08:04.000
the main purpose
behind Async/Await

00:08:04.000 --> 00:08:06.100
is to make it nice
and easy to program

00:08:06.100 --> 00:08:07.920
in asynchronous programs.

00:08:07.920 --> 00:08:11.520
And for that, the main
point is improve the syntax.

00:08:11.520 --> 00:08:14.530
We want to make it easier to
reason, write, read program

00:08:14.530 --> 00:08:16.420
of asynchronous programs.

00:08:16.420 --> 00:08:21.540
So let's go back to a small
example of web server in Dart,

00:08:21.540 --> 00:08:23.090
so no error handling here.

00:08:23.090 --> 00:08:26.380
The way it works in Dart,
we bind an HTTP server

00:08:26.380 --> 00:08:28.700
to a socket, locals host here.

00:08:28.700 --> 00:08:30.240
And that gives us a future back.

00:08:30.240 --> 00:08:33.230
And then we can basically
register our callback.

00:08:33.230 --> 00:08:36.221
We can then say, well, once
you have that callback, give me

00:08:36.221 --> 00:08:36.720
the server.

00:08:36.720 --> 00:08:40.200
I will then listen on all
the requests that come in.

00:08:40.200 --> 00:08:42.440
So server is clearly
a stream here.

00:08:42.440 --> 00:08:44.330
And then, again, we
pass in the callback,

00:08:44.330 --> 00:08:47.500
and we run-- we respond
to these things.

00:08:47.500 --> 00:08:49.670
And unfortunately, even
though we love these futures

00:08:49.670 --> 00:08:51.620
and streams, if we
had just done this

00:08:51.620 --> 00:08:54.129
in any other
callback-based language,

00:08:54.129 --> 00:08:55.670
it would have looked
almost the same.

00:08:55.670 --> 00:08:57.580
So instead of having the
.then, we would have pushed

00:08:57.580 --> 00:08:59.280
the callback directly
to the [INAUDIBLE].

00:08:59.280 --> 00:09:01.071
But really, it wouldn't
have changed a lot.

00:09:01.071 --> 00:09:03.200
So there are still
too many callbacks.

00:09:03.200 --> 00:09:04.580
We like the futures and streams.

00:09:04.580 --> 00:09:07.300
They're great, but there are
still too many callbacks.

00:09:07.300 --> 00:09:10.590
And what we would like
to have is something

00:09:10.590 --> 00:09:13.600
like this imaginary
synchronous zone where we say,

00:09:13.600 --> 00:09:15.574
bind this to the server.

00:09:15.574 --> 00:09:17.490
And once you're done,
give me the server back.

00:09:17.490 --> 00:09:20.000
And then I run through
all the requests,

00:09:20.000 --> 00:09:20.980
and I just handle them.

00:09:20.980 --> 00:09:23.560
And it just looks very nice,
synchronous, straightforward,

00:09:23.560 --> 00:09:25.800
straight-line code.

00:09:25.800 --> 00:09:27.800
And Async/Await kind
of tries to get there.

00:09:27.800 --> 00:09:30.290
It's Syntactic Sugar.

00:09:30.290 --> 00:09:31.920
You start with a
modify on the body,

00:09:31.920 --> 00:09:34.460
so that clearly means
it's function local.

00:09:34.460 --> 00:09:36.980
And we have explicit points
where we say, well here,

00:09:36.980 --> 00:09:37.850
we simulates.

00:09:37.850 --> 00:09:42.920
Or we do as if you had
written .then or listen.

00:09:42.920 --> 00:09:46.460
So let's go to the web
server that I showed before.

00:09:46.460 --> 00:09:47.210
It's the same.

00:09:47.210 --> 00:09:48.779
Nothing changed so far.

00:09:48.779 --> 00:09:50.820
The first thing we do in
order to use Async/Await

00:09:50.820 --> 00:09:54.310
is, as I said, we have
to have a modifier.

00:09:54.310 --> 00:09:56.710
So we add the async on the body.

00:09:56.710 --> 00:09:58.920
So this is really just
a modifier on the body.

00:09:58.920 --> 00:10:00.920
It doesn't change the
signature of the function.

00:10:00.920 --> 00:10:03.510
The function still behaves
the same as before.

00:10:03.510 --> 00:10:06.970
But once we have
this async modifier,

00:10:06.970 --> 00:10:08.290
we can use primitives.

00:10:08.290 --> 00:10:11.890
We can use asynchronous
syntax in the body.

00:10:11.890 --> 00:10:14.140
So in this case, for
instance, we can say,

00:10:14.140 --> 00:10:15.520
we do not want the .then.

00:10:15.520 --> 00:10:16.080
on the bind.

00:10:16.080 --> 00:10:19.964
We want to say, wait until it's
done, and then we continue.

00:10:19.964 --> 00:10:21.880
It looks like it's a
straight synchronous code

00:10:21.880 --> 00:10:22.546
we're actuating.

00:10:22.546 --> 00:10:24.952
But really this is
the same as before.

00:10:24.952 --> 00:10:25.910
We still do it a .then.

00:10:25.910 --> 00:10:28.320
It's just Syntactic
Sugar to get there.

00:10:28.320 --> 00:10:30.460
And then if we want to
get rid of to the listen,

00:10:30.460 --> 00:10:31.767
we also can use await.

00:10:31.767 --> 00:10:34.350
And we have a similar syntax as
before in the synchronous code

00:10:34.350 --> 00:10:35.380
in await for.

00:10:35.380 --> 00:10:38.950
So we take the server
stream and then

00:10:38.950 --> 00:10:42.920
run over all the
requests that's come in

00:10:42.920 --> 00:10:47.470
and execute to the
request handling.

00:10:47.470 --> 00:10:50.540
So this is really--
it's still pretty much

00:10:50.540 --> 00:10:52.322
the same code as
before in the sense

00:10:52.322 --> 00:10:53.530
that it's still asynchronous.

00:10:53.530 --> 00:10:54.840
It's still waiting.

00:10:54.840 --> 00:10:56.090
But it looks much, much nicer.

00:10:56.090 --> 00:10:58.381
It looks now like the straight
forward synchronous code

00:10:58.381 --> 00:11:00.840
that we wanted to have.

00:11:00.840 --> 00:11:05.530
So now a few of these
details-- so the first

00:11:05.530 --> 00:11:08.520
question, and it's a very
easy question to start with.

00:11:08.520 --> 00:11:12.691
What's the static
type of an await?

00:11:12.691 --> 00:11:13.940
Actually, it's pretty obvious.

00:11:13.940 --> 00:11:15.935
But again, it's the
easy one to start.

00:11:15.935 --> 00:11:18.060
If you have a future that
returns a list of string,

00:11:18.060 --> 00:11:18.650
for instance.

00:11:18.650 --> 00:11:20.180
And you use it with an await.

00:11:20.180 --> 00:11:22.330
Well, the static
type of his await

00:11:22.330 --> 00:11:26.150
is going to be a generic type of
that future, nothing surprising

00:11:26.150 --> 00:11:27.466
here.

00:11:27.466 --> 00:11:29.270
The next question,
a little bit more

00:11:29.270 --> 00:11:32.950
involved-- what happens if you
wait on a non-future value?

00:11:32.950 --> 00:11:35.940
And the way it works in Dart is
that we just make it a future.

00:11:35.940 --> 00:11:38.680
So if you do an await on
49, for instance, well,

00:11:38.680 --> 00:11:41.225
it becomes an await of a
new Future.value of 499.

00:11:41.225 --> 00:11:42.890
The same is true for null.

00:11:42.890 --> 00:11:46.279
We just basically wait.

00:11:46.279 --> 00:11:48.070
The other thing is--
does work on closures?

00:11:48.070 --> 00:11:48.740
Yes.

00:11:48.740 --> 00:11:50.980
So even if you use
the arrow braced

00:11:50.980 --> 00:11:53.980
or the normal curly
braced closures,

00:11:53.980 --> 00:11:55.190
you can just use async there.

00:11:55.190 --> 00:11:56.720
It just works the
same way as if you

00:11:56.720 --> 00:11:59.310
has a method, just the same.

00:11:59.310 --> 00:12:03.050
And finally, and that one is
actually quite interesting,

00:12:03.050 --> 00:12:04.700
the body of all
asynchronous functions

00:12:04.700 --> 00:12:07.850
is automatically wrapped
in a new Future.microtask.

00:12:07.850 --> 00:12:10.044
And that has several
consequences.

00:12:10.044 --> 00:12:11.460
So basically, if
you see an async,

00:12:11.460 --> 00:12:12.980
you have to
immediately think, this

00:12:12.980 --> 00:12:15.370
is as if I saw a new
Future.microtask.

00:12:15.370 --> 00:12:16.620
This has several consequences.

00:12:16.620 --> 00:12:19.080
One is, you will never have
a synchronous error out

00:12:19.080 --> 00:12:20.610
of an async function.

00:12:20.610 --> 00:12:22.380
Because you have a
new Future.microtask,

00:12:22.380 --> 00:12:25.110
that new Future.microtask will
capture all synchronous errors.

00:12:25.110 --> 00:12:28.756
And you will only get
errors back in the future.

00:12:28.756 --> 00:12:31.130
The other thing is that it
means that the function yields

00:12:31.130 --> 00:12:33.176
immediately when you call it.

00:12:33.176 --> 00:12:35.300
So it will go through the
event, before it actually

00:12:35.300 --> 00:12:36.711
executes the body.

00:12:36.711 --> 00:12:38.460
And then it also gives
us two nice answers

00:12:38.460 --> 00:12:42.272
for the questions of what
happens if you return

00:12:42.272 --> 00:12:43.480
a future and the return type.

00:12:43.480 --> 00:12:46.920
So if you return a future
inside the async body,

00:12:46.920 --> 00:12:48.800
well, it will just do
as if you returned it

00:12:48.800 --> 00:12:49.966
inside the Future.microtask.

00:12:49.966 --> 00:12:52.290
It will wait for the
inner future to complete,

00:12:52.290 --> 00:12:53.970
before it completes
the other one.

00:12:53.970 --> 00:12:57.020
So that basically
falls out of this.

00:12:57.020 --> 00:12:59.750
Similarly, the return
type of an async function

00:12:59.750 --> 00:13:01.220
is automatically a future.

00:13:01.220 --> 00:13:03.260
So if you see an
async on the body,

00:13:03.260 --> 00:13:06.460
it automatically means that
return must be a future.

00:13:06.460 --> 00:13:10.510
There's just no way
to get out of that.

00:13:10.510 --> 00:13:13.470
Yes, let's talk about
the star versions.

00:13:13.470 --> 00:13:16.940
So going back to this table
that we had before-- we

00:13:16.940 --> 00:13:19.100
have these four
different data types

00:13:19.100 --> 00:13:22.430
that you can return usually or
that are most important ones.

00:13:22.430 --> 00:13:24.640
And we always had
the return type

00:13:24.640 --> 00:13:26.080
where we can just
return a value.

00:13:26.080 --> 00:13:29.500
Now we just added a way to
return a future of a value.

00:13:29.500 --> 00:13:31.000
By just adding an
async to the body,

00:13:31.000 --> 00:13:34.400
now we can return a
future out of the body.

00:13:34.400 --> 00:13:37.080
And in this section, I
will show that we also

00:13:37.080 --> 00:13:39.270
have ways to return
a stream on iterable.

00:13:39.270 --> 00:13:43.000
So starting with the
iterable, to sync star

00:13:43.000 --> 00:13:45.680
is the way to return an
iterable from a function.

00:13:45.680 --> 00:13:49.534
So the moment you put a
sync star on the body,

00:13:49.534 --> 00:13:50.700
you will return an iterable.

00:13:50.700 --> 00:13:51.866
It's the same as for future.

00:13:51.866 --> 00:13:54.960
The moment you have it, you
get the return type as fixed.

00:13:54.960 --> 00:13:58.130
And sync star is
actually pretty simple.

00:13:58.130 --> 00:14:00.600
It allows you to basically
yield inside your body.

00:14:00.600 --> 00:14:03.590
And at the places
where you yield,

00:14:03.590 --> 00:14:08.240
you push or you put the
value in the iterable.

00:14:08.240 --> 00:14:09.860
This is done synchronously.

00:14:09.860 --> 00:14:13.435
So basically, once somebody
starts listening or starts

00:14:13.435 --> 00:14:15.950
iterating over your
iterable, it will

00:14:15.950 --> 00:14:18.830
start executing the function
until it reaches a yield.

00:14:18.830 --> 00:14:22.390
And then only the
caller that's called

00:14:22.390 --> 00:14:25.100
MoveNext will get the value.

00:14:25.100 --> 00:14:27.470
And in this example,
range 3, 6 does

00:14:27.470 --> 00:14:31.850
exactly what you expect
it to do-- 3, 4 5 and on.

00:14:31.850 --> 00:14:33.850
So what we added with
this sync star keyword

00:14:33.850 --> 00:14:35.520
is yield and yield star.

00:14:35.520 --> 00:14:37.450
So yield, I just showed,
is basically pushing.

00:14:37.450 --> 00:14:38.870
Or it's not really pushing.

00:14:38.870 --> 00:14:43.280
It's building the value,
giving the value to the caller.

00:14:43.280 --> 00:14:46.120
A yield star pipes through
a completely other iterable.

00:14:46.120 --> 00:14:49.480
So if we change
the range function

00:14:49.480 --> 00:14:53.490
from before to become
recursive, then we

00:14:53.490 --> 00:14:56.740
can yield one value of the
first and then recursively

00:14:56.740 --> 00:14:58.762
yield the remaining one.

00:14:58.762 --> 00:15:00.900
Yes, that's plus 1.

00:15:00.900 --> 00:15:02.860
And we can use yield
star to do that.

00:15:02.860 --> 00:15:04.570
And really, it just
takes the iterable

00:15:04.570 --> 00:15:08.855
that you got and pipes
it through to the caller.

00:15:08.855 --> 00:15:10.355
So that means that
we now have a way

00:15:10.355 --> 00:15:12.570
to return an iterable
from a function,

00:15:12.570 --> 00:15:15.730
just by adding a
modifier on the body.

00:15:15.730 --> 00:15:20.740
And with async star, we also
can do that for Streams.

00:15:20.740 --> 00:15:23.890
So once you put an async
star in the function body,

00:15:23.890 --> 00:15:26.180
you will return a Stream,
the same as for the futures

00:15:26.180 --> 00:15:28.530
and for the iterables.

00:15:28.530 --> 00:15:31.170
And we have the
same yield and yield

00:15:31.170 --> 00:15:33.010
star as we had for iterables.

00:15:33.010 --> 00:15:34.510
But we can also
now use the await.

00:15:34.510 --> 00:15:36.440
So in this example, we
have just a function

00:15:36.440 --> 00:15:39.560
that returns us the big files
of a list of file names.

00:15:39.560 --> 00:15:41.790
We run over these
file names one by one,

00:15:41.790 --> 00:15:44.955
open them, stat them, which
is an asynchronous operations.

00:15:44.955 --> 00:15:47.170
So it will take the system
a little bit of time

00:15:47.170 --> 00:15:48.550
to get that information.

00:15:48.550 --> 00:15:50.980
And then we just see if the
file is more than 100,000.

00:15:50.980 --> 00:15:53.550
And if it is, we push that
value into the Stream.

00:15:53.550 --> 00:15:56.000
So it's a basic,
straightforward loop,

00:15:56.000 --> 00:15:58.550
running over all the files.

00:15:58.550 --> 00:16:01.020
So since we are in
asynchronous setting,

00:16:01.020 --> 00:16:03.340
we have the await
and the await for.

00:16:03.340 --> 00:16:04.232
So that works nicely.

00:16:04.232 --> 00:16:05.940
And we also now have,
since are a stream,

00:16:05.940 --> 00:16:07.398
since we return
multiple values, we

00:16:07.398 --> 00:16:09.040
have now yield and yield star.

00:16:09.040 --> 00:16:10.730
So this is really
the culmination

00:16:10.730 --> 00:16:14.380
of all the modifiers together.

00:16:14.380 --> 00:16:17.190
So again, a few things
good to know-- it's

00:16:17.190 --> 00:16:20.470
not going to be as much
detail as to the future one.

00:16:20.470 --> 00:16:22.450
So one thing you
probably want to know

00:16:22.450 --> 00:16:25.930
is that both sync star
and async star functions

00:16:25.930 --> 00:16:30.480
are not started before anybody
is listening or iterating

00:16:30.480 --> 00:16:31.160
over them.

00:16:31.160 --> 00:16:33.030
So it really waits
until somebody actually

00:16:33.030 --> 00:16:34.304
needs the values.

00:16:34.304 --> 00:16:35.970
The other thing that's
important to know

00:16:35.970 --> 00:16:38.261
is that finallies are executed
if a stream is canceled.

00:16:38.261 --> 00:16:40.690
This gives you a way
to handle resources.

00:16:40.690 --> 00:16:43.640
So you can have a
resource handling,

00:16:43.640 --> 00:16:45.160
like opening files,
closing files

00:16:45.160 --> 00:16:47.510
in the finallies of a stream.

00:16:47.510 --> 00:16:52.880
And then just as an interesting
note, because we discussed it

00:16:52.880 --> 00:16:55.100
for a long time,
the yield eventually

00:16:55.100 --> 00:16:56.450
returns to an event loop.

00:16:56.450 --> 00:16:57.825
So in this example,
for instance,

00:16:57.825 --> 00:17:01.850
you have a while (true)
loop, which just yields 499.

00:17:01.850 --> 00:17:04.240
And you have different
semantics possible.

00:17:04.240 --> 00:17:08.099
One is to say, we just
continue running that loop

00:17:08.099 --> 00:17:09.710
and push the value
into some buffer.

00:17:09.710 --> 00:17:12.670
And eventually, you just die,
because you run out of memory.

00:17:12.670 --> 00:17:14.369
The other one is to
say, at every yield,

00:17:14.369 --> 00:17:16.744
we give somebody the
chance to react to it.

00:17:16.744 --> 00:17:18.910
Or the third one, which is
the one we haven't taught

00:17:18.910 --> 00:17:21.240
is to say, yes,
you can push it in.

00:17:21.240 --> 00:17:23.304
But eventually, we know
that it will yield.

00:17:23.304 --> 00:17:24.220
It can be immediately.

00:17:24.220 --> 00:17:26.160
It can take some time.

00:17:26.160 --> 00:17:28.009
It can buffer for some
time for efficiency.

00:17:28.009 --> 00:17:29.300
But eventually, you will yield.

00:17:29.300 --> 00:17:30.870
So basically what
that means-- you

00:17:30.870 --> 00:17:32.870
are allowed to write while
(true), often yields.

00:17:32.870 --> 00:17:35.620
And it will work.

00:17:35.620 --> 00:17:38.140
So this concludes the
four different sections

00:17:38.140 --> 00:17:39.530
of this table.

00:17:39.530 --> 00:17:42.540
And we have now ways to return
values, futures, iterables,

00:17:42.540 --> 00:17:47.600
and streams, just by adding
modifiers to your function.

00:17:47.600 --> 00:17:49.480
And with that, I will
talk a little bit more

00:17:49.480 --> 00:17:51.390
about debugging.

00:17:51.390 --> 00:17:54.300
As Lars said in
the previous talk,

00:17:54.300 --> 00:17:57.590
debugging in asynchronous
programs is really hard.

00:17:57.590 --> 00:18:01.000
There is clearly obviously
the interleaved execution.

00:18:01.000 --> 00:18:04.730
But more importantly the
stack frames are lost.

00:18:04.730 --> 00:18:06.162
And even though I
would have loved

00:18:06.162 --> 00:18:07.870
to basically be on
the stage now and say,

00:18:07.870 --> 00:18:09.750
yes, we have the great,
great solution here.

00:18:09.750 --> 00:18:11.690
And then everything is easy now.

00:18:11.690 --> 00:18:13.660
There's actually no
real silver bullet.

00:18:13.660 --> 00:18:15.920
We're working on making
things easier and better.

00:18:15.920 --> 00:18:20.010
As Lars said, we're trying to
make that much, much better.

00:18:20.010 --> 00:18:21.496
But I mean,
interleaved execution,

00:18:21.496 --> 00:18:22.620
there's nothing you can do.

00:18:22.620 --> 00:18:24.953
That's the whole point of
running asynchronous programs.

00:18:24.953 --> 00:18:28.000
You want to alternate
on your thread.

00:18:28.000 --> 00:18:30.150
And in stack frames,
it's really hard.

00:18:30.150 --> 00:18:35.390
But there are still ways to make
it much, much better right now.

00:18:35.390 --> 00:18:39.030
And that's what I want to
talk to in this section.

00:18:39.030 --> 00:18:43.620
Here, we have a typical example
of an asynchronous program.

00:18:43.620 --> 00:18:46.530
So it's just main calling
gee calling bar calling foo.

00:18:46.530 --> 00:18:49.350
And foo is doing some
asynchronous things

00:18:49.350 --> 00:18:52.040
and then having an error.

00:18:52.040 --> 00:18:55.100
So if we look at the stack
trace of this program,

00:18:55.100 --> 00:18:58.280
we will have long stack trace.

00:18:58.280 --> 00:19:00.699
But in the end, starting
looking at the stack trace,

00:19:00.699 --> 00:19:02.740
there's a lot of things
that we don't care about.

00:19:02.740 --> 00:19:05.787
So let's just clean it up
first and look at the stack

00:19:05.787 --> 00:19:07.870
once we've removed all the
internal frames that we

00:19:07.870 --> 00:19:10.367
actually don't want.

00:19:10.367 --> 00:19:12.450
And after the clean-up,
we're already at the point

00:19:12.450 --> 00:19:14.940
where we see, well,
There's one stack trace.

00:19:14.940 --> 00:19:17.230
Stack one frame, and it's foo.

00:19:17.230 --> 00:19:20.170
But it doesn't tell us
where this foo comes from,

00:19:20.170 --> 00:19:22.950
why-- basically, it
doesn't help us a all.

00:19:25.417 --> 00:19:27.250
What's interesting is,
all these [INAUDIBLE]

00:19:27.250 --> 00:19:30.140
noisy frames that you saw
before, the reason for them

00:19:30.140 --> 00:19:31.170
are zones.

00:19:31.170 --> 00:19:34.480
And these zones, while
they're noisy and annoying,

00:19:34.480 --> 00:19:36.980
and we'll try to make that
better in future versions,

00:19:36.980 --> 00:19:40.910
and they also help us to have
sophisticated hooks to track

00:19:40.910 --> 00:19:45.060
stack traces and to
other fancy stuff.

00:19:45.060 --> 00:19:48.040
I could do a full talk in
30 minutes easily on zones.

00:19:48.040 --> 00:19:49.770
So I will not go in
a lot of details.

00:19:49.770 --> 00:19:53.210
But if you wanted to-- if you
want to check the stack traces

00:19:53.210 --> 00:19:55.102
you want to have a
better debugging.

00:19:55.102 --> 00:19:57.560
What you will need to do is,
you create a zone description.

00:19:57.560 --> 00:19:59.990
Then you fork the zone
with that description.

00:19:59.990 --> 00:20:01.830
You intercept all
the synchronous calls

00:20:01.830 --> 00:20:03.626
in that zone description again.

00:20:03.626 --> 00:20:05.750
You wrap the targets and
start to trace information

00:20:05.750 --> 00:20:08.300
on them, so that when you come
back, you can find it again.

00:20:08.300 --> 00:20:10.110
And then you [INAUDIBLE]
information when come back.

00:20:10.110 --> 00:20:11.484
And basically,
what I want to say

00:20:11.484 --> 00:20:14.310
is that this is
extremely complicated.

00:20:14.310 --> 00:20:17.530
But fortunately for you,
Natalie on the Dart team

00:20:17.530 --> 00:20:19.460
actually implemented this.

00:20:19.460 --> 00:20:23.000
So it has a stack trace package
that is doing that for you.

00:20:23.000 --> 00:20:25.370
And this really helps a lot
in asynchronous programming.

00:20:25.370 --> 00:20:30.070
And the way this works
is-- so if you go back

00:20:30.070 --> 00:20:32.650
to the original program
that I had before.

00:20:32.650 --> 00:20:33.920
So this is nothing changed.

00:20:33.920 --> 00:20:36.712
The file just shifted
a little bit down.

00:20:36.712 --> 00:20:39.170
The only thing you need to do
to have an asynchronous stack

00:20:39.170 --> 00:20:42.050
trace is, you import
the stack trace package.

00:20:42.050 --> 00:20:44.770
And you call Chain.capture
on the function

00:20:44.770 --> 00:20:47.357
call where you want to get
the asynchronous stack trace.

00:20:47.357 --> 00:20:48.940
And what happens in
the background is,

00:20:48.940 --> 00:20:51.350
now it will do exactly what
I said before in the zones.

00:20:51.350 --> 00:20:54.650
It will register as
a zone description,

00:20:54.650 --> 00:20:56.730
intercept, all these
kind of things.

00:20:56.730 --> 00:21:00.475
And if look at the stack trace
now, it's not much better.

00:21:00.475 --> 00:21:03.460
But that's just-- if
you have sharp eyes,

00:21:03.460 --> 00:21:07.570
you will actually see that
down there, here, somewhere,

00:21:07.570 --> 00:21:09.380
there is a foo,
bar, and the gee,

00:21:09.380 --> 00:21:11.070
which is the one that we want.

00:21:11.070 --> 00:21:12.220
So we're not done yet.

00:21:12.220 --> 00:21:13.050
But it's close.

00:21:13.050 --> 00:21:16.660
So what you need to do now
is just have an onError,

00:21:16.660 --> 00:21:19.770
take the chain, and get
the terse version of it.

00:21:19.770 --> 00:21:21.460
It's already in the
stack trace package.

00:21:21.460 --> 00:21:22.480
It's already there.

00:21:22.480 --> 00:21:23.530
We just need to use it.

00:21:23.530 --> 00:21:26.350
And if we do with that,
then we get what we want.

00:21:26.350 --> 00:21:28.410
So I have pulled the
things that I care about.

00:21:28.410 --> 00:21:30.480
So that's not part of
the stack trace package.

00:21:30.480 --> 00:21:32.280
But we now have a main.

00:21:32.280 --> 00:21:33.560
We have the gee.

00:21:33.560 --> 00:21:34.344
We have the bar.

00:21:34.344 --> 00:21:35.010
We have the foo.

00:21:35.010 --> 00:21:37.650
We see that there are
asynchronous gaps to get there.

00:21:37.650 --> 00:21:40.319
We really have an idea of how
did we actually get there.

00:21:40.319 --> 00:21:41.360
And this is what we want.

00:21:41.360 --> 00:21:43.740
This is what we
need for debugging.

00:21:43.740 --> 00:21:46.870
And so what I recommend is-- if
you have asynchronous programs

00:21:46.870 --> 00:21:50.960
and you want to debug them, try
to use the stack trace package

00:21:50.960 --> 00:21:54.040
and see if that
doesn't help you.

00:21:54.040 --> 00:21:57.630
So with that, I'm going
to go to the summary.

00:21:57.630 --> 00:22:01.860
So really, what I
want you to take away

00:22:01.860 --> 00:22:03.950
from this talk is that
from the beginning on,

00:22:03.950 --> 00:22:07.390
we had Dart designed sign
for asynchronous programming.

00:22:07.390 --> 00:22:09.750
So there are a lot of
primitives and classes

00:22:09.750 --> 00:22:12.840
that have good semantics
that work nicely in Dart.

00:22:12.840 --> 00:22:15.720
And with Async/Await,
since 9.1, we also

00:22:15.720 --> 00:22:17.380
have the nice syntax
that goes with it.

00:22:17.380 --> 00:22:21.670
So not only do we have great
classes and [INAUDIBLE].

00:22:21.670 --> 00:22:24.170
We also have the syntax
to go with it not.

00:22:24.170 --> 00:22:26.700
And then, if you need
to debug, I strongly

00:22:26.700 --> 00:22:29.870
recommend to use the stack trace
package to help you figure out

00:22:29.870 --> 00:22:32.740
what's going on.

00:22:32.740 --> 00:22:36.470
Before I finish, I have
to give some credits.

00:22:36.470 --> 00:22:38.840
Really not much in
this talk is new.

00:22:38.840 --> 00:22:41.530
Almost everything
has been done before.

00:22:41.530 --> 00:22:44.950
Futures are actually
as old as 1976.

00:22:44.950 --> 00:22:47.410
At that time, they were
called promises, futures,

00:22:47.410 --> 00:22:48.460
or eventuals.

00:22:48.460 --> 00:22:51.440
So they have existed
in this world.

00:22:51.440 --> 00:22:53.000
They have existed
for a long time.

00:22:53.000 --> 00:22:55.790
And there are lots and lots
of JavaScript packages out.

00:22:55.790 --> 00:22:58.550
So again, this has
become popular recently.

00:22:58.550 --> 00:23:00.580
It's actually to
a point where they

00:23:00.580 --> 00:23:03.510
have a standard of how
do you need to interact,

00:23:03.510 --> 00:23:06.440
so that you can use
different promise packages,

00:23:06.440 --> 00:23:08.190
so that they can
interact with each other.

00:23:08.190 --> 00:23:10.480
So there's a standard
now specification

00:23:10.480 --> 00:23:13.800
of how your promise
package needs to behave.

00:23:13.800 --> 00:23:17.570
So there's a lot of future
and promise going on.

00:23:17.570 --> 00:23:19.450
The streams are
something we were heavily

00:23:19.450 --> 00:23:22.000
inspired by the Reactive
Extensions in Rx.

00:23:22.000 --> 00:23:25.710
So that too comes
from somewhere else.

00:23:25.710 --> 00:23:31.190
And the Async/Await has been
made popular by the .NET

00:23:31.190 --> 00:23:33.850
frameworking in version 4.5.

00:23:33.850 --> 00:23:36.420
And with that, I'm done.

00:23:36.420 --> 00:23:37.740
Thank you for listening.

00:23:37.740 --> 00:23:40.270
And I do think I do have a
few minutes of questions.

00:23:40.270 --> 00:23:41.650
SPEAKER 2: He does.

00:23:41.650 --> 00:23:44.869
If folks want to ask
questions, I can repeat them.

00:23:44.869 --> 00:23:47.410
And I do want to say too, along
with the debugging question--

00:23:47.410 --> 00:23:49.810
so the unit test package
and soon the test

00:23:49.810 --> 00:23:53.170
package, all those things run
using this stack trace thing.

00:23:53.170 --> 00:23:55.390
So actually, you'll notice
in your testing situation,

00:23:55.390 --> 00:23:57.270
your stack traces should
already look good,

00:23:57.270 --> 00:23:59.728
because we took care of it in
our testing packages for you.

00:23:59.728 --> 00:24:02.460
So again, if you see
Natalie, buy her a whiskey.

00:24:02.460 --> 00:24:03.920
She likes whiskey.

00:24:03.920 --> 00:24:06.780
Any questions?

00:24:06.780 --> 00:24:08.039
Yes, sir.

00:24:08.039 --> 00:24:11.951
AUDIENCE: So a wait for
is basically a syntax that

00:24:11.951 --> 00:24:13.907
are more streamed [INAUDIBLE].

00:24:13.907 --> 00:24:16.841
So it also returns a
stream subscription.

00:24:16.841 --> 00:24:18.308
How do we cancel a subscription?

00:24:18.308 --> 00:24:21.320
SPEAKER 2: OK, so
how does a wait

00:24:21.320 --> 00:24:23.280
for work with canceling
subscriptions?

00:24:23.280 --> 00:24:26.290
FLORIAN LOITSCH: So a
wait for automatically

00:24:26.290 --> 00:24:28.390
cancels the subscription
if you leave the loop.

00:24:28.390 --> 00:24:31.355
So there's a try catch basically
around it, a try finally,

00:24:31.355 --> 00:24:32.730
that makes sure
that if you leave

00:24:32.730 --> 00:24:35.250
the loop in a
non-standard way, we

00:24:35.250 --> 00:24:36.620
will cancel the subscription.

00:24:36.620 --> 00:24:38.995
SPEAKER 2: So people can use
break or throw an exception,

00:24:38.995 --> 00:24:39.900
and all that works.

00:24:39.900 --> 00:24:40.775
FLORIAN LOITSCH: Yes.

00:24:43.495 --> 00:24:45.130
SPEAKER 2: Way in the back.

00:24:45.130 --> 00:24:46.110
AUDIENCE: [INAUDIBLE]?

00:24:49.317 --> 00:24:51.150
FLORIAN LOITSCH: Is
there a performance cost

00:24:51.150 --> 00:24:52.430
in the stack trace package?

00:24:52.430 --> 00:24:53.980
Can you use it in
production code?

00:24:53.980 --> 00:24:55.500
There is a performance cost.

00:24:55.500 --> 00:24:59.610
It's basically intercepting
your asynchronous calls.

00:24:59.610 --> 00:25:02.830
Depending on how
often that happens

00:25:02.830 --> 00:25:05.524
or when you use
asynchronous calls,

00:25:05.524 --> 00:25:07.940
it might not matter that much,
because you're asynchronous

00:25:07.940 --> 00:25:08.440
anyway.

00:25:08.440 --> 00:25:09.820
So you're waiting for something.

00:25:09.820 --> 00:25:11.250
But there is an overhead.

00:25:11.250 --> 00:25:12.960
SPEAKER 3: I can
add some detail too.

00:25:12.960 --> 00:25:15.170
So we use the stack
trace package in pub.

00:25:15.170 --> 00:25:17.680
And the way we use it-- because
it's something that you're

00:25:17.680 --> 00:25:19.600
dynamically enabling.

00:25:19.600 --> 00:25:21.340
When you're running
pub normally,

00:25:21.340 --> 00:25:23.230
we just disable collecting
the stack chains,

00:25:23.230 --> 00:25:24.520
so that we don't
take a perf hit.

00:25:24.520 --> 00:25:26.210
And then if you run
pub in verbose mode,

00:25:26.210 --> 00:25:28.060
then we can just
dynamically turn it on.

00:25:28.060 --> 00:25:29.800
So you can just
give the end user

00:25:29.800 --> 00:25:31.950
the ability to control
that perf cost if you want.

00:25:31.950 --> 00:25:33.790
AUDIENCE: What's great is,
there's that one entry point,

00:25:33.790 --> 00:25:34.290
right.

00:25:34.290 --> 00:25:37.450
So if I don't wrap that top
level closure or that method

00:25:37.450 --> 00:25:40.652
with Chain.capture, if you
don't do that, you pay no cost.

00:25:40.652 --> 00:25:42.360
And so for instance,
in the test package,

00:25:42.360 --> 00:25:45.540
we do that wrapping, but normal
production code, generally not.

00:25:45.540 --> 00:25:47.010
FLORIAN LOITSCH:
I also want it add

00:25:47.010 --> 00:25:49.570
that, obviously, since you
capture the stack traces,

00:25:49.570 --> 00:25:51.220
you collect things.

00:25:51.220 --> 00:25:53.490
So you cannot really run
it in production forever.

00:25:53.490 --> 00:25:55.135
It will blow up.

00:25:55.135 --> 00:25:57.115
AUDIENCE: [INAUDIBLE]?

00:25:57.115 --> 00:26:00.600
FLORIAN KITSCH: Does it work
for [INAUDIBLE] JavaScript?

00:26:00.600 --> 00:26:02.060
I think there's
one outstanding--

00:26:02.060 --> 00:26:03.607
SPEAKER 3: That's
a Natalie question.

00:26:03.607 --> 00:26:05.190
And I don't know if
Natalie's in here.

00:26:05.190 --> 00:26:05.880
SPEAKER 2: We'll find
Natalie. and she'll

00:26:05.880 --> 00:26:06.780
be able to answer for you.

00:26:06.780 --> 00:26:08.870
FLORIAN LOITSCH: If not,
we should look at it.

00:26:11.492 --> 00:26:15.665
AUDIENCE: 30 seconds-- and
of course, if you haven't

00:26:15.665 --> 00:26:18.290
looked already, there's actually
been a number of refactorings.

00:26:18.290 --> 00:26:20.964
You can look at the pub source
code-- uses Async/Await a lot.

00:26:20.964 --> 00:26:22.255
We've done C other refactoring.

00:26:22.255 --> 00:26:23.630
SPEAKER 3: A little.

00:26:23.630 --> 00:26:24.960
SPEAKER 2: Or a lot.

00:26:24.960 --> 00:26:27.267
We're the first
customers, because they

00:26:27.267 --> 00:26:29.600
did a lot of I/O. So if you're
looking for examples talk

00:26:29.600 --> 00:26:29.930
to me.

00:26:29.930 --> 00:26:30.950
And there's a few of us.

00:26:30.950 --> 00:26:31.810
We can shoot you some code.

00:26:31.810 --> 00:26:33.640
The before and after
is just mind blowing.

00:26:33.640 --> 00:26:34.590
It's a really fun.

00:26:34.590 --> 00:26:36.340
And it makes the code
a lot more readable.

00:26:36.340 --> 00:26:37.780
So definitely take a look at it.

00:26:37.780 --> 00:26:38.530
And think you, Florian.

00:26:38.530 --> 00:26:39.654
FLORIAN LOITSCH: Thank you.

00:26:39.654 --> 00:26:42.650
[APPLAUSE]

