WEBVTT
Kind: captions
Language: en

00:00:00.500 --> 00:00:01.820
GREG KICK: Hi, I'm Greg Keck.

00:00:01.820 --> 00:00:06.540
I work at Google on the
Java core libraries team.

00:00:06.540 --> 00:00:10.000
We've brought you
such things as Guava,

00:00:10.000 --> 00:00:13.560
some contributions
to Guice, and full

00:00:13.560 --> 00:00:15.570
of other things, here
and there over the years.

00:00:15.570 --> 00:00:19.340
But most notably Guava.

00:00:19.340 --> 00:00:21.170
In the past, I worked
on Data Liberation,

00:00:21.170 --> 00:00:23.450
which people may or
may not have heard of.

00:00:23.450 --> 00:00:27.820
Takeout, in a former life I
wrote JavaScript for that.

00:00:27.820 --> 00:00:30.500
And now I am working on
dependency injection,

00:00:30.500 --> 00:00:35.760
and specifically not Guice, but
Dagger, and now the redesign

00:00:35.760 --> 00:00:37.850
Dagger 2.

00:00:37.850 --> 00:00:40.640
That's me, I want
to do a quick couple

00:00:40.640 --> 00:00:43.830
questions about you guys.

00:00:43.830 --> 00:00:46.240
When I say injection
raise your hand

00:00:46.240 --> 00:00:48.800
if you know what
I'm talking about.

00:00:48.800 --> 00:00:52.680
Good news, the first couple
slides will be real quick.

00:00:52.680 --> 00:00:55.710
And then, as we talk about
dependency injection,

00:00:55.710 --> 00:00:57.960
you know there's been many
frameworks over the years

00:00:57.960 --> 00:00:58.980
for getting that done.

00:00:58.980 --> 00:01:01.060
We have, for example Spring.

00:01:01.060 --> 00:01:03.650
Any spring users?

00:01:03.650 --> 00:01:07.230
All right, and some groans
for Spring, sorry Spring.

00:01:07.230 --> 00:01:10.140
How about Guice?

00:01:10.140 --> 00:01:12.950
OK, a few fewer.

00:01:12.950 --> 00:01:14.750
And then has anybody
had the opportunity

00:01:14.750 --> 00:01:17.790
to pick up Dagger 1?

00:01:17.790 --> 00:01:19.700
Very few.

00:01:19.700 --> 00:01:21.990
So it's good to keep in
mind, as we move along.

00:01:24.900 --> 00:01:26.744
Because of the
microphone situation,

00:01:26.744 --> 00:01:28.160
normally I would
say interrupt me,

00:01:28.160 --> 00:01:30.660
but I think we're doing some
recording, we've got some mics,

00:01:30.660 --> 00:01:32.980
there will be time
for Q&amp;A at the end.

00:01:32.980 --> 00:01:36.840
All right so let's get started.

00:01:36.840 --> 00:01:38.775
If the presentation works.

00:01:45.250 --> 00:01:48.020
Hey, almost.

00:01:48.020 --> 00:01:50.130
There we go, perfect.

00:01:50.130 --> 00:01:52.510
So like I said, I just
want to do a quick overview

00:01:52.510 --> 00:01:54.049
of what dependency injection is.

00:01:54.049 --> 00:01:55.840
Everybody seems to have
a pretty good idea,

00:01:55.840 --> 00:01:59.150
but let's just make sure we're
all started on the same page.

00:01:59.150 --> 00:02:01.770
Dependency injection is a
nice little design pattern

00:02:01.770 --> 00:02:04.960
for your Java classes,
and Java user group--

00:02:04.960 --> 00:02:07.640
we're going to talk about
Java whole way through.

00:02:07.640 --> 00:02:09.139
And on the left
over here, I have

00:02:09.139 --> 00:02:11.410
a simple fictitious CoffeeMaker.

00:02:11.410 --> 00:02:13.704
If we were going to model
a CoffeeMaker in Java.

00:02:13.704 --> 00:02:15.120
And we're going
to pretend like it

00:02:15.120 --> 00:02:17.580
has only a heater and a pump.

00:02:17.580 --> 00:02:20.150
And so in order to make
Coffee with my CoffeeMaker,

00:02:20.150 --> 00:02:22.630
I need a heater, in this
case an electric heater.

00:02:22.630 --> 00:02:25.820
I need a pump, in this
case of thermosiphon.

00:02:25.820 --> 00:02:27.430
And because a
thermosiphon requires

00:02:27.430 --> 00:02:30.760
heat, that's the thermo, we
give it the heater as well.

00:02:30.760 --> 00:02:34.430
And so my CoffeeMaker class has
a method called make Coffee,

00:02:34.430 --> 00:02:37.740
and if I were to write my
application from a main method,

00:02:37.740 --> 00:02:40.880
I would make a new CoffeeMaker
tell it to make Coffee.

00:02:40.880 --> 00:02:43.030
That's without
dependency injection.

00:02:43.030 --> 00:02:46.290
Everything that I need to
make Coffee in my CoffeeMaker,

00:02:46.290 --> 00:02:48.950
I instantiate myself
in the constructor.

00:02:48.950 --> 00:02:52.530
Dependency injection
takes the dependencies

00:02:52.530 --> 00:02:55.240
of that class, the things
that it needs to do its job,

00:02:55.240 --> 00:02:58.160
and has been passed in
rather than created yourself

00:02:58.160 --> 00:02:58.666
explicitly.

00:02:58.666 --> 00:03:00.790
And that's the highlight
portion over to the right.

00:03:00.790 --> 00:03:03.030
The constructor just
takes two parameter,

00:03:03.030 --> 00:03:05.380
sets them, and relies
on somebody else

00:03:05.380 --> 00:03:06.810
to give it its dependencies.

00:03:06.810 --> 00:03:09.670
Dependency injection, go figure.

00:03:09.670 --> 00:03:11.400
The main method down
there is the example

00:03:11.400 --> 00:03:13.140
of how that might be done.

00:03:13.140 --> 00:03:15.850
In order to make my CoffeeMaker,
I must first make my heater,

00:03:15.850 --> 00:03:19.280
must first make my pump, then
pass it to the CoffeeMaker

00:03:19.280 --> 00:03:20.551
to make Coffee.

00:03:20.551 --> 00:03:21.050
Great?

00:03:21.050 --> 00:03:22.780
Great.

00:03:22.780 --> 00:03:25.839
The reason we do this,
or at least the claims

00:03:25.839 --> 00:03:28.130
that I'm going to make for
the reasons that we do this,

00:03:28.130 --> 00:03:31.341
is you can do things like easily
swap in fakes for testing.

00:03:31.341 --> 00:03:33.590
If I'm going to write a unit
test for the CoffeeMaker,

00:03:33.590 --> 00:03:34.790
I could make a fake
heater rather than

00:03:34.790 --> 00:03:36.706
an actual electric heater,
because electricity

00:03:36.706 --> 00:03:38.370
is expensive.

00:03:38.370 --> 00:03:42.550
We can also easily reconfigure
these different types.

00:03:42.550 --> 00:03:44.080
If I, instead of
an electric heater,

00:03:44.080 --> 00:03:47.720
want to use some crazy
solar powered heater,

00:03:47.720 --> 00:03:50.050
then I can go ahead and do that.

00:03:50.050 --> 00:03:53.280
I could also kind of do
development a little easier

00:03:53.280 --> 00:03:54.050
in parallel.

00:03:54.050 --> 00:03:55.550
Somebody else can
work on the heater

00:03:55.550 --> 00:03:57.192
while I work on the CoffeeMaker.

00:03:57.192 --> 00:03:59.650
If they change the constructor
for the electric heater that

00:03:59.650 --> 00:04:03.292
doesn't affect my code,
which sounds great.

00:04:03.292 --> 00:04:05.500
And all that wiring that
happened in the main method,

00:04:05.500 --> 00:04:07.990
and I want to be explicitly
clear, we can do that wherever.

00:04:07.990 --> 00:04:11.610
People have come up with all
sorts of ways to get that done.

00:04:11.610 --> 00:04:13.210
The part that we
want to focus on,

00:04:13.210 --> 00:04:15.040
is passing the
parameters in rather

00:04:15.040 --> 00:04:17.329
than making them yourself.

00:04:17.329 --> 00:04:19.810
In pictures, this
looks like this.

00:04:19.810 --> 00:04:22.130
I have my CoffeeMaker, it
includes the thermosiphon,

00:04:22.130 --> 00:04:25.380
it includes the electric heater
with dependency injection.

00:04:25.380 --> 00:04:28.430
Take all those things apart,
and via the interfaces,

00:04:28.430 --> 00:04:30.139
I declare my dependencies.

00:04:30.139 --> 00:04:31.430
Everything's nice and separate.

00:04:34.110 --> 00:04:35.720
So what's the problem?

00:04:35.720 --> 00:04:40.130
Well for big applications,
for big non-coffee related

00:04:40.130 --> 00:04:44.610
applications, taking
all those dependencies,

00:04:44.610 --> 00:04:48.720
wiring them altogether, there
could be a ton of boilerplate.

00:04:48.720 --> 00:04:52.900
This is, ironically, part of
the implementation of Dagger 2.

00:04:52.900 --> 00:04:55.550
Because you can't you Dagger
2 in Dagger 2, go figure.

00:04:55.550 --> 00:04:57.400
So I have to do all
of this stuff by hand.

00:04:57.400 --> 00:05:00.690
This is just one tiny
little confusing snippet

00:05:00.690 --> 00:05:02.560
that I have to manage myself.

00:05:02.560 --> 00:05:04.000
It's a pain.

00:05:04.000 --> 00:05:08.370
The biggest portion of the pain
is that all of those things

00:05:08.370 --> 00:05:10.370
have to be in the correct order.

00:05:10.370 --> 00:05:12.060
Dependency request
factory has to come

00:05:12.060 --> 00:05:14.410
before provision binding
factory, because it requires

00:05:14.410 --> 00:05:16.710
a dependency request
factory, yeah blah blah blah.

00:05:16.710 --> 00:05:19.150
All the way down, it's
ugly, it's a nuisance,

00:05:19.150 --> 00:05:22.460
we don't want to have
to do that by hand.

00:05:22.460 --> 00:05:24.576
And some people say,
yeah that's true,

00:05:24.576 --> 00:05:25.700
but I can manage it myself.

00:05:25.700 --> 00:05:29.210
No really, I'm a great software
engineer, I've got this.

00:05:29.210 --> 00:05:31.730
As examples, we had
an Android application

00:05:31.730 --> 00:05:37.270
that had about 3,000 lines of
that, because they-- I looked,

00:05:37.270 --> 00:05:38.280
it was 3,000 lines.

00:05:38.280 --> 00:05:40.030
I checked before I
wrote the presentation.

00:05:40.030 --> 00:05:43.150
3,000 lines of exactly this.

00:05:43.150 --> 00:05:45.920
For a large server-side
app, it actually

00:05:45.920 --> 00:05:50.136
flushes out to be about 100,000
lines of exactly this code.

00:05:50.136 --> 00:05:51.510
It's depressing,
it's monotonous,

00:05:51.510 --> 00:05:55.304
we're going to try our best to
not have to do that by hand.

00:05:55.304 --> 00:05:57.095
The question is, how
do we get the benefits

00:05:57.095 --> 00:05:59.670
without the boilerplate?

00:05:59.670 --> 00:06:03.465
Well, we started back in
2002 with Spring 1 and 2.

00:06:03.465 --> 00:06:04.840
This is why I
asked about Spring,

00:06:04.840 --> 00:06:06.790
we love Spring back at that.

00:06:06.790 --> 00:06:08.430
It was revolutionary.

00:06:08.430 --> 00:06:10.996
It popularized dependency
injection, or inversion

00:06:10.996 --> 00:06:12.620
of control, or the
Hollywood principle,

00:06:12.620 --> 00:06:13.997
or what you want to call it.

00:06:13.997 --> 00:06:16.080
You had a way to declare
all of your dependencies,

00:06:16.080 --> 00:06:19.500
and it figured out that really
monotonous ordering for you.

00:06:19.500 --> 00:06:21.750
No matter of how you shifted
your dependencies around,

00:06:21.750 --> 00:06:23.999
it would always instantiate
things in the right order.

00:06:23.999 --> 00:06:27.000
Everybody was really
happy with that.

00:06:27.000 --> 00:06:30.150
And the best part, was
but all of the objects

00:06:30.150 --> 00:06:32.414
that you were doing,
you are manipulating,

00:06:32.414 --> 00:06:34.080
with your dependency
injection framework

00:06:34.080 --> 00:06:35.567
stayed exactly the same.

00:06:35.567 --> 00:06:38.150
Well that sounds like magic, how
did it stay exactly the same?

00:06:41.120 --> 00:06:41.710
It was XML.

00:06:41.710 --> 00:06:42.265
I'm sorry.

00:06:44.830 --> 00:06:46.150
It looked like that.

00:06:48.736 --> 00:06:52.620
It was cutting edge at the
time, let's not make fun.

00:06:52.620 --> 00:06:55.450
You would define
a beans.xml file,

00:06:55.450 --> 00:06:58.620
and you'd have little snippets
of XML here and there.

00:06:58.620 --> 00:07:00.550
But the things to
note, the good things,

00:07:00.550 --> 00:07:03.900
the things that we still
do today; it's declarative.

00:07:03.900 --> 00:07:06.030
There's no logic here,
there's no for loops,

00:07:06.030 --> 00:07:07.280
there's no anything like that.

00:07:07.280 --> 00:07:10.570
You say that I need to make a
CoffeeMaker, it takes a heater.

00:07:10.570 --> 00:07:13.120
Refer to the heater
that I've defined below.

00:07:13.120 --> 00:07:15.392
That heater, it's
an electric heater.

00:07:15.392 --> 00:07:16.850
That's the class
we want to use it.

00:07:16.850 --> 00:07:19.710
Also takes a pump, you
know, so on and so forth.

00:07:19.710 --> 00:07:22.770
And the point to
note specifically,

00:07:22.770 --> 00:07:25.032
is that those things do not
have to appear in order.

00:07:25.032 --> 00:07:26.740
That's the problem
we're trying to solve.

00:07:26.740 --> 00:07:28.614
We don't want to have
to constantly reshuffle

00:07:28.614 --> 00:07:30.540
every type of thing when
we swap a dependency.

00:07:30.540 --> 00:07:33.070
We don't want to have
to manually figure out

00:07:33.070 --> 00:07:35.840
the ordering of a
directed acyclic graph,

00:07:35.840 --> 00:07:38.925
for those of you that
love graph theory.

00:07:38.925 --> 00:07:40.300
And it ends up
looking like this.

00:07:40.300 --> 00:07:42.430
It's the exact same DI
picture, but now we've

00:07:42.430 --> 00:07:45.125
applied some XML to it.

00:07:45.125 --> 00:07:46.875
Where we used to have
a CoffeeMaker class,

00:07:46.875 --> 00:07:48.291
we've got this
little snippet that

00:07:48.291 --> 00:07:50.070
represents the CoffeeMaker.

00:07:50.070 --> 00:07:51.950
We have those constructor
our references.

00:07:51.950 --> 00:07:55.490
That's what gives
you your dependencies

00:07:55.490 --> 00:07:57.480
between all of those things.

00:07:57.480 --> 00:07:59.660
And the bean factory
is the Spring class

00:07:59.660 --> 00:08:02.650
that sort of wraps that all
up and does the work for you.

00:08:02.650 --> 00:08:04.610
Great.

00:08:04.610 --> 00:08:07.440
So like I said, solve
the ordering problem.

00:08:07.440 --> 00:08:11.140
It also solves instance
management and scoping.

00:08:11.140 --> 00:08:12.700
Feel free, if you're
curious to talk,

00:08:12.700 --> 00:08:14.550
or if you want to ask
about scoping later,

00:08:14.550 --> 00:08:17.070
it's kind of a complicated
topic we can Q&amp;A it later.

00:08:17.070 --> 00:08:19.300
But for the most part,
we'll just take it on faith

00:08:19.300 --> 00:08:21.330
But it does that.

00:08:21.330 --> 00:08:22.890
But there were issues.

00:08:22.890 --> 00:08:24.450
Possibly more issues
than solutions,

00:08:24.450 --> 00:08:26.560
as my completely
jaded bullet points

00:08:26.560 --> 00:08:29.560
might lead you to believe.

00:08:29.560 --> 00:08:30.930
XML is not so good.

00:08:30.930 --> 00:08:33.350
We don't like XML.

00:08:33.350 --> 00:08:36.340
And all of the validation
of that configuration file

00:08:36.340 --> 00:08:37.720
happened at runtime.

00:08:37.720 --> 00:08:40.350
If you made a typo
anywhere in one

00:08:40.350 --> 00:08:43.000
of the names of one of your
bean definitions, or bean

00:08:43.000 --> 00:08:45.420
references, you were going
to start up your server

00:08:45.420 --> 00:08:47.820
before you found out about it.

00:08:47.820 --> 00:08:51.330
Same thing with validating
the graph itself.

00:08:51.330 --> 00:08:54.154
Even if your configuration
file was great, at runtime

00:08:54.154 --> 00:08:55.570
we have to figure
out to make sure

00:08:55.570 --> 00:08:57.340
that all the dependencies
were satisfied.

00:08:57.340 --> 00:08:59.000
If you forgot to
constructor parameter,

00:08:59.000 --> 00:09:02.290
you can't make an object.

00:09:02.290 --> 00:09:06.520
It also had some issues with
tracing the application flow.

00:09:06.520 --> 00:09:09.220
Trying to swap back and
forth from Java to XML,

00:09:09.220 --> 00:09:11.060
and it was a mess.

00:09:11.060 --> 00:09:13.230
And a map-like API,
that we will talk about

00:09:13.230 --> 00:09:15.200
in just a little bit.

00:09:15.200 --> 00:09:17.350
So that was Spring.

00:09:17.350 --> 00:09:20.790
Guice came around
somewhere around 2006.

00:09:20.790 --> 00:09:24.870
I looked at the very first CL
for Guice, it was adorable.

00:09:24.870 --> 00:09:30.200
But all the way back
to the mid 2000s.

00:09:30.200 --> 00:09:35.400
And Java 1.5 had
just been released up

00:09:35.400 --> 00:09:37.380
and coming somewhere
around there.

00:09:37.380 --> 00:09:40.240
And Guice said, I can use
all of these new language

00:09:40.240 --> 00:09:43.010
features like
annotations and generics

00:09:43.010 --> 00:09:46.630
to start doing the things that
I used to have to do an XML,

00:09:46.630 --> 00:09:50.630
now I can do in Java
with the annotations

00:09:50.630 --> 00:09:52.220
that I have available.

00:09:52.220 --> 00:09:56.190
And what that did was it
decreased the configuration,

00:09:56.190 --> 00:09:58.410
and decentralized
the configuration.

00:09:58.410 --> 00:10:02.089
No more giant XML files,
and the annotations

00:10:02.089 --> 00:10:04.380
that defined your configuration
were close to the code.

00:10:04.380 --> 00:10:05.140
Great.

00:10:05.140 --> 00:10:08.810
And entirely written
and executed in Java.

00:10:08.810 --> 00:10:11.070
Quick informal poll,
how many people

00:10:11.070 --> 00:10:15.360
have installed the Spring
Eclipse plug-in that tells you

00:10:15.360 --> 00:10:18.241
how the XML relates to the Java?

00:10:18.241 --> 00:10:20.740
Yeah, there's like three people
because getting it installed

00:10:20.740 --> 00:10:24.170
was sort of a pain,
I don't blame you.

00:10:24.170 --> 00:10:27.850
So now we want to talk about,
where did all that XML go.

00:10:27.850 --> 00:10:31.010
How do you do this in Guice.

00:10:31.010 --> 00:10:31.850
Who can spot it?

00:10:31.850 --> 00:10:34.870
Who can spot the one little
bit of configuration?

00:10:34.870 --> 00:10:37.050
That looks remarkably
like the CoffeeMaker

00:10:37.050 --> 00:10:40.800
I started with, except that guy.

00:10:40.800 --> 00:10:43.300
It's barely any
configuration at all,

00:10:43.300 --> 00:10:45.880
but just applying one
annotation to that constructor

00:10:45.880 --> 00:10:49.070
says I now participate
in dependency injection.

00:10:49.070 --> 00:10:52.029
A little better
than angle brackets.

00:10:52.029 --> 00:10:54.320
We also have these things at
say how the objects relate

00:10:54.320 --> 00:10:56.420
to each other, how
abstract classes relate

00:10:56.420 --> 00:10:57.710
to concrete classes.

00:10:57.710 --> 00:11:00.470
And for that, we have a
little bit more work to do.

00:11:00.470 --> 00:11:02.850
The top is an example
of how you might do it

00:11:02.850 --> 00:11:07.260
with the Java API
using class literals,

00:11:07.260 --> 00:11:10.750
and the bottom defines how
you might do with a method.

00:11:10.750 --> 00:11:14.610
So in the top example, I want
to say that my heaters are all

00:11:14.610 --> 00:11:16.210
going to be electric heaters.

00:11:16.210 --> 00:11:19.140
In the bottom, I say
that I want pumps,

00:11:19.140 --> 00:11:22.120
and I'm going to use
thermosiphons for my pumps.

00:11:22.120 --> 00:11:26.060
And that's the,
again, 100% in Java,

00:11:26.060 --> 00:11:28.210
but expressing all
the same concepts

00:11:28.210 --> 00:11:33.770
that we saw in XML, but
now in just pure Java code.

00:11:33.770 --> 00:11:37.100
Back to our friendly graphic.

00:11:37.100 --> 00:11:39.730
We're kind of showing how
that all ends up working out,

00:11:39.730 --> 00:11:41.880
is the same CoffeeMaker
was now defined

00:11:41.880 --> 00:11:44.420
by that @inject constructor.

00:11:44.420 --> 00:11:46.240
So much easier than XML.

00:11:46.240 --> 00:11:50.270
We have that provides method
that defined the pump.

00:11:50.270 --> 00:11:51.700
We can take it on
faith that there

00:11:51.700 --> 00:11:55.600
were @inject constructors
for the thermosiphon.

00:11:55.600 --> 00:11:57.860
Guice actually has a nifty
little feature, where

00:11:57.860 --> 00:12:00.050
if you don't have an
@inject constructor,

00:12:00.050 --> 00:12:01.770
it will just assume
default constructors,

00:12:01.770 --> 00:12:04.350
work so the electric
heater gets to participate,

00:12:04.350 --> 00:12:05.780
and we have that binding.

00:12:05.780 --> 00:12:08.640
The exact same concepts,
just in a little bit

00:12:08.640 --> 00:12:11.370
different
configuration language.

00:12:11.370 --> 00:12:13.950
And rather than bean factory,
we wrap it all up and injector.

00:12:16.790 --> 00:12:19.730
The one last thing
I want to point out

00:12:19.730 --> 00:12:23.050
is that in the
Spring XML version,

00:12:23.050 --> 00:12:25.629
in order to find the heater, we
had to define two references.

00:12:25.629 --> 00:12:27.420
We had to say that the
CoffeeMaker depended

00:12:27.420 --> 00:12:29.240
on a heater, and
the thermosiphon

00:12:29.240 --> 00:12:30.420
depend on a heater.

00:12:30.420 --> 00:12:33.450
Now we have one
definition for the heater.

00:12:33.450 --> 00:12:37.690
We are making huge
strides towards collapsing

00:12:37.690 --> 00:12:39.179
our configuration language.

00:12:39.179 --> 00:12:40.595
If for example,
you had a database

00:12:40.595 --> 00:12:43.760
that you needed to access
from 10 different places

00:12:43.760 --> 00:12:45.490
in your application,
you get to bind it

00:12:45.490 --> 00:12:49.309
once instead of having a line
of XML for each of the 10 places

00:12:49.309 --> 00:12:50.350
you might need to use it.

00:12:53.170 --> 00:12:55.750
That said, you might
also want to note

00:12:55.750 --> 00:12:58.690
that there are two
ways that we bind

00:12:58.690 --> 00:13:00.310
abstract types to
concrete types.

00:13:00.310 --> 00:13:03.930
Or, in this case, interfaces
to concrete types.

00:13:03.930 --> 00:13:06.030
We don't generally prefer
two ways to do things,

00:13:06.030 --> 00:13:07.810
and that tended to get
a little confusing.

00:13:10.470 --> 00:13:13.170
But this all sounds
great, what's the problem.

00:13:13.170 --> 00:13:15.980
Why is juice not
our silver bullet?

00:13:15.980 --> 00:13:17.900
We still have a lot of
issues with runtime.

00:13:17.900 --> 00:13:19.300
Guice users, how
many people have

00:13:19.300 --> 00:13:22.810
seen stack traces
exactly like this?

00:13:22.810 --> 00:13:24.855
How many people found
them immediately helpful?

00:13:27.860 --> 00:13:30.125
For those of you in
video land it was zero.

00:13:33.240 --> 00:13:35.720
The problem is, it's the
same problem that Spring had.

00:13:35.720 --> 00:13:37.540
You have to start
up your application,

00:13:37.540 --> 00:13:41.260
or start up some integration
test, or something on the like,

00:13:41.260 --> 00:13:44.750
and you get this stack trace,
that all it's trying to express

00:13:44.750 --> 00:13:45.840
is you forgot a binding.

00:13:45.840 --> 00:13:50.372
You forgot, in this case,
a binding for the pump.

00:13:50.372 --> 00:13:52.330
What happens if you
declare data binding twice?

00:13:52.330 --> 00:13:56.470
An equally sort of convoluted
runtime stack trace

00:13:56.470 --> 00:14:01.030
that has a lot more noise
than we would probably prefer.

00:14:01.030 --> 00:14:03.690
And this has been long,
basically since day one,

00:14:03.690 --> 00:14:07.150
a source of frustration
for Guice users.

00:14:07.150 --> 00:14:08.950
Another question
might be, how do we

00:14:08.950 --> 00:14:10.445
debug a Guice application?

00:14:10.445 --> 00:14:11.820
We're creating
all these objects,

00:14:11.820 --> 00:14:14.130
what happens if we
turn on the debugger?

00:14:14.130 --> 00:14:17.100
The top example is what happened
when we did it manually.

00:14:17.100 --> 00:14:18.340
Read two stack frames.

00:14:18.340 --> 00:14:22.050
One was the main method, the
other one was the CoffeeMaker.

00:14:22.050 --> 00:14:27.037
In Guice land, the exact
same breakpoint becomes that.

00:14:27.037 --> 00:14:28.120
It's a little frustrating.

00:14:28.120 --> 00:14:29.745
There's a little more
to trace through.

00:14:29.745 --> 00:14:35.290
There's a big run time process
that you have to deal with.

00:14:35.290 --> 00:14:39.130
Or worse yet, if you
enable the wrong feature,

00:14:39.130 --> 00:14:41.740
you will just get breakpoints
that your debugger doesn't

00:14:41.740 --> 00:14:42.700
know how to deal with.

00:14:42.700 --> 00:14:44.630
You can't possibly
run a debugger

00:14:44.630 --> 00:14:48.260
against some of
these applications.

00:14:48.260 --> 00:14:50.810
And you get something
curious things

00:14:50.810 --> 00:14:53.280
in the middle of
those stack traces.

00:14:53.280 --> 00:14:58.400
CoffeeMaker$$EnhancerByGuice$$,
some hashCode,

00:14:58.400 --> 00:15:04.590
$$FastClassByGuice$$,
more garbage.

00:15:04.590 --> 00:15:08.530
That's not particularly
helpful in most cases.

00:15:08.530 --> 00:15:11.450
And if you try to go figure
out what that thing is,

00:15:11.450 --> 00:15:14.220
it's going to tell you source
not found over, and over,

00:15:14.220 --> 00:15:18.270
and over, and over again.

00:15:18.270 --> 00:15:20.560
Not the friendliest experience.

00:15:20.560 --> 00:15:22.890
But worst of all, and
this is the same problem

00:15:22.890 --> 00:15:27.330
that Spring had, the
code becomes untraceable.

00:15:27.330 --> 00:15:29.304
How do you know
which implementation

00:15:29.304 --> 00:15:30.470
of [INAUDIBLE] going to use?

00:15:30.470 --> 00:15:33.490
Now you have to go
track down a binding.

00:15:33.490 --> 00:15:35.520
Tracking down a
binding sort of feels

00:15:35.520 --> 00:15:39.010
like getting a big pile of
LEGOs, somebody saying, OK,

00:15:39.010 --> 00:15:41.860
there's a house, you figure
out how it was put together.

00:15:45.610 --> 00:15:48.390
It's a little
daunting sometimes.

00:15:48.390 --> 00:15:51.060
And if you tried
to do things like,

00:15:51.060 --> 00:15:52.642
well OK, Eclipse
has a feature where

00:15:52.642 --> 00:15:54.350
I say find all the
places that somebody's

00:15:54.350 --> 00:15:56.210
calling my constructor.

00:15:56.210 --> 00:15:58.420
In your Guice
centric application,

00:15:58.420 --> 00:16:00.581
there'll be exactly zero
places that somebody

00:16:00.581 --> 00:16:01.830
is calling it the constructor.

00:16:01.830 --> 00:16:03.880
Because it's all
done by reflection.

00:16:03.880 --> 00:16:05.630
So your normal
tools that you might

00:16:05.630 --> 00:16:07.520
use to traverse your code?

00:16:07.520 --> 00:16:11.070
Not so helpful anymore.

00:16:11.070 --> 00:16:17.230
And finally the configuration
we laid out in Java.

00:16:17.230 --> 00:16:21.490
It's dynamic, and it
can be conditional.

00:16:21.490 --> 00:16:23.280
In this case, this
is a snippet out

00:16:23.280 --> 00:16:25.420
one of those
configuration modules.

00:16:25.420 --> 00:16:28.780
And somebody did
something very earnest.

00:16:28.780 --> 00:16:31.524
They said OK, my application
under some conditions,

00:16:31.524 --> 00:16:33.190
I want a certain type
of authentication.

00:16:33.190 --> 00:16:35.148
Under other conditions,
I want a different type

00:16:35.148 --> 00:16:36.230
of authentication.

00:16:36.230 --> 00:16:38.960
So in the middle of my module, I
checked to see what a flag did,

00:16:38.960 --> 00:16:39.960
picked one of the other.

00:16:39.960 --> 00:16:43.100
That seems like a perfectly
reasonable thing to do.

00:16:43.100 --> 00:16:44.870
But back to the LEGO analogy.

00:16:44.870 --> 00:16:47.319
If you imagine that
big pile of LEGOs,

00:16:47.319 --> 00:16:49.360
and every time you try to
put that house together

00:16:49.360 --> 00:16:52.210
the instructions kept
changing, how easy might that

00:16:52.210 --> 00:16:55.500
be to figure out how
the pieces might fit.

00:16:55.500 --> 00:16:59.830
It can be frustrating,
to say the least.

00:16:59.830 --> 00:17:02.860
So given all that, we've
heard some good news

00:17:02.860 --> 00:17:03.960
and bad with Guice.

00:17:03.960 --> 00:17:05.712
We've got binding discovery.

00:17:05.712 --> 00:17:07.170
I could just find
those things that

00:17:07.170 --> 00:17:08.294
are annotated with @inject.

00:17:08.294 --> 00:17:11.400
They get to participate without
a lot of extra configuration.

00:17:11.400 --> 00:17:13.050
So we greatly reduce
the configuration.

00:17:13.050 --> 00:17:16.099
No duplication,
things like that.

00:17:16.099 --> 00:17:19.290
And that configuration all lives
right next to the Java code,

00:17:19.290 --> 00:17:22.339
we don't have to go to a
separate XML file to find it.

00:17:22.339 --> 00:17:25.067
We can just be right
there go take a look.

00:17:25.067 --> 00:17:26.150
And it's all in pure Java.

00:17:26.150 --> 00:17:27.960
All of these things sound great.

00:17:27.960 --> 00:17:31.140
And for that reason,
Guice has become--

00:17:31.140 --> 00:17:34.460
I can't think of an
exception-- Guice is almost

00:17:34.460 --> 00:17:38.020
certainly the most popular
framework that we have

00:17:38.020 --> 00:17:40.040
in Google applications for Java.

00:17:40.040 --> 00:17:41.740
It's used virtually everywhere.

00:17:41.740 --> 00:17:44.020
I mean hundreds and
thousands of classes

00:17:44.020 --> 00:17:45.900
are being managed with Guice.

00:17:45.900 --> 00:17:47.910
But it had issues.

00:17:47.910 --> 00:17:51.160
The runtime validation of
the graph, still a problem.

00:17:51.160 --> 00:17:54.120
Untraceable application
flow- pile of LEGOs-- still

00:17:54.120 --> 00:17:55.180
a problem.

00:17:55.180 --> 00:17:58.182
Synthetic classes that you
can't inspect, and have

00:17:58.182 --> 00:17:59.640
to go look at the
Guice source code

00:17:59.640 --> 00:18:01.880
even guess at what
they might be doing.

00:18:01.880 --> 00:18:02.950
Still a problem.

00:18:02.950 --> 00:18:05.530
And that map like API.

00:18:05.530 --> 00:18:09.110
So, Dagger 1 came along.

00:18:09.110 --> 00:18:13.500
Dagger 1 actually is not--
so, whereas Guice was a Google

00:18:13.500 --> 00:18:18.060
effort, Dagger 1 was former
Googlers working at Square.

00:18:18.060 --> 00:18:20.640
They decided to take their
crack at the problem.

00:18:20.640 --> 00:18:23.560
And they basically said the
configuration API-- basically

00:18:23.560 --> 00:18:27.740
all the solutions in
that solution column--

00:18:27.740 --> 00:18:29.690
all that stuff was great.

00:18:29.690 --> 00:18:31.620
So we just take all
the bits that juice

00:18:31.620 --> 00:18:34.100
API that you can
inspect statically,

00:18:34.100 --> 00:18:36.050
that was the caveat.

00:18:36.050 --> 00:18:38.920
Everything that the compiler
knows ahead of time,

00:18:38.920 --> 00:18:41.050
and you don't have
to execute in order

00:18:41.050 --> 00:18:42.202
to figure out the behavior?

00:18:42.202 --> 00:18:43.410
That's the part that we want.

00:18:43.410 --> 00:18:46.655
We want this thing
to be-- your compiler

00:18:46.655 --> 00:18:48.530
will know what's going
on, you don't actually

00:18:48.530 --> 00:18:50.690
have to startup a
server to figure it out.

00:18:50.690 --> 00:18:52.960
That's the API.

00:18:52.960 --> 00:18:54.470
And then for the
feature set, we're

00:18:54.470 --> 00:18:59.730
going to toss out everything
that may be a little dangerous.

00:18:59.730 --> 00:19:03.924
Guice was used to great effect,
but if people are really

00:19:03.924 --> 00:19:06.340
frequently shooting themselves
in the foot with a feature,

00:19:06.340 --> 00:19:08.520
let's toss it.

00:19:08.520 --> 00:19:12.770
And then, the combination
of those two things

00:19:12.770 --> 00:19:16.080
let them go through each of the
dependency injection features

00:19:16.080 --> 00:19:19.580
that you might want, and stop
doing the things at runtime,

00:19:19.580 --> 00:19:21.870
and start doing them at
compile time with annotation

00:19:21.870 --> 00:19:23.920
processors.

00:19:23.920 --> 00:19:26.200
And this is a bit of the magic.

00:19:26.200 --> 00:19:28.930
Is that error
reporting now happens

00:19:28.930 --> 00:19:31.370
at compile time in Dagger 1.

00:19:31.370 --> 00:19:33.375
We'll get to some
examples of that.

00:19:33.375 --> 00:19:34.750
But the other bit
is you can just

00:19:34.750 --> 00:19:35.790
do things more efficiently.

00:19:35.790 --> 00:19:37.248
If you don't have
to do reflection.

00:19:37.248 --> 00:19:39.269
No reflection is always
cheaper than reflection

00:19:39.269 --> 00:19:40.810
if you're doing the
exact same thing,

00:19:40.810 --> 00:19:43.400
so let's do no reflection.

00:19:43.400 --> 00:19:45.170
And we take all of
that overhead out

00:19:45.170 --> 00:19:46.460
of asking for a new instance.

00:19:49.310 --> 00:19:53.690
The graph looks almost identical
to what we saw in Guice.

00:19:53.690 --> 00:19:57.000
The difference is
that where we used

00:19:57.000 --> 00:19:59.570
to have that API where
you could bind things

00:19:59.570 --> 00:20:02.580
with class literals, now
everything's a provider method.

00:20:02.580 --> 00:20:05.260
It's a little more
verbose, possibly,

00:20:05.260 --> 00:20:07.717
but that's the part that
we could know statically.

00:20:07.717 --> 00:20:09.550
The compiler can look
at that and figure out

00:20:09.550 --> 00:20:12.370
how your application
is wired together,

00:20:12.370 --> 00:20:16.080
because it's got a return
type, and it's got parameters.

00:20:16.080 --> 00:20:18.730
The other difference which
we don't quite show here,

00:20:18.730 --> 00:20:22.270
is that whereas in
Guice, abstract module

00:20:22.270 --> 00:20:25.610
was a class you had to inherit
modules, now an annotation.

00:20:25.610 --> 00:20:29.410
Really not that
interesting a difference.

00:20:29.410 --> 00:20:32.080
But what happens when
we forget bindings?

00:20:32.080 --> 00:20:35.220
I claim that we got
errors at compile time,

00:20:35.220 --> 00:20:36.210
and we do in fact do.

00:20:36.210 --> 00:20:40.190
That little red squiggly is
Eclipse dutifully reporting

00:20:40.190 --> 00:20:41.720
that there is no
binding for pump,

00:20:41.720 --> 00:20:45.770
it was required by the
CoffeeMaker via the drip

00:20:45.770 --> 00:20:47.040
module.

00:20:47.040 --> 00:20:49.290
And javac will tell you,
Eclipse will tell you,

00:20:49.290 --> 00:20:51.200
whatever your IDE will tell you.

00:20:51.200 --> 00:20:53.960
That happens immediately
as you type in Eclipse,

00:20:53.960 --> 00:20:56.150
because of its
constant compilation.

00:20:56.150 --> 00:20:58.390
We no longer have to start
servers to figure out

00:20:58.390 --> 00:20:59.640
that we have missing bindings.

00:20:59.640 --> 00:21:04.400
The development life cycle
becomes very, very quick.

00:21:04.400 --> 00:21:06.530
What happens if you
declare a binding twice?

00:21:06.530 --> 00:21:07.470
The exact same thing.

00:21:07.470 --> 00:21:09.840
You get a red squiggly line
on each of the duplicates.

00:21:09.840 --> 00:21:11.470
It tells you exactly
what they are,

00:21:11.470 --> 00:21:17.180
and it tells you as immediately
as compile time can make it.

00:21:17.180 --> 00:21:19.660
What about debugging?

00:21:19.660 --> 00:21:20.460
Better.

00:21:20.460 --> 00:21:25.540
I will argue that it's better,
but it's not quite perfect yet.

00:21:25.540 --> 00:21:27.960
The thing you will notice,
is that we still have weird

00:21:27.960 --> 00:21:31.120
classes with a $$ sign in them,
but at least we tried to give

00:21:31.120 --> 00:21:32.170
them friendly names.

00:21:32.170 --> 00:21:35.220
We call them inject adapter.

00:21:35.220 --> 00:21:38.680
It adapts your class to
injection, go figure.

00:21:38.680 --> 00:21:43.680
So we give them names
meant for humans to read.

00:21:43.680 --> 00:21:46.080
But the most important
bit, is those

00:21:46.080 --> 00:21:47.700
inject adapters have source.

00:21:47.700 --> 00:21:50.190
You can look at it, all the
time, without exception.

00:21:50.190 --> 00:21:54.020
You can always go look at
exactly what it is doing.

00:21:54.020 --> 00:21:58.010
So you have a clear path of
code from your main method

00:21:58.010 --> 00:22:02.160
all the way down to the
CoffeeMaker constructer.

00:22:02.160 --> 00:22:05.720
So I claim that you could look
at the code, let's do that.

00:22:05.720 --> 00:22:12.060
Uh oh, that's a lot of not
so friendly looking code.

00:22:12.060 --> 00:22:13.400
It does generate code.

00:22:13.400 --> 00:22:15.550
You can trace through it.

00:22:15.550 --> 00:22:18.274
Maybe a lot of time you
probably don't want to.

00:22:18.274 --> 00:22:19.940
There's a lot of stuff
going on, there's

00:22:19.940 --> 00:22:22.620
strings that look
like class literals.

00:22:22.620 --> 00:22:24.320
There's actual class literals.

00:22:24.320 --> 00:22:26.400
There's asking
for class loaders.

00:22:26.400 --> 00:22:29.380
It's certainly a
faraway as from perfect.

00:22:29.380 --> 00:22:32.490
But we do all sort
of boil down to kind

00:22:32.490 --> 00:22:34.570
of the holy grail
of this is what

00:22:34.570 --> 00:22:36.550
we're trying to do
in the first place,

00:22:36.550 --> 00:22:38.240
we've just got a
lot of extra cruft

00:22:38.240 --> 00:22:40.530
that we might want
to get around.

00:22:40.530 --> 00:22:42.830
Sort of toss out.

00:22:42.830 --> 00:22:45.940
So, what did Dagger 1 do for us?

00:22:45.940 --> 00:22:47.870
Well, we get compile
time validation

00:22:47.870 --> 00:22:49.370
of big portions of the graph.

00:22:49.370 --> 00:22:53.200
We saw that you get
errors pretty quickly.

00:22:53.200 --> 00:22:57.350
Easy debugging, we can have an
entirely concrete call stack.

00:22:57.350 --> 00:23:00.270
And highly efficient provision.

00:23:00.270 --> 00:23:03.080
I think I probably should
make that a little clearer.

00:23:03.080 --> 00:23:06.770
Did you notice that in creating
my new CoffeeMaker instance

00:23:06.770 --> 00:23:08.250
there is no reflection?

00:23:08.250 --> 00:23:11.650
Reflection is not used to
instantiate a CoffeeMaker

00:23:11.650 --> 00:23:13.100
in any way, shape, or form.

00:23:13.100 --> 00:23:17.720
Reflection is used to figure out
how everything fits together.

00:23:17.720 --> 00:23:21.240
So if you have applications
with sensitive start up times,

00:23:21.240 --> 00:23:23.970
or you're creating
graphs per request,

00:23:23.970 --> 00:23:25.690
that's going to be
an issue for you.

00:23:25.690 --> 00:23:27.690
But if you already have
a graph, and you're just

00:23:27.690 --> 00:23:31.240
asking for instances, it's
going to be nice and cheap.

00:23:31.240 --> 00:23:33.890
The issues are
that-- I think it's

00:23:33.890 --> 00:23:37.420
pretty-- I feel a little
bad calling it ugly.

00:23:37.420 --> 00:23:39.340
I had a hand in some of it.

00:23:39.340 --> 00:23:42.360
But it's a little ugly.

00:23:42.360 --> 00:23:45.910
And it's also a runtime
graph composition.

00:23:45.910 --> 00:23:48.220
The reflective part where
you wire everything together?

00:23:48.220 --> 00:23:49.160
That still runtime.

00:23:49.160 --> 00:23:51.690
So there are still
classes of errors

00:23:51.690 --> 00:23:56.930
that you can see at
runtime, which is not ideal.

00:23:56.930 --> 00:24:00.950
And reflection makes inefficient
graph creation sometimes.

00:24:00.950 --> 00:24:04.770
And if you want to trace
through your application

00:24:04.770 --> 00:24:06.080
for creating an instance?

00:24:06.080 --> 00:24:08.200
Great, everything's good to go.

00:24:08.200 --> 00:24:10.700
If you want to trace through
your application for how

00:24:10.700 --> 00:24:13.830
to compose your graph, that's
where we're still a little

00:24:13.830 --> 00:24:15.030
lacking.

00:24:15.030 --> 00:24:19.030
And that map-like API that
we just can't seem to kick?

00:24:19.030 --> 00:24:21.070
Still there.

00:24:21.070 --> 00:24:25.120
So we got together one day.

00:24:25.120 --> 00:24:27.970
Said, alright, how do
we finally take a shot

00:24:27.970 --> 00:24:30.760
at fixing these problems
once and for all.

00:24:30.760 --> 00:24:33.290
Or better yet, what
are the problems?

00:24:33.290 --> 00:24:38.530
And I continue to argue that
dependency injection has

00:24:38.530 --> 00:24:41.770
worked since roughly 2002.

00:24:41.770 --> 00:24:45.140
And certainly as of Guice in
2006, when you do things right,

00:24:45.140 --> 00:24:46.490
everything's easy.

00:24:46.490 --> 00:24:47.900
The parts we need
to focus on are

00:24:47.900 --> 00:24:49.960
what happens when
things go wrong.

00:24:49.960 --> 00:24:52.190
And particularly traceability.

00:24:52.190 --> 00:24:54.140
I want to be able
to have a navigate

00:24:54.140 --> 00:24:56.364
through the entire application.

00:24:56.364 --> 00:24:57.030
All parts of it.

00:24:57.030 --> 00:24:59.750
Creating the graph,
getting a new instance.

00:24:59.750 --> 00:25:03.294
With eclipses find usage
or open declaration.

00:25:03.294 --> 00:25:05.460
Those nice little hot key
that we all know and love,

00:25:05.460 --> 00:25:08.170
they should never not work.

00:25:08.170 --> 00:25:09.740
And I also want to
trace through code

00:25:09.740 --> 00:25:12.740
that looks kind of like
what I wanted to write.

00:25:12.740 --> 00:25:16.580
If I were to undertake
doing 100,000 lines by hand,

00:25:16.580 --> 00:25:20.740
I want the code that's generated
to look exactly, within reason,

00:25:20.740 --> 00:25:24.180
exactly like what I would
have written myself.

00:25:24.180 --> 00:25:26.770
We also want to clarify
the API a little bit.

00:25:26.770 --> 00:25:28.430
Simpler module declarations.

00:25:28.430 --> 00:25:31.380
They can get kind of
convoluted sometimes,

00:25:31.380 --> 00:25:33.720
because of how things
are composed at runtime.

00:25:33.720 --> 00:25:34.980
And no more maps.

00:25:34.980 --> 00:25:38.510
That map-like API, we're getting
rid of it once and for all.

00:25:38.510 --> 00:25:39.410
And then performance.

00:25:39.410 --> 00:25:43.350
Performance was actually
one of the big motivators

00:25:43.350 --> 00:25:48.300
for why we want Dagger 2.

00:25:48.300 --> 00:25:52.210
The Android, youre
mobile device,

00:25:52.210 --> 00:25:54.260
had pretty good
success with Dagger 1.

00:25:54.260 --> 00:25:56.940
Because you start up your
application once for the most

00:25:56.940 --> 00:25:59.370
part, and then you ask
for new activities,

00:25:59.370 --> 00:26:00.460
you ask for new things.

00:26:00.460 --> 00:26:03.000
And that reflection cost
that they were paying,

00:26:03.000 --> 00:26:05.010
they were paying
pretty infrequently.

00:26:05.010 --> 00:26:08.000
If you wanted to use
Dagger on the server side--

00:26:08.000 --> 00:26:10.220
and we have been using
Dagger on the server side,

00:26:10.220 --> 00:26:12.850
on one of our larger
search applications,

00:26:12.850 --> 00:26:16.440
one of our larger
search services.

00:26:16.440 --> 00:26:19.290
The per request overhead of
creating big object graphs

00:26:19.290 --> 00:26:23.950
was really starting to weigh
pretty heavily on Dagger 1.

00:26:23.950 --> 00:26:26.430
And we'll talk about
some of the results

00:26:26.430 --> 00:26:28.815
for having moved on to Dagger 2.

00:26:28.815 --> 00:26:30.190
The other thing
is, we don't want

00:26:30.190 --> 00:26:31.606
to code around the
perk framework.

00:26:31.606 --> 00:26:33.940
Every time you find
yourself caching something

00:26:33.940 --> 00:26:36.990
because it's slow,
that's the burden

00:26:36.990 --> 00:26:39.120
we're placing on our users
that we don't want to.

00:26:39.120 --> 00:26:40.494
And we make sure
that no one ever

00:26:40.494 --> 00:26:42.670
has to do that with Dagger 2.

00:26:42.670 --> 00:26:43.490
So what we do?

00:26:43.490 --> 00:26:46.100
How do we do it?

00:26:46.100 --> 00:26:48.310
More or less we like the
API for configuration.

00:26:48.310 --> 00:26:51.470
We liked it in Guice, we
continue to like it in Dagger.

00:26:51.470 --> 00:26:53.760
It works, stick with
the configuration API.

00:26:53.760 --> 00:26:56.600
Those are provides methods
@inject constructors.

00:26:56.600 --> 00:27:02.274
All those things that JSR 330
defined for us, we're happy.

00:27:02.274 --> 00:27:05.620
The compile time code.

00:27:05.620 --> 00:27:09.880
We want to generate nice, simple
code for the entire stack.

00:27:09.880 --> 00:27:10.730
No more reflection.

00:27:10.730 --> 00:27:14.570
We're getting rid of
reflection entirely.

00:27:14.570 --> 00:27:17.310
That was a bit of a tricky
goal, we'll see how we did it.

00:27:17.310 --> 00:27:19.960
We also want to validate all
framework and configuration

00:27:19.960 --> 00:27:21.992
preconditions at compile time.

00:27:21.992 --> 00:27:23.450
If we don't have
reflection, and we

00:27:23.450 --> 00:27:25.450
don't have a runtime
presence, we obviously

00:27:25.450 --> 00:27:28.110
need to check all the
errors at compile time,

00:27:28.110 --> 00:27:32.200
otherwise your application would
just fall over and not compile.

00:27:32.200 --> 00:27:34.690
And then we finally wanted
to unify user defined types

00:27:34.690 --> 00:27:36.390
with generated
types, but we wanted

00:27:36.390 --> 00:27:39.720
to do it in a way that
was limited, clear,

00:27:39.720 --> 00:27:40.600
sort of intuitive.

00:27:40.600 --> 00:27:43.980
Something that you don't have
to really have to figure out.

00:27:43.980 --> 00:27:46.320
And that's, a lot of times,
the challenge with user

00:27:46.320 --> 00:27:47.590
generated code.

00:27:47.590 --> 00:27:53.110
And for that, we drew
inspiration from a framework,

00:27:53.110 --> 00:27:56.340
project, whatever you want
to call it, called AutoValue.

00:27:56.340 --> 00:28:00.050
It you are sick of writing
equals hashCode and toString,

00:28:00.050 --> 00:28:04.180
I highly recommend you
go look into AutoValue.

00:28:04.180 --> 00:28:07.490
Different project, also
code generation, that's

00:28:07.490 --> 00:28:09.210
where inspiration came.

00:28:09.210 --> 00:28:11.250
Go take a look.

00:28:11.250 --> 00:28:14.740
But what AutoValue did, in
the sort of the montra they

00:28:14.740 --> 00:28:18.250
set forth, was step one
is constrain the problem.

00:28:18.250 --> 00:28:21.620
Make the problem solvable
using code generation,

00:28:21.620 --> 00:28:24.100
and then generate the only
reasonable implementation

00:28:24.100 --> 00:28:26.750
that anyone would ever expect.

00:28:26.750 --> 00:28:28.020
Seems straightforward.

00:28:28.020 --> 00:28:30.500
So that was our strategy.

00:28:30.500 --> 00:28:31.960
Here's how we did it.

00:28:31.960 --> 00:28:35.100
We started with JSR 330.

00:28:35.100 --> 00:28:37.580
That's the thing that defines
@inject, a couple scoping

00:28:37.580 --> 00:28:40.020
annotations, all those DI
things that you're probably

00:28:40.020 --> 00:28:43.829
familiar with having
used the DI frameworks.

00:28:43.829 --> 00:28:45.620
The funny thing is it
only actually defines

00:28:45.620 --> 00:28:48.849
one non-annotation type,
it is called provider.

00:28:48.849 --> 00:28:50.390
Provider is an
interface, and it just

00:28:50.390 --> 00:28:53.790
says give me an instance of
whatever I'm a provider of,

00:28:53.790 --> 00:28:55.290
which seems pretty
straightforward.

00:28:55.290 --> 00:29:00.320
In our CoffeeMaker case-- I'm
sorry, I knew it would happen.

00:29:00.320 --> 00:29:01.440
There's a typo.

00:29:01.440 --> 00:29:03.240
That should say "provider
of CoffeeMaker,"

00:29:03.240 --> 00:29:05.320
not "Provider of T".

00:29:05.320 --> 00:29:08.200
But imagine that said
provider of CoffeeMaker.

00:29:08.200 --> 00:29:10.940
By the time anyone on
YouTube sees these slides,

00:29:10.940 --> 00:29:13.880
it will say provider
of CoffeeMaker.

00:29:13.880 --> 00:29:15.560
So for provider of
CoffeeMaker, you just

00:29:15.560 --> 00:29:17.540
say, hey, I want
an instance called

00:29:17.540 --> 00:29:19.244
get, you get a CoffeeMaker.

00:29:19.244 --> 00:29:20.660
That seems pretty
straightforward.

00:29:20.660 --> 00:29:22.380
The trick is figuring
out how we need

00:29:22.380 --> 00:29:24.840
to implement-- you
know, what we generate

00:29:24.840 --> 00:29:29.930
the implements provider that
will work for our DI framework.

00:29:29.930 --> 00:29:31.131
Here's what we make.

00:29:31.131 --> 00:29:33.630
For a CoffeeMaker provider, we
call it CoffeeMaker$$Factory.

00:29:36.284 --> 00:29:37.700
Quick note about
the dollar signs,

00:29:37.700 --> 00:29:40.880
is anything that we don't
expect users to explicitly have

00:29:40.880 --> 00:29:43.460
to deal with, we put
double dollar signs in it.

00:29:43.460 --> 00:29:45.515
If you find yourself
typing in your IDE,

00:29:45.515 --> 00:29:49.320
and you type two dollar signs,
you're doing the wrong thing.

00:29:49.320 --> 00:29:51.420
But because they have
to become public classes

00:29:51.420 --> 00:29:54.501
for a variety of reasons,
we couldn't just hide them,

00:29:54.501 --> 00:29:55.750
so people couldn't touch them.

00:29:55.750 --> 00:29:57.900
We just had to make them ugly.

00:29:57.900 --> 00:30:03.800
So CoffeeMaker$$Factory
basically does exactly what we

00:30:03.800 --> 00:30:06.370
want to do in that
original main method,

00:30:06.370 --> 00:30:09.030
but instead of asking
for new instances,

00:30:09.030 --> 00:30:10.860
it just asked for the
provider of a heater,

00:30:10.860 --> 00:30:12.068
and the provider of the pump.

00:30:12.068 --> 00:30:14.650
It knows exactly one
link in the graph.

00:30:14.650 --> 00:30:19.600
It says, in order to make a
CoffeeMaker, I need a heater,

00:30:19.600 --> 00:30:22.240
I need a pump, so get the
provider for those things,

00:30:22.240 --> 00:30:25.120
call get(), return
a new CoffeeMaker.

00:30:25.120 --> 00:30:27.580
And that's all happening
right down there.

00:30:27.580 --> 00:30:30.380
With the layer of
provider indirection,

00:30:30.380 --> 00:30:32.962
it's otherwise exactly the same.

00:30:32.962 --> 00:30:34.170
And we generate that for you.

00:30:34.170 --> 00:30:37.220
And I would argue
that most people can,

00:30:37.220 --> 00:30:38.680
if they're familiar
with providers,

00:30:38.680 --> 00:30:41.127
had not having seen
this for the first time,

00:30:41.127 --> 00:30:42.460
it looks pretty straightforward.

00:30:42.460 --> 00:30:46.570
It's certainly a lot shorter
than our previous version.

00:30:46.570 --> 00:30:49.540
The other thing is, we
all have provides methods,

00:30:49.540 --> 00:30:51.240
which is a method
that provides a value.

00:30:51.240 --> 00:30:53.600
We saw those in the
previous examples.

00:30:53.600 --> 00:30:56.300
The only difference between
a factory for a constructor,

00:30:56.300 --> 00:30:59.324
and a factory for
provides method,

00:30:59.324 --> 00:31:01.240
is that you just get an
instance of the module

00:31:01.240 --> 00:31:03.100
invoke the method.

00:31:03.100 --> 00:31:05.360
That's happening down there.

00:31:05.360 --> 00:31:09.410
In order to provide a pump,
I need a thermosiphon,

00:31:09.410 --> 00:31:12.060
because that's my
implementation of pump.

00:31:12.060 --> 00:31:13.830
I generate code the
just calls the method

00:31:13.830 --> 00:31:16.390
and passes in the thermosiphon.

00:31:16.390 --> 00:31:20.010
Pretty straightforward
there too, I think.

00:31:20.010 --> 00:31:22.940
Now we get to talk
about that map-like API.

00:31:22.940 --> 00:31:24.560
This is the client API.

00:31:24.560 --> 00:31:27.810
This is how you actually
ask for a CoffeeMaker.

00:31:27.810 --> 00:31:33.190
In Spring, it was pre-generic,
so it was make a bean factory,

00:31:33.190 --> 00:31:35.940
pass in the string, cast.

00:31:35.940 --> 00:31:39.360
In Guice, we had Java 1.5, so we
got to be a little more clever.

00:31:39.360 --> 00:31:42.210
We got to say create an
injector by passing it

00:31:42.210 --> 00:31:44.184
on my configuration,
and then get

00:31:44.184 --> 00:31:46.350
an instance of a CoffeeMaker,
and automatically does

00:31:46.350 --> 00:31:47.741
the right things generics.

00:31:47.741 --> 00:31:49.490
But we're still passing
in class literals,

00:31:49.490 --> 00:31:52.120
so obviously we're still
in reflection land.

00:31:52.120 --> 00:31:54.940
And Dagger 1, like I said,
that was exactly the same.

00:31:54.940 --> 00:31:56.050
It was still reflection.

00:31:56.050 --> 00:32:01.390
It still looked, more or less,
like a map of class to object.

00:32:01.390 --> 00:32:04.290
In Dagger 2, this
is the crux of it.

00:32:04.290 --> 00:32:05.750
This is the part of the changes.

00:32:05.750 --> 00:32:09.410
This is the part that we
are doing most differently.

00:32:09.410 --> 00:32:12.290
We say, here is a
CoffeeMaker maker component.

00:32:12.290 --> 00:32:16.750
And component is the
word for the interface

00:32:16.750 --> 00:32:19.210
that Dagger 2
needs to implement,

00:32:19.210 --> 00:32:22.220
that just gives you instances
of all the types you defined.

00:32:22.220 --> 00:32:24.350
So as a user, I say
I want a CoffeeMaker.

00:32:24.350 --> 00:32:27.420
I define an interface that
says give me a CoffeeMaker.

00:32:27.420 --> 00:32:31.100
Just a method, no arguments,
returns a CoffeeMaker,

00:32:31.100 --> 00:32:34.380
and I toss an @component
annotation on it.

00:32:34.380 --> 00:32:36.410
I list out all of
the modules that I

00:32:36.410 --> 00:32:38.057
need to make my component.

00:32:38.057 --> 00:32:40.640
And if any of them are missing,
we get the compile time errors

00:32:40.640 --> 00:32:42.110
that we expect.

00:32:42.110 --> 00:32:46.810
And what it does, is it
generates a class with the same

00:32:46.810 --> 00:32:50.220
name as the component, but
prefixed with Dagger_ that

00:32:50.220 --> 00:32:53.600
knows how to take all of
those bindings together,

00:32:53.600 --> 00:32:55.710
and create your CoffeeMaker.

00:32:55.710 --> 00:33:00.690
So, we just say
Dagger_CoffeeMaker.create();,

00:33:00.690 --> 00:33:03.490
and we didn't implementation
of that interface.

00:33:03.490 --> 00:33:06.382
We never have to hold onto
that concrete type again,

00:33:06.382 --> 00:33:08.590
but that thing knows how to
make CoffeeMakers for me.

00:33:08.590 --> 00:33:10.910
And I just called the
method with the method name

00:33:10.910 --> 00:33:13.270
that I gave it.

00:33:13.270 --> 00:33:15.230
Sounds like magic.

00:33:15.230 --> 00:33:16.720
Here's the magic.

00:33:16.720 --> 00:33:21.010
We literally write all of
that horrible boilerplate

00:33:21.010 --> 00:33:23.110
that we used to have
to write by hand,

00:33:23.110 --> 00:33:24.970
exactly as you would
have to write it

00:33:24.970 --> 00:33:29.080
if you wrote it by hand in
the generated implementation.

00:33:29.080 --> 00:33:33.960
It is all of the same logic,
in all the same order,

00:33:33.960 --> 00:33:35.910
just written out for you.

00:33:35.910 --> 00:33:39.249
I am going to admit to this
being slightly different

00:33:39.249 --> 00:33:41.290
than what you would actually
get out of the tool,

00:33:41.290 --> 00:33:44.550
cause I had to kind of
keep a little more compact

00:33:44.550 --> 00:33:46.450
to live on a slide.

00:33:46.450 --> 00:33:51.849
But with very few modifications,
this is exactly what you get.

00:33:51.849 --> 00:33:54.140
It just goes through, says
here are all the things that

00:33:54.140 --> 00:33:56.170
don't have dependencies,
I can make them first.

00:33:56.170 --> 00:34:01.320
And then all the things that
I need, wires them all up,

00:34:01.320 --> 00:34:03.300
stores the references
to the provider.

00:34:03.300 --> 00:34:07.240
And the CoffeeMaker method,
the getCoffeeMaker method

00:34:07.240 --> 00:34:08.610
that I defined I my interface?

00:34:08.610 --> 00:34:11.002
The implementation is,
invoke that provider.

00:34:11.002 --> 00:34:12.960
Which in turn, invokes
all the other providers.

00:34:12.960 --> 00:34:15.001
Which in turn, invokes
all of the other providers

00:34:15.001 --> 00:34:16.400
all the way down.

00:34:16.400 --> 00:34:20.449
And as far as we can tell
it is the single most

00:34:20.449 --> 00:34:24.489
runtime efficient version
of dependency injection

00:34:24.489 --> 00:34:27.719
that you can possibly have.

00:34:27.719 --> 00:34:30.179
We have yet to dream
up anything better.

00:34:30.179 --> 00:34:33.139
And there are a couple layers
of indirection in here, a couple

00:34:33.139 --> 00:34:35.560
extra provider objects,
and for the most part,

00:34:35.560 --> 00:34:38.520
hotspot seems to do its job
and make all of those things as

00:34:38.520 --> 00:34:42.080
cheap, with all the inlining
that we could hope for.

00:34:42.080 --> 00:34:44.310
So what have we done.

00:34:44.310 --> 00:34:46.870
We have compile time
validation of the entire graph,

00:34:46.870 --> 00:34:49.199
because we're generating
the entire graph.

00:34:49.199 --> 00:34:51.710
We have super easy debugging,
because you could literally

00:34:51.710 --> 00:34:53.420
just trace through,
line by line,

00:34:53.420 --> 00:34:56.219
and watch it invoke
all of these providers.

00:34:56.219 --> 00:34:59.440
Fully traceable, you can
see all the find usages.

00:34:59.440 --> 00:35:01.040
Let's go back to that slide.

00:35:01.040 --> 00:35:03.160
Every one of those
factories that we generated

00:35:03.160 --> 00:35:05.370
in the first step, we have
references right there.

00:35:05.370 --> 00:35:09.720
We can just F3 in
Eclipse, open declaration.

00:35:09.720 --> 00:35:12.740
And the API is finally,
once and for all, a Java

00:35:12.740 --> 00:35:14.350
object just like
everything else.

00:35:14.350 --> 00:35:17.200
I say I have this interface,
here the things that I need,

00:35:17.200 --> 00:35:20.140
that's what I work with instead
of map type things with class

00:35:20.140 --> 00:35:21.240
liberals.

00:35:21.240 --> 00:35:24.370
And most importantly,
performance.

00:35:24.370 --> 00:35:26.350
I guess this is the part
where I could tell you

00:35:26.350 --> 00:35:28.980
exactly how performant.

00:35:28.980 --> 00:35:32.810
So we had a pretty
large search service

00:35:32.810 --> 00:35:35.750
that's serving a lot of traffic.

00:35:35.750 --> 00:35:38.000
And the more Dagger
1 we adopted,

00:35:38.000 --> 00:35:40.230
people were very happy with
the compile time errors.

00:35:40.230 --> 00:35:45.410
But people, our SRE's, the
people in charge of monitoring

00:35:45.410 --> 00:35:47.640
just how efficiently
things are running,

00:35:47.640 --> 00:35:49.142
how many CPU things are taking.

00:35:49.142 --> 00:35:50.850
They started to come
knocking on my door,

00:35:50.850 --> 00:35:52.975
saying this is getting
worse, and worse, and worse,

00:35:52.975 --> 00:35:55.480
and we have to stall some of
the migrations to Dagger 1

00:35:55.480 --> 00:35:58.960
because we're
burning too much CPU.

00:35:58.960 --> 00:36:01.382
So I kept saying, hold
on, we'll get Dagger 2.

00:36:01.382 --> 00:36:02.840
It'll solve all of
our problems, it

00:36:02.840 --> 00:36:05.740
is theoretically the best we
can do, so obviously that'll

00:36:05.740 --> 00:36:08.750
work in practice, right?

00:36:08.750 --> 00:36:11.180
It was earlier this
week that I finally

00:36:11.180 --> 00:36:15.610
got to wipe the sweat off my
brow, to the tune of about 13%

00:36:15.610 --> 00:36:19.690
of per quest CPU
at Google scale.

00:36:19.690 --> 00:36:21.020
That's a lot of CPU.

00:36:21.020 --> 00:36:25.020
We made every single request
all of a sudden 13% cheaper

00:36:25.020 --> 00:36:27.720
by moving just
dependency injection.

00:36:27.720 --> 00:36:29.830
That was a very big win.

00:36:29.830 --> 00:36:33.840
In Android world, that could be
13% of your application startup

00:36:33.840 --> 00:36:37.250
time, depending on how your
applications are wired.

00:36:37.250 --> 00:36:39.150
But I think most
importantly, I continue

00:36:39.150 --> 00:36:41.120
to argue that you just
can't do any better.

00:36:43.710 --> 00:36:44.920
But I'm not going to lie.

00:36:44.920 --> 00:36:45.900
There are some issues.

00:36:45.900 --> 00:36:47.840
There are some things
we traded in order

00:36:47.840 --> 00:36:50.150
to get all these great benefits.

00:36:50.150 --> 00:36:52.190
It's less flexible.

00:36:52.190 --> 00:36:54.320
Reflection is nice
and magic because you

00:36:54.320 --> 00:36:56.250
can do virtually
anything you want.

00:36:56.250 --> 00:36:58.490
You can inspect your
entire application,

00:36:58.490 --> 00:37:01.320
permute it crazy ways,
generate byte code.

00:37:01.320 --> 00:37:05.000
We don't let you do any of that,
so you can't do any of that.

00:37:05.000 --> 00:37:07.340
We think that's
an OK concession.

00:37:07.340 --> 00:37:08.480
There's no dynamism.

00:37:08.480 --> 00:37:09.670
No more flags.

00:37:09.670 --> 00:37:14.402
No more recomposing your
application at runtime.

00:37:14.402 --> 00:37:16.110
You still have all
the same conditionals,

00:37:16.110 --> 00:37:18.620
below provider methods,
and above your components.

00:37:18.620 --> 00:37:22.510
But we don't let you
retool how the framework is

00:37:22.510 --> 00:37:24.780
behaving dynamically.

00:37:24.780 --> 00:37:27.020
That seemed also kind of
to be it OK concession,

00:37:27.020 --> 00:37:30.240
because it was causing a lot
of people a lot of confusion.

00:37:30.240 --> 00:37:34.570
And the biggest issue
that we are finding,

00:37:34.570 --> 00:37:36.610
is that because of
these constraints

00:37:36.610 --> 00:37:39.430
there is no automated
migration path from Guice.

00:37:39.430 --> 00:37:41.457
You can't say, oh swap
out the set of imports,

00:37:41.457 --> 00:37:43.540
for this other set of
imports, and all of a sudden

00:37:43.540 --> 00:37:45.610
your application
becomes a lot faster.

00:37:45.610 --> 00:37:48.540
And as I mentioned, we
have a lot of Guice code.

00:37:48.540 --> 00:37:50.390
So if you want the
benefits of Dagger 2,

00:37:50.390 --> 00:37:54.091
you're probably going to have
to do a little bit of work

00:37:54.091 --> 00:37:55.840
to migrate your app
from one to the other.

00:37:58.360 --> 00:38:00.470
And again, that's
it's a concession,

00:38:00.470 --> 00:38:02.450
but I think that
it's probably fine,

00:38:02.450 --> 00:38:07.090
specifically as we software
engineering community at large

00:38:07.090 --> 00:38:09.550
can't seem to spawn
new apps faster

00:38:09.550 --> 00:38:10.910
than we know what to do with.

00:38:10.910 --> 00:38:12.850
So if we only target
new apps, I think

00:38:12.850 --> 00:38:16.606
that's probably not
half bad either.

00:38:16.606 --> 00:38:17.480
So what's the status?

00:38:17.480 --> 00:38:18.670
Where are we?

00:38:18.670 --> 00:38:21.614
Can we put this in your hands?

00:38:21.614 --> 00:38:23.780
This very specifically, you
guys might have noticed,

00:38:23.780 --> 00:38:25.296
wasn't a tutorial.

00:38:25.296 --> 00:38:26.670
I didn't show you
how to do it, I

00:38:26.670 --> 00:38:28.230
showed you why we
do it, because how

00:38:28.230 --> 00:38:30.430
to do it isn't quite there yet.

00:38:30.430 --> 00:38:33.530
We are roughly speaking,
feature complete.

00:38:33.530 --> 00:38:36.920
If everything goes
well, it runs.

00:38:36.920 --> 00:38:39.700
And like I said, we've seen
this running on something

00:38:39.700 --> 00:38:42.490
very like production traffic.

00:38:42.490 --> 00:38:43.520
But we have bugs.

00:38:43.520 --> 00:38:45.070
We have bugs that
we have to squash.

00:38:45.070 --> 00:38:48.450
We have error messages that
we need to make a lot better.

00:38:48.450 --> 00:38:50.700
In fact my partner in
crime over there and I

00:38:50.700 --> 00:38:53.110
spend probably a
good hour and a half

00:38:53.110 --> 00:38:56.625
locked in a very hot
to room debating over

00:38:56.625 --> 00:38:58.000
just what we're
going to show you

00:38:58.000 --> 00:39:00.610
when you have a cycle
in your dependencies.

00:39:00.610 --> 00:39:03.269
We are working very hard, and
taking that very seriously,

00:39:03.269 --> 00:39:05.310
because we don't want to
give you something where

00:39:05.310 --> 00:39:06.684
your first experience
with it is,

00:39:06.684 --> 00:39:09.840
I made a mistake in
the thing blew up.

00:39:09.840 --> 00:39:12.970
We have some preliminary
performance tests

00:39:12.970 --> 00:39:13.700
that I mentioned.

00:39:13.700 --> 00:39:16.010
And we are developing
a migration guide,

00:39:16.010 --> 00:39:18.320
not from Guice,
but from Dagger 1.

00:39:18.320 --> 00:39:21.510
We do fully expect to
support, I have Dagger 1,

00:39:21.510 --> 00:39:22.372
now I want Dagger 2.

00:39:22.372 --> 00:39:23.830
They're similar
enough that I think

00:39:23.830 --> 00:39:27.159
we should be able to give you
a pretty clear path forward.

00:39:27.159 --> 00:39:28.200
So that's where we're at.

00:39:28.200 --> 00:39:34.270
And we expect, certainly, I will
promise that we will have this

00:39:34.270 --> 00:39:37.270
in your hands, in the open
source projects hands,

00:39:37.270 --> 00:39:40.340
certainly within the
quarter in some form.

00:39:40.340 --> 00:39:41.790
But you can go
check out the code,

00:39:41.790 --> 00:39:43.750
build it yourself, poke around.

00:39:43.750 --> 00:39:49.030
But when things break, it's
sort of your own risk right now.

00:39:49.030 --> 00:39:51.300
Resources for all of this.

00:39:51.300 --> 00:39:54.790
We've got the Dagger 1 page, the
Dagger 2 Design Doc, the Dagger

00:39:54.790 --> 00:39:57.000
2 Code.

00:39:57.000 --> 00:39:59.594
We have some spin-off
projects that are probably

00:39:59.594 --> 00:40:01.010
worth taking a
look at, if this is

00:40:01.010 --> 00:40:03.560
the sort of thing
that interests you.

00:40:03.560 --> 00:40:05.250
Compile testing
was a big effort,

00:40:05.250 --> 00:40:08.660
where we made some tools for
testing annotation processors.

00:40:08.660 --> 00:40:12.050
If you ever write one, I highly
recommend looking at that.

00:40:12.050 --> 00:40:13.920
And auto-commonism,
common libraries

00:40:13.920 --> 00:40:16.040
for annotation processors.

