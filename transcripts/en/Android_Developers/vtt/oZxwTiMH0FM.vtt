WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.346
[MUSIC PLAYING]

00:00:05.780 --> 00:00:07.530
AKSHAY KANNAN: Good
morning, everyone.

00:00:07.530 --> 00:00:09.730
Ooh, first talk of the day.

00:00:09.730 --> 00:00:10.890
So hi.

00:00:10.890 --> 00:00:12.680
I'll start by
introducing ourselves.

00:00:12.680 --> 00:00:13.870
My name is Akshay Kannan.

00:00:13.870 --> 00:00:16.922
And I'm a Product Manager
on the Android Auth team.

00:00:16.922 --> 00:00:18.130
FELIPE LEME: I'm Felipe Leme.

00:00:18.130 --> 00:00:21.100
I'm Software Engineer in
Android Frameworks Team.

00:00:21.100 --> 00:00:22.900
SIMRANJIT KOHLI: Hi,
I'm Simranjit Kohli.

00:00:22.900 --> 00:00:26.300
I am Software Engineer in
Android Authentication Team.

00:00:26.300 --> 00:00:28.780
AKSHAY KANNAN: And our talk
is all about Android APIs

00:00:28.780 --> 00:00:31.390
that you can use to
improve sign-in, payment,

00:00:31.390 --> 00:00:34.150
and other key forms and
experiences in your apps.

00:00:36.840 --> 00:00:38.614
So let's dive right in.

00:00:38.614 --> 00:00:39.780
Why are we giving this talk?

00:00:39.780 --> 00:00:42.700
What are the goals we want
to accomplish with this?

00:00:42.700 --> 00:00:47.460
The first is to get more apps to
use existing data from Android,

00:00:47.460 --> 00:00:49.740
and to avoid
prompting your users.

00:00:49.740 --> 00:00:52.650
Throwing up any kind of
blank form in your app,

00:00:52.650 --> 00:00:55.350
such as an app log-in
or a credit card,

00:00:55.350 --> 00:00:57.630
can create friction
and result in drop-off

00:00:57.630 --> 00:01:00.660
when users don't know
this information offhand.

00:01:00.660 --> 00:01:03.270
We've created APIs for
you to automatically get

00:01:03.270 --> 00:01:05.600
this information
when it's available

00:01:05.600 --> 00:01:07.980
so that you can let your
users skip past this step

00:01:07.980 --> 00:01:12.220
and get right to the stuff that
actually matters in your app.

00:01:12.220 --> 00:01:13.950
Secondly, we'll
talk about how you

00:01:13.950 --> 00:01:15.630
can provide a
seamless experience

00:01:15.630 --> 00:01:18.870
and reduce churn when
your users switch devices.

00:01:18.870 --> 00:01:20.520
Getting a new phone is awesome.

00:01:20.520 --> 00:01:22.980
But it can also mean that
your users get locked out of

00:01:22.980 --> 00:01:25.260
or stop engaging with your app.

00:01:25.260 --> 00:01:28.860
Here also, we have a set of
APIs to maintain your app state

00:01:28.860 --> 00:01:31.330
across devices.

00:01:31.330 --> 00:01:32.850
Let's start by
focusing on how you

00:01:32.850 --> 00:01:35.430
can use existing information
that the user has already

00:01:35.430 --> 00:01:37.365
provided to enhance your flows.

00:01:41.130 --> 00:01:44.160
The first feature I want
to talk about is a new one.

00:01:44.160 --> 00:01:46.260
You may have heard about
this in the Keynote.

00:01:46.260 --> 00:01:49.170
Starting in Android O,
we've added native support

00:01:49.170 --> 00:01:51.120
for password managers.

00:01:51.120 --> 00:01:54.570
This functionality is
integrated tightly into the OS.

00:01:54.570 --> 00:01:57.120
So you don't have to rely
on hacks like Accessibility

00:01:57.120 --> 00:01:59.850
Services or Custom
Keyboards in order

00:01:59.850 --> 00:02:02.010
to securely fill in
passwords, credit

00:02:02.010 --> 00:02:04.590
cards, and other information.

00:02:04.590 --> 00:02:09.240
We've partnered with DashLane,
LastPass, Keeper, and 1Password

00:02:09.240 --> 00:02:12.130
to support this feature when
Android O goes out this year.

00:02:12.130 --> 00:02:14.370
And we're really
excited about this.

00:02:14.370 --> 00:02:18.090
Of course, not everyone
uses a password manager.

00:02:18.090 --> 00:02:20.310
But we still want
all Android O users

00:02:20.310 --> 00:02:22.260
to be able to
experience the security

00:02:22.260 --> 00:02:24.060
and convenience of Autofill.

00:02:24.060 --> 00:02:26.670
So for those users,
we're introducing

00:02:26.670 --> 00:02:29.040
Autofill with Google.

00:02:29.040 --> 00:02:32.130
This feature comes bundled
with Android O devices

00:02:32.130 --> 00:02:35.070
and lets you fill in passwords,
addresses, credit cards

00:02:35.070 --> 00:02:36.810
and other information
that you already

00:02:36.810 --> 00:02:38.640
have saved to your
Google account

00:02:38.640 --> 00:02:41.760
with Chrome Sync, all
with a single tap.

00:02:41.760 --> 00:02:44.370
We've made a preview of this
feature available to developers

00:02:44.370 --> 00:02:47.370
as part of the O beta, which
you can play around with today,

00:02:47.370 --> 00:02:49.620
and use to test out
functionality for autofilling

00:02:49.620 --> 00:02:51.750
the logins in your apps.

00:02:51.750 --> 00:02:53.880
Support for credit
cards and addresses

00:02:53.880 --> 00:02:58.380
is coming later this year,
along with a consumer release.

00:02:58.380 --> 00:03:00.130
Let's take a look at
what this looks like.

00:03:04.810 --> 00:03:07.250
Let's cut to the demo.

00:03:07.250 --> 00:03:11.050
So let's say that I'm logging
into Twitter on a new device.

00:03:11.050 --> 00:03:12.670
I simply open the app.

00:03:12.670 --> 00:03:13.780
I tap Log in.

00:03:13.780 --> 00:03:15.820
And you can see here,
that my username already

00:03:15.820 --> 00:03:18.040
auto-populates as a suggestion.

00:03:18.040 --> 00:03:19.260
I simply tap on that.

00:03:19.260 --> 00:03:22.390
My Username and Password
automatically get filled in.

00:03:22.390 --> 00:03:23.590
I hit Log in.

00:03:23.590 --> 00:03:26.170
And now, as you
can see, I've been

00:03:26.170 --> 00:03:28.390
able to log into
Twitter without pressing

00:03:28.390 --> 00:03:31.000
a single key on my phone.

00:03:31.000 --> 00:03:33.700
Next, I'll hand
things over to Felipe,

00:03:33.700 --> 00:03:36.100
who's going to talk a little
bit about how this all works

00:03:36.100 --> 00:03:38.560
and how you can optimize
your apps as developers

00:03:38.560 --> 00:03:39.619
for Autofill.

00:03:39.619 --> 00:03:40.785
FELIPE LEME: Thanks, Akshay.

00:03:40.785 --> 00:03:45.150
[APPLAUSE]

00:03:45.150 --> 00:03:47.850
Yes, the clap was for him
or for Autofill with Google.

00:03:47.850 --> 00:03:49.290
But pretty sure
it was not for me.

00:03:49.290 --> 00:03:51.230
Anyway.

00:03:51.230 --> 00:03:53.390
So the Android
Autofill framework

00:03:53.390 --> 00:03:56.720
was designed to work out of
the box with existing apps,

00:03:56.720 --> 00:04:01.060
without changing the apps
to support the Autofill.

00:04:01.060 --> 00:04:04.790
In fact, for our Twitter
demo, we just got a Twitter.

00:04:04.790 --> 00:04:06.560
We just installed our
existing Twitter app

00:04:06.560 --> 00:04:07.684
from the Google Play Store.

00:04:07.684 --> 00:04:09.770
And it just worked,
without any involvement

00:04:09.770 --> 00:04:11.510
for the Twitter developers.

00:04:11.510 --> 00:04:14.110
We hope this is going to
be the case for most apps.

00:04:14.110 --> 00:04:15.890
But we still provide
some API's that you

00:04:15.890 --> 00:04:19.640
can use to make sure that
your app integrates well

00:04:19.640 --> 00:04:20.839
with Autofill.

00:04:20.839 --> 00:04:23.480
We'll see some of these
API's over the next slides.

00:04:23.480 --> 00:04:25.940
But first, let's take a
high-level look on how Autofill

00:04:25.940 --> 00:04:27.770
works, because that
will make it easier

00:04:27.770 --> 00:04:33.340
to understand why using
these API's is important.

00:04:33.340 --> 00:04:37.080
So the Autofill workflow
involves three processes.

00:04:37.080 --> 00:04:39.330
In one hand, you
have our app, which

00:04:39.330 --> 00:04:41.210
is the app, being Autofill.

00:04:41.210 --> 00:04:43.710
In the other hand, you
have Autofill service,

00:04:43.710 --> 00:04:46.020
which is the app that
has the user data,

00:04:46.020 --> 00:04:49.320
like a Password Manager,
or Autofill with Google.

00:04:49.320 --> 00:04:52.470
Then in between then, you have
the Android Runtime System,

00:04:52.470 --> 00:04:55.380
which is a mediator used
for privacy, security,

00:04:55.380 --> 00:04:58.560
and performance reasons.

00:04:58.560 --> 00:05:01.080
The whole workflow starts
when the user selects

00:05:01.080 --> 00:05:02.730
an editable field on the app.

00:05:02.730 --> 00:05:07.230
For example, when the Username
view on Twitter was focused.

00:05:07.230 --> 00:05:09.870
So at that point, there
is an Autofill [? infra ?]

00:05:09.870 --> 00:05:11.910
running on the app the process.

00:05:11.910 --> 00:05:15.120
And that [? infra ?] is
going to create a customized

00:05:15.120 --> 00:05:18.870
version of the very structure
that is optimized for Autofill.

00:05:18.870 --> 00:05:21.290
Then it will send this view
structure back to the Android

00:05:21.290 --> 00:05:25.140
system, where the Android
system will sanitize the data

00:05:25.140 --> 00:05:28.140
by stripping out sensitive
[? valleys. ?] Next,

00:05:28.140 --> 00:05:31.650
the Android system sends the
data to the Autofill service.

00:05:31.650 --> 00:05:34.200
Now, here is the part where
things got interesting

00:05:34.200 --> 00:05:36.210
from an API point of view.

00:05:36.210 --> 00:05:38.730
The Autofill service will
parse this view's structure,

00:05:38.730 --> 00:05:41.820
and will look for fields
that can be autofilled.

00:05:41.820 --> 00:05:44.310
Then it will look on the
user data for that app

00:05:44.310 --> 00:05:46.230
and see if there is a match.

00:05:46.230 --> 00:05:48.960
If there is a match, then it
creates another data structure

00:05:48.960 --> 00:05:50.520
called data set.

00:05:50.520 --> 00:05:54.750
And sends that data set
over to the Android system.

00:05:54.750 --> 00:05:56.550
At this point,
the Android system

00:05:56.550 --> 00:05:58.560
is able to Autofill your app.

00:05:58.560 --> 00:06:01.770
But it doesn't do that
without the user confirmation.

00:06:01.770 --> 00:06:05.320
So what it does instead, it
shows an Autofill dialog,

00:06:05.320 --> 00:06:07.890
with the Options
sent by the service.

00:06:07.890 --> 00:06:10.470
And only after the
user selects an Option,

00:06:10.470 --> 00:06:13.399
we send that data
set back to the app.

00:06:13.399 --> 00:06:14.940
And then the Autofill
infrastructure,

00:06:14.940 --> 00:06:17.400
we will automatically
set the views

00:06:17.400 --> 00:06:19.680
and change the
background colors to show

00:06:19.680 --> 00:06:22.260
that the view was Autofilled.

00:06:22.260 --> 00:06:24.500
So this workflow
works pretty fast.

00:06:24.500 --> 00:06:25.840
It's pretty fast.

00:06:25.840 --> 00:06:28.410
Like we saw in the demo,
the Autofill dialog

00:06:28.410 --> 00:06:32.040
comes out almost at the same
time as the keyboard itself.

00:06:32.040 --> 00:06:34.320
But this workflow has a catch.

00:06:34.320 --> 00:06:37.800
It only works if the Autofill
service can figure out what

00:06:37.800 --> 00:06:40.470
can be autofilled in your app.

00:06:40.470 --> 00:06:43.650
Generally speaking, the password
managers have good heuristics,

00:06:43.650 --> 00:06:45.240
And they can pretty
much figure out

00:06:45.240 --> 00:06:47.640
how to Autofill almost any app.

00:06:47.640 --> 00:06:50.010
But they don't want to
rely only on the heuristics

00:06:50.010 --> 00:06:51.320
to make it work.

00:06:51.320 --> 00:06:54.620
It's better if you
can tell them for sure

00:06:54.620 --> 00:06:57.390
what can be Autofilled
on their app and how.

00:06:57.390 --> 00:06:59.940
It's also nice to help the
Android system to optimize

00:06:59.940 --> 00:07:01.882
the workflow by
telling which fields

00:07:01.882 --> 00:07:03.840
should be ignored because
they don't make sense

00:07:03.840 --> 00:07:06.250
to be Autofilled.

00:07:06.250 --> 00:07:08.010
You can accomplish
both these goals

00:07:08.010 --> 00:07:11.774
by simply annotating our
active XML with Autofill text,

00:07:11.774 --> 00:07:13.440
as we're going to see
on the next slide,

00:07:13.440 --> 00:07:15.990
using a very simple
log-in screen example.

00:07:20.280 --> 00:07:22.850
So this log-in screen has
three editable fields.

00:07:22.850 --> 00:07:26.250
There is a Username and Password
and a CAPTCHA challenge.

00:07:26.250 --> 00:07:29.320
The Username and
Password are the fields

00:07:29.320 --> 00:07:32.280
that really make sense
to be Autofilled,

00:07:32.280 --> 00:07:34.950
while the CAPTCHA is something
the user has to type in

00:07:34.950 --> 00:07:38.010
to prove that the user is
a human being, or a tree,

00:07:38.010 --> 00:07:40.440
in this case, and not a robot.

00:07:40.440 --> 00:07:44.460
So without further ado,
let's take a look at the XML.

00:07:44.460 --> 00:07:46.440
The first and most
important tag you can use,

00:07:46.440 --> 00:07:48.540
it's called Autofill hints.

00:07:48.540 --> 00:07:50.550
This tag tells the
Autofill service

00:07:50.550 --> 00:07:53.130
what is the meaning of our
view, or what kind of user

00:07:53.130 --> 00:07:57.630
information that the service
can use to fill your view.

00:07:57.630 --> 00:08:00.170
For example, on
our password field,

00:08:00.170 --> 00:08:03.230
there is only one way to
fill that info, which it

00:08:03.230 --> 00:08:04.650
is using the user's password.

00:08:04.650 --> 00:08:08.250
So we say out Autofill
hints equals password.

00:08:08.250 --> 00:08:12.630
But on our username, our
app allows either a Username

00:08:12.630 --> 00:08:13.880
or email address.

00:08:13.880 --> 00:08:16.320
But we don't know in
advance which of these two

00:08:16.320 --> 00:08:18.290
informations the
Autofill service it has.

00:08:18.290 --> 00:08:21.090
So it's better to give the
Autofill service a choice.

00:08:21.090 --> 00:08:23.290
So we put all values
that are possible here.

00:08:23.290 --> 00:08:26.890
So we say Username,
email address.

00:08:26.890 --> 00:08:29.670
The Autofill hints
can take any string.

00:08:29.670 --> 00:08:31.260
You can have
something as bizarre

00:08:31.260 --> 00:08:34.590
as my dog's favorite color
while on vacation in California,

00:08:34.590 --> 00:08:36.510
last year, during the drought.

00:08:36.510 --> 00:08:39.090
But these hints are only useful
if the service understand

00:08:39.090 --> 00:08:40.450
what they mean.

00:08:40.450 --> 00:08:42.549
So we provide the
constants in view.java

00:08:42.549 --> 00:08:45.531
for the most common cases
like Username, Email Address,

00:08:45.531 --> 00:08:48.030
Telephone Number, Credit Card
number, Credit Card Expiration

00:08:48.030 --> 00:08:48.750
Date.

00:08:48.750 --> 00:08:52.890
So it's better if you try to
use this constant as that.

00:08:52.890 --> 00:08:56.480
The next tag is called
Important for Autofill.

00:08:56.480 --> 00:08:58.860
This tag is used by
the Android system

00:08:58.860 --> 00:09:02.910
to optimize the workflow.

00:09:02.910 --> 00:09:04.890
So basically, it tells
the Android system

00:09:04.890 --> 00:09:08.040
whether the view should
trigger the Autofill workflow,

00:09:08.040 --> 00:09:09.630
and whether the
contents of the view

00:09:09.630 --> 00:09:12.470
should be included in
the view structure that's

00:09:12.470 --> 00:09:14.670
sent over to the service.

00:09:14.670 --> 00:09:19.230
So in our example, we can
mark the CAPTCHA editor

00:09:19.230 --> 00:09:21.750
test important for
Autofill equals no.

00:09:21.750 --> 00:09:25.110
That means that when the
Autofill workflow is triggered

00:09:25.110 --> 00:09:28.710
by the Username and Password,
we don't send the CAPTCHA over.

00:09:28.710 --> 00:09:31.950
So this might sound like a
small, minor improvement.

00:09:31.950 --> 00:09:35.100
But remember, this is running
on our mobile environment, where

00:09:35.100 --> 00:09:37.890
every little
optimization counts.

00:09:37.890 --> 00:09:40.449
In fact, there
might be cases where

00:09:40.449 --> 00:09:42.740
the whole activity doesn't
make sense to be Autofilled.

00:09:42.740 --> 00:09:44.750
For example, in a
spreadsheet editor

00:09:44.750 --> 00:09:46.770
like the one in Google Drive.

00:09:46.770 --> 00:09:50.400
In this case, you can mark
the root view of your activity

00:09:50.400 --> 00:09:53.730
with an importantForAutoFill
equals noExcludeDescendants.

00:09:53.730 --> 00:09:56.140
And that pretty much is
telling the Android system

00:09:56.140 --> 00:09:57.880
that no view inside
the directive

00:09:57.880 --> 00:10:02.140
should automatically
trigger Autofill.

00:10:02.140 --> 00:10:04.740
Just keep in mind that
an important for Autofill

00:10:04.740 --> 00:10:08.500
is an optimization hint, another
way to effectively disable

00:10:08.500 --> 00:10:10.540
Autofill on your app.

00:10:10.540 --> 00:10:14.170
The user can always bypass
your decision, your hint,

00:10:14.170 --> 00:10:16.060
by manually requesting Autofill.

00:10:16.060 --> 00:10:19.540
For example, the user can
long-press the Edit Text,

00:10:19.540 --> 00:10:22.870
and then select the Autofill
option in the Overflow menu.

00:10:22.870 --> 00:10:25.490
And when that happens, not only
will it trigger the Autofill

00:10:25.490 --> 00:10:28.510
workflow, but it will send
over all views, including

00:10:28.510 --> 00:10:31.140
those marked as not important.

00:10:31.140 --> 00:10:33.610
So this is pretty much
the two easiest ways

00:10:33.610 --> 00:10:36.950
you can optimize your
apps for Autofill.

00:10:36.950 --> 00:10:40.240
There are other tags and
Java API's that you can use.

00:10:40.240 --> 00:10:42.960
But we didn't have time to
show in the presentation.

00:10:42.960 --> 00:10:45.820
But they are available on
the official documentations,

00:10:45.820 --> 00:10:47.790
on the official docs
for the Autofill.

00:10:47.790 --> 00:10:51.378
Now, back to Akshay,
for more tips.

00:10:51.378 --> 00:10:53.590
AKSHAY KANNAN: Thanks, Felipe.

00:10:53.590 --> 00:10:56.740
As we mentioned earlier, along
with introducing the Autofill

00:10:56.740 --> 00:10:59.200
framework in Android, we're
launching our own Autofill

00:10:59.200 --> 00:11:01.990
service that comes bundled
with O Devices, Autofill

00:11:01.990 --> 00:11:03.220
with Google.

00:11:03.220 --> 00:11:05.650
Of the nice things about
Autofill with Google

00:11:05.650 --> 00:11:08.530
is that your data is synced
between the Chrome browser

00:11:08.530 --> 00:11:10.870
and the mobile
apps that you use.

00:11:10.870 --> 00:11:12.730
In order for this
to work, you need

00:11:12.730 --> 00:11:16.270
to claim the association
between your mobile app

00:11:16.270 --> 00:11:17.050
and your website.

00:11:17.050 --> 00:11:19.577
And you can do this using
digital asset linking.

00:11:19.577 --> 00:11:21.910
If you've used other things
like App Linking in Android,

00:11:21.910 --> 00:11:24.160
you might be familiar
with this already.

00:11:24.160 --> 00:11:27.190
Basically, for Autofill,
this enables any web logins

00:11:27.190 --> 00:11:31.600
that are saved using Chrome to
work with mobile apps and vice

00:11:31.600 --> 00:11:32.620
versa.

00:11:32.620 --> 00:11:35.140
And basically, in order to
make this association work,

00:11:35.140 --> 00:11:38.480
there's just two steps involved.

00:11:38.480 --> 00:11:41.350
So the first step is to host
some JSON on your web server,

00:11:41.350 --> 00:11:45.040
at yourdomain/.well
known./assetlinks.json.

00:11:45.040 --> 00:11:47.009
And this tells us
about the mobile apps

00:11:47.009 --> 00:11:48.550
that are associated
with your domain,

00:11:48.550 --> 00:11:50.008
along with the
permissions that you

00:11:50.008 --> 00:11:51.800
want to share with those apps.

00:11:51.800 --> 00:11:54.070
Here, you explicitly
define the permissions

00:11:54.070 --> 00:11:55.630
that you want to have shared.

00:11:55.630 --> 00:11:58.310
So in this case on
the slide, there is

00:11:58.310 --> 00:12:01.760
the common.get_login_creds
permission,

00:12:01.760 --> 00:12:05.250
which enables your credentials
to be shared from your website

00:12:05.250 --> 00:12:07.150
to your mobile app.

00:12:07.150 --> 00:12:08.660
In addition to
credential sharing,

00:12:08.660 --> 00:12:10.660
there's many other
permissions that you can also

00:12:10.660 --> 00:12:13.480
grant to your app
using the same JSON.

00:12:13.480 --> 00:12:16.760
For example, there's also the
Handle All URLs permission,

00:12:16.760 --> 00:12:19.390
which lets your app handle
incoming web links via app

00:12:19.390 --> 00:12:22.180
linking, so that your users
can seamlessly open links

00:12:22.180 --> 00:12:26.060
that your app was
designed to handle.

00:12:26.060 --> 00:12:28.240
The next step, once
you've hosted this JSON

00:12:28.240 --> 00:12:31.430
on your server, is to define
the corresponding association

00:12:31.430 --> 00:12:32.660
in your mobile app.

00:12:32.660 --> 00:12:35.510
And you can do this by
modifying your apps manifest.

00:12:35.510 --> 00:12:37.100
To enable credential
sharing, you

00:12:37.100 --> 00:12:40.440
need to add the following
metadata tag to your manifest.

00:12:40.440 --> 00:12:43.070
Here, Android string
assets statements

00:12:43.070 --> 00:12:45.500
points to a JSON
string resource that

00:12:45.500 --> 00:12:48.140
contains a list of web
targets and permissions,

00:12:48.140 --> 00:12:50.540
similar to what you
hosted on your web site.

00:12:50.540 --> 00:12:51.620
And that's it.

00:12:51.620 --> 00:12:53.270
With these two
steps, you can share

00:12:53.270 --> 00:12:56.360
credentials between your web
site and your mobile app.

00:12:56.360 --> 00:12:57.740
This works for Autofill.

00:12:57.740 --> 00:13:00.290
And it also works for
Smart Lock for Passwords,

00:13:00.290 --> 00:13:03.734
which lets you automatically
sign in your users.

00:13:03.734 --> 00:13:05.150
Now, I'm going to
hand things over

00:13:05.150 --> 00:13:07.310
to Simranjit, who's going
to talk more about how

00:13:07.310 --> 00:13:10.040
you can enable Automatic
Sign-in for your users

00:13:10.040 --> 00:13:12.459
in further detail.

00:13:12.459 --> 00:13:13.792
SIMRANJIT KOHLI: Thanks, Akshay.

00:13:16.890 --> 00:13:19.710
We want our users to get as
much value out of their device

00:13:19.710 --> 00:13:21.560
as quickly as possible.

00:13:21.560 --> 00:13:24.930
A lot of that value is
associated with their accounts.

00:13:24.930 --> 00:13:27.720
So we have provided
a set of APIs

00:13:27.720 --> 00:13:30.690
to make user log-ins
easy and seamless.

00:13:30.690 --> 00:13:33.200
The first one is Smart
Lock for Passwords,

00:13:33.200 --> 00:13:35.560
which was introduced last year.

00:13:35.560 --> 00:13:38.100
The second one is
Account Transfer API,

00:13:38.100 --> 00:13:40.530
which will be released in an
upcoming Google Play Services

00:13:40.530 --> 00:13:41.730
update.

00:13:41.730 --> 00:13:43.680
There are benefits
to each of them

00:13:43.680 --> 00:13:47.670
that we look at as we move on.

00:13:47.670 --> 00:13:51.480
The first API we discuss here
is Smart Lock for Passwords.

00:13:51.480 --> 00:13:54.450
It allows for automatic sign-in
and skipping password forms

00:13:54.450 --> 00:13:55.660
completely.

00:13:55.660 --> 00:13:59.940
It syncs with passwords stored
in users' Chrome profile.

00:13:59.940 --> 00:14:03.630
As a result, it persists
across app installs.

00:14:03.630 --> 00:14:05.930
It has some differences
from Autofill.

00:14:05.930 --> 00:14:09.470
While Autofill is only support
supported Android O onwards,

00:14:09.470 --> 00:14:12.030
Smart Lock is backward
compatible with ICS,

00:14:12.030 --> 00:14:14.580
and delivered via
Google Play Services.

00:14:14.580 --> 00:14:17.340
With Smart Lock,
users can be logged

00:14:17.340 --> 00:14:21.950
into your app programmatically
without any user input.

00:14:21.950 --> 00:14:25.590
Here, as you can see in the
Netflix example on the slide,

00:14:25.590 --> 00:14:27.610
user did not have
to do anything.

00:14:27.610 --> 00:14:29.550
They just opened
their Netflix app.

00:14:29.550 --> 00:14:33.240
Netflix makes the API call,
gets the credential result,

00:14:33.240 --> 00:14:35.670
verifies the credential
with the server,

00:14:35.670 --> 00:14:38.130
and signs-in a
user automatically.

00:14:38.130 --> 00:14:43.340
In this case, log-in screen
can be skipped completely.

00:14:43.340 --> 00:14:46.620
With Autofill, user at least
has to tap into the fields

00:14:46.620 --> 00:14:49.070
in order to populate them.

00:14:49.070 --> 00:14:53.040
Smart Lock also provides
advanced security feature.

00:14:53.040 --> 00:14:55.080
There are two major
flows associated

00:14:55.080 --> 00:14:57.720
with this API, retrieving
credentials and saving

00:14:57.720 --> 00:14:59.500
credentials.

00:14:59.500 --> 00:15:03.030
Here's how to retrieve
credentials using the Request

00:15:03.030 --> 00:15:04.200
API.

00:15:04.200 --> 00:15:06.780
If the credential was
already available,

00:15:06.780 --> 00:15:08.640
you get success on the callback.

00:15:08.640 --> 00:15:10.740
And you can sign-in
user immediately,

00:15:10.740 --> 00:15:14.670
as was shown in the Netflix
example in the previous slide.

00:15:14.670 --> 00:15:17.340
The other cases
require user action,

00:15:17.340 --> 00:15:20.280
which are triggered by
launching relevant intent.

00:15:20.280 --> 00:15:22.950
If the user has
multiple credentials,

00:15:22.950 --> 00:15:25.710
they can pick the
credential they want to use.

00:15:25.710 --> 00:15:27.930
If there are no
credential available,

00:15:27.930 --> 00:15:31.260
they get a dialog to select
email address or phone number

00:15:31.260 --> 00:15:35.190
to sign-in or sign-up with.

00:15:35.190 --> 00:15:37.470
Here's an example of a save API.

00:15:37.470 --> 00:15:40.160
If the credentials were
already saved previously,

00:15:40.160 --> 00:15:42.700
and you are making a
call to updating them,

00:15:42.700 --> 00:15:45.140
the callback results
in a success.

00:15:45.140 --> 00:15:47.660
But to save a new
password, the user

00:15:47.660 --> 00:15:50.660
must give consent for the
credential to be saved.

00:15:50.660 --> 00:15:53.450
In this scenario, you have
to call start resolution

00:15:53.450 --> 00:15:56.460
for result.

00:15:56.460 --> 00:15:58.970
Additionally, the responses
from Smart Lock API

00:15:58.970 --> 00:16:02.180
also includes a signed
JSON web ID token,

00:16:02.180 --> 00:16:05.840
if Google has verified
the user's email address.

00:16:05.840 --> 00:16:07.640
You can use this
token on your server

00:16:07.640 --> 00:16:10.520
to verify user's email
address, and sign them

00:16:10.520 --> 00:16:12.290
in without a password.

00:16:12.290 --> 00:16:15.990
Or you can use it as a
strong positive signal

00:16:15.990 --> 00:16:18.680
in anti-abuse algorithms.

00:16:18.680 --> 00:16:21.110
Also, check out the talk
later today on phone auth,

00:16:21.110 --> 00:16:24.470
which will cover a new
Smart Lock API to verify

00:16:24.470 --> 00:16:28.870
phone numbers via SMS messages.

00:16:28.870 --> 00:16:33.170
Now, let's talk about a second
API, the Account Transfer API.

00:16:33.170 --> 00:16:35.470
While setting up your
new Android device,

00:16:35.470 --> 00:16:37.405
you might have seen
the following flow,

00:16:37.405 --> 00:16:40.630
where it gives you an
option to copy your data

00:16:40.630 --> 00:16:42.790
from your existing phone.

00:16:42.790 --> 00:16:46.600
Initially, introduced a tap
and go in Lollipop release,

00:16:46.600 --> 00:16:49.510
this flow allows you to
copy your Google accounts

00:16:49.510 --> 00:16:52.350
from your existing device
to your new device.

00:16:52.350 --> 00:16:56.950
We thought about how we can make
it more seamless for our users

00:16:56.950 --> 00:16:59.140
to get started on
their new device.

00:16:59.140 --> 00:17:01.870
And we came up with
Account Transfer API

00:17:01.870 --> 00:17:04.660
to help transfer
non-Google accounts also

00:17:04.660 --> 00:17:06.760
during the setup process.

00:17:06.760 --> 00:17:08.380
After you select
that you are copying

00:17:08.380 --> 00:17:13.060
your data from another
device, our flow kicks in.

00:17:13.060 --> 00:17:14.650
As you saw in the
previous slide,

00:17:14.650 --> 00:17:16.910
Account Transfer API
transfers credentials

00:17:16.910 --> 00:17:19.089
during the setup of the device.

00:17:19.089 --> 00:17:21.160
It's a device to
device transfer.

00:17:21.160 --> 00:17:23.440
Some organizations
don't allow the storage

00:17:23.440 --> 00:17:26.030
of the users' credentials
on their servers,

00:17:26.030 --> 00:17:29.000
due to the nature of
their security policy.

00:17:29.000 --> 00:17:33.260
So in that case, this
API is very useful.

00:17:33.260 --> 00:17:36.700
Also, there is no dependency
on Google accounts.

00:17:36.700 --> 00:17:39.230
If you are an identity
provider, this API

00:17:39.230 --> 00:17:42.320
provides a lot of benefits.

00:17:42.320 --> 00:17:44.990
It is only available to
Android authenticators.

00:17:44.990 --> 00:17:48.150
Authenticators are apps which
implement Android Account

00:17:48.150 --> 00:17:51.256
Authenticator, and integrate
with account manager

00:17:51.256 --> 00:17:52.255
on the Android platform.

00:17:55.130 --> 00:17:57.610
Account Transfer API
provides an encrypted channel

00:17:57.610 --> 00:17:59.800
between participating
authenticators

00:17:59.800 --> 00:18:02.490
on a user's existing
and new device.

00:18:02.490 --> 00:18:04.600
This encrypted
pipe is established

00:18:04.600 --> 00:18:09.050
by Google Play Services,
running on both these devices.

00:18:09.050 --> 00:18:10.525
Apps can do two-way
communication

00:18:10.525 --> 00:18:12.970
over this encrypted
channel, if they are also

00:18:12.970 --> 00:18:15.280
present on the new device.

00:18:15.280 --> 00:18:18.120
But if the app is not
present on the new device,

00:18:18.120 --> 00:18:20.740
transfer credentials are
held in temporary storage.

00:18:24.240 --> 00:18:26.430
If your app is pre-installed
on the new device,

00:18:26.430 --> 00:18:29.580
here is how it looks.

00:18:29.580 --> 00:18:31.320
You can send
messages from source

00:18:31.320 --> 00:18:33.990
to target, and from
target to source,

00:18:33.990 --> 00:18:36.780
establishing a
two-way communication.

00:18:36.780 --> 00:18:40.710
You can perform key exchanges or
perform cryptographic challenge

00:18:40.710 --> 00:18:42.480
response flows.

00:18:42.480 --> 00:18:44.370
Google Play Services
running onboard

00:18:44.370 --> 00:18:47.970
these devices notifies you of
available data on that device

00:18:47.970 --> 00:18:50.920
by a broadcast.

00:18:50.920 --> 00:18:54.460
However, if your app is not
installed on the target device,

00:18:54.460 --> 00:18:57.970
the credentials sent from your
app on the source to the target

00:18:57.970 --> 00:19:00.250
are stored in temporary storage.

00:19:00.250 --> 00:19:04.180
When your app gets installed,
and is open for the first time,

00:19:04.180 --> 00:19:05.980
make a call to our
API to retrieve

00:19:05.980 --> 00:19:09.990
the transferred-over
credentials.

00:19:09.990 --> 00:19:12.780
To participate in
this API, you need

00:19:12.780 --> 00:19:15.460
to register these
broadcasts in your manifest.

00:19:15.460 --> 00:19:17.570
This slide shows
which broadcasts

00:19:17.570 --> 00:19:19.170
are active on the
source and which

00:19:19.170 --> 00:19:21.750
ones are active on the target.

00:19:21.750 --> 00:19:24.940
If your app doesn't come
pre-installed on any OEM system

00:19:24.940 --> 00:19:31.280
image, you only need
START_ACCOUNT_EXPORT broadcast.

00:19:31.280 --> 00:19:34.400
Here is a sample code that will
be called on your users' source

00:19:34.400 --> 00:19:35.550
device.

00:19:35.550 --> 00:19:37.790
When source-side
broadcast is triggered,

00:19:37.790 --> 00:19:39.740
you should start a new service.

00:19:39.740 --> 00:19:43.880
In the service, you first get
a handle to the API object.

00:19:43.880 --> 00:19:47.510
And then send the user
credentials in byte format,

00:19:47.510 --> 00:19:49.820
using the same data API.

00:19:49.820 --> 00:19:53.550
In case there is a failure,
notify about it to our API.

00:19:56.260 --> 00:19:58.540
On the target side,
you can retrieve

00:19:58.540 --> 00:20:00.490
the data that was sent over.

00:20:00.490 --> 00:20:03.160
Here also, when your
broadcast is triggered,

00:20:03.160 --> 00:20:04.470
you should start a service.

00:20:04.470 --> 00:20:07.750
In the service,
grab the API object.

00:20:07.750 --> 00:20:10.630
And then make the
retrieve data API call

00:20:10.630 --> 00:20:13.850
and retrieve the byte data
that was transferred over.

00:20:13.850 --> 00:20:16.630
Convert this byte data to your
credentials using your custom

00:20:16.630 --> 00:20:17.410
logic.

00:20:17.410 --> 00:20:22.030
And then add the account on the
device using Account Manager

00:20:22.030 --> 00:20:23.680
API.

00:20:23.680 --> 00:20:29.000
Finally, notify our API
about success or failure.

00:20:29.000 --> 00:20:30.780
This is a simplistic
example, where

00:20:30.780 --> 00:20:33.040
only one-way communication
is happening.

00:20:33.040 --> 00:20:36.550
Source sends the data
and target retrieves it.

00:20:36.550 --> 00:20:38.800
This is sufficient
for many apps,

00:20:38.800 --> 00:20:43.810
like apps managing email,
IMAP, POP3 accounts.

00:20:43.810 --> 00:20:46.390
The same code can be
used if the app is not

00:20:46.390 --> 00:20:48.940
installed on the target,
and when the user opens

00:20:48.940 --> 00:20:50.950
the app for the first time.

00:20:50.950 --> 00:20:53.920
However, in this case,
you can send the data back

00:20:53.920 --> 00:20:55.810
to the source.

00:20:55.810 --> 00:20:59.800
Also, make sure not to call
this API from your main thread.

00:20:59.800 --> 00:21:02.910
Now I will hand it over to
Akshay to discuss Android Pay

00:21:02.910 --> 00:21:04.990
and Backup API's.

00:21:04.990 --> 00:21:07.000
AKSHAY KANNAN:
Thanks, Simranjit.

00:21:07.000 --> 00:21:09.730
So in the last few
slides, you learned about

00:21:09.730 --> 00:21:11.590
how you can
automatically sign users

00:21:11.590 --> 00:21:14.110
in using Smart
Lock for Passwords,

00:21:14.110 --> 00:21:16.090
or how you can securely
transfer credentials

00:21:16.090 --> 00:21:18.700
from your old device to your
new device using the upcoming

00:21:18.700 --> 00:21:20.770
Account Transfer API.

00:21:20.770 --> 00:21:24.700
Similarly, for Payments
also, we offer a set of APIs

00:21:24.700 --> 00:21:27.220
to help you get this
information automatically,

00:21:27.220 --> 00:21:28.610
on behalf of the user.

00:21:28.610 --> 00:21:31.812
And similarly, this also extends
down to older Android versions.

00:21:31.812 --> 00:21:33.520
So you don't have to
depend on your users

00:21:33.520 --> 00:21:35.830
running Autofill on Android O.

00:21:35.830 --> 00:21:38.860
Currently, we have the
Android Pay API today, which

00:21:38.860 --> 00:21:40.300
gives you Android Pay Cards.

00:21:40.300 --> 00:21:42.040
But as you heard in
the payment session,

00:21:42.040 --> 00:21:45.280
we'll be introducing the Google
Payments API in the coming

00:21:45.280 --> 00:21:48.820
weeks to extend this API to
include all of the cards tied

00:21:48.820 --> 00:21:51.670
to a user's Google account,
not just the ones that they

00:21:51.670 --> 00:21:53.650
have using Android Pay.

00:21:53.650 --> 00:21:56.230
And best of all, there's
no commission or fees

00:21:56.230 --> 00:21:59.200
involved at all in
using any of these APIs.

00:21:59.200 --> 00:22:02.650
To make this work, there's
basically three steps involved.

00:22:02.650 --> 00:22:05.190
First thing you do, is
you request MaskedWallet.

00:22:05.190 --> 00:22:09.200
And that shows a dialog similar
to the one in the screenshot

00:22:09.200 --> 00:22:10.420
you can see on the slide.

00:22:10.420 --> 00:22:13.150
And this lets the user
pick a form of payment.

00:22:13.150 --> 00:22:15.400
Once they've selected one,
you can handle the response

00:22:15.400 --> 00:22:18.220
from this, and use that to
present a final confirmation

00:22:18.220 --> 00:22:20.440
to your user, confirming
the amount, what they're

00:22:20.440 --> 00:22:22.570
going to be ordering,
and the method of payment

00:22:22.570 --> 00:22:24.010
they selected.

00:22:24.010 --> 00:22:26.080
And then once the
user confirms this,

00:22:26.080 --> 00:22:28.480
you can request a Full Wallet.

00:22:28.480 --> 00:22:31.450
And what that does is that
gives you the credentials

00:22:31.450 --> 00:22:35.060
that you need to
complete the transaction.

00:22:35.060 --> 00:22:36.760
So that's it for payment API's.

00:22:40.200 --> 00:22:43.430
So in the whole first
part of this presentation,

00:22:43.430 --> 00:22:46.580
we've talked a lot about
using existing information

00:22:46.580 --> 00:22:48.350
that the user
already has provided

00:22:48.350 --> 00:22:51.260
to speed up critical forms
and flows in your apps.

00:22:51.260 --> 00:22:54.560
Whether it's logins, or
payments, or anything else.

00:22:54.560 --> 00:22:57.770
In the second part, we're
going to focus on using backup

00:22:57.770 --> 00:23:02.030
and restore to reduce churn
when your users switch devices,

00:23:02.030 --> 00:23:05.910
or if they reinstall their
app on the same device.

00:23:05.910 --> 00:23:07.809
Even if someone's
using a new device,

00:23:07.809 --> 00:23:09.600
our goal is to make it
feel like they never

00:23:09.600 --> 00:23:10.740
stopped using your app.

00:23:14.990 --> 00:23:18.070
So as we mentioned before,
throwing up a blank login

00:23:18.070 --> 00:23:21.370
screen the first time
an existing user uses

00:23:21.370 --> 00:23:25.060
your app on a new device
can create unnecessary churn

00:23:25.060 --> 00:23:27.830
and stop users from reengaging.

00:23:27.830 --> 00:23:29.570
If they've already
used your app,

00:23:29.570 --> 00:23:32.030
you can skip your welcome
flow, pre-populate

00:23:32.030 --> 00:23:35.180
log-in information, and
transfer over settings

00:23:35.180 --> 00:23:38.840
and any other states to give
your users a warm welcome and a

00:23:38.840 --> 00:23:41.900
seamless transition
onto their new device.

00:23:41.900 --> 00:23:45.512
The goal is to preserve as much
of your app state as possible

00:23:45.512 --> 00:23:47.345
so that your users
continue to stay engaged.

00:23:51.570 --> 00:23:54.640
We offer two API's
for doing this.

00:23:54.640 --> 00:23:57.210
There is the Auto
Backup API, which,

00:23:57.210 --> 00:23:59.910
as you'll see in the next
slide, is extremely low effort

00:23:59.910 --> 00:24:00.720
for developers.

00:24:00.720 --> 00:24:03.450
It's basically a line of code
that you add to your manifest.

00:24:03.450 --> 00:24:06.860
And it backs up everything
in your app, wholesale.

00:24:06.860 --> 00:24:09.470
For a more fine-grain
control over exactly what

00:24:09.470 --> 00:24:11.570
gets backed up in
your app, we recommend

00:24:11.570 --> 00:24:13.910
using Key/Value Backup.

00:24:13.910 --> 00:24:15.890
This works on Froyo and above.

00:24:15.890 --> 00:24:18.170
So pretty much all
active Android devices

00:24:18.170 --> 00:24:22.940
today are supported, assuming
a user has Backup turned on.

00:24:22.940 --> 00:24:24.632
We'll talk through
both of these API's.

00:24:24.632 --> 00:24:26.840
We'll explain how you use
them, and talk through some

00:24:26.840 --> 00:24:29.930
of the trade-offs between them.

00:24:29.930 --> 00:24:32.500
Let's start by talking
about the Auto Backup API.

00:24:32.500 --> 00:24:34.040
As we mentioned
in the last slide,

00:24:34.040 --> 00:24:36.670
it's extremely low effort for
developers to add to your app.

00:24:36.670 --> 00:24:38.680
You just add this single
line to your manifest

00:24:38.680 --> 00:24:40.840
that you can see on the
slide, and everything

00:24:40.840 --> 00:24:44.050
gets backed up wholesale,
including shared preferences,

00:24:44.050 --> 00:24:46.570
your files, and your databases.

00:24:46.570 --> 00:24:50.470
In addition, you can also define
custom XML include and exclude

00:24:50.470 --> 00:24:54.320
rules to control exactly
what gets backed up.

00:24:54.320 --> 00:24:57.320
All of this data gets
persisted in a private folder

00:24:57.320 --> 00:24:58.970
in the users' Google
Drive account,

00:24:58.970 --> 00:25:02.870
which is limited to 25
megabytes per user, per app.

00:25:02.870 --> 00:25:05.420
This doesn't count towards
the users' Drive storage.

00:25:05.420 --> 00:25:07.802
And only the most recent
backup ever gets stored.

00:25:07.802 --> 00:25:09.260
So every time
there's a new backup,

00:25:09.260 --> 00:25:12.570
it overrides the
previous backup.

00:25:12.570 --> 00:25:15.630
That being said, auto backup
is limited to Marshmallow

00:25:15.630 --> 00:25:16.680
and above.

00:25:16.680 --> 00:25:19.830
And if you want broader support,
or more fine-grained control

00:25:19.830 --> 00:25:21.579
over exactly what
gets backed up,

00:25:21.579 --> 00:25:24.120
you're going to want to use the
Key/Value Backup API instead.

00:25:26.990 --> 00:25:30.740
The Android Key/Value Backup
lets you preserve your app data

00:25:30.740 --> 00:25:33.500
by uploading it to
Android's backup service.

00:25:33.500 --> 00:25:36.620
The amount of data is limited
to five megabytes per user,

00:25:36.620 --> 00:25:39.275
per app, and it's available
completely free of charge.

00:25:41.840 --> 00:25:43.807
There's basically two
steps to make this work.

00:25:43.807 --> 00:25:45.390
You update your
manifest, and then you

00:25:45.390 --> 00:25:47.350
write the code to do the backup.

00:25:47.350 --> 00:25:49.580
In the first step, where
you update your manifest,

00:25:49.580 --> 00:25:52.640
you want to point to the backup
agent, which in this case,

00:25:52.640 --> 00:25:55.490
is my backup agent, which
we'll define in the next slide.

00:25:55.490 --> 00:25:57.840
And you want to register for
the Android Backup Service

00:25:57.840 --> 00:26:00.440
in the API console, which gives
you an API key that you can

00:26:00.440 --> 00:26:01.760
Copy/Paste into your manifest.

00:26:04.390 --> 00:26:06.910
Next, once you've
updated your manifest,

00:26:06.910 --> 00:26:09.500
you want to actually
define your backup agent.

00:26:09.500 --> 00:26:12.130
And this is the code that
actually does the backup.

00:26:12.130 --> 00:26:16.060
In most cases, rather than
extending BackupAgent directly,

00:26:16.060 --> 00:26:18.400
you can extend
BackupAgentHelper,

00:26:18.400 --> 00:26:21.490
and use the two included helpers
that we've already provided,

00:26:21.490 --> 00:26:24.100
which are the Shared Preferences
Backup Helper for backing up

00:26:24.100 --> 00:26:27.130
shared preferences, and the
FileBackupHelper for backing up

00:26:27.130 --> 00:26:28.940
files.

00:26:28.940 --> 00:26:30.710
In the right, you can
look at an example

00:26:30.710 --> 00:26:31.710
of what this looks like.

00:26:31.710 --> 00:26:33.620
Basically, in the
onCreate method

00:26:33.620 --> 00:26:36.174
of your BackupAgentHelper,
you can instantiate

00:26:36.174 --> 00:26:38.090
one of these helpers
with the name of the file

00:26:38.090 --> 00:26:39.320
that you want to back up.

00:26:39.320 --> 00:26:41.150
And then you call
the addHelper method,

00:26:41.150 --> 00:26:44.690
which adds this helper to
your BackupAgentHelper.

00:26:44.690 --> 00:26:47.800
If you need further control
over versioning, file portions,

00:26:47.800 --> 00:26:51.135
or databases, you can extend
the BackupAgent directly,

00:26:51.135 --> 00:26:52.760
rather than using
our included helpers.

00:26:56.600 --> 00:26:58.370
So that's Backup and Restore.

00:26:58.370 --> 00:27:00.700
In this whole talk,
we've discussed

00:27:00.700 --> 00:27:03.160
a lot of API's to help
you streamline your apps,

00:27:03.160 --> 00:27:06.970
ranging from logins, to credit
cards, to Backup and Restore.

00:27:06.970 --> 00:27:09.160
Our vision with these
API's is to lower

00:27:09.160 --> 00:27:11.080
the barrier for
new users, and even

00:27:11.080 --> 00:27:13.330
existing users on an
old device, to start

00:27:13.330 --> 00:27:16.115
interacting with and
engaging with your app.

00:27:16.115 --> 00:27:18.490
We want to move to a world in
which your phone knows more

00:27:18.490 --> 00:27:21.670
about you, and it can provide
this information to other apps

00:27:21.670 --> 00:27:24.800
when you allow that information
to be provided to them.

00:27:24.800 --> 00:27:27.130
We want to make forms
a thing of the past.

00:27:27.130 --> 00:27:28.600
And as app
developers, you should

00:27:28.600 --> 00:27:31.120
be able to tap into information
that's already been provided

00:27:31.120 --> 00:27:34.480
by the user, rather than forcing
them to type it over and over

00:27:34.480 --> 00:27:36.980
again just so you can get it.

00:27:36.980 --> 00:27:39.230
Especially with instant
apps, upfront forms

00:27:39.230 --> 00:27:41.150
can significantly
hurt the experience

00:27:41.150 --> 00:27:44.400
and increase the friction that's
needed to try something new.

00:27:44.400 --> 00:27:47.360
So our goal with these
APIs is for mundane stuff

00:27:47.360 --> 00:27:50.030
like credential entry to
become a thing of the past.

00:27:50.030 --> 00:27:51.890
And if the user
purchases a new device,

00:27:51.890 --> 00:27:54.590
we want this information to stay
with them and move with them,

00:27:54.590 --> 00:27:56.923
so they don't feel like they're
starting all over again.

00:28:00.080 --> 00:28:04.450
So just to recap the key
takeaways from the whole talk,

00:28:04.450 --> 00:28:07.520
first and foremost, Autofill
is coming with Android O,

00:28:07.520 --> 00:28:09.170
as you saw in the demo.

00:28:09.170 --> 00:28:11.710
Please optimize your
apps for Autofill.

00:28:11.710 --> 00:28:13.810
You can annotate your
XML using the hints

00:28:13.810 --> 00:28:15.610
that Felipe talked about.

00:28:15.610 --> 00:28:17.230
And also, you can
use Digital Asset

00:28:17.230 --> 00:28:19.840
Linking to associate your
website and your mobile app,

00:28:19.840 --> 00:28:21.880
so that credentials can
be seamlessly shared

00:28:21.880 --> 00:28:23.610
between the two.

00:28:23.610 --> 00:28:26.730
Second, populate credentials
and payment information

00:28:26.730 --> 00:28:28.810
automatically when
it's available.

00:28:28.810 --> 00:28:32.610
You can use the Smart
Lock API to backup

00:28:32.610 --> 00:28:36.180
your username and password
associated with Chrome Sync.

00:28:36.180 --> 00:28:38.040
You can use the Android
Account Transfer API

00:28:38.040 --> 00:28:40.830
if you need a secure and
encrypted pipe during device

00:28:40.830 --> 00:28:41.940
setup.

00:28:41.940 --> 00:28:44.280
And you can use the
Android Pay API's today,

00:28:44.280 --> 00:28:47.460
and the Google Payment's
API's in the coming weeks

00:28:47.460 --> 00:28:49.710
to get payment
information from the user

00:28:49.710 --> 00:28:52.240
without any sort of commission.

00:28:52.240 --> 00:28:54.310
And thirdly, make
sure you persist

00:28:54.310 --> 00:28:56.920
your apps' data across devices.

00:28:56.920 --> 00:28:59.320
We talked about the
Auto Backup API's,

00:28:59.320 --> 00:29:01.240
which is extremely low
effort and backs up

00:29:01.240 --> 00:29:03.150
pretty much everything
in your app.

00:29:03.150 --> 00:29:05.500
And for more fine-grain
control, we also

00:29:05.500 --> 00:29:06.760
offer a Key/Value Backup.

00:29:09.880 --> 00:29:12.310
So this was a lot of APIs
that we talked about today.

00:29:12.310 --> 00:29:14.310
We have a short link
here on the slide

00:29:14.310 --> 00:29:16.620
that takes you to a doc,
where we've provided links

00:29:16.620 --> 00:29:18.990
to the developer documentations
for each of these APIs

00:29:18.990 --> 00:29:20.890
so you can learn more.

00:29:20.890 --> 00:29:23.130
Thank you so much for
coming out to our talk.

00:29:23.130 --> 00:29:25.560
Hopefully, you'll check
these APIs out and use them

00:29:25.560 --> 00:29:26.790
in your apps.

00:29:26.790 --> 00:29:27.660
Thank you so much.

00:29:27.660 --> 00:29:29.760
[APPLAUSE]

00:29:29.760 --> 00:29:32.810
[MUSIC PLAYING]

