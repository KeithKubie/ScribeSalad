WEBVTT
Kind: captions
Language: en

00:00:07.474 --> 00:00:09.140
RICHARD UHLER: My
name is Richard Uhler.

00:00:09.140 --> 00:00:13.160
I'm a software engineer on
the Android Runtime team.

00:00:13.160 --> 00:00:16.520
I spent the last three years
trying to better understand

00:00:16.520 --> 00:00:18.200
memory use on Android.

00:00:18.200 --> 00:00:20.720
And more recently, I've been
working with first party app

00:00:20.720 --> 00:00:23.930
developers to tackle the
challenges of evaluating

00:00:23.930 --> 00:00:26.300
and improving
Android memory use.

00:00:26.300 --> 00:00:28.220
It's great to see
so many of you here,

00:00:28.220 --> 00:00:31.670
interested in
Android memory use.

00:00:31.670 --> 00:00:35.540
To start off, why should
you, as an app developer,

00:00:35.540 --> 00:00:37.760
care about memory use?

00:00:37.760 --> 00:00:40.175
For me, it's really about
the Android ecosystem,

00:00:40.175 --> 00:00:44.120
the ecosystem of
applications, of devices,

00:00:44.120 --> 00:00:46.520
and of the users
of those devices.

00:00:46.520 --> 00:00:49.610
And where memory
comes into play is not

00:00:49.610 --> 00:00:51.350
so much for the
premium devices where

00:00:51.350 --> 00:00:53.780
you have a lot of memory
available, but much more

00:00:53.780 --> 00:00:55.880
for the entry level devices.

00:00:55.880 --> 00:00:59.420
Because these devices need a
decent selection of low memory

00:00:59.420 --> 00:01:01.100
apps to work well.

00:01:01.100 --> 00:01:05.510
If application memory use
and requirements grow,

00:01:05.510 --> 00:01:07.850
then the entry level
devices won't work as well.

00:01:07.850 --> 00:01:10.400
If they don't work as
well, OEMs will not

00:01:10.400 --> 00:01:12.170
want to produce these devices.

00:01:12.170 --> 00:01:13.910
And if they don't
produce these devices,

00:01:13.910 --> 00:01:17.000
well, we're kind of
excluding a bunch of users

00:01:17.000 --> 00:01:19.170
from our Android ecosystem.

00:01:19.170 --> 00:01:20.970
And that's a bad thing.

00:01:20.970 --> 00:01:23.150
So app developers
have a role to play

00:01:23.150 --> 00:01:25.730
when they're developing their
applications to do whatever

00:01:25.730 --> 00:01:29.150
they can to be efficient
in your memory use,

00:01:29.150 --> 00:01:32.210
to reduce your memory use,
keep it from growing too much,

00:01:32.210 --> 00:01:35.780
so that we have a nice selection
of low memory applications

00:01:35.780 --> 00:01:39.470
so that entry level devices
behave well, they work well.

00:01:39.470 --> 00:01:43.520
And if that happens, OEMs
will produce these devices

00:01:43.520 --> 00:01:45.590
and we can put them
in the hands of users

00:01:45.590 --> 00:01:49.200
to use our applications.

00:01:49.200 --> 00:01:51.560
So in this talk, I'm
going to talk about three

00:01:51.560 --> 00:01:53.660
broad categories, three areas.

00:01:53.660 --> 00:01:56.150
First, I'll talk about
the mechanisms that

00:01:56.150 --> 00:01:58.070
come into play on
an Android device

00:01:58.070 --> 00:02:02.350
when it's running low on memory,
and how that impacts the user.

00:02:02.350 --> 00:02:07.010
I'll talk about how we evaluate
an application's memory impact,

00:02:07.010 --> 00:02:09.440
and in particular, some
very important factors

00:02:09.440 --> 00:02:13.130
to be aware of that come
into play with that.

00:02:13.130 --> 00:02:15.810
And third, I will
give you some tips

00:02:15.810 --> 00:02:17.970
for how to reduce your
application's memory

00:02:17.970 --> 00:02:21.980
impact, especially given that a
lot of the allocations going on

00:02:21.980 --> 00:02:25.430
in your application originate
deep within the Android

00:02:25.430 --> 00:02:26.680
stack on which it's running.

00:02:30.570 --> 00:02:31.950
Let's start.

00:02:31.950 --> 00:02:36.420
What happens on a device when
it's running low on memory?

00:02:36.420 --> 00:02:39.740
Well, memory on device,
physical memory on device,

00:02:39.740 --> 00:02:42.630
is organized or
grouped into pages.

00:02:42.630 --> 00:02:46.260
And each page is typically
around four kilobytes.

00:02:46.260 --> 00:02:48.780
Different pages can be
used for different things.

00:02:48.780 --> 00:02:52.596
So pages can be used pages.

00:02:52.596 --> 00:02:53.970
These are pages
that are actively

00:02:53.970 --> 00:02:55.830
being used by processes.

00:02:55.830 --> 00:02:57.310
They can be cached pages.

00:02:57.310 --> 00:03:00.990
These are pages of memory that
are being used by processes,

00:03:00.990 --> 00:03:05.580
but the data they contain also
live somewhere on the device

00:03:05.580 --> 00:03:09.300
storage, which means we can
sometimes reclaim these pages.

00:03:09.300 --> 00:03:10.770
And then there
might be free pages

00:03:10.770 --> 00:03:14.490
of memory sitting on the
device that you're not using.

00:03:14.490 --> 00:03:18.690
So what I have done is I
took a two gigabyte device,

00:03:18.690 --> 00:03:20.560
and I started it doing nothing.

00:03:20.560 --> 00:03:21.960
So at the very
beginning of time,

00:03:21.960 --> 00:03:23.670
the runtime is not running.

00:03:23.670 --> 00:03:26.010
And then I started
using it more and more.

00:03:26.010 --> 00:03:29.940
So lots of different
applications, exercising them,

00:03:29.940 --> 00:03:32.460
which has the effect of
using more and more memory

00:03:32.460 --> 00:03:34.440
on the device over time.

00:03:34.440 --> 00:03:38.610
So we can see at the beginning,
the flat line there is

00:03:38.610 --> 00:03:40.200
before I started the runtime.

00:03:40.200 --> 00:03:42.510
Then I start the runtime up.

00:03:42.510 --> 00:03:45.660
There's plenty of free memory
available on the device.

00:03:45.660 --> 00:03:48.930
And this is a happy device,
because if an application needs

00:03:48.930 --> 00:03:52.620
more memory, the kernel can
satisfy that request right away

00:03:52.620 --> 00:03:55.490
from the free memory.

00:03:55.490 --> 00:03:58.370
Over time, as you
use more memory,

00:03:58.370 --> 00:04:00.090
the free memory gets exhausted.

00:04:00.090 --> 00:04:01.230
It goes down.

00:04:01.230 --> 00:04:04.410
And to avoid very bad
things from happening,

00:04:04.410 --> 00:04:06.900
the Linux kernel
has this mechanism

00:04:06.900 --> 00:04:09.760
that kicks in called kswapd.

00:04:09.760 --> 00:04:13.770
And kswapd's job is to
find more free memory.

00:04:13.770 --> 00:04:16.079
This kicks in when
the free memory

00:04:16.079 --> 00:04:19.829
goes below what I'm calling
here the kswapd threshold.

00:04:19.829 --> 00:04:22.310
And the main
mechanism that kswapd

00:04:22.310 --> 00:04:29.160
uses to find more free memory
is to reclaim cached pages.

00:04:29.160 --> 00:04:33.780
Now, if an app goes to
access a cached page,

00:04:33.780 --> 00:04:36.990
or memory that was on a cached
page has been reclaimed,

00:04:36.990 --> 00:04:39.000
it's going to take a
little extra time to reload

00:04:39.000 --> 00:04:41.100
that data from device storage.

00:04:41.100 --> 00:04:43.830
But probably, the user is not
going to be noticing this.

00:04:43.830 --> 00:04:46.830
So that's OK.

00:04:46.830 --> 00:04:50.610
Now, I exercise more
and more applications,

00:04:50.610 --> 00:04:52.200
they use more memory.

00:04:52.200 --> 00:04:55.380
The number of cached pages is
going to fall as kswapd starts

00:04:55.380 --> 00:04:56.910
to reclaim them.

00:04:56.910 --> 00:04:59.980
If it gets too low, there's
too few cached pages,

00:04:59.980 --> 00:05:02.190
then the device can
start to thrash.

00:05:02.190 --> 00:05:05.040
And this is a very bad thing
because, basically, the device

00:05:05.040 --> 00:05:06.660
will completely lock up.

00:05:06.660 --> 00:05:08.970
So on Android, we
have a mechanism

00:05:08.970 --> 00:05:11.070
which is called the
low memory killer that

00:05:11.070 --> 00:05:15.000
kicks in when the amount of
cached memory falls too low.

00:05:15.000 --> 00:05:17.340
And the way this works
is low memory killer

00:05:17.340 --> 00:05:20.580
is going to pick a
process on the device,

00:05:20.580 --> 00:05:21.990
and it's going to kill it.

00:05:21.990 --> 00:05:23.730
And it's going to get
back all the memory

00:05:23.730 --> 00:05:26.550
that that process was using.

00:05:26.550 --> 00:05:30.360
Now, this is an
unhappy state to be in,

00:05:30.360 --> 00:05:33.810
especially if the low memory
killer kills a process

00:05:33.810 --> 00:05:36.810
that the user cares about.

00:05:36.810 --> 00:05:40.110
So let me go through and
tell you a little bit more

00:05:40.110 --> 00:05:43.920
about how the low memory
killer decides what to kill.

00:05:43.920 --> 00:05:46.380
Android keeps track
of the processes

00:05:46.380 --> 00:05:48.120
that are running on the device.

00:05:48.120 --> 00:05:50.160
And it keeps them
in a priority order.

00:05:50.160 --> 00:05:54.510
So the highest priority
processes are native processes.

00:05:54.510 --> 00:05:56.340
These are ones that
come with Linux,

00:05:56.340 --> 00:05:59.520
things like init, kswapd,
which I told you about,

00:05:59.520 --> 00:06:02.510
demons like netd, logd.

00:06:02.510 --> 00:06:05.650
And Android-specific
specific demons, adbd,

00:06:05.650 --> 00:06:08.970
installd-- basically any
native process that's running

00:06:08.970 --> 00:06:11.400
is categorized into this.

00:06:11.400 --> 00:06:13.440
The next highest
priority process

00:06:13.440 --> 00:06:18.780
we have is a system server,
which is maintaining this list,

00:06:18.780 --> 00:06:21.420
followed by what are known
as persistent processes.

00:06:21.420 --> 00:06:23.550
These are kind of
core functionality,

00:06:23.550 --> 00:06:29.290
so [INAUDIBLE],, NFC, SMS,
those kinds of things.

00:06:29.290 --> 00:06:31.200
Next, we have the
foreground app.

00:06:31.200 --> 00:06:33.820
So this is going to be the
application that the user is

00:06:33.820 --> 00:06:35.200
directly interacting with.

00:06:35.200 --> 00:06:38.090
In this case, perhaps the
user's viewing a web page,

00:06:38.090 --> 00:06:41.500
so they're interacting
with the Chrome app.

00:06:41.500 --> 00:06:45.280
Next in priority are what are
called perceptible or visible

00:06:45.280 --> 00:06:46.660
processes.

00:06:46.660 --> 00:06:49.060
These are not processes
the user's directly

00:06:49.060 --> 00:06:52.430
interacting with, but
perceptible in some way.

00:06:52.430 --> 00:06:54.850
So for instance, if you
have a search process,

00:06:54.850 --> 00:06:58.020
maybe it has a little
bit of UI on the screen.

00:06:58.020 --> 00:07:00.609
Or if the user is listening
to music in the background,

00:07:00.609 --> 00:07:02.900
then they can hear that music
through their headphones.

00:07:02.900 --> 00:07:05.620
They can perceive it.

00:07:05.620 --> 00:07:07.930
After the perceptible
apps, we have services.

00:07:07.930 --> 00:07:10.870
These are services started
by applications for things

00:07:10.870 --> 00:07:16.120
like sinking, or uploading,
downloading from Cloud.

00:07:16.120 --> 00:07:17.410
And then we have the Home app.

00:07:17.410 --> 00:07:19.493
This is what you get when
you hit the Home button.

00:07:19.493 --> 00:07:23.150
It often hosts your wallpaper
if you have something there.

00:07:23.150 --> 00:07:25.540
So in addition to these
running processes,

00:07:25.540 --> 00:07:28.600
we also keep track of what
the previous application

00:07:28.600 --> 00:07:29.950
the user used was.

00:07:29.950 --> 00:07:33.640
So maybe they're using
this red app, your red app,

00:07:33.640 --> 00:07:36.490
and it brings them to
Chrome with a link.

00:07:36.490 --> 00:07:38.830
Then, when they
switch to Chrome,

00:07:38.830 --> 00:07:41.260
that app is going to
be the previous app.

00:07:41.260 --> 00:07:46.480
And we also keep in memory
a bunch of other processes

00:07:46.480 --> 00:07:51.070
which are cached applications
the user used before.

00:07:51.070 --> 00:07:52.900
Some of them may be
recently, some of them

00:07:52.900 --> 00:07:55.270
not for a little bit of a while.

00:07:55.270 --> 00:07:58.420
I want to point out here
that these cached processes--

00:07:58.420 --> 00:08:00.640
when I use the term cached,
this is a different use

00:08:00.640 --> 00:08:03.580
of the term cached than
the cached memory pages I

00:08:03.580 --> 00:08:06.560
was talking about previously.

00:08:06.560 --> 00:08:10.810
OK, so the reason we keep around
previous and cached processes

00:08:10.810 --> 00:08:12.400
is because if a
user wants to switch

00:08:12.400 --> 00:08:14.950
to one of these
applications, and say,

00:08:14.950 --> 00:08:17.380
they want to switch to
the previous application,

00:08:17.380 --> 00:08:19.900
it's very quick
to switch to that.

00:08:19.900 --> 00:08:23.770
I should say this is for a
device in a normal memory

00:08:23.770 --> 00:08:24.490
state.

00:08:24.490 --> 00:08:26.680
So if you want to switch
to previous application,

00:08:26.680 --> 00:08:28.090
that's very quick.

00:08:28.090 --> 00:08:30.460
But also, if you want to
switch to an application that

00:08:30.460 --> 00:08:32.710
happens to be in
a cached process,

00:08:32.710 --> 00:08:36.490
that's very quick to do
because it's already in memory.

00:08:36.490 --> 00:08:39.100
If we step back,
though, and say, well,

00:08:39.100 --> 00:08:42.460
what happens when the
device is low on memory?

00:08:42.460 --> 00:08:47.170
In that case, we could imagine
the memory used by the running

00:08:47.170 --> 00:08:48.940
applications is growing.

00:08:48.940 --> 00:08:52.341
The number of cached pages drops
below the low memory killer

00:08:52.341 --> 00:08:52.840
threshold.

00:08:52.840 --> 00:08:57.010
The low memory killer now has
to come in and kill something

00:08:57.010 --> 00:08:58.425
to free up some memory.

00:08:58.425 --> 00:08:59.800
Well, it's going
to start killing

00:08:59.800 --> 00:09:01.700
from the bottom of this list.

00:09:01.700 --> 00:09:05.270
So maybe it kills
this blue application.

00:09:05.270 --> 00:09:06.280
That's gone.

00:09:06.280 --> 00:09:09.040
We get some more memory
back for the applications

00:09:09.040 --> 00:09:10.520
that are still running.

00:09:10.520 --> 00:09:12.280
But if the user
now wants to switch

00:09:12.280 --> 00:09:14.770
and start using that
blue application,

00:09:14.770 --> 00:09:16.960
it's not cached any longer.

00:09:16.960 --> 00:09:21.040
It means it's going to take a
noticeably long time to launch

00:09:21.040 --> 00:09:21.980
that application.

00:09:21.980 --> 00:09:23.680
It could be two
or three seconds,

00:09:23.680 --> 00:09:25.480
and maybe it's lost some state.

00:09:25.480 --> 00:09:29.020
So this is where the user first
starts to really feel, oh,

00:09:29.020 --> 00:09:31.360
something's going on here
that's making things slower.

00:09:34.150 --> 00:09:35.860
If the processes
that are running

00:09:35.860 --> 00:09:39.670
continue to use more memory,
so we get under more memory

00:09:39.670 --> 00:09:41.850
pressure, low memory
killer is going

00:09:41.850 --> 00:09:44.740
to start to kill more
cached processes.

00:09:44.740 --> 00:09:48.610
If they continue to grow more
and more, until eventually

00:09:48.610 --> 00:09:51.850
there's only a few cached
processes left, at this point,

00:09:51.850 --> 00:09:54.350
we say the device memory
status is critical.

00:09:54.350 --> 00:09:56.590
This is a very bad place to be.

00:09:56.590 --> 00:09:59.920
If the running processes
continue to use more memory,

00:09:59.920 --> 00:10:01.570
though, low memory
killer is going

00:10:01.570 --> 00:10:03.880
to have to kill more processes.

00:10:03.880 --> 00:10:06.670
Eventually, it's going to
end up killing the whole map.

00:10:06.670 --> 00:10:09.470
At this point, the user's
going to ask, well, hey,

00:10:09.470 --> 00:10:10.950
what just happened
to my wallpaper?

00:10:10.950 --> 00:10:12.450
Because when they
go Home it's going

00:10:12.450 --> 00:10:14.230
to be a black screen
for a few seconds

00:10:14.230 --> 00:10:16.930
before the wallpaper
starts up again.

00:10:16.930 --> 00:10:20.110
If it's even worse, maybe
a perceptible processes

00:10:20.110 --> 00:10:20.977
is killing.

00:10:20.977 --> 00:10:23.560
The user is going to say, hey,
what just happened to my music?

00:10:23.560 --> 00:10:27.350
I was listening and
it just stopped.

00:10:27.350 --> 00:10:30.190
Really bad case, the
foreground app is killed,

00:10:30.190 --> 00:10:32.830
the user just looks
like the app crashed.

00:10:32.830 --> 00:10:34.840
And the most
extreme case you can

00:10:34.840 --> 00:10:36.730
get into for a
low memory killer,

00:10:36.730 --> 00:10:40.150
basically it needs to
kill the system server.

00:10:40.150 --> 00:10:42.430
This looks like your
phone is rebooted.

00:10:42.430 --> 00:10:46.030
So these are all
very visible impacts

00:10:46.030 --> 00:10:49.180
of what happens when a device
is running low on memory.

00:10:49.180 --> 00:10:51.167
And it's not a good
user experience

00:10:51.167 --> 00:10:52.750
when this is happening
on your device.

00:10:55.380 --> 00:10:58.790
I want to go back to this
graph that I was showing before

00:10:58.790 --> 00:11:02.150
about what happens to the
memory pages on the device

00:11:02.150 --> 00:11:04.100
as you use more memory.

00:11:04.100 --> 00:11:06.380
This was a two gigabyte device.

00:11:06.380 --> 00:11:10.100
What do you think it looks
like, this graph, four

00:11:10.100 --> 00:11:12.487
or 512 megabyte device?

00:11:12.487 --> 00:11:14.820
I'm going to give you a few
seconds to think about that.

00:11:26.360 --> 00:11:28.950
You have an idea
which it looks like?

00:11:28.950 --> 00:11:31.530
So I tried it for a
512 megabyte device.

00:11:31.530 --> 00:11:34.820
Same thing, start the
Runtime, use more memory,

00:11:34.820 --> 00:11:36.690
and it looks
something like this.

00:11:36.690 --> 00:11:38.870
So because there's
so little memory

00:11:38.870 --> 00:11:40.670
available at the
beginning, there's

00:11:40.670 --> 00:11:44.330
very few free pages that we can
use up before the kswapd has

00:11:44.330 --> 00:11:45.390
to kick in.

00:11:45.390 --> 00:11:47.110
And then there's
very few cached pages

00:11:47.110 --> 00:11:49.310
we can reclaim before
the low memory killer is

00:11:49.310 --> 00:11:51.990
needed to start killing things.

00:11:51.990 --> 00:11:54.050
And so you can imagine
if you have this device

00:11:54.050 --> 00:11:55.970
and the low memory
killer is always active,

00:11:55.970 --> 00:12:01.130
it's always killing processes,
and it leads to this bad user

00:12:01.130 --> 00:12:04.430
experience, then
maybe OEMs are not

00:12:04.430 --> 00:12:07.070
going to be too interested in
shipping this device because,

00:12:07.070 --> 00:12:08.990
well, it just doesn't work well.

00:12:08.990 --> 00:12:12.020
And that gets back to
the ecosystem challenges

00:12:12.020 --> 00:12:14.160
I mentioned in the beginning.

00:12:14.160 --> 00:12:17.090
So this is why we
care about memory.

00:12:22.090 --> 00:12:25.540
Now, how do we figure out how
much memory an application

00:12:25.540 --> 00:12:26.410
is used?

00:12:26.410 --> 00:12:31.870
How do we know your
application's memory, in fact?

00:12:31.870 --> 00:12:35.670
I told you that memory on device
is broken down into pages.

00:12:35.670 --> 00:12:37.500
The Linux kernel is
going to keep track,

00:12:37.500 --> 00:12:41.220
for each process running on the
device, which pages it's using.

00:12:41.220 --> 00:12:44.730
So maybe we have a system
process, Google Play services

00:12:44.730 --> 00:12:47.610
process, couple apps
running on a device.

00:12:47.610 --> 00:12:50.040
We want to know each of
their memory impacts.

00:12:50.040 --> 00:12:55.640
Well, just count up the number
of pages that it's using.

00:12:55.640 --> 00:12:57.330
It's a little bit
more complicated

00:12:57.330 --> 00:13:01.980
than this because of sharing,
because multiple processes

00:13:01.980 --> 00:13:03.660
on the device can
be sharing memory.

00:13:03.660 --> 00:13:05.700
So for instance, if
you have an app who's

00:13:05.700 --> 00:13:08.010
calling into Google
Play services,

00:13:08.010 --> 00:13:11.280
it's going to be sharing some
memory, perhaps code memory,

00:13:11.280 --> 00:13:13.860
or other kinds of memory,
with the Google Play services

00:13:13.860 --> 00:13:14.970
process.

00:13:14.970 --> 00:13:17.100
And then we can
ask, how should we

00:13:17.100 --> 00:13:19.410
account for this shared memory?

00:13:19.410 --> 00:13:21.180
Is that part of
the responsibility

00:13:21.180 --> 00:13:22.200
of the application?

00:13:22.200 --> 00:13:26.440
Is that memory impact something
that we should care about?

00:13:26.440 --> 00:13:30.300
And there's a few different
ways that you can approach this.

00:13:30.300 --> 00:13:34.080
One is to use what we call
resident set size, or RSS.

00:13:34.080 --> 00:13:37.860
And what this means is when
we're counting in apps, RSS,

00:13:37.860 --> 00:13:41.340
we're saying the application
is fully responsible for all

00:13:41.340 --> 00:13:42.990
the pages of memory
that it's sharing

00:13:42.990 --> 00:13:45.760
with other applications.

00:13:45.760 --> 00:13:49.960
Another approach is called
proportional set size, PSS.

00:13:49.960 --> 00:13:51.820
And in this case,
we're going to say

00:13:51.820 --> 00:13:53.860
the app is responsible
for those shared

00:13:53.860 --> 00:13:56.650
pages, proportional to
the number of processes

00:13:56.650 --> 00:13:57.890
that are sharing them.

00:13:57.890 --> 00:14:00.980
So in this case, two
applications or processes

00:14:00.980 --> 00:14:02.050
sharing these pages.

00:14:02.050 --> 00:14:05.590
The application, we'll say, is
responsible for half of them.

00:14:05.590 --> 00:14:08.390
If there were three processes
sharing the same memory,

00:14:08.390 --> 00:14:10.690
we would say the application
is responsible for a third

00:14:10.690 --> 00:14:13.480
of them, and so on.

00:14:13.480 --> 00:14:15.500
And then a third
approach you can take

00:14:15.500 --> 00:14:17.650
is called unique
set size, where we

00:14:17.650 --> 00:14:20.500
say the application is
not responsible for any

00:14:20.500 --> 00:14:23.030
of its shared pages.

00:14:23.030 --> 00:14:26.780
Now, in general, which
approach to take really

00:14:26.780 --> 00:14:28.560
depends on the context.

00:14:28.560 --> 00:14:32.120
So for instance, if those
shared pages were not

00:14:32.120 --> 00:14:34.730
being used in the
Google Play services app

00:14:34.730 --> 00:14:39.500
until your app called into
Google Play services, then

00:14:39.500 --> 00:14:42.920
maybe it makes sense to say
the app is responsible for all

00:14:42.920 --> 00:14:43.640
of those pages.

00:14:43.640 --> 00:14:45.530
We want to use RSS.

00:14:45.530 --> 00:14:48.530
On the other hand,
if those pages

00:14:48.530 --> 00:14:51.470
were sitting in memory in the
Google Play services process

00:14:51.470 --> 00:14:55.310
before the app called
into Google Play services,

00:14:55.310 --> 00:14:57.020
they were always
there, the app is not

00:14:57.020 --> 00:14:59.810
bringing them into memory, then
we wouldn't want to count them.

00:14:59.810 --> 00:15:02.420
USS would be more appropriate.

00:15:02.420 --> 00:15:06.050
In general, we don't have access
to this high level context

00:15:06.050 --> 00:15:09.590
to know, at least at the system
level, so the approach we take

00:15:09.590 --> 00:15:12.020
is the most straightforward
one, which is proportional set

00:15:12.020 --> 00:15:14.750
size with equal sharing.

00:15:14.750 --> 00:15:18.200
And one benefit of using PSS
for evaluating an application's

00:15:18.200 --> 00:15:22.310
memory impact, especially when
looking at multiple processes

00:15:22.310 --> 00:15:24.770
at the same time,
is it will avoid

00:15:24.770 --> 00:15:27.125
overcounting or undercounting
of shared pages.

00:15:30.610 --> 00:15:35.510
So use PSS for your
application's memory impact.

00:15:35.510 --> 00:15:41.740
And you can run this command,
adb shell dumpsys meminfo -s.

00:15:41.740 --> 00:15:46.060
Give it your process name,
com dot example, dot Richard,

00:15:46.060 --> 00:15:48.370
or whatever it is, or
you can give the process

00:15:48.370 --> 00:15:49.864
ID if you happen to know that.

00:15:49.864 --> 00:15:51.280
And it's going to
output something

00:15:51.280 --> 00:15:55.890
like this, an app summary view
of the application's memory.

00:15:55.890 --> 00:15:57.760
And at the very bottom,
there's a total.

00:15:57.760 --> 00:16:01.570
And that number is
the application's PSS.

00:16:01.570 --> 00:16:05.000
This is adb shell
dumpsys meminfo -s.

00:16:07.750 --> 00:16:09.640
Now, let's say you do this.

00:16:09.640 --> 00:16:12.790
You figure out what the
PSS of your application is.

00:16:12.790 --> 00:16:15.790
There's a very interesting
question to ask.

00:16:15.790 --> 00:16:19.180
How much memory should
your application be using?

00:16:19.180 --> 00:16:22.570
Because-- I say earlier,
if we use a lot of memory

00:16:22.570 --> 00:16:25.390
that's bad because low
memory killer kicks in.

00:16:25.390 --> 00:16:28.340
But we're actually using
memory for a reason.

00:16:28.340 --> 00:16:30.550
We're using it to
provide features,

00:16:30.550 --> 00:16:33.580
to provide user value, to
provide delightfulness.

00:16:33.580 --> 00:16:35.320
Everything that
makes our app great

00:16:35.320 --> 00:16:37.150
is going to be taking up memory.

00:16:37.150 --> 00:16:43.450
So we have this tradeoff
between user value and memory.

00:16:43.450 --> 00:16:46.620
That's what I'm showing here in
this graph, the tradeoff space.

00:16:46.620 --> 00:16:49.780
And in an ideal world, we're
kind of up and to the left

00:16:49.780 --> 00:16:53.170
on the graph, where we're
providing a lot of user value

00:16:53.170 --> 00:16:56.020
without very much
memory impact at all.

00:16:56.020 --> 00:16:58.990
But in practice, this
is going to probably

00:16:58.990 --> 00:17:03.700
be technically infeasible
because you need memory

00:17:03.700 --> 00:17:05.104
to provide value.

00:17:05.104 --> 00:17:06.520
And there's only
so much value you

00:17:06.520 --> 00:17:10.599
can provide with a
limited amount of memory.

00:17:10.599 --> 00:17:12.910
On the other hand,
the other extreme

00:17:12.910 --> 00:17:16.030
would be if you're
using a lot of memory

00:17:16.030 --> 00:17:18.500
to provide not much value.

00:17:18.500 --> 00:17:20.410
And I think it's safe
to say this is not

00:17:20.410 --> 00:17:23.380
a great app because
it's basically providing

00:17:23.380 --> 00:17:27.540
too much memory,
using too much memory.

00:17:27.540 --> 00:17:30.500
Unfortunately, my slides
are not showing up right.

00:17:30.500 --> 00:17:35.440
But imagine a curve
on which there's

00:17:35.440 --> 00:17:37.690
too much memory for this app.

00:17:37.690 --> 00:17:40.246
It's not worth it
to the user to use.

00:17:40.246 --> 00:17:41.530
Ah, there they go.

00:17:41.530 --> 00:17:43.960
Wonderful.

00:17:43.960 --> 00:17:47.800
Next, we can look at
this corner of the graph

00:17:47.800 --> 00:17:49.990
where we're not providing
too much user value.

00:17:49.990 --> 00:17:51.430
We're not using too much memory.

00:17:51.430 --> 00:17:54.430
We can say this is a
small application, maybe

00:17:54.430 --> 00:17:57.190
your desk clock app.

00:17:57.190 --> 00:17:58.930
And at the other
end, we can have

00:17:58.930 --> 00:18:02.930
apps that use a lot of memory
to provide a lot of value.

00:18:02.930 --> 00:18:05.460
These are large applications,
maybe a photo editor,

00:18:05.460 --> 00:18:07.280
or something like that.

00:18:07.280 --> 00:18:08.780
And we can say,
well, what's better?

00:18:08.780 --> 00:18:10.330
A small app or a large app?

00:18:10.330 --> 00:18:15.370
In this case, they
can both be useful,

00:18:15.370 --> 00:18:18.460
except that when I've said
that an application is using

00:18:18.460 --> 00:18:22.270
too much memory, that really
depends on what kind of device

00:18:22.270 --> 00:18:23.350
you're running on.

00:18:23.350 --> 00:18:25.120
If you're running
on a premium device,

00:18:25.120 --> 00:18:27.400
it can support much
larger applications.

00:18:27.400 --> 00:18:30.030
But on a smaller device,
an entry level device,

00:18:30.030 --> 00:18:32.890
maybe this large app
uses too much memory

00:18:32.890 --> 00:18:34.300
to make sense on that.

00:18:34.300 --> 00:18:36.340
So really I should
be drawing a line

00:18:36.340 --> 00:18:38.980
and say, too much memory
depends on the device.

00:18:38.980 --> 00:18:43.960
Premium, mid-tier,
and entry level

00:18:43.960 --> 00:18:47.810
might not support
that large app.

00:18:47.810 --> 00:18:51.800
For better or for worse,
what I see happening often

00:18:51.800 --> 00:18:54.830
is over time as you
develop your application,

00:18:54.830 --> 00:18:57.420
you tend to add more features.

00:18:57.420 --> 00:18:59.250
It tends to take more memory.

00:18:59.250 --> 00:19:03.370
So you tend to go up and
to the right in this graph.

00:19:03.370 --> 00:19:07.884
Now, this is actually good
for mid-tier and premium users

00:19:07.884 --> 00:19:09.550
because they're getting
more value, more

00:19:09.550 --> 00:19:12.340
bang for their buck,
memory-wise, but in this case,

00:19:12.340 --> 00:19:15.100
it's a little bit unfortunate
for the entry level device user

00:19:15.100 --> 00:19:18.160
because while he could use
the older version of your app,

00:19:18.160 --> 00:19:19.870
you've now added
so many features

00:19:19.870 --> 00:19:22.300
and it's using so much
memory that it just doesn't

00:19:22.300 --> 00:19:25.450
work as well on their device.

00:19:25.450 --> 00:19:27.190
So the points that
I want to say here,

00:19:27.190 --> 00:19:29.500
the takeaways,
anything you can do

00:19:29.500 --> 00:19:32.830
to improve your application's
memory efficiency is good.

00:19:32.830 --> 00:19:35.300
So if you can move to
the left on this graph,

00:19:35.300 --> 00:19:38.270
so less memory use without
sacrificing user value,

00:19:38.270 --> 00:19:40.420
that's great.

00:19:40.420 --> 00:19:41.890
And just be aware
that when you're

00:19:41.890 --> 00:19:46.120
adding new features, while
it can be good for mid-tier

00:19:46.120 --> 00:19:49.300
and premium device users, there
might be a negative consequence

00:19:49.300 --> 00:19:50.890
for these entry level devices.

00:19:53.564 --> 00:19:55.230
There's something
wrong with this graph.

00:19:58.410 --> 00:20:00.360
Does anyone know what it is?

00:20:00.360 --> 00:20:02.030
Well, let me see.

00:20:02.030 --> 00:20:04.530
The problem that
this graph is, it's

00:20:04.530 --> 00:20:08.580
suggesting that an application's
memory use is one number.

00:20:08.580 --> 00:20:12.690
So you give me this application,
and I can tell you its PSS.

00:20:12.690 --> 00:20:15.570
But in practice, that's
far from the case,

00:20:15.570 --> 00:20:17.970
because an application's
memory impact

00:20:17.970 --> 00:20:20.740
depends on a whole bunch
of different things,

00:20:20.740 --> 00:20:23.820
such as the application
use case, the platform

00:20:23.820 --> 00:20:27.630
configuration, and
device memory pressure.

00:20:27.630 --> 00:20:30.990
And so this is important to be
aware of when you're testing

00:20:30.990 --> 00:20:33.690
your application's
memory, perhaps testing

00:20:33.690 --> 00:20:37.020
for regressions, or to see if
an optimization is working,

00:20:37.020 --> 00:20:40.230
to make sure that you're
testing the application use case

00:20:40.230 --> 00:20:42.930
you care about, and
you're controlling

00:20:42.930 --> 00:20:45.600
all of the other
parameters so that you're

00:20:45.600 --> 00:20:49.140
doing a proper apples
to apples comparison.

00:20:49.140 --> 00:20:51.820
Let me go into a
little bit more detail.

00:20:51.820 --> 00:20:56.520
So how does an application
use case impact memory?

00:20:56.520 --> 00:20:59.430
What I've done here is
I started using Gmail.

00:20:59.430 --> 00:21:01.740
And I've switched to
different use cases

00:21:01.740 --> 00:21:03.720
in the application over time.

00:21:03.720 --> 00:21:05.760
So every 20 seconds I switch.

00:21:05.760 --> 00:21:08.370
I started by viewing the
inbox, of using just a little

00:21:08.370 --> 00:21:10.740
over 100 megabytes PSS.

00:21:10.740 --> 00:21:13.630
Then I switched to looking at
an email that had some text,

00:21:13.630 --> 00:21:15.480
using a little bit more memory.

00:21:15.480 --> 00:21:17.580
I switched to looking
at a different email,

00:21:17.580 --> 00:21:19.080
this time with pictures.

00:21:19.080 --> 00:21:20.540
It uses more memory.

00:21:20.540 --> 00:21:23.580
Then I started to compose an
email, used a little bit less.

00:21:23.580 --> 00:21:27.160
I stopped using the app, and
then it used less memory.

00:21:27.160 --> 00:21:30.210
So you can see here that
depending on the application

00:21:30.210 --> 00:21:35.080
use case, memory impact
varies quite significantly.

00:21:35.080 --> 00:21:37.860
And it doesn't
necessarily make any sense

00:21:37.860 --> 00:21:40.470
to compare your application's
memory from point

00:21:40.470 --> 00:21:43.725
A point B because these
are different use cases.

00:21:47.190 --> 00:21:50.880
Application use case is a
pretty straightforward factor.

00:21:50.880 --> 00:21:54.120
Something that's less
obvious is that your memory

00:21:54.120 --> 00:21:56.010
will change a lot
depending on what

00:21:56.010 --> 00:21:58.260
your platform configuration is.

00:21:58.260 --> 00:22:00.480
So what I was
showing in this graph

00:22:00.480 --> 00:22:03.510
is I picked one of
those application

00:22:03.510 --> 00:22:06.900
use cases from the previous
slide, Gmail, looking

00:22:06.900 --> 00:22:09.540
at an email with pictures.

00:22:09.540 --> 00:22:11.800
And I've run it on a bunch
of different devices.

00:22:11.800 --> 00:22:16.860
So a Nexus 4, a Nexus 5X,
Nexus XP, Pixel XL, and also

00:22:16.860 --> 00:22:19.470
on a number of different
platform versions,

00:22:19.470 --> 00:22:20.880
even within the same device.

00:22:20.880 --> 00:22:23.310
So for instance,
for the Nexus 5,

00:22:23.310 --> 00:22:27.750
I ran it on Android
M, N, and O. And you

00:22:27.750 --> 00:22:31.270
can see that there's quite a
variation in how much memory

00:22:31.270 --> 00:22:35.580
this application use
case is taking up.

00:22:35.580 --> 00:22:38.370
This comes about because,
well, for different devices

00:22:38.370 --> 00:22:40.860
we have different screen
resolutions, different screen

00:22:40.860 --> 00:22:46.110
sizes, which means bitmaps take
up different amounts of memory.

00:22:46.110 --> 00:22:48.660
You might have different
platform optimizations

00:22:48.660 --> 00:22:50.380
on the different devices.

00:22:50.380 --> 00:22:53.670
You might have a different
zygote configuration,

00:22:53.670 --> 00:22:55.590
different runtime
configuration that's

00:22:55.590 --> 00:22:57.810
running your code differently.

00:22:57.810 --> 00:23:00.360
And so there's a lot of
different factors going

00:23:00.360 --> 00:23:03.810
on here, which, when you
switch to a different platform

00:23:03.810 --> 00:23:08.100
configuration, you're going
to get different memory use.

00:23:08.100 --> 00:23:10.860
So I would say, when you're
testing your application's

00:23:10.860 --> 00:23:13.560
memory use, try
as hard as you can

00:23:13.560 --> 00:23:17.610
to use a consistent platform
set up, the same kind of device,

00:23:17.610 --> 00:23:20.940
the same platform version,
and the same scenario

00:23:20.940 --> 00:23:22.275
of what's running on device.

00:23:26.640 --> 00:23:28.730
And now there's a third
case I want to talk about,

00:23:28.730 --> 00:23:30.938
which is pretty interesting
because it's a little bit

00:23:30.938 --> 00:23:33.820
counter-intuitive which
is an application's memory

00:23:33.820 --> 00:23:38.630
impact depends on the
memory pressure on device.

00:23:38.630 --> 00:23:41.980
So here, what I've done is
I've taken Chrome application

00:23:41.980 --> 00:23:44.710
and I started running
it on a device that

00:23:44.710 --> 00:23:46.780
had plenty of free memory.

00:23:46.780 --> 00:23:48.944
And then I set up
some native process

00:23:48.944 --> 00:23:50.610
in the background
that's going to slowly

00:23:50.610 --> 00:23:52.780
use up more and more
memory on the device

00:23:52.780 --> 00:23:55.870
so that I can see what happens
to Chrome when the device gets

00:23:55.870 --> 00:23:59.140
under medium memory pressure
or high memory pressure.

00:23:59.140 --> 00:24:00.730
And we can see,
when there's plenty

00:24:00.730 --> 00:24:04.530
of free memory on the device,
so low memory pressure, Chrome's

00:24:04.530 --> 00:24:07.900
PSS is pretty flat except
for that little spike, which

00:24:07.900 --> 00:24:10.180
is probably some
variation in app use

00:24:10.180 --> 00:24:13.720
case [INAUDIBLE] the platform.

00:24:13.720 --> 00:24:16.510
When the device gets under
enough memory pressure that

00:24:16.510 --> 00:24:20.620
kswapd kicks in and starts
to reclaim cached pages,

00:24:20.620 --> 00:24:22.870
well, some of those
pages that it reclaims

00:24:22.870 --> 00:24:25.690
are going to be from
the Chrome process.

00:24:25.690 --> 00:24:27.490
And that's going to
cause Chrome's memory

00:24:27.490 --> 00:24:28.750
impact to go down.

00:24:28.750 --> 00:24:32.290
Its PSS is going to go
down until eventually,

00:24:32.290 --> 00:24:34.590
if the device has so
much memory pressure,

00:24:34.590 --> 00:24:37.120
the low memory killer
is active and it decides

00:24:37.120 --> 00:24:40.840
it wants to kill Chrome,
then PSS for Chrome

00:24:40.840 --> 00:24:44.650
is going to very
quickly drop to zero.

00:24:44.650 --> 00:24:47.440
So what you can see here is that
even for the same application

00:24:47.440 --> 00:24:50.710
use case, the same
platform configuration,

00:24:50.710 --> 00:24:54.520
we have a wide range of
PSS values we might get.

00:24:54.520 --> 00:24:57.490
And so you have to be
a little bit careful.

00:24:57.490 --> 00:25:00.470
Imagine I've come up with this
optimized version of the Chrome

00:25:00.470 --> 00:25:01.630
APK.

00:25:01.630 --> 00:25:04.660
And it has this kind of lighter
blue line for the memory

00:25:04.660 --> 00:25:05.830
profile.

00:25:05.830 --> 00:25:09.040
I'm confident that this
is an optimized version

00:25:09.040 --> 00:25:11.350
of the APK from a
memory standpoint

00:25:11.350 --> 00:25:14.590
because for every level
of device memory pressure,

00:25:14.590 --> 00:25:16.580
it uses less memory.

00:25:16.580 --> 00:25:18.970
But if I'm doing a
test and I sample

00:25:18.970 --> 00:25:22.630
the PSS of the original
Chrome version at point A,

00:25:22.630 --> 00:25:27.400
but I sample the PSS of the
supposedly optimized Chrome

00:25:27.400 --> 00:25:29.530
version of point
B and I compare,

00:25:29.530 --> 00:25:34.300
and I say, oh, well, A is less
than B, so A has less memory,

00:25:34.300 --> 00:25:38.470
I might falsely conclude that
the original version of Chrome

00:25:38.470 --> 00:25:41.050
is better than my
optimized version.

00:25:41.050 --> 00:25:44.260
So you really have to be careful
when comparing PSS values

00:25:44.260 --> 00:25:47.890
to make sure that the device
memory pressure is the same.

00:25:47.890 --> 00:25:51.760
Otherwise, you can get
these funny results.

00:25:51.760 --> 00:25:54.070
My advice, because
it's pretty hard

00:25:54.070 --> 00:25:56.530
to control for device
memory pressure,

00:25:56.530 --> 00:26:01.030
is to run your tests on a device
that has plenty of free RAM

00:26:01.030 --> 00:26:03.070
so that there's a low
device memory pressure

00:26:03.070 --> 00:26:06.280
and you can see, the PSS
numbers will be much more stable

00:26:06.280 --> 00:26:06.970
in that area.

00:26:11.740 --> 00:26:16.360
So we talked about why you
want your applications not

00:26:16.360 --> 00:26:18.490
to take up too much
memory, how you

00:26:18.490 --> 00:26:22.000
can evaluate your
application's memory impact.

00:26:22.000 --> 00:26:23.770
Let me now give you
some tips for how

00:26:23.770 --> 00:26:26.460
to reduce your
application's memory impact.

00:26:26.460 --> 00:26:30.070
And the first tip is, check
out Android Studio's memory

00:26:30.070 --> 00:26:31.000
profiler.

00:26:31.000 --> 00:26:34.300
Profile your
application's Java heap.

00:26:34.300 --> 00:26:38.500
This is going to give you
a ton of useful information

00:26:38.500 --> 00:26:40.510
about the Java
objects on your heap.

00:26:40.510 --> 00:26:43.810
So where they're allocated,
what's holding onto them,

00:26:43.810 --> 00:26:46.990
how big they are,
pretty much anything

00:26:46.990 --> 00:26:50.290
you want to know about the Java
heap, you can see from this.

00:26:50.290 --> 00:26:53.140
My tip for you is to
focus on the app heap.

00:26:53.140 --> 00:26:55.060
So if you open this
up in Android Studio,

00:26:55.060 --> 00:26:56.500
you'll see three heaps.

00:26:56.500 --> 00:27:00.100
One is a zygote heap, one the
image heap, one the app heap.

00:27:00.100 --> 00:27:02.170
The image and the
zygote heap are

00:27:02.170 --> 00:27:05.481
inherited from the system
when your application first

00:27:05.481 --> 00:27:05.980
launches.

00:27:05.980 --> 00:27:08.390
So there's not much
you can do about that.

00:27:08.390 --> 00:27:13.420
But definitely, you can
do a lot on the app heap.

00:27:13.420 --> 00:27:16.390
I'm not going to go
into a ton of detail

00:27:16.390 --> 00:27:17.950
on how you would use this--

00:27:17.950 --> 00:27:21.280
or actually not very much
at all, because Esteban

00:27:21.280 --> 00:27:25.180
is going to be giving a
talk tomorrow at 12:30

00:27:25.180 --> 00:27:27.040
on exactly how to use this tool.

00:27:27.040 --> 00:27:28.660
His team built the tool.

00:27:28.660 --> 00:27:31.690
He's going to be talking about
how to do live allocation

00:27:31.690 --> 00:27:33.430
tracking and heap analysis.

00:27:33.430 --> 00:27:37.210
So I highly recommend you go
check out that talk tomorrow

00:27:37.210 --> 00:27:37.960
at 12:30.

00:27:42.370 --> 00:27:45.760
So you say, Richard,
you've told us

00:27:45.760 --> 00:27:47.350
that we should care about PSS.

00:27:47.350 --> 00:27:50.170
That's our application's
memory impact.

00:27:50.170 --> 00:27:52.970
You just told us we should use
the Android Studio's memory

00:27:52.970 --> 00:27:55.480
profile to profile
the Java heap.

00:27:55.480 --> 00:27:58.660
But if we look here, we
see, well, the Java heap's

00:27:58.660 --> 00:28:02.800
not actually all that
much of the overall memory

00:28:02.800 --> 00:28:04.930
impact of the application.

00:28:04.930 --> 00:28:06.880
What about all the
rest of this memory?

00:28:06.880 --> 00:28:09.910
What should we do here?

00:28:09.910 --> 00:28:13.720
This is tricky because
most of these applications,

00:28:13.720 --> 00:28:16.990
or allocations, sorry,
are originating deep

00:28:16.990 --> 00:28:20.840
within the platform
stack, the Android stack.

00:28:20.840 --> 00:28:23.410
So if you want to
know about them

00:28:23.410 --> 00:28:25.210
and really understand
them, it helps

00:28:25.210 --> 00:28:30.430
to know a lot more about how
frameworks is implementing

00:28:30.430 --> 00:28:34.210
the view system and resources,
or how the native library

00:28:34.210 --> 00:28:39.820
fonts and SQL light, web view
is working, from the Android

00:28:39.820 --> 00:28:42.220
Runtime, how it's
running your code,

00:28:42.220 --> 00:28:46.060
from the hardware abstraction
layer, how graphics is working,

00:28:46.060 --> 00:28:50.320
all the way down to virtual
memory management in the Linux

00:28:50.320 --> 00:28:51.940
kernel.

00:28:51.940 --> 00:28:54.970
By the way, I live in the
orange block in the middle,

00:28:54.970 --> 00:28:56.170
the Android Runtime.

00:28:56.170 --> 00:28:59.080
That's where I am in the stack.

00:28:59.080 --> 00:29:01.660
So you might ask,
OK, so this memory

00:29:01.660 --> 00:29:04.990
is coming from the platform,
or within the platform.

00:29:04.990 --> 00:29:09.490
Should we be using platform
tools to diagnose this memory?

00:29:09.490 --> 00:29:14.560
For instance, if dumpsys meminfo
-s, that summary view isn't

00:29:14.560 --> 00:29:18.310
enough, you could try running
dumpsys meminfo with -a,

00:29:18.310 --> 00:29:20.230
to show, basically,
everything you

00:29:20.230 --> 00:29:22.480
can see from a
platform perspective

00:29:22.480 --> 00:29:24.940
about your application's
memory use.

00:29:24.940 --> 00:29:27.850
This will give you a much
more detailed breakdown.

00:29:27.850 --> 00:29:32.830
For instance, instead of seeing
your code memory regress,

00:29:32.830 --> 00:29:36.550
you can see, is it because my
dot SO memory mappings have

00:29:36.550 --> 00:29:41.380
regressed, or my .APK or
[INAUDIBLE] memory mappings

00:29:41.380 --> 00:29:43.210
have regressed?

00:29:43.210 --> 00:29:45.430
It will also show
you a breakdown

00:29:45.430 --> 00:29:47.230
of the different
categories of memory,

00:29:47.230 --> 00:29:51.310
so private, clean,
share, dirty, and so on.

00:29:51.310 --> 00:29:53.890
Private dirty memory
is like the used memory

00:29:53.890 --> 00:29:55.750
I was talking about
at the beginning.

00:29:55.750 --> 00:29:58.500
Private clean memory,
the clean, suggests

00:29:58.500 --> 00:30:02.410
it's like the cached memory
that also lives on this.

00:30:02.410 --> 00:30:04.690
So you could use
dumpsys meminfo.

00:30:04.690 --> 00:30:07.360
If that's not enough
detail, maybe you see, OK,

00:30:07.360 --> 00:30:09.370
.APK mmap regressed.

00:30:09.370 --> 00:30:11.470
There's this tool called
show map you can do,

00:30:11.470 --> 00:30:13.180
run on your
application, and it's

00:30:13.180 --> 00:30:15.670
going to give you an even
more fine grained breakdown

00:30:15.670 --> 00:30:20.800
of your memory mappings,
and it will actually

00:30:20.800 --> 00:30:24.280
give you specific files
that are being memory mapped

00:30:24.280 --> 00:30:25.550
in your application.

00:30:25.550 --> 00:30:29.040
And this can help
pinpoint what files

00:30:29.040 --> 00:30:30.790
might have led to regressions.

00:30:33.520 --> 00:30:36.820
In the platform, we
have a heap dump viewer

00:30:36.820 --> 00:30:39.160
that I've developed,
experimental heap

00:30:39.160 --> 00:30:41.080
dump viewer called
[INAUDIBLE] that

00:30:41.080 --> 00:30:43.790
tries to surface more
platform specific things.

00:30:43.790 --> 00:30:46.960
You could try using that to
learn more about your Java

00:30:46.960 --> 00:30:49.930
heap, though Android
Studio's memory profile will

00:30:49.930 --> 00:30:53.330
have all the same information.

00:30:53.330 --> 00:30:55.600
And then we also have on
the platform something

00:30:55.600 --> 00:30:56.810
called debug malware.

00:30:56.810 --> 00:30:59.770
This is where you can
instrument your application

00:30:59.770 --> 00:31:02.380
so that every native
application it makes

00:31:02.380 --> 00:31:06.610
is going to save a stack
trace to that allocation.

00:31:06.610 --> 00:31:11.770
You take what we call a native
heap snapshot of your app

00:31:11.770 --> 00:31:14.950
when it's running instrumented,
and if you have the symbols,

00:31:14.950 --> 00:31:16.750
you can desymbolize
the stack traces,

00:31:16.750 --> 00:31:20.110
and you can get native
stack traces for all

00:31:20.110 --> 00:31:22.960
of your native allocations.

00:31:22.960 --> 00:31:25.660
This has quite a bit
of overhead at Runtime,

00:31:25.660 --> 00:31:28.000
and so it can be a little
bit tricky to work,

00:31:28.000 --> 00:31:31.210
but it provides a lot of
insight into the native heap.

00:31:31.210 --> 00:31:33.400
So we have these platform tools.

00:31:33.400 --> 00:31:34.330
Should we use them?

00:31:34.330 --> 00:31:36.550
Can we use them?

00:31:36.550 --> 00:31:37.990
Well, certainly you could.

00:31:37.990 --> 00:31:39.050
They're all available.

00:31:39.050 --> 00:31:41.530
But some caveats
with these tools.

00:31:41.530 --> 00:31:44.450
They tend not to
be well supported.

00:31:44.450 --> 00:31:46.390
They have very clumsy
user interfaces,

00:31:46.390 --> 00:31:51.230
as you just witnessed
from my snapshots.

00:31:51.230 --> 00:31:54.700
This approach requires quite a
bit of deep platform expertise

00:31:54.700 --> 00:31:56.470
to understand for
instance, what's

00:31:56.470 --> 00:32:01.359
the difference between Dex mmap,
VDex mmap, [INAUDIBLE] mmap.

00:32:01.359 --> 00:32:03.400
Where are these things
coming from, for instance?

00:32:06.110 --> 00:32:07.840
You might need to
have a routed device,

00:32:07.840 --> 00:32:10.690
such as in the case for
show map and debug malware.

00:32:10.690 --> 00:32:12.490
You might have to build
a platform yourself

00:32:12.490 --> 00:32:14.950
if you want to get your hands
on [INAUDIBLE] or the symbols

00:32:14.950 --> 00:32:17.980
that debug [INAUDIBLE]
needs to desymbolize.

00:32:17.980 --> 00:32:20.920
The numbers tend to be pretty
noisy because you are looking

00:32:20.920 --> 00:32:23.390
at memory at a page level.

00:32:23.390 --> 00:32:26.440
And a lot of the memory you
shall see from these tools

00:32:26.440 --> 00:32:29.240
is kind of outside of
your control anyway.

00:32:29.240 --> 00:32:31.990
So you might see
zygote allocations,

00:32:31.990 --> 00:32:35.950
Runtime allocations, that
aren't related to your code.

00:32:35.950 --> 00:32:39.190
So I don't think that this
is the best use of your time,

00:32:39.190 --> 00:32:40.920
to try and use these tools.

00:32:40.920 --> 00:32:44.190
Though by all means, go
ahead and try them out.

00:32:44.190 --> 00:32:46.870
I'm going to give a bit
of a different suggestion,

00:32:46.870 --> 00:32:50.760
which is if you want to improve
your overall memory use,

00:32:50.760 --> 00:32:52.020
do two things.

00:32:52.020 --> 00:32:55.460
One, profile your Java heap
using Android Studio's memory

00:32:55.460 --> 00:32:57.510
profiler like I showed before.

00:32:57.510 --> 00:33:00.500
And two, reduce your APK size.

00:33:00.500 --> 00:33:02.310
And let me tell you why.

00:33:02.310 --> 00:33:05.850
I think this is a
reasonable approach for you

00:33:05.850 --> 00:33:09.600
to take to reduce your
overall memory impact.

00:33:09.600 --> 00:33:14.130
First, is that allocations that
are outside of the Java heap,

00:33:14.130 --> 00:33:17.350
many of those are tied
to Java allocations.

00:33:17.350 --> 00:33:20.760
So your application is calling
into the Android frameworks,

00:33:20.760 --> 00:33:22.530
which is calling
into native libraries

00:33:22.530 --> 00:33:26.160
under the cover, which is doing
native allocations or even

00:33:26.160 --> 00:33:28.800
graphics allocations,
whose lifetime is

00:33:28.800 --> 00:33:32.170
tied to Java objects.

00:33:32.170 --> 00:33:35.730
For instance, just to
give you a sampling,

00:33:35.730 --> 00:33:37.500
in Java on your
Java heap, if you

00:33:37.500 --> 00:33:40.950
see these kinds of objects, so
a SQLite database, web views,

00:33:40.950 --> 00:33:43.710
patterns, those all
have native allocations

00:33:43.710 --> 00:33:45.210
associated with them.

00:33:45.210 --> 00:33:48.660
If you see a DexFile object,
that's going to have .Dexmmap,

00:33:48.660 --> 00:33:51.720
.VDex, [INAUDIBLE] mmap
associated with it.

00:33:51.720 --> 00:33:54.360
If you have thread
instances on your Java heap,

00:33:54.360 --> 00:33:57.300
that's going to be
associated with stack memory.

00:33:57.300 --> 00:33:59.970
And if you're using bitmaps
or sometimes surface views,

00:33:59.970 --> 00:34:03.660
or texture views, that can
lead to graphics memory use.

00:34:03.660 --> 00:34:05.620
And there are many others.

00:34:05.620 --> 00:34:10.549
So if you're focusing
on your Java heap,

00:34:10.549 --> 00:34:12.090
you're worried it's
not going to help

00:34:12.090 --> 00:34:14.420
anywhere else, that's not true.

00:34:14.420 --> 00:34:16.739
Optimisations on
your Java heap are

00:34:16.739 --> 00:34:21.060
going to help with other
memory categories as well.

00:34:21.060 --> 00:34:24.810
I am trying, as part of
my job, to surface better

00:34:24.810 --> 00:34:29.130
this information about these
non-Java heap allocations.

00:34:29.130 --> 00:34:30.280
And you start to see that.

00:34:30.280 --> 00:34:34.630
And if you look at Android
Studio's memory profilers,

00:34:34.630 --> 00:34:37.800
it'll report a
number called native.

00:34:37.800 --> 00:34:39.710
And I just want to
let you know this

00:34:39.710 --> 00:34:43.139
is an approximation or
a suggestion of some

00:34:43.139 --> 00:34:46.650
of the non-Java memory that
might be associated with a Java

00:34:46.650 --> 00:34:47.639
object.

00:34:47.639 --> 00:34:49.620
Take it with a little
bit of a grain of salt,

00:34:49.620 --> 00:34:52.090
but it works really well
for surfacing the memory

00:34:52.090 --> 00:34:53.340
impacts of, say, bitmaps.

00:34:58.000 --> 00:35:01.382
My second suggestion was
reduce your APK size.

00:35:01.382 --> 00:35:02.340
And why do you do this?

00:35:02.340 --> 00:35:05.580
Because a lot of things that
take up space in your APK

00:35:05.580 --> 00:35:08.680
take up space in memory
at runtime as well.

00:35:08.680 --> 00:35:11.260
For instance, your
classes.dex file

00:35:11.260 --> 00:35:14.220
is going to take up
space on the Java heap

00:35:14.220 --> 00:35:15.840
in terms of class objects.

00:35:15.840 --> 00:35:19.484
It's going to take a code memory
for the memory map DexFile.

00:35:19.484 --> 00:35:21.150
It's also going to
take up what shows up

00:35:21.150 --> 00:35:26.550
in private other in the app
summary view runtime metadata.

00:35:26.550 --> 00:35:29.070
Representations for your
fields, methods, and strings,

00:35:29.070 --> 00:35:31.480
and so on.

00:35:31.480 --> 00:35:33.780
If you have bitmaps
in your APK, when

00:35:33.780 --> 00:35:36.090
those are loaded at
runtime, the pixel data

00:35:36.090 --> 00:35:38.400
is going to take up space
depending on the platform

00:35:38.400 --> 00:35:40.140
version or how
you've loaded them,

00:35:40.140 --> 00:35:45.450
either in the Java heap, the
native heap, or as graphics.

00:35:45.450 --> 00:35:48.630
Resources in your APK take
up space on the Java heap,

00:35:48.630 --> 00:35:51.210
so you have an asset
manager object.

00:35:51.210 --> 00:35:54.600
Also, on the native heap,
you have a parsed zip file

00:35:54.600 --> 00:35:56.680
structure that shows up there.

00:35:56.680 --> 00:36:00.280
And you're going to have code
memory for your APK on that.

00:36:00.280 --> 00:36:05.750
And .so files if you're
shipping libraries,

00:36:05.750 --> 00:36:08.040
J and I native libraries
with your application,

00:36:08.040 --> 00:36:10.440
when you're accessing
those libraries at runtime,

00:36:10.440 --> 00:36:12.190
it's going to take up space.

00:36:12.190 --> 00:36:14.640
So all of these things,
if you can shrink them,

00:36:14.640 --> 00:36:17.910
you reduce your APK size,
you reduce your memory size.

00:36:17.910 --> 00:36:20.550
And I will tell you
that measuring APK size

00:36:20.550 --> 00:36:24.780
reliably is much easier than
memory, because for an APK

00:36:24.780 --> 00:36:27.960
you actually do have
one number for the size.

00:36:27.960 --> 00:36:31.740
If you measure the APK size
for a single APK repeatedly,

00:36:31.740 --> 00:36:35.370
you will get the same result,
very much unlike memory.

00:36:38.190 --> 00:36:40.830
There was a talk at
Google I/O last year

00:36:40.830 --> 00:36:43.530
called Best Practices to
Slim Down Your App Size.

00:36:43.530 --> 00:36:44.880
I recommend you check that out.

00:36:44.880 --> 00:36:48.480
That'll give you more
advice, more concrete action

00:36:48.480 --> 00:36:51.308
items you can take to
shrink these things.

00:36:54.250 --> 00:36:57.460
Let me do a quick recap of
why we care about memory,

00:36:57.460 --> 00:37:01.670
what I suggest you do to improve
your application's memory use.

00:37:01.670 --> 00:37:05.560
So first, I talked about how as
we use more memory on device,

00:37:05.560 --> 00:37:08.030
the low memory killer is
going to eventually kick in.

00:37:08.030 --> 00:37:09.730
It's going to kill processes.

00:37:09.730 --> 00:37:14.740
If the user cares about
these processes, that's bad.

00:37:14.740 --> 00:37:18.370
If the device is getting
low memory killers running

00:37:18.370 --> 00:37:23.080
too much, then OEMs won't want
to produce the entry level

00:37:23.080 --> 00:37:23.830
device.

00:37:23.830 --> 00:37:25.060
Then we lose those devices.

00:37:25.060 --> 00:37:26.050
We lose those users.

00:37:29.230 --> 00:37:34.960
To evaluate your application's
memory impact, use PSS.

00:37:34.960 --> 00:37:39.880
Anything you can do to improve
your memory efficiency is good.

00:37:39.880 --> 00:37:43.210
When you're testing for memory
regressions or optimizations,

00:37:43.210 --> 00:37:45.430
make sure you're targeting
the application use

00:37:45.430 --> 00:37:47.800
case you care about in
controlling for the platform

00:37:47.800 --> 00:37:50.260
configuration.

00:37:50.260 --> 00:37:52.720
Test on a device that
has plenty of free RAM

00:37:52.720 --> 00:37:55.900
to help control for
device memory pressure.

00:37:55.900 --> 00:37:59.560
And to reduce your
application's memory use,

00:37:59.560 --> 00:38:02.770
do try out Android
Studio's memory profiler,

00:38:02.770 --> 00:38:05.910
focus on the app heap,
go to the session

00:38:05.910 --> 00:38:08.860
that Esteban's giving tomorrow
at 12:30 to learn more

00:38:08.860 --> 00:38:11.860
about how to do that.

00:38:11.860 --> 00:38:14.240
Do what you can to
reduce your APK size,

00:38:14.240 --> 00:38:19.270
and check out the talk from last
year on how you can do that.

00:38:19.270 --> 00:38:21.950
So thank you all for coming.

00:38:21.950 --> 00:38:25.570
I would love to chat with
you more and hear more

00:38:25.570 --> 00:38:28.000
about the memory
challenges you're facing.

00:38:28.000 --> 00:38:30.770
So you'll find me, I'll
hang out for a little while

00:38:30.770 --> 00:38:34.270
outside after the
stage, and you can also

00:38:34.270 --> 00:38:36.430
find me at the
Android Runtime office

00:38:36.430 --> 00:38:40.190
hours, which are 5:30, so
that's just a couple hours

00:38:40.190 --> 00:38:42.200
after this talk.

00:38:42.200 --> 00:38:44.100
Thank you very much.

