WEBVTT
Kind: captions
Language: en

00:00:03.380 --> 00:00:04.910
RYAN BOYD: Hello, everyone.

00:00:04.910 --> 00:00:07.250
I hope you're all here for
the OAuth 2 session.

00:00:07.250 --> 00:00:08.565
How's your day been
going thus far?

00:00:08.565 --> 00:00:09.950
AUDIENCE: [INTERPOSING VOICES].

00:00:09.950 --> 00:00:11.970
RYAN BOYD: Good,
good, awesome.

00:00:11.970 --> 00:00:14.450
My name is Ryan Boyd,
and I am a developer

00:00:14.450 --> 00:00:16.440
advocate here at Google.

00:00:16.440 --> 00:00:18.470
OAuth 2 isn't really
my day job.

00:00:18.470 --> 00:00:20.200
It's just a passion of mine.

00:00:20.200 --> 00:00:22.500
Normally, by the day, I'm
working on our cloud data

00:00:22.500 --> 00:00:27.630
services like Google BigQuery,
but OAuth 2 has been a passion

00:00:27.630 --> 00:00:31.350
of mine since I started in
Google at about 2006.

00:00:31.350 --> 00:00:34.270
I was working on our proprietary
authorization

00:00:34.270 --> 00:00:38.090
protocols, AuthSub and
ClientLogin, and I realized

00:00:38.090 --> 00:00:42.490
how painful doing authorization
for our APIs was

00:00:42.490 --> 00:00:43.870
for developers.

00:00:43.870 --> 00:00:46.510
And frankly, I think most
developers spend about 80% of

00:00:46.510 --> 00:00:49.000
their time dealing with
authorization, and then the

00:00:49.000 --> 00:00:52.740
other 20% of the time dealing
with the actual APIs that they

00:00:52.740 --> 00:00:55.410
were using, and that's
kind of sad.

00:00:55.410 --> 00:00:57.770
And it was especially
problematic because, back

00:00:57.770 --> 00:01:01.540
then, there were these
proprietary protocols across

00:01:01.540 --> 00:01:03.790
many different API providers,
so if you learned how to

00:01:03.790 --> 00:01:07.240
interact with Google's APIs
using ClientLogin or AuthSub,

00:01:07.240 --> 00:01:10.580
and you went over to Yahoo, you
might have to use BBAuth.

00:01:10.580 --> 00:01:12.550
You went to other providers,
you have to use other

00:01:12.550 --> 00:01:14.690
protocols, and this
is really painful.

00:01:14.690 --> 00:01:18.970
So I'm super happy that we've
standardized on OAuth for

00:01:18.970 --> 00:01:20.480
authorization.

00:01:20.480 --> 00:01:23.430
We had OAuth 1, and that was
still a little bit of painful

00:01:23.430 --> 00:01:24.440
for developers to use.

00:01:24.440 --> 00:01:27.700
At least, it was standard across
many providers, and now

00:01:27.700 --> 00:01:29.090
we're at OAuth 2.

00:01:29.090 --> 00:01:33.720
The draft is nearly complete,
any day now, I think.

00:01:33.720 --> 00:01:38.280
And with OAuth 2, things got a
lot easier for developers, and

00:01:38.280 --> 00:01:40.470
we'll show you how it works.

00:01:40.470 --> 00:01:42.800
OAuth 2 is such a passion of
mine that I actually recently

00:01:42.800 --> 00:01:46.930
released a book, a few months
ago, with O'Reilly, talking

00:01:46.930 --> 00:01:47.520
about OAuth 2.

00:01:47.520 --> 00:01:50.320
It's a very short book, but
gives you a good introduction

00:01:50.320 --> 00:01:53.270
in about '90 pages, I believe.

00:01:53.270 --> 00:01:57.520
So in order to understand
OAuth, we first need to

00:01:57.520 --> 00:02:00.770
understand a variety
of different terms.

00:02:00.770 --> 00:02:05.340
I went sailing last weekend,
sailing school, and sailing is

00:02:05.340 --> 00:02:07.060
all about terminology.

00:02:07.060 --> 00:02:10.330
There's way too many terms
even for me to remember.

00:02:10.330 --> 00:02:12.300
Hopefully, OAuth will be a
little bit better than that,

00:02:12.300 --> 00:02:14.000
but there are various terms.

00:02:14.000 --> 00:02:17.680
So we're going to introduce a
couple terms up front here,

00:02:17.680 --> 00:02:20.020
and then throughout the talk,
we'll give you some additional

00:02:20.020 --> 00:02:24.650
terms that are little bit less
important, but are nonetheless

00:02:24.650 --> 00:02:27.630
things that are essential
to understand OAuth.

00:02:27.630 --> 00:02:31.110
So the first term is
authorization.

00:02:31.110 --> 00:02:32.270
Sorry, authentication.

00:02:32.270 --> 00:02:36.000
See, even I'm mixing
these two up.

00:02:36.000 --> 00:02:37.460
All right, pause
here a second.

00:02:37.460 --> 00:02:38.340
Authentication.

00:02:38.340 --> 00:02:40.770
Authentication is about
verifying the identity of a

00:02:40.770 --> 00:02:44.390
user, knowing the user is
who they say they are.

00:02:44.390 --> 00:02:46.920
When you go and visit a website,
and it asks you to

00:02:46.920 --> 00:02:51.160
login, you type a user name
and password, that website

00:02:51.160 --> 00:02:54.480
verifies that you've typed the
right password for that

00:02:54.480 --> 00:02:57.380
account, and thus has
authenticated you.

00:02:57.380 --> 00:02:59.650
It's validated your identity.

00:02:59.650 --> 00:03:03.460
But after it authenticates you,
it needs to figure out

00:03:03.460 --> 00:03:06.350
what resources you should have
access to, and that's what

00:03:06.350 --> 00:03:08.920
authorization is all about,
making sure that you have

00:03:08.920 --> 00:03:12.670
access to your data and only
your data, or the very least

00:03:12.670 --> 00:03:14.780
only appropriate data.

00:03:14.780 --> 00:03:17.720
So if you went and logged into
your email account, and you

00:03:17.720 --> 00:03:20.990
had access to your colleague
Tom's email, this

00:03:20.990 --> 00:03:21.860
would be a bad thing.

00:03:21.860 --> 00:03:24.330
So that's what authorization is
all about, making sure that

00:03:24.330 --> 00:03:25.885
you have access to only
the right information.

00:03:29.120 --> 00:03:31.030
Questions for you.

00:03:31.030 --> 00:03:35.650
How many of you ever shared a
password with an application,

00:03:35.650 --> 00:03:38.850
a third party app, so it can
access your data on something

00:03:38.850 --> 00:03:41.940
like Google or Twitter
or Facebook?

00:03:41.940 --> 00:03:43.480
Raise your hands.

00:03:43.480 --> 00:03:45.650
All right, some of you are just
being shy here, because

00:03:45.650 --> 00:03:48.690
I'm pretty sure everyone in this
audience has done that at

00:03:48.690 --> 00:03:51.640
some point in time, and this is
obviously very bad for the

00:03:51.640 --> 00:03:53.330
security of you.

00:03:53.330 --> 00:03:57.400
And it's also very bad for the
security of users as, after

00:03:57.400 --> 00:03:58.860
all, you guys are developers.

00:03:58.860 --> 00:04:00.100
You have plenty of users.

00:04:00.100 --> 00:04:03.020
You should never be asking them
for their passwords for

00:04:03.020 --> 00:04:06.380
any of the major account
holders.

00:04:06.380 --> 00:04:08.180
So you have an opportunity.

00:04:08.180 --> 00:04:10.850
You have an opportunity, as
developers, to eliminate the

00:04:10.850 --> 00:04:15.030
need for users to reveal the
passwords to your application.

00:04:15.030 --> 00:04:17.470
At the same time, you have an
opportunity to restrict the

00:04:17.470 --> 00:04:21.209
level of data available to your
application to only what

00:04:21.209 --> 00:04:23.420
your application needs in
order to make a good

00:04:23.420 --> 00:04:25.540
experience for your users.

00:04:25.540 --> 00:04:27.690
And then you have an opportunity
to allow the users

00:04:27.690 --> 00:04:31.460
to revoke access to your app
when your application no

00:04:31.460 --> 00:04:35.010
longer needs access
to their data.

00:04:35.010 --> 00:04:37.820
This is your opportunity, but
it's important to understand.

00:04:37.820 --> 00:04:41.130
I believe that you have an
obligation to your users, an

00:04:41.130 --> 00:04:44.500
obligation to help keep
your users safe.

00:04:44.500 --> 00:04:46.100
And so you have an opportunity,
but also a

00:04:46.100 --> 00:04:47.860
responsibility here.

00:04:47.860 --> 00:04:50.930
A few more questions for you.

00:04:50.930 --> 00:04:52.330
Sorry, that was what
OAuth 2 for

00:04:52.330 --> 00:04:54.280
authorization is all about.

00:04:54.280 --> 00:04:56.280
Now, we'll get into a
few more questions.

00:04:56.280 --> 00:04:58.210
Do you use the same user
name and password

00:04:58.210 --> 00:05:00.580
for multiple sites?

00:05:00.580 --> 00:05:02.920
How many of you do that?

00:05:02.920 --> 00:05:04.710
Tell you a little story here.

00:05:04.710 --> 00:05:07.790
Of course, everyone does this.

00:05:07.790 --> 00:05:11.140
I think it was like a week or
two ago when some major

00:05:11.140 --> 00:05:13.900
website, which I won't name,
managed to get a lot of their

00:05:13.900 --> 00:05:17.100
passwords leaked out
onto the web.

00:05:17.100 --> 00:05:19.540
And I didn't know about this,
and I looked over at one of my

00:05:19.540 --> 00:05:21.420
colleagues, and he was
looking really sad.

00:05:21.420 --> 00:05:25.090
And I'm like, Sean, why are you
looking really sad today?

00:05:25.090 --> 00:05:28.500
And he told me that now that
his password was leaked out

00:05:28.500 --> 00:05:31.180
there on the web, he has to go
change his password, not only

00:05:31.180 --> 00:05:34.950
on this site, but on dozens of
other sites around the web,

00:05:34.950 --> 00:05:36.980
and he didn't even know
what those sites were.

00:05:36.980 --> 00:05:40.090
So he was basically thinking,
you know what, I had some free

00:05:40.090 --> 00:05:41.040
time this evening.

00:05:41.040 --> 00:05:43.410
No longer do I have any free
time that evening, or maybe

00:05:43.410 --> 00:05:45.190
even the next couple days.

00:05:45.190 --> 00:05:47.310
So he was really sad about this,
and you don't want to be

00:05:47.310 --> 00:05:49.250
in the position of being sad.

00:05:49.250 --> 00:05:53.750
And as developers, you don't
want to make your users sad,

00:05:53.750 --> 00:05:56.440
or have a risk of making
your users sad.

00:05:56.440 --> 00:05:57.780
Another question.

00:05:57.780 --> 00:06:00.370
How many keystrokes do you type
when you sign up for a

00:06:00.370 --> 00:06:01.980
new account?

00:06:01.980 --> 00:06:02.720
Call out some answers.

00:06:02.720 --> 00:06:04.890
AUDIENCE: [INAUDIBLE].

00:06:04.890 --> 00:06:06.230
RYAN BOYD: All right,
all over the board.

00:06:06.230 --> 00:06:07.850
Some of you have much
longer passwords

00:06:07.850 --> 00:06:09.180
than others, I guess.

00:06:09.180 --> 00:06:11.730
I think I type about
50 characters.

00:06:11.730 --> 00:06:14.230
I have a relatively short
name even if I

00:06:14.230 --> 00:06:15.730
do use longer passwords.

00:06:15.730 --> 00:06:17.060
50+ characters.

00:06:17.060 --> 00:06:20.000
My first name, my last name,
my email address, password

00:06:20.000 --> 00:06:21.715
once, password confirm.

00:06:21.715 --> 00:06:23.860
That's a lot of characters
to type when you

00:06:23.860 --> 00:06:25.510
sign up for new account.

00:06:25.510 --> 00:06:28.570
What if you could drop that
down into two mouse clicks

00:06:28.570 --> 00:06:32.780
instead of 50 plus characters
typed on the keyboard?

00:06:32.780 --> 00:06:34.540
So again, you have some
opportunities.

00:06:34.540 --> 00:06:36.430
You have an opportunity to
minimize the number of

00:06:36.430 --> 00:06:39.260
passwords your users
need to remember.

00:06:39.260 --> 00:06:43.420
You an opportunity to discourage
reuse of passwords.

00:06:43.420 --> 00:06:45.510
And then you have an opportunity
to optimize the

00:06:45.510 --> 00:06:49.610
sign up flows for your
application to get users on

00:06:49.610 --> 00:06:50.910
board faster.

00:06:50.910 --> 00:06:54.460
If you get users on board faster
in your application,

00:06:54.460 --> 00:06:56.570
then you get more and more
users, and hopefully, you

00:06:56.570 --> 00:07:00.110
become wealthy with
the next IPO.

00:07:00.110 --> 00:07:04.110
And this is what OAuth 2.0
for login is about.

00:07:04.110 --> 00:07:06.470
And I use that term because
that's the term we use in our

00:07:06.470 --> 00:07:07.860
documentation.

00:07:07.860 --> 00:07:11.820
Externally, you'll see this as
OpenID Connect or OAuth 2 for

00:07:11.820 --> 00:07:13.090
Authentication.

00:07:13.090 --> 00:07:14.660
All sorts of different
terms, but they all

00:07:14.660 --> 00:07:18.030
mean the same thing.

00:07:18.030 --> 00:07:21.290
So our agenda, we talked
about some terminology.

00:07:21.290 --> 00:07:23.860
Next we're going to go into
authorization and go through

00:07:23.860 --> 00:07:26.040
how you do authorization in
a variety of different

00:07:26.040 --> 00:07:28.640
environments, whether you're
in a pure JavaScript

00:07:28.640 --> 00:07:31.600
environment on the browser,
or whether you're doing a

00:07:31.600 --> 00:07:35.830
server-side environment with
server-side code, or whether

00:07:35.830 --> 00:07:38.280
you're doing a mobile
environment, or even some

00:07:38.280 --> 00:07:40.740
newer things with service
accounts.

00:07:40.740 --> 00:07:43.170
And then we're going to get
into authentication, and

00:07:43.170 --> 00:07:46.400
lastly, end up with a set of
resources that will hopefully

00:07:46.400 --> 00:07:49.340
be very valuable to you,
including a link to the slides

00:07:49.340 --> 00:07:51.350
so you don't need to be
furiously taking notes.

00:07:54.240 --> 00:07:58.450
All right, so OAuth 2
for Authorization.

00:07:58.450 --> 00:08:04.650
Google has 35+ APIs which
are enabled for OAuth 2

00:08:04.650 --> 00:08:05.650
authorization.

00:08:05.650 --> 00:08:07.110
Now, I say 35+.

00:08:07.110 --> 00:08:08.340
I've had these slides
for a bit.

00:08:08.340 --> 00:08:10.760
I tried to count this morning.

00:08:10.760 --> 00:08:14.220
There is probably many more
than this, but at least 35

00:08:14.220 --> 00:08:18.460
APIs that Google has that you
can use OAuth 2 to get

00:08:18.460 --> 00:08:21.500
authorization for, and this is
everything from Calendar and

00:08:21.500 --> 00:08:24.510
Contacts to things like
YouTube and Google+.

00:08:24.510 --> 00:08:27.860
All the Google APIs, when they
require authorization,

00:08:27.860 --> 00:08:30.160
support OAuth 2.

00:08:30.160 --> 00:08:33.530
And not only do we have 35
APIs at Google, there are

00:08:33.530 --> 00:08:37.400
hundreds of other APIs around
the web, which use OAuth for

00:08:37.400 --> 00:08:38.000
authorization.

00:08:38.000 --> 00:08:40.650
Many of them are still an OAuth
1, but I'm sure they'll

00:08:40.650 --> 00:08:44.350
be upgrading soon to OAuth 2.

00:08:44.350 --> 00:08:48.880
Now, your goal when working with
OAuth is to get access to

00:08:48.880 --> 00:08:52.390
a user's data in one
of these APIs.

00:08:52.390 --> 00:08:59.740
In order to accomplish that
goal, you need to get a token.

00:08:59.740 --> 00:09:02.570
This is what a token
looks like.

00:09:02.570 --> 00:09:06.120
Well, not really, but
this is a image to

00:09:06.120 --> 00:09:08.230
represent an access token.

00:09:08.230 --> 00:09:12.010
OAuth 2 works off the concept of
access tokens, and all the

00:09:12.010 --> 00:09:14.680
various OAuth flows that we're
going to show you here today,

00:09:14.680 --> 00:09:19.000
your goal is to acquire one
of these access tokens.

00:09:19.000 --> 00:09:22.830
And this access token if then
used to access an API on

00:09:22.830 --> 00:09:24.850
behalf the user.

00:09:24.850 --> 00:09:27.360
So in each of the flows, we're
going to show you how to get

00:09:27.360 --> 00:09:28.650
an access token.

00:09:28.650 --> 00:09:30.820
And then a little bit later in
the presentation, we're going

00:09:30.820 --> 00:09:33.740
to actually show you how to
use that access token to

00:09:33.740 --> 00:09:36.530
access the API, but trust me,
once you have this access

00:09:36.530 --> 00:09:37.780
token, you're all set.

00:09:42.150 --> 00:09:44.810
All right, so to get started,
the first thing that you need

00:09:44.810 --> 00:09:48.700
to do to get started with OAuth
is to register your

00:09:48.700 --> 00:09:50.040
application.

00:09:50.040 --> 00:09:52.990
You can visit the Google APIs
console, and you can register

00:09:52.990 --> 00:09:55.040
your application, and this
will give you all the

00:09:55.040 --> 00:09:58.340
information that you need to
get started with OAuth, in

00:09:58.340 --> 00:10:02.240
particular ClientID and also
some other information.

00:10:02.240 --> 00:10:05.100
So you can access that now on
the new developers.google.com

00:10:05.100 --> 00:10:08.480
site,
developers.goggle.com/console,

00:10:08.480 --> 00:10:11.510
and you can register your app.

00:10:11.510 --> 00:10:12.510
So let's get into it.

00:10:12.510 --> 00:10:14.360
Let's get to the pure
JavaScript flow.

00:10:14.360 --> 00:10:16.630
If you're developing client-side
applications that

00:10:16.630 --> 00:10:19.550
require only the browser, how
many of you work mostly in

00:10:19.550 --> 00:10:21.790
JavaScript?

00:10:21.790 --> 00:10:23.060
OK, handful of you.

00:10:23.060 --> 00:10:25.110
For those people that like the
server-side code, we're going

00:10:25.110 --> 00:10:27.680
to come up with some other
things here later.

00:10:27.680 --> 00:10:31.610
But the most simplistic flow is
this pure JavaScript flow,

00:10:31.610 --> 00:10:33.020
and it works something
like this.

00:10:33.020 --> 00:10:34.830
I'm going to go through a
diagram here, and then I'm

00:10:34.830 --> 00:10:36.520
going to go into the
actual code in one

00:10:36.520 --> 00:10:38.350
of our client libraries.

00:10:38.350 --> 00:10:41.720
And then I assume, because you
guys are in a session on OAuth

00:10:41.720 --> 00:10:44.800
2, that you want to know how it
works underneath the cover,

00:10:44.800 --> 00:10:48.740
so I'm going to go into the
raw protocol as well.

00:10:48.740 --> 00:10:51.110
So the first thing that we have
here, and it's a little

00:10:51.110 --> 00:10:53.690
bit small, but we have this fake
app called Taskman, and

00:10:53.690 --> 00:10:57.840
Taskman displays your tasks
from your Google Tasks.

00:10:57.840 --> 00:11:01.600
And Taskman says to the user we
need access to your Google

00:11:01.600 --> 00:11:04.960
Tasks and gives you a button
to click on and say go to

00:11:04.960 --> 00:11:08.640
Google to grant authorization.

00:11:08.640 --> 00:11:12.070
Pops open a window that looks
something like this, where

00:11:12.070 --> 00:11:15.350
Google says that Taskman is
requesting access to your

00:11:15.350 --> 00:11:17.640
Google Tasks, and you're
given the option to

00:11:17.640 --> 00:11:19.520
allow it or deny it.

00:11:19.520 --> 00:11:22.970
If you allow it, it's going to
redirect you back to the

00:11:22.970 --> 00:11:25.070
Taskman application.

00:11:25.070 --> 00:11:27.040
And you're going to notice here,
at the top right, we

00:11:27.040 --> 00:11:30.520
have an access token, and this
access token is in the hash

00:11:30.520 --> 00:11:32.760
fragment of the URL.

00:11:32.760 --> 00:11:35.980
What that means is this access
token is sent only through the

00:11:35.980 --> 00:11:39.970
web browser and doesn't actually
get sent back to the

00:11:39.970 --> 00:11:42.820
web server where the Taskman
application is coming from.

00:11:42.820 --> 00:11:45.640
It's only in the web browser.

00:11:45.640 --> 00:11:49.270
And then in JavaScript code,
we use that access token to

00:11:49.270 --> 00:11:51.990
call the Google Tasks
API servers.

00:11:51.990 --> 00:11:55.540
And I believe Google Tasks now
supports cores, but you could

00:11:55.540 --> 00:11:58.791
also use JSONP and that
sort of thing.

00:11:58.791 --> 00:12:01.176
All right, so let's show
you how it works.

00:12:01.176 --> 00:12:04.300
I'm going to give you a quick
demo with the real code, and

00:12:04.300 --> 00:12:07.760
in this case, the slide deck
is my Taskman application.

00:12:07.760 --> 00:12:10.950
So I'm going to say let's see
it in action, and it's going

00:12:10.950 --> 00:12:13.410
to pop open-- this is actually a
pop up window, but since I'm

00:12:13.410 --> 00:12:16.520
in presentation view, it looks
like I replaced the window.

00:12:16.520 --> 00:12:21.000
But I'll hit Allow Access, and
in there are my Google Tasks.

00:12:21.000 --> 00:12:23.230
My Google Tasks have been
printed out right in this

00:12:23.230 --> 00:12:23.890
presentation.

00:12:23.890 --> 00:12:27.030
The beauty of using HTML5 for
your presentations so you can

00:12:27.030 --> 00:12:29.000
embed this stuff
right in there.

00:12:29.000 --> 00:12:31.470
So this had access,
using JavaScript,

00:12:31.470 --> 00:12:33.630
to my Google Tasks.

00:12:33.630 --> 00:12:37.460
This was done using the
JavaScript client library, and

00:12:37.460 --> 00:12:39.830
the JavaScript client library
to do this sort of thing is

00:12:39.830 --> 00:12:41.770
just a handful of
lines of code.

00:12:41.770 --> 00:12:44.460
First off, some configuration.

00:12:44.460 --> 00:12:46.400
You can see the client_ID.

00:12:46.400 --> 00:12:49.390
The client_ID is a value that
we've acquired from the Google

00:12:49.390 --> 00:12:51.140
APIs console.

00:12:51.140 --> 00:12:53.040
And then we see the scope.

00:12:53.040 --> 00:12:57.120
The scope in OAuth is
basically a string.

00:12:57.120 --> 00:13:01.510
In Google's terms, we put this
in a URI, and this URI

00:13:01.510 --> 00:13:04.540
basically says that my
application's looking for

00:13:04.540 --> 00:13:06.660
access to Google Tasks.

00:13:06.660 --> 00:13:09.270
You can specify more than one
scope, and I'll show you how

00:13:09.270 --> 00:13:12.190
that works later, but for now,
we're asking for Google tasks.

00:13:12.190 --> 00:13:14.650
And then there's a callback
handler there, and that

00:13:14.650 --> 00:13:18.390
callback handler has access to
the actual access token.

00:13:18.390 --> 00:13:22.450
And we just do a quick
JavaScript alert here, and

00:13:22.450 --> 00:13:26.550
thus, we've reached our goal,
and we have an access token.

00:13:26.550 --> 00:13:28.780
Here's how it works in
JavaScript under the covers,

00:13:28.780 --> 00:13:29.280
like I said.

00:13:29.280 --> 00:13:32.460
The client library really does
a lot of this for you, but

00:13:32.460 --> 00:13:34.300
you're in a session on OAuth,
you probably want to see

00:13:34.300 --> 00:13:36.340
what's happening under
the covers.

00:13:36.340 --> 00:13:39.600
So here, you're defining a
client_ID, the base of

00:13:39.600 --> 00:13:43.110
Google's URLs for
OAuth provider.

00:13:43.110 --> 00:13:44.930
The redirect URI.

00:13:44.930 --> 00:13:49.820
The redirect URI's simply
the application's URL.

00:13:49.820 --> 00:13:54.020
Then the scope, the tasks API
again, and then we're just

00:13:54.020 --> 00:13:56.730
building up, concatenating a
string to really ugly, tacky

00:13:56.730 --> 00:13:58.970
way, but concatenating
a string together to

00:13:58.970 --> 00:14:00.080
build up this URL.

00:14:00.080 --> 00:14:04.020
Then we're opening up a popup
window to this URL.

00:14:04.020 --> 00:14:05.470
Here's what that
URL looks like.

00:14:10.210 --> 00:14:12.390
And that results in a screen
that looks like this.

00:14:12.390 --> 00:14:14.270
The user hits Allow.

00:14:14.270 --> 00:14:16.680
The user's redirected back
to the application.

00:14:16.680 --> 00:14:19.740
And you can see that hash
fragment there, and in that

00:14:19.740 --> 00:14:22.550
hash fragment is an
access token.

00:14:22.550 --> 00:14:25.400
This is the token that allows
you to access the API on

00:14:25.400 --> 00:14:26.820
behalf of the user.

00:14:26.820 --> 00:14:29.840
And then there's also
a token_type=bearer.

00:14:29.840 --> 00:14:33.020
Basically what this means,
they're called bearer tokens,

00:14:33.020 --> 00:14:36.710
and bearer tokens-- all you need
to do to get access to

00:14:36.710 --> 00:14:40.140
the user's data on behalf of
a user is to present one of

00:14:40.140 --> 00:14:42.280
these bearer tokens.

00:14:42.280 --> 00:14:44.980
And OAuth 2 really adds
this simplification.

00:14:44.980 --> 00:14:47.310
Most of OAuth 2 does not
require cryptographic

00:14:47.310 --> 00:14:50.560
signatures, but it assumes that
your API calls are being

00:14:50.560 --> 00:14:55.920
made over SSL, so it's OK to
pass this bearer token in the

00:14:55.920 --> 00:14:58.760
actual HTTP request.

00:14:58.760 --> 00:15:02.090
And then we have
expires_in=3600.

00:15:02.090 --> 00:15:05.720
It's 3,600 seconds
or 60 minutes.

00:15:05.720 --> 00:15:07.120
And we reached our goal.

00:15:07.120 --> 00:15:10.890
We have this access token.

00:15:10.890 --> 00:15:13.805
So questions that
you might have.

00:15:13.805 --> 00:15:15.720
We are going to have a Q&amp;A
period at the end.

00:15:15.720 --> 00:15:17.380
You can come up to the
microphones at the end, but

00:15:17.380 --> 00:15:19.540
I'm going to predict a couple
questions here that you might

00:15:19.540 --> 00:15:21.450
have for this particular flow.

00:15:21.450 --> 00:15:25.320
And the first is how do you get
the token back from the

00:15:25.320 --> 00:15:28.300
popup window back to
the application?

00:15:28.300 --> 00:15:31.880
So there's HTML5 postmessage
is one great way to do it.

00:15:31.880 --> 00:15:34.440
If you're looking to support
some older web browsers, you

00:15:34.440 --> 00:15:39.230
can use window.opener in
JavaScript to pass it back.

00:15:39.230 --> 00:15:40.410
I've used both of them.

00:15:40.410 --> 00:15:44.100
Both work, but if you're
supporting just modern web

00:15:44.100 --> 00:15:46.130
browsers, the HTML5 postmessage
is probably the

00:15:46.130 --> 00:15:48.550
best way to go.

00:15:48.550 --> 00:15:50.460
How do you get another
access token?

00:15:50.460 --> 00:15:52.020
Well, you saw that
that access token

00:15:52.020 --> 00:15:54.910
expired in 3,600 seconds.

00:15:54.910 --> 00:15:58.660
So in 3,600 seconds, you're
going to need to get another

00:15:58.660 --> 00:16:02.400
access token, and you can do
this by running the exact same

00:16:02.400 --> 00:16:04.220
flow over again.

00:16:04.220 --> 00:16:06.450
So you do the exact same thing,
and only this time

00:16:06.450 --> 00:16:09.490
around, the user's not going to
be prompted for access to

00:16:09.490 --> 00:16:12.240
their data because the user's
already granted access to

00:16:12.240 --> 00:16:14.000
their data.

00:16:14.000 --> 00:16:16.520
And this does do the popup
window and all.

00:16:16.520 --> 00:16:20.580
You can actually do it without
the pop up window.

00:16:20.580 --> 00:16:24.530
There is a way to do that with
OAuth, at least Google's OAuth

00:16:24.530 --> 00:16:28.720
provider, and you can ask me
about that later if you have

00:16:28.720 --> 00:16:29.680
any questions on that.

00:16:29.680 --> 00:16:31.160
But it makes the
user experience

00:16:31.160 --> 00:16:33.500
a little bit easier.

00:16:33.500 --> 00:16:37.210
And then what happens if the
user's not logged in?

00:16:37.210 --> 00:16:39.340
If the user's not logged into
their Google account at the

00:16:39.340 --> 00:16:41.140
time they go through this
OAuth flow, they will be

00:16:41.140 --> 00:16:42.720
prompted to log in.

00:16:42.720 --> 00:16:47.150
So we kind of assume that, most
times, the user is logged

00:16:47.150 --> 00:16:51.250
into their Google account, and
so the user will have to log

00:16:51.250 --> 00:16:52.500
in if they're not.

00:16:54.640 --> 00:16:58.840
So you use the client-side flow
if you're looking for

00:16:58.840 --> 00:16:59.650
simplicity.

00:16:59.650 --> 00:17:01.180
You'll see the diagram
here soon.

00:17:01.180 --> 00:17:02.790
It's a little bit more
complex to use some

00:17:02.790 --> 00:17:04.220
of the other flows.

00:17:04.220 --> 00:17:07.050
If you like to do coding in
JavaScript, you only need to

00:17:07.050 --> 00:17:10.089
access when the user is
logged into Google.

00:17:10.089 --> 00:17:12.190
And there's some more
information about our

00:17:12.190 --> 00:17:15.220
JavaScript library at a session
that already happened,

00:17:15.220 --> 00:17:17.130
but you should be to catch
it on YouTube.

00:17:17.130 --> 00:17:19.500
"Building Web Applications that
use Google APIs and the

00:17:19.500 --> 00:17:22.560
JavaScript Client for Google
APIs." A very descriptive

00:17:22.560 --> 00:17:24.750
session title.

00:17:24.750 --> 00:17:29.950
All right, the vast majority of
you seem to not raise your

00:17:29.950 --> 00:17:33.170
hand when I asked you if you
code mostly in JavaScript, so

00:17:33.170 --> 00:17:36.080
I'm assuming you're looking
for server-side code.

00:17:36.080 --> 00:17:37.150
I'm going to show
the server-side

00:17:37.150 --> 00:17:38.590
code in Python here.

00:17:38.590 --> 00:17:41.310
This is using our
Python library.

00:17:41.310 --> 00:17:44.850
We have, I think, nine client
libraries that all support

00:17:44.850 --> 00:17:47.265
OAuth 2, so you can use
it in a variety

00:17:47.265 --> 00:17:48.300
of different languages.

00:17:48.300 --> 00:17:52.050
I'm just using Python
for this demo here.

00:17:52.050 --> 00:17:53.330
And we'll start off
with one of these

00:17:53.330 --> 00:17:56.320
diagrams, step by step.

00:17:56.320 --> 00:17:58.055
The first step looks the same.

00:17:58.055 --> 00:17:59.800
The user experience
here is the same.

00:17:59.800 --> 00:18:02.610
The user gets prompted and said,
hey, this application

00:18:02.610 --> 00:18:04.390
needs access to Google Tasks.

00:18:04.390 --> 00:18:07.310
They go over to Google, and
they get this screen.

00:18:07.310 --> 00:18:08.340
It looks very similar.

00:18:08.340 --> 00:18:11.680
The only difference here is the
line at the bottom that

00:18:11.680 --> 00:18:15.320
says it needs access when you're
not at your keyboard.

00:18:15.320 --> 00:18:17.330
So in this case, for the
server-side flow, we're

00:18:17.330 --> 00:18:20.110
getting access to user's data
even when the user's not

00:18:20.110 --> 00:18:22.770
actively logged into
their account.

00:18:22.770 --> 00:18:26.920
The user approves, then it
redirects to the application

00:18:26.920 --> 00:18:29.870
with this authorization code.

00:18:29.870 --> 00:18:32.230
The authorization code, you
notice, is passed in a query

00:18:32.230 --> 00:18:34.090
parameter, not in the hash
fragment, and the

00:18:34.090 --> 00:18:38.430
authorization code is sort of
intermediate code that's used

00:18:38.430 --> 00:18:40.680
to eventually get
an access token.

00:18:40.680 --> 00:18:43.580
Because it's passed in the query
parameter, though, it is

00:18:43.580 --> 00:18:47.210
passed to the back end web
server of the Taskman

00:18:47.210 --> 00:18:47.920
applications.

00:18:47.920 --> 00:18:51.480
So the Taskman application gets
that code, and then calls

00:18:51.480 --> 00:18:55.350
over to the OAuth provider and
exchanges that code for an

00:18:55.350 --> 00:19:01.140
access token, which is then
uses to call the API.

00:19:01.140 --> 00:19:04.030
So slightly more complex than
the previous flow, but it has

00:19:04.030 --> 00:19:06.820
this added benefit of giving you
the ability to get offline

00:19:06.820 --> 00:19:10.890
access to the users data.

00:19:10.890 --> 00:19:12.240
So let's step through
it in Python.

00:19:14.900 --> 00:19:17.150
A bunch of configuration
stuff up front.

00:19:17.150 --> 00:19:19.390
So you can see here, we
have a client_ID,

00:19:19.390 --> 00:19:20.290
and we have a scope.

00:19:20.290 --> 00:19:21.780
You saw those before.

00:19:21.780 --> 00:19:24.470
We additionally have
this client_secret.

00:19:24.470 --> 00:19:27.700
This client_secret also comes
from the API's console.

00:19:27.700 --> 00:19:29.960
When you register your
application, we give you a

00:19:29.960 --> 00:19:34.080
client_secret, and then you
can use this client_secret

00:19:34.080 --> 00:19:36.490
with the web server flow here.

00:19:36.490 --> 00:19:39.180
You might wonder why do I have
a client_secret here, and I

00:19:39.180 --> 00:19:42.750
didn't have a client_secret
in the previous example in

00:19:42.750 --> 00:19:43.730
JavaScript.

00:19:43.730 --> 00:19:46.510
The client_secret just adds an
additional level of security.

00:19:46.510 --> 00:19:49.530
It basically authenticates
your app when your app is

00:19:49.530 --> 00:19:53.260
talking to the OAuth provider.

00:19:53.260 --> 00:19:55.840
And security is all about
adding these additional

00:19:55.840 --> 00:19:58.030
layers, and we think it's
important to add additional

00:19:58.030 --> 00:20:00.810
layers when you're getting
higher levels of access.

00:20:00.810 --> 00:20:02.920
So in this case, you're getting
access while the

00:20:02.920 --> 00:20:07.830
user's offline, so there's a
little bit more security here.

00:20:07.830 --> 00:20:10.550
And then you basically just
generate a URL and redirect

00:20:10.550 --> 00:20:12.060
the user over to the URL.

00:20:12.060 --> 00:20:14.835
This is exact same as you saw
with the JavaScript flow.

00:20:17.980 --> 00:20:19.930
The URL will look something
like this.

00:20:19.930 --> 00:20:23.620
The only two parameters that are
different in that URL are

00:20:23.620 --> 00:20:27.470
the response type of code
instead of Token and then the

00:20:27.470 --> 00:20:30.910
access type of Offline, saying
you really do want offline

00:20:30.910 --> 00:20:34.010
access to a user's data.

00:20:34.010 --> 00:20:36.460
You could also do the
authorization code flow, or

00:20:36.460 --> 00:20:38.780
the server to server flow,
without offline access, but

00:20:38.780 --> 00:20:43.700
most people are using it because
they need offline.

00:20:43.700 --> 00:20:46.140
Here's our approval
prompt screen in a

00:20:46.140 --> 00:20:47.310
real screen shot here.

00:20:47.310 --> 00:20:51.010
Perform these operations when
I'm not using the application.

00:20:51.010 --> 00:20:54.330
And then the user is redirected
back to the

00:20:54.330 --> 00:20:57.410
application, and you can see
that authorization code as a

00:20:57.410 --> 00:20:59.670
query parameter.

00:20:59.670 --> 00:21:03.100
Then the server exchanges that
authorization code for an

00:21:03.100 --> 00:21:04.830
access token.

00:21:04.830 --> 00:21:07.270
It's really just one
method call here.

00:21:07.270 --> 00:21:10.760
The flow step2_exchange,
passing in the request

00:21:10.760 --> 00:21:13.370
parameters, which includes
that authorization code.

00:21:13.370 --> 00:21:16.090
And we're getting back a
credentials object, and that

00:21:16.090 --> 00:21:19.370
credentials object has the
access token in it.

00:21:19.370 --> 00:21:20.780
And we've reached our goal.

00:21:20.780 --> 00:21:22.215
We have an access token.

00:21:22.215 --> 00:21:25.060
You guys excited we have
an access token?

00:21:25.060 --> 00:21:26.610
All right.

00:21:26.610 --> 00:21:29.860
We also, additionally, have
one other bit of data.

00:21:29.860 --> 00:21:31.770
We have a refresh token.

00:21:31.770 --> 00:21:34.210
This refresh token used
to get access later.

00:21:34.210 --> 00:21:37.540
If we need access after the 60
minutes, we can use this

00:21:37.540 --> 00:21:39.250
refresh token to get access.

00:21:39.250 --> 00:21:42.060
And we'll show you how that
works here shortly, but first,

00:21:42.060 --> 00:21:44.390
I want to show you the raw
protocol of what's happening

00:21:44.390 --> 00:21:49.450
underneath the covers for when
you're using this Python code.

00:21:49.450 --> 00:21:54.130
It's basically just and HTTPS
post to Google's OAuth

00:21:54.130 --> 00:21:58.340
provider, and passing those five
lines there, we have the

00:21:58.340 --> 00:22:02.260
grant type of authorization
code, the code itself, and

00:22:02.260 --> 00:22:03.720
then the client_secret.

00:22:03.720 --> 00:22:06.440
The client_secret, again,
authenticates your application

00:22:06.440 --> 00:22:08.630
to the OAuth provider.

00:22:08.630 --> 00:22:11.040
And Google returns a nice little
bob of JSON, looks

00:22:11.040 --> 00:22:14.820
something like this, and again
you have that access token and

00:22:14.820 --> 00:22:17.750
also the refresh token.

00:22:17.750 --> 00:22:21.920
So when you want to take that
access token and use it,

00:22:21.920 --> 00:22:26.400
normally you would have validity
for 60 minutes here.

00:22:26.400 --> 00:22:28.915
But when that's up, and you need
another access token, you

00:22:28.915 --> 00:22:30.770
use that refresh token.

00:22:30.770 --> 00:22:34.670
So what code do you have to do
exchange that refresh token

00:22:34.670 --> 00:22:36.372
for an access token?

00:22:36.372 --> 00:22:38.560
There's not much here.

00:22:38.560 --> 00:22:40.590
Really just one line of comment
because the client

00:22:40.590 --> 00:22:42.600
library actually does
this for you.

00:22:42.600 --> 00:22:44.810
The client library automatically
will exchange

00:22:44.810 --> 00:22:50.780
your refresh token to get a new
access token as is needed.

00:22:50.780 --> 00:22:52.710
But again, you probably want
to know what the client

00:22:52.710 --> 00:22:54.770
library's doing under the
covers, and it's really a

00:22:54.770 --> 00:22:57.860
simple HTTPS post again.

00:22:57.860 --> 00:23:00.650
And this post is saying, here,
I have this refresh token.

00:23:00.650 --> 00:23:04.320
Here's my client_secret grant
type refresh token, and again,

00:23:04.320 --> 00:23:07.800
getting back a new
access token.

00:23:07.800 --> 00:23:10.970
You can do this either when the
token already has expired

00:23:10.970 --> 00:23:14.700
and you know it does not work,
or you could do it as soon as

00:23:14.700 --> 00:23:17.640
you get a failure, or you
could do it in advance.

00:23:17.640 --> 00:23:20.500
You could say, hey, this expires
in 3,600 seconds.

00:23:20.500 --> 00:23:25.470
I'm going to start a timer and
automatically refresh in less

00:23:25.470 --> 00:23:27.020
than 3,600 seconds.

00:23:27.020 --> 00:23:29.890
Our client libraries, I think
most of them actually do this

00:23:29.890 --> 00:23:31.450
refresh in advance for you.

00:23:31.450 --> 00:23:33.300
It keeps track of the time.

00:23:33.300 --> 00:23:36.810
Some of them may actually wait
until it gets a failure.

00:23:36.810 --> 00:23:40.260
The difference in performance
isn't huge, but the client

00:23:40.260 --> 00:23:43.720
libraries will handle
this for you.

00:23:43.720 --> 00:23:47.860
So again, questions that you
might have at this point?

00:23:47.860 --> 00:23:50.270
When do these refresh
tokens expire?

00:23:50.270 --> 00:23:51.706
Does anyone want to guess?

00:23:51.706 --> 00:23:53.610
AUDIENCE: [INAUDIBLE].

00:23:53.610 --> 00:23:54.760
RYAN BOYD: Correct.

00:23:54.760 --> 00:23:58.150
The refresh tokens never expire
unless the user revokes

00:23:58.150 --> 00:24:01.090
access, and some people might
not call that expiration.

00:24:01.090 --> 00:24:05.290
But a user can revoke access,
going to their Google accounts

00:24:05.290 --> 00:24:09.370
and managing the list of APIs
they've authorized.

00:24:09.370 --> 00:24:12.680
And thus your refresh token will
no longer be valid, and

00:24:12.680 --> 00:24:17.180
you'll have to start the user
over in the normal flow.

00:24:17.180 --> 00:24:20.180
Where do you store these
refresh tokens?

00:24:20.180 --> 00:24:22.140
You typically store these
refresh tokens in your

00:24:22.140 --> 00:24:24.340
database alongside your
user account.

00:24:24.340 --> 00:24:28.430
So you get one refresh token
for every grant of a

00:24:28.430 --> 00:24:30.060
particular scope.

00:24:30.060 --> 00:24:34.370
If you do a grant of multiple
scopes, which we'll see here

00:24:34.370 --> 00:24:37.160
shortly, you'll still get one
refresh token for those

00:24:37.160 --> 00:24:41.780
multiple APIs, and you store
those in your user database.

00:24:41.780 --> 00:24:45.450
Now, those refresh tokens in
themselves aren't really that

00:24:45.450 --> 00:24:47.660
valuable, so it's OK
to just store it

00:24:47.660 --> 00:24:48.820
in your user database.

00:24:48.820 --> 00:24:51.840
But when combined with
the client_secret,

00:24:51.840 --> 00:24:53.020
they are very valuable.

00:24:53.020 --> 00:24:55.870
So you want to keep your
client_secret in a secure key

00:24:55.870 --> 00:24:59.550
store or something like that on
your server and make sure

00:24:59.550 --> 00:25:02.290
to limit access to that
client_secret because combine

00:25:02.290 --> 00:25:04.540
the client_secret with a refresh
token, and you get a

00:25:04.540 --> 00:25:08.630
new access token for
any of you users.

00:25:08.630 --> 00:25:11.320
So I want to show you one
other thing here.

00:25:11.320 --> 00:25:15.070
The code before wasn't that
challenging, but we can even

00:25:15.070 --> 00:25:16.320
make it easier.

00:25:18.460 --> 00:25:22.920
So this is showing you the
decorator flow, or decorator

00:25:22.920 --> 00:25:26.450
handler, in the Python
library.

00:25:26.450 --> 00:25:29.720
When running on App Engine,
we can just define a few

00:25:29.720 --> 00:25:33.600
variables up top, and then just
add this decorator to our

00:25:33.600 --> 00:25:37.440
web methods and basically say,
hey, OAuth is required for

00:25:37.440 --> 00:25:40.190
this method, and then
we'll handle the

00:25:40.190 --> 00:25:41.690
entire flow for you.

00:25:41.690 --> 00:25:44.750
Really, you can basically, if
you ignore indentation here

00:25:44.750 --> 00:25:46.500
and such, and formatting,
you could do this in

00:25:46.500 --> 00:25:47.480
two lines of code.

00:25:47.480 --> 00:25:52.530
You can add OAuth support to
your App Engine app in Python

00:25:52.530 --> 00:25:53.840
using this decorator method.

00:25:53.840 --> 00:25:56.880
So if you want to be lazy,
go for that mechanism.

00:25:56.880 --> 00:26:00.790
There's also a OAuth Aware is
another decorator that allows

00:26:00.790 --> 00:26:05.230
you to be a little bit more
handle the experience, but

00:26:05.230 --> 00:26:07.150
combine these together, if
makes it really easy to

00:26:07.150 --> 00:26:10.480
implement OAuth.

00:26:10.480 --> 00:26:15.020
So you're looking to your long
lived access to a user data.

00:26:15.020 --> 00:26:17.310
Pretty much, if you want long
lived access to a user data,

00:26:17.310 --> 00:26:20.180
you have to use the
server-side flow.

00:26:20.180 --> 00:26:23.370
You also use the server-side
flow if you need access when

00:26:23.370 --> 00:26:26.770
the user isn't at their keyboard
or you need to call

00:26:26.770 --> 00:26:29.490
the API from server-side code.

00:26:29.490 --> 00:26:31.930
And reminder, I showed this in
Python, but there's a bunch of

00:26:31.930 --> 00:26:34.050
different languages that we have
support for, or you can

00:26:34.050 --> 00:26:35.300
write your own code.

00:26:38.070 --> 00:26:40.620
So you have these tokens we've
reached our goal with both the

00:26:40.620 --> 00:26:43.550
client-side JavaScript flow
and with the server-side

00:26:43.550 --> 00:26:45.810
flown, and you have
this access token.

00:26:45.810 --> 00:26:50.160
Now, how do you use the access
token to access an API?

00:26:50.160 --> 00:26:51.750
It's pretty simple.

00:26:51.750 --> 00:26:53.980
There's two different ways.

00:26:53.980 --> 00:26:57.890
There's the preferred way, which
is using an HTTP header

00:26:57.890 --> 00:26:59.950
that looks something
like this.

00:26:59.950 --> 00:27:02.820
You make an HTTP request, you
have an authorization header,

00:27:02.820 --> 00:27:05.160
you're saying authorization
bearer, and you're putting

00:27:05.160 --> 00:27:07.830
that access token there.

00:27:07.830 --> 00:27:10.480
That is definitely the much
preferred way, and it is

00:27:10.480 --> 00:27:13.300
preferred because authorization
headers are very

00:27:13.300 --> 00:27:18.820
rarely logged in a web server
log, very rarely logged by a

00:27:18.820 --> 00:27:22.580
proxy server, very rarely
cached, et cetera, et cetera.

00:27:22.580 --> 00:27:26.760
So you want to use the HTTP
header whenever possible.

00:27:26.760 --> 00:27:29.370
Now, if you're trying to do
JSONP, or trying to do quick

00:27:29.370 --> 00:27:32.430
debugging, you may want a
different way to do this, and

00:27:32.430 --> 00:27:36.500
you can use a query parameter
and pass in the access token

00:27:36.500 --> 00:27:40.200
as a query parameter
in the URL here.

00:27:40.200 --> 00:27:43.270
So fairly simple either
way you do it.

00:27:43.270 --> 00:27:47.030
It's really just passing that
bearer token in plain text.

00:27:47.030 --> 00:27:50.510
But like I said, that plain text
then gets wrapped in SSL

00:27:50.510 --> 00:27:52.600
to make sure that this
is all secure.

00:27:55.710 --> 00:27:59.560
And if you want to have access
to multiple APIs at once, you

00:27:59.560 --> 00:28:01.860
could just do that by specifying
your scope in a

00:28:01.860 --> 00:28:04.270
space delimited list.

00:28:04.270 --> 00:28:06.210
So the space delimited
list looks like this.

00:28:06.210 --> 00:28:09.360
In this case, we're accessing
two separate APIs, and we've

00:28:09.360 --> 00:28:13.680
just specified both scopes
separated by a space, and you

00:28:13.680 --> 00:28:16.400
use that any time it asks you
for your scope field.

00:28:16.400 --> 00:28:20.220
And then the user will be
presented with both APIs.

00:28:20.220 --> 00:28:22.430
You can access a bunch of
different APIs it once.

00:28:22.430 --> 00:28:25.550
The user has presented it as an
all or nothing decision, so

00:28:25.550 --> 00:28:28.270
they have a choice to allow
access to your application for

00:28:28.270 --> 00:28:30.270
all of those or none of those.

00:28:30.270 --> 00:28:31.520
They can't be selective.

00:28:36.190 --> 00:28:39.050
How many of you are developers
that build mobile

00:28:39.050 --> 00:28:41.180
applications?

00:28:41.180 --> 00:28:42.280
Wow, a lot.

00:28:42.280 --> 00:28:43.800
I would think you'd be in
the Android session.

00:28:43.800 --> 00:28:45.940
Is there some bad session going
on right now on the

00:28:45.940 --> 00:28:48.310
Android track?

00:28:48.310 --> 00:28:52.250
Anyway, so mobile authorization,
it typically is

00:28:52.250 --> 00:28:55.460
what I've heard it as the
biggest challenge for

00:28:55.460 --> 00:28:58.420
developers when working
with authorization.

00:28:58.420 --> 00:29:01.780
It's very difficult to work with
authorization, and mobile

00:29:01.780 --> 00:29:03.220
apps typically--

00:29:03.220 --> 00:29:05.550
because there's not really a
prescriptive way to do it.

00:29:05.550 --> 00:29:07.560
You have some decisions
to make and some

00:29:07.560 --> 00:29:09.110
trade offs to make.

00:29:09.110 --> 00:29:12.240
OAuth 2 got a lot better in
giving some more choice of how

00:29:12.240 --> 00:29:15.520
to do this than OAuth 1, and
the spec actually talks a

00:29:15.520 --> 00:29:18.290
little bit about mobile apps,
which is helpful.

00:29:18.290 --> 00:29:21.910
But in the end, they're really
three different ways that you

00:29:21.910 --> 00:29:26.290
can get access on a mobile
application, or for a native

00:29:26.290 --> 00:29:29.830
mobile application by OAuth.

00:29:29.830 --> 00:29:32.510
The first, which is what
you see here, is an

00:29:32.510 --> 00:29:34.000
embedded web view.

00:29:34.000 --> 00:29:36.900
This is a cross platform way
that you can get access to a

00:29:36.900 --> 00:29:40.440
user's data from a native mobile
device, and basically,

00:29:40.440 --> 00:29:43.730
you embed a web view, which is
the OAuth authorization page,

00:29:43.730 --> 00:29:46.650
very similar to the URLs that
we saw earlier in the other

00:29:46.650 --> 00:29:52.860
flows, and the user gets to
allow or deny access here.

00:29:52.860 --> 00:29:55.640
Now, there's some great benefits
to this, considered

00:29:55.640 --> 00:29:58.300
by some, which is the
user experience.

00:29:58.300 --> 00:30:01.750
You get to see the OAuth
authorization

00:30:01.750 --> 00:30:03.360
page in the full screen.

00:30:03.360 --> 00:30:06.450
There's not too much
context switching.

00:30:06.450 --> 00:30:08.620
But there's also some drawbacks,
and the drawbacks

00:30:08.620 --> 00:30:09.440
are in two areas.

00:30:09.440 --> 00:30:13.220
One, in the user experience
again, and the drawback with

00:30:13.220 --> 00:30:18.980
the user experience is that the
user often times is logged

00:30:18.980 --> 00:30:23.100
in on their main web browser
to their Google account.

00:30:23.100 --> 00:30:25.670
But since the embedded web view
uses a different cookie

00:30:25.670 --> 00:30:28.320
store, they're not actually
logged in here, so they're

00:30:28.320 --> 00:30:31.420
asked to type in their user
name and password again.

00:30:31.420 --> 00:30:34.150
But that also leads to a
security concern because we're

00:30:34.150 --> 00:30:36.820
not seeing the standard
browser Chrome here.

00:30:36.820 --> 00:30:40.140
We're not seeing the normal
indicators that this is an SSL

00:30:40.140 --> 00:30:42.520
enabled website and the
certificate's been validated

00:30:42.520 --> 00:30:44.220
and things like that,
so there's

00:30:44.220 --> 00:30:46.680
some security concerns.

00:30:46.680 --> 00:30:49.870
The next way, which is also
cross platform, is to use the

00:30:49.870 --> 00:30:51.540
system web browser.

00:30:51.540 --> 00:30:54.520
Because the user is often
already logged in, this will

00:30:54.520 --> 00:30:57.180
just require them to essentially
do one tap to say

00:30:57.180 --> 00:31:02.400
Allow Access, and that's
the benefit.

00:31:02.400 --> 00:31:06.740
The drawbacks are, in the UX,
it is the standard browser,

00:31:06.740 --> 00:31:08.460
there's some context
switching.

00:31:08.460 --> 00:31:10.340
The user doesn't look like
they're still in your

00:31:10.340 --> 00:31:13.530
application, and then the
other drawback is it's

00:31:13.530 --> 00:31:16.970
difficult to communicate the
access token or authorization

00:31:16.970 --> 00:31:20.800
code back from the system
web browser back to the

00:31:20.800 --> 00:31:23.350
application depending
on the environment.

00:31:23.350 --> 00:31:25.590
There are some security concerns
there that you can

00:31:25.590 --> 00:31:28.140
ask me later about.

00:31:28.140 --> 00:31:30.080
So then the third way.

00:31:30.080 --> 00:31:32.470
The third way is
super exciting.

00:31:32.470 --> 00:31:35.250
It works only on Android.

00:31:35.250 --> 00:31:38.540
And it was just announced and
doesn't quite work just yet,

00:31:38.540 --> 00:31:41.320
but very soon in the coming
weeks, and it is the

00:31:41.320 --> 00:31:44.090
GoogleAuthUtil mechanism.

00:31:44.090 --> 00:31:46.610
This is part of the Google Play
services that we just

00:31:46.610 --> 00:31:51.050
announced, and this allows you
to create a much more superior

00:31:51.050 --> 00:31:55.100
user experience for your
authorization screen, which

00:31:55.100 --> 00:31:57.270
looks something like this.

00:31:57.270 --> 00:32:00.690
This is Google handling
it all for you.

00:32:00.690 --> 00:32:02.570
So Google is basically--

00:32:02.570 --> 00:32:06.810
you make a very simple API
call in your Android app.

00:32:06.810 --> 00:32:08.280
Google displays this screen.

00:32:08.280 --> 00:32:09.630
The user hits Allow Access.

00:32:09.630 --> 00:32:12.080
Your application gets
an access token.

00:32:12.080 --> 00:32:14.160
You don't have to deal with the
communication between a

00:32:14.160 --> 00:32:16.590
web browser and your
application.

00:32:16.590 --> 00:32:19.530
We handle it all for you, and
it's a little more secure

00:32:19.530 --> 00:32:21.560
because you're also registering
your Android

00:32:21.560 --> 00:32:22.670
application.

00:32:22.670 --> 00:32:28.210
Specifically, registering a
signature of your application

00:32:28.210 --> 00:32:32.300
as it exists on the Play store,
and that is creating a

00:32:32.300 --> 00:32:34.090
client ID for you.

00:32:34.090 --> 00:32:37.420
So when a user sees your
application in their account

00:32:37.420 --> 00:32:40.250
manager, and they're looking at
the Google accounts page,

00:32:40.250 --> 00:32:42.860
they will see your specific
Android application and the

00:32:42.860 --> 00:32:47.600
data that they've granted access
to in your application.

00:32:47.600 --> 00:32:50.680
It's a pretty small snippet
of code here.

00:32:50.680 --> 00:32:53.290
The first thing you need to do
is figure out what account the

00:32:53.290 --> 00:32:56.070
user would like to grant
access from.

00:32:56.070 --> 00:32:58.210
This is in email
address format.

00:32:58.210 --> 00:33:00.580
So there's a way to do that
where you can get a list of

00:33:00.580 --> 00:33:04.560
the various accounts
for the user.

00:33:04.560 --> 00:33:06.500
You can also have us
render the UI.

00:33:06.500 --> 00:33:09.370
There's another call you can
make to us render the UI, but

00:33:09.370 --> 00:33:11.830
after you determine what account
you want the user to

00:33:11.830 --> 00:33:14.920
grant access to, you
then just determine

00:33:14.920 --> 00:33:17.400
your scope like before.

00:33:17.400 --> 00:33:19.190
And this one line of
code that says

00:33:19.190 --> 00:33:22.360
GoogleAuthUtil.authenticate,
passing in the context you

00:33:22.360 --> 00:33:26.670
render out the email address
and the scope.

00:33:26.670 --> 00:33:28.500
Makes it so much easier.

00:33:28.500 --> 00:33:31.690
So if you're doing cross
platform mechanisms, you might

00:33:31.690 --> 00:33:36.090
still have to use the other ways
that I showed you here,

00:33:36.090 --> 00:33:37.940
but if you're developing your
application on Android, I

00:33:37.940 --> 00:33:41.850
would definitely suggest
looking at this.

00:33:41.850 --> 00:33:43.100
And we have our goal.

00:33:46.090 --> 00:33:48.500
App-based Authorization.

00:33:48.500 --> 00:33:51.030
So app-based authorization
is something different.

00:33:51.030 --> 00:33:55.130
What we've seen here before is
how you get access to a user's

00:33:55.130 --> 00:33:59.990
data and access data belonging
to that user

00:33:59.990 --> 00:34:00.860
on behalf of them.

00:34:00.860 --> 00:34:04.100
They're granting you that access
as an application.

00:34:04.100 --> 00:34:07.390
But what if your application
needs access to its own data?

00:34:07.390 --> 00:34:10.150
What if your application needs
access to data that belongs to

00:34:10.150 --> 00:34:12.920
the application and is kind of
for all the users of your

00:34:12.920 --> 00:34:13.940
application?

00:34:13.940 --> 00:34:16.659
So think of something like
Google Cloud Storage, where

00:34:16.659 --> 00:34:19.960
you can store arbitrary binary
files and all, like let's say

00:34:19.960 --> 00:34:23.449
your application transcodes a
bunch of videos, or something

00:34:23.449 --> 00:34:25.929
like that, and you want to store
the output somewhere.

00:34:25.929 --> 00:34:28.150
Google Cloud Storage will allow
you to do that, and you

00:34:28.150 --> 00:34:31.250
can upload all these files,
but really, it's your

00:34:31.250 --> 00:34:32.540
application's data.

00:34:32.540 --> 00:34:36.230
It's not data belonging to any
individual end user, and in

00:34:36.230 --> 00:34:38.670
that case, there's a separate
OAuth flow which doesn't

00:34:38.670 --> 00:34:41.400
involve the user at all.

00:34:41.400 --> 00:34:42.650
It looks something like this.

00:34:44.920 --> 00:34:46.380
You have your app server.

00:34:46.380 --> 00:34:50.540
Your app server makes a signed
request over to Google OAuth

00:34:50.540 --> 00:34:54.560
servers, and this signed request
basically says I'm

00:34:54.560 --> 00:34:59.200
looking for this particular
scope, and I'm identifying

00:34:59.200 --> 00:35:03.210
myself here, based on this
signature, and give me an

00:35:03.210 --> 00:35:04.060
access token.

00:35:04.060 --> 00:35:07.800
And then your access token is
used to access the API.

00:35:07.800 --> 00:35:09.240
So there's no user
involved here.

00:35:09.240 --> 00:35:11.120
There's no web browser
involved here.

00:35:11.120 --> 00:35:13.740
It's just another different way
that you can use the OAuth

00:35:13.740 --> 00:35:15.690
2 technology.

00:35:15.690 --> 00:35:19.400
The sad part is this
reintroduces signed requests.

00:35:19.400 --> 00:35:23.500
How many of you liked signatures
in OAuth 1?

00:35:23.500 --> 00:35:25.280
There's a few people.

00:35:25.280 --> 00:35:28.820
Even the author of the OAuth 2
spec really wants signatures

00:35:28.820 --> 00:35:33.680
to be used every day with OAuth
2, but in this case

00:35:33.680 --> 00:35:36.480
here, we do actually
add signatures.

00:35:36.480 --> 00:35:39.780
And we add signatures back in,
again, because of the security

00:35:39.780 --> 00:35:41.830
through layers.

00:35:41.830 --> 00:35:44.550
You're getting access to,
potentially, the data that

00:35:44.550 --> 00:35:47.370
belongs to a bunch of different
users, or your

00:35:47.370 --> 00:35:51.770
entire application's data, so
you want to add another layer

00:35:51.770 --> 00:35:52.460
of security.

00:35:52.460 --> 00:35:53.470
And this other layer of

00:35:53.470 --> 00:35:56.230
security here is the signature.

00:35:56.230 --> 00:35:59.310
So when you register your
application, you get a key.

00:35:59.310 --> 00:36:01.750
You use this key to make
signed requests over to

00:36:01.750 --> 00:36:05.930
Google, but again, when you're
actually accessing the API,

00:36:05.930 --> 00:36:08.420
every time you're accessing the
API, all you're doing is

00:36:08.420 --> 00:36:10.320
the same thing you're doing with
all the other flows, and

00:36:10.320 --> 00:36:12.010
that is passing this
access token.

00:36:15.510 --> 00:36:16.980
Here's how it's done
in Python.

00:36:16.980 --> 00:36:20.820
You first load in your private
key that comes from that APIs

00:36:20.820 --> 00:36:25.250
console, and then there's a very
simple request here that

00:36:25.250 --> 00:36:26.180
you're passing in.

00:36:26.180 --> 00:36:28.310
Here's your service account,
which again, you get from the

00:36:28.310 --> 00:36:29.870
APIs console.

00:36:29.870 --> 00:36:33.550
Here's the scope of data that
you're looking for access to,

00:36:33.550 --> 00:36:36.500
and then what that's doing in
this authorize method is,

00:36:36.500 --> 00:36:40.520
essentially, calling the OAuth
provider with that signed

00:36:40.520 --> 00:36:44.700
request and giving you
an access token back.

00:36:44.700 --> 00:36:47.250
Now, I'd recommend, if you're
using this at all, please,

00:36:47.250 --> 00:36:49.290
please, use our client
libraries.

00:36:49.290 --> 00:36:53.010
Also please, please, make sure
your time on your server is

00:36:53.010 --> 00:36:55.410
synced to an NTP server because
that tends to be the

00:36:55.410 --> 00:36:58.330
biggest issue developers
have when working with

00:36:58.330 --> 00:37:00.660
cryptographic signatures.

00:37:00.660 --> 00:37:02.890
But anyway, it's pretty easy.

00:37:02.890 --> 00:37:05.120
You can then access cloud
storage on behalf of your

00:37:05.120 --> 00:37:07.730
application rather than on
behalf of any individual user.

00:37:15.120 --> 00:37:17.900
So OAuth w for Login,
or OAuth 2 for

00:37:17.900 --> 00:37:21.760
Authentication or OpenID Connect.

00:37:21.760 --> 00:37:26.380
This is really the next
version OpenID.

00:37:26.380 --> 00:37:29.240
So OpenID had OpenID
version 2.

00:37:29.240 --> 00:37:31.110
Still rather complicated
to use.

00:37:31.110 --> 00:37:34.950
I've worked with hundreds of
developers to implement OpenID

00:37:34.950 --> 00:37:39.230
2 in their applications,
including some folks I'm

00:37:39.230 --> 00:37:41.890
seeing in this room here
today, and it can be

00:37:41.890 --> 00:37:43.180
challenging at times.

00:37:47.370 --> 00:37:50.250
OAuth 2 for Login builds on
top of the standard OAuth

00:37:50.250 --> 00:37:54.930
flows to give you identity or
login or authentication just

00:37:54.930 --> 00:37:59.380
the same as you would get
access to a user's data.

00:37:59.380 --> 00:38:01.200
So this is really important.

00:38:01.200 --> 00:38:04.580
Let's show you how it works.

00:38:04.580 --> 00:38:07.330
First of all the traditional
sign-in form.

00:38:07.330 --> 00:38:09.550
The traditional sign-in form
is where you're typing your

00:38:09.550 --> 00:38:13.740
50+ characters, but you want to
eliminate that down to two

00:38:13.740 --> 00:38:15.660
mouse clicks.

00:38:15.660 --> 00:38:17.210
So we'll see how that
works here.

00:38:17.210 --> 00:38:20.430
I basically click the button
that says sign up with Google.

00:38:20.430 --> 00:38:23.610
It pops open and says my slide
deck is requesting permission

00:38:23.610 --> 00:38:26.720
to view basic information about
my account and view my

00:38:26.720 --> 00:38:28.270
email address.

00:38:28.270 --> 00:38:32.100
I'm going to say Allow Access,
and then the application has

00:38:32.100 --> 00:38:36.770
my name, my email address, my
profile photo, my Google+

00:38:36.770 --> 00:38:40.650
profile, and public information
such as my sex,

00:38:40.650 --> 00:38:43.770
date of birth, and
things like that.

00:38:43.770 --> 00:38:44.690
Very powerful.

00:38:44.690 --> 00:38:47.900
Makes it a lot easier for users
to onboard and use your

00:38:47.900 --> 00:38:49.150
application.

00:38:52.070 --> 00:38:56.220
So you can make it faster
to onboard users.

00:38:56.220 --> 00:39:00.310
You can securely get a unique
stable identifier for the

00:39:00.310 --> 00:39:02.680
user's account, so this
is really important.

00:39:02.680 --> 00:39:05.100
A lot of times, people
use an identifier

00:39:05.100 --> 00:39:06.460
that's their email address.

00:39:06.460 --> 00:39:08.760
Developers seem to love the
email address as a unique

00:39:08.760 --> 00:39:09.800
identifier.

00:39:09.800 --> 00:39:12.240
Users change their email
addresses all the time.

00:39:12.240 --> 00:39:15.220
This is not really a good plan,
so in this case, you get

00:39:15.220 --> 00:39:18.670
a unique stable identifier
that's just a number that

00:39:18.670 --> 00:39:21.250
represents that user on Google,
and you can use that

00:39:21.250 --> 00:39:22.660
in your database.

00:39:22.660 --> 00:39:25.750
You can also personalize your
site to make your application

00:39:25.750 --> 00:39:30.090
a little bit more friendly and
inviting to your users.

00:39:30.090 --> 00:39:32.430
So here's how it works.

00:39:32.430 --> 00:39:36.050
You first of all specify a scope
that is one of these two

00:39:36.050 --> 00:39:38.010
values or both.

00:39:38.010 --> 00:39:42.470
So the userinfo.profile gives
you this unique ID, name,

00:39:42.470 --> 00:39:44.700
profile photo, a bunch
of information.

00:39:44.700 --> 00:39:48.230
And then there's a separate
userinfo.email scope, which

00:39:48.230 --> 00:39:51.740
gives you access to the
user's email address.

00:39:51.740 --> 00:39:54.260
Now, there's the occasional
geek in the audience that

00:39:54.260 --> 00:39:56.620
says, well, what if I don't want
the application to have

00:39:56.620 --> 00:39:58.500
access to my email address?

00:39:58.500 --> 00:40:01.220
And my response is usually,
well, pretty much every

00:40:01.220 --> 00:40:02.990
application on the
web will want to

00:40:02.990 --> 00:40:04.860
have your email address.

00:40:04.860 --> 00:40:07.660
And those applications do it
already for an email address

00:40:07.660 --> 00:40:10.650
and password based system,
so this is no different.

00:40:10.650 --> 00:40:14.200
And applications need this
information in order to hook

00:40:14.200 --> 00:40:15.440
up with the rest of
their system.

00:40:15.440 --> 00:40:19.940
So most developers will end up
specifying both of these, and

00:40:19.940 --> 00:40:23.460
then they can request access by
generating a URL that looks

00:40:23.460 --> 00:40:26.410
very similar to what we saw,
both with the client-side flow

00:40:26.410 --> 00:40:28.820
and the server-side flow.

00:40:28.820 --> 00:40:31.220
In this case, we are using
the client-side flow.

00:40:31.220 --> 00:40:34.230
We just have our client ID,
we have these scopes, the

00:40:34.230 --> 00:40:38.920
multiple scopes delineated by a
space, and the redirect URI,

00:40:38.920 --> 00:40:42.220
which is our application's
URL.

00:40:42.220 --> 00:40:44.620
There's one other way that you
can do this, and this was

00:40:44.620 --> 00:40:47.715
announced just recently, in the
last day or so, as part of

00:40:47.715 --> 00:40:49.730
the history API.

00:40:49.730 --> 00:40:54.050
You can use our branded button
for a sign-in button as part

00:40:54.050 --> 00:40:59.470
of Google+, and that basically
just allows you to get the

00:40:59.470 --> 00:41:02.130
redirect and to handle the popup
and all automatically

00:41:02.130 --> 00:41:05.270
for you, and then get a access
token in JavaScript.

00:41:08.970 --> 00:41:12.720
And again, we've reached
our goal.

00:41:12.720 --> 00:41:15.340
So there's this other step with
authentication, the step

00:41:15.340 --> 00:41:19.180
that you don't have to take with
authorization, and this

00:41:19.180 --> 00:41:21.700
step is verifying the token.

00:41:21.700 --> 00:41:25.380
So you call this TokenInfo API,
and basically, what your

00:41:25.380 --> 00:41:28.610
goal is here is to make sure
that this token was actually

00:41:28.610 --> 00:41:30.520
issued to your application.

00:41:30.520 --> 00:41:33.170
It's called an audience check,
so your verifying that that

00:41:33.170 --> 00:41:38.580
audience ID there matches the
client ID of your application,

00:41:38.580 --> 00:41:41.120
and it's really important
that you do that.

00:41:41.120 --> 00:41:43.920
It's really important that you
make sure that this token was

00:41:43.920 --> 00:41:47.030
actually issued to your
application and not some other

00:41:47.030 --> 00:41:50.480
application, and I can't
stress that enough.

00:41:50.480 --> 00:41:53.000
But I won't go into details from
a security prospective as

00:41:53.000 --> 00:41:55.890
to why it's important,
but do it.

00:41:55.890 --> 00:41:58.500
And so when you call this
TokenInfo API, you get that

00:41:58.500 --> 00:42:00.540
audience, you verify
that audience

00:42:00.540 --> 00:42:02.670
matches your client ID.

00:42:02.670 --> 00:42:05.140
And then you can also get this
unique stable identify, the

00:42:05.140 --> 00:42:07.590
user ID, from there.

00:42:07.590 --> 00:42:09.880
But if you want to get some
additional information, you

00:42:09.880 --> 00:42:12.680
can then call the UserInfo API,
which is, again, just a

00:42:12.680 --> 00:42:16.250
REST-based API that you pass
in the access token, and it

00:42:16.250 --> 00:42:19.110
returns a JSON responds
with a bunch of

00:42:19.110 --> 00:42:21.210
information about the user.

00:42:26.070 --> 00:42:30.050
So there are a variety of tools
that you'll want to use

00:42:30.050 --> 00:42:32.890
as you're exploring and
learning OAuth.

00:42:32.890 --> 00:42:36.330
The first is the OAuth
2 Playground.

00:42:36.330 --> 00:42:40.340
The OAuth 2 Playground is a
really helpful application

00:42:40.340 --> 00:42:44.030
that helps you learn both
the client-side and the

00:42:44.030 --> 00:42:47.310
server-side flows, and it goes
through step-by-step,

00:42:47.310 --> 00:42:52.470
explaining what's happening
as you access your data.

00:42:52.470 --> 00:42:56.000
And you can use this with both
Google APIs, but you can also

00:42:56.000 --> 00:42:59.450
use it with third party APIs
as long as they comply with

00:42:59.450 --> 00:43:02.270
the latest version of the
OAuth 2 draft spec.

00:43:02.270 --> 00:43:04.750
And it's a really helpful tool
built by a couple of my

00:43:04.750 --> 00:43:06.910
colleagues.

00:43:06.910 --> 00:43:10.080
And then there's also a demo
that does the exact same thing

00:43:10.080 --> 00:43:13.970
with OAuth 2 for Login of
Authentication or OpenID

00:43:13.970 --> 00:43:15.630
Connect, whatever you
want to call it.

00:43:15.630 --> 00:43:18.500
And it goes step-by-step
through, so you should check

00:43:18.500 --> 00:43:21.160
that out as well.

00:43:21.160 --> 00:43:25.080
All right, everyone, so I've
gone through in showing you

00:43:25.080 --> 00:43:29.720
how to do OAuth both for a
client-side flow, as well as a

00:43:29.720 --> 00:43:31.290
server-side flow.

00:43:31.290 --> 00:43:34.680
I've talked about how to do
it on mobile applications.

00:43:34.680 --> 00:43:39.060
I've talked about how to use
OAuth for identity and logging

00:43:39.060 --> 00:43:41.410
users into your site.

00:43:41.410 --> 00:43:43.730
I just want to remind you all
that you guys have an

00:43:43.730 --> 00:43:47.490
obligation to help keep your
users secure and to make for a

00:43:47.490 --> 00:43:51.200
great experience for your users,
and I believe that the

00:43:51.200 --> 00:43:54.160
OAuth technologies really
help you do that.

00:43:54.160 --> 00:43:57.550
In the latest version of OAuth
2, hopefully you've seen here,

00:43:57.550 --> 00:43:59.840
with the exception of a little
bit as cryptographic signature

00:43:59.840 --> 00:44:02.050
work there, is much
easier than the

00:44:02.050 --> 00:44:03.410
previous versions of OAuth.

00:44:03.410 --> 00:44:05.380
So I encourage you all
to check it out

00:44:05.380 --> 00:44:06.750
a little bit more.

00:44:06.750 --> 00:44:10.220
And here are the various
resources, which I will leave

00:44:10.220 --> 00:44:15.390
up while I open this up for Q&amp;A.
And feel free to come to

00:44:15.390 --> 00:44:18.285
the mics here if you
have any questions.

00:44:23.410 --> 00:44:26.190
AUDIENCE: The ID that comes back
in the audience check, is

00:44:26.190 --> 00:44:30.800
that the same as the
other unique IDs?

00:44:30.800 --> 00:44:31.140
RYAN BOYD: Yes.

00:44:31.140 --> 00:44:33.580
The ID that comes back in the
audience check for the user,

00:44:33.580 --> 00:44:34.263
you're saying?

00:44:34.263 --> 00:44:35.030
AUDIENCE: Yeah.

00:44:35.030 --> 00:44:37.330
RYAN BOYD: Yeah, that's the same
ID as would come back via

00:44:37.330 --> 00:44:39.300
the UserInfo API as well.

00:44:42.390 --> 00:44:43.270
Is that your question?

00:44:43.270 --> 00:44:43.715
AUDIENCE: Yeah.

00:44:43.715 --> 00:44:45.940
RYAN BOYD: Cool.

00:44:45.940 --> 00:44:46.830
AUDIENCE: Hi.

00:44:46.830 --> 00:44:49.760
Question on the Android flow.

00:44:49.760 --> 00:44:52.020
The util thing that you
mentioned, is that part of

00:44:52.020 --> 00:44:54.000
Jelly Bean, or is that
part of another--

00:44:54.000 --> 00:44:54.840
RYAN BOYD: Sorry.

00:44:54.840 --> 00:44:56.760
Yeah, I missed that part.

00:44:56.760 --> 00:45:00.060
Yes, it is part of what's called
Google Play services,

00:45:00.060 --> 00:45:02.890
which is distributed along
with the Play store.

00:45:02.890 --> 00:45:08.320
It will be available in FroYo on
up, so pretty much most of

00:45:08.320 --> 00:45:10.210
the devices that
are out there.

00:45:10.210 --> 00:45:12.620
And I've been told in the coming
weeks is when it'll be

00:45:12.620 --> 00:45:14.840
available, but you can check
out the URL there for the

00:45:14.840 --> 00:45:19.040
documentation and learn how it
works today and then actually

00:45:19.040 --> 00:45:21.440
deploy your app in a few weeks
once it's available.

00:45:21.440 --> 00:45:23.620
AUDIENCE: And will this
kind of popup a native

00:45:23.620 --> 00:45:27.700
authorization screen and
bypass the entire web?

00:45:27.700 --> 00:45:29.560
Because it interacts
with the Android

00:45:29.560 --> 00:45:31.370
account manager, I imagine.

00:45:31.370 --> 00:45:33.370
RYAN BOYD: Yeah, sorry if I
didn't make that clear, but it

00:45:33.370 --> 00:45:38.880
does popup the native
authorization screen that

00:45:38.880 --> 00:45:41.480
looks something like this.

00:45:41.480 --> 00:45:43.080
AUDIENCE: Because there
is currently a native

00:45:43.080 --> 00:45:46.460
authorization OAuth 2 screen
that you can use, I think,

00:45:46.460 --> 00:45:48.610
from Honeycomb and upwards.

00:45:48.610 --> 00:45:50.090
But it doesn't look like this.

00:45:50.090 --> 00:45:52.800
RYAN BOYD: Yeah, so there's the
account manager version of

00:45:52.800 --> 00:45:54.140
the native screen.

00:45:54.140 --> 00:45:58.940
There's a few issues, and those
issues are that you

00:45:58.940 --> 00:46:01.650
specify your OAuth 2 scope
is like OAuth 2,

00:46:01.650 --> 00:46:03.180
colon, and then a string.

00:46:03.180 --> 00:46:05.390
And that's often how it's
presented to a user, so it's

00:46:05.390 --> 00:46:07.340
kind of a bad user experience.

00:46:07.340 --> 00:46:11.770
And then the second thing is
that that token is issued and

00:46:11.770 --> 00:46:16.300
assigned basically to that
Android device as opposed to

00:46:16.300 --> 00:46:18.830
being assigned to your
individual application, so

00:46:18.830 --> 00:46:21.640
when a user goes to manage and
revoke access, it gets a

00:46:21.640 --> 00:46:22.430
little confusing.

00:46:22.430 --> 00:46:27.400
So we often did not recommend
that you use that because of

00:46:27.400 --> 00:46:28.710
those limitations.

00:46:28.710 --> 00:46:30.630
Now, with the Google Play
services and the

00:46:30.630 --> 00:46:33.120
GoogleAuthUtil, we can
confidently say that's the

00:46:33.120 --> 00:46:34.060
best way to do it.

00:46:34.060 --> 00:46:36.610
AUDIENCE: And this will be
FroYo and upwards, in

00:46:36.610 --> 00:46:37.800
a native way, 100%?

00:46:37.800 --> 00:46:38.700
RYAN BOYD: Correct.

00:46:38.700 --> 00:46:39.960
AUDIENCE: OK, thanks.

00:46:39.960 --> 00:46:42.370
RYAN BOYD: Thank you.

00:46:42.370 --> 00:46:43.325
AUDIENCE: Hi, question.

00:46:43.325 --> 00:46:46.600
RYAN BOYD: Actually, sorry.

00:46:46.600 --> 00:46:48.500
OK, go ahead, and we'll
take him next.

00:46:48.500 --> 00:46:51.150
AUDIENCE: OK, we have
multiple devices.

00:46:51.150 --> 00:46:54.460
The same client ID as is
in the same user data.

00:46:54.460 --> 00:46:58.740
Won't they get the same access
token, or will they get the

00:46:58.740 --> 00:46:59.760
different access tokens?

00:46:59.760 --> 00:47:02.320
Will they be all valid
access tokens

00:47:02.320 --> 00:47:04.150
approximately at the same time?

00:47:04.150 --> 00:47:08.180
RYAN BOYD: The access tokens are
valid for an hour, and the

00:47:08.180 --> 00:47:12.380
access tokens will be different
access tokens if you

00:47:12.380 --> 00:47:15.280
issued them in multiple calls.

00:47:15.280 --> 00:47:19.150
The refresh tokens are the long
lived the ones, and you

00:47:19.150 --> 00:47:24.540
only get a refresh token,
typically, the first time that

00:47:24.540 --> 00:47:26.610
you do the authorization,
where a user

00:47:26.610 --> 00:47:28.540
hits the Approve button.

00:47:28.540 --> 00:47:30.920
On the Android side-- are
you asking on the

00:47:30.920 --> 00:47:31.600
Android side or--

00:47:31.600 --> 00:47:34.320
AUDIENCE: No, no, basically I
have two devices, same client

00:47:34.320 --> 00:47:37.140
ID accesses the same user data.

00:47:37.140 --> 00:47:38.160
Right?

00:47:38.160 --> 00:47:39.890
RYAN BOYD: But when you
say devices are--

00:47:39.890 --> 00:47:43.656
AUDIENCE: Two devices, say
mobile phone and my desktop

00:47:43.656 --> 00:47:44.142
application.

00:47:44.142 --> 00:47:45.100
Right?

00:47:45.100 --> 00:47:48.590
And they're doing it like
approximately the same time,

00:47:48.590 --> 00:47:50.470
might be slightly apart.

00:47:50.470 --> 00:47:52.840
RYAN BOYD: You should not get
the same access tokens.

00:47:52.840 --> 00:47:54.230
They should be different
access--

00:47:54.230 --> 00:47:56.175
AUDIENCE: Different, but my
previous access token, would

00:47:56.175 --> 00:47:58.310
it still be valid
for my, say--

00:47:58.310 --> 00:47:59.260
RYAN BOYD: Yes.

00:47:59.260 --> 00:48:02.590
AUDIENCE: So it's possible to
have multiple access tokens?

00:48:02.590 --> 00:48:04.850
RYAN BOYD: It is possible to
have multiple outstanding

00:48:04.850 --> 00:48:07.550
access tokens that are valid,
but when a user revokes

00:48:07.550 --> 00:48:10.690
access, it will revoke access
to the refresh token and all

00:48:10.690 --> 00:48:12.590
outstanding access tokens.

00:48:12.590 --> 00:48:15.370
AUDIENCE: OK, thank you.

00:48:15.370 --> 00:48:19.360
AUDIENCE: I noticed the refresh
token is longer than

00:48:19.360 --> 00:48:23.280
normal tokens, so do you save
the scope inside the refresh

00:48:23.280 --> 00:48:25.010
token, or in the server-side?

00:48:25.010 --> 00:48:27.500
So you must save the
scope somewhere.

00:48:27.500 --> 00:48:28.870
RYAN BOYD: Yes.

00:48:28.870 --> 00:48:31.410
With that refresh token, we
associate the scope on

00:48:31.410 --> 00:48:31.770
[INAUDIBLE]

00:48:31.770 --> 00:48:35.460
provider that that refresh
token is valid for.

00:48:35.460 --> 00:48:37.890
AUDIENCE: So basically, the
refresh token, you have some

00:48:37.890 --> 00:48:40.740
copy, something to value
the server-side

00:48:40.740 --> 00:48:41.920
so make it a longer.

00:48:41.920 --> 00:48:45.460
So because refresh tokens
can live forever.

00:48:45.460 --> 00:48:47.990
RYAN BOYD: Yes, the refresh
token can be valid forever

00:48:47.990 --> 00:48:50.870
until the user revokes access.

00:48:50.870 --> 00:48:54.130
If the user goes through
multiple authorization flows

00:48:54.130 --> 00:48:56.110
for your application with
different scopes, you'll get

00:48:56.110 --> 00:48:58.480
multiple refresh tokens.

00:48:58.480 --> 00:49:00.910
But if you just asked for access
to a bunch of different

00:49:00.910 --> 00:49:04.030
APIs at once, you'll still have
one refresh token for

00:49:04.030 --> 00:49:06.060
those bunch of different APIs.

00:49:06.060 --> 00:49:08.535
And we store all that
information server-side.

00:49:08.535 --> 00:49:11.050
AUDIENCE: OK, so it will
live forever in

00:49:11.050 --> 00:49:13.080
the server-side basically?

00:49:13.080 --> 00:49:14.286
RYAN BOYD: Correct.

00:49:14.286 --> 00:49:17.260
AUDIENCE: OK, thanks.

00:49:17.260 --> 00:49:19.620
AUDIENCE: I kind of have a
continuation from the question

00:49:19.620 --> 00:49:20.520
before last.

00:49:20.520 --> 00:49:26.730
So talking only about Android
devices using GoogleAuthUtil,

00:49:26.730 --> 00:49:29.590
if you had the same app and
the same Google account on

00:49:29.590 --> 00:49:33.630
multiple Android devices and
access was allowed, say, on a

00:49:33.630 --> 00:49:35.860
phone or whatever, would they
have to allow access again on

00:49:35.860 --> 00:49:39.740
the tablet, or could you just
use the refresh token there?

00:49:39.740 --> 00:49:42.420
RYAN BOYD: So this is a good
plug for the session which is

00:49:42.420 --> 00:49:44.620
coming up next in the
Android track, which

00:49:44.620 --> 00:49:45.580
I should have announced.

00:49:45.580 --> 00:49:48.410
There is a session specifically
on this coming up

00:49:48.410 --> 00:49:52.240
next on "Accessing Web APIs
from Android Devices."

00:49:52.240 --> 00:49:52.690
[INAUDIBLE]

00:49:52.690 --> 00:49:54.340
there would know the answer
to that question.

00:49:54.340 --> 00:49:55.350
I don't know the answer.

00:49:55.350 --> 00:49:57.490
This is just late breaking
technology.

00:49:57.490 --> 00:49:59.280
I haven't actually had
a chance to use it.

00:49:59.280 --> 00:50:01.680
We just got it working a couple
days ago, I think.

00:50:01.680 --> 00:50:06.040
So yeah, definitely ask them at
the next session or hunt me

00:50:06.040 --> 00:50:07.670
down later, and I can find
out the answer for you.

00:50:07.670 --> 00:50:08.920
AUDIENCE: All right, thanks.

00:50:11.260 --> 00:50:12.200
AUDIENCE: I've introduced
[INAUDIBLE]

00:50:12.200 --> 00:50:13.460
mentioned in [INAUDIBLE].

00:50:13.460 --> 00:50:16.380
They are based in Google,
but let's say, if I'm an

00:50:16.380 --> 00:50:22.410
enterprise, and I already have
directory that is on premise,

00:50:22.410 --> 00:50:25.750
how do I use this with
the workflow?

00:50:25.750 --> 00:50:29.030
RYAN BOYD: So you've an on
premise directory, like say an

00:50:29.030 --> 00:50:31.040
LDAP or active directory
environment, and

00:50:31.040 --> 00:50:33.030
you're trying to--

00:50:33.030 --> 00:50:34.230
What are you trying
to do, though?

00:50:34.230 --> 00:50:35.620
Like you're trying to
grant access to

00:50:35.620 --> 00:50:37.390
corporate data or what?

00:50:37.390 --> 00:50:39.510
AUDIENCE: I want to take
all my line of business

00:50:39.510 --> 00:50:42.662
applications and run them
in Google Cloud.

00:50:42.662 --> 00:50:45.530
RYAN BOYD: OK, and you're
trying to make sure the

00:50:45.530 --> 00:50:47.650
identity is communicated back?

00:50:47.650 --> 00:50:51.400
I mean, one way to
do that is, for

00:50:51.400 --> 00:50:53.420
instance, with Google Apps.

00:50:53.420 --> 00:50:57.430
With Google Apps, you can have a
SAML provider, and that SAML

00:50:57.430 --> 00:51:01.650
provider is basically a service
that runs behind your

00:51:01.650 --> 00:51:05.040
firewall on your corporate
network that associates users

00:51:05.040 --> 00:51:08.020
with your directory, and then
you're the one that's actually

00:51:08.020 --> 00:51:09.930
authenticating those users.

00:51:09.930 --> 00:51:12.350
So when the user goes over
through an OAuth flow to

00:51:12.350 --> 00:51:17.700
Google, it will basically
delegate then to your SAML

00:51:17.700 --> 00:51:20.665
provider, so it'll basically
say, hey, Google doesn't know

00:51:20.665 --> 00:51:22.170
how to log this user in.

00:51:22.170 --> 00:51:24.170
Let's go to the corporate
directory, and the corporate

00:51:24.170 --> 00:51:28.370
directory will handle logging
the user in and then doing the

00:51:28.370 --> 00:51:29.600
normal OAuth flow.

00:51:29.600 --> 00:51:32.690
So you can kind of bridge
between the internet and

00:51:32.690 --> 00:51:34.540
traditional on premise
environments doing

00:51:34.540 --> 00:51:35.920
something like that.

00:51:35.920 --> 00:51:37.170
AUDIENCE: OK, thanks.

00:51:40.648 --> 00:51:44.630
AUDIENCE: How does a two-part
authentication play into this?

00:51:44.630 --> 00:51:47.000
RYAN BOYD: So two-part
authentication is basically a

00:51:47.000 --> 00:51:49.540
way, for those of you who aren't
familiar with it, to

00:51:49.540 --> 00:51:53.460
add an additional layer of
security to your account.

00:51:53.460 --> 00:51:56.830
So basically, instead of just
your user name and password,

00:51:56.830 --> 00:52:00.450
which is something you'd know,
the second part is something

00:52:00.450 --> 00:52:02.160
that you have in your
possession.

00:52:02.160 --> 00:52:04.850
So in order to login to My
Accounts, I need to actually

00:52:04.850 --> 00:52:06.470
use my mobile device.

00:52:06.470 --> 00:52:10.400
It gives me a code that I then
enter into my Google account

00:52:10.400 --> 00:52:13.450
when I go to login, and then
combined with my password and

00:52:13.450 --> 00:52:15.250
that code, I'm able to login.

00:52:15.250 --> 00:52:19.390
It does play well with OAuth
in that, if the user is not

00:52:19.390 --> 00:52:24.690
logged into their browser, the
user will be asked to login.

00:52:24.690 --> 00:52:27.440
And when the user is asked to
log in, if they haven't used

00:52:27.440 --> 00:52:32.570
that browser, they'll be asked
to prove their second

00:52:32.570 --> 00:52:36.340
authentication factor at the
time that they login before

00:52:36.340 --> 00:52:39.950
any sort of OAuth grant
is going to be issued.

00:52:39.950 --> 00:52:42.910
There's no way to, say, force
that or something like that,

00:52:42.910 --> 00:52:45.440
to add an additional layer
of security right now.

00:52:45.440 --> 00:52:50.120
We supported some things like
that with OpenID 2.

00:52:50.120 --> 00:52:53.230
It's called paid provider
off-policy extension.

00:52:53.230 --> 00:52:57.610
I'm not aware of, currently, a
way to do that with OAuth 2,

00:52:57.610 --> 00:52:59.850
but I would imagine that's
something that will come down

00:52:59.850 --> 00:53:02.215
the line with more enterprise
use cases.

00:53:02.215 --> 00:53:04.890
AUDIENCE: Thank you.

00:53:04.890 --> 00:53:07.650
AUDIENCE: Hi, actually
the question I

00:53:07.650 --> 00:53:08.550
have is kind of related.

00:53:08.550 --> 00:53:12.170
In an enterprise environment, if
I have an application that

00:53:12.170 --> 00:53:15.480
needs to access a user's data,
is there a way I can do that

00:53:15.480 --> 00:53:17.850
without forcing the user to go
through the whole flow and

00:53:17.850 --> 00:53:19.500
say, yeah, OK, I'm going to
login now, and I'm going to

00:53:19.500 --> 00:53:21.680
authorize the application?

00:53:21.680 --> 00:53:23.720
RYAN BOYD: So we have
another mechanism.

00:53:23.720 --> 00:53:27.680
The service account stuff that
I showed you to do app-based

00:53:27.680 --> 00:53:30.590
authentication, where the
application is authenticating

00:53:30.590 --> 00:53:33.290
and then authorizing
access to data--

00:53:33.290 --> 00:53:36.210
that flow could also be used
if there was, say, a

00:53:36.210 --> 00:53:38.530
pre-authorization of data.

00:53:38.530 --> 00:53:41.590
So if an application was
previously authorized to

00:53:41.590 --> 00:53:45.570
access, say, all the user's
Google Calendars in an

00:53:45.570 --> 00:53:48.120
organization, there's
a way, when you

00:53:48.120 --> 00:53:50.270
make that signed request.

00:53:50.270 --> 00:53:54.310
So the application makes a
signed request to the OAuth

00:53:54.310 --> 00:53:56.670
provider that says I
need this scope.

00:53:56.670 --> 00:53:59.450
There's a way to say I need this
scope for this particular

00:53:59.450 --> 00:54:04.450
user, and then use that for this
user-based authorization.

00:54:04.450 --> 00:54:07.600
And provided that the user has
previously granted access,

00:54:07.600 --> 00:54:09.620
which in the Google Apps world,
happens in the Google

00:54:09.620 --> 00:54:12.540
Apps control panel or by
installing an app from the

00:54:12.540 --> 00:54:16.340
Google Apps Marketplace, then an
access token will be issued

00:54:16.340 --> 00:54:18.805
for that particular user,
and the application

00:54:18.805 --> 00:54:19.670
can then access it.

00:54:19.670 --> 00:54:21.600
It's not something
I've tried out.

00:54:21.600 --> 00:54:24.740
It's something we've launched
just recently, and I haven't

00:54:24.740 --> 00:54:26.070
heard many users that
have tried it out.

00:54:26.070 --> 00:54:28.310
So if you try it out, and you
have any problems, definitely

00:54:28.310 --> 00:54:31.280
let us know, but that
should work for you.

00:54:31.280 --> 00:54:33.724
AUDIENCE: Brilliant, thanks.

00:54:33.724 --> 00:54:39.190
AUDIENCE: Is there an OAuth
2.0 for Login hybrid with

00:54:39.190 --> 00:54:41.810
authentication and authorization
as well?

00:54:41.810 --> 00:54:42.160
RYAN BOYD: Yeah.

00:54:42.160 --> 00:54:45.230
So just the same as we added
multiple scopes for

00:54:45.230 --> 00:54:48.870
authentication there, we added
the user profile scope as well

00:54:48.870 --> 00:54:50.410
as the email scope.

00:54:50.410 --> 00:54:52.420
You can add a bunch of
other scopes as well.

00:54:52.420 --> 00:54:55.540
You can ask for calendar or
contacts or YouTube, put that

00:54:55.540 --> 00:54:58.380
all in together into one
request, and then it works the

00:54:58.380 --> 00:55:01.450
same as the OAuth 1 hybrid
that I believe you're

00:55:01.450 --> 00:55:02.980
referring to.

00:55:02.980 --> 00:55:05.680
AUDIENCE: OK, and one
other question.

00:55:05.680 --> 00:55:10.330
Can you match up the claimed
identities from OpenID with

00:55:10.330 --> 00:55:13.850
the ID you get back from
OAuth 2.0 for Login?

00:55:13.850 --> 00:55:17.100
RYAN BOYD: For Google
Apps accounts, yes.

00:55:17.100 --> 00:55:20.840
For Google Apps accounts, the
identity remains constant

00:55:20.840 --> 00:55:23.300
between the different
applications, and I believe

00:55:23.300 --> 00:55:24.890
the identity is the
same thing.

00:55:24.890 --> 00:55:28.390
The user ID that you see with
OAuth 2 is the same thing as

00:55:28.390 --> 00:55:33.390
the ID number that's included
in the OpenID 2.

00:55:36.160 --> 00:55:40.930
For regular Google consumer
accounts, the OpenID 2

00:55:40.930 --> 00:55:43.920
identifiers are what's called
realm obfuscated.

00:55:43.920 --> 00:55:47.150
What that means is as you go
across the various different

00:55:47.150 --> 00:55:50.750
applications around the web
with OpenID 2, those

00:55:50.750 --> 00:55:53.340
applications are getting
different identifiers for you

00:55:53.340 --> 00:55:56.170
as a user where those
applications can't correlate

00:55:56.170 --> 00:55:58.580
the information together.

00:55:58.580 --> 00:56:00.080
With OAuth 2, that's
not the case.

00:56:00.080 --> 00:56:03.040
We no longer realm obfuscate
it, primarily because every

00:56:03.040 --> 00:56:04.780
application asks for email
address anyway.

00:56:04.780 --> 00:56:08.530
The realm obfuscation is kind
of pointless in some ways.

00:56:08.530 --> 00:56:10.740
So the IDs will be different.

00:56:10.740 --> 00:56:15.090
We do have a feature request,
which I personally filed.

00:56:15.090 --> 00:56:18.410
When you call that UserInfo
API or maybe even the

00:56:18.410 --> 00:56:24.320
TokenInfo API to provide you
the old realm obfuscated ID

00:56:24.320 --> 00:56:27.590
for you to use, then,
to match the two up.

00:56:27.590 --> 00:56:28.810
It's not there yet.

00:56:28.810 --> 00:56:29.560
I'm hoping--

00:56:29.560 --> 00:56:31.980
I was told this quarter, which
ends in a couple days.

00:56:31.980 --> 00:56:32.870
I don't think it's going
to make it in

00:56:32.870 --> 00:56:33.680
the next couple days.

00:56:33.680 --> 00:56:36.680
They're busy at I/O, but
hopefully in the near future,

00:56:36.680 --> 00:56:38.120
we have something like that.

00:56:38.120 --> 00:56:39.240
AUDIENCE: In the meantime,
can you just

00:56:39.240 --> 00:56:41.620
use the Gmail address?

00:56:41.620 --> 00:56:45.230
RYAN BOYD: Yeah, so you can use
the email address as long

00:56:45.230 --> 00:56:50.800
as you made sure, with OpenID
2, to validate the attribute

00:56:50.800 --> 00:56:52.490
exchange signature.

00:56:52.490 --> 00:56:54.450
There's some issues with some
applications which never

00:56:54.450 --> 00:56:55.600
validated that signature.

00:56:55.600 --> 00:56:58.570
So as long as you're sure you
validated that signature when

00:56:58.570 --> 00:57:02.010
acquiring the email address,
then you also have a

00:57:02.010 --> 00:57:04.490
is_verified value when
you get the email

00:57:04.490 --> 00:57:06.150
address from OAuth 2.

00:57:06.150 --> 00:57:08.660
If that's verified, and you
validate your signature, you

00:57:08.660 --> 00:57:10.880
can be fairly comfortable in
matching those two up.

00:57:10.880 --> 00:57:14.400
It's still not as secure as the
user ID, but it gets you

00:57:14.400 --> 00:57:15.470
there mostly.

00:57:15.470 --> 00:57:17.110
AUDIENCE: When you said earlier
that users change

00:57:17.110 --> 00:57:18.470
their email address all
the time, you don't

00:57:18.470 --> 00:57:19.320
mean that one, then.

00:57:19.320 --> 00:57:20.460
Right?

00:57:20.460 --> 00:57:21.510
RYAN BOYD: I don't mean what?

00:57:21.510 --> 00:57:23.810
AUDIENCE: You don't mean that
particular address?

00:57:23.810 --> 00:57:24.010
RYAN BOYD: No.

00:57:24.010 --> 00:57:26.530
I mean, they can.

00:57:26.530 --> 00:57:27.950
People get married
or whatever.

00:57:27.950 --> 00:57:30.960
You can change your address at
Google, Google Apps accounts,

00:57:30.960 --> 00:57:32.260
they can change their address.

00:57:32.260 --> 00:57:34.750
So there's going to be
some failure rate.

00:57:34.750 --> 00:57:38.110
It's much better to map up over
those IDs, but until we

00:57:38.110 --> 00:57:40.880
give you that ability, then
that's your only choice.

00:57:40.880 --> 00:57:42.730
AUDIENCE: Thanks.

00:57:42.730 --> 00:57:45.840
AUDIENCE: So will the user ID
be changed when the user

00:57:45.840 --> 00:57:47.770
change password?

00:57:47.770 --> 00:57:49.880
RYAN BOYD: The user ID
change when the user

00:57:49.880 --> 00:57:50.900
changes their password?

00:57:50.900 --> 00:57:51.820
No.

00:57:51.820 --> 00:57:53.200
The user ID remains constant.

00:57:55.950 --> 00:57:58.420
Look like I have one more.

00:57:58.420 --> 00:58:03.020
AUDIENCE: Yeah, so if you do the
server-side approach for

00:58:03.020 --> 00:58:06.770
the OAuth, do you have to ask
them multiple times on

00:58:06.770 --> 00:58:11.300
different device for
permissions?

00:58:11.300 --> 00:58:12.770
RYAN BOYD: I do not
believe so.

00:58:12.770 --> 00:58:16.140
I believe that we associate that
with the client ID, as

00:58:16.140 --> 00:58:19.620
long as you registered your
devices and your web

00:58:19.620 --> 00:58:23.590
applications all in the same
APIs console project.

00:58:23.590 --> 00:58:26.360
I don't believe that it
will prompt you again.

00:58:26.360 --> 00:58:28.560
But if you're talking about on,
like, an Android device or

00:58:28.560 --> 00:58:31.360
something like that, I would
definitely ask the folks in

00:58:31.360 --> 00:58:33.420
the next session to
be sure of that.

00:58:35.960 --> 00:58:38.470
All right, well, so there's
a lot of people

00:58:38.470 --> 00:58:39.410
still left in the room.

00:58:39.410 --> 00:58:40.890
Thank you.

00:58:40.890 --> 00:58:42.560
Hopefully you're here for me
still, and not the next

00:58:42.560 --> 00:58:45.310
session, but anyone that asked
any questions, I do have a

00:58:45.310 --> 00:58:46.600
couple copies of my book.

00:58:46.600 --> 00:58:49.160
So the first people to get
up here without injuring

00:58:49.160 --> 00:58:52.680
yourselves, I'll give you a
couple copies of my book.

00:58:52.680 --> 00:58:53.930
Thank you.

