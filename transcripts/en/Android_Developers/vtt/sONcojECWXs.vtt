WEBVTT
Kind: captions
Language: en

00:00:08.230 --> 00:00:08.730
Hi.

00:00:08.730 --> 00:00:09.780
My name is Reto Meier.

00:00:09.780 --> 00:00:11.620
I'm the tech lead for the
Android Developer Relations

00:00:11.620 --> 00:00:12.460
team at Google.

00:00:12.460 --> 00:00:14.585
And I'm here to dig beneath
the delicious chocolate

00:00:14.585 --> 00:00:16.210
shell of the latest
flavor of Android,

00:00:16.210 --> 00:00:17.930
and into the
wafer-biscuity goodness

00:00:17.930 --> 00:00:20.250
at the center of the
new developer features.

00:00:20.250 --> 00:00:23.450
KitKat may only represent a
0.1 increase in version number,

00:00:23.450 --> 00:00:25.630
but it turns out that
a small bump can still

00:00:25.630 --> 00:00:28.022
include a lot of new features.

00:00:28.022 --> 00:00:29.980
Where the defining
characteristic of Jelly Bean

00:00:29.980 --> 00:00:31.630
was buttery
smoothness, KitKat is

00:00:31.630 --> 00:00:33.800
all about memory optimization.

00:00:33.800 --> 00:00:36.540
Android 4.4 is designed
to run just as smoothly

00:00:36.540 --> 00:00:39.750
on a much broader range of
devices, including those

00:00:39.750 --> 00:00:43.020
with as little as
512 megs of RAM.

00:00:43.020 --> 00:00:45.810
For developers, that means a
selection of new APIs and tools

00:00:45.810 --> 00:00:47.610
to help us ensure
that our apps are

00:00:47.610 --> 00:00:49.860
as memory efficient
as the platform.

00:00:49.860 --> 00:00:52.570
You can start by checking if
your app is running on a memory

00:00:52.570 --> 00:00:56.380
constrained device using
the new .isLowRamDevice call

00:00:56.380 --> 00:00:57.950
on the ActivityManager.

00:00:57.950 --> 00:00:59.660
Based on the result,
you might choose

00:00:59.660 --> 00:01:01.490
to modify or even
disable features

00:01:01.490 --> 00:01:03.220
with significant
memory implications

00:01:03.220 --> 00:01:05.250
to ensure your app
provides a great user

00:01:05.250 --> 00:01:07.430
experience on devices
with memory limits

00:01:07.430 --> 00:01:09.880
similar to those featured
by Guy Pearce's character

00:01:09.880 --> 00:01:11.300
in "Memento."

00:01:11.300 --> 00:01:13.950
Of course, disabling features
is always a last resort,

00:01:13.950 --> 00:01:16.530
so check out this guide for
tips on how you can optimize

00:01:16.530 --> 00:01:18.540
your app's memory
usage without having

00:01:18.540 --> 00:01:21.110
to sacrifice functionality.

00:01:21.110 --> 00:01:23.500
But before you can start
improving your app's memory

00:01:23.500 --> 00:01:25.180
efficiency, you need
to first understand

00:01:25.180 --> 00:01:28.120
how you're using memory
in the first place.

00:01:28.120 --> 00:01:32.080
The new procstats tool helps
you analyze memory resources,

00:01:32.080 --> 00:01:35.220
providing data about app's
execution durations and memory

00:01:35.220 --> 00:01:35.990
use.

00:01:35.990 --> 00:01:41.220
You can access procstats
from the adb tool by calling,

00:01:41.220 --> 00:01:43.570
adb shell dumpsys procstats.

00:01:43.570 --> 00:01:45.780
If command lines make
you nervous, fear not.

00:01:45.780 --> 00:01:49.210
Android 4.4 also includes
a new developer option

00:01:49.210 --> 00:01:50.880
that helps you analyze
your app's memory

00:01:50.880 --> 00:01:53.390
profile on any
Android 4.4 device

00:01:53.390 --> 00:01:57.840
or emulator through the Process
Stats developer option screen.

00:01:57.840 --> 00:01:59.830
Below the system
memory summary, there's

00:01:59.830 --> 00:02:03.670
a list of blue bars indicating
the relative computed memory

00:02:03.670 --> 00:02:07.500
load of each app's process,
and the relative percentage

00:02:07.500 --> 00:02:10.610
of time each has spent
in the background.

00:02:10.610 --> 00:02:13.490
Selecting that displays a
summary of the memory consumed

00:02:13.490 --> 00:02:15.530
and the percentage of
the collection interval

00:02:15.530 --> 00:02:18.110
that this particular app
has been running for,

00:02:18.110 --> 00:02:21.556
as well as the average
and maximum RAM usage.

00:02:21.556 --> 00:02:23.430
It's not all about memory
efficiency, though.

00:02:23.430 --> 00:02:26.590
KitKat also includes some new
ways to build beautiful apps,

00:02:26.590 --> 00:02:29.480
starting with some updates
to the Android Design Guide,

00:02:29.480 --> 00:02:31.060
designed to help
you create striking,

00:02:31.060 --> 00:02:33.060
innovative, and
distinctive apps that

00:02:33.060 --> 00:02:35.384
offer users a
magical experience.

00:02:35.384 --> 00:02:37.300
For more details, check
out tomorrow's episode

00:02:37.300 --> 00:02:39.680
of "Android Design in Action."

00:02:39.680 --> 00:02:41.430
In terms of APIs,
there's support

00:02:41.430 --> 00:02:44.910
for a more immersive full-screen
experience, a new transition

00:02:44.910 --> 00:02:48.000
framework for animating scenes,
closed captioning support,

00:02:48.000 --> 00:02:51.350
and a new tool for
high-fidelity screen recording.

00:02:51.350 --> 00:02:52.850
The new full-screen
immersive mode

00:02:52.850 --> 00:02:56.270
lets you create full-bleed UIs
that reach from edge to edge,

00:02:56.270 --> 00:02:59.675
hiding all system UI, including
the status and navigation bars.

00:02:59.675 --> 00:03:01.550
It allows your app to
respond to touch events

00:03:01.550 --> 00:03:06.220
from areas that would otherwise
be occupied by the system bars.

00:03:06.220 --> 00:03:09.830
It's a great solution for rich,
visual content such as photos,

00:03:09.830 --> 00:03:12.190
videos, maps, books, and games.

00:03:12.190 --> 00:03:13.760
You can enable
this new mode using

00:03:13.760 --> 00:03:15.930
two new mutually
exclusive system UI

00:03:15.930 --> 00:03:19.300
flags-- immersive
and immersive_sticky.

00:03:19.300 --> 00:03:21.370
This code shows how
to toggle between

00:03:21.370 --> 00:03:23.640
an immersive full-screen
experience within your app

00:03:23.640 --> 00:03:25.260
using the Immersive flag.

00:03:25.260 --> 00:03:28.017
Alternatively, you can utilize
the immersive_sticky flag

00:03:28.017 --> 00:03:29.850
to create a persistent,
immersive experience

00:03:29.850 --> 00:03:32.320
that will automatically
rehide the system

00:03:32.320 --> 00:03:35.360
bars after a short delay,
or if the user interacts

00:03:35.360 --> 00:03:36.790
with the middle of the screen.

00:03:36.790 --> 00:03:38.540
You can learn more
about the new immersive

00:03:38.540 --> 00:03:40.820
modes, including
the best practices

00:03:40.820 --> 00:03:43.570
for using each alternative, in
Roman Nurik's Immersive Mode

00:03:43.570 --> 00:03:45.510
DevByte.

00:03:45.510 --> 00:03:48.030
To make it easier to create
high-quality animations

00:03:48.030 --> 00:03:51.590
in your app, Android 4.4 also
introduces a new transitions

00:03:51.590 --> 00:03:53.740
framework for animating
between scenes.

00:03:53.740 --> 00:03:55.740
Now it's pretty common
to use animations

00:03:55.740 --> 00:03:58.460
to help users understand their
progress through UI states

00:03:58.460 --> 00:04:01.650
where each state can
expose different actions.

00:04:01.650 --> 00:04:04.990
The new transitions framework
helps you define these scenes--

00:04:04.990 --> 00:04:08.250
typically view hierarchies like
these-- and the transitions

00:04:08.250 --> 00:04:11.250
which define how to animate the
transformations between scenes

00:04:11.250 --> 00:04:13.760
when the user enters
or exits them.

00:04:13.760 --> 00:04:16.370
You can use one of several
pre-defined transition types

00:04:16.370 --> 00:04:18.180
based on specific
properties like layout

00:04:18.180 --> 00:04:21.350
bounds or visibility, or
use the auto-transition type

00:04:21.350 --> 00:04:24.680
to automagically fade,
move, and resize views

00:04:24.680 --> 00:04:26.510
during a scene change.

00:04:26.510 --> 00:04:28.486
You can also define
custom transitions

00:04:28.486 --> 00:04:30.860
that animate the properties
that matter most to your app,

00:04:30.860 --> 00:04:33.845
or even plug in your
own animation styles.

00:04:33.845 --> 00:04:35.970
For more details, check
out the Transitions DevByte

00:04:35.970 --> 00:04:39.182
by our master of
animation, Chet Haase.

00:04:39.182 --> 00:04:41.140
In an effort to make your
apps more accessible,

00:04:41.140 --> 00:04:43.880
Android 4.4 includes
system-wide preferences

00:04:43.880 --> 00:04:45.490
for closed captioning.

00:04:45.490 --> 00:04:48.430
Users can now set global
captioning preferences,

00:04:48.430 --> 00:04:50.850
and apps that use video can
use those settings to adjust

00:04:50.850 --> 00:04:53.820
how they present closed captions
by using the new Captioning

00:04:53.820 --> 00:04:54.860
Manager.

00:04:54.860 --> 00:04:56.470
Apps that use
VideoView can simply

00:04:56.470 --> 00:04:59.860
pass a captioning
stream in WebVTT format,

00:04:59.860 --> 00:05:01.810
along with the video
stream for rendering.

00:05:01.810 --> 00:05:04.230
And the system will handle
display of the captions

00:05:04.230 --> 00:05:06.590
according to those
user preferences.

00:05:06.590 --> 00:05:09.600
For more details, check out
this DevByte by Alan Viverette,

00:05:09.600 --> 00:05:12.120
the engineer who
implemented it all.

00:05:12.120 --> 00:05:14.220
If you've ever tried to
record a demo of your app

00:05:14.220 --> 00:05:16.790
by holding a video
camera very steady,

00:05:16.790 --> 00:05:19.070
you'll appreciate the
new screen recording

00:05:19.070 --> 00:05:22.090
tool that lets you capture
video as you use the device

00:05:22.090 --> 00:05:23.870
and store it as an MP4.

00:05:23.870 --> 00:05:26.190
You can record in any
device-supported resolution

00:05:26.190 --> 00:05:28.300
and bit rate, and
the output retains

00:05:28.300 --> 00:05:30.290
the aspect ratio of the display.

00:05:30.290 --> 00:05:32.980
You can access screen recording
through the adb tool calling

00:05:32.980 --> 00:05:35.610
adb shell screenrecord,
or through the DDMS

00:05:35.610 --> 00:05:38.170
panel in Eclipse
or Android Studio.

00:05:38.170 --> 00:05:42.720
KitKat also includes a couple
of significant new storage API

00:05:42.720 --> 00:05:44.960
changes, with a new
storage access framework

00:05:44.960 --> 00:05:47.970
and a fully supported
SMS content provider.

00:05:47.970 --> 00:05:49.620
The new storage
access framework makes

00:05:49.620 --> 00:05:53.210
it easier for users to browse
and open documents, images,

00:05:53.210 --> 00:05:56.120
and other files across all
of the available local and

00:05:56.120 --> 00:05:58.960
cloud-based document
storage providers.

00:05:58.960 --> 00:06:01.250
If you develop an app
that manages files or uses

00:06:01.250 --> 00:06:03.470
documents, you can integrate
with the storage access

00:06:03.470 --> 00:06:05.110
framework using
the create_document

00:06:05.110 --> 00:06:07.450
or open_document
intents, and the system

00:06:07.450 --> 00:06:09.270
will display the
standard UI, including

00:06:09.270 --> 00:06:12.540
content from all the
available document providers.

00:06:12.540 --> 00:06:14.440
If you want to add
a storage provider,

00:06:14.440 --> 00:06:17.530
you implement a new
documents provider.

00:06:17.530 --> 00:06:19.020
Overriding these
four methods will

00:06:19.020 --> 00:06:21.080
let you manage the browsing,
reading, and writing

00:06:21.080 --> 00:06:24.920
of any local or remote data that
can be represented as files.

00:06:24.920 --> 00:06:27.940
Then, you just need to
add the documents provider

00:06:27.940 --> 00:06:30.020
manifest intent filter,
and request permission

00:06:30.020 --> 00:06:31.435
to manage documents.

00:06:31.435 --> 00:06:33.880
This process will register
your provider with the storage

00:06:33.880 --> 00:06:36.930
access framework and make it
available to the standard UI.

00:06:36.930 --> 00:06:38.590
Then, whenever your
app is installed,

00:06:38.590 --> 00:06:41.000
any app that uses this framework
to view or select files

00:06:41.000 --> 00:06:43.250
will provide access
to your content.

00:06:43.250 --> 00:06:45.050
Our very own Lisa
Wray has created

00:06:45.050 --> 00:06:48.480
DevBytes for both provider and
consumer uses of the storage

00:06:48.480 --> 00:06:51.960
access framework, so check
them out for more details.

00:06:51.960 --> 00:06:56.030
Now, if you've been using
undocumented methods

00:06:56.030 --> 00:06:59.920
to provide an SMS-based app,
now is an excellent opportunity

00:06:59.920 --> 00:07:03.780
to familiarize yourself with the
official APIs for SMS handling.

00:07:03.780 --> 00:07:06.670
That primarily involves a
newly documented SMS content

00:07:06.670 --> 00:07:09.080
provider, but also
introduces new semantics

00:07:09.080 --> 00:07:12.007
for receiving messages and
writing to the provider.

00:07:12.007 --> 00:07:13.590
When a message is
received, the system

00:07:13.590 --> 00:07:16.640
routes it directly to the
user's default messaging app

00:07:16.640 --> 00:07:19.020
using the SMS_DELIVER
intent, while other apps

00:07:19.020 --> 00:07:21.720
can continue to listen for
incoming messages using the SMS

00:07:21.720 --> 00:07:23.180
Received intent.

00:07:23.180 --> 00:07:26.350
Only the default app is able to
write new messages to the SMS

00:07:26.350 --> 00:07:30.230
provider, but other apps can
continue to read from it.

00:07:30.230 --> 00:07:31.730
Apps that aren't
the current default

00:07:31.730 --> 00:07:33.350
can also continue
to send messages.

00:07:33.350 --> 00:07:35.540
Here, the system will write
those outgoing messages

00:07:35.540 --> 00:07:38.860
to the provider on your
behalf, so that users can still

00:07:38.860 --> 00:07:40.880
see them in their default app.

00:07:40.880 --> 00:07:44.000
For more details, check
out Adam's DevByte.

00:07:44.000 --> 00:07:46.240
Also included in
Android 4.4 are a number

00:07:46.240 --> 00:07:49.310
of additions to help your app
interact with the real world,

00:07:49.310 --> 00:07:52.920
including new Bluetooth profiles
for Bluetooth HID Over GATT,

00:07:52.920 --> 00:07:54.770
which provides apps
with a low latency

00:07:54.770 --> 00:07:58.780
link for low-power peripheral
devices like mice, joysticks,

00:07:58.780 --> 00:08:02.060
and keyboards, and Bluetooth
MAP for nearby device message

00:08:02.060 --> 00:08:03.020
exchange.

00:08:03.020 --> 00:08:05.490
There's also new platform
support for built-in IR

00:08:05.490 --> 00:08:07.200
blasters with a
new API that lets

00:08:07.200 --> 00:08:09.680
you check whether the device
has an infrared emitter,

00:08:09.680 --> 00:08:13.200
query its carrier frequencies,
and then send infrared signals.

00:08:13.200 --> 00:08:15.800
There's also support
for host card emulation.

00:08:15.800 --> 00:08:19.230
HCE adds support for secure
NFC-based transactions

00:08:19.230 --> 00:08:22.190
for things like payments,
loyalty programs, card access,

00:08:22.190 --> 00:08:24.560
and transit passes
by allowing your app

00:08:24.560 --> 00:08:26.730
to emulate an NFC
smart card, though

00:08:26.730 --> 00:08:29.760
without requiring a
provisioned secure element.

00:08:29.760 --> 00:08:31.560
It also supports
a new reader mode

00:08:31.560 --> 00:08:33.710
to have your app act
as a reader for HCE

00:08:33.710 --> 00:08:36.419
cards and other
NFC-based transactions.

00:08:36.419 --> 00:08:40.340
Android HCE emulates ISO
7816-based smart cards

00:08:40.340 --> 00:08:44.220
using the ISO 14443-4
protocol for transmission,

00:08:44.220 --> 00:08:46.570
along with the application
identifiers as defined

00:08:46.570 --> 00:08:50.980
in ISO 7816-4 as the basis
for routing transactions

00:08:50.980 --> 00:08:53.710
to the correct
Android applications.

00:08:53.710 --> 00:08:56.440
There's also native platform
support for printing,

00:08:56.440 --> 00:08:58.240
along with APIs for
managing printing

00:08:58.240 --> 00:09:01.030
over Wi-Fi or
cloud-hosted services

00:09:01.030 --> 00:09:03.330
such as Google Cloud Print.

00:09:03.330 --> 00:09:05.850
You can use these new APIs
to add printing capabilities

00:09:05.850 --> 00:09:09.140
for nearly any type of content,
from local images and documents

00:09:09.140 --> 00:09:12.650
to network data or anything
that you can render to a canvas.

00:09:12.650 --> 00:09:15.580
Android uses PDF as its primary
file format for printing,

00:09:15.580 --> 00:09:18.450
so it's best practice to use the
helper classes to print bitmaps

00:09:18.450 --> 00:09:21.080
or to generate a
properly paginated PDF

00:09:21.080 --> 00:09:23.440
version of your content.

00:09:23.440 --> 00:09:24.910
For convenience,
the printing API

00:09:24.910 --> 00:09:26.960
provides native
and WebView helpers

00:09:26.960 --> 00:09:30.390
to let you create PDFs using
standard Android drawing APIs.

00:09:30.390 --> 00:09:33.040
If your app knows how
to draw the content,

00:09:33.040 --> 00:09:35.600
it can create a PDF
for printing it.

00:09:35.600 --> 00:09:37.640
Nazmul Idris summarizes
the best practices

00:09:37.640 --> 00:09:40.110
for getting started
with printing on Android

00:09:40.110 --> 00:09:42.180
in this DevByte.

00:09:42.180 --> 00:09:45.160
KitKat also introduces new
ways to improve the power use

00:09:45.160 --> 00:09:47.320
profile of device
sensors, starting

00:09:47.320 --> 00:09:49.890
with sensor batching,
a new optimization

00:09:49.890 --> 00:09:52.010
that delivers sensor
results in batches

00:09:52.010 --> 00:09:54.020
rather than as
they are detected.

00:09:54.020 --> 00:09:55.520
This lets the
application processors

00:09:55.520 --> 00:09:58.910
stay in a low-power state
until each batch is delivered.

00:09:58.910 --> 00:10:01.280
You can define the interval
at which you receive batches

00:10:01.280 --> 00:10:04.850
or request immediate delivery
of events between batch cycles.

00:10:04.850 --> 00:10:07.470
There's also two new composite
sensors-- step detection

00:10:07.470 --> 00:10:09.160
and step counting--
both of which

00:10:09.160 --> 00:10:12.440
were implemented within hardware
to help minimize the associated

00:10:12.440 --> 00:10:14.110
power consumption.

00:10:14.110 --> 00:10:17.270
And that's just a small taste
of the new APIs available.

00:10:17.270 --> 00:10:19.900
There's also a completely
new implementation

00:10:19.900 --> 00:10:22.260
of WebView based on
Google Chromium that

00:10:22.260 --> 00:10:24.380
offers the latest in
standard support performance

00:10:24.380 --> 00:10:27.680
and compatibility,
and most of the HTML5

00:10:27.680 --> 00:10:30.810
features available in Chrome
for Android version 30,

00:10:30.810 --> 00:10:33.590
plus an updated
JavaScript V8 engine.

00:10:33.590 --> 00:10:37.240
There's also a range of new APIs
to better support RTL locales,

00:10:37.240 --> 00:10:40.480
including drawable,
mirroring, and pseudo-locales.

00:10:40.480 --> 00:10:42.310
Declaring a drawable
as auto-mirrorable

00:10:42.310 --> 00:10:44.730
will allow the system
to flip it automatically

00:10:44.730 --> 00:10:48.240
for users using an RTL
locale, preventing you

00:10:48.240 --> 00:10:50.380
from having to
duplicate your assets.

00:10:50.380 --> 00:10:52.930
Android now also includes
an RTL pseudo-locale

00:10:52.930 --> 00:10:54.970
as a new developer option.

00:10:54.970 --> 00:10:56.670
The pseudo-locale
switches the device

00:10:56.670 --> 00:10:59.460
to an RTL for all
locales and displays text

00:10:59.460 --> 00:11:01.110
in the current language.

00:11:01.110 --> 00:11:03.700
This can help you find
layout issues across your app

00:11:03.700 --> 00:11:06.430
without having to display
the app in an RTL language

00:11:06.430 --> 00:11:08.510
that you may not
be able to read.

00:11:08.510 --> 00:11:11.500
There's also good news for fans
of high performance computation

00:11:11.500 --> 00:11:13.130
with performance
improvements to render

00:11:13.130 --> 00:11:15.930
script and the new ability to
take advantage of render script

00:11:15.930 --> 00:11:17.850
directly from your native code.

00:11:17.850 --> 00:11:21.390
A new C++ API in the ADK lets
you access the same render

00:11:21.390 --> 00:11:24.320
script functionality available
through the framework APIs,

00:11:24.320 --> 00:11:27.510
including script intrinsics
and custom kernels.

00:11:27.510 --> 00:11:30.730
Last, but by no means
least, is a series

00:11:30.730 --> 00:11:32.350
of security
enhancements, including

00:11:32.350 --> 00:11:35.560
an update to Android's SELinux
configuration, changing

00:11:35.560 --> 00:11:38.490
from permissive to
enforcing, and improved

00:11:38.490 --> 00:11:40.190
cryptographic algorithms.

00:11:40.190 --> 00:11:42.864
Elliptic Curve Digital
Signature Algorithm support

00:11:42.864 --> 00:11:44.530
has been added to the
keystore provider.

00:11:44.530 --> 00:11:46.490
And the script key
derivation function

00:11:46.490 --> 00:11:49.630
is now implemented to protect
the cryptographic keys used

00:11:49.630 --> 00:11:51.690
for full disk encryption.

00:11:51.690 --> 00:11:54.610
In entirely related news,
there is a new device

00:11:54.610 --> 00:11:57.610
in town with the
launch of the Nexus 5.

00:11:57.610 --> 00:11:59.410
Check out Google Play
for all the details

00:11:59.410 --> 00:12:01.170
and grab one for
yourself, purely

00:12:01.170 --> 00:12:03.880
for development
purposes, of course.

00:12:03.880 --> 00:12:06.770
The Android 4.4 SDK is now
available for your downloading

00:12:06.770 --> 00:12:10.190
and code updating pleasure
using the SDK manager.

00:12:10.190 --> 00:12:13.230
And you can get more details on
all of the new APIs, features,

00:12:13.230 --> 00:12:14.950
best practice, and
every other change

00:12:14.950 --> 00:12:16.690
at developers.google.com.

