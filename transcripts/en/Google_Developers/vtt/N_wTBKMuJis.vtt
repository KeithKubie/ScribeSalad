WEBVTT
Kind: captions
Language: en

00:00:00.530 --> 00:00:00.930
ERIC BIDELMAN: Hello,
everybody.

00:00:00.930 --> 00:00:04.160
Thank you so much for coming
to A More Awesome Web:

00:00:04.160 --> 00:00:07.110
Features You've Always Always,
Always Wanted.

00:00:07.110 --> 00:00:08.340
My name is Eric Bidelman.

00:00:08.340 --> 00:00:09.990
I'm a Developer Programs
Engineer on the

00:00:09.990 --> 00:00:11.250
Google Chrome team.

00:00:11.250 --> 00:00:13.140
We're goingto talk about
a lot of stuff today.

00:00:13.140 --> 00:00:15.190
Way too many features to
really cover in-depth.

00:00:15.190 --> 00:00:17.340
But you can follow me on Google
+, you can follow me on

00:00:17.340 --> 00:00:19.840
Twitter, or check out some of
the articles I've written on

00:00:19.840 --> 00:00:22.300
html5Rocks, which will discuss
some of these technologies and

00:00:22.300 --> 00:00:25.250
APIs more in-depth.

00:00:25.250 --> 00:00:26.420
So plenty got moreawesome.

00:00:26.420 --> 00:00:28.480
I stood onstage last year
and gave a rundown

00:00:28.480 --> 00:00:30.250
of really cool features.

00:00:30.250 --> 00:00:32.450
And there's a ton of stuff
that've come since last year,

00:00:32.450 --> 00:00:34.820
in the last six months, even
in the last three months.

00:00:34.820 --> 00:00:36.360
Web Components is now a thing.

00:00:36.360 --> 00:00:37.740
There's a lot of stuff
landing under this

00:00:37.740 --> 00:00:38.680
umbrella in the browser.

00:00:38.680 --> 00:00:40.620
You saw some at the keynote.

00:00:40.620 --> 00:00:43.400
There's a couple sessions on
this tomorrow, including one

00:00:43.400 --> 00:00:44.000
that I'm giving.

00:00:44.000 --> 00:00:45.060
Really exciting, awesome

00:00:45.060 --> 00:00:46.720
technologies under that umbrella.

00:00:46.720 --> 00:00:48.230
WebRTC now on mobile.

00:00:48.230 --> 00:00:49.000
Now everywhere.

00:00:49.000 --> 00:00:52.530
DataChannel API for doing binary
streaming peer to peer

00:00:52.530 --> 00:00:53.780
is a thing now.

00:00:53.780 --> 00:00:56.460
Web Audio API is getting
awesome, awesome adoption

00:00:56.460 --> 00:00:58.090
across the various
browser vendors.

00:00:58.090 --> 00:01:00.860
So Chrome, Firefox has this
enabled in their nightlies.

00:01:00.860 --> 00:01:02.740
Safari and iOS and mobile.

00:01:02.740 --> 00:01:04.430
You can do real time
processing.

00:01:04.430 --> 00:01:06.920
We'll see demos of this later
on in the browser and

00:01:06.920 --> 00:01:08.250
JavaScript.

00:01:08.250 --> 00:01:09.190
Request Autocomplete.

00:01:09.190 --> 00:01:13.020
Standardizing payments on the
web is a session, I believe,

00:01:13.020 --> 00:01:15.620
tomorrow or today on this.

00:01:15.620 --> 00:01:16.440
Just amazing stuff.

00:01:16.440 --> 00:01:17.890
And the list goes on
and on and on.

00:01:17.890 --> 00:01:21.260
There's APIs for about
everything now.

00:01:21.260 --> 00:01:24.580
But I want to focus on two
primary topic areas.

00:01:24.580 --> 00:01:26.850
And that is CSS and
multimedia.

00:01:26.850 --> 00:01:28.820
I think these are the two
biggest areas where we're

00:01:28.820 --> 00:01:32.370
seeing the most changes and most
awesome stuff land in CSS

00:01:32.370 --> 00:01:34.490
and multimedia.

00:01:34.490 --> 00:01:37.300
So just a little convention
on this slidedeck.

00:01:37.300 --> 00:01:38.140
You're going to see icons
for everything.

00:01:38.140 --> 00:01:39.630
You're going to see
specification links.

00:01:39.630 --> 00:01:41.410
There's actually one thing today
that I'm talking about

00:01:41.410 --> 00:01:43.680
that doesn't have
a spec for it.

00:01:43.680 --> 00:01:46.600
HTML5 Rocks article, if there's
more content on that

00:01:46.600 --> 00:01:49.530
subject you can come back
later in the slide deck.

00:01:49.530 --> 00:01:51.620
Old Way, the red,
old busted way.

00:01:51.620 --> 00:01:54.520
This is a technique we have
learned how to do in the past.

00:01:54.520 --> 00:01:56.080
And there's probably a
better way to do it.

00:01:56.080 --> 00:01:59.100
Maybe a CSS feature has landed
that we don't need JavaScript

00:01:59.100 --> 00:01:59.650
for anymore.

00:01:59.650 --> 00:02:02.890
So that's what the new hotness,
the orange, means.

00:02:02.890 --> 00:02:06.380
No JavaScript, the purple,
basically means, again CSS

00:02:06.380 --> 00:02:08.880
stuff is starting to
take full circle.

00:02:08.880 --> 00:02:11.600
And we don't necessarily need
JavaScript to do the things we

00:02:11.600 --> 00:02:12.780
used to need to do.

00:02:12.780 --> 00:02:15.300
We can offload that stuff to
CSS at the presentational

00:02:15.300 --> 00:02:16.830
layer, where it should be.

00:02:16.830 --> 00:02:19.810
And then that sort of leads to
this last bling, the bling of

00:02:19.810 --> 00:02:21.940
the hash "perfmatters" tag.

00:02:21.940 --> 00:02:23.460
This is going to be a
performance tip that you can

00:02:23.460 --> 00:02:26.310
take advantage of.

00:02:26.310 --> 00:02:29.770
So without further ado, let's
dive right into CSS.

00:02:29.770 --> 00:02:32.030
If you take away anything from
this talk, it's basically that

00:02:32.030 --> 00:02:35.160
you don't necessarily need
JavaScript for everything.

00:02:35.160 --> 00:02:36.560
And that's really because
performance matters.

00:02:36.560 --> 00:02:39.560
You saw the talk before me
talk about jank busting.

00:02:39.560 --> 00:02:42.500
The more you can offload from
JavaScript, not have to set up

00:02:42.500 --> 00:02:45.240
scroll handlers, all this stuff,
the more the browser

00:02:45.240 --> 00:02:47.000
can optimize.

00:02:47.000 --> 00:02:51.040
And one great example of this is
new viewport units in CSS.

00:02:51.040 --> 00:02:51.980
So this is really great.

00:02:51.980 --> 00:02:55.160
We have vw, vmin, vmax,
and the vmin.

00:02:55.160 --> 00:02:57.540
So these are the
Viewport-percentage units.

00:02:57.540 --> 00:03:01.410
So Viewport width, Viewport
height, Viewport min and max.

00:03:01.410 --> 00:03:04.720
And unlike rems or ems, which
are based solely on the parent

00:03:04.720 --> 00:03:05.350
container--

00:03:05.350 --> 00:03:08.080
these are relative
to the parent--

00:03:08.080 --> 00:03:10.210
Viewport-percentage units are
great because they're based

00:03:10.210 --> 00:03:11.730
solely on the Viewport.

00:03:11.730 --> 00:03:14.060
So in this sort of multi-device
responsive design

00:03:14.060 --> 00:03:16.340
world, it's really handy to be
able to size things according

00:03:16.340 --> 00:03:19.410
to what Viewport I'm talking
to, and my app is being

00:03:19.410 --> 00:03:21.040
displayed on.

00:03:21.040 --> 00:03:24.760
So one of these guys is equal to
1% of the width or height,

00:03:24.760 --> 00:03:26.830
depending on what you're
talking about.

00:03:26.830 --> 00:03:30.000
So one vw is 1% of the
Viewport width.

00:03:30.000 --> 00:03:32.250
1 vh is 1% of the height.

00:03:32.250 --> 00:03:35.760
And in the case of the vmin or
vmax, you're talking about the

00:03:35.760 --> 00:03:36.970
minimum dimensions.

00:03:36.970 --> 00:03:39.480
So this slide deck, for
instance, is about 1,000 by

00:03:39.480 --> 00:03:40.760
700 pixels.

00:03:40.760 --> 00:03:42.470
So my min would be the
height, in this case.

00:03:42.470 --> 00:03:46.140
So 1 vmin would equal 1 vh in
the case of this viewport that

00:03:46.140 --> 00:03:48.370
I have here.

00:03:48.370 --> 00:03:50.560
So this is cool because we can
size things based on the

00:03:50.560 --> 00:03:52.710
viewport, solely on the
viewport, and we don't need to

00:03:52.710 --> 00:03:56.220
set a crazy amount of media
query breakpoints to size

00:03:56.220 --> 00:03:57.510
things like fonts.

00:03:57.510 --> 00:03:59.500
We can just take advantage of
these units and use them right

00:03:59.500 --> 00:04:01.700
out of the box.

00:04:01.700 --> 00:04:03.460
So ultimately, what this means
is you have a couple

00:04:03.460 --> 00:04:04.420
performance gains here.

00:04:04.420 --> 00:04:06.460
You don't have to do things like
determine the viewport

00:04:06.460 --> 00:04:08.140
size if you're just
sizing fonts or

00:04:08.140 --> 00:04:10.720
sizing divs or something.

00:04:10.720 --> 00:04:12.410
You can use these units.

00:04:12.410 --> 00:04:14.180
And you don't need to use
JavaScript to determine that

00:04:14.180 --> 00:04:15.940
viewport size anymore.

00:04:15.940 --> 00:04:18.529
And similarly, you don't need
to set up resize handlers.

00:04:18.529 --> 00:04:20.670
People tend to do way too much
stuff in resize handlers.

00:04:20.670 --> 00:04:22.230
They manipulate the DOM.

00:04:22.230 --> 00:04:24.880
And that basically just says, OK
browser you can't optimize

00:04:24.880 --> 00:04:28.000
scrolling or anything
of that nature.

00:04:28.000 --> 00:04:29.860
So a quick example of this
is something like this.

00:04:29.860 --> 00:04:32.770
I have 1,000 by 700
pixel Viewport.

00:04:32.770 --> 00:04:36.370
And I want to set an h1 to
be 4 vw, its font size.

00:04:36.370 --> 00:04:38.760
So what that roughly calculates
out to be is 4

00:04:38.760 --> 00:04:39.600
times 1,000--

00:04:39.600 --> 00:04:41.540
so viewport width--

00:04:41.540 --> 00:04:42.590
times that 1%.

00:04:42.590 --> 00:04:44.850
So in this case, my h1 is going
to be calculated out to

00:04:44.850 --> 00:04:48.400
be about 40 pixels once
displayed on screen.

00:04:48.400 --> 00:04:51.820
Similarly, I can set a div to
be a width of 15 vmin, which

00:04:51.820 --> 00:04:54.840
means 15 times the minimum
dimension-- so in this case,

00:04:54.840 --> 00:04:57.950
it's the height, 700 pixels,
times that 1%.

00:04:57.950 --> 00:05:03.580
So this div's width would
be roughly 105 pixels.

00:05:03.580 --> 00:05:04.830
Quick example of this.

00:05:10.630 --> 00:05:14.150
So this is my current
viewport.

00:05:14.150 --> 00:05:17.430
It's about 1,500 by 1984.

00:05:17.430 --> 00:05:20.590
On this resolution.

00:05:20.590 --> 00:05:23.600
So one of use case for viewport
percentage units is

00:05:23.600 --> 00:05:24.530
things like font size.

00:05:24.530 --> 00:05:25.340
It's really, really great.

00:05:25.340 --> 00:05:27.180
Your fonts are always going to
look good no matter what

00:05:27.180 --> 00:05:28.320
viewport you're in.

00:05:28.320 --> 00:05:31.620
Now as I scale this thing down,
you'll see that my fonts

00:05:31.620 --> 00:05:34.250
are being re-calculated based
solely on the viewport.

00:05:34.250 --> 00:05:36.790
So those "Hello World"s are
always going to look great no

00:05:36.790 --> 00:05:39.030
matter what my viewport
size is.

00:05:39.030 --> 00:05:40.530
And so they're always going
to be scaled based

00:05:40.530 --> 00:05:41.780
solely on the viewport.

00:05:43.910 --> 00:05:45.870
So I don't have set up things
like media query break points,

00:05:45.870 --> 00:05:48.470
define all these different
break points, for my

00:05:48.470 --> 00:05:49.690
responsive design.

00:05:49.690 --> 00:05:50.940
So it's pretty handy.

00:05:56.410 --> 00:05:58.150
And support for this is actually
really, really good.

00:05:58.150 --> 00:06:00.180
So this is sort of your current
lay of the land as far

00:06:00.180 --> 00:06:01.070
as browser support.

00:06:01.070 --> 00:06:04.680
You have a Safari, Firefox,
Chrome, IE has this, as well,

00:06:04.680 --> 00:06:05.720
which is really great.

00:06:05.720 --> 00:06:07.630
And mobile support is actually
up and coming, too.

00:06:07.630 --> 00:06:10.610
I'm including Opera beta mobile
on here, because of

00:06:10.610 --> 00:06:12.760
course they've moved to
Chromium recently.

00:06:12.760 --> 00:06:14.700
So this is something you can
take advantage of today.

00:06:14.700 --> 00:06:16.180
Really, really awesome,
especially for

00:06:16.180 --> 00:06:19.060
responsive-type designs.

00:06:19.060 --> 00:06:21.150
Something else we have
is intrinsic sizing.

00:06:21.150 --> 00:06:22.770
And this is really one
of my favorites.

00:06:22.770 --> 00:06:24.730
And a lot of people don't
know about this.

00:06:24.730 --> 00:06:26.880
But if you combine intrinsic
sizing so

00:06:26.880 --> 00:06:28.840
there's these new values--

00:06:28.840 --> 00:06:30.760
and these are vendor
prefixed--

00:06:30.760 --> 00:06:32.510
WebKit min or [INAUDIBLE].

00:06:32.510 --> 00:06:35.380
Content, fit-content,
max-content, and

00:06:35.380 --> 00:06:36.170
fill-available.

00:06:36.170 --> 00:06:39.010
And so you combine something
like this with Flexbox and

00:06:39.010 --> 00:06:40.050
it's just absolutely amazing.

00:06:40.050 --> 00:06:41.140
It boggles your mind.

00:06:41.140 --> 00:06:43.820
So I have display flex,
[? this is ?], of course,

00:06:43.820 --> 00:06:47.740
vendor prefixed for this
API or this property.

00:06:47.740 --> 00:06:49.600
My right container is
a Flexbox container.

00:06:49.600 --> 00:06:51.670
And its content, the Hello
World, is being centered

00:06:51.670 --> 00:06:52.640
vertically and horizontally.

00:06:52.640 --> 00:06:55.370
Thank you, Flexbox, three
lines of CSS.

00:06:55.370 --> 00:06:56.640
Really, really sweet.

00:06:56.640 --> 00:06:59.190
But then I can combine it with
intrinsic sizing and do things

00:06:59.190 --> 00:07:03.250
like, I can basically
shrink-wrap the width and

00:07:03.250 --> 00:07:05.640
height of this parent container
down to that inner

00:07:05.640 --> 00:07:06.760
[INAUDIBLE] content.

00:07:06.760 --> 00:07:08.810
So I don't have to use
JavaScript to get computed

00:07:08.810 --> 00:07:09.960
style of my inner children.

00:07:09.960 --> 00:07:13.320
I can just set fit content to
both width and height and get

00:07:13.320 --> 00:07:15.700
that shrink wrap effect.

00:07:15.700 --> 00:07:17.970
I could also say Fill Available,
so take up the

00:07:17.970 --> 00:07:19.860
entirety of your parent
container.

00:07:19.860 --> 00:07:23.250
And so, height, 100% doesn't
ever work out like we quite

00:07:23.250 --> 00:07:25.920
want it to, but Fill Available
does the right thing each and

00:07:25.920 --> 00:07:28.560
every time.

00:07:28.560 --> 00:07:29.950
You could also say
Main Content.

00:07:29.950 --> 00:07:34.060
So in this case, shrink-wrap
yourself to be container

00:07:34.060 --> 00:07:34.890
inside of your children.

00:07:34.890 --> 00:07:36.150
But it's OK to wrap.

00:07:36.150 --> 00:07:38.600
So I have a text note,
just Hello World.

00:07:38.600 --> 00:07:39.290
That's going to wrap.

00:07:39.290 --> 00:07:41.720
I haven't specified
for it not to.

00:07:41.720 --> 00:07:42.800
So really, really handy.

00:07:42.800 --> 00:07:44.060
It combines the Flexbox.

00:07:44.060 --> 00:07:46.760
You don't have to do crazy
things in JavaScript anymore.

00:07:46.760 --> 00:07:48.580
Support is in Firefox,
and a couple of the

00:07:48.580 --> 00:07:50.110
mobile browsers as well.

00:07:50.110 --> 00:07:51.410
And Chrome.

00:07:51.410 --> 00:07:52.310
So really, really handy.

00:07:52.310 --> 00:07:54.700
Again, height 100%, you
don't need it anymore.

00:07:54.700 --> 00:07:57.050
You can use Fill Available.

00:07:57.050 --> 00:07:58.410
What about CSS variables?

00:07:58.410 --> 00:08:01.050
This is something that's sort
of been on the horizon for a

00:08:01.050 --> 00:08:02.020
long, long time.

00:08:02.020 --> 00:08:04.950
People have wanted proper
CSS variables to do

00:08:04.950 --> 00:08:06.360
variables in CSS.

00:08:06.360 --> 00:08:07.920
And we can finally
enable this.

00:08:07.920 --> 00:08:10.600
This is an experimental feature
in Chrome that you can

00:08:10.600 --> 00:08:12.760
enable in About Flags.

00:08:12.760 --> 00:08:15.630
And so pre-processors have
made this really common.

00:08:15.630 --> 00:08:17.440
GLASS, Sass, Compass.

00:08:17.440 --> 00:08:19.520
You can set up variables
globally and then you can use

00:08:19.520 --> 00:08:20.610
them throughout your
style sheets.

00:08:20.610 --> 00:08:21.780
Very, very handy.

00:08:21.780 --> 00:08:23.610
It's an obvious win
for the web.

00:08:23.610 --> 00:08:26.370
And so we can do that now,
actually, in CSS proper.

00:08:26.370 --> 00:08:29.040
And the way it works is that
you define a variable name.

00:08:29.040 --> 00:08:30.850
And the only caveat is
it has to be prefixed

00:08:30.850 --> 00:08:32.070
with this var dash.

00:08:32.070 --> 00:08:35.409
So again, vendor prefixes
var dash, variable name,

00:08:35.409 --> 00:08:36.070
whatever you want.

00:08:36.070 --> 00:08:38.510
Uppercase, lowercase,
camel case.

00:08:38.510 --> 00:08:41.080
so I'm defining a font
color to be red.

00:08:41.080 --> 00:08:43.190
And then the way I use
this variable is

00:08:43.190 --> 00:08:44.420
to use the var function.

00:08:44.420 --> 00:08:47.720
So var and then the CSS
variables name.

00:08:52.530 --> 00:08:55.580
What's really nice about this
is that, just as with CSS,

00:08:55.580 --> 00:08:57.120
things cascade down.

00:08:57.120 --> 00:08:58.960
That's an awesome
property of CSS.

00:08:58.960 --> 00:09:00.800
Variables cascade down, too.

00:09:00.800 --> 00:09:04.500
So this variable here, this font
color has been defined in

00:09:04.500 --> 00:09:07.370
my body element, my
body selector.

00:09:07.370 --> 00:09:09.360
And then I can use that in
any children that it

00:09:09.360 --> 00:09:12.090
cascades down to.

00:09:12.090 --> 00:09:12.650
Which is really handy.

00:09:12.650 --> 00:09:14.020
It's a great property of CSS.

00:09:14.020 --> 00:09:16.600
And that carries over to
variables, as well.

00:09:16.600 --> 00:09:18.450
And there's also room
for fallback cases.

00:09:18.450 --> 00:09:20.590
So if I don't have that
cascading, for some reason I'm

00:09:20.590 --> 00:09:23.480
not getting the font color
variable in that selector I'm

00:09:23.480 --> 00:09:26.690
using, I can use the var
function, give it the font

00:09:26.690 --> 00:09:29.610
color variable name, and if it
doesn't exist, we'll just use

00:09:29.610 --> 00:09:30.910
blue by default.

00:09:30.910 --> 00:09:33.010
So that's pretty cool.

00:09:33.010 --> 00:09:36.030
A little bit more real-world
example of this.

00:09:36.030 --> 00:09:39.830
So I have basically defined a
couple global variables on my

00:09:39.830 --> 00:09:41.600
root document.

00:09:41.600 --> 00:09:44.710
This is how you define global
variables and CSS variables.

00:09:44.710 --> 00:09:47.000
So I have a text color that
and I'm saying to yellow.

00:09:47.000 --> 00:09:49.900
And I have a background color
that I'm defining to be pink.

00:09:49.900 --> 00:09:52.020
But you'll notice, in my footer,
this black thing at

00:09:52.020 --> 00:09:53.490
the bottom here is
this live demo.

00:09:53.490 --> 00:09:55.280
And the black thing
is not pink.

00:09:55.280 --> 00:09:56.490
It's actually black.

00:09:56.490 --> 00:09:59.460
And that's because I've defined
a locally scoped

00:09:59.460 --> 00:10:02.420
background color variable
to be black.

00:10:02.420 --> 00:10:06.460
So that's sort of the local
scoping of CSS variables.

00:10:06.460 --> 00:10:09.090
And then I'm using the text
color, which is inherited from

00:10:09.090 --> 00:10:09.880
that global variable.

00:10:09.880 --> 00:10:12.180
That text color yellow, up here
at the top, I can use

00:10:12.180 --> 00:10:13.930
that because again, these rules

00:10:13.930 --> 00:10:17.220
cascade down into children.

00:10:17.220 --> 00:10:18.940
Very similarly, I've redefined
a new local

00:10:18.940 --> 00:10:20.260
variable text color.

00:10:20.260 --> 00:10:22.420
Even though it's the same as
this one that I've defined

00:10:22.420 --> 00:10:24.470
globally, it's locally
scoped down here.

00:10:24.470 --> 00:10:26.700
So that's why this white
span is colored

00:10:26.700 --> 00:10:29.840
white instead of yellow.

00:10:29.840 --> 00:10:30.630
So that's pretty awesome.

00:10:30.630 --> 00:10:32.670
CSS proper variables.

00:10:32.670 --> 00:10:34.770
You can experiment with this
in Chrome, again, with the

00:10:34.770 --> 00:10:36.910
Experimental Features flag.

00:10:36.910 --> 00:10:40.160
This is a really awesome,
great, perfect time to

00:10:40.160 --> 00:10:41.070
highlight chromestatus.com.

00:10:41.070 --> 00:10:43.590
A lot of stuff I'm going to
show you today is brand

00:10:43.590 --> 00:10:44.620
spanking new.

00:10:44.620 --> 00:10:47.460
And of course, Chrome is one of
the first browsers to see a

00:10:47.460 --> 00:10:49.080
lot of this awesome coolness.

00:10:49.080 --> 00:10:51.660
But we're actually trying to
track across different browser

00:10:51.660 --> 00:10:55.000
vendors the lay of the land,
where features are in flight.

00:10:55.000 --> 00:10:56.590
And you can visit
chromestatus.com.

00:10:56.590 --> 00:10:58.850
It's not only Chrome features,
but what other browser vendors

00:10:58.850 --> 00:10:59.260
are thinking.

00:10:59.260 --> 00:11:01.060
Where specs are.

00:11:01.060 --> 00:11:03.330
So you get a good idea for when
features are available.

00:11:07.140 --> 00:11:10.310
What about CSS features
detection in CSS?

00:11:10.310 --> 00:11:11.005
How cool would that be?

00:11:11.005 --> 00:11:12.160
It's right here.

00:11:12.160 --> 00:11:14.570
So we have, now, a new
@supports rule

00:11:14.570 --> 00:11:16.190
that finally landed.

00:11:16.190 --> 00:11:18.760
And we can actually do feature
detection in CSS detect

00:11:18.760 --> 00:11:21.550
features, in our CSS features.

00:11:21.550 --> 00:11:22.170
So this is really great.

00:11:22.170 --> 00:11:23.580
Because we've relied
on JavaScript

00:11:23.580 --> 00:11:25.070
libraries do this for us.

00:11:25.070 --> 00:11:27.550
But if I wanted to I could
test the browser that the

00:11:27.550 --> 00:11:30.230
user's using, if it
supports FlexBox.

00:11:30.230 --> 00:11:32.765
So basically, this new
supports at-rule.

00:11:32.765 --> 00:11:35.980
Then I give it the query,
similar to a media query.

00:11:35.980 --> 00:11:37.920
But it's the property that
I want to test for.

00:11:37.920 --> 00:11:40.850
So in this case, if the browser
supports FlexBox, all

00:11:40.850 --> 00:11:43.540
the rules in this block
will then apply.

00:11:43.540 --> 00:11:45.520
So in that case, I
know it's true.

00:11:45.520 --> 00:11:46.740
The browser supports FlexBox.

00:11:46.740 --> 00:11:48.790
I can set and use--

00:11:48.790 --> 00:11:51.790
I can make the body a
FlexBox container.

00:11:51.790 --> 00:11:54.510
So if the browser doesn't
support this new at-rule, it's

00:11:54.510 --> 00:11:56.450
no big, nowhere.

00:11:56.450 --> 00:11:58.130
It's just going to ignore
all the styles in there.

00:11:58.130 --> 00:11:59.080
So that's totally cool.

00:11:59.080 --> 00:12:00.920
There's no harm done there.

00:12:00.920 --> 00:12:03.540
But I can do things like nodding
or anding or or-ing.

00:12:03.540 --> 00:12:05.150
So a more complex example--

00:12:05.150 --> 00:12:06.970
but not entirely more
complex-- is

00:12:06.970 --> 00:12:07.580
at the bottom, here.

00:12:07.580 --> 00:12:10.740
I can test for the negation
or the complement.

00:12:10.740 --> 00:12:13.840
So if the browser doesn't
support FlexBox with this not,

00:12:13.840 --> 00:12:15.720
then I can apply--

00:12:15.720 --> 00:12:16.820
maybe I could use floats.

00:12:16.820 --> 00:12:18.210
Or I can CSS columns.

00:12:18.210 --> 00:12:20.700
Or I can use CSS grid
if it's available.

00:12:20.700 --> 00:12:22.190
So really, really handy.

00:12:22.190 --> 00:12:25.240
At the presentation level, where
you can now test CSS

00:12:25.240 --> 00:12:27.240
features using @supports.

00:12:27.240 --> 00:12:29.080
But similar to media queries,
there's also a

00:12:29.080 --> 00:12:30.760
JavaScript API for that.

00:12:30.760 --> 00:12:33.140
We do have a JavaScript
API for testing CSS

00:12:33.140 --> 00:12:34.390
features, as well.

00:12:34.390 --> 00:12:36.880
And that's a new property
on Windows CSS.

00:12:36.880 --> 00:12:39.940
And there's a supports method
that you can use.

00:12:39.940 --> 00:12:42.110
And so this is kind of cool,
because you can do things like

00:12:42.110 --> 00:12:43.860
dynamic testing.

00:12:43.860 --> 00:12:47.430
And so it's really important
that, for this to return true,

00:12:47.430 --> 00:12:49.830
the browser has to, A,
support the feature,

00:12:49.830 --> 00:12:51.180
support the CSS property.

00:12:51.180 --> 00:12:53.520
So most browsers now
support width.

00:12:53.520 --> 00:12:55.090
So we're cool there.

00:12:55.090 --> 00:12:58.530
But the browser also has to
actually successfully parse

00:12:58.530 --> 00:13:01.020
out, and this has to
be a value they can

00:13:01.020 --> 00:13:02.800
be set to this property.

00:13:02.800 --> 00:13:05.710
So what I mean by that is, yes,
width is supported in

00:13:05.710 --> 00:13:06.260
most browsers.

00:13:06.260 --> 00:13:09.790
But CSS calc a may not be.

00:13:09.790 --> 00:13:11.760
But when I set it
to some garbage.

00:13:11.760 --> 00:13:14.090
I use calc and, like,
ABC, or something.

00:13:14.090 --> 00:13:15.490
That's not a parsed out value.

00:13:15.490 --> 00:13:17.720
So the browser's actually going
to return false for that

00:13:17.720 --> 00:13:21.210
particular call, if I'm trying
to set it up to some garbage.

00:13:21.210 --> 00:13:22.260
And there's actually
an overload

00:13:22.260 --> 00:13:23.240
version of this, as well.

00:13:23.240 --> 00:13:26.160
If you don't want to give it
the simple property value

00:13:26.160 --> 00:13:30.300
pair, you can put in your
full-on, crazy string of

00:13:30.300 --> 00:13:32.470
features that you want to test
and featured detect.

00:13:32.470 --> 00:13:35.340
So I can test, for example, if
the browsers support width,

00:13:35.340 --> 00:13:37.730
setting it to this calc
value, and if the

00:13:37.730 --> 00:13:39.890
browser supports FlexBox.

00:13:39.890 --> 00:13:42.370
So that's how you would do
anding, nodding, and or-ing or

00:13:42.370 --> 00:13:44.065
test for a bunch of
vendor prefixes.

00:13:46.730 --> 00:13:50.690
So the takeaway here is that we
can reduce, possibly, once

00:13:50.690 --> 00:13:53.030
this is supported across all the
browsers, we don't need a

00:13:53.030 --> 00:13:55.430
library to do this for us and
do feature detection.

00:13:55.430 --> 00:13:59.500
We can feature detect now,
natively in CSS.

00:13:59.500 --> 00:14:01.640
So this is actually pretty
good support, as well.

00:14:01.640 --> 00:14:02.980
Firefox Nightly has this.

00:14:02.980 --> 00:14:04.750
Chrome and Opera have
this. @supports.

00:14:09.510 --> 00:14:11.210
So this is a really common
thing you see

00:14:11.210 --> 00:14:12.460
all over the web.

00:14:14.600 --> 00:14:18.790
If you can't tell what's
going on here--

00:14:18.790 --> 00:14:20.040
try to play this again--

00:14:24.320 --> 00:14:25.490
If you can't tell what's going
on here, it's this thing on

00:14:25.490 --> 00:14:27.680
the left, this Nav bar.

00:14:27.680 --> 00:14:29.610
As I scroll this page,
this Nav bar kind of

00:14:29.610 --> 00:14:30.420
scrolls with the page.

00:14:30.420 --> 00:14:32.520
And at a certain point, it
stops and becomes sticky.

00:14:32.520 --> 00:14:34.435
It sticks to that position.

00:14:34.435 --> 00:14:36.090
So that's really great
for navigation.

00:14:36.090 --> 00:14:38.180
And then, when I come back past
that threshold again, it

00:14:38.180 --> 00:14:40.390
starts to be position-relative.

00:14:40.390 --> 00:14:41.020
And this is great.

00:14:41.020 --> 00:14:42.150
This is a really common
thing to do.

00:14:42.150 --> 00:14:43.480
The internet is littered
with this now.

00:14:43.480 --> 00:14:45.540
You have Google News, which
was that example

00:14:45.540 --> 00:14:47.400
I just showed you.

00:14:47.400 --> 00:14:49.230
Yelp, on their map results,
has this.

00:14:49.230 --> 00:14:52.340
their map follows you as
you scroll the page.

00:14:52.340 --> 00:14:54.230
I think TechCrunch used to have
this on their header.

00:14:54.230 --> 00:14:55.600
So super common,
blogs do this.

00:14:55.600 --> 00:14:56.650
Everybody's doing this.

00:14:56.650 --> 00:14:57.640
And the way you do it
is really easy.

00:14:57.640 --> 00:14:59.550
It's with some JavaScript.

00:14:59.550 --> 00:15:02.060
So you find a position
fixed class that you

00:15:02.060 --> 00:15:04.600
can apply in CSS.

00:15:04.600 --> 00:15:05.460
Give a position fixed.

00:15:05.460 --> 00:15:09.070
I want to tell it to stick to
zero pixels from the top.

00:15:09.070 --> 00:15:10.490
And give it a width of 100%.

00:15:10.490 --> 00:15:13.800
So this banner is just going to
span the entire top of the

00:15:13.800 --> 00:15:15.270
presentation.

00:15:15.270 --> 00:15:18.260
And what you do is you set up
a JavaScript Scroll Handler.

00:15:18.260 --> 00:15:21.350
So you get that initial offset
of that element you want to

00:15:21.350 --> 00:15:24.080
tell to stick at a certain
location, and then you set up

00:15:24.080 --> 00:15:26.170
a scroll handler that basically
detects, have I

00:15:26.170 --> 00:15:27.680
passed that initial offset?

00:15:27.680 --> 00:15:30.400
If I have, apply that
position sticky

00:15:30.400 --> 00:15:32.170
class, that fixed class.

00:15:32.170 --> 00:15:34.700
And then when I come back
down, this, of course

00:15:34.700 --> 00:15:35.790
condition won't be
true anymore.

00:15:35.790 --> 00:15:36.860
And then you just remove
that class.

00:15:36.860 --> 00:15:40.870
It becomes position static or
whatever it was before.

00:15:40.870 --> 00:15:42.190
So that's super handy.

00:15:42.190 --> 00:15:45.270
But actually, a really cool new
way to do this is to use

00:15:45.270 --> 00:15:46.040
position sticky.

00:15:46.040 --> 00:15:47.790
And this is actually one of the
only features I'm talking

00:15:47.790 --> 00:15:49.280
about today that doesn't
have a spec.

00:15:49.280 --> 00:15:50.030
It landed in WebKit.

00:15:50.030 --> 00:15:51.950
It's super awesome,
super handy.

00:15:51.950 --> 00:15:53.400
Because without any JavaScript,
we can have the

00:15:53.400 --> 00:15:55.020
exact same functionality.

00:15:55.020 --> 00:15:55.816
So I really hope it's

00:15:55.816 --> 00:15:58.670
implemented soon in all browsers.

00:15:58.670 --> 00:16:00.750
FYI, you can enable
this, as well, in

00:16:00.750 --> 00:16:02.950
Chrome using About Flags.

00:16:02.950 --> 00:16:06.300
So I can set up a class,
position sticky, vendor

00:16:06.300 --> 00:16:07.940
prefix, WebKit sticky.

00:16:07.940 --> 00:16:10.370
I can say, 10 pixels from the
top, that's where you're going

00:16:10.370 --> 00:16:11.340
to do your sticking.

00:16:11.340 --> 00:16:13.870
Totally cool, no JavaScript
whatsoever.

00:16:13.870 --> 00:16:17.840
So if that doesn't make sense
to you, let me show you a

00:16:17.840 --> 00:16:19.090
quick demo.

00:16:22.840 --> 00:16:27.000
So these blue bars running
across my blog posts here are

00:16:27.000 --> 00:16:28.180
just h tags.

00:16:28.180 --> 00:16:30.630
And they have position
sticky on them.

00:16:30.630 --> 00:16:32.900
And so, without any JavaScript,
I can tell them to

00:16:32.900 --> 00:16:35.860
stick it 10 pixels from the
top as I scroll this page.

00:16:35.860 --> 00:16:38.500
But what's really cool about
this is that, once their

00:16:38.500 --> 00:16:41.130
parent goes off the Viewport,
off the screen, they'll also

00:16:41.130 --> 00:16:42.240
go off the screen.

00:16:42.240 --> 00:16:44.255
So this is a really common
UI pattern that

00:16:44.255 --> 00:16:44.910
you're seeing now.

00:16:44.910 --> 00:16:47.820
I think Gmail does this, the
native app, at least.

00:16:47.820 --> 00:16:48.520
And this is really great.

00:16:48.520 --> 00:16:51.510
Because the browser
can optimize the

00:16:51.510 --> 00:16:52.910
snot out of this page.

00:16:52.910 --> 00:16:55.660
Let me pump this up a little
so I can scroll way more.

00:16:55.660 --> 00:16:59.810
It can optimize the snot out of
this page and put scrolling

00:16:59.810 --> 00:17:02.310
on the GPU, do all kinds of
crazy cool compositing things

00:17:02.310 --> 00:17:04.569
like the previous talk
talked about.

00:17:04.569 --> 00:17:05.760
And I don't have to
touch JavaScript.

00:17:05.760 --> 00:17:08.170
I don't have to sort of negate
that contract and say, I'm

00:17:08.170 --> 00:17:11.650
going to be doing a bunch of
work in my scroll handlers.

00:17:11.650 --> 00:17:14.950
So it's really awesome with
run new position property.

00:17:14.950 --> 00:17:17.040
We have that functionality
without the need for

00:17:17.040 --> 00:17:18.290
JavaScript.

00:17:22.640 --> 00:17:25.680
So again, position sticky
enabled in Chrome.

00:17:25.680 --> 00:17:29.600
It's in WebKit Nightly, as well,
you can play with that.

00:17:29.600 --> 00:17:32.555
What if I'm doing crazy things
like clipping DOM elements to

00:17:32.555 --> 00:17:35.840
crazy shapes or, like, making
interesting UIs?

00:17:35.840 --> 00:17:38.080
One thing we've had for a long
time, actually, is the CSS

00:17:38.080 --> 00:17:39.120
clip property.

00:17:39.120 --> 00:17:42.580
And so, with clip, I could say
any DOM image, div, whatever

00:17:42.580 --> 00:17:45.940
you have, clip yourself
to be a rectangle.

00:17:45.940 --> 00:17:47.780
So that's what I'm doing here
on this image, just clipping

00:17:47.780 --> 00:17:50.030
it to be some rectangle shape.

00:17:50.030 --> 00:17:52.930
There's actually some really
crazy limitations with this.

00:17:52.930 --> 00:17:55.810
First is that Clip only
supports rectangles.

00:17:55.810 --> 00:17:57.040
I can't do anything
more complex.

00:17:57.040 --> 00:17:57.970
I can't be circles.

00:17:57.970 --> 00:17:59.420
I can't do polygons.

00:17:59.420 --> 00:18:02.180
So that's pretty limiting
in and of itself.

00:18:02.180 --> 00:18:04.530
But the more, I think,
restrictive thing is that the

00:18:04.530 --> 00:18:06.640
element has to be position
absolute.

00:18:06.640 --> 00:18:12.450
So if we're talking about,
again, responsive design, not

00:18:12.450 --> 00:18:14.400
everybody's doing absolute
layouts anymore.

00:18:14.400 --> 00:18:18.990
So super limiting, what you
can do with CSS Clip.

00:18:18.990 --> 00:18:20.950
But what we have now is sort
of an awesome new way.

00:18:20.950 --> 00:18:22.490
And this is Clip path.

00:18:22.490 --> 00:18:23.630
So don't get confused.

00:18:23.630 --> 00:18:25.880
Clip path is different
than Clip.

00:18:25.880 --> 00:18:28.080
But this is great because it
removes the requirements of

00:18:28.080 --> 00:18:30.710
Clip, which are that the element
doesn't have to be

00:18:30.710 --> 00:18:31.840
position absolute anymore.

00:18:31.840 --> 00:18:32.660
So that's great.

00:18:32.660 --> 00:18:35.070
Can be position relative,
whatever.

00:18:35.070 --> 00:18:37.730
So that's the first thing
it gets rid of.

00:18:37.730 --> 00:18:40.660
And the second thing is that you
can use any basic shape in

00:18:40.660 --> 00:18:43.700
the CSS or SVG exclusions
specifications.

00:18:43.700 --> 00:18:45.790
So we're talking circles, we're
talking polygons, we're

00:18:45.790 --> 00:18:47.130
talking whatever.

00:18:47.130 --> 00:18:51.080
Whatever you want, you can Clip
DOM to that Clip path.

00:18:51.080 --> 00:18:53.620
And you can also specify
a more complex shape.

00:18:53.620 --> 00:18:55.420
So it doesn't have to be
just a basic shape.

00:18:55.420 --> 00:18:58.826
It can be-- you can reference
an ID of an SVG Clip path.

00:18:58.826 --> 00:19:01.030
And I'll show you that
in just a second.

00:19:01.030 --> 00:19:03.840
So again, vendor prefixed, Clip
path, I can Clip any type

00:19:03.840 --> 00:19:05.300
of DOM to whatever I want now.

00:19:05.300 --> 00:19:07.970
In this case, I'm clipping
just a section of div.

00:19:07.970 --> 00:19:09.610
Just some text to a circle.

00:19:09.610 --> 00:19:14.080
And I can have a little CSS
transition as I do that.

00:19:14.080 --> 00:19:16.080
I can use crazy CSS
animations.

00:19:16.080 --> 00:19:17.980
And then do a star effect.

00:19:17.980 --> 00:19:19.290
I don't know if you want
this on your website.

00:19:19.290 --> 00:19:23.350
But it's still pretty cool
that I can do that.

00:19:23.350 --> 00:19:25.090
And this here, the one
all the way to the

00:19:25.090 --> 00:19:26.360
right, it's just a list.

00:19:26.360 --> 00:19:27.910
It's a bulleted list.

00:19:27.910 --> 00:19:29.970
And it's got a little Clip
path polygon on top.

00:19:29.970 --> 00:19:32.630
So it's kind of a cool
tape cutter effect.

00:19:32.630 --> 00:19:34.105
And so again, any
type of DOM--

00:19:38.220 --> 00:19:41.560
I'm just going to go to HTML5
Rocks here, real quick.

00:19:41.560 --> 00:19:45.620
And I have this bookmark here.

00:19:45.620 --> 00:19:48.880
So when I do this, it's going
to add a CSS Clip path as a

00:19:48.880 --> 00:19:52.510
circle to the entire container
of the content.

00:19:52.510 --> 00:19:54.320
And see, it's kind of this
cool little [SINGING]

00:19:54.320 --> 00:19:56.120
"doo doo,doo doo" James
Bond effect.

00:20:01.480 --> 00:20:03.270
But really, I think this
is kind of cool.

00:20:03.270 --> 00:20:04.330
We haven't been able
to do this before.

00:20:04.330 --> 00:20:06.530
Clipping DOM to different
shapes.

00:20:06.530 --> 00:20:08.170
Again, not just regular
shapes.

00:20:08.170 --> 00:20:11.850
You can do more complex things
like reference a

00:20:11.850 --> 00:20:13.130
Clip path in SVG.

00:20:13.130 --> 00:20:16.240
So I have a defined Clip
path in my SVG.

00:20:16.240 --> 00:20:18.620
Inlined SVG to me document.

00:20:18.620 --> 00:20:21.460
I can use Clip path and
reference a URL.

00:20:21.460 --> 00:20:24.570
It's ID by URL here
at the top.

00:20:24.570 --> 00:20:26.520
And so what I get for
this is crazy

00:20:26.520 --> 00:20:27.600
modern art, or something.

00:20:27.600 --> 00:20:30.370
I'm clipping an image with some
interesting polygons.

00:20:30.370 --> 00:20:31.940
I don't know what's
going on there.

00:20:31.940 --> 00:20:33.930
But again, it's not
just images.

00:20:33.930 --> 00:20:34.690
It's any DOM.

00:20:34.690 --> 00:20:37.260
So this is text that's being
clipped to that same

00:20:37.260 --> 00:20:40.160
reference Clip path.

00:20:40.160 --> 00:20:42.870
Very cool stuff.

00:20:42.870 --> 00:20:43.940
So this one--

00:20:43.940 --> 00:20:45.450
Safari, Firefox.

00:20:45.450 --> 00:20:47.780
Chrome, and a couple mobile
browsers, as well.

00:20:47.780 --> 00:20:51.720
You can play with this
today, clip-path.

00:20:51.720 --> 00:20:53.430
All right, so that was a
crash course in CSS.

00:20:53.430 --> 00:20:56.750
There's plenty we could cover,
as I alluded to before.

00:20:56.750 --> 00:20:57.930
But I want to switch
to multimedia.

00:20:57.930 --> 00:20:59.670
Because I think there's a lot
of really, really awesome

00:20:59.670 --> 00:21:02.240
stuff coming to the browser
space [INAUDIBLE]

00:21:02.240 --> 00:21:04.310
multimedia.

00:21:04.310 --> 00:21:05.750
First is screen sharing.

00:21:05.750 --> 00:21:07.330
So actually, I wrote
an article about

00:21:07.330 --> 00:21:08.730
this on HTML5 Rocks.

00:21:08.730 --> 00:21:10.330
I might've talked about
this a little bit last

00:21:10.330 --> 00:21:11.400
year using a WebSocket.

00:21:11.400 --> 00:21:14.570
You can do crazy hacks, you
can do screen sharing.

00:21:14.570 --> 00:21:17.300
But, actually, what we have now
is the ability to proper

00:21:17.300 --> 00:21:19.060
screen sharing with WebRTC.

00:21:19.060 --> 00:21:23.560
So this is an extension to
the WebRTC specification.

00:21:23.560 --> 00:21:26.880
And so, instead of getting user
media, instead of getting

00:21:26.880 --> 00:21:30.830
camera or microphone data, I'm
going to say my mandatory--

00:21:30.830 --> 00:21:32.340
the thing that I want
to access to--

00:21:32.340 --> 00:21:33.240
sort of giving a Boolean--

00:21:33.240 --> 00:21:36.010
giving it an object describing
I want a Chrome media source

00:21:36.010 --> 00:21:36.980
and set that to screen.

00:21:36.980 --> 00:21:39.910
So my source now is not my
camera or mic, it's the

00:21:39.910 --> 00:21:41.160
desktop screen.

00:21:46.250 --> 00:21:49.450
So a quick demo of that is, once
I click this button, it's

00:21:49.450 --> 00:21:50.530
going to get user media.

00:21:50.530 --> 00:21:53.210
It's going to create
that call.

00:21:53.210 --> 00:21:54.480
I'm going to say, yes
I wrote this app.

00:21:54.480 --> 00:21:58.770
I trust it And when I do,
what I get is sort of

00:21:58.770 --> 00:22:00.260
an Inception effect.

00:22:00.260 --> 00:22:03.240
So this is sharing, again,
not just my tab, but

00:22:03.240 --> 00:22:04.370
it's my whole desktop.

00:22:04.370 --> 00:22:06.110
And so you can imagine--

00:22:06.110 --> 00:22:08.080
Google Hangouts, for instance,
uses a plug-in to this.

00:22:08.080 --> 00:22:10.330
You can easily do something
with WebRTC now

00:22:10.330 --> 00:22:11.840
that this is available.

00:22:11.840 --> 00:22:12.460
Very, very cool.

00:22:12.460 --> 00:22:14.350
Very inception-y.

00:22:14.350 --> 00:22:16.460
What I'm not showing you here is
the more interesting thing,

00:22:16.460 --> 00:22:20.910
which is actually sharing that
content out to other users.

00:22:20.910 --> 00:22:22.740
So I'm just rendering that
locally to a video tag,

00:22:22.740 --> 00:22:24.650
getting that stream.

00:22:24.650 --> 00:22:26.420
Switch back to the
code, real quick.

00:22:26.420 --> 00:22:28.800
So I'm getting that user
and get user media.

00:22:28.800 --> 00:22:31.840
I'm getting this stream of data
and pumping that in, just

00:22:31.840 --> 00:22:32.530
to a video tag.

00:22:32.530 --> 00:22:36.710
But you could use WebRTC data
channel API, then, to transfer

00:22:36.710 --> 00:22:38.160
that as sort of a
peer-to-peer.

00:22:38.160 --> 00:22:41.510
You can do things like remote
desktop assistance, browse the

00:22:41.510 --> 00:22:44.990
web together, friend and you
view different pages together.

00:22:44.990 --> 00:22:47.870
That's all using nothing but
open web technology thanks to

00:22:47.870 --> 00:22:51.610
WebRTC and some cool stuff
they're doing on that project.

00:22:56.320 --> 00:22:57.250
So this one, you
can enable it.

00:22:57.250 --> 00:22:59.330
It's still behind a flag,
at least in Chrome.

00:22:59.330 --> 00:23:02.890
You can enable Screen Capture
Support and Get User Media.

00:23:02.890 --> 00:23:12.160
That's in Chrome 26.

00:23:12.160 --> 00:23:12.810
[INAUDIBLE]

00:23:12.810 --> 00:23:13.410
Web Audio.

00:23:13.410 --> 00:23:15.220
There's been a couple
talks last year on

00:23:15.220 --> 00:23:16.290
the web audio API.

00:23:16.290 --> 00:23:19.030
But we didn't have at the time
was the ability to do anything

00:23:19.030 --> 00:23:21.450
really, really interesting
with it.

00:23:21.450 --> 00:23:22.770
And what I mean by
that is that you

00:23:22.770 --> 00:23:24.590
can combine the WebRTC.

00:23:24.590 --> 00:23:25.560
Get User Media, right?

00:23:25.560 --> 00:23:27.640
Get access to live
microphone data.

00:23:27.640 --> 00:23:29.130
And you can combine that
with web audio.

00:23:29.130 --> 00:23:33.270
You can do real time processing
and analyzing of

00:23:33.270 --> 00:23:35.750
microphone input into the
laptop using nothing

00:23:35.750 --> 00:23:37.360
but open web tech.

00:23:37.360 --> 00:23:38.720
So this is one of my
favorites, because

00:23:38.720 --> 00:23:39.860
it really is great.

00:23:39.860 --> 00:23:43.460
Because it illustrates how a lot
of-- at least two of these

00:23:43.460 --> 00:23:45.670
new APIs are talking together.

00:23:45.670 --> 00:23:47.290
So we have Get User Media.

00:23:47.290 --> 00:23:49.660
We have access to the
microphone data.

00:23:49.660 --> 00:23:50.620
Vendor prefixed.

00:23:50.620 --> 00:23:54.410
Once we get the stream, we'll
create our Web Audio context

00:23:54.410 --> 00:23:56.030
but we won't give
it an MP3 file.

00:23:56.030 --> 00:23:58.390
We won't give it an audio
file to play.

00:23:58.390 --> 00:24:00.100
We'll Create Media
Stream Source.

00:24:00.100 --> 00:24:02.690
So we'll passed that microphone
data right to the

00:24:02.690 --> 00:24:03.870
Web Audio API.

00:24:03.870 --> 00:24:06.500
And then we can use that API
to do real time processing,

00:24:06.500 --> 00:24:08.430
effects, filters.

00:24:08.430 --> 00:24:10.540
So that's really awesome.

00:24:10.540 --> 00:24:12.310
Let me just show you a
quick demo of this.

00:24:12.310 --> 00:24:14.420
This is a demo I did a
couple of years back.

00:24:14.420 --> 00:24:15.670
But now--

00:24:21.510 --> 00:24:22.760
Good afternoon.

00:24:27.240 --> 00:24:30.700
So you can see, as I talk,
there's a canvas tag that's

00:24:30.700 --> 00:24:32.890
doing the real time analysis
of the voice.

00:24:32.890 --> 00:24:36.020
Get User Media is giving me
access to the microphone and

00:24:36.020 --> 00:24:39.380
we're pumping that in to
the Web Audio API.

00:24:39.380 --> 00:24:40.190
Very, very cool.

00:24:40.190 --> 00:24:42.180
It allows you to do some
very interesting thing.

00:24:42.180 --> 00:24:43.430
Not just visualize your voice.

00:24:53.930 --> 00:24:55.555
But you can do things
like record--

00:24:58.120 --> 00:25:00.530
So this is just a visualization
of my voice as I

00:25:00.530 --> 00:25:02.360
talk in this second mic, here.

00:25:02.360 --> 00:25:04.400
But using nothing but
client-side technologies--

00:25:04.400 --> 00:25:06.430
I think it's Recorder JS--

00:25:06.430 --> 00:25:08.890
you can record your voice, get
that data from the Web Audio

00:25:08.890 --> 00:25:13.305
API, and then get the spectrum
data, download the wave file

00:25:13.305 --> 00:25:14.590
of the thing I just recorded.

00:25:14.590 --> 00:25:15.660
So really, really cool.

00:25:15.660 --> 00:25:17.150
No servers involved
whatsoever.

00:25:17.150 --> 00:25:20.095
It's all thanks to WebRTC
Get User Media and

00:25:20.095 --> 00:25:21.345
the Web Audio API.

00:25:25.780 --> 00:25:27.210
So what's even cooler
is actually--

00:25:30.720 --> 00:25:31.970
it's not just microphone,
right?

00:25:35.470 --> 00:25:38.570
Get User Media is for
any type of device.

00:25:38.570 --> 00:25:40.450
I want to see if this works,
here, you guys.

00:25:40.450 --> 00:25:41.700
Bear with.

00:25:56.950 --> 00:25:58.800
It'll be a test of
my guitar skills.

00:26:21.180 --> 00:26:24.456
[PLAYING GUITAR]

00:26:24.456 --> 00:26:26.740
Let's do a cool effect,
like distortion.

00:26:26.740 --> 00:26:27.830
That's a great guitar
distortion.

00:26:27.830 --> 00:26:29.680
So Web Audio API--

00:26:29.680 --> 00:26:30.900
so I don't have a
pedal up here.

00:26:30.900 --> 00:26:32.280
This is just basically
microphone

00:26:32.280 --> 00:26:34.030
input to a web page.

00:26:34.030 --> 00:26:35.440
So I can play guitar
into a web page.

00:26:35.440 --> 00:26:36.360
I can tune my guitar.

00:26:36.360 --> 00:26:40.386
I can apply distortion
effects in real time.

00:26:40.386 --> 00:26:52.980
[PLAYING GUITAR]

00:26:52.980 --> 00:26:54.580
What else you can do
with this API.

00:26:54.580 --> 00:27:02.420
[PLAYING GUITAR]

00:27:02.420 --> 00:27:03.180
So that's interesting.

00:27:03.180 --> 00:27:03.520
Web Audio API.

00:27:03.520 --> 00:27:12.540
[PLAYING GUITAR]

00:27:12.540 --> 00:27:15.160
So all I have up here is a
little USB controller that I

00:27:15.160 --> 00:27:16.930
plugged the guitar into,
plugged that

00:27:16.930 --> 00:27:18.510
into my USB in laptop.

00:27:18.510 --> 00:27:21.020
And using the Web Audio API and
Get User Media, I can play

00:27:21.020 --> 00:27:23.200
guitar and even tune.

00:27:23.200 --> 00:27:24.450
Let's see if this
one will work.

00:27:27.057 --> 00:27:30.860
I don't have it, Sorry
Took it off.

00:27:30.860 --> 00:27:31.900
Very, very cool.

00:27:31.900 --> 00:27:37.280
Really awesome examples of new
web tech working together to

00:27:37.280 --> 00:27:38.510
do some interesting things
we could never

00:27:38.510 --> 00:27:39.760
do on the web before.

00:27:43.120 --> 00:27:46.980
So live input to Web Audio API
is available in Chrome.

00:27:46.980 --> 00:27:49.660
Firefox, actually just has
a Web Audio API coming.

00:27:49.660 --> 00:27:51.340
I believe they enabled
it by default in

00:27:51.340 --> 00:27:52.040
their nightly build.

00:27:52.040 --> 00:27:54.790
So I really, really hope this
comes to other browsers very

00:27:54.790 --> 00:27:55.670
soon, implement the
Web Audio API.

00:27:55.670 --> 00:27:57.470
I think it's super,
super awesome.

00:27:57.470 --> 00:28:00.660
Real time processing effects
using mic input.

00:28:00.660 --> 00:28:03.270
You can imagine sending that
across the wire using WebRTC

00:28:03.270 --> 00:28:04.960
to do karaoke or something.

00:28:04.960 --> 00:28:07.800
[? Audio ?] tune in the
browser, it's here.

00:28:07.800 --> 00:28:10.450
Super, super cool.

00:28:10.450 --> 00:28:11.700
[INAUDIBLE]

00:28:16.300 --> 00:28:20.370
So you remember from the
keynote, you saw Google Now

00:28:20.370 --> 00:28:23.270
sort of living on the web.

00:28:23.270 --> 00:28:24.150
Can we do that?

00:28:24.150 --> 00:28:26.680
With all this access to the
microphone data and these

00:28:26.680 --> 00:28:28.410
extra devices, can we do
that in websites now.

00:28:28.410 --> 00:28:31.640
And the answer is, sure,
we can do this.

00:28:31.640 --> 00:28:32.470
There's a new API.

00:28:32.470 --> 00:28:34.680
It's called the Web
Speech API.

00:28:34.680 --> 00:28:37.320
It allows you to do speech
recognition and voice

00:28:37.320 --> 00:28:39.250
synthesis in the web browser.

00:28:39.250 --> 00:28:42.720
And so you can set up the speech
recognition object.

00:28:42.720 --> 00:28:45.170
You can say, hey, I want my
results to be continuous.

00:28:45.170 --> 00:28:46.990
I can continued to talk
in the microphone.

00:28:46.990 --> 00:28:48.110
The user can talk.

00:28:48.110 --> 00:28:50.170
And you can process
results for me.

00:28:50.170 --> 00:28:52.580
I can set up in-term
results if I want.

00:28:52.580 --> 00:28:55.930
So as the user talks, new
results are being thrown back

00:28:55.930 --> 00:28:57.850
at me and they're
being redefined.

00:28:57.850 --> 00:28:59.530
I get that information.

00:28:59.530 --> 00:29:00.570
And then you set up events
for all this.

00:29:00.570 --> 00:29:03.230
So there's error events,
result events.

00:29:03.230 --> 00:29:07.040
In this case, on a result, all
I want to do is a rip out the

00:29:07.040 --> 00:29:10.030
last result was filled in my
results array and then pull

00:29:10.030 --> 00:29:10.900
out the transcript.

00:29:10.900 --> 00:29:13.970
So this is how I get the
speech-to-text from the server

00:29:13.970 --> 00:29:15.220
that this is talking to.

00:29:18.560 --> 00:29:20.948
So let get this mic back up.

00:29:39.520 --> 00:29:41.096
Testing, testing.

00:29:53.490 --> 00:29:54.740
Testing, testing.

00:30:06.210 --> 00:30:07.460
Testing.

00:30:11.830 --> 00:30:12.470
OK.

00:30:12.470 --> 00:30:14.750
I'll use good tried and true.

00:30:14.750 --> 00:30:17.272
I can use just the
Mac's input.

00:30:29.470 --> 00:30:31.740
Testing, testing.

00:30:31.740 --> 00:30:33.370
So I can talk into
this application.

00:30:33.370 --> 00:30:34.620
It's just a web app.

00:30:34.620 --> 00:30:37.810
It's a web speech API to do
continuous dictation.

00:30:37.810 --> 00:30:40.560
I can type an email
with no hands.

00:30:40.560 --> 00:30:41.380
So this is great.

00:30:41.380 --> 00:30:42.560
It's continuous playback.

00:30:42.560 --> 00:30:44.730
You can see the results
as they come in.

00:30:44.730 --> 00:30:47.060
Hopefully it's not going to
say anything naughty.

00:30:47.060 --> 00:30:48.910
As they're being processed by
the server, they're coming in.

00:30:48.910 --> 00:30:50.132
They're being redefined.

00:30:50.132 --> 00:30:54.750
[LAUGHTER]

00:30:54.750 --> 00:30:56.630
Apparently I just said "nutty
professor." 1910.

00:30:56.630 --> 00:31:02.540
We're not in 1910 anymore.

00:31:02.540 --> 00:31:05.140
But this allows for more
than just dedication.

00:31:05.140 --> 00:31:06.960
We can do some really
interesting things with other

00:31:06.960 --> 00:31:09.110
server-side and APIs
to talk to.

00:31:15.540 --> 00:31:17.220
I don't know how to speak
in Spanish, but I hope

00:31:17.220 --> 00:31:18.470
someone here does.

00:31:21.930 --> 00:31:28.590
[COMPUTER SPEAKING SPANISH]

00:31:28.590 --> 00:31:29.840
ERIC BIDELMAN: Italian sounds
very beautiful.

00:31:32.530 --> 00:31:38.190
[COMPUTER SPEAKING ITALIAN]

00:31:38.190 --> 00:31:42.070
ERIC BIDELMAN: English doesn't
sound quite as good, does it?

00:31:42.070 --> 00:31:46.690
English doesn't sound quite
as good, does it.

00:31:46.690 --> 00:31:50.330
So that's voice dictation
using the translate API.

00:31:50.330 --> 00:31:51.650
But what about Star Trek?

00:31:51.650 --> 00:31:52.800
Can we do Star Trek?

00:31:52.800 --> 00:31:54.050
Sure we can.

00:31:56.210 --> 00:31:57.460
Presentation.

00:31:59.620 --> 00:32:01.700
Yes, how can I help you?

00:32:01.700 --> 00:32:02.950
ERIC BIDELMAN: Go backward.

00:32:05.770 --> 00:32:07.020
Go forward.

00:32:10.420 --> 00:32:11.670
Open google.com.

00:32:14.566 --> 00:32:15.816
Close it.

00:32:18.260 --> 00:32:18.740
Google

00:32:18.740 --> 00:32:24.610
"Paul Irish." [LAUGHTER]

00:32:24.610 --> 00:32:25.860
Close it.

00:32:28.970 --> 00:32:30.220
Make me a sandwich.

00:32:32.680 --> 00:32:34.830
Do it yourself.

00:32:34.830 --> 00:32:36.245
ERIC BIDELMAN: Please
make me a sandwich.

00:32:41.100 --> 00:32:43.250
You're getting warmer

00:32:43.250 --> 00:32:45.310
ERIC BIDELMAN: Pseudo
make me a sandwich.

00:32:49.340 --> 00:32:50.930
You said the magic word.

00:32:50.930 --> 00:32:52.430
How about PB&amp;J?

00:32:52.430 --> 00:32:53.840
ERIC BIDELMAN: Yeah.

00:32:53.840 --> 00:33:00.110
[APPLAUSE]

00:33:00.110 --> 00:33:00.590
[? Quiet ?]

00:33:00.590 --> 00:33:00.790
[? her ?]

00:33:00.790 --> 00:33:01.380
[? up. ?]

00:33:01.380 --> 00:33:05.260
So that's using nothing but
the Web Speech API and web

00:33:05.260 --> 00:33:06.060
technologies.

00:33:06.060 --> 00:33:07.900
No plug-ins whatsoever.

00:33:07.900 --> 00:33:09.270
Very, very cool stuff.

00:33:09.270 --> 00:33:11.120
Available in Chrome today.

00:33:11.120 --> 00:33:12.240
We talked about a lot.

00:33:12.240 --> 00:33:13.750
So I have about four
minutes left.

00:33:13.750 --> 00:33:15.990
I can't cover the entire
web platform.

00:33:15.990 --> 00:33:19.090
But we talked about feature
detection, CSS, new units,

00:33:19.090 --> 00:33:22.020
responsive design.

00:33:22.020 --> 00:33:24.910
CSS variables after, 15 years or
something, they're finally

00:33:24.910 --> 00:33:26.510
like thing you could
start to play with.

00:33:26.510 --> 00:33:29.980
Position sticky for doing
position-fixed elements that

00:33:29.980 --> 00:33:32.130
are really easy without
JavaScript.

00:33:32.130 --> 00:33:34.380
Live input for not only a
microphone, but different

00:33:34.380 --> 00:33:36.280
types of devices, to
the Web Audio API.

00:33:36.280 --> 00:33:37.900
Screen sharing.

00:33:37.900 --> 00:33:39.310
Web Speech API.

00:33:39.310 --> 00:33:42.260
And there's plenty, plenty
to look forward to.

00:33:42.260 --> 00:33:44.540
Things like CSS grid layout I'm
really excited about being

00:33:44.540 --> 00:33:46.080
able to find sort of a
grid system for your

00:33:46.080 --> 00:33:47.230
page or your app.

00:33:47.230 --> 00:33:48.010
Web Components.

00:33:48.010 --> 00:33:49.140
There's two sessions on this.

00:33:49.140 --> 00:33:50.430
Amazing, amazing stuff
you can do.

00:33:50.430 --> 00:33:52.490
It's going to fundamentally,
I think, change the way we

00:33:52.490 --> 00:33:54.120
develop applications.

00:33:54.120 --> 00:33:55.110
WebRTC in mobile.

00:33:55.110 --> 00:33:59.100
Video conferencing on a phone
using nothing but web tech.

00:33:59.100 --> 00:34:00.600
And there's some other
cool things, too.

00:34:00.600 --> 00:34:02.770
Blink has proposed some
interesting ideas, such as

00:34:02.770 --> 00:34:03.690
Lazy block layout.

00:34:03.690 --> 00:34:06.450
This is infinite scroll lists
that are really easy.

00:34:06.450 --> 00:34:08.130
This is very hard to
do in JavaScript.

00:34:08.130 --> 00:34:10.620
There's been a lot of smart
people on this.

00:34:10.620 --> 00:34:12.449
They're proposing an
API to do this.

00:34:12.449 --> 00:34:15.309
DOM attributes in JavaScript
make everyone's app faster.

00:34:15.309 --> 00:34:17.429
So there's plenty
look forward to.

00:34:17.429 --> 00:34:18.429
I want to point out,
if you want to

00:34:18.429 --> 00:34:20.110
follow things in Chrome.

00:34:20.110 --> 00:34:22.080
We're trying to track
this really, really

00:34:22.080 --> 00:34:23.429
aggressively now.

00:34:23.429 --> 00:34:26.400
There's these Blink Intend to
Implement emails that are sent

00:34:26.400 --> 00:34:27.540
out to Blink Dev.

00:34:27.540 --> 00:34:30.260
And you can follow the lay of
the land where everything is

00:34:30.260 --> 00:34:32.830
in flight on all these new
features, if you want to stay

00:34:32.830 --> 00:34:36.050
up to date, or six months ahead,
of where things are

00:34:36.050 --> 00:34:37.750
implemented.

00:34:37.750 --> 00:34:38.900
So that's really great.

00:34:38.900 --> 00:34:40.130
Turn to HTML5 Rocks.

00:34:40.130 --> 00:34:41.929
My team helps write
articles for that.

00:34:41.929 --> 00:34:43.639
We try to cover some of
this new stuff so you

00:34:43.639 --> 00:34:45.159
can learn about it.

00:34:45.159 --> 00:34:46.520
I'm going to plug Chrome
Status again.

00:34:46.520 --> 00:34:47.270
It's not just Chrome.

00:34:47.270 --> 00:34:49.020
We're trying to do this for all
browser vendors and sort

00:34:49.020 --> 00:34:50.650
of get the lay of the land.

00:34:50.650 --> 00:34:51.600
So you can follow things.

00:34:51.600 --> 00:34:52.230
There's bugs.

00:34:52.230 --> 00:34:53.230
There's version numbers.

00:34:53.230 --> 00:34:55.889
It's really, really handy.

00:34:55.889 --> 00:34:57.280
So I really appreciate
you guys' time.

00:34:57.280 --> 00:34:59.420
Thank you for everyone tuning
into live stream.

00:34:59.420 --> 00:35:01.970
This presentation's going to be
up at moreawesomeweb.com.

00:35:01.970 --> 00:35:05.230
I might not have enough time for
questions here, but feel

00:35:05.230 --> 00:35:08.052
free to hit me up in Office
Hours or visit me on one of

00:35:08.052 --> 00:35:09.320
those social channels, there.

00:35:09.320 --> 00:35:09.890
Thank you, guys.

00:35:09.890 --> 00:35:11.140
Really appreciate it.

