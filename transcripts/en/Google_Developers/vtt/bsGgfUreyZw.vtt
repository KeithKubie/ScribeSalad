WEBVTT
Kind: captions
Language: en

00:00:01.280 --> 00:00:01.520
LARS BAK: Hello.

00:00:01.520 --> 00:00:03.225
Welcome, everybody.

00:00:03.225 --> 00:00:03.610
Oh.

00:00:03.610 --> 00:00:04.880
They fixed the sound.

00:00:04.880 --> 00:00:05.820
Great.

00:00:05.820 --> 00:00:08.380
So welcome to the Dart,
a modern web language

00:00:08.380 --> 00:00:09.410
presentation.

00:00:09.410 --> 00:00:11.530
This is the first ever
presentation about

00:00:11.530 --> 00:00:13.310
Dart at Google IO.

00:00:13.310 --> 00:00:15.260
And I'm here.

00:00:15.260 --> 00:00:18.680
I'm Lars Bak with Kaspar Lund,
coming all the way from

00:00:18.680 --> 00:00:20.200
Denmark to present Dart.

00:00:23.300 --> 00:00:26.050
I can just say right away, we
will not be doing any base

00:00:26.050 --> 00:00:29.270
jumping nor stage diving.

00:00:29.270 --> 00:00:30.975
This will be fairly boring
in that respect.

00:00:33.480 --> 00:00:36.260
What I can tell you about is
about this new programming

00:00:36.260 --> 00:00:38.780
language we have been working
on for a year.

00:00:38.780 --> 00:00:41.550
And this presentation will
include a few things.

00:00:41.550 --> 00:00:45.190
We'll talk about the
motivation for it.

00:00:45.190 --> 00:00:49.990
And part of the motivation
is our work on V8.

00:00:49.990 --> 00:00:53.790
Kasper and I have been working
on V8 for many years, I guess.

00:00:53.790 --> 00:00:54.810
Four or so?

00:00:54.810 --> 00:00:55.630
KASPER LUND: Four years, yeah.

00:00:55.630 --> 00:00:56.260
LARS BAK: Four years.

00:00:56.260 --> 00:01:00.050
And some of the experience
with JavaScript

00:01:00.050 --> 00:01:02.820
has led us to Dart.

00:01:02.820 --> 00:01:04.550
We'll be talking about
the basic language.

00:01:04.550 --> 00:01:08.000
We'll be talking about some of
the components we have in the

00:01:08.000 --> 00:01:08.780
Dart project.

00:01:08.780 --> 00:01:11.900
And then we'll talk about the
bright future we hopefully

00:01:11.900 --> 00:01:12.930
have with Dart.

00:01:12.930 --> 00:01:14.555
So let's get started.

00:01:14.555 --> 00:01:19.100
We have a lot of interesting
stuff to talk about.

00:01:19.100 --> 00:01:22.950
So our background is in
implementing virtual machines.

00:01:22.950 --> 00:01:28.030
And as you probably can see,
I'm the oldest one.

00:01:28.030 --> 00:01:29.400
He's the younger version.

00:01:29.400 --> 00:01:33.000
I've been doing VMs for 26
years, and Kasper's been doing

00:01:33.000 --> 00:01:34.360
it for the last 12.

00:01:34.360 --> 00:01:36.830
We've worked together
on many projects.

00:01:36.830 --> 00:01:40.780
We've been doing Java,
virtual machines.

00:01:40.780 --> 00:01:43.140
Also JavaScript engines,
like V8.

00:01:43.140 --> 00:01:45.650
And that's been pretty cool.

00:01:45.650 --> 00:01:47.980
So this is our first project
ever where we've been

00:01:47.980 --> 00:01:50.160
designing a programming
language.

00:01:50.160 --> 00:01:53.530
KASPER LUND: Before I joined
Lars on this mission to try to

00:01:53.530 --> 00:01:57.720
improve the performance of
virtual machines for various

00:01:57.720 --> 00:01:58.230
languages--

00:01:58.230 --> 00:02:01.685
Lars was working on more exotic
languages, too, like

00:02:01.685 --> 00:02:05.000
the Beta programming language,
sort of a Scandinavian

00:02:05.000 --> 00:02:05.960
object-oriented language.

00:02:05.960 --> 00:02:09.169
So there's a lot of experience
on the stage here.

00:02:09.169 --> 00:02:12.480
Nearly 40 years combined.

00:02:12.480 --> 00:02:16.240
So we certainly know a thing or
two about virtual machines,

00:02:16.240 --> 00:02:18.260
so hopefully we can convince
you that we know a thing or

00:02:18.260 --> 00:02:21.030
two about languages as well.

00:02:21.030 --> 00:02:23.300
LARS BAK: So first of all, there
will be a little bit of

00:02:23.300 --> 00:02:25.680
a salute to the web.

00:02:25.680 --> 00:02:28.580
We think the web is fantastic.

00:02:28.580 --> 00:02:29.580
The web is everywhere today.

00:02:29.580 --> 00:02:32.000
You have it on your
mobile phone, your

00:02:32.000 --> 00:02:33.670
pads and your desktop.

00:02:33.670 --> 00:02:36.240
So when you do an application
it can actually cover most

00:02:36.240 --> 00:02:38.300
devices today.

00:02:38.300 --> 00:02:40.260
It's also very easy to
use as a developer.

00:02:40.260 --> 00:02:43.140
You can just pop into your
favorite text editor, type in

00:02:43.140 --> 00:02:46.760
a few lines, and then you can
start it up in your browser.

00:02:46.760 --> 00:02:49.190
There's no tool chain
involved in getting

00:02:49.190 --> 00:02:51.770
the program up running.

00:02:51.770 --> 00:02:54.650
And one thing I really like
about the web, there's no

00:02:54.650 --> 00:02:56.570
required installation
of the app.

00:02:56.570 --> 00:02:59.660
Whenever you start Gmail, you
get the newest version.

00:02:59.660 --> 00:03:02.820
So you are not bothered
by these updates.

00:03:02.820 --> 00:03:05.380
I assume you all have
mobile phones?

00:03:05.380 --> 00:03:09.390
Have you tried to get bothered
by an update notification?

00:03:09.390 --> 00:03:11.320
I guess.

00:03:11.320 --> 00:03:13.860
For me, at least, that's one
of the benefits of the web.

00:03:13.860 --> 00:03:16.710
That you don't have to install
an application.

00:03:20.330 --> 00:03:23.190
Furthermore it's also a very
incremental experience, to

00:03:23.190 --> 00:03:24.560
develop for the web.

00:03:24.560 --> 00:03:27.960
You can change one line in the
program and use a refresh.

00:03:27.960 --> 00:03:30.850
So within a second, you can
have your application up

00:03:30.850 --> 00:03:31.220
running again.

00:03:31.220 --> 00:03:33.540
And that's very appealing
when you do prototype

00:03:33.540 --> 00:03:35.730
develop and so on.

00:03:35.730 --> 00:03:40.500
And one thing that's even
better, the browser industry

00:03:40.500 --> 00:03:42.760
is right now fairly
competitive.

00:03:42.760 --> 00:03:45.380
All the browser vendors, they're
competing on speed and

00:03:45.380 --> 00:03:46.600
functionality.

00:03:46.600 --> 00:03:49.180
And most implementations are
open source, so it's a

00:03:49.180 --> 00:03:50.430
friendly competition.

00:03:54.910 --> 00:03:56.980
Here's my best attempt
to make a wheel.

00:03:56.980 --> 00:04:00.250
It turned out to
be three-sided.

00:04:00.250 --> 00:04:03.800
But I'm trying to explain
the ecosystem of browser

00:04:03.800 --> 00:04:06.140
development.

00:04:06.140 --> 00:04:10.010
When you add more performance
into a browser, you will sort

00:04:10.010 --> 00:04:12.750
of enable application developers
to innovate.

00:04:12.750 --> 00:04:15.170
They can add more functionality
on the client

00:04:15.170 --> 00:04:19.120
side, and that again will
require new browser features.

00:04:19.120 --> 00:04:20.959
And so on and so forth.

00:04:20.959 --> 00:04:24.140
And this is great, because
whenever you take a turn with

00:04:24.140 --> 00:04:27.780
this wheel, the browser will be
a better place to develop

00:04:27.780 --> 00:04:29.995
applications and also
use applications.

00:04:33.570 --> 00:04:36.650
Here's a JavaScript performance
improvement chart.

00:04:36.650 --> 00:04:39.650
It'll show you the speedup
of JavaScript

00:04:39.650 --> 00:04:42.210
over the last 12 years.

00:04:42.210 --> 00:04:45.360
And as you can see, there
was a dry spell

00:04:45.360 --> 00:04:47.720
of a number of years.

00:04:47.720 --> 00:04:51.130
And then we introduced in
2008, Chrome, the beta

00:04:51.130 --> 00:04:55.360
version, where V8 was
part of that.

00:04:55.360 --> 00:05:00.530
And you can see, since 2008 the
performance of JavaScript

00:05:00.530 --> 00:05:03.150
has just improved
tremendously.

00:05:03.150 --> 00:05:08.250
In fact, JavaScript is now 100
times faster on the same

00:05:08.250 --> 00:05:12.140
hardware, compared to a browser
five years ago.

00:05:12.140 --> 00:05:14.804
That's pretty amazing,
isn't it?

00:05:14.804 --> 00:05:16.180
KASPER LUND: That's
a lot, yeah.

00:05:16.180 --> 00:05:19.310
LARS BAK: Even on mobile
devices, like an Android

00:05:19.310 --> 00:05:23.240
device, you can see that the
performance of JavaScript is

00:05:23.240 --> 00:05:26.370
comparable to a desktop
machine, when we

00:05:26.370 --> 00:05:29.440
introduced V8 in 2008.

00:05:29.440 --> 00:05:30.470
So this is pretty amazing.

00:05:30.470 --> 00:05:35.300
And it really allows you guys to
do better apps on the web.

00:05:35.300 --> 00:05:36.840
KASPER LUND: We've already seen
a few things that have

00:05:36.840 --> 00:05:41.370
come along that take advantage
of this new power.

00:05:41.370 --> 00:05:44.570
So the point with the previous
slide, where performance

00:05:44.570 --> 00:05:46.750
improvements of the core
platform really help you

00:05:46.750 --> 00:05:50.110
innovate, can be seen in one
of the latest versions of

00:05:50.110 --> 00:05:52.390
Google Maps for instance,
where you can enable

00:05:52.390 --> 00:05:55.420
client-side rendering of
things-- things that you had

00:05:55.420 --> 00:05:57.130
to do on the server side before,
it's now possible to

00:05:57.130 --> 00:05:58.510
do on the client instead.

00:05:58.510 --> 00:06:00.070
Which is pretty cool.

00:06:00.070 --> 00:06:02.720
So we certainly see that this
is already now helping a lot

00:06:02.720 --> 00:06:06.710
on what you can do and
achieve with the web.

00:06:06.710 --> 00:06:10.320
LARS BAK: So during this period
the web applications

00:06:10.320 --> 00:06:13.000
have become more and
more complex.

00:06:13.000 --> 00:06:18.930
And have posed some challenges
for the web.

00:06:18.930 --> 00:06:21.850
What we really want, we want
to have better programmer

00:06:21.850 --> 00:06:23.330
productivity.

00:06:23.330 --> 00:06:28.110
And we also want application
scalability, so that as you

00:06:28.110 --> 00:06:30.670
get bigger and bigger
applications the browser can

00:06:30.670 --> 00:06:33.080
cope with it as you
execute it.

00:06:33.080 --> 00:06:35.510
And then of course you need
raw execution speed.

00:06:35.510 --> 00:06:39.300
We've fixed some of that with
V8, but we are not hitting the

00:06:39.300 --> 00:06:41.440
glass ceiling yet.

00:06:41.440 --> 00:06:44.080
One thing that's a problem
today, at least from my point

00:06:44.080 --> 00:06:47.060
of view, is that startup
performance is not where we

00:06:47.060 --> 00:06:48.280
want it to be.

00:06:48.280 --> 00:06:51.560
When you start up a big web
app, it's fairly slow.

00:06:51.560 --> 00:06:55.690
For instance, if you take Gmail,
you have to read in a

00:06:55.690 --> 00:06:58.380
lot of source code before you
can start the application.

00:06:58.380 --> 00:07:01.410
And that sort of delays
the startup with

00:07:01.410 --> 00:07:04.530
half to a full second.

00:07:04.530 --> 00:07:08.520
So the final item on this slide
here is that if we don't

00:07:08.520 --> 00:07:13.540
innovate, the web will lose out
to mobile apps, where they

00:07:13.540 --> 00:07:16.640
can install more native
types of applications.

00:07:22.130 --> 00:07:26.000
Fortunately, we have
a solution for you.

00:07:26.000 --> 00:07:28.570
We have the Dart platform.

00:07:28.570 --> 00:07:32.550
And this is a suite of
technologies that will

00:07:32.550 --> 00:07:35.550
hopefully solve so some
of these issues with

00:07:35.550 --> 00:07:36.930
the existing platform.

00:07:36.930 --> 00:07:39.180
Our high-level goals
are fairly simple.

00:07:39.180 --> 00:07:41.740
We want to make a simple,
productive programming

00:07:41.740 --> 00:07:45.710
alignment and programming
language that supports for

00:07:45.710 --> 00:07:48.090
programming in the large.

00:07:48.090 --> 00:07:51.620
And we also want to have
predictable high performance.

00:07:51.620 --> 00:07:54.100
And that means that when you
write your code, you can

00:07:54.100 --> 00:07:56.020
expect some sort
of performance.

00:07:56.020 --> 00:07:58.170
Right now it's complicated
with JavaScript.

00:07:58.170 --> 00:08:01.350
It often depends on what the
browser optimized, how good

00:08:01.350 --> 00:08:04.180
performance you get out of it.

00:08:04.180 --> 00:08:07.120
We want to have ultra-fast
startup.

00:08:07.120 --> 00:08:09.750
Things that take more than
100 milliseconds are just

00:08:09.750 --> 00:08:11.740
unacceptable.

00:08:11.740 --> 00:08:15.280
And then of course, we are
not out to break the web.

00:08:15.280 --> 00:08:19.250
We really want to have
compatibility

00:08:19.250 --> 00:08:20.540
with all modern browsers.

00:08:20.540 --> 00:08:22.870
And we'll show you how we've
done that in Dart, by

00:08:22.870 --> 00:08:25.520
providing a translator from
Dart to JavaScript.

00:08:28.790 --> 00:08:30.800
So.

00:08:30.800 --> 00:08:32.470
KASPER LUND: Let's talk
about JavaScript.

00:08:32.470 --> 00:08:33.530
LARS BAK: Let's do that.

00:08:33.530 --> 00:08:35.700
KASPER LUND: So, I don't know
how many people in here are

00:08:35.700 --> 00:08:36.950
familiar with JavaScript.

00:08:39.320 --> 00:08:40.289
There are some that know it.

00:08:40.289 --> 00:08:40.610
OK.

00:08:40.610 --> 00:08:42.270
That's good.

00:08:42.270 --> 00:08:43.750
How many people here
actually work with

00:08:43.750 --> 00:08:46.670
JavaScript every day?

00:08:46.670 --> 00:08:47.470
Good crowd.

00:08:47.470 --> 00:08:47.960
I like that.

00:08:47.960 --> 00:08:51.690
So hopefully you're aware of
some fundamental issues with

00:08:51.690 --> 00:08:52.200
JavaScript.

00:08:52.200 --> 00:08:55.070
I'm going to run through a few
of them, just to give you a

00:08:55.070 --> 00:08:58.490
feel for the kind of issues
we're trying to tackle.

00:08:58.490 --> 00:09:02.310
So one big issue we see with
JavaScript is it's very hard

00:09:02.310 --> 00:09:05.030
to reason about where the
problem is actually defined.

00:09:05.030 --> 00:09:09.440
There is almost no declarative
syntax, and it's very hard, if

00:09:09.440 --> 00:09:12.820
not impossible sometimes, to
find dependencies between

00:09:12.820 --> 00:09:16.160
different components in a
language like JavaScript.

00:09:16.160 --> 00:09:18.470
It's not uncommon and not
unheard of that in JavaScript

00:09:18.470 --> 00:09:21.430
you do monkey patching of core
functionality to add your

00:09:21.430 --> 00:09:24.810
message to the object
[? or ?] prototype.

00:09:24.810 --> 00:09:26.930
And that makes it even harder to
reason about what's defined

00:09:26.930 --> 00:09:28.290
where, and who uses what.

00:09:28.290 --> 00:09:30.600
And understanding the program
structure is really, really

00:09:30.600 --> 00:09:33.270
important if you want to be
efficient as a programmer.

00:09:33.270 --> 00:09:36.090
You need to be able to do code
maintenance and refactoring,

00:09:36.090 --> 00:09:38.710
and that really requires you to
have a full and very good

00:09:38.710 --> 00:09:40.750
understanding of the
program structure.

00:09:40.750 --> 00:09:43.570
You also need that understanding
of the program

00:09:43.570 --> 00:09:46.000
structure if you want to write
a good tool that can analyze

00:09:46.000 --> 00:09:48.720
your code, and work with it, and
allow you to debug it and

00:09:48.720 --> 00:09:51.020
maybe navigate the code
in a clever way.

00:09:51.020 --> 00:09:53.000
So it's actually really
hard in JavaScript.

00:09:53.000 --> 00:09:54.760
Let me give you a
small example of

00:09:54.760 --> 00:09:55.850
what I mean with that.

00:09:55.850 --> 00:09:59.690
So here's a very, very simple
JavaScript function, meant as

00:09:59.690 --> 00:10:02.070
a constructor for points.

00:10:02.070 --> 00:10:04.870
So the fields of this point
class, that I'm trying to

00:10:04.870 --> 00:10:07.540
simulate in JavaScript, are
not actually declared

00:10:07.540 --> 00:10:10.930
anywhere, except that they are
implicitly defined by the

00:10:10.930 --> 00:10:13.770
statements that I put in the
constructor that assign x and

00:10:13.770 --> 00:10:16.750
y to this.x and this.y.

00:10:16.750 --> 00:10:18.960
This seems simple enough,
and pretty nice.

00:10:18.960 --> 00:10:21.290
And you could probably write a
tool that works with this kind

00:10:21.290 --> 00:10:22.250
of information.

00:10:22.250 --> 00:10:24.980
But in reality it's often more
complicated than this.

00:10:24.980 --> 00:10:28.370
So in JavaScript we often see
code like this, for instance,

00:10:28.370 --> 00:10:32.210
where you really want to make
these properties non-writable,

00:10:32.210 --> 00:10:33.400
like read-only.

00:10:33.400 --> 00:10:37.700
And suddenly you have to go
through actual control flow in

00:10:37.700 --> 00:10:41.230
your constructors, to figure
out what kind of fields you

00:10:41.230 --> 00:10:43.260
end up having on all
your points.

00:10:43.260 --> 00:10:45.720
Of course, this is a trivial
example, so a very good tool

00:10:45.720 --> 00:10:47.800
could probably analyze this
code and understand what

00:10:47.800 --> 00:10:48.540
you're doing.

00:10:48.540 --> 00:10:51.080
But for real applications,
this really quickly gets

00:10:51.080 --> 00:10:53.910
really, really hard.

00:10:53.910 --> 00:10:56.080
If you look at the tools out
there today for working with

00:10:56.080 --> 00:10:58.790
JavaScript code, it is pretty
clear that it's not an easy

00:10:58.790 --> 00:10:59.680
problem to solve.

00:10:59.680 --> 00:11:01.040
I mean, there are good
tools coming

00:11:01.040 --> 00:11:02.120
out, and it's improving.

00:11:02.120 --> 00:11:05.150
But it's really hard.

00:11:05.150 --> 00:11:09.050
Another very fundamental issue
with JavaScript is this keep

00:11:09.050 --> 00:11:10.410
on trucking mentality.

00:11:10.410 --> 00:11:13.420
So JavaScript has this idea
that it's a good thing to

00:11:13.420 --> 00:11:16.930
tolerate mistakes in the
program, and it's OK to

00:11:16.930 --> 00:11:21.210
operate on unexpected types, and
it's OK if that actually

00:11:21.210 --> 00:11:24.370
just leads to unusable or
unexpected results.

00:11:24.370 --> 00:11:27.130
So at the point in your code
where you introduce an error,

00:11:27.130 --> 00:11:30.030
you're very unlikely
to get that error.

00:11:30.030 --> 00:11:33.500
And it's much more likely that
the value you get out of that

00:11:33.500 --> 00:11:36.120
mistake you put in will just
flow through your program and

00:11:36.120 --> 00:11:38.680
end up causing a problem
later on.

00:11:38.680 --> 00:11:42.110
That just makes it very, very
hard to find your problem.

00:11:42.110 --> 00:11:44.660
Almost anything goes.

00:11:44.660 --> 00:11:46.900
For the program productivity,
it's much better to throw

00:11:46.900 --> 00:11:48.680
errors more eagerly.

00:11:48.680 --> 00:11:51.980
So it makes it much easier to
locate the source of an error,

00:11:51.980 --> 00:11:57.230
and it gives you many of the
errors when you're testing

00:11:57.230 --> 00:12:00.660
your code, not at run time
at the end user's side.

00:12:00.660 --> 00:12:02.450
So it gives you more
confidence in the

00:12:02.450 --> 00:12:03.280
deployed apps, too.

00:12:03.280 --> 00:12:06.470
It's really a good thing
for writing large scale

00:12:06.470 --> 00:12:08.930
applications and being able to
trust that they actually work

00:12:08.930 --> 00:12:10.890
as intended.

00:12:10.890 --> 00:12:12.470
Let me give you a few
examples of that.

00:12:12.470 --> 00:12:15.790
So in JavaScript,
constructors for

00:12:15.790 --> 00:12:18.060
objects are just functions.

00:12:18.060 --> 00:12:20.080
That seems pretty
nice and simple.

00:12:20.080 --> 00:12:23.910
I can use the function
as a constructor.

00:12:23.910 --> 00:12:24.740
It just sort of works.

00:12:24.740 --> 00:12:29.370
So if we build on the point
example from before, we can

00:12:29.370 --> 00:12:32.790
clearly allocate a point by
using that as a constructor.

00:12:32.790 --> 00:12:34.620
But what happens if we actually
forget to write new

00:12:34.620 --> 00:12:37.610
in front of that constructor
application?

00:12:37.610 --> 00:12:38.990
Well, it turns out it works.

00:12:38.990 --> 00:12:40.170
It doesn't give you an error.

00:12:40.170 --> 00:12:41.620
It's fine.

00:12:41.620 --> 00:12:45.570
It does give you the point
undefined back., and

00:12:45.570 --> 00:12:48.490
additionally it gives you two
extra global variables, x and

00:12:48.490 --> 00:12:50.360
y, that have the
value 2 and 3.

00:12:50.360 --> 00:12:54.020
So you don't get a point, but
you get extra state and the

00:12:54.020 --> 00:12:55.370
global object.

00:12:55.370 --> 00:12:59.260
That seems unintended, kind of
weird, and just is a real

00:12:59.260 --> 00:12:59.850
source of errors.

00:12:59.850 --> 00:13:02.360
We see this every day.

00:13:02.360 --> 00:13:05.110
During the development of V8
we've been through quite a lot

00:13:05.110 --> 00:13:07.960
of JavaScript code written by
many, many people, and these

00:13:07.960 --> 00:13:11.850
sort of subtle bugs
always pop up.

00:13:11.850 --> 00:13:13.100
LARS BAK: And one more thing.

00:13:13.100 --> 00:13:17.040
The interesting part is that
undefined [? integers, ?]

00:13:17.040 --> 00:13:18.740
you can see here, you
can't even rely on.

00:13:18.740 --> 00:13:19.800
Because it's mutable.

00:13:19.800 --> 00:13:21.510
You can change that property.

00:13:21.510 --> 00:13:23.690
So most people that would write
correct code, in this

00:13:23.690 --> 00:13:26.750
case, will instead of undefined
use [? write ?]

00:13:26.750 --> 00:13:28.430
zero.

00:13:28.430 --> 00:13:30.496
That makes sense
to you, right?

00:13:30.496 --> 00:13:32.010
KASPER LUND: Yeah, it does.

00:13:32.010 --> 00:13:32.990
I don't know how many
people that make

00:13:32.990 --> 00:13:34.440
sense to, but anyway.

00:13:34.440 --> 00:13:36.330
Let's take another example.

00:13:36.330 --> 00:13:39.430
This is probably the most common
source of issues in

00:13:39.430 --> 00:13:41.190
JavaScript.

00:13:41.190 --> 00:13:43.960
If you have a typo in your
code, that gives you real

00:13:43.960 --> 00:13:45.460
problems and it's
hard to find.

00:13:45.460 --> 00:13:47.750
So I put some code up here
that uses an XML

00:13:47.750 --> 00:13:49.190
HTTP request object.

00:13:49.190 --> 00:13:53.120
And the intent is, of course,
to install a callback that

00:13:53.120 --> 00:13:56.740
will get invoked whenever the
ready state changes, and if we

00:13:56.740 --> 00:13:59.900
reach the done state,
which is state 4,

00:13:59.900 --> 00:14:01.390
will log in to console.

00:14:01.390 --> 00:14:02.410
Very simple.

00:14:02.410 --> 00:14:04.520
Unfortunately this
does not work.

00:14:04.520 --> 00:14:07.760
The console will never have
anything here, even if the

00:14:07.760 --> 00:14:09.580
ready state does change to 4.

00:14:09.580 --> 00:14:14.670
Because ready state is spelled
with a capital S. So

00:14:14.670 --> 00:14:16.420
JavaScript allows this,
and it's just fine.

00:14:16.420 --> 00:14:18.490
It just gives you undefined
every single time you try to

00:14:18.490 --> 00:14:21.120
read the ready state with a
lowercase S. And undefined is

00:14:21.120 --> 00:14:22.880
not equal to 4.

00:14:22.880 --> 00:14:25.820
Maybe it should be,
I don't know.

00:14:25.820 --> 00:14:28.060
Anyway, it's this kind of thing
that makes you less

00:14:28.060 --> 00:14:29.090
productive as a programmer.

00:14:29.090 --> 00:14:32.870
And it kind of sucks.

00:14:32.870 --> 00:14:35.530
If we're sort of continuing on
that trend, we can also take a

00:14:35.530 --> 00:14:37.410
look at implicit conversions.

00:14:37.410 --> 00:14:40.100
There have been some pretty
funny videos circulating the

00:14:40.100 --> 00:14:42.650
web with more examples like
this, but this is a very

00:14:42.650 --> 00:14:43.630
simple one.

00:14:43.630 --> 00:14:45.450
So here we have a string.

00:14:45.450 --> 00:14:48.040
Strings in JavaScript
are values.

00:14:48.040 --> 00:14:49.910
They're immutable, you
cannot change them.

00:14:49.910 --> 00:14:52.390
If you try, do like string
dot hash equals

00:14:52.390 --> 00:14:54.220
something, it's accepted.

00:14:54.220 --> 00:14:56.790
What actually happens here is
that you actually implicitly

00:14:56.790 --> 00:15:01.030
convert string to a string
object that wraps that string.

00:15:01.030 --> 00:15:02.990
And you can access properties
on that, you can even set

00:15:02.990 --> 00:15:04.420
properties on that.

00:15:04.420 --> 00:15:06.260
The only problem is you actually
throw that temporary

00:15:06.260 --> 00:15:09.540
object away just after having
done it, so it has no effect.

00:15:09.540 --> 00:15:12.230
So when you try to assert that
string dot hash is something

00:15:12.230 --> 00:15:14.410
reasonable afterwards,
it's undefined.

00:15:14.410 --> 00:15:17.230
And again, I probably should
have put void 0 here.

00:15:17.230 --> 00:15:20.840
Because you get a different
object wrapped around the

00:15:20.840 --> 00:15:23.810
string value to grab
hold of the hash.

00:15:23.810 --> 00:15:25.600
This is surprising
to many people.

00:15:25.600 --> 00:15:28.230
And often you use this kind of
trick to try to add some

00:15:28.230 --> 00:15:29.580
caching to your code.

00:15:29.580 --> 00:15:31.330
And it seems to work just fine,
except that you never

00:15:31.330 --> 00:15:33.200
get any caching out of it.

00:15:33.200 --> 00:15:36.080
It's a performance problem, and
it's just annoying to have

00:15:36.080 --> 00:15:37.330
to deal with.

00:15:39.770 --> 00:15:41.070
I think I can top
the last slide.

00:15:41.070 --> 00:15:42.860
How about this one?

00:15:42.860 --> 00:15:45.750
I don't know if anyone here can
tell me why 2.0 should be

00:15:45.750 --> 00:15:48.940
equal to the string two, that
is equal to a Boolean object

00:15:48.940 --> 00:15:51.280
that wraps the true value,
that is equal

00:15:51.280 --> 00:15:52.480
to the string one.

00:15:52.480 --> 00:15:54.920
But it is.

00:15:54.920 --> 00:15:56.880
There are so many implicit
conversions going on here that

00:15:56.880 --> 00:15:58.750
it makes my head explode.

00:15:58.750 --> 00:16:02.390
And having to implement this
in V8, it was a lot of fun.

00:16:02.390 --> 00:16:04.960
But sometimes you have to doubt
whether or not the value

00:16:04.960 --> 00:16:06.300
you get out of these implicit
conversions

00:16:06.300 --> 00:16:07.760
is worth the trouble.

00:16:07.760 --> 00:16:09.250
LARS BAK: Actually if you take
the [INAUDIBLE] script

00:16:09.250 --> 00:16:11.520
standard and go through
specification, you'll figure

00:16:11.520 --> 00:16:14.850
out that you need at least six
implicit conversions of

00:16:14.850 --> 00:16:18.330
objects before you can evaluate
this expression.

00:16:18.330 --> 00:16:20.060
KASPER LUND: Yeah, and they go
in different directions.

00:16:20.060 --> 00:16:22.040
Like sometimes you convert to
numbers implicitly, sometimes

00:16:22.040 --> 00:16:25.790
to strings, sometimes from
objects to primitive values.

00:16:25.790 --> 00:16:28.960
It's pretty messy.

00:16:28.960 --> 00:16:31.400
Another big issue that we see,
and this is of course also

00:16:31.400 --> 00:16:35.240
coming from the low level, from
the VM side up, is that

00:16:35.240 --> 00:16:37.820
JavaScript has really
unpredictable performance.

00:16:37.820 --> 00:16:40.490
There's sort of an advice
floating around that you

00:16:40.490 --> 00:16:42.300
should just try to use the
efficient subset of

00:16:42.300 --> 00:16:43.310
JavaScript.

00:16:43.310 --> 00:16:46.370
Because VMs over the last few
years have been optimized for

00:16:46.370 --> 00:16:47.630
certain patterns.

00:16:47.630 --> 00:16:49.120
And if you want to benefit
from the performance

00:16:49.120 --> 00:16:53.270
improvements, and you probably
do want to do that, you have

00:16:53.270 --> 00:16:57.040
to hit that sweet spot, and have
all your code fit in that

00:16:57.040 --> 00:16:58.770
efficient subset.

00:16:58.770 --> 00:17:00.980
The problem is that it's
actually kind of hard to find

00:17:00.980 --> 00:17:01.580
that subset.

00:17:01.580 --> 00:17:03.790
Nobody can tell you what
that subset is.

00:17:03.790 --> 00:17:05.589
It depends on the browser,
it depends on the

00:17:05.589 --> 00:17:06.920
version of the browser.

00:17:06.920 --> 00:17:09.190
And it's not just about using
the right syntactic

00:17:09.190 --> 00:17:10.170
constructs.

00:17:10.170 --> 00:17:13.579
It can be about not fetching
local variables from the

00:17:13.579 --> 00:17:14.410
context chain.

00:17:14.410 --> 00:17:16.300
It can be about many
different things.

00:17:16.300 --> 00:17:18.770
If you see a site like
jsperf.com, where people try

00:17:18.770 --> 00:17:21.859
to upload these mini-snippets
of code to figure out what

00:17:21.859 --> 00:17:24.579
works well in certain browsers,
this is an act of

00:17:24.579 --> 00:17:25.359
desperation.

00:17:25.359 --> 00:17:27.579
People are trying to figure
out what works well.

00:17:27.579 --> 00:17:28.740
They just don't know.

00:17:28.740 --> 00:17:30.890
So the only way to write a
really high-performance

00:17:30.890 --> 00:17:33.680
JavaScript application is
to profile all the time.

00:17:33.680 --> 00:17:36.230
That takes time, again limiting
your productivity.

00:17:36.230 --> 00:17:38.780
So you can do amazing things
with JavaScript.

00:17:38.780 --> 00:17:41.980
It's just kind of tricky
and time consuming.

00:17:41.980 --> 00:17:45.620
And JavaScript performance
is pretty unpredictable.

00:17:45.620 --> 00:17:47.920
Sometimes it's really great, and
sometimes you get like a

00:17:47.920 --> 00:17:53.400
factor of 20 slower code, just
by using some slightly less

00:17:53.400 --> 00:17:55.640
common version of something.

00:17:55.640 --> 00:17:56.890
That's not a good place to be.

00:17:59.990 --> 00:18:00.300
LARS BAK: All right.

00:18:00.300 --> 00:18:03.740
So this is the summary for
the JavaScript portion.

00:18:03.740 --> 00:18:09.290
And as Kasper stated, programs
are hard to understand when

00:18:09.290 --> 00:18:10.950
you look at the source code.

00:18:10.950 --> 00:18:15.170
And it's also hard to reason
about if you're a tool.

00:18:15.170 --> 00:18:17.930
One thing that's really bad in
JavaScript is you can monkey

00:18:17.930 --> 00:18:19.280
patch the basic objects.

00:18:19.280 --> 00:18:22.290
That means that if you have two
different components that

00:18:22.290 --> 00:18:26.220
rely on the same library,
you get into problems.

00:18:26.220 --> 00:18:29.370
Because if one component patches
the library in a way

00:18:29.370 --> 00:18:31.550
the other component cannot
handle, then

00:18:31.550 --> 00:18:32.720
your program breaks.

00:18:32.720 --> 00:18:36.380
So compatibility is
out the window.

00:18:36.380 --> 00:18:39.670
Keep on trucking mentality is
just surprising to most.

00:18:39.670 --> 00:18:41.930
And we have gotten programs
in to analyze

00:18:41.930 --> 00:18:43.920
where this is an error.

00:18:43.920 --> 00:18:46.730
So programmers actually sent
their programs out, in

00:18:46.730 --> 00:18:51.480
production, with these keep on
trucking errors in them.

00:18:51.480 --> 00:18:52.300
And then of course there's

00:18:52.300 --> 00:18:55.850
unpredictability about the code.

00:18:55.850 --> 00:18:58.060
You should try to take your
favorite fast-running

00:18:58.060 --> 00:19:03.520
JavaScript code and put delete
property in a crucial place,

00:19:03.520 --> 00:19:04.500
and then the performance
[? quota ?]

00:19:04.500 --> 00:19:06.950
will go down the toilet.

00:19:06.950 --> 00:19:10.010
So this was the motivational
part.

00:19:10.010 --> 00:19:12.620
And hopefully you can see
innovation is needed, if you

00:19:12.620 --> 00:19:15.420
want to move the platform
forward so it's more

00:19:15.420 --> 00:19:16.670
productive for programmers.

00:19:19.380 --> 00:19:23.210
So let's talk about that.

00:19:23.210 --> 00:19:26.166
And you'll get that
in one slide.

00:19:26.166 --> 00:19:26.875
It's here.

00:19:26.875 --> 00:19:28.110
KASPER LUND: Here it is.

00:19:28.110 --> 00:19:30.600
LARS BAK: So since we're VM
developers, we don't really

00:19:30.600 --> 00:19:32.040
know how to design languages.

00:19:32.040 --> 00:19:35.560
So we thought a good idea would
be to take different

00:19:35.560 --> 00:19:38.020
languages, and take the best
aspects of them, and

00:19:38.020 --> 00:19:39.390
put them into one.

00:19:39.390 --> 00:19:43.610
So Dart is basically sort of a
combination of the syntax from

00:19:43.610 --> 00:19:47.590
JavaScript, the [? optional ?]
types in Strongtalk, the

00:19:47.590 --> 00:19:54.020
object model in Smalltalk, some
concepts from C#, and

00:19:54.020 --> 00:19:57.250
then an isolate model that's
inspired by Erlang.

00:19:57.250 --> 00:20:00.160
So that is very simple.

00:20:00.160 --> 00:20:05.740
And to specify what it is,
is an unsurprising simple

00:20:05.740 --> 00:20:06.240
[INAUDIBLE]

00:20:06.240 --> 00:20:06.800
language.

00:20:06.800 --> 00:20:11.130
With simple inheritance-- we
have classes, and we have

00:20:11.130 --> 00:20:13.640
interfaces, and we have
a familiar syntax.

00:20:13.640 --> 00:20:18.520
So if you know how to program in
C# or Java or JavaScript, I

00:20:18.520 --> 00:20:21.850
would expect that you can get
productive within a few hours.

00:20:21.850 --> 00:20:23.540
KASPER LUND: One thing that's
worth mentioning here is that

00:20:23.540 --> 00:20:26.120
at some point we found that
if you want to develop a

00:20:26.120 --> 00:20:29.830
language, design it to make it
appealing to people, it has to

00:20:29.830 --> 00:20:31.620
have curly braces.

00:20:31.620 --> 00:20:34.910
It is not possible to come up
with a mainstream programming

00:20:34.910 --> 00:20:37.260
language that gets any
kind of acceptance

00:20:37.260 --> 00:20:38.350
without curly braces.

00:20:38.350 --> 00:20:41.440
So we have tons of
curly braces.

00:20:41.440 --> 00:20:42.670
You're welcome.

00:20:42.670 --> 00:20:48.560
[APPLAUSE]

00:20:48.560 --> 00:20:49.810
LARS BAK: It's sad, but true.

00:20:55.250 --> 00:20:58.040
So let me just go on.

00:20:58.040 --> 00:21:01.780
So here is the point
example in Dart.

00:21:01.780 --> 00:21:04.930
This is the first Dart
example of this talk.

00:21:04.930 --> 00:21:07.390
And there's a class
named point.

00:21:07.390 --> 00:21:09.880
It has two fields, x and y.

00:21:09.880 --> 00:21:12.310
And there's a constructor.

00:21:12.310 --> 00:21:15.450
And parameters for the
constructor are this.x and

00:21:15.450 --> 00:21:18.500
this.y means when you call the
constructor it will assign the

00:21:18.500 --> 00:21:20.720
parameters to the two fields.

00:21:20.720 --> 00:21:23.520
So there's no body of the
constructor in this case.

00:21:23.520 --> 00:21:28.250
It also has an operator plus
that takes us another point,

00:21:28.250 --> 00:21:32.640
and then it returns a new point
that's actually the

00:21:32.640 --> 00:21:34.430
addition of the two points, the

00:21:34.430 --> 00:21:36.860
receiver and the parameter.

00:21:36.860 --> 00:21:40.860
Here you can see the shorthand
notation for a function, where

00:21:40.860 --> 00:21:42.340
you see the arrow.

00:21:42.340 --> 00:21:45.810
Syntax just means that there's
one expression to the right,

00:21:45.810 --> 00:21:50.270
and the function will return the
result of that expression.

00:21:50.270 --> 00:21:54.650
There's also a to string method,
and it returns a

00:21:54.650 --> 00:21:59.450
string so you can see what
coordinates the point has.

00:21:59.450 --> 00:22:01.450
Here we're using string
interpolation, it's fairly

00:22:01.450 --> 00:22:03.280
obvious what's going on.

00:22:03.280 --> 00:22:06.420
And then we have a top level
main that creates a new point.

00:22:06.420 --> 00:22:10.690
And then it has an expression
where we add one point to

00:22:10.690 --> 00:22:14.220
another point, which
is new point 4, 5.

00:22:14.220 --> 00:22:17.382
One thing I should point out,
you cannot call the

00:22:17.382 --> 00:22:20.030
constructor without new.

00:22:20.030 --> 00:22:21.260
That's a good thing.

00:22:21.260 --> 00:22:22.790
KASPER LUND: Hopefully this
syntax does not look

00:22:22.790 --> 00:22:23.840
too scary to people.

00:22:23.840 --> 00:22:26.450
I mean, the feedback we've
gotten so far is that this

00:22:26.450 --> 00:22:29.280
kind of code is actually fairly
easy for people to just

00:22:29.280 --> 00:22:30.840
read on the slide
and understand.

00:22:30.840 --> 00:22:32.616
That's exactly what
we're going for.

00:22:36.990 --> 00:22:40.350
LARS BAK: When we designed the
language, we looked at various

00:22:40.350 --> 00:22:43.340
attempts to make scalable
programs.

00:22:43.340 --> 00:22:47.860
And there needs to be a way
where the programmer can

00:22:47.860 --> 00:22:51.530
specify the intent
of a library.

00:22:51.530 --> 00:22:53.720
And one way of doing that
is by specifying type

00:22:53.720 --> 00:22:55.130
annotations.

00:22:55.130 --> 00:22:56.700
And we have that in Dart.

00:22:56.700 --> 00:22:57.480
They're optional, though.

00:22:57.480 --> 00:23:00.370
So you can write without
types if you want to.

00:23:00.370 --> 00:23:03.530
And as your program matures and
you get more structure on

00:23:03.530 --> 00:23:07.070
it, you can add the types
any time you want.

00:23:07.070 --> 00:23:10.485
But they act as checkable
documentation for the code and

00:23:10.485 --> 00:23:11.280
the interfaces.

00:23:11.280 --> 00:23:14.750
So you can decide only to put in
types in the interface, but

00:23:14.750 --> 00:23:18.730
you can also decide to really
put in static types everywhere

00:23:18.730 --> 00:23:20.080
in your program.

00:23:20.080 --> 00:23:23.660
And people that are familiar
with the Java or C#, they have

00:23:23.660 --> 00:23:24.910
a tendency to do that.

00:23:27.420 --> 00:23:29.430
We also have generics.

00:23:29.430 --> 00:23:31.800
And that makes really useful, so
you can specify you have a

00:23:31.800 --> 00:23:36.080
list of apples or a
set of oranges.

00:23:36.080 --> 00:23:39.210
States intent.

00:23:39.210 --> 00:23:41.650
The type system is a little
bit special in that it is

00:23:41.650 --> 00:23:47.810
considered unsound, because we
allow downcasts when steadily

00:23:47.810 --> 00:23:48.920
checking a Dart program.

00:23:48.920 --> 00:23:50.970
However, these abilities
are run time.

00:23:50.970 --> 00:23:54.060
So if you violate the assignment
rules, you'll get a

00:23:54.060 --> 00:23:55.240
runtime error.

00:23:55.240 --> 00:23:56.960
But it makes it very,
very flexible.

00:23:56.960 --> 00:23:59.540
And I'll show you that on the
next slide, hopefully.

00:24:02.360 --> 00:24:04.570
Or the next slide.

00:24:04.570 --> 00:24:07.680
This one here is the point
example again, where we have

00:24:07.680 --> 00:24:09.780
added the types.

00:24:09.780 --> 00:24:14.980
So you can see that the fields
are now annotated with num,

00:24:14.980 --> 00:24:17.470
which is a number in Dart.

00:24:17.470 --> 00:24:22.390
And also the return type of the
operator plus will be a

00:24:22.390 --> 00:24:26.360
point, and the parameter to
that is also a point.

00:24:26.360 --> 00:24:28.800
So you can see, if you contrast
it to the first

00:24:28.800 --> 00:24:31.920
example, as little changes
you have to make in

00:24:31.920 --> 00:24:34.360
order to type it.

00:24:34.360 --> 00:24:38.370
And this hopefully here also
is very easy to read.

00:24:38.370 --> 00:24:41.230
KASPER LUND: We see people start
out without writing a

00:24:41.230 --> 00:24:42.230
lot of type notations.

00:24:42.230 --> 00:24:44.860
While they're prototyping, just
wanted to get some things

00:24:44.860 --> 00:24:47.160
done, they will write in a style
where they have less

00:24:47.160 --> 00:24:47.880
type notations.

00:24:47.880 --> 00:24:50.170
And once they want to coordinate
their work with

00:24:50.170 --> 00:24:54.450
coworkers, or maybe send it out
for a code review, they

00:24:54.450 --> 00:24:56.930
will add more types to try to
document what they felt like

00:24:56.930 --> 00:25:00.660
doing, an what the different
constructs were meant to do.

00:25:00.660 --> 00:25:05.330
Usually we end up having types
in interfaces and return types

00:25:05.330 --> 00:25:07.520
and parameters, and
less types in the

00:25:07.520 --> 00:25:08.820
implementations of methods.

00:25:08.820 --> 00:25:12.550
But it's a matter of taste,
and you can choose,

00:25:12.550 --> 00:25:13.800
essentially, what you like.

00:25:17.940 --> 00:25:21.350
LARS BAK: So to some of you
that are used to generics,

00:25:21.350 --> 00:25:24.630
from Java or C#, this might
sound surprising.

00:25:24.630 --> 00:25:26.980
But we have covariant
generic types.

00:25:26.980 --> 00:25:35.370
And it basically means that if
apple is a fruit, then a list

00:25:35.370 --> 00:25:38.130
of apples is clearly
a list of fruits.

00:25:38.130 --> 00:25:42.290
In this example we have
the main function.

00:25:42.290 --> 00:25:47.070
It calls a pick apples
from a tree, and it

00:25:47.070 --> 00:25:49.220
returns a list of apples.

00:25:49.220 --> 00:25:52.190
And then you call the print
fruits method--

00:25:52.190 --> 00:25:53.060
hello--

00:25:53.060 --> 00:25:55.080
and that takes a
list of fruits.

00:25:55.080 --> 00:25:56.250
And it seems to work.

00:25:56.250 --> 00:25:57.770
And that's how it should work.

00:25:57.770 --> 00:26:01.420
But if you take Java or
C#, that will fail.

00:26:01.420 --> 00:26:05.470
Because if you take these two
generic types in these

00:26:05.470 --> 00:26:07.330
languages, they are unrelated.

00:26:07.330 --> 00:26:11.710
And the type system cannot
cope with it.

00:26:11.710 --> 00:26:14.100
It works like you
want it to work.

00:26:14.100 --> 00:26:16.370
KASPER LUND: That's exactly
what I wanted to say.

00:26:16.370 --> 00:26:19.220
This fits with your intuition
in most cases.

00:26:19.220 --> 00:26:22.690
And of course there are some
theoretical reasons why other

00:26:22.690 --> 00:26:24.410
languages have not
done this before.

00:26:24.410 --> 00:26:27.500
But this actually works pretty
well in practice.

00:26:27.500 --> 00:26:28.850
So it does give you some
runtime checks

00:26:28.850 --> 00:26:29.430
every now and then.

00:26:29.430 --> 00:26:31.370
But it works really
well in practice.

00:26:31.370 --> 00:26:37.020
And it makes the types
not get in your way

00:26:37.020 --> 00:26:38.290
LARS BAK: All right.

00:26:38.290 --> 00:26:40.380
So let's go for a small demo.

00:26:47.160 --> 00:26:49.360
KASPER LUND: Let me show you
just a tiny bit of Dart code,

00:26:49.360 --> 00:26:50.530
and how it works in practice.

00:26:50.530 --> 00:26:55.260
And I want to try to illustrate
how these types can

00:26:55.260 --> 00:26:58.820
be checked at runtime to give
you very recognizable and very

00:26:58.820 --> 00:27:02.280
strong error signals, that allow
you to fix issues in

00:27:02.280 --> 00:27:03.520
your code much more quickly.

00:27:03.520 --> 00:27:06.410
So here's an instance of the
Dart editor running.

00:27:06.410 --> 00:27:08.580
I'm not going to go into a lot
of detail about the editor.

00:27:08.580 --> 00:27:13.340
You should come to the next talk
at 2:45 in Room Three.

00:27:13.340 --> 00:27:15.600
You'll get much more insights
into what the editor can do

00:27:15.600 --> 00:27:16.540
and how it works.

00:27:16.540 --> 00:27:18.950
This will just be
a small teaser.

00:27:18.950 --> 00:27:21.160
So here I have a
sunflower demo.

00:27:21.160 --> 00:27:25.000
I can show you that running in
our custom build of Chrome,

00:27:25.000 --> 00:27:26.750
that has the Dart VM enabled.

00:27:26.750 --> 00:27:30.120
And it's a fairly simple,
small thing.

00:27:30.120 --> 00:27:32.370
It just allows me to have a
slider and adjust the size of

00:27:32.370 --> 00:27:34.230
this sunflower thing.

00:27:34.230 --> 00:27:37.050
If I go back to the editor and
I deliberately introduce a

00:27:37.050 --> 00:27:38.810
small issue in the code--

00:27:38.810 --> 00:27:40.580
let me scroll down here,
find the main thing.

00:27:40.580 --> 00:27:44.690
Something like messing up and
providing a rubbish argument

00:27:44.690 --> 00:27:45.620
to draw frame.

00:27:45.620 --> 00:27:47.520
Instead of providing the
context, I'll give it the

00:27:47.520 --> 00:27:48.810
canvas instead.

00:27:48.810 --> 00:27:49.950
I'll say that.

00:27:49.950 --> 00:27:53.630
And because the VM is enabled
in this Dart [INAUDIBLE], I

00:27:53.630 --> 00:27:55.730
can just go and refresh the
browser, and it gets the

00:27:55.730 --> 00:27:56.320
latest source code.

00:27:56.320 --> 00:27:59.190
No compilation necessary.

00:27:59.190 --> 00:28:01.920
What actually happens is I go
back into the editor, because

00:28:01.920 --> 00:28:03.470
this actually gives
me an exception.

00:28:03.470 --> 00:28:06.650
Because I'm supposed to be
passing a canvas rendering

00:28:06.650 --> 00:28:07.500
context 2D.

00:28:07.500 --> 00:28:09.750
That's a nice, short name.

00:28:09.750 --> 00:28:12.100
It wants the context, and I'm
giving it a canvas instead.

00:28:12.100 --> 00:28:15.610
So I get a very recognizable
error, right here when I have

00:28:15.610 --> 00:28:16.360
the mistake.

00:28:16.360 --> 00:28:18.560
It doesn't try to keep
on trucking.

00:28:18.560 --> 00:28:21.310
And it really helps me, as a
developer, to figure out what

00:28:21.310 --> 00:28:22.600
I messed up.

00:28:22.600 --> 00:28:25.630
So this was a very small teaser,
just to show you that

00:28:25.630 --> 00:28:28.520
the checking of these types at
runtime can really help you

00:28:28.520 --> 00:28:33.210
just find those issues
really quickly.

00:28:33.210 --> 00:28:35.440
LARS BAK: And this is a good
example, where there's a

00:28:35.440 --> 00:28:38.890
mixture between untyped
code and typed code.

00:28:38.890 --> 00:28:42.020
And even though you have a
mixture, the typing in the

00:28:42.020 --> 00:28:44.990
type part will help you validate
that you used the

00:28:44.990 --> 00:28:46.460
code the right way.

00:28:46.460 --> 00:28:49.120
KASPER LUND: So the canvas
that I provided as the

00:28:49.120 --> 00:28:51.340
argument was untyped.

00:28:51.340 --> 00:28:53.130
That's OK to pass to something
that expects a type, but we

00:28:53.130 --> 00:28:55.640
will check it.

00:28:55.640 --> 00:28:57.060
Let's go back to the
presentation, here.

00:29:00.000 --> 00:29:01.640
LARS BAK: All right.

00:29:01.640 --> 00:29:05.770
Since this is a full language,
we decided to select a small

00:29:05.770 --> 00:29:09.190
portfolio of cool language
features I hope you like.

00:29:09.190 --> 00:29:12.620
So let's go through
them quickly.

00:29:12.620 --> 00:29:15.980
So we have name constructors.

00:29:15.980 --> 00:29:19.540
And it means that you can have
more than one constructor in

00:29:19.540 --> 00:29:20.820
the same class.

00:29:20.820 --> 00:29:23.520
In this case here we
have added a name

00:29:23.520 --> 00:29:24.530
constructor to point.

00:29:24.530 --> 00:29:26.150
It's called polar.

00:29:26.150 --> 00:29:29.310
So if you have polar
coordinates, you can pass that

00:29:29.310 --> 00:29:32.070
in and also create a point.

00:29:32.070 --> 00:29:35.860
The main reason for doing that
is we don't have type

00:29:35.860 --> 00:29:38.710
overloading in Dart.

00:29:38.710 --> 00:29:42.380
And this will give you
flexibility compared to other

00:29:42.380 --> 00:29:46.820
languages, where you often
have to do several steady

00:29:46.820 --> 00:29:49.810
factory methods to get
to the same result.

00:29:49.810 --> 00:29:52.540
So, cool feature.

00:29:52.540 --> 00:29:54.200
Next.

00:29:54.200 --> 00:29:55.510
We have interfaces.

00:29:55.510 --> 00:29:58.240
But what we have also added
something called default

00:29:58.240 --> 00:30:00.560
implementations to interfaces.

00:30:00.560 --> 00:30:05.370
And it's mainly designed so that
novice users do not have

00:30:05.370 --> 00:30:09.180
to know all the implementation
types in the system.

00:30:09.180 --> 00:30:12.610
So all they have to know is
the simple interfaces.

00:30:12.610 --> 00:30:16.250
And you can say new to a list,
which is an interface, and the

00:30:16.250 --> 00:30:18.760
only thing that will happened
is it will just delegate the

00:30:18.760 --> 00:30:22.160
constructor call to the default
implementation.

00:30:22.160 --> 00:30:24.890
And in this case it's the
list [? factoring. ?]

00:30:24.890 --> 00:30:27.810
So we created two lists
for you here.

00:30:27.810 --> 00:30:30.890
In main, the first one,
is just a list

00:30:30.890 --> 00:30:33.050
without a generic parameter.

00:30:33.050 --> 00:30:37.360
And in that list you can add
any update you have.

00:30:37.360 --> 00:30:39.910
The second one is a
list of points.

00:30:39.910 --> 00:30:44.170
You can pass the optional
parameter linked to it.

00:30:44.170 --> 00:30:49.000
So we'll get a list of 12
elements, and you can only add

00:30:49.000 --> 00:30:51.430
points to it.

00:30:51.430 --> 00:30:53.980
KASPER LUND: So if you look at
the list constructor up in the

00:30:53.980 --> 00:30:57.140
interface, that square bracket
notation means that that

00:30:57.140 --> 00:30:58.460
parameter is optional.

00:30:58.460 --> 00:30:59.845
It can be provided by
the caller, and

00:30:59.845 --> 00:31:03.000
it can not be provided.

00:31:03.000 --> 00:31:05.873
The default implementation gets
to decide what to do it

00:31:05.873 --> 00:31:07.990
it's not provided, and in this
case it just initializes the

00:31:07.990 --> 00:31:10.150
list with zero elements and
you get to add your stuff

00:31:10.150 --> 00:31:11.750
afterwards.

00:31:11.750 --> 00:31:15.010
But it's a nice thing that you
can specify in the interface,

00:31:15.010 --> 00:31:17.050
that the intent is that you can
provide this if you want

00:31:17.050 --> 00:31:19.980
to, or you may not want to do
that and you get the default

00:31:19.980 --> 00:31:21.440
behavior instead.

00:31:21.440 --> 00:31:23.470
So that's another language
feature on the same slide.

00:31:23.470 --> 00:31:26.260
Like two in one.

00:31:26.260 --> 00:31:28.040
LARS BAK: Next one is
cascaded calls.

00:31:28.040 --> 00:31:31.180
How many of you have
used Smalltalk?

00:31:31.180 --> 00:31:32.860
KASPER LUND: Wow.

00:31:32.860 --> 00:31:36.070
LARS BAK: Out of the five,
how many like cascaded

00:31:36.070 --> 00:31:37.660
[? sends? ?]

00:31:37.660 --> 00:31:38.290
Nobody?

00:31:38.290 --> 00:31:42.020
Anyways, we have added
cascaded [? sends. ?]

00:31:42.020 --> 00:31:43.800
I'm a true believer in them.

00:31:43.800 --> 00:31:48.640
So it basically means we have a
construct that allows you to

00:31:48.640 --> 00:31:51.640
do multiple calls on
the same object.

00:31:51.640 --> 00:31:55.380
Here's an example where you
want to draw a circle.

00:31:55.380 --> 00:31:57.800
You get the canvas, the
x- and y-coordinates,

00:31:57.800 --> 00:31:59.380
and the size in.

00:31:59.380 --> 00:32:04.800
And you first compute the
context from the canvas, and

00:32:04.800 --> 00:32:08.650
then you want to do a
number of calls on

00:32:08.650 --> 00:32:10.120
that object, the context.

00:32:10.120 --> 00:32:12.430
And this is how it's
done in Dart.

00:32:12.430 --> 00:32:15.740
You use the dot dot notation,
and it means that you first

00:32:15.740 --> 00:32:19.290
call beginPath on the context,
then arc, then fill, then

00:32:19.290 --> 00:32:21.710
closePath, and then stroke.

00:32:21.710 --> 00:32:24.890
It's just a simple way to avoid
introducing yet another

00:32:24.890 --> 00:32:26.140
local variable.

00:32:28.190 --> 00:32:30.510
KASPER LUND: It also gives us
great typing information.

00:32:30.510 --> 00:32:34.680
So if you have a canvas out of
context and that is typed in

00:32:34.680 --> 00:32:38.290
the definition of the canvas,
the system will know and be

00:32:38.290 --> 00:32:41.060
able to give you code completion
suggestions when

00:32:41.060 --> 00:32:43.500
you're doing these
cascaded things.

00:32:43.500 --> 00:32:48.320
So it helps, at least if the
alternative was to do a bar

00:32:48.320 --> 00:32:50.020
declaration, and have
to go through all

00:32:50.020 --> 00:32:50.290
the things with that.

00:32:50.290 --> 00:32:52.380
So this is shorter, and
nicer in many ways.

00:32:56.350 --> 00:32:59.110
LARS BAK: Here's
another thing.

00:32:59.110 --> 00:33:02.030
This illustrates how we do
proper capturing of loop

00:33:02.030 --> 00:33:03.280
variables in Dart.

00:33:05.760 --> 00:33:07.760
Here's a function called main.

00:33:07.760 --> 00:33:10.690
It has a list called closures.

00:33:10.690 --> 00:33:16.330
And we have a for loop from zero
to eight, where we add a

00:33:16.330 --> 00:33:19.840
closure each time you
execute the loop.

00:33:19.840 --> 00:33:25.030
And in this case here, it's just
a function that returns

00:33:25.030 --> 00:33:27.270
the [? count of variable ?] i.

00:33:27.270 --> 00:33:30.680
In most languages what happens
if you execute this code as

00:33:30.680 --> 00:33:31.680
specified--

00:33:31.680 --> 00:33:34.420
by the way, at the end here
we go through the list of

00:33:34.420 --> 00:33:36.600
closures, and then evaluate
the closure

00:33:36.600 --> 00:33:38.700
and print the result.

00:33:38.700 --> 00:33:42.520
If you do that in C# or in
JavaScript, you'll get a

00:33:42.520 --> 00:33:45.630
number of eights out, because
all the closures were referred

00:33:45.630 --> 00:33:48.680
to the same loop variable.

00:33:48.680 --> 00:33:50.320
In Dart it's different.

00:33:50.320 --> 00:33:54.030
In Dart, you'll introduce a new
loop variable each time

00:33:54.030 --> 00:33:55.680
you enter the loop.

00:33:55.680 --> 00:34:02.360
So in Dart, you'll see the
results 1, 2, 3, 4, 5, 6, 7.

00:34:02.360 --> 00:34:05.320
And this is a common mistake
when you use closures for

00:34:05.320 --> 00:34:06.910
programming.

00:34:06.910 --> 00:34:08.719
KASPER LUND: We have a number
of examples from JavaScript,

00:34:08.719 --> 00:34:12.300
again, where we see people
using asynchronous API.

00:34:12.300 --> 00:34:14.800
And they have to be very careful
to capture the right

00:34:14.800 --> 00:34:16.810
variables and the
right values.

00:34:16.810 --> 00:34:19.000
So there's a lot of small
mistakes in that, and you see

00:34:19.000 --> 00:34:21.130
a lot of weird things
going on with that.

00:34:21.130 --> 00:34:23.690
So we decided to try to fix
that, and make it simpler for

00:34:23.690 --> 00:34:25.010
programmers to reason
about this.

00:34:29.239 --> 00:34:33.820
LARS BAK: So to us Dart is
beautiful, even though we took

00:34:33.820 --> 00:34:35.810
most of the components
and curly

00:34:35.810 --> 00:34:37.060
braces from other languages.

00:34:39.449 --> 00:34:42.040
It's declarative, so we think
it's easy to read.

00:34:42.040 --> 00:34:44.260
And it's certainly toolable.

00:34:44.260 --> 00:34:47.699
We don't do any implicit
conversion, so the semantics

00:34:47.699 --> 00:34:49.830
is fairly straightforward.

00:34:49.830 --> 00:34:53.239
And the libraries are actually
read-only, so we can have

00:34:53.239 --> 00:34:58.470
composable component and it
works, and you can rely on it.

00:34:58.470 --> 00:35:05.280
And again, if you're used to
Java, C# or JavaScript, other

00:35:05.280 --> 00:35:07.620
languages with curly braces,
this should be easy.

00:35:11.360 --> 00:35:15.210
KASPER LUND: So the Dart
language is, of course, a big

00:35:15.210 --> 00:35:16.540
part of this project.

00:35:16.540 --> 00:35:17.760
But there is more to it.

00:35:17.760 --> 00:35:20.790
So let me give you a brief
tour of what we're doing.

00:35:20.790 --> 00:35:23.690
Language is only part
of the story.

00:35:23.690 --> 00:35:27.200
If you want to have a great web
development platform, that

00:35:27.200 --> 00:35:30.250
entire platform has to be
well-tuned for helping you

00:35:30.250 --> 00:35:32.200
guys to deliver fantastic
apps.

00:35:32.200 --> 00:35:35.600
So developers need a great new
language, and we've tried to

00:35:35.600 --> 00:35:37.560
argue why Dart is that
new language.

00:35:37.560 --> 00:35:41.720
But you also need really fast
execution, and really fast

00:35:41.720 --> 00:35:42.670
startup applications.

00:35:42.670 --> 00:35:45.800
And you need very good tools for
developing your apps and

00:35:45.800 --> 00:35:48.420
for analyzing your apps.

00:35:48.420 --> 00:35:50.830
It's also very important that
you get very good integration

00:35:50.830 --> 00:35:53.450
with the DOM.

00:35:53.450 --> 00:35:55.830
As developers you need
all of this.

00:35:55.830 --> 00:35:59.170
So the Dart project is not just
about the language, it's

00:35:59.170 --> 00:36:04.820
also about innovating on the
tool side, and it's also about

00:36:04.820 --> 00:36:07.460
giving you access to much
better and much more

00:36:07.460 --> 00:36:08.710
predictable performance.

00:36:12.830 --> 00:36:16.260
LARS BAK: Because we have
decided to make Dart run on

00:36:16.260 --> 00:36:18.860
existing platforms, we have
a little bit complicated

00:36:18.860 --> 00:36:20.260
deployment story for Dart.

00:36:20.260 --> 00:36:22.210
And I'll try to go
through it here.

00:36:22.210 --> 00:36:24.290
So the green stuff at
the top is your

00:36:24.290 --> 00:36:27.370
application, plus libraries.

00:36:27.370 --> 00:36:28.700
And you have a few
choices here.

00:36:28.700 --> 00:36:31.690
You can run it directly on that
Dartium build, which you

00:36:31.690 --> 00:36:35.590
saw Kasper demo before, and
it will run right away.

00:36:35.590 --> 00:36:37.680
But you can also process
the application

00:36:37.680 --> 00:36:39.380
library through tools.

00:36:39.380 --> 00:36:42.930
One tool is the Dart to JS
compiler, which will translate

00:36:42.930 --> 00:36:46.560
Dart into one single
JavaScript file.

00:36:46.560 --> 00:36:49.720
And then you can run it
in any modern browser.

00:36:49.720 --> 00:36:51.970
This is the part where you
should be happy we're not

00:36:51.970 --> 00:36:55.530
trying to break the web.

00:36:55.530 --> 00:36:59.260
Another tool we have is we can
convert an application, plus

00:36:59.260 --> 00:37:02.060
libraries, into a snapshot.

00:37:02.060 --> 00:37:05.560
And a snapshot is a serialized
form of the data structure

00:37:05.560 --> 00:37:08.590
that makes applications
start up much faster.

00:37:08.590 --> 00:37:10.740
I'll get back to that
in two slides.

00:37:13.869 --> 00:37:16.280
KASPER LUND: This is actually
a really important point, I

00:37:16.280 --> 00:37:17.200
think I want to make it again.

00:37:17.200 --> 00:37:18.810
Lars already said it.

00:37:18.810 --> 00:37:21.300
Dart is compatible with
all modern browsers.

00:37:21.300 --> 00:37:26.300
So this is just a small cut-out
of the Buildbot we

00:37:26.300 --> 00:37:29.590
have running on
buildbot.dartlang.org.

00:37:29.590 --> 00:37:33.500
And it shows us testing Dart
across Firefox, Chrome,

00:37:33.500 --> 00:37:36.970
Safari, IE and Opera.

00:37:36.970 --> 00:37:38.900
This is actually just an
indication that we take this

00:37:38.900 --> 00:37:41.050
compatibility issue
very seriously.

00:37:41.050 --> 00:37:44.270
It's very dear to our hearts
to have Dart running really

00:37:44.270 --> 00:37:46.490
well across all modern
browsers.

00:37:46.490 --> 00:37:50.270
All the browsers here do not
have Dart VMs built in, so

00:37:50.270 --> 00:37:53.140
here we're using the Dart to
JavaScript translation.

00:37:53.140 --> 00:37:55.330
And we make that work across
all these browsers.

00:37:55.330 --> 00:37:58.943
And we continue to do that and
keep that part running.

00:38:02.190 --> 00:38:04.460
Let me just spend a few moments
on telling you about

00:38:04.460 --> 00:38:06.090
the translation process.

00:38:06.090 --> 00:38:08.460
We do have a compiler that
translates Dart to JavaScript.

00:38:08.460 --> 00:38:11.430
It's written in Dart itself.

00:38:11.430 --> 00:38:15.930
That gives us a nice excuse
for using Dart

00:38:15.930 --> 00:38:17.330
as a language ourselves.

00:38:17.330 --> 00:38:19.680
And it also means that
we can compile Dart--

00:38:19.680 --> 00:38:21.290
through Dart to JS compiler--

00:38:21.290 --> 00:38:24.380
with itself, and get a compiler
out that actually can

00:38:24.380 --> 00:38:26.910
compile Dart to JavaScript,
that runs

00:38:26.910 --> 00:38:28.280
in any modern browser.

00:38:28.280 --> 00:38:31.470
That's maybe kind of freaky,
but it works really well.

00:38:31.470 --> 00:38:34.030
You can have a JavaScript
implementation of a Dart to

00:38:34.030 --> 00:38:37.430
JavaScript compiler by just
compiling it with itself.

00:38:37.430 --> 00:38:38.090
I like that stuff.

00:38:38.090 --> 00:38:40.520
LARS BAK: Maybe it'll go
to [? reflector ?] now.

00:38:40.520 --> 00:38:42.520
KASPER LUND: So let's get
back to something more

00:38:42.520 --> 00:38:43.030
down-to-earth.

00:38:43.030 --> 00:38:45.690
Here's a, I think
at this point,

00:38:45.690 --> 00:38:47.120
very well-known example.

00:38:47.120 --> 00:38:50.240
The point, with two fields,
x and y, and a

00:38:50.240 --> 00:38:51.550
constructor and a to string.

00:38:51.550 --> 00:38:53.910
And it translates to something
like this on the JavaScript.

00:38:53.910 --> 00:38:56.100
That's the right hand side.

00:38:56.100 --> 00:39:00.810
We create a structure, give it
an endpoint, and we fill in an

00:39:00.810 --> 00:39:03.360
explicit superclass, object in
this case, and put in a couple

00:39:03.360 --> 00:39:04.940
fields, x and y.

00:39:04.940 --> 00:39:07.740
And then we have a small piece
of code that actually

00:39:07.740 --> 00:39:11.000
translates this to JavaScript
instructor at runtime, and

00:39:11.000 --> 00:39:13.330
puts in the getters and setters
for these fields, and

00:39:13.330 --> 00:39:14.760
it makes it nice to work with.

00:39:14.760 --> 00:39:16.740
But the rest of the definition
of point is

00:39:16.740 --> 00:39:18.190
actually just the methods.

00:39:18.190 --> 00:39:21.570
So here you see the to string
method is being translated to

00:39:21.570 --> 00:39:24.670
a JavaScript to string method,
with a dollar zero at the end.

00:39:24.670 --> 00:39:25.940
That just means that
that function

00:39:25.940 --> 00:39:27.590
expects zero arguments.

00:39:27.590 --> 00:39:30.380
It's important for us to make
sure that these functions that

00:39:30.380 --> 00:39:32.710
you call get the expected number
of arguments, so you

00:39:32.710 --> 00:39:35.820
don't have this classical issue
in JavaScript where you

00:39:35.820 --> 00:39:38.110
forget to provide a parameter,
and it just kind of

00:39:38.110 --> 00:39:39.380
works in a weird way.

00:39:39.380 --> 00:39:41.670
The to string method on the
right is a bit more verbose

00:39:41.670 --> 00:39:43.040
than the one on the left.

00:39:43.040 --> 00:39:45.500
And that's because of the string
interpolation feature,

00:39:45.500 --> 00:39:50.670
where we will make it very, very
easy to convert strings,

00:39:50.670 --> 00:39:55.370
and bits and pieces of
expressions and code, to join

00:39:55.370 --> 00:39:56.200
them as strings.

00:39:56.200 --> 00:39:59.300
And you see here it's translated
into a couple of

00:39:59.300 --> 00:40:01.100
string concatenation
operations.

00:40:01.100 --> 00:40:04.170
So we'll do this for you, and
this code runs across all

00:40:04.170 --> 00:40:06.838
modern browsers.

00:40:06.838 --> 00:40:10.540
LARS BAK: We have to speed
up a little bit, I think.

00:40:10.540 --> 00:40:11.570
Anyways.

00:40:11.570 --> 00:40:14.730
One cool thing about Dart is
that because it is declarative

00:40:14.730 --> 00:40:17.140
we can do something called
tree shaking.

00:40:17.140 --> 00:40:19.810
And tree shaking is this
pre-deployment step that

00:40:19.810 --> 00:40:23.200
allows you to reduce the
size of the executable.

00:40:23.200 --> 00:40:25.290
And what it basically means
is that you take the main

00:40:25.290 --> 00:40:28.820
function and you start
shaking it.

00:40:28.820 --> 00:40:32.110
Everything that you're not using
will fall off the tree,

00:40:32.110 --> 00:40:34.490
and when you're done you can
wrap it up, and that's your

00:40:34.490 --> 00:40:36.080
application.

00:40:36.080 --> 00:40:41.010
So unused classes and unused
methods will be eliminated.

00:40:41.010 --> 00:40:45.920
And the application is just
penalized for what it's using,

00:40:45.920 --> 00:40:49.480
compared to what's being
included in libraries.

00:40:49.480 --> 00:40:53.145
And this is great because it
helps the download time of the

00:40:53.145 --> 00:40:56.280
application, and also helps
the startup time.

00:40:56.280 --> 00:40:57.710
KASPER LUND: It also means that
you can depend on a big

00:40:57.710 --> 00:41:00.670
library, and you only pay for
the small pieces of it you

00:41:00.670 --> 00:41:01.810
actually use.

00:41:01.810 --> 00:41:03.140
LARS BAK: You cannot do
that in JavaScript.

00:41:03.140 --> 00:41:03.880
Why?

00:41:03.880 --> 00:41:05.510
Well, because there's a val.

00:41:05.510 --> 00:41:07.400
Val is a thing that
takes a string and

00:41:07.400 --> 00:41:09.310
converts it into code.

00:41:09.310 --> 00:41:12.150
So you cannot analyze
it statically.

00:41:12.150 --> 00:41:15.670
The second one is, it also has
the with statement that

00:41:15.670 --> 00:41:16.800
introduces [? voodoo, ?]

00:41:16.800 --> 00:41:17.585
scoping.

00:41:17.585 --> 00:41:19.570
You basically have no chance of
figuring out what's being

00:41:19.570 --> 00:41:22.470
accessed in the outer scope.

00:41:22.470 --> 00:41:26.100
So that's much easier in Dart,
and that is what clear

00:41:26.100 --> 00:41:29.010
semantics will give you.

00:41:29.010 --> 00:41:32.800
Tree shaking is already used by
dart2js today, and clearly

00:41:32.800 --> 00:41:37.930
reduces the size of the app,
and also improves startup.

00:41:37.930 --> 00:41:40.440
We are in the process of also
working on a tool that takes

00:41:40.440 --> 00:41:44.230
Dart code, tree shakes it,
and emits Dart code.

00:41:44.230 --> 00:41:47.790
So the Dart code itself will
be easier to start up.

00:41:47.790 --> 00:41:49.970
And that will be based on the
same infrastructure as the

00:41:49.970 --> 00:41:51.520
Dart to JS compiler.

00:41:51.520 --> 00:41:54.170
KASPER LUND: Shaken,
not stirred.

00:41:54.170 --> 00:41:54.890
That's the motto.

00:41:54.890 --> 00:41:56.140
LARS BAK: Yes, James.

00:41:58.350 --> 00:42:02.380
Another thing that should be
really cool and is already

00:42:02.380 --> 00:42:05.990
implemented in the Dart VM
is the Dart snapshots.

00:42:05.990 --> 00:42:11.120
And it's a binary form of the
entire Dart application.

00:42:11.120 --> 00:42:14.610
And our measurements so far
means that you get a 10x

00:42:14.610 --> 00:42:17.840
speedup compared to sourcing
in the application before

00:42:17.840 --> 00:42:19.400
starting up.

00:42:19.400 --> 00:42:21.670
And that's fantastic, because
that means that instead of

00:42:21.670 --> 00:42:25.520
having a one second startup,
you get down below 100

00:42:25.520 --> 00:42:28.810
milliseconds to start
up the application.

00:42:28.810 --> 00:42:30.070
And it's very simple.

00:42:30.070 --> 00:42:33.810
If you do the VM the right way,
you can just load the

00:42:33.810 --> 00:42:38.270
application into the heap, and
then you serialize the heap

00:42:38.270 --> 00:42:40.410
into a binary format.

00:42:40.410 --> 00:42:41.430
Very simple.

00:42:41.430 --> 00:42:43.330
And it's really, really
efficient when

00:42:43.330 --> 00:42:44.670
you start up again.

00:42:44.670 --> 00:42:47.320
What benefits you is you don't
have to do scanning and

00:42:47.320 --> 00:42:50.440
parsing of the source code.

00:42:50.440 --> 00:42:53.160
And also, on mobile devices,
you don't have to spend as

00:42:53.160 --> 00:42:58.070
much CPU resources in loading
in the application, because

00:42:58.070 --> 00:43:03.220
it's just a matter of
deserializing the heap.

00:43:03.220 --> 00:43:03.580
All right.

00:43:03.580 --> 00:43:05.920
KASPER LUND: It's important to
notice that this binary form

00:43:05.920 --> 00:43:07.370
is completely
platform-independent.

00:43:07.370 --> 00:43:09.573
It's the same thing you would
ship to a mobile device, that

00:43:09.573 --> 00:43:11.100
you would ship to the desktop.

00:43:11.100 --> 00:43:14.120
Even if it's like a 64-bit and
a 32-bit machine involved,

00:43:14.120 --> 00:43:15.020
it's the same format.

00:43:15.020 --> 00:43:17.620
So it's not about doing
a per-target

00:43:17.620 --> 00:43:18.680
compilation of any sort.

00:43:18.680 --> 00:43:21.560
This is just a binary form of
the source code, essentially.

00:43:21.560 --> 00:43:24.030
LARS BAK: It doesn't contain
any generic code.

00:43:24.030 --> 00:43:30.150
And it can handle going from a
32-bit machine to a 64-bit

00:43:30.150 --> 00:43:33.690
machine, if you want
to do that.

00:43:33.690 --> 00:43:34.660
All right.

00:43:34.660 --> 00:43:36.450
Now.

00:43:36.450 --> 00:43:37.700
Let's talk about the future.

00:43:44.270 --> 00:43:46.460
One important part of this
project is to design a new

00:43:46.460 --> 00:43:47.570
programming language.

00:43:47.570 --> 00:43:51.900
And we are pretty much done
with that design process.

00:43:51.900 --> 00:43:55.620
We have a form of specification
made.

00:43:55.620 --> 00:43:58.910
You can download it and read it
if you want to, with a few

00:43:58.910 --> 00:44:00.000
exceptions.

00:44:00.000 --> 00:44:02.990
We have a few things
we will put in.

00:44:02.990 --> 00:44:07.170
One is we will probably
eliminate interfaces, because

00:44:07.170 --> 00:44:09.180
we also have abstract classes,
and they work

00:44:09.180 --> 00:44:10.810
exactly the same way.

00:44:10.810 --> 00:44:14.260
So these have just simplified
the language.

00:44:14.260 --> 00:44:17.610
We'll also introduce mixins,
which allow you to do

00:44:17.610 --> 00:44:22.150
co-sharing across inheritance
hierarchies.

00:44:22.150 --> 00:44:26.120
That'll come in after
version one of Dart.

00:44:26.120 --> 00:44:29.070
And then of course we'll have
some support for annotations,

00:44:29.070 --> 00:44:33.430
because most IDEs say they
want annotations.

00:44:33.430 --> 00:44:36.850
Java programmers want
annotations.

00:44:36.850 --> 00:44:38.120
So that's how it is.

00:44:38.120 --> 00:44:38.760
But anyway.

00:44:38.760 --> 00:44:40.050
You should look at the
specification.

00:44:40.050 --> 00:44:42.070
It's pretty much done, and
I hope you like it.

00:44:42.070 --> 00:44:45.140
Otherwise send us comments.

00:44:45.140 --> 00:44:48.520
So this is our timeline
we have on the

00:44:48.520 --> 00:44:50.880
whiteboard in Denmark.

00:44:50.880 --> 00:44:53.510
KASPER LUND: As you can tell,
up to 2009 we were busy

00:44:53.510 --> 00:44:55.920
hacking on JavaScript,
making that faster.

00:44:55.920 --> 00:44:59.330
And at some point Lars and I
decided to try to do something

00:44:59.330 --> 00:45:00.440
a bit simpler than that.

00:45:00.440 --> 00:45:02.780
We called that Spot, and
that was in 2010.

00:45:02.780 --> 00:45:07.160
And we spent three months on
hacking up this new virtual

00:45:07.160 --> 00:45:08.630
machine, a new programming
language, and

00:45:08.630 --> 00:45:09.870
a new set of libraries.

00:45:09.870 --> 00:45:11.640
And that was a lot of fun.

00:45:11.640 --> 00:45:14.460
At some point it was so
promising that we decided to

00:45:14.460 --> 00:45:19.150
turn it into a real project, and
it got re-branded to Dart.

00:45:19.150 --> 00:45:21.160
And that's where we're at now.

00:45:21.160 --> 00:45:26.480
So in 2011 we introduced Dart
as a technology preview, and

00:45:26.480 --> 00:45:28.150
we've been getting a
lot of very good

00:45:28.150 --> 00:45:30.500
feedback from that process.

00:45:30.500 --> 00:45:34.940
So this here is all about making
Dart robust and really,

00:45:34.940 --> 00:45:36.180
really fast.

00:45:36.180 --> 00:45:39.090
And next year?

00:45:39.090 --> 00:45:41.250
LARS BAK: Success.

00:45:41.250 --> 00:45:42.500
KASPER LUND: That will do.

00:45:45.970 --> 00:45:50.000
LARS BAK: So what we're working
on hard today is to

00:45:50.000 --> 00:45:52.970
make sure that you have a
developer release in your

00:45:52.970 --> 00:45:56.410
hands later this year, so you
can start relying on the

00:45:56.410 --> 00:45:59.290
libraries, the performance
of Dart, and building

00:45:59.290 --> 00:46:02.280
applications on top of it.

00:46:02.280 --> 00:46:04.910
The release will include
the language--

00:46:04.910 --> 00:46:08.020
fixed, hopefully, for
the first version--

00:46:08.020 --> 00:46:10.790
libraries for the web and server
development, so you can

00:46:10.790 --> 00:46:14.500
also write Dart applications
on the server side.

00:46:14.500 --> 00:46:16.320
We have a programming
environment.

00:46:16.320 --> 00:46:20.680
So some of it is based
on Eclipse.

00:46:20.680 --> 00:46:24.100
And we also have a standalone
virtual machine, that's also

00:46:24.100 --> 00:46:26.690
been integrated into
the Chromium build.

00:46:26.690 --> 00:46:30.180
And that was the Dartium browser
you saw in the demo.

00:46:30.180 --> 00:46:33.250
And then we have this translator
to JavaScript that

00:46:33.250 --> 00:46:37.950
allows us to be compatible
with most browsers.

00:46:37.950 --> 00:46:39.200
So this is exciting.

00:46:41.740 --> 00:46:45.590
KASPER LUND: So in addition to
all that, Dart is already now,

00:46:45.590 --> 00:46:48.130
and will remain, a fully open
source product here.

00:46:48.130 --> 00:46:52.150
Dart is available under a very
permissive BSD license.

00:46:52.150 --> 00:46:53.940
So if you want to take it,
run with it, use it for

00:46:53.940 --> 00:46:56.160
something, have fun.

00:46:56.160 --> 00:46:58.630
The entire idea is to try to
foster innovation in this

00:46:58.630 --> 00:47:01.210
space, so it makes a lot of
sense for us to just put all

00:47:01.210 --> 00:47:04.830
the bits and pieces out there,
and have a community based

00:47:04.830 --> 00:47:05.890
around that.

00:47:05.890 --> 00:47:07.430
It's developed in the open.

00:47:07.430 --> 00:47:09.900
All our code reviews are on
public mailing lists, and all

00:47:09.900 --> 00:47:12.120
the build bots are for
everybody to see.

00:47:12.120 --> 00:47:16.310
It makes it much easier for us
to interact with members of

00:47:16.310 --> 00:47:19.790
the community that have good
ideas or good feedback.

00:47:19.790 --> 00:47:23.120
Already now we have a fairly
active community, and we're

00:47:23.120 --> 00:47:26.600
getting a lot of very helpful
and very good feedback on new

00:47:26.600 --> 00:47:28.880
ideas that we circulate
on the mailing list.

00:47:28.880 --> 00:47:32.360
So if you're interested in
joining in, or at least trying

00:47:32.360 --> 00:47:34.910
it out, you should go to some
of the online resources we

00:47:34.910 --> 00:47:35.910
have available.

00:47:35.910 --> 00:47:38.410
The primary site is
dartlang.org.

00:47:38.410 --> 00:47:41.630
And there you'll find a lot of
information about how to

00:47:41.630 --> 00:47:44.680
download the SDK and the
editor, and try it out.

00:47:44.680 --> 00:47:49.440
So please try it out, continue
to give us good feedback.

00:47:49.440 --> 00:47:51.880
LARS BAK: And one interesting
note is that since we released

00:47:51.880 --> 00:47:57.930
it as a preview last fall,
we have had a few

00:47:57.930 --> 00:47:59.710
changes to that platform.

00:47:59.710 --> 00:48:02.760
There's now 9,000 revisions
since last fall.

00:48:02.760 --> 00:48:04.870
So you can imagine that there's
a lot of change lists

00:48:04.870 --> 00:48:06.260
coming out every day.

00:48:06.260 --> 00:48:09.460
And we're really serious about
making this fast and

00:48:09.460 --> 00:48:10.810
consistent.

00:48:10.810 --> 00:48:12.895
KASPER LUND: It's fun to work
on a project like that, that

00:48:12.895 --> 00:48:13.900
moves really quickly.

00:48:13.900 --> 00:48:16.830
And it's fun to see people
that use it being excited

00:48:16.830 --> 00:48:20.000
about the new changes, and
adapting their existing code

00:48:20.000 --> 00:48:22.430
bases to new, interesting
things that

00:48:22.430 --> 00:48:23.190
pop up in the language.

00:48:23.190 --> 00:48:24.440
So it's been a fun process.

00:48:27.600 --> 00:48:30.380
So there's even more about
Dart at this Google IO.

00:48:30.380 --> 00:48:35.100
So this was a very sort of high
level presentation about

00:48:35.100 --> 00:48:36.980
Dart, and the motivation
behind it.

00:48:36.980 --> 00:48:40.390
If you're interested in more
details, I suggest you go to

00:48:40.390 --> 00:48:44.710
the next talk, at 2:45 in Room
3, which is about building web

00:48:44.710 --> 00:48:45.590
apps in Dart.

00:48:45.590 --> 00:48:48.480
And you'll get more hands-on
experience with what it is to

00:48:48.480 --> 00:48:50.980
build something new and
exciting in Dart.

00:48:50.980 --> 00:48:53.070
There's also a talk about
migrating code that's written

00:48:53.070 --> 00:48:56.970
in GWT to Dart in the
same room, Room 3.

00:48:56.970 --> 00:48:59.200
And during the entire afternoon
here, from now,

00:48:59.200 --> 00:49:02.780
essentially, to fairly late, we
have Dart office hours on

00:49:02.780 --> 00:49:03.650
the Chrome demo floor.

00:49:03.650 --> 00:49:06.660
So if you want to come chat with
us there, feel free to

00:49:06.660 --> 00:49:08.840
drop by, and if you have
questions we'll be very happy

00:49:08.840 --> 00:49:10.910
to try to answer them.

00:49:10.910 --> 00:49:15.360
Tomorrow, if you're really
Darty, you should go to our

00:49:15.360 --> 00:49:18.190
Bullseye, Your First Dart App
code lab, where you'll get a

00:49:18.190 --> 00:49:21.680
chance to do some hands-on work
with the environment and

00:49:21.680 --> 00:49:22.930
the product.

00:49:25.770 --> 00:49:27.310
LARS BAK: And we are pretty
much at the end now.

00:49:27.310 --> 00:49:29.280
So this is a summary slide.

00:49:29.280 --> 00:49:32.580
I hope we managed to convince
you that Dart is a simple and

00:49:32.580 --> 00:49:34.500
unsurprising object-oriented
language that

00:49:34.500 --> 00:49:37.040
should be easy to use.

00:49:37.040 --> 00:49:43.060
And it allows you to write
structured code, and also

00:49:43.060 --> 00:49:46.830
develop tools that can analyze
these programs.

00:49:46.830 --> 00:49:48.760
And it works on modern
browsers.

00:49:48.760 --> 00:49:51.810
So we've had a lot of experience
in implementing

00:49:51.810 --> 00:49:54.560
virtual machines for various
object-oriented languages.

00:49:54.560 --> 00:49:59.810
This is the first time we are
doing a new language, and it's

00:49:59.810 --> 00:50:00.490
a challenge.

00:50:00.490 --> 00:50:01.610
But it's fun.

00:50:01.610 --> 00:50:03.110
So thank you for listening.

00:50:03.110 --> 00:50:06.400
And if you have any questions,
please line up in front of the

00:50:06.400 --> 00:50:10.102
mics so we can capture
what you're asking.

00:50:10.102 --> 00:50:13.320
KASPER LUND: Yeah, the final
thing here is to just make a

00:50:13.320 --> 00:50:16.670
mental note of the fact that
it's fairly easy to build a

00:50:16.670 --> 00:50:19.630
really high-performance, fast
virtual machine, at least

00:50:19.630 --> 00:50:20.840
compared to building
a new language.

00:50:20.840 --> 00:50:23.401
So we're having a lot of fun.

00:50:23.401 --> 00:50:46.560
[APPLAUSE]

00:50:46.560 --> 00:50:47.930
KASPER LUND: Go ahead.

00:50:47.930 --> 00:50:48.630
AUDIENCE: Hello?

00:50:48.630 --> 00:50:49.970
KASPER LUND: Yes, it's on.

00:50:49.970 --> 00:50:51.660
AUDIENCE: Is it the
same JavaScript--

00:50:51.660 --> 00:50:54.840
it's cross-browser, or do you
have different versions for

00:50:54.840 --> 00:50:55.920
different browsers?

00:50:55.920 --> 00:50:57.880
KASPER LUND: So we generate
one version of

00:50:57.880 --> 00:50:59.536
the JavaScript code.

00:50:59.536 --> 00:51:01.460
And there are some parts
in there that are

00:51:01.460 --> 00:51:04.010
browser-specific, but right
now we just compile one

00:51:04.010 --> 00:51:07.780
version that deals with all the
differences in one file.

00:51:07.780 --> 00:51:10.910
So one output, one JavaScript
file that works across all the

00:51:10.910 --> 00:51:12.550
modern browsers.

00:51:12.550 --> 00:51:13.800
AUDIENCE: One other question.

00:51:17.280 --> 00:51:21.310
You've shown us the language,
but the APIs that you use to

00:51:21.310 --> 00:51:25.910
access the DOM and the other
elements of the browser, are

00:51:25.910 --> 00:51:29.220
those familiar?

00:51:29.220 --> 00:51:31.880
LARS BAK: They are the same.

00:51:31.880 --> 00:51:34.550
We're using the same DOM
interface as JavaScript,

00:51:34.550 --> 00:51:38.190
except a few changes to make
it more consistent.

00:51:38.190 --> 00:51:40.840
And we call it the Dart
HTML library.

00:51:40.840 --> 00:51:43.770
So it's also available when
you download Dart.

00:51:43.770 --> 00:51:46.290
If you go to the next talk about
Dart, you'll see how

00:51:46.290 --> 00:51:49.250
that's being used for building
web applications.

00:51:49.250 --> 00:51:52.170
But this talk was mostly about
the language, and not how to

00:51:52.170 --> 00:51:54.270
hook it up to the web.

00:51:54.270 --> 00:51:57.786
LARS BAK: If you drop by the
Chrome demo floor, I'm sure

00:51:57.786 --> 00:51:59.340
someone can show you what
it is and how it

00:51:59.340 --> 00:52:03.880
looks at the API level.

00:52:03.880 --> 00:52:05.590
AUDIENCE: I had a question, I
guess more about the Dart

00:52:05.590 --> 00:52:07.070
editor, but.

00:52:07.070 --> 00:52:09.430
I've played with it a little
bit, and I was wondering if

00:52:09.430 --> 00:52:12.610
there's plans to make an
official Eclipse plugin, so

00:52:12.610 --> 00:52:14.560
that we can get all the version
control, and other

00:52:14.560 --> 00:52:17.460
features of the Eclipse
platform.

00:52:17.460 --> 00:52:20.970
LARS BAK: There's been a lot of
requests to get a plugin.

00:52:20.970 --> 00:52:23.850
And behind the scenes it's
sort of the same.

00:52:23.850 --> 00:52:26.030
So we will wrap it
up at some point.

00:52:26.030 --> 00:52:28.910
I cannot give you a date when it
is there, but it will come.

00:52:32.920 --> 00:52:34.390
KASPER LUND: Take one more here,
and then we'll switch to

00:52:34.390 --> 00:52:36.070
that side for a while.

00:52:36.070 --> 00:52:36.345
AUDIENCE: Yeah.

00:52:36.345 --> 00:52:36.620
Sorry.

00:52:36.620 --> 00:52:39.970
So what sort of integration,
or is there any integration

00:52:39.970 --> 00:52:44.110
with Google Closure compiler
for JavaScript?

00:52:44.110 --> 00:52:46.780
Like, do you guys pump out
minified, optimized

00:52:46.780 --> 00:52:47.330
JavaScript?

00:52:47.330 --> 00:52:49.740
Or is it just unminified and
then you pump it through

00:52:49.740 --> 00:52:50.990
Closure afterwards?

00:52:50.990 --> 00:52:53.340
KASPER LUND: So right now what
we're doing is we're

00:52:53.340 --> 00:52:57.370
generating unminified but
optimized output.

00:52:57.370 --> 00:52:59.680
And we're pushing hard on making
those optimizations

00:52:59.680 --> 00:53:00.180
even better.

00:53:00.180 --> 00:53:02.670
And we are working on
minification as well.

00:53:02.670 --> 00:53:05.020
So we don't have any immediate
plans of using the Closure

00:53:05.020 --> 00:53:07.320
compiler for doing this, because
sometimes we actually

00:53:07.320 --> 00:53:11.240
use a lot of information, when
you go from our input to

00:53:11.240 --> 00:53:14.270
JavaScript with type annotations
in common.

00:53:14.270 --> 00:53:16.910
So we want to try to avoid
losing that kind of

00:53:16.910 --> 00:53:19.100
information, and essentially
do the minification and

00:53:19.100 --> 00:53:21.750
optimizations ourselves, based
on the fact that we understand

00:53:21.750 --> 00:53:25.090
the Dart semantics even better
than the Closure compiler can.

00:53:25.090 --> 00:53:27.660
LARS BAK: Minification is
actually very simple when you

00:53:27.660 --> 00:53:31.280
have all the information
from the compiler.

00:53:31.280 --> 00:53:36.220
So it's much easier to do it
ourselves than go through the

00:53:36.220 --> 00:53:38.090
Closure compiler for
minification.

00:53:38.090 --> 00:53:40.980
KASPER LUND: We also have a need
for minifying Dart code,

00:53:40.980 --> 00:53:42.780
to make the download of
Dart code smaller.

00:53:42.780 --> 00:53:45.110
So we will produce something
like a Dart-to-Dart

00:53:45.110 --> 00:53:47.380
translator, that minifies
and optimizes.

00:53:47.380 --> 00:53:47.840
AUDIENCE: Cool.

00:53:47.840 --> 00:53:49.700
And just one other quick
question, is there any ability

00:53:49.700 --> 00:53:54.640
to at runtime to load in
additional code, if you're

00:53:54.640 --> 00:53:55.410
using binaries?

00:53:55.410 --> 00:53:58.120
Or is it all done at
compile time only?

00:53:58.120 --> 00:54:00.480
KASPER LUND: Actually we use
this concept that we actually

00:54:00.480 --> 00:54:02.210
didn't introduce much here.

00:54:02.210 --> 00:54:03.120
It's isolates.

00:54:03.120 --> 00:54:06.790
And that's one way of creating
a completely new world that

00:54:06.790 --> 00:54:09.800
you can populate with new,
dynamically loaded code.

00:54:09.800 --> 00:54:11.820
And it's still a work in
progress, it's something that

00:54:11.820 --> 00:54:13.430
we will be pushing more on.

00:54:13.430 --> 00:54:15.430
LARS BAK: There's also
another way of

00:54:15.430 --> 00:54:16.880
dynamically loading code.

00:54:16.880 --> 00:54:21.220
We have a way of lazy loading
an entire library.

00:54:21.220 --> 00:54:23.686
So when you say import to a
library, we'll say it should

00:54:23.686 --> 00:54:25.600
be lazy loaded.

00:54:25.600 --> 00:54:28.310
And you just have to activate
the loading.

00:54:28.310 --> 00:54:29.680
And you cannot use the
[? interpoints ?]

00:54:29.680 --> 00:54:31.440
that the library before it has
been completely loaded.

00:54:31.440 --> 00:54:33.786
If you try to use it, it
throws an exception.

00:54:36.736 --> 00:54:37.680
AUDIENCE: I just have
a question.

00:54:37.680 --> 00:54:40.620
What is the recipe for
server [INAUDIBLE]?

00:54:40.620 --> 00:54:45.321
So Dart is on the client side
sort of language, but how do

00:54:45.321 --> 00:54:49.570
you envision the communication
between server and client

00:54:49.570 --> 00:54:50.970
serialization?

00:54:50.970 --> 00:54:53.210
[INAUDIBLE]

00:54:53.210 --> 00:54:55.080
LARS BAK: So certainly
we support JSON.

00:54:55.080 --> 00:54:59.060
So you can use the JSON format
to move stuff back and forth.

00:54:59.060 --> 00:55:02.270
The language is not a client
language, it's

00:55:02.270 --> 00:55:03.640
also a server language.

00:55:03.640 --> 00:55:05.520
And we have a standard
loan VM you can run

00:55:05.520 --> 00:55:06.880
on the server side.

00:55:06.880 --> 00:55:10.590
And it has an I/O library
that supports--

00:55:10.590 --> 00:55:11.420
[INAUDIBLE]

00:55:11.420 --> 00:55:16.180
asynchronous way of doing I/O.
So you can write server code

00:55:16.180 --> 00:55:19.700
in Dart, if you want to.

00:55:19.700 --> 00:55:22.580
KASPER LUND: There's some work
going on with using something

00:55:22.580 --> 00:55:23.650
like [? protobufs ?]

00:55:23.650 --> 00:55:26.720
to communicate between
client and server.

00:55:26.720 --> 00:55:28.940
There's a lot of community
interest in this area, too.

00:55:28.940 --> 00:55:31.990
So it is very important to
stress that Dart runs just

00:55:31.990 --> 00:55:33.080
fine on the server.

00:55:33.080 --> 00:55:35.630
So you can write your code, the
client code and the server

00:55:35.630 --> 00:55:38.820
code, in the same language, and
have that interoperate in

00:55:38.820 --> 00:55:40.070
a nice way.

00:55:44.460 --> 00:55:47.260
AUDIENCE: Does Dart support
compile time [INAUDIBLE], so

00:55:47.260 --> 00:55:51.780
that I will be able to calculate
optimal parameters

00:55:51.780 --> 00:55:55.250
before generating the code?

00:55:55.250 --> 00:55:59.790
A good example of the use of
that is being articulated in

00:55:59.790 --> 00:56:01.940
[INAUDIBLE]

00:56:01.940 --> 00:56:05.930
and all the [INAUDIBLE]
programming language.

00:56:05.930 --> 00:56:07.550
KASPER LUND: We have some
support for that.

00:56:07.550 --> 00:56:10.480
It's not completely general, but
it's very simple, and it

00:56:10.480 --> 00:56:11.170
works well.

00:56:11.170 --> 00:56:15.650
That's in the form of what we
call compile time expressions.

00:56:15.650 --> 00:56:17.330
There's a subset of the
language, essentially, that

00:56:17.330 --> 00:56:21.530
you can use for building compile
time expressions.

00:56:21.530 --> 00:56:25.090
And that includes user-defined
data structures, we call them

00:56:25.090 --> 00:56:28.760
const objects, that are actually
built at compile time

00:56:28.760 --> 00:56:29.770
rather than at runtime.

00:56:29.770 --> 00:56:31.620
So there's some support
in the language there.

00:56:31.620 --> 00:56:34.020
You should drop by the
demo floor, and I can

00:56:34.020 --> 00:56:35.640
show you how it works.

00:56:35.640 --> 00:56:38.360
LARS BAK: So for instance, in
the point example, if you make

00:56:38.360 --> 00:56:41.240
the fields final, you
can make a const

00:56:41.240 --> 00:56:43.220
constructor for the point.

00:56:43.220 --> 00:56:46.260
So you make instances of point
as compile time expressions,

00:56:46.260 --> 00:56:49.700
that are compiled
at compile time.

00:56:49.700 --> 00:56:50.950
AUDIENCE: [INAUDIBLE]

00:56:55.120 --> 00:57:02.320
AUDIENCE: What did you mean
by success for 2013?

00:57:02.320 --> 00:57:06.350
LARS BAK: That we still have
a job working on Dart.

00:57:06.350 --> 00:57:07.600
No.

00:57:10.540 --> 00:57:13.080
That was a joke.

00:57:13.080 --> 00:57:19.790
Success means that in 2013 we
have a stable system that's

00:57:19.790 --> 00:57:25.550
out in Chrome, and we have many
real projects outside

00:57:25.550 --> 00:57:29.930
Google, also working on
Dart and using Dart

00:57:29.930 --> 00:57:31.010
for deploying code.

00:57:31.010 --> 00:57:33.160
This is the ultimate goal.

00:57:33.160 --> 00:57:37.040
The premise here is to make sure
programmers will get a

00:57:37.040 --> 00:57:40.700
much better platform for
writing applications.

00:57:40.700 --> 00:57:43.030
And if you cannot demonstrate
that,

00:57:43.030 --> 00:57:44.770
that's certainly a failure.

00:57:44.770 --> 00:57:47.650
AUDIENCE: So do you expect
any [INAUDIBLE]

00:57:47.650 --> 00:57:56.250
is going to [INAUDIBLE], since
it's already compatible over

00:57:56.250 --> 00:57:58.990
most of of the JavaScript
stuff, that's OK?

00:57:58.990 --> 00:58:02.450
LARS BAK: So your question is,
will the other browser vendors

00:58:02.450 --> 00:58:06.040
take the Dart VM and integrate
it into their browsers?

00:58:06.040 --> 00:58:08.430
Well, I cannot answer that,
since I'm not controlling what

00:58:08.430 --> 00:58:09.390
they're doing.

00:58:09.390 --> 00:58:12.320
But what I can do is, I can
make sure that Dart is an

00:58:12.320 --> 00:58:13.310
appealing offer.

00:58:13.310 --> 00:58:16.850
So it's out there,
it's open source.

00:58:16.850 --> 00:58:20.120
And if we can demonstrate Dart
applications when running with

00:58:20.120 --> 00:58:22.880
a native VM has instant
startup, and better

00:58:22.880 --> 00:58:28.390
performance than a similar
JavaScript program, it seems

00:58:28.390 --> 00:58:32.410
very appealing to me, if I was
sitting in the other camp and

00:58:32.410 --> 00:58:34.480
then integrated.

00:58:34.480 --> 00:58:38.270
And we hope that will
happen of course.

00:58:38.270 --> 00:58:40.230
AUDIENCE: I'm curious if all of
the Dart language features

00:58:40.230 --> 00:58:41.320
compile to JavaScript?

00:58:41.320 --> 00:58:44.590
And I'm specifically curious
about covariant generics.

00:58:44.590 --> 00:58:46.270
KASPER LUND: So, yeah.

00:58:46.270 --> 00:58:48.770
So covariant generics are
reasonably easy to compile to

00:58:48.770 --> 00:58:49.180
JavaScript.

00:58:49.180 --> 00:58:51.230
There's nothing in JavaScript
that hinders that.

00:58:51.230 --> 00:58:55.710
There's one area where it's
problematic to have the full

00:58:55.710 --> 00:58:58.790
Dart language implemented when
translated to JavaScript, and

00:58:58.790 --> 00:59:00.070
that's numerics.

00:59:00.070 --> 00:59:02.790
JavaScript does not have any
efficient way of having

00:59:02.790 --> 00:59:05.010
arbitrary sized integers,
for instance.

00:59:05.010 --> 00:59:07.450
Everything is, when it comes
to numbers, a double in

00:59:07.450 --> 00:59:08.250
JavaScript.

00:59:08.250 --> 00:59:11.790
So there are some restrictions
on how numbers work in Dart

00:59:11.790 --> 00:59:14.030
when compiled to JavaScript,
compared to what you get on

00:59:14.030 --> 00:59:15.260
the native VM.

00:59:15.260 --> 00:59:16.520
It's a hard problem to solve.

00:59:16.520 --> 00:59:18.990
We're looking at ways
of doing that.

00:59:18.990 --> 00:59:21.460
But for now that's the one
area where there's a real

00:59:21.460 --> 00:59:23.150
difference between
the two setups.

00:59:23.150 --> 00:59:26.300
LARS BAK: We have discussed
caving in, and just having

00:59:26.300 --> 00:59:28.720
numbers like in JavaScript.

00:59:28.720 --> 00:59:30.610
But boy, we really like
integers, and the

00:59:30.610 --> 00:59:32.140
semantics of integers.

00:59:32.140 --> 00:59:34.700
And mixing them all up,
I think, is a mistake.

00:59:34.700 --> 00:59:37.810
So that's the reason why,
precisely in this area, that's

00:59:37.810 --> 00:59:39.610
a little bit of discrepancy
between the native

00:59:39.610 --> 00:59:47.130
implementation and the
JavaScript-generated code.

00:59:47.130 --> 00:59:48.535
Yes?

00:59:48.535 --> 00:59:51.270
AUDIENCE: Is Google going
to promote Dart over

00:59:51.270 --> 00:59:52.520
GWT down the road?

00:59:55.660 --> 00:59:59.640
LARS BAK: GWT already has a
lot of customers, and it's

00:59:59.640 --> 01:00:01.550
still supported.

01:00:01.550 --> 01:00:04.720
We think, since we have done the
Dart part and have nothing

01:00:04.720 --> 01:00:08.310
to do with the GWT part, that
this is a better fit for the

01:00:08.310 --> 01:00:09.600
web platform.

01:00:09.600 --> 01:00:14.390
And during the presentation
we were talking about this

01:00:14.390 --> 01:00:17.790
importance of immediacy when
doing programming.

01:00:17.790 --> 01:00:19.740
The fact that you can change the
file and get it up running

01:00:19.740 --> 01:00:23.770
right away, where there's no
tool chain in between you and

01:00:23.770 --> 01:00:25.520
debugging the program--

01:00:25.520 --> 01:00:29.460
this is something that's hard to
do in GWT, where it's much,

01:00:29.460 --> 01:00:32.690
much easier to do in Dart.

01:00:32.690 --> 01:00:35.260
At the same time, in Dart
you can avoid the types.

01:00:35.260 --> 01:00:38.480
So if you prototype, you can do
crazy stuff and don't think

01:00:38.480 --> 01:00:40.640
about the types, it'll
still work.

01:00:40.640 --> 01:00:45.190
And I think that really will
help you accelerate your

01:00:45.190 --> 01:00:47.890
prototyping of your
application.

01:00:47.890 --> 01:00:51.340
AUDIENCE: Also I was just
curious about, for a project

01:00:51.340 --> 01:00:57.630
of similar size, how does Dart
stack up against GWT in terms

01:00:57.630 --> 01:01:00.010
of code generation,
[INAUDIBLE]

01:01:00.010 --> 01:01:01.540
JavaScript code?

01:01:01.540 --> 01:01:05.300
Is it smaller in size,
or larger in size?

01:01:09.120 --> 01:01:11.690
LARS BAK: I don't have
comparable numbers right now.

01:01:11.690 --> 01:01:15.870
What I can tell you is that the
generated JavaScript code

01:01:15.870 --> 01:01:17.310
from Dart is fairly
minimal now.

01:01:17.310 --> 01:01:20.320
You should try it out.

01:01:20.320 --> 01:01:23.150
And we expected to be
much smaller than

01:01:23.150 --> 01:01:24.280
what GWT can generate.

01:01:24.280 --> 01:01:28.430
I think the GWT system is also
doing a lot of tree shaking

01:01:28.430 --> 01:01:32.130
before they generate
JavaScript code.

01:01:32.130 --> 01:01:36.310
But they have a lot of legacy
stuff related to the Java

01:01:36.310 --> 01:01:37.390
libraries they're using.

01:01:37.390 --> 01:01:39.550
But I don't have numbers
right now.

01:01:39.550 --> 01:01:42.820
So go home and measure it.

01:01:42.820 --> 01:01:43.340
Yes.

01:01:43.340 --> 01:01:45.660
KASPER LUND: This will be the
last question, by the way.

01:01:45.660 --> 01:01:47.120
AUDIENCE: Two questions.

01:01:47.120 --> 01:01:50.550
So first, the syntax
for importing a

01:01:50.550 --> 01:01:53.160
module is pound import.

01:01:53.160 --> 01:01:56.730
Do you have some sort of
preprocessor that you can use,

01:01:56.730 --> 01:01:59.075
with if defs and stuff?

01:01:59.075 --> 01:01:59.950
KASPER LUND: No.

01:01:59.950 --> 01:02:02.400
But it is true that right now,
the way to write an import is

01:02:02.400 --> 01:02:04.010
using a pound import.

01:02:04.010 --> 01:02:06.700
It is to try to make it stick
out, and it certainly does.

01:02:06.700 --> 01:02:09.650
And we are thinking about making
it look more like an

01:02:09.650 --> 01:02:11.070
integrated part of the
language, rather than

01:02:11.070 --> 01:02:12.410
preprocessing.

01:02:12.410 --> 01:02:16.220
But it was designed to make
it stick out, and it does.

01:02:16.220 --> 01:02:20.930
AUDIENCE: Secondly, for
isolates, are they implemented

01:02:20.930 --> 01:02:22.340
as threads?

01:02:22.340 --> 01:02:25.230
Or is it somehow a thin--

01:02:25.230 --> 01:02:27.450
KASPER LUND: Thread.

01:02:27.450 --> 01:02:29.600
LARS BAK: Since we translate
to JavaScript and it has to

01:02:29.600 --> 01:02:32.630
run on top of a single
JavaScript engine, we have to

01:02:32.630 --> 01:02:33.760
multiplex between them.

01:02:33.760 --> 01:02:35.916
But you can run isolates.

01:02:35.916 --> 01:02:38.100
AUDIENCE: But in the
Dart VM itself?

01:02:38.100 --> 01:02:40.010
LARS BAK: Yes, they're running
completely independent, so

01:02:40.010 --> 01:02:42.890
that you can have isolates
running in parallel.

01:02:42.890 --> 01:02:44.490
AUDIENCE: So they are
actual threads?

01:02:44.490 --> 01:02:46.110
KASPER LUND: They don't have
to be [? native ?]

01:02:46.110 --> 01:02:46.350
threads.

01:02:46.350 --> 01:02:47.890
There is a thread pull
implementation that we're

01:02:47.890 --> 01:02:51.620
working on, where essentially
you'll get as many threads

01:02:51.620 --> 01:02:52.880
running as you need to--

01:02:52.880 --> 01:02:55.600
as the amount of parallels
you have in your program.

01:02:55.600 --> 01:02:58.350
So it's not tied to one thread,
and it's more like a

01:02:58.350 --> 01:03:00.800
thin threading model.

01:03:00.800 --> 01:03:03.340
LARS BAK: So for instance, if
the isolate is not active it

01:03:03.340 --> 01:03:06.370
doesn't have to have a native
thread bound to it.

01:03:06.370 --> 01:03:10.560
AUDIENCE: Does it have a
pre-allocated execution stack?

01:03:10.560 --> 01:03:12.950
Fixed size stack?

01:03:12.950 --> 01:03:14.800
KASPER LUND: No, so, everything
is asynchronous.

01:03:14.800 --> 01:03:15.660
There's no blocking.

01:03:15.660 --> 01:03:17.490
So you actually don't
need to do that.

01:03:17.490 --> 01:03:20.880
You just have to return from
your isolate at that point.

01:03:20.880 --> 01:03:23.470
It is an asynchronous model,
so there are no execution

01:03:23.470 --> 01:03:25.100
stacks stuck on native
threads or anything.

01:03:25.100 --> 01:03:26.600
So it's very simple that way.

01:03:26.600 --> 01:03:29.700
LARS BAK: So we are using the
native execution stack when

01:03:29.700 --> 01:03:31.430
executing an isolate.

01:03:31.430 --> 01:03:32.480
KASPER LUND: Thanks
for staying for

01:03:32.480 --> 01:03:34.200
the Q&amp;A. We're done.

01:03:34.200 --> 01:03:35.450
LARS BAK: Thank you.

