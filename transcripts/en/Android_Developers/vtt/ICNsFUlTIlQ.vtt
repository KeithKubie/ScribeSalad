WEBVTT
Kind: captions
Language: en

00:00:00.550 --> 00:00:06.030
&gt;&gt;Joe Malin: Hello, and welcome once again
to Android Developer Office Hours.

00:00:06.030 --> 00:00:07.600
My name is Joe Malin.

00:00:07.600 --> 00:00:08.600
I'm your moderator.

00:00:08.600 --> 00:00:11.390
To my right is Trevor Johns.

00:00:11.390 --> 00:00:15.430
Beyond him is Jeff Sharkey and Reto Meier.

00:00:15.430 --> 00:00:20.609
At the producer's panel is Robert Ly.

00:00:20.609 --> 00:00:27.980
I can't think of anything else to say at this
moment except that our topic for today is

00:00:27.980 --> 00:00:28.980
performance.

00:00:28.980 --> 00:00:31.599
&gt;&gt;Reto Meier: More importantly, it's efficiency.

00:00:31.599 --> 00:00:40.129
&gt;&gt;Malin: And efficiency, sorry.

00:00:40.129 --> 00:00:42.260
Efficiency.

00:00:42.260 --> 00:01:01.450
[indistinct conversation]
[video game music and sound effects playing]

00:01:01.450 --> 00:01:05.710
&gt;&gt;Malin: Great.

00:01:05.710 --> 00:01:06.870
Thank you very much.

00:01:06.870 --> 00:01:10.050
Shout out your questions.

00:01:10.050 --> 00:01:17.570
You can get into the Hangout and call them
in, or you can type them in, or whatever you

00:01:17.570 --> 00:01:19.000
want to do.

00:01:19.000 --> 00:01:22.300
For the moment, since we don't have any of
those from the Hangout, we're going to go

00:01:22.300 --> 00:01:26.290
to Moderator and take some of the questions
that have been entered already.

00:01:26.290 --> 00:01:31.040
The first question is: "Is there a simple
way to get distinct results from the contacts

00:01:31.040 --> 00:01:32.040
provider?

00:01:32.040 --> 00:01:34.560
I used a loader manager to bring the cursor
loader.

00:01:34.560 --> 00:01:40.150
The cursor's past one adapter of an auto complete
text field, but I did dupes."

00:01:40.150 --> 00:01:43.880
I will try to answer this.

00:01:43.880 --> 00:01:48.900
If the person that asked this is online, I
would like to know more about exactly what

00:01:48.900 --> 00:01:50.090
you're trying to do.

00:01:50.090 --> 00:01:56.410
My guess is what you-- based on what you've
said--, you are getting duplicates because

00:01:56.410 --> 00:02:03.610
there are distinct records in the provider
for the same person.

00:02:03.610 --> 00:02:06.220
That's the way the provider is supposed to
work.

00:02:06.220 --> 00:02:08.390
You will not--.

00:02:08.390 --> 00:02:18.590
The provider is set up so that different versions
of the same person, from different sources,

00:02:18.590 --> 00:02:22.030
are recorded as distinct records.

00:02:22.030 --> 00:02:24.640
The duplicates are not eliminated.

00:02:24.640 --> 00:02:30.130
What happens is they're aggregated into a
single record that points to all these different

00:02:30.130 --> 00:02:31.130
versions.

00:02:31.130 --> 00:02:32.130
&gt;&gt;Johns: Yeah.

00:02:32.130 --> 00:02:38.190
For example, you could have your-- a contact
from your Google contact book as well as the

00:02:38.190 --> 00:02:41.300
data that's retrieved from Google+, that the
user themself entered.

00:02:41.300 --> 00:02:42.300
&gt;&gt;Malin: Right.

00:02:42.300 --> 00:02:48.910
Depending on how you access the provider,
you could get a person's record based on their

00:02:48.910 --> 00:02:55.160
personal Gmail, their work Gmail, Google+,
etcetera.

00:02:55.160 --> 00:03:03.140
The documentation for the contacts provider
that's on developer.android.com explains to

00:03:03.140 --> 00:03:11.790
you how to deal with that situation and get
the data that you may be looking for.

00:03:11.790 --> 00:03:13.410
That's probably why you're getting duplicates.

00:03:13.410 --> 00:03:18.320
If you were to look at all the information
in the records that are being returned to

00:03:18.320 --> 00:03:20.130
you, you'd see that some of it was different.

00:03:20.130 --> 00:03:21.240
&gt;&gt;Johns: Yeah.

00:03:21.240 --> 00:03:26.090
I guess as a tip, stay away from the [indistinct]
contacts table.

00:03:26.090 --> 00:03:29.190
Also, the data table is going to have duplicate
data as well.

00:03:29.190 --> 00:03:35.960
But I believe the high level contacts table
should have a single representation of each

00:03:35.960 --> 00:03:36.960
person.

00:03:36.960 --> 00:03:40.770
That'd be a good starting point if you're
trying to read through the docs.

00:03:40.770 --> 00:03:46.121
&gt;&gt;Malin: If you look at the documentation,
you'll see some examples of how to retrieve

00:03:46.121 --> 00:03:49.810
different types of information from the provider.

00:03:49.810 --> 00:03:54.870
And also, look at the things called entities.

00:03:54.870 --> 00:04:02.370
What entities do is a behind the scenes combine
of different pieces of data that help you

00:04:02.370 --> 00:04:06.350
do the sorts of things that you might want
to do with the provider.

00:04:06.350 --> 00:04:09.390
But I definitely suggest you look at the documentation.

00:04:09.390 --> 00:04:11.040
Anything else?

00:04:11.040 --> 00:04:14.570
&gt;&gt;Johns: No, I think that pretty much covered
it.

00:04:14.570 --> 00:04:16.410
&gt;&gt;Malin: Okay.

00:04:16.410 --> 00:04:20.879
Next question: "What are some tips for file
manager UIs?

00:04:20.879 --> 00:04:26.469
I'm currently writing an app that, although
it autosaves, its saved files and external

00:04:26.469 --> 00:04:28.280
ones should be accessible to the user.

00:04:28.280 --> 00:04:32.800
The file browsers on the store are in lists
or icons.

00:04:32.800 --> 00:04:36.380
DPI is also a factor."

00:04:36.380 --> 00:04:38.740
&gt;&gt;Johns: First thing.

00:04:38.740 --> 00:04:42.430
Don't show the whole file system is my recommendation.

00:04:42.430 --> 00:04:44.409
There's a number of file manager apps out
there.

00:04:44.409 --> 00:04:45.879
For example, Astro.

00:04:45.879 --> 00:04:50.370
They're good tools for power users, but that's
not the model we want for Android UIs.

00:04:50.370 --> 00:04:54.080
We really want to say, "Okay, here's the documents
on your device."

00:04:54.080 --> 00:04:57.229
We don't really care where they live, are
they on internal storage, external storage

00:04:57.229 --> 00:04:59.110
in some subfolder.

00:04:59.110 --> 00:05:00.110
All that's irrelevant.

00:05:00.110 --> 00:05:04.050
We don't actually want to expose the underlying
Linux file system.

00:05:04.050 --> 00:05:08.150
We just want to say, again, "Here's all the
docs we could find.

00:05:08.150 --> 00:05:09.960
Go ahead and pick one and open it up."

00:05:09.960 --> 00:05:14.490
If you're asking whether it should actually
be a list versus thumbnails versus some sort

00:05:14.490 --> 00:05:21.050
of icon, I tend to lean a little bit more
towards the idea of either a list or a thumbnail,

00:05:21.050 --> 00:05:22.970
and possibly even allow the user to pick.

00:05:22.970 --> 00:05:25.189
If you have more [indistinct] state, thumbnails
are really nice.

00:05:25.189 --> 00:05:27.569
But they do take up more space.

00:05:27.569 --> 00:05:31.930
A good example, if you're looking at something
to model off of, would be Google Docs.

00:05:31.930 --> 00:05:32.930
They do a really--.

00:05:32.930 --> 00:05:34.370
Or Google Drive, excuse me.

00:05:34.370 --> 00:05:38.789
They do a really awesome list view for displaying
files.

00:05:38.789 --> 00:05:44.180
Because they don't have a folder hierarchy
by default, they have to go and do that fairly

00:05:44.180 --> 00:05:45.180
well.

00:05:45.180 --> 00:05:47.930
Of course, you still can create folders, and
they handle that, too.

00:05:47.930 --> 00:05:49.689
I guess that's my advice.

00:05:49.689 --> 00:05:51.210
It's really more of a UI question.

00:05:51.210 --> 00:05:55.639
Without seeing your app, I don't think we
can give you one size fits all recommendations

00:05:55.639 --> 00:05:56.639
here.

00:05:56.639 --> 00:05:59.180
But I think that should be some good general
guidance.

00:05:59.180 --> 00:06:01.789
&gt;&gt;Malin: Any other comments?

00:06:01.789 --> 00:06:03.749
&gt;&gt;Jeff Sharkey: Yeah.

00:06:03.749 --> 00:06:06.289
One thing to think about when you're building
a file browser like that: you're going to

00:06:06.289 --> 00:06:08.539
have the different UI on phones versus tablets.

00:06:08.539 --> 00:06:12.569
On a phone, you might end up with that single
list view where the user navigates deeper

00:06:12.569 --> 00:06:14.099
into a file hierarchy.

00:06:14.099 --> 00:06:19.020
You might be able to present the tree or the
file system tree on a left-hand side pane

00:06:19.020 --> 00:06:23.279
using something like fragments on a tablet-sized
app.

00:06:23.279 --> 00:06:26.409
Definitely depends on which size of device
you're targeting.

00:06:26.409 --> 00:06:28.430
You might be able to fit more or less details.

00:06:28.430 --> 00:06:32.389
&gt;&gt;Meier: I think generally, and I just want
to reiterate what Trevor and Joe have already

00:06:32.389 --> 00:06:40.409
said, and that is, generally speaking, the
move has been away from having hierarchical

00:06:40.409 --> 00:06:43.240
file structures to support your app.

00:06:43.240 --> 00:06:50.349
It made sense back in pre-GUI days we had
to figure out a way to be able to put things

00:06:50.349 --> 00:06:54.310
in a place you'd be able to find again if
all you've got is the ability to list the

00:06:54.310 --> 00:06:57.639
files in a folder and what the current folder
is.

00:06:57.639 --> 00:06:59.629
These days, the move is very much away from
that.

00:06:59.629 --> 00:07:02.899
It's really more about tagging things, making
them more easily searchable.

00:07:02.899 --> 00:07:06.949
You can see the way that Google Drive does
that in that your things just sit there.

00:07:06.949 --> 00:07:08.900
You can tag them and you can search for them.

00:07:08.900 --> 00:07:12.279
Same with Gmail, which was a forerunner to
that.

00:07:12.279 --> 00:07:17.229
In most cases, if [clears throat] if what
you're building is just a file manager, then

00:07:17.229 --> 00:07:21.229
I think it does have some value, if you're
figuring out how to put the file manager into

00:07:21.229 --> 00:07:24.830
your app, to make it easier for users to save
files and load files.

00:07:24.830 --> 00:07:27.460
I'd say that you're probably going in slightly
the wrong direction.

00:07:27.460 --> 00:07:32.469
You should be thinking more about how can
you make it easy for people to find the content

00:07:32.469 --> 00:07:37.710
that they're looking for without having to
navigate a hierarchy or a deducer.

00:07:37.710 --> 00:07:39.270
&gt;&gt;Malin: Okay.

00:07:39.270 --> 00:07:45.050
Yeah, I would add that the difference is that
if you use some sort of file hierarchy like

00:07:45.050 --> 00:07:50.669
old-fashioned directories, then you're stuck
with putting one thing in one place.

00:07:50.669 --> 00:07:56.259
Whereas if you tag it or give it some metadata
that you can then search on that for, you

00:07:56.259 --> 00:08:02.349
can put something, so to speak, in more than
one place at the same time.

00:08:02.349 --> 00:08:07.270
Kind of like the way that labels work in Gmail.

00:08:07.270 --> 00:08:10.610
They appear sometimes to be folders, but they're
really not.

00:08:10.610 --> 00:08:12.999
A message can be in more than one label.

00:08:12.999 --> 00:08:16.550
It can have more than one label at the same
time.

00:08:16.550 --> 00:08:18.069
That's a great benefit to users.

00:08:18.069 --> 00:08:19.069
&gt;&gt;Johns: Yep.

00:08:19.069 --> 00:08:23.919
Another thing to think about, too, we're just
speeding file hierarchies to death here, but

00:08:23.919 --> 00:08:28.619
when you have nested folders or nested directories,
you have to go and click through all of them.

00:08:28.619 --> 00:08:31.229
That's a pain on a mobile device.

00:08:31.229 --> 00:08:32.810
It's a lot easier if you have a list.

00:08:32.810 --> 00:08:35.510
You swipe, you tap, you're done.

00:08:35.510 --> 00:08:39.180
Again, Meier touched on this: search is incredibly
important.

00:08:39.180 --> 00:08:40.700
Make sure you have that in there.

00:08:40.700 --> 00:08:42.320
I'd say it's more important than tagging.

00:08:42.320 --> 00:08:44.589
If you can only implement one of these suggestions,
it would be search.

00:08:44.589 --> 00:08:45.589
[pause]

00:08:45.589 --> 00:08:46.589
&gt;&gt;Malin: Okay.

00:08:46.589 --> 00:08:51.010
&gt;&gt;Robert Ly: We've got a question on the Hangout
here.

00:08:51.010 --> 00:08:52.010
&gt;&gt;Malin: Okay.

00:08:52.010 --> 00:08:57.589
&gt;&gt;Ly: "How do I go about creating a category
side view which takes only half the screen

00:08:57.589 --> 00:09:04.550
when sufficient real state is available with
a pager title script, similar to what is shown

00:09:04.550 --> 00:09:05.840
in Google Play?"

00:09:05.840 --> 00:09:07.529
&gt;&gt;Malin: Okay.

00:09:07.529 --> 00:09:09.730
The question was--.

00:09:09.730 --> 00:09:11.970
Can people hear you on the Hangout?

00:09:11.970 --> 00:09:12.970
&gt;&gt;Johns: Yes.

00:09:12.970 --> 00:09:13.970
&gt;&gt;Malin: Okay, fine.

00:09:13.970 --> 00:09:14.970
So you've heard the question.

00:09:14.970 --> 00:09:18.759
&gt;&gt;Johns: I heard the question, but could you
repeat it, actually?

00:09:18.759 --> 00:09:19.759
[laughs]

00:09:19.759 --> 00:09:20.759
&gt;&gt;Ly: Sure thing.

00:09:20.759 --> 00:09:24.720
"How do I go about creating a category side
view which takes only half the screen when

00:09:24.720 --> 00:09:29.610
sufficient real estate is available with a
pager title script, similar to what is shown

00:09:29.610 --> 00:09:30.670
in Google Play?"

00:09:30.670 --> 00:09:35.950
&gt;&gt;Johns: Also, I know that in Google Play,
you can swipe.

00:09:35.950 --> 00:09:37.900
I'm not sure what the side view is.

00:09:37.900 --> 00:09:39.550
We're trying to pull it up here so we have
an example.

00:09:39.550 --> 00:09:42.310
&gt;&gt;Sharkey: So you go up to the top level,
go into one of the categories--

00:09:42.310 --> 00:09:44.100
&gt;&gt;Meier: Oh, categories?

00:09:44.100 --> 00:09:46.660
Okay, so I'm going to go into apps.

00:09:46.660 --> 00:09:47.660
&gt;&gt;Sharkey: Yeah, and pull left.

00:09:47.660 --> 00:09:48.930
I think it'll even work in portrait as well.

00:09:48.930 --> 00:09:50.190
&gt;&gt;Meier: And-- oh, cool

00:09:50.190 --> 00:09:53.360
&gt;&gt;Sharkey: In one of the apps, like apps for
magazines.

00:09:53.360 --> 00:09:57.490
&gt;&gt;Johns: We need to hook up our HTMI tablets
here so we can actually show you this.

00:09:57.490 --> 00:09:58.490
&gt;&gt;Meier: Oh, I see, okay.

00:09:58.490 --> 00:09:59.490
Let me just turn it around--

00:09:59.490 --> 00:10:00.490
&gt;&gt;Sharkey: Demonstrate.

00:10:00.490 --> 00:10:01.490
&gt;&gt;Johns: Yeah, hold it up to the camera.

00:10:01.490 --> 00:10:02.490
&gt;Sharkey: There we go.

00:10:02.490 --> 00:10:05.980
&gt;&gt;Meier: Let's get rid of the glare.

00:10:05.980 --> 00:10:08.589
When I pull and it stops halfway across.

00:10:08.589 --> 00:10:11.230
And I can pull it back.

00:10:11.230 --> 00:10:12.410
That's exactly halfway.

00:10:12.410 --> 00:10:16.020
I presume that that's the functionality that
they are looking for.

00:10:16.020 --> 00:10:17.020
Excellent.

00:10:17.020 --> 00:10:18.020
Getting head nods.

00:10:18.020 --> 00:10:19.020
All right.

00:10:19.020 --> 00:10:20.020
That's a good question.

00:10:20.020 --> 00:10:21.020
How would you do this?

00:10:21.020 --> 00:10:23.170
I would guess that this isn't using a view
pager.

00:10:23.170 --> 00:10:26.509
&gt;&gt;Johns: Or at least, it's a modified version
of view pager.

00:10:26.509 --> 00:10:27.690
Yeah.

00:10:27.690 --> 00:10:33.279
To my knowledge, there's no way, by default,
to ask view pager to do that for you.

00:10:33.279 --> 00:10:36.730
There's another question a bit further down
on the question queue, too, which touches

00:10:36.730 --> 00:10:43.250
on this, which is asking, for example, Google+,
when you tap the home button, you have a navigation

00:10:43.250 --> 00:10:47.089
panel that slides out from the left.

00:10:47.089 --> 00:10:51.160
Right now, there's nothing in the support
library or otherwise elsewhere in the framework

00:10:51.160 --> 00:10:52.880
that really makes this easy to do.

00:10:52.880 --> 00:10:57.339
A recommendation, actually, right now, it's
an awesome model.

00:10:57.339 --> 00:10:58.339
I love it.

00:10:58.339 --> 00:11:01.240
But it's not something we're actually actively
recommending to people because there's been

00:11:01.240 --> 00:11:04.180
so much flux with these widgets.

00:11:04.180 --> 00:11:08.529
Everybody's doing it a little bit differently,
so there's not really a single recommended

00:11:08.529 --> 00:11:12.699
approach as far as our UI deadlines are concerned.

00:11:12.699 --> 00:11:15.639
If you really do want to implement it right
now, you're on your own.

00:11:15.639 --> 00:11:20.690
Over time, once we actually figure out what
the right way this should look should be,

00:11:20.690 --> 00:11:24.500
we'll probably add it somewhere, support library,
most likely.

00:11:24.500 --> 00:11:29.870
But that's a ways off, and that's assuming
that we actually decide we like it.

00:11:29.870 --> 00:11:32.319
It's always possible we'll change our minds
later on.

00:11:32.319 --> 00:11:36.949
Yeah, you're pretty much on your own, unfortunately.

00:11:36.949 --> 00:11:41.160
From the technical respective, if you wanted
to place a start, I'd start with view pager

00:11:41.160 --> 00:11:42.269
and start modifying that.

00:11:42.269 --> 00:11:46.040
But it's not going to be as simple as setting
a property.

00:11:46.040 --> 00:11:49.529
&gt;&gt;Meier: It looks, if we try and think this
through, it looks like what it's doing is

00:11:49.529 --> 00:11:53.830
it's-- all the other interaction works exactly
the same as view pager.

00:11:53.830 --> 00:11:58.690
If you started with that, and it looks like
all it's doing is saying if you're at N+1,

00:11:58.690 --> 00:12:07.750
well, I guess at 1, then limit the size of
the fragment for the 0th fragment.

00:12:07.750 --> 00:12:09.370
That would seem to be a place to start.

00:12:09.370 --> 00:12:10.370
Have a look at the view pager.

00:12:10.370 --> 00:12:16.129
What you want to do is modify the behavior,
if the first fragment is visible so it doesn't

00:12:16.129 --> 00:12:20.829
fully extend to the full width of the screen.

00:12:20.829 --> 00:12:22.449
I don't think we have any sample cuts.

00:12:22.449 --> 00:12:23.540
&gt;&gt;Johns: Nope.

00:12:23.540 --> 00:12:25.399
I'm not aware of any, either.

00:12:25.399 --> 00:12:33.350
&gt;&gt;Ly: The person in the Hangout says they
looked into that using a view flipper in combination

00:12:33.350 --> 00:12:40.170
with animations, but they could not figure
out how do they let the size-- not the view

00:12:40.170 --> 00:12:41.170
flipper.

00:12:41.170 --> 00:12:43.079
Reto's suggestion.

00:12:43.079 --> 00:12:44.079
They tried what you--

00:12:44.079 --> 00:12:46.779
&gt;&gt;Meier: They tried what I suggested with
a view pager, but they couldn't find out how

00:12:46.779 --> 00:12:47.779
to limit the size?

00:12:47.779 --> 00:12:51.629
Yeah, I think that's going to be the struggle,
because the way that the view pager is designed

00:12:51.629 --> 00:12:57.009
is to effectively do the animations between
two set frames.

00:12:57.009 --> 00:13:02.470
Instead of having those two fragments on screen.

00:13:02.470 --> 00:13:11.339
The other possibility that you may want to
try is to have the 0th fragment contain--.

00:13:11.339 --> 00:13:15.190
What you're actually looking at on that view
pager isn't actually the lost fragment being

00:13:15.190 --> 00:13:16.190
half width?

00:13:16.190 --> 00:13:20.740
It's just that the last fragment looks like
the previous fragment and the first fragment

00:13:20.740 --> 00:13:22.130
joined together, if that makes sense?

00:13:22.130 --> 00:13:26.430
I don't know how you would do the animation,
but maybe once you get halfway across and

00:13:26.430 --> 00:13:28.310
then it switches it.

00:13:28.310 --> 00:13:32.870
I see it's getting a little bit hairy, even
in my own mind.

00:13:32.870 --> 00:13:37.689
We'd be interested to see how you get on,
but I don't think there's an easy solution

00:13:37.689 --> 00:13:39.870
for that at this point, unfortunately.

00:13:39.870 --> 00:13:44.320
Like Trevor says, the best chance in terms
of getting something relatively straightforward

00:13:44.320 --> 00:13:49.649
is to wait and see if we or anyone else creates
a standardized widget that does something

00:13:49.649 --> 00:13:52.149
similar to what G+ and YouTube did.

00:13:52.149 --> 00:13:53.149
&gt;&gt;Malin: Okay.

00:13:53.149 --> 00:13:56.199
&gt;&gt;Ly: Okay, we got another question on the
Hangout.

00:13:56.199 --> 00:13:57.199
&gt;&gt;Malin: All right.

00:13:57.199 --> 00:14:02.959
&gt;&gt;Ly: "I'm looking for tools or methods that
will help me test my app in extreme conditions.

00:14:02.959 --> 00:14:09.880
For example, low memory, low disk space by
CPU usage and", in parenthesis, "that is done

00:14:09.880 --> 00:14:11.640
by another process."

00:14:11.640 --> 00:14:12.810
&gt;&gt;Malin: Hmm.

00:14:12.810 --> 00:14:13.810
Okay.

00:14:13.810 --> 00:14:15.570
&gt;&gt;Johns: At first I thought here, extreme
conditions.

00:14:15.570 --> 00:14:21.829
Are you going go and try to drop it in a volcano,
launch it into space, take it over to Antarctica?

00:14:21.829 --> 00:14:23.560
Space has been done, by the way.

00:14:23.560 --> 00:14:26.370
We actually have launched Android phones into
space.

00:14:26.370 --> 00:14:29.250
But I'm not aware of any that have gone into
volcanoes.

00:14:29.250 --> 00:14:30.250
Seriously, though.

00:14:30.250 --> 00:14:31.250
&gt;&gt;Sharkey: Challenge accepted.

00:14:31.250 --> 00:14:34.320
&gt;&gt;Johns: [laughs] Anybody know a good volcano
nearby?

00:14:34.320 --> 00:14:37.430
&gt;&gt;Sharkey: Sounds like an excuse to go to
Hawaii to me.

00:14:37.430 --> 00:14:43.360
&gt;&gt;Johns: Some of the things, like Slow Network
in particular, there's support for an emulator.

00:14:43.360 --> 00:14:48.089
Now, low disk space, I'm not aware of any
really good automated ways to go and test

00:14:48.089 --> 00:14:52.440
that other than writing a script that goes
and dumps a bunch of files onto your SD card.

00:14:52.440 --> 00:14:57.189
I know there are some third party companies
that make some test suites that do go and

00:14:57.189 --> 00:15:01.949
test some things like what happens when the
battery gets low.

00:15:01.949 --> 00:15:07.840
Off the top of my head, I believe Testdroid
is one of the ones that can do some of this

00:15:07.840 --> 00:15:08.840
stuff.

00:15:08.840 --> 00:15:11.670
I don't think it can do everything on your
list, but it's worth looking into.

00:15:11.670 --> 00:15:13.850
That's by a company called Bitbar.

00:15:13.850 --> 00:15:17.959
They offer a subscription service where you
upload your APK to their service and they

00:15:17.959 --> 00:15:20.690
run a series of tests on devices you've supplied
to them.

00:15:20.690 --> 00:15:22.510
Oh, sorry, on devices they've supplied for
you.

00:15:22.510 --> 00:15:26.339
You don't have to mail them any devices.

00:15:26.339 --> 00:15:30.290
That's probably your best bet if you're looking
to try and do a lot of this short of trying

00:15:30.290 --> 00:15:34.430
to go and automate a bunch of it yourself
using things like ADB to go and--.

00:15:34.430 --> 00:15:37.220
Actually, ADB will only get you so far, even.

00:15:37.220 --> 00:15:41.730
If you're trying to test low battery, you'd
have to hook up some hardware and start modifying

00:15:41.730 --> 00:15:42.870
the voltage.

00:15:42.870 --> 00:15:44.490
It's a tough one.

00:15:44.490 --> 00:15:48.040
Really no easy way there, other than what
the emulator already provides.

00:15:48.040 --> 00:15:50.270
And it does supply some of it, so definitely
look at that first.

00:15:50.270 --> 00:15:55.860
&gt;&gt;Sharkey: One of the tools that can potentially
be really powerful is the Monkey, which generates

00:15:55.860 --> 00:15:57.600
a bunch of random events.

00:15:57.600 --> 00:16:01.910
Touches on the screen, keyboard event inputs.

00:16:01.910 --> 00:16:04.699
It'll push your app in all different directions.

00:16:04.699 --> 00:16:09.310
We use that a lot on the team to help uncover
bugs in all of our apps across the platform.

00:16:09.310 --> 00:16:11.110
It'll generate a lot of that noise.

00:16:11.110 --> 00:16:13.850
It'll uncover race conditions a lot of times
in codes.

00:16:13.850 --> 00:16:15.010
The Monkey tool is great.

00:16:15.010 --> 00:16:18.920
You can find it, it's just using ADB on the
command line.

00:16:18.920 --> 00:16:24.759
&gt;&gt;Meier: Similarly, if you're trying to simulate
these extreme conditions based on what our

00:16:24.759 --> 00:16:29.329
other apps are doing, the easiest solution
in a lot of cases is going to be to create

00:16:29.329 --> 00:16:31.200
your own version of those other apps.

00:16:31.200 --> 00:16:34.629
The extreme conditions are going to be when
other apps are misbehaving.

00:16:34.629 --> 00:16:38.970
You get to have fun and create an app which
is really poorly behaved and does everything

00:16:38.970 --> 00:16:40.310
that we tell you not do to.

00:16:40.310 --> 00:16:45.430
It chews up memory, it causes other apps to
effectively swap out and get killed.

00:16:45.430 --> 00:16:47.559
&gt;&gt;Johns: I think we actually--.

00:16:47.559 --> 00:16:49.259
I think, was it Dianne Hackborn where we actually--.

00:16:49.259 --> 00:16:52.579
Something very similar to that for an internal
use for a while.

00:16:52.579 --> 00:16:57.939
[laughter] Our own builds had a very badly
misbehaving app installed on them for a bit

00:16:57.939 --> 00:17:01.649
to go and try and test what happens when apps
misbehave.

00:17:01.649 --> 00:17:04.350
Thankfully, that doesn't chip.

00:17:04.350 --> 00:17:07.320
[laughs] I think that's probably a good approach.

00:17:07.320 --> 00:17:08.910
Just write a really bad app.

00:17:08.910 --> 00:17:14.130
That's going to go and cover, at least from
the performance side of things, what happens

00:17:14.130 --> 00:17:15.130
when things go wrong.

00:17:15.130 --> 00:17:17.140
&gt;&gt;Meier: That's usually the easiest way to
do it.

00:17:17.140 --> 00:17:19.060
You can do a lot through simulating things.

00:17:19.060 --> 00:17:22.690
But ultimately, it's going to be "How does
my app behave when another app is using all

00:17:22.690 --> 00:17:27.210
my bandwidth, using all my processors, using
all my storage?" is to build that other app.

00:17:27.210 --> 00:17:30.800
It gives you the control as well, because
then you can decide how far you want it to

00:17:30.800 --> 00:17:31.800
go.

00:17:31.800 --> 00:17:34.550
"At what point does my app start being unresponsive?

00:17:34.550 --> 00:17:38.960
What steps should I take to try and help the
system out?"

00:17:38.960 --> 00:17:40.620
&gt;&gt;Malin: Any other comments?

00:17:40.620 --> 00:17:41.620
&gt;&gt;Johns: Nope.

00:17:41.620 --> 00:17:43.230
&gt;&gt;Malin: Okay, thank you, gentlemen.

00:17:43.230 --> 00:17:44.930
Now let's move on.

00:17:44.930 --> 00:17:49.100
Oops, I think I skipped one here.

00:17:49.100 --> 00:17:53.230
"I have a fragment which uses a loader that
implements the loader callbacks.

00:17:53.230 --> 00:17:57.720
I have set retained instants true for the
fragment so that it is not destroyed across

00:17:57.720 --> 00:17:59.270
orientation changes.

00:17:59.270 --> 00:18:04.130
However, the loader it creates in the on create
loader gets reset.

00:18:04.130 --> 00:18:05.600
Why?"

00:18:05.600 --> 00:18:07.070
[pause]

00:18:07.070 --> 00:18:10.740
&gt;&gt;Johns: That's a good question.

00:18:10.740 --> 00:18:13.490
[laughs] Actually, I've never seen this behavior
before, so I'm not sure what the answer is

00:18:13.490 --> 00:18:14.490
off the top of my head.

00:18:14.490 --> 00:18:18.420
This also, I think, was one of the later questions
to come to the queue, so I didn't get a chance

00:18:18.420 --> 00:18:20.110
to research it beforehand.

00:18:20.110 --> 00:18:21.250
Yeah.

00:18:21.250 --> 00:18:23.270
I actually do not know the answer to this.

00:18:23.270 --> 00:18:24.270
[pause]

00:18:24.270 --> 00:18:25.270
&gt;&gt;Malin: No?

00:18:25.270 --> 00:18:26.520
&gt;&gt;Sharkey: Hmm?

00:18:26.520 --> 00:18:28.470
Yeah, don't know.

00:18:28.470 --> 00:18:29.770
&gt;&gt;Malin: Okay.

00:18:29.770 --> 00:18:32.360
&gt;&gt;Meier: It seems strange.

00:18:32.360 --> 00:18:35.610
&gt;&gt;Malin: Well, the panel's puzzled.

00:18:35.610 --> 00:18:40.630
&gt;&gt;Johns: Our usual advice, if you can go ahead
an post the question on Stack Overflow, we

00:18:40.630 --> 00:18:46.050
try and take anything that we can't answer
after the show and get an answer for you.

00:18:46.050 --> 00:18:52.390
Just go ahead and drop a comment on the G+
post, pointing to the Stack Overflow question.

00:18:52.390 --> 00:18:54.780
We'll try to get some more detail for you
after the show.

00:18:54.780 --> 00:19:00.010
&gt;&gt;Meier: The other thing that I'd want to
mention, for this one in particular.

00:19:00.010 --> 00:19:02.680
Set retain instant state fragments is awesome.

00:19:02.680 --> 00:19:09.470
But generally, it's designed to work specifically
for fragments which don't have a UI, which

00:19:09.470 --> 00:19:11.900
is a perfectly good place to put a loader.

00:19:11.900 --> 00:19:17.170
One of the things that I've mentioned is a
word of caution: if you are using that on

00:19:17.170 --> 00:19:19.760
a fragment with UI, that may be causing the
problem.

00:19:19.760 --> 00:19:21.640
I'd need to look into more detail.

00:19:21.640 --> 00:19:24.970
This is something which is vaguely tingling
in the back of my mind.

00:19:24.970 --> 00:19:30.280
But generally speaking, the set retain instant
estate property is designed for UI-less fragments.

00:19:30.280 --> 00:19:34.570
&gt;&gt;Ly: Got another question on the Hangout.

00:19:34.570 --> 00:19:35.730
&gt;&gt;Malin: All right.

00:19:35.730 --> 00:19:39.530
&gt;&gt;Ly: "I have a performance question related
to databases.

00:19:39.530 --> 00:19:44.640
What are the overhead implications with SQLite
and increasing the number of tables?"

00:19:44.640 --> 00:19:46.860
&gt;&gt;Johns: Hmm.

00:19:46.860 --> 00:19:48.800
That's a good question.

00:19:48.800 --> 00:19:52.550
I'd say adding more tables probably is not
going to hurt you too much.

00:19:52.550 --> 00:19:59.520
What is going to hurt you is joins and, at
some point, just having so many records that

00:19:59.520 --> 00:20:02.130
it takes a while to iterate through all of
them.

00:20:02.130 --> 00:20:05.020
Setting indexes wisely is definitely going
to help.

00:20:05.020 --> 00:20:07.920
Indexes to increase the costs when you perform
a write.

00:20:07.920 --> 00:20:09.250
It's a trade off.

00:20:09.250 --> 00:20:11.020
In exchange, you get faster read times.

00:20:11.020 --> 00:20:17.560
I'd say that's pretty much where you're going
to see most of your performance, is trying

00:20:17.560 --> 00:20:21.930
to do joins and trying to iterate through
a lot of records or searching on fields that

00:20:21.930 --> 00:20:23.430
don't have an index.

00:20:23.430 --> 00:20:25.080
That sort of thing.

00:20:25.080 --> 00:20:28.340
Adding more tables should be fine.

00:20:28.340 --> 00:20:33.140
Performance impact: minimal.

00:20:33.140 --> 00:20:35.460
&gt;&gt;Malin: Any other comments?

00:20:35.460 --> 00:20:37.980
All right, let's move on.

00:20:37.980 --> 00:20:42.830
"In the past, I've used an Intent Service
to load data from a REST web service, but

00:20:42.830 --> 00:20:48.310
I saw that in the new Google I/O app that
Async loaders are used extensively.

00:20:48.310 --> 00:20:51.890
Is loader currently the recommended way to
load remote data?

00:20:51.890 --> 00:20:54.590
When should Intent Service be used?"

00:20:54.590 --> 00:20:56.250
&gt;&gt;Johns: Okay.

00:20:56.250 --> 00:21:00.820
I think this one's in a bit of confusion about
the way the I/O app works.

00:21:00.820 --> 00:21:04.880
Using an Async loader to go and pull data
from a web service doesn't actually sound

00:21:04.880 --> 00:21:07.490
like a very good idea to me.

00:21:07.490 --> 00:21:09.570
We actually don't do that in the Google I/O
app.

00:21:09.570 --> 00:21:15.621
What we do do is we have a background service
in conjunction with a sync adapter, which

00:21:15.621 --> 00:21:20.560
goes an fetches the data from the web service,
stores it in a local database.

00:21:20.560 --> 00:21:25.630
Then that loader is used to go and fetch the
data out of the local database.

00:21:25.630 --> 00:21:27.540
That's the model we're using.

00:21:27.540 --> 00:21:31.340
It's nice because we don't have to worry about
trying to fetch data while the apps are running.

00:21:31.340 --> 00:21:33.450
Everything's already cached locally.

00:21:33.450 --> 00:21:38.690
In the background, we actually can send a
GCM message to the phone, informing it that

00:21:38.690 --> 00:21:39.880
the schedule's changed.

00:21:39.880 --> 00:21:43.180
Then it can go and update the conference schedule
in the background.

00:21:43.180 --> 00:21:46.780
That way, every time you open the app, you
don't have to wait a couple of minutes for

00:21:46.780 --> 00:21:48.710
the latest schedule data.

00:21:48.710 --> 00:21:54.030
You know you always have the latest data right
on your phone there, already stashed.

00:21:54.030 --> 00:22:00.010
As far as the other half of the question,
which should entail when should Intent Service

00:22:00.010 --> 00:22:02.800
be used?

00:22:02.800 --> 00:22:08.360
I think, in that case, partly it's a matter
of convenience, what's easier for you.

00:22:08.360 --> 00:22:10.990
Intent Service is still going to run as a
service.

00:22:10.990 --> 00:22:12.660
We're still running as a service.

00:22:12.660 --> 00:22:18.010
It's just-- Intent Service is more, if I remember
correctly, because I've actually never used

00:22:18.010 --> 00:22:20.840
that one myself, but I think that's more for
one-off jobs.

00:22:20.840 --> 00:22:24.420
You specify a request instead of an intent.

00:22:24.420 --> 00:22:27.820
Whereas in this case, since we're always going
and doing the same thing over and over again,

00:22:27.820 --> 00:22:32.510
we're always fetching these schedule changes.

00:22:32.510 --> 00:22:37.530
There's really, I think it works better, it's
just a self-contained background service.

00:22:37.530 --> 00:22:41.940
Reto, did you have any comments on when Intent
Service is a better choice?

00:22:41.940 --> 00:22:42.940
&gt;&gt;Meier: Yeah, actually.

00:22:42.940 --> 00:22:47.460
Me and Joe have actually been talking about
this for the last couple of weeks.

00:22:47.460 --> 00:22:52.420
I think, if you're looking specifically between
Intent Service and Async Task, I think that's

00:22:52.420 --> 00:22:54.200
generally the sort of question people have.

00:22:54.200 --> 00:22:59.350
Often, you'll come across the Async Task class
first and see it as a really convenient way

00:22:59.350 --> 00:23:01.560
of being able to do background stuff.

00:23:01.560 --> 00:23:04.820
You want to get off the UI thread for it to
work in Android.

00:23:04.820 --> 00:23:06.570
It's great.

00:23:06.570 --> 00:23:09.750
It does all the marshaling to the UI thread
for you, which is really, really handy.

00:23:09.750 --> 00:23:14.850
That's a clue as to when it's most appropriate,
as well, so there is some overhead associated

00:23:14.850 --> 00:23:16.240
with it.

00:23:16.240 --> 00:23:20.040
What it's really designed for is doing something
within your activity which is going to have

00:23:20.040 --> 00:23:21.820
a direct impact on your UI.

00:23:21.820 --> 00:23:26.470
If it's something which is allowed to get
destroyed as soon as your activity gets closed,

00:23:26.470 --> 00:23:31.940
because remember, of course, that your Asynced
tasks within an activity, as soon as you rotate

00:23:31.940 --> 00:23:34.600
the device, they're all going to get killed.

00:23:34.600 --> 00:23:37.060
It's really stuff which should not be long-lived.

00:23:37.060 --> 00:23:40.410
It's just too time consuming to do on the
UI thread.

00:23:40.410 --> 00:23:44.220
Intent Service is just a really neat way of
being able to encapsulate one of the most

00:23:44.220 --> 00:23:49.030
common service implementation patterns.

00:23:49.030 --> 00:23:52.760
Service is basically designed if anything
within your app which needs to live longer

00:23:52.760 --> 00:23:56.410
than the average lifespan of a particular
activity instance.

00:23:56.410 --> 00:24:01.100
Anything which needs to live across multiple
activities, anything which should stay, continue

00:24:01.100 --> 00:24:06.140
to be active when you're rotating the screen,
all that sort of stuff should live in a service.

00:24:06.140 --> 00:24:10.410
Anything which you are downloading which is
more than, anything nontrivial which you're

00:24:10.410 --> 00:24:13.040
downloading probably wants to be in a service.

00:24:13.040 --> 00:24:16.780
The Intent Service is really handy because
it creates this queue for you.

00:24:16.780 --> 00:24:21.880
It'll basically create a serial queue where
you keep sending it commands to do and it

00:24:21.880 --> 00:24:25.530
will keep going through them until all the
tasks have been done, and then innately kill

00:24:25.530 --> 00:24:26.810
the service for you.

00:24:26.810 --> 00:24:32.220
If you're doing things like intermittent downloads,
as Trevor says, anything which is going to

00:24:32.220 --> 00:24:36.850
be on a regular schedule, anything which has
to happen on an ongoing basis, should probably

00:24:36.850 --> 00:24:38.600
live using Async adaptor.

00:24:38.600 --> 00:24:43.270
But if you're just going to be downloading
things when a user clicks something, so you

00:24:43.270 --> 00:24:46.890
don't really know when it's going to happen,
then Intent Service is perfect, because you

00:24:46.890 --> 00:24:48.310
can send it the things.

00:24:48.310 --> 00:24:51.170
"Ooh, I want you to download this."

00:24:51.170 --> 00:24:52.170
It will download it.

00:24:52.170 --> 00:24:55.790
When it's finished, it updates your content
provider, and then your UI automatically gets

00:24:55.790 --> 00:24:59.850
updated by its loader when the content provider
associated with it has been updated.

00:24:59.850 --> 00:25:03.840
It just helps to create that nice pattern
for you.

00:25:03.840 --> 00:25:06.040
Often, that's the way it works, as well.

00:25:06.040 --> 00:25:10.900
Intuitively, when you first get started with
something, you have an activity, you have

00:25:10.900 --> 00:25:12.080
a UI.

00:25:12.080 --> 00:25:14.870
There's a temptation to just do everything
within that class.

00:25:14.870 --> 00:25:20.980
That's the trick behind Android, that your
main form is actually made up of your activity

00:25:20.980 --> 00:25:25.220
plus the service support plus potentially
a content provider as well.

00:25:25.220 --> 00:25:28.770
You really need to think of all of those modules
and how they fit together in order to create

00:25:28.770 --> 00:25:32.550
something that works in the best way.

00:25:32.550 --> 00:25:33.550
&gt;&gt;Malin: Thank you.

00:25:33.550 --> 00:25:34.550
Good answer.

00:25:34.550 --> 00:25:35.550
[laughter]

00:25:35.550 --> 00:25:36.550
&gt;&gt;Meier: Thank you.

00:25:36.550 --> 00:25:39.040
I need to take a beverage to moisten my mouth.

00:25:39.040 --> 00:25:40.040
[laughter]

00:25:40.040 --> 00:25:41.610
&gt;&gt;Malin: Any other comments?

00:25:41.610 --> 00:25:45.700
&gt;&gt;Sharkey: The one other value of Intent Service
is really, if you're in your UI and you want

00:25:45.700 --> 00:25:49.040
to persist something, if you really want to
make sure that it gets saved, that's what

00:25:49.040 --> 00:25:50.670
Intent Service is used for.

00:25:50.670 --> 00:25:54.150
Even if the user hits that home key or gets
an incoming phone call, if you've kicked that

00:25:54.150 --> 00:25:58.710
off in an Async Task, there's the potential
that your process gets killed, and that data

00:25:58.710 --> 00:25:59.710
may not be saved.

00:25:59.710 --> 00:26:02.290
So if the data is important, send it off to
that Intent Service.

00:26:02.290 --> 00:26:04.250
If it's something that's important to persist.

00:26:04.250 --> 00:26:05.950
&gt;&gt;Malin: Yeah, that's a very good point.

00:26:05.950 --> 00:26:12.350
I would add that it's really great for being
able to go send off some work to be done,

00:26:12.350 --> 00:26:16.630
allowing the user, then, to go off and do
any other task that may come up.

00:26:16.630 --> 00:26:22.010
So that if a phone call comes in or the user
wants to go off and do some work and wait

00:26:22.010 --> 00:26:27.380
for this thing to finish, they can go do that
and then get a notification or some other

00:26:27.380 --> 00:26:33.580
indication when the work is done, and then
go back to the activity.

00:26:33.580 --> 00:26:35.400
Okay.

00:26:35.400 --> 00:26:36.400
Let's move on.

00:26:36.400 --> 00:26:37.400
&gt;&gt;Ly: Another live question.

00:26:37.400 --> 00:26:38.400
&gt;&gt;Malin: Shoot.

00:26:38.400 --> 00:26:43.550
&gt;&gt;Ly: "Is there a way to use a different class
loader at development time, not necessarily

00:26:43.550 --> 00:26:46.000
for production for services?

00:26:46.000 --> 00:26:49.950
It looks like it's possible to do this for
activities using instrumentations and new

00:26:49.950 --> 00:26:55.270
activity methods, but I'd like to do this
for all parts of an app."

00:26:55.270 --> 00:26:58.290
&gt;&gt;Malin: A different class loader.

00:26:58.290 --> 00:27:05.320
Okay. [pause] The only thing that instrumentation
does, really, in terms of loading classes,

00:27:05.320 --> 00:27:13.350
is that it allows you a little bit of extra
control or injection into activities.

00:27:13.350 --> 00:27:20.980
There's instrumentation available for services
and for content providers as well as for activities.

00:27:20.980 --> 00:27:25.900
That's the only answer that I can give, myself.

00:27:25.900 --> 00:27:30.240
I'd be curious to see what the use case is
to know what the answer would be.

00:27:30.240 --> 00:27:34.330
&gt;&gt;Johns: I know it definitely is possible
to specify a different class loader within

00:27:34.330 --> 00:27:36.260
your activity.

00:27:36.260 --> 00:27:39.340
When you start going and firing off other
things like creating a new service, creating

00:27:39.340 --> 00:27:43.330
other activities, I think you have limited
control there.

00:27:43.330 --> 00:27:47.900
But I know there definitely is a way to go
and control things once your activity has

00:27:47.900 --> 00:27:50.100
gotten started.

00:27:50.100 --> 00:27:54.590
Unfortunately, it's not a very common task,
so I can't remember the way to do it off the

00:27:54.590 --> 00:27:55.590
top of my head.

00:27:55.590 --> 00:27:57.820
But I know it definitely can be done.

00:27:57.820 --> 00:28:03.230
For example, I know there was some talk a
while back of trying to use this as an investigation

00:28:03.230 --> 00:28:08.230
mechanism and encrypt classes and do all sorts
of other fun things like that.

00:28:08.230 --> 00:28:14.640
Again, not something I'd do or recommend most
developers try and concern themselves with,

00:28:14.640 --> 00:28:17.640
because lots of pitfalls lie down that road.

00:28:17.640 --> 00:28:20.590
But it definitely is possible.

00:28:20.590 --> 00:28:28.330
&gt;&gt;Ly: So he basically says, "I want to load
the activity itself with another class loader."

00:28:28.330 --> 00:28:30.510
&gt;&gt;Johns: Right, that's the question.

00:28:30.510 --> 00:28:32.080
Oh, the activity itself.

00:28:32.080 --> 00:28:33.200
I don't think that's possible.

00:28:33.200 --> 00:28:39.950
I think the best you can do is load classes
within the activity, because activity startup

00:28:39.950 --> 00:28:43.380
is not something that you can control.

00:28:43.380 --> 00:28:46.270
By the time you have control, your activity
has already been loaded.

00:28:46.270 --> 00:28:49.790
&gt;&gt;Meier: Could you do something within the
application object?

00:28:49.790 --> 00:28:52.010
If you created your own application--

00:28:52.010 --> 00:28:54.860
&gt;&gt;Johns: Well, except, when you get a chance--.

00:28:54.860 --> 00:28:56.900
Well, then you'd have one before your activity
is actually created.

00:28:56.900 --> 00:28:58.160
&gt;&gt;Meier: Yeah, the application will--

00:28:58.160 --> 00:29:00.120
&gt;&gt;Johns: It will get it maybe slightly before.

00:29:00.120 --> 00:29:03.190
&gt;&gt;Meier: The application instance will get
created before the activity.

00:29:03.190 --> 00:29:04.190
&gt;&gt;Johns: All right.

00:29:04.190 --> 00:29:05.190
Ahh, maybe.

00:29:05.190 --> 00:29:08.360
It's worth a try, but I don't think any of
us have ever attempted to do that.

00:29:08.360 --> 00:29:10.380
&gt;&gt;Meier: It doesn't seem like a very good
idea.

00:29:10.380 --> 00:29:11.860
&gt;&gt;Johns: No, it isn't.

00:29:11.860 --> 00:29:15.960
Like I said, lots of dangers when you start
messing with the class loader.

00:29:15.960 --> 00:29:17.950
It's usually something I recommend people
to stay away from.

00:29:17.950 --> 00:29:19.550
Also, it's a little odd.

00:29:19.550 --> 00:29:22.650
We've been getting a lot of questions today
that are text only.

00:29:22.650 --> 00:29:26.190
You guys are welcome to go and hop on video
chat or audio.

00:29:26.190 --> 00:29:28.140
Just let Robert, our producer, know.

00:29:28.140 --> 00:29:30.650
He'll make sure that you'll get patched in
live to us.

00:29:30.650 --> 00:29:32.010
We can actually talk to you face-to-face.

00:29:32.010 --> 00:29:38.410
We're more than happy to answer text questions,
too, if you don't have a camera.

00:29:38.410 --> 00:29:39.690
[pause]

00:29:39.690 --> 00:29:42.230
&gt;&gt;Malin: Okay.

00:29:42.230 --> 00:29:48.470
We'll move along to the next question on Moderator:
"How to create the drop down slide in navigation

00:29:48.470 --> 00:29:50.950
from action home up button?

00:29:50.950 --> 00:29:56.440
Is it as convoluted as all my Google results
indicate?

00:29:56.440 --> 00:29:58.390
Or is there a simple way to do it?

00:29:58.390 --> 00:30:02.660
Google+, YouTube, and Spotify incorporate
this feature."

00:30:02.660 --> 00:30:04.930
&gt;&gt;Johns: I think we already answered this
one earlier.

00:30:04.930 --> 00:30:08.070
But just to reiterate: yes.

00:30:08.070 --> 00:30:13.330
It is as convoluted as all your Google results
indicate.

00:30:13.330 --> 00:30:18.770
On that note, also, we don't recommend, really,
pursuing this until we have a recommendation

00:30:18.770 --> 00:30:23.070
as part of our design guide, or at the very
least, if people start coming up with some

00:30:23.070 --> 00:30:24.680
libraries to do it.

00:30:24.680 --> 00:30:27.000
There's really nothing out there that makes
it easy yet.

00:30:27.000 --> 00:30:31.570
That said, if you'd actually like to go and
write the first library to implement this,

00:30:31.570 --> 00:30:33.890
I'm sure there's lots of developers that would
thank you.

00:30:33.890 --> 00:30:37.560
But right now, it's not something we can really
recommend people do unless they're really

00:30:37.560 --> 00:30:38.560
adventurous.

00:30:38.560 --> 00:30:43.150
&gt;&gt;Meier: I'd also point out, as well, if anyone
does decide to take Trevor up on that challenge

00:30:43.150 --> 00:30:44.510
that the--.

00:30:44.510 --> 00:30:50.110
So each of these different implementations
you mentioned are slightly different in the

00:30:50.110 --> 00:30:51.110
way that they work.

00:30:51.110 --> 00:30:56.580
That's part of what Trevor's talking about,
is that there isn't a real consensus based

00:30:56.580 --> 00:30:58.290
on the star guidance to the right way.

00:30:58.290 --> 00:31:04.900
That said, the consensus seems to be heading
towards the YouTube model being the right

00:31:04.900 --> 00:31:06.280
way of doing this.

00:31:06.280 --> 00:31:10.850
If you do want to implement something similar,
look at the way the YouTube app has implemented

00:31:10.850 --> 00:31:12.090
it and head in that direction.

00:31:12.090 --> 00:31:13.393
But for now, it's definitely not for beginners.

00:31:13.393 --> 00:31:16.670
I think it's going to be a little bit tricky
to do.

00:31:16.670 --> 00:31:17.980
&gt;&gt;Malin: Okay.

00:31:17.980 --> 00:31:21.630
&gt;&gt;Ly: We have a live video question.

00:31:21.630 --> 00:31:22.910
&gt;&gt;Malin: Go for it.

00:31:22.910 --> 00:31:24.590
&gt;&gt;Johns: Yay!

00:31:24.590 --> 00:31:27.120
&gt;&gt;Malin: Fire away.

00:31:27.120 --> 00:31:29.650
&gt;&gt;Ly: Thank you.

00:31:29.650 --> 00:31:31.720
Give me a minute, here.

00:31:31.720 --> 00:31:32.720
&gt;&gt;Malin: Are you on--

00:31:32.720 --> 00:31:35.580
&gt;&gt;Male #1: --where we have an ad with a button
next to it to launch in an app purchase, but

00:31:35.580 --> 00:31:41.550
every time we don't give the ad view the full
width of the layout, it freaks out and says

00:31:41.550 --> 00:31:43.460
it can't display the ad.

00:31:43.460 --> 00:31:50.470
But even if we create a VM that has a really
tiny screen that is equivalent to what space

00:31:50.470 --> 00:31:58.640
it has, it will display the ad as long as
we give it match parent or fill parent.

00:31:58.640 --> 00:32:01.140
We're trying to figure out how we can solve
this.

00:32:01.140 --> 00:32:05.530
Right now, what we're thinking about is making
a fragment that it was allowed to take full

00:32:05.530 --> 00:32:11.920
width of, but I'd like to not complicate the
layouts too much, if possible.

00:32:11.920 --> 00:32:13.280
&gt;&gt;Malin: Hmm.

00:32:13.280 --> 00:32:19.830
Okay, so to repeat this, you've done an ad
that you want to display with a button next

00:32:19.830 --> 00:32:22.890
to it to do something like in-app purchasing.

00:32:22.890 --> 00:32:24.580
&gt;&gt;Male #1: Correct.

00:32:24.580 --> 00:32:25.710
&gt;&gt;Malin: Okay.

00:32:25.710 --> 00:32:31.650
And every time you try to set that up, it
complains because it says you don't have enough

00:32:31.650 --> 00:32:33.340
room to display the ad.

00:32:33.340 --> 00:32:34.480
&gt;&gt;Male #1: Correct.

00:32:34.480 --> 00:32:35.480
&gt;&gt;Meier: Interesting.

00:32:35.480 --> 00:32:39.660
So the ads are coming from a third party provider
like AdMob or something like that?

00:32:39.660 --> 00:32:41.110
&gt;&gt;Male #1: Yes.

00:32:41.110 --> 00:32:43.050
AdMob, to be specific.

00:32:43.050 --> 00:32:44.510
&gt;&gt;Meier: [laughs] Okay.

00:32:44.510 --> 00:32:45.510
Interesting.

00:32:45.510 --> 00:32:48.350
This is only going to be an issue on certain
size of displays.

00:32:48.350 --> 00:32:54.430
If it's, say, a phone where the AdMob banner
is specified to be the right size to fit best

00:32:54.430 --> 00:32:58.490
with the full width of the phone, then you're
going to have that issue when you try to put

00:32:58.490 --> 00:32:59.500
something next to it.

00:32:59.500 --> 00:33:00.520
Is that right?

00:33:00.520 --> 00:33:09.010
&gt;&gt;Male #1: Yeah, except for if we create a
virtual machine that has a width in pixels

00:33:09.010 --> 00:33:13.510
of what the view would be expanded into, as
long as we don't put the button there, it

00:33:13.510 --> 00:33:14.880
works fine.

00:33:14.880 --> 00:33:21.140
So we know that that amount, that real estate,
is sufficient to display the ad.

00:33:21.140 --> 00:33:22.440
&gt;&gt;Meier: Gotcha.

00:33:22.440 --> 00:33:23.740
That's interesting.

00:33:23.740 --> 00:33:26.950
While we think about that, one thing which
I would mention is that you need to be really

00:33:26.950 --> 00:33:31.880
careful when you try to create something like
what you're describing.

00:33:31.880 --> 00:33:38.750
One of the requirements we have in, I think
it's our developer content policy, is that

00:33:38.750 --> 00:33:43.500
you shouldn't be putting ads anywhere where
a user may accidentally click them.

00:33:43.500 --> 00:33:47.130
Putting ads right next to a button, which
you want people to press for any reason, may

00:33:47.130 --> 00:33:50.720
actually be in violation of that, because
it would be very easy to get confused and

00:33:50.720 --> 00:33:53.150
accidentally hit the ad instead of the button,
or--

00:33:53.150 --> 00:33:59.130
&gt;&gt;Male #1: Then how does Pandora get away
with it, because I hit those ads all the time.

00:33:59.130 --> 00:34:00.130
&gt;&gt;Meier: [laughs] Yeah, fair call, fair call.

00:34:00.130 --> 00:34:02.750
I can have a look how the Pandora app works.

00:34:02.750 --> 00:34:04.050
Like I said, I'm not--

00:34:04.050 --> 00:34:06.710
&gt;&gt;Male #1: Should we display the ads behind
the interface buttons?

00:34:06.710 --> 00:34:10.220
&gt;&gt;Meier: [laughs] That doesn't sound awesome.

00:34:10.220 --> 00:34:14.330
I can't comment on other apps and what they
may or may not be doing wrong.

00:34:14.330 --> 00:34:19.160
It's just something which has come up at least
once before with a developer I was working

00:34:19.160 --> 00:34:23.040
with who ran into some problems on that basis.

00:34:23.040 --> 00:34:24.040
I'd be cautious.

00:34:24.040 --> 00:34:28.710
You basically want to have any of your interactive
elements as far away from your ads as possible

00:34:28.710 --> 00:34:30.990
to avoid running into those kinds of issues.

00:34:30.990 --> 00:34:31.990
&gt;&gt;Male #1: Okay.

00:34:31.990 --> 00:34:35.890
I see Keys mentioned something about not being
able to place ads, or buttons close to the

00:34:35.890 --> 00:34:36.890
ads.

00:34:36.890 --> 00:34:41.990
Is that possible the API is seeing that and
causing a problem, or--?

00:34:41.990 --> 00:34:43.760
&gt;&gt;Meier: That's actually possible.

00:34:43.760 --> 00:34:45.500
I hadn't considered that.

00:34:45.500 --> 00:34:50.220
But it is possible that the actual AdMob API
is looking and seeing, "Oh, you've got a button

00:34:50.220 --> 00:34:51.510
right next to the ad.

00:34:51.510 --> 00:34:52.830
That's not kosher."

00:34:52.830 --> 00:34:56.110
It does seem a little strange.

00:34:56.110 --> 00:35:00.620
I'd be a little bit surprised if it was smart
enough to do that on your behalf.

00:35:00.620 --> 00:35:05.260
But just from a UX perspective, if nothing
else, I think it's really not best practice

00:35:05.260 --> 00:35:09.300
to have your interactive elements that close
to your banner ads.

00:35:09.300 --> 00:35:10.550
&gt;&gt;Male #1: Right, okay.

00:35:10.550 --> 00:35:13.480
Regarding an in-app purchase button, would
that be something like in the overflow of

00:35:13.480 --> 00:35:16.690
the action bar that would be recommended?

00:35:16.690 --> 00:35:19.900
&gt;&gt;Johns: It depends on what you're buying.

00:35:19.900 --> 00:35:21.230
It depends on the nature of the in-app purchase.

00:35:21.230 --> 00:35:23.880
&gt;&gt;Male #1: It's like the premium kind of model.

00:35:23.880 --> 00:35:27.940
&gt;&gt;Johns: Okay, so basically it's an upgrade
for your app that adds additional features.

00:35:27.940 --> 00:35:32.410
Yeah, the overflow menu is certainly one option.

00:35:32.410 --> 00:35:35.420
The downside there is discoverability , right.

00:35:35.420 --> 00:35:39.120
The idea behind an overflow menu is you never
see it unless you really want to go looking

00:35:39.120 --> 00:35:40.320
through it.

00:35:40.320 --> 00:35:42.210
A better idea is just to go and put a--.

00:35:42.210 --> 00:35:48.470
When users get to the part of the app where
they try and get to the premium features is

00:35:48.470 --> 00:35:50.800
where you could start promoting the upgrades.

00:35:50.800 --> 00:35:52.700
Have the right controls available.

00:35:52.700 --> 00:35:56.250
Then when you click on them, you could pop
up a dialog, saying, "This is reserved for

00:35:56.250 --> 00:35:57.270
a pro version."

00:35:57.270 --> 00:36:01.740
Or you could have an entirely separate screen
with all the controls disabled and say, "Click

00:36:01.740 --> 00:36:03.520
here to upgrade."

00:36:03.520 --> 00:36:08.140
Probably a better idea just to go and display
the dialog as soon as they click on the button

00:36:08.140 --> 00:36:09.540
that takes you to that part of your app.

00:36:09.540 --> 00:36:15.510
I still would have an option in the overflow
menu to go and apply the upgrade for people

00:36:15.510 --> 00:36:18.820
who know that they really want to get to it
to keep them from having to dig.

00:36:18.820 --> 00:36:22.690
But definitely look at other opportunities
for upselling.

00:36:22.690 --> 00:36:28.230
Try and figure out how users will know that
there's actually additional value, that it's

00:36:28.230 --> 00:36:29.310
something they want to buy.

00:36:29.310 --> 00:36:30.350
&gt;&gt;Male #1: All right.

00:36:30.350 --> 00:36:31.350
Thank you.

00:36:31.350 --> 00:36:32.350
&gt;&gt;Johns: Yep.

00:36:32.350 --> 00:36:33.350
&gt;&gt;Meier: Thanks for your question.

00:36:33.350 --> 00:36:36.010
&gt;&gt;Malin: Anybody else?

00:36:36.010 --> 00:36:41.650
All right, we'll move on to the next question
from Moderator.

00:36:41.650 --> 00:36:43.660
Is that okay?

00:36:43.660 --> 00:36:46.360
[pause] Producer says, "Okay."

00:36:46.360 --> 00:36:51.570
"I'm loading several images from disk at basically
the same time, using a background thread,

00:36:51.570 --> 00:36:52.570
of course.

00:36:52.570 --> 00:36:58.810
However, loading so many images in a matter
of milliseconds will cause gc_for_alloc, causing

00:36:58.810 --> 00:36:59.830
noticeable jank.

00:36:59.830 --> 00:37:01.730
Anything I can do about that?"

00:37:01.730 --> 00:37:03.680
&gt;&gt;Johns: This sounds like a performance question.

00:37:03.680 --> 00:37:06.640
Jeff, do you want to take a shot at this?

00:37:06.640 --> 00:37:07.640
&gt;&gt;Sharkey: Sure.

00:37:07.640 --> 00:37:10.690
Something to realize is even in that background
thread, if you're making that allocation,

00:37:10.690 --> 00:37:15.590
you're allocating those bitmaps, if you do
end up having to do this gc_for_alloc, it

00:37:15.590 --> 00:37:18.920
could potentially end up locking in the main
thread of your application that's running

00:37:18.920 --> 00:37:23.860
the UIV animation if that main thread is also
trying to allocate things.

00:37:23.860 --> 00:37:27.820
Really, what you're looking to do here is
you want to really optimize and minimize the

00:37:27.820 --> 00:37:30.760
number of allocations you're doing on that
main thread, because what you might find in

00:37:30.760 --> 00:37:34.880
this cases is that there's one small, little
allocation that's being exposed to this pause

00:37:34.880 --> 00:37:36.350
from the background thread.

00:37:36.350 --> 00:37:41.230
If you're able to get the UI animation done
with zero allocations, if you get it all the

00:37:41.230 --> 00:37:46.410
way down to zero, you probably wouldn't see
that pause that you're describing.

00:37:46.410 --> 00:37:50.130
&gt;&gt;Johns: Also, I'll add that I did a code
lab at Google I/O that did something very

00:37:50.130 --> 00:37:54.010
similar to the behavior you're describing.

00:37:54.010 --> 00:37:59.000
Specifically, I created a gridview that loads
a bunch of really high resolution images over

00:37:59.000 --> 00:38:00.510
and over again.

00:38:00.510 --> 00:38:06.330
We walked people through going and finding
all the hotspots in the code, all the things

00:38:06.330 --> 00:38:11.750
that would cause-- garbage collection cause--
just general jank.

00:38:11.750 --> 00:38:12.750
Everything that was bad.

00:38:12.750 --> 00:38:16.040
We'd go and get rid of them one after another.

00:38:16.040 --> 00:38:19.920
I think that you can get a link to it from
the Google I/O website.

00:38:19.920 --> 00:38:23.320
If not, it is in my own website, tjohns.net/io2012.

00:38:23.320 --> 00:38:25.900
I have all the code up there.

00:38:25.900 --> 00:38:30.170
Important things: make sure, of course for
performance reasons, you're going to want

00:38:30.170 --> 00:38:35.070
to load your images in a background thread,
use AsyncTask or something similar.

00:38:35.070 --> 00:38:46.630
Also, make sure that you're reusing all of
your listview elements-- item views, I think's

00:38:46.630 --> 00:38:47.630
the word.

00:38:47.630 --> 00:38:48.630
Make sure you reuse those.

00:38:48.630 --> 00:38:50.980
They do get recycled.

00:38:50.980 --> 00:38:54.550
Just make sure that you reuse objects whenever
possible.

00:38:54.550 --> 00:38:57.540
On that note, make sure that you're recycling
bitmaps, too.

00:38:57.540 --> 00:39:02.890
All the usual things for whenever you're dealing
with bitmap supplier there, because they do

00:39:02.890 --> 00:39:04.770
take up a lot of memory.

00:39:04.770 --> 00:39:09.270
It's very easy to mess up and cause objects
to be created when they don't need to be.

00:39:09.270 --> 00:39:10.730
We've added a lot of hooks there.

00:39:10.730 --> 00:39:16.390
Especially, like I said, you can recycle bitmaps
and hang on to things that way.

00:39:16.390 --> 00:39:18.350
Actually, I'm trying to--.

00:39:18.350 --> 00:39:20.172
Recycling a bitmap actually gets rid of it,
right?

00:39:20.172 --> 00:39:22.640
I'm trying to know what the right way to do
it is.

00:39:22.640 --> 00:39:27.460
[pause] Do either of you remember the right
way to handle bitmaps?

00:39:27.460 --> 00:39:30.190
Like reuse the address space there, for it?

00:39:30.190 --> 00:39:32.430
&gt;&gt;Sharkey: I'm trying to remember.

00:39:32.430 --> 00:39:34.790
Because there is a release method or a recycle.

00:39:34.790 --> 00:39:35.790
&gt;&gt;Johns: Right.

00:39:35.790 --> 00:39:37.410
&gt;&gt;Sharkey: But I don't think that's what--

00:39:37.410 --> 00:39:38.410
&gt;&gt;Johns: Right.

00:39:38.410 --> 00:39:40.260
I think recycling actually completely gets
rid of it.

00:39:40.260 --> 00:39:42.820
&gt;&gt;Meier: Yeah, recycle gets rid of the address
space completely, or at least--

00:39:42.820 --> 00:39:48.360
&gt;&gt;Sharkey: But there is a method where you
can pass it in an existing instance into a

00:39:48.360 --> 00:39:50.360
bitmap options as part of uplay.

00:39:50.360 --> 00:39:54.710
That's one of the, that's the mechanism that
you're describing, that would allow you to

00:39:54.710 --> 00:39:56.110
recycle those existing allocations.

00:39:56.110 --> 00:39:57.110
&gt;&gt;Johns: Right.

00:39:57.110 --> 00:40:01.350
&gt;&gt;Sharkey: But yeah, the biggest takeaway,
though, is avoid allocations inside of your

00:40:01.350 --> 00:40:06.450
drawing, your own draws, because that's what
probably exposing, in this case, to that jank.

00:40:06.450 --> 00:40:08.980
&gt;&gt;Johns: Yeah, and you can take a look at
DDMS.

00:40:08.980 --> 00:40:13.140
There is an allocation tracker that will show
you where all of your memory is going.

00:40:13.140 --> 00:40:18.810
That should give you a pretty strong clue
as to what's causing all of these GC events.

00:40:18.810 --> 00:40:21.270
[pause] All right.

00:40:21.270 --> 00:40:22.910
&gt;&gt;Meier: Excellent.

00:40:22.910 --> 00:40:27.670
I actually have a question from someone on
the invite.

00:40:27.670 --> 00:40:31.980
Simon Marquis, who wants to know, "What is
the best choice to play a list of music files

00:40:31.980 --> 00:40:35.340
for an app and sometimes interrupts them to
play an effect sound?"

00:40:35.340 --> 00:40:37.420
He's listed a couple of ideas.

00:40:37.420 --> 00:40:39.480
And also, "What is the--.

00:40:39.480 --> 00:40:44.170
Is there a best practice to appropriately
handle the sound but when the screen is off?"

00:40:44.170 --> 00:40:45.620
and so on and so forth.

00:40:45.620 --> 00:40:48.010
I'm going to jump in and answer that as well.

00:40:48.010 --> 00:40:52.490
Yes, SoundPool is the API that you want to
look for, that can best handle that sort of

00:40:52.490 --> 00:40:53.490
thing.

00:40:53.490 --> 00:40:57.900
A variety of different sound effects and music
within a game.

00:40:57.900 --> 00:40:59.630
SoundPool is definitely your friend.

00:40:59.630 --> 00:41:02.810
And a media player API should you need it,
but I think you should actually be able to

00:41:02.810 --> 00:41:05.860
handle most things within SoundPool by itself.

00:41:05.860 --> 00:41:12.280
In terms of the best way to handle sound playing,
our good friends from the Friday Review, Ian

00:41:12.280 --> 00:41:17.050
Lewis and Dan Galpin, actually covered this
in some detail at their Google I/O talk Ten

00:41:17.050 --> 00:41:19.030
Things All Game Developers Should Know.

00:41:19.030 --> 00:41:23.280
Check that out and that will get you some
great advice, particularly how to handle things

00:41:23.280 --> 00:41:27.930
like music playback during a lock screen and
when the screen's off and those sorts of things

00:41:27.930 --> 00:41:28.930
.

00:41:28.930 --> 00:41:30.090
&gt;&gt;Malin: Great answer.

00:41:30.090 --> 00:41:31.090
Thank you.

00:41:31.090 --> 00:41:34.110
Thank you very much.

00:41:34.110 --> 00:41:39.040
Next question from Moderator: "In the Developer's
Console for one app, the content rating has

00:41:39.040 --> 00:41:41.570
the everyone rating disabled.

00:41:41.570 --> 00:41:46.320
Next to it, it says, 'This rating option has
been disabled by the Google Play team.'

00:41:46.320 --> 00:41:47.900
What could have caused this?"

00:41:47.900 --> 00:41:49.090
&gt;&gt;Johns: Well.

00:41:49.090 --> 00:41:51.520
[laughs] The answer's actually right there
in front of your face.

00:41:51.520 --> 00:41:56.080
It was manually set by a member of the Google
Play team.

00:41:56.080 --> 00:41:57.930
We do periodically review apps.

00:41:57.930 --> 00:42:02.020
If we notice that an app has an incorrect
rating, it's rated lower than it should be,

00:42:02.020 --> 00:42:03.610
we'll go and make a manual adjustment.

00:42:03.610 --> 00:42:05.090
That's what you're seeing there.

00:42:05.090 --> 00:42:10.190
Basically, they're saying, "Your app contains
some sort of content that makes it unsuitable

00:42:10.190 --> 00:42:11.820
for everyone."

00:42:11.820 --> 00:42:17.210
&gt;&gt;Meier: In my experience, the most common
cause for that is typically if you're using

00:42:17.210 --> 00:42:21.890
some sort of viewer requesting file location
in your app as a permission.

00:42:21.890 --> 00:42:27.750
Then there is a minimum level, minimum maturity
level, which has to be, I think it's not below

00:42:27.750 --> 00:42:30.580
us, but possibly the next up from that, at
least.

00:42:30.580 --> 00:42:32.170
That tends to be the most common case.

00:42:32.170 --> 00:42:37.540
It can also be if there is, if your app's
being flagged and the play team are looking

00:42:37.540 --> 00:42:40.870
through to make sure that it's compliant with
our content policies and so on.

00:42:40.870 --> 00:42:43.450
They may do it manually for those reasons
as well.

00:42:43.450 --> 00:42:51.900
But location, I think, is typically the most
common case for this sort of thing.

00:42:51.900 --> 00:42:52.900
&gt;&gt;Malin: That's good to know.

00:42:52.900 --> 00:42:53.900
Okay.

00:42:53.900 --> 00:42:54.900
Great.

00:42:54.900 --> 00:42:57.300
Next question from Moderator: "When using
an MHL adaptor to get HDMI out, some apps

00:42:57.300 --> 00:43:02.340
like YouTube show different views on the device
display and the HDMI output.

00:43:02.340 --> 00:43:03.340
How's that done?

00:43:03.340 --> 00:43:05.830
I could not find any API for this.

00:43:05.830 --> 00:43:07.840
Is it hardware dependent?"

00:43:07.840 --> 00:43:12.290
&gt;&gt;Johns: I did some digging into this.

00:43:12.290 --> 00:43:14.200
The answer is there isn't really an API.

00:43:14.200 --> 00:43:16.540
This is something that's done by the system.

00:43:16.540 --> 00:43:23.850
Whenever, at least, the Google experience
devices detect a video surface that will modify

00:43:23.850 --> 00:43:28.330
the HDMI output to go and display the contents
of only that video surface.

00:43:28.330 --> 00:43:31.150
It's not something that YouTube is explicitly
doing.

00:43:31.150 --> 00:43:34.390
It's something the system is taking care of
automatically.

00:43:34.390 --> 00:43:39.320
That said, this behavior is not guaranteed
for all devices.

00:43:39.320 --> 00:43:44.050
It's a vendor specific implementation detail.

00:43:44.050 --> 00:43:46.190
Other devices might choose to handle HDMI
differently.

00:43:46.190 --> 00:43:51.790
But to answer your question, though, if you
want to go and display some custom content

00:43:51.790 --> 00:43:54.430
on the other display, there's not really a
way to do it right now.

00:43:54.430 --> 00:43:56.840
It's just limited to videos.

00:43:56.840 --> 00:43:57.840
[pause]

00:43:57.840 --> 00:43:59.520
&gt;&gt;Malin: Okay, thank you.

00:43:59.520 --> 00:44:04.500
&gt;&gt;Meier: I have two questions from the live
invite.

00:44:04.500 --> 00:44:08.820
One is by, ooh, gosh, that's a name which
is going to be hard for me.

00:44:08.820 --> 00:44:09.980
Jazz Lagvankar?

00:44:09.980 --> 00:44:16.480
Who would like to know the name of the guy
in the hat.

00:44:16.480 --> 00:44:17.480
&gt;&gt;Johns: Ah. [laughs] Hey.

00:44:17.480 --> 00:44:18.480
My name is Trevor Johns.

00:44:18.480 --> 00:44:21.190
I'm actually on here almost every week, usually
without a hat.

00:44:21.190 --> 00:44:24.710
But I'm on the same team as Joe and Reto.

00:44:24.710 --> 00:44:27.520
We're all members of the Android Developer
Relations team.

00:44:27.520 --> 00:44:28.520
Yeah.

00:44:28.520 --> 00:44:29.520
[laughs]

00:44:29.520 --> 00:44:35.540
&gt;&gt;Meier: We are trying to implement, possibly,
having a mandatory hat-wearing person in each

00:44:35.540 --> 00:44:36.540
of our sessions.

00:44:36.540 --> 00:44:37.990
That's usually Dan Galpin on Friday.

00:44:37.990 --> 00:44:42.280
But seeing as Dan doesn't sit in on these
sessions, we thought we'd see if Trevor can

00:44:42.280 --> 00:44:46.250
sport a hat with the style to which we've
become accustomed.

00:44:46.250 --> 00:44:48.190
The next question is from Nicholas Johnson.

00:44:48.190 --> 00:44:53.040
He's attempting to develop a rich text component
with buttons for typical rich text editing.

00:44:53.040 --> 00:44:57.930
He goes on to say that spans are really difficult
to work with.

00:44:57.930 --> 00:45:06.020
The whole thing is a pain, particularly when
you get to things like text selection.

00:45:06.020 --> 00:45:10.300
My suggestion here, it will be interesting
to see if you guys agree, but intending to

00:45:10.300 --> 00:45:16.260
develop a rich text editing component within
Android is not going to be simple.

00:45:16.260 --> 00:45:20.210
You're effectively going to have to recreate
the edit text component from scratch, because

00:45:20.210 --> 00:45:24.920
as soon as you try to do things like change
colors midline, add italics and bold, and

00:45:24.920 --> 00:45:31.040
so on and so forth, to arbitrary text within
a full control, then you really need to also

00:45:31.040 --> 00:45:33.520
take care of how that layout is going to work.

00:45:33.520 --> 00:45:37.060
You're effectively going to end up having
to recreate the edit text component from scratch

00:45:37.060 --> 00:45:40.840
into something which, within a fairly short
amount of time, is going to look a lot like

00:45:40.840 --> 00:45:42.200
a web browser.

00:45:42.200 --> 00:45:46.510
Which is in fact how a lot of teams have implemented
this sort of thing, where they do have the

00:45:46.510 --> 00:45:51.780
need for rich text editing rather than being
some variation of the edit text.

00:45:51.780 --> 00:45:54.619
It's actually a webview within the app.

00:45:54.619 --> 00:45:56.420
That, I don't know.

00:45:56.420 --> 00:46:00.250
My gut feeling is that that's going to be
the way to go if you want to have something

00:46:00.250 --> 00:46:02.750
like anything beyond a really simple marker.

00:46:02.750 --> 00:46:03.750
How do you guys feel?

00:46:03.750 --> 00:46:06.800
&gt;&gt;Johns: Yeah, I think that that pretty much
covers it.

00:46:06.800 --> 00:46:11.230
Rich text is definitely something that's very
difficult to implement.

00:46:11.230 --> 00:46:12.720
Webview covers most of it already.

00:46:12.720 --> 00:46:14.420
It covers more than you probably want.

00:46:14.420 --> 00:46:16.330
It gives you room for expansion.

00:46:16.330 --> 00:46:21.230
I want to say most of the time when people
are doing rich text anyway, they're going

00:46:21.230 --> 00:46:27.560
to go and want to convert it to HTML, so using
webview takes care of that for you as well.

00:46:27.560 --> 00:46:28.560
[pause]

00:46:28.560 --> 00:46:31.480
&gt;&gt;Malin: Okay, thank you.

00:46:31.480 --> 00:46:37.260
Next question from Moderator: "I've noticed
that some apps that use action bar tabs for

00:46:37.260 --> 00:46:42.100
navigation will have the tabs replaced with
the dropdown list when switched to landscape,

00:46:42.100 --> 00:46:44.490
when there isn't enough room for tabs.

00:46:44.490 --> 00:46:46.830
Is there a way to force it to do that?

00:46:46.830 --> 00:46:47.830
Landscape tags are ugly."

00:46:47.830 --> 00:46:48.980
Hmm.

00:46:48.980 --> 00:46:50.220
Okay.

00:46:50.220 --> 00:46:57.270
&gt;&gt;Meier: I think the simple answer, for me,
is to try and use an action bar where possible,

00:46:57.270 --> 00:47:02.690
because that's going to already have that
sort of toggle between navigation in--.

00:47:02.690 --> 00:47:07.900
It's going to be a dropdown navigation in
portrait mode and in action bar tabs, potentially

00:47:07.900 --> 00:47:09.370
in landscape mode.

00:47:09.370 --> 00:47:12.770
You can do that variation yourself.

00:47:12.770 --> 00:47:18.070
It doesn't necessarily help you for if you
want to have apps which work prior to Honeycomb,

00:47:18.070 --> 00:47:19.530
mind you.

00:47:19.530 --> 00:47:22.760
But you can certainly try and use that same
sort of model.

00:47:22.760 --> 00:47:29.720
In general, my feeling is that your tab post
control isn't great.

00:47:29.720 --> 00:47:33.060
This is talking about action bar tabs in general.

00:47:33.060 --> 00:47:34.060
Yeah, okay.

00:47:34.060 --> 00:47:35.060
Specific to action bar tabs.

00:47:35.060 --> 00:47:40.260
That would be my suggestion, to just switch
between them using the spinner in portrait

00:47:40.260 --> 00:47:44.080
and the tabs in landscape, or vice versa.

00:47:44.080 --> 00:47:45.080
[pause]

00:47:45.080 --> 00:47:46.840
&gt;&gt;Malin: All right.

00:47:46.840 --> 00:47:49.609
Thank you very much.

00:47:49.609 --> 00:47:50.609
Next question from--

00:47:50.609 --> 00:47:51.609
&gt;&gt;Ly: Got a Hangout question.

00:47:51.609 --> 00:47:52.609
&gt;&gt;Malin: Oh.

00:47:52.609 --> 00:47:53.609
Shoot.

00:47:53.609 --> 00:47:54.609
&gt;&gt;Meier: Excellent.

00:47:54.609 --> 00:47:59.220
&gt;&gt;Ly: "I created a test database and exported
the strings for insert test data, looping

00:47:59.220 --> 00:48:04.200
through a string array that were all executing
each command, populate the database.

00:48:04.200 --> 00:48:08.550
I couldn't use begin transaction because I
was already in one.

00:48:08.550 --> 00:48:12.510
Any advice for creating a test database on
a device?"

00:48:12.510 --> 00:48:16.030
&gt;&gt;Sharkey: So you were already in a transaction.

00:48:16.030 --> 00:48:18.470
Just to-- I don't know if they're running
this.

00:48:18.470 --> 00:48:23.280
It's an Android program, it's an Android app,
and they're attempting to build a prepopulated

00:48:23.280 --> 00:48:24.440
database?

00:48:24.440 --> 00:48:28.300
That's what it sounds like?

00:48:28.300 --> 00:48:32.080
You should be able to create everything inside
of a single transaction on your own.

00:48:32.080 --> 00:48:33.630
I'm not sure what the exact--.

00:48:33.630 --> 00:48:37.080
It shouldn't be creating in the transaction
on your behalf.

00:48:37.080 --> 00:48:39.500
You should be able to begin and manage your
own.

00:48:39.500 --> 00:48:41.980
But, yeah.

00:48:41.980 --> 00:48:45.420
Without any more detail-- The other thing
he was mentioning is that it's designed to

00:48:45.420 --> 00:48:47.310
be generated once.

00:48:47.310 --> 00:48:50.619
He's pregenerating the SQLite database to
then ship?

00:48:50.619 --> 00:48:53.970
&gt;&gt;Ly: We're getting some clarification.

00:48:53.970 --> 00:48:55.310
&gt;&gt;Sharkey: Okay.

00:48:55.310 --> 00:48:58.830
&gt;&gt;Ly: It was in the on-create in the open
helper.

00:48:58.830 --> 00:48:59.830
&gt;&gt;Sharkey: Okay.

00:48:59.830 --> 00:49:01.070
You should be able to--.

00:49:01.070 --> 00:49:04.080
Oh, so if it's in the on-create, yeah, you're
right.

00:49:04.080 --> 00:49:07.170
You may already be in a transaction at that
point.

00:49:07.170 --> 00:49:12.560
If you're looking to test performance, it
should be as good as it's going to get.

00:49:12.560 --> 00:49:16.480
The one other thing to potentially look at
is, when you're doing that initial database

00:49:16.480 --> 00:49:19.950
setup, you're inserting a lot of data in a
[clattering noise] bulk way.

00:49:19.950 --> 00:49:24.890
You may look at creating your indexes after
you've inserted all of the data.

00:49:24.890 --> 00:49:28.910
If you create the indexes and then do a whole
bunch of inserts, the database is going to,

00:49:28.910 --> 00:49:32.010
may try updating those indexes as your inserting
all of your data.

00:49:32.010 --> 00:49:36.710
But if you insert the data first, and then
create the indexes, you may end up with less

00:49:36.710 --> 00:49:40.940
work on the database engine side of things.

00:49:40.940 --> 00:49:43.340
It may be faster.

00:49:43.340 --> 00:49:44.340
[pause]

00:49:44.340 --> 00:49:45.340
&gt;&gt;Malin: Okay.

00:49:45.340 --> 00:49:46.500
Any response from them?

00:49:46.500 --> 00:49:47.580
&gt;&gt;Ly: He said, "Thanks."

00:49:47.580 --> 00:49:51.770
&gt;&gt;Malin: Well, if you've got any more questions,
just holler out.

00:49:51.770 --> 00:49:56.670
Otherwise we'll move on to the next question
in Moderator: "I have to load an image with

00:49:56.670 --> 00:49:57.670
certain restrictions.

00:49:57.670 --> 00:50:04.330
For example, I have an 8 megapixel picture
that I want to center crop as a square, rotate,

00:50:04.330 --> 00:50:05.690
and maybe scale it.

00:50:05.690 --> 00:50:11.500
What's the most efficient way to do this without
creating new bitmaps and recycling the old

00:50:11.500 --> 00:50:12.500
ones?"

00:50:12.500 --> 00:50:16.300
&gt;&gt;Johns: [laughs] All right.

00:50:16.300 --> 00:50:18.320
That's actually a pretty good question.

00:50:18.320 --> 00:50:21.200
Jeff, you don't have an answer off the top
of your head for that?

00:50:21.200 --> 00:50:25.940
&gt;&gt;Sharkey: I think it depends on if zooming,
if the user can zoom in on the photo while

00:50:25.940 --> 00:50:28.290
they're actually working on it.

00:50:28.290 --> 00:50:29.290
Because there are some--.

00:50:29.290 --> 00:50:31.740
The 8 megapixels, that's a lot of data behind
the scenes.

00:50:31.740 --> 00:50:35.000
There's a handful of bitmap factories, the
bitmap options.

00:50:35.000 --> 00:50:38.450
You can actually request to have it downsampled.

00:50:38.450 --> 00:50:41.290
You can request it to maybe only load every
other pixel.

00:50:41.290 --> 00:50:44.760
Instead of an 8 megapixel photo, now you're
working with a 4 megapixel.

00:50:44.760 --> 00:50:46.790
There are some options there.

00:50:46.790 --> 00:50:50.360
You can load a lower resolution version of
the photo for the user to edit.

00:50:50.360 --> 00:50:54.960
It may not be the full quality that they're
expecting, and maybe a lower resolution.

00:50:54.960 --> 00:50:58.310
Once you've decided the mutation operations
that the user wants to perform, once they've

00:50:58.310 --> 00:51:03.190
chosen the exact rotation, you can go back
and perform a high quality pass of those operations

00:51:03.190 --> 00:51:04.650
on the full resolution photo.

00:51:04.650 --> 00:51:06.720
That may allow you to make your UI nice and
fast.

00:51:06.720 --> 00:51:14.120
You're maybe rotating and manipulating something
lower quality, but then applying it later

00:51:14.120 --> 00:51:15.490
against the full resolution image.

00:51:15.490 --> 00:51:18.550
&gt;&gt;Meier: That seems like it would be a fairly
good approach for what they're describing

00:51:18.550 --> 00:51:21.320
here, because it's fairly coarse-grained stuff.

00:51:21.320 --> 00:51:22.450
Center crop, square rotate.

00:51:22.450 --> 00:51:26.380
It sounds like they just basically want to
be able to load up any picture in the same

00:51:26.380 --> 00:51:30.620
way that you choose a profile pic or something
in a social network.

00:51:30.620 --> 00:51:32.869
It just needed to be square, so you just pick
it.

00:51:32.869 --> 00:51:35.530
I think in that instance, particularly on
an Android app--.

00:51:35.530 --> 00:51:40.640
Even if you are zooming in, as long as it's
good enough to see what the edges are, you

00:51:40.640 --> 00:51:45.390
do that and then do a live preview of the
cropped data at a higher res, maybe.

00:51:45.390 --> 00:51:46.390
&gt;&gt;Johns: Yeah.

00:51:46.390 --> 00:51:48.590
Bitmap Factory has a methods to do most of
that stuff.

00:51:48.590 --> 00:51:50.590
The only one I'm not clear about is rotation.

00:51:50.590 --> 00:51:53.400
I'm not sure if you can have it rotate for
you.

00:51:53.400 --> 00:51:57.200
If that's the case, you might even want to
consider subclassing bitmap Factory and adding

00:51:57.200 --> 00:52:02.990
rotation in there, so that way all these operations
are performed as your loading the bitmap.

00:52:02.990 --> 00:52:07.131
That would help reduce the-- If you can do
it before you create your bitmap, then you

00:52:07.131 --> 00:52:08.420
only have to make one bitmap.

00:52:08.420 --> 00:52:09.420
&gt;&gt;Sharkey: Yeah.

00:52:09.420 --> 00:52:13.861
The benefit of using those options is that
SKIA, down deep in the native code, is the

00:52:13.861 --> 00:52:16.060
one that's doing this downsampling.

00:52:16.060 --> 00:52:21.240
Your application doesn't have to allocate
8 megapixels worth of data to store the image

00:52:21.240 --> 00:52:22.240
when it's inflated.

00:52:22.240 --> 00:52:25.940
It's doing it in a very optimized way under
the hood.

00:52:25.940 --> 00:52:26.940
[pause]

00:52:26.940 --> 00:52:30.330
&gt;&gt;Malin: Okay, thank you.

00:52:30.330 --> 00:52:35.490
Next question from Moderator: "Could you consider
maintaining the Android and support library

00:52:35.490 --> 00:52:38.210
artifacts official in Maven central?

00:52:38.210 --> 00:52:40.680
Whoever does it now can be a bit slow.

00:52:40.680 --> 00:52:43.420
It is a pain in the [pause] ass.

00:52:43.420 --> 00:52:46.190
For want of a better word."

00:52:46.190 --> 00:52:48.470
&gt;&gt;Johns: Feature request noted.

00:52:48.470 --> 00:52:52.860
[chuckles] We've always had a bit of reluctance
to go and support any build systems aside

00:52:52.860 --> 00:52:58.270
from Eclipse, just because that's what we
decided that we want to go and spend our time

00:52:58.270 --> 00:52:59.270
supporting.

00:52:59.270 --> 00:53:01.550
We've always left everything else to the community
to do.

00:53:01.550 --> 00:53:07.250
I'll definitely pass that along to do build
team, or the tools team, rather, and let them

00:53:07.250 --> 00:53:08.800
know that there's a feature request for that.

00:53:08.800 --> 00:53:10.680
That being said, I'm pretty sure they've heard
it before.

00:53:10.680 --> 00:53:15.340
It's not the first time I've seen this come
up.

00:53:15.340 --> 00:53:21.580
Most likely [pause] it's going to be a bit
of a tough sell, because we have chosen to

00:53:21.580 --> 00:53:23.660
go and focus most of our efforts on Eclipse.

00:53:23.660 --> 00:53:26.370
But again, I'll make sure they get that feedback.

00:53:26.370 --> 00:53:30.160
&gt;&gt;Meier: Related to that as well, we sit right
next to the tools team.

00:53:30.160 --> 00:53:34.210
If you guys have questions or requests or
something like that and you'd like to see

00:53:34.210 --> 00:53:39.280
us do a Hangout or something like this, specifically
so you guys can talk to them, let us know.

00:53:39.280 --> 00:53:41.710
We'll schedule something up.

00:53:41.710 --> 00:53:42.960
That is a resource available.

00:53:42.960 --> 00:53:48.280
We're not part of that team, so we aren't
necessarily in the best position to answer

00:53:48.280 --> 00:53:51.130
those sorts of questions.

00:53:51.130 --> 00:53:52.359
&gt;&gt;Malin: All right.

00:53:52.359 --> 00:53:55.690
We're getting towards the end, so let's move
on through as quickly as we can.

00:53:55.690 --> 00:54:02.810
"Did the Nexus S have its offline voice dictation
and hot word detection disabled in 4.1.1 due

00:54:02.810 --> 00:54:04.360
to inadequate audio hardware?

00:54:04.360 --> 00:54:10.500
If so, what are your guidelines for testing
if devices running 4.1 meet the baseline for

00:54:10.500 --> 00:54:14.200
using the relevant new multimedia APIs?"

00:54:14.200 --> 00:54:17.670
&gt;&gt;Johns: I don't think anybody here actually
knows the answer to that, given that none

00:54:17.670 --> 00:54:22.520
of us work on the voice team.

00:54:22.520 --> 00:54:27.320
This is probably a question better suited
for another office hours where we might have

00:54:27.320 --> 00:54:29.280
someone from the voice team on.

00:54:29.280 --> 00:54:33.030
But right now, we have no expert who can actually
give you a definitive answer there.

00:54:33.030 --> 00:54:35.660
&gt;&gt;Ly: We had a Hangout question.

00:54:35.660 --> 00:54:36.880
&gt;&gt;Malin: Go for it.

00:54:36.880 --> 00:54:39.800
&gt;&gt;Ly: It's about location updates in a service.

00:54:39.800 --> 00:54:40.800
&gt;&gt;Malin: Right.

00:54:40.800 --> 00:54:46.110
&gt;&gt;Ly: "Is it better, battery-wise, to sample
updates from network or passive providers

00:54:46.110 --> 00:54:53.140
on an interval, or register, on start, a listener
for pending intent and depend on their request

00:54:53.140 --> 00:54:56.290
updates parameters for min time and min distance?

00:54:56.290 --> 00:55:00.160
&gt;&gt;Meier: Okay, let me see if I understand
this.

00:55:00.160 --> 00:55:07.210
So the question is, are they better off poling,
basically getting a last known location?

00:55:07.210 --> 00:55:14.150
Or using a, basically asking for a location
based updates at a minimum time and distance?

00:55:14.150 --> 00:55:15.150
Is that the gist?

00:55:15.150 --> 00:55:16.440
&gt;&gt;Ly: Yeah, it sounds about right.

00:55:16.440 --> 00:55:23.190
&gt;&gt;Johns: From what I remember, Get Last Position
is literally returning the last known position,

00:55:23.190 --> 00:55:27.290
which is not going to be where the user is,
necessarily, at that given moment.

00:55:27.290 --> 00:55:28.730
That is one issue you have to deal with.

00:55:28.730 --> 00:55:29.990
&gt;&gt;Meier: Yeah, I would say gen--.

00:55:29.990 --> 00:55:35.370
In terms of efficiency, hmm.

00:55:35.370 --> 00:55:41.670
In terms of efficiency, I would almost never
recommend a poling approach.

00:55:41.670 --> 00:55:45.450
As soon as you're poling for anything, then
you're creating a minimum amount of time where

00:55:45.450 --> 00:55:49.760
the device is going to be on, responding to
whatever it is that you're doing at that wake

00:55:49.760 --> 00:55:50.760
up.

00:55:50.760 --> 00:55:56.540
If you can have anything which is more on
demand, that tends to be a better solution.

00:55:56.540 --> 00:56:00.690
I would definitely go with actually creating
a location listener, particularly for the

00:56:00.690 --> 00:56:02.240
passive provider.

00:56:02.240 --> 00:56:08.109
That way, if there are no apps requesting
location updates, then your app will never

00:56:08.109 --> 00:56:09.109
get triggered.

00:56:09.109 --> 00:56:10.109
It will go to sleep.

00:56:10.109 --> 00:56:13.030
This is really important when the device is
on standby.

00:56:13.030 --> 00:56:16.590
If you are doing a poling solution, then you're
still going to wake the device, and you're

00:56:16.590 --> 00:56:20.870
still going to check to see when that last
location update was, even if it hasn't changed

00:56:20.870 --> 00:56:21.870
for an hour.

00:56:21.870 --> 00:56:25.800
Whereas if you've actually got to listener
registered, it's no less efficient than poling

00:56:25.800 --> 00:56:27.250
in terms of the work it's doing.

00:56:27.250 --> 00:56:31.530
And you have the advantage of being on demand,
so that it's only going to happen as frequently

00:56:31.530 --> 00:56:36.810
as any other app is actually making those
location requests.

00:56:36.810 --> 00:56:38.660
&gt;&gt;Malin: Okay.

00:56:38.660 --> 00:56:40.520
Thank you.

00:56:40.520 --> 00:56:44.010
This is an interesting one: "Can you take
another look at my question from last week?

00:56:44.010 --> 00:56:45.211
We ran out of time at the end.

00:56:45.211 --> 00:56:50.119
The question is 'How to iterate through fragments
in a tab view pager to tell each fragment

00:56:50.119 --> 00:56:57.493
the ping data which as been updated by a loader
in the main activity?'" [pause]

00:56:57.493 --> 00:57:00.280
&gt;&gt;Meier: I remember hearing the question last
week while I was doing the production.

00:57:00.280 --> 00:57:04.530
I don't think we had a great answer then,
and I'm not sure that there really is one.

00:57:04.530 --> 00:57:05.810
&gt;&gt;Johns: I still--.

00:57:05.810 --> 00:57:13.090
My question is "Why are you trying to do this?"
given that you're only going to have one page

00:57:13.090 --> 00:57:14.830
on your view pager visible.

00:57:14.830 --> 00:57:21.020
Trying to ask anything else to update while
it's in the background is just a waste of

00:57:21.020 --> 00:57:22.020
CPU.

00:57:22.020 --> 00:57:25.100
Most UI events don't occur for objects which
are off screen.

00:57:25.100 --> 00:57:33.620
Now, that being said, the quest there, the
answer here is basically your typical solution

00:57:33.620 --> 00:57:35.020
for communicating with fragments.

00:57:35.020 --> 00:57:38.510
I don't think view pager really has anything
to do with it.

00:57:38.510 --> 00:57:43.360
It's really a matter of going and sending
a method to all of your fragments.

00:57:43.360 --> 00:57:49.250
Register some sort of callback method so that
your activity can just go an deliver a message

00:57:49.250 --> 00:57:52.920
to all the known fragments when these events
happen and let them know that they have stale

00:57:52.920 --> 00:57:56.440
data which needs to be refreshed at some point
which is appropriate.

00:57:56.440 --> 00:58:01.330
&gt;&gt;Sharkey: That's a--, data set observer is
one way that list views, for example, connect

00:58:01.330 --> 00:58:02.520
up to cursors.

00:58:02.520 --> 00:58:06.980
When you sign a cursor to a cursor loader
and it's bound to a list view, that list view

00:58:06.980 --> 00:58:08.680
may be often one of those other fragments.

00:58:08.680 --> 00:58:12.230
But the data set observer is the mechanism
by which it knows, "I need to invalidate and

00:58:12.230 --> 00:58:13.400
repaint my content."

00:58:13.400 --> 00:58:14.930
A strategy like that.

00:58:14.930 --> 00:58:17.140
There's data set observer and data set observable.

00:58:17.140 --> 00:58:22.300
Those may be a good strategy.

00:58:22.300 --> 00:58:23.300
&gt;&gt;Malin: Okay.

00:58:23.300 --> 00:58:26.780
&gt;&gt;Ly: We got another Hangout question, and
two more minutes.

00:58:26.780 --> 00:58:28.000
&gt;&gt;Malin: All right.

00:58:28.000 --> 00:58:29.000
Hangout question.

00:58:29.000 --> 00:58:30.450
&gt;&gt;Ly: Last one here.

00:58:30.450 --> 00:58:37.510
This person has quite a big database of assets
and dumps it into an SD card.

00:58:37.510 --> 00:58:43.880
"Is there a way to access this database directly
to assets so I don't have to duplicate it,

00:58:43.880 --> 00:58:46.940
since it's, like, 6 megabytes?"

00:58:46.940 --> 00:58:48.100
Does that make sense?

00:58:48.100 --> 00:58:52.859
&gt;&gt;Meier: Yes, I think what he wants to do
here is basically-- Similar to the question

00:58:52.859 --> 00:58:58.410
which one of the earlier questioners had,
which is "I want to prepopulate a database,

00:58:58.410 --> 00:59:00.530
but I don't want to download it in a piecemeal.

00:59:00.530 --> 00:59:04.680
I just want to be able to dump it on an SD
card, possibly as part of the installation

00:59:04.680 --> 00:59:06.040
process or as a one-off."

00:59:06.040 --> 00:59:10.820
Right now, you would have to do-- The usual
way is that you would then have to open that

00:59:10.820 --> 00:59:15.790
database, move everything into an SQLite database,
and have the content provider on top of that

00:59:15.790 --> 00:59:17.470
to do most operations.

00:59:17.470 --> 00:59:21.850
I think the question here is, "Is there a
way you can just point to that database and

00:59:21.850 --> 00:59:23.300
say, 'This is my database.

00:59:23.300 --> 00:59:27.800
Treat it the same way you would an SQLite
database that you've had opened.'?"

00:59:27.800 --> 00:59:30.760
I'm not sure that I have an answer.

00:59:30.760 --> 00:59:33.550
I think if it is an SQLite database, then
you probably can.

00:59:33.550 --> 00:59:36.780
If it's not, then I'm not sure that that's
possible.

00:59:36.780 --> 00:59:38.780
Do you guys have any?

00:59:38.780 --> 00:59:42.540
&gt;&gt;Sharkey: SQLite databases, I think you can
open based on an explicit file system path.

00:59:42.540 --> 00:59:44.460
You can tell it, "Open this file."

00:59:44.460 --> 00:59:50.000
But one thing to note is that if it's living
out on the SD card, anyone could come along,

00:59:50.000 --> 00:59:54.780
open it writable, and write any sort of data
in there, which then your app is going to

00:59:54.780 --> 00:59:55.780
go consume.

00:59:55.780 --> 00:59:59.570
Anything on the SD card is publicly available
for other apps to write into.

00:59:59.570 --> 01:00:03.660
The other thing is if you're using it for
persistence, just be aware that sometimes

01:00:03.660 --> 01:00:05.500
the SD card can disappear.

01:00:05.500 --> 01:00:06.500
But it may also not be--.

01:00:06.500 --> 01:00:10.980
The SD card can be of [beeping noise] varying
quality, because they're using a different

01:00:10.980 --> 01:00:13.240
file system that's maybe not as resilient.

01:00:13.240 --> 01:00:18.460
If you're using the internal file system on
the device, maybe it's like EAFS or ext4,

01:00:18.460 --> 01:00:22.740
it's a lot more resilient to changes if the
user pulls the battery out of their device.

01:00:22.740 --> 01:00:27.040
&gt;&gt;Meier: Yeah, I think that, I really just
want to emphasize that first point, which

01:00:27.040 --> 01:00:33.780
is that it's trivially easy for your SD card
to be, or your shared space to be, unmounted.

01:00:33.780 --> 01:00:37.750
If someone plugs it into their computer, boom,
your database disappears.

01:00:37.750 --> 01:00:42.790
If they unclick their SD card, boom, your
database is gone.

01:00:42.790 --> 01:00:47.480
That adds a certain amount of-- how can I
say?

01:00:47.480 --> 01:00:49.180
It doesn't do bad things.

01:00:49.180 --> 01:00:51.210
It doesn't do good things to your app.

01:00:51.210 --> 01:00:55.320
Suddenly, you have to keep in mind the fact
that your database may just disappear mid

01:00:55.320 --> 01:00:59.040
transaction, and figure out how you're going
to recover from that.

01:00:59.040 --> 01:01:01.140
And as well, as Jeff said, it can change.

01:01:01.140 --> 01:01:04.910
It can be mounted to a computer, then have
all its data changed, then plugged back in.

01:01:04.910 --> 01:01:08.330
You need to figure out what you're going to
do with that now.

01:01:08.330 --> 01:01:12.400
It's generally not great practice to go that
way.

01:01:12.400 --> 01:01:16.599
Granted, if you've got a very large database,
it seems like a reasonable alternative.

01:01:16.599 --> 01:01:21.390
But you may actually want to consider storing,
keeping most of that on a server and just

01:01:21.390 --> 01:01:27.310
downloading effectively enough data to have
cached a reasonable amount of data to be able

01:01:27.310 --> 01:01:32.000
to respond to when you're offline, rather
than storing the entire thing on the phone.

01:01:32.000 --> 01:01:36.730
Depending on your usage, that may not work.

01:01:36.730 --> 01:01:37.910
&gt;&gt;Johns: Okay.

01:01:37.910 --> 01:01:40.960
All right, I think that's it for time.

01:01:40.960 --> 01:01:41.960
[laughs]

01:01:41.960 --> 01:01:44.859
&gt;&gt;Malin: I think we have run off the end of
the clock.

01:01:44.859 --> 01:01:50.349
[pause] So, once again, thank you, everybody,
for stopping in.

01:01:50.349 --> 01:01:52.240
We will see you next week.

01:01:52.240 --> 01:01:53.230
&gt;&gt;Sharkey: Thanks, everyone.

