WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.360
[MUSIC PLAYING]

00:00:04.855 --> 00:00:06.490
FLORINA MUNTENESCU:
Hello, everyone.

00:00:06.490 --> 00:00:07.770
I'm Florina Muntenescu.

00:00:07.770 --> 00:00:10.467
I'm an engineer in the
Developer Relations team.

00:00:10.467 --> 00:00:12.050
SIYAMED SINIR: Hi,
I am Siyamed Sinir.

00:00:12.050 --> 00:00:13.962
I am engineer in
UI Toolkit team.

00:00:13.962 --> 00:00:14.670
SEIGO NONAKA: Hi.

00:00:14.670 --> 00:00:15.950
My name's Seigo Nonaka.

00:00:15.950 --> 00:00:19.775
I'm also engineer
in UI Toolkit team.

00:00:19.775 --> 00:00:21.150
FLORINA MUNTENESCU:
Last year, we

00:00:21.150 --> 00:00:25.320
told you the basics of
best practices with text.

00:00:25.320 --> 00:00:28.720
And this year, we want
to build on top of that.

00:00:28.720 --> 00:00:32.729
So if you haven't seen that
talk yet, go check it out.

00:00:32.729 --> 00:00:33.290
We'll wait.

00:00:36.450 --> 00:00:41.090
This year, we looked
again at topics

00:00:41.090 --> 00:00:44.810
that you have most problems
with, the ones that you feel

00:00:44.810 --> 00:00:46.380
are most challenging.

00:00:46.380 --> 00:00:50.670
So in this talk, we're going
to cover a variety of topics.

00:00:50.670 --> 00:00:54.200
Some are wider, more
generally applicable,

00:00:54.200 --> 00:00:58.460
and some are more
niche advanced topics.

00:00:58.460 --> 00:01:00.650
And the solutions,
as you'll see,

00:01:00.650 --> 00:01:05.400
are either new APIs in queue
or some specific guidance.

00:01:05.400 --> 00:01:06.275
So let's get started.

00:01:09.640 --> 00:01:12.570
SEIGO NONAKA: OK, let's get
started from performance.

00:01:12.570 --> 00:01:16.380
The performance is a top
topic in the user experience,

00:01:16.380 --> 00:01:19.850
and text is one of the most
heavily used components

00:01:19.850 --> 00:01:23.590
in UI Toolkit team.

00:01:23.590 --> 00:01:26.990
Despite from the usage, the
most of the internal things

00:01:26.990 --> 00:01:29.710
are black box and
how to optimize

00:01:29.710 --> 00:01:33.080
for many of developers.

00:01:33.080 --> 00:01:36.470
We have been keep improving
the TextView performance

00:01:36.470 --> 00:01:42.910
and it shows some utility
tips in less Google I/O.

00:01:42.910 --> 00:01:47.980
This year, first let me announce
that the hyphenation is now

00:01:47.980 --> 00:01:56.410
turned off by default in Android
Q and AppCompat version 1.1.

00:01:56.410 --> 00:01:59.380
As we talked last
year, the hyphenation

00:01:59.380 --> 00:02:04.050
has a huge impact to the
TextView performance.

00:02:04.050 --> 00:02:09.430
Actually, the 70% of the
text work is for hyphenation.

00:02:09.430 --> 00:02:12.850
So we turned off
with by default.

00:02:12.850 --> 00:02:15.850
If you need hyphenation,
please manually turn

00:02:15.850 --> 00:02:18.024
it own in your application.

00:02:20.810 --> 00:02:23.030
To enable the
hyphenations, please

00:02:23.030 --> 00:02:27.460
set hyphenation frequency
attribute to normal

00:02:27.460 --> 00:02:32.840
in style.xml or layout.xml.

00:02:32.840 --> 00:02:36.320
Also, you can call fit
hyphenation frequency method

00:02:36.320 --> 00:02:39.280
in your code.

00:02:39.280 --> 00:02:42.910
OK, next.

00:02:42.910 --> 00:02:48.010
We released the precomputed
text in last Google I/O.

00:02:48.010 --> 00:02:53.380
This is a tool for doing text
work in background thread.

00:02:53.380 --> 00:02:57.460
This does 90% of
text work beforehand,

00:02:57.460 --> 00:02:59.245
selecting fonts
or measuring text.

00:03:02.160 --> 00:03:04.190
This is a [INAUDIBLE]
object and it should be

00:03:04.190 --> 00:03:07.960
created in background thread.

00:03:07.960 --> 00:03:10.240
And we back ported
this craft to jet pack

00:03:10.240 --> 00:03:11.700
and available from API 21.

00:03:14.900 --> 00:03:19.010
Then this year, we
added new utility APIs

00:03:19.010 --> 00:03:21.395
for easy integration with
RecyclerView prefetch.

00:03:25.060 --> 00:03:28.180
Before looking into the
details, let's see the overview

00:03:28.180 --> 00:03:30.820
of the RecyclerView prefetch.

00:03:30.820 --> 00:03:34.180
This figure shows the work
growth of UI thread and render

00:03:34.180 --> 00:03:36.290
thread.

00:03:36.290 --> 00:03:40.100
UI thread does some work
and pass the rendering work

00:03:40.100 --> 00:03:43.220
to render thread.

00:03:43.220 --> 00:03:47.740
The eye icon shows
the timing of VSYNC.

00:03:47.740 --> 00:03:53.290
You see here shows a good state,
nothing broke the VSYNC event.

00:03:53.290 --> 00:03:56.590
But if some work takes
time and couldn't

00:03:56.590 --> 00:03:59.320
finish until the
next VSYNC event,

00:03:59.320 --> 00:04:01.690
it end up with [INAUDIBLE].

00:04:01.690 --> 00:04:04.660
In this example, the
lid works takes time

00:04:04.660 --> 00:04:06.120
and blocks the next VSYNC event.

00:04:08.810 --> 00:04:12.200
This typically happens
when the new item

00:04:12.200 --> 00:04:15.860
is appeared by scrolling.

00:04:15.860 --> 00:04:20.149
The idea of prefetch is
doing this view item process

00:04:20.149 --> 00:04:23.090
in much earlier time when
the UI thread is idle.

00:04:25.610 --> 00:04:28.940
If everything goes well, the
workload of the UI thread

00:04:28.940 --> 00:04:32.532
have distributed, and we
can prevent UI [INAUDIBLE]..

00:04:35.190 --> 00:04:37.210
This is just the overview.

00:04:37.210 --> 00:04:40.500
So if you need the more details,
please check the articles

00:04:40.500 --> 00:04:42.971
on the Android developer
medium publication.

00:04:46.410 --> 00:04:50.150
This is how prefetch
works, but this prefetch

00:04:50.150 --> 00:04:52.250
had three limitations.

00:04:52.250 --> 00:04:56.550
The prefetch still
works on the UI thread.

00:04:56.550 --> 00:04:59.890
If prefetch takes longer
time, that prefetch

00:04:59.890 --> 00:05:02.760
still blocks the VSYNC event.

00:05:02.760 --> 00:05:04.590
This typically
happens when you set

00:05:04.590 --> 00:05:06.450
long, long text to TextView.

00:05:10.430 --> 00:05:12.170
One obvious reason
for this problem

00:05:12.170 --> 00:05:16.760
is moving some work
to background thread.

00:05:16.760 --> 00:05:21.020
Actually, you can move some
text work to background thread

00:05:21.020 --> 00:05:24.530
by using PrecomputedText.

00:05:24.530 --> 00:05:28.610
However, in general, moving
some work to background set

00:05:28.610 --> 00:05:32.100
is not a trivial work.

00:05:32.100 --> 00:05:37.960
So we introduce new utility APIs
for make this happen easily.

00:05:37.960 --> 00:05:42.760
The API is getTextFuture
in PrecomputedTextCompat

00:05:42.760 --> 00:05:46.600
and setTextFuture in
AppCompatTextView.

00:05:46.600 --> 00:05:47.600
Let's see how it works.

00:05:51.480 --> 00:05:54.360
When you write the application
with the RecyclerView,

00:05:54.360 --> 00:05:58.336
you may set text in
onBindViewHolder callback

00:05:58.336 --> 00:06:01.490
like this.

00:06:01.490 --> 00:06:04.710
Then, if we move that text
work to background set,

00:06:04.710 --> 00:06:06.460
the code looks like this.

00:06:06.460 --> 00:06:10.080
Let's see it line by line.

00:06:10.080 --> 00:06:13.590
First, let's call getTextFuture.

00:06:13.590 --> 00:06:16.110
The getTextFuture
schedule text work

00:06:16.110 --> 00:06:18.990
on the past
execution and returns

00:06:18.990 --> 00:06:24.210
the future of the result.
Once you get the future,

00:06:24.210 --> 00:06:27.060
you can set it to
the AppCompatTextView

00:06:27.060 --> 00:06:30.220
by calling setTextFuture.

00:06:30.220 --> 00:06:33.270
Basically, that's it.

00:06:33.270 --> 00:06:36.300
By coding these two APIs,
you can move the text work

00:06:36.300 --> 00:06:37.200
to background set.

00:06:40.200 --> 00:06:43.730
This is pretty simple, but
please note that you cannot

00:06:43.730 --> 00:06:47.740
change the style after
coding getTextFuture,

00:06:47.740 --> 00:06:51.080
because getTextFuture
schedules the text work with

00:06:51.080 --> 00:06:54.520
the parameters when it's called.

00:06:54.520 --> 00:06:57.490
So if you change the
style after that,

00:06:57.490 --> 00:07:00.250
the async work
result won't match up

00:07:00.250 --> 00:07:02.530
with the parameter
of the TextView.

00:07:02.530 --> 00:07:04.791
Then it end up
with the exception.

00:07:07.380 --> 00:07:09.980
So if you want to
change the style,

00:07:09.980 --> 00:07:12.593
please do it before
calling getTextFuture.

00:07:16.460 --> 00:07:20.450
If you need more details
or what is under the hood,

00:07:20.450 --> 00:07:23.210
please check the article on
the Android developer medium

00:07:23.210 --> 00:07:24.440
publication.

00:07:24.440 --> 00:07:26.267
Thank you.

00:07:26.267 --> 00:07:32.478
[APPLAUSE]

00:07:32.478 --> 00:07:34.270
FLORINA MUNTENESCU:
Apart from performance,

00:07:34.270 --> 00:07:36.600
another thing that
everyone needs to work with

00:07:36.600 --> 00:07:38.610
is text styling.

00:07:38.610 --> 00:07:43.380
But with so many ways of styling
text, which one should you use?

00:07:43.380 --> 00:07:47.200
And what's the precedence
order for each of them?

00:07:47.200 --> 00:07:49.710
So one of the easiest
ways to style text

00:07:49.710 --> 00:07:52.590
is by just using the
TextView attributes.

00:07:52.590 --> 00:07:55.620
But the problem with this
is that this is tedious

00:07:55.620 --> 00:07:57.130
and error prone.

00:07:57.130 --> 00:07:58.590
If you, for example,
need to update

00:07:58.590 --> 00:08:01.320
the color of the
TextViews, you need

00:08:01.320 --> 00:08:04.710
to see absolutely every
TextView in your application,

00:08:04.710 --> 00:08:06.850
and then do that update

00:08:06.850 --> 00:08:10.380
The solution for this
is working with styles.

00:08:10.380 --> 00:08:14.685
They bring you consistency,
reusability, and easy updates.

00:08:17.670 --> 00:08:20.940
And this actually brings us
to the first precedence order.

00:08:20.940 --> 00:08:25.590
So you see here, we have both
the text size in the style

00:08:25.590 --> 00:08:27.780
and also in the text attribute.

00:08:27.780 --> 00:08:33.330
So which text size will
the text actually have?

00:08:33.330 --> 00:08:36.150
Well, the view attributes
overrides the one

00:08:36.150 --> 00:08:37.480
from the style.

00:08:37.480 --> 00:08:40.409
So what you'll see here
is a text that's 16 sp.

00:08:43.270 --> 00:08:45.140
Views have a default style.

00:08:45.140 --> 00:08:48.480
So for example, for
the button that's

00:08:48.480 --> 00:08:50.710
a subclass of the
TextView, you'll

00:08:50.710 --> 00:08:54.070
see that we're also using
a theme attribute, that's

00:08:54.070 --> 00:08:55.980
the button style.

00:08:55.980 --> 00:08:58.720
Well, in the
Material theme, this

00:08:58.720 --> 00:09:02.990
pointed to a certain style
which styles different elements,

00:09:02.990 --> 00:09:07.640
including attributes of
the text of the button.

00:09:07.640 --> 00:09:09.620
By setting your
default styles, it

00:09:09.620 --> 00:09:13.970
means that styling becomes an
opt out rather than opt in.

00:09:13.970 --> 00:09:17.120
By default, all buttons,
independent If you're

00:09:17.120 --> 00:09:19.640
adding them to new screens
or you're refactoring,

00:09:19.640 --> 00:09:21.570
will have a default style.

00:09:21.570 --> 00:09:23.390
So you'll only
need to modify them

00:09:23.390 --> 00:09:25.070
if you specifically
want to change

00:09:25.070 --> 00:09:28.590
the style for the button.

00:09:28.590 --> 00:09:31.590
So by default, but
this default style

00:09:31.590 --> 00:09:35.610
is going to be overridden by
any style that sits directly

00:09:35.610 --> 00:09:37.950
on the view.

00:09:37.950 --> 00:09:42.480
The button properties, as some
eagle eye might have seen here,

00:09:42.480 --> 00:09:46.350
are set using the
text appearance.

00:09:46.350 --> 00:09:49.320
So text appearance actually
functions very similarly

00:09:49.320 --> 00:09:50.700
to a style.

00:09:50.700 --> 00:09:53.850
Under the hood, the TextView
checks whether the view

00:09:53.850 --> 00:09:55.680
has a text appearance.

00:09:55.680 --> 00:09:56.610
It loads it.

00:09:56.610 --> 00:09:58.050
It applies it to the view.

00:09:58.050 --> 00:09:59.970
And then, it adds all
the other attributes,

00:09:59.970 --> 00:10:03.030
like the text style, also.

00:10:03.030 --> 00:10:05.400
So this means that, as
the precedence order,

00:10:05.400 --> 00:10:07.260
the text appearance
is then overridden

00:10:07.260 --> 00:10:09.540
by the default style,
and then the style,

00:10:09.540 --> 00:10:12.890
and then the view attributes.

00:10:12.890 --> 00:10:18.260
But there's something you should
know about text appearance.

00:10:18.260 --> 00:10:20.720
It's character building.

00:10:20.720 --> 00:10:23.900
It only supports
character-level styling.

00:10:23.900 --> 00:10:26.510
It doesn't support
paragraph-level styling,

00:10:26.510 --> 00:10:29.780
like line height
or break strategy.

00:10:29.780 --> 00:10:33.440
These can be customized here.

00:10:33.440 --> 00:10:37.340
In Android Q, we added a new
attribute in text appearance--

00:10:37.340 --> 00:10:40.790
the font variation settings.

00:10:40.790 --> 00:10:43.550
And the same attribute,
starting from Q,

00:10:43.550 --> 00:10:48.840
can be used in TextView
and in AppCompatTextView.

00:10:48.840 --> 00:10:50.780
Some of the text
appearance attributes

00:10:50.780 --> 00:10:54.740
are also supported in
text appearance span.

00:10:54.740 --> 00:10:57.230
Before Q, the text
appearance span

00:10:57.230 --> 00:10:59.120
didn't read some of
the text attributes,

00:10:59.120 --> 00:11:01.430
like typeface or shadow.

00:11:01.430 --> 00:11:04.190
So starting from Q, the
text appearance span

00:11:04.190 --> 00:11:08.940
is updated to read and apply
these attributes, as well.

00:11:08.940 --> 00:11:11.130
Also new in Q,
speaking of spans,

00:11:11.130 --> 00:11:13.730
we've added implementations
to two new spans--

00:11:13.730 --> 00:11:17.810
line height span and
line background span.

00:11:17.810 --> 00:11:20.510
When applying the span
on top of text styling,

00:11:20.510 --> 00:11:23.090
keep in mind that the
properties of the span

00:11:23.090 --> 00:11:25.400
set the properties that
are set by the span

00:11:25.400 --> 00:11:27.590
will override any other
properties that you

00:11:27.590 --> 00:11:28.630
might be setting--

00:11:28.630 --> 00:11:33.670
VI style, or default
style, or view.

00:11:33.670 --> 00:11:37.330
But what if you want to change
some attributes of the TextView

00:11:37.330 --> 00:11:38.590
at the app level?

00:11:38.590 --> 00:11:41.590
So let's say that you want
to change the entire font

00:11:41.590 --> 00:11:43.510
in your application.

00:11:43.510 --> 00:11:46.090
Well, for this, you
would use themes.

00:11:46.090 --> 00:11:48.820
So for example here, we're
setting the font family

00:11:48.820 --> 00:11:52.440
attribute to set the theme.

00:11:52.440 --> 00:11:55.170
The theme is part of
the view styling system,

00:11:55.170 --> 00:11:57.840
and it overrides anything
that's supplied in the text

00:11:57.840 --> 00:12:04.580
appearance, but it will override
any more specific attributes.

00:12:04.580 --> 00:12:08.410
So for the text styling, we
looked at the precedence order

00:12:08.410 --> 00:12:13.195
to help you better understand
why or why not style is

00:12:13.195 --> 00:12:13.695
applied.

00:12:17.140 --> 00:12:18.810
SIYAMED SINIR: Thanks.

00:12:18.810 --> 00:12:20.450
Hi again.

00:12:20.450 --> 00:12:22.945
[APPLAUSE]

00:12:22.945 --> 00:12:25.940
Thank you.

00:12:25.940 --> 00:12:28.760
So we have covered tips
related to text styling

00:12:28.760 --> 00:12:30.440
and also performance.

00:12:30.440 --> 00:12:32.570
And we will continue
with fonts, which

00:12:32.570 --> 00:12:34.730
is an important
part of text styling

00:12:34.730 --> 00:12:38.553
and also your application's
brand identity.

00:12:38.553 --> 00:12:40.220
Over the years, you
have mentioned to us

00:12:40.220 --> 00:12:43.243
about the shortcomings of
font support on Android.

00:12:43.243 --> 00:12:44.660
And in the last
few years, we have

00:12:44.660 --> 00:12:47.600
added features such as
downloadable fonts and fonts

00:12:47.600 --> 00:12:48.860
in XML.

00:12:48.860 --> 00:12:52.040
This year, we have improved the
typeface and font-related APIs

00:12:52.040 --> 00:12:54.370
based on the further
feedback we got.

00:12:57.010 --> 00:12:59.470
Let's go over a
real-life use case,

00:12:59.470 --> 00:13:01.180
and let's assume
that we have an app.

00:13:01.180 --> 00:13:03.370
And in one of our
buttons, we want

00:13:03.370 --> 00:13:05.860
to use an icon in
between the text.

00:13:05.860 --> 00:13:09.100
And we want this icon to be
rendered using the icon font.

00:13:09.100 --> 00:13:10.690
And for the remaining
of the text,

00:13:10.690 --> 00:13:14.860
we want to use another
custom font, let's say, Lato.

00:13:14.860 --> 00:13:17.170
When we want to do this,
we are kind of in trouble,

00:13:17.170 --> 00:13:21.340
because the button will
accept only a single typeface,

00:13:21.340 --> 00:13:24.280
and a typeface can be created
using a single font or font

00:13:24.280 --> 00:13:26.110
family.

00:13:26.110 --> 00:13:30.430
Actually, in the current API,
we can use a typeface span,

00:13:30.430 --> 00:13:34.510
give the icon font into it,
and cover the icon character.

00:13:34.510 --> 00:13:36.370
And then for the
whole button, we

00:13:36.370 --> 00:13:40.070
can choose to use the Lato font.

00:13:40.070 --> 00:13:43.180
However, things will get
much more complicated

00:13:43.180 --> 00:13:47.110
if we were to try to
support multiple languages

00:13:47.110 --> 00:13:49.600
with their own custom fonts.

00:13:49.600 --> 00:13:52.840
Using spans here is definitely
not a scalable solution,

00:13:52.840 --> 00:13:55.780
because you will have a lot
of languages to support,

00:13:55.780 --> 00:13:58.360
and it's pretty hard
to accurately identify

00:13:58.360 --> 00:14:01.600
different languages
for a given string.

00:14:01.600 --> 00:14:04.030
And on top of that,
over the years

00:14:04.030 --> 00:14:06.880
I have heard continuously,
parsing emoji, for example,

00:14:06.880 --> 00:14:07.970
is pretty hard.

00:14:07.970 --> 00:14:10.210
And if you have another
custom emoji font,

00:14:10.210 --> 00:14:13.960
that would be a pain.

00:14:13.960 --> 00:14:17.020
Therefore, in Android Q, we
added custom fallback builder

00:14:17.020 --> 00:14:18.640
to the typeface class.

00:14:18.640 --> 00:14:22.750
It enables you to create a
typeface using multiple fonts

00:14:22.750 --> 00:14:25.660
or font families.

00:14:25.660 --> 00:14:28.360
Then we check our
multi-language use case.

00:14:28.360 --> 00:14:31.840
Here we create a builder, and
for each of the languages,

00:14:31.840 --> 00:14:36.310
we create a font family and add
the related fonts into them.

00:14:36.310 --> 00:14:40.170
And this will also show the
icon font use case, as well,

00:14:40.170 --> 00:14:43.030
where this time
again, we put the icon

00:14:43.030 --> 00:14:46.780
font as a separate font family
into the final typeface.

00:14:49.690 --> 00:14:52.030
Then you have multiple
styles for a font family,

00:14:52.030 --> 00:14:55.180
you can add them into the
same font family object.

00:14:55.180 --> 00:14:57.940
And whenever you set the text,
we have to use bold style

00:14:57.940 --> 00:15:01.930
or mark a portion of the
text to be bold using spans.

00:15:01.930 --> 00:15:04.270
The system will choose
the correct bold font

00:15:04.270 --> 00:15:08.480
from the given configuration.

00:15:08.480 --> 00:15:11.060
When creating a typeface
using this builder,

00:15:11.060 --> 00:15:14.370
you can add up to
64 font families.

00:15:14.370 --> 00:15:19.220
However, what you cannot do is
you cannot put the fonts that

00:15:19.220 --> 00:15:22.730
belong conceptually to different
font families into the same

00:15:22.730 --> 00:15:24.930
font family object.

00:15:24.930 --> 00:15:27.770
The reason is the system
expects the fonts that

00:15:27.770 --> 00:15:30.950
are in the same font family
to have the same code

00:15:30.950 --> 00:15:32.450
coverage, which
means that they have

00:15:32.450 --> 00:15:35.300
to have one-to-one mapping
between the characters

00:15:35.300 --> 00:15:37.040
that they support.

00:15:37.040 --> 00:15:39.500
And the other thing that
you cannot do is to put two

00:15:39.500 --> 00:15:43.460
of the same styled fonts
into the same font family.

00:15:43.460 --> 00:15:46.580
For example, here, if I
were to put Lato bold twice

00:15:46.580 --> 00:15:52.880
into the same font family,
I would get an exception.

00:15:52.880 --> 00:15:55.350
And then you define a
custom fallback builder.

00:15:55.350 --> 00:15:57.210
Here is how the system works.

00:15:57.210 --> 00:16:00.230
It does a sequential search
over the string, and also

00:16:00.230 --> 00:16:02.390
over the fonts
that are provided.

00:16:02.390 --> 00:16:04.160
For example, in
here, it will start

00:16:04.160 --> 00:16:07.160
with the Japanese
character, and it

00:16:07.160 --> 00:16:10.040
will check if Lato font
supports this character.

00:16:10.040 --> 00:16:13.010
If not, it will go to the
second one, see Kosugi,

00:16:13.010 --> 00:16:16.160
and at that point, it will try
to cover as many characters as

00:16:16.160 --> 00:16:18.330
possible using the same font.

00:16:18.330 --> 00:16:22.950
And then it will do the
same thing over again.

00:16:22.950 --> 00:16:26.630
And if the string
contains language

00:16:26.630 --> 00:16:29.000
that is not supported
with the given font,

00:16:29.000 --> 00:16:31.160
the system will use
the system fallback use

00:16:31.160 --> 00:16:37.590
case, which is the current
case for Android and typeface.

00:16:37.590 --> 00:16:39.600
As a control over
system fallback,

00:16:39.600 --> 00:16:43.270
the new API has a function
named setSystemFallback,

00:16:43.270 --> 00:16:46.410
where you define what
kind of generic family

00:16:46.410 --> 00:16:49.560
should be preferred while
choosing a font from the system

00:16:49.560 --> 00:16:50.550
fallback.

00:16:50.550 --> 00:16:53.280
Since Lato is a sans
serif font, here I

00:16:53.280 --> 00:16:55.770
tell the system that
if a character is not

00:16:55.770 --> 00:16:58.350
supported by Lato,
the font that I edit,

00:16:58.350 --> 00:17:00.810
I want system to prefer
a sans-serif font.

00:17:03.680 --> 00:17:07.250
Just like the current
typeface builders,

00:17:07.250 --> 00:17:10.520
while creating a font, you can
set the weight, slant, and also

00:17:10.520 --> 00:17:15.650
the variable font
settings on a font object.

00:17:15.650 --> 00:17:17.630
And finally, in terms
of font matching,

00:17:17.630 --> 00:17:21.230
let's assume that you added
two different weighted forms

00:17:21.230 --> 00:17:24.500
into the same font
family, 400 and 700.

00:17:24.500 --> 00:17:29.180
And by using text font
weight attribute on TextView,

00:17:29.180 --> 00:17:33.320
you requested to render
this text using a 600 font.

00:17:33.320 --> 00:17:35.690
In such mismatches,
the system will

00:17:35.690 --> 00:17:39.110
use the closest match or style.

00:17:39.110 --> 00:17:42.170
For this case, it will
choose to use 700.

00:17:42.170 --> 00:17:45.005
Text font weight was
recently added, I think in P,

00:17:45.005 --> 00:17:46.310
to TextView.

00:17:46.310 --> 00:17:49.310
And it's also currently being
read by text appearance span.

00:17:53.210 --> 00:17:55.426
SEIGO NONAKA:
Thank you, Siyamed.

00:17:55.426 --> 00:17:58.378
[APPLAUSE]

00:18:00.850 --> 00:18:06.150
As he explained, we expanded
the font experience in Android Q

00:18:06.150 --> 00:18:08.890
for Java applications.

00:18:08.890 --> 00:18:10.930
On the other hand, there's
another strong demand

00:18:10.930 --> 00:18:15.160
from NDK application
developers about system fonts.

00:18:15.160 --> 00:18:18.590
So we decided to add new
APIs for existing system

00:18:18.590 --> 00:18:21.790
fonts from native code.

00:18:21.790 --> 00:18:25.960
This would be a great tool for
NDK application filtered text

00:18:25.960 --> 00:18:29.595
on the screen, like a games,
document viewer, or browsers.

00:18:32.530 --> 00:18:36.900
First, what is a system font?

00:18:36.900 --> 00:18:39.640
Android supports
over 100 languages,

00:18:39.640 --> 00:18:43.650
and each languages may
require different font files.

00:18:43.650 --> 00:18:50.220
For example, to draw Hindi,
you may need Devanagari font.

00:18:50.220 --> 00:18:52.800
In case of pixels
three, to support

00:18:52.800 --> 00:18:54.810
this large number
of languages, it

00:18:54.810 --> 00:19:01.130
has over 270 font
files are installed.

00:19:01.130 --> 00:19:05.420
To draw text, NDK application,
like document viewer,

00:19:05.420 --> 00:19:10.780
needs to know which system
font can render the given text.

00:19:10.780 --> 00:19:13.030
This is not a trivial question.

00:19:13.030 --> 00:19:15.100
So we added two
new APIs for this.

00:19:17.680 --> 00:19:20.085
The API is font matcher API.

00:19:22.600 --> 00:19:24.450
This is a interface
of the system

00:19:24.450 --> 00:19:27.890
internal font selection engine.

00:19:27.890 --> 00:19:31.460
This font selection engine
is also used by the TextView,

00:19:31.460 --> 00:19:34.300
so you can get the same
result as in the TextView.

00:19:37.800 --> 00:19:42.500
OK, let's see how this works.

00:19:42.500 --> 00:19:44.690
Let's think with this example.

00:19:44.690 --> 00:19:49.390
The core API is
AFontMatcher match function.

00:19:49.390 --> 00:19:54.730
This takes a search string
and returns two outputs--

00:19:54.730 --> 00:19:55.855
font and length.

00:19:58.630 --> 00:20:02.430
Please note that this API
is simplified for explaining

00:20:02.430 --> 00:20:03.790
its behaviors.

00:20:03.790 --> 00:20:09.820
The real API is written in
C and takes more parameters.

00:20:09.820 --> 00:20:12.980
Anyway, this function
would return,

00:20:12.980 --> 00:20:17.290
in this example, font
NotoSansCJK-Regular and length

00:20:17.290 --> 00:20:19.900
3.

00:20:19.900 --> 00:20:23.110
This length 3 means
first three characters

00:20:23.110 --> 00:20:25.540
can be rendered
with a return font.

00:20:25.540 --> 00:20:29.500
In this case, NotoSansCJK.

00:20:29.500 --> 00:20:34.810
OK, now we know the font for
the first three characters.

00:20:34.810 --> 00:20:36.277
What about remaining?

00:20:39.020 --> 00:20:40.930
Since we know the
first three characters,

00:20:40.930 --> 00:20:44.120
let's advance the search
range, in this case,

00:20:44.120 --> 00:20:48.380
moving starting offset by 3.

00:20:48.380 --> 00:20:49.810
Then, for the same
function again.

00:20:52.960 --> 00:20:55.840
On the second time,
this API returns

00:20:55.840 --> 00:20:59.590
font Roboto-Regular
and length 8.

00:20:59.590 --> 00:21:03.520
Again, this 8 means the
next eight characters--

00:21:03.520 --> 00:21:06.160
in this example, it
includes a white space--

00:21:06.160 --> 00:21:10.450
can render the
Roboto-Regular front.

00:21:10.450 --> 00:21:15.060
Then, advance search range,
then call function again.

00:21:18.700 --> 00:21:23.540
On the third time, now, really,
it is the end of the string.

00:21:23.540 --> 00:21:27.034
So we get all fonts for
the given characters.

00:21:29.940 --> 00:21:33.330
As you've seen it, by keep
coding these functions,

00:21:33.330 --> 00:21:36.000
you can get font files
for all characters.

00:21:39.190 --> 00:21:40.990
This is how this API works.

00:21:40.990 --> 00:21:44.970
But please note that this API
never returns null pointers.

00:21:47.890 --> 00:21:50.860
If no font can render
the given font,

00:21:50.860 --> 00:21:55.830
this API still returns
a byte font object.

00:21:55.830 --> 00:21:59.440
This font of that should be used
for drawing missing with symbol

00:21:59.440 --> 00:21:59.990
called Tofu.

00:22:03.340 --> 00:22:07.880
Similarly, even if it has
no font exactly matches

00:22:07.880 --> 00:22:11.180
with the given
parameters, this function

00:22:11.180 --> 00:22:15.004
still returns a font which
should have a closest style.

00:22:17.910 --> 00:22:18.600
OK.

00:22:18.600 --> 00:22:22.350
This is font matching API.

00:22:22.350 --> 00:22:25.030
This API gives an
answer to the question,

00:22:25.030 --> 00:22:27.390
what font should be
used for the text?

00:22:29.950 --> 00:22:32.080
On the other hand, there's
another frequently asked

00:22:32.080 --> 00:22:33.310
question.

00:22:33.310 --> 00:22:34.935
What fonts are
installed in the device?

00:22:38.120 --> 00:22:39.980
To answer these
questions, we also

00:22:39.980 --> 00:22:42.800
add a new API called
font enumeration API.

00:22:45.700 --> 00:22:48.500
This font enumeration
API gives user

00:22:48.500 --> 00:22:53.690
access to the
system-installed font files.

00:22:53.690 --> 00:22:57.230
Let's see how to use this.

00:22:57.230 --> 00:23:00.420
The Java API is really simple.

00:23:00.420 --> 00:23:05.420
You can just call system
fonts, get the available fonts.

00:23:05.420 --> 00:23:08.840
This gives you the set of
system-installed font files,

00:23:08.840 --> 00:23:11.240
and you can get the clear
path of the system fonts.

00:23:15.170 --> 00:23:21.370
In case of NDK, it starts
from creating iterator object.

00:23:21.370 --> 00:23:25.150
By keep calling next
function to iterator,

00:23:25.150 --> 00:23:29.910
you can access all
system-installed font files.

00:23:29.910 --> 00:23:32.280
But please note that
the returning order

00:23:32.280 --> 00:23:34.620
doesn't mean anything here.

00:23:34.620 --> 00:23:36.880
For example, even
if font A comes

00:23:36.880 --> 00:23:40.700
before font B, that doesn't
mean font A has higher

00:23:40.700 --> 00:23:44.160
priority than font
B. This next function

00:23:44.160 --> 00:23:45.370
returns in random order.

00:23:50.060 --> 00:23:53.750
Finally, there's
another note here.

00:23:53.750 --> 00:23:57.020
This font enumeration
API is not so fast,

00:23:57.020 --> 00:24:01.980
so we recommend you
to cache the result.

00:24:01.980 --> 00:24:04.560
Since the system
font configuration

00:24:04.560 --> 00:24:10.320
is read only and modified
only by the system update,

00:24:10.320 --> 00:24:13.140
so you can keep the
result for a longer time

00:24:13.140 --> 00:24:15.532
until the next system update.

00:24:15.532 --> 00:24:17.987
Thank you.

00:24:17.987 --> 00:24:20.442
[APPLAUSE]

00:24:23.880 --> 00:24:26.160
FLORINA MUNTENESCU: One of
the most used subclasses

00:24:26.160 --> 00:24:28.880
of TextView is EditText.

00:24:28.880 --> 00:24:31.380
And pretty much everything
that applies to the TextView

00:24:31.380 --> 00:24:32.940
also applies to EditText.

00:24:32.940 --> 00:24:34.440
But on top of this,
there are also

00:24:34.440 --> 00:24:36.150
other things that
you need to handle,

00:24:36.150 --> 00:24:40.230
things like layout, styling,
keyboard configuration, input

00:24:40.230 --> 00:24:43.085
formatting,
internationalization, and more.

00:24:43.085 --> 00:24:44.460
Unfortunately, we
don't have time

00:24:44.460 --> 00:24:45.850
to go over all of these today.

00:24:45.850 --> 00:24:48.730
But we will cover some of them.

00:24:48.730 --> 00:24:51.630
So first of all, when
working with EditText,

00:24:51.630 --> 00:24:54.490
you actually interact with
three different processes.

00:24:54.490 --> 00:24:57.550
The first one is
your application.

00:24:57.550 --> 00:25:00.030
The next one is
the soft keyboards,

00:25:00.030 --> 00:25:02.820
named Input Method Service.

00:25:02.820 --> 00:25:05.400
And then the third one
is the system process

00:25:05.400 --> 00:25:07.560
that orchestrates those two.

00:25:07.560 --> 00:25:11.160
And because this is an
inter-process communication,

00:25:11.160 --> 00:25:13.650
you might see in some
cases a slight delay

00:25:13.650 --> 00:25:16.050
between key events
entered in the UI

00:25:16.050 --> 00:25:19.270
and them showing up in the app.

00:25:19.270 --> 00:25:22.590
So visually, EditText has
the following components--

00:25:22.590 --> 00:25:27.750
the hints, the text, the
background, the selection,

00:25:27.750 --> 00:25:31.800
the cursor, and the cursor
and selection handles.

00:25:31.800 --> 00:25:35.430
The background, cursor, and
handles, the colors for these

00:25:35.430 --> 00:25:38.190
are updated when you
set the color secondary

00:25:38.190 --> 00:25:39.920
in your application theme.

00:25:39.920 --> 00:25:41.820
They are actually
just drawables that

00:25:41.820 --> 00:25:45.360
use colorControlNormal
and colorControlActivated

00:25:45.360 --> 00:25:46.890
in their definitions.

00:25:46.890 --> 00:25:50.790
So actually, you can also modify
those theme overlay attributes

00:25:50.790 --> 00:25:53.340
to change their color.

00:25:53.340 --> 00:25:54.840
Each of these
drawables themselves

00:25:54.840 --> 00:25:58.200
can also be updated
using related attributes.

00:25:58.200 --> 00:26:01.290
But probably the one
you want to set the most

00:26:01.290 --> 00:26:03.900
is editTextBackground.

00:26:03.900 --> 00:26:07.020
Finally, textColorHint,
editTextColor,

00:26:07.020 --> 00:26:09.360
and textHighlightColor
are also used

00:26:09.360 --> 00:26:12.840
to update the color
of the other three.

00:26:12.840 --> 00:26:15.960
Apart from these attributes,
just like TextView, EditText

00:26:15.960 --> 00:26:20.460
has its own default style, which
is the editTextStyle attribute.

00:26:20.460 --> 00:26:23.580
And this can be ported
to your own custom style.

00:26:23.580 --> 00:26:26.610
So use this attribute to
change any EditText view

00:26:26.610 --> 00:26:29.939
attributes, such as text
size, or text style.

00:26:34.430 --> 00:26:37.424
[APPLAUSE]

00:26:39.693 --> 00:26:41.360
SIYAMED SINIR: As you
all know, EditText

00:26:41.360 --> 00:26:44.460
has support for
compound drawables.

00:26:44.460 --> 00:26:47.030
And sometimes we see
those compound drawables

00:26:47.030 --> 00:26:49.880
are being used as action
buttons on the EditText,

00:26:49.880 --> 00:26:52.650
such as a clear action.

00:26:52.650 --> 00:26:54.890
However, using
drawables as buttons

00:26:54.890 --> 00:26:57.200
comes with a lot of
constraints, and it definitely

00:26:57.200 --> 00:27:01.220
negatively impacts the
final user experience.

00:27:01.220 --> 00:27:04.970
Things like, when you
add an action button,

00:27:04.970 --> 00:27:07.940
you will probably want to
show the ripples on touch,

00:27:07.940 --> 00:27:10.490
maybe animate the icons,
have more than one icon

00:27:10.490 --> 00:27:11.570
on each side.

00:27:11.570 --> 00:27:14.780
And then you will also have
the accessibility requirements.

00:27:14.780 --> 00:27:16.280
All of these
features are already

00:27:16.280 --> 00:27:19.080
supported by the existing
[INAUDIBLE] layout system.

00:27:19.080 --> 00:27:23.150
And therefore, we will
suggest to use them instead.

00:27:23.150 --> 00:27:25.370
Apart from being
convenient at first,

00:27:25.370 --> 00:27:28.370
I believe that there
might be two reasons why

00:27:28.370 --> 00:27:30.810
people would like to
choose to go that way

00:27:30.810 --> 00:27:32.330
and use the drawables.

00:27:32.330 --> 00:27:35.980
One of them is having the
same EditText look and feel

00:27:35.980 --> 00:27:38.300
over the whole group,
and the other one

00:27:38.300 --> 00:27:41.030
is being able to
contract and expand

00:27:41.030 --> 00:27:46.100
the editable area based on
the visibility of the button.

00:27:46.100 --> 00:27:48.320
You should definitely
use text input layout,

00:27:48.320 --> 00:27:50.390
and that will cover
a lot of use cases.

00:27:50.390 --> 00:27:52.580
However, if you have
application-specific

00:27:52.580 --> 00:27:55.790
requirements that are not
supported by text input layout,

00:27:55.790 --> 00:27:59.450
you should create your
own view group and layout.

00:27:59.450 --> 00:28:02.480
And in order to address the
issue of having the same look

00:28:02.480 --> 00:28:04.790
and feel, you can set
the EditText background

00:28:04.790 --> 00:28:08.330
to null, and use the exact
same background that is already

00:28:08.330 --> 00:28:10.640
in the system for
the view group.

00:28:10.640 --> 00:28:12.770
The only thing we have
to do is, in order

00:28:12.770 --> 00:28:15.770
to respond to the state
changes for the drawable, such

00:28:15.770 --> 00:28:18.020
as pressed and focused,
you have to add

00:28:18.020 --> 00:28:20.930
the addStatesFromChildren
attribute to the parent layout.

00:28:24.630 --> 00:28:28.470
Another common issue in terms
of EditText that we are aware of

00:28:28.470 --> 00:28:31.980
is how the keyboard plays with
a possible input validation

00:28:31.980 --> 00:28:33.510
error.

00:28:33.510 --> 00:28:35.820
Depending on the location
of the input field,

00:28:35.820 --> 00:28:38.130
the error can remain
behind the keyboard,

00:28:38.130 --> 00:28:40.620
and you really want
the users to be

00:28:40.620 --> 00:28:44.370
able to see what went
wrong, let's say,

00:28:44.370 --> 00:28:49.380
when they were going
through a sign up process.

00:28:49.380 --> 00:28:52.470
This is currently the case
also for the text input layout,

00:28:52.470 --> 00:28:54.550
and there is an open
ticket about it.

00:28:54.550 --> 00:28:58.230
But until we get to address this
issue in the material library,

00:28:58.230 --> 00:29:02.080
here is what we can do in order
to make those errors visible.

00:29:04.640 --> 00:29:06.740
There is already
a system in place

00:29:06.740 --> 00:29:10.130
that keeps the
editable area visible

00:29:10.130 --> 00:29:12.020
after the keyboard shows up.

00:29:12.020 --> 00:29:14.720
And all we want to do is to
tell the system, instead of

00:29:14.720 --> 00:29:17.780
the edit text area, which
is the green box in here,

00:29:17.780 --> 00:29:21.620
use the yellow box.

00:29:21.620 --> 00:29:25.160
And in order to do that, we
have to extend from EditText

00:29:25.160 --> 00:29:26.720
and override three functions.

00:29:26.720 --> 00:29:29.840
I have added the sample code
to the URL given in the slide.

00:29:29.840 --> 00:29:32.630
But I will go through
the functions briefly.

00:29:32.630 --> 00:29:36.260
Get focused rectangle is used
to find the next focusable

00:29:36.260 --> 00:29:40.310
widget, updates a rectangle.

00:29:40.310 --> 00:29:43.280
Get globally visible rectangle
defines the visible array

00:29:43.280 --> 00:29:44.420
of a view.

00:29:44.420 --> 00:29:46.670
And finally, request
rectangle on screen

00:29:46.670 --> 00:29:50.090
is used by EditText to
request from the system

00:29:50.090 --> 00:29:53.330
to make a certain area visible,
in terms of the edit text where

00:29:53.330 --> 00:29:54.230
the cursor is.

00:29:57.480 --> 00:29:59.970
Get focused rectangle
implementation is pretty

00:29:59.970 --> 00:30:02.400
straightforward and simple.

00:30:02.400 --> 00:30:05.310
You let the edit text to
fill in the rectangle,

00:30:05.310 --> 00:30:08.700
and you just update the
bottom of the final rectangle

00:30:08.700 --> 00:30:10.800
to be the parent's button.

00:30:10.800 --> 00:30:14.790
And you do the same thing for
the global visible rectangle.

00:30:14.790 --> 00:30:17.790
Finally, for request
rectangle on screen,

00:30:17.790 --> 00:30:21.630
again we let the edit text
to request its own rectangle,

00:30:21.630 --> 00:30:23.860
and then we request
another rectangle,

00:30:23.860 --> 00:30:26.820
which is at the bottom
of our parent layout.

00:30:26.820 --> 00:30:29.070
The number 10 here is
just a magic number

00:30:29.070 --> 00:30:31.620
to define a rectangle at
the bottom of the parent.

00:30:34.380 --> 00:30:37.110
Going back to the EditText
configuration and how

00:30:37.110 --> 00:30:39.690
it works with keyboard--

00:30:39.690 --> 00:30:42.540
as you all know, when you
set the input type attribute

00:30:42.540 --> 00:30:45.210
to text password, the
characters on the screen

00:30:45.210 --> 00:30:46.990
will be invisible.

00:30:46.990 --> 00:30:48.600
However, this
information is also

00:30:48.600 --> 00:30:53.050
being shared to the keyboard in
order to change its behavior.

00:30:53.050 --> 00:30:58.170
Now, the keyboard itself
is another application

00:30:58.170 --> 00:31:00.390
that can be installed
from Play Store.

00:31:00.390 --> 00:31:03.570
Therefore, they can
define their own behavior

00:31:03.570 --> 00:31:05.580
based on the signals they get.

00:31:05.580 --> 00:31:07.920
Since we cannot rely
on their behavior,

00:31:07.920 --> 00:31:11.580
you still have to validate
the input on our side.

00:31:11.580 --> 00:31:16.410
However, using the correct
input types and IME options

00:31:16.410 --> 00:31:19.920
is important to reduce the
friction for the end user

00:31:19.920 --> 00:31:23.290
as much as possible.

00:31:23.290 --> 00:31:25.860
And when you set the input
type to number password,

00:31:25.860 --> 00:31:27.980
you have a visible
change on the keyboard,

00:31:27.980 --> 00:31:30.266
where they show the number pad.

00:31:34.550 --> 00:31:37.610
If you have a custom
component, let's say,

00:31:37.610 --> 00:31:41.120
and you toggle the
visibility of the password,

00:31:41.120 --> 00:31:44.300
you still want to signal
the keyboard that this

00:31:44.300 --> 00:31:46.610
is a password field,
and they should not

00:31:46.610 --> 00:31:50.120
learn about what the user
types, because you don't want

00:31:50.120 --> 00:31:53.540
the keyboard itself, which
is not under your control,

00:31:53.540 --> 00:31:56.870
to show back the user, here is
your password, I know about it.

00:31:56.870 --> 00:31:58.880
Because it gets a little
creepy for the users.

00:32:03.420 --> 00:32:07.210
And the cases where you don't
want the keyboard to learn

00:32:07.210 --> 00:32:09.460
is not limited to
the password fields.

00:32:09.460 --> 00:32:12.570
Things like an incognito
mode, such as in Chrome,

00:32:12.570 --> 00:32:15.977
or a promo code in
your checkout screen

00:32:15.977 --> 00:32:18.060
are really things that you
don't want the keyboard

00:32:18.060 --> 00:32:19.830
to learn about.

00:32:19.830 --> 00:32:24.330
For those cases, you can add
the no personalized learning

00:32:24.330 --> 00:32:28.320
flag to the IME options.

00:32:28.320 --> 00:32:31.590
One more IME option that
is important in my opinion

00:32:31.590 --> 00:32:34.530
is flag force ASCII.

00:32:34.530 --> 00:32:37.680
A lot of times, we have seen
that developers are expecting

00:32:37.680 --> 00:32:40.770
when they set the password, when
they set the input type to text

00:32:40.770 --> 00:32:42.480
password, they
expect the keyboard

00:32:42.480 --> 00:32:44.250
to show an ASCII keyboard.

00:32:44.250 --> 00:32:47.640
However, text password is
definitely not a strong signal

00:32:47.640 --> 00:32:50.230
for them to switch
to ASCII keyboard.

00:32:50.230 --> 00:32:53.580
So if you have an ASCII-only
field, such as username

00:32:53.580 --> 00:32:56.040
and password, maybe,
you might want

00:32:56.040 --> 00:32:57.975
to add this flag to IME options.

00:33:01.220 --> 00:33:04.400
One last case that can
happen for applications

00:33:04.400 --> 00:33:07.730
is the control over the
application language,

00:33:07.730 --> 00:33:10.400
text field language, and
the keyboard language.

00:33:10.400 --> 00:33:11.870
If you have an
application such as

00:33:11.870 --> 00:33:16.520
a language-learning application
or a translation application,

00:33:16.520 --> 00:33:19.520
there might be a case
where the main language

00:33:19.520 --> 00:33:21.680
of the application is
different than the language

00:33:21.680 --> 00:33:23.900
of the edit text,
which can be different

00:33:23.900 --> 00:33:25.370
than the language
of the keyboard,

00:33:25.370 --> 00:33:29.700
because the user can set
any language that they want.

00:33:29.700 --> 00:33:32.090
If you want to
signal to keyboard

00:33:32.090 --> 00:33:35.570
to use a specific language
and switch to that language,

00:33:35.570 --> 00:33:39.290
you can use set IME hint locales
function on the EditText.

00:33:42.930 --> 00:33:46.920
Since we mentioned that
keyboard behavior depends

00:33:46.920 --> 00:33:48.960
on the keyboard
implementation, and they

00:33:48.960 --> 00:33:51.180
can define their
own behavior, there

00:33:51.180 --> 00:33:52.680
might be times
where you might want

00:33:52.680 --> 00:33:56.520
to learn about which keyboard
is active at any given time.

00:33:56.520 --> 00:33:59.580
You can read the active
keyboard from the settings,

00:33:59.580 --> 00:34:03.750
and this will give you the
class name and the package

00:34:03.750 --> 00:34:04.660
name of the keyboard.

00:34:09.449 --> 00:34:11.780
FLORINA MUNTENESCU: We covered
so many fantastic things

00:34:11.780 --> 00:34:13.350
with text in this talk.

00:34:13.350 --> 00:34:16.159
But let's see what are
some of the key things we

00:34:16.159 --> 00:34:18.110
should remember.

00:34:18.110 --> 00:34:20.480
First, in terms of
performance, keep in mind

00:34:20.480 --> 00:34:23.389
that the hyphenation is
now turned off by default

00:34:23.389 --> 00:34:26.510
in Android Q and AppCompat 1.1.

00:34:26.510 --> 00:34:29.120
So if you need it, enable it.

00:34:29.120 --> 00:34:31.520
And also, you should
use PrecomputedText

00:34:31.520 --> 00:34:34.460
with RecyclerView prefetch.

00:34:34.460 --> 00:34:37.730
For text styling, keep in
mind the precedence order.

00:34:37.730 --> 00:34:39.350
If you're trying
to style something

00:34:39.350 --> 00:34:41.120
and you don't see
the results, it's

00:34:41.120 --> 00:34:42.980
likely been overridden
by something

00:34:42.980 --> 00:34:46.120
with a higher precedence.

00:34:46.120 --> 00:34:48.340
If you need to support
multiple fonts in your app,

00:34:48.340 --> 00:34:51.400
use the custom
fallback builder API.

00:34:51.400 --> 00:34:54.310
To find the font used by
the system, use the font

00:34:54.310 --> 00:34:55.510
matcher API.

00:34:55.510 --> 00:34:57.790
And then, to find all
the installed fonts,

00:34:57.790 --> 00:35:01.000
use the font enumeration API.

00:35:01.000 --> 00:35:03.910
In terms of EditText,
use the theme attributes

00:35:03.910 --> 00:35:08.680
and the Android's edit text
style to style your edit texts.

00:35:08.680 --> 00:35:11.750
Make sure you don't use the
EditText drawables as actions,

00:35:11.750 --> 00:35:17.020
so you can enable extensibility
and maintainability.

00:35:17.020 --> 00:35:20.890
And also, use IME flags
to configure soft keyboard

00:35:20.890 --> 00:35:23.780
for a better user experience.

00:35:23.780 --> 00:35:27.970
So these were some top tips
to make your text terrific.

00:35:27.970 --> 00:35:29.170
Thank you.

00:35:29.170 --> 00:35:32.520
[MUSIC PLAYING]

