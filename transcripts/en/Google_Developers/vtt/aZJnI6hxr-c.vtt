WEBVTT
Kind: captions
Language: en

00:00:01.580 --> 00:00:04.510
BRENDAN KENNY: So
good morning.

00:00:04.510 --> 00:00:05.850
My name is Brendan Kenny.

00:00:05.850 --> 00:00:09.060
I'm an engineer with the Maps
Developer Relations team.

00:00:09.060 --> 00:00:12.570
And I mostly work with
the JavaScript APIs.

00:00:12.570 --> 00:00:14.960
So good old browsers.

00:00:14.960 --> 00:00:18.710
And so, as you can see, I'm here
to tell you a story about

00:00:18.710 --> 00:00:26.940
where maps and browsers and
geospatial data meet and make

00:00:26.940 --> 00:00:29.850
beautiful, beautiful
things for us.

00:00:29.850 --> 00:00:34.680
It says HTML5 up there because
I wanted to be cool, I guess,

00:00:34.680 --> 00:00:36.310
but it's really about
modern browsers.

00:00:36.310 --> 00:00:39.250
What are the new things that
browsers can bring to the

00:00:39.250 --> 00:00:42.550
table and allow us
to do things that

00:00:42.550 --> 00:00:44.730
we couldn't do before.

00:00:44.730 --> 00:00:48.370
So how are you doing there?

00:00:51.380 --> 00:00:54.220
There we go.

00:00:54.220 --> 00:01:01.470
So the kind of catchphrase
of the day for

00:01:01.470 --> 00:01:05.170
visualization is process.

00:01:05.170 --> 00:01:10.730
And the reason why that is, and
a lot of the visualization

00:01:10.730 --> 00:01:13.150
minds out there, the great
visualization minds out there,

00:01:13.150 --> 00:01:16.160
are focusing on process, is that
visualization, it turns

00:01:16.160 --> 00:01:19.760
out, is really difficult
to do well.

00:01:19.760 --> 00:01:22.720
If we wanted to take it easy,
we could get a couple of

00:01:22.720 --> 00:01:26.637
numbers together and pick a nice
font and maybe some clip

00:01:26.637 --> 00:01:28.780
art, and you can have it like
a long vertical thing.

00:01:28.780 --> 00:01:29.340
And it would be an
infographic.

00:01:29.340 --> 00:01:30.820
And you'd get some
hits on Reddit.

00:01:30.820 --> 00:01:33.015
And then a bunch of angry people
would come in and say

00:01:33.015 --> 00:01:34.860
you're bad at statistics.

00:01:34.860 --> 00:01:36.520
So we could do that.

00:01:36.520 --> 00:01:38.680
But if you want to do a
visualization that that's

00:01:38.680 --> 00:01:42.220
actually valuable and actually
gives insight and

00:01:42.220 --> 00:01:44.510
communicates, it takes time.

00:01:44.510 --> 00:01:50.000
And so what this kind of thing
that people have started

00:01:50.000 --> 00:01:51.470
calling this time is process.

00:01:51.470 --> 00:01:59.790
So Ben Fry, who is one of the
co-creators of Processing--

00:01:59.790 --> 00:02:03.640
which is, if you haven't heard
of it it's, a kind of

00:02:03.640 --> 00:02:08.300
computational sketchbook slash
programming environment.

00:02:08.300 --> 00:02:10.800
It's great, I really like the
sketchbook part of that.

00:02:10.800 --> 00:02:13.970
It's meant to kind of just
immediately start getting

00:02:13.970 --> 00:02:16.040
something on the screen
and going so that

00:02:16.040 --> 00:02:17.280
you can start exploring.

00:02:17.280 --> 00:02:22.360
And in his book on data
visualization, he takes the

00:02:22.360 --> 00:02:25.070
stages of process and divides
it into these kind of seven

00:02:25.070 --> 00:02:26.120
categories.

00:02:26.120 --> 00:02:27.870
And the exact categories
aren't that important.

00:02:27.870 --> 00:02:28.880
There's definitely overlap.

00:02:28.880 --> 00:02:32.190
And we could probably each have
our own definitions for

00:02:32.190 --> 00:02:32.780
these words.

00:02:32.780 --> 00:02:36.350
But it's actually a pretty good
way to think about it.

00:02:36.350 --> 00:02:39.110
And what I don't have here, and
he actually has when he

00:02:39.110 --> 00:02:43.110
first introduces this in the
book, is a bunch of arrows

00:02:43.110 --> 00:02:45.170
that point back and forth
and back and forth.

00:02:45.170 --> 00:02:46.060
And it turns out that's
what you have

00:02:46.060 --> 00:02:49.500
to do for this process.

00:02:49.500 --> 00:02:52.880
You don't go through stages
and then get to the end.

00:02:52.880 --> 00:02:55.760
It turns out you get to midway
through and realize you had no

00:02:55.760 --> 00:02:57.350
idea what you were doing, and
have to go back to the

00:02:57.350 --> 00:03:00.820
beginning and take care
of your data.

00:03:00.820 --> 00:03:04.893
So now that I have emphasized
the importance of these, I'm

00:03:04.893 --> 00:03:08.050
going to lump the first three
together so I can dismiss them

00:03:08.050 --> 00:03:09.930
as quickly as possible.

00:03:09.930 --> 00:03:14.890
So these are actually
the hardest steps--

00:03:14.890 --> 00:03:15.960
acquire, parse, and filter.

00:03:15.960 --> 00:03:18.160
So this is really about your
data, your source data.

00:03:18.160 --> 00:03:22.920
And it turns out this is
often definitely the

00:03:22.920 --> 00:03:24.305
longest amount of time.

00:03:24.305 --> 00:03:26.640
It tends to be the most
tedious part of a

00:03:26.640 --> 00:03:31.200
visualization project because
data tends to be so horrible

00:03:31.200 --> 00:03:34.800
in the real world, especially
as you get larger in the

00:03:34.800 --> 00:03:36.370
amount of data.

00:03:36.370 --> 00:03:41.470
I'm going to avoid saying that
phrase about voluminous

00:03:41.470 --> 00:03:44.280
amounts of data.

00:03:44.280 --> 00:03:47.870
But as the amount of data you
have increases, the likelihood

00:03:47.870 --> 00:03:49.700
of error increases.

00:03:49.700 --> 00:03:53.340
And just the raw number of even
somebody entering wrong

00:03:53.340 --> 00:03:57.430
things on a keyboard, or much
more like subtle but

00:03:57.430 --> 00:04:01.160
pernicious things like somebody
took a survey of data

00:04:01.160 --> 00:04:03.670
using 1990s census tracts, and
somebody else took a survey of

00:04:03.670 --> 00:04:05.770
data using 2000 census tracts.

00:04:05.770 --> 00:04:08.010
And then you want to compare
them, but it turns out in your

00:04:08.010 --> 00:04:09.740
area, the census tracts
don't actually align.

00:04:09.740 --> 00:04:12.770
And then you're going to have
make some pretty serious

00:04:12.770 --> 00:04:17.820
assumptions about how things
average over areas that only

00:04:17.820 --> 00:04:22.820
intersect but aren't the same.

00:04:22.820 --> 00:04:26.970
So there's a bunch of tools
out there to help you with

00:04:26.970 --> 00:04:27.410
these steps.

00:04:27.410 --> 00:04:28.280
You import the data.

00:04:28.280 --> 00:04:30.820
You look what's wrong.

00:04:30.820 --> 00:04:33.570
All the way down from just
libraries, a lot of Python

00:04:33.570 --> 00:04:35.000
libraries exist.

00:04:35.000 --> 00:04:36.970
If you are a fan of R,
this is great for it.

00:04:36.970 --> 00:04:40.390
One thing that I'll put a plug
in for is Open Refine, which

00:04:40.390 --> 00:04:42.290
used to be called
Google Refine.

00:04:42.290 --> 00:04:43.940
It's a great program
that you can run.

00:04:43.940 --> 00:04:46.170
And it's specifically for
this type of thing.

00:04:46.170 --> 00:04:51.870
You put in your data, and you
run what are called filters.

00:04:51.870 --> 00:04:54.020
So for this unemployment column,
you say, show me

00:04:54.020 --> 00:04:55.340
everything that's not a
number because this is

00:04:55.340 --> 00:04:56.000
supposed to be a number.

00:04:56.000 --> 00:04:58.380
And it might turn out somebody
entered strings in there for

00:04:58.380 --> 00:04:59.240
some reason.

00:04:59.240 --> 00:05:02.680
And then you can write a really
quick little snippet in

00:05:02.680 --> 00:05:07.100
the little Refine programming
scripting

00:05:07.100 --> 00:05:08.950
language to correct those.

00:05:08.950 --> 00:05:11.580
And it turns out this is kind of
what happens, big or small,

00:05:11.580 --> 00:05:12.090
what you have to do.

00:05:12.090 --> 00:05:15.280
You have to look at your data
and say, what doesn't belong?

00:05:15.280 --> 00:05:19.180
And there's a lot of tricks that
you can do to get there.

00:05:22.620 --> 00:05:23.680
So this is hard.

00:05:23.680 --> 00:05:27.855
And the kind of data that I want
to use, for WebGL stuff,

00:05:27.855 --> 00:05:32.720
which we're going to get to in
just a second, it tends to be

00:05:32.720 --> 00:05:37.355
high in count, and so there
tends to be errors in it.

00:05:37.355 --> 00:05:40.660
And as I said, I'm going to
kind of pass over this now

00:05:40.660 --> 00:05:44.960
because there's an awesome
session just after lunch in

00:05:44.960 --> 00:05:48.316
Room 1, which is somewhere down
the hall, called All the

00:05:48.316 --> 00:05:49.430
Ships in the World.

00:05:49.430 --> 00:05:53.310
And it's about gathering
data from all the

00:05:53.310 --> 00:05:55.030
ships in the world.

00:05:55.030 --> 00:05:56.820
So you can imagine, it's
quite a bit of data.

00:05:56.820 --> 00:05:59.720
And it's a great session,
specifically, about how you

00:05:59.720 --> 00:06:06.470
get kind of nasty, poorly
formatted, sometimes just

00:06:06.470 --> 00:06:09.550
erratic data, clean it up, put
it through a pipeline so that

00:06:09.550 --> 00:06:13.200
you can process that large a
volume of data, and then start

00:06:13.200 --> 00:06:14.890
serving it fast enough that
you can start doing

00:06:14.890 --> 00:06:19.020
interactive queries on it, and
so you can actually take a

00:06:19.020 --> 00:06:22.240
look at things, and a little
graph, and say, oh, that

00:06:22.240 --> 00:06:24.650
little lump in that distribution
does not belong

00:06:24.650 --> 00:06:27.240
there, so let's go figure
out what that is.

00:06:27.240 --> 00:06:29.380
So I definitely recommend it.

00:06:29.380 --> 00:06:31.260
12:45 after lunch.

00:06:31.260 --> 00:06:35.460
So what we're going to do is
treat that course as a little

00:06:35.460 --> 00:06:38.980
awesome black box and
use their data.

00:06:38.980 --> 00:06:43.820
So we're going to take a look at
All the Ships in the World

00:06:43.820 --> 00:06:45.920
and just try our hand at
visualizing it and kind of

00:06:45.920 --> 00:06:46.810
exploring the data.

00:06:46.810 --> 00:06:50.220
So this is about the process of
figuring out what are the

00:06:50.220 --> 00:06:51.390
interesting stories here.

00:06:51.390 --> 00:06:53.940
So the data comes from
SpaceQuest, a company called

00:06:53.940 --> 00:06:55.020
SpaceQuest.

00:06:55.020 --> 00:06:57.830
And it turns out that ships
broadcast a bunch of data

00:06:57.830 --> 00:06:58.460
about themselves.

00:06:58.460 --> 00:07:02.860
They have transmissions that
they sent out periodically

00:07:02.860 --> 00:07:05.590
talking about who they
are, where they are,

00:07:05.590 --> 00:07:06.850
what they're doing.

00:07:06.850 --> 00:07:10.400
And it's primarily for collision
avoidance and in

00:07:10.400 --> 00:07:13.730
harbors and things like that,
for traffic control.

00:07:13.730 --> 00:07:16.620
But all the ships broadcast
it out.

00:07:16.620 --> 00:07:18.730
And so SpaceQuest has a
satellite overhead.

00:07:18.730 --> 00:07:19.590
And they pick it up.

00:07:19.590 --> 00:07:22.490
And they log it.

00:07:22.490 --> 00:07:25.600
And so we've partnered
with them to kind of

00:07:25.600 --> 00:07:27.100
explore what's possible.

00:07:27.100 --> 00:07:29.900
If we were to visualize this
kind of data, what kind of

00:07:29.900 --> 00:07:31.150
things could we do?

00:07:35.950 --> 00:07:38.380
So let's talk about Represent,
representations.

00:07:38.380 --> 00:07:40.080
Finding a representation.

00:07:40.080 --> 00:07:43.520
So this is something that's part
of my personal process,

00:07:43.520 --> 00:07:47.470
finding something on screen as
quickly as possible so that I

00:07:47.470 --> 00:07:52.150
can get a look at the data
and see what's going on.

00:07:52.150 --> 00:07:55.450
So a year ago at I/O, I released
a library called

00:07:55.450 --> 00:07:56.600
CanvasLayer.

00:07:56.600 --> 00:07:59.690
It's in the Google Maps
Utility Library.

00:07:59.690 --> 00:08:02.080
If you just look for
CanvasLayer, one word, it's

00:08:02.080 --> 00:08:04.440
usually in the top hits.

00:08:04.440 --> 00:08:06.600
So it's a Maps API.

00:08:06.600 --> 00:08:09.885
How many people here are
familiar with the Maps API,

00:08:09.885 --> 00:08:11.800
the JavaScript Maps API?

00:08:11.800 --> 00:08:15.770
OK, would you rate yourself as
you have made more than two

00:08:15.770 --> 00:08:19.720
maps that you didn't directly
copy paste from the samples?

00:08:19.720 --> 00:08:20.440
[LAUGHTER]

00:08:20.440 --> 00:08:22.567
BRENDAN KENNY: Yeah, OK, I mean,
no it's totally fine.

00:08:22.567 --> 00:08:24.170
I just am curious about
what level of

00:08:24.170 --> 00:08:27.240
detail I should go into.

00:08:27.240 --> 00:08:31.160
So the Maps API has a concept
called overlays.

00:08:31.160 --> 00:08:34.330
And they're exactly what
they sound like.

00:08:34.330 --> 00:08:39.539
Chrome doesn't like when I go
full screen to other tabs.

00:08:39.539 --> 00:08:42.450
So this is a ground overlay.

00:08:42.450 --> 00:08:46.240
And it's literally an image
put on top of the ground.

00:08:46.240 --> 00:08:49.320
And so the key thing
with overlays--

00:08:49.320 --> 00:08:52.600
the kind of overlays in the Maps
API parlance-- is that

00:08:52.600 --> 00:08:53.650
you take an object.

00:08:53.650 --> 00:08:55.580
And it's associated with
a point in the world.

00:08:55.580 --> 00:08:58.180
And so when you move, and
when you zoom, it

00:08:58.180 --> 00:09:01.620
stays put at that point.

00:09:01.620 --> 00:09:02.200
So that's great.

00:09:02.200 --> 00:09:05.510
And you can do nice things like
overlay historical data

00:09:05.510 --> 00:09:06.650
on top of here.

00:09:06.650 --> 00:09:09.520
So CanvasLayer is a
layer because it

00:09:09.520 --> 00:09:10.500
doesn't quite do that.

00:09:10.500 --> 00:09:13.280
But it tries to emulate that.

00:09:13.280 --> 00:09:14.340
Did that actually work?

00:09:14.340 --> 00:09:15.368
Oh, cool.

00:09:15.368 --> 00:09:18.240
There we go.

00:09:18.240 --> 00:09:23.060
So CanvasLayer takes an HTML5
canvas and puts it right on

00:09:23.060 --> 00:09:26.900
top of a map and let's you draw

00:09:26.900 --> 00:09:28.480
anything you want to canvas.

00:09:28.480 --> 00:09:31.250
And if you're not familiar,
canvas is supposed to be a

00:09:31.250 --> 00:09:32.990
dynamic image element.

00:09:32.990 --> 00:09:36.710
And so it originally had a 2D
API that's based off drawing

00:09:36.710 --> 00:09:38.320
APIs of old.

00:09:38.320 --> 00:09:44.730
But then more recently, a 3D API
was added, WebGL, which is

00:09:44.730 --> 00:09:48.550
based on OpenGL, yes, 2, but
it's basically OpenGL

00:09:48.550 --> 00:09:51.550
bindings, emulated or not,
through the browser.

00:09:51.550 --> 00:09:55.680
So you can use the canvas
as your place to draw.

00:09:55.680 --> 00:09:57.720
I'm sure most people have seen
a WebGL thing by now.

00:09:57.720 --> 00:10:01.300
I guess we saw a bunch
yesterday.

00:10:01.300 --> 00:10:02.200
So here's our canvas.

00:10:02.200 --> 00:10:04.230
And the main thing is--

00:10:04.230 --> 00:10:06.210
ooh, that's no good.

00:10:06.210 --> 00:10:09.140
The main thing to see
here, though, is--

00:10:09.140 --> 00:10:11.760
it's a little hard
to understand--

00:10:11.760 --> 00:10:13.670
is that the canvas actually
stays still.

00:10:13.670 --> 00:10:15.330
So the canvas covers the whole
map, and it doesn't

00:10:15.330 --> 00:10:16.370
move with the map.

00:10:16.370 --> 00:10:18.440
And the difference is, what
you're doing is instead

00:10:18.440 --> 00:10:20.000
logically moving the content.

00:10:20.000 --> 00:10:22.960
And so there's a callback
every frame, so on a

00:10:22.960 --> 00:10:25.840
RequestAnimationFrame, to
redraw the content.

00:10:25.840 --> 00:10:28.800
And for 2D canvas, it's
not that important.

00:10:28.800 --> 00:10:30.530
You could kind of
do some tricks.

00:10:30.530 --> 00:10:32.370
But for WebGL, it turns out it's
really important because

00:10:32.370 --> 00:10:40.150
every wasted pixel in WebGL is
possibly a significant cost

00:10:40.150 --> 00:10:40.960
with wasted pixels.

00:10:40.960 --> 00:10:42.325
So you don't want anything
sliding offscreen

00:10:42.325 --> 00:10:43.690
that you can't see.

00:10:43.690 --> 00:10:47.460
And you don't want to allocate a
bigger canvas than you need.

00:10:47.460 --> 00:10:48.020
So that's what we do.

00:10:48.020 --> 00:10:51.240
And so it's just something,
too, that you have to deal

00:10:51.240 --> 00:10:53.730
with when you're dealing
with CanvasLayer.

00:10:53.730 --> 00:10:57.590
But it's not terribly difficult
to understand.

00:11:06.380 --> 00:11:10.840
So CanvasLayer is created like
a lot of Maps API objects.

00:11:10.840 --> 00:11:13.550
You create a canvas layer
with a constructor.

00:11:13.550 --> 00:11:15.350
You pass it a configuration
object.

00:11:15.350 --> 00:11:17.440
The most important things are
the map that you want to

00:11:17.440 --> 00:11:19.270
actually put it on and the
update function, so that

00:11:19.270 --> 00:11:21.500
function that's called
back every frame.

00:11:21.500 --> 00:11:22.240
There's other options.

00:11:22.240 --> 00:11:24.340
It's all in the docs if you
want to take a look.

00:11:24.340 --> 00:11:28.190
And so here's an example of
the 2D transformation that

00:11:28.190 --> 00:11:28.800
we're doing.

00:11:28.800 --> 00:11:31.910
And there's a direct analog
to it in WebGL.

00:11:31.910 --> 00:11:33.320
So we're calculating a scale.

00:11:33.320 --> 00:11:35.560
So as you zoom in, you can think
of the world as scaling

00:11:35.560 --> 00:11:36.720
rather than zooming.

00:11:36.720 --> 00:11:38.980
And it's to the power
of the zoom.

00:11:38.980 --> 00:11:41.170
And then you have an offset,
which is just the translation

00:11:41.170 --> 00:11:42.360
as you pan around.

00:11:42.360 --> 00:11:45.340
And then the context.scale and
context.translate are part of

00:11:45.340 --> 00:11:48.160
the 2D drawing API that
actually let you

00:11:48.160 --> 00:11:49.430
transform the canvas.

00:11:49.430 --> 00:11:53.310
So then I can just say draw
a square, and it will

00:11:53.310 --> 00:11:55.130
correctly place it.

00:11:55.130 --> 00:11:56.930
So that's the 2D canvas.

00:11:56.930 --> 00:11:58.510
And we don't care about
it anymore.

00:11:58.510 --> 00:12:03.160
So we have a canvas that
we can draw to.

00:12:03.160 --> 00:12:06.060
We have data from an awesome
black box that's covered

00:12:06.060 --> 00:12:08.870
really well at 12:45, All
the Ships in the World.

00:12:08.870 --> 00:12:10.440
You should go.

00:12:10.440 --> 00:12:14.520
And we need to get the data from
there into the canvas.

00:12:14.520 --> 00:12:16.040
So there's a couple
of different ways.

00:12:16.040 --> 00:12:19.150
Oh, that's exciting.

00:12:19.150 --> 00:12:21.900
OK, whatever.

00:12:21.900 --> 00:12:26.420
So we have CSV, which ends up
poorly wrapping, often.

00:12:26.420 --> 00:12:29.470
And that's the tried
and trusted way.

00:12:29.470 --> 00:12:32.100
Whatever, if you really like
spreadsheets, if you know

00:12:32.100 --> 00:12:34.225
people that really like
spreadsheets, you probably

00:12:34.225 --> 00:12:37.060
could get CSV pretty quickly.

00:12:37.060 --> 00:12:41.320
A million libraries can import
it and parse it for you.

00:12:41.320 --> 00:12:45.460
If you go talk to the
Perfmatters guys upstairs in

00:12:45.460 --> 00:12:49.070
the Chrome booth area, they'll
tell you not to mess

00:12:49.070 --> 00:12:49.790
with this too much.

00:12:49.790 --> 00:12:52.510
As it gets bigger, you start
generating a lot of strings.

00:12:52.510 --> 00:12:56.175
And modern JavaScript engines
are really good at doing

00:12:56.175 --> 00:13:00.140
offsets into strings because
strings are read only.

00:13:00.140 --> 00:13:03.170
But you can quite easily
generate a ton of garbage.

00:13:03.170 --> 00:13:04.670
And then everything
slows down.

00:13:04.670 --> 00:13:05.360
So that's no good.

00:13:05.360 --> 00:13:07.690
So we'll look for something
better.

00:13:07.690 --> 00:13:11.110
JSON is the classic thing.

00:13:11.110 --> 00:13:13.710
Hopefully, everybody is
familiar with JSON.

00:13:13.710 --> 00:13:16.050
It has a nice direct translation
to the object

00:13:16.050 --> 00:13:19.740
literal from JavaScript, which
is what JSONP is based on.

00:13:19.740 --> 00:13:22.790
And all the browsers, for years
now, have had support

00:13:22.790 --> 00:13:27.750
for json.parse, which is a
native method to safely parse

00:13:27.750 --> 00:13:29.680
Jason into JavaScript objects.

00:13:29.680 --> 00:13:30.980
It's really fast.

00:13:30.980 --> 00:13:32.210
There's a couple of downsides.

00:13:32.210 --> 00:13:35.050
People tend to make deep
objects with JSON, even

00:13:35.050 --> 00:13:35.750
without meaning to.

00:13:35.750 --> 00:13:39.730
GeoJSON is a really beautifully
simple format, and

00:13:39.730 --> 00:13:42.640
yet people still end up taking
features and putting them in

00:13:42.640 --> 00:13:44.620
feature sets, and then they have
geometries, but they're

00:13:44.620 --> 00:13:47.050
also siblings to other
features which

00:13:47.050 --> 00:13:47.710
have feature sets.

00:13:47.710 --> 00:13:52.010
And you end up having to write
general tree callers just to

00:13:52.010 --> 00:13:53.430
find all the things.

00:13:53.430 --> 00:13:55.770
The other thing is just size.

00:13:55.770 --> 00:13:58.930
So the numeric type in
JavaScript is a 64-bit float.

00:13:58.930 --> 00:14:00.790
And that's eight bytes
on the wire.

00:14:00.790 --> 00:14:03.530
And you can see that right
here we have some

00:14:03.530 --> 00:14:06.960
lat longs or something.

00:14:06.960 --> 00:14:12.240
And every character over eight
characters is an extra byte.

00:14:12.240 --> 00:14:14.290
And you actually want
that because

00:14:14.290 --> 00:14:15.380
you want the precision.

00:14:15.380 --> 00:14:20.850
A 64-bit floating point has 14
decimal places of precision.

00:14:20.850 --> 00:14:25.780
And so you want that, but
you start wasting space.

00:14:25.780 --> 00:14:27.120
Gzip does help.

00:14:27.120 --> 00:14:30.180
Don't let me make it
sound too bad.

00:14:30.180 --> 00:14:32.350
But you do end up paying
the price.

00:14:32.350 --> 00:14:36.300
So all of which is to say, the
most beautiful thing, the most

00:14:36.300 --> 00:14:39.730
wonderful thing, is
typed arrays.

00:14:39.730 --> 00:14:43.370
So typed arrays came
along with WebGL.

00:14:43.370 --> 00:14:45.730
Is everybody familiar
with typed arrays?

00:14:45.730 --> 00:14:47.698
Yes?

00:14:47.698 --> 00:14:49.180
No?

00:14:49.180 --> 00:14:49.970
OK.

00:14:49.970 --> 00:14:52.440
So typed arrays are kind
of what you would

00:14:52.440 --> 00:14:54.443
think in C as an array.

00:14:54.443 --> 00:14:56.350
It's a contiguous
block of bytes.

00:14:56.350 --> 00:14:59.280
And you say to the browser, give
me these number of bytes.

00:14:59.280 --> 00:15:02.640
And then you can just fill it
in with whatever you want.

00:15:02.640 --> 00:15:06.220
And so what's great about that
is, when you get a message

00:15:06.220 --> 00:15:10.040
from a server with XHR2, which
has been around for a little

00:15:10.040 --> 00:15:12.500
while now, you can actually
set the response

00:15:12.500 --> 00:15:15.460
type on your XHR.

00:15:15.460 --> 00:15:17.950
And so that basically tells the
browser, don't mess with

00:15:17.950 --> 00:15:18.410
anything here.

00:15:18.410 --> 00:15:19.040
Don't parse.

00:15:19.040 --> 00:15:21.190
Don't send it through some
string engine, and back to

00:15:21.190 --> 00:15:22.890
binary, or something awful.

00:15:22.890 --> 00:15:25.110
Just give me the
bytes directly.

00:15:25.110 --> 00:15:28.340
And so you can see here that,
what I'm doing is, I take this

00:15:28.340 --> 00:15:30.900
response, which is the array
buffer, and then I'm putting

00:15:30.900 --> 00:15:33.480
it in a float 32 array.

00:15:33.480 --> 00:15:36.240
And so I think a lot of people,
when they encounter

00:15:36.240 --> 00:15:39.540
typed arrays, they think of
float 32 array, and int 32

00:15:39.540 --> 00:15:43.540
array, and float 64 array
because you think of it, it's

00:15:43.540 --> 00:15:44.250
a typed array.

00:15:44.250 --> 00:15:47.070
You have a data type throughout
an array.

00:15:47.070 --> 00:15:50.110
But actually, those are what are
called type array views.

00:15:50.110 --> 00:15:53.180
And it's great because you can
actually have multiple views

00:15:53.180 --> 00:15:54.300
on the same buffer.

00:15:54.300 --> 00:15:58.890
So say you had, for instance,
alternating float and ints.

00:15:58.890 --> 00:16:02.780
So in the data that we're about
to see, our time stamps

00:16:02.780 --> 00:16:05.810
couldn't fit in a float 32
without losing precision.

00:16:05.810 --> 00:16:07.780
And so we can fit them
in an int 32.

00:16:07.780 --> 00:16:09.570
And so I can actually
get two views.

00:16:09.570 --> 00:16:13.100
I could do a new int 32 array
on this.response, and just

00:16:13.100 --> 00:16:16.640
alternate as I iterate through
the array, and take a look at

00:16:16.640 --> 00:16:19.350
them because they just interpret
the underlying bytes

00:16:19.350 --> 00:16:20.810
the way that you tell them to.

00:16:20.810 --> 00:16:22.220
So they're my favorite thing.

00:16:22.220 --> 00:16:27.075
They let us have JavaScript
the way that we want it.

00:16:27.075 --> 00:16:31.430
There's the loose, scripty, just
throw it out on the page

00:16:31.430 --> 00:16:32.190
that everybody does.

00:16:32.190 --> 00:16:35.820
And there's the snooty, I do
everything with promises and

00:16:35.820 --> 00:16:36.820
wrapped up callbacks.

00:16:36.820 --> 00:16:40.050
And if it's not a monad, then I
don't want to hear about it.

00:16:40.050 --> 00:16:44.930
And then there's the asm.js
hacker types that just want to

00:16:44.930 --> 00:16:46.420
do some bit twiddling
sometimes.

00:16:46.420 --> 00:16:47.435
And we can merge all of them.

00:16:47.435 --> 00:16:49.550
And it's beautiful.

00:16:49.550 --> 00:16:53.350
So I apologize for this long
to actually draw something.

00:16:53.350 --> 00:16:55.560
So let's take a look at some
really simple points.

00:16:55.560 --> 00:16:58.750
So this is taking data from all
the ships in the world.

00:16:58.750 --> 00:17:01.610
And actually, the query is,
what are all the latest

00:17:01.610 --> 00:17:04.300
positions of ships
that you've seen.

00:17:04.300 --> 00:17:07.270
So the satellite, actually,
is in a polar orbit.

00:17:07.270 --> 00:17:09.640
And so it only sees ships
every once in a while,

00:17:09.640 --> 00:17:10.930
whenever they're underneath.

00:17:10.930 --> 00:17:14.390
And so, typically, I don't
remember my orbital mechanics

00:17:14.390 --> 00:17:16.950
exactly, but it depends on the
Earth turning, actually,

00:17:16.950 --> 00:17:19.839
underneath the polar orbit
to see everything.

00:17:19.839 --> 00:17:25.420
And so it only sees what's in
its line of sight, and so

00:17:25.420 --> 00:17:26.460
there's a certain amount
of time since

00:17:26.460 --> 00:17:27.470
you've last seen a ship.

00:17:27.470 --> 00:17:30.490
And if ships turn off their
receivers, we might not see

00:17:30.490 --> 00:17:32.350
them for months.

00:17:32.350 --> 00:17:37.920
So here's an image
of all of them.

00:17:37.920 --> 00:17:39.340
And as of this morning,
I think it was

00:17:39.340 --> 00:17:43.600
about 79,000 points.

00:17:43.600 --> 00:17:47.270
So if you are familiar with web
mapping, this is actually

00:17:47.270 --> 00:17:50.590
a huge amount of points.

00:17:50.590 --> 00:17:51.590
It's not unheard of.

00:17:51.590 --> 00:17:55.680
It's not it's not completely
out of a normal range.

00:17:55.680 --> 00:17:57.270
But typically, with regular
markers, you

00:17:57.270 --> 00:17:58.235
might have a few hundred.

00:17:58.235 --> 00:18:01.130
You can use optimized markers or
some kind of canvas tricks

00:18:01.130 --> 00:18:02.300
for more than that.

00:18:02.300 --> 00:18:05.990
But what we have here is very
quickly interactive.

00:18:05.990 --> 00:18:13.620
And remember that this is
actually redrawing every frame

00:18:13.620 --> 00:18:14.960
that that's actually
being done.

00:18:14.960 --> 00:18:17.310
And so it's actually quite
nice and fast.

00:18:17.310 --> 00:18:19.540
So this is just a very
simple drawing.

00:18:19.540 --> 00:18:21.700
I'm just taking the lat
long And I'm filling

00:18:21.700 --> 00:18:24.570
a box around it.

00:18:24.570 --> 00:18:25.480
So that's great.

00:18:25.480 --> 00:18:27.820
And we can see, already, that we
have plenty of performance

00:18:27.820 --> 00:18:31.772
room that we can start kind
of abusing our GPU.

00:18:31.772 --> 00:18:36.110
Because what are those fans for
but running at full speed?

00:18:36.110 --> 00:18:37.610
Makes sense to me.

00:18:37.610 --> 00:18:48.360
So just to give you a look at
what we're doing to get those

00:18:48.360 --> 00:18:54.610
blocks on screen, if you've
never seen WebGL code before,

00:18:54.610 --> 00:18:55.700
this might be a little
shocking.

00:18:55.700 --> 00:18:58.730
It's a very C-like API, on
purpose, to make it very easy

00:18:58.730 --> 00:19:00.870
to port old OpenGL code.

00:19:00.870 --> 00:19:03.040
It's really not that bad, and
there's a ton of libraries out

00:19:03.040 --> 00:19:05.710
there to wrap it.

00:19:05.710 --> 00:19:07.710
I personally would
suggest three.js.

00:19:07.710 --> 00:19:12.340
I don't use it that much, but
there's a huge community to

00:19:12.340 --> 00:19:13.670
support that.

00:19:13.670 --> 00:19:16.260
And the three.js people are so
fast in Stack Overflow, I

00:19:16.260 --> 00:19:17.880
never get to answer anything.

00:19:17.880 --> 00:19:20.120
So they're ready to help you.

00:19:20.120 --> 00:19:22.200
And it wraps it in a bunch
of kind of very familiar

00:19:22.200 --> 00:19:26.600
JavaScript objects and
helper classes.

00:19:26.600 --> 00:19:28.330
So it can help you out.

00:19:28.330 --> 00:19:30.960
But here's just looking
at raw WebGL.

00:19:30.960 --> 00:19:33.950
So we get a WebGL context by
asking-- so CanvasLayer has a

00:19:33.950 --> 00:19:34.630
canvas on it.

00:19:34.630 --> 00:19:37.110
And we ask for the
WebGL context.

00:19:37.110 --> 00:19:39.740
I put this in specifically on
its own slide because I'm

00:19:39.740 --> 00:19:40.330
really excited.

00:19:40.330 --> 00:19:44.420
It used to be experimental WebGL
until a few months ago.

00:19:44.420 --> 00:19:45.680
WebGL was finally ratified.

00:19:45.680 --> 00:19:47.280
And it's now no longer
experimental.

00:19:47.280 --> 00:19:50.560
We have enough conforming
browsers to do it.

00:19:50.560 --> 00:19:54.790
So that's Firefox, and we have
Chrome, and Opera on Windows,

00:19:54.790 --> 00:19:59.870
I think, and then Firefox on
mobile, Chrome on mobile, if

00:19:59.870 --> 00:20:03.430
you go to about flags and turn
it, on and then Safari as well

00:20:03.430 --> 00:20:06.030
if you go to the developer
menu and turn on WebGL.

00:20:06.030 --> 00:20:08.690
So we have a lot of platforms
available.

00:20:08.690 --> 00:20:10.565
That's a huge amount of market
share, depending on

00:20:10.565 --> 00:20:11.790
how you count it.

00:20:11.790 --> 00:20:15.470
And then I'll let you search on
the web for, I don't know,

00:20:15.470 --> 00:20:16.440
IE11 and WebGL.

00:20:16.440 --> 00:20:19.196
And you might find some
interesting rumors.

00:20:19.196 --> 00:20:20.446
But I won't comment.

00:20:23.130 --> 00:20:25.440
I am encouraged, though.

00:20:25.440 --> 00:20:29.540
So this is kind of pretty
typical WebGL code.

00:20:29.540 --> 00:20:32.070
Again, don't worry too much
about the specifics.

00:20:32.070 --> 00:20:34.580
But what this is doing here is,
we're creating a buffer.

00:20:34.580 --> 00:20:37.020
WebGL is very state based.

00:20:37.020 --> 00:20:40.000
And so you create buffers, and
then you say, WebGL, here's my

00:20:40.000 --> 00:20:41.700
current buffer, like
bind this.

00:20:41.700 --> 00:20:44.030
And now I want to give this data
to the current buffer,

00:20:44.030 --> 00:20:46.410
rather than saying, current
buffer, here's some data.

00:20:46.410 --> 00:20:48.200
It's feels a little bit--

00:20:48.200 --> 00:20:51.670
I don't know.

00:20:51.670 --> 00:20:52.740
So that's what we're
doing here.

00:20:52.740 --> 00:20:55.580
We're binding a buffer, and
we're passing raw data here.

00:20:55.580 --> 00:20:58.690
And if you remember, raw data
was that array buffer that we

00:20:58.690 --> 00:21:01.580
got off the wire from our XHR.

00:21:01.580 --> 00:21:03.690
And now we can just pass
it directly into WebGL.

00:21:03.690 --> 00:21:04.900
It's a beautiful thing.

00:21:04.900 --> 00:21:06.440
If you don't have to do any
processing, if you've already

00:21:06.440 --> 00:21:09.440
processed on the server, you can
just pass it on in and no

00:21:09.440 --> 00:21:10.200
work needs to be done.

00:21:10.200 --> 00:21:16.400
So that's the fastest thing to
compute is no computation.

00:21:16.400 --> 00:21:19.110
And then you do this thing
where you bind it to a

00:21:19.110 --> 00:21:21.400
variable to these shaders that
I'm about to show you.

00:21:21.400 --> 00:21:25.190
And you tell it these kind of
esoteric long string of

00:21:25.190 --> 00:21:26.330
parameters here.

00:21:26.330 --> 00:21:30.140
But I'm telling it it's a vector
of two components.

00:21:30.140 --> 00:21:31.920
So its a latitude
and longitude.

00:21:31.920 --> 00:21:34.670
And the type is float.

00:21:34.670 --> 00:21:36.685
And I tell it where to
find it in the array.

00:21:36.685 --> 00:21:40.380
And it's just lat long, lat
long, lat long, right in one

00:21:40.380 --> 00:21:42.520
long array.

00:21:42.520 --> 00:21:45.080
So then we create what
are called shaders.

00:21:45.080 --> 00:21:47.730
And they are kind
of a misnomer.

00:21:47.730 --> 00:21:49.870
They used to be just for
shading, but now we can pretty

00:21:49.870 --> 00:21:51.660
much use them for whatever
we want.

00:21:51.660 --> 00:21:54.960
There's a great blog series
by Gregg Tavares, who's an

00:21:54.960 --> 00:21:56.210
engineer on Chrome.

00:21:56.210 --> 00:21:58.740
And it's called WebGL
as a 2D API.

00:21:58.740 --> 00:22:03.560
And it's a really great look at
how, with the way that GPUs

00:22:03.560 --> 00:22:09.710
have kind of generalized, that
the 3D is kind of incidental.

00:22:09.710 --> 00:22:15.000
It's very optimized for 3D, but
we think of these 3D APIs

00:22:15.000 --> 00:22:17.520
as a means to games and
things like that.

00:22:17.520 --> 00:22:18.320
But there's no reason
for that.

00:22:18.320 --> 00:22:21.690
We can draw fancy 2D things,
for instance.

00:22:21.690 --> 00:22:23.190
So we create these shaders.

00:22:23.190 --> 00:22:25.810
And they're special programs
in a special scripting

00:22:25.810 --> 00:22:30.700
language that is a different
language than JavaScript, but

00:22:30.700 --> 00:22:32.030
it is very C-like.

00:22:32.030 --> 00:22:33.500
And its very small.

00:22:33.500 --> 00:22:34.810
So there's not much to learn.

00:22:34.810 --> 00:22:35.780
And it's highly typed.

00:22:35.780 --> 00:22:38.050
So it's easy to make a mistake,
but you know pretty

00:22:38.050 --> 00:22:39.920
much instantly because
the compiler

00:22:39.920 --> 00:22:44.420
complains quite quickly.

00:22:44.420 --> 00:22:46.050
So you create your shaders.

00:22:46.050 --> 00:22:48.040
And you bind them.

00:22:48.040 --> 00:22:50.550
And so what happens on the
inside is, you've told it that

00:22:50.550 --> 00:22:54.420
your array is broken up into
x, y, x, y, x, y, x, y.

00:22:54.420 --> 00:22:58.770
And so the GPU actually has a
ton of, essentially, parallel

00:22:58.770 --> 00:23:00.620
processors all on its chip.

00:23:00.620 --> 00:23:03.090
And it can run these extremely
quickly and a

00:23:03.090 --> 00:23:04.210
lot of them at once.

00:23:04.210 --> 00:23:06.450
This machine, for instance, is
just a laptop, and it has a

00:23:06.450 --> 00:23:08.960
few hundred that it
can run these

00:23:08.960 --> 00:23:11.450
calculations at the same time.

00:23:11.450 --> 00:23:14.620
So it runs a bunch of
things through.

00:23:14.620 --> 00:23:16.330
And so you run it through
this vertex shader.

00:23:16.330 --> 00:23:18.300
And here's a very simple
vertex shader.

00:23:18.300 --> 00:23:21.430
I'm taking that world
coordinate, that lat long.

00:23:21.430 --> 00:23:23.400
I'm taking a matrix
that encodes

00:23:23.400 --> 00:23:25.210
that scale and translate.

00:23:25.210 --> 00:23:26.560
And then I'm just
multiplying it.

00:23:26.560 --> 00:23:33.710
And GLSL, the language, has a
bunch of handy things like 4

00:23:33.710 --> 00:23:36.960
vectors, and 4 by 4 matrices,
and things like that.

00:23:36.960 --> 00:23:41.980
So don't worry too much if
you're not big on this.

00:23:41.980 --> 00:23:44.155
Like I said, there's lots of
libraries to help you out.

00:23:44.155 --> 00:23:47.120
But the point is, the vertex
shader, the output here in

00:23:47.120 --> 00:23:48.880
this vertex shader is
gl_position, a global

00:23:48.880 --> 00:23:50.040
that you write to.

00:23:50.040 --> 00:23:53.500
And all you have to do is write
somewhere on the screen,

00:23:53.500 --> 00:23:57.255
between negative 1 and 1 and x,
and negative 1 and 1 and y,

00:23:57.255 --> 00:23:59.210
and as long as you do that, it's
going to be on screen.

00:23:59.210 --> 00:24:02.160
If it's offscreen, then it's
going to get clipped somehow.

00:24:02.160 --> 00:24:05.930
And so that's all the vertex
shader is responsible for is

00:24:05.930 --> 00:24:07.750
outputting an x, y coordinate.

00:24:07.750 --> 00:24:10.310
And then you can include extra
coordinates if you're going to

00:24:10.310 --> 00:24:14.230
be in 3D and can absorb it later
on down the pipeline.

00:24:14.230 --> 00:24:18.170
So depending on what you told
WebGL you're drawing, in this

00:24:18.170 --> 00:24:20.900
case, we might have said, I'm
drawing triangles, and so

00:24:20.900 --> 00:24:26.930
it'll actually take the three
x, y pairs in a row and bind

00:24:26.930 --> 00:24:28.160
them together in a triangle.

00:24:28.160 --> 00:24:30.800
And so then it says, OK, these
three are in a triangle.

00:24:30.800 --> 00:24:32.460
You told me three positions
on the screen.

00:24:32.460 --> 00:24:36.170
So every pixel inside that
logical triangle I'm

00:24:36.170 --> 00:24:36.870
going to fill in.

00:24:36.870 --> 00:24:40.760
And there's rules for those
partial pixels, which ones are

00:24:40.760 --> 00:24:42.300
filled and which ones aren't.

00:24:42.300 --> 00:24:44.380
And then, finally, the last part
of the pipeline is, for

00:24:44.380 --> 00:24:47.310
each of those pixels, you get
to run another program.

00:24:47.310 --> 00:24:50.270
So you can run even more
computations per pixel, which

00:24:50.270 --> 00:24:50.910
gets kind of crazy.

00:24:50.910 --> 00:24:54.030
And that's what kind of
separates this from canvas 2D,

00:24:54.030 --> 00:24:54.520
especially.

00:24:54.520 --> 00:24:58.680
Even as a canvas speeds up,
and even as SVG speeds up,

00:24:58.680 --> 00:25:01.730
there's really nothing that
can compare to running a

00:25:01.730 --> 00:25:04.990
rather complex program
per pixel.

00:25:04.990 --> 00:25:08.110
And again, the fragment shader
only has one job,

00:25:08.110 --> 00:25:10.570
is to output a color.

00:25:10.570 --> 00:25:19.580
So I created a little thing that
lets you edit shaders.

00:25:19.580 --> 00:25:21.640
And so this is the shader that's
actually running on

00:25:21.640 --> 00:25:24.250
that map that we just saw,
just to remind you.

00:25:24.250 --> 00:25:24.990
Here it is.

00:25:24.990 --> 00:25:31.980
So we're drawing squares,
black squares.

00:25:31.980 --> 00:25:34.420
So in this case, we
have one point.

00:25:34.420 --> 00:25:37.000
And so in my vertex shader, I'm
just directly outputting

00:25:37.000 --> 00:25:38.500
the x, y, which is 0, 0.

00:25:38.500 --> 00:25:41.170
And I'm using points this
time, which come

00:25:41.170 --> 00:25:42.500
out as little sprites.

00:25:42.500 --> 00:25:44.790
And I'm saying that the point
size, which is the other

00:25:44.790 --> 00:25:48.590
variable you can output for
points, it's 256 pixels across

00:25:48.590 --> 00:25:51.810
and 256 pixels downwards.

00:25:51.810 --> 00:25:53.170
And then, finally, the
fragment shader,

00:25:53.170 --> 00:25:54.000
I'm not doing anything.

00:25:54.000 --> 00:25:57.510
I'm saying for every pixel
that's in this point, I'm

00:25:57.510 --> 00:26:01.810
outputting an RGBA of
black, so 0001.

00:26:01.810 --> 00:26:05.410
And so, finally, when I run
that, I have my black pixel.

00:26:08.540 --> 00:26:13.300
So that's very exciting, but
we can do better than that.

00:26:13.300 --> 00:26:17.070
So it turns out, as I said, you
can run whole programs in

00:26:17.070 --> 00:26:17.450
these things.

00:26:17.450 --> 00:26:20.150
And people actually run
incredibly complex programs.

00:26:20.150 --> 00:26:22.940
If you've ever looked at Shader
Toy, it's actually

00:26:22.940 --> 00:26:28.500
designed specifically just to
draw two triangles to fill up

00:26:28.500 --> 00:26:29.010
the whole screen.

00:26:29.010 --> 00:26:31.570
And then everything else
is run per pixel.

00:26:31.570 --> 00:26:33.580
And you can run very elaborate,
even ray tracing,

00:26:33.580 --> 00:26:35.290
just through that one pixel.

00:26:35.290 --> 00:26:37.430
So we can be simpler
than that.

00:26:37.430 --> 00:26:41.050
But we can use this built in
variable called gl Point

00:26:41.050 --> 00:26:43.480
Coordinate, which is
within this square.

00:26:43.480 --> 00:26:46.000
And the point coordinates of the
square has yet a different

00:26:46.000 --> 00:26:47.280
coordinate system,
which is great.

00:26:47.280 --> 00:26:51.550
But it basically runs from
0, 0 to 1, 1 like that.

00:26:51.550 --> 00:26:54.700
And so the center of
it is 0.5, 0.5.

00:26:54.700 --> 00:27:02.450
So I can say that the distance
for a particular pixel-- so

00:27:02.450 --> 00:27:04.920
remember, this is running
per pixel--

00:27:04.920 --> 00:27:10.970
is equal to the length of gl
Point Coordinate, the x, y

00:27:10.970 --> 00:27:14.640
components of that, and then
subtracted from a vector of

00:27:14.640 --> 00:27:18.370
0.5, 0.5, which is the center.

00:27:18.370 --> 00:27:21.940
And so that's my distance from
the center of that circle.

00:27:21.940 --> 00:27:23.610
And so I just want to test it.

00:27:27.410 --> 00:27:27.680
Let's see.

00:27:27.680 --> 00:27:29.490
Alpha is equal to--

00:27:29.490 --> 00:27:36.870
if distance is greater than 0.5
away, so past that circle,

00:27:36.870 --> 00:27:41.500
then let's make that
an alpha of 0.

00:27:41.500 --> 00:27:43.165
Otherwise, let's
make it opaque.

00:27:43.165 --> 00:27:46.236
And now we can just multiply
our color by alpha.

00:27:46.236 --> 00:27:50.310
And that's not right.

00:27:50.310 --> 00:27:51.560
Luckily, we have a debugger.

00:27:54.710 --> 00:27:58.160
No matching overhead found.

00:27:58.160 --> 00:27:59.410
Which line?

00:28:01.770 --> 00:28:02.300
Vec2.

00:28:02.300 --> 00:28:03.870
There we go.

00:28:03.870 --> 00:28:08.120
So now I've clipped everything
past 0.5 distance away from

00:28:08.120 --> 00:28:12.050
the center, and I've made
it transparent.

00:28:12.050 --> 00:28:14.775
And so now, if we look over
in our points, we

00:28:14.775 --> 00:28:16.650
can do the same thing.

00:28:16.650 --> 00:28:19.820
And we can make nice
blue circles.

00:28:19.820 --> 00:28:24.020
So Already we have a slightly
better looking map.

00:28:24.020 --> 00:28:25.880
And that's just the start.

00:28:30.090 --> 00:28:34.120
So the next thing we might want
to do is, so now have a

00:28:34.120 --> 00:28:35.260
representation.

00:28:35.260 --> 00:28:36.740
We have our other points
on the map.

00:28:36.740 --> 00:28:37.980
And actually, we should
take a look at this.

00:28:37.980 --> 00:28:39.700
I've looked at this too much,
and so I get jaded.

00:28:39.700 --> 00:28:46.800
So this is about 79,000 ships
over the last month or two.

00:28:46.800 --> 00:28:51.640
And they're older than last week
if they've docked, and

00:28:51.640 --> 00:28:53.640
they stopped there, and actually
turned off their

00:28:53.640 --> 00:28:58.190
transceiver, or something's
messed up, or sometimes ships

00:28:58.190 --> 00:29:00.460
even change call
signs and IDs.

00:29:00.460 --> 00:29:02.630
And so you think the
ship is gone, but

00:29:02.630 --> 00:29:03.770
really it's a new ship.

00:29:03.770 --> 00:29:05.400
But you can see lots of
interesting things.

00:29:05.400 --> 00:29:08.880
So already, we can tell where
the major shipping lanes are,

00:29:08.880 --> 00:29:11.920
where a lot of ships are.

00:29:11.920 --> 00:29:14.310
These are actually, they have
a slight alpha on them.

00:29:14.310 --> 00:29:20.310
And so you can see, when they
really bunch up here, that

00:29:20.310 --> 00:29:21.800
there are quite a few.

00:29:21.800 --> 00:29:24.260
And then there's amusing things
like where people are

00:29:24.260 --> 00:29:29.110
very strict about shipping
lanes, like down here, or

00:29:29.110 --> 00:29:31.180
where they're less strict about
shipping lanes, where

00:29:31.180 --> 00:29:36.060
they just kind of go for it.

00:29:36.060 --> 00:29:38.710
And then you can see, obviously,
one of the busiest

00:29:38.710 --> 00:29:46.210
shipping straits in the world
is right through here.

00:29:46.210 --> 00:29:48.340
And so a huge number of shipping
companies pass

00:29:48.340 --> 00:29:49.140
through there.

00:29:49.140 --> 00:29:51.810
And we can come over here, and
there's interesting things.

00:29:51.810 --> 00:29:54.760
You can see the Panama Canal.

00:29:54.760 --> 00:29:57.020
You can see ships approach
and come in, and

00:29:57.020 --> 00:29:59.060
then fan back out.

00:29:59.060 --> 00:30:00.020
It's quite cool.

00:30:00.020 --> 00:30:01.860
So this is our representation.

00:30:01.860 --> 00:30:03.700
We can go with this for now.

00:30:03.700 --> 00:30:08.500
And so we want to start
mining, is the

00:30:08.500 --> 00:30:10.290
next Ben Fry stage.

00:30:10.290 --> 00:30:11.930
And so we need data.

00:30:11.930 --> 00:30:13.800
We need to be able to
pick into this.

00:30:13.800 --> 00:30:16.580
And so, when I say picking,
I mean it.

00:30:16.580 --> 00:30:22.180
So picking points-- picking is
the kind of classic graphics

00:30:22.180 --> 00:30:26.800
term for literally saying, like,
I pick that-- like where

00:30:26.800 --> 00:30:28.250
your mouse is.

00:30:28.250 --> 00:30:31.730
And so it is basically sampling
what is at that place

00:30:31.730 --> 00:30:36.750
that you clicked and giving
you something back.

00:30:36.750 --> 00:30:42.080
Now one of the advantages that
SVG fans tout about SVG is

00:30:42.080 --> 00:30:43.830
that they're actually
elements in the DOM.

00:30:43.830 --> 00:30:47.060
And so you can add a click event
to it, and then it works

00:30:47.060 --> 00:30:49.740
just like any other click
event in a browser.

00:30:49.740 --> 00:30:50.670
And it is great.

00:30:50.670 --> 00:30:55.042
But it runs into trouble when
you can't really add 80,000

00:30:55.042 --> 00:31:01.740
points to an SVG element and
expect it to perform well--

00:31:01.740 --> 00:31:02.660
yet.

00:31:02.660 --> 00:31:04.500
They keep improving.

00:31:04.500 --> 00:31:07.100
So we have to do it manually,
which is no fun.

00:31:07.100 --> 00:31:08.730
And so I've written some
code that does this.

00:31:08.730 --> 00:31:11.800
And actually, three.js has
a picking library.

00:31:11.800 --> 00:31:12.860
I've never used it in 2D.

00:31:12.860 --> 00:31:14.910
But I think it should work.

00:31:14.910 --> 00:31:18.500
And so the key is right here,
the gl.readPixels right here

00:31:18.500 --> 00:31:19.590
in the middle.

00:31:19.590 --> 00:31:22.970
And what you do is, you
transform the world so that

00:31:22.970 --> 00:31:25.900
where you just clicked
is now at 0, 0.

00:31:25.900 --> 00:31:29.820
And you just say, read me back
from that OpenGL frame buffer,

00:31:29.820 --> 00:31:33.190
what color is at that pixel?

00:31:33.190 --> 00:31:40.850
And you only want one pixel
because it's actually quite

00:31:40.850 --> 00:31:43.250
expensive to bring stuff back
from the GPU, just as it's

00:31:43.250 --> 00:31:44.580
expensive to push things--

00:31:44.580 --> 00:31:46.830
expensive relative to
a steady frame rate.

00:31:46.830 --> 00:31:50.940
So you might pay even five
milliseconds for this call,

00:31:50.940 --> 00:31:55.050
and the latency increases as the
amount of memory increases

00:31:55.050 --> 00:31:56.690
that you want to bring over.

00:31:56.690 --> 00:31:58.890
So I included this code just
because I love typed arrays so

00:31:58.890 --> 00:32:00.520
much right at the top.

00:32:00.520 --> 00:32:05.030
So what I do is, I first create
a ReadBytes, and it's a

00:32:05.030 --> 00:32:06.590
Uint8 array.

00:32:06.590 --> 00:32:08.560
So it's an array
of four bytes.

00:32:08.560 --> 00:32:10.830
And then I take a
pixelReadInt.

00:32:10.830 --> 00:32:12.060
So the type is Int.

00:32:12.060 --> 00:32:16.330
And it's an Int32 array of the
buffer of that Uint8 array.

00:32:16.330 --> 00:32:18.950
So it's taking that four byte
array and shoving it into a

00:32:18.950 --> 00:32:20.130
single int.

00:32:20.130 --> 00:32:22.530
And what's cool about this is,
when you sample a color from

00:32:22.530 --> 00:32:24.510
the screen, it's an RGBA.

00:32:24.510 --> 00:32:26.660
And it's fitting into
four bytes.

00:32:26.660 --> 00:32:29.400
And so I can read those
separately.

00:32:29.400 --> 00:32:33.700
It'll be like 255, 128, 36,
and then 1 or whatever for

00:32:33.700 --> 00:32:37.600
alpha, or 255 for alpha.

00:32:37.600 --> 00:32:41.000
But then I can look down here
the bottom, this last line,

00:32:41.000 --> 00:32:44.510
and I can do a look up table
on the int value of that.

00:32:44.510 --> 00:32:47.330
So I can make a table
of values.

00:32:47.330 --> 00:32:50.640
And as long as my values fit
into an int, I can then just

00:32:50.640 --> 00:32:52.520
shove them into a color.

00:32:52.520 --> 00:32:54.630
And OpenGL will just treat
it as a color.

00:32:54.630 --> 00:32:55.780
And so that's exactly
what I've done.

00:32:55.780 --> 00:32:59.800
So I have an ID for each ship.

00:32:59.800 --> 00:33:02.100
And I shove it into a color.

00:33:02.100 --> 00:33:04.600
And I never actually draw
it onscreen, but

00:33:04.600 --> 00:33:06.790
we can look at it.

00:33:06.790 --> 00:33:09.610
And it's really pretty.

00:33:09.610 --> 00:33:13.710
It's kind of unpleasant
to look at.

00:33:13.710 --> 00:33:15.330
But it doesn't matter because
we never see it.

00:33:15.330 --> 00:33:17.330
And it's because each of these
is a unique color.

00:33:17.330 --> 00:33:19.640
We have a huge range here.

00:33:19.640 --> 00:33:20.880
Alpha gets a little tricky,
but we have at

00:33:20.880 --> 00:33:25.990
least 24 bits of values.

00:33:25.990 --> 00:33:30.300
And so what happens is, I click
on here, and I get the

00:33:30.300 --> 00:33:32.750
single pixel that's
under my mouse.

00:33:32.750 --> 00:33:37.350
And I read back what that ID.

00:33:37.350 --> 00:33:39.560
And then I can look up in
a table to find it.

00:33:39.560 --> 00:33:40.530
And so let's find out.

00:33:40.530 --> 00:33:43.410
We actually have different
amounts of data for different

00:33:43.410 --> 00:33:43.940
types of ship.

00:33:43.940 --> 00:33:45.030
So here's the New Venture.

00:33:45.030 --> 00:33:46.520
It's a cargo ship.

00:33:46.520 --> 00:33:48.120
We last saw it on May 5.

00:33:48.120 --> 00:33:53.730
And it's speeding ahead at 11.8
knots on a course of 27.4

00:33:53.730 --> 00:33:55.830
degrees, so mostly north.

00:33:55.830 --> 00:33:59.720
And meanwhile, let's find
a different one with a--

00:34:04.760 --> 00:34:05.180
there we go.

00:34:05.180 --> 00:34:08.280
The Falcon traveler, it's
another cargo ship.

00:34:08.280 --> 00:34:11.210
But it's traveling south.

00:34:11.210 --> 00:34:12.080
So we can now do that.

00:34:12.080 --> 00:34:15.090
And so now, when we see kind of
curious ships, like say in

00:34:15.090 --> 00:34:18.770
the middle of nowhere in land,
we can be like, well what's

00:34:18.770 --> 00:34:19.790
going on here.

00:34:19.790 --> 00:34:23.449
And so we don't have
a ship name.

00:34:23.449 --> 00:34:27.050
But we can then use the MMSI,
which is there, which is kind

00:34:27.050 --> 00:34:29.960
of an ID for it that you have
to register somewhere.

00:34:29.960 --> 00:34:30.980
And we can look it up.

00:34:30.980 --> 00:34:36.080
We can look up the country and
then the registration office.

00:34:36.080 --> 00:34:38.489
And so usually what happens
is, it's a mistake.

00:34:38.489 --> 00:34:42.389
So either the GPS on the ship
messed up, or there's even

00:34:42.389 --> 00:34:46.420
cases were lightning has struck
the GPS antenna and

00:34:46.420 --> 00:34:48.560
fried the electronics, and
suddenly a ship will be

00:34:48.560 --> 00:34:51.589
teleporting all over Earth.

00:34:51.589 --> 00:34:54.030
And unfortunately, it's very
difficult to tell if it's a

00:34:54.030 --> 00:34:57.100
mistake or not because a lot of
this is standardized in a

00:34:57.100 --> 00:35:00.050
way that allows you to--

00:35:00.050 --> 00:35:02.520
you come on shift, and you're
just a guy, and you're kind of

00:35:02.520 --> 00:35:03.410
on the deck.

00:35:03.410 --> 00:35:05.510
And you're typing in your ship
ID, and hopefully you got it

00:35:05.510 --> 00:35:07.020
right because you're
broadcasting to the

00:35:07.020 --> 00:35:08.790
world who you are.

00:35:08.790 --> 00:35:10.740
So a lot of it is
not automated.

00:35:10.740 --> 00:35:11.910
So it can be very messy.

00:35:11.910 --> 00:35:15.180
And All the Ships in the World
covers some of that, how you

00:35:15.180 --> 00:35:17.720
kind of figure out, if two ships
have the same ID, and

00:35:17.720 --> 00:35:20.240
one's in South America, and
one's in England, maybe

00:35:20.240 --> 00:35:21.250
they're not the same ship.

00:35:21.250 --> 00:35:22.895
But then you really hope that
they never come together

00:35:22.895 --> 00:35:24.600
because then you can't
tell them apart.

00:35:27.110 --> 00:35:30.570
OK, so now we have picking.

00:35:30.570 --> 00:35:33.500
So we can kind of dig
a little bit deeper.

00:35:33.500 --> 00:35:35.960
I really like that you can see
ships on the Mississippi.

00:35:35.960 --> 00:35:39.270
I think that's awesome.

00:35:39.270 --> 00:35:41.235
So now we can dig a
little bit deeper.

00:35:45.300 --> 00:35:55.380
So we actually get more
complicated data down from the

00:35:55.380 --> 00:35:57.510
server than just x,
y coordinates.

00:35:57.510 --> 00:35:59.590
We actually can get a whole
bunch of attributes that come

00:35:59.590 --> 00:36:00.100
with the ship.

00:36:00.100 --> 00:36:02.160
So ships actually broadcast
quite a bit more.

00:36:02.160 --> 00:36:05.830
They broadcast, as you've seen
from the info windows, they

00:36:05.830 --> 00:36:07.570
broadcast the direction they're
travelling, their

00:36:07.570 --> 00:36:12.530
current speed, and then
some other attributes.

00:36:12.530 --> 00:36:16.070
And so what we can do is
actually take those and shove

00:36:16.070 --> 00:36:17.530
those into WebGL as well.

00:36:17.530 --> 00:36:19.190
And even though they're not
spatial coordinates, we can

00:36:19.190 --> 00:36:21.990
use those to do the same thing
we're doing here, color them

00:36:21.990 --> 00:36:24.800
by that value.

00:36:24.800 --> 00:36:27.492
So let's see, is this
what I want to do?

00:36:31.830 --> 00:36:33.280
Yes.

00:36:33.280 --> 00:36:40.300
So this is one that seems like
it's just as ugly as the

00:36:40.300 --> 00:36:41.370
picking one.

00:36:41.370 --> 00:36:44.300
But actually, you'll start to
see some coherence in the

00:36:44.300 --> 00:36:48.640
colors, especially around places
like here, where you

00:36:48.640 --> 00:36:50.700
can see that there's obviously
a line of ships

00:36:50.700 --> 00:36:52.950
with the same color.

00:36:52.950 --> 00:36:55.510
And then we come down, and
you'll see, even here, where

00:36:55.510 --> 00:37:01.700
you have much more distinct,
it's kind of party colors,

00:37:01.700 --> 00:37:03.040
very distinct shipping lanes.

00:37:03.040 --> 00:37:07.710
And so what we're doing is,
I'm not a designer.

00:37:07.710 --> 00:37:09.210
If I was, this would
look prettier.

00:37:09.210 --> 00:37:12.360
But what I'm doing is just
taking the course that the

00:37:12.360 --> 00:37:17.730
ship is traveling in, and just
taking the color wheel of hues

00:37:17.730 --> 00:37:19.690
and assigning a direction
to a hue.

00:37:19.690 --> 00:37:22.680
So north is red, and then
it goes from there.

00:37:22.680 --> 00:37:24.580
And so what we can see
here is coherence

00:37:24.580 --> 00:37:27.280
in direction traveling.

00:37:27.280 --> 00:37:29.580
And so remember, we're just
exploring data here.

00:37:29.580 --> 00:37:32.060
You wouldn't want to send
this to your end user.

00:37:32.060 --> 00:37:34.440
But you can start to see, first
of all, you can sanity

00:37:34.440 --> 00:37:35.940
check is my data correct?

00:37:35.940 --> 00:37:39.590
Like, yes, so if I look in the
Suez Canal, typically, ships

00:37:39.590 --> 00:37:41.090
are moving in the
same direction.

00:37:41.090 --> 00:37:44.410
You might lose your heading if
you're still, for instance.

00:37:44.410 --> 00:37:48.500
So we can't be totally sure that
those aren't errors, but

00:37:48.500 --> 00:37:54.410
we see enough coherence that
this is actually a valuable

00:37:54.410 --> 00:37:55.630
insight into the data.

00:37:55.630 --> 00:37:58.000
And then we can also start
seeing things like this where,

00:37:58.000 --> 00:38:00.160
as a person who doesn't know
that much about shipping, I

00:38:00.160 --> 00:38:02.810
immediately suspect that this
is a major shipping channel.

00:38:02.810 --> 00:38:07.250
And that it must be either
advantageous enough to cut

00:38:07.250 --> 00:38:10.380
across like this because it's
a short distance, and it's

00:38:10.380 --> 00:38:15.540
near the equator, so it could
be a great circle, or it's

00:38:15.540 --> 00:38:17.300
some kind of mandated thing
by governments, or

00:38:17.300 --> 00:38:18.000
something like that.

00:38:18.000 --> 00:38:21.660
And you can even see, as you get
close, that the ships on

00:38:21.660 --> 00:38:34.570
top are very distinctively going
269, which is west for

00:38:34.570 --> 00:38:35.930
you, that way.

00:38:35.930 --> 00:38:38.180
And then the guys in the bottom
are going the opposite

00:38:38.180 --> 00:38:39.590
way, almost directly.

00:38:39.590 --> 00:38:40.840
So almost directly east/west.

00:38:44.090 --> 00:38:44.530
So that's great.

00:38:44.530 --> 00:38:47.010
And in fact, you can assign
any color to those

00:38:47.010 --> 00:38:49.190
things that you want.

00:38:49.190 --> 00:38:53.640
So then the last thing is that
you want to start getting

00:38:53.640 --> 00:38:58.470
insight into more than that.

00:38:58.470 --> 00:39:00.250
So we can look at this, and it's
difficult because there's

00:39:00.250 --> 00:39:01.260
a lot of data on screen.

00:39:01.260 --> 00:39:04.740
It's difficult to get a feel
for what's going on,

00:39:04.740 --> 00:39:09.600
especially in confettiville
over here in the Gulf.

00:39:09.600 --> 00:39:11.940
And this isn't unexpected.

00:39:11.940 --> 00:39:13.980
There's actually a bunch of oil
platforms out here, and

00:39:13.980 --> 00:39:15.530
ships that to go to and
from, and then a bunch

00:39:15.530 --> 00:39:16.570
of tankers as well.

00:39:16.570 --> 00:39:18.750
And oil platforms, I didn't know
this until recently, oil

00:39:18.750 --> 00:39:20.150
platforms actually
count as ships.

00:39:20.150 --> 00:39:23.900
And so they actually broadcast
their IDs because I guess

00:39:23.900 --> 00:39:26.410
they're tethered, and actually,
they might be

00:39:26.410 --> 00:39:29.740
drilling, unless they're
refineries.

00:39:29.740 --> 00:39:32.095
But they're floating.

00:39:32.095 --> 00:39:34.200
And this is also--

00:39:34.200 --> 00:39:38.680
like, party town.

00:39:38.680 --> 00:39:41.120
So what we can do is actually
get another

00:39:41.120 --> 00:39:42.370
view into the data.

00:39:42.370 --> 00:39:44.140
And so I actually really
like this.

00:39:44.140 --> 00:39:50.670
And it's difficult to explain
why because it's not that

00:39:50.670 --> 00:39:51.110
interesting.

00:39:51.110 --> 00:39:57.990
But if you think of the classic
model view controller,

00:39:57.990 --> 00:40:03.030
we've actually kind of split
both the model and the view--

00:40:03.030 --> 00:40:06.210
well, depending on how you
define them, but whatever--

00:40:06.210 --> 00:40:09.520
into a GPU side and
a CPU side.

00:40:09.520 --> 00:40:12.340
So we have a GPU side that's
taken, we've loaded all of our

00:40:12.340 --> 00:40:13.330
data over there.

00:40:13.330 --> 00:40:15.420
And the only things that we
sent over are things like,

00:40:15.420 --> 00:40:17.980
well, here are the lat longs,
so only draw the things in

00:40:17.980 --> 00:40:18.650
that lat long.

00:40:18.650 --> 00:40:20.530
And only scale it by this
amount, and don't draw

00:40:20.530 --> 00:40:22.212
anything off the screen.

00:40:22.212 --> 00:40:24.430
Meanwhile, on the CPU side,
I do things like read

00:40:24.430 --> 00:40:25.240
back from the GPU.

00:40:25.240 --> 00:40:27.660
But all I'm reading back
is that one index.

00:40:27.660 --> 00:40:29.640
And so we can take that further
and actually do

00:40:29.640 --> 00:40:30.820
computations on the CPU.

00:40:30.820 --> 00:40:32.470
And that's great because the
CPU is not doing anything

00:40:32.470 --> 00:40:35.570
while the GPU is crunching
away at these numbers.

00:40:35.570 --> 00:40:38.710
And if we really want to get
those fans at full speed, what

00:40:38.710 --> 00:40:44.530
we can do is actually
plot things.

00:40:44.530 --> 00:40:46.730
You see that?

00:40:46.730 --> 00:40:47.980
I wonder if I can--

00:40:52.079 --> 00:40:53.570
yeah, well, the country's
all messed up now.

00:40:58.000 --> 00:40:58.860
There we go.

00:40:58.860 --> 00:41:02.410
So we lost some crispness.

00:41:02.410 --> 00:41:02.870
But that's OK.

00:41:02.870 --> 00:41:05.080
It's better to see this big.

00:41:05.080 --> 00:41:07.780
So what this is, it's
a histogram of the

00:41:07.780 --> 00:41:10.010
speeds of the ships.

00:41:10.010 --> 00:41:11.480
And it changes as
we go around.

00:41:11.480 --> 00:41:13.390
It actually changes the
current view of the

00:41:13.390 --> 00:41:14.640
speeds of the ship.

00:41:16.650 --> 00:41:18.210
So first of all, the thing
that always wins

00:41:18.210 --> 00:41:19.530
is zero over here.

00:41:19.530 --> 00:41:22.000
So there's always enough ships
at rest that that's going to

00:41:22.000 --> 00:41:22.750
be the biggest bucket.

00:41:22.750 --> 00:41:28.516
And in fact, the bucket goes
like up to India here, but I

00:41:28.516 --> 00:41:30.330
clipped it off because it makes
everything else very

00:41:30.330 --> 00:41:32.000
small if I normalize by that.

00:41:32.000 --> 00:41:33.450
And so remember, this
is a distribution.

00:41:33.450 --> 00:41:36.720
So this not a bar graph
of the total.

00:41:36.720 --> 00:41:40.970
This is just taking a look at,
if you count the current ships

00:41:40.970 --> 00:41:45.900
on screen as 100%, this is
a division of that full

00:41:45.900 --> 00:41:47.880
distribution.

00:41:47.880 --> 00:41:54.110
So you can normalize in your
head by root 2 pi whatever.

00:41:54.110 --> 00:41:56.625
So what's interesting about this
is, you can start to see,

00:41:56.625 --> 00:41:59.750
well A, everybody seems to
travel at about 12 knots,

00:41:59.750 --> 00:42:03.880
which is a little slower than
I would've thought.

00:42:03.880 --> 00:42:05.250
But you can see definite
patterns.

00:42:05.250 --> 00:42:07.180
So where's a good pattern?

00:42:07.180 --> 00:42:12.060
So off this Eastern Seaboard,
people are kind of doing a lot

00:42:12.060 --> 00:42:14.020
of shipping.

00:42:14.020 --> 00:42:16.250
And so you have these
ships coming in

00:42:16.250 --> 00:42:17.750
from across the ocean.

00:42:17.750 --> 00:42:22.020
And so they're tending to go
pretty fast because you spend

00:42:22.020 --> 00:42:24.640
more time at sea, the more
expensive it is.

00:42:24.640 --> 00:42:26.890
But as I was mentioning,
in the Gulf

00:42:26.890 --> 00:42:28.960
it's quite a bit different.

00:42:28.960 --> 00:42:30.320
You actually have
very slow ships.

00:42:30.320 --> 00:42:31.830
So first all, your
oil platforms

00:42:31.830 --> 00:42:33.010
aren't necessarily moving.

00:42:33.010 --> 00:42:34.330
They might fall in
the 0 category.

00:42:34.330 --> 00:42:36.910
But the ships that service
them are also quite slow.

00:42:36.910 --> 00:42:38.870
And so you actually have, as you
come around here, you have

00:42:38.870 --> 00:42:41.310
this really nice bimodal
distribution which you never

00:42:41.310 --> 00:42:44.420
get to see enough of where you
have definite slow ships, and

00:42:44.420 --> 00:42:45.420
you have fast ships.

00:42:45.420 --> 00:42:48.100
And so this can help you start
to investigate your data.

00:42:48.100 --> 00:42:50.240
And then you can start looking
at things, like, so what I've

00:42:50.240 --> 00:42:52.875
done here is actually,
it's hard to tell.

00:42:52.875 --> 00:42:54.870
But I've actually colored it.

00:42:54.870 --> 00:42:59.580
I'm bending by everything that's
this light blue, which

00:42:59.580 --> 00:43:04.930
is an unfortunate choice, but
that's OK, is not moving.

00:43:04.930 --> 00:43:07.290
And everything that's dark blue
is moving at some speed.

00:43:07.290 --> 00:43:09.200
And you can even color
it the same way

00:43:09.200 --> 00:43:11.220
that we do with course.

00:43:11.220 --> 00:43:13.360
So that's looking this thing.

00:43:13.360 --> 00:43:16.480
And this is, I should say, this
is using the Crossfilter

00:43:16.480 --> 00:43:17.720
library, that comes from--

00:43:17.720 --> 00:43:18.780
Mike Bostock wrote it.

00:43:18.780 --> 00:43:22.700
And then it's drawing with D3,
which Mike Bostock also wrote,

00:43:22.700 --> 00:43:23.910
is the little histogram.

00:43:23.910 --> 00:43:25.690
It's basically the simplest
little histogram

00:43:25.690 --> 00:43:26.130
that you can write.

00:43:26.130 --> 00:43:29.920
But you can drop this in for any
variable in the data set.

00:43:29.920 --> 00:43:32.210
And actually, so this afternoon,
when All the Ships

00:43:32.210 --> 00:43:34.635
in the World shows, we actually
have a few more that

00:43:34.635 --> 00:43:39.660
we can show that time, but
I need to press on.

00:43:39.660 --> 00:43:44.380
So the last thing I wanted to
show before we go to questions

00:43:44.380 --> 00:43:49.540
is that here, I showed that
you can clip the alpha and

00:43:49.540 --> 00:43:50.760
have a distinct circle.

00:43:50.760 --> 00:43:52.490
And so this is actually drawing
a square still, but

00:43:52.490 --> 00:43:57.660
it's just drawing invisible
pixels around a circle.

00:43:57.660 --> 00:43:59.540
But there's no reason that
we have to do that.

00:43:59.540 --> 00:44:04.570
So what we could do instead is
actually draw with functions.

00:44:04.570 --> 00:44:07.460
So for instance, instead of
doing distance as this link

00:44:07.460 --> 00:44:10.060
and then cutting off the alpha,
we could, instead, do

00:44:10.060 --> 00:44:19.710
something like take the distance
and set it equal to 1

00:44:19.710 --> 00:44:24.230
minus dist times 2.

00:44:24.230 --> 00:44:27.780
And so if you remember the
distance to the edge is 0.5

00:44:27.780 --> 00:44:29.430
because that's the edge
of the circle.

00:44:29.430 --> 00:44:31.130
So we multiply it by
2 to get to one.

00:44:31.130 --> 00:44:35.980
And then we invert it so that
zero's at the center.

00:44:35.980 --> 00:44:37.320
No, one is at the
center, yeah.

00:44:37.320 --> 00:44:39.080
And so now, if we
take this dist--

00:44:42.310 --> 00:44:44.660
actually no, we want to do
one thing, just in case.

00:44:44.660 --> 00:44:49.272
dist equals max 0.

00:44:49.272 --> 00:44:52.940
So we clamp it at zero so we
don't draw out of range.

00:44:52.940 --> 00:44:55.200
We can now do something
like this.

00:44:55.200 --> 00:45:00.120
And what you see is, you
quickly get a function.

00:45:00.120 --> 00:45:05.236
Or it's a fall off function
that's put on top of that dot.

00:45:05.236 --> 00:45:06.460
So you can do anything here.

00:45:06.460 --> 00:45:09.240
And you can do quite
complicated things.

00:45:09.240 --> 00:45:11.100
And so what you can start
thinking about is taking

00:45:11.100 --> 00:45:15.490
functions and geometry, and
what's called convolving them,

00:45:15.490 --> 00:45:18.030
and so you can actually have a
function that's spread out

00:45:18.030 --> 00:45:19.220
over geometry.

00:45:19.220 --> 00:45:21.450
And that's the last thing
I wanted to show you.

00:45:21.450 --> 00:45:26.550
If we think about, instead of
points, we say, OK, so this is

00:45:26.550 --> 00:45:27.910
the latest positions
of these ships.

00:45:27.910 --> 00:45:31.050
What about if we look at the
paths that these ships have

00:45:31.050 --> 00:45:32.110
actually traveled?

00:45:32.110 --> 00:45:36.640
So that was about
79,000 ships.

00:45:36.640 --> 00:45:39.080
And instead, we're going to
look at about 20,000.

00:45:39.080 --> 00:45:41.040
So less ships, but we're
actually going to look at a

00:45:41.040 --> 00:45:42.480
bunch of data points per ship.

00:45:42.480 --> 00:45:44.070
And so we're going to end
up with about two

00:45:44.070 --> 00:45:45.780
million paths on screen.

00:46:11.130 --> 00:46:17.085
So you should see,
there we go.

00:46:17.085 --> 00:46:19.760
It's a little difficult to
see with these lights.

00:46:19.760 --> 00:46:20.435
That's unfortunate.

00:46:20.435 --> 00:46:23.240
So what you can see now is, as
we zoom in, you can actually

00:46:23.240 --> 00:46:25.100
see these ships moving.

00:46:25.100 --> 00:46:27.240
And you can see some of the
errors in the data where they

00:46:27.240 --> 00:46:28.410
cut across Saudi Arabia.

00:46:28.410 --> 00:46:31.450
Probably, that's just the
sampling of the data.

00:46:31.450 --> 00:46:35.710
If the ship has made it around
the cape there in a day, then

00:46:35.710 --> 00:46:37.290
they'll be drawn straight
through it.

00:46:37.290 --> 00:46:41.520
But you can quickly see, as it
builds up, that you can see

00:46:41.520 --> 00:46:43.650
those same shipping
lanes building up.

00:46:43.650 --> 00:46:48.920
And we can do things like fall
off to blue and more

00:46:48.920 --> 00:46:50.390
transparent over time.

00:46:50.390 --> 00:46:53.350
And so the newer ships, the
ships that are actually

00:46:53.350 --> 00:46:55.670
passing by, are these
bright orange.

00:46:55.670 --> 00:46:58.550
And the older ships are
the darker pink.

00:46:58.550 --> 00:47:00.170
And then we can do things.

00:47:00.170 --> 00:47:05.422
It's difficult to see, but it's
easier-- you can come put

00:47:05.422 --> 00:47:08.190
to the sandbox afterwards and
come see for yourself at full.

00:47:08.190 --> 00:47:11.540
It's a Retina screen, too.

00:47:11.540 --> 00:47:14.170
But what we're actually doing
is taking an error function.

00:47:14.170 --> 00:47:15.600
And we're putting that
over the line.

00:47:15.600 --> 00:47:16.420
So it's not just a line.

00:47:16.420 --> 00:47:17.360
It's also an error function.

00:47:17.360 --> 00:47:19.900
And it's an attempt I'm kind
of playing around with--

00:47:19.900 --> 00:47:22.960
can we take GPS error and
kind of visualize it.

00:47:22.960 --> 00:47:24.990
So we have an uncertainty
of where the ship is.

00:47:24.990 --> 00:47:27.530
We know it was here, and we
know it was here with some

00:47:27.530 --> 00:47:28.290
amount of error.

00:47:28.290 --> 00:47:30.980
And we know it got between
them somehow.

00:47:30.980 --> 00:47:33.820
And so we want to start
thinking about, can we

00:47:33.820 --> 00:47:34.430
quantify the error?

00:47:34.430 --> 00:47:36.890
And can we draw it by actually
spreading out and kind of

00:47:36.890 --> 00:47:40.890
having a sum of all possible
ships that go through.

00:47:40.890 --> 00:47:42.580
And so it's a pretty fun area.

00:47:42.580 --> 00:47:45.430
And I think we're just
starting with

00:47:45.430 --> 00:47:47.210
that particular thing.

00:47:47.210 --> 00:47:50.290
But polylines are something that
have been ignored for too

00:47:50.290 --> 00:47:54.410
long as kind of an interesting
geometric thing, especially in

00:47:54.410 --> 00:47:58.030
Maps because while we can draw
polylines, it turns out

00:47:58.030 --> 00:48:00.660
polylines are expensive, and in
many ways, more expensive

00:48:00.660 --> 00:48:03.510
than polygons to draw.

00:48:03.510 --> 00:48:06.470
And I did want to show just
a couple of things.

00:48:06.470 --> 00:48:08.740
I can leave while I
go for questions.

00:48:08.740 --> 00:48:11.100
But you can see already some
interesting things that we

00:48:11.100 --> 00:48:13.090
couldn't pick up in just
the point data

00:48:13.090 --> 00:48:14.355
like, here around Iceland--

00:48:20.122 --> 00:48:21.370
there they are.

00:48:21.370 --> 00:48:24.420
You'll see there's definite
ships that are tracking and

00:48:24.420 --> 00:48:25.630
doing cargo.

00:48:25.630 --> 00:48:28.940
But then as we get close to
the end here, you'll see

00:48:28.940 --> 00:48:31.760
fishing vessels go out and
kind of swirl around

00:48:31.760 --> 00:48:32.460
and come back in.

00:48:32.460 --> 00:48:34.290
And you can only see that
pretty much through the

00:48:34.290 --> 00:48:37.880
behavior of the lines, which
is pretty cool to see.

00:48:37.880 --> 00:48:39.370
So I'll open it up
for questions.

00:48:39.370 --> 00:48:40.910
We have about eight minutes.

00:48:40.910 --> 00:48:43.344
I apologize for going over.

00:48:43.344 --> 00:48:44.720
There's a lot more to show.

00:48:44.720 --> 00:48:46.990
So I'll just kind of--

00:48:46.990 --> 00:48:48.880
I like this area
in Alaska, too.

00:48:48.880 --> 00:48:53.910
But so I just wanted
to say thank you.

00:48:53.910 --> 00:48:57.940
And as I said, there's a bunch
of resources online, a bunch

00:48:57.940 --> 00:48:59.080
of libraries for WebGL.

00:48:59.080 --> 00:49:03.110
CanvasLayer, if you look for
it, it has two sample apps,

00:49:03.110 --> 00:49:05.340
they are very simple, a 2D app
and a WebGL app just to get

00:49:05.340 --> 00:49:06.580
you started.

00:49:06.580 --> 00:49:09.050
And the 2D app does, I think,
exactly what you saw.

00:49:09.050 --> 00:49:10.030
It draws a square.

00:49:10.030 --> 00:49:12.260
And the WebGL app just generates
a bunch of random

00:49:12.260 --> 00:49:14.230
points and plops them
down on a map.

00:49:14.230 --> 00:49:16.350
So you can kind of use
it and copy it.

00:49:16.350 --> 00:49:18.370
And I think there was even a
blog post where somebody

00:49:18.370 --> 00:49:20.930
deciphered my code and
made it nicer.

00:49:20.930 --> 00:49:22.840
So you might look
for that, too.

00:49:22.840 --> 00:49:26.180
So if anybody has questions,
please come up to

00:49:26.180 --> 00:49:29.740
the mic and ask away.

00:49:29.740 --> 00:49:32.660
AUDIENCE: So when you're
coloring on a pixel by pixel

00:49:32.660 --> 00:49:34.710
basis, how do you do things
like sprites?

00:49:34.710 --> 00:49:36.450
Do you have a buffer that
represents the sprites, then

00:49:36.450 --> 00:49:38.770
you look at the pixel offset in
there and draw that color

00:49:38.770 --> 00:49:40.330
at that exact point?

00:49:40.330 --> 00:49:43.040
Or how do you do more complex
things than dots?

00:49:43.040 --> 00:49:44.570
BRENDAN KENNY: Oh, more complex
things than dots?

00:49:44.570 --> 00:49:48.090
So you were asking about
sprites, like image sprites?

00:49:48.090 --> 00:49:52.880
Yeah, so obviously this
3D stuff is used for

00:49:52.880 --> 00:49:53.760
games all the time.

00:49:53.760 --> 00:49:56.010
And so games are often
based on, actually,

00:49:56.010 --> 00:49:56.760
texturing and things.

00:49:56.760 --> 00:49:58.440
And so, yeah, you just
load up a bunch of

00:49:58.440 --> 00:49:59.890
images onto your GPU.

00:49:59.890 --> 00:50:03.020
And then you can just get
those pixel offsets.

00:50:03.020 --> 00:50:05.840
The same thing I was using for
the function to do a distance,

00:50:05.840 --> 00:50:07.280
you can use that to look
up into your sprite.

00:50:07.280 --> 00:50:09.050
And you say, like, this
is a gray pixel.

00:50:09.050 --> 00:50:10.420
This is a red pixel.

00:50:10.420 --> 00:50:11.290
This is a gray pixel.

00:50:11.290 --> 00:50:13.410
And it seems like it would
be slow, but it's not.

00:50:13.410 --> 00:50:18.270
And you get your little 2D
sprite art before you know it.

00:50:18.270 --> 00:50:19.360
So that's typically
what you do.

00:50:19.360 --> 00:50:22.660
AUDIENCE: And also, is that
shader playground that you

00:50:22.660 --> 00:50:25.250
used to interactively
show the changes, is

00:50:25.250 --> 00:50:26.240
that available online?

00:50:26.240 --> 00:50:27.430
BRENDAN KENNY: I can
put it online.

00:50:27.430 --> 00:50:29.940
It's dead simple, but yeah,
I can put it online.

00:50:32.510 --> 00:50:37.400
AUDIENCE: Hi, yeah, I have a
simple question about plotting

00:50:37.400 --> 00:50:39.280
the items on the map.

00:50:39.280 --> 00:50:47.310
So would it be possible for
those points to have like an

00:50:47.310 --> 00:50:50.910
additional bigger circles,
like the radius?

00:50:50.910 --> 00:50:55.880
So my current project is, I need
to have a visualization

00:50:55.880 --> 00:50:59.340
for overlapping schools, public
schools, particularly,

00:50:59.340 --> 00:51:00.510
in the Philippines.

00:51:00.510 --> 00:51:05.410
So I would need to have a range
of five kilometers.

00:51:05.410 --> 00:51:10.560
I need to indicate if there are
overlapping schools within

00:51:10.560 --> 00:51:12.550
a five kilometer radius.

00:51:12.550 --> 00:51:15.320
BRENDAN KENNY: So how many
schools are you talking about?

00:51:15.320 --> 00:51:18.505
AUDIENCE: I would be plotting
around 70,000 schools.

00:51:18.505 --> 00:51:19.260
BRENDAN KENNY: Oh, so a lot.

00:51:19.260 --> 00:51:20.390
OK, so yes.

00:51:20.390 --> 00:51:23.820
So I actually limited the
circles because they get so

00:51:23.820 --> 00:51:26.130
big after a while that
you lose all context.

00:51:26.130 --> 00:51:27.690
You can't see the map anymore.

00:51:27.690 --> 00:51:30.600
But yes, they can be
arbitrarily big.

00:51:30.600 --> 00:51:33.510
There are some limits with point
sprites, but you can

00:51:33.510 --> 00:51:35.580
then just switch to triangles
and pretending

00:51:35.580 --> 00:51:36.350
they're point sprites.

00:51:36.350 --> 00:51:38.980
AUDIENCE: OK, so that's
possible, right?

00:51:38.980 --> 00:51:45.770
So I could like mark it as red
for those schools who overlap

00:51:45.770 --> 00:51:51.400
for, let's say, I could adjust
it like 2 kilometers, 5

00:51:51.400 --> 00:51:51.600
kilometers.

00:51:51.600 --> 00:51:52.140
BRENDAN KENNY: Yeah, so there's
a couple of different

00:51:52.140 --> 00:51:53.580
ways you could do that.

00:51:53.580 --> 00:51:55.230
You can just do it with
plain color if it's

00:51:55.230 --> 00:51:56.990
just for visual display.

00:51:56.990 --> 00:51:58.670
You could also use what's called
the stencil buffer,

00:51:58.670 --> 00:52:00.820
where you can actually use, it's
like a secondary buffer,

00:52:00.820 --> 00:52:04.270
where you can do more logical
operations like checking for

00:52:04.270 --> 00:52:05.910
intersections and things
like that.

00:52:05.910 --> 00:52:08.015
And you can even do something,
if you had the colors, you

00:52:08.015 --> 00:52:11.270
could then do that read back
thing that I did for picking.

00:52:11.270 --> 00:52:13.390
And you could even read the
color back and know, like, OK,

00:52:13.390 --> 00:52:15.262
this is the intersection of this
kind of school and this

00:52:15.262 --> 00:52:17.550
kind of school, if you
wanted to do that.

00:52:17.550 --> 00:52:19.490
It might be faster do that
side on the CPU.

00:52:19.490 --> 00:52:20.550
It's always a trade off.

00:52:20.550 --> 00:52:22.750
But sometimes it's easier to
just shove it on the GPU and

00:52:22.750 --> 00:52:23.480
say, take care of it.

00:52:23.480 --> 00:52:27.950
And GPUs tend to be so fast
these days that, at least for

00:52:27.950 --> 00:52:30.310
a prototype, it's fast enough.

00:52:30.310 --> 00:52:32.400
And then you just need to
evaluate on real hardware and

00:52:32.400 --> 00:52:34.140
see if it's fast enough there.

00:52:34.140 --> 00:52:34.920
AUDIENCE: OK, thank you.

00:52:34.920 --> 00:52:37.020
BRENDAN KENNY: Yeah.

00:52:37.020 --> 00:52:39.210
AUDIENCE: Hi, can you
obtain a similar

00:52:39.210 --> 00:52:40.870
effect on Google Earth?

00:52:40.870 --> 00:52:45.330
And can you do it sharing
the same pieces of code?

00:52:45.330 --> 00:52:47.190
BRENDAN KENNY: It would
be awesome to do

00:52:47.190 --> 00:52:49.060
it in Google Earth.

00:52:49.060 --> 00:52:49.965
OK, if I understand
your question.

00:52:49.965 --> 00:52:52.950
So you're asking if you can do
this, take Google Earth and

00:52:52.950 --> 00:52:55.520
draw the same things
on the planet.

00:52:55.520 --> 00:52:56.830
It would be awesome.

00:52:56.830 --> 00:53:00.860
But Google Earth is
a C++ program.

00:53:00.860 --> 00:53:04.520
And it's more difficult to
insert yourself into that kind

00:53:04.520 --> 00:53:06.460
of program.

00:53:06.460 --> 00:53:09.860
And so it's difficult to
share the context.

00:53:09.860 --> 00:53:13.677
And especially if you want to
do things like properly draw

00:53:13.677 --> 00:53:15.295
on terrain, and not
self-intersect it,

00:53:15.295 --> 00:53:16.140
and stuff like that.

00:53:16.140 --> 00:53:17.710
Because if they've
done any tricks--

00:53:17.710 --> 00:53:19.280
you would definitely
be hacking.

00:53:19.280 --> 00:53:26.070
It would not be getting
along harmoniously.

00:53:26.070 --> 00:53:28.950
I think it would be great
to do that, though.

00:53:28.950 --> 00:53:32.550
And I mean, some of this is
very possible with KML.

00:53:32.550 --> 00:53:35.660
Usually not on this scale,
usually not in the tens of

00:53:35.660 --> 00:53:37.970
thousands of polylines,
especially if

00:53:37.970 --> 00:53:39.420
they're long enough.

00:53:39.420 --> 00:53:43.350
But I think we're starting to
see more and more stuff move

00:53:43.350 --> 00:53:46.030
to the browser, kind of
with the new Maps

00:53:46.030 --> 00:53:46.690
and things like that.

00:53:46.690 --> 00:53:50.880
And I would love to see this
kind of thing, just plop it

00:53:50.880 --> 00:53:52.870
right on top of WebGL globe.

00:53:52.870 --> 00:53:53.900
I think that would be amazing.

00:53:53.900 --> 00:53:56.810
We'll see if that happens.

00:53:56.810 --> 00:53:58.240
AUDIENCE: Thank you.

00:53:58.240 --> 00:54:01.120
I noticed you said you had
about 70,000 points.

00:54:01.120 --> 00:54:03.340
And then here, you were talking
about millions.

00:54:03.340 --> 00:54:04.710
What are the limits?

00:54:04.710 --> 00:54:06.140
I didn't understand.

00:54:06.140 --> 00:54:07.187
I have a second question, too.

00:54:07.187 --> 00:54:10.650
BRENDAN KENNY: Right, it was
79,000 in the first one.

00:54:10.650 --> 00:54:18.040
And it was just a query of the
database saying, for every

00:54:18.040 --> 00:54:22.670
unique ID you have, show me the
most recent timestamped

00:54:22.670 --> 00:54:23.980
message you have from them.

00:54:23.980 --> 00:54:26.610
And so we had 79,000 ships
that fall within--

00:54:26.610 --> 00:54:29.055
we had a couple of things,
like it can't be--

00:54:29.055 --> 00:54:32.610
there's a bunch of things with
obviously wrong data, like

00:54:32.610 --> 00:54:34.530
either their machine's messed
up, or we're parsing it wrong,

00:54:34.530 --> 00:54:36.255
or the satellite picked
it up wrong.

00:54:36.255 --> 00:54:37.320
So we're leaving them out.

00:54:37.320 --> 00:54:40.470
So that's the good 79,000 that
are within the last three

00:54:40.470 --> 00:54:41.710
months or something.

00:54:41.710 --> 00:54:43.510
So for this, this is actually
fewer points.

00:54:43.510 --> 00:54:45.000
So this is 20,000 ships.

00:54:45.000 --> 00:54:50.270
So it's fewer ships, but it's
two million line segments is

00:54:50.270 --> 00:54:51.540
what we end up drawing.

00:54:51.540 --> 00:54:53.880
And actually, the frame rate
is good enough that I was

00:54:53.880 --> 00:54:54.630
thinking about bumping it up.

00:54:54.630 --> 00:54:56.155
But I didn't have time.

00:54:56.155 --> 00:54:57.850
AUDIENCE: But my question
is, what is the limits?

00:54:57.850 --> 00:54:59.420
Like let's say you had
a million points?

00:54:59.420 --> 00:54:59.950
BRENDAN KENNY: Yes.

00:54:59.950 --> 00:55:01.470
So a million points is
definitely doable.

00:55:01.470 --> 00:55:02.810
It depends on the hardware.

00:55:02.810 --> 00:55:06.780
So you might have more
difficulty on older hardware.

00:55:06.780 --> 00:55:10.390
And it's difficult to, right
now, get the feedback you need

00:55:10.390 --> 00:55:11.800
to from the browser.

00:55:11.800 --> 00:55:15.310
There are a bunch of browser
extensions that you can run to

00:55:15.310 --> 00:55:15.970
get that feedback.

00:55:15.970 --> 00:55:19.300
But it's hard to ask an end user
to run that and say, can

00:55:19.300 --> 00:55:22.170
you copy and paste what
that just printed out.

00:55:22.170 --> 00:55:30.110
And so but I run regularly,
on here, up to 10

00:55:30.110 --> 00:55:32.715
million points, maybe.

00:55:32.715 --> 00:55:35.650
And that's mostly brute
force, actually.

00:55:35.650 --> 00:55:39.950
As long as it's not on screen,
you can actually

00:55:39.950 --> 00:55:41.230
call it quite quickly.

00:55:41.230 --> 00:55:45.070
And if it is on screen, you can
do things like be careful

00:55:45.070 --> 00:55:47.690
of your alpha, so you're
not drawing too much.

00:55:47.690 --> 00:55:51.450
But then you can start doing
things like actually

00:55:51.450 --> 00:55:52.740
partitioning it spatially.

00:55:52.740 --> 00:55:54.750
So you can do things like only
draw it between these

00:55:54.750 --> 00:55:55.780
latitudes and these
longitudes.

00:55:55.780 --> 00:55:58.820
And so you actually save a
bunch of time that way.

00:55:58.820 --> 00:56:01.630
And so, but yeah, just brute
force, like draw it all on

00:56:01.630 --> 00:56:03.240
screen, 10 million.

00:56:03.240 --> 00:56:04.950
It depends on the exact blending
modes that you're

00:56:04.950 --> 00:56:05.780
doing and things like that.

00:56:05.780 --> 00:56:08.050
AUDIENCE: My final question
is, let's say you're a

00:56:08.050 --> 00:56:09.830
JavaScript map programmer.

00:56:09.830 --> 00:56:13.310
You want to learn this, is
a good place to start?

00:56:13.310 --> 00:56:15.590
BRENDAN KENNY: Yeah,
so three.js is a

00:56:15.590 --> 00:56:16.270
great place to start.

00:56:16.270 --> 00:56:19.910
I've seen a number of people
start with three.js.

00:56:19.910 --> 00:56:21.390
It's a library.

00:56:21.390 --> 00:56:23.720
AUDIENCE: Oh, OK, so search
Google on three.js?

00:56:23.720 --> 00:56:24.690
BRENDAN KENNY: Yeah.

00:56:24.690 --> 00:56:25.770
A lot of people have
started with that.

00:56:25.770 --> 00:56:28.570
And if they've wanted to move
on to full WebGL, there's

00:56:28.570 --> 00:56:32.230
actually a few escape hatches
where you can say custom

00:56:32.230 --> 00:56:35.470
element, and you specify
everything yourself, but then

00:56:35.470 --> 00:56:38.290
lots of it is already
made for you.

00:56:38.290 --> 00:56:41.080
Just simple things that
are already made.

00:56:41.080 --> 00:56:43.570
But then the variety that people
come up with with that

00:56:43.570 --> 00:56:45.120
stuff is amazing.

00:56:45.120 --> 00:56:46.060
There's a few books.

00:56:46.060 --> 00:56:53.360
My favorite book is still the
"OpenGL ES 2.0 Programming

00:56:53.360 --> 00:56:55.720
Guide." It's a purple book.

00:56:55.720 --> 00:56:57.100
And it's not actually
WebGL, but it's

00:56:57.100 --> 00:56:58.470
close enough to WebGL.

00:56:58.470 --> 00:57:02.230
It's basically the mirrored
API, but in C. But it's is

00:57:02.230 --> 00:57:03.040
pretty much the same thing.

00:57:03.040 --> 00:57:05.380
There's also two, at least,
that I know of,

00:57:05.380 --> 00:57:07.010
of WebGL books directly.

00:57:07.010 --> 00:57:09.110
And I haven't read either
of them, so I

00:57:09.110 --> 00:57:10.180
can't vouch for them.

00:57:10.180 --> 00:57:14.390
But one of them is specifically
about three.js.

00:57:14.390 --> 00:57:16.200
And it's written
by Tony Parisi.

00:57:19.850 --> 00:57:23.360
And he runs a blog called
"Learning WebGL" now.

00:57:23.360 --> 00:57:26.120
And it's specifically about
that sort of thing.

00:57:26.120 --> 00:57:28.370
And he has updates every week,
like, cool stuff that happened

00:57:28.370 --> 00:57:29.610
around the web.

00:57:29.610 --> 00:57:31.107
Yeah, so hopefully,
that's helpful.

00:57:31.107 --> 00:57:31.484
Yeah?

00:57:31.484 --> 00:57:32.240
AUDIENCE: Hi there.

00:57:32.240 --> 00:57:35.810
So using the color as an index
for picking is a pretty cool

00:57:35.810 --> 00:57:39.370
trick, but kind of
limited to just

00:57:39.370 --> 00:57:42.220
picking individual things.

00:57:42.220 --> 00:57:44.910
It seems that for a lot of real
world stuff, you quickly

00:57:44.910 --> 00:57:48.280
fall into sort of spatial
partitioning problems.

00:57:48.280 --> 00:57:51.920
So do you have any advice for
how to efficiently, when

00:57:51.920 --> 00:57:54.560
you've got really large data
sets, sort of do the spatial

00:57:54.560 --> 00:57:57.650
partitioning for finding regions
and things like that?

00:57:57.650 --> 00:57:58.235
BRENDAN KENNY: Sure, sure.

00:57:58.235 --> 00:58:00.675
So you're talking like if you
wanted to be like a ranged

00:58:00.675 --> 00:58:02.590
query and say, all the points.

00:58:02.590 --> 00:58:06.040
So honestly, it's a little
embarrassing to do picking.

00:58:06.040 --> 00:58:08.140
It's actually nice to
show the technique.

00:58:08.140 --> 00:58:09.910
But it's the lazy way.

00:58:09.910 --> 00:58:12.460
Points, especially, are some
of the easiest things to

00:58:12.460 --> 00:58:15.680
partition and select
the nearest from.

00:58:15.680 --> 00:58:17.340
Especially 80,000 points.

00:58:17.340 --> 00:58:20.080
So one piece of advice I have
would be to trust JavaScript.

00:58:20.080 --> 00:58:21.640
It's actually much faster
than a lot of people

00:58:21.640 --> 00:58:23.030
give it credit for.

00:58:23.030 --> 00:58:26.100
You have to kind of stick to
same things, but there's even

00:58:26.100 --> 00:58:29.550
a lot of profiling tools
available now to tell you

00:58:29.550 --> 00:58:33.610
exactly where you screwed up--

00:58:33.610 --> 00:58:35.940
screwed up in the sense that
you angered the JavaScript

00:58:35.940 --> 00:58:40.070
gods, and you de-allocated
something they assumed it was

00:58:40.070 --> 00:58:40.560
allocating.

00:58:40.560 --> 00:58:44.735
And they de-opted your just
in time compiled code.

00:58:44.735 --> 00:58:47.130
But other than that, I mean,
it's really just like pretty

00:58:47.130 --> 00:58:49.820
much the algorithms
that you expect.

00:58:49.820 --> 00:58:51.820
So Crossfilter, which was
running that histogram at the

00:58:51.820 --> 00:58:53.560
bottom, is actually
doing that.

00:58:53.560 --> 00:58:57.840
They do range queries in
up to 32 dimensions.

00:58:57.840 --> 00:59:00.500
And it's pretty fast.

00:59:00.500 --> 00:59:02.350
WebGL is faster than it.

00:59:02.350 --> 00:59:03.960
And so it can actually slow
down the frame rate

00:59:03.960 --> 00:59:05.580
calculating that.

00:59:05.580 --> 00:59:08.360
But one thing that you can do,
but I've never tried before,

00:59:08.360 --> 00:59:09.850
is you can run it in a
web worker, so it's

00:59:09.850 --> 00:59:11.240
in a different thread.

00:59:11.240 --> 00:59:12.600
And actually, you're
bringing over

00:59:12.600 --> 00:59:14.460
just the grouped histogram.

00:59:14.460 --> 00:59:17.830
So it's much less data that
you're bringing between

00:59:17.830 --> 00:59:21.830
processes, threads, whatever.

00:59:21.830 --> 00:59:24.210
And so you can kind of
shove off work there.

00:59:24.210 --> 00:59:27.280
But I would say really, the
typical space partition

00:59:27.280 --> 00:59:29.930
algorithms that are everywhere,
and hopefully

00:59:29.930 --> 00:59:33.400
we'll start to see more
implementations.

00:59:33.400 --> 00:59:37.980
I've done a little bit with some
computational algebra,

00:59:37.980 --> 00:59:40.600
computational geometry libraries
that you can check

00:59:40.600 --> 00:59:43.430
out if you check out
my GitHub account.

00:59:43.430 --> 00:59:48.400
And that might be helpful.

00:59:48.400 --> 00:59:51.500
So yeah, so, any
more questions?

00:59:51.500 --> 00:59:53.000
All right, thank you.

00:59:53.000 --> 00:59:56.073
[APPLAUSE]

