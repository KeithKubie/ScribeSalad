WEBVTT
Kind: captions
Language: en

00:00:00.500 --> 00:00:03.792
[MUSIC PLAYING]

00:00:05.214 --> 00:00:06.800
BEN POIESZ: I'm Ben Poiesz.

00:00:06.800 --> 00:00:09.184
I'm the product manager
for Android framework.

00:00:09.184 --> 00:00:10.850
I like how everybody's
right over there.

00:00:10.850 --> 00:00:11.849
I wish I could join you.

00:00:11.849 --> 00:00:13.919
The sun's going to
come and get me.

00:00:13.919 --> 00:00:15.460
What I want to talk
to you guys about

00:00:15.460 --> 00:00:18.640
is background limits and a
lot of the infrastructure

00:00:18.640 --> 00:00:21.850
that we've put in place in O.
And it is a starting point.

00:00:21.850 --> 00:00:23.830
And I wanted to try
and have this talk,

00:00:23.830 --> 00:00:27.735
give you a glimpse as to how
we're approaching the problem

00:00:27.735 --> 00:00:29.110
and so you don't
just think we're

00:00:29.110 --> 00:00:30.914
trying to ruin all the
apps and everything

00:00:30.914 --> 00:00:32.080
you're doing the background.

00:00:32.080 --> 00:00:36.250
We're actually trying to find
a balance of enabling users

00:00:36.250 --> 00:00:38.440
to have battery life
they can rely on

00:00:38.440 --> 00:00:41.260
and enabling developers to
do the use cases that they

00:00:41.260 --> 00:00:44.297
think are great and that
users respond positively to.

00:00:44.297 --> 00:00:45.880
And so to do that,
we're going to talk

00:00:45.880 --> 00:00:48.730
a little bit about the past,
a lot about the present,

00:00:48.730 --> 00:00:50.789
and then a bit about
the future where,

00:00:50.789 --> 00:00:52.330
for one of the few
times, we're going

00:00:52.330 --> 00:00:54.190
to give you a
glimpse of the space

00:00:54.190 --> 00:00:57.450
that we're trying
to go longer term.

00:00:57.450 --> 00:01:01.240
So in the past, we
have Doze and Standby.

00:01:01.240 --> 00:01:03.850
Doze and Doze Lite were
introduced to try and save

00:01:03.850 --> 00:01:06.520
battery in two main
conditions, one

00:01:06.520 --> 00:01:09.479
being when the device is off
for a long period of time.

00:01:09.479 --> 00:01:11.395
So a good example of
this is I take my tablet.

00:01:11.395 --> 00:01:14.820
I toss it in my desk, and it
sits there for a few days.

00:01:14.820 --> 00:01:17.540
And that, you really want the
device to last a long time.

00:01:17.540 --> 00:01:21.010
And Doze was introduced to make
that device last up to a week.

00:01:21.010 --> 00:01:23.860
And it was largely successful
when it was introduced.

00:01:23.860 --> 00:01:26.740
Doze Lite was trying to
take that same concept

00:01:26.740 --> 00:01:30.880
and apply that to my
phone is in my pocket.

00:01:30.880 --> 00:01:33.830
It's not on, but it is on me.

00:01:33.830 --> 00:01:35.784
And Doze wasn't
identifying that situation.

00:01:35.784 --> 00:01:37.450
And Doze Lite was
trying to target that.

00:01:37.450 --> 00:01:39.074
And it starts slowing
down applications

00:01:39.074 --> 00:01:41.560
and limiting what's
happening throughout the day.

00:01:41.560 --> 00:01:43.690
And app Standby was
very similar in concept,

00:01:43.690 --> 00:01:45.610
but had been about is
the user interacting

00:01:45.610 --> 00:01:47.080
with the application very often?

00:01:47.080 --> 00:01:50.590
And if not, begin
throttling that back.

00:01:50.590 --> 00:01:52.630
We also looked at
broadcast removal.

00:01:52.630 --> 00:01:55.270
And this was when we
targeted an initial set

00:01:55.270 --> 00:01:57.640
of three particular broadcasts.

00:01:57.640 --> 00:02:00.880
And the best example of
this was we were finding--

00:02:00.880 --> 00:02:04.450
you take a photo, and
suddenly all the applications

00:02:04.450 --> 00:02:07.027
are getting really
excited about that photo

00:02:07.027 --> 00:02:08.860
because they're listening
to that broadcast.

00:02:08.860 --> 00:02:10.389
And they would all be
waking up and going,

00:02:10.389 --> 00:02:11.680
what's going on with the photo?

00:02:11.680 --> 00:02:12.970
Is there a restaurant nearby?

00:02:12.970 --> 00:02:13.803
Should I back it up?

00:02:13.803 --> 00:02:14.650
What should happen?

00:02:14.650 --> 00:02:17.777
And the user's going, I'm really
just trying to take a photo.

00:02:17.777 --> 00:02:19.360
Like, god forbid
you're trying to take

00:02:19.360 --> 00:02:21.760
two photos, because the first
photo triggered everybody

00:02:21.760 --> 00:02:23.500
to wake up, and the
second photo is now

00:02:23.500 --> 00:02:25.330
this resource contention.

00:02:25.330 --> 00:02:27.880
And so we found this was really
successful to pull these guys

00:02:27.880 --> 00:02:30.820
back from being these general
broadcasts, and instead,

00:02:30.820 --> 00:02:32.290
being a bit more targeted.

00:02:32.290 --> 00:02:35.625
And so that's kind of the
lead-in to then the present,

00:02:35.625 --> 00:02:37.750
where we started looking
at then a general strategy

00:02:37.750 --> 00:02:39.054
for background limits.

00:02:39.054 --> 00:02:40.470
I'll also talk
about Alert Window,

00:02:40.470 --> 00:02:42.910
as well, which has a very
similar problem space,

00:02:42.910 --> 00:02:44.500
and then a bit about
how we're trying

00:02:44.500 --> 00:02:47.380
to bring a data-based
approach to improving

00:02:47.380 --> 00:02:49.210
system health on Android.

00:02:49.210 --> 00:02:51.190
I don't mean health
like my personal health,

00:02:51.190 --> 00:02:53.200
but more like the device health.

00:02:53.200 --> 00:02:56.650
And then I'll pepper
in a few best practices

00:02:56.650 --> 00:02:58.880
as we go through.

00:02:58.880 --> 00:03:01.690
So background limits, why?

00:03:01.690 --> 00:03:04.190
So what we're trying
to do is two parts.

00:03:04.190 --> 00:03:06.437
One is to save battery.

00:03:06.437 --> 00:03:08.020
This one was largely
around the limits

00:03:08.020 --> 00:03:09.580
that we put in
place for location.

00:03:09.580 --> 00:03:11.455
And the goal that
we're trying to get at

00:03:11.455 --> 00:03:13.990
is we want multi-day
battery life.

00:03:13.990 --> 00:03:16.420
That's what it's going to
take us a while to get there.

00:03:16.420 --> 00:03:18.220
But that's where
we're trying to go.

00:03:18.220 --> 00:03:22.390
And to do that, we know we have
a pretty large task in terms

00:03:22.390 --> 00:03:24.280
of what's happening
in the background.

00:03:24.280 --> 00:03:26.860
It's a nearly 6% to 8%
efficiency improvement

00:03:26.860 --> 00:03:28.510
from where we are today.

00:03:28.510 --> 00:03:30.900
And so that's like the
backdrop, if you will,

00:03:30.900 --> 00:03:32.580
of how we're thinking about it.

00:03:32.580 --> 00:03:34.510
And these are the
initial steps in setting

00:03:34.510 --> 00:03:37.490
the framework for how
we're going to get there.

00:03:37.490 --> 00:03:39.640
The other part is
about RAM management

00:03:39.640 --> 00:03:43.780
and working on how broadcasts
are being fired to applications

00:03:43.780 --> 00:03:45.880
and also dealing
with how applications

00:03:45.880 --> 00:03:49.700
are running in the background
with long-running services.

00:03:49.700 --> 00:03:52.290
So just to give you a
concrete example of this

00:03:52.290 --> 00:03:54.920
is you have this chart
of screen-off performance

00:03:54.920 --> 00:03:55.854
over time.

00:03:55.854 --> 00:03:57.520
And the one thing you
can see up there--

00:03:57.520 --> 00:03:58.853
I can't see my monitors anymore.

00:03:58.853 --> 00:04:00.527
The sun has totally
killed me up here.

00:04:00.527 --> 00:04:02.110
But the one thing
you can see up there

00:04:02.110 --> 00:04:04.450
is over time,
you're going to have

00:04:04.450 --> 00:04:07.140
a slide of your screen-off
battery performance

00:04:07.140 --> 00:04:09.130
the longer the phone
is in the field.

00:04:09.130 --> 00:04:13.030
You'll also see that the jank
rates, or slow UI frames,

00:04:13.030 --> 00:04:15.767
get higher the longer the
device is in the field.

00:04:15.767 --> 00:04:17.350
And so these are
things that we really

00:04:17.350 --> 00:04:20.260
want to help remedy and add
robustness into the platform

00:04:20.260 --> 00:04:22.360
so we can really
smooth these out.

00:04:22.360 --> 00:04:23.890
Obviously, over
time devices age,

00:04:23.890 --> 00:04:26.770
and physics comes into play,
and the march of time happens.

00:04:26.770 --> 00:04:29.830
But we really don't want them
to be anywhere near that steep.

00:04:29.830 --> 00:04:33.640
Another example of this is as
a device is on, in the course

00:04:33.640 --> 00:04:37.300
of even days-- this one's
measured all initially hours

00:04:37.300 --> 00:04:38.260
and then in days--

00:04:38.260 --> 00:04:41.284
you can see just uptime starts
to take a toll on the device.

00:04:41.284 --> 00:04:43.450
And so these are the things
that we're really trying

00:04:43.450 --> 00:04:45.586
to target and to improve.

00:04:45.586 --> 00:04:47.710
So let's dig in a little
bit to some of the changes

00:04:47.710 --> 00:04:49.210
that we're introducing.

00:04:49.210 --> 00:04:51.580
Background limits
on the Save RAM part

00:04:51.580 --> 00:04:53.830
is we want to restrict
services and broadcasts.

00:04:53.830 --> 00:04:56.110
And we want to reduce
the amount of churn

00:04:56.110 --> 00:04:57.610
that's happening on the device.

00:04:57.610 --> 00:04:59.230
And the Save Battery,
we're looking

00:04:59.230 --> 00:05:03.030
to improve background location
scan rates and Wi-Fi scan rates

00:05:03.030 --> 00:05:05.639
and to reduce them and make
them be more of a trickle

00:05:05.639 --> 00:05:07.680
than these really bursty
events that we're seeing

00:05:07.680 --> 00:05:11.100
happening in the ecosystem.

00:05:11.100 --> 00:05:13.320
So for background
limits, the big one

00:05:13.320 --> 00:05:15.090
here is we want to
reduce that RAM usage.

00:05:15.090 --> 00:05:17.249
And to do that is--

00:05:17.249 --> 00:05:18.540
well, that slide like the same.

00:05:18.540 --> 00:05:20.420
I should just skip.

00:05:20.420 --> 00:05:23.250
So how we're doing that is
with broadcast receivers.

00:05:23.250 --> 00:05:26.180
By pulling these guys back,
you're able to then say, OK.

00:05:26.180 --> 00:05:27.960
Oh, all these
broadcasts before that

00:05:27.960 --> 00:05:29.730
were implicit in
waking up applications

00:05:29.730 --> 00:05:30.780
are going to be silenced.

00:05:30.780 --> 00:05:33.570
If you're running at the moment,
you're still going to get them.

00:05:33.570 --> 00:05:35.280
But if you're not
currently running,

00:05:35.280 --> 00:05:37.738
we're not going to wake you up
for them, except in the case

00:05:37.738 --> 00:05:38.840
where they're explicit.

00:05:38.840 --> 00:05:41.070
And explicit ones, we say
something really important

00:05:41.070 --> 00:05:42.653
has happened, or
you've been targeted,

00:05:42.653 --> 00:05:44.562
or you've registered
for some wake up.

00:05:44.562 --> 00:05:46.770
And those things will still
work completely as normal

00:05:46.770 --> 00:05:48.370
as they did before.

00:05:48.370 --> 00:05:51.257
And so that follows like
alarms and notifications.

00:05:51.257 --> 00:05:53.090
Other ones that we're
still keeping around--

00:05:53.090 --> 00:05:55.470
BOOT_COMPLETED, LOCALE_CHANGING.

00:05:55.470 --> 00:05:57.420
And these are really
events that are not

00:05:57.420 --> 00:06:01.027
happening as the user is
trying to do something else.

00:06:01.027 --> 00:06:02.610
And that's really
been a target of how

00:06:02.610 --> 00:06:04.609
we approach which things
should continue to work

00:06:04.609 --> 00:06:07.120
and which things should
we start deferring.

00:06:07.120 --> 00:06:10.020
The other one here is free
running background services

00:06:10.020 --> 00:06:12.330
should no longer be a thing.

00:06:12.330 --> 00:06:14.790
And the idea behind
that is we want

00:06:14.790 --> 00:06:16.980
users to have
visibility to what's

00:06:16.980 --> 00:06:18.077
happening on their phone.

00:06:18.077 --> 00:06:20.160
And so if an application
is doing something really

00:06:20.160 --> 00:06:21.790
expensive in the
background, we want

00:06:21.790 --> 00:06:23.460
there to be some
awareness for the user.

00:06:23.460 --> 00:06:26.001
We don't want the device to be
toiling away in the background

00:06:26.001 --> 00:06:27.660
without any awareness.

00:06:27.660 --> 00:06:29.370
This also means we
want to then start

00:06:29.370 --> 00:06:30.911
stopping those
services after they're

00:06:30.911 --> 00:06:32.600
running for a little bit.

00:06:32.600 --> 00:06:34.350
We're going to start
throwing an exception

00:06:34.350 --> 00:06:36.432
if you start a background
service when you're not

00:06:36.432 --> 00:06:38.640
in the foreground or when
you don't have a foreground

00:06:38.640 --> 00:06:39.624
service running.

00:06:39.624 --> 00:06:41.040
And this is also
the very last one

00:06:41.040 --> 00:06:43.164
is we're start releasing
wake locks under some more

00:06:43.164 --> 00:06:43.682
conditions.

00:06:43.682 --> 00:06:45.390
You still want to
manage your wake locks.

00:06:45.390 --> 00:06:47.431
Don't think the OS is
going to handle it for you.

00:06:47.431 --> 00:06:49.260
But we are adding
more protections

00:06:49.260 --> 00:06:51.780
in different scenarios where
they might have been leaked

00:06:51.780 --> 00:06:56.176
or the developer was a
little lax in their cleanup.

00:06:56.176 --> 00:06:58.800
We still have the white listing
strategy that we've had before.

00:06:58.800 --> 00:07:00.960
So there will still
be a white listing

00:07:00.960 --> 00:07:01.980
strategy that is around.

00:07:01.980 --> 00:07:06.150
When GCM fires off a
broadcast to your application,

00:07:06.150 --> 00:07:07.560
you'll still get woken up.

00:07:07.560 --> 00:07:10.225
You'll get a short exemption
to handle that message.

00:07:10.225 --> 00:07:11.850
From there, you can
kick off a service.

00:07:11.850 --> 00:07:13.975
You could bring your
applications to the foreground

00:07:13.975 --> 00:07:15.180
if it's appropriate.

00:07:15.180 --> 00:07:18.780
Or you can just take a note,
run it, schedule a job or alarm

00:07:18.780 --> 00:07:23.100
and have it be scheduled by the
OS and happen when it happens.

00:07:23.100 --> 00:07:25.050
There's also the
flexibility, still, for OEMs

00:07:25.050 --> 00:07:27.120
if you're relying on
some OEM-specific intent

00:07:27.120 --> 00:07:30.400
or something behavior that's not
built into AOSP, Android Open

00:07:30.400 --> 00:07:30.900
Source.

00:07:30.900 --> 00:07:33.135
The OEM will be able
to define on their own

00:07:33.135 --> 00:07:35.760
which things are explicit, which
things are implicit and should

00:07:35.760 --> 00:07:38.600
still be fired, and which things
are implicit and should still

00:07:38.600 --> 00:07:41.770
get the brakes tapped on them.

00:07:41.770 --> 00:07:45.020
So you might be thinking
at this point, this all--

00:07:45.020 --> 00:07:46.440
I guess, the user
part of my brain

00:07:46.440 --> 00:07:48.480
is really happy, probably.

00:07:48.480 --> 00:07:50.370
The developer side
is going, wait.

00:07:50.370 --> 00:07:51.330
I have things to do.

00:07:51.330 --> 00:07:52.290
I have things to say.

00:07:52.290 --> 00:07:54.840
How can I communicate
to the developer?

00:07:54.840 --> 00:07:56.640
It's really important, Ben.

00:07:56.640 --> 00:07:57.850
What are you doing?

00:07:57.850 --> 00:07:59.460
And so there's a
number of strategies,

00:07:59.460 --> 00:08:01.130
and I'll talk about
them right now

00:08:01.130 --> 00:08:03.420
of how to do these
operations still

00:08:03.420 --> 00:08:05.347
with the user on a
timely basis and still

00:08:05.347 --> 00:08:06.930
be respectful of the
battery, but then

00:08:06.930 --> 00:08:08.790
also be able to tell
the user, no, I'm

00:08:08.790 --> 00:08:10.720
doing something
incredibly important.

00:08:10.720 --> 00:08:14.980
So the first one to look at is
using Firebase in Google Cloud

00:08:14.980 --> 00:08:17.440
Messaging and using
the high-priority and

00:08:17.440 --> 00:08:21.060
normal-priority messages I hope
your takeaway from this slide

00:08:21.060 --> 00:08:24.774
is not fire all torpedoes
at high priority.

00:08:24.774 --> 00:08:26.940
We really want you to be
kind of balanced and saying

00:08:26.940 --> 00:08:30.870
if something is important, like,
say, my fire alarm is going off

00:08:30.870 --> 00:08:33.831
at home, and I want to send
a notification to the user,

00:08:33.831 --> 00:08:35.205
use a high-priority
notification.

00:08:35.205 --> 00:08:37.020
It's kind of a big deal.

00:08:37.020 --> 00:08:40.320
If you're, say, using a, oh, the
user's scheduled for a TV show

00:08:40.320 --> 00:08:43.440
that they like, and that
TV show is now available,

00:08:43.440 --> 00:08:45.550
and they can stream
it at their leisure,

00:08:45.550 --> 00:08:47.160
use a normal-priority
notification.

00:08:47.160 --> 00:08:49.560
And it'll make a big
difference in the battery

00:08:49.560 --> 00:08:50.744
life of the device.

00:08:50.744 --> 00:08:52.410
And it really adds
up when the ecosystem

00:08:52.410 --> 00:08:55.050
starts taking these approaches.

00:08:55.050 --> 00:08:56.880
The other one here
is something new.

00:08:56.880 --> 00:08:58.650
It's called the Job
Intense Service.

00:08:58.650 --> 00:09:00.120
And this is coming out.

00:09:00.120 --> 00:09:02.070
We just missed the
window, but I still

00:09:02.070 --> 00:09:05.687
wanted to talk about it for what
came out with the new 26 beta.

00:09:05.687 --> 00:09:07.770
But it will be coming out
shortly before O launch.

00:09:07.770 --> 00:09:11.610
And it's a strategy of you can
use Job Intense Service on O

00:09:11.610 --> 00:09:13.380
to give you backwards
compat support

00:09:13.380 --> 00:09:16.800
so that you will use then
Jobs when you're on O.

00:09:16.800 --> 00:09:18.750
And you'll have an
automatic fallback

00:09:18.750 --> 00:09:20.582
to using services pre-O.

00:09:20.582 --> 00:09:23.040
The really nice part about this
when you have that fallback

00:09:23.040 --> 00:09:24.666
is we'll handle the
wake locks for you.

00:09:24.666 --> 00:09:27.206
So you don't have to worry about
are you going to make a leak

00:09:27.206 --> 00:09:28.470
or make a mistake there.

00:09:28.470 --> 00:09:30.636
So definitely take a look
at this when it comes out.

00:09:30.636 --> 00:09:33.900
It's going to make your
lives a lot easier to adopt.

00:09:33.900 --> 00:09:36.120
The other one here is
about alarms, syncs,

00:09:36.120 --> 00:09:38.130
and job scheduling.

00:09:38.130 --> 00:09:43.080
These are all good strategies
to run Jobs on a cadence

00:09:43.080 --> 00:09:46.260
in the background that gives
the OS flexibility about when

00:09:46.260 --> 00:09:47.140
it runs.

00:09:47.140 --> 00:09:49.980
So as easy an example,
if all these applications

00:09:49.980 --> 00:09:53.110
before when we had a world of
these broadcasts being fired,

00:09:53.110 --> 00:09:55.140
and then applications
could start services,

00:09:55.140 --> 00:09:57.060
they'll all start
at the same time.

00:09:57.060 --> 00:10:00.540
And the OS really has only
nukes to deal with this problem.

00:10:00.540 --> 00:10:02.750
We can only kill your process.

00:10:02.750 --> 00:10:04.130
There's no ability to throttle.

00:10:04.130 --> 00:10:05.750
We can't try to squish RAM.

00:10:05.750 --> 00:10:07.670
It's just you live or you die.

00:10:07.670 --> 00:10:09.290
And when the RAM
becomes contentious,

00:10:09.290 --> 00:10:12.080
we start thrashing
pretty rapidly.

00:10:12.080 --> 00:10:13.940
When you're using
Jobs and Alarms,

00:10:13.940 --> 00:10:16.550
the OS has now
flexibility to defer,

00:10:16.550 --> 00:10:18.620
to run one job at a time,
a few times at a time,

00:10:18.620 --> 00:10:21.410
and spread it out across
the lifetime of the device.

00:10:21.410 --> 00:10:24.040
And that avoids then
resource contention.

00:10:24.040 --> 00:10:26.300
It avoids janky UI
in the foreground

00:10:26.300 --> 00:10:28.920
because stuff is happening
in the background.

00:10:28.920 --> 00:10:32.050
So I've made this really
exciting flowchart for you

00:10:32.050 --> 00:10:33.720
that you can look at later.

00:10:33.720 --> 00:10:35.706
But the idea behind
it is roughly

00:10:35.706 --> 00:10:37.580
looking at what are the
different stages that

00:10:37.580 --> 00:10:40.580
are happening and what is
the right choice for you

00:10:40.580 --> 00:10:44.300
as a developer and for the
user to have that be the best,

00:10:44.300 --> 00:10:46.990
most efficient experience
for the use case

00:10:46.990 --> 00:10:48.590
that you're trying to achieve.

00:10:48.590 --> 00:10:51.620
Yes, the end of this is
maybe you shouldn't do it

00:10:51.620 --> 00:10:52.690
in the background.

00:10:52.690 --> 00:10:55.530
And that's the one I really want
you to focus on is think about

00:10:55.530 --> 00:10:57.350
do I really have
to be doing this?

00:10:57.350 --> 00:11:01.250
Is the user going to understand
what I'm trying to do?

00:11:01.250 --> 00:11:02.912
If the user is
going to understand

00:11:02.912 --> 00:11:05.120
what you're trying to do,
and a great example of this

00:11:05.120 --> 00:11:07.970
are like navigation
apps, music-playing apps,

00:11:07.970 --> 00:11:13.017
various exercise applications,
all of those scenarios,

00:11:13.017 --> 00:11:14.600
if you're running a
foreground service

00:11:14.600 --> 00:11:16.730
and the user sees
a notification,

00:11:16.730 --> 00:11:18.170
it's going to make
sense to them.

00:11:18.170 --> 00:11:19.795
You're going to be
really well aligned.

00:11:19.795 --> 00:11:21.700
So in those scenarios,
please go do that.

00:11:21.700 --> 00:11:23.150
In other ones where
you're like, I

00:11:23.150 --> 00:11:25.020
don't know how to
explain this to a user,

00:11:25.020 --> 00:11:26.960
then you should definitely
be considering Jobs

00:11:26.960 --> 00:11:28.501
or just be considering
not running it

00:11:28.501 --> 00:11:30.770
in the background at all.

00:11:30.770 --> 00:11:33.020
So transitioning now, that
was the battery saving

00:11:33.020 --> 00:11:33.990
and executions portion.

00:11:33.990 --> 00:11:35.823
And now I'm going to
transition a little bit

00:11:35.823 --> 00:11:37.520
to talk about location limits.

00:11:37.520 --> 00:11:39.680
And the idea here was
to put some upper bounds

00:11:39.680 --> 00:11:41.680
on what we're seeing
happening in the background

00:11:41.680 --> 00:11:43.640
around geofencing,
polling, and others.

00:11:43.640 --> 00:11:47.480
And it was causing really a
significant amount of drain.

00:11:47.480 --> 00:11:50.000
And the reason is
location is power-hungry.

00:11:50.000 --> 00:11:52.940
And there were really
no functional limits

00:11:52.940 --> 00:11:54.980
on what an application
could do when

00:11:54.980 --> 00:11:57.650
it's in the background
with respect to location.

00:11:57.650 --> 00:12:00.840
And so it would end up with two
different types of scenarios.

00:12:00.840 --> 00:12:03.400
And most of them, to be
honest, are accidental,

00:12:03.400 --> 00:12:05.360
one being is that
applications are aggressively

00:12:05.360 --> 00:12:07.190
requesting location.

00:12:07.190 --> 00:12:09.165
And this could be
because they're

00:12:09.165 --> 00:12:11.540
interested in where you are
or they have a particular use

00:12:11.540 --> 00:12:12.040
case.

00:12:12.040 --> 00:12:16.280
But the one that was really
sad was this idea of leaks,

00:12:16.280 --> 00:12:18.389
is that if you're running
in the foreground,

00:12:18.389 --> 00:12:20.180
say you're navigating,
you're going to have

00:12:20.180 --> 00:12:22.055
a really high rate of query.

00:12:22.055 --> 00:12:23.900
And when you go
to the background,

00:12:23.900 --> 00:12:26.630
that high rate maybe
isn't necessary anymore.

00:12:26.630 --> 00:12:29.286
And the intention of the
developer was to reduce it.

00:12:29.286 --> 00:12:31.410
But for one reason or
another, similar memory leaks

00:12:31.410 --> 00:12:34.032
or wake lock leaks, it's
still running full blast.

00:12:34.032 --> 00:12:35.990
And that we saw a lot,
of a lot of applications

00:12:35.990 --> 00:12:39.114
polling at every second
getting a location request.

00:12:39.114 --> 00:12:41.280
And that's just going to
completely destroy battery.

00:12:41.280 --> 00:12:44.520
And so those are the two areas
we're trying to target here.

00:12:44.520 --> 00:12:46.104
So the idea now is
not to say that you

00:12:46.104 --> 00:12:48.103
can't run in the background,
because we're still

00:12:48.103 --> 00:12:48.960
enabling that.

00:12:48.960 --> 00:12:51.890
But the idea is to space it
out, once every 30 minutes,

00:12:51.890 --> 00:12:54.140
with a cycle of accuracy
of two to three minutes

00:12:54.140 --> 00:12:56.492
within those 30-minute updates.

00:12:56.492 --> 00:12:58.700
So you can think of it as
you have a 30-minute delay,

00:12:58.700 --> 00:13:01.220
roughly, with then
an update accuracy

00:13:01.220 --> 00:13:04.299
of two to three minutes
within that 30-minute cycle.

00:13:04.299 --> 00:13:05.840
The same thing will
apply with Wi-Fi.

00:13:05.840 --> 00:13:07.170
The API is a little
bit different.

00:13:07.170 --> 00:13:09.020
We don't have that kind of
convenience for scheduling.

00:13:09.020 --> 00:13:10.394
But the idea is
if you're banging

00:13:10.394 --> 00:13:12.440
on the Wi-Fi scanning
query, you'll

00:13:12.440 --> 00:13:14.900
keep getting the same results
if you're going too fast.

00:13:14.900 --> 00:13:16.592
We won't actually do the query.

00:13:16.592 --> 00:13:18.050
And so those are
the two strategies

00:13:18.050 --> 00:13:21.200
that we've taken for
location and for Wi-Fi.

00:13:21.200 --> 00:13:23.480
So just to highlight, there's
a number of options here

00:13:23.480 --> 00:13:25.200
that are a lower
battery impacting

00:13:25.200 --> 00:13:26.480
that you should be looking at.

00:13:26.480 --> 00:13:29.390
One is batching, geofencing.

00:13:29.390 --> 00:13:31.587
And in the complete
last case, again,

00:13:31.587 --> 00:13:33.170
is to consider the
foreground service.

00:13:33.170 --> 00:13:35.180
If you are using the
foreground service and the user

00:13:35.180 --> 00:13:37.370
understands what's
happening-- that's really kind

00:13:37.370 --> 00:13:38.379
of critical--

00:13:38.379 --> 00:13:40.670
but if they understand what's
happening, that will then

00:13:40.670 --> 00:13:42.050
enable them to
say, oh, OK, yeah,

00:13:42.050 --> 00:13:42.920
you're running in
the background.

00:13:42.920 --> 00:13:43.910
You're expensive.

00:13:43.910 --> 00:13:46.300
I get it, moving on.

00:13:46.300 --> 00:13:48.770
And you'll have
relaxed requirements

00:13:48.770 --> 00:13:51.150
when you're in that mode.

00:13:51.150 --> 00:13:53.390
So the other thing I wanted
to talk about a moment--

00:13:53.390 --> 00:13:54.680
I know it feels like
all about battery,

00:13:54.680 --> 00:13:56.870
and then suddenly, I'm
talking about Alert Window,

00:13:56.870 --> 00:13:58.490
but I wanted to take
a moment to talk

00:13:58.490 --> 00:14:00.684
about it-- is there's
a number of use cases

00:14:00.684 --> 00:14:01.850
that this is coming up with.

00:14:01.850 --> 00:14:05.030
And to be brutally
honest with you,

00:14:05.030 --> 00:14:07.640
this was only intended
for what the name is--

00:14:07.640 --> 00:14:09.810
System Alert Windows.

00:14:09.810 --> 00:14:12.230
It was never really
consciously intended to be

00:14:12.230 --> 00:14:13.980
used the way that it has been.

00:14:13.980 --> 00:14:16.970
But we were in a simpler
world, an API one.

00:14:16.970 --> 00:14:18.440
And it was left public.

00:14:18.440 --> 00:14:22.520
And people have found really
amazing ideas and solutions

00:14:22.520 --> 00:14:23.877
using this API.

00:14:23.877 --> 00:14:25.460
And so we don't want
to get rid of it.

00:14:25.460 --> 00:14:28.390
However, we do want to
try and put it on rails.

00:14:28.390 --> 00:14:30.980
What we're really worried
about is many applications

00:14:30.980 --> 00:14:33.930
rendering on top of each other,
conflicting with each other.

00:14:33.930 --> 00:14:35.960
There's no attribution
of what applications

00:14:35.960 --> 00:14:38.410
happen to be rendering
at any point in time.

00:14:38.410 --> 00:14:41.360
And so the idea was that
can we add some layering?

00:14:41.360 --> 00:14:43.880
Can we add some attribution
within the model?

00:14:43.880 --> 00:14:46.300
And that's what we did with
the application overlay.

00:14:46.300 --> 00:14:48.710
And so the idea here
is with an app overlay

00:14:48.710 --> 00:14:50.990
is the user can
now manage what is

00:14:50.990 --> 00:14:54.560
floating above their
application activity.

00:14:54.560 --> 00:14:57.470
It's Z-ord, Z-ordered
properly unto themselves

00:14:57.470 --> 00:15:00.630
and to system UI and to
the application below.

00:15:00.630 --> 00:15:03.850
And it will automatically
show a foreground notification

00:15:03.850 --> 00:15:05.570
in the notification
menus, so the user

00:15:05.570 --> 00:15:08.570
is aware if there are multiple
applications simultaneously

00:15:08.570 --> 00:15:10.670
using this feature.

00:15:10.670 --> 00:15:12.944
This way, if they see it,
they're unhappy with it,

00:15:12.944 --> 00:15:15.110
they can go to the application,
control the settings

00:15:15.110 --> 00:15:15.791
if they want.

00:15:15.791 --> 00:15:17.540
You should always make
sure your users are

00:15:17.540 --> 00:15:20.165
aware of using this, because it
can be kind of surprising if it

00:15:20.165 --> 00:15:21.430
doesn't happen.

00:15:21.430 --> 00:15:24.160
And the other thing that we
changed was for targeting on O

00:15:24.160 --> 00:15:27.380
is if you are now using
this new overlay type,

00:15:27.380 --> 00:15:30.280
you will then sit
above the legacy views.

00:15:30.280 --> 00:15:32.330
So this is maybe your
incentive to adopt

00:15:32.330 --> 00:15:34.730
the new model, is once
you're using that, everybody

00:15:34.730 --> 00:15:38.240
will be properly Z-ordered
in a kind of LRU fashion.

00:15:38.240 --> 00:15:40.850
And then you'll sit
below system UI,

00:15:40.850 --> 00:15:43.670
but above things like the
keyboard and other system UI

00:15:43.670 --> 00:15:45.874
components.

00:15:45.874 --> 00:15:47.540
So now I want to
transition a little bit

00:15:47.540 --> 00:15:49.456
about talking about how
we're going to improve

00:15:49.456 --> 00:15:50.810
the system with data.

00:15:50.810 --> 00:15:54.020
And I don't mean
to blame anyone,

00:15:54.020 --> 00:15:56.540
because that's not my intent.

00:15:56.540 --> 00:15:59.060
But it's really a story
about applications

00:15:59.060 --> 00:16:00.950
and that phones are amazing.

00:16:00.950 --> 00:16:03.391
And you can do so many things
with this portable computing

00:16:03.391 --> 00:16:03.890
device.

00:16:03.890 --> 00:16:07.510
However, we have
resource scarcity, mostly

00:16:07.510 --> 00:16:08.669
in the frame of battery.

00:16:08.669 --> 00:16:10.460
And the question that
comes up, well, then,

00:16:10.460 --> 00:16:12.140
how do we balance this?

00:16:12.140 --> 00:16:14.025
And the big thing
that we realized,

00:16:14.025 --> 00:16:15.650
and you might be
thinking at your seat,

00:16:15.650 --> 00:16:17.300
like, yeah, no, duh, thanks.

00:16:17.300 --> 00:16:19.760
But there really isn't great
tooling up until very recently

00:16:19.760 --> 00:16:22.470
to help developers
understand their impact.

00:16:22.470 --> 00:16:24.660
And when we reached out
even internally at Google,

00:16:24.660 --> 00:16:28.460
we would find they didn't
realize they were doing it.

00:16:28.460 --> 00:16:31.020
And so that kind of brought
around a number of thoughts

00:16:31.020 --> 00:16:32.767
that I'll get into in a moment.

00:16:32.767 --> 00:16:35.100
And the other one is this
kind of tragedy of the commons

00:16:35.100 --> 00:16:37.980
in that you have so many
applications on your phone.

00:16:37.980 --> 00:16:42.380
And if any of those applications
say, stick a wake lock,

00:16:42.380 --> 00:16:43.640
you only need one to do it.

00:16:43.640 --> 00:16:46.430
And the cost is now your CPU
is unable to go to sleep,

00:16:46.430 --> 00:16:48.290
and you'll have a
very precipitous drain

00:16:48.290 --> 00:16:50.070
on your battery over time.

00:16:50.070 --> 00:16:52.340
And when you have hundreds
of apps and only one needs

00:16:52.340 --> 00:16:54.350
to make a mistake,
you're pretty much

00:16:54.350 --> 00:16:56.300
guaranteed to have a bad time.

00:16:56.300 --> 00:16:58.010
And so what we
started looking at

00:16:58.010 --> 00:17:01.250
is how can we get to a point
of sustaining performance,

00:17:01.250 --> 00:17:03.770
introducing accurate
measurements for developers,

00:17:03.770 --> 00:17:06.710
and bring online new dashboards?

00:17:06.710 --> 00:17:09.349
So let's dig in a little
bit into what these are.

00:17:09.349 --> 00:17:11.010
And there's a talk
on bad behaviors.

00:17:11.010 --> 00:17:12.109
It was earlier in the day.

00:17:12.109 --> 00:17:14.630
If you haven't seen it, please
go hop on YouTube and go

00:17:14.630 --> 00:17:15.380
take a look at it.

00:17:15.380 --> 00:17:16.255
It's very, very good.

00:17:16.255 --> 00:17:18.760
The guys that presented
are right here in front

00:17:18.760 --> 00:17:19.346
staring at me.

00:17:19.346 --> 00:17:19.887
This is good.

00:17:19.887 --> 00:17:20.780
Thank you.

00:17:20.780 --> 00:17:23.599
But the big one here is we're
looking for egregious behavior

00:17:23.599 --> 00:17:25.160
that we can all agree on.

00:17:25.160 --> 00:17:27.740
And so a good example
of this is wake locks,

00:17:27.740 --> 00:17:31.070
is if you ask a developer,
you are holding a wake lock

00:17:31.070 --> 00:17:33.154
for six hours straight.

00:17:33.154 --> 00:17:34.820
You were in the
foreground, and the user

00:17:34.820 --> 00:17:36.860
wasn't interacting
with your application.

00:17:36.860 --> 00:17:39.530
And pretty much
everybody says, yeah, I

00:17:39.530 --> 00:17:41.120
shouldn't have been doing that.

00:17:41.120 --> 00:17:43.219
And so the trick, though,
is there wasn't really

00:17:43.219 --> 00:17:45.010
good instrumentation
to help you understand

00:17:45.010 --> 00:17:46.010
that that was happening.

00:17:46.010 --> 00:17:49.574
And that's where the Play
console is coming into its own

00:17:49.574 --> 00:17:51.490
and bringing out these
features so you can now

00:17:51.490 --> 00:17:54.210
see these type of situations
that are happening.

00:17:54.210 --> 00:17:56.750
Other big one has
been really severely

00:17:56.750 --> 00:17:58.760
janking frames,
so frozen frames.

00:17:58.760 --> 00:18:00.915
Frames take over 700
milliseconds to run.

00:18:00.915 --> 00:18:03.290
Also, really hard to figure
out where in your application

00:18:03.290 --> 00:18:04.100
they're occurring.

00:18:04.100 --> 00:18:06.433
And even if they're occurring,
and if they're occurring,

00:18:06.433 --> 00:18:08.190
what devices they're
occurring on.

00:18:08.190 --> 00:18:10.648
And then the last one was around
crash looping and a number

00:18:10.648 --> 00:18:12.355
of other crash states.

00:18:12.355 --> 00:18:14.480
The other one is we're also
looking at the OS side.

00:18:14.480 --> 00:18:16.220
Not to say that
everything is about apps.

00:18:16.220 --> 00:18:17.210
It's not.

00:18:17.210 --> 00:18:19.880
We do have to bring a level
of sanity and attribution

00:18:19.880 --> 00:18:20.960
to the operating system.

00:18:20.960 --> 00:18:23.072
One good example of that
was the improvements

00:18:23.072 --> 00:18:24.530
we made to the boot
time and really

00:18:24.530 --> 00:18:26.549
looking hard at how
the OS is structured.

00:18:26.549 --> 00:18:28.340
And the other one is
also going be starting

00:18:28.340 --> 00:18:30.867
looking at I/O
throughput, how many scans

00:18:30.867 --> 00:18:33.200
are happening in the background
in different parameters.

00:18:33.200 --> 00:18:35.366
And all these things will
start coming out and being

00:18:35.366 --> 00:18:37.770
available for you guys
over the coming years.

00:18:37.770 --> 00:18:39.620
So just to give you
an example of this,

00:18:39.620 --> 00:18:41.660
I have a selection
of Google Apps.

00:18:41.660 --> 00:18:43.700
I have hidden the
names to protect

00:18:43.700 --> 00:18:46.310
the innocent slash guilty.

00:18:46.310 --> 00:18:48.984
But what I have put up
there is a hash line.

00:18:48.984 --> 00:18:50.900
And the hash line is
effectively the threshold

00:18:50.900 --> 00:18:52.358
that you're going
to see of when we

00:18:52.358 --> 00:18:54.530
say an application has
crossed into the territory

00:18:54.530 --> 00:18:56.489
of bad behavior.

00:18:56.489 --> 00:18:58.280
So you can see the
majority of applications

00:18:58.280 --> 00:18:59.196
in this cross-section.

00:18:59.196 --> 00:19:01.070
And these are all
major Google Apps.

00:19:01.070 --> 00:19:02.420
Most of them are quite good.

00:19:02.420 --> 00:19:05.030
And there's a few outliers
that are having issues

00:19:05.030 --> 00:19:07.689
where a wake lock is getting
stuck in their applications.

00:19:07.689 --> 00:19:09.230
And you can see the
percentages here.

00:19:09.230 --> 00:19:10.049
They look small.

00:19:10.049 --> 00:19:11.840
But when you see these
numbers of like half

00:19:11.840 --> 00:19:15.260
a percent here, 1% there,
those are just one app.

00:19:15.260 --> 00:19:17.150
And as I mentioned
before, only one app

00:19:17.150 --> 00:19:20.270
needs to make this mistake for
your entire device to suffer.

00:19:20.270 --> 00:19:21.950
Multiply that by the 100 apps.

00:19:21.950 --> 00:19:24.010
If you working out
the ratio, you're

00:19:24.010 --> 00:19:25.940
going to have a bad time.

00:19:25.940 --> 00:19:28.190
The next one here was talking
about foreground crashes

00:19:28.190 --> 00:19:30.350
and helping our
developers understand

00:19:30.350 --> 00:19:32.060
repeat crashes,
repeat offenders,

00:19:32.060 --> 00:19:33.519
rapid crashing in a cycle.

00:19:33.519 --> 00:19:35.060
We generally had
good instrumentation

00:19:35.060 --> 00:19:37.640
to help developers understand
if you crash, but not necessary

00:19:37.640 --> 00:19:41.110
the severity of repeated
crashes versus sporadic crashes.

00:19:41.110 --> 00:19:44.340
Do I have a population of 5%
crashing really extremely,

00:19:44.340 --> 00:19:47.930
or does it really spread
across a population 95%?

00:19:47.930 --> 00:19:50.510
And the very last one here
is about frozen frames.

00:19:50.510 --> 00:19:52.790
And you can see another
example of most applications

00:19:52.790 --> 00:19:54.150
are actually doing pretty good.

00:19:54.150 --> 00:19:58.180
And in this case, there was one
who was a little not as good.

00:19:58.180 --> 00:20:00.340
And when we passed this
data along to the team,

00:20:00.340 --> 00:20:03.959
they're like, crap, [CHUCKLES]
not their intent, obviously.

00:20:03.959 --> 00:20:05.375
But it really makes
the experience

00:20:05.375 --> 00:20:07.422
of the device not
really that fantastic,

00:20:07.422 --> 00:20:08.630
especially their application.

00:20:08.630 --> 00:20:09.830
And it makes the users
go on there, like,

00:20:09.830 --> 00:20:10.700
is my device wrong?

00:20:10.700 --> 00:20:11.360
Is the app bad?

00:20:11.360 --> 00:20:12.147
What's happening?

00:20:12.147 --> 00:20:14.230
So giving this information
back to the developers,

00:20:14.230 --> 00:20:16.313
and they're able to start
remedying these problems

00:20:16.313 --> 00:20:18.510
and solving them.

00:20:18.510 --> 00:20:20.240
So the big thing
here is visibility.

00:20:20.240 --> 00:20:22.230
And this is visibility
both for you guys

00:20:22.230 --> 00:20:25.200
as well as for the
user on their device.

00:20:25.200 --> 00:20:27.380
So in new developer
tools, we're also

00:20:27.380 --> 00:20:29.690
doing a lot of outreach, both
internally and externally

00:20:29.690 --> 00:20:32.789
with Biz Dev to reach out to
teams and inform them, hey,

00:20:32.789 --> 00:20:34.580
do you know this is
happening on your apps?

00:20:34.580 --> 00:20:35.792
And in many cases, we don't.

00:20:35.792 --> 00:20:37.250
And it's an easy,
it's a quick fix,

00:20:37.250 --> 00:20:39.170
and especially when it
comes to wake clocks.

00:20:39.170 --> 00:20:40.878
It's usually a fairly
straightforward fix

00:20:40.878 --> 00:20:44.300
once you know which wake lock
is the one that's been stuck.

00:20:44.300 --> 00:20:46.820
And the last ones here is
battery settings in the Play

00:20:46.820 --> 00:20:48.240
Store, and I'll talk a
little bit about that,

00:20:48.240 --> 00:20:49.906
and then OEM dashboards,
because we also

00:20:49.906 --> 00:20:51.650
want to get this data
over to OEM so they

00:20:51.650 --> 00:20:52.650
can see what's going on.

00:20:52.650 --> 00:20:55.610
And they can make sure that
devices are intrinsically good

00:20:55.610 --> 00:20:57.590
and that you have a
strong base to work on,

00:20:57.590 --> 00:21:00.080
that you're not seeing jank
because of the device freaking

00:21:00.080 --> 00:21:02.780
out, but you're having
a good experience

00:21:02.780 --> 00:21:05.960
and that you have the ability
to control your own destiny.

00:21:05.960 --> 00:21:09.120
So Battery Menu
on here is about--

00:21:09.120 --> 00:21:10.430
this is the new O Battery Menu.

00:21:10.430 --> 00:21:12.320
And it was redesigned
with the idea

00:21:12.320 --> 00:21:14.420
of being actionable for users.

00:21:14.420 --> 00:21:16.800
We wanted to make sure that
if you go to this menu,

00:21:16.800 --> 00:21:21.800
you don't go, OK, I see Google
Play Services, the Settings,

00:21:21.800 --> 00:21:24.130
Android OS, and screen.

00:21:24.130 --> 00:21:27.475
Like, what am I supposed
to think if I see this?

00:21:27.475 --> 00:21:29.100
There's really nothing
actionable here.

00:21:29.100 --> 00:21:31.970
And while it was
technically accurate,

00:21:31.970 --> 00:21:34.400
it wasn't necessarily useful
to what you're trying to do,

00:21:34.400 --> 00:21:36.800
is to understand
what applications are

00:21:36.800 --> 00:21:38.370
impacting your battery life.

00:21:38.370 --> 00:21:39.890
So this is how we
restructured it.

00:21:39.890 --> 00:21:43.820
And we also included, though,
your foreground's interaction

00:21:43.820 --> 00:21:45.140
with those applications.

00:21:45.140 --> 00:21:47.515
And this is something that
happens really quite commonly.

00:21:47.515 --> 00:21:49.930
And I'll give you just
a quick anecdote from--

00:21:49.930 --> 00:21:51.470
internally, I had
a bug filed to me.

00:21:51.470 --> 00:21:53.450
And it was about
Android O battery life.

00:21:53.450 --> 00:21:54.170
It's horrible.

00:21:54.170 --> 00:21:55.910
I don't make it past 3 o'clock.

00:21:55.910 --> 00:21:57.080
What's going on?

00:21:57.080 --> 00:21:59.010
And, you know, dig
into the bug report,

00:21:59.010 --> 00:22:00.020
look at what's going on.

00:22:00.020 --> 00:22:01.700
And what happened
on their device

00:22:01.700 --> 00:22:07.070
was they were playing "Pokemon
Go" for two hours on Thursday

00:22:07.070 --> 00:22:09.260
at 1:00 PM.

00:22:09.260 --> 00:22:11.985
And my reply was like
that's pretty amazing

00:22:11.985 --> 00:22:13.610
that you got this
much battery life out

00:22:13.610 --> 00:22:16.250
of "Pokemon Go" on your phone.

00:22:16.250 --> 00:22:20.120
Also, it was Thursday
at 1:00 PM, Googler.

00:22:20.120 --> 00:22:22.400
But the thing was
that it took away

00:22:22.400 --> 00:22:26.790
was they didn't realize
they played it that long.

00:22:26.790 --> 00:22:28.486
And so that was
happening quite often.

00:22:28.486 --> 00:22:30.110
You'd see an app be
high battery drain.

00:22:30.110 --> 00:22:31.776
But you don't necessarily
recognize, oh,

00:22:31.776 --> 00:22:34.760
it was because I used my phone
like an extra hour today.

00:22:34.760 --> 00:22:36.360
And it's hard to
remember how long did

00:22:36.360 --> 00:22:37.460
I really have the screen on.

00:22:37.460 --> 00:22:39.335
And so that's how we
really structure battery

00:22:39.335 --> 00:22:41.855
is to help inform you of how
long you're using the device,

00:22:41.855 --> 00:22:43.730
how long you're using
different applications,

00:22:43.730 --> 00:22:48.040
and so that you can make
this comparison of what

00:22:48.040 --> 00:22:49.310
is happening in the apps.

00:22:49.310 --> 00:22:52.130
We don't want to pass judgment
on an application being

00:22:52.130 --> 00:22:53.130
good or bad.

00:22:53.130 --> 00:22:55.280
It's not necessarily
a bad thing if an app

00:22:55.280 --> 00:22:56.960
uses 20% of your battery.

00:22:56.960 --> 00:22:59.090
If you were
live-streaming an event,

00:22:59.090 --> 00:23:02.040
that's pretty decent, especially
if it was for an hour or two.

00:23:02.040 --> 00:23:03.770
So we're not trying to say
intrinsically things are

00:23:03.770 --> 00:23:04.603
bad if they're high.

00:23:04.603 --> 00:23:06.410
But we do want to add
some visibility so

00:23:06.410 --> 00:23:08.300
that a user can see
this is an app I

00:23:08.300 --> 00:23:11.060
didn't engage with for days.

00:23:11.060 --> 00:23:13.244
Why is it taking up
5% of my battery?

00:23:13.244 --> 00:23:14.660
And then those
questions can start

00:23:14.660 --> 00:23:17.076
happening on the users' part
and giving you guys feedback.

00:23:17.076 --> 00:23:20.730
And then you can see the same
data in the Play console.

00:23:20.730 --> 00:23:22.280
So this is where
I will transition

00:23:22.280 --> 00:23:24.860
to talking a little
bit about the future

00:23:24.860 --> 00:23:27.650
so you can kind of get an
idea of where we're going.

00:23:27.650 --> 00:23:29.690
This is also my
suggestion to really

00:23:29.690 --> 00:23:32.000
look at background limits,
to look at targeting O,

00:23:32.000 --> 00:23:34.250
to transitioning away
from background services

00:23:34.250 --> 00:23:37.820
to Jobs, Alarms, GCM, et cetera.

00:23:37.820 --> 00:23:41.540
And the thing is we want to get
to this amazing battery life

00:23:41.540 --> 00:23:45.000
that I started out with,
multi-day battery life.

00:23:45.000 --> 00:23:47.000
And to do that, there's
a few things we're going

00:23:47.000 --> 00:23:49.590
to have to change, if you will.

00:23:49.590 --> 00:23:51.990
But I want to talk
about some principles.

00:23:51.990 --> 00:23:55.100
One is we fundamentally
believe applications should be

00:23:55.100 --> 00:23:57.860
able to run in the background.

00:23:57.860 --> 00:24:00.170
We want much more
well-defined rules

00:24:00.170 --> 00:24:03.590
about when applications
are able to run.

00:24:03.590 --> 00:24:05.444
Today, you can see
a number of OEMs

00:24:05.444 --> 00:24:06.860
taking strategies,
trying to solve

00:24:06.860 --> 00:24:08.274
this problem independently.

00:24:08.274 --> 00:24:10.190
And it becomes really
difficult for developers

00:24:10.190 --> 00:24:12.941
to deal with that world
when you don't necessarily

00:24:12.941 --> 00:24:13.940
know what the rules are.

00:24:13.940 --> 00:24:16.290
So we want to get a
lot crisper there.

00:24:16.290 --> 00:24:20.240
We also want users to better
understand battery impact.

00:24:20.240 --> 00:24:22.670
You could argue my previous
statements about the Settings

00:24:22.670 --> 00:24:24.294
menu where it's like,
what the user has

00:24:24.294 --> 00:24:26.940
to do math in their head about
how much time that it used

00:24:26.940 --> 00:24:28.177
or how much battery it used?

00:24:28.177 --> 00:24:29.510
And I agree with you completely.

00:24:29.510 --> 00:24:31.093
We want to get to a
better place where

00:24:31.093 --> 00:24:34.299
it's much easier for a user to
understand what's happening.

00:24:34.299 --> 00:24:35.840
And we want to then
enable a user who

00:24:35.840 --> 00:24:39.350
says, I'm not OK with this,
and if the application doesn't

00:24:39.350 --> 00:24:41.660
offer the control, to
give them another option

00:24:41.660 --> 00:24:44.660
than uninstalling the
application, something other

00:24:44.660 --> 00:24:46.244
than just the nuclear option.

00:24:46.244 --> 00:24:47.660
And then the last
one is we really

00:24:47.660 --> 00:24:50.960
want this idea of consistent
device performance,

00:24:50.960 --> 00:24:53.420
that you shouldn't be worrying,
will my device make it

00:24:53.420 --> 00:24:54.800
through the day today or not?

00:24:54.800 --> 00:24:57.050
Will it be able to make it
till I get home on charger?

00:24:57.050 --> 00:25:00.110
We want that to be
something reliable.

00:25:00.110 --> 00:25:02.240
All these use cases that
we're doing on phones,

00:25:02.240 --> 00:25:03.500
and all the properties
from Google,

00:25:03.500 --> 00:25:04.916
and all the
properties that you're

00:25:04.916 --> 00:25:07.640
making as app developers, you
can't really rely on this stuff

00:25:07.640 --> 00:25:09.740
unless you know your
phone's going to be there.

00:25:09.740 --> 00:25:11.750
And so that's really
the underpinnings

00:25:11.750 --> 00:25:14.050
for this general strategy.

00:25:14.050 --> 00:25:15.860
And so how do we get there?

00:25:15.860 --> 00:25:19.100
So there's three big tiers
is we have to consider,

00:25:19.100 --> 00:25:20.990
what is the API contract?

00:25:20.990 --> 00:25:24.980
We don't want to break the
promises we make to you.

00:25:24.980 --> 00:25:29.060
However, we do make a lot of
promises that we later regret.

00:25:29.060 --> 00:25:31.700
And so an example of
this is a wake lock.

00:25:31.700 --> 00:25:34.400
And if you were to generally
describe a wake lock,

00:25:34.400 --> 00:25:38.000
you're saying, we've given the
application-- any application,

00:25:38.000 --> 00:25:40.720
can tell the OS, stay
awake until I say

00:25:40.720 --> 00:25:43.370
to go to sleep indefinitely.

00:25:43.370 --> 00:25:45.060
And when you give
that level of control

00:25:45.060 --> 00:25:48.360
and there's not really
a way to close the loop,

00:25:48.360 --> 00:25:50.502
you end up with
varying battery life.

00:25:50.502 --> 00:25:51.960
And so we have to
figure out, then,

00:25:51.960 --> 00:25:54.529
what is the right promise
to make to a developer?

00:25:54.529 --> 00:25:56.070
And what is the
range of that promise

00:25:56.070 --> 00:25:57.111
that we should be giving.

00:25:57.111 --> 00:25:58.860
So enable. the use
cases, but make sure

00:25:58.860 --> 00:26:01.200
that the OS can be
responsive in the face

00:26:01.200 --> 00:26:03.540
of adversity or
many applications

00:26:03.540 --> 00:26:06.306
taking advantage of the
promise that's being made.

00:26:06.306 --> 00:26:07.680
The other one is
that attribution

00:26:07.680 --> 00:26:09.600
that I mentioned before
and the controls so

00:26:09.600 --> 00:26:11.130
that the user can then take
advantage of this stuff.

00:26:11.130 --> 00:26:12.870
And together, the
three of these things

00:26:12.870 --> 00:26:15.150
should give us a much
a better structure.

00:26:15.150 --> 00:26:17.490
And so all of this
is, again, like you

00:26:17.490 --> 00:26:20.190
see this little exciting badge
of a pending review on there.

00:26:20.190 --> 00:26:21.900
These are really just
ideas to articulate

00:26:21.900 --> 00:26:24.060
how we're approaching
the problem, because we

00:26:24.060 --> 00:26:25.500
know it's a big change.

00:26:25.500 --> 00:26:28.560
And so we're trying to broadcast
this change really early so you

00:26:28.560 --> 00:26:29.730
can take advantage of it.

00:26:29.730 --> 00:26:31.980
You can start moving
over to background limits

00:26:31.980 --> 00:26:34.740
and targeting O now so
that you're not going

00:26:34.740 --> 00:26:37.026
to have a bad time later on.

00:26:37.026 --> 00:26:38.400
And so some of
these things is we

00:26:38.400 --> 00:26:41.855
need to look at more limits
on background scanning.

00:26:41.855 --> 00:26:44.170
We have to adjust the
limits that we're doing.

00:26:44.170 --> 00:26:46.404
We haven't really gotten
around to Bluetooth yet.

00:26:46.404 --> 00:26:47.820
We're also looking
at applications

00:26:47.820 --> 00:26:50.040
listening to other
events on the device

00:26:50.040 --> 00:26:52.980
and whether those things
should be happening or not.

00:26:52.980 --> 00:26:54.930
The big one here
is deferring work.

00:26:54.930 --> 00:26:57.330
We want the OS to
have more flexibility

00:26:57.330 --> 00:27:00.180
to have discretion
about when jobs run.

00:27:00.180 --> 00:27:03.580
When it's all services-based,
the OS has really no control.

00:27:03.580 --> 00:27:05.400
If a single large
install-based application

00:27:05.400 --> 00:27:08.790
makes a unilateral decision to
increase its wake lock time,

00:27:08.790 --> 00:27:11.820
the OS today and the user
is powerless to do anything

00:27:11.820 --> 00:27:12.320
about it.

00:27:12.320 --> 00:27:14.736
And so that's why we're looking
to make these transitions.

00:27:14.736 --> 00:27:16.380
And the balance
should be, now, users

00:27:16.380 --> 00:27:18.930
are more in the
driver's seat about what

00:27:18.930 --> 00:27:20.490
features the
application's giving

00:27:20.490 --> 00:27:22.920
and whether the user finds
value in those features running

00:27:22.920 --> 00:27:25.299
in the background, and then
they can articulate that.

00:27:25.299 --> 00:27:27.090
The defaults for all
of these things is on.

00:27:27.090 --> 00:27:28.548
And the model you
can roughly think

00:27:28.548 --> 00:27:31.080
about it as long as you're
cool, the OS will be cool.

00:27:31.080 --> 00:27:33.701
And everybody will be
cool, and it's great.

00:27:33.701 --> 00:27:35.575
And if in this scenario,
though, applications

00:27:35.575 --> 00:27:37.908
start getting aggressive,
batteries starts getting high,

00:27:37.908 --> 00:27:39.540
scanning rates start
getting higher,

00:27:39.540 --> 00:27:43.410
we may start informing the user,
hey, this stuff's kind of heavy

00:27:43.410 --> 00:27:44.310
on your battery.

00:27:44.310 --> 00:27:46.650
Do you want it to run
in the background?

00:27:46.650 --> 00:27:49.590
And then they can articulate
take back to the OS.

00:27:49.590 --> 00:27:52.590
And then we can begin having
a control surface for how we

00:27:52.590 --> 00:27:54.390
manage individual applications.

00:27:54.390 --> 00:27:55.980
And so then the user
can say, these 10

00:27:55.980 --> 00:27:58.110
apps I care about a lot.

00:27:58.110 --> 00:27:59.466
These other apps, not so much.

00:27:59.466 --> 00:28:00.840
We're not suggesting
that we need

00:28:00.840 --> 00:28:02.130
to have a micro-managing menu.

00:28:02.130 --> 00:28:03.046
That's not the desire.

00:28:03.046 --> 00:28:05.250
But using things like
how users are interacting

00:28:05.250 --> 00:28:07.867
with the application, how
often are interacting with GCM

00:28:07.867 --> 00:28:09.700
messages when the
application gets woken up,

00:28:09.700 --> 00:28:12.040
how often do they interact
with notifications,

00:28:12.040 --> 00:28:13.740
these are all great
signals to inform

00:28:13.740 --> 00:28:17.340
how the OS should dole out
its limited resources, namely

00:28:17.340 --> 00:28:19.140
battery.

00:28:19.140 --> 00:28:21.930
And the last one is we have to
beef up the idea of foreground

00:28:21.930 --> 00:28:25.470
service and figure out how
does that as an API surface

00:28:25.470 --> 00:28:27.570
and how does that as
a UI construct not

00:28:27.570 --> 00:28:29.760
turn into all the
applications rushing

00:28:29.760 --> 00:28:31.680
to the exits of
foreground service.

00:28:31.680 --> 00:28:33.600
And then we're back
in the same mess

00:28:33.600 --> 00:28:35.860
that we are now with no
control surface again.

00:28:35.860 --> 00:28:38.460
We want to find a balance so
that applications can generally

00:28:38.460 --> 00:28:40.810
do everything they need
and that in the extremes,

00:28:40.810 --> 00:28:42.750
the user's able to
articulate approval

00:28:42.750 --> 00:28:44.040
for these extreme situations.

00:28:44.040 --> 00:28:45.456
And we're hoping
that that's going

00:28:45.456 --> 00:28:48.450
to result in a much more stable,
much more reliable device

00:28:48.450 --> 00:28:49.660
in the long run.

00:28:49.660 --> 00:28:52.200
And so hopefully, that
gives you a bit of insight

00:28:52.200 --> 00:28:55.150
about how we're approaching
Android health and mostly

00:28:55.150 --> 00:28:59.725
the battery life and
resource contention.

00:28:59.725 --> 00:29:01.440
Oh, I forgot a slide.

00:29:01.440 --> 00:29:04.110
But the idea here in the last
one was attribution and value.

00:29:04.110 --> 00:29:06.320
And so we want to really
make that identified.

00:29:06.320 --> 00:29:07.861
And I already talked
about the point,

00:29:07.861 --> 00:29:10.670
so I won't bore
you repeating it.

00:29:10.670 --> 00:29:13.745
And thank you very
much for your time.

00:29:13.745 --> 00:29:14.245
Thanks.

00:29:14.245 --> 00:29:17.640
[APPLAUSE]

00:29:19.095 --> 00:29:23.570
[MUSIC PLAYING]

