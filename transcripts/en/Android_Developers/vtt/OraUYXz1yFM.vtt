WEBVTT
Kind: captions
Language: en

00:06:55.820 --> 00:06:57.820
Coming up next: Getting the Most

00:14:14.444 --> 00:14:15.899
Out of Android Lint by Matthew 
Gharrity  SPEAKER: Howdy, 

00:14:15.900 --> 00:14:18.593
welcome to another Android 
developer summit!  So how many 

00:14:18.594 --> 00:14:20.594
people went to the last

00:14:23.922 --> 00:14:26.982
one?
How many people enjoyed the last

00:14:26.983 --> 00:14:30.480
one? We liked it here, which is 
why we did it immediately again 

00:14:30.825 --> 00:14:36.209
three years later.  We were just
building suspense to make it 

00:14:36.468 --> 00:14:39.622
extra special.  Hopefully we can
do it again.  A lot of this 

00:14:40.199 --> 00:14:43.331
content, all of the -- most of 
the content is live streamed, 

00:14:43.605 --> 00:14:47.708
all of it is being recorded.  If
you prefer consuming this 

00:14:47.979 --> 00:14:50.388
through a live stream, I can 
pause occasionally and buffer 

00:14:50.650 --> 00:14:53.994
and maybe that will make it more
of a live stream situation for 

00:14:54.153 --> 00:14:56.153
you.  I'm Che it, I

00:14:58.811 --> 00:15:06.621
-- Chet, I lead the toolkit 
team, I'm emceeing today.  And I

00:15:06.622 --> 00:15:10.500
am making it a nice enough 
event, but short enough so you 

00:15:10.501 --> 00:15:14.610
are not tired of the emcee.  I 
will tell you how this thing is 

00:15:14.611 --> 00:15:19.008
going to work today.
So Dan went over some of it, and

00:15:19.009 --> 00:15:24.130
I assumed you went over the 
keynotes as much as I do.

00:15:24.131 --> 00:15:28.627
The most important to me is 
office hours, there are two 

00:15:28.957 --> 00:15:32.842
reasons why we like to have 
these events in Mountain View, 

00:15:33.246 --> 00:15:35.582
it is such an interesting city 
with so much to do, we live 

00:15:35.792 --> 00:15:39.383
here, and every day we are here.
So obviously, Mountain View, for

00:15:39.384 --> 00:15:42.188
the culture.
And the second reason is Google 

00:15:42.341 --> 00:15:45.520
is just up the street, which 
means we can drag a lot of 

00:15:45.811 --> 00:15:47.986
engineers from the team that 
build all of the bugs that you 

00:15:48.491 --> 00:15:50.740
are now dealing with into the 
product, and we like to bring 

00:15:51.074 --> 00:15:53.562
them into the conference to help
answer all of your questions.  

00:15:53.765 --> 00:15:56.425
The key thing for you to know, 
though, is all of those people 

00:15:56.698 --> 00:16:00.012
aren't here all day.
We have broken up the event into

00:16:00.327 --> 00:16:02.631
four half-day sessions, and 
there are different people in 

00:16:03.123 --> 00:16:05.456
different teams in different 
technoloies represented at 

00:16:05.758 --> 00:16:08.085
different times.
And so there are three scheduled

00:16:08.736 --> 00:16:12.400
posted, there are screens around
the conference.  This is one of 

00:16:12.401 --> 00:16:16.199
the screen sscreens, if you 
can't read this, maybe you can 

00:16:16.200 --> 00:16:21.201
read the screens outside the 
room instead.  There's a 

00:16:21.202 --> 00:16:26.705
rotating schedule, will tell you
when people are on where, if you

00:16:26.706 --> 00:16:32.542
have a question for the location
team, make sure you are at the 

00:16:32.710 --> 00:16:36.500
right time.  You can skip 
sessions if you want, they are 

00:16:36.768 --> 00:16:40.618
recorded, and there are people 
in all of those sessions.  So 

00:16:40.881 --> 00:16:42.881
ask the right questions, find 

00:16:47.087 --> 00:16:50.720
people, they are here at the 
right time.  There's App Review 

00:16:53.041 --> 00:16:57.911
clinices, there's the hashtag on
Twitter, #AndroidDevSummit, 

00:16:57.912 --> 00:17:04.888
there's the  application.  And 
if you don't have it, it is an 

00:17:04.889 --> 00:17:07.875
instant app.  Do your favorite 
search in the search engine, 

00:17:08.138 --> 00:17:14.953
click on the link if  -- for the
instant app and it downloads 

00:17:15.330 --> 00:17:18.446
instantly.  There's a party 
tonight after the session after 

00:17:18.646 --> 00:17:21.439
6:00, that will kick in, a party
with a bunch of engineers, where

00:17:21.698 --> 00:17:24.918
we all have the excellent 
experience of talking to each 

00:17:25.338 --> 00:17:28.931
other while the DJ is playing 
the loud music and having 

00:17:29.151 --> 00:17:32.357
conversations that go along the 
lines of, what!  What!

00:17:32.358 --> 00:17:35.723
Enjoy the party, enjoy those 
deep conversations with the new 

00:17:36.077 --> 00:17:39.224
friends, that's about it.  And 
one more thing, there are three 

00:17:39.658 --> 00:17:42.121
different session links.  
There's the long session, 40 

00:17:42.122 --> 00:17:44.955
minutes.  There are shorter 
sessions of 20 minutes.  The 

00:17:45.197 --> 00:17:48.361
intention is to link these 
things, you will go for both of 

00:17:48.740 --> 00:17:51.730
them at one slot.  It is awkward
to get up in the middle of a 

00:17:52.004 --> 00:17:54.765
crowd, so we are about to see 
two in a middle here.  Please 

00:17:55.254 --> 00:17:58.597
stick around for both of them, 
if you need to get to one on the

00:17:58.598 --> 00:18:01.282
other side, try to do so quickly
and quietly, we are going to 

00:18:01.452 --> 00:18:04.770
roll from one into the other.  
And then there's lightning talks

00:18:05.042 --> 00:18:09.245
that start at 12:05 and will run
for an hour, those are going to 

00:18:09.494 --> 00:18:11.505
go back to back into each other.
So stick around for 

00:18:17.616 --> 00:18:19.616
those.
And that is about it.  I'm 

00:18:19.700 --> 00:18:22.647
standing in the way between you 
and technical content.  I would 

00:18:22.998 --> 00:18:27.933
like to bring up Matthew 
Gharrity to talk about Lint.  

00:18:28.336 --> 00:18:30.336
Thanks.

00:18:37.184 --> 00:18:39.184
[ Applause ]

00:18:42.487 --> 00:18:45.397
MATTHEW GHARRITY: 
All right, let's get started.

00:18:45.753 --> 00:18:51.261
I'm Matthew, on the Android 
Studio team, I work on project 

00:18:51.522 --> 00:18:53.522
stability, call integration, and
we will go to the

00:19:02.347 --> 00:19:04.347
next slide.

00:19:11.605 --> 00:19:17.828
And one of the most exciting 
things I get to work on besides 

00:19:18.661 --> 00:19:21.294
project stability is Android 
lint.  It is a very powerful 

00:19:21.295 --> 00:19:24.441
tool, you know a lot about it, 
but you might not know the cool 

00:19:24.730 --> 00:19:27.639
things it can do.
So despite the name, it is not 

00:19:28.256 --> 00:19:32.115
just a linting-tool, it is a 
full-fledged stack analytics 

00:19:32.291 --> 00:19:36.234
framework, it is powerful, you 
can write your own checks and I 

00:19:36.527 --> 00:19:38.527
will talk about

00:19:44.177 --> 00:19:46.177
that today.
No

00:19:51.693 --> 00:19:55.130
worries.
This talk is really for anyone 

00:19:55.612 --> 00:20:00.286
really interested in programming
languages, compilers, stack 

00:20:00.588 --> 00:20:02.985
analysis, and for anyone that 
has to deal with bugs in the 

00:20:03.401 --> 00:20:05.401
project.  So that is for most

00:20:13.355 --> 00:20:15.355
of you.

00:20:17.676 --> 00:20:21.628
Yeah, one last thing, I only 
have 20 minutes, there's a lot 

00:20:21.629 --> 00:20:24.070
of material, I will go fast 
through the slides.  Try to keep

00:20:24.308 --> 00:20:27.712
up.  At the end of the day, you 
can watch it in half speed on 

00:20:28.279 --> 00:20:30.279
YouTube and get a sense of it 

00:20:36.313 --> 00:20:38.313
then.

00:21:47.604 --> 00:21:50.169
Perfect.
 All right, let's get started.

00:21:51.309 --> 00:21:56.053
So what is Android lint? A lot 
of you probably already  know, 

00:21:56.212 --> 00:21:59.772
if you don't know the name, you 
know what Android lint is.  It 

00:21:59.967 --> 00:22:02.843
shows up in the IDE saying that 
you did something wrong.  In 

00:22:02.844 --> 00:22:05.786
some cases, it is like telling 
you that Gradle is out of date, 

00:22:06.083 --> 00:22:08.313
do you want to update it, or 
maybe you are not calling a 

00:22:08.684 --> 00:22:12.735
super method in a method that 
expects you to do so.  In 

00:22:13.205 --> 00:22:16.631
Android Studio, in the IDE, it 
will say that there is 

00:22:16.914 --> 00:22:19.900
suspicious code, take a look.  
Sometimes there are warnings, 

00:22:20.183 --> 00:22:23.596
sometimes there are errors that 
will fail the builds.

00:22:23.597 --> 00:22:26.114
So some of you might not know 
it, there's a lot of the ways to

00:22:26.391 --> 00:22:29.559
use Android Lint.  The first is 
on-the-fly, that I just 

00:22:30.059 --> 00:22:32.752
mentioned, in the IDE as you are
typing, shows the error messages

00:22:33.012 --> 00:22:36.345
right away.  You can also do 
inspect code, this is an action 

00:22:36.602 --> 00:22:40.656
in Android Studio where you can 
run a batch analysis of the 

00:22:40.927 --> 00:22:44.286
project, a good way to audit 
your project for common errors. 

00:22:44.545 --> 00:22:46.800
And an action called run 
inspection by name.  If you have

00:22:47.097 --> 00:22:52.406
a particular bug in mind, say 
you want to find a lot of thread

00:22:54.297 --> 00:22:56.761
annotation violations, you can 
run the inspection by name, run 

00:22:57.046 --> 00:23:00.352
the entire projects in one batch
analysis and look through those 

00:23:01.122 --> 00:23:05.970
one pie  by one.  You can run 
Lint on the command line with 

00:23:06.638 --> 00:23:11.359
Gradle, Gradle Lint debug, it 
will do a batch analysis for the

00:23:11.360 --> 00:23:16.004
project.  And the great thing 
about that is it will make an 

00:23:16.282 --> 00:23:23.714
html and XML report.  You can 
parse the XML report, or you can

00:23:24.701 --> 00:23:27.755
do the html report and do the 
warnings.

00:23:27.756 --> 00:23:32.216
If you know what Lint is, I want
to dive into the advanced use 

00:23:32.486 --> 00:23:35.788
cases, because it is a powerful 
tool.  I will talk about 

00:23:35.789 --> 00:23:38.018
configuration, and it is 
actually really important.  For 

00:23:38.019 --> 00:23:41.465
big projects, you want to make 
sure that Android Lint is 

00:23:41.755 --> 00:23:43.835
working for your projects and 
needs.  I will talk about 

00:23:44.107 --> 00:23:47.187
annotations, it is a powerful 
way to mark up your code to help

00:23:49.855 --> 00:23:52.619
Lint help you more.  Lint does 
as much as it can, but sometimes

00:23:52.896 --> 00:23:56.122
you need to give it hints to 
help you more.  We will talk 

00:23:56.123 --> 00:23:58.905
about Lint internals, I'm 
excited about this, I want to 

00:23:58.906 --> 00:24:02.121
give you a good mental model for
how it works under the hood.  

00:24:02.910 --> 00:24:08.720
This will get you set up for 
kind of realizing how powerful a

00:24:08.721 --> 00:24:16.841
tool it is and writing your 
customcustom Lint chuck schecks.

00:24:17.080 --> 00:24:19.449
We will talk about 
configuration.  The easiest way 

00:24:19.450 --> 00:24:23.424
to see what Lint is capable of, 
Android Studio, preferences, 

00:24:24.282 --> 00:24:26.745
inspections window.
You will see the heading, Lint, 

00:24:27.059 --> 00:24:31.770
and all of the inspections that 
lint  has.  There are are 

00:24:32.148 --> 00:24:37.294
hundreds, most are enabled by 
default.  There are some  that 

00:24:37.899 --> 00:24:41.308
are not, and take a look at 
them, some of them may apply to 

00:24:41.309 --> 00:24:44.730
your project, even though we 
don't enable them by default.  

00:24:46.790 --> 00:24:49.517
One example is call 
interoperability, this is a set 

00:24:49.518 --> 00:24:54.572
of checks we created so you can 
call it from link code and vice 

00:24:54.906 --> 00:25:00.021
versa.  If you do something that
makes it difficult, Lint will 

00:25:00.626 --> 00:25:03.241
tell you to re-name the function
so it is easy to call from the 

00:25:03.541 --> 00:25:07.914
other language.  There is 
another way to configure Lint, 

00:25:07.915 --> 00:25:12.535
with Gradle.  If you go into the
Build.gradle file, you have this

00:25:12.820 --> 00:25:18.307
Android block, as you know.  You
can write a Lint options block, 

00:25:18.567 --> 00:25:20.512
and there are powerful options 
here.

00:25:20.513 --> 00:25:25.387
So this first option, I will go 
through a few examples.  This 

00:25:25.657 --> 00:25:29.418
first option is a powerful tool,
if you have a big project, you 

00:25:29.419 --> 00:25:34.379
want to pay attention to this.  
The Lint baseline, when you add 

00:25:34.646 --> 00:25:38.278
this to your options, Lint will 
look at all of the warnings and 

00:25:38.851 --> 00:25:40.851
errors you currently have in the
project.  And this will give you

00:25:41.022 --> 00:25:44.899
a clean slate, so you can say, 
hey, I want to take a baseline 

00:25:44.900 --> 00:25:47.513
of this point of the project, 
forget about all of the 

00:25:47.781 --> 00:25:51.714
thousands of warnings that I 
already have.  And I only want 

00:25:52.124 --> 00:25:54.559
to look at new warnings and 
errors and new code that checks 

00:25:54.975 --> 00:25:58.293
it.  And this will help you get 
a handle on the massive amount 

00:25:58.619 --> 00:26:01.648
of code that you have so you can
have clean code going forward.  

00:26:01.649 --> 00:26:04.670
When you have more time, free 
time, you can knack  go back and

00:26:05.405 --> 00:26:11.256
look at the baseline issues that
Lint stashed away.  Once you 

00:26:11.951 --> 00:26:16.311
have a clean slate, through a 
baseline, or you want to do a 

00:26:16.464 --> 00:26:19.334
new project, you want to say, I 
want to have clean code forever,

00:26:19.335 --> 00:26:23.770
starting now, you can turn on 
warnings as errors.  I encourage

00:26:24.048 --> 00:26:27.166
you to try it out.  And if you 
want clean code, try to get this

00:26:27.459 --> 00:26:31.563
to work for you.  And then, like
in the last slide, you can 

00:26:31.948 --> 00:26:37.597
enable specific checks that are 
not on by default, like 

00:26:37.598 --> 00:26:42.527
interopability.  Some of you may
have this Lint options block set

00:26:42.963 --> 00:26:45.846
up.  And some more advanced 
things I want to talk about is 

00:26:46.201 --> 00:26:50.247
performance issues.
  So one of the reasons we have 

00:26:50.248 --> 00:26:54.299
this lint  Lint options block is
a lot of people run Lint on the 

00:26:55.455 --> 00:26:57.689
continuous integration server, 
they are checking the 

00:26:58.301 --> 00:27:01.654
application for warnings, 
errors, they block Lint submit 

00:27:01.655 --> 00:27:04.782
if you have it checked in.  And 
some people are concerned with 

00:27:04.783 --> 00:27:07.224
performance.
So just a few tips here, real 

00:27:07.529 --> 00:27:10.821
quick.
Try to avoid the check all 

00:27:11.296 --> 00:27:14.317
warnings option, I know it is 
tempting.  I know I told you to 

00:27:14.318 --> 00:27:17.245
enable more checks, but some of 
the checks are off by default 

00:27:18.360 --> 00:27:20.742
for performance reasons, for 
example.  If you check all the 

00:27:21.016 --> 00:27:24.592
warnings, man, my time to check 
the project just doubled.  Be 

00:27:25.320 --> 00:27:27.320
more selective in the checks 
that you

00:27:31.330 --> 00:27:37.593
turn on.
 Also avoid the Gradle lint 

00:27:37.594 --> 00:27:43.586
tasks, it is a parent task of 
Lint debug or release.  It will 

00:27:43.587 --> 00:27:48.506
run it multiple times on the 
project in each Lint variance, 

00:27:48.782 --> 00:27:54.630
that's a simple gotcha to avoid.
  Use the ignore test sources 

00:27:54.905 --> 00:27:57.685
function.  By default, we don't 
look at the test sources for 

00:27:57.897 --> 00:28:01.725
warnings or errors, the theory 
that you don't care about how 

00:28:02.355 --> 00:28:07.284
clean your tests are.  But this 
option makes it so you don't 

00:28:07.285 --> 00:28:10.924
parse your test sources at all. 
So presumably, all of you have 

00:28:10.925 --> 00:28:15.627
well-tested code.  So this 
option will help with that, to 

00:28:15.940 --> 00:28:18.719
make things go faster.
  Let's switch gears a bit, I 

00:28:18.720 --> 00:28:23.642
want to talk about annotations. 
They are a really powerful way 

00:28:23.643 --> 00:28:27.776
to live Lint hints for specific 
issues that you want to look 

00:28:28.049 --> 00:28:31.198
for.
And so, I'm just going to go for

00:28:31.199 --> 00:28:35.046
a few examples, you know about 
the nullability annotations, you

00:28:35.336 --> 00:28:38.767
use it a lot in Java, you don't 
need them, it is built into the 

00:28:39.611 --> 00:28:41.611
language.
But we also have really 

00:28:41.800 --> 00:28:46.520
Android-specific annotations, 
that you should check out.  

00:28:46.521 --> 00:28:49.890
There's the required permission,
this is an interesting example, 

00:28:49.891 --> 00:28:54.324
we kind of annotate certain 
Android APIs with requires 

00:28:54.698 --> 00:28:59.799
permission, like the set 
wallpaper permission, and Lint 

00:28:59.800 --> 00:29:02.391
does analysis on the code that 
calls into the API, is the 

00:29:03.314 --> 00:29:05.964
program checking that they have 
this permission? If you don't, 

00:29:05.965 --> 00:29:08.541
we can worry, hey, it looks like
you have not checked you have 

00:29:09.334 --> 00:29:13.787
this permission, this may crash 
at runtime.  And this impacts 

00:29:14.181 --> 00:29:17.914
the users quite a bit.  There is
also one of my favorites, kind 

00:29:19.153 --> 00:29:22.283
of annotations, which is UI 
thread and worker thread 

00:29:22.662 --> 00:29:24.920
annotations, there's thread 
annotations in url.

00:29:24.921 --> 00:29:28.016
And these are really important, 
actually.

00:29:28.017 --> 00:29:32.959
So a lot of -- a big problem 
with application development is 

00:29:33.399 --> 00:29:37.554
a lot of UI frameworks require 
that you only up Tate the UI on 

00:29:37.555 --> 00:29:43.304
a single thread, the network 
thread, and everything else is 

00:29:43.677 --> 00:29:48.574
on background threads.  If it is
on the UI thread, it might 

00:29:48.575 --> 00:29:51.836
block, you will not see a crash 
report, the user is frustrated, 

00:29:52.038 --> 00:29:56.291
it is hard to track these 
issues.  We have these threat 

00:29:56.652 --> 00:29:59.856
annotations where we say these 
method should only be called on 

00:30:00.130 --> 00:30:04.889
the UI thread, or the worker 
thread.  And we have some 

00:30:05.119 --> 00:30:08.100
analyses.  So I will actually do
a demo of these analyses.  

00:30:08.101 --> 00:30:10.491
Hopefully that is set up.
So let's switch

00:30:22.485 --> 00:30:23.331
over.
Awesome.

00:30:23.332 --> 00:30:27.116
So I will go through an example.
This is just Kotlin, let's say 

00:30:27.382 --> 00:30:29.382
that we

00:30:30.731 --> 00:30:34.561
have a function, oh, the screen 
is black.  You're

00:30:39.165 --> 00:30:41.165
right.
It was there for a

00:30:49.114 --> 00:30:51.114
second.

00:31:13.414 --> 00:31:16.292
Awesome.  Let's get started.  We
have a function, update UI, this

00:31:16.582 --> 00:31:21.874
is run on the UI thread.  This 
is updating the user interface, 

00:31:21.875 --> 00:31:24.262
whatever you want, and the 
network request.  This is a 

00:31:24.583 --> 00:31:26.583
contrived 

00:31:30.097 --> 00:31:33.091
example.
And this does some stuff.

00:31:33.092 --> 00:31:35.092
All

00:31:37.183 --> 00:31:39.237
right, and unfortunately, 
someone decided to call a 

00:31:39.238 --> 00:31:41.528
network request from the update 
UI method.  So this is a 

00:31:41.815 --> 00:31:45.865
problem, as you can see.  There 
is no errors or warnings, and 

00:31:45.866 --> 00:31:49.346
studying this is hard to track 
down in general.  If you know 

00:31:49.717 --> 00:31:52.732
about the threat annotations, 
you can add the UI thread here, 

00:31:52.933 --> 00:31:57.966
you can add the worker thread 
annotation here.  And instance  

00:31:58.276 --> 00:32:01.134
instantly, Lint says you are 
making a worker request on the 

00:32:01.462 --> 00:32:05.456
UI thread, that freezes the UI, 
you don't want that.  So I 

00:32:05.779 --> 00:32:09.352
encourage you to use these.  And
you might think, this is a trite

00:32:10.223 --> 00:32:13.206
example.  This is too simple.  
In the application, we have the 

00:32:13.938 --> 00:32:17.471
UI method that calls the 
function, FU, and that function 

00:32:17.804 --> 00:32:19.974
calls something called bar, and 
then that bar function calls the

00:32:19.975 --> 00:32:23.443
network request.
There is just multiple layers of

00:32:23.444 --> 00:32:28.708
indirection here.  And you might
think that Lint cannot help us 

00:32:29.182 --> 00:32:33.035
here.  It can't be default, it 
for performance reasons, we 

00:32:33.528 --> 00:32:37.983
don't do advanced analyses.  We 
have an analysis for this.  I 

00:32:38.139 --> 00:32:40.828
will show you an example of 
that.  You can do run inspection

00:32:42.496 --> 00:32:45.346
by name.  The name of the 
inspection is called wrong 

00:32:45.627 --> 00:32:48.217
thread, and then 
interprocedural.  You select 

00:32:49.047 --> 00:32:56.450
that, select the scope, I will 
say module scope.  And bam, it 

00:32:56.711 --> 00:32:59.804
will find the path from Fu to 
bar to network request.  You 

00:33:00.186 --> 00:33:03.266
cannot see the error message 
right here, so I will copy it 

00:33:03.498 --> 00:33:09.371
for you.  I will remove the 
class names, you can see the 

00:33:09.981 --> 00:33:14.526
error message says, hey, you are
doing the UI, going to fu, bar, 

00:33:14.527 --> 00:33:16.978
the network request, that is 
annotated with worker thread and

00:33:17.225 --> 00:33:20.543
that is an issue.  Let's go back
to the slides.

00:33:20.544 --> 00:33:26.965
So please check that analysis is
off by default for -- it is 

00:33:27.493 --> 00:33:29.722
being performant and doing a 
program analysis, pretty 

00:33:29.974 --> 00:33:34.165
expensive.  Use it when you can,
try to see if you can find any 

00:33:34.488 --> 00:33:36.488
bugs in the application.
All

00:33:38.683 --> 00:33:41.290
right.
NERBS  next I will talk about 

00:33:41.847 --> 00:33:46.259
Lint internals.  This part is 
really cool.

00:33:46.260 --> 00:33:50.574
The way Lint works, it starts 
out parsing a source file, so 

00:33:50.883 --> 00:33:54.782
you have some Java or Kotlin 
laying around, it builds 

00:33:55.908 --> 00:33:58.531
abstracts syntax tree, and then 
we wrap

00:34:01.803 --> 00:34:06.414
it in UST, universal Syntax 
Tree, and this may sound pretty 

00:34:06.680 --> 00:34:10.121
familiar.  And this step is 
really important because it 

00:34:10.419 --> 00:34:12.557
means that when you write a 
check, you only have to write it

00:34:14.017 --> 00:34:17.621
once, it works in both Java and 
Kotlin.  That is really 

00:34:17.950 --> 00:34:22.109
convenient.  When you write a 
Lint analysis, you are writing 

00:34:23.886 --> 00:34:28.278
directly on the UAST.  When you 
are writing the Lint check, you 

00:34:28.279 --> 00:34:32.108
are scanning the AST for the 
source code, calls, and 

00:34:32.544 --> 00:34:34.651
expressions you are interested 
in and that is how it works.  

00:34:34.938 --> 00:34:38.604
And Lint actually works on all 
types of files, so you can look 

00:34:38.605 --> 00:34:42.736
at Gradle files, you can look at
XML files and resources.  This 

00:34:43.193 --> 00:34:46.884
is powerful, it gives a 
wholistic view of your 

00:34:47.152 --> 00:34:49.976
application and can provide a 
lot more helpful messages with 

00:34:50.346 --> 00:34:52.566
that.
A couple more points here, so 

00:34:53.203 --> 00:34:55.203
type information is available.  
It is not just -- you are not 

00:34:55.347 --> 00:35:00.726
just looking at text, you have 
the whole AST, you can do method

00:35:03.576 --> 00:35:07.109
resolution, examine the class 
hiarko of of the class you are 

00:35:07.384 --> 00:35:11.380
looking at, that is important 
for preventing false positives 

00:35:11.381 --> 00:35:14.988
and having powerful Lint checks.
That is what makes Lint useful. 

00:35:15.373 --> 00:35:20.036
We have tight integration with 
the IDE.  And Lint does show you

00:35:20.037 --> 00:35:23.725
the warning messages right in 
the IDE.  That is critical, if 

00:35:23.989 --> 00:35:27.486
you don't have that, a lot of 
your messages are lost in some 

00:35:27.846 --> 00:35:30.538
build-up somewhere and it is not
useful to most people.

00:35:30.539 --> 00:35:33.429
And so, with that, we are going 
to move into writing custom Lint

00:35:33.889 --> 00:35:37.154
checks.  This means that, you 
know, Android Lint is a 

00:35:37.443 --> 00:35:41.318
framework.  You can write your 
own Lint checks.  If you have 

00:35:42.260 --> 00:35:45.192
something that annoys you, a 
common bug that you run into on 

00:35:45.481 --> 00:35:47.865
your team, or something that you
want your colleagues to watch 

00:35:48.696 --> 00:35:52.559
out for, you can run your own 
Lint check, upload it to the 

00:35:52.828 --> 00:35:56.221
code base, and all of your 
colleagues will see in the I it 

00:35:56.761 --> 00:36:00.617
DE this highlighted.
  And Lint has an unstable API, 

00:36:00.884 --> 00:36:03.526
we don't promise that we keep it
the same from release to 

00:36:03.790 --> 00:36:06.175
release.  The good news is that 
it is not changing too often, 

00:36:06.464 --> 00:36:09.689
but no promises.
The other good news is that 

00:36:09.690 --> 00:36:12.713
unstable APIs are really fun to 
play with.

00:36:12.714 --> 00:36:15.460
All right.  And with that, we 
are going to move into the demo.

00:36:15.736 --> 00:36:22.153
So let's switch over, awesome.
All right.

00:36:22.154 --> 00:36:24.161
So don't bother reading code too
much.

00:36:24.162 --> 00:36:29.472
The example I want to set up 
here is that you see that your 

00:36:29.473 --> 00:36:33.072
call logs are calling 
thread.yields.  If you look at 

00:36:33.073 --> 00:36:39.353
the documentation, there ask  is
not a useful method.  If you are

00:36:39.354 --> 00:36:42.386
running concurrent data 
structures, it is useful.  But 

00:36:42.387 --> 00:36:44.904
in other ways, you want to avoid
it.  It doesn't do what you 

00:36:45.168 --> 00:36:49.848
think it does.  So let's say we 
will write our own lint check 

00:36:50.429 --> 00:36:53.698
that calls thread.yields.  So 
right now, it is not 

00:36:53.992 --> 00:36:57.377
highlighted, there are no Lint 
checks yet.  I want to show you 

00:36:59.265 --> 00:37:01.265
how I have this set up.  You 
have an Android application 

00:37:01.476 --> 00:37:03.798
module here, here it is called 
app.  The way you will write 

00:37:04.093 --> 00:37:09.429
your on Lint checks, you will 
have a Java module, checks, for 

00:37:09.716 --> 00:37:13.803
example.  And you are going to 
add a dependency from your 

00:37:16.731 --> 00:37:18.456
Android application to the 
checks module.

00:37:18.457 --> 00:37:23.655
And we have this nice Lint 
checks block here that makes it 

00:37:23.927 --> 00:37:26.824
easy to do that.  Once you have 
that set up, and I'm skipping 

00:37:27.098 --> 00:37:30.945
over some of the details here, 
but I'm going to have some links

00:37:31.214 --> 00:37:35.254
at the end.  I can look at 
sample projects.  Once that is 

00:37:35.387 --> 00:37:38.715
set up, I can go to the Lint 
check itself. You have a class, 

00:37:38.991 --> 00:37:42.820
yield detector.  This is a 
detector for calls to 

00:37:42.821 --> 00:37:46.118
thread.yields, it extends some 
classes in the Lint framework, 

00:37:46.754 --> 00:37:49.792
and I have typed up some of the 
metadata for this check that we 

00:37:50.240 --> 00:37:54.638
want to have.  There's a name, 
brief description, and 

00:37:55.181 --> 00:38:01.673
explanation for how to fix the 
issue, the severityseseverity, 

00:38:01.674 --> 00:38:05.299
whether it breaks the build, 
etc. And once I have the 

00:38:05.724 --> 00:38:08.831
metadata, I'm going to start 
typing some code here.

00:38:08.832 --> 00:38:15.057
So one method to be aware of is 
called Git applicable method 

00:38:15.476 --> 00:38:18.174
names.
So the way lint works is, you 

00:38:18.530 --> 00:38:23.356
know, there's a couple options. 
You can make your own AST 

00:38:23.618 --> 00:38:26.072
scanner, which will give you 
total control.  You can scan the

00:38:26.344 --> 00:38:28.436
source file, looking for 
whatever you want.  And for 

00:38:28.790 --> 00:38:30.853
performance reasons, we have 
these hooks where you can 

00:38:31.067 --> 00:38:34.395
register with Lint, hey, I'm 
only interested in method calls 

00:38:34.682 --> 00:38:36.933
with this particular name.  And 
so here, we are actually only 

00:38:36.934 --> 00:38:41.630
interested in method calls with 
name yield.

00:38:41.631 --> 00:38:44.533
And if I have any typos, it is 
not going to work.  So let me 

00:38:44.890 --> 00:38:47.289
know.
Haha.

00:38:47.290 --> 00:38:51.251
Once you have the hook in place,
we have to write the hook 

00:38:51.536 --> 00:38:53.536
itself.  So here, we can say 
visit 

00:38:57.362 --> 00:38:59.493
method.
And I wil will make

00:39:03.789 --> 00:39:07.452
sure that is -- this method is 
only called when we come across 

00:39:07.453 --> 00:39:10.851
a yield function call.  We will 
say, okay, let's assert that the

00:39:11.112 --> 00:39:14.265
method name we are looking at is
actually yield.  So this should 

00:39:14.546 --> 00:39:17.204
always be the case.
And then, because we have type 

00:39:17.588 --> 00:39:22.120
information, we can do due 
diligence and making sure we 

00:39:22.121 --> 00:39:24.269
don't have a false positive 
here.  Maybe there's another 

00:39:24.434 --> 00:39:27.501
class with a function called 
yield, and we want to make sure 

00:39:28.538 --> 00:39:30.538
that the Java

00:39:32.431 --> 00:39:34.357
link thread.yield.
So we will check to make sure we

00:39:34.358 --> 00:39:38.862
is have the methods, look at the
evaluat evaluator, is the method

00:39:39.197 --> 00:39:42.225
in class, we will pass the 
revolve method node and give it 

00:39:42.226 --> 00:39:47.644
the class name.  So 
Java.link.thread.  So this means

00:39:47.954 --> 00:39:53.012
that if this method that they 
are callingging is part of the 

00:39:53.013 --> 00:39:54.641
exact class, we can record the 
error. 

00:39:54.642 --> 00:39:59.699
And context.report, I will give 
it the issue that holds the 

00:40:00.071 --> 00:40:05.062
metadata we have above.  I will 
give it the node, I will give it

00:40:05.506 --> 00:40:08.741
the locations.  We are telling 
Lint, this is where the error 

00:40:09.025 --> 00:40:11.911
is, what you should highlight.
And I think I have to give it a 

00:40:12.357 --> 00:40:17.380
message.
So let's say, please don't use 

00:40:17.637 --> 00:40:19.857
this.
And also, you should use a more 

00:40:20.197 --> 00:40:21.954
helpful error message.
All right.

00:40:21.955 --> 00:40:24.736
That's all it takes.
If I have no typos, I'm going to

00:40:25.051 --> 00:40:27.051
make the

00:40:33.223 --> 00:40:35.223
projects.
It looks like it is done.  If I 

00:40:37.451 --> 00:40:42.598
go back to our application, bam,
lint scanned the source code, 

00:40:42.919 --> 00:40:46.395
picked up the check right in the
IDE.  And this is powerful.  You

00:40:47.026 --> 00:40:51.570
can make it pop up for your 
colleagues and everything.  

00:40:51.571 --> 00:40:54.978
Awesome, we will go back to the 
slides.

00:40:54.979 --> 00:40:58.595
All right.
So 50 seconds left, happy with 

00:40:58.596 --> 00:41:03.468
the timing here.
Here are some links, I want you 

00:41:03.469 --> 00:41:06.678
to check them out.  If you never
read the overview on the 

00:41:06.953 --> 00:41:08.737
development page, go there, 
there's a lot of information 

00:41:08.738 --> 00:41:11.106
from this talk and a little bit 
more. 

00:41:14.425 --> 00:41:17.413
Please  check out the 
annotations page, there are so 

00:41:17.700 --> 00:41:21.036
many that can prevent a lot of 
bugs ahead of time.

00:41:21.037 --> 00:41:28.717
If you are really excited about 
this demo I just gave, check out

00:41:28.718 --> 00:41:35.324
the sample project on GitHub, 
where you can run custom Lint 

00:41:35.584 --> 00:41:39.311
checks.  If you have an issue, 
we have a Lint mailing list.  

00:41:39.728 --> 00:41:42.633
Many of you know Tor, he is 
active on the mailing list and I

00:41:42.634 --> 00:41:45.423
am, too.  We answer all of the 
questions that are asked there. 

00:41:45.424 --> 00:41:46.998
And with that, thank you so 
much.

00:41:46.999 --> 00:41:54.350
If you have any questions, I 
don't -- don't ask them now, I 

00:41:55.404 --> 00:41:58.521
wills  will be in the sandbox 
afterward.  Please check out 

00:41:58.936 --> 00:42:00.936
custom Lint checks.  Thanks.

00:42:07.241 --> 00:42:09.241
[ Applause ]
Coming up next: Testing Rebooted

00:42:41.222 --> 00:42:41.933
(with AndroidX Test) by Yuki 
Hamada, John Gerrish  SPEAKER: 

00:42:41.934 --> 00:42:44.471
Good morning, everyone.  Great 
to see so many people here 

00:42:44.472 --> 00:42:51.689
interested in testing.
My name is John Gerrish, with my

00:42:52.116 --> 00:42:55.529
colleague Yuki Hamada, we're 
presenting a session on testing 

00:42:55.948 --> 00:43:00.021
APIs today.
To get started, hands up, anyone

00:43:00.306 --> 00:43:03.339
who has written unit tests.  It 
is not a trick question, good.  

00:43:03.616 --> 00:43:08.483
And what about integration 
tests? You can be honest.  

00:43:08.484 --> 00:43:09.858
Awesome.
Okay.

00:43:09.859 --> 00:43:11.859
So let's get

00:43:15.254 --> 00:43:17.254
started.

00:43:24.352 --> 00:43:26.352
Click.

00:43:57.778 --> 00:43:59.952
SPEAKER: I have a question while
you are setting up.  Is this 

00:44:00.656 --> 00:44:02.522
related to the project 
languages? 

00:44:02.523 --> 00:44:05.435
SPEAKER: There's a project 
nitrogen talk tomorrow, it is 

00:44:05.436 --> 00:44:09.748
near the end of the day.  I 
strongly encourage CHERK 

00:44:09.749 --> 00:44:12.627
checking it out.  The topic we 
are introducing today is part of

00:44:12.628 --> 00:44:17.031
the grander vision, along with 
project nitrogen, and they work 

00:44:19.861 --> 00:44:21.861
in con 

00:44:24.314 --> 00:44:27.279
conjunction.
Any more questions? We can do 

00:44:27.605 --> 00:44:29.605
this in 

00:44:36.774 --> 00:44:38.774
reverse.
[ Laughter ].

00:45:27.062 --> 00:45:29.996
  SPEAKER: I will ad-lib this.  
On Android, there are two kinds 

00:45:30.261 --> 00:45:33.083
of tests you might be familiar 
with.  There's local unit tests,

00:45:33.981 --> 00:45:38.244
and then there's instrumentation
tests.  So let's start by 

00:45:38.433 --> 00:45:42.087
looking at local unit tests.
So these are ones that -- these 

00:45:42.381 --> 00:45:45.265
are tests that are executed on 
your local developer's 

00:45:45.266 --> 00:45:48.116
workstation, on the local VM 
running there.

00:45:48.117 --> 00:45:52.104
And, because you don't need to 
run the entire Android build 

00:45:52.522 --> 00:45:56.316
chain, to avoid dexing, 
packaging, installing on the 

00:45:56.596 --> 00:45:59.287
device, these tests are actually
really, really fast.  And on 

00:45:59.662 --> 00:46:02.310
these kinds of tests, you can 
use a tool like 

00:46:05.316 --> 00:46:08.600
robolectric, which comes with 
its own set of testing APIs to 

00:46:08.601 --> 00:46:12.472
set up the state for your 
Android aenvironment, or use a 

00:46:12.473 --> 00:46:16.841
tool like Mokito and you can 
step out the interactions with 

00:46:16.842 --> 00:46:19.742
the Android framework.  And 
either way, they allow you to 

00:46:19.743 --> 00:46:23.207
write tests, setting up the 
state of the environment that 

00:46:23.208 --> 00:46:27.878
satisfied the preconditions that
you might want in your test 

00:46:28.405 --> 00:46:31.598
case.
The second kind of tests are 

00:46:31.795 --> 00:46:35.487
instrumentation tests.  And 
these are the tests that will 

00:46:35.488 --> 00:46:38.971
run on a virtual, or a real, 
device.  A real device could 

00:46:39.245 --> 00:46:42.753
just be a phone connected to 
your workstation, or if could be

00:46:43.061 --> 00:46:45.612
a form of devices somewhere in 
the cloud.

00:46:45.613 --> 00:46:49.865
These kind of tests run slower 
because you have to execute the 

00:46:49.866 --> 00:46:53.835
whole build chain and install an
application on to the device.  

00:46:54.147 --> 00:46:59.251
But they have the advantage of 
being a lot more accurate, 

00:46:59.556 --> 00:47:02.234
because the real lure of a 
virtual device is very similar, 

00:47:02.235 --> 00:47:06.853
or in some cases identical, to 
devices your users are using out

00:47:07.140 --> 00:47:12.174
until the field.  And this 
brings you the confidence your 

00:47:12.439 --> 00:47:17.289
app will behave as expected.
  One criticism we heard, on 

00:47:17.290 --> 00:47:20.899
these tests, there's a lack of 
testing APIs available.  And 

00:47:20.900 --> 00:47:23.097
that makes it difficult for you 
to set up the state of your 

00:47:23.514 --> 00:47:26.393
environment in a way that 
satisfies certain preconditions,

00:47:26.708 --> 00:47:30.526
or edge cases, that you might 
want to be testing.  We heard 

00:47:30.527 --> 00:47:32.527
you loud and clear, this is 
something that we are

00:47:35.436 --> 00:47:43.311
actively working on.
So a bit of a history less on, 

00:47:44.810 --> 00:47:49.102
2017, Android I/O, we wrote out 
the testing story, the software 

00:47:49.416 --> 00:47:53.187
development pyramid.  In this 
model, we encouraged you to 

00:47:53.188 --> 00:47:56.685
write lots and lots of fast, 
scalable unit tests that tested 

00:47:57.751 --> 00:48:00.557
all of your exhaustive 
conditions.  We encouraged you 

00:48:00.880 --> 00:48:04.348
to write a smaller number of 
instrumentation tests that will 

00:48:04.673 --> 00:48:07.406
actually prove that all of these
units assemble together, behave 

00:48:07.580 --> 00:48:10.427
as you would expect, on a real 
device.

00:48:10.428 --> 00:48:16.365
And, in some ways, this was kind
of a compromise.  It was a 

00:48:16.632 --> 00:48:20.209
compromise between the 
advantages of one set of -- one 

00:48:20.210 --> 00:48:24.866
kind of tests, and the tradeoffs
of another.  It brings you a 

00:48:25.180 --> 00:48:29.964
wholistic way of testing your 
app.

00:48:29.965 --> 00:48:35.728
And we showed how this kind of 
approach can lead to 

00:48:35.729 --> 00:48:36.843
test-drivern development on 
Android.

00:48:36.844 --> 00:48:40.366
First of all, you would start 
with a failing UI test.  This 

00:48:40.367 --> 00:48:43.328
would be an instrumentation 
test, probably written with 

00:48:44.216 --> 00:48:48.570
Espresso, and it would test the 
UI of your component, or your 

00:48:49.350 --> 00:48:53.476
feature.  And then you would 
satisfy that feature by a series

00:48:53.724 --> 00:48:58.278
of units, classes, coming 
together that are interactions.

00:48:58.544 --> 00:49:05.367
And you could test drive these 
as well, using a tool like 

00:49:05.368 --> 00:49:13.482
roboelectric, or Mokeyto, as a 
unit test.  And this gives you 

00:49:13.925 --> 00:49:16.870
fast development cycles.  When 
you bring them all together, you

00:49:17.166 --> 00:49:20.511
can run the slower-running, but 
faithful, instrumentation test 

00:49:20.512 --> 00:49:26.498
and hopefully it goes green and 
you're done.

00:49:26.499 --> 00:49:31.149
Well, we enter a refactoring 
cycle because maybe your code 

00:49:31.641 --> 00:49:35.173
leaves a little to be desired 
and you want to do some 

00:49:35.656 --> 00:49:39.833
clean-up.  You can spend some 
refactoring cycles there before 

00:49:39.834 --> 00:49:43.341
coming around to the beginning 
of the cycle where if you have 

00:49:43.620 --> 00:49:46.928
any more work on the feature, 
you might add another test, test

00:49:47.334 --> 00:49:49.738
another aspect to the that 
feature.  And you will keep 

00:49:50.031 --> 00:49:52.444
iterating until you are 
complete, at which time you are 

00:49:52.606 --> 00:49:57.554
good to submit your code and 
move on to the next task.

00:49:57.555 --> 00:50:02.119
So at Google I/O this year, we 
realized there was somewhat of a

00:50:02.120 --> 00:50:06.022
test writing crisis.
And because there's so many 

00:50:06.284 --> 00:50:11.455
tools available, it is not 
always clear which one to use.

00:50:11.654 --> 00:50:15.351
And each of these tools all have
their own different styles and 

00:50:15.618 --> 00:50:23.140
APIs and paradigms for the same 
concepts that exist on Android.

00:50:23.428 --> 00:50:27.819
And the problem with this is 
that tests written

00:50:33.074 --> 00:50:39.578
in different levels are not 
portable across levels, it is 

00:50:39.579 --> 00:50:42.470
stuck in the environment that 
you have written on.  So this 

00:50:42.471 --> 00:50:47.619
year, in Google I/O, we 
announced the render next test, 

00:50:47.620 --> 00:50:52.124
it brings in testing as part of 
the tool chain, as part of 

00:50:52.326 --> 00:50:56.095
Jetpack.  It includes some of 
the existing libraries you've 

00:50:56.096 --> 00:51:00.829
used before, some new APIs, full
Kotlin support, which allows you

00:51:01.113 --> 00:51:06.727
to run beautiful and concise 
tests.  It is available on and 

00:51:06.728 --> 00:51:12.961
off device.
Well, last week, AndroidX test 

00:51:14.872 --> 00:51:19.068
moved out of beta into release, 
1.0.  And it is also, as of last

00:51:19.928 --> 00:51:23.638
week, fully open-sourced.  So we
look forward to welcoming your 

00:51:24.616 --> 00:51:29.022
contribution contribute  -- 
contributeutions.

00:51:32.071 --> 00:51:37.399
.  All of it is being revamp ed 
to show you the new styles of 

00:51:37.713 --> 00:51:40.363
APIs.  So please go and check 
that out.

00:51:40.364 --> 00:51:43.318
Let's take a look inside.
The first module that we pulled 

00:51:43.611 --> 00:51:47.010
across was the existing JUnit 
for support, the runner and the 

00:51:47.361 --> 00:51:49.361
rules that you may have

00:51:51.049 --> 00:51:53.049
used before.
We've already added a new 

00:51:53.203 --> 00:51:59.960
module, which we call core.  
This includes some new APIs: 

00:52:00.231 --> 00:52:04.402
ApplicationProvider, as its name
suggestsZsuggests, is a quick 

00:52:04.403 --> 00:52:08.745
and easy way to get a hold of 
the application context.  

00:52:08.746 --> 00:52:14.576
ActivityScenario, which is a 
brand-new API that provides a 

00:52:14.904 --> 00:52:16.904
course and 

00:52:20.242 --> 00:52:27.332
fine-grained activities, and 
FragmentScenerio that provides a

00:52:27.514 --> 00:52:30.477
set of testing features for 
fragments.

00:52:30.478 --> 00:52:32.478
We also brought

00:52:34.883 --> 00:52:39.058
Espresso into the AndroidX 
family.  It is a set of 

00:52:39.690 --> 00:52:45.107
view-matching libraries -- a set
of view matching APIs and 

00:52:45.279 --> 00:52:48.137
actions, allowing you to match 
and interact with those UI 

00:52:48.478 --> 00:52:51.001
elements.
It also includes some other 

00:52:51.296 --> 00:52:57.123
things like the ability to 
capture intents for the system.

00:52:57.325 --> 00:53:03.313
And finally, we've also released
some truth Android extensions.  

00:53:03.651 --> 00:53:07.924
And truth is Google's open 
source, fluent testing 

00:53:08.457 --> 00:53:12.787
assertions library.
And we brought a bunch of 

00:53:13.085 --> 00:53:19.156
components for Android subjects 
, which allow you to test your 

00:53:19.785 --> 00:53:21.609
Android objects beautifully and 
concisely.

00:53:21.610 --> 00:53:25.327
And those of you who have been 
using roboelectric will know 

00:53:25.645 --> 00:53:29.779
that we had a version, 4.0, in 
beta for a while.

00:53:29.780 --> 00:53:34.358
And, as of last week, we did a 
simultaneous release that has 

00:53:34.623 --> 00:53:38.274
now gone into final.  
Roboelectric four fully supports

00:53:38.645 --> 00:53:42.640
all of the unified APIs that are
in AndroidX test, as well as a 

00:53:42.641 --> 00:53:44.641
number of its own new features 

00:53:50.296 --> 00:53:52.296
and 

00:53:53.396 --> 00:53:57.147
improvements.
Okay.  So I would like to 

00:53:57.666 --> 00:54:00.293
welcome Yuki on stage, who will 
give a deeper dive into some of 

00:54:01.400 --> 00:54:03.400
the APIs available. 

00:54:17.040 --> 00:54:19.040
IA

00:54:28.414 --> 00:54:29.458
[ Applause ]. 
SPEAKER: Thanks.  Hi, everyone.

00:54:29.459 --> 00:54:32.725
So let me introduce our new API.
This starts with 

00:54:29.459 --> 00:54:33.444
ApplicationProvider, a new way 
of accessing context from your 

00:54:33.726 --> 00:54:37.923
test support.  So when you look 
on Android testing, you need to 

00:54:38.867 --> 00:54:42.446
handle two different context 
objects.  The first one comes

00:54:47.184 --> 00:54:52.598
from application under your 
test, and the second one comes 

00:54:52.974 --> 00:54:55.791
from the instrumentation APK, 
where your test code is

00:55:00.495 --> 00:55:04.565
stored.
So with today's library, we have

00:55:04.845 --> 00:55:08.458
two different methods to access 
this context object.  And this 

00:55:09.021 --> 00:55:11.576
makes your test code harder to 
understand, because the

00:55:15.509 --> 00:55:18.985
library used, targets the 
context meaning the context from

00:55:19.699 --> 00:55:24.037
your instrumentation APK, while,
sorry, the target context means 

00:55:24.360 --> 00:55:29.215
that context from your 
application while get-context 

00:55:29.216 --> 00:55:32.970
means the context from your 
instrumentation or APK also -- 

00:55:34.286 --> 00:55:40.379
it is not obviously which one to
use for your tests.

00:55:40.380 --> 00:55:46.462
So, in our new API, we hide the 
instrumentation context from 

00:55:48.800 --> 00:55:52.545
target API, and we only -- only 
the ApplicationProvider provides

00:55:52.749 --> 00:55:57.315
an application context in the 
form of your application graph.

00:55:57.484 --> 00:56:01.926
And let's take a look at the 
example.

00:56:01.927 --> 00:56:06.813
So here, let's say we have a 
test for the location tracker 

00:56:07.212 --> 00:56:11.474
activity.  And in the set up 
method, we get the target 

00:56:11.748 --> 00:56:14.740
context in the old-fashioned 
way, and we type cast the 

00:56:15.111 --> 00:56:21.299
location tracker application, so
that we can reduce the mark 

00:56:22.279 --> 00:56:27.895
object for testing, and the 
second line, set a mark object 

00:56:27.896 --> 00:56:32.026
for that.  This code is simple, 
and it actually works.  But you 

00:56:32.303 --> 00:56:38.874
could use the run context and 
face the runtime error, and 

00:56:39.110 --> 00:56:41.110
ended up with wasting your

00:56:47.471 --> 00:56:50.394
time for debugging.
Now, with the new way, 

00:56:50.395 --> 00:56:54.809
application context provider 
provides your context in the 

00:56:57.215 --> 00:56:59.662
application graph.
So you can do exactly the same 

00:56:59.925 --> 00:57:04.879
thing, but there is less chance 
for confusion.

00:57:04.880 --> 00:57:08.116
Okay.
And let me move on to the more 

00:57:08.412 --> 00:57:11.844
complicated stuff, activity 
scenario.

00:57:11.845 --> 00:57:15.402
Actually, before I -- we dive 
into it, I have a few questions 

00:57:16.012 --> 00:57:22.244
for you.  How many of you have 
written your own activity, and 

00:57:25.033 --> 00:57:28.767
handled the live cycle 
transitions by yourself? Raise 

00:57:29.035 --> 00:57:32.786
your hands if you are.  And how 
many of you have shifted your 

00:57:33.507 --> 00:57:38.421
activity with a bug related to 
life cycle?

00:57:38.422 --> 00:57:44.405
Many of you.  Who didn't write 
the tests for that? Who did not 

00:57:45.042 --> 00:57:46.477
write the tests?
Cool.

00:57:46.478 --> 00:57:51.455
Well, yeah, I see some hands up,
keeping up.  And to be honest, I

00:57:51.456 --> 00:57:56.145
do, too.  And I agree.
Writing tests for the activity 

00:57:57.248 --> 00:58:01.650
life cycle transition is pretty 
hard, and there is no good API 

00:58:01.918 --> 00:58:08.739
in the testing library now.
So that's why our team have 

00:58:09.123 --> 00:58:12.235
sought for a solution, and we 
developed the ActivityScenario, 

00:58:12.640 --> 00:58:16.566
which you can use it for driving
your activity state to 

00:58:16.838 --> 00:58:18.838
laboratory state for

00:58:21.622 --> 00:58:24.288
testing.
So let's visit the activity 

00:58:24.289 --> 00:58:27.303
state first.
So the creative state is where 

00:58:27.304 --> 00:58:32.268
activity is created, and 
instantiateinstantiated.  But it

00:58:32.269 --> 00:58:38.789
is not visible to users yet.
Or activity, sorry, can be 

00:58:40.456 --> 00:58:45.363
created state, while it is 
running in background.

00:58:45.364 --> 00:58:48.233
And the started state is where 
the activity is created and 

00:58:49.074 --> 00:58:53.024
started.  It is partially 
visible to the users, but not 

00:58:53.238 --> 00:58:55.799
the fore ground of activities.  
The activities running in 

00:58:56.076 --> 00:59:00.014
picture mode is also in this 
state.

00:59:00.015 --> 00:59:06.093
And the  the resumed state is 
where the activity state is 

00:59:06.248 --> 00:59:09.570
visible to users and running in 
the fore ground.

00:59:09.571 --> 00:59:13.968
And under the framework, you can
change the life cycle state 

00:59:15.380 --> 00:59:19.374
anytime the user interactions, 
so the activity has to handle 

00:59:19.375 --> 00:59:24.303
those transitions properly for a
good user experience, otherwise 

00:59:26.475 --> 00:59:32.392
you see some bugs.  And activity
scenario provides a method 

00:59:36.606 --> 00:59:39.411
moveToState, where you can move 
it to testing.  We will look at 

00:59:39.692 --> 00:59:42.902
the testing code.  We have a 
test, location Tracker Activity,

00:59:43.180 --> 00:59:48.698
and here we want to verify that 
location listener is properly 

00:59:48.967 --> 00:59:51.714
registered from the system when 
the activity becomes a creative 

00:59:52.392 --> 00:59:56.606
state.
So across, we have to start the 

00:59:56.607 --> 01:00:00.590
activity.  The launch activity 
takes your activity graph and it

01:00:00.992 --> 01:00:04.323
starts the activity and waits 
for it until it becomes a

01:00:09.572 --> 01:00:14.337
reasonable state.
And move to state initiates the 

01:00:14.619 --> 01:00:18.927
transition, and moves the life 
cycle state to the created 

01:00:19.270 --> 01:00:22.786
state. And the older method, the
older ActivityScenario method 

01:00:23.390 --> 01:00:28.098
works as a broken code.  So 
after this method call, it is 

01:00:28.680 --> 01:00:32.300
guaranteed that activity's life 
cycle state to be created.

01:00:32.301 --> 01:00:37.749
And then you can inspect your 
activity's internal state by 

01:00:38.338 --> 01:00:41.941
calling activity method. Yes, 
that is easy, and now we have 

01:00:41.942 --> 01:00:44.776
our API.
And also you can use 

01:00:45.903 --> 01:00:47.903
ActivityScenario for testing the
creation of

01:00:51.153 --> 01:00:55.482
your activity.  So activity 
creation happens when your 

01:00:55.483 --> 01:00:57.710
activity is running in 
background for a long time and 

01:01:00.340 --> 01:01:04.464
where you can come back to it 
later.  And your activity has to

01:01:05.004 --> 01:01:07.004
save its

01:01:09.064 --> 01:01:15.342
internal state, to a saved 
instance state bundle, where it 

01:01:15.343 --> 01:01:21.620
is destroyed, otherwise you will
lose the state.  We have a 

01:01:21.621 --> 01:01:24.638
re-create where you can use the 
testing scenario.  This is the 

01:01:24.639 --> 01:01:26.532
example code.
  So here, in this test, we 

01:01:26.533 --> 01:01:29.975
wanted to make sure that input 
text is restored properly after 

01:01:30.428 --> 01:01:35.307
the activity is re-created after
disruption.

01:01:35.308 --> 01:01:39.289
So first, we have some test 
data, like test user, as our 

01:01:39.499 --> 01:01:46.100
input.  And again, we started 
the activity.  And then we input

01:01:46.101 --> 01:01:53.357
-- we filled the text box by u 
using the Espresso library.

01:01:53.358 --> 01:01:57.406
The ActivityScenario works 
nicely with Espresso, and we 

01:02:00.796 --> 01:02:03.816
call re-create, which disrupts 
the activity, re-creates the 

01:02:04.606 --> 01:02:07.562
instance, and waits for the 
activity to be a reasonable 

01:02:08.431 --> 01:02:11.842
state.  And using the Espresso 
again, we can make sure that the

01:02:12.790 --> 01:02:18.310
text is there as we expected.  
Yes, it is also simple.

01:02:18.311 --> 01:02:23.000
Okay.  And finally, I would like
to show you one more example 

01:02:23.258 --> 01:02:28.463
from the Truth extension.  
Intent Subject, by using Intent 

01:02:29.312 --> 01:02:33.695
Subject, you can verify your 

01:02:36.840 --> 01:02:39.909
Intent values and it produced 
really good schema-friendly 

01:02:40.180 --> 01:02:43.320
error messages, if that error 
happens.

01:02:43.321 --> 01:02:47.089
This testing example, again, 
this time, we want to make sure 

01:02:47.376 --> 01:02:52.585
that Intent -- we want to make 
sure that the data intent has an

01:02:53.244 --> 01:02:58.509
expected contact name in extras.
So first, we create a bundle of 

01:02:58.510 --> 01:03:04.481
the data intent.  And then we 
start with three lines, one is 

01:03:04.759 --> 01:03:10.610
checking if that intent has the 
expect action, the second is 

01:03:11.405 --> 01:03:18.196
type, and the third is extra 
bunted  bundles.  If the value 

01:03:18.436 --> 01:03:22.016
does not meet the expectation, 
you see this error.  And you can

01:03:23.215 --> 01:03:28.101
immediately know the, in this 
example, the intent action is 

01:03:28.668 --> 01:03:34.779
not what you expected.
And there's a lot of components

01:03:37.807 --> 01:03:40.569
that come under the release 1.0.
I cannot show you everything 

01:03:40.570 --> 01:03:45.382
today.  For example, we have 
more assertions, and we also 

01:03:45.724 --> 01:03:48.592
have Android Builders where you 
can create your testing data 

01:03:49.213 --> 01:03:51.213
easily.  And also scenarios for 

01:03:55.130 --> 01:03:57.470
activity and fragment.  You can 
look at the documentation to see

01:03:57.471 --> 01:03:59.471
more.  I hope you try it out 

01:04:03.012 --> 01:04:06.154
after the talk.
Okay, so this is our solution 

01:04:06.745 --> 01:04:14.669
for the test writing crisis.
So with unified API, you no 

01:04:14.933 --> 01:04:19.744
longer consider whether you have
to write an instrumentation test

01:04:19.745 --> 01:04:25.329
because you can now just write 
the Android test, and that test 

01:04:25.622 --> 01:04:31.351
runs on both runtime 
environmentsenvironments nicely.

01:04:31.630 --> 01:04:35.337
With the unified API, you can 
focus on what to test and you 

01:04:35.338 --> 01:04:41.432
can forget about where and how, 
and to ensure the contistancy of

01:04:41.433 --> 01:04:48.697
the behavior of our API, we have
a verification test and we run 

01:04:48.698 --> 01:04:54.407
the same tests against the, 
sorry, we run the same test on 

01:04:54.408 --> 01:04:56.408
locally 

01:04:57.823 --> 01:05:02.968
with Robolectric and on a bunch 
of devices from the API 15 to 

01:05:03.280 --> 01:05:05.280
the latest 

01:05:07.041 --> 01:05:09.328
version.
And let's go back to the 

01:05:09.329 --> 01:05:13.162
workflow that we showed you 
earlier in this talk.

01:05:13.163 --> 01:05:19.384
So we can execute the test 
driven development much more 

01:05:19.773 --> 01:05:25.581
effectively using the device 
agnostic tests, with the tests, 

01:05:26.083 --> 01:05:29.807
writing it in a unified API.
As a recommendation, we 

01:05:30.065 --> 01:05:35.074
recommend that you write that 
test with

01:05:39.644 --> 01:05:42.318
Robolectric until the call is 
ready to submit, and run the 

01:05:42.319 --> 01:05:46.404
same test, but on a battery of 
devices before you submit the 

01:05:46.405 --> 01:05:47.872
test to maximize your 
confidence.

01:05:47.873 --> 01:05:52.796
And also, you can run the same 
test as a continuous integration

01:05:53.095 --> 01:05:55.095
test against the

01:05:57.137 --> 01:05:59.523
binaries.
With the upcoming nitrogen tool 

01:06:00.146 --> 01:06:05.819
change, you can set up such a 
configuration easily.

01:06:05.820 --> 01:06:12.181
If you want to know more about 
the Project Nitrogen, we have a 

01:06:12.570 --> 01:06:17.021
session tomorrow, and we highly 
recommend that you attend it.

01:06:17.283 --> 01:06:19.749
Thank you very much for 
listening, and have a happy 

01:06:20.225 --> 01:06:22.225
testing.
[ Applause ]

01:06:30.589 --> 01:06:33.098
.
Coming up next: Optimizing User 

01:09:17.397 --> 01:09:20.863
Flows through Login by Sean 
McQuillan, Jeremy Orlow.

01:09:17.397 --> 01:09:21.704
SPEAKER: Hey, everybody.  With 
that interstitial music, the 

01:09:21.705 --> 01:09:25.570
point is to make you really 
happy for when the next 

01:09:25.875 --> 01:09:28.122
presentation starts.  We will do
lightning talks that we have not

01:09:28.342 --> 01:09:30.836
done before.  We will see how 
well it works.  The way it is 

01:09:30.995 --> 01:09:35.359
supposed to work, we are going 
to roll from one into the other.

01:09:35.622 --> 01:09:39.356
They have 5 minutes to go, when 
it is up, I will call time.  In 

01:09:39.706 --> 01:09:42.745
the back, they are going to 
press a magic button that makes 

01:09:44.839 --> 01:09:46.769
this sound.
So that's how we know it is time

01:09:46.770 --> 01:09:49.388
for the next talk.  And 
otherwise, I have no purpose 

01:09:50.006 --> 01:09:52.853
being here.  I will talk about 
the next speakers, optimizing 

01:09:53.635 --> 01:09:59.270
user flows through login, and I 
will start my timer.

01:09:59.271 --> 01:10:02.691
Thunderous applause for the 
lightning talk, please!

01:10:05.804 --> 01:10:07.480
[ Applause ].
SPEAKER: Welcome to lightning 

01:10:07.481 --> 01:10:10.974
talks, I'm excited to talk to 
you today about how to welcome 

01:10:10.975 --> 01:10:15.551
your users to your Android app 
whether you when you get a new 

01:10:15.552 --> 01:10:20.593
phone.  Why is this important? 
On the Android system, we get a 

01:10:20.856 --> 01:10:23.921
new phone every 2 or 3 years and
we reinstall the apps that have 

01:10:23.922 --> 01:10:27.921
been installed, and all of the 
users do this as well.  If you 

01:10:28.288 --> 01:10:31.217
buy a new phone every two years,
half of your users are going to 

01:10:31.521 --> 01:10:35.293
get a new phone this year.  And 
if you don't do anything at all 

01:10:35.771 --> 01:10:38.687
with the application, you will 
give them a cold welcome when 

01:10:38.960 --> 01:10:43.720
they come back.  You will show 
is  them an email and a password

01:10:44.141 --> 01:10:47.595
form that shows them that they 
have never used it before, you 

01:10:47.596 --> 01:10:49.840
will disrupt the flow of the 
app.  You want to welcome them 

01:10:50.093 --> 01:10:52.081
back to the application and 
create the continuous user 

01:10:52.082 --> 01:10:55.583
experience that jumps from their
old device to the new device, so

01:10:56.380 --> 01:10:58.933
you don't have friction or 
retention problems for these 

01:10:59.279 --> 01:11:02.070
users that are switching devices
and using your application.

01:11:02.071 --> 01:11:04.429
There's a couple products you 
can use in Google that help you 

01:11:04.430 --> 01:11:09.750
do this.  So one of them is 
Google sign-in, it is a button 

01:11:10.015 --> 01:11:12.344
you press when you log in.  It 
is a button you 

01:11:15.418 --> 01:11:18.746
press, you log in, it is amazing
for the flow because it makes it

01:11:18.747 --> 01:11:22.385
simple to do the log in.  It is 
good for the activation because 

01:11:22.386 --> 01:11:26.566
it makes it easier to log into 
the app.  In your phone, it is 

01:11:26.567 --> 01:11:29.167
good for reactivating the users 
because they have to click a 

01:11:29.438 --> 01:11:33.643
button.  On Android, you can 
configure it so you don't can  

01:11:33.644 --> 01:11:36.237
have to click the button on the 
new device.  

01:11:36.238 --> 01:11:39.016
Google sign-in works on iOS, 
Android, as well as the web.  So

01:11:39.338 --> 01:11:43.117
you can use it everywhere, and 
it is a great way to add 

01:11:43.622 --> 01:11:45.344
federated log-in to your 
application.

01:11:45.345 --> 01:11:50.560
And another feature on Android 
is Smart Lock for passwords.  It

01:11:52.036 --> 01:11:56.833
is a password manager, stores 
user names and passwords, 

01:11:58.292 --> 01:12:00.141
federated credentials in the 
cloud, when the user confirms 

01:12:00.142 --> 01:12:02.831
they want to save the password 
after they log in.  So in the 

01:12:03.409 --> 01:12:06.586
old phone, they save the 
password, on the new device, in 

01:12:06.872 --> 01:12:11.274
the application, you will give 
them a warm welcome and say, I 

01:12:11.764 --> 01:12:15.319
know who you are, do you want to
log in with the new account? And

01:12:15.625 --> 01:12:19.056
it will create the seamless 
experience and log the user into

01:12:19.057 --> 01:12:22.839
the application.  One of our 
partners, Netflix who is here 

01:12:22.989 --> 01:12:26.512
today, they used this and they 
found that they had 20 percent 

01:12:26.691 --> 01:12:29.001
fewer support requests.  If you 
think about this, every time a 

01:12:30.146 --> 01:12:37.250
user contacts you to get a user 
name and password fixed, there 

01:12:37.553 --> 01:12:41.661
are five that didn't, and they 
will just become a retention 

01:12:41.829 --> 01:12:44.276
problem and may never come back.
This is a great way to improve 

01:12:44.277 --> 01:12:46.981
your business metrics.
  And Autofill is another 

01:12:47.230 --> 01:12:51.885
feature we launched in Android 
O, works like smart lock.  It is

01:12:52.149 --> 01:12:58.523
an Autofill system, it Autofills
TextViews the way you would 

01:12:58.795 --> 01:13:03.203
think, and one of the most 
common ways is user names and 

01:13:03.716 --> 01:13:05.722
passwords.  After they log into 
the old device, they will choose

01:13:05.723 --> 01:13:09.653
to save it to the Autofill 
service, that comes to the same 

01:13:09.979 --> 01:13:15.227
data store, smart lock.  In the 
new device, it Autofills.  

01:13:15.228 --> 01:13:18.118
There's a few ways to get the 
application ready for Autofill. 

01:13:18.653 --> 01:13:24.272
One is to set up a digital asset
link that links the web and the 

01:13:24.552 --> 01:13:28.547
Android app.  This is great, it 
has pluggable password manager 

01:13:28.548 --> 01:13:31.551
and all of them support this and
then the user can log in on the 

01:13:31.552 --> 01:13:34.756
web.  If they are using the same
password manager on the Android 

01:13:34.923 --> 01:13:39.890
device, they are go to  going to
get the credentials transferred.

01:13:40.094 --> 01:13:42.900
And then the password is saved 
and you get the seamless 

01:13:43.143 --> 01:13:45.304
experience to the Android 
application.  And another thing 

01:13:47.624 --> 01:13:51.572
you have to do for Autofill, you
should set up Autofill hints.  

01:13:51.573 --> 01:13:54.423
Tell the service what the user 
name and the password field is, 

01:13:54.780 --> 01:13:58.226
and that way the service does 
not have to guess and maybe get 

01:13:58.498 --> 01:14:01.316
it wrong, probably the worst 
experience you can give your 

01:14:01.562 --> 01:14:03.889
users.  And the last thing we 
are going to talk about is auto 

01:14:03.890 --> 01:14:07.249
back up, I will hand it over to 
Jeremy. 

01:14:07.250 --> 01:14:10.869
SPEAKER: It is a great way to 
also provide continuity to your 

01:14:11.541 --> 01:14:14.319
users.
And so even if your app syncs to

01:14:14.582 --> 01:14:19.205
the cloud, there are still 
device specific settings you can

01:14:19.206 --> 01:14:23.897
back up, and no user who has 
been using your app for a year 

01:14:25.169 --> 01:14:30.810
wants to see a tutorial on how 
to launch an app on the new 

01:14:30.811 --> 01:14:33.756
phone.  So auto back up, when 
the phone is idle, we back up to

01:14:34.664 --> 01:14:39.669
the cloud, the data is stored 
securely, you can have up to 

01:14:40.016 --> 01:14:43.765
25MG, if you go over that, the 
back ups fail.  On the new 

01:14:43.766 --> 01:14:46.940
phone, when the user restores 
the app, it will restore the 

01:14:46.941 --> 01:14:50.498
data before the app runs for the
first time.  And the user picks 

01:14:50.499 --> 01:14:54.079
up where they left off without 
any friction or churn.

01:14:54.080 --> 01:14:59.512
And you can also include and 
exclude specific files, so you 

01:15:03.704 --> 01:15:11.028
can exclude OAuth tokens, and 
keep users engaged when you 

01:15:11.313 --> 01:15:14.244
switch phones.  We will be back 
in the back.

01:15:14.245 --> 01:15:16.526
[Gong ringing]. 
SPEAKER: Be around if you have 

01:15:16.527 --> 01:15:18.527
any 

01:15:21.399 --> 01:15:23.399
questions.
Coming up next: Kotlin + Watch 

01:15:25.069 --> 01:15:28.020
Faces by Jeremy Walker.
SPEAKER: Hi, I'm Jeremy Walker, 

01:15:28.951 --> 01:15:31.434
a developer platform engineer 
here at Google.  I wanted to 

01:15:32.021 --> 01:15:35.047
talk to you about how I use 
Kotlin to make watch face 

01:15:35.924 --> 01:15:39.993
creation much easier on Wear OS.
So watch faces are kind of hard 

01:15:40.318 --> 01:15:44.798
right now, and you have to write
about 600-plus lines of code, it

01:15:44.799 --> 01:15:49.553
is not like a nice app you do in
Android or iOS, where you 

01:15:50.106 --> 01:15:53.437
declare the UI in the XML 
format, you have to manually 

01:15:53.744 --> 01:15:56.050
paint everything, and then you 
have to include a bunch of code 

01:15:56.051 --> 01:16:02.167
so when you are in ambient mode,
you are not hurting the battery 

01:16:02.438 --> 01:16:05.636
life.  I was trying to think of 
how to improve this.  Last year,

01:16:05.637 --> 01:16:08.336
we launched the support for 
Kotlin.  So I thought, how can I

01:16:08.761 --> 01:16:12.646
use Kotlin to make it easier? I 
converted the whole thing to 

01:16:12.647 --> 01:16:16.415
Kotlin, which reduced the code 
lines a lot.  But I found 

01:16:16.677 --> 01:16:19.622
something else with Kotlin that 
made it more cool, and that was 

01:16:19.915 --> 01:16:23.276
something called DSL.
So what is Kotlin DSL?

01:16:23.277 --> 01:16:26.999
Well, the best way to understand
what domain-specific language is

01:16:28.385 --> 01:16:32.218
to compare it to a regular 
programming language.

01:16:32.219 --> 01:16:36.114
So, again, domain-specific lang
language, that did not really 

01:16:36.474 --> 01:16:40.472
help me what it meant.  If you 
compare to a general programming

01:16:41.304 --> 01:16:44.159
language, Kotlin or Java, you 
have a bunch of key words and 

01:16:44.733 --> 01:16:48.843
classes and languages, and you 
make a big app, on the other 

01:16:48.844 --> 01:16:53.617
side is a DSL that focuses on a 
task or domain.  It foregoes a 

01:16:53.828 --> 01:16:57.520
lot of functionality and allows 
you to do that specific task.  

01:16:57.903 --> 01:17:01.417
You probably used external DSL 
and have not realized it.  For 

01:17:01.934 --> 01:17:05.397
example, SQL, for manipulating 
databases, that is a DSL.  Those

01:17:05.632 --> 01:17:10.673
are expressions for manipulating
strings.  They have an 

01:17:11.185 --> 01:17:13.775
independent syntax, reduce 
functionality, you don't have 

01:17:13.939 --> 01:17:16.293
methods or a class to make them 
work.  You are not going to 

01:17:16.517 --> 01:17:19.968
write a full-on application in 
them, either, at least I hope 

01:17:20.286 --> 01:17:24.133
not.  And for SQL, the first key
word indicates as a verb what 

01:17:24.410 --> 01:17:28.573
you are going to do.  You are 
going to select and update.  The

01:17:28.574 --> 01:17:32.338
disadvantage is you have to put 
it as a string literal.  You 

01:17:32.700 --> 01:17:35.264
have to pray and hope that you 
spelled everything right until 

01:17:37.342 --> 01:17:40.168
run time, it fails and you have 
to see what is going on.  And 

01:17:40.734 --> 01:17:43.670
Kotlin DSL, it extracts that out
the string and puts it in the 

01:17:44.209 --> 01:17:46.506
code so you can have type 
checking, you can have code hint

01:17:46.692 --> 01:17:50.772
and all of that good stuff that 
comes with your IDE.

01:17:50.773 --> 01:17:53.421
So now that I have an idea of 
what it is, I like to show you 

01:17:53.910 --> 01:17:58.120
two structures really quick.
And I used the latter, there is 

01:17:58.556 --> 01:18:01.905
one called creating ones for 
chain method calls, and the 

01:18:01.906 --> 01:18:04.918
other is nesting of Lambda.  So 
recognizing DSL is really 

01:18:05.870 --> 01:18:08.224
subjective.  You know it when 
you see it.  So let's see some.

01:18:09.363 --> 01:18:13.547
So this is Kotlin DSL for SQL.  
You can probably look at it, and

01:18:13.816 --> 01:18:16.760
if you know SQL, you can 
understand it right away.

01:18:16.761 --> 01:18:22.142
And it is all words, like Slice,
then I select all, group by,ords

01:18:22.433 --> 01:18:25.911
order by, and limit.  This is 
all type-checked, you get code 

01:18:26.365 --> 01:18:29.221
hinting so you don't spell 
anything wrong.  This is great 

01:18:29.222 --> 01:18:33.496
and understandable, this is DSL.
The DSL for the watch face that 

01:18:33.755 --> 01:18:36.945
I liked is the nested Lambda 
structure.  So this is to create

01:18:37.302 --> 01:18:41.519
a watch face, you can see it 
right there, create a watch face

01:18:41.708 --> 01:18:44.612
is a verb.  If you look at the 
structure, you may not know 

01:18:44.613 --> 01:18:46.320
anything about making a watch 
face, but you probably 

01:18:46.321 --> 01:18:50.789
understand what is going on 
right away.  Analog watch face, 

01:18:50.790 --> 01:18:54.612
it is not digital, it has arms. 
Colors, the dimensions for the 

01:18:54.613 --> 01:18:58.110
hand, the hour, the minute, the 
second, I understand that.  And 

01:18:58.111 --> 01:19:00.435
watch face background image, 
that is all -- it is very 

01:19:02.108 --> 01:19:04.108
declarative, you can understand 
it right away.  This is type 

01:19:04.476 --> 01:19:07.456
checked, and I get code hints 
and all of that good stuff.  In 

01:19:07.709 --> 01:19:11.067
the end, I get this nice little 
watch face with no work. And the

01:19:11.532 --> 01:19:15.155
600 lines, they did not go away.
I put them in a helper class and

01:19:15.156 --> 01:19:17.904
combined them with the more 
important class that interprets 

01:19:18.252 --> 01:19:21.435
the DSL.  If you are making a 
watch face, you only need to 

01:19:21.436 --> 01:19:24.777
know about the DSL.
So what is next?

01:19:24.778 --> 01:19:27.528
I -- this is kind of an 
experiment that I did as a code 

01:19:27.819 --> 01:19:33.570
a lab, check it out, it will 
take eye  you 15 minutes to make

01:19:33.843 --> 01:19:37.408
a new watch face, search for 
Google codelab, it is under the 

01:19:37.737 --> 01:19:40.304
Wear OS, search under Kotlin.  
You can see how to make a watch 

01:19:40.577 --> 01:19:43.652
face, you can see the source 
code for how I made the 

01:19:43.980 --> 01:19:47.487
transition between DSL and 
interpreted it into a nice 

01:19:47.812 --> 01:19:50.334
little watch face.  And more 
importantly, hopefully now you 

01:19:50.335 --> 01:19:52.335
are a

01:19:53.343 --> 01:19:55.345
little bit interested in DSL, 
you can use it in a project to 

01:19:55.346 --> 01:20:02.294
make it better, or you can go 
and use something like the DSL 

01:20:02.588 --> 01:20:07.072
for SQL, for testing, or in html
in the Kotlin coding type 

01:20:07.263 --> 01:20:09.683
checked.  So thank you for the 
talk, for letting me talk, and 

01:20:09.968 --> 01:20:12.603
hopefully I have gotten you a 
little bit interested in DSL.  

01:20:12.984 --> 01:20:14.984
Thank you.

01:20:19.079 --> 01:20:21.079
[ Applause ] 
Coming up next: Push 

01:20:22.553 --> 01:20:26.086
Notifications: An India 
Perspective by Amrit Sanjeev 

01:20:22.553 --> 01:20:27.712
SPEAKER: Well down, no gong.  
Next up, push notifications. 

01:20:28.494 --> 01:20:31.258
SPEAKER: I'm Amrit, a developer 
advocate at Google.  I want to 

01:20:31.522 --> 01:20:35.238
talk about push notifications 
and how interapp developers are 

01:20:35.402 --> 01:20:38.832
getting the delivery higher in 
the region.  I want to talk 

01:20:39.211 --> 01:20:45.438
about a stat in India, we have 
314 million-plus smartphone 

01:20:45.743 --> 01:20:49.955
users, growing on a 16 percent 
year on year growth rate, your 

01:20:50.532 --> 01:20:55.361
apps have a chance for users and
great business in the region, 

01:20:55.632 --> 01:20:57.804
and it comes with a lot of 
competition.  There's a need to 

01:20:58.037 --> 01:21:01.293
have a better engagement as well
as lighting your users.  And 

01:21:01.459 --> 01:21:04.075
push noteification is one of the
mechanisms a lot of developers 

01:21:04.557 --> 01:21:09.352
use to engage your users.  And 
when it comes to push delivery 

01:21:10.251 --> 01:21:16.632
ratess some in India affect the 
delivery.  Until recently, data 

01:21:16.896 --> 01:21:20.008
plans were expensive and people 
have the habit of turning off 

01:21:20.551 --> 01:21:22.611
mobile data when they are not 
using the internet.  So when 

01:21:22.612 --> 01:21:28.026
they go out the WiFi zone, they 
will turn the mobile data off, 

01:21:29.034 --> 01:21:32.337
and that changes the behavior of
time to lift parameter for the 

01:21:32.338 --> 01:21:34.812
push notification, if you have a
short one and they turn the data

01:21:34.998 --> 01:21:40.363
off during that period, the 
notification is never delivered.

01:21:40.364 --> 01:21:43.823
 Recently, new carriers have 
come in and reduced the data 

01:21:43.824 --> 01:21:47.368
costs drastly, and now those 
behaviors are changing, but not 

01:21:47.369 --> 01:21:50.904
enough for you to ignore that 
change.

01:21:51.231 --> 01:21:55.001
Secondly, a lot of devices with 
custom behavior, or Android 

01:21:55.002 --> 01:21:57.927
builds, where your notification 
and, because of battery 

01:21:58.133 --> 01:22:00.890
optimization, they kill off the 
notification services.  They 

01:22:01.263 --> 01:22:05.217
sometimes force close the apps, 
and avoid the app for never 

01:22:05.612 --> 01:22:07.612
getting the notification 
delivered to it.  That is 

01:22:07.821 --> 01:22:10.222
another problem.
  And then your time to 

01:22:10.469 --> 01:22:13.407
parameter, if you actually 
increase it by, say, from four 

01:22:15.642 --> 01:22:19.634
to-eight eight hours, you see a 
drastic improvement, or a large 

01:22:19.799 --> 01:22:26.762
improvement, in notification 
flivverdelivery.  You might go 

01:22:26.763 --> 01:22:29.339
over the WiFi user.  So that 
makes it interesting.  And in 

01:22:29.340 --> 01:22:33.780
any other region, notification 
frequency also, the number of 

01:22:34.062 --> 01:22:38.135
notifications that are sent to 
the users is affected and people

01:22:38.787 --> 01:22:42.027
get irritated and turn off 
notifications if you do it too 

01:22:42.028 --> 01:22:44.659
many times.  So collapsible keys
and things like that are very 

01:22:45.085 --> 01:22:47.237
important here.
And I want to talk about three 

01:22:47.833 --> 01:22:52.200
design patterns that developers 
are actually trying out for 

01:22:52.520 --> 01:22:59.168
querying use cases to improve 
the notification delivery.  One 

01:22:59.169 --> 01:23:04.282
is buffering the notifications, 
to give you understanding of 

01:23:04.283 --> 01:23:06.918
your use case and how the 
buckets work better for you.  

01:23:07.061 --> 01:23:12.713
The neckinism developed here, 
there's a period job that runs, 

01:23:12.714 --> 01:23:16.454
refreshes the npm token, sends 
it to the server, when the 

01:23:17.139 --> 01:23:24.298
server gets the data, it maps 
the fcm and the update.  When it

01:23:24.758 --> 01:23:28.149
you send out oo cap  -- a 
campaign, they split it

01:23:31.628 --> 01:23:37.698
based on recently.  And you put 
in the first batch based on what

01:23:38.126 --> 01:23:42.475
is in the last 7 days, the next 
batch is to update it from 7 to 

01:23:42.476 --> 01:23:46.307
31 day said, all the tokens from
the 7 to the 31 days, and the 

01:23:46.308 --> 01:23:50.387
third is 31 is above. And what 
this allows us, in each of these

01:23:51.047 --> 01:23:55.098
buckets, the parameters for each
of these buckets will improve 

01:23:55.327 --> 01:23:58.864
notfication delivery, you have a
better understanding of which 

01:23:59.123 --> 01:24:01.406
users get the notification and 
might react to your notification

01:24:02.584 --> 01:24:05.626
better.  And because you have a 
lot of tokens, which are not 

01:24:06.614 --> 01:24:11.628
updated frequently, or the users
never send that update cycle, 

01:24:11.629 --> 01:24:15.254
you don't end up calculating 
that in peer notification 

01:24:15.579 --> 01:24:18.571
delivery and you miscalculate 
the effectiveness of push 

01:24:18.851 --> 01:24:19.914
notifications.
  The second one is basically 

01:24:19.915 --> 01:24:24.534
where you have, again, a job 
that comes in.  It checks 

01:24:24.535 --> 01:24:30.385
whether a notification was 
delivered to the device from the

01:24:30.627 --> 01:24:35.861
last one or not.  If not, it 
will go to a service, an RS 

01:24:36.220 --> 01:24:38.046
service in the notification to 
the user.

01:24:38.047 --> 01:24:44.557
And you have to ensure that this
does not wake up the device.  

01:24:45.116 --> 01:24:47.296
This is not the most efficient 
way of doing things, but it 

01:24:47.576 --> 01:24:50.960
still works.  And the last I 
will call out is data messages 

01:24:51.255 --> 01:24:53.919
in the scenario.  In the case 
you want to send a message, 

01:24:54.091 --> 01:24:57.192
there's a sale that is going to 
start at 12:00 you want to show 

01:24:57.466 --> 01:25:02.704
the message at 12:00, and your 
users are 20 percent more on 

01:25:02.966 --> 01:25:09.430
this service.  Instead of 
senting at -- sending at 12:00 

01:25:09.431 --> 01:25:11.763
and hoping that the users 
receive it, they will send it 

01:25:12.292 --> 01:25:14.751
two days before, which as a data
message.  So the app will 

01:25:14.752 --> 01:25:17.767
receive it, and then based on 
the schedule that is within the 

01:25:18.231 --> 01:25:22.417
data message, they will schedule
a job to come up at exactly the 

01:25:22.418 --> 01:25:28.007
right time to display the 
message to the user. 

01:25:28.008 --> 01:25:31.294
SPEAKER: That is time's up.  
SPEAKER: 

01:25:39.728 --> 01:25:41.728
[Gong]. 

01:25:46.220 --> 01:25:49.953
SPEAKER:Coming up next: 
Understand the impact of Generic

01:25:46.220 --> 01:25:48.686
System Images (GSI) by Hung-ying
Tyan.

01:25:46.220 --> 01:25:51.753
SPEAKER: Hello, I'm Hung-ying, 
I'm talking about GSI, the 

01:25:51.999 --> 01:25:56.086
generic STIMP  system images.  
It is the purest form of Android

01:25:56.440 --> 01:26:06.308
framework that we can build from
AOSP.  By purest, it does not 

01:26:06.563 --> 01:26:10.228
have a device maker or carrier 
customization.

01:26:10.229 --> 01:26:12.229
You will

01:26:13.602 --> 01:26:17.370
want to ask -- AOSP has been 
there for 10 years.  Why does it

01:26:17.590 --> 01:26:23.916
become a thing right now?
It is because GSI is the central

01:26:24.304 --> 01:26:30.405
piece in travel compliance.  So 
remember the project travel, we 

01:26:30.732 --> 01:26:32.732
took out

01:26:34.742 --> 01:26:36.742
the Android 

01:26:42.932 --> 01:26:45.138
updateability prom in trial.  We

01:26:48.490 --> 01:26:51.443
architected between the flame 
work and the hardware

01:26:54.622 --> 01:27:00.024
original vendor implementation. 
With this, we no longer need to 

01:27:00.289 --> 01:27:02.289
update the vendor

01:27:04.146 --> 01:27:06.872
implementation with the Android 
framework.  

01:27:06.873 --> 01:27:10.913
This reduces the time for the 
device maker to update their 

01:27:10.914 --> 01:27:15.550
Android framework.
Now, to make sure that the 

01:27:15.817 --> 01:27:22.723
boundary is not altered by 
device makers at will, we 

01:27:23.495 --> 01:27:29.901
require every treble-certified 
device to pass a series of CTS 

01:27:29.902 --> 01:27:35.120
and VTS tests with the Android 
framework replaced by GSI.  So 

01:27:35.121 --> 01:27:40.012
with all of these powerful tools
in place, about a year ago, we 

01:27:40.275 --> 01:27:46.501
started to see the momentum of 
faster Android adoption this 

01:27:47.149 --> 01:27:49.353
year.
So let's take a look

01:27:53.528 --> 01:28:00.437
at the Android developer program
at Google iOS last year.  Only 

01:28:00.951 --> 01:28:07.581
Nexus and Pixel forms were able 
available for you to try out 

01:28:08.029 --> 01:28:12.152
Android Oreo.  And fast forward 
one year later at Google I/O 

01:28:12.153 --> 01:28:18.344
this year, it was the first time
we had non-Google phones join 

01:28:18.742 --> 01:28:23.044
the beta line up.  It is not 
one, it is not two, it is seven 

01:28:23.430 --> 01:28:27.972
device makers joining us.
So the progress was phenomenal.

01:28:28.309 --> 01:28:31.603
We know we are on the right 
track, and we will continue to 

01:28:31.604 --> 01:28:33.604
push for

01:28:36.821 --> 01:28:41.666
it.
Now, despite that GSI is the 

01:28:42.116 --> 01:28:44.978
central piece in Treble 
compliance, we feel like it has 

01:28:44.979 --> 01:28:52.049
a lot more potential than that.
So we set up a goal to make GSI 

01:28:52.315 --> 01:28:57.319
be more accessible and useful, 
not just for device makers, but 

01:28:57.739 --> 01:29:02.174
also for the general public.
Including app developers like 

01:29:02.535 --> 01:29:09.678
you, and even consumers.
An important first step toward 

01:29:10.100 --> 01:29:14.805
that goal is to make GSI 
available in AOSP.

01:29:14.806 --> 01:29:16.806
So, for this, we have

01:29:19.824 --> 01:29:29.651
published pie GSI in AOSP, so 
you can download and build the 

01:29:29.652 --> 01:29:35.121
pie GSI today.  We are exploring
ways to make future GSI 

01:29:35.122 --> 01:29:37.122
available earlier than the 
release of the next Android 

01:29:37.717 --> 01:29:41.879
version.
So you will be able to try out 

01:29:44.416 --> 01:29:47.341
next century version earlier 
than GSI.

01:29:47.342 --> 01:29:51.063
And, at the same time, we can 
get early feedback from you.  So

01:29:51.064 --> 01:29:56.059
the benefit is mutual.
So please stay tuned for our 

01:29:57.784 --> 01:30:02.982
further announcement on this.
Finally, we understand that 

01:30:03.421 --> 01:30:07.432
trying out GSI can be cumbersome
sometimes.

01:30:07.433 --> 01:30:11.316
We are looking into different 
ways to improve the process.

01:30:11.317 --> 01:30:17.488
Right now, we have an idea of 
trying out GSI without actually 

01:30:17.783 --> 01:30:25.041
flashing GSI out to the device.
But I'm not going into detail 

01:30:25.042 --> 01:30:30.363
here.  We do have a working 
early prototype at our demo 

01:30:30.699 --> 01:30:34.376
booth.
In addition to that, we also 

01:30:34.581 --> 01:30:39.995
prepare a set of devices.  They 
are all running on the same pie 

01:30:41.231 --> 01:30:46.126
GSI i.  So please do check out 
our demoes at the Android 

01:30:46.530 --> 01:30:48.530
platform 

01:30:55.173 --> 01:30:55.975
sandbox. 
SPEAKER: Thank you. 

01:30:55.976 --> 01:30:57.976
SPEAKER: Coming up next: Buiding

01:31:02.517 --> 01:31:06.650
Reliable Apps When Connectivity 
Is Unreliable by Naheed Vora, 

01:31:02.517 --> 01:31:04.694
Ryan Hamilton.
 SPEAKER: Hi, I'm a product 

01:31:04.997 --> 01:31:11.131
manager at Android checkativity.
SPEAKER: I'm Ryan Hamilton, a 

01:31:11.664 --> 01:31:13.228
manager on the Chrome networking
team. 

01:31:13.229 --> 01:31:15.229
SPEAKER: So we will

01:31:20.476 --> 01:31:25.030
start with the -- how many of 
you have noticed this in the 

01:31:25.031 --> 01:31:34.020
last few years? The signal is 
flaky and you turn off the WiFi.

01:31:34.677 --> 01:31:36.677
Connectivity keeps changing 
underneath you, and the 

01:31:36.806 --> 01:31:38.457
application is trying to 
understand what is going on 

01:31:38.458 --> 01:31:40.620
underneath, is really 
complicated.

01:31:40.621 --> 01:31:44.813
And, for creating a good 
experience, we need to hide this

01:31:44.814 --> 01:31:48.535
complexity from the user.  We 
don't want users to go and turn 

01:31:48.536 --> 01:31:51.986
off their WiFi in order to use 
the app.  It could be any app 

01:31:52.372 --> 01:31:56.514
that you can think of that the 
user is using at a given point 

01:31:56.515 --> 01:31:58.855
in time.
So who should care?

01:31:58.856 --> 01:32:03.736
If you are building a 
user-facing application, maybe 

01:32:03.737 --> 01:32:08.231
your app depends on mobility.  
Maybe it is Google maps, or 

01:32:08.232 --> 01:32:13.716
something like that.  Or you are
building a gaming application or

01:32:13.717 --> 01:32:17.132
communicating app.  Anytime you 
know you need to react really, 

01:32:17.494 --> 01:32:20.909
really fast, irrespective of 
what is happening in the 

01:32:20.910 --> 01:32:23.811
activity is critical.  This is 
important to make, that you 

01:32:24.111 --> 01:32:25.498
address this point in your 
application.

01:32:25.499 --> 01:32:29.821
And one thing I would add here 
is that the user dropoff rate 

01:32:30.532 --> 01:32:36.580
with had when the delayss are 
1-3 seconds, or 10 seconds, it 

01:32:36.581 --> 01:32:42.714
may vary in markets.  If you are
in a market that is emerging 

01:32:42.715 --> 01:32:46.231
like India, it may be resilient 
to delays.  If you are in the 

01:32:46.635 --> 01:32:49.074
United States, if you go beyond 
three seconds, you will lose the

01:32:49.519 --> 01:32:52.461
user.
  So what I have here is a demo.

01:32:53.154 --> 01:32:55.154
And it is a Google assistant 
demo, what we are doing is we 

01:32:55.325 --> 01:32:58.852
are using the technology and we 
will talk about that a little 

01:32:59.122 --> 01:33:03.972
bit later.  On the left-hand 
side, there is no optimization 

01:33:04.260 --> 01:33:07.229
on the phone.  On the right hand
side, there's an optimization, 

01:33:07.890 --> 01:33:12.930
and we are doing a Google 
assistant query and the user is 

01:33:13.320 --> 01:33:15.454
walking out of the building.  
The phone is connected to WiFi, 

01:33:15.631 --> 01:33:20.312
as the user walks out, the user 
loses connectivity.  Let's

01:33:29.056 --> 01:33:31.056
see 

01:33:32.774 --> 01:33:35.480
what happens.
Trying to click.  This is 

01:33:36.387 --> 01:33:40.122
interesting.
Okay, in the interest of time, 

01:33:40.640 --> 01:33:43.658
this is what happens.
The one on the left-hand side, 

01:33:44.818 --> 01:33:50.358
it takes -- is it possible?
Awesome.  Okay.

01:33:50.359 --> 01:33:57.087
So the -- we will make a query, 
and what it is doing -- it is in

01:33:57.777 --> 01:34:01.121
direction to Oxford service in 
London.  And you can see on the 

01:34:01.321 --> 01:34:04.159
right, the response came back 
already.  The left one, it is 

01:34:04.160 --> 01:34:07.723
still waiting and waiting.  The 
right one is like, eh, I don't 

01:34:07.888 --> 01:34:11.652
have anything to do.  I'm out.  
The left one is like, ah, 

01:34:12.950 --> 01:34:15.924
finally.  This is a lot from 
reaction time perspective.  You 

01:34:16.212 --> 01:34:21.896
want to have this resilience in 
your app, it can reconnect fast 

01:34:22.174 --> 01:34:24.174
irrespective of what is 
happening in the connectivity

01:34:27.792 --> 01:34:29.792
stack.
So let's get out of here.  It is

01:34:36.195 --> 01:34:39.424
a separate problem.
Okay, so what it is using, what 

01:34:39.707 --> 01:34:44.420
you need is you need a protocol 
that can handle this different 

01:34:44.634 --> 01:34:48.415
mobility where the device is 
moving between the networks.

01:34:48.416 --> 01:34:54.174
And so that's where the Cronet 
and QUIC comes into play, the 

01:34:54.803 --> 01:34:57.470
application layer and the 
protocols that you are using can

01:34:57.471 --> 01:35:00.911
handle this mobility.  So I will
hand it over to Ryan to talk 

01:35:00.912 --> 01:35:02.971
about Cronet and QUIC.  
SPEAKER: I will do this quickly.

01:35:04.521 --> 01:35:06.747
We have taken the network stack 
that is inside of the Chrome web

01:35:07.017 --> 01:35:11.843
browser and made it available as
a library for apps to use, we 

01:35:12.249 --> 01:35:17.296
call it Cronet, Chrome, network,
Cronet.  Since it comes from 

01:35:19.484 --> 01:35:21.955
Chrome, it has the reliability 
and interoperability that you 

01:35:22.714 --> 01:35:26.702
would expect.  It is used by a 
variety of Google apps, search, 

01:35:28.273 --> 01:35:30.842
YouTube, maps, and available on 
iOS as well.  Coming soon, it is

01:35:31.131 --> 01:35:35.571
an option to pull from the Play 
Store, you will not need to 

01:35:35.898 --> 01:35:40.207
bundle it in the app.  You can 
get the automatic opdates and 

01:35:40.477 --> 01:35:42.545
security and performance 
improvementes.

01:35:42.546 --> 01:35:45.806
Part of the coolness of Cronet 
is that it comes with support 

01:35:46.191 --> 01:35:49.866
for QUIC, a new transport we 
have implemented in the user 

01:35:51.887 --> 01:35:56.603
space on top of GDP. And it does
some things that TCP can.  It is

01:35:56.604 --> 01:36:00.174
a modern transporter, provides 
new teachers and better 

01:36:00.857 --> 01:36:03.425
performance.  And with QUIC 
connection migration, you can 

01:36:03.706 --> 01:36:07.970
switch back and forth between 
WiFi and Sailor.  It has a bunch

01:36:08.248 --> 01:36:10.905
of awesome performance 
highlights, we release every six

01:36:11.355 --> 01:36:17.176
weeks, it comes with state of 
the art security. 

01:36:17.177 --> 01:36:20.920
SPEAKER: And the best part is 
that the platform optimizations 

01:36:20.921 --> 01:36:25.437
are built in, you do not have to
do everything time there are 

01:36:25.816 --> 01:36:29.510
Android releases, it will take 
advantage of the latest and 

01:36:29.867 --> 01:36:31.280
greatest that Android has to 
offer.

01:36:31.281 --> 01:36:34.035
For any more questions, we have 
a booth outside.  You can talk 

01:36:34.291 --> 01:36:36.291
to us, we are happy to help. 

01:36:44.461 --> 01:36:45.724
Thank you. 
SPEAKER: Thanks.

01:36:45.725 --> 01:36:47.725
Coming up next: Quick Ways to 

01:36:48.903 --> 01:36:53.036
Ensure App Compatibility with 
Android Autofill by Felipe Leme.

01:36:48.903 --> 01:36:54.726
 SPEAKER: Next talk, as a bonus,
this person lets 10 minutes on 

01:36:55.129 --> 01:36:58.146
Autofill. 
SPEAKER: Hello, everybody.

01:36:58.147 --> 01:37:00.147
So my name

01:37:07.881 --> 01:37:13.607
is Felipe Leme, and I'm talking 
about what Android Auto fill is 

01:37:13.608 --> 01:37:16.038
and why it is important for you 
to optimize your apps for it.  

01:37:16.039 --> 01:37:20.132
It is a new feature that we 
introduced last year on the 

01:37:20.133 --> 01:37:22.794
Android Auto release, and the 
goal is to provide a safe and 

01:37:22.795 --> 01:37:27.283
fast way for platform managers 
to do their job.  To use 

01:37:27.947 --> 01:37:29.947
Autofill, you need to select an

01:37:32.154 --> 01:37:38.348
Autofill service which could be 
provided by Google, or 

01:37:38.924 --> 01:37:43.333
third-party apps, like One 
password, and many others.  Last

01:37:43.606 --> 01:37:48.095
time I checked, there are about 
30 different apps on the Play 

01:37:48.096 --> 01:37:50.882
Store that provides an Autofill 
service.

01:37:50.883 --> 01:37:53.807
And one key decision we made 
when we designed the API is that

01:37:54.183 --> 01:37:58.682
it should work out of the box 
with existing apps.  In order 

01:37:59.042 --> 01:38:01.926
words, as an app developer, you 
do not have to support the app 

01:38:01.927 --> 01:38:05.078
-- if you don't do anything, the
password manager will figure out

01:38:05.079 --> 01:38:07.801
what to do for you.
But just because you don't need 

01:38:08.187 --> 01:38:10.853
to change it, it doesn't mean 
you shouldn't.  After all, it is

01:38:11.541 --> 01:38:16.657
your app that is on the line, 
and you don't want to depend on 

01:38:17.109 --> 01:38:20.622
the third party app it has no 
control over.  And the tip I 

01:38:20.889 --> 01:38:25.121
want to give you, you should not
rely on Autofill service 

01:38:25.275 --> 01:38:29.885
heuristics, you want to make 
sure that the password manager 

01:38:30.063 --> 01:38:33.328
does their job properly, you can
do it quickly and easily by 

01:38:33.533 --> 01:38:36.703
annotating your XML views.
  The first thing you should do 

01:38:36.973 --> 01:38:40.695
is make sure that you annotate 
what should be Autofilled, and 

01:38:40.998 --> 01:38:43.750
you do that using the Android 

01:38:47.170 --> 01:38:50.788
Auto fills filling stack.  So 
let's say you have the user name

01:38:51.778 --> 01:38:55.716
and password loading screen.  If
you don't annotate it for 

01:38:55.942 --> 01:39:00.308
Autofill, and the layout XML is 
using user name fields and 

01:39:00.309 --> 01:39:06.869
password fields, it is going to 
work fine.  When they use the 

01:39:07.113 --> 01:39:11.377
instructor, they will say, 
there's a user name string here 

01:39:11.378 --> 01:39:14.333
and password here, and that is 
the user name and passwords.  

01:39:14.334 --> 01:39:20.226
And say you are in Brazil, your 
name is in Portuguese, and I 

01:39:20.227 --> 01:39:26.589
grew up there and it is common.
So my fields are [speaking in 

01:39:26.852 --> 01:39:30.863
language other than language].
So the password manager you get 

01:39:30.864 --> 01:39:34.828
is this instructor, and it knows
what it is.  So it is providing 

01:39:35.312 --> 01:39:38.074
the Autofill data, and the user,
you have to manually type in the

01:39:38.075 --> 01:39:40.075
user name

01:39:41.524 --> 01:39:45.685
and password, which is the 
problem to avoid with password 

01:39:45.959 --> 01:39:49.484
managers.  So you will annotate 
the fields, the user name, and 

01:39:49.485 --> 01:39:53.712
the password, you use password.
And on

01:39:58.029 --> 01:40:01.992
Java, we provide fields for the 
user name and passwords, like 

01:40:01.993 --> 01:40:05.175
telephone number, etc.
  And there is another issue, 

01:40:05.640 --> 01:40:09.888
you should annotate what should 
not be Autofills, using the 

01:40:10.178 --> 01:40:14.691
Android import texts.
  So to see another example, in 

01:40:14.956 --> 01:40:17.922
developing the API last year, I 
wanted to send an SMS to my 

01:40:17.923 --> 01:40:22.414
friend, and then I got a pop-up 
with my own telephone number as 

01:40:23.272 --> 01:40:27.864
a recipient of the SMS.  Am  
when you are composing an SMS, 

01:40:28.374 --> 01:40:32.396
or a spreadsheet, you want to 
type something dynamically, you 

01:40:32.652 --> 01:40:37.779
do not want to use a pre-define 
said ed variance.  This was 

01:40:38.235 --> 01:40:41.857
annoying for me, I knew the API,
it is confusing for ra a user 

01:40:42.120 --> 01:40:45.293
that doesn't.  So you can 
disable the field for the 

01:40:45.294 --> 01:40:47.759
activity, you can do it on the 
whole activity layer by

01:40:51.081 --> 01:40:56.332
annotating the root view, it is 
important for Autofill, no 

01:40:56.622 --> 01:41:00.040
exclude descendantdescendants.  
It will not use password manager

01:41:00.579 --> 01:41:06.623
when it doesn't make sense and 
it will improve the experience.

01:41:07.306 --> 01:41:11.014
  And say you are using the tags
and you are so excited to 

01:41:11.671 --> 01:41:13.807
change, that you skip the 
presentation, the summit, and go

01:41:13.808 --> 01:41:17.966
back to your laptop and change 
your apps.  Don't do that.  If 

01:41:18.280 --> 01:41:21.824
you are going to change, how are
you going to test the changes? 

01:41:22.207 --> 01:41:24.842
You need to select a service to 
see what is the data provided by

01:41:24.843 --> 01:41:29.932
the service, and you will say, 
we will choose whatever comes 

01:41:30.670 --> 01:41:35.972
with my device, Google Autofill,
or install a third-party 

01:41:36.259 --> 01:41:38.848
password manager.  You can do 
that, but you can go back to 

01:41:39.794 --> 01:41:44.405
that problem of relying on the 
password manager heuristic, and 

01:41:44.406 --> 01:41:49.707
we can provide it without a lot 
of changes, and you cannot see 

01:41:51.090 --> 01:41:54.681
what is going on with making 
these changes.  You can use the 

01:41:55.610 --> 01:41:59.399
standard Autofill service, and 
we can provide some samples on 

01:41:59.400 --> 01:42:04.509
GitHub.  We provide a couple 
Autofill samples permutations 

01:42:04.825 --> 01:42:08.253
project, one is the 
basicservice, which is a service

01:42:10.505 --> 01:42:15.009
that only understand Autofill 
hints.  If you are using auto 

01:42:15.010 --> 01:42:17.341
fithints on your app, you will 
see something like this that 

01:42:17.942 --> 01:42:21.722
will pop up, because in this 
field, the user name, you will 

01:42:22.022 --> 01:42:28.284
see is the the options. And on 
the other screens, the base fill

01:42:28.770 --> 01:42:31.827
will not show anything.
  And it has a pretty simple 

01:42:32.313 --> 01:42:37.060
service, less than 200 lines of 
code.  If you are interested in 

01:42:37.061 --> 01:42:44.355
seeing how it works, you can do 
this a well.  And debugservice, 

01:42:44.874 --> 01:42:49.715
it will try to fill anything 
based on your search IDs.  This 

01:42:49.716 --> 01:42:52.137
is useful to test what would 
happen if you are not tagging 

01:42:54.291 --> 01:42:58.358
your views.
So back to my SMS app, you would

01:42:58.604 --> 01:43:01.710
see something like this, and you
will click on two.  And I'm just

01:43:02.843 --> 01:43:05.683
making sure that -- okay.
So we will make sure that I'm 

01:43:05.684 --> 01:43:07.102
seeing, I'm looking on the 
screen.

01:43:07.103 --> 01:43:13.494
So when you click on two, you 
are going to see this pop-up 

01:43:13.495 --> 01:43:16.082
with some user data, which is 
two, which is just the name of 

01:43:16.358 --> 01:43:20.219
the resource ID.  You can see 
how confused it is for the user 

01:43:20.465 --> 01:43:21.909
if they see something like that 
on the app.

01:43:21.910 --> 01:43:24.872
And then, the final tip that I 
would like to give is you should

01:43:25.196 --> 01:43:28.651
also make sure that the app 
works when the Autofill service 

01:43:28.946 --> 01:43:32.342
requires authentication.  So 
what does that mean? So most 

01:43:32.686 --> 01:43:36.799
password managers, they don't 
retain the data right away, it 

01:43:37.429 --> 01:43:41.089
is encrypted somehow.  So they 
will ask the user to 

01:43:41.345 --> 01:43:44.572
authenticate, a master password 
or a finger print to unlock the 

01:43:44.828 --> 01:43:49.066
data.  The way the framework 
works, we are launching this, it

01:43:50.579 --> 01:43:53.498
belongs to the service on top of
the app stack.  The user does 

01:43:53.499 --> 01:43:56.433
the authentication, and when you
are finished, the activity 

01:43:56.434 --> 01:43:58.434
resums.
  So for most apps, it is not a 

01:43:58.465 --> 01:44:01.819
problem.  If your app is doing 
something where it is resumed, 

01:44:02.105 --> 01:44:08.584
you are revalidating, or 
rebuilding this new hierarchy  

01:44:10.205 --> 01:44:13.553
hierarchy, you might break it 
out of view.

01:44:13.554 --> 01:44:16.331
So to test this, to make sure 
that the app works in this 

01:44:16.635 --> 01:44:21.658
scenario, you need an Autofill 
service that requires a 

01:44:25.141 --> 01:44:26.922
permpermutation, the 
debugservice.  

01:44:26.923 --> 01:44:29.111
And when you launch the 
debugservice, you need to launch

01:44:30.484 --> 01:44:32.686
the Autofill and click and 
select the debugservice, you 

01:44:33.002 --> 01:44:35.312
will see the debugservice is one
of the options.  We provided 

01:44:35.633 --> 01:44:40.028
that example.  And then you can 
select this authenticate 

01:44:40.437 --> 01:44:43.208
response option on the top.  
When you go back to the app, 

01:44:43.969 --> 01:44:46.535
when you trigger out of view, 
instead of getting the data, and

01:44:46.937 --> 01:44:51.903
unlock it, you will have this 
response toa thent caught.  So 

01:44:52.198 --> 01:44:57.913
icate.  So when the user 
attempts to -- it will ask for 

01:44:58.059 --> 01:45:02.164
yes or no.  So when you click on
yes, this screenshot, the sample

01:45:02.823 --> 01:45:06.200
app where I have re-created a 
new hierarchy.  When you click 

01:45:06.201 --> 01:45:08.475
yes, you will return to your 
activity, and now from the 

01:45:08.889 --> 01:45:10.889
framework point of view, all of 
the data is different.  So they 

01:45:11.082 --> 01:45:13.813
don't know that they have the 
locked data for your activity, 

01:45:13.814 --> 01:45:18.789
for your user name field, it is 
a different ID.  They are going 

01:45:19.054 --> 01:45:22.706
to show the response again.  
When there's a click there, it 

01:45:22.707 --> 01:45:26.047
will launch the authenticate, 
and then it go backs and asks it

01:45:26.302 --> 01:45:31.851
again.  So the user is now on 
this groundhog loop where it 

01:45:31.852 --> 01:45:33.947
never goes forward, it is 
frustrating.  And the solution 

01:45:33.948 --> 01:45:37.749
for this case is to make sure 
that you don't -- you create a 

01:45:38.383 --> 01:45:42.193
view hierarchy.  So the user 
attempts to authenticate, we 

01:45:42.641 --> 01:45:45.657
will launch the authenticated 
activity, and now when we go 

01:45:45.658 --> 01:45:49.087
back, we will see the unlocked 
data and when the user selects 

01:45:49.088 --> 01:45:53.339
the data, and we are Autofill 
and everybody is going to be 

01:45:53.741 --> 01:45:57.024
happy.  These are the main tips 
I would like to give from this 

01:45:57.025 --> 01:46:00.936
session.  Make sure that you 
have your notater views, the 

01:46:01.207 --> 01:46:04.835
tess in the standard service, 
and the work with usera thent

01:46:11.547 --> 01:46:14.169
authentication.  I have links 
for all of these talks for 

01:46:14.484 --> 01:46:17.422
Autofill service as well that 
explains all of the apps that 

01:46:17.423 --> 01:46:19.423
I'm using.  That's it.  Thank 

01:46:23.017 --> 01:46:29.808
you for coming, and I'm supposed
to say that the QA will be out. 

01:46:29.809 --> 01:46:35.785
I have 25 seconds before I'm 
going to be gonged  out it. 

01:46:35.786 --> 01:46:37.917
SPEAKER: SPEAKER: Do you want to
say anything else, or are you 

01:46:37.918 --> 01:46:40.548
done? 
SPEAKER: We are done, I guess. 

01:46:41.006 --> 01:46:42.608
SPEAKER: Thank you. 
SPEAKER: Thank you to everybody 

01:46:42.609 --> 01:46:44.609
that played the game

01:48:12.538 --> 01:48:14.538
today.  $1

03:02:22.390 --> 03:02:24.639
did.
And we will assume that the 

03:02:25.111 --> 03:02:28.101
users are able to touch the 
device, or they can see what is 

03:02:28.281 --> 03:02:31.250
on the screen.  That turns out 
not to be true.

03:02:40.235 --> 03:02:42.235
So these assumption

03:02:44.192 --> 03:02:47.098
s assumptions helps people with 
disabilities to overcome

03:02:54.999 --> 03:02:56.346
obstacles.
Not what they are interested in 

03:02:56.347 --> 03:02:57.687
or what they are actually able 
to do.

03:02:57.688 --> 03:03:03.111
And so the way Android does 
accessibility is it depends on 

03:03:03.311 --> 03:03:07.553
the entire ecosystem.  So we 
were directly on Android, and we

03:03:07.554 --> 03:03:11.665
-- we build a lot of the core of
it.  But we really depend on the

03:03:11.666 --> 03:03:13.216
entire ecosystem to make this 
work.

03:03:13.217 --> 03:03:15.217
So the accessibility 

03:03:18.070 --> 03:03:24.839
framework is able to handle a 
lot of low-level features, like 

03:03:25.248 --> 03:03:28.599
magnification, you are not able 
to build it into every app, if 

03:03:28.600 --> 03:03:32.220
you do, we will have a nightmare
experience.  And that is handled

03:03:32.221 --> 03:03:38.039
down close to the graphics 
level, you want to magnify 

03:03:39.000 --> 03:03:42.439
things.  Accessibility 
developers who work on services,

03:03:42.440 --> 03:03:45.822
TalkBack, select to speak, they 
build these plugin services and 

03:03:45.823 --> 03:03:48.696
the idea is that they generally 
have a particular type of user 

03:03:48.697 --> 03:03:51.080
in mind, they will go through 
and really understand what those

03:03:51.600 --> 03:03:53.600
users need, what their 
challenges are, and

03:03:56.846 --> 03:03:59.960
try to build something that 
works for them.  

03:03:59.961 --> 03:04:02.708
But they cannot do everything on
their own, they need to get 

03:04:02.936 --> 03:04:04.886
information from, somebody who 
is blind, you need to be able to

03:04:04.887 --> 03:04:07.718
speak what is on the screen.  We
need to find that out from the 

03:04:07.878 --> 03:04:11.067
apps what is going on in the UI,
and that is where we really need

03:04:11.431 --> 03:04:13.431
the help of the ecosystem and 

03:04:17.764 --> 03:04:21.453
all developers.
So as a general model, we have 

03:04:21.454 --> 03:04:28.006
these plugin services, like 
switch access, voice access, and

03:04:28.007 --> 03:04:31.935
Braille, they are able to query 
an API for the accessibility 

03:04:33.069 --> 03:04:35.582
service to tell me what Windows 
are on the screen and the views 

03:04:35.880 --> 03:04:38.852
inside the windows, what text is
where, what actions are 

03:04:38.853 --> 03:04:42.901
available on each view.
And then they can present this 

03:04:42.902 --> 03:04:46.316
to the user in whatever way they
need to.  The user does not 

03:04:46.317 --> 03:04:51.728
touch the screen, it do do you 
want to perform this control, 

03:04:51.729 --> 03:04:55.530
that control, that gesture.  And
we need the apps to provide the 

03:04:55.531 --> 03:05:00.649
right semantics to do that.
And the -- I want to try to make

03:05:00.877 --> 03:05:03.360
this as simple as possible.  So 
a few things to keep in mind.

03:05:03.750 --> 03:05:07.441
One is just to make sure that 
the information that you are 

03:05:07.702 --> 03:05:13.153
presenting to all your users is 
as visible as possible.

03:05:13.154 --> 03:05:21.077
So color -- luminous contrast is
the most importantsingle thing 

03:05:21.361 --> 03:05:24.224
you can do in that regard to 
make sure you are not using gray

03:05:25.351 --> 03:05:30.330
on slightly lighter gray to 
convey information. Thatt  can 

03:05:30.331 --> 03:05:32.849
look cool, but it is difficult 
for people to use.  And the 

03:05:32.850 --> 03:05:35.451
second is to prefer controls to 
be big and 

03:05:38.492 --> 03:05:40.492
simple.
It is sometimes -- you want to 

03:05:40.770 --> 03:05:44.783
cram a bunch of stuff to get as 
much options as possible for 

03:05:45.055 --> 03:05:48.101
users, and you want to figure 
out what is important for your 

03:05:48.515 --> 03:05:53.334
users can simplify things for 
everybody, and for somebody who 

03:05:53.606 --> 03:05:57.780
does not have perfect dexterity 
to use it.  We can have a 48 by 

03:05:58.442 --> 03:06:01.851
48 density independent pixel, 
that's a guideline we can throw 

03:06:01.852 --> 03:06:05.132
out there, to have a uniform 
standard throughout the 

03:06:06.001 --> 03:06:11.422
ecosystem.  That is set as a min
height and width thing.

03:06:11.423 --> 03:06:15.301
Next is to label toff  stuff. 
If you are conveying information

03:06:15.555 --> 03:06:18.632
visually, if you have a button, 
just have a label and the labels

03:06:19.020 --> 03:06:22.577
should be precise and concise.  
So the users who cannot see the 

03:06:22.859 --> 03:06:25.973
screen can find out what they 
do.

03:06:25.974 --> 03:06:31.931
And so people ask when in the 
project should I consider 

03:06:32.135 --> 03:06:34.325
accessibility? Early and often 
is the short answer.  The longer

03:06:34.558 --> 03:06:36.743
answer is, in each of these 
different phases of your 

03:06:37.018 --> 03:06:39.057
project, there is something that
you can do.

03:06:39.058 --> 03:06:44.568
So in design, ZERL generally the
things that I mentioned, keeping

03:06:44.569 --> 03:06:49.037
the contrast, control size, 
labels, that will get you a long

03:06:49.322 --> 03:06:52.495
way.  If you are using standard 
UI patterns.

03:06:52.496 --> 03:06:56.066
But the more innovation you are 
doing on your user interface, 

03:06:56.067 --> 03:06:59.583
the further away you get from 
the stuff we built into the 

03:06:59.584 --> 03:07:03.747
Android framework.  At that 
point, it is really helpful if 

03:07:03.947 --> 03:07:05.947
you can think

03:07:07.217 --> 03:07:11.446
broadly about the full range of 
users who use your project.  So 

03:07:11.447 --> 03:07:14.225
the more gesture type things 
that you are doing, you want to 

03:07:14.226 --> 03:07:18.565
make sure that you are taking 
into account how people are 

03:07:18.566 --> 03:07:22.501
going to interact with that that
cannot perhaps perform that 

03:07:22.786 --> 03:07:25.137
gesture.
  During development, we have a 

03:07:25.399 --> 03:07:30.820
series of APIs, Qasid is going 
to show those, and we have 

03:07:31.160 --> 03:07:34.093
testing tools that show, as much
as possible, we can automate the

03:07:34.515 --> 03:07:37.628
processes to make sure you are 
handling these things correctly.

03:07:40.935 --> 03:07:43.803
So just to explain a bunch of 
stuff about the complexities of 

03:07:44.082 --> 03:07:48.991
users and things you can do, you
can forgive me for saying making

03:07:49.336 --> 03:07:52.953
accessibility easy, and I said 
making, and not that we already 

03:07:53.161 --> 03:07:57.195
made.  In general, we want this 
to be easy.  We want to make 

03:07:57.419 --> 03:08:00.953
sure that we are doing that, if 
we are not, please let us know. 

03:08:01.344 --> 03:08:03.432
If you are using standard

03:08:08.088 --> 03:08:13.431
com POFE components and ways, it
should not be complicated, like 

03:08:13.432 --> 03:08:15.841
how a particular user is going 
to use your project.  It is 

03:08:15.842 --> 03:08:18.738
something like, what does this 
control do?

03:08:18.739 --> 03:08:25.800
And as you evolve, it gets less 
easy.  But we want to make sure 

03:08:26.512 --> 03:08:29.867
that the incremental work that 
you do for accessibility grows 

03:08:29.868 --> 03:08:32.350
more slowly than the work you 
need to do to serve whatever 

03:08:33.404 --> 03:08:36.450
users you have in mind to begin 
with.

03:08:36.451 --> 03:08:41.084
And now, Qasid is going to talk 
about a way to think about the 

03:08:41.359 --> 03:08:45.448
development process for folks 
with disabilities. 

03:08:45.449 --> 03:08:50.775
SPEAKER: Hey, my name is Qasid, 
I work for Phil on the Android 

03:08:51.032 --> 03:08:53.178
accessibility team.
Let's get into it.  If you 

03:08:53.468 --> 03:08:55.677
really think about it, there are
two ways that your user can 

03:08:55.955 --> 03:09:00.449
interact with your application.
Right?

03:09:00.450 --> 03:09:03.992
The first is consuming 
information.  This can be 

03:09:04.160 --> 03:09:09.951
content that the user wants, or 
indications how to use the UI.  

03:09:09.952 --> 03:09:15.240
And the way we use information 
varies from user to user.  I 

03:09:15.555 --> 03:09:18.712
look at it on a screen and I 
process it that way.  A TalkBack

03:09:19.844 --> 03:09:24.424
user will hear a description of 
what is on the screen from a 

03:09:24.904 --> 03:09:27.864
device speech synthesizer.  Once
a user understood and consumed 

03:09:28.454 --> 03:09:31.457
that information and combined it
for the real world, they can act

03:09:31.675 --> 03:09:34.171
on your application to make it 
do things.  And just like 

03:09:34.433 --> 03:09:37.643
consuming information, this 
varies dramatically from user to

03:09:38.028 --> 03:09:39.613
user and from circumstance to 
circumstance.

03:09:39.614 --> 03:09:42.647
And now these actions can be 
something like a tap, a swipe, a

03:09:44.855 --> 03:09:46.855
scroll.
It can be speaking into a 

03:09:47.030 --> 03:09:51.598
device, some users drive the 
whole device with a single 

03:09:52.430 --> 03:09:54.430
button.
And now once you combine these 

03:09:54.711 --> 03:09:57.461
two modes of interaction, we see
this cycle of action and 

03:09:57.462 --> 03:10:00.848
information, right?
And we can see if any part of 

03:10:01.267 --> 03:10:09.373
this is su subtly broken for a 
user, the application is 

03:10:09.374 --> 03:10:12.483
useless.  How to make it 
complete for every single user? 

03:10:12.484 --> 03:10:15.946
That seems like a daunting task,
like we mentioned before, the 

03:10:16.416 --> 03:10:20.293
way the users interact with our 
devices varies a lot and trying 

03:10:20.818 --> 03:10:24.178
to understand those users is a 
complicated task.  If you don't 

03:10:24.820 --> 03:10:27.596
try to do anything through 
non-standard, you trust us, and 

03:10:27.842 --> 03:10:31.424
you use APIs, it is a pretty 
easy task.  I will show you some

03:10:31.425 --> 03:10:34.224
trivial things that you can do, 
that are fundamental, and push 

03:10:34.389 --> 03:10:36.389
your accessibility to be much 
better than it otherwise would

03:10:40.765 --> 03:10:43.148
have been.
Let's start with the way that we

03:10:43.410 --> 03:10:45.809
consume information.  And I 
started this search application,

03:10:46.085 --> 03:10:48.704
a novel idea.  And the way that 
I'm indicating this is a search 

03:10:48.970 --> 03:10:53.182
UI is that, by that magnifying 
glass on the little line.  You 

03:10:53.444 --> 03:10:57.655
will notice something, that's a 
very light shade of gray on a 

03:10:58.090 --> 03:11:02.383
slightly lighter shade of gray. 
That is going to be difficult 

03:11:02.542 --> 03:11:05.079
for people who -- for a lot of 
people to see, because that is a

03:11:05.362 --> 03:11:08.585
very low contrast ratio.  It is 
frustrating and downright 

03:11:09.243 --> 03:11:11.539
impossible for others.  So we 
should darken it up.

03:11:11.540 --> 03:11:16.086
And just like that, many other 
people are able to use our 

03:11:16.366 --> 03:11:18.366
application.  The goal is to 
make sure that all of the 

03:11:18.614 --> 03:11:22.356
information is visible in terms 
of size and contrast.  If you 

03:11:23.231 --> 03:11:25.231
want concrete guidelines on 
this, you can go to the material

03:11:25.348 --> 03:11:29.141
website and we can give you 
contrast ratios under 

03:11:29.404 --> 03:11:31.848
circumstances and the hard 
numbers in terms of size, like 

03:11:32.338 --> 03:11:36.368
the 48 by 48.
  That was straightforward, but 

03:11:36.369 --> 03:11:40.047
there are dramatic variations in
how we consume information. For 

03:11:40.683 --> 03:11:43.903
those situations, what we want 
you to do is to fill in the 

03:11:44.170 --> 03:11:46.908
blanks for our frameworks.  What
we mean is that your framework 

03:11:46.909 --> 03:11:50.206
can infer a lot from the view 
hierarchy from the code we have 

03:11:50.750 --> 03:11:52.769
written, but there are some 
situations where we need your 

03:11:53.024 --> 03:11:56.495
help.  I will show you.  Let's 
assume that I'm a TalkBack user 

03:11:56.496 --> 03:12:00.418
and I'm putting a finger on a 
screen to hear the description 

03:12:01.251 --> 03:12:05.013
of what is under my finger.  I 
put my finger on the mag finying

03:12:05.891 --> 03:12:08.378
icon, but there is no way for 
our frameworks to figure out 

03:12:08.802 --> 03:12:11.406
what that means, because there 
is no text associated with that.

03:12:11.407 --> 03:12:16.453
It is essentially an arrangement
of pixels on a screen.  You have

03:12:16.454 --> 03:12:18.454
to fill in the

03:12:21.227 --> 03:12:25.882
blanks as app developers, you do
it by a label, search.  Make 

03:12:25.883 --> 03:12:29.487
your labels concise and to the 
point.  If it indicates an 

03:12:29.640 --> 03:12:34.818
action, make it a simple action 
word.  And this is easy, in this

03:12:35.089 --> 03:12:39.095
situation, set the content 
description, make sure it is 

03:12:39.911 --> 03:12:43.764
localized, because accessibility
users do not only exist in 

03:12:43.918 --> 03:12:46.328
America.  And now that the user 
can understand what is generally

03:12:46.329 --> 03:12:50.085
happening on screen, let's make 
sure we allow them to act on our

03:12:50.086 --> 03:12:54.054
device or application 
appropriately.

03:12:54.055 --> 03:12:59.198
So I decided to add a new 
feature, clear text button, 

03:12:59.471 --> 03:13:04.383
instead of having a back space, 
you can reset and start stip 

03:13:04.384 --> 03:13:10.224
typing again.  That's a tiny 
butpen, buttonbutton, if you 

03:13:10.225 --> 03:13:13.055
have a fine motor disability, 
that is going to be impossible 

03:13:13.056 --> 03:13:17.190
for them to tap.  We will make 
it bigger.  This works for many 

03:13:17.191 --> 03:13:19.491
more users.  And make sure that 
your controls are simple and

03:13:25.506 --> 03:13:27.973
large.
I added another feature, a 

03:13:27.974 --> 03:13:30.167
history feature.  You can type 
in the queries and see the 

03:13:30.474 --> 03:13:34.091
results of the query again.
And now if you end up swiping on

03:13:34.357 --> 03:13:38.586
that, any of these items, you 
will see a trash icon indicating

03:13:38.967 --> 03:13:42.584
this can be removed from 
history.  If you continue 

03:13:43.768 --> 03:13:46.689
swiping, that item will be 
removed from history.  This is 

03:13:46.884 --> 03:13:50.268
great and all, but it is a 
pretty custom-built gesture 

03:13:50.844 --> 03:13:53.554
overloaded on to an item.  It is
going to be hard for our 

03:13:53.827 --> 03:13:56.148
frameworks to detect.  So you 
guys are going to have to fill 

03:13:56.701 --> 03:14:00.107
in the blanks for our frameworks
and for accessibility users.  

03:14:01.006 --> 03:14:03.566
You can do that by adding an 
action, or an accessibility 

03:14:03.798 --> 03:14:07.858
action.  And all you have to do 
here is specify a user-facing 

03:14:07.859 --> 03:14:12.820
label or description of that 
action, a simple verb, and the 

03:14:13.107 --> 03:14:15.652
code that should be executed 
when the action is performed.  

03:14:16.085 --> 03:14:17.994
You can do that with the 
accessibility action API, but we

03:14:17.995 --> 03:14:22.234
are adding something to the 
Android X library which allows 

03:14:22.490 --> 03:14:25.911
you to do it in a single line 
call, with a Lambda and a string

03:14:25.912 --> 03:14:28.798
passed in.
So I have shown you a way of 

03:14:29.335 --> 03:14:31.271
thinking about accessibility 
issues and how to address them, 

03:14:31.272 --> 03:14:33.483
but you still need to know how 
to find these issues and how to 

03:14:33.484 --> 03:14:36.447
verify that you have actually 
fixed them.  This is where Casey

03:14:36.629 --> 03:14:45.335
comes in.  Casey? 
CASEY BURKHARDT: Thanks, Qasid. 

03:14:45.336 --> 03:14:49.093
I'm Casey Burkhardt, I'm a 
software engineer on Google's 

03:14:49.649 --> 03:14:51.706
accessibility engineering team, 
and I lead the development on 

03:14:52.282 --> 03:14:55.324
accessibility testing tools for 
Android.  So as Qasid pointed 

03:14:55.690 --> 03:14:58.607
out, there are many 
accessibility issues that 

03:14:58.908 --> 03:15:02.390
actually fixes our fairly 
straightforward from the 

03:15:02.599 --> 03:15:04.981
development side and can improve
the accessibility of your app.  

03:15:04.982 --> 03:15:08.532
The big question, though, is how
it  do we go about finding those

03:15:09.132 --> 03:15:11.514
issues? There are three types of
accessibility testing today I 

03:15:11.784 --> 03:15:16.353
would like to cover.  Automated 
testing, use of automated tools,

03:15:16.713 --> 03:15:20.138
manual testing, where you use 
Android's accessibility services

03:15:20.709 --> 03:15:27.175
itself to understand the user's 
experience, and and  and user 

03:15:27.448 --> 03:15:30.664
testing, where you bring in 
users with disabilities and get 

03:15:30.966 --> 03:15:32.544
their feedback using your 
application.

03:15:32.545 --> 03:15:35.536
My section of the talk focuses 
on automation because, right 

03:15:35.783 --> 03:15:39.917
now, we see that as one big area
where we can make vast 

03:15:40.696 --> 03:15:43.786
improvements across the 
ecosystem if we have some 

03:15:44.264 --> 03:15:46.548
developers' cooperation using 
these tools.  So automated 

03:15:46.817 --> 03:15:50.616
accessibility testing, until 
several years ago, on Android 

03:15:51.180 --> 03:15:56.528
didn't really exist.  Around 
2015, we launched a project 

03:15:56.919 --> 03:15:59.723
known as Android's accessibility
test framework, which is an 

03:16:00.063 --> 03:16:03.281
Android and Java library that 
houses a lot of detection logic 

03:16:03.282 --> 03:16:06.457
for the more common 
accessibility issues that we can

03:16:06.851 --> 03:16:12.670
identify within an app's UI, a 
rule-based fashion.  This is an 

03:16:12.928 --> 03:16:16.645
open source project, so you can 
find it on GitHub.  And 

03:16:18.196 --> 03:16:22.221
essentially what it is aiming to
do is to look at the app's UI at

03:16:22.222 --> 03:16:25.889
runtime and find the 
automateable, mechanical aspects

03:16:26.085 --> 03:16:30.500
of accessibility that we see 
day-to-day that affect users the

03:16:30.501 --> 03:16:34.828
most.  We can find the common 
issues that Qasid discuss, so we

03:16:34.829 --> 03:16:38.265
can find an UI that is missing a
label for a screen reader, we 

03:16:38.541 --> 03:16:41.361
can identify low-contrast text 
and images.  We can tell you if 

03:16:41.651 --> 03:16:47.369
you have lickable clickable 
items within an UI that meet the

03:16:47.370 --> 03:16:50.099
minimums for touch target 
guidelines, and we identify a 

03:16:50.368 --> 03:16:53.249
number of various other 
implementation-specific issues, 

03:16:53.519 --> 03:17:00.469
and the core testing library ATF
is growing constantly to find 

03:17:00.759 --> 03:17:04.117
new and more interesting issues.
  We have taken this library, 

03:17:04.280 --> 03:17:08.093
integrated it with common 
developer end points, tools that

03:17:08.094 --> 03:17:11.534
you will use commonly throughout
the development life cycle and 

03:17:11.802 --> 03:17:13.426
you can leverage throughout your
project.

03:17:13.427 --> 03:17:17.549
I want to talk through some of 
those integrations today and how

03:17:18.128 --> 03:17:20.980
you can use them and get started
with them quickly.  So first and

03:17:20.981 --> 03:17:25.421
foremost, we have integrations 
with two test frameworks that 

03:17:25.422 --> 03:17:28.024
are commonly used throughout 
unit and UI tests on Android 

03:17:28.306 --> 03:17:33.561
apps.  The first is Espresso, 
and Robolectric.  The idea with 

03:17:34.291 --> 03:17:38.512
these integrations of ATF is 
they will piggy back on top of 

03:17:40.605 --> 03:17:46.084
your existing tests.  You have a
test that loads, runs UI with 

03:17:46.085 --> 03:17:50.756
the application, and inserts a 
state.  During the phase of your

03:17:50.757 --> 03:17:59.164
tests, if you used Espresso or 
Robolectric, if we identify an 

03:17:59.165 --> 03:18:03.100
accessibility issue that we 
believe will affect a user with 

03:18:03.767 --> 03:18:06.532
a disability's ability to 
interact with your application, 

03:18:07.289 --> 03:18:09.754
we will failure the existing 
test.  If you have strong 

03:18:10.226 --> 03:18:12.226
testing coverage with 

03:18:15.200 --> 03:18:19.667
Robolectric or Espressoo, 
enabling this will allow you to 

03:18:19.883 --> 03:18:23.523
get a decent amount of coverage 
in accessibility testing for 

03:18:24.362 --> 03:18:26.362
your app.
  And each framework offers what

03:18:26.746 --> 03:18:29.201
is known as an accessibility 
validator.  And this is an 

03:18:29.852 --> 03:18:33.504
object that you can use to 
essentially configure ATF's 

03:18:33.757 --> 03:18:37.584
behavior inside of your tests.
  So you can configure ATF, for 

03:18:38.089 --> 03:18:41.319
example, to not fail your test 
and to log something, and we've 

03:18:41.590 --> 03:18:46.418
run into an issue.
And you can set up ATF to crawl 

03:18:46.924 --> 03:18:49.597
from the root of your view 
hierarchy when you perform a 

03:18:49.854 --> 03:18:53.927
view action, rather than 
validating the item that was 

03:18:53.928 --> 03:18:56.913
interacted with for additional 
coverage.  You can use 

03:18:56.914 --> 03:18:59.345
accessibility validator to set a
white list.  If you want to turn

03:18:59.894 --> 03:19:04.382
on accessibility tests within 
your Robolectric or Espresso 

03:19:05.055 --> 03:19:08.957
tests, you can do so.  You can 
maintain a green presubmit and 

03:19:09.212 --> 03:19:12.149
burn through issues you know 
about by creating and 

03:19:13.203 --> 03:19:16.191
registering these white lists 
for issues.

03:19:16.192 --> 03:19:23.205
And how you leverage these in 
Espresso and Robolectric, you 

03:19:23.466 --> 03:19:26.432
will call accessibility 
checks.enable within your test 

03:19:26.704 --> 03:19:29.583
set-up.  This is going to 
trigger our global assertion to 

03:19:29.584 --> 03:19:34.177
run whenever you use a view 
action within an Espresso test. 

03:19:34.444 --> 03:19:39.940
So in this case, the view action
is run, runs a performant 

03:19:40.705 --> 03:19:44.689
evaluation on the view 
interacted with and its sub 

03:19:45.014 --> 03:19:49.752
tree.  Accessibility val  
validator is returned through 

03:19:50.210 --> 03:19:53.434
enable.  So if you need to 
customize the enable, you can do

03:19:53.912 --> 03:19:56.437
so through the object return in 
that call.

03:19:56.438 --> 03:20:00.058
Within Robolectric, it is 
slightly different.  Instead of 

03:20:00.333 --> 03:20:03.666
calling accessibility 
checks.enable, it is annotation,

03:20:04.091 --> 03:20:07.395
and it will annotate the test 
method or class that you would 

03:20:07.737 --> 03:20:11.613
like to enable accessibility 
testing within.  It allows you 

03:20:13.276 --> 03:20:17.054
using shadow view.clickon for 
you to interact with your 

03:20:18.902 --> 03:20:25.458
elements.  Avoid the temptation 
to use view perform click, do it

03:20:25.459 --> 03:20:26.702
correctly.
  It is available in a different

03:20:26.703 --> 03:20:30.136
class that mirrors the same API,
you can use for accessibility 

03:20:30.696 --> 03:20:34.899
Util and make data calls there 
to configure your behavior.

03:20:34.900 --> 03:20:38.176
So, in addition to integrations 
with these automated test 

03:20:38.408 --> 03:20:41.294
frameworks, we built a separate 
stand-alone tool, known as 

03:20:41.768 --> 03:20:45.036
accessibility scanner.
And this is a direct integration

03:20:45.350 --> 03:20:49.377
of ATF, and accessibility 
scanner acts s scanner as as a 

03:20:49.704 --> 03:20:52.499
front-end for the library.  It 
will evaluate

03:20:58.083 --> 03:21:00.805
the fore ground for the device. 
It installs the accessibility 

03:21:01.080 --> 03:21:04.792
scanner, you turn it on, it will
add a floating button to the 

03:21:05.091 --> 03:21:07.943
device's screen, you will open 
up the application, navigate to 

03:21:07.944 --> 03:21:10.357
the UI you would like to 
evaluate, and just tap the 

03:21:10.722 --> 03:21:13.231
button.  What you see is 
essentially a report that 

03:21:13.522 --> 03:21:16.312
describes the ways in which you 
can improve that UI for 

03:21:16.580 --> 03:21:18.580
accessibility.
And again, these will mirror the

03:21:19.042 --> 03:21:25.620
same types of issues that ATF 
and Espresso and Robolectric can

03:21:25.621 --> 03:21:27.994
identify as well.  It is easy to
take these reports from 

03:21:28.688 --> 03:21:31.748
accessibility scanner and share 
them with your team, you can 

03:21:31.982 --> 03:21:37.209
export to email or drive.  It 
does not require technical 

03:21:37.454 --> 03:21:39.499
skills, you don't need a debug 
version of your application, or 

03:21:39.933 --> 03:21:44.313
a user debug device, you don't 
need to -- you don't need to do 

03:21:44.537 --> 03:21:48.117
anything special to set it up.  
It works on any app or any 

03:21:48.665 --> 03:21:52.801
Android device running 
Marshmallow or later.  And you 

03:21:53.179 --> 03:21:55.195
don't have to have a lot of 
experience related to 

03:21:55.467 --> 03:21:59.371
accessibility.  Each issue that 
accessibility scanner can 

03:21:59.791 --> 03:22:01.791
identify comes with extensive

03:22:04.528 --> 03:22:06.528
documentation that gives you 
background, and how to think 

03:22:06.720 --> 03:22:09.201
about the issue during the 
design, development, and test 

03:22:09.481 --> 03:22:12.227
phases of your project.
And so please do download 

03:22:12.750 --> 03:22:14.861
accessibility scanner, it is 
something that I highly 

03:22:14.862 --> 03:22:22.180
recommend we use when we build 
UI.  G.co/accessibilityscanner 

03:22:22.663 --> 03:22:24.234
will take you to the Play Store 
page.

03:22:24.235 --> 03:22:27.843
And one last integration I would
like to cover today, this is a 

03:22:27.844 --> 03:22:32.020
new one.  We launched it a few 
months ago.  An integration of 

03:22:32.021 --> 03:22:34.689
the accessibility testing 
framework and the Play Store 

03:22:35.489 --> 03:22:38.080
developer console's pre-launch 
report.  For those of you who 

03:22:38.081 --> 03:22:43.020
have not used pre-launch report 
yet, it is a great tool to get a

03:22:43.472 --> 03:22:48.061
sanity check during the launch 
or release process for an APK to

03:22:48.062 --> 03:22:51.922
the Play Store on an open or 
closed channel.  The way it 

03:22:52.199 --> 03:22:56.421
works, you upload an APK, 
pre-launch report takes that 

03:22:56.422 --> 03:22:59.331
APK, instrument it, and push it 
to a number of different 

03:22:59.332 --> 03:23:05.571
physical devices in a lab.
And it will crawl your app, 

03:23:05.759 --> 03:23:09.456
essentially on these different 
devices and generate reports 

03:23:09.855 --> 03:23:13.127
that include findings about 
performance, security, and now 

03:23:13.409 --> 03:23:16.274
accessibility as well.
And so ATF is running along side

03:23:16.962 --> 03:23:20.422
pre-launch report as it is 
crawling your application and 

03:23:20.936 --> 03:23:22.936
generating reports at each stage
in the crawl, and it is taking 

03:23:23.541 --> 03:23:25.928
all of the results and 
deduplicating them.  So if you 

03:23:26.105 --> 03:23:31.696
would like to check this out, it
is available now in Play Store 

03:23:32.084 --> 03:23:34.206
developer console under release 
management, you should be able 

03:23:34.475 --> 03:23:37.391
to see accessibility results for
any APK that you have uploaded 

03:23:37.662 --> 03:23:41.513
to the store since fairly early 
in July.  So please do cleck 

03:23:41.776 --> 03:23:47.083
that out.  Here is what it looks
like, to give you an idea.  The 

03:23:47.349 --> 03:23:50.464
main entry point for an APK, it 
will show you the categories of 

03:23:50.631 --> 03:23:52.631
issues we have identified.  It 
will show you the clusters of 

03:23:52.794 --> 03:23:56.575
issues, you can click on any one
of those and it will show you 

03:23:56.993 --> 03:24:00.061
detame  tails about the problem.
So in this case, we are pointing

03:24:00.261 --> 03:24:04.050
out an issue related to touch 
target size.  In the column on 

03:24:04.314 --> 03:24:08.488
the left, you see many examples 
of the same de-duplicated issue 

03:24:09.159 --> 03:24:11.504
across different crawls of the 
application that prelaunch 

03:24:11.927 --> 03:24:14.371
report has performed.  You have 
access to the same additional 

03:24:14.372 --> 03:24:17.301
documentation here as well, too.
So if you are not familiar with 

03:24:17.694 --> 03:24:19.645
a particular issue, the learn 
more link will give you the 

03:24:19.646 --> 03:24:24.903
details you need to resolve it, 
regardless of the stage your 

03:24:24.904 --> 03:24:26.904
project is currently

03:24:29.790 --> 03:24:32.370
in.
I want to wrap up by talking 

03:24:32.834 --> 03:24:34.639
about an accessibility testing 
strategy.  We talked about 

03:24:34.640 --> 03:24:37.803
automation, but we did not go 
into manual testing and user 

03:24:38.081 --> 03:24:40.474
testing.  And these are equally 
important.

03:24:40.475 --> 03:24:43.284
Automation is great because it 
helps you find issues very 

03:24:43.692 --> 03:24:46.944
quickly, early in the 
development cycle, especially if

03:24:46.945 --> 03:24:51.379
you have good test coverage with
our automated tools.  So think 

03:24:51.964 --> 03:24:54.784
about automation as a way to 
catch very common issues 

03:24:55.503 --> 03:24:58.422
quickly, but not as a way to 
guarantee that your app or your 

03:24:58.688 --> 03:25:02.008
UI is fully accessible.
To really understand your user's

03:25:02.009 --> 03:25:05.859
experience, to get that -- to 
get that awaterness of how your 

03:25:06.118 --> 03:25:08.691
UI is performing within an 
accessibility service, we really

03:25:09.190 --> 03:25:12.445
highly recommend you go and 
actually turn on TalkBack, turn 

03:25:12.846 --> 03:25:16.639
on switch Access, try them out, 
learn how to use them, and gain 

03:25:17.151 --> 03:25:19.686
a true understanding of your 
user's experience.  The way I 

03:25:19.687 --> 03:25:22.568
like to describe it is 
automation is capable of finding

03:25:22.918 --> 03:25:25.341
a missing label for a screen 
reader.  But we can't really 

03:25:25.638 --> 03:25:27.750
tell you if your labels make 
sense.

03:25:27.751 --> 03:25:30.389
So really only by understanding 
and putting yourself in the 

03:25:30.897 --> 03:25:34.468
user's shoes and understanding 
their experience, we are asking 

03:25:35.210 --> 03:25:37.451
users directly about their 
experience.  Only then can you 

03:25:37.720 --> 03:25:41.297
truly understand how accessible 
your UI is for users with 

03:25:42.142 --> 03:25:45.075
various different disabilities.
  And we have found at Google, 

03:25:45.076 --> 03:25:48.716
both looking at our first party 
and third-party applications, 

03:25:48.986 --> 03:25:53.735
the most successful, the most 
highly accessible apps we see 

03:25:54.352 --> 03:25:59.442
day-to-day are the apps that 
combine multiple accessibility 

03:26:00.142 --> 03:26:02.807
testing strategies, like 
presubmit, continuous 

03:26:03.707 --> 03:26:07.623
integration, and a process for 
manual accessibility testing and

03:26:07.875 --> 03:26:10.667
bringing users in and 
understanding the perspective of

03:26:10.932 --> 03:26:12.747
an accessibility application.  
These are things to consider.  

03:26:12.748 --> 03:26:16.416
With that, I will hand it back 
to Qasid that will talk about 

03:26:16.687 --> 03:26:18.812
the newer APIs for expressing

03:26:24.018 --> 03:26:26.018
app semantics.
SPEAKER: I'm back, say you have 

03:26:26.240 --> 03:26:29.899
adopted APIs that I talked about
earlier and the testing that 

03:26:31.328 --> 03:26:34.840
Qasid suggested.  And you have a
pretty good foundation of 

03:26:34.841 --> 03:26:36.772
accessibility in your 
application, and the more you 

03:26:36.773 --> 03:26:40.834
are testing, the more you 
realize that there are holes in 

03:26:41.008 --> 03:26:43.154
your experience, that is 
breaking the cycle of 

03:26:43.421 --> 03:26:46.226
interaction that I mentioned 
earlier.  We are adding API and 

03:26:46.579 --> 03:26:49.552
new things to make it so those 
holes get plugged.

03:26:49.553 --> 03:26:54.699
So the first thing is clickable 
spans, the clickable bits of 

03:26:54.700 --> 03:27:01.203
text.  Before API 26, non-url 
spans were fundamentally 

03:27:01.763 --> 03:27:05.225
inaccessible.  And developers 
had to write a bunch of hackie 

03:27:06.252 --> 03:27:11.395
work arounds to make these 
things work.  In the latest 

03:27:11.833 --> 03:27:16.648
alpha of the AndroidX library, 
we made it all the way back to 

03:27:18.004 --> 03:27:20.267
API 19.  You can look out for 
that, too.

03:27:20.268 --> 03:27:26.943
And there are users that make 
apps behave like -- they have 

03:27:27.336 --> 03:27:30.497
their own life cycle and so 
forth.  They are accessibility 

03:27:31.421 --> 03:27:33.874
panes.  You need to develop your
frameworks that present these 

03:27:34.135 --> 03:27:36.852
differently to the user. And the
way you do that is by

03:27:41.184 --> 03:27:44.773
passing a string to the 
accessibility pane title on the 

03:27:45.037 --> 03:27:47.503
view.  Make sure it is concise 
and localized.  This is 

03:27:47.504 --> 03:27:53.805
available on API 28, and we 
added this API in the latest 

03:27:53.960 --> 03:27:58.083
AndroidX alpha that will work 
all the way back to API 19.

03:27:58.084 --> 03:28:03.303
And finally, there are headings.
These are used by TalkBack users

03:28:03.907 --> 03:28:06.674
to navigate through sections 
quickly and easily.

03:28:06.675 --> 03:28:10.793
And the way you specify that is 
exactly what you probably 

03:28:10.794 --> 03:28:14.394
expect, pass in a boolean to set
an accessibility heading on a 

03:28:14.395 --> 03:28:20.624
view.  This is also available in
28, and we added this to the 

03:28:21.992 --> 03:28:24.552
latest alpha of the AndroidX 
library that will work all the 

03:28:24.752 --> 03:28:26.752
way back to '19.
Now it is back to

03:28:32.138 --> 03:28:34.224
Phil.  
SPEAKER: Circlng back to the 

03:28:34.960 --> 03:28:37.998
title of this, making 
accessibility easy.  We really 

03:28:38.434 --> 03:28:41.942
want this to be easy.  The only 
way that this -- that 

03:28:45.042 --> 03:28:47.865
user's didn't disabilities are 
going to be able to access the 

03:28:48.123 --> 03:28:50.123
ecosystem.  
Sometimes you see somebody that 

03:28:50.151 --> 03:28:54.020
wants to go the extra mile and 
dig into the app and all the 

03:28:55.246 --> 03:28:57.844
issues around accessibility, 
that is great but not every 

03:28:58.142 --> 03:29:01.037
developer can do that.  We need 
to make it as easy as possible 

03:29:01.290 --> 03:29:03.881
so everyone can build it into 
their workflow in a natural way.

03:29:04.105 --> 03:29:07.300
So certainly, to get the basics,
we want it to be 

03:29:08.559 --> 03:29:10.454
straightforward.
So if you have reasonable 

03:29:10.455 --> 03:29:12.455
contrast, to make the 
information visible to everyone,

03:29:13.041 --> 03:29:17.091
you have simple controls, you 
are using labels.  We want that 

03:29:19.085 --> 03:29:22.028
to kind of get you almost all 
the way, and some of the other 

03:29:22.406 --> 03:29:25.657
APIs, like Qasid was describing,
should be able to handle the 

03:29:27.260 --> 03:29:29.627
specialized situations.  If you 
have a full screen fragment 

03:29:29.906 --> 03:29:33.005
transition, you can use the pane
title to make sure that that 

03:29:33.408 --> 03:29:39.130
gets handled the same way a 
window transition would.

03:29:39.131 --> 03:29:44.384
So we want it to be easy.  That 
means, if it is hard, we have 

03:29:44.385 --> 03:29:47.224
messed up and we should fix 
that.

03:29:47.225 --> 03:29:51.589
And we found some developers 
that really, well, the framework

03:29:52.219 --> 03:29:55.198
seems to be coming up short, I 
will engineer a workaround to 

03:29:55.466 --> 03:29:58.858
get around the problems with the
framework.  Honestly, please 

03:29:58.859 --> 03:30:03.643
don't do that.
Let us fix it, because we can 

03:30:03.910 --> 03:30:07.841
fix it at scale, and it needs to
be inside Android.  You find it 

03:30:08.022 --> 03:30:12.368
in AndroidX, you know, if you 
wanted to fix it, by all means, 

03:30:12.369 --> 03:30:14.949
upload it to AndroidX and we 
would be happy to accept fixes. 

03:30:15.207 --> 03:30:20.519
We want it fixed centrally so we
can get a consistent experience 

03:30:20.753 --> 03:30:22.753
throughout the

03:30:24.443 --> 03:30:28.301
whole COREMS.  ecosystem. 
If you are engineering a custom 

03:30:28.579 --> 03:30:30.579
solution, if an engineer at a 
different company is going to do

03:30:30.737 --> 03:30:32.737
this work, and the answer is no,
then there is probably something

03:30:33.791 --> 03:30:35.791
wrong.
So please reach out if we are 

03:30:35.974 --> 03:30:40.255
messing this up.  You can file 
bugs on AOSP, you can ask 

03:30:40.988 --> 03:30:45.310
questions on Stack Overflow.  
But we much prefer to, we 

03:30:45.311 --> 03:30:48.784
probably prefer to get the 
feedback that something is 

03:30:49.039 --> 03:30:52.022
difficult so we can get an 
elegant solution that everyone 

03:30:52.023 --> 03:30:55.181
can use.  Some of the things 
that Qasid just presented before

03:30:55.454 --> 03:30:59.551
he did that, the effort required
to do some of these things 

03:30:59.752 --> 03:31:03.462
really require, like, learning a
new API surface.  We wanted to 

03:31:03.854 --> 03:31:07.450
condense everything we could to 
one line.  So we are trying to 

03:31:07.451 --> 03:31:10.178
present solutions that really 
are -- if you have this thing, 

03:31:10.372 --> 03:31:13.140
here is one line of code, all 
you need.  If you get to 

03:31:13.141 --> 03:31:15.881
something that seems like it 
should be one line of code and 

03:31:15.882 --> 03:31:21.248
it is not, let us know.
And another place you can go for

03:31:21.249 --> 03:31:24.682
other resources is to 

03:31:29.109 --> 03:31:31.109
G.co/Androidaccessibility, 
there's a link for accessibility

03:31:31.231 --> 03:31:36.187
testing, how to get to 
accessibility scanner, and the 

03:31:36.188 --> 03:31:41.692
test framework project that 
Qasid described.  That is 

03:31:42.084 --> 03:31:45.453
available on open source on 
GitHub if you are interested in 

03:31:45.729 --> 03:31:47.729
that.
  So, I really appreciate your 

03:31:48.049 --> 03:31:52.385
time, I would be very happy -- 
if you have feedback for us, and

03:31:52.658 --> 03:31:55.674
you think things should be 
easier than they are, we will be

03:31:55.844 --> 03:31:57.844
having office hours for a while 
this afternoon.  We would love 

03:31:58.553 --> 03:32:02.526
to talk to you.  Thanks a lot 
for coming and for your efforts 

03:32:03.739 --> 03:32:08.969
and hopefully making a 
consistent ecosystem of 

03:32:09.274 --> 03:32:11.274
accessible apps.  

03:32:16.708 --> 03:32:17.665
Thanks.
[ Applause ]. 

03:32:17.666 --> 03:32:19.666
SPEAKER: Everyone, the next 
session will begin in 10 

03:32:28.450 --> 03:32:30.450
minutes.
Coming up next: Bundling an App 

03:32:32.487 --> 03:32:34.487
in an Instant by Wojtek 
Kalicinski, Ben Weiss.

03:34:14.923 --> 03:34:16.923
12C3W4R50I6R7B8G9SDS

03:41:36.203 --> 03:41:38.203
Wojtek

03:50:27.708 --> 03:50:31.922
SPEAKER: Hello, everyone.
So today at the keynote, you 

03:50:32.310 --> 03:50:36.065
heard that we are unifying the 
developerdeveloper experience 

03:50:36.066 --> 03:50:39.876
for instant apps and Android app
bundles.  

03:50:39.877 --> 03:50:42.622
My colleague, Ben, and I are 
going to talk about how that 

03:50:42.896 --> 03:50:44.210
works for the developer 
perspective.

03:50:44.211 --> 03:50:47.012
So instant apps, it is a 
technology that we introduced a 

03:50:47.217 --> 03:50:51.295
little over two years ago at 
Google I/O.  It lets you give 

03:50:51.682 --> 03:50:56.068
your users a native Android app 
experience without them having 

03:50:56.638 --> 03:50:58.730
to explicitly go and install the
app.

03:50:58.731 --> 03:51:03.438
And now how that works is you 
split up your app, into smaller

03:51:08.180 --> 03:51:12.919
pieces, and the user can reach 
that via a link.  And now to 

03:51:12.920 --> 03:51:17.894
QUET your apps small enough and 
to launch it instantly, instant 

03:51:18.813 --> 03:51:28.446
apps for the first time used a 
technology in Lollipop, called

03:51:29.940 --> 03:51:33.627
split APKs.  And they are able 
to use the smallest and most 

03:51:34.185 --> 03:51:36.974
optimized version of the app to 
the user's device.  In order to 

03:51:37.436 --> 03:51:40.511
do that, the build system, the 
Gradle Android build system that

03:51:40.512 --> 03:51:44.582
you have that you build your 
apps with, built all of those 

03:51:45.427 --> 03:51:50.960
split APKs locally, bundled them
in a zip file, and you upload 

03:51:51.357 --> 03:51:55.293
that to the Play Store they can 
choose from the set of APKs and 

03:51:56.032 --> 03:51:59.088
deliver them to the devices.
  To do that, the developer had 

03:51:59.380 --> 03:52:02.221
to do some significant 
refactoring in your African  

03:52:02.582 --> 03:52:05.990
apps.  The project structure of 
the instant app, as we looked to

03:52:06.350 --> 03:52:08.350
one year ago, probably looked 
something like this.  First of 

03:52:08.911 --> 03:52:12.100
all, you have to take all of 
your base application code and 

03:52:12.382 --> 03:52:15.769
move it from the application 
module into a base feature.

03:52:15.770 --> 03:52:23.032
And then you had to split your 
app into feature month featuree

03:52:27.517 --> 03:52:31.742
modules containing the feature 
of your activities.  And then 

03:52:31.743 --> 03:52:36.717
you have almost two dummy 
modules, application and instant

03:52:37.803 --> 03:52:44.497
ach  app.  So the APK, and the 
instant app zip bundle that you 

03:52:44.771 --> 03:52:47.177
upload to a separate track in 
the Play Store.  This was not 

03:52:47.455 --> 03:52:51.284
ideal.  As I said, it required 
significant work.  Your project 

03:52:51.926 --> 03:52:56.314
no longer looked simple.
And at the same time this year, 

03:52:56.839 --> 03:52:58.839
we introduced a new

03:53:01.169 --> 03:53:07.517
publishing format called the 
Android App Bundle.  This 

03:53:07.518 --> 03:53:12.790
contains metadata about the 
targeting of the resource 

03:53:12.791 --> 03:53:19.225
resources, native libraries, and
so on, and it contains some of 

03:53:19.832 --> 03:53:21.780
the module information for a 
module called dynamic feature.  

03:53:21.781 --> 03:53:26.327
I called it a publishing 
feature, we use it to upload a 

03:53:27.730 --> 03:53:29.650
bundle, telling the Play Store 
everything about your app to 

03:53:29.651 --> 03:53:33.158
play.  And together with Google 
play dynamic delivery, we are 

03:53:33.605 --> 03:53:40.206
able to serve an optimized set 
of APKs to user devices.  In 

03:53:40.207 --> 03:53:42.341
order to do that, there's a big 
difference.  Because it happens 

03:53:42.342 --> 03:53:47.147
on the server side on the Play 
Store, we need to be able to 

03:53:47.407 --> 03:53:50.187
sign the app.  If you use an 
Android App Bundle, you

03:53:53.717 --> 03:53:57.003
need to enable sending by Google
play.  

03:53:57.004 --> 03:54:00.906
If you allow us to store the key
for you, it is more secure.  

03:54:01.110 --> 03:54:03.859
There is another benefit, 
because we can transform the 

03:54:04.420 --> 03:54:06.869
APKs and make them more 
optimized, as we develop more 

03:54:07.349 --> 03:54:13.392
apt miizations on the Play Store
side, what we bring to the users

03:54:13.646 --> 03:54:17.546
is more optimized from 
compressed libraries.  It makes 

03:54:17.892 --> 03:54:20.725
sense to move instant apps to 
this new model.  Why build all 

03:54:21.510 --> 03:54:24.557
the APKs locally and not be able
to optimize them further on the 

03:54:24.883 --> 03:54:29.280
Play Store? What if we could use
the new App Bundle for the  mat 

03:54:29.531 --> 03:54:31.484
to deliver instant app 
experience to our users?

03:54:31.485 --> 03:54:36.478
So let me tell you how to go 
back to that simpler, better 

03:54:36.803 --> 03:54:38.803
project structure for your

03:54:40.585 --> 03:54:42.585
instant apps.

03:54:46.750 --> 03:54:49.159
If you have -- we need to go 
back to the simple project you 

03:54:49.335 --> 03:54:54.253
use as your build your APK.
So we no longer need the instant

03:54:55.011 --> 03:54:57.634
app plugin, everything we need 
is baked into the application 

03:54:58.078 --> 03:55:01.588
plugin that can now build 
bundles.  We don't need the base

03:55:01.965 --> 03:55:04.268
feature anymore.
Instead, we can move our code 

03:55:04.524 --> 03:55:06.902
back to the application, where 
we will be using that to build 

03:55:07.976 --> 03:55:12.413
our unified bundle artifact.
And so, again, with feature 

03:55:13.085 --> 03:55:16.166
modules, we replace them with 
dynamic features that work in 

03:55:16.167 --> 03:55:19.708
the App Bundle world.
So ultimately, we want something

03:55:19.709 --> 03:55:25.198
simple.  You can have your 
application module with any 

03:55:25.461 --> 03:55:28.734
additional library modules that 
you need.  Optionally, we have 

03:55:28.994 --> 03:55:33.446
dynamic features that can be 
downloaded on demand, adding 

03:55:33.447 --> 03:55:37.451
functionality alt run time.  We 
have single piece of metadata 

03:55:37.452 --> 03:55:41.379
that tells the Play Store that 
this is instant bundle app 

03:55:41.647 --> 03:55:44.702
enables.  That would be great if
you can upload it to the Play 

03:55:44.971 --> 03:55:48.603
Store and all have it downloaded
on the install and instant track

03:55:48.971 --> 03:55:55.053
which, what we  is what we are 
aiming for.

03:55:55.054 --> 03:55:59.708
We are testing it, but you are 
not able to upload it just yet. 

03:55:59.981 --> 03:56:03.312
If you want to try it right now,
create two project variants, it 

03:56:03.582 --> 03:56:06.988
is in the simple project still. 
In one of the variants, enable 

03:56:07.358 --> 03:56:09.358
the metadata, enable the instant

03:56:12.579 --> 03:56:16.015
app for your bundle and use the 
other variant to build it 

03:56:16.016 --> 03:56:23.865
without that entry, or man  
manifest.  Still one app, one 

03:56:24.470 --> 03:56:26.982
codebase, and you may have to do
that in order to upload to the 

03:56:27.833 --> 03:56:29.798
Play Store.
  There is another white list n 

03:56:29.799 --> 03:56:33.737
, if you want to use dynamic 
features in order to let your 

03:56:34.297 --> 03:56:38.288
users download them on demand as
they run the app, this is on a 

03:56:38.289 --> 03:56:40.412
white list for developers who 
want to test that.  You can 

03:56:40.904 --> 03:56:44.969
apply online, however, you are 
currently not able to publish 

03:56:44.970 --> 03:56:48.568
your app to the production track
if you have more than one 

03:56:48.930 --> 03:56:50.930
module.
Okay, so how to try it yourself 

03:56:51.107 --> 03:56:55.171
right now.  First thing you need
to do is use the new Android 

03:56:55.449 --> 03:56:59.252
Studio 3.3 that is currently on 
the channel.  If you are 

03:56:59.704 --> 03:57:04.279
creating a project from scratch,
you can select this check box.  

03:57:04.942 --> 03:57:07.988
We will collect the modules with
the necessary metadata in there 

03:57:07.989 --> 03:57:12.886
already.  That's what it looks 
like, thin  in the base 

03:57:13.124 --> 03:57:16.935
manifest, you enable it, you are
good to go.  If your app is 

03:57:17.634 --> 03:57:22.313
compliant with the other instant
app restrictions, such as file 

03:57:22.753 --> 03:57:24.753
size, you will be able to 

03:57:27.628 --> 03:57:30.419
publish an instantly enabled 
bundle.  If you have a project 

03:57:30.420 --> 03:57:35.464
that you use to enable an App 
Bundle, you can use the wizard 

03:57:36.423 --> 03:57:41.444
to allow a bundle.  This will 
instant enable your base module 

03:57:41.753 --> 03:57:45.200
if you haven't done so.
  And next, we will build an App

03:57:45.333 --> 03:57:47.640
Bundle through Gradle, through 
the bundle release command 

03:57:47.641 --> 03:57:51.906
instead of assembly release, or 
through the wizard and the UI.

03:57:52.345 --> 03:57:56.529
By the way if you are using our 
Android dev summit app at this 

03:57:56.936 --> 03:58:01.617
conference, it has been built 
exactly as an instant enable App

03:58:01.846 --> 03:58:04.514
Bundle.  We publish that to our 
channels on the Play Store, what

03:58:04.752 --> 03:58:07.814
you are using right now is 
exactly what I'm talking about.

03:58:08.090 --> 03:58:12.941
And it has been great.  It is 
has greatly simplified what we 

03:58:13.244 --> 03:58:15.646
need to do in order to have that
working.

03:58:15.647 --> 03:58:22.039
Let me invite on stage Ben who 
will tell you about best 

03:58:23.299 --> 03:58:28.408
practices for modeler 
modularizing this copy of your 

03:58:28.409 --> 03:58:31.272
app.  Round of applause, please.
SPEAKER: Thank you very much.  I

03:58:31.598 --> 03:58:37.138
will talk a little bit about 
discoverability of your instant 

03:58:37.329 --> 03:58:40.431
apps.  One of them you saw, the 
try now functionality.  I will 

03:58:40.971 --> 03:58:46.627
talk about this.  Try now is 
basically a second bud  button 

03:58:46.898 --> 03:58:50.865
on the Play Store that allows 
users to download and run the 

03:58:50.866 --> 03:58:53.427
app without having to 
permanently install it on the 

03:58:53.841 --> 03:58:55.893
device.  That's a great 
experience that we can easily 

03:58:56.256 --> 03:59:00.205
see how it works, you can go to 
Play Store now and check it out 

03:59:00.908 --> 03:59:04.873
through the Android dev summit 
app, and you can get to it 

03:59:05.181 --> 03:59:07.908
directly from the dev landing 
page.  If you don't have an url 

03:59:08.178 --> 03:59:11.359
associated with your app, that 
works as well.  You don't have 

03:59:11.749 --> 03:59:14.615
the restrictions that you have 
to map to your urls anymore.

03:59:14.616 --> 03:59:17.328
How do you do that? That is 
basically it.  I think that 

03:59:17.851 --> 03:59:20.479
everybody has this somewhere in 
their application, the main 

03:59:20.730 --> 03:59:25.470
launcher.  You don't have to do 
anything else other than add the

03:59:25.471 --> 03:59:29.799
instant metadata that you were 
shown earlier, there is nothing 

03:59:29.800 --> 03:59:33.238
else you have to do in order to 
be eligible for the try now 

03:59:33.638 --> 03:59:36.355
experience.  What is your app, 
you want to have your app 

03:59:36.704 --> 03:59:42.497
available with an url mapping?
That allows you basically to 

03:59:42.895 --> 03:59:46.903
access your app through any url 
that you have associated with 

03:59:47.202 --> 03:59:49.865
your app.  The first thing you 
have to do, you have to verify 

03:59:49.866 --> 03:59:52.598
if you own the domain.  In order
to do that, you

03:59:56.324 --> 04:00:00.979
upload an asset links JSON file.
There are resources where you 

04:00:00.980 --> 04:00:03.730
can identify what you uploaded 
is correct and the mapping you 

04:00:03.731 --> 04:00:07.692
have is correct as well, you can
share the link with anyone and 

04:00:07.693 --> 04:00:11.337
they can open the app straight 
away.  I will show you how that 

04:00:11.338 --> 04:00:13.243
works where we started with the 
main launcher. 

04:00:13.244 --> 04:00:19.862
You have to set a second filter 
with it set to true.  That tells

04:00:20.597 --> 04:00:23.094
the Play Store it should check 
for the asset links JSON file on

04:00:23.095 --> 04:00:28.806
the url provided below.  Then 
you add the action view, the 

04:00:29.066 --> 04:00:32.564
browseable default, this is what
I want to use as the default to 

04:00:32.565 --> 04:00:36.479
view this url.  You have the 

04:00:40.892 --> 04:00:46.563
scenes for https, or http, and 
multiple path prefixes for 

04:00:46.893 --> 04:00:50.751
multiple activities.  If you 
want to use a default activity, 

04:00:50.752 --> 04:00:53.546
whether it come from try now or 
the home screen, is the metadata

04:00:54.654 --> 04:00:59.212
here, the tag for the filter.  
This is the default url, this is

04:00:59.213 --> 04:01:02.262
where I want users to come in 
initially.  Like I said earlier,

04:01:02.263 --> 04:01:04.731
if you don't have an url in the 
first place, you don't have to 

04:01:05.007 --> 04:01:07.981
do this.  If you have to have an
url mapping, then this is the 

04:01:07.982 --> 04:01:11.356
way to go.
And it is not a lot of work to 

04:01:11.357 --> 04:01:15.919
do.  It gives you the -- it uses
the experience that you can 

04:01:16.497 --> 04:01:19.222
share any link that leads to 
your app and any user can open 

04:01:19.223 --> 04:01:22.116
the app straightaway without 
having to install it 

04:01:22.514 --> 04:01:25.518
permanently.  And I think for a 
conference, it is a good use 

04:01:25.519 --> 04:01:29.427
case to have an app that you use
once, you don't have to fully 

04:01:31.478 --> 04:01:33.757
install install it.  You have a 
couple features, like 

04:01:34.017 --> 04:01:36.703
notifications, you have to 
install the app.  But it is fair

04:01:36.704 --> 04:01:40.326
enough to have the experience 
that you can have straight away 

04:01:40.727 --> 04:01:42.717
without the first steps that are
necessary.

04:01:42.718 --> 04:01:47.175
And also there is another thing 
that we use for app bundles in 

04:01:47.447 --> 04:01:51.252
order to download code 
dynamically.

04:01:51.253 --> 04:01:55.595
So going back to the previous 
section is basically, you can do

04:01:55.860 --> 04:02:00.102
that with the zip and feature 
instant apps.  What we are going

04:02:00.103 --> 04:02:03.862
on forward now, you have to 
ship, as the App Bundle, and you

04:02:03.863 --> 04:02:09.881
have to use dynamic feature 
modules in order to use the play

04:02:10.320 --> 04:02:13.860
core library.  This allows you 
to download features dynamically

04:02:14.143 --> 04:02:16.429
on demand, not during the 

04:02:19.651 --> 04:02:21.651
instillation,

04:02:22.908 --> 04:02:25.940
andapp.  And it does all the 
heavy lifting.  If you say to 

04:02:25.941 --> 04:02:29.659
the library, download this, it 
connects to the Play Store, 

04:02:29.660 --> 04:02:32.506
downloads it, puts it in the 
right place.  For instant apps, 

04:02:32.507 --> 04:02:37.549
it puts it into the shared catch
there, and then it installs it 

04:02:37.948 --> 04:02:40.274
on the device permanently.  So 
how does it work?

04:02:40.275 --> 04:02:46.858
So you add it as a dependency, 
available from Google.com, you 

04:02:47.079 --> 04:02:50.104
can use it in your project.  You
create a 

04:02:52.034 --> 04:02:54.034
splitinstallmanagerfactory, 
create a request where you can 

04:02:54.043 --> 04:02:57.967
install one or multiple modules 
at the same time.  Those module 

04:02:58.504 --> 04:03:00.865
names have to match the module 
name that you set for the 

04:03:01.358 --> 04:03:04.907
dynamic feature module directly 
in the manifesto module.  You 

04:03:05.183 --> 04:03:07.550
build it, and you tell the 
manager to start the 

04:03:08.419 --> 04:03:11.096
instillation.
And that's all the code you need

04:03:11.352 --> 04:03:16.994
to get started with it.  There's
a couple things to go around it,

04:03:17.266 --> 04:03:20.759
I will go into it in a second.  
If you don't want to do 

04:03:20.932 --> 04:03:25.473
instillation straight away, you 
can do deferred instillation.  

04:03:25.474 --> 04:03:29.473
So you have the app, the user is
in a flow where they are buying 

04:03:29.824 --> 04:03:32.645
something, so they have logged 
in and then they started the 

04:03:33.501 --> 04:03:37.500
purchase process and you want to
download a payment module, for 

04:03:38.003 --> 04:03:40.208
example.  You can do that 
deferred, or during the flow 

04:03:41.935 --> 04:03:45.965
with had  the user is in that, 
you can do the instillations.

04:03:46.198 --> 04:03:52.452
  And so the deferred -- it is 
not done straight away, the 

04:03:52.642 --> 04:03:55.404
system says I'm cleaning up and 
this is where the module is 

04:03:55.673 --> 04:03:58.909
removed.  And you can also 
cancel the instillation requests

04:03:58.910 --> 04:04:02.591
where, for any reason, you want 
to cancel that, there's an 

04:04:02.757 --> 04:04:05.292
option to do it.
And there's a listener that you 

04:04:05.880 --> 04:04:09.606
can set on the manager that is 
my preferred way of listening 

04:04:10.490 --> 04:04:14.754
for the updates, the split 
install state update listener.  

04:04:15.262 --> 04:04:18.413
That's quite a word.  And 
usually what happens, the happy 

04:04:19.597 --> 04:04:24.423
path is you trigger an install, 
the app starts with Pending and 

04:04:25.096 --> 04:04:28.426
goes to downloading, downloaded,
installing, installed.  That's 

04:04:28.696 --> 04:04:33.762
the happy path, for an app or 
module that is small enough -- 

04:04:34.092 --> 04:04:37.401
that required user confirmation.
If you go into that state, you 

04:04:37.658 --> 04:04:42.526
will get the -- you will get 
some information that you can 

04:04:43.310 --> 04:04:46.819
start the intent with, to show a
dialogue whether they want to 

04:04:47.098 --> 04:04:50.023
confirm or deny whether they 
want to install the module at 

04:04:50.024 --> 04:04:56.127
this point.  If they con firm  
firm they want to install, you 

04:04:56.417 --> 04:05:01.218
continue down the happy path.  
The instllation can be canceled 

04:05:01.219 --> 04:05:04.484
in the cancelling state, and for
a couple reasons, it can fail.  

04:05:04.769 --> 04:05:08.026
So that's the path where you 
have to handle all those states.

04:05:08.027 --> 04:05:14.268
We do have a sample al -- 
available for that, I will share

04:05:14.475 --> 04:05:19.669
the urls later in the session so
you can see how it works.

04:05:19.670 --> 04:05:23.884
I talked about file size.
The limit that triggers, for 

04:05:24.175 --> 04:05:28.356
example, the -- that requires 
user confirmation coincides with

04:05:28.613 --> 04:05:33.404
a couple apps for instant apps 
in general and for dynamic 

04:05:33.795 --> 04:05:37.751
delivery.
One of the things we do is we 

04:05:38.048 --> 04:05:42.227
don't take the installed size, 
or the downloaded size, as the 

04:05:42.532 --> 04:05:46.610
main factor anymore.
So if your app or device has a 

04:05:46.803 --> 04:05:49.831
file size that is larger than 
the limit, that is all right.  

04:05:49.832 --> 04:05:53.629
We can take the download size 
into account.  You get 

04:05:53.630 --> 04:05:55.654
compression over the wire, 
that's what we take into account

04:05:55.925 --> 04:05:58.953
for that.  And this we show in 
the play console as well.  You 

04:05:58.954 --> 04:06:02.653
will see the download size is 
this, you are right above or 

04:06:02.950 --> 04:06:05.304
below the threshold.  And 
dynamic feature modules do not 

04:06:05.745 --> 04:06:08.969
fall into the initial download 
size as well.  What falls into 

04:06:09.408 --> 04:06:12.965
it is basically your base module
and your instant entry module.  

04:06:12.966 --> 04:06:15.805
If you have more than one, that 
you can have, it is the base 

04:06:16.193 --> 04:06:20.454
module and the largest instant 
entry module.  And those, under 

04:06:20.670 --> 04:06:24.283
a white list, have to be less 
than 10MB.

04:06:24.284 --> 04:06:30.872
Dynamic feature modules that you
download later on or other 

04:06:31.174 --> 04:06:36.559
instant entry modules do not 
fall into the 10 instant MB in 

04:06:36.825 --> 04:06:41.863
the first place.  If your app is
larger than 10MB, you do not 

04:06:42.148 --> 04:06:45.068
have the instant app benefits, 
you are not discoverable to 

04:06:45.333 --> 04:06:50.382
users as an instant app.  If it 
is less than 10 or more than  

04:06:50.383 --> 04:06:52.535
4MB, your app can be seen and 
used as an instant app.  So you 

04:06:53.527 --> 04:06:56.546
can access it through try now, 
on the Play Store, and also you 

04:06:56.547 --> 04:07:02.064
can is show it in the web 
banners and share it viaU urls. 

04:07:02.652 --> 04:07:06.270
If your base module and your 
instant entry model is less than

04:07:07.018 --> 04:07:12.693
4MB, your app can be discovered 
from anywhere, like ads and 

04:07:13.416 --> 04:07:18.050
search results.  If you research
for Android dev summit app, you 

04:07:19.369 --> 04:07:22.763
will see that and go directly to
the instant app because it is 

04:07:23.565 --> 04:07:28.170
under the 4MB threshold.  While 
you are at it, you can continue 

04:07:29.124 --> 04:07:32.376
to modularize.  It is a tricky 
topic because it entails some 

04:07:33.182 --> 04:07:37.315
work that some people are not 
100 percent certain how that is 

04:07:33.182 --> 04:07:35.182
done best. 

04:07:36.308 --> 04:07:42.594
We recently went through the 
whole process with a project, it

04:07:42.595 --> 04:07:49.510
is called Platt, it is on GitHub
and I will talk about how we 

04:07:49.511 --> 04:07:56.601
managed to move away from a 
monolithic app to an app that 

04:07:56.602 --> 04:08:01.597
uses bundles.  It uses the same 
technology underneath for 

04:08:01.598 --> 04:08:06.030
modularizing an instant app as 
well.  So what we did is we, and

04:08:06.031 --> 04:08:12.438
most apps will do it, we created
a base module which hosts the 

04:08:12.716 --> 04:08:15.497
domain code and data so it 
shares the shared preferences, 

04:08:15.498 --> 04:08:19.539
log in, for example, some of the
repository, some persistent API 

04:08:20.404 --> 04:08:22.569
calls, and things like that.  On
top of that are different 

04:08:22.570 --> 04:08:27.791
feature modules.  Those have 
their own domain code, logic, 

04:08:27.792 --> 04:08:32.095
and the UI which is only 
displayed in this module.  And 

04:08:32.096 --> 04:08:36.196
that set up can be used for many
apps, if you have a base module 

04:08:36.197 --> 04:08:40.203
that shares information and the 
different feature modules.  I 

04:08:40.204 --> 04:08:43.924
will share a little bit more in 
depth what we did.

04:08:43.925 --> 04:08:50.695
So we initially had an app, a 
module that most people had, a 

04:08:51.584 --> 04:08:55.233
monolith.  If we shift to an 
APK, that is fine.  There is no 

04:08:55.234 --> 04:08:58.566
way to go into the whole 
modularization part if we have, 

04:08:58.799 --> 04:09:03.077
in the end, one single 
monolithic app, APK, that we 

04:09:03.078 --> 04:09:06.049
ship to our users.  And since we
were considering going towards 

04:09:07.616 --> 04:09:10.081
dynamic features and app 
bundles, we move everything into

04:09:10.377 --> 04:09:13.437
a base, with the shared 
dependencies, that means 

04:09:13.710 --> 04:09:16.897
everything that we include, 
coming from whatever 

04:09:17.342 --> 04:09:19.847
repositories externally as well 
as a couple of local, 

04:09:20.622 --> 04:09:26.177
third-party APIs and libraries 
that we have forked and worked 

04:09:27.020 --> 04:09:29.700
with.
After we tested this, we worked 

04:09:29.701 --> 04:09:33.176
on features that we extracted 
from the app itself.  The first 

04:09:33.877 --> 04:09:36.664
thing we started with is an 
about screen.  Well, an about 

04:09:36.928 --> 04:09:40.498
screen is kind of untangled from
most of the stuff within the 

04:09:40.729 --> 04:09:45.159
app.  It is a good starting 
point for getting our hands wet 

04:09:45.469 --> 04:09:49.067
with -- what does it actually 
entail to make the dynamic 

04:09:49.434 --> 04:09:52.785
feature module, how we make it 
do all the things.  Then we did 

04:09:52.786 --> 04:09:55.973
a search screen, and then we 
have two new sources that we 

04:09:56.868 --> 04:10:00.110
extracted into the dynamic 
feature modules as well.  They 

04:10:00.457 --> 04:10:02.980
all depend on the app, and 
everything shares the 

04:10:02.981 --> 04:10:05.012
information through that as 
well.  You can read up more 

04:10:05.599 --> 04:10:10.273
in-depth on a blog post on the 
Android developer's medium 

04:10:10.542 --> 04:10:14.853
publication, and we also have 
information available on instant

04:10:15.462 --> 04:10:20.191
apps on general, and on App 
Bundle on dynamic features, and 

04:10:20.623 --> 04:10:25.065
instant apps without urls.  The 
instant app scene is outside 

04:10:25.579 --> 04:10:27.312
during office hours to share 
information and knowledge.  If 

04:10:27.313 --> 04:10:30.301
you have questions, please come 
there.  And with that, thank you

04:10:30.692 --> 04:10:32.692
very much.

04:10:40.171 --> 04:10:42.171
[ Applause ] 
Coming up next: Android Slices 

04:12:46.520 --> 04:12:49.786
Best Practices by Arun 
Venkatesan, Artur Tsurkan.

04:12:46.520 --> 04:12:50.500
SPEAKER: Hi, everyone.  My name 

04:12:53.516 --> 04:12:56.215
is Artur, I'm a product manager 
on Android. 

04:12:56.216 --> 04:13:01.858
SPEAKER: My name is Arun. 
SPEAKER: We're going to tell you

04:13:02.362 --> 04:13:08.176
about Android Slices, part of 
Android pie.

04:13:08.177 --> 04:13:11.432
So we're going to start an 
introduction to Android Slices, 

04:13:11.808 --> 04:13:14.227
user experiences, best practices
in constructing your Slices, and

04:13:14.592 --> 04:13:19.931
more details on search indexing 
best practices, and finally 

04:13:19.932 --> 04:13:22.908
through the -- what we have been
running over the course of the 

04:13:23.203 --> 04:13:26.760
summer, the important developer 
gotchas for when you start 

04:13:27.138 --> 04:13:29.787
building slices whether  when 
they are available.

04:13:29.788 --> 04:13:31.818
We will start by reintroducing 
get SNOOT  slices.

04:13:31.819 --> 04:13:38.890
Before we into it, I wanted to 
remind you of some resources.  

04:13:38.891 --> 04:13:43.660
We introduced slices at Google 
I/O, you can find documentation 

04:13:43.661 --> 04:13:47.686
at g.co/slices.  
And you can look at our I/O 

04:13:48.760 --> 04:13:53.293
session video, Android slices, 
building interactive results for

04:13:53.294 --> 04:13:57.559
Google search and that will give
you information on building 

04:13:58.265 --> 04:14:02.414
slices, building a custom 
template and an UI for your 

04:14:02.855 --> 04:14:07.016
slice .  Slices are a new way 
for you to present remote app 

04:14:07.283 --> 04:14:12.523
content in Android.
Think of Slices as embeddable 

04:14:13.342 --> 04:14:16.212
app snippits that can be 
inserted inside another app or 

04:14:16.213 --> 04:14:19.391
part of a system.  Slices are 
meant to work across multiple 

04:14:19.784 --> 04:14:24.430
possible surfaces, the whole 
idea of a slice is the ability 

04:14:24.715 --> 04:14:28.834
to constrain and provide you 
with a lot of power in how you 

04:14:29.236 --> 04:14:34.173
express your app.  Slices 
contain a variety of components,

04:14:34.174 --> 04:14:36.791
including text and images, and 
they are powerful.  They are not

04:14:36.926 --> 04:14:39.970
just static pieces of content, 
they can house realtime data and

04:14:40.930 --> 04:14:44.797
interactive controls, and 
TalkBack to your app in the 

04:14:45.068 --> 04:14:48.575
interaction.  So all of these 
examples you see here are 

04:14:48.728 --> 04:14:50.979
examples of slices that you can 
build.

04:14:50.980 --> 04:14:55.107
I mention that slices can be 
embedded across a number of 

04:14:55.961 --> 04:14:59.810
contexts, and we are excited to 
be bringing them to search as 

04:14:59.811 --> 04:15:04.710
the first surface to insert 
slices.  So as they are typing 

04:15:04.711 --> 04:15:07.666
in a search on Android, you can 
enhance the predictions offered 

04:15:08.158 --> 04:15:11.205
by Google with lives, personal 
content from your apps, 

04:15:11.540 --> 04:15:13.454
constructed through the slices 
you create.  There are two types

04:15:13.455 --> 04:15:15.455
of slices you can provide

04:15:18.029 --> 04:15:21.066
in search predictions.  The 
first are app name queries, if 

04:15:21.412 --> 04:15:25.337
somebody can search is searching
for your app, you can direct 

04:15:25.894 --> 04:15:30.369
them to a canonical part of your
app.  So maybe in YouTube, you 

04:15:32.130 --> 04:15:38.372
want to get the visitors to the 
video they were watching.

04:15:38.373 --> 04:15:44.399
Or maybe you want to get beyond 
the name, and the settings app 

04:15:44.400 --> 04:15:47.533
will give them toggles for data 
usage.

04:15:47.534 --> 04:15:55.352
How do we build these slices? 
We will start with default or 

04:15:55.353 --> 04:15:58.541
app name slices.  It is easy to 
build an app name slice.  

04:15:58.542 --> 04:16:03.315
Construct it as you would.  
Android's recent updates include

04:16:03.645 --> 04:16:06.455
tooling.  When you create a 
slice, you will create a 

04:16:06.724 --> 04:16:09.555
definition in the manifest, like
this one, and the exception to 

04:16:09.556 --> 04:16:13.394
the slice provider class.  That 
provides details of how the 

04:16:13.395 --> 04:16:16.709
system can find your slice and 
what templates it offers to the 

04:16:17.061 --> 04:16:20.334
system when it does.  To make 
this slice map to your activity,

04:16:21.548 --> 04:16:25.865
or to make it map to the app 
name, you need to add the slice 

04:16:26.292 --> 04:16:30.007
content URI to the content 
activity and specify it in the 

04:16:30.254 --> 04:16:33.726
metadata field.  So this tells 
the system, this is a slice that

04:16:34.511 --> 04:16:38.271
I want to point to the main 
activity, this is the content 

04:16:38.272 --> 04:16:41.141
from which you can reference 
that slice.

04:16:41.142 --> 04:16:45.555
The implementation details for 
general terms are a little bit 

04:16:45.718 --> 04:16:47.638
different.
  So first, you actually don't 

04:16:47.639 --> 04:16:50.455
provide the same linking in an 
activity as you would have an 

04:16:54.023 --> 04:16:57.195
app name slice.
You are going to use updates to 

04:16:58.103 --> 04:17:03.370
the Firebase app indexing APIs 
to expose the content URI for a 

04:17:03.638 --> 04:17:06.932
specific set of key words.  
Using the Firebase APIs, you 

04:17:06.933 --> 04:17:10.250
would construct an indexable.  
That would have a public url, it

04:17:10.424 --> 04:17:14.501
will also have the name for that
indexable content, some very 

04:17:14.991 --> 04:17:18.475
targeted key words for users to 
find that content, a 

04:17:18.476 --> 04:17:23.016
description, and then finally 
with the update to the Firebase 

04:17:23.480 --> 04:17:27.949
app indexing APIs, you can add 
the content URI or slice URI for

04:17:28.200 --> 04:17:32.313
this indexable.  When the user 
is searching for the key words 

04:17:33.431 --> 04:17:35.920
you specified, search on Android
will replace the prediction with

04:17:36.124 --> 04:17:40.155
the slice predicted by the 
content URI in this indexable.

04:17:40.783 --> 04:17:47.200
  Finally, in order for 
indexables to be transilated 

04:17:47.201 --> 04:17:50.680
transilatedilated from the 
public urls to the content, you 

04:17:50.934 --> 04:17:54.095
need to over write the URI 
method into the slice provider. 

04:17:54.269 --> 04:17:57.335
This allows you to talk between 
the two formats in order for the

04:17:58.125 --> 04:18:01.432
URIs to be visible as a search 
prediction.  Overriing this 

04:18:02.369 --> 04:18:07.883
method allows us to provide you 
as a developer with flexibility 

04:18:08.179 --> 04:18:11.484
over what schemas are important 
to you, without attaching them 

04:18:11.485 --> 04:18:13.797
one to one.
  Now we know how to build a 

04:18:14.137 --> 04:18:17.183
slice and also how to expose it 
to search on Android.  Let's go 

04:18:17.819 --> 04:18:20.982
into a little bit more detail on
what makes a good slice, and the

04:18:21.473 --> 04:18:25.357
user experience best practices 
to keep in mind.

04:18:25.358 --> 04:18:29.331
So the first is try to focus 
your slice on one task or a set 

04:18:29.332 --> 04:18:35.185
of sight  tightly related tasks.
Avoid making your slice do too 

04:18:35.447 --> 04:18:39.776
many things, and that the 
content in the slice is coherent

04:18:40.877 --> 04:18:43.319
coherent.  So those slices are 
embeddable as a search 

04:18:43.320 --> 04:18:45.347
prediction for now, we would 
like to think that the slices 

04:18:45.348 --> 04:18:48.098
that you build should be 
reusable in many other parts of 

04:18:48.876 --> 04:18:53.992
the operating system and you 
should consider when building 

04:18:53.993 --> 04:18:57.781
your slice for those 
possibilities.  So it focuses on

04:18:57.782 --> 04:19:02.109
consuming and previewing one 
video, the slice on the right 

04:19:02.379 --> 04:19:05.040
goes to other functionality, 
like channel selection, and 

04:19:05.378 --> 04:19:08.675
stresses the definition and use 
of a slice, which we discourage 

04:19:08.940 --> 04:19:11.293
you doing. 
Try to keep interaction in the 

04:19:11.294 --> 04:19:14.635
slice lightweight, highlight the
most important features, excuse 

04:19:14.843 --> 04:19:17.677
me, and make sure that the 
actions you are presenting to 

04:19:17.678 --> 04:19:21.920
the user are using clear and 
familiar iconography so they 

04:19:22.195 --> 04:19:26.112
make sure that they understand 
what they represent.  Avoid 

04:19:26.513 --> 04:19:29.128
making it do too many things.  
So the slice on the left focuses

04:19:29.410 --> 04:19:33.068
on users listening to the 
content and play list, and 

04:19:33.435 --> 04:19:37.272
offers them the ability to like 
certain content.  The slice on 

04:19:37.273 --> 04:19:40.752
the right leans into things you 
can do with the play list items,

04:19:41.573 --> 04:19:47.121
functionality that is probably 
best within your app.

04:19:47.122 --> 04:19:49.167
When sharing your slices to 
different platforms, make sure 

04:19:49.168 --> 04:19:51.970
you are surfacing recognizable 
features and content so that 

04:19:52.236 --> 04:19:55.113
users know that they can query 
for them.  When they query for 

04:19:55.411 --> 04:19:58.183
them and see it as a prediction,
they can understand how it might

04:19:58.744 --> 04:20:02.335
have appeared for that 
particular query.  And 

04:20:05.377 --> 04:20:09.808
Arun will go into those 
principles, but try to keep that

04:20:09.809 --> 04:20:15.479
the case to avoid promotional or
advertiing content in the slice.

04:20:16.307 --> 04:20:19.153
  And finally, have the slice 
accelerate critical user 

04:20:19.436 --> 04:20:21.675
journeys and make sure that the 
slice accomplishes as much of 

04:20:22.116 --> 04:20:26.343
the user journey in line as 
possible without going into the 

04:20:26.517 --> 04:20:30.655
app.  By providing the 
information and actions that the

04:20:30.656 --> 04:20:34.446
user would need to accomplish 
that action.  So on the left, 

04:20:34.834 --> 04:20:37.113
the user has all of the stuff 
that they need to know to 

04:20:37.328 --> 04:20:39.328
understand what the slice is 
for, what kind of information it

04:20:39.711 --> 04:20:43.150
is representing, what kind of 
actions I can do with that 

04:20:43.151 --> 04:20:45.594
information, changing the song, 
adjusting the transfer or 

04:20:46.078 --> 04:20:47.978
brightness, and they don't need 
to click into the app to do 

04:20:47.979 --> 04:20:52.092
that.  The slices on the right 
are missing some critical pieces

04:20:52.427 --> 04:20:54.862
of information or critical 
component as part of

04:20:58.341 --> 04:21:02.107
that user journey and adds an 
additional layer of friction for

04:21:03.779 --> 04:21:11.520
users in completing the task 
they want to complete.

04:21:11.521 --> 04:21:14.300
There is more that Arun will go 
into. 

04:21:14.301 --> 04:21:18.442
SPEAKER: Thanks.  So here are 
the main pockets when you think 

04:21:18.836 --> 04:21:24.000
about use cases for building 
slices.  They should be 

04:21:24.177 --> 04:21:27.834
familiar, such as requesting a 
ride on a ridesharing app.  They

04:21:28.089 --> 04:21:30.089
should be 

04:21:33.216 --> 04:21:36.857
targeted.  And finally, recall 
and reengage with content that 

04:21:36.858 --> 04:21:41.776
the user has seen, rather than 
discovery use cases.

04:21:41.777 --> 04:21:44.909
Next we will see guidelines 
around the content you can 

04:21:45.395 --> 04:21:47.395
surface in slices and the data 
that needs to be

04:21:51.243 --> 04:21:55.588
indexed.
Slices should be targeted and 

04:21:55.930 --> 04:21:57.930
personalized.
  Like the video streaming app 

04:21:58.030 --> 04:22:02.226
that shows slices, when a movie 
a user is searching for is 

04:22:02.227 --> 04:22:06.191
available in the app.  The app 
can index movies, like the users

04:22:07.406 --> 04:22:13.654
previously, or it is curated 
based on the in-app behavior. 

04:22:19.231 --> 04:22:22.771
Do not create one for all the 
users in the database.

04:22:26.289 --> 04:22:28.984
  Slices should give 
information.

04:22:28.985 --> 04:22:37.116
A ridesharing app gives users 
the ability to search for rides.

04:22:37.679 --> 04:22:43.965
Create index cases based on past
history, or popular places near 

04:22:45.072 --> 04:22:47.072
the user, such as concert

04:22:53.304 --> 04:22:54.304
venues.
.

04:22:53.304 --> 04:22:57.774
Slices should give users timely 
information.

04:22:57.775 --> 04:22:59.775
Let's say that

04:23:04.989 --> 04:23:06.989
a

04:23:08.735 --> 04:23:11.218
smartphone -- 
they are likely in their home.

04:23:11.647 --> 04:23:13.984
It is not recommended to create 
an indexed slices for 

04:23:14.759 --> 04:23:18.157
controlling lights at any time 
or in any place.

04:23:18.158 --> 04:23:21.624
Here are some more examples of 
the type of app content to index

04:23:21.894 --> 04:23:29.725
and display in the slice.
A food ordering app can search 

04:23:30.044 --> 04:23:32.689
relevant realtime data, such as 
food price, when the user 

04:23:32.955 --> 04:23:36.880
fetches the slice.
Similarly, a news app slice can 

04:23:41.746 --> 04:23:44.878
index and display information to
the readers.

04:23:44.879 --> 04:23:48.252
Travel and local can allow users
to look at their content, such 

04:23:48.253 --> 04:23:51.326
as bookings and upcoming flight 
reservations.

04:23:51.327 --> 04:23:55.940
Let's now see how to keep your 
slices fresh.

04:23:55.941 --> 04:24:02.781
When a slice is indexed, the 
indexable object includes the 

04:24:03.157 --> 04:24:09.888
matadata and the cached slice.  
And in order to make sure it is 

04:24:10.179 --> 04:24:13.272
accurate and not still, you 
should set a time to live.  This

04:24:14.952 --> 04:24:19.506
is used by the Google search app
to make sure the cache is not 

04:24:20.630 --> 04:24:25.225
displayed.  In this example 
here, the time is set to 1R 

04:24:25.576 --> 04:24:30.291
expiration.  And if the slice 
has content that is not time 

04:24:32.055 --> 04:24:36.443
sensitive, use it to time to 
infinity.  In order to present 

04:24:36.444 --> 04:24:41.000
to the user, reindex the slices 
in the background when content 

04:24:41.424 --> 04:24:44.155
changes, and only when content

04:24:49.583 --> 04:24:54.558
changes.
Earlier, arrtur showed us how to

04:24:55.256 --> 04:24:58.689
index.  What are the best 
practices for key words?

04:24:58.690 --> 04:25:06.353
Limit key words to 10 per slice.
Account for likely

04:25:11.256 --> 04:25:13.253
permutations.
This is probably the most 

04:25:13.254 --> 04:25:17.924
important, avoid key word 
stuffing, use the minimum number

04:25:17.925 --> 04:25:23.462
needed per slice.  So the app 
slice will be in the search 

04:25:23.856 --> 04:25:28.107
rankings, if you use too many 
key words that the users are 

04:25:28.475 --> 04:25:30.475
tapping on.
  How do you

04:25:32.534 --> 04:25:36.684
determine if the --
the most important signal is the

04:25:37.087 --> 04:25:42.406
of times that the user uses the 
app on the device.

04:25:42.407 --> 04:25:45.716
It is also important that the 
user has viewed the content 

04:25:46.009 --> 04:25:48.655
previously and interacted with 
it.

04:25:48.656 --> 04:25:53.150
And finally, in order for us to 
know that the user interacted 

04:25:55.639 --> 04:26:00.471
with the content, log it to the 
indexing API.

04:26:00.472 --> 04:26:06.109
We conclude the session today by
sharing the lessons learned from

04:26:06.110 --> 04:26:08.110
the early access

04:26:10.732 --> 04:26:13.118
program.
  Content URI can be confusing. 

04:26:13.448 --> 04:26:18.074
Content URIs are mentioned with 
a slice and start with 

04:26:20.262 --> 04:26:26.622
content://, and deep uris start 
with http or https.

04:26:26.623 --> 04:26:33.176
Content URIs use the package 
name, or the reverse of the 

04:26:33.466 --> 04:26:35.667
package name shown in the 
example.  When you see a content

04:26:36.424 --> 04:26:46.288
URI, think of a slice.  Key 
words must be included in the 

04:26:47.056 --> 04:26:52.694
slice title or subtitle.
This is done to ensure that the 

04:26:53.571 --> 04:26:56.225
relevant content is displayed to
the user when they search for 

04:26:56.596 --> 04:26:58.863
something.
How do you handle location?

04:26:58.864 --> 04:27:03.767
So slices do not provide 
location to apps, and therefore 

04:27:05.073 --> 04:27:07.983
use the last cached location 
when displaying the slice.  

04:27:07.984 --> 04:27:10.257
Reindex the key words based on 
the last location.  And note 

04:27:10.570 --> 04:27:12.570
that indexables are not

04:27:16.348 --> 04:27:19.609
instantly updated and it leads 
to bad ratios.  So keep in place

04:27:19.610 --> 04:27:22.910
when handling location changes 
for the app, and apply those to 

04:27:24.883 --> 04:27:26.992
slices as well.
It is recommended to keep the 

04:27:28.156 --> 04:27:31.626
slice initialization short.  The
on create slice provider method 

04:27:31.627 --> 04:27:34.722
is called for all registered 
slice providers on the 

04:27:35.011 --> 04:27:38.773
application's main thread at 
lunchtime, and therefore do not 

04:27:38.774 --> 04:27:42.920
perform lengthy operations for 
the application start up will be

04:27:42.921 --> 04:27:44.921
delayed.
And if you have multiple 

04:27:45.861 --> 04:27:50.208
indexables, in the case of apps 
with multiple slices, put in all

04:27:50.209 --> 04:27:53.422
-- pass in all the indexables 
together as we showed in the 

04:27:53.701 --> 04:27:56.680
example.  And make sure to test 
the indexable.  If one is 

04:27:57.391 --> 04:28:02.945
invalid, that update called it 
failed.  So here is a small code

04:28:02.946 --> 04:28:07.800
snippet that shows it, how to 
pass multiple indexables to the 

04:28:07.801 --> 04:28:10.698
Firebase app indexing API.
So now that you have

04:28:15.652 --> 04:28:21.324
built your slice, you are 
viewing the API.

04:28:21.325 --> 04:28:24.081
That's all we have for the talk 
for today.  We want to give a 

04:28:24.377 --> 04:28:27.339
shout out for the developer, to 
the early access program.  Thank

04:28:27.640 --> 04:28:29.640
you and have a fun rest of

04:28:37.119 --> 04:28:39.119
the session.

04:28:40.978 --> 04:28:44.640
SPEAKER: We are now on break, 
this is the worst fab I have 

04:28:44.641 --> 04:28:47.794
ever seen, I recommend people 
put it on lower right and not 

04:28:47.975 --> 04:28:50.841
have it be that color, there is 
something disturbing about that 

04:28:51.091 --> 04:28:55.389
one.  It is snack time t , it 
says on the agenda.  There is 

04:28:55.682 --> 04:28:58.899
coffee as well as tea, and there
is also coffee, there is snacks,

04:28:59.270 --> 04:29:02.406
and there is coffee, and I have 
it on good authority that there 

04:29:02.672 --> 04:29:06.864
is also coffee downstairs.
There is coffee, excellent 

04:29:06.865 --> 04:29:09.157
question.
Thank you for asking.  Let's 

04:29:09.445 --> 04:29:15.488
see, we are back here at 4:00.
Building a great TV app.  

04:29:15.489 --> 04:29:19.846
There's a talk on building 
Gradle best practices.

04:29:19.847 --> 04:29:21.847
See you back here at 4:00,

04:29:29.877 --> 04:29:31.877
thanks.

04:30:15.473 --> 04:30:17.473
#

05:00:43.467 --> 05:00:44.985
#. 
SPEAKER: Hey, everyone.  Today, 

05:00:44.986 --> 05:00:47.892
we're going to talk about 
building a great Android TV app.

05:00:48.759 --> 05:00:51.740
So before we dig into the 
details, we will talk about the 

05:00:52.007 --> 05:00:55.515
ecosystem.  We continue to see 
two times year over year growth.

05:00:55.516 --> 05:01:02.017
We are investing more in smart 
TVs, desktop boxes, the 

05:01:02.018 --> 05:01:04.229
ecosystem has been pretty 
strong.  But you are all 

05:01:05.300 --> 05:01:09.269
developers, let's get into how 
you can make a good TV app.

05:01:09.270 --> 05:01:15.254
So before we talk about what the
innards of the app are, we will 

05:01:15.524 --> 05:01:18.325
talk about what the TV is and 
why it is so important.  We have

05:01:19.172 --> 05:01:21.945
living rooms and other rooms 
dedicated and focused around a 

05:01:22.442 --> 05:01:25.163
TV.  It is a pretty key point 
for users, it is the focus of an

05:01:25.561 --> 05:01:29.295
entire room.  Just think about 
that for a second.  So your app 

05:01:29.553 --> 05:01:33.562
matters.  The content matters.  
So if we try to think about what

05:01:33.563 --> 05:01:35.977
is the foundation for an app, 
the biggest piece is your

05:01:39.424 --> 05:01:41.424
content.
That is your value prop to your 

05:01:42.456 --> 05:01:46.159
users.  If you add on to that, 
usant, how do you make it easier

05:01:46.558 --> 05:01:50.438
for users to add.  You have 
great content, how can they 

05:01:50.772 --> 05:01:53.088
discover more of your content 
inside of your app.  If you want

05:01:53.587 --> 05:01:56.545
the cherry on top, think about 
the experience.  How can you 

05:01:56.759 --> 05:01:59.948
layer in all of these extra 
things to build a sweet 

05:01:59.949 --> 05:02:03.135
experience for users, no matter 
where they are in your app?

05:02:03.136 --> 05:02:07.171
We will dive into each of these 
concepts and I will call 'em out

05:02:07.661 --> 05:02:10.675
later on.  But the key take away
is they come from your content, 

05:02:10.676 --> 05:02:15.505
but they stay for your app.
So what I would like to talk 

05:02:16.030 --> 05:02:19.569
about is how to build a great TV
app.  There are three things to

05:02:23.452 --> 05:02:25.452
think 

05:02:26.824 --> 05:02:29.936
they can see other content in 
your app easily, and 

05:02:31.097 --> 05:02:33.190
distributing, making your 
content easy to find should be 

05:02:33.191 --> 05:02:35.191
as easy as making your app easy 
to

05:02:41.010 --> 05:02:45.220
find.
Let's talk about the player.  

05:02:45.941 --> 05:02:48.631
Player can make or break an app.
We will talk about this review, 

05:02:48.905 --> 05:02:50.905
feel free to 

05:02:58.069 --> 05:03:00.069
read.

05:03:02.595 --> 05:03:06.708
So the key take away for me is 
that it constantly stalls, this 

05:03:06.709 --> 05:03:10.547
app is completely frustrating.
They ended up with just a 

05:03:10.803 --> 05:03:13.930
one-star review, just because 
they are a player.  And reviews 

05:03:14.604 --> 05:03:16.818
matter, there are whole other 
talks about Google play and how 

05:03:17.239 --> 05:03:20.399
to improve your reviews.  But 
the player was the key point 

05:03:20.400 --> 05:03:24.664
here, it is the why their app 
was not as good astle could it 

05:03:24.930 --> 05:03:28.695
could be.  So it is very clear 
to users that the play back is 

05:03:28.696 --> 05:03:31.968
important.  They don't want to 
have stutters and stales, they 

05:03:31.969 --> 05:03:34.149
want to be able to watch the 
content.  And even in that 

05:03:34.413 --> 05:03:39.514
review, they talked about XHURNS
commercials and ads. They are 

05:03:39.515 --> 05:03:43.668
okay with it, they don't it  
like that they stalled.  

05:03:43.669 --> 05:03:47.987
Soshowing things that may be 
annoying, such as commercials, 

05:03:47.988 --> 05:03:51.018
as long as they play fine, users
are okay with it.  So the 

05:03:51.417 --> 05:03:54.918
player, we have many options to 
build a good player.  Media 

05:03:55.500 --> 05:03:58.150
Player is a good tool, comes out
of the box in the framework, you

05:03:58.486 --> 05:04:02.197
give it a data source, it chugs 
long in play, you can build a 

05:04:02.382 --> 05:04:04.603
great experience with media 
player.  If you have more 

05:04:04.604 --> 05:04:11.019
advanced things you want to do, 
Exoplayer is a great tool.  We 

05:04:11.493 --> 05:04:14.296
work hard to make it customable,
there's a lot of extensions.  If

05:04:14.987 --> 05:04:18.560
you are using lean back, there's
an extension that hooks into the

05:04:18.712 --> 05:04:21.444
lean back controller.  If you 
are doing ads, there's a bunch 

05:04:22.070 --> 05:04:27.911
of ad stitching support.  Lets 
talk about ads, ads are 

05:04:28.573 --> 05:04:31.266
important.  You are going to 
make money from showing ads.  

05:04:31.267 --> 05:04:35.536
And ads are just as important as
the content shown and displayed 

05:04:35.812 --> 05:04:38.970
to the user.  Focus on ads and 
make sure that adstitching 

05:04:39.273 --> 05:04:43.248
works, whether you do it server 
or client-side, these are 

05:04:43.496 --> 05:04:47.602
considerations you should make 
for your app.

05:04:47.603 --> 05:04:51.246
So there's many options for 
players, media player, 

05:04:52.838 --> 05:04:55.719
ExoPlayer, custom player.  And 
having a player is a good start.

05:04:55.992 --> 05:04:59.509
But there are things that you 
can layer in, that top part of 

05:05:00.411 --> 05:05:02.562
the pyramid, the experience, 
there are things that you can to

05:05:02.825 --> 05:05:04.970
to build an experience around 
the player to make it even 

05:05:05.136 --> 05:05:11.450
better.  So we talked about this
at I/O, play back controls.  

05:05:11.815 --> 05:05:14.747
Everyone's phone should be 
ready, here we go.  Okay, 

05:05:15.018 --> 05:05:17.586
Google, skip 5 minutes.  Okay, 
Google, pause.

05:05:17.587 --> 05:05:22.273
Okay, Google, play.  Thesep  
types of transport controls can 

05:05:22.525 --> 05:05:23.999
be commands through the 
assistant.

05:05:24.000 --> 05:05:27.311
Adding this extra little 
feature, this little nice nugget

05:05:27.579 --> 05:05:30.948
of delight, helps build that 
experience  experience for your 

05:05:34.493 --> 05:05:37.725
app.
  This works with Media Session,

05:05:38.120 --> 05:05:40.474
if you have Media Session call 
back, you get all of these 

05:05:40.742 --> 05:05:44.832
features for free.  Since I 
talked about this at I/O and 

05:05:45.123 --> 05:05:47.587
there are other talks, I will 
jam through this fast.  Pay 

05:05:47.845 --> 05:05:50.812
attention, here we go.
Boom, beautiful.

05:05:50.813 --> 05:05:56.200
Six wonderful methods: Pause, 
play, stop, seek, next, and 

05:05:56.374 --> 05:06:00.550
previous.  But in reality, 
that's a lot.  That's a lot to 

05:06:00.551 --> 05:06:05.291
think about, all of these 
different casesism if.  If you 

05:06:10.682 --> 05:06:13.074
use ExoPlayer, it can be done 
for you.  There's an extension, 

05:06:13.472 --> 05:06:18.451
all you do is connect the player
to the media session and it 

05:06:18.897 --> 05:06:24.043
works out of the box.  Making a 
media session is pretty simple, 

05:06:24.427 --> 05:06:29.093
there is documentation and talks
ants  about Media Session.  I 

05:06:29.521 --> 05:06:33.049
will not go into it, set it to 
be active, set the controller, 

05:06:33.291 --> 05:06:36.444
set anything else you need to 
set.  Set the current state, are

05:06:36.445 --> 05:06:41.000
you currently playing, what 
position are you in, set up the 

05:06:41.269 --> 05:06:44.899
media session to be what you 
need it to be, and once you have

05:06:45.352 --> 05:06:52.388
a media session and you have an 
ExoPlayer instance, connect 

05:06:53.474 --> 05:06:58.025
them.  There's the extension 
library for ExoPlayer, add in 

05:06:58.284 --> 05:07:00.284
the media session as the

05:07:02.475 --> 05:07:07.324
parameter, and set the ExoPlayer
instance.  The media session 

05:07:07.662 --> 05:07:11.660
connecter helps understand how 
to set up the call back, the 

05:07:11.661 --> 05:07:14.470
edge cases around playing and 
seeking, you don't want to go 

05:07:14.471 --> 05:07:18.446
back past the end of the video, 
rewind before the video starts. 

05:07:18.868 --> 05:07:21.793
It handles the edge cases for 
you.  In this sample, we are 

05:07:22.013 --> 05:07:24.090
saying set player, player, and 
then null.

05:07:24.091 --> 05:07:28.664
And you can set a custom play 
back refair.  There are other 

05:07:28.975 --> 05:07:31.123
customizations you can do as 
well, so if you are music app 

05:07:31.431 --> 05:07:35.383
and you have a custom playlist, 
and you want to set a different 

05:07:35.647 --> 05:07:38.513
order for how the songs go 
through the queue, you can set 

05:07:38.794 --> 05:07:44.694
up a custom queuing mechanism on
the extension.  That's it.

05:07:44.695 --> 05:07:46.695
Three wonderful lines

05:07:47.851 --> 05:07:51.469
of code, and the instance is 
taken care of for you.  All the 

05:07:51.470 --> 05:07:54.327
default behavior you would 
expect, done.

05:07:54.328 --> 05:07:59.085
So having a great player is 
great, that is one example of 

05:07:59.086 --> 05:08:02.232
how to layer thin experience to 
make the player even better.

05:08:02.233 --> 05:08:06.518
We're going to skip ahead to 
discovering content.

05:08:06.519 --> 05:08:09.433
So the whole point of 
discovering is you want users to

05:08:09.434 --> 05:08:11.982
stayp in your app, and you want 
them to discover and watch 

05:08:13.146 --> 05:08:16.568
content faster.
So let's look at this review, I 

05:08:16.889 --> 05:08:19.824
love the first sentence, they 
love love love -- so many loves 

05:08:28.522 --> 05:08:30.522
in this ach.

05:08:38.542 --> 05:08:45.207
So the key takeaway here is that
it was a five-star review, they 

05:08:45.418 --> 05:08:47.944
loved that all of the content 
was there.  It is easy to find, 

05:08:47.945 --> 05:08:50.205
they can do whatever they need 
to do inside of that app and 

05:08:50.486 --> 05:08:54.676
watch what they want to watch.  
Funny story, it is the same app 

05:08:54.677 --> 05:08:57.529
that got the one-star review.  
So even though they had a bad 

05:08:57.737 --> 05:08:59.616
player, they worked on 
discoverability and they are 

05:08:59.617 --> 05:09:03.649
able to have good review in the 
flay  Play Store.

05:09:03.650 --> 05:09:08.142
So how can we make content 
discoverable? Everything happens

05:09:08.791 --> 05:09:13.432
in threes, that's a rule of 
comedy, and a really good rule 

05:09:13.433 --> 05:09:17.510
in life.  And discoverability 
also happened  happens in 

05:09:17.770 --> 05:09:21.073
threes.  We can work in in-app 
browsing, search with the 

05:09:21.566 --> 05:09:23.969
assistant, and the home screen. 
We can start with in-app 

05:09:24.408 --> 05:09:26.885
browsing, there's a beautiful 
library, Lean Back.  If you have

05:09:27.176 --> 05:09:30.614
done TV development, you are 
very familiar with it.  It is a 

05:09:31.005 --> 05:09:33.852
templated UI system where you 
can plugin data and it works on 

05:09:34.005 --> 05:09:36.673
building the UI for you, so you 
don't have to worry about the 

05:09:36.962 --> 05:09:40.844
focus handling and the user 
input.  You can just, this is 

05:09:40.845 --> 05:09:43.566
the content we have, and it will
show it for you.  It is not just

05:09:43.769 --> 05:09:49.734
how to browse content, though, 
leanback also works and showss 

05:09:50.615 --> 05:09:53.592
details.  So there's a bunch of 
information about content, you 

05:09:54.403 --> 05:09:58.701
have duration, content rating, 
the rotten tomatoes score, the 

05:09:58.971 --> 05:10:02.068
album, artist, I can keep going 
on and on for the rest of the 30

05:10:02.069 --> 05:10:04.957
minutes of this talk.  But I 
think you get the point, there's

05:10:04.958 --> 05:10:06.958
tons

05:10:12.081 --> 05:10:15.497
of information.
You can show it using lean back 

05:10:15.498 --> 05:10:18.475
and in multiple places on the 
home screen, in search.  And by 

05:10:18.653 --> 05:10:21.500
showing this information sooner,
it lets users make these 

05:10:21.840 --> 05:10:24.802
microdecisions faster and they 
don't have to go in and out, in 

05:10:24.803 --> 05:10:30.077
and out, to figure out hot  what
they want to watch.  Make your 

05:10:30.390 --> 05:10:33.447
user's lives easier by showing 
this sooner.  Let's look at 

05:10:33.789 --> 05:10:37.647
another example, search.  We 
talked about this at I/O, 

05:10:38.391 --> 05:10:40.917
there's tons of documentation on
this.  I want to breeze through 

05:10:41.174 --> 05:10:47.891
some of these things quickly.
Search is all supplied with the 

05:10:48.049 --> 05:10:52.349
content.  Content providers are 
simple, they return a cursor, 

05:10:52.604 --> 05:10:55.841
you can do whatever you want in 
the background with the content

05:11:03.192 --> 05:11:05.558
provider.
If this did a network call, 

05:11:05.559 --> 05:11:09.522
maybe you have a bunch of pojos.
This is a database call, you 

05:11:10.459 --> 05:11:12.871
have a cursor.  That's fine, the
trick for the search provides

05:11:15.405 --> 05:11:19.063
provider is it needs to return 
results that match the search 

05:11:19.481 --> 05:11:22.869
manager's criteria.  A search 
manager is way of saying this 

05:11:22.870 --> 05:11:26.141
cursor has a bunch of columns 
with these names, and then the 

05:11:26.142 --> 05:11:29.087
assistant is able to pull in 
from that cursor and say, here's

05:11:29.088 --> 05:11:33.132
the title, here's the duration, 
and is able to figure out what 

05:11:33.133 --> 05:11:38.338
content is where.
Super simple to do to do with 

05:11:38.593 --> 05:11:43.007
the matrix cursor, we will dive 
into it closer.  You need to 

05:11:43.267 --> 05:11:46.061
take each of the results, add 
them into a row as a matrix 

05:11:46.504 --> 05:11:48.969
cursor, and then return the 
matrix cursor.  The matrix 

05:11:49.244 --> 05:11:52.509
cursor is really just like a 
mock cursor, it is a 2D array, 

05:11:52.818 --> 05:11:55.518
essentially, under the covers.
  So if you don't have to go 

05:11:56.092 --> 05:12:01.848
about, how it  do I store all of
these in a database, you can 

05:12:02.122 --> 05:12:04.530
mock it out at the very end of 
your search.

05:12:04.531 --> 05:12:08.218
So mapping, this is where the 
hard work happens.

05:12:08.219 --> 05:12:11.621
You have a matrix cursor, it 
takes in a query projection.  

05:12:12.445 --> 05:12:15.316
This query projection is going 
to have all of the columns 

05:12:15.737 --> 05:12:17.417
defined that match the search 
manager.

05:12:17.418 --> 05:12:21.699
So here we have suggest column, 
text one, is the title of the 

05:12:22.575 --> 05:12:25.707
content.
An action, the data ID, the ID 

05:12:26.037 --> 05:12:28.037
is what is unique to your 
content inside the

05:12:30.863 --> 05:12:34.546
app.
And if you take the context into

05:12:34.547 --> 05:12:36.547
this row, you

05:12:38.408 --> 05:12:41.824
supply an array, the name, and 
it corresponds to the order in 

05:12:41.825 --> 05:12:45.304
which the query projection was. 
So the ID, the title, the 

05:12:45.970 --> 05:12:48.070
action, etc. All of the fields 
you have, you can return it 

05:12:48.992 --> 05:12:52.579
back.
So search manager, and with the 

05:12:52.580 --> 05:12:59.288
search and assistant, you can 
make the return result mump  

05:13:07.297 --> 05:13:10.043
much faster.
And so we will cover the new 

05:13:10.327 --> 05:13:12.327
stuff that

05:13:15.903 --> 05:13:18.762
is happening.
The app will have the channel, 

05:13:19.025 --> 05:13:21.939
the play next row, and for the 
video apps, you will have 

05:13:22.495 --> 05:13:26.110
previews.  We have seen up to 2X
increase in engagement

05:13:30.395 --> 05:13:36.611
, you can see a trailer for a 
movie, or a recap, but they take

05:13:36.612 --> 05:13:40.998
a little bit more work because 
it requires the content team to 

05:13:41.314 --> 05:13:45.716
make the content for you.  We 
will not talk about play next, 

05:13:50.825 --> 05:13:52.825
or video.
So inserting it into the content

05:14:00.362 --> 05:14:08.718
provider.  So set the preview, 
the link, when they open the 

05:14:09.046 --> 05:14:11.046
channel, they put it into the 
app and set the internal 

05:14:11.581 --> 05:14:15.017
provider ID.  This is what the 
app keeps track of and knows 

05:14:15.272 --> 05:14:20.520
about.  And then you just get 
the content resolver, you call 

05:14:20.521 --> 05:14:23.637
the insert, give the content 
values, and you are good to

05:14:28.117 --> 05:14:32.256
go.
So you do stuff, the channel ID,

05:14:32.516 --> 05:14:39.453
you keep track of it for sink  
synchronization.

05:14:39.454 --> 05:14:42.708
So it has the deep link, the 
internal provider ID, and the 

05:14:42.986 --> 05:14:45.323
logo, those are the key pieces 
of the channel.

05:14:45.324 --> 05:14:48.544
So what just happened? We 
created a channel, we inserted 

05:14:48.815 --> 05:14:52.519
it, and then we stored the logo.
So we did two things with the 

05:14:52.520 --> 05:14:55.793
home screen, insert the channel,
store the logo.

05:14:55.794 --> 05:15:03.234
So, as of AndroidX 1.00, we have
a new API.  This API looks very 

05:15:03.235 --> 05:15:07.353
similar, small differences.  We 
have a preview channel helper 

05:15:07.354 --> 05:15:12.399
class.  It takes in a context, 
and then it does a bunch of 

05:15:12.400 --> 05:15:15.778
look-ups to get the content 
resolver for you, so you don't 

05:15:16.309 --> 05:15:21.232
have to do context, content 
resolver.insert, it does the 

05:15:21.233 --> 05:15:23.943
work for you.  It makes a 
channel, you have the builder, 

05:15:23.944 --> 05:15:28.834
you set the name, the 
description, the app link, the 

05:15:28.835 --> 05:15:33.433
intent provider url, you think 
you should set the type.  But 

05:15:33.434 --> 05:15:37.976
this class knows it is a preview
channel.  It knows the preview, 

05:15:38.247 --> 05:15:41.155
and you don't have to set the 
type.  Instead, you can set the

05:15:45.219 --> 05:15:47.259
logo.
Now, all of this is contained in

05:15:47.260 --> 05:15:52.304
one united, you can call the 
helper.publish channel, and it 

05:15:52.570 --> 05:15:53.963
gives you all of the work for 
you.

05:15:53.964 --> 05:15:57.594
And you can get the channel ID 
back.  So what it does under the

05:15:57.595 --> 05:16:00.847
covers, it inserts the channel 
into the provider, and it goes 

05:16:01.173 --> 05:16:04.806
to add a logo.
And if the channel isn't able to

05:16:05.491 --> 05:16:08.513
be inserted, maybe you have bad 
data and you are hitting an 

05:16:08.803 --> 05:16:11.642
error or something, it will 
return an error back to you.

05:16:11.643 --> 05:16:14.442
If it is able to insert the 
channel, it tries to store the 

05:16:14.959 --> 05:16:23.914
logo on that channel.  If the 
loFWO it go cannot be persisted,

05:16:23.915 --> 05:16:27.329
it wraps it all up, unwinds the 
channel, so you have half one on

05:16:27.604 --> 05:16:33.550
the home screen.  It treats 
everything as an atomic unit.  

05:16:35.292 --> 05:16:38.642
Pretty convenient.  It does 
everything CRUD does.  So we 

05:16:38.821 --> 05:16:40.821
talked about publishing the 
channel, you can read all of the

05:16:40.970 --> 05:16:48.091
chanles les and get individual 
channel, you can update a 

05:16:48.292 --> 05:16:51.634
channel and you can delete them.
And all of this also happens for

05:16:51.955 --> 05:16:54.349
preview programs, and there is 
support for

05:16:57.619 --> 05:17:01.449
the play next proin this class. 
There are two options to do it, 

05:17:01.450 --> 05:17:04.923
which one is better? You could 
say I want to use content 

05:17:04.924 --> 05:17:08.797
providers, I want to fine tune 
the performance, I can do batch 

05:17:08.798 --> 05:17:12.070
inserts, bulk operations, I can 
go lower-level control.  I don't

05:17:12.071 --> 05:17:15.678
need an entire program with all 
of that metadata, maybe I want 

05:17:15.679 --> 05:17:19.499
the title and the duration, and 
now I can slow down that query 

05:17:19.862 --> 05:17:22.061
projection, and have faster 
results.

05:17:22.062 --> 05:17:25.083
And it is based out of the 
framework, you don't have to do 

05:17:25.346 --> 05:17:29.098
all of this extra work to access
it.  You get it out of the box 

05:17:29.368 --> 05:17:33.063
from the framework.  If you want
to use Android X, you get more 

05:17:33.413 --> 05:17:35.413
convenience, you don't have to 
worry about all of the nuances 

05:17:35.898 --> 05:17:40.406
of a content provider, it is 
a-liner for all intents and 

05:17:40.694 --> 05:17:43.311
purposes, and you get the 
benefits of having the AndroidX 

05:17:48.822 --> 05:17:50.999
in your app.
Discovering content is great, 

05:17:51.000 --> 05:17:53.344
three ways to go about it.  In 
the app, searching the 

05:17:53.777 --> 05:17:58.153
assistant, and on the home 
screen with chan LSS. Les.  How 

05:17:58.154 --> 05:18:00.480
do you make your app 
discoverable? The third thing.  

05:18:00.481 --> 05:18:02.481
The app store on TV is a

05:18:07.123 --> 05:18:10.316
bit different, it makes sure 
that only apps designed for TV 

05:18:10.317 --> 05:18:14.465
are shown.  When the user opens 
up the app store, they are 

05:18:14.466 --> 05:18:19.127
looking at apps that can be 
played on or installed on TV.  

05:18:19.128 --> 05:18:23.049
Try to make your app stick out 
can be hard, but there are 

05:18:23.050 --> 05:18:26.503
simple things that you can do to
have your app appear on the Play

05:18:26.953 --> 05:18:31.029
Store.  The first is to declare 
features, and even if you don't 

05:18:31.030 --> 05:18:36.186
use it, there's a giant 
asterisk.  Don't start declarng 

05:18:36.187 --> 05:18:38.316
bluetooth or location just for 
fun.  There are two features 

05:18:38.317 --> 05:18:40.317
that

05:18:42.151 --> 05:18:44.151
really matter.
The first is touch screen, you 

05:18:44.689 --> 05:18:46.793
want to declare it as false.  It
is not a touch screen, this is 

05:18:47.074 --> 05:18:50.472
not a phone, this isn't a TV 
from way back in the day, these 

05:18:50.747 --> 05:18:54.391
are smart TVs.
You don't need touch screen 

05:18:57.036 --> 05:19:01.166
support.  The second thing is to
declare lean back as true.  This

05:19:01.459 --> 05:19:03.459
tells the Play Store is ready to
be deployed on

05:19:07.054 --> 05:19:09.379
a TV.
If you have all of the code in a

05:19:09.659 --> 05:19:14.089
single code base and making a 
single APK that deploys on 

05:19:14.090 --> 05:19:19.389
mobile and TV, set the lean back
to false.  This tells the Play 

05:19:19.639 --> 05:19:23.599
Store that the APK is compatible
on mobile and TV.  The second 

05:19:24.537 --> 05:19:26.788
thing you should do is try to be
visible in the launcher.  If you

05:19:26.789 --> 05:19:32.660
are a headless app, a screen 
saver or a keyboard, go away for

05:19:32.661 --> 05:19:34.661
two minutes.  And I will see it 

05:19:38.954 --> 05:19:42.544
then.
So you need to supply a banner 

05:19:42.696 --> 05:19:45.176
to see it in the application or 
activity.  The launcher will go 

05:19:46.857 --> 05:19:48.696
in through the manifest, find 
the resource, this is what it 

05:19:48.697 --> 05:19:51.234
uses to show the icon on the 
launcher.

05:19:51.235 --> 05:19:54.742
And once the user selects the 
icon, it needs to launch 

05:19:55.008 --> 05:19:57.884
something.  So the launcher 
fires an intent, and you need to

05:19:58.162 --> 05:20:00.162
have an activity that accepts 

05:20:02.802 --> 05:20:05.574
this intent.
It is called the lean back 

05:20:05.842 --> 05:20:10.746
launcher intent, cleverly named.
And from that it will trigger 

05:20:11.155 --> 05:20:16.767
the lean back experience.  There
are three things you need to 

05:20:17.029 --> 05:20:20.161
have.  One, declare the two 
features so the app is found on 

05:20:20.162 --> 05:20:26.440
the Play Store.  Two, how the 
have the banner, and three, have

05:20:26.441 --> 05:20:31.456
the lean back intent so the app 
launches when the user wants to 

05:20:31.711 --> 05:20:33.711
enter your app.
And that's it.  You are ready to

05:20:34.459 --> 05:20:36.809
go in the Play Store.  This talk
is done.

05:20:36.810 --> 05:20:39.761
All right.
But, in a sense, that is kind of

05:20:40.209 --> 05:20:44.289
the minimum viable product.  You
are able to have a strong 

05:20:44.290 --> 05:20:47.152
player, you are able to have 
easy-to-find content, and you 

05:20:47.431 --> 05:20:51.082
are able to distribute on the 
Play Store.  That is just a good

05:20:51.083 --> 05:20:53.210
app.
How do you make it great?

05:20:53.211 --> 05:20:55.211
To start with this, you should 
look at your

05:20:59.857 --> 05:21:01.704
users.
Imagine the spectrum, they start

05:21:01.705 --> 05:21:07.448
from one side of the spectrum.  
I bought a TV, I want to be 

05:21:07.449 --> 05:21:13.279
cool, everybody is doing it, sit
s in my closet but I have one.  

05:21:13.280 --> 05:21:17.785
The next part of the spectrum, I
have one, I watch a show every 

05:21:18.350 --> 05:21:22.666
week.  You go further down, I 
love how to get away with 

05:21:23.420 --> 05:21:28.898
murder, field of disease  
daisies is awesome, I should 

05:21:29.216 --> 05:21:37.426
watch suicide squad, theis in 
that.  Or for sports, here is a 

05:21:37.825 --> 05:21:44.110
fantasy team, the jersey and the
player I like and I keep going 

05:21:44.470 --> 05:21:47.262
into it.  That side, the left, 
is called the lean back user.  

05:21:47.263 --> 05:21:49.852
They are sitting back, watching 
TV.  That's all they want

05:21:53.598 --> 05:21:56.659
to do.
This is the lean-in user, they 

05:21:56.917 --> 05:22:01.917
are sitting on the edge of the 
seat, this is awesome, who are 

05:22:01.918 --> 05:22:05.501
the people in the show and going
deeper into the content.  

05:22:05.502 --> 05:22:08.289
Everything I talked about until 
now, having a good player, 

05:22:08.558 --> 05:22:12.737
making the app usable, this is 
for the lean-back, the right 

05:22:12.939 --> 05:22:14.939
side of the screen.  If you 

05:22:17.457 --> 05:22:20.974
think about it, how can you tap 
into that lean-back user? Here 

05:22:20.975 --> 05:22:23.293
you have a beautiful living 
room, a very beautiful living 

05:22:23.532 --> 05:22:27.209
room.  I wish it was mine, but 
it is not.  If you look closer, 

05:22:27.210 --> 05:22:30.944
you see a camera, a microphone, 
a tablet phone, and then, as you

05:22:31.255 --> 05:22:35.375
start to think about it, the TV 
is the center piece of the 

05:22:35.964 --> 05:22:37.964
living room.  There are so many

05:22:40.690 --> 05:22:44.225
devices around.  You don't have 
to just do stuff in TV, you can 

05:22:44.486 --> 05:22:49.182
tap everything around the liveic
ing room.  I love the Android 

05:22:49.460 --> 05:22:53.440
TV, it is the focal point around
everything that is happening.  

05:22:53.693 --> 05:22:57.555
Again, we do it in threes, 
threes are great.  In concept, 

05:22:58.195 --> 05:23:01.716
if you want to tap into the 
other surfaces, what should we 

05:23:01.994 --> 05:23:04.723
do? The first is controlling 
media, the play back controls we

05:23:05.004 --> 05:23:08.518
talked about earlier is a great 
step.  It is going to go a 

05:23:08.939 --> 05:23:12.895
little bit farther advanced, you
are building an experience 

05:23:13.381 --> 05:23:17.502
around your app.  And another 
option is to have notefication

05:23:18.414 --> 05:23:22.880
notifications, the big gomis 
game is going to start.  Do you 

05:23:22.881 --> 05:23:27.774
want to watch in your TV? And 
the next is going deeper into 

05:23:27.775 --> 05:23:31.555
the content, the cast and crew, 
behind the scenes of this 

05:23:31.833 --> 05:23:35.592
production, are there extra 
sponsored content I want to know

05:23:36.341 --> 05:23:39.236
more about.  And the third 
pillar is about reducing 

05:23:39.860 --> 05:23:43.616
friction, how do Iinstall your 
app, it is installed, how do I 

05:23:43.875 --> 05:23:45.875
sign into

05:23:47.250 --> 05:23:50.351
your ach.
I want to make a payment, how do

05:23:51.055 --> 05:23:53.218
I authenticate it in a secure 
way 

05:23:57.820 --> 05:24:04.335
inside the TV.  Everybody who 
has the TV has done the third 

05:24:04.336 --> 05:24:07.172
step, the frictionless 
interaction.  The Android TV set

05:24:07.430 --> 05:24:10.698
up does it for you, during the 
flow, it says, do you want to 

05:24:10.954 --> 05:24:15.697
set up on the phone? They give 
the UX indicator, you get the 

05:24:15.989 --> 05:24:18.496
notification, you say, this is 
me, this is my account, and the 

05:24:18.899 --> 05:24:20.983
TV takes over from that 
information and it was

05:24:26.489 --> 05:24:29.544
really frictionless.
And how do they do that? It is 

05:24:29.545 --> 05:24:32.078
something that you can do today,
it is 

05:24:35.717 --> 05:24:37.838
nearby.  We try to use that on 
TV, what you can

05:24:51.810 --> 05:24:53.983
do.
You do the work on the phone, 

05:24:54.248 --> 05:24:58.299
and not on the TV.  We will set 
up a peer-to-peer wireless 

05:24:58.571 --> 05:25:01.932
connection that is encrypted, 
you don't have to worry about a 

05:25:01.933 --> 05:25:04.892
lot of things, you have an 
intimate connection between the 

05:25:05.172 --> 05:25:08.137
phone and the TV.  We will dive 
in a little bit deeper, let's 

05:25:08.138 --> 05:25:13.393
get started with this, we will 
start on the TV side.  So I'm on

05:25:14.131 --> 05:25:19.643
the Android TV, so I'm biassed. 
So TV will start advertising, 

05:25:22.106 --> 05:25:24.542
you set up the 
nearby.get-connectionsclient.  

05:25:24.836 --> 05:25:28.114
That is a helper class from the 
nearby API that has all of these

05:25:28.527 --> 05:25:31.813
things to get you started.  You 
call the start advertising, you 

05:25:32.257 --> 05:25:35.669
give it a name, a service ID, a 
package name is perfectly fine. 

05:25:35.931 --> 05:25:42.466
You are going to give it a 
connection, a life cycle call   

05:25:42.467 --> 05:25:44.903
callback, and set a strategy.  A
cluster is a really good 

05:25:45.175 --> 05:25:48.444
strategy.  If you notice, 
there's a P to P, point to 

05:25:48.445 --> 05:25:52.358
point, strategy.  And it might 
be one TV, one point, point to 

05:25:52.359 --> 05:25:55.928
point, that is great.  If you 
try to do multi-device set-up, I

05:25:55.929 --> 05:25:59.960
have a TV in my living room, in 
my bedroom, bathroom, all of a 

05:26:00.207 --> 05:26:03.973
sudden that point to point 
breaks down.  So to make it a 

05:26:04.317 --> 05:26:07.811
more robust app, think about 
using cluster.  You also set a 

05:26:08.089 --> 05:26:12.140
success and failure listeners.  
These listeners are not saying, 

05:26:12.438 --> 05:26:17.879
oh, I have been found, I have 
been advertising on non found, 

05:26:17.880 --> 05:26:22.377
the users will say you can start
sad  advertising, great for 

05:26:23.644 --> 05:26:26.782
debugging and adding extra 
information inside the app.  The

05:26:27.588 --> 05:26:33.076
big elephant in the room is the 
connection Lifecycle Callback, 

05:26:33.346 --> 05:26:37.393
this talks about how the devices
talk to each other.  What is 

05:26:37.394 --> 05:26:39.645
going to be said is later, how 
they are saying it now is 

05:26:39.955 --> 05:26:42.768
handled in the connection life 
cycle callback.

05:26:42.769 --> 05:26:48.788
And a simple three methods: On 
initialized, results, and 

05:26:49.552 --> 05:26:52.330
disconnected.  And they are 
pretty straightforward, but 

05:26:52.663 --> 05:26:56.077
let's dive in a little bit more.
So when the connection is 

05:26:56.674 --> 05:26:58.697
initialized, that means the 
phone requested a connection, 

05:26:58.698 --> 05:27:03.591
you are going to prompt for 
security and do a couple things.

05:27:03.592 --> 05:27:05.592
Eventually, you will see 

05:27:10.489 --> 05:27:14.160
nearby.get connections client, 
and you will accept it.  Based 

05:27:14.453 --> 05:27:17.729
on that, there's a result, was 
it okay, continue on, was it 

05:27:18.000 --> 05:27:21.745
rejected, maybe it will ask for 
another re-try.  And based on 

05:27:21.968 --> 05:27:23.850
that result, you should handle 
appropriately.

05:27:23.851 --> 05:27:28.071
And the last one on disconnected
is pretty simple.

05:27:28.072 --> 05:27:32.891
So clean up any metadata that 
you may have started collecting.

05:27:33.201 --> 05:27:36.285
The big line here is the 
connections client, accept 

05:27:36.552 --> 05:27:38.736
connections.
  And here you pass in a payload

05:27:39.585 --> 05:27:44.369
callback.  This payload doll  
callback is what the devices 

05:27:44.629 --> 05:27:46.537
communicate.  So you have a 
contract on your phone and on 

05:27:46.538 --> 05:27:48.971
your TV for what they are going 
to say to each other.  Hey, 

05:27:49.224 --> 05:27:52.334
phone, we want to do this.  Hey,
TV, we're going to do this.  And

05:27:52.663 --> 05:27:57.429
this is all handled inside the 
payload callback.  So here are a

05:27:57.430 --> 05:27:59.430
couple tips.
What you are going to 

05:27:59.755 --> 05:28:03.025
communicate is very specific to 
your app, but here are some 

05:28:03.571 --> 05:28:06.219
tips.  The payload received and 
payload transfer update are the 

05:28:06.894 --> 05:28:12.080
only two methods you get.
They are pretty succinct.  

05:28:12.081 --> 05:28:15.641
Payload receive, if you want to 
send an acknowledgement back, 

05:28:15.642 --> 05:28:19.100
hey, thanks for telling us this,
phone.  We will send back an 

05:28:20.006 --> 05:28:23.605
acknowledge.
acknowledge.Ment, so you know 

05:28:23.999 --> 05:28:26.691
the message that has been 
received.  You call send to 

05:28:26.993 --> 05:28:30.638
payload.  You give it the end 
point ID and some body, in this 

05:28:31.118 --> 05:28:32.996
case, it says ack, or 
acknowledge.

05:28:32.997 --> 05:28:38.051
And if you want to disconnect, 
hey, I received this payload, I 

05:28:38.052 --> 05:28:40.052
want to

05:28:42.195 --> 05:28:44.223
disconnect the connection and 
close the session, you should do

05:28:44.224 --> 05:28:46.856
it in the transfer update.  And 
in the transfer update, you 

05:28:46.857 --> 05:28:50.998
should see if it is in progress 
or not.  If you are sending 

05:28:50.999 --> 05:28:53.674
messages like ack and send, 
those are fast.  

05:28:53.675 --> 05:28:56.596
If you are sending something big
like a file, that can take a 

05:28:56.916 --> 05:29:00.490
while.  You want to make sure 
that all of the bytes have been 

05:29:00.864 --> 05:29:03.853
sent.  Once all of the bytes 
have been sent, you can call 

05:29:04.132 --> 05:29:06.132
disconnect from end

05:29:09.210 --> 05:29:12.823
point.
So now you are going to say, 

05:29:13.084 --> 05:29:15.575
hey, I'm a TV, accept the 
connection and you are going to 

05:29:15.943 --> 05:29:17.943
communicate.  On the phone, what
happens on the phone

05:29:23.039 --> 05:29:25.039
side?
You are going to

05:29:27.407 --> 05:29:30.562
discover the TV this time, 
accept the connection, and 

05:29:30.563 --> 05:29:34.543
everything else looks like the 
slides I showed you.

05:29:34.544 --> 05:29:39.553
To discover the TV, this time 
you call start discovery.  Mind 

05:29:39.554 --> 05:29:43.103
blown.  You give it a service 
ID.  This time, I'm using a 

05:29:43.272 --> 05:29:47.307
constant, and there's a reason 
for the service ID, depending on

05:29:47.607 --> 05:29:50.290
your app, it should be the 
package name or the constant.  

05:29:50.291 --> 05:29:52.960
If you have a package name that 
is the same for both your TV app

05:29:53.241 --> 05:29:57.358
and your mobile app, it is going
to work great.  If you have 

05:29:57.803 --> 05:29:59.803
something like 

05:30:01.565 --> 05:30:03.565
com.mycompany.Android, or 
Android TV as your two package 

05:30:03.682 --> 05:30:06.685
names, imagine they are on their
own channels.  So the nearby 

05:30:07.031 --> 05:30:10.377
connections library will not be 
able to find the phone and the 

05:30:10.378 --> 05:30:16.385
TV.  Having a service ID used be
both by both sides is a good 

05:30:16.732 --> 05:30:19.121
practice.  You will give it a 
mobile end point discovery call 

05:30:19.714 --> 05:30:21.714
back, I love really big

05:30:25.672 --> 05:30:27.644
words.
And you will have a strategy, 

05:30:27.645 --> 05:30:29.645
and I encourage you to use 
cluster for

05:30:32.348 --> 05:30:34.876
this use case.  You get 
listeners, they are pretty 

05:30:35.178 --> 05:30:38.363
important, and they are able to 
start discovery.  This does

05:30:43.921 --> 05:30:46.182
require location permission, so 
if you get a failure listener, 

05:30:46.970 --> 05:30:50.149
like permission for location 
hasn't been enabled, so they are

05:30:50.492 --> 05:30:53.423
great for debugging and trying 
to urge the user down the

05:30:56.479 --> 05:31:00.068
correct path.
 So the next part, accept the 

05:31:00.310 --> 05:31:03.368
connection.  Really simple, you 
have the mobile end point 

05:31:03.685 --> 05:31:07.092
discovery call back.  It has two
methods, you found the end point

05:31:07.093 --> 05:31:10.594
or lost the end point.  Pretty 
simple.  If you find the end 

05:31:10.595 --> 05:31:12.595
point, go ahead and request a

05:31:17.694 --> 05:31:19.694
connection.
This requests the TV initialized

05:31:20.078 --> 05:31:23.669
on the TV you saw earl
ierearlier.  If you lost the end

05:31:24.015 --> 05:31:26.710
point, maybe the user is no 
longer nearby, or they gave up 

05:31:26.711 --> 05:31:31.792
and closed the app and said 
forget it.  Hopefully it is the 

05:31:31.793 --> 05:31:35.424
first for you, not the second.  
You should clean up whatever 

05:31:35.725 --> 05:31:42.300
metadata you collected already. 
And anything after this is 

05:31:42.301 --> 05:31:45.586
identical, you will have the 
connections live cycle call back

05:31:45.587 --> 05:31:48.298
that shows how they communicate,
and the payload call back that 

05:31:48.299 --> 05:31:53.064
shows what they are going to 
communicate.  And that's it, 

05:31:53.065 --> 05:31:58.440
that's nearby in a nutshell.  
And nearby is a cool tool, it is

05:31:58.702 --> 05:32:04.368
a nice box in your kits to have 
more experience in a TV app.  We

05:32:04.621 --> 05:32:07.661
wills go on payments, we will 
look at one more example.  

05:32:07.662 --> 05:32:12.834
Payments is cool, it adds a 
family-friendly idea. 

05:32:12.835 --> 05:32:16.427
Imagine you are at work, your 
kid is at home, and they want

05:32:19.733 --> 05:32:23.105
to buy the next season of a TV 
show.  You get a push 

05:32:23.260 --> 05:32:25.684
notification, are you sure you 
want to purchase this, you say, 

05:32:25.948 --> 05:32:30.181
man, my kid is at home buying 
stuff, no, or yeah, they are 

05:32:31.732 --> 05:32:36.000
bored, I will use my finger 
print or anything from the phone

05:32:37.285 --> 05:32:39.810
to authenticate yourself.  And 
you enabled a purchase at home 

05:32:40.092 --> 05:32:42.092
from your

05:32:49.066 --> 05:32:54.236
office.
And I have not seen a lot of 

05:32:54.944 --> 05:32:58.794
this in Android.  This is not a 
good fit, it is not a good tool 

05:32:59.361 --> 05:33:05.004
in the toolbox, but it is not 
necessarily the best fit.  So 

05:33:05.416 --> 05:33:11.214
let's talk about a good fit, you
get a push notification, and it 

05:33:11.215 --> 05:33:15.610
says watch on TV, or watch here.
This a big game, you want to 

05:33:16.182 --> 05:33:19.437
watch it, watching on a small 
phone.  Eh.  Watching on a big 

05:33:19.676 --> 05:33:25.331
TV? Awesome.
So you can use nearby to figure 

05:33:25.590 --> 05:33:28.781
out proximity.  They are close 
to the TV, we should watch the 

05:33:29.069 --> 05:33:34.302
TV button.  That's a great use 
for nearby.  Receiving

05:33:37.731 --> 05:33:42.143
the notification an example of 
content immersion.  When you 

05:33:42.424 --> 05:33:45.089
said watch on TV, the background
lit up, the schedule for the 

05:33:45.090 --> 05:33:48.466
game, the highlights, the score.
And then whenever the user 

05:33:48.742 --> 05:33:52.955
wants, they can put the phone to
the side, it is very 

05:33:52.956 --> 05:33:55.652
non-intrusive, and they can 
focus on their game.  So in a 

05:33:55.653 --> 05:33:58.737
sense, this is kind of kicked 
off from a notification.

05:33:58.738 --> 05:34:03.531
And in a way, you would say that
is more of a push model.  Nearby

05:34:04.130 --> 05:34:08.305
feels more like a pulling, I'm 
pulling a conversation between 

05:34:08.306 --> 05:34:11.284
the two devices, and whereas in 
this case you are pushing that 

05:34:11.450 --> 05:34:15.741
information to the user.
And you are talking about 

05:34:16.059 --> 05:34:19.164
Firebase cloud messaging after 
this, I will not step on their 

05:34:19.439 --> 05:34:21.788
toes too much.  We will talk 
about it for fun, what is the 

05:34:22.184 --> 05:34:25.143
worst that can happen.  You set 
up the Firebase members of the 

05:34:25.685 --> 05:34:27.685
jury 

05:34:31.604 --> 05:34:34.287
messaging messaging service, and
this is what to do.

05:34:34.288 --> 05:34:39.995
And if the action happens to be 
watch this movie or game, start 

05:34:39.996 --> 05:34:42.687
watching and you are good to go.
Start watching,

05:34:45.722 --> 05:34:49.944
then it should literally launch 
an activity.  

05:34:49.945 --> 05:34:53.443
This is the Android Dev Summit, 
I will assume that everybody has

05:34:54.971 --> 05:34:58.674
launched before.  In this case, 
we will set up the intent, the 

05:34:59.055 --> 05:35:01.055
extras, this is a

05:35:03.681 --> 05:35:06.425
video to watch and the activity.
And next, what happens when the 

05:35:06.426 --> 05:35:10.257
TV is off? I am at home, I get a
push notification, oh, man, the 

05:35:10.547 --> 05:35:13.595
game is about to start.  I have 
to hit power on the remote, I 

05:35:13.596 --> 05:35:16.351
have to tune to the channel, 
man, this is first-world 

05:35:16.606 --> 05:35:18.606
problems at its finest.

05:35:22.481 --> 05:35:27.212
But you can solve this.  With 
the fragment activity, you can 

05:35:27.434 --> 05:35:31.364
call, set turn on screen to 
true.  And this is a cool API on

05:35:31.798 --> 05:35:35.589
activity.  It is actually 
introduced in OMR1.  So if you 

05:35:36.057 --> 05:35:38.904
are on API 27 or higher, you 
should do a check.  Hey, turn on

05:35:39.165 --> 05:35:41.849
screen to true, otherwise you 

05:35:47.630 --> 05:35:51.443
can add the flag.  So start with
your player, your content is

05:35:55.041 --> 05:35:59.691
king.  So really focus on the 
player, whether it is content or

05:35:59.692 --> 05:36:04.084
an ad, make sure the player is 
solid.  How do you make the app 

05:36:04.085 --> 05:36:08.521
more usable and get the 
lean-back experience so users 

05:36:08.961 --> 05:36:12.005
can quickly find other content 
to watch? The third pillar is 

05:36:12.759 --> 05:36:16.806
distribution, is my app deployed
to set up on the Play Store 

05:36:17.864 --> 05:36:20.446
correctly? When you have all 
three of these, you have happy 

05:36:20.850 --> 05:36:27.280
users, and who DUNCHT  doesn't 
want that? If you want to take 

05:36:27.281 --> 05:36:31.960
it further, use these lean-in 
experiences, have payments, push

05:36:33.901 --> 05:36:36.862
notification control, add the 
immersive content, the details 

05:36:39.554 --> 05:36:42.628
of the game.
Thank you, and everyone go build

05:36:42.629 --> 05:36:46.266
great TV apps.  If you have any 
questions, you can see us at the

05:36:46.267 --> 05:36:48.267
office hours, thank you

05:36:52.234 --> 05:36:54.234
very much. 
SPEAKER: The next

05:37:01.562 --> 05:37:03.562
session will 

05:47:46.275 --> 05:47:48.098
begin.
Coming up next: Android 

05:47:48.099 --> 05:47:50.099
Suspenders by Chris Banes, Adam 
Powell.

05:48:26.560 --> 05:48:28.560
 S

05:50:33.052 --> 05:50:35.052
PEAKER: Hey, good afternoon, 

05:50:41.932 --> 05:50:44.222
everyone.  Thanks.
SPEAKER: I'm Adam. 

05:50:44.223 --> 05:50:47.930
SPEAKER: I'm Chris. 
SPEAKER: This is Android 

05:50:48.247 --> 05:50:51.404
suspenders.  We're going to talk
about coroutines, and to get 

05:50:51.682 --> 05:50:57.127
started, many of you are 
probably familiar with Android's

05:50:57.415 --> 05:51:03.156
main thread.  Like any other 
toolkit, it exposes a UI or main

05:51:03.426 --> 05:51:08.635
thread for exposing updates to 
parts of the UI.  You may be 

05:51:08.912 --> 05:51:12.985
inflating views, measuring 
layout operations to change the 

05:51:13.443 --> 05:51:16.108
shape of your view hierarchy, 
drawing, and many other things 

05:51:16.617 --> 05:51:20.640
like processing input events and
so on and so forth.

05:51:20.641 --> 05:51:24.697
So today you are probably 
familiar with the 16 millisecond

05:51:24.960 --> 05:51:31.572
time limit, the vast majority of
devices out there are have a 

05:51:32.425 --> 05:51:42.018
refresh of 16 hertz, which means
you have 16 mill secondss to 

05:51:42.019 --> 05:51:45.535
load the display framework.  You
have less and less time to get 

05:51:45.536 --> 05:51:50.674
this work done as the hertz go 
up.  

05:51:50.675 --> 05:51:54.195
The things that cause you to 
miss a frame and have Jenk in 

05:51:55.212 --> 05:51:59.018
your application is app code.  
If you are binding items to a 

05:51:59.413 --> 05:52:03.767
recycler view, these are all 
bits of work that are great if 

05:52:03.768 --> 05:52:06.138
we can keep it out of the main 
thread and off the critical 

05:52:06.814 --> 05:52:11.823
path.  How do we fix it? This 
talk is not about achieving 8 

05:52:11.974 --> 05:52:15.469
millisecond refresh boundaries, 
but using the resources we have 

05:52:16.015 --> 05:52:20.049
available.  All the phones we 
have have multiple cores in them

05:52:20.050 --> 05:52:24.265
today.  How do we make use of 
that? Some of you probably 

05:52:25.056 --> 05:52:27.056
remember this thing, it

05:52:29.348 --> 05:52:34.799
has been around for some time.  
It has issues around rotation, a

05:52:34.800 --> 05:52:39.336
lot that it gets wrong.  There 
are executors, that developers 

05:52:39.337 --> 05:52:42.718
are familiar with.  It has 
thread pools that are nice, but 

05:52:42.719 --> 05:52:45.313
it is a raw API.  You can build 
things out of it, but it is not 

05:52:48.147 --> 05:52:50.962
convenience  -- convenient to 
use on its own.

05:52:50.963 --> 05:52:54.166
Loaders are a thing out there 
that solved a few problems, 

05:52:56.069 --> 05:52:58.127
narrowly-scoped, it is 
deprecated and there's not a 

05:52:58.128 --> 05:53:02.176
whole lot there.  We can use 
features, there's listenable 

05:53:02.361 --> 05:53:05.639
future that showed up in the 
AndroidX APIs, but you might not

05:53:05.640 --> 05:53:09.022
want to pull in all of the 
infrastructure that helps you to

05:53:09.023 --> 05:53:12.954
leverage some of the thingsout  
you can do with it.  And unless 

05:53:13.833 --> 05:53:18.789
you are working in min SDK24, 
you cannot use importable future

05:53:18.790 --> 05:53:24.551
either and there's a lot of 
reasons you don't want to use it

05:53:25.012 --> 05:53:30.990
to begin with.
  So Guava, you can use that to 

05:53:30.991 --> 05:53:34.942
pull into the app.  And RSDK is 
helpful as well.  If you are 

05:53:35.099 --> 05:53:40.525
here, you probably want to talk 
about coroutines, which went 

05:53:40.526 --> 05:53:45.190
stable in Kotlin 1.3 this fall. 
So why should we use them?

05:53:45.191 --> 05:53:49.685
All right.
So whaI when I think about this 

05:53:49.951 --> 05:53:56.894
question, what does the typical 
mobile app do? They are CRUD 

05:53:57.307 --> 05:54:01.909
apps, they Create, Read, Update,
Delete data.  And usually it is 

05:54:02.327 --> 05:54:04.714
a source, a database, or 
whatever it may be.  And it has 

05:54:04.715 --> 05:54:08.846
some kind of sync.  They will 
upload data and pull it back 

05:54:09.147 --> 05:54:12.223
from some kind of web service.  
And apps are pretty simple 

05:54:12.506 --> 05:54:15.610
computationally, you are not 
taxing the CPU very much.  And I

05:54:15.879 --> 05:54:20.074
guess the logic can be tricky to
get right, but they are pretty 

05:54:20.340 --> 05:54:23.382
simple.  And in Android, we put 
a lot of stuff in your way.  We 

05:54:23.584 --> 05:54:26.740
make your life harder, but your 
apps are pretty simple from a 

05:54:27.062 --> 05:54:31.529
logic point of view.
So why coroutines? And how do we

05:54:31.836 --> 05:54:36.076
fix that? They are great for I/O
tasks, especially a 

05:54:36.077 --> 05:54:38.077
resource-constrained system, 
like the phone and tablets you 

05:54:38.263 --> 05:54:40.876
are using today.  And you cannot
create a thread for everything 

05:54:41.199 --> 05:54:43.968
network request that you ever 
use, because threads take in the

05:54:44.248 --> 05:54:49.053
space of that, they take about a
megabyte of RAM every time you 

05:54:49.571 --> 05:54:54.737
create one.  That is why thread 
pools cache threads for you.  

05:54:54.738 --> 05:54:58.886
And coroutines take in the realm
of 10s of kilobytes in a 

05:54:59.321 --> 05:55:03.141
Coroutine, they use threads 
underneath in a much more 

05:55:03.411 --> 05:55:06.746
optimal way.  They have an 
easier development model.  It is

05:55:08.471 --> 05:55:13.169
easier for developers to come 
into a new source, and see an 

05:55:13.837 --> 05:55:18.020
imperative, line-by-line 
Coroutine of something like an 

05:55:19.242 --> 05:55:21.774
RX Java chain.  To understand 
what is happening there, in my 

05:55:22.453 --> 05:55:25.453
mind it is easier, and the same 
for call-backs, everyone knows 

05:55:25.717 --> 05:55:28.446
about call back hell, and going 
line by line and seeing what you

05:55:28.703 --> 05:55:31.459
have called and stuff.  And 
coroutines hopefully, anyway, 

05:55:32.232 --> 05:55:36.223
fix that.
And so a lot of this talk was 

05:55:37.785 --> 05:55:41.818
written in mind with an app I 
have been writing called Tivi, I

05:55:42.417 --> 05:55:51.400
went all in in RX Java, it is 50
percent coroutines

05:55:52.426 --> 05:55:59.563
and 50 percent RX Java.  I use 
both, they both have a place in 

05:55:59.827 --> 05:56:02.614
Android development, so I say 
use both.  And as developers, we

05:56:03.321 --> 05:56:08.865
have to care about APK size and 
method cans.  I'm using free 

05:56:11.065 --> 05:56:13.065
libraries from the

05:56:17.147 --> 05:56:23.895
coroutines core, and RX2 that 
allows you to interact with RX 

05:56:24.177 --> 05:56:27.158
Java.
And if you are actually pulling 

05:56:27.159 --> 05:56:32.474
down the jars files to central, 
they come to 774 kilobytes.  

05:56:34.199 --> 05:56:36.199
That is quite big.  And once you
are actually putting that in 

05:56:36.641 --> 05:56:41.925
your APK, it shrinks down.  It 
comes down to 500 kilobytes.  

05:56:43.297 --> 05:56:46.358
And the references are quite 
high, 54 percent of your 64K.  

05:56:47.057 --> 05:56:50.538
And as soon as you turn on 
minify, and now this is tree 

05:56:50.818 --> 05:56:54.550
shaken, no optimization turned 
on here.  And they both have 

05:56:54.829 --> 05:56:57.641
results.
  You are looking at 113K.  So a

05:56:57.642 --> 05:57:01.294
lot less, and again, the 
references is dropped.  As soon 

05:57:01.592 --> 05:57:06.201
as you turn on optimization, and
you fix all the program rules, 

05:57:06.482 --> 05:57:09.172
you are coming down to the magic
value, which is less than 100 

05:57:09.672 --> 05:57:13.728
kilobytes.  And your reference 
is now 834, less than 1 percent 

05:57:13.729 --> 05:57:17.238
of your references.
And now one thing to note, when 

05:57:18.164 --> 05:57:23.782
you are using R8, you need to 
use this rule.  It is not 

05:57:24.607 --> 05:57:30.332
bundled with Java, hopefully 
added soon, but a simple rule to

05:57:30.608 --> 05:57:33.140
add. 
SPEAKER: Okay.

05:57:33.141 --> 05:57:38.622
So hopefully you are thinking 
about how to use coroutines in 

05:57:38.976 --> 05:57:43.273
your app, we will talk about how
to write them.  Anything you do 

05:57:43.274 --> 05:57:47.058
with a call back feature, you 
can do with a suspend function. 

05:57:47.472 --> 05:57:51.713
Anything with coroutines is a 
suspend function for creating 

05:57:51.977 --> 05:57:55.574
APIs, they can suspend without 
blocking and resumed later with 

05:57:55.575 --> 05:57:59.159
a call back and can only be 
called from another suspend 

05:57:59.603 --> 05:58:01.914
function to set up the machinery
involved in that.  The core 

05:58:01.915 --> 05:58:06.772
thing is all of this fits in one
slide, the language works the 

05:58:07.043 --> 05:58:11.782
same in thethe presence of 
suspend functions and we will 

05:58:11.783 --> 05:58:15.856
spend the talk talking about 
that.  This is the suspend from 

05:58:15.857 --> 05:58:18.685
Chris's app, a data repository 
for TV shows, you call the 

05:58:18.686 --> 05:58:22.795
update show function with the 
ID, we get some shows, and we 

05:58:22.796 --> 05:58:27.191
get a little bit more data from 
a remote source, and a little 

05:58:27.192 --> 05:58:31.340
bit more data from a second 
source.  We merge all of that 

05:58:31.341 --> 05:58:36.217
together and we save that data.
So these three main tasks where 

05:58:36.486 --> 05:58:41.615
we spend the bulk of the time, 
these are done sequentially, but

05:58:41.962 --> 05:58:45.852
none of them have a dependency 
on one another.  Wouldn't it be 

05:58:46.267 --> 05:58:49.452
nice to do it concurrently? With
the async builder, we can do it.

05:58:49.453 --> 05:58:54.126
We start from the top here, we 
open a Coroutine scope, and this

05:58:54.862 --> 05:58:59.551
allows us to build a parallel 
composition using the async 

05:58:59.970 --> 05:59:03.473
builder, it has the receiver in 
the scope for the Lambda block  

05:59:03.945 --> 05:59:07.662
block we have.  We build the 
async operation, the second, and

05:59:07.948 --> 05:59:11.117
the third.  And we await the 
result of each one in turn.  So 

05:59:11.458 --> 05:59:13.755
the nice one is that we have 
launched all of these things, 

05:59:14.041 --> 05:59:16.124
let them run independently and 
then we bring them back together

05:59:18.558 --> 05:59:20.558
again.
So since all of these things can

05:59:20.811 --> 05:59:25.731
be now done in parallel, things 
should complete faster.  Trying 

05:59:26.662 --> 05:59:29.545
to do this with raw threads by 
hand is a lot more code than you

05:59:29.546 --> 05:59:32.955
need to maintain along the way. 
The async builder is when you 

05:59:33.225 --> 05:59:36.066
want to run something and await 
the result after giving it a 

05:59:36.589 --> 05:59:40.324
chance to finish while doing 
something else.  It is similar 

05:59:40.853 --> 05:59:45.104
to C# or promises in JavaScript.
  What if you want to launch 

05:59:45.105 --> 05:59:48.603
something and forget? There is 
that, too, it is called launch 

05:59:49.299 --> 05:59:52.820
and works the same way.  In this
case, it is a lot more similar 

05:59:53.673 --> 05:59:56.308
to executors and just sort of 
submitting a task, submitting 

05:59:56.586 --> 06:00:02.312
something to an Android hand led
handler when we just want to 

06:00:02.313 --> 06:00:04.347
fire and forget and deal with it
later.

06:00:04.348 --> 06:00:08.994
Those are the basics of running 
coroutines in isolation, how do 

06:00:08.995 --> 06:00:11.442
you handle it on Android?
So you may have the components 

06:00:12.468 --> 06:00:16.419
ViewModel, wouldn't it be nice 
to have a way to put all of this

06:00:16.698 --> 06:00:19.471
stuff together automatically? 
You need to open a scope, where 

06:00:19.971 --> 06:00:22.534
can you open those things to 
begin with that you can launch 

06:00:23.407 --> 06:00:26.679
into? In this case, the model 
has a show repository, the data 

06:00:26.900 --> 06:00:30.781
layer, we have the viewer state 
that the viewer activity or 

06:00:35.361 --> 06:00:40.080
fragment observe.  We refresh on
construction and we have the 

06:00:40.081 --> 06:00:45.989
construct property.  
This is coming up soon.  The 

06:00:46.936 --> 06:00:48.936
refresh function uses the 
Coroutine, the launch builder, 

06:00:49.419 --> 06:00:53.628
and updates the function on the 
repository.  And the Coroutine 

06:00:54.295 --> 06:00:57.785
updates back on the main thread 
so we can manipulate the view 

06:00:57.997 --> 06:01:01.978
hierarchy, so we have a nice, 
clean, sequential ordering of 

06:01:01.979 --> 06:01:03.835
operations.
  So those of you who want to 

06:01:03.836 --> 06:01:07.049
check out this thing that is 
upcoming, you can go to this 

06:01:07.050 --> 06:01:11.522
link, take a look at the change 
so far in advance of the actual 

06:01:11.829 --> 06:01:16.868
release.  It is a release of the
KTX libraries.  We will 

06:01:17.343 --> 06:01:21.178
demystify how this works.  
Before we go deep, we will talk 

06:01:21.446 --> 06:01:25.927
about the other primitives that 
are under the hood here.

06:01:25.928 --> 06:01:32.707
Woah, we lost our deck.
Uh-oh.  Did we switch to the 

06:01:35.492 --> 06:01:37.510
wrong -- keynote crash

06:01:43.368 --> 06:01:45.570
.
SPEAKER: We will talk about 

06:01:45.971 --> 06:01:50.222
jobs, so what is a job? So when 
you look at the code snippet, 

06:01:50.501 --> 06:01:52.723
you are actually using the 
launch method.  And now when you

06:01:52.724 --> 06:01:56.084
are actually running that launch
method, it returns what we call 

06:01:56.353 --> 06:02:00.585
a job.  And a job allows us to 
reference, keep a reference of 

06:02:00.586 --> 06:02:04.524
the ongoing piece of work, it 
has one method on it, it is 

06:02:04.525 --> 06:02:07.457
called cancel.  In this example,
we would not call cancel 

06:02:07.727 --> 06:02:11.379
straight away after we launch 
something, that is ridiculous.  

06:02:11.618 --> 06:02:14.688
What it does allow us to do is 
to handle double refreshes, if 

06:02:15.387 --> 06:02:18.485
you have something that pulled 
the refresh in your app, you 

06:02:18.791 --> 06:02:21.083
don't want the bugs to happen at
the same time and then you have 

06:02:21.399 --> 06:02:23.769
two things happen at the same 
time.  So here, this code 

06:02:23.770 --> 06:02:26.036
snippet, you can keep a 
reference of the one that is 

06:02:26.505 --> 06:02:28.505
currently running, and if

06:02:30.665 --> 06:02:33.904
first one.  And that is the kind
of how the job works, it is a 

06:02:35.293 --> 06:02:37.943
very simple object.  It allows 
you to keep a reference of the 

06:02:38.983 --> 06:02:42.720
on going piece of work.  So you 
may have seen that scope and 

06:02:42.999 --> 06:02:45.361
wondered what it is, Adam 
explained it earlier.  You can 

06:02:45.939 --> 06:02:48.952
have a scope, and it provides 
you with all the context that 

06:02:49.313 --> 06:02:53.115
you need to run a launch or an 
async.

06:02:53.116 --> 06:02:55.645
So let's look at how they work 
underneath.

06:02:55.646 --> 06:03:00.216
So Coroutinescope ask an 
interface that allows objects to

06:03:00.217 --> 06:03:04.158
provide a scope for coroutines, 
think things like with a life 

06:03:04.436 --> 06:03:07.079
cycle, like fragment, 
activities, ViewModel.  They can

06:03:07.650 --> 06:03:11.666
provide a life cycle full of 
Coroutine itself and start and 

06:03:11.954 --> 06:03:17.057
stop it as it needs.  Async and 
launch used to be global 

06:03:17.058 --> 06:03:20.410
methods, and a recent refactor 
brought them as instant methods 

06:03:21.514 --> 06:03:24.396
on the coroutines scope.  And 
what it means is that, mentally,

06:03:24.925 --> 06:03:28.433
instead of just launching 
something, you are launching a 

06:03:28.715 --> 06:03:32.238
Coroutine on X.  So I'm 
launching a Coroutine on the 

06:03:33.280 --> 06:03:36.394
activity.  It changes it in your
head, so it is tied to the life 

06:03:36.678 --> 06:03:38.791
cycle of something else. 
SPEAKER: Right if you are used 

06:03:38.792 --> 06:03:43.097
to working with the life cycle 
owner in arch components, the 

06:03:43.390 --> 06:03:46.734
life cycle owner has a life 
cycle that you can observe and 

06:03:47.090 --> 06:03:51.272
attach things to.  A Coroutine 
scope has a context that carries

06:03:52.187 --> 06:03:55.730
everything necessary to launch 
the Coroutine. 

06:03:59.052 --> 06:04:01.052
SPEAKER: YOU CAN

06:04:08.353 --> 06:04:12.047
s. 
SPEAKER: You can essentially map

06:04:12.048 --> 06:04:16.140
the context.  
SPEAKER: And it crashed again.  

06:04:16.141 --> 06:04:18.314
SPEAKER: Well, it is a good day 
for slides. 

06:04:18.315 --> 06:04:21.160
SPEAKER: Got it back? 
SPEAKER: Okay, cool. 

06:04:21.161 --> 06:04:25.598
SPEAKER: So we will look at 
another example.  We are not 

06:04:25.870 --> 06:04:29.897
using the V model scope, we're 
going to add the data ourselves 

06:04:30.172 --> 06:04:33.906
.  We created a job, a simple 
instantiation, and then we are 

06:04:33.907 --> 06:04:38.107
going to keep that -- we are 
going to create a Coroutine 

06:04:38.401 --> 06:04:41.856
scope using add a job.  Anything
that runs on it allows us to 

06:04:42.124 --> 06:04:46.722
track back using that Java 
object.  We will give it a 

06:04:47.377 --> 06:04:49.529
default dispatcher, talk about 
it later.  And anything that is 

06:04:50.315 --> 06:04:53.852
launched on that scope will be 
run on the main thread, so the 

06:04:58.093 --> 06:05:01.011
Android main thread.  So once 
we've done that, we will have 

06:05:01.286 --> 06:05:06.644
the refresh method, and we will 
use our own creative scope, the 

06:05:06.645 --> 06:05:10.322
same code, using a different 
scope.  And this time the launch

06:05:11.700 --> 06:05:17.251
we scoped to the job object woe 
created -- we created earlier.

06:05:18.050 --> 06:05:22.183
  And what has been torn down, 
we can call the job.cancel, and 

06:05:22.731 --> 06:05:25.264
any coroutines that are running 
when it goes down will be 

06:05:25.546 --> 06:05:29.550
canceled at the same time.  It 
reduces memory leaks and allows 

06:05:30.487 --> 06:05:33.221
it to tidy up.  So if you can 
look at how things are running 

06:05:33.222 --> 06:05:37.132
now, so we have launched the 
Coroutine and we are going to go

06:05:37.525 --> 06:05:41.621
into the update/share method.  
So here we are in Coroutine, the

06:05:42.179 --> 06:05:45.160
launch, which is that blue thing
going around.  And in the update

06:05:45.373 --> 06:05:51.492
share method, which is denoted 
by the yellow.  And this is the 

06:05:51.787 --> 06:05:55.999
async builder, we have a first 
Coroutine running.  And so it is

06:05:56.000 --> 06:06:02.602
running nicely, doing its thing.
And the outer Coroutine goes 

06:06:03.215 --> 06:06:08.849
past that, and the second async,
which is the remote.  We have 

06:06:09.426 --> 06:06:13.552
two coroutines running, well, we
have three.  But two in the 

06:06:13.553 --> 06:06:16.180
launch.
And once they are going along, 

06:06:16.181 --> 06:06:19.959
we go into the first await.  And
that first async, the local, to 

06:06:20.750 --> 06:06:26.969
finish itself off and return a 
result, what is what the await 

06:06:27.251 --> 06:06:31.051
will return.  Because we are 
waiting on the first Uync, the 

06:06:31.645 --> 06:06:38.379
outer coroutines are suspended.
And during that time, the 

06:06:38.796 --> 06:06:44.535
ViewModel is down, and we call 
job.cancel.  And at this point, 

06:06:45.226 --> 06:06:51.257
the outer Coroutine is cancels 
and the inner two are canceled. 

06:06:51.652 --> 06:06:55.956
And the child coroutines inherit
from the parent.  So if the 

06:06:56.222 --> 06:06:58.338
parent has been canceled, 
anything below it will also be. 

06:06:58.339 --> 06:07:00.339
That is something that was added

06:07:03.959 --> 06:07:08.507
recently.
WLAUPS if what happens if you 

06:07:08.508 --> 06:07:13.482
are using view models? So as 
part of the Android architecture

06:07:13.483 --> 06:07:16.824
components, we added a listener 
functionality of the life psych

06:07:18.107 --> 06:07:22.918
cycles.  You create a life cycle
observer, in this case we are 

06:07:25.620 --> 06:07:32.083
using default, you can add 
create, destroy, stop, or 

06:07:32.084 --> 06:07:34.993
whatever it be.  And you can 
create instance or observer, 

06:07:35.270 --> 06:07:38.679
hopefully you have seen this API
before.  And this builds a scope

06:07:38.881 --> 06:07:42.433
of where life cycle observer, 
which allows us to scope 

06:07:42.855 --> 06:07:46.365
coroutines to the actual life 
cycle instance.  The primary API

06:07:46.682 --> 06:07:49.812
is it passes the Lambda, and 
that is what everything runs 

06:07:50.083 --> 06:07:53.152
with when you are started, that 
is kind of what you are using 

06:07:53.153 --> 06:07:58.009
most of the time.  So it will 
allow the governance, and the 

06:07:58.286 --> 06:08:02.365
first thing we want to do is on 
start, we are running the piece 

06:08:02.639 --> 06:08:06.824
of code, creating the Coroutine 
scope, and running the 

06:08:06.825 --> 06:08:10.645
dispatches domain.  And then we 
will call script.launch and call

06:08:11.620 --> 06:08:15.408
the Lambda.  Pretty simple.  And
finally, on stop, it seems like 

06:08:15.909 --> 06:08:20.272
a good life cycle to use that 
will call and will eventually 

06:08:20.754 --> 06:08:24.870
cancel the job.  And that means 
the Coroutine will be canceled. 

06:08:24.871 --> 06:08:31.297
You can see that it is not 
actually that complex.  In 

06:08:31.588 --> 06:08:34.563
AndroidX, if you look deep down 
into it, it is pretty simple.  

06:08:34.564 --> 06:08:37.792
To finish it off, we will have a
nice build function, you pass 

06:08:38.371 --> 06:08:40.541
the Lambda, and it will observe 
it for you.

06:08:40.542 --> 06:08:47.009
And what it allows us to do is 
like this.  So here we have a 

06:08:47.881 --> 06:08:50.954
detailss fragment, the live 
scope, and then run something.  

06:08:51.177 --> 06:08:53.754
And it will automatically start 
it, when we get to -- it will be

06:08:53.755 --> 06:08:56.629
started when we go to start and 
new fragment, and then it will 

06:08:56.916 --> 06:09:02.664
be closed or ended when we get 
on stop.

06:09:02.665 --> 06:09:05.619
All right.  Brings us to 
cancellation. 

06:09:05.620 --> 06:09:08.134
SPEAKER: . 
SPEAKER: We talked a lot about 

06:09:08.393 --> 06:09:11.833
cancelling a Coroutine, what 
happens when this cancels? If 

06:09:12.029 --> 06:09:15.738
you have a block of code that is
running, what is torn down when 

06:09:16.015 --> 06:09:20.890
you need to clean up? So when a 
Coroutine is canceled, if it is 

06:09:21.095 --> 06:09:23.095
while it is suspended and 
waiting for something else to 

06:09:23.481 --> 06:09:27.801
happen.  In call back terms, it 
has not been invoked yet.  It 

06:09:28.324 --> 06:09:31.632
will throw a cancellation 
exceptionexception, it will 

06:09:32.249 --> 06:09:35.136
resume from the point it was 
suspended with a cancellation 

06:09:35.406 --> 06:09:38.180
exception.  What does that look 
like? This is the example from 

06:09:38.464 --> 06:09:40.464
before.  What happens if we need
to clean something up if this is

06:09:40.612 --> 06:09:44.336
canceled in the middle of the 
update show function? Because it

06:09:44.779 --> 06:09:48.493
throws a cancellation exception,
this is something we know how to

06:09:48.494 --> 06:09:53.647
do already.  The blocks run as 
expected, we don't need to add 

06:09:54.284 --> 06:09:57.031
concepts from what we already 
know from the rest of Kotlin.  

06:09:57.314 --> 06:10:00.897
If the block-in code is running,
it requires cooperation in order

06:10:01.358 --> 06:10:05.338
to stop what it is doing.  So we
can check for that cancellation 

06:10:05.869 --> 06:10:11.012
explicitly in a couple ways.  
Generally this means checkinging

06:10:11.880 --> 06:10:16.128
to see if the Coroutine is 
active. 

06:10:16.129 --> 06:10:20.175
And one of the patterns is if 
you know the job is canceled, 

06:10:20.698 --> 06:10:24.962
you can call the stock 
suspendingsuspending method, 

06:10:24.963 --> 06:10:29.567
such as yield, to force the 
cancellation to be thrown.  If 

06:10:29.568 --> 06:10:33.742
you are canceled, when you are 
trying to suspendsuspend, you 

06:10:33.743 --> 06:10:37.335
will resume when the 
cancellation exception, so it 

06:10:37.336 --> 06:10:40.710
will immediately throw if we 
happen to be canceled.  If you 

06:10:40.940 --> 06:10:44.298
throw a tight loop, you can 
check the is active that is 

06:10:44.836 --> 06:10:46.915
available from any suspending 
scope and you can stop what you 

06:10:47.182 --> 06:10:51.010
are doing.  There is no reason 
to involve an exception here if 

06:10:51.912 --> 06:10:54.678
you are doing a tight 
intercomputational loop you need

06:10:54.943 --> 06:11:00.186
to break out of.  And that leads
into how exceptions are handled 

06:11:00.782 --> 06:11:04.816
with coroutines in general, and 
there's a few things to point 

06:11:05.049 --> 06:11:08.236
out, especially if you followed 
Kotlin's development leading up 

06:11:08.237 --> 06:11:10.935
to release, because there were 
significant things that 

06:11:11.330 --> 06:11:15.242
happened.  Launch will re-throw 
unhandled exceptions as they 

06:11:15.557 --> 06:11:19.480
happen.  It fails the parent, it
cancels the parent job.  The 

06:11:20.457 --> 06:11:26.094
parent sees the cancellation 
with the original exception as 

06:11:26.095 --> 06:11:29.683
the cause.  And they get thrown 
back to the exception handler in

06:11:29.684 --> 06:11:34.242
the root of the job tree, and 
the Coroutine context gets a 

06:11:34.243 --> 06:11:37.830
chance to intercept.  You can 
attach a special element to the 

06:11:38.660 --> 06:11:40.660
Coroutine concept itself that 
you can use to handle

06:11:43.994 --> 06:11:48.678
handle unhandled exceptions.  
How does it work? So say that 

06:11:48.679 --> 06:11:51.101
save show throws a 
domain-specific exception in 

06:11:51.102 --> 06:11:53.627
this case.
So in this case, this will be 

06:11:53.990 --> 06:11:57.726
treated like an on-call 
exception at run time, just like

06:11:57.727 --> 06:12:03.267
anything else that calls the 
exception on the main thread.  

06:12:03.503 --> 06:12:05.503
Async is different, if the 
exception is thrown while 

06:12:05.878 --> 06:12:08.877
something you launch with async 
is running, it will hold the 

06:12:09.140 --> 06:12:12.115
exception and only throw when 
the caller calls await.  So 

06:12:12.399 --> 06:12:15.005
going back to the example from 
before, we will use what we 

06:12:15.881 --> 06:12:17.677
know.
So we throw our exception from 

06:12:17.678 --> 06:12:22.075
one of these async jobs, and 
that gets thrown from this call 

06:12:22.600 --> 06:12:25.960
to await itself.  So we know 
exactly where we need to try and

06:12:26.145 --> 06:12:29.221
catch that exception in the 
normal way and handle that 

06:12:29.484 --> 06:12:33.184
error.
But there's a gotcha here, and 

06:12:33.474 --> 06:12:36.727
that is that async works the 
same as launch in terms of how 

06:12:37.015 --> 06:12:41.580
the nested job tree is handled. 
The deferred object is another 

06:12:41.846 --> 06:12:46.329
kind of job, it will cancel the 
parent, just like launch does, 

06:12:46.944 --> 06:12:49.609
and it will do it even if we did
an await and called it.  This is

06:12:50.126 --> 06:12:53.664
important, if something throws 
an exception, it is important 

06:12:54.240 --> 06:12:56.786
that your app knows about it, it
should not disappear into the 

06:12:57.058 --> 06:12:59.058
Ether, but

06:13:03.508 --> 06:13:08.442
it  we caught it, what do we do?
So instead of using Coroutine, 

06:13:08.443 --> 06:13:14.685
we can use supervisor scope.  It
works like a Coroutine scope, 

06:13:14.686 --> 06:13:19.392
but it is a supervisor job that 
will not be 

06:13:22.797 --> 06:13:26.827
canceled if it is handled with 
an unhandled exception. 

06:13:26.828 --> 06:13:31.165
SPEAKER: And earlier, we 
mentioned that me can decide 

06:13:31.166 --> 06:13:35.487
when coroutines are run and what
thread they run on.  On Android,

06:13:35.890 --> 06:13:38.196
we run on threads, and we are 
using the thread pull 

06:13:38.689 --> 06:13:42.845
underneath.  And we can decide 
when that is dispatched on.

06:13:42.846 --> 06:13:46.001
And now let's have a look.  We 
are running a very simple 

06:13:46.002 --> 06:13:49.223
launch, that is missing a scope.
We are looking at the example.  

06:13:49.519 --> 06:13:53.051
And default is the context we 
are using what is called a 

06:13:54.069 --> 06:13:58.666
dispatch.default, that is what 
is given to you for free, and it

06:13:58.962 --> 06:14:03.858
is default for everyone 
FWLNCHLTS . 

06:14:03.859 --> 06:14:07.320
SPEAKER: A computation thread 
pool. 

06:14:07.321 --> 06:14:09.321
SPEAKER: So

06:14:10.649 --> 06:14:14.635
what is a Coroutine dispatcher? 
It schedules it to run on 

06:14:15.564 --> 06:14:17.460
something, in a thread in this 
case.

06:14:17.461 --> 06:14:22.160
And the default, which you can 
get, is it uses CPU threads.  So

06:14:23.622 --> 06:14:28.262
your device has four CPUs in it,
you will get a thread pull of 

06:14:28.263 --> 06:14:36.645
four.  So it is not as great as 
I/O, it is more like a 

06:14:36.919 --> 06:14:41.388
computational-type dispatcher.  
And it is also an Elastic thread

06:14:41.389 --> 06:14:43.440
executor, that I will talk about
in a minute, but it is the 

06:14:43.984 --> 06:14:47.582
default.  There are 
dispatchers.I/O, that was added 

06:14:48.434 --> 06:14:50.801
recently, and it was designed 
for blocking I/O tasks, so 

06:14:51.082 --> 06:14:55.540
things that we care about, 
network, image loading, reading 

06:14:56.269 --> 06:15:00.729
disks, database, blah blah blah.
It uses 64 parallelism, which 

06:15:01.254 --> 06:15:05.191
means you can have 64 tasks run 
at a time.  It can launch it 

06:15:05.811 --> 06:15:12.213
like that.  And the really great
thing about the I/O dispatcher 

06:15:12.510 --> 06:15:16.119
is it shares thread pulls with 
the default dispatcher. And the 

06:15:16.388 --> 06:15:19.585
point where it is great is this.
We have an async that is using 

06:15:19.837 --> 06:15:24.834
the default dispatcher, and then
we load an image on the I/O 

06:15:25.854 --> 06:15:28.572
dispatcher, we do disk reading, 
and then we're going to use that

06:15:28.573 --> 06:15:33.241
result and process it somehow.  
It is a computational task.

06:15:33.242 --> 06:15:35.687
And now what?
Because this is running on the 

06:15:35.962 --> 06:15:41.032
default dispatcher, there is no 
actual switch in there, we are 

06:15:41.292 --> 06:15:44.802
using the shared thread pools, 
the I/O uses the shared threads,

06:15:45.141 --> 06:15:49.089
and there is no actual thread 
switch which makes it a whole 

06:15:49.525 --> 06:15:58.400
lot quicker.  And we have 
dispatch.main, it allows running

06:15:58.759 --> 06:16:02.336
coroutines on the main thread.  
And it uses service loader to 

06:16:02.337 --> 06:16:06.298
load the dispatcher in your 
code, which is tricky when we 

06:16:07.845 --> 06:16:09.845
have things like 

06:16:13.080 --> 06:16:17.811
Pergyle, so you need to be 
careful and add the Android 

06:16:18.072 --> 06:16:20.072
dependency.  So use it,

06:16:25.201 --> 06:16:33.282
launch the dispatch.  That 
brings us to reactivity.

06:16:33.283 --> 06:16:37.573
How many launches can be 
summarized by this slide? I have

06:16:37.574 --> 06:16:40.799
been guilty of this.
And I will make the premise and 

06:16:41.897 --> 06:16:48.522
the statement that most devs use
RX Java because you can switch a

06:16:48.523 --> 06:16:56.129
thread, or switch multiple 
threads, that is when most RX 

06:16:56.408 --> 06:17:01.372
Java is useful.  And I think, 
for 80 percent of the cases, it 

06:17:01.628 --> 06:17:04.098
is a switcher thread.  And that 
is because the APIs that we 

06:17:04.099 --> 06:17:07.148
have, and we spoke about them 
earlier, are not so great to 

06:17:08.677 --> 06:17:10.681
use.
And because of that, most people

06:17:10.682 --> 06:17:14.316
end up using things like single,
maybe, and completeable.  That's

06:17:14.692 --> 06:17:17.785
what they are, they are a 
single, one-shot thing, a single

06:17:18.217 --> 06:17:21.536
allows you to have a type, maybe
it is nullable, and the 

06:17:21.537 --> 06:17:23.961
completeable doesn't have a 
return type.  They are all 

06:17:24.350 --> 06:17:32.549
pretty similar.  But in fact, 
they only exist on RX 

06:17:38.556 --> 06:17:42.867
Java, RX Ruby.
  So they can be replaced by 

06:17:43.191 --> 06:17:45.985
single, maybe, and completeable.
They do what you think.  They 

06:17:46.321 --> 06:17:49.797
replace call-backs, and they 
replace these nicely.  So as an 

06:17:50.221 --> 06:17:56.481
example, we have a retrofit 
interface, and it has a Git and 

06:17:57.276 --> 06:18:06.552
returns a single.  And the way 
you use that a in RX Java, we 

06:18:07.177 --> 06:18:11.933
have the scheduler, and we will 
do some calls when it is finish 

06:18:12.143 --> 06:18:16.505
ed.  The nice thing about the RX
two libraries of coroutines, you

06:18:16.933 --> 06:18:20.398
can use that exact single as an 
await.  So you can actually use 

06:18:20.664 --> 06:18:25.292
it as a suspending deferred.  So
it is handy for when you are 

06:18:26.300 --> 06:18:28.779
slowly migrating towards 
coroutines and you don't want to

06:18:29.029 --> 06:18:33.309
change from day one.  You can 
actually keep those interfaces, 

06:18:33.892 --> 06:18:37.321
and you can actually just call 
await on them and you never 

06:18:37.753 --> 06:18:40.845
receive using coroutines.  It is
a handy way to slowly 

06:18:43.859 --> 06:18:45.859
migrate.
And wouldn't it be great if we 

06:18:46.238 --> 06:18:49.802
can make the retrofit call, a 
suspending function, and remove 

06:18:50.069 --> 06:18:53.353
the RX from the start?
Well, we can.  And that is 

06:18:53.637 --> 06:18:57.805
coming to retrofit soon.  Jake 
has a PR, in review, and he 

06:18:58.194 --> 06:19:00.194
tells me it is

06:19:05.008 --> 06:19:12.748
soon.  And if you look at 
consuming code, it is a normal 

06:19:12.749 --> 06:19:19.164
suspending call.  And that 
brings us to a final section, 

06:19:19.165 --> 06:19:21.986
bringing it together and trying 
to think of two scenarios that 

06:19:21.987 --> 06:19:25.050
we will show you to use 
coroutines to make your lives 

06:19:25.051 --> 06:19:27.589
easier on Android.  Both of 
these examples are about 

06:19:27.590 --> 06:19:31.423
location.  The first is about 
getting the last known 

06:19:34.957 --> 06:19:38.523
location, which is the call 
back.  And we will use the fused

06:19:38.794 --> 06:19:42.673
location provider client.  And 
it is kind of cool, it combines 

06:19:42.674 --> 06:19:47.713
all the providers that we have, 
like WiFi, GPS, mobile, and 

06:19:48.008 --> 06:19:50.650
bluetooth, it provides all the 
providers for you into one 

06:19:50.923 --> 06:19:55.334
single API.  It is a nice API to
use.  And it returns a task, a 

06:19:57.386 --> 06:20:01.198
futury-type thing that the 
library has.

06:20:01.199 --> 06:20:03.260
And so you get the 
classification and it returns 

06:20:03.663 --> 06:20:08.773
the task.  And then you add the 
complete listener and you get 

06:20:09.045 --> 06:20:11.863
the result back.  So it is 
completely async.

06:20:11.864 --> 06:20:18.882
So what we are doing is we are 
converting the call back API 

06:20:19.692 --> 06:20:23.957
into a suspended function.  The 
coroutines library has two 

06:20:24.225 --> 06:20:29.834
builders that do what we want.  
The first is suspend Coroutine, 

06:20:30.554 --> 06:20:33.757
and you pass a Lambda under it 
that allows you to set up the 

06:20:34.042 --> 06:20:39.810
call back.  So we call play 
services.  And then, at that 

06:20:40.254 --> 06:20:43.867
point, the Coroutine suspends 
waiting for the results to come 

06:20:44.320 --> 06:20:47.537
back, and the call back can wake
up, basically.

06:20:47.538 --> 06:20:51.506
So right now, you are getting a 
continuation to later resume. 

06:20:51.721 --> 06:20:53.954
And then you will pass the 
result back.

06:20:53.955 --> 06:20:55.955
And it allows

06:20:58.766 --> 06:21:00.766
the 

06:21:04.348 --> 06:21:07.235
call.
So there is the suspend 

06:21:07.528 --> 06:21:12.476
cancelable Coroutine.  So let's 
say it is canceled, you can -- 

06:21:12.875 --> 06:21:16.904
under the line API, play 
services, to cancel its call.

06:21:17.310 --> 06:21:22.508
So we will build that function, 
get classification, and it 

06:21:22.795 --> 06:21:25.629
returns a location, not the 
future or anything like that.  

06:21:25.906 --> 06:21:29.454
Just a straight location.  And 
so we are going to use our 

06:21:30.224 --> 06:21:32.685
suspend cancelable Coroutine 
builder, and then you get a 

06:21:32.952 --> 06:21:36.522
continuation, the call-back type
thing, and then we are going to 

06:21:36.804 --> 06:21:40.694
set up, so you are going to call
the location client, the play 

06:21:41.294 --> 06:21:46.158
services API, the last location,
and then we get a task back and 

06:21:46.442 --> 06:21:48.805
add the complete listener.  At 
that point, we are going to wake

06:21:49.090 --> 06:21:52.084
up our Coroutine.  So that is 
how we pass back to the 

06:21:52.700 --> 06:21:57.341
suspended Coroutine, the result,
and it wakes up in the suspended

06:21:57.598 --> 06:22:02.533
function basically, or it 
resumes.

06:22:02.534 --> 06:22:07.045
And because this is a 
cancelable, because this we are 

06:22:07.365 --> 06:22:10.160
using task, we are not using 
success, we are using the 

06:22:10.683 --> 06:22:13.253
complete listener, which means 
that the task itself can throw 

06:22:13.254 --> 06:22:18.597
an exception.  It can fail for 
whatever reason, so you don't 

06:22:18.598 --> 06:22:21.368
have location permission or 
whatever it be.  It will raise 

06:22:21.369 --> 06:22:24.928
an exception on you, so you can 
populate that back up to the 

06:22:24.929 --> 06:22:29.069
call, which is done with the 
review and exception method.

06:22:29.070 --> 06:22:32.700
And finally, because we are 
using suspend cancelable 

06:22:33.286 --> 06:22:36.531
Coroutine, we need to tell the 
play services API that we have 

06:22:36.532 --> 06:22:39.470
been canceled, so therefore it 
should cancel.  So we did that 

06:22:39.471 --> 06:22:45.658
with a call back, which is 
invoke on completion, and once 

06:22:45.938 --> 06:22:49.980
you know it has been canceled, 
you have play services.  And 

06:22:50.252 --> 06:22:52.931
play services does not have the 
cancel method, but imagine it 

06:22:53.199 --> 06:22:55.574
exists.
  And now Adam is going to talk 

06:22:56.082 --> 06:22:57.508
about observing. 
SPEAKER: Sure.  So what happens 

06:22:57.509 --> 06:23:02.570
when you want to observe a 
sequence of events over time? 

06:23:02.863 --> 06:23:07.482
This is what RX is good at, if 
you are using it for anything t 

06:23:07.831 --> 06:23:12.741
, it should be this.  People 
compare RX and coroutines quite 

06:23:12.964 --> 06:23:16.619
a bit, so what does it look like
if we emulate this using 

06:23:17.436 --> 06:23:21.409
coroutines as a primitive.  So 
it is an API in addition to 

06:23:21.896 --> 06:23:25.096
letting you get a one-shot, it  
the current location, you have 

06:23:25.097 --> 06:23:32.078
the up adapts updates.  So this 
is a prime candidate to be an 

06:23:34.303 --> 06:23:37.385
observable.  And we get this 
composable control over shutting

06:23:37.386 --> 06:23:41.803
it down the  down the updates 
cleanly.  It offers a lot of 

06:23:42.151 --> 06:23:44.549
functionality to build things 
like this.  So how many similar 

06:23:44.881 --> 06:23:47.607
benefits can we get if we base 
this off of suspending 

06:23:47.908 --> 06:23:50.219
functions?
So let's again start just 

06:23:50.665 --> 06:23:53.910
writing a simple function, or it
is going to start out simple.  

06:23:54.394 --> 06:23:56.544
Suspending functions do not 
return until the work is done.  

06:23:56.891 --> 06:23:59.345
There is no disposable or 
closeable return, since the 

06:24:00.108 --> 06:24:02.265
calling scope itself is 
cancelable, we do not return 

06:24:02.497 --> 06:24:06.014
until we are done.  So the 
observer in this case can be a 

06:24:06.626 --> 06:24:11.353
Lambda that accepts a location 
result, we will call it whenever

06:24:11.756 --> 06:24:14.443
a new location is reported 
without returning from the 

06:24:14.764 --> 06:24:16.764
observed location.  So if you 
take in the giant pile of code 

06:24:16.956 --> 06:24:25.221
here, some of you may mote  
notice that it looks like an 

06:24:26.554 --> 06:24:29.357
observable.create.  We will 
create the done signal that we 

06:24:29.358 --> 06:24:33.493
can await on later, so is this 
like the observable completion. 

06:24:34.071 --> 06:24:37.388
If you have a stream with a 
well-defined end signal, you can

06:24:38.135 --> 06:24:40.326
clean this up to let it clean up
and return and we will see that 

06:24:40.691 --> 06:24:44.488
in a bit.  So the next piece 
here, we are creating a location

06:24:45.266 --> 06:24:50.217
call-back, we need to know when 
to receive updates from the 

06:24:50.218 --> 06:24:52.218
provider.  We use launch to

06:24:55.128 --> 06:24:58.465
get the -- the Coroutine scope 
that we opened here carries the 

06:24:58.886 --> 06:25:01.153
dispatcher with it that it was 
called with.  So we know that we

06:25:01.154 --> 06:25:04.116
are going to call the observer 
in the same place that the 

06:25:05.019 --> 06:25:07.059
caller wanted the information 
reported.

06:25:07.060 --> 06:25:12.091
So we cancel the old job, and we
call the observer when holding 

06:25:12.092 --> 06:25:17.432
the suspending new text, it 
keeps it serialized so we don't 

06:25:17.433 --> 06:25:20.011
have too many at once.  
And it will not have multiple 

06:25:20.536 --> 06:25:23.179
calls open at once either.  And 
this is an example of some of 

06:25:23.180 --> 06:25:26.439
the things that if you are 
building one of these things 

06:25:26.721 --> 06:25:31.244
yourself, this is a comparison 
that RX Java does a lot of these

06:25:32.449 --> 06:25:35.133
things for you.  With 
coroutines, we have the 

06:25:35.412 --> 06:25:37.744
primitives to build it, but we 
need to do a little bit more by 

06:25:38.314 --> 06:25:41.755
hand.  And so we register the 
call back, and then we await on 

06:25:42.245 --> 06:25:46.471
the done signal.  Since we never
complete it, when is the 

06:25:47.045 --> 06:25:51.229
location stream complete anyway?
This waits for the calling job 

06:25:51.615 --> 06:25:55.108
to be canceled.  So we have it 
on the blog, and request 

06:25:55.763 --> 06:26:01.060
location updates takes a looper 
instead of an executor, which is

06:26:01.611 --> 06:26:05.044
unfortunate.  So if you can use 
a direct executor, it will just 

06:26:05.045 --> 06:26:09.647
go ahead and run the observer 
wherever the update happens on 

06:26:10.048 --> 06:26:14.280
the incoming binding thread, it 
shines when you can avoid the 

06:26:14.686 --> 06:26:18.161
extra hops.  You get the idea.
And so here is what it looks 

06:26:18.162 --> 06:26:24.336
like in use, and it looks a lot 
like a four H call in a 

06:26:24.847 --> 06:26:28.758
collection and behaves the same 
way.  If we use launch to call 

06:26:30.618 --> 06:26:33.856
the observer, if the location 
call itself will

06:26:39.054 --> 06:26:43.570
throw in itself.  So it is a 
child job, it will chancel the 

06:26:43.571 --> 06:26:47.608
parent scope with the exception 
as well, what wraps the observed

06:26:47.860 --> 06:26:53.488
location function body.  It will
have the await, unregister it 

06:26:53.489 --> 06:26:57.055
from the final block from above 
and all of this composes so you 

06:26:57.056 --> 06:26:59.622
can lean on the constructs of 
the language that you know by 

06:26:59.623 --> 06:27:01.623
adding some of these suspending

06:27:05.395 --> 06:27:07.349
primitives.
SPEAKER: So we will wrap up a 

06:27:07.350 --> 06:27:10.444
little bit.  What is next?
Well, the first is that, as you 

06:27:10.724 --> 06:27:15.243
saw thin keynote earlier, we 
have a code lab for coroutines, 

06:27:15.848 --> 06:27:20.103
that was released three weeks 
ago, a really good introduction 

06:27:20.104 --> 06:27:23.019
into coroutines and how to use 
it in your app.  Read the 

06:27:23.371 --> 06:27:28.326
manual, and the docs are really,
really good.

06:27:28.327 --> 06:27:31.421
And you can edit them how you 
want to, they are use-case 

06:27:31.807 --> 06:27:36.104
based, so I need to do X, how do
I do it? Make sure to check it 

06:27:36.241 --> 06:27:41.600
out if you are using coroutines.
That is it, thank you very much.

06:27:50.699 --> 06:27:52.699
[ Applause.] 
Coming up next: Modern WebView 

06:27:55.577 --> 06:27:59.643
Best Practices by Nate Fischer, 
Richard Coles, Toby Sargeant.

06:27:55.577 --> 06:27:56.746
Coming up next: Modern WebView 
Coming up next: Modern WebView 

06:27:56.747 --> 06:28:00.947
Best Practices by Nate Fischer, 
Coming up next: Modern WebView 

06:27:56.747 --> 06:28:00.947
Best Practices by Nate Fischer, 
Coming up next: Modern WebView 

06:27:56.747 --> 06:27:58.747
Coming up next: Modern WebView 

06:28:36.732 --> 06:28:40.932
Best Practices by Nate Fischer, 
Coming up next: Modern WebView 

06:28:36.732 --> 06:28:40.932
Best Practices by Nate Fischer, 
Coming up next: Modern WebView 

06:28:36.732 --> 06:28:40.798
Best Practices by Nate Fischer, 
Richard Coles, Toby Sargeant.

06:28:36.732 --> 06:28:38.732
1XZ

06:36:54.922 --> 06:36:56.922
Coming up next: Modern WebView 

06:40:42.006 --> 06:40:46.272
Best Practices by Nate Fischer, 
Richard Coles, Toby Sargeant. [ 

06:40:42.006 --> 06:40:44.375
Applause ]. 
SPEAKER: Hi, everyone.  My name 

06:40:45.393 --> 06:40:47.818
is Nate, I'm here from the 
WebView team, I would like to 

06:40:48.485 --> 06:40:51.313
talk about some modern WebView 
best practices or, as I like to 

06:40:51.536 --> 06:40:55.132
call it, using WebView like it 
is 2018.  Because

06:40:59.052 --> 06:41:01.052
it is.
Before I dive into what is 

06:41:01.190 --> 06:41:04.914
modern with WebView, we will 
talk about what is old.

06:41:04.915 --> 06:41:08.799
So WebView has been around since
the very beginning, added in API

06:41:09.073 --> 06:41:12.438
level 1, and it changed in a 
significant way, starting with 

06:41:12.634 --> 06:41:15.835
Lollipop.  It became updateable,
the implementation was.  And 

06:41:16.105 --> 06:41:20.130
this was great, it meant that 
users could benefit from 

06:41:20.131 --> 06:41:23.154
security fixes and bug fixes, it
would update every six weeks, 

06:41:23.335 --> 06:41:27.503
just like your browser.  And a 
lot has changed since then, too.

06:41:27.504 --> 06:41:32.960
We added 40 new APIs, ZUST  -- 
just to make it easier to work 

06:41:34.418 --> 06:41:36.705
with WebView to help developers.
But what has really changed? 

06:41:36.954 --> 06:41:39.374
Well, when we look at the 
ecosystem, it seems like apps 

06:41:39.706 --> 06:41:44.171
are kind of using WebView the 
same way they have always used 

06:41:44.356 --> 06:41:49.489
it.  And when you look at 
StackOverflow, the answers are 

06:41:50.046 --> 06:41:52.046
outdated at best.  They are 
certainly not best practices 

06:41:52.113 --> 06:41:57.354
and, often times, they are just 
wrong.  But some of the blame is

06:41:57.783 --> 06:42:02.239
on our shoulders, too.  A lot of
the doc is still written like it

06:42:02.644 --> 06:42:05.169
is API level one and a lot has 
changed since then.  So we 

06:42:05.432 --> 06:42:09.707
looked over the past year and we
looked out at the Android 

06:42:09.886 --> 06:42:11.886
ecosystem and the devices that 
are out there today. And what we

06:42:12.047 --> 06:42:17.560
found is that, although we 
added, you know, on nougat, all 

06:42:19.614 --> 06:42:22.464
of these great APIs, a lot of 
apps cannot take advantage of 

06:42:22.809 --> 06:42:24.809
them because they run on the

06:42:28.758 --> 06:42:33.035
nougat devices, less than 5 
percent of devices today and it 

06:42:33.656 --> 06:42:37.911
has been two years since it came
out.  And a lot of devices are 

06:42:38.107 --> 06:42:43.925
running lollipop and the 
implementation of the APIs are 

06:42:43.926 --> 06:42:48.464
not exposed on older platform 
levels.  We thought, can we do 

06:42:49.106 --> 06:42:51.759
better?
So, over the past year, we 

06:42:53.004 --> 06:42:55.565
worked on our AndroidX library. 
We launched a new AndroidX 

06:42:55.566 --> 06:42:59.102
library, and we are pretty 
excited about it.  The basic 

06:42:59.103 --> 06:43:02.570
idea is we will bring in all of 
these brand new developer APIs, 

06:43:02.571 --> 06:43:05.400
but we are going to try to give 
you the device coverage you 

06:43:05.401 --> 06:43:13.147
need, and we are going to 
support lollipop and above.  We 

06:43:13.464 --> 06:43:16.676
will leverage the update cycle, 
and make sure that it is usable 

06:43:16.677 --> 06:43:19.871
so you can use the APIs to do 
productive things.  We designed 

06:43:20.940 --> 06:43:23.350
them to be straightforward to 
swap out from the framework's 

06:43:23.609 --> 06:43:29.181
APIs.  So this all sounds fine, 
but how can we use it to make 

06:43:29.412 --> 06:43:32.552
your apps better?
So let's take an example.  Since

06:43:32.835 --> 06:43:36.005
the very beginning of Android, 
we have given apps a lot of 

06:43:36.290 --> 06:43:40.282
power to customize WebView's 
behavior.  And, in particular, 

06:43:40.283 --> 06:43:46.805
we added a call back called 
override loading, and the idea 

06:43:46.806 --> 06:43:50.937
of this call back, for search 
and navigations, you can cancel 

06:43:50.938 --> 06:43:57.005
things in the WebView and 
dispatch them to a different 

06:43:57.187 --> 06:44:01.664
thread instead.  Joy can have a 
YouTube url that is better 

06:44:02.170 --> 06:44:04.460
suited in the YouTube app. And 
this is great, a lot of apps 

06:44:04.461 --> 06:44:06.394
took advantage of this.  But 
there was a problem with the 

06:44:06.395 --> 06:44:09.399
API, we did not get it right the
first time.  And the issues that

06:44:09.400 --> 06:44:15.410
JavaScript can trigger 
navigations, there is malicious 

06:44:15.411 --> 06:44:18.602
JavaScript out in the wild that 
actually tries to exploit this 

06:44:19.377 --> 06:44:21.377
app behavior.  And, from the 

06:44:24.737 --> 06:44:27.282
useruser's perspective, they 
might be reading web content and

06:44:27.539 --> 06:44:29.987
without their interaction, it 
starts opening up some new 

06:44:30.361 --> 06:44:32.438
Android app that they are not 
trying to open.

06:44:32.439 --> 06:44:37.070
And so we actually already fixed
this issue.  We fixed it back in

06:44:37.639 --> 06:44:41.524
Nougat, where the idea is that 
we exposed this notion of user 

06:44:41.790 --> 06:44:44.585
gesture.  Did the user trigger 
this navigation?

06:44:44.586 --> 06:44:48.906
And it actually works really, 
really well, but it only works 

06:44:48.907 --> 06:44:56.193
on the Nougat and above devices,
and these -- before, Nougat 

06:44:56.714 --> 06:45:01.043
devices are still vulnerable.  
Weal thought it was a candidate 

06:45:01.317 --> 06:45:05.966
for AndroidX library, we will do
this gesture all the way back to

06:45:06.268 --> 06:45:08.268
loll

06:45:10.775 --> 06:45:14.193
Pop for devices and you can make
it a safe experience for all of 

06:45:14.194 --> 06:45:19.245
your users, and we can make it 
easy for apps to override T. 

06:45:19.246 --> 06:45:23.833
There is no confusion.  I think 
we succeeded, but we will look 

06:45:23.834 --> 06:45:30.799
at the code.  Before Nougat this
is what a lot of app code looked

06:45:31.078 --> 06:45:33.078
like,

06:45:35.195 --> 06:45:37.238
we are doing overview coding, 
and in the 

06:45:40.427 --> 06:45:43.783
coding, and this is the insecure
version of the API but in the 

06:45:43.784 --> 06:45:48.248
past the best we could do.  Some
better apps that were out there 

06:45:48.249 --> 06:45:51.359
is something like this, you are 
overriding the old implement 

06:45:51.360 --> 06:45:57.049
from before, the before Nougat 
devices, and the newer devices, 

06:45:57.050 --> 06:46:00.880
you have this implementation, we
are choosing user gesture, we 

06:46:00.881 --> 06:46:03.929
not launching intent if we don't
have user gesture.

06:46:03.930 --> 06:46:07.511
So this seems great, but it only
runs on a small number of 

06:46:07.873 --> 06:46:11.887
devices, even today, only 50 
percent.

06:46:11.888 --> 06:46:14.842
So here's how it looks like with
AndroidX.  And the first thing I

06:46:15.127 --> 06:46:17.758
want to point out is that almost
nothing changed on this slide.  

06:46:18.164 --> 06:46:20.476
I think that is really 
beautiful, it means all the code

06:46:20.477 --> 06:46:23.966
that you already wrote to 
handle, you know, the old 

06:46:24.344 --> 06:46:26.824
framework APIs, that code is all
the same.

06:46:26.825 --> 06:46:29.572
The only difference here is that
we are employing -- we are 

06:46:30.033 --> 06:46:34.915
importing our WebView client 
compat class from the AndroidX 

06:46:35.289 --> 06:46:38.782
library, we setting this compat 
client, and the idea is that we 

06:46:38.783 --> 06:46:41.462
are using the compat client,

06:46:45.196 --> 06:46:51.929
instead of invoked on Nougat and
involved, they are invoked to 

06:46:51.930 --> 06:46:55.221
Lollipop so you can provide your
users a safer experience without

06:46:56.502 --> 06:46:58.502
changing a lot of code.
  This is one example we have to

06:46:58.561 --> 06:47:05.577
everyone in AndroidX. O I I 
would like you to check it out 

06:47:06.019 --> 06:47:08.936
it  to so how it can make your 
app better.  We are giving you 

06:47:08.937 --> 06:47:12.656
the device coverage you need to 
use these APIs, but we will have

06:47:12.848 --> 06:47:15.650
a lot more APIs available.  Some
of these are small improvements 

06:47:15.651 --> 06:47:21.714
on classic APIs, like we've 
seen, and some them are for en 

06:47:22.508 --> 06:47:24.508
tirely new features, like safe 
browsing. 

06:47:26.975 --> 06:47:32.783
And had point is this is not in 
a soon to be released library, 

06:47:32.784 --> 06:47:37.325
it is out there, ready to go, so
you can try to 1.0 release.  I 

06:47:37.326 --> 06:47:40.837
would like to shift gears a 
little bit.  We looked at the 

06:47:40.838 --> 06:47:43.754
AndroidX APIs, these same great.
You are going to give us new 

06:47:43.755 --> 06:47:50.775
APIs with, you know, pretty good
device coverage, almost ninety 

06:47:50.776 --> 06:47:55.161
90 percent.  What about the APIs
around forever, they have 100 

06:47:55.162 --> 06:47:58.456
percent device coverage, but 
some of them are hard to use.  

06:47:58.457 --> 06:48:01.284
Even I struggle to use them 
correctly and I working on the 

06:48:01.470 --> 06:48:06.262
team.  A common use cay we have 
seen is loading in-app content. 

06:48:06.263 --> 06:48:09.342
And the idea is that you want to
display some content in your 

06:48:09.605 --> 06:48:11.410
application, but you don't 
necessarily want to fetch it 

06:48:11.411 --> 06:48:14.515
over the internet, you want to 
just compile it right into your 

06:48:15.306 --> 06:48:17.841
app.
But you also want to continue to

06:48:18.417 --> 06:48:21.462
build this content with web 
technology.  You want to use 

06:48:21.870 --> 06:48:25.474
html, JavaScript, CSS.  And 
WebView has had pretty good 

06:48:25.475 --> 06:48:28.386
support for this, in fact, we 
almost have too much support for

06:48:28.776 --> 06:48:32.519
this.  We have so many APIs that
it is hard to figure out which 

06:48:32.520 --> 06:48:35.275
one is actually the right thing 
to use.

06:48:35.276 --> 06:48:39.283
And some of them have some weird
gotchas that make them kind of 

06:48:39.284 --> 06:48:43.461
hard to use.
And so I thought maybe we could 

06:48:43.774 --> 06:48:47.253
take a look at some of these 
APIs and talk about what is so 

06:48:47.519 --> 06:48:50.316
tough about them and recommend 
some best practices.  You don't 

06:48:50.317 --> 06:48:53.174
have to start from scratch with 
a new API, but you can kind of 

06:48:53.450 --> 06:48:56.397
tweak how you are using these.  
So the first API that we can 

06:48:57.450 --> 06:49:00.622
look at is Load Data, and the 
basic idea is that this is going

06:49:01.413 --> 06:49:05.131
to accept some html content.  It
accepts it as a string, and it 

06:49:05.446 --> 06:49:08.347
is supposed to display this in 
the WebView.

06:49:08.348 --> 06:49:14.138
And but one of the gotchas is it
does not really accept html 

06:49:14.416 --> 06:49:17.164
content, but encoded content.  
The idea is that you need to 

06:49:17.447 --> 06:49:20.657
escape special characters, 
replace them with a percent sign

06:49:21.383 --> 06:49:25.392
and the code following it.
And we call this percent in 

06:49:25.683 --> 06:49:29.274
coding, this is the default 
configuration for the API.  But 

06:49:29.275 --> 06:49:32.621
there is actually no framework 
API to do the percent in coding 

06:49:33.161 --> 06:49:37.145
for you.
It is kind of an oversight.

06:49:37.146 --> 06:49:40.704
But the end result is that 
developers, what we've seen, is 

06:49:41.014 --> 06:49:44.614
that developers tend to actually
do this percent in coding by 

06:49:44.615 --> 06:49:49.155
hand themselves.  And this is 
manual, it leads to bugs, and 

06:49:49.805 --> 06:49:52.489
these bugs can have significant 
impacts for your application.  

06:49:52.762 --> 06:49:56.413
You know, one small bug might 
seem okay today, but it might 

06:49:56.665 --> 06:50:01.203
break in a future WebView update
if you forget to encode a 

06:50:01.204 --> 06:50:03.866
particular character.
The other issue with load data 

06:50:04.151 --> 06:50:06.569
is this thing called an opaque 
origin.

06:50:06.570 --> 06:50:10.453
So when your content is loaded 
with what is called an opaque 

06:50:10.624 --> 06:50:13.925
origin, this means that it is 
going to fail all the same 

06:50:14.124 --> 06:50:17.606
origin checks in the web.
And these same origin checks are

06:50:18.011 --> 06:50:22.688
actually chit  critical to 
providing powerful web APIs

06:50:26.023 --> 06:50:32.436
securely.  Without these, you 
cannot provide great APIs, like 

06:50:33.050 --> 06:50:38.040
html http requests.
So what can you do with this 

06:50:38.041 --> 06:50:42.630
APIAPI? You can escape the 
coding-related problems.  This 

06:50:42.631 --> 06:50:47.085
API has always accepted an 
alternate encoding scheme, base 

06:50:47.086 --> 06:50:50.945
64.  This is not that special of
a coding scheme, it is just a 

06:50:51.128 --> 06:50:53.202
different scheme.  It is not 
necessarily better, but it is 

06:50:53.487 --> 06:50:55.864
kind of nice because there is 
actually a framework API that 

06:50:56.191 --> 06:50:59.544
will do the encoding for you, 
and it does it correctly.  

06:50:59.545 --> 06:51:03.424
Great.
So the base64, encode to string,

06:51:03.849 --> 06:51:06.490
it will take the content, spit 
out the right answer.  And the 

06:51:06.754 --> 06:51:10.278
only reason it is not documented
is because this came out in API 

06:51:10.770 --> 06:51:14.455
level 8, which today is ancient 
history, but was still in the 

06:51:14.729 --> 06:51:16.729
future at the time of writing

06:51:19.313 --> 06:51:22.614
load data.
But we can also take a look at 

06:51:22.821 --> 06:51:25.615
the same origin restrictions.  
So the way we recommend to get 

06:51:26.430 --> 06:51:29.187
around this is to use something 
called load data with base url. 

06:51:29.967 --> 06:51:33.634
And one of the nice things about
this, I think of it as a 

06:51:34.082 --> 06:51:36.874
feature, not a bug, is that it 
actually accepts the content as 

06:51:37.865 --> 06:51:41.541
is.  You can give it content 
that is totally unencoded, you 

06:51:41.741 --> 06:51:44.582
don't have to worry about the 
base 64 stuff if you use this 

06:51:44.919 --> 06:51:47.130
API.
The other really nice thing 

06:51:48.045 --> 06:51:54.786
about it is it has this thing 
called a base url.  You are 

06:51:54.787 --> 06:51:58.932
displaying this as you pass in 
as a string, the base url 

06:51:59.374 --> 06:52:03.115
configures the origin that it 
operates it.  You can control 

06:52:03.608 --> 06:52:07.336
the origin that you get without 
disabling the important security

06:52:07.767 --> 06:52:12.217
settings, just to make the APIs 
work.  How do we choose the 

06:52:12.218 --> 06:52:15.081
right base url?
So this is something that even I

06:52:15.842 --> 06:52:18.491
struggle with when I try to use 
this API, I know it is the right

06:52:18.816 --> 06:52:20.816
thing,

06:52:23.206 --> 06:52:25.104
but I don't know what the right 
thing is to pass to it.  

06:52:25.105 --> 06:52:28.936
So we will go through the common
use cases.  So something that 

06:52:28.937 --> 06:52:33.524
we've seen in a lut  lot of apps
use cached content, it is 

06:52:33.525 --> 06:52:38.386
downloaded from the web over the
internet, but they are saving it

06:52:38.387 --> 06:52:42.668
for later.  Now when they show 
it, they need to show it with 

06:52:42.669 --> 06:52:48.282
the right base url.  And the url
you choose is just the original 

06:52:48.283 --> 06:52:50.795
url it came from.  So if it 
worked originally, it has the 

06:52:51.510 --> 06:52:55.235
same origin and all the APIs are
going to continue to work.  The 

06:52:55.236 --> 06:52:58.638
other use case that we have 
noticed is that apps tend to 

06:52:58.956 --> 06:53:00.965
shift the own content and 
display it this way, which is 

06:53:03.288 --> 06:53:06.340
great.
And we recommend that you choose

06:53:07.924 --> 06:53:13.804
a real internet-type url, and it
should use your organization's 

06:53:14.732 --> 06:53:19.280
real domain.  The reason for 
this is so you can import other 

06:53:19.511 --> 06:53:22.834
resources from the servers and 
use this content without 

06:53:23.102 --> 06:53:27.157
worrying about same origin 
checks, it will all work.  And 

06:53:27.592 --> 06:53:32.621
the question is, do we use https
or http? Here is the rule of 

06:53:32.923 --> 06:53:39.309
thumb, you want to use https as 
the secure protocol.  If you 

06:53:39.941 --> 06:53:42.109
need to share insecure 
resources, we recommend that you

06:53:42.400 --> 06:53:46.917
use the html scheme as opposed 
to disabling important security 

06:53:47.218 --> 06:53:49.376
settings just to get your app 
working.

06:53:49.377 --> 06:53:57.561
And as a last point I want to 
urge apps to avoid curs  custom 

06:53:57.823 --> 06:54:01.580
url schemes.  This is something 
that cropped up, they make up 

06:54:01.853 --> 06:54:04.483
their own scheme and use that.  
But the problem is that the web 

06:54:04.844 --> 06:54:07.715
standards don't really expect 
custom url schemes.  They are 

06:54:07.909 --> 06:54:10.062
very vague about how to handle 
this, and it turns out that they

06:54:10.344 --> 06:54:14.503
wind up getting handled very 
inconsistently, and this can 

06:54:14.504 --> 06:54:18.553
lead to surprising app breakage.
So if you can stick to one of 

06:54:19.226 --> 06:54:21.226
the internet url schemes you 
will have a much better

06:54:25.683 --> 06:54:28.687
time.
So hopefully I have expressed 

06:54:28.987 --> 06:54:30.987
that we care

06:54:32.192 --> 06:54:35.774
about developers at the WebView 
team and we are working hard to 

06:54:35.775 --> 06:54:40.358
make sure THLT  that you have 
powerful new APIs, paying 

06:54:40.359 --> 06:54:43.712
attention to the old APIs, and 
explaining how they need to be 

06:54:43.713 --> 06:54:46.933
used and they are actually 
usable.  If you have any 

06:54:47.251 --> 06:54:50.099
questions, me and my colleagues 
will be around for the rest of 

06:54:50.100 --> 06:54:52.871
today as well as tomorrow and 
would be more than happy to talk

06:54:53.520 --> 06:54:56.740
to you about WebView usage and 
what you need for your 

06:54:57.013 --> 06:54:59.013
application.  Thank you very 
much.

06:55:06.649 --> 06:55:08.649
[ Applause.] 
Coming up next: Low Latency 

06:57:11.828 --> 06:57:15.361
Audio - Because Your Ears Are 
Worth It by Don Turner.

06:57:11.828 --> 06:57:13.828
Coming up next: Low Latency 

07:02:43.067 --> 07:02:46.600
Audio - Because Your Ears Are 
Worth It by Don Turner.

07:02:43.067 --> 07:02:47.601
SPEAKER: Hello, hello.  My name 
is Don, I work in the Android 

07:02:47.814 --> 07:02:50.588
developer team, I'm here today 
to talk to you about low latency

07:02:50.910 --> 07:02:56.247
audio on Android.
So why is audio latency 

07:02:56.871 --> 07:03:03.007
important? Well, there are many 
use cases where the audio 

07:03:03.285 --> 07:03:07.200
latency is directly proportional
to the user experience.

07:03:07.201 --> 07:03:12.436
So this can be in games, where 
you tap on the screen and you 

07:03:12.823 --> 07:03:17.151
hear a sound, particularly in 
rhythm games, like Guitar 

07:03:17.620 --> 07:03:21.009
Hero-style games, you are 
tapping in response to some 

07:03:21.010 --> 07:03:23.398
rhythmic event and you need to 
have audible feedback as quickly

07:03:23.575 --> 07:03:26.786
as possible, like the longer the
delay between tapping on the 

07:03:27.052 --> 07:03:31.467
screen and hearing a sound, the 
worse the user experience.

07:03:31.468 --> 07:03:35.978
And also in DJing apps, you are 
tapping on the screen and 

07:03:36.357 --> 07:03:39.954
manipulating odd we and you 
expect that audio manipulation 

07:03:40.424 --> 07:03:42.424
to happen in realtime.  

07:03:47.584 --> 07:03:50.642
 Karaoke, you have the input, 
your voice, against a backing 

07:03:50.643 --> 07:03:54.533
track and also your own voice.  
So if the delay between you 

07:03:54.811 --> 07:03:57.841
singing and hearing your own 
voice is too long, then it 

07:03:58.284 --> 07:04:02.695
sounds awful.
And also, in VR, we have objects

07:04:02.975 --> 07:04:05.969
that make sound in a virtual 
world and, if that sound doesn't

07:04:06.493 --> 07:04:09.741
follow you around as your head 
moves in this environment, then 

07:04:10.063 --> 07:04:15.320
it kind of distorts the reality.
And lastly, of course, theres a 

07:04:16.722 --> 07:04:19.221
whole load of apps for live 
performance, sin 

07:04:25.507 --> 07:04:26.177
hesizers, drumming apps, 
anything where you press a key 

07:04:26.178 --> 07:04:29.844
and make a sound, you need 
low-latency audio.

07:04:29.845 --> 07:04:33.706
So, with this in mind, we built 
a library to help developers 

07:04:33.969 --> 07:04:37.212
build these kind of apps.  It is
called Oboe, and it is available

07:04:38.113 --> 07:04:40.959
on GitHub now.  We just launched
version 1, it is 

07:04:42.760 --> 07:04:46.454
production-ready, to be included
in your apps today.

07:04:46.455 --> 07:04:52.890
And the way it works is, under 
the hood, it uses the audio API 

07:04:53.153 --> 07:04:56.480
on API 27 and above, which is 
the new high performance, low 

07:04:57.028 --> 07:04:59.028
latency, audio introduced

07:05:01.948 --> 07:05:07.373
in Oreo.  And on all the 
devices, it uses open SLES. It 

07:05:07.674 --> 07:05:12.291
provides a simple, easy-to-use 
API that works across the widest

07:05:12.537 --> 07:05:17.486
range of devices.
  So rather than me talking 

07:05:17.487 --> 07:05:21.270
about this API, I thought it 
would be fun to build a musical 

07:05:21.271 --> 07:05:24.638
instrument in 17 minutes and 23 
seconds.

07:05:24.639 --> 07:05:27.756
So, before I start that, I'm 
going to explain the 

07:05:27.757 --> 07:05:30.878
architecture so it makes sense 
when I'm in the code.  So we 

07:05:31.342 --> 07:05:35.435
have an app, and I'm going to 
build the audioengine part of 

07:05:35.436 --> 07:05:37.958
this app.
This audioengine is going to be 

07:05:38.500 --> 07:05:41.612
responsible for creating an 
audiostream that is provided by 

07:05:42.390 --> 07:05:48.152
the Oboe library, we're going to
be passing audio frames of data 

07:05:49.288 --> 07:05:51.672
into this audiostream.  
Ultimately, this stream is 

07:05:51.940 --> 07:05:55.942
responsible for putting data out
of the audio device.  In this 

07:05:56.219 --> 07:06:01.834
case, it will be the 3 and a 
half millimeter jack on this 

07:06:02.091 --> 07:06:05.807
pixel XL phone.  And every time 
the audio device needs more 

07:06:05.808 --> 07:06:08.765
information, it is going to give
us a call-back.  So we get this 

07:06:09.101 --> 07:06:13.353
call-back loop of, hey, I need 
more audio data, and our 

07:06:14.012 --> 07:06:16.750
audioengine is going to be 
passing frames of audio data 

07:06:17.823 --> 07:06:23.808
into the audiostream.
For some form of control, we're 

07:06:23.809 --> 07:06:28.752
going to monitor tap events in 
that screen.  When you tap down,

07:06:29.356 --> 07:06:32.114
the sound will go on.  When you 
lift up, the sound will go off. 

07:06:32.508 --> 07:06:36.199
This works about 50 percent of 
the time in rehearsal, we will 

07:06:37.062 --> 07:06:40.712
see what happens.
Okay.

07:06:40.713 --> 07:06:44.224
First, I need to log in.
Okay, and

07:06:47.362 --> 07:06:50.059
can you see my screen?

07:06:55.012 --> 07:06:57.308
Fantastic.
Okay, so I'm just going to run 

07:06:57.684 --> 07:07:01.509
the app.  So I have a very 
simple shell of an app.  It 

07:07:01.510 --> 07:07:03.813
doesn't really do anything at 
the moment, but it has a few 

07:07:05.113 --> 07:07:07.447
little shortcuts that make it 
possible for me to do this in a 

07:07:07.745 --> 07:07:11.327
short amount of time.
So I would just run the app on 

07:07:11.676 --> 07:07:15.791
this pixel XL, and hopefully you
will be able to see that it does

07:07:17.971 --> 07:07:20.946
nothing.
So here we go.  Here is the app,

07:07:21.165 --> 07:07:24.468
when I tap on the screen, 
nothing happens.  No sound comes

07:07:24.728 --> 07:07:30.427
out, it is non-functional.  I 
want you to know that there is 

07:07:30.643 --> 07:07:39.395
no smoke and mir and mirrorers, 
it is jen  genuinely 

07:07:41.346 --> 07:07:41.898
live.
[ Laughter ].

07:07:41.899 --> 07:07:47.176
Thank you, GLRKS  Glenn.
  I have a few methods I will 

07:07:47.451 --> 07:07:49.833
use, and I will implement them 
in a second.

07:07:49.834 --> 07:07:52.062
So we will create an 
audioengine, and we will start 

07:07:52.608 --> 07:07:57.644
by calling start engine.
So we will just jump into our 

07:07:58.054 --> 07:08:05.649
J&amp;I code.
So this is in native lib.CVP 

07:08:05.912 --> 07:08:10.263
here.  So I'm going to define an
audioengine up here.

07:08:10.264 --> 07:08:16.963
I will call it engine.
And then I'm going to call a 

07:08:17.345 --> 07:08:19.302
method on my engine called 
start.

07:08:19.303 --> 07:08:22.295
And now, I have already created 
the header and implementation 

07:08:22.679 --> 07:08:26.255
files, just the blank files for 
this audioengine class.  So I 

07:08:27.159 --> 07:08:30.499
will go ahead now and write the 
class.

07:08:30.500 --> 07:08:36.564
So audioengine.
And I'm going to have one method

07:08:38.381 --> 07:08:40.880
called start.
Okay, now I can use option enter

07:08:41.723 --> 07:08:43.723
to generate the definition for 
this in my

07:08:47.527 --> 07:08:52.439
implementation and I'm in the 
start method.  Before I use the 

07:08:52.440 --> 07:08:54.922
Oboe library, I need to include 
the Oboe

07:08:58.794 --> 07:09:00.794
header.
There we

07:09:02.420 --> 07:09:03.840
go.
And the other thing I need to 

07:09:03.841 --> 07:09:08.357
do, where it makes it easier for
me, to use the Oboe name space. 

07:09:08.624 --> 07:09:11.874
And this avoids me having to 
prefix the objects with the word

07:09:14.985 --> 07:09:18.342
Oboe.
So, in our start method, I will 

07:09:18.730 --> 07:09:23.803
create an audiostream.  To do 
that, we use an audiostream 

07:09:24.183 --> 07:09:27.853
builder.
That builder allows us to set 

07:09:28.289 --> 07:09:30.678
properties on the stream.  That 
is like the format of the 

07:09:31.030 --> 07:09:33.030
stream.
And now, when I set the format, 

07:09:35.176 --> 07:09:38.468
there are two choices I can 
choose from, 16-bit integers, or

07:09:40.140 --> 07:09:43.762
floats.  I will use floats.  I 
can also set the number of 

07:09:44.203 --> 07:09:49.144
channels, so that is two for 
stereo, or one for mono.

07:09:49.145 --> 07:09:53.617
And I can also set properties 
which inform the stream of my 

07:09:54.335 --> 07:10:00.188
latency requirements.  So the 
most important one here is set 

07:10:00.189 --> 07:10:02.851
performance mode.
And there's a number of options,

07:10:03.123 --> 07:10:08.272
but the one I want is the low 
latency one.

07:10:08.273 --> 07:10:13.330
The second thing I can do is set
the sharing mode on the stream. 

07:10:13.331 --> 07:10:17.361
We will set that.  I will set it
to an exclusive sharing mode.  

07:10:17.362 --> 07:10:20.481
So that means that I'm 
requesting the audio device give

07:10:20.482 --> 07:10:26.730
me an exclusive stream, that 
means that my app's audio is not

07:10:26.731 --> 07:10:29.277
mixed with any other audio in 
the system.  If the device 

07:10:29.278 --> 07:10:39.109
supports it, I can avoid having 
my odd ye -- audio mixed with 

07:10:39.782 --> 07:10:43.855
anything else and I can cut a 
few milliseconds of latency in 

07:10:44.184 --> 07:10:46.184
the output.
So that's all I need to do to 

07:10:46.337 --> 07:10:51.154
open the stream, Joe can go 
ahead now and call open stream, 

07:10:51.155 --> 07:10:54.761
this takes a reference now to an
audiostream pointer.  I can use 

07:10:55.430 --> 07:11:00.511
option enter to create a new 
field called stream.  So back in

07:11:00.512 --> 07:11:04.663
the header, it is done 
automatically for me.  And once 

07:11:04.664 --> 07:11:09.714
the stream is open, there is one
final step I need to take which,

07:11:09.715 --> 07:11:15.130
is to set the buffer size on the
stream.  I can do this by 

07:11:15.450 --> 07:11:21.789
setting buffer size in frames.  
To get the smallest possible 

07:11:21.790 --> 07:11:26.295
buffer size, we have to 
interrogate the audio device for

07:11:27.164 --> 07:11:30.833
the minimal amount of data it 
will read in one operation, a 

07:11:31.634 --> 07:11:34.221
discrete chunk of audio data, 
and we call it a burst.  So we 

07:11:34.402 --> 07:11:36.402
want to obtain the burst size 
from the

07:11:38.944 --> 07:11:43.736
odd  -- audio device.  
We will use stream, gets per 

07:11:43.737 --> 07:11:47.754
burst.  And that's the minimum 
number of buffers we can set our

07:11:47.984 --> 07:11:51.648
stream to have, but we to not 
recommend that you use this 

07:11:53.271 --> 07:11:55.615
absolute minimum.  We recognize 
that you use double this, 

07:11:55.616 --> 07:11:58.679
because it provides a good 
protection against under runs, 

07:11:58.680 --> 07:12:01.125
and it is a good tradeoff with

07:12:08.315 --> 07:12:10.315
latency.
That's all I need to do to 

07:12:10.571 --> 07:12:13.818
create a low latency stream.  So
I can go ahead and start the 

07:12:13.965 --> 07:12:16.635
stream, which will do nothing 
because we have not found a way 

07:12:17.467 --> 07:12:21.330
of putting data into the stream.
To get the data into the stream,

07:12:22.226 --> 07:12:27.673
we use a call back.  I'm back in
the builder, I will send the 

07:12:27.674 --> 07:12:29.674
call back

07:12:31.607 --> 07:12:34.612
method.  It will take the call 
back object, and using this, I 

07:12:34.613 --> 07:12:38.342
will use my this object, which 
means that my audioengine needs 

07:12:38.343 --> 07:12:40.343
to implement this

07:12:43.490 --> 07:12:45.490
interface.
So I will do this, and I will 

07:12:45.620 --> 07:12:49.950
use control O to show me the 
methods I can override in this 

07:12:50.754 --> 07:12:54.497
interface.  I want on radio 
ready, the method that is called

07:12:54.728 --> 07:12:56.957
every time the audio device 

07:13:01.220 --> 07:13:03.963
needs more data.
So inside here, I will look at 

07:13:04.299 --> 07:13:09.506
what this method signature is.  
So on audio ready is called, it 

07:13:10.249 --> 07:13:14.220
tells me the stream that wants 
more data, and it gives me a 

07:13:14.221 --> 07:13:17.750
container array.  So this 
container array, which is of 

07:13:18.025 --> 07:13:23.712
type void star, because it can 
be either 16 bit integers, or 

07:13:25.975 --> 07:13:27.998
floating point samples is 
something that I'm going to 

07:13:27.999 --> 07:13:35.200
write my audio data into.  SoI 
so I write that, that is passed 

07:13:35.776 --> 07:13:39.756
to the audio device.  And next 
is num frames, it tells me the 

07:13:40.041 --> 07:13:42.336
number of num frames that need 
to be populated in this 

07:13:42.831 --> 07:13:47.192
container array.  I need an 
audio source, I will cheat a 

07:13:47.495 --> 07:13:51.062
little bit here.  I created an 
oscillator in advance, we will 

07:13:51.265 --> 07:13:54.091
take a quick look at it, and it 
is going to generate a square 

07:13:54.439 --> 07:13:59.652
wave here.  So that's a periodic
signal, varying between two 

07:14:00.051 --> 07:14:02.051
points to create

07:14:07.599 --> 07:14:13.892
a square wave. 
We will create an oscillator.

07:14:14.233 --> 07:14:16.238
So this is the template object, 
I need to tell it

07:14:21.617 --> 07:14:23.617
what type.
I will include the oscillator 

07:14:23.846 --> 07:14:26.522
header.  And now I have the 
oscillator, I will do ask

07:14:30.957 --> 07:14:35.640
render, so Android Studio is 
complaining about the signature.

07:14:36.466 --> 07:14:38.889
I will build, and that will 
normally sort it

07:14:45.039 --> 07:14:48.099
out.
Ignore the arrows.  So on my 

07:14:49.518 --> 07:14:54.109
oscillatoroscillator, I have a 
render method to put the audio 

07:14:54.110 --> 07:14:57.087
frames from the oscillator into 
the audio data array.  So the 

07:14:57.088 --> 07:15:02.280
first thing I need to do is to 
cast it to this -- an array of 

07:15:02.540 --> 07:15:05.043
floats.  
So audio data.

07:15:05.044 --> 07:15:09.520
And pass in the number of 
frames.

07:15:09.521 --> 07:15:13.809
So the last thing I need to do 
on audio ready is return a 

07:15:14.161 --> 07:15:16.928
result.  This can be either to 
continue where the call backs 

07:15:17.195 --> 07:15:20.689
will continue, or it can be 
stopped and the call backs will 

07:15:21.016 --> 07:15:26.692
stop.  So, in my case, I'm going
to continue.  And the final 

07:15:26.974 --> 07:15:32.293
thing I want to do is set some 
things up on my oscillator.

07:15:32.294 --> 07:15:38.960
And soso I'm going to set the 
amplitude, which is the volume, 

07:15:38.961 --> 07:15:46.694
and I'm also going to set the 
frequency, set that at 80 hertz,

07:15:46.695 --> 07:15:50.155
a nice base freaks  frequency, 
and the sample rate, which tells

07:15:50.403 --> 07:15:54.280
the oscillator how frequently 
these samples should be 

07:15:54.575 --> 07:15:57.217
produced.
And I can get that from the 

07:15:57.685 --> 07:16:02.133
stream, get sample rate there.
Okay, I know that you are all 

07:16:02.390 --> 07:16:07.209
desperate to hear a sound.  
There is a final thing I need to

07:16:07.582 --> 07:16:12.212
do here, I need to respond to 
tap events.  So I will just go 

07:16:12.213 --> 07:16:18.758
back into the main activity and 
I will override the on touch 

07:16:20.693 --> 07:16:22.693
event so that

07:16:24.715 --> 07:16:30.675
if the event is down, then I'm 
going to call this native method

07:16:31.082 --> 07:16:33.082
tap, to make 

07:16:37.221 --> 07:16:41.572
that true.
Otherwise, if the event is up, 

07:16:41.573 --> 07:16:44.919
I'm lifting my finger off the 
screen, then I will pass in 

07:16:45.318 --> 07:16:50.159
false.  Okay, let's have a look 
at the tap method.

07:16:50.160 --> 07:16:52.160
This needs 

07:16:53.516 --> 07:16:56.307
implementing.
So I will pass in the true or 

07:16:56.639 --> 07:17:04.326
false value, create the new 
method, and they will just call 

07:17:04.622 --> 07:17:11.596
ask, set, wave on, and that is 
going to pass that in there.

07:17:11.597 --> 07:17:16.533
Now, a moment of truth.
So I'm going to run this and, in

07:17:17.703 --> 07:17:19.703
theory, you should hear a

07:17:27.585 --> 07:17:29.905
sound.
And when I tap on the screen, we

07:17:30.214 --> 07:17:33.028
should hear an 80 hertz square 
wave.

07:17:33.029 --> 07:17:38.039
The pressure.
[Tone].

07:17:38.040 --> 07:17:41.860
There we go.
[ Applause ].

07:17:43.275 --> 07:17:46.561
[Buzzing noise].  
SPEAKER: So you can see, it is 

07:17:47.014 --> 07:17:51.725
the lowest possible latency 
here, and it is actually -- 

07:17:51.726 --> 07:17:56.652
[series of beeps] -- pretty 
responsive.  So we have a 

07:17:56.828 --> 07:18:00.475
musical instrument.  Admittedly,
it is not the best instrument in

07:18:00.476 --> 07:18:04.962
the world.  It is a little bit 
to be desired on the sound.  So 

07:18:04.963 --> 07:18:08.551
what I thought would be nice is 
if you could add a little bit 

07:18:08.863 --> 07:18:14.519
more control.  So for the last 
four minutes and 30 seconds, I 

07:18:14.520 --> 07:18:16.520
will tie the motion sensor to

07:18:19.503 --> 07:18:25.169
the pitch of the oscillator.  To
do this, I'm going to cheap.  I 

07:18:25.476 --> 07:18:28.268
will call in some code that I 
did earlier, and it will 

07:18:28.534 --> 07:18:34.473
register a list now that will 
listen to the rotation vector 

07:18:35.043 --> 07:18:38.626
sensor.
So to listen to these events, I 

07:18:38.627 --> 07:18:44.938
need to implement the sensor 
eventevent listener interface, 

07:18:45.573 --> 07:18:52.354
implement the methods, 
onsensorchanged.  So what I want

07:18:52.637 --> 07:18:59.548
to do is set the frequency based
on the event values of the X 

07:18:59.949 --> 07:19:02.726
axis.  And I also need to scale 
this value.

07:19:02.727 --> 07:19:07.840
So I want to have it from, let's
say, from 20 hertz, the limit of

07:19:08.469 --> 07:19:12.052
human hearing, and we will go

07:19:16.685 --> 07:19:23.428
up to, like,- this will give me 
up to around 100  hertz.

07:19:23.429 --> 07:19:30.004
So, yep, that looks good.
So again, I need to implement 

07:19:30.641 --> 07:19:32.641
this.

07:19:41.131 --> 07:19:45.912
Frequency... so we will just go 
ask set frequency, and there we 

07:19:46.278 --> 07:19:50.527
go.
Okay, so we are good to go on 

07:19:52.166 --> 07:19:54.680
that.  Brief interlude.  Very 
brief, in fact.  Has

07:19:58.336 --> 07:20:04.867
anyone heard of the R man break?
One person.  So the R man break 

07:20:05.126 --> 07:20:13.518
comes from a song in the '60s, R
man brother, 4bar four bars of 

07:20:13.519 --> 07:20:17.702
the most incredible drum solo, 
the most sampled loop in 

07:20:17.945 --> 07:20:20.952
history, but nobody has heard of
it evidently, apart from one 

07:20:21.254 --> 07:20:24.947
guy.  I thought it would be nice
if I can play my new musical 

07:20:25.203 --> 07:20:27.203
instrument over this 

07:20:29.665 --> 07:20:32.512
loop.
So here's the loop, I need to 

07:20:32.722 --> 07:20:34.722
run the app.  We will give it a

07:20:37.645 --> 07:20:39.645
go.
We will make sure

07:20:43.511 --> 07:20:51.873
it is here.
So, with a bit of luck [drum 

07:20:58.286 --> 07:21:00.286
sample].
[Oscillating

07:21:06.395 --> 07:21:10.754
tone].
[Drumming and oscillating tone].

07:21:11.030 --> 07:21:13.715
SPEAKER: Right.

07:21:20.934 --> 07:21:24.527
[ Applause ]. 
SPEAKER: Okay, so that is about 

07:21:25.950 --> 07:21:27.950
it from me.  If you can go back 
to the

07:21:31.502 --> 07:21:34.524
slides.
And, yes, the library is 

07:21:34.525 --> 07:21:37.942
available on GitHub.  There's a 
documentation, codelabs, all 

07:21:38.235 --> 07:21:45.453
sort saidsses of stuff in there.
We would love for you to build 

07:21:46.061 --> 07:21:48.184
awesome experiences on Android, 
and I'm here for any questions. 

07:21:48.495 --> 07:21:50.495
Thank you all very 

07:21:54.105 --> 07:21:55.279
much.
[ Applause ]. 

07:21:55.280 --> 07:21:57.449
SPEAKER: Thanks, Don.  With the 
end of that talk, that is the 

07:21:57.739 --> 07:22:00.302
end of the day.
That means that it is time for a

07:22:01.586 --> 07:22:06.383
par  party.  So the theory is we
will have food, drinks, and a 

07:22:07.155 --> 07:22:12.344
DJ.  I vote for Don do the DJ.  
I wanted  want to hear that tune

07:22:12.865 --> 07:22:16.739
all night long, or a two-minute 
loop and that is probably about 

07:22:17.265 --> 07:22:19.919
enough.  So 6:20, the party 

07:22:29.125 --> 07:22:31.125
starts....

