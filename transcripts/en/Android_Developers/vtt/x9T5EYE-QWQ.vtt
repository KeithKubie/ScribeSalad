WEBVTT
Kind: captions
Language: en

00:00:00.500 --> 00:00:04.419
[MUSIC PLAYING]

00:00:05.892 --> 00:00:07.520
STEPHAN HERHUT: Hello, everyone.

00:00:07.520 --> 00:00:08.440
Thanks for coming.

00:00:08.440 --> 00:00:09.074
I'm Stephan.

00:00:09.074 --> 00:00:10.490
I'm a software
engineer at Google,

00:00:10.490 --> 00:00:14.110
where I work on compilers
and runtime systems.

00:00:14.110 --> 00:00:15.610
And most recently,
I've been working

00:00:15.610 --> 00:00:18.160
on R8, which is Google's
new shrinker for Android

00:00:18.160 --> 00:00:19.420
applications.

00:00:19.420 --> 00:00:21.580
Now, if you attended
yesterday's session

00:00:21.580 --> 00:00:23.530
on new compilers
and Android Studio,

00:00:23.530 --> 00:00:25.690
you already heard a fair
bit about what R8 is

00:00:25.690 --> 00:00:27.280
and how you can use it.

00:00:27.280 --> 00:00:30.520
And today, I don't want to talk
too much, actually, what R8 is.

00:00:30.520 --> 00:00:33.700
I want to focus
more on keep rules.

00:00:33.700 --> 00:00:35.230
So what are keep rules?

00:00:35.230 --> 00:00:37.510
Keep rules is the
configuration language

00:00:37.510 --> 00:00:40.780
that ProGuard uses to
specify the things you

00:00:40.780 --> 00:00:43.090
need to keep in your
application while shrinking.

00:00:43.090 --> 00:00:44.650
And when we built
R8, we decided we

00:00:44.650 --> 00:00:46.840
wanted to use the same
language because we wanted

00:00:46.840 --> 00:00:49.090
to be a drop-in
replacement for ProGuard,

00:00:49.090 --> 00:00:52.840
the idea being that you could
just reuse your existing rules

00:00:52.840 --> 00:00:55.770
and try R8 really easily.

00:00:55.770 --> 00:00:57.760
Now, as you might imagine,
building something

00:00:57.760 --> 00:01:00.220
that is compatible to
that degree required

00:01:00.220 --> 00:01:03.010
us to quite deeply understand
what ProGuard keep rules

00:01:03.010 --> 00:01:04.330
actually mean.

00:01:04.330 --> 00:01:06.580
And today, I want to
use this opportunity

00:01:06.580 --> 00:01:08.462
to share some of that
knowledge with you.

00:01:08.462 --> 00:01:10.420
And I also want to take
you on a little journey

00:01:10.420 --> 00:01:13.780
to understand what it really
takes, given an application,

00:01:13.780 --> 00:01:16.300
to come up with effective
keep rules to shrink it

00:01:16.300 --> 00:01:18.370
to its minimum.

00:01:18.370 --> 00:01:21.030
But before we go there, let
me ask you all the questions.

00:01:21.030 --> 00:01:25.370
So who of you has used ProGuard
before in some way or shape?

00:01:25.370 --> 00:01:25.870
Wow.

00:01:25.870 --> 00:01:27.610
That's a lot of people.

00:01:27.610 --> 00:01:30.790
So who of you is
using ProGuard today

00:01:30.790 --> 00:01:34.919
in the Released Production
app on the Play Store?

00:01:34.919 --> 00:01:37.210
That's already a little less,
but you're a great crowd.

00:01:37.210 --> 00:01:40.810
Thank you for doing that,
because our estimates show

00:01:40.810 --> 00:01:44.410
that only about a quarter of
applications on the Play Store

00:01:44.410 --> 00:01:46.640
actually use keep rules.

00:01:46.640 --> 00:01:49.240
So there's a big
room for improvement.

00:01:49.240 --> 00:01:51.880
And I want to talk a little bit
about why it actually matters

00:01:51.880 --> 00:01:53.707
to shrink application size.

00:01:53.707 --> 00:01:55.540
So, of course, for me,
it matters, because I

00:01:55.540 --> 00:01:56.440
helped build a shrinker.

00:01:56.440 --> 00:01:56.940
Right?

00:01:56.940 --> 00:01:58.660
I'm interested that
somebody uses it.

00:01:58.660 --> 00:02:00.520
But it should also
matter for you.

00:02:00.520 --> 00:02:04.210
There has been a lot of talk
about next billion users,

00:02:04.210 --> 00:02:06.610
entry-level Android devices,
and how we can make the user

00:02:06.610 --> 00:02:08.759
experience better.

00:02:08.759 --> 00:02:12.460
And what makes an entry-level
user Android device?

00:02:12.460 --> 00:02:15.650
So one thing is, it's
really resource-limited.

00:02:15.650 --> 00:02:17.440
So if you think
of these devices,

00:02:17.440 --> 00:02:21.010
they typically have less
than 512 megabytes of RAM,

00:02:21.010 --> 00:02:24.350
or they might only have like
four gigabytes of storage.

00:02:24.350 --> 00:02:26.770
And quite often, people
that use these devices

00:02:26.770 --> 00:02:31.210
are in areas where they have
very limited connectivity.

00:02:31.210 --> 00:02:33.040
So for these users,
size actually

00:02:33.040 --> 00:02:34.550
makes a daily difference.

00:02:34.550 --> 00:02:35.050
Right?

00:02:35.050 --> 00:02:37.360
When they decide of all
the apps they actually

00:02:37.360 --> 00:02:40.770
want to use which ones
they can afford to install,

00:02:40.770 --> 00:02:42.640
there might be a small subset.

00:02:42.640 --> 00:02:45.370
And that's bad for them because
it's a bad user experience,

00:02:45.370 --> 00:02:48.380
but it's also really bad for
you as application developers,

00:02:48.380 --> 00:02:50.920
because it might be your app
that doesn't make the cut.

00:02:50.920 --> 00:02:53.350
It might be your app that
they actually want to use,

00:02:53.350 --> 00:02:58.210
but they can't use, because
they don't have the space.

00:02:58.210 --> 00:03:01.640
Now, you might say, OK,
that's not really my audience.

00:03:01.640 --> 00:03:03.490
Next billion users,
entry level, that's

00:03:03.490 --> 00:03:05.410
not where I see my application.

00:03:05.410 --> 00:03:08.890
But even if you target
really high-end devices,

00:03:08.890 --> 00:03:13.840
the fundamental truth is that
smaller is always faster.

00:03:13.840 --> 00:03:16.030
And that's quite
obvious, because, A,

00:03:16.030 --> 00:03:18.370
they download faster,
because they are smaller.

00:03:18.370 --> 00:03:19.810
There's less to transfer.

00:03:19.810 --> 00:03:21.790
They also install a lot
faster, because there's

00:03:21.790 --> 00:03:23.380
less code to compile,
and that what

00:03:23.380 --> 00:03:26.170
takes the time at installing.

00:03:26.170 --> 00:03:29.230
And lastly, and that's
what users see every day,

00:03:29.230 --> 00:03:31.570
they also start up much
faster because there's

00:03:31.570 --> 00:03:33.610
less code to load.

00:03:33.610 --> 00:03:36.209
So whenever I talk
to people about this

00:03:36.209 --> 00:03:38.750
and say, OK, you have to care,
you have to make them smaller,

00:03:38.750 --> 00:03:40.950
an answer I get really,
really often is, yeah,

00:03:40.950 --> 00:03:42.550
but hardware will fix this.

00:03:42.550 --> 00:03:43.050
Right?

00:03:43.050 --> 00:03:44.560
Devices are becoming faster.

00:03:44.560 --> 00:03:45.580
There's more storage.

00:03:45.580 --> 00:03:47.410
Connectivity is better.

00:03:47.410 --> 00:03:50.410
That might be true, but
it's not a solution.

00:03:50.410 --> 00:03:52.180
I have a graph for you.

00:03:52.180 --> 00:03:55.630
So this shows the average
size of installed apps

00:03:55.630 --> 00:03:57.790
on people's devices.

00:03:57.790 --> 00:04:00.922
And as you can see, this
has been growing steadily.

00:04:00.922 --> 00:04:02.380
Since the early
days of Android, we

00:04:02.380 --> 00:04:05.470
started at about
a megabit per APK.

00:04:05.470 --> 00:04:08.560
And by now, we are at a
whopping 32 megabytes,

00:04:08.560 --> 00:04:11.620
on average, for
installed applications.

00:04:11.620 --> 00:04:14.825
So clearly, hardware is
not going to fix this.

00:04:14.825 --> 00:04:16.200
We have to do
something about it.

00:04:16.200 --> 00:04:19.014
We have to make apps smaller.

00:04:19.014 --> 00:04:19.930
So let's look at this.

00:04:19.930 --> 00:04:21.304
Where does this
growth come from?

00:04:21.304 --> 00:04:22.720
Why are apps so big?

00:04:22.720 --> 00:04:26.420
And to get an idea, I thought
I'd bring you a little example.

00:04:26.420 --> 00:04:29.020
So I built this app, which
I call Simple Weather,

00:04:29.020 --> 00:04:32.170
and the stress
really is on simple.

00:04:32.170 --> 00:04:34.000
Because all this
app does, it take

00:04:34.000 --> 00:04:36.370
some statically
pre-defined weather data

00:04:36.370 --> 00:04:39.340
and then renders it
as a dynamic graph.

00:04:39.340 --> 00:04:41.920
Dynamic graph means
if you turn the app,

00:04:41.920 --> 00:04:43.740
it will render in
a different size,

00:04:43.740 --> 00:04:45.730
or if you install it
on a different device,

00:04:45.730 --> 00:04:46.940
it will adapt to resolution.

00:04:46.940 --> 00:04:48.910
So the graph is truly dynamic.

00:04:48.910 --> 00:04:50.740
The data isn't.

00:04:50.740 --> 00:04:52.536
And this is a really,
really simple app.

00:04:52.536 --> 00:04:54.160
And there's are two
things that I found

00:04:54.160 --> 00:04:56.170
surprising when
I built this app.

00:04:56.170 --> 00:04:59.994
The positive thing was, it
took me all but 30 minutes.

00:04:59.994 --> 00:05:02.410
I just went on the internet,
I looked for a graph library,

00:05:02.410 --> 00:05:04.420
I typed in about
100 lines of code,

00:05:04.420 --> 00:05:08.410
and there it was, my
little Simple Weather app.

00:05:08.410 --> 00:05:10.300
But there was also
a negative surprise.

00:05:10.300 --> 00:05:12.127
And that was the size.

00:05:12.127 --> 00:05:13.960
I thought I built
something simple and small

00:05:13.960 --> 00:05:16.001
because that makes it
small, but that's not true.

00:05:16.001 --> 00:05:18.450
This app was two
megabytes of an APK.

00:05:18.450 --> 00:05:21.640
Two megabytes just
for rendering a graph.

00:05:21.640 --> 00:05:23.680
And even worse, when
I installed this,

00:05:23.680 --> 00:05:26.530
it turns into a
four-megabyte blob of code

00:05:26.530 --> 00:05:29.006
because it was uncompressed.

00:05:29.006 --> 00:05:30.880
And again, you might
say, OK, four megabytes.

00:05:30.880 --> 00:05:31.810
That's not really much.

00:05:31.810 --> 00:05:32.309
Right?

00:05:32.309 --> 00:05:33.167
New devices.

00:05:33.167 --> 00:05:33.750
Lots of space.

00:05:33.750 --> 00:05:36.370
Let me put that into
perspective for you.

00:05:36.370 --> 00:05:39.670
If you look back into the
'60s, we flew to the moon

00:05:39.670 --> 00:05:41.210
with 60k of code.

00:05:41.210 --> 00:05:41.710
Right?

00:05:41.710 --> 00:05:44.140
That's 1/60 of the
application size

00:05:44.140 --> 00:05:46.430
I had for my Simple
Weather here.

00:05:46.430 --> 00:05:48.080
And no matter how
you turn this, it's

00:05:48.080 --> 00:05:50.650
strictly more complicated
to fly to the moon

00:05:50.650 --> 00:05:53.230
than rendering a graph.

00:05:53.230 --> 00:05:55.120
So what has happened here?

00:05:55.120 --> 00:05:57.890
Why did we go from
60k flying to the moon

00:05:57.890 --> 00:06:01.022
to four megabytes
rendering a graph?

00:06:01.022 --> 00:06:02.980
And I think the reason
is that we fundamentally

00:06:02.980 --> 00:06:06.670
changed how we do software.

00:06:06.670 --> 00:06:08.910
So back then, when they did
the software for Apollo,

00:06:08.910 --> 00:06:12.550
there was a dedicated team that
wrote this code line by line,

00:06:12.550 --> 00:06:15.340
everything was on purpose,
everything was handcrafted,

00:06:15.340 --> 00:06:18.460
so it was really meticulously
crafted to fit into this 60k,

00:06:18.460 --> 00:06:22.030
and do exactly one
thing, fly to the moon.

00:06:22.030 --> 00:06:24.040
Fast-forward to today.

00:06:24.040 --> 00:06:25.480
How build I my app?

00:06:25.480 --> 00:06:27.310
I use components.

00:06:27.310 --> 00:06:29.500
I just went to the web,
downloaded some components,

00:06:29.500 --> 00:06:30.610
stitched it all together.

00:06:30.610 --> 00:06:31.109
Ta-da!

00:06:31.109 --> 00:06:32.680
I have my app.

00:06:32.680 --> 00:06:34.161
There's a great
advantage of this.

00:06:34.161 --> 00:06:34.660
Right?

00:06:34.660 --> 00:06:35.920
It took me only 30 minutes.

00:06:35.920 --> 00:06:36.820
It was really easy.

00:06:36.820 --> 00:06:38.680
I was super productive.

00:06:38.680 --> 00:06:40.930
But there's also a
big, big drawback.

00:06:40.930 --> 00:06:44.200
My application was really big.

00:06:44.200 --> 00:06:45.760
So let's look into the details.

00:06:45.760 --> 00:06:48.990
Which components
did I actually use?

00:06:48.990 --> 00:06:51.490
For that, I brought you
my build.gradle file.

00:06:51.490 --> 00:06:53.410
And this is essentially
the default file

00:06:53.410 --> 00:06:55.840
that Android Studio
will generate for you.

00:06:55.840 --> 00:06:58.499
And all I've done, I've
added two components.

00:06:58.499 --> 00:07:00.790
I've highlighted them here,
so that it's easier for you

00:07:00.790 --> 00:07:01.290
to see.

00:07:01.290 --> 00:07:04.200
The first one is Guava.

00:07:04.200 --> 00:07:06.250
Now, Guava, that's
Google's common components

00:07:06.250 --> 00:07:08.080
for software
engineering and Java,

00:07:08.080 --> 00:07:10.210
and they add a lot of
convenient classes.

00:07:10.210 --> 00:07:13.540
And the thing I wanted
was immutable collections.

00:07:13.540 --> 00:07:16.044
Because I thought my static
weather data, it's static,

00:07:16.044 --> 00:07:17.710
so it should be an
immutable collection.

00:07:17.710 --> 00:07:18.210
Right?

00:07:18.210 --> 00:07:20.930
That's good software
engineering practice.

00:07:20.930 --> 00:07:23.247
The other thing I
use is Android plot.

00:07:23.247 --> 00:07:25.330
And that's just a library
I found in the internet.

00:07:25.330 --> 00:07:27.371
There's probably lots more
of plotting libraries,

00:07:27.371 --> 00:07:29.740
but I spotted this
one the first.

00:07:29.740 --> 00:07:31.390
And AndroidPlot is really great.

00:07:31.390 --> 00:07:35.440
It has lots of support for bar
graphs and all kinds of charts.

00:07:35.440 --> 00:07:37.450
But I really needed
a line graph.

00:07:37.450 --> 00:07:40.280
That's all I cared about.

00:07:40.280 --> 00:07:42.970
So let's look what
this means for size.

00:07:42.970 --> 00:07:46.810
How did these components impact
the size of my application?

00:07:46.810 --> 00:07:50.641
And to get an idea, I
went to the APK Analyzer.

00:07:50.641 --> 00:07:53.140
Now if you haven't seen this
tool before, it's really great.

00:07:53.140 --> 00:07:54.910
It's part of Android Studio.

00:07:54.910 --> 00:07:58.060
You will find documentation
on developers Android.com.

00:07:58.060 --> 00:08:00.190
But what this does is it
gives you deep insight

00:08:00.190 --> 00:08:02.940
into what contributes
to the size of the APK.

00:08:02.940 --> 00:08:05.530
It can do resources and
all kinds of things,

00:08:05.530 --> 00:08:09.600
but I'm only interested
here in the actual code.

00:08:09.600 --> 00:08:11.980
So I've highlighted that at
the bottom there for you.

00:08:11.980 --> 00:08:13.990
There is this com
Google package which

00:08:13.990 --> 00:08:16.400
contributes 1.4 megabytes.

00:08:16.400 --> 00:08:18.280
Well, that's Guava.

00:08:18.280 --> 00:08:21.730
So I'm paying 1.4 megabytes
for a mutable collection.

00:08:21.730 --> 00:08:23.332
This might be a very
extreme example,

00:08:23.332 --> 00:08:25.540
but there's something that
is more realistic there as

00:08:25.540 --> 00:08:27.970
well, which is AndroidPlot.

00:08:27.970 --> 00:08:30.310
That's the second thing you see.

00:08:30.310 --> 00:08:31.960
And that's 180K.

00:08:31.960 --> 00:08:37.271
So my plotting library
takes 180K of APK size.

00:08:37.271 --> 00:08:38.770
Now there will be
something in there

00:08:38.770 --> 00:08:42.429
that I don't need, because
my actual application that's

00:08:42.429 --> 00:08:46.540
the EU part down
there is only 35K.

00:08:46.540 --> 00:08:48.640
That's the code I wrote.

00:08:48.640 --> 00:08:51.060
You might think 35K for
a hundred lines of code?

00:08:51.060 --> 00:08:52.030
That's a bit much.

00:08:52.030 --> 00:08:54.880
Well, it is, because there's
all the auto-generated code,

00:08:54.880 --> 00:08:58.420
most of which I
actually don't need.

00:08:58.420 --> 00:09:00.650
So this brings us
to the question

00:09:00.650 --> 00:09:04.800
how do I get from this, where
you can clearly see that Guava

00:09:04.800 --> 00:09:07.050
and Android plot take
the majority of my APK

00:09:07.050 --> 00:09:10.840
size, [INAUDIBLE] application
is really small, to something

00:09:10.840 --> 00:09:13.570
that's more tailored,
that's more like the thing

00:09:13.570 --> 00:09:15.130
that they did for Apollo.

00:09:15.130 --> 00:09:16.630
Of course, we won't
get to something

00:09:16.630 --> 00:09:19.960
as crafted as that without
doing all the investment,

00:09:19.960 --> 00:09:22.670
but there must be some
kind of middle ground.

00:09:22.670 --> 00:09:27.190
And that really is where a tool
like ProGuard and R8 comes in.

00:09:27.190 --> 00:09:29.050
Because one of the
things it does,

00:09:29.050 --> 00:09:31.150
it takes your application,
and it removes

00:09:31.150 --> 00:09:33.550
all the unused components.

00:09:33.550 --> 00:09:36.370
So the goal is to take
a componentalized build

00:09:36.370 --> 00:09:39.430
that you've made into something
as tailored as possible,

00:09:39.430 --> 00:09:42.890
and to remove all that code.

00:09:42.890 --> 00:09:45.370
Now when I ask you, you all
said you already used this.

00:09:45.370 --> 00:09:47.890
So you will know it's
really easy to enable,

00:09:47.890 --> 00:09:49.720
because all you
have to do is you

00:09:49.720 --> 00:09:53.230
have to head back to
your build.gradle file,

00:09:53.230 --> 00:09:55.210
and then flip this one flag.

00:09:55.210 --> 00:09:55.710
Right?

00:09:55.710 --> 00:09:57.790
If Android studio
generated this for you,

00:09:57.790 --> 00:10:00.880
then it will already
say minfyEnabled, false.

00:10:00.880 --> 00:10:04.690
You just flip that to true, and
ta-da, you have a small app.

00:10:04.690 --> 00:10:07.000
I see some people are shaking
their heads already here,

00:10:07.000 --> 00:10:10.340
because, of course, that's
not really the truth.

00:10:10.340 --> 00:10:12.130
So I did this for
my application.

00:10:12.130 --> 00:10:16.810
I flipped the flag, and
there it was, more than 200

00:10:16.810 --> 00:10:18.930
build time errors.

00:10:18.930 --> 00:10:20.042
Hooray.

00:10:20.042 --> 00:10:22.000
So I looked at these
errors, and I thought, OK,

00:10:22.000 --> 00:10:24.160
what are they trying to tell me?

00:10:24.160 --> 00:10:25.210
There's classes missing.

00:10:25.210 --> 00:10:26.543
Classes I haven't even heard of.

00:10:28.980 --> 00:10:29.940
What do I do?

00:10:29.940 --> 00:10:32.050
How do I fix this?

00:10:32.050 --> 00:10:34.680
Well, the first solution,
you search on the internet.

00:10:34.680 --> 00:10:35.700
So I did.

00:10:35.700 --> 00:10:38.520
And I found this great
piece of advice, which says,

00:10:38.520 --> 00:10:43.430
just put dontwarn star into
your ProGuard configuration,

00:10:43.430 --> 00:10:44.880
and everything will be fine.

00:10:48.010 --> 00:10:50.860
Now, technically,
this is correct.

00:10:50.860 --> 00:10:54.700
You put this in there,
and it will compile.

00:10:54.700 --> 00:10:55.810
But there's a problem.

00:10:55.810 --> 00:10:59.290
What this tells R8 is,
no matter what happens,

00:10:59.290 --> 00:11:01.320
don't tell me about it.

00:11:01.320 --> 00:11:03.320
And that means it will
mask these benign errors,

00:11:03.320 --> 00:11:06.280
but it will also really mask
all the errors you actually

00:11:06.280 --> 00:11:09.860
care about, where
something went wrong.

00:11:09.860 --> 00:11:12.130
So how can we improve on this?

00:11:12.130 --> 00:11:16.060
And to do that, we have to
actually deep dive a bit

00:11:16.060 --> 00:11:18.670
into how R8 works.

00:11:18.670 --> 00:11:20.650
Now I will talk about
R8 here, because that's

00:11:20.650 --> 00:11:22.030
the tool I helped build.

00:11:22.030 --> 00:11:23.860
But most of this also
applies to ProGuard,

00:11:23.860 --> 00:11:27.080
because it solves
the same problem.

00:11:27.080 --> 00:11:28.210
So what does R8 do?

00:11:28.210 --> 00:11:29.390
It does two things.

00:11:29.390 --> 00:11:31.240
Firstly, it does minification.

00:11:31.240 --> 00:11:33.100
And minification is
the process, where

00:11:33.100 --> 00:11:35.800
you take very long class
names and replace them

00:11:35.800 --> 00:11:38.770
by very short class
names instead.

00:11:38.770 --> 00:11:41.770
Some also call this
obfuscation, but it really

00:11:41.770 --> 00:11:44.000
doesn't obfuscate your code.

00:11:44.000 --> 00:11:46.460
It just makes it a
little less hard to read,

00:11:46.460 --> 00:11:49.690
but it's nowhere safe
for reverse engineering.

00:11:49.690 --> 00:11:52.279
So let's call this minification.

00:11:52.279 --> 00:11:54.070
That's one thing ProGuard
does, but I don't

00:11:54.070 --> 00:11:55.550
want to focus too much on that.

00:11:55.550 --> 00:11:57.980
The other thing it
does is shrinking.

00:11:57.980 --> 00:12:00.220
Now shrinking is a
great name for this,

00:12:00.220 --> 00:12:03.250
from a developer perspective,
because it takes your app

00:12:03.250 --> 00:12:06.004
and it shrinks it
into a smaller app.

00:12:06.004 --> 00:12:07.420
If you actually
want to understand

00:12:07.420 --> 00:12:10.420
what happens under the hood,
it works actually the other way

00:12:10.420 --> 00:12:11.620
around.

00:12:11.620 --> 00:12:13.180
Because what we're
doing is we're

00:12:13.180 --> 00:12:15.700
doing tree growing,
which takes the entry

00:12:15.700 --> 00:12:17.650
point of the
application and grows

00:12:17.650 --> 00:12:19.540
that until we've
seen everything that

00:12:19.540 --> 00:12:21.100
will be executed at runtime.

00:12:23.650 --> 00:12:26.600
Let's look at the example here.

00:12:26.600 --> 00:12:28.600
So I create these graphics.

00:12:28.600 --> 00:12:31.120
And in essence,
a box is a class.

00:12:31.120 --> 00:12:32.950
That's all you have
to care about for now.

00:12:32.950 --> 00:12:34.730
There's also code
in these boxes,

00:12:34.730 --> 00:12:37.630
but don't read it just yet.

00:12:37.630 --> 00:12:41.110
Another thing on these graphs
is that everything on your right

00:12:41.110 --> 00:12:42.580
is library classes.

00:12:42.580 --> 00:12:44.770
That's part of the
Android system.

00:12:44.770 --> 00:12:49.030
And everything on the left
is your application code.

00:12:49.030 --> 00:12:50.530
And the first thing
to realize here

00:12:50.530 --> 00:12:54.895
is that library classes
are always live.

00:12:54.895 --> 00:12:56.770
And there's a very
practical reason for this,

00:12:56.770 --> 00:12:59.555
because we can shrink
them away anyway.

00:12:59.555 --> 00:13:00.430
They're on the phone.

00:13:00.430 --> 00:13:02.650
They're part of the system.

00:13:02.650 --> 00:13:04.390
But there's also a
technical reason,

00:13:04.390 --> 00:13:06.400
because for a static
analysis tool,

00:13:06.400 --> 00:13:09.689
we don't know what these
library classes actually do.

00:13:09.689 --> 00:13:11.230
And that is because
the runtime might

00:13:11.230 --> 00:13:13.020
call into them at any point.

00:13:13.020 --> 00:13:14.920
There's very many
different libraries,

00:13:14.920 --> 00:13:16.900
like different Android
versions, and they also

00:13:16.900 --> 00:13:18.950
might change in the future.

00:13:18.950 --> 00:13:20.860
So from an analysis
standpoint, we just

00:13:20.860 --> 00:13:25.900
have to assume that the
library class is always live.

00:13:25.900 --> 00:13:29.220
So let's assume we will start
our app by calling the run

00:13:29.220 --> 00:13:32.410
method in the app class.

00:13:32.410 --> 00:13:34.890
So the first thing we will
have to do to actually do this

00:13:34.890 --> 00:13:37.920
is we have to instantiate
this app class, which

00:13:37.920 --> 00:13:40.680
means we create an
instance of the class app,

00:13:40.680 --> 00:13:43.960
and we also call
the constructor.

00:13:43.960 --> 00:13:47.200
And that leads to both
of them being live.

00:13:47.200 --> 00:13:49.240
That means we cannot
strip away the app class,

00:13:49.240 --> 00:13:51.370
and we cannot strip
away the constructor.

00:13:51.370 --> 00:13:53.509
So far, so good.

00:13:53.509 --> 00:13:56.050
Next, we have to actually look
at the code of the constructor

00:13:56.050 --> 00:13:58.439
to see what it
will do at runtime.

00:13:58.439 --> 00:13:59.980
And if you look at
the code, you will

00:13:59.980 --> 00:14:04.240
see it actually creates a
new instance of Class A.

00:14:04.240 --> 00:14:07.600
So again, this makes
class A become alive.

00:14:07.600 --> 00:14:09.420
We can no longer remove it.

00:14:09.420 --> 00:14:12.740
Note that class doesn't
actually have a constructor.

00:14:12.740 --> 00:14:14.387
So there is no code to look at.

00:14:14.387 --> 00:14:15.970
It only has a default
constructor that

00:14:15.970 --> 00:14:18.502
does nothing interesting here.

00:14:18.502 --> 00:14:20.710
The other thing that the
constructor of the app class

00:14:20.710 --> 00:14:23.320
does, it writes the
created instance

00:14:23.320 --> 00:14:26.055
to this field, Other Field.

00:14:26.055 --> 00:14:28.180
It's interesting to note
here that doesn't actually

00:14:28.180 --> 00:14:30.100
make Other Field live.

00:14:30.100 --> 00:14:32.680
Because writing to a
field is not observable.

00:14:32.680 --> 00:14:34.180
You have to actually
read the field

00:14:34.180 --> 00:14:37.824
to know that the field exists.

00:14:37.824 --> 00:14:39.990
So now we've created the
instance of this app class.

00:14:39.990 --> 00:14:41.460
We've executed the constructor.

00:14:41.460 --> 00:14:43.090
We want to call the run method.

00:14:43.090 --> 00:14:44.760
And again, calling
this run method

00:14:44.760 --> 00:14:47.550
will mark this method as live.

00:14:47.550 --> 00:14:49.197
And like with every
other live method,

00:14:49.197 --> 00:14:51.530
we now have to look at it and
see what the code actually

00:14:51.530 --> 00:14:53.582
does at runtime.

00:14:53.582 --> 00:14:55.040
So if you look at
Run, you will see

00:14:55.040 --> 00:14:58.250
it first reads the field Other
Field to retrieve the instance,

00:14:58.250 --> 00:15:00.260
and this is the moment
where this field actually

00:15:00.260 --> 00:15:02.990
becomes live.

00:15:02.990 --> 00:15:06.130
And next, we will call A method
on the retrieved instance,

00:15:06.130 --> 00:15:11.650
and that is where A method
in class A becomes live.

00:15:11.650 --> 00:15:13.600
And now we would look
at the code of A method,

00:15:13.600 --> 00:15:17.260
see what that does, and
mark all those effects.

00:15:17.260 --> 00:15:20.350
So this is how the basic
analysis flow works.

00:15:20.350 --> 00:15:21.850
Whenever you think
about keep rules,

00:15:21.850 --> 00:15:24.308
you have to keep in mind, this
is what your analysis engine

00:15:24.308 --> 00:15:25.660
will do.

00:15:25.660 --> 00:15:27.910
Now, how does this
relate to Android?

00:15:27.910 --> 00:15:29.830
How do we actually
know the entry point

00:15:29.830 --> 00:15:32.750
of an Android application?

00:15:32.750 --> 00:15:35.510
Well, that comes from
your manifest file.

00:15:35.510 --> 00:15:37.610
So this is a very
simplified manifest file.

00:15:37.610 --> 00:15:39.760
But one thing it
does, it tells you

00:15:39.760 --> 00:15:43.640
that the activity has
the class, the graph,

00:15:43.640 --> 00:15:46.760
as its implementation.

00:15:46.760 --> 00:15:50.800
Now, neither R8 nor ProGuard
do understand manifest files.

00:15:50.800 --> 00:15:52.210
And they shouldn't,
because there

00:15:52.210 --> 00:15:55.150
is a little tool that actually
helps us understand them,

00:15:55.150 --> 00:15:57.800
and that's called AAPT.

00:15:57.800 --> 00:16:01.840
AAPT during a build process
pre-process all your resources,

00:16:01.840 --> 00:16:05.467
and it creates corespondent
keep rules for you.

00:16:05.467 --> 00:16:06.800
So let's look at this keep rule.

00:16:06.800 --> 00:16:08.133
And this is the first keep rule.

00:16:08.133 --> 00:16:12.055
So we'll talk a bit
about it in detail.

00:16:12.055 --> 00:16:14.670
So what it basically
does, it says keep.

00:16:14.670 --> 00:16:15.980
That's the simplest form.

00:16:15.980 --> 00:16:18.460
It says, OK, everything I
mention now, you have to keep.

00:16:18.460 --> 00:16:19.150
Don't touch it.

00:16:19.150 --> 00:16:19.840
Don't shrink it.

00:16:19.840 --> 00:16:21.180
Don't rename it.

00:16:21.180 --> 00:16:24.100
And you want to keep
a class, and then we

00:16:24.100 --> 00:16:26.300
have a fully
qualified class name,

00:16:26.300 --> 00:16:30.354
which is my main class that
came from this manifest.

00:16:30.354 --> 00:16:31.520
There's something more here.

00:16:31.520 --> 00:16:34.330
Just the class name would
only keep the class.

00:16:34.330 --> 00:16:35.830
It wouldn't actually
tell the system

00:16:35.830 --> 00:16:38.330
that this class is
also instantiated,

00:16:38.330 --> 00:16:40.309
which is a big difference.

00:16:40.309 --> 00:16:42.850
To tell it about that, we also
have to keep the constructors,

00:16:42.850 --> 00:16:44.680
and that's what
this init line does.

00:16:44.680 --> 00:16:48.220
So this init, with the
elided parameters, tells R8,

00:16:48.220 --> 00:16:50.800
we also need the constructors,
and we will instantiate this

00:16:50.800 --> 00:16:53.150
at runtime.

00:16:53.150 --> 00:16:55.010
So now, R8 knows
this class is live.

00:16:55.010 --> 00:16:57.750
And as I said before, it
will look at the code.

00:16:57.750 --> 00:16:59.320
Let's go there.

00:16:59.320 --> 00:17:01.244
This is my TheGraph
class, and I've

00:17:01.244 --> 00:17:03.160
removed all the function
bodies and everything

00:17:03.160 --> 00:17:04.970
that's not important.

00:17:04.970 --> 00:17:07.390
But what you will see
here is it actually

00:17:07.390 --> 00:17:10.430
doesn't have a constructor.

00:17:10.430 --> 00:17:13.000
So that means our
analysis ends right here.

00:17:13.000 --> 00:17:13.890
We've seen the class.

00:17:13.890 --> 00:17:15.069
There's no constructor.

00:17:15.069 --> 00:17:17.308
Nothing to do.

00:17:17.308 --> 00:17:19.599
Now, every one of you who's
ever written an Android app

00:17:19.599 --> 00:17:23.270
knows the actual meat happens
in the onCreate method.

00:17:23.270 --> 00:17:26.810
That's where the actual
configuration happens.

00:17:26.810 --> 00:17:28.430
So how does R8 know?

00:17:28.430 --> 00:17:32.900
The keep rule never told it
to actually look at onCreate.

00:17:32.900 --> 00:17:37.100
Well, the trick here is
that the graph extends

00:17:37.100 --> 00:17:40.550
this AppCompatActivity class.

00:17:40.550 --> 00:17:42.440
And if you keep
on following this,

00:17:42.440 --> 00:17:47.610
you will see that eventually
that extends activity.

00:17:47.610 --> 00:17:49.580
Now activity is a Library class.

00:17:49.580 --> 00:17:51.740
And as I said before,
all library classes

00:17:51.740 --> 00:17:53.920
are always live.

00:17:53.920 --> 00:17:58.040
Hence, this onCreate
method is also life.

00:17:58.040 --> 00:18:00.650
But this is onCreate in
the library class is live,

00:18:00.650 --> 00:18:05.434
all its overrides in live
subclasses also become live.

00:18:05.434 --> 00:18:07.100
And that's another
thing of the analysis

00:18:07.100 --> 00:18:09.183
you have to keep in mind
if you want to understand

00:18:09.183 --> 00:18:10.770
how it actually works.

00:18:10.770 --> 00:18:14.270
So this is what
marks onCreate life.

00:18:14.270 --> 00:18:15.080
Let's take a look.

00:18:15.080 --> 00:18:17.300
This is my onCreate method.

00:18:17.300 --> 00:18:19.490
And it looks like a
standard onCreate method.

00:18:19.490 --> 00:18:23.330
It first does some set up,
delegates to the superclass.

00:18:23.330 --> 00:18:25.290
I want to highlight
only two things here.

00:18:25.290 --> 00:18:29.210
The first is this findViewByID.

00:18:29.210 --> 00:18:32.000
This calls the Library
method, and what it does,

00:18:32.000 --> 00:18:34.160
it at runtime
dynamically returns

00:18:34.160 --> 00:18:38.900
an object somewhere from your
view based on your layout.

00:18:38.900 --> 00:18:42.690
Again, R8 cannot
really understand this.

00:18:42.690 --> 00:18:46.650
Because this ID is, again,
defined in an XML file

00:18:46.650 --> 00:18:47.940
somewhere.

00:18:47.940 --> 00:18:50.130
This is my layout.

00:18:50.130 --> 00:18:52.020
And you can see it
says this XYPlot

00:18:52.020 --> 00:18:54.570
class is in my
constraint layout,

00:18:54.570 --> 00:18:57.900
and it has this ID plot.

00:18:57.900 --> 00:19:00.090
How do we figure this out in R8?

00:19:00.090 --> 00:19:02.497
Again, AAPT comes to the rescue.

00:19:02.497 --> 00:19:04.330
And this keep rule might
look quite similar,

00:19:04.330 --> 00:19:09.090
but what it tells R8 that your
layout uses this XYPlot class,

00:19:09.090 --> 00:19:12.220
and it will instantiate
it at runtime.

00:19:12.220 --> 00:19:14.231
So it's always the
same principle.

00:19:17.530 --> 00:19:19.450
Another thing I want
to highlight here

00:19:19.450 --> 00:19:22.810
is that during this
addPlotSeries, where we set up

00:19:22.810 --> 00:19:25.720
the plots, we use another
R identifier, which

00:19:25.720 --> 00:19:28.141
is this R.xml.

00:19:28.141 --> 00:19:29.140
Now, R.xml is different.

00:19:29.140 --> 00:19:33.820
These are three XML
[INAUDIBLE] just

00:19:33.820 --> 00:19:37.180
puts in your XML directory
in your resources.

00:19:37.180 --> 00:19:38.930
There's no requirements
on their contents,

00:19:38.930 --> 00:19:42.350
so AAPT cannot actually
understand them.

00:19:42.350 --> 00:19:44.590
So when you use these
R.xml somewhere,

00:19:44.590 --> 00:19:49.180
you are responsible for all the
keep rules that may require.

00:19:49.180 --> 00:19:50.230
Just keep this in mind.

00:19:50.230 --> 00:19:52.880
We'll come back to that later.

00:19:52.880 --> 00:19:54.480
So this is the
basic analysis flow.

00:19:54.480 --> 00:19:56.710
This is how this
basically works.

00:19:56.710 --> 00:20:01.300
Now you might ask, OK,
200 error messages.

00:20:01.300 --> 00:20:02.680
How does that relate?

00:20:02.680 --> 00:20:03.640
What went wrong there?

00:20:03.640 --> 00:20:05.780
I mean, this analysis
looks reasonable.

00:20:05.780 --> 00:20:07.330
Why does it fail?

00:20:07.330 --> 00:20:10.630
And the reasons is that
the analysis that we do

00:20:10.630 --> 00:20:13.640
is different from
what the VM does.

00:20:13.640 --> 00:20:16.700
And one difference
is annotations.

00:20:16.700 --> 00:20:18.580
Now the Android
VM doesn't really

00:20:18.580 --> 00:20:20.620
care about annotations at all.

00:20:20.620 --> 00:20:24.980
They have no meaning at runtime
unless you use reflection.

00:20:24.980 --> 00:20:26.890
So if an annotation
class is missing,

00:20:26.890 --> 00:20:29.470
the Android VM will still
just execute that code

00:20:29.470 --> 00:20:32.200
because it doesn't
even look at them.

00:20:32.200 --> 00:20:35.380
In comparison, R8 has to
understand notation classes

00:20:35.380 --> 00:20:37.790
because they might be
part of a keep rule.

00:20:37.790 --> 00:20:39.790
So R8 has to find
these classes and has

00:20:39.790 --> 00:20:41.750
to understand the hierarchy.

00:20:41.750 --> 00:20:44.810
And if R8 can't, it
will warn you about it.

00:20:44.810 --> 00:20:47.060
So that's a very common
source about these warnings,

00:20:47.060 --> 00:20:48.325
is missing annotation classes.

00:20:51.320 --> 00:20:54.200
The other thing is code
R8 just can't understand.

00:20:54.200 --> 00:20:56.630
Here's an example,
which is class value.

00:20:56.630 --> 00:20:58.820
So class value is a
concept from Java 7,

00:20:58.820 --> 00:21:01.530
but that's not available
on the Android platform.

00:21:01.530 --> 00:21:04.460
So this code will
actually fail at runtime.

00:21:04.460 --> 00:21:06.350
When the entered VM
tries to execute it,

00:21:06.350 --> 00:21:09.380
it will tell you this
clause is missing.

00:21:09.380 --> 00:21:11.420
Why does this still work?

00:21:11.420 --> 00:21:14.300
Because the creators of Guava
used this nifty trick here

00:21:14.300 --> 00:21:16.640
to hide the missing class.

00:21:16.640 --> 00:21:19.520
What they do is they load
the class via Reflection,

00:21:19.520 --> 00:21:21.470
and if that fails,
they fall back

00:21:21.470 --> 00:21:25.230
to some alternative
implementation.

00:21:25.230 --> 00:21:27.850
Now, the Android VM will
understand this at runtime.

00:21:27.850 --> 00:21:30.560
It will just throw an exception,
the exception gets caught,

00:21:30.560 --> 00:21:32.660
and the alternative is executed.

00:21:32.660 --> 00:21:35.180
But R8 cannot
understand this code.

00:21:35.180 --> 00:21:38.584
It's just too complicated
to handle aesthetically.

00:21:38.584 --> 00:21:40.250
And to fix these
errors, you just really

00:21:40.250 --> 00:21:41.990
have to look at
all these examples

00:21:41.990 --> 00:21:44.000
and find where they came from.

00:21:44.000 --> 00:21:47.060
And ultimately, that
distills to these five

00:21:47.060 --> 00:21:50.900
keep rules or warning
rules that you have to add.

00:21:50.900 --> 00:21:53.180
Now the first three,
they just disable

00:21:53.180 --> 00:21:56.180
warnings about certain
annotations from the checker

00:21:56.180 --> 00:21:58.700
framework and error
prone, and those are just

00:21:58.700 --> 00:22:03.960
static analysis tool frames that
are not used at runtime at all.

00:22:03.960 --> 00:22:05.690
The bottom two are
two classes that

00:22:05.690 --> 00:22:08.700
are not readily available
on the Android platform.

00:22:08.700 --> 00:22:11.180
And they are typically used
via some reflective wrappers

00:22:11.180 --> 00:22:14.600
to make this work at runtime.

00:22:14.600 --> 00:22:19.952
So adding these five rules, we
get our application to compile.

00:22:19.952 --> 00:22:20.910
That wasn't bad, right?

00:22:20.910 --> 00:22:22.010
So we looked a bit at it.

00:22:22.010 --> 00:22:22.980
We added five rules.

00:22:22.980 --> 00:22:26.660
And ta-da, we have a
smaller application.

00:22:26.660 --> 00:22:29.620
Unfortunately, the runtime
behavior of my application

00:22:29.620 --> 00:22:32.410
has changed just
ever so slightly,

00:22:32.410 --> 00:22:34.510
because now it crashes.

00:22:34.510 --> 00:22:37.970
And that's the other
problem you typically see.

00:22:37.970 --> 00:22:40.560
Again, what happened here?

00:22:40.560 --> 00:22:41.060
Right?

00:22:41.060 --> 00:22:43.460
I explained to you how
the analysis works.

00:22:43.460 --> 00:22:46.520
That looked all
fine and reasonable.

00:22:46.520 --> 00:22:50.810
The typical problem
is reflection.

00:22:50.810 --> 00:22:52.490
Because by its mere
nature, reflection

00:22:52.490 --> 00:22:55.100
is about using a
dynamic runtime value

00:22:55.100 --> 00:22:58.170
to load a method or a clause.

00:22:58.170 --> 00:23:01.240
And static analysis just
can't understand this.

00:23:01.240 --> 00:23:05.820
Dynamic values are the
enemy of static analysis.

00:23:05.820 --> 00:23:07.710
So how do we fix this?

00:23:07.710 --> 00:23:09.380
Well, we have to
somehow figure out

00:23:09.380 --> 00:23:13.610
how to tell our aide about
these cases of reflection

00:23:13.610 --> 00:23:15.560
and make R8 understand them.

00:23:15.560 --> 00:23:17.720
And that's really
what keep rules do.

00:23:17.720 --> 00:23:19.710
So what did I do?

00:23:19.710 --> 00:23:21.760
I went to the internet.

00:23:21.760 --> 00:23:23.930
Unfortunately, the developers
of AndroidPlot put up

00:23:23.930 --> 00:23:27.860
this rule on the internet,
which says, keep class--

00:23:27.860 --> 00:23:30.130
OK, you want to keep some
classes-- com AndroidPlot,

00:23:30.130 --> 00:23:32.360
star, star.

00:23:32.360 --> 00:23:35.390
And what this means is it
tells R8 to essentially

00:23:35.390 --> 00:23:39.220
not touch Android plot at all.

00:23:39.220 --> 00:23:41.380
Again, this will
fix the problem.

00:23:41.380 --> 00:23:45.510
It will run again, but
it will no longer shrink.

00:23:45.510 --> 00:23:48.840
So this cannot be the
point in using R8.

00:23:48.840 --> 00:23:50.820
So how can we improve on this?

00:23:50.820 --> 00:23:52.440
And there's really
no clever way doing

00:23:52.440 --> 00:23:56.970
this, other than going on
some forensics investigation.

00:23:56.970 --> 00:23:59.670
We really have to find out
where all this reflection is

00:23:59.670 --> 00:24:03.510
happening and what we have to
add toward the configuration

00:24:03.510 --> 00:24:06.360
to make R8 understand it.

00:24:06.360 --> 00:24:07.370
So where do you look?

00:24:07.370 --> 00:24:08.990
Where do we find evidence?

00:24:08.990 --> 00:24:13.560
And the first place
to look is adb log.

00:24:13.560 --> 00:24:15.320
So I've preprocessed
this a bit here

00:24:15.320 --> 00:24:16.659
so that it's easier to read.

00:24:16.659 --> 00:24:18.450
But in essence, if you
go on Android Studio

00:24:18.450 --> 00:24:21.540
and use the log viewer, you
can filter by Process ID,

00:24:21.540 --> 00:24:25.072
and this is, in essence,
what you will see.

00:24:25.072 --> 00:24:26.530
So there will be
this log statement

00:24:26.530 --> 00:24:30.250
saying that styleable
definition not found for A.

00:24:30.250 --> 00:24:32.140
As such, this is
not really helpful,

00:24:32.140 --> 00:24:34.906
because I don't understand
what this is trying to tell me.

00:24:34.906 --> 00:24:37.030
But it is really great,
because it gives me a place

00:24:37.030 --> 00:24:39.190
to look in the source code.

00:24:39.190 --> 00:24:41.110
So this is a big
piece of advice.

00:24:41.110 --> 00:24:43.030
If you write these
kind of libraries

00:24:43.030 --> 00:24:46.170
and you do a reflection,
put in logging statements.

00:24:46.170 --> 00:24:47.920
It's not so important
that people actually

00:24:47.920 --> 00:24:49.090
understand the message.

00:24:49.090 --> 00:24:51.370
It's much more important
that people will find where

00:24:51.370 --> 00:24:53.807
this statement was generated.

00:24:53.807 --> 00:24:55.640
Because I have this
logging statement there,

00:24:55.640 --> 00:25:00.840
I can now actually look at the
code and see what it's doing.

00:25:00.840 --> 00:25:01.840
So here's plus plotjava.

00:25:01.840 --> 00:25:03.214
And as you can
see down there, it

00:25:03.214 --> 00:25:06.770
says log.d styleable
definition not found.

00:25:06.770 --> 00:25:10.000
So what is going wrong here?

00:25:10.000 --> 00:25:11.660
As you can see, this
does reflection.

00:25:11.660 --> 00:25:13.450
There is this
styeableclass.getfield,

00:25:13.450 --> 00:25:16.690
and styleable class
is a class object.

00:25:16.690 --> 00:25:20.230
And get field will get
a field from that class,

00:25:20.230 --> 00:25:22.990
give them the name,
styleable name.

00:25:22.990 --> 00:25:26.065
So this is an example of
reflection on a class.

00:25:28.660 --> 00:25:30.100
How is styleable name defined?

00:25:30.100 --> 00:25:31.891
Because that's clearly
what is going wrong.

00:25:31.891 --> 00:25:33.670
It's trying to find a
field called A. That

00:25:33.670 --> 00:25:36.250
seems a strange field name.

00:25:36.250 --> 00:25:38.935
This is how styleable name is.

00:25:38.935 --> 00:25:42.212
I's defined by means
of getclass.getname.

00:25:42.212 --> 00:25:44.170
So again, we have to
understand what this does.

00:25:44.170 --> 00:25:45.965
What does getclass do?

00:25:45.965 --> 00:25:47.590
That's, again, a
reflective invocation.

00:25:47.590 --> 00:25:51.430
It will return what's called
in Java the current class.

00:25:51.430 --> 00:25:54.790
Now if you're in this plot
file, and in the plot class,

00:25:54.790 --> 00:25:57.920
the current class can be
the plot class itself,

00:25:57.920 --> 00:26:00.520
but it can also be
any of its subclasses.

00:26:00.520 --> 00:26:02.260
Because at runtime,
this method might

00:26:02.260 --> 00:26:04.480
run in different
contexts, depending on how

00:26:04.480 --> 00:26:07.750
the virtual dispatch worked.

00:26:07.750 --> 00:26:09.730
And now we get the
name of this class,

00:26:09.730 --> 00:26:17.350
and this seems to return A. Why
did they name their class A?

00:26:17.350 --> 00:26:18.280
Well, they didn't.

00:26:18.280 --> 00:26:19.831
The problem is minification.

00:26:19.831 --> 00:26:20.330
Right?

00:26:20.330 --> 00:26:23.455
R8 went ahead, saw this
class, and thought, well,

00:26:23.455 --> 00:26:24.420
plot is a long name.

00:26:24.420 --> 00:26:27.400
Let's call it A.
So to fix this, we

00:26:27.400 --> 00:26:30.370
have to prevent R8 from
renaming this class or any

00:26:30.370 --> 00:26:31.480
of its subclasses.

00:26:34.480 --> 00:26:37.142
And this is the
corresponding keep rule.

00:26:37.142 --> 00:26:38.350
So again, what does this say?

00:26:38.350 --> 00:26:43.750
It says keep class
com androidplot.pot.

00:26:43.750 --> 00:26:46.150
And that means R8
should keep the class,

00:26:46.150 --> 00:26:48.730
not rename it, not optimize it.

00:26:48.730 --> 00:26:51.080
But as I said, we also have
to keep all the subclasses,

00:26:51.080 --> 00:26:53.590
so we have to say keep
class star extends

00:26:53.590 --> 00:26:57.400
com androidplot.plot.

00:26:57.400 --> 00:27:02.530
This will keep all subclasses of
plot and the plot class itself.

00:27:02.530 --> 00:27:05.570
But is this actually
what we want?

00:27:05.570 --> 00:27:08.260
If you think again about
what get class does,

00:27:08.260 --> 00:27:12.910
it, at runtime, returns the
class of the current object.

00:27:12.910 --> 00:27:15.840
Now, you can only
be the current class

00:27:15.840 --> 00:27:17.840
if you have actually
been instantiated.

00:27:17.840 --> 00:27:18.340
Right?

00:27:18.340 --> 00:27:20.220
If a class never
gets created, there

00:27:20.220 --> 00:27:24.526
is no way of getting
it via get class.

00:27:24.526 --> 00:27:25.900
So our keep rules
do not actually

00:27:25.900 --> 00:27:27.880
have to keep extra classes.

00:27:27.880 --> 00:27:30.010
All we want is we
want to prevent them

00:27:30.010 --> 00:27:30.910
from being renamed.

00:27:30.910 --> 00:27:33.340
And that's where
modifiers come in.

00:27:33.340 --> 00:27:35.540
So here's a modifier for you.

00:27:35.540 --> 00:27:37.750
What this now does,
it still says keep.

00:27:37.750 --> 00:27:39.520
But it says Allow Shrinking.

00:27:39.520 --> 00:27:43.010
So it tells R8, if you
see this plot class,

00:27:43.010 --> 00:27:45.940
you're allowed to remove
it if nobody uses it.

00:27:45.940 --> 00:27:50.610
But if you keep it, don't rename
it, and don't optimize it.

00:27:50.610 --> 00:27:52.900
And this will fix our
problem, because now the plot

00:27:52.900 --> 00:27:55.710
class at runtime will
actually still be called plot,

00:27:55.710 --> 00:27:58.889
as will be all the subclasses.

00:27:58.889 --> 00:28:00.180
So that was not too bad, right?

00:28:00.180 --> 00:28:01.305
You look a bit at the code.

00:28:01.305 --> 00:28:06.130
You come up with two keep rules,
and your application will run.

00:28:06.130 --> 00:28:08.530
Or not.

00:28:08.530 --> 00:28:10.180
So it's still not working.

00:28:10.180 --> 00:28:12.220
We have to do more
forensics work.

00:28:12.220 --> 00:28:13.180
What do we do?

00:28:13.180 --> 00:28:15.310
We go back to the adb log.

00:28:15.310 --> 00:28:17.030
And the message has changed.

00:28:17.030 --> 00:28:19.450
We now see a
different exception.

00:28:19.450 --> 00:28:22.270
Again, it's not really clear
what this is trying to tell me,

00:28:22.270 --> 00:28:24.100
but I have an exception
I can look for.

00:28:24.100 --> 00:28:26.140
So this says, error
while parsing key,

00:28:26.140 --> 00:28:29.200
linePaint.strokeWidth.

00:28:29.200 --> 00:28:30.690
OK.

00:28:30.690 --> 00:28:32.190
Why does this happen?

00:28:32.190 --> 00:28:33.320
How do we find out?

00:28:33.320 --> 00:28:35.000
We look at the code.

00:28:35.000 --> 00:28:36.840
And here's the
corresponding method.

00:28:36.840 --> 00:28:38.840
And I've highlighted the
reflective use in there

00:28:38.840 --> 00:28:39.510
for you.

00:28:39.510 --> 00:28:41.900
So again, you can
see, we take a class,

00:28:41.900 --> 00:28:44.850
and they beget all its methods.

00:28:44.850 --> 00:28:49.160
And next, we compare the name of
this method against some given

00:28:49.160 --> 00:28:52.520
name we are looking for.

00:28:52.520 --> 00:28:54.820
So there's two things
that can go wrong here.

00:28:54.820 --> 00:28:56.740
We are just getting
a set of all methods

00:28:56.740 --> 00:28:59.415
so we might have removed
too many methods.

00:28:59.415 --> 00:29:01.540
And again, we're getting
the name of these methods,

00:29:01.540 --> 00:29:03.229
so we might have renamed them.

00:29:03.229 --> 00:29:04.770
So these are the
two error conditions

00:29:04.770 --> 00:29:05.740
we now have to check.

00:29:05.740 --> 00:29:08.080
What are we removing, and
what are we renaming that we

00:29:08.080 --> 00:29:09.130
shouldn't?

00:29:09.130 --> 00:29:10.510
Now I have to
admit, it's kind of

00:29:10.510 --> 00:29:13.080
hard to figure out what this
code really does unless you

00:29:13.080 --> 00:29:14.620
are the library developer.

00:29:14.620 --> 00:29:16.930
So the person who wrote
this code initially

00:29:16.930 --> 00:29:18.967
knows perfectly clearly
what this is doing.

00:29:18.967 --> 00:29:20.800
And at that point, it
would have been really

00:29:20.800 --> 00:29:23.990
easy to write these keep rules.

00:29:23.990 --> 00:29:26.120
So what does this do?

00:29:26.120 --> 00:29:29.170
Do you remember these?

00:29:29.170 --> 00:29:30.870
So when we do this
addPlotSeries,

00:29:30.870 --> 00:29:34.360
we configure what these series
are supposed to look like.

00:29:34.360 --> 00:29:36.340
And AndroidPlot has this
really great feature

00:29:36.340 --> 00:29:39.100
where you can tell it to
configure your graph based

00:29:39.100 --> 00:29:41.720
on some XML file.

00:29:41.720 --> 00:29:45.136
And this is what this
XML file looks like.

00:29:45.136 --> 00:29:46.510
And as you can
see, in there, you

00:29:46.510 --> 00:29:49.460
will find this
linePaint.StrokeWidth.

00:29:49.460 --> 00:29:53.230
And what this library will do,
it will take this XML file,

00:29:53.230 --> 00:29:55.420
it goes through all the
attributes in there,

00:29:55.420 --> 00:29:57.310
and then it will call
corresponding getters

00:29:57.310 --> 00:30:01.390
and setters on an object
it's trying to configure.

00:30:01.390 --> 00:30:03.550
So we'll take a graph
object, and then we'll

00:30:03.550 --> 00:30:07.210
call the get linePaint
getter, and then

00:30:07.210 --> 00:30:09.760
set the StrokeWidth property.

00:30:09.760 --> 00:30:12.250
This is a very standard pattern
of configuring something

00:30:12.250 --> 00:30:14.630
at runtime, and it's a
really great feature.

00:30:14.630 --> 00:30:17.230
But if R8 sees this, it
cannot understand this,

00:30:17.230 --> 00:30:19.510
because R8 cannot make the
connection between this XML

00:30:19.510 --> 00:30:22.320
file and the actual classes.

00:30:22.320 --> 00:30:26.050
Also, as this is freeform XML,
we don't have AAPT to help us.

00:30:26.050 --> 00:30:30.350
Instead, we have to
do this ourselves.

00:30:30.350 --> 00:30:33.020
And this is the
corresponding keep rule.

00:30:33.020 --> 00:30:35.370
What do we need to do?

00:30:35.370 --> 00:30:37.370
We don't want to keep
[INAUDIBLE] extra classes,

00:30:37.370 --> 00:30:38.985
because again, what
we're trying to do here

00:30:38.985 --> 00:30:41.510
is we're trying to take an
object at runtime that already

00:30:41.510 --> 00:30:43.820
exists, and then we
try to configure it

00:30:43.820 --> 00:30:46.790
by calling getters and setters.

00:30:46.790 --> 00:30:49.190
So that's why we use
keep class members.

00:30:49.190 --> 00:30:51.050
That doesn't keep
any extra classes,

00:30:51.050 --> 00:30:53.000
but it tells R8
if you're already

00:30:53.000 --> 00:30:56.000
keeping a class in the
com AndroidPlot package,

00:30:56.000 --> 00:31:00.410
also keep these members,
and don't rename them.

00:31:00.410 --> 00:31:02.190
And what members
do we want to keep?

00:31:02.190 --> 00:31:04.380
First of all, we
want to keep getters.

00:31:04.380 --> 00:31:06.000
And what to getters look like?

00:31:06.000 --> 00:31:07.650
They return some result--

00:31:07.650 --> 00:31:08.850
that's the three stars.

00:31:08.850 --> 00:31:12.660
They start with Get, and they
typically have no arguments.

00:31:12.660 --> 00:31:15.470
So that first line in there
will keep your getters.

00:31:15.470 --> 00:31:17.450
Similarly, we can keep setters.

00:31:17.450 --> 00:31:21.200
So they don't return anything,
but they start with set,

00:31:21.200 --> 00:31:25.630
and they take a single
argument of some type.

00:31:25.630 --> 00:31:28.010
So this rule will now keep
the getters and setters,

00:31:28.010 --> 00:31:30.290
so that runtime,
the configuaration,

00:31:30.290 --> 00:31:31.010
can just happen.

00:31:33.810 --> 00:31:35.480
So one more keep rule.

00:31:35.480 --> 00:31:37.470
Do you think it will work now?

00:31:37.470 --> 00:31:39.210
Let's take a look.

00:31:39.210 --> 00:31:40.560
And yes, we made it.

00:31:40.560 --> 00:31:42.510
So we added a couple
of keep rules.

00:31:42.510 --> 00:31:44.890
And now, our application
is actually running again,

00:31:44.890 --> 00:31:46.132
but was it worth it?

00:31:46.132 --> 00:31:48.090
Because this was a bit
of an investment, right?

00:31:48.090 --> 00:31:48.930
We had to look at the code.

00:31:48.930 --> 00:31:51.000
We had to figure out
what it actually does.

00:31:51.000 --> 00:31:53.160
Was this journey worthwhile?

00:31:53.160 --> 00:31:56.880
Let's go back to
the APK analyzer.

00:31:56.880 --> 00:31:58.780
And here, you can
see the results.

00:31:58.780 --> 00:32:01.440
So if you look at com
Google, which is Guava,

00:32:01.440 --> 00:32:06.720
that went from 1.3
megabytes to just 8K.

00:32:06.720 --> 00:32:08.430
I know that's very
extreme, because I'm

00:32:08.430 --> 00:32:10.500
using essentially a
couple of few classes

00:32:10.500 --> 00:32:12.190
in this huge collection.

00:32:12.190 --> 00:32:14.520
But also for AndroidPlot,
which is much more realistic,

00:32:14.520 --> 00:32:18.600
you can see that it went
from 180K to about 100K,

00:32:18.600 --> 00:32:22.350
and that's more than
one entire [INAUDIBLE]..

00:32:22.350 --> 00:32:24.180
Also, if you look at
my app, you can see

00:32:24.180 --> 00:32:27.170
that it went from 35K to 2K.

00:32:27.170 --> 00:32:29.820
And 2K is a lot closer
to the 100 lines of code

00:32:29.820 --> 00:32:32.040
I actually wrote,
because we removed

00:32:32.040 --> 00:32:35.010
all the unneeded auto-generated
parts that the build

00:32:35.010 --> 00:32:36.300
system has created for us.

00:32:38.850 --> 00:32:41.490
Again, I've created
this graphic for you

00:32:41.490 --> 00:32:43.200
to make this a bit more visual.

00:32:43.200 --> 00:32:45.610
And as you can see,
Guava nearly disappeared.

00:32:45.610 --> 00:32:48.870
AndroidPlot halved,
and my app also

00:32:48.870 --> 00:32:52.410
turned into this
little sliver there.

00:32:52.410 --> 00:32:55.560
So it was a bit of a journey,
but it really, really paid off.

00:32:58.610 --> 00:33:01.137
So what's the
takeaway lessons here?

00:33:01.137 --> 00:33:03.220
I hope I was able to
convince you that it actually

00:33:03.220 --> 00:33:05.807
makes sense to look into size.

00:33:05.807 --> 00:33:08.140
If you build an app, no matter
what your target audience

00:33:08.140 --> 00:33:10.210
is, please invest into size.

00:33:10.210 --> 00:33:11.920
Please invest into
creating keep rules.

00:33:11.920 --> 00:33:16.910
Please use ProGuard or R8
to actually shrink your app.

00:33:16.910 --> 00:33:19.360
But also, I hope I've
shown you some ideas of how

00:33:19.360 --> 00:33:22.030
to make this easier.

00:33:22.030 --> 00:33:24.040
And the first thing to
really take away here

00:33:24.040 --> 00:33:27.970
is, you should consider
a size early on.

00:33:27.970 --> 00:33:30.660
Because while you are
writing your code,

00:33:30.660 --> 00:33:33.569
it is really, really easy to
also write your keep rules,

00:33:33.569 --> 00:33:35.860
because you still understand
what that code is actually

00:33:35.860 --> 00:33:37.420
doing.

00:33:37.420 --> 00:33:39.430
Write all the code
examples we looked at,

00:33:39.430 --> 00:33:41.050
if you had just
written them, it would

00:33:41.050 --> 00:33:45.080
be easy to understand
why this goes wrong.

00:33:45.080 --> 00:33:47.360
Also, you should add
structure to your code

00:33:47.360 --> 00:33:50.300
to ease describing
reflective use.

00:33:50.300 --> 00:33:52.790
You remember those getters
and setters example I had,

00:33:52.790 --> 00:33:55.340
where I said, OK, all
classes and AndroidPlot,

00:33:55.340 --> 00:33:57.332
keep the getters and setters?

00:33:57.332 --> 00:33:59.540
These kind of things are
much simpler if you actually

00:33:59.540 --> 00:34:03.230
have some kind of interface that
allows you to tighten these up.

00:34:03.230 --> 00:34:06.830
So if you had an interface,
say, runtime configured object,

00:34:06.830 --> 00:34:09.889
you could just say in a
keep rule, every object that

00:34:09.889 --> 00:34:14.719
extends runtime configured,
keep these getters and setters.

00:34:14.719 --> 00:34:17.030
And then it's independent
of the actual application,

00:34:17.030 --> 00:34:20.060
then it can just be
part of that library.

00:34:20.060 --> 00:34:21.659
And lastly, and
this sounds obvious,

00:34:21.659 --> 00:34:22.889
but it's really important.

00:34:22.889 --> 00:34:26.679
You should continuously
test and optimize build.

00:34:26.679 --> 00:34:29.179
Again, the earlier you
find regressions in your

00:34:29.179 --> 00:34:31.550
build, the easier
it is to fix them,

00:34:31.550 --> 00:34:34.190
because you will still remember
what you actually changed,

00:34:34.190 --> 00:34:36.480
and they will make it easy
to come up with keep rules.

00:34:40.190 --> 00:34:42.380
If you are a library
developer, you

00:34:42.380 --> 00:34:46.639
should really, really
carefully provide keep rules,

00:34:46.639 --> 00:34:48.440
because there's
this multiplayer.

00:34:48.440 --> 00:34:52.730
If you make precise keep rules,
all the users of your library

00:34:52.730 --> 00:34:57.890
will benefit from it, and a lot
of apps will become smaller.

00:34:57.890 --> 00:34:59.270
Don't make this an afterthought.

00:34:59.270 --> 00:35:01.970
Invest into keep rules while
you build your library,

00:35:01.970 --> 00:35:03.692
while you design your library.

00:35:03.692 --> 00:35:05.150
Publish them
somewhere where people

00:35:05.150 --> 00:35:08.210
can find them, because that's
typically what we all do.

00:35:08.210 --> 00:35:11.060
We will search the
internet for rules to use,

00:35:11.060 --> 00:35:13.970
so put them on your home page,
put them in the readme file,

00:35:13.970 --> 00:35:16.250
make it visible.

00:35:16.250 --> 00:35:19.670
And lastly, consider using
consumer ProGuard files

00:35:19.670 --> 00:35:22.520
when you are shipping
via the AAR system,

00:35:22.520 --> 00:35:25.310
because this makes it completely
transparent to your library

00:35:25.310 --> 00:35:26.300
users.

00:35:26.300 --> 00:35:28.490
When they enable ProGuard,
they will automatically

00:35:28.490 --> 00:35:30.017
get your Keep Rules.

00:35:33.430 --> 00:35:36.890
Lastly, please give us feedback.

00:35:36.890 --> 00:35:39.340
So we've built R8,
we have tested it.

00:35:39.340 --> 00:35:41.260
We believe it's a
drop-in replacement.

00:35:41.260 --> 00:35:43.330
But only you can
actually find that out.

00:35:43.330 --> 00:35:46.450
So if you're using ProGuard
today, give R8 a try,

00:35:46.450 --> 00:35:48.220
tell us how it worked for you.

00:35:48.220 --> 00:35:50.140
If you're not yet
using ProGuard,

00:35:50.140 --> 00:35:53.050
try out R8, and see how far
you can get with shrinking,

00:35:53.050 --> 00:35:55.015
and how good our diagnostics.

00:35:55.015 --> 00:35:56.216
File bugs.

00:35:56.216 --> 00:35:57.590
We have a really
responsive team,

00:35:57.590 --> 00:35:59.650
and we really care
about your feedback.

00:35:59.650 --> 00:36:02.770
And lastly, after this talk, you
can also see me at the sandbox,

00:36:02.770 --> 00:36:05.440
or find me outside if
you want to have a chat.

00:36:05.440 --> 00:36:07.030
And with that, I
want to thank you

00:36:07.030 --> 00:36:09.654
very much for your attention.

00:36:09.654 --> 00:36:12.576
[APPLAUSE]

00:36:14.524 --> 00:36:21.042
[MUSIC PLAYING]

