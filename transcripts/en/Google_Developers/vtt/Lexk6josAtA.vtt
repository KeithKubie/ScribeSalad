WEBVTT
Kind: captions
Language: en

00:00:00.660 --> 00:00:01.500
JAREK WILKIEWICZ:
Hello, everyone.

00:00:01.500 --> 00:00:03.170
I'm going to go ahead
and get started.

00:00:03.170 --> 00:00:05.250
Welcome to our session.

00:00:05.250 --> 00:00:07.710
Thank you very much
for coming.

00:00:07.710 --> 00:00:12.975
I realize there's free drinks
after this, so we're going to

00:00:12.975 --> 00:00:15.550
try to keep you entertained
until then.

00:00:15.550 --> 00:00:19.390
We'll talk about supercharging
your mobile game with YouTube.

00:00:19.390 --> 00:00:21.050
And I would like
to introduce my

00:00:21.050 --> 00:00:24.900
co-presenter Corey from Unity.

00:00:24.900 --> 00:00:28.470
He is working on Unity
implementation with a number

00:00:28.470 --> 00:00:29.850
of partners.

00:00:29.850 --> 00:00:34.400
So I wanted to start with
this photo that I

00:00:34.400 --> 00:00:36.060
found on the internet.

00:00:36.060 --> 00:00:39.820
As you can tell, it was
taken a while ago.

00:00:39.820 --> 00:00:43.770
There's a few really excited
mobile gamers.

00:00:43.770 --> 00:00:47.240
This photo was taken at
a gaming convention in

00:00:47.240 --> 00:00:49.100
Vancouver, Canada.

00:00:49.100 --> 00:00:54.250
The question that popped into
my mind when I saw this is,

00:00:54.250 --> 00:00:59.680
what would it take to excite and
energize your gamers, your

00:00:59.680 --> 00:01:04.030
players, your customers
equally today?

00:01:04.030 --> 00:01:10.080
Well, if you look at some stats,
there was a study done

00:01:10.080 --> 00:01:10.850
two years ago.

00:01:10.850 --> 00:01:15.530
And 95% of gamers that spend
significant time playing games

00:01:15.530 --> 00:01:18.590
watch user generated
content on YouTube.

00:01:18.590 --> 00:01:19.870
So these are gaming clips.

00:01:19.870 --> 00:01:22.110
Actually, the number for
trailers is 94%.

00:01:22.110 --> 00:01:25.680
So more people watch user
generated content than the

00:01:25.680 --> 00:01:29.250
highly produced gaming
trailers.

00:01:29.250 --> 00:01:32.310
In fact, there's several
companies already taking

00:01:32.310 --> 00:01:34.070
advantage of this trend.

00:01:34.070 --> 00:01:37.190
So, some of these titles that
I'll show you will probably be

00:01:37.190 --> 00:01:38.320
familiar to you.

00:01:38.320 --> 00:01:43.680
Trial Xtreme 3, FIFA 13 has
video upload capability so you

00:01:43.680 --> 00:01:46.830
can share your gameplay directly
from the game, and

00:01:46.830 --> 00:01:50.280
then the granddaddy of them
all, Talking Tom.

00:01:50.280 --> 00:01:53.500
This is an application that
has really taken great

00:01:53.500 --> 00:01:55.690
advantage of video sharing.

00:01:55.690 --> 00:01:59.790
So in that app, you can create
a video that's both a nice

00:01:59.790 --> 00:02:02.650
virtual pet, a type of
app, as well as a

00:02:02.650 --> 00:02:05.680
self expression platform.

00:02:05.680 --> 00:02:09.240
So this is what we'll
talk about today.

00:02:09.240 --> 00:02:13.500
We will show you how you can
take a sample Unity game that

00:02:13.500 --> 00:02:18.850
we build for this purpose, and
then integrate YouTube API in

00:02:18.850 --> 00:02:22.530
order to share the gameplay
with the world.

00:02:22.530 --> 00:02:25.330
YouTube has one billion users,
so there's a billion potential

00:02:25.330 --> 00:02:27.050
customers out there.

00:02:27.050 --> 00:02:30.960
And then we'll show you both
the upload and playback

00:02:30.960 --> 00:02:31.570
capability--

00:02:31.570 --> 00:02:34.520
how that can be integrated
into a Unity game.

00:02:34.520 --> 00:02:37.460
So really, the only thing you
have to do as a game developer

00:02:37.460 --> 00:02:40.100
is focus on building
a great game.

00:02:40.100 --> 00:02:41.480
That's it.

00:02:41.480 --> 00:02:47.450
So first I wanted to show you a
little demo of the game that

00:02:47.450 --> 00:02:49.345
we have built for
this purpose.

00:02:55.960 --> 00:03:00.900
So here's my game, and the
objective of this game is to

00:03:00.900 --> 00:03:05.990
shoot these gas cans as
fast as possible.

00:03:05.990 --> 00:03:09.130
And I'm pretty bad at it, as you
can tell, but I'll try to

00:03:09.130 --> 00:03:10.380
do my best.

00:03:12.390 --> 00:03:13.320
One more.

00:03:13.320 --> 00:03:14.020
Oh.

00:03:14.020 --> 00:03:15.180
I got 12 points.

00:03:15.180 --> 00:03:18.030
All right, time is up.

00:03:18.030 --> 00:03:19.740
So the next step--

00:03:19.740 --> 00:03:22.200
I just had this wonderful
score of 12 points.

00:03:22.200 --> 00:03:24.070
I would like to watch
myself play this

00:03:24.070 --> 00:03:25.710
game, so here's a replay.

00:03:29.360 --> 00:03:30.610
Pretty amazing.

00:03:34.470 --> 00:03:35.170
I rock.

00:03:35.170 --> 00:03:40.250
So what I do next is, well, I
definitely want to share this

00:03:40.250 --> 00:03:42.720
gameplay on YouTube.

00:03:42.720 --> 00:03:45.730
So I'm going to hit the YouTube
button and let this

00:03:45.730 --> 00:03:49.630
processing take place.

00:03:49.630 --> 00:03:54.540
What this means to you is,
imagine you were playing an

00:03:54.540 --> 00:03:55.510
awesome game--

00:03:55.510 --> 00:03:58.250
some sort of warfare simulation
and with your best

00:03:58.250 --> 00:04:02.500
friend, and you just blew up
his or her Abrams tank.

00:04:02.500 --> 00:04:06.080
You can share that achievement
on YouTube, and then claim the

00:04:06.080 --> 00:04:08.630
bragging rights for the
rest of the week.

00:04:08.630 --> 00:04:12.130
Now, I would like to introduce
Corey, who will take you

00:04:12.130 --> 00:04:16.010
through the process of creating
games with Unity, and

00:04:16.010 --> 00:04:19.750
then he will discuss some of
the plugging opportunities

00:04:19.750 --> 00:04:22.160
that exist within the
Unity framework.

00:04:22.160 --> 00:04:24.550
After that, I'll take you
through the process of

00:04:24.550 --> 00:04:27.630
actually integration between
YouTube APIs and Unity.

00:04:27.630 --> 00:04:28.910
So over to you, Corey.

00:04:28.910 --> 00:04:29.760
COREY JOHNSON: Thank you.

00:04:29.760 --> 00:04:30.240
Hello, everyone.

00:04:30.240 --> 00:04:32.052
My name's Corey Johnson.

00:04:32.052 --> 00:04:35.240
I'm a field engineer at
Unity Technologies.

00:04:35.240 --> 00:04:39.000
This is Unity circa last fall.

00:04:39.000 --> 00:04:41.800
There I am, just in case
you were doubting me.

00:04:41.800 --> 00:04:46.010
I'm going to take you through
what Unity is, what we're

00:04:46.010 --> 00:04:50.000
about, and then kind of give you
an overview of our editor,

00:04:50.000 --> 00:04:52.975
just so that we have some
context when Jarek talks about

00:04:52.975 --> 00:04:54.890
his plugin later.

00:04:54.890 --> 00:04:57.100
I apologize if you already
know Unity.

00:04:57.100 --> 00:04:59.820
We're going to stay high level,
but I just want to go

00:04:59.820 --> 00:05:00.680
really, really fast.

00:05:00.680 --> 00:05:02.460
And if you don't know Unity, I
apologize, because we're going

00:05:02.460 --> 00:05:03.710
to go really, really fast.

00:05:03.710 --> 00:05:07.290
But myself and my illustrious
colleagues are in the sandbox

00:05:07.290 --> 00:05:09.190
on the third floor in the
Android section, so please

00:05:09.190 --> 00:05:12.210
feel free to follow up.

00:05:12.210 --> 00:05:13.270
So what is Unity?

00:05:13.270 --> 00:05:16.130
Well, we're a cross
platform engine.

00:05:16.130 --> 00:05:17.750
We come with an editor,
which is a tool to

00:05:17.750 --> 00:05:20.050
create 2D and 3D content.

00:05:20.050 --> 00:05:22.280
We believe we have the best
tool in the industry.

00:05:22.280 --> 00:05:24.820
We believe that we give you a
rapid learning curve and rapid

00:05:24.820 --> 00:05:26.150
iteration times.

00:05:26.150 --> 00:05:28.510
We have a mantra of build once,
deploy anywhere, meaning

00:05:28.510 --> 00:05:30.920
we're, again, multi-platform.

00:05:30.920 --> 00:05:34.210
Our mission statement is to
democratize game development,

00:05:34.210 --> 00:05:36.270
and that means that we want
anybody out there who wants to

00:05:36.270 --> 00:05:38.170
build a game-- whether an artist
or an engineer-- to be

00:05:38.170 --> 00:05:40.000
able to build a game.

00:05:40.000 --> 00:05:43.090
And that attitude has led to our
tooling, and it also led

00:05:43.090 --> 00:05:45.270
to an enormous community, which
I'm going to talk about

00:05:45.270 --> 00:05:47.200
in a second.

00:05:47.200 --> 00:05:48.880
When I say everywhere,
I'm just going to

00:05:48.880 --> 00:05:49.880
quickly define that.

00:05:49.880 --> 00:05:53.130
We're currently at 13 different
platforms, and more

00:05:53.130 --> 00:05:53.980
on the way.

00:05:53.980 --> 00:05:57.390
We even have Union, which is
platforms that you may not

00:05:57.390 --> 00:05:58.720
even know you want to
be on yet that we

00:05:58.720 --> 00:06:00.220
help get content to.

00:06:00.220 --> 00:06:03.820
So as you can see, we're fairly
prolific, and if you

00:06:03.820 --> 00:06:06.968
want to be there, we're probably
there for you.

00:06:06.968 --> 00:06:08.560
A little bit about
our community.

00:06:08.560 --> 00:06:11.440
1.8 million people
use the product.

00:06:11.440 --> 00:06:15.310
400,000 monthly actives
every month.

00:06:15.310 --> 00:06:18.230
5 million hours of creation
every month.

00:06:18.230 --> 00:06:19.330
Enormous.

00:06:19.330 --> 00:06:22.940
From the hobbyist all the way
up to triple A studios.

00:06:22.940 --> 00:06:25.740
One of the things we did to
democratize this is build an

00:06:25.740 --> 00:06:28.320
asset store, which is a
marketplace for our users to

00:06:28.320 --> 00:06:31.710
share content, whether it be
tools that they built in our

00:06:31.710 --> 00:06:36.040
customizable editor that we just
didn't get to, or if it's

00:06:36.040 --> 00:06:38.800
awesome artwork that
people need.

00:06:38.800 --> 00:06:40.400
So like, for me, I'm
an engineer.

00:06:40.400 --> 00:06:42.340
I can't do art, but I can
go in and buy awesome

00:06:42.340 --> 00:06:44.410
environments or a knight
to run around my game.

00:06:47.360 --> 00:06:51.430
One of the features that we use
is called Native plugins.

00:06:51.430 --> 00:06:53.150
We're going to talk a lot about
it today, so I just want

00:06:53.150 --> 00:06:54.740
to give you an overview
of what they are.

00:06:54.740 --> 00:06:58.880
So Unity uses Mono for
scripting, so that means you

00:06:58.880 --> 00:07:02.460
can run your game scripts
across platform.

00:07:02.460 --> 00:07:04.840
But what plugins let you do is
call native code to whatever

00:07:04.840 --> 00:07:08.140
platform you're on from
your game scripts.

00:07:08.140 --> 00:07:11.140
For this talk, we're going to
focus only on Android, and I

00:07:11.140 --> 00:07:12.490
will point out this
is a pro feature.

00:07:15.420 --> 00:07:17.850
So first, there's two
ways to do plugins.

00:07:17.850 --> 00:07:21.630
The first is native and
the second is Java.

00:07:21.630 --> 00:07:23.140
They're actually
interchangeable.

00:07:23.140 --> 00:07:24.870
I'm going to talk about Native
first, and then a little bit

00:07:24.870 --> 00:07:26.010
about Java.

00:07:26.010 --> 00:07:29.540
So here is an example of some
code that's like C code that's

00:07:29.540 --> 00:07:30.470
a minimal plugin.

00:07:30.470 --> 00:07:32.690
All it does return a value.

00:07:32.690 --> 00:07:36.680
All I need to do is put this C
file and build it into a .so

00:07:36.680 --> 00:07:40.400
file using the Android NDK, and
I need to place it in my

00:07:40.400 --> 00:07:41.630
project plugins folder,
which I'm going to

00:07:41.630 --> 00:07:43.870
show you in a minute.

00:07:43.870 --> 00:07:45.780
To call that code-- and that
code can be doing, obviously,

00:07:45.780 --> 00:07:47.140
a lot more complex things--

00:07:47.140 --> 00:07:51.200
all I need to do is, from my
game code, use interop

00:07:51.200 --> 00:07:55.510
services, annotate my function
definition, and

00:07:55.510 --> 00:07:57.370
then call my code.

00:07:57.370 --> 00:07:58.620
That simple.

00:08:00.760 --> 00:08:04.410
For Java plugins, it's a
little bit different.

00:08:04.410 --> 00:08:07.210
We use the JNI to interact
with your Java

00:08:07.210 --> 00:08:08.490
class that you build.

00:08:08.490 --> 00:08:11.700
You can build a .jar file using
Eclipse and the Android

00:08:11.700 --> 00:08:12.810
development toolkit.

00:08:12.810 --> 00:08:14.450
Again, you just build a .jar
that contains all your

00:08:14.450 --> 00:08:16.920
classes, make sure you check
the Is Library button, and

00:08:16.920 --> 00:08:20.200
then place that inside
your plugins folder.

00:08:20.200 --> 00:08:21.440
We provide--

00:08:21.440 --> 00:08:25.280
because you have to do some work
with the JNI to discover

00:08:25.280 --> 00:08:27.030
your methods and then
invoke them--

00:08:27.030 --> 00:08:29.220
we provide some wrapper classes,
the Android JNI and

00:08:29.220 --> 00:08:31.390
the Android JNI Helper.

00:08:31.390 --> 00:08:33.650
And on top of that, we build
another layer of helpers,

00:08:33.650 --> 00:08:36.990
which is Android Java Object and
Android Java Class, which

00:08:36.990 --> 00:08:41.159
allow you to not only automate
the whole process, but we also

00:08:41.159 --> 00:08:42.460
cache those lookups
so subsequent

00:08:42.460 --> 00:08:44.670
calls are a lot faster.

00:08:44.670 --> 00:08:47.520
So instead of showing you Java
code for the plugins, I'm

00:08:47.520 --> 00:08:50.060
actually just going to show
you an example here.

00:08:50.060 --> 00:08:51.850
And then Jarek's example
is going to show

00:08:51.850 --> 00:08:53.620
a lot of Java code.

00:08:53.620 --> 00:08:56.560
So on the slide, the two lines
that you see that are not

00:08:56.560 --> 00:09:01.360
commented out are what you need
to do to make a call to

00:09:01.360 --> 00:09:03.600
get this hash code string.

00:09:03.600 --> 00:09:05.710
All the commented out lines are
what you would do if you

00:09:05.710 --> 00:09:07.290
had to do that natively, so it
just kind of gives you an

00:09:07.290 --> 00:09:09.490
example of how much work we
save for you and how much

00:09:09.490 --> 00:09:10.994
prettier your code can look.

00:09:13.740 --> 00:09:15.020
That's about it with plugins.

00:09:15.020 --> 00:09:16.940
What you do with them
is up to you.

00:09:16.940 --> 00:09:17.980
Here's some pro tips.

00:09:17.980 --> 00:09:19.480
When you're dealing
with Android--

00:09:19.480 --> 00:09:22.340
and obviously, you have the
whole world of the native

00:09:22.340 --> 00:09:23.750
platform at your fingertips--

00:09:23.750 --> 00:09:26.510
you can do things like add
activities and do things with

00:09:26.510 --> 00:09:30.360
stuff that we don't normally
request permissions for.

00:09:30.360 --> 00:09:32.930
So in order to use that,
obviously, you need those in

00:09:32.930 --> 00:09:33.950
your Android manifest.

00:09:33.950 --> 00:09:36.720
Now, usually we generate one for
you, but you can take that

00:09:36.720 --> 00:09:39.400
and modify it, add whatever you
need, place that in your

00:09:39.400 --> 00:09:41.895
plugins folder, and just drop
it right next to it, and we

00:09:41.895 --> 00:09:43.370
will automatically use
that one instead.

00:09:43.370 --> 00:09:46.320
That way, you don't have to
rebuild it every time.

00:09:46.320 --> 00:09:48.160
One thing, whether it's for
yourself, whether it's for

00:09:48.160 --> 00:09:52.160
future users, customers,
whatever, teammates--

00:09:52.160 --> 00:09:54.910
you saw there was some work,
annotating your function

00:09:54.910 --> 00:09:57.700
definitions, making
the NJI calls.

00:09:57.700 --> 00:10:00.770
It's really easy to just drop in
another code file that does

00:10:00.770 --> 00:10:04.040
all that work for you and just
exposes the raw APIs you want

00:10:04.040 --> 00:10:05.680
your users of this--

00:10:05.680 --> 00:10:08.200
the plug-in-- to actually see.

00:10:08.200 --> 00:10:14.086
We are dealing with
managed code in

00:10:14.086 --> 00:10:17.190
your user game scripts.

00:10:17.190 --> 00:10:18.930
When you go down to the native
level, obviously you're

00:10:18.930 --> 00:10:20.690
native, and we have to marshal
that data-- any data that you

00:10:20.690 --> 00:10:22.400
want to deal with--
back and forth.

00:10:22.400 --> 00:10:26.540
So be aware that there is some
penalty costs to this, so you

00:10:26.540 --> 00:10:29.520
may have to weigh the benefits
of where you

00:10:29.520 --> 00:10:30.770
want to do the work.

00:10:33.130 --> 00:10:34.280
We're talking a lot about video

00:10:34.280 --> 00:10:35.240
today, for obvious reasons.

00:10:35.240 --> 00:10:37.410
I just want to point out some
function calls that we're

00:10:37.410 --> 00:10:39.210
going to use later, and
what they do, and

00:10:39.210 --> 00:10:40.840
explain a little bit.

00:10:40.840 --> 00:10:42.570
The first is on render image.

00:10:42.570 --> 00:10:46.660
This is a call back to you, so
you can basically react to

00:10:46.660 --> 00:10:48.600
whenever all the rendering
is finished

00:10:48.600 --> 00:10:50.380
for your render target.

00:10:50.380 --> 00:10:53.240
This means that everything is
done, and in this case,

00:10:53.240 --> 00:10:55.540
normally, what we would do is
Michael Bay up the screen like

00:10:55.540 --> 00:10:57.900
here, and add some bloom effects
and lens flares.

00:10:57.900 --> 00:11:01.160
All we need to do it for
to get a replay is

00:11:01.160 --> 00:11:03.510
just copy the frame.

00:11:03.510 --> 00:11:07.380
Similarly, on audio filter
read gives you a chance--

00:11:07.380 --> 00:11:10.470
every time we read a piece of
audio data that we're going to

00:11:10.470 --> 00:11:14.410
send into the audio processor,
you get a chance to customize.

00:11:14.410 --> 00:11:16.300
You can squelch it, make
yourself sound like Darth

00:11:16.300 --> 00:11:17.350
Vader, whatever.

00:11:17.350 --> 00:11:19.890
Again, in this case, all we're
doing is using that

00:11:19.890 --> 00:11:22.710
opportunity to copy that
data so that way, we

00:11:22.710 --> 00:11:25.900
can encode it later.

00:11:25.900 --> 00:11:28.150
When you're dealing with a
plugin that deals with your

00:11:28.150 --> 00:11:31.160
frame time, you're going to
want to be able to sync up

00:11:31.160 --> 00:11:35.950
your plugin work when you're
going to get the frame versus

00:11:35.950 --> 00:11:37.665
when Unity's rendering, because
you don't want to grab

00:11:37.665 --> 00:11:40.150
any frame data in the middle
of when it's writing to the

00:11:40.150 --> 00:11:41.060
frame buffer.

00:11:41.060 --> 00:11:45.400
Wait for end of frame is an
object you can yield to in

00:11:45.400 --> 00:11:48.370
your co-routines, and that will
make sure that when you

00:11:48.370 --> 00:11:50.820
come back and that code
executes, you're at the end of

00:11:50.820 --> 00:11:52.380
the current frame.

00:11:52.380 --> 00:11:54.190
And that just helps keep all
the syncing together.

00:11:56.790 --> 00:11:58.785
I'm going to switch over
to the editor now.

00:12:08.170 --> 00:12:08.990
Awesome.

00:12:08.990 --> 00:12:10.400
So this is Unity Editor.

00:12:10.400 --> 00:12:12.490
This is where you're going
to build your game.

00:12:12.490 --> 00:12:15.170
The first thing I'm going to
talk about is our project

00:12:15.170 --> 00:12:17.440
window right here
in the middle.

00:12:17.440 --> 00:12:20.820
The project window is literally
a mirror of what's

00:12:20.820 --> 00:12:21.660
actually on disk.

00:12:21.660 --> 00:12:23.680
It's all your models,
meshes, textures,

00:12:23.680 --> 00:12:26.020
sound files, et cetera.

00:12:26.020 --> 00:12:28.490
You can literally go and look
in on the file system, and

00:12:28.490 --> 00:12:30.740
it's going to look
exactly the same.

00:12:30.740 --> 00:12:32.560
You'll see here I have this
plugins directory.

00:12:32.560 --> 00:12:34.620
Plugins is one of our
reserve words.

00:12:34.620 --> 00:12:36.760
We look for that folder and then
treat things in there as

00:12:36.760 --> 00:12:38.010
plugins, so we know
how to build them

00:12:38.010 --> 00:12:40.380
into your final game.

00:12:40.380 --> 00:12:42.430
And then you just say,
I want an Android.

00:12:42.430 --> 00:12:43.480
And as you can see
here, we have a

00:12:43.480 --> 00:12:45.090
custom Android manifest.

00:12:45.090 --> 00:12:49.170
And then we have a bunch of
libs that Jarek's going to

00:12:49.170 --> 00:12:50.420
talk about later.

00:12:52.550 --> 00:12:54.820
So not everything in there is
going to end up in your final

00:12:54.820 --> 00:12:56.850
build of your game.

00:12:56.850 --> 00:12:59.240
On the left here, we have a
hierarchy window, which you

00:12:59.240 --> 00:13:01.280
can see here to the right
of my screen.

00:13:01.280 --> 00:13:04.380
This represents everything
that's represented in our

00:13:04.380 --> 00:13:05.030
drawing screen.

00:13:05.030 --> 00:13:06.270
So that's like my wall here.

00:13:06.270 --> 00:13:09.870
I can move it up and down and
break his game, and do all

00:13:09.870 --> 00:13:11.120
sorts of fun stuff.

00:13:13.720 --> 00:13:16.560
And here's where you build your
layout of your game and

00:13:16.560 --> 00:13:18.860
all that stuff.

00:13:18.860 --> 00:13:21.880
So we are a component based
engine, which means that

00:13:21.880 --> 00:13:24.310
everything in our game engine
is an object with components

00:13:24.310 --> 00:13:25.780
that add behavior.

00:13:25.780 --> 00:13:28.350
So over on the right, we have
the inspector window.

00:13:40.140 --> 00:13:43.510
The inspector window shows us
all the components on there.

00:13:43.510 --> 00:13:56.620
So you can see that currently,
I have the wall selected.

00:13:56.620 --> 00:13:59.660
We can see that it has a mesh,
it's a mesh render, it has

00:13:59.660 --> 00:14:02.410
some animation to it, it
has a box collider.

00:14:02.410 --> 00:14:04.580
And all these do is tell the
engine different things, and

00:14:04.580 --> 00:14:06.750
have different widgets where
we can customize how our

00:14:06.750 --> 00:14:09.770
engine reacts to
these objects.

00:14:09.770 --> 00:14:15.170
If I select our main camera,
we'll see that we have a bunch

00:14:15.170 --> 00:14:16.710
of scripts attached to it.

00:14:16.710 --> 00:14:19.390
Now, to get custom functionality
into your game,

00:14:19.390 --> 00:14:21.230
you create scripts.

00:14:21.230 --> 00:14:23.070
Our scripts, again, are
Mono, so it can be C#,

00:14:23.070 --> 00:14:25.670
JavaScript, or Boo.

00:14:25.670 --> 00:14:28.470
We ship with Mono Develop, so
you have everything you need

00:14:28.470 --> 00:14:31.590
to develop a game already
installed.

00:14:31.590 --> 00:14:33.300
Inside here, we have--

00:14:38.000 --> 00:14:39.600
it looks like I picked
the audio one.

00:14:39.600 --> 00:14:40.700
That's fine.

00:14:40.700 --> 00:14:42.970
Inside here, we have the
OnAudioFilterRead, and you can

00:14:42.970 --> 00:14:45.410
see all we're doing is checking
to make sure that

00:14:45.410 --> 00:14:48.370
recording is active and then
passing that data to a convert

00:14:48.370 --> 00:14:49.620
and write function.

00:14:54.220 --> 00:14:57.320
Similarly, we have a similar
function for video, where we

00:14:57.320 --> 00:15:04.850
have OnRenderImage, where all
we do is do a little bit of

00:15:04.850 --> 00:15:08.430
logging, and we are making a
copy of our frame buffer.

00:15:13.130 --> 00:15:15.150
I mentioned earlier to have
rapid iteration times.

00:15:15.150 --> 00:15:18.530
At any time, you can hit the
Play button located at the top

00:15:18.530 --> 00:15:21.140
of the screen there.

00:15:21.140 --> 00:15:23.100
And we go ahead and allow
you to play your

00:15:23.100 --> 00:15:27.260
game, and test it out.

00:15:27.260 --> 00:15:29.020
So I can test out the force of
the tennis balls that we're

00:15:29.020 --> 00:15:31.640
shooting out, et cetera,
et cetera.

00:15:34.650 --> 00:15:35.030
Awesome.

00:15:35.030 --> 00:15:37.940
So that's a little bit, so when
Jarek's in there later

00:15:37.940 --> 00:15:39.660
and showing screenshots, you
kind of know what you're

00:15:39.660 --> 00:15:40.380
looking at.

00:15:40.380 --> 00:15:42.500
I'm going to pass it back
to him now, so he

00:15:42.500 --> 00:15:45.170
can talk about, maybe.

00:16:02.170 --> 00:16:03.000
JAREK WILKIEWICZ: OK,
thank you, Corey.

00:16:03.000 --> 00:16:05.350
OK, so Corey took you through
the process of creating a game

00:16:05.350 --> 00:16:05.890
with Unity.

00:16:05.890 --> 00:16:08.180
And if you're a Unity developer,
then really, the

00:16:08.180 --> 00:16:12.480
only thing that might be new
for you is the way you

00:16:12.480 --> 00:16:14.080
integrate plugin capabilities.

00:16:14.080 --> 00:16:16.730
If you haven't tried Unity
yet, I encourage

00:16:16.730 --> 00:16:17.320
you to try it out.

00:16:17.320 --> 00:16:19.150
This is a lot of fun.

00:16:19.150 --> 00:16:23.140
Now, what I'll cover next is,
OK, now how can we integrate

00:16:23.140 --> 00:16:25.330
video upload and video playback
capability into the

00:16:25.330 --> 00:16:28.490
game to really take advantage
of the opportunity out there

00:16:28.490 --> 00:16:30.230
that we highlighted earlier?

00:16:30.230 --> 00:16:36.050
So first, let me switch
back to my demo.

00:16:39.010 --> 00:16:43.650
And the gameplay that I was
showing you earlier when I

00:16:43.650 --> 00:16:48.210
scored an amazing amount
of points, I'm actually

00:16:48.210 --> 00:16:49.060
ready to share it.

00:16:49.060 --> 00:16:50.550
I think it's really awesome.

00:16:50.550 --> 00:16:53.330
I'm just going to hit Upload.

00:16:53.330 --> 00:16:58.710
And at this point, we're
actually uploading the video

00:16:58.710 --> 00:17:01.260
to YouTube.

00:17:01.260 --> 00:17:04.550
I'm actually generating a
notification to show the

00:17:04.550 --> 00:17:06.450
status of the upload.

00:17:06.450 --> 00:17:10.130
While that is taking place, let
me walk you through what

00:17:10.130 --> 00:17:11.380
actually happens.

00:17:13.900 --> 00:17:19.819
So for this, we are using WebM
as a video container, VP8

00:17:19.819 --> 00:17:25.270
codec, and Vorbis codec for
video and audio respectively.

00:17:25.270 --> 00:17:28.119
Tomorrow morning, there's a
talk about VP8, so if you

00:17:28.119 --> 00:17:30.350
would like to learn more,
I highly encourage

00:17:30.350 --> 00:17:31.460
you to check it out.

00:17:31.460 --> 00:17:33.280
And we're also launching VP9.

00:17:33.280 --> 00:17:35.470
There's another talk about the
next generation of this

00:17:35.470 --> 00:17:36.840
technology.

00:17:36.840 --> 00:17:39.620
But let's just take a
step by step look at

00:17:39.620 --> 00:17:41.060
what is involved here.

00:17:41.060 --> 00:17:45.190
So we started with this awesome
Unity game, and then

00:17:45.190 --> 00:17:48.020
what we actually need to get out
of the game engine is the

00:17:48.020 --> 00:17:50.830
audio and the video frames.

00:17:50.830 --> 00:17:54.240
So this is what is illustrated
on this diagram.

00:17:54.240 --> 00:17:56.950
We're getting the video frames,
passing them onto the

00:17:56.950 --> 00:17:58.780
VP8 encoder.

00:17:58.780 --> 00:18:01.250
We're getting the audio frames,
passing through the

00:18:01.250 --> 00:18:04.450
Vorbis encoder, and then use the
WebM container in order to

00:18:04.450 --> 00:18:07.020
create a video file for us.

00:18:07.020 --> 00:18:10.660
Once that file is created, we
use the YouTube data API.

00:18:10.660 --> 00:18:14.380
In this case, we use the YouTube
data API version 3 to

00:18:14.380 --> 00:18:18.620
upload the resulting
video to YouTube.

00:18:18.620 --> 00:18:20.930
The YouTube data
API is RESTful.

00:18:20.930 --> 00:18:22.550
It's fairly straightforward
to use.

00:18:22.550 --> 00:18:26.290
For Android, we use the Java
client libraries, so you don't

00:18:26.290 --> 00:18:30.580
actually have to write
any HTTP, HTML, HTTP

00:18:30.580 --> 00:18:34.310
JSON parsing code.

00:18:34.310 --> 00:18:39.230
Now, in our example, we built
a Unity plugin in order to

00:18:39.230 --> 00:18:43.130
take care of the video
upload from Unity

00:18:43.130 --> 00:18:46.160
and the video encoding.

00:18:46.160 --> 00:18:48.560
Couple of hints while developing
the plugin.

00:18:48.560 --> 00:18:52.030
Corey mentioned the Android
manifest is something that

00:18:52.030 --> 00:18:54.310
Unity generates by
default, since it

00:18:54.310 --> 00:18:56.590
actually creates the APK.

00:18:56.590 --> 00:18:59.800
However, if you're building any
additional activities in

00:18:59.800 --> 00:19:02.710
your code, or need additional
permissions, you need to merge

00:19:02.710 --> 00:19:06.190
that into the manifest
created by Unity.

00:19:06.190 --> 00:19:09.130
So the way to do that is, first
time you build a game in

00:19:09.130 --> 00:19:12.560
temp staging area, you will
get an Android manifest.

00:19:12.560 --> 00:19:16.000
And then you edit that and
copy that over into the

00:19:16.000 --> 00:19:18.240
plugins directory, and
you're all set.

00:19:18.240 --> 00:19:21.140
Another thing to pay attention
to is that plugins are

00:19:21.140 --> 00:19:27.050
actually required to be built as
Java Android libraries, so

00:19:27.050 --> 00:19:30.140
you actually need to be careful
about resource merge.

00:19:30.140 --> 00:19:32.900
And really, the only thing that
is somewhat inconvenient

00:19:32.900 --> 00:19:36.370
is that if you're used to the ID
base lookup up in your code

00:19:36.370 --> 00:19:41.560
directly, inside of the plugin
while you're running in Unity,

00:19:41.560 --> 00:19:44.440
you should actually use the
functional way of looking up

00:19:44.440 --> 00:19:47.630
or the procedural way of looking
up the resources.

00:19:47.630 --> 00:19:52.070
Other than that, it's just
regular Android development.

00:19:52.070 --> 00:19:57.490
Now, Corey mentioned some of the
methods involved in video

00:19:57.490 --> 00:20:00.650
and audio capture, so I'm just
going to quickly go through

00:20:00.650 --> 00:20:02.280
what we did for this demo.

00:20:02.280 --> 00:20:06.370
So we actually attach two
scripts to the camera--

00:20:06.370 --> 00:20:08.700
one script responsible for
video capture, the other

00:20:08.700 --> 00:20:12.580
script responsible for
audio capture.

00:20:12.580 --> 00:20:14.200
So let's start with the audio.

00:20:14.200 --> 00:20:19.010
We are actually capturing the
audio at 24 kHz frequency, so

00:20:19.010 --> 00:20:22.710
this is the raw PCM data that
you're going to be receiving

00:20:22.710 --> 00:20:24.560
in your application.

00:20:24.560 --> 00:20:26.030
You can actually configure
that using

00:20:26.030 --> 00:20:27.880
AudioSettings.outputSampleRate.

00:20:27.880 --> 00:20:30.750
So this is something that you
can configure in Unity.

00:20:30.750 --> 00:20:32.870
And for video, I'm just
using 10 frames per

00:20:32.870 --> 00:20:34.510
second right now.

00:20:34.510 --> 00:20:36.590
Unity has a nifty feature.

00:20:36.590 --> 00:20:40.200
You can actually set the replay
frame rate, and this is

00:20:40.200 --> 00:20:42.880
different than the actual target
frame rate at which

00:20:42.880 --> 00:20:45.310
your game runs, precisely
for this use case.

00:20:45.310 --> 00:20:47.780
So if you want to record a video
of the game, you can

00:20:47.780 --> 00:20:50.460
actually set the capture
framework to whatever makes

00:20:50.460 --> 00:20:52.970
sense, and you do operate
within the number of

00:20:52.970 --> 00:20:56.660
constraints that we'll touch
upon a little later.

00:20:56.660 --> 00:21:00.970
So for audio recording, and
Corey highlighted that when he

00:21:00.970 --> 00:21:03.700
pulled up MonoDevelop to show
you a snippet of the code.

00:21:03.700 --> 00:21:05.230
We use AudioFilterRead.

00:21:05.230 --> 00:21:08.950
So this is the callback that
is invoked by Unity at the

00:21:08.950 --> 00:21:11.820
frequency that you define using
the mechanics from the

00:21:11.820 --> 00:21:12.860
previous slide.

00:21:12.860 --> 00:21:16.590
And what's passed to you is
really raw PCM audio, and this

00:21:16.590 --> 00:21:19.520
is what we'll pass on
to the encoder.

00:21:19.520 --> 00:21:22.870
Then for video--

00:21:22.870 --> 00:21:25.400
and this is, again, something
that Corey highlighted--

00:21:25.400 --> 00:21:28.850
the continuation here, yield
return new wait for end of

00:21:28.850 --> 00:21:33.260
frame, that allows you to be
notified when frame rendering

00:21:33.260 --> 00:21:35.950
is fully completed, at which
point you can actually turn

00:21:35.950 --> 00:21:38.090
around and read the complete
frame back.

00:21:38.090 --> 00:21:40.000
And there's a number of
approaches to this.

00:21:42.750 --> 00:21:44.520
We experimented with
a few of them.

00:21:44.520 --> 00:21:46.210
They all have different
tradeoffs.

00:21:46.210 --> 00:21:47.510
Here's one.

00:21:47.510 --> 00:21:50.590
So this is the approach where
I'm actually using texture 2D

00:21:50.590 --> 00:21:56.000
to read back pixels at a
resolution defined by you, so

00:21:56.000 --> 00:22:01.910
you can actually generate a
video at a lower resolution

00:22:01.910 --> 00:22:03.480
than the original.

00:22:03.480 --> 00:22:05.250
And this is, again, if you
want the video file to be

00:22:05.250 --> 00:22:07.920
relatively small, so you
can be shared from

00:22:07.920 --> 00:22:09.520
mobile devices quickly.

00:22:09.520 --> 00:22:15.450
You can actually read the frames
at smaller resolution.

00:22:15.450 --> 00:22:19.020
Another approach is to use the
glReadPixels, so you can read

00:22:19.020 --> 00:22:22.660
it directly from the frame
buffer using the open GL

00:22:22.660 --> 00:22:23.550
glReadPixels.

00:22:23.550 --> 00:22:27.140
And this is an example of
another implementation that I

00:22:27.140 --> 00:22:29.210
did using Java.

00:22:29.210 --> 00:22:32.700
So that is actually invoked from
within the Java plug-in

00:22:32.700 --> 00:22:37.240
to obtain the frame buffer.

00:22:37.240 --> 00:22:40.130
So that's the capture step.

00:22:40.130 --> 00:22:45.400
Once the frames are captured,
so the raw audio, raw video,

00:22:45.400 --> 00:22:46.870
we need to encode it.

00:22:46.870 --> 00:22:51.460
And for that, we're actually
using WebM and VP8

00:22:51.460 --> 00:22:54.440
plus Vorbis for audio.

00:22:54.440 --> 00:22:56.505
So let's talk a little bit
about how that is done.

00:22:56.505 --> 00:23:00.430
And again, just referring back
to our reference diagram,

00:23:00.430 --> 00:23:03.590
we're actually at that stage
right there in the middle

00:23:03.590 --> 00:23:06.820
where we obtain the raw frames,
we are passing it down

00:23:06.820 --> 00:23:09.170
through the encoder.

00:23:09.170 --> 00:23:16.060
So one thing that is very useful
on Android is our WebM

00:23:16.060 --> 00:23:21.890
engineers actually have created
JNI bindings for the

00:23:21.890 --> 00:23:26.810
encoder, both the Vorbis encoder
as well as the VP8

00:23:26.810 --> 00:23:30.695
encoder, and you can fetch that
from code.google.com.

00:23:33.698 --> 00:23:36.400
That is a JNI wrapper.

00:23:36.400 --> 00:23:39.760
It has dependencies on a few of
the native libraries, but

00:23:39.760 --> 00:23:44.170
this is what actually provides
you a really nice performance,

00:23:44.170 --> 00:23:47.730
and this is what we used
in our application.

00:23:47.730 --> 00:23:50.830
So a couple of things to
consider when you're actually

00:23:50.830 --> 00:23:51.750
using this.

00:23:51.750 --> 00:23:55.585
So think of this as a kind of
nice object-oriented way to do

00:23:55.585 --> 00:23:56.420
a video encoding.

00:23:56.420 --> 00:23:59.530
So if you're not comfortable
writing C code, but you're an

00:23:59.530 --> 00:24:01.810
Android developer, you know
Java, well, now you can encode

00:24:01.810 --> 00:24:04.720
video, and you can do
that very easily.

00:24:04.720 --> 00:24:07.870
So let's just walk through the
basic building blocks.

00:24:07.870 --> 00:24:10.190
Audio encoder, there's a
couple of classes-- the

00:24:10.190 --> 00:24:13.460
encoder configuration and the
actual encoder, a video

00:24:13.460 --> 00:24:16.810
recorder, again, the
configuration, and the actual

00:24:16.810 --> 00:24:21.390
encoder, and then the WebM
maxing capabilities so that

00:24:21.390 --> 00:24:24.500
you can write the compressed
audio and video frames to a

00:24:24.500 --> 00:24:26.440
container, and then end
up with a single file.

00:24:29.290 --> 00:24:33.580
And here's an example of how
this looks in practice.

00:24:33.580 --> 00:24:36.020
So we start with the byte array,
which is basically the

00:24:36.020 --> 00:24:41.590
PCM audio that was given to us
by Unity as a part of the

00:24:41.590 --> 00:24:46.590
script attached to a camera, and
then similarly for video,

00:24:46.590 --> 00:24:49.050
we read that video from
the frame buffer.

00:24:49.050 --> 00:24:50.910
And then we construct--

00:24:50.910 --> 00:24:54.220
ultimately, what we want is
an audio frame and encoded

00:24:54.220 --> 00:24:57.960
packet, which basically
represents the encoded audio

00:24:57.960 --> 00:25:00.140
and the encoded video.

00:25:00.140 --> 00:25:06.460
And the way that is obtained
is we actually pass the raw

00:25:06.460 --> 00:25:11.080
audio bytes to the Vorbis
encoder, pass the raw video

00:25:11.080 --> 00:25:18.800
bytes to the VPN encoder, and
then we use the maxer to save

00:25:18.800 --> 00:25:23.330
the audio and the video frame.

00:25:23.330 --> 00:25:25.980
That takes care also of
synchronization, so you don't

00:25:25.980 --> 00:25:28.900
really have to do any
work in that area.

00:25:28.900 --> 00:25:31.990
And what you get back
is a video file.

00:25:31.990 --> 00:25:36.490
So here's an overview,
again, of the objects

00:25:36.490 --> 00:25:38.310
that we just discussed.

00:25:38.310 --> 00:25:41.260
So encoder configurations, both
for video and audio, the

00:25:41.260 --> 00:25:44.710
actual encoders, the tracks
representing the audio and the

00:25:44.710 --> 00:25:48.420
video part of the WebM
file, and the maxer.

00:25:48.420 --> 00:25:51.450
So this is kind of the way I see
it as an object-oriented

00:25:51.450 --> 00:25:53.840
way of doing video encoding.

00:25:53.840 --> 00:25:55.800
And I really like it, because
I think it's very

00:25:55.800 --> 00:25:56.860
approachable.

00:25:56.860 --> 00:25:59.380
So for those of you that would
like to do a little bit more

00:25:59.380 --> 00:26:03.680
work in this area, but have been
intimidated by having to

00:26:03.680 --> 00:26:07.330
deal with a bunch of native code
and large libraries, this

00:26:07.330 --> 00:26:11.870
provides an abstraction that
is very easy to use.

00:26:11.870 --> 00:26:16.570
So once we have the video and
audio, the only thing

00:26:16.570 --> 00:26:18.770
remaining is the
actual upload.

00:26:18.770 --> 00:26:21.080
And the way we do that is using
the YouTube data APIs.

00:26:21.080 --> 00:26:24.770
I'm using the YouTube
data API version 3.

00:26:24.770 --> 00:26:26.960
So in order to access that,
you need to register your

00:26:26.960 --> 00:26:29.070
project in the developer
console.

00:26:29.070 --> 00:26:32.350
One thing to note is we are
uploading the video into the

00:26:32.350 --> 00:26:33.430
user's account.

00:26:33.430 --> 00:26:36.710
Therefore, we must obtain a note
of permission from the

00:26:36.710 --> 00:26:41.210
user for our application to
act on his or her behalf.

00:26:41.210 --> 00:26:43.040
And the way that takes place,
there's a little

00:26:43.040 --> 00:26:44.710
bit of magic involved.

00:26:44.710 --> 00:26:46.400
It actually works very nicely.

00:26:46.400 --> 00:26:48.520
The only thing you need to know
about is that when you

00:26:48.520 --> 00:26:52.350
register your project in the
developer console, you need to

00:26:52.350 --> 00:26:57.180
supply a fingerprint for the
key that you're going to be

00:26:57.180 --> 00:27:00.800
signing the application with,
and you have to tell Unity to

00:27:00.800 --> 00:27:05.160
use a specific key storer or a
specific key to sign your APK.

00:27:05.160 --> 00:27:06.440
And once you do that,
everything

00:27:06.440 --> 00:27:08.090
just works like magic.

00:27:08.090 --> 00:27:12.580
So we know on the server sides,
our API back end notes

00:27:12.580 --> 00:27:14.430
that hey, this is your
application that is generating

00:27:14.430 --> 00:27:16.960
these requests, so you don't
actually have to change any

00:27:16.960 --> 00:27:18.110
code for this.

00:27:18.110 --> 00:27:21.680
And then the upload process,
when I was showing you a

00:27:21.680 --> 00:27:24.940
couple of hints, don't
block the user

00:27:24.940 --> 00:27:26.280
waiting for the upload.

00:27:26.280 --> 00:27:30.130
You can just do that as a
service, and then use a

00:27:30.130 --> 00:27:32.880
notification to indicate
the progress.

00:27:32.880 --> 00:27:35.280
And then, use resumable uploads,
because if you lose

00:27:35.280 --> 00:27:38.670
connectivity, which is, in
fact, very likely at

00:27:38.670 --> 00:27:39.700
[INAUDIBLE]

00:27:39.700 --> 00:27:44.370
right now, this should actually
resume automatically.

00:27:44.370 --> 00:27:47.190
So here's one video that I
created a little earlier.

00:27:47.190 --> 00:27:48.556
Let's just play it.

00:28:10.990 --> 00:28:14.110
I'm going to switch to
the mobile device.

00:28:17.210 --> 00:28:23.060
So remember the notification
that I was popping up as a

00:28:23.060 --> 00:28:29.710
part of the video upload right
now indicates that my video

00:28:29.710 --> 00:28:31.600
has been successfully
uploaded.

00:28:31.600 --> 00:28:33.110
Watch the video on YouTube.

00:28:33.110 --> 00:28:35.140
So when I click it--

00:28:35.140 --> 00:28:36.520
let me just select it--

00:28:42.540 --> 00:28:46.310
I can see the gameplay
right in my game.

00:28:49.900 --> 00:28:53.770
And I'm going to tell you a
little more about how that is

00:28:53.770 --> 00:28:56.800
implemented as well.

00:28:56.800 --> 00:29:00.820
But before that, just a quick
note on authorization.

00:29:00.820 --> 00:29:06.540
I mentioned to you that we use
OAuth 2.0 in order to upload

00:29:06.540 --> 00:29:08.790
the video on behalf
of the user.

00:29:08.790 --> 00:29:12.470
And to implement that in your
Android application, you can

00:29:12.470 --> 00:29:14.750
use Google Play services.

00:29:14.750 --> 00:29:16.440
So we're using GoogleAuthUtil.

00:29:16.440 --> 00:29:19.460
Makes it very straightforward
to implement the old flow.

00:29:19.460 --> 00:29:23.270
And really, the only thing you
need is to remember about the

00:29:23.270 --> 00:29:26.490
scope that you're going to be
requesting from the user.

00:29:26.490 --> 00:29:30.180
So in our case, I'm using
YouTube Read Only, because I

00:29:30.180 --> 00:29:33.370
need that in order to check
on the upload status.

00:29:33.370 --> 00:29:36.350
And I'm using YouTube Upload,
which is going to grant my

00:29:36.350 --> 00:29:39.890
application the right
to upload videos.

00:29:39.890 --> 00:29:44.800
And that is reflected here by
this popup that is generated

00:29:44.800 --> 00:29:47.415
by the Auth for Google
Play Services.

00:29:51.450 --> 00:29:54.290
And then I was just showing
you a while ago how the

00:29:54.290 --> 00:29:56.930
playback in application
playback works.

00:29:56.930 --> 00:30:02.070
So the reason why that is useful
is earlier today, you

00:30:02.070 --> 00:30:07.840
have learned about the new
capabilities that will be

00:30:07.840 --> 00:30:09.990
launching in the gaming area.

00:30:09.990 --> 00:30:12.820
So personally, I think
leaderboards and achievements

00:30:12.820 --> 00:30:16.890
are very cool, but I want
a video to prove it.

00:30:16.890 --> 00:30:20.030
So this is one use case that
you can implement is if you

00:30:20.030 --> 00:30:22.880
have the upload capability, you
could associate or keep

00:30:22.880 --> 00:30:26.400
track of these achievements and
leaders, and show the most

00:30:26.400 --> 00:30:32.000
interesting footage from your
users in the app itself.

00:30:32.000 --> 00:30:36.910
And for that, you can use the
YouTube Android Player API.

00:30:36.910 --> 00:30:40.340
So this is an API that we
launched a few months back,

00:30:40.340 --> 00:30:43.760
and as I was showing you
earlier, it has the capability

00:30:43.760 --> 00:30:47.380
of high quality in-app
video playback.

00:30:47.380 --> 00:30:51.040
There's very little work that
is required in making that

00:30:51.040 --> 00:30:53.530
happen in your application.

00:30:53.530 --> 00:30:56.800
Really, all you need to do is
drop in this library here,

00:30:56.800 --> 00:30:58.930
YouTube Android Player API.

00:30:58.930 --> 00:31:02.310
This is a small client library
that actually relies on our

00:31:02.310 --> 00:31:05.130
YouTube app to do the actual
video playback.

00:31:05.130 --> 00:31:06.160
So it's very robust.

00:31:06.160 --> 00:31:09.070
It has all the capabilities that
you see in the YouTube

00:31:09.070 --> 00:31:11.940
app, and you can make that
available inside of your own

00:31:11.940 --> 00:31:17.480
app that is running inside of a
Unity game using the plugin

00:31:17.480 --> 00:31:18.560
capability.

00:31:18.560 --> 00:31:20.870
A couple of things to note.

00:31:20.870 --> 00:31:23.970
The YouTube Android player API
requires a developer key that

00:31:23.970 --> 00:31:28.730
is slightly different than the
dev key that we used for the

00:31:28.730 --> 00:31:31.080
old uploads.

00:31:31.080 --> 00:31:35.980
And then we may prompt you to
actually upgrade the YouTube

00:31:35.980 --> 00:31:38.380
app on the user's device.

00:31:38.380 --> 00:31:44.040
So if the app is out of date,
because the user hasn't

00:31:44.040 --> 00:31:47.010
updated it, or it's not set
for automatic updates, we

00:31:47.010 --> 00:31:48.880
actually generate this
error service

00:31:48.880 --> 00:31:50.340
version update required.

00:31:50.340 --> 00:31:53.050
Typically, that doesn't happen,
but this is how we can

00:31:53.050 --> 00:31:56.410
make sure that the latest
capabilities or bug fixes are

00:31:56.410 --> 00:32:00.950
actually made available to the
user when they try to use our

00:32:00.950 --> 00:32:03.580
YouTube API to do video
playback inside

00:32:03.580 --> 00:32:05.910
of your Unity game.

00:32:05.910 --> 00:32:09.090
And then our transcoding
pipeline takes a little while,

00:32:09.090 --> 00:32:11.110
especially if it's high
quality video, and we

00:32:11.110 --> 00:32:13.500
transcode it to a number
of different formats.

00:32:13.500 --> 00:32:15.960
YouTube data API v3 has
this nice capability.

00:32:15.960 --> 00:32:18.910
You can actually check the
processing progress in order

00:32:18.910 --> 00:32:22.540
to find out, is this video ready
to be shown on all the

00:32:22.540 --> 00:32:24.170
platforms that YouTube
supports?

00:32:24.170 --> 00:32:27.200
So I highly encourage you to
actually do that before you

00:32:27.200 --> 00:32:28.550
do, say, software sharing.

00:32:28.550 --> 00:32:33.900
So I was requesting G+
permission in my auth flow a

00:32:33.900 --> 00:32:36.680
few slides earlier, and the use
case there is, once I'm

00:32:36.680 --> 00:32:37.940
done with the uploading,
I want to

00:32:37.940 --> 00:32:39.200
share it with the world.

00:32:39.200 --> 00:32:42.520
But share it only once
processing progress indicates

00:32:42.520 --> 00:32:44.650
that the video has been
completely processed, because

00:32:44.650 --> 00:32:47.080
that means it will play on every
single type of device

00:32:47.080 --> 00:32:49.980
that YouTube supports, all the
transcodes have completed.

00:32:52.730 --> 00:32:53.820
So a few links.

00:32:53.820 --> 00:32:55.780
If you'd like to learn more
about our APIs, go to

00:32:55.780 --> 00:32:57.620
youtube.com/dev.

00:32:57.620 --> 00:33:00.950
This is the link to the
repository that hosts all the

00:33:00.950 --> 00:33:07.360
JNI wrappers for WebM, VP8,
Vorbis, and libyuv, which

00:33:07.360 --> 00:33:10.690
allows you to do RGB to YUV
conversion, which is, again, a

00:33:10.690 --> 00:33:13.200
little detail that we
don't get into too

00:33:13.200 --> 00:33:15.550
much during the stock.

00:33:15.550 --> 00:33:18.990
And then we are working on
polishing up this demo app,

00:33:18.990 --> 00:33:21.290
and then we're planning to open
source it as well, so you

00:33:21.290 --> 00:33:24.220
can try it out yourself.

00:33:24.220 --> 00:33:28.350
So we hope that this capability

00:33:28.350 --> 00:33:30.730
will excite your users.

00:33:30.730 --> 00:33:33.670
Now it's 2013, so I figured
someone playing a tablet game

00:33:33.670 --> 00:33:37.440
would be an appropriate way to
conclude this presentation.

00:33:37.440 --> 00:33:39.840
And if you guys have any
questions, please

00:33:39.840 --> 00:33:40.730
come up to the mic.

00:33:40.730 --> 00:33:41.980
We have a few minutes left.

00:33:49.000 --> 00:33:51.860
AUDIENCE: So this would do a
record as the user is playing

00:33:51.860 --> 00:33:52.560
the game, right?

00:33:52.560 --> 00:33:57.660
So what's the impact on the
performance that you expect on

00:33:57.660 --> 00:33:58.610
the device?

00:33:58.610 --> 00:34:01.055
Because gaming already consumes
significant horse

00:34:01.055 --> 00:34:03.170
power on the platform.

00:34:03.170 --> 00:34:07.240
And then if you're going to
record at the same time.

00:34:07.240 --> 00:34:09.100
JAREK WILKIEWICZ: So the
question is, what is the

00:34:09.100 --> 00:34:11.940
performance impact of
this capability?

00:34:11.940 --> 00:34:17.100
Actually, the way this demo
app is implimented, we are

00:34:17.100 --> 00:34:21.800
using attract where the gameplay
recording is not

00:34:21.800 --> 00:34:24.770
happening at the same
time as the game.

00:34:24.770 --> 00:34:32.030
So I am actually doing a
replay using the Unity

00:34:32.030 --> 00:34:34.330
capability where you can
actually tell it to render

00:34:34.330 --> 00:34:36.540
frames at certain speeds.

00:34:36.540 --> 00:34:42.000
So there is no impact while
you play the game.

00:34:42.000 --> 00:34:45.120
However, when you're actually
ready to share it, depending

00:34:45.120 --> 00:34:50.600
on the device and depending on
how you configured it-- for

00:34:50.600 --> 00:34:54.860
example, if you want HD, if you
want high quality video,

00:34:54.860 --> 00:34:57.210
because those are parameters you
can pass to the encoder--

00:34:57.210 --> 00:35:00.700
then the actual rendering of the
frames may or may not keep

00:35:00.700 --> 00:35:03.300
up with the frame rate
that you get when

00:35:03.300 --> 00:35:04.980
you're playing the game.

00:35:04.980 --> 00:35:09.200
So there's an additional step
that involves basically

00:35:09.200 --> 00:35:12.860
rendering the frames one by one,
and at low resolution,

00:35:12.860 --> 00:35:14.160
low frame rate.

00:35:14.160 --> 00:35:19.820
Right now, because I'm using a
pretty expensive way to fetch

00:35:19.820 --> 00:35:22.800
the frames from the frame
buffer, at low resolution, I

00:35:22.800 --> 00:35:25.350
can keep up with the frame
rate of the game.

00:35:25.350 --> 00:35:26.540
At high resolutions, I can't.

00:35:26.540 --> 00:35:30.520
However, that doesn't really
impact the gameplay, but it

00:35:30.520 --> 00:35:32.230
impacts the replay.

00:35:32.230 --> 00:35:33.730
Ideally, what we would want--

00:35:33.730 --> 00:35:37.710
and we have a couple of partners
that do that for

00:35:37.710 --> 00:35:38.900
other platforms--

00:35:38.900 --> 00:35:41.920
in fact, there's one in the
sandbox, and one of them spoke

00:35:41.920 --> 00:35:44.320
earlier today at the--

00:35:44.320 --> 00:35:47.090
as you see, raising his hand.

00:35:47.090 --> 00:35:48.980
So there's other approaches
to that.

00:35:48.980 --> 00:35:53.670
They don't currently work
on Android, so that's an

00:35:53.670 --> 00:35:55.720
alternative that can be used.

00:35:55.720 --> 00:35:59.760
Hopefully we'll get to that same
level of performance, but

00:35:59.760 --> 00:36:02.550
the impact right now is zero,
because the step of rendering

00:36:02.550 --> 00:36:08.290
the gameplay is distinct
from the play.

00:36:08.290 --> 00:36:12.250
AUDIENCE: So you also said that
VP8 and going to VP9,

00:36:12.250 --> 00:36:16.220
again, does the developer kind
of pick the codec there?

00:36:16.220 --> 00:36:20.250
If it's going to be VP8, VP9, or
is it YouTube that decides?

00:36:20.250 --> 00:36:21.240
JAREK WILKIEWICZ: Yes.

00:36:21.240 --> 00:36:24.450
So the question is, what
does it mean now that

00:36:24.450 --> 00:36:26.000
we have VP9, VP8?

00:36:26.000 --> 00:36:27.710
So the good news is, you
don't really care.

00:36:27.710 --> 00:36:32.620
So frankly, as long as you give
us the content in any of

00:36:32.620 --> 00:36:35.270
the formats that we support
for YouTube ingestion, we

00:36:35.270 --> 00:36:37.210
actually turn around and
transcode it and everything

00:36:37.210 --> 00:36:39.850
imaginable that is required
by all the

00:36:39.850 --> 00:36:41.590
devices that we support.

00:36:41.590 --> 00:36:45.450
So we chose VP8, and we're going
to get into that in more

00:36:45.450 --> 00:36:48.820
details tomorrow is because this
is open source royalty

00:36:48.820 --> 00:36:49.380
free codec.

00:36:49.380 --> 00:36:51.480
You don't have to pay
anybody any money.

00:36:51.480 --> 00:36:52.990
You don't have to pay
any royalties.

00:36:52.990 --> 00:36:54.170
You can do whatever
you want with it.

00:36:54.170 --> 00:36:58.405
And it's a very liberal
license.

00:36:58.405 --> 00:36:59.750
And it's open source.

00:36:59.750 --> 00:37:04.550
So we find that this is a good
fit for these types of

00:37:04.550 --> 00:37:05.560
applications.

00:37:05.560 --> 00:37:09.390
The way YouTube works is, once
you upload the video, it will

00:37:09.390 --> 00:37:12.130
actually take care of
transcoding into the formats

00:37:12.130 --> 00:37:13.590
that are supported by
different devices.

00:37:13.590 --> 00:37:17.590
So if a target device for
playback only supports H.264,

00:37:17.590 --> 00:37:19.500
we'll use that transcode.

00:37:19.500 --> 00:37:22.580
Then our Android player API,
which I demonstrated earlier

00:37:22.580 --> 00:37:25.190
for playback, uses one
of these transcodes.

00:37:25.190 --> 00:37:28.320
So it really is totally
transparent to the developer.

00:37:28.320 --> 00:37:30.740
The only thing you have to know
is all these codecs have

00:37:30.740 --> 00:37:31.770
specific requirements.

00:37:31.770 --> 00:37:35.060
For example, VP8 requires a YUV

00:37:35.060 --> 00:37:36.630
representation of the data.

00:37:36.630 --> 00:37:39.000
That's why we have libyuv also
wrapped, so you can pass the

00:37:39.000 --> 00:37:42.730
RGB data that you get from the
frame wrapper, convert that to

00:37:42.730 --> 00:37:44.410
YUV, and pass that into VP8.

00:37:44.410 --> 00:37:46.360
So there's a little bit of
knowledge that is required,

00:37:46.360 --> 00:37:48.450
but I would say it's
pretty minimal.

00:37:48.450 --> 00:37:50.580
AUDIENCE: So you answered part
of my question with respect to

00:37:50.580 --> 00:37:52.470
the transcoding.

00:37:52.470 --> 00:37:58.140
Now, for recording, I assume
it would also be H.264?

00:37:58.140 --> 00:38:01.170
Because most of the devices,
they don't necessarily have

00:38:01.170 --> 00:38:04.245
support for VP8 HD record.

00:38:04.245 --> 00:38:04.610
JAREK WILKIEWICZ: Yeah.

00:38:04.610 --> 00:38:07.470
So we are using a software
encoder right now.

00:38:07.470 --> 00:38:13.030
So the way this application is
built is the actual VP8 codec,

00:38:13.030 --> 00:38:18.420
Vorbis codec WebM container is
shipped as a native library

00:38:18.420 --> 00:38:22.420
wrapped through JNI and packaged
in the Android plugin

00:38:22.420 --> 00:38:24.220
that is integrated
with the Unity.

00:38:24.220 --> 00:38:28.690
So everything required to render
the video is included

00:38:28.690 --> 00:38:29.910
in the game itself.

00:38:29.910 --> 00:38:33.490
Android has the capability to
actually use the underlying

00:38:33.490 --> 00:38:36.640
hardware encoder, and that
is typically H264.

00:38:36.640 --> 00:38:39.730
Though, and again, this is
something that tomorrow's

00:38:39.730 --> 00:38:42.430
session is going to go into in
more detail, the world there

00:38:42.430 --> 00:38:46.960
is also becoming more
attractive.

00:38:46.960 --> 00:38:51.470
But the nice thing about this
approach is there's no

00:38:51.470 --> 00:38:54.020
dependency on the specific
device or a specific version

00:38:54.020 --> 00:38:58.110
of Android, because it's just C
code that you compile using

00:38:58.110 --> 00:39:01.640
NDK, and then the
JNI wrappers.

00:39:01.640 --> 00:39:04.236
And it's also very small.

00:39:04.236 --> 00:39:05.486
AUDIENCE: Thank you.

00:39:09.170 --> 00:39:10.095
JAREK WILKIEWICZ: All
right, so we have 20

00:39:10.095 --> 00:39:11.345
more seconds left.

00:39:17.770 --> 00:39:21.470
If there's one more question.

00:39:21.470 --> 00:39:22.310
AUDIENCE: From the beginning.

00:39:22.310 --> 00:39:26.510
I just want to ask, can we
record the normal Java screen?

00:39:26.510 --> 00:39:33.100
I mean, the application screen
in Android, without

00:39:33.100 --> 00:39:33.790
[INAUDIBLE]?

00:39:33.790 --> 00:39:34.060
JAREK WILKIEWICZ: Yeah.

00:39:34.060 --> 00:39:36.970
Yeah, so the question is,
can you record the

00:39:36.970 --> 00:39:38.960
application's screen?

00:39:38.960 --> 00:39:43.030
And I believe the answer is,
for an arbitrary app, the

00:39:43.030 --> 00:39:43.670
answer is no.

00:39:43.670 --> 00:39:46.010
And typically, it's because
of sandboxing

00:39:46.010 --> 00:39:47.650
requirements and whatnot.

00:39:47.650 --> 00:39:50.930
So that's why this is something
that has to be built

00:39:50.930 --> 00:39:53.190
into the application itself.

00:39:53.190 --> 00:39:56.110
And this is really how
for PC games--

00:39:56.110 --> 00:39:58.470
AUDIENCE: What are these
mechanisms for [INAUDIBLE]?

00:39:58.470 --> 00:39:58.750
JAREK WILKIEWICZ: Yeah.

00:39:58.750 --> 00:40:01.410
So in this session, we actually
described how that

00:40:01.410 --> 00:40:02.770
can be done with Unity.

00:40:02.770 --> 00:40:06.150
And the mechanism for that is
Unity has integration points

00:40:06.150 --> 00:40:09.410
to obtain the raw audio and
the raw video frames.

00:40:09.410 --> 00:40:12.690
And this is what is actually
passed into our encoder and

00:40:12.690 --> 00:40:14.150
uploaded to YouTube.

00:40:14.150 --> 00:40:15.400
But it's application specific.

00:40:15.400 --> 00:40:18.390
So Unity has this capability.

00:40:18.390 --> 00:40:22.620
It relies on the
GL capability.

00:40:22.620 --> 00:40:23.910
So this is something that
is app specific.

00:40:29.210 --> 00:40:32.630
And if this is not clear, I'll
hang out after this.

00:40:32.630 --> 00:40:36.420
We can go in more detail.

00:40:36.420 --> 00:40:37.250
All right so.

00:40:37.250 --> 00:40:37.980
I think we're out of time.

00:40:37.980 --> 00:40:39.780
Thank you very much
for coming, and

00:40:39.780 --> 00:40:41.030
please rate our session.

