WEBVTT
Kind: captions
Language: en

00:00:01.000 --> 00:00:06.350
&gt;&gt;&gt; Ladies and gentlemen, would you please
welcome Chet Haase and Romain Guy.

00:00:06.350 --> 00:00:12.290
[ Applause ]
&gt;&gt;Chet Haase: Thanks.

00:00:12.290 --> 00:00:18.359
Welcome to "For Butter or Worse," which I
kind of thought we would actually have to

00:00:18.359 --> 00:00:22.690
explain what we meant by "butter," but since
they actually called it "Project Butter" in

00:00:22.690 --> 00:00:27.070
the keynote yesterday, maybe you're absolutely
on the same slide with us now.

00:00:27.070 --> 00:00:28.070
This is Romain Guy.

00:00:28.070 --> 00:00:29.450
&gt;&gt;Romain Guy: So my name is Romain Guy.

00:00:29.450 --> 00:00:31.439
I'm the tech lead of the Android UI toolkit.

00:00:31.439 --> 00:00:33.960
&gt;&gt;Chet Haase: And I'm Chet Haase, on the same
team.

00:00:33.960 --> 00:00:37.650
And we work on graphics and UI and animation
and all that stuff.

00:00:37.650 --> 00:00:40.030
Moving stuff around which is kind of what
this stuff is about.

00:00:40.030 --> 00:00:44.680
It's a bit self-indulgent because we're going
to tell you a lot of stuff that we did internally

00:00:44.680 --> 00:00:50.420
to make the platform better but it is our
subjective and totally selfish believe that

00:00:50.420 --> 00:00:54.280
understanding more about the architecture
and what's actually going on in the platform

00:00:54.280 --> 00:00:56.100
will help you write better applications.

00:00:56.100 --> 00:00:58.039
&gt;&gt;Romain Guy: There are three parts to this
talk.

00:00:58.039 --> 00:01:01.540
The first part is what Chet just mentioned,
we're going to explain how things work under

00:01:01.540 --> 00:01:05.089
the hood, then we're going to show you a few
tools that you can use to identify problems

00:01:05.089 --> 00:01:09.530
in your application, and based on the result
of these tools we'll show you a few tips and

00:01:09.530 --> 00:01:12.010
tricks you can use in your application to
fix those issues.

00:01:12.010 --> 00:01:16.760
&gt;&gt;Chet Haase: But before we get there, we
don't --

00:01:16.760 --> 00:01:19.710
&gt;&gt;Romain Guy: I must say he took that picture.

00:01:19.710 --> 00:01:23.210
[ Laughter ]
&gt;&gt;Chet Haase: He focuses on landscape and

00:01:23.210 --> 00:01:25.850
I focus on fattening food products.

00:01:25.850 --> 00:01:30.130
We don't like to give a talk here at Google
and Google I/O without giving something away,

00:01:30.130 --> 00:01:34.470
so if you look under your seat, you will find
a stick of butter.

00:01:34.470 --> 00:01:37.450
It's not there because that would be ridiculous.

00:01:37.450 --> 00:01:39.850
[ Laughter ]
&gt;&gt;Romain Guy: And very gross.

00:01:39.850 --> 00:01:43.420
So let's define a couple of terms for you.

00:01:43.420 --> 00:01:45.610
There's jank and there's butter.

00:01:45.610 --> 00:01:48.909
So jank is about two things.

00:01:48.909 --> 00:01:51.270
It's basically discontinuous experiences in
the UI.

00:01:51.270 --> 00:01:53.400
So one is choppy performances.

00:01:53.400 --> 00:01:57.090
Hiccups and animations as they're happening,
rendering is not quite happening fast enough

00:01:57.090 --> 00:01:59.290
so the user sees stutters.

00:01:59.290 --> 00:02:04.700
The other meaning that we assigned to jank
is discontinuous experiences like layout -- sort

00:02:04.700 --> 00:02:09.060
of relayouting and resizing itself on the
screen, in front of the user, very discontinuous,

00:02:09.060 --> 00:02:10.060
very disconcerting.

00:02:10.060 --> 00:02:13.410
&gt;&gt;Romain Guy: And this is a word we use a
lot, so someone yesterday asked the question

00:02:13.410 --> 00:02:18.140
in the fireside chat, he wanted to know what
skills do we need to work on the Android team.

00:02:18.140 --> 00:02:19.709
Someone replied you need to know how to skydive.

00:02:19.709 --> 00:02:23.270
Well, you also need to use this word in every
sentence.

00:02:23.270 --> 00:02:27.290
If you come around the office, it's pretty
annoying, you hear jank, jank, jank, jank,

00:02:27.290 --> 00:02:28.290
jank, jank.

00:02:28.290 --> 00:02:29.290
I hate that word.

00:02:29.290 --> 00:02:30.520
&gt;&gt;Chet Haase: Swiping the home screen feels
very jank.

00:02:30.520 --> 00:02:33.890
Yeah, we actually got really tired of this
word; on the other hand, it was a nice word

00:02:33.890 --> 00:02:37.901
to describe exactly what we meant, which was
the experience is not good enough, what can

00:02:37.901 --> 00:02:40.569
we do to make it more buttery.

00:02:40.569 --> 00:02:47.270
So butter means two things: Smooth performance,
which is basically the opposite of that meaning

00:02:47.270 --> 00:02:52.280
of jank, let's smooth things out and remove
that choppiness and animations and rendering.

00:02:52.280 --> 00:02:57.790
Such as home screen swiping is very buttery
in Android 4.1 Jelly Bean.

00:02:57.790 --> 00:02:59.129
It also means a fattening spread.

00:02:59.129 --> 00:03:02.280
We're not actually talking about that meaning
today, but there's some rice crispy treats

00:03:02.280 --> 00:03:04.290
right out there and you can get your dose
of it right out there.

00:03:04.290 --> 00:03:05.870
&gt;&gt;Romain Guy: And I have tip for you.

00:03:05.870 --> 00:03:10.330
If you take a stick of butter and you smudge
it across your screen you will get free antialiasing

00:03:10.330 --> 00:03:11.620
on all your applications.

00:03:11.620 --> 00:03:15.640
[ Laughing ]
&gt;&gt;Romain Guy: I'm joking, but remember "The

00:03:15.640 --> 00:03:20.489
Empire Strikes Back," remember the big robots
at the beginning, that was stop-motion animation,

00:03:20.489 --> 00:03:23.900
that's what they did to do the motion blur,
because you can see -- usually when they use

00:03:23.900 --> 00:03:25.220
that technique you can see it's puppets.

00:03:25.220 --> 00:03:30.240
Well, they were just smudging some sort of
jelly in front of the camera to make it look

00:03:30.240 --> 00:03:31.240
blurry and unappetizing.

00:03:31.240 --> 00:03:33.209
&gt;&gt;Chet Haase: That would have been a lot less
effort.

00:03:33.209 --> 00:03:36.310
We could have spent the last several months
doing something else besides actually working

00:03:36.310 --> 00:03:39.310
on performance if we just had enough butter.

00:03:39.310 --> 00:03:43.870
So, as I said, we're addressing the first
concern of jank right now, choppy performance,

00:03:43.870 --> 00:03:46.730
the other is sort of discontinue those UI
experiences.

00:03:46.730 --> 00:03:47.730
Separate problem.

00:03:47.730 --> 00:03:51.340
This one is all about graphic performance,
animation performance, speeding up the platform

00:03:51.340 --> 00:03:55.799
as well as tips that you can do to speed up
your applications in particular.

00:03:55.799 --> 00:03:58.450
So for any food product, there's always a
recipe.

00:03:58.450 --> 00:04:00.230
If you want to make butter you're going to
make cream.

00:04:00.230 --> 00:04:04.709
If you want to make butter in Android there's
essentially two elements that we're talking

00:04:04.709 --> 00:04:05.709
about here.

00:04:05.709 --> 00:04:11.150
One is low latency by which we mean the time
elapse between something happens, like the

00:04:11.150 --> 00:04:15.590
user touches the screen and the effects of
that action appear on the screen so the user

00:04:15.590 --> 00:04:18.530
actually sees the consequence of that action.

00:04:18.530 --> 00:04:20.630
So what we want to do is minimize latency.

00:04:20.630 --> 00:04:23.500
At the same time we also want to speed up
frame rate.

00:04:23.500 --> 00:04:28.510
We want to make these things happen as fast
and as continuously as possible so that the

00:04:28.510 --> 00:04:32.830
user has a continuous experience through user
events as they're dragging things along or

00:04:32.830 --> 00:04:37.150
animations that are happening on the screen
during transitions or whatever.

00:04:37.150 --> 00:04:42.120
So, first of all, let's talk about the latency
issue.

00:04:42.120 --> 00:04:44.920
Specifically we'll talk about what we did
in the input area.

00:04:44.920 --> 00:04:49.720
So the overall way that input events appear
on the screen, a consequence of that action

00:04:49.720 --> 00:04:51.169
is there's a bunch of events.

00:04:51.169 --> 00:04:55.150
You can picture the finger hitting the screen,
there's a down action, moves around a bunch,

00:04:55.150 --> 00:04:57.240
there's a bunch of move events, eventually
the finger comes up.

00:04:57.240 --> 00:05:02.639
So there's a pile of events that come in and
asynchronously put into this event queue and

00:05:02.639 --> 00:05:06.449
they're batched up and they're sent over across
some wire and eventually we process those

00:05:06.449 --> 00:05:07.830
events and then we draw.

00:05:07.830 --> 00:05:11.669
And the affects of those drawing -- those
drawing operations are eventually seen on

00:05:11.669 --> 00:05:13.160
the screen by the user.

00:05:13.160 --> 00:05:14.780
So we flip the buffer, they see the display.

00:05:14.780 --> 00:05:16.971
So that's the whole process, old and new.

00:05:16.971 --> 00:05:18.350
This is how things happen.

00:05:18.350 --> 00:05:21.870
Events come in, we react to it, we draw, user
sees the results.

00:05:21.870 --> 00:05:24.110
&gt;&gt;Romain Guy: So here's a way to visualize
the issue.

00:05:24.110 --> 00:05:28.190
So here we have a screen shot of the Nexus
7, so the device you all got yesterday.

00:05:28.190 --> 00:05:32.190
And you can see we have an icon in the top
left corner of the launcher, we're just going

00:05:32.190 --> 00:05:36.960
to simulate a finger, long pressing on the
icon and moving it around.

00:05:36.960 --> 00:05:40.940
So we pick up the icon and then when we move
it, that's latency.

00:05:40.940 --> 00:05:45.020
You can see that the finger is moving faster
than the icon itself.

00:05:45.020 --> 00:05:48.820
The maximum difference between the position
of the icon and the position of the finger,

00:05:48.820 --> 00:05:49.820
that's latency.

00:05:49.820 --> 00:05:53.199
And latency is due to many things.

00:05:53.199 --> 00:05:56.690
Some of it is introduced by the software rewrites,
some of it is because of the hardware, it

00:05:56.690 --> 00:06:00.350
can be the touch screen, it can be the memory,
it could be many, many things.

00:06:00.350 --> 00:06:04.470
So we're going to talk about what we did in
our software to reduce the latency that we

00:06:04.470 --> 00:06:05.750
introduced in the system.

00:06:05.750 --> 00:06:09.319
&gt;&gt;Chet Haase: Specifically, let's talk about
what happened in the input system.

00:06:09.319 --> 00:06:11.190
So we drew a really complicated diagram.

00:06:11.190 --> 00:06:14.570
Get used to complicated diagrams, because
we're basically talking about complicated

00:06:14.570 --> 00:06:18.630
things, and complicated things require complicated
diagrams with primary colors in them.

00:06:18.630 --> 00:06:22.100
&gt;&gt;Romain Guy: And you can see if you can do
what we do and just pretend you understand.

00:06:22.100 --> 00:06:25.789
&gt;&gt;Chet Haase: So this is not a real situation
but this is essentially what's going on.

00:06:25.789 --> 00:06:30.030
You can sort of picture the green string along
the top as a series of input events that are

00:06:30.030 --> 00:06:32.170
continuously coming into the system.

00:06:32.170 --> 00:06:36.699
And then occasionally -- this is in the pre-Jelly
Bean era -- we would batch up the events that

00:06:36.699 --> 00:06:40.979
were there already and we'd put them into
a queue to await later processing, eventually

00:06:40.979 --> 00:06:45.260
the thread kicks in at the activity level
that processes those events that were batched

00:06:45.260 --> 00:06:49.090
earlier, and then we draw the results and
then we see the results on the screen.

00:06:49.090 --> 00:06:53.320
And what you're really looking for is when
do the things appear to the user which is

00:06:53.320 --> 00:06:55.560
basically at the end of that drawing cycle.

00:06:55.560 --> 00:06:58.970
And you can think about the latency involved
in different parts of this system.

00:06:58.970 --> 00:07:04.160
So, for instance, event A, which is the first
one up there, didn't appear -- the consequences

00:07:04.160 --> 00:07:08.470
of that didn't appear to the user until the
end of that first draw action so fairly long

00:07:08.470 --> 00:07:09.470
latency period.

00:07:09.470 --> 00:07:13.210
Event C, which happened just slightly after
A, also didn't appear till then, right?

00:07:13.210 --> 00:07:16.900
They were batched up together and all of them
appeared, the results of those actions appeared

00:07:16.900 --> 00:07:18.840
at the end of the first drawing cycle.

00:07:18.840 --> 00:07:22.900
And then we go in and we batched up further
events in the meantime asynchronously and

00:07:22.900 --> 00:07:28.610
then they come in and we process those, events
D-J and they also have these fairly extended

00:07:28.610 --> 00:07:32.819
latency periods between when the user did
something and when the results of that action

00:07:32.819 --> 00:07:34.990
actually appeared on the screen.

00:07:34.990 --> 00:07:41.210
So one of the big things that we did to smooth
out performance in Jelly Bean was to address

00:07:41.210 --> 00:07:46.169
the system of too many layers of interaction
in queues and dispatching operations happening

00:07:46.169 --> 00:07:47.169
in input.

00:07:47.169 --> 00:07:52.169
What we really want to do is get the input
to the process as soon as possible so that

00:07:52.169 --> 00:07:56.150
when the user is ready to actually process
input events, it gets the latest thing that

00:07:56.150 --> 00:07:57.150
happens.

00:07:57.150 --> 00:08:00.100
So we can take a look at the diagram as it
actually happens in Jelly Bean.

00:08:00.100 --> 00:08:02.259
Again, we had this string of events going
on.

00:08:02.259 --> 00:08:05.910
We have vsync, we'll talk about vsync a little
bit later, but basically this is the time

00:08:05.910 --> 00:08:09.780
at which we can actually sort of grab things
and process it which is a little out of sync

00:08:09.780 --> 00:08:12.190
with the way the diagram happens to be drawn.

00:08:12.190 --> 00:08:15.210
We'll going to come in -- you'll notice the
blue bars went away.

00:08:15.210 --> 00:08:18.860
So we no longer have a dispatching operation
that bundled these things up and then sends

00:08:18.860 --> 00:08:20.720
them off into the ether somewhere.

00:08:20.720 --> 00:08:27.610
Instead, at the time when we process, which
is a proc A-F bar in here, we grab all the

00:08:27.610 --> 00:08:32.750
events at that time, so we're not just stuck
with the A-C events that happened further

00:08:32.750 --> 00:08:37.010
away in time; instead, we can grab every event
that happened up to that point.

00:08:37.010 --> 00:08:39.630
And the net effect is that we have much smaller
latencies.

00:08:39.630 --> 00:08:44.860
The older event may still take awhile to actually
reach the screen, but you can see the newer

00:08:44.860 --> 00:08:50.760
event that happened right before the process
operation appears in a much smaller time period

00:08:50.760 --> 00:08:52.130
at the end of the draw operation.

00:08:52.130 --> 00:08:54.560
So what we've got is much better latency overall.

00:08:54.560 --> 00:08:56.190
There's a couple nuances to this.

00:08:56.190 --> 00:08:59.190
In the old system it was also possible to
really bog down the system.

00:08:59.190 --> 00:09:02.660
If you were sending in a lot of input events,
you could actually bog down the dispatcher

00:09:02.660 --> 00:09:06.360
and we would be way, way behind and getting
further behind all the time.

00:09:06.360 --> 00:09:10.950
The other nuance which they mentioned in the
keynote yesterday was not only are we streaming

00:09:10.950 --> 00:09:16.260
the events to get them there faster, but we're
also able to anticipate in some cases where

00:09:16.260 --> 00:09:19.440
the input events should be at exactly the
time that we need it.

00:09:19.440 --> 00:09:23.760
So we go back and we get the most recent event
and if there is no input event at that specific

00:09:23.760 --> 00:09:27.260
time, we could plot a little bit of a trajectory
and say, well, where would an input event

00:09:27.260 --> 00:09:31.990
be given the information we have about the
preceding events such as the finger moving

00:09:31.990 --> 00:09:33.000
on the screen.

00:09:33.000 --> 00:09:38.029
And this gives us much more input events and
much more recent input events that we can

00:09:38.029 --> 00:09:39.130
track things with.

00:09:39.130 --> 00:09:42.360
And the best thing to do, we're not showing
demos today because it's really hard to show

00:09:42.360 --> 00:09:45.740
this stuff on the screen especially with this
display technology.

00:09:45.740 --> 00:09:50.550
Set an Ice Cream Sandwich device next to a
Jelly Bean device and just do the same swiping

00:09:50.550 --> 00:09:54.230
and launching operations on them and you'll
see that we mean, especially with --

00:09:54.230 --> 00:09:55.360
&gt;&gt;Romain Guy: And just one thing.

00:09:55.360 --> 00:10:00.600
On this diagram, the latency, for instance,
of input D and G, looks a lot worse than it

00:10:00.600 --> 00:10:01.600
actually is.

00:10:01.600 --> 00:10:05.550
When we measure latency, we measure the number
of frames of latency, so here the D and G

00:10:05.550 --> 00:10:09.050
has only one frame of latency and it's really,
really, really good.

00:10:09.050 --> 00:10:12.720
To give you an idea, like the best devices
that you can get today or the kind of performance

00:10:12.720 --> 00:10:19.920
we get with Jelly Bean on the Nexus, you can
expect around five frames of latency between

00:10:19.920 --> 00:10:25.050
the time, you know, your finger causes a reaction
from the device until you see the frame that

00:10:25.050 --> 00:10:27.490
corresponds to this action.

00:10:27.490 --> 00:10:31.959
&gt;&gt;Chet Haase: I've been talking for a long
time, I don't know --

00:10:31.959 --> 00:10:33.300
&gt;&gt;Romain Guy: I like to listen to you.

00:10:33.300 --> 00:10:34.950
&gt;&gt;Chet Haase: Then I'll talk some more.

00:10:34.950 --> 00:10:36.630
So frame rate is the other one.

00:10:36.630 --> 00:10:38.320
So reducing latency is good.

00:10:38.320 --> 00:10:42.450
Also making the frame rate faster and more
consistent is a good thing and frame rate

00:10:42.450 --> 00:10:44.980
is all about making the drawing time smaller.

00:10:44.980 --> 00:10:48.160
So how can you actually draw your stuff faster.

00:10:48.160 --> 00:10:51.570
That's kind of what it's all about, but that's
not really all there is to it.

00:10:51.570 --> 00:10:56.290
For one thing, there's a lot of things that
go into what we mean by drawing and drawing

00:10:56.290 --> 00:10:57.290
faster.

00:10:57.290 --> 00:11:01.230
So we thought it might help to go into a architecture
diagram.

00:11:01.230 --> 00:11:02.510
&gt;&gt;Romain Guy: Yeah, so here's the explanation.

00:11:02.510 --> 00:11:06.149
&gt;&gt;Chet Haase: Give you a second, everybody
done?

00:11:06.149 --> 00:11:07.980
All right, good.

00:11:07.980 --> 00:11:11.800
So moving on, that's how the rendering system
works.

00:11:11.800 --> 00:11:17.230
Next topic -- maybe it would help to actually
walk through this a little bit 'cause we're

00:11:17.230 --> 00:11:21.160
serious, that is the diagram and you're going
to understand it in five minutes or you have

00:11:21.160 --> 00:11:22.519
to leave.

00:11:22.519 --> 00:11:27.660
So there's essentially three parts to the
process: Something happens, some event occurs

00:11:27.660 --> 00:11:32.970
or an animation event, finger-dragging, whatever
it is, something happens that we need to react

00:11:32.970 --> 00:11:38.480
to, then we draw; big, nebulous box that has
a lot of subcomponents to it, and then we

00:11:38.480 --> 00:11:42.610
hand over control to the surface flinger object
to actually get the results of that onto the

00:11:42.610 --> 00:11:46.570
screen, that's the buffer flipping, it's posting
the pixels actually onto the screen, the buffer

00:11:46.570 --> 00:11:48.050
where the pixels are.

00:11:48.050 --> 00:11:50.779
So let's walk through the different parts
of these three processes.

00:11:50.779 --> 00:11:53.171
&gt;&gt;Chet Haase: And so surface flinger, for
those of you who don't know what it is, it's

00:11:53.171 --> 00:11:58.600
our window compositor, so it takes all the
windows that are visible on the screen at

00:11:58.600 --> 00:12:02.910
the same time and makes one single image and
then pushes it to the display.

00:12:02.910 --> 00:12:07.850
So it's not something you interact with directly
but that's the -- the window manager and the

00:12:07.850 --> 00:12:11.519
kind of code rewriting UI toolkit interact
with surface flinger a lot.

00:12:11.519 --> 00:12:14.530
&gt;&gt;Chet Haase: So the first part of the process,
something happens.

00:12:14.530 --> 00:12:17.649
So let's say there's an event, the user touches
a screen.

00:12:17.649 --> 00:12:23.040
That will set a property value or propagate
the event somehow, let's say, you know, setting

00:12:23.040 --> 00:12:25.740
a translation property on some view, whatever.

00:12:25.740 --> 00:12:29.279
That causes an invalidate, that's what we
mean by something happens basically.

00:12:29.279 --> 00:12:33.649
There's an event, we react to it, we set a
value, we invalidate which tells the system

00:12:33.649 --> 00:12:37.230
next time we come around to do something we
need to redraw the affected view.

00:12:37.230 --> 00:12:40.240
&gt;&gt;Romain Guy: And when we say "invalidate,"
we really mean view that invalidate.

00:12:40.240 --> 00:12:43.780
It's probably a method that you have used
yourself, this is what is happening here.

00:12:43.780 --> 00:12:47.160
&gt;&gt;Chet Haase: And it's what happens internally
as well, when you change something on one

00:12:47.160 --> 00:12:49.990
of the standard views, we invalidate internally.

00:12:49.990 --> 00:12:51.550
Very core method.

00:12:51.550 --> 00:12:54.440
And there's right and wrong ways to use it
and we'll get into that later.

00:12:54.440 --> 00:12:56.370
Okay, now we're into the big part of the process.

00:12:56.370 --> 00:12:57.839
The bit in the middle that says draw.

00:12:57.839 --> 00:13:00.050
A lot of different pieces to this.

00:13:00.050 --> 00:13:01.850
Measure and layout is certainly part of draw.

00:13:01.850 --> 00:13:04.990
In an optimal situation, if you're in the
middle of the animation, hopefully you're

00:13:04.990 --> 00:13:10.410
not measuring and laying out, lay outing?

00:13:10.410 --> 00:13:11.410
Doing stuff with layout.

00:13:11.410 --> 00:13:12.490
&gt;&gt;Romain Guy: That's what you shouldn't be
doing.

00:13:12.490 --> 00:13:13.490
&gt;&gt;Chet Haase: Yeah.

00:13:13.490 --> 00:13:16.880
But it is a standard part where we come in
to do rendering, we say do we need to do measure

00:13:16.880 --> 00:13:20.880
and layout and then we go on to the next step
which is preparing the draw.

00:13:20.880 --> 00:13:25.930
&gt;&gt;Romain Guy: And we have this really particular
name where we dequeue a buffer.

00:13:25.930 --> 00:13:29.670
We talk to surface flinger so we have this
window compositor and we ask surface flinger

00:13:29.670 --> 00:13:33.070
to give us a buffer in which we can draw so
this is dequeuing the buffer.

00:13:33.070 --> 00:13:36.740
&gt;&gt;Chet Haase: The next step is to update the
display width.

00:13:36.740 --> 00:13:44.470
So as of Android 3.0 in Honeycomb, we started
GPU accelerating the canvas API and a lot

00:13:44.470 --> 00:13:49.190
of the applications and framework that we
run with internally and the way that we did

00:13:49.190 --> 00:13:53.310
this was by creating these structures called
display lists which is an intermediate representation

00:13:53.310 --> 00:13:55.850
of all the drawing commands that a view does.

00:13:55.850 --> 00:14:01.670
So we create this display list that the entire
hierarchy basically says I need to move here,

00:14:01.670 --> 00:14:06.100
draw this, set a cliprect, all this stuff,
and then a display list later is issued into

00:14:06.100 --> 00:14:07.660
--
&gt;&gt;Romain Guy: If you want to know more about

00:14:07.660 --> 00:14:12.470
those two little blue boxes, update display
list and display list, you can go to YouTube,

00:14:12.470 --> 00:14:16.720
and we gave a talk last year at Google I/O,
a one-hour talk where we talk in detail about

00:14:16.720 --> 00:14:18.769
displays and how they work and how you should
use them.

00:14:18.769 --> 00:14:22.330
&gt;&gt;Chet Haase: But not now because we don't
have an hour for you to watch that, you can

00:14:22.330 --> 00:14:24.199
do that later.

00:14:24.199 --> 00:14:27.610
So we update the display list and then we
draw the display list.

00:14:27.610 --> 00:14:31.209
So now that we have all the information about
all the drawing commands that we need to issue,

00:14:31.209 --> 00:14:35.980
now we go ahead and issue the commands which
is basically a process of telling open GL,

00:14:35.980 --> 00:14:40.050
draw this line, draw this bitmap, do these
operations.

00:14:40.050 --> 00:14:44.449
And these are both working from this common
display list data structure.

00:14:44.449 --> 00:14:47.209
And then we get to the point where, okay,
we've done all our drawings, we're ready to

00:14:47.209 --> 00:14:52.029
tell surface flinger, hey, swap the buffers,
I'm done, flip it, get it onto the screen.

00:14:52.029 --> 00:14:56.250
So then we do the opposite of dequeue, we
do an NQ, we say, here's our buffer, we're

00:14:56.250 --> 00:14:57.250
done with it.

00:14:57.250 --> 00:15:01.130
&gt;&gt;Romain Guy: So once surface flinger gets
the buffer back from our application, it has

00:15:01.130 --> 00:15:03.350
to composite all the windows that you see
on the screen.

00:15:03.350 --> 00:15:08.579
It does that into a single buffer, we're simplifying
a little bit, so we compose everything into

00:15:08.579 --> 00:15:10.940
a single buffer and that's what we display.

00:15:10.940 --> 00:15:14.760
So compositing windows, we'll talk a bit more
about that a little later.

00:15:14.760 --> 00:15:17.389
&gt;&gt;Chet Haase: So now everybody understands
the architecture, right?

00:15:17.389 --> 00:15:18.389
&gt;&gt;Romain Guy: Yes.

00:15:18.389 --> 00:15:20.480
So it's not that difficult.

00:15:20.480 --> 00:15:24.260
But it's important to understand the different
stages so -- to know we invalidate and updated

00:15:24.260 --> 00:15:27.420
the displays, then we draw the displays and
we send our buffer to surface flinger because

00:15:27.420 --> 00:15:32.930
we'll say at the end of the talk what you
can do to make every one of those steps a

00:15:32.930 --> 00:15:35.800
little faster.

00:15:35.800 --> 00:15:40.610
So we mentioned during the keynote that we
introduced vsync on Android.

00:15:40.610 --> 00:15:41.720
It's not quite true.

00:15:41.720 --> 00:15:45.509
So for those of you who don't know what vsync
is, it's basically the ability to synchronize

00:15:45.509 --> 00:15:48.060
yourself, your code, with the refresh rate
of the displays.

00:15:48.060 --> 00:15:53.860
So typically we talk about 60 Hertz, we think
of displays as running at 60 FPS, so every

00:15:53.860 --> 00:16:00.149
60 milliseconds you get a pulse from the display
that's the vsync that says I'm about to render,

00:16:00.149 --> 00:16:01.839
to put a new buffer on the screen.

00:16:01.839 --> 00:16:05.780
And if you manage to synchronize everything
with the display, you can get much smoother

00:16:05.780 --> 00:16:08.560
performance and we'll explain how.

00:16:08.560 --> 00:16:13.910
On Android, it's not quite true that the display
is always at 60 Hertz, it will depend on the

00:16:13.910 --> 00:16:14.910
device.

00:16:14.910 --> 00:16:19.339
So some devices will run at 55 Hertz, some
devices will run at 57 Hertz.

00:16:19.339 --> 00:16:23.519
The Nexus 7 in particular runs at 60 Hertz,
so this is a good device to test on.

00:16:23.519 --> 00:16:28.960
This can be a good thing when it displays
at 55 Hertz, you have a few more milliseconds

00:16:28.960 --> 00:16:33.940
per frame to draw and still look really smooth.

00:16:33.940 --> 00:16:38.280
We talked about introducing vsync, but we've
always had vsync on Android.

00:16:38.280 --> 00:16:42.750
So surface flinger itself was synchronized
with the display, so that we never suffer

00:16:42.750 --> 00:16:43.860
from tearing.

00:16:43.860 --> 00:16:47.860
So tearing is an effect you see in games sometimes,
especially on consoles, when you turn around

00:16:47.860 --> 00:16:52.750
really quickly, you get this effect where
you're seeing at the same time on the screen

00:16:52.750 --> 00:16:57.100
the old buffer, so the last position where
you were in the game and then you see the

00:16:57.100 --> 00:17:00.320
new buffer coming in and they're both on the
screen at the same time because the display

00:17:00.320 --> 00:17:02.529
is busy refreshing line by line.

00:17:02.529 --> 00:17:04.410
So to avoid that issue we had vsync.

00:17:04.410 --> 00:17:09.919
But now what we do is also use the vsync pulse
to synchronize the logic inside the applications.

00:17:09.919 --> 00:17:14.490
So we synchronize all our animations, the
scrolling, the flings, dispatching the touch

00:17:14.490 --> 00:17:18.050
events with the vsync to get smoother results.

00:17:18.050 --> 00:17:21.679
&gt;&gt;Chet Haase: The process of getting pixels
to the screen.

00:17:21.679 --> 00:17:25.900
This is more education for you, how do things
work, so that we can see actually how to optimize

00:17:25.900 --> 00:17:29.220
it, is basically three steps you can think
of this as.

00:17:29.220 --> 00:17:32.230
First, we're updating the display list, which
we saw before.

00:17:32.230 --> 00:17:37.640
This is generally CPU operations, so this
is calling your on-draw method or our on-draw

00:17:37.640 --> 00:17:41.360
method internally for the standard components,
and then we're drawing the display, this is

00:17:41.360 --> 00:17:45.510
done on the GPU, we actually call GL draw
and then it queues the things up in the GL

00:17:45.510 --> 00:17:49.640
and does its operations on the GPU and then
actually displaying the pixels, flipping the

00:17:49.640 --> 00:17:54.240
buffer, this is, again, GPU operations, to
take that buffer and post it to the screen.

00:17:54.240 --> 00:17:58.520
And then visible is just more of a point in
time where the user can actually see it which

00:17:58.520 --> 00:18:02.910
comes in handy when we're going to talk about
how we sped things up to make things visible

00:18:02.910 --> 00:18:05.180
as consistently as possible.

00:18:05.180 --> 00:18:09.929
So in the previous platform, in Ice Cream
Sandwich, this is kind of how things looked.

00:18:09.929 --> 00:18:14.200
Yes, we used vsync, but did it at a very low
level, which was when we get around to posting

00:18:14.200 --> 00:18:18.220
the buffer, we post it during the refresh
interval, which means there's no tearing on

00:18:18.220 --> 00:18:19.220
seeing the buffer.

00:18:19.220 --> 00:18:22.260
However, nothing else in the system was actually
working off of vsync.

00:18:22.260 --> 00:18:26.780
We were just working on event systems that
had similar timing behavior but had nothing

00:18:26.780 --> 00:18:29.039
really to do with vsync itself.

00:18:29.039 --> 00:18:33.620
So we would come in at any random time during
the frame to actually do our drawing operation.

00:18:33.620 --> 00:18:38.610
So you can see here the display at the top,
this is the buffer that it's currently showing.

00:18:38.610 --> 00:18:42.870
So it may be showing buffer 0, which means
that we can work on operations for buffer

00:18:42.870 --> 00:18:43.870
1.

00:18:43.870 --> 00:18:47.290
So we do our update display list calls on
the CPU when we're done with that, and we

00:18:47.290 --> 00:18:52.290
pass control over to the GPU to do the actual
issuing to do OpenGL.

00:18:52.290 --> 00:18:53.700
And they're both working on buffer 1.

00:18:53.700 --> 00:18:57.140
And then when that's done, then that can be
displayed on the next vsync interval.

00:18:57.140 --> 00:19:00.059
So go into the first frame, display showing
buffer 1.

00:19:00.059 --> 00:19:01.059
Life is good.

00:19:01.059 --> 00:19:04.430
Now, if for some reason there's been a delay
before we actually get around to rendering

00:19:04.430 --> 00:19:06.900
on the CPU and updating the list again.

00:19:06.900 --> 00:19:14.240
So we go in and can't draw into buffer 2 until
very near the end of that vsync frame, which

00:19:14.240 --> 00:19:18.120
means that by the time we're done with that
and then the GPU operations that follow after

00:19:18.120 --> 00:19:19.309
it, it's too late.

00:19:19.309 --> 00:19:20.520
We can't vsync.

00:19:20.520 --> 00:19:23.480
So what we end up with is jank; right?

00:19:23.480 --> 00:19:29.080
We basically displayed the buffer 1 twice
in a row, which means to the user they have

00:19:29.080 --> 00:19:34.070
seen a hiccup in an animation or a rendering
because they saw the same information on the

00:19:34.070 --> 00:19:37.160
screen for two frames in a row.

00:19:37.160 --> 00:19:42.120
And 16 milliseconds may not seem like a lot
of time and 60 frames per second may seem

00:19:42.120 --> 00:19:46.340
really fast, but you see two of these, you
may not know exactly what you saw, but you

00:19:46.340 --> 00:19:47.340
will notice it.

00:19:47.340 --> 00:19:50.970
&gt;&gt;Romain Guy: What's difficult about it is,
if you see that kind of issue in your application

00:19:50.970 --> 00:19:54.450
and you use Traceview or one of our (indiscernible)
tools, you'll see that your code may be running

00:19:54.450 --> 00:19:55.450
really fast.

00:19:55.450 --> 00:20:02.240
Even if you take a fraction of a millisecond
to execute your draw methods, if that happens

00:20:02.240 --> 00:20:05.150
across the vsync boundary, you will get the
jank.

00:20:05.150 --> 00:20:06.850
There's nothing you can do about it.

00:20:06.850 --> 00:20:08.570
So we fixed it for you.

00:20:08.570 --> 00:20:10.150
&gt;&gt;Chet Haase: Like this.

00:20:10.150 --> 00:20:16.060
So now we pulse everything in the system related
to rendering, animations, graphic input events,

00:20:16.060 --> 00:20:19.669
and then rendering results from those actions.

00:20:19.669 --> 00:20:21.310
And we key it all off of vsync.

00:20:21.310 --> 00:20:27.280
So, basically, we give ourselves as much time
as possible within a frame to finish all those

00:20:27.280 --> 00:20:30.500
operations, get all the information to the
buffer so that by the time we get around to

00:20:30.500 --> 00:20:34.140
posting the buffer on the next vsync event,
we're ready to go.

00:20:34.140 --> 00:20:38.380
In this case, there's no jank because in all
of these frames we had the information soon

00:20:38.380 --> 00:20:41.840
enough that we could actually post the buffer
and display the next frame and there was not

00:20:41.840 --> 00:20:42.840
a hiccup not user.

00:20:42.840 --> 00:20:45.870
&gt;&gt;Romain Guy: Now if you're missing frames,
it's your fault because you're taking more

00:20:45.870 --> 00:20:47.440
than 16 milliseconds.

00:20:47.440 --> 00:20:53.350
&gt;&gt;Chet Haase: There's a lot of information
and advice about how things work.

00:20:53.350 --> 00:20:56.630
This is not to say that you can't still jank,
obviously.

00:20:56.630 --> 00:21:03.040
If any of these bars goes longer than 16 milliseconds
or if together they take longer than 16 milliseconds,

00:21:03.040 --> 00:21:04.040
that's a jank, too.

00:21:04.040 --> 00:21:08.059
This is just in a well-behaved application,
now that we have vsync, we have a much greater

00:21:08.059 --> 00:21:12.190
probability of actually having a smooth experience.

00:21:12.190 --> 00:21:16.440
So display lists, as we said are a core part
of rendering with our GPU.

00:21:16.440 --> 00:21:20.560
It's cache in the intermediate rendering commands
so we can go ahead and issue they will very

00:21:20.560 --> 00:21:22.370
efficiently into OpenGL.

00:21:22.370 --> 00:21:26.541
So the process that this happens with is a
bunch of properties will be set, let's say

00:21:26.541 --> 00:21:29.070
you're fading in a view and sliding it at
the same time.

00:21:29.070 --> 00:21:32.169
We're setting translation and alpha properties
on the view.

00:21:32.169 --> 00:21:35.870
All of these cause their separate invalidates
to propagate through the system.

00:21:35.870 --> 00:21:39.760
On the next vsync, we get an event from the
vsync pulse that will says, okay, time to

00:21:39.760 --> 00:21:40.870
actually render.

00:21:40.870 --> 00:21:45.220
So we go through and update the display lists
that have changed because of these operations.

00:21:45.220 --> 00:21:48.520
We don't update everything, but we update
the views that were changed.

00:21:48.520 --> 00:21:52.789
And then we draw the display list in its current
state.

00:21:52.789 --> 00:21:56.870
So what we found in this release was there
were certain key properties that were being

00:21:56.870 --> 00:22:00.610
animated over and over again, let's say in
launcher going between all apps and the home

00:22:00.610 --> 00:22:05.120
screen or swiping back and forth that we could
handle much more efficiently by simply setting

00:22:05.120 --> 00:22:07.090
some properties in a data structure.

00:22:07.090 --> 00:22:08.900
So we called this display list properties.

00:22:08.900 --> 00:22:13.669
So rather than, on the previous slide, if
you're setting alpha and translation properties,

00:22:13.669 --> 00:22:17.799
instead of recreating the display list for
all of the affect views and then redrawing

00:22:17.799 --> 00:22:22.131
the Display, what we can actually do is simply
set some properties that the display list

00:22:22.131 --> 00:22:26.660
basically grabs on its way to the grocery
store, on its way to talking to GL, it says

00:22:26.660 --> 00:22:28.710
where are you now and what's your alpha value?

00:22:28.710 --> 00:22:29.929
And then it draws it in there.

00:22:29.929 --> 00:22:35.260
Much more efficient, and there should be a
little graph in here, maybe on the next slide.

00:22:35.260 --> 00:22:37.409
It will be very exciting.

00:22:37.409 --> 00:22:42.530
This is specific to the properties that we
added in 3.0, which are the transform properties,

00:22:42.530 --> 00:22:47.309
translation X and Y, rotate, scale, as well
as the alpha property.

00:22:47.309 --> 00:22:51.950
So if you're setting these properties correctly
or running object animators or view property

00:22:51.950 --> 00:22:55.371
animators that are setting these properties,
then they will be taking this much more efficient

00:22:55.371 --> 00:23:00.610
route of simply setting some properties instead
of causing the invalidations, which costs

00:23:00.610 --> 00:23:04.840
time, as well as the rerendering of the views
that were affected.

00:23:04.840 --> 00:23:05.910
And here's the pretty graph.

00:23:05.910 --> 00:23:07.429
&gt;&gt;Romain Guy: Here's why it matters.

00:23:07.429 --> 00:23:11.539
So in blue, you can see the time -- so this
is taking the example of you're in launcher,

00:23:11.539 --> 00:23:13.970
you click on the O apps (phonetic) button
and (indiscernible) animation to take you

00:23:13.970 --> 00:23:16.610
to a list of all the installed applications.

00:23:16.610 --> 00:23:22.020
So in blue, it's the time we were taking to
run through the Dalvik code of launcher to

00:23:22.020 --> 00:23:24.460
run all the draw methods on ICS.

00:23:24.460 --> 00:23:30.470
The red line is the time we take on Jelly
Bean, because it's using display list properties,

00:23:30.470 --> 00:23:33.690
so now we don't have to run the draw methods
of any view in the system.

00:23:33.690 --> 00:23:35.290
We just go poke at the display list.

00:23:35.290 --> 00:23:39.169
We can avoid, like, most of the invalidate
work, and then we just start drawing the display.

00:23:39.169 --> 00:23:44.600
In this particular case, we gain about up
to 2 milliseconds per frame, which matters

00:23:44.600 --> 00:23:48.140
a lot when you are trying to hit a target
that's maximum 16 milliseconds.

00:23:48.140 --> 00:23:51.640
&gt;&gt;Chet Haase: And this was an animation that
was specifically either going into all apps

00:23:51.640 --> 00:23:53.640
or back from all apps.

00:23:53.640 --> 00:23:56.720
So this is just data that I collected at the
time to make sure that I hadn't wasted my

00:23:56.720 --> 00:24:00.059
time for the past couple of weeks.

00:24:00.059 --> 00:24:02.799
Somebody made the comment at the time, really,
one millisecond, you save one millisecond,

00:24:02.799 --> 00:24:03.799
does that matter?

00:24:03.799 --> 00:24:05.640
Think about 60 frames a second.

00:24:05.640 --> 00:24:09.299
That's 16 milliseconds in which you have to
accomplish everything; right?

00:24:09.299 --> 00:24:13.020
Every millisecond counts, especially in something
you're going to run really commonly like this.

00:24:13.020 --> 00:24:17.049
So, yeah, maybe I only saved a millisecond,
it was only taking one or two or three.

00:24:17.049 --> 00:24:20.280
But what if it was doing something more at
the time and it was just enough to push it

00:24:20.280 --> 00:24:22.750
over those 60 frames per second boundary?

00:24:22.750 --> 00:24:23.750
Then we just avoided jank.

00:24:23.750 --> 00:24:26.620
&gt;&gt;Romain Guy: And as far as the UI toolkit
is concerned, that's a pretty simple animation.

00:24:26.620 --> 00:24:29.250
We're only changing the scale and the alpha
property.

00:24:29.250 --> 00:24:33.539
But if you were to change 20 of those properties
at the same time, the gains would be much,

00:24:33.539 --> 00:24:34.539
much higher.

00:24:34.539 --> 00:24:38.309
&gt;&gt;Chet Haase: Parallel processing.

00:24:38.309 --> 00:24:40.610
Let's talk about triple buffering.

00:24:40.610 --> 00:24:48.230
So one of the things that we did in Jelly
Bean was to enable more parts of the system

00:24:48.230 --> 00:24:51.870
to work in parallel to give us more benefits.

00:24:51.870 --> 00:24:55.551
If you think about it, there's three distinct
parts of the system that all need to talk

00:24:55.551 --> 00:25:00.740
to the GPU at one time, where we're doing
work on the CPU that needs to sort of grab

00:25:00.740 --> 00:25:02.679
a buffer and have a place to store the information.

00:25:02.679 --> 00:25:05.530
Then somebody else is going to be doing work
on the GPU.

00:25:05.530 --> 00:25:08.830
They need access to that buffer to get the
information that we stored there and then

00:25:08.830 --> 00:25:12.960
talk to the GPU and say these are the drawing
commands, and then OpenGL is actually doing

00:25:12.960 --> 00:25:14.630
work to process those commands as well.

00:25:14.630 --> 00:25:18.600
And, then, finally, the display system is
-- in queuing and dequeuing and posting the

00:25:18.600 --> 00:25:21.279
buffers, it needs access to the same information.

00:25:21.279 --> 00:25:25.840
In the previous version of the platform, we
were double buffered, which is very common,

00:25:25.840 --> 00:25:28.710
which means I can be displaying a buffer while
you're working on it.

00:25:28.710 --> 00:25:31.210
Well, there's three people that work here;
right?

00:25:31.210 --> 00:25:33.789
So, yeah, maybe you're working on it and I'm
displaying the buffer.

00:25:33.789 --> 00:25:38.760
But somebody else is waiting for one of those
to free up to do their part of the work chain.

00:25:38.760 --> 00:25:46.070
So what we did was enable triple buffering
in a lazy way where, when you need it, it

00:25:46.070 --> 00:25:47.290
will be there.

00:25:47.290 --> 00:25:51.590
So this -- we can get the low latency the
double buffering gives you, but we can also

00:25:51.590 --> 00:25:55.640
get the consistency that triple buffering
can give you, as shown in the following fascinating

00:25:55.640 --> 00:25:56.640
diagram.

00:25:56.640 --> 00:26:00.429
Here is a very well behaved application where
vsync, so we're drawing at the beginning of

00:26:00.429 --> 00:26:05.049
the frame and can do all the CPU and GPU work
in enough time that we're ready for the next

00:26:05.049 --> 00:26:10.660
vsync interval, which means we're displaying
buffer A, B, A, B, A. Life is good.

00:26:10.660 --> 00:26:13.650
But what if some of these operations took
a little bit too long?

00:26:13.650 --> 00:26:19.250
Which means that buffer B doesn't get displayed,
we're not finished with buffer B in time to

00:26:19.250 --> 00:26:24.640
vsync to it to flip the buffer, which means
that we're going to see buffer A twice.

00:26:24.640 --> 00:26:25.640
That's a jank.

00:26:25.640 --> 00:26:27.760
And then, finally, we get around to the next
vsync interval.

00:26:27.760 --> 00:26:30.990
Finally buffer A is freed up so that we can
operate on it again.

00:26:30.990 --> 00:26:34.140
And you can see all the wasted time at the
end of that second frame where we're just

00:26:34.140 --> 00:26:36.720
sitting there, waiting for buffer A to be
free.

00:26:36.720 --> 00:26:40.020
And, again, maybe we take a little bit too
long and then we jank again.

00:26:40.020 --> 00:26:41.020
Right?

00:26:41.020 --> 00:26:44.980
What we can do instead is allow these things
to happen in parallel, so we may still have

00:26:44.980 --> 00:26:49.539
a jank the first time we took too long to
draw, but after that, we allocate a third

00:26:49.539 --> 00:26:52.170
buffer, and that buffer is available immediately.

00:26:52.170 --> 00:26:57.000
So even though the display is still sitting
on buffer A, our CPU operations can actually

00:26:57.000 --> 00:27:02.540
be working with buffer C at the time, because
the GPU is busy with buffer B. And all of

00:27:02.540 --> 00:27:06.030
a sudden there's three pieces that are in
play at the same time for the three different

00:27:06.030 --> 00:27:09.970
components that need them, and we can get
-- yes, we will have an occasional jank when

00:27:09.970 --> 00:27:11.840
the system gets into this state.

00:27:11.840 --> 00:27:14.340
But then we're going to have much more consistent
performance after that.

00:27:14.340 --> 00:27:18.640
&gt;&gt;Romain Guy: So to improve input latency,
we removed the buffer, and to improve frame

00:27:18.640 --> 00:27:19.840
rate consistency, we added the buffer.

00:27:19.840 --> 00:27:22.720
That makes no sense to me.

00:27:22.720 --> 00:27:25.240
[ Laughter ]
&gt;&gt;Chet Haase: All the stuff we're talking

00:27:25.240 --> 00:27:29.940
about is actually far more complicated than
we're unloading on you today.

00:27:29.940 --> 00:27:32.160
But these are the sort of high-level concepts
behind them.

00:27:32.160 --> 00:27:35.360
&gt;&gt;Romain Guy: So we wanted -- we mentioned
window composition before.

00:27:35.360 --> 00:27:38.530
I just wanted to explain really quickly how
window composition works.

00:27:38.530 --> 00:27:42.450
So window composition can use the GPU and
something we call a hardware composer.

00:27:42.450 --> 00:27:48.399
Besides the GPU, hardware often has the notion
of what to call an overlay, which can be seen

00:27:48.399 --> 00:27:49.419
as a bit map.

00:27:49.419 --> 00:27:53.340
Hardware usually has a limiting number of
overlays you can use to composite things together

00:27:53.340 --> 00:27:55.240
without using the GPU.

00:27:55.240 --> 00:27:59.970
Most of the time, what we try to do is use
overlays, we try to put the window of your

00:27:59.970 --> 00:28:01.320
application inside an overlay.

00:28:01.320 --> 00:28:06.210
If we can fit all the windows on screen inside
the overlays, the GPU is completely free and

00:28:06.210 --> 00:28:08.250
we can keep those resources for the apps.

00:28:08.250 --> 00:28:12.470
Unfortunately, sometimes we cannot use the
overlays for all the windows on screen, and

00:28:12.470 --> 00:28:13.760
we have to use the GPU.

00:28:13.760 --> 00:28:17.340
So you will see here on the left, we have
something called the frame buffers.

00:28:17.340 --> 00:28:20.390
So instead of sending your window, you're
drawing into an overlay, we send it to what

00:28:20.390 --> 00:28:22.159
we call a frame buffer.

00:28:22.159 --> 00:28:26.799
Surface flinger has to take them and compose
them together using the GPU and send that

00:28:26.799 --> 00:28:28.480
to an overlay.

00:28:28.480 --> 00:28:32.721
The problem is that when we use the GPU, it
takes time, like, GPU have a limited number

00:28:32.721 --> 00:28:36.309
of pixels they can manipulate per second.

00:28:36.309 --> 00:28:41.580
Anything we do on top of what the application
is doing can be a source of problems.

00:28:41.580 --> 00:28:46.630
So now I want to show you a few tools that
you can use in your application to identify

00:28:46.630 --> 00:28:48.990
frame rate issues and fix them.

00:28:48.990 --> 00:28:51.640
So the first one is called dumpsys gfx info.

00:28:51.640 --> 00:28:56.270
You have to use a command line to use it,
so you run ADB shell, dumpsys gfx info.

00:28:56.270 --> 00:29:04.920
But before you can do that, you go into developer
options, and so labeled on your Jelly Bean

00:29:04.920 --> 00:29:05.920
phone.

00:29:05.920 --> 00:29:10.760
And then at the end, you'll find an item called
profile GPU rendering.

00:29:10.760 --> 00:29:12.100
Turn that on.

00:29:12.100 --> 00:29:16.140
Then make sure to kill your application first
or at least to kill the window that you want

00:29:16.140 --> 00:29:18.730
to profile, and then you can run the command.

00:29:18.730 --> 00:29:23.040
So I'll show you what the result of the command
looks like.

00:29:23.040 --> 00:29:26.990
I have a Nexus 7 hooked up right here.

00:29:26.990 --> 00:29:32.570
And I'm just going to scroll a few times in
the settings applications, and I'm going to

00:29:32.570 --> 00:29:33.570
output the results.

00:29:33.570 --> 00:29:35.620
So I'm just scrolling.

00:29:35.620 --> 00:29:36.670
Run the command.

00:29:36.670 --> 00:29:39.830
You'll get a lot of information about all
the running processes.

00:29:39.830 --> 00:29:44.590
If you want, you can specify the name of your
process to eliminate a lot of information.

00:29:44.590 --> 00:29:47.010
We mentioned this, too, in other talks.

00:29:47.010 --> 00:29:49.299
If you want to know more about the other information.

00:29:49.299 --> 00:29:53.000
But what happens is those three columns of
data that you see here.

00:29:53.000 --> 00:29:54.620
So you find the three columns.

00:29:54.620 --> 00:30:00.190
And what you will do is just grab all this
data, copy and paste it into a spreadsheet.

00:30:00.190 --> 00:30:04.040
And then you will get a result like this one.

00:30:04.040 --> 00:30:07.940
One sec.

00:30:07.940 --> 00:30:09.210
So this is the data you can grab.

00:30:09.210 --> 00:30:14.320
Here, I just create a stack graph, so every
bar contains the sum of the three columns.

00:30:14.320 --> 00:30:18.700
So the first column on the left in the data
that we output is the time it takes to update

00:30:18.700 --> 00:30:20.710
the display list on every frame.

00:30:20.710 --> 00:30:22.840
The middle column is called process display
list.

00:30:22.840 --> 00:30:25.240
It's the time we take to draw the actual display
list.

00:30:25.240 --> 00:30:29.539
And the last one is the time we take to swap
the buffers, so to give the buffer back to

00:30:29.539 --> 00:30:30.549
surface flinger.

00:30:30.549 --> 00:30:34.520
So here, when I was scrolling through settings,
you can see that when we do the sum of all

00:30:34.520 --> 00:30:39.940
those data, we are well below the 16 millisecond
limit.

00:30:39.940 --> 00:30:44.399
So this app is running at 60 FPS, we're vsync'd,
everything is going great.

00:30:44.399 --> 00:30:49.130
And you can see that most of the time, you
should be spending most of the time in process

00:30:49.130 --> 00:30:50.130
display list.

00:30:50.130 --> 00:30:53.659
So drawing, executing the display list should
be where you spend the bulk of the time.

00:30:53.659 --> 00:30:56.080
The blue part is your code.

00:30:56.080 --> 00:31:00.169
When you write your Java code, your on draw
method, that's in the blue bar at the bottom.

00:31:00.169 --> 00:31:02.559
And this is where you can do most of the optimizations.

00:31:02.559 --> 00:31:06.679
Next, I wanted to show you Systrace.

00:31:06.679 --> 00:31:11.350
So Systrace was mentioned several times as
to -- if you attended the tools talk earlier

00:31:11.350 --> 00:31:13.559
today, you will -- you saw what it looks like.

00:31:13.559 --> 00:31:14.890
It was mentioned during the keynote.

00:31:14.890 --> 00:31:18.980
And I wanted to show you how you can use it
to identify issues.

00:31:18.980 --> 00:31:21.570
So let's imagine that you have an app that's
misbehaving.

00:31:21.570 --> 00:31:26.100
You can use Systrace to understand what's
-- what in the system is making your app misbehave.

00:31:26.100 --> 00:31:28.970
So, first of all, you have to enable Systrace.

00:31:28.970 --> 00:31:33.570
So you go back to developer options in settings
and then look for something called enable

00:31:33.570 --> 00:31:34.570
traces.

00:31:34.570 --> 00:31:35.860
You'll get a little dialogue.

00:31:35.860 --> 00:31:39.110
And here, you can see the type of information
that you want to trace.

00:31:39.110 --> 00:31:43.779
In this particular case, we're only interested
in graphics performance, so we're going to

00:31:43.779 --> 00:31:45.840
set a graphics and view.

00:31:45.840 --> 00:31:47.789
There is a lot more you can use.

00:31:47.789 --> 00:31:53.240
If you're doing audio processing or video
playing, you can enable that.

00:31:53.240 --> 00:31:57.850
Now, using the tool, once you have that enabled,
is very simple.

00:31:57.850 --> 00:31:59.980
So you go back to your terminal.

00:31:59.980 --> 00:32:02.299
Let's remove this.

00:32:02.299 --> 00:32:05.580
And I'm just going to capture a trace while
scrolling through settings.

00:32:05.580 --> 00:32:11.179
So the same test as I just did with the dumpsys
gfx info.

00:32:11.179 --> 00:32:16.309
In the SDK, you have to go in the directory
called tools/systrace.

00:32:16.309 --> 00:32:20.309
And there, you'll find a Python script called
Systrace.py.

00:32:20.309 --> 00:32:25.390
So you run that, and while it's running, just
make your app react.

00:32:25.390 --> 00:32:27.320
Here I'm scrolling the ListView in settings.

00:32:27.320 --> 00:32:29.700
&gt;&gt;Chet Haase: Captures the trace for five
seconds.

00:32:29.700 --> 00:32:30.980
&gt;&gt;Romain Guy: Yes.

00:32:30.980 --> 00:32:32.809
So you get an HTML file.

00:32:32.809 --> 00:32:35.690
Going to open.

00:32:35.690 --> 00:32:37.010
And this is the result.

00:32:37.010 --> 00:32:41.799
So this gives you an overview of everything
that's going on in the system at the time

00:32:41.799 --> 00:32:42.799
you took the trace.

00:32:42.799 --> 00:32:44.770
&gt;&gt;Chet Haase: In very comforting pastel colors.

00:32:44.770 --> 00:32:49.720
&gt;&gt;Romain Guy: It's very interesting, because
here you can see how many CPUs were active

00:32:49.720 --> 00:32:51.370
when I started the trace.

00:32:51.370 --> 00:32:56.080
This is a quad core device but I needed only
one CPU to get the job done, so we can see

00:32:56.080 --> 00:32:57.860
that only one CPU is active.

00:32:57.860 --> 00:33:03.120
If I zoom in on it, so the UI is a little
complicated, you have to use, if you like,

00:33:03.120 --> 00:33:09.409
Doom or Quake games on PCUs, WASD, it's the
same (indiscernible) to navigate in the tool.

00:33:09.409 --> 00:33:13.250
We're going to get a better UI, I hope.

00:33:13.250 --> 00:33:16.880
So we zoom in on the CPU, and you can see
exactly what the CPU is doing.

00:33:16.880 --> 00:33:20.970
So, for instance, here, if I click on it,
I can see that settings, the settings application

00:33:20.970 --> 00:33:24.070
was doing something for about 2 milliseconds.

00:33:24.070 --> 00:33:28.279
You can see that next, we had something called
binder, so a binder thread that was doing

00:33:28.279 --> 00:33:31.120
something for a tenth of a millisecond.

00:33:31.120 --> 00:33:35.179
It's a really powerful tool, because you can
get a lot of details about the system.

00:33:35.179 --> 00:33:39.350
And the important part when you want to improve
performance in your application is to look

00:33:39.350 --> 00:33:43.760
at the process called surface flinger, remember,
surface flinger is in charge, ultimately,

00:33:43.760 --> 00:33:46.830
of putting your pixels on the screen.

00:33:46.830 --> 00:33:51.640
What we are capturing here, every bar that
you see is basically one frame.

00:33:51.640 --> 00:33:56.169
You can see here everything is very regular,
so we're posting our frames on the vsync at

00:33:56.169 --> 00:33:57.340
about 60 FPS.

00:33:57.340 --> 00:34:01.950
The only two places that we see here is because
I just reached the end of the list when I

00:34:01.950 --> 00:34:06.990
was calling it, so for a fraction of a second,
the time it took me to start going the other

00:34:06.990 --> 00:34:08.550
direction, nothing was happening.

00:34:08.550 --> 00:34:13.649
You can also zoom in on your application,
and here, you can see the graph we are talking

00:34:13.649 --> 00:34:14.940
about.

00:34:14.940 --> 00:34:18.250
So deliver input event, this is where we received
the touch events.

00:34:18.250 --> 00:34:20.270
This is where we deliver the touch events
to all your views.

00:34:20.270 --> 00:34:23.640
This is where you run your own code if you
intercept touch events.

00:34:23.640 --> 00:34:26.360
And then we have this perform (indiscernible)
source method.

00:34:26.360 --> 00:34:28.329
This is where we draw.

00:34:28.329 --> 00:34:30.179
This is where we dequeue the buffer.

00:34:30.179 --> 00:34:33.129
So we get a buffer from surface flinger.

00:34:33.129 --> 00:34:36.980
Then get display list, this is what we call
update display list in the diagram.

00:34:36.980 --> 00:34:42.359
So here we spent about 1.2 milliseconds going
through the views in the UI toolkit, asking

00:34:42.359 --> 00:34:43.940
them to recreate that display list.

00:34:43.940 --> 00:34:45.970
So it was very fast.

00:34:45.970 --> 00:34:50.290
Then draw display list, this is where we execute
the display list, and you can see it took

00:34:50.290 --> 00:34:55.359
only 2.3 milliseconds, and then we swap buffers
and give the buffer back to surface flinger.

00:34:55.359 --> 00:35:01.270
When we are done, if you look at the surface
flinger process, you can see that we finished

00:35:01.270 --> 00:35:08.570
our work and at the next vsync, surface flinger
takes our buffer and posts it on screen.

00:35:08.570 --> 00:35:11.400
So this example, I mean, just shows you how
to use the tool.

00:35:11.400 --> 00:35:13.070
It's pretty simple.

00:35:13.070 --> 00:35:16.829
You can do multiple selections to see everything
that's happening, you know, in a given period

00:35:16.829 --> 00:35:17.990
of time.

00:35:17.990 --> 00:35:21.740
What's more interesting is to look at the
tool when things go wrong.

00:35:21.740 --> 00:35:24.700
So I won't show you the application, but I
wrote a little application, it's a simple

00:35:24.700 --> 00:35:26.940
ListView that's doing something bad.

00:35:26.940 --> 00:35:30.630
And so when you scroll the list, it's very
janky, very choppy.

00:35:30.630 --> 00:35:35.890
We're going to look at the output of Systrace
to try and understand what was going on.

00:35:35.890 --> 00:35:39.369
So let me find the trace.

00:35:39.369 --> 00:35:46.170
Now, this one -- there we go.

00:35:46.170 --> 00:35:47.170
So looks the same.

00:35:47.170 --> 00:35:52.800
But already, when you look at surface flinger,
you can see that all the frames that we post,

00:35:52.800 --> 00:35:53.800
it's not regular anymore.

00:35:53.800 --> 00:35:54.869
We have those big gaps.

00:35:54.869 --> 00:36:00.970
And if we zoom in on the application I was
running, you can see -- and we look for drawing,

00:36:00.970 --> 00:36:04.520
so here we are drawing, you can see that we're
spending only 4 milliseconds drawing.

00:36:04.520 --> 00:36:06.100
So the app should be smooth.

00:36:06.100 --> 00:36:07.800
The problem is not in our drawing code.

00:36:07.800 --> 00:36:12.859
But if you look at what's happening between
two frames, we see this huge block called

00:36:12.859 --> 00:36:14.580
deliver input event.

00:36:14.580 --> 00:36:18.281
So because it's a ListView and I was calling
it with my finger on screen, that means we

00:36:18.281 --> 00:36:21.060
were spending time in the dispatching of the
touch events.

00:36:21.060 --> 00:36:26.250
In the case of a ListView, we called the adapter
method called get view while you are scrolling

00:36:26.250 --> 00:36:27.250
the screen.

00:36:27.250 --> 00:36:29.810
So chances are that's where we are spending
most of our time.

00:36:29.810 --> 00:36:30.950
Here, we can go further.

00:36:30.950 --> 00:36:36.990
If we zoom in on this block here, there's
a tiny bar, maybe it's hard to see, but you

00:36:36.990 --> 00:36:38.680
can see the state of the thread.

00:36:38.680 --> 00:36:43.160
So here at the beginning for about 5 milliseconds,
my process was running.

00:36:43.160 --> 00:36:44.920
I was actually running code.

00:36:44.920 --> 00:36:47.060
And then after that, it's blank.

00:36:47.060 --> 00:36:51.520
That means that my thread was waiting on something,
my process was sleeping.

00:36:51.520 --> 00:36:56.920
So what we can do is go all the way to the
top and look at the CPU and see what the CPU

00:36:56.920 --> 00:36:58.240
was doing at the time.

00:36:58.240 --> 00:37:03.990
Here we can see that a thread called binder
1 was doing a lot of work.

00:37:03.990 --> 00:37:07.589
At the bottom, you can see the thread ID for
binder 1.

00:37:07.589 --> 00:37:11.520
And then you can go back to the shell, and
using ADP shell PS, so where you can see all

00:37:11.520 --> 00:37:16.480
the processes running, and PS-T to see all
the threads running, you can identify that

00:37:16.480 --> 00:37:17.480
thread.

00:37:17.480 --> 00:37:22.260
And in this particular case, the thread was
identified as a thread that belongs to the

00:37:22.260 --> 00:37:23.500
contacts process.

00:37:23.500 --> 00:37:27.800
And it was slow because my application was
making a query for the content provider of

00:37:27.800 --> 00:37:32.490
contacts between -- in get view every other
frame.

00:37:32.490 --> 00:37:36.260
So that's what was blocking the application.

00:37:36.260 --> 00:37:41.281
And usually when you see -- when you identify
an issue like this, you can stop using Systrace,

00:37:41.281 --> 00:37:43.640
and then you can use Traceview.

00:37:43.640 --> 00:37:45.859
So how many of you have used Traceview before?

00:37:45.859 --> 00:37:46.900
Just raise your hand.

00:37:46.900 --> 00:37:47.900
Okay.

00:37:47.900 --> 00:37:49.070
That's pretty good.

00:37:49.070 --> 00:37:50.650
Everybody should use Traceview.

00:37:50.650 --> 00:37:55.030
That means you either don't care about performance
or your application is awesome, in which case,

00:37:55.030 --> 00:37:56.030
congratulations.

00:37:56.030 --> 00:37:59.390
[ Laughter ]
&gt;&gt;Romain Guy: I wish all my applications were

00:37:59.390 --> 00:38:00.390
that good.

00:38:00.390 --> 00:38:01.390
Let's see.

00:38:01.390 --> 00:38:03.640
So it's a trace I captured in the same application.

00:38:03.640 --> 00:38:09.900
But you can invoke Traceview pretty easily
yourself from the DMS or Eclipse.

00:38:09.900 --> 00:38:14.710
So this is what it looks like.

00:38:14.710 --> 00:38:21.410
When you see a blank section in Traceview,
it means that your thread, your application

00:38:21.410 --> 00:38:22.440
was not running.

00:38:22.440 --> 00:38:26.030
So if you see one of those things, you can
go in Systrace and Systrace will tell you

00:38:26.030 --> 00:38:28.210
what's going on elsewhere in the system.

00:38:28.210 --> 00:38:33.410
So we've already identified that we are waiting
on this binder 1, we're waiting on the contacts

00:38:33.410 --> 00:38:34.410
process.

00:38:34.410 --> 00:38:38.920
If we look at this block and we navigate through
the parents, we can see that we were doing

00:38:38.920 --> 00:38:40.890
a content resolver query.

00:38:40.890 --> 00:38:46.720
In my list activity, I have something called
a slow adapter that makes it easy to find

00:38:46.720 --> 00:38:47.720
the bug.

00:38:47.720 --> 00:38:53.059
So in the get view method, I was doing a query,
calling a query, and we were spending about

00:38:53.059 --> 00:39:01.320
-- oops, sorry -- we were spending about 52
milliseconds per call was spent doing the

00:39:01.320 --> 00:39:02.320
query.

00:39:02.320 --> 00:39:07.260
So, obviously, I should stop querying the
database on every frame.

00:39:07.260 --> 00:39:13.490
&gt;&gt;Chet Haase: So there's an interesting relationship
between Traceview and Systrace.

00:39:13.490 --> 00:39:19.290
Actually, Traceview kind of inspired at least
my desire for something like Systrace, which,

00:39:19.290 --> 00:39:20.290
fortunately, people wrote.

00:39:20.290 --> 00:39:21.589
That was great.

00:39:21.589 --> 00:39:25.079
Because sometimes you look in Traceview and
you say, well, actually my stuff is not taking

00:39:25.079 --> 00:39:29.329
very long, but in the middle of a method call
which I know for sure is not doing anything,

00:39:29.329 --> 00:39:32.800
my thread is just swapped out and there's
something else going on in the system maybe

00:39:32.800 --> 00:39:33.800
regularly.

00:39:33.800 --> 00:39:37.010
And Systrace allows you to see what that other
thing is that's happening.

00:39:37.010 --> 00:39:41.460
Maybe you have a service running somewhere
that is syncing on a regular basis and, basically,

00:39:41.460 --> 00:39:43.400
stealing CPU cycles away from you.

00:39:43.400 --> 00:39:48.300
So they're both useful in their own way, we
don't do the per-method tracing in Systrace.

00:39:48.300 --> 00:39:51.090
It's more to get a system-wide overview of
what's going on.

00:39:51.090 --> 00:39:55.390
Traceview is really important to use to see
what's actually going on in the methods of

00:39:55.390 --> 00:39:56.990
your --
&gt;&gt;Romain Guy: So and all the vsync and triple

00:39:56.990 --> 00:40:00.880
buffering work was actually made possible
thanks to Systrace.

00:40:00.880 --> 00:40:01.930
So just a reminder.

00:40:01.930 --> 00:40:04.470
Systrace by default will capture five seconds
of traces.

00:40:04.470 --> 00:40:06.780
You can change that as a comment line argument
you can use.

00:40:06.780 --> 00:40:09.240
It will output an HTML file.

00:40:09.240 --> 00:40:11.760
The UI is not that great right now.

00:40:11.760 --> 00:40:13.400
But we will improve that.

00:40:13.400 --> 00:40:17.540
And the benefit of the HTML5 is that you can
attach it to a bug report, send it by email.

00:40:17.540 --> 00:40:19.230
You don't need a special tool to visualize
it.

00:40:19.230 --> 00:40:23.860
You just open the HTML file in Chrome and
you're good to go.

00:40:23.860 --> 00:40:29.420
I mentioned before, window composition, I
made a distinction between the GPU composition

00:40:29.420 --> 00:40:31.710
with frame buffers and overlays.

00:40:31.710 --> 00:40:36.329
So you can use a tool called dumpsys surface
flinger to see the state of overlays and frame

00:40:36.329 --> 00:40:37.329
buffers in the system.

00:40:37.329 --> 00:40:41.680
If you run that command, and I'm not going
to run it because we're running out of time,

00:40:41.680 --> 00:40:44.800
you're going to see, you're going to get a
huge amount of logs.

00:40:44.800 --> 00:40:48.240
And somewhere towards the end, you're going
to see a little table that's going to list

00:40:48.240 --> 00:40:52.330
all the windows currently visible on screen
and where they are not, they are on overlays.

00:40:52.330 --> 00:40:56.220
Here I wrote a simple application, the same
application I showed you in Systrace.

00:40:56.220 --> 00:40:59.500
You can see we have the status bar and we
have the navigation bar at the bottom with

00:40:59.500 --> 00:41:01.550
the home button and the back button.

00:41:01.550 --> 00:41:03.030
And everything is in an overlay.

00:41:03.030 --> 00:41:04.160
Everything is great.

00:41:04.160 --> 00:41:06.800
We're not using the GPU for the window composition.

00:41:06.800 --> 00:41:10.020
You have access to the entire GPU inside your
application.

00:41:10.020 --> 00:41:17.380
If I modify the application to invoke a popup
window, then we are running out of overlays.

00:41:17.380 --> 00:41:23.310
That was on the Nexus 7, when we run out of
overlays, we have to revert back to GPU composition.

00:41:23.310 --> 00:41:26.600
So suddenly, I have three windows that are
in frame buffers.

00:41:26.600 --> 00:41:31.590
So the time it takes to composite those three
windows together is taking away from my application.

00:41:31.590 --> 00:41:36.470
So here, if I see that in my application and
I need the screen to be really fast, you should

00:41:36.470 --> 00:41:38.569
think about whether or not you need that extra
window.

00:41:38.569 --> 00:41:42.810
Like, maybe you can turn that window into
a view in the main activity.

00:41:42.810 --> 00:41:45.620
Now, be very careful when you use this tool,
dumpsys surface flinger.

00:41:45.620 --> 00:41:50.830
We have a special application after the application
is done drawing, everything reverts back to

00:41:50.830 --> 00:41:51.830
overlays.

00:41:51.830 --> 00:41:54.650
Make sure that you run this comment as the
application is drawing, when you're scrolling,

00:41:54.650 --> 00:42:01.550
when there's an animation going on -- what
do you mean the other way around?

00:42:01.550 --> 00:42:02.550
Sorry, yes.

00:42:02.550 --> 00:42:05.170
I'm glad that we have a surface flinger guy
in the room.

00:42:05.170 --> 00:42:07.930
It reverses to frame buffers when you're done
drawing.

00:42:07.930 --> 00:42:11.770
And there's a good reason for that, basically,
to save battery.

00:42:11.770 --> 00:42:16.090
So take away, make sure that your application
is drawing when you're running the command

00:42:16.090 --> 00:42:18.520
or the information you're going to get is
not going to be very useful.

00:42:18.520 --> 00:42:20.980
That's what I just said.

00:42:20.980 --> 00:42:22.420
So a few other tools you should use.

00:42:22.420 --> 00:42:24.650
Traceview, we just saw Traceview.

00:42:24.650 --> 00:42:28.890
Heirarchy viewer, for those of you who don't
know what this tool is about, you can check

00:42:28.890 --> 00:42:32.099
out the documentation on developer.android.com.

00:42:32.099 --> 00:42:36.119
And if you're not aware of it, this tool will
not work -- it's very useful to develop your

00:42:36.119 --> 00:42:38.470
UI, but it will not work on retail devices.

00:42:38.470 --> 00:42:42.040
So if you go to the store and buy a device,
Hierarchy will not work.

00:42:42.040 --> 00:42:46.440
So on GitHub, I put a little library called
U server.

00:42:46.440 --> 00:42:49.090
It's one class, one Java file that you put
in your project.

00:42:49.090 --> 00:42:50.290
Just read your documentation.

00:42:50.290 --> 00:42:53.650
You have to add about two lines per activity
to make it work.

00:42:53.650 --> 00:42:58.960
That will enable the use of hierarchy in your
application.

00:42:58.960 --> 00:43:02.070
So.

00:43:02.070 --> 00:43:06.080
Tracer for OpenGL, if you're writing applications,
you can look at it.

00:43:06.080 --> 00:43:10.010
If you're using hardware acceleration in your
application and your frame rate is choppy,

00:43:10.010 --> 00:43:15.390
you can take a look tracer for OpenGL ES to
identify what view is taking so much time.

00:43:15.390 --> 00:43:18.599
There was a demo of it earlier today.

00:43:18.599 --> 00:43:19.599
Allocation tracker.

00:43:19.599 --> 00:43:21.790
How many of you have used allocation tracker
before?

00:43:21.790 --> 00:43:23.330
That's awesome.

00:43:23.330 --> 00:43:24.460
The number is increasing every year.

00:43:24.460 --> 00:43:25.460
I like that.

00:43:25.460 --> 00:43:32.119
It's funny, as I was taking this screen shot
a couple weeks before we finished Jelly Bean,

00:43:32.119 --> 00:43:36.430
I identified an allocation that the framework
was doing several times per frame.

00:43:36.430 --> 00:43:37.990
&gt;&gt;Chet Haase: I don't know where that came
from.

00:43:37.990 --> 00:43:39.040
&gt;&gt;Romain Guy: That's okay.

00:43:39.040 --> 00:43:43.480
We're just allocating dozens of exceptions
in all their strings, per frame.

00:43:43.480 --> 00:43:46.440
[ Laughter ]
&gt;&gt;Chet Haase: It was exceptional coding.

00:43:46.440 --> 00:43:48.790
&gt;&gt;Romain Guy: It's good that we have tools.

00:43:48.790 --> 00:43:53.819
We have two types of tools, this one and this
one.

00:43:53.819 --> 00:43:55.599
[ Laughter ]
[ Applause ]

00:43:55.599 --> 00:43:59.180
&gt;&gt;Romain Guy: All right.

00:43:59.180 --> 00:44:02.680
Now the part that you're probably most interested
in, tips and tricks.

00:44:02.680 --> 00:44:06.160
What can you do in your application to solve
the problems that you identified with the

00:44:06.160 --> 00:44:07.160
tools.

00:44:07.160 --> 00:44:08.900
So these are the things that you can fix.

00:44:08.900 --> 00:44:11.319
You can make the frame rate more consistent.

00:44:11.319 --> 00:44:12.819
You can lower the latency.

00:44:12.819 --> 00:44:16.079
You can increase the speed of drawing display
list.

00:44:16.079 --> 00:44:20.450
You can increase the speed of updating display
list, and, finally, you can free up the GPU

00:44:20.450 --> 00:44:23.090
for your own application.

00:44:23.090 --> 00:44:24.090
So first one.

00:44:24.090 --> 00:44:27.079
&gt;&gt;Chet Haase: Is about allocations, related
to the allocation tracker.

00:44:27.079 --> 00:44:30.560
&gt;&gt;Romain Guy: How many of you have used this
key word before?

00:44:30.560 --> 00:44:32.480
&gt;&gt;Chet Haase: Okay.

00:44:32.480 --> 00:44:34.260
Seem to know how to use it.

00:44:34.260 --> 00:44:40.720
The best way to use it, in fact, is like this.

00:44:40.720 --> 00:44:41.780
Don't use this.

00:44:41.780 --> 00:44:45.160
In particular, obviously, we need to allocate
objects.

00:44:45.160 --> 00:44:49.900
Don't do it during an animation or during
your interloop or during performance-sensitive

00:44:49.900 --> 00:44:52.069
operations or methods of these.

00:44:52.069 --> 00:44:55.970
Because, basically, even though that looks
like a really small temporary object, it may

00:44:55.970 --> 00:45:01.390
take up significant time actually creating
the object, and, more importantly, it creates

00:45:01.390 --> 00:45:04.310
garbage that will have to be collected at
some point in time.

00:45:04.310 --> 00:45:08.119
We put a fair amount of effort -- besides
that previous bug that we were talking about

00:45:08.119 --> 00:45:13.030
-- into making sure that we are not doing
allocations in the middle of our animation

00:45:13.030 --> 00:45:18.480
routines or our rendering logic, because we
don't want to cause jank in the middle of

00:45:18.480 --> 00:45:19.480
an animation.

00:45:19.480 --> 00:45:23.420
And one of the ways that that happens regularly
is by creating little bits of garbage here

00:45:23.420 --> 00:45:27.380
and there and then in the middle of that 500
millisecond animation, you're going to pause

00:45:27.380 --> 00:45:31.310
for four 4 milliseconds, which may be enough
to shove you over the frame barrier.

00:45:31.310 --> 00:45:33.200
So avoid allocating if you can.

00:45:33.200 --> 00:45:38.190
There's various techniques for this, transient,
static objects that you use, pass around,

00:45:38.190 --> 00:45:39.190
or whatever.

00:45:39.190 --> 00:45:42.079
But try to avoid it when you need to.

00:45:42.079 --> 00:45:45.680
This will give you more consistent frame rate
overall, because, basically, you avoid those

00:45:45.680 --> 00:45:46.680
hiccups.

00:45:46.680 --> 00:45:51.440
&gt;&gt;Romain Guy: The next big thing you can do
is stop writing code.

00:45:51.440 --> 00:45:53.470
Just do as little as you can.

00:45:53.470 --> 00:45:54.470
It's pretty obvious.

00:45:54.470 --> 00:45:55.839
But we had a great example.

00:45:55.839 --> 00:46:00.500
In one of our applications that shipped on
Jelly Bean, we identified a performance issue.

00:46:00.500 --> 00:46:05.980
What was happening was, in the get view method,
it first was creating an object.

00:46:05.980 --> 00:46:11.240
But the constructor in that object was doing
about 200 string comparisons.

00:46:11.240 --> 00:46:14.829
And we were actually spending most of our
time doing the string comparisons instead

00:46:14.829 --> 00:46:16.589
of drawing or doing the layout.

00:46:16.589 --> 00:46:19.930
And, you know, it looks innocent when you
write the code.

00:46:19.930 --> 00:46:24.160
And over the years, like, your coding will
be used in different places or differently

00:46:24.160 --> 00:46:25.900
than you intended it to be.

00:46:25.900 --> 00:46:27.710
So be very careful.

00:46:27.710 --> 00:46:28.859
Use Traceview, use Systrace.

00:46:28.859 --> 00:46:32.280
If you do so, you're going to improve the
consistency of the frame rate and you're going

00:46:32.280 --> 00:46:33.700
to lower latency.

00:46:33.700 --> 00:46:38.810
&gt;&gt;Chet Haase: Choreographer is a new class
that was introduced, new API that was introduced

00:46:38.810 --> 00:46:40.599
around vsync capabilities.

00:46:40.599 --> 00:46:44.050
Most of its capabilities are actually under
the hoods.

00:46:44.050 --> 00:46:48.339
It's basically the logic in charge of making
sure that everybody's actually running on

00:46:48.339 --> 00:46:53.020
that vsync pulse, the animations, the input
events, and the rendering stuff.

00:46:53.020 --> 00:46:56.470
So you don't topic talk to choreographer directly,
but you can.

00:46:56.470 --> 00:47:01.099
If you are using the system in an atypical
way, then you can actually link into the vsync

00:47:01.099 --> 00:47:03.630
system that everybody else --
&gt;&gt;Romain Guy: Just like the tools we showed

00:47:03.630 --> 00:47:06.329
you, choreographer, that's what we used in
the platform.

00:47:06.329 --> 00:47:11.940
So all the vsync work we talked about, the
UI toolkit uses choreographer to make it happen.

00:47:11.940 --> 00:47:17.410
&gt;&gt;Chet Haase: And the way that you would hook
into this, actually, you hook into it automatically,

00:47:17.410 --> 00:47:19.900
just through using the mechanisms of the platform.

00:47:19.900 --> 00:47:23.033
If you're using animators, those animators
are actually running are actually running

00:47:23.033 --> 00:47:25.099
on the vsync pulse provided by choreographer.

00:47:25.099 --> 00:47:26.370
You don't need to do anything.

00:47:26.370 --> 00:47:30.780
But if you're doing something else, if you're
doing your own custom runnable animations

00:47:30.780 --> 00:47:35.260
that are getting posted later, you can hook
into the same vsync pulse by calling methods

00:47:35.260 --> 00:47:37.770
such as the new post invalidate on animation.

00:47:37.770 --> 00:47:42.060
&gt;&gt;Romain Guy: And post invalidate on animation,
and this one, post on animation, are available

00:47:42.060 --> 00:47:43.460
in the support library.

00:47:43.460 --> 00:47:47.440
So on previous versions of the platform, they
will behave just like a post runnable or post

00:47:47.440 --> 00:47:48.440
invalidate.

00:47:48.440 --> 00:47:51.030
And on Jelly Bean, you'll automatically benefit
from the vsync.

00:47:51.030 --> 00:47:57.349
&gt;&gt;Chet Haase: And there's also a way to get
-- to register a call back that gets called

00:47:57.349 --> 00:47:58.349
on the next frame.

00:47:58.349 --> 00:47:59.490
All of these are one shot deals.

00:47:59.490 --> 00:48:02.320
You basically post a request, you get a call
back.

00:48:02.320 --> 00:48:05.700
If you want to be called back on a regular
basis, you would post another one.

00:48:05.700 --> 00:48:09.230
&gt;&gt;Romain Guy: This one in particular post
frame call back if you're writing a game or

00:48:09.230 --> 00:48:13.400
some OpenGL animation, this is probably what
the -- the API you want to use.

00:48:13.400 --> 00:48:15.840
It's completely independent from view.

00:48:15.840 --> 00:48:18.230
So just take a look at it and use it.

00:48:18.230 --> 00:48:21.390
I think this one, though, is not in the support
library.

00:48:21.390 --> 00:48:26.170
&gt;&gt;Chet Haase: So using choreographer helps
give you that consistent frame rate because

00:48:26.170 --> 00:48:31.609
now everything in the universe is synced on
than vsync pulse for obvious and wonderful

00:48:31.609 --> 00:48:32.609
reasons.

00:48:32.609 --> 00:48:36.359
And lower latency because then you're reducing
the amount of time that you're actually spending

00:48:36.359 --> 00:48:37.359
in the frame.

00:48:37.359 --> 00:48:41.210
You're doing things as soon up-front during
the refresh frame as possible.

00:48:41.210 --> 00:48:42.650
&gt;&gt;Romain Guy: Layers.

00:48:42.650 --> 00:48:43.750
Use hardware layers.

00:48:43.750 --> 00:48:46.240
We talked about layers a lot last year.

00:48:46.240 --> 00:48:51.490
So if you go back to our Google I/O 2011 talk,
Android accelerated rendering.

00:48:51.490 --> 00:48:55.530
&gt;&gt;Chet Haase: Accelerated --
&gt;&gt;Romain Guy: The talk we gave last year,

00:48:55.530 --> 00:48:57.160
we went on and on and on about layers.

00:48:57.160 --> 00:49:01.069
So if you want to know more about layers,
go watch that talk.

00:49:01.069 --> 00:49:04.970
Basically, what you want to do if you're writing
animations and you're using the view property

00:49:04.970 --> 00:49:08.960
animator, so first of all, the view property
animator has tons of optimizations under the

00:49:08.960 --> 00:49:11.599
hood that we cannot apply with normal animations.

00:49:11.599 --> 00:49:13.650
So you get a lot of benefits from using it.

00:49:13.650 --> 00:49:18.150
And we introduced -- well, Chet introduced
a new API this time around called withlayer.

00:49:18.150 --> 00:49:21.589
We will automatically set up a layer on your
view at the beginning of the animation, and

00:49:21.589 --> 00:49:23.930
we will remove it at the end of the animation.

00:49:23.930 --> 00:49:27.559
So do not go wild and use withlayer on any
view.

00:49:27.559 --> 00:49:30.930
Try to do that on large views or complex views
that have tons of children.

00:49:30.930 --> 00:49:37.329
But don't do that on a button or just a simple
text view.

00:49:37.329 --> 00:49:38.500
So consistent frame rate.

00:49:38.500 --> 00:49:40.480
Faster display drawing.

00:49:40.480 --> 00:49:41.480
Clipping.

00:49:41.480 --> 00:49:42.480
Clipping is very important.

00:49:42.480 --> 00:49:44.860
The UI toolkit, does a lot of clipping for
you.

00:49:44.860 --> 00:49:50.630
It's one of the biggest optimizations that
we have and that you have at your disposal

00:49:50.630 --> 00:49:52.480
when you're writing custom code.

00:49:52.480 --> 00:49:57.099
The first part of clipping is to -- is about
doing proper invalidations.

00:49:57.099 --> 00:50:00.720
So it's very tempting when something changes
in the view to just call view.invalidate.

00:50:00.720 --> 00:50:01.720
It's easy.

00:50:01.720 --> 00:50:02.720
It works.

00:50:02.720 --> 00:50:07.609
Now, what we want you to do is call invalidate
and tell us what part of the view really needs

00:50:07.609 --> 00:50:08.609
to be redrawn.

00:50:08.609 --> 00:50:11.740
Because if you do so, we can avoid a lot of
work.

00:50:11.740 --> 00:50:16.190
So if you call invalidate on a view, so let's
we have the view at the top that's the tree

00:50:16.190 --> 00:50:21.330
of display list for the view and its children,
and you call invalidate, we'll have to redraw

00:50:21.330 --> 00:50:22.330
everything.

00:50:22.330 --> 00:50:27.310
It's a lot of work, and in the case of a ListView,
for example, or a complex view, it can take

00:50:27.310 --> 00:50:28.310
a lot of time.

00:50:28.310 --> 00:50:32.631
Now, if you do an invalidate with a specific
(indiscernible), what we can do is we can

00:50:32.631 --> 00:50:38.120
reject views on the display list that are
outside of this (indiscernible), and we do

00:50:38.120 --> 00:50:40.420
a lot less work.

00:50:40.420 --> 00:50:45.270
And in very complex applications, when you
have hundreds of views, it can be very, very

00:50:45.270 --> 00:50:48.710
important, because we're going to do that
rejection work as early as possible in the

00:50:48.710 --> 00:50:54.280
tree so we can get rid of most of the views
and just ignore them completely.

00:50:54.280 --> 00:50:59.290
So if you're spending too much time updating
display list or drawing display list, you

00:50:59.290 --> 00:51:01.309
can do that.

00:51:01.309 --> 00:51:05.510
And if you want to know if you're doing things
right, go to developer options.

00:51:05.510 --> 00:51:09.160
There is a new option called show GPU view
updates.

00:51:09.160 --> 00:51:13.010
If you turn that on, I hope you're not epileptic.

00:51:13.010 --> 00:51:18.660
The system is going to Flash in red quickly,
the regions of the screen that we redraw.

00:51:18.660 --> 00:51:22.470
It's very useful to see exactly what your
application is doing.

00:51:22.470 --> 00:51:27.810
&gt;&gt;Chet Haase: So this is a tip that came out
of one of the applications that we were working

00:51:27.810 --> 00:51:29.410
on during Jelly Bean that's.

00:51:29.410 --> 00:51:31.010
&gt;&gt;Romain Guy: Google Now.

00:51:31.010 --> 00:51:32.940
&gt;&gt;Chet Haase: Yes, that one.

00:51:32.940 --> 00:51:35.930
So we're a 2D API.

00:51:35.930 --> 00:51:38.119
We have no idea of the structure of your application.

00:51:38.119 --> 00:51:40.770
All we know is the rendering commands that
you give us.

00:51:40.770 --> 00:51:44.780
So if you have a view that's really complex
and you're drawing lines and text and bit

00:51:44.780 --> 00:51:47.680
maps and all the stuff in the view and then
you have another view that's drawn directly

00:51:47.680 --> 00:51:50.480
on top of it, what -- we're going to draw
the first one, and then we're going to draw

00:51:50.480 --> 00:51:51.480
the second one.

00:51:51.480 --> 00:51:55.150
And the user is not going to see most of what
we spent that time drawing for the first view

00:51:55.150 --> 00:51:57.059
because it's covered by the second view.

00:51:57.059 --> 00:52:00.790
So the idea here is, you have that information
about your activity.

00:52:00.790 --> 00:52:01.790
We don't.

00:52:01.790 --> 00:52:02.829
Well, you can tell us about it.

00:52:02.829 --> 00:52:07.170
So you can actually tell us the information
about what's being clipped out.

00:52:07.170 --> 00:52:10.819
So, basically, don't waste our time trying
to draw that stuff if it's not going to show

00:52:10.819 --> 00:52:12.180
up to the user anyway.

00:52:12.180 --> 00:52:13.691
So in this case, there are two cards here.

00:52:13.691 --> 00:52:16.760
The first one you only see that header information.

00:52:16.760 --> 00:52:19.750
And the second one, you see all of the content
in it.

00:52:19.750 --> 00:52:23.860
So maybe in the first one, you can actually
just tell us, you know, what, don't draw the

00:52:23.860 --> 00:52:27.859
stuff beyond here, because we're going to
-- you're going to waste your time doing that

00:52:27.859 --> 00:52:28.859
anyway.

00:52:28.859 --> 00:52:30.970
So the red region that we're showing here
is the overdraw.

00:52:30.970 --> 00:52:35.250
It's the time that we wasted drawing all this
information that didn't appear to the user.

00:52:35.250 --> 00:52:40.230
The easiest way to do this is to simply tell
us to clip out that information.

00:52:40.230 --> 00:52:43.490
So you know that you're being displayed with
something else on top of you.

00:52:43.490 --> 00:52:46.600
You're only in header mode where you only
want to show the stuff at the top.

00:52:46.600 --> 00:52:49.500
Set a cliprect and then go ahead and draw
your content.

00:52:49.500 --> 00:52:52.460
You're going to spend a little bit of time
drawing that content.

00:52:52.460 --> 00:52:54.809
So maybe the simpler logic is, you know, that's
okay.

00:52:54.809 --> 00:52:56.079
You are spending a little bit of time.

00:52:56.079 --> 00:53:00.010
But in the meantime, you've given us a really
important piece of information that when we

00:53:00.010 --> 00:53:04.140
go to talk to OpenGL and say render the following
commands, we're going to check it against

00:53:04.140 --> 00:53:08.670
the cliprect and clipreject it immediately
and just get rid of that information without

00:53:08.670 --> 00:53:10.810
actually bothering to render it.

00:53:10.810 --> 00:53:14.960
So, again, you set the cliprect.

00:53:14.960 --> 00:53:16.900
And we're not drawing the rest of the stuff
in it.

00:53:16.900 --> 00:53:19.750
We're just that header, and then we draw the
other thing on top of it.

00:53:19.750 --> 00:53:24.090
And it gave this one application a big performance
boost, because they had several of these stacked

00:53:24.090 --> 00:53:28.130
cards, and they were basically wasting a lot
of time drawing information that never appeared

00:53:28.130 --> 00:53:29.140
to the user.

00:53:29.140 --> 00:53:35.190
So make the display list issuing much faster
by simply not having us do stuff that really

00:53:35.190 --> 00:53:36.190
doesn't matter.

00:53:36.190 --> 00:53:37.190
&gt;&gt;Romain Guy: And you can go even further.

00:53:37.190 --> 00:53:40.210
If you use cliprect, there's a method on Canvas
called quickreject.

00:53:40.210 --> 00:53:45.450
You pass a rectangle and the method will tell
you whether or not that rectangle will be

00:53:45.450 --> 00:53:49.280
visible on screen when it comes time to draw.

00:53:49.280 --> 00:53:53.140
So this is what we use a lot inside the UI
toolkit to know whether or not we have to

00:53:53.140 --> 00:53:54.140
draw a view.

00:53:54.140 --> 00:53:58.349
But if you set your own cliprect, you can
avoid running extra code in your application

00:53:58.349 --> 00:54:00.030
by just checking the state of the cliprect.

00:54:00.030 --> 00:54:02.300
So, for instance, here we have a list of items.

00:54:02.300 --> 00:54:04.309
We have set a cliprect.

00:54:04.309 --> 00:54:07.819
And we can check whether each item will be
visible or not.

00:54:07.819 --> 00:54:10.210
If the item is not visible, we can skip it
entirely.

00:54:10.210 --> 00:54:14.160
So we're going to avoid doing extra work,
running Java code that will generate drawing

00:54:14.160 --> 00:54:17.950
commands that we'll have to queue in the display
list and so on and so on.

00:54:17.950 --> 00:54:20.260
Our displays have a lot of optimizations around
clipping.

00:54:20.260 --> 00:54:24.920
We're going to try to do clipping ahead of
time so that we don't have to do it on every

00:54:24.920 --> 00:54:25.920
frame.

00:54:25.920 --> 00:54:30.240
But by doing this, you're going to avoid running
extra Java code, which can matter a lot.

00:54:30.240 --> 00:54:33.859
So if you do a quick reject, we're going to
make display list drawing faster, and updating

00:54:33.859 --> 00:54:35.300
display list will also be faster.

00:54:35.300 --> 00:54:39.549
&gt;&gt;Chet Haase: So this is an optimization that
came out of another application that shipped

00:54:39.549 --> 00:54:40.549
on the device.

00:54:40.549 --> 00:54:45.010
This came from the contacts application, where
they were having a janky experience when animating

00:54:45.010 --> 00:54:46.010
one of these cards.

00:54:46.010 --> 00:54:49.579
You'd click on the icon, the thumbnail, and
it would animate up.

00:54:49.579 --> 00:54:53.050
And you'd get this nice experience where you
see the activity below, and then you get this

00:54:53.050 --> 00:54:57.650
sort of translucent, dim thing on top of that,
and then you get the contacts in full view.

00:54:57.650 --> 00:54:59.480
And when it was just static, it was great.

00:54:59.480 --> 00:55:01.920
When it was animating into view, it was horrible.

00:55:01.920 --> 00:55:05.050
And we used Systrace and looked at what was
going on in surface flinger to see where the

00:55:05.050 --> 00:55:06.150
hiccups why coming from.

00:55:06.150 --> 00:55:09.200
It turns out it was coming from dim window.

00:55:09.200 --> 00:55:14.030
So if you set an attribute on window manager
and the layout params.

00:55:14.030 --> 00:55:15.250
You say dim behind.

00:55:15.250 --> 00:55:19.800
Then, basically, the thing behind your current
window will dim, you'll get this nice translucent

00:55:19.800 --> 00:55:20.800
effect.

00:55:20.800 --> 00:55:22.950
And it's great if all you're doing is looking
at this statically.

00:55:22.950 --> 00:55:26.460
But if you're actually running a lot of code
at the same time, in this case, the contacts

00:55:26.460 --> 00:55:31.000
application was running an animation in the
view on the top, then, basically, you're asking

00:55:31.000 --> 00:55:36.710
the GPU to do a lot of work because you're
shoved into that frame buffer versus overlay

00:55:36.710 --> 00:55:38.020
situation.

00:55:38.020 --> 00:55:41.849
So all of a sudden now we have the GPU compositing
frame buffers together to put them into an

00:55:41.849 --> 00:55:44.510
overlay to get composited onto the screen.

00:55:44.510 --> 00:55:48.300
And at the same time, you're doing a lot of
work on the GPU just to draw your application

00:55:48.300 --> 00:55:51.380
because you're trying to animate this thing
in at the time.

00:55:51.380 --> 00:55:52.730
There was a very easy fix to this.

00:55:52.730 --> 00:55:56.560
It was a very nonobvious problem until we
looked at Systrace output and saw what was

00:55:56.560 --> 00:55:57.560
going on.

00:55:57.560 --> 00:55:59.799
But there's fortunately a very easy fix.

00:55:59.799 --> 00:56:03.550
Don't use dim window if you're running into
this sort of situation, especially when running

00:56:03.550 --> 00:56:05.510
an animation on that thing on top.

00:56:05.510 --> 00:56:10.020
Instead, you can simply set a background that
is the color or the translucent color that

00:56:10.020 --> 00:56:11.020
you need.

00:56:11.020 --> 00:56:16.010
You can get the exact same visual effect without
actually introducing that extra window into

00:56:16.010 --> 00:56:19.890
the hierarchy that tossed everything into
frame buffers and caused the problem to begin

00:56:19.890 --> 00:56:20.890
with.

00:56:20.890 --> 00:56:23.970
So in this case, you're going to get faster
display list drawing, because we're simply

00:56:23.970 --> 00:56:30.859
not doing as much stuff in parallel with the
surface flinger also doing stuff on the given.

00:56:30.859 --> 00:56:33.700
And, again, you'll get faster composition.

00:56:33.700 --> 00:56:38.310
So I think the takeaway here is, obviously,
especially in America, with our love of food

00:56:38.310 --> 00:56:41.340
--
&gt;&gt;Romain Guy: I have to say, this slide is

00:56:41.340 --> 00:56:42.820
entirely his fault, okay?

00:56:42.820 --> 00:56:44.420
&gt;&gt;Chet Haase: I will take the credit.

00:56:44.420 --> 00:56:49.069
I'm okay with that, because I have to own
it.

00:56:49.069 --> 00:56:50.470
Spread the word.

00:56:50.470 --> 00:56:52.560
[ Laughter ]
[ Applause ]

00:56:52.560 --> 00:56:56.730
&gt;&gt;Chet Haase: Thank you.

00:56:56.730 --> 00:57:00.750
[ Applause ]
&gt;&gt;Romain Guy: If you want to know more about

00:57:00.750 --> 00:57:04.240
performance in rendering and graphics, check
out our Google I/O 2011 talk.

00:57:04.240 --> 00:57:10.040
And you can also go on parleys.com, where
we have a bunch of talks, videos, and slides

00:57:10.040 --> 00:57:12.460
where we also touch those subjects.

00:57:12.460 --> 00:57:14.630
And we have exactly two minutes left for Q&amp;A.

00:57:14.630 --> 00:57:18.730
If you have a question, walk up to the mike,
and we'll try to answer it.

00:57:18.730 --> 00:57:23.470
&gt;&gt;Chet Haase: We'll probably be -- we're going
to be doing -- watching some talks this afternoon.

00:57:23.470 --> 00:57:25.410
Otherwise, in and out of Android office hours.

00:57:25.410 --> 00:57:28.280
&gt;&gt;Romain Guy: You should go to the next session
by Jeff Sharkey.

00:57:28.280 --> 00:57:29.589
You will learn even more about performance.

00:57:29.589 --> 00:57:30.589
&gt;&gt;Chet Haase: Yes.

00:57:30.589 --> 00:57:31.589
Yes.

00:57:31.589 --> 00:57:32.589
&gt;&gt;&gt; So one question is, I've got a ListView
with a ton of images.

00:57:32.589 --> 00:57:33.589
They're drawing.

00:57:33.589 --> 00:57:36.720
And I think that the drawing of those bit
maps are slow.

00:57:36.720 --> 00:57:39.700
And so I have two questions.

00:57:39.700 --> 00:57:46.400
Number one is, is there a way -- I heard that
compressed textures are faster to draw, but

00:57:46.400 --> 00:57:50.150
I had bit maps that I'm passing as bit map
drawables to an image view.

00:57:50.150 --> 00:57:54.340
Is there any way to use compress textures
there?

00:57:54.340 --> 00:57:55.430
&gt;&gt;Romain Guy: No.

00:57:55.430 --> 00:57:57.340
We won't be able to use compress textures.

00:57:57.340 --> 00:58:03.089
How big are your drawables in how big are
the images?

00:58:03.089 --> 00:58:04.290
&gt;&gt;&gt; They're 256 by 256 bit maps.

00:58:04.290 --> 00:58:05.290
Like, 20 on a page.

00:58:05.290 --> 00:58:06.500
&gt;&gt;Romain Guy: That shouldn't be an issue.

00:58:06.500 --> 00:58:08.200
The issue is probably somewhere else.

00:58:08.200 --> 00:58:12.049
&gt;&gt;Chet Haase: One question, too, is are you
-- are they drawing at that size or are you

00:58:12.049 --> 00:58:13.190
scaling them into a different size?

00:58:13.190 --> 00:58:14.190
&gt;&gt;&gt; They're at that size.

00:58:14.190 --> 00:58:17.699
&gt;&gt;Romain Guy: So that's -- I would say it's
almost definitely not the issue.

00:58:17.699 --> 00:58:22.090
&gt;&gt;&gt; Well, so it's definitely also, like, loading
those bit maps, especially as JPEGs.

00:58:22.090 --> 00:58:23.090
And, unfortunately, there's, like, thousands
of them on a page.

00:58:23.090 --> 00:58:31.099
So I was wondering if I could store them as
compressed textures and then load them directly

00:58:31.099 --> 00:58:32.099
to you guys.

00:58:32.099 --> 00:58:33.099
&gt;&gt;Romain Guy: Yeah, you won't be able to do
that.

00:58:33.099 --> 00:58:36.650
But use Systrace and Traceview and you'll
be able to figure out what's going on.

00:58:36.650 --> 00:58:39.119
I really doubt that the issue is drawing.

00:58:39.119 --> 00:58:40.119
&gt;&gt;&gt; Okay.

00:58:40.119 --> 00:58:43.619
&gt;&gt;Chet Haase: I think, given 30 seconds, I
think we're out of time.

00:58:43.619 --> 00:58:44.619
We should probably get off the mikes.

00:58:44.619 --> 00:58:45.619
Thank you.

00:58:45.619 --> 00:58:45.620
[ Applause ]

