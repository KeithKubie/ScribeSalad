WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.862
[MUSIC PLAYING]

00:00:05.730 --> 00:00:06.730
YIGIT BOYAR: Welcome.

00:00:06.730 --> 00:00:08.360
Good afternoon, everybody.

00:00:08.360 --> 00:00:08.940
I'm Yigit.

00:00:08.940 --> 00:00:11.590
I'm the Technical Lead for
Architecture Components.

00:00:11.590 --> 00:00:15.470
And I'm here joining with
Kirill, also part of the team.

00:00:15.470 --> 00:00:20.780
So today, we are going to
talk about persistence.

00:00:20.780 --> 00:00:22.730
Now, this is a loading screen.

00:00:22.730 --> 00:00:25.520
This is one of my
favorite screens.

00:00:25.520 --> 00:00:26.900
Said no one.

00:00:26.900 --> 00:00:30.740
No one ever said, I
like to wait, especially

00:00:30.740 --> 00:00:34.010
if there's some content
that they have already seen.

00:00:34.010 --> 00:00:38.120
And if you are making the user
wait to see the same content,

00:00:38.120 --> 00:00:38.880
it's horrible.

00:00:38.880 --> 00:00:42.492
Like, you're a bad person.

00:00:42.492 --> 00:00:43.790
I didn't mean it.

00:00:43.790 --> 00:00:45.720
So now, how do we fix this?

00:00:45.720 --> 00:00:46.820
We persist the data.

00:00:46.820 --> 00:00:48.740
This is what we
recommend developers.

00:00:48.740 --> 00:00:52.070
Whatever information you
fetch from your network--

00:00:52.070 --> 00:00:54.910
different data services--
save it to disk

00:00:54.910 --> 00:00:57.230
so that if your
application is restarted,

00:00:57.230 --> 00:00:59.510
and there's no
network conditions,

00:00:59.510 --> 00:01:01.250
you could show
something to the user.

00:01:01.250 --> 00:01:04.206
You can make that
experience seamless.

00:01:04.206 --> 00:01:06.360
And we say persist on Android.

00:01:06.360 --> 00:01:08.300
We know this is a
very crowded field.

00:01:08.300 --> 00:01:11.630
There's a lot of different
options, different companies.

00:01:11.630 --> 00:01:15.800
And most of these solutions are
really, really good solutions.

00:01:15.800 --> 00:01:17.490
Especially if you
come to Android

00:01:17.490 --> 00:01:20.790
and if you're new to the
platform, what you will do.

00:01:20.790 --> 00:01:24.110
You will check what is
inside the framework already.

00:01:24.110 --> 00:01:25.850
So there's these
three things that

00:01:25.850 --> 00:01:28.610
come with the standard library.

00:01:28.610 --> 00:01:30.320
And if you read about
them, you realize

00:01:30.320 --> 00:01:33.500
that if you want to put
structured data, then

00:01:33.500 --> 00:01:35.360
you want to go with SQLite.

00:01:35.360 --> 00:01:39.170
SQLite is something we have
been shipping since Android 1.

00:01:39.170 --> 00:01:40.550
It's a proven technology.

00:01:40.550 --> 00:01:42.180
Works very well.

00:01:42.180 --> 00:01:44.270
So you go ahead and
say, I know SQL.

00:01:44.270 --> 00:01:46.070
I want to use SQLite.

00:01:46.070 --> 00:01:47.040
You go to this page.

00:01:47.040 --> 00:01:49.580
This is the very
first page you see.

00:01:49.580 --> 00:01:50.780
This is horrible.

00:01:50.780 --> 00:01:51.370
This is like--

00:01:51.370 --> 00:01:53.120
It's kind of trying
to say, you know what?

00:01:53.120 --> 00:01:54.578
You actually don't
want to persist.

00:01:57.150 --> 00:01:58.530
That's not what we meant.

00:01:58.530 --> 00:02:00.780
But this is what we have.

00:02:00.780 --> 00:02:03.500
So we said, you know what?

00:02:03.500 --> 00:02:05.152
Let's look at this page.

00:02:05.152 --> 00:02:06.610
We want to make
this better, right?

00:02:06.610 --> 00:02:07.609
Let's look at this page.

00:02:07.609 --> 00:02:09.780
It's trying to say,
I want to select

00:02:09.780 --> 00:02:14.820
these columns, with this
constraint, with this order.

00:02:14.820 --> 00:02:19.290
So if you look at this, this is
a very, very simple SQL query.

00:02:19.290 --> 00:02:21.030
But it takes a lot
of stuff to write it.

00:02:21.030 --> 00:02:23.520
You would need to define all
these constants, which are not

00:02:23.520 --> 00:02:25.890
even visible on this page.

00:02:25.890 --> 00:02:27.990
So we want to say, OK
that should leave us

00:02:27.990 --> 00:02:29.875
some room for improvement.

00:02:29.875 --> 00:02:33.510
And we came up with Room, which
is an object-mapping library

00:02:33.510 --> 00:02:34.140
for SQLite.

00:02:37.020 --> 00:02:38.670
We said, OK, let's step back.

00:02:38.670 --> 00:02:40.920
We said, writing the
same thing with SQL

00:02:40.920 --> 00:02:43.050
is a lot shorter, a lot nicer.

00:02:43.050 --> 00:02:46.650
So let's go back to our roots,
which now there's an SQL query.

00:02:46.650 --> 00:02:48.260
Then we assign it to a string.

00:02:48.260 --> 00:02:51.090
It is standard SQLite.

00:02:51.090 --> 00:02:56.340
Now, of course, if it is like
this, we cannot understand it.

00:02:56.340 --> 00:02:57.360
We allow annotations.

00:02:57.360 --> 00:02:59.672
So we put it inside
an annotation.

00:02:59.672 --> 00:03:01.130
And if it is inside
the annotation,

00:03:01.130 --> 00:03:04.120
now you want to get the
response from the query.

00:03:04.120 --> 00:03:06.510
Want to say, well,
put it into a method

00:03:06.510 --> 00:03:09.630
so we can understand what
the query wants to return.

00:03:09.630 --> 00:03:12.600
Now we know that
this is a query.

00:03:12.600 --> 00:03:16.530
It wants to fetch these
columns from this table

00:03:16.530 --> 00:03:17.730
and with this constraint.

00:03:17.730 --> 00:03:19.164
But if you look
at the constraint,

00:03:19.164 --> 00:03:20.580
there's actually
a bind parameter.

00:03:20.580 --> 00:03:23.970
This is SQLite standard
bind parameter syntax.

00:03:23.970 --> 00:03:25.650
We didn't come up with this.

00:03:25.650 --> 00:03:28.420
So where do we get
this bind parameters?

00:03:28.420 --> 00:03:30.540
How do you get parameters
to your functions?

00:03:30.540 --> 00:03:31.800
From the function arguments.

00:03:31.800 --> 00:03:34.380
So we put it there,
the most obvious place

00:03:34.380 --> 00:03:36.570
to get this argument from.

00:03:36.570 --> 00:03:38.280
And now, last but
not least, we want

00:03:38.280 --> 00:03:40.060
to know what it wants to return.

00:03:40.060 --> 00:03:42.952
OK, so it is returning
list of feeds.

00:03:42.952 --> 00:03:44.900
Now, of course, there's
that feed class.

00:03:44.900 --> 00:03:46.440
It needs to be somewhere.

00:03:46.440 --> 00:03:48.090
We have that class.

00:03:48.090 --> 00:03:50.850
And I want to put this query
inside that Data Access

00:03:50.850 --> 00:03:51.510
Object--

00:03:51.510 --> 00:03:53.131
that's what DAO stands for--

00:03:53.131 --> 00:03:55.380
because you don't want to
have your application making

00:03:55.380 --> 00:03:57.810
database queries
along the code base.

00:03:57.810 --> 00:04:00.420
You want to put these into
certain classes, which

00:04:00.420 --> 00:04:02.610
we call data access objects.

00:04:02.610 --> 00:04:06.090
So we said, now we need to tell
the Room that this is a DAO.

00:04:06.090 --> 00:04:07.630
And I needed to
tell Room that feed

00:04:07.630 --> 00:04:11.850
is some class that it will like
to persist into a database.

00:04:11.850 --> 00:04:14.700
Last but not least, we need
the database to put these two

00:04:14.700 --> 00:04:16.839
things together.

00:04:16.839 --> 00:04:20.070
That needs to extends
the Room database class.

00:04:20.070 --> 00:04:23.160
And so the FeedDao
we defined there,

00:04:23.160 --> 00:04:26.130
we just say this
database has this DAO.

00:04:26.130 --> 00:04:29.350
And the feed entity we defined,
we put inside database.

00:04:29.350 --> 00:04:32.450
So you can have multiple
entities, multiple DAOs.

00:04:32.450 --> 00:04:34.950
You can actually have
multiple database definitions

00:04:34.950 --> 00:04:36.660
that access the same DAOs.

00:04:36.660 --> 00:04:40.920
As long as whatever schema
you define in the database

00:04:40.920 --> 00:04:43.430
works with the
DAOs and entities,

00:04:43.430 --> 00:04:46.830
Room will figure it out.

00:04:46.830 --> 00:04:49.140
Once you have all
that description,

00:04:49.140 --> 00:04:52.290
you can get the implementation
of that database

00:04:52.290 --> 00:04:53.610
through this builder.

00:04:53.610 --> 00:04:56.170
It's very similar to how
we use Retrofit Dagger.

00:04:56.170 --> 00:05:02.730
You define the interfaces, we
provide the implementation.

00:05:02.730 --> 00:05:05.540
Now, of course, because we
are doing the implementation,

00:05:05.540 --> 00:05:06.952
select queries
are very specific.

00:05:06.952 --> 00:05:08.660
We really don't know
how you will select.

00:05:08.660 --> 00:05:10.060
But there are other queries.

00:05:10.060 --> 00:05:13.160
You would like to insert
something into the database.

00:05:13.160 --> 00:05:15.740
So we say, OK, we can just
define Android annotation

00:05:15.740 --> 00:05:18.230
to make it easier for you.

00:05:18.230 --> 00:05:20.210
Inside these annotations,
these are actually

00:05:20.210 --> 00:05:22.580
very, very flexible.

00:05:22.580 --> 00:05:24.650
You can pass multiple arguments.

00:05:24.650 --> 00:05:27.956
If you read this method,
it says, insert both.

00:05:27.956 --> 00:05:30.080
You really want to insert
both of them to database,

00:05:30.080 --> 00:05:32.240
and Room understands this.

00:05:32.240 --> 00:05:34.070
You can send a list of items.

00:05:34.070 --> 00:05:36.890
You can send variable
arguments, multiple parameters.

00:05:36.890 --> 00:05:42.070
If it is readable,
Room will make it work.

00:05:42.070 --> 00:05:45.400
You can even say like, when
you try to insert this thing,

00:05:45.400 --> 00:05:49.500
if there's a unique key conflict
in the database, do this.

00:05:49.500 --> 00:05:53.030
So it can also specify
these constraints.

00:05:53.030 --> 00:05:55.030
So we have the
Insert annotation.

00:05:55.030 --> 00:05:58.160
We have similarly, Delete,
or Update annotations just

00:05:58.160 --> 00:05:59.495
for the very common tasks.

00:06:03.120 --> 00:06:05.350
So we say we just
start up on the SQLite.

00:06:05.350 --> 00:06:08.350
But there are some cases where
writing SQLite is harder.

00:06:08.350 --> 00:06:10.570
For example, I have
this query where

00:06:10.570 --> 00:06:12.510
I want to query these feeds.

00:06:12.510 --> 00:06:14.410
But I'm trying to
return a list of feeds,

00:06:14.410 --> 00:06:17.650
which means I want to
get multiple feed items.

00:06:17.650 --> 00:06:19.900
So that means I want
to get them by ID,

00:06:19.900 --> 00:06:23.070
so I probably want
to pass multiple IDs.

00:06:23.070 --> 00:06:26.530
Now, in SQL, you will
do this in these IDs.

00:06:26.530 --> 00:06:28.690
But you need to know
how many IDs you have

00:06:28.690 --> 00:06:32.080
so you can put that
number of bind parameters.

00:06:32.080 --> 00:06:33.940
But this is some
information we don't

00:06:33.940 --> 00:06:36.400
know while writing this query.

00:06:36.400 --> 00:06:37.710
Well, that's OK.

00:06:37.710 --> 00:06:38.860
Room can understand it.

00:06:38.860 --> 00:06:41.920
If whatever the perimeter
you are passing to a function

00:06:41.920 --> 00:06:43.180
is a collection.

00:06:43.180 --> 00:06:46.480
Room knows that, OK, they
want to have multiple bind

00:06:46.480 --> 00:06:47.860
parameters.

00:06:47.860 --> 00:06:50.470
At runtime, we will generate
the right query for you.

00:06:50.470 --> 00:06:51.690
And we will do that.

00:06:51.690 --> 00:06:53.880
You can send them as an
array, send them as a list,

00:06:53.880 --> 00:06:55.570
doesn't really matter.

00:06:55.570 --> 00:07:00.070
If Room can understand
it, it will do it for you.

00:07:00.070 --> 00:07:02.040
Now the most important
part about Room

00:07:02.040 --> 00:07:04.930
is that once we let you
define all these things,

00:07:04.930 --> 00:07:07.605
make sure Room understands
these queries-- does not just

00:07:07.605 --> 00:07:10.672
say, like, you know, take
this SQL and then compile it

00:07:10.672 --> 00:07:12.540
and generate the code.

00:07:12.540 --> 00:07:15.180
Room understands it, knows
what you are trying to do.

00:07:15.180 --> 00:07:17.830
And this gives us
a lot of power.

00:07:17.830 --> 00:07:19.680
For example, if Room
looks at this query,

00:07:19.680 --> 00:07:24.830
says, OK, this is a select query
with this bind parameter, which

00:07:24.830 --> 00:07:29.880
is passed in as a string, and
it knows it is from the feed

00:07:29.880 --> 00:07:33.450
table, and it wants to
return items as feeds,

00:07:33.450 --> 00:07:36.640
then Room goes and says,
OK, can I validate this?

00:07:36.640 --> 00:07:37.910
Yeah.

00:07:37.910 --> 00:07:40.470
The table has these
three columns.

00:07:40.470 --> 00:07:42.150
The feed item is
these three columns.

00:07:42.150 --> 00:07:43.210
These match.

00:07:43.210 --> 00:07:44.160
They are fine.

00:07:44.160 --> 00:07:47.070
You could have another class
in sort of that feed that

00:07:47.070 --> 00:07:48.300
has these three fields.

00:07:48.300 --> 00:07:53.010
Room will still work

00:07:53.010 --> 00:07:56.800
Now after this verification,
let's say you made a typo.

00:07:56.800 --> 00:07:59.340
The reason why we define
all those constants

00:07:59.340 --> 00:08:03.750
or use Java builders,
is it would be typing,

00:08:03.750 --> 00:08:05.430
like mistyping queries.

00:08:05.430 --> 00:08:08.610
Room can do this validation
for you, similar to Java code,

00:08:08.610 --> 00:08:09.110
right?

00:08:09.110 --> 00:08:10.609
You don't use
builders to write Java

00:08:10.609 --> 00:08:12.180
code You write your Java code.

00:08:12.180 --> 00:08:14.610
Compilers tells
you if it is wrong.

00:08:14.610 --> 00:08:15.990
And the ID helps you with this.

00:08:15.990 --> 00:08:17.700
So the reason why we
don't have builders

00:08:17.700 --> 00:08:21.120
is that we think helping
you write SQL query

00:08:21.120 --> 00:08:25.300
is the job of Android Studio,
which they are working on it.

00:08:25.300 --> 00:08:27.290
But once you write
the query, Room

00:08:27.290 --> 00:08:28.960
verifies that it is correct.

00:08:28.960 --> 00:08:31.350
So if you do this
mistake, Room will not

00:08:31.350 --> 00:08:33.549
let you compile the application.

00:08:33.549 --> 00:08:35.429
Similarly, if you
access some columns that

00:08:35.429 --> 00:08:37.890
doesn't exist in the
database, again, it

00:08:37.890 --> 00:08:39.580
will be a compile time error.

00:08:39.580 --> 00:08:41.159
By the way, it can be any query.

00:08:41.159 --> 00:08:43.080
You might be
joining five tables.

00:08:43.080 --> 00:08:44.520
Room will still understand.

00:08:44.520 --> 00:08:49.410
You may have grouping, like
almost anything in SQL.

00:08:49.410 --> 00:08:52.330
Let's say we made that mistake
like that where we only

00:08:52.330 --> 00:08:54.510
fetch the subtitle column.

00:08:54.510 --> 00:08:56.340
But you want to
return this as a feed.

00:08:56.340 --> 00:08:58.710
Now, in this case,
the feed object

00:08:58.710 --> 00:09:00.310
also has a subtitle column.

00:09:00.310 --> 00:09:01.860
So this might be intentional.

00:09:01.860 --> 00:09:04.420
Maybe you are going to fill
in those fields later on

00:09:04.420 --> 00:09:05.710
or you made a mistake.

00:09:05.710 --> 00:09:06.600
We don't know.

00:09:06.600 --> 00:09:09.440
In this case, Room just
generates a warning.

00:09:09.440 --> 00:09:13.260
It says, hey, feed classes
these two other fields

00:09:13.260 --> 00:09:16.380
that you are not
returning from the query.

00:09:16.380 --> 00:09:18.250
It will just give
you all the details--

00:09:18.250 --> 00:09:20.010
well, what the query returns.

00:09:20.010 --> 00:09:21.500
Maybe you made a typo.

00:09:21.500 --> 00:09:23.370
And what are the
fields in the column--

00:09:23.370 --> 00:09:24.940
in the entity?

00:09:24.940 --> 00:09:28.020
Now, there are two ways you
can get rid of this warning.

00:09:28.020 --> 00:09:29.850
The first thing you
can do is, maybe

00:09:29.850 --> 00:09:33.230
you really want to return
them as feed instances.

00:09:33.230 --> 00:09:35.700
And I can tell the
Room to ignore it.

00:09:35.700 --> 00:09:36.830
I know what I am doing.

00:09:36.830 --> 00:09:38.700
Suppress this warning.

00:09:38.700 --> 00:09:42.220
Alternatively, you can just
create any class, as I said.

00:09:42.220 --> 00:09:44.590
You can just say, return
me these as a string.

00:09:44.590 --> 00:09:47.550
You are returning one
column as a string.

00:09:47.550 --> 00:09:50.760
And Room will do it for you.

00:09:50.760 --> 00:09:54.420
Very similarly, what if you
are returning ID and title?

00:09:54.420 --> 00:09:56.340
In that case, again,
Room will say, well,

00:09:56.340 --> 00:09:57.930
there's two columns, one string.

00:09:57.930 --> 00:09:59.420
That doesn't match.

00:09:59.420 --> 00:10:01.680
It will give you an error.

00:10:01.680 --> 00:10:03.960
When that happens, we
can just create a POJO.

00:10:03.960 --> 00:10:06.600
Again, any class in
your application,

00:10:06.600 --> 00:10:09.210
as long as we can
read what's inside it

00:10:09.210 --> 00:10:12.030
and it matches what
the query returns,

00:10:12.030 --> 00:10:13.620
we will generate the code.

00:10:13.620 --> 00:10:16.950
And to make the match, you can
rename the columns in SQLite.

00:10:16.950 --> 00:10:20.570
All of those things works here.

00:10:20.570 --> 00:10:23.180
Now, this Room does
everything automatically.

00:10:23.180 --> 00:10:26.090
But sometimes, you have
classes we don't know about.

00:10:26.090 --> 00:10:28.520
Now I want Kirill
to talk about them.

00:10:28.520 --> 00:10:30.260
How do we extend Room, Kirill?

00:10:30.260 --> 00:10:31.510
KIRILL GROUCHNIKOV: Thank you.

00:10:31.510 --> 00:10:34.520
So let's talk about something
a little bit more interesting.

00:10:34.520 --> 00:10:38.570
Going back to this feed
object that has one ID integer

00:10:38.570 --> 00:10:41.450
field and two strings,
these are primitive types

00:10:41.450 --> 00:10:44.750
that are directly supported by
the underlying SQLite database.

00:10:44.750 --> 00:10:48.890
What happens if you want to
add a field of a type that

00:10:48.890 --> 00:10:52.730
is not directly supported by
SQLite, such as Java util date?

00:10:52.730 --> 00:10:54.590
In this case, at
compile time, Room

00:10:54.590 --> 00:10:56.540
is going to tell us,
well, I can't really

00:10:56.540 --> 00:10:58.280
figure out how to save this.

00:10:58.280 --> 00:10:59.840
You need to help me out.

00:10:59.840 --> 00:11:02.120
And the way you help
out, in this case,

00:11:02.120 --> 00:11:06.930
is provide two methods to
take your original data,

00:11:06.930 --> 00:11:09.620
convert it to something
that SQLite can store,

00:11:09.620 --> 00:11:11.810
so that is going
into the database.

00:11:11.810 --> 00:11:15.410
And on the way out, when
you're doing the queries,

00:11:15.410 --> 00:11:18.140
convert back from that
representation in the database

00:11:18.140 --> 00:11:20.407
to your original data type.

00:11:20.407 --> 00:11:21.740
You implement these two methods.

00:11:21.740 --> 00:11:24.410
In this particular case, we
are converting date to long,

00:11:24.410 --> 00:11:26.270
and back from long to date.

00:11:26.270 --> 00:11:27.290
We annotate them.

00:11:27.290 --> 00:11:29.720
As Yigit said, we
love annotations.

00:11:29.720 --> 00:11:31.700
We use the type
converter annotations

00:11:31.700 --> 00:11:32.630
on these two methods.

00:11:32.630 --> 00:11:35.510
And then we take these
MyConverters class

00:11:35.510 --> 00:11:39.860
and use the type converters
annotation pointing

00:11:39.860 --> 00:11:42.530
to these two methods-- pointing,
essentially, to this class that

00:11:42.530 --> 00:11:44.630
has our conversion methods.

00:11:44.630 --> 00:11:48.140
You can put it directly on the
field in your entity object.

00:11:48.140 --> 00:11:50.900
You can put it on the
entity object itself.

00:11:50.900 --> 00:11:54.810
You can put it onto your
data access object class

00:11:54.810 --> 00:11:56.390
or the specific query in it.

00:11:56.390 --> 00:11:58.280
Or you can put it on
your database class.

00:11:58.280 --> 00:12:01.320
No matter where you put it, at
compile time and at runtime,

00:12:01.320 --> 00:12:05.300
Room will do the right thing
to find those two methods.

00:12:05.300 --> 00:12:08.420
Now with this, we
can write a query

00:12:08.420 --> 00:12:10.070
that finds the list
of all the feeds

00:12:10.070 --> 00:12:12.770
that were posted between two
specific dates, "from" and

00:12:12.770 --> 00:12:13.910
"to".

00:12:13.910 --> 00:12:16.910
So here, since we are
accessing the "from"

00:12:16.910 --> 00:12:20.510
and "to" fields, or columns
in the database, that

00:12:20.510 --> 00:12:26.120
are defined as long, when the
database table is created,

00:12:26.120 --> 00:12:27.860
you don't really
want to use "long"

00:12:27.860 --> 00:12:29.450
as the implementation detail.

00:12:29.450 --> 00:12:33.680
Since you are using the date
class for your entity data

00:12:33.680 --> 00:12:38.180
field, you want to use the date
objects in the query itself.

00:12:38.180 --> 00:12:39.560
And this is what you do here.

00:12:39.560 --> 00:12:43.040
And when the query runs,
these two values, from and to,

00:12:43.040 --> 00:12:44.580
are going to be
converted to longs.

00:12:44.580 --> 00:12:45.860
The query will run.

00:12:45.860 --> 00:12:49.790
And on the way back, when
Room constructs and fields

00:12:49.790 --> 00:12:52.550
these feed objects, it's going
to convert back from long

00:12:52.550 --> 00:12:54.110
to dates.

00:12:54.110 --> 00:12:58.610
Now, let's talk about even
more complicated stuff.

00:12:58.610 --> 00:13:02.540
What happens if you
have a class hierarchy

00:13:02.540 --> 00:13:08.180
in your kind of data
model universe that has

00:13:08.180 --> 00:13:11.420
object graph that is not flat?

00:13:11.420 --> 00:13:14.360
In this case, we are adding a
location object that has two

00:13:14.360 --> 00:13:16.670
double fields--
latitude, longitude--

00:13:16.670 --> 00:13:18.080
into our feed.

00:13:18.080 --> 00:13:20.600
Now, what happens
at compile time?

00:13:20.600 --> 00:13:22.340
Once again, at
compile time, you need

00:13:22.340 --> 00:13:29.090
to tell Room how to store this
field since, especially here,

00:13:29.090 --> 00:13:31.580
it's not a primitive
type, but it's a type that

00:13:31.580 --> 00:13:33.740
has subfields in it.

00:13:33.740 --> 00:13:37.580
So one option is going
back to our type adapters.

00:13:37.580 --> 00:13:40.760
You can do something like,
take latitude and longitude

00:13:40.760 --> 00:13:43.504
and convert them into a
single, concatenated string

00:13:43.504 --> 00:13:45.170
with some kind of,
let's say, semi-colon

00:13:45.170 --> 00:13:47.690
as a separator on the way in.

00:13:47.690 --> 00:13:51.080
And on the way back, it is
going to be some kind of a split

00:13:51.080 --> 00:13:53.600
where the string goes back
through these two doubles.

00:13:53.600 --> 00:13:56.630
Or you can go to do
something like bit masking

00:13:56.630 --> 00:13:59.040
and bit shifting to try and
convert these two doubles

00:13:59.040 --> 00:14:02.690
and code them in one long field.

00:14:02.690 --> 00:14:05.090
This is going to
be hard to query,

00:14:05.090 --> 00:14:07.850
even for this simple case,
when we only have two

00:14:07.850 --> 00:14:10.010
doubles that we are
trying to encode.

00:14:10.010 --> 00:14:13.250
We're trying to compact
it into one field.

00:14:13.250 --> 00:14:17.130
And the more complicated
the data structure is,

00:14:17.130 --> 00:14:21.810
the harder it becomes to use
type adapters for these cases.

00:14:21.810 --> 00:14:24.380
Another option is
to say that I'm

00:14:24.380 --> 00:14:26.300
going to flatten everything--

00:14:26.300 --> 00:14:29.040
that you are going to
flatten everything for us.

00:14:29.040 --> 00:14:31.280
So instead of having
the location data

00:14:31.280 --> 00:14:34.040
field in your data entity,
you are essentially

00:14:34.040 --> 00:14:36.770
flattening all the fields
from the location class

00:14:36.770 --> 00:14:38.870
into the main feed class.

00:14:38.870 --> 00:14:41.390
And then, Room is going to
create these two latitude,

00:14:41.390 --> 00:14:44.010
longitude columns, which works.

00:14:44.010 --> 00:14:46.490
But first of all, you
lose the encapsulation.

00:14:46.490 --> 00:14:49.880
Now you just look at the
definition of your data class,

00:14:49.880 --> 00:14:51.110
of this feed object--

00:14:51.110 --> 00:14:54.920
or somebody else in your
project looks at that--

00:14:54.920 --> 00:14:57.360
and it's not really clear
that these two objects

00:14:57.360 --> 00:14:59.780
represent one single entity.

00:14:59.780 --> 00:15:01.760
And another thing
is just because you

00:15:01.760 --> 00:15:05.150
want to persist this object
and later on retrieve it,

00:15:05.150 --> 00:15:08.450
why should you be changing
the definition of your data

00:15:08.450 --> 00:15:09.200
classes?

00:15:09.200 --> 00:15:11.150
That's not good.

00:15:11.150 --> 00:15:16.640
Instead, there's another
option, which is also not ideal.

00:15:16.640 --> 00:15:19.440
You can say we have
two data classes.

00:15:19.440 --> 00:15:21.150
Why don't we store
these objects,

00:15:21.150 --> 00:15:24.310
each one in its own
separate database table?

00:15:24.310 --> 00:15:26.890
So we have our feed
object with ID title,

00:15:26.890 --> 00:15:28.980
subtitle, and
posted at, the date.

00:15:28.980 --> 00:15:31.870
And then we have the
location-- latitude, longitude.

00:15:31.870 --> 00:15:34.530
Now, in order to connect
them, not when you say,

00:15:34.530 --> 00:15:36.390
but when you retrieve
them, in order

00:15:36.390 --> 00:15:39.330
to connect the location
back to its feed,

00:15:39.330 --> 00:15:41.250
you need to have
the primary key,

00:15:41.250 --> 00:15:44.670
the feed ID so that they
are combined together.

00:15:44.670 --> 00:15:47.230
Once again, it works.

00:15:47.230 --> 00:15:51.300
First of all, yet another
table is not very clean.

00:15:51.300 --> 00:15:53.670
But also, going back to
what I mentioned before,

00:15:53.670 --> 00:15:57.930
why should you be forced
to change and tweak

00:15:57.930 --> 00:15:59.940
the definition of your
data model classes

00:15:59.940 --> 00:16:02.520
just because you
want to persist them?

00:16:02.520 --> 00:16:06.120
So what would be
ideal is that you

00:16:06.120 --> 00:16:07.920
have your clean
separation of how

00:16:07.920 --> 00:16:09.940
you define your data classes.

00:16:09.940 --> 00:16:15.030
But at runtime, the way the
feed object is persisted

00:16:15.030 --> 00:16:17.040
is in one flattened table.

00:16:17.040 --> 00:16:19.650
So essentially, the latitude
and longitude fields

00:16:19.650 --> 00:16:23.460
from the location are
flattened into the same table.

00:16:23.460 --> 00:16:26.280
And the way you do it is with
this embedded annotation.

00:16:26.280 --> 00:16:28.710
At compile time and
at runtime, Room

00:16:28.710 --> 00:16:32.670
is going to figure out how to
flatten your entire hierarchy

00:16:32.670 --> 00:16:35.400
into this one table.

00:16:35.400 --> 00:16:37.710
Now you can write a query
like this in your data access

00:16:37.710 --> 00:16:38.280
object.

00:16:38.280 --> 00:16:41.770
We are going to
select all the feeds

00:16:41.770 --> 00:16:45.690
in the specific geographical
rectangular area.

00:16:45.690 --> 00:16:47.260
As you can see,
we are referencing

00:16:47.260 --> 00:16:50.380
latitude and longitude
in the query directly.

00:16:50.380 --> 00:16:52.580
They're not in a separate table.

00:16:52.580 --> 00:16:57.250
And you are just using the same
names for the database columns

00:16:57.250 --> 00:17:00.190
as the attributes in
your location object.

00:17:00.190 --> 00:17:02.830
You can write a query
like this to select

00:17:02.830 --> 00:17:07.180
the location for the specific
feed based on the feed ID.

00:17:07.180 --> 00:17:10.240
And Room is going to figure
out that, while it needs

00:17:10.240 --> 00:17:12.819
to fetch the entire
row from the database,

00:17:12.819 --> 00:17:16.150
it only needs to create and
fill the location object,

00:17:16.150 --> 00:17:19.390
because this is what this
method wants to return.

00:17:19.390 --> 00:17:22.670
Or if you want to be more
specific, you can say,

00:17:22.670 --> 00:17:24.970
I only want you to fetch
the latitude and longitude

00:17:24.970 --> 00:17:27.619
from that table.

00:17:27.619 --> 00:17:29.920
The last part about
embedded objects

00:17:29.920 --> 00:17:34.390
is what happens when you
have more than one field

00:17:34.390 --> 00:17:37.760
of the same kind
of nested class.

00:17:37.760 --> 00:17:40.480
So in this case, we want
to store two locations.

00:17:40.480 --> 00:17:42.620
So what is going to
happen at compile time,

00:17:42.620 --> 00:17:45.910
Room is going to say,
as I was flattening

00:17:45.910 --> 00:17:49.690
these fields into one
database table definition,

00:17:49.690 --> 00:17:51.940
I see that the
same latitude field

00:17:51.940 --> 00:17:53.920
is defined by two objects.

00:17:53.920 --> 00:17:59.320
And since SQLite doesn't
support having two columns

00:17:59.320 --> 00:18:01.950
with the same name in
the same database table,

00:18:01.950 --> 00:18:05.800
it's going to fail as an
error, not as a warning.

00:18:05.800 --> 00:18:09.280
And what you need
to do, is in case

00:18:09.280 --> 00:18:11.950
you do want to have
something like this, to have,

00:18:11.950 --> 00:18:14.290
in this particular
case, two locations,

00:18:14.290 --> 00:18:16.360
you want to use the
prefix attribute

00:18:16.360 --> 00:18:18.940
on the embedded annotation.

00:18:18.940 --> 00:18:21.520
At compile time and
at runtime, it's

00:18:21.520 --> 00:18:25.450
going to be used as Room is
flattening the data graph

00:18:25.450 --> 00:18:26.840
definition.

00:18:26.840 --> 00:18:29.620
It's going to use this
prefix to create latitude,

00:18:29.620 --> 00:18:33.400
longitude for the original,
for the first location,

00:18:33.400 --> 00:18:35.740
and seen latitude,
seen longitude

00:18:35.740 --> 00:18:38.850
for the second location object.

00:18:38.850 --> 00:18:40.350
Now, let's talk
about observability.

00:18:40.350 --> 00:18:42.290
For those of you
who have listened

00:18:42.290 --> 00:18:44.970
to yesterday's
introduction session

00:18:44.970 --> 00:18:49.130
and who have been here
earlier in the day

00:18:49.130 --> 00:18:53.670
to listen to the life
cycle live data view model,

00:18:53.670 --> 00:18:55.680
we want to talk
about observability.

00:18:55.680 --> 00:18:59.580
So this is a simple query
that returns a list of feeds

00:18:59.580 --> 00:19:02.310
based on a particular query.

00:19:02.310 --> 00:19:05.640
This is kind of a
snapshot, a point in time

00:19:05.640 --> 00:19:07.380
where you have run this query.

00:19:07.380 --> 00:19:10.500
And however many
feeds it returns,

00:19:10.500 --> 00:19:13.650
it represents the state
of your data universe

00:19:13.650 --> 00:19:15.320
at that particular moment.

00:19:15.320 --> 00:19:18.400
What happens if your
data is dynamic?

00:19:18.400 --> 00:19:21.970
It can be manipulated directly
by your users in the app.

00:19:21.970 --> 00:19:24.880
Or maybe it's pushed or
pulled down from the server.

00:19:24.880 --> 00:19:27.300
So in this case,
if one of the feed

00:19:27.300 --> 00:19:29.130
changes in the
database, when you

00:19:29.130 --> 00:19:32.070
add new feeds, when you delete
existing feeds that match

00:19:32.070 --> 00:19:36.750
this query, every single time
to reflect these changes back

00:19:36.750 --> 00:19:41.280
onto the screen, you would
need to refresh this query

00:19:41.280 --> 00:19:43.980
explicitly, to run this
query again and again.

00:19:47.250 --> 00:19:49.260
Instead of returning
list of feeds,

00:19:49.260 --> 00:19:52.740
you can wrap this
return object--

00:19:52.740 --> 00:19:54.750
it can be a single feed
or a list of feeds--

00:19:54.750 --> 00:19:56.560
in a live data object.

00:19:56.560 --> 00:20:01.830
This instructs Room not only
to fetch it once, but also

00:20:01.830 --> 00:20:04.080
update the LiveData--

00:20:04.080 --> 00:20:06.660
the callback that you pass
to the LiveData when you call

00:20:06.660 --> 00:20:08.970
the .observe-- we'll
see it in a few slides--

00:20:08.970 --> 00:20:12.810
every single time any
one of the objects that

00:20:12.810 --> 00:20:15.150
were returned by this
query was changed,

00:20:15.150 --> 00:20:18.570
or new objects were added, or
existing objects were removed

00:20:18.570 --> 00:20:20.400
from the result of the query.

00:20:20.400 --> 00:20:26.550
And this is my favorite part by
far of architecture components.

00:20:26.550 --> 00:20:29.820
And also, we provide
support for using Flowable

00:20:29.820 --> 00:20:32.040
from our RxJava 2.

00:20:32.040 --> 00:20:37.580
So let's say-- like this one.

00:20:37.580 --> 00:20:41.310
OK, so let's see an example
of how Room integrates

00:20:41.310 --> 00:20:45.870
with the rest of lifecycle
aware and lifecycle aware parts

00:20:45.870 --> 00:20:47.940
of architecture components.

00:20:47.940 --> 00:20:50.790
We're going to start with a
simple database interface.

00:20:50.790 --> 00:20:53.820
It has one method
to load the data

00:20:53.820 --> 00:20:57.330
for a specific user, and
one method to save the data.

00:20:57.330 --> 00:20:59.730
The first time, it is going
to be a simple insert.

00:20:59.730 --> 00:21:02.490
And then as the data changes,
it's going to be an update

00:21:02.490 --> 00:21:04.440
or replace.

00:21:04.440 --> 00:21:06.630
As you can see here, instead
of rejoining the user

00:21:06.630 --> 00:21:08.580
object directly in
our load method,

00:21:08.580 --> 00:21:11.280
we're returning a live data
that traps the information

00:21:11.280 --> 00:21:13.200
about this user.

00:21:13.200 --> 00:21:16.530
Now, we're going to set up the
data binding to actually show

00:21:16.530 --> 00:21:19.380
the information on that user,
perhaps in the Details page

00:21:19.380 --> 00:21:22.700
or somewhere in some
kind of a profile page.

00:21:22.700 --> 00:21:24.510
We have our lifecycle activity.

00:21:24.510 --> 00:21:25.890
It can be a lifecycle fragment.

00:21:25.890 --> 00:21:29.670
It can be a lifecycle service,
or your custom lifecycle owner.

00:21:29.670 --> 00:21:32.550
In this case, we're
using lifecycle activity.

00:21:32.550 --> 00:21:36.480
And in on create, we're going
to get access to our database

00:21:36.480 --> 00:21:38.610
and database access object.

00:21:38.610 --> 00:21:40.530
We're going to call
our load method that

00:21:40.530 --> 00:21:44.160
returns the live data
that traps that user data.

00:21:44.160 --> 00:21:47.310
And now, we are going to
use the observe method

00:21:47.310 --> 00:21:50.440
on this live data object
passing two parameters.

00:21:50.440 --> 00:21:51.960
The first parameter
is the reference

00:21:51.960 --> 00:21:53.470
to the lifecycle owner.

00:21:53.470 --> 00:21:54.960
This is our activity.

00:21:54.960 --> 00:21:56.760
And the second parameter
is the callback

00:21:56.760 --> 00:22:00.090
that is going to be
invoked by Room at runtime

00:22:00.090 --> 00:22:04.380
every time this user information
changes in the database

00:22:04.380 --> 00:22:07.770
on the first load or on
the subsequent updates.

00:22:07.770 --> 00:22:09.030
Now a word of caution.

00:22:09.030 --> 00:22:10.680
Because it's kind
of like, you know,

00:22:10.680 --> 00:22:12.900
we don't want to put
too many lines of code

00:22:12.900 --> 00:22:15.900
here on one slide,
you usually don't

00:22:15.900 --> 00:22:21.840
want to expose database details
or details about loading

00:22:21.840 --> 00:22:24.000
this information
from your web service

00:22:24.000 --> 00:22:27.290
or caching it locally in some
form directly to the activity

00:22:27.290 --> 00:22:28.740
or directly to the fragment.

00:22:28.740 --> 00:22:30.780
So this code is
highly recommended

00:22:30.780 --> 00:22:34.150
to be put in a view model.

00:22:34.150 --> 00:22:36.510
And once again, the
most powerful part

00:22:36.510 --> 00:22:40.290
here is the connection between
the lifecycle activity,

00:22:40.290 --> 00:22:44.220
the owner, that says I'm
active, I am not active,

00:22:44.220 --> 00:22:46.740
and the live data
that Room returns

00:22:46.740 --> 00:22:50.760
as a result of this
particular query.

00:22:50.760 --> 00:22:53.280
The callback that you provide
as the second parameter

00:22:53.280 --> 00:22:55.140
to the method, once
again, it's going

00:22:55.140 --> 00:22:58.530
to be invoked every
time Room detects

00:22:58.530 --> 00:23:00.900
that the result of that
query that you wrote,

00:23:00.900 --> 00:23:07.200
select star from the user
database table, has changed.

00:23:07.200 --> 00:23:08.940
Once again, the
flow of information

00:23:08.940 --> 00:23:10.530
is one part of your app.

00:23:10.530 --> 00:23:13.770
It can be some kind of a
service that pulls information

00:23:13.770 --> 00:23:14.754
from your back end.

00:23:14.754 --> 00:23:16.920
Or maybe the information
is pushed through some kind

00:23:16.920 --> 00:23:18.870
of network tickles.

00:23:18.870 --> 00:23:21.540
It gets updates on the data.

00:23:21.540 --> 00:23:25.380
It's using this save method
to insert the information

00:23:25.380 --> 00:23:29.100
into the database or update
the existing information.

00:23:29.100 --> 00:23:32.610
As the data is updated
in the database,

00:23:32.610 --> 00:23:35.010
Room is going to
detect at runtime,

00:23:35.010 --> 00:23:38.040
all those active
places in your app--

00:23:38.040 --> 00:23:40.650
activity fragment
service, or your custom

00:23:40.650 --> 00:23:43.350
lifecycle owners
that are active,

00:23:43.350 --> 00:23:47.370
and that are subscribed or
are observing a live data

00:23:47.370 --> 00:23:50.400
object that traps
the information

00:23:50.400 --> 00:23:52.680
that has been updated.

00:23:52.680 --> 00:23:56.310
And then this callback
is going to be invoked,

00:23:56.310 --> 00:23:58.680
letting you know that
most probably you

00:23:58.680 --> 00:24:01.710
want to update
whatever slice of data

00:24:01.710 --> 00:24:04.710
is right now showing in
the application screen.

00:24:04.710 --> 00:24:07.170
So for example, it
can be an app that

00:24:07.170 --> 00:24:11.100
shows live results
for some sports games,

00:24:11.100 --> 00:24:15.390
or live updates for the weather,
wherever you happen to be,

00:24:15.390 --> 00:24:18.660
or live updates to
market stock prices.

00:24:18.660 --> 00:24:21.660
One part of your app
handles the data flow.

00:24:21.660 --> 00:24:26.940
Get that information and display
and insert it into the database

00:24:26.940 --> 00:24:28.620
or update in the database.

00:24:28.620 --> 00:24:32.780
And the other part gets notified
by Room and the live data

00:24:32.780 --> 00:24:37.980
that the information
now has new data.

00:24:37.980 --> 00:24:41.340
And you need to update
whatever the presentation is,

00:24:41.340 --> 00:24:43.380
once again, in your
activity, in your fragment

00:24:43.380 --> 00:24:46.200
or in your service that
posts maybe notification

00:24:46.200 --> 00:24:48.380
that handles a widget.

00:24:48.380 --> 00:24:49.338
YIGIT BOYAR: All right.

00:24:49.338 --> 00:24:52.200
Thank you.

00:24:52.200 --> 00:24:55.310
So let's focus on another
important topic, which

00:24:55.310 --> 00:24:56.810
is relations.

00:24:56.810 --> 00:24:59.180
Now SQLite is a
relational database.

00:24:59.180 --> 00:25:02.720
So it can understand the
relations between entities.

00:25:02.720 --> 00:25:07.760
And if you are using any ORM on
Android or any other platform,

00:25:07.760 --> 00:25:11.010
they usually try to handle
these relations for you.

00:25:11.010 --> 00:25:14.210
So let's look at it,
how it works in Room.

00:25:14.210 --> 00:25:15.830
So if we have a
feed, we probably

00:25:15.830 --> 00:25:19.330
also has a user object, which
has posted this feed active.

00:25:19.330 --> 00:25:22.880
So you want to have a user
field inside that field,

00:25:22.880 --> 00:25:24.630
inside that entity.

00:25:24.630 --> 00:25:26.610
If you do this in
Room, it actually

00:25:26.610 --> 00:25:30.220
wants compiled application.

00:25:30.220 --> 00:25:32.980
The moral of the story--
we don't allow entities

00:25:32.980 --> 00:25:35.860
to contain other entities.

00:25:35.860 --> 00:25:37.360
Now you're probably asking, why?

00:25:37.360 --> 00:25:38.710
Everybody else does this.

00:25:38.710 --> 00:25:42.070
And if we can understand all
this SQLite, why can't we just

00:25:42.070 --> 00:25:43.270
enable this?

00:25:43.270 --> 00:25:46.450
Well, there's a very particular
reason for us not to do this.

00:25:46.450 --> 00:25:48.370
Is we have seen
a lot of problems

00:25:48.370 --> 00:25:53.410
with applications caused
by these kind of models.

00:25:53.410 --> 00:25:55.850
So I just want to go
through an example.

00:25:55.850 --> 00:25:57.730
So first, let's
look at this query.

00:25:57.730 --> 00:26:01.900
Starts to select a
feed with some ID.

00:26:01.900 --> 00:26:05.320
When we select this feed or
you look at this feed item,

00:26:05.320 --> 00:26:09.520
you cannot know whether it
also fetches the user or not.

00:26:09.520 --> 00:26:11.080
It's very hard to define.

00:26:11.080 --> 00:26:14.560
And most of the ORMs, the way
they solve this problem is,

00:26:14.560 --> 00:26:16.660
you just say, lazy loading.

00:26:16.660 --> 00:26:19.080
Until the user wants
to fetch that data,

00:26:19.080 --> 00:26:21.580
don't load it, which
works very well if you're

00:26:21.580 --> 00:26:23.560
working on the server side.

00:26:23.560 --> 00:26:27.970
But on the UI, it is a
little bit more tricky.

00:26:27.970 --> 00:26:29.970
So it's implied
that lazy loading.

00:26:29.970 --> 00:26:32.010
We could just generate
this code for you.

00:26:32.010 --> 00:26:34.170
You could say, just
keep a user ID,

00:26:34.170 --> 00:26:36.810
or say keep a user instance.

00:26:36.810 --> 00:26:38.670
When we get, user is
called we can say,

00:26:38.670 --> 00:26:42.310
if the user is the first time,
now fetch it from the database.

00:26:42.310 --> 00:26:44.730
Otherwise, just return
the existing [INAUDIBLE].

00:26:44.730 --> 00:26:47.340
It's very easy.

00:26:47.340 --> 00:26:51.990
We believe this is actually a
mine planted in your code base.

00:26:51.990 --> 00:26:53.613
Let's see how we explode it.

00:26:53.613 --> 00:26:57.470
We are using a recycler view
where we show these feed items.

00:26:57.470 --> 00:26:59.130
And I will get
the feed and we'll

00:26:59.130 --> 00:27:02.050
show the title and the
subtitle of the feed item.

00:27:02.050 --> 00:27:03.820
So it looks fine.

00:27:03.820 --> 00:27:06.480
And then like two months later,
your product manager comes.

00:27:06.480 --> 00:27:07.890
Actually, you know what?

00:27:07.890 --> 00:27:11.150
Let's show the user name
in that feed item, as well.

00:27:11.150 --> 00:27:12.220
It make sense.

00:27:12.220 --> 00:27:13.470
It's like, OK.

00:27:13.470 --> 00:27:14.040
So easy.

00:27:14.040 --> 00:27:17.980
Your developer goes, just adds
feed, get user, get user name,

00:27:17.980 --> 00:27:19.510
puts it on text view.

00:27:19.510 --> 00:27:20.310
You are done.

00:27:20.310 --> 00:27:21.570
You send the code to review.

00:27:21.570 --> 00:27:23.190
It looks obvious.

00:27:23.190 --> 00:27:25.020
It passes the code review.

00:27:25.020 --> 00:27:25.740
You test it.

00:27:25.740 --> 00:27:27.430
It looks fine, as well.

00:27:27.430 --> 00:27:29.960
But when your users
start using it,

00:27:29.960 --> 00:27:32.670
and then your application
starts receiving these ANRs,

00:27:32.670 --> 00:27:37.600
which stands for
"Application" Not Responding."

00:27:37.600 --> 00:27:40.345
This happens because when you
are testing the application,

00:27:40.345 --> 00:27:41.264
your own device.

00:27:41.264 --> 00:27:42.180
There is good network.

00:27:42.180 --> 00:27:43.390
Everything is fast.

00:27:43.390 --> 00:27:45.550
But when the user is
using their application,

00:27:45.550 --> 00:27:47.530
there's probably like
50 other applications

00:27:47.530 --> 00:27:49.240
that they're also trying to run.

00:27:49.240 --> 00:27:51.220
And if you want
to relate to this,

00:27:51.220 --> 00:27:53.860
just try to use your
application when Play Store is

00:27:53.860 --> 00:27:55.222
updating your applications.

00:27:55.222 --> 00:27:56.305
You will see how it feels.

00:27:58.980 --> 00:28:01.350
I mean, these are
still mobile devices.

00:28:01.350 --> 00:28:05.400
The disk on these devices is
actually relatively slower.

00:28:05.400 --> 00:28:08.194
And the UI thread only
has 60 milliseconds.

00:28:08.194 --> 00:28:10.110
So even if your query
takes five milliseconds,

00:28:10.110 --> 00:28:12.360
like ignore all the
locks and everything.

00:28:12.360 --> 00:28:13.740
Uses five milliseconds.

00:28:13.740 --> 00:28:15.330
Five milliseconds
is a lot of time.

00:28:15.330 --> 00:28:20.370
You can probably like lay out
20 recycler views at that time.

00:28:20.370 --> 00:28:23.040
So how do you solve
this problem with Room?

00:28:23.040 --> 00:28:26.610
Now previously, we said SQLite
is in a relational database.

00:28:26.610 --> 00:28:29.550
We should just take
advantage of it.

00:28:29.550 --> 00:28:30.740
We just keep the user ID.

00:28:30.740 --> 00:28:32.190
We know the feed is a user ID.

00:28:32.190 --> 00:28:33.210
Just keep it.

00:28:33.210 --> 00:28:35.610
And now, we can
write a query that

00:28:35.610 --> 00:28:39.230
says I want title,
subtitle, and username.

00:28:39.230 --> 00:28:42.630
And join me these two
tables on this constraint.

00:28:42.630 --> 00:28:46.650
Like this is already a solved
problem on the SQLite lang.

00:28:46.650 --> 00:28:49.170
Why don't we just embrace it?

00:28:49.170 --> 00:28:51.950
When you do this, it's faster.

00:28:51.950 --> 00:28:54.080
You only fetch
the data you need.

00:28:54.080 --> 00:28:58.060
And when you fetch the data,
you know that data is in memory.

00:28:58.060 --> 00:28:58.860
And I'll say, wait.

00:28:58.860 --> 00:29:00.960
What is this item?

00:29:00.960 --> 00:29:02.820
It can be like any Java class.

00:29:02.820 --> 00:29:05.940
It may even have a constructor
with public fields,

00:29:05.940 --> 00:29:07.760
public final fields.

00:29:07.760 --> 00:29:09.600
Room will set this
with [INAUDIBLE].

00:29:09.600 --> 00:29:13.870
We will use that constructor.

00:29:13.870 --> 00:29:15.580
You can even say,
return live data.

00:29:15.580 --> 00:29:17.680
Because Room knows
about the query,

00:29:17.680 --> 00:29:20.620
it knows it's querying
these two tables.

00:29:20.620 --> 00:29:22.190
Think about the other example.

00:29:22.190 --> 00:29:25.020
If you were observing the
feed, if the user changes,

00:29:25.020 --> 00:29:27.910
how do we know it should
validate the feed or not?

00:29:27.910 --> 00:29:30.250
But when you wrote
this, we actually know.

00:29:30.250 --> 00:29:32.090
We know what you are returning.

00:29:32.090 --> 00:29:33.670
We know which tables
you're querying.

00:29:33.670 --> 00:29:37.210
So we can be clever about this.

00:29:37.210 --> 00:29:38.560
So it's what we tell people.

00:29:38.560 --> 00:29:42.120
If you want to have relations
and you cannot use embedded

00:29:42.120 --> 00:29:45.670
or type adaptors, you
probably want to use POJOs

00:29:45.670 --> 00:29:48.340
for your relations, which
means you don't have any hidden

00:29:48.340 --> 00:29:49.390
costs.

00:29:49.390 --> 00:29:51.700
You only fetch what you need.

00:29:51.700 --> 00:29:52.840
And it's still observable.

00:29:52.840 --> 00:29:56.350
And you don't need to
do anything for that.

00:29:56.350 --> 00:29:58.540
But of course, we said
SQLite is relational

00:29:58.540 --> 00:30:00.220
and supports foreign keys.

00:30:00.220 --> 00:30:02.500
Room supports foreign
keys, as well.

00:30:02.500 --> 00:30:04.380
So inside your
entity, you can say,

00:30:04.380 --> 00:30:08.730
this entity has a foreign
key to this other entity,

00:30:08.730 --> 00:30:12.070
where I want to match the
ID column in that entity

00:30:12.070 --> 00:30:14.000
with this child column.

00:30:14.000 --> 00:30:16.620
SQLite foreign keys
also support like, you

00:30:16.620 --> 00:30:19.200
may have multiple fields
matching multiple fields

00:30:19.200 --> 00:30:20.550
in the other tables.

00:30:20.550 --> 00:30:21.360
It's very complex.

00:30:21.360 --> 00:30:23.370
You should just
go ahead and read.

00:30:23.370 --> 00:30:25.950
But once you declare
this, now SQLite

00:30:25.950 --> 00:30:27.520
knows about this relationship.

00:30:27.520 --> 00:30:29.880
And if it knows, you can say
things like, you know what?

00:30:29.880 --> 00:30:32.010
If someone tries to
delete that user,

00:30:32.010 --> 00:30:35.580
don't let them delete, because
I have a feed for them.

00:30:35.580 --> 00:30:38.850
Or you can say, if that user
is updated, please update me,

00:30:38.850 --> 00:30:40.510
as well.

00:30:40.510 --> 00:30:43.080
So we're trying to embrace
SQLite rather than trying

00:30:43.080 --> 00:30:48.000
to hide these details and
create a bunch of pitfalls.

00:30:48.000 --> 00:30:49.680
Index is another great thing.

00:30:49.680 --> 00:30:54.100
Now the SQLite keeps the data
on the disk in a structured way

00:30:54.100 --> 00:30:56.746
so that you can query it back.

00:30:56.746 --> 00:30:58.120
If we're going to
query like this

00:30:58.120 --> 00:31:00.190
where you want to
select feed items,

00:31:00.190 --> 00:31:02.200
which has a certain title.

00:31:02.200 --> 00:31:05.230
But if you just write this query
and don't do anything else,

00:31:05.230 --> 00:31:08.080
that means SQLite needs to
go through every single row

00:31:08.080 --> 00:31:11.680
in the database to find
the ones that are matching.

00:31:11.680 --> 00:31:15.560
Now, if you're not making this
query frequently, that's fine.

00:31:15.560 --> 00:31:18.250
But if this is the query
that you run frequently,

00:31:18.250 --> 00:31:20.890
you probably want to index it.

00:31:20.890 --> 00:31:22.046
It's very simple in Room.

00:31:22.046 --> 00:31:23.670
You just, inside the
entity annotation,

00:31:23.670 --> 00:31:29.570
you can say, well, can you
please index this column?

00:31:29.570 --> 00:31:31.120
If your query is
like this where your

00:31:31.120 --> 00:31:35.330
have like, you query title
and subtitle together,

00:31:35.330 --> 00:31:37.760
you can also create
a composite index,

00:31:37.760 --> 00:31:40.030
which means these two things
will be indexed together.

00:31:40.030 --> 00:31:43.435
So if you are querying
together, that will be fast.

00:31:46.090 --> 00:31:47.641
And you can have
multiple indexes.

00:31:47.641 --> 00:31:48.390
It doesn't matter.

00:31:48.390 --> 00:31:50.700
By the way, just because
you're querying something,

00:31:50.700 --> 00:31:54.150
doesn't mean you should index
it, because every index you add

00:31:54.150 --> 00:31:57.640
has a cost on every
insertion or data change.

00:31:57.640 --> 00:32:01.740
So you need to just measure and
see, well, what's the best way?

00:32:01.740 --> 00:32:06.240
And SQLite's documentation
on query planner is amazing.

00:32:06.240 --> 00:32:09.090
If you read that, you will
know how to write queries

00:32:09.090 --> 00:32:11.800
and how to optimize it.

00:32:11.800 --> 00:32:15.340
Now testing-- we
know in the past

00:32:15.340 --> 00:32:17.480
we haven't been very
good in this area.

00:32:17.480 --> 00:32:19.630
But when we were designing
architecture components,

00:32:19.630 --> 00:32:22.690
testing was a very, very
important topic for us.

00:32:22.690 --> 00:32:25.060
We want to have whatever
we create for architecture

00:32:25.060 --> 00:32:30.710
components, that they can
scale, and that can be testable.

00:32:30.710 --> 00:32:34.552
So let's look at how you
can test your queries.

00:32:34.552 --> 00:32:36.010
By the way, you
should really test.

00:32:36.010 --> 00:32:38.410
Just because we are
verifying your SQL queries

00:32:38.410 --> 00:32:41.800
doesn't mean that that's
what you really intended.

00:32:41.800 --> 00:32:43.600
Your Java code compiles.

00:32:43.600 --> 00:32:45.100
But you still test it.

00:32:45.100 --> 00:32:47.230
Similarly, if your
Room SQL compiles,

00:32:47.230 --> 00:32:49.730
you should still test it.

00:32:49.730 --> 00:32:51.420
But testing Room is
actually very easy.

00:32:51.420 --> 00:32:54.432
Now, we still recommend
testing on the device.

00:32:54.432 --> 00:32:55.890
But there's no
activity on your UI.

00:32:55.890 --> 00:32:57.580
So they run faster.

00:32:57.580 --> 00:33:00.370
You can also test on
the JVM by changing

00:33:00.370 --> 00:33:03.020
the SQLite bindings we use.

00:33:03.020 --> 00:33:06.830
So I'm just going
through a sample case.

00:33:06.830 --> 00:33:10.440
So before each test is
created, I create my database.

00:33:10.440 --> 00:33:13.000
But I create an
in-memory database,

00:33:13.000 --> 00:33:16.390
which means the database will
be created when the test starts.

00:33:16.390 --> 00:33:17.860
And I can clean it afterwards.

00:33:17.860 --> 00:33:21.850
You want these tests to run
isolated from other tests.

00:33:21.850 --> 00:33:24.520
So you don't want to
save the data into disk.

00:33:24.520 --> 00:33:27.250
So I say after, just close
the database so the memory

00:33:27.250 --> 00:33:29.310
can be released fast.

00:33:29.310 --> 00:33:30.670
And I can write it as--

00:33:30.670 --> 00:33:33.430
this is just like
I create an item.

00:33:33.430 --> 00:33:37.110
I insert it to Room and then
make some queries on it.

00:33:37.110 --> 00:33:40.780
And I verify that
is what I expect.

00:33:40.780 --> 00:33:43.030
But the way Room is
designed actually

00:33:43.030 --> 00:33:45.420
helps with the overall
application testing.

00:33:45.420 --> 00:33:50.200
So you remember we talked about
those DAO classes we generate?

00:33:50.200 --> 00:33:53.410
Because you defined how
you access the database

00:33:53.410 --> 00:33:57.070
as an interface, which has
nothing to do with SQL,

00:33:57.070 --> 00:34:00.800
you can very, very
easily mock it.

00:34:00.800 --> 00:34:03.730
So if you have a view model that
you want to test, first of all,

00:34:03.730 --> 00:34:06.930
you can test view
models on your computer.

00:34:06.930 --> 00:34:09.699
You don't need to run
them on the device.

00:34:09.699 --> 00:34:12.820
You can create a mock
of that DAO You can just

00:34:12.820 --> 00:34:14.139
use Mockito to mock it.

00:34:14.139 --> 00:34:16.030
And now you can write
a test like this,

00:34:16.030 --> 00:34:18.909
like when loadFeed with
these parameters called,

00:34:18.909 --> 00:34:20.320
return these feeds.

00:34:20.320 --> 00:34:22.330
Because it's just
a Java interface,

00:34:22.330 --> 00:34:25.520
there's not even any
mention of database there.

00:34:25.520 --> 00:34:29.080
So it's all very well abstracted
without you doing anything.

00:34:32.760 --> 00:34:36.139
Now, migrations is
another important topic.

00:34:36.139 --> 00:34:39.020
So as you use the
application over time,

00:34:39.020 --> 00:34:41.092
your entities will change.

00:34:41.092 --> 00:34:42.800
Let's say if you have
these user objects,

00:34:42.800 --> 00:34:44.590
now we start to
show user photos,

00:34:44.590 --> 00:34:48.000
so you want to add this
new field into that.

00:34:48.000 --> 00:34:53.000
If you do that when you run
the application, as soon as you

00:34:53.000 --> 00:34:55.030
first access the
database, Room will say,

00:34:55.030 --> 00:34:57.050
oops, looks like you
changed the schema,

00:34:57.050 --> 00:34:59.690
but you didn't
increase the version.

00:34:59.690 --> 00:35:01.730
It's going to crash
your application.

00:35:01.730 --> 00:35:03.030
Now you need to handle this.

00:35:03.030 --> 00:35:05.650
You can simply increase
your database version

00:35:05.650 --> 00:35:07.760
in the annotation,
which means you don't

00:35:07.760 --> 00:35:09.290
want any of the previous data.

00:35:09.290 --> 00:35:11.570
You want to start from scratch.

00:35:11.570 --> 00:35:14.950
Or you could write a migration.

00:35:14.950 --> 00:35:18.330
Now, to write the migrations
in our database builder,

00:35:18.330 --> 00:35:21.090
you can just pass a couple
of migration implementations.

00:35:21.090 --> 00:35:24.450
Like this one says, I know how
to migrate from one to two.

00:35:24.450 --> 00:35:26.760
You can have one from two
to three, three to four.

00:35:26.760 --> 00:35:29.460
And then Room will
run whatever necessary

00:35:29.460 --> 00:35:32.400
from the current version on the
device to your latest version.

00:35:32.400 --> 00:35:34.060
It will just chain them.

00:35:34.060 --> 00:35:35.810
And if anything in
the middle is missing,

00:35:35.810 --> 00:35:38.790
it's going to
recreate the database.

00:35:38.790 --> 00:35:41.040
Another important thing to
know-- in these migrations,

00:35:41.040 --> 00:35:42.380
don't use any constants.

00:35:42.380 --> 00:35:44.670
Always use full SQLite,
because over time,

00:35:44.670 --> 00:35:47.760
your application will change,
those constants may change,

00:35:47.760 --> 00:35:50.235
and you will get bugs.

00:35:50.235 --> 00:35:51.760
OK, we wrote this.

00:35:51.760 --> 00:35:55.030
But we said testing
is important, right?

00:35:55.030 --> 00:35:58.240
So Room also comes with a
testing name and artifact.

00:35:58.240 --> 00:36:00.310
We have separate
artifacts so that you

00:36:00.310 --> 00:36:02.980
can test your migrations.

00:36:02.980 --> 00:36:04.400
Now, just is a couple of steps.

00:36:04.400 --> 00:36:08.500
First, when we compile Room, we
can actually ask Room to export

00:36:08.500 --> 00:36:11.200
the schema-- that's how
your database looks--

00:36:11.200 --> 00:36:14.290
into some JSON files, which
you should be committing

00:36:14.290 --> 00:36:17.570
to your version control system.

00:36:17.570 --> 00:36:18.600
Pass argument.

00:36:18.600 --> 00:36:22.190
And then we want these schema
files to be visible to our test

00:36:22.190 --> 00:36:25.620
so that we can access them.

00:36:25.620 --> 00:36:27.630
Last but not least,
for our Android test,

00:36:27.630 --> 00:36:30.450
we add this new
dependency from Room

00:36:30.450 --> 00:36:33.030
which includes some helper
classes that will help us

00:36:33.030 --> 00:36:36.220
with our migration testing.

00:36:36.220 --> 00:36:40.170
So let's say we are trying to
test a migration from version

00:36:40.170 --> 00:36:41.270
one to three.

00:36:41.270 --> 00:36:43.560
Does this migration
test helper class,

00:36:43.560 --> 00:36:47.480
which comes from that artifact?

00:36:47.480 --> 00:36:49.990
We create an instance
of that helper.

00:36:49.990 --> 00:36:54.665
This canonical name is how Room
exports these files by default.

00:36:54.665 --> 00:36:56.630
We don't need to
think about it much.

00:36:56.630 --> 00:36:59.030
And we create an
open helper factory.

00:36:59.030 --> 00:37:02.510
One we have that, we say, OK,
migrate from one to three.

00:37:02.510 --> 00:37:06.080
We ask helper to create
the database at version 1.

00:37:06.080 --> 00:37:08.690
You may even have entities
that doesn't exist anymore.

00:37:08.690 --> 00:37:10.490
It doesn't matter,
because it did

00:37:10.490 --> 00:37:12.680
export the schema previously.

00:37:12.680 --> 00:37:16.010
By reading that, it's going
to recreate your database

00:37:16.010 --> 00:37:17.450
in that version.

00:37:17.450 --> 00:37:20.720
You can just change it directly
from whatever you want.

00:37:20.720 --> 00:37:23.060
But as you realize, this
doesn't return your DAO.

00:37:23.060 --> 00:37:24.770
It just returns your
database instance,

00:37:24.770 --> 00:37:28.900
because DAO may not
be valid anymore.

00:37:28.900 --> 00:37:31.230
You can just say,
run these migrations

00:37:31.230 --> 00:37:32.810
and validate the schema.

00:37:32.810 --> 00:37:34.990
Well, then we give
the database name.

00:37:34.990 --> 00:37:37.290
We give it the version we want.

00:37:37.290 --> 00:37:40.200
Now, you may have tables
that you had before.

00:37:40.200 --> 00:37:42.390
And maybe you want
to still keep them,

00:37:42.390 --> 00:37:44.130
but don't tell Room about it.

00:37:44.130 --> 00:37:47.680
So you can decide whether we
should check for these or not.

00:37:47.680 --> 00:37:50.610
And now you give a
list of migrations.

00:37:50.610 --> 00:37:52.140
These are all
migrations we have.

00:37:52.140 --> 00:37:54.750
What Room will do is
migrate the database

00:37:54.750 --> 00:37:57.330
from the previous version
to the new version,

00:37:57.330 --> 00:37:59.660
and then check the
schema for you.

00:37:59.660 --> 00:38:02.950
And then if you have
custom things like change

00:38:02.950 --> 00:38:08.430
the entities in the previous
versions to the new versions,

00:38:08.430 --> 00:38:13.080
then you can manually
assert on these things.

00:38:13.080 --> 00:38:14.420
OK, so that was Room.

00:38:14.420 --> 00:38:19.040
We have a very detailed
documentation on the web page.

00:38:19.040 --> 00:38:22.740
By the way, like we do for Room,
also for all our architecture

00:38:22.740 --> 00:38:26.790
components, we have a testing
artifact which includes

00:38:26.790 --> 00:38:31.320
one rule for JUnit and one rule
for your instrumentation test,

00:38:31.320 --> 00:38:34.770
that helps with dealing with
the background test we use.

00:38:34.770 --> 00:38:36.750
So we want to make
sure everything

00:38:36.750 --> 00:38:38.280
we have here is testable.

00:38:38.280 --> 00:38:40.750
And if it is not,
we will fix it.

00:38:40.750 --> 00:38:42.852
So what's next for you?

00:38:42.852 --> 00:38:44.370
Room is available today.

00:38:44.370 --> 00:38:45.540
Please go check it.

00:38:45.540 --> 00:38:46.740
Play with it.

00:38:46.740 --> 00:38:49.020
See how it looks.

00:38:49.020 --> 00:38:51.330
Check out
developer.andorid.com/arch,

00:38:51.330 --> 00:38:53.700
which is the main page for
all of these architecture

00:38:53.700 --> 00:38:54.810
components.

00:38:54.810 --> 00:38:57.150
Now we say, these can
work independently.

00:38:57.150 --> 00:38:59.430
But these also work
very well together,

00:38:59.430 --> 00:39:03.030
as we've seen in the live
data example Kirill had.

00:39:03.030 --> 00:39:04.140
So check it out.

00:39:04.140 --> 00:39:05.610
And also check out the codelabs.

00:39:05.610 --> 00:39:08.790
We have codelabs for
both Room and lifecycles.

00:39:08.790 --> 00:39:11.590
And they're available
in the code lab.

00:39:11.590 --> 00:39:12.890
Thank you.

00:39:12.890 --> 00:39:14.730
[APPLAUSE]

00:39:14.730 --> 00:39:18.740
[MUSIC PLAYING]

