WEBVTT
Kind: captions
Language: en

00:00:02.304 --> 00:00:03.720
PROFESSOR ERIK
DEMAINE: All right,

00:00:03.720 --> 00:00:06.640
so this lecture we
talked about fold

00:00:06.640 --> 00:00:09.450
and one cut, two
methods and a little bit

00:00:09.450 --> 00:00:11.860
about polyhedron flattening,
so most of the questions

00:00:11.860 --> 00:00:13.150
are about fold and one cut.

00:00:13.150 --> 00:00:14.970
I'll stick to that.

00:00:14.970 --> 00:00:17.900
First question is, is
there an equal software

00:00:17.900 --> 00:00:19.330
for doing fold-and-cut now?

00:00:19.330 --> 00:00:22.710
And the answer is yes,
there's some software.

00:00:22.710 --> 00:00:25.840
Maybe not the coolest possible
yet, but it's getting there.

00:00:25.840 --> 00:00:27.450
There's two pieces of software.

00:00:27.450 --> 00:00:34.150
One is from Final Project after
this lecture was given, 2010.

00:00:34.150 --> 00:00:36.610
And another one is in
SourceForge project

00:00:36.610 --> 00:00:39.880
called JOrigami, or J Origami.

00:00:39.880 --> 00:00:41.640
Both are written
in Java, I believe.

00:00:41.640 --> 00:00:43.160
I have this one.

00:00:43.160 --> 00:00:47.620
This is the swan, which
you've seen before.

00:00:47.620 --> 00:00:48.910
I have it here.

00:00:48.910 --> 00:00:50.740
We can try it out.

00:00:55.790 --> 00:01:00.500
It's not online yet, because
it could use some improvements,

00:01:00.500 --> 00:01:04.269
but it's already pretty cool.

00:01:04.269 --> 00:01:08.390
So you can take something
like the angelfish here,

00:01:08.390 --> 00:01:13.490
and if you like,
it has an editor

00:01:13.490 --> 00:01:15.530
so you can move
your polygon around.

00:01:15.530 --> 00:01:19.090
And you can say, OK, please
give me the straight skeleton,

00:01:19.090 --> 00:01:22.400
first straight skeleton only,
and it will update on the fly,

00:01:22.400 --> 00:01:25.570
and gives you some nice
intuition about how that works.

00:01:25.570 --> 00:01:27.950
I know that looks weird
that it goes up that way,

00:01:27.950 --> 00:01:31.380
but it is correct,
because it's bisecting

00:01:31.380 --> 00:01:38.986
this edge and some
edge, this one I guess.

00:01:38.986 --> 00:01:40.860
They meet out here, and
then you go that way.

00:01:44.286 --> 00:01:45.910
So you can play with
that, and then you

00:01:45.910 --> 00:01:48.120
can add in the
perpendiculars too.

00:01:48.120 --> 00:01:49.870
Takes a little bit
longer, so the refresh

00:01:49.870 --> 00:01:52.390
may not be as immediate.

00:01:52.390 --> 00:01:54.810
But it works.

00:01:54.810 --> 00:01:58.430
It's really complicated behavior
in there, some spiraling in,

00:01:58.430 --> 00:02:00.610
spiraling out, but it's
fairly well-behaved.

00:02:06.220 --> 00:02:08.795
Here's one of the simpler
spiraling examples.

00:02:13.320 --> 00:02:15.840
This one is stable under
perturbation more or less.

00:02:15.840 --> 00:02:18.290
You move the vertices
all a little bit.

00:02:18.290 --> 00:02:21.420
They should continue spiraling.

00:02:21.420 --> 00:02:23.650
It looks like that one is
a little bit degenerate.

00:02:23.650 --> 00:02:26.410
So we'll go around, and as you
go get bigger and bigger pieces

00:02:26.410 --> 00:02:28.201
of paper, you'll get
more and more creases.

00:02:32.210 --> 00:02:36.990
I should mention, you can
add new vertices as well

00:02:36.990 --> 00:02:39.750
and draw polygon.

00:02:39.750 --> 00:02:41.680
You can delete edges.

00:02:41.680 --> 00:02:43.650
I'm holding all sorts
of crazy modifier keys

00:02:43.650 --> 00:02:47.230
to make this happen,
but it does work.

00:02:47.230 --> 00:02:49.290
The one other thing you
can do is snap to a grid.

00:02:49.290 --> 00:02:51.581
This is probably hard to see,
but there's a square grid

00:02:51.581 --> 00:02:52.320
underneath.

00:02:52.320 --> 00:02:56.000
If you hold down Alt, it
snaps to a square grid.

00:02:56.000 --> 00:02:58.160
I have one other
example I've prepared.

00:02:58.160 --> 00:03:00.330
It has save and load,
which is pretty cool.

00:03:00.330 --> 00:03:07.980
And this example is one
of the dense instances.

00:03:07.980 --> 00:03:09.720
Although this one has
rational multiples,

00:03:09.720 --> 00:03:11.430
so it doesn't
actually go forever.

00:03:11.430 --> 00:03:13.370
Because I drew it
on the grid so that

00:03:13.370 --> 00:03:15.540
could get all the
horizontal and verticals.

00:03:15.540 --> 00:03:18.290
And you can see in
particular it stops

00:03:18.290 --> 00:03:22.190
here, because at some
point it gives up

00:03:22.190 --> 00:03:24.920
in reflecting perpendiculars,
says that's enough.

00:03:24.920 --> 00:03:27.190
It won't draw anymore.

00:03:27.190 --> 00:03:29.750
So it's fairly
robust in that sense.

00:03:29.750 --> 00:03:32.482
Occasionally it's using
some straight skeleton

00:03:32.482 --> 00:03:34.440
code they did not write,
and it has some issues

00:03:34.440 --> 00:03:36.630
when you have really
degenerate situations,

00:03:36.630 --> 00:03:38.310
which they tried to mitigate.

00:03:38.310 --> 00:03:39.739
But occasionally
it's not perfect.

00:03:39.739 --> 00:03:41.280
But there are lots
of possible follow

00:03:41.280 --> 00:03:44.882
on projects to this work,
improving the user interface.

00:03:44.882 --> 00:03:46.590
Actually putting it
on the web for people

00:03:46.590 --> 00:03:48.441
to play with, I think,
would be super cool.

00:03:48.441 --> 00:03:50.690
Alternatively, could port
it to JavaScript-- right now

00:03:50.690 --> 00:03:53.310
it's in Java-- and make it
even more accessible run

00:03:53.310 --> 00:03:54.995
on iPhones and things like that.

00:03:57.990 --> 00:04:00.190
Still, one of the questions
I've posed in lecture

00:04:00.190 --> 00:04:02.390
was, can you make a
nice interface that

00:04:02.390 --> 00:04:04.170
would let you
force degeneracies,

00:04:04.170 --> 00:04:12.760
make like in-- I think the swan
has instances of this, where

00:04:12.760 --> 00:04:22.540
you'd like more than three
skeleton edges to come together

00:04:22.540 --> 00:04:23.040
at a point.

00:04:23.040 --> 00:04:24.720
Here they almost do.

00:04:24.720 --> 00:04:28.104
It would be nice to be able
to say, and for it to snap

00:04:28.104 --> 00:04:30.020
to a position where many
things come together.

00:04:30.020 --> 00:04:32.144
Because that, in general,
reduces number of creases

00:04:32.144 --> 00:04:33.052
substantially.

00:04:33.052 --> 00:04:35.010
You could also try to
compute the folded state.

00:04:35.010 --> 00:04:37.840
That would be another
interesting project

00:04:37.840 --> 00:04:39.810
based on what we're
going to talk about

00:04:39.810 --> 00:04:42.800
in a little bit,
folding the underlying

00:04:42.800 --> 00:04:44.340
structure of corridors.

00:04:44.340 --> 00:04:45.530
And then you can computer
a crease pattern.

00:04:45.530 --> 00:04:46.800
And there you have
various choices,

00:04:46.800 --> 00:04:48.925
and that lets you throw
away some of these creases.

00:04:48.925 --> 00:04:50.920
Like this is much messier
than the swan crease

00:04:50.920 --> 00:04:52.670
pattern that's on my
web page, because you

00:04:52.670 --> 00:04:54.050
don't need all these folds.

00:04:54.050 --> 00:04:55.970
If you choose the
right subset of folds

00:04:55.970 --> 00:04:59.690
you can save a lot of time.

00:04:59.690 --> 00:05:03.400
So, still lots of cool
projects to do here.

00:05:03.400 --> 00:05:05.190
It'd be great to get
this software online,

00:05:05.190 --> 00:05:07.270
but that's its current state.

00:05:07.270 --> 00:05:11.180
Next question is, what
about odd degree vertices?

00:05:11.180 --> 00:05:13.895
This is actually a
pretty natural question.

00:05:16.490 --> 00:05:20.650
Even degree vertices seem nice
because you can kind of-- well,

00:05:20.650 --> 00:05:22.480
it relates to a page
that I didn't really

00:05:22.480 --> 00:05:25.830
talk very much about
in the lecture,

00:05:25.830 --> 00:05:30.320
but it was in the lecture notes,
this idea of a side assignment.

00:05:30.320 --> 00:05:32.480
So in general, if you have
something like a swan,

00:05:32.480 --> 00:05:34.270
there's the inside of the
swan, the outside of the swan,

00:05:34.270 --> 00:05:36.070
and generally you have
a bunch of regions.

00:05:36.070 --> 00:05:37.653
And for each region
you'd like to know

00:05:37.653 --> 00:05:40.130
is it above the cut line
or below the cut line?

00:05:40.130 --> 00:05:43.690
If you imagine the cut
line as horizontal.

00:05:43.690 --> 00:05:45.600
And in general,
the side assignment

00:05:45.600 --> 00:05:48.440
would specify, do I want
my region above or below?

00:05:48.440 --> 00:05:50.200
And you could do
whatever you want.

00:05:50.200 --> 00:05:52.140
Now with even degree
vertices, this is great.

00:05:52.140 --> 00:05:54.430
You could just alternate
around and say, above,

00:05:54.430 --> 00:05:55.660
below, above, below.

00:05:55.660 --> 00:05:57.190
With odd degree
vertices, you can't,

00:05:57.190 --> 00:05:58.856
so you're going to
have two regions that

00:05:58.856 --> 00:06:02.730
are adjacent to each other which
are both above or both below.

00:06:02.730 --> 00:06:04.210
So what does that mean?

00:06:06.840 --> 00:06:09.960
It means it's a little
bit hard to cut.

00:06:09.960 --> 00:06:12.810
And there's actually
two models of cuts.

00:06:12.810 --> 00:06:19.210
There's scissor cuts-- which are
in particular what the question

00:06:19.210 --> 00:06:21.080
poser had in mind,
and probably what

00:06:21.080 --> 00:06:24.510
you might have had in mind in
general-- where the cut you're

00:06:24.510 --> 00:06:28.670
going to make separates material
from above and below the line.

00:06:28.670 --> 00:06:32.020
So this is the cut line here.

00:06:32.020 --> 00:06:34.500
And it'd be really nice if you
had material on both sides,

00:06:34.500 --> 00:06:38.310
because that's usually how
scissors work, they tear apart

00:06:38.310 --> 00:06:40.190
material.

00:06:40.190 --> 00:06:45.520
An alternative is that you
have a mathematical cut.

00:06:45.520 --> 00:06:49.290
And a mathematical cut can
cut right along a crease line.

00:06:49.290 --> 00:06:54.100
So it could be you
have two polygons,

00:06:54.100 --> 00:06:58.120
there's a fold here between
them, and you can cut right

00:06:58.120 --> 00:07:00.260
along that line.

00:07:00.260 --> 00:07:02.490
Maybe I shouldn't draw scissors.

00:07:02.490 --> 00:07:07.315
Imagine a laser beam which
can zap right along the line,

00:07:07.315 --> 00:07:09.690
so there's no material on the
left side of the line, just

00:07:09.690 --> 00:07:11.064
material on the
right, but yet it

00:07:11.064 --> 00:07:13.240
separates the two
things on the right.

00:07:13.240 --> 00:07:17.170
So we call that
mathematical cut,

00:07:17.170 --> 00:07:19.690
because it is the natural
definition mathematically.

00:07:19.690 --> 00:07:21.282
You're erasing a line.

00:07:21.282 --> 00:07:22.990
But practically it's
a little hard to do.

00:07:22.990 --> 00:07:24.400
So scissor cuts are also nice.

00:07:24.400 --> 00:07:25.990
This is a more
restrictive model.

00:07:25.990 --> 00:07:27.490
This is general model.

00:07:27.490 --> 00:07:29.770
So what I was talking
about in lecture,

00:07:29.770 --> 00:07:31.570
implicitly use
mathematical cuts.

00:07:31.570 --> 00:07:36.380
And that's when you could
make anything with one cut.

00:07:36.380 --> 00:07:41.290
But, it would be nice to get
scissor cuts when possible.

00:07:41.290 --> 00:07:43.280
And when possible
is basically when

00:07:43.280 --> 00:07:46.090
you have even degree
at every vertex.

00:07:46.090 --> 00:07:48.980
And one fun example of
that is checkerboard.

00:07:48.980 --> 00:07:50.690
This is actually
an old magic trick.

00:07:50.690 --> 00:07:53.360
You have a piece of usually
tissue paper, so it's

00:07:53.360 --> 00:07:57.460
really thin, pre colored
as checkered squares,

00:07:57.460 --> 00:07:59.640
both sides matching.

00:07:59.640 --> 00:08:03.520
And you can fold this,
because every vertex here

00:08:03.520 --> 00:08:06.730
has degree 4, so
even degree, you

00:08:06.730 --> 00:08:09.169
can assign the
black squares to be

00:08:09.169 --> 00:08:10.710
on one side or the
blue squares to be

00:08:10.710 --> 00:08:12.876
one side, the white squares
to be on the other side.

00:08:12.876 --> 00:08:15.340
And so you could make one cut
and simultaneously cut out

00:08:15.340 --> 00:08:17.548
all the white squares and
all the black squares which

00:08:17.548 --> 00:08:18.990
is kind of cool.

00:08:18.990 --> 00:08:21.390
This is old, decades old.

00:08:23.960 --> 00:08:37.054
So in general, you can do
something with scissor cuts.

00:08:40.484 --> 00:08:43.549
Or scissor cuts are going
to be possible if and only

00:08:43.549 --> 00:08:51.300
if you can find
a side assignment

00:08:51.300 --> 00:08:57.880
that sort of alternates between
above and below the cut line.

00:09:02.330 --> 00:09:05.532
Meaning when you have two
regions that are adjacent,

00:09:05.532 --> 00:09:07.490
you don't want them both
to be above and below.

00:09:07.490 --> 00:09:10.670
You'd like one to be
above, one to be below.

00:09:10.670 --> 00:09:16.420
And this is what's called a face
2-coloring in planar graphs.

00:09:16.420 --> 00:09:20.470
You want to color the faces,
the regions of your graph,

00:09:20.470 --> 00:09:23.400
with two colors such that
no two adjacent cells have

00:09:23.400 --> 00:09:26.140
the same color, no two adjacent
faces have the same color,

00:09:26.140 --> 00:09:28.620
and that turns out to
be equivalent to having

00:09:28.620 --> 00:09:30.120
all vertices of even degree.

00:09:33.940 --> 00:09:36.330
So this is why that question
was asking about odd degree,

00:09:36.330 --> 00:09:40.720
because indeed with scissor
cuts, you can't do odd degree.

00:09:40.720 --> 00:09:44.870
There is a fun fact, though,
that relates these two things.

00:09:44.870 --> 00:09:47.060
So if you have even
degree like polygons,

00:09:47.060 --> 00:09:49.760
which is typical case, scissor
cuts should be possible.

00:09:53.710 --> 00:09:56.051
Mathematical cuts
can do everything.

00:09:56.051 --> 00:09:58.300
What if I have something
that has odd degree vertices,

00:09:58.300 --> 00:10:00.110
but I still want to
use scissor cuts?

00:10:00.110 --> 00:10:04.360
Well then, it turns out two
cuts are enough, pretty much.

00:10:04.360 --> 00:10:23.630
That if you have, I'll call it
a 2-edge-connected planar graph,

00:10:23.630 --> 00:10:29.505
equals the union
of two even graphs.

00:10:32.030 --> 00:10:35.144
I should say even subgraphs.

00:10:35.144 --> 00:10:37.260
It doesn't much matter.

00:10:37.260 --> 00:10:39.820
So there's one
exception, which is,

00:10:39.820 --> 00:10:43.620
if you have an edge in
your desired set of cuts,

00:10:43.620 --> 00:10:48.420
that partitions the
graph into two parts.

00:10:48.420 --> 00:10:51.540
So if you could delete an
edge and disconnect the graph

00:10:51.540 --> 00:10:56.350
into more parts, there's
no hope of decomposing this

00:10:56.350 --> 00:10:58.186
into even graphs.

00:10:58.186 --> 00:11:00.740
I think.

00:11:00.740 --> 00:11:02.210
Should check that.

00:11:02.210 --> 00:11:04.290
But as long as you
do not have such,

00:11:04.290 --> 00:11:07.680
these are called
bridges, typically.

00:11:07.680 --> 00:11:09.080
So bridges are forbidden.

00:11:09.080 --> 00:11:11.190
If you have no
bridges, then you're

00:11:11.190 --> 00:11:13.319
at what's called a
2-edge-connected planar graph.

00:11:13.319 --> 00:11:14.860
And then you can
decompose your graph

00:11:14.860 --> 00:11:17.300
into two parts, each
of which is even.

00:11:17.300 --> 00:11:19.180
So you could fold,
make one straight cut,

00:11:19.180 --> 00:11:21.940
and get one even graph,
fold, make once straight cut,

00:11:21.940 --> 00:11:23.130
get the other even graph.

00:11:23.130 --> 00:11:26.910
Good luck folding it the
second time if it decomposed.

00:11:26.910 --> 00:11:29.780
But in theory at least,
with two scissor cuts,

00:11:29.780 --> 00:11:34.530
you can make anything
that doesn't have bridges.

00:11:34.530 --> 00:11:37.130
So that's just kind of an aside.

00:11:37.130 --> 00:11:40.007
Some graph theory that
tells you a little bit more

00:11:40.007 --> 00:11:41.590
about what you can
do with two scissor

00:11:41.590 --> 00:11:44.420
cuts-- pretty much everything.

00:11:44.420 --> 00:11:48.230
Any more questions about that?

00:11:48.230 --> 00:11:49.755
So that was odd degree vertices.

00:11:53.830 --> 00:12:01.100
Next questions are about
folding and how exactly-- so

00:12:01.100 --> 00:12:04.820
I kind of briefly sketched the
proof for linear corridors,

00:12:04.820 --> 00:12:08.220
how you would fold
or how you would

00:12:08.220 --> 00:12:10.230
prove that this
thing actually folds.

00:12:10.230 --> 00:12:12.840
This is the skeleton
method first.

00:12:12.840 --> 00:12:15.270
We'll go to
disk-packing afterwards.

00:12:15.270 --> 00:12:19.480
So how do you convert a set of
linear quarters into a tree?

00:12:19.480 --> 00:12:21.490
Then once you have
that correspondence,

00:12:21.490 --> 00:12:23.500
how does trees
folding flat relate

00:12:23.500 --> 00:12:26.530
to corridors folding flat?

00:12:26.530 --> 00:12:30.430
And so I redrew this figure to
make it a little bit clearer.

00:12:30.430 --> 00:12:33.910
So this is one of the images
in the textbook where I just

00:12:33.910 --> 00:12:37.900
face colored, in this case with
three colors, the corridors.

00:12:37.900 --> 00:12:39.580
Those are the regions
of constant width

00:12:39.580 --> 00:12:41.940
bounded by perpendiculars.

00:12:41.940 --> 00:12:43.240
This is for making a turtle.

00:12:43.240 --> 00:12:45.450
That sort of doesn't
really matter.

00:12:45.450 --> 00:12:47.680
And this is the
corresponding tree.

00:12:47.680 --> 00:12:52.670
And this is the folded
state of this blue guy

00:12:52.670 --> 00:12:55.130
here between B and C.

00:12:55.130 --> 00:12:58.230
And to really illustrate
what's going on here,

00:12:58.230 --> 00:12:59.240
I folded this thing.

00:12:59.240 --> 00:13:02.690
It's tricky to fold, let's say.

00:13:02.690 --> 00:13:07.240
And I added a few paper
clips to make it really stay.

00:13:07.240 --> 00:13:11.460
But if you hold it right, which
is a little bit challenging,

00:13:11.460 --> 00:13:17.690
the projection of this
structure is exactly this tree.

00:13:17.690 --> 00:13:20.830
Maybe let me show
you some examples.

00:13:20.830 --> 00:13:26.830
Out here, for example,
this flap is labeled A B,

00:13:26.830 --> 00:13:29.370
so it corresponds to this flap.

00:13:29.370 --> 00:13:34.180
And it corresponds to the
material here between A and B.

00:13:34.180 --> 00:13:39.136
And this A part is at the very
tip here, and attached to this

00:13:39.136 --> 00:13:40.190
is this guy.

00:13:40.190 --> 00:13:42.581
That would be this
unlabeled pink edge,

00:13:42.581 --> 00:13:43.830
which corresponds to this one.

00:13:43.830 --> 00:13:46.500
It's unlabeled, because it goes
off to infinity in principle.

00:13:46.500 --> 00:13:48.000
So this would just keep going.

00:13:48.000 --> 00:13:49.890
This one turns
around right here.

00:13:49.890 --> 00:13:53.290
Then there's this edge,
this bit of material.

00:13:53.290 --> 00:13:56.320
Sorry, it's probably easier
for you to see from that side.

00:13:56.320 --> 00:13:59.540
And that corresponds
to this BC part,

00:13:59.540 --> 00:14:01.160
which is exactly this folding.

00:14:01.160 --> 00:14:03.930
And if I laser cut
or even scissor

00:14:03.930 --> 00:14:07.930
cut down these two
lines, and just

00:14:07.930 --> 00:14:09.510
cut out that little
folded part, it

00:14:09.510 --> 00:14:11.980
would look exactly like this.

00:14:11.980 --> 00:14:15.280
So conversely, I was sort
of begging the question

00:14:15.280 --> 00:14:17.730
by assuming I could
fold this thing,

00:14:17.730 --> 00:14:19.570
if you don't know how
to fold this thing,

00:14:19.570 --> 00:14:21.070
you can go on the
reverse direction

00:14:21.070 --> 00:14:23.870
and figure out how to
fold it by first modeling

00:14:23.870 --> 00:14:25.720
these corridors as a tree.

00:14:25.720 --> 00:14:27.010
How do you do that?

00:14:27.010 --> 00:14:30.000
It's just like in
the tree method,

00:14:30.000 --> 00:14:33.010
going from crease pattern
from the tree method

00:14:33.010 --> 00:14:35.940
to the shadow tree.

00:14:35.940 --> 00:14:38.480
Except there, we were given
the shadow tree as input.

00:14:38.480 --> 00:14:41.894
Here, we have to compute it.

00:14:41.894 --> 00:14:43.935
But it's like what you
solved in the problem set.

00:14:43.935 --> 00:14:46.640
Is it one or two?

00:14:46.640 --> 00:14:49.500
For each of these corridors,
it has fixed width,

00:14:49.500 --> 00:14:51.605
so you make an edge
of that length.

00:14:51.605 --> 00:14:53.140
It's not quite
drawn to scale here.

00:14:53.140 --> 00:14:56.090
This has been scaled up by
roughly a factor of two.

00:14:56.090 --> 00:14:59.740
So this length
becomes this length.

00:14:59.740 --> 00:15:01.210
And you label it the same thing.

00:15:01.210 --> 00:15:04.966
This set of connecting
component of perpendiculars A

00:15:04.966 --> 00:15:06.130
goes to that point.

00:15:06.130 --> 00:15:08.860
The connected component
of perpendiculars here,

00:15:08.860 --> 00:15:10.760
this thing which
branches, all of that

00:15:10.760 --> 00:15:14.200
is B. It's like a hinge
in the tree method.

00:15:14.200 --> 00:15:17.870
So that's going to be a hinge
between this flap and two

00:15:17.870 --> 00:15:21.780
other flaps, whatever
touches the B perpendicular.

00:15:21.780 --> 00:15:25.370
So there's this pink one,
and there's the cyan one.

00:15:25.370 --> 00:15:27.800
Cyan one is here.

00:15:27.800 --> 00:15:31.050
It's attached to whatever
C is attached to.

00:15:31.050 --> 00:15:32.810
so here's C.

00:15:32.810 --> 00:15:35.000
It branches off
here, bounces around.

00:15:35.000 --> 00:15:37.830
All that's C, and it's adjacent
to the blue thing we just did.

00:15:37.830 --> 00:15:42.540
The yellow and the pink-- that's
this yellow and this pink--

00:15:42.540 --> 00:15:45.530
connecting to D and G, and
so on through the thing.

00:15:45.530 --> 00:15:47.770
So it's actually really
easy to map from here

00:15:47.770 --> 00:15:51.010
to the tree, just every
corridor maps to an edge.

00:15:51.010 --> 00:15:53.900
Every connected component
of the perpendicular graph

00:15:53.900 --> 00:15:56.616
maps to a point.

00:15:56.616 --> 00:15:57.740
And this is the projection.

00:15:57.740 --> 00:15:59.900
It will always look
exactly like this.

00:15:59.900 --> 00:16:01.840
You'll be able to
independently manipulate

00:16:01.840 --> 00:16:04.580
each of these
corridors as a flap.

00:16:04.580 --> 00:16:08.150
And individually it's pretty
easy to fold each corridor.

00:16:08.150 --> 00:16:11.290
It just looks like
this accordion thing.

00:16:11.290 --> 00:16:17.450
So the faces will be stacked
linearly in order from

00:16:17.450 --> 00:16:21.490
back to front, and
be really clean.

00:16:21.490 --> 00:16:25.120
They'll all line up in
this nice vertical strip.

00:16:28.180 --> 00:16:30.095
So that's easy to
prove it exists

00:16:30.095 --> 00:16:32.320
from sketching the proof now.

00:16:32.320 --> 00:16:34.930
And then all you have to
do is attach them together.

00:16:34.930 --> 00:16:39.120
So basically first you take this
tree view, you fold it flat.

00:16:39.120 --> 00:16:42.200
Here, I can fold it flat just by
collapsing the top and bottom.

00:16:42.200 --> 00:16:43.750
Then I replace
each of these edges

00:16:43.750 --> 00:16:46.989
with one of these
vertical accordion strips.

00:16:46.989 --> 00:16:49.030
And then I just need to
check that at each vertex

00:16:49.030 --> 00:16:50.571
I can actually attach
everything that

00:16:50.571 --> 00:16:52.470
needs to attach without
getting crossings.

00:16:52.470 --> 00:16:53.520
So that's the one
part of the proof

00:16:53.520 --> 00:16:56.000
I'm not going to show you,
because it's kind of tedious.

00:16:56.000 --> 00:16:59.670
But basically, because
the structure was planar,

00:16:59.670 --> 00:17:01.820
because it came
from one sheet, you

00:17:01.820 --> 00:17:04.760
can show there's not going
to be any crossings there.

00:17:04.760 --> 00:17:07.069
All of these layers,
each of these edges

00:17:07.069 --> 00:17:08.960
expands to be many
layers, and the layers

00:17:08.960 --> 00:17:11.380
will nicely connect together.

00:17:11.380 --> 00:17:13.677
So that's the sketch
of that proof.

00:17:13.677 --> 00:17:14.260
Any questions?

00:17:14.260 --> 00:17:18.339
This is for just linear
corridors, not circular ones.

00:17:18.339 --> 00:17:20.980
OK.

00:17:20.980 --> 00:17:21.480
Cool.

00:17:26.680 --> 00:17:30.760
Next question is
about the bad example

00:17:30.760 --> 00:17:34.880
that makes a dense set of
creases that completely fills

00:17:34.880 --> 00:17:39.270
the plane, and therefore
is completely unfoldable.

00:17:39.270 --> 00:17:43.270
And the question was,
is it really unlikely

00:17:43.270 --> 00:17:46.084
or is actually very
likely that this happens?

00:17:46.084 --> 00:17:47.500
And there are two
things going on.

00:17:47.500 --> 00:17:51.280
Here's the example,
again, from the textbook.

00:17:51.280 --> 00:17:54.260
So it's got, the dark blue
is the desire cut graph,

00:17:54.260 --> 00:17:56.490
then the black lines are
the straight skeleton,

00:17:56.490 --> 00:17:59.250
and then the dash
lines are the beginning

00:17:59.250 --> 00:18:00.830
of the perpendiculars.

00:18:00.830 --> 00:18:06.050
And the point was to
make this corridor width

00:18:06.050 --> 00:18:09.330
verses this corridor
width verses this quarter

00:18:09.330 --> 00:18:10.830
width versus this
corner width, make

00:18:10.830 --> 00:18:13.230
those all irrational
multiples of each other.

00:18:13.230 --> 00:18:15.855
And then as this thing spirals
around, it never finishes.

00:18:15.855 --> 00:18:17.410
It never hits itself.

00:18:17.410 --> 00:18:18.610
And so it just keeps going.

00:18:18.610 --> 00:18:20.680
I think this is where this
one's currently going.

00:18:25.470 --> 00:18:29.590
And so the question is,
well, irrational multiples

00:18:29.590 --> 00:18:30.760
are actually very common.

00:18:30.760 --> 00:18:33.360
If you, for example, randomly
perturb all these vertices

00:18:33.360 --> 00:18:37.370
and you measure the
sizes of those corridors,

00:18:37.370 --> 00:18:39.934
with probability 1, they
will be irrational multiples

00:18:39.934 --> 00:18:41.350
of each other,
because irrationals

00:18:41.350 --> 00:18:44.390
are much more common
than rational numbers.

00:18:44.390 --> 00:18:45.880
And that's true.

00:18:45.880 --> 00:18:49.990
But the other thing that
this example requires

00:18:49.990 --> 00:18:52.030
is this outer boundary.

00:18:52.030 --> 00:18:53.870
We need that none of
these perpendiculars

00:18:53.870 --> 00:18:55.340
can escape out to infinity.

00:18:55.340 --> 00:18:57.590
If they do, they
won't stay in there.

00:18:57.590 --> 00:19:00.660
Eventually, if there's
a tiny, tiny gap here,

00:19:00.660 --> 00:19:03.400
if these guys didn't
quite match up, eventually

00:19:03.400 --> 00:19:05.959
because this thing is dense,
it will find that little gap

00:19:05.959 --> 00:19:07.250
because it has positive length.

00:19:07.250 --> 00:19:08.410
When it finds the
gap, it's going

00:19:08.410 --> 00:19:09.993
to spiral around and
around and around

00:19:09.993 --> 00:19:13.450
and go out to infinity instead
of being trapped inside.

00:19:13.450 --> 00:19:15.235
So the unlikely
thing in this example

00:19:15.235 --> 00:19:17.740
is actually this
outer pink polygon,

00:19:17.740 --> 00:19:21.190
that the perpendicular
coming out this way

00:19:21.190 --> 00:19:22.870
bounced around,
did lots of things,

00:19:22.870 --> 00:19:25.020
and eventually hit
the same vertex.

00:19:25.020 --> 00:19:27.360
That's actually unlikely.

00:19:27.360 --> 00:19:29.280
Definitely in this
example and in general

00:19:29.280 --> 00:19:33.470
we claim that we do not get
cycles of perpendiculars

00:19:33.470 --> 00:19:37.330
except in one kind
of scenario, which

00:19:37.330 --> 00:19:39.710
I guess I could draw
in the software.

00:19:39.710 --> 00:19:43.340
Let's try it.

00:19:43.340 --> 00:19:52.780
So whenever you have a vertex
of degree more than two,

00:19:52.780 --> 00:19:54.935
so let's do something like that.

00:19:58.720 --> 00:19:59.930
Little too far away.

00:19:59.930 --> 00:20:02.090
So let me just add a
little guy like this.

00:20:05.510 --> 00:20:08.355
And this a little closer.

00:20:17.360 --> 00:20:18.960
It's got a lot of spiraling.

00:20:18.960 --> 00:20:21.700
Let's make it a little
bit cleaner here.

00:20:21.700 --> 00:20:23.300
It's actually kind
of degenerate,

00:20:23.300 --> 00:20:29.030
but the point is, if-- here
I have three cut edges.

00:20:29.030 --> 00:20:32.510
I've kind of made them roughly
equal so this doesn't get huge,

00:20:32.510 --> 00:20:35.840
but in general, if you have
any straight skeleton vertex

00:20:35.840 --> 00:20:39.890
and you reflect it'
around these bisectors,

00:20:39.890 --> 00:20:43.600
you will always come back
to where you started.

00:20:43.600 --> 00:20:46.170
So this requires that
each of these angles

00:20:46.170 --> 00:20:49.450
is strictly convex, so this is
why you need at least three cut

00:20:49.450 --> 00:20:51.440
edges to come together here.

00:20:51.440 --> 00:20:54.470
But once you have
at least three,

00:20:54.470 --> 00:20:55.870
you'll always cycle around.

00:20:55.870 --> 00:20:57.180
You'll always come back
to where you started.

00:20:57.180 --> 00:20:58.471
It actually happens again here.

00:20:58.471 --> 00:21:02.595
This guy cycles
around and comes back.

00:21:02.595 --> 00:21:04.970
So that's-- well, sorry, that
one's actually a little bit

00:21:04.970 --> 00:21:09.810
special because of what
I did with the dragging.

00:21:09.810 --> 00:21:14.380
In general, it's going
to be more like this.

00:21:14.380 --> 00:21:16.610
It's a little hard to see.

00:21:16.610 --> 00:21:20.160
What's going on here is that
this innermost guy cycles

00:21:20.160 --> 00:21:22.430
around, indeed,
but everyone else

00:21:22.430 --> 00:21:25.729
spirals around and keeps going.

00:21:25.729 --> 00:21:27.270
So that's actually
the perpendicular.

00:21:27.270 --> 00:21:29.560
It comes from here
and goes that way,

00:21:29.560 --> 00:21:30.930
and then it spirals around.

00:21:30.930 --> 00:21:32.805
It hasn't finished yet,
but it would actually

00:21:32.805 --> 00:21:36.170
spiral all the way
out to infinity.

00:21:36.170 --> 00:21:44.865
So the claim is, in general,
the-- this is conjecture.

00:21:55.050 --> 00:21:58.220
With probability 1, if you
randomly perturb the vertices

00:21:58.220 --> 00:22:16.950
slightly, the only cycles of
perpendiculars that you get

00:22:16.950 --> 00:22:20.695
are around a single vertex.

00:22:25.550 --> 00:22:28.300
So something like
this example, which

00:22:28.300 --> 00:22:32.400
we saw where there is a straight
skeleton edge here, here,

00:22:32.400 --> 00:22:39.040
and then this guy-- I guess I
should draw the skeleton edges.

00:22:39.040 --> 00:22:41.120
It's a good test of
how accurate I drew it,

00:22:41.120 --> 00:22:43.290
because I know if
this is perpendicular,

00:22:43.290 --> 00:22:47.060
this is perpendicular,
and this is perpendicular,

00:22:47.060 --> 00:22:49.850
this will always come back
to its starting point.

00:22:49.850 --> 00:22:51.340
It's just property
of reflections.

00:22:51.340 --> 00:22:53.800
Basically, because we
satisfy Kawasaki here,

00:22:53.800 --> 00:22:59.690
this must be true because these
are bisectors of these guys.

00:22:59.690 --> 00:23:01.320
So this has to happen.

00:23:01.320 --> 00:23:04.370
The claim is, that's the
only situation it happens.

00:23:04.370 --> 00:23:05.870
And if this is all
that happens, you

00:23:05.870 --> 00:23:08.650
can prove there's no density,
and in fact, it folds flat.

00:23:08.650 --> 00:23:10.300
So this is the good case.

00:23:10.300 --> 00:23:12.050
Unfortunately, when
we make real examples,

00:23:12.050 --> 00:23:13.730
we like degeneracies
because they

00:23:13.730 --> 00:23:14.990
reduce the number of folds.

00:23:14.990 --> 00:23:18.360
So the theory says, avoid
degeneracies Let's perturb

00:23:18.360 --> 00:23:21.960
things slightly, then
it's guaranteed to fold.

00:23:21.960 --> 00:23:24.200
But in practice, you want
to add degeneracies, just

00:23:24.200 --> 00:23:27.150
carefully so that you
don't get dense behavior

00:23:27.150 --> 00:23:31.350
like the weird
example I showed you.

00:23:31.350 --> 00:23:40.080
So that's clarification why
we think this does not happen.

00:23:40.080 --> 00:23:43.510
Or, sorry, why we think with
probability 1 things are good.

00:23:43.510 --> 00:23:44.760
But sadly we can't prove this.

00:23:44.760 --> 00:23:46.340
Maybe we'll work on it in
the open problem session.

00:23:46.340 --> 00:23:48.736
I think it's tractable, I
just haven't worked on it

00:23:48.736 --> 00:23:49.360
in a long time.

00:23:51.846 --> 00:23:52.345
Questions?

00:23:55.970 --> 00:23:56.510
OK.

00:23:56.510 --> 00:23:57.900
So, right.

00:23:57.900 --> 00:24:01.780
The claim is if you
perturb this example,

00:24:01.780 --> 00:24:05.840
everybody will escape out to
infinity like in the spiral.

00:24:05.840 --> 00:24:06.340
OK.

00:24:06.340 --> 00:24:10.050
So I think this is the end
of the skeleton method,

00:24:10.050 --> 00:24:13.050
but before we go on, I
want to show some examples.

00:24:13.050 --> 00:24:18.540
So problem set-- we have up to
four [INAUDIBLE] later today.

00:24:18.540 --> 00:24:21.200
One of the questions is
design your own folding cut,

00:24:21.200 --> 00:24:23.060
and draw it.

00:24:23.060 --> 00:24:25.910
So you probably want to draw
it into a program like Inkscape

00:24:25.910 --> 00:24:27.630
or Adobe Illustrator.

00:24:27.630 --> 00:24:31.190
It has good snapping, so you can
find intersections and things

00:24:31.190 --> 00:24:33.430
like that, and compute
angular bisectors

00:24:33.430 --> 00:24:37.240
as in ruler and compass.

00:24:37.240 --> 00:24:40.890
And these are some examples
from 2010, same question.

00:24:40.890 --> 00:24:42.360
There are lots of
them, but I chose

00:24:42.360 --> 00:24:43.801
three that are
particularly cool.

00:24:43.801 --> 00:24:45.300
This one has a line
of symmetry, you

00:24:45.300 --> 00:24:49.490
get a fish bone
by [? Ji, ?] who's

00:24:49.490 --> 00:24:52.530
a Ph.D. student
in the media lab.

00:24:52.530 --> 00:24:55.150
This is by
[? Sarah Eisenstadt ?],

00:24:55.150 --> 00:24:59.750
who's a Ph.D. student in CSAIL
working on folding things.

00:24:59.750 --> 00:25:03.470
Witch's hat is pretty
cool, pretty fairly simple.

00:25:03.470 --> 00:25:04.930
You have to fold your examples.

00:25:04.930 --> 00:25:06.870
It can't be too complicated.

00:25:06.870 --> 00:25:10.260
And then Jason [? Ku ?], who
we saw the guest lecture by

00:25:10.260 --> 00:25:13.190
wasn't sufficiently impressed
by my jack o' lantern,

00:25:13.190 --> 00:25:17.360
so he made a really
complicated one and folded it.

00:25:17.360 --> 00:25:21.000
So those are some
inspiration points.

00:25:21.000 --> 00:25:24.560
And I thought I'd show
you a magic trick which

00:25:24.560 --> 00:25:27.530
is one of the sources
for inspiration

00:25:27.530 --> 00:25:29.010
for the fold and
one cut problem.

00:25:31.720 --> 00:25:34.600
So, a piece of paper.

00:25:34.600 --> 00:25:36.510
So this is a magic
trick of unknown origin.

00:25:36.510 --> 00:25:39.540
It was described
by Martin Gardner,

00:25:39.540 --> 00:25:42.830
I think, probably in
the '60s, and then

00:25:42.830 --> 00:25:44.540
the book appeared in the '90s.

00:25:44.540 --> 00:25:47.450
And it's a story
of two politicians,

00:25:47.450 --> 00:25:49.670
and let's just be generic.

00:25:49.670 --> 00:25:52.820
Let's say one politician was
very much liked by the people,

00:25:52.820 --> 00:25:55.520
and the other politician
was disliked by the people.

00:25:55.520 --> 00:25:59.470
Imagine a simple world
where it was so simple.

00:25:59.470 --> 00:26:02.530
And by a freak accident,
both politicians

00:26:02.530 --> 00:26:04.080
die at the same time.

00:26:04.080 --> 00:26:05.920
And they both happen
to be Christians,

00:26:05.920 --> 00:26:07.570
so they go to the
gates of Heaven.

00:26:07.570 --> 00:26:09.110
That's how the story goes.

00:26:09.110 --> 00:26:10.720
And arrive at the
gates of Heaven.

00:26:10.720 --> 00:26:12.750
I guess Saint Peter's
the keeper of the gates,

00:26:12.750 --> 00:26:14.770
and Saint Peter
says, well not just

00:26:14.770 --> 00:26:16.260
anyone can get into heaven.

00:26:16.260 --> 00:26:18.320
You have to have a ticket.

00:26:18.320 --> 00:26:20.470
And the good politician
being liked by the people

00:26:20.470 --> 00:26:22.250
has a ticket, which
he folds flat.

00:26:22.250 --> 00:26:24.683
And the bad politician
has no ticket.

00:26:24.683 --> 00:26:26.432
So the bad politician
says, well you know,

00:26:26.432 --> 00:26:28.310
we've had our
disagreements, but maybe you

00:26:28.310 --> 00:26:29.990
could put in a good
word to Saint Peter

00:26:29.990 --> 00:26:31.440
or do something to help me out.

00:26:31.440 --> 00:26:33.320
I hear Heaven's a nice place.

00:26:33.320 --> 00:26:35.320
Maybe we could go
there together,

00:26:35.320 --> 00:26:37.270
resolve our
differences, whatever.

00:26:37.270 --> 00:26:40.860
So the good politician, having
a ticket and a pair of scissors

00:26:40.860 --> 00:26:44.550
like any respecting
politician, takes his ticket

00:26:44.550 --> 00:26:46.790
and makes one
complete straight cut.

00:26:46.790 --> 00:26:48.440
And it's going to
get a lot of pieces,

00:26:48.440 --> 00:26:53.150
so I've got to be,
hold this carefully.

00:26:53.150 --> 00:26:55.230
So, put that down.

00:26:55.230 --> 00:27:00.010
And he hands all these
pieces to the bad politician,

00:27:00.010 --> 00:27:01.120
says there you go.

00:27:01.120 --> 00:27:03.257
The bad politician has
no idea what they're for,

00:27:03.257 --> 00:27:04.590
so he hands them to Saint Peter.

00:27:04.590 --> 00:27:09.240
Saint Peter starts
unfolding the pieces, says,

00:27:09.240 --> 00:27:10.380
I wonder what shapes I get.

00:27:10.380 --> 00:27:13.240
I hear there's a cool
problem about this.

00:27:13.240 --> 00:27:16.430
So it's a little hard
to do without a table.

00:27:16.430 --> 00:27:19.200
So I'm going to have
to use the board.

00:27:19.200 --> 00:27:36.670
First, we get the letter H. Then
we get-- put these down here.

00:27:36.670 --> 00:27:46.010
Then we get the letter E. OK?

00:27:46.010 --> 00:27:49.610
Then we get letter
L, and the letter L.

00:27:49.610 --> 00:27:51.460
And if it was on a
table, I'd arrange it,

00:27:51.460 --> 00:27:53.420
and clearly Saint
Peter's not happy,

00:27:53.420 --> 00:27:55.730
and the bad politician
gets sent straight to hell.

00:27:55.730 --> 00:27:59.190
The good politician hung
on to one piece cleverly,

00:27:59.190 --> 00:28:02.733
and his ticket is still
more or less intact,

00:28:02.733 --> 00:28:05.050
and he gets into heaven.

00:28:05.050 --> 00:28:07.590
That's the magic trick.

00:28:07.590 --> 00:28:10.520
It's very simple folding.

00:28:10.520 --> 00:28:13.990
I've known this, memorized
this even, for years.

00:28:13.990 --> 00:28:15.610
And you get exactly
those pieces.

00:28:15.610 --> 00:28:17.200
So pretty cool.

00:28:17.200 --> 00:28:20.245
Of course, from a
mathematical standpoint,

00:28:20.245 --> 00:28:21.370
it's a little unsatisfying.

00:28:21.370 --> 00:28:24.250
Because, come on, use
three pieces for the H,

00:28:24.250 --> 00:28:27.170
three pieces for the E.
Surely you could do better.

00:28:27.170 --> 00:28:30.510
And from a rectangle, you
can kind of do better.

00:28:30.510 --> 00:28:33.860
It's a little awkward
because the pieces

00:28:33.860 --> 00:28:36.720
are not all the same size,
but is one scissor cut

00:28:36.720 --> 00:28:38.620
because all the vertices
are even degree.

00:28:38.620 --> 00:28:43.850
You cut it, and you get
all these pieces, which

00:28:43.850 --> 00:28:46.310
if I were more
practiced at this,

00:28:46.310 --> 00:28:52.110
I could immediately pick
out which one's the H. OK,

00:28:52.110 --> 00:28:53.490
I'll just do them out of order.

00:28:53.490 --> 00:28:56.270
Here is the cross.

00:28:56.270 --> 00:28:57.340
Well, kind of a cross.

00:28:57.340 --> 00:28:59.330
Not quite perfect
proportions, but good enough.

00:29:01.797 --> 00:29:04.380
This is the letter E. This one's
actually more impressive when

00:29:04.380 --> 00:29:07.005
you don't have a table, because
you can't tell that they're all

00:29:07.005 --> 00:29:08.320
different sizes.

00:29:08.320 --> 00:29:14.944
The letter E. We've got the
letter-- these look like L's.

00:29:14.944 --> 00:29:16.610
And they're small
L's, but there you go.

00:29:16.610 --> 00:29:18.560
They're different orientations.

00:29:18.560 --> 00:29:23.801
And then I've got the
letter H. There you go.

00:29:23.801 --> 00:29:24.300
OK.

00:29:24.300 --> 00:29:27.810
So that's our new and improved
version using universality

00:29:27.810 --> 00:29:29.290
of folding cut.

00:29:29.290 --> 00:29:32.110
So it gives you some idea
of A, where folding cut

00:29:32.110 --> 00:29:35.452
came from in recent times,
is the magic community.

00:29:35.452 --> 00:29:37.660
I mentioned Harry Houdini
did some tricks, and Gerald

00:29:37.660 --> 00:29:40.470
[? Low ?], but there's a
bunch of these tricks around,

00:29:40.470 --> 00:29:41.760
and kind of cool.

00:29:41.760 --> 00:29:47.020
So the checkerboard trick
and the previous hell trick.

00:29:47.020 --> 00:29:48.570
So those are some examples.

00:29:48.570 --> 00:29:52.840
Now we move onto the
disk-packing method.

00:29:52.840 --> 00:29:55.370
So I have one
question about this,

00:29:55.370 --> 00:30:00.350
which is, how exactly do we
go from the disk-packing to--

00:30:00.350 --> 00:30:03.740
yeah, cool proof,
though, cool proof, bro.

00:30:03.740 --> 00:30:06.050
So how do we go from
the disk-packing

00:30:06.050 --> 00:30:09.450
to the decomposition into
triangles and quadrilaterals.

00:30:09.450 --> 00:30:12.040
So I thought I'd just
review this slide.

00:30:12.040 --> 00:30:13.620
We start with our graph.

00:30:13.620 --> 00:30:16.420
We offset it by
some tiny epsilon.

00:30:16.420 --> 00:30:19.620
That's to get things
off the line, basically.

00:30:19.620 --> 00:30:21.460
Then we do this disk-packing.

00:30:21.460 --> 00:30:23.780
And remember roughly how
the disk-packing works.

00:30:23.780 --> 00:30:26.997
We put some disks at
each of the centers.

00:30:26.997 --> 00:30:29.080
Here, it's a little awkward
because of the offset,

00:30:29.080 --> 00:30:31.316
but you put one at each
of these four corners.

00:30:31.316 --> 00:30:32.940
Also the corners of
the piece of paper.

00:30:32.940 --> 00:30:34.260
Why not?

00:30:34.260 --> 00:30:37.070
Then you also pack small
enough disks along the edge,

00:30:37.070 --> 00:30:40.760
so that you cover the edge
by diameters of the disks.

00:30:40.760 --> 00:30:42.676
I do that the same
on all the sides.

00:30:42.676 --> 00:30:44.300
Basically, you try
to put a big one in,

00:30:44.300 --> 00:30:48.020
but if that big one intersects,
you decompose it into half.

00:30:48.020 --> 00:30:50.819
That's how the algorithm works.

00:30:50.819 --> 00:30:52.860
So now you've covered the
vertices and the edges,

00:30:52.860 --> 00:30:56.150
but you may have
big gaps like this,

00:30:56.150 --> 00:30:58.700
too many sides on this gap.

00:30:58.700 --> 00:31:00.190
And so then you
just greedily put

00:31:00.190 --> 00:31:02.130
the largest disk you
can in those gaps

00:31:02.130 --> 00:31:04.640
until all you're left
with in these yellow gaps

00:31:04.640 --> 00:31:07.220
are triangles and
quadrilaterals,

00:31:07.220 --> 00:31:09.930
or three-sided gaps
and four-sided gaps.

00:31:09.930 --> 00:31:12.730
And then all we do is
draw this red graph

00:31:12.730 --> 00:31:15.892
by putting a vertex at
the center of each disk.

00:31:15.892 --> 00:31:17.350
That's what the
question was about.

00:31:17.350 --> 00:31:20.510
And then whenever
two disks touch,

00:31:20.510 --> 00:31:24.720
we call this kissing disks
for historic reasons,

00:31:24.720 --> 00:31:26.655
because they're just
barely touching I guess,

00:31:26.655 --> 00:31:28.220
at their lips.

00:31:28.220 --> 00:31:30.590
Got a lot of lips for disks.

00:31:30.590 --> 00:31:32.370
At least we're in flat land.

00:31:32.370 --> 00:31:34.740
So then whenever
they touch, we draw

00:31:34.740 --> 00:31:37.790
the edge between
the two centers.

00:31:37.790 --> 00:31:40.670
So that decomposes this
piece of paper into parts,

00:31:40.670 --> 00:31:42.370
and because the gaps
are three sides,

00:31:42.370 --> 00:31:45.060
those will correspond to
triangles, or four sides,

00:31:45.060 --> 00:31:47.530
those will correspond
to quadrilaterals.

00:31:47.530 --> 00:31:48.600
So that's all.

00:31:48.600 --> 00:31:50.310
And then we put
rabbit ears in here,

00:31:50.310 --> 00:31:53.970
and line universal quad
molecules in there,

00:31:53.970 --> 00:31:55.240
and it folds flat.

00:31:55.240 --> 00:31:56.970
It will align all
of the red edges

00:31:56.970 --> 00:31:59.490
plus these black
edges on the outside,

00:31:59.490 --> 00:32:02.212
and it will align all
these inner red edges

00:32:02.212 --> 00:32:03.670
with these black
edges, and then we

00:32:03.670 --> 00:32:05.820
do the sync folds
that we mentioned.

00:32:05.820 --> 00:32:08.600
And that will get one of these
out of the way of the other,

00:32:08.600 --> 00:32:11.680
and we'll end up aligning
just these cut edges.

00:32:14.560 --> 00:32:19.500
So that's a quick
review of that method.

00:32:19.500 --> 00:32:22.230
So one question is, how
do you allocate the disks.

00:32:22.230 --> 00:32:24.240
Is there sort of a best way?

00:32:24.240 --> 00:32:26.346
And I guess there could
be several measures.

00:32:26.346 --> 00:32:27.970
Maybe you don't want
really tiny disks,

00:32:27.970 --> 00:32:30.420
because that tends to
lead to very tiny folds.

00:32:30.420 --> 00:32:33.870
But the standard measure here
is how many disks do you need,

00:32:33.870 --> 00:32:36.520
because that will reduce
the number of folds.

00:32:36.520 --> 00:32:38.520
So can you minimize
the number of disks,

00:32:38.520 --> 00:32:41.070
and in general,
it's known roughly

00:32:41.070 --> 00:32:42.310
how many disks you need.

00:32:42.310 --> 00:32:44.420
And the algorithm
I just told you

00:32:44.420 --> 00:32:47.230
achieves that number of disks.

00:32:47.230 --> 00:32:52.000
So first I'll give
you the number.

00:32:52.000 --> 00:32:58.482
Number of disks is
proportional to the integral--

00:32:58.482 --> 00:32:59.940
I didn't say it
was the easy bound,

00:32:59.940 --> 00:33:01.840
but it is the right answer.

00:33:06.810 --> 00:33:08.620
OK, there's a lot
of notation in here,

00:33:08.620 --> 00:33:10.470
and this one you
should definitely not

00:33:10.470 --> 00:33:13.210
know unless you've taken a
computational geometry class.

00:33:13.210 --> 00:33:15.390
Even then, you probably
wouldn't know it.

00:33:15.390 --> 00:33:16.697
It's not that common.

00:33:16.697 --> 00:33:18.655
It mostly comes up in
meshing and disk-packing,

00:33:18.655 --> 00:33:20.150
so it's pretty specific.

00:33:20.150 --> 00:33:22.590
It's called local feature size.

00:33:25.390 --> 00:33:27.390
And this is if,
once I define it,

00:33:27.390 --> 00:33:30.940
it is actually fairly
intuitive, this bound.

00:33:30.940 --> 00:33:34.270
Local feature size
at X. So we're

00:33:34.270 --> 00:33:36.170
imagining some kind
of polygon here.

00:33:38.910 --> 00:33:41.140
And at every point
of the polygon--

00:33:41.140 --> 00:33:43.170
let's look at a
vertex here-- but it

00:33:43.170 --> 00:33:45.400
works for any point
along the boundary.

00:33:45.400 --> 00:33:47.820
Actually maybe not
even on the boundary,

00:33:47.820 --> 00:33:51.830
but we're interested
here-- this notation del p

00:33:51.830 --> 00:33:53.260
is the boundary of the polygon.

00:33:53.260 --> 00:33:55.770
So this is del p.

00:33:55.770 --> 00:34:00.310
That just means edges and
vertices, all of those points.

00:34:00.310 --> 00:34:02.460
So we take some point
X on the boundary,

00:34:02.460 --> 00:34:05.810
and we look at the
smallest disk centered

00:34:05.810 --> 00:34:10.730
at that point that
touches another feature.

00:34:10.730 --> 00:34:12.090
So that's the feature size.

00:34:12.090 --> 00:34:13.920
Features here are
edges of the polygon.

00:34:13.920 --> 00:34:15.719
That's all we have.

00:34:15.719 --> 00:34:18.570
Now of course, no matter what
size disk, you hit this feature

00:34:18.570 --> 00:34:20.528
and you hit this feature,
so those don't count.

00:34:20.528 --> 00:34:21.929
Those are incident features.

00:34:21.929 --> 00:34:32.510
So in general, it is
the smallest radius disk

00:34:32.510 --> 00:34:41.900
that hits a non incident feature
on incident feature, which

00:34:41.900 --> 00:34:44.500
is an edge.

00:34:44.500 --> 00:34:47.320
So here, as soon as
the disk gets this big,

00:34:47.320 --> 00:34:48.870
it hits this edge.

00:34:48.870 --> 00:34:54.880
And so the local feature
size is this radius.

00:34:54.880 --> 00:34:58.272
In general, for every point,
you can draw some size disk.

00:34:58.272 --> 00:35:00.985
So over here, it's going
to be a little bit bigger.

00:35:00.985 --> 00:35:03.210
You can maybe get up to here.

00:35:06.990 --> 00:35:09.920
Actually, I guess it
should be non-adjacent.

00:35:09.920 --> 00:35:12.500
That was going to be
a little bit awkward.

00:35:12.500 --> 00:35:14.300
I also don't want
to count this edge,

00:35:14.300 --> 00:35:17.090
because if I'm right here, the
feature size is super tiny,

00:35:17.090 --> 00:35:20.480
and I don't want
LFS ever to be 0.

00:35:20.480 --> 00:35:24.877
So you also have to skip
the adjacent edges, which

00:35:24.877 --> 00:35:26.460
means local feature
size of this point

00:35:26.460 --> 00:35:31.660
is going to be more like--
hard to draw circles--

00:35:31.660 --> 00:35:34.370
it's going to be more
like that distance.

00:35:34.370 --> 00:35:37.742
That's when you hit a
non-adjacent feature, sorry.

00:35:37.742 --> 00:35:39.700
So you have to exclude
this edge that you're on

00:35:39.700 --> 00:35:41.200
and the two adjacent
ones, otherwise

00:35:41.200 --> 00:35:44.100
this definition
doesn't quite work out.

00:35:44.100 --> 00:35:46.670
So then you measure
this for all points.

00:35:46.670 --> 00:35:48.450
There's infinitely
many, of course,

00:35:48.450 --> 00:35:50.360
continuum along the boundary.

00:35:50.360 --> 00:35:54.070
That's the integral over
X in the boundary of P.

00:35:54.070 --> 00:35:56.860
And you take 1 over the
local feature size of X,

00:35:56.860 --> 00:36:00.680
and you integrate that for
all X. It gives you a number,

00:36:00.680 --> 00:36:03.660
and it turns out, some
constant times that number

00:36:03.660 --> 00:36:04.890
is the right answer.

00:36:04.890 --> 00:36:06.959
The algorithm I achieve,
which I described,

00:36:06.959 --> 00:36:09.250
which is put the biggest disk
you can or divide in half

00:36:09.250 --> 00:36:12.240
if you can't will get within
a constant factor of the best

00:36:12.240 --> 00:36:15.480
possible bound of all
possible to disk-packings.

00:36:15.480 --> 00:36:17.720
So this is pretty much known.

00:36:17.720 --> 00:36:20.320
You get within a constant factor
of the optimal disk-packing

00:36:20.320 --> 00:36:23.059
if you're counting disks.

00:36:23.059 --> 00:36:23.850
Not a great number.

00:36:23.850 --> 00:36:26.490
I can't say they're N
disks or N squared disks,

00:36:26.490 --> 00:36:30.120
because you just can't do that.

00:36:30.120 --> 00:36:33.590
If you have a piece of
paper and some really long--

00:36:33.590 --> 00:36:35.020
here's your cut graph.

00:36:35.020 --> 00:36:37.790
Doesn't quite go to the
ends, though-- then you've

00:36:37.790 --> 00:36:39.660
got to have a tiny
disk here, and that's

00:36:39.660 --> 00:36:41.576
going to require you to
have a bunch of disks.

00:36:41.576 --> 00:36:44.660
Even though this has constant
size, you're going to need,

00:36:44.660 --> 00:36:46.762
I don't know how
many disks here.

00:36:46.762 --> 00:36:48.470
Especially if your
paper's really narrow,

00:36:48.470 --> 00:36:50.854
you're going to
need a lot of disks.

00:36:50.854 --> 00:36:52.770
That's the best you can
hope for disk-packing.

00:36:52.770 --> 00:36:55.370
I actually brought a
little example of something

00:36:55.370 --> 00:36:57.389
like that where
your goal is just

00:36:57.389 --> 00:36:59.680
to cut out a single segment
in the middle of the paper.

00:36:59.680 --> 00:37:02.019
This is to illustrate
odd degree vertices.

00:37:02.019 --> 00:37:04.060
These are degree 1 vertices,
and you might think,

00:37:04.060 --> 00:37:07.420
wow, it's impossible for me
to cut this thing without,

00:37:07.420 --> 00:37:09.310
I don't know, just cutting.

00:37:09.310 --> 00:37:12.210
I could cut with my X-ACTO
knife from here to here.

00:37:12.210 --> 00:37:14.640
If I want to make a
complete straight cut,

00:37:14.640 --> 00:37:17.320
you can fold it like this.

00:37:17.320 --> 00:37:20.610
This is what the skeleton
method would give you.

00:37:20.610 --> 00:37:22.840
Fold it like this, and
then you use your laser

00:37:22.840 --> 00:37:24.320
to cut right along the line.

00:37:24.320 --> 00:37:27.050
With scissor cuts,
it's not so bad, right?

00:37:27.050 --> 00:37:28.460
I cut slightly in.

00:37:31.260 --> 00:37:34.200
It's pretty much
cutting along the line.

00:37:34.200 --> 00:37:36.950
Just not quite.

00:37:36.950 --> 00:37:38.190
I made a tiny mistake.

00:37:38.190 --> 00:37:41.570
So I cut off a line,
slightly thicker line,

00:37:41.570 --> 00:37:43.220
and I get my slit in the paper.

00:37:43.220 --> 00:37:47.280
So mathematical cuts
are not really that bad.

00:37:47.280 --> 00:37:50.460
You just are cutting a
slightly larger version

00:37:50.460 --> 00:37:52.730
than the single slit
that you wanted to make.

00:37:52.730 --> 00:37:56.160
You just have to
cut very carefully.

00:37:56.160 --> 00:37:57.200
OK.

00:37:57.200 --> 00:37:59.590
That was number of disks.

00:37:59.590 --> 00:38:03.217
Next question is, how does all
this relate to the tree method?

00:38:03.217 --> 00:38:04.550
This is kind of a neat question.

00:38:04.550 --> 00:38:07.780
Both methods, skeleton method
and the disk-packing method

00:38:07.780 --> 00:38:11.140
relate to the tree
method in different ways.

00:38:11.140 --> 00:38:12.620
I thought I would
talk about that.

00:38:12.620 --> 00:38:14.580
So first, let's compare
the disk-packing method

00:38:14.580 --> 00:38:17.610
which we just talked
about to the tree method.

00:38:17.610 --> 00:38:19.850
Both of them use
universal molecules.

00:38:19.850 --> 00:38:21.760
This one only uses
universal molecules

00:38:21.760 --> 00:38:23.890
for triangles and quads.

00:38:23.890 --> 00:38:25.640
We know in general,
the universal molecule

00:38:25.640 --> 00:38:27.050
works for any convex polygon.

00:38:27.050 --> 00:38:29.720
This is an example
of a pentagon.

00:38:29.720 --> 00:38:30.690
And it works.

00:38:30.690 --> 00:38:33.510
It has a gusset to get
the tree lengths right.

00:38:33.510 --> 00:38:36.296
Here we use gussets to kind
of get the tree lengths right.

00:38:36.296 --> 00:38:38.170
As you may recall, we
want the perpendiculars

00:38:38.170 --> 00:38:43.010
to go to the disk kissing
points, those tangencies.

00:38:43.010 --> 00:38:44.690
Because then they
align with the others,

00:38:44.690 --> 00:38:46.950
and then we never
get the perpendicular

00:38:46.950 --> 00:38:48.552
spiraling or doing
other bad things.

00:38:48.552 --> 00:38:51.010
So the number of creases becomes
proportional to the number

00:38:51.010 --> 00:38:51.509
of disks.

00:38:51.509 --> 00:38:55.190
The number of disks
is this messy thing.

00:38:55.190 --> 00:38:57.840
So that's that.

00:38:57.840 --> 00:38:59.700
Let's see, what else?

00:38:59.700 --> 00:39:01.320
Here, we only use disks.

00:39:01.320 --> 00:39:03.070
Over here, we could
just use disks,

00:39:03.070 --> 00:39:05.040
but there's also the
ability to use rivers,

00:39:05.040 --> 00:39:09.630
so this is more general in
that we can do bigger polygons

00:39:09.630 --> 00:39:14.620
than' just quads, and we can
do rivers, not just circles.

00:39:14.620 --> 00:39:18.310
Here, the input, though, is a
tree with specified lengths,

00:39:18.310 --> 00:39:23.780
and it's actually NP-hard to
place the disks correctly.

00:39:23.780 --> 00:39:26.190
We proved that last time.

00:39:26.190 --> 00:39:29.209
Over here, the
input is a polygon.

00:39:29.209 --> 00:39:31.250
It's already been embedded
on the sheet of paper.

00:39:31.250 --> 00:39:33.830
There's no really hard
decisions here except you

00:39:33.830 --> 00:39:36.810
have to fill the
paper with disks.

00:39:36.810 --> 00:39:39.050
But that's not so hard.

00:39:39.050 --> 00:39:40.880
So you can do this
in polynomial time.

00:39:40.880 --> 00:39:45.740
Polynomial and even,
almost, roughly this time.

00:39:45.740 --> 00:39:48.220
Times a log factor.

00:39:48.220 --> 00:39:50.662
You can find
displacement of disks.

00:39:50.662 --> 00:39:52.620
So that's not too hard,
whereas over here, it's

00:39:52.620 --> 00:39:55.810
NP-hard to place a disk,
optimally at least.

00:39:55.810 --> 00:39:58.250
Find a displacement
you could do.

00:39:58.250 --> 00:40:00.220
So basically the
inputs differ, and it's

00:40:00.220 --> 00:40:06.020
using the same
backbone or the same,

00:40:06.020 --> 00:40:08.310
what do you call it, front end.

00:40:08.310 --> 00:40:11.780
The same back end, I
suppose, after we've

00:40:11.780 --> 00:40:13.370
decomposed into a
bunch of molecules,

00:40:13.370 --> 00:40:15.280
you just fold the molecules
and you're basically done.

00:40:15.280 --> 00:40:17.240
Here we have to do
some syncs at the end,

00:40:17.240 --> 00:40:19.160
but it's using it for
different purposes.

00:40:19.160 --> 00:40:20.750
Otherwise they're very similar.

00:40:20.750 --> 00:40:25.130
And indeed, this is
inspired by that.

00:40:25.130 --> 00:40:27.191
OK, so that was the
disk-packing method.

00:40:27.191 --> 00:40:28.940
Then there's the
straight skeleton method.

00:40:28.940 --> 00:40:31.660
These look much more
different, but in fact, they

00:40:31.660 --> 00:40:33.050
are quite related.

00:40:33.050 --> 00:40:37.090
If you do fold-and-cut
on a convex polygon,

00:40:37.090 --> 00:40:39.150
it gives you roughly
the universal molecule,

00:40:39.150 --> 00:40:41.270
just with no gussets.

00:40:41.270 --> 00:40:44.170
So here, neither one is
more general than the other.

00:40:44.170 --> 00:40:45.834
The universal molecule
is more general

00:40:45.834 --> 00:40:47.250
in that it has
gussets, which lets

00:40:47.250 --> 00:40:49.790
it control the tree
topology you get and control

00:40:49.790 --> 00:40:51.710
the lengths you get in the tree.

00:40:51.710 --> 00:40:54.540
Over here, we saw the
tree just happens.

00:40:54.540 --> 00:40:57.980
You can't control the tree.

00:40:57.980 --> 00:41:00.860
The shadow tree is just a tool
to prove that it falls flat,

00:41:00.860 --> 00:41:02.780
but you can do non
convex polygons, which

00:41:02.780 --> 00:41:05.400
is much more general
than convex polygons.

00:41:05.400 --> 00:41:09.630
So they each have their
own unique claims to fame.

00:41:09.630 --> 00:41:12.010
A natural question is,
can you combine them.

00:41:12.010 --> 00:41:13.580
And in fact, you can.

00:41:13.580 --> 00:41:17.500
And this was, you may remember
a bunch of lectures ago--

00:41:17.500 --> 00:41:20.320
I think class four
or so-- I showed

00:41:20.320 --> 00:41:23.860
this slide of the meat
of origami design secrets

00:41:23.860 --> 00:41:26.950
volume two, or the
second edition, rather.

00:41:26.950 --> 00:41:29.000
There's tree theory,
which we talked about.

00:41:29.000 --> 00:41:31.860
There was a box pleating tree
theory which we briefly showed.

00:41:31.860 --> 00:41:34.318
And there's this more general
thing called polygon packing,

00:41:34.318 --> 00:41:35.900
and this is in some
sense the fusion

00:41:35.900 --> 00:41:39.180
of straight skeleton
method of fold-and-cut,

00:41:39.180 --> 00:41:43.840
basically the straight
skeleton, plus tree theory.

00:41:43.840 --> 00:41:48.170
And this is done jointly between
Robert Lang and the domains.

00:41:48.170 --> 00:41:50.640
And here's an example
of what it looks like.

00:41:50.640 --> 00:41:53.550
It's a little hard to see
here, but I will point out

00:41:53.550 --> 00:41:57.830
if you look at the blue lines,
which are the cut lines-- here,

00:41:57.830 --> 00:42:00.570
of course, they're
the active paths.

00:42:00.570 --> 00:42:05.480
This guy is non convex.

00:42:05.480 --> 00:42:07.680
And if you look at the
red stuff in there,

00:42:07.680 --> 00:42:12.590
it is exactly the straight
skeleton of that polygon.

00:42:12.590 --> 00:42:14.460
So those red lines are
the straight skeleton

00:42:14.460 --> 00:42:15.860
of this blue thing.

00:42:15.860 --> 00:42:16.710
So there you go.

00:42:16.710 --> 00:42:19.290
I've got the fold-and-cut
straight skeleton

00:42:19.290 --> 00:42:21.550
being used in that setting.

00:42:21.550 --> 00:42:23.860
You've got perpendiculars
all over the place, which

00:42:23.860 --> 00:42:26.090
is an annoying feature
of the skeleton method.

00:42:26.090 --> 00:42:27.940
It is inherited by this method.

00:42:27.940 --> 00:42:33.110
And if you look at something
like this rectangle.

00:42:33.110 --> 00:42:35.920
It's convex, but
you have gussets.

00:42:35.920 --> 00:42:38.490
This is a gusset, this is
a gusset, gusset, gusset.

00:42:38.490 --> 00:42:40.940
It's a little hard to
see, but we basically

00:42:40.940 --> 00:42:43.870
split the rectangle into
this rectangle, this square,

00:42:43.870 --> 00:42:48.510
this rectangle, this
square, this rectangle.

00:42:48.510 --> 00:42:50.980
So this is really the
fusion of the two.

00:42:50.980 --> 00:42:53.100
It's not yet been
mathematically formalized,

00:42:53.100 --> 00:42:55.391
because we're first proving
that the tree method works.

00:42:55.391 --> 00:42:56.870
Then we will
finally get to this.

00:42:56.870 --> 00:43:00.160
But if you want these slightly
more informal but practical

00:43:00.160 --> 00:43:04.042
version, read Oragami Design
Secrets and it will explain

00:43:04.042 --> 00:43:05.500
all the different
cases and what we

00:43:05.500 --> 00:43:06.791
believe is a correct algorithm.

00:43:06.791 --> 00:43:09.880
We just haven't proved
all the cases yet.

00:43:09.880 --> 00:43:13.200
And you can use it to design
cool things in the box pleating

00:43:13.200 --> 00:43:16.160
setting and get more efficient
than if you required rectangles

00:43:16.160 --> 00:43:19.660
or some convex shape.

00:43:19.660 --> 00:43:20.230
Cool.

00:43:20.230 --> 00:43:23.616
So that's that.

00:43:23.616 --> 00:43:24.490
What else do we have?

00:43:30.490 --> 00:43:35.290
I have one-- almost done-- one
cool open question posed by you

00:43:35.290 --> 00:43:38.870
is, what if instead of
cutting with a straight line,

00:43:38.870 --> 00:43:41.400
I cut with a constant
curvature line?

00:43:41.400 --> 00:43:43.886
So a piece of a circular arc.

00:43:43.886 --> 00:43:45.260
Then, of course,
the things I get

00:43:45.260 --> 00:43:46.676
will have circular
arc boundaries,

00:43:46.676 --> 00:43:48.940
but can I get any
circular arc boundary

00:43:48.940 --> 00:43:51.190
with that fixed curvature?

00:43:51.190 --> 00:43:53.680
Or are there limitations?

00:43:53.680 --> 00:43:55.850
And at first I thought
the answer is clearly yes,

00:43:55.850 --> 00:44:04.870
but I do wonder about
situations like this.

00:44:04.870 --> 00:44:07.965
Can you align these
two by folding?

00:44:07.965 --> 00:44:09.340
I haven't thought
about it enough

00:44:09.340 --> 00:44:11.950
to be sure, but
not totally sure.

00:44:11.950 --> 00:44:18.617
Whereas if I have things like
this, I think this is good.

00:44:18.617 --> 00:44:20.450
I mean, I could fold
here, and in general, I

00:44:20.450 --> 00:44:22.806
could just kind of
pretend there's a segment.

00:44:22.806 --> 00:44:24.930
And the segment I saw fold
and cut on the segments,

00:44:24.930 --> 00:44:26.680
and that will also
align the circular arc.

00:44:26.680 --> 00:44:28.210
That won't work
in general, but I

00:44:28.210 --> 00:44:29.970
feel comfortable if they
have the same orientation,

00:44:29.970 --> 00:44:30.580
it looks good.

00:44:30.580 --> 00:44:32.940
When they flip
orientations, I'm not sure.

00:44:32.940 --> 00:44:35.820
So a neat problem
to think about.

00:44:35.820 --> 00:44:41.300
And one final thing
is about flattening.

00:44:41.300 --> 00:44:44.240
This is about this
question, this picture.

00:44:44.240 --> 00:44:46.890
So we said, oh great, because
we can solve fold-and-cut,

00:44:46.890 --> 00:44:48.870
we can also take the
boundary of that polygon

00:44:48.870 --> 00:44:52.180
and flatten it like this.

00:44:52.180 --> 00:44:54.370
Of course, the folding
of the interior here

00:44:54.370 --> 00:44:56.080
which we're
ignoring-- in general,

00:44:56.080 --> 00:44:58.610
this whole thing goes
through three dimensions

00:44:58.610 --> 00:45:00.110
until we end up here.

00:45:00.110 --> 00:45:02.800
One dimension up, if we solve
the 3D fold-and-cut problem

00:45:02.800 --> 00:45:05.800
where you have a polyhedron,
you fold it through 4D

00:45:05.800 --> 00:45:08.470
back into 3D which is
flat so that you align

00:45:08.470 --> 00:45:14.082
all the boundaries of the
faces of that polyhedron.

00:45:14.082 --> 00:45:16.040
And then just take the
boundary of that motion.

00:45:16.040 --> 00:45:17.790
It's like flattening
a polyhedron

00:45:17.790 --> 00:45:19.960
like cereal box or whatever.

00:45:19.960 --> 00:45:23.510
And indeed, that will
find a folded state

00:45:23.510 --> 00:45:27.630
of a polyhedron that is flat.

00:45:27.630 --> 00:45:30.480
But of course, you can't
really use that motion,

00:45:30.480 --> 00:45:31.910
because it goes through 4D.

00:45:31.910 --> 00:45:34.020
This one will go
through 3D, so if you

00:45:34.020 --> 00:45:37.734
want it to flatten this
linkage, that's also not valid.

00:45:37.734 --> 00:45:39.150
So you get a folded
state, but you

00:45:39.150 --> 00:45:41.000
don't get the
folding motion if you

00:45:41.000 --> 00:45:42.842
could solve 3D fold-and-cut.

00:45:42.842 --> 00:45:44.300
Our current state
is, we don't know

00:45:44.300 --> 00:45:45.920
how to solve 3D fold-and-cut.

00:45:45.920 --> 00:45:48.230
We do know how to solve
polyhedron flattening.

00:45:48.230 --> 00:45:51.495
So this relation is
just kind of interest,

00:45:51.495 --> 00:45:55.200
it doesn't imply
anything super useful.

00:45:55.200 --> 00:45:57.220
An open problem
is, so we know how

00:45:57.220 --> 00:45:59.930
to solve polyhedron
flattening as a folded state.

00:45:59.930 --> 00:46:02.180
What we don't know so much
about is folding motions.

00:46:02.180 --> 00:46:07.680
There is a recent paper
from just last year which

00:46:07.680 --> 00:46:11.010
will continuously flatten
by continuous motion

00:46:11.010 --> 00:46:12.640
any convex polyhedron.

00:46:12.640 --> 00:46:14.890
But non convex polyhedron
we still don't know.

00:46:14.890 --> 00:46:17.615
These are roughly
hand drawn figures.

00:46:17.615 --> 00:46:19.740
An interesting project
would be to actually animate

00:46:19.740 --> 00:46:20.650
their motion.

00:46:20.650 --> 00:46:22.025
I think it would
look pretty cool

00:46:22.025 --> 00:46:24.390
and be much more
convincing that it works.

00:46:24.390 --> 00:46:25.890
I mean, I'm convinced
that it works,

00:46:25.890 --> 00:46:28.306
but it's a lot harder to see
visually from these pictures.

00:46:28.306 --> 00:46:32.160
It'd be really cool to see the
motions, the actual continuous

00:46:32.160 --> 00:46:33.940
animation.

00:46:33.940 --> 00:46:37.910
And a couple last project ideas.

00:46:37.910 --> 00:46:40.210
One would be to make a
fold-and-cut alphabet,

00:46:40.210 --> 00:46:42.040
like the maze software
that you just used.

00:46:42.040 --> 00:46:43.956
It would be fun if you
just type in a message,

00:46:43.956 --> 00:46:45.480
and out comes the
crease patterns.

00:46:45.480 --> 00:46:47.979
This is sort of like a special
case of a fold-and-cut design

00:46:47.979 --> 00:46:51.330
tool, but in letters
it's a little bit easier.

00:46:51.330 --> 00:46:54.020
And a different challenge
would be if I just

00:46:54.020 --> 00:46:56.600
want to be able to fold a
single letter at a time,

00:46:56.600 --> 00:46:58.464
can you always do it
with simple folds?

00:46:58.464 --> 00:46:59.880
So can you design
an alphabet that

00:46:59.880 --> 00:47:01.660
is simply fold-and-cuttable.

00:47:01.660 --> 00:47:02.714
That would be even nicer.

00:47:02.714 --> 00:47:04.630
And there's some magicians
who worked on that,

00:47:04.630 --> 00:47:06.213
but they couldn't
get all the letters,

00:47:06.213 --> 00:47:08.740
so it would be nice to do with
just a few folds, any letter

00:47:08.740 --> 00:47:10.289
of the alphabet, any digit.

00:47:10.289 --> 00:47:11.830
This is one we did
for our conference

00:47:11.830 --> 00:47:14.450
in honor of Martin Gardner,
gathering for Gardner five,

00:47:14.450 --> 00:47:17.140
back in 2002.

00:47:17.140 --> 00:47:20.010
And here's another possible
idea for a project,

00:47:20.010 --> 00:47:21.760
although mostly it's
an excuse to show you

00:47:21.760 --> 00:47:23.040
really cool pictures.

00:47:23.040 --> 00:47:25.900
This is Peter Callesen,
and he takes usually

00:47:25.900 --> 00:47:30.220
four sheets of paper, cuts
them probably an X-ACTO knife

00:47:30.220 --> 00:47:35.760
or something, and then from
that material that he acquires,

00:47:35.760 --> 00:47:37.600
builds a 3D structure
on that sheet.

00:47:37.600 --> 00:47:39.620
So you see all the
material that was used,

00:47:39.620 --> 00:47:42.230
and these are just amazing.

00:47:42.230 --> 00:47:45.230
And I don't think you could
necessarily do this level

00:47:45.230 --> 00:47:46.910
of fidelity from
a fold-and-cut ,

00:47:46.910 --> 00:47:49.310
but it would be cool to do a
fold-and-cut and then build

00:47:49.310 --> 00:47:54.245
a sculpture out of the
slits that you made.

00:47:54.245 --> 00:47:55.620
And I mean, it's
really cool when

00:47:55.620 --> 00:47:58.570
he can use the cutout parts
to be shadows of the things

00:47:58.570 --> 00:48:01.580
that he builds, especially
when those shadows

00:48:01.580 --> 00:48:04.410
are more complicated than the
sheet he actually assembles.

00:48:04.410 --> 00:48:09.190
That's a fairly cool effect
of the monsters in the closet.

00:48:09.190 --> 00:48:12.660
Pandora's box, or box
in a box in a box.

00:48:12.660 --> 00:48:16.290
You can't see that here,
but you see it unfolding.

00:48:16.290 --> 00:48:22.275
The bones inside the hand,
the old versus new cities.

00:48:25.830 --> 00:48:27.330
Using the positive
and the negative.

00:48:27.330 --> 00:48:32.360
There's actually a little boat
up there, which you can see.

00:48:32.360 --> 00:48:34.650
So pretty amazing stuff.

00:48:34.650 --> 00:48:39.616
And for free versus
caged, and so on.

00:48:39.616 --> 00:48:41.740
Interesting project would
be to try to make art out

00:48:41.740 --> 00:48:46.560
of fold-and-cut, just doing one
cut instead of a zillion cuts.

00:48:46.560 --> 00:48:47.060
That's it.

00:48:47.060 --> 00:48:50.185
Any more questions?

00:48:50.185 --> 00:48:50.685
Yeah.

00:48:50.685 --> 00:48:54.066
AUDIENCE: In the
circle-packing method,

00:48:54.066 --> 00:48:57.275
how do you assign the
mountain-valley [INAUDIBLE]?

00:48:57.275 --> 00:48:59.650
PROFESSOR ERIK DEMAINE: OK,
in the circle-packing method,

00:48:59.650 --> 00:49:01.316
how do you assign
mountains and valleys?

00:49:01.316 --> 00:49:03.530
That was briefly
covered in lecture.

00:49:03.530 --> 00:49:06.880
First you take a spanning
tree of all of the molecules,

00:49:06.880 --> 00:49:08.480
and you basically
fold each molecule

00:49:08.480 --> 00:49:11.200
into your parent in the tree.

00:49:11.200 --> 00:49:14.250
So each one has a
direction, and from that

00:49:14.250 --> 00:49:16.362
you can extract the
mountain-valley assignment.

00:49:16.362 --> 00:49:17.320
You go into the parent.

00:49:17.320 --> 00:49:19.210
It's a mountain there,
everyone else's valley.

00:49:19.210 --> 00:49:21.251
Basically you're reversing
one perpendicular fold

00:49:21.251 --> 00:49:23.190
per molecule.

00:49:23.190 --> 00:49:24.160
I think.

00:49:24.160 --> 00:49:25.045
Maybe two.

00:49:25.045 --> 00:49:26.580
With triangles, it's just one.

00:49:26.580 --> 00:49:29.130
For quads you might
be reversing two.

00:49:29.130 --> 00:49:31.570
So you start with all
of the straight skeleton

00:49:31.570 --> 00:49:33.820
being mountains, all the
perpendiculars being valleys,

00:49:33.820 --> 00:49:37.642
and you have to flip a few to
just get them to fit together.

00:49:37.642 --> 00:49:39.350
Little more complicated
than what I said,

00:49:39.350 --> 00:49:42.560
but I would need a slide
to show you the details.

00:49:42.560 --> 00:49:45.490
It's in the textbook.

00:49:45.490 --> 00:49:47.600
Anything else?

00:49:47.600 --> 00:49:49.470
All right, that's fold-and-cut.

