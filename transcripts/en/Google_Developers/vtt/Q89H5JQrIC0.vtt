WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:22.279
&gt;&gt; RAMSDALE: So to keep things on track here,
we'll go ahead and get started. My name is

00:00:22.279 --> 00:00:39.789
Chris Ramsdale. Thanks for coming out today.
It's packed house this is fantastic. So I'm

00:00:39.789 --> 00:01:04.530
going to give two sessions for today that
are on our Google Web Toolkit. The first one's

00:01:04.530 --> 00:01:26.240
is going to be more of a 101 session to get
everybody on the same page about what you

00:01:26.240 --> 00:01:53.439
can do with Google Web Toolkit, how you can
build rich Web apps. So from a show of hands,

00:01:53.439 --> 00:02:08.360
how many people have actually used Google
Web Toolkit to build an application for you?

00:02:08.360 --> 00:02:19.700
Great, I think there's a lot. But there's
blinding lights in front of you so I'll assume

00:02:19.700 --> 00:02:28.610
that it's half the crowd. Today, we're going
to go through what Google Web Toolkit is.

00:02:28.610 --> 00:02:39.060
I'll give you an overview of that. We're going
to talk about tools for developers and then

00:02:39.060 --> 00:02:48.720
optimization for users. And then we'll give
you an intro to GWT best practices in GWT

00:02:48.720 --> 00:02:57.920
2.1. So from a 25,000-foot view, what is Google
Web Toolkit? Well, it's a development toolkit,

00:02:57.920 --> 00:03:06.519
it's not a framework. I have nothing against
frameworks but the notion is that we are a

00:03:06.519 --> 00:03:20.709
set of tools that you can pick and choose
to make web applications. We have a compiler.

00:03:20.709 --> 00:03:34.209
We have code generators. We have Eclipse support.
We have plugins for IDEs. You can pick and

00:03:34.209 --> 00:03:45.000
choose either one and you don't have to--you
don't have to buy into all of them. Unlike

00:03:45.000 --> 00:03:54.049
frameworks like Spring or other ones that
are supposedly favored by JBoss. So the one

00:03:54.049 --> 00:04:06.870
thing you code and buy to is that you're coding
in Java. You're writing a front-end code.

00:04:06.870 --> 00:04:26.390
And what I mean is--when I say front-end throughout
this presentation I'm talking about code that

00:04:26.390 --> 00:04:40.270
runs in a browser. So, if you write front-end
code in Java then it runs in JavaScript. We

00:04:40.270 --> 00:04:53.180
have again, a compiler, a set of code generators
that take that, cut that Java code and turn

00:04:53.180 --> 00:05:10.930
it into HTML5 and to CSS and JavaScript. The
other thing is use one code base in a browser.

00:05:10.930 --> 00:05:27.280
So if you're running a consumer-based application,
you typically have users that are using both

00:05:27.280 --> 00:05:39.630
IE, Firefox, Safari, Chrome, some Opera users,
depending on where you're at. What we tried

00:05:39.630 --> 00:05:52.630
to do is give you the ability to write one
single application with no tweaks in or right

00:05:52.630 --> 00:06:07.050
in any browser. Fourth, we make AJAX a piece
of cake. Not that it's rocket science to begin

00:06:07.050 --> 00:06:17.590
with, but there's lot of boilerplate code
that goes into doing AJAX. There's a lot of

00:06:17.590 --> 00:06:28.250
serialization, deserialization codes, some
stuff that I talked about in the keynote today.

00:06:28.250 --> 00:06:49.660
And with GWT, we tried to make that a piece
of cake. We tried to make it faster because

00:06:49.660 --> 00:07:09.800
we have a holistic view of your application.
That means we know what types you're sending

00:07:09.800 --> 00:07:18.460
over the wire. We know what types you're expecting
to get back. We know how to serialize them

00:07:18.460 --> 00:07:29.260
off the wires. We can reduce payload and ultimately
make your application even faster. And then

00:07:29.260 --> 00:07:46.920
it's funny, GWT is using the main products,
AdWords, or kit, which is open to you guys,

00:07:46.920 --> 00:08:11.220
and hundreds of internal applications as well.
So as you can see, Google Web Toolkit started

00:08:11.220 --> 00:08:47.810
out as just an SDK. But it's grown over the
years. Now, we have a GWT family, as we like

00:08:47.810 --> 00:09:00.420
to call it. There's the GWT SDK. There's the
Google Plugin For Eclipse. There's Speed Tracer.

00:09:00.420 --> 00:09:15.190
And now, this recent addition to the family,
which is the Google Web Toolkit Designer.

00:09:15.190 --> 00:09:40.540
It was part of a company called Instantiations
that we acquired about several months ago.

00:09:40.540 --> 00:11:30.220
We are now in the process of bringing their
products into the IDE as well, making more

00:11:30.220 --> 00:12:51.491
unified Google Plugin for Eclipse. Now, when
you do these tools working together is that

00:12:51.491 --> 00:13:10.780
you design and develop using the Google Web
Toolkit SDK and the Google Web Toolkit Designer.

00:13:10.780 --> 00:13:29.630
You're going to debug using our Google Plugin
for Eclipse, right, within the IDE. And then,

00:13:29.630 --> 00:13:54.090
you're going to optimize with Speed Tracer.
Now, for some of the users who are not familiar

00:13:54.090 --> 00:14:06.360
with Speed Tracer, if you ever used Firefox,
use Firebug instead of--outside of Firefox,

00:14:06.360 --> 00:14:18.280
it gives you an idea of like, how your JavaScript's
operating. You could do some debugging. You

00:14:18.280 --> 00:14:26.371
could do some introspective look into your
application. Well, Speed Tracer takes that

00:14:26.371 --> 00:14:36.460
one step further. And it actually has hooks
inside of Webkit so that it can see when you're

00:14:36.460 --> 00:14:43.020
doing things like painting, layouts, garbage
collection, things like that, to identify

00:14:43.020 --> 00:14:57.730
where your app might be sluggish in the browser.
So, when we typically think about who our

00:14:57.730 --> 00:15:11.510
target is, right, we have two focuses. We
have to focus on the user. We focused on our

00:15:11.510 --> 00:15:21.400
users. So that's the developers, everybody
in this room. And for those developing for

00:15:21.400 --> 00:15:30.450
those users, we look to leverage existing
IDEs and tools, right? Again, everything is

00:15:30.450 --> 00:15:38.720
available in Eclipse that was normally available
to service side programmers or mobile programmers.

00:15:38.720 --> 00:15:46.350
We should make that available to web app programmers
as well. We want to minimize the refresh time

00:15:46.350 --> 00:15:57.520
between coaching. And so you're not actually
going and making a change, having to recompile,

00:15:57.520 --> 00:16:04.700
to redeploy, it'll take some [INDISTINCT]
to do that which means [INDISTINCT]. And then

00:16:04.700 --> 00:16:14.170
the work, when we can, we would animate as
possible. Again, we have tools that are operating

00:16:14.170 --> 00:16:23.040
on you're Java code. We know things. We can
do things based on that that minimizes the

00:16:23.040 --> 00:16:37.750
amount of code that you'd have to write. Let's
you focus on the next killer feature. But

00:16:37.750 --> 00:16:48.430
then we focus on your users which are the
end users, your customers. And then, we would

00:16:48.430 --> 00:16:57.250
have minimized our time when we're making
a comfortable experience, right? We want to

00:16:57.250 --> 00:17:08.569
get them off the desktop applications and
get them into the web, into the browser. That's

00:17:08.569 --> 00:17:18.130
why we have to make it as fast as possible.
It needs to feel like a desktop application.

00:17:18.130 --> 00:17:24.100
And then finally, when have made a comfortable
experience, being in that we will let them

00:17:24.100 --> 00:17:31.040
use whatever browsers they're comfortable
with, right, whether it's Safari, in Firefox,

00:17:31.040 --> 00:17:41.100
IE, or Chrome. So, we have different goals
when we look to different users. You as developers

00:17:41.100 --> 00:17:53.940
focus on writing the next killer feature,
making it look good, and doing some code refactoring.

00:17:53.940 --> 00:18:05.531
Say, you've picked up a piece of code from
your colleague who's left the company. You

00:18:05.531 --> 00:18:20.390
think it's terrible. You want to go refractor
and make it better. So that's what your goals

00:18:20.390 --> 00:18:30.490
are right there. Goals for your customers
are a little different. They just want to

00:18:30.490 --> 00:18:40.210
make it fast. You know, "By the way, don't
charge my credit card twice when I hit the

00:18:40.210 --> 00:18:47.429
back button." How many times have you been
using a banking application and you're like,

00:18:47.429 --> 00:19:03.680
"Hmm, if I go back, are they going to charge
me twice?" So they would appear to be different

00:19:03.680 --> 00:19:20.550
and somewhat competing goals, right? That's
not the case. With Google Web Toolkit, what

00:19:20.550 --> 00:19:30.780
we've done is we made it possible for you
to focus on what you want to do as a developer,

00:19:30.780 --> 00:19:37.650
right? Write a great app. Killer features
you can be proud of. I mean, who will take

00:19:37.650 --> 00:19:41.670
care of making it fast and doing things like
handling history support for you, right? Let's

00:19:41.670 --> 00:19:51.180
you focus on the features. So, some back story
on Google Web Toolkit. No plugins required.

00:19:51.180 --> 00:19:59.060
Now, you'll see me talk about a developer
plugin that we use for us developers. But

00:19:59.060 --> 00:20:06.460
for your customers it's just HTML, CSS, and
JavaScript. So, you don't need any Flash plug-in.

00:20:06.460 --> 00:20:14.370
You don't need any Silverlight plug-in to
run the applications. It's nothing against

00:20:14.370 --> 00:20:23.950
those plug-ins. I think they're great, actually.
We just don't want to run into this, right?

00:20:23.950 --> 00:20:32.760
So, some plug-in is not available for let's
say your mobile phone and then you can't run

00:20:32.760 --> 00:20:40.040
an application on it. So, look, stick to standards,
right? Eric talked about cloud portability.

00:20:40.040 --> 00:20:46.460
Well, it's not just cloud portability, it's
the ability to bring your application anywhere

00:20:46.460 --> 00:20:54.480
on any device and not have to worry about
two companies working out some silly agreement.

00:20:54.480 --> 00:21:04.490
So, port use. If you just focus on IE, it's
not--you're not--this is not going to be of

00:21:04.490 --> 00:21:13.970
great importance. But if you have your focus
any other browser other than IE, it gets to

00:21:13.970 --> 00:21:21.590
be important. Because what we've done is that
each browser handles certain pieces of JavaScript

00:21:21.590 --> 00:21:37.300
code in CSS just a little differently. So,
here's one example. If I want to take--and

00:21:37.300 --> 00:21:48.990
I have a div, right, just a spot where I could
put in some HTML, there's a couple of ways

00:21:48.990 --> 00:22:02.280
that I can do this. I can say, "set in a text."
I can set text content equal to some HTML.

00:22:02.280 --> 00:22:11.140
Or I'm going to say, "intertext equals some
HTML," right? In each way, it's a little bit

00:22:11.140 --> 00:22:20.220
different. Some browsers support one, some
browsers don't support the others. And if

00:22:20.220 --> 00:22:23.670
you have to write this by hand you have to
know which way to optimize. Because, for example,

00:22:23.670 --> 00:22:32.550
on Firefox, it's a little bit faster just
to say, "intertext equals," right? And now

00:22:32.550 --> 00:22:43.210
on IE, it's significantly faster to say, "intertext
equals." So, what we do is we take those and

00:22:43.210 --> 00:22:50.200
we find the most optimal way and we expose
an API that's just normal for you. So, you

00:22:50.200 --> 00:22:52.520
just simply say, "set text," or "set HTML,"
and then we'll take care of doing the right

00:22:52.520 --> 00:23:04.190
thing for you, and then that's it. And, you
know, you might want to think that the new

00:23:04.190 --> 00:23:20.830
terms in milliseconds, this is very big. But
if you look at it, the percentages are pretty

00:23:20.830 --> 00:23:34.900
good. You had a 14% savings on Firefox; Webkit
gives you 29% savings, so on and so forth.

00:23:34.900 --> 00:23:47.660
And then there's this guy here 464, you definitely
should check out this guy's blog because it's

00:23:47.660 --> 00:23:55.860
filled with pages and pages, and pages and
pages of weird things you'll run into as you

00:23:55.860 --> 00:24:05.910
start to build up your application. Granted
you're not going to run into them the first

00:24:05.910 --> 00:24:16.970
few days but look, we're in for the long haul,
right? We're going to write an application

00:24:16.970 --> 00:24:32.910
that'll take three months. It's going to take
a year, some take two years. And it's going

00:24:32.910 --> 00:24:39.480
to grow. And eventually, we're going to get
into some weird state where like, "Oh, it

00:24:39.480 --> 00:24:51.290
just doesn't quite work right on IE6," you
know? So, we take care of that for you. Another

00:24:51.290 --> 00:24:59.680
thing, and this is why we love tools so much,
right? This is JavaScript right here. And

00:24:59.680 --> 00:25:11.820
I heard you say, "It's pretty trivial. But
can you find the bug with this example?" Well,

00:25:11.820 --> 00:25:16.530
if you can--go ahead. Right, exactly. So,
it's pretty simple, right? But it doesn't

00:25:16.530 --> 00:25:26.140
look like it. So, if you actually ran this,
the way you found a bug--unless you're just

00:25:26.140 --> 00:25:35.400
staring at it on a big screen--you run your
app and you probably have three screens into

00:25:35.400 --> 00:25:44.680
it and you get some weird JavaScript, no exception,
have no idea what's going on, have to trace

00:25:44.680 --> 00:25:52.400
back in your code, you wasted about two hours.
Totally ridiculous. But if you actually use

00:25:52.400 --> 00:26:00.200
Google Web Tool Kit and our plug-in, what
you get is nice little red squigglies, right?

00:26:00.200 --> 00:26:08.130
I mean, it sounds really silly, just red squigglies.
But you take them for granted almost because

00:26:08.130 --> 00:26:13.960
what they do is they tell you immediately
that you've done something wrong with your

00:26:13.960 --> 00:26:22.860
application, fix it now, don't worry about
going three screens down into it, and you

00:26:22.860 --> 00:26:31.590
can back up. It's demo time. So, let's use
an actual--let's create a new web app. And

00:26:31.590 --> 00:26:42.030
then we're going to actually run it the browsers
and hit a breakpoint within the IDE. This

00:26:42.030 --> 00:26:52.600
goes online? It is. So, here. Again, this
is a SpringSource Tool Suite, what I was showing

00:26:52.600 --> 00:26:59.730
you this morning. And if you go "new" and
hit "other," let's do this, "new," create

00:26:59.730 --> 00:27:06.210
a new web application project. I will use
Google Web Toolkit at this app engine. I'll

00:27:06.210 --> 00:27:09.360
call it "demos." You know what, I actually
realized that I don't have a Java SDK installed.

00:27:09.360 --> 00:27:19.590
So here's what we're going to do. I'm going
to expand on a demo that we did this morning.

00:27:19.590 --> 00:27:26.570
So, this is the application that I created
with Spring Roo this morning where I did a

00:27:26.570 --> 00:27:38.000
simple refresh demo. All you have to do--it's
going to hear and say, "debug now this Web

00:27:38.000 --> 00:27:51.010
application." And it's going to start-up the
debugger. So finally--so I've started up the

00:27:51.010 --> 00:27:58.840
debugger. I'm not going to worry about the
screen [INDISTINCT] but what I'm going to

00:27:58.840 --> 00:28:07.850
try to splice my speakerphone from my application.
So [INDISTINCT] into step one. Step up right

00:28:07.850 --> 00:28:09.600
here. [INDISTINCT] okay. Sorry about that.
So I'm sending this today--as this morning.

00:28:09.600 --> 00:28:14.970
We will talk [INDISTINCT] goes. So it's been
a part in here. It's actually compiling the

00:28:14.970 --> 00:28:23.400
Java code into some JavaScript, shooting it
up for the wire. We're going to get into how

00:28:23.400 --> 00:28:33.679
this actually works in just a second, all
right? So, let's jump. Come on, laptop, I

00:28:33.679 --> 00:28:40.500
know you can. All right. Now, not much have
showed here, but what I've done is I've actually

00:28:40.500 --> 00:28:54.240
launched development code from within an IDE,
so I'm told we will plug in for Eclipse, go

00:28:54.240 --> 00:29:04.520
ahead and launch this. I launched it in my
browser and I set a breakpoint in my Java

00:29:04.520 --> 00:29:14.100
code and that's what I get right now. So I'm
actually sitting in the IDE of a full stack

00:29:14.100 --> 00:29:23.890
trace, of a full call stack as well. I can
see what's going on and as well, I can run--I

00:29:23.890 --> 00:29:31.900
can walk in here and so if I go to run, let's
do a step into. I'm actually stepping into

00:29:31.900 --> 00:29:37.230
my code now. And I can--and as I traverse
this, I can actually debug both the client

00:29:37.230 --> 00:29:49.470
from the server side as well. So then finally
you just hit run, ensure that map efficiency

00:29:49.470 --> 00:30:02.070
keeps running. And it's warning me because
I took too long to actually complete the script,

00:30:02.070 --> 00:30:14.540
but if I continue, I should be good to go.
So there, so similar to this morning, only

00:30:14.540 --> 00:30:20.300
instead, I've actually debugged so it doesn't
run out. And I've got a breakpoint that's

00:30:20.300 --> 00:30:27.710
landing inside my IDE. Let's see how that
works. So before we come into that, we typically

00:30:27.710 --> 00:30:36.980
have a joke back in the office that, you know,
we're really just a Java and JavaScript compiler,

00:30:36.980 --> 00:30:45.559
right, that's all we do. And in fact, that
is the larger portion of what we do. We take

00:30:45.559 --> 00:30:55.030
Java turn it into a JavaScript. In fact, at
some point, we actually said, "You know, this

00:30:55.030 --> 00:31:04.090
looks a lot like assembly language because
this is the compiler output from the GWT C

00:31:04.090 --> 00:31:11.890
or from the GWT Compiler. And what it does
is it takes your Java, turns it into a JavaScript,

00:31:11.890 --> 00:31:19.679
obfuscates it and then minimizes it. So have
this--you have a small, small JavaScript download

00:31:19.679 --> 00:31:31.370
in the end of the day. But you can always
change that. And let's see, I actually want

00:31:31.370 --> 00:31:35.450
to see what the compiler's output is. I can
change it to pretty print and now I have something

00:31:35.450 --> 00:31:37.190
that actually looks like a JavaScript. So
if you've ever done an enormous HTML, CSS

00:31:37.190 --> 00:31:38.190
in JavaScript program, this should look pretty
familiar, right, given an end function and

00:31:38.190 --> 00:31:39.190
you have some other things going on, some
exception handlers. So now, let's go back

00:31:39.190 --> 00:31:40.460
to the demo and see and take a deeper dive
of actually how that happened. So how did

00:31:40.460 --> 00:31:43.780
that actually get to where I was running the
browser to debugging in the IDE? So tools

00:31:43.780 --> 00:31:44.780
were developed, right. So when I--when I hit
go inside Eclipse, in this case, it was Springsource

00:31:44.780 --> 00:31:46.400
Tool Suite which you're getting in the brand
new version of Eclipse. When I hit go and

00:31:46.400 --> 00:31:47.786
hit debug outs, what happened was the Google
plug--the Google plug-in, our Google plug-in,

00:31:47.786 --> 00:31:49.100
started a code server which is just the TC,
which is a server listed on a TCP port, and

00:31:49.100 --> 00:31:50.309
it start at the getty server. Getty is Tomcat;
it's just an embeddable server for hosting

00:31:50.309 --> 00:31:51.380
your application. And then when I launched
Firefox, there's a plug-in in Firefox that

00:31:51.380 --> 00:31:53.030
actually--that is making a TCP connection
back to the code server that's running into

00:31:53.030 --> 00:31:54.500
Eclipse and they're passing JavaScript objects
back and forth. So as I'm stepping through

00:31:54.500 --> 00:31:58.100
my code and I'm translating it into the Java
and the JavaScript, I'm shipping those over

00:31:58.100 --> 00:32:00.880
the wire back to the--back to the browser
and the browser is taking and injecting it

00:32:00.880 --> 00:32:02.510
into the page. So I really do get step by
step by step when I'm debugging. So if you

00:32:02.510 --> 00:32:03.510
look at it from Eclipse to deployment, how
do we actually get to the point where we have

00:32:03.510 --> 00:32:04.510
an application that we want to deploy? So
we start with the code, it's just code that

00:32:04.510 --> 00:32:05.510
you have in Eclipse, knowing we're authorized
to use a generator. And this is where a lot

00:32:05.510 --> 00:32:06.510
of the power of Google Web Toolkit comes from,
right? So we'll take a look into the use cases.

00:32:06.510 --> 00:32:07.510
And when we look at the--at generators, what
we're talking about is getting enough power

00:32:07.510 --> 00:32:08.510
behind your GWT App. And then, one of the
other goals is that we want to automate away

00:32:08.510 --> 00:32:09.510
a lot like BorderSide code. And then the foundation
for how we can split your app to serve up

00:32:09.510 --> 00:32:10.570
the right version on Eclipse, the right version
on Firefox, the right version on Safari, and

00:32:10.570 --> 00:32:16.610
the right version on Chrome. So let's take
a look at two use cases for why code generation

00:32:16.610 --> 00:32:20.001
is so good. One, we take a look at typical
RPC, just remote procedure calls, right? So

00:32:20.001 --> 00:32:24.900
the way this happens in a typical application,
this is a deploy AJAX call, because you have

00:32:24.900 --> 00:32:28.190
a client, right, and it takes in zero--it
takes an object, it serializes it, turns it

00:32:28.190 --> 00:32:32.210
into an XHR, an AJAX request, then it gets
to the server, the server de-serializes it.

00:32:32.210 --> 00:32:34.840
It does something with it, gets a response,
serializes that, sends it back over the wire

00:32:34.840 --> 00:32:44.309
and you de-serialize it and your application
is running. That's a lot of code you don't

00:32:44.309 --> 00:32:46.741
need to write, right, and not to mention,
if you start bumping versions, it's a real

00:32:46.741 --> 00:32:55.159
pain. So what we do is we come along and say,
"Well, since we know--we've seen all of your

00:32:55.159 --> 00:32:58.429
code, we know what you're trying to do, we're
going to put two proxies in between." So the

00:32:58.429 --> 00:33:04.761
client ends up calling a proxy which just
says, "Take this object and send it to the

00:33:04.761 --> 00:33:06.080
server," right? I don't want to care about
serialization, blah, blah, blah. You just

00:33:06.080 --> 00:33:19.290
do it. So, if you have proxies, that's great.
I know how to serialize it. I have code to

00:33:19.290 --> 00:33:23.630
do that, so turns it into a format that you
can send over the wire and again that's just

00:33:23.630 --> 00:33:29.669
using XHRs. Then when it hits the server,
it actually doesn't hit your server site code

00:33:29.669 --> 00:33:33.910
right away. It hits a GWT proxy, again, that's
running a de-serialization, hands it to your

00:33:33.910 --> 00:33:39.450
application and so your server site code,
what it's dealing with is objects. It doesn't

00:33:39.450 --> 00:33:41.791
have some JSON payload that it has to de-serialize
and in fact, the objects. It just gets the

00:33:41.791 --> 00:33:42.791
objects. They are the same when [INDISTINCT]
is true for the reverse file. So what you

00:33:42.791 --> 00:33:46.380
end up doing is you write code that looks
like this. So the top portion is your client

00:33:46.380 --> 00:33:53.311
code. And what you do is--now when putting
the other trivia example where you would do

00:33:53.311 --> 00:33:54.311
a suggestion service just like you do when
typing Google and you'd say, "I want to do

00:33:54.311 --> 00:33:55.311
a search," and you get back to search results,
it's--now I've got a defined suggest service.

00:33:55.311 --> 00:33:56.311
And I'm going to expose a method, it's called
get suggestions, and it's going to return

00:33:56.311 --> 00:33:57.311
back an array of strings when it passed through
the strings. So if I type in App, then it

00:33:57.311 --> 00:33:58.311
returns back apple and some subsequent matches
as well. Then, what I actually want it--and

00:33:58.311 --> 00:33:59.311
that's how I just find my service. That's
all I have to write and they coincide. Now

00:33:59.311 --> 00:34:01.850
when I actually click a button; and I actually
want to do something and call this, it's as

00:34:01.850 --> 00:34:02.850
simple as the--as the code will look. So I'm
going to click method, let's say I click a

00:34:02.850 --> 00:34:03.850
button, and all I have to do is say suggestservice.get
suggestions, get the text from my search box,

00:34:03.850 --> 00:34:04.850
and it provides some callback mechanisms.
That's really on the code. The key here is

00:34:04.850 --> 00:34:05.850
that you're not--you're not dealing with some
arbitrary strings. You're dealing with objects

00:34:05.850 --> 00:34:06.850
that you can pass back and forth. Strongly
typed objects that you can--not only can we

00:34:06.850 --> 00:34:07.850
compile and optimize for you, but you keep
tooling around as well. So you get code completion,

00:34:07.850 --> 00:34:09.179
refactoring, and so on and so forth. And at
the end of the day, it's really simplistic

00:34:09.179 --> 00:34:12.250
code that's easy to maintain and easy to scale.
So let's take a look at use case number two,

00:34:12.250 --> 00:34:13.250
which is creating new audits. So typically,
if you ever--if you've used Google Web Toolkit

00:34:13.250 --> 00:34:14.250
prior to our 2.0 release, what you found when
you're creating UIs by specifying a whole

00:34:14.250 --> 00:34:15.250
bunch of Java, lines and lines and lines and
lines of Java. So what we did is we decided

00:34:15.250 --> 00:34:16.250
that for, you know, our 2.0 release, we're
going to utilize the upcoming depth practices.

00:34:16.250 --> 00:34:17.250
And that's when we're going to make UIs declarative.
Make them feel like you would normally write

00:34:17.250 --> 00:34:18.250
them when you're doing a web application just
to use XML, right? Because when you're--when

00:34:18.250 --> 00:34:19.250
you're creating some web application, you're
just creating HTML, right? That's typically

00:34:19.250 --> 00:34:20.250
what you're used to doing. So we said, "Okay.
We'll do it in XML." So wee said, "By the

00:34:20.250 --> 00:34:21.250
way, when we do this, we can again minimize
some of the boiler plate code." You're going

00:34:21.250 --> 00:34:22.250
to give us time and time again when we talk
about Google Web Toolkit. And then we remove

00:34:22.250 --> 00:34:23.250
other--some other frustrations along the way.
One of them being if you've ever done, again,

00:34:23.250 --> 00:34:24.250
a typical web app and you use a lot of CSS,
you'll find that you have one big huge mile

00:34:24.250 --> 00:34:25.250
of this CCS file with a lot of strange names
which we don't have--we don't want to have

00:34:25.250 --> 00:34:26.250
namespace solutions. So there's some things
that we can do there to break that out, so

00:34:26.250 --> 00:34:27.250
that when you can find this widget that has
sub-widgets and it has this style as in this

00:34:27.250 --> 00:34:28.250
one file, we can make sure that that CSS is
specific only for that widget. So what you

00:34:28.250 --> 00:34:29.250
end up doing is you write code that looks
like this. So this is self-contained. It is

00:34:29.250 --> 00:34:30.250
a widget on a page. And all I've done is at
the very top where it says UI style, I have

00:34:30.250 --> 00:34:31.250
specified some style. I want it to--I want
some margin; I want some padding around this

00:34:31.250 --> 00:34:32.250
widget. And then, I dropped down, and below
where I think this is really powerful. I start

00:34:32.250 --> 00:34:33.250
to layout my UI, again in declarative form
using XML. And if you squint just a little

00:34:33.250 --> 00:34:34.250
bit, this looks like standard HTML only if
you used some widgets here. So you notice

00:34:34.250 --> 00:34:35.250
things like horizontal panel; that's specific
to Google Web Toolkit applications. Then we

00:34:35.250 --> 00:34:36.250
can find two buttons. So what you end up with
is a horizontal panel with two buttons in

00:34:36.250 --> 00:34:37.250
it with some added color, and that's it. Now
you can see how you can start your string

00:34:37.250 --> 00:34:38.250
on this. But the beauty is this is self-contained.
So if I have styles inside of here, right?

00:34:38.250 --> 00:34:39.250
They're specific to only that widget. It will
not affect anything else in the page. And

00:34:39.250 --> 00:34:40.250
then what you can do is by using the UI field
mechanisms, you'll see that UI field add button,

00:34:40.250 --> 00:34:41.250
UI field delete button. I can then go annotate
my Java code with those same field names and

00:34:41.250 --> 00:34:42.250
implement click handlers for them. And the
generators come along and they will link up

00:34:42.250 --> 00:34:43.250
my declarative UI and the XML that you see
right there and the Java code where I've annotated

00:34:43.250 --> 00:34:44.250
with these UI fields. And when I talk of--if
in it--if you're a current Google Web Toolkit

00:34:44.250 --> 00:34:45.250
user, I'm going to have a few tips and tricks
as we move through here. But if you're interested

00:34:45.250 --> 00:34:46.250
in what we're generating, the code that we're
generating, the code that I'm talking about,

00:34:46.250 --> 00:34:47.250
you can simply pass it down to [INDISTINCT]
flag through your compiler, and you'll see

00:34:47.250 --> 00:34:48.250
all this firsthand. In fact, we talked about
another--a couple other flags you can pass

00:34:48.250 --> 00:34:49.250
through your compiler to optimize your application
in a second. So, a good reason. We talked

00:34:49.250 --> 00:34:50.250
about generators, right? So moving along the
chains to get into production, we're going

00:34:50.250 --> 00:34:51.250
to talk about translators. But it gets pretty
simple after generators because translators,

00:34:51.250 --> 00:34:52.250
all they are that's where to JavaScript to
Java--Java to JavaScript compiler comes in

00:34:52.250 --> 00:34:53.250
where we've taken your Java code--we've taken
the code that we're generating, right? And

00:34:53.250 --> 00:34:54.250
now we have the entire app. It's all Java
source. And what we do then is we take our

00:34:54.250 --> 00:34:55.250
compiler and we're going to compile our pass
on it, that compiles it for JavaScript and

00:34:55.250 --> 00:34:56.250
then optimizes along the way to all these
things and compresses it so that it's minimal.

00:34:56.250 --> 00:34:57.250
That's it. So then we need the linkers. Now,
if anybody's ever done compiler design or

00:34:57.250 --> 00:34:58.250
worked on compilers before, you'll see--you'll
notice a pattern here. This is typically what

00:34:58.250 --> 00:34:59.250
compilers do as well, right? If you took a
normal C++ compiler, you would see that instead

00:34:59.250 --> 00:35:00.250
of generators, they have macro expansion.
And then the translators, that's actually

00:35:00.250 --> 00:35:01.250
where they're translating it into assembly
code and then linkers to pull it all together

00:35:01.250 --> 00:35:02.250
to give you the EXE that we're looking for;
so we're doing stuff that are--that's similar.

00:35:02.250 --> 00:35:03.250
And the EXE that it produces is typically
tied to a platform, right? It's what--it's

00:35:03.250 --> 00:35:04.250
the binary that we hand out if you're building
an application. Same thing goes for linkers

00:35:04.250 --> 00:35:05.250
here, right? The linkers are the entry points
of your GWT application--for your Google Web

00:35:05.250 --> 00:35:06.250
Toolkit application. Now, that could be I
want to load from my site or I want to do

00:35:06.250 --> 00:35:07.250
a mash up where I load from your site onto
my site, so there's some cross-scripting going

00:35:07.250 --> 00:35:08.250
on. Or I actually want to create a mobile
application in which point I'll--in which

00:35:08.250 --> 00:35:09.250
case, I'll have to completely separate entry
points so that it can serve up just some slightly

00:35:09.250 --> 00:35:10.250
to the HTML but still the same JavaScript
on the backend that I'm using and generating

00:35:10.250 --> 00:35:11.250
from a Java code. So again, when I talk about
entry points, this is what I'm talking about,

00:35:11.250 --> 00:35:12.250
there's permutations. If you keep going off
and you use Google Web Toolkit, right, you'll

00:35:12.250 --> 00:35:13.250
end up generating something that looks like
this. Now, it looks a little bit cryptic and

00:35:13.250 --> 00:35:14.250
that's fine; but what you end up have--what
you end up with here, each of these HTML pages

00:35:14.250 --> 00:35:15.250
are for your--for a specific browser. They're
for Internet Explorer, or they're for IEE--I'm

00:35:15.250 --> 00:35:16.250
sorry, they're for IE, or they're for Chrome,
or they're for Safari and also per language

00:35:16.250 --> 00:35:17.250
as well. So you can serve a specific application
for Internet Explorer 6 for the English version

00:35:17.250 --> 00:35:18.250
or for whatever language your actual server
got. So you've me talk about optimizing the

00:35:18.250 --> 00:35:19.250
way we're all going to type code, right? And
I'm really focused on developer efficiency.

00:35:19.250 --> 00:35:20.250
That was one of the messages we're talking
about in the keynote. So here I kind of go

00:35:20.250 --> 00:35:21.250
through some of the developer time cycle column.
And what we see typically is that you want

00:35:21.250 --> 00:35:22.250
to go write some code, you run it, you push
a few pixels around, right? Have you ever

00:35:22.250 --> 00:35:23.250
gone to this, this stage where you could just
tweaking little things here and there? So

00:35:23.250 --> 00:35:24.250
you just push a few pixels around just to
make it look just right. And then you have

00:35:24.250 --> 00:35:25.250
to compile and then you go off. And while
it's compiling, you read some xkcd, you read

00:35:25.250 --> 00:35:26.250
some blogs and Twitter traffic. You might
debate with your colleague about what color

00:35:26.250 --> 00:35:27.250
[INDISTINCT] should then you revel in your
accomplishments because finally the compilations

00:35:27.250 --> 00:35:28.250
done and you deployed it and then you rinse-wash
your IP. So you actually spend, you know,

00:35:28.250 --> 00:35:29.250
50% of your day writing code, the other 50%
of your day doing nothing, you're being unproductive.

00:35:29.250 --> 00:35:30.250
Well, if you're having fun, you're honestly
being productive. So, you know, we talked

00:35:30.250 --> 00:35:31.250
about it to look into that and what's going
on, right? So if you happen to go through

00:35:31.250 --> 00:35:32.250
that cycle, well, you happen to be in that
cycle for a reason because you have tradeoffs,

00:35:32.250 --> 00:35:33.250
right? You are not writing code because the
compiler is running. When the compiler is

00:35:33.250 --> 00:35:34.250
running it's optimizing your code. It's making
it small. It's giving you this alpha list.

00:35:34.250 --> 00:35:35.250
So you get speed, or end-user gets speed,
and trade off for your productivity. Or so

00:35:35.250 --> 00:35:36.250
we think. You asked for quick user experience,
right? So while the compiler is running and

00:35:36.250 --> 00:35:37.250
it's doing all of this [INDISTINCT], it's
generating all those permutations, it's having

00:35:37.250 --> 00:35:38.250
to parse to your Java code and actually spit
out a version of IE6 that runs in English,

00:35:38.250 --> 00:35:39.250
a version of IE6 that runs in Japanese, and
the same probably on the browsers. That takes

00:35:39.250 --> 00:35:40.250
a while. So again, trading off developer productivity
for user experience, or so you think. So there's

00:35:40.250 --> 00:35:41.250
a couple ways you can accomplish this. So
if you're having difficulty compiling it,

00:35:41.250 --> 00:35:42.250
right, and you have to develop a timestamp
of what's going on, what you can do is you

00:35:42.250 --> 00:35:43.250
can specify things, even a little tricky.
We specify things like I just want a compile

00:35:43.250 --> 00:35:44.250
for Firefox running in English because that's
what I'm developing on, right? I'm in the

00:35:44.250 --> 00:35:45.250
development phase. I'm not on the production
phase. I'm not going to the QA cycle. I'm

00:35:45.250 --> 00:35:46.250
just writing code to develop this. That's
one way you can do it. You can also speed

00:35:46.250 --> 00:35:47.250
it up by simply telling the compiler, "Hey,
compiler, no more optimizations. I don't care.

00:35:47.250 --> 00:35:48.250
I'm just writing the code. I'm just developing.
It doesn't need to be super fast because I'm

00:35:48.250 --> 00:35:49.250
not pushing a new production yet. So you compile
it faster, you can deploy it, you test your

00:35:49.250 --> 00:35:50.250
changes, that kind of works, too. But why
were you out compiling at all? Why bother

00:35:50.250 --> 00:35:51.250
with this? The real way we should be developing
code is simply like this; you write some code,

00:35:51.250 --> 00:35:52.250
we refresh the new browser just like I showed
you. Does it work? Nope. Let's develop some

00:35:52.250 --> 00:35:53.250
more. Let's refresh. Does it work? Keep that
cycle going, and that's quick. Those are quick

00:35:53.250 --> 00:35:54.250
refreshes. So you're making changes and you're
seeing instantaneous feedback. And finally,

00:35:54.250 --> 00:35:55.250
when you're done, then compile and then deploy.
Hopefully, the Google App Engine go wherever

00:35:55.250 --> 00:35:56.250
you want to deploy. So what you do is, this
is the software along the life cycle we that

00:35:56.250 --> 00:35:57.250
want to see for Web applications, for Web
app developments. It's what everybody else

00:35:57.250 --> 00:35:58.250
in the industry has. We should have it, too.
So, great. We're happy, right? So as developers

00:35:58.250 --> 00:35:59.250
we're happy though. We have--well, I think
you are. I hope you are. We're--we have tools

00:35:59.250 --> 00:36:00.250
that make us efficient. We got strong and
tight languages, that's good. We got IDEs,

00:36:00.250 --> 00:36:01.250
that's fantastic. But what about our users?
What about your customers, right? Are they

00:36:01.250 --> 00:36:02.250
happy? Are they getting exactly what they
want? I mean, after all, the GWT compilers

00:36:02.250 --> 00:36:03.250
coming along and making that really tight,
small JavaScript which lets me go a step further.

00:36:03.250 --> 00:36:04.250
So let's talk about optimization for users.
So there's two ways you can do this. You can

00:36:04.250 --> 00:36:05.250
phone the resources and you can split your
code. Now if you've ever done gaming before,

00:36:05.250 --> 00:36:06.250
writing games, you do a thing called sprite
which is where you take a whole bunch of images

00:36:06.250 --> 00:36:07.250
and you put them into one and then you just
do offsets to get to those. You can do a similar

00:36:07.250 --> 00:36:08.250
thing in Google Web Toolkit. So let's take
a simple example. I would associate icons

00:36:08.250 --> 00:36:09.250
with my contacts, all right? So when I do
that I have a contacts application. At some

00:36:09.250 --> 00:36:10.250
point in time in that application, I'm going
click a button, I'm going to get a dialogue

00:36:10.250 --> 00:36:11.250
that looks like this, right, and I'm going
to pick an icon to pull with my users. Pretty

00:36:11.250 --> 00:36:12.250
simple. So--and I'm going to hand over a few
of the details so bear with me. But you can

00:36:12.250 --> 00:36:13.250
do this one way. You can goFetch all those
20 images, okay, there's 20 images there,

00:36:13.250 --> 00:36:14.250
right? You can fetch those one at a time.
Give me image one. Give me image two. Give

00:36:14.250 --> 00:36:15.250
me image three. And that would work. So I
fetch the image and then you'd actually set

00:36:15.250 --> 00:36:16.250
the height and the width, and then it would
add it to the images panel. It works perfectly

00:36:16.250 --> 00:36:17.250
fine. By the way, that's--that is the GWT
code right there. So this is what you'd see

00:36:17.250 --> 00:36:18.250
if you did that. Now this is fire--this Firefox--running
in Firefox, right? So what you see is initial

00:36:18.250 --> 00:36:19.250
download, so I'm going to go fetch my application.
I'm going to pull it down, right? So I fetch

00:36:19.250 --> 00:36:20.250
my contacts to HTML, which is a really small
file, and that tells me, "Okay, it looks like

00:36:20.250 --> 00:36:21.250
you're running on Firefox with the versions--with
language set in English, so go fetch this

00:36:21.250 --> 00:36:22.250
other JavaScript. That's the second set you
see. That's 61K." Then later on my application,

00:36:22.250 --> 00:36:23.250
you see a whole bunch of fetches to get the
images, right? Those are all those 20 images.

00:36:23.250 --> 00:36:24.250
The problem is that when you do that it's
inefficient because you're actually experiencing

00:36:24.250 --> 00:36:25.250
all the HTTP overhead associated with getting
an image. Now you don't think that's a lot.

00:36:25.250 --> 00:36:26.250
And it's not, when there's 20 images. But
imagine if you're getting 2,000 images or

00:36:26.250 --> 00:36:27.250
imagine you are scaling to the size of a Bing
search, or Google search, or Yahoo search.

00:36:27.250 --> 00:36:28.250
The speed needs to be instantaneous so you
don't want to go with that overhead. So there's

00:36:28.250 --> 00:36:29.250
ways to do that. And actually, there's one
specific way to do that. What we can do is

00:36:29.250 --> 00:36:30.250
we can take advantage again of a code generation
inside Google Web Toolkit. And all we have

00:36:30.250 --> 00:36:31.250
to do is we say, we're going to define the
interface, right? The interface--the implementation

00:36:31.250 --> 00:36:32.250
of this interface is going to be generated
by Google Web Toolkit. But what we do is we

00:36:32.250 --> 00:36:33.250
said, "Okay, I'm going to find an interface
with a bunch of methods and I'm going to annotate

00:36:33.250 --> 00:36:34.250
them with a path to my actual file," right?
So what I have then is I have this interface,

00:36:34.250 --> 00:36:35.250
this nice interface. And I can say, resources.,
you know, imagezero, and it will give me back

00:36:35.250 --> 00:36:36.250
an image resource, an actual Google Web Toolkit
class that I can use to display that image.

00:36:36.250 --> 00:36:37.250
Now, how I got that? It doesn't matter because
what were doing is we're taking all those

00:36:37.250 --> 00:36:38.250
images, compressing them down into one file
and then overlaying this interface on top

00:36:38.250 --> 00:36:39.250
of it so you can actually call and link that
image resource. When you do that, you end

00:36:39.250 --> 00:36:40.250
up with a column, a call stack, that looks
like this. So again, we get the contact to

00:36:40.250 --> 00:36:41.250
HTML, that doesn't change, it's 2k, very small.
Then we go fetch our JavaScript and we're

00:36:41.250 --> 00:36:42.250
like, "Hmm, that's a little bigger. I'll come
back to that in a second." Then we move through

00:36:42.250 --> 00:36:43.250
our application and then suddenly when I pop-up
that image dialog again you don't see the

00:36:43.250 --> 00:36:44.250
20 fetches. This is great. "I reduced all
that http overhead on my application. I've

00:36:44.250 --> 00:36:45.250
gotten rid of it." But the problem is when
you look at this really closer, the problem

00:36:45.250 --> 00:36:46.250
is that. So now, those fetches, right? I've
taken all that data that I have to give, those

00:36:46.250 --> 00:36:47.250
20 images, and I have to go fetch it when
I initially did my application. So, that's

00:36:47.250 --> 00:36:48.250
great. You have no worries the view overhead
but that means my users have to experience

00:36:48.250 --> 00:36:49.250
that lag the first time they ran my application.
That kind of sucks. You don't want that to

00:36:49.250 --> 00:36:50.250
happen. Imagine if that, again, that was 2,000
images. You have to pull down, 1 to 10 megs

00:36:50.250 --> 00:36:51.250
of JavaScript to initially run your application.
Imagine that you're doing that now on a mobile

00:36:51.250 --> 00:36:52.250
phone. Unacceptable, right? So there's another
way to fix that. So let me introduce code

00:36:52.250 --> 00:36:53.250
splitting. Code splitting is just that, the
idea that you're splitting your code. You're

00:36:53.250 --> 00:36:54.250
only going to fetch what you need. If you
remove optimizations in any application you've

00:36:54.250 --> 00:36:55.250
written, we call that kind of lazy fetching,
lazy initializations, go fetch all my contacts

00:36:55.250 --> 00:36:56.250
right after them, do page in that sense. Well,
this is the same thing here. So, when we're

00:36:56.250 --> 00:36:57.250
talking about JavaScript, right? So, if at
the end of the day my entire application is

00:36:57.250 --> 00:36:58.250
two megs of JavaScript but I only need the
first 20k and show the first screen to you

00:36:58.250 --> 00:36:59.250
new application, then why should I be needing
them? Let's see what we have here. So, now

00:36:59.250 --> 00:37:00.250
imagine if when I click on that button, right,
when I click on the button, it showed that

00:37:00.250 --> 00:37:01.250
images dialog, if I surround it with something
that's specific to Google Web Toolkit, right,

00:37:01.250 --> 00:37:02.250
which is this GWT.runAsync that kind of wraps
what's going to happen when I actually call

00:37:02.250 --> 00:37:03.250
the [INDISTINCT] what the compiler does is
it comes and looks for those split points

00:37:03.250 --> 00:37:04.250
as it works to the application. Again, the
tracking, we have a holistic view of your

00:37:04.250 --> 00:37:05.250
application that allows you to do these kind
of tricks. And it says, you know what, the

00:37:05.250 --> 00:37:06.250
developer has said that he doesn't want to
have this, he wants to split this off, right?

00:37:06.250 --> 00:37:07.250
And as long as it doesn't have any ties back
in other portions of your application it can

00:37:07.250 --> 00:37:08.250
be completely separated, the compiler will
create a whole bunch of JavaScript files.

00:37:08.250 --> 00:37:09.250
And then when your application is running,
you've noticed that like when you get to a

00:37:09.250 --> 00:37:10.250
point, "Oh, I don't have a JavaScript so I
have to make a callout and then get answers

00:37:10.250 --> 00:37:11.250
to an RPC call [INDISTINCT] to fetch that
JavaScript and bring it in your application

00:37:11.250 --> 00:37:12.250
in you run it. The nice thing is that they
call stack then looks like this, exactly the

00:37:12.250 --> 00:37:13.250
way we want it. You get your initial HTML.
It doesn't change, again, that's 2k. Then

00:37:13.250 --> 00:37:14.250
you go and fetch your JavaScript instead of
being a 160k, like previously, it's back down

00:37:14.250 --> 00:37:15.250
to 39k, which is very reasonable. Again, it
should be available, imagine less than 200,000

00:37:15.250 --> 00:37:16.250
images for 2,000 images. And then finally,
when I get later on in my application, I make

00:37:16.250 --> 00:37:17.250
a comment and slide images, look what we have.
We actually do the fetch to get the images

00:37:17.250 --> 00:37:18.250
but we do in a way that we minimize the initial
views overhead. So we have the best of both

00:37:18.250 --> 00:37:19.250
worlds. Quick start time going to the applications,
look and feels like a desktop application

00:37:19.250 --> 00:37:20.250
but then hyper-optimized throughout my application
and it'll only pull when I need to. And by

00:37:20.250 --> 00:37:21.250
the way, once you pull down images, they're
cached if you want to do it again. So this

00:37:21.250 --> 00:37:22.250
way we get the best of both worlds. And so,
finally, to recap, we have--we talked about,

00:37:22.250 --> 00:37:23.250
Google Web Toolkit, Java for front-end development,
right? Tools to target large view applications

00:37:23.250 --> 00:37:24.250
which means that you have now a language that
works on IDEs and all these tools. Beyond

00:37:24.250 --> 00:37:25.250
the idea, imagine all the plug-ins that are
there Eclipse and IntelliJ, right, they all

00:37:25.250 --> 00:37:26.250
work with Google Web Toolkit. So that in turn
makes you efficient developers. And then given

00:37:26.250 --> 00:37:27.250
the fact that you're efficient developers,
you can go write killer features and you could

00:37:27.250 --> 00:37:28.250
start incorporating these best practices,
tweaking for that last 10%, which you're not

00:37:28.250 --> 00:37:29.250
worried about all that boilerplate code. See,
this is why I keep saying, no more boilerplate

00:37:29.250 --> 00:37:30.250
code, no more of that just stifling applications
that you have to right. Let some tool do it

00:37:30.250 --> 00:37:30.265
for you. You can focus on killer features
and making your end-users happy. That's it.

