WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:04.480
MARCELO CAMELO: Welcome again.

00:00:04.480 --> 00:00:06.080
My name is Marcelo.

00:00:06.080 --> 00:00:08.730
I'm the tech lead for
the Places API.

00:00:08.730 --> 00:00:13.440
I work as part of the Maps
API team in Sydney.

00:00:13.440 --> 00:00:17.030
And we're going to be talking
today about writing location

00:00:17.030 --> 00:00:19.730
based apps using Google APIs.

00:00:25.800 --> 00:00:30.230
So this is the feedback
page for the session.

00:00:30.230 --> 00:00:33.520
And also, if you're tweeting
about how awesome your next

00:00:33.520 --> 00:00:36.770
location-based app is going to
be, this is the hashtag you'll

00:00:36.770 --> 00:00:38.990
want to use.

00:00:38.990 --> 00:00:43.040
So yeah, most of the Maps API
team is based in Sydney.

00:00:43.040 --> 00:00:44.540
We've created part of that.

00:00:44.540 --> 00:00:50.900
And I've got a few stickers
here with a cool Maps API

00:00:50.900 --> 00:00:55.900
marker and the Aussie flag, so
you guys can take it after

00:00:55.900 --> 00:00:57.150
this session.

00:01:00.380 --> 00:01:02.730
So this is the agenda
for today.

00:01:02.730 --> 00:01:06.250
And I'm going to give you a
quick intro about what the

00:01:06.250 --> 00:01:08.980
Places API is about.

00:01:08.980 --> 00:01:12.080
Then I'm going to go over each
of the main features of the

00:01:12.080 --> 00:01:17.930
API, alternating between live
demos and cold samples.

00:01:17.930 --> 00:01:20.260
It's going to be a bit dry
because I really want to show

00:01:20.260 --> 00:01:23.900
you how you use the API.

00:01:23.900 --> 00:01:29.040
So I'm going to be using
shell commands.

00:01:29.040 --> 00:01:30.380
Be prepared.

00:01:30.380 --> 00:01:35.070
And then I'm going to hand it
over to Yoni, from SCVNGR, and

00:01:35.070 --> 00:01:38.960
he's going to be telling us
about his experience using the

00:01:38.960 --> 00:01:41.375
API from an engineering
perspective.

00:01:45.810 --> 00:01:48.550
So instead of telling you what
an API is, I'm going to show

00:01:48.550 --> 00:01:49.800
you a quick demo.

00:01:52.800 --> 00:01:55.730
So one really cool feature
of the Places API

00:01:55.730 --> 00:01:58.250
is the suggest feature.

00:01:58.250 --> 00:02:04.270
So I can start typing here say,
the Moscone Center, so it

00:02:04.270 --> 00:02:08.520
shows up pretty quickly one
of our first suggestions.

00:02:08.520 --> 00:02:16.620
Or I could try say, going a bit
further, Australia-- you

00:02:16.620 --> 00:02:19.630
see that it's actually
ranked lower.

00:02:19.630 --> 00:02:24.750
That's because I'm looking at
San Francisco, so it's biasing

00:02:24.750 --> 00:02:27.780
results within the viewport.

00:02:27.780 --> 00:02:30.710
So if I choose Australia,
so there I am.

00:02:30.710 --> 00:02:41.330
Now I can go Sydney, right at
the top, Pyrmont [TYPING]

00:02:47.710 --> 00:02:49.500
Google Sydney.

00:02:49.500 --> 00:02:52.140
So that's where our office is.

00:02:52.140 --> 00:02:57.750
So you see, really quick I went
from zooming right in

00:02:57.750 --> 00:03:01.460
from the Moscone Center into
the Google office halfway

00:03:01.460 --> 00:03:02.900
around the world.

00:03:02.900 --> 00:03:06.560
And here I'll do
a Place search.

00:03:06.560 --> 00:03:08.800
So returning a couple
of results.

00:03:08.800 --> 00:03:16.540
Some of them are what we call
Geocodes: things like suburbs,

00:03:16.540 --> 00:03:21.010
localities, cities, and
also local listings.

00:03:21.010 --> 00:03:26.332
So Google Sydney is here, I
click on the listing, and I

00:03:26.332 --> 00:03:30.320
show some details about
the listing.

00:03:30.320 --> 00:03:34.345
So you see over there,
Signorelli Gastronomia, so on

00:03:34.345 --> 00:03:35.750
and so forth.

00:03:35.750 --> 00:03:38.440
So that's the idea
behind the API.

00:03:38.440 --> 00:03:44.510
So it'll give you an easy access
to places in general,

00:03:44.510 --> 00:03:50.910
business listings, or a Geocode,
a suburb, a point of

00:03:50.910 --> 00:03:54.170
interest in general.

00:03:54.170 --> 00:03:55.420
So how do you do this?

00:03:58.770 --> 00:04:02.220
There are two main ways to
access the API: one is via the

00:04:02.220 --> 00:04:06.720
JS API, and the other one
is via the web service.

00:04:06.720 --> 00:04:08.400
Just a quick show
of hands here.

00:04:08.400 --> 00:04:11.180
How many of you use
the Maps API?

00:04:14.150 --> 00:04:16.019
How many of you use
the Maps API v3?

00:04:18.790 --> 00:04:20.899
How many of you have ever
used a library?

00:04:24.680 --> 00:04:28.430
All right, maybe 15, 20%.

00:04:28.430 --> 00:04:32.660
So for those that don't know,
a library on Maps API v3

00:04:32.660 --> 00:04:36.880
allows us to add known core
functionality to the API

00:04:36.880 --> 00:04:41.670
without adding bulk
to the binary.

00:04:41.670 --> 00:04:44.230
So Places is one more
of those libraries.

00:04:44.230 --> 00:04:49.030
So when you specify in the
bootstrap request, an extra

00:04:49.030 --> 00:04:52.590
module will be downloaded
with the API.

00:04:52.590 --> 00:04:56.100
And all Places API symbols will
be available inside the

00:04:56.100 --> 00:04:59.230
Google Maps Places name space.

00:05:04.390 --> 00:05:08.580
You also have to set a sensor
flag to either true or false,

00:05:08.580 --> 00:05:09.750
depending on where you're
getting your

00:05:09.750 --> 00:05:11.000
location signal from.

00:05:16.860 --> 00:05:22.360
So the other way to use the API
is via the web service.

00:05:22.360 --> 00:05:25.560
So how many of you were thinking
of writing a native

00:05:25.560 --> 00:05:28.180
app, running maybe on a--

00:05:28.180 --> 00:05:30.200
OK.

00:05:30.200 --> 00:05:33.450
So if you want to write a native
app, you probably will

00:05:33.450 --> 00:05:41.060
be using the HTTPS service, and
that offers both JSON and

00:05:41.060 --> 00:05:43.950
XML endpoints.

00:05:43.950 --> 00:05:47.520
You have to sign up for a key
in the developer's console.

00:05:47.520 --> 00:05:48.480
It's really easy.

00:05:48.480 --> 00:05:51.580
It gives you an API key.

00:05:51.580 --> 00:05:55.830
You set the API key for every
request, as I'm doing here in

00:05:55.830 --> 00:05:58.340
the example.

00:05:58.340 --> 00:06:01.560
And you also set the sensor
flag again, either true or

00:06:01.560 --> 00:06:04.070
false, depending where the
location is coming from.

00:06:09.330 --> 00:06:17.090
So here I'll show you just what
happens if you try to

00:06:17.090 --> 00:06:19.370
send the request
without a key.

00:06:21.890 --> 00:06:29.630
The same request now, with the
key set, gets this back.

00:06:29.630 --> 00:06:37.440
So, if you look at my request, I
specify the location and the

00:06:37.440 --> 00:06:38.500
radius, right?

00:06:38.500 --> 00:06:42.020
So I'm doing a 200-meter search

00:06:42.020 --> 00:06:44.800
around a specific location.

00:06:44.800 --> 00:06:50.140
And what I get back is response
status and a list of

00:06:50.140 --> 00:06:53.180
Places in the array
called results.

00:06:55.930 --> 00:06:58.590
So it's very straightforward,
actually.

00:07:02.640 --> 00:07:07.200
So Place Search, so this
is another demo.

00:07:07.200 --> 00:07:13.992
So whenever I drag the map,
it reissues a search.

00:07:13.992 --> 00:07:18.770
If I zoom in, it
reissues again.

00:07:18.770 --> 00:07:23.560
So you see, it's always
returning 20 results plus

00:07:23.560 --> 00:07:27.090
maybe two or three Geocodes.

00:07:27.090 --> 00:07:35.540
The results are ranked based on
a Google-specific ranking.

00:07:35.540 --> 00:07:40.130
But we're going to see later in
the session that when you

00:07:40.130 --> 00:07:42.660
do check-ins, you can
actually have an

00:07:42.660 --> 00:07:43.910
impact on that ranking.

00:07:47.240 --> 00:07:48.490
So how do you do that search?

00:07:51.560 --> 00:07:57.520
So since most of you look more
interested in using it from

00:07:57.520 --> 00:08:03.270
the JavaScript perspective,
this is how you do it.

00:08:03.270 --> 00:08:07.190
So you declare a request object,
providing a location

00:08:07.190 --> 00:08:11.400
and a radius, the location
is the LatLng.

00:08:11.400 --> 00:08:17.460
You associate a PlacesService
object.

00:08:17.460 --> 00:08:22.380
And you provide either a map
or a div of your own.

00:08:22.380 --> 00:08:26.910
And the reason we need that is
because we need to display all

00:08:26.910 --> 00:08:29.420
the attributes, the copyrights,
from the list that

00:08:29.420 --> 00:08:30.480
we're going to return.

00:08:30.480 --> 00:08:35.960
So if you provide a map, the
copyright will appear together

00:08:35.960 --> 00:08:39.809
with the attributes
of the map.

00:08:39.809 --> 00:08:44.630
Then you call a search on the
Places object, providing the

00:08:44.630 --> 00:08:48.290
request, and then a
callback function.

00:08:48.290 --> 00:08:50.130
And the callback function will
be called when the results

00:08:50.130 --> 00:08:53.310
come back from the Places API.

00:08:53.310 --> 00:08:56.660
And it's going to contain an
array of Places in the results

00:08:56.660 --> 00:09:00.980
array and also the
response status.

00:09:00.980 --> 00:09:03.370
So here I'm ignoring the
response status.

00:09:03.370 --> 00:09:06.440
You shouldn't when you're
actually try to use this.

00:09:06.440 --> 00:09:10.910
But what I'm doing is I'm going
through all the entries

00:09:10.910 --> 00:09:15.860
in the array and adding
a marker.

00:09:15.860 --> 00:09:19.560
And then you can see, when I
create the marker, I use the

00:09:19.560 --> 00:09:21.820
geometry, the location
properties on the Place to set

00:09:21.820 --> 00:09:23.250
a position.

00:09:23.250 --> 00:09:26.750
I use the name as the
title of the marker.

00:09:26.750 --> 00:09:35.280
I use the icon as the custom
image for the marker.

00:09:35.280 --> 00:09:37.850
So, really easy.

00:09:40.840 --> 00:09:46.100
So if you're using the web
service interface, you're

00:09:46.100 --> 00:09:50.490
going to call the Maps API
search, either JSON or XML

00:09:50.490 --> 00:09:54.090
endpoints depending on what
you're more comfortable

00:09:54.090 --> 00:10:00.140
dealing with, that's a location
of ranges and I

00:10:00.140 --> 00:10:04.220
didn't put it there, but also
the key and the sensor flag.

00:10:08.370 --> 00:10:11.460
So we've seen what the
results look like.

00:10:11.460 --> 00:10:14.105
So it's going to be
a list of places.

00:10:18.590 --> 00:10:20.830
And these are the attributes
that come back

00:10:20.830 --> 00:10:21.930
on the search result.

00:10:21.930 --> 00:10:25.650
So you get name, you got
vicinity, which is a way to

00:10:25.650 --> 00:10:27.930
disambiguate two results
if they're the same.

00:10:27.930 --> 00:10:37.130
So if you have two Starbucks
within your search radius, you

00:10:37.130 --> 00:10:39.820
can provide that to your user so
he can tell to tell the two

00:10:39.820 --> 00:10:42.730
Starbucks apart.

00:10:42.730 --> 00:10:47.340
A list of types, which are the
categories that are assigned

00:10:47.340 --> 00:10:51.480
to that listing, and the
geometry and an icon, so you

00:10:51.480 --> 00:10:54.215
can use the icon to display
your results.

00:10:58.500 --> 00:11:03.670
So this is a thin slice of the
types that we support.

00:11:03.670 --> 00:11:07.280
Just wanted to give
you an idea of how

00:11:07.280 --> 00:11:09.710
the API treats types.

00:11:09.710 --> 00:11:13.320
So it's actually a hierarchy
of types.

00:11:13.320 --> 00:11:17.470
And usually a place is assigned
to one of those leaf

00:11:17.470 --> 00:11:19.100
nodes, sometimes
more than one.

00:11:19.100 --> 00:11:22.440
It could be, say, a
cafe, a bar and a

00:11:22.440 --> 00:11:24.710
restaurant at the same time.

00:11:24.710 --> 00:11:26.300
When you get the results
back, you don't get

00:11:26.300 --> 00:11:28.050
just the leaf node.

00:11:28.050 --> 00:11:31.380
You get the leaf node and all
the parents node of that leaf.

00:11:31.380 --> 00:11:34.690
So if it's a bar, you're
going to get bar, food,

00:11:34.690 --> 00:11:36.200
establishment, right?

00:11:36.200 --> 00:11:37.810
And if it's a neighborhood,
you're going to get

00:11:37.810 --> 00:11:39.310
neighborhood, political.

00:11:42.340 --> 00:11:46.690
And the icon is also attached to
each of those types, so if

00:11:46.690 --> 00:11:49.380
you have a specific icon for
the leaf node, that's what

00:11:49.380 --> 00:11:51.950
you're going to return,
Otherwise you're going to

00:11:51.950 --> 00:11:56.120
return to the first icon
that shows up the tree.

00:12:00.050 --> 00:12:04.080
So in this example, if I'm
returning shoe store because I

00:12:04.080 --> 00:12:06.620
don't have a specific icon for
shoe store, I'll just return

00:12:06.620 --> 00:12:08.340
you the icon for store.

00:12:15.240 --> 00:12:19.000
So, as I said, this is really
a tiny slice of the classes

00:12:19.000 --> 00:12:20.080
that we support.

00:12:20.080 --> 00:12:23.990
And if you look, the
documentation will list more

00:12:23.990 --> 00:12:27.020
than 100 different types.

00:12:27.020 --> 00:12:30.720
And you can use those
types in two places.

00:12:30.720 --> 00:12:32.880
You can use them if you're
filtering search.

00:12:32.880 --> 00:12:36.490
We're going to see that later
how you do filtering by type.

00:12:36.490 --> 00:12:41.720
And you can also use it when
you're adding your own places.

00:12:41.720 --> 00:12:46.890
There's actually a difference
here at the bottom of the

00:12:46.890 --> 00:12:50.150
list. There are some types
that you can't add.

00:12:50.150 --> 00:12:56.130
So currently it would not allow
you to add a country or

00:12:56.130 --> 00:12:57.230
a locality.

00:12:57.230 --> 00:12:59.260
So most of the Geocodes we
don't allow you to add.

00:12:59.260 --> 00:13:02.510
So we're looking more at
adding local listings.

00:13:17.380 --> 00:13:22.300
So filtering by type, this is
how you do it if you're using

00:13:22.300 --> 00:13:23.850
JavaScript.

00:13:23.850 --> 00:13:26.660
So, when declaring the request,
in addition to the

00:13:26.660 --> 00:13:30.120
location, the radius, you
add a type array.

00:13:30.120 --> 00:13:33.890
And in this type array you can
include all the types that

00:13:33.890 --> 00:13:36.020
you're interested in getting
back from the Places API.

00:13:39.420 --> 00:13:43.630
So in this demo here,
what I have is a

00:13:43.630 --> 00:13:46.570
search without any filtering.

00:13:46.570 --> 00:13:50.200
And then, when I click on
Museum, I'm actually adding

00:13:50.200 --> 00:13:55.830
museum to the list of
types that I want.

00:13:55.830 --> 00:13:56.320
Restaurants--

00:13:56.320 --> 00:14:01.430
I'm getting museums and
restaurants, lodging, and I

00:14:01.430 --> 00:14:04.340
can use any combination
of those.

00:14:04.340 --> 00:14:09.150
So that's different from listing
on the client side,

00:14:09.150 --> 00:14:15.050
because when I remove a type,
I'm actually allowing some

00:14:15.050 --> 00:14:17.350
room for me to fetch
more places.

00:14:17.350 --> 00:14:23.400
So, say that I'm doing a search
on a high-density area,

00:14:23.400 --> 00:14:30.930
or maybe a bigger radius, when
you have more than actually 20

00:14:30.930 --> 00:14:34.810
local listings, a lot of places
will be dropped from

00:14:34.810 --> 00:14:35.820
the results.

00:14:35.820 --> 00:14:38.220
But if you're interested just in
bars, then you're going to

00:14:38.220 --> 00:14:39.710
get much more bars back.

00:14:46.650 --> 00:14:50.780
And it's similar if you're
using the web service.

00:14:50.780 --> 00:14:54.360
So you provide the types on the
type parameter, and you

00:14:54.360 --> 00:14:57.640
use a type separator
between the types.

00:14:57.640 --> 00:15:08.220
I'm just going to show you, if
I do a search, that's what I

00:15:08.220 --> 00:15:11.050
get back if I search
in New York.

00:15:11.050 --> 00:15:18.680
So what I have here, this is a
bit of bash magic because I'm

00:15:18.680 --> 00:15:22.650
running a graph and just getting
the types of names of

00:15:22.650 --> 00:15:25.690
each of the places that I get
back from the Places API.

00:15:25.690 --> 00:15:28.470
So you see, I get neighborhoods,
stores,

00:15:28.470 --> 00:15:33.460
university, lodging,
establishment, restaurants.

00:15:33.460 --> 00:15:39.450
If I do the same search, but
now you can see that I'm

00:15:39.450 --> 00:15:44.030
asking just for restaurants
back, I get the same number of

00:15:44.030 --> 00:15:47.255
results, but now all that
I get is restaurants.

00:15:51.530 --> 00:15:54.110
And if I do the same search but
now instead of restaurants

00:15:54.110 --> 00:15:55.590
I use food--

00:15:55.590 --> 00:15:58.000
remember the hierarchy
that we had?

00:15:58.000 --> 00:16:03.345
So food is a common parent
between restaurants and bars.

00:16:06.660 --> 00:16:12.320
So now you see that, in addition
to restaurants, I got

00:16:12.320 --> 00:16:14.730
a grocery shop.

00:16:14.730 --> 00:16:19.990
That's because it's also
a food establishment.

00:16:32.370 --> 00:16:34.210
So maybe I can skip this
because most of you are

00:16:34.210 --> 00:16:39.770
thinking of using the JS API,
but the idea is that if you're

00:16:39.770 --> 00:16:43.290
working on a native client, you
probably won't be sending

00:16:43.290 --> 00:16:46.610
a request directly from the
client to the Places API.

00:16:46.610 --> 00:16:50.270
You'd be proxied via
your server.

00:16:50.270 --> 00:16:53.320
Actually, even if you're
using the JS API--

00:16:53.320 --> 00:16:55.330
no, maybe not.

00:16:55.330 --> 00:16:57.890
But the idea is that your client
will send a request to

00:16:57.890 --> 00:17:00.460
the server, the server will
process the request, probably

00:17:00.460 --> 00:17:02.905
authenticate the user, and then
translate that request

00:17:02.905 --> 00:17:06.280
into a Places API request,
send it to the API.

00:17:06.280 --> 00:17:10.380
When you get the response back
from the API, it's going to

00:17:10.380 --> 00:17:15.109
augment the results, adding in
some content, and then send it

00:17:15.109 --> 00:17:18.859
back to your client.

00:17:18.859 --> 00:17:20.950
So the other reason that you do
this is that you don't want

00:17:20.950 --> 00:17:25.310
your API key to be installed
on the client,

00:17:25.310 --> 00:17:27.060
for security reasons.

00:17:27.060 --> 00:17:29.180
So that would only exist
in your server.

00:17:34.300 --> 00:17:40.000
Place Details: So if you
remember when I told you what

00:17:40.000 --> 00:17:44.030
are the attributes that come
back with a search result,

00:17:44.030 --> 00:17:46.580
that's not all the data that
we know about a place.

00:17:46.580 --> 00:17:48.510
So you can use the Place
Details request

00:17:48.510 --> 00:17:50.970
to fetch more data.

00:17:50.970 --> 00:17:55.800
And we actually plan to be
adding more stuff with time to

00:17:55.800 --> 00:17:57.010
the Place results.

00:17:57.010 --> 00:17:59.370
And we imagine that the results
are going to get

00:17:59.370 --> 00:18:03.400
longer and longer and longer, so
it's not really a good idea

00:18:03.400 --> 00:18:06.570
to be stuffing all that data
into the search result.

00:18:09.970 --> 00:18:17.900
So, the demo again, I click
on the listing.

00:18:17.900 --> 00:18:24.330
I'm sending a request to the
API and getting the Place

00:18:24.330 --> 00:18:25.610
Details back.

00:18:25.610 --> 00:18:26.860
So how do I do this?

00:18:29.590 --> 00:18:33.840
I need some form of ID
to request a Place

00:18:33.840 --> 00:18:37.290
back from the API.

00:18:37.290 --> 00:18:45.120
But when we think of
IDs, we have two

00:18:45.120 --> 00:18:48.160
expectations from IDs.

00:18:48.160 --> 00:18:51.320
The first expectation is that
you can easily recall with an

00:18:51.320 --> 00:18:59.300
ID an entry on a table, an
entry on a database.

00:18:59.300 --> 00:19:00.550
Let's call that a recall.

00:19:03.890 --> 00:19:06.145
The other purpose you would
expect from an ID is the

00:19:06.145 --> 00:19:10.700
ability to tell these two
entries are related, are the

00:19:10.700 --> 00:19:14.920
same without having to actually
compare each of the

00:19:14.920 --> 00:19:18.640
rules, each of the columns
in the row.

00:19:18.640 --> 00:19:19.890
We call that identity.

00:19:26.100 --> 00:19:30.130
The thing is, our index of
places is not really a

00:19:30.130 --> 00:19:32.520
conventional database.

00:19:32.520 --> 00:19:35.800
It's not just places
in a table.

00:19:35.800 --> 00:19:40.430
Google is constantly improving
its knowledge of the world.

00:19:40.430 --> 00:19:42.200
And because of that,
there's a lot of

00:19:42.200 --> 00:19:44.350
instability at the margins.

00:19:44.350 --> 00:19:49.010
So we discover new places, new
places actually come into

00:19:49.010 --> 00:19:52.475
existence, places may
shut down, or may

00:19:52.475 --> 00:19:53.725
fall off our indexes.

00:19:56.540 --> 00:19:59.300
There's a lot of overclustering
and

00:19:59.300 --> 00:20:00.470
underclustering.

00:20:00.470 --> 00:20:05.150
That means that there can be two
different places that show

00:20:05.150 --> 00:20:06.930
up in our index as
a single one--

00:20:06.930 --> 00:20:08.460
that's overclustering.

00:20:08.460 --> 00:20:12.950
Or there can also be a single
place that shows up that's two

00:20:12.950 --> 00:20:15.590
individual entries on
the index-- that's

00:20:15.590 --> 00:20:17.800
underclustering.

00:20:17.800 --> 00:20:22.210
So they cause a lot of ID
fluctuation at the margins.

00:20:22.210 --> 00:20:26.200
And although it's not very
likely to impact the place

00:20:26.200 --> 00:20:29.770
that we really care about, that
people engage with, we

00:20:29.770 --> 00:20:34.340
had to design our API in a way
that it could deal with that

00:20:34.340 --> 00:20:35.870
kind of instability.

00:20:35.870 --> 00:20:41.630
So what we did is we actually
split the two concepts into

00:20:41.630 --> 00:20:45.800
two separate entities
for each place.

00:20:45.800 --> 00:20:46.830
One we call reference.

00:20:46.830 --> 00:20:48.690
That's where we call from.

00:20:48.690 --> 00:20:49.990
And the other one we call ID.

00:20:49.990 --> 00:20:52.640
That's what you use when you
want to infer identity.

00:20:55.620 --> 00:20:57.650
So use references whenever
you're referencing a

00:20:57.650 --> 00:21:00.050
place on the API.

00:21:00.050 --> 00:21:02.350
It's optimized for recall.

00:21:02.350 --> 00:21:07.010
But It's very likely that it's
going to still be returning

00:21:07.010 --> 00:21:10.450
the same place a
year from now.

00:21:10.450 --> 00:21:13.050
But you cannot use it
as a key, and I'll

00:21:13.050 --> 00:21:14.300
show you why here.

00:21:19.860 --> 00:21:23.900
So with a bit of bash magic
here, this thing requests

00:21:23.900 --> 00:21:27.870
twice for a Subway.

00:21:27.870 --> 00:21:31.310
And you see that on each
request, it returned me a

00:21:31.310 --> 00:21:33.290
different reference.

00:21:33.290 --> 00:21:35.770
So if I was to use that
reference to tell if that

00:21:35.770 --> 00:21:39.540
place is the same, you would
conclude that no, it's not.

00:21:43.700 --> 00:21:45.920
On the other hand,
we have IDs.

00:21:45.920 --> 00:21:48.570
IDs are used to infer
identities, so to tell if two

00:21:48.570 --> 00:21:50.520
places are the same.

00:21:50.520 --> 00:21:55.060
It's optimized for stability,
but it cannot be used as a

00:21:55.060 --> 00:21:57.650
handle, cannot be used as a
reference anywhere in API.

00:21:57.650 --> 00:22:01.080
There's no entrypoint on the API
that you can pass an ID to

00:22:01.080 --> 00:22:03.870
get a Place back.

00:22:03.870 --> 00:22:09.520
And if I go back and I run this
same example for IDs,

00:22:09.520 --> 00:22:10.960
you'll see that IDs come first,

00:22:10.960 --> 00:22:12.210
between the two requests.

00:22:23.690 --> 00:22:26.450
You're going to see references
and IDs everywhere in the API.

00:22:26.450 --> 00:22:29.370
Whenever you get a Place result
back, you're going to

00:22:29.370 --> 00:22:32.180
also get a reference
and an ID.

00:22:32.180 --> 00:22:35.610
When you add a Place, you get
a reference and an ID.

00:22:35.610 --> 00:22:39.510
Suggest gives you back
references and IDs.

00:22:39.510 --> 00:22:42.460
And you can think of them
as the Places API ID.

00:22:48.720 --> 00:22:53.090
So how do you issue a Place
Request using the JS API?

00:22:53.090 --> 00:22:58.400
Again, use the PlacesService
object, and you call the

00:22:58.400 --> 00:23:00.870
getDetails method on it.

00:23:00.870 --> 00:23:03.280
That's in the request.
In this case, all the

00:23:03.280 --> 00:23:04.530
request has is a reference.

00:23:08.650 --> 00:23:12.920
And I'm using the Reference
Property on the Place.

00:23:12.920 --> 00:23:18.310
The Callback function takes a
Place in the response status.

00:23:18.310 --> 00:23:22.040
And what I'm doing, the demo
was just using the Place to

00:23:22.040 --> 00:23:25.790
populate the attributes
on the div.

00:23:34.260 --> 00:23:38.650
If you use the web service,
similar fashion.

00:23:38.650 --> 00:23:43.900
The endpoint is Maps API Place
Details, either JSON or XML,

00:23:43.900 --> 00:23:47.980
and the only parameter
is reference.

00:23:52.930 --> 00:23:59.490
Just XML output, for a change,
it is exactly the same

00:23:59.490 --> 00:24:04.010
structure as the JSON output,
it just uses the XML syntax.

00:24:10.090 --> 00:24:12.660
So as I said, the PlaceResult,
when it comes back from Place

00:24:12.660 --> 00:24:16.160
Details, has more meat.

00:24:16.160 --> 00:24:21.190
So, for instance, you get a
phone number, you get a

00:24:21.190 --> 00:24:24.510
rating, you get a
Place page URL.

00:24:24.510 --> 00:24:29.020
You can go to the Reference doc
to get a full reference.

00:24:34.920 --> 00:24:37.700
So now we're going
to the real-time

00:24:37.700 --> 00:24:39.090
capabilities of the API.

00:24:41.860 --> 00:24:43.690
So they deal with the real-time
capabilities to

00:24:43.690 --> 00:24:47.280
allow you to somewhat customize
the results that you

00:24:47.280 --> 00:24:50.020
get back from the API.

00:24:50.020 --> 00:24:55.100
All real-time functions are
restricted to your app.

00:24:55.100 --> 00:24:58.920
So whenever you do a check-in,
whenever you add a Place or

00:24:58.920 --> 00:25:01.290
you delete a Place, you are
only really affecting the

00:25:01.290 --> 00:25:04.720
results that your
app gets back.

00:25:04.720 --> 00:25:08.290
So the reason for that is what
is relevant to my application

00:25:08.290 --> 00:25:10.040
may not be relevant
your application.

00:25:10.040 --> 00:25:14.870
And also, we want to protect
you from spammy apps.

00:25:22.820 --> 00:25:26.260
So the first feature
is check-in.

00:25:26.260 --> 00:25:30.010
So what the check-in is, is
an anonymous relevance

00:25:30.010 --> 00:25:31.730
signal to the API.

00:25:31.730 --> 00:25:37.120
Because the API is not end-user
authenticated, we

00:25:37.120 --> 00:25:40.890
have no notion of what user is
actually sending the check-in

00:25:40.890 --> 00:25:44.270
to us, and we don't
really care.

00:25:44.270 --> 00:25:50.670
The semantics, we don't have
explicit semantics through the

00:25:50.670 --> 00:25:54.350
check-in, so it's up to your app
to decide what that means.

00:25:54.350 --> 00:25:57.080
If you're writing a check-in
app, it's maybe your user

00:25:57.080 --> 00:26:01.370
telling your application,
hey, I'm here.

00:26:01.370 --> 00:26:05.160
Or if you have more of a
recommendation kind of app,

00:26:05.160 --> 00:26:09.960
it's probably your user telling
your application, hey,

00:26:09.960 --> 00:26:12.570
I found what I'm looking for.

00:26:12.570 --> 00:26:16.150
So it affects the ranking
in real time.

00:26:16.150 --> 00:26:19.820
Of course, we have only the
first implementation of

00:26:19.820 --> 00:26:22.180
real-time ranking.

00:26:22.180 --> 00:26:26.460
And as we get more data from
actual usage, we plan to

00:26:26.460 --> 00:26:27.280
improve on that.

00:26:27.280 --> 00:26:28.890
And we have a lot of ideas.

00:26:28.890 --> 00:26:36.120
So the idea is eventually it
should be able to tell a

00:26:36.120 --> 00:26:38.800
coffee shop from a night
club, if they're next

00:26:38.800 --> 00:26:40.660
door to each other.

00:26:40.660 --> 00:26:44.140
During the day, you're going to
probably be checking into

00:26:44.140 --> 00:26:45.800
the coffee shop, and during
the night, you're probably

00:26:45.800 --> 00:26:47.050
checking into the night club.

00:26:51.580 --> 00:26:57.330
So the check-in is actually not
available for the JS API

00:26:57.330 --> 00:26:58.820
because the JS API
doesn't have a

00:26:58.820 --> 00:27:03.080
notion off an app, right?

00:27:03.080 --> 00:27:05.780
So if you want to use check-in,
you're going to have

00:27:05.780 --> 00:27:09.160
to use the web service.

00:27:09.160 --> 00:27:11.820
And also, it's worth mentioning
that if you're not

00:27:11.820 --> 00:27:14.680
using the web service, the
check-in won't affect the

00:27:14.680 --> 00:27:19.290
results you get back from
using the JS API.

00:27:19.290 --> 00:27:21.870
So because you're actually
writing to your database,

00:27:21.870 --> 00:27:23.990
you're required to
use a POST method

00:27:23.990 --> 00:27:26.670
instead of a GET method.

00:27:26.670 --> 00:27:30.740
And what you're providing the
POST, in the body of the

00:27:30.740 --> 00:27:33.100
request, is just the reference
of the place you want to

00:27:33.100 --> 00:27:34.350
check-in to.

00:27:36.560 --> 00:27:43.200
So this is a check-in request,
and this is all

00:27:43.200 --> 00:27:44.580
you get back always.

00:27:48.670 --> 00:27:51.630
So all I'm providing here is
the reference of a Place.

00:27:59.010 --> 00:28:02.505
The XML endpoint works the same
way, and you also have to

00:28:02.505 --> 00:28:15.730
use XML syntax on the
body of the request.

00:28:15.730 --> 00:28:18.670
So the second real-time feature
that we have is the

00:28:18.670 --> 00:28:22.970
ability to add a Place.

00:28:22.970 --> 00:28:26.100
So they used to allow users
and admins to add missing

00:28:26.100 --> 00:28:27.520
Places on the fly.

00:28:27.520 --> 00:28:29.810
It really depends on your policy
of your app, if you're

00:28:29.810 --> 00:28:32.490
going to give that functionality
directly to your

00:28:32.490 --> 00:28:37.060
users, or if you're going to
take it on yourself to be

00:28:37.060 --> 00:28:41.510
adding the missing Places as
maybe users report, or your

00:28:41.510 --> 00:28:47.090
customers claim their business
into your app.

00:28:47.090 --> 00:28:50.810
It shows up in the results
immediately, and the users can

00:28:50.810 --> 00:28:52.700
engage with it straight away.

00:28:52.700 --> 00:28:58.250
So that means that if a user is
trying to check into a bar,

00:28:58.250 --> 00:29:02.690
it doesn't show up in the
application, he adds it into

00:29:02.690 --> 00:29:04.050
your database.

00:29:04.050 --> 00:29:06.940
His friend, right next to him,
can do a search right away,

00:29:06.940 --> 00:29:10.500
and it will return his search
results, and he'll be

00:29:10.500 --> 00:29:11.750
able to check in.

00:29:18.260 --> 00:29:23.530
Again, it's only available
via the web service.

00:29:23.530 --> 00:29:28.140
The endpoint is the Maps
API Place Add.

00:29:28.140 --> 00:29:30.790
And you provide all the
data about a place

00:29:30.790 --> 00:29:32.180
in the request body.

00:29:35.200 --> 00:29:40.770
We accept name, location,
accuracy of the location, and

00:29:40.770 --> 00:29:43.590
a single type, actually,
for the Place.

00:29:43.590 --> 00:29:44.860
And all those are required.

00:29:47.380 --> 00:29:57.090
So, just to show you here,
I'll add a taco place.

00:29:57.090 --> 00:30:00.480
So see that I get back the
response status, a

00:30:00.480 --> 00:30:01.730
reference, and an ID.

00:30:04.185 --> 00:30:05.435
[TYPING]

00:30:11.440 --> 00:30:14.510
So I added the two Places, so
I got a different reference

00:30:14.510 --> 00:30:15.760
and a different ID.

00:30:18.000 --> 00:30:19.340
And now I'll do a search.

00:30:25.240 --> 00:30:33.190
So because I've added the LatLng
1, 1, there's nothing

00:30:33.190 --> 00:30:36.780
else, apart from those Places
I've just added, but you see

00:30:36.780 --> 00:30:39.290
they come back straight away.

00:30:39.290 --> 00:30:41.412
Let me just add one more.

00:30:41.412 --> 00:30:42.662
[TYPING]

00:30:52.840 --> 00:30:54.090
There it is.

00:31:03.060 --> 00:31:06.520
The same way that you can add
a Place, you can also delete

00:31:06.520 --> 00:31:09.030
it from your database.

00:31:09.030 --> 00:31:12.780
So the idea is that, if you
allow your users to add a

00:31:12.780 --> 00:31:16.360
Place, they may add spam, or
they may add stuff that isn't

00:31:16.360 --> 00:31:21.880
really relevant to your app,
or use abusive words.

00:31:21.880 --> 00:31:23.390
So you have the ability
to remove

00:31:23.390 --> 00:31:25.480
them from your database.

00:31:25.480 --> 00:31:28.680
Again, all you need is a
reference, and what I'll do

00:31:28.680 --> 00:31:33.380
here, I'll copy the reference
for the pizza place.

00:31:37.780 --> 00:31:41.025
And adhere to the delete
request. It's deleted.

00:31:44.010 --> 00:31:47.780
I'll search, it no
longer shows up.

00:31:47.780 --> 00:31:54.350
If I tried to do it again, it
doesn't find a Place, as you

00:31:54.350 --> 00:31:55.600
would expect.

00:31:58.460 --> 00:32:01.150
So last but not least,
we have autocomplete.

00:32:08.370 --> 00:32:09.915
So, seeing them all again--

00:32:12.680 --> 00:32:15.020
so I'll just call your attention
here to the fact

00:32:15.020 --> 00:32:24.460
that it highlights the match
between the user input and the

00:32:24.460 --> 00:32:25.170
suggestion.

00:32:25.170 --> 00:32:26.420
[TYPING]

00:32:38.910 --> 00:32:51.220
Also, the fact that it biases
the results, so I have to type

00:32:51.220 --> 00:32:53.560
a bit more to get
back to Brazil.

00:32:53.560 --> 00:32:57.620
But if I try it from here, from
the B, it is my first

00:32:57.620 --> 00:32:58.870
suggestion.

00:33:04.260 --> 00:33:05.150
And how do you use this?

00:33:05.150 --> 00:33:07.620
It's actually really easy.

00:33:07.620 --> 00:33:14.260
On the JS, you declare
text input field.

00:33:17.290 --> 00:33:22.990
You then, on JavaScript, get a
handle to that element, and

00:33:22.990 --> 00:33:25.360
that's your element in the
construction to the

00:33:25.360 --> 00:33:26.610
autocomplete object.

00:33:29.510 --> 00:33:31.860
And you're done.

00:33:31.860 --> 00:33:34.360
Actually, not quite, but you
already start getting all

00:33:34.360 --> 00:33:35.830
suggestions, right?

00:33:35.830 --> 00:33:39.790
And then, when the user selects
a Place, an event

00:33:39.790 --> 00:33:42.670
called PlaceChanged
will be triggered.

00:33:42.670 --> 00:33:47.380
And you can listen to that
event, and maybe update them

00:33:47.380 --> 00:33:51.290
at viewport or do whatever you
want with the Place data.

00:33:51.290 --> 00:33:56.510
So when you call control
getPlace, when you get back

00:33:56.510 --> 00:34:03.140
the Place results, just in the
same way as you got when you

00:34:03.140 --> 00:34:06.490
issued up a getDetails request.
So it has all the

00:34:06.490 --> 00:34:11.480
information like the name,
full address, a strict

00:34:11.480 --> 00:34:14.000
address, icon, so
on and so forth.

00:34:20.330 --> 00:34:23.580
So what I'm doing here with the
Place is I'm updating the

00:34:23.580 --> 00:34:24.940
map viewport.

00:34:24.940 --> 00:34:28.580
So I call this map.fitBounds.

00:34:28.580 --> 00:34:30.500
That's in the Place viewport.

00:34:33.320 --> 00:34:36.260
But some places do not have a
viewport, so what I do is I

00:34:36.260 --> 00:34:39.130
use the location.

00:34:39.130 --> 00:34:41.530
And I used the fixed
zoom level.

00:34:48.330 --> 00:34:51.239
So the bounds of the
autocomplete is what the

00:34:51.239 --> 00:34:56.440
bounds use to bias
the suggestions.

00:34:56.440 --> 00:35:02.360
And here I'm listening to the
map's bounds_changed event to

00:35:02.360 --> 00:35:04.730
call control the set bounds.

00:35:04.730 --> 00:35:07.950
So it couldn't be any
easier than this.

00:35:13.950 --> 00:35:18.630
If you're writing a native app
and you also want to deploy

00:35:18.630 --> 00:35:23.470
autocomplete into it, there is
also an HTTP web service.

00:35:23.470 --> 00:35:28.910
So maps/api/place/autocomplete
endpoint and you'll set the

00:35:28.910 --> 00:35:32.190
two arguments: one is
the partial user

00:35:32.190 --> 00:35:35.146
input, and the bounds.

00:35:35.146 --> 00:35:36.396
[TYPING]

00:35:41.950 --> 00:35:49.540
So I have one more demo here.

00:35:49.540 --> 00:35:53.500
And it's the Suggest
autocomplete.

00:35:59.810 --> 00:36:01.060
Come on!

00:36:01.060 --> 00:36:07.100
So you've seen me using curl
in the line, so that's a

00:36:07.100 --> 00:36:11.090
really useful way to experiment
with APIs if you

00:36:11.090 --> 00:36:16.350
somehow pull the Places API key,
you can just go in any

00:36:16.350 --> 00:36:19.980
shell and start playing
with it using curl.

00:36:19.980 --> 00:36:25.640
And you can also use, if it's
just a GET method, like for

00:36:25.640 --> 00:36:30.930
search, or detail request, or
autosuggest, autocomplete, you

00:36:30.930 --> 00:36:34.650
can just use a browser.

00:36:34.650 --> 00:36:38.140
So if you look at what an
autocomplete response looks

00:36:38.140 --> 00:36:44.070
like, it has description, which
is what we're showing

00:36:44.070 --> 00:36:52.360
for the user, it has a list of
types, a reference, an ID, and

00:36:52.360 --> 00:36:58.740
then it has a list of terms
which break down the

00:36:58.740 --> 00:36:59.990
description.

00:37:02.260 --> 00:37:09.580
And then there's also a list
of matched substrings.

00:37:09.580 --> 00:37:13.380
So the matched substrings are
what we use to highlight where

00:37:13.380 --> 00:37:18.780
the user input matches the
autocomplete suggestion.

00:37:18.780 --> 00:37:22.760
And that's not as trivial as it
sounds because sometimes,

00:37:22.760 --> 00:37:25.770
if you try doing just a search,
it won't match.

00:37:25.770 --> 00:37:32.010
For instance, if you search
for Sao Paolo, you've got

00:37:32.010 --> 00:37:37.550
graphic accents on the name of
the city, so you don't need to

00:37:37.550 --> 00:37:40.000
type the graphic accent, and but
the suggestion does come

00:37:40.000 --> 00:37:41.250
back with an accent.

00:37:55.390 --> 00:37:56.640
So that's what I
had for today.

00:37:59.500 --> 00:38:06.310
The takeaway we want you guys
to take from here is the

00:38:06.310 --> 00:38:07.370
Places API.

00:38:07.370 --> 00:38:11.220
It's a service that provides
you advanced local search

00:38:11.220 --> 00:38:16.950
services, gives developers
access to Google's super

00:38:16.950 --> 00:38:21.290
comprehensive and massive
database of places.

00:38:21.290 --> 00:38:26.290
You can access it via the web
service interface or a

00:38:26.290 --> 00:38:28.680
JavaScript API.

00:38:28.680 --> 00:38:32.150
It's still in Labs, which means
that we're constantly

00:38:32.150 --> 00:38:39.340
working to improve it and make
it more useful and usable.

00:38:39.340 --> 00:38:41.760
So we need your feedback.

00:38:41.760 --> 00:38:46.540
Sign up, try it out, tell
us what you think.

00:38:46.540 --> 00:38:50.820
And now, Yoni is going
to tell you about his

00:38:50.820 --> 00:38:54.550
experience using the API.

00:38:54.550 --> 00:38:55.800
[APPLAUSE]

00:38:58.924 --> 00:39:03.320
YONI SAMLAN: Thanks, Marcelo.

00:39:03.320 --> 00:39:04.110
My name is Yoni.

00:39:04.110 --> 00:39:07.185
I'm the lead Android developer
at SCVNGR, and I'm just going

00:39:07.185 --> 00:39:09.200
to talk to you really quickly
about our experiences

00:39:09.200 --> 00:39:13.270
integrating the Places
API into SCVNGR.

00:39:13.270 --> 00:39:15.430
First off, quick intro:
what's SCVNGR?

00:39:15.430 --> 00:39:18.850
SCVNGR is a game that you play
from your Android device, or

00:39:18.850 --> 00:39:22.320
iPhone, if you really insist.
It's about going places, doing

00:39:22.320 --> 00:39:25.200
challenges, and earning points,
badges, and even

00:39:25.200 --> 00:39:28.370
real-world rewards
for playing.

00:39:28.370 --> 00:39:31.600
We were one of the larger early
partners to integrate

00:39:31.600 --> 00:39:32.820
with the Places API.

00:39:32.820 --> 00:39:35.050
When we first started
last year, we had

00:39:35.050 --> 00:39:37.400
over 500,000 users.

00:39:37.400 --> 00:39:40.630
Now we're almost at 1.5 million,
and growing quickly.

00:39:40.630 --> 00:39:42.980
So we were outgrowing our
existing solution, which was

00:39:42.980 --> 00:39:46.430
based on GeoAPI, which is now
part of the Twitter API, and

00:39:46.430 --> 00:39:49.210
sort of killed off quietly as
part of that, at least for

00:39:49.210 --> 00:39:51.100
public usage.

00:39:51.100 --> 00:39:53.790
So we needed a solution that
would scale up with us, and we

00:39:53.790 --> 00:39:56.700
also have a lot of businesses
that rely on us to engage with

00:39:56.700 --> 00:39:57.580
their customers.

00:39:57.580 --> 00:40:00.300
A recent Buffalo Wild Wings
campaign we ran earlier this

00:40:00.300 --> 00:40:06.620
year was at 780 locations with
180,000 players completing

00:40:06.620 --> 00:40:08.980
over 1.2 million challenges.

00:40:08.980 --> 00:40:11.240
So we needed a solution that
could scale up to that sort of

00:40:11.240 --> 00:40:15.140
size and have the accuracy to
work with a good list of

00:40:15.140 --> 00:40:17.220
places to go forward with.

00:40:17.220 --> 00:40:21.090
So we turned to Google and
the Places API for that.

00:40:21.090 --> 00:40:23.450
So what's it really like,
getting started?

00:40:23.450 --> 00:40:25.900
The answer is today, actually
really easy.

00:40:25.900 --> 00:40:28.130
As Marcelo showed you, really
all you need is curl and an

00:40:28.130 --> 00:40:29.860
API key and you can get going.

00:40:29.860 --> 00:40:32.830
Almost all the data you need
to get started building a

00:40:32.830 --> 00:40:35.380
location-based app you can get
from just one or two of those

00:40:35.380 --> 00:40:37.306
API endpoints.

00:40:37.306 --> 00:40:39.630
So that's really great,
especially if you're getting

00:40:39.630 --> 00:40:40.380
started today.

00:40:40.380 --> 00:40:43.800
It'll be really easy for you.

00:40:43.800 --> 00:40:45.490
There are a few little
gotchas--

00:40:45.490 --> 00:40:47.720
things that you might run
across, patricularly as you

00:40:47.720 --> 00:40:50.590
get ready to actually ship your
app into the real world.

00:40:50.590 --> 00:40:53.370
The ID versus references
difference that Marcelo

00:40:53.370 --> 00:40:54.540
covered is one of
those things.

00:40:54.540 --> 00:40:56.250
So be aware of that.

00:40:56.250 --> 00:41:00.320
And also, there is an API
request limit, it's 1,000 by

00:41:00.320 --> 00:41:02.800
default, per day.

00:41:02.800 --> 00:41:06.480
So before you launch your hot,
stealth-mode startup out into

00:41:06.480 --> 00:41:09.070
the world, make sure you
authenticate yourself to get

00:41:09.070 --> 00:41:12.510
bumped up to 100,000 a day,
which is very easy to do, it

00:41:12.510 --> 00:41:15.430
doesn't cost any money, and will
definitely save you some

00:41:15.430 --> 00:41:19.650
headaches that you would have
if you forgot to do that.

00:41:19.650 --> 00:41:22.510
And also attributions,
particularly the Places

00:41:22.510 --> 00:41:26.460
database has really good data
for especially non-US

00:41:26.460 --> 00:41:29.650
locations, where a lot of other
services fall flat, but

00:41:29.650 --> 00:41:32.330
they do have a bit of data
that comes back called

00:41:32.330 --> 00:41:34.950
attributions that you have to
show your users, which is

00:41:34.950 --> 00:41:37.710
where that data is
sourced from.

00:41:37.710 --> 00:41:40.080
That also applies to mobile
clients, so don't be stuck

00:41:40.080 --> 00:41:42.400
scrambling to update your iPhone
and Android clients

00:41:42.400 --> 00:41:44.060
last minute before
launch with that.

00:41:44.060 --> 00:41:46.710
Be aware of that from
the outset.

00:41:46.710 --> 00:41:48.040
But those are really
little things.

00:41:48.040 --> 00:41:50.850
The bottom line is what happens
when you move to the

00:41:50.850 --> 00:41:51.910
Places API?

00:41:51.910 --> 00:41:54.800
For us, it was a
win all around.

00:41:54.800 --> 00:41:56.910
Uncached place listing
requests--

00:41:56.910 --> 00:41:58.370
what are the places near me--

00:41:58.370 --> 00:42:00.170
for us, sped up about
three times.

00:42:00.170 --> 00:42:03.840
Mostly because we were able to
replace a lot of areas where

00:42:03.840 --> 00:42:07.230
we had to make multiple API
calls to remote services with

00:42:07.230 --> 00:42:10.760
just one call to the Places
API, which was great.

00:42:10.760 --> 00:42:12.020
The data's a lot
more complete.

00:42:12.020 --> 00:42:15.160
We found that the ratio of users
adding places versus

00:42:15.160 --> 00:42:18.720
visits went down by about 40%,
meaning that users were just

00:42:18.720 --> 00:42:21.190
finding the places they were
looking for more often without

00:42:21.190 --> 00:42:23.790
having to go through the kind
of painful manual process of

00:42:23.790 --> 00:42:27.160
typing in a place from scratch,
which is really good,

00:42:27.160 --> 00:42:29.460
especially for mobile
applications.

00:42:29.460 --> 00:42:32.530
And finally, and probably
hardest to quantify, the data

00:42:32.530 --> 00:42:33.610
is just cleaner.

00:42:33.610 --> 00:42:36.150
We have a lot less of a problem
with junk data,

00:42:36.150 --> 00:42:39.370
duplicate places, old places
that aren't around anymore.

00:42:39.370 --> 00:42:41.580
And we don't have to go through
a process we used to

00:42:41.580 --> 00:42:44.600
have to go through to remove
spam places-- especially spam

00:42:44.600 --> 00:42:46.320
locksmiths, for some reason--

00:42:46.320 --> 00:42:48.085
that were in a lot of
our other data sets.

00:42:48.085 --> 00:42:50.840
So that was great.

00:42:50.840 --> 00:42:53.370
And I'll leave you with just a
few of the features that are

00:42:53.370 --> 00:42:56.570
new to the API versus what was
there last year, that I'm most

00:42:56.570 --> 00:42:58.530
excited about as a developer.

00:42:58.530 --> 00:43:00.130
First of all, that check-ins
matter now.

00:43:00.130 --> 00:43:03.320
When you post a check-in back to
the Places API, that's used

00:43:03.320 --> 00:43:06.490
for adjusting the rankings of
those Places short term.

00:43:06.490 --> 00:43:08.980
So if we're running a promotion,
for example, with

00:43:08.980 --> 00:43:12.970
Toscanini's, an ice cream shop
in Cambridge, Toscanini's will

00:43:12.970 --> 00:43:15.480
rise up in the rankings while
that promotion or that event

00:43:15.480 --> 00:43:18.570
is going on, with no manual
intervention necessary on our

00:43:18.570 --> 00:43:21.890
part just because our users
are checking in there.

00:43:21.890 --> 00:43:25.090
And then once they're done,
once that event is over,

00:43:25.090 --> 00:43:27.680
Toscanini's will fall back to
its normal ranking, although

00:43:27.680 --> 00:43:29.980
probably not quite that, because
it'll inherently be

00:43:29.980 --> 00:43:34.210
more popular because
of our event there.

00:43:34.210 --> 00:43:35.720
And the second thing I'm
pretty excited about is

00:43:35.720 --> 00:43:36.960
instant Place adds.

00:43:36.960 --> 00:43:40.400
With most other Place APIs, and
the old way it worked on

00:43:40.400 --> 00:43:44.880
the Google Places API, if your
users reported a new place

00:43:44.880 --> 00:43:48.290
that was missing from the
database, you'd have to either

00:43:48.290 --> 00:43:50.130
tell that user that they
couldn't do anything there

00:43:50.130 --> 00:43:53.130
until it's approved, or you'd
have to keep a local copy of

00:43:53.130 --> 00:43:55.530
that place and merge it with the
data coming back from the

00:43:55.530 --> 00:43:58.500
remote API, and then once it
got approved on the remote

00:43:58.500 --> 00:44:01.120
end, you'd have to go through
some sort of de-duplication

00:44:01.120 --> 00:44:02.520
process and move all
the activity

00:44:02.520 --> 00:44:03.520
over to the new place.

00:44:03.520 --> 00:44:05.080
You don't have to
do that anymore.

00:44:05.080 --> 00:44:09.140
The results come back your app
now instantly, and eventually

00:44:09.140 --> 00:44:11.370
they'll get approved for
everybody else using the APIs,

00:44:11.370 --> 00:44:13.100
which is really nice and
means a lot less

00:44:13.100 --> 00:44:15.660
bookkeeping for you.

00:44:15.660 --> 00:44:18.750
And the bottom line is, by
moving to the Places API,

00:44:18.750 --> 00:44:21.680
we've improved the experience
for our end users, for our

00:44:21.680 --> 00:44:24.080
business clients, and it's made
life easier for us as

00:44:24.080 --> 00:44:24.720
developers.

00:44:24.720 --> 00:44:27.470
And at the end of the day, it
means everybody can spend less

00:44:27.470 --> 00:44:29.350
time tweaking lists
of locations

00:44:29.350 --> 00:44:30.510
and more time playing.

00:44:30.510 --> 00:44:33.250
And really, that's what
it's all about.

00:44:33.250 --> 00:44:35.720
And on that note, I'll pass
things back to Marcelo, and

00:44:35.720 --> 00:44:37.828
we'll open the floor
up to Q&amp;A.

00:44:37.828 --> 00:44:39.078
[APPLAUSE]

00:44:57.380 --> 00:45:00.720
AUDIENCE: I have a question
about the ratings and reviews.

00:45:00.720 --> 00:45:04.940
I see when I go to the
maps.google.com Places

00:45:04.940 --> 00:45:09.570
detailed result, is there any
plans to integrate that into

00:45:09.570 --> 00:45:14.120
the service, or more
detailed aggregate

00:45:14.120 --> 00:45:15.915
reviews from other places?

00:45:15.915 --> 00:45:17.840
MARCELO CAMELO: Yes there is.

00:45:17.840 --> 00:45:22.200
That's a roadmap, definitely.

00:45:22.200 --> 00:45:23.390
AUDIENCE: Is a sign-up
required for

00:45:23.390 --> 00:45:25.390
the JavaScript API?

00:45:25.390 --> 00:45:29.130
And when you do an add through
the web service API, is that

00:45:29.130 --> 00:45:35.030
added site essentially stored
underneath your key?

00:45:35.030 --> 00:45:36.790
MARCELO CAMELO: So there's no
sign-up for the JS API.

00:45:39.910 --> 00:45:43.050
And I don't know if I understood
your question, but

00:45:43.050 --> 00:45:44.900
there's no add from
the JS API.

00:45:44.900 --> 00:45:46.610
AUDIENCE: Right, but when you
use the web service and you

00:45:46.610 --> 00:45:47.710
add something--

00:45:47.710 --> 00:45:50.436
I've added it, is it cluttering
up his results?

00:45:50.436 --> 00:45:51.155
MARCELO CAMELO: No.

00:45:51.155 --> 00:45:54.560
AUDIENCE: So it's stored
underneath my key.

00:45:54.560 --> 00:45:55.810
MARCELO CAMELO: Exactly.

00:45:59.260 --> 00:46:01.830
AUDIENCE: So I think you kind
of addressed this, but the

00:46:01.830 --> 00:46:04.640
reference that comes back is
different every time you call

00:46:04.640 --> 00:46:06.990
the API, even with the
same client ID.

00:46:06.990 --> 00:46:10.730
And you mentioned that there are
times when there might be

00:46:10.730 --> 00:46:11.680
duplicates, right?

00:46:11.680 --> 00:46:13.250
Like, it's been underclustered.

00:46:13.250 --> 00:46:17.180
What happens if those two
entities get merged?

00:46:17.180 --> 00:46:22.135
MARCELO CAMELO: So both
references will now fetch the

00:46:22.135 --> 00:46:23.385
merged place.

00:46:26.120 --> 00:46:30.750
AUDIENCE: I was trying out the
autocomplete feature and I

00:46:30.750 --> 00:46:32.730
noticed that there was geocoding
that's put into it

00:46:32.730 --> 00:46:35.640
so you can actually look up
addresses as well as just

00:46:35.640 --> 00:46:37.060
Place names.

00:46:37.060 --> 00:46:38.900
One thing I was having some
trouble with, though, is that

00:46:38.900 --> 00:46:44.120
I have a service which has food
trucks as a major user of

00:46:44.120 --> 00:46:47.665
it, and they always want
to use intersections.

00:46:47.665 --> 00:46:50.230
And I didn't see that there
was any support for

00:46:50.230 --> 00:46:51.380
intersections at current.

00:46:51.380 --> 00:46:53.390
Are there plans for that?

00:46:53.390 --> 00:46:54.310
MARCELO CAMELO: No.

00:46:54.310 --> 00:46:56.150
AUDIENCE: [LAUGHTER]

00:46:56.150 --> 00:47:01.350
MARCELO CAMELO: But it's a
really interesting idea.

00:47:01.350 --> 00:47:03.220
How would you look for
an intersection?

00:47:03.220 --> 00:47:04.502
Maybe Thor knows.

00:47:04.502 --> 00:47:07.960
AUDIENCE: Because right now,
when I use the Geocode, the

00:47:07.960 --> 00:47:10.520
Geocoder has a great feature
where you just type in Fifth

00:47:10.520 --> 00:47:14.830
and Mission, and it'll turn to
Mission Avenue and Fifth

00:47:14.830 --> 00:47:16.260
Street, San Francisco,
California

00:47:16.260 --> 00:47:17.620
as one of the options.

00:47:17.620 --> 00:47:19.100
But it doesn't seem to be
that way in Places.

00:47:19.100 --> 00:47:24.430
THOR MITCHELL: I think one of
the things I kind of expect

00:47:24.430 --> 00:47:28.410
and accept that we're going to
have to say a lot over the

00:47:28.410 --> 00:47:31.610
next year is it's important
to understand that the

00:47:31.610 --> 00:47:34.150
autocomplete service
is not a Geocoder.

00:47:34.150 --> 00:47:37.670
It's not designed or intended
to be used as a Geocoder.

00:47:37.670 --> 00:47:43.000
It is designed to be used to
complete queries and to find

00:47:43.000 --> 00:47:46.100
individual places
by their name.

00:47:46.100 --> 00:47:48.510
Now, in the case of an
address object, then

00:47:48.510 --> 00:47:49.790
the name is the address.

00:47:49.790 --> 00:47:57.080
So you could enter the name of
a street and you could enter

00:47:57.080 --> 00:47:59.530
the name of a city, and even
if those two things are not

00:47:59.530 --> 00:48:02.050
next to each other in the
address, we would match it for

00:48:02.050 --> 00:48:02.750
autocomplete.

00:48:02.750 --> 00:48:04.210
That would work.

00:48:04.210 --> 00:48:07.870
But the Geocoder service, the
official one, can do other,

00:48:07.870 --> 00:48:10.750
more smart things, where its
whole purpose in life is to

00:48:10.750 --> 00:48:13.760
try and give you back a LatLng
for the query you've given us.

00:48:13.760 --> 00:48:17.140
So we'll take that query and it
will try and split it, and

00:48:17.140 --> 00:48:21.360
decompose it, and do analysis on
it to try and infer as much

00:48:21.360 --> 00:48:23.170
meaning as possible from that
query in order to give you

00:48:23.170 --> 00:48:24.040
back a LatLng.

00:48:24.040 --> 00:48:26.200
And you'll notice that the
autocomplete service does not

00:48:26.200 --> 00:48:28.280
give you back a LatLng
by design.

00:48:28.280 --> 00:48:30.330
It gives you back a reference,
which you can use to get a

00:48:30.330 --> 00:48:31.470
LatLng if you really want one.

00:48:31.470 --> 00:48:33.770
But we actually don't want to
encourage its use as an

00:48:33.770 --> 00:48:34.760
alternate Geocoder.

00:48:34.760 --> 00:48:37.510
In fact, if there are reasons
why you're finding you're

00:48:37.510 --> 00:48:40.120
getting more success in
searching the places in

00:48:40.120 --> 00:48:42.570
autocomplete than you do in the
Geocoder, then we consider

00:48:42.570 --> 00:48:44.160
that to be a bug in the
Geocoder, and we'd like to

00:48:44.160 --> 00:48:45.926
know about it.

00:48:45.926 --> 00:48:47.290
AUDIENCE: Thank you.

00:48:47.290 --> 00:48:49.120
By the way, is there any
way to supplement the

00:48:49.120 --> 00:48:51.420
autocomplete?

00:48:51.420 --> 00:48:52.960
THOR MITCHELL: What, with
your own list of--

00:48:52.960 --> 00:48:55.450
AUDIENCE: With some other API.

00:48:55.450 --> 00:49:00.460
MARCELO CAMELO: So you could,
then, if you're using the web

00:49:00.460 --> 00:49:01.210
service, right?

00:49:01.210 --> 00:49:03.910
Because you're getting
the result back.

00:49:03.910 --> 00:49:09.470
But we do have plans to allow
you to extend how both how the

00:49:09.470 --> 00:49:14.700
controls that I showed you work
and also to provide you a

00:49:14.700 --> 00:49:17.060
service inside the JS API.

00:49:17.060 --> 00:49:20.680
So you could autocomplete with
a request and then get back a

00:49:20.680 --> 00:49:25.760
list of results instead of
injecting that into a div.

00:49:29.130 --> 00:49:31.610
THOR MITCHELL: Also, I'll just
take this opportunity to say

00:49:31.610 --> 00:49:37.150
that we prioritized the control
we have at the moment

00:49:37.150 --> 00:49:38.340
or at least the feature we have
at the moment in the JS

00:49:38.340 --> 00:49:39.590
API where we actually
implement the

00:49:39.590 --> 00:49:40.840
drop-down for you.

00:49:40.840 --> 00:49:43.050
We wanted to make it as easy
as possible because we want

00:49:43.050 --> 00:49:46.280
every single field on the web
which asks someone for an

00:49:46.280 --> 00:49:48.540
address to implement
autocomplete because the world

00:49:48.540 --> 00:49:51.130
would be better for it.

00:49:51.130 --> 00:49:52.180
AUDIENCE: Hi, my
name is Thomas,

00:49:52.180 --> 00:49:52.850
and I've got a question.

00:49:52.850 --> 00:49:56.490
Who is actually meant to add or
delete the new locations?

00:49:56.490 --> 00:50:00.015
Is that the user of the
application, or who does it?

00:50:00.015 --> 00:50:03.105
MARCELO CAMELO: It really
depends on your app.

00:50:06.260 --> 00:50:09.530
You could give that power to the
user if you trust them to

00:50:09.530 --> 00:50:10.890
do with the right thing.

00:50:10.890 --> 00:50:14.600
Or, you know, crowd-sourcing
it, or you could do it like

00:50:14.600 --> 00:50:16.840
having admin people
doing it for you.

00:50:16.840 --> 00:50:19.280
THOR MITCHELL: I think a
particularly interesting

00:50:19.280 --> 00:50:23.310
question on that topic is how
do you handle deletes?

00:50:23.310 --> 00:50:26.790
I think many apps still allow
users to add places and they

00:50:26.790 --> 00:50:30.360
just assume that that place is
good, and they publish it

00:50:30.360 --> 00:50:30.830
immediately.

00:50:30.830 --> 00:50:35.305
But for deletes, you could, for
example, say, if five of

00:50:35.305 --> 00:50:37.150
my users signal to us that
this place is bad, we'll

00:50:37.150 --> 00:50:39.425
delete it just to avoid
someone just going and

00:50:39.425 --> 00:50:42.500
deleting everything.

00:50:42.500 --> 00:50:44.490
AUDIENCE: So again, this is
probably a stupid question,

00:50:44.490 --> 00:50:47.210
but so there are no rate limits
on the JavaScript

00:50:47.210 --> 00:50:49.870
version of the API?

00:50:49.870 --> 00:50:52.680
THOR MITCHELL: There are rate
limits, although we don't

00:50:52.680 --> 00:50:58.420
publish them because we don't
want to encourage people to

00:50:58.420 --> 00:51:01.460
push them and because we need
the freedom to change

00:51:01.460 --> 00:51:03.380
them or vary them.

00:51:03.380 --> 00:51:07.060
So there are rate limits that
apply per map session.

00:51:07.060 --> 00:51:11.900
There are no daily limits.

00:51:11.900 --> 00:51:15.700
Because that doesn't really
apply to maps that appear

00:51:15.700 --> 00:51:17.595
within web pages where you can
have multiple tabs for

00:51:17.595 --> 00:51:19.030
different pages open,
and so forth.

00:51:19.030 --> 00:51:21.570
AUDIENCE: So a mapping session
is some combination of IP and

00:51:21.570 --> 00:51:23.450
source URL and all
these things?

00:51:23.450 --> 00:51:26.030
THOR MITCHELL: A map session is
one single load of the Maps

00:51:26.030 --> 00:51:30.480
API regardless of how much
activity then follows.

00:51:30.480 --> 00:51:35.145
So within that, there are rate
limits that apply, but let's

00:51:35.145 --> 00:51:38.560
say they're not documented.

00:51:38.560 --> 00:51:41.160
AUDIENCE: Hi, one more question:
is there a way to

00:51:41.160 --> 00:51:45.395
get user-specific check-ins so
that I can prioritize the

00:51:45.395 --> 00:51:48.670
places that a user themself
has checked in, over just

00:51:48.670 --> 00:51:51.060
general, every place
in my app?

00:51:51.060 --> 00:51:52.700
MARCELO CAMELO: No, so, as I
said, we don't know who the

00:51:52.700 --> 00:51:55.640
user is because the user is not
authenticated with us, and

00:51:55.640 --> 00:51:58.430
there's no way for
you to tell us.

00:51:58.430 --> 00:52:01.130
So currently no.

00:52:01.130 --> 00:52:03.810
THOR MITCHELL: It's something
that we've considered and that

00:52:03.810 --> 00:52:06.600
we could implement
in the future.

00:52:06.600 --> 00:52:08.600
There are some interesting
questions around privacy that

00:52:08.600 --> 00:52:09.950
come into play at that
point when we

00:52:09.950 --> 00:52:11.465
have an explicit end-user.

00:52:11.465 --> 00:52:14.530
But, in fact, the questions
become a lot more complicated

00:52:14.530 --> 00:52:16.490
if we just have a signal as
the user, rather than

00:52:16.490 --> 00:52:18.440
actually, for example,
a Google account.

00:52:18.440 --> 00:52:20.080
At least with a Google account,
we can provide them

00:52:20.080 --> 00:52:23.260
with tools to manage the data
that we've stored and to

00:52:23.260 --> 00:52:24.680
delete the data that
we've stored.

00:52:24.680 --> 00:52:27.510
But if you're just giving us
some opaque identifier, we

00:52:27.510 --> 00:52:29.365
have information stored about
users and we can't provide

00:52:29.365 --> 00:52:33.235
them with any way to manage that
data, which isn't good.

00:52:33.235 --> 00:52:37.030
AUDIENCE: Is there a limit
on the radius?

00:52:37.030 --> 00:52:39.350
For example, if we want
to search within

00:52:39.350 --> 00:52:41.560
30 miles in a city--

00:52:41.560 --> 00:52:43.870
MARCELO CAMELO: So we're
actually working on this at

00:52:43.870 --> 00:52:47.410
the moment, and there
probably will be.

00:52:47.410 --> 00:52:51.380
AUDIENCE: But right now
there's nothing.

00:52:51.380 --> 00:52:52.925
MARCELO CAMELO: You can
assume that there is.

00:52:57.330 --> 00:53:00.290
We're still trying to
nail down a number.

00:53:00.290 --> 00:53:02.610
THOR MITCHELL: Yeah, I mean,
bear in mind, you only ever

00:53:02.610 --> 00:53:04.920
get 20 results.

00:53:04.920 --> 00:53:10.050
So the broader you search,
you're essentially--

00:53:10.050 --> 00:53:12.000
because of the way the ranking
algorithm works-- particularly

00:53:12.000 --> 00:53:14.130
in the absence of
any check-ins--

00:53:14.130 --> 00:53:16.920
we give you the top 20
places in that area.

00:53:16.920 --> 00:53:20.390
And so as that area gets bigger
and bigger, you're

00:53:20.390 --> 00:53:22.550
going to end up with just
really, really,

00:53:22.550 --> 00:53:23.770
really major landmarks.

00:53:23.770 --> 00:53:25.860
MARCELO CAMELO: Like Empire
State Building

00:53:25.860 --> 00:53:28.420
and Statue of Liberty.

00:53:28.420 --> 00:53:30.980
AUDIENCE: Oh, one more thing:
with regards to caching the

00:53:30.980 --> 00:53:35.940
information, do you guys have
any terms on that, like what

00:53:35.940 --> 00:53:36.930
we cannot do?

00:53:36.930 --> 00:53:39.310
THOR MITCHELL: We don't have
terms that are specific to the

00:53:39.310 --> 00:53:40.740
Places API.

00:53:40.740 --> 00:53:43.340
But the Maps API terms of
service, which the Places API

00:53:43.340 --> 00:53:47.640
falls under, have language
around rights to cache that,

00:53:47.640 --> 00:53:51.270
that basically say that you
can cache reasonable

00:53:51.270 --> 00:53:53.660
quantities, small quantities
of data, for performance

00:53:53.660 --> 00:53:57.630
reasons, and the reference and
IDs you're allowed to store

00:53:57.630 --> 00:53:59.040
for as long as you like.

00:53:59.040 --> 00:54:00.680
And you can always use
those to refresh

00:54:00.680 --> 00:54:03.930
cached data as well.

00:54:03.930 --> 00:54:09.070
The most important things there
are that you need to

00:54:09.070 --> 00:54:12.130
only use the data in conjunction
with the Maps API,

00:54:12.130 --> 00:54:12.960
Places API application--

00:54:12.960 --> 00:54:15.410
you can't use it outside
of an application.

00:54:15.410 --> 00:54:20.630
And if at any point you choose
to stop offering this

00:54:20.630 --> 00:54:23.950
application or switch to a
different source of Places

00:54:23.950 --> 00:54:25.319
data, then you have
to dispose of the

00:54:25.319 --> 00:54:28.500
data that you've cached.

00:54:28.500 --> 00:54:31.560
AUDIENCE: So stuff that I add
using my Add key, is that

00:54:31.560 --> 00:54:33.460
available to only my
application, or will that be

00:54:33.460 --> 00:54:34.480
available to everybody?

00:54:34.480 --> 00:54:36.810
MARCELO CAMELO: No, it's only
available to your application,

00:54:36.810 --> 00:54:38.940
only to that specifically.

00:54:38.940 --> 00:54:40.190
THOR MITCHELL: Until
it's moderated.

00:54:42.870 --> 00:54:45.720
So when you add something, it
immediately turns up in your

00:54:45.720 --> 00:54:48.640
subsequent set results, but it
does also get passed into

00:54:48.640 --> 00:54:51.410
Google's moderation pipeline for
when new Places, the same

00:54:51.410 --> 00:54:54.470
one that's used on Google maps
when you report a new place.

00:54:54.470 --> 00:54:58.860
If it gets successfully
moderated, then it will go

00:54:58.860 --> 00:55:01.330
into Google's main index and
be visible across all of

00:55:01.330 --> 00:55:04.060
Google's properties and to other
Places API applications.

00:55:04.060 --> 00:55:06.450
If it does not get successfully
moderated, it

00:55:06.450 --> 00:55:08.400
will still continue to be
available to your application.

00:55:08.400 --> 00:55:11.320
AUDIENCE: And how long does it
take for it to moderate?

00:55:11.320 --> 00:55:13.610
THOR MITCHELL: That varies.

00:55:13.610 --> 00:55:15.350
It's of the order of weeks.

00:55:15.350 --> 00:55:16.390
AUDIENCE: OK.

00:55:16.390 --> 00:55:19.360
And I understand I need to use
the Add key when I add stuff

00:55:19.360 --> 00:55:21.490
to it, but I can curate
using the

00:55:21.490 --> 00:55:22.740
JavaScript without the key?

00:55:25.120 --> 00:55:26.760
THOR MITCHELL: You don't need
a Places API key to use the

00:55:26.760 --> 00:55:31.810
JavaScript, but the JavaScript
will not return app-specific

00:55:31.810 --> 00:55:33.290
places, in other words,
places that have

00:55:33.290 --> 00:55:34.040
not yet been moderated.

00:55:34.040 --> 00:55:37.630
MARCELO CAMELO: All the
real-time features, you don't

00:55:37.630 --> 00:55:40.230
go them when you
use the JS API.

00:55:40.230 --> 00:55:41.800
AUDIENCE: OK, so there's no
way to add the key to the

00:55:41.800 --> 00:55:43.026
JavaScript API.

00:55:43.026 --> 00:55:47.605
THOR MITCHELL: No, the problem
is that because all JavaScript

00:55:47.605 --> 00:55:51.220
applications are, by definition,
publicly visible,

00:55:51.220 --> 00:55:53.650
I can just hit View Source
and wade through.

00:55:53.650 --> 00:55:55.090
Then I could find your
key very easily

00:55:55.090 --> 00:55:57.291
and just hammer it.

00:55:57.291 --> 00:55:58.975
So we didn't want
to allow that.

00:56:02.510 --> 00:56:04.030
AUDIENCE: How you guys doing?

00:56:04.030 --> 00:56:10.340
My question's on Place ID
or reference ID facets.

00:56:10.340 --> 00:56:15.030
Have you given thought to, for
example, other facets of

00:56:15.030 --> 00:56:16.760
spatial locations?

00:56:16.760 --> 00:56:21.392
One might be temporal, for
example, the definition of a

00:56:21.392 --> 00:56:25.460
spatial location may change
over time, whether or not

00:56:25.460 --> 00:56:27.860
you're going to be
storing that--

00:56:27.860 --> 00:56:28.555
first part.

00:56:28.555 --> 00:56:32.340
The second is, how immutable
are these IDs?

00:56:32.340 --> 00:56:36.180
You said earlier, for instance,
two reference IDs

00:56:36.180 --> 00:56:39.800
might get merged and point
to one specific location.

00:56:39.800 --> 00:56:43.680
So it sounds to me like if
you're issuing an ID or

00:56:43.680 --> 00:56:46.850
reference IDs that someone else
then receives, then it's

00:56:46.850 --> 00:56:49.840
more or less guaranteed to
always resolve to something

00:56:49.840 --> 00:56:52.690
once a query is made
with that ID.

00:56:52.690 --> 00:56:54.320
And then also, the
caching question.

00:56:54.320 --> 00:56:55.823
I just want to reiterate
on the caching--

00:56:58.630 --> 00:57:02.470
you're not the only place
provider, there are other

00:57:02.470 --> 00:57:07.030
people who are doing IDs, so
how kosher is doing like a

00:57:07.030 --> 00:57:09.880
global placing map between your

00:57:09.880 --> 00:57:11.410
services and other services?

00:57:11.410 --> 00:57:12.390
THOR MITCHELL: OK, so
I think there were

00:57:12.390 --> 00:57:13.540
three questions there.

00:57:13.540 --> 00:57:17.620
Let me see if I can
remember them.

00:57:17.620 --> 00:57:18.870
Right.

00:57:20.750 --> 00:57:23.220
So as far as facets are
concerned, it's

00:57:23.220 --> 00:57:24.660
a good point that--

00:57:24.660 --> 00:57:27.400
and something I mentioned in
the session yesterday--

00:57:27.400 --> 00:57:30.130
places is a very fuzzy
and broad concept.

00:57:30.130 --> 00:57:35.710
We as people, we can define
places in all sorts of ways,

00:57:35.710 --> 00:57:37.500
and some of them can be
personal: I can say, my house,

00:57:37.500 --> 00:57:39.710
I can say, the place
I got married.

00:57:39.710 --> 00:57:43.070
Some of them can be relative:
I can say, that coffee shop

00:57:43.070 --> 00:57:46.880
opposite the hardware store.

00:57:46.880 --> 00:57:51.205
And some of them can be
completely transient, like a

00:57:51.205 --> 00:57:53.020
state fair.

00:57:53.020 --> 00:57:57.950
Some of them can be in motion,
such as flights, for example,

00:57:57.950 --> 00:58:00.700
you know, I'm on QF73
or whatever.

00:58:00.700 --> 00:58:04.070
And these are all use cases
which ideally we'd like to be

00:58:04.070 --> 00:58:06.300
able to support well
in the long term.

00:58:06.300 --> 00:58:10.900
For the time being, we've taken
a position that a single

00:58:10.900 --> 00:58:13.860
place is an object with a fixed

00:58:13.860 --> 00:58:16.300
location and a fixed name.

00:58:16.300 --> 00:58:20.410
So for the time being, we don't
support things like,

00:58:20.410 --> 00:58:22.620
say, moving objects.

00:58:22.620 --> 00:58:26.330
I think temporal awareness
is very important.

00:58:26.330 --> 00:58:28.120
There's no doubt that people
would like to check into

00:58:28.120 --> 00:58:30.960
events, for example, as
well as into places.

00:58:30.960 --> 00:58:32.760
It's much more interesting to
tell your friends that you're

00:58:32.760 --> 00:58:35.730
at the Lady Gaga concert than
that you're at the HP

00:58:35.730 --> 00:58:37.160
Pavilion, for example.

00:58:37.160 --> 00:58:39.980
So, event support is something
that is absolutely on the

00:58:39.980 --> 00:58:44.600
roadmap, not necessarily as a
new type of place but as a

00:58:44.600 --> 00:58:46.490
property of an existing place.

00:58:46.490 --> 00:58:47.910
That's the more likely model.

00:58:47.910 --> 00:58:50.170
OK, second question was--

00:58:50.170 --> 00:58:54.760
AUDIENCE: The immutable nature
of your identification scheme.

00:58:54.760 --> 00:59:03.830
THOR MITCHELL: So the goal of
the Places API reference is

00:59:03.830 --> 00:59:07.880
that a Places API reference,
for any given place, should

00:59:07.880 --> 00:59:10.050
continue to always return that
place for as long as that

00:59:10.050 --> 00:59:14.940
place continues to exist. So
clearly places of business

00:59:14.940 --> 00:59:18.085
close, and what we don't
currently support is the

00:59:18.085 --> 00:59:20.060
ability to retrieve information
about a place

00:59:20.060 --> 00:59:22.910
after it's no longer
in the index.

00:59:22.910 --> 00:59:26.870
We realize that may actually
be important.

00:59:26.870 --> 00:59:29.370
You're checking history,
ultimately, you may span years

00:59:29.370 --> 00:59:31.880
and years, and you don't want
to lose that context.

00:59:31.880 --> 00:59:35.950
So that's something that we're
going to have to consider.

00:59:35.950 --> 00:59:38.620
But right now, as long as our
business continues to exists,

00:59:38.620 --> 00:59:39.720
we will match it.

00:59:39.720 --> 00:59:43.370
And the way we do that is the
whole reason we have a

00:59:43.370 --> 00:59:46.085
separate reference is because
the references you will see

00:59:46.085 --> 00:59:48.720
are significantly longer, and
although they appear to be

00:59:48.720 --> 00:59:50.830
garbage, it's actually
effectively an encrypted

00:59:50.830 --> 00:59:54.720
search that gives us a way of
falling back through different

00:59:54.720 --> 00:59:57.880
means of matching, in the case
of drift of attributes that we

00:59:57.880 --> 00:59:59.386
rely on for that purpose.

00:59:59.386 --> 01:00:01.680
AUDIENCE: And the
last was caching

01:00:01.680 --> 01:00:05.460
and creating a matching--

01:00:05.460 --> 01:00:07.092
THOR MITCHELL: We're definitely
very aware, and

01:00:07.092 --> 01:00:08.860
this was one of the great pieces
of feedback that came

01:00:08.860 --> 01:00:09.775
out in the developer preview.

01:00:09.775 --> 01:00:10.900
It really shows the
value of it.

01:00:10.900 --> 01:00:13.730
Because it wasn't something that
we picked up on at first.

01:00:13.730 --> 01:00:16.390
Something that's extremely
valuable to these

01:00:16.390 --> 01:00:18.370
location-based app developers
is what they call

01:00:18.370 --> 01:00:19.100
distribution--

01:00:19.100 --> 01:00:22.810
the ability to make people
aware of their app in a

01:00:22.810 --> 01:00:25.270
crowded market space of hundreds
of thousands of

01:00:25.270 --> 01:00:28.290
iPhone and Android
applications.

01:00:28.290 --> 01:00:29.650
Awareness is key.

01:00:29.650 --> 01:00:32.290
Now, one of the main ways in
which applications rely on

01:00:32.290 --> 01:00:33.870
this kind of awareness
right now is

01:00:33.870 --> 01:00:36.400
through social networks.

01:00:36.400 --> 01:00:38.410
If I download an app and use
it and then do a check-in,

01:00:38.410 --> 01:00:40.740
that check-in gets written to
my Twitter stream or to my

01:00:40.740 --> 01:00:41.770
Facebook page.

01:00:41.770 --> 01:00:46.420
And in doing so, my friends
see that and may choose to

01:00:46.420 --> 01:00:47.850
join the party, as it were.

01:00:47.850 --> 01:00:51.790
And so it's important, that in
those cases, you can write

01:00:51.790 --> 01:00:54.180
your check-ins across
these services.

01:00:54.180 --> 01:00:56.027
So we do actually have language
in the terms of

01:00:56.027 --> 01:00:56.980
service that address this.

01:00:56.980 --> 01:01:03.215
And the basic rule of thumb is
that if I do a check-in using

01:01:03.215 --> 01:01:06.440
an app that's based on the
Places API, I pull back a set

01:01:06.440 --> 01:01:09.000
of information about
that place.

01:01:09.000 --> 01:01:11.430
What I can do is take, say, the
location of that place,

01:01:11.430 --> 01:01:14.080
and then do a search on a
third-party API and attempt to

01:01:14.080 --> 01:01:18.230
match those things
developer-side, if you like,

01:01:18.230 --> 01:01:21.720
in your infrastructure in
order to find the ID.

01:01:21.720 --> 01:01:22.950
That's perfectly fine.

01:01:22.950 --> 01:01:29.920
What we ask that you don't do
is submit data that you've

01:01:29.920 --> 01:01:34.660
received from our API
to those services.

01:01:34.660 --> 01:01:38.520
So that means two things: it
means I get a LatLng from the

01:01:38.520 --> 01:01:40.640
user's phone, I do a search on
the Place API, I come back

01:01:40.640 --> 01:01:42.390
with a set of places, I present
them with one, they

01:01:42.390 --> 01:01:43.440
choose one, great.

01:01:43.440 --> 01:01:46.180
I then do a similar LatLng-based
search on some

01:01:46.180 --> 01:01:48.030
other API, they give me
back a set of places,

01:01:48.030 --> 01:01:49.330
I match them, great.

01:01:49.330 --> 01:01:52.396
What you can't do is take the
place name and use it as a

01:01:52.396 --> 01:01:54.790
search query over
here, all right?

01:01:54.790 --> 01:01:56.690
Similarly, you can't say, oh,
they don't have that place,

01:01:56.690 --> 01:02:00.880
I'm going to create it using
the data I got from Google.

01:02:00.880 --> 01:02:03.580
AUDIENCE: Fair, fair.

01:02:03.580 --> 01:02:05.380
THOR MITCHELL: I think
we're out of time.

01:02:05.380 --> 01:02:06.390
MARCELO CAMELO: Out of time.

01:02:06.390 --> 01:02:08.095
THOR MITCHELL: I'm happy to chat
more afterwards if that

01:02:08.095 --> 01:02:09.780
would be useful.

