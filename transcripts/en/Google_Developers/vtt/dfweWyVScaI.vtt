WEBVTT
Kind: captions
Language: en

00:00:08.777 --> 00:00:09.860
PATRICK HAMMAN: Oh, sorry.

00:00:09.860 --> 00:00:11.370
I don't have any notes.

00:00:11.370 --> 00:00:15.680
Let me just turn off
this button over here.

00:00:15.680 --> 00:00:16.887
Brilliant.

00:00:16.887 --> 00:00:17.970
Cheers for the intro part.

00:00:17.970 --> 00:00:21.650
Sorry it had to be so long.

00:00:21.650 --> 00:00:23.810
So, I'm Patrick,
and you can catch me

00:00:23.810 --> 00:00:26.730
on Twitter, @patrickhamman.

00:00:26.730 --> 00:00:29.080
As Paul said, I'm here
to talk to you today

00:00:29.080 --> 00:00:34.780
about how we at the Guardian
manage to break news

00:00:34.780 --> 00:00:36.330
within a thousand milliseconds.

00:00:36.330 --> 00:00:38.300
And hopefully, the
true meaning of that

00:00:38.300 --> 00:00:40.000
will be explained
throughout this talk.

00:00:40.000 --> 00:00:41.583
So, if you haven't
guessed it already,

00:00:41.583 --> 00:00:44.950
I work at theguardian.com,
where I'm a senior developer

00:00:44.950 --> 00:00:47.760
and technical lead on
the core content team.

00:00:47.760 --> 00:00:50.560
So our web team is
split into three teams.

00:00:50.560 --> 00:00:52.430
I manage one of
them, and there I

00:00:52.430 --> 00:00:56.790
specialize in front-end
operations and performance.

00:00:56.790 --> 00:01:00.170
Again, as Paul mentioned,
over the last 18 months,

00:01:00.170 --> 00:01:03.670
we've been building a new,
completely responsive website,

00:01:03.670 --> 00:01:04.480
from the ground-up.

00:01:04.480 --> 00:01:08.800
We did not use a single line
of code from the old system.

00:01:08.800 --> 00:01:13.250
Completely re-architecting
the system for a new Guardian

00:01:13.250 --> 00:01:15.790
in the future, a
Guardian that will

00:01:15.790 --> 00:01:18.280
sustainable
throughout the future.

00:01:18.280 --> 00:01:20.830
As Brad Frost coined
the phrase once,

00:01:20.830 --> 00:01:23.020
of planting the responsive seed.

00:01:23.020 --> 00:01:25.360
So, large organizations
like ourselves,

00:01:25.360 --> 00:01:28.377
and BBC News, and some
of our other friends--

00:01:28.377 --> 00:01:30.710
it's a very daunting and scary
fact when you turn around

00:01:30.710 --> 00:01:32.250
to your stakeholders,
and you say,

00:01:32.250 --> 00:01:34.060
"We are going to
throw away the whole

00:01:34.060 --> 00:01:35.930
of the entire
previous architecture

00:01:35.930 --> 00:01:38.290
that you've just invested
millions over the last six

00:01:38.290 --> 00:01:43.961
years on, and we want to build
a completely new platform."

00:01:43.961 --> 00:01:45.460
You know, they're
like, "No, no, no.

00:01:45.460 --> 00:01:47.250
We've got to test this first."

00:01:47.250 --> 00:01:49.920
And so, what we did, is
that we actually implemented

00:01:49.920 --> 00:01:53.050
the responsive site on
our m-dot domain first--

00:01:53.050 --> 00:01:55.060
on the mobile domain--
and then last year,

00:01:55.060 --> 00:01:56.440
when we moved to
theguardian.com,

00:01:56.440 --> 00:01:59.060
we integrated that one to
just a singled dot dot dot ,

00:01:59.060 --> 00:02:02.190
and using some clever
routing at the CDN level.

00:02:02.190 --> 00:02:04.870
And hopefully, over
the next two months,

00:02:04.870 --> 00:02:06.920
it will be coming to a
desktop near you soon,

00:02:06.920 --> 00:02:08.680
and we will be
completely turning off

00:02:08.680 --> 00:02:11.309
the old architecture.

00:02:11.309 --> 00:02:13.100
And as well as that,
in March of this year,

00:02:13.100 --> 00:02:17.540
we broke 100 million unique
browsers within a single month.

00:02:17.540 --> 00:02:21.259
And I'm very proud of this stat,
and it's a very key cornerstone

00:02:21.259 --> 00:02:22.550
in the history of The Guardian.

00:02:22.550 --> 00:02:25.690
And the current
platform that we had

00:02:25.690 --> 00:02:30.410
was just not designed to cater
for this sheer amount of users.

00:02:30.410 --> 00:02:32.220
But also, more
interestingly, we are

00:02:32.220 --> 00:02:37.490
seeing these 100 million
users are accessing the site

00:02:37.490 --> 00:02:43.980
from over 6 to 7,000
uniquely different devices.

00:02:43.980 --> 00:02:46.830
Again the old
platform was just not

00:02:46.830 --> 00:02:50.210
designed to cater for these.

00:02:50.210 --> 00:02:53.120
We needed a better solution.

00:02:53.120 --> 00:02:55.040
So, a very good
example of this here.

00:02:55.040 --> 00:02:57.710
We've got the current site
on the left-hand side,

00:02:57.710 --> 00:03:00.100
and the new, responsive
platform on the right-hand side.

00:03:05.700 --> 00:03:08.070
The new platform managed
to render within a second,

00:03:08.070 --> 00:03:11.130
and we're still waiting
slowly as we build the page

00:03:11.130 --> 00:03:14.820
bit by bit, component-component
with the old site.

00:03:14.820 --> 00:03:18.430
But what does this actually
see, what is this to the user?

00:03:18.430 --> 00:03:21.136
How does a user really
see this in real time?

00:03:21.136 --> 00:03:21.860
Boom.

00:03:21.860 --> 00:03:24.590
We finished loading the
entire site in three seconds.

00:03:24.590 --> 00:03:28.250
We're still waiting, waiting.

00:03:28.250 --> 00:03:30.520
The current median
average for load time

00:03:30.520 --> 00:03:34.840
on our current platform
is 10-12 seconds.

00:03:34.840 --> 00:03:36.560
That's not acceptable.

00:03:36.560 --> 00:03:38.490
You can see there's a
recurring theme here.

00:03:38.490 --> 00:03:41.580
And it's not just The
Guardian's problem.

00:03:41.580 --> 00:03:45.150
This is a great article
taken from "Web Performance

00:03:45.150 --> 00:03:47.922
Today" in March last year.

00:03:47.922 --> 00:03:49.630
This was taken from
e-commerce platforms,

00:03:49.630 --> 00:03:52.985
that your average user
in 2000 expected your web

00:03:52.985 --> 00:03:55.120
page to load within
nine seconds.

00:03:55.120 --> 00:03:59.670
And, in 2012, that was
reduced to below two.

00:03:59.670 --> 00:04:03.260
So again, our current platform
isn't designed for this.

00:04:03.260 --> 00:04:05.260
But still, it's not just
The Guardian's problem.

00:04:05.260 --> 00:04:09.140
In reality-- I digged this
up from [INAUDIBLE] archive,

00:04:09.140 --> 00:04:12.020
and pumped the
data into BigQuery.

00:04:12.020 --> 00:04:16.180
This is the median speed
index for the top 10,000 Alexa

00:04:16.180 --> 00:04:17.850
websites.

00:04:17.850 --> 00:04:23.100
You can see here that the median
average is around 9-10 seconds.

00:04:23.100 --> 00:04:25.960
But the 90th percentile
is staggeringly

00:04:25.960 --> 00:04:30.090
between 15-20 seconds off
the top 10,000 websites

00:04:30.090 --> 00:04:31.550
in the world.

00:04:31.550 --> 00:04:34.540
I was shocked when
I saw that data.

00:04:34.540 --> 00:04:36.290
But it's not just
a Guardian problem.

00:04:36.290 --> 00:04:38.720
We're here in the
median baseline.

00:04:38.720 --> 00:04:41.510
We had to do
something about this.

00:04:41.510 --> 00:04:43.520
I hope when most of you
create new products,

00:04:43.520 --> 00:04:45.970
the first thing you do
is go and find out about,

00:04:45.970 --> 00:04:48.430
maybe our users didn't
care about speed.

00:04:48.430 --> 00:04:52.530
So we went out, and we
queried 3,000 of our users,

00:04:52.530 --> 00:04:55.960
and asked them about 17
of the key product drivers

00:04:55.960 --> 00:04:57.800
for the Guardian news site.

00:04:57.800 --> 00:05:00.722
And they rated-- this is
very unsurprisingly to me,

00:05:00.722 --> 00:05:02.430
but surprisingly to
a lot of stakeholders

00:05:02.430 --> 00:05:05.005
in the business--
they rated speed

00:05:05.005 --> 00:05:11.020
as the second-most important
factor, a key product indicator

00:05:11.020 --> 00:05:15.400
for our platform, only
after easy-to-find content.

00:05:15.400 --> 00:05:17.810
And you'd hope,
on a news website,

00:05:17.810 --> 00:05:19.670
that the content
is easy to find.

00:05:19.670 --> 00:05:23.310
So our uses do actually care.

00:05:23.310 --> 00:05:25.210
The websites are
slowing down, and users

00:05:25.210 --> 00:05:26.820
are asking for faster websites.

00:05:30.700 --> 00:05:32.550
As well as taken from
the user's mouth--

00:05:32.550 --> 00:05:36.357
this is an excerpt taken from
Ilya Grigorik's amazing book,

00:05:36.357 --> 00:05:37.940
"High Performance
Browser Networking,"

00:05:37.940 --> 00:05:40.060
which I think literally
everyone in this room

00:05:40.060 --> 00:05:42.350
should go out and buy and read.

00:05:42.350 --> 00:05:43.870
It was the best
book of this year.

00:05:43.870 --> 00:05:45.480
So, there's a lot
of HCI research

00:05:45.480 --> 00:05:50.530
that shows that for a user
to perceive that a machine is

00:05:50.530 --> 00:05:54.310
actually working, they'd have
to have a response within 1,000

00:05:54.310 --> 00:05:55.670
milliseconds.

00:05:55.670 --> 00:06:00.230
And after 10 seconds, the
task is completely abandoned.

00:06:00.230 --> 00:06:02.140
This doesn't just
relate to websites.

00:06:02.140 --> 00:06:04.360
This could be me at home,
watching television,

00:06:04.360 --> 00:06:05.900
changing a channel.

00:06:05.900 --> 00:06:06.970
Clicking a button.

00:06:06.970 --> 00:06:10.610
I want the machine to respond
within 1,000 milliseconds,

00:06:10.610 --> 00:06:13.580
for me to know the machine is
working, for me to cognitively

00:06:13.580 --> 00:06:17.580
feel that this is a fast
machine, it is responsive.

00:06:17.580 --> 00:06:21.530
Let's look at that number
again: 1,000 milliseconds.

00:06:21.530 --> 00:06:23.260
No longer can we
as web developers

00:06:23.260 --> 00:06:24.540
start to think in seconds.

00:06:24.540 --> 00:06:27.440
We must be thinking
in milliseconds.

00:06:27.440 --> 00:06:31.740
And, both Nat and Addy here
today have shown that clearly.

00:06:31.740 --> 00:06:35.370
We really need to be
thinking in milliseconds.

00:06:35.370 --> 00:06:40.950
And so, what if you could
enforce this, as a budget?

00:06:40.950 --> 00:06:42.700
As part of your
development workflow,

00:06:42.700 --> 00:06:44.450
when we were starting
to create a website,

00:06:44.450 --> 00:06:46.830
setting ourselves
a rendering budget.

00:06:46.830 --> 00:06:51.850
Our site needs to render
within 1,000 milliseconds.

00:06:51.850 --> 00:06:54.250
Both Tim [? Cadlick ?]
and Brad Frost

00:06:54.250 --> 00:06:56.400
have been coining
this idea of having

00:06:56.400 --> 00:06:58.540
a concept of a
performance budget,

00:06:58.540 --> 00:07:00.430
and that is exactly
what we did at Guardian.

00:07:00.430 --> 00:07:03.070
We call them our lines
in the sand: rules

00:07:03.070 --> 00:07:05.970
that we are not
willing to cross.

00:07:05.970 --> 00:07:09.240
All features must
adhere to these budgets,

00:07:09.240 --> 00:07:11.956
to these lines in the sand.

00:07:11.956 --> 00:07:13.330
We've actually
got a lot of them,

00:07:13.330 --> 00:07:15.799
but I'm only going to focus
on four of them today.

00:07:15.799 --> 00:07:17.340
For the rest of the
talk, I just want

00:07:17.340 --> 00:07:21.760
to go through our lines
in the sand with you--

00:07:21.760 --> 00:07:23.220
a manifesto, as such.

00:07:23.220 --> 00:07:29.430
So the first one-- let's dive
straight in, and take a look.

00:07:29.430 --> 00:07:32.940
One thing that we are very true
believers in at The Guardian:

00:07:32.940 --> 00:07:35.160
we are in the content business.

00:07:35.160 --> 00:07:35.910
That is our job.

00:07:35.910 --> 00:07:38.720
We deliver high-quality
content to users.

00:07:38.720 --> 00:07:41.640
Therefore, when we think
about responsive design,

00:07:41.640 --> 00:07:44.610
we actually think of
content-first delivery,

00:07:44.610 --> 00:07:45.605
content-first design.

00:07:49.580 --> 00:07:51.880
That's the only Flash
animation I've got in my talk.

00:07:55.150 --> 00:07:58.440
Think of a word for
site, a normal blog.

00:07:58.440 --> 00:08:02.360
What happens on the server
side to actually render a page:

00:08:02.360 --> 00:08:06.241
if user clicks on a link goes
through to read the article.

00:08:06.241 --> 00:08:08.240
What's actually happening
in the server response

00:08:08.240 --> 00:08:10.720
there, is normally we are
doing a database look-up

00:08:10.720 --> 00:08:12.830
for the article itself.

00:08:12.830 --> 00:08:14.980
Or, probably then, perform
another database look-up

00:08:14.980 --> 00:08:17.700
for the related content
widget you've got.

00:08:17.700 --> 00:08:21.710
Another database look-up for
your comment section, and maybe

00:08:21.710 --> 00:08:23.360
the most popular
content at the bottom.

00:08:23.360 --> 00:08:26.650
So, all these database
queries are building up.

00:08:26.650 --> 00:08:28.740
On average, your Wordpress
blog will probably

00:08:28.740 --> 00:08:30.920
bed doing six to eight
database look-ups

00:08:30.920 --> 00:08:34.659
before it can even deliver
the content to the user.

00:08:34.659 --> 00:08:37.370
But even though the
user only really came

00:08:37.370 --> 00:08:40.820
to read the article-- he didn't
care about the side widgets,

00:08:40.820 --> 00:08:43.110
or the most popular component,
or even the comments

00:08:43.110 --> 00:08:43.940
[INAUDIBLE].

00:08:43.940 --> 00:08:45.630
Each one of those
database requests

00:08:45.630 --> 00:08:48.270
is eating into our 1,000
millisecond barrier.

00:08:51.830 --> 00:08:55.200
On The Guardian-- this is
our typical architecture

00:08:55.200 --> 00:09:00.010
of the old site-- is that we
had to perform three database

00:09:00.010 --> 00:09:01.540
look-ups before we
could then render

00:09:01.540 --> 00:09:03.410
to the user, each
one of these having

00:09:03.410 --> 00:09:06.860
a tight coupled, single point
of failure to the services

00:09:06.860 --> 00:09:08.210
that lie behind them.

00:09:08.210 --> 00:09:10.700
So for instance, if
the commenting platform

00:09:10.700 --> 00:09:15.790
was to fall over, so would
the rendering the website.

00:09:15.790 --> 00:09:18.930
And I'm afraid it did,
on numerous occasions.

00:09:18.930 --> 00:09:21.210
Each one of these creating
single points of failures

00:09:21.210 --> 00:09:24.620
to other services, when
in fact, the user only

00:09:24.620 --> 00:09:25.845
really came to read the news.

00:09:29.590 --> 00:09:31.640
And so, we started to
think about different ways

00:09:31.640 --> 00:09:33.840
of creating a service-oriented
architecture that we

00:09:33.840 --> 00:09:36.740
can isolate these single
points of failure.

00:09:36.740 --> 00:09:38.540
The user came to read the news.

00:09:38.540 --> 00:09:42.110
We call this process swimlaning.

00:09:42.110 --> 00:09:46.490
We have a line in the sand that
says, "We can only perform one

00:09:46.490 --> 00:09:49.230
blocking database request
through our content API,

00:09:49.230 --> 00:09:52.240
and that has to be the
primary content, the thing

00:09:52.240 --> 00:09:53.950
that the user came there for."

00:09:53.950 --> 00:09:57.170
The rest of the look-ups
can be done asynchronously,

00:09:57.170 --> 00:09:58.900
progressively enhanced.

00:09:58.900 --> 00:10:01.230
And so you look at
that diagram now:

00:10:01.230 --> 00:10:08.000
we've created a swimlane, a
fault-tolerant system that

00:10:08.000 --> 00:10:10.500
has no dependencies on the
other single point of failures,

00:10:10.500 --> 00:10:11.810
or other services.

00:10:11.810 --> 00:10:15.240
And so we can
asynchronously, progressively

00:10:15.240 --> 00:10:18.010
enhance the most popular
component at the bottom.

00:10:18.010 --> 00:10:22.570
And then, if the comments
section was to fail,

00:10:22.570 --> 00:10:25.470
we still can deliver the news
within 1,000 milliseconds,

00:10:25.470 --> 00:10:28.490
to the user, because that's
what they came here for.

00:10:28.490 --> 00:10:31.970
So, on the new platform,
on the left hand side,

00:10:31.970 --> 00:10:34.660
you'll see that's what
the initial payload is:

00:10:34.660 --> 00:10:38.160
a bare-bones article, but still,
the content they came here for.

00:10:38.160 --> 00:10:39.880
And then, eventually,
we progressively

00:10:39.880 --> 00:10:43.010
enhance asynchronously loading
in the rest of the components,

00:10:43.010 --> 00:10:46.530
each one of them having their
own single blocking request

00:10:46.530 --> 00:10:48.460
rule.

00:10:48.460 --> 00:10:52.214
If the comments don't
load, we fail gracefully.

00:10:52.214 --> 00:10:53.630
And, to me, the
biggest thing here

00:10:53.630 --> 00:10:55.960
is that we've been
able to deliver

00:10:55.960 --> 00:10:58.982
a much faster,
resilient-to-failure

00:10:58.982 --> 00:11:01.190
of other services, and we
can still deliver the news.

00:11:01.190 --> 00:11:03.840
And for me, progressive
enhancement-- and I

00:11:03.840 --> 00:11:06.440
went to a great
conference last Friday,

00:11:06.440 --> 00:11:10.380
where my friend Tom from
GDS spoke-- and this really

00:11:10.380 --> 00:11:12.300
resonated home to me.

00:11:12.300 --> 00:11:14.380
Brad Wright at GDS
team once said this,

00:11:14.380 --> 00:11:17.970
that "Progressive enhancement
is about resilience

00:11:17.970 --> 00:11:20.880
as much as it is about
is about inclusiveness."

00:11:20.880 --> 00:11:24.200
And to me, that's how I see
progressive enhancement.

00:11:24.200 --> 00:11:27.410
We want to create
resilient systems that

00:11:27.410 --> 00:11:30.920
are resilient to failure,
regardless of it.

00:11:30.920 --> 00:11:35.980
The internet is
inherently--- I'm sorry,

00:11:35.980 --> 00:11:39.970
don't know where I
was going with that.

00:11:39.970 --> 00:11:42.040
Let's move on.

00:11:42.040 --> 00:11:45.230
So for a system to
feel responsive,

00:11:45.230 --> 00:11:47.410
we need to respond within
1,000 milliseconds.

00:11:47.410 --> 00:11:50.440
We saw that as part
of Ilya's slide.

00:11:50.440 --> 00:11:55.380
But before we do that, I want
us to take a step back, and have

00:11:55.380 --> 00:11:58.280
a quick lesson in
Browser Rendering 101.

00:11:58.280 --> 00:12:00.840
Nat actually did a very, very
amazing job-- much better

00:12:00.840 --> 00:12:02.760
than I could at doing
this-- so hopefully we

00:12:02.760 --> 00:12:05.220
can skim through a bit of it.

00:12:05.220 --> 00:12:06.680
But, the point I
want to make here

00:12:06.680 --> 00:12:10.560
is that having the knowledge
of how browsers actually

00:12:10.560 --> 00:12:13.050
perform rendering--
everything from the click

00:12:13.050 --> 00:12:16.020
on a link on the previous page,
through the critical path,

00:12:16.020 --> 00:12:17.890
to actually painting
to your screen--

00:12:17.890 --> 00:12:20.370
having the knowledge of
how it does that allows us

00:12:20.370 --> 00:12:23.110
as web developers to make
a lot better decisions.

00:12:23.110 --> 00:12:25.190
We know our application
stat very well,

00:12:25.190 --> 00:12:27.930
but combined with the knowledge
of how the browser stat works

00:12:27.930 --> 00:12:30.880
really allows us to make
some powerful decisions

00:12:30.880 --> 00:12:33.910
about how we load our web pages.

00:12:33.910 --> 00:12:36.990
So let's look at this, thinking
in mind our 1,000 millisecond

00:12:36.990 --> 00:12:38.000
budget.

00:12:38.000 --> 00:12:41.500
Here is a great slide, taken
from Google's page insights

00:12:41.500 --> 00:12:46.430
resource, showing that actually,
on your average 3G connection,

00:12:46.430 --> 00:12:50.110
600 milliseconds
minimum are already

00:12:50.110 --> 00:12:52.430
taken up by 3G networking.

00:12:52.430 --> 00:12:57.010
That's the look-up, and then
the through your HTTP handshake,

00:12:57.010 --> 00:12:59.380
and then eventually, making
initial HTTP request ,

00:12:59.380 --> 00:13:02.060
like maybe the get
request your index page,

00:13:02.060 --> 00:13:03.580
and waiting for the response.

00:13:03.580 --> 00:13:07.180
So that only leaves us
with 400 milliseconds

00:13:07.180 --> 00:13:09.310
to play with as developers.

00:13:09.310 --> 00:13:12.130
And I'm telling you-- 600
millisecond is a minimum.

00:13:12.130 --> 00:13:14.820
On most UK 3G connections,
you can't even

00:13:14.820 --> 00:13:18.550
beat the 1,000
millisecond barrier.

00:13:18.550 --> 00:13:21.010
Normally much more.

00:13:21.010 --> 00:13:23.760
Once we've done
that-- we've performed

00:13:23.760 --> 00:13:27.820
the networking-- that's
taking up 600 milliseconds.

00:13:27.820 --> 00:13:31.370
Once we get to the payload
back, just the html file,

00:13:31.370 --> 00:13:35.789
we have to start
incrementally pausing the DOM.

00:13:35.789 --> 00:13:38.080
Now, this is one of the great
things of that HTML spec,

00:13:38.080 --> 00:13:40.230
is it actually can be
paused incrementally

00:13:40.230 --> 00:13:42.580
as packets come in,
and we can start

00:13:42.580 --> 00:13:45.750
to construct a
document object model.

00:13:45.750 --> 00:13:50.410
But once we're constructing the
DOM, if we find a stylesheets

00:13:50.410 --> 00:13:53.060
or script element, for
reasons that we're just

00:13:53.060 --> 00:13:54.570
about to find out,
we have to stop.

00:13:54.570 --> 00:13:57.560
We have to go back, and
perform our networking again.

00:13:57.560 --> 00:14:02.420
Again, incurring that 600
millisecond latency-- already

00:14:02.420 --> 00:14:05.606
blasted past our budget.

00:14:05.606 --> 00:14:06.980
Once we've got
the stylesheet, we

00:14:06.980 --> 00:14:10.559
can then start to construct
a CSS object model.

00:14:10.559 --> 00:14:12.350
There is a lesson known,
just like the DOM,

00:14:12.350 --> 00:14:13.891
it's still a tree-like
structure that

00:14:13.891 --> 00:14:17.230
contains all of the
styles in an O -format.

00:14:17.230 --> 00:14:18.800
But the problem is
here, is that we

00:14:18.800 --> 00:14:23.357
have our wonderful
friend, Javascript.

00:14:23.357 --> 00:14:24.940
Sorry, I skipped
past something a bit.

00:14:24.940 --> 00:14:28.880
CSS can't be caused
incrementally,

00:14:28.880 --> 00:14:31.880
because of the nature
of the cascade.

00:14:31.880 --> 00:14:34.300
You paint, and then something
later in the cascade

00:14:34.300 --> 00:14:36.299
will come over, and you
get this horrible flash,

00:14:36.299 --> 00:14:37.680
and reflows and restyles.

00:14:37.680 --> 00:14:41.710
So we have to fully
download the entire file

00:14:41.710 --> 00:14:43.480
before we can then pause it.

00:14:43.480 --> 00:14:47.425
But, our friend of and
foe, JavaScript, he

00:14:47.425 --> 00:14:51.150
is so tightly coupled,
interwoven, with HTML and CSS,

00:14:51.150 --> 00:14:53.780
that because of the
nature of JavaScript

00:14:53.780 --> 00:14:56.265
could do a document.write--
our favorite feature

00:14:56.265 --> 00:14:58.750
of JavaScript-- it
might amend the DOM.

00:14:58.750 --> 00:15:00.820
It alter it in a way.

00:15:00.820 --> 00:15:03.950
So, JavaScript blocks
DOM construction.

00:15:03.950 --> 00:15:08.380
This is why we have the
age-old, best practice,

00:15:08.380 --> 00:15:10.149
of making JavaScript
asynchronous,

00:15:10.149 --> 00:15:11.690
putting it at the
bottom of the page,

00:15:11.690 --> 00:15:13.240
making a promise
to the browser--

00:15:13.240 --> 00:15:16.205
by using an async or
divert tag-- I know

00:15:16.205 --> 00:15:18.330
that this JavaScript is
not going to alter the DOM.

00:15:18.330 --> 00:15:19.890
I'm making a promise to you.

00:15:19.890 --> 00:15:23.200
And so, we can take it
off the critical path.

00:15:23.200 --> 00:15:25.950
But JavaScript is
tightly coupled with CSS,

00:15:25.950 --> 00:15:29.300
because JavaScript execution
cannot proceed until we have

00:15:29.300 --> 00:15:31.790
CSS object model, because
the JavaScript might ask

00:15:31.790 --> 00:15:33.730
for a style of the DOM.

00:15:33.730 --> 00:15:37.660
And then eventually, once we
have all this information,

00:15:37.660 --> 00:15:40.330
we create a render tree, which
is the mixture of the two

00:15:40.330 --> 00:15:42.110
of them, having all
the information,

00:15:42.110 --> 00:15:45.310
from the top left of the screen,
top right, all the way down.

00:15:45.310 --> 00:15:47.067
And then, we can
perform the geometry,

00:15:47.067 --> 00:15:49.400
form layout, actually work
out the size of all of these,

00:15:49.400 --> 00:15:51.324
and eventually
paint to the screen.

00:15:51.324 --> 00:15:52.740
Nat's laughing,
because I probably

00:15:52.740 --> 00:15:54.455
got a lot of that
information wrong.

00:15:54.455 --> 00:15:57.080
NAT: No, just 'cause it's such
a horrible, complicated maching.

00:15:57.080 --> 00:16:00.075
PATRICK HAMMAN: Yeah, and this
is quite a simple explanation

00:16:00.075 --> 00:16:00.900
of it.

00:16:00.900 --> 00:16:04.000
It is even a lot more
complex, and certain browsers

00:16:04.000 --> 00:16:05.080
have different nuances.

00:16:05.080 --> 00:16:07.160
But this is the easiest
way of simplifying that.

00:16:07.160 --> 00:16:10.320
So, the point I'm
trying to make here

00:16:10.320 --> 00:16:15.540
is how crucial CSS is
to your critical path.

00:16:15.540 --> 00:16:18.400
If we look at a traditional
web page, we've got HMTL .

00:16:18.400 --> 00:16:19.250
We then pause it.

00:16:19.250 --> 00:16:21.047
We find the CSS, we
carry on, and then

00:16:21.047 --> 00:16:23.380
eventually, the JavaScript
is at the bottom of the page.

00:16:23.380 --> 00:16:26.700
Now, if we declared
to the browser

00:16:26.700 --> 00:16:28.760
that's asynchronous
JavaScript, you've

00:16:28.760 --> 00:16:32.580
already knocked off
400 milliseconds

00:16:32.580 --> 00:16:34.170
off you're rendering.

00:16:34.170 --> 00:16:37.000
And so here, this is the
tight coupling between CSS.

00:16:37.000 --> 00:16:40.610
We cannot render until
we've completely downloaded,

00:16:40.610 --> 00:16:43.480
performed all the networking,
and paused that CSS file.

00:16:43.480 --> 00:16:48.440
So, we must get the CSS
down as soon as possible.

00:16:48.440 --> 00:16:50.250
It is the only thing
on your critical path.

00:16:50.250 --> 00:16:54.540
To me, it is the critical path.

00:16:54.540 --> 00:16:57.430
And you might see where I'm
starting to go with this.

00:16:57.430 --> 00:16:59.970
So what is your critical CSS?

00:16:59.970 --> 00:17:02.830
What is the only
CSS that you need

00:17:02.830 --> 00:17:06.042
to be able to paint the core
content your user came here

00:17:06.042 --> 00:17:08.079
for?

00:17:08.079 --> 00:17:11.410
But I mean, with responsive
web design, it's pretty tricky.

00:17:11.410 --> 00:17:14.650
This concept of above the
fold no longer exists.

00:17:14.650 --> 00:17:18.410
So, some CSS that might be
critical on my mobile device

00:17:18.410 --> 00:17:20.180
is not critical on my desktop.

00:17:20.180 --> 00:17:23.530
Or, the desktop actually might
need some more complex styles.

00:17:23.530 --> 00:17:27.150
It's a very hard problem.

00:17:27.150 --> 00:17:28.940
But is it your sharing widget?

00:17:28.940 --> 00:17:29.440
No.

00:17:29.440 --> 00:17:30.890
And it's not your
popular content.

00:17:30.890 --> 00:17:32.990
You can see where I'm
probably going here.

00:17:32.990 --> 00:17:35.410
It's nothing of the
progressively enhanced

00:17:35.410 --> 00:17:36.220
component.

00:17:36.220 --> 00:17:40.100
The only CSS that I really
need to render my core

00:17:40.100 --> 00:17:42.405
content to the user is
what they can came there

00:17:42.405 --> 00:17:43.210
for-- the article.

00:17:43.210 --> 00:17:47.690
And maybe a bit of the Chrome
at the top, the navigation.

00:17:47.690 --> 00:17:50.410
So what if we were
to inline that CSS

00:17:50.410 --> 00:17:53.120
into the head of the
document, negating the need

00:17:53.120 --> 00:17:57.350
to perform the 600
millisecond networking for it?

00:17:57.350 --> 00:18:00.490
If we had all of the information
to render that core content

00:18:00.490 --> 00:18:04.140
within the initial payload,
the first HTTP request,

00:18:04.140 --> 00:18:07.440
we are creating the
most resilient system,

00:18:07.440 --> 00:18:11.410
because we only need one
HTTP request to render

00:18:11.410 --> 00:18:14.180
the thing that the
user came here for.

00:18:14.180 --> 00:18:17.320
The browser wouldn't have
to do any more networking.

00:18:17.320 --> 00:18:19.740
That's exactly what we
started to do at The Guardian.

00:18:19.740 --> 00:18:22.410
We started to inline
the critical CSS

00:18:22.410 --> 00:18:23.720
into the head of our document.

00:18:23.720 --> 00:18:26.460
This goes against
everything that we've

00:18:26.460 --> 00:18:29.990
been taught, of separation
of concerns, styles in CSS,

00:18:29.990 --> 00:18:31.820
behavior in JavaScript.

00:18:31.820 --> 00:18:34.132
It's a very weird
concept to get around,

00:18:34.132 --> 00:18:36.423
but when you see the results,
that you're going through

00:18:36.423 --> 00:18:38.540
in a second, it's astonishing.

00:18:38.540 --> 00:18:42.340
Now, I'm going to
mention some tools later

00:18:42.340 --> 00:18:44.620
that people like Addy
are spearheading, is

00:18:44.620 --> 00:18:46.850
that you can automate
the process of this.

00:18:46.850 --> 00:18:49.400
We choose not to automate
the process of it,

00:18:49.400 --> 00:18:52.560
because of the tricky
problem that I mentioned,

00:18:52.560 --> 00:18:54.700
of that what is above the fold?

00:18:54.700 --> 00:18:56.810
We as application developers
are the best people

00:18:56.810 --> 00:18:57.790
to make that decision.

00:18:57.790 --> 00:19:00.440
So, we started off
with one head file.

00:19:00.440 --> 00:19:02.590
We've now got about four
different head files.

00:19:02.590 --> 00:19:06.540
We use Sass to do this, so that
we can maintain the modules,

00:19:06.540 --> 00:19:08.880
include them back into
a single head file,

00:19:08.880 --> 00:19:11.890
and then get ourselves our
code to do a bit of I/O,

00:19:11.890 --> 00:19:14.090
read the file, and
just inject it out

00:19:14.090 --> 00:19:17.980
as a string inside
of style element.

00:19:17.980 --> 00:19:23.095
So let's see how the user
perceives this change.

00:19:25.950 --> 00:19:29.030
On the bottom is with
inline CSS, boom.

00:19:29.030 --> 00:19:32.832
Within 600 milliseconds,
we've rendered that.

00:19:32.832 --> 00:19:34.540
We've nearly finished
rendering the page,

00:19:34.540 --> 00:19:36.123
and the first one
hasn't even started.

00:19:36.123 --> 00:19:40.810
Unfortunately, its with David
Cameron's head in it there.

00:19:40.810 --> 00:19:44.360
So, at the bottom of the page,
the observant in the room

00:19:44.360 --> 00:19:46.414
would have we realized,
"Hang on a second.

00:19:46.414 --> 00:19:48.830
You're still gonna have to
load in the rest of the styles.

00:19:48.830 --> 00:19:52.150
You can't just have a
bare-boned bit of CSS there."

00:19:52.150 --> 00:19:53.830
Now, at the foot
of our document,

00:19:53.830 --> 00:19:57.959
we asynchronously load in the
rest of the global styles.

00:19:57.959 --> 00:19:59.000
So we're doing that here.

00:19:59.000 --> 00:20:01.310
If we get a 200 response,
we do two things.

00:20:01.310 --> 00:20:05.310
First, we inline
the CSS instantly,

00:20:05.310 --> 00:20:07.710
so we have an instant rendering.

00:20:07.710 --> 00:20:11.130
Although, albeit, maybe a
flash of unstyled content,

00:20:11.130 --> 00:20:14.010
because we've instantly painted
with the inline at the top.

00:20:14.010 --> 00:20:15.480
We then load in the rest.

00:20:15.480 --> 00:20:17.900
That's obviously going to
cause a massive reflow.

00:20:17.900 --> 00:20:19.950
So to get around that
issue, we actually

00:20:19.950 --> 00:20:23.030
then store the CSS
in local storage.

00:20:23.030 --> 00:20:25.330
We're using the MD5
hash of the file

00:20:25.330 --> 00:20:28.310
to do a bit of simple
caching validation.

00:20:28.310 --> 00:20:31.845
And then, as you'll see
on the next time road,

00:20:31.845 --> 00:20:33.990
on the second load,
we can instantly

00:20:33.990 --> 00:20:36.530
ask: "Does the user
already have the rest

00:20:36.530 --> 00:20:38.450
of the global styles in
their local storage?"

00:20:38.450 --> 00:20:39.480
If yes, boom.

00:20:39.480 --> 00:20:42.230
We then have all of the
styles-- not even just

00:20:42.230 --> 00:20:45.020
the critical styles-- all
of the styles of the page,

00:20:45.020 --> 00:20:48.450
within the initial payload.

00:20:48.450 --> 00:20:51.524
Some of the pioneers
of this technique,

00:20:51.524 --> 00:20:52.940
which has actually
been in Google.

00:20:52.940 --> 00:20:56.630
Steve [? Style ?] just wrote
an article dating back to 2011,

00:20:56.630 --> 00:20:59.120
when he started noticing
that the service giants were

00:20:59.120 --> 00:21:00.590
using this technique.

00:21:00.590 --> 00:21:04.770
They actually use a cookie
to say that the user already

00:21:04.770 --> 00:21:05.750
has it in its cache.

00:21:05.750 --> 00:21:08.180
And the only reason why we
don't use that technique

00:21:08.180 --> 00:21:11.240
is that we maintain a very
strict no-cookie policy.

00:21:11.240 --> 00:21:14.040
We don't do any
dynamic rendering,

00:21:14.040 --> 00:21:17.862
so that we can cache all of our
HTML on the edge, in the CDN.

00:21:17.862 --> 00:21:19.820
So that's why we we've
opted for local storage,

00:21:19.820 --> 00:21:22.620
but I'm very open to hearing
other people's approaches

00:21:22.620 --> 00:21:24.791
to this.

00:21:24.791 --> 00:21:26.790
Here, we've got our
traditional waterfall again.

00:21:26.790 --> 00:21:29.190
So we're rendering
over our budget.

00:21:29.190 --> 00:21:34.671
We've still got the classic
three-pronged autofill.

00:21:34.671 --> 00:21:38.880
Now, because we've made our
CSS loading asynchronous--

00:21:38.880 --> 00:21:41.710
it's going on in the
background-- the browser has

00:21:41.710 --> 00:21:44.160
instant, there's the
start render event,

00:21:44.160 --> 00:21:47.860
shaving off nearly 500
milliseconds of our rendering,

00:21:47.860 --> 00:21:50.860
because we've managed to inline
our CSS into the document,

00:21:50.860 --> 00:21:53.940
breaking the 1,000
millisecond barrier.

00:21:53.940 --> 00:21:57.970
So now, if you were to
load our website today,

00:21:57.970 --> 00:22:00.330
you will notice that
in your dev tools,

00:22:00.330 --> 00:22:02.720
there will be no
stylesheets loaded.

00:22:02.720 --> 00:22:08.230
But, you will see a string
in your local storage.

00:22:08.230 --> 00:22:12.280
As I mentioned, there's a lot
of people pioneering this.

00:22:12.280 --> 00:22:16.540
The speed module from ngx
does it on the fly for you.

00:22:16.540 --> 00:22:18.770
Again, one of the main
reasons why we didn't use that

00:22:18.770 --> 00:22:20.492
is because of cacheing purposes.

00:22:20.492 --> 00:22:22.700
And Addy's written a very
great tool called Critical,

00:22:22.700 --> 00:22:24.980
and I highly advise
you check this out.

00:22:24.980 --> 00:22:26.450
So, automate this
as part of your

00:22:26.450 --> 00:22:29.130
build process inside
Grunt and Gulp.

00:22:29.130 --> 00:22:33.672
And Jonas has also written a
different approach to that,

00:22:33.672 --> 00:22:37.760
using Penthouse, using
Phantom headless browser,

00:22:37.760 --> 00:22:42.190
to render your page to determine
what is the critical CSS.

00:22:42.190 --> 00:22:44.910
That's all well and good,
but surely this is a hack.

00:22:44.910 --> 00:22:48.390
We shouldn't be
having to do this.

00:22:48.390 --> 00:22:52.970
And so what does the future hold
for us, to be able to do this?

00:22:52.970 --> 00:22:55.650
The first one is http/2.

00:22:55.650 --> 00:22:58.690
It's an IETF working
draft that should

00:22:58.690 --> 00:23:00.282
be finalized by the
end of this year.

00:23:00.282 --> 00:23:01.740
Maybe other people
in the room that

00:23:01.740 --> 00:23:03.620
might be able to
tell me differently.

00:23:03.620 --> 00:23:05.380
But, the main thing
about http/2 is it

00:23:05.380 --> 00:23:08.410
allows multiple
concurrent connections

00:23:08.410 --> 00:23:10.270
on the same connection.

00:23:10.270 --> 00:23:13.100
But, more importantly,
there's a great new feature

00:23:13.100 --> 00:23:14.720
could Server Push.

00:23:14.720 --> 00:23:16.560
So, you as a web
application developer

00:23:16.560 --> 00:23:19.780
know more about your application
than the browser done.

00:23:19.780 --> 00:23:22.190
What if you knew the next
file that the browser's gonna

00:23:22.190 --> 00:23:25.250
instantly ask for
is the CSS file?

00:23:25.250 --> 00:23:28.330
What if when we initially
requested the HTML file,

00:23:28.330 --> 00:23:31.020
we could also push
the CSS, saying

00:23:31.020 --> 00:23:33.400
"I know you're going to
need this, so have it.

00:23:33.400 --> 00:23:36.160
And maybe you've even
got in your cache."

00:23:36.160 --> 00:23:39.210
So, this paradigm of
having to load the HTML,

00:23:39.210 --> 00:23:41.650
and then go on later
to CSS, and only then

00:23:41.650 --> 00:23:43.580
do we have enough
information to render.

00:23:43.580 --> 00:23:46.500
In http/2, instead of a
push, we can instantly

00:23:46.500 --> 00:23:48.200
push both files
down the same time.

00:23:52.860 --> 00:23:55.040
You've seen that we've
designed a system

00:23:55.040 --> 00:23:56.095
to be resilient failure.

00:23:59.730 --> 00:24:02.140
We now enforce
that every feature

00:24:02.140 --> 00:24:05.740
has to be resilient
failure that we build.

00:24:05.740 --> 00:24:10.870
I'm sure you've all seen this,
probably on a daily basis.

00:24:10.870 --> 00:24:13.950
I know, being a kind of
semi Google-sponsored event,

00:24:13.950 --> 00:24:16.892
I'm not saying that
it's Google's fault

00:24:16.892 --> 00:24:19.350
in any way at all-- is anyone's
fault-- it just so happened

00:24:19.350 --> 00:24:20.074
that that was the slide.

00:24:20.074 --> 00:24:21.448
I should have
edited that before.

00:24:21.448 --> 00:24:26.360
But this really is the
story of my life, OK?

00:24:26.360 --> 00:24:27.360
I do a lot of commuting.

00:24:27.360 --> 00:24:29.710
I'm on the train,
I'm on Twitter,

00:24:29.710 --> 00:24:33.360
someone sends a cool
link, I click on it.

00:24:33.360 --> 00:24:35.890
I have enough network to get
the HTML file-- but boom,

00:24:35.890 --> 00:24:38.065
I go into a tunnel--
and my browser

00:24:38.065 --> 00:24:39.940
has now realized that
there's some custom web

00:24:39.940 --> 00:24:41.216
fonts on that page.

00:24:41.216 --> 00:24:42.840
And then it has to
go and perform them,

00:24:42.840 --> 00:24:43.550
and it's blocking.

00:24:43.550 --> 00:24:45.175
It's not gonna render,
even though I've

00:24:45.175 --> 00:24:46.330
got all the content.

00:24:46.330 --> 00:24:47.800
I just want to read the content.

00:24:47.800 --> 00:24:50.620
I don't really care what
it looks like that much.

00:24:50.620 --> 00:24:52.490
And so, annoyingly, I
don't get to see it.

00:24:52.490 --> 00:24:53.490
I just get a white page.

00:24:57.202 --> 00:24:59.660
But the browser is actually
probably doing the right thing,

00:24:59.660 --> 00:25:01.700
according to the specs.

00:25:01.700 --> 00:25:03.680
It's slightly misleading,
if you ask me,

00:25:03.680 --> 00:25:06.750
but it says that "user
agents may render text,"

00:25:06.750 --> 00:25:08.750
as if it would be
rendered if downloadable.

00:25:08.750 --> 00:25:10.320
"Font resources
are not available,

00:25:10.320 --> 00:25:12.130
or they may render
text transparently

00:25:12.130 --> 00:25:15.800
with a fallback font," to avoid
a flash of unstyled content.

00:25:15.800 --> 00:25:18.070
"In cases where the
font download fails,

00:25:18.070 --> 00:25:21.340
user agents must
display the text,

00:25:21.340 --> 00:25:23.340
simply leaving transfer
text is considered

00:25:23.340 --> 00:25:24.810
to be non-conformant."

00:25:24.810 --> 00:25:28.250
Now, it is our wonderful
browser ecosystem,

00:25:28.250 --> 00:25:31.430
and surely not everyone's going
to implement the same way.

00:25:31.430 --> 00:25:34.532
So this table was actually
taken from a friend of mine

00:25:34.532 --> 00:25:35.490
who is in the audience.

00:25:35.490 --> 00:25:39.440
He wrote a very
good post, titled,

00:25:39.440 --> 00:25:41.989
"Web Fonts and Critical
Path," by Ian Feather

00:25:41.989 --> 00:25:42.780
from Lonely Planet.

00:25:42.780 --> 00:25:44.860
But, you'll see here that
every browser's deeming it

00:25:44.860 --> 00:25:45.734
slightly differently.

00:25:45.734 --> 00:25:48.830
So, IE doesn't block at all,
and it doesn't have a timeout.

00:25:48.830 --> 00:25:52.060
Firefox does block, and it
has a three-second timeout.

00:25:52.060 --> 00:25:54.630
And Blink and Webkit do block,
but don't have a timeout.

00:25:54.630 --> 00:25:59.910
Although, they might have
changed in recent versions.

00:25:59.910 --> 00:26:01.440
But, why am I
talking about this?

00:26:01.440 --> 00:26:04.630
And this is a very
contentious subject.

00:26:04.630 --> 00:26:06.850
A lot of people
say that web fonts

00:26:06.850 --> 00:26:09.030
aren't crucial to content.

00:26:09.030 --> 00:26:13.270
I've argued throughout this
talk that the user to see also

00:26:13.270 --> 00:26:16.280
the article, Why should they
block on a certain resource?

00:26:16.280 --> 00:26:18.230
problem for us is
The Guardian, is

00:26:18.230 --> 00:26:19.730
that we are in the
content business.

00:26:19.730 --> 00:26:21.590
We are traditionally
a newspaper,

00:26:21.590 --> 00:26:24.340
that our content was
printed on paper,

00:26:24.340 --> 00:26:27.600
and the only thing that makes
The Guardian brand stand out

00:26:27.600 --> 00:26:31.060
against any other
newspaper is our typeface.

00:26:31.060 --> 00:26:33.630
And back in 2006, when we
were doing the major Guardian,

00:26:33.630 --> 00:26:36.100
rebrand, we commissioned
a font foundry

00:26:36.100 --> 00:26:38.750
to make a beautiful,
Guardian Egyptian font.

00:26:38.750 --> 00:26:41.350
And if you showed
someone the website,

00:26:41.350 --> 00:26:43.210
with or without the
font, they can instantly

00:26:43.210 --> 00:26:45.100
recognize that it's
the Guardian brand.

00:26:45.100 --> 00:26:48.280
So to us, when we were were
developing the project,

00:26:48.280 --> 00:26:49.900
we were like, "We do want that.

00:26:49.900 --> 00:26:52.085
It is part of our brand."

00:26:52.085 --> 00:26:55.080
But, going back to that idea
of progressive enhancement,

00:26:55.080 --> 00:26:58.430
are phones really a
first class citizen?

00:26:58.430 --> 00:27:00.760
We didn't think so.

00:27:00.760 --> 00:27:03.350
Especially when we've got a line
in the sand of breaking news

00:27:03.350 --> 00:27:05.770
within 1,000 milliseconds
, surely we won't be able

00:27:05.770 --> 00:27:08.350
to force the user to block.

00:27:08.350 --> 00:27:10.790
We want them to fail gracefully.

00:27:10.790 --> 00:27:12.650
Andy Hume, who now
works at Twitter,

00:27:12.650 --> 00:27:15.770
and he was our client-side
architect at the time,

00:27:15.770 --> 00:27:19.570
came up with this idea of fonts
as a progressive enhancement.

00:27:19.570 --> 00:27:22.320
What if we could progressively
enhance the page,

00:27:22.320 --> 00:27:25.270
and not cause the user
to block rendering?

00:27:25.270 --> 00:27:27.149
So that's what we do.

00:27:27.149 --> 00:27:29.190
The first thing we do, is
we asked whether or not

00:27:29.190 --> 00:27:30.523
the browser is a modern browser.

00:27:30.523 --> 00:27:33.350
We use the BBC'S "cutting
the mustard" test.

00:27:33.350 --> 00:27:36.040
So, if it's not then
showing the fallback font,

00:27:36.040 --> 00:27:36.950
we don't really care.

00:27:41.260 --> 00:27:42.860
Do they support WOFF?

00:27:42.860 --> 00:27:45.370
Do they support
modern font files?

00:27:45.370 --> 00:27:48.760
If not, they can have
the fallback font.

00:27:48.760 --> 00:27:53.110
If the font's in local
storage, if so, great.

00:27:53.110 --> 00:27:55.760
Let's use it, let's
render, let's go.

00:27:55.760 --> 00:28:00.280
If not, do we have enough
local storage space?

00:28:00.280 --> 00:28:03.015
We'll then download
a single JSON file.

00:28:03.015 --> 00:28:04.990
And we'll talk about
this in a second.

00:28:04.990 --> 00:28:07.610
Once we've got that, we
store it in local storage,

00:28:07.610 --> 00:28:10.260
and then eventually, we
can then render again.

00:28:10.260 --> 00:28:11.620
Never blocking rendering.

00:28:11.620 --> 00:28:13.950
Avoiding that flash of fallback.

00:28:13.950 --> 00:28:17.430
But, more importantly,
reducing HTTP requests,

00:28:17.430 --> 00:28:20.150
for maybe five or six font
requests, down to a single HTTP

00:28:20.150 --> 00:28:25.390
request, and caching that
aggressively, in local storage.

00:28:25.390 --> 00:28:27.600
And so, what we do is,
we actually base-64

00:28:27.600 --> 00:28:30.820
encoding the font file into
string, with the key being

00:28:30.820 --> 00:28:33.070
the font name, and then
the value being-- now,

00:28:33.070 --> 00:28:36.110
yes, I know that base-64
encoding a font file

00:28:36.110 --> 00:28:38.780
is actually going to
increase it in size,

00:28:38.780 --> 00:28:44.120
but the trade off here for us is
having that one resilient HTTP

00:28:44.120 --> 00:28:46.530
request, rather than multiple
that can take longer.

00:28:46.530 --> 00:28:49.180
And we can actually
catch that aggressively

00:28:49.180 --> 00:28:51.240
inside local storage.

00:28:51.240 --> 00:28:54.820
And so we opensource that, as
with most of the things we do.

00:28:54.820 --> 00:28:58.010
So you can check out
the MPM package web font

00:28:58.010 --> 00:29:02.060
JSON, or the Grunt web font.

00:29:02.060 --> 00:29:06.980
But again, there must be
a better solution to this.

00:29:06.980 --> 00:29:11.179
The first one is the
font loading spec.

00:29:11.179 --> 00:29:13.220
This is actually being
implemented in JavaScript.

00:29:13.220 --> 00:29:15.072
I know Chrome would
definitely work in it.

00:29:15.072 --> 00:29:16.780
Jake actually has got
a great post on it.

00:29:16.780 --> 00:29:18.830
But the most exciting
to me of this,

00:29:18.830 --> 00:29:23.230
is it uses the new
native DOM Promises API,

00:29:23.230 --> 00:29:25.300
so that you can
actually use promises

00:29:25.300 --> 00:29:26.530
to do things with events.

00:29:26.530 --> 00:29:29.330
We have a lot more greater
power over controlling

00:29:29.330 --> 00:29:33.700
when and when not do fonts get
loaded, and what to do in cases

00:29:33.700 --> 00:29:34.810
and fall back events.

00:29:34.810 --> 00:29:36.380
All with native Promises.

00:29:36.380 --> 00:29:40.419
So it's amazing, allowed
us much finer control.

00:29:40.419 --> 00:29:42.627
But this is probably one of
the most important things

00:29:42.627 --> 00:29:44.700
I'm going to to say
tonight, is ServiceWorker.

00:29:44.700 --> 00:29:47.650
To me, this combined
with http/2,

00:29:47.650 --> 00:29:49.740
are literally the
most important things

00:29:49.740 --> 00:29:52.470
coming to the webstack
over the next five years.

00:29:52.470 --> 00:29:54.640
This is going to literally
revolutionize, and change

00:29:54.640 --> 00:29:57.280
the way we develop
web applications.

00:29:57.280 --> 00:30:00.500
And, as I mentioned at
the beginning, for me,

00:30:00.500 --> 00:30:02.850
progressive enhancement
is resilience.

00:30:02.850 --> 00:30:06.410
And ServiceWorker is designed
for an offline world,

00:30:06.410 --> 00:30:08.640
having offline-first
web applications.

00:30:08.640 --> 00:30:10.620
But for me, more
importantly, it's

00:30:10.620 --> 00:30:12.780
about having resilient
web applications.

00:30:12.780 --> 00:30:15.750
Ones that don't care about
the networking, don't care

00:30:15.750 --> 00:30:17.655
about the network
stuff-- will always still

00:30:17.655 --> 00:30:21.260
be able to render, regardless
of the location you are,

00:30:21.260 --> 00:30:22.830
or whether or not
you have network.

00:30:25.930 --> 00:30:30.270
ServiceWorker is a
separate process,

00:30:30.270 --> 00:30:32.830
one that's intercepting every
single one of the networking

00:30:32.830 --> 00:30:34.450
requests on the page.

00:30:34.450 --> 00:30:36.810
And then, you can actually
decide whether or not

00:30:36.810 --> 00:30:38.730
you want to respond
from network,

00:30:38.730 --> 00:30:40.100
or respond from a cache.

00:30:40.100 --> 00:30:42.260
So, we now have
new cache objects

00:30:42.260 --> 00:30:45.590
coming to JavaScript-- much
more advanced caches that

00:30:45.590 --> 00:30:48.540
will be able to store
items, and retrieve them,

00:30:48.540 --> 00:30:51.030
based on certain keys.

00:30:51.030 --> 00:30:53.306
Imagine my CSS is
in local storage,

00:30:53.306 --> 00:30:54.430
my font's in local storage.

00:30:54.430 --> 00:30:57.030
Now I can actually have a
place where I can cache this.

00:30:57.030 --> 00:30:59.006
But, more reliably,
decide whether or not

00:30:59.006 --> 00:31:00.880
we actually want to go
back onto the network,

00:31:00.880 --> 00:31:04.252
if the user has it, or
return from a cache,

00:31:04.252 --> 00:31:05.460
even while I'm still offline.

00:31:10.360 --> 00:31:15.040
The final point here I want to
make is it's all well and good

00:31:15.040 --> 00:31:16.870
developing in your
controlled environment,

00:31:16.870 --> 00:31:19.800
with your 16 gigs
of MacBook Pro,

00:31:19.800 --> 00:31:22.300
of with that T1 connection
that your office has got .

00:31:22.300 --> 00:31:25.060
What are your real users seeing?

00:31:25.060 --> 00:31:29.300
How are these features
performing in production?

00:31:29.300 --> 00:31:32.540
How do you know if a
resources is failing?

00:31:32.540 --> 00:31:36.890
We do that with lots
of strict monitoring.

00:31:36.890 --> 00:31:42.190
The first thing is, as you
saw with the CSS in-lining,

00:31:42.190 --> 00:31:43.800
one thing I
mentioned was that we

00:31:43.800 --> 00:31:47.640
have to restrict
that file to 14 kb.

00:31:47.640 --> 00:31:50.890
A lot of you know about the
networking stat is obviously

00:31:50.890 --> 00:31:54.590
the first part the connection
window in the first few TCP

00:31:54.590 --> 00:31:59.840
packets, that we must maintain a
small enough file that it's not

00:31:59.840 --> 00:32:04.415
actually going to be
detrimental to our payload.

00:32:04.415 --> 00:32:06.181
My developers, I
saw them a lot kind

00:32:06.181 --> 00:32:07.681
of going, "That's
all well and good,

00:32:07.681 --> 00:32:11.020
but how are we going to
stick inside of this budge?"

00:32:11.020 --> 00:32:13.870
So, I wrote a Grunt
task, the NICI server,

00:32:13.870 --> 00:32:17.090
it monitors the size of
all of our static assets,

00:32:17.090 --> 00:32:19.560
and pinging back to
an Amazon CloudWatch

00:32:19.560 --> 00:32:22.220
the raw and GZIP
file size of that.

00:32:22.220 --> 00:32:24.640
So, then I could use
CloudWatch's fresh holding

00:32:24.640 --> 00:32:26.660
and alerting on
that, to I literally

00:32:26.660 --> 00:32:29.350
get an email when we
commit some code that

00:32:29.350 --> 00:32:32.914
breaks the CSS past
its 14k budget.

00:32:32.914 --> 00:32:34.330
Because I found
myself quite a lot

00:32:34.330 --> 00:32:37.625
of having to keep a watchful
eye on our pull requests

00:32:37.625 --> 00:32:41.850
on GitHub, of saying "Is
your feature really critical?

00:32:41.850 --> 00:32:44.500
Does it need to be
inlined in the head?

00:32:44.500 --> 00:32:46.730
Is it about the fold?

00:32:46.730 --> 00:32:49.800
Are users really going to
interact with that instantly?

00:32:49.800 --> 00:32:52.720
But now, I have a
system that tells me

00:32:52.720 --> 00:32:55.920
when we've broken that budget.

00:32:55.920 --> 00:32:59.450
And so, real user metrics.

00:32:59.450 --> 00:33:01.180
Having synthetic
analysis is good,

00:33:01.180 --> 00:33:04.770
but knowing when
and how something's

00:33:04.770 --> 00:33:07.970
broken in production,
or how fast your site is

00:33:07.970 --> 00:33:10.210
is in production in
real time, has literally

00:33:10.210 --> 00:33:11.440
been invaluable to us.

00:33:11.440 --> 00:33:15.520
We use the navigation
timing API to beacon back.

00:33:15.520 --> 00:33:18.020
We have an in-house
analytics tool, called Ophan,

00:33:18.020 --> 00:33:21.650
that was actually a system
designed for the editorial tool

00:33:21.650 --> 00:33:24.010
team, based of one
of our Hack Days,

00:33:24.010 --> 00:33:26.990
but then turned into a
fully-fledged product.

00:33:26.990 --> 00:33:30.770
It allows the journalist to
see what content is trending

00:33:30.770 --> 00:33:33.660
in real time, where
referrals are coming from,

00:33:33.660 --> 00:33:34.850
what was recently published.

00:33:34.850 --> 00:33:36.760
They use it as their
day-to-day [INAUDIBLE].

00:33:36.760 --> 00:33:39.050
But we were beaconing
back information,

00:33:39.050 --> 00:33:41.090
so as engineers we were
like, "Hang on a second.

00:33:41.090 --> 00:33:42.214
We're missing a trick here.

00:33:42.214 --> 00:33:44.820
We can add some of our
own data to that request,

00:33:44.820 --> 00:33:46.190
and they'll never know."

00:33:46.190 --> 00:33:48.480
So, we started using
the navigation timing

00:33:48.480 --> 00:33:52.280
API that exposes all
of the timing data,

00:33:52.280 --> 00:33:54.500
down to the millisecond
of the core loading

00:33:54.500 --> 00:33:55.390
events for the page.

00:33:55.390 --> 00:33:57.848
So, your DNS lookup, all the
way through to your final load

00:33:57.848 --> 00:33:58.360
event.

00:33:58.360 --> 00:34:00.443
There's a lot of great
third-party tools out here.

00:34:00.443 --> 00:34:03.250
You don't have to
just roll your own.

00:34:03.250 --> 00:34:07.240
Here, you can see our
median average is perfectly

00:34:07.240 --> 00:34:10.480
staying underneath
our 1k budget.

00:34:10.480 --> 00:34:12.810
Compared to the
old website, which

00:34:12.810 --> 00:34:16.280
got its horrible
12-second media load time,

00:34:16.280 --> 00:34:19.540
in its four-second
DOM content ready.

00:34:19.540 --> 00:34:21.699
In real time, more
importantly, I

00:34:21.699 --> 00:34:24.030
can know if a deployment
that I've just made

00:34:24.030 --> 00:34:26.080
has affected our performance.

00:34:26.080 --> 00:34:28.400
This is one of our developers.

00:34:28.400 --> 00:34:32.440
Two weeks ago, we
started unloaded WOFF 2.

00:34:32.440 --> 00:34:35.670
So, it's actually only supported
by Chrome at the moment.

00:34:35.670 --> 00:34:39.639
But, we could filter to see by
device, by user in [INAUDIBLE]

00:34:39.639 --> 00:34:44.050
Chrome, and instantly see
the impact that had on users.

00:34:44.050 --> 00:34:46.940
And amazingly, because of the
way that WOFF 2 is constructed,

00:34:46.940 --> 00:34:49.389
you actually get a lot
smaller file sizes,

00:34:49.389 --> 00:34:52.080
we managed to shave
off 400 milliseconds,

00:34:52.080 --> 00:34:55.429
just by doing that
changed to our fonts.

00:34:55.429 --> 00:34:59.811
But, knowing in real
time how we did it.

00:34:59.811 --> 00:35:01.310
This isn't really
about performance,

00:35:01.310 --> 00:35:02.470
but I sneaked it in
here, because it's

00:35:02.470 --> 00:35:04.094
one of my favorite
tools at the moment.

00:35:04.094 --> 00:35:06.270
This is called Century.

00:35:06.270 --> 00:35:09.200
We wanted to know how our
JavaScript was performing

00:35:09.200 --> 00:35:11.270
in production, and
if it was breaking.

00:35:11.270 --> 00:35:14.230
You can never test on
every single permutation

00:35:14.230 --> 00:35:16.910
of JavaScript engine device,
and operating system,

00:35:16.910 --> 00:35:19.617
and browser, even if you've
got a fully-fleshed device lab.

00:35:19.617 --> 00:35:21.950
There's no way that you'll
be able to test on every one.

00:35:21.950 --> 00:35:24.510
So, what if you were to monkey
patch window [INAUDIBLE]

00:35:24.510 --> 00:35:27.670
on error, catching all of
the events, and beaconing

00:35:27.670 --> 00:35:29.730
them back to a server
so that you can then

00:35:29.730 --> 00:35:31.610
aggregate those results.

00:35:31.610 --> 00:35:33.840
This is exactly what
Century does for us.

00:35:33.840 --> 00:35:36.040
I can now, in real
time, get an alert

00:35:36.040 --> 00:35:38.230
if we introduce a new
JavaScript error in production

00:35:38.230 --> 00:35:40.771
that we might not have caught
for unit testing or integration

00:35:40.771 --> 00:35:41.779
testing.

00:35:41.779 --> 00:35:44.070
Give me a breakdown of the
browsers that it's happening

00:35:44.070 --> 00:35:46.590
on, the build number of our
server that's happening on it,

00:35:46.590 --> 00:35:49.570
but the most amazing
thing is literally,

00:35:49.570 --> 00:35:50.670
it gives me a stack trace.

00:35:50.670 --> 00:35:54.300
It tells me where
in my code base

00:35:54.300 --> 00:35:55.940
the JavaScript
error's being thrown.

00:35:55.940 --> 00:35:58.310
Through the next resource
maps, we can now even

00:35:58.310 --> 00:36:00.580
get that back to
a single module.

00:36:00.580 --> 00:36:04.100
Again, your system telling
you of its own ill health,

00:36:04.100 --> 00:36:05.350
automating this.

00:36:05.350 --> 00:36:07.296
It's amazing.

00:36:07.296 --> 00:36:08.920
I mentioned [INAUDIBLE]
and monitoring,

00:36:08.920 --> 00:36:12.630
but obviously there's always a
place for synthetic analysis,

00:36:12.630 --> 00:36:15.274
so you can track your trends
and outliers over time.

00:36:15.274 --> 00:36:16.440
For this, we use SpeedCurve.

00:36:19.320 --> 00:36:21.230
The greatest thing
about it has been

00:36:21.230 --> 00:36:22.950
how we expose it
to the business,

00:36:22.950 --> 00:36:27.240
or how by default it exposes
itself to the business.

00:36:27.240 --> 00:36:29.220
We made sure, as a
team that actually,

00:36:29.220 --> 00:36:31.000
rather than just
it going to myself,

00:36:31.000 --> 00:36:33.760
it goes through a distribution
list for the whole department.

00:36:33.760 --> 00:36:38.270
So, we get a weekly email every
Monday morning from SpeedCurve,

00:36:38.270 --> 00:36:42.980
telling us how our site
performed over the last two

00:36:42.980 --> 00:36:44.520
weeks.

00:36:44.520 --> 00:36:47.610
This makes everyone accountable
for the change, which

00:36:47.610 --> 00:36:49.820
is extremely
important when you're

00:36:49.820 --> 00:36:52.430
trying to change performance
culture within a business.

00:36:52.430 --> 00:36:55.350
So, the great thing here is
that I might have not noticed

00:36:55.350 --> 00:36:58.120
that we've actually gone up with
our median load time last week,

00:36:58.120 --> 00:37:00.010
but then my product
[INAUDIBLE] on a Monday morning

00:37:00.010 --> 00:37:02.050
gets an email saying
that, and he can instantly

00:37:02.050 --> 00:37:03.841
email me saying, "Hang
on a second Patrick.

00:37:03.841 --> 00:37:04.920
What we did last week?"

00:37:04.920 --> 00:37:07.800
This has been invaluable.

00:37:07.800 --> 00:37:10.860
And lastly, once you're
getting and gathering

00:37:10.860 --> 00:37:12.650
all this metric
data please, make

00:37:12.650 --> 00:37:15.450
sure to set alerts
and thresholds on it.

00:37:15.450 --> 00:37:18.150
Your thresholds will probably
be wrong the first few times--

00:37:18.150 --> 00:37:20.360
with kind of outliers,
and boy-who-cries-wolf--

00:37:20.360 --> 00:37:23.140
but with this, you'll
be able to tell them,

00:37:23.140 --> 00:37:26.830
and then know instantly if
you've broken your performance

00:37:26.830 --> 00:37:28.960
budget.

00:37:28.960 --> 00:37:33.230
Again, last section: what does
the future hold for us on this?

00:37:33.230 --> 00:37:35.970
The first one is, not
timing API is great,

00:37:35.970 --> 00:37:38.700
but for security
reasons, only gives you

00:37:38.700 --> 00:37:40.950
access to the initial
HTML document.

00:37:40.950 --> 00:37:42.770
But what you surely
want to measure,

00:37:42.770 --> 00:37:45.520
all of maybe the third parties,
or using the Facebook API,

00:37:45.520 --> 00:37:46.940
you want to know
when that breaks.

00:37:46.940 --> 00:37:51.140
Or even our own services that
I'm progressively enhancing in:

00:37:51.140 --> 00:37:53.320
how do I know if one of
those features dies out?

00:37:53.320 --> 00:37:56.380
So, we've got a new
resource timing API,

00:37:56.380 --> 00:37:58.110
applying a header
to those resources,

00:37:58.110 --> 00:37:59.970
it tells the
browser, "Yep, you're

00:37:59.970 --> 00:38:02.620
safe to give this
user in his JavaScript

00:38:02.620 --> 00:38:04.505
the timing information
for these requests."

00:38:04.505 --> 00:38:08.040
So then again, you beacon them
back into real-user monitoring.

00:38:08.040 --> 00:38:10.390
Set your alerts, so
you can even when

00:38:10.390 --> 00:38:14.386
you're external services or
internal services go down.

00:38:14.386 --> 00:38:15.510
And lastly, the Beacon API.

00:38:15.510 --> 00:38:18.130
This is one of my favorite APIs.

00:38:18.130 --> 00:38:20.500
So, we're gathering
all this data--

00:38:20.500 --> 00:38:21.980
and unfortunately,
the pure nature

00:38:21.980 --> 00:38:26.070
of analytics, the old hack
has been using an image tag

00:38:26.070 --> 00:38:28.320
to send these
quick, simple, dirty

00:38:28.320 --> 00:38:30.110
get requests, or post requests.

00:38:33.000 --> 00:38:35.700
Beacon API allows you to
make asynchronous requests.

00:38:35.700 --> 00:38:37.240
So, you tell the
browser, "Right, I

00:38:37.240 --> 00:38:40.456
want you to send off all this
metric data back to my service,

00:38:40.456 --> 00:38:42.830
but I don't care when you
perform the networking for it."

00:38:42.830 --> 00:38:44.960
Or, more importantly,
let the browser

00:38:44.960 --> 00:38:48.320
decide when it
has networking for

00:38:48.320 --> 00:38:50.180
And that's very
crucial on mobile,

00:38:50.180 --> 00:38:52.796
because the browser knows
when the radio is active,

00:38:52.796 --> 00:38:54.170
but you as a web
developer don't.

00:38:58.040 --> 00:39:01.440
My final point is that having
these lines in the sand

00:39:01.440 --> 00:39:06.170
has enabled us to create a
conversation with everyone

00:39:06.170 --> 00:39:08.540
in the company, be it a
designer, a product-owner,

00:39:08.540 --> 00:39:11.150
a stakeholder, or
third parties even.

00:39:11.150 --> 00:39:13.394
It allows us to say, no
"No, we can't actually

00:39:13.394 --> 00:39:15.060
do the design for
that feature that way,

00:39:15.060 --> 00:39:17.887
because it will break
this line in the sand."

00:39:17.887 --> 00:39:19.970
It allows you to start
having these conversations,

00:39:19.970 --> 00:39:20.820
creating rules around.

00:39:20.820 --> 00:39:21.340
Them

00:39:21.340 --> 00:39:23.890
And, if you're going
to stay for the pub

00:39:23.890 --> 00:39:26.250
I'd be really interested
to hear if any of you

00:39:26.250 --> 00:39:27.890
have got the same rules.

00:39:27.890 --> 00:39:30.400
Or, tell me about how
you're implementing budgets

00:39:30.400 --> 00:39:32.867
within inside your
organizations.

00:39:32.867 --> 00:39:34.700
So finally, here's some
takeaways and things

00:39:34.700 --> 00:39:36.660
that I've learned along the way.

00:39:36.660 --> 00:39:40.870
Everyone must be involved
in baking performance

00:39:40.870 --> 00:39:42.570
into your workflow from day on."

00:39:42.570 --> 00:39:44.829
This is not something
that you can retrofit.

00:39:44.829 --> 00:39:46.370
It's not something
you can chuck over

00:39:46.370 --> 00:39:48.328
the wall to your operations
team, "Don't worry,

00:39:48.328 --> 00:39:50.220
they'll sort out the
performance problems."

00:39:50.220 --> 00:39:54.020
Performance is a
first class citizen.

00:39:54.020 --> 00:39:55.680
It must be part of
all discussions you

00:39:55.680 --> 00:39:58.280
have for new
features, and everyone

00:39:58.280 --> 00:40:00.680
should be held accountable
for change in performance.

00:40:03.540 --> 00:40:07.340
I hope this resonated
throughout my talk--

00:40:07.340 --> 00:40:09.380
just deliver your
core content first ,

00:40:09.380 --> 00:40:12.490
and then progressively
enhance the rest of it.

00:40:12.490 --> 00:40:17.400
Set a performance budget, but
measure, optimize, and repeat.

00:40:17.400 --> 00:40:18.542
Constantly, right?

00:40:18.542 --> 00:40:20.500
And again, it's not
something that you can just

00:40:20.500 --> 00:40:23.609
do now for a month: "We'll focus
on performance for two weeks.

00:40:23.609 --> 00:40:24.650
It's gonna make it fast."

00:40:24.650 --> 00:40:26.600
Your site will slow down .

00:40:26.600 --> 00:40:28.560
I promise you that.

00:40:28.560 --> 00:40:30.660
That's the nature of
building software.

00:40:30.660 --> 00:40:32.770
Products do slow down,
so you have to constantly

00:40:32.770 --> 00:40:35.710
be measuring, and
optimizing, and repeating.

00:40:35.710 --> 00:40:38.750
One of my favorite quotes
from Paul is, "Don't guess it,

00:40:38.750 --> 00:40:40.022
test it."

00:40:40.022 --> 00:40:40.980
Isn't that right, Paul?

00:40:40.980 --> 00:40:43.492
PAUL: Yes.

00:40:43.492 --> 00:40:44.950
PATRICK HAMMAN:
And the final point

00:40:44.950 --> 00:40:47.210
is, it is the requirement.

00:40:47.210 --> 00:40:50.330
It's not a feature.

00:40:50.330 --> 00:40:53.180
Thank you.

00:40:53.180 --> 00:40:57.710
The whole project
is open on GitHub,

00:40:57.710 --> 00:41:00.077
so if you want to find
out more about the code,

00:41:00.077 --> 00:41:02.160
and how we're doing it,
go and check it out there,

00:41:02.160 --> 00:41:04.665
and you can touch my
slides at that URL.

00:41:04.665 --> 00:41:06.454
Thank you.

00:41:06.454 --> 00:41:11.822
[APPLAUSE]

00:41:14.270 --> 00:41:16.520
MALE SPEAKER: So, you load
the content in last, right?

00:41:16.520 --> 00:41:18.309
PATRICK HAMMAN: Yeah (CHUCKLES).

00:41:18.309 --> 00:41:20.600
MALE SPEAKER: Thank you,
again, so much for coming out.

00:41:20.600 --> 00:41:22.950
Sorry it;s run on a
little bit longer tonight,

00:41:22.950 --> 00:41:24.540
but I hope you've
enjoyed yourselves.

00:41:24.540 --> 00:41:26.020
If you can, do
join us at the pub,

00:41:26.020 --> 00:41:29.697
and if you just give our
speakers-- Addy, Nat,

00:41:29.697 --> 00:41:32.030
and Patrick-- one more of
applause, that would be great.

00:41:32.030 --> 00:41:35.980
Thank you. [APPLAUSE]

