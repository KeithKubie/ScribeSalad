WEBVTT
Kind: captions
Language: en

00:00:01.912 --> 00:00:03.350
BRENDAN KENNY: Hi.

00:00:03.350 --> 00:00:06.640
Welcome to Spatial Data
Visualization.

00:00:06.640 --> 00:00:07.660
My name is Brendan Kenny.

00:00:07.660 --> 00:00:09.680
I'm an engineer with
the Maps Developer

00:00:09.680 --> 00:00:10.870
Relations team at Google.

00:00:10.870 --> 00:00:13.300
And this Enoch Lau, who's
an engineer with

00:00:13.300 --> 00:00:15.100
the Maps API Team.

00:00:15.100 --> 00:00:18.030
And we're here today to talk
to you about spatial data

00:00:18.030 --> 00:00:19.790
visualization.

00:00:19.790 --> 00:00:28.830
So most of the data that we as
developers deal with, it's

00:00:28.830 --> 00:00:30.730
usually geo-related.

00:00:30.730 --> 00:00:35.650
In some way, it is associated
with place, whether that's

00:00:35.650 --> 00:00:38.740
explicitly, actually data
collected about specific

00:00:38.740 --> 00:00:41.110
locations and actually
associated with a

00:00:41.110 --> 00:00:44.520
latitude-longitude or a place
name, or implicitly--

00:00:44.520 --> 00:00:48.560
for instance, data associated
with demographics then you can

00:00:48.560 --> 00:00:50.490
associate with place.

00:00:50.490 --> 00:00:54.620
And as the computer revolution
continues and we get more and

00:00:54.620 --> 00:00:59.040
more data, we are getting to
a point where we can also

00:00:59.040 --> 00:01:01.200
visualize all that data, and
all this data that's been

00:01:01.200 --> 00:01:06.610
locked up behind tables and
tables of numbers can start

00:01:06.610 --> 00:01:09.890
becoming visual, which gives
insight and exposes patterns

00:01:09.890 --> 00:01:11.940
that we might not have
ever seen before.

00:01:11.940 --> 00:01:14.900
And so we want to talk to you
today about the tools that you

00:01:14.900 --> 00:01:17.750
can use to start doing that
with the Maps API.

00:01:17.750 --> 00:01:21.060
And Enoch is going to start us
off with things you can do

00:01:21.060 --> 00:01:22.310
right now with the Maps API.

00:01:26.120 --> 00:01:28.100
ENOCH LAU: So as the name
suggests, spatial data

00:01:28.100 --> 00:01:32.330
visualization is all about
spatially representing your

00:01:32.330 --> 00:01:37.010
data, which has some spatial
component visually.

00:01:37.010 --> 00:01:39.440
And what better way
to represent this

00:01:39.440 --> 00:01:40.800
data than on a map?

00:01:40.800 --> 00:01:44.480
So a very common way of
representing spatial data

00:01:44.480 --> 00:01:49.270
using the Maps API is using the
Google Maps market class.

00:01:49.270 --> 00:01:52.560
And what I have here on the
screen is a standard default

00:01:52.560 --> 00:01:54.530
Google Maps marker.

00:01:54.530 --> 00:01:59.030
So what I have here is a data
set containing the location of

00:01:59.030 --> 00:02:00.720
airports around the world.

00:02:00.720 --> 00:02:04.370
And for each airport, I've
placed one marker on the map.

00:02:04.370 --> 00:02:06.590
And as you can see, there
are a lot of markers.

00:02:06.590 --> 00:02:09.910
So one thing that we can do to
enhance this visualization to

00:02:09.910 --> 00:02:13.530
make it clearer where the
airports are, we can use

00:02:13.530 --> 00:02:14.680
custom icons.

00:02:14.680 --> 00:02:18.000
And with the Google Maps API,
you can replace the standard

00:02:18.000 --> 00:02:21.150
Google Maps marker icon
with your own icon.

00:02:21.150 --> 00:02:26.590
So what I've done is replaced
the marker with a small red

00:02:26.590 --> 00:02:27.950
circle or dot.

00:02:27.950 --> 00:02:33.410
And I've used that image
as the marker icon.

00:02:33.410 --> 00:02:34.970
There's some additional
visualizations that you can

00:02:34.970 --> 00:02:37.280
use with Maps API.

00:02:37.280 --> 00:02:40.270
So there is a popular marker
clusterer library, which is an

00:02:40.270 --> 00:02:43.520
open source library that you
can use in conjunction with

00:02:43.520 --> 00:02:45.220
the Google Maps API.

00:02:45.220 --> 00:02:48.930
And what the marker clusterer
does is, for a large group of

00:02:48.930 --> 00:02:53.140
markers, it summarizes
them into one marker.

00:02:53.140 --> 00:02:58.080
So as you can see, on the West
Coast of the US, it summarizes

00:02:58.080 --> 00:03:02.140
a whole bunch of markers into
one red marker, which

00:03:02.140 --> 00:03:05.990
represents over 100 airports
in that one marker.

00:03:05.990 --> 00:03:09.670
And if I click on one of these
markers, it then expands

00:03:09.670 --> 00:03:13.400
through to represent the markers
that were summarized

00:03:13.400 --> 00:03:14.070
within that.

00:03:14.070 --> 00:03:17.850
So this is a very powerful way
to show lots of data on the

00:03:17.850 --> 00:03:19.790
map without overcluttering
the map.

00:03:23.450 --> 00:03:26.990
So another popular way of
representing geospatial data

00:03:26.990 --> 00:03:29.270
is through the use
of heat maps.

00:03:29.270 --> 00:03:34.770
So a heat map is a map of
intensity or density, how many

00:03:34.770 --> 00:03:37.520
points there are in
a given region.

00:03:37.520 --> 00:03:39.760
So it doesn't represent
temperature.

00:03:39.760 --> 00:03:42.010
It represents intensity
or density.

00:03:42.010 --> 00:03:44.590
And what I have here is, again,
the airports data

00:03:44.590 --> 00:03:47.030
represented using a heat map.

00:03:47.030 --> 00:03:50.710
So in this particular example,
green means that there are few

00:03:50.710 --> 00:03:52.280
airports in that area.

00:03:52.280 --> 00:03:55.050
And orange means that
there are more

00:03:55.050 --> 00:03:56.210
airports in that area.

00:03:56.210 --> 00:04:00.510
So it's quite easy to see, using
a heat map, where the

00:04:00.510 --> 00:04:02.420
airports are in the world.

00:04:02.420 --> 00:04:05.200
So I'm pleased to announce today
that from today, you'll

00:04:05.200 --> 00:04:10.230
be able to use a new
HeatmapLayer in the Maps API.

00:04:10.230 --> 00:04:14.350
So the new HeatmapLayer is in
the visualization library.

00:04:14.350 --> 00:04:18.190
So to use it, when you're
including the Maps API script,

00:04:18.190 --> 00:04:22.029
you specify that you want the
visualization library.

00:04:22.029 --> 00:04:25.550
Then, once you've done that,
you can instantiate a new

00:04:25.550 --> 00:04:28.065
HeatmapLayer by writing
new Google.maps.visu

00:04:28.065 --> 00:04:29.315
alization.HeatmapLayer.

00:04:32.340 --> 00:04:34.600
And in the constructor
you [? pass ?]

00:04:34.600 --> 00:04:37.380
an array of positions, an
array of lat-longs.

00:04:37.380 --> 00:04:42.666
And these positions will be used
to populate your Heatmap.

00:04:42.666 --> 00:04:45.420
So just to give you an example
of how dynamic this

00:04:45.420 --> 00:04:48.340
HeatmapLayer is, I have
an example here where

00:04:48.340 --> 00:04:49.490
I have a heat map.

00:04:49.490 --> 00:04:53.370
And I'm adding points to
the map on mouseover.

00:04:53.370 --> 00:04:55.780
So one key feature of the
HeatmapLayer is that it's

00:04:55.780 --> 00:04:59.550
rendered client size, rendered
in JavaScript in the browser.

00:04:59.550 --> 00:05:02.350
And it works in all supported
browsers that the Maps API

00:05:02.350 --> 00:05:03.600
supports except for IE7.

00:05:06.980 --> 00:05:10.140
And it's all rendered in the
browser, so you can filter

00:05:10.140 --> 00:05:12.430
your data in the client.

00:05:12.430 --> 00:05:15.260
You can change which points are
displayed dynamically on

00:05:15.260 --> 00:05:17.740
the fly and let that be
repopulated for you.

00:05:22.350 --> 00:05:25.380
So just to give you an example
of how I built this particular

00:05:25.380 --> 00:05:28.250
heatmap, let's start with
a very basic example.

00:05:28.250 --> 00:05:33.190
I've taken all the points in my
data set for the airports,

00:05:33.190 --> 00:05:36.880
and I've placed them on the
map using a HeatmapLayer.

00:05:36.880 --> 00:05:40.390
So this is an example just using
the default styling,

00:05:40.390 --> 00:05:42.180
using the default behavior.

00:05:42.180 --> 00:05:44.695
I'm just putting all this data
into the HeatmapLayer and

00:05:44.695 --> 00:05:46.055
letting it do its magic.

00:05:46.055 --> 00:05:48.480
So this is what it looks like.

00:05:48.480 --> 00:05:56.130
And notice that when I zoom in,
the points dissipate, or

00:05:56.130 --> 00:05:57.460
they sort of disappear.

00:05:57.460 --> 00:06:01.990
And by default, each point
has a fixed radius.

00:06:01.990 --> 00:06:04.830
And that fixed radius is
expressed in pixels.

00:06:04.830 --> 00:06:08.460
So as you zoom in, the points
separate out in space.

00:06:08.460 --> 00:06:10.750
And you may lose track of
where your points are.

00:06:10.750 --> 00:06:13.880
So one feature of the new
HeatmapsLayer is the ability

00:06:13.880 --> 00:06:16.800
to specify that you do not want

00:06:16.800 --> 00:06:18.390
this dissipating behavior.

00:06:18.390 --> 00:06:23.420
So in this particular example
here when I zoom in, you see

00:06:23.420 --> 00:06:25.450
the same heatmap, just
blown up larger.

00:06:25.450 --> 00:06:31.430
So this is great if you want
to be able to examine in

00:06:31.430 --> 00:06:35.010
detail an area a little bit more
and to see the same image

00:06:35.010 --> 00:06:36.790
as you did further out.

00:06:39.500 --> 00:06:42.280
So there's some other options
that you can play with when

00:06:42.280 --> 00:06:45.910
building a heatmap using
the new HeatmapLayer.

00:06:45.910 --> 00:06:46.930
And you can change the radius.

00:06:46.930 --> 00:06:49.410
So you can change the radius
of influence of each

00:06:49.410 --> 00:06:51.390
particular data point.

00:06:51.390 --> 00:06:53.660
So here, I've made it 24
pixels, much larger.

00:06:53.660 --> 00:06:56.660
And you can see a more general
trend when you

00:06:56.660 --> 00:06:57.950
increase the radius.

00:06:57.950 --> 00:07:00.320
But I like a more
detailed map.

00:07:00.320 --> 00:07:02.855
So in my example I've chosen
a smaller radius.

00:07:07.280 --> 00:07:09.050
Next, we can apply styling.

00:07:09.050 --> 00:07:11.350
So with the new HeatmapLayer,
you can change the gradient.

00:07:11.350 --> 00:07:15.650
You can change the colors that
different intensities or

00:07:15.650 --> 00:07:16.970
densities map to.

00:07:16.970 --> 00:07:21.080
So I changed the gradient,
the default gradient.

00:07:21.080 --> 00:07:23.800
And now I've chosen my own
gradient that runs from green

00:07:23.800 --> 00:07:25.010
through to orange.

00:07:25.010 --> 00:07:28.280
At the same time, I've applied
a style to the map.

00:07:28.280 --> 00:07:31.460
So using styled maps, I can
change the appearance of the

00:07:31.460 --> 00:07:34.610
base layers on the map so that
it better complements my

00:07:34.610 --> 00:07:37.550
particular heatmap.

00:07:37.550 --> 00:07:43.160
So notice here that the heatmap
kind of leaks into the

00:07:43.160 --> 00:07:46.450
ocean, because the points have
a certain radius, and many

00:07:46.450 --> 00:07:49.320
airports are, in fact,
near the ocean.

00:07:49.320 --> 00:07:52.970
So what I can do to pretty this
up a little bit more is

00:07:52.970 --> 00:07:56.690
overlay it with a series
of ocean polygons.

00:07:56.690 --> 00:08:00.370
And that just brings out the
sharp outlines of continents a

00:08:00.370 --> 00:08:03.320
bit more and makes the map a
little bit more understandable

00:08:03.320 --> 00:08:05.460
as you can more easily
see these

00:08:05.460 --> 00:08:07.880
recognizable continent shapes.

00:08:07.880 --> 00:08:10.210
OK, so that's how I built
this particular heatmap.

00:08:16.010 --> 00:08:18.290
Just to give you another
example of the power of

00:08:18.290 --> 00:08:22.690
heatmaps, this example here
uses data that illustrates

00:08:22.690 --> 00:08:25.830
where people look at on the
map using Google Maps

00:08:25.830 --> 00:08:27.620
and the Maps API.

00:08:27.620 --> 00:08:30.820
So bright areas are where
people look at more.

00:08:30.820 --> 00:08:34.120
And dark areas are where
people look at less.

00:08:34.120 --> 00:08:36.590
So what we've done
here is overlayed

00:08:36.590 --> 00:08:38.320
the map with a heatmap.

00:08:38.320 --> 00:08:42.640
And instead of just being
overlay, this heatmap brings

00:08:42.640 --> 00:08:49.740
out and enhances the underlying
map tiles, so that

00:08:49.740 --> 00:08:52.020
it draws your attention to
those areas that are more

00:08:52.020 --> 00:08:56.710
trafficked by making them
brighter and more visible.

00:08:56.710 --> 00:08:59.850
And this is one example of how
you can use a heatmap in your

00:08:59.850 --> 00:09:01.100
application.

00:09:03.830 --> 00:09:08.070
So we've explored the idea of
location as being a very

00:09:08.070 --> 00:09:11.040
important idea in spatial
data visualization.

00:09:11.040 --> 00:09:14.550
There are other attributes on
the map that you can explore

00:09:14.550 --> 00:09:17.130
and change.

00:09:17.130 --> 00:09:21.890
So two other attributes that
you can explore can be the

00:09:21.890 --> 00:09:24.910
size of your particular data
points and the color of your

00:09:24.910 --> 00:09:26.640
particular data points.

00:09:26.640 --> 00:09:29.640
So what I have here is the same
airport data, but with a

00:09:29.640 --> 00:09:30.270
little bit more data.

00:09:30.270 --> 00:09:33.780
So this time, I know how many
flights arrive at that airport

00:09:33.780 --> 00:09:37.120
during a particular
24-hour period.

00:09:37.120 --> 00:09:40.590
A larger marker means that there
are more planes that

00:09:40.590 --> 00:09:43.140
arrive at that airport
during the day.

00:09:43.140 --> 00:09:45.250
And hotter colors also
mean that there

00:09:45.250 --> 00:09:47.600
are more planes arriving.

00:09:47.600 --> 00:09:51.870
So you can do this today
using a custom icon.

00:09:51.870 --> 00:09:56.480
You can specify that you want
a particular image, a

00:09:56.480 --> 00:09:57.440
particular color.

00:09:57.440 --> 00:10:02.230
You can use SVGs so that when
you scale up the custom icon,

00:10:02.230 --> 00:10:04.230
it looks pretty good.

00:10:04.230 --> 00:10:06.580
But there are still some
difficulties with

00:10:06.580 --> 00:10:08.580
using custom icons.

00:10:08.580 --> 00:10:11.890
So for example, it's difficult
to recolor an SVG file or a

00:10:11.890 --> 00:10:14.630
PNG file in the client.

00:10:14.630 --> 00:10:19.040
So if you went to the previous
talk by Thor, he mentioned

00:10:19.040 --> 00:10:21.400
that there are now symbols
in the Maps API.

00:10:21.400 --> 00:10:23.200
And this is one illustration
of the use of

00:10:23.200 --> 00:10:26.180
symbols in the Maps API.

00:10:26.180 --> 00:10:28.120
So how do we use symbols?

00:10:28.120 --> 00:10:32.840
A symbol is a substitute
for a custom icon.

00:10:32.840 --> 00:10:34.070
It has a path.

00:10:34.070 --> 00:10:37.855
And this path is expressed in
the vector format, so that

00:10:37.855 --> 00:10:41.260
when you scale it up, it
still looks great.

00:10:41.260 --> 00:10:45.800
You can also change the styling
of this symbol,

00:10:45.800 --> 00:10:49.830
independent of the path.

00:10:49.830 --> 00:10:52.410
So you can scale it up, you can
change the stroke color,

00:10:52.410 --> 00:10:54.390
you can change the fill color.

00:10:54.390 --> 00:10:56.200
And through these properties
that you can set in

00:10:56.200 --> 00:11:00.630
JavaScript, you can represent
attributes of

00:11:00.630 --> 00:11:02.810
your spatial data.

00:11:02.810 --> 00:11:05.740
So in this example here, I've
represented a circle that is

00:11:05.740 --> 00:11:07.195
of radius 10.

00:11:07.195 --> 00:11:11.020
It has a fill color blue and a
stroke color that is white.

00:11:11.020 --> 00:11:13.400
So by changing these attributes,
I can make that

00:11:13.400 --> 00:11:15.390
map that you saw on the
previous slide.

00:11:19.640 --> 00:11:25.610
So one of the great advantages
of being able to change these

00:11:25.610 --> 00:11:29.680
styling attributes in JavaScript
is that it enables

00:11:29.680 --> 00:11:36.370
you to create geo-temporal
visualizations, visualizations

00:11:36.370 --> 00:11:40.160
that represent data that not
just have a spatial component,

00:11:40.160 --> 00:11:42.290
but also a time component.

00:11:42.290 --> 00:11:48.040
So this demo here was an
illustration of arrivals at

00:11:48.040 --> 00:11:49.540
airports throughout the day.

00:11:49.540 --> 00:11:53.030
So as time goes past, more and
more planes arrive at these

00:11:53.030 --> 00:11:54.750
airports, and the bubbles
grow larger.

00:11:54.750 --> 00:11:58.590
And this is controlled in
JavaScript by changing the

00:11:58.590 --> 00:12:02.310
scale perimeter and the color
of those particular markers.

00:12:02.310 --> 00:12:04.880
So all these parameters can be
changed in JavaScript very

00:12:04.880 --> 00:12:06.130
dynamically.

00:12:14.370 --> 00:12:18.000
So as Thor also mentioned, we
started on this odyssey of

00:12:18.000 --> 00:12:23.030
symbols by considering
the use of

00:12:23.030 --> 00:12:25.560
putting arrows onto polylines.

00:12:25.560 --> 00:12:28.427
So here I have some examples of
symbols that you can place

00:12:28.427 --> 00:12:29.270
on polylines.

00:12:29.270 --> 00:12:32.040
So not only can these symbols
appear on markers, they can

00:12:32.040 --> 00:12:35.730
also appear along a polyline.

00:12:35.730 --> 00:12:37.650
And then you can choose the
styling and so forth.

00:12:37.650 --> 00:12:41.250
So here I have the five built-in
symbols that are part

00:12:41.250 --> 00:12:42.560
of the Maps API.

00:12:42.560 --> 00:12:44.570
We have seen the circle,
which is in the middle.

00:12:44.570 --> 00:12:47.760
And then we have two
other arrows.

00:12:47.760 --> 00:12:51.460
We have closed arrows and
we have open arrows.

00:12:51.460 --> 00:12:54.300
And these come in both forward
and backward varieties, giving

00:12:54.300 --> 00:12:57.060
you five symbols in total.

00:12:57.060 --> 00:13:00.490
And as illustrated by this demo
here, you can change the

00:13:00.490 --> 00:13:04.510
styling of these symbols on
the fly in JavaScript.

00:13:04.510 --> 00:13:07.090
So I've got an animation that
shows that you can change the

00:13:07.090 --> 00:13:09.360
fill color and the stroke color
to anything you like.

00:13:12.000 --> 00:13:15.785
So a great use of arrows, or
symbols in general, on

00:13:15.785 --> 00:13:18.420
polylines is to indicate
a direction.

00:13:18.420 --> 00:13:21.640
So this is a direction rendered
using the Google Maps

00:13:21.640 --> 00:13:23.840
Directions Renderer
in the Maps API.

00:13:23.840 --> 00:13:28.210
And you can see the path
starting at the A marker going

00:13:28.210 --> 00:13:30.240
towards the B marker.

00:13:30.240 --> 00:13:31.740
But it enhances the
visualization.

00:13:31.740 --> 00:13:35.270
It makes it easier to see the
particular path when it has an

00:13:35.270 --> 00:13:40.170
arrow indicating the direction
of the path to be taken.

00:13:40.170 --> 00:13:44.772
One place where symbols and
arrows in general come to the

00:13:44.772 --> 00:13:47.280
fore is where you have a
very monochromatic map.

00:13:47.280 --> 00:13:51.930
So if I have two paths here, one
driving and one bicycling,

00:13:51.930 --> 00:13:54.590
and I wish to differentiate
these two paths, if I don't

00:13:54.590 --> 00:13:59.060
have the luxury, say, of using
color to represent the

00:13:59.060 --> 00:14:01.510
difference between these two
paths, I can use a symbol.

00:14:01.510 --> 00:14:03.660
So for example, for the driving
path I've used a

00:14:03.660 --> 00:14:06.390
circle, and for the bicycling
path I've used an arrow.

00:14:06.390 --> 00:14:10.680
So these visually separate these
two paths without using

00:14:10.680 --> 00:14:11.930
color, for example.

00:14:14.480 --> 00:14:18.670
So how do I add a symbol
to a polyline?

00:14:18.670 --> 00:14:22.440
Again, I have a symbol
definition.

00:14:22.440 --> 00:14:26.630
So I've specified that I want
the path to be an open arrow.

00:14:26.630 --> 00:14:27.580
I can set the stroke color.

00:14:27.580 --> 00:14:30.380
I can set the size through
the scale parameter.

00:14:30.380 --> 00:14:32.750
But I've also got two
new properties--

00:14:32.750 --> 00:14:34.320
offset and repeat.

00:14:34.320 --> 00:14:37.680
So offset and repeat are the two
properties that allow you

00:14:37.680 --> 00:14:42.620
to specify how that symbol is to
be placed along that line.

00:14:42.620 --> 00:14:46.800
So I'll give you some examples
of using repeats and offset.

00:14:46.800 --> 00:14:49.840
So here is an example of
repeat set to zero.

00:14:49.840 --> 00:14:52.630
So no repeat along this
polyline, just one symbol.

00:14:52.630 --> 00:14:55.120
And as you can see, I've
got an open arrow at

00:14:55.120 --> 00:14:56.210
the end of that line.

00:14:56.210 --> 00:14:59.200
Just one arrow.

00:14:59.200 --> 00:15:01.900
Now, I've changed the
repeat to 25%.

00:15:01.900 --> 00:15:06.970
So the spacing between the
arrows on this line is 25% of

00:15:06.970 --> 00:15:08.480
the total line length.

00:15:08.480 --> 00:15:12.350
And if you zoom in, you notice
that the arrows get further

00:15:12.350 --> 00:15:14.780
apart, because the line
grows longer.

00:15:14.780 --> 00:15:18.240
So this is an example of how
you could have a line with

00:15:18.240 --> 00:15:23.080
arrows that are spaced no matter
what the zoom level is.

00:15:26.240 --> 00:15:29.430
Now, I've changed it to a pixel
spacing, so 50 pixels.

00:15:29.430 --> 00:15:34.270
So if I zoom in, I in fact see
more symbols assigned.

00:15:34.270 --> 00:15:38.390
Because the pixel spacing is
what I see on the screen.

00:15:38.390 --> 00:15:40.370
So if I zoom in, the
line gets longer.

00:15:40.370 --> 00:15:42.460
I get more symbols along
that particular line.

00:15:45.310 --> 00:15:50.400
To illustrate offset, offset is
the distance from the start

00:15:50.400 --> 00:15:53.890
of the line at which a symbol
is to be rendered.

00:15:53.890 --> 00:15:56.160
So in this example here, the
top line has an offset of

00:15:56.160 --> 00:16:00.510
zero, and the second line has
an offset of 50 pixels.

00:16:00.510 --> 00:16:03.900
The spacing for both lines
is 100 pixels.

00:16:03.900 --> 00:16:06.780
So on the second line, the first
symbol, you can see,

00:16:06.780 --> 00:16:09.510
starts halfway between
the first two symbols

00:16:09.510 --> 00:16:11.950
of the upper line.

00:16:11.950 --> 00:16:18.450
The use of this is you can
animate this, so that you can

00:16:18.450 --> 00:16:21.880
make arrows traverse a
line throughout time.

00:16:21.880 --> 00:16:23.610
And if you went to the previous
talk, you would have

00:16:23.610 --> 00:16:26.740
seen Thor's flights demo.

00:16:26.740 --> 00:16:27.990
So I'm going to open that up.

00:16:46.660 --> 00:16:51.680
So how this was done is each
plane sits on a geodesic line.

00:16:51.680 --> 00:16:56.260
And we've used JavaScript
animation to simply change the

00:16:56.260 --> 00:17:02.060
offset of that symbol along
the line throughout time.

00:17:02.060 --> 00:17:06.670
So we set 1% and 2% and
3% and so forth.

00:17:06.670 --> 00:17:08.800
And the plane gets automatically
moved along that

00:17:08.800 --> 00:17:10.180
line for you.

00:17:10.180 --> 00:17:12.470
And to animate this, we're
just using setTimeout.

00:17:12.470 --> 00:17:14.099
But in newer browsers
you can use

00:17:14.099 --> 00:17:16.380
window.RequestAnimationFrame
to make your

00:17:16.380 --> 00:17:17.640
animations even smoother.

00:17:24.950 --> 00:17:26.720
So just to give you another
example of the power of

00:17:26.720 --> 00:17:30.460
symbols, what I have here is an
example using the elevation

00:17:30.460 --> 00:17:33.930
service of the Maps API.

00:17:33.930 --> 00:17:40.760
So the elevation service gives
you the height along a path.

00:17:40.760 --> 00:17:43.360
You specify the path that you
want, and then you can request

00:17:43.360 --> 00:17:44.370
the number of samples.

00:17:44.370 --> 00:17:46.460
And it will tell you the height
above sea level for

00:17:46.460 --> 00:17:49.100
those particular samples.

00:17:49.100 --> 00:17:52.470
So what we have here is one
symbol at each location at

00:17:52.470 --> 00:17:53.990
which I have a sample.

00:17:53.990 --> 00:17:56.940
And the height of that symbol
represents the height.

00:17:56.940 --> 00:17:59.580
And that gives me a very good
visualization of the height

00:17:59.580 --> 00:18:01.490
along this particular line.

00:18:01.490 --> 00:18:04.250
So as you can see here, it runs
from somewhere in India

00:18:04.250 --> 00:18:05.850
to somewhere in China.

00:18:05.850 --> 00:18:08.220
It runs across the Himalayas.

00:18:08.220 --> 00:18:10.810
So you can see the height
progression throughout that

00:18:10.810 --> 00:18:13.820
particular line.

00:18:13.820 --> 00:18:16.510
How did I build this?

00:18:16.510 --> 00:18:19.740
Symbols are not just restricted
to the five

00:18:19.740 --> 00:18:21.360
built-in types of symbols.

00:18:21.360 --> 00:18:27.080
You can use SVG path data to
represent your own symbols.

00:18:27.080 --> 00:18:30.440
So I've blown up the example
down at the bottom.

00:18:30.440 --> 00:18:32.320
And if you can see that
there are actually

00:18:32.320 --> 00:18:33.910
lots of little lines.

00:18:33.910 --> 00:18:39.060
And for example, the top example
is a line that's 20

00:18:39.060 --> 00:18:40.260
pixels long.

00:18:40.260 --> 00:18:42.210
And that's expressed
using SVG.

00:18:42.210 --> 00:18:44.690
And by constructing a different
path for the second

00:18:44.690 --> 00:18:47.600
example down there, I
have a shorter line.

00:18:47.600 --> 00:18:52.910
And by creating SVG paths
dynamically in JavaScript

00:18:52.910 --> 00:18:57.270
along the line, I can have lines
of different heights

00:18:57.270 --> 00:18:58.640
throughout that line.

00:18:58.640 --> 00:19:02.090
And the possibilities of
using SVG are endless.

00:19:02.090 --> 00:19:06.780
You can take almost any SVG
out there, take its path,

00:19:06.780 --> 00:19:10.050
plunk it in there, and
it will render a

00:19:10.050 --> 00:19:11.470
vector symbol for you.

00:19:11.470 --> 00:19:14.390
For example, you can use it to
render your own dash lines.

00:19:14.390 --> 00:19:17.650
You can render airline
symbols, et cetera.

00:19:17.650 --> 00:19:20.750
The great thing is that this
SVG support works on all

00:19:20.750 --> 00:19:23.856
supported browsers, including
IE7 and 8.

00:19:27.460 --> 00:19:29.910
So those are just some examples
of new features in

00:19:29.910 --> 00:19:32.720
the Maps API.

00:19:32.720 --> 00:19:34.590
I'm just going to give you some
examples of things that

00:19:34.590 --> 00:19:37.340
you could have done in the Maps
API today, just some very

00:19:37.340 --> 00:19:40.160
interesting examples of maps.

00:19:40.160 --> 00:19:45.150
What I have here is electoral
data from Australia.

00:19:45.150 --> 00:19:48.220
So these are federal electorates
from Australia.

00:19:48.220 --> 00:19:53.910
And all the data is being sent
down to the clients.

00:19:53.910 --> 00:19:58.210
So all the polygons, all the
vertices of these polygons,

00:19:58.210 --> 00:20:00.070
they're sent down
to the browser.

00:20:00.070 --> 00:20:01.160
And they're rendered using just

00:20:01.160 --> 00:20:03.180
standard Google Maps polygons.

00:20:03.180 --> 00:20:04.400
And it's very, very
performant.

00:20:04.400 --> 00:20:09.060
I can mouse over individual
polygons and have very nice

00:20:09.060 --> 00:20:11.280
mouseover effects.

00:20:11.280 --> 00:20:17.960
I can zoom in and see
more data like that.

00:20:17.960 --> 00:20:20.440
So this just shows you what
you can do just using

00:20:20.440 --> 00:20:23.850
JavaScript, just using the
built-in primitives that the

00:20:23.850 --> 00:20:25.100
Maps API provides you.

00:20:29.630 --> 00:20:32.270
One interesting thing, though,
is that if you're sending all

00:20:32.270 --> 00:20:34.920
this data down to the client,
that's a lot of data.

00:20:34.920 --> 00:20:37.370
So for example, in that previous
example there was

00:20:37.370 --> 00:20:42.290
about 60 megs of uncompressed
raw JSON that I got from

00:20:42.290 --> 00:20:42.680
[INAUDIBLE]

00:20:42.680 --> 00:20:43.860
file.

00:20:43.860 --> 00:20:46.710
So what can I do to make it
more compact for easier

00:20:46.710 --> 00:20:48.490
sending to the clients?

00:20:48.490 --> 00:20:52.350
So the Google Maps API has
a geometry library.

00:20:52.350 --> 00:20:56.920
And the geometry library has a
function called encodePath.

00:20:56.920 --> 00:21:01.040
And what encodePath does is it
takes your lat-longs, and then

00:21:01.040 --> 00:21:05.510
produces a very compact path,
which is a string of letters

00:21:05.510 --> 00:21:08.530
and numbers and symbols that
you can see down there.

00:21:08.530 --> 00:21:10.200
So I've taken this, run it
through the function.

00:21:10.200 --> 00:21:12.390
That's the answer that I got.

00:21:12.390 --> 00:21:14.570
What can I do with this
encoded path?

00:21:14.570 --> 00:21:15.370
I can decode it.

00:21:15.370 --> 00:21:18.720
So there's a corresponding
function called decodePath,

00:21:18.720 --> 00:21:22.260
which takes that string and
gives me back my lat-longs.

00:21:22.260 --> 00:21:25.360
So using this, I compress my
data by a factor of 10.

00:21:25.360 --> 00:21:27.990
It was 10% the size of what
it was originally.

00:21:27.990 --> 00:21:29.860
And it was a size that was
feasible enough to be able to

00:21:29.860 --> 00:21:33.720
send down to the client and
render using JavaScript.

00:21:33.720 --> 00:21:37.490
So this particular star is the
unencoding of that string,

00:21:37.490 --> 00:21:42.360
turned to lat-longs, and then
plus it using a polygon.

00:21:42.360 --> 00:21:43.670
But know that there
is a trade-off

00:21:43.670 --> 00:21:46.250
between speed and size.

00:21:46.250 --> 00:21:48.930
So encoding and decoding is
quite fast, but maybe it's not

00:21:48.930 --> 00:21:49.970
fast enough for your
application.

00:21:49.970 --> 00:21:52.670
So you need to weigh up whether
encoding it to save

00:21:52.670 --> 00:21:56.160
space is worthwhile, or taking
the hit of encoding and

00:21:56.160 --> 00:21:57.410
decoding is worth it.

00:22:00.250 --> 00:22:02.870
Finally, I have an another
example of just using regular

00:22:02.870 --> 00:22:04.400
Google Maps polylines.

00:22:04.400 --> 00:22:09.840
So this data set is a data set
that shows ship tracks from

00:22:09.840 --> 00:22:16.000
European countries from about
1750 to about 1850.

00:22:16.000 --> 00:22:18.590
So each color on this map
represents ships of a

00:22:18.590 --> 00:22:20.270
different country.

00:22:20.270 --> 00:22:23.190
And there are hundreds
and hundreds of

00:22:23.190 --> 00:22:26.240
polylines on this map.

00:22:26.240 --> 00:22:32.836
And by setting the opacity and
the stroke width of each line

00:22:32.836 --> 00:22:36.520
to be very small, by plotting
many, many ship tracks on top

00:22:36.520 --> 00:22:39.640
of each other, I get a general
sense of the pathings of ship

00:22:39.640 --> 00:22:43.150
travel from theses European
countries.

00:22:43.150 --> 00:22:44.080
So for example, you
could probably

00:22:44.080 --> 00:22:48.130
guess that red is Spain.

00:22:48.130 --> 00:22:53.300
So you can see very clearly from
this visualization trends

00:22:53.300 --> 00:22:56.586
simply by building up a whole
series of polylines on top of

00:22:56.586 --> 00:22:57.836
each other.

00:23:00.450 --> 00:23:01.980
So one thing that you may have
noticed is that I've made

00:23:01.980 --> 00:23:06.270
extensive use of styled maps
during this presentation.

00:23:06.270 --> 00:23:10.350
So for example, on the left
I have a styled map.

00:23:10.350 --> 00:23:13.430
And on the right, I've left the
map unstyled, using the

00:23:13.430 --> 00:23:15.320
default Google Maps styling.

00:23:15.320 --> 00:23:17.500
So while the default Google
Map styling has a lot of

00:23:17.500 --> 00:23:21.310
information that's very useful,
sometimes you want

00:23:21.310 --> 00:23:24.050
your data to be the
hero of your map.

00:23:24.050 --> 00:23:27.850
So you can use styled maps to
make the base map a little bit

00:23:27.850 --> 00:23:33.380
more subdued so that it just
allows for context without

00:23:33.380 --> 00:23:36.130
swamping your data on top.

00:23:36.130 --> 00:23:38.110
So I'm not going to go into
detail about styled maps, but

00:23:38.110 --> 00:23:41.670
there will be a master class in
styling tomorrow from 4:00

00:23:41.670 --> 00:23:45.090
to 5:00 in room one, in which
you can learn more about the

00:23:45.090 --> 00:23:48.470
use of styled maps
in the Maps API.

00:23:48.470 --> 00:23:50.180
So just to recap, there
are some new

00:23:50.180 --> 00:23:52.350
features in the Maps API.

00:23:52.350 --> 00:23:55.180
We now have heatmaps, which
allow you to represent density

00:23:55.180 --> 00:23:59.120
and intensity of your
data on a map.

00:23:59.120 --> 00:24:00.560
We now have symbols
as markers.

00:24:00.560 --> 00:24:04.960
So symbols, if you recall, are
vector images that you can

00:24:04.960 --> 00:24:07.285
change the scale dynamically.

00:24:07.285 --> 00:24:09.540
You can change the stroke
color and fill color

00:24:09.540 --> 00:24:11.060
independently.

00:24:11.060 --> 00:24:12.370
And finally, you can
also place these

00:24:12.370 --> 00:24:13.960
symbols along polylines.

00:24:13.960 --> 00:24:16.900
So in particular, this allows
you to place arrows on

00:24:16.900 --> 00:24:18.550
polylines, say, for
directions, or

00:24:18.550 --> 00:24:21.240
implement dash lines.

00:24:21.240 --> 00:24:23.290
Now, all of these features
in the Maps API you

00:24:23.290 --> 00:24:24.870
can use from today.

00:24:24.870 --> 00:24:27.770
And they work in a broad
range of browsers.

00:24:27.770 --> 00:24:29.040
And they use [INAUDIBLE]

00:24:29.040 --> 00:24:32.290
Canvas and images to bring
these elements

00:24:32.290 --> 00:24:33.860
to you in the browser.

00:24:33.860 --> 00:24:36.430
But Brendan's now going to talk
about the bleeding edge,

00:24:36.430 --> 00:24:39.500
what we can do if we put
behind some of the

00:24:39.500 --> 00:24:42.192
legacy and use WebGL.

00:24:42.192 --> 00:24:43.608
Thanks, Brendan.

00:24:43.608 --> 00:24:48.800
[APPLAUSE]

00:24:48.800 --> 00:24:49.180
BRENDAN KENNY: Yes.

00:24:49.180 --> 00:24:52.500
So now, we're going to talk
about less practical things,

00:24:52.500 --> 00:24:54.870
and things that might break.

00:24:54.870 --> 00:24:59.790
So in the last few years,
browsers have been increasing

00:24:59.790 --> 00:25:02.590
their capability at an
accelerating rate.

00:25:02.590 --> 00:25:05.620
We've seen a huge amount of
work put into hardware

00:25:05.620 --> 00:25:12.220
acceleration, new APIs around
CSS, and Canvas, and WebGL,

00:25:12.220 --> 00:25:14.020
and JavaScript execution
speed.

00:25:14.020 --> 00:25:17.100
And a lot of times we are held
back from using that.

00:25:17.100 --> 00:25:19.670
Because some of it's not ready
yet, and it's just being kind

00:25:19.670 --> 00:25:22.340
of finished up or still
has a ways to go.

00:25:22.340 --> 00:25:25.930
But in a lot of cases, it's
because we're being held back

00:25:25.930 --> 00:25:27.710
by legacy browsers.

00:25:27.710 --> 00:25:30.305
And we have some portion
of our audience

00:25:30.305 --> 00:25:31.560
that uses these browsers.

00:25:31.560 --> 00:25:32.870
And we need to serve
content to them.

00:25:32.870 --> 00:25:36.380
And there's various theories
around progressive enhancement

00:25:36.380 --> 00:25:39.640
versus regressive enhancement,
that sort of thing.

00:25:39.640 --> 00:25:41.150
But the fact remains
that you have to

00:25:41.150 --> 00:25:42.930
serve them some content.

00:25:42.930 --> 00:25:47.520
But it is nice to imagine and
play with sometimes the kinds

00:25:47.520 --> 00:25:49.700
of things that we could build if
we didn't have to deal with

00:25:49.700 --> 00:25:52.180
those and to start imagining
the kinds of things that we

00:25:52.180 --> 00:25:55.480
can build in the near future.

00:25:55.480 --> 00:25:57.340
Some of these things you
actually can use today,

00:25:57.340 --> 00:26:00.220
especially if you're in an
environment where the browser

00:26:00.220 --> 00:26:01.270
usage is homogeneous.

00:26:01.270 --> 00:26:03.900
So if you can tell your company
to use a certain kind

00:26:03.900 --> 00:26:09.740
of browser, or your clients
based on your log data tells

00:26:09.740 --> 00:26:12.930
you that most people use a
recent Chrome or Firefox, then

00:26:12.930 --> 00:26:14.110
you actually can
use this stuff.

00:26:14.110 --> 00:26:16.140
And so we're going to talk
a little bit about that.

00:26:16.140 --> 00:26:19.030
And hopefully, my computer
won't explode,

00:26:19.030 --> 00:26:20.230
and it'll be great.

00:26:20.230 --> 00:26:25.340
So let's take a look at
a demo to start off--

00:26:25.340 --> 00:26:28.320
close this.

00:26:28.320 --> 00:26:28.650
Great.

00:26:28.650 --> 00:26:34.390
So we're going to start off
with the National Highway

00:26:34.390 --> 00:26:37.310
Traffic and Safety
Administration collects

00:26:37.310 --> 00:26:39.900
information on every traffic
fatality that happens the

00:26:39.900 --> 00:26:40.960
United States.

00:26:40.960 --> 00:26:42.960
And for the last decade,
they've actually been

00:26:42.960 --> 00:26:43.780
geo-locating them.

00:26:43.780 --> 00:26:47.460
And you can go to their website
and download a log of

00:26:47.460 --> 00:26:49.790
the latitude and longitude of
every traffic fatality that

00:26:49.790 --> 00:26:52.820
happens in the United States,
as well as a bunch of really

00:26:52.820 --> 00:26:56.710
fascinating data like where
people are from, like how many

00:26:56.710 --> 00:27:00.640
people were involved, what time
of day it was, if alcohol

00:27:00.640 --> 00:27:02.100
was involved, that
sort of thing.

00:27:02.100 --> 00:27:08.100
So there's a little over 30,000
fatal crashes a year in

00:27:08.100 --> 00:27:09.140
the United States.

00:27:09.140 --> 00:27:11.580
And so for a decade, that's
about 300,000 points, which

00:27:11.580 --> 00:27:14.980
it's not something that you can
today just kind of throw

00:27:14.980 --> 00:27:17.870
on a map and expect to have
it run really well.

00:27:17.870 --> 00:27:20.510
You have to start thinking about
marker clustering or

00:27:20.510 --> 00:27:22.990
rendering offline, serving
tiles, that sort of thing.

00:27:22.990 --> 00:27:27.120
The beauty of WebGL is that it
laughs in the face of 300,000.

00:27:27.120 --> 00:27:30.710
300,000 is puny.

00:27:30.710 --> 00:27:35.000
So as a result, we can start
just playing with this data

00:27:35.000 --> 00:27:39.450
and start seeing patterns and
start developing tools in ways

00:27:39.450 --> 00:27:40.710
that we couldn't before.

00:27:40.710 --> 00:27:45.760
So I'm going to start loading
this data, starting with 2001.

00:27:45.760 --> 00:27:48.320
Hopefully, it does load.

00:27:48.320 --> 00:27:51.140
Oh, there it goes.

00:27:51.140 --> 00:27:54.050
So you can start seeing
this data come in.

00:27:54.050 --> 00:27:56.680
And it's loading bit by bit.

00:27:56.680 --> 00:28:00.250
And right now, we're just
using simple circles.

00:28:00.250 --> 00:28:04.140
And the great thing about
WebGL is that it'll keep

00:28:04.140 --> 00:28:05.420
animating as we come in.

00:28:05.420 --> 00:28:07.830
And there's no redraw time
or fetching tiles.

00:28:07.830 --> 00:28:11.040
You can see, especially on this
network, sometimes the

00:28:11.040 --> 00:28:13.270
map tiles take quite a
bit more time to come

00:28:13.270 --> 00:28:14.520
in than this data.

00:28:19.670 --> 00:28:21.180
So that's the first pass.

00:28:21.180 --> 00:28:22.540
We can start loading
this data.

00:28:22.540 --> 00:28:24.990
We can animate it so there's
a temporal component.

00:28:24.990 --> 00:28:27.420
And the most obvious thing is
we can kind of animate it as

00:28:27.420 --> 00:28:31.010
it comes in and start to see
where the patterns are.

00:28:31.010 --> 00:28:33.030
And you can see pretty much
here's the road network of the

00:28:33.030 --> 00:28:34.180
United States.

00:28:34.180 --> 00:28:37.480
And some places appear more
dangerous than others.

00:28:37.480 --> 00:28:41.535
There's actually a particular
highway--

00:28:44.110 --> 00:28:49.040
if we zoom out--

00:28:49.040 --> 00:28:49.340
yes.

00:28:49.340 --> 00:28:52.270
So apparently if you're
traveling LA to Las Vegas, you

00:28:52.270 --> 00:28:54.320
need to be careful.

00:28:54.320 --> 00:28:58.980
Because this highway is
basically solid red.

00:28:58.980 --> 00:28:59.890
So that's the first thing.

00:28:59.890 --> 00:29:01.600
You can start seeing
spatial patterns.

00:29:01.600 --> 00:29:04.320
It's hard with this kind of data
to see temporal patterns,

00:29:04.320 --> 00:29:08.220
because over the course of a
decade, it goes by so quickly.

00:29:08.220 --> 00:29:10.810
And people are kind
of distributed.

00:29:10.810 --> 00:29:13.820
So you're not going to see
a pattern in that aspect.

00:29:13.820 --> 00:29:17.210
So we can start asking, what
kinds of things can WebGL let

00:29:17.210 --> 00:29:20.900
us do, besides just loading
lots of data?

00:29:20.900 --> 00:29:23.000
So the first thing
is really simple.

00:29:23.000 --> 00:29:26.910
We can style dynamically
and see it in action.

00:29:26.910 --> 00:29:28.920
So here is just a really
simple-- we can change the

00:29:28.920 --> 00:29:34.980
radius of the dots used and
actually make it more intense.

00:29:34.980 --> 00:29:40.930
Or as we get closer, we can
bring it down so we can

00:29:40.930 --> 00:29:42.780
actually see the individual
roads that these

00:29:42.780 --> 00:29:44.120
accidents happen on.

00:29:44.120 --> 00:29:47.350
And so let's just--

00:29:47.350 --> 00:29:49.280
because everybody loves
seeing maps in San

00:29:49.280 --> 00:29:54.010
Francisco, let's do that.

00:29:54.010 --> 00:29:55.690
So that's kind of
a first pass.

00:29:55.690 --> 00:29:59.040
And actually, a pretty typical
thing when you're visualizing

00:29:59.040 --> 00:30:06.480
data is deciding are you have
your points define their size

00:30:06.480 --> 00:30:08.965
in pixel space so as you zoom
in and out they stay a fixed

00:30:08.965 --> 00:30:11.840
size, or do you want actually a
physical size so as you zoom

00:30:11.840 --> 00:30:13.830
in they get bigger?

00:30:13.830 --> 00:30:16.200
And you can start making
decisions with WebGL that

00:30:16.200 --> 00:30:19.710
become trivial that are
non-physical kind of

00:30:19.710 --> 00:30:20.240
relationships.

00:30:20.240 --> 00:30:21.770
So this actually increases
at the square

00:30:21.770 --> 00:30:24.100
root of the zoom level.

00:30:24.100 --> 00:30:28.890
And so it's not quite matching
any kind of physical

00:30:28.890 --> 00:30:29.410
relationship.

00:30:29.410 --> 00:30:31.270
But as a result, at all zoom
levels, you actually get a

00:30:31.270 --> 00:30:31.970
decent coverage.

00:30:31.970 --> 00:30:34.870
And you can see, it doesn't
get lost as you zoom out.

00:30:34.870 --> 00:30:38.890
It doesn't overwhelm when
you get too close.

00:30:38.890 --> 00:30:39.890
So that's styling.

00:30:39.890 --> 00:30:40.800
And that's great.

00:30:40.800 --> 00:30:42.550
You can kind of do
that on your own.

00:30:42.550 --> 00:30:44.870
But there is something
to be said for

00:30:44.870 --> 00:30:47.040
that instant feedback.

00:30:47.040 --> 00:30:48.380
You don't have to refresh
your browser.

00:30:48.380 --> 00:30:50.886
You don't have to re-render
any tiles.

00:30:50.886 --> 00:30:54.320
And this is something simple
like points, but 300,000

00:30:54.320 --> 00:30:57.800
points is not a big
deal to WebGL.

00:30:57.800 --> 00:30:58.990
So that helps your workflow.

00:30:58.990 --> 00:31:01.300
But what about the
data itself?

00:31:01.300 --> 00:31:07.750
So we're going to really taunt
the demo gods here by trying

00:31:07.750 --> 00:31:09.000
to make this work--

00:31:12.620 --> 00:31:13.870
if it works.

00:31:17.146 --> 00:31:19.990
Oh.

00:31:19.990 --> 00:31:21.240
Hmm.

00:31:27.008 --> 00:31:28.357
Oh, there you go.

00:31:31.040 --> 00:31:32.290
That's pretty funny.

00:31:35.520 --> 00:31:37.520
I think that means somehow
a non-number

00:31:37.520 --> 00:31:38.770
snuck into the data.

00:31:43.450 --> 00:31:48.160
Wow, that's unfortunate
right there.

00:31:52.776 --> 00:31:55.180
All right, well, we do
have one backup.

00:31:55.180 --> 00:31:56.890
We can see if it's working.

00:32:01.770 --> 00:32:04.380
It might load very slowly.

00:32:04.380 --> 00:32:08.140
So I'll come back to the
backup if it loads.

00:32:08.140 --> 00:32:11.440
But the idea is you can actually
look at multiple

00:32:11.440 --> 00:32:13.170
dimensions of the data
at the same time.

00:32:13.170 --> 00:32:17.740
And so if it loads, it's
actually using microstocks

00:32:17.740 --> 00:32:22.220
cross filter and D3
visualization libraries to

00:32:22.220 --> 00:32:24.750
draw histograms in real
time of other

00:32:24.750 --> 00:32:25.520
attributes of the data.

00:32:25.520 --> 00:32:29.600
So looking at the time of the
traffic accident, looking at

00:32:29.600 --> 00:32:30.990
the number of people involved,
looking at the

00:32:30.990 --> 00:32:32.260
distance from home.

00:32:32.260 --> 00:32:33.680
And then you can start
sub-selecting.

00:32:33.680 --> 00:32:36.290
So you can say, show me the
histograms of everything in

00:32:36.290 --> 00:32:37.560
the current view.

00:32:37.560 --> 00:32:38.810
And show me the--

00:32:41.730 --> 00:32:43.600
so this is an older version, and
it's not quite as pretty,

00:32:43.600 --> 00:32:44.850
but it's loading.

00:32:47.800 --> 00:32:49.290
Oh, and not all the
data's loading.

00:32:49.290 --> 00:32:50.210
It's loading very slowly.

00:32:50.210 --> 00:32:55.340
But if we come down to, say--

00:32:55.340 --> 00:32:56.590
Miami's always a good one--

00:32:59.840 --> 00:33:02.610
so if we come down to Miami,
you can see down below the

00:33:02.610 --> 00:33:06.270
histograms actually adjust
to the view right there.

00:33:06.270 --> 00:33:09.960
It's really interesting, because
only a minimal amount

00:33:09.960 --> 00:33:14.650
of data is being communicated
between these two libraries,

00:33:14.650 --> 00:33:18.110
the WebGL library and the
cross filter library.

00:33:18.110 --> 00:33:19.800
Because we really only
need bounds.

00:33:19.800 --> 00:33:22.950
We need lat-long bounds, we need
maybe year bounds, time

00:33:22.950 --> 00:33:25.850
of day bounds.

00:33:25.850 --> 00:33:29.320
And as a result, you don't get
weighed down by the traffic.

00:33:29.320 --> 00:33:33.100
They can exist one mostly in the
GPU process and one in the

00:33:33.100 --> 00:33:35.960
main JavaScript process, and
take full advantage of the

00:33:35.960 --> 00:33:38.700
computing power in
your machine.

00:33:38.700 --> 00:33:40.910
And so we can start seeing
trends here.

00:33:40.910 --> 00:33:46.000
So you'll see on a yearly
basis, Miami's not that

00:33:46.000 --> 00:33:46.390
interesting.

00:33:46.390 --> 00:33:49.340
But you'll see a definite curve
in the time of day.

00:33:49.340 --> 00:33:52.470
So you can see at night Miami's
kind of a dangerous

00:33:52.470 --> 00:33:56.400
place, but in relatively
early evening.

00:33:56.400 --> 00:34:00.130
And then you can also see this
split here in the distance.

00:34:00.130 --> 00:34:03.050
This person was, when they had
an accident, the distance they

00:34:03.050 --> 00:34:06.570
were from home, were primarily
people were either right at

00:34:06.570 --> 00:34:11.530
home or from over 500
kilometers away.

00:34:11.530 --> 00:34:23.150
So if we instead go to, say,
Austin, Texas, my hometown,

00:34:23.150 --> 00:34:26.190
you can see that, instead, we
have quite a few more people

00:34:26.190 --> 00:34:28.429
are tourists than
they are locals.

00:34:28.429 --> 00:34:31.280
But one key thing to notice is
right here, this little spike

00:34:31.280 --> 00:34:32.239
right here.

00:34:32.239 --> 00:34:34.710
Last call in Austin
is 2:00 AM.

00:34:34.710 --> 00:34:38.500
And it's kind of the received
wisdom that that's one of the

00:34:38.500 --> 00:34:40.320
more dangerous times
to go out at night.

00:34:40.320 --> 00:34:45.150
And according to these numbers,
that is the case.

00:34:45.150 --> 00:34:47.210
So you can start seeing these
patterns, and then you can

00:34:47.210 --> 00:34:48.280
start filtering.

00:34:48.280 --> 00:34:53.340
So if I'm only interested in
this particular year, it'll

00:34:53.340 --> 00:34:55.580
actually filter out
those points.

00:34:55.580 --> 00:34:58.102
And if I'm only interested
in, say--

00:34:58.102 --> 00:34:59.352
is that going to work?--

00:35:03.230 --> 00:35:06.350
let's say locals, I can see in
that particular year there

00:35:06.350 --> 00:35:07.250
weren't that many.

00:35:07.250 --> 00:35:09.540
And it looks like I'm filtering
out more than I'm

00:35:09.540 --> 00:35:09.970
meaning to.

00:35:09.970 --> 00:35:15.030
But maybe they're just
really out of town.

00:35:15.030 --> 00:35:22.060
So in any case, you can just
imagine on a bigger map the

00:35:22.060 --> 00:35:23.650
usefulness of this
sort of thing.

00:35:23.650 --> 00:35:28.550
So this comes down to the
tension in visualizations,

00:35:28.550 --> 00:35:31.720
which I won't dwell on, because
there's a lot of WebGL

00:35:31.720 --> 00:35:32.300
stuff to talk about.

00:35:32.300 --> 00:35:35.310
But the idea that when you make
a visualization you're

00:35:35.310 --> 00:35:39.630
making a story about your data,
and as a designer of

00:35:39.630 --> 00:35:43.790
visualization, or as a
cartographer, you're making a

00:35:43.790 --> 00:35:44.780
very specific story.

00:35:44.780 --> 00:35:48.200
And if you aren't making a
specific story, you're doing

00:35:48.200 --> 00:35:50.250
your users a disservice, because
you're just flooding

00:35:50.250 --> 00:35:52.740
them with data and not giving
any kind of context.

00:35:52.740 --> 00:35:56.080
And so you do need to
construct a story.

00:35:56.080 --> 00:35:58.470
But as we get into this new
medium where things are

00:35:58.470 --> 00:36:01.000
dynamic, things are scriptable,
we need to start

00:36:01.000 --> 00:36:02.740
thinking about other kinds
of stories we can tell.

00:36:02.740 --> 00:36:05.380
We need to think about ways
that we can let the user

00:36:05.380 --> 00:36:07.790
interact with the data and
discover things while still

00:36:07.790 --> 00:36:10.920
guiding them to the interesting
things while

00:36:10.920 --> 00:36:13.425
discarding all the noise so that
they can actually get to

00:36:13.425 --> 00:36:14.750
that signal.

00:36:14.750 --> 00:36:16.200
It's a hard problem.

00:36:16.200 --> 00:36:18.980
You're just as likely to end up
with the blink tag as you

00:36:18.980 --> 00:36:21.060
are something insightful.

00:36:21.060 --> 00:36:24.910
But it's a big opportunity.

00:36:24.910 --> 00:36:29.590
So today, we're introducing
the canvas

00:36:29.590 --> 00:36:31.340
layer utility library.

00:36:31.340 --> 00:36:34.700
It's going to be part of the
Maps API Utility Library.

00:36:34.700 --> 00:36:35.430
It's open source.

00:36:35.430 --> 00:36:37.840
You can go-- well actually, it's
not quite available now.

00:36:37.840 --> 00:36:39.950
But it will be shortly.

00:36:39.950 --> 00:36:44.310
And so it's the Maps API
Utility v3 Library.

00:36:44.310 --> 00:36:49.660
And it's basically an extension
of the overlay view

00:36:49.660 --> 00:36:51.710
that's provided by
the Maps API.

00:36:51.710 --> 00:36:57.160
And best practices are
built into it.

00:36:57.160 --> 00:36:59.660
It uses RequestAnimationFrame,
so your animation is

00:36:59.660 --> 00:37:03.350
well-aligned with the browser's
repaint process.

00:37:03.350 --> 00:37:07.790
And it does various things to
make it more efficient to do

00:37:07.790 --> 00:37:08.720
the job that you need to.

00:37:08.720 --> 00:37:11.770
But in the end, all it's really
doing is providing an

00:37:11.770 --> 00:37:15.420
HTML5 canvas over your map,
which sounds mundane.

00:37:15.420 --> 00:37:19.710
But it makes a lot of things
much simpler, because mashing

00:37:19.710 --> 00:37:25.540
up WebGL and pure DOM content
is harder than it looks.

00:37:25.540 --> 00:37:27.200
And it's something that
browsers need

00:37:27.200 --> 00:37:27.960
to get better at.

00:37:27.960 --> 00:37:30.930
But in the meantime,
we have this.

00:37:30.930 --> 00:37:35.360
It's crated pretty much just
like any Maps API object.

00:37:35.360 --> 00:37:38.680
You can give an object literal
for options to the

00:37:38.680 --> 00:37:41.350
constructor, specify
the map, specify--

00:37:41.350 --> 00:37:42.320
there's a couple of
different options.

00:37:42.320 --> 00:37:47.000
The main thing, though, is an
update function, which is what

00:37:47.000 --> 00:37:49.420
is called when you need
to repaint the screen.

00:37:49.420 --> 00:37:51.410
So this is kind of your
animation loop.

00:37:51.410 --> 00:37:58.080
Or it's when your content
currently on screen has been

00:37:58.080 --> 00:37:59.845
invalidated, you
need a repaint.

00:37:59.845 --> 00:38:03.260
And it's called more often than
if you actually use an

00:38:03.260 --> 00:38:07.390
overlay view, and you need
to redraw the overlay.

00:38:07.390 --> 00:38:09.470
It's actually called more often
that, because it's--

00:38:09.470 --> 00:38:10.720
well, I'll show you.

00:38:13.410 --> 00:38:15.630
So this is a really
simple example.

00:38:15.630 --> 00:38:21.760
This is using the 2D canvas API
on top of canvas layer.

00:38:21.760 --> 00:38:25.100
And you can see down at the
bottom, pretty much all that's

00:38:25.100 --> 00:38:28.940
happening here is we're taking
a lat-long and we're

00:38:28.940 --> 00:38:31.110
projecting it to world
coordinates, as is pretty

00:38:31.110 --> 00:38:36.190
typical, and then drawing a
rectangle at that coordinate.

00:38:36.190 --> 00:38:37.270
Projecting to world
coordinates is

00:38:37.270 --> 00:38:39.190
actually fairly important.

00:38:39.190 --> 00:38:41.310
Actually, there's a couple of
different ways that you could

00:38:41.310 --> 00:38:44.240
do this step, but projecting to
world coordinates is really

00:38:44.240 --> 00:38:47.530
helpful because then a lot
of things become linear.

00:38:47.530 --> 00:38:49.360
And linear is good
for computation.

00:38:49.360 --> 00:38:53.580
And then--

00:38:53.580 --> 00:38:56.280
well, yeah, that's actually
the main reason.

00:38:56.280 --> 00:38:57.380
So that's a good first step.

00:38:57.380 --> 00:39:01.570
And you're kind of pulling out
the heavy lifting outside of

00:39:01.570 --> 00:39:03.870
your hot code and moving
it outside.

00:39:03.870 --> 00:39:05.770
So convert to world
coordinates.

00:39:05.770 --> 00:39:07.350
Lot of things become linear.

00:39:07.350 --> 00:39:09.800
You aren't dealing with
transcendental

00:39:09.800 --> 00:39:11.200
functions all the time.

00:39:11.200 --> 00:39:13.350
And many things become easier.

00:39:13.350 --> 00:39:15.240
Some things become harder,
like geodisics.

00:39:15.240 --> 00:39:18.970
But that's a topic
for another time.

00:39:18.970 --> 00:39:22.610
And so if you're an eagle-eyed
developer, you might have

00:39:22.610 --> 00:39:25.060
noticed this is not
quite correct.

00:39:25.060 --> 00:39:27.860
That point, that lat-long is
actually somewhere, I don't

00:39:27.860 --> 00:39:31.530
know, in Illinois
or something.

00:39:31.530 --> 00:39:34.200
But we're simplifying for
pedagogical purposes.

00:39:34.200 --> 00:39:38.650
So the problem here is what I'm
about to show you, is that

00:39:38.650 --> 00:39:42.140
this rectangle is not
fixed to the map.

00:39:42.140 --> 00:39:45.530
So the major difference between
canvas layer and

00:39:45.530 --> 00:39:49.550
overlay view is that overlay
view takes care of

00:39:49.550 --> 00:39:53.700
synchronizing your content with
a map as it pans around.

00:39:53.700 --> 00:39:56.610
And that's actually really
important to the

00:39:56.610 --> 00:39:57.890
concept of an overlay.

00:39:57.890 --> 00:39:58.860
It takes care of that for you.

00:39:58.860 --> 00:40:01.700
But it becomes problematic
with a canvas.

00:40:01.700 --> 00:40:07.190
So to kind of illustrate that,
what's going on, here's a

00:40:07.190 --> 00:40:09.090
hopefully less confusing
thing.

00:40:09.090 --> 00:40:12.400
So I'm drawing a checkerboard
to the canvas, relative just

00:40:12.400 --> 00:40:12.910
to the canvas.

00:40:12.910 --> 00:40:14.110
There's no map content.

00:40:14.110 --> 00:40:18.050
And you can see, obviously, the
rectangle is being drawn

00:40:18.050 --> 00:40:21.150
to a fixed point based
on the canvas.

00:40:21.150 --> 00:40:23.510
The canvas itself is not
moving, in other words.

00:40:23.510 --> 00:40:27.550
With a normal overlay, you add
a DOM element to the map, and

00:40:27.550 --> 00:40:30.150
the Maps API will actually
move it around for you.

00:40:30.150 --> 00:40:31.440
In this case, we're actually
keeping the

00:40:31.440 --> 00:40:33.365
canvas fixed on purpose.

00:40:35.960 --> 00:40:37.320
And we'll take a look
at the next slide.

00:40:37.320 --> 00:40:41.870
The reason we're keeping it
fixed is not for 2D canvas.

00:40:41.870 --> 00:40:44.230
2D canvas is actually
really flexible.

00:40:44.230 --> 00:40:46.910
You can make a lot of 2D
canvases, you could make

00:40:46.910 --> 00:40:49.290
hundreds of 2D canvases, and
browsers will be OK with you.

00:40:49.290 --> 00:40:51.360
It might be a little slow.

00:40:51.360 --> 00:40:54.050
But WebGL contexts are
actually extremely

00:40:54.050 --> 00:40:54.680
heavyweight.

00:40:54.680 --> 00:40:57.910
You have this backing store for
color data, and maybe for

00:40:57.910 --> 00:41:02.280
depth data, for all this
heavy state of OpenGL.

00:41:02.280 --> 00:41:05.980
And right now, it's extremely
expensive to allocate that in

00:41:05.980 --> 00:41:10.180
terms of if you, say, have three
open in the same page,

00:41:10.180 --> 00:41:11.170
you might have trouble.

00:41:11.170 --> 00:41:12.770
Hopefully, we're going to
get to a point where

00:41:12.770 --> 00:41:13.560
that's not an issue.

00:41:13.560 --> 00:41:17.470
But for now, that is an issue.

00:41:17.470 --> 00:41:22.330
Here, all we're doing is
calculating a scale based on

00:41:22.330 --> 00:41:22.950
just the zoom.

00:41:22.950 --> 00:41:26.110
So the world is twice
as big every time

00:41:26.110 --> 00:41:27.330
you zoom in one level.

00:41:27.330 --> 00:41:30.360
So we're going to scale by two
the power of the map zoom.

00:41:30.360 --> 00:41:33.180
And then we're going to find the
offset from the canvas's

00:41:33.180 --> 00:41:35.670
zero-zero point to the world
coordinate zero-zero point,

00:41:35.670 --> 00:41:41.180
which is somewhere up northwest,
so it's Alaska, or

00:41:41.180 --> 00:41:44.040
past Alaska.

00:41:44.040 --> 00:41:47.420
And then, we're just going to
use the 2D canvas's built-in

00:41:47.420 --> 00:41:49.920
scale and translate methods.

00:41:49.920 --> 00:41:53.815
So that changes the 2D canvas's
transformation, and

00:41:53.815 --> 00:41:55.390
then draws there.

00:41:55.390 --> 00:41:57.900
And the reason I chose this is
because that's what we have to

00:41:57.900 --> 00:41:59.480
do in 3D as well.

00:41:59.480 --> 00:42:01.595
So you could do this with-- so
for instance, there's the

00:42:01.595 --> 00:42:05.890
overlay views from lat-long to
container pixel, which will

00:42:05.890 --> 00:42:06.600
take care of this for you.

00:42:06.600 --> 00:42:08.850
But again, we want to take
out that heavy lifting.

00:42:08.850 --> 00:42:12.840
We don't want to be running
natural logs and tangent

00:42:12.840 --> 00:42:16.770
functions on every point, every
frame if we're going to

00:42:16.770 --> 00:42:18.770
draw millions of points.

00:42:18.770 --> 00:42:21.940
So let's talk about WebGL
just really quickly.

00:42:21.940 --> 00:42:24.840
It came out of Mozilla's
project, Canvas 3D.

00:42:24.840 --> 00:42:31.110
Vladimir Vukicevic decided
one day to 2D

00:42:31.110 --> 00:42:31.890
canvas was not enough.

00:42:31.890 --> 00:42:33.200
So he made 3D canvas.

00:42:33.200 --> 00:42:36.360
It's moved to the Khronos Group,
which does OpenGL,

00:42:36.360 --> 00:42:41.330
OpenCL, OpenGL ES, and
for standardization.

00:42:41.330 --> 00:42:42.330
It's not OpenGL.

00:42:42.330 --> 00:42:46.070
It's actually Open GL ES
2, for the most part.

00:42:46.070 --> 00:42:49.710
And the reason this was
chosen was for--

00:42:49.710 --> 00:42:51.170
well, there was really
two reasons.

00:42:51.170 --> 00:42:54.990
The first is that OpenGL ES
2 cut out a lot of cruft.

00:42:54.990 --> 00:42:57.870
OpenGL is 20 years old
with legacy APIs that

00:42:57.870 --> 00:42:59.510
go back even farther.

00:42:59.510 --> 00:43:02.980
And OpenGL ES 2 was a
time to break that.

00:43:02.980 --> 00:43:08.060
So rather than 15 ways of doing
something, 14 of them

00:43:08.060 --> 00:43:11.050
dangerous and slow, now there's
only maybe two ways of

00:43:11.050 --> 00:43:11.730
doing things.

00:43:11.730 --> 00:43:13.930
And it becomes a lot simpler.

00:43:13.930 --> 00:43:18.750
The other reason is because
OpenGL ES 2 was written for

00:43:18.750 --> 00:43:19.640
mobile devices.

00:43:19.640 --> 00:43:23.450
So the idea is that mobile
devices can continue to be

00:43:23.450 --> 00:43:25.260
first-class web consumers.

00:43:25.260 --> 00:43:27.330
And we're not going to rule out
a whole class of devices

00:43:27.330 --> 00:43:31.310
by choosing a 3D API that
can't run on phones.

00:43:31.310 --> 00:43:35.520
So all the examples that I'm
going to show actually run on

00:43:35.520 --> 00:43:38.040
a phone, in Firefox and Opera.

00:43:38.040 --> 00:43:41.010
And I'm looking forward to the
day that Chrome for Android

00:43:41.010 --> 00:43:44.190
also supports WebGL.

00:43:44.190 --> 00:43:46.790
So this is pretty typical
WebGL code.

00:43:46.790 --> 00:43:49.720
You ask the canvas
for a context.

00:43:49.720 --> 00:43:52.260
It actually is still
experimental WebGL.

00:43:52.260 --> 00:43:55.140
There's some last conformance
tests being written.

00:43:55.140 --> 00:43:58.830
And then pretty soon, we're
actually going to have

00:43:58.830 --> 00:44:01.820
official WebGL implementations.

00:44:01.820 --> 00:44:02.550
We can drop the experimental.

00:44:02.550 --> 00:44:03.780
It will be very exciting.

00:44:03.780 --> 00:44:05.355
But that is something
to keep in mind.

00:44:07.920 --> 00:44:10.750
So this is typical WebGL code.

00:44:10.750 --> 00:44:11.980
It's very C-like.

00:44:11.980 --> 00:44:13.900
It's not very JavaScript-like.

00:44:13.900 --> 00:44:18.490
If you just feel like you're
getting to know JavaScript or

00:44:18.490 --> 00:44:20.190
you're just getting to the point
where you feel like you

00:44:20.190 --> 00:44:23.750
should really have learned
JavaScript already, this is

00:44:23.750 --> 00:44:24.800
going to be a little
disappointing.

00:44:24.800 --> 00:44:31.380
Because it's not a very
idiomatic JavaScript API.

00:44:31.380 --> 00:44:33.180
And it was chosen for
compatibility

00:44:33.180 --> 00:44:34.350
with OpenGL ES 2.

00:44:34.350 --> 00:44:36.910
This is actually almost exactly
code that you would

00:44:36.910 --> 00:44:42.470
write on, say, an Android phone
or iOS, which is great,

00:44:42.470 --> 00:44:45.870
and it allows a lot of
cross-pollination between

00:44:45.870 --> 00:44:49.000
APIs, but the end result is
that it can be a little

00:44:49.000 --> 00:44:51.590
alienating and a lot to learn.

00:44:51.590 --> 00:44:54.100
And it's kind of old-fashioned,

00:44:54.100 --> 00:44:55.630
because it is old.

00:44:55.630 --> 00:45:01.610
And it's kind of simulating the
graphics stack as a giant

00:45:01.610 --> 00:45:02.600
state machine.

00:45:02.600 --> 00:45:05.190
And as a result, you're binding
buffers and then

00:45:05.190 --> 00:45:07.290
sitting attributes on the
current bound buffer, and then

00:45:07.290 --> 00:45:08.950
switching your bound buffers.

00:45:08.950 --> 00:45:11.290
Anyway, but it doesn't
matter because

00:45:11.290 --> 00:45:13.860
Libraries to the rescue.

00:45:13.860 --> 00:45:16.030
So there are a ton-- a ton--

00:45:16.030 --> 00:45:19.090
of WebGL libraries out
there for you.

00:45:19.090 --> 00:45:21.870
The top three are
my favorites.

00:45:21.870 --> 00:45:24.030
They might not be yours.

00:45:24.030 --> 00:45:25.440
Three.js is by far
the most popular.

00:45:25.440 --> 00:45:27.410
It was started by Mr.doob.

00:45:27.410 --> 00:45:30.730
And he's had just a ton
of people join him.

00:45:30.730 --> 00:45:33.250
And even more recently,
demoscene hackers are coming

00:45:33.250 --> 00:45:33.820
out of the woodwork.

00:45:33.820 --> 00:45:38.340
And they just implemented an
amazing software rasterizer.

00:45:38.340 --> 00:45:42.400
So it actually runs quite well
in IE9 on 2D Canvas.

00:45:42.400 --> 00:45:44.210
And PhiloGl--

00:45:44.210 --> 00:45:47.510
or Phi-lo GL, depending on where
you fall on the Greek

00:45:47.510 --> 00:45:49.110
letter pronunciation--

00:45:49.110 --> 00:45:49.870
is another great one.

00:45:49.870 --> 00:45:52.210
I like it because it's a
little more low-level.

00:45:52.210 --> 00:45:56.980
It doesn't hide as much of the
complexity of OpenGL from you.

00:45:56.980 --> 00:46:01.090
TDL is a library from
Gregg Tavares, who's

00:46:01.090 --> 00:46:02.870
an engineer on Chrome.

00:46:02.870 --> 00:46:05.990
And it's extremely low-level,
but it's great because if you

00:46:05.990 --> 00:46:09.230
want every last little
bell and whistle,

00:46:09.230 --> 00:46:10.250
you can get at it.

00:46:10.250 --> 00:46:13.500
And many more-- if you go to the
Khronos Wiki you can see

00:46:13.500 --> 00:46:15.370
there's just a huge list.

00:46:15.370 --> 00:46:16.710
A lot of them are
games-focused.

00:46:16.710 --> 00:46:19.630
So these are libraries that
are well-suited to

00:46:19.630 --> 00:46:24.120
visualization as opposed to
make a game character and

00:46:24.120 --> 00:46:25.830
animate them and make
them shiny.

00:46:25.830 --> 00:46:30.300
Which is great for everything,
but maybe not perfect.

00:46:30.300 --> 00:46:37.580
So really fast, going through
the WebGL pipeline, your data

00:46:37.580 --> 00:46:40.790
tends to be a giant typed array,
which is a great thing

00:46:40.790 --> 00:46:45.120
that was added to browsers,
which is a continuous block of

00:46:45.120 --> 00:46:50.880
memory that you can allocate
once and have tens of millions

00:46:50.880 --> 00:46:52.030
of data points in there.

00:46:52.030 --> 00:46:55.240
And it typically ends up being
you have attributes one right

00:46:55.240 --> 00:46:59.590
after another, with each vertex
is associated a bunch

00:46:59.590 --> 00:46:59.980
of attributes.

00:46:59.980 --> 00:47:02.160
So here we have x and
y, but it might be

00:47:02.160 --> 00:47:02.760
latitude and longitude.

00:47:02.760 --> 00:47:04.610
And there might be time, and
there might be color.

00:47:04.610 --> 00:47:07.650
And you can have dozens
of attributes

00:47:07.650 --> 00:47:08.970
depending on the hardware.

00:47:08.970 --> 00:47:11.110
But what happens is that
gets split up.

00:47:11.110 --> 00:47:14.860
And so what you end up doing
is when you pass it over to

00:47:14.860 --> 00:47:17.930
the GPU, it's actually
transferred to the GPU memory

00:47:17.930 --> 00:47:21.810
so it can be super efficient,
not a bunch of messages

00:47:21.810 --> 00:47:23.080
passing over the bus.

00:47:23.080 --> 00:47:25.660
It splits those up per vertex.

00:47:25.660 --> 00:47:28.210
And then it passes those things
through the pipeline

00:47:28.210 --> 00:47:29.110
one at a time.

00:47:29.110 --> 00:47:34.160
And so what a GPU really is is a
bunch of parallel processing

00:47:34.160 --> 00:47:37.240
cores shoved on a single
chip and ready to do

00:47:37.240 --> 00:47:38.470
lots of work for you.

00:47:38.470 --> 00:47:41.720
And it's extremely well-suited
to graphics work.

00:47:41.720 --> 00:47:45.270
And it just so happens to be
extremely well-suited to

00:47:45.270 --> 00:47:46.420
geo-visualization work.

00:47:46.420 --> 00:47:48.920
Because if you think about
graphics, all the first things

00:47:48.920 --> 00:47:52.570
were like retracing spheres
and intersecting lines and

00:47:52.570 --> 00:47:55.170
spheres and putting things on
spheres, which happens to be

00:47:55.170 --> 00:48:00.910
the same as the Earth,
if we're kind.

00:48:00.910 --> 00:48:05.450
So if you think about just
taking those attributes per

00:48:05.450 --> 00:48:08.280
vertex and splitting them off,
then we can send it through

00:48:08.280 --> 00:48:10.520
what's called the Vertex Shader,
which is kind of an

00:48:10.520 --> 00:48:11.050
unfortunate name.

00:48:11.050 --> 00:48:12.880
For historical purposes, that's
what it's called.

00:48:12.880 --> 00:48:14.210
But it can do anything
you want.

00:48:14.210 --> 00:48:16.780
It's actually a little
kernel of execution--

00:48:16.780 --> 00:48:19.190
or an execution kernel--

00:48:19.190 --> 00:48:23.150
that runs on your data and can
do all sorts of things to it.

00:48:23.150 --> 00:48:25.060
So it doesn't have to
be geometric in

00:48:25.060 --> 00:48:26.330
nature, which is key.

00:48:26.330 --> 00:48:33.240
Most people think of kind of old
school 1997-era transform

00:48:33.240 --> 00:48:35.540
my 3D point into 3D because
my character's

00:48:35.540 --> 00:48:36.370
moving across the screen.

00:48:36.370 --> 00:48:38.030
It doesn't need to do that.

00:48:38.030 --> 00:48:42.350
So this is some typical
Vertex Shader code.

00:48:42.350 --> 00:48:44.250
It's actually a different
shading language than

00:48:44.250 --> 00:48:45.260
JavaScript.

00:48:45.260 --> 00:48:49.530
The benefit is, one, it's
domain-specific.

00:48:49.530 --> 00:48:53.450
It has things like that vectors
and matrices and

00:48:53.450 --> 00:48:54.860
operator overloading
for those things.

00:48:54.860 --> 00:48:57.080
So it's really nice
to write in.

00:48:57.080 --> 00:48:58.900
And it's very small.

00:48:58.900 --> 00:49:01.970
It's like a tiny little version
of C. So it's easy to

00:49:01.970 --> 00:49:02.850
reason about.

00:49:02.850 --> 00:49:06.340
And the key things here are just
in a vertex shader you

00:49:06.340 --> 00:49:07.270
take inputs.

00:49:07.270 --> 00:49:09.850
They're typically attributes,
as per vertex.

00:49:09.850 --> 00:49:11.300
So this is like lat-long.

00:49:11.300 --> 00:49:13.520
And the last thing is you need
to write a GL position.

00:49:13.520 --> 00:49:15.550
And that's really
all there to it.

00:49:15.550 --> 00:49:17.090
You can do all sorts of
complicated things in the

00:49:17.090 --> 00:49:19.590
meantime, but you need to
write a GL position.

00:49:19.590 --> 00:49:24.310
And what that GL position is
is a point on the screen.

00:49:24.310 --> 00:49:27.390
So you have to forgive
the program art.

00:49:27.390 --> 00:49:28.970
This a point on the screen.

00:49:28.970 --> 00:49:31.910
And there's a great blog series
called "WebGL is a 2D

00:49:31.910 --> 00:49:34.520
API" that if you're interested
you should check out, which is

00:49:34.520 --> 00:49:35.000
pretty interesting.

00:49:35.000 --> 00:49:36.930
Because all it's doing is-- you
don't really care about

00:49:36.930 --> 00:49:39.240
the actual 3D nature of this.

00:49:39.240 --> 00:49:43.880
What you need to do is take some
thing that's represented

00:49:43.880 --> 00:49:46.500
as a vertex and just tell the
machine, I'm going to draw it

00:49:46.500 --> 00:49:47.800
here on the screen.

00:49:47.800 --> 00:49:51.280
And you can do all sorts
of things in between.

00:49:51.280 --> 00:49:54.580
So next is primitive assembly.

00:49:54.580 --> 00:49:57.190
And this depends on the original
layout of that array

00:49:57.190 --> 00:50:00.840
that you passed to WebGL
in the first place.

00:50:00.840 --> 00:50:02.120
There's three different
kinds of primitives.

00:50:02.120 --> 00:50:04.190
There's triangles, lines,
and points.

00:50:04.190 --> 00:50:10.620
And so what WebGL does is it
takes those three points, it

00:50:10.620 --> 00:50:14.180
says, here's all the pixels in
between, and I need to fill

00:50:14.180 --> 00:50:15.340
those with color.

00:50:15.340 --> 00:50:19.100
And the final stage is it takes
each one of those pixels

00:50:19.100 --> 00:50:22.050
and passes it to yet another
execution kernel, where you

00:50:22.050 --> 00:50:23.460
can run another program on it.

00:50:23.460 --> 00:50:28.330
And in this case, you take all
sorts of inputs that might be

00:50:28.330 --> 00:50:29.810
interpreted across
the primitive.

00:50:29.810 --> 00:50:31.690
So if you have color on each
of those three points, you

00:50:31.690 --> 00:50:33.840
find the interpolated color.

00:50:33.840 --> 00:50:35.180
And in the end, all
you need to do is

00:50:35.180 --> 00:50:36.980
output a GL frag color.

00:50:36.980 --> 00:50:39.060
So it's just like an RGBA.

00:50:39.060 --> 00:50:43.830
And the amazing thing about this
is this is what gets you

00:50:43.830 --> 00:50:48.360
the amazing 3D graphics that
we have in modern games.

00:50:48.360 --> 00:50:51.610
You take interpolated data about
geometry, and surface

00:50:51.610 --> 00:50:53.180
roughness, and material
properties,

00:50:53.180 --> 00:50:54.780
and maybe some textures.

00:50:54.780 --> 00:50:55.970
You put it all together.

00:50:55.970 --> 00:50:59.000
And you just write
one little RGBA.

00:50:59.000 --> 00:51:01.610
But taken as a whole, you end
up having like a smooth

00:51:01.610 --> 00:51:04.230
surface with crazy
things going on.

00:51:04.230 --> 00:51:07.600
And we can use that same
thing for non--

00:51:07.600 --> 00:51:10.080
it doesn't have to
be a 3D model.

00:51:10.080 --> 00:51:12.120
It can also be your
point data.

00:51:12.120 --> 00:51:13.130
We can start talking
about geodesics.

00:51:13.130 --> 00:51:17.300
We can start talking
about isosurfaces,

00:51:17.300 --> 00:51:18.460
that sort of thing.

00:51:18.460 --> 00:51:21.260
It can be anything we want.

00:51:21.260 --> 00:51:26.940
So the key here, though, is that
you have all these cores

00:51:26.940 --> 00:51:28.960
waiting to execute
things for you.

00:51:28.960 --> 00:51:30.190
This machine is two years old.

00:51:30.190 --> 00:51:31.870
It has 48 cores in there.

00:51:31.870 --> 00:51:36.270
So it runs basically through--
rather than doing a for loop

00:51:36.270 --> 00:51:40.530
over your long array there, it
splits it up into all its

00:51:40.530 --> 00:51:41.300
constituent parts.

00:51:41.300 --> 00:51:43.630
And it runs at it-- in
the ideal case--

00:51:43.630 --> 00:51:47.337
at 50 times the speed that it
would if you just looped over

00:51:47.337 --> 00:51:48.740
the thing naively.

00:51:48.740 --> 00:51:50.760
And meanwhile, this thing is
optimized for the kind of

00:51:50.760 --> 00:51:52.080
vector operations that
you need to do.

00:51:52.080 --> 00:51:56.790
So it does amazing things.

00:51:56.790 --> 00:51:59.600
So just to cut this short,
I won't click on this.

00:51:59.600 --> 00:52:05.280
But GLSL is the shading
language of WebGL.

00:52:05.280 --> 00:52:08.590
And it's great to think about
it as a scripting language,

00:52:08.590 --> 00:52:10.580
rather than something
that enforces a lot

00:52:10.580 --> 00:52:13.500
of things on you.

00:52:13.500 --> 00:52:15.870
We're embedding it in a dynamic
language, JavaScript.

00:52:15.870 --> 00:52:19.370
And it itself is not dynamic,
and it's statically typed, but

00:52:19.370 --> 00:52:22.620
you're passing it in plain
text to the driver.

00:52:22.620 --> 00:52:25.680
And as a result, you can sit
there, and tweak it, and pass

00:52:25.680 --> 00:52:29.700
it, and the driver will either
say, no, that's bad, or, OK,

00:52:29.700 --> 00:52:31.400
I'll take that, and
draw with it.

00:52:31.400 --> 00:52:35.230
And as a result, people-- well,
I'll just click on it--

00:52:35.230 --> 00:52:42.800
people actually have created
little scripting environments,

00:52:42.800 --> 00:52:47.475
where you actually have the code
right here on the screen.

00:52:47.475 --> 00:52:49.750
And as you change it--
so if I change--

00:52:49.750 --> 00:52:55.615
we can make things kind of less
distinct, you sit here

00:52:55.615 --> 00:52:56.560
and change the code
right here.

00:52:56.560 --> 00:53:00.400
And if you make an error, it'll
actually highlight that

00:53:00.400 --> 00:53:01.340
line where you made the error.

00:53:01.340 --> 00:53:07.910
So it's yet another level of
dynamic execution that we can

00:53:07.910 --> 00:53:11.140
add to our workflows to
do awesome things.

00:53:13.980 --> 00:53:15.380
So I wanted to show
one last demo.

00:53:15.380 --> 00:53:22.700
And this is based on data that
comes from Earth Engine, which

00:53:22.700 --> 00:53:23.700
is an amazing project.

00:53:23.700 --> 00:53:26.480
And there's a session
at some point--

00:53:26.480 --> 00:53:26.980
there's not?

00:53:26.980 --> 00:53:27.894
Oh.

00:53:27.894 --> 00:53:28.810
MALE SPEAKER: Tomorrow.

00:53:28.810 --> 00:53:29.730
BRENDAN KENNY: Tomorrow!

00:53:29.730 --> 00:53:31.980
And you should definitely go,
because it's amazing.

00:53:31.980 --> 00:53:38.070
But what I use it for is
actually for raster data.

00:53:38.070 --> 00:53:40.110
So while this is loading--

00:53:43.000 --> 00:53:46.580
so you have tiles come down from
the server to show maps,

00:53:46.580 --> 00:53:49.480
or show satellite imagery,
or show your

00:53:49.480 --> 00:53:51.075
overlay on top of it.

00:53:51.075 --> 00:53:53.970
But there's no reason that that
has to be what you show

00:53:53.970 --> 00:53:54.700
to the end user.

00:53:54.700 --> 00:53:59.280
You can actually use that as
input to that pipeline and run

00:53:59.280 --> 00:54:01.350
processes on it--

00:54:01.350 --> 00:54:04.410
hopefully run processes
on it--

00:54:04.410 --> 00:54:05.540
and get an output.

00:54:05.540 --> 00:54:08.500
And like I said, there's
no need for it to be

00:54:08.500 --> 00:54:09.170
photorealistic.

00:54:09.170 --> 00:54:11.450
There's no need for it to be--

00:54:11.450 --> 00:54:15.110
you get a road in, you
put a road out.

00:54:15.110 --> 00:54:16.730
So here's an old version.

00:54:16.730 --> 00:54:20.030
And this is less exciting,
because it is photorealistic.

00:54:20.030 --> 00:54:25.160
So what's actually coming down
the wire is, if we look in

00:54:25.160 --> 00:54:28.640
here, we can look at
one at these tiles.

00:54:28.640 --> 00:54:33.840
So this is a tile that has a
normal data to the surface.

00:54:33.840 --> 00:54:37.780
So it shows what is the
direction of the surface.

00:54:37.780 --> 00:54:41.730
And then you can start doing
lighting on it, and actually

00:54:41.730 --> 00:54:43.700
light your terrain
in real time.

00:54:43.700 --> 00:54:45.240
So this is lit in real time.

00:54:45.240 --> 00:54:51.230
And you can actually see,
so this is Oregon.

00:54:51.230 --> 00:54:52.976
So this is Mt.

00:54:52.976 --> 00:54:54.440
Hood down here, and this is--

00:54:54.440 --> 00:54:54.893
I think that's Mt.

00:54:54.893 --> 00:54:56.850
St. Helens.

00:54:56.850 --> 00:54:58.690
So you'll have to imagine.

00:54:58.690 --> 00:55:01.950
And so I'll post something
about this

00:55:01.950 --> 00:55:03.230
later to get it working.

00:55:03.230 --> 00:55:05.980
But there's no reason
it has to be

00:55:05.980 --> 00:55:07.140
geometric data like this.

00:55:07.140 --> 00:55:09.235
So Earth Engine has a bunch of
sources, and there's a bunch

00:55:09.235 --> 00:55:11.900
of sources out there available
for free-- you just have to

00:55:11.900 --> 00:55:13.910
serve them--

00:55:13.910 --> 00:55:19.330
but about land use, about
elevation data, about all

00:55:19.330 --> 00:55:20.780
sorts of demographic data.

00:55:20.780 --> 00:55:22.990
And you can start looking at
ways that you can use these

00:55:22.990 --> 00:55:29.550
shaders to actually start
showing ways that--

00:55:29.550 --> 00:55:32.730
so you could start actually
visualizing those things in

00:55:32.730 --> 00:55:35.120
ways that aren't discrete
and aren't just a

00:55:35.120 --> 00:55:36.700
straight image of points.

00:55:36.700 --> 00:55:38.970
So you can start saying, give
me all the pixels that are

00:55:38.970 --> 00:55:45.040
red, but also are within some
distance of the city, things

00:55:45.040 --> 00:55:47.270
like that, and then actually
shade them in a way that

00:55:47.270 --> 00:55:49.870
highlights the area
with a map.

00:55:49.870 --> 00:55:51.600
And so this would be a lot more
interesting if it was

00:55:51.600 --> 00:55:52.850
here, but that's OK.

00:55:58.910 --> 00:56:00.830
So we're going to wrap
it up, because we're

00:56:00.830 --> 00:56:01.560
basically out of time.

00:56:01.560 --> 00:56:07.240
But definitely visit
developers.google.com/maps for

00:56:07.240 --> 00:56:10.550
all the new stuff, heatmaps,
and polylines, and symbols

00:56:10.550 --> 00:56:11.620
along paths.

00:56:11.620 --> 00:56:15.160
And it's live right now.

00:56:15.160 --> 00:56:16.740
You can go see the
documentation.

00:56:16.740 --> 00:56:18.530
Then check out canvas layer.

00:56:18.530 --> 00:56:21.620
And Mano Marks and I are
actually going to be doing a

00:56:21.620 --> 00:56:25.280
summer learning series coming up
in the upcoming weeks that

00:56:25.280 --> 00:56:29.530
kind of walks through this WebGL
stuff and shows you ways

00:56:29.530 --> 00:56:33.370
of maybe importing your existing
geographic data,

00:56:33.370 --> 00:56:36.250
visualizing it in a way that's
interesting and useful.

00:56:36.250 --> 00:56:39.570
And hopefully you'll get
something out of it.

00:56:39.570 --> 00:56:42.690
So I think we have a few
minutes for questions.

00:56:42.690 --> 00:56:46.670
And if we don't get to your
question, then we'll be over

00:56:46.670 --> 00:56:49.730
in office hours and you
can come and quiz us.

00:56:49.730 --> 00:56:52.480
And I can make my demo work if
you want to come see it.

00:56:52.480 --> 00:56:54.290
If you have a question, would
you go to the mic?

00:56:57.260 --> 00:57:06.680
[APPLAUSE]

00:57:06.680 --> 00:57:09.326
BRENDAN KENNY: One minute
and 30 seconds.

00:57:09.326 --> 00:57:11.260
Yeah?

00:57:11.260 --> 00:57:14.830
AUDIENCE: So for heatmaps, is
it possible to have multiple

00:57:14.830 --> 00:57:16.910
points that are of the
same intensity

00:57:16.910 --> 00:57:18.060
but different colors?

00:57:18.060 --> 00:57:21.580
Or is color always keyed
off of intensity?

00:57:21.580 --> 00:57:23.960
ENOCH LAU: Color is always keyed
off the intensity, but

00:57:23.960 --> 00:57:26.880
each data point can have an
additional weight attribute.

00:57:26.880 --> 00:57:30.240
So you can make one point
worth 1,000 points.

00:57:30.240 --> 00:57:30.860
AUDIENCE: I see.

00:57:30.860 --> 00:57:32.220
So you would normalize
that way.

00:57:32.220 --> 00:57:32.930
Thanks very much.

00:57:32.930 --> 00:57:34.180
ENOCH LAU: No worries.

00:57:38.020 --> 00:57:39.580
AUDIENCE: When you're using a
symbol as a marker, are you

00:57:39.580 --> 00:57:42.440
able to add a label to that?

00:57:42.440 --> 00:57:42.570
ENOCH LAU: Pardon?

00:57:42.570 --> 00:57:43.920
What was that again?

00:57:43.920 --> 00:57:46.720
AUDIENCE: Using as symbol as a
marker, could you add a label

00:57:46.720 --> 00:57:47.710
onto that marker?

00:57:47.710 --> 00:57:48.835
So if I [INAUDIBLE]

00:57:48.835 --> 00:57:51.480
cluster, that label would
tell how many

00:57:51.480 --> 00:57:52.880
points were in the cluster?

00:57:52.880 --> 00:57:53.190
ENOCH LAU: Sure.

00:57:53.190 --> 00:57:54.920
By label you mean like
a text label?

00:57:54.920 --> 00:57:55.340
AUDIENCE: Sure.

00:57:55.340 --> 00:57:55.890
ENOCH LAU: That's right.

00:57:55.890 --> 00:57:57.390
So there are two ways
you can do this.

00:57:57.390 --> 00:57:59.410
There's an existing library
called [? MAC ?]

00:57:59.410 --> 00:58:00.190
Label, I believe.

00:58:00.190 --> 00:58:02.810
And it's on in the utility
library website.

00:58:02.810 --> 00:58:06.840
You can get that today, and you
can render text on the map

00:58:06.840 --> 00:58:08.710
at arbitrary lat-long
locations.

00:58:08.710 --> 00:58:12.010
In addition there, you can use
the new symbols functionality

00:58:12.010 --> 00:58:12.970
to also render text.

00:58:12.970 --> 00:58:16.190
So one thing you can do is use
an open source library called

00:58:16.190 --> 00:58:21.280
Raphael, and that turns
fonts into SVG paths.

00:58:21.280 --> 00:58:23.980
So you can take a font turned
SVG path, and then use that

00:58:23.980 --> 00:58:26.850
custom SVG functionality that
I talked about to put that

00:58:26.850 --> 00:58:28.880
onto a polyline,
or on a marker.

00:58:32.050 --> 00:58:34.560
AUDIENCE: Any plans
for GWT wrappers

00:58:34.560 --> 00:58:37.130
around Google Maps API?

00:58:37.130 --> 00:58:38.170
ENOCH LAU: What was
that again?

00:58:38.170 --> 00:58:40.755
AUDIENCE: GWT wrappers
around Google--

00:58:40.755 --> 00:58:41.950
ENOCH LAU: I believes
it's in the works.

00:58:41.950 --> 00:58:42.570
MALE SPEAKER: They're out.

00:58:42.570 --> 00:58:43.030
AUDIENCE: It's in the works.

00:58:43.030 --> 00:58:43.400
ENOCH LAU: Oh, they're out?

00:58:43.400 --> 00:58:44.232
OK, sure.

00:58:44.232 --> 00:58:45.480
AUDIENCE: Thanks.

00:58:45.480 --> 00:58:46.330
BRENDAN KENNY: Yeah.

00:58:46.330 --> 00:58:47.320
Stop by the office hours.

00:58:47.320 --> 00:58:50.190
We can chat about it.

00:58:50.190 --> 00:58:53.330
AUDIENCE: I wanted to clarify on
the canvas layer, you don't

00:58:53.330 --> 00:58:56.110
have it synchronized with
the map [INAUDIBLE].

00:58:56.110 --> 00:58:58.370
Was the reason for that for
future compatibility when you

00:58:58.370 --> 00:58:59.750
make that all work
under WebGL?

00:58:59.750 --> 00:59:02.000
I was a little confused
on that point.

00:59:02.000 --> 00:59:02.930
BRENDAN KENNY: Well, so
there's two reasons.

00:59:02.930 --> 00:59:04.110
One is efficiency.

00:59:04.110 --> 00:59:07.190
Because if you let it be regular
overlay, it actually

00:59:07.190 --> 00:59:08.630
will move with the map.

00:59:08.630 --> 00:59:12.740
And so you'll see either breaks
between where it exists

00:59:12.740 --> 00:59:16.110
and where the edges of the
screen are, or you just have

00:59:16.110 --> 00:59:17.780
to allocate a much
bigger canvas.

00:59:17.780 --> 00:59:19.440
And that's expensive.

00:59:19.440 --> 00:59:22.240
The other thing is, when you
actually get to WebGL, if you

00:59:22.240 --> 00:59:26.520
start boxing somebody into a
particular transformation

00:59:26.520 --> 00:59:28.370
method, it is limiting.

00:59:28.370 --> 00:59:31.710
And so it might be good to pick
a sensible default for

00:59:31.710 --> 00:59:35.050
that, but I know that in the
maps that I've made, I tend to

00:59:35.050 --> 00:59:37.580
do slightly different things
on different maps.

00:59:37.580 --> 00:59:40.360
So it's fairly straightforward
code.

00:59:40.360 --> 00:59:41.565
But depending on how
you want to do

00:59:41.565 --> 00:59:43.370
it, it will be different.

00:59:43.370 --> 00:59:45.440
AUDIENCE: Yeah, in the past I've
done canvas as a regular

00:59:45.440 --> 00:59:48.540
overlay layer and stuck my
own canvas in there.

00:59:48.540 --> 00:59:50.230
But I can port it to this
if I just do your

00:59:50.230 --> 00:59:51.320
update thing, right?

00:59:51.320 --> 00:59:51.710
BRENDAN KENNY: Yes.

00:59:51.710 --> 00:59:56.000
So for 2D canvas you'll have
more calls to the update

00:59:56.000 --> 01:00:01.270
function than you do-- because
normally it calls on zoom and

01:00:01.270 --> 01:00:03.640
resize, I think is
usually-- yeah.

01:00:03.640 --> 01:00:03.840
AUDIENCE:OK, great.

01:00:03.840 --> 01:00:04.240
I'll check it out.

01:00:04.240 --> 01:00:04.650
Thanks.

01:00:04.650 --> 01:00:06.550
BRENDAN KENNY: Sure.

01:00:06.550 --> 01:00:07.560
ENOCH LAU: Unfortunately, I
think we're out of time.

01:00:07.560 --> 01:00:10.610
So perhaps if you have further
questions, please meet us

01:00:10.610 --> 01:00:11.330
after the talk.

01:00:11.330 --> 01:00:13.880
We'll be over at office hours
outside in the Geo Office

01:00:13.880 --> 01:00:15.170
Hours area.

01:00:15.170 --> 01:00:16.420
Thanks.

