WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:05.669
&gt;&gt; DANILATOS: Hello everyone. Yeah. So my
name is Daniel, I work with GWT on the Google

00:00:05.669 --> 00:00:11.410
Wave Client in Sydney. So today, I'd like
to share with you some of the best practices

00:00:11.410 --> 00:00:17.199
we've found have served us well over time
with respect to writing reliable testable

00:00:17.199 --> 00:00:21.949
GWT applications. It used to be that it was
hard for us to write with unit tests. But

00:00:21.949 --> 00:00:25.489
by applying some of the ideas I'm going to
show you, we were able to bring much of our

00:00:25.489 --> 00:00:31.539
code under test so that when bugs are fixed,
they stayed fix. All right, so just before

00:00:31.539 --> 00:00:37.510
I begin, I've been asked to point out this
link here to this talk's wave where you can

00:00:37.510 --> 00:00:43.420
ask questions and see notes being taken. All
right, so what did I mean when I said good

00:00:43.420 --> 00:00:49.260
unit test? Well, we can probably agree that
these are some properties of good unit tests.

00:00:49.260 --> 00:00:56.710
Obviously, we want them to run fast, we want
have good code coverage, and we want to have

00:00:56.710 --> 00:01:03.210
both testing granular--code at a granular
but also at an integration level. At Google,

00:01:03.210 --> 00:01:09.111
we have this little convention where you probably
heard about it before. We have small test,

00:01:09.111 --> 00:01:14.880
medium test, and large tests. Small tests
are the ones that run in, you know--milliseconds

00:01:14.880 --> 00:01:19.720
and have no external--they don't depending
on network resource or anything like that.

00:01:19.720 --> 00:01:25.830
And we try to have a rule of about 70/20/10
where 70% of our tests are small tests, 20%

00:01:25.830 --> 00:01:30.140
are medium, and 10% are large tests. And the
large test--well, a GWTTestCase would count

00:01:30.140 --> 00:01:38.340
as a large test. So we don't want--we want
most of our tests not actually be those. All

00:01:38.340 --> 00:01:45.570
right, so unfortunately--okay, so testable
code simplifies writing such GWT tests. Now

00:01:45.570 --> 00:01:48.960
unfortunately, GWT applications face some
inherent difficulties in the way of achieving

00:01:48.960 --> 00:01:53.740
this. And I go through some of them. First
and most importantly is JSNI code. Does everyone

00:01:53.740 --> 00:01:58.189
know what JSNI is? Just in case, I'll quickly
explain, JSNI stands for JavaScript Native

00:01:58.189 --> 00:02:04.409
Interface. It is JavaScript code which comprises
the lowest building blocks upon which a GWT

00:02:04.409 --> 00:02:09.720
app--GWT apps are ultimately based. It is
a necessary bridge for interacting with the

00:02:09.720 --> 00:02:15.300
DOM and other browser features. Obviously,
to run code that calls into JSNI requires

00:02:15.300 --> 00:02:22.170
having either a browser or some kind of browser
emulator. And GWTTestCase provides this facility.

00:02:22.170 --> 00:02:27.670
So any code that we want to test would transitively
depends on the execution of some JSNI requires

00:02:27.670 --> 00:02:34.410
sub-classing GWTTestCase. Unfortunately, this
means that most--this implies most of the

00:02:34.410 --> 00:02:43.090
GWT Widget and DOM Library and any application-specific
low-level code would need GWTTestCase. So

00:02:43.090 --> 00:02:47.800
the problem with GWTTestCase, maybe you guys
probably have known is it's slow and cumbersome

00:02:47.800 --> 00:02:53.099
to use. Ultimately for realistic integration
level testing, GWTTestCase and Selenium or

00:02:53.099 --> 00:02:58.140
WebDriver based testing is necessary. But
to iterate quickly and easily achieve higher

00:02:58.140 --> 00:03:02.280
code coverage, we need to be able to put as
much of our code under plain old fashion,

00:03:02.280 --> 00:03:08.500
just lightweight JUnit testing as possible.
Okay, so the next problem is we need to simulate

00:03:08.500 --> 00:03:14.120
user interactions. This is further hampered
by a cross-browser event behavior differences.

00:03:14.120 --> 00:03:21.069
And I'll talk about that particular point
a bit of depth later. For example, the differences

00:03:21.069 --> 00:03:28.790
between key down, key press, mouse down, click
and so forth can be quite insidious between

00:03:28.790 --> 00:03:35.190
browsers. So some information--the next point--some
information needed by our programs can only

00:03:35.190 --> 00:03:39.300
be properly obtained from a real browser.
For example, if we're asking the DOM about

00:03:39.300 --> 00:03:46.290
its size, like how big it actually ended up
being rendered. And frequently, there are

00:03:46.290 --> 00:03:51.230
tricky optimizations that we need to perform
that are specific to the web environment.

00:03:51.230 --> 00:03:56.629
For example, widget reuse or data structures
optimized for the browser environment or even

00:03:56.629 --> 00:04:04.580
on a web browser basis. Often, we need to
defer execution. So for example, by using

00:04:04.580 --> 00:04:09.470
DeferredCommand or timer in order to allow
layout to be performed further before further

00:04:09.470 --> 00:04:14.040
action or to split up a long running task,
so it doesn't block the UI and other such

00:04:14.040 --> 00:04:19.900
reasons. Okay, and so all of these things
can be odds with testing. So writing web applications

00:04:19.900 --> 00:04:23.650
is a naturally test hostile environment. And
now that we've got these problems at the front

00:04:23.650 --> 00:04:27.440
of my mind, I'd like to go into some patterns
and ideas that we found helpful in our experience

00:04:27.440 --> 00:04:35.690
over time. The first thing I'd like to talk
about is the MVP pattern. MVP stands for Model

00:04:35.690 --> 00:04:40.190
View Presenter. Now, if you're here last year,
you may remember Ray Ryan's talk about GWT

00:04:40.190 --> 00:04:44.680
application architecture that discussed among
other things with the use of MVP in building

00:04:44.680 --> 00:04:50.070
the AdWords front-end. It's a great talk.
I encourage you all to check it out. It's

00:04:50.070 --> 00:04:54.060
on YouTube. What I'm going to outline here.
I have a few subtle differences but produce

00:04:54.060 --> 00:05:00.070
is basically the same. Okay, so I like to
use this little diagram to help explain MVP.

00:05:00.070 --> 00:05:04.340
It represents for a conceptual flow of a UI
application. Whether or not it's explicitly

00:05:04.340 --> 00:05:09.950
stored, a GUI application has at all time
some kind of presentation state. What you

00:05:09.950 --> 00:05:14.690
see displayed in the UI is a function of that
state. So there is some logic, which is at

00:05:14.690 --> 00:05:21.301
the top here, but--well, conceptually mapping
at the top here--that maps the state to the

00:05:21.301 --> 00:05:27.710
display. And in many cases, if we're just
hacking something up, the display in the state,

00:05:27.710 --> 00:05:31.050
you know, would just be conflated together
without any distinction. On the other side

00:05:31.050 --> 00:05:36.500
of the loop, the user actions trigger code
that update the presentation stage. Now in

00:05:36.500 --> 00:05:42.949
GWT, it's "for display code" over here, that
is the hard to test code. It's a code where

00:05:42.949 --> 00:05:48.550
most of our widget and JSNI and on browser
event handles of JSO events and so forth.

00:05:48.550 --> 00:05:56.080
And what MVP is particularly good at is isolating
that hard to test code to the greatest extent

00:05:56.080 --> 00:06:01.380
possible and while still trying to be a lightweight
pattern. So in MVP, we have a view and we

00:06:01.380 --> 00:06:09.520
have a presenter. And the idea is basically
put all the complicated stuff in here, all

00:06:09.520 --> 00:06:14.669
the logic in here and leave this to be as
simple as possible, the part that actually

00:06:14.669 --> 00:06:23.360
we can't test very well. So it's--and so the
presenter can then communicate to this view

00:06:23.360 --> 00:06:29.560
through a very DOM easily implementable interface.
All right, so the goal we're trying to achieve

00:06:29.560 --> 00:06:34.160
here is that our JSNI-dependent display code
has kept minimal and trivial and ideally correct

00:06:34.160 --> 00:06:38.850
by construction while all our logic is in
testable presenters. Presenters know nothing

00:06:38.850 --> 00:06:43.889
of their view implementation as the views--dependents
are injected into the presenters. Contrast

00:06:43.889 --> 00:06:50.259
this with MVC, we're roughly speaking until
someone might find, you know, self-aware error

00:06:50.259 --> 00:06:55.660
in this. But basically, the thing called the
view confines the whole rendering logic and

00:06:55.660 --> 00:07:01.130
display together. So here rather than logic
pushing updates to a simple view interface,

00:07:01.130 --> 00:07:06.370
the whole view pulls what it needs from the
presentation or model. And we have a controller

00:07:06.370 --> 00:07:12.360
down the bottom that handles UI Events in
a similar fashion. Okay. So here is--just

00:07:12.360 --> 00:07:17.710
to, sort of, put this in a different way maybe,
here is an example of an MVP-type hierarchy

00:07:17.710 --> 00:07:24.340
for a Foo UI component. We have a FooPresenter
and a FooViewInterface. And the presenter

00:07:24.340 --> 00:07:28.100
knows only of and talks only through the view
interface. It doesn't know anything about

00:07:28.100 --> 00:07:32.889
what specific implementation is backing it.
In turn, it receives UI gesture events as

00:07:32.889 --> 00:07:37.941
a listener of its view and deal with them.
So let's start with a particularly trivial

00:07:37.941 --> 00:07:42.400
example for illustrative purposes, an image
thumbnail widget. The capabilities of this

00:07:42.400 --> 00:07:47.430
widget are quite simple. It can display an
image and a caption and it accepts clicking

00:07:47.430 --> 00:07:52.729
as an actionable UI gesture. So pretty much
all we need in our view interface is exactly

00:07:52.729 --> 00:07:58.220
that. Two push methods to set the URL and
the caption and a simple listener interface

00:07:58.220 --> 00:08:02.810
that provides all the click events. An application
can choose to do all kinds of complicated

00:08:02.810 --> 00:08:06.669
things with this pretty simple building block.
But our application logic is shielded from

00:08:06.669 --> 00:08:11.850
the display concerns behind this simple interface.
Now before I go further, I just want to throw

00:08:11.850 --> 00:08:15.680
this in here. Everything I'm saying here is
the result of our experiences talking about

00:08:15.680 --> 00:08:20.419
things that have worked well for us. I don't
mean for any of this to be prescriptive. So

00:08:20.419 --> 00:08:24.810
remember, the goal at the end of a day is
to write clean factored testable code, not

00:08:24.810 --> 00:08:30.960
to blindly follow some [INDISTINCT]. So for
us in our experience, MVP helped us a lot

00:08:30.960 --> 00:08:35.829
to solve our problems--outlined at the start.
Not all of them, but a lot of them. And I'll

00:08:35.829 --> 00:08:42.619
go throughout the solutions as well. And we
found it useful in that it was--we could incrementally

00:08:42.619 --> 00:08:49.170
apply it to. We didn't have to rewrite everything
from scratch. Okay, so with that in mind,

00:08:49.170 --> 00:08:53.730
I like to outline some general guidelines,
without being prescriptive. I'll be giving

00:08:53.730 --> 00:08:58.829
examples shortly. So first off--well, the
whole point is we don't want any transitive

00:08:58.829 --> 00:09:03.630
dependency on JSNI in order to run. Otherwise,
we can't--we have to use GWTTestCase so [INDISTINCT]

00:09:03.630 --> 00:09:13.870
purpose. Presenter should maintain full presentations
state. That means they don't--now the state

00:09:13.870 --> 00:09:18.540
is maintained in the view, they don't have
to ask the view, "Hey view, tell me what currently

00:09:18.540 --> 00:09:27.559
I set you to this value or whatever." They
don't have to be recyclable. So this is not

00:09:27.559 --> 00:09:32.029
really a rule of thumb. It's more--just something
to point out that in practice if we're going

00:09:32.029 --> 00:09:37.989
to be reusing or recycling widgets, we found
in our experience that most of the performance

00:09:37.989 --> 00:09:42.559
speed updates from reusing the DOM, not the
presenter which is a very lightweight object

00:09:42.559 --> 00:09:48.180
in comparison. So you know, you can keep the
logical at simply by not having to do that.

00:09:48.180 --> 00:09:53.040
I'll talk about that a little bit more. And,
you know, presenters can delegate to each

00:09:53.040 --> 00:10:00.550
other like using an event bus. It's up to
you. All right, another point is to avoid

00:10:00.550 --> 00:10:06.179
the new keyword. I mean obviously, you need
to construct the object somewhere, but in

00:10:06.179 --> 00:10:11.860
your presenters, you should, as much as possible,
dependency inject a collaborated so that you

00:10:11.860 --> 00:10:15.170
can provide different ones for testing. I'm
not talking about just the views but also

00:10:15.170 --> 00:10:19.779
other presenters and so forth. And I encourage
you to try Gin. It's--you probably have heard

00:10:19.779 --> 00:10:27.439
of it. It's a dependency injection framework
which is juice for GWT. Okay, now onto the

00:10:27.439 --> 00:10:33.899
juicy bit. View interfaces, this is the most
important part. If you designed a good view

00:10:33.899 --> 00:10:38.149
interface, everything else will follow. So
they should be satisfied or satisfiable--I

00:10:38.149 --> 00:10:44.069
should say--by an obvious trivial implementations.
A default [INDISTINCT] implementation for

00:10:44.069 --> 00:10:48.779
testing would, in theory, be machine generatable.
In fact in many cases, it should be possible

00:10:48.779 --> 00:10:52.949
for a blank implementation to be a valid one.
So we just have all these blank methods for

00:10:52.949 --> 00:10:58.029
many of your interfaces, giving that to a
presenter will--it will still function perfectly,

00:10:58.029 --> 00:11:05.439
correctly, and not have any bugs. You can't
[INDISTINCT] all cases, but in many cases,

00:11:05.439 --> 00:11:11.350
you can. So what is important? So like this
is not to say that it can't contain logic,

00:11:11.350 --> 00:11:14.949
the view implementations. They most certainly
can. And I'll give you some interesting examples

00:11:14.949 --> 00:11:18.940
of this, but what is important is that they
are implementable in an obvious trivial way.

00:11:18.940 --> 00:11:24.029
The implementation should follow from the
interface. This makes testing easy and accurate.

00:11:24.029 --> 00:11:31.089
And in practice, most real widget implementations
of a view interface will, in fact, lack non-trivial

00:11:31.089 --> 00:11:40.130
logic. So, the second point is that the view
interfaces should avoid implying a particular

00:11:40.130 --> 00:11:44.980
layout or design. They should present an interface
relevant to the application logic we want

00:11:44.980 --> 00:11:50.839
to test. This model is good, not just for
testing but, for example, should--would be

00:11:50.839 --> 00:11:55.160
good for an app that wants to have both desktop
browser and and mobile browser views or even

00:11:55.160 --> 00:12:00.269
for a non-webapp version and application.
Finally, for the last point, avoiding state

00:12:00.269 --> 00:12:05.939
getters simplifies the view contract, because
then view implementations aren't required

00:12:05.939 --> 00:12:11.819
to maintain any state. So that tries another
one I say about presenters should maintain

00:12:11.819 --> 00:12:15.449
full presentation state. I don't mean views
can contain getters, but they shouldn't [INDISTINCT]

00:12:15.449 --> 00:12:22.459
state. I'll give you examples of this. So
lack of redundant state avoids potential bugs

00:12:22.459 --> 00:12:26.660
and requires less code. There can be some
exceptions, for example [INDISTINCT] but this

00:12:26.660 --> 00:12:32.019
kind of thing is not state explicitly maintain
by the view. And so it's not redundant. In

00:12:32.019 --> 00:12:36.939
any cases, it's fairly easy to mark out the
tests. All right, in terms of the events that

00:12:36.939 --> 00:12:43.129
views in, event center view listener should
be at the correct semantic level. They are

00:12:43.129 --> 00:12:48.610
in semantic level. They are too few--that's
why they are too low if they correspond directly

00:12:48.610 --> 00:12:55.079
to browser events such as key down and key
press. And this also pushes cross-browser

00:12:55.079 --> 00:13:00.120
event pane into our application logic. They
are too high if they correspond to application

00:13:00.120 --> 00:13:05.420
logic itself--resulting in [INDISTINCT]. For
example, we didn't create an open image or

00:13:05.420 --> 00:13:12.040
show a slideshow in that image thumb in our
example here. We just have a, you know, click.

00:13:12.040 --> 00:13:20.809
The user [INDISTINCT] UI gesture. It's because
it's not the image on those to care what happens

00:13:20.809 --> 00:13:24.880
when it's clicked. So--and finally, prefer
limiting views to one listener. If you have

00:13:24.880 --> 00:13:29.499
more than one, that's probably code [INDISTINCT]
as the view is being made to maintain too

00:13:29.499 --> 00:13:37.989
much. So if this is a slide departure from
Ray Ryan's talk where he advocated having

00:13:37.989 --> 00:13:45.320
methods like HasHandlers, getButton, HasClickHandlers,
getButton. So where you would get a button

00:13:45.320 --> 00:13:49.001
from a view and attach handlers--click handlers
to it like that. There's something wrong with

00:13:49.001 --> 00:13:59.549
that. I just personally prefer the more--an
interface where the implementation can be

00:13:59.549 --> 00:14:07.192
more blank. And this way, the event listening
is simpler. So at this point, I like to illustrate

00:14:07.192 --> 00:14:12.209
with a more real example from my own experience
which illustrates many of the main points.

00:14:12.209 --> 00:14:17.129
Google Waves, Wave Panel UI. Now, I'll just
quickly explain the cut down version of the

00:14:17.129 --> 00:14:21.799
UI for those unfamiliar so we're on the same
page. Conceptually, you can think of a Wave

00:14:21.799 --> 00:14:26.699
as nested threads. Each thread contains are
the GWT switching messages or more threads.

00:14:26.699 --> 00:14:32.399
So this is basically what would be stored
in the model so to speak, something like this.

00:14:32.399 --> 00:14:37.949
When I want to render it, we want the groups
to show up like this and they're grouped into

00:14:37.949 --> 00:14:45.139
a thread as you can see. And note the green
bars on the left, which--note read or unread

00:14:45.139 --> 00:14:49.290
status. A clickable blue widget at the bottom
of the blips prompts the user to add a new

00:14:49.290 --> 00:14:56.149
blip to the end of a thread like so. And it
can show up differently between blips, prompting

00:14:56.149 --> 00:15:03.339
creation of an indented sub-thread like so--with
its own blips. And also, note how the Chrome

00:15:03.339 --> 00:15:07.860
around the Blips differs depending on their
place in the UI, for example, whether or not

00:15:07.860 --> 00:15:12.369
they have a dashboard up. Okay. So, I think
this is interesting enough. And how would

00:15:12.369 --> 00:15:17.459
we structure this using MVP? Well, here's
a subset of the view interfaces taken directly

00:15:17.459 --> 00:15:23.259
from the code. The--we have a thread view
and blip view that both extend some blank

00:15:23.259 --> 00:15:29.699
view in an interface. The thread view provides
two code variant creation methods for the

00:15:29.699 --> 00:15:35.319
addition of new blips and threads within the
parent thread. So if you look at them, they're

00:15:35.319 --> 00:15:41.709
quite reminiscent of the DOM-like insert before
method, so you give it the item to insert

00:15:41.709 --> 00:15:46.850
before and, you know, if it's not [INDISTINCT]
you know, that kind of thing. Notice how there

00:15:46.850 --> 00:15:52.769
is no need for getters here. The view contract
here is--in this particular interface, view

00:15:52.769 --> 00:15:56.200
contract is quite straightforward leaving
all the maintenance logic to represent it.

00:15:56.200 --> 00:16:04.459
There's no get the nth view out of the--get
the nth child view or anything like that because,

00:16:04.459 --> 00:16:07.669
you know, you'd have to actually maintain
a collection and, you know, potentially provide

00:16:07.669 --> 00:16:15.709
some kind of non-trivial logic. So the next
one, a blip view contains exactly one indicator

00:16:15.709 --> 00:16:23.209
view, the indicator is that blue thing that
you saw. So using UI binder, it is quite natural

00:16:23.209 --> 00:16:26.989
and efficient to create both in one go because
this is just a one-to-one correspondence with

00:16:26.989 --> 00:16:32.139
them. Just create them all in on go. And so
we have a getter here that's on a state getter.

00:16:32.139 --> 00:16:37.069
It's just a little [INDISTINCT] getter that
returns the indicator view that is the child

00:16:37.069 --> 00:16:41.699
of that blip. And that's just a getter from
a variable that was constructed by a UI binder

00:16:41.699 --> 00:16:50.439
straight out. Or that's more--that's one obvious
implementation of it. And finally, a bunch

00:16:50.439 --> 00:16:55.189
of set and forget methods, so one for showing
or hiding the green, read, unread status bar,

00:16:55.189 --> 00:16:59.369
and another pair for controlling aspects of
the presentation that depend on the state

00:16:59.369 --> 00:17:07.199
and structure of the surrounding thread. So
the show divider and hide divider, those are

00:17:07.199 --> 00:17:13.470
the little, the dashboard of things. And the
logic for that can be quite tricky for when

00:17:13.470 --> 00:17:17.049
we want to show and hide them because it depends
on the positioning of other blips and threads

00:17:17.049 --> 00:17:21.699
nearby. And so this solid interface frees
the view implementation--nothing to worry

00:17:21.699 --> 00:17:26.829
about that logic. We can put it all in the
presenter and the view implementation is follow

00:17:26.829 --> 00:17:32.100
as trivially from this. So--and I'm not going
to show any really complicated presenter logic

00:17:32.100 --> 00:17:36.920
talking to a view because it won't fit on
the slide and the detail such ---really important

00:17:36.920 --> 00:17:41.509
to point. I will show you an example of some
lifecycle code which is the boring code, but

00:17:41.509 --> 00:17:45.809
it will give you some idea of how to create
views that presenters hook them up and--or

00:17:45.809 --> 00:17:50.710
back [INDSTINCT] some abstract although, if
you have one. Okay, so just going through

00:17:50.710 --> 00:17:57.320
it quickly. This method, let's say, in our
[INDISTINCT], because an event came from the

00:17:57.320 --> 00:18:01.779
server to tell us to do so or builds a UI
gesture that told us to do so. Either way,

00:18:01.779 --> 00:18:05.190
our [INDISTINCT] has been updated so that
we now have a new blip. And this is--and we're

00:18:05.190 --> 00:18:18.870
given blip. And blip is the model object.
So--oops, that's better. So we--just from

00:18:18.870 --> 00:18:25.191
our state, get the view for that current model
object and then we ask the view which is--this

00:18:25.191 --> 00:18:30.519
is in a thread. This is in a thread presenter,
so we get our view and we call that createbefore

00:18:30.519 --> 00:18:36.490
method. So if this--so we've got the view
for the--for what its next siblings is going

00:18:36.490 --> 00:18:43.679
to be or now, we create the new view for this
new presenter we're going to make and then

00:18:43.679 --> 00:18:49.029
we created--I mean the tiny top of this should
be blip. So we have some factory which creates

00:18:49.029 --> 00:18:53.291
a blip presenter given a view and its mode.
It's just two things we're passing into here.

00:18:53.291 --> 00:18:58.720
Now, in reality, the--a presenter might have
many other dependencies but using a factory,

00:18:58.720 --> 00:19:04.580
we can carry those a lot and so we don't have
to thread dependencies through seven constructors

00:19:04.580 --> 00:19:10.840
all the way down. This is just noble dependency
injection. So I won't go into that in detail.

00:19:10.840 --> 00:19:13.483
Okay, and then we return to the blip presenter
so then we do all our state stuff and--yeah.

00:19:13.483 --> 00:19:20.860
So that's an--just to give you an idea of
the lifecycle. Okay now, for testing purposes.

00:19:20.860 --> 00:19:24.871
What kind of view implementations? Let's go
into actual implementations now. So a testing

00:19:24.871 --> 00:19:28.750
mostly obviously is the simplest. You know,
if you use something like Eclipse or an IDE,

00:19:28.750 --> 00:19:32.380
you can just say, you know, you can generate
most of the boiler plate implementation for

00:19:32.380 --> 00:19:36.740
you. You just say general methods. And if
you have a good view interface, that blank

00:19:36.740 --> 00:19:42.880
implementation as I mentioned earlier, will
probably suffice. But obviously, if you want

00:19:42.880 --> 00:19:47.009
to record what gets called, you know, you
can use some kind of mocking utility so it

00:19:47.009 --> 00:19:53.220
maybe something like [INDISTINCT] whatever
you prefer. And it makes it--with that style

00:19:53.220 --> 00:19:57.720
of interface, it makes it a lot easier to
mark because usually--since we only have these

00:19:57.720 --> 00:20:03.750
setters, by and large, it's much easier to
mark because we have to say, "When you call

00:20:03.750 --> 00:20:08.429
this getter, I return this thing," which then
gives you this other thing so you can attach

00:20:08.429 --> 00:20:16.110
the listeners to it and so, you know, this
is quite straightforward. Now, a more real

00:20:16.110 --> 00:20:22.179
practical example, obviously, so if we have
a widget that are actually implementing interfaces.

00:20:22.179 --> 00:20:29.460
As far as efficiency thing we might want them
to recyclable. So we've had this init reset

00:20:29.460 --> 00:20:33.630
recycling pattern where you call init when
the widget is first going to be using, call

00:20:33.630 --> 00:20:38.960
reset when you want to stop using it for now,
for many clean-up and then put it back in

00:20:38.960 --> 00:20:43.360
a pool of widgets for re-use so we don't keep
[INDISTINCT], you don't--this is actually

00:20:43.360 --> 00:20:47.980
a good performance boost. Now, in THE past,
we're now--first, what is now present to logic

00:20:47.980 --> 00:20:54.600
and the display logic rules are managed together.
The implementation of init reset required

00:20:54.600 --> 00:21:00.909
tricky and also cause a lot of bugs. However,
by--because presenters are, you know, order

00:21:00.909 --> 00:21:06.110
of magnitude more lightweight than the actual
widgets, we can--now we've got it separated,

00:21:06.110 --> 00:21:10.529
we don't have to reuse our presenters. And,
you know, we can make all the variables final

00:21:10.529 --> 00:21:17.960
and this is just one few dimensions to worry
about the testing. And in practice, it turns

00:21:17.960 --> 00:21:23.380
out for the widget implementations now [INDISTINCT]
reset because it's just a dumb contract, it's

00:21:23.380 --> 00:21:26.870
basically they are the no ups or maybe setting
a couple of things to null and the reset method

00:21:26.870 --> 00:21:41.830
is very, it's very simple. Yeah, so next slide.
Here is a more interesting example. So here's

00:21:41.830 --> 00:21:48.700
an example where the view implementations
are actually quite non-trivial. So for a large

00:21:48.700 --> 00:21:52.090
scrolling UIs such as a wave panel where you
might have hundreds and hundreds of messages,

00:21:52.090 --> 00:21:57.309
you need to scroll up and down. It's much
more efficient to render only the visible

00:21:57.309 --> 00:22:04.240
widgets. We've had enormous speed improvements
by implementing this. Take it from maybe 30

00:22:04.240 --> 00:22:09.350
seconds toward a massive, massive wave to,
you know, virtually instant if we already

00:22:09.350 --> 00:22:14.629
had the data loaded from the cell because
we're only rendering the bits we need to render.

00:22:14.629 --> 00:22:19.250
And it turns out that most of the performance
by Foo, all the performance been released

00:22:19.250 --> 00:22:25.029
all that dumb rendering. So the actual full
tree can be made in terms of the presenters

00:22:25.029 --> 00:22:28.720
quite efficiently. And it's--without much
cost but it's the widgets that we need to

00:22:28.720 --> 00:22:33.279
optimize. So we can treat this kind of thing
as a view concern. And doing it in some way

00:22:33.279 --> 00:22:38.870
has--doing it this way has some advantages.
The presenter code which so far is concerned

00:22:38.870 --> 00:22:43.649
only with user interaction logic can remain
clear and uncomplicated. It can remain agnostic

00:22:43.649 --> 00:22:47.580
as to whether or not we have this pagination
feature. We don't have to complicate it with

00:22:47.580 --> 00:22:54.540
this extra dimension of a, yeah, there's extra
dimension. So, and this is--another advantage

00:22:54.540 --> 00:23:00.090
of having a dumb view contract. So to do this,
what we can do is we're going to have the

00:23:00.090 --> 00:23:06.460
paging implementation of our view. So, let's
say, we have a FooWidget or a blip widget

00:23:06.460 --> 00:23:11.971
or something so if PagingFooView is implementation.
To present a [INDISTINCT], I'm just--put it

00:23:11.971 --> 00:23:18.629
there just so you can see where it all fits
in. And then, this implementation delegates

00:23:18.629 --> 00:23:27.169
to either a Pojo implementation overview which
is Pojo, you know, playing all jobs or object

00:23:27.169 --> 00:23:35.740
just has basically nothing in it. It just
records what methods get called and just sets--sets

00:23:35.740 --> 00:23:40.250
just to--when you call a setter, it just sets
a variable to remember that. And there's a

00:23:40.250 --> 00:23:45.440
copy into the method to copy all that stuff
into a real widget when we actually want to

00:23:45.440 --> 00:23:48.360
page that view in, when it's--when we decided
to come into view and we're going to render

00:23:48.360 --> 00:23:56.419
it for real. And in that case, we will have
this delegating next up. Okay, so, how this

00:23:56.419 --> 00:24:01.100
is actually works? So, I think, this is called
the state pattern or something--it is more

00:24:01.100 --> 00:24:04.910
great complicated obviously, we use--get the
current implementation. So, for example, for

00:24:04.910 --> 00:24:10.019
the markUnread method I showed you earlier
in the blip view, we get out info and called

00:24:10.019 --> 00:24:15.039
markUnread on it, as simple as that. And for
the Pojo implementation, markUnread would

00:24:15.039 --> 00:24:20.080
simply record that in a variable, copy into,
give another view, would call markUnread on

00:24:20.080 --> 00:24:26.779
the other one. And for the widget obviously,
we'd use the, you know, the actual pattern

00:24:26.779 --> 00:24:34.500
set the grain thing to display whatever. So
as you can see here, the paging logic part

00:24:34.500 --> 00:24:40.710
of the view implementation is actually testable.
So, all these blue stuff here is also 100%

00:24:40.710 --> 00:24:46.169
JUnit testable. It's still only this bit here,
that's the heart of testing. But since it's

00:24:46.169 --> 00:24:50.400
a--the logic in here is still trivial were
all good, right? So, this is an advantage

00:24:50.400 --> 00:24:56.429
of having a dumb view contract again. Okay,
so, just little side point, I've mentioned

00:24:56.429 --> 00:25:03.890
the word, covariant a few times and I want
to emphasize it. So when I say covariance,

00:25:03.890 --> 00:25:08.879
I don't necessarily mean it in the strictest
type [INDISTINCT] sense of the word. For example,

00:25:08.879 --> 00:25:13.539
in those create before methods, we accepted
a view, we obviously have to cast it to a

00:25:13.539 --> 00:25:18.270
particular widget, you know, to, you know,
in our panel implementation or whatever you're

00:25:18.270 --> 00:25:24.460
using to be able to insert it before in the
list. But the important thing is what I mean

00:25:24.460 --> 00:25:29.789
is I'm referring to that entire runtime view
structure, like the whole tree with all our

00:25:29.789 --> 00:25:33.711
views together is a close universe. I mean,
there's no presenter code can actually construct

00:25:33.711 --> 00:25:38.600
the implementations directly. We can't decide
what the implementations we're going to use.

00:25:38.600 --> 00:25:44.700
So this allows different groups of collaborating
view implementations to be injected in different

00:25:44.700 --> 00:25:49.020
specific contexts. For example, we put enable
and disable paging by using a different group

00:25:49.020 --> 00:25:59.880
of view implementations, as simple as that.
Yes. Okay, so, in summary, there's quite of

00:25:59.880 --> 00:26:03.389
few things here, but basically, I guess, the
thing I was mentioning most importantly, over

00:26:03.389 --> 00:26:07.620
and over again is to have a dumb view contract.
Everything else pretty much follows from there.

00:26:07.620 --> 00:26:14.120
You should be in a closed universe and presenters
maintain full presentations state. We don't

00:26:14.120 --> 00:26:19.350
want any of our presentation state to be in
the view wherever we can avoid it. Okay, so

00:26:19.350 --> 00:26:24.100
that was MVP about, we took only about, you
know, architecture kind of stuff. Using MVP

00:26:24.100 --> 00:26:27.510
comes a lot of the problems mentioned at the
start but there are few more that it doesn't

00:26:27.510 --> 00:26:35.330
solve for us. So, one of the problems mentioned
at beginning was the need for Web or browser-specific

00:26:35.330 --> 00:26:40.760
optimizations. So, a couple of examples I
gave were, we're using widgets as a sort of--once

00:26:40.760 --> 00:26:45.379
we think, without example MVP, yup, we just
put that in a view and we're fine. But if

00:26:45.379 --> 00:26:49.990
we're doing some kind of JavaScript related
optimization to the actual running of our

00:26:49.990 --> 00:26:54.669
JavaScript, you know, if it's run most of
our JavaScript and all the logic codes, so

00:26:54.669 --> 00:27:00.350
that's a cross-cutting concerned, and we can't
box that away inside some logic view or something

00:27:00.350 --> 00:27:06.590
should be like that. So, one example is GWT's
HashMap and HashSet emulation, it's slow but

00:27:06.590 --> 00:27:10.509
it needs to be, I think Joe was mentioning,
talking about in his talk earlier, but this

00:27:10.509 --> 00:27:19.840
is a result of having to match the JRE interfaces.
So, for example, bucketing is a necessary

00:27:19.840 --> 00:27:23.980
for string or end keys. But just in general,
to implement that interface you need a more

00:27:23.980 --> 00:27:28.500
sort of heavy weight collections. So one thing
we can do is write our own Web-optimized collections

00:27:28.500 --> 00:27:35.320
data structures with our own interfaces. And
so, that's what we've done. We have so to

00:27:35.320 --> 00:27:41.050
compare JSO StringMap, which is a map in string
to something implemented with the JSO, which

00:27:41.050 --> 00:27:45.340
is a JavaScript native object, I'll talk about
that a bit later. This is a HashMap. And in

00:27:45.340 --> 00:27:52.220
this case, we have a, for a Chrome--this is
just for--this is just a micro-benchmark populating

00:27:52.220 --> 00:28:01.369
a map. For a small map, it takes these mini-microseconds,
there are HashMap versus JSO StringMap for

00:28:01.369 --> 00:28:07.340
a large map, and then, Firefox--sorry--Safari
and then Firefox. So you can see it's roughly

00:28:07.340 --> 00:28:12.460
a factor of two difference in all cases. I/O
has similar results but the numbers are in

00:28:12.460 --> 00:28:17.919
order of magnitude larger so the rest of the
graph would look very, you know, part of the

00:28:17.919 --> 00:28:25.259
cycle, but yet [INDISTINCT]. So, we have some
efficient data structures like StringMap,

00:28:25.259 --> 00:28:32.749
StringSet, NumberMap, IntMap, IdentityMap,
IdentitySet, IntQueue. And let's say you wanted

00:28:32.749 --> 00:28:36.879
to write your own data structures such as
these. And then implement interfaces as efficient

00:28:36.879 --> 00:28:42.090
designed for efficient JSO implementations.
And then, for unit tests or for server-side

00:28:42.090 --> 00:28:46.559
code, we actually want to back those implementations
by regular java.util based implementations.

00:28:46.559 --> 00:28:51.530
So we don't actually have to call JSON code
when we're running on the server or when we're

00:28:51.530 --> 00:28:56.220
running in the test case. So how we do this?
Okay, well, we could define that collection's

00:28:56.220 --> 00:29:00.360
factory interface and dependency injected
everywhere, that's obviously a bit cumbersome

00:29:00.360 --> 00:29:04.299
just for collections, right, so, I mean, it's
pretty straightforward. In practice, we don't

00:29:04.299 --> 00:29:09.730
really need to provide fake collections with
different logic or anything. So static constructor

00:29:09.730 --> 00:29:13.740
method delegating to a singleton factory is
fine and we use "GWT.isScript" to switch between

00:29:13.740 --> 00:29:19.110
implementations. "GWT.isScript" tells us if
we're in compiled JavaScript mode versus JVM

00:29:19.110 --> 00:29:27.760
mode. So, if--this will turn false if we're
in hosted mode or not using any GWT environment

00:29:27.760 --> 00:29:36.590
at all. So, pretty straightforward, so "JsoCollectionFactory"
would have methods like, well, a collection

00:29:36.590 --> 00:29:41.259
of [INDISTINCT] StringMap, StringSet and obviously
we just called the JSO version create, et

00:29:41.259 --> 00:29:46.049
cetera. For the "JavaCollectionFactory" we,
you know, we would have adopt the HashMap

00:29:46.049 --> 00:29:50.059
just to implement those specific interface.
I can go into the details but what we have

00:29:50.059 --> 00:29:55.289
specific--why we have different interfaces
and it's mainly to do with iteration. If you

00:29:55.289 --> 00:30:02.440
want to have a very efficient data structure,
we need to change--some iteration has to change,

00:30:02.440 --> 00:30:07.509
how that works, so we need a different interface,
that sort of important point. Yes, the data

00:30:07.509 --> 00:30:12.640
StringSet so on and so forth. So, and then,
we have a factory which is "GWT.isScript"

00:30:12.640 --> 00:30:19.409
is JSO1 otherwise it's JavaOne then create
that, okay, very straightforward. Okay now,

00:30:19.409 --> 00:30:25.490
sometimes we don't actually want to depend
on GWT at all. I mean, not even have GWT in

00:30:25.490 --> 00:30:31.101
any inputs statements. So, for example, in
shared model code that we want to run on the

00:30:31.101 --> 00:30:39.140
server, so the solution for now is to use
supersource. I'm sure the GWT guys will come

00:30:39.140 --> 00:30:45.259
up with something pretty nifty in the near
future but for now this will works fine. Supersourcing

00:30:45.259 --> 00:30:52.590
is basically a--it's like overriding a class
path kind of thing [INDISTINCT]. Instead of

00:30:52.590 --> 00:30:57.169
this implementation of this class, you use
this other completely different one. And it's--but

00:30:57.169 --> 00:31:00.789
it's the same, you know, packaging, the same
class and everything we just say uses other

00:31:00.789 --> 00:31:05.389
one instead. So obviously, that's, you know,
copy paste code sort of duplication. We don't--we

00:31:05.389 --> 00:31:09.779
want to minimize that sort of the--the idiom
we use is to have this--just a "platform.java",

00:31:09.779 --> 00:31:15.710
that sort of stand the [INDISTINCT] where
we put the platform specific differences as

00:31:15.710 --> 00:31:25.580
it where inside here. And so it's--those record
from your--from the collection utils method

00:31:25.580 --> 00:31:30.160
where we set up that factory, we just call
"platform.initcollectionsfactory", which will

00:31:30.160 --> 00:31:34.850
then call back and set the appropriate one.
And then in the default case, it's just uses

00:31:34.850 --> 00:31:40.649
the Java--the regular "java.util" implementation.
But then, in the client, we supersource this,

00:31:40.649 --> 00:31:45.259
so for the code that doesn't do any GWT specific
stuff will get the regular one. And the Cloud

00:31:45.259 --> 00:31:49.860
will supersource it, and we get--then we have
to switch here. We still need to switch because

00:31:49.860 --> 00:31:54.529
the things like hosted mode is still nicer
to use the JavaCollection just because they're

00:31:54.529 --> 00:31:58.410
faster when you're actually running in JVM,
you have to cross--the instruction point doesn't

00:31:58.410 --> 00:32:04.350
have to cross the JavaScript boundary continually
as your accessing your collections. Okay,

00:32:04.350 --> 00:32:09.330
so, another thing I'd like to talk about is
asynchronous logic. This is--some things are

00:32:09.330 --> 00:32:17.620
pretty tricky one. So, for example, how would
test it, so you may not know it but I hope

00:32:17.620 --> 00:32:23.789
you don't know it. But in GWTTestCase, you
can actually defer the failure or pass status

00:32:23.789 --> 00:32:28.779
until a timeout has elapsed. So needless to
say, this is nasty as it makes test flaky

00:32:28.779 --> 00:32:34.950
and take even longer to run. It should only
be used when you really need in some integration

00:32:34.950 --> 00:32:39.030
text, for some integration test context like
you've actually talk into a real backend.

00:32:39.030 --> 00:32:46.419
So, I guess, the obvious solution is to dependency
injects some kind of timer interface, which

00:32:46.419 --> 00:32:52.980
we can then fake out under the tests, we can
manually tick the clock asynchronously enough

00:32:52.980 --> 00:33:01.330
test but the--but then using the time interface
will get call back and forth as it normally

00:33:01.330 --> 00:33:07.169
expected. Okay, so, just an example of it,
this is basically what we use. Now, we have

00:33:07.169 --> 00:33:14.230
a schedule method or overloaded versions of
it which is accept the familiar a command

00:33:14.230 --> 00:33:19.309
and incremental command interfaces. So there
are few flavors about methods just for convenience

00:33:19.309 --> 00:33:24.220
but you can notice that the interface here,
there's no--it's sort of sub-classing type

00:33:24.220 --> 00:33:29.490
of API, like timer. It's more of the service
where you schedule tasks. So the advantage

00:33:29.490 --> 00:33:33.950
of this solid interface is that it allows
the entire application or pattern of to share

00:33:33.950 --> 00:33:39.009
a single time of service, or have a centralized,
different centralized time of services running

00:33:39.009 --> 00:33:43.200
at different priorities. It makes easy to
find tune, the running of background logic,

00:33:43.200 --> 00:33:50.239
animations rendering. It's an invaluable testing
and debugging feature for logging complex

00:33:50.239 --> 00:33:55.820
application. Just a little mention, actually,
I'll mention it later. So, all right, this

00:33:55.820 --> 00:34:02.669
is a pretty nasty one, events. So I mentioned
at that start we have a lot of subtle differences

00:34:02.669 --> 00:34:10.300
between browsers in terms of KeyDown, KeyPress,
so in particular key events are particular

00:34:10.300 --> 00:34:19.510
nasty. So, I'll give you an example of this.
I want to just show you this little testing

00:34:19.510 --> 00:34:26.669
[INDISTINCT] here. So, we know that's in a--in
WebKit if I press and hold, you know, you

00:34:26.669 --> 00:34:34.799
may notice I get a KeyDown and KeyPress over
time, whereas in Firefox when I press and

00:34:34.799 --> 00:34:40.030
hold, I just get a KeyPress for the repeats.
So, you know, if we just listen to all key

00:34:40.030 --> 00:34:44.619
events, we would get duplicates in WebKit--yeah,
you have to--I'm sure you--a lot of you would

00:34:44.619 --> 00:34:48.020
be familiar with this, you know, you need
some special logic but it's not as simple

00:34:48.020 --> 00:34:51.290
as that. I guess quite complicated in terms
of, you know, depending on what key it is

00:34:51.290 --> 00:34:58.170
and so on and so forth. And and an ever annoying
differences that "delete" and "full stop"

00:34:58.170 --> 00:35:03.620
have the same key code. And the way which
you actually detect which one is which also

00:35:03.620 --> 00:35:08.470
differs between browsers, there's lots of
examples such as the delete keys, so just

00:35:08.470 --> 00:35:22.710
a--it's a bit of a nasty one. So,
the solution, oops, the solution that we have

00:35:22.710 --> 00:35:30.000
is we--to find an interface code signal, just
to make it different, it's basically an event,

00:35:30.000 --> 00:35:41.359
same kind of interface. And what you do is
you--we create one from a rawEvent, so from--we

00:35:41.359 --> 00:35:47.460
get a raw browser event, we create this signal
thing. And then, this method will return null

00:35:47.460 --> 00:35:52.760
if we should just ignore, which means if we're,
for example, if one of us is redundant KeyDown

00:35:52.760 --> 00:36:02.260
or KeyPress a base. And then, using that we
can then--it sells, the interface will provide

00:36:02.260 --> 00:36:05.059
the difference between things like, you know,
why don't we just get the key code, you'll

00:36:05.059 --> 00:36:08.930
know the difference between delete and full
stop and so forth. So, for example, let's

00:36:08.930 --> 00:36:13.190
say, this is in one of our dumb widgets. I
know there's a next statement here but it's--I

00:36:13.190 --> 00:36:17.300
wouldn't really call this logic. This is more
a decoration of what the events are, where

00:36:17.300 --> 00:36:21.880
it's propagating. So, if we hit delete, we
call this "onDelete". If it's an input-type

00:36:21.880 --> 00:36:26.700
event, so a full stop would be an input-type
event, we call this ".onUserEditing". Now,

00:36:26.700 --> 00:36:30.840
since the signal thing is a nice little interface,
if you want it to be a more complicated logic,

00:36:30.840 --> 00:36:36.410
you know, if it belongs in the presenter,
you could just make that part of your listener

00:36:36.410 --> 00:36:42.940
interface and call on signal and just pass
that in. So in here, we have all the complicated

00:36:42.940 --> 00:36:49.670
logic but actually does all the cross-browser
event normalization. And so what's our test

00:36:49.670 --> 00:36:58.470
strategy for this? Well, how would you test
this kind of thing and actually--how would

00:36:58.470 --> 00:37:04.440
you test it when you've got--when it's such
a low-level real browser thing? Well, our

00:37:04.440 --> 00:37:19.240
strategy is actually to record, again, using
this tool. We can write a little Web JavaScript

00:37:19.240 --> 00:37:24.010
that press--that goes in--press a bunch of
keys and we can take all this test data and

00:37:24.010 --> 00:37:29.599
actually record it in the big file. And then,
that actually runs in milliseconds, we can

00:37:29.599 --> 00:37:37.880
run regression test or that logic. So we can
call these methods like, you know, check that

00:37:37.880 --> 00:37:41.339
left as the navigation thing, check that delete
if it actually gives us a delete. And we don't

00:37:41.339 --> 00:37:46.720
get redundant events and all that kind of
stuff. And, you know, if a German keyboard

00:37:46.720 --> 00:37:51.109
layout, you know, that kind of thing. So,
it's--we can, you know, this is a bug we had

00:37:51.109 --> 00:37:56.220
once and now we have a test for it and there's
not going to be bug again. So, it's a small

00:37:56.220 --> 00:38:03.460
test, that test always, always cross-browser
event logic. And yeah, I'll just give you

00:38:03.460 --> 00:38:14.450
a little demo of that. So here we have an
example, if I hit all stuff and if I hit delete,

00:38:14.450 --> 00:38:20.730
you see, it says delete for one and input
for the other. And, you know, if I press and

00:38:20.730 --> 00:38:24.030
hold all of it, so it's not giving me a duplicate,
so this is a little test [INDISTINCT]. Now,

00:38:24.030 --> 00:38:27.960
you could also write a web driver test to
test this directly like a--kind of a web driver

00:38:27.960 --> 00:38:33.920
unit test, which we do as well because it's
good to have lots of tests. Okay, before I

00:38:33.920 --> 00:38:39.320
go, I just like to say, well, that stuff I'm
showing like the the signal logic and the

00:38:39.320 --> 00:38:46.369
JSO collections and the time and service thing,
we've actually open source that as part of

00:38:46.369 --> 00:38:52.660
the wave code. And although I think, it really
belongs more in GWT, so we'll probably try

00:38:52.660 --> 00:38:58.400
to move some of that into GWT or as time goes
on. So you can go and get after, write all

00:38:58.400 --> 00:39:04.260
that event normalizing logic, it's done. Okay,
so, that hopefully gives you like some ideas

00:39:04.260 --> 00:39:12.450
of what interesting sort of long-standard
ways of testing things. So, JavaScriptObject,

00:39:12.450 --> 00:39:20.370
I'd just like to talk about--sorry--"SingleJsoImpl".
I don't know who's heard of it, but it's a

00:39:20.370 --> 00:39:24.910
pretty useful facility. So, before I explain
that, just a recap of what a JavaScriptObject

00:39:24.910 --> 00:39:33.230
is. JavaScriptObject is use as an interface
to raw browser, JavaScriptObject. So for example,

00:39:33.230 --> 00:39:40.680
if you have the DOM object or something from
a JavaScript library, the older methods in

00:39:40.680 --> 00:39:50.339
a JSO sub-type must be effectively final.
So that means, I mean you can sub-class JavaScriptObjects

00:39:50.339 --> 00:39:57.780
but you can't overwrite a specific method.
And one point is that given any JSO and I

00:39:57.780 --> 00:40:03.070
call a method on it, I know exactly statically
which method to call. So the syntactic sugar

00:40:03.070 --> 00:40:11.010
for static methods. And they cannot be constructed
by Java code because they're the sort of native

00:40:11.010 --> 00:40:18.099
object things. Okay. So SingleJsoImpl is a--I
think its a little known facility in GWT.

00:40:18.099 --> 00:40:23.160
It's a facility where you can actually have
a JavaScript object being implement--sorry,

00:40:23.160 --> 00:40:32.140
implementing an interface. So an interface
method may have at most one implementation

00:40:32.140 --> 00:40:39.359
to find within a JSO subtype. So that means,
I mean you can think of it as a compile time

00:40:39.359 --> 00:40:43.539
if the compiler sees this interface and a
specific method on it, it knows--still knows

00:40:43.539 --> 00:40:50.320
statically which one to actually turn it into.
Because these JSO things, they don't have

00:40:50.320 --> 00:40:55.023
any of that runtime dynamic dispatch method
information that is associated with these--with

00:40:55.023 --> 00:41:05.200
the Java objects normally. Okay. So I just
like to point out, it has nothing to do with

00:41:05.200 --> 00:41:14.650
whether or not the method itself is native,
and so on. So what we can do then is our--for

00:41:14.650 --> 00:41:20.500
example, our string map implementation can
be a JSO. So we can have this very efficient

00:41:20.500 --> 00:41:26.309
map which is just a pure raw JavaScript object.
There's no wrapper object or anything, and

00:41:26.309 --> 00:41:32.660
I put methods to just updating fields on them.
Like so, for example, this is just a helper

00:41:32.660 --> 00:41:39.039
that basically sets an exact--give us the
exact key value pair on a JavaScript, raw

00:41:39.039 --> 00:41:43.539
JavaScript object escaping it by some optimized
escaping code, obviously. We can do better

00:41:43.539 --> 00:41:51.901
than just prefixing it with a colon or whatever.
And yes, so this implements the interface

00:41:51.901 --> 00:41:58.551
directly. We don't need wrappers. So this
is a way to--if you get your JSOs to implement

00:41:58.551 --> 00:42:02.940
an interface then you can make them, make
your code more testable because you're only

00:42:02.940 --> 00:42:06.700
doing for an interface. But it is just as
efficient as if you're using a raw JSO. So

00:42:06.700 --> 00:42:13.359
that's the important point. Now for example,
that signal thing--the signal that is map

00:42:13.359 --> 00:42:16.890
from--created from an event. It's actually
created. It's still the same event object.

00:42:16.890 --> 00:42:21.160
But we just cross-classed it over to this,
and now it implements a nice interface. So

00:42:21.160 --> 00:42:27.170
I think that's pretty nifty and then, you
know, get keycode would be "event.as(this).getKeyCode()"

00:42:27.170 --> 00:42:35.520
for example and that--it all compiles down
to a property access, right, at runtime. Okay

00:42:35.520 --> 00:42:42.609
so, one last little thing I'd want to--I like
to point out, use of Test Harnesses. It's

00:42:42.609 --> 00:42:48.839
not really a writing testable code thing.
Well, it kind of helps, but I'd like to advocate

00:42:48.839 --> 00:42:54.170
the practice of it. If you're writing some
UI component, it's good to have a little test

00:42:54.170 --> 00:42:57.099
[INDISTINCT] which is just for that. I'm sure
a lot of people already to this. But it's

00:42:57.099 --> 00:43:02.350
good to have a little test [INDISTINCT] just
for that specific component. It is good for

00:43:02.350 --> 00:43:07.250
fast feature development, and all of these
points I've got here. And it does help a little

00:43:07.250 --> 00:43:12.420
bit with writing testable code too because
it makes it clear that if you have too many

00:43:12.420 --> 00:43:19.039
dependencies, it is hard to write this such
an App. So it helps to keep your things isolated

00:43:19.039 --> 00:43:30.289
and clean. I'll try and give a demo of one
of them. So in the, I showed this earlier,

00:43:30.289 --> 00:43:36.890
well, the--oops! So for our Wave Editor, I
mean instead of having to load up the whole

00:43:36.890 --> 00:43:41.470
client and compile the whole Wave client to
test, you know, as collaborative editing or

00:43:41.470 --> 00:43:46.450
something, we can just fire this thing up
and, you know, and notice how it changes,

00:43:46.450 --> 00:43:51.549
propagating across the other side. If this
only shows--and it got lots of debugging information

00:43:51.549 --> 00:43:57.910
and I'll also like to advocate to the use
for integration testing of webdriver. It's

00:43:57.910 --> 00:44:02.380
a very important part about test strategy
for all the stuff I've said about writing,

00:44:02.380 --> 00:44:08.740
you know, JUnit small tests and all that.
It's still important to have integration tests.

00:44:08.740 --> 00:44:13.359
And having something like this with lots of
places for webdriver to hook into and set

00:44:13.359 --> 00:44:18.700
some content or read some information out
which you wouldn't have in your actual applications

00:44:18.700 --> 00:44:29.940
is quite useful. So, anyway, so that's about
it. I guess there's lots of things I went

00:44:29.940 --> 00:44:35.710
through and I could summarize all of them.
But if there's one take-home point, I would

00:44:35.710 --> 00:44:44.069
say its think, "So avoid non-trivial logic
in hard-to-test code." Okay. So, let's start

00:44:44.069 --> 00:44:52.270
with questions I guess.
&gt;&gt; I have one here.

00:44:52.270 --> 00:45:01.160
&gt;&gt; DANILATOS: Yes.
&gt;&gt; Okay. Can you talk a bit more about webdriver?

00:45:01.160 --> 00:45:03.049
&gt;&gt; DANILATOS: About what, sorry?
&gt;&gt; Webdriver.

00:45:03.049 --> 00:45:06.231
&gt;&gt; DANILATOS: Oh, talk a little bit more about
webdriver.

00:45:06.231 --> 00:45:12.140
&gt;&gt; Yeah, especially the Internet Explorer
driver as opposed to Firefox driver. Do you

00:45:12.140 --> 00:45:14.410
use...
&gt;&gt; DANILATOS: As opposed to Firefox driver,

00:45:14.410 --> 00:45:16.559
sorry?
&gt;&gt; Yeah. There is an implementation for Internet

00:45:16.559 --> 00:45:19.720
Explorer and Firefox.
&gt;&gt; DANILATOS: So...

00:45:19.720 --> 00:45:27.690
&gt;&gt; Like in your development for the Wave.
Do you run it in multiple implementations?

00:45:27.690 --> 00:45:34.780
So how do you do it on day-to-day basis?
&gt;&gt; DANILATOS: So with--I'm not sure I particularly--fully

00:45:34.780 --> 00:45:41.190
understand. So the question was with webdriver,
do we use Firefox driver and IE driver, and

00:45:41.190 --> 00:45:48.119
that kind of thing? Yes, we have--I mean webdriver
is an interface. And it is implemented by

00:45:48.119 --> 00:45:54.710
various browser specific implementations and
then you write a code which test or says something

00:45:54.710 --> 00:45:59.780
like, you know, load up a page, click this
button, type this thing, and check the, [INDISTINCT]

00:45:59.780 --> 00:46:03.940
that this element has this content. And you
write it again to that interface and then

00:46:03.940 --> 00:46:12.180
the, you know, you can run the same test against
Firefox, IE, and so forth. So it's a very,

00:46:12.180 --> 00:46:17.820
actually, something I didn't include in my
talk because it's not released. So I don't

00:46:17.820 --> 00:46:22.000
want to make any promises about it. But we've
actually, internally--I might as well mention

00:46:22.000 --> 00:46:27.329
it. We've internally implemented a thing we
like to call GWT driver which actually lets

00:46:27.329 --> 00:46:35.260
us run our webdriver test which is slow and
cumbersome as a JUnit fast test by loading

00:46:35.260 --> 00:46:41.010
up the GWT application, which if you've written
in a testable manner. Well, [INDISTINCT] load

00:46:41.010 --> 00:46:47.980
up the GWT application and the webdriver test
in the same JVM and the implementation of

00:46:47.980 --> 00:46:55.849
the webdriver interface just drives the application
directly inside the same JVM. So it's actually

00:46:55.849 --> 00:46:56.849
pretty nifty but there's a lot more work to
be done on that.

00:46:56.849 --> 00:47:02.480
&gt;&gt; Is it Open Source or is it Internal?
&gt;&gt; DANILATOS: It'll probably be release.

00:47:02.480 --> 00:47:04.609
&gt;&gt; Okay.
&gt;&gt; DANILATOS: But, yeah, I don't want to make

00:47:04.609 --> 00:47:05.609
any promises.
&gt;&gt; Sure. Sure.

00:47:05.609 --> 00:47:08.780
&gt;&gt; DANILATOS: That's why I didn't actually
include it in the talk itself.

00:47:08.780 --> 00:47:13.030
&gt;&gt; Thank you.
&gt;&gt; DANILATOS: Yep?

00:47:13.030 --> 00:47:20.680
&gt;&gt; How does your new architecture--how did
that change your ability to do test driven

00:47:20.680 --> 00:47:24.609
development? And what does test driven development
actually look like? I know it was in the description

00:47:24.609 --> 00:47:30.420
of the talk, do you test--do you write your
behavior like presenter first or how does

00:47:30.420 --> 00:47:34.559
test driven development connect to this sort
of these changes you've made?

00:47:34.559 --> 00:47:38.650
&gt;&gt; DANILATOS: Sure. Yes. Yeah, the talk, I
guess, that I may have been slightly misleading.

00:47:38.650 --> 00:47:43.480
My talk is more about writing testable code.
But yes, with test driven development, I mean

00:47:43.480 --> 00:47:48.300
yep, it's definitely good. I think every developer
might have their own, sort of, style. We don't--at

00:47:48.300 --> 00:47:52.880
our workplace, we don't really particularly
enforce what you to do one thing or another

00:47:52.880 --> 00:47:56.910
but it's very important to have tests. Some
people find it hard to write a test first

00:47:56.910 --> 00:48:00.500
just because they want to try it out, play
around with the code, you know. They haven't

00:48:00.500 --> 00:48:07.490
really come up with exactly what the interface
is before, you know. So, I mean yes. Is there

00:48:07.490 --> 00:48:10.099
anything more like a specific question about
that? But we definitely don't have...

00:48:10.099 --> 00:48:14.410
&gt;&gt; I was just looking for an example of like
what a test driven behavior--test driven development

00:48:14.410 --> 00:48:17.270
process would look like that was enabled by
this.

00:48:17.270 --> 00:48:21.210
&gt;&gt; DANILATOS: A test driven development process.
That would be...

00:48:21.210 --> 00:48:24.020
&gt;&gt; It couldn't otherwise be done. Like what
sort of test? Could you--how could you do

00:48:24.020 --> 00:48:30.430
test first with this in a way you couldn't,
if you hadn't, if you'd done MVC instead of

00:48:30.430 --> 00:48:33.380
MVP?
&gt;&gt; DANILATOS: I think that's--how could you--the

00:48:33.380 --> 00:48:38.450
question was, how could you write test first
in this way that in a way that you couldn't

00:48:38.450 --> 00:48:44.329
with other patterns? I think that's--it's
kind of orthogonal, I mean it's more--this,

00:48:44.329 --> 00:48:50.210
with these patterns and these ideas that helps
you write different kinds of test. I guess,

00:48:50.210 --> 00:48:54.059
so if its not--it doesn't help you write and
test at a different time. It just helps you

00:48:54.059 --> 00:49:02.329
write more tests. When you write them, it's
sort of a separate thing up. In my opinion

00:49:02.329 --> 00:49:05.670
I think I, yeah.
&gt;&gt; Okay.

00:49:05.670 --> 00:49:10.890
&gt;&gt; One of our pinpoints is managing and making
sure that we have a specific tab order of

00:49:10.890 --> 00:49:17.852
things that need to be done. Not yet to figure
out a good way to have tab order of the unit

00:49:17.852 --> 00:49:20.089
testable. As far as I could tell, Selenium
is not able to--like it doesn't actually record

00:49:20.089 --> 00:49:24.819
when you do tabs. It just records the actual
actions. So like if you tabbed through the

00:49:24.819 --> 00:49:30.130
entire Google search page and then you did--you
typed something and then you did tab through

00:49:30.130 --> 00:49:34.020
it, and then you hit enter. It would just
record the enter. It wouldn't actually record

00:49:34.020 --> 00:49:37.739
any of the tabbing. Have you guys come up
with any solutions to that?

00:49:37.739 --> 00:49:42.089
&gt;&gt; DANILATOS: So the question is, have we
come up with any solutions particularly with

00:49:42.089 --> 00:49:47.940
respect to tabbing with Selenium test. So
you're saying when you tab from one input

00:49:47.940 --> 00:49:54.340
field to another it doesn't behave properly
or it doesn't record it?

00:49:54.340 --> 00:49:58.660
&gt;&gt; More, like we need to make--I need to make
sure that when we--as we're making all kinds

00:49:58.660 --> 00:50:02.630
of changes to our code base, we haven't inserted
some things in somewhere...

00:50:02.630 --> 00:50:05.589
&gt;&gt; DANILATOS: Oh, you want to...
&gt;&gt; So that all of a sudden we don't have a

00:50:05.589 --> 00:50:11.590
new control somehow hidden like somebody threw
a focus panel some place that's now grabbing

00:50:11.590 --> 00:50:18.000
focus.
&gt;&gt; DANILATOS: Okay. So you're asking of, how

00:50:18.000 --> 00:50:22.720
do you make sure the tab order didn't get
broken? How do you write a test for maintaining

00:50:22.720 --> 00:50:24.260
tab order?
&gt;&gt; Exactly.

00:50:24.260 --> 00:50:31.549
&gt;&gt; DANILATOS: Okay. That's a good one actually.
And I think we did have a test for that. Or

00:50:31.549 --> 00:50:35.160
maybe we haven't done one yet. But I can't
see why that would actually be a problem because

00:50:35.160 --> 00:50:40.220
you can find out which element has focus on
the page, right. So unless there's an actual

00:50:40.220 --> 00:50:45.550
deficiency in Selenium, maybe try webdriver
because it's actually--webdriver is the next

00:50:45.550 --> 00:50:50.660
Selenium. It's the same interface. It's going
to--it's Selenium 2. It's going to be rechristened

00:50:50.660 --> 00:50:55.911
and everything, so webdriver, because it's
not JavaScript sitting in the page. It's actually

00:50:55.911 --> 00:51:00.210
a plug-in. So it can do more native kind of
driving at the pages. So that should really

00:51:00.210 --> 00:51:06.099
work. And then with webdriver, you can also
call Java--like in your test, you can actually

00:51:06.099 --> 00:51:11.539
call JavaScript on the page directly. So you
can set up a little webdriver hooks in your

00:51:11.539 --> 00:51:19.760
code. So in your GWT code, for example, native
hooks. So you say "window.webdrivertesthook"

00:51:19.760 --> 00:51:23.141
blah, blah, blah, blah, blah, you know, equals
some call out to another method. And then

00:51:23.141 --> 00:51:29.210
you can return for--you have a test hook that,
for example, returns which element is currently

00:51:29.210 --> 00:51:34.160
has focus, or if a certain element--if a specific
element has focus, you know, and then you

00:51:34.160 --> 00:51:38.270
could just make your test go tab. The surface
of the element has focus, tab, the surface

00:51:38.270 --> 00:51:42.080
of the other element has focus or, you know,
whatever exact logic you particularly want

00:51:42.080 --> 00:51:46.330
to test and that should work. I hope that
answers your question.

00:51:46.330 --> 00:51:47.970
&gt;&gt; Yeah, it does. Thank you.
&gt;&gt; DANILATOS: Okay.

00:51:47.970 --> 00:51:52.089
&gt;&gt; I think you may have just answered my question.
I'm not familiar with webdriver. So you're

00:51:52.089 --> 00:52:00.539
saying that's a replacement for Selenium now?
&gt;&gt; DANILATOS: Yes, it is--the path it's headed

00:52:00.539 --> 00:52:08.480
is to be Selenium 2. So its--I'm not sure
kind--it's been actively developed, it's--we

00:52:08.480 --> 00:52:15.890
use it. It's quite feature complete enough
for us to use. But perhaps it's still not

00:52:15.890 --> 00:52:22.770
100% feature parity so that's why it's not
Selenium yet. But it's--the approach is--it

00:52:22.770 --> 00:52:25.650
requires more work, obviously, because you
have to write a specific implementation for

00:52:25.650 --> 00:52:31.349
every browser. But it also means that the
test is more realistic because it's not JavaScript

00:52:31.349 --> 00:52:36.859
simulating, clicking buttons. Its actual buttons
actually being clicked and text actually being

00:52:36.859 --> 00:52:42.770
typed, not calling event handlers and putting
stuff in the DOM explicitly.

00:52:42.770 --> 00:52:45.109
&gt;&gt; Thanks.
&gt;&gt; DANILATOS: No problem.

00:52:45.109 --> 00:52:52.380
&gt;&gt; Yeah. In one of the other presentations,
there were some graphs around. Like continuous

00:52:52.380 --> 00:52:57.900
performance measurement. And I was wondering
how you guys do that or like...

00:52:57.900 --> 00:53:02.130
&gt;&gt; DANILATOS: Is that with...
&gt;&gt; If that is the way to run Speed Tracer?

00:53:02.130 --> 00:53:03.980
&gt;&gt; DANILATOS: Was that [INDISTINCT] Adam Shuck?
&gt;&gt; Yeah.

00:53:03.980 --> 00:53:05.859
&gt;&gt; DANILATOS: Yeah. Yeah. That's also the
same team that's what we do.

00:53:05.859 --> 00:53:09.820
&gt;&gt; Yeah. Can you talk about how you do that
exactly?

00:53:09.820 --> 00:53:12.470
&gt;&gt; DANILATOS: How we actually get those graphs?
&gt;&gt; Yeah.

00:53:12.470 --> 00:53:21.180
&gt;&gt; DANILATOS: We have cheap little Windows
laptops that reboot themselves automatically

00:53:21.180 --> 00:53:25.920
every so often because, you know, we don't
want the test to sort of degrade over time

00:53:25.920 --> 00:53:31.970
because of Windows or whatever. And we just
fires up our--fire up a browser with a webdriver-type

00:53:31.970 --> 00:53:37.309
test. Then we perform actions in time to see
how long they take and, you know, the graph

00:53:37.309 --> 00:53:44.119
is fuzzy. But it's noticeable. You'll see,
you know, it's like this fuzzy and then it

00:53:44.119 --> 00:53:48.849
drops. And then it's fuzzy from there or it
rises up. So, and it's--so that's basically

00:53:48.849 --> 00:53:55.339
what we do. We just have a bunch of those
continually synching to the tip building and

00:53:55.339 --> 00:53:59.450
running--well, we don't obviously build with
the small laptops. The small laptops connect

00:53:59.450 --> 00:54:05.800
to a server. And we see how fast it takes--how
long it takes for things to load or, you know,

00:54:05.800 --> 00:54:07.160
whatever it is that we're testing. Is that
the answer to your question?

00:54:07.160 --> 00:54:12.089
&gt;&gt; Where did you get the timing information
from--is that from Speed Tracer or some--or

00:54:12.089 --> 00:54:15.270
how do you...?
&gt;&gt; DANILATOS: I don't think we use Speed Tracer

00:54:15.270 --> 00:54:20.279
for the automated time. We just actually record
the time it takes in the browser or in the

00:54:20.279 --> 00:54:24.680
test. I'm not sure of the details but I think
it's basically just that. Question was how

00:54:24.680 --> 00:54:32.680
do we actually record the timing? Yes?
&gt;&gt; I'm curious. Is there a way you have to

00:54:32.680 --> 00:54:39.440
test the UI code in a way where the--non-graphically--where
the unit test start up time takes less than

00:54:39.440 --> 00:54:43.000
a couple or a few seconds?
&gt;&gt; DANILATOS: Oh, absolutely. If you--sorry,

00:54:43.000 --> 00:54:48.199
the UI code itself, the heart of the test.
&gt;&gt; The UI code in a non-graphical test.

00:54:48.199 --> 00:54:56.150
&gt;&gt; DANILATOS: So do you mean not the regular
test that we would have, say, for presentors.

00:54:56.150 --> 00:54:59.730
But you want to actually test the widget implementations
of use?

00:54:59.730 --> 00:55:06.130
&gt;&gt; Right.
&gt;&gt; DANILATOS: Okay. So well, the idea is,

00:55:06.130 --> 00:55:10.511
with based in MVP, if you have a DOM view
contract. Then your widget implementation

00:55:10.511 --> 00:55:16.440
is so trivial that literally, you know, if
it's set this, your implementation is set

00:55:16.440 --> 00:55:20.660
this other line of code. I mean, that's something
that's quite unlikely to break. And if it's

00:55:20.660 --> 00:55:24.180
going to break, you're going to notice it
immediately when you just load up your app.

00:55:24.180 --> 00:55:27.680
It's not like a subtle bug that it's going
to regress later and it's going to be hard

00:55:27.680 --> 00:55:31.480
to detect. So the whole point is to actually
obviate the need for even writing that test

00:55:31.480 --> 00:55:35.430
in the first place. Now it's too good to have
integration test that sort of run through

00:55:35.430 --> 00:55:40.170
and, you know, make sure everything hooks
up together. And in terms of actually making

00:55:40.170 --> 00:55:46.200
that run faster, there is a way. And what
you can do is--and this is one of the things

00:55:46.200 --> 00:55:50.779
we're doing for GWT, this GWT writer thing
I talked about, is you can use a custom--it's

00:55:50.779 --> 00:56:01.710
a bit of a hack, but you can use a custom
class loader to replace anything that runs

00:56:01.710 --> 00:56:08.099
JSNI. And for example, you can replace elements
with some other different implementation of

00:56:08.099 --> 00:56:11.839
elements that's in Java. Then it can actually
run pretty fast. However, at the end of the

00:56:11.839 --> 00:56:17.700
day if you want a real true test, you're going
to need a real true browser. So it depends

00:56:17.700 --> 00:56:22.230
on how realistic you want to get. And I would
say if you write your code in a--with MVP

00:56:22.230 --> 00:56:28.310
in that style on the scale of, you know, non-realistic
to fully realistic. It's almost all the way

00:56:28.310 --> 00:56:32.200
at fully realistic. Because the rest of the
bit that you haven't tested is quite minimal,

00:56:32.200 --> 00:56:36.519
and then if you going to do with effort just
to test that one little bit further and you

00:56:36.519 --> 00:56:40.680
want it to be fast. And if you want it to
be fast, you're probably not going to be loading

00:56:40.680 --> 00:56:43.789
up a real browser. You're going to do some--you're
going to cut some kind of corner. So it's

00:56:43.789 --> 00:56:47.519
still not going to be a hundred percent realistic
and I mean do you really care about that last

00:56:47.519 --> 00:56:51.549
little bit this much? You may as well just
have lots of good, you know, tests on your

00:56:51.549 --> 00:56:55.210
presentors. Put all your logic in a testable
manner. And then have some integration test

00:56:55.210 --> 00:56:57.440
to test the whole thing through.
&gt;&gt; Okay.

00:56:57.440 --> 00:57:13.090
&gt;&gt; DANILATOS: Okay. Oh, yes, you have a question?
&gt;&gt; [INDISTINCT]

00:57:13.090 --> 00:57:29.750
&gt;&gt; DANILATOS: So the widgets you mean?
&gt;&gt; Yes.

00:57:29.750 --> 00:57:35.230
&gt;&gt; DANILATOS: So the question was with our
coverage reporting, do we tell the coverage

00:57:35.230 --> 00:57:40.550
reporter to ignore the fact that we're not
covering the widget code? We don't currently.

00:57:40.550 --> 00:57:47.339
But--I mean, you know, does it really matter?
Yeah. So, we do have a lot of GWTTestCases

00:57:47.339 --> 00:57:53.349
don't get me wrong. We have heaps and heaps
of GWTTestCases. And also this code does get

00:57:53.349 --> 00:57:58.760
covered with webdriver as well. It's hard
to get coverage reports for that. We're going

00:57:58.760 --> 00:58:02.200
to work on finding a way to do that. But,
you know, it could--[INDISTINCT] would be

00:58:02.200 --> 00:58:06.670
actually run it against hosted model something
and get coverage that way or maybe find some

00:58:06.670 --> 00:58:10.730
way through the JavaScript to get coverage.
But it's not a super high priority. Yes?

00:58:10.730 --> 00:58:21.810
&gt;&gt; I have a question. So if you get the MVP
test and then a webdriver test, which is what

00:58:21.810 --> 00:58:27.529
I've got now. I don't--actually, I have very
many GWTTestCases. Do you think that that's

00:58:27.529 --> 00:58:34.190
fine that the webdriver can basically replace
those or where do you see who are still using

00:58:34.190 --> 00:58:36.981
GWTTestCases if you've got webdriver in the
picture?

00:58:36.981 --> 00:58:41.440
&gt;&gt; DANILATOS: So the question is, I mean,
if you got all these MVP tests and then--so

00:58:41.440 --> 00:58:43.660
you, in particular, don't have any GWTTestCases?
&gt;&gt; Right.

00:58:43.660 --> 00:58:48.150
&gt;&gt; DANILATOS: Yes. So we have all of these
MVP test cases and then webdriver to do the

00:58:48.150 --> 00:58:52.180
integration testing. And there's no GWTTestCase
at all. I mean if that's working for you then

00:58:52.180 --> 00:58:56.390
great. I mean you don't have to wait for your
GWTTestCases to run. GWTTestCase--I mean I

00:58:56.390 --> 00:59:02.460
would see GWTTestCases are heavy integration
level testing tool similar to webdriver, not

00:59:02.460 --> 00:59:08.000
quite as heavy. A GWTTestCase will probably
be faster than a webdriver test. But I see

00:59:08.000 --> 00:59:13.319
it as somewhere in between the two. But if
you've got, you know--if your app is reliable

00:59:13.319 --> 00:59:18.020
and you've got good coverage and you're happy
with that and then whatever works. I guess.

00:59:18.020 --> 00:59:27.109
I wouldn't say "No, you must have GWTTestCase."
Okay. Time up. Thanks everyone.

