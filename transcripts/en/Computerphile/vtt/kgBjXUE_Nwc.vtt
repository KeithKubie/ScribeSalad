WEBVTT
Kind: captions
Language: en

00:00:00.370 --> 00:00:04.680
Today we are going to be going over some some basic sorting algorithms [simply] case

00:00:04.680 --> 00:00:07.109
So you have a list [of] numbers and you want to sort that into?

00:00:07.630 --> 00:00:09.280
numerical order and

00:00:09.280 --> 00:00:12.900
[there's] all sorts of reasons you want to do that say you've got a spreadsheet open

00:00:12.900 --> 00:00:18.240
And you want to sort one column that [use] [a] sorting algorithm, but also, there's the less obvious

00:00:19.000 --> 00:00:21.420
applications all Sorts of artificial intelligent stuff

00:00:23.619 --> 00:00:24.990
if you're playing a computer game

00:00:24.990 --> 00:00:30.480
And there's some sort of AI somewhere there will be somewhere that they'll definitely using sorting to find the best way to go about doing

00:00:30.480 --> 00:00:31.540
something

00:00:31.540 --> 00:00:37.889
Let me explain. How bubble Sort works. It's got some playing [cards] here, so I'll just tell you I'll deal them out upside down

00:00:37.890 --> 00:00:40.020
So I can't see hopefully won't come out Sorted

00:00:40.239 --> 00:00:45.899
So we've got five three seven eight okay, so this is actually quite a boring bubble

00:00:45.899 --> 00:00:46.420
Sort you

00:00:46.420 --> 00:00:49.739
Go through the list you compare each pair of elements in turn

00:00:49.739 --> 00:00:53.249
And if you need to swap them you swap them so you need to swap three and five

00:00:53.800 --> 00:00:55.829
Yes, because three is lower than five okay

00:00:55.829 --> 00:00:59.639
So we swapped those over then we look at five and seven - we've swapped those there

00:00:59.640 --> 00:01:04.049
We don't seven and eight three sort those no. We don't let me go back to start based and

00:01:04.989 --> 00:01:09.118
[tweenies] Swap three and five no five and seven no seven and eight

00:01:09.299 --> 00:01:14.699
No, that was very simple very [easy] once we've gone through the list one full time, and there's no swaps

00:01:14.700 --> 00:01:19.650
We know the list must be sorted so I'll show you that with a few more cards, okay, so let's deal out

00:01:20.650 --> 00:01:22.650
three four five

00:01:23.259 --> 00:01:26.519
six seven eight cards, okay

00:01:26.520 --> 00:01:29.460
So we start from the left do we need to swap seven and three yes?

00:01:29.790 --> 00:01:36.779
Doing you swap seven and ten no do we need to swap ten six yes, ten four yes, ten and eight. Yes

00:01:37.210 --> 00:01:41.729
Ten and five yes, ten and seven yes, okay. Let me go back to the start

00:01:42.520 --> 00:01:49.829
To need to stop three and seven no seven or six yes seven or four yes, seven and eight no eight and five yes

00:01:49.899 --> 00:01:52.529
eight and seven yes, eight and Ten no

00:01:53.049 --> 00:01:59.459
That's the start three and six no six and four. Yes six and seven no 7:05

00:01:59.460 --> 00:01:59.920
Yes

00:01:59.920 --> 00:02:03.329
[seven] or 7 no 8 and 7 no 8 and 10 no

00:02:03.790 --> 00:02:07.649
practical start [3] and [4] no 4 and 6 no 6 and 5

00:02:07.649 --> 00:02:14.489
Yes 6 and 7 no 6 and 7 no 7 and 8 no 8 and 10 no back to start

00:02:15.370 --> 00:02:21.630
Three and four no four and five no five and six no six and seven no seven seven no

00:02:21.790 --> 00:02:27.030
Seven and eight no eight and ten no, so we've sorted the list I took a lot of effort

00:02:27.820 --> 00:02:29.820
and if you had even more cars it would take

00:02:30.340 --> 00:02:34.770
Even longer you can't actually make bubble sauce slightly simpler, so let me just do a quick

00:02:35.860 --> 00:02:37.780
first pass over this so

00:02:37.780 --> 00:02:42.479
Swap those don't swap those that's all those dents all those don't stop those do swap those do swap those

00:02:42.580 --> 00:02:47.190
What you do now is after every pass the highest card will definitely have been swapped all the way to the end

00:02:47.560 --> 00:02:51.300
So actually you don't need to check that one anymore. You can move that off and just go right

00:02:51.820 --> 00:02:58.259
Don't stop those no those no those no those no those no those yes, okay?

00:02:58.260 --> 00:03:02.670
So now you know eight is actually the next [card] there, but it's still not a very good algorithm. I can demonstrate

00:03:03.280 --> 00:03:06.119
Merge sort to you if you like so for that. I have got another prop

00:03:06.120 --> 00:03:12.239
We bring in this so I'll deal out seven cards the merge, sort we split the [list] into two parts, okay?

00:03:12.239 --> 00:03:14.909
So we've got this left half goes there and the right half goes there

00:03:14.980 --> 00:03:19.619
we've got two lists now this list gets put into to this let's guess listen to two and

00:03:20.140 --> 00:03:26.309
Then each of these four lists gets put into two until you've got either one card or or no cards in [your] list now what?

00:03:26.310 --> 00:03:28.769
we do we look at each of these pairs of

00:03:29.019 --> 00:03:30.070
Sorted lists and

00:03:30.070 --> 00:03:35.249
we merge them back together in the right order by looking at the top card on each list first of all we put four and

00:03:35.250 --> 00:03:39.419
Then we put seven okay, so now we've that's a sorted list there, okay?

00:03:39.420 --> 00:03:42.030
So with ten and eight we look at the lowest card put that in first

00:03:42.030 --> 00:03:47.339
We've got eight then we've got ten and then this one. We've got five and then we've got seven

00:03:48.100 --> 00:03:49.690
But these two we've got

00:03:49.690 --> 00:03:55.229
Three and the Empty list so three just goes there hopefully everyone will agree that a list with [just] one card in it is

00:03:55.360 --> 00:03:58.470
Sorted I've separated them just a clarity so you can see the cards

00:03:58.470 --> 00:04:00.400
You should only bear to look at the top [element] at each

00:04:00.400 --> 00:04:03.900
List so now what we do we merge these two sub lists part together

00:04:03.940 --> 00:04:05.940
Which is the lowest card between [four] and eight?

00:04:06.070 --> 00:04:07.920
Those are the two we can see so we pick four

00:04:07.920 --> 00:04:10.709
I goes in that list and then we say which is lowest between seven and eight

00:04:10.709 --> 00:04:14.369
It's seven which is lowest between eight and nothing it's eight

00:04:14.370 --> 00:04:19.560
And then similarly ten and nothing it's ten and then look at these two lists we take pick the lowest

00:04:19.560 --> 00:04:23.970
so we've got three and then got an empty list so we just put five there and

00:04:24.490 --> 00:04:29.340
Seven there, so we've got two so to [lists] now and all we do is merge them back together

00:04:29.340 --> 00:04:31.919
So we've got four here and three [here] so threes lowest

00:04:31.919 --> 00:04:38.008
[so] that goes first between 4 &amp; 5 5 &amp; 7 &amp; 7 7 &amp; 7 8 7 8 and nothing it's 8 and then

00:04:38.009 --> 00:04:42.329
Between 10 nothing it's 10. I did three tests. We've got bubble Sorts

00:04:42.330 --> 00:04:43.830
We've got the slightly better bubble

00:04:43.830 --> 00:04:48.330
Sort which is the one where you check less elements each time because you know the highest ones are already sorted so we can see

00:04:48.330 --> 00:04:51.960
that actually around the low end Mergesort can be

00:04:53.050 --> 00:04:58.889
significantly slower than either bubble sorts, and that's because most thoughts got slightly more overhead associated with it and

00:04:59.440 --> 00:05:04.499
Also, I guess the lists are more likely to be sorted or nearer Sorted when they're smaller

00:05:04.509 --> 00:05:07.379
So we've got the input size here, so I sorted 10 things in this row

00:05:07.380 --> 00:05:14.669
I run it a thousand times for each, so a thousand different randomly Sorted lists, so it took three hundred ninety one ninety seconds

00:05:14.669 --> 00:05:19.228
Sort 10 things with the first bubble sort 322 with the second bubble, sort and

00:05:20.139 --> 00:05:25.168
770 with Merge Sort even though Merge, Sort should be quicker. There's going to be a little bit of overheads

00:05:25.169 --> 00:05:32.758
It's a slightly more complicated sorting algorithm however as the input size gets bigger if [we're] get to 100 say bubble sort to twenty eight

00:05:33.219 --> 00:05:37.019
thousand nine eight seconds the better Bubble, Sort took nineteen microseconds and

00:05:37.539 --> 00:05:43.619
Know sort took about eight microseconds, [so] [you] can see there that the merge, Sort [Saul] ready starting to

00:05:44.259 --> 00:05:50.999
Take over even by 100, so let's see what it's like at a thousand bubble, sort is taking

00:05:51.789 --> 00:05:56.789
three milliseconds to Sort this of a thousand things the better bubble, sort to take in two milliseconds and

00:05:57.789 --> 00:05:59.789
Merge Sort is taking

00:06:00.340 --> 00:06:03.419
[0.1] of a millisecond to sort the list with a small end

00:06:03.419 --> 00:06:09.089
It doesn't remake with difference, but with a big end makes it makes a world of difference really important, okay?

00:06:09.090 --> 00:06:14.429
So at five thousand it was taking seventy seven milliseconds to Sort with double sort

00:06:15.009 --> 00:06:18.869
51 milliseconds Sort of the Better level, Sort Point Six five [the]

00:06:19.449 --> 00:06:25.799
Millisecond to do those Sort bubble sort as I said earlier scales with the square of the input size

00:06:25.800 --> 00:06:31.079
So they're going to call the emphasize n. So we can say bubble, sort scales with N

00:06:31.300 --> 00:06:32.370
Squared merge

00:06:32.370 --> 00:06:38.310
sort that we've just done that scales with the input size times the log of the input size a

00:06:38.500 --> 00:06:42.000
Log is it's just the inverse of a power if you've got

00:06:42.220 --> 00:06:45.929
10 to the power of [3] say is a thousand log base 10 of thousands 3

00:06:46.180 --> 00:06:50.820
Whatever the base of the log, is it just is [just] a constant factor in front of it, and that doesn't matter motor

00:06:50.820 --> 00:06:52.150
Sort will always take N

00:06:52.150 --> 00:06:58.470
Times log N [runtime] so in the best case and the worst case and the average case you've always got to split the list

00:06:58.720 --> 00:07:02.040
into two and into two again and two again

00:07:02.040 --> 00:07:06.809
And then you still want to compare them all immersion about together so that one that one that one that one

00:07:06.810 --> 00:07:10.710
So you've kind of always got to do the same number of steps the best case of merge, Sort is still n

00:07:10.780 --> 00:07:17.399
Log n. Whereas bubble Sort what actually what you'll find is if you've got a list that's already Sorted it will only take N

00:07:17.400 --> 00:07:21.900
Steps to do it because all it's doing is goes doing sort these no don't need to top these no

00:07:22.060 --> 00:07:27.450
Don't need to sort these no okay, so you've done basically n. Steps, so it's proportional to number of cards

00:07:27.550 --> 00:07:28.620
Don't [is] Duty swap

00:07:28.620 --> 00:07:32.190
So you're done, but if you want to sort [a] list with a million things in Bubble Sorts, not the way to go

00:07:32.920 --> 00:07:36.599
You need to better succinctly convey how when I wear them scales

00:07:37.180 --> 00:07:40.080
There's some mathematical notation used by computer scientists

00:07:40.080 --> 00:07:46.499
This is called Big O notation so actually what you might find is your actual algorithm might run in N squared plus

00:07:47.110 --> 00:07:52.739
[4n] plus tens, but what you don't write you don't write n. Squared plus 4n Plus [ten]

00:07:53.530 --> 00:07:55.619
You can just chuck away the lower order terms

00:07:55.620 --> 00:08:00.780
So you just take the term the scales biggest so you can cross off those and you just say as o of n squared?

00:08:01.660 --> 00:08:07.200
Okay, and the reason is as you increase n. The n squared term will always dominate for N

00:08:07.200 --> 00:08:09.719
so [if] n is 1 we get 1

00:08:09.910 --> 00:08:11.410
Squared which is 1

00:08:11.410 --> 00:08:13.150
Plus 4 times 1 which is 4

00:08:13.150 --> 00:08:18.270
Plus 10 so you can see this term is actually the biggest one and then this term is biggest and then the n squared times

00:08:18.270 --> 00:08:20.489
smallest, but if n is 2

00:08:21.130 --> 00:08:27.059
You get 2 squared which is 4 you get 2 times 4 which is 8 [and] then we still got 10?

00:08:27.060 --> 00:08:29.910
But if we make n, 10 you get 10 squared here

00:08:29.910 --> 00:08:33.809
Which is 100 we get 4 times 10 which is 40, and then we've got 10 here

00:08:34.180 --> 00:08:40.080
But as n gets bigger the n, squared term it dominates the rest of it the n. Squared term really takes

00:08:40.780 --> 00:08:45.269
Takes precedence over the others with big o we only care about the highest order term

00:08:46.000 --> 00:08:47.920
so N squared

00:08:47.920 --> 00:08:52.120
So is it a way of saying there is stuff that goes along there might be other stuff

00:08:52.120 --> 00:08:55.390
but it's a way of simplifying it when we're looking at the figures from my

00:08:55.460 --> 00:09:01.329
Tests or and you know merge sort of it's slower actually at the start than bubble sort that's probably because there's some big

00:09:01.490 --> 00:09:08.500
Constant factors in there or some overhead that is making it take longer there are some algorithms that scale the order of N factorial

00:09:08.630 --> 00:09:10.630
Is N times n minus?

00:09:11.330 --> 00:09:14.559
1 Times N minus 2

00:09:15.290 --> 00:09:22.719
Times all the way down to [one] got n and n factorial n is [one] N. Factorials one N

00:09:22.720 --> 00:09:29.319
Is two it's two [it's] three. [we've] got [three] times two times one. Which is six when it's four

00:09:29.360 --> 00:09:31.689
We've got six six six six

00:09:33.290 --> 00:09:37.480
720 but seven it's whatever seven times by it is quite a big number

00:09:37.700 --> 00:09:42.280
by the time you get to 70 factorial my calculator doesn't like it because you've [gone] over [ten] to the power of

00:09:42.530 --> 00:09:46.780
100 [I] can show you a sorting algorithm that in the average case is n. Factorial if you like?

00:09:48.500 --> 00:09:52.510
So we've got some cards you throw them up into the air and pick them up

00:09:53.270 --> 00:10:00.460
We check if they're sorted so are they sorted no right so so chuck them up in the air again and [once] more

00:10:01.700 --> 00:10:04.119
Pick them up. Are they sorted?

00:10:04.820 --> 00:10:10.090
No, we could be here forever, but in the average case. It's the factorial of the number of cards, so we've got

00:10:10.610 --> 00:10:12.610
Seven cards here, so let's go

00:10:13.400 --> 00:10:15.400
It's going to take me a long time

00:10:21.610 --> 00:10:26.169
Called Bogo [Salt] by the way interesting though Bogo Sort has got a [best-case] complexity of N

00:10:26.570 --> 00:10:31.779
Because if the list is sorted you check if it's sorted and these so you finished you've only done n. Steps

00:10:31.820 --> 00:10:37.089
There's anything that you know I've [used] [bogus] sorting and practical I don't think so

00:10:37.089 --> 00:10:42.549
I think the term was invented just to just as just the sort of instructive purposes so you can kind of

00:10:42.800 --> 00:10:48.130
Have an example of an n. Factorial algorithm. I mean you'll find it in practice quite difficult to write any algorithm

00:10:48.130 --> 00:10:49.970
that runs an n factorial

00:10:49.970 --> 00:10:52.540
It's difficult even if you're a really bad programmer, you'd struggle

00:10:53.240 --> 00:10:58.149
You probably ought to be [quite] good programmer to work out how to do something that runs it runs that badly

