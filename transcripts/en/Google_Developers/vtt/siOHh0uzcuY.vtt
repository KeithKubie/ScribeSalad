WEBVTT
Kind: captions
Language: en

00:00:00.070 --> 00:00:03.499
&gt;&gt; NEUBERG: My name is Brad Neuberg. Today,
I'm going to be talking to you about HTML

00:00:03.499 --> 00:00:08.490
5 and giving you an introduction to the interesting
aspects of the new standard. I'm at Google's

00:00:08.490 --> 00:00:14.249
Developer Programs specifically a group called
Open Web Advocacy. Our group is focused on

00:00:14.249 --> 00:00:20.609
helping through outreach, education, JavaScript
tool kits that help really increase the rate

00:00:20.609 --> 00:00:26.359
at which developers can use interesting new
Web technologies like HTML 5, SVG, CSS3 and

00:00:26.359 --> 00:00:33.460
more. Before jumping into HTML 5, I want to
set the context of where we are on the Web

00:00:33.460 --> 00:00:39.660
today. The last two years, we've really seen
the Web platform accelerate. In this graph,

00:00:39.660 --> 00:00:45.030
you see, at the bottom, sort of the Web capabilities.
And at the top you see the capabilities of

00:00:45.030 --> 00:00:50.020
native applications which have stayed roughly
the same the last few years. What's really

00:00:50.020 --> 00:00:54.680
interesting is the last two years, we've seen
an acceleration of what you can do on the

00:00:54.680 --> 00:00:59.789
Web that's starting to get close to the abilities
of native applications. We see the iPhone

00:00:59.789 --> 00:01:06.470
was a real game changer. Safari 4 really increased
capabilities. Opera has always been a leader.

00:01:06.470 --> 00:01:10.979
The Android device really opened things up
and so on with the introduction of Chrome,

00:01:10.979 --> 00:01:16.759
Firefox 3.5. And we see that over time, the
Web is getting better and better and better

00:01:16.759 --> 00:01:22.670
at having a greater degree of fidelity of
things that you want to do on the Web. And

00:01:22.670 --> 00:01:28.189
what's really unique is that as the Web the
last few years has really accelerated with

00:01:28.189 --> 00:01:32.680
modern browsers, it's solving real developer
challenges. And that, when we get into HTML

00:01:32.680 --> 00:01:37.530
5, we'll see how some of these solutions play
into these challenges. But things like, having

00:01:37.530 --> 00:01:43.950
improved graphic support in the base platform
of the Web. Being able to tie location into

00:01:43.950 --> 00:01:50.090
your Web applications. Storage means actually
being able to use the abilities of a desktop

00:01:50.090 --> 00:01:54.520
machine to do storage, so that we can treat
it as more than like a Commodore 64. We have

00:01:54.520 --> 00:01:59.180
these very powerful machines. Let's start
using them on the Web. And finally, speed,

00:01:59.180 --> 00:02:07.750
that's been a really key change. JavaScript
has gotten much faster and that's a game changer.

00:02:07.750 --> 00:02:12.420
Along with this has been something that's
really surprising. You know, when Firefox

00:02:12.420 --> 00:02:17.970
really helped create the idea of a consumer
driven open-source application, that was a

00:02:17.970 --> 00:02:22.860
new untested idea. People didn't know it could
open-source scale into the consumer market.

00:02:22.860 --> 00:02:27.020
But I think, at this point, that's a done
experiment. We know that it's true, that it

00:02:27.020 --> 00:02:32.050
can happen. If you look at this, you'll see
that it is an increasing accelerating number

00:02:32.050 --> 00:02:37.610
of developers contributing to open-source
projects, to open-source Web browsers including

00:02:37.610 --> 00:02:42.390
Chrome, Firefox, WebKit. So that's really
going to help accelerate even more what we

00:02:42.390 --> 00:02:48.870
have. And at the same time you see a roughly
linear trend in terms of the number of users.

00:02:48.870 --> 00:02:56.980
Here we see millions of open-source browser
users that is increasing overtime. At the

00:02:56.980 --> 00:03:00.960
same time, and sort of setting the context
of where we are today, we see a tremendous

00:03:00.960 --> 00:03:05.320
improvement in JavaScript performance and
we are only at the beginning of that trend.

00:03:05.320 --> 00:03:12.410
The last two years, we've begun to see that.
We've already seen a roughly 100x improvement

00:03:12.410 --> 00:03:17.610
in JavaScript performance, really, pretty
much within about the last sort of year and

00:03:17.610 --> 00:03:22.240
a half. We're only at the beginning of the
optimizations that are possible when you treat

00:03:22.240 --> 00:03:28.370
JavaScript as something that you can really
crank a lot of performance out of. So these

00:03:28.370 --> 00:03:33.660
trends come together, you know, the increasing
fidelity of Web applications, a greater number

00:03:33.660 --> 00:03:39.470
of open source browsers, faster JavaScript.
These come together to really kind of create

00:03:39.470 --> 00:03:45.240
the stage at which HTML 5 can really do much
more than HTML 4 which was the last major

00:03:45.240 --> 00:03:49.620
iteration of HTML, which was really in the
late Ã«90s. So it's really time for a new

00:03:49.620 --> 00:03:56.590
version of HTML because we are in a different
world at this point than we were then. And

00:03:56.590 --> 00:04:02.810
this time around, I just want to sort of make
a point that let's do it differently. One

00:04:02.810 --> 00:04:07.560
of really surprising things is most people
don't realize that AJAX, the idea was invented

00:04:07.560 --> 00:04:14.980
by Microsoft in the late Ã«90s, Outlook
Web Express in 1997 was the first app to use

00:04:14.980 --> 00:04:20.400
AJAX, which at that time was the XML HTTP
request object and it really took until about

00:04:20.400 --> 00:04:27.210
2005 for Firefox to also support that and
the other browsers, and people just sort of

00:04:27.210 --> 00:04:33.520
wake up to the fact that, Ã¬Hey, you can
combine server--background server talking

00:04:33.520 --> 00:04:39.860
to support with things like more advanced
CSS, HTML and that kind of gave us the world

00:04:39.860 --> 00:04:44.570
that we have today. But it took something
like eight years to really gain enough awareness

00:04:44.570 --> 00:04:49.540
and gain enough support for people to really
start paying attention. You know, this time

00:04:49.540 --> 00:04:55.130
around, I think people are going to notice
a lot sooner the capabilities of HTML 5, the

00:04:55.130 --> 00:05:02.080
capabilities of SVG, CSS3, faster JavaScript.
Let's not wait us long as we did then to start

00:05:02.080 --> 00:05:05.190
really doing amazing things. And I think we're
going to--we're actually going to see that

00:05:05.190 --> 00:05:10.780
shift. So people are already jumping on these
things. So let's do things differently this

00:05:10.780 --> 00:05:16.590
time around. So the structure of the talk
I'm going to do today is I want to talk about

00:05:16.590 --> 00:05:22.460
five major sections. I'm going to talk about
vector graphics on the Web including canvass

00:05:22.460 --> 00:05:28.360
and SVG, Scable Vector Graphics. I'm going
to talk about video within the HTML 5 standard.

00:05:28.360 --> 00:05:33.800
I'll talk about geolocation. I'll talk about
the application cache in the database and

00:05:33.800 --> 00:05:38.650
then I'll talk about Web Workers. The HTML
5 spec includes more than this. These are

00:05:38.650 --> 00:05:43.800
five aspects of the spec that are very exciting
and very useful. We could spend the whole

00:05:43.800 --> 00:05:47.560
day talking about these aspects. There are
so many interesting things in there including

00:05:47.560 --> 00:05:54.200
new tags, sort of cleaning up, describing
how you render older content and so on. We're

00:05:54.200 --> 00:05:57.990
going to focus on these aspects today. Each
one of the sections, I'm going to give you

00:05:57.990 --> 00:06:02.639
an introduction. I'm going to give you some
sample code and some demos. And also to talk

00:06:02.639 --> 00:06:07.340
about how this fits in to what you're doing.
So let's get started. Let's jump in to vector

00:06:07.340 --> 00:06:13.139
graphics. So until recently, you really couldn't
draw on the Web. The Web itself didn't really

00:06:13.139 --> 00:06:20.590
provide primitives to help you actually draw
things on the screen. And the graphics--if

00:06:20.590 --> 00:06:23.970
you could, you know, kind of get some graphics
out there, they weren't very interactive.

00:06:23.970 --> 00:06:31.330
They didn't interface very well with JavaScript.
Now, you could sort of rely on other sort

00:06:31.330 --> 00:06:36.620
of aspects of the Web to do this, things like
Flash, Silverlight, VML which was an early

00:06:36.620 --> 00:06:41.150
vector graphics language from Microsoft. So
a lot of people would sort of do clever tricks

00:06:41.150 --> 00:06:47.930
in order to do some drawing on the Web. But
what's really cool is if, if we can get graphics

00:06:47.930 --> 00:06:53.960
to be an intrinsic part of the Web, what you
get is things interact really well with each

00:06:53.960 --> 00:06:57.889
other and that's what so cool about Canvas
and SVG, which I'll talk about both of them,

00:06:57.889 --> 00:07:04.300
is they embed themselves into the Web platform.
They are part of HTML. They're a part of the

00:07:04.300 --> 00:07:10.080
document object model. They can fit into CSS
and HTTP. And that gets really powerful. As

00:07:10.080 --> 00:07:14.830
you'll see that lets them break out of the
box and do really cool stuff using existing

00:07:14.830 --> 00:07:23.520
Web skills. So let's talk about both. Let's
jump into SVG. So SVG is a, is an acronym

00:07:23.520 --> 00:07:28.940
that stands for Scalable Vector Graphics.
Really, they just give you new HTML-like tags

00:07:28.940 --> 00:07:34.860
for drawing. So to do a rectangle, you get
a rectangle tag. You can say where on the

00:07:34.860 --> 00:07:40.660
screen to put it. Here we're putting it at
x=0, y=0. You can set a width and the height.

00:07:40.660 --> 00:07:46.980
You can add a fill and a stroke if you're
changing the width. You know, how many crazy

00:07:46.980 --> 00:07:50.770
hacks people have done to do rounded corners?
Well, it's really easy with SVG. There we

00:07:50.770 --> 00:07:57.060
are making some rounded corners. We say, round
the x side, round the y side by 8. Boom! You

00:07:57.060 --> 00:08:02.000
know, one line for rounded corners. That's
nice. And then finally, you know, we--I talked

00:08:02.000 --> 00:08:07.500
about how this stuff is native to the Web
stack. So we can add an ID that will allow

00:08:07.500 --> 00:08:13.550
JavaScript to grab this. We can add a CSS
class which lets you style this with CSS if

00:08:13.550 --> 00:08:19.620
you want to control in a centralized way how
aspects of your drawing are displayed. And

00:08:19.620 --> 00:08:23.990
there, right there, is what that particular
tag would get rendered as. A blue square with

00:08:23.990 --> 00:08:31.090
some rounded corners and red outline. Now,
what you just saw surround this is at the

00:08:31.090 --> 00:08:35.839
very top, that is the HTML 5 doc type. That's
the thing that you drop at the top of your

00:08:35.839 --> 00:08:43.520
page. And that tells the browser, Ã¬Hey,
this is HTML 5.Ã® Now SVG is a Web standard

00:08:43.520 --> 00:08:50.089
that predates HTML 5. One of the things that's
really unique about HTML 5 is it now says,

00:08:50.089 --> 00:08:57.070
here's how you drop SVG right into a normal
HTML page. So it really makes SVG a core part

00:08:57.070 --> 00:09:04.320
of HTML. So right here, we see, we've got
some normal HTML. You say SVG and then you

00:09:04.320 --> 00:09:08.690
drop your mark up in. So that's one of the
really cool new aspects of HTML 5 that hasn't

00:09:08.690 --> 00:09:12.040
got as much attention as it should, 'cause
it's something that's really unique. We now

00:09:12.040 --> 00:09:20.190
have HTML-like tags that do drawing right
inside of HTML. Now, I mentioned that one

00:09:20.190 --> 00:09:24.770
of the unique things about these things is
they integrate well. So these aren't just

00:09:24.770 --> 00:09:29.970
static graphics. These are graphics that you
can animate, you can interact with. Here we

00:09:29.970 --> 00:09:37.060
are using the normal document object model.
We grab our rectangle. We can use sort of

00:09:37.060 --> 00:09:41.790
the exact same way that we change the style
of HTML. There we are changing the fill to

00:09:41.790 --> 00:09:47.490
"green." We can add interactivity, again,
the same way. There we are doing an onclick.

00:09:47.490 --> 00:09:53.680
So when you click on the rectangle, it says,
"Hello." And that's it, interactivity is really

00:09:53.680 --> 00:09:59.210
straight forward. This shows sort of one of
the nice benefits of what it means to have

00:09:59.210 --> 00:10:07.110
scalable graphics. On the left you see a normal
bitmap. When we change the size, it distorts.

00:10:07.110 --> 00:10:13.930
It pixelates. On the right, whether you're
looking at an SVG image on a 40-inch monitor,

00:10:13.930 --> 00:10:19.330
or a small iphone screen which supports SVG,
it still stays beautiful and legible. That's

00:10:19.330 --> 00:10:27.060
one of the benefits of this technology. So
let's jump into the Canvas API. The Canvas

00:10:27.060 --> 00:10:33.730
API is--I like to think it as a scriptable
image tag. As opposed to SVG which is mark

00:10:33.730 --> 00:10:40.230
up, it's a tree inside of your HTML. The Canvas
API is more like an image tag that you can

00:10:40.230 --> 00:10:47.050
create JavaScript that directly scripts and
draws your own custom image. So, the first

00:10:47.050 --> 00:10:52.690
thing you do to use the Canvas tag is you
drop a simple tag that say's, "canvas" into

00:10:52.690 --> 00:10:59.110
your page, give it a width and height and
you give it an ID. Then, your JavaScript grabs

00:10:59.110 --> 00:11:05.790
that canvas tag, and gets what's known as
the context. So we get a context which is

00:11:05.790 --> 00:11:11.529
a drawing surface area. Right here, we say
a 2D context. This is really interesting.

00:11:11.529 --> 00:11:16.690
It opens up the door to say 3D in the future
so you could possibly do a 3D drawing context.

00:11:16.690 --> 00:11:25.610
We just saw something called WebGL which landed
in Firefox 3.6 recently, which is a 3D Canvas

00:11:25.610 --> 00:11:30.670
API based on OpenGL. And that's really exciting
work. That stuff is not formally a part of

00:11:30.670 --> 00:11:34.660
HTML 5, but it's experimental, interesting
things that's happening out on the edges that

00:11:34.660 --> 00:11:40.820
started to gain interaction. Once you've got
your contexts, you can set the fill style.

00:11:40.820 --> 00:11:48.460
Here we are saying, make anything that we're
going to draw, fill it as red. Here we are

00:11:48.460 --> 00:11:54.110
drawing a rectangle. That's the X, the Y,
the width and the height. Here we are adding

00:11:54.110 --> 00:12:02.500
opacity. So we say RGBA, that's going to make
50% shaded blue rectangle. There we are drawing

00:12:02.500 --> 00:12:06.529
the rectangle. And there you go. There on
the right, you see the two things that we

00:12:06.529 --> 00:12:16.089
just drew. You see a red rectangle with the
partially opaque blue rectangle on top. So,

00:12:16.089 --> 00:12:23.860
I want to show you some demos. A lot of people
ask, how do SVG and Canvas fit together. But

00:12:23.860 --> 00:12:27.160
what's interesting is they both fulfill different
use cases. I will touch on that. But I want

00:12:27.160 --> 00:12:33.980
to show you something really unique, a really
great way that they integrate together. This

00:12:33.980 --> 00:12:40.430
is the Mozilla Firefox download page. What
you see on this page, you see a map of the

00:12:40.430 --> 00:12:47.790
world. That map is drawn using SVG, it's markup.
And then you'll see occasionally a little

00:12:47.790 --> 00:12:54.779
yellow boom, dot show up in a specific location.
Those are drawn with Canvas. This page keeps

00:12:54.779 --> 00:13:00.140
the connection open to the server, so that
it has streaming events, and it records whenever

00:13:00.140 --> 00:13:05.950
anyone downloads Firefox 3.5, where in the
world are they downloading them. The thing

00:13:05.950 --> 00:13:12.310
I love about this page is it really shows
when to use either technology, and when it's

00:13:12.310 --> 00:13:18.310
appropriate. SVG is great when you've got
graphical assets like a map of the world or

00:13:18.310 --> 00:13:23.980
maps in general or a drawing of a tiger for
example. That's a really appropriate thing.

00:13:23.980 --> 00:13:28.220
And you can bring that in. Canvas is really
good when you want to add drawings on top.

00:13:28.220 --> 00:13:33.330
SVG is good for interactivity. So you can
play these things together in order to use

00:13:33.330 --> 00:13:40.540
their strengths where appropriate.

00:13:40.540 --> 00:13:49.519
This is a really cool demo of Canvas. Everyone's
played Doom. This is not a first person player,

00:13:49.519 --> 00:13:57.250
it's a first person gifter, as we walk around.
So this entire thing is drawn with Canvas.

00:13:57.250 --> 00:14:02.760
And you can't see, but I'm using my keyboard
to walk around. Again, this is a really good

00:14:02.760 --> 00:14:08.959
use case that shows Canvas. It doesn't have
mouse interactivity. Canvas is really good

00:14:08.959 --> 00:14:14.290
if you want to create games that are keyboard
driven. SVG is good if you want to create

00:14:14.290 --> 00:14:20.769
interactive mouse driven things. So Canvas
is great for creating a side-scrolling game

00:14:20.769 --> 00:14:27.050
for example.

00:14:27.050 --> 00:14:38.610
This is an interesting population demo. Over
here, we see sort of demographic information

00:14:38.610 --> 00:14:44.779
showing the sort of the number of men and
women in Germany. Now, this right here is

00:14:44.779 --> 00:14:49.970
SVG. This is normal HTML. This shows them
integrated together. The SVG is right in the

00:14:49.970 --> 00:14:55.850
page using HTML 5. What's really cool is what
makes this, and you see as we run over, this

00:14:55.850 --> 00:15:00.040
is just using JavaScript that adds itself,
just like you saw with the samples on mouse

00:15:00.040 --> 00:15:05.490
over, to show further information there going
in. What's interesting that makes this unique

00:15:05.490 --> 00:15:09.899
is in real time we can change the language
of the image. So if you were to push down

00:15:09.899 --> 00:15:16.860
a static image, you couldn't dynamically change
the language of the page and the data. And

00:15:16.860 --> 00:15:21.290
you also couldn't do the interactivity. So
this shows one of the strengths of SVG, you

00:15:21.290 --> 00:15:27.810
can think of them as, as, information-dense
data that you can push down. That, those are

00:15:27.810 --> 00:15:50.120
really a unique way to use SVG. Another great
example of Canvas
is Bespin. This is a graphical developer's

00:15:50.120 --> 00:15:55.100
editor created from Mozilla that allows you
to do all sorts of interesting collaboration,

00:15:55.100 --> 00:16:02.550
social sharing right within. The whole thing
does all of its drawing through Bespin. A

00:16:02.550 --> 00:16:08.800
really, really cool use case. And finally,
I want to show you one last demo of these

00:16:08.800 --> 00:16:18.680
two technologies.

00:16:18.680 --> 00:16:26.350
This is an atlas that shows all of the results
of the German election. It's information dense.

00:16:26.350 --> 00:16:36.760
We can drag it around. We can zoom in. Again,
on the right here is HTML, on the left here

00:16:36.760 --> 00:16:42.079
is SVG, that's natively integrated. Of course,
as we go over it, we can update what's going

00:16:42.079 --> 00:16:51.839
on in the HTML. We can break this down by
different political parties. So here you go.

00:16:51.839 --> 00:16:59.260
You get kind of a sense of both technologies.
So a really natural question is when Canvas

00:16:59.260 --> 00:17:07.389
or SVG? When should you use one or the other?
So SVG is actually what's known as a retained-mode

00:17:07.389 --> 00:17:13.059
API. In graphics, you have retained-mode APIs
and immediate-mode APIs. And you need both

00:17:13.059 --> 00:17:19.139
for different situations. SVG is higher level.
You want to use it when you need import and

00:17:19.139 --> 00:17:24.439
export, like I said, of graphical assets.
You can load in the Illustrator and the Inkscape.

00:17:24.439 --> 00:17:30.340
Whenever you want to create easy user interfaces,
because SVG is a retained-mode API, that means

00:17:30.340 --> 00:17:35.460
there's a tree of everything that you've added
to the screen. So it's really easy to do hit

00:17:35.460 --> 00:17:39.909
detection and adding events to things 'cause
you can just add your listeners somewhere

00:17:39.909 --> 00:17:44.940
in the tree. It's interactive. It's good for
medium animation and it gives you a tree of

00:17:44.940 --> 00:17:49.809
objects. So when should you use Canvas? Well,
Canvas is a lower level and depending on your

00:17:49.809 --> 00:17:53.730
project, that's a strength or a weakness.
It's really good when you don't need that

00:17:53.730 --> 00:17:58.009
tree; when you don't have mouse interaction;
when you have just keyboard interaction like

00:17:58.009 --> 00:18:02.210
with a game. When you have a tremendous amount
of high animation, especially if it's not

00:18:02.210 --> 00:18:06.690
interactive, Canvas is a really good choice
because the tree just gets in your way. You

00:18:06.690 --> 00:18:12.859
don't need collision detection. It's JavaScriptcentric.
It requires some more bookkeeping in order

00:18:12.859 --> 00:18:17.429
to do what you need to do, but that can be
a strength depending on your application,

00:18:17.429 --> 00:18:22.859
and it's really pixel-oriented. So really
depending on your application, you need to

00:18:22.859 --> 00:18:27.769
ask yourself, what am I trying to do, and
you need to use the right one. If you have

00:18:27.769 --> 00:18:32.619
something that's sort of mark-up appointed,
that it needs to be interactive and you end

00:18:32.619 --> 00:18:36.200
up using it on Canvas, you're going to rebuild
the lot of infrastructure that SVG gives you

00:18:36.200 --> 00:18:40.600
and vice versa. If you try to do a thousand
bouncing balls that aren't interactive or

00:18:40.600 --> 00:18:45.289
a side-scrolling game with SVG, you're going
to fail. So choose the right one. We need

00:18:45.289 --> 00:18:52.259
both. So where is this supported? Well, both
Canvas and SVG have excellence support across

00:18:52.259 --> 00:18:57.220
all the modern open-source browsers. And something
that's really cool. I want to briefly touch

00:18:57.220 --> 00:19:01.889
on over at Google, we're working with others
in open-source community to create a drop

00:19:01.889 --> 00:19:08.730
in JavaScript Library called SVG Web that
brings SVG to Internet Explorer so that you

00:19:08.730 --> 00:19:12.609
can now deploy SVG to close to 100 percent
of the installed base. I want to play a very

00:19:12.609 --> 00:20:33.159
short video that sort of shows you SVG Web.
It's one minute. I just want to mention, actually,

00:20:33.159 --> 00:20:40.019
in just about two weeks, the SVG Open Conference
will be talking more about SVG Web. We're

00:20:40.019 --> 00:20:44.049
working with Wikipedia. They're doing some
very cool SVG work. They'll also be using

00:20:44.049 --> 00:20:49.899
SVG Web Toolkit to have these images work
on IE. And so keep this in your radar, some

00:20:49.899 --> 00:20:56.929
interesting things, we're doing some interesting
things there. So let's talk about HTML 5 video.

00:20:56.929 --> 00:21:04.059
So currently video is complicated and it's
outside your control. So at this point, I

00:21:04.059 --> 00:21:10.309
like to say in 2009, video really should be
a part of the browser. You know, multimedia

00:21:10.309 --> 00:21:14.629
is obviously here to stay on the web. It's
an integral part. It needs to be a part of

00:21:14.629 --> 00:21:19.779
the basic web platform at this point. What's
so cool is that HTML 5 now gives you a video

00:21:19.779 --> 00:21:23.919
tag that really works very similar to the
image tag. You don't have to have really complicated

00:21:23.919 --> 00:21:29.580
objects or plug-ins; video just works. So
let's look at some example markup and what

00:21:29.580 --> 00:21:36.970
that looks like. So you have a new video tag
and there you point to your video file and

00:21:36.970 --> 00:21:41.970
you can add attributes. There we've added
the controls attribute, which will cause the

00:21:41.970 --> 00:21:47.639
browser to give a nice little sort of control
bar with play and stop. You can drop fallback

00:21:47.639 --> 00:21:54.269
content on the inside if your, if that browser
doesn't support the video tag. Now, what's

00:21:54.269 --> 00:22:04.119
really interesting is, oh, one second. Technical
difficulty. Lights went out in this room.

00:22:04.119 --> 00:22:09.419
What's really interesting is the different
browsers that support HTML 5 video support

00:22:09.419 --> 00:22:14.769
different codecs. So at this time, you generally
need to provide an Ogg [ph] version and what's

00:22:14.769 --> 00:22:19.259
called an H.264 version and that's straightforward.
You just drop in what are called two different

00:22:19.259 --> 00:22:25.080
source files, and you can give the type. What's
really cool is that again this stuff is a

00:22:25.080 --> 00:22:29.950
native part of the browser. To script it is
really straightforward. There we are grabbing

00:22:29.950 --> 00:22:35.729
the video tag from the page and playing it.
And there's a whole host of APIs around video.

00:22:35.729 --> 00:22:41.119
You can have call backs when different events
happen. You can draw on to the video element

00:22:41.119 --> 00:22:45.729
in order to add your own custom interactivity.
You can do all sorts of cool stuff. And I

00:22:45.729 --> 00:22:56.229
will show you some of that.

00:22:56.229 --> 00:23:05.759
This shows right there, you see there's the
browser control that it added. This is an

00:23:05.759 --> 00:23:16.529
Ogg video showing a FireFox promotional video
that's in Ogg using the video tag. Now what's

00:23:16.529 --> 00:23:24.700
really cool. as I said, this stuff jumps outside
the box. So as it's playing, we can use JavaScript

00:23:24.700 --> 00:23:34.239
to rotate and change what's going on. That's
what's cool when things are a part of the

00:23:34.239 --> 00:23:49.479
browser. This is a mockup of YouTube using
the video tag, the HTML 5 video tag. Now,

00:23:49.479 --> 00:23:58.279
what's cool is right here, this is HTML 5
video. It's not any other plug-ins. And each

00:23:58.279 --> 00:24:03.710
of these little thumbnails is the HTML 5 video
tag as well. And what's cool is they just

00:24:03.710 --> 00:24:08.879
have some little JavaScript on them that says,
"On mouse over, play," like you saw; "On mouse

00:24:08.879 --> 00:24:17.720
out, stop." So we have some small thumbnails.
And if, and I actually like to crack open

00:24:17.720 --> 00:24:25.549
this page because I think it's a great example
of a lot of different HTML 5 things going

00:24:25.549 --> 00:24:32.389
on. So let's look at the source of this page.
At the top, we see the HTML 5 doc type. We

00:24:32.389 --> 00:24:37.919
see the HTML 5 header tag. This actually allows
you to define a header, sort of something

00:24:37.919 --> 00:24:43.669
at the top of your page. Here we are just
sort of saying what the page is. We've got

00:24:43.669 --> 00:24:49.639
the new HTML 5 nav element. This says that
the following things are navigation and so

00:24:49.639 --> 00:24:57.129
we fill that out. And then we've got the HTML
5 article tag. The article tag says that here

00:24:57.129 --> 00:25:01.200
is where the real content of the page starts.
So that helps search engines. That can help

00:25:01.200 --> 00:25:06.529
anyone who wants to script a page and sort
of understand it. So the article tag surrounds

00:25:06.529 --> 00:25:11.460
where the real content is and then the header,
the nav, that allows you to say, "Oh, that's

00:25:11.460 --> 00:25:17.090
the chrome of the page." Within an article
you can have various sections. So here's the

00:25:17.090 --> 00:25:26.149
HTML 5 section tag. So our main video on the
page is one section. Our list of thumbnails

00:25:26.149 --> 00:25:31.999
is another section. Here we are, we see the
HTML 5 progress tag. That allows you to show

00:25:31.999 --> 00:25:41.909
as you're loading something how much is loaded.
Here's the meter tag. So that helps with the

00:25:41.909 --> 00:25:46.149
common use case of having little stars to
rate something, which we you see all over

00:25:46.149 --> 00:25:50.200
the web. So that's a way to actually do that
with less scripting and less custom code.

00:25:50.200 --> 00:26:12.269
And let's find one of these video tags. Here's
one of our thumbnails. So auto buffer says,

00:26:12.269 --> 00:26:16.090
"Hey, start loading this in the background
even if we don't play it, that's going to

00:26:16.090 --> 00:26:20.139
make the performance better when you run the
mouse over." Loop says, "Just keep playing

00:26:20.139 --> 00:26:29.190
this over and over, and over in a loop." There
we are providing the source and so on. So

00:26:29.190 --> 00:26:35.080
this is the, I just like this page, they're
just using a lot of different HTML 5 elements,

00:26:35.080 --> 00:26:43.799
it's a good showcase. And I think they use
the footer tag as well at the bottom. So just

00:26:43.799 --> 00:26:49.629
like the header tag, the footer tag is where
you can put copyright information, other aspects

00:26:49.629 --> 00:27:00.889
of things that aren't part of the article.
So the video tag is well supported, it shows

00:27:00.889 --> 00:27:07.809
up in Firefox 3.5; it's in Chrome; it starts
in Safari 4; it's in Opera. The one thing

00:27:07.809 --> 00:27:13.789
right now is there's essentially two codecs.
Let's put this one known as the Ogg, sort

00:27:13.789 --> 00:27:18.419
of Vorbis codec. And then there is H264. At
this time the safest thing is just produce

00:27:18.419 --> 00:27:22.830
both videos in both formats. There's open
tools that can easily do that, it's a pretty

00:27:22.830 --> 00:27:29.119
straight forward process. So let's look at
the Geolocation. So Geolocation, this is one

00:27:29.119 --> 00:27:34.849
of the things I'm really excited about. On
this page, you see all sorts of things that

00:27:34.849 --> 00:27:40.719
are possible once you have Geolocation. You
can do CRM systems, social applications become

00:27:40.719 --> 00:27:46.099
really, really interesting with the location.
Ads of course, games, people haven't really

00:27:46.099 --> 00:27:49.590
tapped into that one yet. That one is going
to be really amazing especially when you combine

00:27:49.590 --> 00:27:58.299
augmented reality, photos, and so on. Now,
what's interesting is, most of the HTML 5

00:27:58.299 --> 00:28:05.389
Geolocation back ends don't just use GPS and
don't just use IP. They also tend to try to

00:28:05.389 --> 00:28:11.450
grab the Cell ID and the WIFI to bring in
more data. So having all three of these, you

00:28:11.450 --> 00:28:17.330
only need one really to get location. They
help you kind of trade off different design

00:28:17.330 --> 00:28:20.599
constraints to get the location. But that
actually happens in the background, you don't

00:28:20.599 --> 00:28:25.639
have to be as concerned about that. So what's
really cool is we now finally have browsers

00:28:25.639 --> 00:28:32.269
that are location enabled. The latest rev
of the iPhone OS has geolocation, Firefox

00:28:32.269 --> 00:28:38.249
does and so on. It's now in enough places
to do some really cool stuff. So let's look

00:28:38.249 --> 00:28:43.769
at the API. I love this API. It's so straight
forward. You get a new object called geolocation

00:28:43.769 --> 00:28:50.700
that lives in the navigator object. And you
call get current position, and you give it

00:28:50.700 --> 00:28:56.690
a call back that will receive the location
when it's ready and you get a position object,

00:28:56.690 --> 00:28:59.639
and this object is really straightforward.
You can grab the coordinates. There we grab

00:28:59.639 --> 00:29:04.259
the latitude. We grab the longitude. And then
you can pass that to some method that can

00:29:04.259 --> 00:29:08.729
do something with that. Here we have a show
location method that might show it on a map

00:29:08.729 --> 00:29:13.139
for example. Now what's really cool is there's
actually lots of other things on here, you

00:29:13.139 --> 00:29:17.059
can find out, you know, what's the degree
of reliability of that, sort of what's the

00:29:17.059 --> 00:29:22.299
resolution so you could draw a circle, depending
on how well you know the location and so on,

00:29:22.299 --> 00:29:30.759
but the basic use is really straightforward.
I want to show you a prototype of Google Maps

00:29:30.759 --> 00:29:40.999
that uses this API. Here at the top, here's
how we see how it becomes secure. No website

00:29:40.999 --> 00:29:44.989
obviously should be able to reach your location
unless you give permission. So it says, "Hey,

00:29:44.989 --> 00:29:48.759
this website wants to show your location."
You can give permission or not and you can

00:29:48.759 --> 00:29:54.219
remember it. It thinks a little while and
boom, it figures out where I am and that is

00:29:54.219 --> 00:30:03.269
where I am, I'm downtown in San Francisco
right now. So where is this supported? It's

00:30:03.269 --> 00:30:09.429
in all the browsers. For Safari, it's on the
iPhone currently but it's not yet on Safari

00:30:09.429 --> 00:30:16.359
desktop. Now, let's look at the app cache
in the database. So Web apps, if we really

00:30:16.359 --> 00:30:19.669
want to keep them evolving, they really need
to be able to work everywhere. You don't want

00:30:19.669 --> 00:30:25.019
to use your web-based word processor or web-based
address book only when you have a network

00:30:25.019 --> 00:30:29.279
connection. It's important to be able to use
it on airplanes, when you have a spotty internet

00:30:29.279 --> 00:30:35.509
connection, perhaps you're overseas. Maybe
you're in a dead zone where there's no WIFI

00:30:35.509 --> 00:30:41.299
or cellular connection. So when you really
critically need your Web App, it needs to

00:30:41.299 --> 00:30:47.379
be available. The HTML 5 database and app
cache work together to help provide offline

00:30:47.379 --> 00:30:55.099
Web access. So before I show the code, I want
to show you a cool demo of both of these together.

00:30:55.099 --> 00:31:10.289
Here are some old messages, actually, they
were already saved. We can add messages. We

00:31:10.289 --> 00:31:24.259
can make new notes and delete notes. And then,
if we quit the browser and come back, we will

00:31:24.259 --> 00:31:39.009
see our latest data. And that is all being
saved into the local database.
So let's look at this. So the first aspect

00:31:39.009 --> 00:31:42.450
is what's known as the application cache.
This is what I like to call, it's a super

00:31:42.450 --> 00:31:48.219
browser cache. We can't depend on the browser
cache to have everything we need for our web

00:31:48.219 --> 00:31:53.049
application for a number of reasons. One,
things may have timed out and there may not

00:31:53.049 --> 00:31:57.629
be stuff in there that we need. Maybe the
user never went to some aspect of an application,

00:31:57.629 --> 00:32:03.539
but you still want to go to it when you're
offline. So the application cache, think of

00:32:03.539 --> 00:32:08.479
it as a super browser cache that you control
as the application writer, and it's really

00:32:08.479 --> 00:32:13.580
straight forward to use. The first thing is
you create a special file where the first

00:32:13.580 --> 00:32:21.330
line says cache manifest and then you provide
all of the resources, the HTML, the CSS, the

00:32:21.330 --> 00:32:25.759
images that you want to take offline. And
here we have all the things for that sticky

00:32:25.759 --> 00:32:32.919
notes demo you saw. Then, in your HTML on
the body tag, you add a new attribute, you

00:32:32.919 --> 00:32:37.919
say manifest equals and then you point to
your cache manifest. The one other thing that's

00:32:37.919 --> 00:32:43.710
not shown here is on your web server, you
make sure to have the cache manifest have

00:32:43.710 --> 00:32:49.809
a certain mind type that's unique, that just,
that's for this offline app cache manifest.

00:32:49.809 --> 00:32:54.169
And that's it, that's really straight forward.
At that point, when the browser first sees

00:32:54.169 --> 00:32:59.690
this, it will take those resources, bring
them locally, and then automatically in the

00:32:59.690 --> 00:33:03.899
background, periodically see if they've updated
to pull down the fresh version. And now they

00:33:03.899 --> 00:33:08.659
are available for the user to actually see
your user interface because the files are

00:33:08.659 --> 00:33:16.710
available locally. So let's look at the database.
That's the other major aspect of the HTML

00:33:16.710 --> 00:33:22.669
5 offline abilities. What's really cool is,
this is a real relational database so you

00:33:22.669 --> 00:33:26.739
can do some cool stuff with it. To use, the
first thing is you open a database. So here

00:33:26.739 --> 00:33:32.119
we see, you give a database a name, you give
it a version so that you can know what version

00:33:32.119 --> 00:33:36.830
you're working with if you need to migrate
data. You give it a title. Here we say, "Example

00:33:36.830 --> 00:33:42.330
database." This would be shown to a user if,
in Safari 4 for example, a user can go and

00:33:42.330 --> 00:33:46.710
pull up a list of all their databases through
the preferences or through the developer tools.

00:33:46.710 --> 00:33:51.409
And then, you provide an estimated size at
the very beginning of how big your database

00:33:51.409 --> 00:33:56.710
is, and here we say 200K. When that happens
by the way, the first time, a user will be

00:33:56.710 --> 00:34:00.909
prompted, do you want to allow this website
to store up to 200K of data and they'll give

00:34:00.909 --> 00:34:07.700
permission or not. Then, let's look at an
example sort of save-me method. Here we are,

00:34:07.700 --> 00:34:11.649
we're taking, sort of, everything we need
to save in one of these nodes. So we take

00:34:11.649 --> 00:34:16.300
an ID, some texts, a time stamp of when it
was made, where it is on the screen, and the

00:34:16.300 --> 00:34:20.460
z-index of how it's stacked. So the first
thing is, once you've opened your database,

00:34:20.460 --> 00:34:25.340
you get a database object, you need to do
everything as a transaction. And you call

00:34:25.340 --> 00:34:30.149
a db dot transaction, and you give it a call
back function that will be called when the

00:34:30.149 --> 00:34:35.840
transaction is ready to go. The reason you
need to do this is because the web is a very

00:34:35.840 --> 00:34:41.190
unforgiving environment. Users could quit
your application right in the middle. They

00:34:41.190 --> 00:34:45.280
could crash their browser. This isn't--this
is a tougher environment than a traditional

00:34:45.280 --> 00:34:50.409
desktop application. If you put everything
into a transaction, you're already set up

00:34:50.409 --> 00:34:55.750
to make things more reliable. Once you're
inside the transaction, then you can actually

00:34:55.750 --> 00:35:05.900
execute SQL by calling the execute SQL method,
and you provide normal SQL. Here we are, we

00:35:05.900 --> 00:35:11.480
are saying insert into a table called WebKitStickyNotes
we made. There's the columns, and then we

00:35:11.480 --> 00:35:16.870
provide the values. One of the--you provide
all your values where you want them to plug-in,

00:35:16.870 --> 00:35:20.690
you put a question mark, and then you provide
an array that will fill in any of the new

00:35:20.690 --> 00:35:28.450
values, and there we go. One of the other
things I should mention is not only are the

00:35:28.450 --> 00:35:34.620
transactions asynchronous in order to help
in a more unforgiving environment, it also

00:35:34.620 --> 00:35:39.920
helps performance. It means that the browser
can execute the sequel away from the user

00:35:39.920 --> 00:35:45.950
interface thread to keep things from locking
up, and really give a better experience. And

00:35:45.950 --> 00:35:50.750
this one is in all the modern open-source
browsers. It's currently only on Opera mobiles,

00:35:50.750 --> 00:36:00.490
not the desktop edition yet. Now, Web Workers--so,
sort of, using all this JavaScript, it's kind

00:36:00.490 --> 00:36:05.550
of a double-edged sword, right? We can do
more but that also means we can end up not

00:36:05.550 --> 00:36:11.570
writing apps great that end up, sort of, freezing
the browser, causing it to run slowly. If

00:36:11.570 --> 00:36:17.100
you have a lot of JavaScript,JavaScript runs
in the same thread as the user interface of

00:36:17.100 --> 00:36:22.150
the browser. So as it's sitting there running,
the browser won't respond to the user clicking

00:36:22.150 --> 00:36:26.870
around or if they want to go to another tab.
So as things get more powerful, we can end

00:36:26.870 --> 00:36:32.980
up hosing the browser. So what's really cool
is HTML 5 gives you something called Web Workers,

00:36:32.980 --> 00:36:38.320
and this lets you run JavaScript in the background
in such a way that it won't hose or kill the

00:36:38.320 --> 00:36:46.140
browser. I want to show you an example that
really illustrates this. Nothing really shows

00:36:46.140 --> 00:36:50.840
us more than trying to find prime numbers.
The field of cryptography is really based

00:36:50.840 --> 00:36:55.400
on the fact that prime numbers are hard and
computationally intensive. I want to show

00:36:55.400 --> 00:37:05.890
a sample that tries to find prime numbers
using traditional JavaScript without Web Workers.

00:37:05.890 --> 00:37:11.850
We click "Go", and you'll see that the browser
is totally locked up. As a matter of fact,

00:37:11.850 --> 00:37:15.680
it doesn't even report a prime number yet,
it's still working. Things are bad. And I

00:37:15.680 --> 00:37:30.210
literally, have to kill the browser. That's
bad. We don't want to do that. Let's look

00:37:30.210 --> 00:37:40.100
at good primes; this is using the HTML 5 Web
Workers API. We click "Go" and we see primes

00:37:40.100 --> 00:37:50.910
coming in, things are still responsive, we
can still interact with the browser, and it's

00:37:50.910 --> 00:38:02.440
very fast and responsive. Very cool! Now,
all these pieces come together, again, that's

00:38:02.440 --> 00:38:07.660
what's so cool. You're going to see these
things don't just live in a box. You're going

00:38:07.660 --> 00:38:12.370
to--I want to show a really cool sample that
brings together HTML 5 video, and the Canvas

00:38:12.370 --> 00:38:16.640
tag, and Web Workers to do something that
literally, a year ago, if you'd ask me, "Would

00:38:16.640 --> 00:38:19.420
people do this on the web?" I'd say, "You're
crazy." But someone did it on the web and

00:38:19.420 --> 00:38:43.860
it works well. Okay. So what you're looking
at here, is I'm going to play some video in

00:38:43.860 --> 00:38:52.470
JavaScript running on a Web Worker, is going
to get the pixels from the HTML 5 video; process

00:38:52.470 --> 00:38:58.100
where people are moving; and then use the
Canvas tag to draw bounding boxes over them.

00:38:58.100 --> 00:39:08.150
So you're going to see someone walk across.
And you see the green and red, that is doing

00:39:08.150 --> 00:39:16.810
bounding box calculations. It's figuring out
where people are. I just think that's amazing.

00:39:16.810 --> 00:39:25.360
As someone moves, it's been motion-tracking.
And of course, it could stay responsive as

00:39:25.360 --> 00:39:32.520
the video comes through by using Web Workers.
All right, so now that you've seen this being

00:39:32.520 --> 00:39:41.440
used, let's actually look at using Web Workers
in your code. So the first thing is, you have

00:39:41.440 --> 00:39:46.280
to put all of your Workers into a separate
file, and you Ã¬instantiateÃ® a new Worker

00:39:46.280 --> 00:39:52.060
like this. The thing to know about Workers
is they need to be siloed from the rest of

00:39:52.060 --> 00:39:59.730
your JavaScript because they will run in a
different context. They can't access the screen.

00:39:59.730 --> 00:40:05.730
So they can just do work. They can--they actually
can do XML HTTP request calls. They can access

00:40:05.730 --> 00:40:10.810
the database, and you actually pass the data
back and forth for them to work with, and

00:40:10.810 --> 00:40:16.810
they hand you the data back. And the way you
do that is you set on message events. So over

00:40:16.810 --> 00:40:21.910
on the browser side, you see worker.onmessage
and you give a function that will get called

00:40:21.910 --> 00:40:28.880
when the worker talks back to you. And here
we are grabbing the event and I'll put in

00:40:28.880 --> 00:40:34.730
the data. You could imagine taking that data,
such as, from that video tracking, and that

00:40:34.730 --> 00:40:42.970
data may be, here are the coordinates of where
the person is. And you could use--and then

00:40:42.970 --> 00:40:50.080
use the Canvas tag to draw on the video. Over
on the Worker side, you just provide JavaScript.

00:40:50.080 --> 00:40:56.460
Here we are, we have a find primes method.
We would plug a prime number algorithm in

00:40:56.460 --> 00:41:02.270
here. And once we found a prime number, we're
going to send the message over to the JavaScript

00:41:02.270 --> 00:41:11.740
side, and post message is a magic method that
lives, that allows you to send something over

00:41:11.740 --> 00:41:16.100
to the browser. So it's really straightforward.
You just sort of toss these events back and

00:41:16.100 --> 00:41:21.240
forth. And this one is well-supported as well
on Opera, and it's only on the mobile edition,

00:41:21.240 --> 00:41:29.410
but Web Workers are already across Chrome,
Firefox, and Safari. So that brings us to

00:41:29.410 --> 00:41:37.210
the end of our training today. This is really
just--just the start. Like I said, HTML 5

00:41:37.210 --> 00:41:43.460
has all sorts of interesting things. You got
a taste of that with seeing some of the mark-up

00:41:43.460 --> 00:41:49.110
of the YouTube prototype. And so I encourage
you to begin working with these things, create

00:41:49.110 --> 00:41:52.860
really cool demos and sites. And thank you
so much for your time.

