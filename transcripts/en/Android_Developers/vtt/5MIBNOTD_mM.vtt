WEBVTT
Kind: captions
Language: en

00:00:00.499 --> 00:00:05.442
[MUSIC PLAYING]

00:00:05.442 --> 00:00:06.650
MARC STOGAITIS: Hi, everyone.

00:00:06.650 --> 00:00:08.019
Thank you so much for coming.

00:00:08.019 --> 00:00:10.060
My name is Marc Stogaitis
and I lead the Location

00:00:10.060 --> 00:00:11.460
and Contacts Client Team.

00:00:11.460 --> 00:00:15.360
And with me are Wei Wang,
Steve Malkos, and Souvik Sen.

00:00:15.360 --> 00:00:17.740
And we're really excited to
be speaking with you today

00:00:17.740 --> 00:00:21.550
about what's new with
Android Sensors and Location.

00:00:21.550 --> 00:00:23.650
Now we'll start by discussing
some of the upcoming

00:00:23.650 --> 00:00:25.630
changes to background
location, and how

00:00:25.630 --> 00:00:28.690
you can prepare your application
for the Android O release.

00:00:28.690 --> 00:00:31.019
We'll then discuss accuracy
improvements to location,

00:00:31.019 --> 00:00:32.560
improvements to
activity recognition,

00:00:32.560 --> 00:00:33.850
as well as sensors.

00:00:33.850 --> 00:00:35.962
So let's get to it.

00:00:35.962 --> 00:00:37.420
Well, I think we've
all experienced

00:00:37.420 --> 00:00:39.400
that terrible feeling
when your battery is just

00:00:39.400 --> 00:00:41.590
about to run out.

00:00:41.590 --> 00:00:44.560
It's a beautiful day outside,
so you decide to go for a hike.

00:00:44.560 --> 00:00:46.750
And after several
hours, you come up

00:00:46.750 --> 00:00:48.370
to a beautiful baby deer.

00:00:48.370 --> 00:00:49.420
It's super cute.

00:00:49.420 --> 00:00:51.730
And you manage to get
really, really close to it,

00:00:51.730 --> 00:00:53.162
closer than you've ever been.

00:00:53.162 --> 00:00:55.120
And you decide you are
going to take a picture.

00:00:55.120 --> 00:00:57.578
Now this is going to be the
best picture you've ever taken.

00:00:57.578 --> 00:01:00.550
So you slowly carefully take
your phone out of your pocket,

00:01:00.550 --> 00:01:04.840
push the power button, and
your phone is out of batteries.

00:01:04.840 --> 00:01:07.090
So not only do
you miss the shot,

00:01:07.090 --> 00:01:10.140
but then you realize you're
not exactly sure where you are.

00:01:10.140 --> 00:01:11.890
And you were really
counting on your phone

00:01:11.890 --> 00:01:13.630
to help you navigate back.

00:01:13.630 --> 00:01:17.830
And all of a sudden, the woods
look like a much scarier place.

00:01:17.830 --> 00:01:21.400
So I think the point here
is that battery life is

00:01:21.400 --> 00:01:23.810
extremely important to users.

00:01:23.810 --> 00:01:26.920
In fact, one in three users say
the battery life is the number

00:01:26.920 --> 00:01:28.270
one problem on their device.

00:01:28.270 --> 00:01:30.220
It's the number one problem.

00:01:30.220 --> 00:01:32.020
This is also apparent
in statistics

00:01:32.020 --> 00:01:35.000
we track about location.

00:01:35.000 --> 00:01:37.030
So a large percentage
of users have

00:01:37.030 --> 00:01:40.070
decided to completely disable
location on their device.

00:01:40.070 --> 00:01:43.642
And when asked them why, they
said power was the main reason.

00:01:43.642 --> 00:01:45.350
Now this is a problem
for every developer

00:01:45.350 --> 00:01:47.300
in this room who uses location.

00:01:47.300 --> 00:01:51.020
Since when location is disabled,
just a lot of stuff breaks.

00:01:51.020 --> 00:01:53.300
From navigation, to
context aware apps,

00:01:53.300 --> 00:01:55.330
even the weather
just doesn't work

00:01:55.330 --> 00:01:58.301
whenever location is disabled.

00:01:58.301 --> 00:02:00.800
But I think more importantly,
our users turning off location

00:02:00.800 --> 00:02:03.133
means that they're not happy
with the experience they're

00:02:03.133 --> 00:02:03.920
getting.

00:02:03.920 --> 00:02:05.220
And we don't want that.

00:02:05.220 --> 00:02:08.590
We want users to
absolutely love location.

00:02:08.590 --> 00:02:11.390
So we've taken a really close
look at power consumption,

00:02:11.390 --> 00:02:14.040
and here's what we found.

00:02:14.040 --> 00:02:16.170
Well for one thing,
location is used a lot.

00:02:16.170 --> 00:02:19.170
The location APIs currently
allow applications to request

00:02:19.170 --> 00:02:22.140
location at virtually any time.

00:02:22.140 --> 00:02:24.240
So every bar you
see here is a device

00:02:24.240 --> 00:02:27.090
doing some kind of
location related work.

00:02:27.090 --> 00:02:30.180
Now we can analyze the cost of
these using something called

00:02:30.180 --> 00:02:31.514
Android Power Primitives.

00:02:31.514 --> 00:02:33.180
Now that is something
I'm really excited

00:02:33.180 --> 00:02:34.430
speaking with you today about.

00:02:34.430 --> 00:02:36.930
This the first time we've
talked about these externally.

00:02:36.930 --> 00:02:38.805
So you can think of
Power Primitives as a way

00:02:38.805 --> 00:02:42.180
to understand the fundamental
building blocks of power

00:02:42.180 --> 00:02:45.240
on an Android device.

00:02:45.240 --> 00:02:48.330
And we can use these
to really understand

00:02:48.330 --> 00:02:51.120
how location power is computed.

00:02:51.120 --> 00:02:54.390
Here are the four basic
operations that consume power

00:02:54.390 --> 00:02:56.400
when using location.

00:02:56.400 --> 00:02:58.140
When we first have
to wake up the device

00:02:58.140 --> 00:02:59.820
to perform some
work, we then have

00:02:59.820 --> 00:03:03.990
to get some location
signals, like Wi-Fi and GPS.

00:03:03.990 --> 00:03:06.180
Then we have to run some
computation on the CPU.

00:03:06.180 --> 00:03:08.130
And then finally,
maybe go to the network

00:03:08.130 --> 00:03:10.444
to get some more
model information.

00:03:10.444 --> 00:03:12.360
And we can understand
the cost of all of these

00:03:12.360 --> 00:03:14.100
by using the Power Primitives.

00:03:14.100 --> 00:03:17.441
So this is the cost of every
single one of these operations.

00:03:17.441 --> 00:03:19.440
There's a lot going on
here, so let me highlight

00:03:19.440 --> 00:03:22.130
the most important ones.

00:03:22.130 --> 00:03:25.750
Well first, using the cell
network is extremely expensive.

00:03:25.750 --> 00:03:28.450
This is why the locations stack
has been heavily optimized

00:03:28.450 --> 00:03:31.120
to cache data locally
whenever possible

00:03:31.120 --> 00:03:34.911
and try to avoid going to the
network by computing things

00:03:34.911 --> 00:03:35.410
locally.

00:03:37.940 --> 00:03:41.120
Also obtaining location
signals is expensive.

00:03:41.120 --> 00:03:44.889
For example, the first fix
for GPS can cost quite a bit.

00:03:44.889 --> 00:03:46.430
This is why we
usually tend to prefer

00:03:46.430 --> 00:03:48.260
doing Wi-Fi scans instead.

00:03:48.260 --> 00:03:51.950
But unfortunately, Wi-Fi scans
are not really cheap either.

00:03:51.950 --> 00:03:54.110
So what we've been
doing is try to reduce

00:03:54.110 --> 00:03:57.260
the costs of these as much
as possible by limiting which

00:03:57.260 --> 00:03:59.357
channels we look at
when doing a Wi-Fi scan

00:03:59.357 --> 00:04:01.190
as well as spending the
least amount of time

00:04:01.190 --> 00:04:03.210
possible on each channel.

00:04:03.210 --> 00:04:05.870
But we are coming up to some
physical limits to how much

00:04:05.870 --> 00:04:09.010
we can optimize here.

00:04:09.010 --> 00:04:10.560
So in summary, we
see that power is

00:04:10.560 --> 00:04:12.780
extremely important to users.

00:04:12.780 --> 00:04:14.905
Unfortunately,
location is not cheap.

00:04:14.905 --> 00:04:16.529
And we're coming up
to some pretty hard

00:04:16.529 --> 00:04:19.339
physical constraints as
to where we can optimize.

00:04:19.339 --> 00:04:21.180
And as well, there are
some amazing features

00:04:21.180 --> 00:04:23.910
being built using location.

00:04:23.910 --> 00:04:25.556
So with all of
this in mind, we're

00:04:25.556 --> 00:04:27.180
introducing a
significant change to how

00:04:27.180 --> 00:04:29.100
location works in
the Android O release

00:04:29.100 --> 00:04:31.066
called Background
Location Limits.

00:04:31.066 --> 00:04:32.940
This is something we're
really excited about,

00:04:32.940 --> 00:04:35.700
as it drastically improves
battery life for Android users

00:04:35.700 --> 00:04:38.816
while also allowing great
location use cases to be built.

00:04:38.816 --> 00:04:40.190
And now we will
come speak to you

00:04:40.190 --> 00:04:42.562
about some of the details of
background location limits.

00:04:42.562 --> 00:04:44.520
As well as how you can
prepare your application

00:04:44.520 --> 00:04:48.362
for the Android O.

00:04:48.362 --> 00:04:49.570
WEI WANG: Thanks a lot, Marc.

00:04:49.570 --> 00:04:51.350
My name is Wei Wang.

00:04:51.350 --> 00:04:54.860
I'm a Software Engineer in
Location and Contacts Team.

00:04:54.860 --> 00:04:56.750
I'm going to talk about
Background Location

00:04:56.750 --> 00:05:00.410
Limits in Android O release, the
power improvements to location

00:05:00.410 --> 00:05:04.280
APIs, and where and how you
can prepare your application

00:05:04.280 --> 00:05:07.360
for these changes.

00:05:07.360 --> 00:05:09.570
So first, let's take a
look at the difference

00:05:09.570 --> 00:05:11.780
between foreground apps
and background apps.

00:05:11.780 --> 00:05:13.960
For location purpose,
an application

00:05:13.960 --> 00:05:17.130
is considered as foreground
when it is actually

00:05:17.130 --> 00:05:19.170
interacting with
users, which means

00:05:19.170 --> 00:05:21.390
it's either running
a foreground UI

00:05:21.390 --> 00:05:25.080
or running a foreground service
that the user cares about.

00:05:25.080 --> 00:05:28.380
Otherwise, the application
is considered as background

00:05:28.380 --> 00:05:31.900
from location's perspective.

00:05:31.900 --> 00:05:35.800
So our study showed background
apps are the major contributor

00:05:35.800 --> 00:05:37.570
to location power issues.

00:05:37.570 --> 00:05:39.180
Now before the
Android O release,

00:05:39.180 --> 00:05:41.140
there were no limits
to background location

00:05:41.140 --> 00:05:46.160
usage, which means any app can
request location at any time.

00:05:46.160 --> 00:05:49.020
Now this causes several
different problems.

00:05:49.020 --> 00:05:52.830
Of those apps, many applications
request location aggressively

00:05:52.830 --> 00:05:57.490
when they run in background,
or they leak a fast foreground

00:05:57.490 --> 00:06:01.220
location when they switch
from foreground to background.

00:06:01.220 --> 00:06:04.240
So beginning from O, we
are going to impose limits

00:06:04.240 --> 00:06:06.700
to the background apps.

00:06:06.700 --> 00:06:08.710
So I would like to
emphasize, these limits

00:06:08.710 --> 00:06:11.140
apply to background
location only.

00:06:11.140 --> 00:06:16.360
And it would not affect your
foreground location usage.

00:06:16.360 --> 00:06:18.550
So lets start with
location providers.

00:06:18.550 --> 00:06:20.590
Location providers
are the main entry

00:06:20.590 --> 00:06:23.040
for requesting location updates.

00:06:23.040 --> 00:06:25.820
We have too many location
providers, the Fused Location

00:06:25.820 --> 00:06:30.340
Provider in Google Play Services
and the Location Manager

00:06:30.340 --> 00:06:31.480
on the platform.

00:06:31.480 --> 00:06:35.500
So starting from Android O,
for both location providers,

00:06:35.500 --> 00:06:38.120
apps running in background
cannot trigger location

00:06:38.120 --> 00:06:42.190
computation more frequently
than a couple of times per hour.

00:06:42.190 --> 00:06:44.580
For [INAUDIBLE] API in
Fused Location Provider

00:06:44.580 --> 00:06:47.490
a few more location
computations are allowed.

00:06:47.490 --> 00:06:50.060
But the delivery time is going
to be the same as non-based

00:06:50.060 --> 00:06:53.130
in API.

00:06:53.130 --> 00:06:55.100
For Fused Location
Provider, we are also

00:06:55.100 --> 00:06:57.800
going to take advantage
of Wi-Fi connection

00:06:57.800 --> 00:06:59.620
to reduce location computation.

00:06:59.620 --> 00:07:01.940
And no new location
computation would

00:07:01.940 --> 00:07:05.660
be performed when a device is
connected to the same access

00:07:05.660 --> 00:07:09.230
point, which indicates the
user has not moved much

00:07:09.230 --> 00:07:11.420
from the previous location.

00:07:11.420 --> 00:07:13.850
So this provides significant
battery improvements

00:07:13.850 --> 00:07:19.860
when a user is at home or his
work with Wi-Fi connection.

00:07:19.860 --> 00:07:21.900
So with similar
strategy in mind,

00:07:21.900 --> 00:07:25.260
we also applied very similar
changes to Geofencing.

00:07:25.260 --> 00:07:27.120
The responsiveness
of Geofence will

00:07:27.120 --> 00:07:31.480
increase from tens of
seconds to a few minutes.

00:07:31.480 --> 00:07:35.370
But the power is going to be
10 times more power efficient

00:07:35.370 --> 00:07:38.460
than the previous releases.

00:07:38.460 --> 00:07:40.890
So we also used similar
Wi-Fi connection approach

00:07:40.890 --> 00:07:44.340
and can now provide better
transition detection

00:07:44.340 --> 00:07:46.390
when a user leaves
home or leaves work.

00:07:49.060 --> 00:07:53.570
All the changes I mentioned
apply to all background

00:07:53.570 --> 00:07:55.760
apps running on
Android O release

00:07:55.760 --> 00:07:58.530
regardless of the
target SDK version.

00:07:58.530 --> 00:08:00.350
We believe this is
a tested approach

00:08:00.350 --> 00:08:03.560
to provide our users with
immediate battery improvement

00:08:03.560 --> 00:08:07.170
when they upgrade to O.
Now you may be wondering,

00:08:07.170 --> 00:08:11.160
how do these changes look
like on a real device?

00:08:11.160 --> 00:08:14.750
So Marc showed you an example
of location activities before O.

00:08:14.750 --> 00:08:16.480
Now let's take a
look at how things

00:08:16.480 --> 00:08:21.280
change after applying all the
background location limits.

00:08:21.280 --> 00:08:24.890
So you can see, there are
much fewer location activities

00:08:24.890 --> 00:08:27.230
during the same period.

00:08:27.230 --> 00:08:29.640
In fact, after around
6:00 PM, when a device

00:08:29.640 --> 00:08:31.870
connected to a static
Wi-Fi access point,

00:08:31.870 --> 00:08:33.950
there were no
location computation.

00:08:33.950 --> 00:08:36.530
But it was still able to
provide us fresh locations.

00:08:36.530 --> 00:08:40.159
Because we know that the device
is connected to the same Wi-Fi,

00:08:40.159 --> 00:08:42.990
so the user had
not moved far away.

00:08:42.990 --> 00:08:45.490
So the battery consumption
for background location

00:08:45.490 --> 00:08:50.130
is much, much better
now on O. So I've

00:08:50.130 --> 00:08:53.480
talked about a few changes
to background locations.

00:08:53.480 --> 00:08:56.600
And the battery improvements,
especially, looks really good.

00:08:56.600 --> 00:08:58.580
But as a developer you
might be wondering,

00:08:58.580 --> 00:09:00.950
this means fewer locations
coming to my app.

00:09:00.950 --> 00:09:02.230
What should I do?

00:09:02.230 --> 00:09:04.250
So let's talk about
a few approaches

00:09:04.250 --> 00:09:06.500
that you can take to
make your application

00:09:06.500 --> 00:09:09.920
ready for background changes.

00:09:09.920 --> 00:09:14.210
The first, consider only
requesting foreground location.

00:09:14.210 --> 00:09:16.370
So does your app
really need location

00:09:16.370 --> 00:09:19.090
when it is not
interacting with users?

00:09:19.090 --> 00:09:22.550
If it only needs user location
to search restaurant near by,

00:09:22.550 --> 00:09:25.020
then you could always
request a location after user

00:09:25.020 --> 00:09:26.270
opens the app.

00:09:26.270 --> 00:09:30.870
No background location limits
would apply in this case.

00:09:30.870 --> 00:09:33.840
And you can get frequent
location updates as before.

00:09:33.840 --> 00:09:35.510
So we are also
working on reducing

00:09:35.510 --> 00:09:39.200
the kernel caching latency
to ensure a better foreground

00:09:39.200 --> 00:09:41.900
location.

00:09:41.900 --> 00:09:43.800
On the other hand,
if your application

00:09:43.800 --> 00:09:47.530
needs to trigger when
the user enters or exits

00:09:47.530 --> 00:09:50.660
a given area, such as
automatically turning off

00:09:50.660 --> 00:09:53.340
air conditioning when a
user leaves with home,

00:09:53.340 --> 00:09:56.180
you can use Geofence
API to detect

00:09:56.180 --> 00:10:03.830
that user has entered the world
or exited an area of interest.

00:10:03.830 --> 00:10:06.810
As mentioned before, the
Geofencing API in Android O

00:10:06.810 --> 00:10:09.755
is 10 times more power efficient
than the previous releases.

00:10:12.530 --> 00:10:14.840
If your application needs
to collect a user's location

00:10:14.840 --> 00:10:17.570
and display the location
history at a later stage,

00:10:17.570 --> 00:10:20.000
such as Google Maps
Timeline, then you

00:10:20.000 --> 00:10:23.150
can use Batching API and
Field Location Provider.

00:10:23.150 --> 00:10:26.460
Batching allows location system
to collect location signals,

00:10:26.460 --> 00:10:30.980
such as Wi-Fi scans, at low
power with a higher rate,

00:10:30.980 --> 00:10:33.980
then compute and deliver
locations to the client

00:10:33.980 --> 00:10:35.112
only when needed.

00:10:35.112 --> 00:10:37.320
This way we can consolidate
all the network inquiries

00:10:37.320 --> 00:10:41.180
to save battery.

00:10:41.180 --> 00:10:43.440
So let's take a look
at an example of how

00:10:43.440 --> 00:10:45.220
to enable location batching.

00:10:45.220 --> 00:10:48.710
[INAUDIBLE] you will need to
create a location request.

00:10:48.710 --> 00:10:50.770
You'll set the
interval to 10 minutes.

00:10:50.770 --> 00:10:54.460
The key here is to set the
MaxWaitTime time to a few times

00:10:54.460 --> 00:10:57.010
more than the request interval.

00:10:57.010 --> 00:10:58.830
So this allows the
location provider

00:10:58.830 --> 00:11:01.760
to collect location
signals every 10 minutes

00:11:01.760 --> 00:11:05.960
but delivers the locations to
the client every 30 minutes.

00:11:08.580 --> 00:11:12.780
Now finally as a last resort
if you really, really need

00:11:12.780 --> 00:11:15.100
[INAUDIBLE] to
foreground locations

00:11:15.100 --> 00:11:16.850
when you're running
in background,

00:11:16.850 --> 00:11:18.720
you can start a
foreground service

00:11:18.720 --> 00:11:21.260
by showing an
ongoing notification.

00:11:21.260 --> 00:11:24.060
Applications showing
ongoing notifications

00:11:24.060 --> 00:11:26.010
are considered as
foreground apps.

00:11:26.010 --> 00:11:30.660
So background location
limits would not apply.

00:11:30.660 --> 00:11:34.250
To start a foreground
service, create a notification

00:11:34.250 --> 00:11:36.810
and the supply a
PendingIntent to record when

00:11:36.810 --> 00:11:38.970
the notification is clicked.

00:11:38.970 --> 00:11:42.960
By calling the foreground all
of your apps tagged as Android O

00:11:42.960 --> 00:11:44.670
calls that foreground service.

00:11:44.670 --> 00:11:46.520
The service becomes
foreground while you're

00:11:46.520 --> 00:11:48.840
showing ongoing
notifications to the users.

00:11:48.840 --> 00:11:51.540
Now do not forget to
stop foreground service

00:11:51.540 --> 00:11:56.200
if foreground location
is non-needed animal.

00:11:56.200 --> 00:11:57.847
OK

00:11:57.847 --> 00:11:59.680
So far I've talked about
background location

00:11:59.680 --> 00:12:02.660
limits on the Android O device.

00:12:02.660 --> 00:12:04.780
How about Pre O devices?

00:12:04.780 --> 00:12:08.510
The system did not impose
any limits on Pre O devices.

00:12:08.510 --> 00:12:10.900
So we rely on your
best practices

00:12:10.900 --> 00:12:12.460
to make sure the
background location

00:12:12.460 --> 00:12:15.070
power is at a reasonable state.

00:12:15.070 --> 00:12:18.590
The optimization you do, such
as is request only foreground

00:12:18.590 --> 00:12:22.820
locations, use Geofencing
instead of frequent location

00:12:22.820 --> 00:12:26.050
polling, using Batching if
an immediate location is not

00:12:26.050 --> 00:12:26.900
needed.

00:12:26.900 --> 00:12:29.350
However, will be
applied to Pre O devices

00:12:29.350 --> 00:12:32.680
to make the background
location uses battery usage

00:12:32.680 --> 00:12:34.900
at a reasonable state.

00:12:34.900 --> 00:12:38.080
So in summary, I've talked about
background location limits,

00:12:38.080 --> 00:12:40.220
battery improvements
for locations on O,

00:12:40.220 --> 00:12:42.400
and several different
ways to make your apps

00:12:42.400 --> 00:12:44.570
ready for those changes.

00:12:44.570 --> 00:12:47.020
Now let's switch gear to
talk about location accuracy

00:12:47.020 --> 00:12:48.075
improvements.

00:12:48.075 --> 00:12:53.780
[APPLAUSE]

00:12:53.780 --> 00:12:55.815
For the past years,
we have been keeping

00:12:55.815 --> 00:12:57.990
on improving location
accuracy, especially

00:12:57.990 --> 00:12:59.850
for indoor environments.

00:12:59.850 --> 00:13:04.700
Our data showed a 40% and 20%
percent accuracy improvement

00:13:04.700 --> 00:13:06.930
for the past two years.

00:13:06.930 --> 00:13:09.090
This year we are on
good track of achieving

00:13:09.090 --> 00:13:14.670
another 40% accuracy
improvements and another 40%

00:13:14.670 --> 00:13:17.640
accuracy improvements
in a year 2018.

00:13:17.640 --> 00:13:20.070
In fact, our accuracy
would be good enough

00:13:20.070 --> 00:13:23.720
for indoor navigation.

00:13:23.720 --> 00:13:25.990
Now let me show you
a couple of videos

00:13:25.990 --> 00:13:28.970
to demonstrate our indoor
accuracy improvements.

00:13:28.970 --> 00:13:31.971
So the left side radio is
running on the current Fused

00:13:31.971 --> 00:13:32.720
Location Provider.

00:13:32.720 --> 00:13:37.970
The right one is running on a
version that is coming soon.

00:13:37.970 --> 00:13:40.890
The blue dotted line shows the
route that the user is taking.

00:13:40.890 --> 00:13:44.439
The blue dot is unit's
current location.

00:13:44.439 --> 00:13:45.730
Now let's play the first video.

00:13:49.580 --> 00:13:52.130
So you can see the
blue dot aligned

00:13:52.130 --> 00:13:56.020
with the user's real
location really, really well

00:13:56.020 --> 00:13:57.380
at the start.

00:13:57.380 --> 00:14:00.920
But as user went
indoors the location

00:14:00.920 --> 00:14:06.240
jumped and divert a lot
from user's real location.

00:14:06.240 --> 00:14:10.530
Now let's play the second video
to see how things improved.

00:14:10.530 --> 00:14:14.720
So this time the payload
out aligned with the routes

00:14:14.720 --> 00:14:20.030
perfectly, even when the
yielder was deep indoors.

00:14:20.030 --> 00:14:23.830
Now when the user makes the
turn, you can see [INAUDIBLE]

00:14:23.830 --> 00:14:27.890
with them move
really, really well.

00:14:27.890 --> 00:14:31.310
So we are very excited about
the accuracy improvements.

00:14:31.310 --> 00:14:33.800
And we hope that this can
bring better opportunity

00:14:33.800 --> 00:14:35.040
to your application.

00:14:38.470 --> 00:14:41.759
Another area we are
truly excited about

00:14:41.759 --> 00:14:43.425
is this support of
the GNSS measurements

00:14:43.425 --> 00:14:47.390
in this environment
in Android any release

00:14:47.390 --> 00:14:49.000
on location manager.

00:14:49.000 --> 00:14:51.030
Developers can now
get more information

00:14:51.030 --> 00:14:54.510
such as [INAUDIBLE] ranges,
Doppler's, and [INAUDIBLE]

00:14:54.510 --> 00:14:56.310
other than just the position.

00:14:56.310 --> 00:14:59.410
That information can be used
to build value-added apps,

00:14:59.410 --> 00:15:02.740
such as much much more
precise positioning using

00:15:02.740 --> 00:15:05.990
[INAUDIBLE] fast measurements.

00:15:05.990 --> 00:15:10.240
We also provide the tools
to log, analyze, and realize

00:15:10.240 --> 00:15:12.060
all these GNSS measurements.

00:15:12.060 --> 00:15:14.520
You can use these tools
when prototyping your apps

00:15:14.520 --> 00:15:18.450
and answer questions like, which
satellites are you [INAUDIBLE]?

00:15:18.450 --> 00:15:20.610
How strong are the
individual measurements?

00:15:20.610 --> 00:15:23.190
How accurate are the
[INAUDIBLE] measurements?

00:15:23.190 --> 00:15:26.470
We are very eager to see more
user cases of the [INAUDIBLE]

00:15:26.470 --> 00:15:29.640
and measurements
in the ecosystem.

00:15:29.640 --> 00:15:31.590
So far I've talked about
accuracy improvements

00:15:31.590 --> 00:15:35.230
to Fused Location Provider, the
new APIs for GNSS measurements.

00:15:35.230 --> 00:15:38.370
We hope developers can take
good use of these improvements

00:15:38.370 --> 00:15:41.040
to build better location apps.

00:15:41.040 --> 00:15:43.550
With that, I will
hand it over to Marc

00:15:43.550 --> 00:15:45.360
to talk about
activity recognition.

00:15:45.360 --> 00:15:50.830
[APPLAUSE]

00:15:50.830 --> 00:15:52.520
MARC STOGAITIS:
Well, Thanks, Wei.

00:15:52.520 --> 00:15:55.150
So activity recognition
provides your application

00:15:55.150 --> 00:15:57.010
with contextual cues
as to what users

00:15:57.010 --> 00:15:59.050
are doing in the real world.

00:15:59.050 --> 00:16:01.752
Now these are the activities
we currently detect.

00:16:01.752 --> 00:16:03.460
This is something I'm
extremely proud of,

00:16:03.460 --> 00:16:07.000
as just a few years ago
this list was much smaller.

00:16:07.000 --> 00:16:10.340
So you can break it down
into fitness type activities,

00:16:10.340 --> 00:16:13.180
like running or biking,
device contexts,

00:16:13.180 --> 00:16:15.640
like are you in a vehicle,
as well some gestures,

00:16:15.640 --> 00:16:18.970
like the tilt-to-wake
gesture on your watch.

00:16:18.970 --> 00:16:20.470
And today I'd like
to talk to you

00:16:20.470 --> 00:16:23.130
about some upcoming
improvements to our accuracy,

00:16:23.130 --> 00:16:25.750
simplifications we're
making to our APIs

00:16:25.750 --> 00:16:28.900
to make them much easier to
use, as well some new activities

00:16:28.900 --> 00:16:30.640
will be detecting.

00:16:30.640 --> 00:16:33.190
So let's start with
accuracy improvements.

00:16:33.190 --> 00:16:34.810
Well, the world of
machine learning

00:16:34.810 --> 00:16:37.060
has seen some amazing
results from the use

00:16:37.060 --> 00:16:38.380
of deep neural networks.

00:16:38.380 --> 00:16:41.357
And activity recognition
is no exception.

00:16:41.357 --> 00:16:42.940
We've developed a
Deep Activity Neural

00:16:42.940 --> 00:16:45.460
Net, which significantly
improves the accuracy

00:16:45.460 --> 00:16:47.309
of activity recognition.

00:16:47.309 --> 00:16:48.850
Now this makes it
much easier for you

00:16:48.850 --> 00:16:50.630
to build contextual
applications,

00:16:50.630 --> 00:16:51.880
and it also looks really cool.

00:16:54.012 --> 00:16:55.595
We're also doing
some big improvements

00:16:55.595 --> 00:16:58.850
to our APIs to make them
easier for you to use.

00:16:58.850 --> 00:17:01.130
Now the current
Activity Recognition API

00:17:01.130 --> 00:17:04.520
provides you with raw low level
access to activity signals.

00:17:04.520 --> 00:17:06.619
Now this is very
powerful and flexible.

00:17:06.619 --> 00:17:09.980
But it also means that simple
things can be hard to do.

00:17:09.980 --> 00:17:12.035
So let me show you what I mean.

00:17:12.035 --> 00:17:13.910
Now let's say you're
building a car assistant

00:17:13.910 --> 00:17:16.369
app that allows users to
interact with their device

00:17:16.369 --> 00:17:18.416
hands free when in a car.

00:17:18.416 --> 00:17:19.790
Now a simple way
to do this would

00:17:19.790 --> 00:17:21.829
be to write an if
statement that says,

00:17:21.829 --> 00:17:24.530
if the activity is
in-vehicle, start my app.

00:17:24.530 --> 00:17:27.214
And if it's not
in-vehicle, close my app.

00:17:27.214 --> 00:17:28.880
So let's talk about
some of the pitfalls

00:17:28.880 --> 00:17:32.180
that you'll encounter
if you do this.

00:17:32.180 --> 00:17:35.420
So the user starts in a vehicle
with a confidence of 80%.

00:17:35.420 --> 00:17:36.740
Great, so far so good.

00:17:36.740 --> 00:17:38.075
You launch your application.

00:17:38.075 --> 00:17:40.640
And it keeps driving
with a confidence of 100.

00:17:40.640 --> 00:17:42.470
Everything's
working well so far.

00:17:42.470 --> 00:17:46.290
And then they stop at a light,
and you get a still activity.

00:17:46.290 --> 00:17:48.207
Now that simple if
statement from earlier

00:17:48.207 --> 00:17:49.790
wouldn't have taken
this into account,

00:17:49.790 --> 00:17:51.540
and the app would have closed.

00:17:51.540 --> 00:17:54.020
So you say, OK, let
me update my filter

00:17:54.020 --> 00:17:57.440
to deal with the still
while in-vehicle use case.

00:17:57.440 --> 00:18:01.400
So the user continues to drive
and then hits a speed bump.

00:18:01.400 --> 00:18:03.950
And we misdetect it as biking.

00:18:03.950 --> 00:18:06.614
Now we worked really hard
to avoid misclassifications.

00:18:06.614 --> 00:18:08.030
But sometimes they
are unavoidable

00:18:08.030 --> 00:18:10.370
in this raw low level API
we're providing that has

00:18:10.370 --> 00:18:13.370
very little filtering in it.

00:18:13.370 --> 00:18:14.780
Now you can write
a filter to try

00:18:14.780 --> 00:18:15.860
to deal with things like this.

00:18:15.860 --> 00:18:17.318
Because if you look
at the history,

00:18:17.318 --> 00:18:20.540
well, there's a lot of
driving in the past.

00:18:20.540 --> 00:18:22.020
The biking confidence
is very low.

00:18:22.020 --> 00:18:23.384
So 55 is pretty low.

00:18:23.384 --> 00:18:24.800
And there was no
activity that you

00:18:24.800 --> 00:18:26.540
would expect between
driving and biking,

00:18:26.540 --> 00:18:28.120
like something like walking.

00:18:28.120 --> 00:18:29.630
But writing this
is getting pretty

00:18:29.630 --> 00:18:32.450
cumbersome and complicated.

00:18:32.450 --> 00:18:34.950
OK so the user
continues to drive,

00:18:34.950 --> 00:18:36.670
and now you get a tilt event.

00:18:36.670 --> 00:18:38.630
Now a tilt event is
a strong indication

00:18:38.630 --> 00:18:41.120
that the user's activity
is about to change.

00:18:41.120 --> 00:18:45.110
It tends to happen when a user
goes from sitting to standing.

00:18:45.110 --> 00:18:47.831
So you can take that into
account into a filter.

00:18:47.831 --> 00:18:49.580
And then finally, the
user starts walking.

00:18:49.580 --> 00:18:51.725
And you can finally
close your application.

00:18:51.725 --> 00:18:53.600
Now writing a filter to
deal with all of this

00:18:53.600 --> 00:18:54.380
is pretty tricky.

00:18:54.380 --> 00:18:57.075
It requires a lot of
training data to get right.

00:18:57.075 --> 00:18:59.540
Well we're making this much
easier with the Activity

00:18:59.540 --> 00:19:01.670
Transition API.

00:19:01.670 --> 00:19:05.240
Now it takes a messy raw
activity signal, like this,

00:19:05.240 --> 00:19:08.030
and turns it into
simple transitions.

00:19:08.030 --> 00:19:09.470
You get a vehicle
start event when

00:19:09.470 --> 00:19:11.640
the user starts driving
and a vehicle end

00:19:11.640 --> 00:19:13.100
event when they stop.

00:19:13.100 --> 00:19:14.390
That's it.

00:19:14.390 --> 00:19:17.540
We take care of all the
filtering behind the scenes.

00:19:17.540 --> 00:19:20.600
This means by using this
Activity Requisition Transition

00:19:20.600 --> 00:19:24.340
API, you can write that simple
if in-vehicle statement.

00:19:24.340 --> 00:19:25.590
And your app should just work.

00:19:33.406 --> 00:19:35.030
Now I'd like to
quickly talk about some

00:19:35.030 --> 00:19:38.432
of the new activities that
we're working on detecting.

00:19:38.432 --> 00:19:39.890
So we're really
excited to announce

00:19:39.890 --> 00:19:42.230
that we've developed a road
versus rail vehicle detection

00:19:42.230 --> 00:19:44.420
algorithm that can tell the
difference between a car

00:19:44.420 --> 00:19:47.360
and a train for example.

00:19:47.360 --> 00:19:49.970
So we think this will lead to
some very powerful applications

00:19:49.970 --> 00:19:51.770
that help users
during public transit

00:19:51.770 --> 00:19:53.840
as well as improve
in-car experiences.

00:19:53.840 --> 00:19:57.200
We can't wait for
you to try it out.

00:19:57.200 --> 00:19:58.829
And I'm also really
proud to announce

00:19:58.829 --> 00:20:00.620
that we're now able to
automatically detect

00:20:00.620 --> 00:20:02.870
strength training exercises.

00:20:02.870 --> 00:20:04.730
This means that you
can walk into a gym

00:20:04.730 --> 00:20:08.517
and have your entire workout
automatically tracked for you.

00:20:08.517 --> 00:20:10.850
This makes it really easy to
keep track of your progress

00:20:10.850 --> 00:20:13.689
over time and make
adjustments along the way.

00:20:13.689 --> 00:20:15.230
It's available in
the LG Watch Sport.

00:20:15.230 --> 00:20:17.271
And we'll be rolling it
out to more devices soon.

00:20:19.730 --> 00:20:21.480
So in summary,
activity recognition

00:20:21.480 --> 00:20:24.680
will be bringing you improved
accuracy, simplified APIs,

00:20:24.680 --> 00:20:27.100
and new activities
in the coming month.

00:20:27.100 --> 00:20:29.830
And now I'd like to invite
Steve to talk about how we'll

00:20:29.830 --> 00:20:32.170
be making this, as well
as other contextual use

00:20:32.170 --> 00:20:35.480
cases, run at ultra low power.

00:20:35.480 --> 00:20:38.020
[APPLAUSE]

00:20:38.020 --> 00:20:40.865
STEVE MALKOS: Thanks, Marc
Hi my name is Steve Malkos.

00:20:40.865 --> 00:20:42.970
I'm the Technical Program
Manager for the Android

00:20:42.970 --> 00:20:44.980
Location and Context Team.

00:20:44.980 --> 00:20:48.210
Before I start talking about
Android Sensor Hub and context

00:20:48.210 --> 00:20:50.600
hub runtime environments,
can I see a show of hands?

00:20:50.600 --> 00:20:55.570
How many people here know what
the Android Sensor Hub is?

00:20:55.570 --> 00:20:56.500
Not that many of you.

00:20:56.500 --> 00:20:56.990
That's all right.

00:20:56.990 --> 00:20:58.406
Because when you
leave here today,

00:20:58.406 --> 00:21:01.450
you'll all be experts
in this field.

00:21:01.450 --> 00:21:03.730
Marc just showed us some
really cool examples

00:21:03.730 --> 00:21:06.400
on how activity
recognition works.

00:21:06.400 --> 00:21:09.220
We've launched some amazing
features in Android.

00:21:09.220 --> 00:21:15.340
Things like physically tracking
where you parked your car,

00:21:15.340 --> 00:21:18.130
tracking activities like
running, walking, and biking,

00:21:18.130 --> 00:21:20.710
and providing you with
relevant information that's

00:21:20.710 --> 00:21:23.590
important to you at a
specific moment in time,

00:21:23.590 --> 00:21:25.840
like pulling up a
train schedule as you

00:21:25.840 --> 00:21:27.910
arrive at the train station.

00:21:27.910 --> 00:21:31.090
But we found that bringing
some of these factors, some

00:21:31.090 --> 00:21:32.950
of the biggest limiting
challenges here,

00:21:32.950 --> 00:21:36.220
has been around power,
consuming power.

00:21:36.220 --> 00:21:37.450
That's your battery.

00:21:37.450 --> 00:21:40.840
So with the Android Sensor
Hub and Context Hub Runtime

00:21:40.840 --> 00:21:43.990
Environment, we're able to
leverage the capabilities

00:21:43.990 --> 00:21:47.740
of a low power processor to
make it possible for us to bring

00:21:47.740 --> 00:21:51.280
these experiences and more.

00:21:51.280 --> 00:21:53.560
We all know that if you
write an application

00:21:53.560 --> 00:21:55.600
and it sucks up
the user's battery,

00:21:55.600 --> 00:21:58.690
they're going to quickly
uninstall it from their device.

00:21:58.690 --> 00:22:00.790
When talking about
power for activities

00:22:00.790 --> 00:22:03.190
that happen in an
always-on fashion,

00:22:03.190 --> 00:22:07.630
there's always two things at
play, latency and accuracy.

00:22:07.630 --> 00:22:09.520
Improving power
means we could run

00:22:09.520 --> 00:22:13.600
our apps at a greater frequency
improving on the latencies.

00:22:13.600 --> 00:22:15.130
Improving power
also means we can

00:22:15.130 --> 00:22:18.760
look at more signals
improving on our accuracies.

00:22:18.760 --> 00:22:22.600
So two years ago, we introduced
the Android Sensor Hub

00:22:22.600 --> 00:22:23.860
in Marshmallow.

00:22:23.860 --> 00:22:26.740
We use this tiny
standalone microcontroller,

00:22:26.740 --> 00:22:29.530
that's depicted on a
dime, and connected

00:22:29.530 --> 00:22:31.030
all the sensors to it.

00:22:31.030 --> 00:22:34.060
And it runs in an
always-on fashion.

00:22:34.060 --> 00:22:38.290
We launched this on the
Nexus 5x and the Nexus 6P.

00:22:38.290 --> 00:22:40.360
Last year, we worked on
the second generation

00:22:40.360 --> 00:22:42.040
of the Android Sensor Hub.

00:22:42.040 --> 00:22:45.280
This time, in addition to
connecting all the sensors

00:22:45.280 --> 00:22:48.490
to it, we also connected all
the wireless connectivity

00:22:48.490 --> 00:22:49.540
components.

00:22:49.540 --> 00:22:53.260
And we launched this on
the Pixel and the Pixel XL.

00:22:53.260 --> 00:22:55.990
As mentioned earlier,
the Android Sensor Hub

00:22:55.990 --> 00:22:59.290
runs in an always-on
processing, and it hardly

00:22:59.290 --> 00:23:01.090
affects the user's battery.

00:23:01.090 --> 00:23:05.380
Context Hub Runtime Environment
provides a common platform

00:23:05.380 --> 00:23:08.890
for us to leverage these
low power processors.

00:23:08.890 --> 00:23:12.550
So with the Context
Hub's common platform,

00:23:12.550 --> 00:23:16.930
we created mini-applications
that we call Nanoapps.

00:23:16.930 --> 00:23:19.060
So let's go through a
couple of Nanoapp examples.

00:23:19.060 --> 00:23:22.760
All the activity recognition
APIs, like running,

00:23:22.760 --> 00:23:24.550
walking, biking,
in-vehicle have been

00:23:24.550 --> 00:23:27.040
ported from the main
application processor

00:23:27.040 --> 00:23:29.400
into the Android Sensor Hub.

00:23:29.400 --> 00:23:32.560
And we'll take a look at how
activity recognition both saves

00:23:32.560 --> 00:23:35.290
on power and improves
on our accuracies

00:23:35.290 --> 00:23:37.720
when running as a Nanoapp.

00:23:37.720 --> 00:23:39.730
If you were to run
activity recognition

00:23:39.730 --> 00:23:41.260
on the main
application processor,

00:23:41.260 --> 00:23:44.980
it consumes a ton of
power, about 5 milliamps.

00:23:44.980 --> 00:23:47.380
When we introduced Sensor
Batching in the Android

00:23:47.380 --> 00:23:50.170
Operating System, we were
able to cut that number down

00:23:50.170 --> 00:23:51.310
into half.

00:23:51.310 --> 00:23:54.640
But it's still running on the
main application processor.

00:23:54.640 --> 00:23:57.730
We took it from 5
milliamps to 2.5 milliamps.

00:23:57.730 --> 00:24:00.580
Running these same algorithms
in the Android Sensor Hub

00:24:00.580 --> 00:24:03.370
as a Nanoapp, costs
us a fraction of that

00:24:03.370 --> 00:24:05.440
power, 300 microamps.

00:24:05.440 --> 00:24:07.780
And because the
power is so low, we

00:24:07.780 --> 00:24:11.770
can now run these algorithms
at a faster frequency improving

00:24:11.770 --> 00:24:14.890
on our latencies
and our accuracies.

00:24:14.890 --> 00:24:17.350
Another example of a Nanoapp
that I'd like to highlight

00:24:17.350 --> 00:24:18.790
is Geofencing.

00:24:18.790 --> 00:24:22.060
There are tons of Geofencing
applications in the market

00:24:22.060 --> 00:24:25.840
today that use the
Google Geofencing APIs.

00:24:25.840 --> 00:24:28.390
We've now offloaded
these algorithms

00:24:28.390 --> 00:24:29.864
from the main
application processor

00:24:29.864 --> 00:24:31.030
into the Android Sensor Hub.

00:24:31.030 --> 00:24:35.380
And we did this by connecting
the Wi-Fi chip, GPS,

00:24:35.380 --> 00:24:38.660
and the cell modem into the
low power compute domains.

00:24:38.660 --> 00:24:40.840
This brings us a
significant power savings,

00:24:40.840 --> 00:24:43.840
and it improves
on our latencies.

00:24:43.840 --> 00:24:45.970
And finally on the
Android Sensor Hub,

00:24:45.970 --> 00:24:47.710
let's talk about gestures.

00:24:47.710 --> 00:24:50.050
We added tons of gestures.

00:24:50.050 --> 00:24:52.810
Gestures like lift
to check phone,

00:24:52.810 --> 00:24:57.340
double tap to check phone,
flip camera, and more.

00:24:57.340 --> 00:24:59.950
I'm going to highlight
one of the examples.

00:24:59.950 --> 00:25:01.870
And let's focus on flip camera.

00:25:01.870 --> 00:25:05.050
If I launch my camera
app and double twist it,

00:25:05.050 --> 00:25:08.290
it will change from outward
facing to selfie mode.

00:25:08.290 --> 00:25:09.712
I have to do this.

00:25:09.712 --> 00:25:11.920
All right everybody on the
count of three say cheese.

00:25:11.920 --> 00:25:13.655
One, two, three, cheese.

00:25:17.470 --> 00:25:20.740
This gesture is only
possible because it

00:25:20.740 --> 00:25:24.760
runs in an always-on fashion
in the Android Sensor Hub.

00:25:24.760 --> 00:25:27.220
Any application could
register and use

00:25:27.220 --> 00:25:30.340
this private sensor type today.

00:25:30.340 --> 00:25:32.680
To close on the Android
Sensor Hub with CHRE,

00:25:32.680 --> 00:25:35.530
devices on the market that
support this automatically

00:25:35.530 --> 00:25:37.990
get a common platform
that takes advantage

00:25:37.990 --> 00:25:40.120
of lower power,
lower latencies, in

00:25:40.120 --> 00:25:42.340
an always-on compute fashion.

00:25:42.340 --> 00:25:47.440
And these Nanoapps can overcome
some of the new paradigms that

00:25:47.440 --> 00:25:49.870
have been introduced
with our latest operating

00:25:49.870 --> 00:25:53.170
system, like background
location limitations.

00:25:53.170 --> 00:25:56.740
We're really excited about this
platform and the new use cases

00:25:56.740 --> 00:25:59.410
that can be enabled from it.

00:25:59.410 --> 00:26:00.670
I'm going to switch gears now.

00:26:00.670 --> 00:26:02.920
And go from that
to Android sensors,

00:26:02.920 --> 00:26:04.477
highlighting four key items.

00:26:04.477 --> 00:26:06.310
And then Souvik is going
to come up and talk

00:26:06.310 --> 00:26:09.150
to us about the compass.

00:26:09.150 --> 00:26:13.030
Dynamics sensors, this was
introduced in Android N.

00:26:13.030 --> 00:26:16.690
It allows us to expose sensors
that are not necessarily

00:26:16.690 --> 00:26:18.220
bundled with the device.

00:26:18.220 --> 00:26:21.550
And it lets us connect
them via Bluetooth and USB.

00:26:21.550 --> 00:26:24.400
For example, you can now
attach a high quality

00:26:24.400 --> 00:26:26.200
inertial measurement
unit to your device,

00:26:26.200 --> 00:26:30.550
a biological sensor, an
environmental sensor.

00:26:30.550 --> 00:26:32.950
And your apps could
natively see them.

00:26:32.950 --> 00:26:36.040
This year, we're standardizing
on these interfaces

00:26:36.040 --> 00:26:37.450
for dynamic sensors.

00:26:37.450 --> 00:26:39.790
So the sensors that
you build can now

00:26:39.790 --> 00:26:43.090
leverage the Android platform
and make it easier for you,

00:26:43.090 --> 00:26:46.540
as an application
developer, to access them.

00:26:46.540 --> 00:26:48.580
Direct Sensors
Channel, initially

00:26:48.580 --> 00:26:51.370
targeted for VR and
camera applications.

00:26:51.370 --> 00:26:53.380
Simply put, Direct
Sensors Channel

00:26:53.380 --> 00:26:56.020
is minimal latency
between the sensor

00:26:56.020 --> 00:27:00.610
driver and your application by
bypassing the sensor service.

00:27:00.610 --> 00:27:03.700
Accessing sensors directly
with direct sensors channel,

00:27:03.700 --> 00:27:06.250
the programs that you develop
will have the smallest amount

00:27:06.250 --> 00:27:09.040
of sensor latencies.

00:27:09.040 --> 00:27:13.630
Ever experience a VR application
with a skewed horizon?

00:27:13.630 --> 00:27:16.240
Similar to uncalibrated
magnetometer

00:27:16.240 --> 00:27:18.820
and uncalibrated
gyroscope, we introduced

00:27:18.820 --> 00:27:21.280
uncalibrated accelerometer.

00:27:21.280 --> 00:27:23.860
Last year, we wrote our
own calibration algorithms

00:27:23.860 --> 00:27:25.180
for the accelerometer.

00:27:25.180 --> 00:27:28.450
And we open sourced this to
the ecosystem with the hopes

00:27:28.450 --> 00:27:30.340
and goals that a
device manufacturer

00:27:30.340 --> 00:27:32.410
would build better devices.

00:27:32.410 --> 00:27:35.170
And we're seeing
results like this.

00:27:35.170 --> 00:27:38.860
After applying the
calibration algorithms,

00:27:38.860 --> 00:27:41.685
the VR landscape is straight.

00:27:41.685 --> 00:27:43.810
The final sensor feature
that I'm going to focus on

00:27:43.810 --> 00:27:48.280
is Wrist Sensor, now called
Low Latency Off-body Detector.

00:27:48.280 --> 00:27:51.430
Simply, we have a reliable way
to detect when the watch is

00:27:51.430 --> 00:27:54.250
on the wrist or off the wrist.

00:27:54.250 --> 00:27:56.590
The targeted use
cases for this is low

00:27:56.590 --> 00:28:00.040
friction authentication to
your phone, no passcodes

00:28:00.040 --> 00:28:03.040
for payments, and
changing the UI behavior

00:28:03.040 --> 00:28:04.570
when the watch is
off your wrist,

00:28:04.570 --> 00:28:06.700
like sleeping the watch
more aggressively when its

00:28:06.700 --> 00:28:09.190
off your wrist.

00:28:09.190 --> 00:28:10.690
So before I had the
microphone over,

00:28:10.690 --> 00:28:12.940
I want to quickly note
that we use sensors today

00:28:12.940 --> 00:28:14.890
in almost every application.

00:28:14.890 --> 00:28:18.280
And our commitments to
them at Google is huge.

00:28:18.280 --> 00:28:21.310
We'll continue to invest
in the sensor's future.

00:28:21.310 --> 00:28:23.950
These features, like Dynamic
Sensors, Direct Sensors

00:28:23.950 --> 00:28:26.860
Channel, calibration algorithms,
and Low Latency Off-Body

00:28:26.860 --> 00:28:29.710
Detector, are just a
few highlighted examples

00:28:29.710 --> 00:28:31.030
on what we're working on.

00:28:31.030 --> 00:28:34.030
We'll be adding more sensor
features in the future.

00:28:34.030 --> 00:28:36.220
With that, let's continue
on the sensor theme

00:28:36.220 --> 00:28:39.510
and hear from Souvik
on the compass.

00:28:39.510 --> 00:28:44.007
[APPLAUSE]

00:28:44.007 --> 00:28:45.090
SOUVIK SEN: Thanks, Steve.

00:28:45.090 --> 00:28:45.880
I'm Souvik.

00:28:45.880 --> 00:28:48.730
And I'm a Software Engineer on
Android Location and Context

00:28:48.730 --> 00:28:49.230
Team.

00:28:49.230 --> 00:28:52.290
And I'm here to talk
about heading and bearing.

00:28:52.290 --> 00:28:56.870
So what is heading and bearing?

00:28:56.870 --> 00:28:59.700
So bearing tells you, as
a context, the direction

00:28:59.700 --> 00:29:01.430
that the user is traveling.

00:29:01.430 --> 00:29:03.890
And heading is the direction
that the user's phone

00:29:03.890 --> 00:29:05.170
is pointing.

00:29:05.170 --> 00:29:06.840
So heading and
bearing are different.

00:29:06.840 --> 00:29:10.670
Heading is something that if
you are standing at a stoplight

00:29:10.670 --> 00:29:13.680
and you pan your phone around to
find which direction you should

00:29:13.680 --> 00:29:16.230
walk, that's when
you're heading changes.

00:29:16.230 --> 00:29:17.730
And your bearing
is not necessarily

00:29:17.730 --> 00:29:20.930
changing at that point.

00:29:20.930 --> 00:29:22.690
So how do you realize
bearing and heading?

00:29:22.690 --> 00:29:25.340
It depends a lot on
the user's context.

00:29:25.340 --> 00:29:28.000
So if you're an
application who might

00:29:28.000 --> 00:29:30.220
gain by knowing the
direction of the user,

00:29:30.220 --> 00:29:32.650
think very hard about what
context you are after.

00:29:32.650 --> 00:29:34.570
Because based on that
you want to select

00:29:34.570 --> 00:29:36.910
between heading or bearing.

00:29:36.910 --> 00:29:39.850
Let's see how we're doing
that in Android Google Maps.

00:29:43.060 --> 00:29:45.800
So in Android Google
Maps, the blue dot arrow

00:29:45.800 --> 00:29:47.930
used to always point
to the user's heading,

00:29:47.930 --> 00:29:51.890
essentially which direction
your phone is pointing.

00:29:51.890 --> 00:29:54.560
Now what we found is that
the user's expectation

00:29:54.560 --> 00:29:57.710
from the blue dot
arrow is much more.

00:29:57.710 --> 00:30:02.030
When they are stationary,
like standing still or panning

00:30:02.030 --> 00:30:05.090
their phone around, they
want to see their heading

00:30:05.090 --> 00:30:06.185
from the blue dot arrow.

00:30:06.185 --> 00:30:08.060
Perhaps because they
are trying to figure out

00:30:08.060 --> 00:30:09.990
which direction to go next.

00:30:09.990 --> 00:30:12.710
If they're traveling, like
in a car, or in a bicycle,

00:30:12.710 --> 00:30:16.259
or even when they're running,
they want to see the bearing.

00:30:16.259 --> 00:30:18.050
That is the direction
that they are moving.

00:30:18.050 --> 00:30:20.650
Because they want
to, perhaps, verify

00:30:20.650 --> 00:30:24.020
that the direction they're going
towards is actually correct.

00:30:24.020 --> 00:30:25.460
And more importantly,
they want us

00:30:25.460 --> 00:30:28.190
to communicate the uncertainty
in heading or bearing.

00:30:28.190 --> 00:30:30.570
Because if you're not certain,
if the heading are bearing

00:30:30.570 --> 00:30:32.905
information that we are giving
to the user it is not correct,

00:30:32.905 --> 00:30:35.300
the user wants to look
around, and orient themselves,

00:30:35.300 --> 00:30:37.670
and be diligent about this.

00:30:37.670 --> 00:30:40.430
So how do we do this?

00:30:40.430 --> 00:30:42.964
To distinguish between
stationary and traveling,

00:30:42.964 --> 00:30:44.630
we can use the Activity
Recognition API,

00:30:44.630 --> 00:30:45.950
like Marc just talked about.

00:30:45.950 --> 00:30:48.470
You can know when the user is
stationary versus traveling

00:30:48.470 --> 00:30:51.840
and choose between heading
and bearing based on that.

00:30:51.840 --> 00:30:55.020
Now to determine
the uncertainty--

00:30:55.020 --> 00:30:57.290
note that bearing is
based on location.

00:30:57.290 --> 00:31:01.240
So you can see what
the location speed is,

00:31:01.240 --> 00:31:03.100
and what the
location accuracy is.

00:31:03.100 --> 00:31:04.600
And based on that,
you can determine

00:31:04.600 --> 00:31:07.280
the bearing is correct or not.

00:31:07.280 --> 00:31:10.330
But how do you find
heading uncertainty?

00:31:10.330 --> 00:31:13.360
To understand that, let's
see how heading is actually

00:31:13.360 --> 00:31:15.160
being computed.

00:31:15.160 --> 00:31:19.190
So heading today is estimated
based on the phone's compass.

00:31:19.190 --> 00:31:21.710
And as many of you know, if you
know the phone's compass can

00:31:21.710 --> 00:31:24.530
be very unreliable
in presence of metal

00:31:24.530 --> 00:31:27.410
objects or externally
electromagnetic fields.

00:31:27.410 --> 00:31:30.710
Simple cases, for example,
if you're in a car,

00:31:30.710 --> 00:31:32.420
or you're charging your phone.

00:31:32.420 --> 00:31:34.490
Or even simple things,
like you keep your phone

00:31:34.490 --> 00:31:37.070
next to your laptop,
it's possible

00:31:37.070 --> 00:31:40.370
that the phone's compass will
become uncalibrated and hence

00:31:40.370 --> 00:31:41.792
become unreadable.

00:31:41.792 --> 00:31:43.750
And all of this ties to
the heading uncertainty

00:31:43.750 --> 00:31:45.260
that we're after.

00:31:45.260 --> 00:31:48.230
So in a nutshell what we found,
by looking at a lot of data,

00:31:48.230 --> 00:31:50.270
is that heading
uncertainty really

00:31:50.270 --> 00:31:52.670
is about what is the
environmental uncertainty

00:31:52.670 --> 00:31:55.470
in which your device is at.

00:31:55.470 --> 00:31:59.600
Now to understand the
environmental uncertainty,

00:31:59.600 --> 00:32:01.910
we found machine learning
can actually help us.

00:32:01.910 --> 00:32:06.230
There is only a few kinds of
involvement of uncertainty

00:32:06.230 --> 00:32:07.740
[INAUDIBLE] that are after.

00:32:07.740 --> 00:32:09.615
And if you have enough
data, machine learning

00:32:09.615 --> 00:32:11.950
can tell when there is anomaly.

00:32:11.950 --> 00:32:13.860
And hence when the
compass is correct

00:32:13.860 --> 00:32:15.710
and when the compass is not.

00:32:15.710 --> 00:32:17.630
And that ties into
heading uncertainty.

00:32:17.630 --> 00:32:19.340
We can tell the
user, your heading

00:32:19.340 --> 00:32:23.050
is probably not correct because
the compass is unreliable.

00:32:23.050 --> 00:32:25.210
And moreover, now,
because we know

00:32:25.210 --> 00:32:26.780
when the compass
is unreliable, we

00:32:26.780 --> 00:32:30.370
can go back to other kinds
of sensors like gyroscope.

00:32:30.370 --> 00:32:34.280
And this in return, actually
improves the accuracy

00:32:34.280 --> 00:32:36.410
significantly.

00:32:36.410 --> 00:32:39.020
So now that we know the
heading uncertainty,

00:32:39.020 --> 00:32:43.220
let's see how we can communicate
that in Android Google Maps.

00:32:43.220 --> 00:32:46.340
So before in Google Maps, we
had this pointy cone, which

00:32:46.340 --> 00:32:48.320
will always point to heading.

00:32:48.320 --> 00:32:51.000
But now, because we know
the heading uncertainty,

00:32:51.000 --> 00:32:54.050
we have a Cone UI where
the width of the cone

00:32:54.050 --> 00:32:56.282
now tells you what is the
uncertainty in heading.

00:32:56.282 --> 00:32:58.740
If it's too wide, you know that
the heading is probably not

00:32:58.740 --> 00:32:59.420
correct.

00:32:59.420 --> 00:33:02.780
And hence, you can look around
and try to orient yourself.

00:33:02.780 --> 00:33:04.280
If the cone is
narrow, you know it

00:33:04.280 --> 00:33:09.540
is correct you can just use
it for your own travels.

00:33:09.540 --> 00:33:12.030
Beyond Android
Google Maps, if you

00:33:12.030 --> 00:33:14.690
are an application
who might benefit

00:33:14.690 --> 00:33:17.490
by knowing the user's
direction, and also

00:33:17.490 --> 00:33:19.454
the uncertainty in a
more correct fashion,

00:33:19.454 --> 00:33:21.370
we're happy to announce
that this is something

00:33:21.370 --> 00:33:23.660
we're going to bring
in for all applications

00:33:23.660 --> 00:33:27.610
through the Fused
Location Provider API.

00:33:27.610 --> 00:33:29.716
With this, I will
hand over to Steve

00:33:29.716 --> 00:33:32.090
to talk about the future of
Android Location and Context.

00:33:32.090 --> 00:33:33.312
Thank you.

00:33:33.312 --> 00:33:36.900
[APPLAUSE]

00:33:36.900 --> 00:33:38.750
STEVE MALKOS: Thanks, Souvik.

00:33:38.750 --> 00:33:40.340
I love talking about the future.

00:33:40.340 --> 00:33:43.720
So let's talk about the
presence with regards

00:33:43.720 --> 00:33:45.460
to testing location quality.

00:33:45.460 --> 00:33:49.060
Because that's the key to
making future improvements.

00:33:49.060 --> 00:33:51.160
Over the past few
years we've gotten

00:33:51.160 --> 00:33:54.280
very serious with regards
to testing at Google.

00:33:54.280 --> 00:33:57.520
We've built up massive
labs and real time tests

00:33:57.520 --> 00:34:00.580
from around the world
measuring our location quality.

00:34:00.580 --> 00:34:03.940
For example, we run running
tests, walking tests, biking

00:34:03.940 --> 00:34:07.780
tests, stationary tests, testing
both indoors and outdoors.

00:34:07.780 --> 00:34:09.969
When driving near
tall buildings,

00:34:09.969 --> 00:34:12.219
it's very common for
your GPS position

00:34:12.219 --> 00:34:15.429
to jump, lag, or even drift.

00:34:15.429 --> 00:34:21.370
At Google, we use very expensive
military grade inertial

00:34:21.370 --> 00:34:24.820
measurement unit that gives us
centimeter level accuracies.

00:34:24.820 --> 00:34:28.060
That gives us this ground truth.

00:34:28.060 --> 00:34:31.000
That's the image at the top,
the San Francisco test setup.

00:34:31.000 --> 00:34:35.320
The image at the bottom shows
our running and pedestrian test

00:34:35.320 --> 00:34:36.429
setups.

00:34:36.429 --> 00:34:39.190
The output from these
tests is the graph,

00:34:39.190 --> 00:34:41.080
where we show a
cumulative distribution

00:34:41.080 --> 00:34:45.159
function on the position errors
from each device, as measured

00:34:45.159 --> 00:34:48.190
from the ground truth.

00:34:48.190 --> 00:34:50.860
Project Elevation, before
talking about this,

00:34:50.860 --> 00:34:53.230
I want to quickly
note about a service

00:34:53.230 --> 00:34:56.560
that we launched last year
called Emergency Location

00:34:56.560 --> 00:34:58.420
Services in Android.

00:34:58.420 --> 00:35:00.460
This service gives
us the ability

00:35:00.460 --> 00:35:03.370
to use the computed
location in Android

00:35:03.370 --> 00:35:05.770
and send it to
emergency responders

00:35:05.770 --> 00:35:08.030
during an emergency situation.

00:35:08.030 --> 00:35:13.060
So for example, if you dial
911, or 112, on your handset

00:35:13.060 --> 00:35:14.710
the computed
position from Android

00:35:14.710 --> 00:35:18.070
will go to carrier's network
and public safety answering

00:35:18.070 --> 00:35:22.690
points for those carriers who
sign up for this free service.

00:35:22.690 --> 00:35:25.930
With that in mind,
Project Elevation.

00:35:25.930 --> 00:35:28.690
Many places around the world,
like downtown San Francisco,

00:35:28.690 --> 00:35:31.660
when you're deep indoors
your 2D Lat and long

00:35:31.660 --> 00:35:33.310
are just not enough.

00:35:33.310 --> 00:35:36.730
GPS altitude works great when
you're outdoors but barely

00:35:36.730 --> 00:35:39.460
works, if at all, deep indoors.

00:35:39.460 --> 00:35:41.560
And we especially
need it when we're

00:35:41.560 --> 00:35:43.300
in environments like this.

00:35:43.300 --> 00:35:47.080
So with Google's Machine
Learning Algorithm's Anonymized

00:35:47.080 --> 00:35:49.810
Crowd sourced Models,
we'll soon be launching

00:35:49.810 --> 00:35:52.180
Project Elevation this year.

00:35:52.180 --> 00:35:54.250
This service will
first be utilized

00:35:54.250 --> 00:35:57.640
by our Emergency Location
Services in Android,

00:35:57.640 --> 00:36:00.520
where we hope to see first
responders benefiting off

00:36:00.520 --> 00:36:01.210
of it.

00:36:01.210 --> 00:36:05.230
And then we'll also launch it
as part of the standard Android

00:36:05.230 --> 00:36:07.240
Location Altitude Outputs.

00:36:07.240 --> 00:36:12.290
So you as a developer could
get access to this as well.

00:36:12.290 --> 00:36:16.630
We'll also bring a new class
of 3D accurate indoor location.

00:36:16.630 --> 00:36:18.730
You heard part of this from Wei.

00:36:18.730 --> 00:36:24.550
By using Wi-Fi, GPS,
cellular, PDR, IMU, altimeter,

00:36:24.550 --> 00:36:26.500
we're just around the
corner from launching

00:36:26.500 --> 00:36:28.610
this massive improvement.

00:36:28.610 --> 00:36:31.450
And we'll get there, again, by
using Google's Machine Learning

00:36:31.450 --> 00:36:33.700
Algorithm's Anonymized
Crowdsourced

00:36:33.700 --> 00:36:37.330
Models to give us these better
accuracies, where we can now

00:36:37.330 --> 00:36:39.040
navigate indoors.

00:36:39.040 --> 00:36:42.070
Then once we have this all
running on the main application

00:36:42.070 --> 00:36:45.880
processor, we'll port it down
into the Android Sensor Hub

00:36:45.880 --> 00:36:49.780
because that's the key,
five meters at zero seconds

00:36:49.780 --> 00:36:52.120
time to first fix
at ultra low power.

00:36:55.030 --> 00:36:57.370
The GPS geek inside of
me gets really excited

00:36:57.370 --> 00:37:01.700
when we talk about dual
frequency GNNS receivers.

00:37:01.700 --> 00:37:05.740
L1 plus L5 signals, what
does this mean to you?

00:37:05.740 --> 00:37:08.020
Better GPS performances.

00:37:08.020 --> 00:37:09.550
We'll bring this
into smartphones

00:37:09.550 --> 00:37:11.020
in the next couple of years.

00:37:11.020 --> 00:37:13.490
And we'll do so for
the following reasons.

00:37:13.490 --> 00:37:16.270
Better ranges is for
multipath mitigation.

00:37:16.270 --> 00:37:18.580
Because we'll be using
a higher chipping rate,

00:37:18.580 --> 00:37:23.020
10x higher, it will give
us unprecedented frequency

00:37:23.020 --> 00:37:28.150
diversity using the L1
and L5 signals together.

00:37:28.150 --> 00:37:31.690
Our Android O APIs
already have full support

00:37:31.690 --> 00:37:34.840
for multi frequency
GNNS receivers.

00:37:34.840 --> 00:37:36.570
This enables many use cases.

00:37:36.570 --> 00:37:39.940
I'm just going to highlight
two, better downtown

00:37:39.940 --> 00:37:42.130
urban canyon
performances, no more

00:37:42.130 --> 00:37:44.800
positions on the wrong
side of the street,

00:37:44.800 --> 00:37:47.950
post-process decimeter
level accuracies.

00:37:47.950 --> 00:37:51.070
Any application that needs
really precise location

00:37:51.070 --> 00:37:54.790
will benefit off this,
like fitness applications,

00:37:54.790 --> 00:37:58.120
traffic info, and more.

00:37:58.120 --> 00:38:01.900
So at work, we get to
work on some really cool

00:38:01.900 --> 00:38:03.490
amazing new stuff.

00:38:03.490 --> 00:38:05.410
Let's put this all together.

00:38:05.410 --> 00:38:09.020
The future will become more
and more contextually aware.

00:38:09.020 --> 00:38:12.850
We'll continue to add more
signals into the Android Sensor

00:38:12.850 --> 00:38:13.360
Hub.

00:38:13.360 --> 00:38:17.500
We've already achieved Activity
Recognition and Geofencing.

00:38:17.500 --> 00:38:20.440
Next we're going to add
the Fused Location Provider

00:38:20.440 --> 00:38:23.270
awareness, places, and more.

00:38:23.270 --> 00:38:26.230
We'll do this with deep neural
networks, machine learning

00:38:26.230 --> 00:38:28.840
algorithms, and our
personalized models

00:38:28.840 --> 00:38:31.270
with the goals of
helping you make

00:38:31.270 --> 00:38:35.740
deeper experiences to your
users in your applications.

00:38:35.740 --> 00:38:37.690
By adding all these
signals, we'll

00:38:37.690 --> 00:38:42.160
reach a point of location
and context singularity.

00:38:42.160 --> 00:38:45.910
Where you'll be able to write
applications that simplify user

00:38:45.910 --> 00:38:49.720
interactions, help augment
human memory and knowledge,

00:38:49.720 --> 00:38:53.350
and your users having a better
understanding of themselves.

00:38:53.350 --> 00:38:55.870
I'm truly excited
about this future

00:38:55.870 --> 00:38:57.970
and all these possibilities.

00:38:57.970 --> 00:38:59.814
Thank you very much.

00:38:59.814 --> 00:39:02.018
[APPLAUSE]

