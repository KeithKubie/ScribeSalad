WEBVTT
Kind: captions
Language: en

00:00:00.539 --> 00:00:03.080
What I want to do in this video
is get ourselves a little bit

00:00:03.080 --> 00:00:04.980
more comfortable with
the idea of strings,

00:00:04.980 --> 00:00:07.146
and also see the power of
strings and all the things

00:00:07.146 --> 00:00:09.164
we can do to them
or do with them.

00:00:09.164 --> 00:00:10.580
So what I'm going
to do up here is

00:00:10.580 --> 00:00:12.538
I'm going to write a
little simple program that

00:00:12.538 --> 00:00:14.830
will essentially just define
a bunch of strings for me.

00:00:14.830 --> 00:00:17.162
And then I'm going to use the
Python interpreter to play

00:00:17.162 --> 00:00:19.360
with those strings and see
what we can do to them.

00:00:19.360 --> 00:00:20.800
So let me define a string.

00:00:20.800 --> 00:00:22.140
Let's call the string a.

00:00:22.140 --> 00:00:31.052
And a is-- let's call it
"My first test string."

00:00:31.052 --> 00:00:31.760
Right over there.

00:00:31.760 --> 00:00:34.940
As we know, A string is just
a big sequence of characters.

00:00:34.940 --> 00:00:36.040
Right over here.

00:00:36.040 --> 00:00:38.081
And you can recognize them
because they'll either

00:00:38.081 --> 00:00:39.716
be in single or double
quotation marks.

00:00:39.716 --> 00:00:42.090
And just to make clear that
it doesn't have to be double,

00:00:42.090 --> 00:00:52.540
let me define b to be 'Another
test string that I have

00:00:52.540 --> 00:00:56.810
defined.' And just to clarify
on how you can define strings,

00:00:56.810 --> 00:01:00.600
you can actually put quotations
within the quotation marks,

00:01:00.600 --> 00:01:04.160
as long as it's clear where
the string begins and ends.

00:01:04.160 --> 00:01:06.340
So let's say you have
something like this.

00:01:06.340 --> 00:01:14.260
So let's say you say
"This is Sal's string."

00:01:14.260 --> 00:01:18.080
So in this example,
this apostrophe is OK.

00:01:18.080 --> 00:01:19.440
It's a single quotation.

00:01:19.440 --> 00:01:21.800
But it's OK because
the interpreter

00:01:21.800 --> 00:01:24.590
will know that, look, the string
starts with a double quote.

00:01:24.590 --> 00:01:27.574
So I have to look for another
double quote for it to end.

00:01:27.574 --> 00:01:29.990
So it's not going to say, oh,
it ends at the single quote.

00:01:29.990 --> 00:01:31.904
It says I need to end
with a double quote.

00:01:31.904 --> 00:01:33.820
So it knows that this
whole thing is a string.

00:01:33.820 --> 00:01:37.010
And it also knows that this
apostrophe is just a character.

00:01:37.010 --> 00:01:43.280
One thing I can't do-- let's
try to define string d here.

00:01:43.280 --> 00:01:44.860
Let me define it this way.

00:01:44.860 --> 00:01:50.090
So I couldn't have done
this-- 'This is Sal's string.'

00:01:50.090 --> 00:01:52.720
This doesn't make any
sense because here we're

00:01:52.720 --> 00:01:55.340
opening with a single quotation.

00:01:55.340 --> 00:01:58.200
Then, it'll close when we
get to the next quotation.

00:01:58.200 --> 00:02:00.330
So all of this is just
going to be some text

00:02:00.330 --> 00:02:01.980
that the interpreter
is going to try

00:02:01.980 --> 00:02:03.580
to view as some type
of program and it

00:02:03.580 --> 00:02:05.090
is going to break on that.

00:02:05.090 --> 00:02:07.770
So if you want this to work,
you can't have it like that.

00:02:07.770 --> 00:02:15.800
You could do something like
Sal's-- no, you can do that.

00:02:15.800 --> 00:02:18.047
So 'My favorite-- And
there are ways to do that--

00:02:18.047 --> 00:02:20.380
and we're not going to go
into escape characters and all

00:02:20.380 --> 00:02:21.030
that right now.

00:02:21.030 --> 00:02:25.291
But 'My favorite word
is-- and actually I

00:02:25.291 --> 00:02:26.790
don't know what my
favorite word is.

00:02:26.790 --> 00:02:29.150
I'm kind of putting
myself on the spot.

00:02:29.150 --> 00:02:34.045
But let's say my favorite
word is "asparagus."

00:02:34.045 --> 00:02:37.570
I can't even spell it.

00:02:37.570 --> 00:02:43.690
So 'My favorite word is
"asparagus", what is yours?'

00:02:43.690 --> 00:02:45.210
So once again,
this is legitimate.

00:02:45.210 --> 00:02:47.835
Because I start my string
with a single quotation mark.

00:02:47.835 --> 00:02:50.120
So it says, look let's
not end the string

00:02:50.120 --> 00:02:52.350
until we get to another
single quotation mark.

00:02:52.350 --> 00:02:54.960
So it's not like it'll
confuse the interpreter when

00:02:54.960 --> 00:02:57.160
it sees this first double
quotation because it knows

00:02:57.160 --> 00:02:59.820
that the string started
with a single quotation.

00:02:59.820 --> 00:03:02.000
Let me show you some
other examples of strings.

00:03:02.000 --> 00:03:04.000
And these will be
interesting to deal with.

00:03:04.000 --> 00:03:05.650
And they don't always
have to be named "label."

00:03:05.650 --> 00:03:07.108
So let me call this
my math_string.

00:03:11.271 --> 00:03:12.270
Let's say this is 3+4*2.

00:03:19.190 --> 00:03:20.220
So that's a math_string.

00:03:20.220 --> 00:03:23.050
It's literally just a
string of characters.

00:03:23.050 --> 00:03:24.700
The interpreter
won't evaluate it.

00:03:24.700 --> 00:03:27.830
It literally just views it
as a string of characters.

00:03:27.830 --> 00:03:30.340
So I think this
is a pretty good--

00:03:30.340 --> 00:03:33.777
Let me do one other kind
of pseudo-math string.

00:03:33.777 --> 00:03:35.110
Or let me do another expression.

00:03:35.110 --> 00:03:37.460
Let me call this an
expression_string.

00:03:37.460 --> 00:03:39.190
So that's just the
name of the variable.

00:03:39.190 --> 00:03:49.340
And let me say-- my expression
string is "a+'-- and then

00:03:49.340 --> 00:03:52.960
I'm going to have a string
inside of that string--

00:03:52.960 --> 00:04:03.490
'+b+' tiger.'" Right over there.

00:04:03.490 --> 00:04:05.480
So everything in between
the double quotation

00:04:05.480 --> 00:04:07.360
marks, the interpreter
is just going

00:04:07.360 --> 00:04:10.114
to view as a bunch
of characters.

00:04:10.114 --> 00:04:11.780
But there are interesting
things that we

00:04:11.780 --> 00:04:14.130
might be able to do
with this eventually.

00:04:14.130 --> 00:04:15.950
So that's enough strings
for me to define.

00:04:15.950 --> 00:04:17.408
So let me save this
file right now.

00:04:17.408 --> 00:04:19.639
And let me run it.

00:04:19.639 --> 00:04:21.430
And what this does now
in this environment,

00:04:21.430 --> 00:04:22.600
all of these
strings are defined.

00:04:22.600 --> 00:04:23.580
And I can verify that.

00:04:23.580 --> 00:04:26.220
I can say, A, 'My
first test string.' B,

00:04:26.220 --> 00:04:28.810
'Another test string
that I have defined.' C,

00:04:28.810 --> 00:04:30.660
"This is Sal's test string."

00:04:30.660 --> 00:04:34.312
D, 'my favorite word is
"asparaus"-- "Asparaus."

00:04:34.312 --> 00:04:36.020
I couldn't even spell
asparagus property.

00:04:36.020 --> 00:04:37.230
We'll have to fix that.

00:04:37.230 --> 00:04:41.330
"asparaus", what is yours?' I
missed the "g"-- "asparagus",

00:04:41.330 --> 00:04:42.780
what is yours?'

00:04:42.780 --> 00:04:44.497
And then we have--
it's a good thing

00:04:44.497 --> 00:04:46.080
this isn't a spelling
video-- we could

00:04:46.080 --> 00:04:48.150
look at what
math_string looks like.

00:04:48.150 --> 00:04:50.500
math_string is literally
that string of characters.

00:04:50.500 --> 00:04:52.125
And then we have the
expression_string.

00:04:54.550 --> 00:04:57.320
Literally, just that
string of characters.

00:04:57.320 --> 00:04:59.770
Now let's start to play around
with some of the strings

00:04:59.770 --> 00:05:01.895
and see what we
can do with them.

00:05:01.895 --> 00:05:04.520
So a couple of things-- we could
see hey, how long is a string?

00:05:04.520 --> 00:05:06.600
And there we could use
the built in Python

00:05:06.600 --> 00:05:10.230
function len, which
is short for length.

00:05:10.230 --> 00:05:16.556
So the len of a says, hey,
there's 20 characters in a.

00:05:16.556 --> 00:05:17.180
Let's count it.

00:05:17.180 --> 00:05:22.530
Let's verify it-- 1, 2-- space
is a character-- 3, 4, 5, 6, 7,

00:05:22.530 --> 00:05:28.490
8, 9, 10, 11, 12, 13, 14,
15, 16, 17, 18, 19, 20.

00:05:28.490 --> 00:05:30.180
Yes, 20 characters.

00:05:30.180 --> 00:05:33.700
What's the len of math_string?

00:05:33.700 --> 00:05:37.040
math_string, len
length for short.

00:05:37.040 --> 00:05:38.490
math_string is five characters.

00:05:38.490 --> 00:05:42.370
Let's count them-- 1,
2, 3, 4, 5 characters.

00:05:42.370 --> 00:05:43.550
Makes a lot of sense.

00:05:43.550 --> 00:05:44.360
We could do it for any of them.

00:05:44.360 --> 00:05:45.830
I encourage you to
try this out yourself.

00:05:45.830 --> 00:05:46.600
Really experiment.

00:05:46.600 --> 00:05:48.199
Become comfortable with this.

00:05:48.199 --> 00:05:49.990
Now the next thing I
want to do is show you

00:05:49.990 --> 00:05:51.799
how to concatenate two strings.

00:05:51.799 --> 00:05:53.840
Sounds like a very fancy
word, but it really just

00:05:53.840 --> 00:05:55.980
means connect them together.

00:05:55.980 --> 00:05:59.737
So for example, I would say
let's create a new string.

00:05:59.737 --> 00:06:00.695
Let's call it a_with_b.

00:06:05.010 --> 00:06:07.660
And I'll define it as a+b.

00:06:07.660 --> 00:06:09.580
So I'm doing something
very interesting here.

00:06:09.580 --> 00:06:12.430
You're used to using the
addition operator with numbers.

00:06:12.430 --> 00:06:16.590
But I'm about to
add two strings.

00:06:16.590 --> 00:06:18.720
Let's see what this looks like.

00:06:18.720 --> 00:06:20.720
So let's look what
a_with_b looks like.

00:06:20.720 --> 00:06:23.850
a_with_b is just a variable.

00:06:23.850 --> 00:06:24.870
Now what happened?

00:06:24.870 --> 00:06:27.180
I had a, which is my
first test_string.

00:06:27.180 --> 00:06:29.010
And I had b, which is
another test_string

00:06:29.010 --> 00:06:30.220
that I have defined.

00:06:30.220 --> 00:06:33.840
When I took a+b, it took
a, my first test string,

00:06:33.840 --> 00:06:36.100
and it added b to the end of it.

00:06:36.100 --> 00:06:37.760
It concatenated b to a.

00:06:37.760 --> 00:06:40.984
Concatenated is just a fancy
word for put them together.

00:06:40.984 --> 00:06:43.400
'Another test_string that I
have defined.' So it merged a.

00:06:43.400 --> 00:06:46.589
I guess you could view it
as, input b at the end of a.

00:06:46.589 --> 00:06:47.880
And you could go the other way.

00:06:47.880 --> 00:06:49.005
You could call it b_with_a.

00:06:51.140 --> 00:06:54.540
Let's say that is b+a.

00:06:54.540 --> 00:06:58.220
And then let's look at what
that looks like. b_with_a.

00:06:58.220 --> 00:07:01.246
Now it's the other way around.
a is added to the end of b.

00:07:01.246 --> 00:07:03.120
So you can do very, very
fascinating strings.

00:07:03.120 --> 00:07:07.344
You know if we did
math_string+expression_string.

00:07:07.344 --> 00:07:09.010
I'm not going to set
it to any variable.

00:07:09.010 --> 00:07:11.180
I'll see what I get
if I evaluate that.

00:07:16.370 --> 00:07:20.070
Then I essentially got these
two strings added together.

00:07:20.070 --> 00:07:22.762
And so this string got put
at the end of this string.

00:07:22.762 --> 00:07:23.720
You see it right there.

00:07:23.720 --> 00:07:25.010
And it's this kind of
bizarre looking string.

00:07:25.010 --> 00:07:25.801
But it is a string.

00:07:25.801 --> 00:07:27.404
Everything between
these characters,

00:07:27.404 --> 00:07:29.070
everything between
the double quotation,

00:07:29.070 --> 00:07:30.950
is just viewed as a character.

00:07:30.950 --> 00:07:33.380
These are just characters.

00:07:33.380 --> 00:07:35.472
Now there's many,
many, many other things

00:07:35.472 --> 00:07:36.430
we can do with strings.

00:07:36.430 --> 00:07:38.810
I'm not going to introduce
you to all of them.

00:07:38.810 --> 00:07:40.602
But strings come with
a bunch of functions.

00:07:40.602 --> 00:07:42.851
And if you have an integrated
development environment,

00:07:42.851 --> 00:07:45.760
it'll often tell you what types
of functions you could use.

00:07:45.760 --> 00:07:49.090
For example, maybe
you want a list

00:07:49.090 --> 00:07:50.680
of all of the words in a string.

00:07:50.680 --> 00:07:53.570
So maybe I'm writing
some type of program.

00:07:53.570 --> 00:07:55.320
And I want to take the
string that's in b,

00:07:55.320 --> 00:07:57.330
and I want to put
each of these words

00:07:57.330 --> 00:07:59.460
as a separate element in a list.

00:07:59.460 --> 00:08:02.330
So what I can do is I can say b.

00:08:02.330 --> 00:08:04.410
and I'll call one of
the methods of b--

00:08:04.410 --> 00:08:06.420
and we'll do much
more on methods

00:08:06.420 --> 00:08:08.800
and object oriented
programming and all of that--

00:08:08.800 --> 00:08:11.060
But we can view b as
the string object.

00:08:11.060 --> 00:08:14.420
And it has its own methods
that can operate on itself.

00:08:14.420 --> 00:08:16.040
For now, you could
just say, look,

00:08:16.040 --> 00:08:20.260
if I want to split b
into its component words,

00:08:20.260 --> 00:08:24.600
I could call the split method.

00:08:24.600 --> 00:08:28.670
And I can say, what do
I want to split it on?

00:08:28.670 --> 00:08:31.669
So when I say split, I
mean separate the string

00:08:31.669 --> 00:08:33.669
into a bunch of things
and put them into a list.

00:08:33.669 --> 00:08:37.480
And split the string
wherever I see a space.

00:08:37.480 --> 00:08:39.544
So let's see what we
return when we get that.

00:08:39.544 --> 00:08:41.919
So notice, it took this string,
'Another test string that

00:08:41.919 --> 00:08:45.570
I've defined.' It separated the
string wherever there's a space

00:08:45.570 --> 00:08:48.870
and took what's on either
side of the space and put it

00:08:48.870 --> 00:08:50.180
as an element in a list.

00:08:50.180 --> 00:08:52.990
Could be useful if you're doing
some type of text processing.

00:08:52.990 --> 00:08:54.573
But I want to show
you that it doesn't

00:08:54.573 --> 00:08:58.850
have to be split just
where you have a space.

00:08:58.850 --> 00:09:02.450
You could say
b.split, and you could

00:09:02.450 --> 00:09:05.310
split whenever there's a t.

00:09:05.310 --> 00:09:06.520
So you can split on the t.

00:09:06.520 --> 00:09:08.900
And this will give you
some bizarre looking thing.

00:09:08.900 --> 00:09:12.230
So notice every time there was
a t, it split the string there.

00:09:12.230 --> 00:09:15.620
And it put what was ever
on each side of those t's

00:09:15.620 --> 00:09:19.140
into a separate element
in this list over here.

00:09:19.140 --> 00:09:20.420
So very fascinating things.

00:09:20.420 --> 00:09:23.160
I mean, you can do
things like finding

00:09:23.160 --> 00:09:25.230
where a character
is in a string.

00:09:25.230 --> 00:09:32.890
So, let's say you want to call--
Let's Try the math_string.

00:09:32.890 --> 00:09:35.520
And I want to find
in the math_string--

00:09:35.520 --> 00:09:39.242
so it's one of its methods-- I
want to find that asterisks--

00:09:39.242 --> 00:09:40.700
another word I have
trouble saying.

00:09:40.700 --> 00:09:42.060
So find the asterisks.

00:09:42.060 --> 00:09:45.640
Tell me which character, If
any, has an asterisk in it.

00:09:45.640 --> 00:09:47.760
It tells us the
third character does.

00:09:47.760 --> 00:09:49.310
Let's verify it.

00:09:49.310 --> 00:09:52.125
So this is the
zero-th character.

00:09:52.125 --> 00:09:53.000
That's the beginning.

00:09:53.000 --> 00:09:55.130
That's the convention in
most computer programs.

00:09:55.130 --> 00:09:57.450
Zero-th character, first
character, second character,

00:09:57.450 --> 00:10:00.590
third character is an asterisks.

00:10:00.590 --> 00:10:02.600
If you wanted to
find the three--

00:10:02.600 --> 00:10:05.200
and I really encourage you
to experiment with this--

00:10:05.200 --> 00:10:07.200
find the 3.

00:10:07.200 --> 00:10:09.700
It's the zero-th
character there.

00:10:09.700 --> 00:10:11.160
Now, there's other stuff.

00:10:11.160 --> 00:10:12.580
You could replace characters.

00:10:12.580 --> 00:10:21.790
You can say, look, let's take
c and let's replace all of--

00:10:21.790 --> 00:10:25.720
And you can either look it up in
a book or just do a web search.

00:10:25.720 --> 00:10:28.980
You can normally find all the
libraries for Python strings.

00:10:28.980 --> 00:10:31.325
Or, if you have an IDE,
Integrated Development

00:10:31.325 --> 00:10:34.300
Environment, it'll suggest
things you can do to strings

00:10:34.300 --> 00:10:35.510
and how you do it.

00:10:35.510 --> 00:10:42.790
But let's say we want to replace
in string c all of the i's with

00:10:42.790 --> 00:10:43.980
o's.

00:10:43.980 --> 00:10:45.800
Let's see what we get.

00:10:45.800 --> 00:10:46.600
So there you go.

00:10:46.600 --> 00:10:50.320
It was 'This is Sal's favorite.'
'This is Sal's string.' When

00:10:50.320 --> 00:10:51.650
you replace it with o's.

00:10:51.650 --> 00:10:53.733
And I want to be clear,
it didn't change string c.

00:10:53.733 --> 00:10:56.980
It created a copy of c with
the i's replaced by o's.

00:10:56.980 --> 00:11:00.420
So then it became
"Thos os Sal's strong."

00:11:00.420 --> 00:11:04.280
It sounds like a Nordic
language of some kind.

00:11:04.280 --> 00:11:06.920
And just to be clear,
c did not change.

00:11:06.920 --> 00:11:17.750
But if I said c=c.replace, and
replace the i's with o's, then

00:11:17.750 --> 00:11:21.910
c has changed to "Thos
os Sal's strong."

00:11:21.910 --> 00:11:23.930
Now, the last thing I
want to do is show you

00:11:23.930 --> 00:11:26.790
a very magical function, at
least from my point of view.

00:11:26.790 --> 00:11:28.440
And that's the eval function.

00:11:28.440 --> 00:11:32.160
And it exists in interpreted
languages like Python.

00:11:32.160 --> 00:11:33.550
And it also exists
in JavaScript.

00:11:33.550 --> 00:11:37.260
And what's really cool is
it can evaluate a string.

00:11:37.260 --> 00:11:39.610
It can view a string,
you can treat it

00:11:39.610 --> 00:11:41.700
as a string for a while
and you can construct it.

00:11:41.700 --> 00:11:44.140
So you could, for example,
have a computer program that

00:11:44.140 --> 00:11:46.490
writes another computer
program inside a string

00:11:46.490 --> 00:11:48.684
and then evaluates
that, and then evaluates

00:11:48.684 --> 00:11:49.600
that computer program.

00:11:49.600 --> 00:11:51.183
So that should get
you philosophically

00:11:51.183 --> 00:11:52.180
thinking a little bit.

00:11:52.180 --> 00:11:55.880
So for example, if I
just say math_string,

00:11:55.880 --> 00:11:57.620
it's just a string
of characters.

00:11:57.620 --> 00:12:04.240
But if I say eval
math_string, the interpreter

00:12:04.240 --> 00:12:06.550
will actually evaluate
what's inside of this.

00:12:06.550 --> 00:12:08.710
So it'll actually treat
it as an expression.

00:12:08.710 --> 00:12:10.009
And so I get 11.

00:12:10.009 --> 00:12:11.550
So it takes math_string
and says, OK,

00:12:11.550 --> 00:12:13.300
now let me treat that
as like a program.

00:12:13.300 --> 00:12:14.950
So it's 3+4*2.

00:12:14.950 --> 00:12:17.570
Order of operations--
does the 4*2 first.

00:12:17.570 --> 00:12:18.250
So that's 8.

00:12:18.250 --> 00:12:20.971
3 plus 8 is 11.

00:12:20.971 --> 00:12:22.470
And you could do
even cooler things.

00:12:22.470 --> 00:12:26.410
You could do eval-- let's think
about this-- math_string--

00:12:26.410 --> 00:12:33.380
and let's add to
math_string the character 1.

00:12:33.380 --> 00:12:36.360
And let's see what it
gets us-- it gets us 87.

00:12:36.360 --> 00:12:37.530
What did it do?

00:12:37.530 --> 00:12:40.190
Well, what it did is,
math_string is this stuff.

00:12:40.190 --> 00:12:43.230
But if you add a 1 to it,
it would look like that.

00:12:43.230 --> 00:12:45.050
The 2 would become a 21.

00:12:45.050 --> 00:12:47.680
We're concatenating
a 1 to the end of it.

00:12:47.680 --> 00:12:52.741
So it became 4 times 21, which
is 84 plus 3, which is 87.

00:12:52.741 --> 00:12:53.990
And you could do other things.

00:12:53.990 --> 00:12:55.670
We can evaluate this
expression_string right

00:12:55.670 --> 00:12:56.210
over here.

00:12:56.210 --> 00:12:57.820
That's why I set
it up like that.

00:12:57.820 --> 00:12:58.955
eval expression_string.

00:13:02.090 --> 00:13:03.160
Really fun to play with.

00:13:03.160 --> 00:13:05.085
I could do this all day.

00:13:05.085 --> 00:13:06.960
Remember, expression_string
is just a string.

00:13:06.960 --> 00:13:08.830
But when we evaluate it--
and you might want to pause

00:13:08.830 --> 00:13:10.520
and think what
you're going to get.

00:13:10.520 --> 00:13:12.350
So let's evaluate it.

00:13:12.350 --> 00:13:13.490
I got all this craziness.

00:13:13.490 --> 00:13:14.700
Where did that come from?

00:13:14.700 --> 00:13:17.440
Well, in the string, these
were just characters-- a and b.

00:13:17.440 --> 00:13:19.740
But when I evaluated
in our current context,

00:13:19.740 --> 00:13:22.666
a and b are variables and
they represent strings.

00:13:22.666 --> 00:13:24.790
So when you evaluate this
thing, it's going to say,

00:13:24.790 --> 00:13:25.570
OK, a is a string.

00:13:25.570 --> 00:13:27.850
That's 'My first test
string.' Concatenate,

00:13:27.850 --> 00:13:30.000
or, put this space
at the end of it.

00:13:30.000 --> 00:13:32.500
So 'My first test string'--
and then I have a space.

00:13:32.500 --> 00:13:34.390
And then put b at
the end of that.

00:13:34.390 --> 00:13:41.110
So 'Another test string that I
have defined.' Then put a space

00:13:41.110 --> 00:13:42.130
tiger.

00:13:42.130 --> 00:13:44.380
And then you have a space tiger.

00:13:44.380 --> 00:13:46.750
So I'm going to leave you there.

00:13:46.750 --> 00:13:49.220
As you can imagine, strings
are super, super duper

00:13:49.220 --> 00:13:52.070
powerful concepts for doing
a bunch of applications.

00:13:52.070 --> 00:13:54.420
And I haven't exhausted
anywhere near all the functions

00:13:54.420 --> 00:13:55.711
or things you can do with them.

00:13:55.711 --> 00:13:57.640
So I encourage
you to experiment.

