WEBVTT
Kind: captions
Language: en

00:00:02.455 --> 00:00:04.040
JOANNA SMITH: Any
time that you can

00:00:04.040 --> 00:00:06.320
settle for computing
a less precise answer,

00:00:06.320 --> 00:00:08.222
you're going to get
a performance win.

00:00:08.222 --> 00:00:08.930
I'm Joanna Smith.

00:00:08.930 --> 00:00:10.596
And I'm going to show
you how to balance

00:00:10.596 --> 00:00:12.320
the drive for perfection
against the need

00:00:12.320 --> 00:00:14.300
for perfect performance
while still keeping

00:00:14.300 --> 00:00:16.329
your users perfectly happy.

00:00:16.329 --> 00:00:18.880
Approximation is all about
cutting corners and making

00:00:18.880 --> 00:00:21.760
things good enough for users
and then convincing developers

00:00:21.760 --> 00:00:23.580
that it's OK to do that.

00:00:23.580 --> 00:00:26.110
Consider a trip planner app
that uses the user's location

00:00:26.110 --> 00:00:28.766
to offer reminders to get
gas or suggestions on where

00:00:28.766 --> 00:00:30.920
to eat or cool things to see.

00:00:30.920 --> 00:00:32.960
Now the app doesn't need
the device's location

00:00:32.960 --> 00:00:34.590
down to the foot to do this.

00:00:34.590 --> 00:00:36.160
A zip code might
actually be all it

00:00:36.160 --> 00:00:38.090
needs until the user
accepts a suggestion

00:00:38.090 --> 00:00:40.450
and then asks for
navigation directions.

00:00:40.450 --> 00:00:43.280
That would be the moment to
increase the GPS's precision.

00:00:43.280 --> 00:00:45.620
And this is
approximation in action.

00:00:45.620 --> 00:00:48.950
Using less time, calculating a
less precise result that still

00:00:48.950 --> 00:00:50.870
meets the user's current need.

00:00:50.870 --> 00:00:52.770
So how much time
is your app wasting

00:00:52.770 --> 00:00:55.260
with a more precise result
when something less precise

00:00:55.260 --> 00:00:57.200
would not be
noticed by the user?

00:00:57.200 --> 00:00:59.980
Put in this slide, the potential
for savings for approximation

00:00:59.980 --> 00:01:01.199
is everywhere.

00:01:01.199 --> 00:01:02.490
Like with our trip planner app.

00:01:02.490 --> 00:01:05.129
While the user is driving
on that long, long road,

00:01:05.129 --> 00:01:07.170
it's not necessary to poll
the server for updates

00:01:07.170 --> 00:01:08.850
exactly every five. minutes.

00:01:08.850 --> 00:01:11.080
Instead, your app could
batch and schedule

00:01:11.080 --> 00:01:14.060
requests less precisely and
less frequently to save battery

00:01:14.060 --> 00:01:16.552
which the user will
need if they get a flat.

00:01:16.552 --> 00:01:18.010
The app could also
calculate a path

00:01:18.010 --> 00:01:19.635
between two cities
on the trip and then

00:01:19.635 --> 00:01:21.850
use the estimated travel
time to set an alarm

00:01:21.850 --> 00:01:25.050
for some future time when it
will wake up, turn on the GPS,

00:01:25.050 --> 00:01:26.809
and start offering
suggestions again.

00:01:26.809 --> 00:01:29.100
Because until there is a
point of interest nearby worth

00:01:29.100 --> 00:01:30.530
offering to the
user, there really

00:01:30.530 --> 00:01:32.446
isn't much use in tracking
the user's location

00:01:32.446 --> 00:01:34.634
along that long empty highway.

00:01:34.634 --> 00:01:36.300
And, of course, there
are approximations

00:01:36.300 --> 00:01:37.690
as simple as
allowing your images

00:01:37.690 --> 00:01:40.880
to be slightly lower resolution
in order to save memory space

00:01:40.880 --> 00:01:42.540
and increase rendering speed.

00:01:42.540 --> 00:01:44.260
Because when the
user is scrolling

00:01:44.260 --> 00:01:46.310
through a list of potential
stops along the road,

00:01:46.310 --> 00:01:48.190
they don't need the
fully detailed image yet.

00:01:48.190 --> 00:01:50.439
You can load that when they're
contemplating the decor

00:01:50.439 --> 00:01:52.030
of their chosen restaurant.

00:01:52.030 --> 00:01:54.780
Now I'm going to say this
again, so listen this time.

00:01:54.780 --> 00:01:56.970
For a large majority
of your code,

00:01:56.970 --> 00:01:59.850
you don't need
100% exact results.

00:01:59.850 --> 00:02:01.410
By demanding less
from the hardware

00:02:01.410 --> 00:02:03.250
and still giving users
everything they need,

00:02:03.250 --> 00:02:05.890
you can potentially gain
a lot for your frame rate

00:02:05.890 --> 00:02:08.590
and for the device's
battery life.

00:02:08.590 --> 00:02:10.930
So at its core, approximation
is all about tradeoffs.

00:02:10.930 --> 00:02:13.472
Which in reality is just like
everything else in performance.

00:02:13.472 --> 00:02:15.971
And that's why you need to check
out the rest of our Android

00:02:15.971 --> 00:02:17.860
Performance Patterns
Content and consider

00:02:17.860 --> 00:02:20.410
joining our G Plus community
for tips, tricks, and help.

00:02:20.410 --> 00:02:22.820
So keep calm, profile your
code, and always remember

00:02:22.820 --> 00:02:24.980
perf matters.

