WEBVTT
Kind: captions
Language: en

00:00:01.380 --> 00:00:01.890
JEZ FLETCHER: All right.

00:00:01.890 --> 00:00:04.190
Good afternoon, everyone, and
welcome to this session, which

00:00:04.190 --> 00:00:06.960
is called "How to Build
Multi-platform Maps with

00:00:06.960 --> 00:00:10.010
Google's APIs." My name's
Jez Fletcher.

00:00:10.010 --> 00:00:12.480
I'm a software engineer
on the Google Maps API

00:00:12.480 --> 00:00:14.360
team based in Sydney.

00:00:14.360 --> 00:00:14.710
ENOCH LAU: Hi.

00:00:14.710 --> 00:00:17.540
I'm Enoch Lau, and I'm a
software engineer also in

00:00:17.540 --> 00:00:20.830
Sydney on the Google
Maps API team.

00:00:20.830 --> 00:00:23.020
JEZ FLETCHER: So we thought we'd
start out this afternoon

00:00:23.020 --> 00:00:25.790
with some reasons why you should
be in this session as

00:00:25.790 --> 00:00:27.210
opposed to any of the other
sessions that are

00:00:27.210 --> 00:00:28.570
currently going on.

00:00:28.570 --> 00:00:31.590
We know that Google I/O's an
exciting time, and there's a

00:00:31.590 --> 00:00:34.250
lot of sessions vying
for your time.

00:00:34.250 --> 00:00:38.080
So one good reason why you
should be here is if you have

00:00:38.080 --> 00:00:40.320
a successful mapping
application,

00:00:40.320 --> 00:00:41.440
perhaps on one platform--

00:00:41.440 --> 00:00:43.150
let's say you have a
successful Android

00:00:43.150 --> 00:00:44.330
application--

00:00:44.330 --> 00:00:47.810
and you'd like to bring it to
other platforms, and you want

00:00:47.810 --> 00:00:50.640
to know the principles that you
should follow to make this

00:00:50.640 --> 00:00:53.430
as seamless as possible to
do this cross-platform

00:00:53.430 --> 00:00:55.070
development.

00:00:55.070 --> 00:00:56.790
ENOCH LAU: Alternatively, you're
starting from scratch.

00:00:56.790 --> 00:00:58.760
You're building a new
application, and you want to

00:00:58.760 --> 00:01:03.800
target it for Android, iOS,
and the web together.

00:01:03.800 --> 00:01:05.319
JEZ FLETCHER: What we're not
going to do in this session is

00:01:05.319 --> 00:01:08.660
do any sort of deep dive into
the code of any of the

00:01:08.660 --> 00:01:10.310
particular platforms.

00:01:10.310 --> 00:01:16.150
There was a great talk yesterday
on iOS mapping using

00:01:16.150 --> 00:01:19.020
the new iOS SDK, and there's
another session directly

00:01:19.020 --> 00:01:22.590
following this on Android and
mapping that's going to go

00:01:22.590 --> 00:01:26.020
really deep into the
code and so forth.

00:01:26.020 --> 00:01:29.010
So we thought we'd start out
with a look at what the

00:01:29.010 --> 00:01:31.710
picture was 12 months ago
if you wanted to do

00:01:31.710 --> 00:01:34.780
cross-platform mapping
development.

00:01:34.780 --> 00:01:37.970
And the answer is that it was
somewhat limited compared to

00:01:37.970 --> 00:01:39.650
what it is now.

00:01:39.650 --> 00:01:43.100
We had the JavaScript Maps API,
which you can see on the

00:01:43.100 --> 00:01:44.600
left there.

00:01:44.600 --> 00:01:46.680
This was actually designed
to work on mobile

00:01:46.680 --> 00:01:48.320
devices quite well.

00:01:48.320 --> 00:01:50.350
But it was only one application,
and it didn't

00:01:50.350 --> 00:01:54.270
have a lot of the cool things
that the newer SDKs do.

00:01:54.270 --> 00:02:00.460
We also had v1 of the Java
MapView for Android, which was

00:02:00.460 --> 00:02:01.120
also limited.

00:02:01.120 --> 00:02:02.800
It wasn't really well supported,
and it was missing

00:02:02.800 --> 00:02:06.620
some of the modern features that
are in the newer ones.

00:02:06.620 --> 00:02:10.060
ENOCH LAU: Now if you fast
forward to today, we now have

00:02:10.060 --> 00:02:15.725
an SDK on iOS for you to write
your maps on iPad and iPhone.

00:02:15.725 --> 00:02:18.840
And now we have version two of
the Android Maps API, which is

00:02:18.840 --> 00:02:19.600
really beautiful.

00:02:19.600 --> 00:02:23.350
It has 3D graphics, tilt, vector
graphics, all that

00:02:23.350 --> 00:02:24.310
lovely stuff.

00:02:24.310 --> 00:02:26.960
And of course, the JavaScript
Maps API is still going strong

00:02:26.960 --> 00:02:31.250
for all your web application
needs.

00:02:31.250 --> 00:02:33.110
JEZ FLETCHER: So one of the
things that we're going to be

00:02:33.110 --> 00:02:36.140
coming back to quite a lot in
this talk is that everything

00:02:36.140 --> 00:02:37.830
is a balancing act.

00:02:37.830 --> 00:02:39.240
Now this is particularly
true when you're doing

00:02:39.240 --> 00:02:41.440
cross-platform development,
because you're going to be

00:02:41.440 --> 00:02:45.380
looking a lot at trade-offs.

00:02:45.380 --> 00:02:47.040
You're going to be looking at
when things should go in the

00:02:47.040 --> 00:02:49.700
frontend, when they should go
in the backend, you're going

00:02:49.700 --> 00:02:54.410
to have to do a lot with UI
things that may be trading off

00:02:54.410 --> 00:02:57.130
between different paradigms
that you want to follow.

00:02:57.130 --> 00:02:59.740
So this is a common theme that
we're going to come back to a

00:02:59.740 --> 00:03:02.260
number of times during
the talk.

00:03:02.260 --> 00:03:03.960
ENOCH LAU: So this talk
is in four parts.

00:03:03.960 --> 00:03:05.690
First of all, we're going to
talk about some of the

00:03:05.690 --> 00:03:09.160
challenges that you might
experience as you develop maps

00:03:09.160 --> 00:03:11.990
on three different platforms.

00:03:11.990 --> 00:03:13.120
JEZ FLETCHER: In the second
part, we're going to talk

00:03:13.120 --> 00:03:16.130
about some good guiding
principles for doing

00:03:16.130 --> 00:03:18.820
cross-platform development
in mapping applications.

00:03:18.820 --> 00:03:21.070
And in the process of doing
this, we hope to provide you

00:03:21.070 --> 00:03:22.730
with some solutions
to the challenges

00:03:22.730 --> 00:03:24.900
of the first section.

00:03:24.900 --> 00:03:26.960
ENOCH LAU: Thirdly, we'll
continue down the path of

00:03:26.960 --> 00:03:29.020
talking about some principles,
and we're going to take a deep

00:03:29.020 --> 00:03:32.240
dive into backend infrastructure
and how you can

00:03:32.240 --> 00:03:35.520
best structure your backend
infrastructure so that writing

00:03:35.520 --> 00:03:38.060
apps in three different
platforms is more efficient

00:03:38.060 --> 00:03:40.350
and more easy for you to do.

00:03:40.350 --> 00:03:41.700
JEZ FLETCHER: And in the fourth
section, we're going to

00:03:41.700 --> 00:03:44.530
invite Jack Kwok, who's a
software architect with

00:03:44.530 --> 00:03:47.620
Trulia, to come up and talk
about Trulia's experience

00:03:47.620 --> 00:03:52.970
dealing with making mapping
applications that run across

00:03:52.970 --> 00:03:55.330
multiple platforms.

00:03:55.330 --> 00:03:56.580
ENOCH LAU: So let begin by
looking at some of the

00:03:56.580 --> 00:03:59.440
challenges that you might
experience as you develop

00:03:59.440 --> 00:04:02.350
mapping applications in
multiple platforms.

00:04:02.350 --> 00:04:04.310
First of all, there is the
question of effort.

00:04:04.310 --> 00:04:07.990
So clearly if you have three
different code bases targeting

00:04:07.990 --> 00:04:12.600
three different platforms, and
each is written independently

00:04:12.600 --> 00:04:14.410
of each other, that's
a lot more effort.

00:04:14.410 --> 00:04:15.760
And what is effort?

00:04:15.760 --> 00:04:16.880
Effort is time.

00:04:16.880 --> 00:04:17.610
And what is time?

00:04:17.610 --> 00:04:18.970
Time is money.

00:04:18.970 --> 00:04:22.070
So there's a question of, should
I put more effort in

00:04:22.070 --> 00:04:24.090
and get a greater reward
potentially?

00:04:24.090 --> 00:04:27.845
But perhaps there's also greater
risk there as well.

00:04:27.845 --> 00:04:30.530
JEZ FLETCHER: One of the next
challenges with dealing in

00:04:30.530 --> 00:04:33.690
multiple platforms is dealing
with the different use cases

00:04:33.690 --> 00:04:35.120
across different platforms.

00:04:35.120 --> 00:04:37.550
Obviously, people are going
to use a desktop device

00:04:37.550 --> 00:04:40.930
differently to how they're going
to use a mobile device.

00:04:40.930 --> 00:04:43.980
And there's also subtle
differences in the way that

00:04:43.980 --> 00:04:46.810
particular platforms, even
different mobile

00:04:46.810 --> 00:04:50.060
platforms, are used.

00:04:50.060 --> 00:04:51.790
ENOCH LAU: Next is the challenge
of thinking about

00:04:51.790 --> 00:04:53.760
what are the capabilities
of the

00:04:53.760 --> 00:04:55.200
platform that you're targeting.

00:04:55.200 --> 00:04:57.890
So each platform clearly has
its own strengths and

00:04:57.890 --> 00:04:59.050
weaknesses.

00:04:59.050 --> 00:05:02.460
On the web, you typically have
people at a desktop computer

00:05:02.460 --> 00:05:05.210
with a big screen real
estate, lots of space

00:05:05.210 --> 00:05:06.240
for you to work with.

00:05:06.240 --> 00:05:08.440
But on a mobile device, less
screen real estate.

00:05:08.440 --> 00:05:10.090
You have less space
to work with.

00:05:10.090 --> 00:05:12.940
But there are unique
capabilities that mobile

00:05:12.940 --> 00:05:17.080
offers, like GPS, storage in the
device, cameras, all that

00:05:17.080 --> 00:05:17.930
kind of stuff.

00:05:17.930 --> 00:05:21.740
And as you remember from the
keynote yesterday, Android now

00:05:21.740 --> 00:05:26.050
has greatly new location APIs,
a great new geofencing API.

00:05:26.050 --> 00:05:28.880
And you can take advantage of
these when you're writing an

00:05:28.880 --> 00:05:30.295
application for Android.

00:05:30.295 --> 00:05:31.600
JEZ FLETCHER: Yeah.

00:05:31.600 --> 00:05:34.240
The other thing to think about
is the user experience.

00:05:34.240 --> 00:05:36.630
And when we talk about the user
experience, we're talking

00:05:36.630 --> 00:05:40.390
about matching up with the way
user actually wants to

00:05:40.390 --> 00:05:42.750
interact with your
application.

00:05:42.750 --> 00:05:46.570
This is particularly important
when you're dealing with a

00:05:46.570 --> 00:05:49.400
mapping application, because
there are certain ways that

00:05:49.400 --> 00:05:52.040
people want to interact with
a mapping application.

00:05:52.040 --> 00:05:54.300
There are certain things that
they expect it to do, and

00:05:54.300 --> 00:05:58.240
there are certain ways that
want they want to use it.

00:05:58.240 --> 00:06:02.050
So ensuring that you have a good
user experience is really

00:06:02.050 --> 00:06:04.700
quite important.

00:06:04.700 --> 00:06:06.710
ENOCH LAU: So let's now take a
look at some of the principles

00:06:06.710 --> 00:06:10.220
that you might follow as you
address some of these

00:06:10.220 --> 00:06:12.410
challenges, and we might provide
some solutions that

00:06:12.410 --> 00:06:14.900
might apply to your
situation as well.

00:06:14.900 --> 00:06:18.850
So to address the problem
about effort versus risk

00:06:18.850 --> 00:06:21.730
versus reward, you need to
work with your budget.

00:06:21.730 --> 00:06:24.610
You need to understand what are
the business constraints

00:06:24.610 --> 00:06:25.735
for your particular
organization.

00:06:25.735 --> 00:06:28.890
So every organization is
going to be different.

00:06:28.890 --> 00:06:30.900
Perhaps your organization
has more resources, more

00:06:30.900 --> 00:06:33.800
manpower, more time.

00:06:33.800 --> 00:06:37.520
In that case, maybe developing
three separate applications is

00:06:37.520 --> 00:06:39.010
the right way to go.

00:06:39.010 --> 00:06:41.060
You're going to end up with
a really slick, beautiful

00:06:41.060 --> 00:06:43.700
experience on each particular
platform.

00:06:43.700 --> 00:06:46.100
On the other hand, if
you have limited

00:06:46.100 --> 00:06:48.040
resources, limited power--

00:06:48.040 --> 00:06:50.410
maybe you need to get to
market really quickly--

00:06:50.410 --> 00:06:51.600
then maybe you just
write it once.

00:06:51.600 --> 00:06:54.060
And here's an example of
what you could do.

00:06:54.060 --> 00:06:57.240
Using the JavaScript Maps API,
perhaps you just write the

00:06:57.240 --> 00:06:59.260
mapping application once.

00:06:59.260 --> 00:07:01.500
Obviously, it works beautifully
in a web browser

00:07:01.500 --> 00:07:02.460
for desktop.

00:07:02.460 --> 00:07:04.830
But then you can also embed this
JavaScript implementation

00:07:04.830 --> 00:07:07.280
into a web view so that you
can put the same mapping

00:07:07.280 --> 00:07:11.120
implementation into a native
Android application.

00:07:11.120 --> 00:07:14.470
Alternatively, you could just
have your users navigate to

00:07:14.470 --> 00:07:17.280
mycompany.com, and then build
a beautiful website.

00:07:17.280 --> 00:07:18.830
That works really well too.

00:07:18.830 --> 00:07:20.010
JEZ FLETCHER: But you'd
say this is a

00:07:20.010 --> 00:07:21.170
balancing act, right?

00:07:21.170 --> 00:07:24.990
Because obviously, there are
advantages and disadvantages

00:07:24.990 --> 00:07:25.750
to both sides.

00:07:25.750 --> 00:07:26.060
ENOCH LAU: That's right.

00:07:26.060 --> 00:07:26.690
It's a balancing act.

00:07:26.690 --> 00:07:27.620
JEZ FLETCHER: So you need
to make that decision.

00:07:27.620 --> 00:07:30.410
It is a balancing act.

00:07:30.410 --> 00:07:32.945
So the next point is recognizing
the use cases.

00:07:32.945 --> 00:07:35.850
Now I talked a little bit before
about that there are

00:07:35.850 --> 00:07:38.590
different use cases, and really
the only thing you can

00:07:38.590 --> 00:07:41.740
do as a developer is to work
out what they are.

00:07:41.740 --> 00:07:42.650
Do some research.

00:07:42.650 --> 00:07:45.400
Find out how your users are
going to be using your

00:07:45.400 --> 00:07:46.840
application.

00:07:46.840 --> 00:07:49.810
Now the key point here, perhaps,
is the difference

00:07:49.810 --> 00:07:53.210
between a desktop application
and a mobile application.

00:07:53.210 --> 00:07:55.830
Obviously, when someone's using
a desktop application,

00:07:55.830 --> 00:07:58.330
they're in a different mode to
when they're using a mobile

00:07:58.330 --> 00:07:59.040
application.

00:07:59.040 --> 00:08:01.660
If you're using a mobile
application, you're

00:08:01.660 --> 00:08:02.640
often out and about.

00:08:02.640 --> 00:08:05.020
You're often doing something
that requires an immediate

00:08:05.020 --> 00:08:09.570
answer, and you're doing
something that needs to be

00:08:09.570 --> 00:08:12.570
more focused to the
task at hand.

00:08:12.570 --> 00:08:14.790
When you're on a desktop device,
you're perhaps doing

00:08:14.790 --> 00:08:15.640
more research.

00:08:15.640 --> 00:08:19.620
You're perhaps doing a more time
intensive and more full

00:08:19.620 --> 00:08:23.320
study of the task that you're
trying to perform.

00:08:23.320 --> 00:08:24.480
ENOCH LAU: So as a great example
of this, here's a

00:08:24.480 --> 00:08:27.780
screen shot from Expedia's
website on desktop.

00:08:27.780 --> 00:08:30.820
And you can see they've taken
advantage of the screen real

00:08:30.820 --> 00:08:33.090
estate afforded to
them on desktop.

00:08:33.090 --> 00:08:35.039
For the hotels, there's great
detail about each.

00:08:35.039 --> 00:08:37.809
There's ratings, price, all of
this stuff in a tabular view

00:08:37.809 --> 00:08:39.220
that's great for research.

00:08:39.220 --> 00:08:41.900
And then if you focus your
attention to the left panel,

00:08:41.900 --> 00:08:44.340
you see that there are many
options to drill down and

00:08:44.340 --> 00:08:45.780
really focus your search.

00:08:45.780 --> 00:08:50.030
So you can select from ratings,
location price.

00:08:50.030 --> 00:08:51.460
There's a little map
there as well.

00:08:51.460 --> 00:08:55.070
So they've taking the screen
real estate given to them and

00:08:55.070 --> 00:08:58.140
provided tools to the user such
that it's really powerful

00:08:58.140 --> 00:09:01.300
for them when they're searching
for hotels.

00:09:01.300 --> 00:09:04.090
JEZ FLETCHER: Now conversely,
these are some shots from

00:09:04.090 --> 00:09:07.240
Expedia's Android application,
which is really great.

00:09:07.240 --> 00:09:09.750
And what they do here is that
they really focused down the

00:09:09.750 --> 00:09:13.000
tasks that they're trying
to deliver.

00:09:13.000 --> 00:09:15.090
So on the left, you can
see this is their

00:09:15.090 --> 00:09:16.690
flight search page.

00:09:16.690 --> 00:09:19.970
And not only is it a lot more
streamlined and a lot more

00:09:19.970 --> 00:09:24.030
clean than the desktop
application, but it also takes

00:09:24.030 --> 00:09:26.210
advantage of the capabilities
of the system.

00:09:26.210 --> 00:09:28.580
You can see here it's
automatically picked up

00:09:28.580 --> 00:09:32.440
Oakland and San Francisco
Airport as nearby airports and

00:09:32.440 --> 00:09:33.500
has put them to the top.

00:09:33.500 --> 00:09:35.970
So you don't have to type in
an airport code to find

00:09:35.970 --> 00:09:38.680
flights from your
local airports.

00:09:38.680 --> 00:09:42.050
On the right hand side, you can
see the hotel search page,

00:09:42.050 --> 00:09:45.730
and this is really quite
different to the desktop

00:09:45.730 --> 00:09:47.040
experience.

00:09:47.040 --> 00:09:49.630
Here, everything is focused
on the map.

00:09:49.630 --> 00:09:55.690
You can get things from your
current location, and you can

00:09:55.690 --> 00:09:58.080
also do this filtering.

00:09:58.080 --> 00:09:59.960
But what they've done is they've
really cut back their

00:09:59.960 --> 00:10:02.520
filtering options, and they've
made it a lot more streamlined

00:10:02.520 --> 00:10:05.590
and a lot more focused than it
was when you had all of those

00:10:05.590 --> 00:10:07.170
options when you have
a desktop device.

00:10:09.910 --> 00:10:12.192
ENOCH LAU: So one other
principle that you can take

00:10:12.192 --> 00:10:16.120
into heart is you need to
focus on the correct UI

00:10:16.120 --> 00:10:18.160
paradigms for your particular
platform.

00:10:18.160 --> 00:10:20.600
And what we mean by that is
there's a balancing act

00:10:20.600 --> 00:10:23.060
between cross-platform
consistency--

00:10:23.060 --> 00:10:24.930
that is, between your various
apps on the different

00:10:24.930 --> 00:10:25.770
platforms--

00:10:25.770 --> 00:10:27.270
and intra-platform
consistency--

00:10:27.270 --> 00:10:29.330
that is, between your
app and other

00:10:29.330 --> 00:10:31.500
apps on the same platform.

00:10:31.500 --> 00:10:32.630
So as an example of this--

00:10:32.630 --> 00:10:34.120
JEZ FLETCHER: So that's a really
good example of what we

00:10:34.120 --> 00:10:37.080
mean by cross-platform
consistency.

00:10:37.080 --> 00:10:39.747
When we're talking about that,
we want to make sure that our

00:10:39.747 --> 00:10:43.260
app feels like it's the same
app, that it works the way it

00:10:43.260 --> 00:10:46.180
should across your different
platforms.

00:10:46.180 --> 00:10:51.100
A great example of how you can
do this really nicely is by

00:10:51.100 --> 00:10:55.990
using Google's mapping
and web services.

00:10:55.990 --> 00:11:00.080
So obviously, if you have the
same data across your

00:11:00.080 --> 00:11:03.020
different devices, then you're
going to get the same results.

00:11:03.020 --> 00:11:06.580
If you use the searches for
a bunch of addresses on a

00:11:06.580 --> 00:11:10.940
desktop device, you can be
confident that those addresses

00:11:10.940 --> 00:11:14.290
are going to be exactly the
same on a mobile device.

00:11:14.290 --> 00:11:16.460
So the example we have here is
some directions across the

00:11:16.460 --> 00:11:19.070
country, and you can see
that they get rendered

00:11:19.070 --> 00:11:20.230
exactly the same way.

00:11:20.230 --> 00:11:24.390
They're exactly the same route
between the desktop device and

00:11:24.390 --> 00:11:25.480
the mobile device.

00:11:25.480 --> 00:11:27.890
And because users are going to
be switching between the two,

00:11:27.890 --> 00:11:29.830
having this kind of consistency
across the

00:11:29.830 --> 00:11:32.652
platform is really
quite important.

00:11:32.652 --> 00:11:34.690
ENOCH LAU: So by contrast,
here's what we mean by

00:11:34.690 --> 00:11:36.590
intra-platform consistency.

00:11:36.590 --> 00:11:39.110
And a great example of this is
to look at the Back button on

00:11:39.110 --> 00:11:40.370
each particular platform.

00:11:40.370 --> 00:11:44.440
So on the left here, we have
a screenshot from iOS.

00:11:44.440 --> 00:11:46.980
And typically in an iPhone
application, your Back button

00:11:46.980 --> 00:11:48.900
goes in the top of the corner.

00:11:48.900 --> 00:11:52.300
So if you're developing a
mapping application for iOS,

00:11:52.300 --> 00:11:54.120
it makes sense to put it on the
top of the corner, this

00:11:54.120 --> 00:11:55.400
Back button.

00:11:55.400 --> 00:11:58.210
On the other hand, on Android,
the Back button is typically

00:11:58.210 --> 00:12:00.400
provided by the operating
system.

00:12:00.400 --> 00:12:02.540
There's a soft button on
the bottom left corner.

00:12:02.540 --> 00:12:05.100
So you want to follow these UI
paradigms for that particular

00:12:05.100 --> 00:12:08.610
platform so that your
application feels as though it

00:12:08.610 --> 00:12:11.050
belongs in that particular
ecosystem of apps.

00:12:11.050 --> 00:12:11.320
JEZ FLETCHER: Yeah.

00:12:11.320 --> 00:12:12.640
It's really quite awkward.

00:12:12.640 --> 00:12:14.090
ENOCH LAU: And there's nothing
worse than opening your

00:12:14.090 --> 00:12:17.360
Android phone and seeing apps
that look like iOS on an

00:12:17.360 --> 00:12:17.760
Android phone.

00:12:17.760 --> 00:12:18.720
It's a little bit grating,
isn't it.

00:12:18.720 --> 00:12:20.530
JEZ FLETCHER: Yeah.

00:12:20.530 --> 00:12:21.130
Nothing worse than that.

00:12:21.130 --> 00:12:22.390
ENOCH LAU: Nothing
worse than that.

00:12:22.390 --> 00:12:23.620
JEZ FLETCHER: Actually, I can
think of a few things worse

00:12:23.620 --> 00:12:25.320
than that, but that's
definitely in

00:12:25.320 --> 00:12:28.440
my top 10, I'd say.

00:12:28.440 --> 00:12:28.850
All right.

00:12:28.850 --> 00:12:34.350
Now let's have a look at some
of the principles of the

00:12:34.350 --> 00:12:37.960
backend infrastructure that
can really make your

00:12:37.960 --> 00:12:41.810
development seamless between
different platforms.

00:12:41.810 --> 00:12:43.650
ENOCH LAU: So one key effective
aspect of strong

00:12:43.650 --> 00:12:46.490
backend infrastructure is to
have a shared data store.

00:12:46.490 --> 00:12:50.070
So it'd be surprising and really
weird if on a desktop

00:12:50.070 --> 00:12:52.570
you could search for
restaurants, but then you get

00:12:52.570 --> 00:12:53.940
a different set of restaurants
if you search

00:12:53.940 --> 00:12:54.650
on your mobile device.

00:12:54.650 --> 00:12:56.980
That would be weird.

00:12:56.980 --> 00:12:57.830
That might seem obvious.

00:12:57.830 --> 00:13:01.080
But a more key point is that for
user data, that needs to

00:13:01.080 --> 00:13:04.010
be a persistent in a way
that's cross platform.

00:13:04.010 --> 00:13:06.760
So if the user is on your
restaurant-searching website,

00:13:06.760 --> 00:13:10.320
and they save a list of
locations, ideally he or she

00:13:10.320 --> 00:13:13.080
would be able to get that list
of locations on their mobile

00:13:13.080 --> 00:13:14.330
device when they're
out and about.

00:13:17.370 --> 00:13:20.290
JEZ FLETCHER: The next key point
is that you should push

00:13:20.290 --> 00:13:23.290
functionality to the server
side where it makes sense.

00:13:23.290 --> 00:13:25.990
If you're doing something that's
common to all of your

00:13:25.990 --> 00:13:28.760
platforms, then it makes sense
to push this logic to the

00:13:28.760 --> 00:13:30.390
server side.

00:13:30.390 --> 00:13:31.920
The advantage of this is
that you only have to

00:13:31.920 --> 00:13:33.200
implement it once.

00:13:33.200 --> 00:13:35.820
You don't have to implement it
multiple times for multiple

00:13:35.820 --> 00:13:38.240
different platforms.

00:13:38.240 --> 00:13:42.280
The other key thing that really
helps it pushing server

00:13:42.280 --> 00:13:43.670
side is if you're
doing anything

00:13:43.670 --> 00:13:45.490
computationally intensive.

00:13:45.490 --> 00:13:49.160
If you're doing, say, some sort
of analysis over a very

00:13:49.160 --> 00:13:52.250
large data set, then this might
take a great deal of

00:13:52.250 --> 00:13:53.230
computing time.

00:13:53.230 --> 00:13:56.460
So it makes sense to leverage
the backend architecture that

00:13:56.460 --> 00:13:59.350
you have at your advantage
rather than putting this to

00:13:59.350 --> 00:14:00.390
the device.

00:14:00.390 --> 00:14:03.140
The other thing is if you're
doing a lot of computation on,

00:14:03.140 --> 00:14:06.380
say, a mobile device, you're
going to really minimize the

00:14:06.380 --> 00:14:07.560
battery life.

00:14:07.560 --> 00:14:09.420
And that's going to
annoy your users.

00:14:09.420 --> 00:14:10.900
ENOCH LAU: And then when you
put all this data on the

00:14:10.900 --> 00:14:12.285
server side, where
do you store it?

00:14:12.285 --> 00:14:13.820
You can store it in Google
Maps Engine.

00:14:13.820 --> 00:14:14.293
JEZ FLETCHER: Oh, yeah.

00:14:14.293 --> 00:14:15.590
That's a really, really
good idea.

00:14:15.590 --> 00:14:19.740
So if you haven't actually had a
play with Google Maps Engine

00:14:19.740 --> 00:14:23.680
yet, you can sign up for an
account at the Maps Sandbox.

00:14:23.680 --> 00:14:25.870
We'll be there afterwards, and
you can come talk to us and

00:14:25.870 --> 00:14:28.070
sign up for an account.

00:14:28.070 --> 00:14:30.120
ENOCH LAU: So if you have a
strong backend infrastructure,

00:14:30.120 --> 00:14:33.350
how do you get your clients
to talk to it?

00:14:33.350 --> 00:14:35.730
And a really key point is that
you should use a shared

00:14:35.730 --> 00:14:37.440
communication format.

00:14:37.440 --> 00:14:39.820
So suppose today you're
only talking in web.

00:14:39.820 --> 00:14:40.980
That's fine.

00:14:40.980 --> 00:14:43.040
But then, if your website
talks to your

00:14:43.040 --> 00:14:44.890
server using JSON--

00:14:44.890 --> 00:14:47.380
JavaScript Object Notation--

00:14:47.380 --> 00:14:49.680
then if you add another client--
let's say you added

00:14:49.680 --> 00:14:51.220
an Android application.

00:14:51.220 --> 00:14:54.980
If that Android application
spoke in the same format,

00:14:54.980 --> 00:14:57.690
JSON, then your server wouldn't
need to be changed.

00:14:57.690 --> 00:15:00.520
The sever would then be agnostic
as the client that is

00:15:00.520 --> 00:15:01.340
talking to it.

00:15:01.340 --> 00:15:03.390
And then, you can add additional
clients with less

00:15:03.390 --> 00:15:06.240
effort if all of these spoke
in the same format.

00:15:06.240 --> 00:15:10.950
And other formats include XML,
GeoJSON, which is a particular

00:15:10.950 --> 00:15:15.730
variant of JSON which is great
for geographic data.

00:15:15.730 --> 00:15:18.240
JEZ FLETCHER: So following on
from that shared communication

00:15:18.240 --> 00:15:21.230
format, if you cleanly separate
your frontend from

00:15:21.230 --> 00:15:24.290
your backend, then you're
going to have a lot less

00:15:24.290 --> 00:15:27.740
trouble with the actual
development.

00:15:27.740 --> 00:15:31.770
A good guide is to put things
only in the application which

00:15:31.770 --> 00:15:33.420
need to be in the application.

00:15:33.420 --> 00:15:35.510
They need to be application
specific for

00:15:35.510 --> 00:15:37.390
that particular platform.

00:15:37.390 --> 00:15:41.670
Then you can push all
of the rest of your

00:15:41.670 --> 00:15:43.840
logic to your backend.

00:15:43.840 --> 00:15:46.870
The advantage of doing this is
that it really makes you think

00:15:46.870 --> 00:15:48.160
about the interface that you're

00:15:48.160 --> 00:15:50.120
exposing to your clients.

00:15:50.120 --> 00:15:53.050
And once you have a nice clean
interface, it's really easy to

00:15:53.050 --> 00:15:55.570
add more clients
in the future.

00:15:55.570 --> 00:15:59.040
So as Enoch said, your server
can be agnostic about the

00:15:59.040 --> 00:16:00.230
clients that it's serving.

00:16:00.230 --> 00:16:03.760
The clients only need to know
about the logic for their

00:16:03.760 --> 00:16:05.860
particular platform, and they
need to know how to

00:16:05.860 --> 00:16:09.870
communicate with the server
on the same interface.

00:16:09.870 --> 00:16:12.400
ENOCH LAU: So now one of
advantage of using Google web

00:16:12.400 --> 00:16:14.060
services is that there
are so many of them.

00:16:14.060 --> 00:16:15.510
You can use Geocoding.

00:16:15.510 --> 00:16:16.600
There's Directions.

00:16:16.600 --> 00:16:19.315
There's Distance Matrix, Places
Search-- a whole slew

00:16:19.315 --> 00:16:20.340
of web services.

00:16:20.340 --> 00:16:20.920
JEZ FLETCHER: Slew.

00:16:20.920 --> 00:16:22.580
Elevation too.

00:16:22.580 --> 00:16:23.990
No one ever mentions
Elevation.

00:16:23.990 --> 00:16:24.140
I love Elevation.

00:16:24.140 --> 00:16:25.300
ENOCH LAU: But there's a
slew of web services.

00:16:25.300 --> 00:16:25.600
JEZ FLETCHER: Slew.

00:16:25.600 --> 00:16:28.600
Stop saying "slew."

00:16:28.600 --> 00:16:30.355
ENOCH LAU: So what you can do
with these web services is you

00:16:30.355 --> 00:16:33.660
can query from the client side,
but you can also query

00:16:33.660 --> 00:16:34.880
them from the server
side as well.

00:16:34.880 --> 00:16:37.250
And here's an example of what
you could do if you have

00:16:37.250 --> 00:16:39.540
strong backend infrastructure
that leverages

00:16:39.540 --> 00:16:41.640
Google's web services.

00:16:41.640 --> 00:16:43.120
So let's say that
you're querying

00:16:43.120 --> 00:16:44.630
Google's geocoding service.

00:16:44.630 --> 00:16:48.030
You're querying the Places
Search service, right?

00:16:48.030 --> 00:16:50.000
And then, you have some
special sauce.

00:16:50.000 --> 00:16:51.980
You have some really interesting
logic that

00:16:51.980 --> 00:16:54.840
combines these two pieces
of information together.

00:16:54.840 --> 00:16:57.240
You can also combine some of
your own data as well.

00:16:57.240 --> 00:17:00.010
And then, your server can
combine it in this interesting

00:17:00.010 --> 00:17:02.260
fashion that you come up and
then send the result back to

00:17:02.260 --> 00:17:03.000
the client.

00:17:03.000 --> 00:17:06.160
And by putting it into the
server, you don't have to

00:17:06.160 --> 00:17:08.550
write it three times for each
of the clients, right?

00:17:08.550 --> 00:17:11.640
And you also improve network
latency, because each of your

00:17:11.640 --> 00:17:14.760
clients, they won't need to
talk to three separate

00:17:14.760 --> 00:17:16.200
backends and then combine
it in the client.

00:17:19.040 --> 00:17:20.490
JEZ FLETCHER: So let's
reiterate some of the

00:17:20.490 --> 00:17:22.630
principles we're talking about
when we're talking about

00:17:22.630 --> 00:17:24.680
backend infrastructure.

00:17:24.680 --> 00:17:27.050
The first is to have this clean
separation from your

00:17:27.050 --> 00:17:28.500
frontend and your backend.

00:17:28.500 --> 00:17:30.380
So everything that needs to be
in the frontend should be in

00:17:30.380 --> 00:17:31.000
the frontend.

00:17:31.000 --> 00:17:32.230
Everything that needs
to be in the backend

00:17:32.230 --> 00:17:33.500
should be in the backend.

00:17:33.500 --> 00:17:37.070
And you should have a clean
interface between the two.

00:17:37.070 --> 00:17:39.120
ENOCH LAU: Your apps should
communicate in the same way,

00:17:39.120 --> 00:17:41.480
so that your backends can be
agnostic and you can add new

00:17:41.480 --> 00:17:43.990
clients easily.

00:17:43.990 --> 00:17:45.620
JEZ FLETCHER: And finally,
you should push

00:17:45.620 --> 00:17:47.440
computationally-intensive
or common

00:17:47.440 --> 00:17:49.190
functionality to the server.

00:17:49.190 --> 00:17:51.490
You only have to implement it
once, and you can leverage all

00:17:51.490 --> 00:17:53.906
of the power of your backends.

00:17:53.906 --> 00:17:55.350
ENOCH LAU: You know, in
the end, everything

00:17:55.350 --> 00:17:56.170
is a balancing act.

00:17:56.170 --> 00:17:57.860
Your case is going to be
special, and you need to think

00:17:57.860 --> 00:17:59.990
about how you're going to
balance these things.

00:17:59.990 --> 00:18:03.840
As this turtle knows, he needs
to think about should he put

00:18:03.840 --> 00:18:05.790
more effort into the frontend
or the backend--

00:18:05.790 --> 00:18:08.120
I say the frontend--

00:18:08.120 --> 00:18:10.260
or he's going to put more
effort in a trade-off--

00:18:10.260 --> 00:18:11.983
JEZ FLETCHER: Did you just come
up with that frontend and

00:18:11.983 --> 00:18:13.290
backend thing?

00:18:13.290 --> 00:18:15.740
ENOCH LAU: Maybe I did.

00:18:15.740 --> 00:18:18.270
Alternatively, he needs to
think about a trade-off

00:18:18.270 --> 00:18:20.630
between effort and
risk and reward.

00:18:20.630 --> 00:18:22.300
I'm sure he wants to put more
effort in, so he doesn't crush

00:18:22.300 --> 00:18:23.742
that little poor
guy down there.

00:18:23.742 --> 00:18:25.990
But everything is
a balancing act.

00:18:25.990 --> 00:18:28.060
JEZ FLETCHER: And with that,
we'd like to invite Jack Kwok

00:18:28.060 --> 00:18:31.490
from Trulia to come up on stage
to discuss Trulia's

00:18:31.490 --> 00:18:34.912
experiences with doing
multi-platform development.

00:18:34.912 --> 00:18:38.349
[APPLAUSE]

00:18:38.349 --> 00:18:39.331
JACK KWOK: Thank you, Jez.

00:18:39.331 --> 00:18:40.581
JEZ FLETCHER: Thanks.

00:18:51.130 --> 00:18:52.380
JACK KWOK: [INAUDIBLE]

00:20:40.770 --> 00:20:42.800
Good afternoon, everyone.

00:20:42.800 --> 00:20:44.400
My name is Jack Kwok.

00:20:44.400 --> 00:20:46.580
I'm the mobile architect
at Trulia.

00:20:46.580 --> 00:20:49.750
At Trulia, we have built over
a dozen native mobile

00:20:49.750 --> 00:20:53.760
applications along with our
website to make it really easy

00:20:53.760 --> 00:20:57.340
for consumers to find
the perfect home.

00:20:57.340 --> 00:21:00.220
Buying a house is a huge
decision, and we have built

00:21:00.220 --> 00:21:05.255
some really great map-enhanced
features to help.

00:21:05.255 --> 00:21:08.730
The homebuying experience
is inherently mobile.

00:21:08.730 --> 00:21:13.310
Today, we have applications
across Android phone, tablets,

00:21:13.310 --> 00:21:16.430
iPhone, iPad, and more.

00:21:16.430 --> 00:21:19.170
Today, I'm going to share with
you some of the techniques and

00:21:19.170 --> 00:21:23.090
principles that we have followed
in building an

00:21:23.090 --> 00:21:26.130
amazing map experience across
different platforms.

00:21:29.480 --> 00:21:33.260
So at Trulia, we understand that
a great user experience

00:21:33.260 --> 00:21:38.330
is key to an awesome app, and
a responsive UI keeps our

00:21:38.330 --> 00:21:39.830
users engaged.

00:21:39.830 --> 00:21:42.570
I'll share a couple of
techniques later on how to

00:21:42.570 --> 00:21:46.250
really speed up the
map interactions.

00:21:46.250 --> 00:21:50.360
Another principle that we have
followed is we design our

00:21:50.360 --> 00:21:53.740
backend API, web service
API, to be completely

00:21:53.740 --> 00:21:55.490
device-agnostic.

00:21:55.490 --> 00:21:58.100
So all our apps speak
the same JSON format

00:21:58.100 --> 00:22:02.360
with our backend services.

00:22:02.360 --> 00:22:05.100
You really want avoid a
situation where you are

00:22:05.100 --> 00:22:10.190
returning specific custom data
based on the device type.

00:22:10.190 --> 00:22:15.040
The reason is with a
device-independent API, it

00:22:15.040 --> 00:22:18.000
really simplifies your
maintenance and testing.

00:22:18.000 --> 00:22:20.690
And even if you're just creating
for one platform

00:22:20.690 --> 00:22:23.720
today, once your app becomes
successful, you'll want to be

00:22:23.720 --> 00:22:27.770
able to scale across different
platforms really quickly.

00:22:27.770 --> 00:22:30.730
So let's see some examples.

00:22:30.730 --> 00:22:34.910
At Trulia, we give you the
inside scoop on what it's like

00:22:34.910 --> 00:22:36.590
to live in a neighborhood.

00:22:36.590 --> 00:22:39.230
What you're looking at
is our Crime Map.

00:22:39.230 --> 00:22:42.180
The red area indicates
area of high crime.

00:22:42.180 --> 00:22:45.350
As you zoom in, more detail
emerges, just

00:22:45.350 --> 00:22:48.080
as you would expect.

00:22:48.080 --> 00:22:52.710
We have brought the Crime Map
experience to the iPad as well

00:22:52.710 --> 00:22:54.225
as on Android phones
and tablets.

00:22:56.760 --> 00:22:58.500
Commuting sucks.

00:22:58.500 --> 00:23:01.940
Nobody wants to be stuck
in a traffic jam.

00:23:01.940 --> 00:23:06.350
Our Commute Map is the
visualization of commute

00:23:06.350 --> 00:23:10.340
times, driving times, as well
as public transit times from

00:23:10.340 --> 00:23:11.960
any location.

00:23:11.960 --> 00:23:15.780
Users simply drag the marker
and drop it at any location

00:23:15.780 --> 00:23:21.140
they want, and a
dynamically-generated heat map

00:23:21.140 --> 00:23:26.150
is generated on the fly and
placed on top of Google Maps.

00:23:26.150 --> 00:23:29.660
We are bringing the same Commute
Map experience to

00:23:29.660 --> 00:23:31.850
Android as well.

00:23:31.850 --> 00:23:38.025
One really cool feature about
the Android Maps SDK is the 3D

00:23:38.025 --> 00:23:41.960
functionalities, so all of the
markers and your custom

00:23:41.960 --> 00:23:47.370
overlays are automatically
transformed 3D with no

00:23:47.370 --> 00:23:51.310
additional work involved from
the developer side, as the

00:23:51.310 --> 00:23:54.870
users tilt and rotate
with gestures.

00:23:54.870 --> 00:23:59.560
So at Trulia, we have data on
over 100 million homes.

00:23:59.560 --> 00:24:04.260
Our data scientists use
machine-learning algorithms to

00:24:04.260 --> 00:24:07.530
create models and visualizations
of home values

00:24:07.530 --> 00:24:08.780
down to the block level.

00:24:11.430 --> 00:24:15.050
So how do all these heat
map tiles work?

00:24:15.050 --> 00:24:19.760
A heat map is implemented in
a tile overlay, and a tile

00:24:19.760 --> 00:24:24.160
overlay is a two-dimensional
grid of tiles.

00:24:24.160 --> 00:24:26.560
On the right, you see that
I've highlighted the

00:24:26.560 --> 00:24:29.330
individual tiles with
a red border.

00:24:29.330 --> 00:24:33.190
And each tile is a square
image, a 256-pixel by

00:24:33.190 --> 00:24:38.670
256-pixel image uniquely
identified by three numbers--

00:24:38.670 --> 00:24:44.220
a zoom level, an x-position, and
a y-position, like the URL

00:24:44.220 --> 00:24:45.470
you see at the bottom.

00:24:49.100 --> 00:24:56.150
So typically, out backend
service would process and

00:24:56.150 --> 00:24:58.730
normalize some external data--

00:24:58.730 --> 00:25:00.880
sometimes in XML format--

00:25:00.880 --> 00:25:05.420
and we would use mapping to
generate the tiles in a

00:25:05.420 --> 00:25:06.780
device-agnostic way.

00:25:06.780 --> 00:25:10.140
In fact, all our devices
and our website use

00:25:10.140 --> 00:25:12.540
the same set of tiles.

00:25:12.540 --> 00:25:16.190
So one thing to keep in mind is
even though you can add in

00:25:16.190 --> 00:25:19.840
the opacity in the browser with
the JavaScript API, on

00:25:19.840 --> 00:25:22.650
Android, there's no efficient
way to do that.

00:25:22.650 --> 00:25:26.270
So when you're generating your
tiles, you probably want to

00:25:26.270 --> 00:25:29.580
bake in the opacity, so that you
can have one set of tiles

00:25:29.580 --> 00:25:35.010
working across all your devices
and your website.

00:25:35.010 --> 00:25:38.890
So on Android, it's pretty
simple to add a tile overlay.

00:25:38.890 --> 00:25:43.990
You simply extend a
URLTileProvider class to let

00:25:43.990 --> 00:25:48.540
the Maps SDK know where to
fetch your custom tiles.

00:25:48.540 --> 00:25:53.940
If you want more customized
ability, like customizing the

00:25:53.940 --> 00:25:56.600
caching behavior, you can
implement the tile provider

00:25:56.600 --> 00:25:59.020
interface yourself.

00:25:59.020 --> 00:26:04.200
And for iOS, if you downloaded
the latest version, which was

00:26:04.200 --> 00:26:08.580
released yesterday, there are
new tile overlay capabilities

00:26:08.580 --> 00:26:12.060
that are very similar
to Android.

00:26:12.060 --> 00:26:15.960
So I really like how Google
Maps takes care of all the

00:26:15.960 --> 00:26:18.710
Mercator projection
math for me.

00:26:18.710 --> 00:26:21.590
It's so simple to add
a tile overlay.

00:26:21.590 --> 00:26:25.820
It takes maybe 20 lines of code
to add it into mobile.

00:26:35.280 --> 00:26:39.240
So the Google Maps SDK for
Android and iOS actually share

00:26:39.240 --> 00:26:44.030
very similar abstractions, like
camera position, ground

00:26:44.030 --> 00:26:48.630
overlay, markers, polyline,
polygons, et cetera.

00:26:48.630 --> 00:26:52.890
So if you're developing for
both iOS and Android, you

00:26:52.890 --> 00:26:57.220
appreciate the consistency of
working with similar classes

00:26:57.220 --> 00:26:59.020
across the platforms.

00:26:59.020 --> 00:27:04.230
One really key thing about
making a great user experience

00:27:04.230 --> 00:27:09.490
with tiles is a really robust
caching strategy.

00:27:09.490 --> 00:27:13.900
At Trulia, we cache the tile
images at three levels--

00:27:13.900 --> 00:27:17.410
at the tile server, at the
content uniform network, and

00:27:17.410 --> 00:27:21.170
finally at the device
local storage.

00:27:21.170 --> 00:27:24.800
So caching is especially
important for tiles that don't

00:27:24.800 --> 00:27:25.670
update regularly.

00:27:25.670 --> 00:27:28.650
So for the crime tiles that I
showed you earlier, they're

00:27:28.650 --> 00:27:30.220
only updated once a month.

00:27:30.220 --> 00:27:35.320
So there's no reason to refetch
the tiles every time

00:27:35.320 --> 00:27:36.400
from your mobile device.

00:27:36.400 --> 00:27:38.200
It would just waste bandwidth.

00:27:42.340 --> 00:27:44.370
So at Trulia, we want
to make search fun.

00:27:44.370 --> 00:27:47.650
We added Draw Search to
the browser first.

00:27:47.650 --> 00:27:50.790
You click the upper right corner
to enable Draw Search,

00:27:50.790 --> 00:27:56.840
and each mouse click on the
map marks a vertex of the

00:27:56.840 --> 00:27:57.660
search polygon.

00:27:57.660 --> 00:28:00.800
And you double click to close
the polygon, and within a

00:28:00.800 --> 00:28:04.150
couple of seconds, you get
some results back.

00:28:04.150 --> 00:28:07.680
On the mobile, the experience
is much more natural.

00:28:07.680 --> 00:28:10.110
You simply draw with
you finger a path

00:28:10.110 --> 00:28:12.240
of the search area.

00:28:12.240 --> 00:28:16.560
So when we first built a
prototype on iPad, we noticed

00:28:16.560 --> 00:28:20.110
it was taking a really long time
for results to come back.

00:28:20.110 --> 00:28:23.300
So after some investigation, we
found that the bottleneck

00:28:23.300 --> 00:28:28.460
was due to the large number of
vertexes collected in the path

00:28:28.460 --> 00:28:31.130
the user traced with the
touch interface.

00:28:31.130 --> 00:28:34.810
So we came up with a solution
by plugging in a polygon

00:28:34.810 --> 00:28:38.310
simplification algorithm, which
is an algorithm that

00:28:38.310 --> 00:28:41.070
reduces the number of vertexes
while at the same time

00:28:41.070 --> 00:28:43.940
preserving the general
shape of the polygon.

00:28:43.940 --> 00:28:48.730
So you think since this is
a mobile-specific issue,

00:28:48.730 --> 00:28:52.616
shouldn't this be implemented
on a device side?

00:28:52.616 --> 00:28:57.290
Well, in fact, it's much more
efficient if we push that into

00:28:57.290 --> 00:28:58.770
the backend.

00:28:58.770 --> 00:29:00.420
And there's a few benefits
to that.

00:29:00.420 --> 00:29:05.115
First, you don't have to write
a code like Java code on

00:29:05.115 --> 00:29:06.930
Android and then port the
same thing writing

00:29:06.930 --> 00:29:10.550
Objective-C on iOS.

00:29:10.550 --> 00:29:15.120
And second, if we needed to
tweak or optimize the

00:29:15.120 --> 00:29:18.240
geospatial algorithm, we just
need to do it in the backend.

00:29:18.240 --> 00:29:20.930
There's no need to
push an update to

00:29:20.930 --> 00:29:23.240
individual app stores.

00:29:23.240 --> 00:29:27.660
And finally, it saves users'
battery life by not doing some

00:29:27.660 --> 00:29:30.060
complicated floating-point
operations on the device.

00:29:39.670 --> 00:29:41.820
So three key takeaways
for today.

00:29:46.340 --> 00:29:48.870
Through all the intensive and
shared functionalities, we

00:29:48.870 --> 00:29:52.410
pushed all of that
into the backend.

00:29:52.410 --> 00:29:55.480
Design a platform-agnostic API
so that you can scale to

00:29:55.480 --> 00:29:58.150
multiple platforms quickly.

00:29:58.150 --> 00:30:03.030
And finally, design a robust
caching strategy for a great

00:30:03.030 --> 00:30:04.280
map experience.

00:30:06.310 --> 00:30:09.960
I hope you have learned a few
techniques today in building

00:30:09.960 --> 00:30:14.360
your own great map experience
on multiple platforms.

00:30:14.360 --> 00:30:19.370
With that, I'd like to invite
back Jez and Enoch back up on

00:30:19.370 --> 00:30:21.420
stage for a Q&amp;A session.

00:30:21.420 --> 00:30:22.950
Thank you.

00:30:22.950 --> 00:30:26.310
[APPLAUSE]

00:30:29.670 --> 00:30:31.390
JEZ FLETCHER: If you do have
questions, please come to the

00:30:31.390 --> 00:30:35.080
microphones, because it's
being recorded.

00:30:35.080 --> 00:30:36.000
Yes.

00:30:36.000 --> 00:30:38.380
AUDIENCE: Quick question
about geofencing.

00:30:38.380 --> 00:30:43.040
Is that available on iOS
and in the JavaScript

00:30:43.040 --> 00:30:45.750
implementations, or is
it strictly Android?

00:30:45.750 --> 00:30:47.580
JEZ FLETCHER: So right now,
it's part of Google Play

00:30:47.580 --> 00:30:50.280
services, which is only
available on Android.

00:30:50.280 --> 00:30:54.620
I don't know of anything similar
for other things.

00:30:54.620 --> 00:30:56.550
iOS has something similar?

00:30:56.550 --> 00:30:57.786
It does not have it.

00:30:57.786 --> 00:30:59.130
AUDIENCE: [INAUDIBLE].

00:30:59.130 --> 00:31:00.650
JEZ FLETCHER: Yes.

00:31:00.650 --> 00:31:02.550
ENOCH LAU: But in addition, you
could use the Tracks API.

00:31:05.670 --> 00:31:07.990
You can analyze the data
afterwards and do something

00:31:07.990 --> 00:31:09.780
similar as well if
you have that.

00:31:09.780 --> 00:31:12.285
AUDIENCE: I guess the second
thing is, the geofence, can

00:31:12.285 --> 00:31:14.200
you tie it to a polygon,
or is it simply a

00:31:14.200 --> 00:31:16.370
point with a radius?

00:31:16.370 --> 00:31:16.880
JEZ FLETCHER: That's
a good question.

00:31:16.880 --> 00:31:18.900
I actually don't know
the answer to that.

00:31:18.900 --> 00:31:21.510
If you come talk to us
afterwards, we can probably

00:31:21.510 --> 00:31:22.880
find someone who knows.

00:31:22.880 --> 00:31:24.130
AUDIENCE: All right, thanks.

00:31:26.100 --> 00:31:27.080
AUDIENCE: Hi.

00:31:27.080 --> 00:31:31.270
I enjoy Maps, as you can tell.

00:31:31.270 --> 00:31:34.940
I'm actually curious about the
new version of Google Maps

00:31:34.940 --> 00:31:38.550
that is now in testing stages.

00:31:38.550 --> 00:31:42.960
Is that going to have another
version of Maps API that we'll

00:31:42.960 --> 00:31:45.800
be expecting to come
down the pipeline?

00:31:45.800 --> 00:31:47.890
JEZ FLETCHER: So we did announce
earlier, after the

00:31:47.890 --> 00:31:52.210
keynote, we've done a visual
refresh of the JavaScript Maps

00:31:52.210 --> 00:31:58.550
API, so it looks similar to the
visual experience you get

00:31:58.550 --> 00:31:59.600
with the new Google Maps.

00:31:59.600 --> 00:32:01.180
ENOCH LAU: Base tiles
are similar.

00:32:01.180 --> 00:32:01.920
JEZ FLETCHER: Base tiles
are similar.

00:32:01.920 --> 00:32:03.360
ENOCH LAU: Controls are
refreshed, that kind of stuff.

00:32:03.360 --> 00:32:05.270
JEZ FLETCHER: Controls are
refreshed, new markers, all of

00:32:05.270 --> 00:32:07.590
this sort of thing.

00:32:07.590 --> 00:32:10.320
In terms of other things, we
don't actually have anything

00:32:10.320 --> 00:32:11.750
to announce at this time.

00:32:11.750 --> 00:32:13.810
AUDIENCE: And would you expect
that there's going to be

00:32:13.810 --> 00:32:14.700
something different?

00:32:14.700 --> 00:32:16.600
Because there's some new events
that occur when you

00:32:16.600 --> 00:32:20.500
have some of the things with
Google Maps that are new, such

00:32:20.500 --> 00:32:22.740
as the streets getting bolded
up to a location that you've

00:32:22.740 --> 00:32:25.190
selected or the slider events.

00:32:25.190 --> 00:32:27.576
Are those events that we might
expect to see occur in a new

00:32:27.576 --> 00:32:27.670
implementation?

00:32:27.670 --> 00:32:30.090
ENOCH LAU: We're really excited
about what is coming

00:32:30.090 --> 00:32:32.305
up in API in the future, but
we don't have anything to

00:32:32.305 --> 00:32:32.900
announce right now.

00:32:32.900 --> 00:32:33.580
AUDIENCE: Gotcha.

00:32:33.580 --> 00:32:36.180
Thanks.

00:32:36.180 --> 00:32:36.970
AUDIENCE: Hi, everyone.

00:32:36.970 --> 00:32:40.680
I'm Ho Ming, and I have
a question for Jack.

00:32:40.680 --> 00:32:45.810
I'm very impressed for the tile
that you overlay on the

00:32:45.810 --> 00:32:47.220
different platforms.

00:32:47.220 --> 00:32:51.400
So I would like to know how do
you generate those tiles at

00:32:51.400 --> 00:32:52.030
different levels?

00:32:52.030 --> 00:32:55.650
Because there will be a very
hard loading, say, if you have

00:32:55.650 --> 00:33:01.460
overlaid the zoom for the whole
San Francisco Bay area

00:33:01.460 --> 00:33:06.430
or just for the tiles for San
Francisco downtown area.

00:33:06.430 --> 00:33:09.680
Then the imprecision
of the tiles

00:33:09.680 --> 00:33:10.680
generally would be different.

00:33:10.680 --> 00:33:15.090
So I would like to know how do
you handle this kind of job in

00:33:15.090 --> 00:33:18.020
order to minimize the bandwidth
or give better

00:33:18.020 --> 00:33:22.030
presentation on your
applications.

00:33:22.030 --> 00:33:23.670
JACK KWOK: So I'm not
sure I understand

00:33:23.670 --> 00:33:24.370
the question correctly.

00:33:24.370 --> 00:33:31.270
Are you asking what it takes to
generate the tiles with a

00:33:31.270 --> 00:33:32.120
lot of coverage?

00:33:32.120 --> 00:33:34.660
AUDIENCE: Yeah, and
the algorithm that

00:33:34.660 --> 00:33:36.170
you use on the backend.

00:33:36.170 --> 00:33:36.380
JACK KWOK: Right.

00:33:36.380 --> 00:33:42.335
I mean the algorithm is really
specific to what heat map you

00:33:42.335 --> 00:33:42.800
are making.

00:33:42.800 --> 00:33:46.180
So for example, for our Crime
Map, we have partners that

00:33:46.180 --> 00:33:52.340
provide us with crime data,
crime reports, and those are

00:33:52.340 --> 00:33:53.940
in XML format.

00:33:53.940 --> 00:34:01.195
And the logic, the algorithm to
make that into a colorful

00:34:01.195 --> 00:34:07.550
heat map, that's really
something that is basically

00:34:07.550 --> 00:34:11.949
really dependent on
what the data.

00:34:11.949 --> 00:34:16.159
So generating a Crime Map is
very different from generating

00:34:16.159 --> 00:34:20.250
a Commute Map or a Home
Evaluation Map.

00:34:20.250 --> 00:34:20.525
AUDIENCE: No, no.

00:34:20.525 --> 00:34:22.199
I'll put it in another way.

00:34:22.199 --> 00:34:27.210
I mean for the precision of
the maps in generating an

00:34:27.210 --> 00:34:27.790
overlay tile.

00:34:27.790 --> 00:34:31.530
Say, for example, if you outline
the whole coastline of

00:34:31.530 --> 00:34:37.159
the United States in a 1 to
1,000 scale would be far

00:34:37.159 --> 00:34:39.820
different from 1 to 2,000,00.

00:34:39.820 --> 00:34:42.469
The scale would be different,
and you

00:34:42.469 --> 00:34:43.380
need different precision.

00:34:43.380 --> 00:34:46.820
Because at the very high level
that you see the whole

00:34:46.820 --> 00:34:49.139
America, you do not need a
very precise coastline,

00:34:49.139 --> 00:34:53.360
because the user won't be able
to tell the difference between

00:34:53.360 --> 00:34:56.260
1-10 vertex or 1-1,000 vertex.

00:34:56.260 --> 00:34:58.940
So I'm asking in this aspect.

00:34:58.940 --> 00:34:59.180
JACK KWOK: Right.

00:34:59.180 --> 00:35:01.340
So the tiles are images.

00:35:01.340 --> 00:35:02.830
They are not polygons.

00:35:02.830 --> 00:35:04.080
There's no vertexes.

00:35:07.800 --> 00:35:12.510
The tile is identified by three
numbers, X, Y, and zoom.

00:35:12.510 --> 00:35:19.400
So when you're zooming further
in, it's actually a fetching a

00:35:19.400 --> 00:35:22.630
new set of tiles with a
different zoom number with

00:35:22.630 --> 00:35:25.600
basically the right
resolution.

00:35:25.600 --> 00:35:32.420
So the farther up you are, the
tiles cover more area.

00:35:32.420 --> 00:35:36.690
When you're zooming way in, like
to the maximum level, a

00:35:36.690 --> 00:35:40.330
tile might be a block or
less than a block.

00:35:40.330 --> 00:35:43.390
But when you're zooming all
the way out a tile is the

00:35:43.390 --> 00:35:45.470
whole Earth.

00:35:45.470 --> 00:35:49.120
So that's basically
how it works.

00:35:51.660 --> 00:35:51.970
AUDIENCE: OK.

00:35:51.970 --> 00:35:53.820
So thanks for your question.

00:35:56.510 --> 00:35:57.760
JEZ FLETCHER: Any
other questions?

00:35:59.740 --> 00:36:02.550
As always, there's a load of
great information on the

00:36:02.550 --> 00:36:05.520
developer site for
Google Maps.

00:36:05.520 --> 00:36:07.106
ENOCH LAU: And we'll be at the
Sandbox for the next 15

00:36:07.106 --> 00:36:09.630
minutes or so as well, so come
and chat to us there.

00:36:09.630 --> 00:36:10.880
JEZ FLETCHER: And thanks
very much.

