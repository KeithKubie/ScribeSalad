WEBVTT
Kind: captions
Language: en

00:00:00.970 --> 00:00:03.880
[MUSIC PLAYING]

00:00:09.250 --> 00:00:10.000
JOANNA SMITH: See?

00:00:10.000 --> 00:00:11.795
It doesn't work.

00:00:11.795 --> 00:00:12.920
COLT MCANLIS: That's weird.

00:00:12.920 --> 00:00:14.060
Well, wait a minute.

00:00:14.060 --> 00:00:16.000
No, those numbers
aren't exactly accurate.

00:00:16.000 --> 00:00:18.010
JOANNA SMITH: No, that
is exactly accurate.

00:00:18.010 --> 00:00:19.410
The bald guy in the
Compressor Head videos

00:00:19.410 --> 00:00:20.700
told me that that
would be accurate

00:00:20.700 --> 00:00:22.283
when he told me to
use variable length

00:00:22.283 --> 00:00:24.050
codes for my
compression, that that

00:00:24.050 --> 00:00:25.840
would give me close
to entropy, but what

00:00:25.840 --> 00:00:26.902
I have here is nonsense.

00:00:26.902 --> 00:00:27.610
COLT MCANLIS: OK.

00:00:27.610 --> 00:00:28.141
Hold on.

00:00:28.141 --> 00:00:28.640
OK.

00:00:28.640 --> 00:00:29.460
So the algorithm's fine.

00:00:29.460 --> 00:00:30.510
JOANNA SMITH: No, the
algorithm's not fine.

00:00:30.510 --> 00:00:30.660
COLT MCANLIS: The date is set.

00:00:30.660 --> 00:00:32.534
JOANNA SMITH: Your job
is to teach algorithms

00:00:32.534 --> 00:00:35.469
and how are you still employed
here because this is bad.

00:00:35.469 --> 00:00:36.260
This is a ignorant.

00:00:36.260 --> 00:00:38.380
David Huffman would be turning
in his grave right now.

00:00:38.380 --> 00:00:40.410
COLT MCANLIS: Ah, but you do
know who David Huffman is.

00:00:40.410 --> 00:00:40.550
See, my job--

00:00:40.550 --> 00:00:41.200
JOANNA SMITH: Oh,
so that's point?

00:00:41.200 --> 00:00:43.950
The point is to learn names
and not to learn compression?

00:00:43.950 --> 00:00:45.210
You're just name dropping now?

00:00:45.210 --> 00:00:46.900
I thought you were going
to teach people algorithms.

00:00:46.900 --> 00:00:48.390
I don't have time for bad ones.

00:00:48.390 --> 00:00:48.680
COLT MCANLIS: OK.

00:00:48.680 --> 00:00:50.429
We're competing with
cats on the internet.

00:00:50.429 --> 00:00:52.390
We don't have the
full amount of time

00:00:52.390 --> 00:00:53.090
to go through the algorithm--

00:00:53.090 --> 00:00:54.450
JOANNA SMITH: To tell the story?

00:00:54.450 --> 00:00:55.033
The punchline?

00:00:55.033 --> 00:00:56.850
The thing that works?

00:00:56.850 --> 00:00:59.230
COLT MCANLIS: We need to get
everything in one little--

00:00:59.230 --> 00:01:00.680
JOANNA SMITH: Everything into
one video that be a complete

00:01:00.680 --> 00:01:02.679
and teach people how to
do things because that's

00:01:02.679 --> 00:01:03.480
your job, to teach.

00:01:03.480 --> 00:01:04.140
Is it not?

00:01:04.140 --> 00:01:04.420
COLT MCANLIS: OK.

00:01:04.420 --> 00:01:06.067
So there's other
parts of the algorithm

00:01:06.067 --> 00:01:07.900
that we didn't get a
chance to do last time.

00:01:07.900 --> 00:01:08.760
JOANNA SMITH: The
people in the camera

00:01:08.760 --> 00:01:10.134
need to know the
whole algorithm.

00:01:10.134 --> 00:01:11.070
You need to tell them.

00:01:11.070 --> 00:01:11.720
Tell them.

00:01:11.720 --> 00:01:12.070
COLT MCANLIS: OK.

00:01:12.070 --> 00:01:12.930
So what do you want me to do?

00:01:12.930 --> 00:01:13.390
JOANNA SMITH: Tell them.

00:01:13.390 --> 00:01:15.360
I want you to go and do
your job and tell them

00:01:15.360 --> 00:01:17.837
exactly how to succeed
with compression.

00:01:17.837 --> 00:01:18.920
COLT MCANLIS: Fair enough.

00:01:18.920 --> 00:01:19.440
So--

00:01:19.440 --> 00:01:19.770
JOANNA SMITH: Oh, wait.

00:01:19.770 --> 00:01:20.270
No.

00:01:20.270 --> 00:01:20.830
Your intro.

00:01:20.830 --> 00:01:22.170
Sorry, one little thing.

00:01:22.170 --> 00:01:25.090
The fear not, young programmers
thing, that's insulting.

00:01:25.090 --> 00:01:26.747
Young programmers aren't afraid.

00:01:26.747 --> 00:01:28.080
COLT MCANLIS: But that's my bit.

00:01:28.080 --> 00:01:28.640
JOANNA SMITH: It's your bit?

00:01:28.640 --> 00:01:29.195
It's wrong.

00:01:29.195 --> 00:01:29.820
It's insulting.

00:01:29.820 --> 00:01:30.490
It's mean.

00:01:30.490 --> 00:01:31.281
COLT MCANLIS: Fine.

00:01:33.780 --> 00:01:36.975
My name Colt McAnlis and
this is Compressor Head.

00:01:36.975 --> 00:01:39.885
[MUSIC PLAYING]

00:01:46.170 --> 00:01:47.890
You know, by now I
think that we've all

00:01:47.890 --> 00:01:51.464
understood that variable length
codes aren't exactly optimal.

00:01:51.464 --> 00:01:52.880
Consider if you
wanted to compress

00:01:52.880 --> 00:01:56.561
all of the books in English
Dictionary, all 26 volumes.

00:01:56.561 --> 00:01:58.185
Sure, we could just
run through, create

00:01:58.185 --> 00:02:00.510
a VLC for the whole thing,
and then compress it,

00:02:00.510 --> 00:02:02.920
but that's just not optimal.

00:02:02.920 --> 00:02:05.650
See, the single tome for
words that start with Q

00:02:05.650 --> 00:02:08.199
would have generally
more Q's in it than any

00:02:08.199 --> 00:02:10.130
of the other tomes combined.

00:02:10.130 --> 00:02:13.830
As such, the efficiency of codes
used for the other books of A

00:02:13.830 --> 00:02:17.850
and Z would be offset by the
abundance of Q's in the tome

00:02:17.850 --> 00:02:18.890
of Q's.

00:02:18.890 --> 00:02:20.350
Sounds like my new band.

00:02:20.350 --> 00:02:22.930
Anyhow, sure you could, with
the right foreknowledge,

00:02:22.930 --> 00:02:24.940
simply compress 26
separate streams,

00:02:24.940 --> 00:02:26.870
but we can't assume
that all data streams

00:02:26.870 --> 00:02:29.110
will be so well behaved.

00:02:29.110 --> 00:02:31.780
What we really need is a
way to encode our data that

00:02:31.780 --> 00:02:35.860
takes locality into account, but
it's almost impossible for us

00:02:35.860 --> 00:02:38.390
to pick those dividing points
given the fact that we're

00:02:38.390 --> 00:02:41.590
taking the whole stream
from a high level view.

00:02:41.590 --> 00:02:44.590
The trick is this, we don't pick
a split point ahead of time.

00:02:44.590 --> 00:02:46.680
Now instead we use
a dynamic method

00:02:46.680 --> 00:02:48.640
of encoding that
let's us know when

00:02:48.640 --> 00:02:50.790
we should be splitting
our stream appropriately.

00:02:50.790 --> 00:02:52.940
And this, my friends,
is the definition

00:02:52.940 --> 00:02:55.130
of adaptive statistical
compression.

00:02:55.130 --> 00:02:58.870
It's a crazy algorithm that lets
your coding stream reset itself

00:02:58.870 --> 00:03:00.770
if things get too out of hand.

00:03:00.770 --> 00:03:02.280
So let's take a look.

00:03:02.280 --> 00:03:03.739
Break.

00:03:03.739 --> 00:03:05.010
Go.

00:03:05.010 --> 00:03:06.730
Now typically there
are three stages

00:03:06.730 --> 00:03:08.642
to a statistical compressor.

00:03:08.642 --> 00:03:10.100
Number one, walk
through the stream

00:03:10.100 --> 00:03:11.500
and calculate probabilities.

00:03:11.500 --> 00:03:13.930
Number two, assign
variable length codes

00:03:13.930 --> 00:03:16.270
to symbols based on
their probability.

00:03:16.270 --> 00:03:19.380
And then number three, walk back
through the stream and output

00:03:19.380 --> 00:03:22.100
the appropriate code
word for each symbol.

00:03:22.100 --> 00:03:23.830
It basically means
you have to do

00:03:23.830 --> 00:03:27.090
two passes through the
stream and have one VLC table

00:03:27.090 --> 00:03:29.220
for the entire set of data.

00:03:29.220 --> 00:03:32.830
Now the adaptive version of
this collapses all three steps

00:03:32.830 --> 00:03:34.330
into a single one.

00:03:34.330 --> 00:03:36.320
The key to that
functionality lies

00:03:36.320 --> 00:03:38.950
in the symbol to code
word table not being

00:03:38.950 --> 00:03:40.620
set in stone as we're encoding.

00:03:40.620 --> 00:03:43.440
Instead it updates itself
as we encounter symbols.

00:03:43.440 --> 00:03:46.350
Basically it works like this.

00:03:46.350 --> 00:03:48.820
Read in a symbol, output
it's variable lengths code,

00:03:48.820 --> 00:03:51.160
and then update the VLC table.

00:03:51.160 --> 00:03:52.980
But this is a little complex.

00:03:52.980 --> 00:03:55.170
Let's try to look at an example.

00:03:55.170 --> 00:03:59.420
Let's say we've got a VLC table
that looks just like this.

00:03:59.420 --> 00:04:01.500
Now let's say we read
in the next symbol

00:04:01.500 --> 00:04:05.070
from our input
stream, which is a B,

00:04:05.070 --> 00:04:11.590
so we would then output the 1
0 value to our output stream.

00:04:11.590 --> 00:04:14.870
And we would need to then go
and update our probabilities.

00:04:19.430 --> 00:04:23.480
The next symbol, again,
is a B. So we once again

00:04:23.480 --> 00:04:27.380
output a 1 0 to
the output stream.

00:04:27.380 --> 00:04:29.720
And we're going to go ahead
and update our probabilities

00:04:29.720 --> 00:04:31.190
one more time.

00:04:31.190 --> 00:04:36.310
So let's see this goes to 40%
here and this goes to 50% here,

00:04:36.310 --> 00:04:38.560
and one doesn't need to be used.

00:04:38.560 --> 00:04:40.180
Now notice what
happened here though.

00:04:40.180 --> 00:04:43.470
Since B suddenly became
the dominant symbol

00:04:43.470 --> 00:04:47.080
it now should have the
shortest code word.

00:04:47.080 --> 00:04:48.460
So this should go to 1 0.

00:04:48.460 --> 00:04:50.260
This should go to 0.

00:04:50.260 --> 00:04:52.430
And this should
stay at 1 1, well,

00:04:52.430 --> 00:04:54.350
we got an extra
sticky out of it.

00:04:54.350 --> 00:04:56.970
So if the next symbol we read
off the line was actually

00:04:56.970 --> 00:05:00.110
a B 0 would be output
to our output stream,

00:05:00.110 --> 00:05:02.530
rather than the 1 0 before.

00:05:02.530 --> 00:05:06.060
This allows our stream to
dynamically update and reassign

00:05:06.060 --> 00:05:10.460
the shortest symbols to the
most probable code words,

00:05:10.460 --> 00:05:13.840
even as the frequencies change
in our encoding process.

00:05:13.840 --> 00:05:18.260
Now the decoder will work
in the opposite form.

00:05:18.260 --> 00:05:20.280
It reads the
variable length code,

00:05:20.280 --> 00:05:23.550
checking each step
against its current table.

00:05:23.550 --> 00:05:27.550
Once it finds what it's
looking for it emits a symbol,

00:05:27.550 --> 00:05:31.710
updates the VLC table,
and then continues on.

00:05:31.710 --> 00:05:33.900
Now let's look at
that in action.

00:05:33.900 --> 00:05:37.890
So we say we've got this
updated VLC table here.

00:05:37.890 --> 00:05:38.690
Let's get of these.

00:05:38.690 --> 00:05:41.550
We don't need those anymore.

00:05:41.550 --> 00:05:46.860
Let's say we've got this VLC
table and we read in a 1 0

00:05:46.860 --> 00:05:48.850
from our stream to decode.

00:05:48.850 --> 00:05:53.230
Of course, this then translates
to emitting a B to our output

00:05:53.230 --> 00:05:53.730
stream.

00:05:53.730 --> 00:05:56.930
And we need to, of course,
update our probability

00:05:56.930 --> 00:05:58.590
since we've seen a new symbol.

00:05:58.590 --> 00:05:59.410
This goes to 40%.

00:05:59.410 --> 00:06:03.630
This goes to 50% and this
goes to 10% once again.

00:06:03.630 --> 00:06:07.500
And once again B actually has
become the most dominant symbol

00:06:07.500 --> 00:06:11.010
and we need to change our
code words accordingly.

00:06:11.010 --> 00:06:12.460
So this should go here.

00:06:12.460 --> 00:06:13.800
This should go here.

00:06:13.800 --> 00:06:15.982
And this should go here.

00:06:15.982 --> 00:06:16.690
And look at that.

00:06:16.690 --> 00:06:19.360
As long as our decoder is
updating its symbol table

00:06:19.360 --> 00:06:21.450
in the same fashion
that the encoder is

00:06:21.450 --> 00:06:23.490
the two will always be in sync.

00:06:23.490 --> 00:06:26.860
This is the basic process of
how adaptive statistical coding

00:06:26.860 --> 00:06:27.430
works.

00:06:27.430 --> 00:06:29.800
The encoder and decoder
are both dynamically

00:06:29.800 --> 00:06:32.220
updating their probability
tables for symbols,

00:06:32.220 --> 00:06:33.790
which affects compression.

00:06:33.790 --> 00:06:36.050
This is a very simple
idea in theory,

00:06:36.050 --> 00:06:39.330
but you need two other
items to make it work right.

00:06:43.515 --> 00:06:45.375
[LAUGHTER]

00:06:45.375 --> 00:06:47.815
JOANNA SMITH: That was unfair.

00:06:47.815 --> 00:06:50.026
[LAUGHTER]

00:06:50.026 --> 00:06:51.400
COLT MCANLIS: But
one caveat here

00:06:51.400 --> 00:06:53.950
is what happens when we
encounter a symbol that we

00:06:53.950 --> 00:06:55.680
haven't seen before.

00:06:55.680 --> 00:06:57.730
There's effectively no
entry in the VLC table

00:06:57.730 --> 00:07:00.670
for us reference so we can't
directly admit a symbol.

00:07:00.670 --> 00:07:04.790
I mean, we could hypothetically
update our table first,

00:07:04.790 --> 00:07:07.910
so then we could output a
1 1 to the output stream,

00:07:07.910 --> 00:07:10.590
but this actually creates
another whole problem

00:07:10.590 --> 00:07:13.610
too because the decoder itself
would get super confused.

00:07:13.610 --> 00:07:15.700
I mean, it would see the
1 1 on the output stream

00:07:15.700 --> 00:07:17.710
and think it's two
B symbols in a row,

00:07:17.710 --> 00:07:21.050
since it hasn't been told
to update the VLC tables.

00:07:21.050 --> 00:07:22.890
So we'd need some way
to signal the decoder

00:07:22.890 --> 00:07:24.740
to add a new symbol
to the stream

00:07:24.740 --> 00:07:26.270
before updating
its table so we can

00:07:26.270 --> 00:07:28.159
stay in sync with the encoder.

00:07:28.159 --> 00:07:30.200
This can be done with the
help of a new code that

00:07:30.200 --> 00:07:32.200
can be admitted to our stream.

00:07:32.200 --> 00:07:33.930
Anytime we encounter
a new symbol

00:07:33.930 --> 00:07:36.230
we output a literal
code to the output,

00:07:36.230 --> 00:07:41.090
followed by the 8-bit
ASCII of our input symbol.

00:07:41.090 --> 00:07:45.090
Only after this point do we
update the stats in our VLC

00:07:45.090 --> 00:07:48.300
table, but the lingering
question is what should we

00:07:48.300 --> 00:07:49.901
use for the value of literal?

00:07:49.901 --> 00:07:52.400
I mean we can't just choose a
random set of bits or anything

00:07:52.400 --> 00:07:54.490
that violates the prefix rule.

00:07:54.490 --> 00:07:57.920
Instead what we have to do
is initialize out VLC table

00:07:57.920 --> 00:08:01.330
with a fake symbol that
represents literal.

00:08:01.330 --> 00:08:03.640
When we encounter a symbol
from the token stream

00:08:03.640 --> 00:08:06.050
that we haven't seen
before we first output

00:08:06.050 --> 00:08:10.120
a VLC for the literal token
followed by the eight bits

00:08:10.120 --> 00:08:11.930
for the new symbol.

00:08:11.930 --> 00:08:14.930
And then just like normal we
have to go through and update

00:08:14.930 --> 00:08:17.230
our table and
probabilities accordingly,

00:08:17.230 --> 00:08:20.705
reducing the probability
of the literal symbol.

00:08:23.320 --> 00:08:26.230
The decoder, when it
sees the literal token,

00:08:26.230 --> 00:08:28.520
will first read in
the next eight bits

00:08:28.520 --> 00:08:31.860
and add the symbol to the table
and update the probabilities

00:08:31.860 --> 00:08:33.150
accordingly.

00:08:33.150 --> 00:08:35.630
Effectively this allows
our encoder and decoder

00:08:35.630 --> 00:08:37.659
to handle adapting
to new symbols

00:08:37.659 --> 00:08:39.130
that they haven't seen before.

00:08:41.731 --> 00:08:42.230
That's good.

00:08:46.060 --> 00:08:48.330
Ow. [BLEEP] dude.

00:08:48.330 --> 00:08:49.910
Now as we've talked
about before,

00:08:49.910 --> 00:08:52.790
as your adaptive stream
adjusts to new symbols that

00:08:52.790 --> 00:08:55.560
are being added to it the
code word lengths will change

00:08:55.560 --> 00:08:57.000
and you'll eventually
hit a point

00:08:57.000 --> 00:08:59.390
where the output
stream is diverging

00:08:59.390 --> 00:09:02.350
from the suggested entropy
by a specific amount.

00:09:02.350 --> 00:09:04.650
For example, let's
take this phrase here.

00:09:04.650 --> 00:09:07.780
As we're encoding it we can
track the suggested entropy

00:09:07.780 --> 00:09:12.090
against the results of an
adaptive VLC implementation.

00:09:12.090 --> 00:09:14.880
Now in order to allow our stream
to effectively split itself

00:09:14.880 --> 00:09:17.360
for better compression
we need to allow

00:09:17.360 --> 00:09:20.530
it to define a point in
which you can reset itself

00:09:20.530 --> 00:09:24.380
so that future sections
can get better encoding.

00:09:24.380 --> 00:09:26.380
Now you can see that
for this example string

00:09:26.380 --> 00:09:29.330
we end up with the encoded
output where each symbol is

00:09:29.330 --> 00:09:32.600
about 1.1 bits larger than
the suggested entropy,

00:09:32.600 --> 00:09:36.510
resulting in a stream that's 26
bits larger than it should be.

00:09:36.510 --> 00:09:39.230
But the truth is that if
we split the string in half

00:09:39.230 --> 00:09:41.130
and encode each one
separately, we'd

00:09:41.130 --> 00:09:44.520
end up with a lower entropy and
smaller encoded output, which

00:09:44.520 --> 00:09:47.910
yields a stream that's only 22
bits larger than the suggested

00:09:47.910 --> 00:09:49.290
entropy stream.

00:09:49.290 --> 00:09:51.450
To do this we employ
the same tactic

00:09:51.450 --> 00:09:54.100
that we had with the literals
and create a reset token

00:09:54.100 --> 00:09:55.580
in our variable table.

00:09:55.580 --> 00:09:57.820
Any time this symbol
exists in the stream

00:09:57.820 --> 00:09:59.920
it signals the
encoder or decoder

00:09:59.920 --> 00:10:03.040
to reset its current VLC
tables and start fresh,

00:10:03.040 --> 00:10:04.816
which is pretty straightforward.

00:10:04.816 --> 00:10:06.440
However, the real
trick then is knowing

00:10:06.440 --> 00:10:09.190
when to emit a reset token.

00:10:09.190 --> 00:10:11.010
See, as we're
outputting code words

00:10:11.010 --> 00:10:13.530
we can keep track of the
suggested entropy of the input

00:10:13.530 --> 00:10:17.180
stream and the actual bits per
symbol of the output stream.

00:10:17.180 --> 00:10:19.360
If the output size
starts diverging

00:10:19.360 --> 00:10:21.170
from entropy by a
significant amount

00:10:21.170 --> 00:10:24.870
we can use this cue to emit
a reset token, at which point

00:10:24.870 --> 00:10:28.850
the stream resets and starts
fresh just like normal.

00:10:28.850 --> 00:10:30.750
Applying this technique
for large streams

00:10:30.750 --> 00:10:32.410
is critical to
ensure that you're

00:10:32.410 --> 00:10:34.659
staying as close as
possible to entropy even

00:10:34.659 --> 00:10:36.200
though the probability
of the symbols

00:10:36.200 --> 00:10:38.630
will change as you process
more symbols on the stream.

00:10:41.520 --> 00:10:43.812
JOANNA SMITH: I mean, this--

00:10:48.460 --> 00:10:49.540
Well, that works.

00:10:49.540 --> 00:10:50.460
COLT MCANLIS: See?

00:10:50.460 --> 00:10:51.050
I told you.

00:10:51.050 --> 00:10:52.790
Listen, it was never
a the algorithm.

00:10:52.790 --> 00:10:54.290
It was all about the data set.

00:10:54.290 --> 00:10:57.670
By taking advantage of
the locality of our data

00:10:57.670 --> 00:11:00.540
we're able to optimize the
tables more efficiently, which

00:11:00.540 --> 00:11:02.581
means that we're going to
get better compression.

00:11:02.581 --> 00:11:05.150
This is the whole point of a
dynamic statistical-- wait.

00:11:05.150 --> 00:11:06.000
Where are you going?

00:11:06.000 --> 00:11:08.440
I mean, we've got to talk
about the dynamic Huffman

00:11:08.440 --> 00:11:09.460
and dynamic arithmetic--

00:11:09.460 --> 00:11:11.700
JOANNA SMITH: Some of
us have real work to do.

00:11:11.700 --> 00:11:12.408
COLT MCANLIS: Oh.

00:11:12.408 --> 00:11:13.867
Well, thanks for stopping by.

00:11:13.867 --> 00:11:15.075
JOANNA SMITH: Grow some hair.

00:11:18.837 --> 00:11:20.420
COLT MCANLIS: My
name is Colt McAnlis.

00:11:20.420 --> 00:11:21.640
Thanks for watching.

00:11:21.640 --> 00:11:24.990
[MUSIC PLAYING]

