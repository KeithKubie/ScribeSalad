WEBVTT
Kind: captions
Language: en

00:00:11.420 --> 00:00:12.240
PROFESSOR: Hi.

00:00:12.240 --> 00:00:14.420
Today I'd like to talk about
signals and systems again.

00:00:14.420 --> 00:00:16.960
At this point, you're probably
familiar with the motivation

00:00:16.960 --> 00:00:19.410
for why we're talking about
discrete linear time and

00:00:19.410 --> 00:00:22.330
variant systems, and also with
a few of the representations

00:00:22.330 --> 00:00:24.800
that we're going to end up
using in this course.

00:00:24.800 --> 00:00:28.190
But you're still not sure what
it is that we're trying to

00:00:28.190 --> 00:00:28.770
accomplish.

00:00:28.770 --> 00:00:31.260
Or where's the part where we
get to predict the future

00:00:31.260 --> 00:00:33.110
based on the fact that
we are capable of

00:00:33.110 --> 00:00:34.990
manipulating these systems?

00:00:34.990 --> 00:00:36.940
Well, we actually have
to be capable of

00:00:36.940 --> 00:00:37.940
manipulating these systems.

00:00:37.940 --> 00:00:40.020
And at this point, we can
describe this system as we see

00:00:40.020 --> 00:00:43.025
it, but we can't also manipulate
its representation

00:00:43.025 --> 00:00:45.380
in ways that make sense to us.

00:00:45.380 --> 00:00:47.420
So the thing that I'm going
to do today is talk about

00:00:47.420 --> 00:00:50.650
different system equivalences
and how to take a system and

00:00:50.650 --> 00:00:53.680
solve for an expression that
represents a complex system

00:00:53.680 --> 00:00:57.200
and also how if you know that
some things in your system are

00:00:57.200 --> 00:01:00.340
equivalent, how you can
convert between them.

00:01:00.340 --> 00:01:02.560
At that point, we should be
able to talk about poles,

00:01:02.560 --> 00:01:04.890
which is how we're going to
actually predict the future.

00:01:04.890 --> 00:01:09.950
So different equivalences that
I'd like to talk about.

00:01:09.950 --> 00:01:12.750
I'm first going to briefly
review the facts that last

00:01:12.750 --> 00:01:17.190
time we discovered the notion
of system function, right?

00:01:17.190 --> 00:01:21.090
We can take a representation
of a system and abstract it

00:01:21.090 --> 00:01:24.750
away into some sort of function,
where we take the

00:01:24.750 --> 00:01:28.410
input as it's given to us and
then multiply it by this

00:01:28.410 --> 00:01:30.510
function and then get
the output that

00:01:30.510 --> 00:01:33.110
we're interested in.

00:01:33.110 --> 00:01:34.470
How do we deal with something
more complex?

00:01:37.120 --> 00:01:38.990
I mean, y is all the
way over here.

00:01:38.990 --> 00:01:40.680
And we've got multiple
system functions.

00:01:40.680 --> 00:01:43.960
And I don't even know what
happens here, but it doesn't

00:01:43.960 --> 00:01:45.090
have to be that scary.

00:01:45.090 --> 00:01:46.340
Let's break it down.

00:01:48.280 --> 00:01:51.630
One of the easiest ways to
approach something like this

00:01:51.630 --> 00:01:55.230
is to identify each position
where you have a new signal,

00:01:55.230 --> 00:01:58.530
or if you were to sample here,
you would have a new signal,

00:01:58.530 --> 00:01:59.980
and label those values
appropriately.

00:02:09.009 --> 00:02:12.210
You can then start with your
final output and then back

00:02:12.210 --> 00:02:14.670
solve for the values that you're
interested in as a

00:02:14.670 --> 00:02:18.090
consequence of that
final output.

00:02:18.090 --> 00:02:23.606
In this particular example, y
is going to be y2 plus y3.

00:02:28.100 --> 00:02:40.820
y2 is going to be y1
times H2, where H2

00:02:40.820 --> 00:02:42.980
is some system function.

00:02:42.980 --> 00:02:46.520
And it probably is abstracting
away some combination of

00:02:46.520 --> 00:02:48.320
gains, delays, and adders
like this one here.

00:02:53.460 --> 00:03:01.944
y1 is going to be x times H1.

00:03:05.402 --> 00:03:09.120
And Y3 is going to
be x times H3.

00:03:20.160 --> 00:03:24.200
Now I've got all my expressions
in terms of either

00:03:24.200 --> 00:03:30.310
y or something for which
I have an equivalent

00:03:30.310 --> 00:03:31.930
expression for x.

00:03:31.930 --> 00:03:35.240
So I can do my substitutions,
come up for an expression for

00:03:35.240 --> 00:03:38.270
y over x, in terms of
H1, H2, and H3.

00:04:18.620 --> 00:04:20.480
Here I've just made the
substitutions of the equations

00:04:20.480 --> 00:04:48.760
above and factored out the x.

00:04:48.760 --> 00:04:50.820
If I wanted the system function,
I would then just

00:04:50.820 --> 00:04:51.620
divide by x.

00:04:51.620 --> 00:04:56.720
And then I would have y over x
is equal to this expression.

00:04:56.720 --> 00:05:01.850
The thing I wanted to indicate
is that if I wanted to

00:05:01.850 --> 00:05:05.320
abstract this away into its own
box-- maybe I wanted like

00:05:05.320 --> 00:05:07.840
a big H or an H0 or something
like that--

00:05:07.840 --> 00:05:12.570
and it represented what was
happening in this top line,

00:05:12.570 --> 00:05:17.170
cascading two system functions
is the functional equivalent

00:05:17.170 --> 00:05:18.600
of multiplying them together.

00:05:18.600 --> 00:05:21.420
So if I have an expression for
H1 and I have an expression

00:05:21.420 --> 00:05:24.590
for H2, and I want the
expression that is equal to

00:05:24.590 --> 00:05:27.430
cascading H1 and H2, I just
multiply them together.

00:05:30.280 --> 00:05:33.200
Likewise, if I want an
expression for the linear

00:05:33.200 --> 00:05:37.080
combination of two system
functions applied to an input

00:05:37.080 --> 00:05:46.580
individually, like the
combination H1 and H2, and H3,

00:05:46.580 --> 00:05:50.990
it's a summation of those
two values which

00:05:50.990 --> 00:05:52.670
is expressed here.

00:05:52.670 --> 00:05:55.670
This is the same as the
relationship that we reviewed

00:05:55.670 --> 00:05:58.080
in a very basic sense when we
were originally doing the

00:05:58.080 --> 00:05:59.910
accumulator.

00:05:59.910 --> 00:06:02.817
The only thing I'm attempting
to indicate is that, that

00:06:02.817 --> 00:06:06.450
relationship scales to an
arbitrary level of complexity.

00:06:06.450 --> 00:06:11.670
So if you need to, you could
shift around these values, if

00:06:11.670 --> 00:06:14.960
you can find some sort
of equivalence.

00:06:14.960 --> 00:06:17.300
Let's see what happens when
H2 is equal to H3.

00:06:22.690 --> 00:06:23.940
I'm going to take my
operator equation.

00:07:03.980 --> 00:07:08.110
What this means is that if I
wanted to rewrite this block

00:07:08.110 --> 00:07:14.450
diagram, I could do
so by doing--

00:07:41.980 --> 00:07:43.760
This is really similar
to bubble pushing.

00:07:43.760 --> 00:07:47.300
If you've done 6.004 or 6.002
and have experience with logic

00:07:47.300 --> 00:07:49.990
gates, I just wanted to indicate
that it's also a

00:07:49.990 --> 00:07:51.220
thing that you can do for block

00:07:51.220 --> 00:07:52.470
diagrams and system functions.

00:08:00.940 --> 00:08:02.450
There's one more type of
equivalence that I want to

00:08:02.450 --> 00:08:03.850
talk about.

00:08:03.850 --> 00:08:05.155
I call it feedback
equivalence.

00:08:09.300 --> 00:08:10.820
Here's our normal accumulator
rate.

00:08:20.700 --> 00:08:24.190
If I wanted to represent this
feedback system as a feed

00:08:24.190 --> 00:08:26.440
forward system, what
would I have to do?

00:08:29.310 --> 00:08:33.080
Well, the first time that
I sampled from x, it

00:08:33.080 --> 00:08:35.390
would just be y.

00:08:35.390 --> 00:08:38.620
So right now this diagram
matches for

00:08:38.620 --> 00:08:39.919
the first time step.

00:08:39.919 --> 00:08:45.230
On the second time step, if I
had an input from x from the

00:08:45.230 --> 00:08:50.060
previous time step, I would also
want to account for it by

00:08:50.060 --> 00:08:55.800
putting in a delay and then
summing it with the current

00:08:55.800 --> 00:09:01.110
value of x in order to get y.

00:09:01.110 --> 00:09:08.660
At the second time step, I
would want access to the

00:09:08.660 --> 00:09:18.660
starting value, the value from
the previous time step, and

00:09:18.660 --> 00:09:22.150
the value from the current
time step.

00:09:22.150 --> 00:09:26.260
And one more time, to exhaust
the example, at the third time

00:09:26.260 --> 00:09:45.680
step, my output would be a
linear combination of the

00:09:45.680 --> 00:09:49.520
starting value, the value from
the first time step, the value

00:09:49.520 --> 00:09:53.950
from the second time step, and
the value from the current

00:09:53.950 --> 00:09:55.200
third time step.

00:10:05.750 --> 00:10:09.030
We'd end up doing this
ad nauseum to model

00:10:09.030 --> 00:10:11.930
our feedback system.

00:10:11.930 --> 00:10:17.230
So it's difficult to do on
paper, but it turns out

00:10:17.230 --> 00:10:21.190
there's a great relationship
between these two equivalences

00:10:21.190 --> 00:10:22.605
and things that we already
know from--

00:10:25.400 --> 00:10:26.690
I want to say high school
calculus or

00:10:26.690 --> 00:10:30.370
possibly 18.01, 18.02.

00:10:30.370 --> 00:10:31.620
Geometric sequences.

00:10:35.500 --> 00:10:38.210
When we solved for the system
function, we found an

00:10:38.210 --> 00:10:44.120
expression for our
feedback system.

00:10:52.570 --> 00:10:54.960
If I wanted to find an
equivalent expression using

00:10:54.960 --> 00:10:59.400
this feed forward system, I
would look at this infinite

00:10:59.400 --> 00:11:06.130
summation of x terms.

00:11:18.170 --> 00:11:21.290
So if I wanted to know something
about the long-term

00:11:21.290 --> 00:11:26.710
behavior of the system, in terms
of this system function,

00:11:26.710 --> 00:11:30.810
I would solve for this
expression and then using my

00:11:30.810 --> 00:11:39.475
knowledge of geometric
sequences, in order to express

00:11:39.475 --> 00:11:41.790
the long-term behavior.

00:11:41.790 --> 00:11:44.690
In the general sense, in this
course, we're going to be

00:11:44.690 --> 00:11:47.450
looking at the unit sample
response of a system.

00:11:50.360 --> 00:12:11.710
What that means is, if the only
thing I ever do for input

00:12:11.710 --> 00:12:22.930
is a single value of 1 at
time 0, then what does

00:12:22.930 --> 00:12:25.650
my output look like?

00:12:25.650 --> 00:12:27.510
The reason we're looking at the
unit sample response is

00:12:27.510 --> 00:12:30.540
because it's (a) the simplest
way to look at the long-term

00:12:30.540 --> 00:12:33.990
behavior of a discrete linear
time invariant system.

00:12:33.990 --> 00:12:37.220
But the other reason (b) is --
once we have this, we can also

00:12:37.220 --> 00:12:39.970
use it to do things like to
make predictions about the

00:12:39.970 --> 00:12:44.300
long-term step response
and other more

00:12:44.300 --> 00:12:45.710
complicated input signals.

00:12:49.650 --> 00:12:54.280
In the case of the accumulator,
if I input 1 at

00:12:54.280 --> 00:13:08.140
time 0, my output is going
to be 1 forever more.

00:13:18.130 --> 00:13:28.050
That's reflected in
the coefficient of

00:13:28.050 --> 00:13:29.300
my geometric sequence.

00:13:31.800 --> 00:13:35.940
If I want to know what my
long-term response is going to

00:13:35.940 --> 00:13:41.690
look like, I can look at the
coefficient of R and make a

00:13:41.690 --> 00:13:45.630
decision about whether or not
I'm going to diverge or

00:13:45.630 --> 00:13:46.970
converge or do neither.

00:13:50.070 --> 00:14:47.460
So if I put a coefficient on R,
whatever p0 converges to is

00:14:47.460 --> 00:14:51.510
what my system is going
to converge to.

00:14:51.510 --> 00:14:55.510
So using my knowledge of p0, I
can make long-term predictions

00:14:55.510 --> 00:14:58.920
about the behavior
of the system.

00:14:58.920 --> 00:15:01.440
Next time I'm going to go over
some general classifications

00:15:01.440 --> 00:15:04.180
of those behaviors for the
system and how to more

00:15:04.180 --> 00:15:07.040
effectively use our knowledge
of p0 and how to deal with

00:15:07.040 --> 00:15:08.290
things like second
order systems.

