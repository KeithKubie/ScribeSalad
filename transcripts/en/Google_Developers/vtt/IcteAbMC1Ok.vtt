WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:04.130
&gt;&gt; PARLANTE: So, I just want to make a couple
sort of concluding remarks and say, tell you

00:00:04.130 --> 00:00:06.970
some stuff about Python. I want to show you
like, one more Python feature I've been kind

00:00:06.970 --> 00:00:10.630
of holding back on and then we'll let you
go to--go back coding or go have some more

00:00:10.630 --> 00:00:14.950
free food. So, the first thing I'm going to
do--oh, I just have to establish the point

00:00:14.950 --> 00:00:19.880
of order. All right, so, what does readable
code mean? Let's think about that. It's like,

00:00:19.880 --> 00:00:23.830
well, I would say it's code that if someone
who didn't write it, they kind of look down

00:00:23.830 --> 00:00:28.830
at the printout and they think for like a--they
can kind of see what it does. And I'm willing

00:00:28.830 --> 00:00:33.320
to pause; we'd agree that readable code, that's
a good thing. All right, we like code that

00:00:33.320 --> 00:00:36.260
you can read. All right, so I'm just going
to table that, I'm going to put that on the

00:00:36.260 --> 00:00:41.089
side for use later into this discussion. All
right, so I want to show you this feature.

00:00:41.089 --> 00:00:44.549
This is a feature I kind of thought about
showing you. But there was just so much going

00:00:44.549 --> 00:00:48.120
on. This was just one feature too many for
our discussion. But this is something that

00:00:48.120 --> 00:00:54.209
you're now ready to use. So, we've done a
lot of stuff with lists. So, I'm going to

00:00:54.209 --> 00:01:01.960
set up a list here. I'll have like, you know,
"aaaa", "bb" and "ccccc", that's it. All right,

00:01:01.960 --> 00:01:08.600
there's a list of strings. And suppose I wanted
to have a list of their lengths. We've seen

00:01:08.600 --> 00:01:14.130
how--I could've said, "Well, you know, result,
the sequel to the empty list." Then I could've--you

00:01:14.130 --> 00:01:18.822
know, I looped through list A and added stuff
to the result list like. And you know what?

00:01:18.822 --> 00:01:25.780
That is a fine technique. But Python has a
feature called a list comprehension that is

00:01:25.780 --> 00:01:31.130
a syntax for just making lists with a very
kind of compact syntax and just making them

00:01:31.130 --> 00:01:35.480
in one step. And so, I want to show you the
list comprehension syntax. And so my--the

00:01:35.480 --> 00:01:38.759
problem--my first problem will be like, oh,
what if I want to make a list? Link three

00:01:38.759 --> 00:01:43.539
of the lengths of those strings, so, kind
of parallels the list of strings. So, the

00:01:43.539 --> 00:01:48.390
list comprehension syntax is like--I'm not
sure what adjective describes it and so on.

00:01:48.390 --> 00:01:51.200
But anyway, here's the way I do it. So the
list comprehension syntax, what you start

00:01:51.200 --> 00:01:56.889
off is you write a set of square brackets
and then you're going to put code inside of

00:01:56.889 --> 00:02:00.450
there to represent the list that you want
to compute. This is the way I do it, so I

00:02:00.450 --> 00:02:04.130
type the square brackets and I go into the
middle here. And then it--the list comprehension

00:02:04.130 --> 00:02:08.050
syntax, it reuses as much of the existing
syntax as possible. So, the ones--the existing

00:02:08.050 --> 00:02:17.760
syntax we know is the "for" loop. So, I say--oops.
I say, "for s in a." all right, for each string

00:02:17.760 --> 00:02:23.890
inside of there and then, for the list comprehension
syntax. Then on the left hand side, you put

00:02:23.890 --> 00:02:29.040
the value that it would like to use. What
function would you like it to run on each

00:02:29.040 --> 00:02:34.470
s in this case? So, I'm going to say, "Oh,
yeah, what's len(s) for s in a?" And if I

00:02:34.470 --> 00:02:42.120
just hit return there, that just-- in one
step, just makes the new list. So, if you

00:02:42.120 --> 00:02:45.331
wanted to have--you have a kind of a list
of one sort, this is a--in a list, you would

00:02:45.331 --> 00:02:49.750
call this a mapcar. If you have a list of
one sort and you want to kind of transform

00:02:49.750 --> 00:02:53.540
it to a list of another sort, then this is
exactly what the list of comprehension does.

00:02:53.540 --> 00:02:57.000
Now, let me show you another example. I'll
show you another feature it has. So, if I'll--let's

00:02:57.000 --> 00:03:04.420
say I have a list with, you know, one, two,
three, four here. Oops. All right, and now

00:03:04.420 --> 00:03:10.610
I'll write a comprehension. I'll say, "for
num in a." And let's say I wanted to do squares,

00:03:10.610 --> 00:03:17.610
so I could say, "Oh, num times num for num
in a." So, I could just make the squares that

00:03:17.610 --> 00:03:22.970
way. You can also add an "if" statement on
this if you want to kind of do--what you would

00:03:22.970 --> 00:03:27.020
maybe call a filter operation. So I could
say, "Well, I want num times num for num in

00:03:27.020 --> 00:03:35.409
a, if I don't know, num is greater than two."
And so now, this kind of runs over the list

00:03:35.409 --> 00:03:39.599
and you're sort of slicing off some elements
and then computing this thing for it. So let

00:03:39.599 --> 00:03:44.989
me--I'll show you just a last example. Let's
see, what directory am I in here? Oh, good.

00:03:44.989 --> 00:03:48.969
Oh right, I'm in the copy special directory.
So, as the last example, we have that, you

00:03:48.969 --> 00:03:56.890
know, import os. So we have that "os.listdir"
thing, right? I'll say "listdir(".")". All

00:03:56.890 --> 00:04:04.530
right, so there's that list there. I'm just
going to--can we just write a comprehension

00:04:04.530 --> 00:04:09.109
to just make the list of special files all
in one step? And I'm kind of pushing the envelope

00:04:09.109 --> 00:04:14.230
a little bit here. So, I'm going to say, "import
re." So here, I'll do the square braces. So

00:04:14.230 --> 00:04:22.290
I want to say, "For f," I'll say, you know,
for the--this is the filename--"for f in os.listdir(".")"

00:04:22.290 --> 00:04:31.940
Okay, so now I want to say--I just want "f",
so it's "f for f in os." And then I want to

00:04:31.940 --> 00:04:37.730
add an "if" statement here, right? I want
to say, "if re.search." And what was it? Like

00:04:37.730 --> 00:04:49.520
"r"__\w+"..." This isn't cryptic at all. I
think that--so, let's just try it. Now, check

00:04:49.520 --> 00:04:55.350
it out. So, there's a bunch of things kind
of getting compacted in there, right? I mean,

00:04:55.350 --> 00:05:02.761
there's the search [INDISTINCT]. Okay, so
for small problems, the list comprehension

00:05:02.761 --> 00:05:06.510
is very attractive. And it feels like you
have this idea in your mind--it's always nice

00:05:06.510 --> 00:05:10.790
if you have your--an idea in your mind, and
then the amount of code to kind of express

00:05:10.790 --> 00:05:14.040
that idea is small. You didn't feel like you
needed to add all this extra barricades and

00:05:14.040 --> 00:05:17.510
stuff to kind of like get your idea out there.
And list comprehensions definitely have that

00:05:17.510 --> 00:05:21.100
feeling. Although I think the syntax is a
little foreign at first. I mean, but you know,

00:05:21.100 --> 00:05:23.780
pretty, you get kind a little bit uncomfortable
typing out. And then the mnemonic for what

00:05:23.780 --> 00:05:28.900
it's worth is that it reuses the "for" loop
and the "if" statement as they exist and sort

00:05:28.900 --> 00:05:32.400
of just puts them in a square bracket. That's
kind of the way to remember it, except for

00:05:32.400 --> 00:05:35.920
the thing about the expression on the left
that you just have to commit some brain cells

00:05:35.920 --> 00:05:40.130
to remember that one. All right, so list comprehension
is very attractive and you know, according

00:05:40.130 --> 00:05:44.120
to the Google style guide, we would be very
happy to use these as so long as they're one

00:05:44.120 --> 00:05:50.870
or two lines long. And now, I have to give
you this warning, this surgeon general required

00:05:50.870 --> 00:05:56.100
warning whenever you are showing someone the
list comprehension. And the warning goes as

00:05:56.100 --> 00:06:03.190
follows. There is this form of madness that
can take over a programmer. And the madness

00:06:03.190 --> 00:06:09.710
is of this form. You had a program and it
was like 100 lines long, and your officemate,

00:06:09.710 --> 00:06:13.790
you know, used a bunch of macros and weird
features that no normal person ever uses and

00:06:13.790 --> 00:06:18.300
they got it down to like 80 lines. And you
saw what they did and you're like, "Oh, that's

00:06:18.300 --> 00:06:21.720
nothing." And you like, use more and more
esoteric features or whatever kind of stuff

00:06:21.720 --> 00:06:24.950
and you sort of get it down to like three
lines. You know, it's just like unbelievable.

00:06:24.950 --> 00:06:29.270
Like and it is so satisfying. I mean, it is
actually very satisfying to feel like your

00:06:29.270 --> 00:06:32.620
cleverness is being--just totally working
and wow, you have this thing like completely

00:06:32.620 --> 00:06:38.240
condensed. So, the problem is that it's a
path, it like, pulls you on a path. But in

00:06:38.240 --> 00:06:43.670
reality, what you've created is completely
unreal, right? It is not that someone could

00:06:43.670 --> 00:06:49.320
look at that and say "What does that do?"
So, the list comprehension, I mean, it's like--it's

00:06:49.320 --> 00:06:55.730
like that scenario I described is a risk factor.
So, the list comprehension is great for like

00:06:55.730 --> 00:06:59.160
a couple lines long. But what you can do is
you can nest them. You can have an inter-list

00:06:59.160 --> 00:07:02.160
comprehension that does something and then
that's nested inside of another one, inside

00:07:02.160 --> 00:07:05.090
of another one. You can sort of take your
entire program and just have it be like this

00:07:05.090 --> 00:07:09.740
nested list comprehension. But I would definitely
recommend that you not do that. Or as I would

00:07:09.740 --> 00:07:14.200
say, it's kind of like with great power comes
great responsibility. So, this is a very nice

00:07:14.200 --> 00:07:19.820
feature. If you feel like it's still readable
and sensible but just like, you know, don't

00:07:19.820 --> 00:07:22.470
go out of control. Yeah, question?
&gt;&gt; Is it faster?

00:07:22.470 --> 00:07:26.050
&gt;&gt; PARLANTE: Is it faster? I don't think it's
really, really faster, not--not especially.

00:07:26.050 --> 00:07:30.560
I mean, the trick is you figure that "for"
loop like the "for" whatever append. That

00:07:30.560 --> 00:07:34.490
is a highly optimized case. That's a super,
super common thing to do in Python. So, I

00:07:34.490 --> 00:07:39.490
think these are both low optimized. I don't
think slower either. I mean, I guess maybe

00:07:39.490 --> 00:07:44.660
it has some slight advantages, but I don't
think it would be significantly faster. Great,

00:07:44.660 --> 00:07:48.960
so, I just wanted to show you that, it's just
kind of for fun. The other thing I'll mention

00:07:48.960 --> 00:07:52.900
is that--well, I just want to talk about,
you know, Python and you, what does this mean

00:07:52.900 --> 00:07:56.770
a little bit. So, Python is actually a pretty
popular language and its popularity seems

00:07:56.770 --> 00:07:59.830
to have gone up a lot in recent years. And
I think, certainly in this class, you've gotten

00:07:59.830 --> 00:08:04.420
kind of a feel of--in a sense, I've tried
to give you assignments or projects where

00:08:04.420 --> 00:08:08.550
Python looks pretty good, right? So, Python
has--it has the nice--the list is nice, the

00:08:08.550 --> 00:08:11.930
string is nice, the dictionary--so anything
where you're kind of pulling in data and using

00:08:11.930 --> 00:08:14.461
those things where Python is good, those are
going to work pretty well. I think that's

00:08:14.461 --> 00:08:19.000
one area of strength. Also, syntactically,
it's pretty short. I think that may you know,

00:08:19.000 --> 00:08:22.340
you're not typing a lot extra stuff, and so
that makes it attractive for small problems.

00:08:22.340 --> 00:08:27.710
And then finally, like a lot of other languages,
I think Python--you benefit from the urllib

00:08:27.710 --> 00:08:31.050
and records, you know, all those kind of modules
that are sort of out there that you can build

00:08:31.050 --> 00:08:35.579
on top of them. And so, yeah, out in the real
world, if you look at scientists or universities

00:08:35.579 --> 00:08:39.409
or companies or whatever, yeah, a lot of people
find Python to be like a really nice fit for

00:08:39.409 --> 00:08:41.909
problems they actually have, and so, I'm sure
it gets used a lot. And certainly with Google,

00:08:41.909 --> 00:08:49.149
it gets used for like, all sorts of stuff.
And I think, I will speculate that, you know,

00:08:49.149 --> 00:08:53.820
probably the amount of languages like Python
or JavaScript or Java or whatever is just

00:08:53.820 --> 00:08:58.310
gradually on the way up in Google as they
save programmer time and they use a little

00:08:58.310 --> 00:09:01.899
more memory, a little CPU, but you know, ultimately,
programmer time is something that we, is extremely

00:09:01.899 --> 00:09:06.120
expensive and rare. And so, you know, something
that allows us to save programmer time is

00:09:06.120 --> 00:09:10.420
a little bit attractive. So, what I would
say--and so, I'd have to give you one warning,

00:09:10.420 --> 00:09:15.639
so Python is in fact a large language. If
you really looked at all the features that

00:09:15.639 --> 00:09:19.670
this language has, there's a lot to it. And
we have not, we have not covered all those

00:09:19.670 --> 00:09:25.990
things. That--just study. The good news is
you have absolutely seen the core of the language,

00:09:25.990 --> 00:09:29.860
like the very common, straight ahead, normal
features that you would want to use to solve

00:09:29.860 --> 00:09:32.711
a lot of problems, you have seen them. And
in fact, you've written projects that use

00:09:32.711 --> 00:09:36.890
a lot of them. So, I would say from here on
out, you should be very comfortable if you

00:09:36.890 --> 00:09:40.810
are--want to read a Python book or go some
Python talk at Google or whatever, like, yeah,

00:09:40.810 --> 00:09:44.290
you've definitely seen the basic core stuff.
And so, I think you're--well, you know, well-set-up

00:09:44.290 --> 00:09:48.399
to kind of go from here and sort of learn
more Python if you want. And my last piece

00:09:48.399 --> 00:09:53.980
of advice about that is that I found I--the
way you learn this stuff is by writing code,

00:09:53.980 --> 00:09:56.870
right? I mean, you can watch talks, but really,
it's about in coding. And certainly in this

00:09:56.870 --> 00:10:00.310
class, you know, hopefully write--somebody
is solving these problems, you learn something.

00:10:00.310 --> 00:10:05.689
And so, for myself, or say for example, within
Google, I--my Python stuff got stronger when

00:10:05.689 --> 00:10:10.209
I started forcing myself to solve things in
Python. And so, the first offender there was

00:10:10.209 --> 00:10:15.459
really Bash. So, things that I might've solved
as a shell script and especially--I think

00:10:15.459 --> 00:10:19.220
Bash works well if you're just calling programs
and just sort of dumping their output to text

00:10:19.220 --> 00:10:22.319
files, I go to that--that's fine. Or like,
I can write a correct Bash script so long

00:10:22.319 --> 00:10:26.339
as it has, at most, one "if" statement in
it. It's like I can sort of get that right.

00:10:26.339 --> 00:10:30.451
But if you find yourself in Bash like reeling
the data in and sorting it and uniqueing it

00:10:30.451 --> 00:10:34.890
and cutting it into tabs and all, it's sort
of doing data processing in Bash, then I think

00:10:34.890 --> 00:10:38.639
Python maybe looks pretty good. But if what
you could do is instead call the program from

00:10:38.639 --> 00:10:43.620
Python but pull the data into Python for processing.
So you can use regular expressions, and [INDISTINCT],

00:10:43.620 --> 00:10:48.759
all that kind of stuff. So I think that, as
a first next step for Python programming.

00:10:48.759 --> 00:10:51.470
I think that's a good thing considering, you
know, definitely Python gets used in Google

00:10:51.470 --> 00:10:56.880
a lot. All right, so that concludes--that's
the extent of the Python teaching we're going

00:10:56.880 --> 00:11:00.129
to have today. So, thanks so much for your
attention, and I'm happy to stay longer if

00:11:00.129 --> 00:11:05.899
you want to work on the projects and good
luck with Python in the future. All right,

00:11:05.899 --> 00:11:07.480
thank you. Thank you.

