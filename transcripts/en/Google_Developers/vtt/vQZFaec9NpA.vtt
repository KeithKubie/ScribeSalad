WEBVTT
Kind: captions
Language: en

00:00:06.150 --> 00:00:09.300
&gt;&gt;Chet Haase: So just a reminder this talk
is being live streamed so if you would like

00:00:09.300 --> 00:00:13.920
to catch Glenn and Rafe's excellent performance
you can go to that one and then watch ours

00:00:13.920 --> 00:00:16.730
at the same time.

00:00:16.730 --> 00:00:25.070
Last year we gave a talk where we introduced
Android Jelly Bean 4.1, and 4.2 came out soon

00:00:25.070 --> 00:00:26.310
after that.

00:00:26.310 --> 00:00:30.890
And today we would like to announce --
&gt;&gt;Romain Guy: Graphics and performance.

00:00:30.890 --> 00:00:33.850
[ Laughter ]
&gt;&gt;Romain Guy: The joke would have worked a

00:00:33.850 --> 00:00:38.720
lot better, but for some reason for the live
stream we have to show the title slide first

00:00:38.720 --> 00:00:40.040
so we have to go back.

00:00:40.040 --> 00:00:44.450
Hi, I'm Romain Guy and this is Chet Haase
and we both work on the Android framework

00:00:44.450 --> 00:00:50.610
team and we both work on graphics, performance
and animations.

00:00:50.610 --> 00:00:53.100
So this talk is divided into three, sections.

00:00:53.100 --> 00:00:57.400
First we'll talk about architecture and -- I'll
get back to this.

00:00:57.400 --> 00:01:01.680
Then we'll talk about tools and finally we'll
give you some tips and tricks on how to improve

00:01:01.680 --> 00:01:03.580
performance on your applications.

00:01:03.580 --> 00:01:08.430
The architecture section is interesting because
for the first time I think ever we're going

00:01:08.430 --> 00:01:10.940
to talk about stuff that doesn't exist yet.

00:01:10.940 --> 00:01:13.890
We're going to talk about stuff that's coming.

00:01:13.890 --> 00:01:15.660
So --
&gt;&gt;Chet Haase: It's a really good way for us

00:01:15.660 --> 00:01:19.680
not to be here next year to give any talk
to you on behalf of Google, but we're going

00:01:19.680 --> 00:01:20.680
to try it anyway.

00:01:20.680 --> 00:01:22.970
&gt;&gt;Romain Guy: That doesn't mean it's going
to come out this year or next year.

00:01:22.970 --> 00:01:26.720
We can't tell you when, we can't tell you
how and we can't tell you what version number,

00:01:26.720 --> 00:01:27.720
what name.

00:01:27.720 --> 00:01:29.570
It's just coming sometime in the future.

00:01:29.570 --> 00:01:31.040
&gt;&gt;Chet Haase: Maybe.

00:01:31.040 --> 00:01:32.520
&gt;&gt;Romain Guy: Hopefully.

00:01:32.520 --> 00:01:36.740
&gt;&gt;Chet Haase: So first of all, one of the
architectural changes that we have implemented

00:01:36.740 --> 00:01:40.870
in this fictional future release is reordering
and merging.

00:01:40.870 --> 00:01:45.790
If you recall last year if you happened to
be in a session called for better or worse,

00:01:45.790 --> 00:01:49.810
we gave a really confusing diagram of what's
actually going on in the rendering engine,

00:01:49.810 --> 00:01:53.979
and it bottoms out in something we call display
list which is basically our intermediate mode

00:01:53.979 --> 00:01:57.100
of the commands that we're going to send down
to the GPU.

00:01:57.100 --> 00:02:01.710
Then we compose OpenGL commands out of that
and send them on down and they get rendered,

00:02:01.710 --> 00:02:02.710
hardware, acceleration.

00:02:02.710 --> 00:02:03.710
Life is good.

00:02:03.710 --> 00:02:10.200
What we have done recently is implemented
some changes so that we can actually re-order

00:02:10.200 --> 00:02:14.769
and merge commands to make it more optimal
the way that we actually talk to the GPU.

00:02:14.769 --> 00:02:19.569
We have in previous talks and in articles
recommended a tip where you should batch your

00:02:19.569 --> 00:02:20.569
commands.

00:02:20.569 --> 00:02:23.780
So if you're doing a bunch of -- like I'm
going to draw a bitmap, I'm going to draw

00:02:23.780 --> 00:02:28.150
some text, I'm going to draw a bitmap, draw
some text, it's better for us and for the

00:02:28.150 --> 00:02:32.540
GPU if you draw all the bitmaps at once and
all the text at once.

00:02:32.540 --> 00:02:37.790
We've tried to remove that from you and just
do it more automatically.

00:02:37.790 --> 00:02:41.180
In fact, it turns out that we can actually
do even better than that.

00:02:41.180 --> 00:02:43.760
&gt;&gt;Romain Guy: For once we're making your life
easier instead of harder.

00:02:43.760 --> 00:02:45.439
&gt;&gt;Chet Haase: I don't know how that happened.

00:02:45.439 --> 00:02:46.640
&gt;&gt;Romain Guy: It is not even an API.

00:02:46.640 --> 00:02:47.640
It's all automatic.

00:02:47.640 --> 00:02:51.620
&gt;&gt;Chet Haase: So let's pretend that this is
a sample UI, a very boring sample UI, but

00:02:51.620 --> 00:02:53.080
an sample UI nonetheless.

00:02:53.080 --> 00:02:55.500
We have a couple of chat boxes, each one with
some text.

00:02:55.500 --> 00:02:56.549
We have a couple of buttons.

00:02:56.549 --> 00:02:59.620
Let's pretend the order that we see it on
the screen is the order in which they're added

00:02:59.620 --> 00:03:04.159
to the containers, so they're basically going
to draw it in this order.

00:03:04.159 --> 00:03:07.099
So we're going to -- there's the order.

00:03:07.099 --> 00:03:11.150
We're going to draw the check boxes, so we
draw a bitmap with the checked check box,

00:03:11.150 --> 00:03:12.410
and then we're going to draw --
&gt;&gt;Romain Guy: [ Inaudible ]

00:03:12.410 --> 00:03:15.580
&gt;&gt;Chet Haase: That animation was so awesome
we're going to do it again.

00:03:15.580 --> 00:03:17.810
[ Laughter ]
&gt;&gt;Chet Haase: Draw a bitmap, we're going to

00:03:17.810 --> 00:03:22.439
draw some text, we're going to draw a bitmap,
draw some text, we're going to draw a nine

00:03:22.439 --> 00:03:23.569
patch and draw some text.

00:03:23.569 --> 00:03:27.969
Eight commands, not a lot to worry about,
but let's see what happens when we can actually

00:03:27.969 --> 00:03:29.419
re-order these things.

00:03:29.419 --> 00:03:33.370
So we can switch things around so that before
we send it down to the GPU in the display

00:03:33.370 --> 00:03:38.909
list itself we switch the order of commands
so you draw a bitmap twice, draw two nine

00:03:38.909 --> 00:03:42.730
patches and then draw the text that are next
to and on top of those objects.

00:03:42.730 --> 00:03:46.749
That tends to be a lot faster for the GPU
to process because it doesn't have to change

00:03:46.749 --> 00:03:47.749
state.

00:03:47.749 --> 00:03:53.749
It's not constantly changing the state of
the shaders that it's using, the state that

00:03:53.749 --> 00:03:56.459
we draw bitmaps with versus the state of text.

00:03:56.459 --> 00:04:00.829
None of those things have to change and the
GPU is really happy when you don't change

00:04:00.829 --> 00:04:01.829
states.

00:04:01.829 --> 00:04:05.829
So this is a good step to begin with and this
is where you could get to if you manually

00:04:05.829 --> 00:04:09.129
batched your stuff according to when you made
your drawing step.

00:04:09.129 --> 00:04:12.540
We can do that for you now in this fictional
upcoming release.

00:04:12.540 --> 00:04:16.489
But on top of that we could do something that
we call merging, which is we can actually

00:04:16.489 --> 00:04:19.670
take all of those commands that we have now
reordered and say, do you know what?

00:04:19.670 --> 00:04:24.580
What if we just did one command that drew
two bitmaps in a row and did one command that

00:04:24.580 --> 00:04:29.200
drew to nine patches in a row, and then draw
all of the text all at the same time?

00:04:29.200 --> 00:04:31.789
Even though they're actually on different
views on the screen, that's irrelevant to

00:04:31.789 --> 00:04:32.789
the GPU.

00:04:32.789 --> 00:04:34.750
All it's doing is drawing pixels on the screen.

00:04:34.750 --> 00:04:40.000
If we can do that we've reduced essentially
eight commands to the GPU, which were originally

00:04:40.000 --> 00:04:45.760
changing state and interweaving it the entire
time into three commands, which is much better

00:04:45.760 --> 00:04:47.720
for the GPU and much better for performance
in general.

00:04:47.720 --> 00:04:48.819
&gt;&gt;Romain Guy: So we have a demo.

00:04:48.819 --> 00:04:53.300
We'll use Google+ as an example and I'm going
to switch to one of our debugging tools.

00:04:53.300 --> 00:05:02.680
I'm going to show you what happens when -- without
the reordering and the merging.

00:05:02.680 --> 00:05:07.870
So I'll launch that tool to open the debugging
and I'll capture a frame and we'll see exactly

00:05:07.870 --> 00:05:10.289
what the app draws.

00:05:10.289 --> 00:05:12.100
Are getting everything?

00:05:12.100 --> 00:05:13.100
Yes.

00:05:13.100 --> 00:05:16.920
So we have to look at in details, but as you
can see this is the G+ UI so you have all

00:05:16.920 --> 00:05:22.730
your cards in your stream of posts, and you
can see that we draw the cards one by one

00:05:22.730 --> 00:05:23.730
because that's how they're defined.

00:05:23.730 --> 00:05:30.270
We'll draw the white backgrounds first and
then Chet's face and then we'll go to the

00:05:30.270 --> 00:05:33.910
text and then we go to the next card and we
do that over and over again.

00:05:33.910 --> 00:05:38.780
So in total we have 88 drawing commands that
have been executed on this frame.

00:05:38.780 --> 00:05:43.300
And as you can see there's a lot of -- Chet
was talking about state changes and you can

00:05:43.300 --> 00:05:44.389
see it happening here.

00:05:44.389 --> 00:05:48.770
Here we draw a bunch of text, then we switch
to bitmaps, then we draw text again, then

00:05:48.770 --> 00:05:52.020
bitmaps again and text and bitmap and so on
and so forth.

00:05:52.020 --> 00:06:02.870
So now if we re-enable the new optimizations
-- I have to kill the app first.

00:06:02.870 --> 00:06:12.830
Of course, it's reloaded the post so now they
are different.

00:06:12.830 --> 00:06:14.889
&gt;&gt;Chet Haase: Tension is building.

00:06:14.889 --> 00:06:17.930
What's it going to look like?

00:06:17.930 --> 00:06:23.669
&gt;&gt;Romain Guy: What makes me happy is we have
everyone -- people at the conference this

00:06:23.669 --> 00:06:27.629
week, so if it insists on not working we can
go yell at them.

00:06:27.629 --> 00:06:30.020
&gt;&gt;Chet Haase: Is there a dev doctor in the
house?

00:06:30.020 --> 00:06:34.389
&gt;&gt;Romain Guy: So this is what we do everyday
and everyday it's the same.

00:06:34.389 --> 00:06:37.219
We have to try again and again and again until
it works.

00:06:37.219 --> 00:06:40.020
[ Laughter ]
&gt;&gt;Romain Guy: So you know whenever you complain

00:06:40.020 --> 00:06:44.259
about the dev tools just know that we're in
the same boat.

00:06:44.259 --> 00:06:48.009
[ Laughter ]
&gt;&gt;Romain Guy: All right.

00:06:48.009 --> 00:06:51.250
So we went from 88 drawing commands to 39.

00:06:51.250 --> 00:06:56.020
So it's not exactly the same configuration,
but you can see what's going on here.

00:06:56.020 --> 00:06:57.020
Things are drawn out of order.

00:06:57.020 --> 00:06:59.770
You can see the text appear in pretty much
one block.

00:06:59.770 --> 00:07:02.219
We're going to go back to that.

00:07:02.219 --> 00:07:04.599
Let's go here at the beginning.

00:07:04.599 --> 00:07:08.860
So we can see that we're drawing the white
backgrounds of the cards together and then

00:07:08.860 --> 00:07:11.960
we go back to fill the inside of the cards.

00:07:11.960 --> 00:07:16.930
And then when we draw the text there's this
one spot where we draw a huge batch of text,

00:07:16.930 --> 00:07:17.930
right here.

00:07:17.930 --> 00:07:22.349
And you can see the geometry here, you can
see that we draw pretty much the entire text

00:07:22.349 --> 00:07:25.710
on screen in one draw call instead of many.

00:07:25.710 --> 00:07:26.710
So this is what it does for you.

00:07:26.710 --> 00:07:28.689
You don't have to worry about it.

00:07:28.689 --> 00:07:29.740
Don't change your app.

00:07:29.740 --> 00:07:32.060
It's going to be faster and better automatically.

00:07:32.060 --> 00:07:37.639
And in the future version of Android that
may or may not exist, and that you may or

00:07:37.639 --> 00:07:43.030
may not get on your device, we are also going
to introduce a little bit of multi-threading

00:07:43.030 --> 00:07:44.719
to the rendering pipeline.

00:07:44.719 --> 00:07:47.879
So we're still going to do the rendering on
the main thread, so it's still very important

00:07:47.879 --> 00:07:53.650
that you do not block the main thread to get
smooth animations; however, some of the operations

00:07:53.650 --> 00:07:58.710
that the render performs on your behalf will
now happen on multiple cores, if you have

00:07:58.710 --> 00:07:59.710
multiple cores.

00:07:59.710 --> 00:08:01.460
&gt;&gt;Chet Haase: Which is more and more common.

00:08:01.460 --> 00:08:06.569
The way that manufacturers are scaling performance
in general tends to be going wide, so you've

00:08:06.569 --> 00:08:10.470
got as opposed to faster and faster CPUs,
which was the model for year, now we're getting

00:08:10.470 --> 00:08:12.319
multiple cores, two cores, four cores.

00:08:12.319 --> 00:08:16.009
If you've got these multiple cores down there
can you take advantage of parallel processing

00:08:16.009 --> 00:08:19.210
instead of just continuing to do everything
as fast as you can on one.

00:08:19.210 --> 00:08:23.229
&gt;&gt;Romain Guy: So here we're executing the
drawing command.

00:08:23.229 --> 00:08:27.740
If you're using drop shadows in your application,
if you have drop shadows on text, that's what

00:08:27.740 --> 00:08:32.810
the launcher does a lot on Android, we'll
use renderscript and we're going to spin up

00:08:32.810 --> 00:08:33.810
on the four core device.

00:08:33.810 --> 00:08:38.440
We're going to use four threads to generate
the drop shadows, so we'll use all the cores

00:08:38.440 --> 00:08:39.440
at our disposal.

00:08:39.440 --> 00:08:45.870
So if you draw a little circles or arbitrary
geometric shapes with curves, we're also going

00:08:45.870 --> 00:08:51.060
to use multiple cores to draw this in the
background as open textures so then we can

00:08:51.060 --> 00:08:53.230
draw them on the UI thread.

00:08:53.230 --> 00:08:58.110
So once again, you don't have anything to
do, this all under the hood, but just be aware

00:08:58.110 --> 00:09:00.510
what's going on.

00:09:00.510 --> 00:09:05.820
We also have support for non-rectangular clipping.

00:09:05.820 --> 00:09:10.320
It wasn't supported in the (Indiscernible)
pipeline, so non-rectangular clipping can

00:09:10.320 --> 00:09:14.460
be used to draw very useful things such as
text in the shape of a heart.

00:09:14.460 --> 00:09:19.350
If you ever do that in your app, like I don't
want to know what your app does, but you can

00:09:19.350 --> 00:09:23.550
also be using -- we'll talk more about -- we
will talk more about that later.

00:09:23.550 --> 00:09:27.230
It can also be used to clip when you're doing
rotations.

00:09:27.230 --> 00:09:31.380
So let's say you have a ListView or a ScrollView
and you have a 3D rotation so you want to

00:09:31.380 --> 00:09:32.560
flip it over.

00:09:32.560 --> 00:09:37.160
If you're not using a layer and you run that
animation on existing versions of Android,

00:09:37.160 --> 00:09:42.640
like 4.1 or 4.2, you will see that the clipping
breaks because the clip rect of the list as

00:09:42.640 --> 00:09:48.130
you rotate it in 3D doesn't -- turns into
something that's not a rectangle any more.

00:09:48.130 --> 00:09:53.910
And we didn't know how to deal with that before,
but now that's fixed or it will be fixed.

00:09:53.910 --> 00:09:59.580
And if you're curious on how to do a non-rectangular
clipping and want to clip your text with a

00:09:59.580 --> 00:10:01.410
heart, this is how you do it.

00:10:01.410 --> 00:10:03.030
You get a canvas, you can call clip path.

00:10:03.030 --> 00:10:06.960
There are other methods that you can use.

00:10:06.960 --> 00:10:08.640
You can do those fancy shapes.

00:10:08.640 --> 00:10:11.460
And then you just draw your content and it
will do the right thing for you.

00:10:11.460 --> 00:10:16.540
&gt;&gt;Chet Haase: Now a discussion about some
of the tools that we use.

00:10:16.540 --> 00:10:21.100
Some of these exist now, but we'll be talking
about some slight modifications and improvements

00:10:21.100 --> 00:10:23.920
going forward in possible and fictional releases.

00:10:23.920 --> 00:10:29.450
&gt;&gt;Romain Guy: So the first one was introduced
in 4.2, I think.

00:10:29.450 --> 00:10:34.290
It's a debug tool that's on the device so
you go to settings, developer options, there's

00:10:34.290 --> 00:10:36.050
a check box called show dp overdraw.

00:10:36.050 --> 00:10:37.500
I wrote about it online.

00:10:37.500 --> 00:10:38.630
I wrote an article about that.

00:10:38.630 --> 00:10:42.450
How many of you know about this option or
have used this option?

00:10:42.450 --> 00:10:43.760
Why are we here?

00:10:43.760 --> 00:10:48.760
[ Laughter ]
&gt;&gt;Romain Guy: You're making my job useless.

00:10:48.760 --> 00:10:54.100
So show dp overdraw will colorize the screen,
it will use several different colors to show

00:10:54.100 --> 00:10:57.810
you how many times you draw each individual
pixel on the screen.

00:10:57.810 --> 00:11:03.580
So here you have a picture of the Google Play
Store with the option turned on, and you can

00:11:03.580 --> 00:11:05.230
see there's this bluish tint in the background.

00:11:05.230 --> 00:11:06.550
That doesn't come from the app.

00:11:06.550 --> 00:11:09.480
That's the tool adding this blue color on
the background.

00:11:09.480 --> 00:11:12.400
You can see there's a lot of red in the middle,
the app called 1-800-flowers.

00:11:12.400 --> 00:11:16.850
You can see there's a lot of red in the middle
because we have a lot of pixels here.

00:11:16.850 --> 00:11:18.790
So the color code is pretty simple.

00:11:18.790 --> 00:11:21.510
Blue means you've drawn a 1X overdraw.

00:11:21.510 --> 00:11:25.020
So it means that you've drawn that pixel once
and then you've drawn on top of it.

00:11:25.020 --> 00:11:26.890
So there's a 1X overdraw.

00:11:26.890 --> 00:11:31.470
Green means you have a 2X overview, so you've
drawn the pixel three times.

00:11:31.470 --> 00:11:33.410
The slight difference between the two reds.

00:11:33.410 --> 00:11:36.110
It doesn't really matter because if it's red
you're doing something wrong.

00:11:36.110 --> 00:11:38.720
Red is 3X or 4X or more.

00:11:38.720 --> 00:11:41.730
&gt;&gt;Chet Haase: And if it's 5X we just reboot
the machine.

00:11:41.730 --> 00:11:43.560
&gt;&gt;Romain Guy: I wish I could do that.

00:11:43.560 --> 00:11:45.430
&gt;&gt;Chet Haase: And there is a 0X.

00:11:45.430 --> 00:11:50.260
If you actually have no redraw, then you will
just see the natural color that they're painting

00:11:50.260 --> 00:11:51.260
on the screen.

00:11:51.260 --> 00:11:55.170
&gt;&gt;Romain Guy: We'll see the video of the overdrew
and how it works and the kind of techniques

00:11:55.170 --> 00:11:58.660
that you can use to fix overdraw in a few
minutes.

00:11:58.660 --> 00:12:03.610
&gt;&gt;Chet Haase: So this is a tool that we introduced
in 4.1.

00:12:03.610 --> 00:12:04.940
&gt;&gt;Romain Guy: Last year.

00:12:04.940 --> 00:12:07.300
&gt;&gt;Chet Haase: To track your frame rate.

00:12:07.300 --> 00:12:11.120
It seemed to be a little bit sort of inconsistent
on how you would get the frame rate and how

00:12:11.120 --> 00:12:15.390
to understand how fast you were running and
more importantly how consistently fast you

00:12:15.390 --> 00:12:18.800
were running, what your effective frame rate
was in your application.

00:12:18.800 --> 00:12:24.350
So we instrumented the system to give you
this information, and if you did an ADB shell

00:12:24.350 --> 00:12:31.590
command dump GFX info, then we would spit
out the information for the last 120 frames

00:12:31.590 --> 00:12:34.880
and then you could take that data and you
could paste it into a spreadsheet and then

00:12:34.880 --> 00:12:38.680
you could create a chart, and apparently that
was too tedious for people.

00:12:38.680 --> 00:12:40.870
So we have made that a little bit easier.

00:12:40.870 --> 00:12:45.520
Actually, if you go back to the previous slide,
this gives you the information about the time

00:12:45.520 --> 00:12:49.040
that we're spending actually creating the
drawing commands that are going to be issued

00:12:49.040 --> 00:12:53.230
and then issuing the drawing commands and
then waiting for OpenGL to come back because

00:12:53.230 --> 00:12:56.010
it processed the drawing commands and swapped
the buffers.

00:12:56.010 --> 00:13:00.760
This gives you an indication of those relative
times as well as how many times that's happening

00:13:00.760 --> 00:13:03.560
per second or what your frame rate is.

00:13:03.560 --> 00:13:08.290
So we have the same exact tool available now,
but instead of making you go through the incredibly

00:13:08.290 --> 00:13:12.340
tedious and overbearing process of creating
a spreadsheet to see a graph, we actually

00:13:12.340 --> 00:13:14.830
just create the graph for you on the screen.

00:13:14.830 --> 00:13:18.330
So you can pull up developer settings, you
can select an option in the dialogue box to

00:13:18.330 --> 00:13:22.530
see how you want to display the information,
whether you want to use the tedious method

00:13:22.530 --> 00:13:24.380
or some onscreen graphical method.

00:13:24.380 --> 00:13:28.330
Instead, you can see the results in real-time,
such as is demonstrated here.

00:13:28.330 --> 00:13:32.610
We're running a calendar application, and
we can see as the calendar application, I

00:13:32.610 --> 00:13:35.740
think you were probably scrolling back and
forth in the calendar application.

00:13:35.740 --> 00:13:40.070
And you can see in real time us update an
overlay on the device so you can see what

00:13:40.070 --> 00:13:42.020
the rendering performance and frame rate is
like.

00:13:42.020 --> 00:13:45.570
So you will actually see this for all active
activities on the screen, which is why there's

00:13:45.570 --> 00:13:48.310
actually three separate charts that you will
see.

00:13:48.310 --> 00:13:53.670
You will see one for calendar, you will also
see one for the navigation bar and the notification

00:13:53.670 --> 00:13:55.311
bar at the top.

00:13:55.311 --> 00:13:57.250
&gt;&gt;Romain Guy: It works in every application.

00:13:57.250 --> 00:14:02.300
And you can see it working here -- right here
on the device in real time.

00:14:02.300 --> 00:14:07.420
There's a green line that wasn't shown in
the graph that we used last year as a demonstration.

00:14:07.420 --> 00:14:09.950
So the green line is the 16 milliseconds threshold.

00:14:09.950 --> 00:14:16.000
So if all your vertical bars are under that
line, then you will run at 60 FPS.

00:14:16.000 --> 00:14:18.550
And if you cross that line then there's going
to be jank.

00:14:18.550 --> 00:14:22.850
So it's more complicated than that, but basically
if you can stay below the line you're part

00:14:22.850 --> 00:14:24.370
-- you're in good shape in your application.

00:14:24.370 --> 00:14:27.220
&gt;&gt;Chet Haase: The general tip is smaller is
better.

00:14:27.220 --> 00:14:31.020
Try to stay away from the green line on the
underside of it.

00:14:31.020 --> 00:14:35.990
And what you will see -- and also be aware
of situations where you're tripping very occasionally

00:14:35.990 --> 00:14:39.870
over that green line because then basically
you drop down to half the frame rate immediately

00:14:39.870 --> 00:14:43.590
and the net effect on the screen is that the
user is going to see a stuttery animation

00:14:43.590 --> 00:14:48.270
where it was smooth in 60 FPS and then you
skipped a frame in the middle.

00:14:48.270 --> 00:14:52.500
It's a very discontinuous and disturbing artifact.

00:14:52.500 --> 00:15:00.970
[ Applause ]
&gt;&gt;Romain Guy: I have to say, most of the time

00:15:00.970 --> 00:15:04.300
when you guys send us emails or ask questions,
you're pretty mad at us.

00:15:04.300 --> 00:15:05.630
It's pretty cool when you are happy.

00:15:05.630 --> 00:15:06.630
I like that.

00:15:06.630 --> 00:15:07.630
Keep doing it.

00:15:07.630 --> 00:15:08.970
&gt;&gt;Chet Haase: Maybe it was an angry clap.

00:15:08.970 --> 00:15:11.040
&gt;&gt;Romain Guy: Maybe it was an angry clap.

00:15:11.040 --> 00:15:15.090
Yeah, I'm worried now.

00:15:15.090 --> 00:15:17.510
Next we want to talk about systrace.

00:15:17.510 --> 00:15:22.890
Systrace is this awesome tool, and you can
thank Jamie right here for the tool.

00:15:22.890 --> 00:15:26.230
It's a great performing tool we introduced
last year.

00:15:26.230 --> 00:15:29.500
It was a little difficult to use, just like
the performance graph we showed you.

00:15:29.500 --> 00:15:31.380
It was a little bit involved to set it up.

00:15:31.380 --> 00:15:37.910
And in this future version of Android -- sorry,
future update of Android, not necessarily

00:15:37.910 --> 00:15:43.630
version number, it's easier to use systrace.

00:15:43.630 --> 00:15:49.170
So now the way you invoke systrace is still
from the command line, but you had to turn

00:15:49.170 --> 00:15:50.380
on several tags.

00:15:50.380 --> 00:15:54.100
Like you had to tell us I want to profile
graphics, I want to profile views, I want

00:15:54.100 --> 00:15:59.900
to profile the window manager, and then you
had to restart the runtime on the device,

00:15:59.900 --> 00:16:03.780
effectively rebooting the device, and then
you could run your command.

00:16:03.780 --> 00:16:07.561
Now the way you do it you just invoke the
script, you specify the tags that you want

00:16:07.561 --> 00:16:08.561
to trace.

00:16:08.561 --> 00:16:11.820
So here we are tracing gfx that's all, that's
all the graphics information; view, that's

00:16:11.820 --> 00:16:16.730
all the UI toolkit information; things like
inflation, layout, measure.

00:16:16.730 --> 00:16:21.220
Freq is the frequency of the different CPUs,
and sched is the scheduler, so that way you

00:16:21.220 --> 00:16:23.500
can see who scheduled on what the CPU and
when.

00:16:23.500 --> 00:16:26.610
And I am going to show you and example of
that.

00:16:26.610 --> 00:16:32.460
We also added in 4.2 the ability to trace
open OpenGL commands.

00:16:32.460 --> 00:16:37.351
So if you use OpenGL in your application and
or if you write a normal application and you

00:16:37.351 --> 00:16:42.070
are curious about how many GL commands we
execute on your behalf, you can go turn that

00:16:42.070 --> 00:16:47.190
on in the developer options, and we're going
to trace every individual OpenGL command and

00:16:47.190 --> 00:16:49.610
you are going to see them in systrace.

00:16:49.610 --> 00:16:54.390
Actually, let's go with the slides for a while.

00:16:54.390 --> 00:16:57.630
We are also introducing a new API.

00:16:57.630 --> 00:17:00.690
So there's this new class called Android.os.trace.

00:17:00.690 --> 00:17:04.110
That's the API that we use internally in the
framework to do all of this instrumentation,

00:17:04.110 --> 00:17:06.240
but we're opening it up a little bit.

00:17:06.240 --> 00:17:09.350
There's this new API called begin section
and end section.

00:17:09.350 --> 00:17:11.170
And here, this is an adapter.

00:17:11.170 --> 00:17:16.860
It's an adapter I created in a little test
application, and at the beginning I call begin

00:17:16.860 --> 00:17:17.860
section.

00:17:17.860 --> 00:17:18.860
I specify string.

00:17:18.860 --> 00:17:21.010
So that's just the name of the section you're
going to see the in profiler.

00:17:21.010 --> 00:17:22.440
So that name can be anything you want.

00:17:22.440 --> 00:17:26.270
At the end you close the section by saying
end section, and in the middle we can have

00:17:26.270 --> 00:17:27.780
another section called bind.

00:17:27.780 --> 00:17:29.300
So you can nest the sections.

00:17:29.300 --> 00:17:34.630
The advantage of using this over TraceView
is that the overhead is almost nonexistent.

00:17:34.630 --> 00:17:38.500
So it's not going to modify the behavior of
your application when it's running, and the

00:17:38.500 --> 00:17:43.180
timing that it gives you are very, very, very
precise.

00:17:43.180 --> 00:17:47.870
And if you do this -- so if you use this new
API, you have to use this other flag when

00:17:47.870 --> 00:17:48.870
you invoke systrace.

00:17:48.870 --> 00:17:52.740
You have to use dash A and you have to enter
the name, the package name of your application.

00:17:52.740 --> 00:17:56.950
&gt;&gt;Chet Haase: So to be clear, we're not recommending
don't use TraceView.

00:17:56.950 --> 00:17:57.950
TraceView is awesome.

00:17:57.950 --> 00:18:01.990
It is the tool to get all the information
on all the method calls that happened.

00:18:01.990 --> 00:18:08.080
However, if it's showing you timing about
method call overhead at the Java layer, be

00:18:08.080 --> 00:18:12.160
suspicious because there's a lot of overhead
associated with the tool and with the instrumentation

00:18:12.160 --> 00:18:13.220
in particular.

00:18:13.220 --> 00:18:16.620
So if you want to eliminate that as a factor
and you know the code path that you want to

00:18:16.620 --> 00:18:19.730
instrument very carefully, this is a really
good way to get that information.

00:18:19.730 --> 00:18:23.260
&gt;&gt;Romain Guy: And very often the way we will
use systrace, at least at our level, we will

00:18:23.260 --> 00:18:28.310
use systrace to get an idea of where the application
is slow, and then we have pinpointed that

00:18:28.310 --> 00:18:33.380
part of the application then we will use systrace
to see inside that block what is taking time.

00:18:33.380 --> 00:18:36.420
This is much more efficient usually than going
to TraceView directly.

00:18:36.420 --> 00:18:39.770
So here I have two more examples.

00:18:39.770 --> 00:18:41.660
Here is -- Okay.

00:18:41.660 --> 00:18:45.500
The first one, so this is what the systrace
file looks like.

00:18:45.500 --> 00:18:47.980
It is pretty scary but it is actually pretty
cool.

00:18:47.980 --> 00:18:54.480
At the top here you can see three CPUs, and
if I zoom in all the way --

00:18:54.480 --> 00:18:55.650
&gt;&gt;Chet Haase: I like the text heart better.

00:18:55.650 --> 00:18:56.650
It was more romantic.

00:18:56.650 --> 00:18:59.710
&gt;&gt;Romain Guy: So if I zoom in all the way,
it may be hard to see but you can see the

00:18:59.710 --> 00:19:05.160
name of the process that was scheduled on
the CPU, on CPU zero at that time.

00:19:05.160 --> 00:19:09.280
So if you're doing a lot of multi-threading
in your application, it's a great way to see

00:19:09.280 --> 00:19:10.620
what exactly is going on.

00:19:10.620 --> 00:19:15.250
So maybe all your threads are running one
after the other because you have a synchronization

00:19:15.250 --> 00:19:16.250
issue.

00:19:16.250 --> 00:19:19.200
You can see that in systrace.

00:19:19.200 --> 00:19:21.000
You can see the frequency of each CPU.

00:19:21.000 --> 00:19:25.750
So here the CPU zero and CPU one were running
at full frequency, and you can see that sometimes

00:19:25.750 --> 00:19:27.480
they go back down a little bit.

00:19:27.480 --> 00:19:30.060
So I took this when I was scrolling -- I don't
remember.

00:19:30.060 --> 00:19:31.060
It was Gmail.

00:19:31.060 --> 00:19:32.060
It was Gmail.

00:19:32.060 --> 00:19:35.880
And here at the bottom I have the name of
the application cell, so this is Gmail and

00:19:35.880 --> 00:19:37.170
we can see what Gmail was doing.

00:19:37.170 --> 00:19:41.840
So here we can see one frame of the Gmail
application, and we can see that Gmail took

00:19:41.840 --> 00:19:49.740
28 milliseconds to render one frame, so that's
too slow, but only less than one millisecond

00:19:49.740 --> 00:19:54.080
was spent on the Dalvik side executing Java
code.

00:19:54.080 --> 00:19:59.090
So most of the time is spent executing the
OpenGL commands, so that means that the app

00:19:59.090 --> 00:20:03.270
is not doing much at the Java level, but it
gave us so many drawing commands that we cannot

00:20:03.270 --> 00:20:04.550
draw at 60 fps.

00:20:04.550 --> 00:20:09.870
And I keep zooming here, you can see all the
individual OpenGL commands that we've executed

00:20:09.870 --> 00:20:10.870
for you.

00:20:10.870 --> 00:20:15.020
So if you work on games, that's probably a
lot more useful than if you work on apps.

00:20:15.020 --> 00:20:17.320
But this is what the systrace looks like.

00:20:17.320 --> 00:20:20.050
And we should -- there's a lot to do -- to
say about systrace.

00:20:20.050 --> 00:20:23.330
We would need a couple hours, I think, to
teach you exactly how it works.

00:20:23.330 --> 00:20:24.730
But go give it a try.

00:20:24.730 --> 00:20:25.730
It's really cool.

00:20:25.730 --> 00:20:29.180
Now, if you use that new API I just mentioned,
the begin and end section, this is what it's

00:20:29.180 --> 00:20:31.070
going to look like.

00:20:31.070 --> 00:20:32.720
So here you can see the two tags I created.

00:20:32.720 --> 00:20:37.750
I know they are hard to read, but you see
the strings create list item and bind image.

00:20:37.750 --> 00:20:41.890
I'm trying to zoom.

00:20:41.890 --> 00:20:45.900
So again, you can see exactly how much time
you are spending executing the section.

00:20:45.900 --> 00:20:53.520
So here, I'm spending 31 milliseconds in GetView,
and out of 31 milliseconds, almost the entire

00:20:53.520 --> 00:20:59.700
time was spent binding an image so I was probably
loading the image from the GetView method.

00:20:59.700 --> 00:21:05.570
&gt;&gt;Chet Haase: Tips and tricks.

00:21:05.570 --> 00:21:06.820
&gt;&gt;Romain Guy: Overdraw then?

00:21:06.820 --> 00:21:07.820
&gt;&gt;Chet Haase: Yeah.

00:21:07.820 --> 00:21:09.410
&gt;&gt;Romain Guy: So we'll switch to code.

00:21:09.410 --> 00:21:12.370
&gt;&gt;Chet Haase: Is this the one you did your
analysis --

00:21:12.370 --> 00:21:13.370
&gt;&gt;Romain Guy: No.

00:21:13.370 --> 00:21:14.370
It's a different one.

00:21:14.370 --> 00:21:15.370
&gt;&gt;Chet Haase: Okay.

00:21:15.370 --> 00:21:19.850
&gt;&gt;Romain Guy: So I have a very simple application
that I'm going to install on this phone over

00:21:19.850 --> 00:21:25.380
there, and I am using the new Android Studio,
so hopefully it works.

00:21:25.380 --> 00:21:28.740
Yeah, it worked.

00:21:28.740 --> 00:21:31.280
So this app is just a demo app; right?

00:21:31.280 --> 00:21:35.870
So it's a list of images, and what I do is
I fake loading the images from the network,

00:21:35.870 --> 00:21:40.100
so when I scroll really quickly, you can see
a placeholder, and after a random amount of

00:21:40.100 --> 00:21:42.980
time, the image appears.

00:21:42.980 --> 00:21:46.680
So the scrolling is pretty good but this is
a Nexus 4 so performance is usually awesome

00:21:46.680 --> 00:21:47.680
on the device.

00:21:47.680 --> 00:21:55.450
Now, if we go into settings and we turn on
the overdraw debug -- where is it?

00:21:55.450 --> 00:21:57.640
Here we go.

00:21:57.640 --> 00:22:02.680
So now everything becomes green and blue and
it's hard to read but you can see my application

00:22:02.680 --> 00:22:03.850
is mostly red.

00:22:03.850 --> 00:22:07.010
So the background of the app is blue that
means there is something behind the background

00:22:07.010 --> 00:22:09.090
of the app so we should get rid of that.

00:22:09.090 --> 00:22:15.460
The images are deep red so there is clearly
something else also behind them, and my nine

00:22:15.460 --> 00:22:19.290
patches are green so there's, again, something
behind those things.

00:22:19.290 --> 00:22:25.350
So now we're going to go to the code and see
what we can do to fix this application.

00:22:25.350 --> 00:22:35.120
So if we look at the layout of the activity,
or look at the XML -- how do I zoom?

00:22:35.120 --> 00:22:37.080
Here we go.

00:22:37.080 --> 00:22:39.390
Is the text big enough for everybody?

00:22:39.390 --> 00:22:40.390
Okay.

00:22:40.390 --> 00:22:41.630
You can see here I have a simple ListView.

00:22:41.630 --> 00:22:42.650
That's all there is in my application.

00:22:42.650 --> 00:22:46.450
I have a ListView and I gave it a background
color because I wanted that custom color.

00:22:46.450 --> 00:22:50.830
But by default, on Android when you create
and application you have a background already.

00:22:50.830 --> 00:22:51.830
It's the window background.

00:22:51.830 --> 00:22:52.850
It comes with the theme.

00:22:52.850 --> 00:22:54.210
So right now I have two backgrounds.

00:22:54.210 --> 00:22:57.260
I have the one that comes from the theme and
the one in my list and we're going to draw

00:22:57.260 --> 00:23:00.570
both, and that's where most of the overdraw
comes from.

00:23:00.570 --> 00:23:06.300
So instead of setting that background here
on the list, what I could do is remove it

00:23:06.300 --> 00:23:11.970
from the list, then go to my style that was
created for me when I created the application,

00:23:11.970 --> 00:23:14.920
and you can specify a window background.

00:23:14.920 --> 00:23:18.120
And here I'm just going to specify the color
I was using in the ListView.

00:23:18.120 --> 00:23:26.350
So now if I run the demo again.

00:23:26.350 --> 00:23:29.320
So you can see it's not deep red anymore.

00:23:29.320 --> 00:23:33.010
We have this light red on the images, and
the background of the app, it's real hard

00:23:33.010 --> 00:23:36.190
to read on the screen perhaps but it's white.

00:23:36.190 --> 00:23:38.250
It's not blue anymore.

00:23:38.250 --> 00:23:40.980
And the cards themselves, the nine patches
of the cards are not green anymore.

00:23:40.980 --> 00:23:41.980
It's blue.

00:23:41.980 --> 00:23:44.160
So we lost one layer of overdraw.

00:23:44.160 --> 00:23:47.580
But we can be even more (indiscernible) than
that.

00:23:47.580 --> 00:23:53.130
So we have all these placeholder images that
we show before we load the real image.

00:23:53.130 --> 00:23:58.990
And what's going on is once we have done binding,
loading an image from the network and binding

00:23:58.990 --> 00:24:03.700
it on the image view, we're not removing the
placeholder.

00:24:03.700 --> 00:24:06.720
So the way to do this is -- I lost my placeholder.

00:24:06.720 --> 00:24:11.690
I don't remember how to do it in that demo
but you could just remove -- make sure that

00:24:11.690 --> 00:24:15.010
if you have placeholders and you put an image
on top of it, make sure to remove the placeholder.

00:24:15.010 --> 00:24:16.990
&gt;&gt;Chet Haase: We're going to leave that as
an exercise to the reader.

00:24:16.990 --> 00:24:19.050
&gt;&gt;Romain Guy: It's an exercise to the reader.

00:24:19.050 --> 00:24:24.740
[ Laughter ]
&gt;&gt;&gt; (Speaking off microphone.)

00:24:24.740 --> 00:24:29.000
&gt;&gt;Romain Guy: Yes.

00:24:29.000 --> 00:24:30.000
Don't get ahead.

00:24:30.000 --> 00:24:33.090
Also, they can't hear you.

00:24:33.090 --> 00:24:37.429
And the last trick you can use and a lot of
applications can benefit from that, so this

00:24:37.429 --> 00:24:39.860
is the nine patch I'm using for the cards.

00:24:39.860 --> 00:24:42.940
So this is this little -- you know, there
was a little drop shadow and there was this

00:24:42.940 --> 00:24:45.130
little white area under the image.

00:24:45.130 --> 00:24:47.860
So this is a perfectly regular nine patch.

00:24:47.860 --> 00:24:51.460
There's nothing weird about it but as you
can see, the entire inside of the nine patch

00:24:51.460 --> 00:24:54.190
-- and let me show you the inside.

00:24:54.190 --> 00:24:55.190
Show content.

00:24:55.190 --> 00:24:57.950
So the blue area here is where my images will
go.

00:24:57.950 --> 00:25:00.280
So that area is a single opaque color.

00:25:00.280 --> 00:25:01.310
It's white.

00:25:01.310 --> 00:25:05.860
But because we're going to hide it with an
image, there's no reason for that to be drawn.

00:25:05.860 --> 00:25:10.559
So instead what you can use is you can modify
your nine patch and it's real hard to read

00:25:10.559 --> 00:25:12.500
on screen.

00:25:12.500 --> 00:25:16.800
Here you can see under my mask cursor, there's
a single transparent pixel.

00:25:16.800 --> 00:25:21.000
So just cut a hole in the nine patch and this
is the area that we stretch.

00:25:21.000 --> 00:25:24.730
So here again the blue area on the right,
you can see it's transparent.

00:25:24.730 --> 00:25:27.380
So we won't be drawing anything behind the
images anymore.

00:25:27.380 --> 00:25:30.521
And the rendering pipeline is smart enough
to recognize there is a hole in the nine patch

00:25:30.521 --> 00:25:35.970
the it will remove that part of the geometry
and get rid of the overdraw.

00:25:35.970 --> 00:25:43.330
&gt;&gt;Chet Haase: Trilinear filtering is something
we --

00:25:43.330 --> 00:25:44.450
&gt;&gt;Romain Guy: 4.2.

00:25:44.450 --> 00:25:45.580
&gt;&gt;Chet Haase: Right.

00:25:45.580 --> 00:25:46.580
4.2.

00:25:46.580 --> 00:25:49.710
So this API actually exists in a release that's
out there right now.

00:25:49.710 --> 00:25:54.250
It's also referred to as MIP mapping, sort
of classic, traditional graphics technique

00:25:54.250 --> 00:25:58.980
of getting better image filtering when your
down scaling sort of extremely.

00:25:58.980 --> 00:26:03.610
If you are going down to more than half the
size, it doesn't really matter that much.

00:26:03.610 --> 00:26:08.350
It's not going to change that, but the effect
is if you know that bilinear filtering is

00:26:08.350 --> 00:26:13.020
basically sampling the pixels on either side
and top and bottom of the pixel you're going

00:26:13.020 --> 00:26:17.770
to fill in and then blending that result,
trilinear filtering is doing the same thing

00:26:17.770 --> 00:26:23.030
on the two images that bracket the image size
that you really need, and then filtering that

00:26:23.030 --> 00:26:26.720
result as well and you get a much better scaling
result.

00:26:26.720 --> 00:26:29.120
For instance, I think we zoom in on these
images.

00:26:29.120 --> 00:26:30.380
You can't really tell the difference there.

00:26:30.380 --> 00:26:31.500
&gt;&gt;Romain Guy: Go back.

00:26:31.500 --> 00:26:34.020
So in this demo, the two images were really
large.

00:26:34.020 --> 00:26:39.780
They were bigger than the screen and the same
image was reduced twice on the left and on

00:26:39.780 --> 00:26:42.260
the right to less than half its size.

00:26:42.260 --> 00:26:47.340
On the left side it was using the normal filtering
and on the right side it's using trilinear

00:26:47.340 --> 00:26:48.340
filtering.

00:26:48.340 --> 00:26:51.370
&gt;&gt;Chet Haase: So if we zoom up so you can
see the effect a little more clearly, you

00:26:51.370 --> 00:26:54.350
can see the one on the right is much smoother.

00:26:54.350 --> 00:26:57.640
We're not running into the same artifacts,
the jaggy artifacts that we have on the left

00:26:57.640 --> 00:27:01.050
because we're using more information about
all of the MIP levels.

00:27:01.050 --> 00:27:05.450
So we can see the -- was there the representation
to MIP map?

00:27:05.450 --> 00:27:06.580
Did I go past that one?

00:27:06.580 --> 00:27:07.580
Yeah; right.

00:27:07.580 --> 00:27:10.880
So (indiscernible) this, this is what MIP
mapping or trilinear filtering actually produces.

00:27:10.880 --> 00:27:15.150
Instead of just the one image that we're going
to filter from, we actually produced powers

00:27:15.150 --> 00:27:17.370
of two sizes below that.

00:27:17.370 --> 00:27:21.650
And then we have all of those choices to then
filter from when we do the MIP mapping.

00:27:21.650 --> 00:27:24.200
And there it is again because it's so awesome.

00:27:24.200 --> 00:27:25.200
And here is the code.

00:27:25.200 --> 00:27:29.470
If you want to do it in code at runtime, set
has MIP map to true, or you can do it in your

00:27:29.470 --> 00:27:33.080
XML drawable resource instead with the MIP
map attribute.

00:27:33.080 --> 00:27:37.450
&gt;&gt;Romain Guy: We're going to talk about canvas
layers.

00:27:37.450 --> 00:27:41.640
So this is the (indiscernible) API on the
canvas class.

00:27:41.640 --> 00:27:44.130
So we have two types of layers.

00:27:44.130 --> 00:27:49.100
And if you don't write custom code, they don't
really matter to you directly but we see why

00:27:49.100 --> 00:27:52.880
they do matter even when you write an application
using only views.

00:27:52.880 --> 00:27:55.410
So the first type of layer is what we call
clip layers.

00:27:55.410 --> 00:28:00.390
So when you call the save layer method on
the canvas, you can pass a flag at the end

00:28:00.390 --> 00:28:05.210
the last parameter, and here we pass the value
clip to layer save flag.

00:28:05.210 --> 00:28:06.309
Then we draw stuff.

00:28:06.309 --> 00:28:10.410
So what this method does is very simple.

00:28:10.410 --> 00:28:11.510
So here we have our canvas.

00:28:11.510 --> 00:28:12.830
We invoke save layer.

00:28:12.830 --> 00:28:16.630
We're going to create an upscreen bitmap,
so we're basically creating some -- you can

00:28:16.630 --> 00:28:18.380
see that as a second canvas.

00:28:18.380 --> 00:28:23.350
And then when we draw the contents, or here
we're drawing an image, that image will be

00:28:23.350 --> 00:28:25.460
constrained to that new canvas.

00:28:25.460 --> 00:28:28.980
So it's not going to bleed out anywhere else,
but we've created a second canvas.

00:28:28.980 --> 00:28:30.720
We have the second image in memory.

00:28:30.720 --> 00:28:35.010
This is very useful for a number of effects,
especially opacity and we're going to talk

00:28:35.010 --> 00:28:37.690
about that.

00:28:37.690 --> 00:28:41.809
If you have save layer and you pass zero as
the flag at the end, you're creating an unclipped

00:28:41.809 --> 00:28:43.110
layer.

00:28:43.110 --> 00:28:47.260
And unclipped layers are extremely expensive
because when you invoke them, the save layer

00:28:47.260 --> 00:28:51.210
method, we still have to create that extra
buffer in memory.

00:28:51.210 --> 00:28:56.450
But every time you draw something, what you're
drawing is going to be drawn on every layer

00:28:56.450 --> 00:29:00.230
that the parameter you're drawing with intersects.

00:29:00.230 --> 00:29:05.090
So if you create end layers and the parameters
you're drawing, your bitmap, intersects all

00:29:05.090 --> 00:29:07.559
of them, we're going to execute the command
end times.

00:29:07.559 --> 00:29:09.030
So that can be extremely expensive.

00:29:09.030 --> 00:29:11.721
So this is what we do in software.

00:29:11.721 --> 00:29:15.520
In hardware we do it a little differently
but it's also extremely expensive, and I think

00:29:15.520 --> 00:29:18.040
we give details in one of our talks.

00:29:18.040 --> 00:29:22.679
I think maybe at Devoxx at the end of 2012,
we explained exactly what happens in hardware.

00:29:22.679 --> 00:29:27.530
But the point is if you're using save layer,
be very careful because either in software

00:29:27.530 --> 00:29:31.049
or in hardware the results can be pretty bad
for your performance.

00:29:31.049 --> 00:29:35.911
And if you remember, on Android we used to
have those fading edges in lists and all scroll

00:29:35.911 --> 00:29:39.850
views all over the place, and that's how the
filling edges are implemented.

00:29:39.850 --> 00:29:41.500
They use the save layer commands.

00:29:41.500 --> 00:29:46.980
So the top and bottom edges are one save layer
each, and they were really expensive to run

00:29:46.980 --> 00:29:52.020
and also they didn't fit the new Ice Cream
Sandwich themes so we got rid of them.

00:29:52.020 --> 00:29:55.000
&gt;&gt;Chet Haase: Let's talk about alpha.

00:29:55.000 --> 00:29:57.800
So alpha is a cool property on view.

00:29:57.800 --> 00:30:00.230
You can make views translucent with alpha.

00:30:00.230 --> 00:30:05.350
It's very handy for fading views in and out
and it's really, really easy with alpha to

00:30:05.350 --> 00:30:09.520
give yourself performance problems that you
really don't need to be suffering from.

00:30:09.520 --> 00:30:14.410
So the general tip is use it, but be aware
of what you're doing and maybe there's a better

00:30:14.410 --> 00:30:17.350
way to actually get the effect that you're
looking for.

00:30:17.350 --> 00:30:22.360
So there's lots of different ways to tie yourself
in knots with alpha.

00:30:22.360 --> 00:30:25.510
You can set the alpha on a view, in a couple
of different ways.

00:30:25.510 --> 00:30:30.220
You can create an animation, object animator
or view property animator that evaluate alpha

00:30:30.220 --> 00:30:33.560
over time or you can use one of the old style
alpha animations.

00:30:33.560 --> 00:30:38.220
These all end up doing the same thing under
the hood, which is essentially creating an

00:30:38.220 --> 00:30:41.450
alpha layer, just like Romain already talked
about.

00:30:41.450 --> 00:30:44.200
So we're going to create these intermediate
buffers, we're going to draw stuff there,

00:30:44.200 --> 00:30:46.340
we're going to copy it back and composite
it.

00:30:46.340 --> 00:30:49.180
A fair amount of work to go through, which
is fine if that's what you need.

00:30:49.180 --> 00:30:52.000
But in a lot of situations, that's actually
not what you need.

00:30:52.000 --> 00:30:54.920
You just didn't know there were alternatives,
so maybe it would be good to find out what

00:30:54.920 --> 00:30:56.260
the alternatives are.

00:30:56.260 --> 00:31:00.690
It's also good to understand why you actually
care about this.

00:31:00.690 --> 00:31:03.520
You might think, well, I've got this view
and it's drawing several things.

00:31:03.520 --> 00:31:07.429
Why don't you just draw each one of these
things with alpha directly into the screen

00:31:07.429 --> 00:31:10.910
as opposed to creating this separate buffer
over here, drawing everything and then compositing

00:31:10.910 --> 00:31:12.010
it back.

00:31:12.010 --> 00:31:16.130
So there's a handy animation here to see what
kind of effect you're going to get if you're

00:31:16.130 --> 00:31:20.880
just going to draw things with alpha directly
to the screen, if we wanted to draw all of

00:31:20.880 --> 00:31:26.890
these images and then show a translucent view
of the images, if we drew the images separately

00:31:26.890 --> 00:31:31.820
with alpha, this is what you get, which in
graphics is called a mess.

00:31:31.820 --> 00:31:35.880
And what you actually wanted was something
more like this; right?

00:31:35.880 --> 00:31:39.929
We just wanted to fade everything when it
was drawn together, not fade the individual

00:31:39.929 --> 00:31:44.250
items so that they all mushed together into
that mess.

00:31:44.250 --> 00:31:47.050
So what are some of the alternatives?

00:31:47.050 --> 00:31:48.050
So here's one.

00:31:48.050 --> 00:31:49.050
This is a simple one.

00:31:49.050 --> 00:31:53.720
We ran into this one in notification panel,
which won't be named.

00:31:53.720 --> 00:31:55.020
&gt;&gt;Romain Guy: It was Dr. Dan's fault.

00:31:55.020 --> 00:31:56.919
&gt;&gt;Chet Haase: It was Dr. Dan's fault, actually.

00:31:56.919 --> 00:32:02.971
So the engineer who was playing with this
was trying to achieve a particular effect,

00:32:02.971 --> 00:32:03.971
a specific color.

00:32:03.971 --> 00:32:09.240
It was basically a 70% translucent white value;
right?

00:32:09.240 --> 00:32:14.970
Gave this nice gray, which is wonderful, except
what ended up happening was alpha was set

00:32:14.970 --> 00:32:20.620
on the text view, and the text view occupied
most of the notification panel item, and there

00:32:20.620 --> 00:32:27.030
were several items on the screen and you got
a significant performance problem because

00:32:27.030 --> 00:32:28.030
of that.

00:32:28.030 --> 00:32:31.350
We were basically drawing most of the screen
into these separate off-screen buffers and

00:32:31.350 --> 00:32:34.780
compositing back all so that we could have
gray text on the screen.

00:32:34.780 --> 00:32:40.230
The correct solution for that particular egregious
performance problem was to use gray text.

00:32:40.230 --> 00:32:44.110
[ Laughter ]
&gt;&gt;Chet Haase: A slightly more direct or alternative

00:32:44.110 --> 00:32:48.240
way is if you really want alpha to achieve
the exact color you're going for, if you're

00:32:48.240 --> 00:32:53.850
animating the translucency of that text, you
can set alpha directly on the text color itself

00:32:53.850 --> 00:32:59.400
and we're going to draw that much more optimally
than using the separate buffer approach.

00:32:59.400 --> 00:33:02.250
Image view, similarly, you can set the image
alpha.

00:33:02.250 --> 00:33:03.460
This was new API in ICS.

00:33:03.460 --> 00:33:04.460
&gt;&gt;Romain Guy: Jelly Bean.

00:33:04.460 --> 00:33:05.730
&gt;&gt;Chet Haase: Jelly Bean?

00:33:05.730 --> 00:33:07.070
&gt;&gt;Romain Guy: Yes.

00:33:07.070 --> 00:33:08.419
&gt;&gt;Chet Haase: Okay.

00:33:08.419 --> 00:33:09.419
4.1.

00:33:09.419 --> 00:33:12.620
You can set the image alpha and then when
we draw the image of that image view, we will

00:33:12.620 --> 00:33:13.620
use that alpha.

00:33:13.620 --> 00:33:17.720
Again, we're drawing directly into the destination
buffer as opposed to creating this set-aside

00:33:17.720 --> 00:33:20.010
buffer that we then composite from.

00:33:20.010 --> 00:33:23.630
Much faster if that's the effect that you're
looking for.

00:33:23.630 --> 00:33:28.460
If you have a custom view and you know that
you're going to draw all these different operations

00:33:28.460 --> 00:33:32.250
and you're happy to draw them translucently,
then you can actually change the alpha on

00:33:32.250 --> 00:33:37.310
the paint and draw directly into the destination
instead of setting the alpha directly on the

00:33:37.310 --> 00:33:38.310
view itself.

00:33:38.310 --> 00:33:42.470
Again, you know what you're view is doing,
so do the right thing for your situation.

00:33:42.470 --> 00:33:46.320
Don't depend on, you know, framework capabilities
that are a bit more generic but from which

00:33:46.320 --> 00:33:50.330
you might suffer because we can't know whether
you're going to run into some of the artifacts

00:33:50.330 --> 00:33:52.720
that we talked about.

00:33:52.720 --> 00:33:53.720
Or you can set a layer.

00:33:53.720 --> 00:33:57.330
This is kind of a good thing to do in general,
especially for animations.

00:33:57.330 --> 00:34:00.861
If it's a complex view and you want to fade
the view, just set a hardware layer on the

00:34:00.861 --> 00:34:05.179
object during the animation, and then when
you do an alpha fade on that, if you set the

00:34:05.179 --> 00:34:09.899
alpha property or animate the alpha property,
then we can take care of that very fast.

00:34:09.899 --> 00:34:15.710
We create a texture map and we just fade the
alpha on that texture directly.

00:34:15.710 --> 00:34:20.019
And another related thing to mention is this
new method that was introduced probably in

00:34:20.019 --> 00:34:25.179
API level 16, which is has overlapping rendering.

00:34:25.179 --> 00:34:29.319
We like method names that are really long,
preferably if they actually go past the character

00:34:29.319 --> 00:34:31.109
wrap at the end of the screen.

00:34:31.109 --> 00:34:32.909
This one didn't quite make it.

00:34:32.909 --> 00:34:38.429
This one we use under the hood to figure out
if we can draw optimally in this view.

00:34:38.429 --> 00:34:43.919
If there is no overlapping rendering in a
view, we know we can draw each rendering operation

00:34:43.919 --> 00:34:48.129
separately with alpha, and we'll take care
of that very optimally, as opposed to you

00:34:48.129 --> 00:34:52.200
know we don't know whether these rendering
operation overlap or not so we'll just draw

00:34:52.200 --> 00:34:54.149
them all into the buffer and then composite
them back.

00:34:54.149 --> 00:34:58.609
So if you have a custom view, you can consider
overriding this method and telling us that

00:34:58.609 --> 00:35:02.690
you do not have overlapping rendering, and
we're going to be able to handle alpha operations

00:35:02.690 --> 00:35:03.690
faster.

00:35:03.690 --> 00:35:06.799
&gt;&gt;Romain Guy: We have only five minutes left
so we're going to start talking a little faster.

00:35:06.799 --> 00:35:08.119
Now let's talk about canvas.

00:35:08.119 --> 00:35:14.299
Here is an issue I see in a lot of applications
and I see a lot of confused people online

00:35:14.299 --> 00:35:15.701
asking about this behavior.

00:35:15.701 --> 00:35:24.400
So imagine you have a canvas and that canvas
is 640 pixels wide, 400 pixels high and you

00:35:24.400 --> 00:35:27.749
call canvas that get width and canvas that
get height.

00:35:27.749 --> 00:35:31.599
So I see people think it's going to give them
the size of the window, I see people who think

00:35:31.599 --> 00:35:36.390
it's going to give them the size of the view,
and the answer is both.

00:35:36.390 --> 00:35:42.380
So if we have this canvas in a window, let's
say you're on a Nexus 4 or Nexus 7 and the

00:35:42.380 --> 00:35:47.220
window is about 1280 pixels by 800 and inside
you have a view that's 600 by 300, and you

00:35:47.220 --> 00:35:51.990
call get width and get height, in the window
you're going to get the size of the view as

00:35:51.990 --> 00:35:52.990
the answer.

00:35:52.990 --> 00:35:56.049
So you call canvas that get width and canvas
that get height and you're getting the size

00:35:56.049 --> 00:35:57.049
of the view.

00:35:57.049 --> 00:36:00.009
In software, you're going to get the size
of the window.

00:36:00.009 --> 00:36:05.690
The point here is do not use the dimensions
of the canvas as the dimensions of your view.

00:36:05.690 --> 00:36:08.690
You can just use view the get width and view
the get height.

00:36:08.690 --> 00:36:13.119
There's no reason why you should use the width
and height of the canvas pretty much ever

00:36:13.119 --> 00:36:16.559
and you can think about it in a different
way.

00:36:16.559 --> 00:36:21.010
If you were to rely on one of those two values
to be exact, what would happen if instead

00:36:21.010 --> 00:36:24.640
of giving you the canvas of the window we
would give you the canvas of a bitmap, because

00:36:24.640 --> 00:36:27.160
we're taking a screen shot or we're taking
a drawing cache.

00:36:27.160 --> 00:36:29.049
Then you would get a completely arbitrary
value.

00:36:29.049 --> 00:36:33.249
So be very careful if you're using those methods
your code.

00:36:33.249 --> 00:36:35.420
Now let's talk a little bit about clipping.

00:36:35.420 --> 00:36:41.779
I mentioned that we're introducing super (indiscernible)
clipping, so if you're doing rotations and

00:36:41.779 --> 00:36:44.970
clipping, be very careful about the order
of operations.

00:36:44.970 --> 00:36:49.229
So here, for instance, we're simply going
to draw a rotated bitmap and we want to clip

00:36:49.229 --> 00:36:50.349
that bitmap just in case.

00:36:50.349 --> 00:36:55.359
So we first clip with a rectangle, then we
rotate by minus 30 degrees, then draw the

00:36:55.359 --> 00:36:56.359
bitmap.

00:36:56.359 --> 00:36:57.359
So this is what's going to happen.

00:36:57.359 --> 00:36:59.549
You have your canvas.

00:36:59.549 --> 00:37:05.089
We apply the clip rect, then we rotate the
canvas, we draw our bitmap and this is the

00:37:05.089 --> 00:37:06.089
result.

00:37:06.089 --> 00:37:13.700
As you can see the clip rect remained a rectangle
throughout the drawing operations.

00:37:13.700 --> 00:37:15.819
So we can do it very efficiently.

00:37:15.819 --> 00:37:20.339
Now, if you do it the other way around, if
you rotate first, then use your clip rect

00:37:20.339 --> 00:37:22.519
and then you draw, here's what's going to
happen.

00:37:22.519 --> 00:37:26.349
We're going to rotate the canvas, we're going
to apply the clip rect, we're going to draw,

00:37:26.349 --> 00:37:30.200
and the result is the same because we're not
intersecting -- we're not going outside of

00:37:30.200 --> 00:37:31.240
the bounds of the clip rect.

00:37:31.240 --> 00:37:36.070
But now that we are back nonrotated, you can
see that our rectangle is not a rectangle

00:37:36.070 --> 00:37:37.070
anymore.

00:37:37.070 --> 00:37:38.760
It's actually some sort of a diamond.

00:37:38.760 --> 00:37:42.240
So to apply this affect, what we have to do
under the hood is we have to use something

00:37:42.240 --> 00:37:46.609
on the GPU called the stencil buffer, it's
some sort of a mask, we have to clear that

00:37:46.609 --> 00:37:50.910
mask, we have to render the rotated rectangle
that (indiscernible) the clip inside it, and

00:37:50.910 --> 00:37:54.739
then when we draw the bitmap, for each pixel
we have to test the pixel of the bitmap against

00:37:54.739 --> 00:37:56.619
the content of the stencil buffer.

00:37:56.619 --> 00:38:01.069
GPUs are very good at doing that kind of stuff,
so if you do it once per frame, it's okay,

00:38:01.069 --> 00:38:04.780
but if you have a lot of very expensive drawing
commands or if you change the clip rect or

00:38:04.780 --> 00:38:09.520
if you keep rotating in different ways, it's
going to be extremely expensive.

00:38:09.520 --> 00:38:14.059
And again, remember that you can end up with
a nonrectanglar clip that is just setting

00:38:14.059 --> 00:38:22.180
a rotation on the view if you do a 3D flip
or just a rotation on the Z axis.

00:38:22.180 --> 00:38:28.160
Let's imagine you have a view that's 640 pixels
wide by 400 pixels high, and we invalidate

00:38:28.160 --> 00:38:31.040
a small region of the view.

00:38:31.040 --> 00:38:35.720
So we co-invalidate, we specify this little
rectangle here inside, and we ask for the

00:38:35.720 --> 00:38:38.339
clip bounds on the canvas in the draw method.

00:38:38.339 --> 00:38:43.539
The clip bounds are going to be different
if you are hardware accelerated or if you

00:38:43.539 --> 00:38:44.539
are not.

00:38:44.539 --> 00:38:48.069
So with hardware acceleration, the clip bounds
will always be the size of the view because

00:38:48.069 --> 00:38:49.779
we record a (indiscernible).

00:38:49.779 --> 00:38:51.779
So the clip bounds don't matter at record
time.

00:38:51.779 --> 00:38:54.809
We just want to see all the drawing comments
that you want to execute.

00:38:54.809 --> 00:38:58.960
When we're going to replay the display list,
then we're going to apply the dirty bounds.

00:38:58.960 --> 00:39:03.980
In software, however, we're going to give
you the exact clip bounds that you set using

00:39:03.980 --> 00:39:04.980
invalidate.

00:39:04.980 --> 00:39:08.510
&gt;&gt;Chet Haase: We are not going to talk about
reordering barriers.

00:39:08.510 --> 00:39:11.089
We will be posting these slides online.

00:39:11.089 --> 00:39:13.390
That is, in fact, the talk.

00:39:13.390 --> 00:39:16.819
There's some links to other information on
related topics.

00:39:16.819 --> 00:39:20.509
Parleys.com has a lot of recorded talks that
you can watch.

00:39:20.509 --> 00:39:23.019
And there were performance case studies you
can check out online.

00:39:23.019 --> 00:39:27.940
Our blogs post all of this kind of information,
or watch us on G+ where we also talk about

00:39:27.940 --> 00:39:28.940
this stuff.

00:39:28.940 --> 00:39:28.942
Thank you.

