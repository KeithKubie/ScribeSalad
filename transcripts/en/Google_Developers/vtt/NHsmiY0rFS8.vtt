WEBVTT
Kind: captions
Language: en

00:00:00.650 --> 00:00:01.630
Hi everyone.

00:00:01.630 --> 00:00:04.950
Welcome to my talk, moving
from Node.js to Dart.

00:00:04.950 --> 00:00:06.340
In the end, if
you guys are lucky

00:00:06.340 --> 00:00:07.670
I'll actually fly on a bird.

00:00:07.670 --> 00:00:09.640
We'll see about that.

00:00:09.640 --> 00:00:12.040
So this talk is about
my personal experience

00:00:12.040 --> 00:00:16.420
in taking a production Node.js
API and moving it to Dart.

00:00:16.420 --> 00:00:18.600
This API isn't large scale.

00:00:18.600 --> 00:00:21.060
It's not serving
millions of users.

00:00:21.060 --> 00:00:24.530
It's just a personal app that
we had a stock simulator game

00:00:24.530 --> 00:00:30.140
and why we moved to Dart,
and you know our experiences.

00:00:30.140 --> 00:00:32.549
In my opinion, Dart is
a really powerful VM

00:00:32.549 --> 00:00:34.600
and is a really amazing syntax.

00:00:34.600 --> 00:00:36.260
I mean, that's why I'm here.

00:00:36.260 --> 00:00:40.720
So using that for API
development is pretty cool.

00:00:40.720 --> 00:00:42.050
What are we gonna talk about?

00:00:42.050 --> 00:00:44.880
We'll talk about Node.js
to Dart, the pros and cons

00:00:44.880 --> 00:00:47.900
and the differences
in moving from Node.js

00:00:47.900 --> 00:00:51.900
to Dart and the frameworks
and differences there.

00:00:51.900 --> 00:00:54.490
We'll talk about
thinking in Dart.

00:00:54.490 --> 00:00:58.030
This is interesting because
it's really different paradigms.

00:00:58.030 --> 00:01:00.700
So we'll talk about how to
really think in Dart when

00:01:00.700 --> 00:01:03.840
you're coming from Node.js and
utilizing Dart's most powerful

00:01:03.840 --> 00:01:06.190
features for API development.

00:01:06.190 --> 00:01:09.324
Next, we'll talk about
debugging in Dart.

00:01:09.324 --> 00:01:10.490
I'm not a perfect developer.

00:01:10.490 --> 00:01:13.350
I have bugs so Dart really
helps out with that.

00:01:13.350 --> 00:01:16.610
And lastly, most important
part, getting it out there.

00:01:16.610 --> 00:01:21.910
So how to deploy a Dart
application to an Amazon cloud.

00:01:21.910 --> 00:01:24.610
Before that, a little bit about
me because I don't think anyone

00:01:24.610 --> 00:01:27.530
knows me.

00:01:27.530 --> 00:01:30.020
Pardon, oh.

00:01:30.020 --> 00:01:31.520
I'm an entrepreneur
and an engineer.

00:01:31.520 --> 00:01:35.020
I've been writing APIs
is for the past 10 years

00:01:35.020 --> 00:01:38.630
in ColdFusion first,
Node.js, and now Dart.

00:01:38.630 --> 00:01:41.150
Anyone done any
ColdFusion development?

00:01:41.150 --> 00:01:43.460
Yeah, those are my homies.

00:01:43.460 --> 00:01:47.140
ColdFusion was amazing back
in the day and now it's--

00:01:47.140 --> 00:01:50.110
And I've deployed many
large-scale Node.js APIs.

00:01:50.110 --> 00:01:52.940
I've written recommendation
engines, real-time chat

00:01:52.940 --> 00:01:55.090
servers, and stuff
so it's kind of cool.

00:01:55.090 --> 00:01:57.370
I've done a bunch
of stuff there.

00:01:57.370 --> 00:02:00.330
I'm also an Android and
sometimes an iOS developer.

00:02:00.330 --> 00:02:02.410
I come from a Flex
background like many of you

00:02:02.410 --> 00:02:04.840
here, which is really weird.

00:02:04.840 --> 00:02:07.730
And fun fact, I actually
wrote Flex 2 in Action way

00:02:07.730 --> 00:02:10.866
back in the day, so I don't
know if anyone read that.

00:02:10.866 --> 00:02:13.650
And I've written a handful
of Dart web projects

00:02:13.650 --> 00:02:14.340
for our clients.

00:02:14.340 --> 00:02:17.327
These are not API projects
just like Dart Polymer.

00:02:17.327 --> 00:02:19.660
And that's when I really
started getting exposed to Dart

00:02:19.660 --> 00:02:22.640
and enjoying it how well it
is because I was doing lots

00:02:22.640 --> 00:02:26.630
of JavaScript stuff, Angular,
JS, and just jQuery stuff

00:02:26.630 --> 00:02:28.890
and it was driving me crazy.

00:02:28.890 --> 00:02:31.600
Lastly, but not least, I
work at an amazing company

00:02:31.600 --> 00:02:32.904
called LEAGUE during the day.

00:02:32.904 --> 00:02:34.820
That's where I do lots
of Android development,

00:02:34.820 --> 00:02:37.850
completely separate from
Dart but, threw that in.

00:02:37.850 --> 00:02:41.360
So let's take a look
at The Backstory.

00:02:41.360 --> 00:02:43.210
The animated-- perfect.

00:02:43.210 --> 00:02:44.700
So this is a game.

00:02:44.700 --> 00:02:47.840
It's called the Market Wolf
and it's a native Android stock

00:02:47.840 --> 00:02:49.460
simulator game.

00:02:49.460 --> 00:02:52.330
If anyone wants to learn
how the stock market works

00:02:52.330 --> 00:02:54.120
you can download
this and play it.

00:02:54.120 --> 00:02:57.720
It's by no means full featured
but it's just a fun game

00:02:57.720 --> 00:02:59.242
and you can compare
with each other.

00:02:59.242 --> 00:03:01.450
And if you and your friends
are on there you can see,

00:03:01.450 --> 00:03:02.700
hey, I made a million dollars.

00:03:02.700 --> 00:03:03.670
You suck.

00:03:03.670 --> 00:03:05.580
All that stuff, right?

00:03:05.580 --> 00:03:08.860
Originally, it was
written in Node.js.

00:03:08.860 --> 00:03:10.610
It uses RethinkDB
as its data store

00:03:10.610 --> 00:03:14.120
in the back-end, uses
lots of WebSockets

00:03:14.120 --> 00:03:19.010
because we're scraping stuff
from Yahoo's stock ticker stuff

00:03:19.010 --> 00:03:22.430
and pushing it to your clients
so all that stuff has to happen

00:03:22.430 --> 00:03:24.350
in real-time, pseudo real-time.

00:03:24.350 --> 00:03:27.940
It's every like two
seconds because we're not

00:03:27.940 --> 00:03:31.600
going to pay NASDAQ for all
those stock ticker quotes.

00:03:31.600 --> 00:03:33.050
And it's medium size API.

00:03:33.050 --> 00:03:36.080
It's not tremendously large
but it's not like three lines.

00:03:36.080 --> 00:03:38.830
It facilitates a lot of stuff
like when you're buying stock,

00:03:38.830 --> 00:03:41.640
selling stock, searching
stocks, figuring out

00:03:41.640 --> 00:03:45.340
setting up stop limits
and all that crazy stuff.

00:03:45.340 --> 00:03:48.410
And now it's powered by a Dart
API, which is why I'm here.

00:03:48.410 --> 00:03:50.072
So let's take a look
at the live demo.

00:03:50.072 --> 00:03:51.530
And what's crazy
about this demo is

00:03:51.530 --> 00:03:53.870
I actually logged out
of the application

00:03:53.870 --> 00:03:57.116
so this is going to
be a bit interesting.

00:03:57.116 --> 00:03:58.750
All righty.

00:03:58.750 --> 00:04:00.699
So everyone can see that.

00:04:00.699 --> 00:04:01.990
I'm going to start Market Wolf.

00:04:01.990 --> 00:04:04.727
I hope everything works.

00:04:04.727 --> 00:04:06.060
So here it is, the login screen.

00:04:06.060 --> 00:04:09.070
So now all this is being
powered by Dart in the back-end.

00:04:09.070 --> 00:04:11.310
So when I hit sign-in
with Facebook, what we do

00:04:11.310 --> 00:04:13.410
is we get the user's
Facebook credentials

00:04:13.410 --> 00:04:16.010
and send over that
auth token to Dart.

00:04:16.010 --> 00:04:18.000
And then on Dart we
authenticate the user,

00:04:18.000 --> 00:04:20.649
see if he's registered and
all that fun stuff there.

00:04:20.649 --> 00:04:22.920
So I'm going to hit
it, fingers crossed.

00:04:22.920 --> 00:04:24.520
Hopefully it works.

00:04:24.520 --> 00:04:25.050
Boom.

00:04:25.050 --> 00:04:29.440
All right, so now we
show a litle [? FTE ?].

00:04:29.440 --> 00:04:31.720
Unfortunately, the stock
market is actually closed

00:04:31.720 --> 00:04:33.095
when I'm giving
this talk so what

00:04:33.095 --> 00:04:35.840
I did was I just rigged up our
server to send out random stock

00:04:35.840 --> 00:04:38.940
quotes, so which is why Amazon
is fluctuating like crazy right

00:04:38.940 --> 00:04:40.500
now.

00:04:40.500 --> 00:04:42.290
And so all that will work.

00:04:42.290 --> 00:04:45.060
And now I can hit start
searching for stocks.

00:04:45.060 --> 00:04:47.140
So if I'm searching
for Google, you

00:04:47.140 --> 00:04:48.640
can see it's happening
in real-time.

00:04:48.640 --> 00:04:50.632
That's our WebSocket stuff.

00:04:50.632 --> 00:04:51.340
Google coming in.

00:04:51.340 --> 00:04:53.050
I can hit it.

00:04:53.050 --> 00:04:54.980
It loads up the
Google stock thing.

00:04:54.980 --> 00:04:57.300
I can read a bunch of
news if I'm interested.

00:04:57.300 --> 00:04:59.510
And then I can buy
stock and all this

00:04:59.510 --> 00:05:02.090
is happening using
a Dart back-end.

00:05:02.090 --> 00:05:03.040
Hit Buy Stock.

00:05:03.040 --> 00:05:06.220
It goes and creates an account.

00:05:06.220 --> 00:05:08.380
And yeah, there we go.

00:05:08.380 --> 00:05:10.740
And also the most
important part of this

00:05:10.740 --> 00:05:14.020
is I'm able to compare my net
gain with all the other users

00:05:14.020 --> 00:05:15.220
on the system right now.

00:05:15.220 --> 00:05:17.720
So you can see [INAUDIBLE]
has lost a lot of money.

00:05:17.720 --> 00:05:21.080
He's in debt,
whereas I made $5,000

00:05:21.080 --> 00:05:25.330
and I think that's just because
I rigged up this entire thing.

00:05:25.330 --> 00:05:26.780
It's insider trading.

00:05:26.780 --> 00:05:30.035
So that's basically
the application.

00:05:33.940 --> 00:05:34.690
So it works.

00:05:34.690 --> 00:05:35.390
It was great.

00:05:35.390 --> 00:05:38.060
We actually built the Android
app about like six months ago,

00:05:38.060 --> 00:05:41.020
seven months ago in our free
time and we launched it.

00:05:41.020 --> 00:05:42.210
It has a different name.

00:05:42.210 --> 00:05:45.400
It was called Stock Market
Simulator back then.

00:05:45.400 --> 00:05:48.310
And then I started doing
a lot Dart development.

00:05:48.310 --> 00:05:52.070
I said, you know what, the
Node.js API is good but there

00:05:52.070 --> 00:05:54.640
are some difficulties in it.

00:05:54.640 --> 00:05:58.030
So why would I want to
switch from Node.js to Dart?

00:05:58.030 --> 00:06:00.780
Number one was the tooling and
debugging support for Node.js

00:06:00.780 --> 00:06:01.610
is a pain.

00:06:01.610 --> 00:06:05.100
Now there's WebStorm and
stuff but it's not as great

00:06:05.100 --> 00:06:07.730
as once I started
using Dart development.

00:06:07.730 --> 00:06:09.070
Dart felt good.

00:06:09.070 --> 00:06:12.420
Nose.js didn't feel right.

00:06:12.420 --> 00:06:14.750
I was already using Dart
and Polymer and stuff

00:06:14.750 --> 00:06:16.140
so I knew the Dart syntax.

00:06:16.140 --> 00:06:17.920
I liked it and I
wanted to learn more

00:06:17.920 --> 00:06:20.290
on how I can deploy
this on the server.

00:06:20.290 --> 00:06:23.710
Has anyone done any Dart
server development here?

00:06:23.710 --> 00:06:26.660
A few people, OK, great.

00:06:26.660 --> 00:06:28.840
So and Node didn't seem
to be the right answer.

00:06:28.840 --> 00:06:33.770
And the reason why is our API,
there's a WebSocket component.

00:06:33.770 --> 00:06:36.080
There is a real-time
stock fetching component.

00:06:36.080 --> 00:06:38.700
And there's a real-time
leaderboard updating.

00:06:38.700 --> 00:06:40.440
So if I kept the
application running,

00:06:40.440 --> 00:06:42.430
every five seconds a
leaderboard updates

00:06:42.430 --> 00:06:44.280
with my current
portfolio and everyone

00:06:44.280 --> 00:06:46.710
can see how much I made
and the next instance I

00:06:46.710 --> 00:06:48.510
lost all my life savings.

00:06:48.510 --> 00:06:50.160
So that's all that's happening.

00:06:50.160 --> 00:06:52.100
With a single Node.js
instance, which

00:06:52.100 --> 00:06:54.500
is single threaded and
running in an event loop,

00:06:54.500 --> 00:06:56.320
stuff starts
blocking because you

00:06:56.320 --> 00:06:58.250
are getting a lot
of stock quotes,

00:06:58.250 --> 00:07:00.180
parsing them out, and
putting into our data

00:07:00.180 --> 00:07:01.650
structures and all that stuff.

00:07:01.650 --> 00:07:04.160
So the architecture we
came up with for Node

00:07:04.160 --> 00:07:07.190
ended up being a three
instance node where they're all

00:07:07.190 --> 00:07:08.950
talking be a message broker.

00:07:08.950 --> 00:07:10.460
We had one instance
that controlled

00:07:10.460 --> 00:07:12.970
the API, one instance
that controlled

00:07:12.970 --> 00:07:14.601
the real-time
fetching and stuff.

00:07:14.601 --> 00:07:16.600
And the other instance
that kept the [INAUDIBLE]

00:07:16.600 --> 00:07:18.090
leaderboard up to date.

00:07:18.090 --> 00:07:20.330
It was fine but
again, our application

00:07:20.330 --> 00:07:22.096
we're not building
a massive game.

00:07:22.096 --> 00:07:23.970
We're just trying to
build something for fun.

00:07:23.970 --> 00:07:26.180
I didn't want to
maintain three servers

00:07:26.180 --> 00:07:29.300
or have a message broker
dependency and all that stuff.

00:07:29.300 --> 00:07:33.350
So with that in mind I
started looking into Dart

00:07:33.350 --> 00:07:36.430
and see how can Dart
relieve my pain there.

00:07:40.870 --> 00:07:43.840
They both had to win
when my affection.

00:07:43.840 --> 00:07:45.460
The investigation
was interesting.

00:07:45.460 --> 00:07:46.850
I started looking into it a lot.

00:07:46.850 --> 00:07:50.060
I discovered that just doing
Dart on the website and this

00:07:50.060 --> 00:07:52.130
was before async 0.8 came out.

00:07:52.130 --> 00:07:54.310
This was just when
async 0.8 came out

00:07:54.310 --> 00:07:57.550
so doing Dart web
development before and then

00:07:57.550 --> 00:08:01.470
coming to async 0.8 on
the server-side and stuff

00:08:01.470 --> 00:08:03.509
was really great because
I'm looking at Node.js

00:08:03.509 --> 00:08:04.800
and there's a lot of callbacks.

00:08:04.800 --> 00:08:08.640
So anyone that's done
Node development,

00:08:08.640 --> 00:08:10.240
we end up using promises.

00:08:10.240 --> 00:08:12.010
Promises are OK but
you still end up

00:08:12.010 --> 00:08:16.140
having this column then
then then then then fail.

00:08:16.140 --> 00:08:20.470
So sure it worked but
it wasn't amazing.

00:08:20.470 --> 00:08:24.050
And then when I started
looking at Dart's async 0.8

00:08:24.050 --> 00:08:25.860
that felt great.

00:08:25.860 --> 00:08:27.610
It felt like I
actually felt like all

00:08:27.610 --> 00:08:29.210
writing blocking code first.

00:08:29.210 --> 00:08:31.030
So I actually had to
get my mind across it

00:08:31.030 --> 00:08:32.530
that this was
actually going to work

00:08:32.530 --> 00:08:35.510
perfectly fine because the
syntax was that amazing.

00:08:35.510 --> 00:08:39.605
And right so before I
get into the differences,

00:08:39.605 --> 00:08:41.480
let's talk about a bit
about the similarities

00:08:41.480 --> 00:08:43.419
between both platforms.

00:08:43.419 --> 00:08:46.300
They're both great platforms
but not putting Node.js down.

00:08:46.300 --> 00:08:48.330
Node.js is absolutely amazing.

00:08:48.330 --> 00:08:50.960
Lots of large
companies are using it

00:08:50.960 --> 00:08:53.080
and Dart is equally
amazing, right.

00:08:53.080 --> 00:08:56.380
Lots of large companies as we
saw in the session yesterday,

00:08:56.380 --> 00:08:59.426
lots of companies
are using Dart too.

00:08:59.426 --> 00:09:01.300
And the benchmarks,
they're both pretty good.

00:09:01.300 --> 00:09:03.150
You can't say Dart sucks.

00:09:03.150 --> 00:09:04.017
Node.js is faster.

00:09:04.017 --> 00:09:04.600
Node.js sucks.

00:09:04.600 --> 00:09:05.183
Darts' faster.

00:09:05.183 --> 00:09:07.140
They're both equally
sometimes Dart's good.

00:09:07.140 --> 00:09:09.040
Sometimes Node.js
is a bit faster.

00:09:09.040 --> 00:09:12.030
They're both equal so
I wasn't afraid of that

00:09:12.030 --> 00:09:13.840
or I didn't care about
the benchmark stuff.

00:09:13.840 --> 00:09:17.130
I just cared about the
language and what it offered.

00:09:17.130 --> 00:09:18.980
Both are single threaded
and event based.

00:09:18.980 --> 00:09:21.850
And you might notice an asterisk
beside the single threaded

00:09:21.850 --> 00:09:24.970
and we'll get to that
in the next slide there.

00:09:24.970 --> 00:09:27.680
And both install and run
with a very, very low memory

00:09:27.680 --> 00:09:29.150
footprint.

00:09:29.150 --> 00:09:32.790
This is not ColdFusion where I
have to get a whole server up

00:09:32.790 --> 00:09:36.380
and running and hope to
God everything works fine.

00:09:36.380 --> 00:09:39.760
My actual application
ends up being 200 megs.

00:09:39.760 --> 00:09:42.540
And they're both JIT compiled
so everything runs fine.

00:09:42.540 --> 00:09:44.540
You know all this
stuff looks great.

00:09:44.540 --> 00:09:48.110
To me Dart and Node are equally
the same in that aspect.

00:09:48.110 --> 00:09:49.975
Differences though
are interesting.

00:09:49.975 --> 00:09:52.810
It is a different
programming paradigm.

00:09:52.810 --> 00:09:55.750
You know, Dart is
object-oriented,

00:09:55.750 --> 00:09:59.890
class based and Node.js
is JavaScript, you know,

00:09:59.890 --> 00:10:03.660
all the craziness that
comes a JavaScript.

00:10:07.060 --> 00:10:09.670
Node.js, if you want to take
advantage of multiple CPUs,

00:10:09.670 --> 00:10:13.060
you have to run multiple
instances of Node

00:10:13.060 --> 00:10:14.640
and behind a load balancer.

00:10:14.640 --> 00:10:17.060
So when I built a
real-time chat application

00:10:17.060 --> 00:10:19.850
that API was clustered
on the 16 core

00:10:19.850 --> 00:10:22.560
Amazon CPU and we had a
load balancer in front.

00:10:22.560 --> 00:10:23.960
Well all of them talked.

00:10:23.960 --> 00:10:25.070
Perfectly fine.

00:10:25.070 --> 00:10:27.820
But when you look into Dart
server-side development

00:10:27.820 --> 00:10:29.970
you can do the same thing.

00:10:29.970 --> 00:10:32.830
At the same time,
you can use isolates.

00:10:32.830 --> 00:10:37.710
And isolates lets you run one
node via one Dart instance

00:10:37.710 --> 00:10:44.080
and get multiple single threads
running on multiple CPUs.

00:10:44.080 --> 00:10:47.060
And we'll get into
isolates in just a second.

00:10:47.060 --> 00:10:48.740
This was a personal thing.

00:10:48.740 --> 00:10:51.180
There's no forever tool
to restart Dart servers

00:10:51.180 --> 00:10:52.290
when they crash.

00:10:52.290 --> 00:10:54.800
Node.js [INAUDIBLE]
something crashes you just

00:10:54.800 --> 00:10:57.560
restart the whole thing and
hope all the memory problems

00:10:57.560 --> 00:10:58.400
are gone.

00:10:58.400 --> 00:11:00.820
Dart doesn't have that, but
it's really easy to build.

00:11:00.820 --> 00:11:03.120
And I'll show you in a second.

00:11:03.120 --> 00:11:06.380
So with that in mind I
said, all right, great.

00:11:06.380 --> 00:11:09.841
Dart and Node seem good and
I'm leaning towards Dart

00:11:09.841 --> 00:11:11.340
so I might as well
just write a pros

00:11:11.340 --> 00:11:15.400
and cons list just to see if I'm
going in the right direction.

00:11:15.400 --> 00:11:18.290
Pro for Dart, it's better
profiling and debugging.

00:11:18.290 --> 00:11:22.030
I'm using WebStorm and
it is absolutely amazing.

00:11:22.030 --> 00:11:25.210
I can step debug than
the entire ID is great.

00:11:25.210 --> 00:11:27.390
Everything looks fine to
me and the biggest thing

00:11:27.390 --> 00:11:28.640
is Observatory, right.

00:11:28.640 --> 00:11:30.280
Node Inspector when
you're actually

00:11:30.280 --> 00:11:33.280
profiling Node application
is only so good.

00:11:33.280 --> 00:11:35.670
Observatory is like dang.

00:11:39.850 --> 00:11:42.850
Another pro is syntax
and language features.

00:11:42.850 --> 00:11:44.490
This is a personal
preference and I'm

00:11:44.490 --> 00:11:46.406
sure everyone here shares
the same preference.

00:11:46.406 --> 00:11:48.210
Dart syntax is great.

00:11:48.210 --> 00:11:52.850
Dart's language features are
great compared to JavaScript.

00:11:52.850 --> 00:11:55.720
Another one was organization
of code is better and enforced.

00:11:55.720 --> 00:11:59.270
So sure you have in Node
you have modules and stuff

00:11:59.270 --> 00:12:02.330
but Dart you have classes and
you can extend classes and all

00:12:02.330 --> 00:12:04.320
that really, really
fun stuff that

00:12:04.320 --> 00:12:05.860
keeps your application sane.

00:12:05.860 --> 00:12:10.270
Ane even in your mind keeps
everything very logical.

00:12:10.270 --> 00:12:14.320
It supports all major
databases on pub.Dart.

00:12:14.320 --> 00:12:17.840
You can find a driver for
most if not all databases

00:12:17.840 --> 00:12:20.340
with the exception that
there are some really

00:12:20.340 --> 00:12:23.130
esoteric databases that like
came out yesterday that you

00:12:23.130 --> 00:12:24.760
won't find Dart support for.

00:12:24.760 --> 00:12:26.680
So because they're
building Node.js drivers

00:12:26.680 --> 00:12:31.320
but don't trust the database
that came out yesterday.

00:12:31.320 --> 00:12:32.820
Now this is a pro and con.

00:12:32.820 --> 00:12:34.250
And I really
realized this when I

00:12:34.250 --> 00:12:35.666
started talking
to my friend who's

00:12:35.666 --> 00:12:37.750
helping me build this
application that there

00:12:37.750 --> 00:12:40.820
is a shift in thinking when
you're coming from Node.

00:12:40.820 --> 00:12:44.460
You're not thinking
like JavaScript anymore.

00:12:44.460 --> 00:12:45.980
You're thinking
class based stuff.

00:12:45.980 --> 00:12:48.110
You're thinking about async 0.8.

00:12:48.110 --> 00:12:50.040
It kind of takes
a bit of getting

00:12:50.040 --> 00:12:51.920
used to if you're
not so familiar

00:12:51.920 --> 00:12:54.910
with that type of language.

00:12:54.910 --> 00:12:56.530
And we just talked
about esoteric.

00:12:56.530 --> 00:12:58.880
So going over all this
stuff I'm like, all right,

00:12:58.880 --> 00:13:01.650
you know what, I think
I'm going to go with Dart.

00:13:01.650 --> 00:13:04.240
And I clapped and I
danced around a bit.

00:13:04.240 --> 00:13:05.940
And I said, OK now what?

00:13:05.940 --> 00:13:07.030
Now is the hard part.

00:13:07.030 --> 00:13:09.160
I actually have to
port the code over.

00:13:09.160 --> 00:13:13.020
So the application, initially,
the Node.js application

00:13:13.020 --> 00:13:14.490
was written in Express.

00:13:14.490 --> 00:13:17.710
And Express if you don't
know is like the most

00:13:17.710 --> 00:13:20.370
popular and powerful
framework in Node.

00:13:20.370 --> 00:13:22.080
Almost everyone uses it.

00:13:22.080 --> 00:13:26.320
And so I wanted to find the
Express alternative in Dart

00:13:26.320 --> 00:13:28.320
because I just want to
make that migration easy.

00:13:28.320 --> 00:13:30.653
I didn't want to come up with
a whole new way of writing

00:13:30.653 --> 00:13:32.760
API routing and stuff.

00:13:32.760 --> 00:13:36.050
So there's actually I found
three promising alternatives

00:13:36.050 --> 00:13:38.480
but there are countless
other alternatives.

00:13:38.480 --> 00:13:44.740
The three that I found were
Redstone, Shelf and RPC.

00:13:44.740 --> 00:13:48.080
Now let's talk a bit about--
let's talk about Redstone.

00:13:48.080 --> 00:13:50.890
Has anyone here used
Redstone in the past?

00:13:50.890 --> 00:13:51.910
OK, a few of you.

00:13:51.910 --> 00:13:53.340
OK, cool.

00:13:53.340 --> 00:13:56.670
So Redstone is a API
framework like Express.

00:13:56.670 --> 00:13:59.710
It's actively developed
by the community.

00:13:59.710 --> 00:14:01.630
It's very, very
express-y and we'll

00:14:01.630 --> 00:14:04.420
take a look at a code
snippet in just second.

00:14:04.420 --> 00:14:07.220
It's good community support
for middlewares and plugins.

00:14:07.220 --> 00:14:10.390
So there's a PostgresSQL Mapper.

00:14:10.390 --> 00:14:13.930
There's a MongoDB ORM mapper,
session management stuff,

00:14:13.930 --> 00:14:16.200
a static HTML, a server.

00:14:16.200 --> 00:14:19.240
So it's pretty,
pretty express-y.

00:14:19.240 --> 00:14:23.090
If you take a look at the code,
here's an Express code snippet.

00:14:23.090 --> 00:14:26.420
Very easy to understand but
messy because it's JavaScript.

00:14:26.420 --> 00:14:30.130
And here is Redstone, right.

00:14:30.130 --> 00:14:33.930
Even a preschool kid can go, hey
look, they look really similar.

00:14:33.930 --> 00:14:37.650
So Redstone is really, really,
really similar to Express.

00:14:37.650 --> 00:14:41.930
And in my opinion it is the
Express of the Dart world.

00:14:41.930 --> 00:14:43.760
And so it's really clear.

00:14:43.760 --> 00:14:45.024
It's also easy to understand.

00:14:45.024 --> 00:14:46.440
And there's good
community support

00:14:46.440 --> 00:14:49.390
so if you run into issues,
just ask on Stack Overflow

00:14:49.390 --> 00:14:52.210
or just go to the
GitHub issue page

00:14:52.210 --> 00:14:55.040
and people will
answer and help out.

00:14:55.040 --> 00:14:57.124
But I didn't want to just
go, OK, Redstone, I'm

00:14:57.124 --> 00:14:57.790
going to use it.

00:14:57.790 --> 00:14:58.620
Forget about the other two.

00:14:58.620 --> 00:14:59.980
I wanted to check my options.

00:14:59.980 --> 00:15:01.620
I don't want to make a mistake.

00:15:01.620 --> 00:15:03.610
So I took a look at Shelf .

00:15:03.610 --> 00:15:08.550
Turns out Redstone is actually
built on top of Shelf.

00:15:08.550 --> 00:15:11.160
So Shelf is the
base of Redstone.

00:15:11.160 --> 00:15:12.870
It's very minimal.

00:15:12.870 --> 00:15:15.020
It's not actually
an API framework.

00:15:15.020 --> 00:15:18.380
You can use those components to
build an API framework really

00:15:18.380 --> 00:15:20.900
easily.

00:15:20.900 --> 00:15:21.970
It doesn't have routing.

00:15:21.970 --> 00:15:23.380
So if you want to
use routing you

00:15:23.380 --> 00:15:25.040
have to use a third
party middleware,

00:15:25.040 --> 00:15:27.580
or I think it's
provided by Shelf.

00:15:27.580 --> 00:15:29.790
And a bunch of
Redstone's middlewares

00:15:29.790 --> 00:15:32.850
are actually Shelf's middlewares
so if you are using Redstone

00:15:32.850 --> 00:15:36.910
you can get all of Shelf's
middlewares running there.

00:15:36.910 --> 00:15:39.580
And it's a simple API so let's
take a look at an Express

00:15:39.580 --> 00:15:40.540
example.

00:15:40.540 --> 00:15:41.880
That's how Express is.

00:15:41.880 --> 00:15:45.530
And if you take a look at Shelf
that's how Shelf is, right.

00:15:45.530 --> 00:15:47.260
Again, very simple.

00:15:47.260 --> 00:15:49.740
So if you don't really
need all of Redstone's

00:15:49.740 --> 00:15:52.890
powerful features, you just want
to build a very bare bones API,

00:15:52.890 --> 00:15:55.550
then go with Shelf.

00:15:55.550 --> 00:15:58.982
It's easy.

00:15:58.982 --> 00:16:00.440
And it's also made
by the Dart team

00:16:00.440 --> 00:16:02.350
so you're not going
to go wrong there.

00:16:02.350 --> 00:16:05.010
The last one that
I found was RPC.

00:16:05.010 --> 00:16:07.730
And this was an interesting one.

00:16:07.730 --> 00:16:12.990
RPC is a package for building
RESTful server-side RPC style

00:16:12.990 --> 00:16:13.850
APIs.

00:16:13.850 --> 00:16:15.440
And it's the newest
one of the two.

00:16:15.440 --> 00:16:19.410
It actually just went public
a few months ago I think.

00:16:19.410 --> 00:16:22.980
And it's interesting
because you can write--

00:16:22.980 --> 00:16:25.600
when you write an API
it's very self-documenting

00:16:25.600 --> 00:16:27.160
and that's what I loved a lot.

00:16:27.160 --> 00:16:29.990
You're using a lot of
annotations kind of like Shelf

00:16:29.990 --> 00:16:35.500
but you're adding a bit more
information to your API.

00:16:35.500 --> 00:16:37.369
So if we take a look at Express.

00:16:37.369 --> 00:16:39.160
Again, we're all going
to use that example.

00:16:39.160 --> 00:16:41.962
Here's the RPC example.

00:16:41.962 --> 00:16:43.670
You know, you're
importing a toyapi.dart.

00:16:43.670 --> 00:16:47.414
And we'll take a look at what
toyapi is in the next slide.

00:16:47.414 --> 00:16:48.830
And then you've
got an API server.

00:16:48.830 --> 00:16:51.610
You're adding it and you're
setting up a Discovery API

00:16:51.610 --> 00:16:55.490
and then you're saying, hey,
I'm listening on port 8080.

00:16:55.490 --> 00:17:00.870
toyapi.dart is just a class that
you can have your gets, puts,

00:17:00.870 --> 00:17:02.830
posts, all that stuff there.

00:17:02.830 --> 00:17:06.880
And It's very easy and you can
see that it's very descriptive

00:17:06.880 --> 00:17:08.599
An Android developer
like the developer

00:17:08.599 --> 00:17:10.140
that built the app
can come on and be

00:17:10.140 --> 00:17:11.629
like OK, that's the actual API.

00:17:11.629 --> 00:17:13.920
I don't have to generate lots
and lots of documentation

00:17:13.920 --> 00:17:15.619
for it.

00:17:15.619 --> 00:17:17.310
So it's a bit more verbose.

00:17:17.310 --> 00:17:18.710
It's not as clean.

00:17:18.710 --> 00:17:23.270
I mean it is clean but it's not
as short as Redstone or Shelf.

00:17:23.270 --> 00:17:27.920
But I think I like it because
it's very self-documenting.

00:17:27.920 --> 00:17:29.920
One great feature
about it though,

00:17:29.920 --> 00:17:32.350
that you can generate
client-side libraries

00:17:32.350 --> 00:17:34.530
using Google's Discovery
Document Format.

00:17:34.530 --> 00:17:37.330
So you can have client-side
libraries for Java, Python,

00:17:37.330 --> 00:17:38.680
a bunch of crazy stuff.

00:17:38.680 --> 00:17:39.607
And it's great.

00:17:39.607 --> 00:17:41.190
And again, it's made
by that Dart team

00:17:41.190 --> 00:17:42.930
so you can't go wrong there.

00:17:42.930 --> 00:17:45.540
I went with RPC.

00:17:45.540 --> 00:17:48.500
Next, the requirement
here was we

00:17:48.500 --> 00:17:51.000
had this Socket.IO server
pushing stock quotes

00:17:51.000 --> 00:17:54.250
to the Android devices.

00:17:54.250 --> 00:17:57.750
So we had to find a Socket.IO
alternative for Dart.

00:17:57.750 --> 00:18:00.370
Luckily, we didn't
have to go far.

00:18:00.370 --> 00:18:02.000
Dart comes natively
with WebSockets.

00:18:02.000 --> 00:18:03.670
This was an amazing feature.

00:18:03.670 --> 00:18:12.710
All I had to do literally was
new WebSocket and it worked.

00:18:12.710 --> 00:18:19.320
This is WebSocket's
integrated with Dart RPC.

00:18:19.320 --> 00:18:20.800
So I'm listening
to RPC, then I'm

00:18:20.800 --> 00:18:23.430
saying OK, if the web
request path is [? WS ?],

00:18:23.430 --> 00:18:26.270
then pass that to the
web transformer upgrade.

00:18:26.270 --> 00:18:30.050
And then handle all the messages
that come into the socket.

00:18:30.050 --> 00:18:30.550
Done.

00:18:30.550 --> 00:18:31.880
We had WebSockets working.

00:18:31.880 --> 00:18:33.560
We had the API working.

00:18:33.560 --> 00:18:36.730
Great, so how do we
get them all together?

00:18:36.730 --> 00:18:38.160
Actually write all this stuff.

00:18:40.680 --> 00:18:41.180
Yes.

00:18:41.180 --> 00:18:41.450
OK.

00:18:41.450 --> 00:18:42.310
So thinking in Dart.

00:18:42.310 --> 00:18:44.380
This was the most
key thing that I

00:18:44.380 --> 00:18:50.470
discovered while writing
Market Wolf in Dart.

00:18:50.470 --> 00:18:52.240
Our basic API,
just to reiterate,

00:18:52.240 --> 00:18:54.560
was our basic
architecture was we had

00:18:54.560 --> 00:18:56.100
to fetch stocks in real-time.

00:18:56.100 --> 00:18:58.660
We had to keep the leaderboard
updated in real-time.

00:18:58.660 --> 00:19:01.030
And we also had to serve
all the API requests.

00:19:01.030 --> 00:19:02.660
Node single event
loop [INAUDIBLE]

00:19:02.660 --> 00:19:04.701
back because there's lots
of processing happening

00:19:04.701 --> 00:19:07.880
at every event loop so we ended
up splitting it into three.

00:19:07.880 --> 00:19:10.890
Here's the architecture
again if you guys forgot.

00:19:10.890 --> 00:19:12.200
Three stuff there.

00:19:12.200 --> 00:19:15.060
But in Dart it's very
easy to replicate that.

00:19:15.060 --> 00:19:17.790
I can literally just run
three Dart instances,

00:19:17.790 --> 00:19:19.260
put a load
[INAUDIBLE] the front.

00:19:19.260 --> 00:19:20.360
Everything works.

00:19:20.360 --> 00:19:22.700
But I found out about
isolates and that just

00:19:22.700 --> 00:19:25.410
changed my entire
way of thinking.

00:19:25.410 --> 00:19:28.000
Isolates are pretty interesting.

00:19:28.000 --> 00:19:30.090
Every Dart application
runs in an isolate so

00:19:30.090 --> 00:19:31.730
when you first
run an application

00:19:31.730 --> 00:19:33.520
that itself an isolate.

00:19:33.520 --> 00:19:35.030
An isolate is an
independent worker

00:19:35.030 --> 00:19:36.696
that runs on its own
memory so you can't

00:19:36.696 --> 00:19:38.520
have variables being shared.

00:19:38.520 --> 00:19:40.500
But if you do want to
talk to other isolates

00:19:40.500 --> 00:19:43.290
you can talk to them via
send and receive ports.

00:19:43.290 --> 00:19:46.940
What's great about this is
we took those three cores

00:19:46.940 --> 00:19:48.960
and I made that
into three isolates.

00:19:48.960 --> 00:19:51.204
I had one isolate serving
all the API stuff,

00:19:51.204 --> 00:19:52.620
one isolate for
the stock venture,

00:19:52.620 --> 00:19:54.420
and one isolate for
the real-time stuff.

00:19:54.420 --> 00:19:57.750
All of them are running on one
VM instance but on three cores.

00:19:57.750 --> 00:20:00.464
It actually made
ops a lot easier.

00:20:00.464 --> 00:20:01.380
I just had one server.

00:20:01.380 --> 00:20:04.780
I didn't have to deal with load
balances or anything like that.

00:20:04.780 --> 00:20:07.130
Here's how you just
talk to an isolate.

00:20:07.130 --> 00:20:10.400
You create a new receiver
port, you spot an isolate,

00:20:10.400 --> 00:20:12.022
serviceisolate.leaderboard
service

00:20:12.022 --> 00:20:13.480
is actually the
method that's going

00:20:13.480 --> 00:20:15.140
to run inside the isolate.

00:20:15.140 --> 00:20:18.500
That has a for loop I think,
or a while loop, just fetching

00:20:18.500 --> 00:20:20.320
stocks constantly.

00:20:20.320 --> 00:20:23.030
And then I start the isolate up.

00:20:23.030 --> 00:20:24.990
This fit perfectly
with our design.

00:20:24.990 --> 00:20:29.000
So if we take a look at our
node architecture, and now

00:20:29.000 --> 00:20:32.130
our Dart architecture, it's all
very self-contained, very nice.

00:20:32.130 --> 00:20:35.300
It works perfectly
fine and each isolate

00:20:35.300 --> 00:20:38.560
takes a very, very low amount
of memory, just 1.5 megs.

00:20:38.560 --> 00:20:40.560
And it's light weight
enough to do the job well.

00:20:40.560 --> 00:20:43.070
I've heard that the Dart
team is improving the API,

00:20:43.070 --> 00:20:46.920
going to make that even smaller
so that's no cost to running

00:20:46.920 --> 00:20:48.090
isolates.

00:20:48.090 --> 00:20:49.630
What's cool is
that you can listen

00:20:49.630 --> 00:20:54.800
to isolates get created and
die so if we go back to that

00:20:54.800 --> 00:20:57.251
forever in Node where
whenever a Node app dies

00:20:57.251 --> 00:20:58.250
you can just restart it.

00:20:58.250 --> 00:21:00.160
You can actually just
listen to your API

00:21:00.160 --> 00:21:03.270
isolate or any of these
other isolates and go hey,

00:21:03.270 --> 00:21:04.030
did you die?

00:21:04.030 --> 00:21:04.950
Why did you die?

00:21:04.950 --> 00:21:06.300
OK, I'm going to restart.

00:21:06.300 --> 00:21:09.043
So you can have this
constant as soon

00:21:09.043 --> 00:21:12.120
as it crashes restart the app
again, send out a crash report,

00:21:12.120 --> 00:21:12.620
whatever.

00:21:12.620 --> 00:21:13.737
You can do all that stuff.

00:21:13.737 --> 00:21:15.820
You can also steal across
multiple servers, right?

00:21:15.820 --> 00:21:17.780
There's nothing stopping
you from taking this

00:21:17.780 --> 00:21:20.710
and creating four other
servers and putting

00:21:20.710 --> 00:21:22.010
inside a load balancer.

00:21:22.010 --> 00:21:25.844
Isolates just logically
they make clear sense to me

00:21:25.844 --> 00:21:27.510
and when you're writing
code it actually

00:21:27.510 --> 00:21:30.300
works really, really well.

00:21:30.300 --> 00:21:33.224
Isolates are a game changer
when you develop and imagine

00:21:33.224 --> 00:21:35.390
if you're doing long running
database operations you

00:21:35.390 --> 00:21:36.585
can just launch an isolate.

00:21:36.585 --> 00:21:39.040
It does its stuff
in the back-end

00:21:39.040 --> 00:21:41.340
and just goes to sleep.

00:21:41.340 --> 00:21:42.870
So now we had all this working.

00:21:42.870 --> 00:21:48.300
I was happy but then we ran
into bugs unfortunately.

00:21:48.300 --> 00:21:52.680
So or fortunately
actually because in Node,

00:21:52.680 --> 00:21:54.410
console.log becomes
your best friend.

00:21:54.410 --> 00:21:57.070
All you do in Node.js
is console.log.

00:21:57.070 --> 00:21:59.030
And then as a last
resort you'll set up

00:21:59.030 --> 00:22:02.030
like breakpoint debugging
or go to Node Inspector

00:22:02.030 --> 00:22:05.340
and try to figure
all that stuff out.

00:22:05.340 --> 00:22:07.200
So especially when
you have a memory leak

00:22:07.200 --> 00:22:08.659
you're kind of out
of luck on Node.

00:22:08.659 --> 00:22:10.116
You got to start
up Node Inspector,

00:22:10.116 --> 00:22:12.040
really try to find out
what's happening there.

00:22:12.040 --> 00:22:14.760
But we had a memory leak
with our stock fetcher.

00:22:14.760 --> 00:22:16.170
Something was leaking.

00:22:16.170 --> 00:22:19.220
Luckily, Dart comes
with Observatories.

00:22:19.220 --> 00:22:20.320
Everyone knows.

00:22:20.320 --> 00:22:24.160
And that made the process
of debugging so much easier.

00:22:24.160 --> 00:22:25.750
And what's great
is you can listen,

00:22:25.750 --> 00:22:28.510
you can look at all your
isolates in this memory map.

00:22:28.510 --> 00:22:31.456
So I didn't have to go
look through tons and tons

00:22:31.456 --> 00:22:32.830
of stack traces
to find out where

00:22:32.830 --> 00:22:34.750
my isolate was being executed.

00:22:34.750 --> 00:22:36.520
All I had to do was
just click on OK,

00:22:36.520 --> 00:22:38.030
here's my stock fetcher isolate.

00:22:38.030 --> 00:22:40.010
Let's see what's
happening in there.

00:22:40.010 --> 00:22:43.450
I can also see all the memory
stuff with the foreign isolate,

00:22:43.450 --> 00:22:45.590
see how much memory
it's taking, see

00:22:45.590 --> 00:22:48.750
what's taking a lot of
memory, how much is free,

00:22:48.750 --> 00:22:51.780
how much is not free, see
the heat map, the allocation

00:22:51.780 --> 00:22:52.640
profile.

00:22:52.640 --> 00:22:55.610
So we ended up having
where the hashmap that

00:22:55.610 --> 00:22:57.610
held onto the stocks
kept increasing.

00:22:57.610 --> 00:22:58.965
We weren't clearing stuff out.

00:22:58.965 --> 00:23:00.710
It was getting way too large.

00:23:00.710 --> 00:23:04.570
So using Observatory we solved
that in like ten minutes.

00:23:04.570 --> 00:23:08.570
And then we can get
back to dancing around.

00:23:08.570 --> 00:23:11.100
So debugging in Dart
was absolutely amazing.

00:23:11.100 --> 00:23:12.470
Everything was ready to go.

00:23:12.470 --> 00:23:15.830
We were about to launch
this and we were like OK,

00:23:15.830 --> 00:23:16.570
we forgot a step.

00:23:16.570 --> 00:23:18.740
We actually have to
deploy it to the server.

00:23:18.740 --> 00:23:21.650
So how are we going to
deploy it to the server?

00:23:21.650 --> 00:23:25.180
Originally, the application
used AWS Beanstalk.

00:23:25.180 --> 00:23:28.400
So the first thing I did
was log onto aws.com,

00:23:28.400 --> 00:23:30.490
go to new instance
for Beanstalk,

00:23:30.490 --> 00:23:34.700
and then get bummed out
that this says no JS, PHP,

00:23:34.700 --> 00:23:36.740
Python, but no Dart.

00:23:36.740 --> 00:23:37.240
Right?

00:23:37.240 --> 00:23:41.920
However, implicitly
it did say Dart.

00:23:41.920 --> 00:23:44.400
It said Docker.

00:23:44.400 --> 00:23:47.260
And what's great
is that you can run

00:23:47.260 --> 00:23:50.760
Dart on any server that supports
Docker because the Google

00:23:50.760 --> 00:23:53.170
team-- skip a bit here.

00:23:53.170 --> 00:23:56.270
The Google team has already
deployed, already built

00:23:56.270 --> 00:23:58.740
a Docker image for us
to deploy on Beanstalk.

00:23:58.740 --> 00:24:01.426
If you don't know what Beanstalk
is Beanstalk is really just

00:24:01.426 --> 00:24:04.650
an easy way to run your
application on Amazon's cloud

00:24:04.650 --> 00:24:07.460
and they'll handle auto
provisioning, scaling,

00:24:07.460 --> 00:24:08.620
load balancing for you.

00:24:08.620 --> 00:24:10.340
So you don't have
to set all that up.

00:24:10.340 --> 00:24:12.750
You just have to create servers
and tell Amazon these are

00:24:12.750 --> 00:24:14.250
the servers I want you to use.

00:24:14.250 --> 00:24:15.430
Go nuts.

00:24:15.430 --> 00:24:17.230
And so Amazon will
do that for you.

00:24:17.230 --> 00:24:20.860
So Docker file is
really simple to use.

00:24:20.860 --> 00:24:24.790
It's like
1-2-3-4-5-6-7-8-9-10 lines.

00:24:24.790 --> 00:24:28.355
And you've got your
application ready to go.

00:24:28.355 --> 00:24:31.540
I import from Google/Dart.

00:24:31.540 --> 00:24:33.000
I create my working directory.

00:24:33.000 --> 00:24:33.830
I add the pubspec.

00:24:33.830 --> 00:24:35.950
I add all the files.

00:24:35.950 --> 00:24:37.530
I do pub get.

00:24:37.530 --> 00:24:40.260
And then I expose
the port on 3030.

00:24:40.260 --> 00:24:44.550
And then I tell Docker when
you run, call bin/server.dart.

00:24:47.380 --> 00:24:49.850
Now that we had that ready
there's just one more thing

00:24:49.850 --> 00:24:52.140
that you need to do on AWS.

00:24:52.140 --> 00:24:56.280
You need to create a
[? dockerfile.aws.json. ?]

00:24:56.280 --> 00:24:59.450
And what that tells AWS
is, hey, my Docker instance

00:24:59.450 --> 00:25:02.860
is going to run on port
3030 so keep that in mind

00:25:02.860 --> 00:25:03.880
when I'm deploying.

00:25:03.880 --> 00:25:07.080
So expose the port, set up the
right firewall configurations,

00:25:07.080 --> 00:25:10.010
load balancing, all the
crazy stuff that you do.

00:25:10.010 --> 00:25:11.730
Once you have that
really it's just

00:25:11.730 --> 00:25:14.900
a matter of using their
AWS command line tools

00:25:14.900 --> 00:25:16.799
and typing in eb deploy.

00:25:16.799 --> 00:25:19.090
It's the most simplest way
to deploy a Dart application

00:25:19.090 --> 00:25:21.020
in my opinion.

00:25:21.020 --> 00:25:23.450
eb deploy, it
uploads it, runs it.

00:25:23.450 --> 00:25:24.700
Everything's great.

00:25:24.700 --> 00:25:26.700
Alternatively, what
you could also do

00:25:26.700 --> 00:25:29.650
was use a service like
a continuous integration

00:25:29.650 --> 00:25:31.380
service like Codeship.

00:25:31.380 --> 00:25:34.470
So I ended up doing, ended up
writing a bunch of unit tests

00:25:34.470 --> 00:25:38.550
and whenever I do git push
origin master whatever,

00:25:38.550 --> 00:25:42.020
Codeship would pick that up,
figure it out, run its unit

00:25:42.020 --> 00:25:43.230
tests on it.

00:25:43.230 --> 00:25:45.190
Once that's done it
without automatically

00:25:45.190 --> 00:25:47.750
deploy to AWS Beanstalk
with the right Docker

00:25:47.750 --> 00:25:49.120
file and Docker AWS.

00:25:49.120 --> 00:25:52.920
So there was this continuous
loop of continuous integration

00:25:52.920 --> 00:25:53.632
and deployment.

00:25:53.632 --> 00:25:55.590
That's actually what I
did like ten minutes ago

00:25:55.590 --> 00:25:57.381
when I had to make sure
the stock stuff was

00:25:57.381 --> 00:26:00.790
all dynamic and random.

00:26:00.790 --> 00:26:03.670
Was all this worth it?

00:26:03.670 --> 00:26:04.770
Apparently not.

00:26:04.770 --> 00:26:06.900
All right.

00:26:06.900 --> 00:26:10.020
So was all this worth it?

00:26:10.020 --> 00:26:12.140
I think it took us
about a week to do this.

00:26:12.140 --> 00:26:15.900
Not a lot of manpower
but really took

00:26:15.900 --> 00:26:18.930
already something that worked
and just moved it to Dart.

00:26:18.930 --> 00:26:19.980
I think it was.

00:26:19.980 --> 00:26:22.080
There's no question about it.

00:26:22.080 --> 00:26:23.920
Dart's syntax, the
language features,

00:26:23.920 --> 00:26:27.490
isolates, Observatory, all
that really, really cool stuff,

00:26:27.490 --> 00:26:30.280
made a compelling
case to move to Dart.

00:26:30.280 --> 00:26:32.050
Like when I look
back on Node.js code

00:26:32.050 --> 00:26:33.770
it feels like I'm
writing assembly.

00:26:33.770 --> 00:26:36.620
Right, it's just
very archaic now.

00:26:36.620 --> 00:26:39.190
There's lots of callbacks,
stuffs all over the place,

00:26:39.190 --> 00:26:41.420
and just feels weird.

00:26:41.420 --> 00:26:46.320
Do we find anything missing that
we go OK, I wish Dart had that.

00:26:46.320 --> 00:26:48.060
Node.js does.

00:26:48.060 --> 00:26:48.880
Absolutely not.

00:26:48.880 --> 00:26:50.410
Everything that
we needed in terms

00:26:50.410 --> 00:26:55.900
of the packages, the tooling,
the support, the language

00:26:55.900 --> 00:26:58.220
features, everything's
there in Dart.

00:26:58.220 --> 00:27:01.530
Actually there's stuff
missing from Node.

00:27:01.530 --> 00:27:04.590
And the number lines of code
shrunk dramatically too.

00:27:04.590 --> 00:27:07.060
I think that's because of
all the callbacks and stuff.

00:27:07.060 --> 00:27:08.450
But also because stuff's easier.

00:27:08.450 --> 00:27:11.240
We don't have to import a lot
of dependencies and set that up.

00:27:11.240 --> 00:27:12.640
Socket.IO is a dependency.

00:27:12.640 --> 00:27:13.840
So you have to set that up.

00:27:13.840 --> 00:27:16.080
In Dart it's just new WebSocket.

00:27:16.080 --> 00:27:18.380
And there's a bunch
of other examples

00:27:18.380 --> 00:27:22.480
where it was just really,
really simple to get Dart up

00:27:22.480 --> 00:27:22.980
and running.

00:27:22.980 --> 00:27:26.060
Whereas Node you had to
import a few libraries

00:27:26.060 --> 00:27:29.470
just to make that
code more sane.

00:27:29.470 --> 00:27:31.750
In short, moving
from Node.js to Dart

00:27:31.750 --> 00:27:33.270
was the best decision we made.

00:27:33.270 --> 00:27:35.361
For us all API
projects moving forward

00:27:35.361 --> 00:27:36.360
will be written in Dart.

00:27:36.360 --> 00:27:40.650
So any new, cool thing I
do that will be in Dart.

00:27:40.650 --> 00:27:42.390
Thank you.

