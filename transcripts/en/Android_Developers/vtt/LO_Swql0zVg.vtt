WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.832
[MUSIC PLAYING]

00:00:05.469 --> 00:00:06.760
RAN NACHMANY: Hello, everybody.

00:00:06.760 --> 00:00:07.720
My name is Ran.

00:00:07.720 --> 00:00:10.015
And actually I'm
from Israel, and I

00:00:10.015 --> 00:00:13.040
lead the developer relation
out in Google Tel Aviv.

00:00:13.040 --> 00:00:16.180
And today I'm going to
talk to you about battery

00:00:16.180 --> 00:00:19.970
and how it can be more
efficient in that manner.

00:00:19.970 --> 00:00:23.440
But first I would like
to make a quick poll.

00:00:23.440 --> 00:00:24.170
Looks familiar?

00:00:24.170 --> 00:00:27.020
Anybody use this?

00:00:27.020 --> 00:00:29.520
Raise your hand.

00:00:29.520 --> 00:00:30.810
OK.

00:00:30.810 --> 00:00:32.250
What about this code snippet?

00:00:32.250 --> 00:00:34.230
Anybody wrote something
similar to this?

00:00:34.230 --> 00:00:37.880
Opening HTP connection,
fetching some websites.

00:00:37.880 --> 00:00:39.439
Raise your hand, guys.

00:00:39.439 --> 00:00:40.480
OK, let's do it this way.

00:00:40.480 --> 00:00:43.142
Anybody didn't write
something like that?

00:00:43.142 --> 00:00:44.910
[LAUGHTER]

00:00:44.910 --> 00:00:45.540
Get out.

00:00:45.540 --> 00:00:46.040
Anyway.

00:00:48.710 --> 00:00:50.500
OK, so you must be
asking yourself,

00:00:50.500 --> 00:00:52.190
hey, everybody's doing it.

00:00:52.190 --> 00:00:53.380
What's the big deal here?

00:00:53.380 --> 00:00:57.882
Why we've got this
weird guy talking?

00:00:57.882 --> 00:01:00.340
Accessing the network, fetching
some data over the internet

00:01:00.340 --> 00:01:01.280
is commodity.

00:01:01.280 --> 00:01:02.620
Everybody is doing it.

00:01:02.620 --> 00:01:04.400
What's the big story here?

00:01:04.400 --> 00:01:06.550
Well, it turns
out that accessing

00:01:06.550 --> 00:01:08.936
the network, like
opening HTTP connection

00:01:08.936 --> 00:01:13.170
or especially on
cellular networks,

00:01:13.170 --> 00:01:16.210
it has a significant
impact on battery life.

00:01:16.210 --> 00:01:19.930
In fact, that's the number
one battery killer today.

00:01:19.930 --> 00:01:23.980
If you check and see
what apps are doing,

00:01:23.980 --> 00:01:26.250
what's killing your battery,
what apps are actually

00:01:26.250 --> 00:01:29.810
doing on your phone that kills
your battery, it won't be GPS.

00:01:29.810 --> 00:01:30.810
It won't be the screen.

00:01:30.810 --> 00:01:33.530
It will be network.

00:01:33.530 --> 00:01:37.170
It's true, GPS is a pretty
good battery hogger,

00:01:37.170 --> 00:01:39.290
but most of the time it's off.

00:01:39.290 --> 00:01:40.890
While accessing
the network, apps

00:01:40.890 --> 00:01:42.720
are always accessing
the network,

00:01:42.720 --> 00:01:44.990
and today we're going to fix it,

00:01:44.990 --> 00:01:46.670
And if you still
ask yourself why

00:01:46.670 --> 00:01:48.710
we should care
about battery life,

00:01:48.710 --> 00:01:51.630
I can share with you a research
that we've done at Google.

00:01:51.630 --> 00:01:54.280
It took us years to
conduct this research.

00:01:54.280 --> 00:01:57.797
And we learned that
when the phone is dead--

00:01:57.797 --> 00:01:58.880
there's no battery before.

00:01:58.880 --> 00:02:02.850
The phone is dead-- the user
is less likely to use any app.

00:02:02.850 --> 00:02:04.830
[LAUGHTER]

00:02:04.830 --> 00:02:07.000
Yours as well, OK?

00:02:07.000 --> 00:02:12.270
So you may want to keep the
phone running a little longer.

00:02:12.270 --> 00:02:13.720
So the first thing
that we'll do,

00:02:13.720 --> 00:02:16.460
we will try to
understand how things

00:02:16.460 --> 00:02:19.810
are working under the
scene-- behind the scene,

00:02:19.810 --> 00:02:21.160
under the hood.

00:02:21.160 --> 00:02:24.050
How so networks are
actually working.

00:02:24.050 --> 00:02:28.880
So it turns out that
wireless phone like this one

00:02:28.880 --> 00:02:31.280
are actually wireless.

00:02:31.280 --> 00:02:33.850
There's no cable here, right?

00:02:33.850 --> 00:02:36.790
We rely on radio transmission,
radio communication

00:02:36.790 --> 00:02:40.020
back and forth from my
cell phone to a cell tower

00:02:40.020 --> 00:02:42.145
to a base station which
is located out there.

00:02:42.145 --> 00:02:43.930
This means that
inside the phone,

00:02:43.930 --> 00:02:46.600
there's a little chip
set with the radio

00:02:46.600 --> 00:02:49.580
transmitter and receiver
that transmits radio

00:02:49.580 --> 00:02:53.135
frequency, radio communication
to the base station, which

00:02:53.135 --> 00:02:56.180
receives the communication,
processes it, and sends

00:02:56.180 --> 00:02:58.010
some stuff back.

00:02:58.010 --> 00:03:01.470
Now every communication, every
time we want to send something,

00:03:01.470 --> 00:03:04.040
we need frequency.

00:03:04.040 --> 00:03:08.960
We use frequency, and
frequency is expensive

00:03:08.960 --> 00:03:10.809
because frequency is limited.

00:03:10.809 --> 00:03:11.850
It's a physical resource.

00:03:11.850 --> 00:03:13.260
It's not IP.

00:03:13.260 --> 00:03:14.875
We're running out of IP address.

00:03:14.875 --> 00:03:17.960
Let's make IPv6, and
suddenly we have more.

00:03:17.960 --> 00:03:19.920
It's a physical thing.

00:03:19.920 --> 00:03:22.280
It's a physical limitation.

00:03:22.280 --> 00:03:23.300
Think of this room.

00:03:23.300 --> 00:03:25.480
There's only so much
space inside this room.

00:03:25.480 --> 00:03:28.690
I cannot put 1,000,000
people inside this room,

00:03:28.690 --> 00:03:30.260
just not enough space.

00:03:30.260 --> 00:03:31.725
Same thing with frequency.

00:03:31.725 --> 00:03:35.630
We don't have enough frequency,
and actually the cell tower

00:03:35.630 --> 00:03:39.790
cannot speak and communicate
and talk and allocate frequency

00:03:39.790 --> 00:03:44.350
to 100% of its clients
100% of the time,

00:03:44.350 --> 00:03:46.610
simply doesn't make it.

00:03:46.610 --> 00:03:50.150
So instead, the cell tower--
I'm going to give you a moment

00:03:50.150 --> 00:03:52.840
decides which clients,
which customers,

00:03:52.840 --> 00:03:55.890
which cell phones
will get frequency.

00:03:55.890 --> 00:03:58.810
He allocates frequency
dynamically over time

00:03:58.810 --> 00:04:01.740
to do clients, to
different subscribers,

00:04:01.740 --> 00:04:03.330
and this way, they communicate.

00:04:03.330 --> 00:04:06.100
Just to give you a
rough idea, we're

00:04:06.100 --> 00:04:09.060
all here in this convention.

00:04:09.060 --> 00:04:11.720
We're probably all registered
with a cell tower which,

00:04:11.720 --> 00:04:16.570
I don't know, about half a
mile away, and typical cell

00:04:16.570 --> 00:04:19.784
here in this area will
serve, I don't know,

00:04:19.784 --> 00:04:23.070
2,000 people, 2,000 cell phones.

00:04:23.070 --> 00:04:28.960
But it can only talk to eight or
12, depends on the technology.

00:04:28.960 --> 00:04:30.680
In modern country,
actually it's 16.

00:04:30.680 --> 00:04:34.290
But in the United States
it's kind of falling behind

00:04:34.290 --> 00:04:37.580
when it comes to same networks.

00:04:37.580 --> 00:04:39.830
So over the years,
different technologies

00:04:39.830 --> 00:04:44.420
have emerged to optimize
specifically that,

00:04:44.420 --> 00:04:48.560
to make the allocation process
much faster, more efficient,

00:04:48.560 --> 00:04:51.510
basically to get
more beats per hertz.

00:04:51.510 --> 00:04:54.720
Were talking about
HSDPA just UPS.

00:04:54.720 --> 00:04:59.930
What you guys probably know is
a 3.5, 3.75 generation or OFDM

00:04:59.930 --> 00:05:04.890
and OFDMA, which is LT or 4G.

00:05:04.890 --> 00:05:09.900
This is how the radio state
machine inside any cell

00:05:09.900 --> 00:05:11.440
phone in this room looks like.

00:05:11.440 --> 00:05:13.040
This is what
happens when we want

00:05:13.040 --> 00:05:16.660
to make a transition,
when we want to send

00:05:16.660 --> 00:05:17.780
a bit over the internet.

00:05:17.780 --> 00:05:22.800
Now it's a pretty
self-explanatory diagram,

00:05:22.800 --> 00:05:24.127
so it can move forward.

00:05:24.127 --> 00:05:26.460
I see this guy here with a
question mark above his head.

00:05:26.460 --> 00:05:27.480
Oh, no.

00:05:27.480 --> 00:05:32.780
OK, uh, I made a
simplified version.

00:05:32.780 --> 00:05:36.420
Let's think that we
have three states.

00:05:36.420 --> 00:05:38.010
The first one is idle.

00:05:38.010 --> 00:05:41.320
In idle, our radio
has zero throughput.

00:05:41.320 --> 00:05:43.210
No frequencies allocated to it.

00:05:43.210 --> 00:05:45.810
We can't transmit
even one single bit,

00:05:45.810 --> 00:05:47.960
but we're hardly
using the battery.

00:05:47.960 --> 00:05:50.610
We are hardly using any
power, only two milliamps,

00:05:50.610 --> 00:05:53.330
which is practically nothing.

00:05:53.330 --> 00:05:55.290
Now if the user opens
an app, and that app

00:05:55.290 --> 00:05:59.460
wants to send something to the
internet and receive something,

00:05:59.460 --> 00:06:02.390
we need to move
from idle to DCH.

00:06:02.390 --> 00:06:04.490
DCH stands for
dedicated channel.

00:06:04.490 --> 00:06:06.620
In this mode, the
base station actually

00:06:06.620 --> 00:06:09.860
allocates frequency
to the client,

00:06:09.860 --> 00:06:15.520
to the cell phone in a constant
manner, in a periodic interval,

00:06:15.520 --> 00:06:18.090
like clockwork,
allocates frequency.

00:06:18.090 --> 00:06:22.290
In that mode, again, to make
things easier to digest,

00:06:22.290 --> 00:06:26.020
we have high throughput,
but we actually

00:06:26.020 --> 00:06:28.400
consume a lot of power.

00:06:28.400 --> 00:06:32.390
Now let's say we're getting that
frequency, which transmitted

00:06:32.390 --> 00:06:34.860
whatever we needed to
transmit, and now the cellphone

00:06:34.860 --> 00:06:37.430
doesn't need that
much bandwidth.

00:06:37.430 --> 00:06:39.630
The network understands
that, and the base station

00:06:39.630 --> 00:06:43.826
tells us the cell phone,
hey, move from DCH to FACH.

00:06:43.826 --> 00:06:46.600
FACJ stands for
forward access channel.

00:06:46.600 --> 00:06:49.030
Frequency is still being
allocated to the cell phone,

00:06:49.030 --> 00:06:50.890
but not like before,
not like clockwork,

00:06:50.890 --> 00:06:52.690
but every once in
awhile, we get frequency.

00:06:52.690 --> 00:06:55.530
We'll be able to
transmit and receive.

00:06:55.530 --> 00:06:58.070
In other words,
again, just to make it

00:06:58.070 --> 00:07:01.360
schematics let's say that we've
got half of the bandwidth,

00:07:01.360 --> 00:07:03.885
and we're using
half of the power.

00:07:03.885 --> 00:07:08.254
We're running in this mode until
we're done with the network.

00:07:08.254 --> 00:07:09.670
We don't need the
network anymore,

00:07:09.670 --> 00:07:11.990
and then the cell tower
will tell us, hey, move back

00:07:11.990 --> 00:07:16.320
to idle where you're not
consuming any frequency.

00:07:16.320 --> 00:07:19.450
And that frequency can
be allocated elsewhere.

00:07:19.450 --> 00:07:24.000
Now those transitions, actually,
they don't happen right away.

00:07:24.000 --> 00:07:25.070
They take time.

00:07:25.070 --> 00:07:29.270
It takes about two seconds
to move from idle to DCH.

00:07:29.270 --> 00:07:31.120
Think about it.

00:07:31.120 --> 00:07:32.640
User opens your app.

00:07:32.640 --> 00:07:35.185
Your app wants to fetch
something from the internet.

00:07:35.185 --> 00:07:37.680
The user actually
waits about two seconds

00:07:37.680 --> 00:07:41.162
before you are able to
send the very first bit,

00:07:41.162 --> 00:07:43.510
and it happens a lot.

00:07:43.510 --> 00:07:45.670
Furthermore, in DCH,
it takes the network

00:07:45.670 --> 00:07:49.820
some time to understand that
this specific client that we're

00:07:49.820 --> 00:07:53.150
allocating frequency to it,
doesn't need that bandwidth.

00:07:53.150 --> 00:07:55.830
He's not using it.

00:07:55.830 --> 00:07:57.940
About eight to 10
seconds, depends

00:07:57.940 --> 00:07:59.670
on the configuration
of the network,

00:07:59.670 --> 00:08:02.590
and same goes with FACH.

00:08:02.590 --> 00:08:04.930
Now those tail times,
that's basically

00:08:04.930 --> 00:08:08.110
frequency that has been
allocated and nobody needs it.

00:08:08.110 --> 00:08:10.514
Nobody's actually using it.

00:08:10.514 --> 00:08:11.930
That's a waste of
frequency, which

00:08:11.930 --> 00:08:17.040
is a huge problem to the
AT&amp;T, Horizons of the world.

00:08:17.040 --> 00:08:19.780
But we need to
remember another thing.

00:08:19.780 --> 00:08:24.720
In cellular network, there is
no such thing as being quiet,

00:08:24.720 --> 00:08:28.360
which means that if a
frequency has been allocated,

00:08:28.360 --> 00:08:33.010
you must transmit something.

00:08:33.010 --> 00:08:36.010
I got a cellphone,
move to the CH,

00:08:36.010 --> 00:08:39.870
did whatever transaction
it needed to do,

00:08:39.870 --> 00:08:41.240
got the frequency.

00:08:41.240 --> 00:08:43.286
Now the cellphone
doesn't have the app,

00:08:43.286 --> 00:08:44.660
doesn't have
nothing to transmit,

00:08:44.660 --> 00:08:47.430
but the base station still
allocates frequencies

00:08:47.430 --> 00:08:48.630
to that phone.

00:08:48.630 --> 00:08:50.730
That phone has to
transmit something.

00:08:50.730 --> 00:08:51.810
What do we transmit?

00:08:51.810 --> 00:08:54.360
Random bits, zeros and ones.

00:08:54.360 --> 00:08:55.610
We have to transmit something.

00:08:55.610 --> 00:08:57.610
There are a lot of phrases
that like to do that.

00:08:57.610 --> 00:09:00.070
I'm not going to go
into it right now.

00:09:00.070 --> 00:09:03.670
You can ask me afterwards,
but the bottom line, they

00:09:03.670 --> 00:09:08.880
will understand now that those
tail times from this age to FS

00:09:08.880 --> 00:09:10.030
age to idle.

00:09:10.030 --> 00:09:15.580
This is pure energy
that goes to /dev/null.

00:09:15.580 --> 00:09:17.700
OK, that's energy that
we just throw away.

00:09:17.700 --> 00:09:20.060
We're transmitting something.

00:09:20.060 --> 00:09:23.640
Transmitting something is
very expensive battery-wise,

00:09:23.640 --> 00:09:26.630
and it just goes away.

00:09:26.630 --> 00:09:32.080
So now that we understand
how those networks operate,

00:09:32.080 --> 00:09:35.340
we can ask ourselves what does
it mean to us as developers.

00:09:35.340 --> 00:09:39.140
And at the end it all boils
down to two main things

00:09:39.140 --> 00:09:41.030
that we, as developers,
need to focus

00:09:41.030 --> 00:09:46.600
on, less radio, less data, OK?

00:09:46.600 --> 00:09:49.060
That's what we're going
to talk about today.

00:09:49.060 --> 00:09:51.850
First thing, I want
to go over some name

00:09:51.850 --> 00:09:54.450
common mistakes
that we've seen lots

00:09:54.450 --> 00:09:58.440
of people in lots of
apps doing, and it's time

00:09:58.440 --> 00:10:01.130
to put that to an end.

00:10:01.130 --> 00:10:03.970
First thing, periodic traffic.

00:10:03.970 --> 00:10:05.630
Now we used to do
periodic traffic.

00:10:05.630 --> 00:10:07.770
Let's say we want
to upload analytics

00:10:07.770 --> 00:10:12.440
or do location updates,
or just keep live, OK?

00:10:12.440 --> 00:10:15.690
Sending heartbeat messages
back and forth to the server

00:10:15.690 --> 00:10:17.420
that we're still alive.

00:10:17.420 --> 00:10:20.650
Here's a use case from
a music streaming up

00:10:20.650 --> 00:10:22.295
that we've looked at.

00:10:22.295 --> 00:10:23.920
This is a screenshot
from a tool called

00:10:23.920 --> 00:10:26.700
ARO that was developed
in AT&amp;T when I was there.

00:10:26.700 --> 00:10:32.850
I am going to show that tool
later and elaborate a bit more,

00:10:32.850 --> 00:10:36.370
and as you can see, basically
what this tool does,

00:10:36.370 --> 00:10:38.460
it looks at the
network, requests,

00:10:38.460 --> 00:10:41.350
and it analyzes what
the radio state was.

00:10:41.350 --> 00:10:44.400
And as you can see, the music
file in that music streaming

00:10:44.400 --> 00:10:48.530
app was downloaded as one
big chunk at the beginning.

00:10:48.530 --> 00:10:51.680
OK, you can see we're
in DCH, and we're good.

00:10:51.680 --> 00:10:54.860
But then every 62
seconds the app actually

00:10:54.860 --> 00:10:58.810
sent about the payload, which
is about 2 kilobytes of data

00:10:58.810 --> 00:11:00.560
to the server, analytics.

00:11:00.560 --> 00:11:02.954
What is the song, the volume?

00:11:02.954 --> 00:11:04.620
What the user did,
what are foregrounds?

00:11:04.620 --> 00:11:05.890
What are backgrounds?

00:11:05.890 --> 00:11:08.720
Stuff that they wanted to know.

00:11:08.720 --> 00:11:13.670
And every pic here,
every 62 seconds

00:11:13.670 --> 00:11:18.300
we actually moved the radio
from idle to DCH, FSCH,

00:11:18.300 --> 00:11:19.470
and back to idle.

00:11:19.470 --> 00:11:22.560
That's a lot of energy
that was wasted.

00:11:22.560 --> 00:11:23.815
How much is a lot?

00:11:23.815 --> 00:11:26.950
It turns out that
0.2% of the data

00:11:26.950 --> 00:11:31.640
actually consumed 46% of energy.

00:11:31.640 --> 00:11:33.330
We talked with them.

00:11:33.330 --> 00:11:36.960
Back then that is three
years ago I think.

00:11:36.960 --> 00:11:40.909
They batched the analytics
to piggyback that when

00:11:40.909 --> 00:11:42.950
the file is being done
with it, and they actually

00:11:42.950 --> 00:11:48.100
reduced battery consumption
by half, which is amazing.

00:11:48.100 --> 00:11:51.570
Second anti-pattern is
multiple connections.

00:11:51.570 --> 00:11:55.050
Everybody's doing
it including myself.

00:11:55.050 --> 00:11:57.765
We need to download several
images from the website.

00:11:57.765 --> 00:12:00.030
We will open several
HTTP connection,

00:12:00.030 --> 00:12:02.822
and we'll do multiple
gets from that website.

00:12:02.822 --> 00:12:04.780
But here's another thing
that I didn't tell you

00:12:04.780 --> 00:12:06.440
about until now.

00:12:06.440 --> 00:12:09.800
In cellular network,
every TCP connection

00:12:09.800 --> 00:12:13.569
introduced some overhead because
it needs to be encapsulated.

00:12:13.569 --> 00:12:15.610
So we're adding bits at
the beginning and the end

00:12:15.610 --> 00:12:19.590
of the packets which means that
every TCP connection reduces

00:12:19.590 --> 00:12:21.400
the overall throughput
that we have.

00:12:21.400 --> 00:12:23.980
If I have a radio channel,
a cellular channel here

00:12:23.980 --> 00:12:26.020
that can give me one
megabit per second,

00:12:26.020 --> 00:12:28.790
and I open four TCP
connection at the same time,

00:12:28.790 --> 00:12:32.950
I'm not going to get 250k each.

00:12:32.950 --> 00:12:36.510
I will get less,
around 220 each.

00:12:36.510 --> 00:12:38.500
That means that we
lower throughput.

00:12:38.500 --> 00:12:41.910
The user needs to wait
longer for the data,

00:12:41.910 --> 00:12:44.140
and it also means
that we're spending

00:12:44.140 --> 00:12:48.920
more time in DCH or
FSCH mode, meaning

00:12:48.920 --> 00:12:51.836
I'm draining the battery.

00:12:51.836 --> 00:12:54.750
The third anti-pattern
is duplicate content,

00:12:54.750 --> 00:12:59.510
basically downloading
things that we already know.

00:12:59.510 --> 00:13:01.900
First problem is when the
app downloads something

00:13:01.900 --> 00:13:03.910
from the server,
and that something

00:13:03.910 --> 00:13:05.530
doesn't have any
caching information,

00:13:05.530 --> 00:13:07.190
so the app can't cache it.

00:13:07.190 --> 00:13:09.549
Let's say the app
downloaded an image.

00:13:09.549 --> 00:13:11.340
The image doesn't have
caching information.

00:13:11.340 --> 00:13:12.875
The user sees that.

00:13:12.875 --> 00:13:17.500
Exit the app, and two seconds
later, he goes back to the app.

00:13:17.500 --> 00:13:18.900
We go down.

00:13:18.900 --> 00:13:21.070
We go back and download
the same very image

00:13:21.070 --> 00:13:23.170
that we downloaded
two seconds ago.

00:13:23.170 --> 00:13:23.830
Waste of time.

00:13:23.830 --> 00:13:24.760
Waste of money.

00:13:24.760 --> 00:13:26.840
Waste of battery.

00:13:26.840 --> 00:13:28.920
The solution is to
use headers, the right

00:13:28.920 --> 00:13:32.050
headers like Max Age or
Expires when you send something

00:13:32.050 --> 00:13:32.890
to your client.

00:13:32.890 --> 00:13:35.710
And then the client can use it.

00:13:35.710 --> 00:13:40.290
Second problem is that content
with caching information

00:13:40.290 --> 00:13:43.800
the cache hasn't expired, but
it is being downloaded anyway

00:13:43.800 --> 00:13:44.500
by the client.

00:13:44.500 --> 00:13:46.400
We've seen that happen a lot.

00:13:46.400 --> 00:13:50.450
So when we write some code
that goes and fetches an image.

00:13:50.450 --> 00:13:54.390
But they know we don't actually
check if that content has

00:13:54.390 --> 00:13:55.530
expired or not.

00:13:55.530 --> 00:13:57.400
So the solution is simple.

00:13:57.400 --> 00:13:59.160
Don't do it, OK?

00:14:01.900 --> 00:14:02.970
I don't believe it.

00:14:02.970 --> 00:14:04.105
You're leaving me.

00:14:04.105 --> 00:14:05.965
[LAUGHTER]

00:14:05.965 --> 00:14:07.840
OK, friends.

00:14:07.840 --> 00:14:12.190
Anyway, third problem, content
that has been downloaded,

00:14:12.190 --> 00:14:14.720
cached by the client.

00:14:14.720 --> 00:14:18.410
The cache expired,
but the actual file

00:14:18.410 --> 00:14:20.625
hasn't been changed
on the server side.

00:14:20.625 --> 00:14:22.280
It's the same file.

00:14:22.280 --> 00:14:26.170
So usually what the client will
do, it will go in say, hey,

00:14:26.170 --> 00:14:27.490
my local cache has expired.

00:14:27.490 --> 00:14:29.540
Let's download
that content again.

00:14:29.540 --> 00:14:34.110
But instead, the client can use
an if-modified-since header.

00:14:34.110 --> 00:14:37.370
And then if the content hasn't
changed on the server side,

00:14:37.370 --> 00:14:41.150
the server instead of
sending that image back

00:14:41.150 --> 00:14:44.690
will send three or
four not modified.

00:14:44.690 --> 00:14:47.610
And then the client knows that,
hey, my local copay is still

00:14:47.610 --> 00:14:48.110
valid.

00:14:48.110 --> 00:14:49.110
I can use it.

00:14:49.110 --> 00:14:52.550
Instead of downloading a big
chunk of image or whatever,

00:14:52.550 --> 00:14:56.540
we're downloading a very small,
only headers, only the HTTP

00:14:56.540 --> 00:14:57.040
header.

00:15:00.140 --> 00:15:01.850
Last anti-pattern,
connection management.

00:15:01.850 --> 00:15:03.960
So I know that most
of us are using

00:15:03.960 --> 00:15:08.080
HTTP URL connection or
an OkHttp or whatever,

00:15:08.080 --> 00:15:11.990
a library that gives
us transport layer.

00:15:11.990 --> 00:15:15.330
But in some cases, we
need to actually take

00:15:15.330 --> 00:15:18.790
of connections ourselves to
do some low-level operation

00:15:18.790 --> 00:15:20.100
in the socket level.

00:15:20.100 --> 00:15:23.460
If we're doing voice over
AP or SIP or whatever.

00:15:23.460 --> 00:15:26.064
And we've seen several
mistakes there.

00:15:26.064 --> 00:15:27.980
The common one is that
we open the connection.

00:15:27.980 --> 00:15:31.320
We use it, and then
we don't close it.

00:15:31.320 --> 00:15:33.310
We don't call
socket.close because we

00:15:33.310 --> 00:15:36.700
think that, hey, the
TCP will time out,

00:15:36.700 --> 00:15:39.510
and the TCP stuff will
close the connection for us,

00:15:39.510 --> 00:15:41.254
and actually it does.

00:15:41.254 --> 00:15:43.670
But what happens is that in
order to close the connection,

00:15:43.670 --> 00:15:46.620
we need to send TCP
resets to the side,

00:15:46.620 --> 00:15:49.860
and in order to
send that TCP reset,

00:15:49.860 --> 00:15:55.010
we fire up the radio
from idle to DCH

00:15:55.010 --> 00:15:57.800
to FSCH and back to idle.

00:15:57.800 --> 00:16:00.020
That's a waste of energy.

00:16:00.020 --> 00:16:02.300
Another common name
problem is that when

00:16:02.300 --> 00:16:04.250
we open a connection
just to have

00:16:04.250 --> 00:16:07.900
one ready for when we
need it in the future,

00:16:07.900 --> 00:16:09.590
and then we find
out the radio just

00:16:09.590 --> 00:16:12.710
for the three-way
handshake [INAUDIBLE].

00:16:12.710 --> 00:16:18.132
So if you do need to manage
your connections yourself,

00:16:18.132 --> 00:16:19.840
open connections only
when you need them.

00:16:19.840 --> 00:16:22.000
You use them as
much as you want.

00:16:22.000 --> 00:16:25.340
You're done with them,
please close them.

00:16:25.340 --> 00:16:30.420
So, now that we've covered
the common mistakes

00:16:30.420 --> 00:16:33.350
that a lot of
people are doing, I

00:16:33.350 --> 00:16:38.580
want to talk about some advanced
techniques that will help you

00:16:38.580 --> 00:16:39.890
to become a better new member.

00:16:39.890 --> 00:16:44.190
And our goals are less
radio time and less data.

00:16:44.190 --> 00:16:48.020
Now it's easy to say--
it's a little bit harder

00:16:48.020 --> 00:16:51.430
to implement-- because when
you think about it, in our app,

00:16:51.430 --> 00:16:54.790
we're dealing many,
many, many transactions.

00:16:54.790 --> 00:16:57.300
There are so many
code paths that

00:16:57.300 --> 00:17:01.040
will lead to a transaction,
to a thread that will fire up

00:17:01.040 --> 00:17:02.180
a network transaction.

00:17:02.180 --> 00:17:03.850
It's very hard for
us as developers

00:17:03.850 --> 00:17:08.650
to say which transaction happens
when and how to deal with it.

00:17:08.650 --> 00:17:11.050
So in order to make things
a little bit easier,

00:17:11.050 --> 00:17:13.900
I've decided let's--
what we're going to do,

00:17:13.900 --> 00:17:17.650
we're going to categorize
network requests to three

00:17:17.650 --> 00:17:19.040
different buckets.

00:17:19.040 --> 00:17:22.930
First there is the stuff
that the user asks us now.

00:17:22.930 --> 00:17:24.656
The user clicks on
the article, and he

00:17:24.656 --> 00:17:25.780
wants to read that article.

00:17:25.780 --> 00:17:29.840
He wants to get into that
specific post or whatever.

00:17:29.840 --> 00:17:32.170
We need data right
now for the user.

00:17:32.170 --> 00:17:34.530
We need to go now and
bring the data in order

00:17:34.530 --> 00:17:36.660
to display that to the user.

00:17:36.660 --> 00:17:39.850
Second type is those
small data updates

00:17:39.850 --> 00:17:43.370
that we need to send
to our servers when

00:17:43.370 --> 00:17:45.550
or while the application
is running, again,

00:17:45.550 --> 00:17:49.610
like analytics or location
updates and whatnot.

00:17:49.610 --> 00:17:52.660
These usually will
be small payloads,

00:17:52.660 --> 00:17:57.670
and we care about them only when
the app is actually running.

00:17:57.670 --> 00:18:01.480
The third type is
when we want to send

00:18:01.480 --> 00:18:07.450
a relatively big change of data
to the server in order to sync.

00:18:07.450 --> 00:18:09.420
Let's say, uploading
a bunch of photos

00:18:09.420 --> 00:18:15.110
or doing an email sync like
Gmail does or address book

00:18:15.110 --> 00:18:17.610
and contact list sync
like WhatsApp does, OK?

00:18:17.610 --> 00:18:20.400
We don't really care
about exactly when

00:18:20.400 --> 00:18:22.000
that transaction will happen.

00:18:22.000 --> 00:18:25.480
It's big chunks, and it usually
happens in the background.

00:18:25.480 --> 00:18:30.520
Now the second and third types
we can optimize by batching,

00:18:30.520 --> 00:18:34.360
and the first one can be
optimized by prefetching.

00:18:34.360 --> 00:18:37.100
And we're going to talk about
these two techniques now,

00:18:37.100 --> 00:18:39.560
so let's start with batching.

00:18:39.560 --> 00:18:43.660
Batching basically we take
a bunch of transactions

00:18:43.660 --> 00:18:45.210
that happens over time.

00:18:45.210 --> 00:18:46.920
And for every
transaction, we actually

00:18:46.920 --> 00:18:50.320
pay a radio transition state.

00:18:50.320 --> 00:18:53.210
Those transitions
from this FACH.

00:18:53.210 --> 00:18:55.920
I'm going to say
that a lot today,

00:18:55.920 --> 00:19:02.790
and we batched them together, so
we paid the overhead only once.

00:19:02.790 --> 00:19:05.080
Now the easiest way
to do that is by

00:19:05.080 --> 00:19:08.220
simply when you have
a network request,

00:19:08.220 --> 00:19:10.010
don't execute it immediately.

00:19:10.010 --> 00:19:12.520
Simply send it to a queue, OK?

00:19:12.520 --> 00:19:14.710
It can be a very simple
queue or something

00:19:14.710 --> 00:19:17.180
more complex like, I don't
know, content provider.

00:19:17.180 --> 00:19:19.810
It can even serialize
that transaction

00:19:19.810 --> 00:19:22.840
to persistent storage,
so you want to use it

00:19:22.840 --> 00:19:25.540
if the app gets terminated.

00:19:25.540 --> 00:19:30.200
Now you would ask yourself
when do I purge my queue?

00:19:30.200 --> 00:19:32.089
When do I actually
go and send that?

00:19:32.089 --> 00:19:34.630
So an easy answer, let's that's,
when we reach the threshold.

00:19:34.630 --> 00:19:38.250
Let's say, I don't know, 10
transaction in the queue.

00:19:38.250 --> 00:19:40.720
Let's bash them together
and send them out.

00:19:40.720 --> 00:19:43.670
That works, but when
we think about it,

00:19:43.670 --> 00:19:46.220
actually our phone is doing
a lot of stuff in the system,

00:19:46.220 --> 00:19:49.700
and there is a very good
chance that another app will

00:19:49.700 --> 00:19:53.540
use the radio before the
threshold is reached.

00:19:53.540 --> 00:19:57.000
So we would really like to get
notified when somebody else is

00:19:57.000 --> 00:19:58.150
using the radio.

00:19:58.150 --> 00:20:00.022
The radio is already hot.

00:20:00.022 --> 00:20:00.980
It's in this edge mode.

00:20:00.980 --> 00:20:05.870
Why don't we piggyback on that?

00:20:05.870 --> 00:20:08.830
It will be a very good idea
for us to piggyback on that

00:20:08.830 --> 00:20:12.600
and transmit, and that's
exactly we introduced

00:20:12.600 --> 00:20:14.617
JobScheduler in Lollipop.

00:20:14.617 --> 00:20:16.200
How many people here
use JobScheduler?

00:20:19.050 --> 00:20:22.650
OK, you're in the right room.

00:20:22.650 --> 00:20:24.130
Good, so how do we do that?

00:20:24.130 --> 00:20:28.670
Basically, we specify job ID,
the job that needs to be done

00:20:28.670 --> 00:20:32.200
and some concerns like what
network type do we want,

00:20:32.200 --> 00:20:34.300
and time.

00:20:34.300 --> 00:20:37.970
And actually, we can say,
hey, some except constraints

00:20:37.970 --> 00:20:44.360
I won that transaction to
happen only one charging.

00:20:44.360 --> 00:20:47.700
But job scheduler was
introduced only in Lollipop.

00:20:47.700 --> 00:20:51.020
What happens if you're
running on pre-L devices.

00:20:51.020 --> 00:20:54.990
So first thing you could
do is you Sync Manager

00:20:54.990 --> 00:20:56.270
and SyncAdapters.

00:20:56.270 --> 00:21:01.690
SyncAdapters are great for those
third type of network requests,

00:21:01.690 --> 00:21:06.240
for those cases when you
need upload a bunch of stuff

00:21:06.240 --> 00:21:10.350
to the server or to sync data
from your phone to the servers.

00:21:10.350 --> 00:21:12.390
The things that are
not time critical

00:21:12.390 --> 00:21:17.740
and usually huge loads of
data, big chunks of data.

00:21:17.740 --> 00:21:19.736
This is what Gmail is
using to sing Gmail.

00:21:19.736 --> 00:21:21.360
This is what the
address book is using.

00:21:21.360 --> 00:21:22.820
This is what WhatsApp is using.

00:21:22.820 --> 00:21:26.692
Basically, I can't
think of an application

00:21:26.692 --> 00:21:28.650
that will actually sync
something and not using

00:21:28.650 --> 00:21:29.630
SyncAdapters.

00:21:29.630 --> 00:21:32.487
So SyncAdapters are
great for the third type.

00:21:32.487 --> 00:21:34.070
But what happens
with the second type?

00:21:34.070 --> 00:21:36.990
Those small data
updates that accrue

00:21:36.990 --> 00:21:38.570
while the app is running.

00:21:38.570 --> 00:21:41.140
SyncAdapter just
wasn't built for it,

00:21:41.140 --> 00:21:44.530
and it introduced way
too much overhead.

00:21:44.530 --> 00:21:48.020
For those, we have
a GcmNetworkManager,

00:21:48.020 --> 00:21:51.590
which is very similar
to job scheduler.

00:21:51.590 --> 00:21:55.670
Basically, let's say we
want to schedule a task that

00:21:55.670 --> 00:22:00.500
will run from, I don't know,
from five minutes from now

00:22:00.500 --> 00:22:02.410
to 15 minutes from now.

00:22:02.410 --> 00:22:04.900
You've specified the
task, and you just

00:22:04.900 --> 00:22:07.240
need to override
the single method.

00:22:07.240 --> 00:22:12.850
And when you inherit
from a GcmTaskService

00:22:12.850 --> 00:22:15.380
and you need to return
either results successful,

00:22:15.380 --> 00:22:20.010
results failure, or
results reschedule.

00:22:20.010 --> 00:22:22.140
If you want to debug
when you're running

00:22:22.140 --> 00:22:24.840
with a just GcmNetworkManager,
you need to somehow create

00:22:24.840 --> 00:22:28.410
that trigger to tell
GcmNetworkManager,

00:22:28.410 --> 00:22:30.170
hey, I want you to
trigger that task.

00:22:30.170 --> 00:22:33.276
I want you run it, and there's
an ADB command for that.

00:22:33.276 --> 00:22:34.900
There are some caveats
and limitations,

00:22:34.900 --> 00:22:38.140
so you better go to the
communication about it

00:22:38.140 --> 00:22:42.510
a little bit, but basically
it's works and it's great.

00:22:42.510 --> 00:22:45.000
Now let's talk
about prefetching.

00:22:45.000 --> 00:22:49.500
If in batching we wanted to
grab a few transactions together

00:22:49.500 --> 00:22:52.480
and wait until we have
enough and set them together,

00:22:52.480 --> 00:22:54.972
prefetching is all
the other way around.

00:22:54.972 --> 00:22:55.930
Basically what happens.

00:22:55.930 --> 00:22:57.240
The user opens the app.

00:22:57.240 --> 00:22:59.685
We fetch some data
from the internet.

00:22:59.685 --> 00:23:01.160
The user looks at the data.

00:23:01.160 --> 00:23:02.006
He waits the wait.

00:23:02.006 --> 00:23:03.880
In the meantime, the
radio goes back to idle,

00:23:03.880 --> 00:23:05.213
and then it clicks on something.

00:23:05.213 --> 00:23:08.277
And when it does, and we fetch
some more data, you a seat.

00:23:08.277 --> 00:23:10.860
And then he clicks on something,
and we go and fetch some more

00:23:10.860 --> 00:23:13.420
data, and so on and so forth.

00:23:13.420 --> 00:23:17.930
Prefetching is all about
predicting the future,

00:23:17.930 --> 00:23:22.280
predicting what data we will
need during this session.

00:23:22.280 --> 00:23:27.160
What data the user was likely
to ask us to download for him

00:23:27.160 --> 00:23:31.780
and actually download it now
before he even asks for it.

00:23:31.780 --> 00:23:32.930
Think about it.

00:23:32.930 --> 00:23:36.670
Not only we are improving
battery life dramatically,

00:23:36.670 --> 00:23:38.880
we are actually improving
the user experience

00:23:38.880 --> 00:23:41.320
because when the user
actually clicks on something,

00:23:41.320 --> 00:23:42.540
the data is already there.

00:23:42.540 --> 00:23:47.150
He doesn't have to wait
for it to be downloaded.

00:23:47.150 --> 00:23:51.055
First question, how much
data do we prefetch.

00:23:51.055 --> 00:23:53.060
It's a tough one.

00:23:53.060 --> 00:23:56.990
So a quality prefetch
will fair on a 3G network

00:23:56.990 --> 00:24:00.990
will be around between 1
to 2 megabits per second.

00:24:00.990 --> 00:24:04.020
On faster networks
like 3.5 or 4G,

00:24:04.020 --> 00:24:07.940
we could go up to 5
megabytes of data.

00:24:07.940 --> 00:24:09.700
But there's another
way to look at it.

00:24:09.700 --> 00:24:12.570
Since it doesn't make any
sense to prefetch data

00:24:12.570 --> 00:24:16.810
that the user doesn't want
or that the user won't see,

00:24:16.810 --> 00:24:19.710
actually we can think of
it from a different angle

00:24:19.710 --> 00:24:24.350
and say, hey, let's fetch enough
data for the next minute or two

00:24:24.350 --> 00:24:25.250
minutes.

00:24:25.250 --> 00:24:29.210
OK, that's usually the average
session length in application.

00:24:29.210 --> 00:24:31.130
I depends on the
application category,

00:24:31.130 --> 00:24:34.520
so actually I really encourage
you to go to analytics

00:24:34.520 --> 00:24:39.930
and look how much time
users spends in session

00:24:39.930 --> 00:24:42.520
and you're ops, and then you
can optimized specifically

00:24:42.520 --> 00:24:44.710
for that style.

00:24:44.710 --> 00:24:47.980
So that's a good approach,
and I'll go with it.

00:24:47.980 --> 00:24:52.700
But we can improve it a
little bit and be adaptive.

00:24:52.700 --> 00:24:55.510
Let's they now we want to
look at what the user is doing

00:24:55.510 --> 00:24:57.690
and what the device is doing.

00:24:57.690 --> 00:25:00.420
For example, do we
fetch more of a Wi-Fi?

00:25:00.420 --> 00:25:02.430
Hell, yes.

00:25:02.430 --> 00:25:04.120
Do we fetch more while charging?

00:25:04.120 --> 00:25:06.580
Of course, we download the
internet while charging.

00:25:06.580 --> 00:25:08.680
I don't care.

00:25:08.680 --> 00:25:10.660
Fetch less while
the user is walking?

00:25:10.660 --> 00:25:13.260
For sure, because
users when they walk,

00:25:13.260 --> 00:25:15.790
their attention span
to our app is lower.

00:25:15.790 --> 00:25:20.310
Every session type when walking
is around 20-25 seconds, which

00:25:20.310 --> 00:25:23.670
is a good thing because if it
was 2 minutes like when we're

00:25:23.670 --> 00:25:29.060
standing, people will
get into parking cars

00:25:29.060 --> 00:25:32.940
or fall from cliffs or I don't
know what will happen to them.

00:25:32.940 --> 00:25:35.790
OK, fetch more when
the user is driving?

00:25:35.790 --> 00:25:40.000
Depends, if you're app
is all about roadblocks

00:25:40.000 --> 00:25:42.050
and the hero moment
of the app is

00:25:42.050 --> 00:25:43.760
while the user is driving, yes.

00:25:43.760 --> 00:25:45.260
If the users is
driving, fetch more.

00:25:45.260 --> 00:25:46.885
And you can actually
tell what the user

00:25:46.885 --> 00:25:49.820
is doing, if he's driving, if
he's walking, if he's cycling

00:25:49.820 --> 00:25:53.769
by using activity
recognition API, which

00:25:53.769 --> 00:25:55.060
is in the Google Play services.

00:25:57.630 --> 00:25:59.390
Do we fetch more
over a fast network?

00:25:59.390 --> 00:26:01.090
If we're in 2G,
let's fetch less.

00:26:01.090 --> 00:26:06.120
If we're in 4G, let's fetch
more, et cetera, et cetera.

00:26:06.120 --> 00:26:14.210
But we talked about [INAUDIBLE]
and how much to prefetch

00:26:14.210 --> 00:26:16.860
and how to change the amount
of data that we prefetch.

00:26:16.860 --> 00:26:21.220
Now I want to ask you another
question and take it a notch

00:26:21.220 --> 00:26:22.120
up.

00:26:22.120 --> 00:26:26.260
When to prefetch,
what do you think?

00:26:26.260 --> 00:26:28.070
When to prefetch?

00:26:28.070 --> 00:26:29.841
When is the right
time to prefetch?

00:26:29.841 --> 00:26:31.340
That's actually a
question you can--

00:26:31.340 --> 00:26:32.215
AUDIENCE: [INAUDIBLE]

00:26:33.819 --> 00:26:35.860
RAN NACHMANY: When we're
downloading data anyway.

00:26:35.860 --> 00:26:39.320
That's a good place
to batch actually.

00:26:39.320 --> 00:26:40.880
Prefetch is
predicting the future.

00:26:40.880 --> 00:26:41.899
AUDIENCE: Login.

00:26:41.899 --> 00:26:42.690
RAN NACHMANY: What?

00:26:42.690 --> 00:26:43.357
AUDIENCE: Login.

00:26:43.357 --> 00:26:44.190
RAN NACHMANY: Login.

00:26:44.190 --> 00:26:45.457
When the user opens the app.

00:26:45.457 --> 00:26:46.624
AUDIENCE: The user logs in.

00:26:46.624 --> 00:26:48.040
RAN NACHMANY: User
logs in or user

00:26:48.040 --> 00:26:51.382
opens the app, that's a good
place to prefetch, yeah.

00:26:51.382 --> 00:26:54.260
AUDIENCE: At night.

00:26:54.260 --> 00:26:55.250
RAN NACHMANY: At night.

00:26:55.250 --> 00:26:57.290
At night it's not
a really good idea

00:26:57.290 --> 00:27:00.350
because if the user
opens the app at noon,

00:27:00.350 --> 00:27:04.370
probably the data from the
night is already obsolete.

00:27:04.370 --> 00:27:08.090
But we're going to talk
about BG updates in a second.

00:27:08.090 --> 00:27:11.700
So actually the right
answer, the optimum point

00:27:11.700 --> 00:27:18.390
in time to prefetch is right
before the user opens our app.

00:27:18.390 --> 00:27:21.030
Think about it.

00:27:21.030 --> 00:27:24.690
We save the user those two
seconds from idle to DCH.

00:27:24.690 --> 00:27:27.572
He opens the app, and the
data is already there.

00:27:27.572 --> 00:27:28.780
No need to download anything.

00:27:28.780 --> 00:27:29.800
No need to refresh.

00:27:29.800 --> 00:27:31.340
The app is fresh.

00:27:31.340 --> 00:27:36.130
The data is right
where it needs to be.

00:27:36.130 --> 00:27:37.850
The only problem
with this approach

00:27:37.850 --> 00:27:40.635
is that our crystal ball
API is still in beta.

00:27:40.635 --> 00:27:42.240
[LAUGHTER]

00:27:42.240 --> 00:27:46.010
And we haven't released it yet.

00:27:46.010 --> 00:27:47.280
What?

00:27:47.280 --> 00:27:48.190
Yeah.

00:27:48.190 --> 00:27:49.952
But you can get to
the early access.

00:27:49.952 --> 00:27:50.660
I'm just kidding.

00:27:50.660 --> 00:27:54.090
[LAUGHTER]

00:27:54.090 --> 00:27:56.440
So instead, we need to
take a different approach.

00:27:56.440 --> 00:28:00.390
And that's to do background
updates similar to what you

00:28:00.390 --> 00:28:03.360
said, let's object at night
or when the user is not

00:28:03.360 --> 00:28:05.410
using the app, so when
he will use the app,

00:28:05.410 --> 00:28:06.590
the data will be there.

00:28:06.590 --> 00:28:12.240
Now beckoned updates,
can be very, very tricky.

00:28:12.240 --> 00:28:18.250
And we need to ask ourself
what we update and how

00:28:18.250 --> 00:28:22.460
in order to make that process
efficient and effective.

00:28:22.460 --> 00:28:24.821
Efficient means that we
don't want to pull the server

00:28:24.821 --> 00:28:26.320
and say, hey, is
this something new?

00:28:26.320 --> 00:28:27.350
Is this something new?

00:28:27.350 --> 00:28:31.280
And actually drain the
battery really, really quick.

00:28:31.280 --> 00:28:33.970
And effective, we don't
want to fetch data

00:28:33.970 --> 00:28:36.880
that the user won't see, OK?

00:28:36.880 --> 00:28:41.590
The whole thing here
is to fetch data

00:28:41.590 --> 00:28:43.300
that the user will want to see.

00:28:43.300 --> 00:28:44.970
Predict the future.

00:28:44.970 --> 00:28:47.390
So in order to understand
what to update,

00:28:47.390 --> 00:28:52.180
I, again, segment the contents
to three different buckets.

00:28:52.180 --> 00:28:55.360
The first thing is
the what's hot, OK?

00:28:55.360 --> 00:28:58.810
This is the data, the
information that users

00:28:58.810 --> 00:29:00.150
are most interested in.

00:29:00.150 --> 00:29:03.500
This is why they have download
your app in the first place.

00:29:03.500 --> 00:29:05.190
If we're talking
about the news app,

00:29:05.190 --> 00:29:06.540
that will be the top headline.

00:29:06.540 --> 00:29:07.956
If we're talking
about sports app,

00:29:07.956 --> 00:29:13.510
there will be the current scores
or live objects from the game.

00:29:13.510 --> 00:29:16.000
This is the data
that users care most.

00:29:16.000 --> 00:29:18.230
If you don't know
what the data the user

00:29:18.230 --> 00:29:21.620
cares most in your
app, A, it's a shame.

00:29:21.620 --> 00:29:25.070
B, go to analytics and take
a look what users are doing,

00:29:25.070 --> 00:29:27.590
and then you'll find out.

00:29:27.590 --> 00:29:30.230
The second bucket is
that interesting stuff.

00:29:30.230 --> 00:29:32.850
This is stuff that's
not the what's hot,

00:29:32.850 --> 00:29:35.630
but it's stuff that
the user told us

00:29:35.630 --> 00:29:37.130
that he's interested in.

00:29:37.130 --> 00:29:40.170
For example, if we're
talking about the news app,

00:29:40.170 --> 00:29:41.990
maybe we have a
user that is very

00:29:41.990 --> 00:29:46.300
interested in the final
section and another user who's

00:29:46.300 --> 00:29:48.950
very interested in
the, I don't know,

00:29:48.950 --> 00:29:52.500
science section or
political section.

00:29:52.500 --> 00:29:54.680
So the user actually
told us, hey,

00:29:54.680 --> 00:29:56.664
I'm interested in
that information.

00:29:56.664 --> 00:29:57.330
It's not common.

00:29:57.330 --> 00:29:59.860
It's not for all the users, but
specific users told us, hey,

00:29:59.860 --> 00:30:01.860
this is interesting for me.

00:30:01.860 --> 00:30:05.810
And then there is all
the rest of this stuff.

00:30:05.810 --> 00:30:08.560
Now when I look at
background updates,

00:30:08.560 --> 00:30:10.290
I'm thinking of,
all right, let's

00:30:10.290 --> 00:30:14.710
take a look how we update
every each piece of content.

00:30:14.710 --> 00:30:17.960
So for what's hot, my server
knows that something changed.

00:30:17.960 --> 00:30:20.380
There is no new headline.

00:30:20.380 --> 00:30:23.340
New results form from the
game, something new happened.

00:30:23.340 --> 00:30:26.260
The server can actually
send us a GCM message

00:30:26.260 --> 00:30:28.880
with the data embedded in it.

00:30:28.880 --> 00:30:30.920
We can carry
payload of up to 4K,

00:30:30.920 --> 00:30:33.830
if I'm not mistaken,
in every GCA message.

00:30:33.830 --> 00:30:38.202
And actually, our client, the
app, can get this GCA message.

00:30:38.202 --> 00:30:39.660
We don't show
anything to the user.

00:30:39.660 --> 00:30:42.510
We don't pop out in the
notification, nothing.

00:30:42.510 --> 00:30:46.060
We take the data, and we store
it in our internal database.

00:30:46.060 --> 00:30:48.980
When the user will open
the app, all the What's Hot

00:30:48.980 --> 00:30:50.550
is up to date.

00:30:50.550 --> 00:30:56.670
It doesn't need to wait one
single millisecond to see that.

00:30:56.670 --> 00:30:58.930
When it comes to
interesting stuff,

00:30:58.930 --> 00:31:00.910
we can't use the same
approach because we

00:31:00.910 --> 00:31:04.040
can't send everything to
everyone all the time.

00:31:04.040 --> 00:31:05.330
We take a different approach.

00:31:05.330 --> 00:31:11.160
Basically the server will
tell the users via GCM

00:31:11.160 --> 00:31:13.770
that something has changed.

00:31:13.770 --> 00:31:17.170
Let's say something has
changed in the final section,

00:31:17.170 --> 00:31:20.620
all the users that starred
that said the final section

00:31:20.620 --> 00:31:24.675
dates in their
favorite list, the app

00:31:24.675 --> 00:31:27.010
will get the message
saying, hey there's

00:31:27.010 --> 00:31:29.470
new data in the final section.

00:31:29.470 --> 00:31:34.710
And then the app will use
backoff to pull that data.

00:31:34.710 --> 00:31:41.310
And it will look-- let's say,
it can go in two different ways.

00:31:41.310 --> 00:31:44.710
Option A, we get
this GCM message.

00:31:44.710 --> 00:31:45.840
Something has changed.

00:31:45.840 --> 00:31:46.870
We wait a little.

00:31:46.870 --> 00:31:47.490
We go.

00:31:47.490 --> 00:31:51.090
We fetch the data, and then
the user opens app perfect.

00:31:51.090 --> 00:31:54.000
We predicted the future.

00:31:54.000 --> 00:31:56.530
Another way that
this can go, it's

00:31:56.530 --> 00:31:58.780
the other other way around, OK?

00:31:58.780 --> 00:32:02.030
So we get a GCM,
hey, something new.

00:32:02.030 --> 00:32:03.740
We fetch the data.

00:32:03.740 --> 00:32:05.720
And the user doesn't
open it up, and then

00:32:05.720 --> 00:32:09.600
we get another GCM
something new happened,

00:32:09.600 --> 00:32:10.780
and we fetch the data.

00:32:10.780 --> 00:32:12.850
And then the user opens the app.

00:32:12.850 --> 00:32:16.910
It means that we've
had redundant updates.

00:32:16.910 --> 00:32:17.925
We've wasted bandwidth.

00:32:17.925 --> 00:32:19.420
We've Wasted energy.

00:32:19.420 --> 00:32:21.140
In that case, when
we identify it,

00:32:21.140 --> 00:32:23.540
and it's very easy to
identify in those cases,

00:32:23.540 --> 00:32:27.460
we basically increase
our backoff exponentially

00:32:27.460 --> 00:32:30.121
until we reach to
the right amount.

00:32:30.121 --> 00:32:32.620
So there are users that will
open our app four times of day.

00:32:32.620 --> 00:32:37.230
There will be users that
opens our app two times a day.

00:32:37.230 --> 00:32:39.910
Pretty easy we'll find
the right frequency

00:32:39.910 --> 00:32:41.660
to those background updates.

00:32:41.660 --> 00:32:45.570
And all the other
stuff, we simply

00:32:45.570 --> 00:32:47.660
update that when the
user opens the app.

00:32:47.660 --> 00:32:49.660
It doesn't really matter.

00:32:49.660 --> 00:32:56.020
We can't really predicted that
the user will want that data.

00:32:56.020 --> 00:32:58.780
OK, third technique.

00:32:58.780 --> 00:33:02.400
Now we talked a lot about
reducing radio time.

00:33:02.400 --> 00:33:06.847
Now let's talk about
reducing payload size.

00:33:06.847 --> 00:33:07.430
Here's a test.

00:33:07.430 --> 00:33:10.340
There are two images
on the screen.

00:33:10.340 --> 00:33:13.290
Who thinks the image on the
right is higher quality?

00:33:16.480 --> 00:33:17.350
Two people.

00:33:17.350 --> 00:33:21.760
Who think the image on the
left is higher quality?

00:33:21.760 --> 00:33:23.740
Three people.

00:33:23.740 --> 00:33:28.600
Who thinks I'm fooling you,
and it's the same image?

00:33:28.600 --> 00:33:29.509
Most of the people.

00:33:29.509 --> 00:33:30.800
OK, thanks for the trust, guys.

00:33:30.800 --> 00:33:32.940
[LAUGHTER]

00:33:32.940 --> 00:33:39.830
OK, actually one is 45k,
and the other one is 160k.

00:33:39.830 --> 00:33:42.990
And third, and no one
here in this one room

00:33:42.990 --> 00:33:47.620
could actually tell, hey, this
one is better than that one.

00:33:47.620 --> 00:33:52.210
We can save a lot by compressing
our images correctly.

00:33:52.210 --> 00:33:55.270
We don't need to go with
100% quality in JPEG.

00:33:55.270 --> 00:33:59.280
Actually, if you look at JPEG
quality for the leading sites,

00:33:59.280 --> 00:34:02.080
Google, Facebook, Yahoo,
et cetera, et cetera.

00:34:02.080 --> 00:34:04.700
This is how the
big guys are doing.

00:34:04.700 --> 00:34:07.870
Why don't you do the same?

00:34:07.870 --> 00:34:10.159
And since it is big
on the barbecue,

00:34:10.159 --> 00:34:13.520
and Colt was supposed to be
here, is not here, right?

00:34:13.520 --> 00:34:14.020
Colt?

00:34:14.020 --> 00:34:15.870
Good, so we can skip this slide.

00:34:15.870 --> 00:34:17.250
You don't need to go see it.

00:34:19.830 --> 00:34:22.510
All right, let's talk
about application resource

00:34:22.510 --> 00:34:25.389
optimizer or ARO.

00:34:25.389 --> 00:34:30.449
ARO, it's a tool that was
developed at AT&amp;T several years

00:34:30.449 --> 00:34:32.800
back when I worked there.

00:34:32.800 --> 00:34:39.080
And I think about two years
ago, we've open sourced it.

00:34:39.080 --> 00:34:40.940
What this tool
does, it basically

00:34:40.940 --> 00:34:43.480
monitors all the network
transactions and activity

00:34:43.480 --> 00:34:46.449
that we have that
happens in our app,

00:34:46.449 --> 00:34:50.600
and it analyzes what
the radio states would

00:34:50.600 --> 00:34:52.900
be for those transactions.

00:34:52.900 --> 00:34:57.010
It also runs a lot of
tests against those anti

00:34:57.010 --> 00:35:00.120
patters that I've just
showed you earlier today

00:35:00.120 --> 00:35:05.500
and gives you an easy-to-digest
report how you are doing, OK?

00:35:05.500 --> 00:35:11.020
So give me one moment to
rearrange my screens here,

00:35:11.020 --> 00:35:14.430
and we'll be able
to actually see it.

00:35:14.430 --> 00:35:21.040
OK, so wait another
second, and this

00:35:21.040 --> 00:35:24.240
is going to be challenging
because I'm half blind,

00:35:24.240 --> 00:35:25.340
but it's all right.

00:35:25.340 --> 00:35:29.800
OK, so I took an
Israel application

00:35:29.800 --> 00:35:31.940
so no one would
understand anything

00:35:31.940 --> 00:35:34.800
because the content
doesn't really matter,

00:35:34.800 --> 00:35:38.180
and here we can see, on
the screen, the report.

00:35:38.180 --> 00:35:41.440
And there are a bunch of
tests that the tool did.

00:35:41.440 --> 00:35:47.290
And obviously, green means
good, red not that good,

00:35:47.290 --> 00:35:52.140
and you know that you need to
fix those items, whether it's

00:35:52.140 --> 00:35:54.370
duplicate content or
connection management

00:35:54.370 --> 00:35:59.130
or currently not being
zipped, stuff like that.

00:35:59.130 --> 00:36:03.210
But we can do some
more with the tool.

00:36:03.210 --> 00:36:05.370
It's extremely hard
to see from here.

00:36:05.370 --> 00:36:07.990
We have an overview tab,
which basically tells us

00:36:07.990 --> 00:36:10.880
how much energy we consumed,
how much energy was

00:36:10.880 --> 00:36:15.900
wasted on radio
transitions, on signaling,

00:36:15.900 --> 00:36:17.130
et cetera, et cetera.

00:36:17.130 --> 00:36:21.430
But the most interesting part,
it is for me, is this screen.

00:36:21.430 --> 00:36:22.910
Basically what we
see here-- these

00:36:22.910 --> 00:36:25.040
are the screenshot that
I showed you earlier--

00:36:25.040 --> 00:36:27.415
we can see here
the transactions.

00:36:30.340 --> 00:36:33.710
We can see the transactions,
and actually the packets

00:36:33.710 --> 00:36:34.810
that were sent.

00:36:34.810 --> 00:36:37.160
And if we look at any
single point of time,

00:36:37.160 --> 00:36:43.400
we will see on the right side
the actual screen and what

00:36:43.400 --> 00:36:45.840
happened during that time.

00:36:45.840 --> 00:36:48.180
So during this splash
screen, we can see here

00:36:48.180 --> 00:36:51.370
what packets have been-- we've
downloaded, what we sent,

00:36:51.370 --> 00:36:54.010
and we can immediately
take a look

00:36:54.010 --> 00:36:56.830
and see that we were on
DCH, went down to the DCH,

00:36:56.830 --> 00:37:00.440
back to DCH, down.

00:37:00.440 --> 00:37:01.910
All those small
transactions should

00:37:01.910 --> 00:37:05.120
have been batched into
one single big one

00:37:05.120 --> 00:37:10.070
and save a lot of data
and a lot of battery.

00:37:10.070 --> 00:37:12.730
Lets take a look at this area.

00:37:12.730 --> 00:37:14.970
So the user clicked
here on something,

00:37:14.970 --> 00:37:16.790
and he actually
entered this article.

00:37:16.790 --> 00:37:19.540
This is a news
application in Israel.

00:37:19.540 --> 00:37:24.220
OK, again, you don't need to
read what's happening there.

00:37:24.220 --> 00:37:27.170
Now I can see some
transactions here.

00:37:27.170 --> 00:37:29.150
And if we'll go
down and look, we'll

00:37:29.150 --> 00:37:34.480
see that we actually downloaded
the article and the images.

00:37:34.480 --> 00:37:39.550
But over there, there's
another transaction--

00:37:39.550 --> 00:37:40.720
I don't see my pointer.

00:37:40.720 --> 00:37:43.790
I'm going to point anyway.

00:37:43.790 --> 00:37:45.700
Already, there's
another transaction,

00:37:45.700 --> 00:37:49.380
and I don't understand
why it's there.

00:37:49.380 --> 00:37:52.090
And obviously, I think it
should have been batched,

00:37:52.090 --> 00:37:55.140
so let's click on it.

00:37:55.140 --> 00:37:55.930
Where am I?

00:37:55.930 --> 00:37:57.000
Here am I?

00:37:57.000 --> 00:37:59.880
What changed?

00:37:59.880 --> 00:38:01.960
Did the user see
anything different?

00:38:05.313 --> 00:38:06.750
AUDIENCE: [INAUDIBLE]

00:38:06.750 --> 00:38:08.370
RAN NACHMANY: The ads, exactly.

00:38:08.370 --> 00:38:12.920
So the user was actually
reading the article.

00:38:12.920 --> 00:38:15.220
The radio went
already to idle state,

00:38:15.220 --> 00:38:19.130
and just to change
the ad at the bottom,

00:38:19.130 --> 00:38:24.320
we fired the radio
from idle to DCH, FSCH,

00:38:24.320 --> 00:38:26.570
and so on and so forth.
wasted a lot of energy.

00:38:26.570 --> 00:38:29.920
A better approach will
say, hey, give me five ads,

00:38:29.920 --> 00:38:32.250
and then the clients
will rotate them

00:38:32.250 --> 00:38:36.410
without going to
network every time.

00:38:36.410 --> 00:38:37.660
So there's a lot in this tool.

00:38:37.660 --> 00:38:41.840
It's very hard to
actually go over it,

00:38:41.840 --> 00:38:43.770
but I really encourage
you to try it.

00:38:43.770 --> 00:38:45.755
It's called application
versus optimizer ARO.

00:38:45.755 --> 00:38:47.650
You can find it in GitHub.

00:38:47.650 --> 00:38:48.560
You can compile it.

00:38:48.560 --> 00:38:52.320
There is zip file,
APKs, everything.

00:38:52.320 --> 00:38:57.313
You will discover wonders on
your app if you will use it.

00:38:57.313 --> 00:38:58.299
AUDIENCE: [INAUDIBLE]

00:38:58.299 --> 00:38:58.792
RAN NACHMANY: Yep.

00:38:58.792 --> 00:38:59.667
AUDIENCE: [INAUDIBLE]

00:39:09.817 --> 00:39:10.608
RAN NACHMANY: Yeah.

00:39:10.608 --> 00:39:11.483
AUDIENCE: [INAUDIBLE]

00:39:15.290 --> 00:39:17.070
RAN NACHMANY: This
is your best friend.

00:39:17.070 --> 00:39:17.990
Start here.

00:39:17.990 --> 00:39:18.846
See what your green.

00:39:18.846 --> 00:39:20.345
See what your red,
and all you reds,

00:39:20.345 --> 00:39:22.942
actually, If you click on them,
you get some nice explanation.

00:39:22.942 --> 00:39:23.900
Hey, you're doing this.

00:39:23.900 --> 00:39:27.410
You're doing that, and even
in some case, not all of them,

00:39:27.410 --> 00:39:33.530
pointer to the actual packets
that misbehaved, all right?

00:39:33.530 --> 00:39:37.690
And then you can
actually-- in fact,

00:39:37.690 --> 00:39:42.030
if you only very recent
few things in your code,

00:39:42.030 --> 00:39:44.610
you will see a
tremendous improvement

00:39:44.610 --> 00:39:48.490
just like get rid of all
this periodic bursty traffic.

00:39:48.490 --> 00:39:50.660
And probably, you have one
process or maybe two that

00:39:50.660 --> 00:39:54.305
are doing better
or improve prefetch

00:39:54.305 --> 00:39:55.491
or let's do some batching.

00:39:55.491 --> 00:39:56.990
Let's do a transport
layer that will

00:39:56.990 --> 00:40:00.140
batch some background
request, et cetera, et cetera,

00:40:00.140 --> 00:40:04.110
and you're there, OK?

00:40:04.110 --> 00:40:09.280
All right, so we do have
some time left for Q&amp;A.

00:40:09.280 --> 00:40:13.030
So feel free to ask
whatever you want.

00:40:13.030 --> 00:40:13.530
Yep?

00:40:13.530 --> 00:40:14.405
AUDIENCE: [INAUDIBLE]

00:40:17.784 --> 00:40:18.950
RAN NACHMANY: Actually, yes.

00:40:21.590 --> 00:40:26.910
Yeah, the question was, can
I see when the radio is hot

00:40:26.910 --> 00:40:28.930
or what the state of the radio?

00:40:28.930 --> 00:40:30.604
Actually the question
is yes and no.

00:40:30.604 --> 00:40:31.770
You can see that in Android.

00:40:31.770 --> 00:40:34.450
You can see it in your code.

00:40:34.450 --> 00:40:37.950
The reason ADB command,
if I remember correctly,

00:40:37.950 --> 00:40:46.320
it's ADB-B and then
space and radio.

00:40:46.320 --> 00:40:47.320
Check the communication.

00:40:47.320 --> 00:40:51.240
You can tell ADB that we can
take the log cut from which

00:40:51.240 --> 00:40:53.160
buffer to present the log.

00:40:53.160 --> 00:40:55.910
And there is a buffer for
radio, and while you're running

00:40:55.910 --> 00:40:58.800
and your phone is
connected to your computer,

00:40:58.800 --> 00:41:01.390
you can actually
seen in the log file

00:41:01.390 --> 00:41:05.030
of the radio, what's the
state, et cetera, et cetera.

00:41:05.030 --> 00:41:09.430
So if you want that during
debug to take a look, perfect.

00:41:09.430 --> 00:41:12.510
But while running and
checking in your code what's

00:41:12.510 --> 00:41:15.140
the status of the radio you
don't have access to it.

00:41:15.140 --> 00:41:17.430
That's why you have GCM
network manager and then

00:41:17.430 --> 00:41:21.243
job schedule that
will do that for you.

00:41:21.243 --> 00:41:22.118
AUDIENCE: [INAUDIBLE]

00:41:31.780 --> 00:41:34.510
RAN NACHMANY: The question
was, can I run this tool,

00:41:34.510 --> 00:41:38.200
ARO, in an continuous
integration and automated

00:41:38.200 --> 00:41:39.530
testing environment?

00:41:39.530 --> 00:41:43.700
Actually, I haven't tried
that, so I don't really

00:41:43.700 --> 00:41:45.840
have an answer on that.

00:41:45.840 --> 00:41:48.530
There shouldn't be
a reason why not to.

00:41:48.530 --> 00:41:52.410
The only problem that it--
well, actually when I think

00:41:52.410 --> 00:41:55.240
about it-- OK, so ARO,
the way it works you

00:41:55.240 --> 00:41:56.110
have data collector.

00:41:56.110 --> 00:41:58.300
First you collect the data,
and then you feed that data

00:41:58.300 --> 00:42:00.675
into that tool that I just
showed you, which is basically

00:42:00.675 --> 00:42:01.800
the analyzer.

00:42:01.800 --> 00:42:04.990
Now the data can be collected
by using a specific APK,

00:42:04.990 --> 00:42:11.280
or you can actually feed it
Wireshark dumps, TCP dumps.

00:42:11.280 --> 00:42:13.910
So in your automatic testing
environment all you need to do

00:42:13.910 --> 00:42:18.860
is run TCP dump and
dump those pickup files.

00:42:18.860 --> 00:42:22.300
And then in the morning, feed
them to the analyzer and you

00:42:22.300 --> 00:42:25.182
immediately will see if there
was a regression or not.

00:42:29.950 --> 00:42:30.700
Another one, yeah?

00:42:30.700 --> 00:42:31.575
AUDIENCE: [INAUDIBLE]

00:42:40.552 --> 00:42:42.260
RAN NACHMANY: OK, so
in cellular network,

00:42:42.260 --> 00:42:46.360
every TCP connection is
actually encapsulated,

00:42:46.360 --> 00:42:49.410
which means that the
cellular radio here

00:42:49.410 --> 00:42:52.220
and in the base station, they
add bits at the beginning

00:42:52.220 --> 00:42:55.590
and the end of that payload.

00:42:55.590 --> 00:42:57.780
So we actually add
more bits that we

00:42:57.780 --> 00:43:00.450
need to transmit back
and forth, therefore

00:43:00.450 --> 00:43:04.010
we reduce the
overall throughput.

00:43:04.010 --> 00:43:09.625
The reason for that is that
in cellular network we often--

00:43:09.625 --> 00:43:13.260
I don't know what the
political way to say that--

00:43:13.260 --> 00:43:17.380
we often fake the
TCP state, all right?

00:43:17.380 --> 00:43:20.220
' So think of it this way.

00:43:20.220 --> 00:43:26.886
My phone opens HTTP GET
request to a server,

00:43:26.886 --> 00:43:28.510
and we're a TCP
connection to a server.

00:43:28.510 --> 00:43:30.680
And I want to keep that
TCP connection live.

00:43:30.680 --> 00:43:35.260
That means that the phone needs
to send TCP ACK messages back

00:43:35.260 --> 00:43:36.490
and forth.

00:43:36.490 --> 00:43:41.680
Now the cell network
doesn't want those TCP ACKs.

00:43:41.680 --> 00:43:43.610
They don't add any
value to the user.

00:43:43.610 --> 00:43:45.550
They're not actual payload.

00:43:45.550 --> 00:43:48.590
They just wasteful
frequency, and as I told you,

00:43:48.590 --> 00:43:51.070
frequency is extremely
important to network operators.

00:43:51.070 --> 00:43:53.990
So what they do actually
behind the base station

00:43:53.990 --> 00:43:56.700
somewhere at the base
of the cell tower,

00:43:56.700 --> 00:44:00.260
there's a big machine that looks
at all the TCP connections.

00:44:00.260 --> 00:44:02.660
And when that happens, when
we open the connection,

00:44:02.660 --> 00:44:05.950
that machine will start
talking with the server,

00:44:05.950 --> 00:44:10.220
and it will send those
TPC ACKs on our behalf.

00:44:10.220 --> 00:44:11.620
So we can shut down the radio.

00:44:11.620 --> 00:44:15.950
We cam stop allocating
frequency that's cellular phone,

00:44:15.950 --> 00:44:18.140
but the TCP connection
is still alive.

00:44:18.140 --> 00:44:21.595
And while that server will want
to send something to the phone,

00:44:21.595 --> 00:44:24.395
it actually sends something
to that big box that's

00:44:24.395 --> 00:44:26.590
either it's called ASM gateway.

00:44:26.590 --> 00:44:28.760
And that box will then
tell the base station,

00:44:28.760 --> 00:44:32.160
hey, we have data to that
phone, give him frequency

00:44:32.160 --> 00:44:34.300
and transmit the data to him.

00:44:34.300 --> 00:44:36.360
So basically because
we needed to do that,

00:44:36.360 --> 00:44:39.110
there's encapsulation
for advocacy connection

00:44:39.110 --> 00:44:43.970
that's reduced over throughput
when we are adding connections.

00:44:46.710 --> 00:44:47.210
Yep?

00:44:47.210 --> 00:44:48.085
AUDIENCE: [INAUDIBLE]

00:44:52.619 --> 00:44:54.160
RAN NACHMANY: Yeah,
the best practice

00:44:54.160 --> 00:44:58.490
is actually moving from
HTTP 1.0 to HTTP 1.1, which

00:44:58.490 --> 00:45:00.050
is persistent connection.

00:45:00.050 --> 00:45:02.740
So you open one connection, and
you run multiple get requests

00:45:02.740 --> 00:45:03.846
on top of it.

00:45:03.846 --> 00:45:04.721
AUDIENCE: [INAUDIBLE]

00:45:11.589 --> 00:45:13.380
RAN NACHMANY: So I
don't know what Retrofit

00:45:13.380 --> 00:45:14.820
is using under the hood.

00:45:14.820 --> 00:45:19.220
I can tell you that
OkHttp is perfect.

00:45:19.220 --> 00:45:21.930
So OkHttp actually use
persistent connection

00:45:21.930 --> 00:45:24.890
by default unless
the server doesn't

00:45:24.890 --> 00:45:27.702
support it, which is great.

00:45:27.702 --> 00:45:29.410
The only thing that
you need to make sure

00:45:29.410 --> 00:45:33.050
is that you don't open
several-- or that you minimize

00:45:33.050 --> 00:45:35.470
the amount of HTTP connection,
simultaneous connection

00:45:35.470 --> 00:45:39.010
that you open, OK?

00:45:39.010 --> 00:45:40.890
Anymore questions?

00:45:40.890 --> 00:45:43.030
All right, so I guess
we're done here.

00:45:43.030 --> 00:45:43.560
Thank you.

00:45:43.560 --> 00:45:45.060
[APPLAUSE]

00:45:45.060 --> 00:45:48.410
[MUSIC PLAYING]

