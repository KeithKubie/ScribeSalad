WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.958
[MUSIC PLAYING]

00:00:07.765 --> 00:00:09.140
DARREN KRAHN:
Welcome to our talk

00:00:09.140 --> 00:00:11.810
today on device provisioning
and authentication

00:00:11.810 --> 00:00:13.140
with Android Things.

00:00:13.140 --> 00:00:13.910
My name is Darren.

00:00:13.910 --> 00:00:15.350
I'm a software engineer.

00:00:15.350 --> 00:00:17.100
And I work on security
for Android Things.

00:00:17.100 --> 00:00:18.040
WAYNE PIEKARSKI: Cool.

00:00:18.040 --> 00:00:19.460
So I'm Wayne Piekarski.

00:00:19.460 --> 00:00:23.129
I'm a developer advocate
for Android Things and IoT.

00:00:23.129 --> 00:00:24.920
And so thanks for coming
today to our talk.

00:00:24.920 --> 00:00:27.680
And today, we're going to talk
to you about the strategies

00:00:27.680 --> 00:00:30.770
of getting your IoT devices
connected to the internet,

00:00:30.770 --> 00:00:32.700
to the cloud, and
everything else.

00:00:32.700 --> 00:00:35.119
So we're going to go through
the whole process end to end.

00:00:35.119 --> 00:00:37.160
And we're going to talk
about how Google software

00:00:37.160 --> 00:00:41.320
platforms, such as Android
Things, Firebase, and Cloud IoT

00:00:41.320 --> 00:00:45.830
Core, help to make
this much easier to do.

00:00:45.830 --> 00:00:48.010
So, as many of you
probably know--

00:00:48.010 --> 00:00:50.630
and that's why you're here
today-- is that IoT is huge.

00:00:50.630 --> 00:00:53.130
And it's going to be bigger
than anything we've seen before.

00:00:53.130 --> 00:00:57.020
So in the same way that we saw
phones were orders of magnitude

00:00:57.020 --> 00:00:58.670
larger than PCs, I
think we're going

00:00:58.670 --> 00:01:02.160
to see IoT devices being orders
of magnitude larger than them.

00:01:02.160 --> 00:01:04.900
We're going to be
surrounded by IoT devices

00:01:04.900 --> 00:01:07.370
on a day-to-day basis
that do all kinds

00:01:07.370 --> 00:01:08.597
of different tasks for us.

00:01:08.597 --> 00:01:10.430
And there's not going
to be just one device.

00:01:10.430 --> 00:01:12.304
You're going to have
tens or hundreds of them

00:01:12.304 --> 00:01:14.220
doing all kinds of
interesting things.

00:01:14.220 --> 00:01:17.480
And so today, we're going to
give you some hints as to ideas

00:01:17.480 --> 00:01:20.400
on how to best build
these kind of IoT devices

00:01:20.400 --> 00:01:24.130
and how to connect them,
secure them, and so forth.

00:01:24.130 --> 00:01:26.501
So firstly, let's discuss
the basics of Android Things.

00:01:26.501 --> 00:01:28.500
Hopefully, most of you
have seen the intro talk.

00:01:28.500 --> 00:01:30.240
If you haven't, we
have a bunch of talks

00:01:30.240 --> 00:01:32.790
here at IO that cover
what Android Things is.

00:01:32.790 --> 00:01:34.800
But the core concept
of Android Things

00:01:34.800 --> 00:01:37.110
is that it's based on a
system on a module, which

00:01:37.110 --> 00:01:38.940
is shown in the image
over there, which

00:01:38.940 --> 00:01:40.600
is the little small board.

00:01:40.600 --> 00:01:44.460
And so the SOM contains the
CPU, the Wi-Fi, the memory.

00:01:44.460 --> 00:01:48.550
And it's supported by what we
call a board support package.

00:01:48.550 --> 00:01:51.110
And this provides the drivers,
the kernels, the libraries,

00:01:51.110 --> 00:01:52.030
and everything.

00:01:52.030 --> 00:01:55.200
But it also provides updates
and security from Google.

00:01:55.200 --> 00:01:58.200
And, using an
Android Thing SOM, it

00:01:58.200 --> 00:02:01.530
makes it really easy for
developers to build IoT devices

00:02:01.530 --> 00:02:03.937
and also to help ensure
that they're secure

00:02:03.937 --> 00:02:05.895
and that they're kept up
to date, because those

00:02:05.895 --> 00:02:08.039
are the kind of things
that consumers need now

00:02:08.039 --> 00:02:09.960
with their devices.

00:02:09.960 --> 00:02:12.330
One other thing that makes
Android Things unique

00:02:12.330 --> 00:02:15.540
is that it supports
really powerful types

00:02:15.540 --> 00:02:17.407
of processing on device.

00:02:17.407 --> 00:02:19.240
So you don't need to
do things in the cloud,

00:02:19.240 --> 00:02:21.600
but you can do video
and audio processing,

00:02:21.600 --> 00:02:24.030
you can do machine learning,
and you can do everything

00:02:24.030 --> 00:02:27.360
on device, because we have
phone-level CPU performance

00:02:27.360 --> 00:02:29.910
on these Android Things SOMs.

00:02:29.910 --> 00:02:32.100
And the other thing is
that it's based on Android.

00:02:32.100 --> 00:02:34.620
So you can use all of the
familiar developer tools

00:02:34.620 --> 00:02:37.330
that you're used to, such
as Android Studio and all

00:02:37.330 --> 00:02:40.290
the existing code that you have,
if you're an Android developer.

00:02:40.290 --> 00:02:44.130
And so you'll be right at
home using Android Things

00:02:44.130 --> 00:02:46.357
if you've done Android
development before.

00:02:46.357 --> 00:02:47.940
So there are lots
of other talks at IO

00:02:47.940 --> 00:02:49.620
that you can go to
learn more about that.

00:02:49.620 --> 00:02:51.203
But what we're going
to focus on today

00:02:51.203 --> 00:02:54.150
is how we can take advantage
of all these things

00:02:54.150 --> 00:02:57.690
that come with Android Things
to make your IoT devices easier

00:02:57.690 --> 00:02:59.032
and better for you.

00:02:59.032 --> 00:03:00.990
So with that in mind,
let's get into an example

00:03:00.990 --> 00:03:02.520
that we're going to use
throughout this talk

00:03:02.520 --> 00:03:04.353
to sort of explain what
we're talking about.

00:03:04.353 --> 00:03:05.940
So we're going to
build an IoT washing

00:03:05.940 --> 00:03:08.130
machine, because why not?

00:03:08.130 --> 00:03:11.250
And everyone's excited
about using machine learning

00:03:11.250 --> 00:03:12.360
and TensorFlow.

00:03:12.360 --> 00:03:15.810
So therefore, we probably should
be using a washing machine that

00:03:15.810 --> 00:03:17.580
does machine learning on-board.

00:03:17.580 --> 00:03:19.890
It should have a camera
that looks at your laundry.

00:03:19.890 --> 00:03:21.420
And then, while it's
washing your clothes,

00:03:21.420 --> 00:03:22.878
it does machine
learning algorithms

00:03:22.878 --> 00:03:24.720
to analyze how clean it is.

00:03:24.720 --> 00:03:27.180
And it can also allow you to
see how your laundry is being

00:03:27.180 --> 00:03:28.638
washed when you're
at work, in case

00:03:28.638 --> 00:03:30.910
you're interested in seeing
this kind of thing happen.

00:03:30.910 --> 00:03:33.630
So I guess we could call our
new product "TensorWash."

00:03:33.630 --> 00:03:37.917
So when we build this
"TensorWash" washing machine,

00:03:37.917 --> 00:03:40.500
most washing machines still have
a control panel on the front,

00:03:40.500 --> 00:03:42.740
because you still want
to control it manually.

00:03:42.740 --> 00:03:44.580
Now, because Android
Things supports

00:03:44.580 --> 00:03:46.920
really powerful devices,
you could actually

00:03:46.920 --> 00:03:48.570
have a screen on the front.

00:03:48.570 --> 00:03:50.100
It could run OpenGL.

00:03:50.100 --> 00:03:52.900
You could have videos
and audio playing.

00:03:52.900 --> 00:03:54.900
So that's one option that
you could build, maybe

00:03:54.900 --> 00:03:56.890
in the deluxe model
of the machine.

00:03:56.890 --> 00:03:58.980
However, if you want
to reduce the cost

00:03:58.980 --> 00:04:01.230
to make a cheap IoT
washing machine,

00:04:01.230 --> 00:04:03.360
then you probably want to
get rid of the display.

00:04:03.360 --> 00:04:06.430
And so we're going to leave
that out for this example.

00:04:06.430 --> 00:04:08.674
So the machine is going
to be IoT enabled.

00:04:08.674 --> 00:04:10.590
It's going to have a few
buttons on the front.

00:04:10.590 --> 00:04:12.048
But pretty much
everything is going

00:04:12.048 --> 00:04:13.770
to be controlled via
a phone, which we're

00:04:13.770 --> 00:04:15.300
going to talk about in a bit.

00:04:15.300 --> 00:04:18.959
So the real magic of
a machine like this

00:04:18.959 --> 00:04:21.000
is when it's connected
to the internet.

00:04:21.000 --> 00:04:23.310
And so you can monitor
the machine remotely.

00:04:23.310 --> 00:04:25.080
You can view what
the camera sees.

00:04:25.080 --> 00:04:26.940
You can trigger off
a wash cycle when

00:04:26.940 --> 00:04:29.180
you're at work, when you're
driving home or whatever.

00:04:29.180 --> 00:04:31.020
So the user is not in
the house, and they

00:04:31.020 --> 00:04:32.560
could be potentially
anywhere in the world.

00:04:32.560 --> 00:04:34.530
So we don't want to
restrict it to just being

00:04:34.530 --> 00:04:37.620
controlled from something
that's close by in the house.

00:04:37.620 --> 00:04:41.040
So we really need to have an
internet cloud-based connection

00:04:41.040 --> 00:04:43.850
with some kind of cloud
solution behind that.

00:04:43.850 --> 00:04:45.600
And we could add all
kinds of fun features

00:04:45.600 --> 00:04:47.160
by having cloud support.

00:04:47.160 --> 00:04:48.900
So we could have
it awarding points

00:04:48.900 --> 00:04:52.560
for not washing your clothes
or not wasting water too much.

00:04:52.560 --> 00:04:55.470
It could report faults
to a service department.

00:04:55.470 --> 00:04:58.635
And in order to support all
this, the machine needs Wi-Fi.

00:04:58.635 --> 00:05:00.510
And we're not going to
cheat by just plugging

00:05:00.510 --> 00:05:02.040
in an ethernet cable into it.

00:05:02.040 --> 00:05:05.040
So we have this washing machine.

00:05:05.040 --> 00:05:08.040
We need it to
connect to the cloud.

00:05:08.040 --> 00:05:10.230
And we need to share
state with the cloud

00:05:10.230 --> 00:05:12.650
so that a phone could
control the device.

00:05:12.650 --> 00:05:14.400
So there are many
possible cloud services.

00:05:14.400 --> 00:05:16.120
We'll talk about a
few of them today.

00:05:16.120 --> 00:05:19.950
But firstly, in order to
make this kind of thing work,

00:05:19.950 --> 00:05:22.820
we need to firstly get the
device onto the network.

00:05:22.820 --> 00:05:26.070
And so many devices these
days are Wi-Fi based,

00:05:26.070 --> 00:05:29.340
so the device requires
an SSID and a passphrase

00:05:29.340 --> 00:05:30.990
to join the network.

00:05:30.990 --> 00:05:33.450
Many devices don't have
a keyboard or a display,

00:05:33.450 --> 00:05:35.400
like in the case of
our washing machine,

00:05:35.400 --> 00:05:37.840
so everything needs to
be handled by the phone.

00:05:37.840 --> 00:05:40.410
And if we use a
phone, then the device

00:05:40.410 --> 00:05:43.080
needs to spin up a Wi-Fi
access point of its own.

00:05:43.080 --> 00:05:44.610
The phone connects to it.

00:05:44.610 --> 00:05:46.770
It sends all the login
[INAUDIBLE] over.

00:05:46.770 --> 00:05:49.200
And then the device
reconnects to the network

00:05:49.200 --> 00:05:51.210
and uses that information.

00:05:51.210 --> 00:05:53.190
And if anything goes
wrong for any reason,

00:05:53.190 --> 00:05:55.250
the phone has no way of
knowing what happened.

00:05:55.250 --> 00:05:56.850
And so it's a very
delicate process.

00:05:56.850 --> 00:06:00.674
And so it can be problematic for
some phones or Wi-Fi networks.

00:06:00.674 --> 00:06:03.090
And so many developers find
this challenging to get right.

00:06:03.090 --> 00:06:04.680
So we're going to go
through some hints on how

00:06:04.680 --> 00:06:05.513
to make this better.

00:06:10.230 --> 00:06:12.420
And next, the
device needs to know

00:06:12.420 --> 00:06:14.480
who the owners of
the device are,

00:06:14.480 --> 00:06:17.340
so you want to make sure
that the device is viewed

00:06:17.340 --> 00:06:20.670
and controlled only by the owner
of the device and anyone else

00:06:20.670 --> 00:06:21.690
that they trust.

00:06:21.690 --> 00:06:24.390
So we need some kind
of authentication token

00:06:24.390 --> 00:06:26.370
that needs to be
issued by a server

00:06:26.370 --> 00:06:28.830
that the user then uses
to control this token.

00:06:28.830 --> 00:06:30.510
We put it on the device.

00:06:30.510 --> 00:06:33.390
And then that's what the
device uses to contact

00:06:33.390 --> 00:06:35.440
the internet and the cloud.

00:06:35.440 --> 00:06:37.690
If the user factory
resets the device,

00:06:37.690 --> 00:06:40.660
then we need to forget this
token and everything else.

00:06:40.660 --> 00:06:42.460
And then the device
should reset itself

00:06:42.460 --> 00:06:45.400
so that a different user
could use the machine,

00:06:45.400 --> 00:06:48.830
and none of the previous
history is preserved.

00:06:48.830 --> 00:06:52.160
So now, our "TensorWash" is
all connected and ready to go.

00:06:52.160 --> 00:06:56.470
So when the phone, device,
and cloud all communicate,

00:06:56.470 --> 00:07:00.004
we do that over a TLS
connection, such as HTTPS.

00:07:00.004 --> 00:07:02.170
So it's very important that
it's secure in that way.

00:07:02.170 --> 00:07:04.500
We don't want to have
eavesdroppers in the middle.

00:07:04.500 --> 00:07:09.130
Google services generally
these days require HTTPS.

00:07:09.130 --> 00:07:11.590
And we're actually starting
to enforce this by default.

00:07:11.590 --> 00:07:13.570
So we're making it
harder now for you

00:07:13.570 --> 00:07:16.540
to use unencrypted connections
because of all the security

00:07:16.540 --> 00:07:17.570
implications.

00:07:17.570 --> 00:07:20.080
And it's important that, when
you build devices like this,

00:07:20.080 --> 00:07:22.360
that everyone does
security properly,

00:07:22.360 --> 00:07:24.430
even tiny IoT companies
that are making

00:07:24.430 --> 00:07:27.490
really simple little toys or
whatever, because everyone

00:07:27.490 --> 00:07:30.260
always thinks that their device
is not going to be the problem,

00:07:30.260 --> 00:07:33.834
and then even small problems can
have unexpected impacts in ways

00:07:33.834 --> 00:07:35.500
that you just didn't
even dream of later

00:07:35.500 --> 00:07:38.090
on once your device
is out in the world.

00:07:38.090 --> 00:07:38.950
So that's it.

00:07:38.950 --> 00:07:41.440
That's the key
concepts of what you

00:07:41.440 --> 00:07:44.170
need to get a washing
machine that we're building

00:07:44.170 --> 00:07:46.460
and get it connecting
up to the cloud.

00:07:46.460 --> 00:07:47.920
So we need to set up Wi-Fi.

00:07:47.920 --> 00:07:49.720
We need to transfer
the credentials.

00:07:49.720 --> 00:07:51.670
And then we need to
connect with encryption.

00:07:51.670 --> 00:07:52.840
But there's actually
a lot more to it.

00:07:52.840 --> 00:07:54.339
So what I'm going
to do is I'm going

00:07:54.339 --> 00:07:57.640
to let Darren now do a deep
dive on some of the key concepts

00:07:57.640 --> 00:08:01.120
here and a bit more
of an explanation

00:08:01.120 --> 00:08:02.669
as to what's going on.

00:08:02.669 --> 00:08:03.460
DARREN KRAHN: Cool.

00:08:03.460 --> 00:08:05.300
So I want to take a step
back and talk about a few

00:08:05.300 --> 00:08:06.674
of these key
concepts that we use

00:08:06.674 --> 00:08:09.470
to establish secure
relationships between devices,

00:08:09.470 --> 00:08:11.170
which is fundamentally
what we're doing

00:08:11.170 --> 00:08:12.757
when we provision devices.

00:08:12.757 --> 00:08:15.340
These concepts are distinct, but
they're very much intertwined

00:08:15.340 --> 00:08:16.464
in practice, as you'll see.

00:08:16.464 --> 00:08:19.750
I want to talk about
authentication, authorization,

00:08:19.750 --> 00:08:21.820
and attestation.

00:08:21.820 --> 00:08:23.620
First, authentication.

00:08:23.620 --> 00:08:25.180
To authenticate
something is simply

00:08:25.180 --> 00:08:29.540
to prove that it is genuine
or valid, that it's authentic.

00:08:29.540 --> 00:08:32.409
We authenticate works of
art, official documents,

00:08:32.409 --> 00:08:33.705
handwritten signatures.

00:08:33.705 --> 00:08:36.330
We also authenticate each other,
mostly using face recognition.

00:08:36.330 --> 00:08:37.455
This is very natural to us.

00:08:37.455 --> 00:08:39.659
It's very intuitive.

00:08:39.659 --> 00:08:42.299
Computers often authenticate
us using passwords.

00:08:42.299 --> 00:08:44.880
Automobiles often
authenticate us using keys.

00:08:44.880 --> 00:08:47.280
So we use authentication all
the time in our daily lives

00:08:47.280 --> 00:08:50.530
without really even
thinking about it.

00:08:50.530 --> 00:08:52.020
But what about
when one computing

00:08:52.020 --> 00:08:56.200
device needs to authenticate
to another computing device?

00:08:56.200 --> 00:08:59.510
This is less intuitive
for us to think about.

00:08:59.510 --> 00:09:01.740
Often, what it involves
is secret data.

00:09:01.740 --> 00:09:05.520
So the authentic computer
has access to secret data,

00:09:05.520 --> 00:09:07.997
and all the other
computers don't.

00:09:07.997 --> 00:09:10.080
And so there's two forms
that this secret data can

00:09:10.080 --> 00:09:11.440
take that I want to talk about.

00:09:11.440 --> 00:09:12.720
One is cryptographic keys.

00:09:12.720 --> 00:09:14.269
And the other is bearer tokens.

00:09:14.269 --> 00:09:15.810
There are other ways
to authenticate.

00:09:15.810 --> 00:09:18.120
But these are very common,
and they'll directly relate

00:09:18.120 --> 00:09:19.620
to our "TensorWash" example.

00:09:19.620 --> 00:09:23.750
I'm going to dig into each
one of them a little bit.

00:09:23.750 --> 00:09:25.886
So cryptographic
keys and certificates

00:09:25.886 --> 00:09:27.010
are very common on the web.

00:09:27.010 --> 00:09:29.350
This is how your web browser
would authenticate a web

00:09:29.350 --> 00:09:31.300
server--

00:09:31.300 --> 00:09:34.160
using HTTPS, for example.

00:09:34.160 --> 00:09:36.835
The authentication involves
verifying their certificate,

00:09:36.835 --> 00:09:38.710
verifying the information
in the certificate,

00:09:38.710 --> 00:09:40.990
verifying it against
something you already trust

00:09:40.990 --> 00:09:43.900
or that you expect,
verifying the authority that

00:09:43.900 --> 00:09:47.200
issued that certificate is
something that you trust.

00:09:47.200 --> 00:09:49.725
We also need to verify the
proof of possession of a key.

00:09:49.725 --> 00:09:51.100
The key itself is
not transferred

00:09:51.100 --> 00:09:52.930
across the network,
or at least, not

00:09:52.930 --> 00:09:55.572
the private part of the key.

00:09:55.572 --> 00:09:58.030
But we need to check that the
other computer has possession

00:09:58.030 --> 00:09:59.770
of it, and it gives
us a proof of that.

00:10:02.930 --> 00:10:06.010
So doing this right in
practice can be really hard.

00:10:06.010 --> 00:10:08.085
Building these protocols
can be really hard.

00:10:08.085 --> 00:10:10.210
I strongly recommend you
don't build this yourself.

00:10:10.210 --> 00:10:12.350
Find a good library
that does it.

00:10:12.350 --> 00:10:17.320
If you use Android Things, we
have support for HTTPS and TLS

00:10:17.320 --> 00:10:21.070
built in, and so you don't
have to implement any of this.

00:10:21.070 --> 00:10:23.860
So I like to compare this
kind of authentication

00:10:23.860 --> 00:10:25.820
to an airport passport check.

00:10:25.820 --> 00:10:28.000
If you imagine, you
take your passport

00:10:28.000 --> 00:10:31.010
and you come up to
the check, the agent

00:10:31.010 --> 00:10:33.130
there is going to validate
specific information

00:10:33.130 --> 00:10:35.650
on the passport.

00:10:35.650 --> 00:10:37.900
They're going to verify
that it is from an authority

00:10:37.900 --> 00:10:39.310
that they trust.

00:10:39.310 --> 00:10:40.900
And then they're going to do
a proof of possession check,

00:10:40.900 --> 00:10:42.358
which, in the case
of the passport,

00:10:42.358 --> 00:10:44.987
is a match of the picture
with the face of the person

00:10:44.987 --> 00:10:46.070
standing in front of them.

00:10:50.404 --> 00:10:52.070
I also want to talk
about bearer tokens.

00:10:52.070 --> 00:10:54.090
These work a little
bit differently.

00:10:54.090 --> 00:10:56.810
They're passed from one
computer to another in order

00:10:56.810 --> 00:10:57.592
to verify them.

00:10:57.592 --> 00:10:59.300
They're often opaque
to the computer that

00:10:59.300 --> 00:11:00.800
sends it, but
meaningful, of course,

00:11:00.800 --> 00:11:03.290
to the computer
that verifies it.

00:11:03.290 --> 00:11:05.960
Authentication of the sender
or bearer of the token

00:11:05.960 --> 00:11:08.332
is implied by the
authentication of the token.

00:11:08.332 --> 00:11:10.040
The verifier looks at
the token and makes

00:11:10.040 --> 00:11:14.310
a decision as to whether it's
an authentic token or not.

00:11:14.310 --> 00:11:16.749
I like to compare this to the
example of a movie ticket.

00:11:16.749 --> 00:11:19.040
You go to the ticket stand,
and you buy a movie ticket.

00:11:19.040 --> 00:11:20.750
That ticket becomes
your bearer token.

00:11:20.750 --> 00:11:22.250
You go into the
theater, you present

00:11:22.250 --> 00:11:23.570
that token, you're allowed in.

00:11:23.570 --> 00:11:25.070
You pass that ticket
to your friend.

00:11:25.070 --> 00:11:28.190
Your friend is now the
bearer of that token,

00:11:28.190 --> 00:11:30.632
and they can get into the movie.

00:11:30.632 --> 00:11:32.090
So often, these
kinds of tokens are

00:11:32.090 --> 00:11:34.298
used to represent a more
thorough authentication that

00:11:34.298 --> 00:11:36.034
happened in the past.

00:11:36.034 --> 00:11:37.200
Here's another good example.

00:11:37.200 --> 00:11:39.620
On the web, when you have a
website that requires a login,

00:11:39.620 --> 00:11:41.977
you log in with the
username and password.

00:11:41.977 --> 00:11:44.060
And imagine if you had to
type your password again

00:11:44.060 --> 00:11:45.393
for every page within that site.

00:11:45.393 --> 00:11:47.444
Navigate to a new page,
type your password again.

00:11:47.444 --> 00:11:48.360
It wouldn't be usable.

00:11:48.360 --> 00:11:50.600
And so often, what
happens under the hood

00:11:50.600 --> 00:11:54.590
is a web server will issue
your browser a bearer token.

00:11:54.590 --> 00:11:56.660
And it will live for a
certain amount of time,

00:11:56.660 --> 00:11:59.540
and it'll have access to
your account, whatever

00:11:59.540 --> 00:12:01.197
that means on that website.

00:12:01.197 --> 00:12:03.530
And so you don't have to keep
entering your password all

00:12:03.530 --> 00:12:04.090
the time.

00:12:04.090 --> 00:12:06.200
And it works the same
way with an IoT device.

00:12:06.200 --> 00:12:07.980
You can investigate
it thoroughly once,

00:12:07.980 --> 00:12:12.524
issue it a token, and you get
a much lighter authentication

00:12:12.524 --> 00:12:13.940
mechanism from
that point forward.

00:12:17.992 --> 00:12:19.450
So let's think
about authentication

00:12:19.450 --> 00:12:22.220
in the context of IoT.

00:12:22.220 --> 00:12:25.070
There's a few aspects that
are worth calling out.

00:12:25.070 --> 00:12:29.170
One is that the authentication
needs to go both ways.

00:12:29.170 --> 00:12:31.410
The services and other
devices around a device

00:12:31.410 --> 00:12:33.280
need to authenticate
that device.

00:12:33.280 --> 00:12:35.680
And that device
needs to authenticate

00:12:35.680 --> 00:12:40.230
the other services, the
other devices around it.

00:12:40.230 --> 00:12:44.320
So for example, a device would
authenticate a web service,

00:12:44.320 --> 00:12:46.320
same way that a browser
would authenticate a web

00:12:46.320 --> 00:12:47.940
service using HTTPS or TLS.

00:12:51.970 --> 00:12:53.860
Also, authentication
does not necessarily

00:12:53.860 --> 00:12:57.054
mean a verification of identity.

00:12:57.054 --> 00:12:59.470
Often, we think of it that
way, but it doesn't necessarily

00:12:59.470 --> 00:13:00.610
have to be that way.

00:13:00.610 --> 00:13:02.571
Take the example of a
restricted web service.

00:13:02.571 --> 00:13:04.070
Suppose you [INAUDIBLE]
web service,

00:13:04.070 --> 00:13:07.030
but it's intended for instances
of your product to connect back

00:13:07.030 --> 00:13:08.170
to that web service.

00:13:08.170 --> 00:13:11.660
And you want to make sure that
all the clients are actually

00:13:11.660 --> 00:13:12.910
instances of that web service.

00:13:12.910 --> 00:13:14.380
What you want to
do is authenticate

00:13:14.380 --> 00:13:16.900
that it's one of your devices,
but you don't actually

00:13:16.900 --> 00:13:18.050
care which one.

00:13:18.050 --> 00:13:23.940
You can actually do an anonymous
authentication, in that case.

00:13:23.940 --> 00:13:26.190
Also, we need to
bind authentication

00:13:26.190 --> 00:13:27.915
to meaningful expectations.

00:13:27.915 --> 00:13:30.150
We want to make sure
that we're authenticating

00:13:30.150 --> 00:13:33.890
what we're thinking, what we
are expecting to authenticate.

00:13:33.890 --> 00:13:35.820
Let me give you a
couple of examples.

00:13:35.820 --> 00:13:38.070
If there's a device
in front of you,

00:13:38.070 --> 00:13:41.130
and you want to
authenticate that device,

00:13:41.130 --> 00:13:42.702
you bind it to
something physical.

00:13:42.702 --> 00:13:44.285
Find something
physical in the device.

00:13:44.285 --> 00:13:45.701
If the device has
a screen and you

00:13:45.701 --> 00:13:48.080
can display a code both on
your phone and on the screen,

00:13:48.080 --> 00:13:51.574
for example, that's a physical
binding of that authentication.

00:13:51.574 --> 00:13:53.990
That's a common experience
when you do a Bluetooth pairing

00:13:53.990 --> 00:13:57.100
or something like that.

00:13:57.100 --> 00:14:00.030
But you can also use a sticker
on the device or a barcode.

00:14:00.030 --> 00:14:02.811
And we'll talk about
that a little bit more.

00:14:02.811 --> 00:14:04.560
Same thing goes with
an encrypted channel.

00:14:04.560 --> 00:14:05.850
If you've established
an encrypted channel

00:14:05.850 --> 00:14:07.980
and then you need to
authenticate that channel,

00:14:07.980 --> 00:14:11.430
bind your authentication
to that channel.

00:14:11.430 --> 00:14:15.422
So if you're using a standard
protocol like TLS or HTTPS,

00:14:15.422 --> 00:14:16.630
this is already done for you.

00:14:16.630 --> 00:14:19.074
You don't have to
worry about it.

00:14:19.074 --> 00:14:21.240
But if you're doing some
things between two devices,

00:14:21.240 --> 00:14:23.280
for example, and
they don't support

00:14:23.280 --> 00:14:25.830
that kind of a protocol, then
you need to think about this.

00:14:29.430 --> 00:14:31.640
So let's go back to our
"TensorWash" example

00:14:31.640 --> 00:14:33.348
and take a look at
all the authentication

00:14:33.348 --> 00:14:34.224
that needs to happen.

00:14:34.224 --> 00:14:36.431
So we'll start in the
completely unprovisioned state.

00:14:36.431 --> 00:14:38.780
So we just took our "TensorWash"
machine out of the box.

00:14:41.272 --> 00:14:43.480
So let's assume that our
smartphone's already set up.

00:14:43.480 --> 00:14:47.470
Our smartphone is able to
authenticate web services

00:14:47.470 --> 00:14:49.110
using HTTPS, TLS.

00:14:49.110 --> 00:14:50.869
And also, in our
case, let's assume

00:14:50.869 --> 00:14:53.410
that we have a Google account
we've logged into on the phone.

00:14:53.410 --> 00:14:57.490
And so those web services are
able to authenticate the phone.

00:14:57.490 --> 00:14:59.800
And so there's a two-way
authenticated relationship

00:14:59.800 --> 00:15:01.770
there.

00:15:01.770 --> 00:15:03.360
The first thing we
need to do is we

00:15:03.360 --> 00:15:05.220
need to authenticate
this new device.

00:15:05.220 --> 00:15:06.760
What we want to do is we
want to send it credentials.

00:15:06.760 --> 00:15:08.270
Those credentials
can be valuable--

00:15:08.270 --> 00:15:11.450
Wi-Fi passwords, access
to cloud services.

00:15:11.450 --> 00:15:14.100
And we want to make sure we're
sending it to the right device

00:15:14.100 --> 00:15:15.540
before we send it over.

00:15:19.135 --> 00:15:21.760
And once we've provisioned that,
we want to end up in the state

00:15:21.760 --> 00:15:23.801
where we have two-way
authenticated relationships

00:15:23.801 --> 00:15:26.802
between the "TensorWash"
machine and cloud services.

00:15:26.802 --> 00:15:28.510
So I've given two
examples here, Firebase

00:15:28.510 --> 00:15:32.760
and Cloud IoT Core that we're
going to use with "TensorWash."

00:15:32.760 --> 00:15:37.600
And for both of these, we
want a two-way relationship.

00:15:37.600 --> 00:15:39.130
Again, authenticating
web services,

00:15:39.130 --> 00:15:41.500
we'll use the
standard TLS HTTPS.

00:15:41.500 --> 00:15:44.397
And we'll use
different forms, which

00:15:44.397 --> 00:15:46.230
we'll talk about in
more detail a little bit

00:15:46.230 --> 00:15:49.199
later to authenticate
the device.

00:15:49.199 --> 00:15:50.740
But those credentials
are going to be

00:15:50.740 --> 00:15:53.350
provisioned during this
process from the phone.

00:15:56.534 --> 00:15:57.950
So you may have
noticed that there

00:15:57.950 --> 00:15:59.460
is one authentication
that didn't

00:15:59.460 --> 00:16:00.780
go both ways in my example.

00:16:00.780 --> 00:16:02.280
What about this
one, here in yellow,

00:16:02.280 --> 00:16:03.600
from "TensorWash" to the phone.

00:16:03.600 --> 00:16:06.600
Is it OK for the "TensorWash"
device to come out of the box

00:16:06.600 --> 00:16:09.616
and not authenticate the phone
that's going to set it up?

00:16:09.616 --> 00:16:11.490
So we've put it this
way, because it's really

00:16:11.490 --> 00:16:13.170
common for consumer devices.

00:16:13.170 --> 00:16:17.280
When they come out of the
box, they're in a clear state.

00:16:17.280 --> 00:16:20.700
They don't have any notion
of who their owner is

00:16:20.700 --> 00:16:23.220
or who they trust.

00:16:23.220 --> 00:16:25.460
They're just available
to be set up.

00:16:25.460 --> 00:16:28.530
And so we wanted to
build out this case.

00:16:28.530 --> 00:16:29.447
And mostly, that's OK.

00:16:29.447 --> 00:16:31.404
It doesn't come out of
the box with credentials

00:16:31.404 --> 00:16:32.790
that it's going
to be giving out.

00:16:32.790 --> 00:16:37.139
It's receiving credentials, and
so it's less important than,

00:16:37.139 --> 00:16:39.180
for example, the phone
that needs to authenticate

00:16:39.180 --> 00:16:41.710
the "TensorWash" device.

00:16:41.710 --> 00:16:43.410
But there are
cases, for example,

00:16:43.410 --> 00:16:47.039
in enterprise zero-touch,
mass rollout scenarios,

00:16:47.039 --> 00:16:49.080
where you want that device
to come out of the box

00:16:49.080 --> 00:16:49.996
and get itself set up.

00:16:49.996 --> 00:16:51.810
It'll have to come
out of the box

00:16:51.810 --> 00:16:55.890
already with a notion
of who it trusts.

00:16:55.890 --> 00:16:59.690
And this can be as simple
as just taking an HTTPS URL

00:16:59.690 --> 00:17:01.941
and embedding it onto the
device, so when it wakes up,

00:17:01.941 --> 00:17:02.981
it knows where it can go.

00:17:02.981 --> 00:17:05.280
And that can be a registration
server that can fill it

00:17:05.280 --> 00:17:08.640
in with the rest of the
credentials or the information

00:17:08.640 --> 00:17:10.260
it needs to get configured.

00:17:10.260 --> 00:17:12.550
But we're going to leave
that bit out for our talk.

00:17:12.550 --> 00:17:14.383
And we're going to
assume we have a consumer

00:17:14.383 --> 00:17:17.760
device, "TensorWash" coming out
of the box in a clear state.

00:17:20.660 --> 00:17:22.202
So we've talked
about authentication,

00:17:22.202 --> 00:17:24.243
which is checking whether
something is authentic.

00:17:24.243 --> 00:17:26.200
And now, I want to talk
about authorization.

00:17:26.200 --> 00:17:28.450
Authorization is checking
whether something is allowed

00:17:28.450 --> 00:17:30.730
to do what it's trying to do.

00:17:30.730 --> 00:17:33.920
Think back to the
airport passport check.

00:17:33.920 --> 00:17:36.612
You arrive at the airport
with a valid passport.

00:17:36.612 --> 00:17:38.570
It doesn't mean you're
going to pass the check.

00:17:38.570 --> 00:17:40.278
For example, they're
going to be checking

00:17:40.278 --> 00:17:42.470
whether you're scheduled
for a flight that day.

00:17:42.470 --> 00:17:44.750
Just because your passport
is an authentic passport

00:17:44.750 --> 00:17:47.330
doesn't mean you pass.

00:17:47.330 --> 00:17:49.490
There's still an
additional authorization.

00:17:49.490 --> 00:17:51.610
Similarly, with the
movie ticket scenario,

00:17:51.610 --> 00:17:55.460
if you head to the theater with
a movie ticket from last year,

00:17:55.460 --> 00:17:56.850
you may not get into your movie.

00:17:56.850 --> 00:18:00.530
It's a different time, different
date, different showing.

00:18:00.530 --> 00:18:02.120
And there's an
authorization that

00:18:02.120 --> 00:18:06.327
happens, even though your movie
ticket is perfectly authentic.

00:18:10.900 --> 00:18:13.440
So I want to use the
example of OAuth 2.0, which

00:18:13.440 --> 00:18:15.930
is a very commonly
used authorization

00:18:15.930 --> 00:18:17.172
framework for the web.

00:18:17.172 --> 00:18:18.130
It's built for the web.

00:18:18.130 --> 00:18:21.000
It may or may not work
for a given IoT use case.

00:18:21.000 --> 00:18:23.074
But it's a good
example, and I want

00:18:23.074 --> 00:18:24.990
to pull out a few concepts
that are important.

00:18:24.990 --> 00:18:26.500
And even if you
don't use OAuth 2.0,

00:18:26.500 --> 00:18:29.730
you need to think about
some of these concepts.

00:18:29.730 --> 00:18:31.950
The two big ones are token
scope and token lifetime.

00:18:31.950 --> 00:18:34.290
Token scope describes
what privileges

00:18:34.290 --> 00:18:35.610
are associated with a token.

00:18:35.610 --> 00:18:38.790
So, what can the bearer of
this token get access to?

00:18:38.790 --> 00:18:42.920
Token lifetime describes
when the token expires.

00:18:42.920 --> 00:18:45.420
And there's this notion
of refresh tokens

00:18:45.420 --> 00:18:46.434
versus access tokens.

00:18:46.434 --> 00:18:47.850
Access tokens are
going to be used

00:18:47.850 --> 00:18:50.190
to access the actual resource
you're trying to get to,

00:18:50.190 --> 00:18:51.780
the protected resource.

00:18:51.780 --> 00:18:54.360
These tokens are often
short-lived, narrowly scoped.

00:18:54.360 --> 00:18:55.950
And it can be self-contained.

00:18:55.950 --> 00:18:59.340
So the decision on
the resource server

00:18:59.340 --> 00:19:00.610
can be optimized and quick.

00:19:00.610 --> 00:19:02.360
And it doesn't need to do
any kind of back-end lookups.

00:19:02.360 --> 00:19:04.193
It just looks at the
token that it received,

00:19:04.193 --> 00:19:08.650
and it can make a decision
with the information there.

00:19:08.650 --> 00:19:10.330
Refresh tokens,
on the other hand,

00:19:10.330 --> 00:19:12.880
are used to get new access
tokens when the old access

00:19:12.880 --> 00:19:14.740
token expires.

00:19:14.740 --> 00:19:16.354
These tokens are
often long-lived.

00:19:16.354 --> 00:19:17.770
They're more widely
scoped, so you

00:19:17.770 --> 00:19:20.440
may want to go and get access
tokens for of a variety

00:19:20.440 --> 00:19:22.120
of different scopes.

00:19:22.120 --> 00:19:25.450
And they're not
self-contained specifically.

00:19:25.450 --> 00:19:28.107
And what this enables is this
enables the authorization

00:19:28.107 --> 00:19:30.190
server that's making the
decision as to whether it

00:19:30.190 --> 00:19:32.851
should give a new access token
based on the refresh token.

00:19:32.851 --> 00:19:34.600
It can decide if there's
been a revocation

00:19:34.600 --> 00:19:36.687
of that authorization.

00:19:36.687 --> 00:19:38.770
And that's what you want
to have with IoT as well.

00:19:38.770 --> 00:19:42.220
You want to have that
passive expiration.

00:19:42.220 --> 00:19:46.390
So if it's revoked, once the
current set of access tokens

00:19:46.390 --> 00:19:48.060
expire, there's no more access.

00:19:48.060 --> 00:19:50.932
There's no way to go get
another access token.

00:19:50.932 --> 00:19:52.390
You don't want to
be in a situation

00:19:52.390 --> 00:19:55.626
where you have to pull an unused
IoT device out of a closet,

00:19:55.626 --> 00:19:58.000
hope it still boots up, and
do some kind of factory reset

00:19:58.000 --> 00:19:59.920
in order to de-authorize it.

00:19:59.920 --> 00:20:01.734
You want to be able
to do that passively.

00:20:04.520 --> 00:20:07.792
So this is a snippet from
the OAuth spec rfc6749,

00:20:07.792 --> 00:20:09.840
depicting the
refresh token flow.

00:20:09.840 --> 00:20:12.710
You can see in the
middle, the access token

00:20:12.710 --> 00:20:15.955
is used to access a protected
resource and resource server.

00:20:15.955 --> 00:20:20.270
In steps E and F, that's where
the access token's expired.

00:20:20.270 --> 00:20:21.650
And you'll get an error back.

00:20:21.650 --> 00:20:22.860
And then down at
the bottom, G and H,

00:20:22.860 --> 00:20:24.359
you can see the
refresh token's used

00:20:24.359 --> 00:20:27.440
to go get another access token
from an authorization server.

00:20:27.440 --> 00:20:28.949
Hopefully, that
helps you visualize

00:20:28.949 --> 00:20:29.990
that a little bit better.

00:20:33.074 --> 00:20:34.490
So let's think
about authorization

00:20:34.490 --> 00:20:37.100
in the context of IoT,
or of an IoT device.

00:20:37.100 --> 00:20:38.570
We talked about
the authentication

00:20:38.570 --> 00:20:39.890
needs to go both ways.

00:20:39.890 --> 00:20:42.784
Authorization needs to
go both ways as well.

00:20:42.784 --> 00:20:45.200
Or at least, we need to think
about it in both directions.

00:20:45.200 --> 00:20:48.800
We need to think about who
has access to a device, who

00:20:48.800 --> 00:20:51.260
can send commands to the
device, who can read data

00:20:51.260 --> 00:20:52.680
from the device, and so forth.

00:20:52.680 --> 00:20:56.350
We also need to think about what
does a device have access to?

00:20:56.350 --> 00:20:59.800
What rights does it have when
it connects to a web service,

00:20:59.800 --> 00:21:00.300
for example?

00:21:03.850 --> 00:21:06.390
We want to use the principle
of least privilege.

00:21:06.390 --> 00:21:10.472
We don't want to give more
privilege than necessary.

00:21:10.472 --> 00:21:12.180
This is a really common
problem with IoT,

00:21:12.180 --> 00:21:14.550
and I think it's because
it's so easy to just give

00:21:14.550 --> 00:21:17.469
the device total authorization
for the service it's

00:21:17.469 --> 00:21:20.010
connecting to, because then you
won't have any more problems.

00:21:20.010 --> 00:21:22.060
You won't have any
authorization errors,

00:21:22.060 --> 00:21:23.310
and everything will just work.

00:21:23.310 --> 00:21:25.320
The problem is if
the device is only

00:21:25.320 --> 00:21:31.110
using 10% of that authorization,
if your device gets hacked,

00:21:31.110 --> 00:21:32.970
now the attacker has
access to all of it,

00:21:32.970 --> 00:21:34.345
even though you
weren't using it.

00:21:37.910 --> 00:21:39.160
You also want the expiry.

00:21:39.160 --> 00:21:41.860
I talked about the
passive expiration.

00:21:41.860 --> 00:21:44.590
You also want to be careful
when you're passing your tokens.

00:21:44.590 --> 00:21:46.180
Tokens are, of
course, made to be

00:21:46.180 --> 00:21:49.879
passed for specific purposes,
verification for example.

00:21:49.879 --> 00:21:51.420
But you want to make
sure that you've

00:21:51.420 --> 00:21:55.090
authenticated the recipient
before you send your token.

00:21:55.090 --> 00:21:57.820
If you're sending it up to a
web service for verification,

00:21:57.820 --> 00:21:59.410
make sure it's over HTTPS.

00:22:02.344 --> 00:22:03.760
If you're purchasing
a new device,

00:22:03.760 --> 00:22:07.030
like our "TensorWash" case,
authenticate that new device

00:22:07.030 --> 00:22:10.200
before you send over the token.

00:22:10.200 --> 00:22:13.790
As you'll see in a few minutes,
Google services like Firebase

00:22:13.790 --> 00:22:16.684
on Android Things, the Firebase
SDK will manage tokens for you.

00:22:16.684 --> 00:22:19.100
You don't have to worry about
this token management, which

00:22:19.100 --> 00:22:19.600
is great.

00:22:23.440 --> 00:22:25.190
So let's go back and
look at authorization

00:22:25.190 --> 00:22:27.460
in our "TensorWash"
scenario specifically.

00:22:27.460 --> 00:22:29.970
We start in this state, where
we assume the phone is already

00:22:29.970 --> 00:22:33.030
authorized to set up new devices
with these cloud services.

00:22:33.030 --> 00:22:34.650
And the phone is
implicitly authorized

00:22:34.650 --> 00:22:36.780
to set up the "TensorWash"
device, because it doesn't

00:22:36.780 --> 00:22:37.988
have any policies about that.

00:22:40.830 --> 00:22:43.026
And where we want to be
after we provision is we

00:22:43.026 --> 00:22:45.150
want to have a two-way
authorization with Firebase.

00:22:45.150 --> 00:22:47.790
So we're going to use the
Firebase Realtime Database.

00:22:47.790 --> 00:22:49.831
And it can sync
down to the device.

00:22:49.831 --> 00:22:52.080
It can also sync data from
the device up to the cloud.

00:22:52.080 --> 00:22:53.340
And when it syncs
down to the device,

00:22:53.340 --> 00:22:55.600
we can actually use that to
issue commands to the device.

00:22:55.600 --> 00:22:58.170
And so there's an authorization
where Firebase is authorized

00:22:58.170 --> 00:23:01.170
to give commands to the
device, and the device

00:23:01.170 --> 00:23:05.440
is authorized to push data
back up into Firebase.

00:23:05.440 --> 00:23:09.260
For Cloud IoT Core, we put the
arrow in just one direction,

00:23:09.260 --> 00:23:11.670
because what we're going to
be using it for is metrics.

00:23:11.670 --> 00:23:13.790
So as the device
is working, it's

00:23:13.790 --> 00:23:16.075
pushing metrics up into
the Cloud IoT Core project.

00:23:16.075 --> 00:23:17.450
It needs to be
authorized to push

00:23:17.450 --> 00:23:18.658
into that particular project.

00:23:21.410 --> 00:23:24.261
So we're going to show you the
details of how you set this

00:23:24.261 --> 00:23:24.760
all up.

00:23:24.760 --> 00:23:27.870
First, I'm want to talk
about one more key concept,

00:23:27.870 --> 00:23:31.330
and that is attestation.

00:23:31.330 --> 00:23:35.050
Attestation is really proving
the integrity of a computing

00:23:35.050 --> 00:23:39.790
device with state, so
including the current operating

00:23:39.790 --> 00:23:41.050
state of the device.

00:23:41.050 --> 00:23:43.886
So it's really a special
kind of authentication.

00:23:43.886 --> 00:23:45.260
In order for this
to be possible,

00:23:45.260 --> 00:23:48.260
the device needs to already
have some kind of a credential

00:23:48.260 --> 00:23:49.996
that it can use to prove itself.

00:23:49.996 --> 00:23:51.620
It often is a provision
of the factory.

00:23:51.620 --> 00:23:53.660
So when the device
comes out of the box,

00:23:53.660 --> 00:23:56.090
it can already prove that
it's a genuine instance

00:23:56.090 --> 00:23:59.434
of that particular product.

00:23:59.434 --> 00:24:01.850
It's also worth mentioning
that attestation is often bound

00:24:01.850 --> 00:24:04.060
to a cryptographic key.

00:24:04.060 --> 00:24:06.950
So instead of the attestation
assertion from the device,

00:24:06.950 --> 00:24:11.780
saying, I'm a genuine device
running in a secure mode,

00:24:11.780 --> 00:24:14.690
it's a bit more like, this
particular cryptographic key

00:24:14.690 --> 00:24:16.580
is securely held
by a genuine device

00:24:16.580 --> 00:24:18.369
running in a secure mode.

00:24:18.369 --> 00:24:19.910
And this is useful,
because it allows

00:24:19.910 --> 00:24:22.489
us to bind the attestation
to something else that

00:24:22.489 --> 00:24:24.530
uses the key-- some other
kind of authentication,

00:24:24.530 --> 00:24:25.550
for instance.

00:24:25.550 --> 00:24:28.610
And you'll see in
the example later

00:24:28.610 --> 00:24:31.490
that we use a key like this
to connect to Cloud IoT Core.

00:24:34.470 --> 00:24:38.150
So an Android
Thing specifically,

00:24:38.150 --> 00:24:40.520
you can attest
various properties.

00:24:40.520 --> 00:24:43.500
You can attest that it's
authentic Android Things

00:24:43.500 --> 00:24:44.340
device.

00:24:44.340 --> 00:24:45.840
You can verify that
it's an instance

00:24:45.840 --> 00:24:47.010
of a particular product.

00:24:47.010 --> 00:24:50.130
You can verify device identity,
if you need to do that.

00:24:50.130 --> 00:24:51.720
You can also verify
device state,

00:24:51.720 --> 00:24:53.480
like I was talking about.

00:24:53.480 --> 00:24:57.510
And one of the ones that we pull
out is the verified boot state.

00:24:57.510 --> 00:25:00.930
When this device is
actually running,

00:25:00.930 --> 00:25:03.760
they prove software
for that device.

00:25:03.760 --> 00:25:06.490
You can also verify attributes
of the cryptographic key.

00:25:06.490 --> 00:25:10.020
And I won't get into that today.

00:25:10.020 --> 00:25:12.240
So this is what a
certificate chain looks like.

00:25:12.240 --> 00:25:13.640
Five levels deep.

00:25:13.640 --> 00:25:16.017
At the top, we have the
Android Things CA, Root CA,

00:25:16.017 --> 00:25:16.850
and Intermediate CA.

00:25:16.850 --> 00:25:18.080
These are managed by Google.

00:25:18.080 --> 00:25:21.310
These are the authority for
all Android Things attestation

00:25:21.310 --> 00:25:22.550
certificates.

00:25:22.550 --> 00:25:26.102
In the middle, level 3, we
have the product-specific CA.

00:25:26.102 --> 00:25:27.560
And this is also
managed by Google,

00:25:27.560 --> 00:25:29.860
but it's in the context of
the Android Things developer

00:25:29.860 --> 00:25:30.150
console.

00:25:30.150 --> 00:25:32.060
And it's associated with
a particular product

00:25:32.060 --> 00:25:32.726
on that console.

00:25:32.726 --> 00:25:35.935
Every time you go and create
a product on that console,

00:25:35.935 --> 00:25:38.060
there's going to be an
intermediate-level CA that's

00:25:38.060 --> 00:25:39.101
assigned to that product.

00:25:41.217 --> 00:25:43.300
So the next level, we have
the device-specific CA.

00:25:43.300 --> 00:25:46.340
And this is provision to
each device in the factory.

00:25:46.340 --> 00:25:47.840
This is unique per device.

00:25:47.840 --> 00:25:49.820
It contains an ID
for that device.

00:25:52.360 --> 00:25:54.660
And when your device
comes out of the box,

00:25:54.660 --> 00:25:57.524
this is the one that it has.

00:25:57.524 --> 00:25:59.065
The last level is
the application key

00:25:59.065 --> 00:25:59.630
and certificate.

00:25:59.630 --> 00:26:01.130
So this was generated
on the device.

00:26:01.130 --> 00:26:03.640
It was generated by
your application.

00:26:03.640 --> 00:26:05.550
And the certificate
is generated as well

00:26:05.550 --> 00:26:07.829
by the device-specifics
CA, which

00:26:07.829 --> 00:26:09.370
is protected by the
trusted execution

00:26:09.370 --> 00:26:10.494
environment on that device.

00:26:15.030 --> 00:26:16.680
So back in our
"TensorWash" example,

00:26:16.680 --> 00:26:19.140
the attestation happens
here with the arrow,

00:26:19.140 --> 00:26:21.790
from the "TensorWash"
device up to the phone.

00:26:21.790 --> 00:26:23.880
So when we do that
verification, remember

00:26:23.880 --> 00:26:25.690
the phone is going
to verify, it's

00:26:25.690 --> 00:26:27.550
going to authenticate
the device.

00:26:27.550 --> 00:26:29.428
That's where we're
using attestation.

00:26:31.930 --> 00:26:32.680
So a quick review.

00:26:32.680 --> 00:26:34.400
We talked about
authentication, checking

00:26:34.400 --> 00:26:35.990
that something is
genuine or valid;

00:26:35.990 --> 00:26:38.180
authorization, checking
that it is allowed

00:26:38.180 --> 00:26:40.640
to do what it's trying
to do; and attestation,

00:26:40.640 --> 00:26:44.294
which is checking integrity of
a computing device specifically.

00:26:44.294 --> 00:26:45.710
And now, Wayne is
going to show us

00:26:45.710 --> 00:26:47.459
how to do all of this
with Android Things.

00:26:47.459 --> 00:26:49.520
WAYNE PIEKARSKI: Cool, thanks.

00:26:49.520 --> 00:26:51.654
So now we've discussed
the key concepts.

00:26:51.654 --> 00:26:53.570
So now let's talk about
how we build something

00:26:53.570 --> 00:26:55.640
like this using the
various pieces that

00:26:55.640 --> 00:26:58.640
are available on Android
Things and from other services

00:26:58.640 --> 00:27:00.170
that Google provides.

00:27:00.170 --> 00:27:01.940
The first step is
we can use something

00:27:01.940 --> 00:27:03.740
called Nearby Connections.

00:27:03.740 --> 00:27:05.436
And so Nearby
Connections is great,

00:27:05.436 --> 00:27:07.310
because it provides an
abstraction layer that

00:27:07.310 --> 00:27:09.590
helps to find nearby
devices, and it

00:27:09.590 --> 00:27:12.470
establishes an encrypted
communications channel.

00:27:12.470 --> 00:27:16.640
So under the hood, it uses
Bluetooth, BLE, Wi-Fi hotspots.

00:27:16.640 --> 00:27:19.514
It uses whatever is
available to it at the time.

00:27:19.514 --> 00:27:20.930
And the other nice
thing about it,

00:27:20.930 --> 00:27:22.400
once the connection
is established,

00:27:22.400 --> 00:27:25.670
is it provides a short human
readable code on both sides

00:27:25.670 --> 00:27:28.250
that you can display on screens.

00:27:28.250 --> 00:27:30.800
Now, many of you
have used devices

00:27:30.800 --> 00:27:32.737
where it shows a little
code on the screen.

00:27:32.737 --> 00:27:34.070
And that's great, in most cases.

00:27:34.070 --> 00:27:36.111
But we mentioned earlier
that the washing machine

00:27:36.111 --> 00:27:37.550
doesn't have a screen on it.

00:27:37.550 --> 00:27:40.375
So we don't have quite
enough security that we need.

00:27:40.375 --> 00:27:41.750
And we're going
to talk about how

00:27:41.750 --> 00:27:43.050
to address that in a minute.

00:27:43.050 --> 00:27:45.790
But Nearby Connections is
the first building block

00:27:45.790 --> 00:27:46.790
that we're going to use.

00:27:46.790 --> 00:27:48.989
And so if we look at
some code snippets,

00:27:48.989 --> 00:27:50.780
this is just sort of
an abbreviated version

00:27:50.780 --> 00:27:52.814
of a Nearby Connection sample.

00:27:52.814 --> 00:27:54.980
You can see here that we
create a Nearby Connections

00:27:54.980 --> 00:27:56.350
client at the top.

00:27:56.350 --> 00:27:59.150
We then specify some
discovery options.

00:27:59.150 --> 00:28:01.490
We just used the default
value, P2P cluster.

00:28:01.490 --> 00:28:04.400
That doesn't matter so
much what we use here.

00:28:04.400 --> 00:28:06.470
And once we start the
discovery process,

00:28:06.470 --> 00:28:09.090
we need to have a service ID.

00:28:09.090 --> 00:28:12.200
So in this case, it's com
dot example dot tensorwash.

00:28:12.200 --> 00:28:14.300
And that is like our product ID.

00:28:14.300 --> 00:28:18.110
It's not the name of
your app on Android.

00:28:18.110 --> 00:28:19.520
They call it a service ID.

00:28:19.520 --> 00:28:21.440
But it's what the name
of your device is,

00:28:21.440 --> 00:28:22.880
or whatever you want to call it.

00:28:22.880 --> 00:28:25.250
And then we also have an
endpoint discovery callback,

00:28:25.250 --> 00:28:29.960
which Nearby Connections
will call your code whenever

00:28:29.960 --> 00:28:31.760
a new device is discovered.

00:28:31.760 --> 00:28:34.700
And what you would do is
you'd maintain a list view,

00:28:34.700 --> 00:28:36.320
and you would have
a UI that updates,

00:28:36.320 --> 00:28:38.360
showing all of the devices
that have been discovered--

00:28:38.360 --> 00:28:40.276
because clearly, we want
to be able to support

00:28:40.276 --> 00:28:42.501
more than one device
being available at a time.

00:28:42.501 --> 00:28:44.750
And then once the user has
selected the one they want,

00:28:44.750 --> 00:28:45.740
they can pick it.

00:28:45.740 --> 00:28:48.830
And then we can
establish a connection.

00:28:48.830 --> 00:28:51.410
On the device side,
Nearby supports

00:28:51.410 --> 00:28:53.900
a startAdvertising method,
where you basically

00:28:53.900 --> 00:28:56.970
provide a human readable
name of the device.

00:28:56.970 --> 00:28:59.060
And then you put the
same service ID in.

00:28:59.060 --> 00:29:00.800
And then you also
set up some callbacks

00:29:00.800 --> 00:29:04.050
that will be called whenever
a connection is established.

00:29:04.050 --> 00:29:08.280
So when the user has
selected the device,

00:29:08.280 --> 00:29:10.430
so they've picked
it on the screen,

00:29:10.430 --> 00:29:13.460
now we need to use the request
connection method, which

00:29:13.460 --> 00:29:15.500
will handle establishing
the connection

00:29:15.500 --> 00:29:18.590
to the remote endpoint
ID that's been passed in.

00:29:18.590 --> 00:29:20.750
Once again, there
are callbacks there.

00:29:20.750 --> 00:29:23.330
And then
onConnectionInitiated is

00:29:23.330 --> 00:29:26.630
used when the connection
is starting to that device.

00:29:26.630 --> 00:29:30.087
And it fills in a
authentication token,

00:29:30.087 --> 00:29:31.670
which is that short
code we mentioned.

00:29:31.670 --> 00:29:36.410
So Nearby Connections gives you
a short human readable value.

00:29:36.410 --> 00:29:38.080
Once again, we don't
have a display,

00:29:38.080 --> 00:29:39.960
so we'll talk about how to
deal with that in a minute.

00:29:39.960 --> 00:29:41.600
But you can see here,
the code's really simple

00:29:41.600 --> 00:29:42.950
to work with Nearby Connections.

00:29:42.950 --> 00:29:45.710
And it gets us
going quite quickly.

00:29:45.710 --> 00:29:47.780
The next thing, Darren
talked about attestation

00:29:47.780 --> 00:29:49.400
and verifying the device.

00:29:49.400 --> 00:29:52.040
So we need to make sure that
the device in front of us

00:29:52.040 --> 00:29:54.150
is the one that we're
actually connecting to.

00:29:54.150 --> 00:29:56.664
So what we do on the
phone is we actually

00:29:56.664 --> 00:29:58.330
create what's called
a random challenge.

00:29:58.330 --> 00:30:00.440
So it's a random number
that's unique just

00:30:00.440 --> 00:30:01.950
for this connection.

00:30:01.950 --> 00:30:04.520
And then we send that
over to the device.

00:30:04.520 --> 00:30:06.860
And we use this to
prevent replay attacks.

00:30:06.860 --> 00:30:08.930
And the device takes
the random challenge.

00:30:08.930 --> 00:30:11.030
It combines it with
the authentication code

00:30:11.030 --> 00:30:13.760
from Nearby Connections,
brings them together,

00:30:13.760 --> 00:30:15.770
and then it uses
this to generate

00:30:15.770 --> 00:30:18.230
a new key in the
Android Keystore

00:30:18.230 --> 00:30:20.990
with the attestation
certificate chain.

00:30:20.990 --> 00:30:23.727
This certificate chain is
then sent back to the phone.

00:30:23.727 --> 00:30:25.310
And the phone can
then check it, which

00:30:25.310 --> 00:30:26.660
we'll talk about in a minute.

00:30:26.660 --> 00:30:29.120
And even though we're
using a random challenge,

00:30:29.120 --> 00:30:31.622
the auth code from
Nearby is important,

00:30:31.622 --> 00:30:33.830
because it helps to bind it
to the encryption channel

00:30:33.830 --> 00:30:35.372
that we're using right now.

00:30:35.372 --> 00:30:37.580
And another thing is that
it's also important to rate

00:30:37.580 --> 00:30:39.330
limit failed connections.

00:30:39.330 --> 00:30:41.147
So what you don't
want is for someone

00:30:41.147 --> 00:30:42.980
to be able to constantly
connect your device

00:30:42.980 --> 00:30:46.122
and try random codes and try to
get it to generate some keys.

00:30:46.122 --> 00:30:48.080
You're better off rate
limiting that to prevent

00:30:48.080 --> 00:30:50.215
people attacking your device.

00:30:50.215 --> 00:30:51.840
Here's some of the
code that does that.

00:30:51.840 --> 00:30:53.150
Don't worry about it too much.

00:30:53.150 --> 00:30:54.608
I just wanted to
show you some bits

00:30:54.608 --> 00:30:56.240
and pieces of what there is.

00:30:56.240 --> 00:30:58.670
But on the device, we have
the authentication token

00:30:58.670 --> 00:30:59.780
from Nearby.

00:30:59.780 --> 00:31:03.410
We take in the random
challenge that we got earlier.

00:31:03.410 --> 00:31:04.790
We combine it together.

00:31:04.790 --> 00:31:07.790
We use this code to generate
the signing key here.

00:31:07.790 --> 00:31:10.850
And the interesting part about
when you generate something

00:31:10.850 --> 00:31:13.580
in the Android Keystore is
that it's done in a trusted

00:31:13.580 --> 00:31:15.020
execution environment.

00:31:15.020 --> 00:31:17.390
So we don't actually
keep the key in our app.

00:31:17.390 --> 00:31:20.180
We actually keep it in the
trusted execution environment.

00:31:20.180 --> 00:31:22.820
And this is nice,
because it means

00:31:22.820 --> 00:31:24.557
that, even if someone
hacks in our app,

00:31:24.557 --> 00:31:26.890
they don't have the ability
to pull out the private key.

00:31:26.890 --> 00:31:30.050
So that adds extra security
to what we're doing.

00:31:30.050 --> 00:31:31.680
So anyway, we put
all this stuff in.

00:31:31.680 --> 00:31:34.119
All those purple values are
all just standard constants

00:31:34.119 --> 00:31:34.660
that you use.

00:31:34.660 --> 00:31:36.634
So don't worry about
capturing this exactly.

00:31:36.634 --> 00:31:38.550
Later on, we're going
to release a sample that

00:31:38.550 --> 00:31:39.507
has all of this in it.

00:31:39.507 --> 00:31:41.590
But I just wanted to walk
you through a bit of it.

00:31:41.590 --> 00:31:49.380
But at the end, you extract
out the certificate chain.

00:31:49.380 --> 00:31:52.590
And that is what you then
pass back to the phone for it

00:31:52.590 --> 00:31:55.230
to check it and do
whatever it's going to do.

00:31:55.230 --> 00:31:59.100
So Darren mentioned earlier the
concept of a certificate chain.

00:31:59.100 --> 00:32:02.220
And so the factory
provision attestation key

00:32:02.220 --> 00:32:05.512
also comes with a certificate
chain from this leaf

00:32:05.512 --> 00:32:07.845
all the way back to the Android
Things root certificate.

00:32:07.845 --> 00:32:10.404
So now we have a full chain
for the key we just generated.

00:32:10.404 --> 00:32:12.570
So right on the bottom,
that's what we just created.

00:32:12.570 --> 00:32:16.870
And it links all the way back
to the Android Things root.

00:32:16.870 --> 00:32:18.600
So now "TensorWash"
has generated

00:32:18.600 --> 00:32:21.660
it's custom attestation
key and certificate chain.

00:32:21.660 --> 00:32:23.530
And we've sent the
chain back to the phone.

00:32:23.530 --> 00:32:25.290
So the phone needs
to verify that this

00:32:25.290 --> 00:32:28.130
is a legitimate device
that's untampered with

00:32:28.130 --> 00:32:29.880
and that it's also the
one in front of us.

00:32:29.880 --> 00:32:31.640
It's actually a pretty
tedious process.

00:32:31.640 --> 00:32:32.970
There's a number of steps.

00:32:32.970 --> 00:32:33.960
And it's probably
something that we should

00:32:33.960 --> 00:32:35.460
put in a library in the future.

00:32:35.460 --> 00:32:37.350
But the gist of
what you need to do

00:32:37.350 --> 00:32:39.120
is you need to verify
that the certificate

00:32:39.120 --> 00:32:40.800
chain is connected correctly.

00:32:40.800 --> 00:32:43.560
You need to verify that
the root is the trusted

00:32:43.560 --> 00:32:45.000
root from Android Things.

00:32:45.000 --> 00:32:47.730
You need to verify that
it's your product ID.

00:32:47.730 --> 00:32:52.465
You can verify a 128-bit
UUID for the device.

00:32:52.465 --> 00:32:54.090
This is something
that, at the factory,

00:32:54.090 --> 00:32:57.076
you could actually take and
print on the box with a code

00:32:57.076 --> 00:32:59.700
so that the user can verify that
they've actually matched it up

00:32:59.700 --> 00:33:02.290
against the one
in front of them.

00:33:02.290 --> 00:33:03.720
You can verify the boot status.

00:33:03.720 --> 00:33:05.970
When the key is
signed, it's sent over

00:33:05.970 --> 00:33:07.650
with a flag
indicating if the boot

00:33:07.650 --> 00:33:09.460
loader has been tampered with.

00:33:09.460 --> 00:33:11.580
You verify the attestation
challenge, which

00:33:11.580 --> 00:33:13.090
we'll talk about in a bit.

00:33:13.090 --> 00:33:15.570
And then you end up with a
public key that you can save.

00:33:15.570 --> 00:33:17.736
And it'll come in handy
when we want to authenticate

00:33:17.736 --> 00:33:19.040
with Cloud IoT later on.

00:33:19.040 --> 00:33:22.720
On the phone side, we need to
verify that the attestation

00:33:22.720 --> 00:33:24.060
challenge is correct.

00:33:24.060 --> 00:33:27.330
So we extract the attestation
from that certificate.

00:33:27.330 --> 00:33:30.540
And then we create a hash
of the authentication token

00:33:30.540 --> 00:33:33.390
from Nearby and the random
challenge we generated earlier.

00:33:33.390 --> 00:33:36.120
And we combine them together,
and we generate a hash.

00:33:36.120 --> 00:33:38.970
And we check that it matches
what came from the certificate

00:33:38.970 --> 00:33:40.350
chain from the device.

00:33:40.350 --> 00:33:42.420
And this sort of verifies
that this whole loop

00:33:42.420 --> 00:33:43.860
is complete and secure.

00:33:43.860 --> 00:33:45.360
And it's important,
because we never

00:33:45.360 --> 00:33:48.510
actually sent the authentication
to the device directly.

00:33:48.510 --> 00:33:50.260
It was done by Nearby.

00:33:50.260 --> 00:33:52.410
And so this checks that
everything is done right

00:33:52.410 --> 00:33:54.659
and that there's no man in
the middle attack happening

00:33:54.659 --> 00:33:55.710
along the way.

00:33:55.710 --> 00:33:58.410
So now we know that
the device is ours.

00:33:58.410 --> 00:34:02.340
And that helps to deal
with all these issues

00:34:02.340 --> 00:34:03.970
that we've identified.

00:34:03.970 --> 00:34:06.570
So now the phone has verified
it can trust "TensorWash."

00:34:06.570 --> 00:34:09.540
Now we need to authorize the
device on our Wi-Fi network.

00:34:09.540 --> 00:34:11.820
And the quickest way
is just to pop up

00:34:11.820 --> 00:34:14.219
an activity on your
phone and say, what's

00:34:14.219 --> 00:34:16.107
the Wi-Fi SSID and passphrase?

00:34:16.107 --> 00:34:17.940
But, of course, users
don't want to do that.

00:34:17.940 --> 00:34:19.500
It's not very user-friendly.

00:34:19.500 --> 00:34:22.030
And it requires the user to
enter their passphrase in.

00:34:22.030 --> 00:34:24.420
And your app gets to see
the passphrase while it's

00:34:24.420 --> 00:34:26.340
being sent over to the device.

00:34:26.340 --> 00:34:29.969
And the next thing you do
is, on the device side,

00:34:29.969 --> 00:34:31.830
you then need to use
the Wi-Fi Manager

00:34:31.830 --> 00:34:34.210
to set the SSID and passphrase.

00:34:34.210 --> 00:34:36.580
So this is a little code
snippet that does it.

00:34:36.580 --> 00:34:39.460
However, Wi-Fi Manager is a
little bit more complicated.

00:34:39.460 --> 00:34:41.290
So if you look at
the actual sample,

00:34:41.290 --> 00:34:42.712
this is the code
you need to write

00:34:42.712 --> 00:34:43.920
to talk to the Wi-Fi Manager.

00:34:43.920 --> 00:34:46.020
So this is something
that we're working on

00:34:46.020 --> 00:34:49.290
that we want to make a small
code library that you could use

00:34:49.290 --> 00:34:51.540
that skips all this to make
it so that you don't have

00:34:51.540 --> 00:34:53.250
to write that kind of code.

00:34:53.250 --> 00:34:55.679
And we have some more
good news in that

00:34:55.679 --> 00:34:58.260
we have an API called
Nearby Setup that's

00:34:58.260 --> 00:35:01.110
coming to Google Play services.

00:35:01.110 --> 00:35:03.840
And the great thing about Nearby
Setup, which is coming soon,

00:35:03.840 --> 00:35:06.180
is that it has the ability
to take the Wi-Fi credentials

00:35:06.180 --> 00:35:10.067
stored on your phone and pass
them to another devices, Google

00:35:10.067 --> 00:35:10.650
Play services.

00:35:10.650 --> 00:35:13.260
So Android Thing supports
Google Play services.

00:35:13.260 --> 00:35:15.060
You can copy the
credentials over

00:35:15.060 --> 00:35:17.130
without having to deal
with anything yourself.

00:35:17.130 --> 00:35:18.851
The user doesn't
need to type them in.

00:35:18.851 --> 00:35:20.600
And so this is great
for user convenience.

00:35:20.600 --> 00:35:22.140
So this is coming soon.

00:35:22.140 --> 00:35:25.830
And the details are going to be
on developers.google.com/nearby

00:35:25.830 --> 00:35:27.750
later on when that's ready.

00:35:27.750 --> 00:35:31.340
So we have internet access on
our device, and we have a key.

00:35:31.340 --> 00:35:32.879
So now, let's quickly
talk about how

00:35:32.879 --> 00:35:34.670
we're going to go about
talking and getting

00:35:34.670 --> 00:35:37.100
cloud services enabled
on this device.

00:35:37.100 --> 00:35:40.370
So we're going to talk about
Firebase and Cloud IoT.

00:35:40.370 --> 00:35:42.980
So the first thing we need
to do is, on the phone side,

00:35:42.980 --> 00:35:44.180
we need to set up Firebase.

00:35:44.180 --> 00:35:47.390
Firebase is great, because it
works on Android, iOS, and web.

00:35:47.390 --> 00:35:50.890
So the phone app could be
on many kinds of devices.

00:35:50.890 --> 00:35:53.110
You create a
Firebase project ID.

00:35:53.110 --> 00:35:55.820
And we're going to use that on
both the phone and the device.

00:35:55.820 --> 00:35:58.250
And then, we ask the
phone user to authenticate

00:35:58.250 --> 00:36:01.490
with their username and
password, pop up a dialog box,

00:36:01.490 --> 00:36:03.200
and we'll get a
token that we then

00:36:03.200 --> 00:36:05.861
pass down the encrypted pipe
that we created earlier.

00:36:05.861 --> 00:36:07.610
So here is a bit of a
code snippet for it.

00:36:07.610 --> 00:36:10.730
You can see at the top, we're
doing the sign-in request.

00:36:10.730 --> 00:36:13.490
And it's interesting,
because we're only requesting

00:36:13.490 --> 00:36:15.320
scope for the email ID.

00:36:15.320 --> 00:36:18.320
So we don't want to
have full Google access

00:36:18.320 --> 00:36:21.140
or access to their files or
email or anything like that.

00:36:21.140 --> 00:36:24.530
We're just asking for their
identification details,

00:36:24.530 --> 00:36:26.030
because we're trying
to limit scope,

00:36:26.030 --> 00:36:28.310
like what Darren
talked about earlier.

00:36:28.310 --> 00:36:30.620
We end up getting
a JSON web token

00:36:30.620 --> 00:36:33.290
that we can then pass in
to sign in with Firebase,

00:36:33.290 --> 00:36:38.510
which then allows our device to
interact with Firebase as well.

00:36:38.510 --> 00:36:39.602
But we ship that token.

00:36:39.602 --> 00:36:41.560
We shipped the previous
token off to the device

00:36:41.560 --> 00:36:45.270
so it can log in to Firebase
and do things with that.

00:36:45.270 --> 00:36:49.730
So on the other side, we
take the Google token,

00:36:49.730 --> 00:36:52.130
pass it to Firebase and
authenticate with that.

00:36:52.130 --> 00:36:58.610
And the device now has access to
the Firebase Realtime Database.

00:36:58.610 --> 00:37:01.610
The code snippet looks very
similar on the device as well.

00:37:01.610 --> 00:37:04.490
Because the Android Things
device is regular Android,

00:37:04.490 --> 00:37:07.070
we use the same code, just
like we do on a phone.

00:37:07.070 --> 00:37:08.810
We get the credential,
we pass it in

00:37:08.810 --> 00:37:11.329
to sign in with credential
to Firebase auth,

00:37:11.329 --> 00:37:12.120
and now we're done.

00:37:12.120 --> 00:37:14.210
We now have a bi-directional
authorization.

00:37:14.210 --> 00:37:16.070
And our "TensorWash"
now can fully

00:37:16.070 --> 00:37:19.460
participate with the
Firebase Realtime Database.

00:37:19.460 --> 00:37:21.290
So let's switch
gears to finish up.

00:37:21.290 --> 00:37:23.600
We can also talk
to Cloud IoT Core.

00:37:23.600 --> 00:37:25.970
So imagine you're running
a laundromat with thousands

00:37:25.970 --> 00:37:28.460
of machines and
thousands of locations,

00:37:28.460 --> 00:37:30.950
and you want to do predictive
breakdown analysis.

00:37:30.950 --> 00:37:34.100
So we want to push the
data from these devices

00:37:34.100 --> 00:37:35.970
to Cloud IoT for analysis.

00:37:35.970 --> 00:37:38.970
So in Cloud IoT, we
register the devices.

00:37:38.970 --> 00:37:41.510
You'd have an app on your
phone with some credentials.

00:37:41.510 --> 00:37:43.765
And you would take
that public certificate

00:37:43.765 --> 00:37:45.890
that we've created earlier,
and you would give that

00:37:45.890 --> 00:37:48.400
to Cloud IoT so that
it knows the device

00:37:48.400 --> 00:37:49.940
and that it can trust it.

00:37:49.940 --> 00:37:52.850
We then use MQTT
to send requests

00:37:52.850 --> 00:37:57.220
to Cloud IoT with our device
ID and signed with our key.

00:37:57.220 --> 00:37:59.180
Cloud IoT can verify
that this message

00:37:59.180 --> 00:38:01.910
is legitimate by
verifying this key

00:38:01.910 --> 00:38:04.190
and checking it with
what it received earlier.

00:38:04.190 --> 00:38:07.730
So then, we send the
MQT request using TLS.

00:38:07.730 --> 00:38:09.965
And we use TLS so
that our device knows

00:38:09.965 --> 00:38:12.590
that it can trust who is sending
the data to, because remember,

00:38:12.590 --> 00:38:15.790
both sides need to
check the other side.

00:38:15.790 --> 00:38:17.480
Here's a very quick
little snippet

00:38:17.480 --> 00:38:21.221
that shows how we put in some
of the project IDs and things

00:38:21.221 --> 00:38:21.720
like that.

00:38:21.720 --> 00:38:23.720
And we're going to be
releasing the sample, too,

00:38:23.720 --> 00:38:27.320
soon that shows how to do Cloud
IoT Core on Android Things.

00:38:27.320 --> 00:38:29.840
And so the nice thing is
that publishDeviceState

00:38:29.840 --> 00:38:32.870
at the bottom basically takes
any binary blob that you want

00:38:32.870 --> 00:38:34.290
and sends it off to Cloud IoT.

00:38:34.290 --> 00:38:36.123
And you don't have to
worry about generating

00:38:36.123 --> 00:38:37.410
any of the messages.

00:38:37.410 --> 00:38:40.159
So we talked very quickly
about Cloud IoT and Firebase.

00:38:40.159 --> 00:38:42.200
What are some other options
of things you can do?

00:38:42.200 --> 00:38:44.300
Well, we also have
Smart Home, which

00:38:44.300 --> 00:38:47.060
is our new way of controlling
devices from the Google

00:38:47.060 --> 00:38:47.612
Assistant.

00:38:47.612 --> 00:38:49.820
So you can do things like,
if you've got light bulbs,

00:38:49.820 --> 00:38:51.590
you can say, dim the
lights a little bit.

00:38:51.590 --> 00:38:53.270
Or, in the case of
our washing machine,

00:38:53.270 --> 00:38:54.769
if you implement
Smart Home, you can

00:38:54.769 --> 00:38:56.270
do start my washing
machine, and it

00:38:56.270 --> 00:38:59.210
will kick off a load of laundry
from the Google Assistant.

00:38:59.210 --> 00:39:01.310
And so by implementing
Firebase, you

00:39:01.310 --> 00:39:03.890
write a small web hook
that plugs into Smart Home.

00:39:03.890 --> 00:39:05.960
And then your device
can be enabled

00:39:05.960 --> 00:39:07.304
with the Google Assistant.

00:39:07.304 --> 00:39:08.720
And then finally,
you can actually

00:39:08.720 --> 00:39:12.110
embed the Google Assistant
SDK into your device, which

00:39:12.110 --> 00:39:14.330
means you can actually
talk to the washing machine

00:39:14.330 --> 00:39:16.890
and give it direct commands
to the machine directly,

00:39:16.890 --> 00:39:18.860
which is kind of cool.

00:39:18.860 --> 00:39:19.940
So what's next?

00:39:19.940 --> 00:39:22.960
We have a factory key
provisioning store coming soon.

00:39:22.960 --> 00:39:25.210
We're basically going to
have a hardware device that's

00:39:25.210 --> 00:39:27.876
going to allow you to add keys
on to Android Things devices.

00:39:27.876 --> 00:39:29.500
This is something
you could do yourself

00:39:29.500 --> 00:39:31.310
or when they're being produced.

00:39:31.310 --> 00:39:34.160
And this is how this key is
going to get onto the device.

00:39:34.160 --> 00:39:36.010
So if you have a
developer kit, you

00:39:36.010 --> 00:39:38.770
won't be able to test the
key signing correctly,

00:39:38.770 --> 00:39:41.140
because you won't have an
official key from Android

00:39:41.140 --> 00:39:41.710
Things.

00:39:41.710 --> 00:39:43.510
But we're going to be
releasing the tools

00:39:43.510 --> 00:39:44.860
to be able to do this soon.

00:39:44.860 --> 00:39:47.840
And remember that Nearby Setup
API is coming soon as well.

00:39:47.840 --> 00:39:50.350
And that's going to be really
nice to make provisioning

00:39:50.350 --> 00:39:52.240
these things really easy.

00:39:52.240 --> 00:39:54.685
So, in summary,
go visit our site

00:39:54.685 --> 00:39:58.060
at androidthings.withgoogle.com,
which is a great community

00:39:58.060 --> 00:39:59.710
site with lots of information.

00:39:59.710 --> 00:40:01.450
We have a G+
community, g.co/iotdev,

00:40:01.450 --> 00:40:03.337
where you can find
out more information,

00:40:03.337 --> 00:40:05.920
and the Nearby site, where you
can keep track of what's coming

00:40:05.920 --> 00:40:06.550
soon.

00:40:06.550 --> 00:40:08.600
And also, follow
us on social media.

00:40:08.600 --> 00:40:12.250
If you haven't had a chance,
go get yourself one of the IMX7

00:40:12.250 --> 00:40:15.490
developer kits that we're
giving away here at Google I/O.

00:40:15.490 --> 00:40:16.910
So make sure you
get one of those

00:40:16.910 --> 00:40:18.610
you can try Android
Things out yourself,

00:40:18.610 --> 00:40:20.780
because it's a really fun
development experience.

00:40:20.780 --> 00:40:22.180
It's great for
making prototypes.

00:40:22.180 --> 00:40:24.700
But it's also great for
making production devices.

00:40:24.700 --> 00:40:26.980
That's it for us, so thanks
very much for coming.

00:40:26.980 --> 00:40:28.430
And we'll see you all
around at the conference.

00:40:28.430 --> 00:40:29.176
Thank you.

00:40:29.176 --> 00:40:33.342
[MUSIC PLAYING]

