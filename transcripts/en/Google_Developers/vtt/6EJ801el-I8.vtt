WEBVTT
Kind: captions
Language: en

00:00:03.399 --> 00:00:04.399
&gt;&gt;Steve Souders: Okay.

00:00:04.399 --> 00:00:05.399
Is that my cue to go?

00:00:05.399 --> 00:00:06.399
Okay.

00:00:06.399 --> 00:00:11.400
We're having a current discussion about letting
people come in and sit up front, so I hope

00:00:11.400 --> 00:00:13.200
we can do that.

00:00:13.200 --> 00:00:19.160
I'm really excited to see everyone that showed
up, but I have a cold shower announcement

00:00:19.160 --> 00:00:20.160
to make.

00:00:20.160 --> 00:00:21.840
I'm not giving anything away.

00:00:21.840 --> 00:00:25.850
So although that's not entirely true.

00:00:25.850 --> 00:00:31.849
I'm giving away information and knowledge,
but nothing that physically you can take home

00:00:31.849 --> 00:00:35.770
and give to your kids if that's what they're
expecting.

00:00:35.770 --> 00:00:44.070
So I'm going to talk about HTML5 from a performance
perspective, but first I'm going to start

00:00:44.070 --> 00:00:50.520
off and give a little background on my work
in working on Web performance and kind of

00:00:50.520 --> 00:00:51.520
the motivation.

00:00:51.520 --> 00:00:55.960
I think probably a lot of people -- how many
people here build Web sites?

00:00:55.960 --> 00:01:00.010
Yeah, okay, great.

00:01:00.010 --> 00:01:08.000
So I think there's something in the DNA of
engineers in general, and especially programmers,

00:01:08.000 --> 00:01:10.370
to be efficient and optimize.

00:01:10.370 --> 00:01:16.650
I think as developers we all like our code
-- we feel proud if people -- if we can say

00:01:16.650 --> 00:01:20.180
about our code that it's really fast and efficient.

00:01:20.180 --> 00:01:27.110
And so at the beginning I'm going to talk
about how we can try to work to instill that

00:01:27.110 --> 00:01:32.180
interest and buy-in for performance across
other parts of the organization outside of

00:01:32.180 --> 00:01:33.180
engineering.

00:01:33.180 --> 00:01:36.800
So there will be a little preamble on that
and then we'll dive into the HTML5 stuff.

00:01:36.800 --> 00:01:41.910
I just want to mention the slides are up on
my Web site, stevesouders.com.

00:01:41.910 --> 00:01:43.400
If you go there there's a link to it.

00:01:43.400 --> 00:01:47.909
You can check that out.

00:01:47.909 --> 00:01:48.909
Okay.

00:01:48.909 --> 00:01:55.300
So let's get started -- oh, the other thing
I want to mention is really more than what

00:01:55.300 --> 00:02:01.940
I say and more than the words on the slides,
I really want people to pay attention to the

00:02:01.940 --> 00:02:04.070
photos in the background of the slides.

00:02:04.070 --> 00:02:08.000
[ Laughter ]
&gt;&gt;Steve Souders: Come on, we're going to -- loosen

00:02:08.000 --> 00:02:09.000
up a little bit.

00:02:09.000 --> 00:02:10.000
Let's go.

00:02:10.000 --> 00:02:13.709
I mean, like the story of my life, like I
take slow things and make them fast, like

00:02:13.709 --> 00:02:15.549
is that very appropriate or what?

00:02:15.549 --> 00:02:17.529
I need more feedback.

00:02:17.529 --> 00:02:23.870
[ Applause ]
&gt;&gt;Steve Souders: Yeah, okay, there we go.

00:02:23.870 --> 00:02:25.769
I worked at Yahoo for a long time, eight years.

00:02:25.769 --> 00:02:29.010
I was going to be there one year and I was
there eight years.

00:02:29.010 --> 00:02:34.489
And about four and a half years ago I joined
Google, which was really my goal when I first

00:02:34.489 --> 00:02:38.019
started on Web performance because I knew
the people at Google really cared about making

00:02:38.019 --> 00:02:40.099
things fast, and it's true.

00:02:40.099 --> 00:02:42.249
So I've been there four and a half years.

00:02:42.249 --> 00:02:50.579
I do mostly open source stuff, so I did -- I
created YSlow, Cuzillion, Sprite Me, Hammerhead,

00:02:50.579 --> 00:02:51.579
Browserscope.

00:02:51.579 --> 00:02:55.019
Lindsey Simon now runs that project, very
successful project.

00:02:55.019 --> 00:03:00.359
Jdrop, which is a great concept, but not such
a successful project, but you should check

00:03:00.359 --> 00:03:01.480
it out.

00:03:01.480 --> 00:03:08.250
HTTP Archive, another one I don't have time
to talk about today, but check it out, HTTParchive.org.

00:03:08.250 --> 00:03:11.799
I wrote "High Performance Web sites," "Even
Faster Web sites."

00:03:11.799 --> 00:03:15.900
I taught at Stanford based on the books and
I run the velocity conference.

00:03:15.900 --> 00:03:17.519
Oh, I have to update.

00:03:17.519 --> 00:03:19.579
We just had it this week in fact.

00:03:19.579 --> 00:03:22.310
I just finished that on Wednesday.

00:03:22.310 --> 00:03:26.079
So I've been doing this performance stuff
for quite a listening time now, seven years,

00:03:26.079 --> 00:03:32.749
I think, but when I started back in 2004 I
kind of felt like the lone voice in the woods.

00:03:32.749 --> 00:03:37.169
So really I'm sure there were people that
were working on it back then, but when I searched

00:03:37.169 --> 00:03:41.689
for information about making Web sites faster,
I really didn't find very much.

00:03:41.689 --> 00:03:47.359
There was a great blog post from David Hyatt
that actually really opened my eyes to where

00:03:47.359 --> 00:03:51.209
I should look for making Web sites faster.

00:03:51.209 --> 00:03:56.439
I should mention that when I talk about performance,
I mean that from the end user's perspective.

00:03:56.439 --> 00:04:01.200
My goal when I started this in 2004 was to
make the user experience fast.

00:04:01.200 --> 00:04:07.329
Now, there's another aspect of performance
which I think of more as efficiency or scalability

00:04:07.329 --> 00:04:08.769
on back end servers.

00:04:08.769 --> 00:04:14.599
How can we handle 10X the current number of
users with the same hardware?

00:04:14.599 --> 00:04:19.370
Those kinds of efficiency optimizations are
also performance, but when I say performance,

00:04:19.370 --> 00:04:22.580
I really mean speed, speed of the user experience.

00:04:22.580 --> 00:04:27.419
So when I first started working on this there
really wasn't that much information out there

00:04:27.419 --> 00:04:32.630
and I would try to go -- I started documenting
things, writing books, blogging, trying to

00:04:32.630 --> 00:04:36.330
go to other teams and convince them to focus
on performance.

00:04:36.330 --> 00:04:40.250
And it's kind of like QA or writing unit tests.

00:04:40.250 --> 00:04:47.540
Like try to sell unit tests -- time to build
unit tests to someone from marketing or sales.

00:04:47.540 --> 00:04:52.250
That's kind of hard to do, because it's hard
to visually see the benefit of that.

00:04:52.250 --> 00:04:56.940
So at the beginning it was kind of the same
thing with talking about make the Web site

00:04:56.940 --> 00:04:57.940
faster.

00:04:57.940 --> 00:05:01.530
Yeah, we need like a couple of people to work
for at least six months.

00:05:01.530 --> 00:05:05.639
And you won't see anything different on the
site, it will just feel faster.

00:05:05.639 --> 00:05:07.780
And believe me, that's really critical.

00:05:07.780 --> 00:05:11.390
And they're like no, really we want you to
add more flash.

00:05:11.390 --> 00:05:12.569
[Laughter].

00:05:12.569 --> 00:05:20.260
&gt;&gt;Steve Souders: And so fast forward to 2010,
future of Web apps.

00:05:20.260 --> 00:05:21.509
We have Fred Wilson.

00:05:21.509 --> 00:05:23.520
How many people know Fred Wilson?

00:05:23.520 --> 00:05:26.020
Like one of the most prolific bloggers.

00:05:26.020 --> 00:05:31.949
He's the number one VC out of New York City,
out of Union Square, very techy guy.

00:05:31.949 --> 00:05:37.150
But really his business is investment, funding
startup companies.

00:05:37.150 --> 00:05:42.860
Here he is speaking at a tech conference about
his 10 golden principles of successful Web

00:05:42.860 --> 00:05:43.860
apps.

00:05:43.860 --> 00:05:44.860
What's number one?

00:05:44.860 --> 00:05:45.860
Speed.

00:05:45.860 --> 00:05:49.319
He says, First and foremost we believe that
speed is more than a feature, speed is the

00:05:49.319 --> 00:05:50.819
most important feature.

00:05:50.819 --> 00:05:57.189
And he goes on to talk about with their portfolio
companies they track all of the company's

00:05:57.189 --> 00:06:02.010
performance, speed, page load time for real
users.

00:06:02.010 --> 00:06:09.379
And that in their experience the data shows
that when the speed drops off, the success

00:06:09.379 --> 00:06:10.949
of the business drops off.

00:06:10.949 --> 00:06:16.150
And that's why they do this for all the portfolio
companies that they work with.

00:06:16.150 --> 00:06:21.389
And so I think that's to me like Web performance
has arrived.

00:06:21.389 --> 00:06:26.310
We have a VC talking at a tech conference
about speed, like this was beautiful to me.

00:06:26.310 --> 00:06:28.819
I start almost every slide deck with this
slide.

00:06:28.819 --> 00:06:36.060
And actually, a partner of Fred's spoke at
the Velocity conference this week.

00:06:36.060 --> 00:06:40.560
And in addition -- if that's not enough to
have the number one VC out of New York City

00:06:40.560 --> 00:06:44.720
talking about performance, I'm going to run
through a bunch of case studies here that

00:06:44.720 --> 00:06:49.430
correlate performance speed to the success
of the business.

00:06:49.430 --> 00:06:55.430
So here's -- about two years ago Bing and
Google Search got up on stage at the same

00:06:55.430 --> 00:06:58.439
time and talked about experiments they had
run.

00:06:58.439 --> 00:07:02.990
Bing introduced intentionally a delay in serving
search results.

00:07:02.990 --> 00:07:04.669
They took it up to two seconds.

00:07:04.669 --> 00:07:08.250
At a two-second delay they saw all their goodness
metrics drop off.

00:07:08.250 --> 00:07:13.550
Most significantly revenue per user dropped
off four percent.

00:07:13.550 --> 00:07:18.449
And of course, these companies are doing this
on a very small sample size.

00:07:18.449 --> 00:07:21.490
So Google took this up to 400 milliseconds
at the max.

00:07:21.490 --> 00:07:27.659
Didn't see that much dropoff in searches per
user, although at Google scale that's a fairly

00:07:27.659 --> 00:07:29.620
significant dropoff.

00:07:29.620 --> 00:07:35.720
The thing that was really interesting about
this study was after they removed the delay,

00:07:35.720 --> 00:07:41.000
they kept that user group segmented and tracked
their usage.

00:07:41.000 --> 00:07:47.900
And it took I think six weeks for the usage,
the searches per day, and other goodness metrics,

00:07:47.900 --> 00:07:51.120
to resume where they were before the experiment
started.

00:07:51.120 --> 00:07:58.129
So the user's awareness of what the experience
is like is something that gets ingrained and

00:07:58.129 --> 00:08:04.530
lives with them and it takes a long time to
build that and to recover from delays.

00:08:04.530 --> 00:08:08.370
So it's important to stay on top of keeping
your Web site fast.

00:08:08.370 --> 00:08:11.260
And Yahoo ran a similar study.

00:08:11.260 --> 00:08:18.031
And for full page traffic, that means traffic
where the onload event actually fires, a 400-millisecond

00:08:18.031 --> 00:08:23.400
delay saw a five to nine percent dropoff in
traffic.

00:08:23.400 --> 00:08:25.699
Here Mozilla -- this is about a year old.

00:08:25.699 --> 00:08:31.900
Mozilla, when you want to upgrade to Firefox
and you're in Internet Explorer, you get the

00:08:31.900 --> 00:08:39.230
IE landing page, and they made that IE Firefox
landing page 2.2 seconds faster, and they

00:08:39.230 --> 00:08:43.320
saw a 15% lift in Firefox downloads.

00:08:43.320 --> 00:08:47.420
So for them that's their business metric,
being a nonprofit.

00:08:47.420 --> 00:08:50.750
And this was a seminal study from Velocity
a few years ago.

00:08:50.750 --> 00:08:57.100
Shopzilla did a tremendous performance effort,
taking their site from seven seconds to about

00:08:57.100 --> 00:09:02.940
three seconds, and they saw conversion rate
go up seven to 12 percent depending on the

00:09:02.940 --> 00:09:03.940
country.

00:09:03.940 --> 00:09:05.070
This is very significant.

00:09:05.070 --> 00:09:11.050
They saw the unique users from search engine
marketing more than double.

00:09:11.050 --> 00:09:15.600
And this was the first study that showed another
benefit in addition to the business metrics

00:09:15.600 --> 00:09:17.920
is operating costs going down.

00:09:17.920 --> 00:09:24.680
So here we have the number of servers needed
to run the Web site after this optimization

00:09:24.680 --> 00:09:25.680
dropped.

00:09:25.680 --> 00:09:30.950
And that kind of makes sense because like
one of the optimizations is connecting scripts

00:09:30.950 --> 00:09:35.390
together, so instead of making seven requests
to my server, I'm only making one.

00:09:35.390 --> 00:09:41.040
Turn on Gzip so the amount of time it takes
for the response to get off the server box

00:09:41.040 --> 00:09:45.480
is lowered and so the server can handle a
higher QPS.

00:09:45.480 --> 00:09:50.880
And then following that a good friend of mine,
Bill Scott, when he was at Netflix, they had

00:09:50.880 --> 00:09:54.670
-- they didn't have Gzip turned on for some
reason.

00:09:54.670 --> 00:09:57.850
I can go into it after if people want to ask.

00:09:57.850 --> 00:10:02.720
And he turned it on one day and the [Indiscernible]
said the Web site is down, all we're serving

00:10:02.720 --> 00:10:03.800
is the error page.

00:10:03.800 --> 00:10:05.790
And he said why do you think that?

00:10:05.790 --> 00:10:08.540
And they said the traffic in our data server
has dropped in half.

00:10:08.540 --> 00:10:12.560
He said, Nope, we're serving everything, it's
just that we turned on Gzip.

00:10:12.560 --> 00:10:18.200
So this is probably six figures a month in
a data center that they saved.

00:10:18.200 --> 00:10:19.260
Pretty significant.

00:10:19.260 --> 00:10:26.270
Here's another example, Edmunds.com turned
on -- added an expires header so that their

00:10:26.270 --> 00:10:32.120
resources through their CDN could be cached
and they saw their CDN traffic drop by a third.

00:10:32.120 --> 00:10:40.520
So again, this is a six-figure maybe high
five-figure savings per month from CDN costs.

00:10:40.520 --> 00:10:45.830
And then not that recently anymore, this was
about a year and a half ago, Google announced

00:10:45.830 --> 00:10:51.160
that speed or latency was going to be taken
into consideration for page rank.

00:10:51.160 --> 00:10:55.680
And that was caveated, it's one of two hundred
signals, it only effects about one percent

00:10:55.680 --> 00:11:01.760
of search results, but still it's a consideration
and page rank is really important.

00:11:01.760 --> 00:11:05.630
All of these things about a year, year and
a half ago I saw coming together and so I

00:11:05.630 --> 00:11:11.150
coined a new catch phrase for this emerging
industry called WPO.

00:11:11.150 --> 00:11:14.870
It stands for Web Performance Optimization.

00:11:14.870 --> 00:11:20.550
And actually as I mentioned, I keep mentioning,
we just had Velocity this week, there were

00:11:20.550 --> 00:11:21.550
a number.

00:11:21.550 --> 00:11:25.520
Sequoia, Battery Ventures, Excel, Union Square
were all there.

00:11:25.520 --> 00:11:27.200
This industry is really growing up.

00:11:27.200 --> 00:11:31.160
There's a number of startups in this Web performance
space now.

00:11:31.160 --> 00:11:34.420
And the elevator pitch is it drives traffic
to your site.

00:11:34.420 --> 00:11:38.540
We see that with search engine marketing,
with page rank.

00:11:38.540 --> 00:11:41.270
It improves the user experience.

00:11:41.270 --> 00:11:45.810
You would think that making Web sites faster
the user would get in and out more quickly,

00:11:45.810 --> 00:11:47.000
and it's just the opposite.

00:11:47.000 --> 00:11:53.160
All of these studies show that page views
per session, session length all increase because

00:11:53.160 --> 00:11:55.530
the users are having a better experience.

00:11:55.530 --> 00:11:57.350
It increases revenue.

00:11:57.350 --> 00:12:03.180
We saw stats on that with conversions, downloads,
and it reduces operating costs.

00:12:03.180 --> 00:12:05.910
So this all sounds pretty good, right?

00:12:05.910 --> 00:12:09.000
Web PO is really taking off.

00:12:09.000 --> 00:12:11.030
All right, that's the preamble.

00:12:11.030 --> 00:12:15.670
How many people here think fast Web sites
are good?

00:12:15.670 --> 00:12:16.670
All right.

00:12:16.670 --> 00:12:20.800
So hopefully if you're having trouble selling
that -- if this is stuff that you want to

00:12:20.800 --> 00:12:24.680
work on and you're having trouble selling
that back home, you can take some of these

00:12:24.680 --> 00:12:28.970
case studies and show people back home that
this is a good investment.

00:12:28.970 --> 00:12:31.810
You'll actually get a positive ROI.

00:12:31.810 --> 00:12:35.520
And maybe these will give a little guidance
on what you can track on the business side

00:12:35.520 --> 00:12:39.350
to actually correlate performance improvements
with the goals of the business.

00:12:39.350 --> 00:12:40.350
All right.

00:12:40.350 --> 00:12:43.170
So let's transition into the meat of the topic.

00:12:43.170 --> 00:12:46.080
I don't want to debate about what HTML5 is.

00:12:46.080 --> 00:12:47.080
There's the spec.

00:12:47.080 --> 00:12:48.080
I also mean CSS3.

00:12:48.080 --> 00:12:50.360
It's the new stuff.

00:12:50.360 --> 00:12:57.020
So I'm going to highlight a few things around
HTML5 and CSS3 that I think are really important

00:12:57.020 --> 00:13:01.900
to pay attention to from a performance perspective.

00:13:01.900 --> 00:13:07.670
So the first is if you want to optimize something
you need to be able to measure it.

00:13:07.670 --> 00:13:16.750
And right now what we'd really like to measure
is the user's perception of speed.

00:13:16.750 --> 00:13:21.710
Currently there's no JavaScript handler for
brain activity.

00:13:21.710 --> 00:13:28.020
So what we've been using as an industry -- as
a proxy for that is the window onload event.

00:13:28.020 --> 00:13:33.950
Now, the problem with that is, for example,
if I do a Google search and I click on a search

00:13:33.950 --> 00:13:39.840
result that takes me to Whole Foods, and I
want to measure -- from Whole Foods' perspective,

00:13:39.840 --> 00:13:43.781
they want to know how long it took for the
user to click that link to when Whole Foods

00:13:43.781 --> 00:13:44.781
was ready.

00:13:44.781 --> 00:13:47.020
And the problem is tracking the start time.

00:13:47.020 --> 00:13:52.170
How do you track the time that the user started
by clicking on that link?

00:13:52.170 --> 00:13:54.770
Because that's the user's perception time.

00:13:54.770 --> 00:13:59.740
And what you can do is at the top of the Whole
Foods page you can put a script lock that

00:13:59.740 --> 00:14:04.300
takes a time measurement, but that totally
ignores the time it takes for the request

00:14:04.300 --> 00:14:09.070
to go up to the Whole Foods server, for it
to stitch together all of the content and

00:14:09.070 --> 00:14:11.360
send that back down to the browser.

00:14:11.360 --> 00:14:17.600
So about two years ago Google and Microsoft
formed this Web performance working group

00:14:17.600 --> 00:14:24.890
as part of the W3C, and the first task was
to create the Web timing spec, which is actually

00:14:24.890 --> 00:14:29.440
three specs, navigation timing, user timing,
resource timing.

00:14:29.440 --> 00:14:33.850
How many people here use navigation timing
to measure Web sites?

00:14:33.850 --> 00:14:35.210
Good.

00:14:35.210 --> 00:14:37.170
It's not good that there were so few hands
up.

00:14:37.170 --> 00:14:41.370
It's good because I'm going to talk about
it a little bit.

00:14:41.370 --> 00:14:46.540
So those of three and I'm going to talk about
each one in a little bit more detail.

00:14:46.540 --> 00:14:50.850
They're also working on a few other specs,
page visibility I'll touch on quickly.

00:14:50.850 --> 00:14:54.580
Script-base animations I'm not going to spend
too much time on, but people are doing a lot

00:14:54.580 --> 00:14:58.120
of animation with JavaScript and they're working
on making that better.

00:14:58.120 --> 00:15:02.410
And efficient script yielding, since the browsers
are single threaded, if you have long running

00:15:02.410 --> 00:15:06.550
JavaScript it can really degrade the user
experience.

00:15:06.550 --> 00:15:10.360
So what can scripts do to mitigate that.

00:15:10.360 --> 00:15:11.920
But let me talk about the timing specs.

00:15:11.920 --> 00:15:15.280
So navigation timing actually is out.

00:15:15.280 --> 00:15:18.620
The spec is done and it's available today.

00:15:18.620 --> 00:15:23.690
If you look at window.performance, there's
this timing object.

00:15:23.690 --> 00:15:30.370
And you can do things like from the timing
object you can get the navigation start and

00:15:30.370 --> 00:15:32.890
the load event end, take the difference.

00:15:32.890 --> 00:15:37.120
And the nice thing is that the Web timing
spec gives us two main things.

00:15:37.120 --> 00:15:38.590
This is the first one.

00:15:38.590 --> 00:15:43.760
This is the time at which the -- the epic
time at which the user clicked on that link

00:15:43.760 --> 00:15:45.970
on Google.

00:15:45.970 --> 00:15:53.120
So now the user can -- the Web site owner
can get the full time from when the click

00:15:53.120 --> 00:15:57.170
happened to when the onload event or whatever
event you wanted to.

00:15:57.170 --> 00:16:01.200
And in fact if you put a little time stamp
at the top of the page you can break that

00:16:01.200 --> 00:16:06.020
into what I call the back end time, the time
from the click to when the first byte arrived

00:16:06.020 --> 00:16:10.130
and the time from the first byte to when the
full page loaded.

00:16:10.130 --> 00:16:12.240
And there's a bunch of other timings in there.

00:16:12.240 --> 00:16:14.600
You can get DNS time and connection time.

00:16:14.600 --> 00:16:19.170
There are a bunch of time values that you
can get in there.

00:16:19.170 --> 00:16:23.530
So this has been out -- the spec was finished
probably about six months ago, maybe a little

00:16:23.530 --> 00:16:24.540
longer.

00:16:24.540 --> 00:16:29.280
And I think IE 9 -- no, I think Chrome was
the first to implement it.

00:16:29.280 --> 00:16:32.310
But it's in IE 9 and up, Firefox 7 and up.

00:16:32.310 --> 00:16:38.020
They had some bugs in the Firefox 7 in the
early days, but those are all fixed now.

00:16:38.020 --> 00:16:39.820
It's on Android.

00:16:39.820 --> 00:16:44.190
And I heard a month ago it's on Blackberry,
but I haven't tested that.

00:16:44.190 --> 00:16:48.700
And here's a good URL from Tony Gentilcore
that kind of explains how you could use it

00:16:48.700 --> 00:16:52.990
and some examples of getting different time
values.

00:16:52.990 --> 00:16:59.610
So one thing that's really cool is Google
is taking -- for page rank is taking time

00:16:59.610 --> 00:17:04.040
into consideration, but when they announce
that -- I'm really proud of the work from

00:17:04.040 --> 00:17:09.120
the make the Web faster team at Google, where
it wasn't like okay, we're going to hold you

00:17:09.120 --> 00:17:11.310
responsible for it, good luck.

00:17:11.310 --> 00:17:13.070
We also rolled out several tools.

00:17:13.070 --> 00:17:20.510
In Webmaster tools you can go in there and
you can see how your site compares its speed,

00:17:20.510 --> 00:17:23.230
compares to the rest of the industry.

00:17:23.230 --> 00:17:28.329
And really the folks who were going to get
penalized from a page rank perspective are

00:17:28.329 --> 00:17:31.570
going to be in the lower 10%, maybe even lower
than that.

00:17:31.570 --> 00:17:37.001
So maybe you're not awesome, but if you're
in the top 50% you probably don't have too

00:17:37.001 --> 00:17:38.540
much to worry about there.

00:17:38.540 --> 00:17:43.471
So that's a little help, but the other thing
that's nice to get more granularity, if you

00:17:43.471 --> 00:17:49.750
use Google analytics, we added this time measurement
capability in Google Analytics.

00:17:49.750 --> 00:17:55.770
I think we call it site speed -- yeah, site
speed.

00:17:55.770 --> 00:17:58.380
Yeah, this screen dump is a little old.

00:17:58.380 --> 00:18:01.060
I think the UI is a little difference now.

00:18:01.060 --> 00:18:06.340
But the nice thing is when we first launched
it you had to add a little bit more to your

00:18:06.340 --> 00:18:12.150
Google Analytics snippet, and then about three
or four months ago we turned it on for everyone.

00:18:12.150 --> 00:18:17.810
So even if you had no awareness of the site
speed, time measurement capability, you've

00:18:17.810 --> 00:18:21.360
been gathering data for about five months
now, four or five months.

00:18:21.360 --> 00:18:26.030
So you could go to Google Analytics and go
and find this site speed tab and you could

00:18:26.030 --> 00:18:32.680
get charts, and it's the usual Google Analytics
slice and dice capabilities by browser, by

00:18:32.680 --> 00:18:37.480
geographic region, by page, and you can see
what your performance is.

00:18:37.480 --> 00:18:42.640
This is my Web site, so I don't know what
was going on there, but that was awhile ago.

00:18:42.640 --> 00:18:44.050
See, now it's fast.

00:18:44.050 --> 00:18:48.080
Well, in November it was fast.

00:18:48.080 --> 00:18:49.080
Thank you for that.

00:18:49.080 --> 00:18:50.370
I appreciate that.

00:18:50.370 --> 00:18:53.990
[ Laughter ]
&gt;&gt;Steve Souders: Oh, I think I probably -- now

00:18:53.990 --> 00:18:54.990
it's on by default.

00:18:54.990 --> 00:18:59.310
Oh, it's only in browsers that support nav
timing, so we really need mobile browsers

00:18:59.310 --> 00:19:02.300
to start supporting this more.

00:19:02.300 --> 00:19:05.750
Oh, it's sampled.

00:19:05.750 --> 00:19:08.530
So by default it's a one percent sampling
rate.

00:19:08.530 --> 00:19:11.730
If you have a huge Web site, like one percent
is probably fine.

00:19:11.730 --> 00:19:13.160
And the guys have done a really smart thing.

00:19:13.160 --> 00:19:17.500
Like they don't start it at midnight and if
you're a huge Web site you've used your one

00:19:17.500 --> 00:19:19.390
percent by 12:15.

00:19:19.390 --> 00:19:22.540
They, like, dole it out throughout the day.

00:19:22.540 --> 00:19:28.800
But if you're a smaller Web site, you can
change it with some Google Analytics commands

00:19:28.800 --> 00:19:36.460
to cover 100% of your Web site, but it's limited,
I think, to 10,000 measurements a day.

00:19:36.460 --> 00:19:40.340
But again, those will be sampled throughout
the day, so you won't get biases based on

00:19:40.340 --> 00:19:43.230
peak time and stuff like that.

00:19:43.230 --> 00:19:46.830
And then I'm just going to talk really quick
about the other two parts of the timing spec.

00:19:46.830 --> 00:19:49.440
There's resource timing.

00:19:49.440 --> 00:19:54.250
And this is -- there's drafts of this available,
but this hasn't been nailed down.

00:19:54.250 --> 00:19:58.060
I don't think there's any browser that supports
it yet because the draft is -- the spec is

00:19:58.060 --> 00:19:59.540
still being defined.

00:19:59.540 --> 00:20:04.340
But this -- if you think about it, navigation
timing is basically this same information,

00:20:04.340 --> 00:20:05.770
but it's at the page level.

00:20:05.770 --> 00:20:06.790
It's really high.

00:20:06.790 --> 00:20:11.670
And what we're doing with resource timing
is we're bringing that down to every HTTP

00:20:11.670 --> 00:20:12.720
request in the page.

00:20:12.720 --> 00:20:17.950
So for every HTTP request in the page you
can get DNS lookup time, connection time,

00:20:17.950 --> 00:20:19.640
total time for that to come back.

00:20:19.640 --> 00:20:24.770
This is going to be a great mechanism for
if you're using a CDN to track how your CDN

00:20:24.770 --> 00:20:30.620
-- or maybe you're testing out multiple CDN's,
to see how their performance is going.

00:20:30.620 --> 00:20:33.780
It does have to worry about security safeguards.

00:20:33.780 --> 00:20:39.500
So you could have some kind of hack where,
you know, on my Web site I have the logo from

00:20:39.500 --> 00:20:42.440
some nefarious Web site.

00:20:42.440 --> 00:20:46.160
And when you land on my Web site I can actually
see what the DNS time is.

00:20:46.160 --> 00:20:50.620
And if the DNS time is zero, I know that you've
been to this other Web site.

00:20:50.620 --> 00:20:55.180
So there are some security safeguards with
HTTP headers.

00:20:55.180 --> 00:21:01.020
Web sites can allow or not allow cross-domain
tracking of resource timing.

00:21:01.020 --> 00:21:05.280
And then there's also user timing, which is
really important for people building Web2O

00:21:05.280 --> 00:21:07.770
apps, AJAXy stuff.

00:21:07.770 --> 00:21:13.450
Something like Gmail that is open for several
hours, there's no concept of a page load time.

00:21:13.450 --> 00:21:15.460
There's only one of those when you start it
up.

00:21:15.460 --> 00:21:21.220
So this is, if you're doing HXE stuff like
compose, this will give you commands that

00:21:21.220 --> 00:21:27.140
you can use to say the user is about to do
a compose operation, let me -- let me mark

00:21:27.140 --> 00:21:31.790
a start time and then when the compose is
all done, you can mark an end time, you can

00:21:31.790 --> 00:21:37.370
give it a label, and so it lets you define
and track any timing episodes that you care

00:21:37.370 --> 00:21:40.200
about in the Web apps that you are building.

00:21:40.200 --> 00:21:45.490
So it basically is like nav timing but it's
much more flexible and lets you define the

00:21:45.490 --> 00:21:50.790
start and stop times whenever you want in
your code.

00:21:50.790 --> 00:21:54.350
The other one that I mentioned that they are
working on is page visibility.

00:21:54.350 --> 00:21:58.760
This one is important from a performance perspective.

00:21:58.760 --> 00:22:04.900
Mostly from a -- from an altruistic perspective,
but it could also affect, you know, what you

00:22:04.900 --> 00:22:06.440
are doing on your Web site.

00:22:06.440 --> 00:22:10.420
And so basically what the spec let's you do
is detect when your page is visible.

00:22:10.420 --> 00:22:14.490
So like one thing I do in the morning when
I come in, since I can't stand to wait for

00:22:14.490 --> 00:22:20.820
Web sites to load, is I have this script and
I -- you know, I boot up my machine, I load

00:22:20.820 --> 00:22:25.890
the script, it loads my 30 Web sites that
I read every morning and then I go get breakfast

00:22:25.890 --> 00:22:29.670
and when I come back, all of the pages are
loaded and I can just go through all of the

00:22:29.670 --> 00:22:30.690
tabs.

00:22:30.690 --> 00:22:33.130
But only the top tab is visible.

00:22:33.130 --> 00:22:37.880
And inevitably when I come back, if I left
my sound on, my office manager, you know,

00:22:37.880 --> 00:22:42.750
giving me a dirty look, because there's some
hidden tab that's playing video.

00:22:42.750 --> 00:22:47.540
And the sound -- or maybe multiple tabs that
are playing video and the sound is just annoying

00:22:47.540 --> 00:22:49.800
and it's like really?

00:22:49.800 --> 00:22:53.620
Like you started the video, even though like
the tab is not even visible?

00:22:53.620 --> 00:22:54.670
Like why did you do that?

00:22:54.670 --> 00:23:02.220
And the page visibility API introduces a way
to detect whether or not the tab of the window

00:23:02.220 --> 00:23:04.130
is visible.

00:23:04.130 --> 00:23:10.430
And so this is also really important, like,
if you are tracking metrics, like page impressions.

00:23:10.430 --> 00:23:15.550
If the user opened the tab but they're never
going to go to it, but you counted it as an

00:23:15.550 --> 00:23:17.170
impression, that's a miscount.

00:23:17.170 --> 00:23:18.530
Same thing with ads.

00:23:18.530 --> 00:23:21.880
Again, the example of video.

00:23:21.880 --> 00:23:27.000
You might be doing something like showing
them, you know, stock updates or the latest

00:23:27.000 --> 00:23:31.540
messages from friends or you might be rotating
through a carousel of photos and they're not

00:23:31.540 --> 00:23:32.630
looking at it.

00:23:32.630 --> 00:23:36.710
So not only are you kind of -- like you might
rotate through a carousel of photos that started

00:23:36.710 --> 00:23:40.950
with their favorite photo, but by the time
they opened the tab they are down to their

00:23:40.950 --> 00:23:47.600
5757th favorite photo and you have kind of
ruined the experience for yourself.

00:23:47.600 --> 00:23:48.690
So you could use it there.

00:23:48.690 --> 00:23:58.390
Um, the other thing that you can do is -- this
API can be used for pre-fetching resources.

00:23:58.390 --> 00:24:06.790
So the Web site owner can decide and -- the
Web site owner can decide if they want to

00:24:06.790 --> 00:24:13.370
pre-fetch resources maybe for the next page
and also if the page should be prerendered.

00:24:13.370 --> 00:24:15.120
This is something that Chrome does.

00:24:15.120 --> 00:24:19.260
So Chrome can actually prerender a page in
the background.

00:24:19.260 --> 00:24:25.620
But one of the problems with doing that is,
again, if there are ad impression counts or

00:24:25.620 --> 00:24:31.040
page impression counts that are firing, and
the page is being rendered in the background,

00:24:31.040 --> 00:24:34.080
and the user actually never sees it, that's
a miscount.

00:24:34.080 --> 00:24:40.800
So the page visibility API gives people controlling
those metrics the ability to only fire the

00:24:40.800 --> 00:24:43.740
metrics when it makes sense.

00:24:43.740 --> 00:24:46.770
And I think this is only in Chrome right now.

00:24:46.770 --> 00:24:51.900
But what it looks like is you can say WebKit
hidden is the property, you can look at to

00:24:51.900 --> 00:24:59.240
see whether or not the tab is hidden and this
is an event handler you can attach to to detect

00:24:59.240 --> 00:25:03.490
when the page does become visible.

00:25:03.490 --> 00:25:12.179
So we had script defer in IE for years, but
now with HTML5 the async and defer attributes

00:25:12.179 --> 00:25:19.120
are officially supported across almost every
browser out there.

00:25:19.120 --> 00:25:24.550
I'm not going to go into it here but in fact
I've talked for years and written extensively

00:25:24.550 --> 00:25:29.320
about the impact that scripts have on the
user experience.

00:25:29.320 --> 00:25:35.400
So I mentioned earlier how the UI thread,
you know, the UI is single threaded, the browser

00:25:35.400 --> 00:25:41.820
is single threaded, so if you have JavaScript,
for example, that takes three seconds to execute,

00:25:41.820 --> 00:25:45.390
the user is clicking in the browser and they
are trying to scroll the window and nothing

00:25:45.390 --> 00:25:49.860
is happening because the JavaScript is blocking
any of that interaction.

00:25:49.860 --> 00:25:53.950
And so -- so that also happens when the script
is being downloaded.

00:25:53.950 --> 00:25:58.630
So if you have a 500 k JavaScript payload
and the user has a slow connection, again,

00:25:58.630 --> 00:26:01.020
it can take seconds for that to download.

00:26:01.020 --> 00:26:05.400
While that's downloading, the UI could be
blocked.

00:26:05.400 --> 00:26:09.310
Unless you can do your script loading asynchronously.

00:26:09.310 --> 00:26:17.050
So if you just do scriptsource equals main.js
it's going to stop the HTML parser from parsing

00:26:17.050 --> 00:26:20.850
past that script tag and it's also going to
block rendering.

00:26:20.850 --> 00:26:28.230
No browser in the world will render anything
below a script tag until that script is downloaded

00:26:28.230 --> 00:26:30.270
and parsed and executed.

00:26:30.270 --> 00:26:37.250
But you can use the async attribute which
tells the browser to start the download but

00:26:37.250 --> 00:26:44.230
to go ahead and continue parsing the HTML
and rendering the DOM elements in the page.

00:26:44.230 --> 00:26:45.800
So it gives the user feedback.

00:26:45.800 --> 00:26:46.980
It's a better user experience.

00:26:46.980 --> 00:26:51.470
The user can see the page rendering, especially
because a lot of times we put scripts in the

00:26:51.470 --> 00:26:56.350
heads of our pages, which means the entire
body is blocked from rendering until all of

00:26:56.350 --> 00:26:59.750
those scripts are downloaded, parsed and executed.

00:26:59.750 --> 00:27:05.040
And so this tells the browser, download it
in the background, continue parsing; and as

00:27:05.040 --> 00:27:08.880
soon as the script arrives, parse and execute
it.

00:27:08.880 --> 00:27:14.920
So one -- two tricky things about this is
you can't have any document.write in this

00:27:14.920 --> 00:27:18.420
JavaScript code because parser is already
past that point.

00:27:18.420 --> 00:27:25.050
You are going to get very bad and varied results
across browsers if you do document.write in

00:27:25.050 --> 00:27:26.350
an async script.

00:27:26.350 --> 00:27:31.630
The other challenge with async is suppose
that I have three scripts, A, B, C, C depends

00:27:31.630 --> 00:27:38.400
on B, B depends on A. But A is probably like
jQuery, so might be my biggest script.

00:27:38.400 --> 00:27:42.203
C might be really tiny, so if I load all of
these async, which is the one that's going

00:27:42.203 --> 00:27:44.160
to come back first?

00:27:44.160 --> 00:27:45.160
C.

00:27:45.160 --> 00:27:49.309
If I loaded async, it's going to be parsed
and executed as soon as it comes back and

00:27:49.309 --> 00:27:53.860
it's going to get undefined symbol errors
because B might not be back and A might not

00:27:53.860 --> 00:27:54.860
be back.

00:27:54.860 --> 00:27:59.679
You can't just willy-nilly add an async attribute
to all of your script tags.

00:27:59.679 --> 00:28:01.930
But what you can do is you can use defer.

00:28:01.930 --> 00:28:06.110
If it's JavaScript that isn't critical for
rendering content to the page, and doesn't

00:28:06.110 --> 00:28:09.230
have document.write can add the defer attribute.

00:28:09.230 --> 00:28:10.950
It's pretty similar.

00:28:10.950 --> 00:28:16.600
It says download it in the background, let
the parser continue parsing and rendering

00:28:16.600 --> 00:28:17.980
DOM elements.

00:28:17.980 --> 00:28:23.200
After the entire page is done, parse and execute
these deferred scripts and do it in the order

00:28:23.200 --> 00:28:25.180
that they were listed in the page.

00:28:25.180 --> 00:28:30.990
And so if you have those interdependencies
across scripts, defer is a good fallback.

00:28:30.990 --> 00:28:38.260
But -- but this still doesn't give all of
the control that I think is really needed

00:28:38.260 --> 00:28:43.750
to build a good user experience for -- for
Web apps, especially on mobile.

00:28:43.750 --> 00:28:48.960
For example, one thing that I would like to
do is I would like to download maybe a big

00:28:48.960 --> 00:28:53.420
script, 100 k, 300 k, 500 k, but not parse
and execute it.

00:28:53.420 --> 00:28:58.940
It might be a script for something like popping
up a div to compose a message or address book

00:28:58.940 --> 00:29:03.970
stuff that is only needed if the user starts
typing an email message.

00:29:03.970 --> 00:29:09.580
But if I download that, as soon as it hits
the browser, the parse and execute is going

00:29:09.580 --> 00:29:11.850
to happen and it's going to lock up the UI.

00:29:11.850 --> 00:29:17.441
So I really want to get this JavaScript down
to the device, get it in cache, but parse

00:29:17.441 --> 00:29:20.690
and execute it, depending on what the user
does.

00:29:20.690 --> 00:29:25.400
The other thing that I would like to have
is a control over when the download happens.

00:29:25.400 --> 00:29:29.929
Right now the spec doesn't say when browser
should download the script.

00:29:29.929 --> 00:29:34.120
But if I've said defer, if I've said async,
certainly if I've said defer, I would like

00:29:34.120 --> 00:29:39.360
you to do this download, after everything
more important is already done, because there's

00:29:39.360 --> 00:29:45.650
a limited number of TCP connections that the
browser will make, and if you download scripts

00:29:45.650 --> 00:29:49.920
or multiple scripts, then things like the
background image of the page, the logo at

00:29:49.920 --> 00:29:55.530
the top of the page, might actually be pushed
out because you are already using the six

00:29:55.530 --> 00:29:59.620
TCP connections that most browsers allocate
to a domain.

00:29:59.620 --> 00:30:06.540
So we don't have control over those in markup,
but there are techniques that you can use

00:30:06.540 --> 00:30:08.760
to get that behavior.

00:30:08.760 --> 00:30:12.100
So this is one that Gmail wrote about quite
a while ago.

00:30:12.100 --> 00:30:15.080
Gmail mobile team.

00:30:15.080 --> 00:30:16.290
And it's a hack.

00:30:16.290 --> 00:30:18.010
I think it's a beautiful hack.

00:30:18.010 --> 00:30:24.250
So what they did was in the page, they have
-- you know, maybe 300 k of JavaScript.

00:30:24.250 --> 00:30:25.970
I'm just making these numbers up.

00:30:25.970 --> 00:30:27.590
I don't know how much JavaScript Gmail has.

00:30:27.590 --> 00:30:28.720
It's probably more than that.

00:30:28.720 --> 00:30:35.590
But they have a lot of JavaScript in here
and they just wrap it in -- in comment delimiters.

00:30:35.590 --> 00:30:40.940
So what happens is this will get downloaded
to the browser, it will be cached, it's already

00:30:40.940 --> 00:30:42.350
resident.

00:30:42.350 --> 00:30:44.690
But it's not parsed and executed.

00:30:44.690 --> 00:30:50.340
So -- so let's say this is compose a new message
JavaScript.

00:30:50.340 --> 00:30:58.000
It pops up in div, it formats everything,
it does error detection and things like that.

00:30:58.000 --> 00:31:03.120
So we don't really need this JavaScript to
block the UI thread for parse and execution

00:31:03.120 --> 00:31:07.030
until the user actually clicks on the compose
button, which they may never do during this

00:31:07.030 --> 00:31:08.030
session.

00:31:08.030 --> 00:31:11.480
So what we do is we download the code because
we want it on the device.

00:31:11.480 --> 00:31:17.240
When they click compose, especially on a phone,
we don't want to wait to download 300 k of

00:31:17.240 --> 00:31:19.820
JavaScript, we don't want to make the user
wait.

00:31:19.820 --> 00:31:23.290
So what we do is we download it, you can even
download it in the background.

00:31:23.290 --> 00:31:26.100
It's not going to block the UI thread when
it arrives.

00:31:26.100 --> 00:31:30.660
Now the user clicks compose, you have all
of the JavaScript on the client and now you

00:31:30.660 --> 00:31:36.690
just find the DOM element for the script tag,
remove the comment delimiters and eval the

00:31:36.690 --> 00:31:37.690
code.

00:31:37.690 --> 00:31:40.110
A lot of people say eval is evil.

00:31:40.110 --> 00:31:44.549
Doug Crawford is here today, I saw him downstairs,
he'll tell you that.

00:31:44.549 --> 00:31:46.920
Certainly eval is evil from a security perspective.

00:31:46.920 --> 00:31:51.560
If you are eval'ing code that you didn't generate,
that can produce really bad things.

00:31:51.560 --> 00:31:54.860
You wouldn't want to do this with third party
widgets and ads, et cetera.

00:31:54.860 --> 00:31:58.450
So this is code that you control, that you
generated.

00:31:58.450 --> 00:32:04.880
So from a security perspective, it's okay
and the actual performance of eval is less

00:32:04.880 --> 00:32:07.840
than 10% worse than just a script block.

00:32:07.840 --> 00:32:12.260
So from a performance perspective, it's actually
down like around one or two percent.

00:32:12.260 --> 00:32:14.380
From a performance perspective, it's fine.

00:32:14.380 --> 00:32:17.680
So you control the code, performance-wise
it's good.

00:32:17.680 --> 00:32:21.100
So this is a -- this is a really nice hack.

00:32:21.100 --> 00:32:25.700
And it's perfect for pre-fetching JavaScript
that you might need but you are not sure.

00:32:25.700 --> 00:32:27.340
It's possible that you will never need it.

00:32:27.340 --> 00:32:31.440
So don't block the UI thread, especially for
large amounts of JavaScript.

00:32:31.440 --> 00:32:40.860
You know, this -- might require a fair amount
of rewriting on your Web site.

00:32:40.860 --> 00:32:46.090
So I wrote something called ControlJS, that's
open source, you can get it off my Web site.

00:32:46.090 --> 00:32:49.880
Several big companies -- I was just at this
conference, and I found that -- including

00:32:49.880 --> 00:32:54.930
Wal-Mart, I found several big companies that
were using this that I was really surprised

00:32:54.930 --> 00:32:56.330
at because I don't do a lot of testing.

00:32:56.330 --> 00:33:01.010
[ Laughter ]
&gt;&gt;Steve Souders: I trust that they've done

00:33:01.010 --> 00:33:03.270
that.

00:33:03.270 --> 00:33:06.150
And actually, who else -- Washington Post
is using it.

00:33:06.150 --> 00:33:11.760
And I asked them to contribute back the robustness
changes they had to add.

00:33:11.760 --> 00:33:16.179
And so the thing that I like about this technique
is that it's all done in markup.

00:33:16.179 --> 00:33:21.560
So we can just change -- instead of script
source, having type text script, we would

00:33:21.560 --> 00:33:27.780
say text CJS, and instead of a source we have
a data control.js source, so this means that

00:33:27.780 --> 00:33:33.020
the browser will basically just ignore this
and you can also do it with inline scripts

00:33:33.020 --> 00:33:36.180
just by changing the type.

00:33:36.180 --> 00:33:39.230
Then you load control.js.

00:33:39.230 --> 00:33:43.320
What it does is it crawls the DOM, and it
finds these script nodes and it does the right

00:33:43.320 --> 00:33:44.320
thing.

00:33:44.320 --> 00:33:47.660
It downloads it asynchronously, it does it
in the background.

00:33:47.660 --> 00:33:52.440
Again, you would only do this with scripts
that aren't critical for generating the initial

00:33:52.440 --> 00:33:56.950
user experience and scripts that do not have
any document.write.

00:33:56.950 --> 00:33:59.660
But I think it's a little easier to get on
top of.

00:33:59.660 --> 00:34:05.890
You can even add this execute false, which
says downloaded but don't parse and execute

00:34:05.890 --> 00:34:06.890
it.

00:34:06.890 --> 00:34:11.270
And then later when the user, for example,
clicks on the compose button, you can say

00:34:11.270 --> 00:34:15.960
control.js execute script.

00:34:15.960 --> 00:34:18.879
So that's kind of a nice alternative.

00:34:18.879 --> 00:34:24.079
The other thing I like about it, how many
people here have played with -- with JavaScript

00:34:24.079 --> 00:34:28.029
loader, script loaders, lab js or YUI lowered.

00:34:28.029 --> 00:34:32.619
Some people -- the thing that I find ironic
about all of the other alternatives out there

00:34:32.619 --> 00:34:36.990
is their goal is to help you load JavaScript
asynchronously.

00:34:36.990 --> 00:34:41.929
They do that with a helper script, but you
have to load their helper script synchronously.

00:34:41.929 --> 00:34:44.589
[ Laughter ]
&gt;&gt;Steve Souders: Anyone else think that's

00:34:44.589 --> 00:34:45.589
weird?

00:34:45.589 --> 00:34:49.649
Like, you know, synchronous loaded scripts
are bad.

00:34:49.649 --> 00:34:53.589
So you load our scripts synchronously and
we will help you avoid that problem.

00:34:53.589 --> 00:34:57.210
[ Laughter ]
&gt;&gt;Steve Souders: Like -- so from the beginning,

00:34:57.210 --> 00:35:01.299
one of the requirements of ControlJS was that
you could load it asynchronously.

00:35:01.299 --> 00:35:06.390
So you would use the Google Analytics, async
loading pattern and load the script anywhere

00:35:06.390 --> 00:35:09.760
you want in a page and everything will still
work.

00:35:09.760 --> 00:35:13.550
So JavaScript is a really, really big problem.

00:35:13.550 --> 00:35:18.690
I'm -- make sure that you look at how it's
impacting your Web site and if possible adopt

00:35:18.690 --> 00:35:20.910
some of these asynchronous loading techniques.

00:35:20.910 --> 00:35:21.910
Okay.

00:35:21.910 --> 00:35:27.480
Shifting gears, I wanted to talk about app
cache, which is good for offline apps and

00:35:27.480 --> 00:35:30.859
also for longer caching.

00:35:30.859 --> 00:35:33.329
So again, the importance of the background
photo.

00:35:33.329 --> 00:35:36.440
You are in the desert.

00:35:36.440 --> 00:35:40.229
You typically don't have a good connection.

00:35:40.229 --> 00:35:42.299
So having the offline apps is really important.

00:35:42.299 --> 00:35:48.440
[ Laughter ]
&gt;&gt;Steve Souders: There we go, the groan.

00:35:48.440 --> 00:35:51.569
So building offline apps is really cool.

00:35:51.569 --> 00:35:55.569
I think Google docs just announced that this
week or last week.

00:35:55.569 --> 00:36:02.789
It really helps with the user experience when
you have a bad connection, you are flying,

00:36:02.789 --> 00:36:03.789
whatever.

00:36:03.789 --> 00:36:07.700
But also people are using it from a performance
perspective for better caching.

00:36:07.700 --> 00:36:14.260
So this is a study that I did five or six
years ago with (saying name) when we were

00:36:14.260 --> 00:36:18.660
at Yahoo, it's been a long time, but I've
talked to people at other big Web companies

00:36:18.660 --> 00:36:23.220
who have run the same experiment and they
basically get the same results.

00:36:23.220 --> 00:36:25.519
So I encourage you to run it on your Web site.

00:36:25.519 --> 00:36:31.880
Basically we put a hidden pixel in every page,
we tracked how often people made a request

00:36:31.880 --> 00:36:36.160
with or without an if-modified-since header.

00:36:36.160 --> 00:36:40.349
If they send the if-modified-since request,
it means they have it in the cache.

00:36:40.349 --> 00:36:42.849
If they don't, it means they don't have it
in the cache.

00:36:42.849 --> 00:36:48.260
So we can track how many people coming in,
how many page views are done with a full cache,

00:36:48.260 --> 00:36:49.550
a prime cache.

00:36:49.550 --> 00:36:54.099
Our resources are in their cache or with an
empty cache, our resources are not in their

00:36:54.099 --> 00:36:55.099
cache.

00:36:55.099 --> 00:37:00.700
I talk about in my best practices setting
a far futures expires header.

00:37:00.700 --> 00:37:04.940
Turns out even if you do that, browsers aren't
going to keep things around for that long

00:37:04.940 --> 00:37:10.339
or for whatever reason, users are going to
come in and they're not going to have everything

00:37:10.339 --> 00:37:12.279
in cache that you might expect.

00:37:12.279 --> 00:37:18.519
So what we see here is that for page views,
if you look at it from the page views perspective,

00:37:18.519 --> 00:37:25.880
about 20% of page views on any given day are
done with a -- with an empty cache.

00:37:25.880 --> 00:37:26.880
Right?

00:37:26.880 --> 00:37:28.880
My resources are not in the cache.

00:37:28.880 --> 00:37:33.680
You can see on the first day, when we put
this pixel on the page, 100% of the pages

00:37:33.680 --> 00:37:37.910
had an empty cache because this image had
never been loaded before.

00:37:37.910 --> 00:37:42.029
After about two weeks, we hit a steady state
and we can see it's about 20%.

00:37:42.029 --> 00:37:46.779
We ran this on various properties at Yahoo
that had different user metrics.

00:37:46.779 --> 00:37:48.470
This was always about the same.

00:37:48.470 --> 00:37:53.020
This number fluctuated a little bit more,
but it was always between 40 and 60%.

00:37:53.020 --> 00:37:58.420
About half of your users come in at least
once a day with an empty cache.

00:37:58.420 --> 00:38:00.400
So why are these numbers different?

00:38:00.400 --> 00:38:04.119
Typically, users are doing multiple page views
in a session.

00:38:04.119 --> 00:38:08.220
So even if they have an empty cache, they
will come in and have an empty cache page

00:38:08.220 --> 00:38:11.479
view, which will show up here and show up
here.

00:38:11.479 --> 00:38:15.400
But then they might do three or four more
page views, which are going to be a prime

00:38:15.400 --> 00:38:20.150
cache, because when they did their empty cache
page load stuff got put into the cache.

00:38:20.150 --> 00:38:21.849
So that's why these numbers are different.

00:38:21.849 --> 00:38:26.160
But it still means people anchor on negative
experience.

00:38:26.160 --> 00:38:30.779
So if half of your users were coming in every
day with an empty cache, and you are not taking

00:38:30.779 --> 00:38:36.339
that into consideration, you are like, well,
yeah, it's not 300 k image or script but it

00:38:36.339 --> 00:38:40.150
will be in the cache, for about half of your
users, it's not going to be in the cache.

00:38:40.150 --> 00:38:45.720
So you can run this experiment yourself and
you will get the same results.

00:38:45.720 --> 00:38:51.319
So the cache, even if you are doing far future
expires, the cache might not be doing what

00:38:51.319 --> 00:38:53.039
you think.

00:38:53.039 --> 00:38:58.640
And -- and here's a great study from Guy Poe
over at Blaze, now Akamai, where he shows

00:38:58.640 --> 00:39:01.950
that mobile caches are very small.

00:39:01.950 --> 00:39:05.829
This is another reason why things you think
should be in the cache won't be.

00:39:05.829 --> 00:39:11.810
This was a study I did where I found that
-- I like building Web apps and putting them

00:39:11.810 --> 00:39:16.979
on the home screen and turned out in iOS if
you do that the cache isn't used optimally.

00:39:16.979 --> 00:39:23.019
So you can use app cache for caching.

00:39:23.019 --> 00:39:28.269
So the way they use app cache at this manifest
attribute, you give it a file name, which

00:39:28.269 --> 00:39:30.729
is your app cache.

00:39:30.729 --> 00:39:35.890
Manifest is a good name I think we all intuitively
recognize what we are going to see here.

00:39:35.890 --> 00:39:38.039
Here's your manifest file.

00:39:38.039 --> 00:39:40.450
It has to start with this cache manifest header.

00:39:40.450 --> 00:39:44.230
We will talk about the revision number in
a second, but you'll want to add that.

00:39:44.230 --> 00:39:48.670
It's got these various sections, a cache section
says these are the things that I want you

00:39:48.670 --> 00:39:51.029
to put into app cache.

00:39:51.029 --> 00:39:55.479
The network session says these are the things
that you should never put into app cache.

00:39:55.479 --> 00:40:01.480
The fallback section says if the user is online,
then use this URL.

00:40:01.480 --> 00:40:04.890
But if they are offline, read this one from
app cache.

00:40:04.890 --> 00:40:09.589
So the browser, when the user is online, will
download this one, but will also download

00:40:09.589 --> 00:40:11.950
this one and save it into app cache.

00:40:11.950 --> 00:40:17.200
At least right now, you have to make sure
to give this a very specific content type.

00:40:17.200 --> 00:40:19.270
Text/cache-manifest.

00:40:19.270 --> 00:40:20.510
So it looks pretty good.

00:40:20.510 --> 00:40:25.219
It turns out actually it's really, really,
really hard and complicated to work with.

00:40:25.219 --> 00:40:27.930
So here are some of the gotchas that you will
probably run into.

00:40:27.930 --> 00:40:30.190
I know I did.

00:40:30.190 --> 00:40:36.549
I didn't realize -- like, I never listed my
HTML document itself, .php, .HTML in the manifest

00:40:36.549 --> 00:40:39.999
file, so I just assumed it wouldn't be put
into app cache.

00:40:39.999 --> 00:40:45.640
But if your HTML document uses the manifest
attribute, then it's going to be saved to

00:40:45.640 --> 00:40:46.740
app cache.

00:40:46.740 --> 00:40:51.569
This was really confusing for me because I
had a log-in box on the front page.

00:40:51.569 --> 00:40:56.979
And if the user came in and their app cache
was empty and they weren't logged in, the

00:40:56.979 --> 00:41:00.790
logged-out version of the page would be saved;
every time they came back, that's what they

00:41:00.790 --> 00:41:03.140
would see even after logging in.

00:41:03.140 --> 00:41:04.660
So that's a little confusing.

00:41:04.660 --> 00:41:08.579
If anything in the manifest list 404s, nothing
is saved.

00:41:08.579 --> 00:41:12.280
You get about five meg, which is pretty good.

00:41:12.280 --> 00:41:17.960
Yeah, so this is interesting, suppose you
change one of the resources listed in the

00:41:17.960 --> 00:41:24.259
manifest file, like an image, you would think
that the next time the user opens the app,

00:41:24.259 --> 00:41:25.440
they would see that new image.

00:41:25.440 --> 00:41:26.499
They don't.

00:41:26.499 --> 00:41:31.470
You actually have to change something in the
manifest file to make it different, and that's

00:41:31.470 --> 00:41:34.489
why the revision number was in there on the
previous slide.

00:41:34.489 --> 00:41:41.700
That's what I do is I have that automatically
updated whenever I update through source code,

00:41:41.700 --> 00:41:45.979
through my source code control system, it
will automatically update that revision number,

00:41:45.979 --> 00:41:52.920
so the manifest is always touched whenever
I update a resource, and this was really confusing

00:41:52.920 --> 00:41:55.140
to me.

00:41:55.140 --> 00:42:01.670
Even if you do, you know, rev the manifest
file, the user still won't see the change

00:42:01.670 --> 00:42:04.160
until the second time they open the app.

00:42:04.160 --> 00:42:08.440
So I think this is really interesting, and
it's a real gotcha', so I wanted to walk through

00:42:08.440 --> 00:42:15.509
it in more detail, so let's suppose you go
home today and you build mobile Web app that

00:42:15.509 --> 00:42:20.529
uses app cache, or a desktop app that uses
app cache, and it's got this awesome green

00:42:20.529 --> 00:42:28.289
logo that the designer gave you, and you list
that into your app cache manifest file, so

00:42:28.289 --> 00:42:36.460
you push that tonight, tomorrow, the first
user ever downloads your app, and the app

00:42:36.460 --> 00:42:37.819
cache is obviously empty.

00:42:37.819 --> 00:42:43.559
They've never seen this before, and so the
browser fetches the manifest file and in there

00:42:43.559 --> 00:42:49.039
the logo is listed so the browser downloads
that, puts it into app cache, and renders

00:42:49.039 --> 00:42:53.130
the app to the user so the user sees the awesome
green logo.

00:42:53.130 --> 00:42:58.420
So now suppose tomorrow night you go, you
know, I really think an orange logo would

00:42:58.420 --> 00:43:04.729
be better, so you push to your server this
new orange logo, and you remember to change

00:43:04.729 --> 00:43:06.950
the version number in the manifest file.

00:43:06.950 --> 00:43:13.299
So the logo is new, the manifest file is new.

00:43:13.299 --> 00:43:22.140
And on -- today's Friday, so you do that Saturday
night, so on Sunday, the user -- same user

00:43:22.140 --> 00:43:28.849
loads the app again, and the browser says,
okay, well, this app has a manifest file associated

00:43:28.849 --> 00:43:29.849
with it.

00:43:29.849 --> 00:43:31.720
Do I have any of those resources in my app
cache?

00:43:31.720 --> 00:43:32.720
Oh, I do.

00:43:32.720 --> 00:43:37.479
I need logo.jif, or i have logo.jif in my
app cache; it's this pretty green logo.

00:43:37.479 --> 00:43:42.079
Even though I've already pushed an orange
logo to my server, the browser is ignoring

00:43:42.079 --> 00:43:43.079
that.

00:43:43.079 --> 00:43:44.079
That's why it can work offline.

00:43:44.079 --> 00:43:50.630
It can say I have this stuff in app cache,
let me load as much as I can without using

00:43:50.630 --> 00:43:51.710
the network.

00:43:51.710 --> 00:43:56.830
And so it displays that app cache logo to
the user.

00:43:56.830 --> 00:44:02.180
But now what it does is it's -- once it's
rendered the app with the old out-of-date

00:44:02.180 --> 00:44:08.049
logo, it fetches the manifest file, it detects
that it's changed and so then it checks all

00:44:08.049 --> 00:44:13.359
other resources in the manifest file and it
gets the new version of the logo which is

00:44:13.359 --> 00:44:20.599
orange, it saves that to app cache, so if
the user reloads the app, a second time, it

00:44:20.599 --> 00:44:25.079
will -- the browser will look in app cache
and now it has the orange logo, so it renders

00:44:25.079 --> 00:44:29.829
the orange logo to the user, it fetches the
manifest file which hasn't changed and so

00:44:29.829 --> 00:44:30.829
it's done.

00:44:30.829 --> 00:44:35.650
So it's really taken these two loads -- after
I update a resource it takes two loads for

00:44:35.650 --> 00:44:36.980
the user to see the changes.

00:44:36.980 --> 00:44:42.680
Now, there is a work around to this, it's
not that hard, but not that easy.

00:44:42.680 --> 00:44:44.390
There's this update ready part.

00:44:44.390 --> 00:44:46.140
The implementation is pretty easy.

00:44:46.140 --> 00:44:47.410
I can track this.

00:44:47.410 --> 00:44:50.420
But it's what do I want to do with the user
experience?

00:44:50.420 --> 00:44:55.599
So in the background, the browser detected
that there was a new logo, and it fires this

00:44:55.599 --> 00:45:01.079
update ready, but are you going to tell the
user to like reload the app to see the changes?

00:45:01.079 --> 00:45:03.359
I don't know, you have to decide for yourself.

00:45:03.359 --> 00:45:05.440
Maybe if it's just images it's not that important.

00:45:05.440 --> 00:45:10.359
If it's like an important JavaScript security
privacy fix, then, yeah, maybe you want to

00:45:10.359 --> 00:45:14.029
tell them to reload it, or you want to reload
it without even telling them, just reload

00:45:14.029 --> 00:45:16.890
the app.

00:45:16.890 --> 00:45:21.859
Another way to do improved caching because
we know the browser cache doesn't work super

00:45:21.859 --> 00:45:24.880
awesome is local storage.

00:45:24.880 --> 00:45:26.829
Really simple API.

00:45:26.829 --> 00:45:28.789
Local storage is persistent across sessions.

00:45:28.789 --> 00:45:31.530
If you only care about sessions, you can use
session storage.

00:45:31.530 --> 00:45:33.989
It's about five meg.

00:45:33.989 --> 00:45:40.910
One warning, browser developers really are
worried about this getting too much use because

00:45:40.910 --> 00:45:43.609
it does a synchronous read.

00:45:43.609 --> 00:45:47.240
Some browsers will actually read everything
out of local storage, the first time you go

00:45:47.240 --> 00:45:52.190
to that page during the session, and if you
have a lot of stuff in local storage, again,

00:45:52.190 --> 00:45:56.319
it's single-threaded so that can slow down
the user experience.

00:45:56.319 --> 00:46:02.750
So I built this bookmark that lets you look
into what is stored in local storage, and

00:46:02.750 --> 00:46:07.430
I discovered a couple of interesting things
that Bing and Google search were doing, which

00:46:07.430 --> 00:46:11.099
I hadn't thought of, and it's very cool to
help with caching.

00:46:11.099 --> 00:46:15.579
So I think this is the Google search -- Google
mobile search implementation.

00:46:15.579 --> 00:46:23.309
The first time you do a search, the HTML document
will return all of these inline script and

00:46:23.309 --> 00:46:30.469
style blocks, a lot of JavaScript and CSS,
and when it's done, it iterates over those

00:46:30.469 --> 00:46:37.150
script tags and style tags that have IDs,
and it takes the content of the block, and

00:46:37.150 --> 00:46:41.160
writes it into local storage based on the
ID of that element.

00:46:41.160 --> 00:46:47.229
So now, after I've done this first search
ever on my phone, I have blocks of JavaScript

00:46:47.229 --> 00:46:52.779
and CSS in my local storage, so now let's
say I do another -- oh, and the other thing

00:46:52.779 --> 00:46:59.730
it does is it sets a cookie that says which
blocks of JavaScript and CSS have been written

00:46:59.730 --> 00:47:02.029
into this user's local storage.

00:47:02.029 --> 00:47:07.450
So now if I do another search, this cookie
goes up to the server, and the server says,

00:47:07.450 --> 00:47:11.089
oh, well, you're doing a search, I have to
give you this block and that block and this

00:47:11.089 --> 00:47:13.000
JavaScript and this CSS.

00:47:13.000 --> 00:47:14.940
Let me see what you already have in local
storage.

00:47:14.940 --> 00:47:19.469
It looks at the cookie and says, oh, you already
have this block, I don't have to send you

00:47:19.469 --> 00:47:25.289
that, I don't have to send you this CSS, and
for -- in the case of mobile search, it drops

00:47:25.289 --> 00:47:32.309
the download size from about 110K to just
10K, because all that stuff is now in local

00:47:32.309 --> 00:47:33.309
storage.

00:47:33.309 --> 00:47:38.279
And then when the lightweight page arrives,
there's some JavaScript that will pull all

00:47:38.279 --> 00:47:42.630
of these things out of local storage and write
them into the page.

00:47:42.630 --> 00:47:47.640
So this is a really cool way to get more persistent
cache.

00:47:47.640 --> 00:47:53.569
Local storage is unaffected by other Web sites
whereas the shared browser cache, if the user

00:47:53.569 --> 00:47:58.479
visits a bunch of other Web sites that have
large resources, your content might get pushed

00:47:58.479 --> 00:47:59.479
out.

00:47:59.479 --> 00:48:04.510
So I did a quick survey using this is what
this -- I'm a good JavaScript hacker.

00:48:04.510 --> 00:48:06.440
I'm not a good UI designer.

00:48:06.440 --> 00:48:10.979
This is my awesome storage or bookmark list,
and you can see it lets you look at what's

00:48:10.979 --> 00:48:16.479
in the local storage and session storage,
tells you how big it is, how many items it

00:48:16.479 --> 00:48:17.479
is.

00:48:17.479 --> 00:48:24.150
So let's just do a quick run through the Alexa
Top 10 and see how local storage is being

00:48:24.150 --> 00:48:25.150
used.

00:48:25.150 --> 00:48:31.900
So here we have -- Google search is using
it on both mobile and desktop, so that's one.

00:48:31.900 --> 00:48:35.400
Bing is using it on mobile.

00:48:35.400 --> 00:48:37.809
Facebook is using it on mobile.

00:48:37.809 --> 00:48:41.469
Yahoo is maybe using it a little bit, but
not really.

00:48:41.469 --> 00:48:44.039
We're not going to count that.

00:48:44.039 --> 00:48:45.460
YouTube, yeah, we'll count that.

00:48:45.460 --> 00:48:48.959
Quite a bit of content on mobile.

00:48:48.959 --> 00:48:50.440
Amazon, no.

00:48:50.440 --> 00:48:51.440
Twitter?

00:48:51.440 --> 00:48:54.890
Yeah, okay, we'll count that.

00:48:54.890 --> 00:48:55.890
Five.

00:48:55.890 --> 00:48:59.339
LinkedIn, no, I would say.

00:48:59.339 --> 00:49:00.819
eBay, no.

00:49:00.819 --> 00:49:02.309
MSN, no.

00:49:02.309 --> 00:49:08.369
So about five or six of the Alexa Top 10 are
using local storage, so that's an indicator

00:49:08.369 --> 00:49:10.809
that, you know, it's worth investigating.

00:49:10.809 --> 00:49:14.319
Why is it more -- maybe used more prevalently
on mobile?

00:49:14.319 --> 00:49:18.650
You know, the experience of not having something
in the cache in mobile is worse, because the

00:49:18.650 --> 00:49:24.759
network connection speed is so slow, also
the cache is smaller on mobile, so caching

00:49:24.759 --> 00:49:29.200
isn't awesome on desktop, but is much better
on mobile, so I think that's why these top

00:49:29.200 --> 00:49:35.589
properties started using local storage on
mobile, but I would expect to see this proliferate

00:49:35.589 --> 00:49:38.519
on desktop apps as well.

00:49:38.519 --> 00:49:39.549
So I want to talk about font-face.

00:49:39.549 --> 00:49:44.789
Again, pay attention to the photos, not to
what I say.

00:49:44.789 --> 00:49:53.190
So, you know, fonts, using custom fonts can
create a more compelling, beautiful experience,

00:49:53.190 --> 00:49:57.359
but people haven't really paid attention to
what it does, similar to how scripts and style

00:49:57.359 --> 00:50:05.160
sheets can block a page, what custom font
files do, and so I created this table that

00:50:05.160 --> 00:50:11.140
here's the blog post, that shows how scripts
and style sheets and fonts can affect, and,

00:50:11.140 --> 00:50:19.569
you know, "blank below in red" means that
everything using this font or below it are

00:50:19.569 --> 00:50:21.599
going to be affected.

00:50:21.599 --> 00:50:26.190
Flash -- oh, delayed means -- blank is really
bad.

00:50:26.190 --> 00:50:28.609
It means like everything in the page is blank.

00:50:28.609 --> 00:50:33.180
Delayed means just the element that's using
the font file is affected.

00:50:33.180 --> 00:50:39.519
Flash means once the things -- things will
render, but once the resource arrives it has

00:50:39.519 --> 00:50:44.150
to be redrawn, and so it's kind of a jerky
user experience, things have to be rerenderred

00:50:44.150 --> 00:50:45.940
and repainted.

00:50:45.940 --> 00:50:47.630
So you can see the impact.

00:50:47.630 --> 00:50:50.759
Even the green "good" is not really a good
experience.

00:50:50.759 --> 00:50:55.339
And so you want to use fonts kind of carefully.

00:50:55.339 --> 00:51:00.290
And it's kind of ironic, it's kind of how
these async script loader libraries make you

00:51:00.290 --> 00:51:02.539
load their scripts synchronously.

00:51:02.539 --> 00:51:05.950
When I talk to designers about why they're
using custom fonts, even though we know it

00:51:05.950 --> 00:51:11.319
has this impact on the user experience, they
say, well, these are the most important design

00:51:11.319 --> 00:51:12.499
elements in the page.

00:51:12.499 --> 00:51:17.900
I'm like, "so you want the most important
parts of the page to take the longest to render?"

00:51:17.900 --> 00:51:20.190
Like, that doesn't make sense to me.

00:51:20.190 --> 00:51:27.400
So despite my warnings, custom fonts have
taken off, like they've more than doubled

00:51:27.400 --> 00:51:31.420
in the last year, this is a chart from the
HTP archive.

00:51:31.420 --> 00:51:33.450
So they're taking off.

00:51:33.450 --> 00:51:41.030
The good thing is the folks at Typekit and
the Google fonts library have done a lot of

00:51:41.030 --> 00:51:46.730
good work to mitigate the impact that custom
fonts files have, but we can still go farther.

00:51:46.730 --> 00:51:52.569
In fact, I think Google fonts library just
announced custom fonts a few months ago.

00:51:52.569 --> 00:51:56.480
If you don't need -- like if you're only using
digits or other certain characters, like it's

00:51:56.480 --> 00:52:02.299
just a word that you want to render in that
font, you can actually create a smaller font.

00:52:02.299 --> 00:52:06.859
The font files are typically like over 100K,
so you can create one that is just the characters

00:52:06.859 --> 00:52:12.510
that you need.

00:52:12.510 --> 00:52:18.709
The flash of unstyled text means you draw
text and then you have to redraw it, and so

00:52:18.709 --> 00:52:25.809
what I would propose is that browsers have
like an impatient fallback, like if -- I don't

00:52:25.809 --> 00:52:31.099
want to have this flash of my text, so I'm
going to wait 250 milliseconds for the font

00:52:31.099 --> 00:52:32.099
file.

00:52:32.099 --> 00:52:35.749
If it hasn't come back and we're drawing in
a default font, and even if the font files

00:52:35.749 --> 00:52:37.890
comes back later, I'm not going to redraw
it.

00:52:37.890 --> 00:52:41.630
I'll cache that font for the next time the
user goes to the page, but I'm not going to

00:52:41.630 --> 00:52:47.739
do that, and again, I think this is a behavior
that the Google font library and Typekit loaders

00:52:47.739 --> 00:52:52.279
do automatically for you.

00:52:52.279 --> 00:52:54.969
Yeah.

00:52:54.969 --> 00:52:59.059
And also, okay, I'm running short on time,
so I'm going to go a little faster.

00:52:59.059 --> 00:53:01.719
Font should be given a higher priority in
caching.

00:53:01.719 --> 00:53:09.049
Browsers are still just starting to pay attention
to that, and even if a font is expired, I

00:53:09.049 --> 00:53:14.400
might want to render with it, and do a "if
modified since request", and then if I get

00:53:14.400 --> 00:53:15.869
back, "oh, not modified?"

00:53:15.869 --> 00:53:18.130
It's okay, I've already rendered with a font.

00:53:18.130 --> 00:53:19.520
All I have to do is validate it.

00:53:19.520 --> 00:53:25.229
Oh, good, I'm getting close to the end, so
there's a lot more stuff I didn't talk about.

00:53:25.229 --> 00:53:30.130
We -- you know, all of us spent a lot of time
building rounded corners that downloaded a

00:53:30.130 --> 00:53:35.450
bunch of images, so now you can do a lot of
things that used to require HTP traffic, you

00:53:35.450 --> 00:53:39.450
can do with CSS 3, so that's cool.

00:53:39.450 --> 00:53:44.480
You have to be a little careful, these incur,
you know, might incur a lot of CPU overhead

00:53:44.480 --> 00:53:47.660
or repaints.

00:53:47.660 --> 00:53:51.089
You can use SVG and canvas instead of downloading
images.

00:53:51.089 --> 00:53:53.920
Video tag could make starting up videos faster.

00:53:53.920 --> 00:53:57.339
Web sockets, if you have a very chatty sort
of app can be used.

00:53:57.339 --> 00:54:01.549
Web workers, if you have like a lot of computation
that you want to get out of the UI thread,

00:54:01.549 --> 00:54:07.390
you can use Web workers, oh, for some things
that we used to have to write a lot of JavaScript

00:54:07.390 --> 00:54:11.880
or HTML for, you can do with these new built-in
controls.

00:54:11.880 --> 00:54:18.789
Again, the photo, more, infinite number of
digits.

00:54:18.789 --> 00:54:21.219
History API, we used to have to implement
this in JavaScript.

00:54:21.219 --> 00:54:23.680
Now we don't have to download all that JavaScript.

00:54:23.680 --> 00:54:28.769
Ping is a way to avoid a redirect if you want
to track something.

00:54:28.769 --> 00:54:31.009
Don't use set time-out for animation.

00:54:31.009 --> 00:54:32.609
Use request animation frame.

00:54:32.609 --> 00:54:34.569
It will be faster.

00:54:34.569 --> 00:54:39.880
You can use the native JSON parser, and here
are some good resources to get more information

00:54:39.880 --> 00:54:42.470
about this other HTML5 stuff.

00:54:42.470 --> 00:54:44.249
So what are the takeaways?

00:54:44.249 --> 00:54:45.599
Speed matters.

00:54:45.599 --> 00:54:46.890
Hopefully we all agree about that.

00:54:46.890 --> 00:54:48.109
I saw you raise your hand before.

00:54:48.109 --> 00:54:50.430
So I'm going to hold you to that.

00:54:50.430 --> 00:54:54.949
Pay attention to what's coming out of the
Web performance working group out of the W3C.

00:54:54.949 --> 00:54:59.259
You can use window.performance to track the
timing on your pages, and even if you haven't

00:54:59.259 --> 00:55:03.119
done that yet, if you're using Google Analytics,
you can go and see the data there.

00:55:03.119 --> 00:55:06.339
It's already been gathered for the last few
months.

00:55:06.339 --> 00:55:09.779
JavaScript blocking the UI thread is really
critical.

00:55:09.779 --> 00:55:14.459
Try to get a lot of that stuff deferred or
async, and caching is really important.

00:55:14.459 --> 00:55:18.910
I think it's one of the most important things
for a fast user experience.

00:55:18.910 --> 00:55:20.339
Browsers are improving their cache.

00:55:20.339 --> 00:55:24.180
Mobile browsers have a lot of room to catch
up on, so you can try some of these other

00:55:24.180 --> 00:55:25.300
techniques.

00:55:25.300 --> 00:55:28.109
And be careful about using font-face.

00:55:28.109 --> 00:55:32.349
So before I close out, I want to mention,
if you like this kind of performance stuff,

00:55:32.349 --> 00:55:36.980
I'm sorry, but you should have been at Velocity
this week.

00:55:36.980 --> 00:55:39.219
We just finished that Wednesday.

00:55:39.219 --> 00:55:43.459
But if you missed that, you could go to Web
PERF days, the first ever, but -- well, actually,

00:55:43.459 --> 00:55:44.459
that was yesterday.

00:55:44.459 --> 00:55:46.269
Okay, so you missed that one.

00:55:46.269 --> 00:55:48.969
[ Laughter ]
&gt;&gt;Steve Souders: Oh, okay, we've got Velocity

00:55:48.969 --> 00:55:53.440
Europe coming up in October, so you might
have to go a little farther, but -- and we'll

00:55:53.440 --> 00:55:55.550
be back next year in June for Velocity.

00:55:55.550 --> 00:56:02.390
I also wanted to just mention this -- oh,
I added this like five minutes before I came

00:56:02.390 --> 00:56:03.390
on stage.

00:56:03.390 --> 00:56:08.420
How can I do this, like -- I don't know, I
have to go through them all.

00:56:08.420 --> 00:56:15.380
So (indiscernible) runs this performance calendar
every year, and O'Reilly took the most recent

00:56:15.380 --> 00:56:20.199
performance calendar and put it into a book,
so this just came out this week, and you can

00:56:20.199 --> 00:56:25.920
get most of this content on the blog for the
performance calendar, but the -- they were

00:56:25.920 --> 00:56:29.579
updated, and if you like books, you can get
it in book form here.

00:56:29.579 --> 00:56:31.140
So that's it.

00:56:31.140 --> 00:56:36.410
Thank you very much.

00:56:36.410 --> 00:56:41.539
[ Applause ]
&gt;&gt;Steve Souders: So I've got about four minutes,

00:56:41.539 --> 00:56:47.269
I would be happy to answer any questions and
I think they want you to use the mic.

00:56:47.269 --> 00:56:50.949
Everyone is heading out.

00:56:50.949 --> 00:56:54.279
&gt;&gt;&gt; Would you care to expand upon font awesome?

00:56:54.279 --> 00:56:59.859
And also to resolve some of the issues of
pop-in, I found setting a fixed type for whatever

00:56:59.859 --> 00:57:01.900
text I decide is very nice.

00:57:01.900 --> 00:57:04.109
&gt;&gt;Steve Souders: What's the first one?

00:57:04.109 --> 00:57:05.259
Expound on...

00:57:05.259 --> 00:57:08.289
&gt;&gt;&gt; Font awesome, using fonts instead of sprites?

00:57:08.289 --> 00:57:18.719
&gt;&gt;Steve Souders: Oh, yeah, so you can create
a custom font, you know, file, that has little

00:57:18.719 --> 00:57:23.700
pictures, you know, kind of like wings -- what
is it on windows?

00:57:23.700 --> 00:57:28.479
The wings font, wingdings, yeah, so you can
do that with a font, so if you have like really

00:57:28.479 --> 00:57:34.239
small images that you're using now and you're
downloading them as HTP requests instead of

00:57:34.239 --> 00:57:36.239
images, instead you can download a font fall.

00:57:36.239 --> 00:57:37.430
It doesn't have to be huge.

00:57:37.430 --> 00:57:45.029
Maybe you have 10 of those or 20 of those,
and you can download those and use those to

00:57:45.029 --> 00:57:49.499
draw those little images, those little sprites
in the page for like maybe little buttons

00:57:49.499 --> 00:57:52.940
or things like that, and so, you know, I think
that's a great idea.

00:57:52.940 --> 00:57:54.040
You could also use sprites.

00:57:54.040 --> 00:57:56.210
Sprites are maybe a little harder to do.

00:57:56.210 --> 00:58:00.519
You have to create the image and know all
the CSS, but the one thing I would say, if

00:58:00.519 --> 00:58:04.980
you're using any kind of font file, is try
to figure out a way to do it that doesn't

00:58:04.980 --> 00:58:08.200
block the page, like especially in IE.

00:58:08.200 --> 00:58:13.309
Custom font files block rendering of everything
in the page, so if you could do that lazily

00:58:13.309 --> 00:58:17.449
or something like that, that would be good,
and then the second one was...

00:58:17.449 --> 00:58:24.880
&gt;&gt;&gt; Just a tip to deal with font snapping
in after they loaded, the ugly hack of just

00:58:24.880 --> 00:58:26.549
setting a fixed type for everything.

00:58:26.549 --> 00:58:28.289
So at least it doesn't like reflow.

00:58:28.289 --> 00:58:31.039
&gt;&gt;Steve Souders: Yeah, yeah, you could do
that.

00:58:31.039 --> 00:58:32.950
Yes, another question.

00:58:32.950 --> 00:58:39.599
&gt;&gt;&gt; Yeah, you said mobile browsers don't support
most of those features yet, custom, you know,

00:58:39.599 --> 00:58:42.789
desktop browsers either, so how would we test
them?

00:58:42.789 --> 00:58:45.519
&gt;&gt;Steve Souders: I guess I wasn't clear.

00:58:45.519 --> 00:58:51.099
Everything I talked about is supported in
mobile browsers, pretty much, and, in fact,

00:58:51.099 --> 00:58:55.410
you're going to get -- I think that's another
reason why we're seeing more HTML5 stuff on

00:58:55.410 --> 00:59:02.690
mobile and desktop, because on desktop, there's
still a lot more lingering IE6, IE7 legacy

00:59:02.690 --> 00:59:07.119
browsers out there, so you're almost a little
safer using the cutting edge stuff on mobile

00:59:07.119 --> 00:59:08.170
than you are on desktop.

00:59:08.170 --> 00:59:15.309
The only thing I can think about is I thought
there was something -- well, the page visibility

00:59:15.309 --> 00:59:23.509
API is only in Chrome, but all the timing
stuff, local storage fonts, app cache, async

00:59:23.509 --> 00:59:26.740
and defer attributes, all of that is supported
on mobile too.

00:59:26.740 --> 00:59:27.940
&gt;&gt;&gt; Thank you.

00:59:27.940 --> 00:59:29.750
&gt;&gt;Steve Souders: Yeah.

00:59:29.750 --> 00:59:32.160
Okay, let's go here.

00:59:32.160 --> 00:59:33.970
&gt;&gt;&gt; Let's see here.

00:59:33.970 --> 00:59:42.130
You were talking about visibility and document.webkit
hidden and how that relates with click tracking

00:59:42.130 --> 00:59:43.539
and stuff like that.

00:59:43.539 --> 00:59:47.209
One click unsubscribes and e-mails and things
like that, is that another way that we can

00:59:47.209 --> 00:59:51.319
avoid being automatically unsubscribed?

00:59:51.319 --> 01:00:00.549
&gt;&gt;Steve Souders: Oh, oh, well, but how would
you -- how would you -- what's the scenario

01:00:00.549 --> 01:00:04.990
where you would render unsubscribed page without
the user seeing it?

01:00:04.990 --> 01:00:09.200
&gt;&gt;&gt; Well, if they're following links and pre-loading
in the background, you might follow --

01:00:09.200 --> 01:00:14.969
&gt;&gt;Steve Souders: Oh, yeah, the pre-rendering
I was talking about is the developer or user

01:00:14.969 --> 01:00:20.059
has explicitly asked to open a page, but we
can just know we can do it in the background.

01:00:20.059 --> 01:00:24.990
But, so, yeah, if you're crawling a page,
that could be something that you could do

01:00:24.990 --> 01:00:30.720
is to make sure not to -- you know, you could
instrument an unsubscribed link so that it

01:00:30.720 --> 01:00:33.229
only worked if the page was visible.

01:00:33.229 --> 01:00:34.229
Yeah.

01:00:34.229 --> 01:00:35.229
&gt;&gt;&gt; Thank you.

01:00:35.229 --> 01:00:36.299
&gt;&gt;Steve Souders: Yeah.

01:00:36.299 --> 01:00:40.989
&gt;&gt;&gt; What's your recommendation in terms of
moving the script tags physically to the bottom

01:00:40.989 --> 01:00:45.480
of the body tag versus using the defer script
tag that you described?

01:00:45.480 --> 01:00:50.739
&gt;&gt;Steve Souders: Yeah, I think both of those
work.

01:00:50.739 --> 01:00:56.010
One thing that we -- I only have a few seconds,
so one thing we don't have time to talk about

01:00:56.010 --> 01:01:02.789
is the importance of the onload event firing
as quickly as possible, so in both cases with

01:01:02.789 --> 01:01:07.940
defer and async and putting scripts at the
bottom, you're going to block the onload link,

01:01:07.940 --> 01:01:13.660
the onload event from firing, so really putting
scripts at the bottom is almost the same as

01:01:13.660 --> 01:01:16.009
doing defer.

01:01:16.009 --> 01:01:18.539
It really has more to do with kind of the
size of your team.

01:01:18.539 --> 01:01:24.180
A lot of times there's, you know, 20 or 200
people working on a property, and so it's

01:01:24.180 --> 01:01:30.180
hard to get the message out to put scripts
at the bottom or like someone's code is only

01:01:30.180 --> 01:01:35.759
going to be executed at the top and be really
hard to give them a foothold in the top and

01:01:35.759 --> 01:01:40.150
give them also a foothold in the bottom and
make sure that both of those are done in sync,

01:01:40.150 --> 01:01:46.049
so if the only place like the logging or metrics
team has a place to -- a foothold in the page

01:01:46.049 --> 01:01:51.440
is at the top, they can get the same behavior
using the defer attribute as just putting

01:01:51.440 --> 01:01:53.489
the script tag at the bottom.

01:01:53.489 --> 01:01:57.960
Putting the script tag at the bottom is another
lightweight way to avoid that blocking of

01:01:57.960 --> 01:01:59.579
the UI thread.

01:01:59.579 --> 01:02:00.579
Okay.

01:02:00.579 --> 01:02:01.579
So I should wrap up.

01:02:01.579 --> 01:02:02.579
Thank you very much.

01:02:02.579 --> 01:02:02.580
[ Applause ]

